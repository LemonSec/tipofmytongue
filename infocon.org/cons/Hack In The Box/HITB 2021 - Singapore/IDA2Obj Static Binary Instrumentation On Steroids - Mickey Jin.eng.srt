1
00:00:09,200 --> 00:00:11,360
hello everyone welcome to my

2
00:00:11,360 --> 00:00:12,639
presentation

3
00:00:12,639 --> 00:00:16,000
today i'd like to share my new tool

4
00:00:16,000 --> 00:00:17,480
named as

5
00:00:17,480 --> 00:00:19,199
ida2obj

6
00:00:19,199 --> 00:00:21,600
it is designed to

7
00:00:21,600 --> 00:00:23,840
implement the static binary

8
00:00:23,840 --> 00:00:26,720
instrumentation

9
00:00:27,760 --> 00:00:28,800
first

10
00:00:28,800 --> 00:00:32,399
let me make a simple self introduction

11
00:00:32,399 --> 00:00:35,360
i am a security researcher from trainer

12
00:00:35,360 --> 00:00:37,040
micro

13
00:00:37,040 --> 00:00:39,920
my main job is analyzing all kinds of

14
00:00:39,920 --> 00:00:42,960
mobile awareness platform before

15
00:00:42,960 --> 00:00:46,719
but now i many folks on the mac os

16
00:00:46,719 --> 00:00:49,360
and ios platform

17
00:00:49,360 --> 00:00:51,360
i started to dig zero day

18
00:00:51,360 --> 00:00:54,160
vulnerabilities since last year

19
00:00:54,160 --> 00:00:57,440
currently i have submitted more than 80

20
00:00:57,440 --> 00:00:59,760
vulnerabilities to zdi

21
00:00:59,760 --> 00:01:03,440
and got more than 50 cvs technologies

22
00:01:03,440 --> 00:01:05,680
from apple and google

23
00:01:05,680 --> 00:01:08,159
i also enjoy finding the root cause of

24
00:01:08,159 --> 00:01:10,080
some real issues

25
00:01:10,080 --> 00:01:12,479
by reversing and debugging

26
00:01:12,479 --> 00:01:16,320
edit pro is one of my favorite tools

27
00:01:16,320 --> 00:01:18,479
last but not the least

28
00:01:18,479 --> 00:01:21,119
welcome to follow me on twitter

29
00:01:21,119 --> 00:01:26,119
my twitter id is patch it

30
00:01:26,240 --> 00:01:29,439
this is the background of my topic

31
00:01:29,439 --> 00:01:32,640
nowadays many popular fathers are called

32
00:01:32,640 --> 00:01:34,479
courage guided

33
00:01:34,479 --> 00:01:37,119
including asl

34
00:01:37,119 --> 00:01:38,640
home fast

35
00:01:38,640 --> 00:01:41,119
scholar and so on

36
00:01:41,119 --> 00:01:43,360
it's a piece of cake

37
00:01:43,360 --> 00:01:45,600
for open source project

38
00:01:45,600 --> 00:01:48,320
because we can just add some special

39
00:01:48,320 --> 00:01:50,560
options to compile to do the

40
00:01:50,560 --> 00:01:52,399
instrumentation

41
00:01:52,399 --> 00:01:56,000
but how about the closest binaries

42
00:01:56,000 --> 00:01:58,560
tbi is the most choice

43
00:01:58,560 --> 00:02:02,240
such as dynamo rio frida scholar and so

44
00:02:02,240 --> 00:02:03,280
on

45
00:02:03,280 --> 00:02:06,560
but i think sbi is cooler

46
00:02:06,560 --> 00:02:09,598
and faster actually there are some

47
00:02:09,598 --> 00:02:12,160
existing sbi tools

48
00:02:12,160 --> 00:02:16,640
but it seems no perfect solutions yet

49
00:02:16,640 --> 00:02:19,680
and i have new ideas for the

50
00:02:19,680 --> 00:02:22,680
implementation

51
00:02:24,160 --> 00:02:24,959
so

52
00:02:24,959 --> 00:02:29,280
what is sbi or dbi

53
00:02:30,000 --> 00:02:32,400
the phone name is static

54
00:02:32,400 --> 00:02:33,840
or dynamic

55
00:02:33,840 --> 00:02:37,480
binary instrumentation

56
00:02:37,519 --> 00:02:40,319
instrumentation means the act of adding

57
00:02:40,319 --> 00:02:41,519
s-code

58
00:02:41,519 --> 00:02:42,319
to

59
00:02:42,319 --> 00:02:43,920
a program

60
00:02:43,920 --> 00:02:46,080
to measure its performance

61
00:02:46,080 --> 00:02:48,720
diagnose errors and write trace

62
00:02:48,720 --> 00:02:51,720
information

63
00:02:52,000 --> 00:02:55,040
binary means analyzing program at

64
00:02:55,040 --> 00:02:58,239
machine level and machine code level

65
00:02:58,239 --> 00:03:02,480
without having access to the source code

66
00:03:02,879 --> 00:03:06,879
dynamic means analyzing program at

67
00:03:06,879 --> 00:03:09,518
runtime

68
00:03:09,599 --> 00:03:12,640
static means analyzing program at a

69
00:03:12,640 --> 00:03:16,000
compile or build time

70
00:03:16,000 --> 00:03:18,800
we can see the compiler instruction as

71
00:03:18,800 --> 00:03:21,599
the special case of sbi

72
00:03:21,599 --> 00:03:24,560
so sbi is as fast as compile

73
00:03:24,560 --> 00:03:26,000
instrumentation

74
00:03:26,000 --> 00:03:27,519
in syria

75
00:03:27,519 --> 00:03:29,599
next i will describe

76
00:03:29,599 --> 00:03:35,040
how i implement the sbi step by step

77
00:03:35,200 --> 00:03:36,879
well

78
00:03:36,879 --> 00:03:40,480
let's start from scratch now

79
00:03:41,200 --> 00:03:44,000
this is my first idea

80
00:03:44,000 --> 00:03:46,480
we can load the binary into adder pro

81
00:03:46,480 --> 00:03:47,680
first

82
00:03:47,680 --> 00:03:50,640
and wait for the auto analysis

83
00:03:50,640 --> 00:03:53,439
when the analysis is finished

84
00:03:53,439 --> 00:03:57,200
export it to the assembly file

85
00:03:57,200 --> 00:03:59,760
which can be seen as the source code at

86
00:03:59,760 --> 00:04:02,239
a assembly level

87
00:04:02,239 --> 00:04:03,439
then

88
00:04:03,439 --> 00:04:05,599
we can simulate the instrumentation

89
00:04:05,599 --> 00:04:08,400
process of compiler

90
00:04:08,400 --> 00:04:09,200
so

91
00:04:09,200 --> 00:04:13,040
we got an instrumented assembly file

92
00:04:13,040 --> 00:04:16,000
finally we can build the assembly file

93
00:04:16,000 --> 00:04:19,600
to generate a new binary

94
00:04:21,279 --> 00:04:23,919
this is my first solution

95
00:04:23,919 --> 00:04:26,479
just for pe binaries

96
00:04:26,479 --> 00:04:30,000
i implemented another tool adapted as

97
00:04:30,000 --> 00:04:32,639
ida2 masm

98
00:04:32,639 --> 00:04:34,880
the input and output are both te

99
00:04:34,880 --> 00:04:36,800
binaries

100
00:04:36,800 --> 00:04:39,600
and the assembler is the

101
00:04:39,600 --> 00:04:43,840
masm from microsoft

102
00:04:44,639 --> 00:04:48,639
now let's export the assembly file

103
00:04:48,639 --> 00:04:51,520
we can export all instructions

104
00:04:51,520 --> 00:04:54,800
to one assembly file by using add-on

105
00:04:54,800 --> 00:04:59,520
menu file produce file create asm file

106
00:04:59,520 --> 00:05:00,960
however

107
00:05:00,960 --> 00:05:05,280
mma sm may cost many hours or days to

108
00:05:05,280 --> 00:05:06,320
discern

109
00:05:06,320 --> 00:05:08,080
example one

110
00:05:08,080 --> 00:05:10,960
asm file

111
00:05:10,960 --> 00:05:14,000
luckily we can use the script api

112
00:05:14,000 --> 00:05:18,960
to export from an address range

113
00:05:22,000 --> 00:05:25,680
one more tip is before exporting

114
00:05:25,680 --> 00:05:30,479
we should use the item menu once all

115
00:05:32,240 --> 00:05:33,840
as just said

116
00:05:33,840 --> 00:05:37,440
masm has difficulty to process one big

117
00:05:37,440 --> 00:05:38,400
file

118
00:05:38,400 --> 00:05:42,880
so we must slip them into small ones

119
00:05:42,880 --> 00:05:47,199
splitting by segments is a good choice

120
00:05:48,479 --> 00:05:52,160
we should manually load all segments

121
00:05:52,160 --> 00:05:54,240
including header

122
00:05:54,240 --> 00:05:57,680
and the resource segment

123
00:05:57,840 --> 00:06:01,759
then eliminate all segments to dump

124
00:06:01,759 --> 00:06:04,960
use that for header and the relocation

125
00:06:04,960 --> 00:06:06,479
segment

126
00:06:06,479 --> 00:06:09,280
segments may share the same name

127
00:06:09,280 --> 00:06:12,000
so just append their address to be

128
00:06:12,000 --> 00:06:13,360
unique

129
00:06:13,360 --> 00:06:16,639
after the segment split splitted

130
00:06:16,639 --> 00:06:19,840
we need to process symbol

131
00:06:19,840 --> 00:06:24,240
in masm we can use the keyword public

132
00:06:24,240 --> 00:06:25,840
to expose

133
00:06:25,840 --> 00:06:27,680
a symbol

134
00:06:27,680 --> 00:06:31,199
to linker explicitly

135
00:06:31,199 --> 00:06:34,319
especially for the labels

136
00:06:34,319 --> 00:06:38,960
we need to note the double columns

137
00:06:40,639 --> 00:06:42,800
and we can also

138
00:06:42,800 --> 00:06:46,000
declare the external symbols by using

139
00:06:46,000 --> 00:06:49,840
the keyword extern

140
00:06:52,000 --> 00:06:55,599
here is the symbol example

141
00:06:55,680 --> 00:06:58,479
we can see there is a cross reference

142
00:06:58,479 --> 00:07:02,560
from the pdf segment to the text segment

143
00:07:02,560 --> 00:07:05,520
then in the predator assembly file

144
00:07:05,520 --> 00:07:07,360
there is a declaration

145
00:07:07,360 --> 00:07:10,080
and in the text assembly file there is a

146
00:07:10,080 --> 00:07:12,160
public keyword

147
00:07:12,160 --> 00:07:17,000
notice the double columns here

148
00:07:18,639 --> 00:07:22,800
so this is the processing logic

149
00:07:22,800 --> 00:07:26,319
first scan all the item

150
00:07:26,319 --> 00:07:30,400
from minimum address to maximum address

151
00:07:30,400 --> 00:07:33,120
for each item guest or

152
00:07:33,120 --> 00:07:36,560
cross reference list to its address

153
00:07:36,560 --> 00:07:39,360
if there is no cross reference

154
00:07:39,360 --> 00:07:41,599
script for the item

155
00:07:41,599 --> 00:07:45,280
otherwise make the name public

156
00:07:45,280 --> 00:07:47,599
for each item in the cross reference

157
00:07:47,599 --> 00:07:48,800
list

158
00:07:48,800 --> 00:07:52,560
if it is not in the same segment

159
00:07:52,560 --> 00:07:58,440
add an extern declaration for that item

160
00:08:00,800 --> 00:08:03,440
after got the assembly file

161
00:08:03,440 --> 00:08:05,440
we can insert some

162
00:08:05,440 --> 00:08:07,680
assembly instructions to do the

163
00:08:07,680 --> 00:08:09,520
instrumentation

164
00:08:09,520 --> 00:08:11,960
here is the code to find the

165
00:08:11,960 --> 00:08:14,960
instrumentation points

166
00:08:14,960 --> 00:08:19,280
scan all functions from segments

167
00:08:19,280 --> 00:08:24,240
for each function scan all code blocks

168
00:08:24,240 --> 00:08:27,199
for each code block make a comment

169
00:08:27,199 --> 00:08:31,039
instrument here as a hint

170
00:08:33,839 --> 00:08:35,760
during the post processing of the

171
00:08:35,760 --> 00:08:38,479
assembly files

172
00:08:38,479 --> 00:08:40,479
insert the trampoline instructions

173
00:08:40,479 --> 00:08:42,559
before the comment string instrument

174
00:08:42,559 --> 00:08:44,880
here

175
00:08:45,920 --> 00:08:49,440
now is the time to resemble

176
00:08:49,440 --> 00:08:52,720
which is the most difficult stage

177
00:08:52,720 --> 00:08:54,959
there are too many

178
00:08:54,959 --> 00:08:57,279
grammar errors to handle

179
00:08:57,279 --> 00:09:00,640
and this cost me lots of time

180
00:09:00,640 --> 00:09:03,200
i have written a passing script to to

181
00:09:03,200 --> 00:09:06,399
them all during the assembly file

182
00:09:06,399 --> 00:09:08,880
pre-processing stage

183
00:09:08,880 --> 00:09:11,200
and there is another limitation for the

184
00:09:11,200 --> 00:09:12,399
simulants

185
00:09:12,399 --> 00:09:15,519
so i have to rename the long name to a

186
00:09:15,519 --> 00:09:17,680
short one

187
00:09:17,680 --> 00:09:20,880
masm is too ancient

188
00:09:20,880 --> 00:09:23,440
maybe i should consider

189
00:09:23,440 --> 00:09:26,959
try other assemblers

190
00:09:28,480 --> 00:09:30,880
there is a longer list to tune the

191
00:09:30,880 --> 00:09:34,880
grammar here is just a small part

192
00:09:34,880 --> 00:09:38,480
note that i have to change all the short

193
00:09:38,480 --> 00:09:39,440
jumps

194
00:09:39,440 --> 00:09:42,480
into the long jump

195
00:09:42,480 --> 00:09:45,040
because it may break the short jump

196
00:09:45,040 --> 00:09:46,959
range limitation after the

197
00:09:46,959 --> 00:09:49,959
instrumentation

198
00:09:50,959 --> 00:09:54,560
now we got some obj files from the

199
00:09:54,560 --> 00:09:56,800
assembly files now

200
00:09:56,800 --> 00:09:59,200
it's time to link them

201
00:09:59,200 --> 00:10:01,440
all

202
00:10:02,079 --> 00:10:04,640
this is the key issue at the linking

203
00:10:04,640 --> 00:10:06,240
stage

204
00:10:06,240 --> 00:10:09,440
the api symbols from the imports table

205
00:10:09,440 --> 00:10:11,040
are undefined

206
00:10:11,040 --> 00:10:14,560
we must link with the properly files

207
00:10:14,560 --> 00:10:15,440
but

208
00:10:15,440 --> 00:10:17,760
but for some special api

209
00:10:17,760 --> 00:10:19,920
i don't know what's the leap file to

210
00:10:19,920 --> 00:10:21,200
language

211
00:10:21,200 --> 00:10:23,600
maybe some import symbols are from

212
00:10:23,600 --> 00:10:25,680
private sdks

213
00:10:25,680 --> 00:10:28,720
while we don't have the private leaps

214
00:10:28,720 --> 00:10:31,440
so we must generate the lib files

215
00:10:31,440 --> 00:10:34,399
by ourselves

216
00:10:34,800 --> 00:10:38,560
fortunately i found the lib.exe

217
00:10:38,560 --> 00:10:41,040
from virus studio toolkit have the

218
00:10:41,040 --> 00:10:44,160
function to generate lib files

219
00:10:44,160 --> 00:10:47,200
according to the def file

220
00:10:47,200 --> 00:10:50,000
so this is the solution

221
00:10:50,000 --> 00:10:53,360
for the link issue

222
00:10:54,240 --> 00:10:57,440
i just illuminate all important models

223
00:10:57,440 --> 00:11:00,480
and create a def file for each model and

224
00:11:00,480 --> 00:11:01,920
write the

225
00:11:01,920 --> 00:11:05,040
import symbols into the def file

226
00:11:05,040 --> 00:11:08,399
finally call leap.exe to generate the

227
00:11:08,399 --> 00:11:10,560
lib file from

228
00:11:10,560 --> 00:11:14,119
df file

229
00:11:15,760 --> 00:11:18,399
after the linking stage we got a new

230
00:11:18,399 --> 00:11:19,760
binary

231
00:11:19,760 --> 00:11:22,800
but if there is one more step to run

232
00:11:22,800 --> 00:11:25,680
we need to patch the pe header

233
00:11:25,680 --> 00:11:28,800
such as this directory

234
00:11:28,800 --> 00:11:30,079
for example

235
00:11:30,079 --> 00:11:31,839
we need to patch

236
00:11:31,839 --> 00:11:33,760
export date directory

237
00:11:33,760 --> 00:11:36,480
to make it support to the location of

238
00:11:36,480 --> 00:11:39,760
the symbol export dir

239
00:11:39,760 --> 00:11:42,800
and we need to patch exception data

240
00:11:42,800 --> 00:11:45,279
directory to point

241
00:11:45,279 --> 00:11:48,399
to the location of the symbol

242
00:11:48,399 --> 00:11:51,519
exception dir and so on

243
00:11:51,519 --> 00:11:54,480
and then we need to fix the data entry

244
00:11:54,480 --> 00:11:57,120
in the resource segment

245
00:11:57,120 --> 00:11:59,519
the data entry value is relative to

246
00:11:59,519 --> 00:12:02,639
image-based address

247
00:12:03,200 --> 00:12:06,800
all of these fixed operations are in one

248
00:12:06,800 --> 00:12:07,839
script

249
00:12:07,839 --> 00:12:11,079
for automation

250
00:12:12,639 --> 00:12:16,160
then we can draw and test

251
00:12:16,160 --> 00:12:19,760
but i got some crashes

252
00:12:20,800 --> 00:12:23,440
there are three kinds of issues that

253
00:12:23,440 --> 00:12:25,680
lead to the crashes

254
00:12:25,680 --> 00:12:27,200
all because of

255
00:12:27,200 --> 00:12:31,519
the incorrect analysis result from ida

256
00:12:31,519 --> 00:12:34,880
first is the unrecognized pointer

257
00:12:34,880 --> 00:12:39,360
such as dq offset a symbol

258
00:12:39,360 --> 00:12:42,000
the second is unrecognized image-based

259
00:12:42,000 --> 00:12:47,839
relative value such as ddrva a symbol

260
00:12:47,839 --> 00:12:50,000
the third is the unrecognized

261
00:12:50,000 --> 00:12:52,959
function-based relative value

262
00:12:52,959 --> 00:12:55,760
it is a compression encoded value for

263
00:12:55,760 --> 00:12:58,639
the exception handling

264
00:12:58,639 --> 00:13:01,279
i will talk how to fix these issues

265
00:13:01,279 --> 00:13:04,279
later

266
00:13:06,079 --> 00:13:08,800
either to msm

267
00:13:08,800 --> 00:13:11,839
now works fine

268
00:13:12,639 --> 00:13:14,720
but it's not suitable for full

269
00:13:14,720 --> 00:13:17,279
automation

270
00:13:17,279 --> 00:13:19,360
due to some corner case of grammar

271
00:13:19,360 --> 00:13:21,839
tuning

272
00:13:23,680 --> 00:13:28,479
thinking deeper i have another idea

273
00:13:28,880 --> 00:13:31,680
let's think of the essence

274
00:13:31,680 --> 00:13:35,360
a binary can be divided into two parts

275
00:13:35,360 --> 00:13:38,079
the code and the date

276
00:13:38,079 --> 00:13:39,600
for the code part

277
00:13:39,600 --> 00:13:43,600
there are two kinds of instructions

278
00:13:44,000 --> 00:13:47,199
one is the pure machine code

279
00:13:47,199 --> 00:13:50,160
such as push

280
00:13:50,160 --> 00:13:52,719
or move

281
00:13:53,199 --> 00:13:56,800
the other can is like this

282
00:13:56,800 --> 00:14:00,720
jump a label call a function

283
00:14:00,720 --> 00:14:01,680
and

284
00:14:01,680 --> 00:14:04,079
reference a data

285
00:14:04,079 --> 00:14:06,560
segment

286
00:14:07,519 --> 00:14:12,160
further data patch is similar

287
00:14:12,399 --> 00:14:15,199
the pure machine code has no cross

288
00:14:15,199 --> 00:14:16,560
reference

289
00:14:16,560 --> 00:14:21,199
which means it can be dumped directly

290
00:14:21,839 --> 00:14:24,720
the retina instructions has

291
00:14:24,720 --> 00:14:26,240
cross reference

292
00:14:26,240 --> 00:14:29,199
which means it needs to be fixed for the

293
00:14:29,199 --> 00:14:31,839
symbol reference

294
00:14:33,120 --> 00:14:36,560
therefore one binary can be divided into

295
00:14:36,560 --> 00:14:37,680
two parts

296
00:14:37,680 --> 00:14:40,480
the green part and the red part

297
00:14:40,480 --> 00:14:43,760
the green patch can be dumped directly

298
00:14:43,760 --> 00:14:46,560
however the rather part has simple

299
00:14:46,560 --> 00:14:48,240
references

300
00:14:48,240 --> 00:14:52,360
which need to be relocated

301
00:14:52,959 --> 00:14:55,040
so the key point

302
00:14:55,040 --> 00:14:59,360
of sbi implementation is finding out all

303
00:14:59,360 --> 00:15:01,760
the cross references

304
00:15:01,760 --> 00:15:05,199
which are represented by the red errors

305
00:15:05,199 --> 00:15:07,120
in the picture

306
00:15:07,120 --> 00:15:10,240
and the main task is to fix them all

307
00:15:10,240 --> 00:15:13,240
correctly

308
00:15:15,360 --> 00:15:18,800
so this is my second idea

309
00:15:18,800 --> 00:15:21,680
scan all the instructions from minimal

310
00:15:21,680 --> 00:15:24,399
address to maximum address

311
00:15:24,399 --> 00:15:27,360
and record their addresses as the old

312
00:15:27,360 --> 00:15:30,560
coordinate system

313
00:15:31,199 --> 00:15:33,120
then during the scanning

314
00:15:33,120 --> 00:15:36,079
output the machine code for ins for each

315
00:15:36,079 --> 00:15:37,759
instruction

316
00:15:37,759 --> 00:15:41,759
if the instruction has no reference

317
00:15:41,759 --> 00:15:44,880
output is motion code directly

318
00:15:44,880 --> 00:15:46,240
otherwise

319
00:15:46,240 --> 00:15:49,680
output is the op code first

320
00:15:49,680 --> 00:15:54,240
then output dummy bytes as a placeholder

321
00:15:54,240 --> 00:15:56,720
and record its address and reference

322
00:15:56,720 --> 00:16:00,639
type into a fixed table

323
00:16:00,959 --> 00:16:03,040
during the scanning

324
00:16:03,040 --> 00:16:05,839
insert the trampoline instructions

325
00:16:05,839 --> 00:16:09,199
before the instruction with the comment

326
00:16:09,199 --> 00:16:10,399
hint

327
00:16:10,399 --> 00:16:13,199
instrument here

328
00:16:13,680 --> 00:16:15,440
after the scanning

329
00:16:15,440 --> 00:16:18,720
the size of the temporal output binary

330
00:16:18,720 --> 00:16:22,720
file will be larger

331
00:16:22,720 --> 00:16:26,079
then we will compute the new coordinates

332
00:16:26,079 --> 00:16:28,480
for each instruction in the temporal

333
00:16:28,480 --> 00:16:29,759
binary file

334
00:16:29,759 --> 00:16:32,480
and record them as the new

335
00:16:32,480 --> 00:16:36,120
coordinate system

336
00:16:37,680 --> 00:16:40,560
then we need to fix the placeholder

337
00:16:40,560 --> 00:16:42,880
according to the fixed table and the new

338
00:16:42,880 --> 00:16:45,680
coordinate system

339
00:16:45,680 --> 00:16:49,360
finally we got a new instrumented binary

340
00:16:49,360 --> 00:16:51,839
file

341
00:16:53,120 --> 00:16:56,480
next let's review this idea

342
00:16:56,480 --> 00:17:00,160
it rewrites the binary directory

343
00:17:00,160 --> 00:17:03,360
regardless of the file format

344
00:17:03,360 --> 00:17:06,640
so it could be cross platform

345
00:17:06,640 --> 00:17:08,319
in theory

346
00:17:08,319 --> 00:17:10,559
the key point is fixing all the symbol

347
00:17:10,559 --> 00:17:14,319
references or regulate regulations

348
00:17:14,319 --> 00:17:16,559
and it seems too complicated to

349
00:17:16,559 --> 00:17:19,559
implement

350
00:17:22,000 --> 00:17:27,119
let's thinking of either to masm again

351
00:17:27,119 --> 00:17:30,640
what does the masm do

352
00:17:30,640 --> 00:17:34,640
what happens during the build process

353
00:17:35,440 --> 00:17:38,240
why don't have to fix the

354
00:17:38,240 --> 00:17:40,960
references manually during the process

355
00:17:40,960 --> 00:17:45,080
of ida to masm

356
00:17:49,679 --> 00:17:51,679
msm just

357
00:17:51,679 --> 00:17:53,679
translates the

358
00:17:53,679 --> 00:17:56,720
assembly to machine code

359
00:17:56,720 --> 00:18:01,840
and adds the symbols to the obj file

360
00:18:03,120 --> 00:18:06,320
actually it is the linker that helps to

361
00:18:06,320 --> 00:18:08,880
fix the symbol reference

362
00:18:08,880 --> 00:18:12,160
in the final binary

363
00:18:13,039 --> 00:18:15,919
so can i directly

364
00:18:15,919 --> 00:18:18,720
generate the obj files and make the

365
00:18:18,720 --> 00:18:19,679
linker

366
00:18:19,679 --> 00:18:23,039
help me to do the fixed again

367
00:18:23,039 --> 00:18:26,480
this will bypass the dmasdm

368
00:18:26,480 --> 00:18:29,440
and avoid fixing the symbol reference

369
00:18:29,440 --> 00:18:31,840
manually

370
00:18:31,840 --> 00:18:35,760
so my second solution comes

371
00:18:35,919 --> 00:18:40,799
the tool ida2obj is used to do this

372
00:18:40,799 --> 00:18:43,039
the difference from the first solution

373
00:18:43,039 --> 00:18:45,120
is in the middle part

374
00:18:45,120 --> 00:18:48,960
i will directly dump the obj files

375
00:18:48,960 --> 00:18:53,480
instead of the assembly files

376
00:18:56,799 --> 00:19:01,200
obj file is commons object file format

377
00:19:01,200 --> 00:19:05,679
and this is the file structure

378
00:19:05,679 --> 00:19:08,320
first is the file header

379
00:19:08,320 --> 00:19:10,960
and option header the instruction

380
00:19:10,960 --> 00:19:12,720
headers

381
00:19:12,720 --> 00:19:15,120
the row date is used to

382
00:19:15,120 --> 00:19:18,240
store the executable code and the

383
00:19:18,240 --> 00:19:21,039
initialize the date

384
00:19:21,039 --> 00:19:22,080
then

385
00:19:22,080 --> 00:19:25,440
is the relocation information

386
00:19:25,440 --> 00:19:28,080
symbol table and string table are at the

387
00:19:28,080 --> 00:19:31,039
end of the file

388
00:19:33,120 --> 00:19:36,160
after making sense the file structure

389
00:19:36,160 --> 00:19:39,360
we can write a tool to generate the obj

390
00:19:39,360 --> 00:19:40,799
file

391
00:19:40,799 --> 00:19:44,240
luckily i found a ripple on the github

392
00:19:44,240 --> 00:19:46,799
which meets my demand

393
00:19:46,799 --> 00:19:51,400
avoid reinventing the wheels

394
00:19:52,000 --> 00:19:53,280
the install

395
00:19:53,280 --> 00:19:56,240
process is symbol just use the pip

396
00:19:56,240 --> 00:19:58,080
command

397
00:19:58,080 --> 00:20:01,120
and here is the symbol tutorial for the

398
00:20:01,120 --> 00:20:04,239
python library

399
00:20:04,559 --> 00:20:08,159
first create a module object first

400
00:20:08,159 --> 00:20:10,640
and then create a section

401
00:20:10,640 --> 00:20:14,159
write the machine code to the section

402
00:20:14,159 --> 00:20:17,520
then add the section to the model

403
00:20:17,520 --> 00:20:18,480
next

404
00:20:18,480 --> 00:20:20,640
create a symbol record

405
00:20:20,640 --> 00:20:23,919
and set its value to point to the offset

406
00:20:23,919 --> 00:20:26,480
inside the section

407
00:20:26,480 --> 00:20:29,440
here is zero

408
00:20:29,760 --> 00:20:30,559
then

409
00:20:30,559 --> 00:20:35,039
add the symbol to the module two

410
00:20:35,039 --> 00:20:36,159
finally

411
00:20:36,159 --> 00:20:38,400
serialize the module

412
00:20:38,400 --> 00:20:42,000
object into the test.obj file

413
00:20:42,000 --> 00:20:46,320
next i implement a class segment

414
00:20:46,320 --> 00:20:50,000
to encapsulate some primitives

415
00:20:50,000 --> 00:20:53,360
string method is used to add a ask a

416
00:20:53,360 --> 00:20:54,480
string

417
00:20:54,480 --> 00:20:57,919
to the string table

418
00:20:57,919 --> 00:21:00,720
and a single method is used to add a

419
00:21:00,720 --> 00:21:03,280
symbol record it will call the add

420
00:21:03,280 --> 00:21:05,840
string method

421
00:21:05,840 --> 00:21:08,240
add the relocation method is used to add

422
00:21:08,240 --> 00:21:11,200
a relocation record

423
00:21:11,200 --> 00:21:13,600
public symbol method and a reference

424
00:21:13,600 --> 00:21:16,799
symbol method will call the method

425
00:21:16,799 --> 00:21:19,120
the above

426
00:21:19,120 --> 00:21:22,880
the class example has an abstract method

427
00:21:22,880 --> 00:21:23,760
field

428
00:21:23,760 --> 00:21:25,200
data

429
00:21:25,200 --> 00:21:28,080
close the example and date example at

430
00:21:28,080 --> 00:21:30,880
the start classes of the second number

431
00:21:30,880 --> 00:21:32,080
they just

432
00:21:32,080 --> 00:21:35,200
override the first data method to

433
00:21:35,200 --> 00:21:38,000
implement the dumping logic

434
00:21:38,000 --> 00:21:40,640
both the dumpers have the similar

435
00:21:40,640 --> 00:21:44,120
dumping flow

436
00:21:44,559 --> 00:21:47,600
it iterates all the instructions inside

437
00:21:47,600 --> 00:21:50,400
the segment

438
00:21:50,400 --> 00:21:54,320
stack by the current item size

439
00:21:54,320 --> 00:21:57,120
and if the current item has a name it

440
00:21:57,120 --> 00:21:59,760
will publicate

441
00:21:59,760 --> 00:22:02,720
then it will compute the cross reference

442
00:22:02,720 --> 00:22:03,919
list

443
00:22:03,919 --> 00:22:06,880
if there is no cross reference it will

444
00:22:06,880 --> 00:22:11,120
call the api get many bytes to dump the

445
00:22:11,120 --> 00:22:13,360
data directly

446
00:22:13,360 --> 00:22:16,320
if there is one cross reference

447
00:22:16,320 --> 00:22:18,799
it will dump the

448
00:22:18,799 --> 00:22:20,880
symbol

449
00:22:20,880 --> 00:22:23,200
with this reference type

450
00:22:23,200 --> 00:22:24,640
and if there are

451
00:22:24,640 --> 00:22:27,760
if there are multiple cross references

452
00:22:27,760 --> 00:22:30,240
it will dump many symbols

453
00:22:30,240 --> 00:22:32,480
and they'll cross with the reference

454
00:22:32,480 --> 00:22:34,799
type

455
00:22:37,200 --> 00:22:39,760
during the dumping process

456
00:22:39,760 --> 00:22:42,240
if it meets the hint comment string

457
00:22:42,240 --> 00:22:43,760
instrument here

458
00:22:43,760 --> 00:22:46,080
it will insert the base

459
00:22:46,080 --> 00:22:49,840
code of the gemini instructions

460
00:22:50,000 --> 00:22:52,159
and then increment the new address

461
00:22:52,159 --> 00:22:55,159
pointer

462
00:22:57,280 --> 00:23:00,559
it will use the link.exe

463
00:23:00,559 --> 00:23:03,360
along with the virus studio

464
00:23:03,360 --> 00:23:06,000
2019

465
00:23:06,000 --> 00:23:08,640
there are several arguments for the bat

466
00:23:08,640 --> 00:23:10,240
command

467
00:23:10,240 --> 00:23:14,320
the first argument is the module name

468
00:23:14,320 --> 00:23:17,520
the second argument is the output binary

469
00:23:17,520 --> 00:23:18,799
type

470
00:23:18,799 --> 00:23:21,280
it's a dynamic library

471
00:23:21,280 --> 00:23:22,480
an application

472
00:23:22,480 --> 00:23:25,440
or kernel driver

473
00:23:25,679 --> 00:23:30,080
the third argument is the payload type

474
00:23:30,080 --> 00:23:34,840
choose af your payload or trace

475
00:23:34,840 --> 00:23:38,159
payload the remain arguments are

476
00:23:38,159 --> 00:23:41,440
optional to the linker

477
00:23:42,240 --> 00:23:44,799
now it's time to integrate with a wing

478
00:23:44,799 --> 00:23:47,360
afl

479
00:23:48,080 --> 00:23:51,200
the key point is passing the bitmap area

480
00:23:51,200 --> 00:23:54,960
to the instrumented binary

481
00:23:54,960 --> 00:23:56,320
afl

482
00:23:56,320 --> 00:23:59,360
used the api clarify mapping to create

483
00:23:59,360 --> 00:24:01,440
the shared memory

484
00:24:01,440 --> 00:24:04,480
harness user api open file mapping to

485
00:24:04,480 --> 00:24:06,960
fetch the shared memory

486
00:24:06,960 --> 00:24:08,960
i just do some

487
00:24:08,960 --> 00:24:12,960
modifications from a good example

488
00:24:16,799 --> 00:24:18,640
this is the

489
00:24:18,640 --> 00:24:22,799
symbol architecture diagram

490
00:24:25,279 --> 00:24:28,720
one more tip is enlarging the

491
00:24:28,720 --> 00:24:30,080
math size

492
00:24:30,080 --> 00:24:32,480
when you instrumenting

493
00:24:32,480 --> 00:24:35,279
more modules

494
00:24:38,720 --> 00:24:41,919
the function afl may be log

495
00:24:41,919 --> 00:24:45,520
is implemented in afl payload dot

496
00:24:45,520 --> 00:24:47,840
assembly

497
00:24:48,320 --> 00:24:50,320
which will be linked into the target

498
00:24:50,320 --> 00:24:51,440
binary

499
00:24:51,440 --> 00:24:54,240
and will be called as each code block

500
00:24:54,240 --> 00:24:57,279
to collect the code carriage

501
00:24:57,279 --> 00:25:00,960
the main algorithm is the same as the

502
00:25:00,960 --> 00:25:04,080
traditional afl further

503
00:25:04,080 --> 00:25:07,600
by the way it supports the multiple

504
00:25:07,600 --> 00:25:11,918
threads and multiple modules

505
00:25:12,880 --> 00:25:15,840
as their previous locations

506
00:25:15,840 --> 00:25:18,080
is an array

507
00:25:18,080 --> 00:25:20,480
with the thread thread id

508
00:25:20,480 --> 00:25:23,279
as is in depth

509
00:25:23,279 --> 00:25:26,559
and will be cleared to zero before

510
00:25:26,559 --> 00:25:27,840
each fast

511
00:25:27,840 --> 00:25:30,799
iteration loop

512
00:25:31,039 --> 00:25:34,799
as your area pointer is exported

513
00:25:34,799 --> 00:25:37,360
and will be set to the shared memory

514
00:25:37,360 --> 00:25:41,158
address by the harness

515
00:25:42,480 --> 00:25:45,600
the harness is simple enough

516
00:25:45,600 --> 00:25:48,240
initial function is used to do some

517
00:25:48,240 --> 00:25:51,679
initial initializations before fuzzing

518
00:25:51,679 --> 00:25:54,000
it set up the shown memory and named

519
00:25:54,000 --> 00:25:55,200
pipe

520
00:25:55,200 --> 00:25:58,240
pre and post function are called in each

521
00:25:58,240 --> 00:26:01,760
fuzzing iteration loop

522
00:26:03,600 --> 00:26:05,840
here is the code to fetch the shared

523
00:26:05,840 --> 00:26:11,000
memory address into a global pointer

524
00:26:11,679 --> 00:26:14,960
in its target function we'll set the afl

525
00:26:14,960 --> 00:26:17,039
error pointer to the shared memory

526
00:26:17,039 --> 00:26:21,120
address for each target module

527
00:26:21,520 --> 00:26:22,480
now

528
00:26:22,480 --> 00:26:25,360
it's demo time i will play the video

529
00:26:25,360 --> 00:26:28,399
recorded before

530
00:26:30,720 --> 00:26:33,760
this is the demo for my tour namely as

531
00:26:33,760 --> 00:26:36,480
ida 2 obj

532
00:26:36,480 --> 00:26:39,520
first clone the code

533
00:26:39,520 --> 00:26:42,559
the ripple is private now i will

534
00:26:42,559 --> 00:26:45,600
open source it later

535
00:26:45,600 --> 00:26:50,400
i just put the code on the desktop

536
00:26:50,400 --> 00:26:54,320
then create a workspace

537
00:26:55,360 --> 00:26:58,559
such as demo

538
00:27:00,559 --> 00:27:02,559
then copy the

539
00:27:02,559 --> 00:27:04,240
target binary

540
00:27:04,240 --> 00:27:07,520
which you want to fast

541
00:27:07,520 --> 00:27:10,159
to the workspace

542
00:27:10,159 --> 00:27:12,640
and then load it

543
00:27:12,640 --> 00:27:14,640
into the

544
00:27:14,640 --> 00:27:17,360
edit pro

545
00:27:18,720 --> 00:27:21,600
note that you should choose

546
00:27:21,600 --> 00:27:26,039
menu load and another resources

547
00:27:38,880 --> 00:27:40,960
it asks me

548
00:27:40,960 --> 00:27:44,240
whether to load the pdb file

549
00:27:44,240 --> 00:27:47,240
yes

550
00:27:53,760 --> 00:27:54,880
the

551
00:27:54,880 --> 00:27:59,320
tour still works without pdb

552
00:28:05,679 --> 00:28:09,679
okay auto analysis is done

553
00:28:09,760 --> 00:28:10,720
then

554
00:28:10,720 --> 00:28:12,480
execute my

555
00:28:12,480 --> 00:28:15,480
script

556
00:28:16,320 --> 00:28:19,919
first i want to execute the

557
00:28:19,919 --> 00:28:22,640
leave impulse dot py

558
00:28:22,640 --> 00:28:27,000
to generate the leap files

559
00:28:32,960 --> 00:28:33,840
now

560
00:28:33,840 --> 00:28:37,120
let's check the live files

561
00:28:39,600 --> 00:28:41,039
we can see

562
00:28:41,039 --> 00:28:42,080
there are

563
00:28:42,080 --> 00:28:45,039
32 new files

564
00:28:45,039 --> 00:28:49,679
which corresponding to the impulse table

565
00:28:54,000 --> 00:28:57,720
check this one

566
00:29:10,399 --> 00:29:14,240
these are the important symbols from the

567
00:29:14,240 --> 00:29:16,960
import table

568
00:29:17,120 --> 00:29:18,399
next

569
00:29:18,399 --> 00:29:22,000
execute the script to dump the obj files

570
00:29:22,000 --> 00:29:25,000
now

571
00:29:30,240 --> 00:29:34,520
selectmen or type

572
00:30:03,919 --> 00:30:06,480
okay the pump

573
00:30:06,480 --> 00:30:09,039
is finished now

574
00:30:09,039 --> 00:30:13,200
let's check the bobby device

575
00:30:21,360 --> 00:30:25,440
yes let's link these obj files

576
00:30:25,440 --> 00:30:29,240
into a new binary

577
00:30:49,039 --> 00:30:50,799
just to use the

578
00:30:50,799 --> 00:30:53,600
link command

579
00:30:56,799 --> 00:30:59,440
we will see

580
00:30:59,440 --> 00:31:00,559
the

581
00:31:00,559 --> 00:31:04,080
new binary is generated

582
00:31:04,080 --> 00:31:06,799
more step is to patch the

583
00:31:06,799 --> 00:31:09,279
binary

584
00:31:13,440 --> 00:31:15,760
okay

585
00:31:16,080 --> 00:31:21,600
the patch is done let's note it again

586
00:31:31,519 --> 00:31:34,240
then we will try the new generated

587
00:31:34,240 --> 00:31:35,840
binary

588
00:31:35,840 --> 00:31:39,480
for buzzing

589
00:31:46,880 --> 00:31:50,399
just back half this one

590
00:31:53,120 --> 00:31:56,600
replace two

591
00:32:06,799 --> 00:32:09,679
before the class we can use the command

592
00:32:09,679 --> 00:32:12,240
to check the

593
00:32:13,039 --> 00:32:15,840
instrumentation

594
00:32:18,559 --> 00:32:20,399
yes we can see

595
00:32:20,399 --> 00:32:23,199
capture the

596
00:32:23,720 --> 00:32:27,720
719 portuguese

597
00:32:33,679 --> 00:32:36,000
next

598
00:32:37,120 --> 00:32:40,240
next we will obtain the

599
00:32:40,240 --> 00:32:44,120
multiple arrays

600
00:32:56,080 --> 00:32:57,840
and this

601
00:32:57,840 --> 00:33:00,840
plus

602
00:33:14,799 --> 00:33:17,039
okay we can see

603
00:33:17,039 --> 00:33:21,679
we captured more troopers now

604
00:33:23,360 --> 00:33:24,480
then

605
00:33:24,480 --> 00:33:27,679
run the first command

606
00:33:34,399 --> 00:33:37,760
the r disk is the

607
00:33:37,760 --> 00:33:40,640
i just create

608
00:33:40,640 --> 00:33:43,600
there are four covers

609
00:33:43,600 --> 00:33:45,120
and make

610
00:33:45,120 --> 00:33:46,960
the output

611
00:33:46,960 --> 00:33:49,760
of the directory

612
00:33:49,840 --> 00:33:53,639
then run this command

613
00:34:07,440 --> 00:34:09,199
we can see the further

614
00:34:09,199 --> 00:34:12,078
is running now

615
00:34:12,560 --> 00:34:14,800
before ending the demo

616
00:34:14,800 --> 00:34:19,960
let's check the new generated binary

617
00:34:20,079 --> 00:34:23,119
we can see in each code block

618
00:34:23,119 --> 00:34:27,440
there is a piece of tracing code

619
00:34:28,399 --> 00:34:32,839
that called seo maybe log

620
00:34:38,480 --> 00:34:42,800
and this is the code we write in the

621
00:34:42,800 --> 00:34:46,399
payload assembly before

622
00:34:47,199 --> 00:34:50,158
thanks for watching

623
00:34:54,000 --> 00:34:57,280
okay let's come back

624
00:35:00,079 --> 00:35:03,359
let's make a summary first i just let

625
00:35:03,359 --> 00:35:06,079
the linker hear me fix the symbol

626
00:35:06,079 --> 00:35:07,760
references

627
00:35:07,760 --> 00:35:09,520
however

628
00:35:09,520 --> 00:35:13,599
the linker also generated some redundant

629
00:35:13,599 --> 00:35:16,000
date

630
00:35:16,000 --> 00:35:18,480
such as the pe header

631
00:35:18,480 --> 00:35:21,200
which makes me counter use the old pe

632
00:35:21,200 --> 00:35:22,800
header

633
00:35:22,800 --> 00:35:26,560
maybe i can hijack link.exe

634
00:35:26,560 --> 00:35:30,079
and only exploit exploit its functions

635
00:35:30,079 --> 00:35:33,920
of fixing symbol allocations

636
00:35:33,920 --> 00:35:36,560
second it could be cross platform in

637
00:35:36,560 --> 00:35:38,160
zero

638
00:35:38,160 --> 00:35:40,720
but i just make it come true for

639
00:35:40,720 --> 00:35:42,839
64 platform

640
00:35:42,839 --> 00:35:46,400
pe it is as fast as the compiler

641
00:35:46,400 --> 00:35:49,680
instruction with the source code

642
00:35:49,680 --> 00:35:52,400
finally the new binary could be

643
00:35:52,400 --> 00:35:55,599
equivalent to the old one

644
00:35:55,599 --> 00:35:58,400
only if all the cross references

645
00:35:58,400 --> 00:36:01,760
analysis is right

646
00:36:03,760 --> 00:36:04,880
so

647
00:36:04,880 --> 00:36:08,079
the real challenge coming

648
00:36:08,079 --> 00:36:10,400
the challenge is

649
00:36:10,400 --> 00:36:13,920
the precondition of the solutions is

650
00:36:13,920 --> 00:36:17,359
that the analysis results from ad

651
00:36:17,359 --> 00:36:19,440
is correct

652
00:36:19,440 --> 00:36:22,480
however for some reasons

653
00:36:22,480 --> 00:36:23,599
sometimes

654
00:36:23,599 --> 00:36:25,359
either can't

655
00:36:25,359 --> 00:36:28,560
recognize some pointers or relative bad

656
00:36:28,560 --> 00:36:30,960
values

657
00:36:30,960 --> 00:36:34,079
and it may lead to some crash issue

658
00:36:34,079 --> 00:36:36,560
issues

659
00:36:36,560 --> 00:36:38,880
the solution is

660
00:36:38,880 --> 00:36:42,720
creating assistance group scripts

661
00:36:42,720 --> 00:36:45,119
to help ida

662
00:36:45,119 --> 00:36:49,359
analyze before exporting

663
00:36:53,280 --> 00:36:56,160
the script is used to scan suspicious

664
00:36:56,160 --> 00:36:57,520
pointers from

665
00:36:57,520 --> 00:36:59,359
this segment

666
00:36:59,359 --> 00:37:03,119
it reads a keyword value

667
00:37:03,119 --> 00:37:06,839
if the value inside the pe adjusts

668
00:37:06,839 --> 00:37:13,040
range then it is a suspicious pointer

669
00:37:14,400 --> 00:37:17,440
this script is used to

670
00:37:17,440 --> 00:37:19,599
help some

671
00:37:19,599 --> 00:37:22,079
relative values

672
00:37:22,079 --> 00:37:24,400
there are some image-based relative

673
00:37:24,400 --> 00:37:25,440
values

674
00:37:25,440 --> 00:37:27,359
not recognized

675
00:37:27,359 --> 00:37:31,520
many exist in the jump table of switch

676
00:37:31,520 --> 00:37:33,839
case

677
00:37:34,560 --> 00:37:38,880
the fixed logic is a bit of complex

678
00:37:38,880 --> 00:37:41,200
maybe you will

679
00:37:41,200 --> 00:37:44,800
cost some minutes to read it

680
00:37:44,800 --> 00:37:49,680
but now let's check the fixer effect

681
00:37:49,680 --> 00:37:52,000
we can see the difference in the red

682
00:37:52,000 --> 00:37:54,720
rectangle

683
00:37:54,720 --> 00:37:58,160
it was immediate value before

684
00:37:58,160 --> 00:38:01,520
and it will get the character cross

685
00:38:01,520 --> 00:38:05,480
reference after the fix

686
00:38:10,560 --> 00:38:13,520
i'd ask force to analyze the exception

687
00:38:13,520 --> 00:38:15,680
handling data structures

688
00:38:15,680 --> 00:38:17,280
since the version

689
00:38:17,280 --> 00:38:19,839
7

690
00:38:20,240 --> 00:38:22,800
however there are still some

691
00:38:22,800 --> 00:38:24,800
data structures

692
00:38:24,800 --> 00:38:27,920
that can't be recognized

693
00:38:27,920 --> 00:38:30,160
maybe because of the undocumented data

694
00:38:30,160 --> 00:38:33,160
structures

695
00:38:33,280 --> 00:38:35,520
there are some function relative values

696
00:38:35,520 --> 00:38:36,400
in

697
00:38:36,400 --> 00:38:38,480
sh4

698
00:38:38,480 --> 00:38:41,520
the core logic of the script is writing

699
00:38:41,520 --> 00:38:42,880
a password

700
00:38:42,880 --> 00:38:47,839
according to the referred header file

701
00:38:48,720 --> 00:38:51,119
here we can see the data reference is

702
00:38:51,119 --> 00:38:53,760
recognized

703
00:38:53,760 --> 00:38:57,960
correctly after the fix

704
00:39:02,400 --> 00:39:05,359
c plus plus frame handler 4

705
00:39:05,359 --> 00:39:08,400
ws fh4

706
00:39:08,400 --> 00:39:11,359
it is a new feature to reduce the binary

707
00:39:11,359 --> 00:39:15,440
size of c plus plus exception handling a

708
00:39:15,440 --> 00:39:18,640
64 platform

709
00:39:20,960 --> 00:39:22,880
some function relative values are

710
00:39:22,880 --> 00:39:24,160
compressed

711
00:39:24,160 --> 00:39:25,680
and saved into

712
00:39:25,680 --> 00:39:28,400
update segment

713
00:39:28,400 --> 00:39:31,119
the relative values will be larger

714
00:39:31,119 --> 00:39:34,480
due to the instrumentation

715
00:39:34,480 --> 00:39:38,240
so it means the update segment could be

716
00:39:38,240 --> 00:39:41,879
enlarged too

717
00:39:44,880 --> 00:39:48,320
it compress the value into one to five

718
00:39:48,320 --> 00:39:50,800
bytes

719
00:39:51,040 --> 00:39:54,240
depending on the value

720
00:39:54,960 --> 00:39:57,040
these two functions

721
00:39:57,040 --> 00:39:58,400
get

722
00:39:58,400 --> 00:40:00,800
get a net encoded

723
00:40:00,800 --> 00:40:03,200
and the decompression

724
00:40:03,200 --> 00:40:05,520
are used to com decompression and

725
00:40:05,520 --> 00:40:08,079
compression

726
00:40:08,160 --> 00:40:11,040
the solution is simple i just rename the

727
00:40:11,040 --> 00:40:14,400
compressed location to the concat of a

728
00:40:14,400 --> 00:40:16,000
hand string

729
00:40:16,000 --> 00:40:17,119
fix me

730
00:40:17,119 --> 00:40:20,240
and the two targets adjust string

731
00:40:20,240 --> 00:40:21,280
then

732
00:40:21,280 --> 00:40:24,240
update the real value when the target

733
00:40:24,240 --> 00:40:27,040
address changed

734
00:40:29,839 --> 00:40:32,480
take away

735
00:40:34,000 --> 00:40:36,560
i just introduced

736
00:40:36,560 --> 00:40:37,359
two

737
00:40:37,359 --> 00:40:40,000
static binary instrumentation

738
00:40:40,000 --> 00:40:42,400
implementations

739
00:40:42,400 --> 00:40:45,920
one is either two msm

740
00:40:45,920 --> 00:40:49,839
the other one is added to obj

741
00:40:49,839 --> 00:40:52,560
and then i introduced the

742
00:40:52,560 --> 00:40:53,839
one

743
00:40:53,839 --> 00:40:56,560
sbi algorithm

744
00:40:56,560 --> 00:40:59,280
it will just

745
00:40:59,280 --> 00:41:02,640
rewrite the binary directly

746
00:41:02,640 --> 00:41:06,880
it could be cross-platform in serial

747
00:41:06,880 --> 00:41:11,040
and either is not implemented yet

748
00:41:11,040 --> 00:41:14,079
then i wrote some ida person scripts

749
00:41:14,079 --> 00:41:16,720
to assist the analyses

750
00:41:16,720 --> 00:41:20,480
the reports will be open source later

751
00:41:20,480 --> 00:41:22,560
they are private now

752
00:41:22,560 --> 00:41:25,599
future plan first maybe i will do some

753
00:41:25,599 --> 00:41:27,520
bug fix

754
00:41:27,520 --> 00:41:31,040
welcome to report issues and pro request

755
00:41:31,040 --> 00:41:34,319
then i will try to integrate it with

756
00:41:34,319 --> 00:41:36,240
other fathers

757
00:41:36,240 --> 00:41:37,359
finally

758
00:41:37,359 --> 00:41:39,680
maybe i will try to make the cross

759
00:41:39,680 --> 00:41:43,279
platform idea come true

760
00:41:44,319 --> 00:41:48,720
this is the references list

761
00:41:48,720 --> 00:41:50,000
thank you

762
00:41:50,000 --> 00:41:52,240
if you have any questions you can touch

763
00:41:52,240 --> 00:41:53,599
me on twitter

764
00:41:53,599 --> 00:41:59,160
or email me at mikijin at trendmacro.com

