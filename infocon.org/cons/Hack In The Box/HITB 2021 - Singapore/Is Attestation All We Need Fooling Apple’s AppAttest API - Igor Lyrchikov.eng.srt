1
00:00:09,599 --> 00:00:12,320
hi everyone i hope you all doing good my

2
00:00:12,320 --> 00:00:13,920
name is igor

3
00:00:13,920 --> 00:00:15,599
and today i'll be

4
00:00:15,599 --> 00:00:17,199
talking about

5
00:00:17,199 --> 00:00:19,760
apple's appa test api

6
00:00:19,760 --> 00:00:20,560
so

7
00:00:20,560 --> 00:00:23,279
i'll tell you how this technology works

8
00:00:23,279 --> 00:00:26,560
and what is our options if we want to

9
00:00:26,560 --> 00:00:28,400
bypass this check

10
00:00:28,400 --> 00:00:29,279
so

11
00:00:29,279 --> 00:00:31,840
let's get started

12
00:00:32,558 --> 00:00:35,040
currently i'm working as mobile security

13
00:00:35,040 --> 00:00:36,160
expert

14
00:00:36,160 --> 00:00:38,320
at dallas dis

15
00:00:38,320 --> 00:00:41,120
my average working schedule

16
00:00:41,120 --> 00:00:42,800
includes

17
00:00:42,800 --> 00:00:45,200
a reverse engineering penetration

18
00:00:45,200 --> 00:00:46,480
testing

19
00:00:46,480 --> 00:00:48,960
code reviews and sometimes i conduct

20
00:00:48,960 --> 00:00:51,680
security trainings to our developer

21
00:00:51,680 --> 00:00:53,199
teams

22
00:00:53,199 --> 00:00:56,719
so annually i interact with more than 10

23
00:00:56,719 --> 00:00:59,760
different developer teams and support

24
00:00:59,760 --> 00:01:02,879
around 30 projects that need significant

25
00:01:02,879 --> 00:01:07,360
level of mobile application security

26
00:01:10,240 --> 00:01:12,479
our to the agenda is to

27
00:01:12,479 --> 00:01:13,680
discuss

28
00:01:13,680 --> 00:01:14,880
what's

29
00:01:14,880 --> 00:01:15,680
the

30
00:01:15,680 --> 00:01:18,640
epitest api technology is so this

31
00:01:18,640 --> 00:01:21,759
technology was released by apple

32
00:01:21,759 --> 00:01:22,799
and

33
00:01:22,799 --> 00:01:25,280
yeah in order to help developers to

34
00:01:25,280 --> 00:01:27,920
increase the security level of their

35
00:01:27,920 --> 00:01:30,000
applications

36
00:01:30,000 --> 00:01:33,680
we'll see what this technology is

37
00:01:33,680 --> 00:01:36,400
what's the right motivation to implement

38
00:01:36,400 --> 00:01:38,960
and start using it and most important

39
00:01:38,960 --> 00:01:43,439
part we will see how actually good

40
00:01:43,439 --> 00:01:45,520
it is and

41
00:01:45,520 --> 00:01:48,320
what is the current bypass possibilities

42
00:01:48,320 --> 00:01:51,280
for potential attacker

43
00:01:51,280 --> 00:01:53,280
this talk is mostly for mobile

44
00:01:53,280 --> 00:01:55,840
application developers and defensive

45
00:01:55,840 --> 00:01:57,439
teams who can see their own

46
00:01:57,439 --> 00:02:00,240
implementation of additional protections

47
00:02:00,240 --> 00:02:04,880
to their anti-tampering mechanisms

48
00:02:04,880 --> 00:02:07,119
i think it's necessary to describe a

49
00:02:07,119 --> 00:02:10,318
potential use case for this technology

50
00:02:10,318 --> 00:02:11,440
so

51
00:02:11,440 --> 00:02:15,120
you can get to the to the point yourself

52
00:02:15,120 --> 00:02:18,160
when you can say like goddamn i need to

53
00:02:18,160 --> 00:02:20,800
have this technology in my app so

54
00:02:20,800 --> 00:02:21,680
because

55
00:02:21,680 --> 00:02:24,000
using something related to security

56
00:02:24,000 --> 00:02:27,040
without exact understanding of how it

57
00:02:27,040 --> 00:02:29,520
works can give you a false sense of

58
00:02:29,520 --> 00:02:31,040
security

59
00:02:31,040 --> 00:02:35,120
which is kind of not good at all

60
00:02:35,200 --> 00:02:36,480
so

61
00:02:36,480 --> 00:02:39,440
regarding the topic coverage i want to

62
00:02:39,440 --> 00:02:42,879
declare that this talk is focused on

63
00:02:42,879 --> 00:02:45,200
client-side security of mobile

64
00:02:45,200 --> 00:02:46,959
applications

65
00:02:46,959 --> 00:02:48,239
so

66
00:02:48,239 --> 00:02:50,480
it's mostly about the things that

67
00:02:50,480 --> 00:02:54,000
happening on the user's mobile device

68
00:02:54,000 --> 00:02:57,519
and but however we will see how

69
00:02:57,519 --> 00:03:00,400
client-side security part could be

70
00:03:00,400 --> 00:03:03,920
improved with the server interaction

71
00:03:03,920 --> 00:03:06,800
because app a test api is not a

72
00:03:06,800 --> 00:03:09,360
standalone solution and requires you to

73
00:03:09,360 --> 00:03:13,120
be connected to the internet

74
00:03:14,879 --> 00:03:16,239
now let me

75
00:03:16,239 --> 00:03:17,200
name

76
00:03:17,200 --> 00:03:18,480
those

77
00:03:18,480 --> 00:03:21,599
client-side protections

78
00:03:21,599 --> 00:03:24,879
that mobile application developers want

79
00:03:24,879 --> 00:03:27,200
to implement sometimes

80
00:03:27,200 --> 00:03:28,000
so

81
00:03:28,000 --> 00:03:30,799
maybe based on the requirements or

82
00:03:30,799 --> 00:03:32,959
recommendations

83
00:03:32,959 --> 00:03:35,920
of different standards we know there is

84
00:03:35,920 --> 00:03:38,400
a wide range of protections starting

85
00:03:38,400 --> 00:03:42,000
from most popular things such as basic

86
00:03:42,000 --> 00:03:43,599
ssl pinning

87
00:03:43,599 --> 00:03:46,720
or root or jailbreak detection

88
00:03:46,720 --> 00:03:48,319
and

89
00:03:48,319 --> 00:03:51,200
it goes to more advanced things

90
00:03:51,200 --> 00:03:52,400
including

91
00:03:52,400 --> 00:03:54,560
source code obfuscation

92
00:03:54,560 --> 00:03:58,159
hooking and tampering detection and

93
00:03:58,159 --> 00:04:00,400
other detections

94
00:04:00,400 --> 00:04:05,599
aiming to make hackers life harder

95
00:04:05,840 --> 00:04:06,879
and

96
00:04:06,879 --> 00:04:08,959
since we are talking about

97
00:04:08,959 --> 00:04:11,680
anti-tampering defen

98
00:04:11,680 --> 00:04:13,439
defense mechanism

99
00:04:13,439 --> 00:04:15,360
it's good to

100
00:04:15,360 --> 00:04:17,839
elaborate what tampering is

101
00:04:17,839 --> 00:04:20,399
so tempering is a process

102
00:04:20,399 --> 00:04:24,639
of changing a mobile application

103
00:04:24,639 --> 00:04:27,680
for example during the penetration test

104
00:04:27,680 --> 00:04:30,560
and application might refuse to run on

105
00:04:30,560 --> 00:04:33,040
your jailbroken test device

106
00:04:33,040 --> 00:04:34,320
making it

107
00:04:34,320 --> 00:04:36,479
impossible to complete some of your

108
00:04:36,479 --> 00:04:37,759
tests

109
00:04:37,759 --> 00:04:41,040
and in such case you will want to change

110
00:04:41,040 --> 00:04:43,199
the application's behavior

111
00:04:43,199 --> 00:04:45,840
and just turn off this root detection

112
00:04:45,840 --> 00:04:46,800
check

113
00:04:46,800 --> 00:04:49,520
or jailbreak detection check

114
00:04:49,520 --> 00:04:50,720
and

115
00:04:50,720 --> 00:04:51,680
yeah

116
00:04:51,680 --> 00:04:54,400
maybe another example that

117
00:04:54,400 --> 00:04:56,720
you should be aware because it's more

118
00:04:56,720 --> 00:04:58,320
harmless

119
00:04:58,320 --> 00:05:01,600
more harmful sorry for example crackers

120
00:05:01,600 --> 00:05:04,720
or modders can modify your application

121
00:05:04,720 --> 00:05:07,360
to enable premium features without

122
00:05:07,360 --> 00:05:09,360
paying for that

123
00:05:09,360 --> 00:05:10,960
and

124
00:05:10,960 --> 00:05:13,840
obviously anti-tampering functionality

125
00:05:13,840 --> 00:05:17,120
protects the application against such

126
00:05:17,120 --> 00:05:19,520
kind of modifications

127
00:05:19,520 --> 00:05:22,160
it monitors the integrity of the

128
00:05:22,160 --> 00:05:25,280
application state and environment in

129
00:05:25,280 --> 00:05:28,400
which it is running

130
00:05:28,400 --> 00:05:31,280
i'll definitely recommend you to visit a

131
00:05:31,280 --> 00:05:33,680
avas mstg website

132
00:05:33,680 --> 00:05:36,080
it has a lot of

133
00:05:36,080 --> 00:05:40,479
information and detail descriptions on

134
00:05:40,479 --> 00:05:43,840
tempering and anti-tampering techniques

135
00:05:43,840 --> 00:05:44,960
so

136
00:05:44,960 --> 00:05:48,080
you can find it there

137
00:05:49,199 --> 00:05:53,039
now i want to quickly name

138
00:05:53,039 --> 00:05:55,600
currently known and popular protection

139
00:05:55,600 --> 00:05:58,479
methods against anti-tampering

140
00:05:58,479 --> 00:06:01,039
which is always implemented which are

141
00:06:01,039 --> 00:06:04,080
always implemented on the

142
00:06:04,080 --> 00:06:07,360
client side first one is the signature

143
00:06:07,360 --> 00:06:10,080
check the most trivial one

144
00:06:10,080 --> 00:06:14,080
it checks the signers certificate

145
00:06:14,080 --> 00:06:16,960
and this approach could help you

146
00:06:16,960 --> 00:06:20,880
to detect the modification

147
00:06:20,880 --> 00:06:24,000
applied to the original app once it's

148
00:06:24,000 --> 00:06:26,880
been resigned

149
00:06:26,880 --> 00:06:29,280
second one is a code integrity

150
00:06:29,280 --> 00:06:31,840
verification it checks whether some

151
00:06:31,840 --> 00:06:35,120
specific part of the code has been

152
00:06:35,120 --> 00:06:36,479
tampered with

153
00:06:36,479 --> 00:06:39,120
by computing its

154
00:06:39,120 --> 00:06:41,520
signature at runtime

155
00:06:41,520 --> 00:06:44,400
and check it with precomputed hard-coded

156
00:06:44,400 --> 00:06:47,280
hash of its content

157
00:06:47,280 --> 00:06:50,080
and the last one is a resource integrity

158
00:06:50,080 --> 00:06:51,360
check

159
00:06:51,360 --> 00:06:54,000
it verifies the signature of specific

160
00:06:54,000 --> 00:06:55,840
resources

161
00:06:55,840 --> 00:06:57,520
at runtime

162
00:06:57,520 --> 00:06:59,680
for

163
00:07:00,840 --> 00:07:03,759
example these resources could be an

164
00:07:03,759 --> 00:07:04,880
image

165
00:07:04,880 --> 00:07:08,160
or other assets inside the

166
00:07:08,160 --> 00:07:11,440
application bundle

167
00:07:12,000 --> 00:07:14,160
and unfortunately

168
00:07:14,160 --> 00:07:17,599
in the end attackers always wins

169
00:07:17,599 --> 00:07:19,840
uh

170
00:07:20,080 --> 00:07:23,039
and bypass this kind of checks

171
00:07:23,039 --> 00:07:26,000
this is particularly true in the

172
00:07:26,000 --> 00:07:28,639
client-side security we are talking

173
00:07:28,639 --> 00:07:29,520
about

174
00:07:29,520 --> 00:07:30,560
so

175
00:07:30,560 --> 00:07:33,039
well-equipped attacker has a natural

176
00:07:33,039 --> 00:07:35,840
advantage always and

177
00:07:35,840 --> 00:07:38,560
once the protection mechanism is

178
00:07:38,560 --> 00:07:40,080
well studied

179
00:07:40,080 --> 00:07:42,560
nothing stops you from switching all

180
00:07:42,560 --> 00:07:45,039
protections off

181
00:07:45,039 --> 00:07:48,080
and the good news is that

182
00:07:48,080 --> 00:07:50,080
dealing with multiple protections

183
00:07:50,080 --> 00:07:53,120
sometimes is highly complex and could

184
00:07:53,120 --> 00:07:56,080
take a lot of time and definitely money

185
00:07:56,080 --> 00:07:56,840
to

186
00:07:56,840 --> 00:08:00,479
spend and the state of an art

187
00:08:00,479 --> 00:08:03,199
client site protections are really hard

188
00:08:03,199 --> 00:08:05,759
to bypass sometimes

189
00:08:05,759 --> 00:08:08,400
you can't just

190
00:08:08,400 --> 00:08:10,400
switch it off using

191
00:08:10,400 --> 00:08:12,960
known methods or standard tweaks and

192
00:08:12,960 --> 00:08:14,720
tricks

193
00:08:14,720 --> 00:08:16,560
to defeat them

194
00:08:16,560 --> 00:08:19,680
you really need

195
00:08:19,840 --> 00:08:22,960
to go through a

196
00:08:22,960 --> 00:08:25,680
really meticulous manual analysis i

197
00:08:25,680 --> 00:08:28,240
would say

198
00:08:29,280 --> 00:08:30,400
all right

199
00:08:30,400 --> 00:08:33,519
if we can trust the information coming

200
00:08:33,519 --> 00:08:36,080
from our device and client-side

201
00:08:36,080 --> 00:08:37,360
protections

202
00:08:37,360 --> 00:08:39,599
eventually could be

203
00:08:39,599 --> 00:08:42,799
just switched off so maybe we can rely

204
00:08:42,799 --> 00:08:45,440
on our backend in this case or even

205
00:08:45,440 --> 00:08:47,519
apple's backend servers

206
00:08:47,519 --> 00:08:48,560
so

207
00:08:48,560 --> 00:08:50,880
yeah

208
00:08:50,959 --> 00:08:52,240
i think you

209
00:08:52,240 --> 00:08:54,959
get the point and uh

210
00:08:54,959 --> 00:08:56,959
we're going to talk about apple app the

211
00:08:56,959 --> 00:08:58,720
test api so

212
00:08:58,720 --> 00:09:01,440
and when apple announced it my first

213
00:09:01,440 --> 00:09:03,200
impression was

214
00:09:03,200 --> 00:09:05,920
like yeah that sounds interesting and

215
00:09:05,920 --> 00:09:09,120
our developer teams would definitely be

216
00:09:09,120 --> 00:09:12,480
grateful if they don't need to code the

217
00:09:12,480 --> 00:09:15,600
whole verification logic

218
00:09:15,600 --> 00:09:17,839
on the back end from scratch on their

219
00:09:17,839 --> 00:09:19,920
own so let's see

220
00:09:19,920 --> 00:09:22,880
what it does

221
00:09:22,880 --> 00:09:26,080
and finally yeah it was a quite long

222
00:09:26,080 --> 00:09:27,200
intro

223
00:09:27,200 --> 00:09:29,760
uh we can but yeah we can start

224
00:09:29,760 --> 00:09:32,640
discussing the technology itself

225
00:09:32,640 --> 00:09:36,080
so epitest api was announced and

226
00:09:36,080 --> 00:09:38,480
released one year ago

227
00:09:38,480 --> 00:09:42,000
and the official announcement says

228
00:09:42,000 --> 00:09:45,040
that this new app a test api helps

229
00:09:45,040 --> 00:09:48,000
protecting against security threats to

230
00:09:48,000 --> 00:09:50,399
your apps on ios 14

231
00:09:50,399 --> 00:09:53,519
or later reducing fraudulent use of your

232
00:09:53,519 --> 00:09:54,959
services

233
00:09:54,959 --> 00:09:57,839
and with app a test you can generate a

234
00:09:57,839 --> 00:10:00,800
special cryptographic key on a device

235
00:10:00,800 --> 00:10:03,440
and use it to validate the integrity of

236
00:10:03,440 --> 00:10:06,720
your app before your server provides

237
00:10:06,720 --> 00:10:10,160
access to sensitive data

238
00:10:10,160 --> 00:10:11,360
all right

239
00:10:11,360 --> 00:10:15,519
reducing fraud length it says

240
00:10:15,680 --> 00:10:18,240
this description is quite short and if

241
00:10:18,240 --> 00:10:20,640
you don't understand what it exactly

242
00:10:20,640 --> 00:10:21,519
means

243
00:10:21,519 --> 00:10:25,040
i can say you're not alone here so yeah

244
00:10:25,040 --> 00:10:28,480
initially it was quite uncertain to me

245
00:10:28,480 --> 00:10:30,839
as well i checked the

246
00:10:30,839 --> 00:10:33,959
documentation all related articles and

247
00:10:33,959 --> 00:10:38,399
presentations from wwdc21

248
00:10:38,399 --> 00:10:40,959
and it still wasn't clear

249
00:10:40,959 --> 00:10:43,680
so yeah i was like what exactly this

250
00:10:43,680 --> 00:10:45,200
technology is doing

251
00:10:45,200 --> 00:10:48,000
and is it anti-tampering or

252
00:10:48,000 --> 00:10:50,480
how can i implement it properly do i

253
00:10:50,480 --> 00:10:52,560
need to code my own detections to

254
00:10:52,560 --> 00:10:55,040
support this technology or i can use it

255
00:10:55,040 --> 00:10:56,160
as is

256
00:10:56,160 --> 00:10:57,519
and just

257
00:10:57,519 --> 00:11:00,000
stop worrying about all these hackers

258
00:11:00,000 --> 00:11:01,040
around

259
00:11:01,040 --> 00:11:02,800
after i implemented

260
00:11:02,800 --> 00:11:05,440
so okay

261
00:11:05,440 --> 00:11:06,720
then

262
00:11:06,720 --> 00:11:09,279
i thought the best way to deal with all

263
00:11:09,279 --> 00:11:10,880
these assumptions

264
00:11:10,880 --> 00:11:14,640
is just to implement this technology

265
00:11:14,640 --> 00:11:16,399
on our own

266
00:11:16,399 --> 00:11:17,839
and test

267
00:11:17,839 --> 00:11:21,360
how it works and whether it's possible

268
00:11:21,360 --> 00:11:22,880
to bypass

269
00:11:22,880 --> 00:11:27,240
the detection check

270
00:11:29,040 --> 00:11:30,160
and

271
00:11:30,160 --> 00:11:33,360
as i said eppa test is kinda relatively

272
00:11:33,360 --> 00:11:36,880
new technology and uh first of all

273
00:11:36,880 --> 00:11:38,000
uh

274
00:11:38,000 --> 00:11:43,800
we need to make an intro to this problem

275
00:11:44,480 --> 00:11:46,399
on the screenshot you can see the

276
00:11:46,399 --> 00:11:50,480
default image of interactions between

277
00:11:50,480 --> 00:11:55,440
application on client side and back end

278
00:11:55,440 --> 00:11:58,320
on the right side

279
00:11:59,839 --> 00:12:02,639
you can use the app test class to

280
00:12:02,639 --> 00:12:06,160
generate a special cryptographic key on

281
00:12:06,160 --> 00:12:07,760
the device

282
00:12:07,760 --> 00:12:11,040
and have apple to verify the validity of

283
00:12:11,040 --> 00:12:13,680
that key on their backhand

284
00:12:13,680 --> 00:12:14,720
so

285
00:12:14,720 --> 00:12:18,480
then you can use that key to assert the

286
00:12:18,480 --> 00:12:20,880
validity of your app

287
00:12:20,880 --> 00:12:23,519
whenever you request sensitive data from

288
00:12:23,519 --> 00:12:28,160
your server or want to record some value

289
00:12:28,160 --> 00:12:31,120
on your backend

290
00:12:33,680 --> 00:12:36,639
now let's talk how it exactly works

291
00:12:36,639 --> 00:12:39,920
because it's kind of clear from start

292
00:12:39,920 --> 00:12:42,160
during my research i've made a sample

293
00:12:42,160 --> 00:12:45,040
app to understand how the whole concept

294
00:12:45,040 --> 00:12:46,399
is working

295
00:12:46,399 --> 00:12:48,639
and did a little portion of reverse

296
00:12:48,639 --> 00:12:50,959
engineering to see what is happening on

297
00:12:50,959 --> 00:12:54,000
the device when we interacting with the

298
00:12:54,000 --> 00:12:55,120
api

299
00:12:55,120 --> 00:12:56,959
and what could be

300
00:12:56,959 --> 00:13:00,959
altered on our site

301
00:13:03,920 --> 00:13:08,399
this application is written in flutter

302
00:13:09,040 --> 00:13:16,360
i tested it on iphone 8 under ios 14.0.1

303
00:13:16,480 --> 00:13:18,240
and

304
00:13:18,240 --> 00:13:20,800
yeah forgive me for that but i hard

305
00:13:20,800 --> 00:13:22,320
coded some

306
00:13:22,320 --> 00:13:24,639
values that depended

307
00:13:24,639 --> 00:13:28,639
on back-end interaction because i didn't

308
00:13:28,639 --> 00:13:30,399
uh

309
00:13:30,399 --> 00:13:33,519
coded a whole implementation of back-end

310
00:13:33,519 --> 00:13:35,839
server during this part

311
00:13:35,839 --> 00:13:38,160
during this research but

312
00:13:38,160 --> 00:13:41,040
yeah on the screenshot you can see that

313
00:13:41,040 --> 00:13:44,480
functionality is quite simple

314
00:13:44,480 --> 00:13:47,760
but that's enough for our

315
00:13:47,760 --> 00:13:48,959
and

316
00:13:48,959 --> 00:13:51,360
later on after

317
00:13:51,360 --> 00:13:53,760
in the end of this talk i'll share the

318
00:13:53,760 --> 00:13:56,959
link to my github page where you can get

319
00:13:56,959 --> 00:13:58,240
the

320
00:13:58,240 --> 00:14:00,880
sample app and source code

321
00:14:00,880 --> 00:14:03,440
to do to test your

322
00:14:03,440 --> 00:14:07,040
own bypasses and maybe other

323
00:14:07,040 --> 00:14:09,839
test cases

324
00:14:10,720 --> 00:14:13,040
all right

325
00:14:13,040 --> 00:14:15,680
it's necessary to say that

326
00:14:15,680 --> 00:14:18,480
in the whole process three parties are

327
00:14:18,480 --> 00:14:20,399
involved

328
00:14:20,399 --> 00:14:23,360
first is a mobile device

329
00:14:23,360 --> 00:14:27,519
running under ios 14 or higher

330
00:14:27,519 --> 00:14:31,839
than backend server under our control

331
00:14:31,839 --> 00:14:34,399
and third party is a apple's backend

332
00:14:34,399 --> 00:14:36,160
server

333
00:14:36,160 --> 00:14:37,040
and

334
00:14:37,040 --> 00:14:39,440
yeah now let's see which steps we need

335
00:14:39,440 --> 00:14:41,440
to do to complete the attestation

336
00:14:41,440 --> 00:14:42,480
process

337
00:14:42,480 --> 00:14:47,839
and start signing our outgoing requests

338
00:14:49,839 --> 00:14:50,800
so

339
00:14:50,800 --> 00:14:53,600
on the first step we are generating

340
00:14:53,600 --> 00:14:55,920
initial key value

341
00:14:55,920 --> 00:14:58,800
which is unique to the application

342
00:14:58,800 --> 00:15:03,440
and contains device identifier

343
00:15:03,440 --> 00:15:04,880
after we call

344
00:15:04,880 --> 00:15:07,040
generate key function

345
00:15:07,040 --> 00:15:10,079
it creates cryptographic key

346
00:15:10,079 --> 00:15:13,199
using secure enclave processor

347
00:15:13,199 --> 00:15:16,480
and secure enclave is a hardware based

348
00:15:16,480 --> 00:15:17,839
key manager

349
00:15:17,839 --> 00:15:19,199
which is

350
00:15:19,199 --> 00:15:22,160
isolated from the main processor

351
00:15:22,160 --> 00:15:23,279
and

352
00:15:23,279 --> 00:15:25,279
from my point of view

353
00:15:25,279 --> 00:15:28,160
hardware based cryptography

354
00:15:28,160 --> 00:15:28,959
like

355
00:15:28,959 --> 00:15:32,320
without leaving a device it sounds safe

356
00:15:32,320 --> 00:15:35,440
enough sounds good

357
00:15:36,639 --> 00:15:38,880
then

358
00:15:39,440 --> 00:15:43,120
after we generate this key

359
00:15:43,120 --> 00:15:46,079
we request generation of the challenge

360
00:15:46,079 --> 00:15:49,440
on our backend server

361
00:15:49,440 --> 00:15:51,600
just to stay protected from replay

362
00:15:51,600 --> 00:15:55,680
attacks and as additional trusted source

363
00:15:55,680 --> 00:15:57,440
of data

364
00:15:57,440 --> 00:16:01,600
we're interacting with our backend

365
00:16:04,320 --> 00:16:05,839
yeah

366
00:16:05,839 --> 00:16:08,320
so during this step we are generating a

367
00:16:08,320 --> 00:16:10,399
hash value

368
00:16:10,399 --> 00:16:14,959
and we will be using it as a parameter

369
00:16:14,959 --> 00:16:17,199
to the a test key

370
00:16:17,199 --> 00:16:20,880
function call on the next step

371
00:16:20,880 --> 00:16:23,360
so in the

372
00:16:23,360 --> 00:16:24,959
right corner

373
00:16:24,959 --> 00:16:27,600
you can see the example

374
00:16:27,600 --> 00:16:28,320
of

375
00:16:28,320 --> 00:16:31,199
this hash value

376
00:16:31,199 --> 00:16:32,399
in

377
00:16:32,399 --> 00:16:35,839
our testing app this value is hard coded

378
00:16:35,839 --> 00:16:39,120
which makes it vulnerable to

379
00:16:39,120 --> 00:16:42,959
replay attacks but fortunately this type

380
00:16:42,959 --> 00:16:44,800
of

381
00:16:44,800 --> 00:16:49,519
attacks is at x is beyond

382
00:16:49,519 --> 00:16:53,519
the scope of our research

383
00:16:58,480 --> 00:16:59,680
as i said

384
00:16:59,680 --> 00:17:03,519
on step 3 we need to call this a test

385
00:17:03,519 --> 00:17:06,480
key function in order to receive at the

386
00:17:06,480 --> 00:17:08,720
station object from the apple's back-end

387
00:17:08,720 --> 00:17:11,119
server

388
00:17:11,119 --> 00:17:13,520
so this function as you can see on the

389
00:17:13,520 --> 00:17:15,599
screenshot it takes

390
00:17:15,599 --> 00:17:18,720
two input values the key id value that

391
00:17:18,720 --> 00:17:21,280
we got on step 1

392
00:17:21,280 --> 00:17:22,240
and

393
00:17:22,240 --> 00:17:25,520
this anti-replay hash from our back end

394
00:17:25,520 --> 00:17:26,400
so

395
00:17:26,400 --> 00:17:29,839
apple recommends to use

396
00:17:30,240 --> 00:17:33,240
sha256

397
00:17:33,360 --> 00:17:34,880
hash value

398
00:17:34,880 --> 00:17:38,799
its implementation from cryptokit so

399
00:17:38,799 --> 00:17:40,640
you are willing to decide how you want

400
00:17:40,640 --> 00:17:43,440
to implement it

401
00:17:44,160 --> 00:17:47,120
and yeah then step number three after we

402
00:17:47,120 --> 00:17:49,679
call this a test key function with all

403
00:17:49,679 --> 00:17:53,039
necessary parameters on our iphone

404
00:17:53,039 --> 00:17:56,320
uh our iphone actually sends outgoing

405
00:17:56,320 --> 00:17:57,760
requests

406
00:17:57,760 --> 00:18:01,280
to apple's server and

407
00:18:01,280 --> 00:18:03,760
in the response to this request we

408
00:18:03,760 --> 00:18:06,480
receive at the station object

409
00:18:06,480 --> 00:18:10,160
it's a really really huge

410
00:18:10,160 --> 00:18:12,480
piece of data

411
00:18:12,480 --> 00:18:14,640
even won't fit in the

412
00:18:14,640 --> 00:18:16,320
reference corner

413
00:18:16,320 --> 00:18:18,559
so

414
00:18:19,919 --> 00:18:23,200
yeah it's cropped here

415
00:18:23,440 --> 00:18:24,720
and

416
00:18:24,720 --> 00:18:27,520
what is this attestation

417
00:18:27,520 --> 00:18:29,120
object

418
00:18:29,120 --> 00:18:30,799
actually

419
00:18:30,799 --> 00:18:33,039
so

420
00:18:33,360 --> 00:18:35,919
attestation object contains information

421
00:18:35,919 --> 00:18:37,520
about

422
00:18:37,520 --> 00:18:40,480
device hardware of the requester

423
00:18:40,480 --> 00:18:42,559
application bundle id

424
00:18:42,559 --> 00:18:45,679
and other sensitive values

425
00:18:45,679 --> 00:18:48,480
and it's very important to parse this

426
00:18:48,480 --> 00:18:51,039
attestation object properly on our

427
00:18:51,039 --> 00:18:52,559
backend server

428
00:18:52,559 --> 00:18:53,760
because

429
00:18:53,760 --> 00:18:55,039
one of

430
00:18:55,039 --> 00:18:58,480
bypasses that i encountered was related

431
00:18:58,480 --> 00:19:03,360
to incorrect processing of this data

432
00:19:08,320 --> 00:19:11,600
then during step number four

433
00:19:11,600 --> 00:19:15,200
we send values generated during all

434
00:19:15,200 --> 00:19:19,200
three steps to our backend server where

435
00:19:19,200 --> 00:19:22,000
attestation object is

436
00:19:22,000 --> 00:19:25,360
the resulting value from step three

437
00:19:25,360 --> 00:19:26,799
key id

438
00:19:26,799 --> 00:19:30,320
is a value generated during step one

439
00:19:30,320 --> 00:19:33,280
and challenge is a client

440
00:19:33,280 --> 00:19:35,919
data hash value from our backend server

441
00:19:35,919 --> 00:19:39,840
generated during step two

442
00:19:44,960 --> 00:19:47,600
then during step five we need to verify

443
00:19:47,600 --> 00:19:53,840
that station object on our back end so

444
00:19:54,640 --> 00:19:57,919
we need to decode it

445
00:19:58,960 --> 00:20:00,039
as a

446
00:20:00,039 --> 00:20:01,600
cbor

447
00:20:01,600 --> 00:20:04,399
compatible

448
00:20:04,840 --> 00:20:07,360
format and

449
00:20:07,360 --> 00:20:10,960
store this data on our server

450
00:20:10,960 --> 00:20:15,039
and link it to the corresponding user

451
00:20:15,039 --> 00:20:15,919
so

452
00:20:15,919 --> 00:20:19,200
you need to validate the team identifier

453
00:20:19,200 --> 00:20:21,919
and bundle identifier so they must

454
00:20:21,919 --> 00:20:23,120
comply

455
00:20:23,120 --> 00:20:26,159
with the signature expected for your

456
00:20:26,159 --> 00:20:29,039
application

457
00:20:29,440 --> 00:20:32,640
now let's talk a bit more about these

458
00:20:32,640 --> 00:20:36,799
validation steps what this cbor thing is

459
00:20:36,799 --> 00:20:38,080
and

460
00:20:38,080 --> 00:20:41,600
what which values we need to

461
00:20:41,600 --> 00:20:43,520
take care of

462
00:20:43,520 --> 00:20:47,480
and interpret properly

463
00:20:49,200 --> 00:20:50,559
after you

464
00:20:50,559 --> 00:20:54,080
stored the attestation object on your

465
00:20:54,080 --> 00:20:56,080
back end

466
00:20:56,080 --> 00:20:59,440
you need to decode that station object

467
00:20:59,440 --> 00:21:02,240
using cbor parsing library as i said

468
00:21:02,240 --> 00:21:03,679
sorry for

469
00:21:03,679 --> 00:21:04,880
this

470
00:21:04,880 --> 00:21:08,240
for me repeating myself

471
00:21:09,919 --> 00:21:12,080
you can actually check the example of

472
00:21:12,080 --> 00:21:13,679
this decoded

473
00:21:13,679 --> 00:21:18,000
object in the end of step three

474
00:21:18,400 --> 00:21:19,760
and

475
00:21:19,760 --> 00:21:22,400
yeah first step you need to verify

476
00:21:22,400 --> 00:21:26,559
x5c value that it contains

477
00:21:26,559 --> 00:21:29,600
up a test root certificate

478
00:21:29,600 --> 00:21:31,360
which is

479
00:21:31,360 --> 00:21:35,919
publicly available to be downloaded

480
00:21:35,919 --> 00:21:37,520
you can find the link in the

481
00:21:37,520 --> 00:21:40,240
documentation

482
00:21:40,240 --> 00:21:41,120
then

483
00:21:41,120 --> 00:21:43,760
you parse this up a test root

484
00:21:43,760 --> 00:21:46,559
certificate

485
00:21:46,640 --> 00:21:49,120
obtain the value of credit cert

486
00:21:49,120 --> 00:21:51,440
extension

487
00:21:51,440 --> 00:21:54,559
after that you create hash of the public

488
00:21:54,559 --> 00:21:55,520
key

489
00:21:55,520 --> 00:21:57,120
in

490
00:21:57,120 --> 00:21:57,600
stored this

491
00:21:57,600 --> 00:21:59,039
this credit cert

492
00:21:59,039 --> 00:22:02,000
and verify that it matches with the key

493
00:22:02,000 --> 00:22:05,280
id identifier from your application

494
00:22:05,280 --> 00:22:08,880
generated during the step one

495
00:22:08,880 --> 00:22:12,919
after that you compute the new

496
00:22:12,919 --> 00:22:17,600
sha256 hash of your applications id and

497
00:22:17,600 --> 00:22:20,919
verify that it's the same as the

498
00:22:20,919 --> 00:22:27,400
authenticator data's rpid hash

499
00:22:27,440 --> 00:22:29,120
i don't know why but still it's

500
00:22:29,120 --> 00:22:31,840
necessary to verify that authenticator

501
00:22:31,840 --> 00:22:32,880
data's

502
00:22:32,880 --> 00:22:35,840
counter field equals zero have no idea

503
00:22:35,840 --> 00:22:38,840
why they recommend to do it

504
00:22:38,840 --> 00:22:42,130
then uh you need to verify the

505
00:22:42,130 --> 00:22:43,200
[Music]

506
00:22:43,200 --> 00:22:46,400
aaa guid field

507
00:22:46,400 --> 00:22:47,120
so

508
00:22:47,120 --> 00:22:50,960
it's either a test develop if operating

509
00:22:50,960 --> 00:22:54,480
in the development environment or a test

510
00:22:54,480 --> 00:22:58,880
follow it followed by seven zero bytes

511
00:22:58,880 --> 00:23:00,880
if operating in the production

512
00:23:00,880 --> 00:23:03,280
environment actually it could help you

513
00:23:03,280 --> 00:23:06,879
to detect whether

514
00:23:07,200 --> 00:23:10,960
possibly tampered attestation object

515
00:23:10,960 --> 00:23:11,799
was

516
00:23:11,799 --> 00:23:14,480
incorrectly assembled

517
00:23:14,480 --> 00:23:16,240
using maybe

518
00:23:16,240 --> 00:23:18,159
a

519
00:23:18,159 --> 00:23:21,679
development certificate or something so

520
00:23:21,679 --> 00:23:24,640
it could help in

521
00:23:24,960 --> 00:23:28,080
behavioral analysis

522
00:23:28,080 --> 00:23:30,080
so then you verify that the

523
00:23:30,080 --> 00:23:33,760
authenticator data's credential id field

524
00:23:33,760 --> 00:23:37,760
is the same as the key identifier

525
00:23:37,760 --> 00:23:40,480
from step one

526
00:23:40,480 --> 00:23:42,960
and after successfully completing all

527
00:23:42,960 --> 00:23:45,200
these steps you can trust that station

528
00:23:45,200 --> 00:23:46,799
object

529
00:23:46,799 --> 00:23:48,240
actually yes i agree that

530
00:23:48,240 --> 00:23:50,320
recommendations from apple is kind of

531
00:23:50,320 --> 00:23:52,240
good and efficient

532
00:23:52,240 --> 00:23:55,360
but the problem mostly can occur on

533
00:23:55,360 --> 00:23:57,279
integrators site

534
00:23:57,279 --> 00:23:59,440
if validation is not properly

535
00:23:59,440 --> 00:24:02,159
implemented

536
00:24:03,600 --> 00:24:06,240
then step number six

537
00:24:06,240 --> 00:24:08,640
uh it's kinda optional

538
00:24:08,640 --> 00:24:09,919
because

539
00:24:09,919 --> 00:24:13,600
uh but you still can use the receipt

540
00:24:13,600 --> 00:24:16,559
that was extracted from at the station

541
00:24:16,559 --> 00:24:19,039
object during previous step

542
00:24:19,039 --> 00:24:22,640
and send it to the apple server

543
00:24:22,640 --> 00:24:24,640
to get the metric

544
00:24:24,640 --> 00:24:28,240
as their documentation says

545
00:24:28,240 --> 00:24:30,960
what is the metric you would ask

546
00:24:30,960 --> 00:24:34,799
so actually response body from the apple

547
00:24:34,799 --> 00:24:39,200
server has risk metric field

548
00:24:39,200 --> 00:24:41,760
so which is integer value

549
00:24:41,760 --> 00:24:43,440
that indicates

550
00:24:43,440 --> 00:24:46,720
the number of attested keys associated

551
00:24:46,720 --> 00:24:48,640
with associated

552
00:24:48,640 --> 00:24:52,320
with the given device over the

553
00:24:52,320 --> 00:24:56,159
lifetime of the device so

554
00:24:56,159 --> 00:24:57,360
kind of

555
00:24:57,360 --> 00:25:00,880
small piece of knowledge

556
00:25:00,880 --> 00:25:04,799
in my opinion but still maybe

557
00:25:04,799 --> 00:25:08,159
it become more useful in the

558
00:25:08,159 --> 00:25:10,480
sometime in the future

559
00:25:10,480 --> 00:25:11,919
if they

560
00:25:11,919 --> 00:25:12,799
add

561
00:25:12,799 --> 00:25:17,039
more fields to this metric

562
00:25:17,919 --> 00:25:19,760
next one

563
00:25:19,760 --> 00:25:22,480
server to server interaction

564
00:25:22,480 --> 00:25:24,559
here you can see that

565
00:25:24,559 --> 00:25:28,799
it's declared that this metric can grow

566
00:25:28,799 --> 00:25:32,000
if user reinstalls the application

567
00:25:32,000 --> 00:25:34,080
restores from a backup

568
00:25:34,080 --> 00:25:37,600
or transfer a device to another user

569
00:25:37,600 --> 00:25:39,120
so

570
00:25:39,120 --> 00:25:41,760
yeah for privacy reason upper test key

571
00:25:41,760 --> 00:25:43,600
stored on device

572
00:25:43,600 --> 00:25:45,679
they don't survive these

573
00:25:45,679 --> 00:25:47,120
events

574
00:25:47,120 --> 00:25:48,240
and

575
00:25:48,240 --> 00:25:51,200
you have to generate a new key on the

576
00:25:51,200 --> 00:25:52,880
same device

577
00:25:52,880 --> 00:25:56,000
and this metric from apple could help

578
00:25:56,000 --> 00:25:57,279
you

579
00:25:57,279 --> 00:25:59,360
in identification

580
00:25:59,360 --> 00:26:02,559
of potential api abusers

581
00:26:02,559 --> 00:26:03,600
however

582
00:26:03,600 --> 00:26:06,000
in the end it's just a number

583
00:26:06,000 --> 00:26:08,960
and only you decide whether you want to

584
00:26:08,960 --> 00:26:12,080
interpret this information as something

585
00:26:12,080 --> 00:26:14,480
suspicious or not

586
00:26:14,480 --> 00:26:17,200
and it's necessary to remember that

587
00:26:17,200 --> 00:26:20,559
apple doesn't provide a solution

588
00:26:20,559 --> 00:26:23,440
it gives only additional source of

589
00:26:23,440 --> 00:26:25,840
information

590
00:26:28,880 --> 00:26:31,760
step number seven

591
00:26:31,760 --> 00:26:34,720
as you might note we cannot generate

592
00:26:34,720 --> 00:26:37,840
attestation object each time

593
00:26:37,840 --> 00:26:41,840
when we want to verify the request

594
00:26:41,840 --> 00:26:44,159
because it would mess up the whole

595
00:26:44,159 --> 00:26:45,360
metric

596
00:26:45,360 --> 00:26:47,760
on apple backend

597
00:26:47,760 --> 00:26:50,880
so we will use another object related to

598
00:26:50,880 --> 00:26:52,880
at attestation object

599
00:26:52,880 --> 00:26:56,640
it's called assertion object

600
00:26:56,640 --> 00:26:58,720
if you successfully verify the

601
00:26:58,720 --> 00:27:02,159
attestation object on your server during

602
00:27:02,159 --> 00:27:04,480
the step number five

603
00:27:04,480 --> 00:27:07,679
you can associate the key id which you

604
00:27:07,679 --> 00:27:10,320
got from the step number one with the

605
00:27:10,320 --> 00:27:14,559
user's device for the future reference

606
00:27:14,559 --> 00:27:17,520
you need the key id identifier to

607
00:27:17,520 --> 00:27:20,159
generate assertions

608
00:27:20,159 --> 00:27:23,440
or in other words

609
00:27:23,440 --> 00:27:26,399
you need this key id identifier to be

610
00:27:26,399 --> 00:27:28,159
able to sign

611
00:27:28,159 --> 00:27:29,440
requests

612
00:27:29,440 --> 00:27:31,520
going to

613
00:27:31,520 --> 00:27:34,850
your backend servers

614
00:27:34,850 --> 00:27:36,240
[Music]

615
00:27:36,240 --> 00:27:38,000
actually assertion object and

616
00:27:38,000 --> 00:27:40,640
attestation object are both coming as

617
00:27:40,640 --> 00:27:42,640
cbor

618
00:27:42,640 --> 00:27:43,840
objects

619
00:27:43,840 --> 00:27:47,279
so far i saw almost every popular

620
00:27:47,279 --> 00:27:50,960
programming language has its own library

621
00:27:50,960 --> 00:27:53,840
to parse and decode cbor

622
00:27:53,840 --> 00:27:55,360
and

623
00:27:55,360 --> 00:27:57,690
yeah even the

624
00:27:57,690 --> 00:27:58,720
[Music]

625
00:27:58,720 --> 00:28:00,960
sort of fresh

626
00:28:00,960 --> 00:28:02,799
uh technology

627
00:28:02,799 --> 00:28:06,640
uh flutter and programming language dart

628
00:28:06,640 --> 00:28:08,320
has

629
00:28:08,320 --> 00:28:12,799
its own cbor decoding library and

630
00:28:12,799 --> 00:28:15,760
if you interested in analyzing its

631
00:28:15,760 --> 00:28:17,200
content

632
00:28:17,200 --> 00:28:21,039
i've implemented inbound cbor decoder

633
00:28:21,039 --> 00:28:25,760
inside my sample application and you can

634
00:28:25,760 --> 00:28:27,039
play with it

635
00:28:27,039 --> 00:28:30,279
if you want

636
00:28:30,640 --> 00:28:32,240
and

637
00:28:32,240 --> 00:28:34,720
if i remember correctly step number

638
00:28:34,720 --> 00:28:37,360
eight is the last step finally

639
00:28:37,360 --> 00:28:38,240
uh

640
00:28:38,240 --> 00:28:40,559
we need to verify this assertion object

641
00:28:40,559 --> 00:28:43,120
on the back end

642
00:28:43,120 --> 00:28:46,480
so after receiving the client id data

643
00:28:46,480 --> 00:28:49,440
which is a

644
00:28:49,440 --> 00:28:50,880
request body

645
00:28:50,880 --> 00:28:53,120
and the assertion

646
00:28:53,120 --> 00:28:55,520
you need to verify and decode the

647
00:28:55,520 --> 00:28:56,799
assertion

648
00:28:56,799 --> 00:29:01,279
to ensure it uses the cbor data format

649
00:29:01,279 --> 00:29:05,760
and has the expected contents

650
00:29:07,760 --> 00:29:10,480
after assertion is verified

651
00:29:10,480 --> 00:29:13,279
you can trust the request and consider

652
00:29:13,279 --> 00:29:17,840
it as not tempered

653
00:29:19,679 --> 00:29:22,720
let's quickly go through the process of

654
00:29:22,720 --> 00:29:25,440
assertion object validation

655
00:29:25,440 --> 00:29:28,240
and i can say it's mostly the same with

656
00:29:28,240 --> 00:29:31,440
the attestation object verification

657
00:29:31,440 --> 00:29:34,320
you can check that incoming server

658
00:29:34,320 --> 00:29:37,520
request was signed with previously

659
00:29:37,520 --> 00:29:39,600
generated private key

660
00:29:39,600 --> 00:29:44,320
and all necessary hash are the same

661
00:29:44,320 --> 00:29:45,120
and

662
00:29:45,120 --> 00:29:48,399
after assertion is verified

663
00:29:48,399 --> 00:29:51,200
you can trust the incoming request

664
00:29:51,200 --> 00:29:55,840
and consider it as not tempered

665
00:29:58,480 --> 00:30:02,159
all right finally we finished

666
00:30:02,159 --> 00:30:03,679
with the

667
00:30:03,679 --> 00:30:06,840
implementation process of this

668
00:30:06,840 --> 00:30:09,200
technology but

669
00:30:09,200 --> 00:30:13,279
does it mean we are protected now i mean

670
00:30:13,279 --> 00:30:17,760
if we passed all these eight steps

671
00:30:18,559 --> 00:30:20,720
here you can see

672
00:30:20,720 --> 00:30:23,840
some assumptions and remarks made by

673
00:30:23,840 --> 00:30:25,679
apple on their

674
00:30:25,679 --> 00:30:29,200
forums and even in documentation

675
00:30:29,200 --> 00:30:32,720
and to me it sounds really confusing

676
00:30:32,720 --> 00:30:35,760
because it's almost impossible to say

677
00:30:35,760 --> 00:30:37,200
for example

678
00:30:37,200 --> 00:30:39,520
that

679
00:30:40,480 --> 00:30:44,080
you have 100 person evidence that you

680
00:30:44,080 --> 00:30:46,320
know what is going

681
00:30:46,320 --> 00:30:49,360
what is going on at users device

682
00:30:49,360 --> 00:30:51,279
that

683
00:30:51,279 --> 00:30:54,000
it's not jailbroken or it's not tempered

684
00:30:54,000 --> 00:30:55,919
how could you say that

685
00:30:55,919 --> 00:30:58,799
that it's not tempered from from the

686
00:30:58,799 --> 00:31:01,679
very beginning

687
00:31:02,840 --> 00:31:04,799
uh

688
00:31:04,799 --> 00:31:05,679
yeah

689
00:31:05,679 --> 00:31:08,399
on this screenshot

690
00:31:08,399 --> 00:31:10,000
we can see

691
00:31:10,000 --> 00:31:14,000
a kind of not clear acceptance of the

692
00:31:14,000 --> 00:31:15,600
fact that

693
00:31:15,600 --> 00:31:20,159
they can't do much against jailbreaks

694
00:31:20,159 --> 00:31:22,559
in terms of detections

695
00:31:22,559 --> 00:31:24,000
and

696
00:31:24,000 --> 00:31:24,799
yeah

697
00:31:24,799 --> 00:31:26,720
somehow you need to figure it out on

698
00:31:26,720 --> 00:31:30,120
your own probably

699
00:31:33,840 --> 00:31:35,840
and one

700
00:31:35,840 --> 00:31:40,000
one more funny slide is a

701
00:31:41,760 --> 00:31:44,880
brilliant official answer about possible

702
00:31:44,880 --> 00:31:48,240
hooking or patching of the attestation

703
00:31:48,240 --> 00:31:49,360
call

704
00:31:49,360 --> 00:31:51,440
and

705
00:31:51,440 --> 00:31:55,440
yeah frameworks engineer says

706
00:31:55,440 --> 00:31:59,440
literally nothing you can do with it

707
00:31:59,440 --> 00:32:02,880
so don't be surprised that you

708
00:32:02,880 --> 00:32:06,720
have to implement much more detections

709
00:32:06,720 --> 00:32:11,519
apart from this apathy station thing

710
00:32:12,480 --> 00:32:15,039
now let's talk about all these bypass

711
00:32:15,039 --> 00:32:18,080
related scenarios

712
00:32:18,080 --> 00:32:18,960
all

713
00:32:18,960 --> 00:32:23,120
um all current bypasses are quite simple

714
00:32:23,120 --> 00:32:26,080
and depend on on the fact

715
00:32:26,080 --> 00:32:30,080
that app attest can't detect whether

716
00:32:30,080 --> 00:32:33,760
device is jailbroken or application was

717
00:32:33,760 --> 00:32:36,559
tempered before initial installation on

718
00:32:36,559 --> 00:32:40,840
the fresh device neither detect hooking

719
00:32:40,840 --> 00:32:44,320
frameworks which are modifying behavior

720
00:32:44,320 --> 00:32:45,120
of

721
00:32:45,120 --> 00:32:48,399
your application during runtime

722
00:32:48,399 --> 00:32:51,439
during its runtime

723
00:32:53,120 --> 00:32:55,200
we don't even need to hack the key

724
00:32:55,200 --> 00:32:57,519
generation algorithms

725
00:32:57,519 --> 00:33:00,399
break the cryptography because it's

726
00:33:00,399 --> 00:33:01,360
really

727
00:33:01,360 --> 00:33:04,720
uh tough it's it depends on secure

728
00:33:04,720 --> 00:33:08,320
enclave and in our case definitely not

729
00:33:08,320 --> 00:33:11,200
that efficient

730
00:33:11,200 --> 00:33:12,640
to attack

731
00:33:12,640 --> 00:33:15,600
through this channel

732
00:33:16,480 --> 00:33:18,880
so we don't

733
00:33:18,880 --> 00:33:21,039
need to do that because we can abuse the

734
00:33:21,039 --> 00:33:23,120
developer's logic

735
00:33:23,120 --> 00:33:26,879
fortunately you saw

736
00:33:26,960 --> 00:33:30,320
there is eight steps and

737
00:33:30,320 --> 00:33:32,480
there is plenty of space to make a

738
00:33:32,480 --> 00:33:34,880
mistake during the implementation from

739
00:33:34,880 --> 00:33:37,679
my experience i can say that i haven't

740
00:33:37,679 --> 00:33:40,480
seen a single application which properly

741
00:33:40,480 --> 00:33:43,200
implemented upper tests yet

742
00:33:43,200 --> 00:33:45,840
in all instances it was possible to

743
00:33:45,840 --> 00:33:48,559
bypass the check

744
00:33:48,559 --> 00:33:49,519
i mean

745
00:33:49,519 --> 00:33:52,519
literally

746
00:33:52,880 --> 00:33:56,640
you can bypass it by abusing its logic

747
00:33:56,640 --> 00:33:58,480
and here is the

748
00:33:58,480 --> 00:34:01,039
cases

749
00:34:01,039 --> 00:34:03,919
number one is uh

750
00:34:03,919 --> 00:34:06,399
quite simple do you remember we need to

751
00:34:06,399 --> 00:34:08,560
start the attestation process during

752
00:34:08,560 --> 00:34:10,000
step 3

753
00:34:10,000 --> 00:34:11,520
which

754
00:34:11,520 --> 00:34:13,440
requires internet

755
00:34:13,440 --> 00:34:16,399
connection it's kind of crucial step

756
00:34:16,399 --> 00:34:18,638
so

757
00:34:18,800 --> 00:34:21,520
we can just drop outgoing requests by

758
00:34:21,520 --> 00:34:24,239
configuring the

759
00:34:24,239 --> 00:34:25,918
meeting proxy

760
00:34:25,918 --> 00:34:27,119
or

761
00:34:27,119 --> 00:34:30,560
using frida hooking framework

762
00:34:30,560 --> 00:34:32,800
and

763
00:34:32,800 --> 00:34:36,000
in some cases application logic handling

764
00:34:36,000 --> 00:34:37,440
this case

765
00:34:37,440 --> 00:34:38,879
as a

766
00:34:38,879 --> 00:34:42,000
scenario when

767
00:34:42,000 --> 00:34:43,918
apple server is

768
00:34:43,918 --> 00:34:46,639
down or not accessible

769
00:34:46,639 --> 00:34:50,320
and continue working with the

770
00:34:50,320 --> 00:34:53,359
when internet access disabled

771
00:34:53,359 --> 00:34:54,879
for example

772
00:34:54,879 --> 00:34:57,839
in this case bypass works actually

773
00:34:57,839 --> 00:35:00,078
and

774
00:35:01,119 --> 00:35:05,520
yeah sometimes it requires more

775
00:35:05,520 --> 00:35:07,520
uh

776
00:35:07,520 --> 00:35:09,920
trout

777
00:35:09,920 --> 00:35:11,920
checks

778
00:35:11,920 --> 00:35:14,800
that validates that

779
00:35:14,800 --> 00:35:16,960
you can interact with your own backend

780
00:35:16,960 --> 00:35:19,599
server but somehow you cannot interact

781
00:35:19,599 --> 00:35:21,920
with apple's backend server

782
00:35:21,920 --> 00:35:22,800
yeah

783
00:35:22,800 --> 00:35:27,599
which means something is going wrong but

784
00:35:27,680 --> 00:35:28,839
none of

785
00:35:28,839 --> 00:35:31,520
examples that i saw

786
00:35:31,520 --> 00:35:32,320
had

787
00:35:32,320 --> 00:35:36,480
such type of check on their site

788
00:35:36,720 --> 00:35:40,240
next scenario is

789
00:35:41,359 --> 00:35:42,960
so yeah

790
00:35:42,960 --> 00:35:44,480
my favorite one

791
00:35:44,480 --> 00:35:46,240
which works

792
00:35:46,240 --> 00:35:47,920
every time

793
00:35:47,920 --> 00:35:49,839
as of today

794
00:35:49,839 --> 00:35:52,400
you need to return that ios version is

795
00:35:52,400 --> 00:35:56,240
less than ios 14.

796
00:35:56,240 --> 00:35:59,240
uh

797
00:36:01,119 --> 00:36:02,960
you know

798
00:36:02,960 --> 00:36:05,599
many developers they are not ready to

799
00:36:05,599 --> 00:36:07,599
drop uh

800
00:36:07,599 --> 00:36:09,200
all users

801
00:36:09,200 --> 00:36:13,119
who are using devices below ios 14 yet

802
00:36:13,119 --> 00:36:16,720
and it may take few more years

803
00:36:16,720 --> 00:36:17,599
to

804
00:36:17,599 --> 00:36:20,400
make up a test

805
00:36:20,400 --> 00:36:25,960
api usage mandatory on their site

806
00:36:27,680 --> 00:36:29,359
so

807
00:36:29,359 --> 00:36:33,119
you can just hook the

808
00:36:34,160 --> 00:36:37,200
value the the return value

809
00:36:37,200 --> 00:36:39,520
of platform api

810
00:36:39,520 --> 00:36:41,200
when it checks the

811
00:36:41,200 --> 00:36:42,640
ios version

812
00:36:42,640 --> 00:36:44,640
and you are able to bypass this check it

813
00:36:44,640 --> 00:36:46,880
just won't trigger

814
00:36:46,880 --> 00:36:48,000
the whole

815
00:36:48,000 --> 00:36:51,359
key generation logic

816
00:36:52,079 --> 00:36:54,800
yeah here is a small piece of statistic

817
00:36:54,800 --> 00:36:56,400
regarding that

818
00:36:56,400 --> 00:36:57,520
uh

819
00:36:57,520 --> 00:36:59,920
it says uh

820
00:36:59,920 --> 00:37:04,800
that 10 of all ios and ipod os devices

821
00:37:04,800 --> 00:37:06,480
which is

822
00:37:06,480 --> 00:37:08,040
around

823
00:37:08,040 --> 00:37:12,320
100 million of unsupported devices are

824
00:37:12,320 --> 00:37:14,880
below ios

825
00:37:14,880 --> 00:37:16,880
14.

826
00:37:16,880 --> 00:37:18,320
and

827
00:37:18,320 --> 00:37:20,960
i think this version related bypass will

828
00:37:20,960 --> 00:37:24,560
be most efficient thing for some time

829
00:37:24,560 --> 00:37:25,760
until

830
00:37:25,760 --> 00:37:28,079
ios

831
00:37:28,079 --> 00:37:30,960
versions less than 14

832
00:37:30,960 --> 00:37:33,440
is end of life and

833
00:37:33,440 --> 00:37:37,480
not supported anymore

834
00:37:38,640 --> 00:37:42,720
i've heard an opinion from

835
00:37:42,720 --> 00:37:44,160
one

836
00:37:44,160 --> 00:37:46,720
application developer that apple has an

837
00:37:46,720 --> 00:37:50,560
ability to validate the signers

838
00:37:50,560 --> 00:37:54,000
provisioning provisioning certificate

839
00:37:54,000 --> 00:37:56,800
on their back end before returning the

840
00:37:56,800 --> 00:38:00,079
attestation object

841
00:38:00,079 --> 00:38:02,880
it was his understanding

842
00:38:02,880 --> 00:38:05,760
of the test api description

843
00:38:05,760 --> 00:38:08,720
so in simple words his assumption was

844
00:38:08,720 --> 00:38:09,920
that

845
00:38:09,920 --> 00:38:14,880
apple can see that i resigned the app

846
00:38:14,880 --> 00:38:18,720
with the developers provision in a

847
00:38:18,720 --> 00:38:22,720
certificate with my own certificate

848
00:38:22,720 --> 00:38:24,240
and

849
00:38:24,240 --> 00:38:28,000
apple could detect it somehow

850
00:38:28,240 --> 00:38:29,359
and

851
00:38:29,359 --> 00:38:32,560
just don't allow me to

852
00:38:32,560 --> 00:38:36,160
start this key generation process

853
00:38:36,160 --> 00:38:39,200
and as you can see on the screenshot it

854
00:38:39,200 --> 00:38:42,240
was kind of wrong assumption and anyone

855
00:38:42,240 --> 00:38:46,880
can modify your app touch its logic and

856
00:38:46,880 --> 00:38:49,599
resign it and still generate valid

857
00:38:49,599 --> 00:38:52,320
attestation object after all

858
00:38:52,320 --> 00:38:53,920
and

859
00:38:53,920 --> 00:38:56,240
yeah

860
00:38:57,280 --> 00:38:59,599
it will be

861
00:38:59,599 --> 00:39:03,599
assembled with the wrong values

862
00:39:03,599 --> 00:39:07,119
to your back end but at least it it

863
00:39:07,119 --> 00:39:08,160
still

864
00:39:08,160 --> 00:39:11,920
remain valid in terms of its format and

865
00:39:11,920 --> 00:39:15,040
apple's signature in it so

866
00:39:15,040 --> 00:39:17,119
if you parse it right

867
00:39:17,119 --> 00:39:21,520
it won't be valid or on your back end

868
00:39:22,240 --> 00:39:24,880
however as i described before

869
00:39:24,880 --> 00:39:29,720
once i saw the case

870
00:39:30,240 --> 00:39:32,800
when attestation object was not

871
00:39:32,800 --> 00:39:35,200
correctly processed and

872
00:39:35,200 --> 00:39:38,480
literally any value was correct

873
00:39:38,480 --> 00:39:39,520
for the

874
00:39:39,520 --> 00:39:41,839
to the back end

875
00:39:41,839 --> 00:39:45,520
yeah it's properly packed cbor object

876
00:39:45,520 --> 00:39:49,040
so please remember to implement and test

877
00:39:49,040 --> 00:39:52,160
everything as it's recommended in the

878
00:39:52,160 --> 00:39:56,839
documentation by apple

879
00:39:57,280 --> 00:39:58,160
okay

880
00:39:58,160 --> 00:40:01,760
now i think it's time to

881
00:40:01,760 --> 00:40:03,040
summarize

882
00:40:03,040 --> 00:40:04,720
all the

883
00:40:04,720 --> 00:40:07,839
benefits and bottlenecks

884
00:40:07,839 --> 00:40:12,800
that app a test api gives to us

885
00:40:12,800 --> 00:40:13,839
so

886
00:40:13,839 --> 00:40:16,640
on the bright side

887
00:40:16,640 --> 00:40:18,560
we can use it definitely against the

888
00:40:18,560 --> 00:40:21,040
replay attacks

889
00:40:21,040 --> 00:40:22,160
if we

890
00:40:22,160 --> 00:40:25,040
trust the whole process of key

891
00:40:25,040 --> 00:40:29,119
generation and stuff definitely

892
00:40:29,280 --> 00:40:31,760
some companies can really

893
00:40:31,760 --> 00:40:33,119
benefit from

894
00:40:33,119 --> 00:40:37,680
implementing this fraud metric analysis

895
00:40:37,680 --> 00:40:40,960
and maybe apple can extend

896
00:40:40,960 --> 00:40:45,119
the list of metric data in the future

897
00:40:46,240 --> 00:40:48,880
it really could increase anti-tampering

898
00:40:48,880 --> 00:40:51,040
protection as additional layer of

899
00:40:51,040 --> 00:40:54,160
security by leveraging bypass complexity

900
00:40:54,160 --> 00:40:57,920
for already implemented rasp checks

901
00:40:57,920 --> 00:41:00,319
so in other words

902
00:41:00,319 --> 00:41:01,920
i want to say that

903
00:41:01,920 --> 00:41:02,960
you

904
00:41:02,960 --> 00:41:05,280
if you need anti-tampering

905
00:41:05,280 --> 00:41:09,520
you still have to code a lot of things

906
00:41:09,520 --> 00:41:12,560
on a client side

907
00:41:12,560 --> 00:41:16,000
and maybe in the future it really might

908
00:41:16,000 --> 00:41:19,280
become an industry standard once it's

909
00:41:19,280 --> 00:41:22,160
supported by a 100 percent of ios

910
00:41:22,160 --> 00:41:24,160
devices why not

911
00:41:24,160 --> 00:41:26,800
i think it will be harder to

912
00:41:26,800 --> 00:41:29,440
find logical bypasses for

913
00:41:29,440 --> 00:41:32,079
this technology

914
00:41:32,079 --> 00:41:34,400
and now it's time to summarize

915
00:41:34,400 --> 00:41:38,079
all the bottlenecks

916
00:41:38,079 --> 00:41:41,760
on a constraint site

917
00:41:41,760 --> 00:41:44,400
it's still not possible to validate if

918
00:41:44,400 --> 00:41:46,960
application is already running on

919
00:41:46,960 --> 00:41:49,839
compromised device

920
00:41:50,240 --> 00:41:51,520
so

921
00:41:51,520 --> 00:41:54,640
if device has been jailbroken after the

922
00:41:54,640 --> 00:41:56,240
key attestation

923
00:41:56,240 --> 00:41:58,319
all the new assertions

924
00:41:58,319 --> 00:42:01,119
might be tempered so and you won't

925
00:42:01,119 --> 00:42:02,480
detect

926
00:42:02,480 --> 00:42:03,440
uh

927
00:42:03,440 --> 00:42:06,000
even using this apple's fraud metric

928
00:42:06,000 --> 00:42:08,480
because you can just hook

929
00:42:08,480 --> 00:42:10,800
the application behavior during the

930
00:42:10,800 --> 00:42:12,079
runtime

931
00:42:12,079 --> 00:42:13,760
and

932
00:42:13,760 --> 00:42:19,680
the outgoing request will be signed on

933
00:42:21,280 --> 00:42:23,040
using the test

934
00:42:23,040 --> 00:42:24,880
valid attestation

935
00:42:24,880 --> 00:42:25,839
so

936
00:42:25,839 --> 00:42:28,720
you will trust the object on your back

937
00:42:28,720 --> 00:42:33,359
end so there is no reason to

938
00:42:34,000 --> 00:42:36,319
try

939
00:42:36,560 --> 00:42:38,000
to break the

940
00:42:38,000 --> 00:42:39,599
signature method

941
00:42:39,599 --> 00:42:42,720
if you can just uh

942
00:42:42,720 --> 00:42:46,240
tamper on valley values before

943
00:42:46,240 --> 00:42:49,520
signing the request

944
00:42:49,680 --> 00:42:50,560
uh

945
00:42:50,560 --> 00:42:54,160
then it's yeah kinda

946
00:42:54,160 --> 00:42:56,640
useless as of now because it has

947
00:42:56,640 --> 00:42:58,960
multiple design issues

948
00:42:58,960 --> 00:43:00,400
and

949
00:43:00,400 --> 00:43:03,760
success of this implementation strongly

950
00:43:03,760 --> 00:43:06,319
depends on

951
00:43:06,319 --> 00:43:08,240
on the integrator

952
00:43:08,240 --> 00:43:12,560
so there is a human factor in it

953
00:43:12,560 --> 00:43:16,240
uh yeah one more limitation is that if

954
00:43:16,240 --> 00:43:19,200
your development if you're developing

955
00:43:19,200 --> 00:43:21,520
app extension

956
00:43:21,520 --> 00:43:24,240
and want to use the

957
00:43:24,240 --> 00:43:26,800
the app test api

958
00:43:26,800 --> 00:43:31,359
you can't because it it's not supported

959
00:43:31,359 --> 00:43:34,720
and i don't know whether it's uh

960
00:43:34,720 --> 00:43:38,079
a big concern but you still depend on

961
00:43:38,079 --> 00:43:40,800
the third party you depend on apple's

962
00:43:40,800 --> 00:43:43,040
backend server and

963
00:43:43,040 --> 00:43:45,040
if it's not working

964
00:43:45,040 --> 00:43:46,560
so

965
00:43:46,560 --> 00:43:48,880
i i understand it's

966
00:43:48,880 --> 00:43:52,560
unlikely it it won't be working but

967
00:43:52,560 --> 00:43:54,960
if it happens

968
00:43:54,960 --> 00:43:58,560
it means your app is not working as well

969
00:43:58,560 --> 00:44:01,839
and uh yeah as i said number of

970
00:44:01,839 --> 00:44:04,960
unsupported devices is still

971
00:44:04,960 --> 00:44:08,560
very big so developers are not ready to

972
00:44:08,560 --> 00:44:09,599
drop

973
00:44:09,599 --> 00:44:12,800
all these new potential users to their

974
00:44:12,800 --> 00:44:14,800
app

975
00:44:14,800 --> 00:44:18,560
to improve their security

976
00:44:19,680 --> 00:44:22,319
and yeah now it's time to decide to

977
00:44:22,319 --> 00:44:25,280
answer that question if it's

978
00:44:25,280 --> 00:44:27,440
worth to implement this technology or

979
00:44:27,440 --> 00:44:28,720
not

980
00:44:28,720 --> 00:44:30,319
uh actually

981
00:44:30,319 --> 00:44:31,599
yeah

982
00:44:31,599 --> 00:44:35,119
the simple answer is uh that

983
00:44:35,119 --> 00:44:38,079
you need to listen to your uh security

984
00:44:38,079 --> 00:44:40,480
experts security champions

985
00:44:40,480 --> 00:44:42,400
you need to understand your risk level

986
00:44:42,400 --> 00:44:44,480
and threat model

987
00:44:44,480 --> 00:44:46,800
and

988
00:44:47,040 --> 00:44:49,119
if you really

989
00:44:49,119 --> 00:44:51,280
decide to implement it

990
00:44:51,280 --> 00:44:53,520
and if you are confident

991
00:44:53,520 --> 00:44:54,400
to

992
00:44:54,400 --> 00:44:58,400
have it properly implemented

993
00:44:58,400 --> 00:45:01,920
you have to be ready to work with all

994
00:45:01,920 --> 00:45:04,480
possible caveats

995
00:45:04,480 --> 00:45:05,760
on your own

996
00:45:05,760 --> 00:45:06,560
so

997
00:45:06,560 --> 00:45:09,280
as we just discussed

998
00:45:09,280 --> 00:45:10,960
it won't help you

999
00:45:10,960 --> 00:45:12,960
so the apa test won't help you to

1000
00:45:12,960 --> 00:45:17,760
identify if device is jailbroken or not

1001
00:45:17,760 --> 00:45:19,599
so which means you have to implement

1002
00:45:19,599 --> 00:45:22,560
jailbreak detection and it have to be on

1003
00:45:22,560 --> 00:45:24,000
client side

1004
00:45:24,000 --> 00:45:26,160
which as you remember could be easily

1005
00:45:26,160 --> 00:45:28,319
tempered sometimes

1006
00:45:28,319 --> 00:45:29,440
but okay

1007
00:45:29,440 --> 00:45:31,480
then to fight with runtime

1008
00:45:31,480 --> 00:45:34,800
instrumentation and dynamic analysis

1009
00:45:34,800 --> 00:45:37,440
you need to implement your

1010
00:45:37,440 --> 00:45:39,680
own hooking detection and debugger

1011
00:45:39,680 --> 00:45:41,839
detection checks

1012
00:45:41,839 --> 00:45:44,480
and still even despite upper testing

1013
00:45:44,480 --> 00:45:47,440
sort of anti-tampering solution

1014
00:45:47,440 --> 00:45:49,960
you need to have client-side

1015
00:45:49,960 --> 00:45:53,119
anti-timeframe protections to make it

1016
00:45:53,119 --> 00:45:57,440
harder to statically patch your app and

1017
00:45:57,440 --> 00:45:58,800
resign it

1018
00:45:58,800 --> 00:46:01,359
because you remember the bypass scenario

1019
00:46:01,359 --> 00:46:03,839
number two or number three ah yeah it

1020
00:46:03,839 --> 00:46:06,800
was number three we just watched it and

1021
00:46:06,800 --> 00:46:10,000
resigned the app so

1022
00:46:10,000 --> 00:46:12,800
hypertest won't even trigger it in this

1023
00:46:12,800 --> 00:46:15,280
case

1024
00:46:15,280 --> 00:46:17,599
and in the end definitely

1025
00:46:17,599 --> 00:46:20,000
quite important part to make

1026
00:46:20,000 --> 00:46:22,160
attackers life harder

1027
00:46:22,160 --> 00:46:24,960
you have to

1028
00:46:24,960 --> 00:46:28,560
implement obfuscation layers it must be

1029
00:46:28,560 --> 00:46:30,800
it must be strong enough

1030
00:46:30,800 --> 00:46:33,440
to increase

1031
00:46:34,880 --> 00:46:37,040
the whole analysis

1032
00:46:37,040 --> 00:46:41,880
the complexity of this process

1033
00:46:42,640 --> 00:46:45,680
so in conclusion i want to say that we

1034
00:46:45,680 --> 00:46:48,560
can't create trusted anti-time print

1035
00:46:48,560 --> 00:46:51,280
check using only this api

1036
00:46:51,280 --> 00:46:52,880
so

1037
00:46:52,880 --> 00:46:55,599
every evaluated solution should be

1038
00:46:55,599 --> 00:46:56,880
backed up

1039
00:46:56,880 --> 00:46:59,119
by

1040
00:46:59,200 --> 00:47:01,599
current

1041
00:47:01,599 --> 00:47:04,880
client site protection mechanisms which

1042
00:47:04,880 --> 00:47:06,319
are

1043
00:47:06,319 --> 00:47:08,839
well known and

1044
00:47:08,839 --> 00:47:11,520
described on the different

1045
00:47:11,520 --> 00:47:14,800
resources such as avast mstg

1046
00:47:14,800 --> 00:47:17,359
so i'm talking about

1047
00:47:17,359 --> 00:47:19,520
anti-tampering jailbreak cooking

1048
00:47:19,520 --> 00:47:21,280
detection

1049
00:47:21,280 --> 00:47:24,160
uh

1050
00:47:24,160 --> 00:47:26,319
it will help you to ensure that

1051
00:47:26,319 --> 00:47:29,280
information provided by upper test is

1052
00:47:29,280 --> 00:47:33,760
not modified in the first instance

1053
00:47:33,760 --> 00:47:36,240
sometimes pre even preor

1054
00:47:36,240 --> 00:47:38,240
the

1055
00:47:38,240 --> 00:47:41,920
first usage of this apotest api

1056
00:47:41,920 --> 00:47:44,480
we also have to take in consideration

1057
00:47:44,480 --> 00:47:48,160
that this api is available only from ios

1058
00:47:48,160 --> 00:47:49,520
14

1059
00:47:49,520 --> 00:47:53,520
and yeah we have to wait until

1060
00:47:53,520 --> 00:47:55,040
it supports

1061
00:47:55,040 --> 00:47:56,400
it supports

1062
00:47:56,400 --> 00:47:59,040
vast majority of

1063
00:47:59,040 --> 00:48:00,880
apple devices

1064
00:48:00,880 --> 00:48:03,040
and

1065
00:48:03,040 --> 00:48:04,319
because of that

1066
00:48:04,319 --> 00:48:05,440
i'm

1067
00:48:05,440 --> 00:48:08,720
i recommend to implement this technology

1068
00:48:08,720 --> 00:48:09,640
only in

1069
00:48:09,640 --> 00:48:13,040
experimental mode

1070
00:48:13,119 --> 00:48:15,280
and definitely following the close

1071
00:48:15,280 --> 00:48:19,280
interaction with your security team

1072
00:48:19,599 --> 00:48:20,880
because

1073
00:48:20,880 --> 00:48:22,880
um

1074
00:48:22,880 --> 00:48:26,240
it's necessary not for every product it

1075
00:48:26,240 --> 00:48:28,640
costs money to achieve this efficient

1076
00:48:28,640 --> 00:48:31,040
level of protection so

1077
00:48:31,040 --> 00:48:32,000
uh

1078
00:48:32,000 --> 00:48:34,559
make sure it's really necessary for your

1079
00:48:34,559 --> 00:48:37,760
project before starting playing this

1080
00:48:37,760 --> 00:48:41,599
cat and mouse game with the hackers

1081
00:48:41,599 --> 00:48:43,839
and

1082
00:48:46,000 --> 00:48:49,839
trust me they are always

1083
00:48:50,800 --> 00:48:52,640
competitive

1084
00:48:52,640 --> 00:48:53,680
always

1085
00:48:53,680 --> 00:48:56,400
find bypasses and you

1086
00:48:56,400 --> 00:48:59,119
need to improve your protections

1087
00:48:59,119 --> 00:49:02,119
continuously

1088
00:49:02,480 --> 00:49:05,040
yeah definitely

1089
00:49:05,040 --> 00:49:07,440
i believe there is always a room for

1090
00:49:07,440 --> 00:49:09,440
improvement so

1091
00:49:09,440 --> 00:49:11,280
if you feel that something could be

1092
00:49:11,280 --> 00:49:14,240
improved in this analysis

1093
00:49:14,240 --> 00:49:18,000
or in the whole talk that is

1094
00:49:18,000 --> 00:49:19,839
the explanation part

1095
00:49:19,839 --> 00:49:22,800
so don't hesitate to reach out to me i'm

1096
00:49:22,800 --> 00:49:25,200
planning to continue keeping an eye on

1097
00:49:25,200 --> 00:49:28,839
this technology to see how it evolves or

1098
00:49:28,839 --> 00:49:30,559
whether

1099
00:49:30,559 --> 00:49:31,599
other

1100
00:49:31,599 --> 00:49:34,160
bypass scenarios are

1101
00:49:34,160 --> 00:49:36,720
possible

1102
00:49:39,200 --> 00:49:42,240
here you can find the link to my github

1103
00:49:42,240 --> 00:49:45,440
rip repo with all code i used for this

1104
00:49:45,440 --> 00:49:47,839
presentation

1105
00:49:47,839 --> 00:49:50,400
as i said my implementation doesn't have

1106
00:49:50,400 --> 00:49:53,359
a full-fledged server side so if you

1107
00:49:53,359 --> 00:49:56,240
really need it and don't want to code it

1108
00:49:56,240 --> 00:49:59,200
from scratch please take a look at this

1109
00:49:59,200 --> 00:50:00,160
nice

1110
00:50:00,160 --> 00:50:02,800
secondary repository with the server

1111
00:50:02,800 --> 00:50:04,960
side implementation it's written in

1112
00:50:04,960 --> 00:50:06,240
kotlin

1113
00:50:06,240 --> 00:50:07,200
and

1114
00:50:07,200 --> 00:50:08,000
yeah

1115
00:50:08,000 --> 00:50:10,800
you may want to check wasp mstg if you

1116
00:50:10,800 --> 00:50:12,559
want to know more about the tech

1117
00:50:12,559 --> 00:50:14,960
techniques and protections that we

1118
00:50:14,960 --> 00:50:17,839
discussed today

1119
00:50:17,839 --> 00:50:18,720
and

1120
00:50:18,720 --> 00:50:21,839
the last batch is related to official

1121
00:50:21,839 --> 00:50:24,720
documentation from apple

1122
00:50:24,720 --> 00:50:27,119
kinda must read if you want to get more

1123
00:50:27,119 --> 00:50:30,079
details about this technology but be

1124
00:50:30,079 --> 00:50:31,520
ready

1125
00:50:31,520 --> 00:50:33,839
that documentation

1126
00:50:33,839 --> 00:50:35,599
sometimes

1127
00:50:35,599 --> 00:50:38,960
can is confusing

1128
00:50:39,040 --> 00:50:41,839
and that's mostly it i want to say thank

1129
00:50:41,839 --> 00:50:44,079
you for watching this talk

1130
00:50:44,079 --> 00:50:47,200
and yeah huge respect to the organizers

1131
00:50:47,200 --> 00:50:49,040
of this conference

1132
00:50:49,040 --> 00:50:52,400
so for many of us folks interesting

1133
00:50:52,400 --> 00:50:55,040
interested in cyber security all over

1134
00:50:55,040 --> 00:50:56,559
the world

1135
00:50:56,559 --> 00:51:00,480
uh yeah we are happy to have such events

1136
00:51:00,480 --> 00:51:03,040
during this covet pandemic time

1137
00:51:03,040 --> 00:51:04,079
uh

1138
00:51:04,079 --> 00:51:05,280
yeah

1139
00:51:05,280 --> 00:51:07,680
hope to see you

1140
00:51:07,680 --> 00:51:10,800
irl in the next maybe next year

1141
00:51:10,800 --> 00:51:16,040
so yeah goodbye everybody and stay safe

