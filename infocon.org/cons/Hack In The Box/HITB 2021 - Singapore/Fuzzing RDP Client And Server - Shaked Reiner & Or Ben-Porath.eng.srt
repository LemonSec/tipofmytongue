1
00:00:06,399 --> 00:00:09,440
greetings everyone we are excited to be

2
00:00:09,440 --> 00:00:11,920
here with you today at hacking the box

3
00:00:11,920 --> 00:00:14,240
um this is holding the stick at both

4
00:00:14,240 --> 00:00:17,440
ends fuzzing the rdp client and server

5
00:00:17,440 --> 00:00:19,680
um we'll start with a quick word about

6
00:00:19,680 --> 00:00:22,000
ourselves um

7
00:00:22,000 --> 00:00:24,000
my name is jacqued raynor i am a

8
00:00:24,000 --> 00:00:27,039
security researcher at cyrus labs and

9
00:00:27,039 --> 00:00:30,480
with me today i have ore ben porat who

10
00:00:30,480 --> 00:00:32,558
is also a security researcher

11
00:00:32,558 --> 00:00:35,200
in our group and we are here to tell you

12
00:00:35,200 --> 00:00:39,760
about our journey into fuzzing rdp

13
00:00:39,760 --> 00:00:42,320
our agenda for this session will be as

14
00:00:42,320 --> 00:00:43,440
follows

15
00:00:43,440 --> 00:00:45,280
first we're going to talk about our

16
00:00:45,280 --> 00:00:48,239
motivation going into this project

17
00:00:48,239 --> 00:00:50,640
we'll also provide some of the basics

18
00:00:50,640 --> 00:00:51,840
needed

19
00:00:51,840 --> 00:00:54,160
in rdp in order to get

20
00:00:54,160 --> 00:00:56,320
fuzzing started

21
00:00:56,320 --> 00:00:58,800
then we should jump right into the deep

22
00:00:58,800 --> 00:00:59,840
end

23
00:00:59,840 --> 00:01:01,440
and start to build our fuzzing

24
00:01:01,440 --> 00:01:03,920
environment from the ground up um we'll

25
00:01:03,920 --> 00:01:05,760
also try to explain what made this

26
00:01:05,760 --> 00:01:08,320
fuzzing target uh quite unique

27
00:01:08,320 --> 00:01:10,560
um and how we were able to

28
00:01:10,560 --> 00:01:12,880
overcome the challenges that we faced

29
00:01:12,880 --> 00:01:16,479
until we were able to fuzz it finally

30
00:01:16,479 --> 00:01:18,400
after that we will talk about the

31
00:01:18,400 --> 00:01:20,320
results of our journey

32
00:01:20,320 --> 00:01:22,479
we will also dissect one of the issues

33
00:01:22,479 --> 00:01:24,479
that we were able to find

34
00:01:24,479 --> 00:01:27,600
in rdp and finally we will have the

35
00:01:27,600 --> 00:01:30,000
mandatory summary slide and we should

36
00:01:30,000 --> 00:01:32,320
also discuss some future work

37
00:01:32,320 --> 00:01:34,079
opportunities

38
00:01:34,079 --> 00:01:37,040
so without further ado let's go right

39
00:01:37,040 --> 00:01:40,560
ahead and start with rdp

40
00:01:40,560 --> 00:01:43,200
so this is what the end user usually

41
00:01:43,200 --> 00:01:45,200
knows as rdp

42
00:01:45,200 --> 00:01:47,920
or the remote desktop protocol we

43
00:01:47,920 --> 00:01:50,560
probably all know this flow by now

44
00:01:50,560 --> 00:01:52,799
you need to access a remote windows

45
00:01:52,799 --> 00:01:56,000
machine so you fire up mstsc.exe and

46
00:01:56,000 --> 00:01:58,000
you're ready to go it's pretty pretty

47
00:01:58,000 --> 00:01:58,960
simple

48
00:01:58,960 --> 00:02:02,240
um but as we are soon to find out there

49
00:02:02,240 --> 00:02:04,159
is plenty that is going on behind the

50
00:02:04,159 --> 00:02:06,640
scenes in order to make this remote

51
00:02:06,640 --> 00:02:08,800
connection possible

52
00:02:08,800 --> 00:02:10,878
but before we get into that let's talk

53
00:02:10,878 --> 00:02:13,760
about the motivation

54
00:02:13,760 --> 00:02:16,640
so using a simple shot and query

55
00:02:16,640 --> 00:02:18,720
we see that there are almost four and a

56
00:02:18,720 --> 00:02:21,360
half million rdp servers

57
00:02:21,360 --> 00:02:23,760
exposed to the internet

58
00:02:23,760 --> 00:02:25,440
and as you may imagine there are plenty

59
00:02:25,440 --> 00:02:28,080
more behind different firewalls or

60
00:02:28,080 --> 00:02:30,480
inside some internal networks or

61
00:02:30,480 --> 00:02:32,879
something along the lines of these

62
00:02:32,879 --> 00:02:37,200
so rdp is widely used by windows user

63
00:02:37,200 --> 00:02:40,239
users for their remote access

64
00:02:40,239 --> 00:02:42,239
purposes

65
00:02:42,239 --> 00:02:45,200
but how can this serve an attacker

66
00:02:45,200 --> 00:02:46,959
mainly there are two

67
00:02:46,959 --> 00:02:50,560
attack vectors for attacker

68
00:02:50,720 --> 00:02:52,560
so the first one is the more traditional

69
00:02:52,560 --> 00:02:55,440
in a sense um and in this one the

70
00:02:55,440 --> 00:02:57,840
attacker is trying to get access into an

71
00:02:57,840 --> 00:02:59,440
internal network

72
00:02:59,440 --> 00:03:01,360
um there is an rdp server in that

73
00:03:01,360 --> 00:03:04,800
network which is exposed to the internet

74
00:03:04,800 --> 00:03:06,800
um but of course the attackers doesn't

75
00:03:06,800 --> 00:03:08,879
the attackers don't have any credentials

76
00:03:08,879 --> 00:03:12,400
for it for obvious reasons um

77
00:03:12,400 --> 00:03:14,000
so the attacker can exploit a

78
00:03:14,000 --> 00:03:17,519
vulnerability in the rdp server and use

79
00:03:17,519 --> 00:03:20,159
it in order to gain access unauthorized

80
00:03:20,159 --> 00:03:22,640
access to the server and from there to

81
00:03:22,640 --> 00:03:25,920
the entire network

82
00:03:25,920 --> 00:03:28,560
as for the second vector it is not as

83
00:03:28,560 --> 00:03:29,840
common

84
00:03:29,840 --> 00:03:32,879
and it targets the rdp client rather

85
00:03:32,879 --> 00:03:34,560
than the server

86
00:03:34,560 --> 00:03:36,959
here we have an attacker who was already

87
00:03:36,959 --> 00:03:39,200
able to gain access to some sort of a

88
00:03:39,200 --> 00:03:41,760
server or a virtual machine inside the

89
00:03:41,760 --> 00:03:43,120
network

90
00:03:43,120 --> 00:03:45,840
and they can wait for an administrator

91
00:03:45,840 --> 00:03:48,720
um to connect to the server

92
00:03:48,720 --> 00:03:51,120
then exploit a vulnerability within the

93
00:03:51,120 --> 00:03:52,959
rdp client

94
00:03:52,959 --> 00:03:55,200
this time which will allow them to gain

95
00:03:55,200 --> 00:03:57,200
the administrator's privileges and

96
00:03:57,200 --> 00:04:00,560
execute code on their machine

97
00:04:00,560 --> 00:04:02,640
so this is the second vector

98
00:04:02,640 --> 00:04:05,200
now these are not merely theoretical

99
00:04:05,200 --> 00:04:07,920
attack vectors um there have been some

100
00:04:07,920 --> 00:04:09,920
real life examples for both of them in

101
00:04:09,920 --> 00:04:11,599
the last few years

102
00:04:11,599 --> 00:04:13,840
um and to name a couple

103
00:04:13,840 --> 00:04:15,120
deja blue

104
00:04:15,120 --> 00:04:18,000
which was an integer overflow bug in a

105
00:04:18,000 --> 00:04:21,199
decompression function in the rdp server

106
00:04:21,199 --> 00:04:24,240
that allowed attackers to run arbitrary

107
00:04:24,240 --> 00:04:26,880
code remotely

108
00:04:26,880 --> 00:04:29,360
and for the second vector we had a

109
00:04:29,360 --> 00:04:32,960
reverse rdp which was a path traversal

110
00:04:32,960 --> 00:04:36,400
bug in microsoft's rdp client um that

111
00:04:36,400 --> 00:04:39,280
allowed um an rdp server controlled by

112
00:04:39,280 --> 00:04:41,440
an attacker to run arbitrary

113
00:04:41,440 --> 00:04:43,280
applications on

114
00:04:43,280 --> 00:04:46,479
a client that is connecting to it

115
00:04:46,479 --> 00:04:48,560
so these are the two examples that we

116
00:04:48,560 --> 00:04:49,600
give

117
00:04:49,600 --> 00:04:52,800
um so we can agree that rdp can be a

118
00:04:52,800 --> 00:04:55,759
lucrative target for attackers but why

119
00:04:55,759 --> 00:04:58,400
do you think we should follow it um to

120
00:04:58,400 --> 00:05:00,160
answer that let's have a quick look at

121
00:05:00,160 --> 00:05:02,639
the rdp attack surface

122
00:05:02,639 --> 00:05:05,280
um and as you can see from this simple

123
00:05:05,280 --> 00:05:06,400
file

124
00:05:06,400 --> 00:05:10,240
listing query in powershell um on a

125
00:05:10,240 --> 00:05:12,479
vanilla windows installation

126
00:05:12,479 --> 00:05:16,400
we have more than 190 rdp related

127
00:05:16,400 --> 00:05:17,520
libraries

128
00:05:17,520 --> 00:05:21,120
drivers executables and so on

129
00:05:21,120 --> 00:05:23,360
so it's quite a lot of code

130
00:05:23,360 --> 00:05:25,680
and at this point manual review

131
00:05:25,680 --> 00:05:27,680
doesn't really sound like

132
00:05:27,680 --> 00:05:29,840
a great option and this is why we chose

133
00:05:29,840 --> 00:05:32,800
to go with fuzzing in this case

134
00:05:32,800 --> 00:05:35,120
but before we can start fuzzing we need

135
00:05:35,120 --> 00:05:37,360
to understand some basics

136
00:05:37,360 --> 00:05:40,160
about rdp or the remote desktop protocol

137
00:05:40,160 --> 00:05:42,080
again

138
00:05:42,080 --> 00:05:45,120
um so naturally we go and we try to read

139
00:05:45,120 --> 00:05:46,880
the docs

140
00:05:46,880 --> 00:05:48,960
and after you download the relevant file

141
00:05:48,960 --> 00:05:50,320
from msdn

142
00:05:50,320 --> 00:05:53,199
you can see that you have around 30 uh

143
00:05:53,199 --> 00:05:55,600
specification documents with hundreds of

144
00:05:55,600 --> 00:05:58,479
pages in each of them and sadly not a

145
00:05:58,479 --> 00:06:00,639
lot of pictures and as you can see

146
00:06:00,639 --> 00:06:02,880
clearly we have a lot of reading

147
00:06:02,880 --> 00:06:05,360
material so we should try to boil it

148
00:06:05,360 --> 00:06:08,000
down to the absolute essentials

149
00:06:08,000 --> 00:06:11,680
for us before we get into the fuzzing

150
00:06:11,680 --> 00:06:16,080
so rdp is indeed a complex protocol

151
00:06:16,080 --> 00:06:19,039
it relies on several layers of protocols

152
00:06:19,039 --> 00:06:20,639
and standards

153
00:06:20,639 --> 00:06:22,400
in order to be able to function and

154
00:06:22,400 --> 00:06:24,639
operate

155
00:06:24,639 --> 00:06:27,280
it runs over tcp usually although udp is

156
00:06:27,280 --> 00:06:29,120
also an option

157
00:06:29,120 --> 00:06:32,080
and it uses as you can see here tpkt

158
00:06:32,080 --> 00:06:33,680
x.224

159
00:06:33,680 --> 00:06:34,440
and

160
00:06:34,440 --> 00:06:36,720
t.125 mcs

161
00:06:36,720 --> 00:06:38,639
for data encapsulation that's quite a

162
00:06:38,639 --> 00:06:39,680
mouthful

163
00:06:39,680 --> 00:06:42,880
um so this is the protocol stack of rdp

164
00:06:42,880 --> 00:06:45,120
now nrdp connection has some general

165
00:06:45,120 --> 00:06:47,039
features that define it that we thought

166
00:06:47,039 --> 00:06:50,000
should be worth mentioning um the first

167
00:06:50,000 --> 00:06:52,319
one is negotiation

168
00:06:52,319 --> 00:06:54,479
many of the connections functionality

169
00:06:54,479 --> 00:06:57,440
can be negotiated between the client and

170
00:06:57,440 --> 00:06:59,919
the server and these are things like the

171
00:06:59,919 --> 00:07:02,800
security level of the connection um the

172
00:07:02,800 --> 00:07:05,280
encryption and compression algorithms

173
00:07:05,280 --> 00:07:07,520
that are being used in the connection on

174
00:07:07,520 --> 00:07:11,199
the supported audio um and video formats

175
00:07:11,199 --> 00:07:13,039
for instance and and many other things

176
00:07:13,039 --> 00:07:16,720
that are negotiated so the client has um

177
00:07:16,720 --> 00:07:19,520
some sort of uh an effect on the connect

178
00:07:19,520 --> 00:07:21,440
on how the connection will look like

179
00:07:21,440 --> 00:07:24,000
because of this negotiation scheme

180
00:07:24,000 --> 00:07:27,039
um other than that um

181
00:07:27,039 --> 00:07:30,800
rdp also have uh data compression so in

182
00:07:30,800 --> 00:07:33,360
some of the layers of rdp the data being

183
00:07:33,360 --> 00:07:36,479
sent is compressed by the sender

184
00:07:36,479 --> 00:07:39,520
and later decompressed by the receiver

185
00:07:39,520 --> 00:07:42,160
compression code can be erroneous many

186
00:07:42,160 --> 00:07:43,120
times

187
00:07:43,120 --> 00:07:45,919
so having a lot of data compression uh

188
00:07:45,919 --> 00:07:48,560
logic in our target is really a great

189
00:07:48,560 --> 00:07:50,800
thing and this is of course from the

190
00:07:50,800 --> 00:07:53,199
attacker's standpoint um and again for

191
00:07:53,199 --> 00:07:55,599
example deja blue from uh that we

192
00:07:55,599 --> 00:07:59,039
mentioned before was a decompression uh

193
00:07:59,039 --> 00:08:00,879
issue

194
00:08:00,879 --> 00:08:04,240
uh next we have also security in rdp so

195
00:08:04,240 --> 00:08:06,160
the protocol has some security features

196
00:08:06,160 --> 00:08:08,800
built into it um so for example it

197
00:08:08,800 --> 00:08:10,560
mandates some sort of

198
00:08:10,560 --> 00:08:13,759
data encryption level to be activated

199
00:08:13,759 --> 00:08:16,319
and we it makes the protocol somewhat

200
00:08:16,319 --> 00:08:18,879
secure at the base level so these are

201
00:08:18,879 --> 00:08:20,639
the the general stuff that you should

202
00:08:20,639 --> 00:08:22,319
know

203
00:08:22,319 --> 00:08:23,680
now let's have a look at the following

204
00:08:23,680 --> 00:08:25,520
diagram and get a little bit more

205
00:08:25,520 --> 00:08:27,440
specific about rdp

206
00:08:27,440 --> 00:08:30,479
um so i like to refer to rdp as a

207
00:08:30,479 --> 00:08:32,719
protocol of protocols and i think the

208
00:08:32,719 --> 00:08:35,519
first one to coin the term was um

209
00:08:35,519 --> 00:08:37,440
malwaretech

210
00:08:37,440 --> 00:08:39,120
in one of his blogs

211
00:08:39,120 --> 00:08:40,799
and i've been using it since because

212
00:08:40,799 --> 00:08:43,440
it's really kind of true

213
00:08:43,440 --> 00:08:44,959
so as you can see an rdp connection is

214
00:08:44,959 --> 00:08:47,360
comprised of multiple different channels

215
00:08:47,360 --> 00:08:49,839
and here in front of you you can see

216
00:08:49,839 --> 00:08:52,160
different types of those channels

217
00:08:52,160 --> 00:08:55,440
so from the top um first we have static

218
00:08:55,440 --> 00:08:58,240
channels which are being opened in every

219
00:08:58,240 --> 00:09:00,560
connection no matter what they are

220
00:09:00,560 --> 00:09:03,440
basics to they are basic and essential

221
00:09:03,440 --> 00:09:05,200
for rtp

222
00:09:05,200 --> 00:09:08,160
um next we have virtual static channels

223
00:09:08,160 --> 00:09:10,160
which are an extension

224
00:09:10,160 --> 00:09:12,399
to the static channels

225
00:09:12,399 --> 00:09:14,080
and those are optional

226
00:09:14,080 --> 00:09:16,480
meaning they are negotiated in the

227
00:09:16,480 --> 00:09:19,920
initialization of the connection

228
00:09:19,920 --> 00:09:21,680
and finally we also have the dynamic

229
00:09:21,680 --> 00:09:23,200
virtual channels

230
00:09:23,200 --> 00:09:25,279
that can be created and destroyed upon

231
00:09:25,279 --> 00:09:26,320
request

232
00:09:26,320 --> 00:09:28,720
throughout the connection lifetime

233
00:09:28,720 --> 00:09:30,959
and those are encapsulated within one of

234
00:09:30,959 --> 00:09:33,440
the static virtual channels that we we

235
00:09:33,440 --> 00:09:35,440
saw before

236
00:09:35,440 --> 00:09:37,279
so each of those channels

237
00:09:37,279 --> 00:09:39,440
serves a different purpose so you can

238
00:09:39,440 --> 00:09:42,080
have the user input channel a display

239
00:09:42,080 --> 00:09:44,640
monitor output channel an audio channel

240
00:09:44,640 --> 00:09:47,279
and so on and many many more

241
00:09:47,279 --> 00:09:49,920
um and every channel has its own

242
00:09:49,920 --> 00:09:52,720
initialization sequence message types

243
00:09:52,720 --> 00:09:55,040
data structures and this essentially

244
00:09:55,040 --> 00:09:57,760
makes it its own protocol and hence we

245
00:09:57,760 --> 00:09:58,640
call

246
00:09:58,640 --> 00:10:03,880
rdp the protocol of protocols

247
00:10:04,399 --> 00:10:07,920
here you can see an overview of

248
00:10:07,920 --> 00:10:10,959
the actual software components at play

249
00:10:10,959 --> 00:10:13,440
during an rdp connection

250
00:10:13,440 --> 00:10:16,240
so let's start from the right um you can

251
00:10:16,240 --> 00:10:18,399
see here we have the client

252
00:10:18,399 --> 00:10:19,640
we have

253
00:10:19,640 --> 00:10:21,360
mstsc.exe

254
00:10:21,360 --> 00:10:24,880
and it loads the mstsc aex dll

255
00:10:24,880 --> 00:10:26,880
which contains most of the protocol

256
00:10:26,880 --> 00:10:28,560
logic

257
00:10:28,560 --> 00:10:31,200
handling on the client side and of

258
00:10:31,200 --> 00:10:33,680
course as you can imagine this makes it

259
00:10:33,680 --> 00:10:37,440
a huge binary um with almost 19 000

260
00:10:37,440 --> 00:10:38,560
functions

261
00:10:38,560 --> 00:10:40,720
um and from the screenshot you can see

262
00:10:40,720 --> 00:10:42,560
that at least we are lucky enough to

263
00:10:42,560 --> 00:10:46,160
have um public symbols for most of those

264
00:10:46,160 --> 00:10:49,519
functions so at least we have that

265
00:10:49,519 --> 00:10:51,920
so this is the client now on the other

266
00:10:51,920 --> 00:10:54,480
side we have on the server and and again

267
00:10:54,480 --> 00:10:56,800
just to mention that because of the fact

268
00:10:56,800 --> 00:11:00,720
that the msdcax dll has so much code in

269
00:11:00,720 --> 00:11:01,839
it this is

270
00:11:01,839 --> 00:11:04,160
yet another reason to to go with fuzzing

271
00:11:04,160 --> 00:11:05,680
in this instance

272
00:11:05,680 --> 00:11:07,519
now to the other side do we have the

273
00:11:07,519 --> 00:11:09,519
server the server

274
00:11:09,519 --> 00:11:11,519
has a main service which is hosted

275
00:11:11,519 --> 00:11:17,519
inside svc host um with the term srv.dll

276
00:11:17,519 --> 00:11:20,320
it also loads several other dlls an

277
00:11:20,320 --> 00:11:22,480
example for those you can see here

278
00:11:22,480 --> 00:11:24,880
that handle the protocol logic in the on

279
00:11:24,880 --> 00:11:26,480
the server side

280
00:11:26,480 --> 00:11:29,040
um other than that the server also runs

281
00:11:29,040 --> 00:11:31,519
a few other processes that handle

282
00:11:31,519 --> 00:11:33,839
different uh channel information for

283
00:11:33,839 --> 00:11:36,160
example you can see here the rdp clip

284
00:11:36,160 --> 00:11:37,680
process which handles clipboard

285
00:11:37,680 --> 00:11:39,440
information

286
00:11:39,440 --> 00:11:42,320
and finally the server also has a few

287
00:11:42,320 --> 00:11:44,880
kernel modules that it loads in order to

288
00:11:44,880 --> 00:11:46,399
handle some channel

289
00:11:46,399 --> 00:11:48,160
functionality and for example you can

290
00:11:48,160 --> 00:11:51,680
see rdpdr here which is responsible for

291
00:11:51,680 --> 00:11:53,920
device redirection from the server to

292
00:11:53,920 --> 00:11:55,440
the client

293
00:11:55,440 --> 00:11:58,240
so these are our software components and

294
00:11:58,240 --> 00:12:01,120
now let me hand you over to or to

295
00:12:01,120 --> 00:12:05,200
continue and talk about fuzzing

296
00:12:06,079 --> 00:12:08,240
okay so now that we have some

297
00:12:08,240 --> 00:12:10,560
understanding of rdp and how it works

298
00:12:10,560 --> 00:12:14,079
let's start talking about how to fuzz it

299
00:12:14,079 --> 00:12:16,079
but before we do that we need to talk

300
00:12:16,079 --> 00:12:18,800
about fuzzing in general

301
00:12:18,800 --> 00:12:20,959
so this is a classic setup of what

302
00:12:20,959 --> 00:12:22,880
fuzzing looks like

303
00:12:22,880 --> 00:12:24,720
so what we have here is we have the

304
00:12:24,720 --> 00:12:26,800
target process on the right

305
00:12:26,800 --> 00:12:28,720
we have a fuzzer that generates test

306
00:12:28,720 --> 00:12:32,160
cases and inputs them to the target

307
00:12:32,160 --> 00:12:35,120
and we have the code coverage engine

308
00:12:35,120 --> 00:12:37,120
that tracks the execution flow of the

309
00:12:37,120 --> 00:12:40,399
target and reports it back to the fuzzer

310
00:12:40,399 --> 00:12:43,040
so in this example what we can see is

311
00:12:43,040 --> 00:12:45,839
the target is the pdf reader

312
00:12:45,839 --> 00:12:48,480
and the fuzzer generates the inputs

313
00:12:48,480 --> 00:12:50,800
which are pdf files

314
00:12:50,800 --> 00:12:53,760
and opens them using the reader so this

315
00:12:53,760 --> 00:12:56,000
is pretty straightforward

316
00:12:56,000 --> 00:12:59,519
but when we talk about fuzzing ldp

317
00:12:59,519 --> 00:13:01,680
how how should the fuzzing setup look

318
00:13:01,680 --> 00:13:04,320
like we can't do something exactly like

319
00:13:04,320 --> 00:13:06,720
that because first

320
00:13:06,720 --> 00:13:09,040
we have two machines fuzzing runs on two

321
00:13:09,040 --> 00:13:10,800
machines we have the client and the

322
00:13:10,800 --> 00:13:11,839
server

323
00:13:11,839 --> 00:13:13,120
and second

324
00:13:13,120 --> 00:13:16,160
we don't have a clear a clear

325
00:13:16,160 --> 00:13:18,959
option for what the input files are or

326
00:13:18,959 --> 00:13:21,279
anything of that salt

327
00:13:21,279 --> 00:13:24,160
so what can we do

328
00:13:27,279 --> 00:13:30,079
okay so let's let's see what we came up

329
00:13:30,079 --> 00:13:34,320
for for fuzzing rdp

330
00:13:34,320 --> 00:13:36,720
the first thing we had to figure out is

331
00:13:36,720 --> 00:13:39,199
how can we even send inputs to our

332
00:13:39,199 --> 00:13:40,480
target

333
00:13:40,480 --> 00:13:44,000
whether it is the server or the client

334
00:13:44,000 --> 00:13:45,600
so when we started the project we had a

335
00:13:45,600 --> 00:13:47,519
few options

336
00:13:47,519 --> 00:13:49,680
the first one was to take an open source

337
00:13:49,680 --> 00:13:52,000
rdp client or server

338
00:13:52,000 --> 00:13:54,560
and modify it so that it will send our

339
00:13:54,560 --> 00:13:57,199
fuzzing messages

340
00:13:57,199 --> 00:13:59,120
the second one was to write everything

341
00:13:59,120 --> 00:14:01,760
from scratch write our own client or

342
00:14:01,760 --> 00:14:06,079
father and use that to send our inputs

343
00:14:06,079 --> 00:14:08,160
the third one was to use

344
00:14:08,160 --> 00:14:10,240
snapshot based fuzzing

345
00:14:10,240 --> 00:14:13,920
snapshot based fuzzing has the advantage

346
00:14:13,920 --> 00:14:17,680
that you don't really need to to

347
00:14:17,680 --> 00:14:19,760
recreate the connection every time

348
00:14:19,760 --> 00:14:21,680
basically you just go back to the

349
00:14:21,680 --> 00:14:22,959
snapshot

350
00:14:22,959 --> 00:14:25,600
change the input in memory and continue

351
00:14:25,600 --> 00:14:27,360
from there

352
00:14:27,360 --> 00:14:29,760
and finally we have the option of

353
00:14:29,760 --> 00:14:33,600
leaving off the land meaning we tap into

354
00:14:33,600 --> 00:14:36,800
some existing connect rdp connection

355
00:14:36,800 --> 00:14:39,199
and use exported apis

356
00:14:39,199 --> 00:14:42,320
or code injection to send our fuzzing

357
00:14:42,320 --> 00:14:44,560
messages

358
00:14:44,560 --> 00:14:47,199
and eventually what we did is for the

359
00:14:47,199 --> 00:14:49,839
client side we decided to use existing

360
00:14:49,839 --> 00:14:52,560
solutions and the reason we did that is

361
00:14:52,560 --> 00:14:56,240
because the ldp server exposes very

362
00:14:56,240 --> 00:14:59,600
convenient apis that you can use to send

363
00:14:59,600 --> 00:15:02,480
messages to the client

364
00:15:02,480 --> 00:15:05,279
and for the server side we chose to

365
00:15:05,279 --> 00:15:09,279
modify an open source namely open rdp

366
00:15:09,279 --> 00:15:12,560
and you modified it so that it will send

367
00:15:12,560 --> 00:15:14,160
our messages

368
00:15:14,160 --> 00:15:17,839
as well as the regular messages

369
00:15:18,880 --> 00:15:22,320
so here is the basic uh the basic idea

370
00:15:22,320 --> 00:15:23,120
of

371
00:15:23,120 --> 00:15:26,320
how fuzzing the client looks like and

372
00:15:26,320 --> 00:15:28,560
let me just say that the credit for this

373
00:15:28,560 --> 00:15:32,240
architecture is to park young kim kim

374
00:15:32,240 --> 00:15:33,600
and lee

375
00:15:33,600 --> 00:15:35,839
from korea university and you should

376
00:15:35,839 --> 00:15:38,320
really check out the blackett talk from

377
00:15:38,320 --> 00:15:41,600
2019 that we linked here

378
00:15:41,600 --> 00:15:44,000
now what we can see here is on the right

379
00:15:44,000 --> 00:15:46,399
hand side we have uh something very

380
00:15:46,399 --> 00:15:48,160
similar to what we had in the classic

381
00:15:48,160 --> 00:15:50,399
fuzzer so we have our target which is

382
00:15:50,399 --> 00:15:52,160
the rdp client

383
00:15:52,160 --> 00:15:54,160
and we have the father and the code

384
00:15:54,160 --> 00:15:56,880
coverage engine as before

385
00:15:56,880 --> 00:15:59,600
now the main difference is in how the

386
00:15:59,600 --> 00:16:02,240
the input messages are sent from the

387
00:16:02,240 --> 00:16:06,839
fuzzel to the tag to the target source

388
00:16:06,839 --> 00:16:10,160
and the difference is that the input

389
00:16:10,160 --> 00:16:12,800
messages are first moved from the client

390
00:16:12,800 --> 00:16:15,519
side to the server side

391
00:16:15,519 --> 00:16:18,639
and then our an an agent that we wrote

392
00:16:18,639 --> 00:16:22,000
takes this message and sends it over to

393
00:16:22,000 --> 00:16:24,000
our target so it looks something like

394
00:16:24,000 --> 00:16:26,240
this

395
00:16:27,519 --> 00:16:30,079
and let me just remark that

396
00:16:30,079 --> 00:16:33,199
the the basic idea is the same for the

397
00:16:33,199 --> 00:16:35,600
server side fuzzing just

398
00:16:35,600 --> 00:16:39,040
basically mirror the image

399
00:16:40,160 --> 00:16:42,480
now we did some optimization especially

400
00:16:42,480 --> 00:16:44,480
for the client side

401
00:16:44,480 --> 00:16:47,440
and we ended up with something like this

402
00:16:47,440 --> 00:16:49,680
so the first thing you should note is

403
00:16:49,680 --> 00:16:53,120
now there is just one machine

404
00:16:53,120 --> 00:16:55,839
and what we have is that again the on

405
00:16:55,839 --> 00:16:57,360
the right we have the target file

406
00:16:57,360 --> 00:17:01,279
function which is now mstsc.exe

407
00:17:01,279 --> 00:17:03,680
and we have our code coverage engine

408
00:17:03,680 --> 00:17:05,039
which is

409
00:17:05,039 --> 00:17:07,119
using dynamo rio

410
00:17:07,119 --> 00:17:09,039
and win afl

411
00:17:09,039 --> 00:17:12,640
and we have our father which is f alphas

412
00:17:12,640 --> 00:17:15,679
now the main difference is that instead

413
00:17:15,679 --> 00:17:18,240
of connecting to a server side we are

414
00:17:18,240 --> 00:17:20,959
just connecting to

415
00:17:20,959 --> 00:17:23,679
to localhost to the same machine using

416
00:17:23,679 --> 00:17:25,119
ldp

417
00:17:25,119 --> 00:17:27,839
so we can run everything locally

418
00:17:27,839 --> 00:17:30,400
and we we don't need to send the input

419
00:17:30,400 --> 00:17:32,960
messages from one side to the other

420
00:17:32,960 --> 00:17:35,120
so we just send them to the agent which

421
00:17:35,120 --> 00:17:37,200
runs on the same machine and it sends it

422
00:17:37,200 --> 00:17:38,080
over

423
00:17:38,080 --> 00:17:40,400
to the target as if it was from the

424
00:17:40,400 --> 00:17:42,080
server

425
00:17:42,080 --> 00:17:44,559
now the upshot of that is that when we

426
00:17:44,559 --> 00:17:47,440
can have multiple instance instances of

427
00:17:47,440 --> 00:17:48,559
the same

428
00:17:48,559 --> 00:17:51,520
father and target on the same machine

429
00:17:51,520 --> 00:17:54,480
so we ran concurrently 10

430
00:17:54,480 --> 00:17:58,559
fuzzing instances on the same machine

431
00:17:59,520 --> 00:18:00,480
okay

432
00:18:00,480 --> 00:18:01,520
so

433
00:18:01,520 --> 00:18:03,120
the next thing we did

434
00:18:03,120 --> 00:18:05,679
is we chose what what are we even

435
00:18:05,679 --> 00:18:08,240
fuzzing what are we sending

436
00:18:08,240 --> 00:18:09,200
because

437
00:18:09,200 --> 00:18:11,280
practically every channel as we said is

438
00:18:11,280 --> 00:18:14,480
its own protocol we chose to fuzz

439
00:18:14,480 --> 00:18:16,799
what was what we call channel by channel

440
00:18:16,799 --> 00:18:18,960
so every time we we would pick one

441
00:18:18,960 --> 00:18:20,880
channel and we would fast that

442
00:18:20,880 --> 00:18:22,559
independently

443
00:18:22,559 --> 00:18:24,640
and because for the most part channels

444
00:18:24,640 --> 00:18:25,440
are

445
00:18:25,440 --> 00:18:28,320
their own protocol we can cover most of

446
00:18:28,320 --> 00:18:30,480
the logic of a channel just by fuzzing

447
00:18:30,480 --> 00:18:32,480
it alone and disregarding everything

448
00:18:32,480 --> 00:18:34,720
else

449
00:18:36,400 --> 00:18:37,919
now here is a

450
00:18:37,919 --> 00:18:39,600
i will make some

451
00:18:39,600 --> 00:18:41,760
a technical remark

452
00:18:41,760 --> 00:18:45,120
when we try to fuzz the server we had a

453
00:18:45,120 --> 00:18:47,600
bit of a problem because

454
00:18:47,600 --> 00:18:49,840
the server is

455
00:18:49,840 --> 00:18:53,200
a pos it runs on a process service on

456
00:18:53,200 --> 00:18:55,760
the system that runs from from the boot

457
00:18:55,760 --> 00:18:57,760
of the system

458
00:18:57,760 --> 00:19:00,400
and in classic fastening and in dynamo

459
00:19:00,400 --> 00:19:02,720
rio and win afl solutions

460
00:19:02,720 --> 00:19:06,000
the father has to control the creation

461
00:19:06,000 --> 00:19:08,320
of the target process

462
00:19:08,320 --> 00:19:11,039
so in order to overcome it we had to add

463
00:19:11,039 --> 00:19:13,679
a functionality to dynamo rio that will

464
00:19:13,679 --> 00:19:17,120
attach to an already running service

465
00:19:17,120 --> 00:19:18,799
and this is kind of tricky because there

466
00:19:18,799 --> 00:19:22,000
are there are many uh places you can

467
00:19:22,000 --> 00:19:24,160
fall about threads that are already

468
00:19:24,160 --> 00:19:26,799
running and might be terminating when

469
00:19:26,799 --> 00:19:29,120
you take over them

470
00:19:29,120 --> 00:19:31,600
in any case we took an existing

471
00:19:31,600 --> 00:19:33,520
pull request and we

472
00:19:33,520 --> 00:19:36,160
that was never merged into the code of

473
00:19:36,160 --> 00:19:39,360
dynamo rio and we made it work we added

474
00:19:39,360 --> 00:19:41,600
some functionality functionality on top

475
00:19:41,600 --> 00:19:43,039
of it

476
00:19:43,039 --> 00:19:45,200
and let me just say that if you find any

477
00:19:45,200 --> 00:19:48,880
of this useful you can use our dynamorio

478
00:19:48,880 --> 00:19:51,840
build from our github github page that

479
00:19:51,840 --> 00:19:52,799
we will

480
00:19:52,799 --> 00:19:54,000
add

481
00:19:54,000 --> 00:19:57,760
in the end of the talk

482
00:19:58,559 --> 00:20:02,320
okay so now that we have a connection

483
00:20:02,320 --> 00:20:05,360
and we know how to send messages we come

484
00:20:05,360 --> 00:20:08,640
into the first problem when we send

485
00:20:08,640 --> 00:20:10,320
when we take over a live connection

486
00:20:10,320 --> 00:20:12,320
there are many many messages that are

487
00:20:12,320 --> 00:20:13,360
sent

488
00:20:13,360 --> 00:20:15,679
from the client to the server and back

489
00:20:15,679 --> 00:20:17,440
that have nothing to do with the puzzle

490
00:20:17,440 --> 00:20:19,280
this is a live connection there's a lot

491
00:20:19,280 --> 00:20:21,679
of that lots of data going from one side

492
00:20:21,679 --> 00:20:23,840
to the other

493
00:20:23,840 --> 00:20:25,600
and we need to find a way to

494
00:20:25,600 --> 00:20:28,080
differentiate this data from the

495
00:20:28,080 --> 00:20:30,240
messages that we sent as part of the

496
00:20:30,240 --> 00:20:32,400
fuzzing process

497
00:20:32,400 --> 00:20:35,760
so this would look something like this

498
00:20:35,760 --> 00:20:37,840
what you can see here is the a few

499
00:20:37,840 --> 00:20:40,480
normal messages that are transferred on

500
00:20:40,480 --> 00:20:41,679
the connection

501
00:20:41,679 --> 00:20:45,280
and the last one is our fuzzing message

502
00:20:45,280 --> 00:20:47,440
this is a test case that was generated

503
00:20:47,440 --> 00:20:49,360
by the fuzzer

504
00:20:49,360 --> 00:20:51,760
now in order for coverage guided fuzzing

505
00:20:51,760 --> 00:20:54,000
to work there must be a one-to-one

506
00:20:54,000 --> 00:20:56,480
correspondence between the inputs and

507
00:20:56,480 --> 00:20:59,840
the code path that they triggered

508
00:20:59,840 --> 00:21:02,320
so to do that we developed what we call

509
00:21:02,320 --> 00:21:04,000
background fuzzing

510
00:21:04,000 --> 00:21:06,320
that is differentiating our fuzzing

511
00:21:06,320 --> 00:21:08,640
messages from the regular messages of

512
00:21:08,640 --> 00:21:10,000
the connection

513
00:21:10,000 --> 00:21:12,720
and we need to only track code paths

514
00:21:12,720 --> 00:21:14,840
for the format for

515
00:21:14,840 --> 00:21:19,039
our messages for our fuzzing messages

516
00:21:19,039 --> 00:21:21,520
and again this is essential because if

517
00:21:21,520 --> 00:21:23,600
we track code coverage for the rest then

518
00:21:23,600 --> 00:21:25,679
the fuzzing is complete completely

519
00:21:25,679 --> 00:21:27,840
ineffective

520
00:21:27,840 --> 00:21:29,919
now the way we under identify the

521
00:21:29,919 --> 00:21:33,440
fuzzing message was by adding a marker

522
00:21:33,440 --> 00:21:35,440
so in this example the marker is the

523
00:21:35,440 --> 00:21:39,039
first byte that you can see in red

524
00:21:39,039 --> 00:21:41,440
so the agent the fuzzing agent has

525
00:21:41,440 --> 00:21:45,200
changed the marker to this extra ff

526
00:21:45,200 --> 00:21:48,480
instead of the typical exo20

527
00:21:48,480 --> 00:21:50,640
and the target detects it

528
00:21:50,640 --> 00:21:53,200
and it restores it to 20 before the

529
00:21:53,200 --> 00:21:54,559
execution

530
00:21:54,559 --> 00:21:56,480
before the the message is actually

531
00:21:56,480 --> 00:21:58,559
handled by the target

532
00:21:58,559 --> 00:22:00,480
and that allows us to identify the

533
00:22:00,480 --> 00:22:01,600
different

534
00:22:01,600 --> 00:22:04,640
the different types of messages

535
00:22:04,640 --> 00:22:07,039
so let's take an example

536
00:22:07,039 --> 00:22:09,600
here we can see the the the

537
00:22:09,600 --> 00:22:12,640
documentation of the rdp sound virtual

538
00:22:12,640 --> 00:22:13,840
channel

539
00:22:13,840 --> 00:22:16,559
and this sound this this channel is used

540
00:22:16,559 --> 00:22:19,120
to redirect sounds from the server to

541
00:22:19,120 --> 00:22:21,200
the client

542
00:22:21,200 --> 00:22:22,960
now according to the documentation the

543
00:22:22,960 --> 00:22:25,120
first byte of every message

544
00:22:25,120 --> 00:22:28,159
is the type of the message that is sent

545
00:22:28,159 --> 00:22:30,240
and the supported values for these

546
00:22:30,240 --> 00:22:35,200
message types goes from 1 to x and d

547
00:22:35,200 --> 00:22:37,280
now what we can do in this case is we

548
00:22:37,280 --> 00:22:39,360
can use the most significant bit of the

549
00:22:39,360 --> 00:22:42,960
first byte as our fuzzing marker so we

550
00:22:42,960 --> 00:22:45,360
do something like this the agent will

551
00:22:45,360 --> 00:22:47,919
turn on the most significant bit of the

552
00:22:47,919 --> 00:22:50,799
first byte before it sends the message

553
00:22:50,799 --> 00:22:53,200
and win affair on the other side will

554
00:22:53,200 --> 00:22:55,760
check if the most significant bit is on

555
00:22:55,760 --> 00:22:56,960
or not

556
00:22:56,960 --> 00:23:00,000
if it is on then it knows that this is

557
00:23:00,000 --> 00:23:02,240
our fuzzing message

558
00:23:02,240 --> 00:23:04,480
and it will turn it off it will turn it

559
00:23:04,480 --> 00:23:07,120
back off so that execution com completes

560
00:23:07,120 --> 00:23:09,919
normally but it will track code coverage

561
00:23:09,919 --> 00:23:11,039
for this

562
00:23:11,039 --> 00:23:13,440
and if it is off to begin with then we

563
00:23:13,440 --> 00:23:15,360
can just ignore the message this is a

564
00:23:15,360 --> 00:23:17,200
background message it has nothing to do

565
00:23:17,200 --> 00:23:19,919
with the fuzzing

566
00:23:20,400 --> 00:23:21,360
okay

567
00:23:21,360 --> 00:23:22,400
so

568
00:23:22,400 --> 00:23:24,159
now that we have that we have the basic

569
00:23:24,159 --> 00:23:25,840
ability to

570
00:23:25,840 --> 00:23:27,760
fast to send our messages we

571
00:23:27,760 --> 00:23:31,600
differentiate them from the the

572
00:23:31,600 --> 00:23:33,760
background messages

573
00:23:33,760 --> 00:23:35,520
and we started fuzzing

574
00:23:35,520 --> 00:23:36,960
and we came up

575
00:23:36,960 --> 00:23:40,320
across the following problem

576
00:23:40,320 --> 00:23:41,679
basically

577
00:23:41,679 --> 00:23:44,400
whenever the target found out that there

578
00:23:44,400 --> 00:23:46,880
were two consecutive bad messages it

579
00:23:46,880 --> 00:23:49,520
would simply close the connection

580
00:23:49,520 --> 00:23:51,440
obviously this is horrible for fuzzing

581
00:23:51,440 --> 00:23:55,360
purposes and we cannot allow it

582
00:23:55,360 --> 00:23:56,080
so

583
00:23:56,080 --> 00:23:58,720
we had two approaches of how can we get

584
00:23:58,720 --> 00:23:59,919
around it

585
00:23:59,919 --> 00:24:03,120
the first was using code patches simply

586
00:24:03,120 --> 00:24:05,279
avoid this

587
00:24:05,279 --> 00:24:07,200
do not let the target close the

588
00:24:07,200 --> 00:24:09,600
connection and the second one was

589
00:24:09,600 --> 00:24:12,559
grammar enforcement meaning

590
00:24:12,559 --> 00:24:15,520
only allow the father to send messages

591
00:24:15,520 --> 00:24:18,400
that are valid enough to not close

592
00:24:18,400 --> 00:24:20,080
the connection

593
00:24:20,080 --> 00:24:23,520
so let's talk about them for a bit

594
00:24:23,840 --> 00:24:25,919
first we will talk about code patches so

595
00:24:25,919 --> 00:24:28,559
code purposes are simply

596
00:24:28,559 --> 00:24:30,159
avoiding these

597
00:24:30,159 --> 00:24:32,159
paths in the code that are bad for us to

598
00:24:32,159 --> 00:24:34,640
terminate the connection

599
00:24:34,640 --> 00:24:36,799
so this is an example from the graphics

600
00:24:36,799 --> 00:24:38,559
channel

601
00:24:38,559 --> 00:24:39,760
and

602
00:24:39,760 --> 00:24:41,840
what you can see here is that it checks

603
00:24:41,840 --> 00:24:44,080
some condition and according to the

604
00:24:44,080 --> 00:24:46,720
condition it either exits the

605
00:24:46,720 --> 00:24:47,919
process

606
00:24:47,919 --> 00:24:50,080
or it locks the arrow and it reconnects

607
00:24:50,080 --> 00:24:51,840
and tries again

608
00:24:51,840 --> 00:24:53,760
and what we did is we patched the

609
00:24:53,760 --> 00:24:56,000
conditions so it will always choose the

610
00:24:56,000 --> 00:24:58,480
path of logging and reconnecting so we

611
00:24:58,480 --> 00:24:59,679
would never

612
00:24:59,679 --> 00:25:02,880
terminate at this point

613
00:25:04,000 --> 00:25:06,720
and let me just remember that dynamo rio

614
00:25:06,720 --> 00:25:09,279
exposes a very nice functionality that

615
00:25:09,279 --> 00:25:10,960
allows you to do it

616
00:25:10,960 --> 00:25:12,840
very easily

617
00:25:12,840 --> 00:25:14,480
so

618
00:25:14,480 --> 00:25:16,240
what you can do is basically what it

619
00:25:16,240 --> 00:25:19,039
allows you to do is to take one address

620
00:25:19,039 --> 00:25:21,760
and whenever the the target

621
00:25:21,760 --> 00:25:24,320
gets to that address it will just skip

622
00:25:24,320 --> 00:25:26,400
to the address you supply it so we have

623
00:25:26,400 --> 00:25:29,200
this original target and the replacement

624
00:25:29,200 --> 00:25:31,360
the original address and the replacement

625
00:25:31,360 --> 00:25:34,000
address and we simply say that if we get

626
00:25:34,000 --> 00:25:37,600
to the bad path just jump to the correct

627
00:25:37,600 --> 00:25:41,320
path that we want

628
00:25:42,400 --> 00:25:44,000
okay now let's talk about grammar

629
00:25:44,000 --> 00:25:45,600
enforcement

630
00:25:45,600 --> 00:25:47,919
uh grammar enforcement we used it to

631
00:25:47,919 --> 00:25:49,120
enforce

632
00:25:49,120 --> 00:25:51,520
the size that we allow the messages to

633
00:25:51,520 --> 00:25:52,240
be

634
00:25:52,240 --> 00:25:55,039
and the values and the visibility of

635
00:25:55,039 --> 00:25:58,880
some of the fields that are in it

636
00:25:58,880 --> 00:26:03,039
and the question is well how do you find

637
00:26:03,039 --> 00:26:05,679
what is valid and what is not

638
00:26:05,679 --> 00:26:07,360
so we did it in the following way first

639
00:26:07,360 --> 00:26:09,279
of all we looked at the documentation

640
00:26:09,279 --> 00:26:12,640
when all is fails read the docs

641
00:26:12,640 --> 00:26:14,159
and

642
00:26:14,159 --> 00:26:16,240
microsoft has great documentation about

643
00:26:16,240 --> 00:26:18,720
rdp and we extracted most of the grammar

644
00:26:18,720 --> 00:26:20,720
from it

645
00:26:20,720 --> 00:26:23,360
but in some cases this wasn't enough so

646
00:26:23,360 --> 00:26:25,760
we reversed and engineered the actual

647
00:26:25,760 --> 00:26:27,679
code and we saw what the conditions are

648
00:26:27,679 --> 00:26:30,000
and how do we get to the failing

649
00:26:30,000 --> 00:26:31,840
conditions

650
00:26:31,840 --> 00:26:34,080
and lastly we just

651
00:26:34,080 --> 00:26:36,000
whenever when everything failed we had

652
00:26:36,000 --> 00:26:38,480
to trace our arrows and find what

653
00:26:38,480 --> 00:26:40,880
condition actually caused the errors and

654
00:26:40,880 --> 00:26:43,520
fix them

655
00:26:45,039 --> 00:26:46,880
now an important note about grammar

656
00:26:46,880 --> 00:26:50,000
enforcement is that it limits the space

657
00:26:50,000 --> 00:26:52,480
of possible test case that the fuzzer

658
00:26:52,480 --> 00:26:54,000
can generate

659
00:26:54,000 --> 00:26:56,559
so this means that we we basically limit

660
00:26:56,559 --> 00:26:58,559
the father in what it can do

661
00:26:58,559 --> 00:27:01,120
and therefore we can miss some

662
00:27:01,120 --> 00:27:03,760
interesting inputs

663
00:27:03,760 --> 00:27:05,840
and for that reason what we tried to do

664
00:27:05,840 --> 00:27:08,559
is to enforce as little as we could

665
00:27:08,559 --> 00:27:10,799
but still ensure that the connection is

666
00:27:10,799 --> 00:27:13,840
not closed too oft

667
00:27:15,440 --> 00:27:16,400
all right

668
00:27:16,400 --> 00:27:20,799
so now we have a running fuzzer it sends

669
00:27:20,799 --> 00:27:24,480
messages we detect them as we want

670
00:27:24,480 --> 00:27:28,640
but after some time we found that that

671
00:27:28,640 --> 00:27:32,080
that there was not our coverage was not

672
00:27:32,080 --> 00:27:33,520
big enough

673
00:27:33,520 --> 00:27:35,360
and what we realized is the following

674
00:27:35,360 --> 00:27:37,520
what we had is is

675
00:27:37,520 --> 00:27:40,320
every message for itself we had a single

676
00:27:40,320 --> 00:27:42,559
input messages so the father would

677
00:27:42,559 --> 00:27:45,520
create test cases and each test case is

678
00:27:45,520 --> 00:27:46,840
a single

679
00:27:46,840 --> 00:27:50,880
message and we realized that

680
00:27:50,880 --> 00:27:53,120
the reason we had load coverage is

681
00:27:53,120 --> 00:27:55,760
because a lot of the logic of the rdp

682
00:27:55,760 --> 00:27:58,240
channel depends actually not on a single

683
00:27:58,240 --> 00:27:59,679
message but

684
00:27:59,679 --> 00:28:02,720
on a sequence of messages

685
00:28:02,720 --> 00:28:05,440
and what we decided to do is to make the

686
00:28:05,440 --> 00:28:07,840
fuzzer create larger test case that are

687
00:28:07,840 --> 00:28:10,399
actually a sequence of messages so it

688
00:28:10,399 --> 00:28:12,960
would look something like this the first

689
00:28:12,960 --> 00:28:15,039
test case would be say three messages

690
00:28:15,039 --> 00:28:17,279
and the second would be two messages and

691
00:28:17,279 --> 00:28:19,760
so forth

692
00:28:20,960 --> 00:28:23,760
so let's give an example of why this is

693
00:28:23,760 --> 00:28:26,320
important so here we look at the

694
00:28:26,320 --> 00:28:28,480
graphics channel again

695
00:28:28,480 --> 00:28:32,720
and what we have here is we have this uh

696
00:28:32,720 --> 00:28:35,840
map surface to output pdu and pdu is the

697
00:28:35,840 --> 00:28:38,240
protocol data unit so it's the basic

698
00:28:38,240 --> 00:28:40,080
message

699
00:28:40,080 --> 00:28:42,640
and what it does it maps a predefined

700
00:28:42,640 --> 00:28:45,600
surface to the output buffer

701
00:28:45,600 --> 00:28:48,480
but as you can see it it accepts a

702
00:28:48,480 --> 00:28:51,440
service id that has to it that has to be

703
00:28:51,440 --> 00:28:53,200
provided to it

704
00:28:53,200 --> 00:28:55,520
and that surface id should be created

705
00:28:55,520 --> 00:29:00,080
before that using the create surface pdu

706
00:29:00,080 --> 00:29:01,279
so

707
00:29:01,279 --> 00:29:04,640
it makes no sense to send a map surface

708
00:29:04,640 --> 00:29:07,679
to output pdu without a previous create

709
00:29:07,679 --> 00:29:10,640
surface pdu with the same id

710
00:29:10,640 --> 00:29:13,360
so that's why we needed this multi-input

711
00:29:13,360 --> 00:29:14,480
fuzzing

712
00:29:14,480 --> 00:29:17,760
because to to reach the interesting uh

713
00:29:17,760 --> 00:29:20,080
code paths that uh that happen as a

714
00:29:20,080 --> 00:29:24,918
result of the map surface to output pdu

715
00:29:26,559 --> 00:29:29,440
so what we did to implement this

716
00:29:29,440 --> 00:29:32,080
is we used the winnefeld feature called

717
00:29:32,080 --> 00:29:34,080
afl dictionary

718
00:29:34,080 --> 00:29:36,080
basically afl dictionary allows you to

719
00:29:36,080 --> 00:29:39,279
define a sequence of bytes that the

720
00:29:39,279 --> 00:29:42,159
fuzzer will try in its mutations so

721
00:29:42,159 --> 00:29:44,000
you're basically telling it from time to

722
00:29:44,000 --> 00:29:45,840
time instead of just trying something

723
00:29:45,840 --> 00:29:46,880
random

724
00:29:46,880 --> 00:29:49,279
try this sequence of bytes

725
00:29:49,279 --> 00:29:52,640
and what we did is we used it to to

726
00:29:52,640 --> 00:29:55,120
separate protocol messages

727
00:29:55,120 --> 00:29:57,600
we suggested the further we would use

728
00:29:57,600 --> 00:29:58,399
the

729
00:29:58,399 --> 00:30:00,399
keywords underscore underscore

730
00:30:00,399 --> 00:30:03,200
underscore command

731
00:30:03,200 --> 00:30:06,320
whatever command number of the command

732
00:30:06,320 --> 00:30:09,840
and we would use that in the agent to

733
00:30:09,840 --> 00:30:11,760
split the messages so the test case

734
00:30:11,760 --> 00:30:13,760
would look something like this

735
00:30:13,760 --> 00:30:15,840
and the agent would split it according

736
00:30:15,840 --> 00:30:18,240
to these keywords in this manner so this

737
00:30:18,240 --> 00:30:20,080
will be three messages

738
00:30:20,080 --> 00:30:23,120
message with command type seven then two

739
00:30:23,120 --> 00:30:26,320
then three etc

740
00:30:26,320 --> 00:30:29,360
now an import important note here is we

741
00:30:29,360 --> 00:30:31,600
need the fuzzer to complete the fuzzing

742
00:30:31,600 --> 00:30:34,559
iteration only when it receives the last

743
00:30:34,559 --> 00:30:37,200
message in the sequence and to do that

744
00:30:37,200 --> 00:30:39,760
we used what we already discussed so we

745
00:30:39,760 --> 00:30:42,159
added the second marker that tells the

746
00:30:42,159 --> 00:30:43,039
the

747
00:30:43,039 --> 00:30:45,200
tells when afl that we have reached the

748
00:30:45,200 --> 00:30:47,279
last in the sequence and only then will

749
00:30:47,279 --> 00:30:51,559
it complete the fuzzing iteration

750
00:30:52,159 --> 00:30:53,679
all right

751
00:30:53,679 --> 00:30:55,679
so now we have a

752
00:30:55,679 --> 00:30:58,080
father that runs and it sends multiple

753
00:30:58,080 --> 00:30:59,679
messages

754
00:30:59,679 --> 00:31:02,880
and in some in some cases

755
00:31:02,880 --> 00:31:06,559
we had to deal with multi-channels so

756
00:31:06,559 --> 00:31:08,960
although we said most of for most

757
00:31:08,960 --> 00:31:11,120
channels they are completely independent

758
00:31:11,120 --> 00:31:13,519
that is not correct for all of them

759
00:31:13,519 --> 00:31:16,080
so this is an example for the video

760
00:31:16,080 --> 00:31:18,880
extension of ldp and this extension

761
00:31:18,880 --> 00:31:22,399
works on two different virtual channels

762
00:31:22,399 --> 00:31:25,200
one channel is for the control messages

763
00:31:25,200 --> 00:31:28,080
and one is for the actual video data so

764
00:31:28,080 --> 00:31:29,919
what you can see here is the the first

765
00:31:29,919 --> 00:31:30,720
two

766
00:31:30,720 --> 00:31:32,720
messages are sent over the control

767
00:31:32,720 --> 00:31:35,840
channel basically the server telling the

768
00:31:35,840 --> 00:31:38,159
client hey listen i'm going to send you

769
00:31:38,159 --> 00:31:39,039
some

770
00:31:39,039 --> 00:31:41,760
video data and the client says sure go

771
00:31:41,760 --> 00:31:42,799
ahead

772
00:31:42,799 --> 00:31:45,919
and then the actual data is transferred

773
00:31:45,919 --> 00:31:48,559
on a different channel

774
00:31:48,559 --> 00:31:51,840
so here we needed to somehow send

775
00:31:51,840 --> 00:31:54,240
multiple messages on two different

776
00:31:54,240 --> 00:31:56,240
channels

777
00:31:56,240 --> 00:31:58,640
and we did it in a very similar manner

778
00:31:58,640 --> 00:32:00,799
basically

779
00:32:00,799 --> 00:32:04,480
we split the messages and as before

780
00:32:04,480 --> 00:32:07,519
but the type of the message also told

781
00:32:07,519 --> 00:32:10,240
the agent on which channel it should

782
00:32:10,240 --> 00:32:11,200
send

783
00:32:11,200 --> 00:32:13,200
the message to the target

784
00:32:13,200 --> 00:32:16,480
so for example here say a message

785
00:32:16,480 --> 00:32:19,760
of type 7 should go to the control

786
00:32:19,760 --> 00:32:22,480
message of type 2 should go to the data

787
00:32:22,480 --> 00:32:24,320
and message of type 3 should go to the

788
00:32:24,320 --> 00:32:27,720
control again

789
00:32:28,159 --> 00:32:29,440
okay

790
00:32:29,440 --> 00:32:32,720
so now we have almost everything

791
00:32:32,720 --> 00:32:34,480
but we had some

792
00:32:34,480 --> 00:32:37,600
basic challenge and that was actually

793
00:32:37,600 --> 00:32:38,720
finding

794
00:32:38,720 --> 00:32:42,960
where the target function is meaning

795
00:32:42,960 --> 00:32:45,760
the the the codebase for ldp as we saw

796
00:32:45,760 --> 00:32:47,039
is huge

797
00:32:47,039 --> 00:32:47,840
and

798
00:32:47,840 --> 00:32:49,919
the it's how to locate

799
00:32:49,919 --> 00:32:52,159
which code actually deals with the

800
00:32:52,159 --> 00:32:55,120
messages that we're sending

801
00:32:55,120 --> 00:32:56,480
so

802
00:32:56,480 --> 00:33:00,640
to do this what we did is we downloaded

803
00:33:00,640 --> 00:33:04,240
every pdb that was relevant to rdp

804
00:33:04,240 --> 00:33:06,640
and form it we extracted all the

805
00:33:06,640 --> 00:33:08,799
function names

806
00:33:08,799 --> 00:33:11,279
and we inserted these names into a small

807
00:33:11,279 --> 00:33:14,559
database that links a function name to

808
00:33:14,559 --> 00:33:18,000
the binary itranzi

809
00:33:18,080 --> 00:33:19,279
and

810
00:33:19,279 --> 00:33:20,960
what we found that really helped us

811
00:33:20,960 --> 00:33:23,440
speed things up is that

812
00:33:23,440 --> 00:33:24,720
typically

813
00:33:24,720 --> 00:33:27,760
the target function had the pattern c

814
00:33:27,760 --> 00:33:30,399
class name so say i don't know graphics

815
00:33:30,399 --> 00:33:32,720
client channel

816
00:33:32,720 --> 00:33:34,640
on data received

817
00:33:34,640 --> 00:33:36,640
so what we did is we grabbed all of

818
00:33:36,640 --> 00:33:39,200
those and that gave us a list of

819
00:33:39,200 --> 00:33:41,279
candidate target functions that we can

820
00:33:41,279 --> 00:33:43,360
scan through and see if any of them are

821
00:33:43,360 --> 00:33:46,159
relevant to the message the messages

822
00:33:46,159 --> 00:33:49,360
that we're sending on a given channel

823
00:33:49,360 --> 00:33:52,159
and let me just make a side note that it

824
00:33:52,159 --> 00:33:54,320
would be very helpful and very

825
00:33:54,320 --> 00:33:57,760
interesting to have a database of all on

826
00:33:57,760 --> 00:33:59,120
all available

827
00:33:59,120 --> 00:34:02,480
info and function names of all public

828
00:34:02,480 --> 00:34:04,799
microsoft pdbs

829
00:34:04,799 --> 00:34:07,600
and we didn't get around to it but if

830
00:34:07,600 --> 00:34:09,520
someone wants to take the challenge we

831
00:34:09,520 --> 00:34:11,760
think it will be very beneficial for the

832
00:34:11,760 --> 00:34:13,599
security field to have

833
00:34:13,599 --> 00:34:16,960
such a database

834
00:34:19,440 --> 00:34:23,918
okay so a few fuzzing iterations later

835
00:34:23,918 --> 00:34:26,239
we found our first crash

836
00:34:26,239 --> 00:34:28,638
hora

837
00:34:29,280 --> 00:34:33,119
but alas we had some more issues so

838
00:34:33,119 --> 00:34:37,040
we we started getting crashes

839
00:34:37,040 --> 00:34:38,320
but

840
00:34:38,320 --> 00:34:40,879
what we did is we took those uh inputs

841
00:34:40,879 --> 00:34:42,639
that generate the crashes and we tried

842
00:34:42,639 --> 00:34:45,199
to run them on a clean machine

843
00:34:45,199 --> 00:34:48,079
without the fuzzing environment and

844
00:34:48,079 --> 00:34:50,159
unfortunately some of them did not

845
00:34:50,159 --> 00:34:54,879
reproduce this would simply not crash

846
00:34:54,960 --> 00:34:57,440
and our assumption was that it has to do

847
00:34:57,440 --> 00:34:59,599
with the state of the protocol at the

848
00:34:59,599 --> 00:35:02,400
time of the crash so basically some

849
00:35:02,400 --> 00:35:04,640
previous message put the connection in

850
00:35:04,640 --> 00:35:07,280
the right state and then the crashing

851
00:35:07,280 --> 00:35:11,119
input would crash the the target

852
00:35:11,119 --> 00:35:13,760
so it will come up with a solution

853
00:35:13,760 --> 00:35:15,680
that will allow us to

854
00:35:15,680 --> 00:35:18,079
understand crashes even if we cannot

855
00:35:18,079 --> 00:35:19,520
reproduce them

856
00:35:19,520 --> 00:35:22,960
and we came up with the following

857
00:35:23,520 --> 00:35:24,320
so

858
00:35:24,320 --> 00:35:26,240
i know this looks scary but don't worry

859
00:35:26,240 --> 00:35:28,160
it will be fine

860
00:35:28,160 --> 00:35:29,760
basically what we had is we had this

861
00:35:29,760 --> 00:35:33,119
watchdog in watchdog in the middle

862
00:35:33,119 --> 00:35:34,079
and

863
00:35:34,079 --> 00:35:37,440
every time the target would crash

864
00:35:37,440 --> 00:35:40,720
the watchdog would detect it

865
00:35:40,720 --> 00:35:43,599
and the target will hang until the

866
00:35:43,599 --> 00:35:45,680
watchdog had time to create a full

867
00:35:45,680 --> 00:35:49,359
memory dump of the target

868
00:35:49,359 --> 00:35:51,520
next we had a powershell script that

869
00:35:51,520 --> 00:35:53,599
sampled this folder

870
00:35:53,599 --> 00:35:54,640
and

871
00:35:54,640 --> 00:35:57,359
used the windbag script to automatically

872
00:35:57,359 --> 00:35:59,359
analyze the dump

873
00:35:59,359 --> 00:36:02,079
and find the crashing call stack now

874
00:36:02,079 --> 00:36:04,000
this is not

875
00:36:04,000 --> 00:36:06,640
this is not completely trivial because

876
00:36:06,640 --> 00:36:09,760
the crash we had to we had to analyze

877
00:36:09,760 --> 00:36:12,160
some dynamic rear structures to find the

878
00:36:12,160 --> 00:36:14,000
actual call stack

879
00:36:14,000 --> 00:36:16,000
but after that we have the call stack of

880
00:36:16,000 --> 00:36:18,640
the crash and what we did is we would

881
00:36:18,640 --> 00:36:21,119
check it against previous previous call

882
00:36:21,119 --> 00:36:22,880
stacks

883
00:36:22,880 --> 00:36:25,040
and if it is new

884
00:36:25,040 --> 00:36:28,160
we would alert ourselves and send us an

885
00:36:28,160 --> 00:36:30,320
email telling us

886
00:36:30,320 --> 00:36:32,560
hey you got something new and let's

887
00:36:32,560 --> 00:36:34,160
check it

888
00:36:34,160 --> 00:36:35,119
and

889
00:36:35,119 --> 00:36:36,560
we know it is

890
00:36:36,560 --> 00:36:38,720
a bit hacky but

891
00:36:38,720 --> 00:36:41,280
we came here to hack and besides it

892
00:36:41,280 --> 00:36:44,320
worked quite well

893
00:36:45,200 --> 00:36:48,000
so this is what the exciting email looks

894
00:36:48,000 --> 00:36:51,359
like here you can see a clash in in

895
00:36:51,359 --> 00:36:52,560
a

896
00:36:52,560 --> 00:36:54,400
audio channel

897
00:36:54,400 --> 00:36:56,480
and

898
00:36:56,480 --> 00:36:59,920
you get that you're very happy

899
00:37:00,320 --> 00:37:02,640
now i will let your cad talk about the

900
00:37:02,640 --> 00:37:04,400
results

901
00:37:04,400 --> 00:37:06,880
all right let's talk about results

902
00:37:06,880 --> 00:37:08,800
um so in front of you you can see an

903
00:37:08,800 --> 00:37:10,960
example for one of the stat screens of

904
00:37:10,960 --> 00:37:12,400
afl

905
00:37:12,400 --> 00:37:14,000
for one of the channels that we've

906
00:37:14,000 --> 00:37:15,599
followed

907
00:37:15,599 --> 00:37:17,599
and you can see here that the execution

908
00:37:17,599 --> 00:37:20,320
speed is not that fast

909
00:37:20,320 --> 00:37:23,440
to say the least however uh the father

910
00:37:23,440 --> 00:37:25,680
did manage to find some crashes that we

911
00:37:25,680 --> 00:37:26,960
can work with

912
00:37:26,960 --> 00:37:28,960
and if we take a look at an overview of

913
00:37:28,960 --> 00:37:31,119
the numbers uh we were fuzzing for

914
00:37:31,119 --> 00:37:33,680
around one month and this is actual

915
00:37:33,680 --> 00:37:35,920
actual father's running

916
00:37:35,920 --> 00:37:38,880
we fast 15 channels in both directions

917
00:37:38,880 --> 00:37:41,440
um the client and the server and we were

918
00:37:41,440 --> 00:37:44,640
able to find five bugs in rdp

919
00:37:44,640 --> 00:37:47,839
um so now i will dissect one of those

920
00:37:47,839 --> 00:37:50,640
bugs for you and we can see and we can

921
00:37:50,640 --> 00:37:52,480
better understand

922
00:37:52,480 --> 00:37:53,599
what

923
00:37:53,599 --> 00:37:56,480
those types of bugs

924
00:37:56,480 --> 00:37:58,480
look like

925
00:37:58,480 --> 00:37:59,280
so

926
00:37:59,280 --> 00:38:02,079
this bug was found in the audio playback

927
00:38:02,079 --> 00:38:04,880
channel and what is this channel

928
00:38:04,880 --> 00:38:07,920
basically it's it just redirects sound

929
00:38:07,920 --> 00:38:10,640
sounds from the server to the client so

930
00:38:10,640 --> 00:38:12,800
the client can hear whatever is going on

931
00:38:12,800 --> 00:38:14,079
on the server

932
00:38:14,079 --> 00:38:15,359
side

933
00:38:15,359 --> 00:38:17,359
so it all started with this

934
00:38:17,359 --> 00:38:19,520
crashing stack as you can see from this

935
00:38:19,520 --> 00:38:22,160
wind bag screenshot

936
00:38:22,160 --> 00:38:25,200
and as you can see

937
00:38:25,200 --> 00:38:29,839
the crashing function was on wave data

938
00:38:29,839 --> 00:38:32,720
and if we take a closer look at the

939
00:38:32,720 --> 00:38:35,280
crashing input that caused it

940
00:38:35,280 --> 00:38:37,119
we can see this

941
00:38:37,119 --> 00:38:39,599
and here this is a good example for why

942
00:38:39,599 --> 00:38:42,000
the multi input fuzzing that ore talked

943
00:38:42,000 --> 00:38:43,359
about

944
00:38:43,359 --> 00:38:46,079
was helpful in the rdp case

945
00:38:46,079 --> 00:38:47,440
since this

946
00:38:47,440 --> 00:38:48,640
particular

947
00:38:48,640 --> 00:38:50,880
input that caused the crash

948
00:38:50,880 --> 00:38:53,440
involves four different pdus or four

949
00:38:53,440 --> 00:38:56,000
different protocol messages

950
00:38:56,000 --> 00:38:57,920
as you can see

951
00:38:57,920 --> 00:38:59,920
all right so naturally we'll go to the

952
00:38:59,920 --> 00:39:02,160
crashing code and and try to understand

953
00:39:02,160 --> 00:39:04,720
uh what's going on there um and after we

954
00:39:04,720 --> 00:39:06,960
clean up the pseudocode a little bit um

955
00:39:06,960 --> 00:39:09,440
this is the crashing function

956
00:39:09,440 --> 00:39:13,119
um so based on the crashing stack uh we

957
00:39:13,119 --> 00:39:15,359
know that the crash happens in the last

958
00:39:15,359 --> 00:39:18,000
line of code here uh where we have the

959
00:39:18,000 --> 00:39:19,599
access to

960
00:39:19,599 --> 00:39:23,119
an element inside the formats array um

961
00:39:23,119 --> 00:39:24,560
and now we should try to understand a

962
00:39:24,560 --> 00:39:27,040
little bit better what this array is all

963
00:39:27,040 --> 00:39:28,800
about

964
00:39:28,800 --> 00:39:30,400
and before we dive into

965
00:39:30,400 --> 00:39:32,160
understanding what triggers the crash

966
00:39:32,160 --> 00:39:34,079
and what is this array uh let's have

967
00:39:34,079 --> 00:39:35,280
another

968
00:39:35,280 --> 00:39:38,480
high level look at what may a legitimate

969
00:39:38,480 --> 00:39:42,560
flow in this channel uh look like

970
00:39:42,560 --> 00:39:45,280
so first we have the server which sends

971
00:39:45,280 --> 00:39:49,280
a list of the um sound formats that it

972
00:39:49,280 --> 00:39:52,160
supports um to the client

973
00:39:52,160 --> 00:39:54,400
now when the client gets it um it

974
00:39:54,400 --> 00:39:55,520
creates

975
00:39:55,520 --> 00:39:58,560
or it allocates an array um containing

976
00:39:58,560 --> 00:40:00,800
all of the details on those sound

977
00:40:00,800 --> 00:40:03,680
formats for a later use when it will

978
00:40:03,680 --> 00:40:06,240
need to process uh sound messages from

979
00:40:06,240 --> 00:40:08,000
the server

980
00:40:08,000 --> 00:40:09,680
then the server is basically free to

981
00:40:09,680 --> 00:40:10,960
send

982
00:40:10,960 --> 00:40:13,200
sound information in any of the formats

983
00:40:13,200 --> 00:40:15,359
that were announced before

984
00:40:15,359 --> 00:40:18,240
um and finally the client uses the

985
00:40:18,240 --> 00:40:20,319
format index that it gets from the

986
00:40:20,319 --> 00:40:22,800
server in order to access the format

987
00:40:22,800 --> 00:40:25,359
array and process the data

988
00:40:25,359 --> 00:40:27,520
so in this example you can see that in

989
00:40:27,520 --> 00:40:30,160
the first message the server announced

990
00:40:30,160 --> 00:40:33,520
an array of three supported formats um

991
00:40:33,520 --> 00:40:35,599
and then the server used

992
00:40:35,599 --> 00:40:39,040
the third format in one of its data

993
00:40:39,040 --> 00:40:41,119
packets of sound

994
00:40:41,119 --> 00:40:44,160
so this is a legitimate flow

995
00:40:44,160 --> 00:40:47,119
now based on the crashing input

996
00:40:47,119 --> 00:40:49,520
we can understand what happened before

997
00:40:49,520 --> 00:40:52,880
the crash so let's see how it goes

998
00:40:52,880 --> 00:40:55,839
so much like in the legitimate flow um

999
00:40:55,839 --> 00:40:58,160
the server sends a list of three formats

1000
00:40:58,160 --> 00:41:00,640
that it supports

1001
00:41:00,640 --> 00:41:02,960
then the client allocates an array for

1002
00:41:02,960 --> 00:41:04,640
those three formats and stores the

1003
00:41:04,640 --> 00:41:06,560
information there

1004
00:41:06,560 --> 00:41:07,680
after that

1005
00:41:07,680 --> 00:41:09,280
and again this is like the legitimate

1006
00:41:09,280 --> 00:41:11,520
flow the server sends

1007
00:41:11,520 --> 00:41:14,560
some data in format three

1008
00:41:14,560 --> 00:41:16,560
and the client processes it

1009
00:41:16,560 --> 00:41:19,359
pretty normally

1010
00:41:19,359 --> 00:41:21,359
uh now it gets interesting

1011
00:41:21,359 --> 00:41:23,760
what happens next is that the server um

1012
00:41:23,760 --> 00:41:26,160
updates the list of supported formats

1013
00:41:26,160 --> 00:41:28,480
and this time with a list that contains

1014
00:41:28,480 --> 00:41:30,480
only one sound format

1015
00:41:30,480 --> 00:41:33,200
um practically causing the client to

1016
00:41:33,200 --> 00:41:36,800
free the format array of three

1017
00:41:36,800 --> 00:41:38,079
sound formats

1018
00:41:38,079 --> 00:41:40,720
and to allocate a new array with only

1019
00:41:40,720 --> 00:41:43,920
one sound format

1020
00:41:43,920 --> 00:41:46,800
next the server sends

1021
00:41:46,800 --> 00:41:49,680
some sound information message uh with

1022
00:41:49,680 --> 00:41:51,760
format three again

1023
00:41:51,760 --> 00:41:55,119
even though um the client now only has

1024
00:41:55,119 --> 00:41:56,960
one format to work with

1025
00:41:56,960 --> 00:41:59,839
and as you may imagine uh the client

1026
00:41:59,839 --> 00:42:02,400
tries to access the third format

1027
00:42:02,400 --> 00:42:04,800
inside the format of only inside of an

1028
00:42:04,800 --> 00:42:07,520
array of only one format and practically

1029
00:42:07,520 --> 00:42:10,400
causing it to crash

1030
00:42:10,400 --> 00:42:12,640
so if we have another look at the

1031
00:42:12,640 --> 00:42:14,560
function we saw before the crashing

1032
00:42:14,560 --> 00:42:16,560
function we can understand the flow a

1033
00:42:16,560 --> 00:42:18,640
little bit better

1034
00:42:18,640 --> 00:42:20,960
so this is what happens here

1035
00:42:20,960 --> 00:42:22,480
in the first couple of lines the client

1036
00:42:22,480 --> 00:42:24,240
simply reads the format index from the

1037
00:42:24,240 --> 00:42:25,920
message

1038
00:42:25,920 --> 00:42:29,119
nothing too special about that

1039
00:42:29,119 --> 00:42:30,560
then

1040
00:42:30,560 --> 00:42:32,640
the client checks whether the sound

1041
00:42:32,640 --> 00:42:35,200
format is different

1042
00:42:35,200 --> 00:42:37,200
this time from the one that was

1043
00:42:37,200 --> 00:42:39,680
previously used by the server

1044
00:42:39,680 --> 00:42:42,240
now if it is different the client will

1045
00:42:42,240 --> 00:42:45,280
then treat the format change um and this

1046
00:42:45,280 --> 00:42:48,079
of course includes some bounce checking

1047
00:42:48,079 --> 00:42:49,680
for the array so the client will make

1048
00:42:49,680 --> 00:42:51,359
sure that the

1049
00:42:51,359 --> 00:42:54,000
new format index is within the bounds of

1050
00:42:54,000 --> 00:42:56,800
the format array that it has

1051
00:42:56,800 --> 00:42:58,720
um so this is if it's different and then

1052
00:42:58,720 --> 00:43:01,280
it will process the data

1053
00:43:01,280 --> 00:43:03,440
with no problem

1054
00:43:03,440 --> 00:43:06,240
now in case of the format being the same

1055
00:43:06,240 --> 00:43:08,319
as the previous packet

1056
00:43:08,319 --> 00:43:11,440
the client will simply access the array

1057
00:43:11,440 --> 00:43:13,200
in the appropriate index and will

1058
00:43:13,200 --> 00:43:14,960
continue to process the data as if

1059
00:43:14,960 --> 00:43:17,200
nothing happened

1060
00:43:17,200 --> 00:43:19,119
as you might have guessed already or

1061
00:43:19,119 --> 00:43:21,680
understood already

1062
00:43:21,680 --> 00:43:25,040
the issue is that the bound check occurs

1063
00:43:25,040 --> 00:43:27,520
only when the format has been changed by

1064
00:43:27,520 --> 00:43:30,880
the server but our crashing input didn't

1065
00:43:30,880 --> 00:43:33,680
change the format it changed the array

1066
00:43:33,680 --> 00:43:36,800
itself practically making it smaller

1067
00:43:36,800 --> 00:43:38,560
and this is what ultimately caused the

1068
00:43:38,560 --> 00:43:40,640
client to crash

1069
00:43:40,640 --> 00:43:43,200
and so now that we understand this um

1070
00:43:43,200 --> 00:43:44,480
you can see how

1071
00:43:44,480 --> 00:43:47,280
this type of bugs look like

1072
00:43:47,280 --> 00:43:49,520
now this is an out-of-bound read

1073
00:43:49,520 --> 00:43:51,920
bug with a limited impact

1074
00:43:51,920 --> 00:43:54,240
but we still feel that it is a good

1075
00:43:54,240 --> 00:43:56,960
example and it demonstrates well how

1076
00:43:56,960 --> 00:43:58,079
effective

1077
00:43:58,079 --> 00:44:00,319
the multi-input fuzzing was

1078
00:44:00,319 --> 00:44:01,440
and also

1079
00:44:01,440 --> 00:44:05,359
what rdp bugs may look like

1080
00:44:05,359 --> 00:44:07,680
all right so let's try to summarize what

1081
00:44:07,680 --> 00:44:09,359
we've learned today

1082
00:44:09,359 --> 00:44:11,359
um the first point we believe is worth

1083
00:44:11,359 --> 00:44:14,160
making is that really nothing can be

1084
00:44:14,160 --> 00:44:16,400
deemed as unfuzzable

1085
00:44:16,400 --> 00:44:19,440
um this project shows that no matter how

1086
00:44:19,440 --> 00:44:22,480
complex you think your target is

1087
00:44:22,480 --> 00:44:24,880
you can always find a way around it and

1088
00:44:24,880 --> 00:44:27,520
finally you will be able to fuzz it and

1089
00:44:27,520 --> 00:44:30,000
this is especially true with

1090
00:44:30,000 --> 00:44:33,680
newer snapshot or emulator based fuzzers

1091
00:44:33,680 --> 00:44:35,440
like for example what the fuzz buy

1092
00:44:35,440 --> 00:44:36,960
overclock

1093
00:44:36,960 --> 00:44:39,520
those would be really great tools to um

1094
00:44:39,520 --> 00:44:42,240
try and fuzz some complex

1095
00:44:42,240 --> 00:44:43,839
targets

1096
00:44:43,839 --> 00:44:46,240
um and also

1097
00:44:46,240 --> 00:44:48,480
you know just let the fuzzer do the work

1098
00:44:48,480 --> 00:44:50,480
for you you don't really want to put in

1099
00:44:50,480 --> 00:44:52,240
the effort to manually analyze the

1100
00:44:52,240 --> 00:44:55,040
target right what's the fun in that so

1101
00:44:55,040 --> 00:44:57,280
really fuzz everything you can

1102
00:44:57,280 --> 00:44:58,560
um

1103
00:44:58,560 --> 00:45:01,040
all right regarding future work in this

1104
00:45:01,040 --> 00:45:02,400
field

1105
00:45:02,400 --> 00:45:04,640
um we believe it's worth putting more

1106
00:45:04,640 --> 00:45:07,680
effort into fuzzing rdp our project was

1107
00:45:07,680 --> 00:45:09,599
limited of course due to some

1108
00:45:09,599 --> 00:45:12,319
circumstances and it can be improved

1109
00:45:12,319 --> 00:45:13,760
upon

1110
00:45:13,760 --> 00:45:17,119
and also due to the huge code base that

1111
00:45:17,119 --> 00:45:18,400
rdp has

1112
00:45:18,400 --> 00:45:20,480
and the number the large number of

1113
00:45:20,480 --> 00:45:22,560
logical channels

1114
00:45:22,560 --> 00:45:25,200
we bet that there are still more stuff

1115
00:45:25,200 --> 00:45:27,280
to find in rdp

1116
00:45:27,280 --> 00:45:29,280
we may go back to pursuing it in the

1117
00:45:29,280 --> 00:45:31,040
near future but

1118
00:45:31,040 --> 00:45:34,160
we do encourage the community to join in

1119
00:45:34,160 --> 00:45:36,319
on the effort

1120
00:45:36,319 --> 00:45:38,640
the other thing is that the platform

1121
00:45:38,640 --> 00:45:41,440
that we've built around fuzzing rdp can

1122
00:45:41,440 --> 00:45:44,480
be directed at a completely different

1123
00:45:44,480 --> 00:45:45,839
target

1124
00:45:45,839 --> 00:45:48,079
by platform i mean the multi input

1125
00:45:48,079 --> 00:45:49,440
fuzzing the attaching to windows

1126
00:45:49,440 --> 00:45:52,160
services and all the stuff that orr

1127
00:45:52,160 --> 00:45:53,440
talked about

1128
00:45:53,440 --> 00:45:54,240
um

1129
00:45:54,240 --> 00:45:56,000
and this is exactly what we started

1130
00:45:56,000 --> 00:46:00,160
doing we started fuzzing some rpc server

1131
00:46:00,160 --> 00:46:01,440
on windows

1132
00:46:01,440 --> 00:46:03,280
and we got some promising preliminary

1133
00:46:03,280 --> 00:46:05,440
results so expect to hear more about

1134
00:46:05,440 --> 00:46:07,599
that in the future

1135
00:46:07,599 --> 00:46:09,359
and also

1136
00:46:09,359 --> 00:46:11,680
what we've done is that we pushed

1137
00:46:11,680 --> 00:46:13,520
all of the code and the tools that we

1138
00:46:13,520 --> 00:46:16,560
used and modified to github um

1139
00:46:16,560 --> 00:46:19,599
you can find the link here below um this

1140
00:46:19,599 --> 00:46:21,839
is the this is the link and it should be

1141
00:46:21,839 --> 00:46:23,839
up there as we speak if not it will be

1142
00:46:23,839 --> 00:46:27,200
in the next few hours um again you can

1143
00:46:27,200 --> 00:46:29,119
find there all the stuff that we talked

1144
00:46:29,119 --> 00:46:32,319
about um just a disclaimer it's not an

1145
00:46:32,319 --> 00:46:34,079
off-the-shelf ready-to-use type of

1146
00:46:34,079 --> 00:46:35,440
situation

1147
00:46:35,440 --> 00:46:38,319
but it can give you a jump start if you

1148
00:46:38,319 --> 00:46:41,440
are looking to fuzz rdp or a similar

1149
00:46:41,440 --> 00:46:42,720
target

1150
00:46:42,720 --> 00:46:44,960
on windows so please

1151
00:46:44,960 --> 00:46:47,599
we encourage you to to go ahead and use

1152
00:46:47,599 --> 00:46:49,359
that

1153
00:46:49,359 --> 00:46:51,599
finally let me say that we encourage

1154
00:46:51,599 --> 00:46:53,839
everyone to use the techniques and the

1155
00:46:53,839 --> 00:46:56,400
the tools that we've used in any way you

1156
00:46:56,400 --> 00:46:58,880
see fit and for every target and we'll

1157
00:46:58,880 --> 00:47:00,560
be happy to discuss

1158
00:47:00,560 --> 00:47:03,119
anything fuzzing related please reach

1159
00:47:03,119 --> 00:47:04,319
out to us

1160
00:47:04,319 --> 00:47:06,880
and the best place to find us is on

1161
00:47:06,880 --> 00:47:09,119
twitter

1162
00:47:09,119 --> 00:47:11,760
and that's it let me say thank you very

1163
00:47:11,760 --> 00:47:14,160
much for joining us today i hope you

1164
00:47:14,160 --> 00:47:16,480
enjoyed i hope you enjoyed this

1165
00:47:16,480 --> 00:47:18,000
convention

1166
00:47:18,000 --> 00:47:20,160
and please contact us

1167
00:47:20,160 --> 00:47:23,558
thank you again

