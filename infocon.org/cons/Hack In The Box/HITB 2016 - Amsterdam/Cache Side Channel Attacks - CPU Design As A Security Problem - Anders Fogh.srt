1
00:00:14,850 --> 00:00:18,160
thank you the subject of this talk is
cast aside

2
00:00:18,160 --> 00:00:21,520
LOL attacks as an example of how CPU
design can become a security problem

3
00:00:23,140 --> 00:00:27,550
about a year ago from now I was
preparing a talk about how to detect the

4
00:00:27,550 --> 00:00:34,180
role hammer export and one guy on
Twitter tweeted that he could do it in

5
00:00:34,180 --> 00:00:40,900
JavaScript which throw my plans to the
wind and I have to figure out how he did

6
00:00:40,900 --> 00:00:46,210
it because i had to find out how I could
detect that as well and everything

7
00:00:46,210 --> 00:00:49,570
looked like it was going to be something
good to do with a cash and so I started

8
00:00:49,570 --> 00:00:54,040
reading up on caste side-channel attacks
and about four hours later i wrote my

9
00:00:54,040 --> 00:00:56,620
first cast side-channel attack

10
00:00:56,620 --> 00:00:59,949
the interesting thing here was that I
was actually running my row hammer

11
00:00:59,950 --> 00:01:05,170
mitigation in the background doing
long-term testing of it and it triggered

12
00:01:05,170 --> 00:01:10,539
it triggered I detected my cast
side-channel attacks a row hammer attack

13
00:01:10,539 --> 00:01:14,380
and was like what's going on here

14
00:01:14,380 --> 00:01:18,699
and that became the start of a year
researching what you can do with the

15
00:01:18,700 --> 00:01:24,729
caches in modern CPUs and what you're
about to hear is the results of some of

16
00:01:24,729 --> 00:01:27,550
the results that I've gotten in this
year

17
00:01:27,550 --> 00:01:36,880
so when I prepare for this talk i was
thinking about what is it that I want to

18
00:01:36,880 --> 00:01:41,440
bring across here so i made a gender for
myself and I decided to put it in the

19
00:01:41,440 --> 00:01:46,539
slide and the first point that i want to
make is that hard way to sign a security

20
00:01:46,539 --> 00:01:48,759
implement implications

21
00:01:48,759 --> 00:01:53,380
what I mean by why that is is all in
fact a lot more than just that statement

22
00:01:53,380 --> 00:01:58,929
the first thing is usually would think
that if the software is written

23
00:01:58,929 --> 00:02:03,759
correctly we will be safe but that
assumption breaks when the hardware does

24
00:02:03,759 --> 00:02:06,369
not do what it's what we think it does

25
00:02:06,369 --> 00:02:13,330
and the second thing is when a throat
CPU design is the problem is

26
00:02:13,330 --> 00:02:17,590
specifically chose the work design
because this is not about bucks

27
00:02:17,590 --> 00:02:21,430
this is about a design decisions that is
made by implementing the future you

28
00:02:22,650 --> 00:02:27,989
so that's one of the first thing I want
to get across the second thing I want to

29
00:02:27,989 --> 00:02:30,989
get across is that cast side channels
are a real danger

30
00:02:32,610 --> 00:02:36,840
I hope to show you that we can do lots
of crazy stuff with cast side-channel

31
00:02:36,840 --> 00:02:39,870
attacks and that this is not just a
ticket

32
00:02:39,870 --> 00:02:45,659
academic study filled with which has
mostly been until now and i hope to get

33
00:02:45,659 --> 00:02:46,890
that across as well

34
00:02:46,890 --> 00:02:52,950
third point is that despite that these
attacks are Hardware enabled we actually

35
00:02:52,950 --> 00:03:01,349
do have a chance to defend against them
in software so moving on Castle channel

36
00:03:01,349 --> 00:03:06,060
attacks are attacks that are enabled by
my critique architectural design of the

37
00:03:06,060 --> 00:03:12,450
cpu what this means is that cast a
chocolate axe is not a an attack on it

38
00:03:12,450 --> 00:03:13,500
on its own

39
00:03:13,500 --> 00:03:18,030
it's a mythology what is actually
happening is is that we can figure out

40
00:03:18,030 --> 00:03:22,650
how other software uses memory and we
can use that term for secret information

41
00:03:23,310 --> 00:03:27,569
what I mean by micro tech chure
architectural design of the cpu is it is

42
00:03:27,569 --> 00:03:32,518
not a requirement that the cash is
designed the way it is for the cpu to be

43
00:03:32,519 --> 00:03:37,319
part of the family that is there is no
compatibility problems and in changing

44
00:03:37,319 --> 00:03:38,190
the design

45
00:03:38,190 --> 00:03:41,459
it's just plain design decision that
could be done otherwise and hasn't

46
00:03:41,459 --> 00:03:48,810
cashed side-channel attacks are probably
the most important side channel in one

47
00:03:48,810 --> 00:03:53,579
computers because of the bandwidth that
the memory subsystem hold because of the

48
00:03:53,579 --> 00:03:57,510
size of modern caches that measures in
megabytes and the central position in

49
00:03:57,510 --> 00:04:01,078
the computer system with the bandwidth
is just a matter of how much data you

50
00:04:01,079 --> 00:04:09,060
can get a crack across your side channel
the size makes it more stay longer and

51
00:04:09,060 --> 00:04:14,639
be able to actually get the data out of
the side channel and to understand the

52
00:04:14,639 --> 00:04:16,440
central position in a computer

53
00:04:16,440 --> 00:04:21,089
I like to compare it to a side channel
in the floating point unit that could be

54
00:04:21,089 --> 00:04:22,979
a side channel and floating-point unit

55
00:04:22,979 --> 00:04:26,219
the thing is you can write a software
without using the floating point unit in

56
00:04:26,220 --> 00:04:30,240
fact most software doesn't but you
cannot write write a piece of software

57
00:04:30,240 --> 00:04:31,950
without using memory

58
00:04:31,950 --> 00:04:36,630
by extension the cast stop system so
this is why I think this is the most

59
00:04:36,630 --> 00:04:40,230
general kind of factional attacker is in
one computers and its really really

60
00:04:40,230 --> 00:04:45,540
dangerous because side channels are part
of hardware design they're notoriously

61
00:04:45,540 --> 00:04:46,830
difficult to defeat

62
00:04:46,830 --> 00:04:51,210
I don't see any chances that into oils
be sending me a new cpu anytime soon

63
00:04:52,080 --> 00:04:58,950
at least not without paying for it and
it is possible that because this could

64
00:04:58,950 --> 00:05:03,420
be fixed in microcode i actually don't
think it can but it's possible fact this

65
00:05:03,420 --> 00:05:04,290
that

66
00:05:04,290 --> 00:05:12,690
no wonder has defeated cast side-channel
attacks in and Mike road so far and it's

67
00:05:12,690 --> 00:05:13,890
unlikely to happen

68
00:05:13,890 --> 00:05:20,039
I think because say in to have been
doing like five six generation of cpus

69
00:05:20,040 --> 00:05:24,420
without fixing this problem so we are
most more or less forced to move into

70
00:05:24,420 --> 00:05:29,370
software mitigation forecast channel
attacks and I hope to show that this is

71
00:05:29,370 --> 00:05:32,820
indeed possible

72
00:05:32,820 --> 00:05:38,550
Who am I my name is and as fuck I've
been playing with malware since 1992 and

73
00:05:38,550 --> 00:05:43,020
you can reach me on twitter or by email
and if you like to get hear more about

74
00:05:43,020 --> 00:05:46,380
the stuff i actually blogged about it
you can get it there

75
00:05:47,280 --> 00:05:53,190
so before we proceed I should probably
say that i will be using material made

76
00:05:53,190 --> 00:05:56,850
by other people and at the end of my
slides which you can download after the

77
00:05:56,850 --> 00:06:00,180
talk you can get the entire literature
list and see what's mine and what's not

78
00:06:00,180 --> 00:06:00,720
mine

79
00:06:00,720 --> 00:06:08,460
I don't want to take credit for whatever
other people did so you don't summarize

80
00:06:08,460 --> 00:06:13,169
a year's worth of research in an hour so
i'll restrict the scope here to talk

81
00:06:13,170 --> 00:06:18,720
about modern intel cpus specifically
send a bridge to shoot through skylake

82
00:06:18,720 --> 00:06:23,700
probably the next generation will be
vulnerable to these attack as well

83
00:06:25,260 --> 00:06:29,310
this means i three through Z honest is
affected

84
00:06:29,310 --> 00:06:36,720
throughout most sellers are and some
atoms as well i will mention am disabuse

85
00:06:36,720 --> 00:06:41,040
from time to time just to to point out
the differences

86
00:06:41,550 --> 00:06:46,680
you can do catch on attacks on AMD CPUs
as well they work differently than they

87
00:06:46,680 --> 00:06:53,970
do in dental casts on attacks will work
on other cpus as well has been

88
00:06:53,970 --> 00:06:57,360
demonstrated that you can do
side-channel attacks on ARM processors

89
00:06:57,360 --> 00:07:03,870
on mobile devices as well so there is
many caches and modern computers in the

90
00:07:03,870 --> 00:07:06,870
translation lookaside buffer system
there's caches

91
00:07:07,620 --> 00:07:11,310
I have a paper coming out soon about
abusing them for lots of funny stuff

92
00:07:12,120 --> 00:07:15,180
there's a row buffer cache in the
diagram that you can use for

93
00:07:15,180 --> 00:07:16,350
side-channel attacks

94
00:07:16,350 --> 00:07:21,480
I have helped pioneer that side channel
tech and what we'll be talking about

95
00:07:21,480 --> 00:07:25,920
today is the data caches what everybody
thinks about when I hear cpu caches that

96
00:07:25,920 --> 00:07:28,920
is the cash between the CPU and memory

97
00:07:29,430 --> 00:07:37,830
we were focusing on the shared l3 cache
and i hope you'll understand why when we

98
00:07:37,830 --> 00:07:39,150
get to it

99
00:07:39,150 --> 00:07:46,979
so here I want to show that the l3 is
might be a micro architectural thing but

100
00:07:46,980 --> 00:07:48,390
it's not small at all

101
00:07:48,390 --> 00:07:53,640
as you can see the cast is why the large
part of the real estate and the cpu

102
00:07:53,640 --> 00:07:58,770
another interesting thing that you can
actually see and this shot is that it

103
00:07:58,770 --> 00:07:59,789
looks like that

104
00:07:59,790 --> 00:08:05,850
below each core there is a specific unit
for that core and that is actually what

105
00:08:05,850 --> 00:08:07,950
is happening these are called slices

106
00:08:07,950 --> 00:08:11,610
we'll talk more about slices later

107
00:08:12,120 --> 00:08:16,890
so to have a home my point to that these
things are really dangerous

108
00:08:17,550 --> 00:08:21,360
I ask myself why is this interesting
well cast a channel attacks do not

109
00:08:21,360 --> 00:08:25,650
respect privileges they conducted
uncross cpu cross core

110
00:08:25,650 --> 00:08:30,150
cross me and crush user out of sand box
if you get code execution basically you

111
00:08:30,150 --> 00:08:32,789
can do a cast such an attack

112
00:08:32,789 --> 00:08:39,390
it's pretty much that simple that can be
many uses forecast channel attacks

113
00:08:39,390 --> 00:08:41,429
covert channels

114
00:08:41,429 --> 00:08:46,020
first comes to mind that is where a
hacker has an implant on your virtual

115
00:08:46,020 --> 00:08:50,310
server and is sitting on another virtual
servers it is extracting data through

116
00:08:50,310 --> 00:08:52,119
the cash and not through the

117
00:08:52,120 --> 00:08:57,820
tcp IP which of course means we cannot
be detected by P kapoor deterred by

118
00:08:57,820 --> 00:09:00,430
firewalls and all this kind of stuff

119
00:09:00,430 --> 00:09:04,870
now I think that's mostly mostly
academic but they do allow us to measure

120
00:09:04,870 --> 00:09:10,900
the speed of the side channel and we can
actually stream 720p HD video through

121
00:09:10,900 --> 00:09:16,839
the cash real time so i think that point
is that we have lots of bandwidth here

122
00:09:16,839 --> 00:09:21,430
more important is stealing cryptic ease
you don't actually need an implant you

123
00:09:21,430 --> 00:09:26,410
don't have to need to be on the same
trust domain as the key that is being

124
00:09:26,410 --> 00:09:28,630
used just need to be on the same
processor

125
00:09:28,630 --> 00:09:32,800
well not in that it just need to be on
the same computer to see your keys it

126
00:09:32,800 --> 00:09:38,410
has been demonstrated that you can steal
on our sake 2048-bit key on and live

127
00:09:38,410 --> 00:09:41,589
amazon server if you think that it's
going to be better with elliptical

128
00:09:41,589 --> 00:09:47,140
protective you'd be wrong if you think
that symmetric encryption is as much

129
00:09:47,140 --> 00:09:47,770
better

130
00:09:47,770 --> 00:09:52,630
well is IE s has been broken as well i
should mention here

131
00:09:53,170 --> 00:09:57,069
Castle attacks are attacks on
implementation are not on algorithms

132
00:09:57,070 --> 00:10:00,970
that means that our say is not generally
broken but there are implementation of

133
00:10:00,970 --> 00:10:05,860
ours a which will lead the private key
if you are on the same processor same

134
00:10:05,860 --> 00:10:12,279
time computer risks as an attacker and
remember this can happen from inside a

135
00:10:12,279 --> 00:10:17,560
sandbox as well so there's more mundane
thing like spying and keyboard input

136
00:10:17,560 --> 00:10:22,569
mouse cursor on the screen and there's
the really weird stuff which i have been

137
00:10:22,570 --> 00:10:27,400
involved with is breaking the colonel I
so are you can actually do quite a nice

138
00:10:27,400 --> 00:10:30,310
Colonel hassel a break with cash on
attacks

139
00:10:30,310 --> 00:10:34,959
so if you think this is a wide spectrum
it's because it is is because what we're

140
00:10:34,959 --> 00:10:40,540
doing and we're looking at how
applications use memory and every

141
00:10:40,540 --> 00:10:44,650
application uses memory and attend to
leak information about what it is doing

142
00:10:44,650 --> 00:10:48,970
and we can use this and abuse this with
cash sexual attacks

143
00:10:48,970 --> 00:10:51,970
so let's get technical

144
00:10:52,570 --> 00:10:55,959
how the data cache works on in for
computers

145
00:10:55,959 --> 00:10:59,319
imagine that core two does a member
requests for

146
00:11:01,690 --> 00:11:07,930
request for memory well its first served
in the l1 cache if it's possible if it's

147
00:11:07,930 --> 00:11:11,620
not possible it will be served in the l2
cache and if it's not in the l2 cache

148
00:11:11,620 --> 00:11:16,360
will be served from the l3 cache if it's
not in the l3 cache it will be checked

149
00:11:16,360 --> 00:11:21,670
if it's in the l three slices on the
onion on the other course and it's not

150
00:11:21,670 --> 00:11:22,630
there either

151
00:11:22,630 --> 00:11:25,689
it will be fetched from physical memory

152
00:11:25,690 --> 00:11:30,400
what typically happens is that the
physical memory then written into l3 and

153
00:11:30,400 --> 00:11:33,400
if the l3 is already full something
something will be thrown out

154
00:11:34,060 --> 00:11:40,180
this is called eviction the second thing
we need to know about this cash is that

155
00:11:40,180 --> 00:11:44,079
this cache hierarchy is that it's a
so-called inclusive caste hierarchy that

156
00:11:44,080 --> 00:11:51,280
means that what data is in the l1 caches
has to be in the AL - what's in l2 has

157
00:11:51,280 --> 00:11:56,770
to be an l-3 without three having this
shared structure meaning that an

158
00:11:56,770 --> 00:11:57,910
attacker

159
00:11:57,910 --> 00:12:02,230
if an attacker is able to put something
into the l3 cache it will be available

160
00:12:02,230 --> 00:12:06,760
in all course if attacker is able to
remove something from the l3 cache

161
00:12:07,420 --> 00:12:11,709
he will remove it from all course and
all caches on the entire hierarchy and

162
00:12:11,710 --> 00:12:13,990
this allows him to manipulate the cash

163
00:12:13,990 --> 00:12:18,100
we'll see how we can use that later the
last thing we need to see that the slide

164
00:12:18,100 --> 00:12:19,900
is what's not there

165
00:12:19,900 --> 00:12:25,840
you don't see any rings Colonel
privileges user privileges does not like

166
00:12:25,840 --> 00:12:26,890
nothing like that

167
00:12:26,890 --> 00:12:30,040
it's not because i'm lazy drawing this
thing is just because it's not there

168
00:12:30,040 --> 00:12:36,490
and that's what effectively enable us to
do these things to summarize it

169
00:12:36,490 --> 00:12:40,960
important cast features is almost any
memory right is placed in the cash

170
00:12:40,960 --> 00:12:44,410
the cash is a mirror image of memory
activity on the computer

171
00:12:44,410 --> 00:12:50,050
second healthy is shared globally across
all users and privilege levels and

172
00:12:50,050 --> 00:12:52,329
finalists include the cache hierarchy

173
00:12:52,330 --> 00:12:55,660
if we remove memory from all three
removed from all caches meaning we can

174
00:12:55,660 --> 00:13:01,180
manipulate the cash so I was memory
stored in our three

175
00:13:02,080 --> 00:13:05,530
in this problem here is it takes a lot
of infrastructure and time to keep track

176
00:13:05,530 --> 00:13:10,900
of the position of each byte of memory
it will be anywhere in the cash so and

177
00:13:10,900 --> 00:13:11,480
we'll have

178
00:13:11,480 --> 00:13:18,050
made to design decisions to solve this
problem and the first is it doesn't work

179
00:13:18,050 --> 00:13:21,829
on bites it works in cache lines a cast
line is typically 64 bytes of

180
00:13:21,829 --> 00:13:24,829
consecutive consecutive physical memory

181
00:13:25,550 --> 00:13:29,660
the second design decision is why i
should mention that

182
00:13:29,660 --> 00:13:35,300
that of course divides the problem by 64
which is but not by Phi not enough to to

183
00:13:35,300 --> 00:13:35,959
solve it

184
00:13:35,959 --> 00:13:40,130
so into has made the l3 cache in any way
set associative cache

185
00:13:40,760 --> 00:13:47,209
what this means is that any cache line
belongs to a cast set and the cassat to

186
00:13:47,209 --> 00:13:51,619
which is belonged is determined by the
address meaning that from the address

187
00:13:51,620 --> 00:13:57,019
you can tell we're in the cache active
certain cache line is going to be there

188
00:13:57,019 --> 00:14:06,079
are 2048 casts its per slice meaning
onto course of us before 2096 each set

189
00:14:06,079 --> 00:14:11,630
can store n which is typically 1220
caste lines depending on the total cast

190
00:14:11,630 --> 00:14:12,230
sides

191
00:14:12,230 --> 00:14:18,800
meaning that when we request memory we
have to search Ted 12 or 20 ways to find

192
00:14:18,800 --> 00:14:20,000
our our cache line

193
00:14:20,000 --> 00:14:23,060
actually it's not searching buds

194
00:14:23,060 --> 00:14:27,229
it's multiplexing but it's the same
thing really

195
00:14:27,230 --> 00:14:32,569
so we can look at this graphically here
on CNN bent down in the memory i have

196
00:14:32,569 --> 00:14:38,689
given different addresses different
colors and these callers have to match

197
00:14:38,690 --> 00:14:42,560
the color of the cast set that mean that
something is green it will be cached and

198
00:14:42,560 --> 00:14:49,489
set one if something is blue it would be
cashed in and set 2048 something is read

199
00:14:49,490 --> 00:14:52,310
it will be casting slice one and set one
right

200
00:14:52,310 --> 00:14:55,310
what we also notice here is that

201
00:14:55,819 --> 00:15:00,709
intel has chosen to distribute the caste
lines / memory so that they are not in

202
00:15:00,709 --> 00:15:02,839
blocks but the spread out over the
system

203
00:15:02,839 --> 00:15:06,350
this design decision is so that
application that typically use memory

204
00:15:06,350 --> 00:15:12,769
rather in a local area will use multiple
cast sets at once and thus have the

205
00:15:12,769 --> 00:15:15,889
ability to use more of the cash

206
00:15:15,889 --> 00:15:19,699
so this is very good design for
performance

207
00:15:19,699 --> 00:15:22,719
the thing is it allows an attacker -

208
00:15:22,720 --> 00:15:28,329
look into sets instead of working with
the entire cache which makes the problem

209
00:15:28,329 --> 00:15:30,910
for the attacker much more manageable

210
00:15:30,910 --> 00:15:36,639
so here is a an example code which we
can attack

211
00:15:36,639 --> 00:15:43,629
I hope there's no errors in there that
doesn't have to be the function that are

212
00:15:43,629 --> 00:15:45,519
written here is purely made up

213
00:15:45,519 --> 00:15:51,730
it's inspired by the GDK library
implementation of keep our handling and

214
00:15:51,730 --> 00:15:56,920
it is that what it essentially does is
making turning keystrokes into into

215
00:15:56,920 --> 00:16:05,378
unicode chars and here my simplified
version if it's other case it uses uses

216
00:16:05,379 --> 00:16:09,310
a different function to turn it into
Nakota benefits lower case

217
00:16:09,310 --> 00:16:12,518
so you have these two functions and in
all likelihood they will this will be

218
00:16:12,519 --> 00:16:17,589
placed on different cache lines and on
in different cast sets of which we saw

219
00:16:17,589 --> 00:16:23,560
before and this means that we can if
actually if we could see into the cash

220
00:16:23,560 --> 00:16:27,609
we would see that calling this function
would place different material in the

221
00:16:27,610 --> 00:16:31,300
cash depending on whether your password
uses an upper or lowercase letter

222
00:16:34,240 --> 00:16:38,680
this is not a real thing the real thing
is much much bigger and actually leaks a

223
00:16:38,680 --> 00:16:43,689
lot more data but it doesn't fit on the
slide but i will use this example 28 to

224
00:16:43,689 --> 00:16:47,050
explain the catch on the tax to the
moment so if you try to remember

225
00:16:47,709 --> 00:16:53,079
uppercase and lowercase different castes
different caste lines so common for all

226
00:16:53,079 --> 00:16:57,160
castes on the taxes that we can
determine if something is in the cash

227
00:16:57,160 --> 00:17:01,000
how this works is if we access it the
cat cached version will be much faster

228
00:17:01,000 --> 00:17:05,679
typically around 80 clock cycles the on
cash going to main memory will cost

229
00:17:05,679 --> 00:17:08,919
around 200 clock cycle so we are
actually have a pretty big difference

230
00:17:08,919 --> 00:17:15,220
between how long it takes to access
memory told you before we can manipulate

231
00:17:15,220 --> 00:17:20,530
the cash that certainly happens in one
of three ways the first eviction this

232
00:17:20,530 --> 00:17:25,780
works by accessing memory and a cast set
until all everything that was previously

233
00:17:25,780 --> 00:17:28,510
in there has been replaced with attacker
addresses

234
00:17:28,510 --> 00:17:32,530
then there is a flush handle has decided
as to give us an unprivileged

235
00:17:32,530 --> 00:17:35,660
instruction the seal flush instruction
which we can

236
00:17:35,660 --> 00:17:41,360
used to evict individual cache lines
from the entire cache hierarchy and

237
00:17:41,360 --> 00:17:44,780
finally there's prime prime works pretty
much like evict

238
00:17:44,780 --> 00:17:49,430
except now we access memory and a patent
so that we act the attacker afterwards

239
00:17:49,430 --> 00:17:57,440
knows which addresses are in the cash at
a given point in time so I like to think

240
00:17:57,440 --> 00:17:59,000
of cash or taxes

241
00:17:59,000 --> 00:18:03,260
there's three big cash attacks and then
there's a ton of variation of these

242
00:18:03,260 --> 00:18:04,730
three

243
00:18:04,730 --> 00:18:10,370
there are other cash attacks I will not
be talking about them they all work in

244
00:18:10,370 --> 00:18:15,020
the same way the attack and manipulates
the cash to a known state and then he

245
00:18:15,020 --> 00:18:18,110
waits for the victim activity and then
you get salmon that's what I have

246
00:18:18,110 --> 00:18:22,219
changed to see the big three victim time

247
00:18:22,220 --> 00:18:27,650
primer and probe flushing load the
primitives for manipulating the caches

248
00:18:27,650 --> 00:18:29,090
first part of it

249
00:18:29,090 --> 00:18:33,320
the second part is how we actually see
what's in the cash

250
00:18:33,320 --> 00:18:38,780
so the victim time works in this way we
execute a function and it will set of it

251
00:18:38,780 --> 00:18:42,170
set up the cash and so that the next
time you call this function will go fast

252
00:18:42,170 --> 00:18:50,270
and then we time the same function and
use this as a baseline then we evicted

253
00:18:50,270 --> 00:18:54,620
cast it that we think is interesting and
we time to function again

254
00:18:54,620 --> 00:18:58,909
so if step two was faster than step for
the function probably used an address

255
00:18:58,910 --> 00:19:03,290
can go into the cache 73 meaning in our
password case which is bit unrealistic

256
00:19:03,290 --> 00:19:06,590
because you can't type a password and
such a function that would work but if

257
00:19:06,590 --> 00:19:11,179
you could we would know if the user has
used another case letter or not

258
00:19:13,100 --> 00:19:20,240
its password so it's a bit of a problem
using this function it limits the attack

259
00:19:20,240 --> 00:19:23,870
so there is a more powerful attack but
alleviate this problem

260
00:19:23,870 --> 00:19:29,239
it's a prime and probe the first step of
primer and probe is manipulate the

261
00:19:29,240 --> 00:19:32,780
castro announced eight that is to make
sure that a cast it contains only known

262
00:19:32,780 --> 00:19:33,980
attacker addresses

263
00:19:33,980 --> 00:19:40,220
secondly we wait for just wait for
victim activity and finally we time

264
00:19:40,220 --> 00:19:45,020
accesses time accessing addresses
through used in step 1

265
00:19:45,020 --> 00:19:47,270
what happens is

266
00:19:47,270 --> 00:19:51,320
if the victim used something and go into
the set he will occur

267
00:19:52,250 --> 00:19:56,150
he will throw out one of our addresses
and we'll get a cache miss when we try

268
00:19:56,150 --> 00:20:02,180
to pack up and we'll know he used memory
congruent to this cast set this house an

269
00:20:02,180 --> 00:20:05,540
advantage because we can just repeat the
attack running over and over again and

270
00:20:05,540 --> 00:20:10,340
will not only if we do it on both caste
lines in the example function will not

271
00:20:10,340 --> 00:20:15,709
only get this is using low are other
cases but will actually get how many

272
00:20:15,710 --> 00:20:21,050
charges using will get upper and lower
case and where they are in the password

273
00:20:21,050 --> 00:20:25,490
since the GDK function actually looks a
lot more data than that

274
00:20:25,490 --> 00:20:30,230
that basically means that we can reduce
the entropy of your password if you type

275
00:20:30,230 --> 00:20:36,170
in analytics or whatever box that uses
the GDK library quite significantly by a

276
00:20:36,170 --> 00:20:37,610
cast such an attack

277
00:20:37,610 --> 00:20:45,649
flushing load work similar to my private
probe but instead of priming the cash we

278
00:20:45,650 --> 00:20:49,850
flush an address that we know to be
interesting

279
00:20:49,850 --> 00:20:54,350
this address has to be shared and shared
memory then again we wait for victim

280
00:20:54,350 --> 00:20:55,189
activity

281
00:20:55,190 --> 00:21:01,190
reload and we time access to the shared
address if the timing is fast and three

282
00:21:01,190 --> 00:21:08,870
well it was placed in the cash by the
victim so basically same deal as primer

283
00:21:08,870 --> 00:21:14,030
and probe for the rest and we'll move on
to comparing them so the second time the

284
00:21:14,030 --> 00:21:24,830
accuracy you get is cast set congruence
and we require a function call this has

285
00:21:24,830 --> 00:21:27,530
an advantage we don't have to
synchronize with the client we know from

286
00:21:27,530 --> 00:21:31,970
calling and ending the function were
when the client is running when when the

287
00:21:31,970 --> 00:21:37,490
victim is running a downside is that
this is post-mortem analysis we only get

288
00:21:37,490 --> 00:21:44,930
what actually happened during the
function called not what happens inside

289
00:21:44,930 --> 00:21:45,620
of it

290
00:21:45,620 --> 00:21:52,010
we don't get any spaceship that temporal
resolution out of that I've used the

291
00:21:52,010 --> 00:21:56,000
evicted time to break Colonel SLR and
doing a modified version because it was

292
00:21:56,000 --> 00:21:59,660
faster but it actually you can use this
attack to break Colonel motive case our

293
00:21:59,660 --> 00:22:03,470
priming probe again

294
00:22:03,470 --> 00:22:07,460
accuracy is cached set congruence we do
live analysis this time we get the

295
00:22:07,460 --> 00:22:11,090
entire password and the scary thing
about this is it works well in

296
00:22:11,090 --> 00:22:12,290
JavaScript

297
00:22:12,290 --> 00:22:15,860
why is this important well this is
important because browsers use java

298
00:22:15,860 --> 00:22:20,840
javascript and this means that cast
side-channel attacks becomes a remote

299
00:22:20,840 --> 00:22:29,360
executable remote exploit finally
flushed and reload the accuracy is on

300
00:22:29,360 --> 00:22:33,110
cache line accuracy and we get this
accuracy because we share memory with

301
00:22:33,110 --> 00:22:35,570
the victim again

302
00:22:35,570 --> 00:22:39,290
it's live analysis and there's another
advantage of this attack that is it's

303
00:22:39,290 --> 00:22:44,060
faster than private probe faster means
that you get better

304
00:22:44,060 --> 00:22:47,899
temporal resolution when you're spying
meaning that if you're spying on a

305
00:22:47,900 --> 00:22:52,070
cryptographer them and and want to get
real real nitty-gritty data you're

306
00:22:52,070 --> 00:22:58,970
better served with fresh below than
private probe like a low doesn't work in

307
00:22:58,970 --> 00:23:00,140
JavaScript

308
00:23:00,140 --> 00:23:08,600
well it actually does but it's not like
it's very useful so I had let this .

309
00:23:08,600 --> 00:23:13,820
stand in my slides shared memory is
unfortunately not as rare as one would

310
00:23:13,820 --> 00:23:14,540
think

311
00:23:14,540 --> 00:23:19,129
there are shared libraries think of
kernel32.dll in Windows the code of it

312
00:23:19,130 --> 00:23:26,780
is mapped into all processes in the
system and and distributed to each of

313
00:23:26,780 --> 00:23:29,450
the processes from through the paging
system so it's just physical memory

314
00:23:29,450 --> 00:23:30,560
mapped into others

315
00:23:30,560 --> 00:23:33,770
this is enough for us to do catch all
attacks on this actually happened to

316
00:23:33,770 --> 00:23:39,260
every library reload on windows so
there's plenty of shared memory

317
00:23:39,260 --> 00:23:43,070
it's not just windows the dust is most
operating system standard procedure

318
00:23:43,070 --> 00:23:47,330
then there's another future this is
called deduplication this is where the

319
00:23:47,330 --> 00:23:52,520
colonel or hypervisor searches for
identical pages and physical memory if

320
00:23:52,520 --> 00:23:58,280
it finds wanted free is one of them and
uses the paging system to provide for

321
00:23:58,280 --> 00:24:01,520
the client's needs throughout the system

322
00:24:04,730 --> 00:24:09,919
this works even on virtual machines my
personal opinion is this should not be

323
00:24:09,919 --> 00:24:13,700
used on any system for any reason it
just a security nightmare

324
00:24:14,510 --> 00:24:19,549
it basically not only allows you to do
flashing below to tax it was only that

325
00:24:19,549 --> 00:24:23,690
it would be bad but there's
deduplication attacks you can speculate

326
00:24:23,690 --> 00:24:27,080
on doing row hammer across GM food

327
00:24:27,080 --> 00:24:32,120
deduplication a recent touch paper i
think i read it monday use deduplication

328
00:24:32,120 --> 00:24:35,719
to get an influence in the edge browser
and roll hammer its way out of the

329
00:24:35,720 --> 00:24:36,530
sandbox

330
00:24:36,530 --> 00:24:40,460
so you shouldn't be using the
application if you are well

331
00:24:40,460 --> 00:24:47,120
all bets are off i think yeah

332
00:24:48,580 --> 00:24:54,760
cast and side-channel attacks are not as
perfect as one would like they're

333
00:24:54,760 --> 00:25:00,070
inherently noisy and the reason is there
is other code than the victim running on

334
00:25:00,070 --> 00:25:01,059
on the computer

335
00:25:01,059 --> 00:25:05,950
well that's one of the reason so so if
that code uses the same cache lines

336
00:25:05,950 --> 00:25:11,320
it'll disturb prime probin and the
victim time if it uses the same casted

337
00:25:11,320 --> 00:25:12,700
will disturb that

338
00:25:12,700 --> 00:25:17,440
another thing is these are essentially
timing attacks and there are the shared

339
00:25:17,440 --> 00:25:22,720
substance systems in the cpu and other
uses of these substances will change the

340
00:25:22,720 --> 00:25:24,220
timing of the information

341
00:25:24,220 --> 00:25:28,779
this is not particularly important for
for the basic comcast side-channel

342
00:25:28,779 --> 00:25:33,190
attacks because the time difference of
hundred twenty clock cycles is pretty

343
00:25:33,190 --> 00:25:37,360
substantial will take a look at that a
another kind of such an attack in a

344
00:25:37,360 --> 00:25:40,719
moment of variation of flushing load
where the time difference is much

345
00:25:40,720 --> 00:25:45,460
smaller where it becomes a real issue
then you have interrupt from hardware

346
00:25:45,460 --> 00:25:48,340
and whatnot which disturb you

347
00:25:48,340 --> 00:25:53,590
and finally you have the hardware
prefetcher both attacker and victim and

348
00:25:53,590 --> 00:25:57,279
unrelated code can trigger the hardware
prefetcher to load cache lines into

349
00:25:57,279 --> 00:26:01,990
memory and this of course will cause
false positives in the cast such an

350
00:26:01,990 --> 00:26:07,419
attack the except for the hardware
prefetcher problem the solution is

351
00:26:07,419 --> 00:26:11,799
repeat the attack and rely on the law of
large numbers of course you cannot ask a

352
00:26:11,799 --> 00:26:16,120
user to enter his password 10,000 times
but you can expect that on a web server

353
00:26:16,120 --> 00:26:19,389
your key will be used a couple of
thousand times it so we could get

354
00:26:19,389 --> 00:26:20,289
results

355
00:26:20,289 --> 00:26:30,429
so moving on to where the where a lot of
my worker lies is detecting cast side

356
00:26:30,429 --> 00:26:31,120
channels

357
00:26:31,120 --> 00:26:35,168
i'll be using such as loaded as an
example of how to do it it

358
00:26:35,169 --> 00:26:41,710
the method actually does work for other
cast such as well first we have to need

359
00:26:41,710 --> 00:26:45,460
need to know something about performance
counters performance counters are built

360
00:26:45,460 --> 00:26:51,130
into the cpu we have 18 performance
counters on on mon lentils that we can

361
00:26:51,130 --> 00:26:52,840
program to count my province

362
00:26:52,840 --> 00:26:56,620
there's a lot of micro instead we can
count including destruction instruction

363
00:26:56,620 --> 00:27:01,360
is decoded and interrupts received and
of importance to us all three cast mrs.

364
00:27:01,360 --> 00:27:02,439
and l3 cache

365
00:27:02,440 --> 00:27:03,559
references

366
00:27:03,559 --> 00:27:09,049
now also you can optionally get an
interrupt when the counter overflows and

367
00:27:09,049 --> 00:27:12,470
we can actually set the counter as well
which allows us to get an interrupt on

368
00:27:12,470 --> 00:27:15,710
any instructor any instruction that
causes these events

369
00:27:16,249 --> 00:27:21,590
this has two effects that is that we can
use this to keep track of how many

370
00:27:21,590 --> 00:27:25,970
caches arrives in a particular time
segments and we can get an interrupt

371
00:27:25,970 --> 00:27:30,080
frame and actually analyze instructions
that causes these events will use both

372
00:27:30,080 --> 00:27:33,289
these methods to detect different kind
of side-channel attacks in a moment

373
00:27:34,249 --> 00:27:37,879
on a side note here we can use
performance counters to look for

374
00:27:37,879 --> 00:27:39,649
security related witness

375
00:27:39,649 --> 00:27:42,379
it's not just casts a channel attacks
you can look for rootkits you can look

376
00:27:42,379 --> 00:27:45,949
for brohamer for returned object of
programming and stuff like that

377
00:27:48,080 --> 00:27:51,918
flush and reload here it is since shoe
to assembly code

378
00:27:52,879 --> 00:27:56,449
first we manipulate the cash to a known
state with a steal for construction

379
00:27:56,450 --> 00:28:03,470
then we wait wait for the victim should
probably won't make a common here in the

380
00:28:03,470 --> 00:28:04,490
wait

381
00:28:04,490 --> 00:28:09,799
save your trying to spy on a keyboard
there'd be no reason to be fast about it

382
00:28:09,799 --> 00:28:13,580
you could wait a few milliseconds and
nobody actually types that fast

383
00:28:13,580 --> 00:28:18,019
are you spying on crip to you probably
don't want to wait and all you want to

384
00:28:18,019 --> 00:28:20,240
be as fast as you can be

385
00:28:20,240 --> 00:28:25,909
while repeating this attack so what
essentially is happening is you're in

386
00:28:25,909 --> 00:28:27,559
the race condition with the victim

387
00:28:27,559 --> 00:28:33,259
you're running on different course and
you always want to be before the caches

388
00:28:33,259 --> 00:28:40,850
is cleared so don't wait then the rest
of it is just timing acts accessing the

389
00:28:40,850 --> 00:28:44,809
shared address i do this here with more
of instruction it could be any

390
00:28:44,809 --> 00:28:51,529
instruction that a success ask access
memory the infant's instruction is

391
00:28:51,529 --> 00:28:55,700
because the cpu is capable of
reorganizing memory requests and the

392
00:28:55,700 --> 00:28:59,330
infant's prevent that the attack
actually works without it but it works

393
00:28:59,330 --> 00:29:03,350
better with it and the rest is just
using the idea T&C instruction to get

394
00:29:03,350 --> 00:29:10,009
time and depending on how long it took
that you calculate the information you

395
00:29:10,009 --> 00:29:11,280
want

396
00:29:11,280 --> 00:29:14,310
so how do we detect this

397
00:29:14,310 --> 00:29:20,129
well the marv register shared address
when the victim did not use the shared

398
00:29:20,130 --> 00:29:22,590
address we get to cast miss here

399
00:29:22,590 --> 00:29:27,540
in fact if the victim uses to share a
dress that we just flushed will get a

400
00:29:27,540 --> 00:29:28,920
cash is there

401
00:29:28,920 --> 00:29:32,940
I think about caste mrs. is that they
are rare in reality real applications

402
00:29:32,940 --> 00:29:38,160
and we can use this to Detective
performance counters my original

403
00:29:38,160 --> 00:29:42,480
suggestion was to just interrupt

404
00:29:42,480 --> 00:29:48,900
every number of cache misses and look at
how long it took and and just have a

405
00:29:48,900 --> 00:29:54,810
value if it was too short while we have
a cast such an attack and that worked

406
00:29:54,810 --> 00:30:00,330
pretty well on most guests a channel
attacks since then other researchers

407
00:30:00,330 --> 00:30:05,699
have improved it somehow put the
performance counter data into machine

408
00:30:05,700 --> 00:30:08,070
learning and find that works pretty well

409
00:30:08,070 --> 00:30:13,710
others have just compensated for general
activity and memory subsystem by using a

410
00:30:13,710 --> 00:30:14,670
proxy say

411
00:30:14,670 --> 00:30:20,640
captions references or something like
that and this makes it a bit better with

412
00:30:20,640 --> 00:30:26,460
less false positives and this false
negatives because mainly because that

413
00:30:26,460 --> 00:30:32,610
when you have high activity and memory
subsystem you get in a cast mrs. as a

414
00:30:32,610 --> 00:30:37,080
result that are benign now but in
general this works pretty well

415
00:30:37,710 --> 00:30:42,480
so if you're wondering about the story I
told you in the beginning about Roe

416
00:30:42,480 --> 00:30:43,500
hammer

417
00:30:43,500 --> 00:30:47,640
if you look at this and remove
everything that has to do with timing

418
00:30:47,640 --> 00:30:56,100
and do this on two addresses you get
this and that is in fact the original

419
00:30:56,100 --> 00:31:02,280
code for the original roll him our paper
roll hammer was flush and reload

420
00:31:02,820 --> 00:31:08,070
it's no coincidence that i actually my
role on my detection detected my flushin

421
00:31:08,070 --> 00:31:11,070
reload attack

422
00:31:12,070 --> 00:31:15,790
those are you interesting in row hammer
throw him a jas that I was trying to

423
00:31:15,790 --> 00:31:20,260
detect replace the seal flush
instructions here which are not

424
00:31:20,260 --> 00:31:25,090
available in JavaScript with Victor
teens that work just by accessing memory

425
00:31:25,090 --> 00:31:29,620
in a patent which of course is possible
in JavaScript

426
00:31:29,620 --> 00:31:40,479
so what often happens when you come up
with a good mitigation is that somebody

427
00:31:40,480 --> 00:31:43,300
comes along and figures out how to
bypass it

428
00:31:43,300 --> 00:31:48,669
and this time is no different I actually
had the idea before so when I was

429
00:31:48,670 --> 00:31:52,630
approached by Daniel gross and Maurice
Clinton teen about how we go about

430
00:31:52,630 --> 00:31:57,130
detecting up side-channel attacks that
doesn't cost as much cash mrs. i

431
00:31:57,130 --> 00:32:03,730
immediately said all your your timing
seal flush and that gave me a the

432
00:32:03,730 --> 00:32:08,530
opportunity to actually review the paper
on on flash and flash

433
00:32:08,530 --> 00:32:13,060
so the basic idea about it is that
flashing an address from the cash is

434
00:32:13,060 --> 00:32:17,800
slower than the cash when the address
you're flushing is actually in the cache

435
00:32:17,800 --> 00:32:23,530
logic behind this is obviously that the
instruction can shortcut and doesn't

436
00:32:23,530 --> 00:32:30,910
have to do as much work as when there's
actually something in the cast - so here

437
00:32:30,910 --> 00:32:38,740
you have chute assembly code for the
flash and flash attack and the only

438
00:32:38,740 --> 00:32:42,610
thing that's changed is that the math
instruction has been replaced by CL

439
00:32:42,610 --> 00:32:51,070
flush the authors of the article called
this a stealth side-channel attack and

440
00:32:51,070 --> 00:32:58,149
we can speculate about the reason and
the reason is flash and flash does not

441
00:32:58,150 --> 00:33:02,800
have a reload face and that means
there's no mom no shared address meaning

442
00:33:02,800 --> 00:33:07,180
we get no cache misses meaning that the
detection method that are originally

443
00:33:07,180 --> 00:33:14,110
proposed is not going to work very well
so we can ask performance Candice's

444
00:33:14,110 --> 00:33:14,889
useless

445
00:33:14,890 --> 00:33:19,180
the answer is no we can actually do
something with them but i can just see

446
00:33:19,180 --> 00:33:22,050
that i have enough time to

447
00:33:22,050 --> 00:33:30,540
go off subject the flash and flash is
advantageous in many ways over the flash

448
00:33:30,540 --> 00:33:34,980
and reload the thing is first thing we
should notice is the new seal flush

449
00:33:34,980 --> 00:33:37,950
instruction is much faster than
accessing memory because it doesn't have

450
00:33:37,950 --> 00:33:43,830
to access memory that means it's just
about twice as fast as as a success in

451
00:33:43,830 --> 00:33:44,669
memory

452
00:33:44,670 --> 00:33:48,600
this gets flash and flash bit better
temporal resolution when you do it in

453
00:33:48,600 --> 00:33:49,409
attacks

454
00:33:49,410 --> 00:33:55,620
the second thing is the seal Fletcher
instruction itself will actually return

455
00:33:55,620 --> 00:34:00,209
the cash to a known state meaning that
if you repeat this attack

456
00:34:00,210 --> 00:34:03,210
you don't have to go back to the first
year for construction you can just go

457
00:34:03,210 --> 00:34:08,310
right to the way to face this makes it
faster again and this gives it a lot

458
00:34:08,310 --> 00:34:09,029
better

459
00:34:09,030 --> 00:34:13,290
temporal resolution and much more
bandwidth has a side channel

460
00:34:13,290 --> 00:34:16,949
in fact the fashion flush the attack is
the attack

461
00:34:17,460 --> 00:34:22,620
you know which have the colder side
channel which can stream video in HD

462
00:34:23,639 --> 00:34:29,460
another thing about flash and flash
that's advantageous of explained earlier

463
00:34:29,460 --> 00:34:35,340
that the hardware prefetcher sometimes
get problems and one of the good thing

464
00:34:35,340 --> 00:34:40,830
is that the seal flash instruction does
not trigger the hardware prefetcher so

465
00:34:40,830 --> 00:34:42,960
that that's a nice feature of it

466
00:34:42,960 --> 00:34:48,150
it can be the victim still triggers the
hardware prefetcher so we're not the

467
00:34:48,150 --> 00:34:55,620
problem is not solved but it's a less
relevant so returning to the subject

468
00:34:55,620 --> 00:35:03,480
detecting flushing flushing the core
idea about detecting flushing flashes

469
00:35:03,480 --> 00:35:07,290
that it always has a certain structure

470
00:35:07,830 --> 00:35:12,960
it's a seal for construction bracketed
by high-resolution timers the oddities

471
00:35:12,960 --> 00:35:18,000
the instruction in short sequence and we
can ask ourselves if we can detect this

472
00:35:18,000 --> 00:35:21,000
and the reality of it is that we can

473
00:35:23,900 --> 00:35:29,990
so before that we can go on to actually
detecting you know flash and flush will

474
00:35:29,990 --> 00:35:33,080
need to know some things about how we do
it

475
00:35:33,770 --> 00:35:43,820
and first I should mention that the this
detection does not work on cross DM with

476
00:35:43,820 --> 00:35:46,430
deduplication enabled systems

477
00:35:46,430 --> 00:35:54,140
it could mitigate the problem a tiny bit
so that the attack around and other vm

478
00:35:54,140 --> 00:35:58,129
couldn't use kernel mode has to use
kernel mode to do the attack but he

479
00:35:58,130 --> 00:35:59,780
could do that

480
00:35:59,780 --> 00:36:03,620
I don't think this is a big problem
because I think you should turn off

481
00:36:03,620 --> 00:36:06,920
deduplication and that solves the issue

482
00:36:06,920 --> 00:36:14,570
so thanks for that we use to carry out
this attack is that the rtt SC

483
00:36:14,570 --> 00:36:19,340
instruction can become privileges
privileged if we set a flag and CR for

484
00:36:19,340 --> 00:36:21,380
registered the TSD flag

485
00:36:21,380 --> 00:36:25,460
this will cause an access violation to
be generated every time but this year

486
00:36:25,460 --> 00:36:30,200
the audience the instruction is used

487
00:36:30,200 --> 00:36:37,730
we will use use this to get notification
of of DTC's and what we'll do is we'll

488
00:36:37,730 --> 00:36:41,420
use the access violation handle to
emulate the RTC so that we will not

489
00:36:41,420 --> 00:36:53,990
interfere with the nine clients also we
need to look at that we need to talk

490
00:36:53,990 --> 00:36:59,390
about that attacker cannot spend much
time between the RTC and that is because

491
00:36:59,390 --> 00:37:02,690
on on multi-core CPUs

492
00:37:02,690 --> 00:37:08,840
there's lots of things going on and the
at this add noise to the channel

493
00:37:08,840 --> 00:37:13,850
there is a significance to fashion a
difference to function load here

494
00:37:13,850 --> 00:37:17,089
the thing is fluttering below you have a
hundred and twenty cycles of difference

495
00:37:17,090 --> 00:37:21,440
in timing with flash and flash as much
faster the difference is much smaller

496
00:37:21,440 --> 00:37:26,690
than just a handful of clock cycles and
as a fair bit of noise so will you

497
00:37:26,690 --> 00:37:32,120
the attacker is not capable of waiting
too long before calling his next RTC

498
00:37:32,120 --> 00:37:35,120
instruction to end the timing of the
attack

499
00:37:35,640 --> 00:37:41,940
the final thing that we need to know
about this is that when a seal flash

500
00:37:41,940 --> 00:37:48,270
instruction actually flushes and address
in the cache performance event is

501
00:37:48,270 --> 00:37:55,200
generated and it's a performance work
cash reference event unlike cast mrs.

502
00:37:55,200 --> 00:38:00,180
cash reference events are quite frequent
again this is a testimony to how well

503
00:38:00,180 --> 00:38:02,310
the l3 cache actually works

504
00:38:02,310 --> 00:38:07,259
performance wise but we can actually use
this for building a detection

505
00:38:10,470 --> 00:38:21,270
so I have designed this detection to be
a two-stage attack a two-stage detection

506
00:38:21,270 --> 00:38:24,660
I have two reasons for doing this

507
00:38:24,660 --> 00:38:29,370
the first reason is that the second
stage is expensive

508
00:38:29,370 --> 00:38:34,830
performance wise and thus we want to
avoid doing it on benign subject benign

509
00:38:34,830 --> 00:38:35,880
applications

510
00:38:35,880 --> 00:38:42,930
the second reason is that this two-stage
the detection method is pretty flexible

511
00:38:42,930 --> 00:38:46,169
in terms of other

512
00:38:46,740 --> 00:38:49,950
microtek torial attacks that due time

513
00:38:49,950 --> 00:38:55,049
instruction timing and I have this weird
feeling that we're going to see more

514
00:38:55,050 --> 00:38:57,840
attacks of this nature in the next
coming year

515
00:38:57,840 --> 00:39:00,840
so I like to be prepared to detect these
as well

516
00:39:01,800 --> 00:39:09,210
what we do in the first stage is that we
try to detect the bracket of ITC

517
00:39:09,210 --> 00:39:15,630
instructions and here we use this year
for TSD flag to get an access violation

518
00:39:15,630 --> 00:39:21,480
and count how many times do we see our
DTSC instructions less than type 2 micro

519
00:39:21,480 --> 00:39:26,550
seconds apart the two microseconds a
tuning value to micro sections seconds

520
00:39:26,550 --> 00:39:28,350
is a pretty conservative

521
00:39:28,350 --> 00:39:34,259
- what an attacker can actually afford
to spend between our two instructions if

522
00:39:34,260 --> 00:39:37,740
we get more than to work occurrences of
that in two seconds

523
00:39:37,740 --> 00:39:40,879
well we should proceed to step

524
00:39:40,880 --> 00:39:45,829
stage 2 which is detecting this your
first instruction if we do not we just

525
00:39:45,829 --> 00:39:52,549
do it again to make sure that nobody is
starting a new york flash attack

526
00:39:52,549 --> 00:39:58,160
so stage two

527
00:40:02,210 --> 00:40:11,509
so here we again use the CEO 40s
deflector get on interrupt on RTS see if

528
00:40:11,509 --> 00:40:16,849
we get this interrupt within half a
second of being in stage two

529
00:40:16,849 --> 00:40:23,089
we know that it was not flushing
flushing we can safely return to stage

530
00:40:23,089 --> 00:40:23,690
one

531
00:40:23,690 --> 00:40:28,190
however it was less than that we
proceeded to set up performance counting

532
00:40:28,190 --> 00:40:30,470
on interrupt references

533
00:40:30,470 --> 00:40:38,180
now when we do get a reference on get an
interrupt on the reference event we will

534
00:40:38,180 --> 00:40:39,379
use this in her up

535
00:40:39,380 --> 00:40:42,890
we'll ask ourselves that we spent more
than two microseconds since the last are

536
00:40:42,890 --> 00:40:49,670
DTSC and if we did we know that this
particular oddity is the instruction is

537
00:40:49,670 --> 00:40:54,619
not part of your flash attack early or
it's the end of us your flash attack

538
00:40:54,619 --> 00:41:01,069
so we'll return to the first part of the
stage 2 and to the next part is

539
00:41:01,069 --> 00:41:02,119
instruction

540
00:41:02,119 --> 00:41:07,910
if however it was fast enough after the
ITC instruction

541
00:41:07,910 --> 00:41:16,910
well we'll use to interrupt stack frame
to find out where memory

542
00:41:16,910 --> 00:41:20,839
these instruction across the cash
reference is placed and will read memory

543
00:41:20,839 --> 00:41:23,150
there to check if it's a seal flash
instruction

544
00:41:23,150 --> 00:41:27,380
obviously it was a seal flush it
instruction we will assume that this is

545
00:41:27,380 --> 00:41:31,579
a flash and flash attack and that is
pretty fair assumption given that are

546
00:41:31,579 --> 00:41:36,289
ttc instructions are rare and seal flash
instructions are really really rare

547
00:41:37,430 --> 00:41:42,980
in fact swear i have not found a benign
program that actually uses one but

548
00:41:42,980 --> 00:41:48,829
that's another thing if it's not caused
by a seal flash instruction we could

549
00:41:48,829 --> 00:41:52,620
assume that the attacker has put in a

550
00:41:52,620 --> 00:42:00,240
cash reference in an event to lead me
astray to upscale his attack and that's

551
00:42:00,240 --> 00:42:03,359
the way reason that we go back to
setting up the for performance counters

552
00:42:03,360 --> 00:42:07,560
to get an interrupt on the next cache
reference event and then we just repeat

553
00:42:07,560 --> 00:42:08,910
from there

554
00:42:08,910 --> 00:42:13,290
so are there any problems with doing
this

555
00:42:13,800 --> 00:42:18,120
well causing interrupt penalizes
performance on benign programs using our

556
00:42:18,120 --> 00:42:24,600
DTSC and programs using RTC is actually
fairly rare

557
00:42:25,380 --> 00:42:30,420
there are some visual studio so it's fun
programming stuff like this when your

558
00:42:30,420 --> 00:42:36,750
visual studio always crashes search
indexer stuff like that uses are you to

559
00:42:36,750 --> 00:42:40,080
see but it's very rare

560
00:42:40,080 --> 00:42:43,590
so we're not causing too much
disturbance in that direction but there

561
00:42:43,590 --> 00:42:44,880
is another problem

562
00:42:44,880 --> 00:42:50,910
possibly worse problem with doing this
since we are you spending time handling

563
00:42:50,910 --> 00:42:55,410
our interrupt and emulating the idea to
see instruction we actually make the

564
00:42:55,410 --> 00:43:00,930
timer less accurate for mitigating cast
such an attack that's actually a huge

565
00:43:00,930 --> 00:43:07,200
advantage but it might not be for benign
applications which are also affected so

566
00:43:07,200 --> 00:43:09,029
we should be aware of that

567
00:43:09,030 --> 00:43:14,280
then there's the question of is there
any other time as the naughty tsc and if

568
00:43:14,280 --> 00:43:18,330
there is how will that impact the
detection of that's pretty easy to

569
00:43:18,330 --> 00:43:22,950
detect entire detection hinges on the
IDT she already is the instruction being

570
00:43:22,950 --> 00:43:24,689
detected

571
00:43:24,690 --> 00:43:29,550
somebody suggested that i could have a
threat running and in this thread that's

572
00:43:29,550 --> 00:43:34,230
just count up an address until another
thread tells us to terminate

573
00:43:34,230 --> 00:43:38,760
I've been playing with this I've been
unable in any way to show that this

574
00:43:38,760 --> 00:43:42,840
actually is fast enough for accurate
enough in any way to do flash and flash

575
00:43:42,840 --> 00:43:43,590
with it

576
00:43:43,590 --> 00:43:47,400
I'll be happy to should be shown
otherwise I don't think it's happening

577
00:43:47,400 --> 00:43:51,870
there are the colonel more times
including performance counters and stuff

578
00:43:51,870 --> 00:43:56,100
like that or IDC could be lead from
kernel mode and that of course will

579
00:43:56,100 --> 00:43:59,100
break my detection as well

580
00:44:00,440 --> 00:44:05,359
finally there's a big problem with the
implementation and implemented under

581
00:44:05,359 --> 00:44:09,470
windows and you run into this funny
thing called patch guard that prevents

582
00:44:09,470 --> 00:44:18,500
me from looking interrupt my solution
was actually using windows XP for my for

583
00:44:18,500 --> 00:44:22,550
my implementation of my generalized
testing

584
00:44:22,550 --> 00:44:28,430
I have not seen too much performance
cost of this that's a about a percentage

585
00:44:28,430 --> 00:44:32,509
but it's very very very much

586
00:44:32,510 --> 00:44:36,619
across platforms the thing is i have not
seen a benign program that actually

587
00:44:36,619 --> 00:44:39,020
makes it just to the second stage

588
00:44:39,020 --> 00:44:45,829
I just not seeing it doesn't happen but
she'll flash dresses every time and when

589
00:44:45,829 --> 00:44:48,800
you finish something like this you
always ask yourself can you do better

590
00:44:48,800 --> 00:44:55,730
and I actually think we can and this
will be part of my research for the next

591
00:44:55,730 --> 00:44:59,270
year and i hope to blog on it sometime
during this year

592
00:45:00,319 --> 00:45:06,619
maybe it won't work so maybe you don't
see anything but maybe well so doing it

593
00:45:06,619 --> 00:45:12,170
like this you actually have to admit a
lot of stuff and I left all out the old

594
00:45:12,170 --> 00:45:16,130
all the gory details and that was
intentional because we don't really have

595
00:45:16,130 --> 00:45:17,060
time for it

596
00:45:17,060 --> 00:45:24,200
things i left at with things like how
does the process to decide what to

597
00:45:24,200 --> 00:45:28,129
victim when we access other memory
called the eviction policy

598
00:45:28,130 --> 00:45:32,119
how do we determine to which Kass said a
cache line is congruent

599
00:45:33,170 --> 00:45:38,510
these are things that we can all do it's
all relatively recent at the reason the

600
00:45:38,510 --> 00:45:42,440
reason that research that shows us how
we can do it in the past it has been

601
00:45:42,440 --> 00:45:50,180
done by another side channel attack or
timing attack on figuring out of when

602
00:45:50,180 --> 00:45:54,290
something gets thrown out of the first
things like that and i should mention

603
00:45:54,290 --> 00:45:58,190
there's other mitigation forecast
side-channel attacks the sideline

604
00:45:59,329 --> 00:46:03,920
this is as opposed to detection i'm
actually not aware of any other method

605
00:46:04,580 --> 00:46:09,170
for detecting casa John attacks other
than the ones i've talked about today

606
00:46:09,170 --> 00:46:16,130
now there is a future in modern see on
computers called cat

607
00:46:16,130 --> 00:46:19,580
I believe it's short for cash allocation
technology

608
00:46:19,580 --> 00:46:27,470
it's a performance-enhancing feature but
it can be used for actually providing

609
00:46:27,470 --> 00:46:30,379
privileges for the cash

610
00:46:30,380 --> 00:46:36,320
it doesn't work very well in my opinion
and and this is why I did most of

611
00:46:36,320 --> 00:46:38,780
Wallace chose to ignore it while it did
a little bit

612
00:46:38,780 --> 00:46:44,480
this stuff another thing you can do is
you can write branch free cast set aware

613
00:46:44,480 --> 00:46:45,470
code

614
00:46:45,470 --> 00:46:51,290
now what we saw in the example was that
we feature that allowed us to support

615
00:46:51,290 --> 00:46:57,020
what was going on in memory was that we
branched and you can imagine things like

616
00:46:57,020 --> 00:46:59,660
a raise and stuff like that

617
00:46:59,660 --> 00:47:05,299
being being spybubble and if you to make
your chrome really really careful you

618
00:47:05,300 --> 00:47:11,450
can actually make sure that you don't
read any vital information by being

619
00:47:11,450 --> 00:47:16,100
aware of what Cass said you're using and
why and avoiding branches and stuff like

620
00:47:16,100 --> 00:47:16,790
that

621
00:47:16,790 --> 00:47:19,790
turns out it's pretty difficult to
actually do this

622
00:47:21,170 --> 00:47:27,680
a recent example was that the openssl
library hot and there ra implementation

623
00:47:27,680 --> 00:47:33,470
to be branch recast aware and as it
turns out somebody figured out a

624
00:47:33,470 --> 00:47:37,370
different cache side-channel attack
which broke the new implementation

625
00:47:38,570 --> 00:47:47,510
this was called cash bleed it's not like
we cannot file that as well but it is

626
00:47:47,510 --> 00:47:51,830
quite difficult and I don't think it's a
method for for the broad things

627
00:47:52,340 --> 00:47:57,710
it's not like we're going to have a
colonel that's branch free cash said I

628
00:47:57,710 --> 00:48:02,000
where at any point in time it's just too
expensive and too difficult to write

629
00:48:02,000 --> 00:48:06,170
it's not like we're going to see
application developers handling your

630
00:48:06,170 --> 00:48:08,180
password in any kind of way

631
00:48:08,180 --> 00:48:12,649
branch for you cast aware so it's great
for crip - but it's not going to solve

632
00:48:12,650 --> 00:48:14,660
the problem

633
00:48:14,660 --> 00:48:24,560
so I've about reached the end of my
presentation I hope that you have all

634
00:48:24,560 --> 00:48:28,160
taken to heart that CPU design

635
00:48:28,160 --> 00:48:32,480
we're talking about CPU design here that
it actually poses a danger to bug free

636
00:48:32,480 --> 00:48:33,710
software

637
00:48:33,710 --> 00:48:37,550
I hope you have all taken to heart that
cast side-channel attacks are actually

638
00:48:37,550 --> 00:48:43,790
quite dangerous critters and quite
powerful and finally I hope that you

639
00:48:43,790 --> 00:48:48,830
have a general idea that we can we can
do something about this in software and

640
00:48:48,830 --> 00:48:54,500
we can even do something about this
software when the attacker is adapting

641
00:48:54,500 --> 00:48:59,450
so my closing remarks will be that
defeat want one that's going to make a

642
00:48:59,450 --> 00:49:04,399
closing keynote and she will be touching
this kind of stuff you can be sure that

643
00:49:04,400 --> 00:49:05,750
you'll find me there

644
00:49:05,750 --> 00:49:11,450
I hope to see the rest of you guys well
if your questions don't hesitate to ask

645
00:49:11,450 --> 00:49:13,520
I to love talking about this stuff

646
00:49:13,520 --> 00:49:16,910
it's a hobby of mine and I don't do this
professionally it's a hobby

647
00:49:17,600 --> 00:49:22,580
this means that if you have questions in
connection with this talk please ask

648
00:49:22,580 --> 00:49:25,400
them if you want to talk in private
please get hold of me if you want to

649
00:49:25,400 --> 00:49:32,900
email me do so thank you

650
00:49:35,150 --> 00:49:38,690
ok thank you for the talk

651
00:49:38,690 --> 00:49:41,900
I'm sure we all learned a lot about it
and does anybody have any questions

652
00:49:48,349 --> 00:49:54,440
hi Cheers I was just wondering what the
what was the rule hammer detection that

653
00:49:54,440 --> 00:49:56,839
you were running that you mentioned at
the start

654
00:49:56,839 --> 00:50:02,180
I'm on your own machine the role of a
detection basically it's the same as as

655
00:50:02,180 --> 00:50:05,569
the function below detection I talked
about here basically uses performance

656
00:50:05,569 --> 00:50:09,589
counters count cast mrs. and if you get
too many and too short . well its not

657
00:50:09,589 --> 00:50:13,819
benign software it's going to be Roma it
turns out it could also be flushing load

658
00:50:13,819 --> 00:50:16,460
but either way its not benign

659
00:50:16,460 --> 00:50:21,529
it just doesn't happen on compute well
it can happen but it's really rare and

660
00:50:21,529 --> 00:50:27,289
so for most people is going to be good
enough but there are false positives so

661
00:50:27,289 --> 00:50:30,400
and things like lip quantum

662
00:50:30,400 --> 00:50:35,920
like weird stuff that access memory and
weird patterns and a lot of time to hope

663
00:50:35,920 --> 00:50:37,210
that answers your question

664
00:50:37,210 --> 00:50:49,809
well how much will be having a shared
memory is a requirement to attack shared

665
00:50:49,809 --> 00:50:55,779
memory is required for flushing the load
and variations thereof which includes

666
00:50:55,779 --> 00:51:02,770
flush flush the thing is the reload face
you access memory to find out the state

667
00:51:02,770 --> 00:51:09,009
of the cash after the victims run for
Prime improvement of it and and second

668
00:51:09,010 --> 00:51:17,710
time we are using cash code congruence
which is a lower door criteria that

669
00:51:17,710 --> 00:51:21,369
means that you actually don't have to
share a can access to memory

670
00:51:21,369 --> 00:51:26,319
meaning that you can do cross DM attacks
whatever you really like you don't need

671
00:51:26,319 --> 00:51:29,950
to know anything about that addresses
that is not your own to actually do this

672
00:51:30,940 --> 00:51:36,339
so private probe for for cloud things

673
00:51:36,339 --> 00:51:41,349
it's probably be one to go to where
Victor time is probably more of these

674
00:51:41,349 --> 00:51:42,670
special use cases

675
00:51:42,670 --> 00:51:47,770
you know the answer we talking about
physically tagged cache lines or

676
00:51:47,770 --> 00:51:51,520
beautiful Italian - lines and not sure
about the Intel Architecture I wasn't

677
00:51:51,520 --> 00:51:52,569
going to talk a bit louder

678
00:51:52,569 --> 00:51:57,819
yep are we talking about physically
attacked cache line sort of usually i'm

679
00:51:57,819 --> 00:52:00,549
sure it works on the only Intel our
collection

680
00:52:00,549 --> 00:52:04,569
I know another stuff but the question is
that you have a our physical address

681
00:52:04,569 --> 00:52:06,369
memory right

682
00:52:06,369 --> 00:52:09,849
I want to talk about addresses i talk
about physical address ok

683
00:52:09,849 --> 00:52:18,520
it's all about physical addresses the l3
and l2 caches are both driven by

684
00:52:18,520 --> 00:52:20,390
physical addresses

685
00:52:20,390 --> 00:52:25,819
which is a light which allows us to my
bypass the paging system the l1 cache is

686
00:52:25,819 --> 00:52:30,440
a is a bit special in that direction so
running attacks on on the l1 cache is an

687
00:52:30,440 --> 00:52:34,760
entirely different different story
doesn't doesn't disposed a requirement

688
00:52:34,760 --> 00:52:39,019
that you know actually the physical
address of the day that you want to

689
00:52:39,019 --> 00:52:39,890
attack

690
00:52:39,890 --> 00:52:45,019
well it's one of the things that I
admitted what you typically do to find

691
00:52:45,019 --> 00:52:53,479
out find out cash , congruence isn't the
physical address if you're using large

692
00:52:53,480 --> 00:52:56,359
to make about Paige's the virtual
address actually leaks enough

693
00:52:56,359 --> 00:53:03,769
information to do it but what you do in
in cases where is that you do a timing

694
00:53:03,769 --> 00:53:06,500
attack on castro chrome gruen see

695
00:53:06,500 --> 00:53:14,299
so by loading say in different addresses
and then timing what how long it takes

696
00:53:14,299 --> 00:53:19,640
to to to access them adding one address
timing or 11 at some point you'll find

697
00:53:19,640 --> 00:53:20,240
out

698
00:53:20,240 --> 00:53:25,008
oh I created a cache miss and you will
know that you have within the set of of

699
00:53:25,009 --> 00:53:28,819
data you'll have a set that is congruent
right

700
00:53:28,819 --> 00:53:34,279
ok thanks also look ok any other
questions

701
00:53:39,420 --> 00:53:42,210
okay . and then thanks a lot again for
the dark

