1
00:00:14,519 --> 00:00:17,340
awesome so today I'm going to talk

2
00:00:17,340 --> 00:00:23,340
when your processes or your systems you
have some have bad neighbors and

3
00:00:23,340 --> 00:00:27,570
specifically how this can happen in the
in hardware environments

4
00:00:29,040 --> 00:00:36,720
so just to start off who am i I'm Sofia
Antoine my work as a security researcher

5
00:00:36,720 --> 00:00:39,360
in New York at trail of bits

6
00:00:39,360 --> 00:00:44,489
I'm and most of this work that I'm
presenting it is built off of the work I

7
00:00:44,489 --> 00:00:49,050
put into my master's thesis which I
finished last year and my free time of

8
00:00:49,050 --> 00:00:52,230
course i play CTF so feel free to talk
about that with me afterwards

9
00:00:54,000 --> 00:00:57,960
so this is the overview for the talk
today I'm just going to start off with

10
00:00:57,960 --> 00:01:01,770
the general introduction to what
side-channel attacks are though i'm sure

11
00:01:01,770 --> 00:01:06,990
a lot of you have a good understanding
of that but specifically we talk about

12
00:01:06,990 --> 00:01:11,789
attacks in the world of side channels
what we actually mean is information

13
00:01:11,789 --> 00:01:17,160
leakage is not necessarily an attack of
what i call the first order

14
00:01:17,160 --> 00:01:23,550
it's like memory corruption something
where you go in and alter the the target

15
00:01:23,550 --> 00:01:31,380
itself side-channel attacks are
generally attacks which do not alter or

16
00:01:31,380 --> 00:01:36,179
change the program that you're targeting
but change the system that that target

17
00:01:36,179 --> 00:01:42,509
is interacting with or they win based
off of information they can gain from

18
00:01:42,509 --> 00:01:49,649
the system that that target is
interacting with so specifically an

19
00:01:49,649 --> 00:01:50,520
attacker

20
00:01:50,520 --> 00:01:56,699
when looking at to form of side-channel
attack observes target system but cannot

21
00:01:56,700 --> 00:02:02,220
introspect into it so he must have a few
things you can do

22
00:02:02,220 --> 00:02:07,739
he must be able to repeatedly query the
system that that target is operating in

23
00:02:07,739 --> 00:02:16,860
as well as know that what he's clearing
isn't altered by his introspection into

24
00:02:16,860 --> 00:02:21,390
it and that's the building blocks for a
side channel attack

25
00:02:21,390 --> 00:02:25,859
there's different types of side-channel
attacks specifically in the realm of

26
00:02:25,860 --> 00:02:27,470
hardware

27
00:02:27,470 --> 00:02:31,340
so common ones are the ones i've listed
here like fault attacks and that

28
00:02:31,340 --> 00:02:37,400
requires access to the hardware so
you're flipping bits by I'm changing the

29
00:02:37,400 --> 00:02:41,390
heat that the specific part of the
hardware has or something like that

30
00:02:42,350 --> 00:02:46,940
power analysis side channels are when
you would take readings of the system

31
00:02:46,940 --> 00:02:51,020
and in heat signatures and how that
interacts with the environment to get

32
00:02:51,020 --> 00:02:54,710
information about what the system is
doing and then the last one is actually

33
00:02:54,710 --> 00:02:58,490
the most common so a lot of side-channel
attacks that are coming out the past few

34
00:02:58,490 --> 00:03:04,190
years have really used the element of
time and timing attacks to gain

35
00:03:04,190 --> 00:03:09,859
information about a system or do some
other sort of attack with it and this

36
00:03:09,860 --> 00:03:16,550
require is a process colocation so that
means that you're attacking process has

37
00:03:16,550 --> 00:03:22,010
to be co-located on the same hardware to
perform that timing attack or co located

38
00:03:22,010 --> 00:03:27,500
in the same system so an example of that
would be network packet delivery time

39
00:03:27,500 --> 00:03:33,440
so you're into attacking process would
record that packet delivery time but in

40
00:03:33,440 --> 00:03:38,840
order for that to be profitable it must
be co-located or neighboring of that the

41
00:03:38,840 --> 00:03:46,820
target attack that the targeting must be
co-located with the the target so must

42
00:03:46,820 --> 00:03:51,980
be on the same machine or and the same
network as the the target that you're

43
00:03:51,980 --> 00:03:52,730
looking at

44
00:03:52,730 --> 00:03:59,238
so this is just this example in
cryptography usually in in the realm of

45
00:03:59,239 --> 00:04:04,220
academia and research papers to prove
you have a hardware side channel they

46
00:04:04,220 --> 00:04:08,900
usually apply it to a cryptographic
functions and breaking crypto so leaking

47
00:04:08,900 --> 00:04:10,190
private keys

48
00:04:10,190 --> 00:04:15,470
once you can do that you have a good
side channel and so in this case of this

49
00:04:15,470 --> 00:04:22,280
quotes from Wikipedia but you're
observing an RSA key encryption using

50
00:04:22,280 --> 00:04:28,789
the private key and using power analysis
they can form this graph here and a lot

51
00:04:28,790 --> 00:04:34,370
of it ends up becoming a taking lots of
readings over time of the power that

52
00:04:34,370 --> 00:04:36,620
that system is

53
00:04:36,620 --> 00:04:43,160
emitted during this encryption using RSA
private key and I taking those

54
00:04:43,160 --> 00:04:48,710
measurements over time you can look at
it and start to see patterns forming and

55
00:04:48,710 --> 00:04:53,510
most side-channel attacks end up
becoming pattern recognition so you take

56
00:04:53,510 --> 00:04:54,919
lots of data points

57
00:04:54,919 --> 00:05:00,740
you keep making measurements or keep
doing something repeatedly until you can

58
00:05:00,740 --> 00:05:06,560
extract out meaning in that system and
so here you see that taking lots of

59
00:05:06,560 --> 00:05:10,910
power readings and sampling power from
that system they were able to say that

60
00:05:10,910 --> 00:05:15,919
for the majority of the time when the
power sampled in a specific time frame

61
00:05:15,919 --> 00:05:22,549
is over a certain threshold that can be
represented as a 1-bit and so forth

62
00:05:22,550 --> 00:05:28,220
until you have the whole key and this is
just a depiction of what's going on here

63
00:05:28,220 --> 00:05:33,979
so out what we're doing is we're gaining
information through measuring recordable

64
00:05:33,979 --> 00:05:38,030
changes in the system so in this case
it's the heat signature of the hardware

65
00:05:38,030 --> 00:05:43,130
of its a itself so the implementation of
the crypto system and we treat that

66
00:05:43,130 --> 00:05:47,719
implementation of the crypto system is a
black box but we're making those

67
00:05:47,720 --> 00:05:53,870
measurements of recordable changes in
this case the heat over a period of time

68
00:05:53,870 --> 00:05:59,780
and that Delta will tell us if it's a
one or a zero bit

69
00:05:59,780 --> 00:06:06,679
alright so that was a really specific
example but there's some basic

70
00:06:06,680 --> 00:06:13,940
requirements that all side channels have
soap our timing attacks fault attacks

71
00:06:13,940 --> 00:06:21,169
those sort of things they all require
three main primitives as i call them and

72
00:06:21,169 --> 00:06:23,810
the first is a shared environment

73
00:06:23,810 --> 00:06:29,870
you have to have some sort of medium
that you can both query and know that

74
00:06:29,870 --> 00:06:34,940
you reading that system for measuring
that system doesn't alter the

75
00:06:34,940 --> 00:06:41,300
measurement itself and the transmitter
in this case would be the encryption

76
00:06:41,300 --> 00:06:43,699
process so it's the process that you're
targeting

77
00:06:43,699 --> 00:06:48,680
it's running on the system and because
of its behavior it's changing the system

78
00:06:48,680 --> 00:06:49,470
so its effect

79
00:06:49,470 --> 00:06:54,000
in that chair environment and from a
receiving standpoint as the malicious

80
00:06:54,000 --> 00:06:55,050
attacker

81
00:06:55,050 --> 00:06:59,850
you're reading information from that
shirt environment put there by the the

82
00:06:59,850 --> 00:07:05,550
target or the transmitter but that
measurement of the information does not

83
00:07:05,550 --> 00:07:07,980
alter the shared hardware

84
00:07:07,980 --> 00:07:10,980
so these are three common primitives
across all side-channel attacks

85
00:07:11,880 --> 00:07:20,969
so using these three different kind of
structures here we can actually form

86
00:07:20,970 --> 00:07:28,470
three different classifications of
side-channel attacks and the first

87
00:07:28,470 --> 00:07:30,840
scenario is the one I've been talking
about

88
00:07:30,840 --> 00:07:37,320
come up until this point and that's when
your transmitter is unaware that it's

89
00:07:37,320 --> 00:07:43,380
transmitting it's running its encryption
processes on on a cpu somewhere and it's

90
00:07:43,380 --> 00:07:47,580
running its unaware that someone's
eavesdropping on it and the receiver is

91
00:07:47,580 --> 00:07:52,169
gaining information from that system so
reading some information from that

92
00:07:52,169 --> 00:07:58,799
shared hardware that allows it to make
some sort of mapping between that gain

93
00:07:58,800 --> 00:08:03,090
information and you know the
transmitters are a private key

94
00:08:04,530 --> 00:08:08,520
that's the first application of this but
there's other things you can do with

95
00:08:08,520 --> 00:08:14,789
this sort of model of a active on a
we're transmitting process and a

96
00:08:14,790 --> 00:08:19,710
malicious eavesdropper or recording
process reading from the system

97
00:08:20,220 --> 00:08:24,660
there's many different research papers
that went into environmental King so

98
00:08:24,660 --> 00:08:31,260
determining colocation on the same
hardware for instance a broadcast signal

99
00:08:31,260 --> 00:08:32,069
so for it

100
00:08:32,070 --> 00:08:37,050
for instance if you have a botnet
structure and the transmitter is doing

101
00:08:37,049 --> 00:08:43,109
some sort of behavior on the CP or on
the shared environment that the receiver

102
00:08:43,110 --> 00:08:48,030
can can glean from this your environment
that can be treated as a broadcast

103
00:08:48,030 --> 00:08:52,620
signal so as many different applications
of it but that's more about intention

104
00:08:52,620 --> 00:08:55,620
and not about the vulnerability itself

105
00:08:57,889 --> 00:09:01,459
art so the second scenario is is
actually the opposite

106
00:09:01,459 --> 00:09:05,059
all right so you have a receivers which
is recording from the system but is

107
00:09:05,059 --> 00:09:07,399
unaware that it's recording

108
00:09:07,399 --> 00:09:10,459
just just basically noisy processes
running on the system

109
00:09:11,179 --> 00:09:17,929
the transmitter however is intentionally
sending specific behavioral patterns to

110
00:09:17,929 --> 00:09:22,730
the shared environment and what actually
happens here is you can do something

111
00:09:22,730 --> 00:09:29,269
like a dog attack so for instance a
process uses up all the cpu time

112
00:09:29,269 --> 00:09:33,199
let's say the schedule is really bad and
just completely takes over all the

113
00:09:33,199 --> 00:09:34,579
shared resources

114
00:09:34,579 --> 00:09:40,878
kind of like mine you know and then it
means that no other processes can use it

115
00:09:40,879 --> 00:09:46,730
so this is kind of left discussed if not
as interesting necessarily to

116
00:09:46,730 --> 00:09:51,259
researchers in the past few years but
it's definitely another application of a

117
00:09:51,259 --> 00:09:57,829
side channel and the third scenario is
when both of them are intentionally

118
00:09:57,829 --> 00:09:59,868
sending receiving for to each other

119
00:09:59,869 --> 00:10:07,519
so for instance you have two processes
running on a shared environment and both

120
00:10:07,519 --> 00:10:11,419
of them are intentionally sending
behavioral patterns to the system and

121
00:10:11,419 --> 00:10:16,939
recording them from the system back and
forth and this creates something like a

122
00:10:16,939 --> 00:10:22,248
classical covert channel when you read
about that in this communication medium

123
00:10:22,249 --> 00:10:27,169
specifically in this talk is a shared
hardware but it can be anything

124
00:10:27,169 --> 00:10:31,610
right so you have the idea of forcing
shared some sort of behavioral pattern

125
00:10:31,610 --> 00:10:36,110
and recording that pattern to create a
covert channel

126
00:10:36,110 --> 00:10:44,329
alright so we have this basic model of
receiver transmitter and shared medium

127
00:10:44,329 --> 00:10:48,799
to create a side channel but what
happens when we apply that to to

128
00:10:48,799 --> 00:10:49,639
hardware

129
00:10:49,639 --> 00:10:54,470
ok so we're going to start off with the
same models we have a transmitter

130
00:10:54,470 --> 00:10:58,549
receiver but now that's shared
environment or shared medium is is

131
00:10:58,549 --> 00:11:02,689
hardware and this kind of changes the
state of what we can do

132
00:11:02,689 --> 00:11:04,680
slightly

133
00:11:04,680 --> 00:11:09,959
so if you have two processes running on
the system be that in separate operating

134
00:11:09,960 --> 00:11:12,960
systems or in one operating system

135
00:11:13,800 --> 00:11:17,099
maybe one processes inside of vm so it's
sandbox

136
00:11:17,100 --> 00:11:22,050
they all end up sharing actual hardware
components listed here

137
00:11:23,160 --> 00:11:31,079
so the processors the cash tears system
buses they all end up sharing these

138
00:11:31,080 --> 00:11:36,180
things and these would become the medium
that were using to send and receive

139
00:11:36,180 --> 00:11:39,209
artifacts for our Channel

140
00:11:39,209 --> 00:11:50,609
ok so in this specific case we are using
cpu cpus our caches or other aspects of

141
00:11:50,610 --> 00:11:53,010
a computer to create a side channel

142
00:11:53,010 --> 00:11:58,319
that's the transmitting process must be
able to do these things so if we talked

143
00:11:58,320 --> 00:12:02,399
about this before but it must be able to
affect the state of the hardware

144
00:12:02,399 --> 00:12:07,830
component that is using as the medium
and that must be in such a way that is

145
00:12:07,830 --> 00:12:13,650
completely observable recordable from
all other processes and repeatable so it

146
00:12:13,650 --> 00:12:18,209
can send some sort of message repeatedly
over time but at the same time it can't

147
00:12:18,209 --> 00:12:24,839
do it in such a way that the optimizers
on the computer will mess up somehow it

148
00:12:24,839 --> 00:12:26,070
has to be reliable

149
00:12:26,070 --> 00:12:32,820
so that is one difficulty people have
with creating side channels / hardware

150
00:12:32,820 --> 00:12:38,820
on the other hand the receiving process
must be able to record these changes in

151
00:12:38,820 --> 00:12:46,680
either the pipeline or the cash tears or
the main memory but do that without

152
00:12:46,680 --> 00:12:50,489
affecting the actual artifacts that are
being placed there without affecting the

153
00:12:50,490 --> 00:12:55,890
transmitted behavior that the
transmitting process is putting their

154
00:12:55,890 --> 00:13:01,290
alright so we have these primitives

155
00:13:01,290 --> 00:13:06,329
I'm going back over them and we have
shared pieces of hardware resources so

156
00:13:06,329 --> 00:13:13,199
we're sharing the same cache or the same
pipeline between multiple processes

157
00:13:14,540 --> 00:13:21,260
these processes are these resources are
dynamically allocated so I'm not all

158
00:13:21,260 --> 00:13:26,120
modern computers one process is an
allocated X amount of space in the cash

159
00:13:26,120 --> 00:13:30,860
and that's its piece of the cash for the
entire run of the process that's not how

160
00:13:30,860 --> 00:13:33,860
how computers work because it's not
efficient

161
00:13:33,860 --> 00:13:38,390
so all resources that are shared between
processes are dynamically allocated

162
00:13:38,390 --> 00:13:45,199
based on need and we can actually abuse
that a basic optimization that modern

163
00:13:45,200 --> 00:13:53,600
computers use to create contentions
between processes and this can take many

164
00:13:53,600 --> 00:13:57,500
different forms depending on which
hardware unit you're using but the real

165
00:13:57,500 --> 00:14:02,540
vulnerability for all heart hardware
side channels is that element of dynamic

166
00:14:02,540 --> 00:14:08,510
translation and forced contention and
you can use those that optimization

167
00:14:08,510 --> 00:14:15,200
model 22 deterministically send messages
and create covert channels across

168
00:14:15,200 --> 00:14:17,120
different pieces of hardware

169
00:14:17,120 --> 00:14:24,230
yes like I was saying it's a physical
colocation your two processes running on

170
00:14:24,230 --> 00:14:29,360
the same computer that contention
between dynamically allocated resources

171
00:14:29,360 --> 00:14:34,460
and this leads to the actual
vulnerability

172
00:14:39,230 --> 00:14:48,320
and this actually happens most
frequently with processes that you don't

173
00:14:48,320 --> 00:14:52,700
know of or maybe operating systems that
you don't have control of in the cloud

174
00:14:52,700 --> 00:14:55,700
so when you're running for two processes
on your own computer

175
00:14:56,450 --> 00:15:00,710
there's a good chance that you know
what's going on but in the cloud you're

176
00:15:00,710 --> 00:15:04,100
actually sharing hardware with processes
and operating systems that you have no

177
00:15:04,100 --> 00:15:09,410
control over and and they might be
malicious intentionally or not

178
00:15:09,410 --> 00:15:17,329
alright so how can we create these side
channel side channels / hardware in the

179
00:15:17,330 --> 00:15:24,530
cloud so everyone here probably knows
the basic structures of cloud computing

180
00:15:25,280 --> 00:15:30,020
when you get a bunch of virtual
instances as seen here and these are

181
00:15:30,020 --> 00:15:37,250
allocated on one large hardware unit and
this allocation happens to the

182
00:15:37,250 --> 00:15:42,080
hypervisor so we've had a couple of
talks talks the past few days on on that

183
00:15:42,080 --> 00:15:47,660
hypervisor level level work and friends
but that's the main idea of the cloud

184
00:15:47,660 --> 00:15:53,060
and the reason that - done is because
this dynamic allocation between real

185
00:15:53,060 --> 00:15:57,859
hardware resources and the virtual
hardware resources have seen by the

186
00:15:57,860 --> 00:16:03,410
operating systems reduces costs for
everyone so some good business model

187
00:16:03,410 --> 00:16:09,920
that works but this is basically the
idea of force contention resource

188
00:16:09,920 --> 00:16:15,860
allocation but on a very large scale
with processes that you haven't created

189
00:16:15,860 --> 00:16:16,700
yourself

190
00:16:16,700 --> 00:16:19,700
so foreign processes

191
00:16:21,240 --> 00:16:26,399
art show in the cloud kind of taking a
step back there's a few different attack

192
00:16:26,399 --> 00:16:27,180
scenarios

193
00:16:27,180 --> 00:16:31,709
alright so a lot of people may not store
their data in the cloud because it's

194
00:16:31,709 --> 00:16:32,849
stored remotely

195
00:16:32,850 --> 00:16:37,920
they don't have physical access to that
piece of hardware store data the host

196
00:16:37,920 --> 00:16:42,479
might be vulnerable or untrustable but
the one we're focusing on is the fact

197
00:16:42,480 --> 00:16:48,540
that your processes are co-located with
foreign vm with form processes and

198
00:16:48,540 --> 00:16:55,500
they're sharing that physical hardware
down here and this is just in the

199
00:16:55,500 --> 00:17:00,120
diagram of how that looks just showing
the virtual allocations which are

200
00:17:00,120 --> 00:17:06,599
created dynamically across time by the
hypervisor good to basically share that

201
00:17:06,599 --> 00:17:08,159
that physical resource

202
00:17:08,160 --> 00:17:11,250
I'm down here

203
00:17:11,250 --> 00:17:14,250
alright so creating hardware side
channels in the cloud

204
00:17:16,530 --> 00:17:20,220
we know that we need a medium to create
a side channel and in this case it's

205
00:17:20,220 --> 00:17:24,510
going to be one of the hardware units
that I listed earlier we're going to try

206
00:17:24,510 --> 00:17:30,420
and do an attack which is cross vm so
from between two processes but one

207
00:17:30,420 --> 00:17:37,320
processes of one vm the other is another
and the method of I guess

208
00:17:37,320 --> 00:17:41,639
creating a side channel attack here is
making recordable changes in the system

209
00:17:41,640 --> 00:17:47,730
and enforcing those and receiving those
in that vulnerability like I talked

210
00:17:47,730 --> 00:17:52,860
about before is the translation between
physical and in virtual and the

211
00:17:52,860 --> 00:17:59,280
contention that that causes and this is
just depictions of the different types

212
00:17:59,280 --> 00:18:05,010
of scenarios you could have where
perhaps a one virtual machine is

213
00:18:05,010 --> 00:18:09,540
intentionally malicious or just the
process inside of it or there's two

214
00:18:09,540 --> 00:18:14,520
processes in the same operating system
one is delicious and what is not

215
00:18:14,520 --> 00:18:18,809
there's many different ways in which
these hardware side channels can

216
00:18:18,809 --> 00:18:22,340
actually be applicable to your process

217
00:18:22,340 --> 00:18:29,928
all right so I thought it'd be kind of
fun to show how if you ever want to get

218
00:18:29,929 --> 00:18:32,929
a research paper out or do you do
something on your free time

219
00:18:33,710 --> 00:18:37,760
it's actually quite simple to kind of
build your own side channel

220
00:18:38,330 --> 00:18:42,080
you only need a few different components
and maybe it'll be more or less

221
00:18:42,080 --> 00:18:46,520
effective but it's very methodical

222
00:18:46,520 --> 00:18:50,629
so the first step is to choose the
medium so what medium are you going to

223
00:18:50,630 --> 00:18:57,919
use to send and receive signals across
so you can choose different shared

224
00:18:57,919 --> 00:19:02,419
pieces of hardware in this case the cash
for instance there is a great talked

225
00:19:02,419 --> 00:19:09,529
earlier about that or the processors or
the system buses so something this you

226
00:19:09,529 --> 00:19:12,919
have to choose a method that you're
going to use to make a measurement

227
00:19:12,919 --> 00:19:17,659
across this shared piece of hardware so
are you going to use a timing attack

228
00:19:17,659 --> 00:19:21,710
across the shared hardware to measure
cache misses

229
00:19:21,710 --> 00:19:26,419
I'm gonna use that to send a bits of
information are you going to use

230
00:19:26,419 --> 00:19:29,539
computational results to say

231
00:19:29,539 --> 00:19:32,539
Oh an incorrect value here can imply
something else

232
00:19:33,740 --> 00:19:37,190
resource contention is something else as
well that people you have used I've seen

233
00:19:37,190 --> 00:19:43,640
a paper where a researcher took two
different processes and locked the

234
00:19:43,640 --> 00:19:50,570
memory bus on the entire computer and
that was one bit of information is a

235
00:19:50,570 --> 00:19:55,970
very strong noiseless side channel but
also very noisy in the sense that was

236
00:19:55,970 --> 00:19:56,779
detectable

237
00:19:56,779 --> 00:20:02,090
so it was those funny but any other way
of measuring your piece of shared

238
00:20:02,090 --> 00:20:03,049
hardware

239
00:20:03,049 --> 00:20:08,990
you can use to create a side channel
alright so now we're going to choose a

240
00:20:08,990 --> 00:20:13,850
attack model are we going to choose

241
00:20:13,850 --> 00:20:18,469
scenario one or two or three this
depends on what sort of attack you want

242
00:20:18,470 --> 00:20:24,890
to do for the sake of this talk I'm
going to go ahead and keep discussing it

243
00:20:24,890 --> 00:20:32,350
using a recorder only so just kind of
eavesdropping on other processes of this

244
00:20:32,350 --> 00:20:37,719
like in the crypto RSA key Peele example

245
00:20:40,419 --> 00:20:47,230
all right so I kind of discussed a some
different case studies before the memory

246
00:20:47,230 --> 00:20:51,549
bus one also the cash side channels are
also quite common

247
00:20:52,150 --> 00:20:59,710
it's it's a lot easier to use the cash
but it's it's more reliable because that

248
00:20:59,710 --> 00:21:04,720
Hardware medium is static and what I
mean by that is as that you can send

249
00:21:04,720 --> 00:21:09,370
bits of information or receive them
pretty deterministically because it is

250
00:21:09,370 --> 00:21:15,639
memory you can say oh my value is in
memory in the tier 1 cash for the tier

251
00:21:15,640 --> 00:21:20,020
two or three and you can know that it's
either there or not it's very binary

252
00:21:20,020 --> 00:21:23,590
so it's a very strong side channel
medium

253
00:21:26,440 --> 00:21:30,700
alright so there's some difficulties
associated with different mediums that

254
00:21:30,700 --> 00:21:31,990
you choose

255
00:21:31,990 --> 00:21:36,370
so is it easy or not - - actually query
that hardware unit

256
00:21:36,370 --> 00:21:42,010
like I said before the cash is pretty
deterministic in the sense that you can

257
00:21:42,010 --> 00:21:47,230
see if your value is in memory or not at
a specific location but other hardware

258
00:21:47,230 --> 00:21:52,450
units are or less reliable or more
difficult to to measure for instance

259
00:21:52,450 --> 00:21:58,960
using the CPUs pipeline you actually can
introspect into it right because if you

260
00:21:58,960 --> 00:22:03,520
wrote some instructions that
introspective into the pipeline

261
00:22:03,520 --> 00:22:07,000
you'd be changing the state of the
pipeline itself so you have to do is

262
00:22:07,000 --> 00:22:12,520
come with more roundabout ways to make
measurements of harder harder

263
00:22:12,520 --> 00:22:20,830
side-channel units so this stag or of
this vegas diagram is it is based off

264
00:22:20,830 --> 00:22:25,600
literature survey i did last year and it
sits in here more for

265
00:22:26,279 --> 00:22:31,019
notes later on people are interested but
it just kind of outlines popular

266
00:22:31,019 --> 00:22:35,849
transmitting and reception mechanisms
used in the majority of research papers

267
00:22:35,849 --> 00:22:42,418
out there for different side channel
medium so I'm for instance main memory a

268
00:22:42,419 --> 00:22:50,129
very common transmitting mechanism is
priming and probing shared memory in in

269
00:22:50,129 --> 00:22:55,259
the main memory unit and you're
measuring access capabilities so that

270
00:22:55,259 --> 00:23:02,159
could be mapped to a specific bits of
meeting or something and this again is

271
00:23:02,159 --> 00:23:09,749
similar diagram accept a bit more
simplified so for instance in i'll go

272
00:23:09,749 --> 00:23:14,460
over the the functional units is quite
interesting so you're transmitting bits

273
00:23:14,460 --> 00:23:19,950
of meaning by using a method of resource
eviction in the functional unit and from

274
00:23:19,950 --> 00:23:26,549
the receiving process you can time to
see if you your threads that you create

275
00:23:26,549 --> 00:23:31,739
have the ability to use different
functional units on the shared cpu and

276
00:23:31,739 --> 00:23:34,769
that can be also mapped to different
bits of meeting

277
00:23:34,769 --> 00:23:38,639
so you see here that timing is quite
popular is a form of receiving

278
00:23:38,639 --> 00:23:41,639
information

279
00:23:42,599 --> 00:23:49,678
all right so I'm gonna go in into some
demos as well as more specific examples

280
00:23:49,679 --> 00:23:56,190
to different hardware units so this
first example is is kind of an outline

281
00:23:56,190 --> 00:24:02,249
of the different steps you would take to
make a side channel over the l1 cache in

282
00:24:02,249 --> 00:24:06,629
this example you first have to determine
co residency so you're trying to create

283
00:24:06,629 --> 00:24:11,849
a side channel in the cloud and you want
your vm you start running your processes

284
00:24:11,849 --> 00:24:15,749
and you're listening to the environment
you're receiving information about the

285
00:24:15,749 --> 00:24:19,409
l1 caches behavior from your new vm

286
00:24:19,409 --> 00:24:26,549
so you classify these patterns and you
have to have some before hand knowledge

287
00:24:26,549 --> 00:24:31,289
about what that pattern should look like
what's your target environment and once

288
00:24:31,289 --> 00:24:31,980
you can

289
00:24:31,980 --> 00:24:39,210
reduce the noise and kind of see a clean
signature or environmental signature

290
00:24:39,210 --> 00:24:43,860
then you can determine if your co
resident or not so does that map to a

291
00:24:43,860 --> 00:24:48,270
pattern that you expect or on that a
pattern that you know is being created

292
00:24:48,270 --> 00:24:51,840
by a specific type of process

293
00:24:51,840 --> 00:24:55,770
alright so the first demo

294
00:24:56,280 --> 00:25:01,230
I actually have time to run this by of
code on github later

295
00:25:01,230 --> 00:25:06,660
I'm is over the l3 cache I guess there's
a whole talk about that earlier so don't

296
00:25:06,660 --> 00:25:10,860
go too much in depth but for this case
if there was a time to check the

297
00:25:10,860 --> 00:25:12,090
vulnerability

298
00:25:12,090 --> 00:25:15,178
it's a simple method of recording

299
00:25:15,179 --> 00:25:20,580
how far into memory do you have to go to
receive your value and based on that

300
00:25:20,580 --> 00:25:26,970
distance it will take longer or shorter
to receive that value and I using this

301
00:25:26,970 --> 00:25:32,700
method you can determine how many
different things but in most cases and

302
00:25:32,700 --> 00:25:37,770
in the code provided you're stealing the
center of the transmitters are as a

303
00:25:37,770 --> 00:25:41,250
private key so I have some diagrams here

304
00:25:41,880 --> 00:25:46,410
it's called the flesh and reload tech
there is a paper done three years ago

305
00:25:46,410 --> 00:25:51,299
now at linked to at the bottom and this
was one of the first large papers that

306
00:25:51,299 --> 00:25:56,730
showed how how powerful the l3 cache is
as a side channel medium so it's very

307
00:25:56,730 --> 00:25:57,929
efficient

308
00:25:57,929 --> 00:26:03,630
it's very reliable and and simple in a
very elegant way so what you're doing is

309
00:26:03,630 --> 00:26:10,440
the receiver is forcing a specific code
out of the l3 cache and measuring

310
00:26:10,440 --> 00:26:13,530
measuring later after wait a little bit

311
00:26:13,530 --> 00:26:19,830
the transmitter is performing tomorrow
say encryption in between that forced

312
00:26:19,830 --> 00:26:25,830
eviction and measurement that the
receiver is taking and based on what the

313
00:26:25,830 --> 00:26:30,510
transmitter is doing or the victim is
doing with RSA encryption the receiver

314
00:26:30,510 --> 00:26:31,770
knows that

315
00:26:31,770 --> 00:26:37,440
oh that new value was put into the l3
cache so it actually took a lot quicker

316
00:26:37,440 --> 00:26:39,460
to receive it back

317
00:26:39,460 --> 00:26:44,799
or not now this attracted required
knowledge of the target code so the

318
00:26:44,799 --> 00:26:51,158
receiver had to know what sort of code
it was looking for before and evicted it

319
00:26:51,159 --> 00:26:59,919
and measured i get access again from the
l3 cache and you can go to these two two

320
00:26:59,919 --> 00:27:06,970
links here to find more code or a
detailed write-up about that attack but

321
00:27:06,970 --> 00:27:10,539
they were actually very successful so in
this example they were targeting the

322
00:27:10,539 --> 00:27:13,539
going to PG encryption method

323
00:27:15,460 --> 00:27:21,610
alright so for demo to our this is the
work that i presented at black cat last

324
00:27:21,610 --> 00:27:28,719
year and the medium i chose to do for my
thesis was actually the cpu pipeline so

325
00:27:28,720 --> 00:27:33,760
i chose this one because it's it's less
use and it's also a little harder to

326
00:27:33,760 --> 00:27:39,520
measure so I like i said before you
can't directly introspect into the cpu

327
00:27:39,520 --> 00:27:44,260
to see the state and see it changing
over time you have to wear the pipeline

328
00:27:44,260 --> 00:27:49,210
over time you have to find a clever way
of measuring the cpu without changing

329
00:27:49,210 --> 00:27:55,720
the instructions there in the cpu at any
given time so the vulnerability here is

330
00:27:55,720 --> 00:27:58,630
actually erroneous return values

331
00:27:58,630 --> 00:28:04,059
so what I do is I have two threads and i
can see that after they go through the

332
00:28:04,059 --> 00:28:08,139
pipeline after they're executed the
values i received back from these

333
00:28:08,140 --> 00:28:11,980
threads are incorrect and i'll go into
detail later on

334
00:28:12,490 --> 00:28:20,049
and for the specific attack which I'll
show i created a covert channels so one

335
00:28:20,049 --> 00:28:27,340
process is sending a message to another
and i say cross p.m. here but its cross

336
00:28:27,340 --> 00:28:30,520
DM on in the cloud so

337
00:28:33,400 --> 00:28:38,350
all right so I guess I kind of skipped
ahead but specifically when measuring

338
00:28:38,350 --> 00:28:43,030
these erroneous values that are returned
from my threads

339
00:28:43,030 --> 00:28:49,899
the reason they are erroneous is that
the pipeline actually has a lot of

340
00:28:49,900 --> 00:28:55,300
different optimization methods and when
I put in my computation through the

341
00:28:55,300 --> 00:28:58,240
pipeline to execute so do some math in
the pipeline

342
00:28:58,240 --> 00:29:01,600
it actually uses a method of
optimization called out of order

343
00:29:01,600 --> 00:29:08,350
execution which will change the way in
which my instructions are executed and

344
00:29:08,350 --> 00:29:11,350
change the return value that i receive

345
00:29:12,730 --> 00:29:18,040
so based on that i can create a receiver
which is measuring so it has these

346
00:29:18,040 --> 00:29:22,930
threads and it's looking for these
erroneous return values and based on the

347
00:29:22,930 --> 00:29:27,730
quantity of those values it receives
over a certain time frame it can

348
00:29:27,730 --> 00:29:32,650
determine bits of meeting from that the
transmitter on the other hand has to be

349
00:29:32,650 --> 00:29:37,780
able to determine mystically force the
pipeline state to either optimizer not

350
00:29:37,780 --> 00:29:42,700
so either reorder my instructions to
return incorrectly or not

351
00:29:43,750 --> 00:29:51,059
and this requires that some sort of
pre-arranged time is it

352
00:29:51,059 --> 00:29:55,830
alright so i know that i'm trying to
force the deterministic memory ordering

353
00:29:55,830 --> 00:30:00,749
so I'm trying to at runtime force a
specific way of reordering my

354
00:30:00,749 --> 00:30:02,279
instructions in the pipeline

355
00:30:02,279 --> 00:30:07,649
I'm doing this on x86 so that means that
is they usually strong memory models so

356
00:30:07,649 --> 00:30:11,039
that means usually if the pipeline is
unsure

357
00:30:11,039 --> 00:30:17,999
it will not reorder my instructions and
I can use one of these four things down

358
00:30:17,999 --> 00:30:23,850
here so i want to either tell the
pipeline to reorder or two not to

359
00:30:23,850 --> 00:30:29,699
optimize our to not and it's quite handy
but Intel provides us with four

360
00:30:29,700 --> 00:30:34,529
different types of semantics that we can
use as memory fences and we're going to

361
00:30:34,529 --> 00:30:40,559
focus on the store load which tells the
pipeline to not reorder my instructions

362
00:30:40,559 --> 00:30:45,029
if there's a story of memory and a load
to memory in that order to keep those

363
00:30:45,029 --> 00:30:52,980
two secants sequentially consistent so
specifically in assembly this

364
00:30:52,980 --> 00:30:57,360
instruction is called the infants and
it's quite expensive operation but it

365
00:30:57,360 --> 00:31:02,100
does what i want and it forces the
pipeline to in a specific time frame of

366
00:31:02,100 --> 00:31:08,428
instructions to maintain the order of of
my code to make sure that loads to

367
00:31:08,429 --> 00:31:12,600
memory are done before our stores to
memory or done before loads

368
00:31:12,600 --> 00:31:18,299
I'm now down here i mentioned that this
requires a simultaneous multi-threading

369
00:31:18,299 --> 00:31:19,649
to be turned on

370
00:31:19,649 --> 00:31:24,928
that's not a problem usually just
because that's the default for all

371
00:31:24,929 --> 00:31:32,309
modern computers if if not most but this
just means that two processes running

372
00:31:32,309 --> 00:31:37,799
can share the pipeline at one time so
the the pipeline will execute a few

373
00:31:37,799 --> 00:31:40,980
instructions from one thread execute a
few from another and so on

374
00:31:41,580 --> 00:31:48,210
so this is what a diagram of what it
looks like in the pipeline so you have

375
00:31:48,210 --> 00:31:54,269
some random instructions and it's
storing and loading from memory to the

376
00:31:54,269 --> 00:31:57,450
same spot memory so value X and memory

377
00:31:58,269 --> 00:32:02,679
and the infant was just going to keep
those two separate it's going to force

378
00:32:02,679 --> 00:32:10,599
store to happen for the load right and
this is the page from the Intel manual

379
00:32:10,599 --> 00:32:17,739
detailing how this is possible so saying
that without memory fences your

380
00:32:17,739 --> 00:32:23,769
instructions can be reordered and they
even show this case down here where you

381
00:32:23,769 --> 00:32:27,759
have two processes or two threads and
their move

382
00:32:27,759 --> 00:32:32,559
they're storing and loading to the same
spots in memory so X X Y and Y

383
00:32:33,669 --> 00:32:39,099
however the processor doesn't notice
that the stores to memory loads which

384
00:32:39,099 --> 00:32:42,339
even though they're happening to the
same spot in memory are actually

385
00:32:42,339 --> 00:32:45,729
happening in two different threads so it
treats them as if they're separate spots

386
00:32:45,729 --> 00:32:54,009
and it can actually reorder them such
that in this example r1 r2 could be 0 so

387
00:32:54,009 --> 00:32:59,739
the loads from memory will happen before
any stored in memory and this is what it

388
00:32:59,739 --> 00:33:08,769
looks like so as a simple receiving
mechanism i create two threads and I

389
00:33:08,769 --> 00:33:12,759
basically use the same code that Intel
provided learned in their example

390
00:33:12,759 --> 00:33:16,869
so if you run this multiple times you
realize that sync'd happens occasionally

391
00:33:16,869 --> 00:33:21,339
so this is when your two threads are
running perfectly in time with each

392
00:33:21,339 --> 00:33:22,119
other

393
00:33:22,119 --> 00:33:29,049
the stores happen as expected before the
loads and you get r1 and r2 equal one in

394
00:33:29,049 --> 00:33:33,519
the async example this is majority of
cases that you see even if you're

395
00:33:33,519 --> 00:33:39,969
running threads and in java or different
programs the stores and loads happen at

396
00:33:39,969 --> 00:33:44,320
different times but they don't really
get reordered

397
00:33:44,320 --> 00:33:49,208
so you just have one thread and moving
faster than the other and you get r 1

398
00:33:49,209 --> 00:33:52,089
equals 0 or r 2 equals 0 and vice versa

399
00:33:52,089 --> 00:33:57,039
but the out-of-order execution case and
this is what was being discussed an

400
00:33:57,039 --> 00:34:02,589
intel manual the loads happen before the
stores and this is in the case of no

401
00:34:02,589 --> 00:34:03,999
memory fences at all

402
00:34:03,999 --> 00:34:09,409
so the pipeline feels like it can
reorder it's not instructed to

403
00:34:09,409 --> 00:34:15,799
memory fence your instructions and it so
it realtors these two loads to tap and

404
00:34:15,800 --> 00:34:19,610
first because doesn't realize that the
two threads are actually affecting each

405
00:34:19,610 --> 00:34:26,120
other in memory and this is the case
when r 1 and r 2 equals 0 so this out of

406
00:34:26,120 --> 00:34:29,659
order execution case is what we are
measuring to determine if our

407
00:34:29,659 --> 00:34:32,960
instructions got reordered in the
pipeline or not and that's going to be

408
00:34:32,960 --> 00:34:37,610
the the way in which we can receive
information from the the pipeline about

409
00:34:37,610 --> 00:34:39,500
the state of the pipeline

410
00:34:39,500 --> 00:34:45,770
so just some general information about
my setup before i go into it

411
00:34:46,280 --> 00:34:52,220
I used intel core duo zhi an
architecture with two cores i used the

412
00:34:52,219 --> 00:34:58,250
Sun hypervisors because that is the most
common scheduler out there used to be an

413
00:34:58,250 --> 00:35:04,910
Amazon Cloud and things like that and
these things i mentioned before but my

414
00:35:04,910 --> 00:35:09,350
two processes processes are running in
the same pipeline and it's a relaxed

415
00:35:09,350 --> 00:35:10,310
memory model

416
00:35:10,310 --> 00:35:18,590
alright so this is the diagram what my
setup is looking like so I have UVM's

417
00:35:18,590 --> 00:35:22,130
they're all windows and i'm running
processes and they're sharing the same

418
00:35:22,130 --> 00:35:27,410
core so they're sharing the same
pipeline and running simultaneously and

419
00:35:27,410 --> 00:35:30,740
that means that instructions from one
will actually be able to affect the

420
00:35:30,740 --> 00:35:38,779
state of the instructions from the other
thread and that's um this is what I did

421
00:35:38,780 --> 00:35:44,450
specifically in this example and we have
to vm running and processes in each to

422
00:35:44,450 --> 00:35:50,240
either a defenses to the pipeline or to
receive out of order executions from the

423
00:35:50,240 --> 00:35:57,919
pipeline right if you i want to read
more about this setup or what I did you

424
00:35:57,920 --> 00:36:04,250
go to my website there you can find all
my code as well as a paper i wrote about

425
00:36:04,250 --> 00:36:07,250
it

426
00:36:07,770 --> 00:36:11,880
and this is what happens over time if
you measure in different time intervals

427
00:36:11,880 --> 00:36:16,770
the number of out of order executions
received you actually can get a pretty

428
00:36:16,770 --> 00:36:23,190
clear signal that comes across the
pipeline so in this case out of order

429
00:36:23,190 --> 00:36:26,040
execution frequencies on the left

430
00:36:26,040 --> 00:36:32,310
I represented a zero bit as a . in time
where there's not a lot of out of order

431
00:36:32,310 --> 00:36:35,370
execution so there's lots of offenses in
the pipeline

432
00:36:35,370 --> 00:36:41,160
there's no memory reordering and then
this bit here is represented by a period

433
00:36:41,160 --> 00:36:45,420
of time where I didn't send a lot of
offenses to the pipeline and I actually

434
00:36:45,420 --> 00:36:47,850
received a lot of out of water
executions

435
00:36:47,850 --> 00:36:51,089
after running my two threads thousands
of times

436
00:36:51,690 --> 00:37:03,930
all right so I'm gonna show this short
video and this is just my Zen Center zen

437
00:37:03,930 --> 00:37:10,980
center set up with my different windows
seven bm's i'm going to go into it

438
00:37:10,980 --> 00:37:18,120
this is my demo from recon last year and
so for my receiving code

439
00:37:18,120 --> 00:37:22,710
this is the receiver measuring the
out-of-order execution from the pipeline

440
00:37:23,310 --> 00:37:28,140
so it's running different threads and I
have it calibrated such that in a given

441
00:37:28,140 --> 00:37:29,190
time frame

442
00:37:29,190 --> 00:37:35,040
if it receives not in this case I
flipped it so a lot of out of water

443
00:37:35,040 --> 00:37:40,560
executions to represent that as a zero
and you can create a different mapping

444
00:37:40,560 --> 00:37:45,270
for different number of out-of-order
execution is received but that doesn't

445
00:37:45,270 --> 00:37:49,080
matter as much as the fact that you can
determine mystically change the state of

446
00:37:49,080 --> 00:37:51,690
the pipeline's wells as well as measure
it

447
00:37:51,690 --> 00:37:56,940
alright so in this case I was just
showing that i'm canceling the noise out

448
00:37:56,940 --> 00:37:59,580
from the system so all the other
processes running

449
00:37:59,580 --> 00:38:05,069
I kind of cancel these data points out
and that just takes a lot of data

450
00:38:05,070 --> 00:38:09,870
aggregation and knowing the environment
that you're set up on

451
00:38:09,870 --> 00:38:16,049
so the receiver with the code that i
provide i also read it to a text file

452
00:38:16,050 --> 00:38:17,619
that sort of thing

453
00:38:17,619 --> 00:38:23,980
just for it more data analysis now my
Center is the one sending the memory

454
00:38:23,980 --> 00:38:30,940
fences into the pipeline so that's in a
specific time frame pushing many offense

455
00:38:30,940 --> 00:38:36,400
instructions into the pipeline to force
that state in that in the pipeline

456
00:38:36,400 --> 00:38:44,619
medium so to force it to not optimized
and not reorder my instructions and

457
00:38:44,619 --> 00:38:48,999
actually I do have to use a lot of
offenses but you can see that my 2 bits

458
00:38:48,999 --> 00:38:50,589
got got red

459
00:38:50,589 --> 00:38:56,950
all right to the video ended before I
could stop it but in that scenario I was

460
00:38:56,950 --> 00:39:00,339
just waiting for a signal to then launch
an attack

461
00:39:00,339 --> 00:39:05,470
so you kind of saw the end of the Blues
blue screen there but the idea was that

462
00:39:05,470 --> 00:39:11,259
it was waiting for a signal and then it
was waiting for a signal then to to

463
00:39:11,259 --> 00:39:14,259
launch something

464
00:39:17,540 --> 00:39:21,770
so I'm from the specific types ID
channel there's a couple benefits when I

465
00:39:21,770 --> 00:39:24,920
compared it to side channels over other
hardware mediums

466
00:39:25,580 --> 00:39:31,400
so from a hypervisor point of view it's
actually a little easier to to see

467
00:39:31,400 --> 00:39:36,020
patterns of behavior of processes
queering different parts of memory

468
00:39:37,220 --> 00:39:41,689
so using this method of recording the
pipeline that might be a little harder

469
00:39:41,690 --> 00:39:45,770
for a hypervisor to detect that
anomalous behavior

470
00:39:45,770 --> 00:39:51,350
another interesting part about this is
eavesdropping mutilated the channel

471
00:39:51,350 --> 00:39:56,779
so if I had another process on in the
cloud or something at the kernel level

472
00:39:56,780 --> 00:40:01,760
listening to other processes reading the
pipeline are trying to listen for

473
00:40:01,760 --> 00:40:06,980
periods of time where there is a lot of
instructions of the same type

474
00:40:06,980 --> 00:40:12,590
so maybe of the influence I'm being
pushed into the pipeline eavesdropping

475
00:40:12,590 --> 00:40:16,040
chain would change the the noise
cancelling algorithm so it would change

476
00:40:16,040 --> 00:40:21,529
the state of the pipeline enough where
my receiver would not be able to receive

477
00:40:21,530 --> 00:40:27,650
the same channel and be able to detect
that someone else is listening and all

478
00:40:27,650 --> 00:40:32,450
these other things are specific to to
the some the side channel but it wasn't

479
00:40:32,450 --> 00:40:34,339
affected as much by other system noise

480
00:40:34,340 --> 00:40:38,930
so a lot of processes running on the
same cpu like in the cloud or something

481
00:40:38,930 --> 00:40:45,230
that definitely changes the cash more
the other parts of memory more because

482
00:40:45,230 --> 00:40:50,390
there's more processes can contending
for this same resources but this channel

483
00:40:50,390 --> 00:40:54,890
was was interesting in the fact that a
lot of other processes running on the

484
00:40:54,890 --> 00:40:55,850
system

485
00:40:55,850 --> 00:41:00,140
I didn't necessarily change the way i
read my red the pipeline

486
00:41:00,140 --> 00:41:08,900
alright so what are some defenses you
can use for side-channel attacks in the

487
00:41:08,900 --> 00:41:15,680
cloud or against any sort of hardware
side channel so isolating a vm or

488
00:41:15,680 --> 00:41:17,190
isolating processes

489
00:41:17,190 --> 00:41:22,440
is all honestly the the most assured way
of making sure that your process is

490
00:41:22,440 --> 00:41:28,589
protected but the problem with that is
without hyper-threading turned on or

491
00:41:28,589 --> 00:41:33,960
without sharing resources you you do
lose a lot of optimizations that are

492
00:41:33,960 --> 00:41:36,930
provided by the computer or by the cloud

493
00:41:36,930 --> 00:41:44,250
alright so I've read a lot of papers
about hyper visor anomaly detection so

494
00:41:44,250 --> 00:41:48,540
this is when the hypervisor is is kind
of cute into listening to different

495
00:41:48,540 --> 00:41:53,910
resources on the system to see if one
process is using it more than others and

496
00:41:53,910 --> 00:41:58,200
this is probably where a lot of larger
cloud companies are kind of moving

497
00:41:58,200 --> 00:42:04,140
towards right so either trying to build
intelligent hypervisors which look for

498
00:42:04,140 --> 00:42:08,520
different patterns in the system to see
if they can they also can kind of

499
00:42:08,520 --> 00:42:12,390
eavesdrop on a potential channel being
being center being received

500
00:42:13,770 --> 00:42:20,099
and you know applying little machine
learning or data aggregation these

501
00:42:20,099 --> 00:42:24,780
systems can become quite powerful so in
the same way that you have networks

502
00:42:24,780 --> 00:42:28,770
which predict what should be proper
behavior on that Network you could

503
00:42:28,770 --> 00:42:33,540
perhaps have a hypervisor which could
predict what proper behavior should be

504
00:42:33,540 --> 00:42:36,630
seen at the CP or at the cash level

505
00:42:36,630 --> 00:42:41,880
all right and there's also defenses you
can use the software level so let's say

506
00:42:41,880 --> 00:42:47,310
you want to deploy or your vm or your
processes in the cloud and you know that

507
00:42:47,310 --> 00:42:54,328
you maybe can't trust the cloud or trust
your other neighbors in the cloud so

508
00:42:54,329 --> 00:42:58,740
what you could do is add noise to your
system so you could add noise to your

509
00:42:58,740 --> 00:43:07,950
processes to add different patterns that
it uses to interact with the system and

510
00:43:07,950 --> 00:43:13,919
also an interesting one which is used
mostly by cryptographic libraries now is

511
00:43:13,920 --> 00:43:17,670
trying to create everything with
constant time loops so a lot of side

512
00:43:17,670 --> 00:43:22,380
channels are built especially encrypt
our built on the fact that it takes

513
00:43:22,380 --> 00:43:27,359
different amounts of time to execute
different mathematical instructions for

514
00:43:27,359 --> 00:43:29,580
different lengths bets are different
value

515
00:43:29,580 --> 00:43:35,549
different values of it for variables and
things so constant time loops in

516
00:43:35,550 --> 00:43:41,040
constant time algorithms are very
powerful especially in hardware-based

517
00:43:41,040 --> 00:43:47,880
side channels so kind of talk a little
bit about the future already but I think

518
00:43:47,880 --> 00:43:51,240
we're definitely going to see more
resource sharing

519
00:43:51,240 --> 00:43:55,709
so there's going to be more and more
dynamic optimization is being used to

520
00:43:55,710 --> 00:44:01,710
either scale large systems in the cloud
or even on your own cpu so

521
00:44:01,710 --> 00:44:07,980
virtualization is gonna be very powerful
this field but again that leaves large

522
00:44:07,980 --> 00:44:11,910
gaps and for side-channel attacks to to
take place

523
00:44:11,910 --> 00:44:18,089
also a mall where is an interesting area
where this could go into they have seen

524
00:44:18,090 --> 00:44:23,040
malware which uses network packet side
channels for instance to changes

525
00:44:23,040 --> 00:44:26,970
behavior or to determine if it's in a
safe or unsafe environment

526
00:44:27,480 --> 00:44:32,490
I better finish the rest but there's a
few things to consider

527
00:44:33,180 --> 00:44:38,819
so outside of the realm of side channels
in the cloud itself hypervisors are

528
00:44:38,820 --> 00:44:44,130
still there still very vulnerable right
so we saw a lot of great talks the past

529
00:44:44,130 --> 00:44:47,760
few days on hypervisors and ends and
things like that

530
00:44:48,420 --> 00:44:53,400
I reference this one I thought that
infiltrate this year but hypervisors

531
00:44:53,400 --> 00:44:57,630
were kind of in a dark for a long time
they they got away with not doing a lot

532
00:44:57,630 --> 00:45:03,120
for security and so until recently they
are pretty vulnerable and open

533
00:45:03,690 --> 00:45:06,900
oh but no one really looked at them so
those things have to be hardened as well

534
00:45:06,900 --> 00:45:10,650
if more of our processes get deployed in
the cloud

535
00:45:10,650 --> 00:45:17,100
alright so in conclusion i hope what I
mentioned today helps to come away with

536
00:45:17,100 --> 00:45:22,980
a better understanding of specifically
hardware-based side channels as well as

537
00:45:22,980 --> 00:45:29,100
the primitives needed to create them so
build your own side channel kind of

538
00:45:29,100 --> 00:45:29,730
thing

539
00:45:29,730 --> 00:45:35,460
what mediums are available in the cloud
so what attack vectors could potentially

540
00:45:35,460 --> 00:45:37,090
be vulnerable

541
00:45:37,090 --> 00:45:42,550
for your processes in the cloud or areas
of research look into and hopefully give

542
00:45:42,550 --> 00:45:46,840
you some ideas of possible attacks or
research vectors to go to in the future

543
00:45:46,840 --> 00:45:53,410
so i'd like to acknowledge Jamie
blackthorn my research advisor as well

544
00:45:53,410 --> 00:45:56,470
as our PA second trailer that's where I
work

545
00:45:57,040 --> 00:46:01,750
so there's any questions I can take them
now or you can reach out to me at any of

546
00:46:01,750 --> 00:46:03,370
these links

547
00:46:03,370 --> 00:46:07,210
thank you any question

548
00:46:13,460 --> 00:46:23,510
Here I am how easy do you think it would
be to industrialize this sort of thing

549
00:46:23,510 --> 00:46:27,530
if you're you know some large actor with
time and money and you wanted to go

550
00:46:27,530 --> 00:46:33,140
after the you know ASL keys of the
llamas or someone like this and to just

551
00:46:33,140 --> 00:46:36,650
spend up the ends and the clothes and
hope you get lucky man how easy was that

552
00:46:36,650 --> 00:46:41,210
there's a paper about that actually you
know there's one

553
00:46:41,210 --> 00:46:46,160
it's hard to determine colocation the
cloud that's actually most of the time .

554
00:46:46,160 --> 00:46:50,480
the thing that's protecting vulnerable
pieces of software in the cloud is the

555
00:46:50,480 --> 00:46:54,410
fact that attackers have a hard time
determining colocation because there's

556
00:46:54,410 --> 00:47:00,500
thousands of amazon boxes and the most
common method of getting around that is

557
00:47:00,500 --> 00:47:05,720
just spending tons of money and spinning
up all these bm's taking readings from

558
00:47:05,720 --> 00:47:12,020
the system to get a signature of that
cash for that environment to see if

559
00:47:12,020 --> 00:47:14,330
that's something you're looking for or
not

560
00:47:14,330 --> 00:47:20,660
so people have done that pressure it is
something like Intel SGX something that

561
00:47:20,660 --> 00:47:25,879
you can use to protect against us or is
that the wrong sort of ballpark

562
00:47:25,880 --> 00:47:30,470
no I think that would work that the
problem is right now at least is a lot

563
00:47:30,470 --> 00:47:35,419
of these larger providers of of cloud
services they do have other problems

564
00:47:35,420 --> 00:47:38,960
they they do want to maintain
optimization for their customers and

565
00:47:38,960 --> 00:47:44,930
things like that so that would certainly
be a great solution for maybe like a

566
00:47:44,930 --> 00:47:46,250
personal computer

567
00:47:46,250 --> 00:47:52,550
did you know that hearing side-channel
attacks one person i know a lot of she

568
00:47:52,550 --> 00:47:58,520
does a lot of malware research and a
piece of malware may be looking for a

569
00:47:58,520 --> 00:48:06,050
specific environment environment ID and
you have to have a very specific set up

570
00:48:06,050 --> 00:48:10,730
to make sure that your vm actually has
the same hardware virtualization that

571
00:48:10,730 --> 00:48:15,589
your main operating system does so that
might be applicable in that realm

572
00:48:16,099 --> 00:48:18,289
thank you

573
00:48:18,289 --> 00:48:25,039
any other questions on the floor no all
right well thank you very much to fear

574
00:48:29,450 --> 00:48:30,828
ok

