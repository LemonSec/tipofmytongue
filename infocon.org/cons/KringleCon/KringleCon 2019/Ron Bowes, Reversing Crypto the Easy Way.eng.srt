1
00:00:00,500 --> 00:00:06,690
hello and welcome to my good Kringle can

2
00:00:02,879 --> 00:00:08,970
talk reversing crypt of the easy way my

3
00:00:06,690 --> 00:00:12,120
name is Ron Bo's otherwise known online

4
00:00:08,970 --> 00:00:14,099
as yoga xa6 you can find me on Twitter

5
00:00:12,120 --> 00:00:16,770
on github on all kinds of platforms with

6
00:00:14,099 --> 00:00:18,539
that handled I am one of the holiday

7
00:00:16,770 --> 00:00:21,539
hack challenge challenge and

8
00:00:18,539 --> 00:00:24,180
infrastructure development doing

9
00:00:21,539 --> 00:00:27,420
hollyhock showing stuff and it's gonna

10
00:00:24,180 --> 00:00:29,099
be our biggest and best ever last year I

11
00:00:27,420 --> 00:00:31,380
wrote a blog on a sin spin test blog

12
00:00:29,099 --> 00:00:33,660
kind of outlining the techniques need

13
00:00:31,380 --> 00:00:37,019
for one of my challenges this year I

14
00:00:33,660 --> 00:00:39,779
decided to a video instead I've done

15
00:00:37,020 --> 00:00:41,790
left of toxic conferences and this is my

16
00:00:39,780 --> 00:00:44,070
first time ever growing a video so I

17
00:00:41,790 --> 00:00:45,750
feel like I really need a feedback of an

18
00:00:44,070 --> 00:00:49,469
audience so I've said a little left

19
00:00:45,750 --> 00:00:55,469
track here that will play laughs in tune

20
00:00:49,469 --> 00:00:56,480
with how big my jokes are so okay never

21
00:00:55,469 --> 00:01:01,440
mind

22
00:00:56,480 --> 00:01:03,870
okay so if you want to read my blog go

23
00:01:01,440 --> 00:01:06,330
that's called Sakuya urgh my blog talks

24
00:01:03,870 --> 00:01:07,560
about crypto talks about reversing talks

25
00:01:06,330 --> 00:01:09,810
about all kinds of the same stuff ARCA

26
00:01:07,560 --> 00:01:11,400
talked about here and just like here

27
00:01:09,810 --> 00:01:17,189
we're gonna try make it very

28
00:01:11,400 --> 00:01:19,619
approachable not just math so to choose

29
00:01:17,189 --> 00:01:21,750
is talk this will be an introduction to

30
00:01:19,619 --> 00:01:23,759
reverse engineering cryptographic code

31
00:01:21,750 --> 00:01:26,460
that's a mouthful and it sounds really

32
00:01:23,759 --> 00:01:28,799
scary but don't run away it's not as bad

33
00:01:26,460 --> 00:01:30,509
as it sounds this is targeted towards

34
00:01:28,799 --> 00:01:33,180
anybody with a working knowledge of

35
00:01:30,509 --> 00:01:37,439
pentesting of programming stuff like

36
00:01:33,180 --> 00:01:38,880
that also this talk might help you with

37
00:01:37,439 --> 00:01:43,079
one of this year's hollyhocks challenge

38
00:01:38,880 --> 00:01:44,820
challenges just maybe so what did I

39
00:01:43,079 --> 00:01:47,279
write this talk and whatever it takes

40
00:01:44,820 --> 00:01:49,229
we'll see a challenge well I've been

41
00:01:47,280 --> 00:01:51,240
doing reverses I've been doing pen

42
00:01:49,229 --> 00:01:54,320
testing for years now two years at

43
00:01:51,240 --> 00:01:57,719
counter hack and a lot longer elsewhere

44
00:01:54,320 --> 00:02:00,119
well doing pen tests my focus is often

45
00:01:57,719 --> 00:02:02,009
on applications and equally web

46
00:02:00,119 --> 00:02:05,640
applications desktop stead of server

47
00:02:02,009 --> 00:02:08,038
stuff whatever that frequently means I

48
00:02:05,640 --> 00:02:09,989
run into unknowing programs that do

49
00:02:08,038 --> 00:02:12,920
unknown things they have to reverse

50
00:02:09,989 --> 00:02:15,590
engineer and they're very often with

51
00:02:12,920 --> 00:02:17,119
good findings from that fair thing so I

52
00:02:15,590 --> 00:02:19,520
really want to write a talk that would

53
00:02:17,120 --> 00:02:22,370
talk about some of the easy ways to do

54
00:02:19,520 --> 00:02:24,160
this ways that aren't gonna be days and

55
00:02:22,370 --> 00:02:27,410
days of reversing some cryptographic

56
00:02:24,160 --> 00:02:29,690
mathematical thing for example like

57
00:02:27,410 --> 00:02:32,660
let's say an application outputs a

58
00:02:29,690 --> 00:02:35,870
128-bit ash you could spend hours

59
00:02:32,660 --> 00:02:37,730
looking at the assembly a machine code

60
00:02:35,870 --> 00:02:39,290
that generates the hash and he

61
00:02:37,730 --> 00:02:42,260
eventually figure out that it's md5

62
00:02:39,290 --> 00:02:45,260
based on the algorithms or you can just

63
00:02:42,260 --> 00:02:48,019
think 128 bits that's the side of md5

64
00:02:45,260 --> 00:02:50,450
and just test it and frequently that

65
00:02:48,020 --> 00:02:51,800
just works so I want talk about places

66
00:02:50,450 --> 00:02:54,829
where that will work pretty much

67
00:02:51,800 --> 00:02:56,660
transparently but before I talk about

68
00:02:54,830 --> 00:02:59,480
the actual crypto let's talk about the

69
00:02:56,660 --> 00:03:01,940
tools we're going to use so for the

70
00:02:59,480 --> 00:03:04,070
reverse engineering side I use Ida the

71
00:03:01,940 --> 00:03:05,540
interactive disassembler we'll be using

72
00:03:04,070 --> 00:03:06,590
that for all of our examples because

73
00:03:05,540 --> 00:03:08,810
it's what I know best

74
00:03:06,590 --> 00:03:10,340
it's what I've always used the link here

75
00:03:08,810 --> 00:03:11,739
and I will be polishing these slides

76
00:03:10,340 --> 00:03:13,910
afterwards so I'll send you the link

77
00:03:11,739 --> 00:03:16,280
this link will get you the free version

78
00:03:13,910 --> 00:03:17,570
of idea which is it's a date it's not

79
00:03:16,280 --> 00:03:19,400
doesn't have all the support you need

80
00:03:17,570 --> 00:03:20,859
but has everything you need for the for

81
00:03:19,400 --> 00:03:23,180
this presentation I need to follow along

82
00:03:20,860 --> 00:03:25,250
there's also a completely free tool

83
00:03:23,180 --> 00:03:27,920
called get your or guide ray from the

84
00:03:25,250 --> 00:03:29,930
NSA is link Baird I've heard great

85
00:03:27,920 --> 00:03:33,768
things I've never used it so I can't

86
00:03:29,930 --> 00:03:36,530
judge it myself it's pretty good on the

87
00:03:33,769 --> 00:03:38,959
coding side I'll be using two tools for

88
00:03:36,530 --> 00:03:42,170
the examples microsoft visuals videos

89
00:03:38,959 --> 00:03:45,019
2008 that's right you heard right 2008

90
00:03:42,170 --> 00:03:47,200
back ten years ago I was I conference

91
00:03:45,019 --> 00:03:50,870
from Microsoft I think I free coffee and

92
00:03:47,200 --> 00:03:53,510
freeze free so I still use it I'll also

93
00:03:50,870 --> 00:03:57,799
be using Ruby 2.4 with IRB which is the

94
00:03:53,510 --> 00:04:01,940
interactive Ruby it looks like this I RP

95
00:03:57,799 --> 00:04:04,670
and you can write commands so it's just

96
00:04:01,940 --> 00:04:06,680
a simple Ruby yeah I think I'm

97
00:04:04,670 --> 00:04:07,700
specifically using Ruby tooling for it

98
00:04:06,680 --> 00:04:10,730
shouldn't matter what version you use

99
00:04:07,700 --> 00:04:13,730
any version pretty much neighbors with

100
00:04:10,730 --> 00:04:16,909
all blotchy work there's a link here to

101
00:04:13,730 --> 00:04:18,469
the cream upon slides this link loves to

102
00:04:16,910 --> 00:04:21,590
be at the end so don't worry about

103
00:04:18,470 --> 00:04:25,280
having to write down or pause the video

104
00:04:21,589 --> 00:04:27,080
I guess so let's throw a journey into

105
00:04:25,280 --> 00:04:31,619
crypto talking about keys

106
00:04:27,080 --> 00:04:33,630
aka where things start to go wrong so

107
00:04:31,620 --> 00:04:35,130
we're going to focus for this talk on

108
00:04:33,630 --> 00:04:36,870
symmetric keys because there's some

109
00:04:35,130 --> 00:04:40,110
flutter and because of more common at

110
00:04:36,870 --> 00:04:41,730
least in my experience public key crypto

111
00:04:40,110 --> 00:04:43,770
has its own issues but they didn't be

112
00:04:41,730 --> 00:04:45,840
more complex and it didn't to be more

113
00:04:43,770 --> 00:04:47,880
difficult to understand so I want to

114
00:04:45,840 --> 00:04:50,780
focus just on symmetric keys where the

115
00:04:47,880 --> 00:04:53,010
encryption and decryption are the same

116
00:04:50,780 --> 00:04:54,989
the biggest thing that we're going to

117
00:04:53,010 --> 00:04:57,390
talk about is the last line of the slide

118
00:04:54,990 --> 00:05:00,210
which is Keys must remain confidential

119
00:04:57,390 --> 00:05:02,039
and to be confidential they also have to

120
00:05:00,210 --> 00:05:03,690
be unpredictable because if you can

121
00:05:02,040 --> 00:05:06,330
predict it then it's not confidential

122
00:05:03,690 --> 00:05:09,690
anymore so we will see how keys are

123
00:05:06,330 --> 00:05:10,740
misused in various ways and the next

124
00:05:09,690 --> 00:05:12,750
section will be I'd rather number

125
00:05:10,740 --> 00:05:16,170
generation or key to generate in bad

126
00:05:12,750 --> 00:05:18,660
ways so first of all how do you

127
00:05:16,170 --> 00:05:21,420
recognize a key you're looking at an

128
00:05:18,660 --> 00:05:23,460
application either in you see Python

129
00:05:21,420 --> 00:05:28,140
Ruby assembly rust whatever you want and

130
00:05:23,460 --> 00:05:31,590
you see code what what's it look like

131
00:05:28,140 --> 00:05:34,530
so we will just see an example in about

132
00:05:31,590 --> 00:05:36,330
two slides but normally a key is a fixed

133
00:05:34,530 --> 00:05:38,460
length depending on the algorithm being

134
00:05:36,330 --> 00:05:41,609
used and we'll talk about algorithms you

135
00:05:38,460 --> 00:05:44,520
know two sections from now if it's seven

136
00:05:41,610 --> 00:05:47,040
or eight bytes it's probably des des

137
00:05:44,520 --> 00:05:49,409
uses seven bytes for 56 bits for a key

138
00:05:47,040 --> 00:05:52,350
and then one byte or eight bits as

139
00:05:49,410 --> 00:05:53,550
appeared even so you might see seven or

140
00:05:52,350 --> 00:05:58,230
eight depending on how it's being used

141
00:05:53,550 --> 00:06:00,180
you are going to see 16 24 or 32 byte

142
00:05:58,230 --> 00:06:02,970
keys from AES and we'll talk about

143
00:06:00,180 --> 00:06:04,980
housing these two ciphers later but the

144
00:06:02,970 --> 00:06:08,160
majority of block ciphers you see will

145
00:06:04,980 --> 00:06:11,880
be des or EDS will look up with that

146
00:06:08,160 --> 00:06:12,600
later keys will look random and should

147
00:06:11,880 --> 00:06:13,980
be random

148
00:06:12,600 --> 00:06:15,960
because it's not good enough to just

149
00:06:13,980 --> 00:06:19,080
look random we will talk about the

150
00:06:15,960 --> 00:06:21,659
preference as well and third the key

151
00:06:19,080 --> 00:06:24,210
will be shared somehow meaning that when

152
00:06:21,660 --> 00:06:26,400
you encrypt a file our key is hopefully

153
00:06:24,210 --> 00:06:30,320
generated and when you decrypt the file

154
00:06:26,400 --> 00:06:33,599
it is used which means that he must be

155
00:06:30,320 --> 00:06:36,480
hard coded which is bedded stored

156
00:06:33,600 --> 00:06:40,800
somewhere which could be bad transmitted

157
00:06:36,480 --> 00:06:42,990
pre-med s crude event

158
00:06:40,800 --> 00:06:46,230
somehow the key must be shared very

159
00:06:42,990 --> 00:06:49,130
typical is just a pasture file or a

160
00:06:46,230 --> 00:06:51,060
password derived key where both people

161
00:06:49,130 --> 00:06:53,010
transmit pass through to each other and

162
00:06:51,060 --> 00:06:56,370
then both use a password such as encrypt

163
00:06:53,010 --> 00:06:58,950
a zip file but how do you generate keys

164
00:06:56,370 --> 00:07:01,560
keys should come from secure random

165
00:06:58,950 --> 00:07:04,770
functions such as Krypton random on

166
00:07:01,560 --> 00:07:06,480
Windows or get random on Linux less time

167
00:07:04,770 --> 00:07:08,849
in those two functions a little bit I'll

168
00:07:06,480 --> 00:07:10,820
bring up my Windows machine here we're

169
00:07:08,850 --> 00:07:13,410
going to search for Christian random

170
00:07:10,820 --> 00:07:15,240
also doodlee function name is something

171
00:07:13,410 --> 00:07:16,170
that I want to do an awful lot

172
00:07:15,240 --> 00:07:18,870
well-invested

173
00:07:16,170 --> 00:07:20,910
or well give you applications so if you

174
00:07:18,870 --> 00:07:23,250
search this first of all it's deprecated

175
00:07:20,910 --> 00:07:25,200
so there's that but what you're gonna

176
00:07:23,250 --> 00:07:27,030
want to look for is the Crypt you read

177
00:07:25,200 --> 00:07:29,909
the function fills a buffer with

178
00:07:27,030 --> 00:07:32,390
cryptographically random bytes cryptic

179
00:07:29,910 --> 00:07:36,030
every random is what you want to see I

180
00:07:32,390 --> 00:07:37,650
will switch to my Linux VM and we'll do

181
00:07:36,030 --> 00:07:41,450
the same thing we'll look at a gender

182
00:07:37,650 --> 00:07:44,250
and 'm gender

183
00:07:41,450 --> 00:07:48,150
so get random obtains a series of random

184
00:07:44,250 --> 00:07:50,850
bytes if you read through this you will

185
00:07:48,150 --> 00:07:53,159
eventually see somewhere in here these

186
00:07:50,850 --> 00:07:56,100
bytes can be used for cryptographic

187
00:07:53,160 --> 00:07:59,220
purposes that's we want to see we don't

188
00:07:56,100 --> 00:08:01,910
want to see not grab the keys in

189
00:07:59,220 --> 00:08:04,980
contrast if we just look for Rend

190
00:08:01,910 --> 00:08:06,480
it's a suitor a number generator and

191
00:08:04,980 --> 00:08:12,110
what you're going to see somewhere in

192
00:08:06,480 --> 00:08:14,070
here is that this is insecure and I

193
00:08:12,110 --> 00:08:16,770
don't want to spend all the time reading

194
00:08:14,070 --> 00:08:18,810
a man page but you will see this

195
00:08:16,770 --> 00:08:21,810
function will be a weak random a

196
00:08:18,810 --> 00:08:24,870
generator that means don't use this for

197
00:08:21,810 --> 00:08:27,860
crypto if we scroll down we'll actually

198
00:08:24,870 --> 00:08:31,830
see the algorithm this uses which is

199
00:08:27,860 --> 00:08:37,229
this and we will talk more about the

200
00:08:31,830 --> 00:08:40,020
algorithms later so Keith as I said

201
00:08:37,229 --> 00:08:44,070
should be generated from secure random

202
00:08:40,020 --> 00:08:47,250
functions keys are often generated from

203
00:08:44,070 --> 00:08:49,589
non secure random functions such as ran

204
00:08:47,250 --> 00:08:50,180
like I said time gate account stuff like

205
00:08:49,589 --> 00:08:52,860
that

206
00:08:50,180 --> 00:08:53,279
the example on the slide is from some

207
00:08:52,860 --> 00:08:55,949
stuff

208
00:08:53,279 --> 00:08:57,779
I actually had to work with and you can

209
00:08:55,949 --> 00:09:00,180
see it's using math dot random which is

210
00:08:57,779 --> 00:09:02,639
JavaScript in order to calculate at

211
00:09:00,180 --> 00:09:07,498
random a random stream that's not good

212
00:09:02,639 --> 00:09:09,060
that can you predict it so when you're

213
00:09:07,499 --> 00:09:11,370
trying to evaluate how keys are being

214
00:09:09,060 --> 00:09:13,859
used look for these easy to find flaws

215
00:09:11,370 --> 00:09:14,550
or the key to pro coded we're gonna take

216
00:09:13,860 --> 00:09:17,970
them about that

217
00:09:14,550 --> 00:09:19,949
are they securely generated rules will

218
00:09:17,970 --> 00:09:21,990
say know about that and are they shared

219
00:09:19,949 --> 00:09:24,889
securely we're not going to have a demo

220
00:09:21,990 --> 00:09:27,839
but that's something to keep an eye on

221
00:09:24,889 --> 00:09:30,569
so let's do two demos back-to-back one

222
00:09:27,839 --> 00:09:33,660
on hard coded keys and one on a bad key

223
00:09:30,569 --> 00:09:37,889
generator please them also be on Windows

224
00:09:33,660 --> 00:09:39,569
we'll have some on both OS s so if a

225
00:09:37,889 --> 00:09:42,990
hard cookie let's stop we're looking at

226
00:09:39,569 --> 00:09:44,550
this C version of this code so this is a

227
00:09:42,990 --> 00:09:46,319
very simple T function it doesn't

228
00:09:44,550 --> 00:09:48,719
actually do crypto because I started on

229
00:09:46,319 --> 00:09:51,209
scoping this demo but we're gonna see is

230
00:09:48,720 --> 00:09:53,699
a main function that just calls do

231
00:09:51,209 --> 00:09:55,739
equipped with a static string this is a

232
00:09:53,699 --> 00:09:59,069
data string nothing too fancy

233
00:09:55,740 --> 00:10:02,189
the dude encrypt function calls do a es

234
00:09:59,069 --> 00:10:04,620
it passes a key parameter and the text

235
00:10:02,189 --> 00:10:07,889
parameter the text parameter comes from

236
00:10:04,620 --> 00:10:11,459
main the key parameter comes from a

237
00:10:07,889 --> 00:10:13,769
hard-coded key that's bad and forwards

238
00:10:11,459 --> 00:10:16,349
work this is like he looks like f 0 a 9

239
00:10:13,769 --> 00:10:18,660
a a the black X is just you know that's

240
00:10:16,350 --> 00:10:21,649
hex character if you count these bytes

241
00:10:18,660 --> 00:10:24,089
for each byte is / x AF 0 for example

242
00:10:21,649 --> 00:10:26,699
you will find that there are 16 bytes in

243
00:10:24,089 --> 00:10:29,550
the string and 16 bytes is how you buy

244
00:10:26,699 --> 00:10:32,490
store at AES so if you ever see a 16

245
00:10:29,550 --> 00:10:34,949
byte key you can take a pretty educated

246
00:10:32,490 --> 00:10:36,629
guess that you're looking at 80s it also

247
00:10:34,949 --> 00:10:40,019
helps me see if I'm gonna call it do AES

248
00:10:36,629 --> 00:10:42,420
but function names can lie

249
00:10:40,019 --> 00:10:44,759
field bound that code for a Starcraft

250
00:10:42,420 --> 00:10:46,079
used to have a sha-1 function that

251
00:10:44,759 --> 00:10:48,509
didn't actually do sha-1

252
00:10:46,079 --> 00:10:50,849
it tried to but there was a book that's

253
00:10:48,509 --> 00:10:51,990
a whole other story though so obviously

254
00:10:50,850 --> 00:10:54,029
a point does nothing so I'm not gonna

255
00:10:51,990 --> 00:10:57,179
run it but we are going to look at it in

256
00:10:54,029 --> 00:10:58,800
Ida so if you would have open this file

257
00:10:57,179 --> 00:11:00,899
are there and just click next next next

258
00:10:58,800 --> 00:11:02,519
throw dialogues you will see something

259
00:11:00,899 --> 00:11:05,620
like this I might have scrolled but I

260
00:11:02,519 --> 00:11:07,840
haven't changed anything on the left

261
00:11:05,620 --> 00:11:11,620
we see a main function so let's start

262
00:11:07,840 --> 00:11:14,050
there this will have weird code push EP

263
00:11:11,620 --> 00:11:15,730
movie EP all the stuff we're getting the

264
00:11:14,050 --> 00:11:17,579
world list you don't really know how

265
00:11:15,730 --> 00:11:19,480
this works for this example and when I

266
00:11:17,580 --> 00:11:22,210
overwhelm you with talking about how

267
00:11:19,480 --> 00:11:24,040
like coal stacks working low stuff what

268
00:11:22,210 --> 00:11:26,740
we're going to focus on is where we see

269
00:11:24,040 --> 00:11:29,949
English words primarily so for example

270
00:11:26,740 --> 00:11:32,320
call do encrypt that sounds like it

271
00:11:29,950 --> 00:11:34,029
calls us might repeal to encrypt and as

272
00:11:32,320 --> 00:11:36,250
we know that the parameter to do encrypt

273
00:11:34,029 --> 00:11:38,860
is a static text string which is a

274
00:11:36,250 --> 00:11:42,820
previous line push text this is a death

275
00:11:38,860 --> 00:11:45,820
string so from this you can conclude and

276
00:11:42,820 --> 00:11:48,550
that can confirm that parameters are

277
00:11:45,820 --> 00:11:49,779
pushed and that functions are called the

278
00:11:48,550 --> 00:11:52,270
only other thing to know is that

279
00:11:49,779 --> 00:11:55,120
functions return values by putting them

280
00:11:52,270 --> 00:11:57,939
in a in a ax but I don't even think we

281
00:11:55,120 --> 00:11:59,950
know that for these examples so let's

282
00:11:57,940 --> 00:12:00,690
just double click on do encrypt and see

283
00:11:59,950 --> 00:12:05,800
what that does

284
00:12:00,690 --> 00:12:08,980
so immediately we see do a es so now we

285
00:12:05,800 --> 00:12:11,439
know that it does a es and passes two

286
00:12:08,980 --> 00:12:14,170
parameters the first parameter which is

287
00:12:11,440 --> 00:12:17,860
a closest one to the call is a key the

288
00:12:14,170 --> 00:12:20,110
second parameter is e ax if you look at

289
00:12:17,860 --> 00:12:24,160
it comes from comes from text and text

290
00:12:20,110 --> 00:12:25,780
is a parameter so it calls do a es with

291
00:12:24,160 --> 00:12:29,770
the parameter which is our string and

292
00:12:25,780 --> 00:12:31,600
with a variable called key now what

293
00:12:29,770 --> 00:12:33,699
you're gonna wanna know is what where is

294
00:12:31,600 --> 00:12:36,070
this key come from and often that can be

295
00:12:33,700 --> 00:12:39,730
tricky to find in our case we click on

296
00:12:36,070 --> 00:12:42,240
it and they look there's the key this is

297
00:12:39,730 --> 00:12:44,980
where the left track would play you know

298
00:12:42,240 --> 00:12:46,420
so if we if we were doing this without

299
00:12:44,980 --> 00:12:51,220
seeing the code first we would see the

300
00:12:46,420 --> 00:12:52,390
key is 1 2 3 4 5 6 or 16 bytes again 16

301
00:12:51,220 --> 00:12:56,650
boys means you're probably looking at a

302
00:12:52,390 --> 00:12:59,650
es 128 and that's pretty much all there

303
00:12:56,650 --> 00:13:02,350
is to this example the next things that

304
00:12:59,650 --> 00:13:04,930
we're going to look at is bad key

305
00:13:02,350 --> 00:13:06,279
generation bad rng and all these

306
00:13:04,930 --> 00:13:08,260
examples will be published I'm gonna

307
00:13:06,279 --> 00:13:11,290
head by the way so you can run these

308
00:13:08,260 --> 00:13:13,870
yourself so for this example we're

309
00:13:11,290 --> 00:13:20,439
actually running the program

310
00:13:13,870 --> 00:13:23,470
let's run demos demos demo to slash the

311
00:13:20,440 --> 00:13:25,330
exe file so we run that it's Jessica

312
00:13:23,470 --> 00:13:27,790
generates a key nothing is done with the

313
00:13:25,330 --> 00:13:30,279
key purely a toy example you'll be

314
00:13:27,790 --> 00:13:34,060
running again dinky run again different

315
00:13:30,279 --> 00:13:35,650
key etc but what's gonna be interesting

316
00:13:34,060 --> 00:13:37,239
and this is something to really look out

317
00:13:35,650 --> 00:13:38,230
for because this is your first site and

318
00:13:37,240 --> 00:13:40,480
that something is going wrong with the

319
00:13:38,230 --> 00:13:46,600
encryption is if you read twice quickly

320
00:13:40,480 --> 00:13:49,540
you get the same key a EE 989 oh if I

321
00:13:46,600 --> 00:13:51,550
run it lots of times we may see a hugger

322
00:13:49,540 --> 00:13:54,099
to favorites' but the key change is

323
00:13:51,550 --> 00:13:55,839
roughly once per second which means that

324
00:13:54,100 --> 00:13:58,510
he's probably based on the current time

325
00:13:55,839 --> 00:14:00,670
that's a huge wedge like he should in

326
00:13:58,510 --> 00:14:03,580
every base at a time actually based on

327
00:14:00,670 --> 00:14:06,880
completely random entropy that can't be

328
00:14:03,580 --> 00:14:08,529
predicted by any reasonable person so

329
00:14:06,880 --> 00:14:11,710
let's keep that in mind and look at the

330
00:14:08,529 --> 00:14:13,630
source code the source code the main

331
00:14:11,710 --> 00:14:16,360
functions identical we call do encrypt

332
00:14:13,630 --> 00:14:19,180
on a static string the doom cred

333
00:14:16,360 --> 00:14:21,220
function the first half is a key gen the

334
00:14:19,180 --> 00:14:23,859
second half is just printing it you can

335
00:14:21,220 --> 00:14:26,650
know in a second half so for the key gen

336
00:14:23,860 --> 00:14:30,190
we declare a variable to hold the key 16

337
00:14:26,650 --> 00:14:31,689
bytes we call s trend which is the seed

338
00:14:30,190 --> 00:14:34,810
right for the round number generator

339
00:14:31,690 --> 00:14:37,000
with the current time the current time

340
00:14:34,810 --> 00:14:41,560
is predictable I know what time it is

341
00:14:37,000 --> 00:14:45,250
it's November it's phase 333 p.m. so

342
00:14:41,560 --> 00:14:48,760
that's predictable then we loop 16 times

343
00:14:45,250 --> 00:14:50,200
an each loop we call around well we know

344
00:14:48,760 --> 00:14:53,529
what brand does we just saw the code for

345
00:14:50,200 --> 00:14:55,029
that over on the over right here this is

346
00:14:53,529 --> 00:14:57,279
a linux version we're using a Windows

347
00:14:55,029 --> 00:15:00,310
version but see effectively the same it

348
00:14:57,279 --> 00:15:02,680
takes the seed x number as another

349
00:15:00,310 --> 00:15:06,729
number and returns it that's literally

350
00:15:02,680 --> 00:15:08,380
it if if the seed is a current time then

351
00:15:06,730 --> 00:15:13,240
we can just multiply the current time by

352
00:15:08,380 --> 00:15:16,270
this and this and we have the code now

353
00:15:13,240 --> 00:15:19,180
let's just look like in assembly well

354
00:15:16,270 --> 00:15:23,470
we're gonna open up the Ida file just

355
00:15:19,180 --> 00:15:25,780
before this is completely fresh domain

356
00:15:23,470 --> 00:15:28,110
the main functions identical it pushes a

357
00:15:25,780 --> 00:15:31,120
text it calls do encrypt

358
00:15:28,110 --> 00:15:32,890
now do encrypt has much setup here about

359
00:15:31,120 --> 00:15:34,690
like screen cookie where's they ignore

360
00:15:32,890 --> 00:15:37,960
all that because all I want to see is

361
00:15:34,690 --> 00:15:41,050
their really simple things it calls time

362
00:15:37,960 --> 00:15:45,370
and then time returns its return value

363
00:15:41,050 --> 00:15:49,209
in EAX then they use EDX as a parameter

364
00:15:45,370 --> 00:15:51,190
to s friend that means it has two seats

365
00:15:49,210 --> 00:15:53,770
and random generate random number

366
00:15:51,190 --> 00:15:56,050
generator it's the current time then

367
00:15:53,770 --> 00:15:59,920
stuff happens stuff happens

368
00:15:56,050 --> 00:16:02,500
oh hey look there is rent we see a

369
00:15:59,920 --> 00:16:04,900
little loop here the bottom jumps the

370
00:16:02,500 --> 00:16:08,110
top it does a bunch of loopy stuff and

371
00:16:04,900 --> 00:16:09,400
it calls random each loop if you spend

372
00:16:08,110 --> 00:16:13,300
at that time you'll see is looping

373
00:16:09,400 --> 00:16:16,630
sixteen times and each loop is a screen

374
00:16:13,300 --> 00:16:19,449
one random byte so immediately we can

375
00:16:16,630 --> 00:16:21,490
see that the from observing the

376
00:16:19,450 --> 00:16:23,440
application we see the key only change

377
00:16:21,490 --> 00:16:26,260
one per second then from looking at this

378
00:16:23,440 --> 00:16:28,930
we see it's based on time and is based

379
00:16:26,260 --> 00:16:30,130
on R and so you know that if you can

380
00:16:28,930 --> 00:16:34,439
figure out how R and works which is

381
00:16:30,130 --> 00:16:39,880
documented equally versus decryption so

382
00:16:34,440 --> 00:16:41,230
don't do that if you're programming so I

383
00:16:39,880 --> 00:16:42,370
talked a lot about random and I've

384
00:16:41,230 --> 00:16:45,100
showed you random algorithms a little

385
00:16:42,370 --> 00:16:50,440
bit let's dive into those a little bit

386
00:16:45,100 --> 00:16:51,430
deeper so I've sort of referred to term

387
00:16:50,440 --> 00:16:55,170
PRNG

388
00:16:51,430 --> 00:16:59,370
or pseudo-random generator a few times a

389
00:16:55,170 --> 00:17:01,750
PRNG generates random ish numbers and

390
00:16:59,370 --> 00:17:04,180
remember each numbers are only good for

391
00:17:01,750 --> 00:17:06,970
security if we want a secure ish system

392
00:17:04,180 --> 00:17:08,440
if you want a good key we need better

393
00:17:06,970 --> 00:17:11,650
and I've already talked those better

394
00:17:08,440 --> 00:17:15,210
functions but let's say we're valuing

395
00:17:11,650 --> 00:17:18,250
code how do we recognize a bad PRNG

396
00:17:15,210 --> 00:17:23,110
so one PNG is called a linear

397
00:17:18,250 --> 00:17:25,000
congruential generator i put a link to

398
00:17:23,109 --> 00:17:26,679
related code here which has implications

399
00:17:25,000 --> 00:17:30,550
and every language you could possibly

400
00:17:26,680 --> 00:17:32,860
imagine a linear congruential generator

401
00:17:30,550 --> 00:17:34,480
is a Fanta named for a very simple code

402
00:17:32,860 --> 00:17:37,689
and in fact is this code that we've

403
00:17:34,480 --> 00:17:39,970
already seen when you call s friend

404
00:17:37,690 --> 00:17:43,269
it sets a seed what you call rent

405
00:17:39,970 --> 00:17:46,230
it multiplies as the seed and then this

406
00:17:43,269 --> 00:17:50,320
end shrinks it down to a smaller value

407
00:17:46,230 --> 00:17:53,080
so almost all the Randi use for stuff

408
00:17:50,320 --> 00:17:55,029
uses either an lcg's like this or a

409
00:17:53,080 --> 00:17:56,908
Mersenne twister which we're going to

410
00:17:55,029 --> 00:18:00,389
see a little bit later

411
00:17:56,909 --> 00:18:03,549
one thing that those who and most other

412
00:18:00,389 --> 00:18:05,830
pseudo-rng x' have in common is that you

413
00:18:03,549 --> 00:18:09,279
start with a seed and this seed has the

414
00:18:05,830 --> 00:18:11,949
mass happen to it how does how does math

415
00:18:09,279 --> 00:18:14,230
get inflicted on a seed well that

416
00:18:11,950 --> 00:18:15,549
depends on the generator but we're not

417
00:18:14,230 --> 00:18:17,679
gonna worry too much about that we're

418
00:18:15,549 --> 00:18:19,629
just gonna girlfriend Google if we were

419
00:18:17,679 --> 00:18:21,879
to pump that constant one one zero three

420
00:18:19,629 --> 00:18:25,928
five in your Google the first result

421
00:18:21,879 --> 00:18:27,459
says look this is an LCG that was easy

422
00:18:25,929 --> 00:18:29,110
now we all need to member since you're

423
00:18:27,460 --> 00:18:31,690
in the code we know exactly what it is

424
00:18:29,110 --> 00:18:36,789
and we can find a hundred invitations on

425
00:18:31,690 --> 00:18:40,149
rows that code simple so now let's look

426
00:18:36,789 --> 00:18:44,590
at a different type of RNG as a demo so

427
00:18:40,149 --> 00:18:46,000
this will be demo three unknown RNG so

428
00:18:44,590 --> 00:18:48,330
this is gonna be a little bit of coding

429
00:18:46,000 --> 00:18:52,809
so let's first begin by running the code

430
00:18:48,330 --> 00:18:54,220
demo three slash or not RNG so what

431
00:18:52,809 --> 00:18:56,320
we're going to see I print out the seed

432
00:18:54,220 --> 00:18:57,759
which most crib software it doesn't

433
00:18:56,320 --> 00:18:59,950
print the seed this is just to make it

434
00:18:57,759 --> 00:19:02,289
easier to understand and then we

435
00:18:59,950 --> 00:19:04,120
generate the key so if we run it quickly

436
00:19:02,289 --> 00:19:06,129
we're gonna see it doesn't have a same

437
00:19:04,120 --> 00:19:08,110
thing twice but same way it did before a

438
00:19:06,129 --> 00:19:09,399
big secret is if you running this one

439
00:19:08,110 --> 00:19:11,649
even more quickly like twice per

440
00:19:09,399 --> 00:19:15,428
millisecond they will but we'll see why

441
00:19:11,649 --> 00:19:17,350
in a bit so let's say we want to

442
00:19:15,429 --> 00:19:20,019
generate this key so let's pick this one

443
00:19:17,350 --> 00:19:24,100
for example we have our seed and we have

444
00:19:20,019 --> 00:19:29,110
our key so how does this work well we're

445
00:19:24,100 --> 00:19:31,000
not going to look at the at the CVP file

446
00:19:29,110 --> 00:19:33,549
because that's too easy it has comments

447
00:19:31,000 --> 00:19:37,830
or instead you look straight at our iya

448
00:19:33,549 --> 00:19:42,460
file so once again let's go to main and

449
00:19:37,830 --> 00:19:44,649
scroll so immediately we see it get to

450
00:19:42,460 --> 00:19:47,320
account in case you haven't heard get to

451
00:19:44,649 --> 00:19:49,689
count we're going to copy it we're gonna

452
00:19:47,320 --> 00:19:51,120
paste it to memorize earlier that I do

453
00:19:49,690 --> 00:19:55,770
love googling

454
00:19:51,120 --> 00:19:57,090
okay take count function REE trees the

455
00:19:55,770 --> 00:19:59,639
number of milliseconds in your left's

456
00:19:57,090 --> 00:20:00,689
it's a system we started sounds simple

457
00:19:59,640 --> 00:20:04,830
enough

458
00:20:00,690 --> 00:20:07,560
is this as as bad as using the current

459
00:20:04,830 --> 00:20:10,080
time no is this good

460
00:20:07,560 --> 00:20:13,470
no this is not good this is still really

461
00:20:10,080 --> 00:20:16,679
really bad because we can take a preview

462
00:20:13,470 --> 00:20:18,930
guess 20 beers have started and I worse

463
00:20:16,680 --> 00:20:21,750
this one again resolution has 50 days so

464
00:20:18,930 --> 00:20:23,760
you can predict this you don't everyone

465
00:20:21,750 --> 00:20:26,130
use this for corporate purposes in fact

466
00:20:23,760 --> 00:20:27,780
if you're ever seeking render function

467
00:20:26,130 --> 00:20:31,890
you probably don't use effort if they

468
00:20:27,780 --> 00:20:35,670
have a purposes period then we call my

469
00:20:31,890 --> 00:20:37,890
friend we print the seed and then we

470
00:20:35,670 --> 00:20:40,050
print we call my rent let's take a look

471
00:20:37,890 --> 00:20:43,380
at my s friend my best friend is

472
00:20:40,050 --> 00:20:46,680
actually somewhat complicated it does

473
00:20:43,380 --> 00:20:50,130
stuff it compares a value to 1 5 F which

474
00:20:46,680 --> 00:20:53,430
is hex 3 5 1 in decimal it multiplies by

475
00:20:50,130 --> 00:20:56,010
1 C 8 whatever which is 2 9 in decimal

476
00:20:53,430 --> 00:20:58,290
this is one of somebody so it's short

477
00:20:56,010 --> 00:21:01,610
but does some ass let's keep this value

478
00:20:58,290 --> 00:21:05,370
in mind because it might come in handy

479
00:21:01,610 --> 00:21:09,229
wink then let's look at the written

480
00:21:05,370 --> 00:21:11,459
function rend is a little more complex

481
00:21:09,230 --> 00:21:14,490
there's a lot going on there's some

482
00:21:11,460 --> 00:21:17,100
constants this would be really scared

483
00:21:14,490 --> 00:21:18,990
reverse there's n there's xtour there

484
00:21:17,100 --> 00:21:21,120
shifts there's or there's move lose

485
00:21:18,990 --> 00:21:24,660
there's all kind of stuff going on it

486
00:21:21,120 --> 00:21:26,689
goes on and on so if we had to we could

487
00:21:24,660 --> 00:21:29,490
reverse this function it's just not fun

488
00:21:26,690 --> 00:21:32,690
so let's do this the easy way by locate

489
00:21:29,490 --> 00:21:37,830
the S friend copying that constant and

490
00:21:32,690 --> 00:21:40,770
pasting it into Google give a patient a

491
00:21:37,830 --> 00:21:44,790
Google oh hey look the second result is

492
00:21:40,770 --> 00:21:47,730
called random dots see look at that a

493
00:21:44,790 --> 00:21:50,340
code for a number generator specifically

494
00:21:47,730 --> 00:21:53,220
this is a Mersenne twister so when I

495
00:21:50,340 --> 00:21:57,959
copy this code we're gonna paste this

496
00:21:53,220 --> 00:22:01,490
into my solution skeleton which is as my

497
00:21:57,960 --> 00:22:01,490
executor solution let me take a look

498
00:22:02,050 --> 00:22:06,250
oh good this is an empty solution this

499
00:22:04,900 --> 00:22:09,540
solution is a mic best friend and

500
00:22:06,250 --> 00:22:12,760
mightier and function so let's just

501
00:22:09,540 --> 00:22:15,940
paste the whole block here I'm going to

502
00:22:12,760 --> 00:22:18,700
make a couple small changes because this

503
00:22:15,940 --> 00:22:22,300
was designed for something else so said

504
00:22:18,700 --> 00:22:24,370
seed and Jen random are functions Ren

505
00:22:22,300 --> 00:22:26,440
mask isn't defiance we have used one

506
00:22:24,370 --> 00:22:30,669
bite if you look at the code you would

507
00:22:26,440 --> 00:22:34,810
find there 0xff at the end of rent I'll

508
00:22:30,670 --> 00:22:38,830
delete my test render my friend my s

509
00:22:34,810 --> 00:22:47,710
friend is going to become succeed our

510
00:22:38,830 --> 00:22:49,810
seed is this value here we go and then

511
00:22:47,710 --> 00:22:51,460
each loop is going to call my R and

512
00:22:49,810 --> 00:22:58,149
we're going to change that to generate

513
00:22:51,460 --> 00:23:03,220
though then compile run our output is e

514
00:22:58,150 --> 00:23:05,910
3 6 6 2 F the original one it was III 6

515
00:23:03,220 --> 00:23:08,830
6 2 F so we just Joey the same

516
00:23:05,910 --> 00:23:11,200
cryptographic key in big rotation marks

517
00:23:08,830 --> 00:23:15,159
by simply understanding about the random

518
00:23:11,200 --> 00:23:20,200
generator and guessing the seed so very

519
00:23:15,160 --> 00:23:35,800
simple I should have closed that command

520
00:23:20,200 --> 00:23:38,770
prompt ok so there we go we identified

521
00:23:35,800 --> 00:23:41,020
and with it we were able to break the

522
00:23:38,770 --> 00:23:43,990
poppy oranjee now you wanna think this

523
00:23:41,020 --> 00:23:47,110
such by example but this literal attack

524
00:23:43,990 --> 00:23:48,790
with this literal same process work

525
00:23:47,110 --> 00:23:51,429
exactly like that for a project at work

526
00:23:48,790 --> 00:23:57,970
done so this actual attack has come up

527
00:23:51,430 --> 00:24:00,340
in any pen test before so now in fact

528
00:23:57,970 --> 00:24:03,010
about about keys where things start to

529
00:24:00,340 --> 00:24:06,010
go wrong and or in G's where things

530
00:24:03,010 --> 00:24:10,660
continuing wrong never talk about dough

531
00:24:06,010 --> 00:24:12,310
itself where things really go wrong so

532
00:24:10,660 --> 00:24:13,950
when you actually start looking at

533
00:24:12,310 --> 00:24:16,530
crypto you're going to I know two things

534
00:24:13,950 --> 00:24:19,300
well initially

535
00:24:16,530 --> 00:24:21,460
we already talked about keys so in this

536
00:24:19,300 --> 00:24:23,530
case we won't know what algorithm is

537
00:24:21,460 --> 00:24:26,890
being used and what mode is it being

538
00:24:23,530 --> 00:24:29,530
used in and then what is a mode we'll

539
00:24:26,890 --> 00:24:31,600
talk about that number we're doing this

540
00:24:29,530 --> 00:24:33,310
the easy way we're going to Google

541
00:24:31,600 --> 00:24:35,439
constants we're gonna look at lengths of

542
00:24:33,310 --> 00:24:40,030
things we're not going to like reverse

543
00:24:35,440 --> 00:24:42,100
mathematical stuff not that so what I do

544
00:24:40,030 --> 00:24:44,050
if I run into a situation where I can

545
00:24:42,100 --> 00:24:45,730
encrypt arbitrary text and I want to

546
00:24:44,050 --> 00:24:47,110
know how the crypto works whether it's

547
00:24:45,730 --> 00:24:49,510
being done locally or remotely

548
00:24:47,110 --> 00:24:53,110
I just encrypt the letter a and then a a

549
00:24:49,510 --> 00:24:57,160
and then AAA and so on it's not just a

550
00:24:53,110 --> 00:24:58,899
because I'm Canyon a it's a because it's

551
00:24:57,160 --> 00:25:01,810
something that's had to be a I just like

552
00:24:58,900 --> 00:25:04,000
a but the pattern of how the output

553
00:25:01,810 --> 00:25:06,669
changes based on the input changes tells

554
00:25:04,000 --> 00:25:10,300
you if you know about algorithms and key

555
00:25:06,670 --> 00:25:13,240
sizes and sorry algorithms and modes and

556
00:25:10,300 --> 00:25:15,669
everything else so we're gonna do a

557
00:25:13,240 --> 00:25:17,770
quick demo of recognizing ciphers based

558
00:25:15,670 --> 00:25:22,240
on block size why we talked to lolly

559
00:25:17,770 --> 00:25:23,980
Baja IES is has a 128-bit key now let's

560
00:25:22,240 --> 00:25:31,450
talk about the size of blocks and what

561
00:25:23,980 --> 00:25:35,490
luck is in fact so weird around IRB to

562
00:25:31,450 --> 00:25:40,030
getting a ruby tool then we're going to

563
00:25:35,490 --> 00:25:41,680
copy and paste code ahead open basically

564
00:25:40,030 --> 00:25:46,060
we're going to play in three very simple

565
00:25:41,680 --> 00:25:47,080
crypto with one single same key we're

566
00:25:46,060 --> 00:25:50,409
gonna use rc4

567
00:25:47,080 --> 00:25:52,720
which is a really bad stream cipher we

568
00:25:50,410 --> 00:25:55,720
reuse des which is a really bad block

569
00:25:52,720 --> 00:25:59,470
cipher every is a es we should really

570
00:25:55,720 --> 00:26:02,620
good luck cipher being used badly then

571
00:25:59,470 --> 00:26:05,190
we are going to another piece of code

572
00:26:02,620 --> 00:26:07,149
like pre-written and basically encrypt

573
00:26:05,190 --> 00:26:09,160
let's let's start by doing this by hand

574
00:26:07,150 --> 00:26:17,080
rather than using the code that I put

575
00:26:09,160 --> 00:26:19,690
here so if we run rc4 of some string we

576
00:26:17,080 --> 00:26:21,600
get an output at some string then we

577
00:26:19,690 --> 00:26:24,520
change the string that's that's going in

578
00:26:21,600 --> 00:26:26,899
this one it goes out changes and we're

579
00:26:24,520 --> 00:26:31,220
curious how that string changes

580
00:26:26,899 --> 00:26:38,090
des the same thing depending on the

581
00:26:31,220 --> 00:26:41,009
string in the string changes so you go

582
00:26:38,090 --> 00:26:45,090
now what's interesting about this is if

583
00:26:41,009 --> 00:26:47,159
we have one character and outputs eight

584
00:26:45,090 --> 00:26:49,949
bytes if you have two characters that

585
00:26:47,159 --> 00:26:52,830
puts a bytes we have seven characters

586
00:26:49,950 --> 00:26:56,159
eight bytes if you have eight characters

587
00:26:52,830 --> 00:26:58,320
there's sixteen bytes if we have 24

588
00:26:56,159 --> 00:27:00,590
characters or 32 bytes what we're seeing

589
00:26:58,320 --> 00:27:03,980
here is what's called a block cipher

590
00:27:00,590 --> 00:27:11,970
which means all work is done in blocks

591
00:27:03,980 --> 00:27:14,519
so let's find that code I just had copy

592
00:27:11,970 --> 00:27:16,739
paste so for rc4 let's encrypt

593
00:27:14,519 --> 00:27:19,859
everything from 1 to 40 bytes long and

594
00:27:16,739 --> 00:27:22,769
then just print the links so we encrypt

595
00:27:19,859 --> 00:27:24,899
one byte the outputs one byte two bytes

596
00:27:22,769 --> 00:27:27,119
this two-way city by just easy ways

597
00:27:24,899 --> 00:27:36,268
they're going let's try something like

598
00:27:27,119 --> 00:27:39,209
this it's just right here so when we

599
00:27:36,269 --> 00:27:40,679
have dentist 1 by n is 8 bytes 2 is 8 3

600
00:27:39,210 --> 00:27:47,279
is 8 4 is 8 5 is 8 and so on

601
00:27:40,679 --> 00:27:49,200
you see 8 16 24 32 40 48 and so on the

602
00:27:47,279 --> 00:27:51,330
reason is it only ever operates in

603
00:27:49,200 --> 00:27:52,919
blocks of 8 bytes and as soon as you get

604
00:27:51,330 --> 00:27:56,699
the eighth point it doesn't eat more

605
00:27:52,919 --> 00:27:59,989
bytes if we do a es we're going to see

606
00:27:56,700 --> 00:28:04,440
roughly the same pattern only 16 bytes

607
00:27:59,989 --> 00:28:07,799
32 bytes 48 bytes and so on that's

608
00:28:04,440 --> 00:28:12,480
because des uses 8 byte blocks AES is

609
00:28:07,799 --> 00:28:14,730
this 16 byte blocks so here's a summary

610
00:28:12,480 --> 00:28:17,100
like I said if you see 1 byte blocks

611
00:28:14,730 --> 00:28:21,629
it's probably a stream cipher so look at

612
00:28:17,100 --> 00:28:24,918
rc4 or salsa 20 or a block cipher CTR

613
00:28:21,629 --> 00:28:28,498
mode unfortunately kind of hard to tell

614
00:28:24,919 --> 00:28:30,840
however if you see 8 byte blocks and the

615
00:28:28,499 --> 00:28:33,600
key is 7 or 8 bytes long it's almost

616
00:28:30,840 --> 00:28:37,049
certainly this if you see 16 byte blocks

617
00:28:33,600 --> 00:28:40,080
and the keys are 16 24 or 32 bytes is

618
00:28:37,049 --> 00:28:43,020
probably a es a eh

619
00:28:40,080 --> 00:28:48,060
AES has one block size which is sixteen

620
00:28:43,020 --> 00:28:51,480
and three key sizes which is 16 24 32 so

621
00:28:48,060 --> 00:28:53,460
keep that in mind other than ciphers

622
00:28:51,480 --> 00:28:57,330
we're gonna talk about most of operation

623
00:28:53,460 --> 00:29:00,050
first of all what is a mode so a block

624
00:28:57,330 --> 00:29:02,879
cipher encrypts each block individually

625
00:29:00,050 --> 00:29:04,680
the question is how do those blocks

626
00:29:02,880 --> 00:29:08,460
connect with each other to form a full

627
00:29:04,680 --> 00:29:12,090
ciphertext the simplest concept is ECB

628
00:29:08,460 --> 00:29:14,760
which is electronic code book where the

629
00:29:12,090 --> 00:29:17,790
plaintext and key go into a block cipher

630
00:29:14,760 --> 00:29:21,060
algorithm which is AES or des or many

631
00:29:17,790 --> 00:29:23,909
many others and opop ciphertext then the

632
00:29:21,060 --> 00:29:26,250
next block of plaintext goes in the key

633
00:29:23,910 --> 00:29:28,470
goes in several decks comes out third

634
00:29:26,250 --> 00:29:29,850
block goes in this means that each block

635
00:29:28,470 --> 00:29:32,190
of plaintext and each block of

636
00:29:29,850 --> 00:29:35,219
ciphertext is independent from at the

637
00:29:32,190 --> 00:29:37,290
other the same key the same plaintext

638
00:29:35,220 --> 00:29:40,650
will generate the same ciphertext which

639
00:29:37,290 --> 00:29:43,680
is a problem the famous example of is

640
00:29:40,650 --> 00:29:46,410
the problem is encrypting the Linux tux

641
00:29:43,680 --> 00:29:47,130
symbol so the original image looks like

642
00:29:46,410 --> 00:29:50,130
a penguin

643
00:29:47,130 --> 00:29:53,850
the ECB encrypted image looks like a

644
00:29:50,130 --> 00:29:56,360
very weird penguin the CBC encrypted

645
00:29:53,850 --> 00:30:01,230
image which we will see shortly is

646
00:29:56,360 --> 00:30:03,179
purely random looking and honestly ECB

647
00:30:01,230 --> 00:30:05,550
and CBC are the vast majority of

648
00:30:03,180 --> 00:30:09,000
encryption that actually see and AES in

649
00:30:05,550 --> 00:30:10,169
DES are the vast majority of rhythms are

650
00:30:09,000 --> 00:30:12,090
there's a very special line this year

651
00:30:10,170 --> 00:30:14,880
for a reverse encrypted easy way

652
00:30:12,090 --> 00:30:16,980
presentation I took the entire first

653
00:30:14,880 --> 00:30:19,530
page of this presentation and encrypted

654
00:30:16,980 --> 00:30:22,080
the bitmap with I believe this is with

655
00:30:19,530 --> 00:30:25,500
DES and this is what it looks like an

656
00:30:22,080 --> 00:30:27,240
ECB mode if I was a CBC mode which we'll

657
00:30:25,500 --> 00:30:31,920
talk about next slide it will look

658
00:30:27,240 --> 00:30:34,530
completely random Hey look CBC mode so

659
00:30:31,920 --> 00:30:36,780
at CBC each block depends on a

660
00:30:34,530 --> 00:30:38,940
ciphertext that comes before it what's

661
00:30:36,780 --> 00:30:42,480
that mean it means we start with a plain

662
00:30:38,940 --> 00:30:44,790
text and an IV yeah V we're not gonna

663
00:30:42,480 --> 00:30:48,090
worry much about the plain text in a key

664
00:30:44,790 --> 00:30:51,190
go into the encryption box and out comes

665
00:30:48,090 --> 00:30:53,260
a first block a ciphertext then

666
00:30:51,190 --> 00:30:54,940
that separate text is mixed with a plain

667
00:30:53,260 --> 00:30:57,879
text it's encrypted

668
00:30:54,940 --> 00:31:01,410
I'll come cipher text then cipher text

669
00:30:57,880 --> 00:31:03,760
and play texture and so on so each each

670
00:31:01,410 --> 00:31:04,510
plaintext is mixed with the previous

671
00:31:03,760 --> 00:31:07,390
ciphertext

672
00:31:04,510 --> 00:31:09,430
this leads to some problems you may have

673
00:31:07,390 --> 00:31:11,890
heard of penny or goat X which I talked

674
00:31:09,430 --> 00:31:14,650
about blog dark dark right here these

675
00:31:11,890 --> 00:31:16,210
happen because of this mixing so it's

676
00:31:14,650 --> 00:31:20,110
not always good but this is the most

677
00:31:16,210 --> 00:31:23,580
common way people use encryption so as I

678
00:31:20,110 --> 00:31:26,679
said you'll almost always see ECB or CBC

679
00:31:23,580 --> 00:31:28,929
good judgment is typically view CTR mode

680
00:31:26,680 --> 00:31:31,720
but if you actually implement crept over

681
00:31:28,930 --> 00:31:33,600
breaking crypto you might want to shake

682
00:31:31,720 --> 00:31:38,560
a talk that's not about breaking crypto

683
00:31:33,600 --> 00:31:41,379
so let's do a demo on that so I use the

684
00:31:38,560 --> 00:31:44,379
same application a copy a new piece of

685
00:31:41,380 --> 00:31:48,070
code this new code simply has two

686
00:31:44,380 --> 00:31:50,710
different functions one is ECB with just

687
00:31:48,070 --> 00:31:52,360
encrypt your dad with ECB and then pumps

688
00:31:50,710 --> 00:31:54,790
up the blocks and makes them printable

689
00:31:52,360 --> 00:31:57,250
which is well the extra code is the CBC

690
00:31:54,790 --> 00:31:59,710
one does the same thing encrypt des cbc

691
00:31:57,250 --> 00:32:03,070
and outputs the blocks

692
00:31:59,710 --> 00:32:06,760
so let's write let's do an ECB of 8 8 8

693
00:32:03,070 --> 00:32:07,120
we're gonna see it puts one block six

694
00:32:06,760 --> 00:32:09,610
bytes

695
00:32:07,120 --> 00:32:13,840
one block set in whites one block eight

696
00:32:09,610 --> 00:32:15,870
bytes well I put two blocks if we do how

697
00:32:13,840 --> 00:32:18,399
many bytes we're gonna get five blocks

698
00:32:15,870 --> 00:32:21,209
so we can notice here is that the first

699
00:32:18,400 --> 00:32:24,210
second third and fourth locks are

700
00:32:21,210 --> 00:32:28,180
absolutely identical this is because

701
00:32:24,210 --> 00:32:28,570
each a eight times encrypts the same

702
00:32:28,180 --> 00:32:30,340
thing

703
00:32:28,570 --> 00:32:33,189
how could not when it does have any

704
00:32:30,340 --> 00:32:35,230
other dependencies if we change the

705
00:32:33,190 --> 00:32:37,000
first point we're gonna see the first

706
00:32:35,230 --> 00:32:39,280
block changes the second third and

707
00:32:37,000 --> 00:32:41,920
fourth don't if we change the last block

708
00:32:39,280 --> 00:32:44,020
with the last block changes again the

709
00:32:41,920 --> 00:32:45,970
middle and stay the same this is

710
00:32:44,020 --> 00:32:48,010
basically guaranteed to be ECB

711
00:32:45,970 --> 00:32:51,730
electronic codebook and criminal if you

712
00:32:48,010 --> 00:32:54,220
see this behavior cbz another hand give

713
00:32:51,730 --> 00:32:55,870
encrypt one byte four bytes

714
00:32:54,220 --> 00:32:57,250
you'll notice the default bytes that

715
00:32:55,870 --> 00:33:01,600
same as ECB because we only have one

716
00:32:57,250 --> 00:33:04,600
block so far eight bytes we're gonna see

717
00:33:01,600 --> 00:33:07,809
the same thing as easy be so far roughly

718
00:33:04,600 --> 00:33:09,610
they leave it a bunch of blocks it looks

719
00:33:07,809 --> 00:33:11,590
like it was six blocks you'll see that

720
00:33:09,610 --> 00:33:14,439
even though the blocks are the same the

721
00:33:11,590 --> 00:33:16,149
output is different this means that

722
00:33:14,440 --> 00:33:18,210
there's less patterns which is a good

723
00:33:16,149 --> 00:33:21,489
thing if we change the first block

724
00:33:18,210 --> 00:33:24,190
everything changes not just the first

725
00:33:21,490 --> 00:33:26,399
block if we change the last block only

726
00:33:24,190 --> 00:33:29,830
last one changes nothing before this

727
00:33:26,399 --> 00:33:32,199
this tells you that has CBC if you can

728
00:33:29,830 --> 00:33:34,269
perform this experiment and see either

729
00:33:32,200 --> 00:33:36,750
these two behaviors you know what you're

730
00:33:34,269 --> 00:33:41,200
looking at if you see any other behavior

731
00:33:36,750 --> 00:33:44,740
then it's not if it's not ECB or stat

732
00:33:41,200 --> 00:33:46,090
CBC or it's using an IV for CBC which

733
00:33:44,740 --> 00:33:48,279
means if you change the same thing twice

734
00:33:46,090 --> 00:33:50,918
it'll be different whereas when we don't

735
00:33:48,279 --> 00:33:53,230
know it's the same but taking a very

736
00:33:50,919 --> 00:33:56,620
easy victory or defying crypto

737
00:33:53,230 --> 00:33:59,710
algorithms so some common problems with

738
00:33:56,620 --> 00:34:02,199
crypto modes ECB is worthless there are

739
00:33:59,710 --> 00:34:03,730
patterns there are tax there's block we

740
00:34:02,200 --> 00:34:09,010
shop there's all kinds of tax against it

741
00:34:03,730 --> 00:34:11,379
don't ever use ECB CBC with no IV is bad

742
00:34:09,010 --> 00:34:13,869
we just thought how you can same thing

743
00:34:11,379 --> 00:34:17,440
twice you gonna tame output that's no

744
00:34:13,869 --> 00:34:19,780
decide if you encrypt for the same key

745
00:34:17,440 --> 00:34:22,300
and same IV more than once or if you got

746
00:34:19,780 --> 00:34:26,260
forced an application - that's bad you

747
00:34:22,300 --> 00:34:27,280
lose all security guarantees so we're

748
00:34:26,260 --> 00:34:30,310
going to talk a little bit Windows

749
00:34:27,280 --> 00:34:32,849
Windows is equal to zero point of things

750
00:34:30,310 --> 00:34:36,069
going wrong it is as long as they get

751
00:34:32,849 --> 00:34:38,980
so what Windows doing anything requires

752
00:34:36,069 --> 00:34:41,409
a complex series of well-documented API

753
00:34:38,980 --> 00:34:43,929
calls and by well-documented I mean is

754
00:34:41,409 --> 00:34:45,909
easy to find out what they do it's hard

755
00:34:43,929 --> 00:34:48,700
to actually use them it is really really

756
00:34:45,909 --> 00:34:51,250
really hard to to actually use them so

757
00:34:48,699 --> 00:34:53,109
for example to import the key encrypt

758
00:34:51,250 --> 00:34:55,510
data you'll almost certainly see the

759
00:34:53,109 --> 00:34:58,150
function script acquired context crypt

760
00:34:55,510 --> 00:35:01,660
import key encrypt encrypt next to each

761
00:34:58,150 --> 00:35:03,849
other if you if is doing a web

762
00:35:01,660 --> 00:35:06,848
application functionality stuff is using

763
00:35:03,849 --> 00:35:09,069
like a web api you're gonna see internet

764
00:35:06,849 --> 00:35:12,730
open Internet issue open requests

765
00:35:09,069 --> 00:35:15,490
usually read data and so on very common

766
00:35:12,730 --> 00:35:17,890
requests I spend long time reversing

767
00:35:15,490 --> 00:35:18,109
Windows apps and frequently I just goes

768
00:35:17,890 --> 00:35:21,680
to

769
00:35:18,109 --> 00:35:23,950
list of of the API calls google each one

770
00:35:21,680 --> 00:35:26,509
i don't know and figure out what they do

771
00:35:23,950 --> 00:35:29,149
the a on the end of each these functions

772
00:35:26,509 --> 00:35:31,339
again not because a canadian a just

773
00:35:29,150 --> 00:35:33,980
means s key as opposed to unicode there

774
00:35:31,339 --> 00:35:36,440
are w versions for wide cryptic why

775
00:35:33,980 --> 00:35:38,420
might xw company perky w did you see

776
00:35:36,440 --> 00:35:41,539
they just use unicode otherwise is the

777
00:35:38,420 --> 00:35:43,640
same so we're gonna do a pretty quick

778
00:35:41,539 --> 00:35:48,380
demo because this isn't really a crypto

779
00:35:43,640 --> 00:35:56,089
one now this is a web application so

780
00:35:48,380 --> 00:36:01,970
close don't save don't save all right so

781
00:35:56,089 --> 00:36:04,720
let's go to the demo number six so a few

782
00:36:01,970 --> 00:36:07,308
months ago maybe even a year ago I

783
00:36:04,720 --> 00:36:09,078
released the vulnerability in WebEx

784
00:36:07,309 --> 00:36:11,180
service and we're not gonna talk about

785
00:36:09,079 --> 00:36:13,670
the vulnerability good web x-acto arm to

786
00:36:11,180 --> 00:36:17,960
find the vulnerability but I thought

787
00:36:13,670 --> 00:36:20,890
this was a good example of of learning

788
00:36:17,960 --> 00:36:24,200
learning windows functions via API calls

789
00:36:20,890 --> 00:36:27,799
so if you were to look at this if you

790
00:36:24,200 --> 00:36:29,180
look at the WebEx service client on the

791
00:36:27,799 --> 00:36:30,849
older version it might still be a same a

792
00:36:29,180 --> 00:36:33,529
newer version I haven't looked at it I

793
00:36:30,849 --> 00:36:37,489
was really interested in what is the

794
00:36:33,529 --> 00:36:40,279
import process has user create processes

795
00:36:37,489 --> 00:36:42,859
user creates a process with a

796
00:36:40,279 --> 00:36:45,170
particularly user token and you can see

797
00:36:42,859 --> 00:36:47,390
that this function is called and all the

798
00:36:45,170 --> 00:36:49,609
parameters are commented with what they

799
00:36:47,390 --> 00:36:51,379
actually are so if you want to

800
00:36:49,609 --> 00:36:53,480
understand the context of how this is

801
00:36:51,380 --> 00:36:54,859
being called if we want to top of the

802
00:36:53,480 --> 00:36:58,910
function so let's just scroll up and

803
00:36:54,859 --> 00:37:00,619
open up so now when this function starts

804
00:36:58,910 --> 00:37:02,299
you're gonna see security cookie like

805
00:37:00,619 --> 00:37:03,680
before you're gonna see some

806
00:37:02,299 --> 00:37:06,230
accelerating and some other stuff

807
00:37:03,680 --> 00:37:09,169
don't don't really care the first API

808
00:37:06,230 --> 00:37:11,390
call you see is create create tool helps

809
00:37:09,170 --> 00:37:12,950
32 snapshot which is actually when the

810
00:37:11,390 --> 00:37:15,828
first when it's API as I ever learned

811
00:37:12,950 --> 00:37:17,419
when I was a young young hacker if you

812
00:37:15,829 --> 00:37:20,569
google that you're gonna find the

813
00:37:17,420 --> 00:37:22,369
definition for it it says it takes a

814
00:37:20,569 --> 00:37:26,538
snapshot of the specific processes as

815
00:37:22,369 --> 00:37:28,759
well as user modules and threat okay not

816
00:37:26,539 --> 00:37:31,240
much to go on there but if we look at

817
00:37:28,759 --> 00:37:32,140
the values

818
00:37:31,240 --> 00:37:33,609
you'll be able to figure out what this

819
00:37:32,140 --> 00:37:36,190
is doing we're not going to go too much

820
00:37:33,610 --> 00:37:39,780
then there's air handling as air

821
00:37:36,190 --> 00:37:41,440
handling then we say process 32 first

822
00:37:39,780 --> 00:37:43,570
what's that dude

823
00:37:41,440 --> 00:37:45,760
okay copy it we're going to paste it

824
00:37:43,570 --> 00:37:48,100
we're gonna click on the result

825
00:37:45,760 --> 00:37:50,140
and we're gonna see retrieves

826
00:37:48,100 --> 00:37:52,569
information about the first process in a

827
00:37:50,140 --> 00:37:56,170
snapshot well hey that's Knapp charlie

828
00:37:52,570 --> 00:37:57,700
is what we just saw happy the first

829
00:37:56,170 --> 00:37:59,920
parameter is the handle returned from

830
00:37:57,700 --> 00:38:00,310
create tool helps that you snapshot look

831
00:37:59,920 --> 00:38:03,570
at that

832
00:38:00,310 --> 00:38:08,220
and then LTP is a pointer to son start

833
00:38:03,570 --> 00:38:16,060
alright scroll Scroll scroll what's next

834
00:38:08,220 --> 00:38:19,359
we see WCS ICMP Plus Google today it's a

835
00:38:16,060 --> 00:38:22,090
string compare just performs a case in

836
00:38:19,360 --> 00:38:25,360
sense of comparison of strings alright

837
00:38:22,090 --> 00:38:27,670
one string is win log on the exe it's

838
00:38:25,360 --> 00:38:29,619
hard-coded and one string we don't know

839
00:38:27,670 --> 00:38:31,600
but we can probably guess it came from

840
00:38:29,619 --> 00:38:34,600
the previous function which is the first

841
00:38:31,600 --> 00:38:36,910
process so we can conclude just based on

842
00:38:34,600 --> 00:38:40,720
reasoning that is checking if the first

843
00:38:36,910 --> 00:38:42,759
process is win log on if it is it

844
00:38:40,720 --> 00:38:45,040
continues down if it's not the loop

845
00:38:42,760 --> 00:38:48,130
starts over then we're going to see

846
00:38:45,040 --> 00:38:50,380
process ID to session ID okay copy that

847
00:38:48,130 --> 00:38:54,280
we're going to paste it I'm gonna learn

848
00:38:50,380 --> 00:38:57,670
that well it converts a possibility to

849
00:38:54,280 --> 00:38:59,890
session ID then cross the third you're

850
00:38:57,670 --> 00:39:03,460
next go to the next one what this loop

851
00:38:59,890 --> 00:39:05,770
does is finds the process ID of one log

852
00:39:03,460 --> 00:39:07,150
on the exe that's all if you would

853
00:39:05,770 --> 00:39:11,470
reverse a whole little that's all is

854
00:39:07,150 --> 00:39:16,330
doing once it finds it it calls open

855
00:39:11,470 --> 00:39:20,350
process what open process to open

856
00:39:16,330 --> 00:39:23,410
process opens a local process object not

857
00:39:20,350 --> 00:39:24,850
that helpful but we can I can explain

858
00:39:23,410 --> 00:39:26,740
that basically gets a handle to a

859
00:39:24,850 --> 00:39:30,069
running process in this case we can

860
00:39:26,740 --> 00:39:32,169
guess there's one log on that page then

861
00:39:30,070 --> 00:39:33,940
we get open process token if we google

862
00:39:32,170 --> 00:39:35,010
it that retrieves the token associate

863
00:39:33,940 --> 00:39:37,570
with the process

864
00:39:35,010 --> 00:39:40,090
duplicate token creates a new copy of

865
00:39:37,570 --> 00:39:42,850
token that we can use the in cream

866
00:39:40,090 --> 00:39:44,030
process as user creates a process as a

867
00:39:42,850 --> 00:39:47,089
user even

868
00:39:44,030 --> 00:39:49,430
token the token obviously comes from the

869
00:39:47,090 --> 00:39:51,110
Duke a token which comes from the open

870
00:39:49,430 --> 00:39:54,560
process token which comes up when log on

871
00:39:51,110 --> 00:39:57,770
which runs s system so in only a couple

872
00:39:54,560 --> 00:40:00,170
minutes of simply reasoning we can guess

873
00:39:57,770 --> 00:40:02,990
that great process as user creates a

874
00:40:00,170 --> 00:40:05,900
process as the same user as when log on

875
00:40:02,990 --> 00:40:09,529
or system which turned out to be a huge

876
00:40:05,900 --> 00:40:12,080
privilege escalation and remote sort of

877
00:40:09,530 --> 00:40:13,280
code execution vulnerability and we

878
00:40:12,080 --> 00:40:16,580
figure all that was just based on

879
00:40:13,280 --> 00:40:22,480
following following the API calls very

880
00:40:16,580 --> 00:40:25,160
nice all right

881
00:40:22,480 --> 00:40:27,440
so for my last section putting it all

882
00:40:25,160 --> 00:40:30,980
together otherwise no one that is let's

883
00:40:27,440 --> 00:40:33,080
watch it go wrong in this we're going to

884
00:40:30,980 --> 00:40:34,700
put everything together cracking an

885
00:40:33,080 --> 00:40:37,130
encrypted message by finding a key

886
00:40:34,700 --> 00:40:38,660
generation and the algorithm so

887
00:40:37,130 --> 00:40:40,280
basically take an unknown application

888
00:40:38,660 --> 00:40:42,230
that generates a key took up the message

889
00:40:40,280 --> 00:40:43,850
when we use all the techniques we just

890
00:40:42,230 --> 00:40:49,100
talked about to figure out how and I

891
00:40:43,850 --> 00:40:54,470
break it all right so let's close all

892
00:40:49,100 --> 00:40:56,390
these windows let's go to demo so the

893
00:40:54,470 --> 00:41:00,109
most avid action cleanse it is the ruby

894
00:40:56,390 --> 00:41:02,540
solution so first of all before we

895
00:41:00,110 --> 00:41:05,360
actually start trying to solve it let's

896
00:41:02,540 --> 00:41:10,070
take a look at the at what the

897
00:41:05,360 --> 00:41:12,590
application is doing so demo 7 exe we

898
00:41:10,070 --> 00:41:14,110
run it ask for data all right let's give

899
00:41:12,590 --> 00:41:16,790
it just eight

900
00:41:14,110 --> 00:41:20,270
so for you give it a we have an input of

901
00:41:16,790 --> 00:41:22,970
16 bytes with a key we have a timestamp

902
00:41:20,270 --> 00:41:25,070
I just printed for convenience we have a

903
00:41:22,970 --> 00:41:28,370
key the 16 bytes and we've been up with

904
00:41:25,070 --> 00:41:30,530
the 16 bytes if we have two days same

905
00:41:28,370 --> 00:41:35,210
thing three days and thank for any same

906
00:41:30,530 --> 00:41:38,750
thing if we have five six seven 50 days

907
00:41:35,210 --> 00:41:42,590
same thing 16 days the output doubles to

908
00:41:38,750 --> 00:41:44,570
32 bytes so what we talked about we know

909
00:41:42,590 --> 00:41:50,750
that a key is 16 bytes

910
00:41:44,570 --> 00:41:52,880
it's probably a TS 128 if it's AES 128

911
00:41:50,750 --> 00:41:55,650
the output should be in 16 byte blocks

912
00:41:52,880 --> 00:41:57,900
and it is so that's good

913
00:41:55,650 --> 00:42:04,740
so let's just end cooking this let's

914
00:41:57,900 --> 00:42:06,390
encrypt this is a test message so it

915
00:42:04,740 --> 00:42:08,700
cooks 30 bytes and we're going to try to

916
00:42:06,390 --> 00:42:11,100
break this down so as I mentioned before

917
00:42:08,700 --> 00:42:14,730
if you encrypt the same thing multi me

918
00:42:11,100 --> 00:42:16,440
you must maintain a pattern where see

919
00:42:14,730 --> 00:42:19,320
the two knew each other where the

920
00:42:16,440 --> 00:42:21,270
timestamp is the same the same they're

921
00:42:19,320 --> 00:42:24,780
equipped in the same second you'll get

922
00:42:21,270 --> 00:42:30,180
the same key a 9 to 2 e in FTD the same

923
00:42:24,780 --> 00:42:33,240
output f afdf aft ok so as we mentioned

924
00:42:30,180 --> 00:42:34,589
if we encrypt using a timestamp we're

925
00:42:33,240 --> 00:42:37,859
going to end up with collisions just

926
00:42:34,590 --> 00:42:39,440
like this so now we know that the RNG is

927
00:42:37,860 --> 00:42:40,800
probably seated with the current time

928
00:42:39,440 --> 00:42:43,110
all right

929
00:42:40,800 --> 00:42:47,640
we're making good progress now let's

930
00:42:43,110 --> 00:42:49,170
open up in either alright so in the main

931
00:42:47,640 --> 00:42:52,920
function you can see the error string

932
00:42:49,170 --> 00:42:57,990
usage we saw that earlier then you see a

933
00:42:52,920 --> 00:42:58,920
no file in data and encrypt that's all

934
00:42:57,990 --> 00:43:01,080
we really see in main

935
00:42:58,920 --> 00:43:03,420
so let's see when crypt this encrypt

936
00:43:01,080 --> 00:43:06,120
those weird cookie stuff it does a bunch

937
00:43:03,420 --> 00:43:08,280
of moving variables around there's a

938
00:43:06,120 --> 00:43:13,890
male lock if those men say there's other

939
00:43:08,280 --> 00:43:16,080
stuff it doesn't mem copy so the first

940
00:43:13,890 --> 00:43:17,670
thing you see is crypt acquire context I

941
00:43:16,080 --> 00:43:19,590
mentioned that this is the first

942
00:43:17,670 --> 00:43:22,800
function used when encrypting data on

943
00:43:19,590 --> 00:43:25,860
windows we also have a provider

944
00:43:22,800 --> 00:43:28,230
Microsoft enhanced RSA an aes provider

945
00:43:25,860 --> 00:43:30,060
if you google a string and you go look

946
00:43:28,230 --> 00:43:32,400
at the clear context you will get a lot

947
00:43:30,060 --> 00:43:36,509
of information about a very limit of our

948
00:43:32,400 --> 00:43:40,640
algorithms this might be using then we

949
00:43:36,510 --> 00:43:44,460
see make key make key is going to

950
00:43:40,640 --> 00:43:45,870
presumably create a key and then just

951
00:43:44,460 --> 00:43:49,770
going to print the key and then it's

952
00:43:45,870 --> 00:43:52,350
going to do some encryption down here so

953
00:43:49,770 --> 00:43:55,920
let's take a look at makey makey calls

954
00:43:52,350 --> 00:43:59,400
time just like we talked about it prints

955
00:43:55,920 --> 00:44:03,330
the timestamp and then because my s

956
00:43:59,400 --> 00:44:04,190
friend and then it calls my R and 16

957
00:44:03,330 --> 00:44:07,250
times

958
00:44:04,190 --> 00:44:09,380
let's see oh my car looks like it's a

959
00:44:07,250 --> 00:44:11,450
lot simpler than last example it simply

960
00:44:09,380 --> 00:44:14,869
stores the seed in a variable called

961
00:44:11,450 --> 00:44:18,140
state not much all right let's look at

962
00:44:14,869 --> 00:44:20,900
my rent my grands also very simple it

963
00:44:18,140 --> 00:44:24,140
does a multiply it does an addition it

964
00:44:20,900 --> 00:44:25,789
does an end this is already in decimal

965
00:44:24,140 --> 00:44:30,650
but if we want to we can convert between

966
00:44:25,789 --> 00:44:34,520
X and decimal you can copy this and we

967
00:44:30,650 --> 00:44:37,039
can paste this into our browser and see

968
00:44:34,520 --> 00:44:40,160
what is this okay look why is this value

969
00:44:37,039 --> 00:44:43,430
variable used in rent and it's an LCG

970
00:44:40,160 --> 00:44:45,140
Joseph we talked about if we were to

971
00:44:43,430 --> 00:44:48,788
scroll down we're gonna find rosetta

972
00:44:45,140 --> 00:44:51,379
code org has been has this code and

973
00:44:48,789 --> 00:44:53,180
we're going to scroll down and look at

974
00:44:51,380 --> 00:44:56,660
the Ruby implementation because we're

975
00:44:53,180 --> 00:45:00,109
going to write this exploit in Ruby the

976
00:44:56,660 --> 00:45:03,440
Ruby notation simply has a best friend

977
00:45:00,109 --> 00:45:05,598
function and iran function there are two

978
00:45:03,440 --> 00:45:08,569
different rent functions one is Berkeley

979
00:45:05,599 --> 00:45:10,520
and one is the Microsoft the key we see

980
00:45:08,569 --> 00:45:14,359
is 100 zero three five one five two four

981
00:45:10,520 --> 00:45:17,420
five and that is Microsoft one so we're

982
00:45:14,359 --> 00:45:21,049
just going to copy this function all

983
00:45:17,420 --> 00:45:24,410
together now I'm going to switch windows

984
00:45:21,049 --> 00:45:33,549
back to this so we have everything we

985
00:45:24,410 --> 00:45:36,460
need now okay switch to Maya Ruby seven

986
00:45:33,549 --> 00:45:42,770
we're going to run we're going to edit

987
00:45:36,460 --> 00:45:44,720
demo seven solution skeleton alright so

988
00:45:42,770 --> 00:45:47,270
this is basically a skeleton and I put

989
00:45:44,720 --> 00:45:50,808
together first of all a bunch of to use

990
00:45:47,270 --> 00:45:52,460
the key line very no sixteen bytes the

991
00:45:50,809 --> 00:45:54,950
key generation is going to be where we

992
00:45:52,460 --> 00:46:01,700
employed our random so I'm gonna paste

993
00:45:54,950 --> 00:46:07,399
in the render code I think I might

994
00:46:01,700 --> 00:46:10,279
actually to copy up maybe I'm crazily

995
00:46:07,400 --> 00:46:13,059
broken which is concerning well if I

996
00:46:10,279 --> 00:46:13,059
copy a time step

997
00:46:15,510 --> 00:46:23,380
all right I can't copy of IBM forgive it

998
00:46:19,440 --> 00:46:32,580
differently we're gonna copy this to a

999
00:46:23,380 --> 00:46:37,090
file coming to a file new text file

1000
00:46:32,580 --> 00:46:43,990
random TP paste save all right

1001
00:46:37,090 --> 00:46:58,470
and then we'll also grab the run number

1002
00:46:43,990 --> 00:47:01,930
generator again never get windows

1003
00:46:58,470 --> 00:47:09,430
alright so grab the RNG go back to the

1004
00:47:01,930 --> 00:47:26,379
folder all right sleeve that now we can

1005
00:47:09,430 --> 00:47:29,200
do a lot all right

1006
00:47:26,380 --> 00:47:31,780
so ignoring the bad new lines we have

1007
00:47:29,200 --> 00:47:35,529
our timestamp and everything else we're

1008
00:47:31,780 --> 00:47:45,610
going to grab our RNG we're just going

1009
00:47:35,530 --> 00:47:58,720
to use instead arteries see and then we

1010
00:47:45,610 --> 00:48:00,040
get key plus equals okay so this just

1011
00:47:58,720 --> 00:48:02,290
generates the sequence of random bytes

1012
00:48:00,040 --> 00:48:04,509
that we that we would be generating and

1013
00:48:02,290 --> 00:48:07,180
converts each one to a character and as

1014
00:48:04,510 --> 00:48:10,090
that's the key so there's a very key

1015
00:48:07,180 --> 00:48:12,669
function now we would decrypt function

1016
00:48:10,090 --> 00:48:15,820
so for decrypt way to be the algorithm

1017
00:48:12,670 --> 00:48:19,360
we forgot a es and the details the

1018
00:48:15,820 --> 00:48:26,080
algorithm it's a s 128 we know that

1019
00:48:19,360 --> 00:48:32,140
because we did we saw the key is 1 2016

1020
00:48:26,080 --> 00:48:35,290
and then the mode so now all we need is

1021
00:48:32,140 --> 00:48:36,700
our seed which is gonna be the first

1022
00:48:35,290 --> 00:48:39,190
argument we're just going to harp on

1023
00:48:36,700 --> 00:48:46,060
this since we have a handy here so

1024
00:48:39,190 --> 00:49:02,650
there's our C C equals that and we heard

1025
00:48:46,060 --> 00:49:05,170
that that equals that this is in hex we

1026
00:49:02,650 --> 00:49:08,110
actually need to be in binary so we're

1027
00:49:05,170 --> 00:49:09,760
going to attach each start if you're

1028
00:49:08,110 --> 00:49:11,590
curious about these are convention like

1029
00:49:09,760 --> 00:49:13,210
this I talked about this my blog I don't

1030
00:49:11,590 --> 00:49:15,340
wanna go too much into detail tell you

1031
00:49:13,210 --> 00:49:17,200
this in Ruby because this just is

1032
00:49:15,340 --> 00:49:20,500
complicated unnecessarily complicate

1033
00:49:17,200 --> 00:49:21,970
this talk so they generate a key or get

1034
00:49:20,500 --> 00:49:26,050
print the key or you're meant to decrypt

1035
00:49:21,970 --> 00:49:46,450
a text just for fun let's also print the

1036
00:49:26,050 --> 00:49:50,080
expected key so puts running these the

1037
00:49:46,450 --> 00:49:53,250
best script what we should see it wants

1038
00:49:50,080 --> 00:49:58,180
the two parameters discovered that code

1039
00:49:53,250 --> 00:50:01,330
it's gonna get thanks for the key is a 9

1040
00:49:58,180 --> 00:50:06,210
to EC a generate key is a had to DC and

1041
00:50:01,330 --> 00:50:08,650
decrypted is a test message so despite

1042
00:50:06,210 --> 00:50:11,260
not being a copy for IBM and despite

1043
00:50:08,650 --> 00:50:13,240
being a little bit troublesome I was

1044
00:50:11,260 --> 00:50:16,390
able to reverse this but five minutes

1045
00:50:13,240 --> 00:50:18,609
maybe less and I've literally done this

1046
00:50:16,390 --> 00:50:23,859
exact same sequence for other uses as

1047
00:50:18,610 --> 00:50:25,200
well alright so conclusion where things

1048
00:50:23,860 --> 00:50:27,820
funny stuff going wrong

1049
00:50:25,200 --> 00:50:29,740
so hopefully learn a few new things such

1050
00:50:27,820 --> 00:50:31,600
as how to clean anti crypto keys have

1051
00:50:29,740 --> 00:50:33,990
identified algorithms and most operation

1052
00:50:31,600 --> 00:50:38,330
it had to quickly find cryptographic oh

1053
00:50:33,990 --> 00:50:39,859
that wasn't able to talk so this

1054
00:50:38,330 --> 00:50:43,190
a presentation for a holiday hack

1055
00:50:39,860 --> 00:50:46,670
challenge 2019 in Kumagai thank you so

1056
00:50:43,190 --> 00:50:48,830
much for for watching and here's my

1057
00:50:46,670 --> 00:50:50,780
slides and my demos and my contact

1058
00:50:48,830 --> 00:50:53,299
information feel free to drop me a lot

1059
00:50:50,780 --> 00:50:54,610
in the book about como con about Holly

1060
00:50:53,300 --> 00:50:57,970
hacker about anything else

1061
00:50:54,610 --> 00:50:57,970
thank you very much

