1
00:00:02,480 --> 00:00:04,940
- Hello everyone and
welcome to the Talk Spectra,

2
00:00:04,940 --> 00:00:07,640
which is about new wireless
escalation targets.

3
00:00:07,640 --> 00:00:11,460
This is a joint work by
me, Jiska and Francesco,

4
00:00:11,460 --> 00:00:13,300
who has been working a lot with WiFi

5
00:00:13,300 --> 00:00:15,600
while I have been working
with Bluetooth in the past.

6
00:00:15,600 --> 00:00:18,340
And in this work we join our abilities

7
00:00:18,340 --> 00:00:20,033
to build a new attack scheme.

8
00:00:21,580 --> 00:00:24,930
So, the motivation of
this is as simple as this,

9
00:00:24,930 --> 00:00:28,620
I found a partial
Bluetooth RCE a while ago

10
00:00:28,620 --> 00:00:31,100
and then a bit later a
student of mine, Yang build

11
00:00:31,100 --> 00:00:34,170
a Puzzle Frankenstein which
emulates the Bluetooth chips

12
00:00:34,170 --> 00:00:38,720
and he also found a couple of
more Remote Code Executions.

13
00:00:38,720 --> 00:00:41,990
And with this, I said like,
yeah, that's a great chance,

14
00:00:41,990 --> 00:00:44,330
now we can tour the world, tell everyone,

15
00:00:44,330 --> 00:00:47,020
like we have Bluetooth
Remote Code Execution,

16
00:00:47,020 --> 00:00:50,820
take my unicorn, travel with
it and just show everyone.

17
00:00:50,820 --> 00:00:53,890
But, the thing is that
people said they are not too

18
00:00:53,890 --> 00:00:57,470
surprised about Bluetooth
Remote Code Execution because

19
00:00:57,470 --> 00:01:00,470
Bluetooth after 22 years
is really indistinguishable

20
00:01:00,470 --> 00:01:04,003
from magic and they kind of
expected that it is broken.

21
00:01:06,100 --> 00:01:08,230
And then people also told me, you know,

22
00:01:08,230 --> 00:01:10,410
there is Bluetooth RCE, there's WiFi RCE

23
00:01:10,410 --> 00:01:13,690
and WiFi RCE is much cooler because,

24
00:01:13,690 --> 00:01:16,770
first of all, Bluetooth
it's connected via UART

25
00:01:16,770 --> 00:01:18,910
and WiFi is connected with PCI express

26
00:01:18,910 --> 00:01:22,050
that is just nicer for exploitation.

27
00:01:22,050 --> 00:01:27,050
Then also, if you can pop
calc, it's a nice attack but

28
00:01:27,530 --> 00:01:30,280
if you cannot pop calc
then what kind of attack

29
00:01:30,280 --> 00:01:32,530
is a Bluetooth on chip
Remote Code Execution?

30
00:01:34,100 --> 00:01:38,340
So, I was thinking because now
the idea is of course like,

31
00:01:38,340 --> 00:01:41,960
I could try to take the
Bluetooth RCE and then break into

32
00:01:41,960 --> 00:01:43,890
the operating system all the way up.

33
00:01:43,890 --> 00:01:47,140
But, another funny attack
would be to instead attack

34
00:01:47,140 --> 00:01:50,450
the WiFi chip or maybe even the LTE chip.

35
00:01:50,450 --> 00:01:53,530
So, to break the inter
chip separation instead

36
00:01:53,530 --> 00:01:55,560
of doing the same thing
again of breaking into

37
00:01:55,560 --> 00:01:56,743
the operating system.

38
00:01:58,980 --> 00:02:02,150
And then I called Francesco
and said like, hey,

39
00:02:02,150 --> 00:02:04,570
let's build speculative transmission.

40
00:02:04,570 --> 00:02:07,840
And the idea of the attack
was that in a smartphone

41
00:02:07,840 --> 00:02:11,397
you have the same frequency
used by WiFi and Bluetooth

42
00:02:11,397 --> 00:02:15,270
and LTE has harmonics
in the same spectrum.

43
00:02:15,270 --> 00:02:19,040
And they cause interference
in such a small device.

44
00:02:19,040 --> 00:02:22,510
So they need to arbitrate
the channel access

45
00:02:22,510 --> 00:02:24,880
which means they need to actually tell,

46
00:02:24,880 --> 00:02:27,560
I'm sending a packet can
you please not send a packet

47
00:02:27,560 --> 00:02:30,110
right now and so on and
also need to take priorities

48
00:02:30,110 --> 00:02:31,030
and so on.

49
00:02:31,030 --> 00:02:34,170
And this is called a coexistence mechanism

50
00:02:34,170 --> 00:02:36,320
and it's a performance optimization.

51
00:02:36,320 --> 00:02:39,760
And of course, you could now
also instead speculatively

52
00:02:39,760 --> 00:02:43,930
transmit a packet and use
this to infer what the other

53
00:02:43,930 --> 00:02:44,810
cores are doing.

54
00:02:44,810 --> 00:02:47,110
So, this was the initial attack idea.

55
00:02:47,110 --> 00:02:49,620
In the end, it turned out to be a bit more

56
00:02:49,620 --> 00:02:53,710
of a spectrum transmission
but this is the attack scheme.

57
00:02:53,710 --> 00:02:58,020
Of course it requires a lot
of exploitation before so,

58
00:02:58,020 --> 00:03:00,390
it requires the Bluetooth
Remote Code Execution

59
00:03:00,390 --> 00:03:02,250
or WiFi Remote Code Execution

60
00:03:02,250 --> 00:03:04,410
to then escalate into the other chip.

61
00:03:04,410 --> 00:03:07,810
But the interesting part here
is, as this is a connection

62
00:03:07,810 --> 00:03:10,770
directly between the chips,
you cannot block it with

63
00:03:10,770 --> 00:03:14,840
the operating system so, there
is a very nice attack vector

64
00:03:14,840 --> 00:03:16,283
that is hard to prevent.

65
00:03:18,150 --> 00:03:20,090
And if you look into a modern iPhone

66
00:03:20,090 --> 00:03:22,090
this is what it roughly looks like.

67
00:03:22,090 --> 00:03:26,080
So, you have the Bluetooth
and the WiFi chip

68
00:03:26,080 --> 00:03:28,410
which are within the combo
chip but they still run

69
00:03:28,410 --> 00:03:31,440
on different ARM cores,
and they are connected

70
00:03:31,440 --> 00:03:33,610
via Serial Enhanced Coexistence Interface,

71
00:03:33,610 --> 00:03:35,410
this is what we are going to attack.

72
00:03:36,450 --> 00:03:41,360
The combo chip is also
interconnected with an LTE chip

73
00:03:41,360 --> 00:03:44,240
and this is using Mobile
Wireless Standards.

74
00:03:44,240 --> 00:03:46,180
And then you can also see
that the Bluetooth daemon

75
00:03:46,180 --> 00:03:48,860
has fewer rights than the WiFi daemon

76
00:03:48,860 --> 00:03:52,770
and the Bluetooth chip is
usually connected with UART,

77
00:03:52,770 --> 00:03:55,370
the newer iPhones use PCI express here.

78
00:03:55,370 --> 00:03:57,950
And now if you could
escalate between the chips

79
00:03:57,950 --> 00:04:00,550
you have newer attacks
path that become possible.

80
00:04:00,550 --> 00:04:02,280
So for example,

81
00:04:02,280 --> 00:04:04,960
I could now start from
Bluetooth over the air

82
00:04:04,960 --> 00:04:08,780
and then escalate into WiFi
and then go all the way up.

83
00:04:08,780 --> 00:04:11,070
Or I could also try to infer timings

84
00:04:11,070 --> 00:04:13,143
in between those chips and so on.

85
00:04:15,540 --> 00:04:18,840
The Spectra Impact can be
very different depending

86
00:04:18,840 --> 00:04:21,230
on how this coexistence
interface is implemented.

87
00:04:21,230 --> 00:04:24,390
So, first of all, the most
obvious one is the denial

88
00:04:24,390 --> 00:04:27,650
of service, if one core denies
transmission to another core

89
00:04:27,650 --> 00:04:29,900
but it could also be
information disclosure

90
00:04:29,900 --> 00:04:33,060
via timings or pecker types and so on.

91
00:04:33,060 --> 00:04:35,600
And, the first case
would be code execution

92
00:04:35,600 --> 00:04:37,610
and for this one you
really need to screw up

93
00:04:37,610 --> 00:04:38,733
your implementation.

94
00:04:39,870 --> 00:04:41,760
And this attack has been
first on the internet

95
00:04:41,760 --> 00:04:43,560
because of the Black Hat abstract.

96
00:04:43,560 --> 00:04:46,290
Someone start tweeting
and giving it other names.

97
00:04:46,290 --> 00:04:49,350
And I have to say I also
liked the Queer Ghost Attack

98
00:04:49,350 --> 00:04:53,320
but Spectra is like the
original name, of course,

99
00:04:53,320 --> 00:04:56,510
it's harder to find this on
the internet because Spectra

100
00:04:56,510 --> 00:04:58,183
is just a very generic route.

101
00:05:00,920 --> 00:05:04,570
And now let's go for the
Broadcom Coexistence Interface

102
00:05:04,570 --> 00:05:06,890
which we are now going to exploit.

103
00:05:06,890 --> 00:05:09,740
This is also present in
a couple of Cypress chips

104
00:05:09,740 --> 00:05:13,400
because Cypress acquired
parts of Broadcom in 2016.

105
00:05:13,400 --> 00:05:17,720
So, it's synonymous to be used
here so, don't be confused

106
00:05:17,720 --> 00:05:20,703
if I mix up Broadcom and
Cypress, it's all the same.

107
00:05:22,580 --> 00:05:25,090
Actually, Broadcom is a very nice target

108
00:05:25,090 --> 00:05:27,130
because they don't do any firmware checks.

109
00:05:27,130 --> 00:05:30,250
And no firmware checks
means that if we are able

110
00:05:30,250 --> 00:05:34,670
to reverse engineer certain
parts of the firmware then

111
00:05:34,670 --> 00:05:37,990
we can also patch it within
WiFi and within Bluetooth,

112
00:05:37,990 --> 00:05:41,160
and there are no further
checks which means that there

113
00:05:41,160 --> 00:05:44,490
is no secure boot, no
signature checking, et cetera.

114
00:05:44,490 --> 00:05:46,680
So, you still need to
understand what is going on

115
00:05:46,680 --> 00:05:51,510
to patch such a chip but
then there are no further

116
00:05:51,510 --> 00:05:54,290
security measures to prevent this.

117
00:05:54,290 --> 00:05:57,040
And those chips are in
many, many, many devices,

118
00:05:57,040 --> 00:05:59,690
so for example, all iPhones,
all MacBooks, iMacs,

119
00:05:59,690 --> 00:06:01,386
and also the older Apple Watch system,

120
00:06:01,386 --> 00:06:02,910
since the new ones have a different one,

121
00:06:02,910 --> 00:06:06,480
the Samsung Galaxy S series,
the older Google Nexus phones,

122
00:06:06,480 --> 00:06:09,100
all Raspberry Pis, a couple
of IoT devices and so on.

123
00:06:09,100 --> 00:06:12,340
So, this is a very nice
prototyping platform

124
00:06:12,340 --> 00:06:14,023
for all kinds of attacks.

125
00:06:16,570 --> 00:06:18,380
If you look into the older data sheets

126
00:06:18,380 --> 00:06:21,770
you can also find a couple of
details, still not everything,

127
00:06:21,770 --> 00:06:24,080
but the new data sheets just don't exist

128
00:06:24,080 --> 00:06:27,210
so, we need to live with what
is there, what is documented

129
00:06:27,210 --> 00:06:30,040
and what you can see here,
there's this Bluetooth chip,

130
00:06:30,040 --> 00:06:32,760
there is the WiFi chip,
they share an antenna

131
00:06:32,760 --> 00:06:36,410
so, they need to arbitrate
access onto this one.

132
00:06:36,410 --> 00:06:39,520
And then there is a lot
of stuff going on between

133
00:06:39,520 --> 00:06:42,620
those chips which we are going
to attack in the following.

134
00:06:42,620 --> 00:06:45,230
Nonetheless, they have different
ARM cores so, this one has

135
00:06:45,230 --> 00:06:48,780
an ARM Core CM3, there's
ARM Core CR4 and so on.

136
00:06:48,780 --> 00:06:51,823
So, this is still separated in some ways.

137
00:06:55,370 --> 00:06:59,410
For understanding the attacks
now we need to understand

138
00:06:59,410 --> 00:07:01,130
the Serial Enhanced Coexistence Interface

139
00:07:01,130 --> 00:07:03,490
which is used between WiFi and Bluetooth.

140
00:07:03,490 --> 00:07:06,820
It's also called ECI, so
without the serial, and GCI

141
00:07:06,820 --> 00:07:09,900
which might be Global or
Generic Coexistence Interface

142
00:07:09,900 --> 00:07:13,633
but it's all used in the
same way in the data sheets.

143
00:07:15,530 --> 00:07:17,530
To understand it, the best way

144
00:07:17,530 --> 00:07:20,660
is to actually separate
Bluetooth and WiFi.

145
00:07:20,660 --> 00:07:23,867
And in this setup you can
see that there is a Bluetooth

146
00:07:23,867 --> 00:07:25,650
and WiFI board by Cypress.

147
00:07:25,650 --> 00:07:28,540
They don't have a shared antenna
so, everything is separate.

148
00:07:28,540 --> 00:07:30,620
There are no side effects
and the only connection

149
00:07:30,620 --> 00:07:34,300
that they have is the Serial
Enhanced Coexistence Interface,

150
00:07:34,300 --> 00:07:36,700
which we can now also intercept.

151
00:07:36,700 --> 00:07:40,150
So, that means that we are
actually able to observe

152
00:07:40,150 --> 00:07:44,210
each and every signal that is
sent between those two boards.

153
00:07:44,210 --> 00:07:46,870
And there is nothing else that is going on

154
00:07:46,870 --> 00:07:48,643
that could block a transmission.

155
00:07:51,120 --> 00:07:53,540
If you look into this
in detail, first of all,

156
00:07:53,540 --> 00:07:56,030
we did the experiments of streaming

157
00:07:56,030 --> 00:07:57,780
just some music over Bluetooth.

158
00:07:57,780 --> 00:08:01,070
And then on the WiFi chip, we
did a scan for other WiFis.

159
00:08:01,070 --> 00:08:03,590
You can see a peak when you start to scan,

160
00:08:03,590 --> 00:08:05,150
actually it's two peaks.

161
00:08:05,150 --> 00:08:07,760
And then there are a couple of other peaks

162
00:08:07,760 --> 00:08:11,150
when you get the scan results
at the end of the scan.

163
00:08:11,150 --> 00:08:13,840
And what is very interesting
about this protocol

164
00:08:13,840 --> 00:08:17,327
already at this level is
that the Bluetooth and WiFi

165
00:08:17,327 --> 00:08:20,730
are sending with 3MB over
the serial interface.

166
00:08:20,730 --> 00:08:24,400
And 3MB is also the same
amount of data that is sent

167
00:08:24,400 --> 00:08:26,360
from the Bluetooth chip to the host

168
00:08:26,360 --> 00:08:28,210
to send the actual music of the stream.

169
00:08:28,210 --> 00:08:31,600
So you can imagine how
much data there is within

170
00:08:31,600 --> 00:08:33,233
the coexistence interface.

171
00:08:34,290 --> 00:08:37,430
And now you can see that
Bluetooth is within each peak

172
00:08:37,430 --> 00:08:41,410
actually sending some data
that is annotated in X here.

173
00:08:41,410 --> 00:08:44,300
And also WiFi is sending some data.

174
00:08:44,300 --> 00:08:48,450
So, each tiny peak there
really has some information

175
00:08:48,450 --> 00:08:50,400
about the task that is
running and other stuff

176
00:08:50,400 --> 00:08:52,223
that has priorities of packets.

177
00:08:53,070 --> 00:08:56,040
And in the last example, you can also see

178
00:08:56,040 --> 00:08:58,100
a Bluetooth keyboard
which has regular peaks

179
00:08:58,100 --> 00:09:01,797
that is then being sent when WiFi is idle.

180
00:09:01,797 --> 00:09:03,830
So, this is roughly what it looks like

181
00:09:03,830 --> 00:09:06,853
just to give you some
idea about this protocol.

182
00:09:09,800 --> 00:09:13,540
In the first attack, we
didn't even need to understand

183
00:09:13,540 --> 00:09:15,010
all the details of this.

184
00:09:15,010 --> 00:09:18,980
It's just a simple
reconfiguration of this interface.

185
00:09:18,980 --> 00:09:21,500
So, there are a lot, a
lot, a lot of registers

186
00:09:21,500 --> 00:09:25,750
that are mapped into
the Bluetooth ARM core

187
00:09:25,750 --> 00:09:28,300
that you can write into or read from.

188
00:09:28,300 --> 00:09:30,990
And actually, I tried to
understand all of them

189
00:09:30,990 --> 00:09:33,830
in the very beginning and
you can also do fancy stuff

190
00:09:33,830 --> 00:09:37,440
with this but I didn't
understand all of them

191
00:09:37,440 --> 00:09:39,530
and then Francesco just told me, well,

192
00:09:39,530 --> 00:09:42,020
if you don't understand
it, just try breaking it,

193
00:09:42,020 --> 00:09:44,220
just write something
in all those registers

194
00:09:44,220 --> 00:09:46,030
and see what breaks.

195
00:09:46,030 --> 00:09:48,470
And I found out when I write just Fs into

196
00:09:48,470 --> 00:09:51,920
the gci_chipcontrol, this crashes WiFi.

197
00:09:51,920 --> 00:09:55,050
And more interestingly in
this evaluation board setup

198
00:09:55,050 --> 00:09:57,740
I could even see some voltage
drop on the logic analyzer,

199
00:09:57,740 --> 00:09:59,750
this was very weird.

200
00:09:59,750 --> 00:10:03,750
And on some devices this
even causes a kernel panic

201
00:10:03,750 --> 00:10:06,610
because upon writing
to the gci_chipcontrol

202
00:10:06,610 --> 00:10:10,820
within Bluetooth, WiFi might
stop or even spam stuff

203
00:10:10,820 --> 00:10:12,330
over PCI Express and so on

204
00:10:12,330 --> 00:10:15,563
and then there are very
weird effects from this.

205
00:10:17,030 --> 00:10:19,060
I tested it on a couple of devices, so,

206
00:10:19,060 --> 00:10:23,450
starting from the Nexus 5 but
then also going all the way up

207
00:10:23,450 --> 00:10:25,620
to the newest MacBooks
and iPhones and so on,

208
00:10:25,620 --> 00:10:28,190
and the Samsung Galaxy S10, S20.

209
00:10:28,190 --> 00:10:30,930
And what you can see here
is that, first of all,

210
00:10:30,930 --> 00:10:33,990
depending on the date of
the chip you have a slightly

211
00:10:33,990 --> 00:10:37,510
different scheme but on a newest
ones you just write Fs into

212
00:10:37,510 --> 00:10:41,570
one address and already
this is sufficient to have

213
00:10:41,570 --> 00:10:43,810
a kernel panic on lot of those devices.

214
00:10:43,810 --> 00:10:46,480
On some of them it's all
just WiFi that restarts

215
00:10:46,480 --> 00:10:47,313
and that's it.

216
00:10:48,690 --> 00:10:50,800
Now, this already looks very promising

217
00:10:50,800 --> 00:10:52,490
for such a simple attack.

218
00:10:52,490 --> 00:10:55,380
And because of this we try
to build more fancy attacks

219
00:10:55,380 --> 00:10:57,020
with this primitive.

220
00:10:57,020 --> 00:10:59,920
And this is what Francesco is
now going to tell you about.

221
00:11:05,401 --> 00:11:06,780
- [Francesco] Thanks Jiska for introducing

222
00:11:06,780 --> 00:11:08,050
this part of the talk.

223
00:11:08,050 --> 00:11:11,050
Let's start describing
the Broadcom WiFi chipset.

224
00:11:11,050 --> 00:11:13,940
The last two decades it
evolved from a Soft MAC

225
00:11:13,940 --> 00:11:15,460
to a Full MAC implementation.

226
00:11:15,460 --> 00:11:17,780
And functions that were originally running

227
00:11:17,780 --> 00:11:20,700
on the Linux host at that
top are today offloaded

228
00:11:20,700 --> 00:11:22,410
by an intermediate ARM core.

229
00:11:22,410 --> 00:11:25,700
Interestingly, low-level
operations are always managed

230
00:11:25,700 --> 00:11:27,270
by the same piece of hardware,

231
00:11:27,270 --> 00:11:29,710
that did not change much in 17 years.

232
00:11:29,710 --> 00:11:32,160
No matter which WiFi chipset we are using,

233
00:11:32,160 --> 00:11:34,380
time critical operations are managed

234
00:11:34,380 --> 00:11:37,890
by the same D11 microcontroller
that coordinates PHY,

235
00:11:37,890 --> 00:11:40,610
radio frequency and DMA operations.

236
00:11:40,610 --> 00:11:42,820
Let's have a closer look to the low level.

237
00:11:42,820 --> 00:11:45,950
The D11 microcontroller
runs the microcode,

238
00:11:45,950 --> 00:11:48,410
a short piece of software
that keeps checking

239
00:11:48,410 --> 00:11:51,550
hardware conditions and
triggers a specific operations.

240
00:11:51,550 --> 00:11:53,850
We see here some code from the main loop

241
00:11:53,850 --> 00:11:57,630
that checks if the PHY started
receiving a PLCP preamble

242
00:11:57,630 --> 00:12:00,110
or if the current reception is terminated.

243
00:12:00,110 --> 00:12:03,400
In such cases, it will execute
the corresponding handlers

244
00:12:03,400 --> 00:12:05,860
that will decide what to
do with the current frame.

245
00:12:05,860 --> 00:12:08,900
This other piece of code
is extracted from the part

246
00:12:08,900 --> 00:12:11,360
that schedules the transmission
of an acknowledgement.

247
00:12:11,360 --> 00:12:14,230
We see the preparation of
the reply frame that starts

248
00:12:14,230 --> 00:12:15,820
with D4 as usual.

249
00:12:15,820 --> 00:12:19,423
The D11 tool chain was created
by Michael Busch in 2007.

250
00:12:20,400 --> 00:12:23,240
We incorporated it
inside our Nexmon project

251
00:12:23,240 --> 00:12:26,680
and we've periodically updated
it by adding new instructions

252
00:12:26,680 --> 00:12:28,530
when a new chipset is introduced.

253
00:12:28,530 --> 00:12:31,820
As a spot in the ucode in
the ARM binary blob is easy,

254
00:12:31,820 --> 00:12:34,940
we can modify it adding customized parts

255
00:12:34,940 --> 00:12:36,270
as we will see later.

256
00:12:36,270 --> 00:12:39,090
The D11 CPU coordinates many blocks.

257
00:12:39,090 --> 00:12:41,310
First of all, it controls the transmission

258
00:12:41,310 --> 00:12:44,290
and reception engines, it
manages channels access

259
00:12:44,290 --> 00:12:47,330
by scheduling transmissions
and the sites which receive

260
00:12:47,330 --> 00:12:49,850
its frames should be
pushed to the ARM core.

261
00:12:49,850 --> 00:12:52,240
It can configure with
the PHY and the radio,

262
00:12:52,240 --> 00:12:55,517
and it does so by running
the ucode that is loaded into

263
00:12:55,517 --> 00:12:59,140
the ucode memory by the ARM
firmware during initialization.

264
00:12:59,140 --> 00:13:03,390
D11 has access to an 8kB
shared memory where it keeps

265
00:13:03,390 --> 00:13:05,600
its configuration and state variables.

266
00:13:05,600 --> 00:13:08,420
And it also accesses
indirectly the ARM memory

267
00:13:08,420 --> 00:13:11,250
where packets ready for
transmissions are cued

268
00:13:11,250 --> 00:13:14,450
for deciding which packets can
be transmitted or aggregated.

269
00:13:14,450 --> 00:13:17,360
D11 is equipped with
general power post timers

270
00:13:17,360 --> 00:13:20,040
and with many different
interfaces for talking

271
00:13:20,040 --> 00:13:23,370
to other parts of the chipset
like the SECI interface.

272
00:13:23,370 --> 00:13:25,657
During the years, it turned
out to be a pretty flexible

273
00:13:25,657 --> 00:13:28,830
architecture and we use
it as a research platform

274
00:13:28,830 --> 00:13:32,290
for showcasing operations like
jamming, piggyback in schemes

275
00:13:32,290 --> 00:13:33,880
and time of flight measurements.

276
00:13:33,880 --> 00:13:37,320
Let's now talk about D11
Coexistence Interface.

277
00:13:37,320 --> 00:13:41,080
It includes quite a number of
registers and a 64-bit buffer

278
00:13:41,080 --> 00:13:43,030
for receiving messages from the Bluetooth.

279
00:13:43,030 --> 00:13:46,553
Such messages are transmitted
by Bluetooth every 1.25ms.

280
00:13:48,089 --> 00:13:50,020
It is the minimum Bluetooth
connection interval.

281
00:13:50,020 --> 00:13:52,150
They report to WiFi the timing

282
00:13:52,150 --> 00:13:54,760
and type of all Bluetooth operations.

283
00:13:54,760 --> 00:13:58,470
WiFi copies this information
inside dedicated SECI

284
00:13:58,470 --> 00:14:01,990
count down timer that
differ WiFi operations

285
00:14:01,990 --> 00:14:03,310
and prevent collisions.

286
00:14:03,310 --> 00:14:06,380
On the opposite direction
WiFi uses the Bluetooth

287
00:14:06,380 --> 00:14:08,850
transmission control register, in red,

288
00:14:08,850 --> 00:14:11,300
for granting Bluetooth
access to the chart.

289
00:14:11,300 --> 00:14:14,330
The flow of messages in
the two directions builds

290
00:14:14,330 --> 00:14:16,230
a grant reject scheme.

291
00:14:16,230 --> 00:14:19,340
As we will see in our
attacks, we use the knowledge

292
00:14:19,340 --> 00:14:22,430
we collected on such registers
for breaking such scheme.

293
00:14:22,430 --> 00:14:26,210
According to our analysis,
more than 10% of the ucode

294
00:14:26,210 --> 00:14:28,240
is dedicated to coexistence.

295
00:14:28,240 --> 00:14:31,850
As in general, many other
operations take much less code,

296
00:14:31,850 --> 00:14:35,720
we understand how much complex
is the Coexistence Interface.

297
00:14:35,720 --> 00:14:38,640
Finally, by programming
two boards for transmitting

298
00:14:38,640 --> 00:14:42,100
SECI messages when receiving
the same WiFi beacon,

299
00:14:42,100 --> 00:14:45,100
we measure it with the
help of an external FPGA,

300
00:14:45,100 --> 00:14:46,770
the jitter of the SECI line.

301
00:14:46,770 --> 00:14:50,360
It turned out to be caution
with a 200ns deviation

302
00:14:50,360 --> 00:14:52,410
which is perfect for this application.

303
00:14:52,410 --> 00:14:55,530
So, let's see how we broke
the Grant/Reject Scheme.

304
00:14:55,530 --> 00:14:58,950
We did that to see the
effects when watching a movie

305
00:14:58,950 --> 00:15:02,460
that requires to download
content over the WiFi

306
00:15:02,460 --> 00:15:04,880
and send audio to a Bluetooth headset.

307
00:15:04,880 --> 00:15:08,140
At the bottom, in green,
we see SECI grant messages

308
00:15:08,140 --> 00:15:09,770
transmitted by the WiFi.

309
00:15:09,770 --> 00:15:13,230
Bluetooth uses them for
understanding when it can transmit

310
00:15:13,230 --> 00:15:14,600
audio to the headset.

311
00:15:14,600 --> 00:15:18,240
We introduce into the ucode
a few lines for configuring

312
00:15:18,240 --> 00:15:21,340
the WiFi chipset remotely
from the air interface.

313
00:15:21,340 --> 00:15:24,610
We can hence prevent the
WiFi from sending SECI

314
00:15:24,610 --> 00:15:26,580
grant messages to Bluetooth.

315
00:15:26,580 --> 00:15:30,800
You see this happens
between 2.6s and 3.5s.

316
00:15:30,800 --> 00:15:34,060
During this interval, no more
SECI messages are transmitted.

317
00:15:34,060 --> 00:15:37,410
And in fact, we cannot hear
any sound from the headset.

318
00:15:37,410 --> 00:15:41,470
We tested this both on Nexus
5 and on on-development boards

319
00:15:41,470 --> 00:15:42,310
from Cypress.

320
00:15:42,310 --> 00:15:45,020
This experiment clearly demonstrates that

321
00:15:45,020 --> 00:15:47,830
a denial-of-service
attack from the WiFi side

322
00:15:47,830 --> 00:15:49,650
against Bluetooth is possible.

323
00:15:49,650 --> 00:15:53,130
Let's take a closer look now
at the messages that Bluetooth

324
00:15:53,130 --> 00:15:56,440
sends to WiFi and if we
can use such information

325
00:15:56,440 --> 00:15:57,273
for an attack.

326
00:15:57,273 --> 00:16:00,670
These are the SECI time
diagrams when we have a keyboard

327
00:16:00,670 --> 00:16:02,250
connected over Bluetooth.

328
00:16:02,250 --> 00:16:05,520
Depending on the keyboard,
we can observe SECI messages

329
00:16:05,520 --> 00:16:08,670
transmitted every 15ms or 30ms.

330
00:16:08,670 --> 00:16:12,200
Bluetooth sends these SECI
messages to inform WiFi

331
00:16:12,200 --> 00:16:14,660
that it is going to poll
the keyboard so that

332
00:16:14,660 --> 00:16:17,410
the WiFi defers channel access meanwhile.

333
00:16:17,410 --> 00:16:19,570
In this diagram, WiFi is idle

334
00:16:19,570 --> 00:16:22,540
so, WiFi always grants
access to Bluetooth.

335
00:16:22,540 --> 00:16:25,650
This is what happens when
somebody is actually typing

336
00:16:25,650 --> 00:16:26,770
on a keyboard.

337
00:16:26,770 --> 00:16:29,110
At the bottom, we have
the periodic sequence

338
00:16:29,110 --> 00:16:32,700
of SECI messages, on top we
have the key presses sniffed

339
00:16:32,700 --> 00:16:36,090
by Wireshark when capturing
from the Bluetooth interface.

340
00:16:36,090 --> 00:16:38,820
As we are typing with
moderate speed each key press

341
00:16:38,820 --> 00:16:41,530
is separate from the
others and we can also see

342
00:16:41,530 --> 00:16:43,540
the Bluetooth message with key release

343
00:16:43,540 --> 00:16:45,130
following each key press.

344
00:16:45,130 --> 00:16:48,310
In between, we can see the
HID data captured by Wireshark

345
00:16:48,310 --> 00:16:52,250
with a specific event ID
that represents a key press.

346
00:16:52,250 --> 00:16:54,750
Below we see SECI
messages that we filtered

347
00:16:54,750 --> 00:16:57,860
on the WiFi chipset by
selecting the same message type.

348
00:16:57,860 --> 00:17:01,240
This demonstrates that at
the WiFi side we can easily

349
00:17:01,240 --> 00:17:04,550
distinguish SECI messages
relating to key presses.

350
00:17:04,550 --> 00:17:07,130
This clearly demonstrates
that having access

351
00:17:07,130 --> 00:17:10,120
to the WiFi chipset that is
enough for measuring key press

352
00:17:10,120 --> 00:17:12,300
timings with very accurate resolution.

353
00:17:12,300 --> 00:17:15,080
And we know that in some
cases with the help of some

354
00:17:15,080 --> 00:17:17,710
artificial intelligence or
classification technique,

355
00:17:17,710 --> 00:17:20,430
this is enough for guessing
what the user is typing.

356
00:17:20,430 --> 00:17:23,600
We hence believe that without
any part further protection,

357
00:17:23,600 --> 00:17:25,590
the SECI interface can be used

358
00:17:25,590 --> 00:17:27,500
for mounting side channel attacks.

359
00:17:27,500 --> 00:17:29,260
And we request the CVE

360
00:17:29,260 --> 00:17:31,840
for reporting the
associated vulnerability.

361
00:17:31,840 --> 00:17:33,923
Jiska, the ground is yours again.

362
00:17:36,430 --> 00:17:39,330
- Thank you Francesco for the
very detailed explanations

363
00:17:39,330 --> 00:17:42,010
about the Serial Enhanced
Coexistence Interface

364
00:17:42,010 --> 00:17:43,320
and attacks on it.

365
00:17:43,320 --> 00:17:45,870
There is still one thing
mentioned in the data sheet

366
00:17:45,870 --> 00:17:49,190
which was clearly missing
which is the WLAN RAM sharing.

367
00:17:49,190 --> 00:17:52,453
And in following, we are
also going to attack this.

368
00:17:53,720 --> 00:17:55,900
I would call this effect
when you spend too much time

369
00:17:55,900 --> 00:17:59,280
looking for very fancy side
channels and dig deeper

370
00:17:59,280 --> 00:18:01,550
into all of this and try to explore them

371
00:18:01,550 --> 00:18:04,370
while there is the one
obvious thing in a data sheet

372
00:18:04,370 --> 00:18:06,050
that you just couldn't find within

373
00:18:06,050 --> 00:18:07,940
the Serial Enhanced Coexistence Interface.

374
00:18:07,940 --> 00:18:11,240
And for us this was the
WLAN RAM sharing so,

375
00:18:11,240 --> 00:18:13,780
it must be some variance
in the data sheet arrows

376
00:18:13,780 --> 00:18:17,960
just go into one direction
here from Bluetooth to WiFi.

377
00:18:17,960 --> 00:18:20,270
And we just didn't understand where it is

378
00:18:20,270 --> 00:18:23,293
and couldn't find it
for quite a long time.

379
00:18:25,000 --> 00:18:28,430
And the reason for this
is that the Cypress boards

380
00:18:28,430 --> 00:18:31,690
come with some development
kit and within this there are

381
00:18:31,690 --> 00:18:36,300
some symbol leaks but the
problem here is there's nothing

382
00:18:36,300 --> 00:18:37,670
mentioned with WLAN.

383
00:18:37,670 --> 00:18:41,490
And so, there probably is no
WLAN RAM sharing I thought,

384
00:18:41,490 --> 00:18:45,070
maybe it's just another route
for the enhanced coexistence

385
00:18:45,070 --> 00:18:49,060
mappings but then there was
also another part of symbols

386
00:18:49,060 --> 00:18:51,630
and I was able to obtain a RAM image.

387
00:18:51,630 --> 00:18:53,850
And it's not from a development
board but actually from

388
00:18:53,850 --> 00:18:57,470
a MacBook and within those
symbols there suddenly were

389
00:18:57,470 --> 00:19:00,780
a few called WLAN buff something.

390
00:19:00,780 --> 00:19:05,780
So, it looked a bit like
probably the shared RAM.

391
00:19:06,810 --> 00:19:09,130
But it routes just functions
and then I analyze those

392
00:19:09,130 --> 00:19:12,430
functions and there was one
function that was polling

393
00:19:12,430 --> 00:19:15,940
somewhere in the 0x680000 region.

394
00:19:15,940 --> 00:19:19,860
And actually, when I saw
this then I tried to read it,

395
00:19:19,860 --> 00:19:22,220
it sometimes crashes if you
don't do it in the right order

396
00:19:22,220 --> 00:19:24,700
and so on but in the
beginning of the section,

397
00:19:24,700 --> 00:19:29,700
I actually saw, wow, there is
a string 0x80211-something,

398
00:19:30,220 --> 00:19:31,570
on the device where I did this.

399
00:19:31,570 --> 00:19:34,330
And then I was like, probably
I'm already in there.

400
00:19:34,330 --> 00:19:38,540
Still to confirm it, I
instead tried writing to it.

401
00:19:38,540 --> 00:19:42,600
And when I write to this, what
happens is that quite often

402
00:19:42,600 --> 00:19:43,850
the WiFi crashes.

403
00:19:43,850 --> 00:19:46,400
So within Bluetooth, I
write into those registers

404
00:19:46,400 --> 00:19:48,500
and suddenly WiFi crashes.

405
00:19:48,500 --> 00:19:51,120
And the nice part about a
WiFi crash is that on a couple

406
00:19:51,120 --> 00:19:55,460
of devices, this is causing a
crash dump and this crash dump

407
00:19:55,460 --> 00:19:58,980
actually contains parts of the RAM image.

408
00:19:58,980 --> 00:20:02,180
So, I could write data that I
know and try to find the same

409
00:20:02,180 --> 00:20:05,650
data again to make the
mapping and find how WiFi

410
00:20:05,650 --> 00:20:07,920
and Bluetooth are mapped into each other.

411
00:20:07,920 --> 00:20:12,480
And also it revealed a
couple of function pointers.

412
00:20:12,480 --> 00:20:15,870
So, within the function pointer
table I was just overwriting

413
00:20:15,870 --> 00:20:18,270
a couple of pointers
and it turned out that

414
00:20:18,270 --> 00:20:20,330
if you're in this position
there is a pointer table

415
00:20:20,330 --> 00:20:22,710
and when I write to this I
can get the program counter

416
00:20:22,710 --> 00:20:25,290
under control so, I can write
to RAM, I can set the program

417
00:20:25,290 --> 00:20:28,640
RAM too so, I can have code execution

418
00:20:28,640 --> 00:20:31,050
and that was really amazing.

419
00:20:31,050 --> 00:20:33,610
I have a demo video for this on a MacBook.

420
00:20:33,610 --> 00:20:35,820
The mapping is slightly different
so, on the left hand side

421
00:20:35,820 --> 00:20:39,600
I use internal blue to
write assembly instructions

422
00:20:39,600 --> 00:20:41,450
because I'm just writing within a function

423
00:20:41,450 --> 00:20:44,040
and not within a function pointer.

424
00:20:44,040 --> 00:20:47,260
And then on the right hand side,
you see the WiFi crash logs

425
00:20:47,260 --> 00:20:50,180
on macOS and you can see that
I can get a program counter

426
00:20:50,180 --> 00:20:51,460
under control.

427
00:20:51,460 --> 00:20:54,140
And this is how fast this attack works so,

428
00:20:54,140 --> 00:20:56,940
just within Bluetooth I can
get code execution in WiFi.

429
00:20:59,740 --> 00:21:03,070
The interesting part here is
that I couldn't find this area

430
00:21:03,070 --> 00:21:06,460
on a Nexus 5 so, either
it's not mapped at all

431
00:21:06,460 --> 00:21:08,240
or it's mapped to a different region.

432
00:21:08,240 --> 00:21:11,170
Even though this was the
one that I initially had

433
00:21:12,224 --> 00:21:14,583
as the idea like, from this
data sheet there must be this

434
00:21:14,583 --> 00:21:17,830
WiFi RAM sharing but so
this one, I didn't find it.

435
00:21:17,830 --> 00:21:21,070
Then there are a couple
of devices where within

436
00:21:21,070 --> 00:21:25,340
the RAM dump you can even
find a 0x680000 and so on.

437
00:21:25,340 --> 00:21:28,690
So, you know that in the
firmware this is used

438
00:21:28,690 --> 00:21:31,150
and on those also the attack works.

439
00:21:31,150 --> 00:21:33,190
The fun part here is that the MacBook,

440
00:21:33,190 --> 00:21:35,700
I don't have it with me,
I just have the this dump

441
00:21:35,700 --> 00:21:38,970
so, I couldn't try it on
my own on this MacBook but

442
00:21:38,970 --> 00:21:42,900
at least I know it should work
because the symbol is there.

443
00:21:42,900 --> 00:21:45,140
And in the newest devices,

444
00:21:45,140 --> 00:21:50,140
this register is never ever
mentioned in the firmware

445
00:21:50,150 --> 00:21:51,470
but still the attack works.

446
00:21:51,470 --> 00:21:54,330
So, it's probably a feature
that has been abandoned

447
00:21:54,330 --> 00:21:57,160
and it's not longer used
but still we can use it

448
00:21:57,160 --> 00:21:59,843
for this type of attack
on all those devices.

449
00:22:03,030 --> 00:22:06,690
The even more fun part is
that sometimes I got, again,

450
00:22:06,690 --> 00:22:09,833
issues with PCI express, so why is that?

451
00:22:11,240 --> 00:22:14,110
On all those chips I had
no idea of what exactly

452
00:22:14,110 --> 00:22:16,850
I was doing so, I mean,
yes, there is the mapping

453
00:22:16,850 --> 00:22:19,760
but I first of all need
to get the chip to crash,

454
00:22:19,760 --> 00:22:23,410
to get this RAM image and then
I need to load it into IDA

455
00:22:23,410 --> 00:22:26,200
and analyze it and somehow
find a place to get

456
00:22:26,200 --> 00:22:28,140
code execution for each chip.

457
00:22:28,140 --> 00:22:30,680
And so I was just writing
certain things and then again,

458
00:22:30,680 --> 00:22:32,370
like sometimes finding a pattern again

459
00:22:32,370 --> 00:22:35,520
and when I find the pattern
like in the program counter

460
00:22:35,520 --> 00:22:37,460
then I probably have code execution.

461
00:22:37,460 --> 00:22:40,830
So, this was roughly my approach.

462
00:22:40,830 --> 00:22:44,270
And then on a couple of devices
this turned out to be a very

463
00:22:44,270 --> 00:22:47,300
efficient puzzle so, just
flipping a couple of bytes

464
00:22:47,300 --> 00:22:51,850
somewhere in the shared memory
between WiFi and Bluetooth

465
00:22:51,850 --> 00:22:56,060
was sufficient to get kernel
panics on a couple of devices.

466
00:22:56,060 --> 00:22:57,600
So, sometimes just perfect crashes

467
00:22:57,600 --> 00:23:00,050
but sometimes even kernel panics.

468
00:23:00,050 --> 00:23:02,490
And this is interesting
because there are, of course,

469
00:23:02,490 --> 00:23:06,960
also some memory areas that
are used for the PCI Express

470
00:23:06,960 --> 00:23:10,210
queue between the WiFi
chip and the host and so on

471
00:23:10,210 --> 00:23:12,850
or it might just simply
block something within

472
00:23:12,850 --> 00:23:15,370
the communication, between
the WiFi chip and the host.

473
00:23:15,370 --> 00:23:18,710
And depending on this, it
can already cause a reboot.

474
00:23:18,710 --> 00:23:23,710
So, with the super sympathizer
of just flipping some bytes

475
00:23:24,000 --> 00:23:27,480
or sending some bytes,
you can reboot devices.

476
00:23:27,480 --> 00:23:30,030
And this is a capture of this.

477
00:23:30,030 --> 00:23:33,230
I just use an iPhone 6 because
on this one, it's very fast.

478
00:23:33,230 --> 00:23:35,760
It also works on a
couple of other devices.

479
00:23:35,760 --> 00:23:38,170
And you can see first of
all, WiFi is switched off.

480
00:23:38,170 --> 00:23:40,900
So, that's on the left hand side and then

481
00:23:40,900 --> 00:23:43,133
the device is already rebooting.

482
00:23:47,780 --> 00:23:50,450
Now you might wonder what
the patch looks like.

483
00:23:50,450 --> 00:23:53,150
And I mean a lot of
this is in hardware so,

484
00:23:53,150 --> 00:23:54,760
you cannot really patch it.

485
00:23:54,760 --> 00:23:58,490
But what I have seen in a
couple of devices is that

486
00:23:58,490 --> 00:24:00,760
they are now blocking the communication.

487
00:24:00,760 --> 00:24:03,730
So, after the Bluetooth
chip is initialized

488
00:24:03,730 --> 00:24:05,460
by the Bluetooth daemon,

489
00:24:05,460 --> 00:24:10,460
the Bluetooth chip is then
blocking any read RAM commands

490
00:24:10,820 --> 00:24:14,130
or at least writing, the
reading is only blocked

491
00:24:14,130 --> 00:24:18,210
on a few devices but writing
is blocked on all newer

492
00:24:18,210 --> 00:24:20,093
chips as far as I've seen.

493
00:24:20,940 --> 00:24:25,240
And now the thing is that
this prevents at least attacks

494
00:24:25,240 --> 00:24:28,860
where the Bluetooth daemon
would try to get code execution

495
00:24:28,860 --> 00:24:31,910
within WiFi so, that's like
this path but what is not

496
00:24:31,910 --> 00:24:35,220
prevented by this is if you
have remote code execution

497
00:24:35,220 --> 00:24:38,850
over the air and then escalate into WiFi

498
00:24:38,850 --> 00:24:41,939
or if you just know that
the timing between the WiFi

499
00:24:41,939 --> 00:24:45,640
and Bluetooth is a fixed
one by now and use the known

500
00:24:45,640 --> 00:24:48,580
timing which is not random
because of some things

501
00:24:48,580 --> 00:24:51,030
sent over the air but
actually like predictable

502
00:24:51,030 --> 00:24:53,250
because of coexistence schemes.

503
00:24:53,250 --> 00:24:56,220
This might also be a thing
that's exploitable here.

504
00:24:56,220 --> 00:24:58,980
But at least they added
this to the attack model

505
00:24:58,980 --> 00:25:02,370
that suddenly Bluetooth
might be able to attack WiFi.

506
00:25:02,370 --> 00:25:04,400
And because of this,
this part is now blocked

507
00:25:04,400 --> 00:25:06,400
because you can block this quite easily.

508
00:25:09,090 --> 00:25:11,740
And now, I mentioned in the
beginning that this might

509
00:25:11,740 --> 00:25:14,030
also apply to other chips.

510
00:25:14,030 --> 00:25:17,233
And now the question here
is like, what are the chips?

511
00:25:18,340 --> 00:25:21,230
If you look into the
Bluetooth specification

512
00:25:21,230 --> 00:25:23,350
and read it backwards because, I mean,

513
00:25:23,350 --> 00:25:25,910
I'm a Reverse Engineer so I
also read the specifications

514
00:25:25,910 --> 00:25:29,703
backwards obviously, what
you can see on the last page

515
00:25:29,703 --> 00:25:31,910
is the Bluetooth logo and
on the second last page

516
00:25:31,910 --> 00:25:34,803
it already starts with the
mobile wireless standards.

517
00:25:35,940 --> 00:25:39,220
I guess it's another serial protocol

518
00:25:39,220 --> 00:25:43,100
which is used between
WiFi and Bluetooth chips

519
00:25:43,100 --> 00:25:45,130
or Bluetooth chips and LTE.

520
00:25:45,130 --> 00:25:49,090
And they are also sending
activity information

521
00:25:49,090 --> 00:25:50,700
and so on over UART.

522
00:25:50,700 --> 00:25:52,630
And then there is another
thing that goes via

523
00:25:52,630 --> 00:25:56,240
the operating system to
initially configure it.

524
00:25:56,240 --> 00:25:58,810
And this one is also used on iPhones.

525
00:25:58,810 --> 00:26:01,590
So, I saw it on an iPhone
so probably is also tech

526
00:26:01,590 --> 00:26:02,590
that belong to them.

527
00:26:03,950 --> 00:26:05,560
And because everyone has some

528
00:26:05,560 --> 00:26:07,750
proprietary coexistence features,

529
00:26:07,750 --> 00:26:10,680
we asked Broadcom if we can
also include other manufacturers

530
00:26:10,680 --> 00:26:12,800
in the responsible disclosure process.

531
00:26:12,800 --> 00:26:14,700
And they said, yes we can.

532
00:26:14,700 --> 00:26:18,420
And so we informed a couple of
those who at least mentioned

533
00:26:18,420 --> 00:26:21,700
that they have coexistence in
their data sheets and so on.

534
00:26:21,700 --> 00:26:24,380
And some of their responses
were like, that this doesn't

535
00:26:24,380 --> 00:26:29,070
really apply to them because
there are some chips that have

536
00:26:29,070 --> 00:26:32,710
just one core that handles
multiple wireless protocols.

537
00:26:32,710 --> 00:26:36,640
So by definition, that
wouldn't be a attackable

538
00:26:36,640 --> 00:26:40,090
in the sense of, you already
have code execution either way.

539
00:26:40,090 --> 00:26:42,440
So, a Bluetooth Remote Code
Execution is automatically

540
00:26:42,440 --> 00:26:44,620
a WiFi a Remote Code Execution

541
00:26:44,620 --> 00:26:48,500
but of course there might
be other sections like,

542
00:26:48,500 --> 00:26:52,340
I can now from the timing
of WiFi frames that I send

543
00:26:52,340 --> 00:26:53,270
on an upload

544
00:26:53,270 --> 00:26:58,270
maybe predict how the typing
on a keyboard or something was

545
00:26:59,320 --> 00:27:02,310
for example or how the
activity was on the other

546
00:27:02,310 --> 00:27:03,330
via this core.

547
00:27:03,330 --> 00:27:05,960
And this might be something
that could still be possible

548
00:27:05,960 --> 00:27:09,500
even though the code
execution is kind of by design

549
00:27:09,500 --> 00:27:12,350
that cannot be prevented,
there might be further attacks.

550
00:27:14,670 --> 00:27:16,390
And as a summary, so, what we reached is,

551
00:27:16,390 --> 00:27:18,610
if you have a Bluetooth
remote code execution

552
00:27:18,610 --> 00:27:22,370
on a Broadcom chip, you can
now cause driver kernel panics

553
00:27:22,370 --> 00:27:24,760
get information disclosure about WiFi

554
00:27:24,760 --> 00:27:27,030
and even code execution within WiFi.

555
00:27:27,030 --> 00:27:28,343
And the other way round if you have

556
00:27:28,343 --> 00:27:30,930
a WiFi Remote Code
Execution you can now do

557
00:27:30,930 --> 00:27:33,800
denial-of-service against
Bluetooth and also get information

558
00:27:33,800 --> 00:27:35,200
disclosure within Bluetooth.

559
00:27:37,700 --> 00:27:40,600
If you have further questions
there will be a Q&A session.

560
00:27:40,600 --> 00:27:42,590
And you can of course,
also reach me on Twitter

561
00:27:42,590 --> 00:27:45,810
or you can write an email
to Francesco and me.

562
00:27:45,810 --> 00:27:46,860
Thanks for listening.

