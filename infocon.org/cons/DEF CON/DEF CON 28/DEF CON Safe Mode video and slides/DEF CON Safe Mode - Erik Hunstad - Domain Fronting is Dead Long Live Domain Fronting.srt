1
00:00:01,910 --> 00:00:04,540
- Hello, everyone and welcome
to Domain Fronting is Dead,

2
00:00:04,540 --> 00:00:08,870
Long Live Domain Fronting,
using TLS 1.3 to evade sensors,

3
00:00:08,870 --> 00:00:12,130
bypass network defenses,
and blend in with the noise.

4
00:00:12,130 --> 00:00:13,190
My name is Erik Hunstad

5
00:00:13,190 --> 00:00:16,290
and I'm the CTO and adversary
emulation lead at SixGen,

6
00:00:16,290 --> 00:00:17,990
a full spectrum cyber security company

7
00:00:17,990 --> 00:00:19,880
based in Annapolis, Maryland.

8
00:00:19,880 --> 00:00:22,750
Today, I'm gonna go over
what domain fronting is,

9
00:00:22,750 --> 00:00:25,320
including HTTP and HTTPS basics.

10
00:00:25,320 --> 00:00:28,980
I'll talk about TLS 1.3 and
encrypted server name indication

11
00:00:28,980 --> 00:00:31,210
and how this can be
used for domain hiding.

12
00:00:31,210 --> 00:00:34,160
I'll show some demos of this
in action from basic bypasses

13
00:00:34,160 --> 00:00:37,340
to bypassing the enterprise
TLS decrypting firewall.

14
00:00:37,340 --> 00:00:39,610
And finally, I'll talk about
some ideas for defenders

15
00:00:39,610 --> 00:00:42,490
who may want to detect
this in their environment.

16
00:00:42,490 --> 00:00:44,270
Domain Fronting 101.

17
00:00:44,270 --> 00:00:46,610
If we're gonna discuss a new
method for domain fronting,

18
00:00:46,610 --> 00:00:48,760
let's all get up to speed
on what domain fronting is,

19
00:00:48,760 --> 00:00:51,510
why it works, and what happened to it.

20
00:00:51,510 --> 00:00:53,090
Like many things in security,

21
00:00:53,090 --> 00:00:54,230
to understand the cool stuff,

22
00:00:54,230 --> 00:00:55,950
you have to dig into the basics.

23
00:00:55,950 --> 00:00:57,430
To understand domain fronting,

24
00:00:57,430 --> 00:01:01,010
we really need to
understand HTTP and HTTPS.

25
00:01:01,010 --> 00:01:02,630
Specifically, we'll be focused

26
00:01:02,630 --> 00:01:05,500
on the server name indication,
which is a special extension

27
00:01:05,500 --> 00:01:07,500
added to TLS that allows multiple sites

28
00:01:07,500 --> 00:01:09,381
to be hosted on the same server.

29
00:01:09,381 --> 00:01:12,550
For TLS 1.3, this
extension can be encrypted

30
00:01:12,550 --> 00:01:14,940
and combined with encrypted secure DNS.

31
00:01:14,940 --> 00:01:18,113
We can do domain fronting
2.0 or domain hiding.

32
00:01:19,440 --> 00:01:21,580
Okay, let's start with HTTP.

33
00:01:21,580 --> 00:01:23,220
I'll skip over the super low level stuff

34
00:01:23,220 --> 00:01:24,890
as it's not relevant here.

35
00:01:24,890 --> 00:01:28,090
The first external request
involved in an HTTP connection

36
00:01:28,090 --> 00:01:29,750
is a DNS request.

37
00:01:29,750 --> 00:01:32,930
This DNS request gets sent
out un-encrypted via UDP

38
00:01:32,930 --> 00:01:34,083
to port 53.

39
00:01:35,300 --> 00:01:38,830
The DNS server responds
also unencrypted via UDP,

40
00:01:38,830 --> 00:01:41,260
with an answer that
contains the IP address

41
00:01:41,260 --> 00:01:43,700
of the domain from the request.

42
00:01:43,700 --> 00:01:45,230
Now that the user's computer knows

43
00:01:45,230 --> 00:01:46,680
where the domain is hosted,

44
00:01:46,680 --> 00:01:50,010
it can issue an HTTP
request to that IP address

45
00:01:50,010 --> 00:01:51,350
with the host header indicating

46
00:01:51,350 --> 00:01:53,750
the domain the user wishes to browse.

47
00:01:53,750 --> 00:01:57,360
This request uses TCP,
but it's un-encrypted.

48
00:01:57,360 --> 00:01:59,250
The web server responds with content.

49
00:01:59,250 --> 00:02:01,540
In this case, some simple HTML.

50
00:02:01,540 --> 00:02:03,510
This was fine for the
early days of the internet

51
00:02:03,510 --> 00:02:05,840
when it was just a few
research institutions.

52
00:02:05,840 --> 00:02:08,280
But as soon as people wanted
to conduct business online,

53
00:02:08,280 --> 00:02:10,750
the obvious issues with
completely un-encrypted traffic

54
00:02:10,750 --> 00:02:12,610
had to be fixed.

55
00:02:12,610 --> 00:02:15,280
Plus, without encryption,
all your data is free game

56
00:02:15,280 --> 00:02:17,270
for any number of actors
that are positioned

57
00:02:17,270 --> 00:02:19,350
between you and the web server.

58
00:02:19,350 --> 00:02:21,810
HTTPS was the answer to this problem,

59
00:02:21,810 --> 00:02:25,040
and it starts off the same
way with the DNS request.

60
00:02:25,040 --> 00:02:27,450
The DNS request and response
are still un-encrypted

61
00:02:27,450 --> 00:02:30,310
when using HTTPS, unless
you use a different system,

62
00:02:30,310 --> 00:02:31,960
which we'll talk about later on.

63
00:02:31,960 --> 00:02:34,440
Here's why HTTPS is different.

64
00:02:34,440 --> 00:02:37,340
The connection to the server
starts with a TLS connection,

65
00:02:37,340 --> 00:02:39,480
specifically, a ClientHello.

66
00:02:39,480 --> 00:02:42,270
In this packet, the server
name extension is used to tell

67
00:02:42,270 --> 00:02:45,250
the web server which website
the user's requesting.

68
00:02:45,250 --> 00:02:47,810
This allows the web server to
return the proper certificate

69
00:02:47,810 --> 00:02:48,950
for that site.

70
00:02:48,950 --> 00:02:52,130
The server returns the certificate
and a ServerHello packet.

71
00:02:52,130 --> 00:02:53,230
And then the client and server

72
00:02:53,230 --> 00:02:55,600
can agree on which
encryption algorithms to use

73
00:02:55,600 --> 00:02:58,350
and exchange session keys.

74
00:02:58,350 --> 00:03:00,350
All traffic after this is encrypted,

75
00:03:00,350 --> 00:03:03,380
but both the ClientHello and
ServerHello are un-encrypted,

76
00:03:03,380 --> 00:03:05,300
which leaks to the domain and certificate

77
00:03:05,300 --> 00:03:08,510
to anyone between the
client and the web server.

78
00:03:08,510 --> 00:03:10,260
And we know there are
plenty of organizations

79
00:03:10,260 --> 00:03:11,683
interested in that data.

80
00:03:12,590 --> 00:03:15,540
With the basics covered, let's
talk about domain fronting.

81
00:03:15,540 --> 00:03:16,900
Domain fronting as a technique

82
00:03:16,900 --> 00:03:19,070
to get around network defenses or sensors

83
00:03:19,070 --> 00:03:20,900
by connecting to an approved server

84
00:03:20,900 --> 00:03:24,590
while hiding the true
destination of the HTTPS request.

85
00:03:24,590 --> 00:03:26,950
One of the biggest
restrictions of domain fronting

86
00:03:26,950 --> 00:03:29,890
is that the fronted domain and
the true destination domain

87
00:03:29,890 --> 00:03:32,600
must be hosted by the
same service provider.

88
00:03:32,600 --> 00:03:35,160
Typically, this is a
content delivery network.

89
00:03:35,160 --> 00:03:37,410
So how does domain
fronting work in practice?

90
00:03:37,410 --> 00:03:40,700
Well, it starts with the
same DNS lookup as before.

91
00:03:40,700 --> 00:03:43,050
And the TLS handshake is the same as well.

92
00:03:43,050 --> 00:03:45,520
However, in the handshake,
the client connects

93
00:03:45,520 --> 00:03:48,900
to the front domain, not
the true destination domain.

94
00:03:48,900 --> 00:03:51,540
Once the TLS handshake is
complete with the front domain,

95
00:03:51,540 --> 00:03:53,150
the fronting begins.

96
00:03:53,150 --> 00:03:56,350
The client sends an HTTP
request to the front domain

97
00:03:56,350 --> 00:03:58,720
wrapped in TLS, but with a Host header

98
00:03:58,720 --> 00:04:01,100
of the true destination domain.

99
00:04:01,100 --> 00:04:03,730
When the content delivery
provider receives this request

100
00:04:03,730 --> 00:04:05,220
and inspects the Host header,

101
00:04:05,220 --> 00:04:07,110
determines that it's
for a different domain

102
00:04:07,110 --> 00:04:08,650
hosted on the same provider

103
00:04:08,650 --> 00:04:10,310
and dutifully forwards the request

104
00:04:10,310 --> 00:04:12,600
to the true destination domain.

105
00:04:12,600 --> 00:04:14,690
You can think of domain
fronting like a postcard

106
00:04:14,690 --> 00:04:16,120
inside an envelope.

107
00:04:16,120 --> 00:04:17,400
On the outside of the envelope,

108
00:04:17,400 --> 00:04:20,900
the client writes the address
of the CDN, but on the inside,

109
00:04:20,900 --> 00:04:23,940
the true destination
domain is on the postcard.

110
00:04:23,940 --> 00:04:26,410
The network filters or
sensors are like mailman

111
00:04:26,410 --> 00:04:28,180
who can see the outside of the envelope

112
00:04:28,180 --> 00:04:31,330
and they deliver it since the
CDN is an approved address.

113
00:04:31,330 --> 00:04:33,750
However, when the CDN opens the letter,

114
00:04:33,750 --> 00:04:34,810
they deliver the postcard

115
00:04:34,810 --> 00:04:37,230
to the true destination internally.

116
00:04:37,230 --> 00:04:41,270
This was working well on all
major CDNs until April of 2018

117
00:04:41,270 --> 00:04:43,610
when the Russian government
put pressure on cloud providers

118
00:04:43,610 --> 00:04:46,460
to stop it, since the popular
messaging app, Telegram,

119
00:04:46,460 --> 00:04:49,770
was using both Google and
AWS for domain fronting.

120
00:04:49,770 --> 00:04:50,840
Both Google and Amazon

121
00:04:50,840 --> 00:04:52,480
stated that the reasons were technical

122
00:04:52,480 --> 00:04:54,950
and domain fronting was
either never supported

123
00:04:54,950 --> 00:04:57,060
or a violation of terms of service,

124
00:04:57,060 --> 00:05:00,090
and other providers follow
suit to include Cloudflare.

125
00:05:00,090 --> 00:05:03,530
Microsoft's Azure platform
still allows domain fronting

126
00:05:03,530 --> 00:05:07,090
for now as do a few other smaller CDNs.

127
00:05:07,090 --> 00:05:08,850
Domain fronting is a great censorship

128
00:05:08,850 --> 00:05:12,260
or network bypass technique,
but it has some major problems.

129
00:05:12,260 --> 00:05:14,890
For any network censorship
bypass to be effective,

130
00:05:14,890 --> 00:05:17,030
it has to be really painful to block.

131
00:05:17,030 --> 00:05:18,980
And since the largest
provider shut it down,

132
00:05:18,980 --> 00:05:21,140
it lacks the punch that it once had.

133
00:05:21,140 --> 00:05:23,030
Also, the true destination domain

134
00:05:23,030 --> 00:05:25,890
has to be hosted on the same
service as the front domain,

135
00:05:25,890 --> 00:05:27,630
which limits the potential front sites

136
00:05:27,630 --> 00:05:30,890
and imposes costs on anyone
wishing to set up fronting.

137
00:05:30,890 --> 00:05:32,240
With the background out of the way,

138
00:05:32,240 --> 00:05:36,370
we can talk about TLS 1.3,
encrypted server name indication,

139
00:05:36,370 --> 00:05:38,760
and what can we call domain hiding.

140
00:05:38,760 --> 00:05:41,250
First, let's talk about TLS 1.3.

141
00:05:41,250 --> 00:05:43,680
It's seeing steady growth
on the internet today.

142
00:05:43,680 --> 00:05:45,860
This is data from Qualys SSL labs,

143
00:05:45,860 --> 00:05:49,140
which test the most popular 150,000 sites.

144
00:05:49,140 --> 00:05:51,880
As you can see, TLS 1.3 is on the rise

145
00:05:51,880 --> 00:05:54,567
and it's supported by 31.7% of those sites

146
00:05:54,567 --> 00:05:55,943
tested last month.

147
00:05:57,010 --> 00:06:01,470
Cloudflare is seeing 59% of
all traffic using TLS 1.3,

148
00:06:01,470 --> 00:06:03,930
again, showing a steady increase.

149
00:06:03,930 --> 00:06:07,340
Before we dig into the
mechanics of a TLS 1.3 handshake

150
00:06:07,340 --> 00:06:11,250
with ESNI, we first have
to secure the DNS process.

151
00:06:11,250 --> 00:06:14,270
If a network defender or sensor
can see our DNS requests,

152
00:06:14,270 --> 00:06:16,100
they can easily be blocked.

153
00:06:16,100 --> 00:06:19,210
Also, secure DNS is a cornerstone of ESNI,

154
00:06:19,210 --> 00:06:20,730
which we'll see in a moment.

155
00:06:20,730 --> 00:06:23,110
The first solution is
to simply wrap DNS query

156
00:06:23,110 --> 00:06:24,680
in a TLS connection.

157
00:06:24,680 --> 00:06:26,880
To make things even more
difficult for network defenders

158
00:06:26,880 --> 00:06:30,790
or sensors, DNS via
HTTPS is a newer standard

159
00:06:30,790 --> 00:06:32,790
that is seeing more widespread adoption.

160
00:06:33,910 --> 00:06:36,680
Once we have an encrypted
way to perform DNS queries,

161
00:06:36,680 --> 00:06:39,560
we can use this to retrieve
a public key for domain,

162
00:06:39,560 --> 00:06:41,840
which we can use to
encrypt the server name

163
00:06:41,840 --> 00:06:43,850
in the ClientHello packet.

164
00:06:43,850 --> 00:06:45,600
In this screenshot from Wireshark,

165
00:06:45,600 --> 00:06:50,001
you can see the
encrypted_server_name, TLS extension,

166
00:06:50,001 --> 00:06:51,653
and the encrypted SNI value,

167
00:06:51,653 --> 00:06:54,200
this is just an encrypted hex string,

168
00:06:54,200 --> 00:06:57,060
no longer can defenders
use the server name value

169
00:06:57,060 --> 00:06:59,453
to block traffic based
on a plain text value.

170
00:07:00,400 --> 00:07:03,310
A TLS. 1.3 connection with ESNI

171
00:07:03,310 --> 00:07:05,210
relies on having the server's public key

172
00:07:05,210 --> 00:07:08,000
in order to encrypt the server
name in the ClientHello.

173
00:07:08,000 --> 00:07:10,040
And the current standard
for how to get this key

174
00:07:10,040 --> 00:07:13,970
is to use DNS and query
the _esni text record

175
00:07:13,970 --> 00:07:14,833
for that domain.

176
00:07:15,820 --> 00:07:19,360
This request returns a
base64 encoded public key.

177
00:07:19,360 --> 00:07:21,500
The client can use to derive a session key

178
00:07:21,500 --> 00:07:23,340
that encrypts the server name.

179
00:07:23,340 --> 00:07:25,710
Providers that support
this should rotate this key

180
00:07:25,710 --> 00:07:28,310
to provide some forward secrecy.

181
00:07:28,310 --> 00:07:30,850
Cloudflare, for example,
rotates this key every hour,

182
00:07:30,850 --> 00:07:32,520
but allows a few hours of buffer

183
00:07:32,520 --> 00:07:34,590
in case a client has a slightly stale key

184
00:07:34,590 --> 00:07:36,863
from a previous request or from caching.

185
00:07:38,280 --> 00:07:40,940
Armed with the server's ESNI public key,

186
00:07:40,940 --> 00:07:43,610
the client drives a
session key and uses that

187
00:07:43,610 --> 00:07:46,260
to encrypt the server name
and sends the ClientHello.

188
00:07:47,530 --> 00:07:49,690
The server has the
corresponding private key

189
00:07:49,690 --> 00:07:51,500
and can drive the same session key,

190
00:07:51,500 --> 00:07:53,440
which it uses to decrypt the server name

191
00:07:53,440 --> 00:07:56,550
and performs the same
steps as standard TLS.

192
00:07:56,550 --> 00:07:58,810
The session key generation
ensures that the key

193
00:07:58,810 --> 00:08:00,980
is tied to the session that generated it

194
00:08:00,980 --> 00:08:02,633
and prevents replay attacks.

195
00:08:03,760 --> 00:08:07,630
Another difference between
TLS 1.3 and previous versions

196
00:08:07,630 --> 00:08:10,970
is that the certificate returned
by the server is encrypted.

197
00:08:10,970 --> 00:08:13,830
This is possible because in TLS 1.3,

198
00:08:13,830 --> 00:08:16,870
the ClientHello includes a
list of supported ciphers.

199
00:08:16,870 --> 00:08:18,540
And the client also makes a guess

200
00:08:18,540 --> 00:08:20,280
as to which key agreement algorithm

201
00:08:20,280 --> 00:08:21,880
the server's gonna choose.

202
00:08:21,880 --> 00:08:25,010
And it preemptively sends a
key share for that algorithm.

203
00:08:25,010 --> 00:08:28,250
So all the plaintext portions
of HTTPS we saw before

204
00:08:28,250 --> 00:08:29,500
have been mitigated.

205
00:08:29,500 --> 00:08:31,150
However, there's still weak spots

206
00:08:31,150 --> 00:08:32,570
where sensors or network defenders

207
00:08:32,570 --> 00:08:33,870
could stop the connection.

208
00:08:35,050 --> 00:08:38,520
Even if the DNS request
itself is encrypted inside

209
00:08:38,520 --> 00:08:41,140
either TLS or HTTPS,

210
00:08:41,140 --> 00:08:43,940
the data returned by a
resolver may be poisoned.

211
00:08:43,940 --> 00:08:46,470
Imagine a scenario where
a country or enterprise

212
00:08:46,470 --> 00:08:50,100
returns their own key
for all _esni requests,

213
00:08:50,100 --> 00:08:53,245
no matter the domain, to
enable man-in-the-middle.

214
00:08:53,245 --> 00:08:56,330
DNSSEC solves this problem
by signing the record set

215
00:08:56,330 --> 00:08:58,740
and allowing the chain
of trust to be checked.

216
00:08:58,740 --> 00:09:01,370
The details of DNSSEC are
outside the scope of this talk,

217
00:09:01,370 --> 00:09:03,880
but I encourage you to check it out.

218
00:09:03,880 --> 00:09:06,760
But what if encrypted DNS
is completely blocked?

219
00:09:06,760 --> 00:09:08,810
The solution here is to
bootstrap the connection

220
00:09:08,810 --> 00:09:12,340
by pre-loading the current
ESNI keys by some other means.

221
00:09:12,340 --> 00:09:14,250
Maybe encrypted DNS is blocked,

222
00:09:14,250 --> 00:09:16,580
but what if I have a script
that updates a GitHub gist

223
00:09:16,580 --> 00:09:18,700
with the current keys every hour?

224
00:09:18,700 --> 00:09:21,640
Or you could just bake the
keys directly into your binary

225
00:09:21,640 --> 00:09:22,930
if you know what's gonna be executed

226
00:09:22,930 --> 00:09:24,193
in the next hour or two.

227
00:09:25,160 --> 00:09:27,610
Okay, let's say we get a valid ESNI key,

228
00:09:27,610 --> 00:09:28,650
but the IP address

229
00:09:28,650 --> 00:09:31,100
of the server we wanna
connect to is blocked.

230
00:09:31,100 --> 00:09:33,190
The IP may be shared with other sites,

231
00:09:33,190 --> 00:09:34,760
but it doesn't have to be.

232
00:09:34,760 --> 00:09:37,410
Is there a way to route from
arbitrary domains and IPs

233
00:09:37,410 --> 00:09:40,010
to our true destination domain and IP?

234
00:09:40,010 --> 00:09:42,660
The answer is no, but let's
see how close we can get.

235
00:09:43,530 --> 00:09:45,970
So far, I haven't introduced anything new,

236
00:09:45,970 --> 00:09:47,470
but we have covered a lot of ground

237
00:09:47,470 --> 00:09:49,880
and identified potential
issues and solutions

238
00:09:49,880 --> 00:09:53,890
around domain hiding
with TLS 1.3 and ESNI.

239
00:09:53,890 --> 00:09:56,390
Let's tackle that last
point and get around IP

240
00:09:56,390 --> 00:09:57,533
or domain blocks.

241
00:09:59,230 --> 00:10:02,840
We'll do this by leveraging
the world's largest CDN.

242
00:10:02,840 --> 00:10:06,690
Cloudflare was founded in 2009
and has had explosive growth.

243
00:10:06,690 --> 00:10:08,700
It's now the world's largest CDN,

244
00:10:08,700 --> 00:10:10,580
with the most internet exchange points

245
00:10:10,580 --> 00:10:12,950
as well as being an
authoritative DNS server

246
00:10:12,950 --> 00:10:15,140
hosting over 26 million domains.

247
00:10:15,140 --> 00:10:18,260
Cloudflare is on the forefront
of internet technology

248
00:10:18,260 --> 00:10:23,260
and supports TLS 1.3, ESNI,
Websockets, QUIC and DNSSEC.

249
00:10:25,000 --> 00:10:27,710
This new technique, which
I'm calling domain hiding,

250
00:10:27,710 --> 00:10:30,320
accomplishes the same
goals as domain fronting,

251
00:10:30,320 --> 00:10:32,360
but uses different technologies.

252
00:10:32,360 --> 00:10:36,580
A TLS 1.3 connection with an
ESNI of the true destination

253
00:10:36,580 --> 00:10:41,080
is made to any Cloudflare IP
and the underlying HTTP request

254
00:10:41,080 --> 00:10:44,460
also has a host header
of the true destination.

255
00:10:44,460 --> 00:10:48,140
This enables any Cloudflare
owned IP to act as a front

256
00:10:48,140 --> 00:10:51,120
for any domain hosted by Cloudflare DNS.

257
00:10:51,120 --> 00:10:54,130
This technique was first shown
to be possible by Robin Wood.

258
00:10:54,130 --> 00:10:55,843
So props to him for the discovery.

259
00:10:57,080 --> 00:10:59,430
Today, I'm releasing noctilucent,

260
00:10:59,430 --> 00:11:03,870
a project that enables ESNI
and goes crypto/tls library,

261
00:11:03,870 --> 00:11:07,070
as well as exposes two
additional configuration options,

262
00:11:07,070 --> 00:11:10,120
ESNIServerName and PreserveSNI.

263
00:11:10,120 --> 00:11:12,070
It can be used by any project currently

264
00:11:12,070 --> 00:11:14,710
using the standard crypto/tls library,

265
00:11:14,710 --> 00:11:16,670
as it's backwards compatible.

266
00:11:16,670 --> 00:11:19,300
It comes with a demo client
application that allows you

267
00:11:19,300 --> 00:11:22,680
to control just about every
part of the TLS connection,

268
00:11:22,680 --> 00:11:25,140
as well as the HTTP GET request.

269
00:11:25,140 --> 00:11:28,840
So you can play with what's
possible using this technique.

270
00:11:28,840 --> 00:11:32,130
It also supports Websockets
and through the magic of Go,

271
00:11:32,130 --> 00:11:34,650
it compiles cross-platform
to a single binary

272
00:11:34,650 --> 00:11:35,993
with no dependencies.

273
00:11:37,430 --> 00:11:40,160
Here's what a standard TLS 1.3 connection

274
00:11:40,160 --> 00:11:42,070
looks like with noctilucent.

275
00:11:42,070 --> 00:11:44,640
We've specified the TLS host in red,

276
00:11:44,640 --> 00:11:46,890
the server name indication in yellow,

277
00:11:46,890 --> 00:11:49,990
and the HTTP Host header in green.

278
00:11:49,990 --> 00:11:51,870
The output shows what we expect.

279
00:11:51,870 --> 00:11:56,190
There's no ESNI, the SNI
is set to cloudflare.com.

280
00:11:56,190 --> 00:11:59,730
We're connecting to
cloudflare.com on port 443.

281
00:11:59,730 --> 00:12:01,550
And our GET request to cloudflare.com

282
00:12:01,550 --> 00:12:05,293
returns the expected 301
response, nothing fancy yet.

283
00:12:07,000 --> 00:12:10,640
Let's enable ESNI and
set the ESNI server name,

284
00:12:10,640 --> 00:12:13,940
everything is the same as the
normal TLS. 1.3 connection

285
00:12:13,940 --> 00:12:15,690
we looked at on the last slide,

286
00:12:15,690 --> 00:12:20,010
except this time the ESNI
value is set to cloudflare.com

287
00:12:20,010 --> 00:12:22,260
and there is no standard SNI.

288
00:12:22,260 --> 00:12:25,333
Progress, but no fronting
or domain hiding quite yet.

289
00:12:26,440 --> 00:12:28,637
Now I'll change this, the ESNI server name

290
00:12:28,637 --> 00:12:32,440
and HTTP host header
to a domain we control.

291
00:12:32,440 --> 00:12:35,850
In this case, defcon28.hackthis.computer

292
00:12:35,850 --> 00:12:39,320
But leave the TLS host as cloudflare.com.

293
00:12:39,320 --> 00:12:40,580
Notice that this connection

294
00:12:40,580 --> 00:12:44,450
is still going to cloudflare.com,
but the HTTP request

295
00:12:44,450 --> 00:12:47,900
successfully goes to
defcon28.hackthis.computer,

296
00:12:47,900 --> 00:12:50,290
which returns Hello DEF CON!

297
00:12:50,290 --> 00:12:52,630
To anyone between this
host and Cloudflare,

298
00:12:52,630 --> 00:12:55,720
it appears to be a TLS
connection to cloudflare.com.

299
00:12:55,720 --> 00:12:57,820
We've successfully achieved domain hiding.

300
00:12:59,430 --> 00:13:01,000
Now the fun begins.

301
00:13:01,000 --> 00:13:04,620
Here we send an ESNI and standard SNI

302
00:13:04,620 --> 00:13:07,770
where the standard SNI is cloudflare.com.

303
00:13:07,770 --> 00:13:10,490
Because Cloudflare
ignores the standard SNI

304
00:13:10,490 --> 00:13:14,760
when an encrypted SNI is used,
we can set it to anything.

305
00:13:14,760 --> 00:13:17,270
The HTTP connection works as before.

306
00:13:17,270 --> 00:13:20,600
And this time, anyone between
this host and Cloudflare

307
00:13:20,600 --> 00:13:23,110
looking at SNI data thinks
that this connection

308
00:13:23,110 --> 00:13:24,810
is going to cloudflare.com.

309
00:13:24,810 --> 00:13:26,950
In addition to the
underlying TLS connection

310
00:13:26,950 --> 00:13:29,513
actually connecting to
a cloudflare.com IP.

311
00:13:30,750 --> 00:13:32,550
What I've demonstrated is the ability

312
00:13:32,550 --> 00:13:35,550
to arbitrarily front or hide any IP

313
00:13:35,550 --> 00:13:38,840
behind a domain that is using
DNS provided by Cloudflare.

314
00:13:38,840 --> 00:13:40,850
The true destination IP doesn't have

315
00:13:40,850 --> 00:13:43,850
to be a Cloudflare worker
or other Cloudflare service.

316
00:13:43,850 --> 00:13:47,000
In fact, all the examples today are IPs

317
00:13:47,000 --> 00:13:49,210
hosted by DigitalOcean.

318
00:13:49,210 --> 00:13:52,470
Best of all, the requirements
to sign up for Cloudflare DNS

319
00:13:52,470 --> 00:13:54,163
are minimal and it's free.

320
00:13:56,350 --> 00:13:58,410
What domains can we use for this hiding?

321
00:13:58,410 --> 00:14:03,410
It turns out a lot, over
21% of the top 100,000 sites

322
00:14:03,410 --> 00:14:06,400
are behind Cloudflare
and allow this to work.

323
00:14:06,400 --> 00:14:08,470
Some notable examples are shown below,

324
00:14:08,470 --> 00:14:10,840
including three of 11 domains,

325
00:14:10,840 --> 00:14:13,900
which are both on the Palo
Alto decryption white list

326
00:14:13,900 --> 00:14:16,000
and behind Cloudflare.

327
00:14:16,000 --> 00:14:18,503
I'll demonstrate why this
is important in a minute.

328
00:14:19,860 --> 00:14:21,440
There's a little bit of
everything on this list

329
00:14:21,440 --> 00:14:24,820
from security related
sites, banks, sports,

330
00:14:24,820 --> 00:14:27,650
higher education, streaming services,

331
00:14:27,650 --> 00:14:31,743
and even government sites
and porn, so much porn.

332
00:14:32,950 --> 00:14:34,840
Here's a good example of how the variety

333
00:14:34,840 --> 00:14:37,930
of available domains to
hide behind can be useful.

334
00:14:37,930 --> 00:14:41,110
This is a request to www.okta.com.

335
00:14:41,110 --> 00:14:43,170
A single sign on and identity provider

336
00:14:43,170 --> 00:14:45,090
used by many enterprises,

337
00:14:45,090 --> 00:14:48,640
but the actual request is
going to a server I control.

338
00:14:48,640 --> 00:14:50,640
To a sensor or network defender,

339
00:14:50,640 --> 00:14:52,860
this looks standard Okta traffic

340
00:14:52,860 --> 00:14:56,730
with the exception of the
ESNI extension being used.

341
00:14:56,730 --> 00:14:59,350
The logical next step is
to try out noctilucent

342
00:14:59,350 --> 00:15:02,170
with some web filtering
and see how it fares.

343
00:15:02,170 --> 00:15:03,910
It turns out most web filtering

344
00:15:03,910 --> 00:15:05,920
is done by inspecting the SNI,

345
00:15:05,920 --> 00:15:08,890
and making a filtering
decision based on that.

346
00:15:08,890 --> 00:15:11,080
Here, I set up the untangled firewall

347
00:15:11,080 --> 00:15:12,670
with Federal Government settings

348
00:15:12,670 --> 00:15:16,303
and explicitly blocked
defcon28.hackthis.computer.

349
00:15:17,620 --> 00:15:19,940
On a host behind the Untangle Firewall,

350
00:15:19,940 --> 00:15:22,530
I made this request, which succeeded.

351
00:15:22,530 --> 00:15:27,510
I set the un-encrypted
SNI to bypass-untangle.com

352
00:15:27,510 --> 00:15:29,610
to see if it appears in the logs anywhere.

353
00:15:31,600 --> 00:15:34,270
After repeating the
requests 30 times or so,

354
00:15:34,270 --> 00:15:36,920
back on the firewall, we
can see that the top domains

355
00:15:36,920 --> 00:15:40,113
include the decoy domain that
we sent with the request.

356
00:15:41,430 --> 00:15:44,160
Simple SNI filters were easy to defeat.

357
00:15:44,160 --> 00:15:47,640
What about HTTPS decrypting firewalls?

358
00:15:47,640 --> 00:15:49,650
These are often seen in
enterprise environments

359
00:15:49,650 --> 00:15:52,300
and work by breaking and
then re-encrypting HTTPS

360
00:15:53,210 --> 00:15:55,370
using a root certificate
placed on endpoints

361
00:15:55,370 --> 00:15:56,880
behind the firewall.

362
00:15:56,880 --> 00:15:59,070
You can think of it as a
corporate man-in-the-middle

363
00:15:59,070 --> 00:16:00,320
that allows the network defenders

364
00:16:00,320 --> 00:16:03,260
to inspect full encrypted packet data.

365
00:16:03,260 --> 00:16:06,310
Kazakhstan actually attempted
to implement this nationwide

366
00:16:06,310 --> 00:16:08,860
for a few weeks back in July of 2019,

367
00:16:08,860 --> 00:16:11,440
before a major international
backlash forced them to abandon

368
00:16:11,440 --> 00:16:13,487
what they called a "test".

369
00:16:15,010 --> 00:16:17,840
I headed to AWS and spun
up the latest and greatest

370
00:16:17,840 --> 00:16:22,840
in enterprise firewalls, a
Palo Alto PA-VM version 10.0.0.

371
00:16:23,690 --> 00:16:26,210
Released in June, this
version touts the ability

372
00:16:26,210 --> 00:16:30,160
to decrypt TLS 1.3 with
a two times speed boost.

373
00:16:30,160 --> 00:16:31,957
Imagine my surprise when it was all set up

374
00:16:31,957 --> 00:16:36,420
and the default decryption
profile didn't include TLS 1.3.

375
00:16:36,420 --> 00:16:38,360
Instead, it let it pass through

376
00:16:38,360 --> 00:16:40,903
while logging an error
about a version mismatch.

377
00:16:42,370 --> 00:16:44,160
Once set up with a decryption profile

378
00:16:44,160 --> 00:16:46,830
that enabled decryption of TLS. 1.3,

379
00:16:46,830 --> 00:16:48,490
I pulled the list of default domains

380
00:16:48,490 --> 00:16:49,910
that are allowed to bypass decryption

381
00:16:49,910 --> 00:16:51,350
for variety of reasons,

382
00:16:51,350 --> 00:16:53,600
such as having a pin certificate.

383
00:16:53,600 --> 00:16:55,950
Here, the firewall interfaces on the left

384
00:16:55,950 --> 00:16:58,820
and a Windows VM behind the
firewall is on the right.

385
00:16:58,820 --> 00:17:00,830
We can see that decryption is enabled

386
00:17:00,830 --> 00:17:02,580
and we have no other decryption rules

387
00:17:02,580 --> 00:17:05,360
that would allow traffic
to bypass decryption.

388
00:17:05,360 --> 00:17:07,520
Normally, in an enterprise environment,

389
00:17:07,520 --> 00:17:09,180
categories like banking or healthcare

390
00:17:09,180 --> 00:17:11,500
bypass decryption due to privacy laws.

391
00:17:11,500 --> 00:17:13,670
But this setup is as strict as possible.

392
00:17:13,670 --> 00:17:15,223
No explicit exemptions.

393
00:17:16,360 --> 00:17:18,560
On the Windows VM, I'll
run a PowerShell script

394
00:17:18,560 --> 00:17:20,900
that checks the certificate
hashes of major sites

395
00:17:20,900 --> 00:17:23,680
against hard-coded known fingerprints.

396
00:17:23,680 --> 00:17:26,210
We see that it fails indicating
that all tested sites

397
00:17:26,210 --> 00:17:27,850
are being man-in-the-middled.

398
00:17:27,850 --> 00:17:30,720
Additionally, opening a
browser and going to google.com

399
00:17:30,720 --> 00:17:33,440
shows a lock icon, but
inspecting the certificate

400
00:17:33,440 --> 00:17:36,290
shows that it's the firewall certificate.

401
00:17:36,290 --> 00:17:37,560
Switching to the command line

402
00:17:37,560 --> 00:17:39,610
and using the noctilucent test client,

403
00:17:39,610 --> 00:17:42,520
I'll set the TLS host to mozilla.org,

404
00:17:42,520 --> 00:17:46,180
the host header to
defcon28.hackthis.computer

405
00:17:46,180 --> 00:17:48,940
and the un-encrypted SNI to mozilla.org,

406
00:17:48,940 --> 00:17:51,680
which is on the decryption exemption list.

407
00:17:51,680 --> 00:17:54,570
The SNI is preserved
and set to mozilla.org.

408
00:17:54,570 --> 00:17:57,840
A connection is made to
mozilla.org on port 443.

409
00:17:57,840 --> 00:18:00,490
And we see the Hello DEF
CON 28 response we expect

410
00:18:00,490 --> 00:18:01,540
from the test server.

411
00:18:02,570 --> 00:18:05,200
We'll run nslookup of mozilla.org

412
00:18:05,200 --> 00:18:07,500
so we can look for the
connection in the logs.

413
00:18:11,790 --> 00:18:14,490
Looking at the firewall traffic
logs serves a connection

414
00:18:14,490 --> 00:18:16,943
to one of the IP
addresses for mozilla.org.

415
00:18:21,550 --> 00:18:25,750
Moving to the decryption
logs, we see DNS over HTTPS,

416
00:18:25,750 --> 00:18:28,290
which is the ESNI key
lookup that is performed

417
00:18:28,290 --> 00:18:30,800
before each TLS connection,

418
00:18:30,800 --> 00:18:33,163
but no traffic to mozilla.org's IP.

419
00:18:36,600 --> 00:18:38,720
To make sure we didn't
miss it, I'll add a filter

420
00:18:38,720 --> 00:18:40,273
for the two possible IPs.

421
00:18:41,780 --> 00:18:43,670
No results because mozilla.org

422
00:18:43,670 --> 00:18:46,240
is exempted from decryption by default.

423
00:18:46,240 --> 00:18:50,020
We have successfully defeated
an HTTPS decrypting firewall

424
00:18:50,020 --> 00:18:53,710
by using built-in default
exemption in domain hiding.

425
00:18:53,710 --> 00:18:56,860
This bypass is great, but
every time we wanna send data,

426
00:18:56,860 --> 00:18:58,560
we'll add an entry to the traffic log,

427
00:18:58,560 --> 00:19:00,010
which could stand out.

428
00:19:00,010 --> 00:19:01,800
What if there was a better way to hide?

429
00:19:01,800 --> 00:19:03,800
This technique works at the TLS level.

430
00:19:03,800 --> 00:19:06,410
So any protocol that
Cloudflare supports underneath

431
00:19:06,410 --> 00:19:07,960
would also work.

432
00:19:07,960 --> 00:19:10,620
We saw that regular HTTP requests work,

433
00:19:10,620 --> 00:19:13,660
but create a new connection
for each request.

434
00:19:13,660 --> 00:19:16,590
Websockets are a technology
used by many streaming services

435
00:19:16,590 --> 00:19:18,940
that enable full duplex
communication channels

436
00:19:18,940 --> 00:19:21,520
over a single TCP connection.

437
00:19:21,520 --> 00:19:23,300
And we can take this a step further

438
00:19:23,300 --> 00:19:25,930
by using one or more of
these websites connections

439
00:19:25,930 --> 00:19:29,490
to tunnel arbitrary TCP
or UDP packets to a proxy

440
00:19:29,490 --> 00:19:30,683
beyond the firewall.

441
00:19:32,510 --> 00:19:35,420
Here's the noctilucent test
client sending and receiving

442
00:19:35,420 --> 00:19:38,000
via Websockets to a test server

443
00:19:38,000 --> 00:19:41,370
while hiding behind www.okta.com.

444
00:19:41,370 --> 00:19:43,760
Websockets are the perfect
candidate to use as a wrapper

445
00:19:43,760 --> 00:19:47,130
for a proxy protocol that
allows us to send arbitrary TCP

446
00:19:47,130 --> 00:19:49,860
or UDP traffic using a helper program

447
00:19:49,860 --> 00:19:52,890
while only making a single TCP connection.

448
00:19:52,890 --> 00:19:54,480
The noctilucent project includes

449
00:19:54,480 --> 00:19:57,550
a fork of the amazing
Cloak project by Andy Wang.

450
00:19:57,550 --> 00:20:01,150
That enables two new options
in the client configuration,

451
00:20:01,150 --> 00:20:03,610
ESNIServerName and Preserve SNI,

452
00:20:03,610 --> 00:20:06,520
which operate just like
they did on the test client.

453
00:20:06,520 --> 00:20:09,100
Cloak is a universal plugable transport

454
00:20:09,100 --> 00:20:11,750
that cryptographically
obfuscates proxy traffic

455
00:20:11,750 --> 00:20:14,370
as legitimate HTTPS traffic,

456
00:20:14,370 --> 00:20:17,020
disguises the proxy server
as a normal web server

457
00:20:17,020 --> 00:20:19,430
and multiplexes traffic
through a fixed amount

458
00:20:19,430 --> 00:20:24,230
of TCP connection while providing
multi-user usage control.

459
00:20:24,230 --> 00:20:26,030
With the additions from noctilucent,

460
00:20:26,030 --> 00:20:27,883
it can now do domain hiding as well.

461
00:20:29,420 --> 00:20:32,730
Here's the same Palo Alto
and Windows VMs from before

462
00:20:32,730 --> 00:20:36,940
with a public IP of 3.14.44.10.

463
00:20:36,940 --> 00:20:38,670
This time, the Windows VM is running

464
00:20:38,670 --> 00:20:42,970
a noctilucent Cloak client and
a local shadowsocks client.

465
00:20:42,970 --> 00:20:45,160
The Cloak client is connecting to a VPS

466
00:20:45,160 --> 00:20:49,140
running the standard cloak
server and a shadowsocks server.

467
00:20:49,140 --> 00:20:52,040
Firefox is configured to
use the local SOCKS proxy

468
00:20:52,040 --> 00:20:54,770
provided by the shadowsocks
client running locally.

469
00:20:54,770 --> 00:20:57,640
And I can browse the
internet as I would normally.

470
00:20:57,640 --> 00:21:00,230
The certificates of websites
in this proxy browser

471
00:21:00,230 --> 00:21:02,410
are legitimate, as they're
not being intercepted

472
00:21:02,410 --> 00:21:04,090
by the Palo Alto firewall.

473
00:21:04,090 --> 00:21:05,300
And all traffic is appearing

474
00:21:05,300 --> 00:21:07,333
to come from the DigitalOcean VPS.

475
00:21:16,030 --> 00:21:17,890
The speed is surprisingly good.

476
00:21:17,890 --> 00:21:19,250
During testing, I was getting speeds

477
00:21:19,250 --> 00:21:20,960
up to a hundred megabits per second,

478
00:21:20,960 --> 00:21:23,930
using four TCP connections with Cloak.

479
00:21:23,930 --> 00:21:25,590
If we look at the firewall logs,

480
00:21:25,590 --> 00:21:28,580
we only see the four
connections to mozilla.org,

481
00:21:28,580 --> 00:21:29,980
which are not decrypted

482
00:21:29,980 --> 00:21:31,930
while the client has been browsing freely

483
00:21:31,930 --> 00:21:34,530
with all traffic remaining
encrypted and uncensored.

484
00:21:38,170 --> 00:21:40,200
Switching to the decryption logs,

485
00:21:40,200 --> 00:21:43,310
we see the DNS over HTTPS requests,

486
00:21:43,310 --> 00:21:45,383
but no request to mozilla.org.

487
00:21:47,710 --> 00:21:50,460
I'll filter for the mozilla.org IPs,

488
00:21:50,460 --> 00:21:51,773
but we'll get no results.

489
00:21:53,930 --> 00:21:57,210
What we see here is arbitrary
traffic at highs speeds

490
00:21:57,210 --> 00:21:59,680
using only four TCP connections

491
00:21:59,680 --> 00:22:02,343
to what Palo Alto thinks is mozilla.org.

492
00:22:04,500 --> 00:22:07,460
Can we use this technique for
our preexisting RedTeam tools

493
00:22:07,460 --> 00:22:08,800
if they support proxying?

494
00:22:08,800 --> 00:22:09,760
You bet.

495
00:22:09,760 --> 00:22:12,800
Here's a Cobalt Strike listener
with a SOCKS proxy setting

496
00:22:12,800 --> 00:22:15,570
for localhost port 9999.

497
00:22:15,570 --> 00:22:18,780
For fun, we'll set Cloak
to use bitdefender.com

498
00:22:18,780 --> 00:22:22,473
as the front domain, which
has the IP address shown here.

499
00:22:25,300 --> 00:22:27,850
After starting the
noctilucent Cloak client

500
00:22:27,850 --> 00:22:31,660
and local shadowsocks
server and SOCKS 4 mode,

501
00:22:31,660 --> 00:22:34,690
we'll double click on
an innocent looking EXE.

502
00:22:34,690 --> 00:22:37,590
We get the call back immediately
and it works as expected.

503
00:22:39,700 --> 00:22:41,870
And, of course, the first thing
you do when you get access

504
00:22:41,870 --> 00:22:42,803
is pop a calc.

505
00:22:48,350 --> 00:22:51,660
Switching the firewall and
looking at the decryption logs,

506
00:22:51,660 --> 00:22:54,713
we only see entries
for cloudflare-dns.com.

507
00:22:59,620 --> 00:23:01,710
I'll paste in a filter
for the two possible IPs

508
00:23:01,710 --> 00:23:04,093
for bitdefender.com and we get no results.

509
00:23:09,000 --> 00:23:11,920
Looking at the traffic logs,
you see four connections

510
00:23:11,920 --> 00:23:14,250
to the IP of bitdefender.com

511
00:23:14,250 --> 00:23:16,783
as well as lots of DNS over HTTPS.

512
00:23:21,450 --> 00:23:23,960
Our Cobalt Strike beacon is
still functioning as normal

513
00:23:23,960 --> 00:23:26,253
and any network defender
is none the wiser.

514
00:23:27,260 --> 00:23:29,820
Packaging up Cobalt Strike
Cloak and shadowsocks

515
00:23:29,820 --> 00:23:31,300
into a clean package,

516
00:23:31,300 --> 00:23:34,300
possibly communicating over
named pipes instead of sockets

517
00:23:34,300 --> 00:23:36,653
is an exercise left up to the viewer.

518
00:23:38,700 --> 00:23:41,010
RedTeamers are no doubt wondering
how much work it would be

519
00:23:41,010 --> 00:23:43,360
to integrate this with
their existing tooling.

520
00:23:43,360 --> 00:23:44,960
And I can say if you're for using Go,

521
00:23:44,960 --> 00:23:46,820
it's almost no work at all.

522
00:23:46,820 --> 00:23:49,237
Here's a new C2 framework called DeimosC2.

523
00:23:49,237 --> 00:23:51,540
It was a released just five days ago

524
00:23:51,540 --> 00:23:54,103
and is built using Go, Vue.js.

525
00:23:57,120 --> 00:24:00,510
I've set up an instance
here with an HTTPS listener,

526
00:24:00,510 --> 00:24:02,923
with a public IP on port 443.

527
00:24:03,950 --> 00:24:05,600
Going into the listener settings,

528
00:24:05,600 --> 00:24:08,523
we can view the source
code for an HTTPS agent.

529
00:24:13,110 --> 00:24:15,350
It has the C2 host import in the code,

530
00:24:15,350 --> 00:24:17,800
and the agent will connect
directly to this host.

531
00:24:18,810 --> 00:24:21,230
Switching to an editor, I've
made a few modifications

532
00:24:21,230 --> 00:24:23,420
to get this to work with noctilucent.

533
00:24:23,420 --> 00:24:26,110
First, I set the host to bitdefender.com

534
00:24:26,110 --> 00:24:27,810
and I've added two new variables,

535
00:24:27,810 --> 00:24:30,340
front domain and actual domain,

536
00:24:30,340 --> 00:24:32,326
which are set to bitdefender.com

537
00:24:32,326 --> 00:24:34,053
and deimos.hackthis.computer.

538
00:24:35,500 --> 00:24:37,820
The actual code changes needed
to get everything working

539
00:24:37,820 --> 00:24:39,490
is just 30 lines.

540
00:24:39,490 --> 00:24:43,640
First, we have to query for
the ESNI keys and parse them.

541
00:24:43,640 --> 00:24:46,070
If we wanted to, we could
bake in the current keys here

542
00:24:46,070 --> 00:24:49,470
to avoid the network traffic
related to querying for them.

543
00:24:49,470 --> 00:24:51,200
Then I define a TLS config

544
00:24:51,200 --> 00:24:54,360
and set the minimum value to TLS 1.3.

545
00:24:54,360 --> 00:24:56,840
I'll define the two new
options from noctilucent.

546
00:24:56,840 --> 00:24:59,090
ESNIServerName is set to the actual domain

547
00:25:00,040 --> 00:25:01,773
and PreserveSNI is set to true.

548
00:25:04,040 --> 00:25:06,250
I define an HttpClient by hand,

549
00:25:06,250 --> 00:25:08,320
so I can tell it to use this tlsConfig

550
00:25:08,320 --> 00:25:09,420
when dialing the host.

551
00:25:10,860 --> 00:25:13,070
Besides that, the only change the agent

552
00:25:13,070 --> 00:25:16,140
is having the HttpClient
use the actual host

553
00:25:16,140 --> 00:25:17,740
when it makes its POST requests.

554
00:25:21,000 --> 00:25:23,550
On a Windows VM, I'll
set a filter in Wireshark

555
00:25:23,550 --> 00:25:25,230
for the IP of BitDefender

556
00:25:25,230 --> 00:25:27,620
so we can inspect the ClientHello.

557
00:25:27,620 --> 00:25:29,849
I'll double click this new innocent EXE

558
00:25:29,849 --> 00:25:31,299
and switch back to Wireshark.

559
00:25:34,080 --> 00:25:36,810
In the ClientHello, we see
the un-encrypted server name

560
00:25:36,810 --> 00:25:40,250
is bitdefender.com and
the encrypted server name,

561
00:25:40,250 --> 00:25:41,600
it's just a bunch of hacks.

562
00:25:48,830 --> 00:25:51,480
Back on the C2 server, we
have an agent calling back.

563
00:25:53,340 --> 00:25:55,150
Notice the external IP.

564
00:25:55,150 --> 00:25:58,130
When using this technique,
the reported external IP

565
00:25:58,130 --> 00:26:00,823
will be from one of Cloudflare's ranges.

566
00:26:10,780 --> 00:26:13,763
Just like with Cobalt Strike,
everything works as normal.

567
00:26:16,020 --> 00:26:20,137
You can run whoami, pop a
calc, and check the public IP.

568
00:26:28,520 --> 00:26:29,610
Besides the external IP

569
00:26:29,610 --> 00:26:31,480
appearing to be from a Cloudflare range,

570
00:26:31,480 --> 00:26:33,080
the agent functions as expected.

571
00:26:43,910 --> 00:26:45,290
Back on the Windows VM,

572
00:26:45,290 --> 00:26:48,283
I'll search for traffic
to the C2's server IP.

573
00:26:50,120 --> 00:26:52,630
No packets, there's no trickery here.

574
00:26:52,630 --> 00:26:55,490
With just a small modification,
this Go-based agent

575
00:26:55,490 --> 00:26:56,883
is using domain hiding.

576
00:26:58,230 --> 00:26:59,810
So what is the blue team to do

577
00:26:59,810 --> 00:27:01,540
given that we've just seemingly bypassed

578
00:27:01,540 --> 00:27:04,170
the most sophisticated network defenses?

579
00:27:04,170 --> 00:27:07,640
The easiest thing to do
would be to block TLS 1.3,

580
00:27:07,640 --> 00:27:11,810
but that's likely anywhere from
25 to 50% of the TLS traffic

581
00:27:11,810 --> 00:27:15,640
leaving your network, it might
make a few users unhappy.

582
00:27:15,640 --> 00:27:18,380
You could block Cloudflare,
but dropping 21%

583
00:27:18,380 --> 00:27:20,690
of the most popular a
hundred thousand domains

584
00:27:20,690 --> 00:27:23,180
probably is not a good idea either.

585
00:27:23,180 --> 00:27:26,630
What about just targeting
ClientHellos with ESNIs?

586
00:27:26,630 --> 00:27:29,890
It's possible, and one vendor
has had the ability to do that

587
00:27:29,890 --> 00:27:31,450
for six months now.

588
00:27:31,450 --> 00:27:34,160
However, since you can't
determine the destination site,

589
00:27:34,160 --> 00:27:35,860
it's all or none blocking.

590
00:27:35,860 --> 00:27:38,000
There's no way to only
block selective domains

591
00:27:38,000 --> 00:27:41,110
if you block TLS connections
that have an ESNI.

592
00:27:41,110 --> 00:27:42,820
I was surprised by the
lack of support for this

593
00:27:42,820 --> 00:27:44,170
across major vendors,

594
00:27:44,170 --> 00:27:46,120
but perhaps it's just not an issue yet.

595
00:27:47,420 --> 00:27:50,210
The most sensible way to
detect this specific technique

596
00:27:50,210 --> 00:27:53,190
is to alert on packets that
contain both a server name

597
00:27:53,190 --> 00:27:56,290
and an encrypted server
name TLS extension.

598
00:27:56,290 --> 00:27:58,950
There are no default
helpers for TLS in snort

599
00:27:58,950 --> 00:28:02,200
besides ssl_state, which can help you get

600
00:28:02,200 --> 00:28:04,880
the ClientHello packet and TLS. version,

601
00:28:04,880 --> 00:28:07,040
which can get you TLS 1.3.

602
00:28:07,040 --> 00:28:09,610
So you'll have to get creative
with the content parser

603
00:28:09,610 --> 00:28:11,260
and look for the extension types.

604
00:28:12,098 --> 00:28:14,590
Securicata has a bit more
horsepower than snort,

605
00:28:14,590 --> 00:28:19,030
but only has a selector for
tls.sni and not tls.esni

606
00:28:20,020 --> 00:28:22,363
so custom rules will be
required here as well.

607
00:28:23,810 --> 00:28:26,160
It's gonna come down to tried
and true techniques that work,

608
00:28:26,160 --> 00:28:28,100
regardless of traffic content.

609
00:28:28,100 --> 00:28:30,860
Things like beaconing
detection and anomaly detection

610
00:28:30,860 --> 00:28:32,530
can help show clients that all of a sudden

611
00:28:32,530 --> 00:28:34,740
start sending regular
traffic to destinations

612
00:28:34,740 --> 00:28:37,100
that perhaps don't make sense.

613
00:28:37,100 --> 00:28:40,290
There are even some open
source tools that do just this.

614
00:28:40,290 --> 00:28:42,730
A network defenders should be
asking if a traffic pattern

615
00:28:42,730 --> 00:28:45,540
to a given end point
makes sense in context,

616
00:28:45,540 --> 00:28:47,230
perhaps that Windows machine in accounting

617
00:28:47,230 --> 00:28:48,700
shouldn't be sending gigs of data

618
00:28:48,700 --> 00:28:50,300
to your single sign on provider.

619
00:28:52,540 --> 00:28:54,990
TLS fingerprinting with JA3 and JA3S

620
00:28:54,990 --> 00:28:57,420
is another technique
that could be effective.

621
00:28:57,420 --> 00:29:00,750
JA3 looks at the specific
options used in a ClientHello,

622
00:29:00,750 --> 00:29:03,300
that can sometimes
uniquely identify a client.

623
00:29:03,300 --> 00:29:06,230
And JA3S does the same for servers.

624
00:29:06,230 --> 00:29:08,270
This will work until
attackers tune their tools

625
00:29:08,270 --> 00:29:11,060
to be identical to browsers
and common web servers

626
00:29:11,060 --> 00:29:12,780
and work is already underway to do this

627
00:29:12,780 --> 00:29:16,010
in projects like Cloak and utls.

628
00:29:16,010 --> 00:29:19,680
As always, a layered approach
that uses strong instrumented

629
00:29:19,680 --> 00:29:21,910
and managed endpoint
detection and response,

630
00:29:21,910 --> 00:29:25,470
and other techniques is the
best way to prevent compromise.

631
00:29:25,470 --> 00:29:27,510
Or as Microsoft so hopefully says

632
00:29:27,510 --> 00:29:30,210
just don't let untrusted
code ever run on your server.

633
00:29:32,000 --> 00:29:33,120
To wrap up today,

634
00:29:33,120 --> 00:29:37,010
I've discussed the basics of HTTP, HTTPS,

635
00:29:37,010 --> 00:29:38,920
domain fronting, and a new form

636
00:29:38,920 --> 00:29:42,670
of censorship resisting
communication, domain hiding.

637
00:29:42,670 --> 00:29:45,500
This technique is usable
today with noctilucent

638
00:29:45,500 --> 00:29:48,830
either as a drop-in replacement
for the Go-TLS library

639
00:29:48,830 --> 00:29:50,440
or as a proxy.

640
00:29:50,440 --> 00:29:53,070
The ESNI standard is
still very much a draft

641
00:29:53,070 --> 00:29:55,220
and this technique will continue to evolve

642
00:29:55,220 --> 00:29:57,350
as the changes in adoption grows.

643
00:29:57,350 --> 00:30:00,730
In fact, it's not even
called ESNI anymore.

644
00:30:00,730 --> 00:30:02,840
Just as with standard domain fronting,

645
00:30:02,840 --> 00:30:05,100
this relies on the CDN permitting it.

646
00:30:05,100 --> 00:30:06,310
However, in this case,

647
00:30:06,310 --> 00:30:08,770
besides preserving the
standard SNI header,

648
00:30:08,770 --> 00:30:11,710
we aren't really doing
anything terribly out of spec.

649
00:30:11,710 --> 00:30:14,180
I look forward to seeing the
snort and securicata rules

650
00:30:14,180 --> 00:30:16,060
to detect and block this technique.

651
00:30:16,060 --> 00:30:17,600
And like every good RedTeamer,

652
00:30:17,600 --> 00:30:19,990
I'll push my customers
with the latest techniques,

653
00:30:19,990 --> 00:30:22,193
hopefully before the real adversary can.

654
00:30:23,170 --> 00:30:25,260
I wanna give special thanks to Robin Wood

655
00:30:25,260 --> 00:30:27,090
who first showed this
technique was possible

656
00:30:27,090 --> 00:30:30,850
with a rough POC using a fork of OpenSSL.

657
00:30:30,850 --> 00:30:32,820
Andy Wang, the creator of Cloak,

658
00:30:32,820 --> 00:30:34,710
and Nick Sullivan from Cloudflare

659
00:30:34,710 --> 00:30:37,593
who helped to get me
data on TLS 1.3 adoption.

660
00:30:38,470 --> 00:30:41,090
Noctilucent is available now on GitHub.

661
00:30:41,090 --> 00:30:42,760
If you have any questions or comments,

662
00:30:42,760 --> 00:30:44,330
feel free to hit me up on Twitter,

663
00:30:44,330 --> 00:30:47,840
on my personal handle is @badsectorlabs.

664
00:30:47,840 --> 00:30:48,840
Thanks for watching.

