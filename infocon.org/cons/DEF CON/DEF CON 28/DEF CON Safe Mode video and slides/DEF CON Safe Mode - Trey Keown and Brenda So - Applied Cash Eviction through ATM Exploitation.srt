1
00:00:02,610 --> 00:00:04,670
- Hi, I'm Trey Keown,
I'm here with Brenda So

2
00:00:04,670 --> 00:00:06,360
and we're security researchers here

3
00:00:06,360 --> 00:00:08,280
at Red Balloon Security.

4
00:00:08,280 --> 00:00:09,230
For the past year and a half,

5
00:00:09,230 --> 00:00:10,730
we've been working on this ATM

6
00:00:11,950 --> 00:00:16,950
partially as a CTF target, but
later as a research project.

7
00:00:18,100 --> 00:00:23,100
So this was something that
evolved out of the CTF work

8
00:00:24,230 --> 00:00:25,370
that we've done.

9
00:00:25,370 --> 00:00:26,530
So our agenda today;

10
00:00:26,530 --> 00:00:29,205
first, we're gonna talk about this ATM,

11
00:00:29,205 --> 00:00:32,713
what's involved in here, what's
involved in a normal ATM.

12
00:00:34,420 --> 00:00:35,430
Then we're gonna talk about setting up

13
00:00:35,430 --> 00:00:36,760
our own payment processor,

14
00:00:36,760 --> 00:00:39,520
what we had to do to get that to work;

15
00:00:39,520 --> 00:00:41,530
and then our two vulnerabilities
that we discovered.

16
00:00:41,530 --> 00:00:44,930
So the first in the root
management system on this device,

17
00:00:44,930 --> 00:00:48,510
and the second in its
implementation of the extensions

18
00:00:48,510 --> 00:00:51,343
for the financial the services component,

19
00:00:52,240 --> 00:00:53,840
which we'll get more into later.

20
00:00:55,540 --> 00:00:57,960
So, one of the things to note here is that

21
00:00:57,960 --> 00:01:00,910
there's been a lot of
talk of ATMs in the past.

22
00:01:00,910 --> 00:01:04,430
One of the more famous ones
was Barnaby Jack's talk

23
00:01:04,430 --> 00:01:07,630
10 years ago where he demonstrated

24
00:01:07,630 --> 00:01:10,180
a bunch of cool things, jackpotting ATMs,

25
00:01:10,180 --> 00:01:11,653
installing root kits.

26
00:01:13,290 --> 00:01:16,860
And we wanted to see had things improved

27
00:01:16,860 --> 00:01:18,543
in over a decade?

28
00:01:20,090 --> 00:01:23,253
And yeah, that's one of
the ways we got here.

29
00:01:24,480 --> 00:01:28,040
The initial spark was
we were at a conference

30
00:01:28,040 --> 00:01:30,500
and accidentally unplugged an ATM

31
00:01:30,500 --> 00:01:32,363
as we were setting up our own table.

32
00:01:33,240 --> 00:01:34,530
I noticed something funny on the screen

33
00:01:34,530 --> 00:01:35,830
when we turned it back on.

34
00:01:36,880 --> 00:01:39,590
This is the startup screen on the ATM

35
00:01:39,590 --> 00:01:40,970
and you'll see here that this is running

36
00:01:40,970 --> 00:01:45,970
Microsoft Windows CE 6.0,
which is quite an old version.

37
00:01:46,240 --> 00:01:48,160
And at Red Balloon we've worked

38
00:01:48,160 --> 00:01:49,510
with embedded devices quite a bit

39
00:01:49,510 --> 00:01:51,700
and so there are people here who know

40
00:01:51,700 --> 00:01:53,090
quite a bit about windows CE.

41
00:01:53,090 --> 00:01:54,710
So we thought it'd be
an interesting target

42
00:01:54,710 --> 00:01:56,083
to start tearing into.

43
00:01:58,770 --> 00:02:01,533
Now, you'll see these
ATMs all around the city.

44
00:02:02,370 --> 00:02:06,820
Our city is Manhattan
in things like bodegas,

45
00:02:06,820 --> 00:02:09,433
gas stations, street corners, anywhere.

46
00:02:10,543 --> 00:02:13,040
They're a fairly common ATM.

47
00:02:13,040 --> 00:02:16,170
And we thought we may
as well get this one.

48
00:02:16,170 --> 00:02:19,693
So we did, we got our own
ATM shipped to our office.

49
00:02:20,870 --> 00:02:22,870
In fact, we're up to,

50
00:02:22,870 --> 00:02:25,370
I believe it's five ATMs now.

51
00:02:25,370 --> 00:02:29,920
Three of this larger
ATM; this is the Halo II.

52
00:02:29,920 --> 00:02:32,170
And then two of a smaller ATM that

53
00:02:33,190 --> 00:02:35,570
is actually able to go on a flight

54
00:02:35,570 --> 00:02:37,480
with some modifications,

55
00:02:37,480 --> 00:02:39,730
so it's easier to take
around to conferences.

56
00:02:41,160 --> 00:02:43,040
So one of the things we
want to do on our CTF

57
00:02:43,040 --> 00:02:46,630
was teach people about card technologies,

58
00:02:46,630 --> 00:02:49,780
we got people to interface
with the EMV chip,

59
00:02:49,780 --> 00:02:51,283
magnetic stripes on the card.

60
00:02:52,820 --> 00:02:55,000
And just any way that you can think of to

61
00:02:56,110 --> 00:02:58,510
interface with this device

62
00:02:59,840 --> 00:03:01,100
in ways that you wouldn't normally be able

63
00:03:01,100 --> 00:03:02,030
to interface with something.

64
00:03:02,030 --> 00:03:04,160
So, that was cool to be able to

65
00:03:05,840 --> 00:03:07,990
create a ecosystem around that.

66
00:03:07,990 --> 00:03:12,370
So, we actually had this at
the IoT Village last year.

67
00:03:12,370 --> 00:03:14,720
This is the leaderboard,
the final leaderboard.

68
00:03:15,810 --> 00:03:17,100
And those are real cash payouts.

69
00:03:17,100 --> 00:03:19,540
So we paid everyone in $2 bills.

70
00:03:19,540 --> 00:03:21,623
It was quite a fun experience.

71
00:03:23,400 --> 00:03:25,050
So, this is the smaller ATM

72
00:03:25,050 --> 00:03:28,403
that we took around; the MX4000W.

73
00:03:29,650 --> 00:03:32,730
So, it's almost able to be taken

74
00:03:32,730 --> 00:03:34,540
on a flight, but not quite.

75
00:03:34,540 --> 00:03:36,160
You have to take out the cash dispenser

76
00:03:36,160 --> 00:03:37,903
in order to be underweight.

77
00:03:39,860 --> 00:03:42,414
This is the case we took it in

78
00:03:42,414 --> 00:03:46,000
and it was actually a number
of times we've taken it

79
00:03:46,000 --> 00:03:47,750
on flights for quite a bit of money

80
00:03:48,950 --> 00:03:50,700
and also across international borders.

81
00:03:50,700 --> 00:03:53,850
So, we took it to Canada one time,

82
00:03:53,850 --> 00:03:58,420
which was quite a struggle to
get through border security.

83
00:03:58,420 --> 00:04:01,030
And it ended up not being the thing

84
00:04:01,030 --> 00:04:02,220
they give us the hardest time about;

85
00:04:02,220 --> 00:04:04,610
they were more concerned
about the T-shirts

86
00:04:04,610 --> 00:04:06,880
we were importing into
the country to give away.

87
00:04:06,880 --> 00:04:10,313
So, we registered as importers.

88
00:04:11,450 --> 00:04:13,410
So, there was a lot of
people that I wanna thank

89
00:04:13,410 --> 00:04:16,283
for the work in the CTF that we did:

90
00:04:17,310 --> 00:04:19,080
Aleks, Alex,

91
00:04:19,080 --> 00:04:23,583
our CEO, Ang, Brian, Jatin,
James, Rafi, and Tim.

92
00:04:24,900 --> 00:04:28,640
This was a lot of people
helping a big group effort,

93
00:04:28,640 --> 00:04:30,163
so thank you, guys, for that.

94
00:04:33,280 --> 00:04:35,380
One thing you need to
be able to understand

95
00:04:35,380 --> 00:04:37,030
about the ATM industry
is there's generally

96
00:04:37,030 --> 00:04:39,390
two market segments;
the first being retail,

97
00:04:39,390 --> 00:04:41,370
and the second one financial.

98
00:04:41,370 --> 00:04:44,190
Retail is generally more focused on cost

99
00:04:44,190 --> 00:04:47,520
and being appealing to
people who just want an ATM

100
00:04:47,520 --> 00:04:51,400
on their property to be able
to give to their customers,

101
00:04:51,400 --> 00:04:53,153
let them get cash out of it.

102
00:04:54,810 --> 00:04:58,550
Just anytime you need cash
to appear out of thin air.

103
00:04:58,550 --> 00:05:00,200
The second one is financial;

104
00:05:00,200 --> 00:05:02,040
that one's generally more focused on

105
00:05:03,440 --> 00:05:06,020
being more secure and more up to date.

106
00:05:06,020 --> 00:05:08,060
Those are much larger ATMs, often,

107
00:05:08,060 --> 00:05:12,700
and you generally won't
find those except in a bank.

108
00:05:12,700 --> 00:05:14,400
Most of these ATMs run Windows

109
00:05:15,420 --> 00:05:18,110
and there's a number of manufacturers,

110
00:05:18,110 --> 00:05:20,810
but this is one of most
common and ones that we found.

111
00:05:22,110 --> 00:05:23,710
So, how does an ATM work?

112
00:05:23,710 --> 00:05:25,610
You insert your card, some magic happens,

113
00:05:25,610 --> 00:05:27,023
and then cash comes out.

114
00:05:28,500 --> 00:05:30,870
Well, there's a lot of
moving components here.

115
00:05:30,870 --> 00:05:33,470
Firstly, it's a vault
with some holes in it,

116
00:05:33,470 --> 00:05:36,120
notably the ethernet
cable coming out the back;

117
00:05:36,120 --> 00:05:37,653
though not all ATMs have that.

118
00:05:39,040 --> 00:05:41,040
Some actually use a cellular connection.

119
00:05:42,110 --> 00:05:43,347
So, this is our ATM.

120
00:05:44,330 --> 00:05:49,030
There is two components
to it, two compartments.

121
00:05:49,030 --> 00:05:52,400
The top section, which is
a little bit lower security

122
00:05:52,400 --> 00:05:54,220
in terms of the lock
and the bottom section,

123
00:05:54,220 --> 00:05:55,933
which actually contains the cash.

124
00:05:57,730 --> 00:06:00,500
The top section you'll see

125
00:06:02,150 --> 00:06:04,240
has the receipt printer,
card reader, pin pad,

126
00:06:04,240 --> 00:06:09,240
and also the main CPU and any
network connections in it.

127
00:06:10,050 --> 00:06:12,680
The bottom component
has the cash dispenser,

128
00:06:12,680 --> 00:06:16,510
which works with the cassettes.

129
00:06:16,510 --> 00:06:18,350
So the cassettes are
what actually hold all

130
00:06:18,350 --> 00:06:21,750
of the cash and your cash dispenser

131
00:06:21,750 --> 00:06:22,920
obviously dispenses that.

132
00:06:22,920 --> 00:06:25,463
So, there's two separate sections there.

133
00:06:27,010 --> 00:06:30,690
And in fact, the key for the top section,

134
00:06:30,690 --> 00:06:33,113
as Barnaby Jack mentioned 10 years ago,

135
00:06:34,740 --> 00:06:37,010
all the keys for the tops
of the ATMs are the same.

136
00:06:37,010 --> 00:06:41,590
So you can't trivially get
to the bottom of the ATM

137
00:06:41,590 --> 00:06:46,100
where the vault is because
there's different keys there

138
00:06:46,100 --> 00:06:48,620
and then there's also a electronic lock

139
00:06:48,620 --> 00:06:51,610
which has a numeric code.

140
00:06:51,610 --> 00:06:54,380
However, the top section only has a key

141
00:06:55,860 --> 00:06:57,380
that's commonly available.

142
00:06:57,380 --> 00:06:59,707
So, when we originally got the ATM,

143
00:06:59,707 --> 00:07:02,510
one of the problems we had was

144
00:07:02,510 --> 00:07:05,960
our intern actually locked
the key inside of the ATM,

145
00:07:05,960 --> 00:07:07,120
which is possible to do

146
00:07:07,120 --> 00:07:10,210
'cause this thing automatically
latches when it's closed.

147
00:07:10,210 --> 00:07:14,370
So, we went and Ang
actually 3D-printed a key

148
00:07:15,410 --> 00:07:17,160
that we used in the top of the ATM,

149
00:07:18,240 --> 00:07:19,630
because all the keys are the same

150
00:07:19,630 --> 00:07:23,210
and we were able to open
it, retrieve the real key

151
00:07:23,210 --> 00:07:24,913
and continue on our way.

152
00:07:27,440 --> 00:07:29,570
Again, most of these devices run Windows.

153
00:07:29,570 --> 00:07:33,180
This one specifically runs Windows CE 6.0,

154
00:07:33,180 --> 00:07:36,233
which is quite old in
terms of operating systems.

155
00:07:37,730 --> 00:07:41,180
This was released before
Barnaby Jack's talk.

156
00:07:41,180 --> 00:07:44,100
There's a lot of modern
protections missing from it

157
00:07:44,100 --> 00:07:46,190
that you would expect in a device

158
00:07:46,190 --> 00:07:48,493
that literally holds thousands of dollars.

159
00:07:51,252 --> 00:07:54,120
So, yeah, so when we opened up the ATM,

160
00:07:54,120 --> 00:07:56,843
we were greeted with
this main circuit board.

161
00:07:58,032 --> 00:07:59,690
It has HDMI, USB, ethernet;

162
00:07:59,690 --> 00:08:02,960
interestingly, a dial
up connection so you can

163
00:08:02,960 --> 00:08:04,120
hook this up to a phone line

164
00:08:04,120 --> 00:08:06,400
and set things up that way.

165
00:08:06,400 --> 00:08:08,740
And then connections to the cash dispenser

166
00:08:08,740 --> 00:08:09,740
and receipt printer.

167
00:08:10,880 --> 00:08:13,760
So, immediately looking at
it, there's HDMI and USB,

168
00:08:13,760 --> 00:08:16,010
so, can we just hook up
a monitor and keyboard

169
00:08:16,010 --> 00:08:17,723
and get something going with it?

170
00:08:18,610 --> 00:08:20,670
Well, unfortunately
there's no Explorer shell

171
00:08:20,670 --> 00:08:22,830
that pops up with this.

172
00:08:22,830 --> 00:08:27,450
It's all in this kiosk mode
application, WinAtm.exe.

173
00:08:27,450 --> 00:08:30,760
So our initial attempts
to interface with it

174
00:08:30,760 --> 00:08:33,060
through a keyboard
actually completely failed.

175
00:08:33,940 --> 00:08:37,920
The keyboard didn't work at
all, even Caps Lock didn't work.

176
00:08:37,920 --> 00:08:41,470
And the reason that that would happen is

177
00:08:41,470 --> 00:08:44,300
there's actually no driver
for the keyboard built

178
00:08:44,300 --> 00:08:45,690
into this operating system image,

179
00:08:45,690 --> 00:08:48,610
which is actually very smart because

180
00:08:49,810 --> 00:08:52,440
there's no situation really
where you'd need a keyboard

181
00:08:52,440 --> 00:08:53,980
on this device.

182
00:08:53,980 --> 00:08:56,630
The pin pad is not treated as a keyboard.

183
00:08:56,630 --> 00:09:00,760
It's all about reducing the
attack surface area there,

184
00:09:00,760 --> 00:09:02,510
so you can't just hook
up a USB rubber ducky

185
00:09:02,510 --> 00:09:04,623
and run some bad scripts.

186
00:09:06,430 --> 00:09:09,350
So, I'm gonna hand it off
to Brenda now to talk about,

187
00:09:09,350 --> 00:09:11,930
since we couldn't interface
with it through keyboard,

188
00:09:11,930 --> 00:09:15,263
what we actually did to work
with this device initially.

189
00:09:18,610 --> 00:09:20,350
- All right, so, on the main port,

190
00:09:20,350 --> 00:09:22,880
we found these very suspicious pads

191
00:09:22,880 --> 00:09:24,610
and on the back around the same location,

192
00:09:24,610 --> 00:09:26,100
there are these resistor pads.

193
00:09:26,100 --> 00:09:29,450
So, we suspect that this might be a JTAG,

194
00:09:29,450 --> 00:09:30,810
and turns out it is.

195
00:09:30,810 --> 00:09:33,380
It is a standard 10-pin ARM connector.

196
00:09:33,380 --> 00:09:35,347
We did need to solider
some, pull-up/pull-down

197
00:09:35,347 --> 00:09:37,120
resistors on the back,

198
00:09:37,120 --> 00:09:39,020
but after we did that, we
were able to connect it

199
00:09:39,020 --> 00:09:41,740
with JTAGulator, identify it as JTAG

200
00:09:41,740 --> 00:09:44,220
and use a JTAG debugger afterwards

201
00:09:44,220 --> 00:09:47,180
to interface with the ATM.

202
00:09:47,180 --> 00:09:48,440
So that's good.

203
00:09:48,440 --> 00:09:50,560
The next step is to dump the flash

204
00:09:50,560 --> 00:09:52,960
in order to get the firmware from the ATM.

205
00:09:52,960 --> 00:09:55,373
Now, on the ATM, the firmware
is stored on the NAND flash

206
00:09:55,373 --> 00:09:58,370
and you can see inside that little red box

207
00:09:58,370 --> 00:10:00,550
is 48 pins and the service mount,

208
00:10:00,550 --> 00:10:03,380
so it was pretty painful
to rip out from the board.

209
00:10:03,380 --> 00:10:05,310
But we did desolder it at one point

210
00:10:05,310 --> 00:10:08,960
and we used the SuperPro,
which is a flash reader-writer

211
00:10:08,960 --> 00:10:11,140
to read and write to the flash.

212
00:10:11,140 --> 00:10:14,320
We did it a couple of times,
but eventually the board died.

213
00:10:14,320 --> 00:10:16,100
The board just can't
handle that many times

214
00:10:16,100 --> 00:10:17,480
of soldering and desoldering,

215
00:10:17,480 --> 00:10:19,610
and we did rip out some pin pads

216
00:10:19,610 --> 00:10:22,410
and we cannot recover it afterwards.

217
00:10:22,410 --> 00:10:24,040
So, at that point we're
kind of panicking, right?

218
00:10:24,040 --> 00:10:26,160
Do we need to buy new ATM?

219
00:10:26,160 --> 00:10:27,383
No, not really, because we found out

220
00:10:27,383 --> 00:10:30,250
that we can just go online
and buy the main board

221
00:10:30,250 --> 00:10:33,353
at $400 a pop at ATMPartMart.com.

222
00:10:34,890 --> 00:10:38,670
So we bought a few main boards

223
00:10:38,670 --> 00:10:41,690
and they did work, but we
don't want them to break again.

224
00:10:41,690 --> 00:10:45,090
So, this time, second try,
let's be more resourceful.

225
00:10:45,090 --> 00:10:46,150
We think maybe there's someone

226
00:10:46,150 --> 00:10:48,780
who does some reverse
engineering and put them online,

227
00:10:48,780 --> 00:10:51,820
maybe the firmware is already
online, packaged nicely,

228
00:10:51,820 --> 00:10:54,820
but it could also be behind
some paywall, we don't know.

229
00:10:54,820 --> 00:10:56,890
But with enough Googling we found out

230
00:10:56,890 --> 00:10:59,450
that the firmware is
actually publicly available.

231
00:10:59,450 --> 00:11:03,050
Now, Trey mentioned the two
versions of ATM that we got.

232
00:11:03,050 --> 00:11:06,630
It turns out that they both
share the same firmware update,

233
00:11:06,630 --> 00:11:08,447
so we only need to download it once

234
00:11:09,450 --> 00:11:10,760
and we started looking at it.

235
00:11:10,760 --> 00:11:11,810
So in the firmware update,

236
00:11:11,810 --> 00:11:15,460
there are three main files:
the bootloader, nk.bin,

237
00:11:15,460 --> 00:11:16,510
which is where the kernel

238
00:11:16,510 --> 00:11:18,980
and other kernel libraries are stored,

239
00:11:18,980 --> 00:11:21,290
and most importantly, a Master.zip file

240
00:11:21,290 --> 00:11:23,493
where all the application binaries are.

241
00:11:23,493 --> 00:11:25,963
This is where the ATM executable is,

242
00:11:25,963 --> 00:11:29,090
it's where the libraries
that the executable uses are,

243
00:11:29,090 --> 00:11:31,130
and it's where all the audio files,

244
00:11:31,130 --> 00:11:33,913
the JPEG that is used by the ATM are.

245
00:11:34,940 --> 00:11:37,810
And when we look at the
application binary to export it

246
00:11:37,810 --> 00:11:40,720
and to export a entry in
the application binary

247
00:11:40,720 --> 00:11:43,000
still has their names on it.

248
00:11:43,000 --> 00:11:44,740
So from a reverse engineer's perspective,

249
00:11:44,740 --> 00:11:48,100
it gets pretty easy to figure
out what each function does.

250
00:11:48,100 --> 00:11:50,560
So for instance, if you want to figure out

251
00:11:50,560 --> 00:11:52,690
the dispensed money functionality,

252
00:11:52,690 --> 00:11:55,740
you just the find the function
that is called Dispense.

253
00:11:55,740 --> 00:11:59,280
Or if you're wanna figure out
how the receipt printer works,

254
00:11:59,280 --> 00:12:02,510
you find the other function
called Print Receipts.

255
00:12:02,510 --> 00:12:04,740
So, that's a win for us, right?

256
00:12:04,740 --> 00:12:06,330
So, with this firmware,

257
00:12:06,330 --> 00:12:09,570
although we tried our first
firmware modification attempt,

258
00:12:09,570 --> 00:12:11,000
we didn't do anything fancy.

259
00:12:11,000 --> 00:12:12,100
We just tried to change

260
00:12:12,100 --> 00:12:14,130
the "Please wait while Loading" screen

261
00:12:14,130 --> 00:12:15,970
to "Please wait while Pwning."

262
00:12:15,970 --> 00:12:17,870
However, when we changed
that one character,

263
00:12:17,870 --> 00:12:20,610
we got stuck on a boot up screen.

264
00:12:20,610 --> 00:12:22,130
Now why does that happen?

265
00:12:22,130 --> 00:12:25,540
That's because in this firmware update

266
00:12:25,540 --> 00:12:28,800
the manufacturer enabled
Microsoft code signing.

267
00:12:28,800 --> 00:12:31,110
It is used to ensure that
the software has not been

268
00:12:31,110 --> 00:12:33,160
corrupted by third parties,

269
00:12:33,160 --> 00:12:35,100
and in our case, our application binaries

270
00:12:35,100 --> 00:12:40,100
are signed with a certificate
that is named MX5300CE.

271
00:12:40,540 --> 00:12:41,887
Now, at that point we don't really know

272
00:12:41,887 --> 00:12:44,690
where the certificate is
and we don't really know

273
00:12:44,690 --> 00:12:47,140
how their verification process works.

274
00:12:47,140 --> 00:12:49,790
So in order to figure out
the digital signature,

275
00:12:49,790 --> 00:12:51,943
we have two ways to do it.

276
00:12:53,610 --> 00:12:55,610
Either we take the time,

277
00:12:55,610 --> 00:12:58,070
reverse engineer the
code signing algorithm,

278
00:12:58,070 --> 00:13:00,840
create out own certificate,
resign everything;

279
00:13:00,840 --> 00:13:04,560
or, we just find where the
certificate verification function

280
00:13:04,560 --> 00:13:06,760
is and return true.

281
00:13:06,760 --> 00:13:08,970
So in order to do it that we
need to take a deeper dive

282
00:13:08,970 --> 00:13:12,153
into how the kernel files
and the kernel is structured.

283
00:13:13,260 --> 00:13:16,800
As mentioned before, there's
this file called nk.bin

284
00:13:16,800 --> 00:13:18,010
where the kernel is.

285
00:13:18,010 --> 00:13:22,560
So, that file is packaged in
something called a BINFS format

286
00:13:22,560 --> 00:13:24,980
and within a BINFS format,

287
00:13:24,980 --> 00:13:27,250
there are these records, right?

288
00:13:27,250 --> 00:13:29,900
So in one of the records,
that's where the kernel

289
00:13:29,900 --> 00:13:31,333
and the libraries are.

290
00:13:33,290 --> 00:13:36,640
So we took out the record
and we started trying

291
00:13:36,640 --> 00:13:38,900
to figure out how that binary works.

292
00:13:38,900 --> 00:13:42,050
So in that binary, there
is the Windows CE header.

293
00:13:42,050 --> 00:13:42,910
It's pretty standard,

294
00:13:42,910 --> 00:13:46,150
you have your magic plate,
you have your start address,

295
00:13:46,150 --> 00:13:50,030
and more importantly, is
where there's a pointer

296
00:13:50,030 --> 00:13:53,570
to the ROMHDR structure inside the binary.

297
00:13:53,570 --> 00:13:57,030
So this structure has some
very interesting information.

298
00:13:57,030 --> 00:13:58,410
It has the physical start address,

299
00:13:58,410 --> 00:14:00,580
it has a physical end
address, number of files,

300
00:14:00,580 --> 00:14:04,530
but more importantly, also
points us to the module entries.

301
00:14:04,530 --> 00:14:09,020
So with that table of contents,
with the ROMHDR structure,

302
00:14:09,020 --> 00:14:12,810
we figured out where nk.exe,
which is a kernel, is,

303
00:14:12,810 --> 00:14:15,240
we figured out where the
library is inside the binary,

304
00:14:15,240 --> 00:14:19,760
and we were able to parse out
the kernel and the libraries.

305
00:14:19,760 --> 00:14:23,380
We use a tool called
eimgfs to extract the files

306
00:14:23,380 --> 00:14:26,400
and we figured out that although
the application binaries

307
00:14:26,400 --> 00:14:29,690
are signed, since, in
this version of windows CE

308
00:14:29,690 --> 00:14:32,520
the kernel is used to verify
the application binary,

309
00:14:32,520 --> 00:14:35,340
the kernel itself is not signed.

310
00:14:35,340 --> 00:14:38,570
We found a file called filesys.dll

311
00:14:38,570 --> 00:14:41,550
which checks for certificate verification.

312
00:14:41,550 --> 00:14:43,570
Now, this is part of
the control flow graph

313
00:14:43,570 --> 00:14:46,320
of the certificate verification function.

314
00:14:46,320 --> 00:14:48,130
We figured that out
because there's a string,

315
00:14:48,130 --> 00:14:50,810
literally there, that says search verify.

316
00:14:50,810 --> 00:14:53,260
And as we're analyzing
the control flow graph,

317
00:14:53,260 --> 00:14:56,520
we realized that every
successful operation

318
00:14:56,520 --> 00:14:58,703
would return a number four to the caller.

319
00:14:59,700 --> 00:15:00,870
So here's what we do.

320
00:15:00,870 --> 00:15:03,730
So, instead of returning an
error code on other paths,

321
00:15:03,730 --> 00:15:06,250
we just modified to always
move the number four,

322
00:15:06,250 --> 00:15:08,983
to R0 which is the return register in ARM.

323
00:15:10,040 --> 00:15:12,370
And now that we patched filesys.dll,

324
00:15:12,370 --> 00:15:13,620
repackaged the whole thing,

325
00:15:13,620 --> 00:15:16,860
we successfully bypassed
signature verification.

326
00:15:16,860 --> 00:15:19,800
And from then on, we're
able to modify our firmware

327
00:15:19,800 --> 00:15:22,273
and add our own custom code to the ATM.

328
00:15:23,330 --> 00:15:27,720
So here's a video of the ATM
having custom code on it.

329
00:15:27,720 --> 00:15:31,740
As you can see, we press a
button and we printed out

330
00:15:31,740 --> 00:15:35,250
a small receipt, like
the portrait of the ATM,

331
00:15:35,250 --> 00:15:38,430
so that we think is kinda
cheeky, but that's how we did it.

332
00:15:38,430 --> 00:15:39,760
So that's good, right?

333
00:15:39,760 --> 00:15:41,973
We got the remodification working,

334
00:15:42,920 --> 00:15:45,920
but now it really has to work as an ATM.

335
00:15:45,920 --> 00:15:46,880
And throughout this process,

336
00:15:46,880 --> 00:15:49,160
we found some very interesting stuff.

337
00:15:49,160 --> 00:15:52,213
So firstly, this is the very old device,

338
00:15:52,213 --> 00:15:53,730
it's a pretty slow device

339
00:15:53,730 --> 00:15:55,880
and each update takes around 20 minutes.

340
00:15:55,880 --> 00:15:57,690
We had to sit there and babysit the ATM

341
00:15:57,690 --> 00:16:01,140
as it was updating and
manually punch in the settings.

342
00:16:01,140 --> 00:16:03,610
We also found a lot of peculiar commands.

343
00:16:03,610 --> 00:16:05,530
So for instance, within five seconds

344
00:16:05,530 --> 00:16:07,990
of the loading screen, if
you hit Clear, Left, Right,

345
00:16:07,990 --> 00:16:10,660
Clear, Clear Cancel, you
can clear the settings

346
00:16:10,660 --> 00:16:12,490
on the NVRAM.

347
00:16:12,490 --> 00:16:15,140
Or, if you hit Enter, Clear,
Cancel, one, two, three,

348
00:16:15,140 --> 00:16:17,010
it would bring you to a password prompt

349
00:16:17,010 --> 00:16:18,580
which brings you to the operator screen

350
00:16:18,580 --> 00:16:21,490
where you change the settings on the ATM.

351
00:16:22,800 --> 00:16:24,970
So we figured out the
firmware update process.

352
00:16:24,970 --> 00:16:25,850
We're pretty good now, right?

353
00:16:25,850 --> 00:16:28,860
We have JTAG, we have the firmware itself

354
00:16:28,860 --> 00:16:30,600
with some debugging symbols,

355
00:16:30,600 --> 00:16:32,010
we have an understanding

356
00:16:32,010 --> 00:16:34,040
of how the firmer update process works,

357
00:16:34,040 --> 00:16:37,990
we were able to modify,
add, and remove executables.

358
00:16:37,990 --> 00:16:40,340
One last hurdle: it keeps on getting stuck

359
00:16:40,340 --> 00:16:41,910
on the host screen.

360
00:16:41,910 --> 00:16:43,130
We got stuck on this screen for while,

361
00:16:43,130 --> 00:16:44,080
trying to connect something.

362
00:16:44,080 --> 00:16:46,163
What is it trying to connect to, exactly?

363
00:16:47,070 --> 00:16:48,647
So we did some digging and it turns out

364
00:16:48,647 --> 00:16:52,600
that the ATM is actually
trying to connect to a service,

365
00:16:52,600 --> 00:16:54,980
called the payment processor.

366
00:16:54,980 --> 00:16:56,650
Now, there are these big card networks

367
00:16:56,650 --> 00:16:57,600
that issue a card to you.

368
00:16:57,600 --> 00:17:01,600
So for instance, it could be
your MasterCard, Amex or Visa.

369
00:17:01,600 --> 00:17:03,500
And when you put in your
debit card into the ATM

370
00:17:03,500 --> 00:17:05,400
and try to draw money out,

371
00:17:05,400 --> 00:17:07,570
there is a middle man
called the payment processor

372
00:17:07,570 --> 00:17:11,080
that would help the ATM
connect to these card networks.

373
00:17:11,080 --> 00:17:13,380
So there are different kinds of protocol

374
00:17:13,380 --> 00:17:17,270
for communication between the
ATM and the payment processor,

375
00:17:17,270 --> 00:17:18,250
but the one that we'd looked at

376
00:17:18,250 --> 00:17:20,263
is called the Triton Protocol.

377
00:17:21,520 --> 00:17:22,580
Now, the Triton Protocol

378
00:17:22,580 --> 00:17:25,360
is a request/response
communication protocol.

379
00:17:25,360 --> 00:17:28,320
There are four different
types of communication pairs,

380
00:17:28,320 --> 00:17:31,010
but the most common ones
are the configuration pair

381
00:17:31,010 --> 00:17:32,600
and a transaction pair.

382
00:17:32,600 --> 00:17:35,040
We did find the documentation online.

383
00:17:35,040 --> 00:17:37,360
However, it is a preliminary specification

384
00:17:37,360 --> 00:17:38,930
and it's very out of date,

385
00:17:38,930 --> 00:17:40,610
so some of the information is wrong

386
00:17:40,610 --> 00:17:42,410
and we needed to use wireshark

387
00:17:42,410 --> 00:17:45,400
to figure out a correct
request/response format.

388
00:17:45,400 --> 00:17:46,420
So this is how it works.

389
00:17:46,420 --> 00:17:48,540
When you first boot up the ATM,

390
00:17:48,540 --> 00:17:50,810
it tries to connect to
this payment processor

391
00:17:51,770 --> 00:17:54,210
and the payment processor
will then receive the request

392
00:17:54,210 --> 00:17:56,080
which sends back a response

393
00:17:56,080 --> 00:17:58,490
having some important information in it,

394
00:17:58,490 --> 00:18:00,030
such as the surcharge amount

395
00:18:00,030 --> 00:18:02,560
that it's going to take on the ATM.

396
00:18:02,560 --> 00:18:05,130
And for subsequent transactions,

397
00:18:05,130 --> 00:18:07,310
it will send a balance inquiry

398
00:18:07,310 --> 00:18:09,720
or withdrawal transaction code.

399
00:18:09,720 --> 00:18:12,940
So the ATM would send a packet
to the payment processor,

400
00:18:12,940 --> 00:18:15,080
having the cart number, encrypted pin,

401
00:18:15,080 --> 00:18:17,190
withdraw balance if
you're withdrawing money.

402
00:18:17,190 --> 00:18:18,810
The payment processor takes that packet,

403
00:18:18,810 --> 00:18:21,600
talks to the network, talk to
the different card networks

404
00:18:21,600 --> 00:18:25,670
and returns whether you can
successfully withdraw money

405
00:18:25,670 --> 00:18:28,960
or not with a success/error code.

406
00:18:28,960 --> 00:18:31,080
So you might think this
information is pretty important.

407
00:18:31,080 --> 00:18:33,720
So is that information encrypted?

408
00:18:33,720 --> 00:18:38,080
And the answer is, yes, it
is encrypted with SSL or TLS.

409
00:18:38,080 --> 00:18:40,740
However, this is an option,
which means that operators

410
00:18:40,740 --> 00:18:43,640
can actually opt out not to use encryption

411
00:18:43,640 --> 00:18:46,420
for Triton traffic.

412
00:18:46,420 --> 00:18:48,040
However, the pin numbers do have

413
00:18:48,040 --> 00:18:51,310
an extra layer of protection and most uses

414
00:18:51,310 --> 00:18:53,173
a Triple DES for encryption.

415
00:18:54,090 --> 00:18:56,400
It's pretty standard Triple
DES that uses two keys,

416
00:18:56,400 --> 00:19:01,400
K1 and K2 so the pin would be
enclosed in its own padding,

417
00:19:01,750 --> 00:19:04,600
the ATM encrypts it,
sends it to the server

418
00:19:04,600 --> 00:19:06,263
so the server would decipher it.

419
00:19:08,480 --> 00:19:10,370
So Triple DES is a block cipher

420
00:19:10,370 --> 00:19:12,760
as a shared key protocol and the setup

421
00:19:12,760 --> 00:19:14,300
is actually pretty interesting.

422
00:19:14,300 --> 00:19:16,940
So when a technician comes to your store

423
00:19:16,940 --> 00:19:18,320
or your restaurant instead of the ATM,

424
00:19:18,320 --> 00:19:20,900
it would punch in two keys.

425
00:19:20,900 --> 00:19:22,530
And these two keys are XOR-ed together

426
00:19:22,530 --> 00:19:24,280
to form a master key.

427
00:19:24,280 --> 00:19:26,130
Now, the server also has
knowledge of this key,

428
00:19:26,130 --> 00:19:29,930
but this is not the final
keys used to encrypt the pin.

429
00:19:29,930 --> 00:19:31,310
So this is how it happens:

430
00:19:31,310 --> 00:19:33,620
once the technician punches in the key,

431
00:19:33,620 --> 00:19:35,590
both the ATM and the payment processor

432
00:19:35,590 --> 00:19:37,373
will have a copy of the master key.

433
00:19:38,630 --> 00:19:40,660
The ATM will tell the
payment processor, hey,

434
00:19:40,660 --> 00:19:41,710
I'm using triple DES.

435
00:19:43,210 --> 00:19:45,170
The payment processor with acknowledge it

436
00:19:45,170 --> 00:19:48,500
and encrypt two other keys
which is the final K1 and K2

437
00:19:48,500 --> 00:19:50,250
with the master key

438
00:19:50,250 --> 00:19:53,067
and sends the encrypted pair
of keys back to the ATM.

439
00:19:54,070 --> 00:19:57,950
The ATM decrypts K1 and
K2 with the master key

440
00:19:57,950 --> 00:20:02,420
and those two keys would be
used to encrypt your pin number.

441
00:20:02,420 --> 00:20:04,981
So when someone enters
their pin on the ATM,

442
00:20:04,981 --> 00:20:07,530
K1 and K2 is encrypted, sorry,

443
00:20:07,530 --> 00:20:10,240
the pin is encrypted with K1 and K2,

444
00:20:10,240 --> 00:20:12,590
and that encrypted pin gets sent over

445
00:20:12,590 --> 00:20:15,813
and the payment processor would
decrypt it with K1 and K2.

446
00:20:17,840 --> 00:20:20,310
So after we understand
the Triton protocol,

447
00:20:20,310 --> 00:20:22,530
how the pin encryption scheme works,

448
00:20:22,530 --> 00:20:25,520
we wrote a server, a
Triton protocol server,

449
00:20:25,520 --> 00:20:27,780
put it on a raspberry PI
and connect to the ATM

450
00:20:27,780 --> 00:20:30,913
and the ATM is finally functional.

451
00:20:36,920 --> 00:20:37,753
- Cool.

452
00:20:41,320 --> 00:20:42,540
So one of the first things you wanna do

453
00:20:42,540 --> 00:20:44,060
on a device like this that's hooked up

454
00:20:44,060 --> 00:20:46,300
to a network is to see what surface area

455
00:20:46,300 --> 00:20:48,533
it exposes in terms of open ports.

456
00:20:50,220 --> 00:20:52,070
So, that's what we did.

457
00:20:52,070 --> 00:20:55,440
We actually found eight open
ports on this device initially.

458
00:20:55,440 --> 00:20:58,920
The first two are the
Windows CE webserver,

459
00:20:58,920 --> 00:21:00,610
the default webserver that's built into

460
00:21:00,610 --> 00:21:03,480
all Windows CE images
if that option's enabled

461
00:21:04,800 --> 00:21:06,007
running on this device.

462
00:21:06,007 --> 00:21:08,480
And when you actually pull it up,

463
00:21:08,480 --> 00:21:12,430
it's just the default
webpage that gets returned.

464
00:21:12,430 --> 00:21:15,780
So, likely this was something
that just wasn't removed

465
00:21:15,780 --> 00:21:19,743
from the image as it was being built.

466
00:21:21,320 --> 00:21:23,720
An interesting aside is that you'll find

467
00:21:23,720 --> 00:21:26,563
a lot of Windows CE
devices on the internet.

468
00:21:28,920 --> 00:21:31,630
There's a couple of queries
you can run to look that up,

469
00:21:31,630 --> 00:21:36,407
but especially something
as old as Windows CE 6.0

470
00:21:37,280 --> 00:21:38,870
on the public internet would be a concern.

471
00:21:38,870 --> 00:21:43,840
But ATMs, I haven't seen many,

472
00:21:44,800 --> 00:21:46,693
if any, ATMs on the public internet.

473
00:21:47,770 --> 00:21:48,983
Mostly other devices.

474
00:21:50,880 --> 00:21:54,000
So, this second port, or
third port that we found here,

475
00:21:54,000 --> 00:21:57,350
the 5555, was a bit puzzling at first,

476
00:21:57,350 --> 00:22:01,030
but we realized it was the
remote management system

477
00:22:02,410 --> 00:22:04,060
default listening port.

478
00:22:04,060 --> 00:22:07,340
So that's something that you use to

479
00:22:08,530 --> 00:22:10,850
update the ATM, to administrate it,

480
00:22:10,850 --> 00:22:13,580
to check balances, that sort of deal.

481
00:22:13,580 --> 00:22:15,890
So that's what that port was.

482
00:22:15,890 --> 00:22:17,890
And then we had these
last five ports here.

483
00:22:17,890 --> 00:22:20,890
So these were ones that
we didn't quite know,

484
00:22:20,890 --> 00:22:23,240
ones that we weren't able
to figure out easily.

485
00:22:24,350 --> 00:22:29,350
So, we tried connecting to
them, but for quite a while

486
00:22:29,800 --> 00:22:33,330
we just weren't able to
get any results from it

487
00:22:33,330 --> 00:22:37,763
or send any data and
have it be acknowledged.

488
00:22:39,010 --> 00:22:40,340
So we'll come back to that in a bit,

489
00:22:40,340 --> 00:22:42,030
but first I'm gonna hand it off to Brenda

490
00:22:42,030 --> 00:22:44,260
to talk a little bit more about RMS

491
00:22:44,260 --> 00:22:46,473
and what remote management system does.

492
00:22:49,670 --> 00:22:51,540
- All right, so what is RMS?

493
00:22:51,540 --> 00:22:55,290
So RMS stands for Remote
Monitoring System Service,

494
00:22:55,290 --> 00:22:57,100
Remote Management System Service.

495
00:22:57,100 --> 00:22:58,420
However you wanna call it,

496
00:22:58,420 --> 00:23:00,890
it's a service that lets customers control

497
00:23:00,890 --> 00:23:02,920
a collection of ATM remotely.

498
00:23:02,920 --> 00:23:05,470
So the customer can use the service

499
00:23:05,470 --> 00:23:07,620
to update a firmware on a bunch of ATMs,

500
00:23:07,620 --> 00:23:08,880
check the amount of money left,

501
00:23:08,880 --> 00:23:11,457
and download a transaction
history from the ATM.

502
00:23:12,340 --> 00:23:14,470
Now, this is an optional service,

503
00:23:14,470 --> 00:23:17,170
meaning that users can
enable or disable it.

504
00:23:17,170 --> 00:23:20,500
The default port for RMS is 5555,

505
00:23:20,500 --> 00:23:22,843
which corresponds to Trey's port scan.

506
00:23:25,075 --> 00:23:28,280
So in RMS, it uses the ATM's ID

507
00:23:28,280 --> 00:23:30,883
and the custom password for verification.

508
00:23:32,110 --> 00:23:33,730
So when we were reverse engineering it,

509
00:23:33,730 --> 00:23:37,160
we realized there's close
to no documentation on RMS.

510
00:23:37,160 --> 00:23:39,550
So at the end, we needed to
use a combination of wireshark,

511
00:23:39,550 --> 00:23:42,890
Ghidra and IDA to figure
out a communication protocol

512
00:23:42,890 --> 00:23:45,820
and the process took around two weeks,

513
00:23:45,820 --> 00:23:48,460
but we eventually got it, right?

514
00:23:48,460 --> 00:23:50,930
So the RMS packet's pretty standard.

515
00:23:50,930 --> 00:23:52,330
You have a start byte, a terminal byte,

516
00:23:52,330 --> 00:23:54,470
there's an LRC at the end.

517
00:23:54,470 --> 00:23:57,520
The more interesting
part is the encoded data

518
00:23:57,520 --> 00:24:01,840
where that part is actually
obfuscated with an extra table

519
00:24:01,840 --> 00:24:03,643
hard-coded in the binary.

520
00:24:05,040 --> 00:24:06,780
And this is actually not the first time

521
00:24:06,780 --> 00:24:08,460
someone looked into RMS.

522
00:24:08,460 --> 00:24:11,350
In fact, in Barnaby Jack's talk in 2010,

523
00:24:11,350 --> 00:24:14,457
he jackpotted the ATM via
a vulnerability in RMS.

524
00:24:15,420 --> 00:24:17,500
And since then, and we
looked at his report,

525
00:24:17,500 --> 00:24:21,160
turns out that the RMS packet
structure is still the same;

526
00:24:21,160 --> 00:24:24,130
obfuscation techniques
didn't really change.

527
00:24:24,130 --> 00:24:28,200
And in his talk, he found
out that a malformed packet

528
00:24:28,200 --> 00:24:30,020
can lead to authentication bypass

529
00:24:30,020 --> 00:24:32,570
and eventual firmware modification.

530
00:24:32,570 --> 00:24:36,340
So, the service should
be secure now, right?

531
00:24:36,340 --> 00:24:38,120
Well, let's put it to the test.

532
00:24:38,120 --> 00:24:40,260
We want to use a fuzzer to fuzz it,

533
00:24:40,260 --> 00:24:42,050
but we don't want to set up memory

534
00:24:42,050 --> 00:24:44,620
or emulate some Windows CE functions.

535
00:24:44,620 --> 00:24:47,750
So we used Boofuzz which
is a network fuzzer.

536
00:24:47,750 --> 00:24:50,460
It takes a lot of heavy work out of it

537
00:24:50,460 --> 00:24:53,270
so we only needed to
define a protocol in code

538
00:24:53,270 --> 00:24:56,400
and Boofuzz would take
it, test different inputs,

539
00:24:56,400 --> 00:24:57,363
and do the rest.

540
00:24:58,360 --> 00:25:00,590
So we did get around five to six crashes

541
00:25:01,739 --> 00:25:03,710
and when we were analyzing the crashes,

542
00:25:03,710 --> 00:25:07,230
we see that every time when
we sent a really large packet,

543
00:25:07,230 --> 00:25:09,680
so any packet more than 10 kilobytes,

544
00:25:09,680 --> 00:25:11,810
the device would crash and reboot.

545
00:25:11,810 --> 00:25:14,152
And just interestingly,
this happens regardless

546
00:25:14,152 --> 00:25:17,383
of whatever password or
ID you send to the device.

547
00:25:18,280 --> 00:25:20,850
And with JTAG we figured
out that a crash happened

548
00:25:20,850 --> 00:25:23,073
in this function called RMS_Proc_Tcp()

549
00:25:24,331 --> 00:25:28,140
in the library that controls
the RMS communication.

550
00:25:28,140 --> 00:25:30,950
So let's take at deeper
dive into this function

551
00:25:30,950 --> 00:25:32,500
and how it works.

552
00:25:32,500 --> 00:25:35,590
So at first, the function
accepts any incoming connections

553
00:25:35,590 --> 00:25:38,180
via TCP, receives the packet,

554
00:25:38,180 --> 00:25:40,250
decryptes over the XOR table,

555
00:25:40,250 --> 00:25:43,390
verifies the ID and the password,

556
00:25:43,390 --> 00:25:46,850
parses the command, close the connection.

557
00:25:46,850 --> 00:25:49,540
And the problem happened at this stage

558
00:25:49,540 --> 00:25:51,320
where it received the RMS packet

559
00:25:51,320 --> 00:25:53,143
and decrypts it over the XOR table.

560
00:25:54,330 --> 00:25:56,920
So what, exactly, went wrong?

561
00:25:56,920 --> 00:26:00,410
Well, it turns out it's
basically a buffer overflow.

562
00:26:00,410 --> 00:26:03,160
In the function that
received the RMS packet,

563
00:26:03,160 --> 00:26:05,760
it copies a TCP packet
over to a global buffer

564
00:26:05,760 --> 00:26:08,010
without any balance check.

565
00:26:08,010 --> 00:26:10,810
And what it did is that
this eventually overrides

566
00:26:10,810 --> 00:26:12,510
a function pointer that is called

567
00:26:12,510 --> 00:26:14,620
when the application exits.

568
00:26:14,620 --> 00:26:17,310
And this copy happens before
any kind of terminal ID

569
00:26:17,310 --> 00:26:19,240
or password verification.

570
00:26:19,240 --> 00:26:21,790
So the consequences, as
long as you understand

571
00:26:21,790 --> 00:26:22,623
a package structure,

572
00:26:22,623 --> 00:26:25,050
as long as your package
structure is sound,

573
00:26:25,050 --> 00:26:26,580
the buffer overflow could happen

574
00:26:26,580 --> 00:26:28,460
and you can write shell
code in your packet

575
00:26:28,460 --> 00:26:31,113
to lead to arbitrary code execution.

576
00:26:32,810 --> 00:26:34,600
Now, what can the attacker do?

577
00:26:34,600 --> 00:26:37,390
We were investigating it and
we realized that most DLLs

578
00:26:37,390 --> 00:26:39,480
are paged out as the application exits,

579
00:26:39,480 --> 00:26:43,100
except for the functions
that controls the NVRAM.

580
00:26:43,100 --> 00:26:46,640
And in this device, in this
ATM, NVRAM is pretty important

581
00:26:46,640 --> 00:26:48,910
because it basically controls anything

582
00:26:48,910 --> 00:26:50,500
on the admin screen's control.

583
00:26:50,500 --> 00:26:52,547
It stores all the settings on the ATM.

584
00:26:54,930 --> 00:26:58,220
So for instance, an
attacker can point the ATM

585
00:26:58,220 --> 00:27:01,020
to the malicious server
because within the NVRAM

586
00:27:01,020 --> 00:27:05,040
it stores the IP of the payment processor.

587
00:27:05,040 --> 00:27:07,480
It can change the denomination of the ATM.

588
00:27:07,480 --> 00:27:09,210
So for instance, if your ATM is supposed

589
00:27:09,210 --> 00:27:11,820
to have $20 bills, you can
change your denomination

590
00:27:11,820 --> 00:27:16,190
to $1 bills in order to extract
more money from the ATM.

591
00:27:16,190 --> 00:27:21,190
And let's go to a demo
of the RMS vulnerability.

592
00:27:22,910 --> 00:27:24,930
Alright, so we have our ATM here,

593
00:27:24,930 --> 00:27:29,080
it has RMS running on the background.

594
00:27:29,080 --> 00:27:34,080
So now Trey is going to send
a packet over to the ATM.

595
00:27:34,550 --> 00:27:35,757
And as you see here it says

596
00:27:35,757 --> 00:27:38,090
"Remote monitoring system is in progress."

597
00:27:38,090 --> 00:27:39,920
Trey sends a malformed packet over,

598
00:27:39,920 --> 00:27:42,600
but it still looks fine here, right?

599
00:27:42,600 --> 00:27:44,900
So, now let's say I'm the operator,

600
00:27:44,900 --> 00:27:47,470
and that I need to
perform a firmware update.

601
00:27:47,470 --> 00:27:50,840
So I will do Enter, Clear
Cancel one, two, three

602
00:27:50,840 --> 00:27:55,747
in order to go into a password prompt.

603
00:27:55,747 --> 00:27:59,130
And then I'd put the operator password in.

604
00:27:59,130 --> 00:28:01,240
That brings me to an
administration screen.

605
00:28:01,240 --> 00:28:03,140
You can change a whole
bunch of stuff here,

606
00:28:03,140 --> 00:28:04,830
but right now it says I'm
doing a firmware update.

607
00:28:04,830 --> 00:28:06,543
I'll go into the system setup.

608
00:28:07,490 --> 00:28:10,470
System control, software update.

609
00:28:10,470 --> 00:28:13,210
Yes, I want to do a software update.

610
00:28:13,210 --> 00:28:16,010
So this is where the
shell code gets executed,

611
00:28:16,010 --> 00:28:20,080
because as the application exits cleanly,

612
00:28:20,080 --> 00:28:22,003
the function pointer that we overwrote

613
00:28:23,180 --> 00:28:26,113
would be called and that
would execute our shell code.

614
00:28:28,227 --> 00:28:31,740
In this specific demo,
we set the shell code

615
00:28:31,740 --> 00:28:36,170
so that instead of pointing
to the raspberry PI

616
00:28:36,170 --> 00:28:38,410
with the Triton Protocol running,

617
00:28:38,410 --> 00:28:41,870
it would point back to Trey's laptop

618
00:28:41,870 --> 00:28:45,083
which has the Triton server running.

619
00:28:47,280 --> 00:28:51,000
So as you see here, it
just updated successfully

620
00:28:51,000 --> 00:28:54,690
and we needed to wait a
few seconds to reboot.

621
00:28:54,690 --> 00:28:57,293
Once again this device is pretty
slow, as you can see here.

622
00:28:57,293 --> 00:29:01,650
It's going to take a while for
it to go past the boot screen

623
00:29:01,650 --> 00:29:06,080
and go back into normal operation again.

624
00:29:06,080 --> 00:29:08,740
So, one interesting thing to note is that

625
00:29:08,740 --> 00:29:10,870
as we were writing the shell code,

626
00:29:10,870 --> 00:29:13,090
we needed to figure out
where the functions are

627
00:29:13,090 --> 00:29:15,303
and as Trey said, since
this is a pretty old device,

628
00:29:15,303 --> 00:29:17,570
it's a pretty old version of Windows CE,

629
00:29:17,570 --> 00:29:21,770
a lot of the modern protections against,

630
00:29:21,770 --> 00:29:24,390
a lot of modern protections
and binaries are implemented.

631
00:29:24,390 --> 00:29:28,090
So for instance, we don't
see any ASR implemented

632
00:29:28,090 --> 00:29:30,350
in the binary through JTAG.

633
00:29:30,350 --> 00:29:32,550
So what we're able to do
is that once we use JTAG

634
00:29:32,550 --> 00:29:34,460
to figure out where all the libraries are

635
00:29:34,460 --> 00:29:37,160
in one boot process, the
next time we reboot it,

636
00:29:37,160 --> 00:29:39,380
those libraries, the executables

637
00:29:39,380 --> 00:29:43,030
would be loaded back
into the same location

638
00:29:43,030 --> 00:29:48,030
which makes the process of
writing shell code easier.

639
00:29:49,510 --> 00:29:52,780
And as I mentioned before,
the shell code would point

640
00:29:52,780 --> 00:29:56,990
the ATM to Trey's computer
and how it does this

641
00:29:56,990 --> 00:29:59,900
is modify some settings on the NVRAM.

642
00:29:59,900 --> 00:30:03,340
The NVRAM controls all the settings.

643
00:30:03,340 --> 00:30:05,470
Like it controls whether
SSL is turned on or off,

644
00:30:05,470 --> 00:30:09,940
it controls where the ATM is pointing to,

645
00:30:09,940 --> 00:30:14,100
and it's also a pretty simple
function to reverse engineer.

646
00:30:14,100 --> 00:30:15,640
It takes two numbers

647
00:30:15,640 --> 00:30:18,450
and each pair of number would point to,

648
00:30:18,450 --> 00:30:20,910
for instance, whether SSL
was turned on or if not,

649
00:30:20,910 --> 00:30:24,163
it would point to like the IP string,

650
00:30:25,250 --> 00:30:28,613
the IP string of the
payment processor host.

651
00:30:29,670 --> 00:30:32,883
So as you see here, now it's initializing,

652
00:30:33,740 --> 00:30:35,730
It takes a while, it's
loading and it's trying

653
00:30:35,730 --> 00:30:39,360
to interface with the
peripherals that you get.

654
00:30:39,360 --> 00:30:41,550
It prints out a receipt
whenever it reboots,

655
00:30:41,550 --> 00:30:44,187
so it's to say "Test printing OK"

656
00:30:44,187 --> 00:30:49,187
and it prints out a version
the printer within the ATM.

657
00:30:54,410 --> 00:30:56,760
It takes a while to initialize,
but after initialize,

658
00:30:56,760 --> 00:31:01,760
you will see that instead of
pointing to the ATM on the,

659
00:31:02,910 --> 00:31:04,730
sorry, instead of pointing
to the payment processor

660
00:31:04,730 --> 00:31:08,154
on the raspberry PI, it would
point to the Triton server

661
00:31:08,154 --> 00:31:10,853
that Trey is running on his computer.

662
00:31:11,903 --> 00:31:12,760
(laughing) It makes a lot of noises,

663
00:31:12,760 --> 00:31:14,333
like it's trying to print something,

664
00:31:14,333 --> 00:31:17,223
it's trying to make sure that
the cash dispenser works.

665
00:31:18,070 --> 00:31:20,670
All right, now, it's trying
to connect to the host.

666
00:31:20,670 --> 00:31:23,993
And as you can see on Trey's computer,

667
00:31:24,881 --> 00:31:28,720
our malicious payment
processor is working,

668
00:31:28,720 --> 00:31:30,650
it's interfacing with the ATM.

669
00:31:30,650 --> 00:31:32,910
So I have a card here.

670
00:31:32,910 --> 00:31:35,110
It's one of the cards
that we printed in-house

671
00:31:35,110 --> 00:31:35,943
at Red Balloon.

672
00:31:37,793 --> 00:31:40,120
So it has tracks here
and track two is where

673
00:31:40,120 --> 00:31:41,403
the interesting information's stored.

674
00:31:41,403 --> 00:31:44,110
It's where your card
number is stored, in fact.

675
00:31:44,110 --> 00:31:45,630
So let's say I'm a customer

676
00:31:45,630 --> 00:31:47,280
and I wanted to check my balance.

677
00:31:50,810 --> 00:31:53,050
Right, it takes a while.

678
00:31:53,050 --> 00:31:54,047
Alright.

679
00:31:54,047 --> 00:31:55,768
I hit English.

680
00:31:55,768 --> 00:31:58,223
It asks me to enter a
pin, it can be anything.

681
00:31:59,620 --> 00:32:01,020
Enter.

682
00:32:01,020 --> 00:32:04,280
And let's say I want to
inquire my balance on the ATM.

683
00:32:06,700 --> 00:32:09,050
Let's say, I want to check my checking,

684
00:32:09,050 --> 00:32:11,120
no receipt, thank you.

685
00:32:11,120 --> 00:32:12,730
And it is connecting to the host,

686
00:32:12,730 --> 00:32:16,210
although it says ineligible account,

687
00:32:16,210 --> 00:32:18,940
on Trey's computer it can actually see

688
00:32:18,940 --> 00:32:23,053
the expiration date of the card
and the card number itself.

689
00:32:25,490 --> 00:32:27,363
All right, back to you, Trey.

690
00:32:35,870 --> 00:32:38,270
- Cool, so we just saw the RMS demo,

691
00:32:38,270 --> 00:32:40,140
and now I wanna talk a bit more about

692
00:32:41,090 --> 00:32:43,740
interacting with this device
and what we had to do,

693
00:32:43,740 --> 00:32:46,910
actually, to get things to
work on it since we didn't have

694
00:32:46,910 --> 00:32:51,910
a keyboard or any HRD device
to really interface with it.

695
00:32:52,040 --> 00:32:55,730
So we had to actually take a look at this.

696
00:32:55,730 --> 00:32:59,170
So there's an active sync,
probably, port on here,

697
00:32:59,170 --> 00:33:01,550
but we couldn't quite get that working.

698
00:33:01,550 --> 00:33:03,120
Active sync is the way you would work

699
00:33:03,120 --> 00:33:06,360
with Windows CE devices to interface

700
00:33:06,360 --> 00:33:09,150
with them on a desktop computer.

701
00:33:09,150 --> 00:33:10,110
But we couldn't get that working,

702
00:33:10,110 --> 00:33:14,173
so we actually compiled our own tool.

703
00:33:15,100 --> 00:33:17,710
This is Windows CE, it's
a standard platform.

704
00:33:17,710 --> 00:33:19,810
How difficult should it be to be able

705
00:33:19,810 --> 00:33:22,713
to just compile something to work on it?

706
00:33:24,343 --> 00:33:26,530
Well, the caveat here is
that it's Windows CE 6.0,

707
00:33:26,530 --> 00:33:30,023
so this was released in 2006 initially.

708
00:33:30,970 --> 00:33:32,100
So we actually had to go all the way back

709
00:33:32,100 --> 00:33:36,023
to Visual Studio 2008 to
get this really going.

710
00:33:37,670 --> 00:33:40,780
It's quite an old IDE, but
we knew it had worked well

711
00:33:40,780 --> 00:33:42,630
under Windows XP.

712
00:33:42,630 --> 00:33:46,170
So, what we were able to do with this IDE

713
00:33:46,170 --> 00:33:49,000
was actually build some C# applications,

714
00:33:49,000 --> 00:33:51,680
get them to run on the .net framework,

715
00:33:51,680 --> 00:33:53,240
which is actually on this device.

716
00:33:53,240 --> 00:33:55,590
It has a .net compact framework on here.

717
00:33:57,190 --> 00:33:59,000
However, it's fairly old,

718
00:33:59,000 --> 00:34:02,930
so a lot of examples for C# code

719
00:34:02,930 --> 00:34:06,010
if you're not incredibly
familiar with it initially.

720
00:34:06,010 --> 00:34:07,940
You can't just copy paste
off of stack overflow

721
00:34:07,940 --> 00:34:09,440
to get things working on here.

722
00:34:11,050 --> 00:34:13,260
A lot of useful features are missing,

723
00:34:13,260 --> 00:34:17,340
but in the end, we did get an
application working on here.

724
00:34:17,340 --> 00:34:20,210
So we really wanted an
application for our CTF

725
00:34:20,210 --> 00:34:23,440
to be able to have a webserver

726
00:34:23,440 --> 00:34:26,210
that people could connect to
to interface with the ATM.

727
00:34:27,710 --> 00:34:28,950
So this was the start of that.

728
00:34:28,950 --> 00:34:31,473
We actually popped a dialog box here.

729
00:34:33,880 --> 00:34:38,880
And we could've used
the built-in webserver

730
00:34:39,640 --> 00:34:42,270
on this device that you saw
on the port scan earlier.

731
00:34:42,270 --> 00:34:46,210
However, there wasn't any
DLL or any capabilities

732
00:34:46,210 --> 00:34:49,440
for any sort of dynamic
content or scripting.

733
00:34:49,440 --> 00:34:50,850
So that would've been a bit difficult

734
00:34:50,850 --> 00:34:52,170
to actually get up and running,

735
00:34:52,170 --> 00:34:54,263
so instead we created our own webserver.

736
00:34:56,120 --> 00:34:57,400
Which was difficult in its own right

737
00:34:57,400 --> 00:35:01,490
because HTTP primitives
aren't in the .net version

738
00:35:01,490 --> 00:35:04,350
we were using so we had to build things

739
00:35:04,350 --> 00:35:06,470
on top of just straight TCP sockets.

740
00:35:06,470 --> 00:35:08,960
But with some good examples,

741
00:35:08,960 --> 00:35:12,370
we fast-forwarded a bit and
had a webserver working,

742
00:35:12,370 --> 00:35:14,590
which is what you see here.

743
00:35:14,590 --> 00:35:18,030
So this is our test setup.

744
00:35:18,030 --> 00:35:22,030
This is a device emulator
running the .net code

745
00:35:22,030 --> 00:35:27,023
and displaying our CTF webpage there.

746
00:35:29,790 --> 00:35:31,920
So for launching on
startup, there's a number

747
00:35:31,920 --> 00:35:34,590
of ways we could have gone about this but,

748
00:35:34,590 --> 00:35:37,770
again, we didn't quite
have any way to interface

749
00:35:37,770 --> 00:35:40,630
with the ATM at this point, since we are

750
00:35:42,030 --> 00:35:44,070
trying to compile our own tool.

751
00:35:44,070 --> 00:35:47,860
So, in order to be able
to launch that tool,

752
00:35:47,860 --> 00:35:49,790
to be able to probe how the device works,

753
00:35:49,790 --> 00:35:53,770
we actually used the
debugger every single time

754
00:35:53,770 --> 00:35:57,200
we wanted to run it and
hijacked the startup process,

755
00:35:57,200 --> 00:35:59,650
the call and create
process and pointed that

756
00:35:59,650 --> 00:36:04,603
towards our custom server.

757
00:36:05,460 --> 00:36:07,560
So, we could reverse the startup procedure

758
00:36:07,560 --> 00:36:09,660
and do the proper way
through registry edits

759
00:36:09,660 --> 00:36:12,030
which can be a bit
difficult on Windows CE,

760
00:36:12,030 --> 00:36:14,980
but what we ended up doing was actually

761
00:36:14,980 --> 00:36:18,210
just taking the executable
that was on here

762
00:36:19,250 --> 00:36:23,000
that would normally be
launched called WinAtm.exe,

763
00:36:23,000 --> 00:36:24,380
renamed it to something else,

764
00:36:24,380 --> 00:36:28,560
and then named our own
executable WinAtm.exe

765
00:36:28,560 --> 00:36:33,080
and then launched the
original process that

766
00:36:34,450 --> 00:36:38,573
would normally be launched as
a child process of our server.

767
00:36:40,530 --> 00:36:44,430
So we've got this C# code
running, it's all good,

768
00:36:44,430 --> 00:36:47,660
but what would it take to
get some native code running?

769
00:36:47,660 --> 00:36:49,843
You know, really dig into it here?

770
00:36:51,260 --> 00:36:53,590
And what we ended up needing

771
00:36:53,590 --> 00:36:55,850
to do was use Visual Studio 2005,

772
00:36:55,850 --> 00:36:57,880
going even further back

773
00:36:57,880 --> 00:37:01,970
and install a number of different packages

774
00:37:01,970 --> 00:37:05,670
to actually get this to work,
but it was quite a pain.

775
00:37:05,670 --> 00:37:08,823
But in the end it was actually
quite worth it because,

776
00:37:10,050 --> 00:37:14,530
in one of the most amazing
Microsoft things I've ever seen,

777
00:37:14,530 --> 00:37:18,270
you can click through a
wizard and from scratch,

778
00:37:18,270 --> 00:37:22,790
build an OS image, which is
a pretty amazing concept.

779
00:37:22,790 --> 00:37:26,970
You're clicking little check
boxes to enable or disable

780
00:37:26,970 --> 00:37:31,240
different features and change
how things are built into it.

781
00:37:31,240 --> 00:37:33,550
So from that, we were able to actually see

782
00:37:35,190 --> 00:37:38,073
different DLLs that would
normally be on the ATM,

783
00:37:38,073 --> 00:37:40,553
like the keyboard driver
and things like that.

784
00:37:42,450 --> 00:37:45,890
But by this point, we had already gotten

785
00:37:45,890 --> 00:37:47,340
our webserver up and running,

786
00:37:48,220 --> 00:37:50,360
we've got it launching every boot,

787
00:37:50,360 --> 00:37:52,190
and so we built all
these commands to be able

788
00:37:52,190 --> 00:37:54,860
to interface with the device,

789
00:37:54,860 --> 00:37:57,710
check out what processes were running,

790
00:37:57,710 --> 00:38:01,660
add or remove registry
keys, add or remove files,

791
00:38:01,660 --> 00:38:04,160
any sort of thing we'd
need to really dig in

792
00:38:04,160 --> 00:38:08,060
and research it and have fun
diversion while we did it.

793
00:38:08,060 --> 00:38:11,460
So this was actually,
we found a build of Doom

794
00:38:11,460 --> 00:38:15,030
for this device and we actually
got it up and working here.

795
00:38:15,030 --> 00:38:17,280
This was an Easter egg
in some of our earlier

796
00:38:18,680 --> 00:38:21,673
CTF challenges to be able to find this.

797
00:38:23,920 --> 00:38:25,400
But (chuckling) it ended up,

798
00:38:25,400 --> 00:38:26,900
I'm not sure if it was
eating up all the memory,

799
00:38:26,900 --> 00:38:31,550
but the system would just
randomly reboot partway through

800
00:38:31,550 --> 00:38:32,610
after Doom had been launched.

801
00:38:32,610 --> 00:38:36,680
So we had to remove that
for further CTF challenges,

802
00:38:36,680 --> 00:38:40,210
but it was fun to get it up
and running while we had it.

803
00:38:40,210 --> 00:38:44,960
And despite being fairly
slower and older ARM core,

804
00:38:44,960 --> 00:38:46,210
we were able to run this.

805
00:38:48,570 --> 00:38:49,910
So, one of the things we did next

806
00:38:49,910 --> 00:38:51,880
was take a look at the registry,

807
00:38:51,880 --> 00:38:56,620
see how things were configured
and look for any clues of

808
00:38:56,620 --> 00:38:59,173
things that might be
interesting on this device.

809
00:39:00,070 --> 00:39:02,320
So, one of the things
that we initially found

810
00:39:04,190 --> 00:39:08,140
that was kind of familiar
were some of these keys,

811
00:39:08,140 --> 00:39:10,290
and you might take a look
at them and recognize

812
00:39:10,290 --> 00:39:13,160
those numbers from some of the ports

813
00:39:13,160 --> 00:39:17,280
that were open earlier
and even more interesting,

814
00:39:17,280 --> 00:39:20,163
if you take a look at the key name,

815
00:39:23,520 --> 00:39:27,310
it's a little concerning
because you start to think

816
00:39:27,310 --> 00:39:29,290
maybe this cash dispenser
is somehow related

817
00:39:29,290 --> 00:39:33,600
to this open port on 8004.

818
00:39:33,600 --> 00:39:37,090
So what is this, what are
we taking a look at here?

819
00:39:37,090 --> 00:39:38,815
Well, here's a hint.

820
00:39:38,815 --> 00:39:40,973
XFS is what this is.

821
00:39:41,990 --> 00:39:45,020
Not the file system, the money one,

822
00:39:45,020 --> 00:39:48,940
and XFS is this standard
platform for financial devices

823
00:39:50,840 --> 00:39:53,470
that exposes this sort of middleware,

824
00:39:53,470 --> 00:39:56,560
where you can have a Windows
application send a command

825
00:39:56,560 --> 00:40:00,270
that gets passed through
these layers of abstraction

826
00:40:00,270 --> 00:40:02,680
and go to the service provider;

827
00:40:02,680 --> 00:40:04,050
the service provider being the thing

828
00:40:04,050 --> 00:40:06,940
that actually is able
to interface directly

829
00:40:06,940 --> 00:40:08,450
with the devices.

830
00:40:08,450 --> 00:40:11,200
So this allows you to build things

831
00:40:11,200 --> 00:40:13,150
in sort of Legos fashion, so you can

832
00:40:14,630 --> 00:40:18,410
swap out different
components of your system,

833
00:40:18,410 --> 00:40:21,510
theoretically, swap out
different cash dispensers,

834
00:40:21,510 --> 00:40:22,690
swap out different card readers,

835
00:40:22,690 --> 00:40:25,520
and there are all these
standard different devices

836
00:40:25,520 --> 00:40:26,770
that you can put on here.

837
00:40:28,250 --> 00:40:29,470
So you'll see the cash dispenser,

838
00:40:29,470 --> 00:40:33,593
you'll see the ID card unit
which is reading your card,

839
00:40:34,600 --> 00:40:37,963
pin pad, things of that
nature are all in here.

840
00:40:39,720 --> 00:40:42,800
So what is XFS, where does this come from?

841
00:40:42,800 --> 00:40:44,700
It started out as a Microsoft thing

842
00:40:44,700 --> 00:40:47,380
where they wanted to create
the standard platform

843
00:40:47,380 --> 00:40:49,433
for Windows for financial devices.

844
00:40:50,580 --> 00:40:52,990
They seem to have really
succeeded because this is

845
00:40:54,580 --> 00:40:58,900
one of the industry
standards for how you would

846
00:40:58,900 --> 00:41:01,523
set up an ATM or any
other financial device.

847
00:41:02,690 --> 00:41:05,720
And so Microsoft handed it off to CEN,

848
00:41:05,720 --> 00:41:09,050
the European Committee
for Standardization,

849
00:41:09,050 --> 00:41:10,950
who's actually the maintainers
of the standard now

850
00:41:10,950 --> 00:41:13,530
and you can go on their website and find

851
00:41:13,530 --> 00:41:17,160
all of these documents
detailing how devices

852
00:41:17,160 --> 00:41:18,503
are hooked up in XFS.

853
00:41:19,850 --> 00:41:22,180
So, for example, this
is the cash dispenser

854
00:41:24,090 --> 00:41:28,290
device description document here.

855
00:41:28,290 --> 00:41:30,810
So this is great for people
building these devices.

856
00:41:30,810 --> 00:41:34,240
It creates a fairly open
ecosystem that allows

857
00:41:36,460 --> 00:41:40,660
manufacturers to be able to
swap out different things

858
00:41:40,660 --> 00:41:44,160
and have that, but then
also causes an issue

859
00:41:44,160 --> 00:41:44,993
in terms that

860
00:41:46,470 --> 00:41:49,040
it's a fairly homogenous
platform that allows

861
00:41:50,650 --> 00:41:54,970
people with very little
understanding of ATMs

862
00:41:54,970 --> 00:41:59,970
to actually be able to create
some fairly portable malware,

863
00:42:00,550 --> 00:42:03,130
to be able to use on
these different devices

864
00:42:03,130 --> 00:42:05,040
that takes advantage of the XFS interface.

865
00:42:05,040 --> 00:42:06,340
And we've seen a number of

866
00:42:07,560 --> 00:42:09,660
different pieces of malware that use this.

867
00:42:11,580 --> 00:42:13,540
So going back to the ports, again,

868
00:42:13,540 --> 00:42:15,900
this is something XFS-related.

869
00:42:15,900 --> 00:42:17,800
So, we see those numbers there

870
00:42:18,720 --> 00:42:23,163
and what I did was go through and map out.

871
00:42:24,610 --> 00:42:26,640
You can see that after LOGICAL_SERVICES,

872
00:42:26,640 --> 00:42:29,323
there's Auxiliaries,
CardReader, CashDispenser,

873
00:42:30,190 --> 00:42:32,410
and then there's also the device class,

874
00:42:32,410 --> 00:42:36,250
which is what XFS would call that device.

875
00:42:36,250 --> 00:42:41,250
So IDC and CDM for the cash dispenser.

876
00:42:41,390 --> 00:42:42,970
And created this mapping

877
00:42:44,430 --> 00:42:46,710
showing which registry key corresponds

878
00:42:46,710 --> 00:42:50,163
to which device class, which
corresponds to which port.

879
00:42:51,540 --> 00:42:52,650
So you can see here, again,

880
00:42:52,650 --> 00:42:55,660
that this is, the device classes

881
00:42:55,660 --> 00:43:00,253
or the standard XFS designations
for these types of devices.

882
00:43:01,570 --> 00:43:03,343
So what does this tell us?

883
00:43:04,900 --> 00:43:06,520
There's open ports.

884
00:43:06,520 --> 00:43:08,213
They're related to XFS somehow,

885
00:43:09,630 --> 00:43:12,253
Can we make it dump out some money?

886
00:43:13,923 --> 00:43:15,100
Well, the problem again is,

887
00:43:15,100 --> 00:43:16,470
we can connect to these ports,

888
00:43:16,470 --> 00:43:18,690
but we can't get anything out of them.

889
00:43:18,690 --> 00:43:20,500
We don't see any traffic and we don't know

890
00:43:20,500 --> 00:43:22,420
what to send into them.

891
00:43:22,420 --> 00:43:26,100
So let's sniff it, let's
see if there's anything

892
00:43:26,100 --> 00:43:30,993
on these ports, even on the
local network interface on here,

893
00:43:32,420 --> 00:43:34,370
that's listening and sending messages

894
00:43:35,840 --> 00:43:39,440
to see if we can take that and use it

895
00:43:39,440 --> 00:43:42,440
to build our own messages or replay them.

896
00:43:42,440 --> 00:43:45,190
The problem here being that
this is a Windows CE device

897
00:43:46,370 --> 00:43:50,040
and you can't just download
wireshark for Windows CE

898
00:43:50,040 --> 00:43:52,950
because, as it very helpfully points out,

899
00:43:52,950 --> 00:43:54,800
there is no wireshark for Windows CE.

900
00:43:56,470 --> 00:44:00,930
So, Windows CE does have
packet capture capabilities,

901
00:44:00,930 --> 00:44:03,170
but it's not built into this ATM image

902
00:44:03,170 --> 00:44:06,560
and I didn't really
want to take the time to

903
00:44:08,567 --> 00:44:10,780
try and figure out how to
port it to this ATM image.

904
00:44:10,780 --> 00:44:13,743
So, the easiest way to do
this ended up being JTAG.

905
00:44:15,000 --> 00:44:18,170
And the plan of attack
here was to intercept

906
00:44:18,170 --> 00:44:21,560
the socket create calls,
get the handles for them,

907
00:44:21,560 --> 00:44:26,073
and then map those handles
to the different services,

908
00:44:27,120 --> 00:44:28,770
intercept socket send and receive calls,

909
00:44:28,770 --> 00:44:32,520
and look at the buffers
and save all that traffic

910
00:44:32,520 --> 00:44:34,170
and then acquire some cutlets.

911
00:44:34,170 --> 00:44:37,610
So, what we did was went through,

912
00:44:37,610 --> 00:44:41,363
found where these registry
strings were being read.

913
00:44:42,600 --> 00:44:44,220
And from that, we were able to figure out

914
00:44:44,220 --> 00:44:47,980
which socket creation call

915
00:44:48,880 --> 00:44:52,563
corresponded to which
different device class.

916
00:44:53,480 --> 00:44:56,420
And here you'll see that
this is where we're hooking

917
00:44:56,420 --> 00:44:59,350
the send and receive functions in Winsock,

918
00:44:59,350 --> 00:45:03,650
to be able to look at the
buffer and take the data

919
00:45:03,650 --> 00:45:05,340
that is either being sent or the data

920
00:45:05,340 --> 00:45:08,840
that has been received,
save that to a file,

921
00:45:08,840 --> 00:45:11,580
and take a look at it.

922
00:45:11,580 --> 00:45:12,890
So this is all in (indiscernible),

923
00:45:12,890 --> 00:45:15,430
this is a JTAG debugger that we use

924
00:45:15,430 --> 00:45:17,733
and is great for scripting like this.

925
00:45:19,456 --> 00:45:20,780
So as you can see here,

926
00:45:20,780 --> 00:45:22,130
we have a number of packets that came in.

927
00:45:22,130 --> 00:45:24,300
Some of these are sent,
some of these are received.

928
00:45:24,300 --> 00:45:26,890
So, it's just a bunch of binary blobs

929
00:45:26,890 --> 00:45:28,180
and there's not very much

930
00:45:28,180 --> 00:45:30,660
that we can easily recognize in there.

931
00:45:30,660 --> 00:45:33,200
There is the US dollars
string in the packet

932
00:45:33,200 --> 00:45:37,210
in the lower-right, but it's
nothing immediately obvious.

933
00:45:37,210 --> 00:45:40,670
So, first thing we tried
was, can we just replay

934
00:45:40,670 --> 00:45:41,680
one of these packets?

935
00:45:41,680 --> 00:45:44,850
'Cause we were doing actions on the ATM

936
00:45:44,850 --> 00:45:47,020
as we were capturing these packets,

937
00:45:47,020 --> 00:45:49,560
so we can roughly correlate
what might've been sent

938
00:45:49,560 --> 00:45:52,463
to the cash dispenser to
cause it to dispense cash.

939
00:45:53,640 --> 00:45:58,640
So yes, we can just replay
and send out some cash

940
00:46:00,270 --> 00:46:01,670
from the cash dispenser.

941
00:46:01,670 --> 00:46:03,470
It was actually fairly straightforward

942
00:46:03,470 --> 00:46:06,220
to be able to do that and then you can see

943
00:46:06,220 --> 00:46:08,163
we dumped out some cash here.

944
00:46:09,960 --> 00:46:14,650
It was no need to learn how
all of this structure works,

945
00:46:14,650 --> 00:46:16,580
no need to learn how to
work with these fields.

946
00:46:16,580 --> 00:46:20,800
You can literally just take
this packet that you've seen,

947
00:46:20,800 --> 00:46:22,970
replay it to dispense cash,

948
00:46:22,970 --> 00:46:24,803
and that was fairly straightforward.

949
00:46:26,230 --> 00:46:29,390
So that worked in the case
where we just wanted to

950
00:46:29,390 --> 00:46:30,910
dispense the same amount of cash,

951
00:46:30,910 --> 00:46:33,240
but what if we wanted
to dispense as much cash

952
00:46:33,240 --> 00:46:36,750
as possible over and over?

953
00:46:36,750 --> 00:46:39,700
Well, after looking at
this dump for a while,

954
00:46:39,700 --> 00:46:41,310
we were able to figure out some patterns

955
00:46:41,310 --> 00:46:43,570
and see the structures in there,

956
00:46:43,570 --> 00:46:47,950
especially after looking
at the XFS documentation.

957
00:46:47,950 --> 00:46:49,810
And we created some
scripts that allowed us

958
00:46:49,810 --> 00:46:52,450
to parse these packets and
then see what was in there.

959
00:46:52,450 --> 00:46:57,293
So for example, here, we
have a packet where we,

960
00:46:58,940 --> 00:47:02,350
it's a result of reading a card
that's been put in the ATM,

961
00:47:02,350 --> 00:47:04,130
so you can see the card number

962
00:47:04,130 --> 00:47:08,750
there is 5555, 5555, 5555, 5555.

963
00:47:08,750 --> 00:47:10,303
That's the track two data.

964
00:47:12,100 --> 00:47:15,710
And we have these fields here that

965
00:47:15,710 --> 00:47:17,270
might not be immediately obvious,

966
00:47:17,270 --> 00:47:20,760
this command code notably.

967
00:47:20,760 --> 00:47:23,260
So if you look in the XFS documentation,

968
00:47:23,260 --> 00:47:26,720
you can see that there is
this concept of a device class

969
00:47:26,720 --> 00:47:31,040
and then a service class
and then a service offset.

970
00:47:31,040 --> 00:47:32,793
So the service class being two,

971
00:47:34,240 --> 00:47:35,560
that's multiplied with a hundred

972
00:47:35,560 --> 00:47:38,023
to get the service offsets which is 200.

973
00:47:39,620 --> 00:47:41,340
And then all of the commands

974
00:47:42,690 --> 00:47:44,860
are some offset from that base number.

975
00:47:44,860 --> 00:47:49,860
So 207 is this specific command
for ID card read raw data,

976
00:47:51,050 --> 00:47:52,940
which corresponds to what we saw here,

977
00:47:52,940 --> 00:47:56,193
which is 207, which is hex CF.

978
00:47:57,250 --> 00:48:00,033
You can see the result of
that read raw data there.

979
00:48:02,087 --> 00:48:05,190
So we modified this to
work with the structure

980
00:48:05,190 --> 00:48:07,090
for the cash dispenser packet

981
00:48:08,810 --> 00:48:13,740
and pumped up the amount of
cash that we were dispensing.

982
00:48:13,740 --> 00:48:18,120
And yeah, we were able to run
that and we can actually run

983
00:48:18,120 --> 00:48:21,700
any XFS command on this device

984
00:48:21,700 --> 00:48:23,920
if we send it to the appropriate port.

985
00:48:23,920 --> 00:48:27,590
So, in retrospect here;

986
00:48:27,590 --> 00:48:31,820
pro tip, if you're using
TCP sockets for IPC,

987
00:48:31,820 --> 00:48:34,490
don't listen on 0.0.0.0,

988
00:48:34,490 --> 00:48:38,600
and if you're creating a networked device,

989
00:48:38,600 --> 00:48:40,673
at least do a port scan
before you ship it.

990
00:48:42,110 --> 00:48:45,120
So, we wanna run through the XFS demo here

991
00:48:45,120 --> 00:48:49,053
and show you this machine
spitting out some cash.

992
00:48:51,530 --> 00:48:54,770
Cool, so we have the ATM here
and I'm gonna run the script

993
00:48:54,770 --> 00:48:59,230
we wrote for XFS and you
should see that the command

994
00:48:59,230 --> 00:49:01,520
is being injected directly
into the XFS middleware

995
00:49:01,520 --> 00:49:03,070
so none of this will actually show

996
00:49:03,070 --> 00:49:04,593
that cash is being dispensed.

997
00:49:05,490 --> 00:49:06,930
So if I run the command...

998
00:49:12,990 --> 00:49:17,173
It's gonna dump out some cash!

999
00:49:18,240 --> 00:49:20,120
So this is just gonna continually happen.

1000
00:49:20,120 --> 00:49:21,930
It's just gonna keep dumping out $2 bills

1001
00:49:21,930 --> 00:49:23,300
over and over again.

1002
00:49:23,300 --> 00:49:27,660
And yeah, this is the result of a computer

1003
00:49:27,660 --> 00:49:29,020
just being on the same network.

1004
00:49:29,020 --> 00:49:31,280
You can grab the ethernet cable behind it

1005
00:49:32,380 --> 00:49:34,740
and send a single packet to the ATM

1006
00:49:34,740 --> 00:49:37,296
and it will dump out a load of cash.

1007
00:49:37,296 --> 00:49:39,879
(ATM whirring)

1008
00:49:46,010 --> 00:49:47,580
Thank you for coming to our talk

1009
00:49:47,580 --> 00:49:50,973
and be sure to join us in
our Q and A afterwards.

