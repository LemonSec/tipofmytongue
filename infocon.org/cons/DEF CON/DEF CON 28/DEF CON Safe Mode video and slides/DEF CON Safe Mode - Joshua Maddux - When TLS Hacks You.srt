1
00:00:01,628 --> 00:00:02,860
- Welcome to this talk.

2
00:00:02,860 --> 00:00:04,233
When TLS hacks you.

3
00:00:05,450 --> 00:00:07,260
I'm actually going to start with a demo.

4
00:00:07,260 --> 00:00:08,530
This is going to be weird.

5
00:00:08,530 --> 00:00:10,500
This isn't a concrete attack scenario,

6
00:00:10,500 --> 00:00:11,910
but hopefully it should
make everyone curious

7
00:00:11,910 --> 00:00:13,150
about what's going on.

8
00:00:13,150 --> 00:00:14,460
For those familiar, with SSRF,

9
00:00:14,460 --> 00:00:16,270
the implications will be fairly clear.

10
00:00:16,270 --> 00:00:19,140
That'll explain them right after
the demo for everyone else.

11
00:00:19,140 --> 00:00:19,973
After that,

12
00:00:19,973 --> 00:00:21,350
the attack examples are
going to gradually move

13
00:00:21,350 --> 00:00:22,183
towards real stuff.

14
00:00:22,183 --> 00:00:24,120
But I find it's easiest to
look at the simplest cases

15
00:00:24,120 --> 00:00:27,040
and then start expanding to
look at real world stuff.

16
00:00:27,040 --> 00:00:27,873
For now though,

17
00:00:27,873 --> 00:00:29,680
Let's see the essence of the
dangerous property of TLS

18
00:00:29,680 --> 00:00:30,923
as this talk is about.

19
00:00:34,220 --> 00:00:36,410
Here's memcached, a popular cache

20
00:00:36,410 --> 00:00:38,943
that commonly runs on port 11211.

21
00:00:39,980 --> 00:00:40,870
I haven't installed here.

22
00:00:40,870 --> 00:00:43,450
So you can first see for the key named Z

23
00:00:43,450 --> 00:00:45,070
there currently is no entry.

24
00:00:45,070 --> 00:00:46,300
If you're not familiar with memcached,

25
00:00:46,300 --> 00:00:48,030
this is how stuff communicates with it.

26
00:00:48,030 --> 00:00:50,250
A new line to limited TCP protocol.

27
00:00:50,250 --> 00:00:52,270
But now I'll do something
that you might not expect

28
00:00:52,270 --> 00:00:53,720
to affect memcached.

29
00:00:53,720 --> 00:00:56,350
I'll make a request to an HTTPS URL.

30
00:00:56,350 --> 00:00:57,830
The -L enables redirects

31
00:00:57,830 --> 00:01:00,280
and the -v lets you see
with all that's going on.

32
00:01:02,520 --> 00:01:05,350
You can see at the end everything
is redirecting to itself.

33
00:01:05,350 --> 00:01:07,070
I set this up because
this is a lightning talk

34
00:01:07,070 --> 00:01:10,010
and the string of redirects
takes a couple of minutes,

35
00:01:10,010 --> 00:01:11,740
but redirects don't go on forever.

36
00:01:11,740 --> 00:01:12,573
After a bit,

37
00:01:14,090 --> 00:01:14,923
we get an error.

38
00:01:16,340 --> 00:01:19,550
And now for the magic,
going back to memcached.

39
00:01:19,550 --> 00:01:21,360
If we rerun the same gate command,

40
00:01:21,360 --> 00:01:23,380
we see an entry up here.

41
00:01:23,380 --> 00:01:24,950
The odd thing is that
texts never showed up

42
00:01:24,950 --> 00:01:26,930
in the curl command or
in any of the redirects.

43
00:01:26,930 --> 00:01:28,910
So somehow the server we were talking to,

44
00:01:28,910 --> 00:01:31,090
had to do something with TLS to trick curl

45
00:01:31,090 --> 00:01:33,080
into putting it in there.

46
00:01:33,080 --> 00:01:35,590
Even though I didn't just do anything

47
00:01:35,590 --> 00:01:37,470
aside from hacking myself,

48
00:01:37,470 --> 00:01:40,070
what just happened was weird
and potentially useful.

49
00:01:43,570 --> 00:01:45,280
But here's where I'm going with this.

50
00:01:45,280 --> 00:01:48,020
Because not everyone is
in these sorts of attacks.

51
00:01:48,020 --> 00:01:50,290
I'm going to start off with
exactly what makes this useful

52
00:01:50,290 --> 00:01:51,730
as an attacker.

53
00:01:51,730 --> 00:01:52,870
I'll then move on to some stuff

54
00:01:52,870 --> 00:01:55,550
that shows just how widely
these attacks can be applied

55
00:01:55,550 --> 00:01:57,090
and then get us some recommendations

56
00:01:57,090 --> 00:01:58,390
for what to do about them.

57
00:01:59,480 --> 00:02:01,470
To start off with
there's an existing class

58
00:02:01,470 --> 00:02:03,400
of vulnerability called SRF.

59
00:02:03,400 --> 00:02:05,960
It stands for Server Side Request Forgery.

60
00:02:05,960 --> 00:02:07,520
It's where you effectively phish a server

61
00:02:07,520 --> 00:02:09,570
into doing something by sending it a URL.

62
00:02:11,550 --> 00:02:12,383
Last year at Blackout,

63
00:02:12,383 --> 00:02:14,120
I demonstrated a bunch
of these vulnerabilities

64
00:02:14,120 --> 00:02:16,560
in Apple Pay and in WebHook receivers.

65
00:02:16,560 --> 00:02:18,320
I'm not going to go
into those as much here,

66
00:02:18,320 --> 00:02:19,170
but if you're curious,

67
00:02:19,170 --> 00:02:20,540
you can download these slides later

68
00:02:20,540 --> 00:02:22,633
and go to the C tape to blink right here.

69
00:02:24,417 --> 00:02:26,650
SSRF has a ton of different approaches,

70
00:02:26,650 --> 00:02:28,940
but it was actually
pretty easy in some cases.

71
00:02:28,940 --> 00:02:32,150
webkit.org had a live sample
implementation of Apple Pay

72
00:02:32,150 --> 00:02:33,250
and it was even on AWS

73
00:02:33,250 --> 00:02:35,600
with the old instance metadata service.

74
00:02:35,600 --> 00:02:37,380
So all I had to do was pass this IP

75
00:02:37,380 --> 00:02:39,290
and I could poke around the internal API

76
00:02:39,290 --> 00:02:40,423
and get some tokens.

77
00:02:41,780 --> 00:02:42,990
But not everything was so simple,

78
00:02:42,990 --> 00:02:45,710
I had a lot of SSRF vulnerabilities
that were almost there,

79
00:02:45,710 --> 00:02:48,060
but weren't vulnerable
to this easier approach.

80
00:02:49,420 --> 00:02:51,677
Sometimes I'd have a webhook
where I could hand it a URL

81
00:02:51,677 --> 00:02:53,460
and the server would even fetch the URL,

82
00:02:53,460 --> 00:02:55,130
but not give me a response.

83
00:02:55,130 --> 00:02:56,430
This is called blind SSRF.

84
00:02:58,080 --> 00:03:00,890
Other times the requests in
question would be a PUT request,

85
00:03:00,890 --> 00:03:03,220
which restricted, what
end points I get at.

86
00:03:03,220 --> 00:03:04,840
Sometimes you can mess
with the request method

87
00:03:04,840 --> 00:03:06,740
by setting up an end point that redirects

88
00:03:06,740 --> 00:03:07,790
the target server around,

89
00:03:07,790 --> 00:03:08,940
but that's hit or miss.

90
00:03:10,470 --> 00:03:12,180
Other times you might get some data back,

91
00:03:12,180 --> 00:03:14,870
but it's validated against
a specific content type

92
00:03:14,870 --> 00:03:16,490
where you only get back certain fields,

93
00:03:16,490 --> 00:03:19,633
or even worse, it'll
only accept HTTPS URLs.

94
00:03:21,470 --> 00:03:24,220
But what we really want in
order to exploit this stuff

95
00:03:24,220 --> 00:03:26,450
is a generic, blind SSF approach.

96
00:03:26,450 --> 00:03:29,350
In other words, we'd like
to see it in the server URL,

97
00:03:29,350 --> 00:03:32,090
have it fire a payload to
something internal like SMTP

98
00:03:32,090 --> 00:03:34,550
or ReTIS and get the security compromised

99
00:03:34,550 --> 00:03:37,500
just from that payload without
needing to see the response.

100
00:03:38,900 --> 00:03:41,030
Here are some of the common approaches.

101
00:03:41,030 --> 00:03:44,770
The issues is these are
extremely platforms fixed

102
00:03:44,770 --> 00:03:48,000
to the point where I've never
had any luck with these.

103
00:03:48,000 --> 00:03:49,650
But there are some useful ideas in here,

104
00:03:49,650 --> 00:03:51,860
particularly in a SNI injection.

105
00:03:51,860 --> 00:03:54,110
You wouldn't think that TLS
would be particularly useful

106
00:03:54,110 --> 00:03:56,299
because it's packets are
mostly just encrypted data,

107
00:03:56,299 --> 00:03:57,910
binary flags and other stuff.

108
00:03:57,910 --> 00:04:00,180
And a hacker doesn't
have much control over,

109
00:04:00,180 --> 00:04:01,670
but it's not all that limited.

110
00:04:01,670 --> 00:04:03,730
As Orange Tsai noticed, the SNI,

111
00:04:03,730 --> 00:04:05,680
which is basically just the domain name,

112
00:04:05,680 --> 00:04:06,610
it's part of the URL.

113
00:04:06,610 --> 00:04:07,880
So if you can trick the victim

114
00:04:07,880 --> 00:04:09,420
into accepting a weird domain name

115
00:04:09,420 --> 00:04:11,270
and parsing it in correctly,

116
00:04:11,270 --> 00:04:13,520
you can include stuff like
arbitrary bytes in there

117
00:04:13,520 --> 00:04:16,630
and smuggle stuff like SMTP commands.

118
00:04:16,630 --> 00:04:17,620
This approach is dependent

119
00:04:17,620 --> 00:04:20,150
on a platform-specific URL parsing bug.

120
00:04:20,150 --> 00:04:21,110
But what if we had something

121
00:04:21,110 --> 00:04:23,720
that was inherent to the TLS protocol?

122
00:04:23,720 --> 00:04:25,290
This is where my work starts.

123
00:04:25,290 --> 00:04:27,420
Let's look at a TLS packet
and see what's in there

124
00:04:27,420 --> 00:04:28,323
for us to use.

125
00:04:29,740 --> 00:04:32,710
As is often helpful, when
looking at protocols,

126
00:04:32,710 --> 00:04:34,420
we can open up Wireshark

127
00:04:34,420 --> 00:04:36,760
to see what happens in a TLS connection.

128
00:04:36,760 --> 00:04:39,200
Here's the SNI or Server Name Indication

129
00:04:39,200 --> 00:04:42,040
that was previously
explored in Orange's talk.

130
00:04:42,040 --> 00:04:44,410
His work involves putting
new lines in SNPP commands

131
00:04:44,410 --> 00:04:46,860
into the section pointing
to by the arrow here.

132
00:04:46,860 --> 00:04:49,030
If you poke around, you'll
see stuff like random strings,

133
00:04:49,030 --> 00:04:52,440
key shares and other stuff
that isn't useful for SSRF.

134
00:04:52,440 --> 00:04:53,273
Why?

135
00:04:53,273 --> 00:04:55,100
Because the only part of this
we can typically feed a server

136
00:04:55,100 --> 00:04:56,150
is a URL.

137
00:04:56,150 --> 00:04:57,620
And the only part of the
URL that will make it

138
00:04:57,620 --> 00:04:59,610
into the client hello
packet his domain name

139
00:04:59,610 --> 00:05:01,410
that we provided the victim machine.

140
00:05:03,410 --> 00:05:05,230
But there's a different
way that we as an attacker

141
00:05:05,230 --> 00:05:07,280
can get payloads into
client hello messages.

142
00:05:07,280 --> 00:05:08,480
It involves a couple of steps

143
00:05:08,480 --> 00:05:10,940
and is the main focus of this talk.

144
00:05:10,940 --> 00:05:13,940
First we sent over a
link to our own server.

145
00:05:13,940 --> 00:05:16,200
In this case, jmaddux.com,

146
00:05:16,200 --> 00:05:19,750
then jmaddux.com responds
with a valid server Hello,

147
00:05:19,750 --> 00:05:21,150
but it contains our payload.

148
00:05:22,862 --> 00:05:24,860
It would be ideal. If we as an attacker

149
00:05:24,860 --> 00:05:27,960
could get that payload that
jmaddux.com sent the victim

150
00:05:27,960 --> 00:05:30,367
and then get the victim to
send it somewhere internal.

151
00:05:30,367 --> 00:05:31,940
But that raises a question.

152
00:05:31,940 --> 00:05:33,290
Is there such a field that we can use

153
00:05:33,290 --> 00:05:34,590
to deliver these payloads?

154
00:05:35,780 --> 00:05:37,070
It might seem too good to be true,

155
00:05:37,070 --> 00:05:40,060
but TLS actually provides us exactly that

156
00:05:40,060 --> 00:05:41,680
in the form of a session ID.

157
00:05:41,680 --> 00:05:44,460
Most clients even persist
this field for later use.

158
00:05:44,460 --> 00:05:47,005
Session IDs are limited to 32
bytes, as you can see here,

159
00:05:47,005 --> 00:05:48,690
but depending on the implementation,

160
00:05:48,690 --> 00:05:52,000
you might have session tickets.

161
00:05:52,000 --> 00:05:54,290
This one is about a 200 bytes,

162
00:05:54,290 --> 00:05:57,110
but these can be up to
around 65 kilobytes.

163
00:05:57,110 --> 00:05:59,370
But session IDs and session
tickets are mechanisms

164
00:05:59,370 --> 00:06:00,940
for a TLS client to go,

165
00:06:00,940 --> 00:06:02,760
Hey, remember that
cryptographic key exchange

166
00:06:02,760 --> 00:06:03,780
we did earlier?

167
00:06:03,780 --> 00:06:06,570
Let's just keep using that
key in this new connection.

168
00:06:06,570 --> 00:06:08,610
TLS 1.3 includes a
slightly more complicated,

169
00:06:08,610 --> 00:06:11,510
but similar mechanism called
a pre shared key identity,

170
00:06:11,510 --> 00:06:14,160
which pretty much does the
same thing for our purposes.

171
00:06:14,160 --> 00:06:15,820
All of these are about optimization.

172
00:06:15,820 --> 00:06:18,030
Since key exchanges can be time consuming,

173
00:06:18,030 --> 00:06:19,630
but they provide a way for a server

174
00:06:19,630 --> 00:06:21,480
to tell whatever is connecting to it,

175
00:06:26,030 --> 00:06:27,360
to persist some data for later use.

176
00:06:27,360 --> 00:06:29,360
Almost like a cookie
that lives in plain text.

177
00:06:29,360 --> 00:06:32,110
So it's perfect for the SSRF
attack we're trying to do.

178
00:06:33,290 --> 00:06:35,430
Now, you might anticipate a problem here.

179
00:06:35,430 --> 00:06:38,820
Obviously, if you go to
google.com and then to apple.com,

180
00:06:38,820 --> 00:06:40,820
those TLS sessions are
going to have distinct data

181
00:06:40,820 --> 00:06:41,940
from each other.

182
00:06:41,940 --> 00:06:44,780
The same applies between
Google.com and local host.

183
00:06:44,780 --> 00:06:46,760
So we have a bit of a problem
getting the target server

184
00:06:46,760 --> 00:06:48,213
to reuse the session

185
00:06:48,213 --> 00:06:50,783
when communicating with
something internal.

186
00:06:52,490 --> 00:06:54,170
But when I looked at both the TLS spec

187
00:06:54,170 --> 00:06:56,170
and port doors session cache inclusions.

188
00:06:57,020 --> 00:06:58,800
I saw this wasn't quite the case.

189
00:06:58,800 --> 00:07:00,180
I first went to the curl source code,

190
00:07:00,180 --> 00:07:03,110
since libcurl is used
by a lot of PHP stuff.

191
00:07:03,110 --> 00:07:05,603
Sessions are keyed by the
fourth properties here,

192
00:07:07,640 --> 00:07:09,460
which belong to the struct.

193
00:07:09,460 --> 00:07:12,160
As you can see, none of
these are the IP address.

194
00:07:12,160 --> 00:07:13,900
This means that no matter what IP address,

195
00:07:13,900 --> 00:07:15,710
jmaddux.com resolves to,

196
00:07:15,710 --> 00:07:17,800
curl will attempt to reuse the session.

197
00:07:17,800 --> 00:07:19,677
This happens to be to just
have everything cached

198
00:07:19,677 --> 00:07:21,670
in TLS sessions.

199
00:07:21,670 --> 00:07:24,540
If you establish a TLS
session with jmaddux.com,

200
00:07:24,540 --> 00:07:26,330
whether it resolves to
something on the internet

201
00:07:26,330 --> 00:07:27,560
or your own machine,

202
00:07:27,560 --> 00:07:29,940
your HTPS client will
not know the difference.

203
00:07:29,940 --> 00:07:32,470
Since I, as an attacker own jmaddux.com,

204
00:07:32,470 --> 00:07:34,190
I can combine all this TLS stuff

205
00:07:34,190 --> 00:07:36,457
with a concept called DNS rebinding.

206
00:07:38,170 --> 00:07:41,970
I resolve the first request to 35.x.x.x,

207
00:07:41,970 --> 00:07:43,253
some server I control.

208
00:07:45,200 --> 00:07:48,780
Then the target server picks
up the payload from 35.x.x.x

209
00:07:48,780 --> 00:07:50,380
in the form of a session ticket.

210
00:07:52,220 --> 00:07:54,670
After sometime I send the exact same URL,

211
00:07:54,670 --> 00:07:56,770
except the DNS entry has expired.

212
00:07:56,770 --> 00:07:58,850
Again, since I control the DNS server,

213
00:07:58,850 --> 00:08:01,110
this time around I resolve jmaddux.com

214
00:08:01,110 --> 00:08:01,943
to do something internal

215
00:08:01,943 --> 00:08:03,130
that I wouldn't normally have access to

216
00:08:03,130 --> 00:08:04,250
from the outside.

217
00:08:04,250 --> 00:08:06,500
To simplify things. I'll
just use local host.

218
00:08:08,408 --> 00:08:09,610
Once the DNS query finishes,

219
00:08:09,610 --> 00:08:11,560
the target server then
makes an internal request

220
00:08:11,560 --> 00:08:12,460
with that payload.

221
00:08:14,897 --> 00:08:17,670
Like what I did in the opening demo,

222
00:08:18,530 --> 00:08:20,410
you can manipulate
whatever you're attacking

223
00:08:20,410 --> 00:08:22,530
to send a TLS session ID ticket

224
00:08:22,530 --> 00:08:25,440
or PSK identity like this to itself.

225
00:08:25,440 --> 00:08:26,860
Here, I'm showing a PSK identity

226
00:08:26,860 --> 00:08:28,510
that hasn't been cache inserted .

227
00:08:30,230 --> 00:08:33,030
And here's that same TCP
stream, but just displayed raw.

228
00:08:33,900 --> 00:08:35,780
This feature shows the
really important property

229
00:08:35,780 --> 00:08:38,500
of my approach to combining
TLS with DNS rebinding.

230
00:08:38,500 --> 00:08:40,800
You can get arbitrary
characters to be sent,

231
00:08:40,800 --> 00:08:42,360
which includes new lines.

232
00:08:42,360 --> 00:08:43,303
This is what allows you to redirect

233
00:08:43,303 --> 00:08:45,780
with a bunch of local
services like memcached,

234
00:08:45,780 --> 00:08:47,160
just like people did in the past

235
00:08:47,160 --> 00:08:48,813
with Go free URLs.

236
00:08:50,640 --> 00:08:52,000
And here's an exchange more typical

237
00:08:52,000 --> 00:08:54,400
of what used to do real damage.

238
00:08:54,400 --> 00:08:56,730
This is a value in most
Python memcached libraries

239
00:08:56,730 --> 00:08:58,390
will execute a shell command immediately.

240
00:08:58,390 --> 00:09:01,010
Once it's retrieved from a cache.

241
00:09:01,010 --> 00:09:02,650
This is because it's
quite common in Python

242
00:09:02,650 --> 00:09:05,100
and other languages to use
built in serialization methods

243
00:09:05,100 --> 00:09:06,480
like Pickle to convert values

244
00:09:06,480 --> 00:09:08,460
to something that can be stored.

245
00:09:08,460 --> 00:09:10,690
Unfortunately built in
serialization methods

246
00:09:10,690 --> 00:09:12,710
are also common RCE targets.

247
00:09:12,710 --> 00:09:14,310
We'll get to exploitation later,

248
00:09:15,490 --> 00:09:16,950
but since this is pretty common,

249
00:09:16,950 --> 00:09:19,270
I ended up testing it
for amount of slights.

250
00:09:19,270 --> 00:09:21,010
I'll get some specific ones in a second,

251
00:09:21,010 --> 00:09:23,010
but first I'll go over
some testing infrastructure

252
00:09:23,010 --> 00:09:24,700
I set up, along with some tips

253
00:09:24,700 --> 00:09:27,100
for actually performing
these kinds of exploits.

254
00:09:28,540 --> 00:09:30,320
Here are all the VMs I
have on the internet.

255
00:09:30,320 --> 00:09:32,290
Say for maybe some IP white listing,

256
00:09:32,290 --> 00:09:33,530
they need to be on the open internet

257
00:09:33,530 --> 00:09:35,900
so that the target boxes can reach them.

258
00:09:35,900 --> 00:09:39,090
I've got a name server record
pointing to that (indistinct)

259
00:09:39,090 --> 00:09:42,090
com queries to the DNS
server on the top left,

260
00:09:42,090 --> 00:09:45,450
which is just a Python
script running on port 53.

261
00:09:45,450 --> 00:09:47,400
It alternates between
answering with the IP

262
00:09:47,400 --> 00:09:50,023
of the custom TLS server and local host.

263
00:09:50,980 --> 00:09:53,220
Then over there on the right
half of my custom TLS server,

264
00:09:53,220 --> 00:09:56,440
which is there to deliver my
payloads via session tickets.

265
00:09:56,440 --> 00:09:59,470
I configure those by just
updating values and ReTIS.

266
00:09:59,470 --> 00:10:01,320
But when testing it proved
to be difficult to do,

267
00:10:01,320 --> 00:10:03,000
just go straight to local post,

268
00:10:03,000 --> 00:10:05,220
because depending on what
library is making the requests,

269
00:10:05,220 --> 00:10:07,820
I didn't know if the SSL
sessions were being cached.

270
00:10:09,600 --> 00:10:10,433
To address this,

271
00:10:10,433 --> 00:10:12,310
I've sometimes just ended
up adding another box

272
00:10:12,310 --> 00:10:15,000
to see if the payload was being persisted.

273
00:10:15,000 --> 00:10:15,833
If you're not familiar,

274
00:10:15,833 --> 00:10:19,660
netcat can be set up to just
listen for TCP connections

275
00:10:19,660 --> 00:10:21,310
and log the results.

276
00:10:21,310 --> 00:10:23,080
If I saw my payload
making it into the logs,

277
00:10:23,080 --> 00:10:25,178
I knew the general approach could work.

278
00:10:25,178 --> 00:10:27,400
And then go back to the
setup from the previous slide

279
00:10:27,400 --> 00:10:29,570
to get the server to start
delivering the payload to itself

280
00:10:29,570 --> 00:10:30,520
on different ports.

281
00:10:32,327 --> 00:10:34,290
And here are the links to
all that I actually used.

282
00:10:34,290 --> 00:10:36,960
A big chunk of the work was
saved by just messing around

283
00:10:36,960 --> 00:10:39,210
with a pure rusted implementation of TLS,

284
00:10:39,210 --> 00:10:40,610
which is linked to here.

285
00:10:40,610 --> 00:10:43,270
A big thanks goes out to
everyone mentioned to this slide.

286
00:10:43,270 --> 00:10:45,200
I wouldn't have had the
time to do any of this work

287
00:10:45,200 --> 00:10:47,350
if not for the code
they had put out there.

288
00:10:49,210 --> 00:10:51,660
But I know with everything I just claimed.

289
00:10:51,660 --> 00:10:53,980
I need to back things up by
showing what actual real world

290
00:10:53,980 --> 00:10:56,100
attacks can happen with this.

291
00:10:56,100 --> 00:10:58,530
I'll start off conceptually
and then get to some examples

292
00:10:58,530 --> 00:10:59,730
along with another demo.

293
00:11:01,860 --> 00:11:03,620
But here's the malware card

294
00:11:03,620 --> 00:11:05,260
If you're in the middle of this diagram,

295
00:11:05,260 --> 00:11:06,660
you're generally vulnerable.

296
00:11:07,568 --> 00:11:10,360
The SSRF part refers to when
you can send something in URL

297
00:11:10,360 --> 00:11:11,490
and it'll fetch that URL,

298
00:11:11,490 --> 00:11:14,090
but you don't know of a way
to exploit that behavior.

299
00:11:14,090 --> 00:11:15,720
It's interesting because
you would hope by now

300
00:11:15,720 --> 00:11:17,760
people would have tried
to eliminate anything,

301
00:11:17,760 --> 00:11:19,970
even remotely looking like a SSRF,

302
00:11:19,970 --> 00:11:23,250
But it's pattern is in fact
required by a few popular specs,

303
00:11:23,250 --> 00:11:24,210
That's even common enough

304
00:11:24,210 --> 00:11:26,110
that I've seen bug bounties mention SSRF

305
00:11:26,110 --> 00:11:29,460
with no proven security impact
as an excluded category.

306
00:11:29,460 --> 00:11:30,990
But that's what this talk is about.

307
00:11:30,990 --> 00:11:32,090
Adding the security impact

308
00:11:32,090 --> 00:11:35,263
when you have just something
that is just almost SSRF.

309
00:11:37,400 --> 00:11:39,560
This one on the left sounds
weird, but it's getting bigger.

310
00:11:39,560 --> 00:11:42,520
It's just a matter of if whatever
the SSRF is going through

311
00:11:42,520 --> 00:11:44,720
to make requests has
implemented this feature

312
00:11:44,720 --> 00:11:46,170
according to the latest spec.

313
00:11:48,130 --> 00:11:52,150
Unfortunately, there were quite
a few HTTPS client libraries

314
00:11:52,150 --> 00:11:55,560
out there that support full
blown TLS session caching.

315
00:11:55,560 --> 00:11:57,753
Here are a few that you
may be wondering about.

316
00:11:57,753 --> 00:12:00,330
I reported this as a
vulnerability, some of these,

317
00:12:00,330 --> 00:12:02,610
but not all of the entries with yes,

318
00:12:02,610 --> 00:12:04,230
and I haven't seen much traction,

319
00:12:04,230 --> 00:12:06,740
understandably, since fixing
this requires diverging

320
00:12:06,740 --> 00:12:08,210
from the TLS spec.

321
00:12:08,210 --> 00:12:10,460
Not a whole lot of people
are eager to do so.

322
00:12:12,240 --> 00:12:14,320
The thing you run into
the most trouble with

323
00:12:14,320 --> 00:12:15,650
is this last circle.

324
00:12:15,650 --> 00:12:17,750
Because you have to first do
some recon to see what ports

325
00:12:17,750 --> 00:12:19,950
might be internally exposed on the server.

326
00:12:19,950 --> 00:12:21,630
And then you need to see
if what's on those ports

327
00:12:21,630 --> 00:12:23,540
is permissive enough to
keep the connection open

328
00:12:23,540 --> 00:12:25,913
past the opening bites
of the TLS client Hello.

329
00:12:27,640 --> 00:12:30,100
Here's some examples of what
you might be looking for there

330
00:12:30,100 --> 00:12:31,110
it's far from complete,

331
00:12:31,110 --> 00:12:33,010
but here are the most notable entries.

332
00:12:35,220 --> 00:12:37,260
Now we'll go through a couple
of exploitable examples

333
00:12:37,260 --> 00:12:39,701
of these TLS session-based
SSRF vulnerabilities

334
00:12:39,701 --> 00:12:43,051
that are reported and now fixed.

335
00:12:43,051 --> 00:12:44,270
Here's one from Youtrack.

336
00:12:44,270 --> 00:12:47,140
It's like rated low because
all I did was at local SMTP

337
00:12:47,140 --> 00:12:48,380
and I didn't try poking around

338
00:12:48,380 --> 00:12:51,500
to see if I could exploit
the SMTP server further.

339
00:12:51,500 --> 00:12:53,410
It originated from
Youtracks import feature,

340
00:12:53,410 --> 00:12:56,410
which normally wouldn't be easy
to exploit being blind SSRF.

341
00:12:58,210 --> 00:12:59,560
But with my rebinding code.

342
00:12:59,560 --> 00:13:01,320
Here's a section from the TLS packet

343
00:13:01,320 --> 00:13:03,500
I got Youtrack to send itself.

344
00:13:03,500 --> 00:13:06,400
This works because SMTP is
a new line limited protocol.

345
00:13:06,400 --> 00:13:07,890
So just like memcached,

346
00:13:07,890 --> 00:13:10,543
you can embed working commands
within the TLS ticket.

347
00:13:13,320 --> 00:13:15,100
And here's what came in my packet.

348
00:13:15,100 --> 00:13:16,540
This alone wasn't super severe

349
00:13:16,540 --> 00:13:17,790
because it's not signed quite right.

350
00:13:17,790 --> 00:13:19,300
And I didn't dig too deeply

351
00:13:19,300 --> 00:13:21,960
because I wanted to just report it ASAP,

352
00:13:21,960 --> 00:13:25,450
but it did get initiated by TCP stream

353
00:13:25,450 --> 00:13:27,040
I got Youtrack to send itself.

354
00:13:27,040 --> 00:13:28,290
So it's still pretty bad.

355
00:13:29,910 --> 00:13:32,420
Here's the one I reported on Nextcloud.

356
00:13:32,420 --> 00:13:34,220
The idea behind Nextcloud is a cool one.

357
00:13:34,220 --> 00:13:35,840
You set up a server in host files

358
00:13:35,840 --> 00:13:37,930
and can even share them
with other people's servers

359
00:13:37,930 --> 00:13:39,793
using a share URL like this.

360
00:13:41,400 --> 00:13:42,233
But as it turns out,

361
00:13:42,233 --> 00:13:44,940
you can include port
numbers in this share URL.

362
00:13:44,940 --> 00:13:48,090
Since Nextcloud automatically
puts HTTPS in there.

363
00:13:48,090 --> 00:13:50,500
Normally there wouldn't
be much a SSRF potential

364
00:13:50,500 --> 00:13:52,250
and it would have to be blind SSRF.

365
00:13:53,850 --> 00:13:56,210
But luckily I was able to do just that.

366
00:13:56,210 --> 00:13:57,550
So as a non end user,

367
00:13:57,550 --> 00:13:59,910
I can use my TLS rebinding
attack infrastructure

368
00:13:59,910 --> 00:14:01,960
to perform arbitrary rights on memcached.

369
00:14:04,650 --> 00:14:06,550
After recording this and
working through the options,

370
00:14:06,550 --> 00:14:08,200
there weren't any great ones.

371
00:14:08,200 --> 00:14:09,870
Because not all requests libraries

372
00:14:09,870 --> 00:14:12,030
allow you to disabled TLS sessions.

373
00:14:12,030 --> 00:14:13,640
In this case libcurl has the option,

374
00:14:13,640 --> 00:14:15,780
but it isn't exposed by
PHP request libraries

375
00:14:15,780 --> 00:14:17,200
such as guzzle.

376
00:14:17,200 --> 00:14:18,860
In any case, adding a request timeout

377
00:14:18,860 --> 00:14:20,690
made the attack pretty much infeasible,

378
00:14:20,690 --> 00:14:23,260
assuming that people
don't turn the DNS time

379
00:14:23,260 --> 00:14:25,700
to leave values super
low on their servers.

380
00:14:25,700 --> 00:14:27,540
Nextcloud was still generous
enough to give me a bounty,

381
00:14:27,540 --> 00:14:30,090
even though in my opinion,
this is libcurl's fault.

382
00:14:32,075 --> 00:14:33,920
In the last couple of next slides,

383
00:14:33,920 --> 00:14:35,000
let's see a real demo now,

384
00:14:35,000 --> 00:14:37,080
from the perspective of
a Django web developer

385
00:14:37,080 --> 00:14:38,610
getting phished.

386
00:14:38,610 --> 00:14:40,580
The DNS rebinding part
has been done in the past,

387
00:14:40,580 --> 00:14:41,993
but what's new here is
combining DNS rebinding

388
00:14:41,993 --> 00:14:45,760
with TLS session persistence
to make it more powerful.

389
00:14:45,760 --> 00:14:46,593
In the past,

390
00:14:46,593 --> 00:14:48,720
you had to get people to
visit a fully malicious page

391
00:14:48,720 --> 00:14:50,740
to get anywhere with DNS rebinding,

392
00:14:50,740 --> 00:14:53,440
but with work, you can do the
same with just an image tag.

393
00:14:53,440 --> 00:14:55,470
Because of that, you can
phish people into RCE,

394
00:14:55,470 --> 00:14:58,210
even if they just view an email,
but don't click any links.

395
00:14:58,210 --> 00:14:59,160
Let's see that now.

396
00:15:01,120 --> 00:15:02,773
And now for the actual demo.

397
00:15:05,210 --> 00:15:06,043
So as you can see,

398
00:15:06,043 --> 00:15:08,380
we're pretending I'm a
Django application developer,

399
00:15:08,380 --> 00:15:10,010
running a typical app.

400
00:15:10,010 --> 00:15:11,910
If we look at the app, it's pretty simple.

401
00:15:11,910 --> 00:15:13,060
We can view a sloth emoji,

402
00:15:13,060 --> 00:15:15,090
but if we refresh too fast,

403
00:15:15,090 --> 00:15:16,970
the sloth needs to go to sleep.

404
00:15:16,970 --> 00:15:19,560
And therefore that happens
when I get phished.

405
00:15:19,560 --> 00:15:20,870
As you can see,

406
00:15:20,870 --> 00:15:24,120
I have received some
perfectly legitimate emails,

407
00:15:24,120 --> 00:15:25,360
and I'm viewing them.

408
00:15:25,360 --> 00:15:27,150
Normally these image
types should be benign,

409
00:15:27,150 --> 00:15:31,740
but after viewing them, my
sloth now opens a calculator

410
00:15:31,740 --> 00:15:32,833
via a shell command.

411
00:15:33,690 --> 00:15:35,100
That's because those image tags

412
00:15:35,100 --> 00:15:37,290
pointing to the domain
with my rebinding setup

413
00:15:37,290 --> 00:15:39,403
and the simple Python pickle payload.

414
00:15:44,540 --> 00:15:45,850
Here's the most of the source code

415
00:15:45,850 --> 00:15:48,040
of the example app I created.

416
00:15:48,040 --> 00:15:49,730
You can pretty easily
find apps that called

417
00:15:49,730 --> 00:15:51,860
django.core.cache on GitHub.

418
00:15:51,860 --> 00:15:54,470
But I didn't want to demo
it against a specific one,

419
00:15:54,470 --> 00:15:55,730
because that seems a little mean.

420
00:15:55,730 --> 00:15:58,344
And I wouldn't want people
wanting actual phishing campaigns

421
00:15:58,344 --> 00:16:00,330
against such projects.

422
00:16:00,330 --> 00:16:02,220
It's a little tough to assign blame here.

423
00:16:02,220 --> 00:16:04,650
Nothing is right breaking
from establish practices,

424
00:16:04,650 --> 00:16:05,910
but it's clear that there's a potential

425
00:16:05,910 --> 00:16:08,523
to compromise real-world
developer laptops.

426
00:16:10,280 --> 00:16:11,113
On that note,

427
00:16:11,113 --> 00:16:11,946
there's a lot more to do

428
00:16:11,946 --> 00:16:14,410
that I couldn't possibly do on my own.

429
00:16:14,410 --> 00:16:15,730
These slides will be available online

430
00:16:15,730 --> 00:16:16,840
if you want to return to this.

431
00:16:16,840 --> 00:16:18,360
And if you do anything interesting,

432
00:16:18,360 --> 00:16:20,180
I'd love to hear about it.

433
00:16:20,180 --> 00:16:22,220
There are certainly a lot
more potential vulnerabilities

434
00:16:22,220 --> 00:16:23,053
to explore.

435
00:16:24,200 --> 00:16:26,160
So all of that is bad,

436
00:16:26,160 --> 00:16:27,680
but what can be done about it?

437
00:16:27,680 --> 00:16:30,743
Let's start from the root
of the problem, TLS clients.

438
00:16:32,820 --> 00:16:34,560
Here's the thing I recommended
to the Chromium team

439
00:16:34,560 --> 00:16:35,680
a while back.

440
00:16:35,680 --> 00:16:37,620
We still aren't in agreement
about whether or not

441
00:16:37,620 --> 00:16:38,910
this should be fixed.

442
00:16:38,910 --> 00:16:40,470
And my report was pretty hastily written,

443
00:16:40,470 --> 00:16:42,240
which probably didn't help things.

444
00:16:42,240 --> 00:16:44,080
Essentially, I'd like
to remove the ability

445
00:16:44,080 --> 00:16:46,313
for sessions to be
resumed between servers.

446
00:16:47,700 --> 00:16:50,300
But while the Chromium team
has marked this is a won't fix.

447
00:16:50,300 --> 00:16:52,540
They did suggest an alternative
that maintained support

448
00:16:52,540 --> 00:16:54,920
for resuming sessions across servers.

449
00:16:54,920 --> 00:16:56,890
They probably care about
that more than I do,

450
00:16:56,890 --> 00:16:59,390
but we can at least have
the best of both worlds.

451
00:16:59,390 --> 00:17:01,358
This last option of just partitioning

452
00:17:01,358 --> 00:17:03,860
based upon whether the
address is something local

453
00:17:03,860 --> 00:17:05,490
is a pretty good compromise.

454
00:17:05,490 --> 00:17:06,630
It wouldn't affect performance,

455
00:17:06,630 --> 00:17:08,820
but would protect against
most of the attacks scenarios

456
00:17:08,820 --> 00:17:10,330
I can think of.

457
00:17:10,330 --> 00:17:12,520
But based on my experiences so far,

458
00:17:12,520 --> 00:17:14,180
I'm not hopeful that
there's going to be much

459
00:17:14,180 --> 00:17:16,920
proactive effort on the
part of software packages

460
00:17:16,920 --> 00:17:18,930
that make HTTPS requests.

461
00:17:18,930 --> 00:17:20,350
For most of the audience.

462
00:17:20,350 --> 00:17:22,520
It's more useful to know what susceptible

463
00:17:22,520 --> 00:17:25,340
and what layers of defense can be applied.

464
00:17:25,340 --> 00:17:26,280
However, with all of this,

465
00:17:26,280 --> 00:17:28,130
it's worth taking a step back to consider,

466
00:17:28,130 --> 00:17:30,180
is TLS session resumption, even worth it?

467
00:17:31,980 --> 00:17:33,618
There are other issues with it,

468
00:17:33,618 --> 00:17:35,940
a couple of which you're shown here.

469
00:17:35,940 --> 00:17:37,930
I'm not going to make the case

470
00:17:37,930 --> 00:17:39,810
that the industry as
a whole should give up

471
00:17:39,810 --> 00:17:41,160
on this optimization,

472
00:17:41,160 --> 00:17:42,230
but we should take a step back

473
00:17:42,230 --> 00:17:44,210
and see if this is a worthwhile trade off.

474
00:17:44,210 --> 00:17:45,730
We may just like in the previous slide,

475
00:17:45,730 --> 00:17:47,900
find how the costs can be eliminated.

476
00:17:47,900 --> 00:17:49,690
But if we find we can't
tackle these problems,

477
00:17:49,690 --> 00:17:51,840
we need to weigh them
against the benefits.

478
00:17:53,260 --> 00:17:54,600
And here's the main benefit.

479
00:17:54,600 --> 00:17:56,770
You get a sizable performance improvement

480
00:17:56,770 --> 00:17:59,940
on a small subset of packets
that are TLS handshakes.

481
00:17:59,940 --> 00:18:01,940
You probably care about this
whenever you're in the position

482
00:18:01,940 --> 00:18:03,440
of serving up TLS.

483
00:18:03,440 --> 00:18:06,680
Whatever percentage of CPU
usage is due to TLS handshakes.

484
00:18:06,680 --> 00:18:09,430
You probably want to keep
that little to minimize cost,

485
00:18:11,350 --> 00:18:13,420
but if you're like me, you don't care.

486
00:18:13,420 --> 00:18:14,870
I'm taking on all the security

487
00:18:14,870 --> 00:18:16,854
and privacy risk of session resumption,

488
00:18:16,854 --> 00:18:18,920
but the amount that saves on my power bill

489
00:18:18,920 --> 00:18:20,110
is pretty minimal.

490
00:18:20,110 --> 00:18:21,900
Additionally, if you're
running a web application,

491
00:18:21,900 --> 00:18:23,280
you might care about session resumption,

492
00:18:23,280 --> 00:18:24,990
not incoming connections,

493
00:18:24,990 --> 00:18:26,520
but when you're making external requests,

494
00:18:26,520 --> 00:18:28,620
it's probably not in your interests.

495
00:18:28,620 --> 00:18:30,620
You're placing a lot of
trust on random websites,

496
00:18:30,620 --> 00:18:33,830
not to redirect you and
on your local services.

497
00:18:33,830 --> 00:18:35,343
So how might you turn it off?

498
00:18:37,110 --> 00:18:37,943
Here's what I found.

499
00:18:37,943 --> 00:18:40,630
It's kind of sad when
stuff forces you into this,

500
00:18:40,630 --> 00:18:41,610
but at least as an internet user,

501
00:18:41,610 --> 00:18:44,640
you can pick Firefox and
disabled session identifiers.

502
00:18:44,640 --> 00:18:46,930
If you're a paranoid about this stuff.

503
00:18:46,930 --> 00:18:48,190
If you're running a web application,

504
00:18:48,190 --> 00:18:49,300
you're a bit stuck though.

505
00:18:49,300 --> 00:18:50,400
So what should you do?

506
00:18:51,710 --> 00:18:52,543
First off?

507
00:18:52,543 --> 00:18:53,376
It's a good idea in general

508
00:18:53,376 --> 00:18:55,370
to run your outbound
requests through a proxy,

509
00:18:55,370 --> 00:18:56,820
especially if you're supporting webhooks

510
00:18:56,820 --> 00:18:59,070
or some other SSRF prone feature,

511
00:18:59,070 --> 00:19:02,070
but also where you consider
your infrastructure decisions.

512
00:19:02,070 --> 00:19:05,350
You'd be surprised to
know just how much stuff

513
00:19:05,350 --> 00:19:06,330
is still set up in a way

514
00:19:06,330 --> 00:19:08,820
that is just one locally
initiated TCP stream

515
00:19:08,820 --> 00:19:09,983
away from compromise.

516
00:19:11,500 --> 00:19:13,150
But here are the general takeaways.

517
00:19:13,150 --> 00:19:14,090
The thing I'd like to highlight

518
00:19:14,090 --> 00:19:15,160
is if you're just starting out

519
00:19:15,160 --> 00:19:16,370
in the offensive side of security,

520
00:19:16,370 --> 00:19:18,250
I'd encourage you to look
at the random standards and

521
00:19:18,250 --> 00:19:19,930
browser features that come up.

522
00:19:19,930 --> 00:19:22,030
Even if you don't fully
understand them at first,

523
00:19:22,030 --> 00:19:23,460
find something that seems interesting

524
00:19:23,460 --> 00:19:25,420
and started hacking around in Wireshark.

525
00:19:25,420 --> 00:19:28,160
I know I didn't understand TLS at first,

526
00:19:28,160 --> 00:19:30,560
and I still don't really
understand it very much

527
00:19:31,460 --> 00:19:32,810
after all of this,

528
00:19:32,810 --> 00:19:34,730
but as an attacker you really only need

529
00:19:34,730 --> 00:19:36,120
to understand the worst parts.

530
00:19:36,120 --> 00:19:37,820
And that's what this is all about.

531
00:19:39,694 --> 00:19:40,527
And thank you.

532
00:19:40,527 --> 00:19:43,000
Here's my Twitter and a link
to Lotacora, where I work.

533
00:19:43,000 --> 00:19:43,920
They're a great place to work

534
00:19:43,920 --> 00:19:45,448
and have been amazingly supportive,

535
00:19:45,448 --> 00:19:47,440
in the number of research
directions I take,

536
00:19:47,440 --> 00:19:48,590
definitely take a look.

