1
00:00:01,040 --> 00:00:03,440
- Hello everyone and thank
you for joining my talk today

2
00:00:03,440 --> 00:00:06,350
called "Don't be Silly.
It's Only a Lightbulb."

3
00:00:06,350 --> 00:00:08,500
Before we begin, just
a brief introduction.

4
00:00:09,570 --> 00:00:11,500
My name is Eyal Itkin.

5
00:00:11,500 --> 00:00:12,810
I am a Vulnerability Researcher

6
00:00:12,810 --> 00:00:15,380
working at Check Point Research Firm.

7
00:00:15,380 --> 00:00:17,830
In my research projects,
I tend to focus on

8
00:00:17,830 --> 00:00:20,090
embedded devices and network protocols

9
00:00:20,090 --> 00:00:22,490
and in which case I combine
these both together.

10
00:00:23,350 --> 00:00:25,880
You can usually read more
about my recent publications

11
00:00:25,880 --> 00:00:27,073
on my Twitter account.

12
00:00:29,020 --> 00:00:31,310
The motivation for this specific research

13
00:00:31,310 --> 00:00:33,950
started a few years ago in 2016

14
00:00:33,950 --> 00:00:38,090
when I heard of a new smart
IOT device, smart light bulbs.

15
00:00:38,090 --> 00:00:41,630
I was already quite familiar
with many smart gadget

16
00:00:41,630 --> 00:00:44,130
and even smart air conditioner,

17
00:00:44,130 --> 00:00:46,780
which allows you to activate
it remotely on your way home.

18
00:00:46,780 --> 00:00:50,010
So the temperature will be
just fine when you arrive.

19
00:00:50,010 --> 00:00:53,920
But, why would they
need a smart light bulb?

20
00:00:53,920 --> 00:00:57,000
I only need the light when
I'm physically in the room

21
00:00:57,000 --> 00:00:59,540
and I'm fully capable of
toggling the switch on and off

22
00:00:59,540 --> 00:01:01,580
when I enter and leave the room.

23
00:01:01,580 --> 00:01:03,670
Why would they need an app for that?

24
00:01:03,670 --> 00:01:05,916
Well, I figured out that it won't catch

25
00:01:05,916 --> 00:01:08,700
people won't buy it and that's it.

26
00:01:08,700 --> 00:01:12,440
And apparently I was wrong,
because according to a report

27
00:01:12,440 --> 00:01:17,440
from the end of 2018, more than
400,000 households in the UK

28
00:01:17,450 --> 00:01:19,640
who are already using the
smart lighting solutions,

29
00:01:19,640 --> 00:01:22,033
so people are apparently
buying this gadget.

30
00:01:23,000 --> 00:01:23,833
Okay.

31
00:01:23,833 --> 00:01:27,880
But if I connect my light
bulb to the mobile phone

32
00:01:27,880 --> 00:01:29,250
or to the internet,

33
00:01:29,250 --> 00:01:32,133
there will be some security
risk about it, right.

34
00:01:33,290 --> 00:01:34,780
But when I ask people about it,

35
00:01:34,780 --> 00:01:37,500
I always received the same response.

36
00:01:37,500 --> 00:01:38,450
Don't be silly.

37
00:01:38,450 --> 00:01:39,800
It's only a light bulb.

38
00:01:39,800 --> 00:01:40,633
It's fine.

39
00:01:42,240 --> 00:01:45,480
Obviously I'm not the
first to study this case

40
00:01:45,480 --> 00:01:47,983
and there is some great
prior work before me.

41
00:01:49,430 --> 00:01:52,710
We will start with a Lightbulb
Worm by Colin O'Flynn

42
00:01:52,710 --> 00:01:55,020
and Eyal Ronen which
presented there research

43
00:01:55,020 --> 00:01:57,063
on Black Hat USA on 2016.

44
00:01:57,900 --> 00:01:59,850
Later on, they developed the research

45
00:01:59,850 --> 00:02:03,783
into IOT Goes Nuclear, creating
a ZigBee Chain Reaction.

46
00:02:04,620 --> 00:02:06,920
This time it was joined by Adi Shamir

47
00:02:06,920 --> 00:02:08,240
and Achi-Or Weingarten.

48
00:02:08,240 --> 00:02:11,163
And you can read all
about it on their website.

49
00:02:12,050 --> 00:02:14,040
I really had continued
reading about the research

50
00:02:14,040 --> 00:02:16,610
because it was so cool
we actually took over

51
00:02:16,610 --> 00:02:17,710
all of the light bulbs

52
00:02:17,710 --> 00:02:21,293
on campus in a War-flying
demo from their drone.

53
00:02:22,580 --> 00:02:26,450
Since I already was familiar
with Eyal Ronen's work

54
00:02:26,450 --> 00:02:30,370
and both Eyal Ronen and Achi-Or
are all colleagues of mine.

55
00:02:30,370 --> 00:02:31,850
I talked with Eyal Ronen and together,

56
00:02:31,850 --> 00:02:33,910
we decided that with his help,

57
00:02:33,910 --> 00:02:35,980
I am going to continue on their research

58
00:02:35,980 --> 00:02:38,220
and take it to the next level.

59
00:02:38,220 --> 00:02:39,893
So, what did they find?

60
00:02:41,050 --> 00:02:43,040
Well, it turns out that attackers

61
00:02:43,040 --> 00:02:44,710
can remotely steal a light bulb

62
00:02:44,710 --> 00:02:48,450
from a given ZigBee network
and force it to join their own.

63
00:02:48,450 --> 00:02:49,950
Once it joins the network,

64
00:02:49,950 --> 00:02:53,150
attackers can send a light bulb
a malicious firmware update

65
00:02:53,150 --> 00:02:55,260
to fully take over it.

66
00:02:55,260 --> 00:02:57,271
And if that wasn't enough,

67
00:02:57,271 --> 00:02:59,150
it turns out that even
a regular light bulb

68
00:02:59,150 --> 00:03:00,620
can steal other light bulbs

69
00:03:00,620 --> 00:03:02,980
and you don't need any fancy RF equipment

70
00:03:02,980 --> 00:03:04,580
or an antenna in order to do it.

71
00:03:06,050 --> 00:03:08,180
Using these three parameters together.

72
00:03:08,180 --> 00:03:10,510
The researchers claim
that you can take over

73
00:03:10,510 --> 00:03:13,340
a selected set of light
bulbs in a given city,

74
00:03:13,340 --> 00:03:15,140
from each light bulb you'll take over

75
00:03:15,140 --> 00:03:17,501
the other light bulbs in close proximity

76
00:03:17,501 --> 00:03:19,350
and so on and so forth,

77
00:03:19,350 --> 00:03:21,300
in order to propagate and take over

78
00:03:21,300 --> 00:03:23,800
all of the light bulbs in a giving city

79
00:03:23,800 --> 00:03:25,853
in your nuclear like chain reaction.

80
00:03:26,800 --> 00:03:30,850
Sadly for us, the vendor did
fix the last vulnerability

81
00:03:30,850 --> 00:03:32,900
and we were only left with the first two.

82
00:03:34,180 --> 00:03:35,810
If you put it visually,

83
00:03:35,810 --> 00:03:38,003
we can see the network diagram over here.

84
00:03:39,390 --> 00:03:41,250
On the right we can
see a smart light bulb,

85
00:03:41,250 --> 00:03:44,259
which communicates with
its blades, the controller,

86
00:03:44,259 --> 00:03:46,260
or the ZigBee radio.

87
00:03:46,260 --> 00:03:48,320
The way it is connected
to both the radio network

88
00:03:48,320 --> 00:03:51,110
and the commuter network
with an ethernet cable,

89
00:03:51,110 --> 00:03:54,283
so we could control the light
bulb for my mobile phone,

90
00:03:55,140 --> 00:03:56,290
through the controller.

91
00:03:57,490 --> 00:04:00,350
The attack itself will start
when the attacker will transmit

92
00:04:00,350 --> 00:04:03,230
ZigBee Factory Reset
messages to the light bulb

93
00:04:03,230 --> 00:04:04,390
in order to confuse it

94
00:04:04,390 --> 00:04:07,580
and convince it join their own network.

95
00:04:07,580 --> 00:04:10,600
Once it joins the network,
attackers can send the malicious

96
00:04:10,600 --> 00:04:12,000
Over The Airfield Update

97
00:04:12,000 --> 00:04:14,963
to the light bulb to fully take
over the light bulb itself.

98
00:04:16,400 --> 00:04:17,800
And while the original results

99
00:04:17,800 --> 00:04:19,460
only focused on the light bulbs,

100
00:04:19,460 --> 00:04:22,290
we're focused on a much broader target

101
00:04:22,290 --> 00:04:25,610
and we want to take the
research to the next step.

102
00:04:25,610 --> 00:04:27,310
We want to infiltrate the network.

103
00:04:28,720 --> 00:04:30,260
In order to infiltrate the network,

104
00:04:30,260 --> 00:04:32,330
we're hoping to find vulnerability,

105
00:04:32,330 --> 00:04:35,540
so that our light bulb will be able to

106
00:04:35,540 --> 00:04:37,830
remotely exploit the ZigBee vulnerability

107
00:04:37,830 --> 00:04:41,260
in the bridge itself in
order to take over it.

108
00:04:41,260 --> 00:04:42,820
Once we took over the bridge,

109
00:04:42,820 --> 00:04:45,730
the bridge can launch attack
inside a computer network

110
00:04:45,730 --> 00:04:47,890
and hopefully allow us to
take over the computers

111
00:04:47,890 --> 00:04:49,423
inside the network itself.

112
00:04:50,640 --> 00:04:52,600
Once we understood our attack vector

113
00:04:52,600 --> 00:04:53,903
it's time to get started.

114
00:04:59,800 --> 00:05:02,757
But first some preliminary
slides on ZigBee.

115
00:05:03,790 --> 00:05:05,560
ZigBee is a suite of high level protocols

116
00:05:05,560 --> 00:05:07,990
for close proximity networks.

117
00:05:07,990 --> 00:05:12,020
It's an IEEE 802.15.4-based specs

118
00:05:12,020 --> 00:05:15,053
redefines a low range, low power radio.

119
00:05:16,090 --> 00:05:18,670
Not to be confused with IEEE 802.11

120
00:05:18,670 --> 00:05:21,403
which stands for the
more commonly used wifi.

121
00:05:23,030 --> 00:05:24,440
The maximum transmission unit

122
00:05:24,440 --> 00:05:29,320
or The MTU over ZigBee
is only 127 bytes long.

123
00:05:29,320 --> 00:05:31,630
And I repeat that the maximum packet

124
00:05:31,630 --> 00:05:36,630
we can transmit over the
air contains only 127 bytes.

125
00:05:36,740 --> 00:05:40,470
And with this harsh limit,
we should be able to

126
00:05:40,470 --> 00:05:43,010
somehow exploit vulnerabilities

127
00:05:43,010 --> 00:05:45,057
that we hope to find in the bridge.

128
00:05:46,440 --> 00:05:48,590
ZigBee has a full
network stack of its own.

129
00:05:49,570 --> 00:05:50,940
Like any other network stack,

130
00:05:50,940 --> 00:05:52,490
it starts with the lower levels,

131
00:05:52,490 --> 00:05:53,880
which is the Physical layer

132
00:05:53,880 --> 00:05:55,780
and the Medium Access Control layer,

133
00:05:55,780 --> 00:05:59,993
which acts as the internet acts
in normal computer networks.

134
00:06:01,120 --> 00:06:03,670
On top of that, we have
the Network Access layer,

135
00:06:03,670 --> 00:06:06,903
which is responsible for
both routing and encryption.

136
00:06:08,160 --> 00:06:10,220
Above that we have the
Application Sub layer,

137
00:06:10,220 --> 00:06:12,540
which is responsible
for routing our packet

138
00:06:12,540 --> 00:06:15,040
to the respective application
in the upper layers.

139
00:06:16,000 --> 00:06:18,200
This application could be the ZDP.

140
00:06:18,200 --> 00:06:20,560
We stands for ZigBee Device Profile

141
00:06:20,560 --> 00:06:23,280
and is responsible for
managing different aspects

142
00:06:23,280 --> 00:06:24,533
of the ZigBee protocol.

143
00:06:25,650 --> 00:06:28,750
It could be ZCL, ZigBee Cluster Library,

144
00:06:28,750 --> 00:06:31,340
which is responsible for
managing the configurations

145
00:06:31,340 --> 00:06:32,653
of the different devices.

146
00:06:33,980 --> 00:06:36,070
And it could be whatever
other applications

147
00:06:36,070 --> 00:06:37,820
or the vendor decided to implement.

148
00:06:38,720 --> 00:06:40,860
Now that we've understood
how ZigBee works,

149
00:06:40,860 --> 00:06:42,310
it's time to meet our target.

150
00:06:43,530 --> 00:06:45,390
We target for this research is going to be

151
00:06:45,390 --> 00:06:47,410
The Philips Hue smart lighting,

152
00:06:47,410 --> 00:06:48,993
now under Signify,

153
00:06:50,270 --> 00:06:52,120
Signify controls, approximately

154
00:06:52,120 --> 00:06:54,040
one third of the market in the UK.

155
00:06:54,040 --> 00:06:55,423
So it's a broad target,

156
00:06:56,380 --> 00:06:58,480
and we're going to focus
specifically on the bridge,

157
00:06:58,480 --> 00:07:00,610
because as we mentioned earlier,

158
00:07:00,610 --> 00:07:02,710
the bridge is connected
to both the radio network

159
00:07:02,710 --> 00:07:05,460
and the computer network and
we hope to bridge the two.

160
00:07:06,990 --> 00:07:08,500
Specifically, we're going to focus on

161
00:07:08,500 --> 00:07:11,350
the second generation of
hardware for the bridge,

162
00:07:11,350 --> 00:07:13,210
which is the rectangular
version of the bridge

163
00:07:13,210 --> 00:07:14,260
as seen on the light.

164
00:07:15,730 --> 00:07:17,830
If you remove the plastic
cover form the bridge,

165
00:07:17,830 --> 00:07:18,963
we can see the board.

166
00:07:19,840 --> 00:07:20,860
We're looking on a board,

167
00:07:20,860 --> 00:07:22,900
we can see on the right, in the main CPU,

168
00:07:22,900 --> 00:07:24,210
which is a Qualcomm CPU,

169
00:07:24,210 --> 00:07:26,933
usually found on WiFi enabled devices.

170
00:07:28,210 --> 00:07:29,043
Over the left,

171
00:07:29,043 --> 00:07:30,910
We can see an Atmel CPU,

172
00:07:30,910 --> 00:07:34,210
which we'll refer to as the ZigBee Modem.

173
00:07:34,210 --> 00:07:36,390
And like any other embedded device,

174
00:07:36,390 --> 00:07:39,310
we have a clear pinout for Serial Debug,

175
00:07:39,310 --> 00:07:42,443
which turned out to be quite
useful of this research.

176
00:07:44,635 --> 00:07:48,200
The main CPU is of MIPS
architecture, which is quite unique.

177
00:07:48,200 --> 00:07:50,770
And the operating system is Linux.

178
00:07:50,770 --> 00:07:51,950
This is quite refreshing

179
00:07:51,950 --> 00:07:53,800
because in pilot research projects,

180
00:07:53,800 --> 00:07:57,610
we mainly had to have real
time operating systems,

181
00:07:57,610 --> 00:07:59,400
which are harder to debug.

182
00:07:59,400 --> 00:08:01,430
This time since we have Linux,

183
00:08:01,430 --> 00:08:04,030
we hope to be able to put
it and to access it directly

184
00:08:04,030 --> 00:08:05,740
using an SSH connection

185
00:08:05,740 --> 00:08:09,019
in order to extract the
file of the film itself

186
00:08:09,019 --> 00:08:12,940
and in order to hopefully
install a remote GDB server

187
00:08:12,940 --> 00:08:14,683
in order to debug the device.

188
00:08:15,800 --> 00:08:18,490
And luckily enough, Colin
O'Flynn details in his blog,

189
00:08:18,490 --> 00:08:20,040
exactly how to root the bridge.

190
00:08:20,040 --> 00:08:23,963
We have a step by step
guide followed by a video.

191
00:08:25,350 --> 00:08:28,053
Once finished, we will
get a root SSH connection.

192
00:08:30,290 --> 00:08:31,790
When I started this research

193
00:08:31,790 --> 00:08:33,650
Eyal Ronen and told me
that the bridge is using

194
00:08:33,650 --> 00:08:37,876
a single huge process that
pretty much doing everything,

195
00:08:37,876 --> 00:08:40,554
and this is the Ipbridge.

196
00:08:40,554 --> 00:08:41,969
The Ipbridge is a single process,

197
00:08:41,969 --> 00:08:44,296
that acts as the brain of the device.

198
00:08:44,296 --> 00:08:48,081
It is responsible for parsing
incoming ZigBee messages,

199
00:08:48,081 --> 00:08:50,469
maintaining the different
ZigBee state machines

200
00:08:50,469 --> 00:08:52,933
and pretty much doing everything it needs.

201
00:08:54,350 --> 00:08:56,100
And like any embedded device,

202
00:08:56,100 --> 00:08:58,700
Ip bridge runs with root privileges,

203
00:08:58,700 --> 00:09:01,560
which means that once we
took all this process,

204
00:09:01,560 --> 00:09:03,973
we want, we don't need
any other vulnerability.

205
00:09:05,240 --> 00:09:07,500
Now that we saw all of these data,

206
00:09:07,500 --> 00:09:10,920
it's time to start looking
for vulnerabilities

207
00:09:10,920 --> 00:09:12,870
and Ipbridge is going to be our target.

208
00:09:17,480 --> 00:09:19,490
We had quite a slow start to begin with

209
00:09:19,490 --> 00:09:21,070
because due to technical issues,

210
00:09:21,070 --> 00:09:22,340
i couldn't root the bridge.

211
00:09:22,340 --> 00:09:25,050
It turns out that I don't have
the right hardware equipment,

212
00:09:25,050 --> 00:09:27,513
as my younger brother
rightfully pointed out.

213
00:09:28,510 --> 00:09:31,010
And the package we ordered got delayed,

214
00:09:31,010 --> 00:09:33,935
like pretty much any other
resource projects I've done

215
00:09:33,935 --> 00:09:35,053
thus far.

216
00:09:36,050 --> 00:09:37,450
Instead of sitting idle,

217
00:09:37,450 --> 00:09:40,310
we decided to start working
on the old firmware version,

218
00:09:40,310 --> 00:09:43,330
which we received from the
original research team.

219
00:09:43,330 --> 00:09:45,870
This is a firmware version,
which is a few years old,

220
00:09:45,870 --> 00:09:48,250
and we really hope that
it didn't change a lot

221
00:09:48,250 --> 00:09:50,650
throughout the years,
but we really don't know.

222
00:09:50,650 --> 00:09:53,823
We simply have to cross our
fingers and hope for good.

223
00:09:56,320 --> 00:09:57,890
When analyzing Ipbridge,

224
00:09:57,890 --> 00:10:00,113
we soon enough, saw something quite odd.

225
00:10:01,120 --> 00:10:03,530
The code expects strings
that we found inside

226
00:10:03,530 --> 00:10:06,650
incoming messages
instead of bits, because,

227
00:10:06,650 --> 00:10:10,570
we can see the strings
as such as ZDP or ZCL

228
00:10:10,570 --> 00:10:12,270
or even connection.

229
00:10:12,270 --> 00:10:16,860
But the maximum message
size is only 127 bytes long.

230
00:10:16,860 --> 00:10:20,270
We don't have enough
room for textual strings.

231
00:10:20,270 --> 00:10:23,730
We have enough room for mere
single bits and that's it,

232
00:10:23,730 --> 00:10:25,803
so what's going on.

233
00:10:27,010 --> 00:10:28,993
And things got complicated.

234
00:10:30,180 --> 00:10:32,960
It turns out we forgot
about the ZigBee Modem.

235
00:10:32,960 --> 00:10:35,810
The ZigBee Modem uses AtMel's BitCloud SDK

236
00:10:35,810 --> 00:10:38,330
in order to parse incoming ZigBee messages

237
00:10:38,330 --> 00:10:40,353
before they arrive to the main CPU.

238
00:10:42,140 --> 00:10:44,150
Effectively, it acts as a co-processor,

239
00:10:44,150 --> 00:10:46,240
that handles the ZigBee
lower network layers

240
00:10:46,240 --> 00:10:47,813
instead of the main CPU.

241
00:10:49,000 --> 00:10:51,920
It converts the parsed
messages to textual form

242
00:10:51,920 --> 00:10:55,233
and sends them over serial to
the main CPU to be handled.

243
00:10:56,300 --> 00:10:58,970
And of course we don't
have the firmware for it.

244
00:10:58,970 --> 00:11:00,163
So it's a black box.

245
00:11:02,520 --> 00:11:05,020
The modem reduces the attack
surface on the main CPU

246
00:11:05,020 --> 00:11:08,900
because complex parsing
is offloaded to the modem.

247
00:11:08,900 --> 00:11:11,970
And if the main CPU doesn't
handle a specific task,

248
00:11:11,970 --> 00:11:14,293
it can't be vulnerable when doing so.

249
00:11:15,220 --> 00:11:18,070
And we don't fully control
the messages which are sent

250
00:11:18,070 --> 00:11:19,080
to the main CPU

251
00:11:19,080 --> 00:11:22,333
because they are constructed
on the modem itself.

252
00:11:24,180 --> 00:11:25,850
And if that wasn't enough,

253
00:11:25,850 --> 00:11:28,210
it puts a huge question
mark on everything we find,

254
00:11:28,210 --> 00:11:30,913
because maybe the volume checks it.

255
00:11:31,850 --> 00:11:33,980
Maybe there's no check at all.

256
00:11:33,980 --> 00:11:36,520
So we'll have to add this to
the list of ongoing issues

257
00:11:36,520 --> 00:11:38,063
and really hope for the best.

258
00:11:40,260 --> 00:11:41,660
Our first vulnerability attempt

259
00:11:41,660 --> 00:11:44,740
focus on ZigBee Cluster Library,

260
00:11:44,740 --> 00:11:45,573
which ZCL.

261
00:11:46,680 --> 00:11:49,540
ZCL is responsible for
managing configurations

262
00:11:49,540 --> 00:11:54,143
and it really is similar to
SNMP, traditional IT networks.

263
00:11:55,020 --> 00:11:58,180
It offers a Read Attribute,
Write Attribute interface,

264
00:11:58,180 --> 00:12:01,040
and it supports multiple data types.

265
00:12:01,040 --> 00:12:03,770
The first data type is Boolean

266
00:12:03,770 --> 00:12:06,810
Then we have an unsigned
integer of 8 bits,

267
00:12:06,810 --> 00:12:10,283
and unsigned integer of
32 bits and even Array.

268
00:12:11,725 --> 00:12:14,470
And a variable size datatype

269
00:12:14,470 --> 00:12:15,440
in an embedded device

270
00:12:15,440 --> 00:12:18,270
is a sure recipe for vulnerabilities,

271
00:12:18,270 --> 00:12:19,353
it looks promising.

272
00:12:20,500 --> 00:12:21,590
When we dived in to look,

273
00:12:21,590 --> 00:12:24,340
how ZCL_ARRAY are being parsed in the code

274
00:12:24,340 --> 00:12:26,040
we saw the following code snippet.

275
00:12:27,410 --> 00:12:29,150
Here we can see that at first

276
00:12:29,150 --> 00:12:32,060
a 1-byte Length field is
read from the message,

277
00:12:32,060 --> 00:12:34,460
and when a fixed buffer is allocated

278
00:12:34,460 --> 00:12:38,010
over the hip with 43 bytes.

279
00:12:38,010 --> 00:12:40,790
Don't be confused by
the delay slot in MIPS.

280
00:12:40,790 --> 00:12:44,720
The assignment to register
A0 is done chronologically

281
00:12:44,720 --> 00:12:47,892
before the invocation
of the malloc function

282
00:12:47,892 --> 00:12:50,840
and that's why it's called a delay slot.

283
00:12:50,840 --> 00:12:53,830
Effectively, we allocated
fixed size buffer over the heat

284
00:12:53,830 --> 00:12:54,663
and that's it.

285
00:12:55,800 --> 00:12:57,910
Later on, we'll read the entire blob,

286
00:12:57,910 --> 00:13:02,330
from our attackers packet
into the fixed size buffer.

287
00:13:02,330 --> 00:13:03,900
And, what does it mean?

288
00:13:03,900 --> 00:13:06,630
Well, a controlled 1-byte memcopy`

289
00:13:06,630 --> 00:13:08,310
into a fixed size heap buffer

290
00:13:08,310 --> 00:13:11,130
invested the definition of
a heat based buffer overflow

291
00:13:12,800 --> 00:13:14,720
Sadly for us, it isn't the vulnerability

292
00:13:14,720 --> 00:13:18,200
until we have a working proof
of concept to trigger it.

293
00:13:18,200 --> 00:13:19,540
We don't have the latest firmware

294
00:13:19,540 --> 00:13:21,710
and things might get changed.

295
00:13:21,710 --> 00:13:25,290
The modem might block large
ZCL arrays, we don't know,

296
00:13:25,290 --> 00:13:26,300
and we can't test it

297
00:13:26,300 --> 00:13:27,870
because we don't have the radio equipment

298
00:13:27,870 --> 00:13:30,063
to transmit the attack and check it.

299
00:13:31,030 --> 00:13:34,290
Luckily enough, the package
arrived quite in time.

300
00:13:34,290 --> 00:13:35,647
And we can now root the bridge

301
00:13:35,647 --> 00:13:36,930
and extract the latest firmware

302
00:13:36,930 --> 00:13:39,690
and check if something got changed.

303
00:13:39,690 --> 00:13:41,233
And of course it didn't.

304
00:13:42,330 --> 00:13:45,920
It turns out that now ZCL
Array are no longer supported

305
00:13:45,920 --> 00:13:50,090
and instead there was additional
support for ZCL strings.

306
00:13:50,090 --> 00:13:52,593
But if we look on the support of strings,

307
00:13:53,780 --> 00:13:56,620
we consider the following
code was changed.

308
00:13:56,620 --> 00:13:59,250
Now we allocated a
dynamic buffer on the heap

309
00:13:59,250 --> 00:14:01,150
using the 1-byte Length field

310
00:14:01,150 --> 00:14:04,333
plus an additional 1-byte for
the added Null Terminator.

311
00:14:05,560 --> 00:14:08,170
This means we don't have
any vulnerability this time,

312
00:14:08,170 --> 00:14:09,003
which is bad.

313
00:14:10,690 --> 00:14:12,600
Of course, we still have some good news

314
00:14:12,600 --> 00:14:14,203
because as you can see,

315
00:14:15,100 --> 00:14:18,720
the firmware was shipped
with debug symbols.

316
00:14:18,720 --> 00:14:20,643
For some unknown reason,

317
00:14:20,643 --> 00:14:22,420
the new firmware version supports

318
00:14:23,530 --> 00:14:25,040
and was shipped with

319
00:14:25,040 --> 00:14:28,050
all of the names of all of
the functions in the firmware,

320
00:14:28,050 --> 00:14:30,140
which was really quite useful for us,

321
00:14:30,140 --> 00:14:32,290
for all of us engineering
the new firmware.

322
00:14:33,350 --> 00:14:35,100
So, what do we have?

323
00:14:35,100 --> 00:14:38,170
The latest version dropped
support for ZCL Arrays

324
00:14:38,170 --> 00:14:40,270
because now they use strings instead

325
00:14:40,270 --> 00:14:42,620
and strings don't have
a vulnerability in them.

326
00:14:43,660 --> 00:14:47,140
It's a good time to search
for other vulnerabilities.

327
00:14:47,140 --> 00:14:48,600
And we did try

328
00:14:48,600 --> 00:14:50,290
we'll really, really did try.

329
00:14:50,290 --> 00:14:51,900
And we covered most of the firmware

330
00:14:51,900 --> 00:14:54,353
and still we found pretty much nothing.

331
00:14:56,250 --> 00:14:57,363
And then we remember,

332
00:14:58,394 --> 00:15:01,000
The ZCL strings were handled correctly

333
00:15:01,000 --> 00:15:03,720
and sent to another thread, but,

334
00:15:03,720 --> 00:15:07,660
what does this thread do with
the incoming ZCL strings?

335
00:15:07,660 --> 00:15:10,133
So we traced it down to this code snippet.

336
00:15:11,370 --> 00:15:15,090
In this code snippet, we can
see the same memory location

337
00:15:15,090 --> 00:15:19,410
over the heap using the same
fixed size we saw earlier.

338
00:15:19,410 --> 00:15:22,023
So that's quite suspicious.

339
00:15:23,290 --> 00:15:27,430
We can even see that later
on, the buffer is being copied

340
00:15:27,430 --> 00:15:29,780
to the newly allocated heap buffer,

341
00:15:29,780 --> 00:15:32,490
using the link field
stored in the struct itself

342
00:15:32,490 --> 00:15:34,770
without any side checks.

343
00:15:34,770 --> 00:15:37,090
The only condition for
reaching this code snippet

344
00:15:37,090 --> 00:15:41,200
is to have the fixed style of code of 16

345
00:15:41,200 --> 00:15:43,687
stored in our struct.

346
00:15:43,687 --> 00:15:45,640
And when we go back to how we initialize

347
00:15:45,640 --> 00:15:47,730
the ZCL strings in struct,

348
00:15:47,730 --> 00:15:51,760
we can see that it indeed
uses the same upcode 16.

349
00:15:51,760 --> 00:15:54,799
So it turns out that someone forgot

350
00:15:54,799 --> 00:15:58,437
to finish the migration
from Array to String.

351
00:15:58,437 --> 00:16:02,040
Strings should have been
marked with F for strings

352
00:16:02,040 --> 00:16:05,780
and then be duplicated
using a call to STL dup.

353
00:16:05,780 --> 00:16:08,480
Instead for some exempt,

354
00:16:08,480 --> 00:16:11,560
internally, they are still
marked with 16 for Arrays

355
00:16:11,560 --> 00:16:14,360
and they'll handle using the
same vulnerable code snippet,

356
00:16:14,360 --> 00:16:15,790
We saw in the earlier firmware version,

357
00:16:15,790 --> 00:16:17,910
which is quite good from our perspective.

358
00:16:17,910 --> 00:16:21,530
So the original
vulnerability still exists,

359
00:16:21,530 --> 00:16:23,820
it is just buried a bit deeper.

360
00:16:23,820 --> 00:16:24,653
That's all.

361
00:16:25,800 --> 00:16:27,780
Time to start transmitting ZigBee messages

362
00:16:27,780 --> 00:16:29,730
and hope to take out the vulnerability.

363
00:16:38,430 --> 00:16:40,150
In order to play around with ZigBee

364
00:16:40,150 --> 00:16:41,300
like the previous research,

365
00:16:41,300 --> 00:16:43,440
we decided to use the

366
00:16:43,440 --> 00:16:46,853
ATMEGA256RFR2-XPRO board.

367
00:16:47,770 --> 00:16:49,703
It enables us to send and receive

368
00:16:49,703 --> 00:16:51,763
ZigBee frames over the radio.

369
00:16:53,390 --> 00:16:55,840
It should be computationally
equivalent to a light bulb,

370
00:16:55,840 --> 00:16:57,070
which is quite important

371
00:16:57,070 --> 00:16:58,740
because we are going to do

372
00:16:58,740 --> 00:17:01,110
all of our exploit form this board.

373
00:17:01,110 --> 00:17:02,710
And if we will succeed,

374
00:17:02,710 --> 00:17:05,070
then the same exploit
could have been performed

375
00:17:05,070 --> 00:17:06,480
for a light bulb we took over

376
00:17:06,480 --> 00:17:08,543
using the previous research findings.

377
00:17:10,600 --> 00:17:13,280
In addition, it turned out
to be even more important

378
00:17:13,280 --> 00:17:17,940
because there's really strict
timing constraints in ZigBee

379
00:17:17,940 --> 00:17:19,280
and the timing constraints dictate

380
00:17:19,280 --> 00:17:22,250
that we actually use C
code from the board itself.

381
00:17:22,250 --> 00:17:24,700
We can't use Python from
our laptop, for example.

382
00:17:26,280 --> 00:17:28,306
This means that the entire ZigBee code,

383
00:17:28,306 --> 00:17:30,430
the entire ZigBee stack
that we need to implement

384
00:17:30,430 --> 00:17:31,710
should be in C

385
00:17:31,710 --> 00:17:35,000
and the entire exploit should
also be implemented in C.

386
00:17:35,000 --> 00:17:36,300
So it's not going to be easy,

387
00:17:36,300 --> 00:17:38,823
but we'll have to live with this.

388
00:17:39,952 --> 00:17:42,470
And the vulnerable flow is only accessible

389
00:17:42,470 --> 00:17:45,070
during a process called commissioning.

390
00:17:45,070 --> 00:17:47,090
And, what is commissioning?

391
00:17:47,090 --> 00:17:47,923
Well.

392
00:17:49,000 --> 00:17:50,430
Commissioning is a process of pairing

393
00:17:50,430 --> 00:17:52,440
and associating a new light bulb.

394
00:17:52,440 --> 00:17:54,400
We have two types of commissioning.

395
00:17:54,400 --> 00:17:56,460
We have Classic Commissioning

396
00:17:56,460 --> 00:17:58,473
and we have Touchlink Commissioning.

397
00:17:59,640 --> 00:18:01,890
The Philips Hue app on
Android, which we use,

398
00:18:01,890 --> 00:18:04,190
initiates Classic Commissioning process.

399
00:18:04,190 --> 00:18:05,713
And so we focused on this one.

400
00:18:06,830 --> 00:18:09,240
Technically in theory, the ZigBee specs

401
00:18:09,240 --> 00:18:11,053
explain the entire process.

402
00:18:12,470 --> 00:18:14,730
In practice, there's a
lot of room for vendors

403
00:18:14,730 --> 00:18:17,053
to do as they wish and trust me they did.

404
00:18:19,360 --> 00:18:21,760
When analyzing the
protocol, we got quite stuck

405
00:18:21,760 --> 00:18:25,160
because there was no documented flow

406
00:18:25,160 --> 00:18:27,988
or at least no documented
flow we could find.

407
00:18:27,988 --> 00:18:29,390
There's enough documentation

408
00:18:29,390 --> 00:18:32,080
for the structure of
each specific message,

409
00:18:32,080 --> 00:18:34,980
but we don't know what
message is supposed to be sent

410
00:18:34,980 --> 00:18:37,310
and when, as a response for what,

411
00:18:37,310 --> 00:18:40,153
so we don't have any clear
flow for the commissioning.

412
00:18:41,730 --> 00:18:44,470
In addition, we can't
sniff a full conversation

413
00:18:44,470 --> 00:18:46,320
from our light bulb and the bridge

414
00:18:46,320 --> 00:18:48,210
because too many messages are sent

415
00:18:48,210 --> 00:18:49,550
and they'll send too fast.

416
00:18:49,550 --> 00:18:51,453
And we simply missed some of them.

417
00:18:53,260 --> 00:18:57,030
If that wasn't enough, we
needed cryptographic key.

418
00:18:57,030 --> 00:18:58,410
There is a transport key,

419
00:18:58,410 --> 00:19:01,310
which is shared between all
of the ZigBee light devices,

420
00:19:01,310 --> 00:19:03,840
but we don't have the key, insight.

421
00:19:03,840 --> 00:19:05,270
So, how do we get?

422
00:19:05,270 --> 00:19:06,940
We need to decrypt the messages

423
00:19:06,940 --> 00:19:10,180
really from an early phase
in the commissioning,

424
00:19:10,180 --> 00:19:11,403
we will need the key.

425
00:19:13,320 --> 00:19:15,710
Luckily for us we're not the
first to tackle this issue.

426
00:19:15,710 --> 00:19:17,940
And in this blog post,

427
00:19:17,940 --> 00:19:19,780
you can find all of the information

428
00:19:19,780 --> 00:19:21,653
for all of the keys used in

429
00:19:21,653 --> 00:19:24,870
Touchlink Commissioning and
in Classic Commissioning,

430
00:19:24,870 --> 00:19:27,480
with the values of the keys themselves.

431
00:19:27,480 --> 00:19:28,990
So we took the keys.

432
00:19:28,990 --> 00:19:30,170
We inserted them to Wireshark,

433
00:19:30,170 --> 00:19:32,220
and Wireshark can now automatically

434
00:19:32,220 --> 00:19:34,073
decrypt the messages we sniff.

435
00:19:36,150 --> 00:19:38,400
The analysis and the implementation part

436
00:19:38,400 --> 00:19:39,850
took a lot of effort,

437
00:19:39,850 --> 00:19:42,670
a lot of work days, but
eventually it worked

438
00:19:43,750 --> 00:19:45,920
We managed to fake our own light bulb.

439
00:19:45,920 --> 00:19:48,560
You can see a brand new
checkpoint research light bulb

440
00:19:48,560 --> 00:19:50,323
with the model CPR123.

441
00:19:51,210 --> 00:19:53,146
So now, our board,

442
00:19:53,146 --> 00:19:56,380
is doing all of the classic
commissioning phase,

443
00:19:56,380 --> 00:19:58,203
faking our own light bulb.

444
00:19:59,170 --> 00:20:00,743
So we could continue on.

445
00:20:01,600 --> 00:20:04,470
In order to help other
researchers with this task

446
00:20:04,470 --> 00:20:05,730
we decided to open source

447
00:20:05,730 --> 00:20:08,170
the full pickup of the
classic commissioning

448
00:20:08,170 --> 00:20:10,240
as we send it from our board.

449
00:20:10,240 --> 00:20:12,060
So instead of other researchers

450
00:20:12,060 --> 00:20:14,980
having to manually analyze
the commissioning phase,

451
00:20:14,980 --> 00:20:16,430
you can now look on the pickup,

452
00:20:16,430 --> 00:20:17,680
the decrypted pickup,

453
00:20:17,680 --> 00:20:19,643
with all of the messages we've sent.

454
00:20:22,080 --> 00:20:23,980
The lessons we learn fast forward are.

455
00:20:25,530 --> 00:20:26,820
Without user interaction,

456
00:20:26,820 --> 00:20:28,700
the bridge won't accept new lightbulbs,

457
00:20:28,700 --> 00:20:30,830
which is a good security precaution,

458
00:20:30,830 --> 00:20:32,080
but it doesn't help us.

459
00:20:32,080 --> 00:20:36,063
We will need, somehow, to
bypass this limitation.

460
00:20:37,360 --> 00:20:40,250
In addition, we have
approximately one minute

461
00:20:40,250 --> 00:20:42,750
to commission as many
light bulbs as we want,

462
00:20:42,750 --> 00:20:45,210
there's no check about.

463
00:20:45,210 --> 00:20:46,980
The user will only see the light bulbs

464
00:20:46,980 --> 00:20:49,500
in the app after they
finished a specific face,

465
00:20:49,500 --> 00:20:51,470
we labeled ZCL phase,

466
00:20:51,470 --> 00:20:53,593
which is pretty much the last,

467
00:20:54,750 --> 00:20:56,900
sorry, the last phase
in the commissioning.

468
00:20:58,120 --> 00:21:00,010
If we fake other light bulbs

469
00:21:00,010 --> 00:21:02,010
and we stop before the ZCL phase,

470
00:21:02,010 --> 00:21:03,530
the user won't be aware of that,

471
00:21:03,530 --> 00:21:05,533
which is pretty good for our attack.

472
00:21:06,620 --> 00:21:08,360
And really good news are,

473
00:21:08,360 --> 00:21:10,110
we managed to trigger the vulnerability

474
00:21:10,110 --> 00:21:11,350
during this ZCL phase.

475
00:21:11,350 --> 00:21:13,580
So we have a success.

476
00:21:13,580 --> 00:21:15,163
We really have a vulnerability.

477
00:21:17,092 --> 00:21:18,750
There's no state machine check in place.

478
00:21:18,750 --> 00:21:21,830
We can simply send whatever
ZCL strings we want,

479
00:21:21,830 --> 00:21:25,280
whenever we want ,without
any requests to get them.

480
00:21:25,280 --> 00:21:27,530
So we can pretty much do anything we want

481
00:21:27,530 --> 00:21:29,173
with the lang ZCL strings,

482
00:21:30,060 --> 00:21:32,830
as long as we do it during the ZCL phase,

483
00:21:32,830 --> 00:21:35,390
and specifically during the commissioning.

484
00:21:35,390 --> 00:21:38,220
Once the light bulb was
fully added to the network,

485
00:21:38,220 --> 00:21:40,560
it can no longer trigger
the vulnerability.

486
00:21:40,560 --> 00:21:42,640
The vulnerability will only be accessible

487
00:21:42,640 --> 00:21:44,190
during the commissioning phase.

488
00:21:45,950 --> 00:21:47,313
Time to start the exploit.

489
00:21:52,820 --> 00:21:54,800
Just a basic recap on our vulnerability,

490
00:21:54,800 --> 00:21:55,763
before we continue.

491
00:21:57,220 --> 00:21:59,943
We have a linear based buffer
overflow over the heap.

492
00:22:00,960 --> 00:22:04,492
Our buffer size is limited
to 70 controllable bytes.

493
00:22:04,492 --> 00:22:08,030
And thi s is because we
only started with 127 bytes,

494
00:22:08,030 --> 00:22:10,066
which is the MTU on ZigBee

495
00:22:10,066 --> 00:22:12,400
and the ZCL is quite
high on the ZigBee stack.

496
00:22:12,400 --> 00:22:15,340
So we lost a lot of bytes due to headers.

497
00:22:15,340 --> 00:22:18,163
We will have to settle down
with the 70 bytes we have.

498
00:22:19,690 --> 00:22:21,680
We don't have any byte
constraints on our payload,

499
00:22:21,680 --> 00:22:22,530
which is good.

500
00:22:22,530 --> 00:22:25,280
We can send null bytes,
non printable bytes,

501
00:22:25,280 --> 00:22:26,830
pretty much everything we want.

502
00:22:28,010 --> 00:22:30,630
And the destination buffer
is allocated over the heap,

503
00:22:30,630 --> 00:22:34,173
using a fixed size buffer of 43 bytes.

504
00:22:36,200 --> 00:22:37,400
Time to focus, The Heap.

505
00:22:38,660 --> 00:22:40,120
The bridge uses uClibc

506
00:22:40,120 --> 00:22:42,480
which is an old embedded
libc implementation

507
00:22:42,480 --> 00:22:43,853
using embedded devices.

508
00:22:44,800 --> 00:22:47,453
The chosen heap
implementation inside uClibc,

509
00:22:47,453 --> 00:22:48,530
is the malloc-standard,

510
00:22:48,530 --> 00:22:50,763
which is dlmalloc behind the scenes.

511
00:22:52,250 --> 00:22:54,810
Effectively, it is much like glibc,

512
00:22:54,810 --> 00:22:57,620
but with way less sanity checks.

513
00:22:57,620 --> 00:23:01,860
And this is because uClibc
stands for Micro Libc.

514
00:23:01,860 --> 00:23:04,120
It is meant to be used by devices

515
00:23:04,120 --> 00:23:07,600
without a lot of firm,
without a lot of CPU power.

516
00:23:07,600 --> 00:23:09,860
So it had to be slim

517
00:23:09,860 --> 00:23:13,923
and being slim means less
code and less sanity checks.

518
00:23:15,389 --> 00:23:17,260
All of our free buffers will fall

519
00:23:17,260 --> 00:23:19,553
into the range of what is called Fastbins.

520
00:23:20,600 --> 00:23:21,960
There's a bin for each buffer size

521
00:23:21,960 --> 00:23:24,920
in multiple of eight
bites, starting from 16,

522
00:23:24,920 --> 00:23:26,440
being the minimum size.

523
00:23:26,440 --> 00:23:28,770
So we have a buffer for,

524
00:23:28,770 --> 00:23:32,870
a bin for all of the
buffers up to 16 bytes,

525
00:23:32,870 --> 00:23:36,100
a bin for 16 to 24,

526
00:23:36,100 --> 00:23:38,010
a bin for 24 to 32

527
00:23:38,010 --> 00:23:39,453
and so on and so forth.

528
00:23:40,290 --> 00:23:43,050
Inside each bin, we will
have a singly-linked list

529
00:23:43,050 --> 00:23:44,450
of all of the Freed buffers.

530
00:23:46,320 --> 00:23:50,060
When examining the code
from free in uClibc,

531
00:23:50,060 --> 00:23:52,260
we saw the following check.

532
00:23:52,260 --> 00:23:56,000
If size is less than or equal
to some configurable amount

533
00:23:56,000 --> 00:23:57,350
called max fast,

534
00:23:57,350 --> 00:23:58,183
we will use

535
00:23:59,215 --> 00:24:02,270
the fastbins and store
our buffer inside it.

536
00:24:02,270 --> 00:24:05,210
In order to find the respective
fastbin for our buffer,

537
00:24:05,210 --> 00:24:07,480
we will use the fastbin index Morecore.

538
00:24:07,480 --> 00:24:08,530
We can see over here.

539
00:24:09,550 --> 00:24:12,460
In short, the Morecore
divides the size by eight

540
00:24:12,460 --> 00:24:13,730
and subtracts two,

541
00:24:13,730 --> 00:24:17,030
because 16 should be the minimal size,

542
00:24:17,030 --> 00:24:19,850
but there's no checking place, but,

543
00:24:19,850 --> 00:24:24,290
the size indeed is bigger or equal to 16.

544
00:24:24,290 --> 00:24:27,780
So if we will be able to call
up a buffer over the heap

545
00:24:27,780 --> 00:24:29,260
and modify the size,

546
00:24:29,260 --> 00:24:33,180
we could change the size
to be eight or even zero

547
00:24:33,180 --> 00:24:35,150
giving us the index of minus one

548
00:24:35,150 --> 00:24:36,733
and minus two respectively.

549
00:24:37,830 --> 00:24:39,630
In order to understand what will happen,

550
00:24:39,630 --> 00:24:41,880
if we will use negative indexes.

551
00:24:41,880 --> 00:24:44,560
We can see the malloc
state stocked over here

552
00:24:44,560 --> 00:24:47,950
and the variables before
the fastbins array.

553
00:24:47,950 --> 00:24:51,240
So, if we will use index minus one

554
00:24:51,240 --> 00:24:54,130
we will store our buffer
on top of the max fast

555
00:24:54,130 --> 00:24:56,440
before the fastbin array.

556
00:24:56,440 --> 00:24:59,260
Storing the pointer over
the configurable size

557
00:24:59,260 --> 00:25:00,620
for,

558
00:25:00,620 --> 00:25:02,780
fastbins will be too risky.

559
00:25:02,780 --> 00:25:04,930
It will simply avoid the heap,

560
00:25:04,930 --> 00:25:08,130
but, what will happen if
we'll use index minus two?

561
00:25:08,130 --> 00:25:12,560
Well, index minus two will
store, the pointer to our buffer

562
00:25:12,560 --> 00:25:14,870
before the malloc state variable.

563
00:25:14,870 --> 00:25:17,840
And before the malloc
state struct in memory,

564
00:25:17,840 --> 00:25:22,470
it turns out to be an unused
variable, simply nothing.

565
00:25:22,470 --> 00:25:26,530
So if we free our buffer
with the size of zero,

566
00:25:26,530 --> 00:25:28,440
it will be stored somewhere in memory

567
00:25:28,440 --> 00:25:31,900
before the malloc state
and no one will reach it.

568
00:25:31,900 --> 00:25:33,920
The next buffer will be joined to it,

569
00:25:33,920 --> 00:25:35,840
creating a ghost link list.

570
00:25:35,840 --> 00:25:38,970
We can refer to as the dev null fastbin.

571
00:25:38,970 --> 00:25:41,460
Since malloc is not aware of this bin,

572
00:25:41,460 --> 00:25:43,680
it won't extract buffers from it,

573
00:25:43,680 --> 00:25:45,940
and all of the buffers with free0ed

574
00:25:45,940 --> 00:25:47,230
will be joined to this bin,

575
00:25:47,230 --> 00:25:49,690
but won't be returned to the heap itself

576
00:25:49,690 --> 00:25:52,300
effectively and ambulance enabling us to

577
00:25:52,300 --> 00:25:55,483
gradually shape the heap
in a desired structure.

578
00:25:57,970 --> 00:26:00,987
The plan for our heap
overflow is quite simple.

579
00:26:00,987 --> 00:26:04,340
We can see our buffering blue
and the buffer adjacent to it

580
00:26:04,340 --> 00:26:05,783
normally in purple.

581
00:26:07,280 --> 00:26:09,270
The plan is to modify only the size

582
00:26:09,270 --> 00:26:11,523
and the pointer of the adjacent buffer.

583
00:26:13,150 --> 00:26:15,190
If you change the size to one,

584
00:26:15,190 --> 00:26:17,500
which means a size of zero bytes

585
00:26:17,500 --> 00:26:21,990
and one for the previous buffer is in use.

586
00:26:21,990 --> 00:26:25,070
Then the buffer will go
to the dev null link list

587
00:26:25,070 --> 00:26:29,223
because size zero will
reflect it to index minus two.

588
00:26:30,390 --> 00:26:34,083
And the pointer will be changed
to be our arbitrary address.

589
00:26:35,430 --> 00:26:37,960
Effectively, we want
to get this structure.

590
00:26:37,960 --> 00:26:41,390
We want to call up the singly
link list inside Fastbin

591
00:26:41,390 --> 00:26:44,226
so that an arbitrary buffer will be stored

592
00:26:44,226 --> 00:26:47,620
or at least malloc will think
with an arbitrary buffer,

593
00:26:47,620 --> 00:26:50,263
will be stored in our arbitrary address.

594
00:26:51,330 --> 00:26:53,760
The goal is, we want to confuse malloc.

595
00:26:53,760 --> 00:26:56,440
So it will allocate a buffer
at an arbitrary address,

596
00:26:56,440 --> 00:27:00,540
and then will let us write
our data into this buffer.

597
00:27:00,540 --> 00:27:02,240
Effectively giving us a light,

598
00:27:02,240 --> 00:27:03,863
what will exploit parameter.

599
00:27:05,490 --> 00:27:08,460
The heap shaping strategy is as follows.

600
00:27:08,460 --> 00:27:11,550
If we overflowed a free
fastbin of a buffer,

601
00:27:11,550 --> 00:27:14,600
then we won, this is
exactly what we aim at.

602
00:27:14,600 --> 00:27:17,360
We co-opted the singly link
list inside the fastbin,

603
00:27:17,360 --> 00:27:19,223
and we will get our allocation.

604
00:27:20,930 --> 00:27:22,720
If we overflowed the used buffer,

605
00:27:22,720 --> 00:27:24,440
then when it will be freed,

606
00:27:24,440 --> 00:27:26,490
it will go to the dev/null fastbin.

607
00:27:26,490 --> 00:27:28,040
And we won't see it any longer.

608
00:27:29,860 --> 00:27:33,340
If we overflowed the used
buffer that lives forever.

609
00:27:33,340 --> 00:27:36,190
Oh, well, nothing would happen
and no one will notice it,

610
00:27:37,810 --> 00:27:40,540
but if we overflowed
the free large buffer,

611
00:27:40,540 --> 00:27:42,076
then we're in trouble.

612
00:27:42,076 --> 00:27:43,250
We will probably crash soon.

613
00:27:43,250 --> 00:27:45,123
So we really don't want to do that.

614
00:27:46,250 --> 00:27:48,599
If done correctly, we will get the desired

615
00:27:48,599 --> 00:27:50,516
Malloc-Where appointed.

616
00:27:51,710 --> 00:27:53,220
Malloc-Where will grant us the ability

617
00:27:53,220 --> 00:27:54,930
to write on the GOT.

618
00:27:54,930 --> 00:27:58,180
The GOT is the Global-Offset Table.

619
00:27:58,180 --> 00:28:00,280
It's a global table of function pointers

620
00:28:00,280 --> 00:28:02,110
used to execute level of functions,

621
00:28:02,110 --> 00:28:05,670
such as a free, malloc, sleep,

622
00:28:05,670 --> 00:28:09,320
memcopy, and pretty much
every other library call.

623
00:28:09,320 --> 00:28:11,870
And luckily for us, the
GOT is at the fixed address

624
00:28:14,100 --> 00:28:17,190
The modified function pointer
will jump to our shellcode,

625
00:28:17,190 --> 00:28:20,380
or at least in theory, because
it sounds easy on paper

626
00:28:20,380 --> 00:28:22,393
but it is way harder in real life.

627
00:28:28,520 --> 00:28:30,170
Time to construct the shell code.

628
00:28:32,300 --> 00:28:34,533
Location, location, location.

629
00:28:35,690 --> 00:28:37,600
We need to store a binary shellcode

630
00:28:37,600 --> 00:28:39,193
in his fixed global address.

631
00:28:40,120 --> 00:28:42,670
The problem is, we only
get textual messages

632
00:28:42,670 --> 00:28:43,950
from the ZigBee Modem,

633
00:28:43,950 --> 00:28:48,340
so we don't get any controlled binary data

634
00:28:48,340 --> 00:28:49,573
into the main CPU.

635
00:28:51,240 --> 00:28:54,413
We found only one good candidate
for such a possible buffer,

636
00:28:55,360 --> 00:28:57,123
and this is The ZigBee phone book.

637
00:28:58,380 --> 00:29:00,270
This is an Array of ZigBee addresses

638
00:29:00,270 --> 00:29:03,123
seen by or advertise to the bridge.

639
00:29:04,520 --> 00:29:07,600
It can hold up to 65
records of 16 bytes each

640
00:29:07,600 --> 00:29:10,190
giving us upper bound of approximately

641
00:29:10,190 --> 00:29:12,817
one kilobyte for the entire shellcode.

642
00:29:13,900 --> 00:29:16,833
It's not a lot of bytes, but
it should be enough for us.

643
00:29:18,960 --> 00:29:21,050
The Neighbor Record inside
the ZigBee phone book

644
00:29:21,050 --> 00:29:23,700
is constructed as follows.

645
00:29:23,700 --> 00:29:27,170
The first eight bytes are for
the extended network address,

646
00:29:27,170 --> 00:29:29,250
which we fully controlled.

647
00:29:29,250 --> 00:29:31,400
After all that we have
additional two bytes

648
00:29:31,400 --> 00:29:35,950
for the Short network address
again fully controlled.

649
00:29:35,950 --> 00:29:38,410
And they'll stack, a flag ended,

650
00:29:38,410 --> 00:29:41,860
which is quite reasonably,
reasonable, sorry,

651
00:29:41,860 --> 00:29:45,990
because now we have six bytes
for miscellaneous fields

652
00:29:45,990 --> 00:29:47,740
and we don't really control them.

653
00:29:47,740 --> 00:29:50,350
So we have 10 consecutive
bytes we control,

654
00:29:50,350 --> 00:29:52,513
but we don't control the entire memory.

655
00:29:54,865 --> 00:29:56,090
Oh.

656
00:29:56,090 --> 00:29:59,130
And about that, it turns
out the bridge is unstable

657
00:29:59,130 --> 00:30:01,830
when it gets more than 20 records.

658
00:30:01,830 --> 00:30:03,660
So this is going to be,

659
00:30:03,660 --> 00:30:06,363
quite a small shell code.

660
00:30:08,240 --> 00:30:11,890
The initial plan was simple.

661
00:30:11,890 --> 00:30:13,690
It looks infeasible to restore,

662
00:30:13,690 --> 00:30:16,440
the execution flow because
we pretty much went to heap.

663
00:30:17,550 --> 00:30:20,070
Instead, the outer
shellcode will try to patch

664
00:30:20,070 --> 00:30:24,010
the binary on the file system
and install a backdoor.

665
00:30:24,010 --> 00:30:26,360
After the process will crash,

666
00:30:26,360 --> 00:30:30,240
a deamon will reboot the
binary with our backdoor,

667
00:30:30,240 --> 00:30:33,023
and then we will trigger it
from an another light bulb.

668
00:30:34,585 --> 00:30:38,040
The problem is, both the
patch and the file path

669
00:30:38,040 --> 00:30:40,760
don't fit in 10 consecutive bytes each

670
00:30:40,760 --> 00:30:45,110
so we can't decode them
properly in the ZigBee fund.

671
00:30:45,110 --> 00:30:46,980
This is the solution for this problem

672
00:30:46,980 --> 00:30:48,593
is purely academic.

673
00:30:49,900 --> 00:30:53,330
An ideal shellcode by reduction will be,

674
00:30:53,330 --> 00:30:55,780
use the 10 consecutive bytes per record

675
00:30:55,780 --> 00:30:56,813
to build a decoder.

676
00:30:56,813 --> 00:30:59,730
And the decoder will decode
the rest of the records

677
00:30:59,730 --> 00:31:02,163
to be nicely ordered in memory.

678
00:31:03,480 --> 00:31:05,970
In mips 16, a jump to the next record

679
00:31:05,970 --> 00:31:09,900
will only costs us two bytes
giving us eight spare bytes

680
00:31:09,900 --> 00:31:12,663
in each record to construct our decoder.

681
00:31:14,920 --> 00:31:16,870
But there are problems with this plan.

682
00:31:17,980 --> 00:31:19,760
We need to clear the instruction cache

683
00:31:19,760 --> 00:31:21,910
before jumping into
the unpacked shellcode.

684
00:31:22,870 --> 00:31:26,363
And cause this is a Mips CPU
and we crashed when trying,

685
00:31:27,720 --> 00:31:30,270
and if we use sleep to clear the caches as

686
00:31:30,270 --> 00:31:33,580
people usually do, the
watchdog will kill the process

687
00:31:33,580 --> 00:31:35,253
because it doesn't respond.

688
00:31:36,490 --> 00:31:38,489
And we don't have enough records

689
00:31:38,489 --> 00:31:42,420
to silence the watchdog
sleep and use a decoders

690
00:31:42,420 --> 00:31:45,110
so the ideal shellcode is good on paper,

691
00:31:45,110 --> 00:31:46,923
but it's not practical.

692
00:31:48,670 --> 00:31:50,973
Instead we went for a more bold design.

693
00:31:52,280 --> 00:31:53,950
We will restore the execution flow.

694
00:31:53,950 --> 00:31:55,773
We really don't have any choice.

695
00:31:56,930 --> 00:31:59,260
This means we will call mprotect()

696
00:31:59,260 --> 00:32:01,700
to modify the permissions of the code

697
00:32:01,700 --> 00:32:06,594
in memory form executable to
be executable and writeable.

698
00:32:06,594 --> 00:32:09,610
And we will install the
back door in RAM during

699
00:32:09,610 --> 00:32:10,443
the execution.

700
00:32:12,560 --> 00:32:17,000
A few days, and one
hand-crafted shellcode later on,

701
00:32:17,000 --> 00:32:20,520
we have a shellcode that
fully restores the execution.

702
00:32:20,520 --> 00:32:21,690
It restores the GOT.

703
00:32:21,690 --> 00:32:22,860
It restores the heap.

704
00:32:22,860 --> 00:32:25,210
And it restores pretty
much everything we need.

705
00:32:26,620 --> 00:32:29,670
In addition, the shellcode
will only cost us 16 records,

706
00:32:29,670 --> 00:32:32,303
which is well in budget, less than 20.

707
00:32:34,080 --> 00:32:36,763
And here we can see the
shell code in either.

708
00:32:37,700 --> 00:32:40,020
From the first record, we
will jump to the second

709
00:32:40,020 --> 00:32:42,610
and then we'll jump to the third

710
00:32:42,610 --> 00:32:44,170
and so on and so forth

711
00:32:44,170 --> 00:32:46,220
until we install the back door

712
00:32:46,220 --> 00:32:47,770
and restore the execution flow.

713
00:32:50,010 --> 00:32:52,760
When we connect all of the dots together,

714
00:32:52,760 --> 00:32:54,100
the backdoor shellcode will give us

715
00:32:54,100 --> 00:32:56,700
an Arbitrary-Write primitive.

716
00:32:56,700 --> 00:32:59,470
Our exploit will fake an
additional legitimate light bulb,

717
00:32:59,470 --> 00:33:02,490
but we leverage this arbitrary
light primitive we installed

718
00:33:03,420 --> 00:33:06,233
and we'll use it to hide
Scouts loader to memory.

719
00:33:07,820 --> 00:33:10,580
Upon execution, Scout will
load the full payload,

720
00:33:10,580 --> 00:33:13,223
which in this case, we
chosen to use eternal blue.

721
00:33:14,950 --> 00:33:19,190
Here we can see that scout
drop the file on temp exploit

722
00:33:19,190 --> 00:33:23,070
with good privileges and
this temp exploit file

723
00:33:23,070 --> 00:33:25,290
will use EternalBlue to attack computers

724
00:33:25,290 --> 00:33:26,980
inside the computer network,

725
00:33:26,980 --> 00:33:29,373
which is a good time for our demo.

726
00:33:39,608 --> 00:33:42,690
Here we can see the light
bulb and the user using it.

727
00:33:42,690 --> 00:33:43,980
We can see that it works.

728
00:33:43,980 --> 00:33:46,570
The app works fine and the user can modify

729
00:33:46,570 --> 00:33:48,883
the color of the light bulb as he wishes.

730
00:33:55,120 --> 00:33:56,260
When the attacker starts,

731
00:33:56,260 --> 00:33:58,397
he will try to hijack the light bulb

732
00:33:58,397 --> 00:34:01,060
and steal it from the network.

733
00:34:01,060 --> 00:34:03,320
And once it join the attackers network,

734
00:34:03,320 --> 00:34:04,880
the attacker will change the light bulb

735
00:34:04,880 --> 00:34:06,730
to a hideous color, to annoy the user

736
00:34:07,990 --> 00:34:09,680
so that the user will see that something

737
00:34:09,680 --> 00:34:11,130
is wrong with his light bulb.

738
00:34:12,850 --> 00:34:16,373
So we took over the light
bulb and now it's ours.

739
00:34:17,490 --> 00:34:18,970
When the user sees that
something is wrong,

740
00:34:18,970 --> 00:34:22,050
he can see that he no longer
controls the light bulb,

741
00:34:22,050 --> 00:34:24,180
he can't change the light bulbs color.

742
00:34:24,180 --> 00:34:26,320
And it seems to be unreachable

743
00:34:26,320 --> 00:34:27,983
when it sees it over the app.

744
00:34:29,410 --> 00:34:31,220
The only way to reinstall the light bulb

745
00:34:31,220 --> 00:34:33,190
is to delete it and tell the bridge

746
00:34:33,190 --> 00:34:35,270
to search for new light bulbs.

747
00:34:35,270 --> 00:34:37,933
And this is when our attack
will officially start.

748
00:34:39,120 --> 00:34:40,670
We'll fake a legitimate light bulb.

749
00:34:40,670 --> 00:34:42,090
So the user will be happy.

750
00:34:42,090 --> 00:34:43,240
This is our light bulb.

751
00:34:44,100 --> 00:34:46,120
And we will fake it as the user

752
00:34:46,120 --> 00:34:49,140
actually configures the
light bulb as he wishes

753
00:34:49,140 --> 00:34:51,390
though the user won't see
that something is wrong

754
00:34:51,390 --> 00:34:53,233
with our fake light bulb.

755
00:34:56,410 --> 00:34:58,903
Behind the scene the full
attack will take place.

756
00:35:02,910 --> 00:35:06,740
Here we can see that the bridge
is connected to the laptop.

757
00:35:06,740 --> 00:35:09,530
So it's connected to the computer network.

758
00:35:09,530 --> 00:35:10,520
And now behind the scene,

759
00:35:10,520 --> 00:35:12,070
we will use our vulnerability,

760
00:35:12,070 --> 00:35:13,580
shape the heap and take over the bridge

761
00:35:13,580 --> 00:35:16,510
and from the bridge we
will use Eternal-blue

762
00:35:16,510 --> 00:35:20,500
to attack the computer inside
the network and pop a cork.

763
00:35:20,500 --> 00:35:22,093
So our attack worked.

764
00:35:24,810 --> 00:35:26,633
Time for the coordinated disclosure.

765
00:35:27,730 --> 00:35:29,720
The vulnerability was reported to Signify

766
00:35:29,720 --> 00:35:31,863
on the 5th of November, 2019.

767
00:35:32,780 --> 00:35:35,150
The vendor confirmed a
vulnerability on the same day,

768
00:35:35,150 --> 00:35:36,750
which is quite impressive.

769
00:35:36,750 --> 00:35:40,430
It's even more impressive
because not only did the vendor

770
00:35:40,430 --> 00:35:43,320
send it's acknowledgement on the same day

771
00:35:43,320 --> 00:35:45,290
when it received our report,

772
00:35:45,290 --> 00:35:49,210
it actually acknowledged the
existence of the vulnerability,

773
00:35:49,210 --> 00:35:52,210
which it found in the code,
according to our report.

774
00:35:52,210 --> 00:35:56,090
So the vendor did pretty much
everything in a single day,

775
00:35:56,090 --> 00:35:57,723
which is very impressive.

776
00:35:59,810 --> 00:36:01,410
Later on Signify issued a patch

777
00:36:01,410 --> 00:36:03,273
via an automatic update in January,

778
00:36:04,430 --> 00:36:06,740
and you can find the
full details and advisory

779
00:36:06,740 --> 00:36:07,810
in our blog post

780
00:36:07,810 --> 00:36:11,490
and the official CVE issued
for this specific vulnerability

781
00:36:11,490 --> 00:36:14,823
is CVE-2020-6007.

782
00:36:16,060 --> 00:36:18,980
And if you have Philips
Hue lighting in your office

783
00:36:18,980 --> 00:36:21,220
or in your home, don't worry.

784
00:36:21,220 --> 00:36:22,750
All of their products should have received

785
00:36:22,750 --> 00:36:23,923
the update by now.

786
00:36:25,830 --> 00:36:26,663
Conclusions.

787
00:36:28,370 --> 00:36:31,080
Even with an MTU of 127 bytes,

788
00:36:31,080 --> 00:36:33,410
ZigBee vulnerabilities
are indeed exploitable.

789
00:36:33,410 --> 00:36:34,873
as we've shown in our demo.

790
00:36:36,867 --> 00:36:41,610
Security mitigations only work
when they are on by default.

791
00:36:41,610 --> 00:36:43,940
The Ipbridge binary was compiled to use

792
00:36:43,940 --> 00:36:45,610
static, fixed addresses.

793
00:36:45,610 --> 00:36:47,810
So we were able to target the GOT,

794
00:36:47,810 --> 00:36:49,500
which was on a fixed address

795
00:36:49,500 --> 00:36:52,053
even without an information
leak vulnerability.

796
00:36:53,240 --> 00:36:55,720
The binary was not compiled
with any stack canaries,

797
00:36:55,720 --> 00:36:57,030
the GOT was writeable,

798
00:36:57,030 --> 00:36:59,830
so we could do pretty much
everything we want to do

799
00:36:59,830 --> 00:37:02,670
once we had an initial vulnerability.

800
00:37:02,670 --> 00:37:06,080
Still, there was ASLR
in place for the heap,

801
00:37:06,080 --> 00:37:08,670
for the stack and for
the loaded libraries,

802
00:37:08,670 --> 00:37:10,110
and that's thanks to Linux.

803
00:37:10,110 --> 00:37:12,740
So, if it's on by
default, you will get it.

804
00:37:12,740 --> 00:37:15,320
But if you need to manually do
something in your make file,

805
00:37:15,320 --> 00:37:18,323
you won't get it, in most common cases.

806
00:37:20,300 --> 00:37:23,370
And smart devices are becoming
popular by the minute.

807
00:37:23,370 --> 00:37:26,130
And yet we can't even
trust our own light bulbs.

808
00:37:26,130 --> 00:37:28,373
So maybe we should do something about it.

809
00:37:30,490 --> 00:37:32,390
We can't finish this research

810
00:37:32,390 --> 00:37:34,290
and this presentation without saying

811
00:37:34,290 --> 00:37:35,920
special thanks to everyone that helped

812
00:37:35,920 --> 00:37:37,500
make this research possible.

813
00:37:37,500 --> 00:37:40,940
So we have Eyal Ronen
for the research idea

814
00:37:40,940 --> 00:37:42,583
and the active guidance.

815
00:37:43,910 --> 00:37:45,490
Colin O'Flynn for the detailed writeups

816
00:37:45,490 --> 00:37:46,323
on rooting the bridge

817
00:37:46,323 --> 00:37:48,303
and the entire hardware analysis of it.

818
00:37:50,030 --> 00:37:52,620
For Peter for publishing
the ZigBee transport keys

819
00:37:52,620 --> 00:37:53,550
for the light bulb,

820
00:37:53,550 --> 00:37:55,853
which we used and
couldn't continue without.

821
00:37:57,290 --> 00:38:00,290
And for Yaron Itkin for the
crucial hardware support

822
00:38:00,290 --> 00:38:01,710
along the way.

823
00:38:01,710 --> 00:38:02,810
Thanks little brother.

824
00:38:03,840 --> 00:38:05,070
And last but not least,

825
00:38:05,070 --> 00:38:07,890
therefore the entire cp<r>
research team for their support

826
00:38:07,890 --> 00:38:10,463
alongside this very long research.

827
00:38:11,700 --> 00:38:12,970
Until the next time,

828
00:38:12,970 --> 00:38:14,570
thank you for joining this talk.

