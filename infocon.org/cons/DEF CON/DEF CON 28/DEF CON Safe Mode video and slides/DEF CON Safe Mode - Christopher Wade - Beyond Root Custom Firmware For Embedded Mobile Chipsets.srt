1
00:00:04,550 --> 00:00:06,400
- Hello everyone, my
name is Christopher Wade

2
00:00:06,400 --> 00:00:07,330
and today I'm going to be talking to you

3
00:00:07,330 --> 00:00:09,583
about custom firmware for
embedded mobile chipsets.

4
00:00:09,583 --> 00:00:12,840
This being custom firmware
built for chipsets

5
00:00:12,840 --> 00:00:14,810
that are found in mobile phones,

6
00:00:14,810 --> 00:00:16,530
but are not part of the
core operating system.

7
00:00:16,530 --> 00:00:19,093
I usually deal with certain
aspects of the hardware.

8
00:00:19,093 --> 00:00:19,950
A bit about me.

9
00:00:19,950 --> 00:00:21,740
I'm a Security Consultant
at Pen Test Partners

10
00:00:21,740 --> 00:00:22,820
where I mainly work in hardware,

11
00:00:22,820 --> 00:00:24,140
automotive and maritime.

12
00:00:24,140 --> 00:00:25,490
But today we're mainly gonna be talking

13
00:00:25,490 --> 00:00:28,810
about attacking mobile
phones and embedded firmware.

14
00:00:28,810 --> 00:00:30,700
So the origin of this
project was that I'd found

15
00:00:30,700 --> 00:00:32,580
that smart phones that I'd
bought and rooted contained

16
00:00:32,580 --> 00:00:35,120
a huge amount of closed
firmware and closed hardware,

17
00:00:35,120 --> 00:00:37,510
which you couldn't modify
even after rooting them due

18
00:00:37,510 --> 00:00:39,250
to signature checking restrictions,

19
00:00:39,250 --> 00:00:42,200
or just lack of open
knowledge about the protocols

20
00:00:42,200 --> 00:00:43,790
used by the devices.

21
00:00:43,790 --> 00:00:45,330
Because of this, I
thought if I could break

22
00:00:45,330 --> 00:00:47,060
the firmware protections
on some of these chips,

23
00:00:47,060 --> 00:00:48,310
that I'd be able to
expand the functionality

24
00:00:48,310 --> 00:00:50,910
of my phone more.

25
00:00:50,910 --> 00:00:52,990
There's a few ways one
can do this without having

26
00:00:52,990 --> 00:00:54,860
to do too much a modification
of their phone and are

27
00:00:54,860 --> 00:00:57,000
well known such as WiFi monitor mode,

28
00:00:57,000 --> 00:00:59,360
which can be activated
in Snapdragon chipsets

29
00:00:59,360 --> 00:01:02,510
by echoing four into a
specific kernel parameter

30
00:01:02,510 --> 00:01:04,190
in the fast system,

31
00:01:04,190 --> 00:01:06,070
which converts it from two WiFi chipsets

32
00:01:06,070 --> 00:01:08,220
into a monitor mode chipset.

33
00:01:08,220 --> 00:01:10,290
Also, if you hard custom firmware

34
00:01:10,290 --> 00:01:14,540
to a Broadcom chipset and
modify your kernel slightly,

35
00:01:14,540 --> 00:01:17,133
you can get monitor mode
that way on Broadcom.

36
00:01:18,940 --> 00:01:22,010
You can also modify the
kernel in most mobile devices

37
00:01:22,010 --> 00:01:23,760
to use USB device emulation.

38
00:01:23,760 --> 00:01:26,270
So by disabling the
functionality of things like

39
00:01:26,270 --> 00:01:30,480
ADB or standard MTP and
PTP for Android devices,

40
00:01:30,480 --> 00:01:33,560
you can enable features such
as the Gadget fan system,

41
00:01:33,560 --> 00:01:34,950
which allows you to emulate any

42
00:01:34,950 --> 00:01:37,940
USB device you'd like from a memory stick

43
00:01:37,940 --> 00:01:39,673
to anything more esoteric.

44
00:01:41,090 --> 00:01:43,690
Further to this, when
I root mobile phones,

45
00:01:43,690 --> 00:01:46,340
I usually like to add Debian
root onto them, this being

46
00:01:46,340 --> 00:01:47,670
a Debian file system,

47
00:01:47,670 --> 00:01:50,800
which can be built with
whoever you need to bootstrap,

48
00:01:50,800 --> 00:01:51,720
and a small script,

49
00:01:51,720 --> 00:01:54,580
which can be used to mount up
all the correct device files

50
00:01:54,580 --> 00:01:57,380
in that file system and set up SSH

51
00:01:57,380 --> 00:02:00,230
so that one can ssh
directly into this portion

52
00:02:00,230 --> 00:02:02,070
of their phone without affecting the main

53
00:02:02,070 --> 00:02:05,333
Android operating system, but
still affect the hardware.

54
00:02:06,930 --> 00:02:09,470
I wanted to look at NFC on
Android for this project,

55
00:02:09,470 --> 00:02:11,330
because I'd found that
there was very little

56
00:02:11,330 --> 00:02:13,970
research done on the firmware
of NFC chips on almost

57
00:02:13,970 --> 00:02:16,790
any device, but mainly on phones.

58
00:02:16,790 --> 00:02:20,180
NFC on Android is restricted
some very low level

59
00:02:20,180 --> 00:02:22,530
features such as generic reader mode.

60
00:02:22,530 --> 00:02:25,700
So reading from tags,
using certain applications,

61
00:02:25,700 --> 00:02:29,220
mobile payments, which
are very popular nowadays,

62
00:02:29,220 --> 00:02:31,590
NDEF communication, which
was slightly more complex

63
00:02:31,590 --> 00:02:34,360
and host-card emulation, which
has emulation of NFC tags,

64
00:02:34,360 --> 00:02:35,970
but in a very limited manner.

65
00:02:35,970 --> 00:02:37,510
While these allowed for
certain attacks such

66
00:02:37,510 --> 00:02:39,050
as relay attacks to be performed,

67
00:02:39,050 --> 00:02:41,650
they weren't complete in
what they can be done with.

68
00:02:42,820 --> 00:02:44,620
NFC attack tools often have features such

69
00:02:44,620 --> 00:02:45,530
as reader-based attacks.

70
00:02:45,530 --> 00:02:48,000
That's been trying to
decrypt or attack NFC tags

71
00:02:48,000 --> 00:02:49,140
by the reader.

72
00:02:49,140 --> 00:02:52,710
Raw tag emulation, emulation
of any NFC tag you wish,

73
00:02:52,710 --> 00:02:54,970
or passive sniffing of NFC communication

74
00:02:54,970 --> 00:02:57,290
by basically performing
a man in the middle

75
00:02:57,290 --> 00:02:58,840
between the reader and the tag.

76
00:02:59,810 --> 00:03:01,360
My first target device was

77
00:03:01,360 --> 00:03:05,050
my Samsung S6, the SM-G920F,
which an older smartphone,

78
00:03:05,050 --> 00:03:07,130
found in the EU, there's
different versions

79
00:03:07,130 --> 00:03:09,180
of the same phone in different countries.

80
00:03:09,180 --> 00:03:11,380
And I found that it
allowed for OEM unknocking

81
00:03:11,380 --> 00:03:13,580
and deployment of custom
ROMs, which meant I could

82
00:03:13,580 --> 00:03:15,040
root it very easily and gain access

83
00:03:15,040 --> 00:03:16,630
to the hardware as needed.

84
00:03:16,630 --> 00:03:19,670
I found that it used a proprietary
Samsung NFC controller,

85
00:03:19,670 --> 00:03:22,820
but this was not used in some US versions.

86
00:03:22,820 --> 00:03:25,810
This NFC controller was
the S3FWRN5 developed

87
00:03:25,810 --> 00:03:27,610
by Samsung Semiconductor.

88
00:03:27,610 --> 00:03:29,610
And it was utilized in the non-US versions

89
00:03:29,610 --> 00:03:31,923
of the Samsung S6 and Note 4.

90
00:03:33,190 --> 00:03:35,460
This chipset boasted the ability to update

91
00:03:36,400 --> 00:03:37,233
certain firmware security,

92
00:03:37,233 --> 00:03:39,550
meaning that people can
deploy custom firmware.

93
00:03:39,550 --> 00:03:42,840
Utilizes an ARM SC0000
SecureCore architecture,

94
00:03:42,840 --> 00:03:46,563
and it was communicated with
via I2C and GPIO on a phone.

95
00:03:47,730 --> 00:03:49,570
As smartphones are essentially embedded

96
00:03:49,570 --> 00:03:51,660
Linux devices when you get
rid of the Android side,

97
00:03:51,660 --> 00:03:54,660
I found that the chipset
was communicated with via

98
00:03:54,660 --> 00:03:56,780
GPIO and I2C communication,

99
00:03:56,780 --> 00:03:58,487
which can be performed via device files

100
00:03:58,487 --> 00:04:00,570
and the Linux kernel.

101
00:04:00,570 --> 00:04:03,370
However, I found that
Samsung had abstracted

102
00:04:03,370 --> 00:04:04,920
these into a custom driver,

103
00:04:04,920 --> 00:04:07,620
which I can access using the
device file /dev/sec-nfc.

104
00:04:09,080 --> 00:04:11,783
I looked into how it
communicated via this and found

105
00:04:11,783 --> 00:04:14,540
they use IO controls to
power the chip on and off,

106
00:04:14,540 --> 00:04:16,883
and file reads and writes
to communicate over I2C.

107
00:04:18,670 --> 00:04:21,080
NFC chips communicate with a very standard

108
00:04:21,080 --> 00:04:22,910
protocol called NCI.

109
00:04:22,910 --> 00:04:26,760
This is a protocol which
is used to simplify

110
00:04:26,760 --> 00:04:28,830
NFC communication functionality in phones

111
00:04:28,830 --> 00:04:32,260
and other devices, but also
restricts it quite heavily.

112
00:04:32,260 --> 00:04:35,474
It works by sending three
bytes for the group,

113
00:04:35,474 --> 00:04:38,330
the operation ID, so
what has been performed

114
00:04:38,330 --> 00:04:40,873
on that group, such as
Core, RF Vendor Specific,

115
00:04:41,930 --> 00:04:44,020
and length, which is a one by parameter,

116
00:04:44,020 --> 00:04:45,870
which sets the length of the payload.

117
00:04:47,050 --> 00:04:49,070
It supports a non-standard functionality

118
00:04:49,070 --> 00:04:52,330
of either the vendor
group ID, which is defined

119
00:04:52,330 --> 00:04:54,950
by F which allows
non-standard functionality

120
00:04:54,950 --> 00:04:55,970
to be implemented.

121
00:04:55,970 --> 00:04:57,530
There's no restrictions in the protocol,

122
00:04:57,530 --> 00:05:00,790
which dictate what
should happen when these.

123
00:05:00,790 --> 00:05:02,860
What are these functions do.

124
00:05:02,860 --> 00:05:06,780
So any developer who
creates an NFC chip can make

125
00:05:06,780 --> 00:05:08,610
these do things that they
weren't necessarily intended

126
00:05:08,610 --> 00:05:11,350
to for debugging purposes
or certain configurations

127
00:05:11,350 --> 00:05:12,990
that were specific to the chip.

128
00:05:12,990 --> 00:05:15,010
I found this to be used
in the Samsung chip,

129
00:05:15,010 --> 00:05:18,210
mainly for deploying firmware files to us,

130
00:05:18,210 --> 00:05:19,950
for things like frequency, et cetera,

131
00:05:19,950 --> 00:05:21,800
post deployment of the core firmware.

132
00:05:23,210 --> 00:05:27,460
The S3FWRN5 was found
to support firmware I2C

133
00:05:27,460 --> 00:05:29,620
via the same endpoint as NCI.

134
00:05:29,620 --> 00:05:31,560
However, I found that
the firmware updates use

135
00:05:31,560 --> 00:05:33,630
their own custom protocol,

136
00:05:33,630 --> 00:05:35,780
which did not use any NCI communication.

137
00:05:35,780 --> 00:05:38,780
Now, this is the case in
almost any NFC chip I tested.

138
00:05:38,780 --> 00:05:41,270
However, I found this
quite interested as a lot

139
00:05:41,270 --> 00:05:44,520
of them had very similar
protocols to NCI to do this.

140
00:05:44,520 --> 00:05:46,910
These firmware files were
found in the vendor partition

141
00:05:46,910 --> 00:05:49,303
on the file system of the phone.

142
00:05:50,530 --> 00:05:51,990
I enabled debug mode on this

143
00:05:51,990 --> 00:05:54,973
via going into these vendor
configurations in /system.

144
00:05:56,092 --> 00:05:59,147
I modified the .rc
configs for this chipset

145
00:06:00,530 --> 00:06:03,830
to enable logging and
force firmware updates,

146
00:06:03,830 --> 00:06:06,070
as well as find the names and locations

147
00:06:06,070 --> 00:06:07,880
of the firmware files.

148
00:06:07,880 --> 00:06:10,220
Using this, I can now trace
out any firmware updates

149
00:06:10,220 --> 00:06:11,483
that occurred via Logcat.

150
00:06:13,340 --> 00:06:15,780
Doing this, I could dump
all the the communication

151
00:06:15,780 --> 00:06:17,330
out and I will analyze

152
00:06:17,330 --> 00:06:19,480
how the firmware updates were performed.

153
00:06:19,480 --> 00:06:21,350
It was found to use a four-byte header

154
00:06:21,350 --> 00:06:22,300
followed by payload.

155
00:06:22,300 --> 00:06:25,223
So address zero being the command type,

156
00:06:26,110 --> 00:06:30,240
address one being the
command itself, and two

157
00:06:30,240 --> 00:06:33,140
and three being the 16 bit payload size,

158
00:06:33,140 --> 00:06:36,750
which I found to be
restricted only to 256 bytes.

159
00:06:36,750 --> 00:06:38,420
I also found that it apparently bits added

160
00:06:38,420 --> 00:06:41,573
on every command type at
the start of each update.

161
00:06:44,170 --> 00:06:45,620
Firmware update files can be found

162
00:06:45,620 --> 00:06:46,980
throughout the Android file system.

163
00:06:46,980 --> 00:06:48,860
I found these in the .rc confings,

164
00:06:48,860 --> 00:06:51,490
but they were found
separately in other areas.

165
00:06:51,490 --> 00:06:53,680
And I found this to be due to the fact

166
00:06:53,680 --> 00:06:56,060
that sometimes phones want
to update the firmware due

167
00:06:56,060 --> 00:06:58,933
to software updates that occur
just generally on phones.

168
00:07:00,140 --> 00:07:02,010
I looked through the firmware
file itself and found

169
00:07:02,010 --> 00:07:03,730
that it used metadata highlighted in red,

170
00:07:03,730 --> 00:07:05,700
which was just the date
as well as some other

171
00:07:05,700 --> 00:07:08,270
CRCs and relevant information.

172
00:07:08,270 --> 00:07:10,780
I then found the signature,
which is highlighted in green,

173
00:07:10,780 --> 00:07:12,770
which was just the cryptographic signature

174
00:07:12,770 --> 00:07:13,990
for the firmware.

175
00:07:13,990 --> 00:07:16,300
And then in blue was the
start of the firmware itself.

176
00:07:16,300 --> 00:07:18,250
So very easy to assess how this worked.

177
00:07:20,170 --> 00:07:21,770
I didn't originally know
that this was going to be

178
00:07:21,770 --> 00:07:24,000
an ARM chip, so I decided to
find out what the architecture

179
00:07:24,000 --> 00:07:25,330
was for myself.

180
00:07:25,330 --> 00:07:28,960
Looking through the firmware I found

181
00:07:28,960 --> 00:07:31,990
that it was quite obviously
going to be a Thumb firmware.

182
00:07:31,990 --> 00:07:34,460
By running the strings command
on the firmware itself,

183
00:07:34,460 --> 00:07:36,440
you can find that it has a large number

184
00:07:36,440 --> 00:07:41,140
of lower case B upper case
G outputted by strings.

185
00:07:41,140 --> 00:07:45,907
What this translates to is
hex 7047 which translates

186
00:07:46,900 --> 00:07:50,250
to Thumbs BXLR operation function link.

187
00:07:50,250 --> 00:07:52,190
A high number of these
generally means that it's gonna

188
00:07:52,190 --> 00:07:54,030
be using ARM-Thumb firm
or something similar

189
00:07:54,030 --> 00:07:55,560
to a Cortex-M chip.

190
00:07:55,560 --> 00:07:57,370
This has some interesting features,

191
00:07:57,370 --> 00:08:02,210
such the fact that in the chipset,

192
00:08:02,210 --> 00:08:05,140
as it's processing, the PC
register will always have

193
00:08:05,140 --> 00:08:07,070
the lowest bit set to differentiate

194
00:08:07,070 --> 00:08:08,473
between Thumb and ARM code.

195
00:08:10,120 --> 00:08:11,500
To implement the firmware updates,

196
00:08:11,500 --> 00:08:13,830
all I needed to do was
copy and paste all of them

197
00:08:13,830 --> 00:08:15,980
from the trace log and
follow them in sequence

198
00:08:15,980 --> 00:08:18,690
while reading at the
appropriate times as well.

199
00:08:18,690 --> 00:08:22,680
By setting up the IO controls to set

200
00:08:22,680 --> 00:08:25,400
it into bootloader mode, rather
than standard power mode,

201
00:08:25,400 --> 00:08:28,960
I can deploy these
firmware updates as needed.

202
00:08:28,960 --> 00:08:30,860
Header files from the
open source kernel drivers

203
00:08:30,860 --> 00:08:33,300
for this chipset were
very helpful for this.

204
00:08:33,300 --> 00:08:38,300
I used the sec_nfc.h file to perform this,

205
00:08:38,860 --> 00:08:41,410
and then I could just certainly
appropriate configurations

206
00:08:41,410 --> 00:08:42,963
via controls using this.

207
00:08:44,390 --> 00:08:47,080
I found that there was
a very specific sequence

208
00:08:47,080 --> 00:08:48,690
that was used for firmware
updates every time

209
00:08:48,690 --> 00:08:50,200
using specific commands.

210
00:08:50,200 --> 00:08:51,840
It was command zero for reset,

211
00:08:51,840 --> 00:08:53,900
command one for boot information,

212
00:08:53,900 --> 00:08:55,450
command on two for beginning of updates,

213
00:08:55,450 --> 00:08:59,860
command four for updating
4,096 bytes of the firmware,

214
00:08:59,860 --> 00:09:01,490
and command five for completing update,

215
00:09:01,490 --> 00:09:04,773
which verified the SHA-1
hash of the firmware

216
00:09:04,773 --> 00:09:08,080
against the SHA-1 hash that was
sent at the start of updates

217
00:09:08,080 --> 00:09:09,670
in the begin update function,

218
00:09:09,670 --> 00:09:13,190
and which was compared to
the cryptographic signature.

219
00:09:13,190 --> 00:09:14,910
I noticed that there was a
number of commands missing

220
00:09:14,910 --> 00:09:16,900
from the sequence command three.

221
00:09:16,900 --> 00:09:18,320
And this meant that there
was very likely to be

222
00:09:18,320 --> 00:09:20,593
some hidden commands that
we didn't know about.

223
00:09:21,610 --> 00:09:24,260
Commands in this sequence
only work at certain times,

224
00:09:24,260 --> 00:09:28,440
so you can't start writing
firmware before setting up

225
00:09:28,440 --> 00:09:30,560
the signatures, et cetera.

226
00:09:30,560 --> 00:09:32,410
Due to this, I brute force my way

227
00:09:32,410 --> 00:09:33,820
through the entire firmware update presets

228
00:09:33,820 --> 00:09:36,390
while trying different commands
to see how they worked.

229
00:09:36,390 --> 00:09:38,010
I found that chips would return error two

230
00:09:38,010 --> 00:09:39,480
if the command was not valid or not valid

231
00:09:39,480 --> 00:09:42,230
at that stage of the update
process, and return nine

232
00:09:42,230 --> 00:09:44,030
if the payload was too small.

233
00:09:44,030 --> 00:09:46,580
Now, this would allow me
to find any valid commands

234
00:09:47,780 --> 00:09:50,280
at each point in this process.

235
00:09:50,280 --> 00:09:52,490
I found that hidden
bootloader command three was

236
00:09:52,490 --> 00:09:53,980
the same functionality as command four,

237
00:09:53,980 --> 00:09:56,750
except instead of sending 4,096 bytes,

238
00:09:56,750 --> 00:09:58,710
you would write 512 byte blocks.

239
00:09:58,710 --> 00:10:01,140
So there were no real
actionable weaknesses.

240
00:10:01,140 --> 00:10:03,440
However, I also found
that there was a hidden

241
00:10:03,440 --> 00:10:05,150
bootloader command six.

242
00:10:05,150 --> 00:10:07,120
I found that this took
eight bytes of parameters,

243
00:10:07,120 --> 00:10:08,740
two 32-bit payloads.

244
00:10:08,740 --> 00:10:10,151
And by setting some individual bits

245
00:10:10,151 --> 00:10:13,640
in these parameters and
sending it across to the chip,

246
00:10:13,640 --> 00:10:15,610
it would start dumping memory out to me.

247
00:10:15,610 --> 00:10:17,480
I found that this was because I was giving

248
00:10:17,480 --> 00:10:20,930
it an address in a size
during this process.

249
00:10:20,930 --> 00:10:22,510
This allows me to dump
the RAM of the chip,

250
00:10:22,510 --> 00:10:24,890
the firmware for the
chip, hardware registers,

251
00:10:24,890 --> 00:10:27,040
are more importantly
the secure bootloader.

252
00:10:28,260 --> 00:10:30,540
By stitching together the
responses from this command

253
00:10:30,540 --> 00:10:32,030
by increasing the addresses,

254
00:10:32,030 --> 00:10:35,420
I could make myself a binary
of that bootloader for me

255
00:10:35,420 --> 00:10:37,090
to reverse engineer later.

256
00:10:37,090 --> 00:10:38,680
This showed that it was using a standard

257
00:10:38,680 --> 00:10:42,220
Cortex-M firmware format
starting addresses zero

258
00:10:42,220 --> 00:10:43,900
which was the vector table.

259
00:10:43,900 --> 00:10:46,650
So started off with the
stack pointer followed

260
00:10:46,650 --> 00:10:48,470
by the reset of vector of the chip,

261
00:10:48,470 --> 00:10:49,620
so that's the code that would get jumped

262
00:10:49,620 --> 00:10:52,250
to at the start of the firmware startup,

263
00:10:52,250 --> 00:10:54,190
and found that the firmware
contained no strings.

264
00:10:54,190 --> 00:10:56,933
So all reverse engineering
would have to be done by hand.

265
00:10:58,250 --> 00:11:01,570
I loaded this into IDA as
an ARM little-endian binary

266
00:11:01,570 --> 00:11:04,040
as it should be, and set
the memory layout for zero

267
00:11:04,040 --> 00:11:08,720
flash memory, 20000000
RAM, 40000000, 50000000

268
00:11:08,720 --> 00:11:09,890
for hardware peripherals,

269
00:11:09,890 --> 00:11:13,083
and E0000000 for system addresses.

270
00:11:13,930 --> 00:11:17,553
This assembled very nicely
and very easily assessed.

271
00:11:18,720 --> 00:11:20,563
It had some interesting
artifacts such as the fact

272
00:11:20,563 --> 00:11:22,780
that I could now work out exactly

273
00:11:22,780 --> 00:11:26,080
how the firmware updates
were securely implemented

274
00:11:26,080 --> 00:11:28,200
and how these worked post-update.

275
00:11:28,200 --> 00:11:30,040
I found that on start-up
the bootloader checks

276
00:11:30,040 --> 00:11:32,430
for magic number at the
start of the firmware update,

277
00:11:32,430 --> 00:11:35,953
that's being 5AF00FA5,
which I did not find

278
00:11:35,953 --> 00:11:38,450
when I looked in the
firmware payload itself.

279
00:11:38,450 --> 00:11:40,293
This magic number was
written only after firmware

280
00:11:40,293 --> 00:11:42,780
updates has occurred, if
the signature was valid

281
00:11:42,780 --> 00:11:44,820
during that update,
meaning that every time

282
00:11:44,820 --> 00:11:45,653
the chip started up,

283
00:11:45,653 --> 00:11:47,930
it wouldn't have to verify this signature.

284
00:11:47,930 --> 00:11:49,700
I attempted to manually write this value

285
00:11:49,700 --> 00:11:52,000
into the firmware that
I deployed, however,

286
00:11:52,000 --> 00:11:53,750
this did not do anything effective.

287
00:11:54,800 --> 00:11:56,660
I also found the state machine

288
00:11:56,660 --> 00:11:58,650
which handled the commands I was sending.

289
00:11:58,650 --> 00:12:01,090
So you see comparisons to
zero, one, two and six,

290
00:12:01,090 --> 00:12:03,070
which were the commands
that were valid at the start

291
00:12:03,070 --> 00:12:04,950
of a firmware update process.

292
00:12:04,950 --> 00:12:07,990
I also found the RSA public
key, which was in use

293
00:12:07,990 --> 00:12:11,750
for this chipset, which was
made up of 128 high entropy

294
00:12:11,750 --> 00:12:16,750
bytes followed by 00010001
which translates to 65537,

295
00:12:17,670 --> 00:12:19,873
the exponent of a public key.

296
00:12:21,560 --> 00:12:23,980
Because I only had one phone
and I didn't want to break it,

297
00:12:23,980 --> 00:12:26,530
I didn't want to fuzz it
directly in the hardware.

298
00:12:26,530 --> 00:12:29,210
I wanted to on an emulator chipset.

299
00:12:29,210 --> 00:12:32,640
So what I did was use
this dumped bootloader

300
00:12:32,640 --> 00:12:35,210
and looked into ways that I
could emulate it effectively

301
00:12:35,210 --> 00:12:36,283
on a host computer.

302
00:12:37,860 --> 00:12:40,030
I ended up using the Unicorn
Engine for this process,

303
00:12:40,030 --> 00:12:42,420
which the library for
emulating architectures

304
00:12:42,420 --> 00:12:45,810
and hooking all functionality
of a firmware as needed

305
00:12:45,810 --> 00:12:47,890
in order to emulate certain aspects of it.

306
00:12:47,890 --> 00:12:49,240
You can define the architecture,

307
00:12:49,240 --> 00:12:51,720
memory mapping and hardware
integration as needed

308
00:12:51,720 --> 00:12:53,053
to fit your own needs.

309
00:12:55,230 --> 00:12:59,000
The bootloader I was found
was loaded into address zero

310
00:12:59,000 --> 00:13:00,760
which was the start of the flash memory

311
00:13:00,760 --> 00:13:01,870
in the chip itself.

312
00:13:01,870 --> 00:13:03,930
And the program counter to
a set to the reset factor

313
00:13:03,930 --> 00:13:06,560
that I found in that bootloader 2BD.

314
00:13:06,560 --> 00:13:08,240
Memory was then mapped to flash, RAM,

315
00:13:08,240 --> 00:13:09,400
and hardware registers as needed

316
00:13:09,400 --> 00:13:11,733
so that it would perform
as a chip as needed.

317
00:13:13,040 --> 00:13:15,080
Commands were found to just be received

318
00:13:15,080 --> 00:13:17,330
in a single thread that
started from the main loop

319
00:13:17,330 --> 00:13:19,600
and just loop around
receiving I2C commands.

320
00:13:19,600 --> 00:13:21,430
Because this meant that
there was probably not gonna

321
00:13:21,430 --> 00:13:23,000
be an interrupts in use,

322
00:13:23,000 --> 00:13:25,320
just use the size of the
bootloader and its content,

323
00:13:25,320 --> 00:13:27,310
it would mean that emulation
would be a simpler task

324
00:13:27,310 --> 00:13:30,363
and all I'd need to do is
straight up emulate what I had.

325
00:13:31,550 --> 00:13:34,770
I found that execution
was causing device reset

326
00:13:34,770 --> 00:13:36,420
during the startup process
of this chip however,

327
00:13:36,420 --> 00:13:38,100
because it was trying to access

328
00:13:38,100 --> 00:13:40,410
hardware registers which
simply didn't exist

329
00:13:40,410 --> 00:13:43,030
because they weren't being emulated.

330
00:13:43,030 --> 00:13:45,760
What I did was patch the
bootloader image to bypass

331
00:13:45,760 --> 00:13:48,190
all this hardware
initialization so that the chip

332
00:13:48,190 --> 00:13:49,910
could then move to the
next part of the process,

333
00:13:49,910 --> 00:13:51,670
but wouldn't need to actually
to set up the hardware

334
00:13:51,670 --> 00:13:52,920
in any meaningful manner.

335
00:13:56,270 --> 00:13:58,200
The firmware was allowed
to run and continue

336
00:13:58,200 --> 00:13:59,560
until it hit another hardware address.

337
00:13:59,560 --> 00:14:02,920
So all hardware addresses
started either 4000 or 5000

338
00:14:05,000 --> 00:14:08,993
the address that it hit was 40022030.

339
00:14:10,710 --> 00:14:13,910
And I showed that, I analyzed the assembly

340
00:14:13,910 --> 00:14:15,750
at the point where this
has been read and found

341
00:14:15,750 --> 00:14:18,460
that the firmware was
checking for specific bits

342
00:14:18,460 --> 00:14:20,060
in this address.

343
00:14:20,060 --> 00:14:21,770
By making it return random data,

344
00:14:21,770 --> 00:14:24,170
I found that it was just
checking for status bits

345
00:14:24,170 --> 00:14:25,433
via that register and
allowed me to work out

346
00:14:25,433 --> 00:14:28,130
that it was an I2C interface that was

347
00:14:28,130 --> 00:14:29,363
being communicated with.

348
00:14:30,290 --> 00:14:31,123
Because I implemented this,

349
00:14:31,123 --> 00:14:34,070
it would move on to the
next stage of the process.

350
00:14:34,070 --> 00:14:36,970
Next I made the firmware
continually read bytes

351
00:14:36,970 --> 00:14:40,560
from a single address 40022038.

352
00:14:40,560 --> 00:14:43,300
This implied that it was probably reading

353
00:14:43,300 --> 00:14:46,380
from I2C as well, but the
first in first out buffer.

354
00:14:46,380 --> 00:14:47,930
What I did was start
sending bytes that I would

355
00:14:47,930 --> 00:14:49,180
usually send for firmware updates

356
00:14:49,180 --> 00:14:52,370
via this interface in Unicorn
and to see what happened.

357
00:14:52,370 --> 00:14:55,750
I then found that the chip
started writing out responses

358
00:14:55,750 --> 00:14:59,450
on 40022034, so the
address right next to it.

359
00:14:59,450 --> 00:15:01,710
These responses meant
that I had full emulation

360
00:15:01,710 --> 00:15:03,470
of the I2C communication
without ever having

361
00:15:03,470 --> 00:15:04,463
to touch my chip.

362
00:15:06,240 --> 00:15:08,150
What I wanted to do is find
a memory correction exploit,

363
00:15:08,150 --> 00:15:10,310
so I could bypass the signature checking.

364
00:15:10,310 --> 00:15:13,200
And while I did start doing
some randomized fuzzing

365
00:15:13,200 --> 00:15:14,060
I thought would be viable,

366
00:15:14,060 --> 00:15:16,540
it didn't really come out
with anything interesting.

367
00:15:16,540 --> 00:15:18,360
The commands were found
to have 16-bit sizes,

368
00:15:18,360 --> 00:15:19,860
which were larger than the entire contents

369
00:15:19,860 --> 00:15:22,234
of RAM, which was found
to be only eight K.

370
00:15:22,234 --> 00:15:25,370
However, these were
limited to only 256 bytes.

371
00:15:25,370 --> 00:15:27,180
I did, however, notice
that some functions,

372
00:15:27,180 --> 00:15:29,600
especially ones for
deploying a large box of data

373
00:15:29,600 --> 00:15:32,790
could send data in chunks
like 256 byte chunks.

374
00:15:32,790 --> 00:15:35,430
I also found that the size
of the hash and signature

375
00:15:35,430 --> 00:15:38,290
were defined at the start of
the firmware update process,

376
00:15:38,290 --> 00:15:40,540
right before the hash
and signature was sent.

377
00:15:41,990 --> 00:15:43,700
I found that I could
increase the size of both

378
00:15:43,700 --> 00:15:45,340
the hashes and the signature size

379
00:15:45,340 --> 00:15:46,840
in order to send more data.

380
00:15:46,840 --> 00:15:48,730
And while this would
respond saying that hashes

381
00:15:48,730 --> 00:15:50,220
and signatures weren't valid,

382
00:15:50,220 --> 00:15:52,950
it did allow me to
increase the size and send

383
00:15:52,950 --> 00:15:54,890
increasing amounts of data.

384
00:15:54,890 --> 00:15:56,120
When I did this in my my emulator,

385
00:15:56,120 --> 00:15:58,228
I found that eventually this
made my memory go out of bounds

386
00:15:58,228 --> 00:15:59,463
so outside the eight K of memory

387
00:15:59,463 --> 00:16:02,740
that I had allocated to
my emulated firmware.

388
00:16:02,740 --> 00:16:04,630
Looking into this, I found
that it also overwritten

389
00:16:04,630 --> 00:16:07,053
the stack with the memory
that I had sent to it.

390
00:16:08,980 --> 00:16:10,523
Because I can now
overwrite the stack, I can

391
00:16:10,523 --> 00:16:13,100
manipulate the program
counter and start doing some

392
00:16:13,100 --> 00:16:14,670
more memory corruption exploits.

393
00:16:14,670 --> 00:16:18,160
However, SC000 chipsets,
because they're meant to be

394
00:16:18,160 --> 00:16:20,690
for secure applications,

395
00:16:20,690 --> 00:16:22,633
don't let you ever execute from RAM like

396
00:16:22,633 --> 00:16:24,890
a traditional Cortex-M chip would.

397
00:16:24,890 --> 00:16:26,910
And because the stack was
very small at this point,

398
00:16:26,910 --> 00:16:29,880
only about 12 bytes when I checked,

399
00:16:29,880 --> 00:16:31,300
I wouldn't be able to
do anything too complex

400
00:16:31,300 --> 00:16:32,273
with ROP either.

401
00:16:33,690 --> 00:16:36,020
What I ended up doing was
making the program counter

402
00:16:36,020 --> 00:16:37,550
to just dump directly back into the start

403
00:16:37,550 --> 00:16:41,160
of the bootloader, past the
check for the magic number,

404
00:16:41,160 --> 00:16:43,760
and into the part where it
initializes the firmware.

405
00:16:43,760 --> 00:16:45,380
And this allowed me to bypass all

406
00:16:45,380 --> 00:16:48,287
of the signature checking
and deploy my own firmware.

407
00:16:49,350 --> 00:16:52,630
I then ran this exploit on
my physical chip instead

408
00:16:52,630 --> 00:16:54,710
of the emulated version
and found that what would

409
00:16:54,710 --> 00:16:57,090
happen is I'd start at my
bootloader, send this exploit

410
00:16:57,090 --> 00:17:00,190
and that directly boot
into the main firmware.

411
00:17:00,190 --> 00:17:02,150
I could then send NCI
commands and receive them

412
00:17:02,150 --> 00:17:04,900
as needed with my custom firmware.

413
00:17:04,900 --> 00:17:06,410
What I did was first
change the version number

414
00:17:06,410 --> 00:17:09,280
of the chip so that it was different here.

415
00:17:09,280 --> 00:17:12,550
Here, AA, BB, CC and DD, and
meant that custom firmware

416
00:17:12,550 --> 00:17:15,010
had been sent and validly was running.

417
00:17:15,010 --> 00:17:17,360
I then disclosed this
vulnerability to Samsung.

418
00:17:18,490 --> 00:17:20,530
There are two ways they
could have remediated this.

419
00:17:20,530 --> 00:17:23,020
Firstly, they could have
patched the bootloader

420
00:17:23,020 --> 00:17:25,270
from the main firmware,
removing the buffer overflow.

421
00:17:25,270 --> 00:17:27,370
Now, while this does seems simple,

422
00:17:27,370 --> 00:17:29,430
it would be very difficult
because what would

423
00:17:29,430 --> 00:17:30,840
have to happen is the
bootloader would have had

424
00:17:30,840 --> 00:17:34,270
to start the main firmware
and then let the main firmware

425
00:17:34,270 --> 00:17:35,420
patch the bootloader.

426
00:17:35,420 --> 00:17:37,350
Now, if there is any kind
of power cycling going on,

427
00:17:37,350 --> 00:17:40,200
or any sort of deployment
outage during this process,

428
00:17:40,200 --> 00:17:42,330
the bootloader would be
erased and the chip would

429
00:17:42,330 --> 00:17:45,580
be essentially bricked and
never able to work again.

430
00:17:45,580 --> 00:17:47,960
One could also patch
the kernel to disallow

431
00:17:47,960 --> 00:17:49,010
the commands that were being sent,

432
00:17:49,010 --> 00:17:51,140
so the large hash sizes,
and make them static.

433
00:17:51,140 --> 00:17:52,670
However this would be trivially bypassed

434
00:17:52,670 --> 00:17:54,120
just by modifying the kernel.

435
00:17:55,850 --> 00:17:57,570
I looked into other NFC chips

436
00:17:57,570 --> 00:18:00,205
that Samsung Semiconductor
developed and found

437
00:18:00,205 --> 00:18:01,690
that there were four main
ones that were advertised

438
00:18:01,690 --> 00:18:04,063
on their websites, the S3NRN74, S3NRN81,

439
00:18:06,054 --> 00:18:07,471
S3NRN82, SEN82AB.

440
00:18:08,980 --> 00:18:10,300
The most interesting of these to me was

441
00:18:10,300 --> 00:18:13,070
the S3NRN82 as it seemed
like their latest version

442
00:18:13,070 --> 00:18:13,903
at the time.

443
00:18:15,600 --> 00:18:17,270
I decided to go through the ROMs

444
00:18:17,270 --> 00:18:18,510
of lots of Samsung phones.

445
00:18:18,510 --> 00:18:21,250
Now, because this was not a US phone,

446
00:18:21,250 --> 00:18:22,870
there were not very many tear downs online

447
00:18:22,870 --> 00:18:26,600
for the phone and definitions
of what hardware was in use.

448
00:18:26,600 --> 00:18:28,010
So what I ended up doing was going

449
00:18:28,010 --> 00:18:30,360
to Sammobile.com, which has a huge number

450
00:18:30,360 --> 00:18:32,868
of custom Android ROMs,
dumped as many as I could

451
00:18:32,868 --> 00:18:36,310
and extracted them to see
what firmware files are

452
00:18:36,310 --> 00:18:38,260
in the /vendor partition.

453
00:18:38,260 --> 00:18:41,640
Occasionally these
partitions are not stored

454
00:18:41,640 --> 00:18:44,330
in these because they
are part of a special

455
00:18:44,330 --> 00:18:46,400
vendor partition, which
is deployed to the phone

456
00:18:46,400 --> 00:18:48,180
and can only be extracted from a phone,

457
00:18:48,180 --> 00:18:49,160
but it did give some insight

458
00:18:49,160 --> 00:18:51,233
in that to what chipsets were being used.

459
00:18:52,990 --> 00:18:54,720
While the vendor directory
does always contain

460
00:18:54,720 --> 00:18:55,553
these firmware files,

461
00:18:55,553 --> 00:18:56,880
this separate partition does make things

462
00:18:56,880 --> 00:18:57,930
a bit more difficult.

463
00:18:59,070 --> 00:19:02,720
I found that the S3NRN82
was the latest chipset

464
00:19:02,720 --> 00:19:04,410
after looking through this and found

465
00:19:04,410 --> 00:19:05,880
that there were multiple
chip versions available

466
00:19:05,880 --> 00:19:09,140
in different versions of the the firmwares

467
00:19:09,140 --> 00:19:10,350
that I was downloading.

468
00:19:10,350 --> 00:19:11,410
And I decided to go

469
00:19:11,410 --> 00:19:14,020
with the Samsung S9 which used this chip.

470
00:19:14,020 --> 00:19:15,210
It was also found to be available

471
00:19:15,210 --> 00:19:18,450
in the Samsung Galaxy S8
and and S10, but I purchased

472
00:19:18,450 --> 00:19:21,750
the Samsung S9, rooted
it using OEM unlocking

473
00:19:21,750 --> 00:19:24,650
and a custom ROM, I started
looking through how it worked.

474
00:19:25,960 --> 00:19:28,060
I found this firmware file
to be in the same format

475
00:19:28,060 --> 00:19:32,140
as the S3FWRN5, except the
initial stack pointer was

476
00:19:32,140 --> 00:19:34,920
much larger and moving up
to 12K over the eight K

477
00:19:34,920 --> 00:19:37,330
that the last chip had, and
the reset of factor was lower,

478
00:19:37,330 --> 00:19:39,460
so implying a much smaller bootloader.

479
00:19:39,460 --> 00:19:42,733
I also found that the firmware
size was 32 kilobytes larger.

480
00:19:44,460 --> 00:19:47,450
Looking through my previous
exploit and trying to port

481
00:19:47,450 --> 00:19:50,020
it over I found that commands
three and six were removed.

482
00:19:50,020 --> 00:19:50,853
Meaning meaning they've
made some changes there,

483
00:19:50,853 --> 00:19:54,350
and meant I could no longer
read out firmware as needed.

484
00:19:54,350 --> 00:19:56,690
I also found a new command
seven, which was identified,

485
00:19:56,690 --> 00:19:59,010
just reboot the chip and nothing else.

486
00:19:59,010 --> 00:20:00,420
The new bootloader size
implies that something else

487
00:20:00,420 --> 00:20:03,140
had been changed in here just
because it was much smaller.

488
00:20:03,140 --> 00:20:04,600
However, the lack of memory readout meant

489
00:20:04,600 --> 00:20:07,133
that I wouldn't be able to
exploit this and any exploitation

490
00:20:07,133 --> 00:20:09,330
I did do would have to be done blind.

491
00:20:09,330 --> 00:20:12,190
I also found that signature
checks now no longer

492
00:20:12,190 --> 00:20:13,870
use SHA-1 hashes as before,

493
00:20:13,870 --> 00:20:16,020
and I had to work out
what they were using.

494
00:20:17,320 --> 00:20:21,450
Because they had modified
their kernel to no longer

495
00:20:21,450 --> 00:20:25,140
dump out data via Logcat,
I wouldn't be able to use

496
00:20:25,140 --> 00:20:26,690
the same login procedures I did

497
00:20:26,690 --> 00:20:28,410
before to assess the protocol.

498
00:20:28,410 --> 00:20:29,243
What I found, however,

499
00:20:29,243 --> 00:20:31,200
was that then the sizes of commands sent

500
00:20:31,200 --> 00:20:35,340
during firmware update processes
were stored in /proc/nfclog

501
00:20:35,340 --> 00:20:36,830
in the file system.

502
00:20:36,830 --> 00:20:38,300
Looking through these,
I could see the commands

503
00:20:38,300 --> 00:20:41,190
working in sequence, find
a start of firmware updates

504
00:20:41,190 --> 00:20:42,510
and then deploy them.

505
00:20:42,510 --> 00:20:44,550
And I found that what
was happening was during

506
00:20:44,550 --> 00:20:45,500
the start of firmer updates,

507
00:20:45,500 --> 00:20:47,860
when it was giving this a hash,

508
00:20:47,860 --> 00:20:51,260
it was providing a 32 bytes
plus four bytes implying

509
00:20:51,260 --> 00:20:55,010
that it moved from show on
SHA-1 hash to SHA-256 hash.

510
00:20:55,010 --> 00:20:58,010
I modified my firmware
update tool to reflect this,

511
00:20:58,010 --> 00:21:00,903
and I can now upload valid
firmware to the chip.

512
00:21:03,270 --> 00:21:06,640
I wanted to see if I can
replicate the same buffer flow

513
00:21:06,640 --> 00:21:07,710
I had before.

514
00:21:07,710 --> 00:21:10,490
Now, I need to work out
how big the stack was

515
00:21:10,490 --> 00:21:12,320
before doing so to make
sure that I'd overwritten

516
00:21:12,320 --> 00:21:13,483
the entirety of it.

517
00:21:13,483 --> 00:21:15,530
What I ended up doing
was sending increasingly

518
00:21:15,530 --> 00:21:18,230
sized payloads to the chipset.

519
00:21:18,230 --> 00:21:20,810
Now, I found that when I
sent these payloads to it,

520
00:21:20,810 --> 00:21:22,600
if I was just overflowing the stack,

521
00:21:22,600 --> 00:21:24,270
it was still return and
return data to me just due

522
00:21:24,270 --> 00:21:27,070
to the nature of how the
stack was being set up.

523
00:21:27,070 --> 00:21:29,590
However, if the device
crashed before sending

524
00:21:29,590 --> 00:21:30,423
a response to me,

525
00:21:30,423 --> 00:21:32,630
it was likely that I'd
overwritten into invalid

526
00:21:32,630 --> 00:21:34,653
memory outside of the 12K of RAM.

527
00:21:36,350 --> 00:21:38,930
What I ended up doing for
to find out where I could

528
00:21:38,930 --> 00:21:42,790
find an entry point was
starting my program counter

529
00:21:42,790 --> 00:21:44,890
at 01 and filling a stack with this.

530
00:21:44,890 --> 00:21:48,730
So it's filling the stack
with address 01 and seeing

531
00:21:48,730 --> 00:21:52,880
what would happen if the return pointers,

532
00:21:52,880 --> 00:21:54,300
which were somewhere in the stack,

533
00:21:54,300 --> 00:21:56,600
I didn't know yet, jumps there.

534
00:21:56,600 --> 00:21:59,830
I then sent NCI initialization
commands as you would

535
00:21:59,830 --> 00:22:02,790
at the start of the NFC setup.

536
00:22:02,790 --> 00:22:04,680
And if I receive NFC response,

537
00:22:04,680 --> 00:22:06,440
and then I'd found a valid end point

538
00:22:06,440 --> 00:22:08,150
into the core firmware and bypassing

539
00:22:08,150 --> 00:22:09,640
the signature checking.

540
00:22:09,640 --> 00:22:10,740
If it failed, however,

541
00:22:10,740 --> 00:22:14,280
I restarted the chip and
increase the address by two.

542
00:22:14,280 --> 00:22:15,920
I found a signature bypass succeeded

543
00:22:15,920 --> 00:22:18,633
at address 165 as follows.

544
00:22:20,220 --> 00:22:23,800
So I would send my
exploit, and if it failed,

545
00:22:23,800 --> 00:22:27,260
start it again, and if
it fails, start it again,

546
00:22:27,260 --> 00:22:28,823
and then in the next one,

547
00:22:30,150 --> 00:22:32,630
I found that I could receive data via NCI.

548
00:22:32,630 --> 00:22:34,610
It means that the entry
point had been found

549
00:22:34,610 --> 00:22:38,680
at address 165, which
worked repeatedly and didn't

550
00:22:38,680 --> 00:22:39,793
have any problems.

551
00:22:40,900 --> 00:22:42,610
I then disclosed this vulnerability

552
00:22:42,610 --> 00:22:45,760
to Samsung, I provide them
an exploit and showed them

553
00:22:45,760 --> 00:22:47,040
how it was done.

554
00:22:47,040 --> 00:22:50,270
And they agreed to patch
all newly-manufactured

555
00:22:50,270 --> 00:22:54,900
chipsets that's from April,
2020, as well as patch any

556
00:22:54,900 --> 00:22:56,860
new chipsets that they
were going to develop.

557
00:22:56,860 --> 00:22:59,310
However, because they
couldn't patch the bootloaders

558
00:22:59,310 --> 00:23:00,990
of older chipsets, like
the ones I had in my phone,

559
00:23:00,990 --> 00:23:02,890
custom firmware would still be viable.

560
00:23:04,700 --> 00:23:07,420
In order to patch existing firmware,

561
00:23:07,420 --> 00:23:09,960
one needs to basically modify
what they have in there.

562
00:23:09,960 --> 00:23:12,740
They need to add their own
code into what already exists.

563
00:23:12,740 --> 00:23:15,710
I decided to stick with
S3NRN82 rather than S3FWRN5

564
00:23:15,710 --> 00:23:17,900
'cause it was the latest chipset,

565
00:23:17,900 --> 00:23:19,820
and it would have the most power.

566
00:23:19,820 --> 00:23:22,100
The only method I could find
accessing data for debugging,

567
00:23:22,100 --> 00:23:23,260
this however was I2C.

568
00:23:23,260 --> 00:23:25,620
So I would have to debug
this via the same methods

569
00:23:25,620 --> 00:23:27,563
that I was writing data, et cetera.

570
00:23:29,690 --> 00:23:32,457
What I did was go back to
my dump of ROMs that I had

571
00:23:32,457 --> 00:23:36,610
and go to a Galaxy S8
ROM and find the oldest

572
00:23:36,610 --> 00:23:38,310
available firmware I could.

573
00:23:38,310 --> 00:23:40,510
What I'd found was that
I had a huge number

574
00:23:40,510 --> 00:23:42,440
of FFs in the firmware files.

575
00:23:42,440 --> 00:23:44,100
Now, the firmware files
were always the size

576
00:23:44,100 --> 00:23:45,360
of the available flash memory.

577
00:23:45,360 --> 00:23:49,550
Meaning FFFF is the areas
where no code or no data

578
00:23:49,550 --> 00:23:51,330
has been deployed to the firmware.

579
00:23:51,330 --> 00:23:53,120
I could stick my own code
in there and then jump

580
00:23:53,120 --> 00:23:53,953
to it as needed.

581
00:23:55,420 --> 00:23:58,210
C functions could easily
be compiled as needed

582
00:23:58,210 --> 00:24:01,430
and dumped into there
just by using gcc -c.

583
00:24:01,430 --> 00:24:04,263
When you do use that -C
you're compiling code

584
00:24:04,263 --> 00:24:07,560
without linking or relocating
or checking a thing

585
00:24:07,560 --> 00:24:09,820
so you can get object files and binaries,

586
00:24:09,820 --> 00:24:11,628
which can be dumped in and jumped to

587
00:24:11,628 --> 00:24:13,680
as if there were specific functions,

588
00:24:13,680 --> 00:24:15,610
but you wouldn't be able
to use things like standard

589
00:24:15,610 --> 00:24:20,390
C libraries or any
complex heap, et cetera.

590
00:24:20,390 --> 00:24:21,550
I also found that however,

591
00:24:21,550 --> 00:24:23,840
that stack handling was
performed just by virtue

592
00:24:23,840 --> 00:24:25,023
of how ARM works.

593
00:24:26,550 --> 00:24:29,880
Now, C function calls
are generated as a branch

594
00:24:29,880 --> 00:24:30,713
and link instructions.

595
00:24:30,713 --> 00:24:32,940
These are instructions
which jump relatively

596
00:24:32,940 --> 00:24:36,140
to the current program counter into code.

597
00:24:36,140 --> 00:24:37,600
And just by jumping to the code I had,

598
00:24:37,600 --> 00:24:41,520
which returned back to the
link register after branch

599
00:24:41,520 --> 00:24:44,223
and links meant all my
code would run as needed.

600
00:24:45,470 --> 00:24:46,360
Branch and links are made up

601
00:24:46,360 --> 00:24:48,220
of two's compliment relative addresses.

602
00:24:48,220 --> 00:24:49,840
So I'm addresses that can be

603
00:24:49,840 --> 00:24:52,240
below or above the
current program counter,

604
00:24:52,240 --> 00:24:54,913
and directly patching these
other branch and links

605
00:24:54,913 --> 00:24:55,773
that were already in the firmware.

606
00:24:55,773 --> 00:24:58,460
I mean, I could jump to my own custom code

607
00:24:58,460 --> 00:25:00,580
without causing any trouble in the rest

608
00:25:00,580 --> 00:25:02,880
of the firmware and
changing what I needed to.

609
00:25:03,900 --> 00:25:05,270
I made a small build application,

610
00:25:05,270 --> 00:25:07,590
which compiled all my
custom firmware code,

611
00:25:07,590 --> 00:25:12,440
and also did all the
relocation and integration

612
00:25:12,440 --> 00:25:14,760
of nonstandard functions
for me so that this would

613
00:25:14,760 --> 00:25:16,560
all get built so I could call functions

614
00:25:16,560 --> 00:25:19,750
from different areas and also
patch over branch and links.

615
00:25:19,750 --> 00:25:21,650
I also created a firmware
update tool that was

616
00:25:21,650 --> 00:25:23,103
deployed this code for me.

617
00:25:24,940 --> 00:25:29,223
My initial project was that
I wanted to read out memory

618
00:25:29,223 --> 00:25:31,570
in the same way I had in the Samsung 6S.

619
00:25:31,570 --> 00:25:32,403
In order to do this,

620
00:25:32,403 --> 00:25:35,370
I decided to patch the
NCI command 2F24 which is

621
00:25:35,370 --> 00:25:36,610
a vendor-specific command,

622
00:25:36,610 --> 00:25:39,370
which I didn't find the purpose for ever.

623
00:25:39,370 --> 00:25:41,690
I could send repeated data
to this with the larger

624
00:25:41,690 --> 00:25:44,180
and smaller payload sizes
and it would just take

625
00:25:44,180 --> 00:25:45,470
them as needed.

626
00:25:45,470 --> 00:25:49,443
I searched for MOV .#0x24, which is regex

627
00:25:49,443 --> 00:25:51,960
just for searching quickly
for certain instructions

628
00:25:51,960 --> 00:25:54,240
in IDA and found a function called

629
00:25:54,240 --> 00:25:56,820
which that response had
it using this value.

630
00:25:56,820 --> 00:25:59,480
I then looked through and
assessed that this was indeed

631
00:25:59,480 --> 00:26:02,290
the function that handled this NCI core.

632
00:26:02,290 --> 00:26:05,600
And I overwrote sub_11A76
which was the last

633
00:26:05,600 --> 00:26:09,660
function call before it
sent data back via I2C.

634
00:26:09,660 --> 00:26:11,260
I could then modify any
links that had already

635
00:26:11,260 --> 00:26:12,960
been modified as needed.

636
00:26:12,960 --> 00:26:14,630
I did find however that
the writing firmware took

637
00:26:14,630 --> 00:26:17,530
around 20 seconds, which was
a lot longer than I expected.

638
00:26:20,450 --> 00:26:21,860
To receive parameters, however,

639
00:26:21,860 --> 00:26:26,110
I didn't know where in
RAM these were located.

640
00:26:26,110 --> 00:26:28,340
So what I had to do was
find where they were located

641
00:26:28,340 --> 00:26:29,790
in RAM as my first port of call.

642
00:26:29,790 --> 00:26:31,200
This way, I'd be able to receive commands

643
00:26:31,200 --> 00:26:33,260
as well as send them back,

644
00:26:33,260 --> 00:26:35,040
and responses based on what I had sent.

645
00:26:35,040 --> 00:26:36,870
So if I want to send an
address to read the data back,

646
00:26:36,870 --> 00:26:38,220
this is why I would use.

647
00:26:38,220 --> 00:26:42,080
I crafted an NCI request 2F 24 04

648
00:26:42,080 --> 00:26:45,650
FA CE FA CE which was
just a placeholder value

649
00:26:45,650 --> 00:26:47,710
that would easily be spotted in RAM.

650
00:26:47,710 --> 00:26:49,730
And then I searched
through the entirety RAM

651
00:26:49,730 --> 00:26:53,620
via this I2C call, and set
the response payload via

652
00:26:53,620 --> 00:26:55,713
I2C to be the address it was found.

653
00:26:55,713 --> 00:26:58,490
Then allowed me to find
where this data was stored

654
00:26:58,490 --> 00:27:01,163
in memory and read out
parameters as needed.

655
00:27:02,720 --> 00:27:03,750
Because I could do this,

656
00:27:03,750 --> 00:27:06,580
I could now dump the S3NRN82 bootloader,

657
00:27:06,580 --> 00:27:08,720
which was extremely
helpful for me modifying

658
00:27:08,720 --> 00:27:10,940
my exploit to make it
just a bit more stringent.

659
00:27:10,940 --> 00:27:14,200
I didn't have any problems,
redeploying it several times,

660
00:27:14,200 --> 00:27:16,110
and the exploit worked every time,

661
00:27:16,110 --> 00:27:18,010
however if you'll see what was happening

662
00:27:18,010 --> 00:27:22,420
when I returned in the staff to 165,

663
00:27:22,420 --> 00:27:25,540
was that it was loading from R0 into R0,

664
00:27:25,540 --> 00:27:27,450
meaning that it was loading
for an address I had

665
00:27:27,450 --> 00:27:29,660
no control over, which was slightly scary.

666
00:27:29,660 --> 00:27:31,600
What did was move it to
exactly the same place

667
00:27:31,600 --> 00:27:33,460
as I moved it into the boot loader

668
00:27:33,460 --> 00:27:38,400
of the SFWRN5, that being
the address which loads

669
00:27:38,400 --> 00:27:40,950
the address of the
firmware we're jumping to,

670
00:27:40,950 --> 00:27:42,943
and then jumps into that firmware.

671
00:27:44,420 --> 00:27:46,740
Now I added some custom functionality,

672
00:27:46,740 --> 00:27:49,603
I wanted to try it something
a bit more NSP specific.

673
00:27:50,490 --> 00:27:53,270
When I looked into the
capabilities of the chip,

674
00:27:53,270 --> 00:27:55,830
I found that it supported ISO14443a,

675
00:27:55,830 --> 00:27:57,970
this being things like
MIFARE Classic tags,

676
00:27:57,970 --> 00:28:00,350
MIFARE Ultralight and
most things you'll see.

677
00:28:00,350 --> 00:28:03,040
ISO14443b which is a bit less common,

678
00:28:03,040 --> 00:28:04,620
and several other protocols,

679
00:28:04,620 --> 00:28:08,620
all of which were of the
13.56 megahertz spectrum.

680
00:28:08,620 --> 00:28:12,920
And didn't cover anything in
the 125 kilohertz spectrum.

681
00:28:12,920 --> 00:28:16,040
I found that while I had
access to some information

682
00:28:16,040 --> 00:28:17,850
regarding the I2C interface,

683
00:28:17,850 --> 00:28:20,300
I didn't have any access
to information regarding

684
00:28:20,300 --> 00:28:22,300
things like how NFC works on the chip.

685
00:28:22,300 --> 00:28:24,243
And because this was a
completely custom chip,

686
00:28:24,243 --> 00:28:26,640
I would have to do a deep
dive into how this works

687
00:28:26,640 --> 00:28:29,400
in order to assess all
of its functionality.

688
00:28:29,400 --> 00:28:32,000
My initial goal was to
emulate in MIFARE Classic tag

689
00:28:32,000 --> 00:28:33,630
in its entirety on the S9.

690
00:28:33,630 --> 00:28:35,680
This is functionality that's
not traditionally found

691
00:28:35,680 --> 00:28:38,700
in phones because its
only use really would be

692
00:28:38,700 --> 00:28:41,260
for exploitation as
far as anyone can tell.

693
00:28:41,260 --> 00:28:43,250
What I did was use a
Proxmark for debugging

694
00:28:43,250 --> 00:28:47,020
to assess any responses sent
back from the chip via NFC

695
00:28:47,020 --> 00:28:49,490
so I could keep track of what's
going on from the NFC side

696
00:28:49,490 --> 00:28:51,057
while also debugging from I2C.

697
00:28:53,040 --> 00:28:54,950
I took all the NCI commands that were sent

698
00:28:54,950 --> 00:28:57,620
from the phone to the
chip during traditional

699
00:28:57,620 --> 00:29:01,850
NFC startup and reading, and
just replayed them as needed.

700
00:29:01,850 --> 00:29:04,500
I didn't have any access
to NCI documentation

701
00:29:04,500 --> 00:29:08,680
so everything I looked at via
NCI was reverse engineered.

702
00:29:08,680 --> 00:29:11,160
I went through each of
these commands and deleted

703
00:29:11,160 --> 00:29:12,720
any ones which were unnecessary.

704
00:29:12,720 --> 00:29:15,730
I worked out they were
unnecessary by removing them,

705
00:29:15,730 --> 00:29:18,410
replaying and seeing if NFC still worked.

706
00:29:18,410 --> 00:29:22,193
I found that this worked great and found

707
00:29:22,193 --> 00:29:23,490
that the last command that was sent was

708
00:29:23,490 --> 00:29:25,660
the NCI RF discover command,

709
00:29:25,660 --> 00:29:28,140
which is a command that
starts up either pretending

710
00:29:28,140 --> 00:29:29,030
to be a tag,

711
00:29:29,030 --> 00:29:31,340
pretending to be a reader
of different types or all

712
00:29:31,340 --> 00:29:32,200
of the above.

713
00:29:32,200 --> 00:29:34,723
And I modified this only
to act as a tag for now.

714
00:29:36,310 --> 00:29:38,670
Now, initial reverse
engineering of this hardware

715
00:29:38,670 --> 00:29:40,350
required knowledge of the
functions on the hardware

716
00:29:40,350 --> 00:29:42,280
in quite a large amount of depth.

717
00:29:42,280 --> 00:29:44,140
I would have to look through
how everything worked

718
00:29:44,140 --> 00:29:46,320
and understand it in quite
a lot of detail in order

719
00:29:46,320 --> 00:29:47,440
to modify it.

720
00:29:47,440 --> 00:29:48,630
And because there were no strings

721
00:29:48,630 --> 00:29:50,250
and no function references,

722
00:29:50,250 --> 00:29:53,020
everything I did I'd have to do by hand.

723
00:29:53,020 --> 00:29:53,853
So I know quite a lot

724
00:29:53,853 --> 00:29:57,310
about MIFARE Classic and
ISO14443a, and what I ended up

725
00:29:57,310 --> 00:29:58,970
doing was searching for SELECT command.

726
00:29:58,970 --> 00:30:01,670
Now there's enumeration and communication

727
00:30:01,670 --> 00:30:05,820
in NFC, which largely works
the same communication-wise,

728
00:30:05,820 --> 00:30:08,130
but there are timing
constraints on certain

729
00:30:08,130 --> 00:30:10,580
enumeration functions,
and to use this I'd want

730
00:30:10,580 --> 00:30:12,250
to find this first as
it was very likely to be

731
00:30:12,250 --> 00:30:13,610
using different hardware

732
00:30:13,610 --> 00:30:15,530
than the traditional communication.

733
00:30:15,530 --> 00:30:16,710
What I ended up doing was searching

734
00:30:16,710 --> 00:30:17,820
for the SELECT command,

735
00:30:17,820 --> 00:30:21,203
0x93 just by searching for a
comparison using regex in IDA.

736
00:30:21,203 --> 00:30:22,700
I found an immediate result,

737
00:30:22,700 --> 00:30:24,940
which was reading from a hardware address

738
00:30:24,940 --> 00:30:27,540
that specific value and
then jumping if it found it.

739
00:30:29,070 --> 00:30:31,100
Placing my phone on a
reader and then dumping

740
00:30:31,100 --> 00:30:32,900
the entire hardware address space

741
00:30:32,900 --> 00:30:36,730
of that particular address
found that it was indeed

742
00:30:36,730 --> 00:30:38,470
the NFC functionality.

743
00:30:38,470 --> 00:30:40,610
So I dumped this while NFC was running,

744
00:30:40,610 --> 00:30:43,320
while the chip was running,
and found that address 200,

745
00:30:43,320 --> 00:30:46,060
where it was found in the hardware was all

746
00:30:46,060 --> 00:30:48,630
the data buffers being sent to the chip.

747
00:30:48,630 --> 00:30:51,370
So in this instance, you
can see a hex 52 there

748
00:30:51,370 --> 00:30:54,280
which was NFC wakeup command

749
00:30:54,280 --> 00:30:57,913
which requests start up of NFC tags.

750
00:30:58,870 --> 00:31:01,180
With this I could read all
of the NFC read commands

751
00:31:01,180 --> 00:31:02,610
as well as some configuration data,

752
00:31:02,610 --> 00:31:04,530
which would be helpful later.

753
00:31:04,530 --> 00:31:06,710
This also allowed for
one way passive sniffing

754
00:31:06,710 --> 00:31:08,430
and would have allowed
for it later as well

755
00:31:08,430 --> 00:31:09,443
in different ways.

756
00:31:10,650 --> 00:31:13,650
So, as I said, enumeration
worked slightly different

757
00:31:13,650 --> 00:31:16,130
to traditional communication
for various reasons,

758
00:31:16,130 --> 00:31:18,190
including the size of
payloads and the time

759
00:31:18,190 --> 00:31:19,990
it takes to respond.

760
00:31:19,990 --> 00:31:23,970
However, I wanted to
modify specific aspects

761
00:31:23,970 --> 00:31:26,120
of this in order to modify how it worked.

762
00:31:26,120 --> 00:31:28,970
Now, when enumerates, in
order to define what kind

763
00:31:28,970 --> 00:31:30,450
of chip is being used,

764
00:31:30,450 --> 00:31:34,340
you have to send through three
values that are relevant.

765
00:31:34,340 --> 00:31:36,720
So the first thing that
happens is the NFC reader

766
00:31:36,720 --> 00:31:41,160
either sends a wakeup or
a request A, which has

767
00:31:41,160 --> 00:31:46,150
a command of 0x26, and what's
responded by the NFC chip

768
00:31:46,150 --> 00:31:47,190
is an ATQA value.

769
00:31:47,190 --> 00:31:48,620
Now this is a two byte value,

770
00:31:48,620 --> 00:31:50,240
which defines what kind of chip it is,

771
00:31:50,240 --> 00:31:51,840
and if you want the relevant details,

772
00:31:51,840 --> 00:31:54,500
just by which bits are
set in this response.

773
00:31:54,500 --> 00:31:57,110
The reader then sends the select command

774
00:31:57,110 --> 00:31:58,270
as we've saw earlier,

775
00:31:58,270 --> 00:32:01,750
which then makes the tags
from a unique identifier.

776
00:32:01,750 --> 00:32:02,800
Now on phones, each time,

777
00:32:02,800 --> 00:32:05,350
this is read as a unique
value that is randomized

778
00:32:05,350 --> 00:32:07,430
except for the first byte, which is 08.

779
00:32:07,430 --> 00:32:11,050
Now, traditionally, tags should
keep these as a static value

780
00:32:11,050 --> 00:32:13,130
just by how the standards work.

781
00:32:13,130 --> 00:32:15,050
And the reason it's
randomized is so you can't

782
00:32:15,050 --> 00:32:16,890
emulate specific tag types.

783
00:32:16,890 --> 00:32:18,630
We were gonna bypass this.

784
00:32:18,630 --> 00:32:21,900
And lastly, after selection
of this UID by the reader,

785
00:32:21,900 --> 00:32:23,150
it sends an SAK value

786
00:32:23,150 --> 00:32:25,950
which defines a little bit
more detail about what kind

787
00:32:25,950 --> 00:32:27,480
of tag is as well as saying

788
00:32:27,480 --> 00:32:29,010
whether the UID is slightly longer,

789
00:32:29,010 --> 00:32:31,333
either four, seven or 10 bytes.

790
00:32:36,790 --> 00:32:41,790
I found that I could set
the ATQA, NCI and SAK values

791
00:32:43,180 --> 00:32:45,900
by certain NCI commands.

792
00:32:45,900 --> 00:32:47,480
However, I found that when I sent these,

793
00:32:47,480 --> 00:32:50,460
specific bits were set just
by the firmware to force it

794
00:32:50,460 --> 00:32:53,410
to always behave as a
specific kind of chip.

795
00:32:53,410 --> 00:32:55,510
So you could never pretend
to be any other type

796
00:32:55,510 --> 00:32:57,580
of chip apart from the one
supported by the firmware

797
00:32:57,580 --> 00:32:59,030
at the time.

798
00:32:59,030 --> 00:33:02,030
I used my patched I2C
command to take a RAM dump,

799
00:33:02,030 --> 00:33:04,570
and then look for the values I'd set.

800
00:33:04,570 --> 00:33:06,730
I then compared these
in IDA by the addresses

801
00:33:06,730 --> 00:33:10,180
in RAM to any functionality that's found.

802
00:33:10,180 --> 00:33:12,560
And I found one function
which accessed all

803
00:33:12,560 --> 00:33:15,370
of the addresses that these were set for.

804
00:33:15,370 --> 00:33:16,810
Looking through, I found
that these were all

805
00:33:16,810 --> 00:33:17,870
accessing hardware addresses.

806
00:33:17,870 --> 00:33:21,130
These are the ones starting
at 4022, and this meant

807
00:33:21,130 --> 00:33:23,130
that it was probably setting
these in some configuration

808
00:33:23,130 --> 00:33:24,023
in the hardware.

809
00:33:25,760 --> 00:33:27,520
I overrode this function and then called

810
00:33:27,520 --> 00:33:29,180
it within the new function I'd overridden.

811
00:33:29,180 --> 00:33:32,080
This meant that I would
not have to modify anything

812
00:33:32,080 --> 00:33:35,190
about the functionality,
which was more complex,

813
00:33:35,190 --> 00:33:37,130
like if any had hardware set up,

814
00:33:37,130 --> 00:33:39,270
which I didn't wanna deal
with, but all it would mean

815
00:33:39,270 --> 00:33:41,970
is that I'd be able to override
the values I wanted to.

816
00:33:41,970 --> 00:33:44,333
So I let that function
run, and then set my own

817
00:33:44,333 --> 00:33:47,380
UID, ATQA and SAK values as needed

818
00:33:47,380 --> 00:33:49,330
so that I could pretend to be any chip.

819
00:33:50,390 --> 00:33:53,400
I then put this on Proxmark
again and use the reader mode

820
00:33:53,400 --> 00:33:55,230
to identify what data came out.

821
00:33:55,230 --> 00:33:58,146
And found that it had my
custom UID that I'd implemented

822
00:33:58,146 --> 00:34:01,570
as well as the ATQA and SAK values,

823
00:34:01,570 --> 00:34:04,110
which relates to a MIFARE Classic minitag,

824
00:34:04,110 --> 00:34:06,050
which was the one I was
emulating for this part

825
00:34:06,050 --> 00:34:07,223
of the custom firmware.

826
00:34:08,590 --> 00:34:09,860
I then wanted to move on to

827
00:34:09,860 --> 00:34:11,890
the more high level communication

828
00:34:11,890 --> 00:34:15,200
of the MIFARE Classic protocol.

829
00:34:15,200 --> 00:34:16,920
Now, as I stated before,

830
00:34:16,920 --> 00:34:19,200
enumeration and communication
is very close together,

831
00:34:19,200 --> 00:34:21,330
however, it was very
likely that this would be

832
00:34:21,330 --> 00:34:23,820
custom inside the firmware
rather than handled

833
00:34:23,820 --> 00:34:25,360
by hardware registers.

834
00:34:25,360 --> 00:34:27,350
I searched for the ATS value,

835
00:34:27,350 --> 00:34:29,160
which returns a certain configuration data

836
00:34:29,160 --> 00:34:31,890
about the tag, and just
by another comparison,

837
00:34:31,890 --> 00:34:34,280
I found that this had
very quickly jumped out.

838
00:34:34,280 --> 00:34:36,410
I found four results in the firmware,

839
00:34:36,410 --> 00:34:38,150
which I looked through and
found the specific one,

840
00:34:38,150 --> 00:34:40,170
which was most likely to be related to it.

841
00:34:40,170 --> 00:34:42,270
You can see a load byte
followed by comparison

842
00:34:42,270 --> 00:34:46,090
of that byte just in
the disassembly there.

843
00:34:46,090 --> 00:34:48,090
This meant I got inside the state machine

844
00:34:48,090 --> 00:34:51,930
which handled all of the
requests to the NFC chip

845
00:34:51,930 --> 00:34:53,170
from an NFC reader.

846
00:34:53,170 --> 00:34:54,983
I also noticed some other commands.

847
00:34:56,780 --> 00:34:58,900
Further tracing from this
led me to the function,

848
00:34:58,900 --> 00:35:01,420
which sent responses, including setting up

849
00:35:01,420 --> 00:35:06,130
the buffer address 0x100,
as well as the size

850
00:35:06,130 --> 00:35:09,470
at address 08, and a few other settings,

851
00:35:09,470 --> 00:35:10,920
which I couldn't work out the purpose of,

852
00:35:10,920 --> 00:35:12,110
but were very important.

853
00:35:12,110 --> 00:35:15,060
And if I removed them, it
wouldn't send responses any more.

854
00:35:16,280 --> 00:35:18,010
I first implemented a basic read command.

855
00:35:18,010 --> 00:35:21,240
So MIFARE often uses 30, and then a block,

856
00:35:21,240 --> 00:35:23,170
and then a CRC as just
a standard read command.

857
00:35:23,170 --> 00:35:25,650
And this is common through a
lot of different MIFARE chips.

858
00:35:25,650 --> 00:35:27,660
Sometimes it's encrypted,
sometimes it's not.

859
00:35:27,660 --> 00:35:30,070
But what this allowed me to do was using

860
00:35:30,070 --> 00:35:32,270
a Proxmark, read that
raw data and make sure

861
00:35:32,270 --> 00:35:33,620
that it actually worked.

862
00:35:33,620 --> 00:35:35,770
And I found that this worked as well.

863
00:35:35,770 --> 00:35:39,060
I had to set up a CRC the
end, but apart from that,

864
00:35:39,060 --> 00:35:42,660
this worked as any other read
command should in an NFC chip.

865
00:35:42,660 --> 00:35:45,460
I could later add an appropriate
encryption if I wanted.

866
00:35:46,370 --> 00:35:48,850
I overrode the entirety of
the state machine function

867
00:35:48,850 --> 00:35:50,640
as I found it largely
needless 'cause I didn't wanna

868
00:35:50,640 --> 00:35:53,990
attach anything else apart
from one specific aspect,

869
00:35:53,990 --> 00:35:55,240
which was the HALT command.

870
00:35:55,240 --> 00:35:58,430
Now this one is part of more
of the high level communication

871
00:35:58,430 --> 00:35:59,330
it's still somewhat part

872
00:35:59,330 --> 00:36:02,910
of enumeration as it sets
up the state of the NFC tag

873
00:36:02,910 --> 00:36:06,570
to not respond to
certain startup requests.

874
00:36:06,570 --> 00:36:08,300
I just called the HALT function

875
00:36:08,300 --> 00:36:10,290
that was found in the
state machine as needed,

876
00:36:10,290 --> 00:36:12,453
and it ran exactly as one would want to.

877
00:36:13,630 --> 00:36:15,730
I then also implemented the rest

878
00:36:15,730 --> 00:36:17,220
of MIFARE Classic commands as needed,

879
00:36:17,220 --> 00:36:19,990
including authorization,
as well as a writing

880
00:36:19,990 --> 00:36:21,670
block data, et cetera.

881
00:36:21,670 --> 00:36:23,440
I also added some debugging
commands as needed.

882
00:36:23,440 --> 00:36:25,730
So as you can see commented out there

883
00:36:25,730 --> 00:36:29,700
is debug command 70, which would
be provided with an address

884
00:36:29,700 --> 00:36:31,170
and read raw memory

885
00:36:31,170 --> 00:36:35,320
just out of the RAM of
the chip or any other part

886
00:36:35,320 --> 00:36:38,110
of the chip over NFC so
I can use this to debug

887
00:36:38,110 --> 00:36:39,173
via the Proxmark.

888
00:36:41,010 --> 00:36:42,400
Because I had full control of this,

889
00:36:42,400 --> 00:36:45,980
I could emulate any NFC tag as I wanted to

890
00:36:45,980 --> 00:36:48,920
as long as it was, ISO14443a.

891
00:36:48,920 --> 00:36:50,600
Now, I could have
expanded this to different

892
00:36:50,600 --> 00:36:52,407
13.56 megahertz protocols,

893
00:36:52,407 --> 00:36:54,107
but I stuck with this one for now.

894
00:36:55,630 --> 00:36:57,550
I implemented MIFARE
Classic authentication,

895
00:36:57,550 --> 00:36:58,440
which is quite simple,

896
00:36:58,440 --> 00:37:01,180
just using a very weak
encryption protocol.

897
00:37:01,180 --> 00:37:02,347
And I found that while this worked

898
00:37:02,347 --> 00:37:04,520
with a Proxmark, there
was a very good reason

899
00:37:04,520 --> 00:37:06,080
why it wouldn't work in legitimate reason

900
00:37:06,080 --> 00:37:08,280
that a reader that I
would need to get past.

901
00:37:09,540 --> 00:37:13,730
MIFARE Classic, it overrides
a very specific part

902
00:37:13,730 --> 00:37:17,700
of the RF protocol used
by the ISO14443a standard,

903
00:37:17,700 --> 00:37:19,300
which has the parity bit set at the end

904
00:37:19,300 --> 00:37:20,610
of every eight bits.

905
00:37:20,610 --> 00:37:23,920
So what happens is during
all communication is

906
00:37:23,920 --> 00:37:26,020
that both the reader
and the tag that sends

907
00:37:26,020 --> 00:37:28,480
a party bit after every
eight bits of the response,

908
00:37:28,480 --> 00:37:29,640
this being one or a zero,

909
00:37:29,640 --> 00:37:31,360
depending on how many bits were set

910
00:37:31,360 --> 00:37:33,090
in the previous eight bits.

911
00:37:33,090 --> 00:37:34,930
This is auto-generated
in the hardware as far

912
00:37:34,930 --> 00:37:35,910
as I could tell.

913
00:37:35,910 --> 00:37:38,490
And I was really concerned
'cause this could have been

914
00:37:38,490 --> 00:37:40,367
a complete stopper on this
project and stop me being able

915
00:37:40,367 --> 00:37:44,280
to emulate this firmware as I wanted to.

916
00:37:44,280 --> 00:37:45,410
However, I thought though

917
00:37:45,410 --> 00:37:47,130
that it was probably a
hardware bridge to setting

918
00:37:47,130 --> 00:37:49,660
that would allow me to modify
this as needed in order

919
00:37:49,660 --> 00:37:51,770
to put in my own parity bits.

920
00:37:51,770 --> 00:37:53,270
What this would mean is however,

921
00:37:53,270 --> 00:37:55,430
I'd have to stick nine
bits into eight bit buffers

922
00:37:55,430 --> 00:37:56,760
inside the firmware,

923
00:37:56,760 --> 00:37:59,670
which would make things quite complicated.

924
00:37:59,670 --> 00:38:02,310
What I did was go through
the hardware registers

925
00:38:02,310 --> 00:38:03,820
and the ones that were
specifically related

926
00:38:03,820 --> 00:38:06,380
to configuration, and
modified a single bit in turn,

927
00:38:06,380 --> 00:38:08,040
as often these use bits settings

928
00:38:08,040 --> 00:38:09,880
to define certain functionality.

929
00:38:09,880 --> 00:38:11,850
And I wanted to see what each one did.

930
00:38:11,850 --> 00:38:13,240
Now, this had some interesting outcomes,

931
00:38:13,240 --> 00:38:16,100
like making my responses huge
or adding randomized data,

932
00:38:16,100 --> 00:38:18,640
or encrypting in weird
ways or adding strange

933
00:38:18,640 --> 00:38:21,917
CRCs, but it was all quite
useless for what I wanted.

934
00:38:23,280 --> 00:38:24,820
I found that the parity register,

935
00:38:24,820 --> 00:38:29,820
which I wanted was at
address 400020004 by setting

936
00:38:30,287 --> 00:38:31,187
the bit of 0x4000.

937
00:38:32,540 --> 00:38:35,210
With this set, it shifted down all my data

938
00:38:35,210 --> 00:38:39,160
so that I now required adding
in the size of the data

939
00:38:39,160 --> 00:38:39,993
I was sending.

940
00:38:39,993 --> 00:38:43,520
This meant I had to change
the length to be a nine

941
00:38:43,520 --> 00:38:46,060
bits for each byte instead
of just eight for each byte,

942
00:38:46,060 --> 00:38:48,920
and also shift all the
data ascending left by one

943
00:38:48,920 --> 00:38:51,010
so I could add my encrypted bit.

944
00:38:51,010 --> 00:38:52,430
Within this in place, however,

945
00:38:52,430 --> 00:38:54,510
I could fully implement
a MIFARE Classic tag

946
00:38:54,510 --> 00:38:55,910
with no problems whatsoever.

947
00:38:56,790 --> 00:38:57,810
One of the thing I wanted to add

948
00:38:57,810 --> 00:38:59,270
was persistent storage of data.

949
00:38:59,270 --> 00:39:02,570
So when I was emulating
MIFARE Classic, I set up

950
00:39:02,570 --> 00:39:06,170
an I2C interface so I could
send tag data directly

951
00:39:06,170 --> 00:39:08,840
to the chip via the host phone.

952
00:39:08,840 --> 00:39:10,180
What I wanted to do is
be able to store any

953
00:39:10,180 --> 00:39:12,500
modifications and back to
the host phone as well.

954
00:39:12,500 --> 00:39:14,850
And what I did was modify I2C responses

955
00:39:14,850 --> 00:39:16,530
so that every time a write occurred,

956
00:39:16,530 --> 00:39:18,180
it would send that
written block back to me,

957
00:39:18,180 --> 00:39:20,623
and I could write it to
the file system as needed.

958
00:39:21,630 --> 00:39:23,070
Here's a quick demo of this occurring.

959
00:39:23,070 --> 00:39:25,770
So what I've done here is
taken a different phone

960
00:39:25,770 --> 00:39:27,400
on the NXP TagInfo app,

961
00:39:27,400 --> 00:39:29,470
which tries all sorts
of authentication styles

962
00:39:29,470 --> 00:39:32,690
and tag types to work
out what NFC chip is,

963
00:39:32,690 --> 00:39:34,110
or NFC tag is.

964
00:39:34,110 --> 00:39:39,110
And what I did wAS let this run

965
00:39:39,950 --> 00:39:42,410
on my Samsung S9 to see
if it could work out

966
00:39:42,410 --> 00:39:44,300
whether it was MIFARE Classic tag or not,

967
00:39:44,300 --> 00:39:46,680
and whether it could
authenticate appropriately.

968
00:39:46,680 --> 00:39:48,570
So what I do is I set
up a MIFARE Classic tag

969
00:39:48,570 --> 00:39:51,680
being emulated to have a
number of different keys

970
00:39:51,680 --> 00:39:54,180
and authentication mechanisms in place

971
00:39:54,180 --> 00:39:55,240
just so I could see how that worked.

972
00:39:55,240 --> 00:39:56,100
And as you can see,

973
00:39:56,100 --> 00:39:57,480
some keys were found somewhere

974
00:39:57,480 --> 00:40:00,580
just by what I had got
implemented in NXP TagInfo.

975
00:40:02,250 --> 00:40:04,930
So tag emulation allowed for a spoofing

976
00:40:04,930 --> 00:40:08,170
of access control cards, as
well as more esoteric uses.

977
00:40:08,170 --> 00:40:09,340
There's a lot of games and toys,

978
00:40:09,340 --> 00:40:11,673
which use 13.56 megahertz tags.

979
00:40:12,720 --> 00:40:14,830
But I also found that I could make it work

980
00:40:14,830 --> 00:40:17,010
so that all other NFC
functionality including

981
00:40:17,010 --> 00:40:19,570
reader modes or standard
functionality would work

982
00:40:19,570 --> 00:40:21,410
despite this patching, meaning while I had

983
00:40:21,410 --> 00:40:22,243
a custom firmware,

984
00:40:22,243 --> 00:40:23,930
it didn't damage the core
functionality of the chip

985
00:40:23,930 --> 00:40:27,370
as needed, but it did mean
that I would need to access it

986
00:40:27,370 --> 00:40:31,630
via my tool rather than the
host Android operating system.

987
00:40:31,630 --> 00:40:34,160
I felt that this was more subtle
than a dedicated hack tool

988
00:40:34,160 --> 00:40:36,690
such as a Proxmark or NFC coming in

989
00:40:36,690 --> 00:40:38,700
because it is a phone and
people don't generally

990
00:40:38,700 --> 00:40:40,900
expect them to have this
kind of functionality.

991
00:40:40,900 --> 00:40:43,910
And also extension of this
functionality to allow one,

992
00:40:43,910 --> 00:40:48,910
to do things like use dark
side attacks or MIFARE Classic

993
00:40:49,090 --> 00:40:50,710
decryption attacks directly on the phone

994
00:40:50,710 --> 00:40:53,773
and then deploy them back
again to the chip itself.

995
00:40:54,680 --> 00:40:56,360
I found that the same
emulation can be formed

996
00:40:56,360 --> 00:40:57,980
on any supported protocol.

997
00:40:57,980 --> 00:41:00,210
In fact, I found that
the hardware registers

998
00:41:00,210 --> 00:41:02,730
I was accessing were the
same for every protocol

999
00:41:02,730 --> 00:41:03,563
that was used by the chip.

1000
00:41:03,563 --> 00:41:05,990
So what was happening was it would switch

1001
00:41:05,990 --> 00:41:08,630
between different protocols
in that hardware by setting

1002
00:41:08,630 --> 00:41:09,493
a specific setting.

1003
00:41:09,493 --> 00:41:12,010
What this also meant is
that you could set up things

1004
00:41:12,010 --> 00:41:14,010
like certain amounts of
two-way passive sniffing

1005
00:41:14,010 --> 00:41:16,440
with different protocols
or implement different ones

1006
00:41:16,440 --> 00:41:18,260
as needed and have them
all work in conjunction

1007
00:41:18,260 --> 00:41:19,670
for different purposes.

1008
00:41:19,670 --> 00:41:20,940
Now that the framework
was in place and a lot

1009
00:41:20,940 --> 00:41:23,000
of the reverse engineering had been done,

1010
00:41:23,000 --> 00:41:24,673
I can do this if I wanted to.

1011
00:41:25,670 --> 00:41:28,180
In conclusion, all of the vulnerabilities

1012
00:41:28,180 --> 00:41:29,790
that I found were outlined

1013
00:41:29,790 --> 00:41:33,770
to Samsung as of April, 2020,
or rather they've patched them

1014
00:41:33,770 --> 00:41:35,730
as of April, 2020.

1015
00:41:35,730 --> 00:41:36,583
Because of this,

1016
00:41:37,830 --> 00:41:39,860
the chips won't be
vulnerable going forward.

1017
00:41:39,860 --> 00:41:41,450
However, all chips that are currently

1018
00:41:41,450 --> 00:41:44,150
out in the world will be
forever and we can use

1019
00:41:44,150 --> 00:41:46,360
those to develop custom
firmware as needed.

1020
00:41:46,360 --> 00:41:48,340
The vulnerability did require root access,

1021
00:41:48,340 --> 00:41:51,430
but so you could not
compromise a smartphone using

1022
00:41:51,430 --> 00:41:54,000
this interface by reflecting data back.

1023
00:41:54,000 --> 00:41:57,400
However it did fully compromise
this chip in particular.

1024
00:41:57,400 --> 00:41:59,220
We've got to remember that phones are

1025
00:41:59,220 --> 00:42:01,120
exploitable embedded
devices in the same way

1026
00:42:01,120 --> 00:42:03,070
as any IoT device.

1027
00:42:03,070 --> 00:42:05,270
However, of course they're
slightly high security

1028
00:42:05,270 --> 00:42:07,420
in some ways, but they really
should be treated like that.

1029
00:42:07,420 --> 00:42:10,050
The chips in there are often
running old bootloaders,

1030
00:42:10,050 --> 00:42:11,300
which will never be changed.

1031
00:42:11,300 --> 00:42:12,950
And because of this,
bootloader vulnerabilities

1032
00:42:12,950 --> 00:42:14,090
are very common.

1033
00:42:14,090 --> 00:42:15,980
This is not the only chip that I've broken

1034
00:42:15,980 --> 00:42:17,923
in a similar manner,
and it's not in the only

1035
00:42:17,923 --> 00:42:22,140
NFC chip I've broken in this
manner, especially on phones.

1036
00:42:22,140 --> 00:42:24,320
Developing custom firmware
is a very difficult task,

1037
00:42:24,320 --> 00:42:25,990
sometimes they can take a lot of time.

1038
00:42:25,990 --> 00:42:27,600
However, it can be rewarding and get some

1039
00:42:27,600 --> 00:42:29,500
very interesting outcomes.

1040
00:42:29,500 --> 00:42:31,687
And lastly, if an undisclosed
vulnerability is found

1041
00:42:31,687 --> 00:42:34,210
in old chip, it'll likely be in a new one.

1042
00:42:34,210 --> 00:42:35,210
Thank you very much.

