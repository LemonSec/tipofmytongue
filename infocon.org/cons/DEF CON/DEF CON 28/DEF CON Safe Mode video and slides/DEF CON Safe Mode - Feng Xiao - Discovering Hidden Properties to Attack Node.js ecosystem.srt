1
00:00:02,350 --> 00:00:05,460
- Hi, everyone, my name is
Feng Xiao from Georgia Tech.

2
00:00:05,460 --> 00:00:10,460
It seems like I'm first
DEF CON SAFE MODE TALKS,

3
00:00:10,618 --> 00:00:15,060
and I really hope everyone
can enjoy attending my work.

4
00:00:15,060 --> 00:00:18,000
So, this is not of course only my work,

5
00:00:18,000 --> 00:00:20,000
but also the work of
my wonderful courser's

6
00:00:20,000 --> 00:00:22,990
from Georgia Tech and Texas A&M.

7
00:00:22,990 --> 00:00:24,590
Today I'm going to talk about

8
00:00:24,590 --> 00:00:26,600
some interesting new world abilities

9
00:00:26,600 --> 00:00:28,333
in the Node.js ecosystems.

10
00:00:29,870 --> 00:00:32,010
Before the talk normally begins,

11
00:00:32,010 --> 00:00:34,293
please let me introduce
myself a little more.

12
00:00:35,200 --> 00:00:38,450
I am a CS PhD student at Georgia Tech,

13
00:00:38,450 --> 00:00:41,600
my research goal is about
building automatic systems

14
00:00:41,600 --> 00:00:44,530
to detect and exploit vulnerabilities.

15
00:00:44,530 --> 00:00:46,830
We want the tools to
exploit vulnerabilities

16
00:00:46,830 --> 00:00:50,930
because we want the people
to know the existence

17
00:00:50,930 --> 00:00:54,350
and the consequences
of their security box.

18
00:00:54,350 --> 00:00:58,400
And I do research in the web
and application security,

19
00:00:58,400 --> 00:01:01,810
but I'm also researching
security problems in other areas

20
00:01:01,810 --> 00:01:05,993
such as software-defining
networks and x86 virtualization.

21
00:01:07,510 --> 00:01:11,030
Okay, so these are the topics
I'm going to cover today,

22
00:01:11,030 --> 00:01:13,463
the talk will be divided into three parts.

23
00:01:14,460 --> 00:01:16,930
First, I will introduce
the technical details

24
00:01:16,930 --> 00:01:20,850
of the new vulnerabilities
and discuss the exploitation.

25
00:01:20,850 --> 00:01:24,850
Then I will talk more
about the bug finding pass,

26
00:01:24,850 --> 00:01:27,880
which is about the
lessons and the insights

27
00:01:27,880 --> 00:01:31,440
for building one kind of hack tool

28
00:01:31,440 --> 00:01:35,060
to detect and exploit HPA.

29
00:01:35,060 --> 00:01:36,720
And in the last part,

30
00:01:36,720 --> 00:01:40,790
I will give impact
analysis of the new risk,

31
00:01:40,790 --> 00:01:43,203
and some evaluation data about the tools.

32
00:01:45,560 --> 00:01:47,790
So, first of all let's take a quick look

33
00:01:47,790 --> 00:01:50,813
at the vulnerabilities we
found during our research.

34
00:01:52,370 --> 00:01:56,730
So in total, we discovered
13 zero-day one derivatives

35
00:01:56,730 --> 00:02:00,830
from widely used programs such
as MongoDB official drivers,

36
00:02:00,830 --> 00:02:03,100
class liquidators,

37
00:02:03,100 --> 00:02:06,860
and this box can be exploited
to launch serious attacks,

38
00:02:06,860 --> 00:02:09,020
such as leaking credential data's,

39
00:02:09,020 --> 00:02:12,193
bypassing security checks
and denial of services.

40
00:02:13,670 --> 00:02:16,300
So, before we touch to technical details

41
00:02:16,300 --> 00:02:18,490
of this vulnerabilities,

42
00:02:18,490 --> 00:02:21,430
let's have a brief background introduction

43
00:02:21,430 --> 00:02:22,973
about the Node.js.

44
00:02:24,400 --> 00:02:25,890
Node.js is for executing

45
00:02:25,890 --> 00:02:28,950
JavaScript code outside of browsers,

46
00:02:28,950 --> 00:02:30,070
the picture on the right

47
00:02:30,070 --> 00:02:33,430
is the overall system diagram of Node.js

48
00:02:33,430 --> 00:02:36,750
to interrupt and execute JavaScript,

49
00:02:36,750 --> 00:02:40,950
the Node.js implements a runtime
engine based on Chrome v8,

50
00:02:40,950 --> 00:02:45,143
to satisfy the needs of
the server side languages.

51
00:02:46,760 --> 00:02:49,670
The runtime engine also
provide a set of API

52
00:02:49,670 --> 00:02:52,503
to let JavaScript interact
with the host environment.

53
00:02:53,900 --> 00:02:56,630
By providing such API's,

54
00:02:56,630 --> 00:02:59,510
the JavaScript code can
access the host environment

55
00:02:59,510 --> 00:03:01,930
like anything server side languages,

56
00:03:01,930 --> 00:03:05,300
for example, it can read
and write file systems,

57
00:03:05,300 --> 00:03:08,120
or execute systems command.

58
00:03:08,120 --> 00:03:10,133
So, Node.js is pretty powerful.

59
00:03:12,330 --> 00:03:15,660
Nowadays, many websites
have deployed Node.js.

60
00:03:15,660 --> 00:03:18,450
For example, Node.js are intensively used

61
00:03:18,450 --> 00:03:21,600
in companies like PayPal and LinkedIn.

62
00:03:21,600 --> 00:03:25,350
Also, we are all using
a lot of electron apps,

63
00:03:25,350 --> 00:03:28,630
such as Skype or Discord,

64
00:03:28,630 --> 00:03:32,853
and search electron apps are
also based Node.js runtime.

65
00:03:34,750 --> 00:03:37,620
We've seen so many Node.js applications,

66
00:03:37,620 --> 00:03:39,000
the web based app

67
00:03:39,000 --> 00:03:42,583
are the one of the most common
types of Node.js programs.

68
00:03:43,440 --> 00:03:45,900
For those web based applications,

69
00:03:45,900 --> 00:03:47,500
taking the communication data

70
00:03:47,500 --> 00:03:52,500
into object representations
like JSON is pretty common,

71
00:03:53,650 --> 00:03:56,700
and this feature is convenient.

72
00:03:56,700 --> 00:03:59,730
For example, the Node.js
can use this feature

73
00:03:59,730 --> 00:04:03,253
to use send and receive
very complex data structure.

74
00:04:04,210 --> 00:04:07,340
From the monthly downloads
studies the picture on the right,

75
00:04:07,340 --> 00:04:08,510
we can have an idea

76
00:04:08,510 --> 00:04:11,300
of how the object sharing
is being supported,

77
00:04:11,300 --> 00:04:14,253
and used by the Node.js ecosystems.

78
00:04:15,930 --> 00:04:18,100
So, the diagram demonstrate

79
00:04:18,100 --> 00:04:23,100
how object sharing is being
used in the Node.js ecosystem.

80
00:04:23,200 --> 00:04:28,200
There are two major methods of
serialization object data's,

81
00:04:29,200 --> 00:04:32,020
the first is the
Querystring-based Serialization,

82
00:04:32,020 --> 00:04:35,130
and the second is the
JSON-based Serialization.

83
00:04:35,130 --> 00:04:36,560
As shown in the picture,

84
00:04:36,560 --> 00:04:38,070
if the user wants to update

85
00:04:38,070 --> 00:04:40,910
the age information in the Node.js web,

86
00:04:40,910 --> 00:04:42,950
he can send his data either

87
00:04:42,950 --> 00:04:45,833
via standard Querystring in the URL,

88
00:04:45,833 --> 00:04:49,260
or a JSON string in the request body.

89
00:04:49,260 --> 00:04:51,170
Upon receiving the request,

90
00:04:51,170 --> 00:04:55,070
the web application will
convert the JSON data,

91
00:04:55,070 --> 00:04:58,620
or the Querystring data into an object,

92
00:04:58,620 --> 00:05:00,870
so that the object can further propagate

93
00:05:00,870 --> 00:05:02,343
in the program logic's.

94
00:05:03,370 --> 00:05:06,170
Okay, so basically this
is how the object sharing

95
00:05:06,170 --> 00:05:09,350
is carried out in Node.js ecosystems.

96
00:05:09,350 --> 00:05:11,380
Usually, if we want to evaluate

97
00:05:11,380 --> 00:05:13,520
the security of such a program,

98
00:05:13,520 --> 00:05:17,710
we may want to inject different
payloads into the age field,

99
00:05:17,710 --> 00:05:20,850
so that we can try to trigger

100
00:05:20,850 --> 00:05:23,910
certain vulnerabilities
such as SQL injections,

101
00:05:23,910 --> 00:05:25,293
or course at Scripps.

102
00:05:26,870 --> 00:05:29,410
However, what if we choose

103
00:05:29,410 --> 00:05:31,963
not to test the existing data failed?

104
00:05:33,020 --> 00:05:36,060
Since we can pass an
object into the program,

105
00:05:36,060 --> 00:05:38,940
What will happen if we
inject additional properties

106
00:05:38,940 --> 00:05:42,153
that are not expected to be
received by the server program?

107
00:05:43,160 --> 00:05:46,840
In particular, if an attacker
can send the properties

108
00:05:46,840 --> 00:05:48,680
that forge, or override

109
00:05:48,680 --> 00:05:51,190
to the certain internal program states,

110
00:05:51,190 --> 00:05:54,560
the attacker may easily
obtain dangerous abilities

111
00:05:54,560 --> 00:05:57,663
to manipulate the key program logic's.

112
00:05:59,660 --> 00:06:01,440
So We are going to introduce

113
00:06:01,440 --> 00:06:04,313
the Hidden Property Abusing, HPA.

114
00:06:05,180 --> 00:06:06,620
So the Hidden Property Abusing

115
00:06:06,620 --> 00:06:08,900
leverage the object sharing in Node.js

116
00:06:08,900 --> 00:06:12,830
to tamper or forge
critical programs states,

117
00:06:12,830 --> 00:06:15,390
we call the additional
properties we inject

118
00:06:15,390 --> 00:06:16,910
as the hidden properties,

119
00:06:16,910 --> 00:06:18,240
because these properties

120
00:06:18,240 --> 00:06:20,750
are kind of like some hidden parameters,

121
00:06:20,750 --> 00:06:23,733
which is valid to the endpoint use API.

122
00:06:24,590 --> 00:06:27,100
These parameters are associated

123
00:06:27,100 --> 00:06:29,710
with certain internal program states.

124
00:06:29,710 --> 00:06:32,480
However, nobody knows their existence,

125
00:06:32,480 --> 00:06:36,323
until an attacker leverage
HPA to tamper the states.

126
00:06:37,250 --> 00:06:40,890
In this talk, we mainly focus
on the server side scenarios

127
00:06:40,890 --> 00:06:42,440
where our remote attacker

128
00:06:42,440 --> 00:06:45,440
wants to attack the
Node.js web applications,

129
00:06:45,440 --> 00:06:47,083
or some micro services.

130
00:06:48,050 --> 00:06:49,600
To explore the vulnerabilities,

131
00:06:49,600 --> 00:06:52,920
the attacker will access
the legitimate interfaces,

132
00:06:52,920 --> 00:06:57,200
such as the Web API endpoint
to send his payloads.

133
00:06:57,200 --> 00:07:00,310
In most cases, the attacker payloads

134
00:07:00,310 --> 00:07:02,570
should be in the form of plain object,

135
00:07:02,570 --> 00:07:06,793
which is the simplest object
representation in Node.js.

136
00:07:09,370 --> 00:07:10,440
During our research,

137
00:07:10,440 --> 00:07:15,440
we discovered two types of
typical attack vectors of HPA,

138
00:07:15,710 --> 00:07:17,330
we call the first one as

139
00:07:17,330 --> 00:07:20,053
the App-specific Attribute Manipulation,

140
00:07:20,930 --> 00:07:24,300
this one is for manipulating
certain internal properties

141
00:07:24,300 --> 00:07:27,140
defined by the application themselves,

142
00:07:27,140 --> 00:07:30,260
such internal properties are
supposed to be initialized,

143
00:07:30,260 --> 00:07:33,180
and managed by their internal functions.

144
00:07:33,180 --> 00:07:36,480
However, they usually represent

145
00:07:36,480 --> 00:07:39,200
certain internal states of the programs.

146
00:07:39,200 --> 00:07:40,930
So as showing the picture,

147
00:07:40,930 --> 00:07:43,620
the init_role is an internal function

148
00:07:43,620 --> 00:07:45,780
that is responsible for maintaining

149
00:07:45,780 --> 00:07:48,453
the access right on the user object.

150
00:07:49,460 --> 00:07:53,000
However, with HPA the
attacker can propagate

151
00:07:53,000 --> 00:07:56,930
a conflicting name
property to the use object,

152
00:07:56,930 --> 00:08:01,930
and fast the control the
internal states of the program.

153
00:08:02,000 --> 00:08:03,250
As showed in the picture,

154
00:08:04,160 --> 00:08:08,273
the program also provides
an API, called update,

155
00:08:08,273 --> 00:08:11,010
this is for external usage.

156
00:08:11,010 --> 00:08:14,740
However, if an malicious user inject

157
00:08:14,740 --> 00:08:16,630
additional key value pair,

158
00:08:16,630 --> 00:08:21,630
which is access and admin
in the picture to the API,

159
00:08:22,340 --> 00:08:25,160
then the additional properties

160
00:08:25,160 --> 00:08:29,083
will overwrite the existing access right.

161
00:08:29,940 --> 00:08:32,100
So, this pillow is pretty useful

162
00:08:32,100 --> 00:08:33,410
when we want to abuse

163
00:08:33,410 --> 00:08:35,973
certain concrete logic's
in large applications,

164
00:08:37,020 --> 00:08:39,300
such like some older information,

165
00:08:39,300 --> 00:08:42,240
or user privilege and management logic's.

166
00:08:43,770 --> 00:08:46,720
Also, HPA can target some unique

167
00:08:46,720 --> 00:08:49,403
JavaScript schemes such as prototyping.

168
00:08:50,360 --> 00:08:52,530
We call the second attack scenarios

169
00:08:52,530 --> 00:08:55,053
as prototype inheritance hijacking.

170
00:08:56,180 --> 00:08:58,140
In JavaScript, every object

171
00:08:58,140 --> 00:09:00,800
has a link to a prototype object.

172
00:09:00,800 --> 00:09:02,500
When the JavaScript co-wants

173
00:09:02,500 --> 00:09:05,770
to access a property of an object,

174
00:09:05,770 --> 00:09:09,200
the property will not only
be searched on the object,

175
00:09:09,200 --> 00:09:11,240
but also the prototype of the object,

176
00:09:11,240 --> 00:09:14,000
and even the prototype of the prototype,

177
00:09:14,000 --> 00:09:16,893
until our property with
a matching name is found.

178
00:09:18,000 --> 00:09:19,550
As shown in the picture,

179
00:09:19,550 --> 00:09:21,420
when the JavaScript co-wants to get

180
00:09:21,420 --> 00:09:24,933
the constructive constructor
property from the input object,

181
00:09:24,933 --> 00:09:28,643
it will first search locally
within the input object.

182
00:09:29,500 --> 00:09:32,910
Since there is no property
named constructor here,

183
00:09:32,910 --> 00:09:36,320
the code will continue it's
search to it's prototype,

184
00:09:36,320 --> 00:09:39,593
where the constructor is really located.

185
00:09:40,980 --> 00:09:44,600
So with HPA, we can hijack
the inheritance chain,

186
00:09:44,600 --> 00:09:46,480
and forge our own payloads

187
00:09:46,480 --> 00:09:49,233
as the internal properties on the chain.

188
00:09:50,210 --> 00:09:51,520
As shown in the picture,

189
00:09:51,520 --> 00:09:54,660
if we inject a property
named the constructor,

190
00:09:54,660 --> 00:09:57,240
the search process will be very different,

191
00:09:57,240 --> 00:09:59,660
since there is already a
property named constructor

192
00:09:59,660 --> 00:10:01,980
we've seen the input object,

193
00:10:01,980 --> 00:10:03,963
the search will immediately stop,

194
00:10:05,530 --> 00:10:09,480
and end up with returning
a user controlled value.

195
00:10:09,480 --> 00:10:11,710
As demonstrated in the red circle,

196
00:10:11,710 --> 00:10:14,550
the value of the constructor
will become a stream,

197
00:10:14,550 --> 00:10:15,540
Rick and Morty,

198
00:10:15,540 --> 00:10:18,423
rather than a normal JavaScript functions.

199
00:10:19,350 --> 00:10:23,120
So, the second attack
vector is really useful

200
00:10:23,120 --> 00:10:26,410
because we found many
JavaScript developers

201
00:10:26,410 --> 00:10:30,110
tend to trust the properties
inherited from prototypes,

202
00:10:30,110 --> 00:10:34,183
and make many security sensitive
decisions based on them.

203
00:10:35,130 --> 00:10:37,640
Also, we should be
aware of the differences

204
00:10:37,640 --> 00:10:41,693
between these attack vectors
with the prototype pollution.

205
00:10:42,750 --> 00:10:45,900
The the two attacks totally different,

206
00:10:45,900 --> 00:10:48,750
the prototype pollution
as the name suggested,

207
00:10:48,750 --> 00:10:52,580
is about tampering the prototype object.

208
00:10:52,580 --> 00:10:55,630
However, our attack vector

209
00:10:55,630 --> 00:10:58,373
does not modify the prototype object.

210
00:11:01,370 --> 00:11:03,750
The root cause of the HPA is that

211
00:11:03,750 --> 00:11:08,080
the Node.js fails to
isolate unsafe object,

212
00:11:08,080 --> 00:11:12,970
such as the user input from
the critical internal states.

213
00:11:12,970 --> 00:11:15,940
So, to make a clear classification,

214
00:11:15,940 --> 00:11:19,130
the HPA can be seen as a new security risk

215
00:11:19,130 --> 00:11:22,690
under the common weakness category 915,

216
00:11:22,690 --> 00:11:27,170
whose child variants are all
about improper modification

217
00:11:27,170 --> 00:11:29,443
of the dynamic object attributes.

218
00:11:30,500 --> 00:11:33,140
As shown in the hierarchy
tree on the right,

219
00:11:33,140 --> 00:11:36,350
there are some similar issues
on other language platforms,

220
00:11:36,350 --> 00:11:40,660
such as Ruby Mass Assignment,
the PHP Object Injections.

221
00:11:40,660 --> 00:11:42,280
Although these variance

222
00:11:42,280 --> 00:11:46,690
share the same behavior
feature dominated by 915.

223
00:11:46,690 --> 00:11:49,970
They all have their own data partners

224
00:11:49,970 --> 00:11:52,370
due to the language differences.

225
00:11:52,370 --> 00:11:55,150
For example, the Ruby Mass Assignment

226
00:11:55,150 --> 00:11:57,570
is a set of vulnerabilities discovered

227
00:11:57,570 --> 00:12:00,890
and might use the Ruby
web application framework

228
00:12:00,890 --> 00:12:03,150
called the Ruby on Rails.

229
00:12:03,150 --> 00:12:05,950
Unlike HPA, their attacker does not

230
00:12:05,950 --> 00:12:08,050
pass objects into the program.

231
00:12:08,050 --> 00:12:11,570
Instead, the attacker abuse

232
00:12:11,570 --> 00:12:15,380
a framework specific assignment
feature in Ruby on Rails,

233
00:12:15,380 --> 00:12:17,650
to modify certain existing objects

234
00:12:17,650 --> 00:12:20,310
on the right side of the assignment.

235
00:12:20,310 --> 00:12:24,340
And the payloads between the
two attacks are also different.

236
00:12:24,340 --> 00:12:27,400
The Mass Assignment
payloads are literal value.

237
00:12:27,400 --> 00:12:30,280
However, HPA can introduce
hidden properties

238
00:12:30,280 --> 00:12:34,363
we seen with either literal
value or nested object form.

239
00:12:35,330 --> 00:12:38,320
More importantly, the
Ruby is strongly typed,

240
00:12:38,320 --> 00:12:40,260
so, the mass assignment vulnerabilities

241
00:12:40,260 --> 00:12:43,270
cannot introduce new
properties to the objects.

242
00:12:43,270 --> 00:12:47,710
However, the HPA can inject
arbitrary properties,

243
00:12:48,570 --> 00:12:51,653
which make HPA really
flexible and powerful.

244
00:12:54,010 --> 00:12:57,780
Okay, so with several pages
of concept introduction,

245
00:12:57,780 --> 00:13:00,563
I think it's time we can
have some real targets.

246
00:13:02,000 --> 00:13:03,450
In this example,

247
00:13:03,450 --> 00:13:08,410
we target a popular web framework
named Routing Controller.

248
00:13:08,410 --> 00:13:10,900
We will attack his official example code

249
00:13:10,900 --> 00:13:12,340
to demonstrate an end-to-end

250
00:13:12,340 --> 00:13:16,290
prototype inheritance hijacking exploit,

251
00:13:16,290 --> 00:13:19,293
from security check by
passing to SQL injection.

252
00:13:20,600 --> 00:13:21,700
The figure on the right,

253
00:13:21,700 --> 00:13:25,240
can give you a brief idea
how our example works.

254
00:13:25,240 --> 00:13:26,270
In the example,

255
00:13:26,270 --> 00:13:30,740
a server program is deployed
using routing controllers,

256
00:13:30,740 --> 00:13:34,060
if a remote user wants to
authenticate with the server,

257
00:13:34,060 --> 00:13:37,380
his data will flows into
the following components,

258
00:13:37,380 --> 00:13:40,210
first, he will send his serialized data

259
00:13:40,210 --> 00:13:43,260
into the authentication module,

260
00:13:43,260 --> 00:13:47,990
then the authentication module
will instantiate the objects,

261
00:13:47,990 --> 00:13:49,780
according to the JSON he provides,

262
00:13:49,780 --> 00:13:52,680
and send it to the Param Handler,

263
00:13:52,680 --> 00:13:54,410
here we use the green box

264
00:13:54,410 --> 00:13:57,260
to demonstrate the use of data objects.

265
00:13:57,260 --> 00:13:59,670
The Param Handler is responsible

266
00:13:59,670 --> 00:14:03,660
for showing us the input
object is not malicious.

267
00:14:03,660 --> 00:14:05,520
The handler will first collect

268
00:14:05,520 --> 00:14:08,260
internal format specification object,

269
00:14:08,260 --> 00:14:10,320
which is the blue box in the picture,

270
00:14:10,320 --> 00:14:15,280
and he will merge the specification
with the input object,

271
00:14:15,280 --> 00:14:17,543
and invoke the Input Validation API.

272
00:14:18,653 --> 00:14:20,570
The Input Validation API,

273
00:14:20,570 --> 00:14:22,880
will standardize the use of input data

274
00:14:22,880 --> 00:14:25,270
according to the format specification.

275
00:14:25,270 --> 00:14:26,380
In this case,

276
00:14:26,380 --> 00:14:30,170
it will check if the email
field is legitimate or not,

277
00:14:30,170 --> 00:14:31,760
if the check pass

278
00:14:31,760 --> 00:14:35,670
the use object well,
flows into the Database.

279
00:14:35,670 --> 00:14:38,410
Okay, so this is the overall data flow,

280
00:14:38,410 --> 00:14:41,733
let's analyze how we can
attack the logic step by step.

281
00:14:43,360 --> 00:14:47,330
So, the first step is the
hidden property injection,

282
00:14:47,330 --> 00:14:49,911
in which the malicious attacker

283
00:14:49,911 --> 00:14:53,653
injects hidden properties in his request,

284
00:14:54,830 --> 00:14:57,350
which is the constructor in this case.

285
00:14:57,350 --> 00:14:58,900
As shown in the picture,

286
00:14:58,900 --> 00:15:02,772
when the server program
instantiate the use object,

287
00:15:02,772 --> 00:15:07,530
there will be an additional
property named the constructor,

288
00:15:07,530 --> 00:15:10,530
which is a payload for bypassing

289
00:15:10,530 --> 00:15:12,963
the input validation module.

290
00:15:14,370 --> 00:15:15,940
So, in the second step,

291
00:15:15,940 --> 00:15:18,480
the program will prepare the parameters

292
00:15:18,480 --> 00:15:20,990
needed by the Input Validation API.

293
00:15:20,990 --> 00:15:23,760
The schema program will
merge the user input,

294
00:15:23,760 --> 00:15:25,180
which is the param,

295
00:15:25,180 --> 00:15:29,460
with a object named the schema,

296
00:15:29,460 --> 00:15:31,620
the merging operation is carried out

297
00:15:31,620 --> 00:15:35,290
by putting every property
from the param objects

298
00:15:35,290 --> 00:15:37,010
into the schema object.

299
00:15:37,010 --> 00:15:41,420
So this process is very
much like object assign.

300
00:15:41,420 --> 00:15:43,630
To simplify the demonstration,

301
00:15:43,630 --> 00:15:47,420
let's just use object
assign in this example.

302
00:15:47,420 --> 00:15:50,480
By performing such merging operations,

303
00:15:50,480 --> 00:15:52,040
the hidden property constructor

304
00:15:52,040 --> 00:15:54,323
will also transform to the schema,

305
00:15:56,010 --> 00:15:57,960
and after the transformation,

306
00:15:57,960 --> 00:16:00,120
we now can hijack their inheritance

307
00:16:00,120 --> 00:16:02,650
of the constructor on the schema.

308
00:16:02,650 --> 00:16:05,210
Actually, the constructor of the schema

309
00:16:05,210 --> 00:16:09,720
plays a very important role in
the input validation module.

310
00:16:09,720 --> 00:16:11,462
As shown in the picture,

311
00:16:11,462 --> 00:16:14,520
the constructor actually stores

312
00:16:14,520 --> 00:16:19,520
the important format
restriction information.

313
00:16:19,630 --> 00:16:22,720
As a result, the merging
operation enables us

314
00:16:22,720 --> 00:16:24,694
to hijack the inheritance

315
00:16:24,694 --> 00:16:27,850
of these important
formatting restrictions.

316
00:16:27,850 --> 00:16:29,270
As shown in the picture,

317
00:16:29,270 --> 00:16:33,490
when the constructor is raided
by the getSchema function,

318
00:16:33,490 --> 00:16:36,830
our hidden property will
be immediately matched,

319
00:16:36,830 --> 00:16:41,260
and returned to the code to
bypass the input validation.

320
00:16:41,260 --> 00:16:44,290
We just need to set the
format specification

321
00:16:44,290 --> 00:16:45,770
as an invalid value,

322
00:16:45,770 --> 00:16:49,323
so that our SQL injection
payload can escape the check.

323
00:16:50,450 --> 00:16:54,020
Now, the last step is
much more straightforward,

324
00:16:54,020 --> 00:16:57,510
the validate payload then
flows into the sensitive API

325
00:16:57,510 --> 00:16:59,900
to finish the entire attack.

326
00:16:59,900 --> 00:17:04,300
So this is how our entire
HPA chain looks like.

327
00:17:04,300 --> 00:17:07,130
Actually, the code logic
behind the vulnerability

328
00:17:07,130 --> 00:17:08,990
is much more complex.

329
00:17:08,990 --> 00:17:11,970
For example, the input validation module

330
00:17:11,970 --> 00:17:16,970
contains 30,000 lines of code.

331
00:17:17,500 --> 00:17:20,800
So, it would be helpful
if we can find a tool

332
00:17:20,800 --> 00:17:23,500
that will automatically
track these data structures,

333
00:17:23,500 --> 00:17:25,750
and discover term for hidden properties

334
00:17:25,750 --> 00:17:27,573
existing in the program logic's.

335
00:17:28,910 --> 00:17:32,080
So, what are the challenges
of building such a tool?

336
00:17:32,080 --> 00:17:34,050
First of all it is JavaScript,

337
00:17:34,050 --> 00:17:36,240
analyzing JavaScript is known to be hard

338
00:17:36,240 --> 00:17:37,723
due to the dynamic nature.

339
00:17:39,200 --> 00:17:43,120
And second HPA is a tech that creates

340
00:17:43,120 --> 00:17:46,350
unexpected and new data dependencies.

341
00:17:46,350 --> 00:17:48,840
However, program analysis usually...

342
00:17:50,840 --> 00:17:52,910
Such as data flow tracking

343
00:17:52,910 --> 00:17:56,210
is mainly for analyzing
the existing flows.

344
00:17:56,210 --> 00:17:58,380
Third, from our run examples,

345
00:17:58,380 --> 00:18:02,750
we can observe that HPA tampers
internal program states.

346
00:18:02,750 --> 00:18:05,340
So the attack effects highly depends

347
00:18:05,340 --> 00:18:08,510
on the roles of the compromised states,

348
00:18:08,510 --> 00:18:10,610
this makes the detection more challenging.

349
00:18:11,950 --> 00:18:13,720
To overcome these challenges,

350
00:18:13,720 --> 00:18:15,970
we designed and implement Lynx',

351
00:18:15,970 --> 00:18:18,680
a hybrid JavaScript program analyze tool,

352
00:18:18,680 --> 00:18:22,730
to detect and exploit HPA vulnerabilities.

353
00:18:22,730 --> 00:18:25,453
Lynx' mainly consists of two components.

354
00:18:26,500 --> 00:18:28,970
The first component on the left

355
00:18:28,970 --> 00:18:31,860
is for identifying
potential hidden properties,

356
00:18:31,860 --> 00:18:36,100
it combines dynamic data flow tracking,

357
00:18:36,100 --> 00:18:40,850
and static synthetics analysis
to track all the user input

358
00:18:40,850 --> 00:18:43,570
and infer potential candidates.

359
00:18:43,570 --> 00:18:45,210
And the components on the right

360
00:18:45,210 --> 00:18:47,960
is for detecting the
harmful hidden properties

361
00:18:47,960 --> 00:18:49,853
and generating exploits for them.

362
00:18:51,130 --> 00:18:54,300
To help future Node.js security research,

363
00:18:54,300 --> 00:18:57,350
we decided to open
source our links project

364
00:18:57,350 --> 00:19:00,963
at the GitHub links in the bottom.

365
00:19:02,090 --> 00:19:05,350
So, if you are interested
in the technical details,

366
00:19:05,350 --> 00:19:08,483
you can check it in the GitHub report.

367
00:19:10,200 --> 00:19:12,850
So, the very first
thing this lynx' will do

368
00:19:12,850 --> 00:19:15,050
is dynamic data flow tracking.

369
00:19:15,050 --> 00:19:18,480
First of all, Lynx' will
generated that labeled object,

370
00:19:18,480 --> 00:19:21,863
which is a unique key and value pair.

371
00:19:23,130 --> 00:19:25,610
Lynx' will inject the label

372
00:19:25,610 --> 00:19:28,480
into the input data of the program.

373
00:19:28,480 --> 00:19:31,070
Since different properties
from the input object

374
00:19:31,070 --> 00:19:34,320
may flow into different program logic's,

375
00:19:34,320 --> 00:19:38,320
we want to and we want to
track all these propagation's.

376
00:19:38,320 --> 00:19:41,740
So, we've performed the label injection

377
00:19:41,740 --> 00:19:43,880
in a recursive manner,

378
00:19:43,880 --> 00:19:46,930
that is, as shown in
the picture on the left,

379
00:19:46,930 --> 00:19:50,390
Lynx' will generate it into
three different inputs,

380
00:19:50,390 --> 00:19:54,540
by label injecting the original
test case in each time,

381
00:19:54,540 --> 00:19:57,643
Lynx' will inject the label
into different properties.

382
00:19:58,840 --> 00:20:00,260
After the injection,

383
00:20:00,260 --> 00:20:03,550
Lynx' will observe the program execution,

384
00:20:03,550 --> 00:20:05,430
will leverage our JavaScript,

385
00:20:05,430 --> 00:20:07,580
analyze its framework called julanky

386
00:20:07,580 --> 00:20:10,420
to instrument our test programs.

387
00:20:10,420 --> 00:20:12,640
Since we are studying the data flow,

388
00:20:12,640 --> 00:20:15,400
we instrument the
variable reads and writes,

389
00:20:15,400 --> 00:20:18,720
object property indexing
and function calls,

390
00:20:18,720 --> 00:20:21,030
then we executed the test program.

391
00:20:21,030 --> 00:20:22,300
During the execution

392
00:20:22,300 --> 00:20:26,060
Lynx' will examine area
objects within the data flow,

393
00:20:26,060 --> 00:20:29,870
if an object carriers our property labels,

394
00:20:29,870 --> 00:20:32,203
we will record it for further analysis.

395
00:20:33,860 --> 00:20:37,790
So, now we have a list
of property carriers,

396
00:20:37,790 --> 00:20:41,960
we call that an object is
flagged as a property carrier

397
00:20:41,960 --> 00:20:45,593
because we detect our injected
label under it's body.

398
00:20:46,610 --> 00:20:50,660
So, if we can propagate our label here,

399
00:20:50,660 --> 00:20:52,620
maybe we can also propagate

400
00:20:52,620 --> 00:20:56,500
another malicious property here also,

401
00:20:56,500 --> 00:21:00,110
more specifically, if
we can inject a property

402
00:21:00,110 --> 00:21:01,890
that has a conflicting name

403
00:21:01,890 --> 00:21:05,390
with certain internal
property the program has,

404
00:21:05,390 --> 00:21:09,193
maybe we can control that
property by overriding them.

405
00:21:11,330 --> 00:21:14,640
So, now we want to extract
all the child properties

406
00:21:14,640 --> 00:21:19,320
from the original programs
of the property carriers

407
00:21:19,320 --> 00:21:22,550
and flag them as hidden
property carry candidates.

408
00:21:22,550 --> 00:21:27,550
To achieve this goal, we
need static Syntax analyzer

409
00:21:28,160 --> 00:21:30,900
to extract the necessary
syntactic information

410
00:21:30,900 --> 00:21:32,260
from the code.

411
00:21:32,260 --> 00:21:34,370
The picture on the right demonstrate

412
00:21:34,370 --> 00:21:37,460
how we pass our statement
from our running example.

413
00:21:37,460 --> 00:21:40,150
Lynx' will traverse the Syntax Tree,

414
00:21:40,150 --> 00:21:42,510
until reaching a property carrier,

415
00:21:42,510 --> 00:21:45,670
which is circled by the
red line in the graph,

416
00:21:45,670 --> 00:21:49,810
then it will record all the
properties under the carrier.

417
00:21:49,810 --> 00:21:52,140
In our case, the hidden property candidate

418
00:21:52,140 --> 00:21:53,423
is the constructor.

419
00:21:55,730 --> 00:22:00,730
So, here is an output screenshot
of the first component.

420
00:22:01,610 --> 00:22:03,440
As you can observe,

421
00:22:03,440 --> 00:22:06,790
well, the Lynx' will first
instrument the code based,

422
00:22:06,790 --> 00:22:11,280
and then we tracked 43 property carriers.

423
00:22:11,280 --> 00:22:13,690
As indicated by the red circle

424
00:22:13,690 --> 00:22:15,350
Lynx' successfully detect

425
00:22:15,350 --> 00:22:17,513
our hidden property named constructor.

426
00:22:19,580 --> 00:22:21,780
So, in previous component,

427
00:22:21,780 --> 00:22:23,240
we discovered the key name

428
00:22:23,240 --> 00:22:25,520
of the potential hidden properties.

429
00:22:25,520 --> 00:22:28,220
By injecting the property
with the same key,

430
00:22:28,220 --> 00:22:31,240
we might override certain internal states.

431
00:22:31,240 --> 00:22:33,230
However, we still don't know

432
00:22:33,230 --> 00:22:36,230
whether the candidates
can be controlled or not.

433
00:22:36,230 --> 00:22:37,660
And we also don't know how

434
00:22:37,660 --> 00:22:41,380
to introduce attack effects
with these candidates.

435
00:22:41,380 --> 00:22:43,973
So apparently, Lynx' could do more.

436
00:22:46,000 --> 00:22:48,470
Let's revisit our running example

437
00:22:48,470 --> 00:22:50,720
to see if there is any insights

438
00:22:50,720 --> 00:22:53,963
to help us do the design such
a exploitation component.

439
00:22:54,800 --> 00:22:56,200
The figure on the left

440
00:22:56,200 --> 00:22:59,170
is the vulnerable codes
from our running example.

441
00:22:59,170 --> 00:23:01,350
As we have discussed many times,

442
00:23:01,350 --> 00:23:04,650
hidden property tampers
internal program states,

443
00:23:04,650 --> 00:23:06,890
which means HPA exploitation

444
00:23:06,890 --> 00:23:10,160
highly related to the code contacts.

445
00:23:10,160 --> 00:23:12,160
So, it is important to conclude

446
00:23:12,160 --> 00:23:15,410
our set of vulnerable sensitive behaviors.

447
00:23:15,410 --> 00:23:16,940
This behavior should

448
00:23:16,940 --> 00:23:20,150
clearly indicates certain
security consequences,

449
00:23:20,150 --> 00:23:21,570
so that we can decouple

450
00:23:21,570 --> 00:23:24,373
the harmful needs detected
from the code context.

451
00:23:25,330 --> 00:23:27,220
Also from the running example,

452
00:23:27,220 --> 00:23:28,620
the exploitation is mainly

453
00:23:28,620 --> 00:23:31,123
about manipulating the return result.

454
00:23:32,870 --> 00:23:36,830
More specifically, there are
two possible passes here.

455
00:23:36,830 --> 00:23:41,450
If the execution enter
the branch on line 19,

456
00:23:41,450 --> 00:23:43,520
we will get our validation failed,

457
00:23:43,520 --> 00:23:46,900
but if we can go into the line 21,

458
00:23:46,900 --> 00:23:49,023
we can successfully pass the check.

459
00:23:49,880 --> 00:23:54,150
So, the exploitation point
and the override point

460
00:23:54,150 --> 00:23:55,830
may not be the same place,

461
00:23:55,830 --> 00:24:00,130
which means we shouldn't
stop our analysis at line 11,

462
00:24:00,130 --> 00:24:04,290
instead we should continue
exploring all the possible passes

463
00:24:04,290 --> 00:24:07,453
that can be triggered by
manipulating the hidden properties.

464
00:24:08,890 --> 00:24:10,820
So, we studied and concluded

465
00:24:10,820 --> 00:24:13,173
six general type of sensitive things.

466
00:24:15,030 --> 00:24:17,140
Due to the time constraint,

467
00:24:17,140 --> 00:24:20,070
I will not introduce the
details of each types,

468
00:24:20,070 --> 00:24:23,253
if you want to know more,
you can check our Kit report.

469
00:24:25,310 --> 00:24:28,290
So, after defining our sensitive things,

470
00:24:28,290 --> 00:24:30,130
we want the hidden property

471
00:24:30,130 --> 00:24:33,690
to trigger as many as possible branches,

472
00:24:33,690 --> 00:24:36,480
and monitor whether we can hit a Sink.

473
00:24:36,480 --> 00:24:37,860
To achieve this goal,

474
00:24:37,860 --> 00:24:39,440
we use symbolic execution

475
00:24:39,440 --> 00:24:42,253
to explore all the hidden
property value space.

476
00:24:43,420 --> 00:24:46,090
Lynx', first the
generator exploit template

477
00:24:46,090 --> 00:24:50,100
that can reach the potential
hidden vulnerable property.

478
00:24:50,100 --> 00:24:54,100
We did not such state a
structure as our exploit template

479
00:24:54,100 --> 00:24:59,100
because Lynx' does not specify
a concrete value in the input

480
00:25:01,220 --> 00:25:04,732
instead we insert a special placeholder

481
00:25:04,732 --> 00:25:09,110
which will be used by the
symbolic execution later on,

482
00:25:09,110 --> 00:25:13,363
then we run the test program
with our constructed templates,

483
00:25:14,210 --> 00:25:18,040
and then symbolically
excluding the hidden property.

484
00:25:18,040 --> 00:25:19,780
As shown in the picture,

485
00:25:19,780 --> 00:25:21,180
the Lynx' will explore

486
00:25:21,180 --> 00:25:25,950
all the past constraint
along the input paths,

487
00:25:25,950 --> 00:25:30,950
and if Lynx' found that it has sync...

488
00:25:31,720 --> 00:25:33,480
For example, in this example,

489
00:25:33,480 --> 00:25:35,163
either he hit the Sink I2,

490
00:25:36,010 --> 00:25:38,880
then, he will fetch the
corresponding payload

491
00:25:38,880 --> 00:25:43,880
that can trigger the Sink
as the final exploit.

492
00:25:44,160 --> 00:25:47,040
So, a little background about the Sink I2

493
00:25:47,040 --> 00:25:49,300
is the Sink we defined to detect

494
00:25:49,300 --> 00:25:52,710
that whether our input can manipulate

495
00:25:52,710 --> 00:25:55,053
the return value of a module or not.

496
00:25:58,050 --> 00:26:01,750
So, this is the output of exploit module.

497
00:26:01,750 --> 00:26:03,260
From the circled area,

498
00:26:03,260 --> 00:26:07,710
we can observe that the key
value pair, constructor in one,

499
00:26:07,710 --> 00:26:09,083
trigger the same Sink I2.

500
00:26:10,050 --> 00:26:11,230
In the last line,

501
00:26:11,230 --> 00:26:12,820
we can find that the Lynx'

502
00:26:12,820 --> 00:26:15,870
successfully bypassed generate exploit

503
00:26:15,870 --> 00:26:18,993
that can lead to the
successful validation.

504
00:26:19,880 --> 00:26:23,120
So this is pretty much
about how our system work.

505
00:26:23,120 --> 00:26:26,563
Let's see some interesting new
results about our research.

506
00:26:27,690 --> 00:26:28,860
During our research,

507
00:26:28,860 --> 00:26:32,743
we choose 60 widely used
programs for our NPM,

508
00:26:32,743 --> 00:26:36,920
they're 55 modules and
five web applications,

509
00:26:36,920 --> 00:26:38,840
and with the help of Lynx',

510
00:26:38,840 --> 00:26:42,840
we tracked more than 1,300 carriers,

511
00:26:42,840 --> 00:26:46,680
and detected more than 300
hidden property candidates

512
00:26:46,680 --> 00:26:49,470
associated with those carriers.

513
00:26:49,470 --> 00:26:53,682
In the end, we confirmed 13
zero-day vulnerabilities.

514
00:26:53,682 --> 00:26:55,850
With the help of symbolic execution,

515
00:26:55,850 --> 00:26:58,973
Lynx even synthesized 10
exploits automatically.

516
00:27:00,840 --> 00:27:03,810
So, how is the impact of
this one vulnerabilities?

517
00:27:03,810 --> 00:27:07,490
We found that HPA can introduce
various attack effects,

518
00:27:07,490 --> 00:27:10,520
such as leaking credential data's,

519
00:27:10,520 --> 00:27:14,563
denial of services or
bypassing the security checks.

520
00:27:15,520 --> 00:27:17,380
Based on the impact analysis,

521
00:27:17,380 --> 00:27:18,550
we can observe that

522
00:27:18,550 --> 00:27:20,180
the HPA can compromise

523
00:27:20,180 --> 00:27:22,720
previously unreachable program states,

524
00:27:22,720 --> 00:27:26,223
which effectively enlarges
the attack surface.

525
00:27:27,200 --> 00:27:29,080
Even more, we have noticed that

526
00:27:29,080 --> 00:27:32,340
HPA is not a simple
input validation issue,

527
00:27:32,340 --> 00:27:35,653
and many inputs validated
themselves also vulnerable HPA.

528
00:27:37,550 --> 00:27:39,330
So, in the following slides,

529
00:27:39,330 --> 00:27:41,950
I will pick up two
interesting vulnerabilities

530
00:27:41,950 --> 00:27:44,683
from our result, and case studying them.

531
00:27:46,410 --> 00:27:50,130
So, the first case comes
from MongoDB official driver,

532
00:27:50,130 --> 00:27:51,530
we found that we can tamper

533
00:27:51,530 --> 00:27:54,103
our internal state named the bsontype.

534
00:27:55,340 --> 00:27:57,320
Our background here is that bson,

535
00:27:57,320 --> 00:28:00,575
or the MongoDB leverage
the internal state bsontype

536
00:28:00,575 --> 00:28:05,340
to indicate the data
type of the query object.

537
00:28:05,340 --> 00:28:08,470
However, when serializing
the query object,

538
00:28:08,470 --> 00:28:12,423
MongoDB will ignore the
object with unknown bsontype.

539
00:28:13,270 --> 00:28:17,963
So, what if we abuse the logic
for query condition object?

540
00:28:18,840 --> 00:28:22,550
The code on the right is
for open source online game,

541
00:28:22,550 --> 00:28:24,680
the online game use a vulnerable API

542
00:28:24,680 --> 00:28:27,640
to implement the user management logics.

543
00:28:27,640 --> 00:28:28,950
As shown in the picture

544
00:28:28,950 --> 00:28:32,600
by injecting the unknown
bsontype to the input,

545
00:28:32,600 --> 00:28:35,370
the attacker can force the
MongoDB not serializing

546
00:28:35,370 --> 00:28:37,140
the query condition,

547
00:28:37,140 --> 00:28:39,820
so that the MongoDB will always return

548
00:28:39,820 --> 00:28:43,040
to the first use on top of the database.

549
00:28:43,040 --> 00:28:45,960
With this ability, the attacker can log in

550
00:28:45,960 --> 00:28:50,793
or delete arbitrary accounts.

551
00:28:53,170 --> 00:28:54,040
The second case,

552
00:28:54,040 --> 00:28:57,320
is from another widely
used memory database.

553
00:28:57,320 --> 00:28:59,870
The hidden property is
more like a backdoor

554
00:28:59,870 --> 00:29:03,510
which helps the user
accessing the sensitive data.

555
00:29:03,510 --> 00:29:07,603
So in taffyDB, we discover
a hidden property named ID,

556
00:29:08,520 --> 00:29:13,520
which is an internal index
for each database data item.

557
00:29:14,050 --> 00:29:17,100
Once we specify our own ID in the query,

558
00:29:17,100 --> 00:29:19,920
taffyDB will ignore other query condition

559
00:29:19,920 --> 00:29:24,730
and directly return the result
associated with the index.

560
00:29:24,730 --> 00:29:26,380
So as shown in the picture,

561
00:29:26,380 --> 00:29:29,520
even though we got wrong
password and username,

562
00:29:29,520 --> 00:29:32,140
we can still leak the data from...

563
00:29:32,140 --> 00:29:35,380
validate the user data from the database

564
00:29:35,380 --> 00:29:38,200
with our crafted hidden properties.

565
00:29:38,200 --> 00:29:40,750
Okay, so thanks for attending our talk.

566
00:29:40,750 --> 00:29:43,463
I hope you guys keep safe
in this special year.

