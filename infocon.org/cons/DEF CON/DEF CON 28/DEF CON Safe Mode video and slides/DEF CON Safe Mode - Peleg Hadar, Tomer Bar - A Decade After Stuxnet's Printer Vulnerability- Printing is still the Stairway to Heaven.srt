1
00:00:00,900 --> 00:00:02,320
- Hi, thank you for joining our talk,

2
00:00:02,320 --> 00:00:05,376
A Decade After Stuxnet's
Printing Vulnerability,

3
00:00:05,376 --> 00:00:07,870
Printing is still the Stairway to Heaven.

4
00:00:07,870 --> 00:00:09,520
First, let's introduce ourselves.

5
00:00:10,980 --> 00:00:12,380
My name is Peleg Hadar,

6
00:00:12,380 --> 00:00:14,840
I'm in the InfoSec field
for more than seven years.

7
00:00:14,840 --> 00:00:16,910
Currently working as the
senior security researcher

8
00:00:16,910 --> 00:00:18,660
at SafeBreach Labs.

9
00:00:18,660 --> 00:00:20,410
My main focus is on Windows internals

10
00:00:20,410 --> 00:00:21,793
and vulnerability research.

11
00:00:24,740 --> 00:00:27,270
- Hi, my name is Tomer Bar.

12
00:00:27,270 --> 00:00:29,760
I'm in the InfoSec field
for more than 15 years.

13
00:00:29,760 --> 00:00:32,450
Currently working as
a research team leader

14
00:00:32,450 --> 00:00:33,840
at SafeBreach Labs.

15
00:00:33,840 --> 00:00:36,140
My main focus is on APT research,

16
00:00:36,140 --> 00:00:39,483
Windows internals, and
vulnerability research.

17
00:00:44,550 --> 00:00:47,330
In this presentation, we
will cover the following.

18
00:00:47,330 --> 00:00:49,843
We will demonstrate our (indistinct)

19
00:00:49,843 --> 00:00:53,687
vulnerability to build the
propagation parts of Stuxnet 2.0.

20
00:00:54,936 --> 00:00:58,080
We will do that by walk
through on the vulnerabilities,

21
00:00:58,080 --> 00:01:00,100
which were used by Stuxnet.

22
00:01:00,100 --> 00:01:03,400
For each one, we will
describe the root cause,

23
00:01:03,400 --> 00:01:05,180
describe the patch,

24
00:01:05,180 --> 00:01:07,380
and evaluate the
effectiveness of the patch.

25
00:01:09,150 --> 00:01:11,160
We will continue with
the deep walk through

26
00:01:11,160 --> 00:01:14,020
of our print spooler research findings,

27
00:01:14,020 --> 00:01:16,070
including demos of the tool (indistinct).

28
00:01:17,220 --> 00:01:19,570
Finally, we will suggest a new mitigation

29
00:01:19,570 --> 00:01:22,403
for the entire arbitrary
file write bug class.

30
00:01:23,430 --> 00:01:27,350
We will be focused on answering
two fundamental questions.

31
00:01:27,350 --> 00:01:30,200
Is it possible to build equivalent
propagation capabilities

32
00:01:30,200 --> 00:01:32,010
as Stuxnet capabilities?

33
00:01:32,010 --> 00:01:33,290
Second question,

34
00:01:33,290 --> 00:01:36,290
if I fully patch my entire
Windows operating system,

35
00:01:36,290 --> 00:01:37,297
am I safe now?

36
00:01:38,860 --> 00:01:40,530
Last note before we start,

37
00:01:40,530 --> 00:01:43,600
we will use two symbols
during our presentation.

38
00:01:43,600 --> 00:01:45,970
A narrow patch means that the patch logic

39
00:01:45,970 --> 00:01:49,750
is very specific and it was
possible to re-exploit it.

40
00:01:49,750 --> 00:01:50,970
And secondly,

41
00:01:50,970 --> 00:01:54,440
a regular patch means
that it solved the problem

42
00:01:54,440 --> 00:01:57,030
and had not been bypassed until nowadays.

43
00:01:57,030 --> 00:02:00,230
As much as we know, now that we ready,

44
00:02:00,230 --> 00:02:02,630
let's see the recap and
the timeline of Stuxnet.

45
00:02:04,840 --> 00:02:07,130
Stuxnet is considered by many

46
00:02:07,130 --> 00:02:08,750
to be one of the most complex

47
00:02:08,750 --> 00:02:11,950
and well engineered
computer worms ever seen.

48
00:02:11,950 --> 00:02:15,650
It is believed that the
project was developed in 2006

49
00:02:15,650 --> 00:02:19,010
and lasted four years
until it was discovered.

50
00:02:19,010 --> 00:02:23,320
Stuxnet can be described by
the following three parts.

51
00:02:23,320 --> 00:02:26,220
The first part is the
propagation to the target network

52
00:02:26,220 --> 00:02:29,980
by using three remote
code execution exploits,

53
00:02:29,980 --> 00:02:33,490
and two local privilege
escalation exploits.

54
00:02:33,490 --> 00:02:36,590
The next part is the
special evasion techniques,

55
00:02:36,590 --> 00:02:41,030
which allows Stuxnet to
operate under the radar.

56
00:02:41,030 --> 00:02:43,530
The third part is the final payload

57
00:02:43,530 --> 00:02:45,787
delivering specifically to Siemens PoC.

58
00:02:46,979 --> 00:02:49,815
In our opinion, a decade after Stuxnet,

59
00:02:49,815 --> 00:02:53,510
the most interesting part is
the propagation capabilities,

60
00:02:53,510 --> 00:02:56,557
which is still relevant to
almost any targeted attack.

61
00:02:59,280 --> 00:03:03,080
Let's zoom in into Stuxnet
propagation capabilities.

62
00:03:03,080 --> 00:03:04,803
We will describe them one by one.

63
00:03:05,660 --> 00:03:07,260
Although it was a decade ago,

64
00:03:07,260 --> 00:03:09,020
it's still relevant to all of us

65
00:03:09,020 --> 00:03:12,504
because according to a
research posted in 2017,

66
00:03:12,504 --> 00:03:16,170
those capabilities were
used widely after Stuxnet,

67
00:03:16,170 --> 00:03:19,940
for attacking a wide
range of organization.

68
00:03:19,940 --> 00:03:21,400
Let's dive deeper.

69
00:03:21,400 --> 00:03:22,513
Heading over to Peleg.

70
00:03:25,220 --> 00:03:26,810
- Thank you, Tomer.

71
00:03:26,810 --> 00:03:27,970
So let's start in talking about

72
00:03:27,970 --> 00:03:29,150
the early propagation capability,

73
00:03:29,150 --> 00:03:31,100
which was used by Stuxnet.

74
00:03:31,100 --> 00:03:33,650
It used it to spread via
weaponized USB flash drive,

75
00:03:33,650 --> 00:03:35,770
traveling between
internet facing computers

76
00:03:35,770 --> 00:03:37,320
and internal network computers.

77
00:03:43,550 --> 00:03:46,090
So the attack vector contained
the crafted LNK file,

78
00:03:46,090 --> 00:03:47,690
which is a shorter file.

79
00:03:47,690 --> 00:03:49,970
Once it was displayed, an arbitrary DLL,

80
00:03:49,970 --> 00:03:53,110
which was specified as
the icon file of the LNK,

81
00:03:53,110 --> 00:03:54,073
was executed.

82
00:03:57,040 --> 00:03:58,910
Here's a screenshot of a crafted LNK file,

83
00:03:58,910 --> 00:04:00,970
which exploited the vulnerability.

84
00:04:00,970 --> 00:04:04,170
You can observe that the LNK
file contains the following.

85
00:04:04,170 --> 00:04:08,379
The path of the CPL external
file and the icon ID, zero,

86
00:04:08,379 --> 00:04:11,395
which caused the code to
trigger the execution of the DLL

87
00:04:11,395 --> 00:04:13,853
every time the LNK file was displayed.

88
00:04:16,730 --> 00:04:18,620
So let's take a look at
the exploitation path

89
00:04:18,620 --> 00:04:19,783
and how it was patched.

90
00:04:21,050 --> 00:04:22,990
The main problem was
that instead of loading

91
00:04:22,990 --> 00:04:25,316
the DLL file as a data only file,

92
00:04:25,316 --> 00:04:27,800
by using load library X,

93
00:04:27,800 --> 00:04:30,610
the code actually called
the load library W function,

94
00:04:30,610 --> 00:04:32,503
and also executed the data.

95
00:04:33,360 --> 00:04:35,280
We expected the patch to replace this call

96
00:04:35,280 --> 00:04:36,900
in order to avoid execution,

97
00:04:36,900 --> 00:04:39,000
but let's see what was actually happening.

98
00:04:41,310 --> 00:04:42,830
So the patch had two validations

99
00:04:42,830 --> 00:04:44,840
in order to mitigate the vulnerability.

100
00:04:44,840 --> 00:04:47,620
First, it checked that
the provided CPL file

101
00:04:47,620 --> 00:04:50,520
was a Microsoft's white list
and was allowed to be loaded.

102
00:04:51,550 --> 00:04:54,290
Next, the icon ID, which
would be controlled,

103
00:04:54,290 --> 00:04:57,820
would have been extracted
and converted from a string.

104
00:04:57,820 --> 00:04:59,209
If the ID was zero,

105
00:04:59,209 --> 00:05:01,140
it will overwrite the zero with minus one,

106
00:05:01,140 --> 00:05:02,763
meaning, it wouldn't be loaded.

107
00:05:05,000 --> 00:05:06,900
The patch was very specific,

108
00:05:06,900 --> 00:05:08,110
because as you can see,

109
00:05:08,110 --> 00:05:10,620
the load library function still existed.

110
00:05:10,620 --> 00:05:12,500
Meaning that if someone
would have been able

111
00:05:12,500 --> 00:05:14,080
to bypass the validations,

112
00:05:14,080 --> 00:05:15,993
then the CPL could have been executed.

113
00:05:18,953 --> 00:05:22,283
So let's see the bypass, which
was patched five years later.

114
00:05:25,690 --> 00:05:27,360
In order to bypass the patch,

115
00:05:27,360 --> 00:05:29,150
we need to bypass the icon ID check

116
00:05:29,150 --> 00:05:30,813
and transform it to zero.

117
00:05:32,170 --> 00:05:34,880
It can be done if you will be
able to send the minus sign

118
00:05:34,880 --> 00:05:37,563
as a parameter to StrTointW function.

119
00:05:38,550 --> 00:05:40,323
Let's see exactly how it was done.

120
00:05:41,210 --> 00:05:42,500
Because of a type confusion

121
00:05:42,500 --> 00:05:45,010
between a white call
buffer and a call buffer,

122
00:05:45,010 --> 00:05:47,473
the original icon ID string was truncated.

123
00:05:49,500 --> 00:05:52,410
We can exploit it by providing
a long enough buffer.

124
00:05:52,410 --> 00:05:54,663
So the icon ID will turn
into the minus sign.

125
00:05:55,500 --> 00:05:58,500
Once StrTointW return zero as the icon ID,

126
00:05:58,500 --> 00:06:00,703
our arbitrary CPL will be executed.

127
00:06:04,880 --> 00:06:07,540
The path for this one was pretty simple.

128
00:06:07,540 --> 00:06:09,090
The truncation bug was removed.

129
00:06:10,030 --> 00:06:11,260
The call to load library,

130
00:06:11,260 --> 00:06:14,420
which was the actual root
cause wasn't changed.

131
00:06:14,420 --> 00:06:15,870
That means that if there's another way

132
00:06:15,870 --> 00:06:18,130
to trigger the load CPL module function,

133
00:06:18,130 --> 00:06:20,483
it would have been still vulnerable.

134
00:06:23,160 --> 00:06:24,876
And apparently, there was.

135
00:06:24,876 --> 00:06:26,195
Three years later,

136
00:06:26,195 --> 00:06:28,673
a new vulnerability was
discovered and patched.

137
00:06:29,580 --> 00:06:31,670
It's called the Load CPL Module function

138
00:06:31,670 --> 00:06:33,550
by using another exploitation path,

139
00:06:33,550 --> 00:06:34,833
which was left unpatched.

140
00:06:38,289 --> 00:06:39,122
So the path for this one

141
00:06:39,122 --> 00:06:41,923
was adding the previous
logic of a CPL white list.

142
00:06:43,170 --> 00:06:46,113
But load library still was not replaced.

143
00:06:48,820 --> 00:06:51,120
What's interesting here
is that we have noticed

144
00:06:51,120 --> 00:06:54,140
that there is another left
path to load Library function

145
00:06:54,140 --> 00:06:57,373
But we haven't seen any
disclosed vulnerability yet.

146
00:07:00,550 --> 00:07:03,460
So moving to the next
propagation capability,

147
00:07:03,460 --> 00:07:06,870
next, we will talk about the
Stuxnet RPC vulnerability.

148
00:07:06,870 --> 00:07:07,970
Handing over to Tomer.

149
00:07:12,337 --> 00:07:14,170
- Thanks, Peleg.

150
00:07:14,170 --> 00:07:18,230
On 2006, three years before
Stuxnet's first worm infection,

151
00:07:18,230 --> 00:07:22,330
a new worm RPC vulnerability
was discovered and patched.

152
00:07:22,330 --> 00:07:23,570
According to Microsoft,

153
00:07:23,570 --> 00:07:26,440
it was a very limited
scope attack back then,

154
00:07:26,440 --> 00:07:29,724
but later on, a very
similar exploitation path

155
00:07:29,724 --> 00:07:33,230
was used by both Stuxnet
and Conficker Worm,

156
00:07:33,230 --> 00:07:37,090
which became one of the most
spreadable worm ever seen.

157
00:07:37,090 --> 00:07:39,490
RPC vulnerabilities were the main cause

158
00:07:39,490 --> 00:07:42,590
of global computer worms since 2003.

159
00:07:42,590 --> 00:07:44,380
Remember Blaster.

160
00:07:44,380 --> 00:07:46,830
So it's obvious that the
cost of vulnerability

161
00:07:46,830 --> 00:07:48,840
in this mechanism is huge.

162
00:07:48,840 --> 00:07:51,140
Let's dive into the specific details.

163
00:07:51,140 --> 00:07:52,820
The RPC vulnerability root cause

164
00:07:52,820 --> 00:07:55,710
that we will present is
due to a canonical path.

165
00:07:55,710 --> 00:07:58,240
So let's understand what
is it, a canonical path.

166
00:07:58,240 --> 00:07:59,890
It's actually a pretty simple.

167
00:07:59,890 --> 00:08:01,300
Let's get an absolute path

168
00:08:01,300 --> 00:08:03,700
and convert it to the
shortest absolute path.

169
00:08:03,700 --> 00:08:05,620
In the meaning of string length.

170
00:08:05,620 --> 00:08:07,910
The most common usage of a canonical path

171
00:08:07,910 --> 00:08:11,510
is for textual comparison of
two different representation

172
00:08:11,510 --> 00:08:13,003
of the same canonical path.

173
00:08:15,610 --> 00:08:18,710
The original vulnerability
was a type confusion,

174
00:08:18,710 --> 00:08:22,310
which lead to a classic
stack-based buffer overflow.

175
00:08:22,310 --> 00:08:25,010
The vulnerable function
was copying a buffer,

176
00:08:25,010 --> 00:08:28,793
which exceed the allocated
buffer causing memory corruption.

177
00:08:30,080 --> 00:08:32,270
Here's the exploitation path.

178
00:08:32,270 --> 00:08:35,680
RPC request triggered the
vulnerable function remotely,

179
00:08:35,680 --> 00:08:37,732
which lead to an Out Of Band write

180
00:08:37,732 --> 00:08:40,263
caused by WCS cat function.

181
00:08:41,150 --> 00:08:45,810
Please notice the RPC
functions name, NetpW.

182
00:08:45,810 --> 00:08:48,763
We will explain why it's
important in the following slides.

183
00:08:50,910 --> 00:08:53,570
The patch and the proper buffer check.

184
00:08:53,570 --> 00:08:57,913
which eliminated the original
buffer overflow vulnerability.

185
00:08:57,913 --> 00:09:00,970
Two years later, a newer
vulnerability was discovered

186
00:09:00,970 --> 00:09:03,380
in the same expectation path.

187
00:09:03,380 --> 00:09:07,030
This time, it was discovered
in the RPC wrapper function,

188
00:09:07,030 --> 00:09:08,503
which is called Netpr.

189
00:09:09,400 --> 00:09:10,770
This function caused

190
00:09:10,770 --> 00:09:13,040
the original vulnerable function directly.

191
00:09:13,040 --> 00:09:15,240
Remember NetpW?

192
00:09:15,240 --> 00:09:16,833
Let's dive into the root cause.

193
00:09:18,090 --> 00:09:19,930
So the root cause of the vulnerability

194
00:09:19,930 --> 00:09:24,600
is that the input path
includes most /../cause

195
00:09:24,600 --> 00:09:27,590
then the number of
prior directory entries.

196
00:09:27,590 --> 00:09:29,811
This will result in gaining a control

197
00:09:29,811 --> 00:09:32,470
over the output buffer pointer,

198
00:09:32,470 --> 00:09:34,460
which will point backwards on the stack,

199
00:09:34,460 --> 00:09:36,900
and will trigger Out of Band writing

200
00:09:36,900 --> 00:09:39,713
after calling the WCS copy this time.

201
00:09:41,600 --> 00:09:46,600
So the patch MS08-067
replaced the WCS copy function

202
00:09:47,590 --> 00:09:50,513
with a safer function,
String Copy Worker W.

203
00:09:52,620 --> 00:09:55,443
Let's dive into Stuxnet's
task scheduler vulnerability.

204
00:09:56,490 --> 00:10:00,110
But first, let's understand
how the task scheduler worked.

205
00:10:00,110 --> 00:10:04,390
Task scheduler job XML file
contains the metadata of a job,

206
00:10:04,390 --> 00:10:07,090
including which user will execute the job.

207
00:10:07,090 --> 00:10:11,240
The folder, which contains
it is writeable by all users.

208
00:10:11,240 --> 00:10:14,350
To protect the integrity
of the job figuration files

209
00:10:14,350 --> 00:10:16,460
and prevent user from modifying them,

210
00:10:16,460 --> 00:10:20,010
task scheduler calculated
a CRC 32 checksum

211
00:10:20,010 --> 00:10:22,450
on each created task XML.

212
00:10:22,450 --> 00:10:24,380
When it's time to start the job,

213
00:10:24,380 --> 00:10:27,490
task scheduler recalculated
the XML checksum

214
00:10:27,490 --> 00:10:29,740
and compare it to the original value.

215
00:10:29,740 --> 00:10:31,923
If they matched, the job executed,

216
00:10:33,240 --> 00:10:35,360
if not, it would have been ignored.

217
00:10:35,360 --> 00:10:38,160
The CRC 32 algorithm is collision prone,

218
00:10:38,160 --> 00:10:39,710
which may lead to data forgery.

219
00:10:40,550 --> 00:10:42,600
Stuxnet (indistinct) exploited this fact

220
00:10:42,600 --> 00:10:46,150
by forging an XML file of a job,

221
00:10:46,150 --> 00:10:49,300
which was executed as
anti-authority system.

222
00:10:49,300 --> 00:10:51,660
With added custom CRC 32 checksum,

223
00:10:51,660 --> 00:10:54,541
which was identical to
the original task XML,

224
00:10:54,541 --> 00:10:58,170
therefore, it was being executed as system

225
00:10:58,170 --> 00:11:00,463
resulting in a local privilege escalation.

226
00:11:01,630 --> 00:11:03,510
In the patch, MS10-092,

227
00:11:03,510 --> 00:11:06,590
Microsoft implemented a
second integrity check

228
00:11:06,590 --> 00:11:09,410
by using the SHA-256 algorithm,

229
00:11:09,410 --> 00:11:11,740
implemented by the ComputeHash function,

230
00:11:11,740 --> 00:11:13,240
which is less collision prone.

231
00:11:14,610 --> 00:11:16,590
Moving forward, nine years later,

232
00:11:16,590 --> 00:11:19,580
a newer task scheduler
vulnerability was found.

233
00:11:19,580 --> 00:11:22,530
The vulnerability abused the
backward compatibility feature

234
00:11:22,530 --> 00:11:24,670
of the task scheduler mechanism,

235
00:11:24,670 --> 00:11:28,080
which provides the option
of migrating all tasks

236
00:11:28,080 --> 00:11:31,524
from C Windows task folder
to the new task folder,

237
00:11:31,524 --> 00:11:34,700
which is System 32 Tasks.

238
00:11:34,700 --> 00:11:35,950
In order to exploit it,

239
00:11:35,950 --> 00:11:39,700
the attacker would need to
reform the following four steps.

240
00:11:39,700 --> 00:11:42,290
Step one, create a new job.

241
00:11:42,290 --> 00:11:45,260
As a result, an XML file would be created

242
00:11:45,260 --> 00:11:46,980
in the new tasks folder.

243
00:11:46,980 --> 00:11:49,520
Step two, overwrite the job file

244
00:11:49,520 --> 00:11:52,580
in the legacy task folder with an out link

245
00:11:52,580 --> 00:11:55,030
to the file which the
attacker wishes to control.

246
00:11:55,924 --> 00:12:00,924
Third step is creating a new
legacy task with the same name.

247
00:12:01,460 --> 00:12:06,260
And finally, trigger an ultra
new task integration of RPC.

248
00:12:06,260 --> 00:12:08,770
As a result, the task scheduler service

249
00:12:08,770 --> 00:12:11,730
would update the security
information of the file,

250
00:12:11,730 --> 00:12:13,750
which the attacker wishes to control,

251
00:12:13,750 --> 00:12:16,463
granting the attacker full
control privileges on it.

252
00:12:17,550 --> 00:12:20,950
The attacker can now replace,
or write to any file,

253
00:12:20,950 --> 00:12:22,800
gaining a local privilege escalation.

254
00:12:26,000 --> 00:12:29,170
So this is the exploitation
path that was used.

255
00:12:29,170 --> 00:12:31,183
Let's see how Microsoft patched it.

256
00:12:32,730 --> 00:12:36,197
The patch make sure that the
file is not a symbolic thing,

257
00:12:36,197 --> 00:12:38,466
but using two different checks.

258
00:12:38,466 --> 00:12:41,150
The file check verify that original path

259
00:12:41,150 --> 00:12:43,790
is the final path of the file.

260
00:12:43,790 --> 00:12:44,710
If it's different,

261
00:12:44,710 --> 00:12:48,093
it's means that it was
redirected by symbolical link.

262
00:12:48,093 --> 00:12:48,926
And the second check,

263
00:12:48,926 --> 00:12:51,710
verify that the number
of the files NTFS links

264
00:12:51,710 --> 00:12:53,107
is not bigger than one.

265
00:12:56,530 --> 00:12:58,570
Okay, so let's see the
fourth vulnerability.

266
00:12:58,570 --> 00:13:00,293
Moving over to Win32k.

267
00:13:04,060 --> 00:13:06,660
Actually, there were dozens of Win32k

268
00:13:06,660 --> 00:13:09,060
local privilege escalation vulnerabilities

269
00:13:09,060 --> 00:13:10,740
over the last decade.

270
00:13:10,740 --> 00:13:13,750
Here's the list of
several options from 2020,

271
00:13:13,750 --> 00:13:15,390
which can replace the original

272
00:13:15,390 --> 00:13:17,200
already patched vulnerability.

273
00:13:17,200 --> 00:13:19,489
In order to rebuild the Stuxnet 2.0

274
00:13:19,489 --> 00:13:20,563
propagation capabilities port.

275
00:13:23,450 --> 00:13:25,240
The only capability which remained

276
00:13:25,240 --> 00:13:26,990
is the print spooler vulnerability.

277
00:13:31,450 --> 00:13:32,440
Let's start to talk about

278
00:13:32,440 --> 00:13:34,973
our printer spooler research and findings.

279
00:13:36,800 --> 00:13:39,230
We will start by presenting how we found

280
00:13:39,230 --> 00:13:43,433
a 20 plus year old bug by
using 20 minutes of fuzzing.

281
00:13:44,730 --> 00:13:47,730
We have noticed that each time
a print job is being created,

282
00:13:47,730 --> 00:13:50,300
it's represented by two files.

283
00:13:50,300 --> 00:13:52,109
First, an SPL file,

284
00:13:52,109 --> 00:13:55,710
which is simply, contains
the data to be printed.

285
00:13:55,710 --> 00:14:00,060
Second, an SHD file, shadow
file, which we focused.

286
00:14:00,060 --> 00:14:03,310
It's represented by the
undocumented shadow file stock

287
00:14:03,310 --> 00:14:06,710
and contains the metadata
of the print job.

288
00:14:06,710 --> 00:14:09,950
For example, printer
name, printer port name,

289
00:14:09,950 --> 00:14:12,480
document name, and et cetera.

290
00:14:12,480 --> 00:14:15,220
We found that the printers folder,

291
00:14:15,220 --> 00:14:19,483
which contains the SHD files
is writeable by all user,

292
00:14:20,510 --> 00:14:23,830
and that the SHD files are being processed

293
00:14:23,830 --> 00:14:25,230
once the service is started.

294
00:14:26,090 --> 00:14:28,020
So we ask ourselves,

295
00:14:28,020 --> 00:14:31,360
what will happen if we'll
craft our own SHD file?

296
00:14:31,360 --> 00:14:35,303
So we started to mutate the
SHD files and fuzz the service.

297
00:14:37,720 --> 00:14:39,150
After 20 minutes of fuzzing,

298
00:14:39,150 --> 00:14:41,190
we had our first crash.

299
00:14:41,190 --> 00:14:44,400
We have managed to crash
the print spooler service

300
00:14:44,400 --> 00:14:49,090
by using a limited user
and a crafted SHD file.

301
00:14:49,090 --> 00:14:51,110
It's appeared that the code was trying

302
00:14:51,110 --> 00:14:53,043
to de-reference some part of our data.

303
00:14:54,060 --> 00:14:57,780
It's written it as a pointer
to a security descriptor

304
00:14:57,780 --> 00:15:01,210
without any validation or
sensitization of the data,

305
00:15:01,210 --> 00:15:03,900
we've provided in the SHD file.

306
00:15:03,900 --> 00:15:06,340
Microsoft did not fix this bug.

307
00:15:06,340 --> 00:15:09,560
We would show the response
in the end of our talk.

308
00:15:09,560 --> 00:15:10,870
Okay, demo time.

309
00:15:10,870 --> 00:15:12,400
Let's see a demo of the crash

310
00:15:12,400 --> 00:15:14,453
in the latest Windows 10 side of it.

311
00:15:16,780 --> 00:15:20,060
So on the left side,
Johnny is a limited user.

312
00:15:20,060 --> 00:15:22,880
We can say that we are running
on the latest Windows 10

313
00:15:22,880 --> 00:15:24,310
fully patched machine.

314
00:15:24,310 --> 00:15:27,590
On the right, the user,
John, is administrator

315
00:15:27,590 --> 00:15:29,390
and is used only for convenience

316
00:15:29,390 --> 00:15:31,240
to avoid restarts of the OS,

317
00:15:31,240 --> 00:15:32,610
instead we'll restart the service

318
00:15:32,610 --> 00:15:34,230
to trigger the vulnerability.

319
00:15:34,230 --> 00:15:39,197
So we are copying the crafted SHD file

320
00:15:40,045 --> 00:15:41,793
to the printer spooler directly.

321
00:15:52,160 --> 00:15:54,770
Now, we will trigger the vulnerability

322
00:15:54,770 --> 00:15:57,763
by restarting the service,

323
00:16:05,450 --> 00:16:07,240
and listing the printers

324
00:16:09,410 --> 00:16:10,610
by (indistinct) command.

325
00:16:18,270 --> 00:16:21,223
As we can see in (indistinct)
we crash the service.

326
00:16:24,983 --> 00:16:26,983
- Handing over to Peleg.

327
00:16:29,940 --> 00:16:31,200
- Thank you, Tomer.

328
00:16:31,200 --> 00:16:33,843
So the crash was cool, but we wanted more.

329
00:16:33,843 --> 00:16:37,080
Let's talk on how we got local
privilege escalation twice.

330
00:16:37,080 --> 00:16:38,573
One of them is still 0-day.

331
00:16:40,630 --> 00:16:43,230
So in order to understand the
next vulnerabilities we found,

332
00:16:43,230 --> 00:16:46,772
we will dive into the printing
process in the Windows OS.

333
00:16:46,772 --> 00:16:49,470
The Print Spooler is the
service, which is responsible

334
00:16:49,470 --> 00:16:52,870
for creating and handling
printers in the Windows OS.

335
00:16:52,870 --> 00:16:55,860
Accessing the print spooler
is possible remotely.

336
00:16:55,860 --> 00:16:59,680
For example, using a
shelf printer and locally.

337
00:16:59,680 --> 00:17:01,440
We'll focus on the local scenario.

338
00:17:01,440 --> 00:17:03,580
More specifically, we
will focus on the fact

339
00:17:03,580 --> 00:17:06,530
that spooler allows the
user to print a file

340
00:17:06,530 --> 00:17:07,883
by using a virtual printer.

341
00:17:08,840 --> 00:17:10,030
This is an important part,

342
00:17:10,030 --> 00:17:14,810
which our folders largely rely on.

343
00:17:14,810 --> 00:17:18,130
A quick brief on the flow of
printing to a file scenario.

344
00:17:18,130 --> 00:17:19,780
First, the user sends some data

345
00:17:19,780 --> 00:17:21,950
to be printed using an application,

346
00:17:21,950 --> 00:17:23,143
for example, Notepad,

347
00:17:23,143 --> 00:17:26,223
and specifies which file
he would like to print to.

348
00:17:27,411 --> 00:17:29,690
It means that the data will be printed,

349
00:17:29,690 --> 00:17:31,170
which means it will be written to a file

350
00:17:31,170 --> 00:17:32,600
using a virtual printer

351
00:17:32,600 --> 00:17:34,160
instead of printing...

352
00:17:34,160 --> 00:17:36,273
instead of printed to a real printer.

353
00:17:37,300 --> 00:17:39,950
The spooler service, Spoolsv.exe,

354
00:17:39,950 --> 00:17:42,513
which is the RPC server, gets the request.

355
00:17:43,550 --> 00:17:46,010
Later on, the local print provider,

356
00:17:46,010 --> 00:17:48,520
which is responsible for
printing data to files

357
00:17:48,520 --> 00:17:50,004
will print the data into the file,

358
00:17:50,004 --> 00:17:51,803
which was specified by the user.

359
00:17:55,260 --> 00:17:57,530
Let's start with the first
print spooler vulnerability,

360
00:17:57,530 --> 00:17:58,883
which was used in Stuxnet.

361
00:17:59,940 --> 00:18:01,370
This is the flow of the vulnerability,

362
00:18:01,370 --> 00:18:04,425
which was providing a
remote code execution.

363
00:18:04,425 --> 00:18:06,310
The vulnerability exploited
the fact that the spooler

364
00:18:06,310 --> 00:18:10,186
allows a user to print to
a file on a remote computer

365
00:18:10,186 --> 00:18:12,320
on behalf of system,

366
00:18:12,320 --> 00:18:15,800
and has printed the
malicious file to system 32,

367
00:18:15,800 --> 00:18:17,000
which was a remote file.

368
00:18:20,090 --> 00:18:21,683
So it was patched on 2010.

369
00:18:22,640 --> 00:18:24,571
The patch included two validations.

370
00:18:24,571 --> 00:18:28,700
(a) Check if the printing
job was dispatched locally

371
00:18:28,700 --> 00:18:31,460
on the machine itself or remotely.

372
00:18:31,460 --> 00:18:33,620
If remotely, it will override and ignore

373
00:18:33,620 --> 00:18:35,583
any requested file write operation.

374
00:18:37,010 --> 00:18:39,820
Second, it will check that the
user have right permissions

375
00:18:39,820 --> 00:18:42,730
to the path of the file
that he wanted to print it

376
00:18:42,730 --> 00:18:43,930
before it's running too.

377
00:18:47,210 --> 00:18:48,570
Moving forward to 2020,

378
00:18:48,570 --> 00:18:50,680
we have found a way to
bypass the patch locally

379
00:18:50,680 --> 00:18:52,923
using almost the same exploitation path.

380
00:18:54,450 --> 00:18:56,200
The first check bypass is obvious

381
00:18:56,200 --> 00:18:59,690
because we shifted from
a remote code execution

382
00:18:59,690 --> 00:19:01,290
to a local privilege escalation.

383
00:19:02,230 --> 00:19:04,130
The second check needed some work.

384
00:19:04,130 --> 00:19:06,503
So let's dive into our
print spooler research.

385
00:19:09,030 --> 00:19:10,250
We found that the limited user

386
00:19:10,250 --> 00:19:11,960
can do some interesting operations

387
00:19:11,960 --> 00:19:13,710
without any elevation required

388
00:19:13,710 --> 00:19:15,820
by just using partial commands.

389
00:19:15,820 --> 00:19:18,750
For example, adding a
virtual printer which prints

390
00:19:18,750 --> 00:19:20,110
to a local printer port.

391
00:19:20,110 --> 00:19:22,092
Meaning, it will print to a file.

392
00:19:22,092 --> 00:19:24,900
And specifying the path of the file,

393
00:19:24,900 --> 00:19:26,670
which he doesn't have access to.

394
00:19:26,670 --> 00:19:28,920
For example, System 32.

395
00:19:28,920 --> 00:19:30,490
Okay, interesting.

396
00:19:30,490 --> 00:19:33,130
So does that mean that a
user can just print any data

397
00:19:33,130 --> 00:19:35,240
he would like to System 32?

398
00:19:35,240 --> 00:19:36,073
Let's check.

399
00:19:38,140 --> 00:19:40,570
So apparently, no, or
that's what we thought.

400
00:19:40,570 --> 00:19:41,610
AS we mentioned before,

401
00:19:41,610 --> 00:19:44,090
the MS10-061 patch has added the function,

402
00:19:44,090 --> 00:19:46,380
which validates if the user can write

403
00:19:46,380 --> 00:19:48,270
to the path he asked to print to,

404
00:19:48,270 --> 00:19:49,860
which means that the user won't be able

405
00:19:49,860 --> 00:19:52,150
to print data to System 32.

406
00:19:52,150 --> 00:19:54,723
So let's understand how can we bypass it.

407
00:19:59,243 --> 00:20:02,040
Every time the print spooler initializes,

408
00:20:02,040 --> 00:20:04,993
it processes the SHD files,
which are waiting to be spooled

409
00:20:04,993 --> 00:20:07,513
in the same directory for every user.

410
00:20:08,690 --> 00:20:11,090
A limited user can create an SHD file,

411
00:20:11,090 --> 00:20:14,360
which represents a print job,
which prints to any path.

412
00:20:14,360 --> 00:20:15,883
For example, System 32.

413
00:20:16,900 --> 00:20:18,720
Once the print spooler restarts,

414
00:20:18,720 --> 00:20:20,630
it will process the SHD file

415
00:20:20,630 --> 00:20:23,010
without being impersonated or aware

416
00:20:23,010 --> 00:20:24,930
of who created the print job.

417
00:20:24,930 --> 00:20:28,120
Therefore, it will operate
as anti-authority system

418
00:20:28,120 --> 00:20:31,750
and will print the data to any
file as anti-authority system

419
00:20:31,750 --> 00:20:34,520
resulting with allowing
the user to write data

420
00:20:34,520 --> 00:20:35,963
to any file in the system,

421
00:20:37,000 --> 00:20:38,447
and getting an arbitrary file write

422
00:20:38,447 --> 00:20:40,163
and a local privilege escalation.

423
00:20:42,750 --> 00:20:46,010
This was actually the bypass
of the second patch validation,

424
00:20:46,010 --> 00:20:48,623
specifically for the validate
output file function.

425
00:20:49,470 --> 00:20:52,380
Because the spooler is running
as anti-authority system,

426
00:20:52,380 --> 00:20:54,100
it has writing permissions to almost

427
00:20:54,100 --> 00:20:55,690
every file on the file system.

428
00:20:55,690 --> 00:20:57,540
So the check will patch successfully.

429
00:20:59,680 --> 00:21:02,090
So let's see a demo of the
first local privilege escalation

430
00:21:02,090 --> 00:21:03,590
we found in the print spooler.

431
00:21:07,750 --> 00:21:08,583
As you can see,

432
00:21:08,583 --> 00:21:11,150
we're running under the
context of a limited user.

433
00:21:11,150 --> 00:21:15,090
We're using a Windows
10 machine from March

434
00:21:15,090 --> 00:21:16,963
before our vulnerability was patched.

435
00:21:18,280 --> 00:21:20,480
We're using Johnny,
which is a limited user.

436
00:21:23,960 --> 00:21:25,330
So first, we'll use PowerShell

437
00:21:25,330 --> 00:21:28,453
in order to do the following stuff.

438
00:21:29,840 --> 00:21:30,980
We will add a printer port,

439
00:21:30,980 --> 00:21:33,093
which allows us to print to System 32.

440
00:21:35,040 --> 00:21:36,750
We will add the printer driver,

441
00:21:36,750 --> 00:21:38,950
which allows us to
create a virtual printer.

442
00:21:40,360 --> 00:21:42,720
And finally, we will add a printer,

443
00:21:42,720 --> 00:21:45,053
which is using the System 32 port.

444
00:21:47,240 --> 00:21:49,690
Next, we will use a pre-crafted SHD file,

445
00:21:49,690 --> 00:21:53,180
which represents a print job,
which prints to System 32.

446
00:21:53,180 --> 00:21:54,730
And we will use a DLL payload,

447
00:21:54,730 --> 00:21:57,380
which will write to System 32.

448
00:21:57,380 --> 00:21:59,207
We will rename it to SPL,

449
00:21:59,207 --> 00:22:02,740
and we will copy it by
using our limited user

450
00:22:02,740 --> 00:22:05,760
to the spool printers for the System 32,

451
00:22:05,760 --> 00:22:07,403
which is writable by all users.

452
00:22:12,250 --> 00:22:14,043
Now, before we will restart the VM,

453
00:22:15,586 --> 00:22:16,420
I want you to notice that

454
00:22:16,420 --> 00:22:19,570
there are only three
users in the computer,

455
00:22:19,570 --> 00:22:21,420
administrator, Johnny, and John,

456
00:22:21,420 --> 00:22:24,600
and that the following file in Windows 32,

457
00:22:24,600 --> 00:22:27,873
which name is exploited
TXT, does not exist.

458
00:22:29,045 --> 00:22:32,240
Next, let's restart the
VM by our limited user,

459
00:22:32,240 --> 00:22:33,760
in order to...

460
00:22:33,760 --> 00:22:36,443
the print spooler will
process our SHD file.

461
00:22:43,470 --> 00:22:47,240
Once we are logged in
back into Johnny user,

462
00:22:47,240 --> 00:22:49,950
the print spooler service
will process our SHD file

463
00:22:49,950 --> 00:22:52,220
will treat it as a print job,

464
00:22:52,220 --> 00:22:54,720
and will write our file to System 32.

465
00:22:54,720 --> 00:22:58,302
Next, Windows service
will execute our DLL,

466
00:22:58,302 --> 00:23:00,660
and as you can see, we've been able

467
00:23:00,660 --> 00:23:04,453
to add a new administrator
to the computer.

468
00:23:05,650 --> 00:23:09,330
And it was able to write
a file to the System 32

469
00:23:09,330 --> 00:23:10,933
name, exploited.txt.

470
00:23:12,080 --> 00:23:12,923
Now, let's verify that

471
00:23:12,923 --> 00:23:15,800
we've actually added an administrator.

472
00:23:17,890 --> 00:23:19,870
We'll open a command
prompt, which is elevated,

473
00:23:19,870 --> 00:23:23,473
and we'll just log in using
our new administrator user.

474
00:23:24,960 --> 00:23:25,853
As you can see,

475
00:23:31,551 --> 00:23:35,690
the administrators'
group contains our user.

476
00:23:35,690 --> 00:23:38,230
So we've been able to gain
local privilege escalation

477
00:23:38,230 --> 00:23:39,883
using the print spooler service.

478
00:23:42,560 --> 00:23:43,860
So now that we covered them altogether,

479
00:23:43,860 --> 00:23:48,860
we reached our destination.

480
00:23:57,030 --> 00:23:57,863
We've found equivalent capabilities

481
00:23:57,863 --> 00:24:02,410
to allegedly build Stuxnet
2.0 propagation port.

482
00:24:02,410 --> 00:24:03,883
But our work is not over yet.

483
00:24:07,180 --> 00:24:09,810
After the first vulnerability
we found was patched,

484
00:24:09,810 --> 00:24:12,150
we were able to re-exploit it,

485
00:24:12,150 --> 00:24:15,693
and we credited with CVE-2020-1337.

486
00:24:17,040 --> 00:24:18,950
Microsoft are currently working on a fix,

487
00:24:18,950 --> 00:24:21,630
which will be deployed in
the upcoming patch Tuesday.

488
00:24:21,630 --> 00:24:25,230
Therefore, we can't release any
technical details right now.

489
00:24:25,230 --> 00:24:27,790
We will publish it once
the patch will be deployed,

490
00:24:27,790 --> 00:24:29,073
but let's see a demo.

491
00:24:38,890 --> 00:24:40,220
So as you can see,

492
00:24:40,220 --> 00:24:41,920
we're running under the context of Johnny,

493
00:24:41,920 --> 00:24:43,120
which is a limited user.

494
00:24:48,140 --> 00:24:51,323
We're running under a fully-patched VM.

495
00:24:56,920 --> 00:24:58,370
Under the context of Johnny,

496
00:24:58,370 --> 00:24:59,883
we will execute our export,

497
00:25:01,850 --> 00:25:05,193
which will bypass the
patch of CVE-2020-1048.

498
00:25:10,500 --> 00:25:12,600
After we crafted our SHD file,

499
00:25:12,600 --> 00:25:17,383
we'll copy to the print spool directly.

500
00:25:19,380 --> 00:25:22,930
But first, you can notice
that the exploited TXT file

501
00:25:22,930 --> 00:25:26,113
does not exist and that we have
only three users as before.

502
00:25:27,140 --> 00:25:28,440
Now, let's restart the VM.

503
00:25:35,250 --> 00:25:36,460
Once it was initialized,

504
00:25:36,460 --> 00:25:39,193
we will log in again to
our limited user, Johnny.

505
00:25:42,180 --> 00:25:46,480
Now, as before, the print
spooler will process our SHD file

506
00:25:46,480 --> 00:25:48,670
and will print the data to System 32,

507
00:25:48,670 --> 00:25:51,130
which is our payload, which is a DLL file.

508
00:25:51,130 --> 00:25:54,043
Our DLL file will be
loaded into an elevated

509
00:25:54,043 --> 00:25:56,400
anti-authority system service.

510
00:25:56,400 --> 00:25:58,000
and we will gain call execution.

511
00:26:04,650 --> 00:26:07,980
Now, let's try and find
the exploited TXT file.

512
00:26:07,980 --> 00:26:11,380
As you can see, we write
the data to System 32,

513
00:26:11,380 --> 00:26:13,800
and we have been able to
add an administrator user.

514
00:26:13,800 --> 00:26:15,990
Once again to the VM,

515
00:26:15,990 --> 00:26:19,353
let's execute a command
prompt, which is elevated.

516
00:26:27,068 --> 00:26:31,151
And let's login using our
new administrator user.

517
00:26:32,440 --> 00:26:33,273
As you can see,

518
00:26:33,273 --> 00:26:35,680
we've gained a local privilege escalation

519
00:26:35,680 --> 00:26:37,690
and the call execution
using the print spooler

520
00:26:37,690 --> 00:26:40,390
once again, after the first
vulnerability was patched.

521
00:26:42,810 --> 00:26:43,910
Handing over to Tomer.

522
00:26:46,970 --> 00:26:47,803
- Wow!

523
00:26:47,803 --> 00:26:50,980
1337, that's awesome.

524
00:26:50,980 --> 00:26:54,180
So going back to our second question,

525
00:26:54,180 --> 00:26:57,180
we would like to propose an
additional possible solution

526
00:26:57,180 --> 00:26:58,853
as a second level for patching.

527
00:26:59,860 --> 00:27:03,480
We believe in a level
security mitigation approach.

528
00:27:03,480 --> 00:27:07,083
So we bolted to MSOC on
each vulnerability we found,

529
00:27:08,580 --> 00:27:12,040
but we still believe it's not enough.

530
00:27:12,040 --> 00:27:15,723
So we develop a PoC for real
time prevention of the attack.

531
00:27:17,100 --> 00:27:20,360
The main root cause of the
arbitrary file write bug class

532
00:27:20,360 --> 00:27:22,830
in the context of local
privilege escalation,

533
00:27:22,830 --> 00:27:25,156
is the fact that a limited user is allowed

534
00:27:25,156 --> 00:27:29,210
to write directly to
the following location.

535
00:27:29,210 --> 00:27:32,280
This is dangerous and can
be exploited very easily.

536
00:27:32,280 --> 00:27:34,590
And we found that it's
actually not really needed

537
00:27:34,590 --> 00:27:35,597
for the regular use.

538
00:27:36,670 --> 00:27:39,640
Today, we will release
a mini-filtered driver,

539
00:27:39,640 --> 00:27:43,080
which restricts any file write
operation by a limited user

540
00:27:43,080 --> 00:27:44,853
to some of these location as a PoC.

541
00:27:46,030 --> 00:27:48,900
This mitigation proposal is not specific

542
00:27:48,900 --> 00:27:50,800
to the spooler's vulnerabilities,

543
00:27:50,800 --> 00:27:53,108
and can be used as a
template for mitigating

544
00:27:53,108 --> 00:27:55,920
the arbitrary file write bug class.

545
00:27:55,920 --> 00:27:57,853
Please treat the driver as a PoC,

546
00:27:58,710 --> 00:28:02,130
and be careful not to execute
it in production system

547
00:28:02,130 --> 00:28:04,743
before validating it for false positive.

548
00:28:05,920 --> 00:28:06,753
That's the idea.

549
00:28:07,750 --> 00:28:09,350
Okay, so this time,

550
00:28:09,350 --> 00:28:11,882
we are running on Windows 10 RS1,

551
00:28:11,882 --> 00:28:14,030
our older version, without the patch

552
00:28:14,030 --> 00:28:16,410
for the vulnerability
we were going to use.

553
00:28:16,410 --> 00:28:19,160
And as usual, we are running
as Johnny, a limited user.

554
00:28:23,990 --> 00:28:26,890
Let's make sure that our driver
is loaded to (indistinct).

555
00:28:35,081 --> 00:28:37,153
And now, we'll present

556
00:28:37,153 --> 00:28:40,850
that regular usage of printing is allowed.

557
00:28:49,920 --> 00:28:52,980
So our driver will examine the file write

558
00:28:52,980 --> 00:28:54,522
of the SPL and SHD file,

559
00:28:54,522 --> 00:28:56,223
and will allow it...

560
00:28:56,223 --> 00:28:58,709
You can see that there are two files

561
00:28:58,709 --> 00:29:00,327
in the printer spooler folder,

562
00:29:00,327 --> 00:29:02,353
which size, which is not zero.

563
00:29:16,860 --> 00:29:17,693
And now,

564
00:29:19,200 --> 00:29:23,950
let's copy the SHD and SPL file

565
00:29:23,950 --> 00:29:26,033
to the printer spooler directly.

566
00:29:28,690 --> 00:29:31,770
Now, actually, our driver,

567
00:29:31,770 --> 00:29:33,930
examined the write and blocked it,

568
00:29:33,930 --> 00:29:37,893
considered files are of zero size.

569
00:29:41,880 --> 00:29:44,200
Let's demonstrate the
Task Scheduler exploit.

570
00:29:44,200 --> 00:29:45,350
This is a public exploit,

571
00:29:45,350 --> 00:29:49,663
and you can see that our
driver blocked the write.

572
00:29:53,490 --> 00:29:54,586
So for Microsoft's response

573
00:29:54,586 --> 00:29:58,740
for the spooler's local
privilege escalation,

574
00:29:58,740 --> 00:30:02,860
the additional vector for CVE-2020-1048

575
00:30:02,860 --> 00:30:05,052
will be addressed in August, 2020,

576
00:30:05,052 --> 00:30:08,660
as CVE-2020-1337.

577
00:30:08,660 --> 00:30:11,140
And for the spooler Denial of Service,

578
00:30:11,140 --> 00:30:13,862
the technique results in
a local Denial of Service,

579
00:30:13,862 --> 00:30:16,800
which doesn't meet Microsoft servicing bar

580
00:30:16,800 --> 00:30:18,350
for security updates.

581
00:30:20,337 --> 00:30:23,040
We would like to give credits
for the following people

582
00:30:23,040 --> 00:30:25,160
for researching similar areas.

583
00:30:25,160 --> 00:30:27,530
Alex Ionescu and Yarden Shafir,

584
00:30:27,530 --> 00:30:28,538
Dave Weinstein,

585
00:30:28,538 --> 00:30:29,820
ITh4cker,

586
00:30:29,820 --> 00:30:30,670
and Jeongoh Kyea.

587
00:30:33,600 --> 00:30:37,410
Today, we release our repository,

588
00:30:37,410 --> 00:30:42,410
which includes an exploit
PoC for CVE-2020-1048,

589
00:30:43,460 --> 00:30:47,240
and an exploit PoC for the 0-day,

590
00:30:47,240 --> 00:30:49,653
Denial of Service of the spooler service,

591
00:30:50,850 --> 00:30:54,420
the driver for the arbitrary
file write mitigation.

592
00:30:54,420 --> 00:30:56,740
And in a few days, on August 12th,

593
00:30:56,740 --> 00:31:00,430
we will release the CVE-2020-1337,

594
00:31:00,430 --> 00:31:02,370
super (indistinct) exploit PoC.

595
00:31:02,370 --> 00:31:03,770
Please check our repository.

596
00:31:06,900 --> 00:31:08,520
Thank you for joining us,

597
00:31:08,520 --> 00:31:10,030
and let's go over for the Q&A.

