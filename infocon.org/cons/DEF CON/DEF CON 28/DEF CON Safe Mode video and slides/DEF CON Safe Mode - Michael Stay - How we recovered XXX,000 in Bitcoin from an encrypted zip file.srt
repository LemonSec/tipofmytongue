1
00:00:01,700 --> 00:00:03,480
- Hello, my name is Mike Stay.

2
00:00:03,480 --> 00:00:05,530
I'm the CTO of Pyrofex Corporation.

3
00:00:05,530 --> 00:00:06,630
And today I'm gonna tell you about

4
00:00:06,630 --> 00:00:09,150
how we recovered several
hundred thousand dollars worth

5
00:00:09,150 --> 00:00:11,193
of Bitcoin from an encrypted zip file.

6
00:00:13,180 --> 00:00:16,220
Around 20 years ago, I was
working as a reverse engineer

7
00:00:16,220 --> 00:00:17,900
and cryptanalyst for AccessData

8
00:00:17,900 --> 00:00:19,900
while getting my physics degree at BYU.

9
00:00:19,900 --> 00:00:23,530
It was the late '90s, early 2000s.

10
00:00:23,530 --> 00:00:24,363
The US government

11
00:00:24,363 --> 00:00:26,870
had been gradually easing
off export restrictions

12
00:00:26,870 --> 00:00:29,150
on software containing cryptography,

13
00:00:29,150 --> 00:00:30,110
but most software

14
00:00:30,110 --> 00:00:33,480
still contained a pretty
worthless password protection.

15
00:00:33,480 --> 00:00:35,070
We'd buy desktop Office software,

16
00:00:35,070 --> 00:00:36,560
I'd reverse engineer it to figure out

17
00:00:36,560 --> 00:00:38,970
what algorithm it was
using for access control

18
00:00:38,970 --> 00:00:40,720
and then break the crypto.

19
00:00:40,720 --> 00:00:42,750
It was a never ending
stream of interesting,

20
00:00:42,750 --> 00:00:44,723
but not impossible math puzzles.

21
00:00:45,590 --> 00:00:48,940
I wrote about 40 password
crackers during my time there.

22
00:00:48,940 --> 00:00:51,520
We would sell them to home
users, system, administrators,

23
00:00:51,520 --> 00:00:54,620
local and federal law
enforcement agencies.

24
00:00:54,620 --> 00:00:55,453
I got to go down

25
00:00:55,453 --> 00:00:57,120
to the Federal Law
Enforcement Training Center

26
00:00:57,120 --> 00:00:59,835
in Glynco a few times to
teach secret service agents,

27
00:00:59,835 --> 00:01:02,940
FBI agents, ATF about cryptography

28
00:01:02,940 --> 00:01:04,340
and the use of our products.

29
00:01:05,300 --> 00:01:07,750
Two of the projects really
sunk down in my memory.

30
00:01:07,750 --> 00:01:10,558
The first was Microsoft Word 97.

31
00:01:10,558 --> 00:01:13,830
Before Word 97, the files were encrypted

32
00:01:13,830 --> 00:01:14,980
by XORing the bytes

33
00:01:14,980 --> 00:01:18,520
with the repeating 16 byte
string derived from the password.

34
00:01:18,520 --> 00:01:20,150
The most common bytes in a Word file were

35
00:01:20,150 --> 00:01:24,530
either 0 to 55 or 32, which is space.

36
00:01:24,530 --> 00:01:26,360
So we just look at the
most common character

37
00:01:26,360 --> 00:01:28,200
in each of the 16 columns,

38
00:01:28,200 --> 00:01:31,360
try the three to the
16th variations on those

39
00:01:31,360 --> 00:01:35,100
and recovering the key
was usually instantaneous,

40
00:01:35,100 --> 00:01:36,030
but to help people feel

41
00:01:36,030 --> 00:01:37,300
like they'd gotten their money's worth,

42
00:01:37,300 --> 00:01:41,820
we'd put on a little show
like the scene in "WarGames",

43
00:01:41,820 --> 00:01:44,520
where it would be animated
showing random characters

44
00:01:44,520 --> 00:01:46,883
that would gradually
reveal the right password.

45
00:01:47,870 --> 00:01:51,100
Microsoft 97 changed that.

46
00:01:51,100 --> 00:01:53,590
It might've been possible to
find out the encryption format

47
00:01:53,590 --> 00:01:55,780
through Microsoft Developer Network,

48
00:01:55,780 --> 00:01:57,100
but we were a small company

49
00:01:57,100 --> 00:01:59,240
and couldn't afford the subscription.

50
00:01:59,240 --> 00:02:00,700
It also wasn't clear we'd be allowed

51
00:02:00,700 --> 00:02:03,590
to write the cracker if we
did get the info from them.

52
00:02:03,590 --> 00:02:07,233
So to figure out how it
worked, I used soft dice.

53
00:02:08,220 --> 00:02:11,070
There was a button on a
cable that would go to a card

54
00:02:11,070 --> 00:02:13,463
in the computer, I'd type the password

55
00:02:13,463 --> 00:02:16,580
and then hit enter and
the button on the cable

56
00:02:16,580 --> 00:02:18,720
as fast as I could and hoped

57
00:02:18,720 --> 00:02:23,593
that it would break somewhere
in the crypto stuff.

58
00:02:23,593 --> 00:02:27,080
I'd walk up the stack trying to figure out

59
00:02:27,080 --> 00:02:29,230
where the algorithm was.

60
00:02:29,230 --> 00:02:31,060
This was in the days before IDA Pro,

61
00:02:31,060 --> 00:02:34,560
so I printed out a few
dozen pages of assembly code

62
00:02:34,560 --> 00:02:35,760
and taped it to the wall

63
00:02:35,760 --> 00:02:36,870
and then drew all over it

64
00:02:36,870 --> 00:02:40,980
with the red crayon
updating the function names

65
00:02:43,254 --> 00:02:45,440
and so on as I figured stuff out.

66
00:02:45,440 --> 00:02:48,250
I was very pleased when I
finally worked it all out.

67
00:02:48,250 --> 00:02:49,890
At the time, Microsoft was only allowed

68
00:02:49,890 --> 00:02:51,680
to export 40-bit cryptography.

69
00:02:51,680 --> 00:02:54,710
So they did as much as they
were legally permitted to do.

70
00:02:54,710 --> 00:02:58,820
They'd repeatedly MD5 the password

71
00:02:58,820 --> 00:03:01,715
with some salt, which
is randomly chosen bytes

72
00:03:01,715 --> 00:03:03,690
that is stored in the file

73
00:03:03,690 --> 00:03:05,820
and then they'd get a 40-bit key,

74
00:03:05,820 --> 00:03:08,680
then they'd add salt to that
and repeatedly hash it again.

75
00:03:08,680 --> 00:03:11,460
So it took about half a
second to test a password

76
00:03:11,460 --> 00:03:13,060
on the computers at the time.

77
00:03:13,060 --> 00:03:15,230
So despite being a 40-bit key space,

78
00:03:15,230 --> 00:03:18,670
it was a fairly hard problem to attack,

79
00:03:18,670 --> 00:03:21,180
and we had to resort
to a dictionary attack

80
00:03:21,180 --> 00:03:24,800
'cause breaking it out right
it was pretty much impossible.

81
00:03:24,800 --> 00:03:28,330
We did eventually write a
cracker for larger companies

82
00:03:28,330 --> 00:03:32,080
that had their own computer labs

83
00:03:32,080 --> 00:03:36,638
and resources, other large agencies

84
00:03:36,638 --> 00:03:38,900
to brute force the 40-bit key space

85
00:03:38,900 --> 00:03:42,990
using the fancy MMX
instructions on the Pentium.

86
00:03:42,990 --> 00:03:47,640
This was long before graphics
processors were available.

87
00:03:47,640 --> 00:03:50,760
I knew of one place that ran
the software for nine months

88
00:03:50,760 --> 00:03:52,223
before finally getting in.

89
00:03:53,410 --> 00:03:57,150
The other really fun one
I did was zip archives.

90
00:03:57,150 --> 00:04:01,300
The developer of PKZIP Phil
Katz made the decision,

91
00:04:01,300 --> 00:04:04,450
which was unusual at the time,
to document his file format

92
00:04:04,450 --> 00:04:06,770
and include it with his software,

93
00:04:06,770 --> 00:04:09,070
that made it a favorite of developers.

94
00:04:09,070 --> 00:04:11,210
Roger Schlafly designed
the stream cipher used

95
00:04:11,210 --> 00:04:13,100
for encrypting the archives.

96
00:04:13,100 --> 00:04:14,710
The zip standard quickly became

97
00:04:14,710 --> 00:04:17,333
by far the most popular
compression format on Windows

98
00:04:17,333 --> 00:04:21,214
and many other formats
like Java's JAR format,

99
00:04:21,214 --> 00:04:24,560
OpenOffice's document formats
are really just zip files

100
00:04:24,560 --> 00:04:26,973
with a particular
directory structure inside.

101
00:04:28,438 --> 00:04:32,670
Info-Zip is an open source implementation,

102
00:04:32,670 --> 00:04:35,020
the software that was used as the basis

103
00:04:35,020 --> 00:04:38,340
for nearly all other branded
zip software like WinZip.

104
00:04:38,340 --> 00:04:40,000
And at the time I was trying to crack it,

105
00:04:40,000 --> 00:04:44,723
WinZip had 95% of the market,
according to CNET downloads.

106
00:04:47,170 --> 00:04:49,400
Eli Biham and Paul Kocher

107
00:04:49,400 --> 00:04:53,210
had published a known
plaintext Attack on the cipher,

108
00:04:53,210 --> 00:04:56,620
but the known plaintext
was compressed plaintext.

109
00:04:56,620 --> 00:04:59,070
To get the Huffman codes at
the start of a deflated file,

110
00:04:59,070 --> 00:05:03,063
you basically need 32
kilobytes of the file.

111
00:05:03,950 --> 00:05:06,390
The attack was practically useless

112
00:05:06,390 --> 00:05:08,003
to law enforcement agencies.

113
00:05:08,940 --> 00:05:11,200
This diagram is an illustration

114
00:05:11,200 --> 00:05:14,810
of the internal workings
of the zip cipher.

115
00:05:14,810 --> 00:05:18,800
Each of these boxes
represents a byte, eight bits.

116
00:05:18,800 --> 00:05:21,483
The cipher has 96 bits
of internal state split

117
00:05:21,483 --> 00:05:24,340
into three 32-bit chunks.

118
00:05:24,340 --> 00:05:28,640
One is called key0, key1 and key2.

119
00:05:28,640 --> 00:05:33,150
This subscript indicates the state

120
00:05:33,150 --> 00:05:36,170
of that chunk after having processed

121
00:05:36,170 --> 00:05:39,540
that many bytes of text.

122
00:05:39,540 --> 00:05:41,950
So here, this is the initial state we feed

123
00:05:41,950 --> 00:05:44,070
in the first byte of text

124
00:05:44,070 --> 00:05:47,190
and we get the subsequent state of key0,

125
00:05:47,190 --> 00:05:50,700
and then we take part of
that and feed it in here,

126
00:05:50,700 --> 00:05:53,190
and we get the subsequent state of key1,

127
00:05:53,190 --> 00:05:55,630
then we take one of these
bytes and feed it in here

128
00:05:55,630 --> 00:05:57,610
and get the subsequent state of key2,

129
00:05:57,610 --> 00:06:02,170
then we do one more operation
on these two low bytes

130
00:06:02,170 --> 00:06:03,423
to get the stream byte.

131
00:06:05,320 --> 00:06:07,100
Going into a little more detail,

132
00:06:07,100 --> 00:06:10,590
this first section is CRC32.

133
00:06:10,590 --> 00:06:13,870
CRC stands for cyclical redundancy check.

134
00:06:13,870 --> 00:06:18,380
It was designed for detecting
errors on the circular tracks

135
00:06:18,380 --> 00:06:21,340
that you would find on floppy disks.

136
00:06:21,340 --> 00:06:22,870
So here we can see the shift,

137
00:06:22,870 --> 00:06:25,197
it's being shifted right eight bits

138
00:06:25,197 --> 00:06:28,750
and we take these eight bits
that got shifted off the bottom

139
00:06:28,750 --> 00:06:33,640
and use them to look up a
32-bit word in this table.

140
00:06:33,640 --> 00:06:35,630
Then we take the byte that's coming in

141
00:06:35,630 --> 00:06:39,560
and we also look up a 32-bit
word for that one in the table,

142
00:06:39,560 --> 00:06:42,730
then we XOR the high 24 bits here

143
00:06:42,730 --> 00:06:44,580
that were left after shifting it down

144
00:06:45,500 --> 00:06:49,163
with these two words and we
get the new state of key0.

145
00:06:50,410 --> 00:06:54,420
We take the low byte of
the new value of key0,

146
00:06:55,510 --> 00:06:58,960
add it to the current
state of key1 multiplied

147
00:06:58,960 --> 00:07:02,723
by this constant, add one and
get the new state of key1.

148
00:07:04,090 --> 00:07:07,960
So this is called a truncated
linear congruential generator.

149
00:07:07,960 --> 00:07:12,900
Truncated because we're only
taking the high byte as output,

150
00:07:12,900 --> 00:07:15,363
linear because it's addition,

151
00:07:16,270 --> 00:07:20,000
congruential because it's
modular two to the 32,

152
00:07:20,000 --> 00:07:22,870
and generator because it's spitting out

153
00:07:24,670 --> 00:07:26,490
pseudo random bytes.

154
00:07:26,490 --> 00:07:29,060
So it takes this byte
that it's spitting out

155
00:07:29,060 --> 00:07:31,520
and feeds it into CRC32 again.

156
00:07:31,520 --> 00:07:35,300
Now this is a linear
feedback shift register,

157
00:07:35,300 --> 00:07:38,010
but this one is linear with respect to XOR

158
00:07:38,010 --> 00:07:39,710
while this one is linear with respect

159
00:07:39,710 --> 00:07:42,800
to addition with carries.

160
00:07:42,800 --> 00:07:44,400
So they don't work well together

161
00:07:44,400 --> 00:07:46,180
and that's what really gives it

162
00:07:46,180 --> 00:07:48,040
whatever strength that does have.

163
00:07:50,010 --> 00:07:53,960
So CRC32 truncated linear
congruential generator,

164
00:07:53,960 --> 00:07:58,560
another CRC32, and then the
pseudo squaring operation.

165
00:07:58,560 --> 00:08:00,170
And if you look in the source code,

166
00:08:00,170 --> 00:08:03,270
the pseudo squaring
operation is like this,

167
00:08:03,270 --> 00:08:04,247
you take key2

168
00:08:05,570 --> 00:08:09,020
and the low 16 bits of that

169
00:08:09,020 --> 00:08:12,553
and OR it with two, so you set a bit one,

170
00:08:12,553 --> 00:08:16,890
and then you multiply
that by itself XOR one.

171
00:08:16,890 --> 00:08:18,620
So one of the values is gonna be even,

172
00:08:18,620 --> 00:08:22,460
and the other one's odd,
you shift it down by eight

173
00:08:22,460 --> 00:08:23,670
and take eight bits.

174
00:08:23,670 --> 00:08:27,887
So it's the middle of this
pseudo squaring operation.

175
00:08:30,330 --> 00:08:34,450
And the result is a stream byte.

176
00:08:34,450 --> 00:08:37,420
Now, the way this stream cipher works is

177
00:08:37,420 --> 00:08:40,625
that you initialize it
first with a password

178
00:08:40,625 --> 00:08:45,625
and then you encrypt the plaintext
that you want to encrypt.

179
00:08:46,060 --> 00:08:50,890
To make it harder, they
encrypt some salt, first.

180
00:08:50,890 --> 00:08:55,270
PKZIP used bytes

181
00:08:56,450 --> 00:08:59,120
that were in memory.

182
00:08:59,120 --> 00:09:00,690
So it would allocate 10 bytes

183
00:09:00,690 --> 00:09:02,180
and use whatever bytes were there.

184
00:09:02,180 --> 00:09:03,833
That's how it got its entropy.

185
00:09:05,610 --> 00:09:08,690
Info-Zip because it was
built for use on Linux

186
00:09:08,690 --> 00:09:12,940
as well as Windows couldn't do that

187
00:09:12,940 --> 00:09:14,700
because when the memory was allocated,

188
00:09:14,700 --> 00:09:16,330
it was also initialized.

189
00:09:16,330 --> 00:09:19,200
So they got their entropy
from the process ID

190
00:09:19,200 --> 00:09:20,040
and the timestamp.

191
00:09:20,040 --> 00:09:23,610
You'd XOR those two together
and call srand() on it

192
00:09:23,610 --> 00:09:26,400
to see the random number generator.

193
00:09:26,400 --> 00:09:28,550
Then it would use rand()

194
00:09:28,550 --> 00:09:32,040
to generate 10 bytes as salt

195
00:09:33,090 --> 00:09:36,630
in the file, then you'd follow it by CRC32

196
00:09:36,630 --> 00:09:38,240
and the plaintext.

197
00:09:38,240 --> 00:09:40,620
Now Biham and Kocher had their attack

198
00:09:40,620 --> 00:09:44,430
and it was published when
Info-Zip was implemented,

199
00:09:44,430 --> 00:09:47,640
so they knew that if
they just used rand(),

200
00:09:47,640 --> 00:09:52,439
then if somebody had the
timestamp and the process ID,

201
00:09:52,439 --> 00:09:55,950
they could compute these bytes.

202
00:09:55,950 --> 00:09:57,660
The CRC was stored in the file

203
00:09:57,660 --> 00:10:00,620
to check that the password
was entered correctly.

204
00:10:00,620 --> 00:10:02,700
So they would know these bytes

205
00:10:02,700 --> 00:10:04,700
and that would give them 12 bytes,

206
00:10:04,700 --> 00:10:07,610
which was sufficient to mount
a known plaintext attack.

207
00:10:07,610 --> 00:10:10,080
So Info-Zip tried to avoid that

208
00:10:11,940 --> 00:10:13,030
and they made it harder,

209
00:10:13,030 --> 00:10:14,623
but not quite hard enough.

210
00:10:17,730 --> 00:10:21,480
So renaming these bytes individually,

211
00:10:21,480 --> 00:10:24,180
r0 through r9 are the bytes generated

212
00:10:24,180 --> 00:10:28,330
by rand(), c0, c1 of the CRC32 bytes

213
00:10:28,330 --> 00:10:30,500
and p0 through p3

214
00:10:31,600 --> 00:10:34,020
and so on are the plaintext bytes.

215
00:10:34,020 --> 00:10:35,623
And I'll call this array x.

216
00:10:36,907 --> 00:10:39,650
Now, when you feed the password

217
00:10:39,650 --> 00:10:44,600
into the cipher it treats
it as though it's plaintext,

218
00:10:44,600 --> 00:10:46,560
you feed it in the first password byte,

219
00:10:46,560 --> 00:10:50,630
it updates key0, key1, key2,
spits out a string byte,

220
00:10:53,921 --> 00:10:55,410
then it throws the stream byte way,

221
00:10:55,410 --> 00:10:58,547
until it gets to the last
character of the password

222
00:10:58,547 --> 00:11:01,220
and that final stream byte is used

223
00:11:01,220 --> 00:11:04,013
to encrypt the first salt byte r0.

224
00:11:05,740 --> 00:11:09,970
So I get this set of 10 bytes

225
00:11:09,970 --> 00:11:11,500
that I call y,

226
00:11:11,500 --> 00:11:15,060
which is just these
first 10 bytes generated

227
00:11:15,060 --> 00:11:18,560
by rand(), exclusive ored
with the 10 bytes generated

228
00:11:18,560 --> 00:11:20,530
by the stream cipher.

229
00:11:20,530 --> 00:11:23,530
Now you'll notice here, I call this s0,

230
00:11:23,530 --> 00:11:25,389
but this one is s1x.

231
00:11:25,389 --> 00:11:29,530
These ones that end in x depend

232
00:11:29,530 --> 00:11:32,250
on the values in x,

233
00:11:32,250 --> 00:11:37,130
but s0 only depends on the password itself

234
00:11:38,570 --> 00:11:41,260
that turned out to be their tragic flaw,

235
00:11:41,260 --> 00:11:45,780
that when they encrypted
this a second time,

236
00:11:45,780 --> 00:11:49,193
so they were using y as
the salt bytes in the file,

237
00:11:51,560 --> 00:11:55,010
they would generate s0 again,

238
00:11:55,010 --> 00:11:56,853
because it was the same password.

239
00:11:58,260 --> 00:12:02,587
So they would XOR with s0
once to get the salt byte,

240
00:12:02,587 --> 00:12:06,640
XOR with s0, again, to get the byte

241
00:12:06,640 --> 00:12:09,220
that was stored in the encryption header.

242
00:12:09,220 --> 00:12:12,690
Now, all of these are hard to figure out

243
00:12:12,690 --> 00:12:16,450
because they depend both
on the randomly generated

244
00:12:20,120 --> 00:12:21,260
bytes from rand()

245
00:12:21,260 --> 00:12:25,270
as well as the stream
cipher bytes twice over.

246
00:12:25,270 --> 00:12:27,660
So this is doubly encrypted stuff,

247
00:12:27,660 --> 00:12:29,640
but this first byte leaked

248
00:12:30,890 --> 00:12:34,390
and given five files in
the archive, all encrypted

249
00:12:34,390 --> 00:12:39,310
with the same password,
this gave me eight bits

250
00:12:39,310 --> 00:12:41,660
of entropy per file

251
00:12:41,660 --> 00:12:46,450
to find the 32-bit internal state

252
00:12:46,450 --> 00:12:50,363
of the rand() pseudo
random number generator.

253
00:12:51,890 --> 00:12:55,559
So given five files, I could
simply take the first byte

254
00:12:55,559 --> 00:12:58,783
of each archive,

255
00:13:00,320 --> 00:13:03,250
run through all 32 bits

256
00:13:03,250 --> 00:13:05,790
of possible internal state

257
00:13:05,790 --> 00:13:08,700
and verify that every 10th byte

258
00:13:08,700 --> 00:13:12,860
gave me the byte I was expecting.

259
00:13:12,860 --> 00:13:16,080
So I could uniquely
identify the internal state,

260
00:13:16,080 --> 00:13:21,080
could uniquely find these 10 bytes

261
00:13:21,360 --> 00:13:24,523
and so then I had some place
to stand to mount the attack.

262
00:13:25,370 --> 00:13:27,370
So the next thing I did was notice

263
00:13:27,370 --> 00:13:31,480
that I didn't need all 96 bits

264
00:13:31,480 --> 00:13:34,543
to produce the next stream byte,

265
00:13:34,543 --> 00:13:37,220
I only needed 40 bits.

266
00:13:37,220 --> 00:13:42,000
So here I didn't need to know both key0

267
00:13:43,770 --> 00:13:48,690
or rather the second and
the first byte of key0,

268
00:13:48,690 --> 00:13:51,880
I only needed to know the XOR
of this byte with that one.

269
00:13:51,880 --> 00:13:53,990
So that's an eight bit guess.

270
00:13:53,990 --> 00:13:57,880
I know the value from
rand() that's going in,

271
00:13:57,880 --> 00:13:59,343
so I can predict this thing.

272
00:14:02,340 --> 00:14:04,923
Here, I'm multiplying by this constant.

273
00:14:06,606 --> 00:14:09,070
If I take the...

274
00:14:10,270 --> 00:14:14,060
I don't need to know the
entire value of key1,

275
00:14:14,060 --> 00:14:16,190
I just need to know the high byte

276
00:14:16,190 --> 00:14:18,030
of key1 times the constant.

277
00:14:18,030 --> 00:14:19,940
So I've distributed this multiplication

278
00:14:19,940 --> 00:14:21,960
across the addition we had earlier.

279
00:14:21,960 --> 00:14:23,720
So here is the high byte of that

280
00:14:26,100 --> 00:14:29,940
and when I add one, it
might cause a carry bit,

281
00:14:29,940 --> 00:14:32,020
so I have to guess a carry bit.

282
00:14:32,020 --> 00:14:33,453
Then it comes in here.

283
00:14:35,270 --> 00:14:37,403
I know what the high byte of this is,

284
00:14:38,650 --> 00:14:39,600
I feed it in.

285
00:14:39,600 --> 00:14:42,100
I just need to know these values

286
00:14:42,100 --> 00:14:43,563
and given the stream byte,

287
00:14:45,260 --> 00:14:47,980
I can then figure out

288
00:14:47,980 --> 00:14:51,500
what the low six bits
are here that are needed.

289
00:14:51,500 --> 00:14:54,513
So this is how to figure
out, given a stream byte,

290
00:14:56,360 --> 00:14:59,720
well, a plaintext and a cipher text pair,

291
00:14:59,720 --> 00:15:02,270
these are the bits that you have to guess

292
00:15:02,270 --> 00:15:06,813
in order to get this stream byte.

293
00:15:07,750 --> 00:15:11,113
So what I would do is
I would guess 40 bits,

294
00:15:13,280 --> 00:15:14,170
which would allow me

295
00:15:14,170 --> 00:15:15,587
to process

296
00:15:20,010 --> 00:15:22,900
this byte here,

297
00:15:22,900 --> 00:15:25,950
and so then I could check
for each of the five files,

298
00:15:25,950 --> 00:15:29,930
does this value match what I expect it to?

299
00:15:29,930 --> 00:15:32,650
And since I had 40 bits
that I was guessing

300
00:15:32,650 --> 00:15:36,277
and 40 bits of entropy

301
00:15:37,700 --> 00:15:39,550
to compare it to from the file,

302
00:15:39,550 --> 00:15:42,140
I could filter out all but one guess.

303
00:15:42,140 --> 00:15:45,900
And then for the next byte,
I would guess 26 more bits,

304
00:15:45,900 --> 00:15:50,500
and then just a few more bits
to get the rest of the state

305
00:15:50,500 --> 00:15:51,750
after that point.

306
00:15:51,750 --> 00:15:54,670
Usually once I found this 40-bit one,

307
00:15:54,670 --> 00:15:59,210
the next one I could get
within a few minutes.

308
00:15:59,210 --> 00:16:01,580
The whole attack ran in about two hours

309
00:16:01,580 --> 00:16:06,580
on a Pentium at the time.

310
00:16:08,200 --> 00:16:11,010
Ciphertext-only attack,
I was able to break

311
00:16:11,010 --> 00:16:13,500
into these zip files.

312
00:16:13,500 --> 00:16:17,453
We caught several child
pornographers that way,

313
00:16:19,270 --> 00:16:20,860
and I got a paper out of it.

314
00:16:20,860 --> 00:16:25,860
So in 2001 Fast Software Encryption,

315
00:16:27,410 --> 00:16:32,140
I got this paper and
that lead 20 years later

316
00:16:32,980 --> 00:16:36,670
to a surprising message.

317
00:16:36,670 --> 00:16:39,505
So in October of last year,

318
00:16:39,505 --> 00:16:41,540
a guy contacts me out of the blue

319
00:16:41,540 --> 00:16:45,686
and says, "I read your paper
on known plaintext attacks,

320
00:16:45,686 --> 00:16:49,310
and I've got this password
that I've forgotten,

321
00:16:49,310 --> 00:16:51,240
is there anything you can do to help?

322
00:16:51,240 --> 00:16:54,470
Can you tell me how things
are looking these days?"

323
00:16:54,470 --> 00:16:58,660
And so I looked it over, it
turns out he only had two files

324
00:17:01,576 --> 00:17:03,160
in the archive.

325
00:17:03,160 --> 00:17:07,040
With only two files, I didn't
have enough information

326
00:17:07,040 --> 00:17:09,810
to drive the internal state of rand()

327
00:17:09,810 --> 00:17:11,320
and I didn't have enough information

328
00:17:11,320 --> 00:17:16,120
to filter the guesses

329
00:17:16,120 --> 00:17:17,000
I was making

330
00:17:17,000 --> 00:17:19,800
so far more guesses

331
00:17:19,800 --> 00:17:23,080
would pass each filtering stage,

332
00:17:23,080 --> 00:17:25,840
and it worked out to be something like,

333
00:17:25,840 --> 00:17:29,820
on my back of the envelope calculations,

334
00:17:29,820 --> 00:17:31,900
something like two to the 70.

335
00:17:31,900 --> 00:17:35,810
So I told him compare
the work done this year

336
00:17:35,810 --> 00:17:38,590
to find hash collisions in SHA1.

337
00:17:38,590 --> 00:17:42,330
SHA1 has 128-bit output,
so to find a collision,

338
00:17:42,330 --> 00:17:45,270
you've gotta look at
two to the 64th hashes

339
00:17:45,270 --> 00:17:47,370
that cost around $100,000.

340
00:17:47,370 --> 00:17:49,180
This is not something

341
00:17:49,180 --> 00:17:52,620
that you can use
off-the-shelf software for.

342
00:17:52,620 --> 00:17:54,507
And then he blew my mind and said,

343
00:17:54,507 --> 00:17:57,187
"I could spend so much on this archive".

344
00:17:58,710 --> 00:17:59,670
At that point, I knew

345
00:17:59,670 --> 00:18:03,830
that he probably had several
hundred thousand dollars

346
00:18:03,830 --> 00:18:05,333
of Bitcoin in this thing.

347
00:18:07,800 --> 00:18:11,460
At this point, I started
doing a more careful analysis.

348
00:18:11,460 --> 00:18:13,490
There are 96 bits of key material

349
00:18:13,490 --> 00:18:16,520
that need to be guessed in various stages,

350
00:18:16,520 --> 00:18:19,490
but I can't guess the bits
of key material directly,

351
00:18:19,490 --> 00:18:23,530
instead, I have to
guess bits of a function

352
00:18:23,530 --> 00:18:26,880
of the key material and
use those constraints

353
00:18:26,880 --> 00:18:29,253
to limit what the key material could be.

354
00:18:30,700 --> 00:18:35,610
This first part is CRC32
of the initial key0 value

355
00:18:35,610 --> 00:18:36,833
with the zero byte.

356
00:18:38,010 --> 00:18:41,340
Since CRC32 itself is invertible,

357
00:18:41,340 --> 00:18:43,330
once I guess these four bytes,

358
00:18:43,330 --> 00:18:45,970
there's a very simple
linear operation I do

359
00:18:45,970 --> 00:18:49,163
to recover the initial key0 value itself.

360
00:18:50,410 --> 00:18:53,230
With key1, that's a
little more complicated.

361
00:18:53,230 --> 00:18:55,410
We take the initial key1 value

362
00:18:55,410 --> 00:18:57,704
and multiply it by this constant

363
00:18:57,704 --> 00:19:00,680
from the truncated linear
congruential generator

364
00:19:00,680 --> 00:19:01,993
to the nth power.

365
00:19:02,900 --> 00:19:06,590
And I'm guessing the
high byte of that value.

366
00:19:06,590 --> 00:19:09,250
Given four of these, that'll
put enough constraints

367
00:19:09,250 --> 00:19:13,330
on key1 that I can brute
force it and figure out

368
00:19:13,330 --> 00:19:17,260
what key1 is given those four bytes.

369
00:19:17,260 --> 00:19:20,253
The initial value of key2,
I can guess directly.

370
00:19:21,920 --> 00:19:25,200
So in the first stage, I
guess these five bytes,

371
00:19:25,200 --> 00:19:29,060
that's 40 bits and I guess for carry bits.

372
00:19:29,060 --> 00:19:30,830
These carry bits come

373
00:19:30,830 --> 00:19:34,993
from the possibility

374
00:19:34,993 --> 00:19:37,410
that when I add one

375
00:19:37,410 --> 00:19:40,430
in the truncated linear
congruential generator,

376
00:19:40,430 --> 00:19:43,200
it carries over all the way

377
00:19:45,109 --> 00:19:47,273
to the 24th bit,

378
00:19:48,170 --> 00:19:52,530
which would change the value
of this most significant byte.

379
00:19:52,530 --> 00:19:54,730
So I have to guess these carry bits,

380
00:19:54,730 --> 00:19:58,280
I need to guess two for each
file, there are two files

381
00:19:59,420 --> 00:20:02,090
because I have two passes of encryption

382
00:20:02,090 --> 00:20:03,950
that I do to each byte.

383
00:20:03,950 --> 00:20:07,890
So two passes of encryption,
two files makes four carry bits

384
00:20:07,890 --> 00:20:09,410
that need to be guessed.

385
00:20:09,410 --> 00:20:13,440
So the total work for this
stage is two to the 44th

386
00:20:13,440 --> 00:20:16,844
and after filtering the
16 bits from the file,

387
00:20:16,844 --> 00:20:20,523
I get two to the 28th key guesses passing.

388
00:20:21,820 --> 00:20:26,690
In stage two, I guess these
three bytes that's 24 bits,

389
00:20:26,690 --> 00:20:29,250
four more carry bits makes 28,

390
00:20:29,250 --> 00:20:32,410
added to the previous two
to the 28th key guesses,

391
00:20:32,410 --> 00:20:35,450
I have two to the 56th keys to filter.

392
00:20:35,450 --> 00:20:38,623
And after filtering
two to the 40th remain.

393
00:20:40,109 --> 00:20:41,170
In stage three,

394
00:20:41,170 --> 00:20:45,947
I guess 16 bits plus
four carry bits makes 20.

395
00:20:45,947 --> 00:20:48,050
Previous 40 carried forward,

396
00:20:48,050 --> 00:20:50,800
give us two to the 60th keys to test.

397
00:20:50,800 --> 00:20:54,163
And after filtering two to
the 44th pass the third stage.

398
00:20:55,844 --> 00:20:59,900
In the fourth stage, I guess 16,

399
00:20:59,900 --> 00:21:02,630
as before four carry bits gives us 20,

400
00:21:02,630 --> 00:21:06,470
44 from the previous
stage, 20 now makes 64.

401
00:21:06,470 --> 00:21:10,030
This was the most complicated
stage, two to the 64th.

402
00:21:10,030 --> 00:21:13,070
After filtering, two to the 48th remain.

403
00:21:13,070 --> 00:21:16,080
Now in my original attack,
this is where I would stop.

404
00:21:16,080 --> 00:21:18,380
I have all the key material,

405
00:21:18,380 --> 00:21:21,926
with these four bytes
I can brute force key1,

406
00:21:21,926 --> 00:21:25,760
run through the two to
the 32 possibilities

407
00:21:25,760 --> 00:21:28,430
and get the value itself.

408
00:21:28,430 --> 00:21:31,093
I can invert this and that would work.

409
00:21:32,190 --> 00:21:34,250
But at this point it struck me

410
00:21:34,250 --> 00:21:37,310
if I have to do two to the 32 work

411
00:21:37,310 --> 00:21:40,662
for each of these two to the 48 keys,

412
00:21:40,662 --> 00:21:45,517
that will give a total
cost of two to the 80th.

413
00:21:45,517 --> 00:21:49,560
And there was no way we could
do a two to the 80th attack.

414
00:21:49,560 --> 00:21:54,560
So I had to come up with special approach,

415
00:21:54,770 --> 00:21:57,060
a new idea

416
00:21:57,060 --> 00:22:01,893
to make this step much less expensive.

417
00:22:03,240 --> 00:22:06,220
I remembered having read
somewhere about an attack

418
00:22:06,220 --> 00:22:08,420
on truncated linear
congruential generators

419
00:22:08,420 --> 00:22:10,253
that uses lattice reduction.

420
00:22:11,230 --> 00:22:13,244
Lattice reduction is the idea

421
00:22:13,244 --> 00:22:16,690
that if you have a lattice
which is like a vector space,

422
00:22:16,690 --> 00:22:21,690
but only integer coordinates
and a basis for that lattice,

423
00:22:21,863 --> 00:22:26,360
then you can find a nicer basis

424
00:22:26,360 --> 00:22:28,910
or a nicer means that
the vectors are shorter

425
00:22:28,910 --> 00:22:30,600
and closer orthogonal.

426
00:22:30,600 --> 00:22:33,180
So here I have a two dimensional lattice,

427
00:22:33,180 --> 00:22:35,420
here's a basis for that lattice

428
00:22:35,420 --> 00:22:38,780
where one of these goes
here and another goes there.

429
00:22:38,780 --> 00:22:41,680
Every point on this grid has a coordinate

430
00:22:41,680 --> 00:22:44,730
in terms of how many steps of this kind

431
00:22:44,730 --> 00:22:48,110
and how many steps of that
kind it takes to get there.

432
00:22:48,110 --> 00:22:50,620
But lattice reduction gives
you a much nicer basis.

433
00:22:50,620 --> 00:22:53,523
These are both shorter and
closer to our orthogonal.

434
00:22:56,630 --> 00:23:00,590
Lattice reduction is in
general a hard problem

435
00:23:00,590 --> 00:23:01,940
about half of the candidates

436
00:23:01,940 --> 00:23:04,550
for the post quantum cryptography ciphers

437
00:23:04,550 --> 00:23:08,150
that NIST is considering right
now, use lattice reduction,

438
00:23:08,150 --> 00:23:09,802
for example, NTRU,

439
00:23:09,802 --> 00:23:12,350
but in small cases, it's tractable

440
00:23:12,350 --> 00:23:14,103
and I had a very small case,

441
00:23:15,600 --> 00:23:18,050
only four or five dimensional.

442
00:23:18,050 --> 00:23:19,640
So I went and poked around

443
00:23:19,640 --> 00:23:23,410
on the Cryptography Stack Exchange

444
00:23:23,410 --> 00:23:26,020
and found exactly what I needed.

445
00:23:26,020 --> 00:23:28,540
The vectors in this case,

446
00:23:28,540 --> 00:23:32,005
the basis vectors, were
powers of the constant

447
00:23:32,005 --> 00:23:35,280
from the truncated linear
congruential generator.

448
00:23:35,280 --> 00:23:36,170
In our case,

449
00:23:36,170 --> 00:23:40,573
it was 08 08 84 05 in hex.

450
00:23:43,900 --> 00:23:47,430
If we call that c then c and c squared

451
00:23:47,430 --> 00:23:50,120
and c cubed and c to the forth and so on

452
00:23:50,120 --> 00:23:52,567
become basis vectors for this lattice.

453
00:23:52,567 --> 00:23:55,760
And then you add in one more
basis vector for the modulus,

454
00:23:55,760 --> 00:23:59,780
which in our case was two
to the 32, here called M.

455
00:23:59,780 --> 00:24:02,190
So the idea was

456
00:24:02,190 --> 00:24:05,790
that given the four most significant bytes

457
00:24:05,790 --> 00:24:10,790
of the key1 value times this
consecutive powers of c,

458
00:24:11,450 --> 00:24:15,080
I would do a linear
transformation, get a value

459
00:24:15,080 --> 00:24:17,530
that was close to a basis vector

460
00:24:17,530 --> 00:24:22,160
in this small vector basis,

461
00:24:22,160 --> 00:24:25,810
but then round off to get
it exactly to a basis vector

462
00:24:25,810 --> 00:24:27,490
and then transform back

463
00:24:27,490 --> 00:24:32,463
and that would give me
the exact value of key10.

464
00:24:33,380 --> 00:24:36,470
So I wrote up a Sage program to figure out

465
00:24:36,470 --> 00:24:38,133
how exactly that would work.

466
00:24:39,260 --> 00:24:40,990
Sage is a library for Python

467
00:24:40,990 --> 00:24:44,733
that lets you do linear algebra,
among many other things.

468
00:24:46,240 --> 00:24:50,470
So here we have the modulus two to the 32,

469
00:24:50,470 --> 00:24:51,610
we have the constant

470
00:24:51,610 --> 00:24:54,060
from the truncated linear
congruential generator,

471
00:24:55,030 --> 00:24:57,470
we have the matrix that defines the basis

472
00:24:57,470 --> 00:24:59,653
for our four dimensional vector space.

473
00:25:00,500 --> 00:25:05,380
Now the vectors themselves are the modulus

474
00:25:05,380 --> 00:25:07,870
and the powers of the constant

475
00:25:07,870 --> 00:25:09,893
with minus ones on the diagonal.

476
00:25:10,760 --> 00:25:12,803
This does the lattice reduction step.

477
00:25:13,650 --> 00:25:16,540
Now to test how b worked,

478
00:25:16,540 --> 00:25:19,660
I would generate a random initial k1 value

479
00:25:20,530 --> 00:25:24,663
then compute the actual powers

480
00:25:25,560 --> 00:25:29,750
of c times k1 modular M

481
00:25:29,750 --> 00:25:32,240
that I was going to try to recover.

482
00:25:32,240 --> 00:25:34,170
So I'd print these out.

483
00:25:34,170 --> 00:25:35,890
The most significant bytes were the things

484
00:25:35,890 --> 00:25:37,340
that I had guessed.

485
00:25:37,340 --> 00:25:40,583
I wanted to recover ks from the msbs.

486
00:25:41,580 --> 00:25:43,500
So the secret stuff

487
00:25:43,500 --> 00:25:47,060
that I needed to know
were the low 24 bits,

488
00:25:47,060 --> 00:25:50,780
the part that I had masked off up here.

489
00:25:50,780 --> 00:25:55,780
So this is the secret 24-bit
values that I need to guess.

490
00:25:56,140 --> 00:26:00,000
Given the vector, that is
the most significant bytes,

491
00:26:00,000 --> 00:26:02,220
I multiplied it by b, which switched

492
00:26:02,220 --> 00:26:06,500
from one lattice to the
other, did a basis change.

493
00:26:06,500 --> 00:26:09,420
Then I rounded to the nearest vector

494
00:26:09,420 --> 00:26:14,420
in this nicer basis.

495
00:26:14,530 --> 00:26:17,680
And that meant that I would get

496
00:26:17,680 --> 00:26:20,090
an actual value of k10

497
00:26:20,090 --> 00:26:23,543
that would produce those
same, most significant bytes.

498
00:26:24,540 --> 00:26:28,548
Then I reversed that transformed back

499
00:26:28,548 --> 00:26:31,440
and got the guess and I print it out.

500
00:26:31,440 --> 00:26:36,160
And when I started doing this,
the guess was never right

501
00:26:36,160 --> 00:26:38,363
or rarely right.

502
00:26:39,290 --> 00:26:42,919
And that was because of the limited number

503
00:26:42,919 --> 00:26:44,863
of guesses I had here.

504
00:26:48,410 --> 00:26:53,410
If I could do one more
stage, then I would be able

505
00:26:55,831 --> 00:26:57,550
to get the right answer every time,

506
00:26:57,550 --> 00:27:01,130
but here I had two few powers of c

507
00:27:01,130 --> 00:27:04,616
to find out what it was exactly,

508
00:27:04,616 --> 00:27:06,980
but then I started checking the difference

509
00:27:06,980 --> 00:27:09,823
between the guess and the actual value.

510
00:27:10,780 --> 00:27:14,190
So I'd take the keys,
subtract off the msbs

511
00:27:14,190 --> 00:27:16,143
and the difference between the guess

512
00:27:16,143 --> 00:27:17,770
and the actual one

513
00:27:22,660 --> 00:27:23,990
turned out to fall

514
00:27:23,990 --> 00:27:28,400
into one of 36 possibilities, every time.

515
00:27:28,400 --> 00:27:30,410
So as I thought about it, I realized that

516
00:27:30,410 --> 00:27:33,130
in this four dimensional space,

517
00:27:33,130 --> 00:27:36,000
by truncating it and just using
the most significant bytes,

518
00:27:36,000 --> 00:27:38,310
I was adding a bunch of noise.

519
00:27:38,310 --> 00:27:41,150
And so the point

520
00:27:41,150 --> 00:27:44,430
in the four dimensional space I wanted,

521
00:27:44,430 --> 00:27:46,470
was at the center of a cell

522
00:27:46,470 --> 00:27:49,980
and what I was actually getting
was a point near the whole

523
00:27:49,980 --> 00:27:51,750
of this cell

524
00:27:52,960 --> 00:27:55,493
that tiled this four dimensional space.

525
00:27:57,860 --> 00:28:01,750
So because it was always within this cell,

526
00:28:01,750 --> 00:28:03,390
there were only a finite number

527
00:28:03,390 --> 00:28:07,003
of other possible lattice
points that it could be.

528
00:28:08,720 --> 00:28:10,800
And so I computed

529
00:28:10,800 --> 00:28:15,700
for all of the two to the
32 possible k10 values,

530
00:28:15,700 --> 00:28:19,060
what the set of guesses were

531
00:28:19,910 --> 00:28:23,710
and found that they fit
into this one of 36 classes.

532
00:28:23,710 --> 00:28:25,000
And so instead of having

533
00:28:25,000 --> 00:28:29,170
to try out all two to the
32 possible key1s each time,

534
00:28:29,170 --> 00:28:31,510
I would only have to do 36.

535
00:28:31,510 --> 00:28:34,840
So instead of 4 billion, 36 values,

536
00:28:34,840 --> 00:28:36,840
and that made the attack feasible again.

537
00:28:38,610 --> 00:28:40,340
Once we'd guessed all the key material,

538
00:28:40,340 --> 00:28:43,906
we could filter the two to
the 48th keys at stage four,

539
00:28:43,906 --> 00:28:46,963
by using the remaining bytes
in the encryption header.

540
00:28:48,200 --> 00:28:50,570
My business partner Nash
Foster then started working

541
00:28:50,570 --> 00:28:54,546
on adapting my CPU based
attack to run on GPUs.

542
00:28:54,546 --> 00:28:57,330
He wrote the code harness
for getting code and data

543
00:28:57,330 --> 00:29:00,090
onto the GPUs, did all the kudos stuff,

544
00:29:00,090 --> 00:29:02,960
advised me on how to structure the attack.

545
00:29:02,960 --> 00:29:04,480
We discovered very quickly though,

546
00:29:04,480 --> 00:29:07,060
that getting the
petabytes of possible keys

547
00:29:07,060 --> 00:29:09,250
onto the GPU would take too long

548
00:29:09,250 --> 00:29:11,060
that the GPS would just be sitting idle

549
00:29:11,060 --> 00:29:13,600
for most of the time we
were paying for them waiting

550
00:29:13,600 --> 00:29:16,520
for the data to arrive to process.

551
00:29:16,520 --> 00:29:18,690
So I went back to the drawing board

552
00:29:18,690 --> 00:29:20,770
and each stage, I was guessing
of whole bunch of bits,

553
00:29:20,770 --> 00:29:24,380
and then filtering those
results using the two bytes

554
00:29:24,380 --> 00:29:26,660
from the two archives in the file

555
00:29:26,660 --> 00:29:30,460
and I'd only keep about one out of 65,000.

556
00:29:30,460 --> 00:29:34,170
If I had some way of using that
information to derive bits,

557
00:29:34,170 --> 00:29:36,720
rather than just guessing and checking

558
00:29:36,720 --> 00:29:37,710
and save a lot of work

559
00:29:37,710 --> 00:29:40,420
and more importantly, a
lot of network traffic.

560
00:29:40,420 --> 00:29:41,983
The problem with that idea was

561
00:29:41,983 --> 00:29:44,760
that the math is too complicated.

562
00:29:44,760 --> 00:29:48,270
It involves mixing finite
fields with integer rings

563
00:29:48,270 --> 00:29:51,360
and those simply don't play well together.

564
00:29:51,360 --> 00:29:52,193
So I thought about

565
00:29:52,193 --> 00:29:54,280
some other cryptanalytic attacks I knew,

566
00:29:54,280 --> 00:29:55,770
and one that seemed promising,

567
00:29:55,770 --> 00:29:57,433
was a meet-in-the-middle attack.

568
00:29:58,760 --> 00:30:00,960
A meet-in-the-middle
attack, usually applies

569
00:30:00,960 --> 00:30:02,313
to block ciphers.

570
00:30:03,550 --> 00:30:05,710
One that uses part of the key material

571
00:30:05,710 --> 00:30:08,040
to do the first half of the encryption

572
00:30:08,040 --> 00:30:09,730
and the second part of the key material

573
00:30:09,730 --> 00:30:11,730
to do the second half of the encryption.

574
00:30:13,014 --> 00:30:17,173
The reason we have triple
DES instead of double DES,

575
00:30:19,670 --> 00:30:22,130
is precisely because of this,

576
00:30:22,130 --> 00:30:26,070
triple DES is 112 bit cipher,

577
00:30:26,070 --> 00:30:28,283
even though there are three keys involved.

578
00:30:30,280 --> 00:30:32,940
You can do encrypt and
decrypt and then encrypt.

579
00:30:32,940 --> 00:30:34,830
So 112 bits of strength.

580
00:30:34,830 --> 00:30:39,547
If it's 112 bits why not
just do DES with one key

581
00:30:39,547 --> 00:30:42,300
and then DES with another
key, encrypting it twice?

582
00:30:42,300 --> 00:30:44,300
Well, the answer is right here.

583
00:30:44,300 --> 00:30:48,723
What you do is, you take your
plaintext ciphertext pair

584
00:30:48,723 --> 00:30:50,726
and then encrypt the plaintext

585
00:30:50,726 --> 00:30:55,650
under all two to the 56
possible first DES keys,

586
00:30:55,650 --> 00:30:58,520
and then you take the
cipher text and decrypt it

587
00:30:58,520 --> 00:31:01,580
under all possible two to the 56 DES keys.

588
00:31:01,580 --> 00:31:04,180
And right here in the middle chances are

589
00:31:04,180 --> 00:31:06,303
that one of them will match.

590
00:31:07,230 --> 00:31:11,340
And so you sort all of these
intermediate plaintexts,

591
00:31:11,340 --> 00:31:12,690
and whenever you find

592
00:31:14,020 --> 00:31:17,090
two intermediate texts

593
00:31:17,090 --> 00:31:20,197
that are the same, one of
them came from the plaintext

594
00:31:20,197 --> 00:31:22,060
and one came from the ciphertext

595
00:31:22,060 --> 00:31:24,960
and that uniquely identifies the key

596
00:31:24,960 --> 00:31:27,090
that should go between these two.

597
00:31:27,090 --> 00:31:30,350
So a meet-in-the-middle attack works

598
00:31:30,350 --> 00:31:31,700
when you've got key material

599
00:31:31,700 --> 00:31:36,700
that is not all used

600
00:31:36,950 --> 00:31:39,180
at every stage of the cipher,

601
00:31:39,180 --> 00:31:40,890
and in this stream cipher,

602
00:31:40,890 --> 00:31:42,220
that seemed to be the case, right?

603
00:31:42,220 --> 00:31:46,140
I had only key0 at the
beginning and only key2

604
00:31:46,140 --> 00:31:49,490
at the end, and it seemed
like we could do something

605
00:31:49,490 --> 00:31:54,113
in the middle, but it wasn't quite right.

606
00:31:54,960 --> 00:31:57,720
But then I realized I could
use the XOR of certain bytes

607
00:31:57,720 --> 00:32:00,120
in the middle of the
cipher to mount the attack.

608
00:32:01,730 --> 00:32:04,570
Here's a diagram of the cipher again,

609
00:32:04,570 --> 00:32:06,530
and the cipher gets called four times

610
00:32:06,530 --> 00:32:08,873
in each stage for each byte.

611
00:32:10,670 --> 00:32:13,730
Two for each file, the double encryption

612
00:32:13,730 --> 00:32:16,170
of the byte from rand().

613
00:32:16,170 --> 00:32:19,750
So in the center of the cipher,

614
00:32:19,750 --> 00:32:23,070
there are four different
most significant bytes

615
00:32:23,070 --> 00:32:27,830
for key1 after each of these encryptions.

616
00:32:27,830 --> 00:32:32,830
So what I did was take
the first of those four

617
00:32:32,840 --> 00:32:36,240
and exclusive or with
each of the other three

618
00:32:36,240 --> 00:32:39,380
to get a 24-bit key into a table

619
00:32:39,380 --> 00:32:43,493
and under that key, I would
store my guess for these bits.

620
00:32:45,360 --> 00:32:49,290
Then from the other side,
given a stream byte,

621
00:32:49,290 --> 00:32:54,290
there are 64 possible 14-bit values here.

622
00:32:54,300 --> 00:32:58,300
So I would guess some
intermediate stream bytes,

623
00:32:58,300 --> 00:33:02,950
six bits of this, I guess it's boxed here,

624
00:33:02,950 --> 00:33:06,960
these six bits to figure out
what the other eight are.

625
00:33:06,960 --> 00:33:10,570
And that would allow me to
derive linearly from this stuff,

626
00:33:10,570 --> 00:33:15,570
what this most significant
byte of key1 was again.

627
00:33:15,810 --> 00:33:20,160
And so given these bits
that I was guessing,

628
00:33:20,160 --> 00:33:24,570
I would derive a key and store
these bits under that key.

629
00:33:24,570 --> 00:33:27,463
And then anytime I had a collision,

630
00:33:28,382 --> 00:33:31,210
I would know that the set

631
00:33:31,210 --> 00:33:34,610
of bits here

632
00:33:34,610 --> 00:33:39,030
that I guessed were consistent
with the set of bits here

633
00:33:39,030 --> 00:33:42,270
that I guessed to give this plaintext

634
00:33:42,270 --> 00:33:44,563
to go into that stream byte.

635
00:33:46,940 --> 00:33:49,300
Now that is far smaller

636
00:33:49,300 --> 00:33:54,300
than running through
all of the possibilities

637
00:33:55,230 --> 00:33:56,293
and then filtering.

638
00:33:57,600 --> 00:33:59,840
The amount of memory it required was

639
00:34:01,400 --> 00:34:03,770
on the order of a few megabytes.

640
00:34:03,770 --> 00:34:06,824
So here is the code itself.

641
00:34:06,824 --> 00:34:11,283
This is stage1a moving
forward through the cipher,

642
00:34:11,283 --> 00:34:14,780
we guess the initial stream byte,

643
00:34:14,780 --> 00:34:17,550
because it was XORed with itself twice,

644
00:34:17,550 --> 00:34:18,910
we have no information about it,

645
00:34:18,910 --> 00:34:20,710
so we would guess that one.

646
00:34:20,710 --> 00:34:25,245
Then would guess chunk2,
which came from CRC32 of key0,

647
00:34:25,245 --> 00:34:28,803
chunk3 is the most
significant byte of key1.

648
00:34:30,610 --> 00:34:33,660
Here are the carry bits.

649
00:34:33,660 --> 00:34:36,690
There are two bits for
each of the two files,

650
00:34:36,690 --> 00:34:40,633
so two to the fourth is
16 possible carry bits.

651
00:34:44,190 --> 00:34:48,210
This is debugging code
for checking against files

652
00:34:48,210 --> 00:34:49,833
that we created ourselves.

653
00:34:51,830 --> 00:34:54,400
This is the first half of the cipher

654
00:34:54,400 --> 00:34:57,630
and it updates an upper and a lower bound

655
00:34:57,630 --> 00:35:02,610
on the possible low 24 bits of key1.

656
00:35:02,610 --> 00:35:06,460
So that if it ever goes out of
bounds, we can throw it away.

657
00:35:09,330 --> 00:35:14,010
We compute various
bytes, get through here.

658
00:35:14,010 --> 00:35:17,680
If it has passed all of these
upper and lower bounds checks,

659
00:35:17,680 --> 00:35:21,640
then this converts those
four most significant bytes

660
00:35:21,640 --> 00:35:25,910
to a mapkey and stores the candidate

661
00:35:25,910 --> 00:35:28,047
under that mapkey.

662
00:35:30,032 --> 00:35:31,163
And the second half,

663
00:35:32,940 --> 00:35:37,940
we're guessing the stream one x byte

664
00:35:38,430 --> 00:35:40,083
for file zero.

665
00:35:40,940 --> 00:35:43,500
We're guessing the 64-bit prefix

666
00:35:43,500 --> 00:35:48,500
because each stream byte
has 64 possible preimages

667
00:35:49,730 --> 00:35:52,340
under the pseudo squaring operation.

668
00:35:52,340 --> 00:35:54,730
So these are all of the indexed preimages,

669
00:35:54,730 --> 00:35:58,983
and this gets the specific
preimage that we're caring about.

670
00:36:00,098 --> 00:36:02,030
There's more debugging information.

671
00:36:02,030 --> 00:36:04,320
Again, we do the second half step,

672
00:36:04,320 --> 00:36:08,314
and if there are no consistent results,

673
00:36:08,314 --> 00:36:12,140
then we just go to the next guess.

674
00:36:12,140 --> 00:36:16,943
Here, we're guessing the
stream one x pass for file one.

675
00:36:17,800 --> 00:36:19,910
We do that second half step.

676
00:36:19,910 --> 00:36:22,100
And again, if there
are no consistent ones,

677
00:36:22,100 --> 00:36:23,823
we go back to the next guess.

678
00:36:25,160 --> 00:36:26,670
Finally, we compute

679
00:36:26,670 --> 00:36:31,670
the stream one y bytes.

680
00:36:31,746 --> 00:36:35,750
And if there are no consistent ones

681
00:36:35,750 --> 00:36:38,020
with that prefix, we continue.

682
00:36:38,020 --> 00:36:40,300
So now given each of the possibilities

683
00:36:40,300 --> 00:36:44,620
for the first and second and third bytes,

684
00:36:44,620 --> 00:36:46,543
we put them together into a mapkey

685
00:36:48,810 --> 00:36:51,993
and then meet in the middle.

686
00:36:55,100 --> 00:36:57,293
Here is the CRC20.

687
00:36:59,020 --> 00:37:00,497
If you'd like to look at the code,

688
00:37:00,497 --> 00:37:03,920
you can see how these
exclusive ored together

689
00:37:03,920 --> 00:37:05,910
and we can derive some certain things.

690
00:37:05,910 --> 00:37:10,340
So starting at the bottom,
we derive bits 15 to 2

691
00:37:10,340 --> 00:37:11,930
of K and L

692
00:37:11,930 --> 00:37:14,450
from 15 to 2 of S and T

693
00:37:15,670 --> 00:37:18,873
and these bytes, O, P that we've computed.

694
00:37:19,860 --> 00:37:21,203
So in the center,

695
00:37:24,640 --> 00:37:28,177
we find those groups those guesses

696
00:37:30,390 --> 00:37:35,390
that work and we push back that guess

697
00:37:35,720 --> 00:37:38,460
whenever the two match up with each other

698
00:37:38,460 --> 00:37:40,640
and here's some more
debugging information.

699
00:37:40,640 --> 00:37:42,690
So that's the idea

700
00:37:42,690 --> 00:37:44,670
of the differential
meet-in-the-middle attack,

701
00:37:44,670 --> 00:37:48,556
is computing forwards and
backwards exclusive oring one

702
00:37:48,556 --> 00:37:50,870
of the bytes with the other three

703
00:37:50,870 --> 00:37:54,053
and then whenever the two guesses match,

704
00:37:55,530 --> 00:37:56,670
we have a set of candidates

705
00:37:56,670 --> 00:37:58,610
that's a product of the set

706
00:37:58,610 --> 00:38:01,590
from the first half of the attack

707
00:38:01,590 --> 00:38:03,900
with the set from the
second half of the attack.

708
00:38:03,900 --> 00:38:05,940
Using the differential
meet-in-the-middle attack

709
00:38:05,940 --> 00:38:08,810
on stage one and stage two allowed us

710
00:38:08,810 --> 00:38:12,050
to reduce the complexity
of the attack in stage one

711
00:38:12,050 --> 00:38:15,110
from two to the 40th,
down to two to the 22nd.

712
00:38:15,110 --> 00:38:18,810
That's from trillions
down to mere millions.

713
00:38:18,810 --> 00:38:22,770
And then in stage two
from two to the 56th down

714
00:38:22,770 --> 00:38:24,460
to two to the 40th,

715
00:38:24,460 --> 00:38:27,790
and that let us run stages one and two

716
00:38:27,790 --> 00:38:31,450
on each of the machines that
had GPUs attached to it.

717
00:38:31,450 --> 00:38:33,490
We completely eliminated the need

718
00:38:33,490 --> 00:38:37,040
to ship batches keys over the network.

719
00:38:37,040 --> 00:38:39,590
And so we could generate the keys in place

720
00:38:39,590 --> 00:38:43,010
and then run what we called
the GPU stage three kernel

721
00:38:43,010 --> 00:38:44,893
that did all the rest of the attack.

722
00:38:45,870 --> 00:38:47,693
Now we ran it for 10 days.

723
00:38:48,660 --> 00:38:52,640
We had tried it on all
of our test archives

724
00:38:52,640 --> 00:38:54,733
that we'd created, it worked fine.

725
00:38:56,470 --> 00:39:00,687
10 days passed, and it didn't find a key

726
00:39:00,687 --> 00:39:03,000
and we were distraught
pulling our hair out,

727
00:39:03,000 --> 00:39:04,230
what have we done wrong?

728
00:39:04,230 --> 00:39:06,480
We went back and discovered

729
00:39:06,480 --> 00:39:09,430
that there were a few other process IDs

730
00:39:09,430 --> 00:39:11,000
that could have worked.

731
00:39:11,000 --> 00:39:12,870
And we were wondering,
"Oh, no, are we gonna have

732
00:39:12,870 --> 00:39:14,947
to do this four more times?"

733
00:39:16,670 --> 00:39:20,837
But then our client who was a
programmer himself discovered

734
00:39:21,760 --> 00:39:25,330
that there was a bug

735
00:39:25,330 --> 00:39:29,910
between the GPU stage and the CPU stage.

736
00:39:29,910 --> 00:39:32,570
So when I had run the
tests, I had done it locally

737
00:39:32,570 --> 00:39:37,340
on my computer using the CPU version

738
00:39:37,340 --> 00:39:40,350
and the test, we knew exactly
where the key had to be

739
00:39:40,350 --> 00:39:43,580
so it was a very small piece of key space

740
00:39:43,580 --> 00:39:45,410
that we had to check,

741
00:39:45,410 --> 00:39:47,350
but when my client went back

742
00:39:47,350 --> 00:39:51,010
and tried it again using
the GPU stage three,

743
00:39:51,010 --> 00:39:52,460
he discovered that

744
00:39:52,460 --> 00:39:57,350
when the key candidate was
the first one in a list,

745
00:39:57,350 --> 00:40:01,340
it succeeded, but when it was
the second one, it failed.

746
00:40:01,340 --> 00:40:03,963
And that led me to this line right here.

747
00:40:05,060 --> 00:40:09,030
We had swapped the thread
index with the block index.

748
00:40:09,030 --> 00:40:14,030
So instead of incrementing by
one into the current block,

749
00:40:15,480 --> 00:40:17,370
it would increment the block number

750
00:40:17,370 --> 00:40:20,547
and go off into space
that was uninitialized,

751
00:40:20,547 --> 00:40:22,343
and so it would never work.

752
00:40:23,510 --> 00:40:27,040
So by switching the block
index with the thread index,

753
00:40:27,040 --> 00:40:28,960
we started the search over again

754
00:40:28,960 --> 00:40:32,240
within a day and a half,
we had found the three keys

755
00:40:33,477 --> 00:40:35,580
that decrypted the archive

756
00:40:35,580 --> 00:40:40,053
and our client was able to
get his Bitcoin keys out.

757
00:40:41,700 --> 00:40:42,960
In the end, the improvements

758
00:40:42,960 --> 00:40:47,220
that I made to my old attack
took it from something

759
00:40:47,220 --> 00:40:51,160
that we estimated that
approximately $100,000

760
00:40:52,070 --> 00:40:55,880
and a year of processing down to something

761
00:40:55,880 --> 00:40:58,960
that took about $10,000 of GPU time

762
00:40:58,960 --> 00:41:00,903
and a little under two weeks.

763
00:41:02,050 --> 00:41:05,340
Our client was very pleased
and gave us a big bonus.

764
00:41:05,340 --> 00:41:08,420
And that's how we recovered
his Bitcoin folder.

765
00:41:08,420 --> 00:41:09,420
Thank you very much.

