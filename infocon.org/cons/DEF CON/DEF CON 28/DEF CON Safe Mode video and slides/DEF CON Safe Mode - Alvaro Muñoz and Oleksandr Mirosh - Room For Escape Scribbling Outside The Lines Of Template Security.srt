1
00:00:09,560 --> 00:00:11,780
- Hi, welcome, thanks
for attending our talk.

2
00:00:11,780 --> 00:00:13,680
This is Room For Escape:

3
00:00:13,680 --> 00:00:16,640
Scribbling Outside The
Lines of Templates Security.

4
00:00:16,640 --> 00:00:18,390
So my name is Alvaro Munoz also known as

5
00:00:18,390 --> 00:00:20,340
pwntester in the social media.

6
00:00:20,340 --> 00:00:21,989
I'm Security Researcher
with a GitHub Security Lab,

7
00:00:21,989 --> 00:00:25,670
and with me, my colleague Oleksandr Mirosh

8
00:00:25,670 --> 00:00:27,259
also known as olekmirosh in Twitter,

9
00:00:27,259 --> 00:00:31,940
and he is Security Researcher
with Micro Focus Fortify team.

10
00:00:31,940 --> 00:00:33,670
So today we will be reviewing

11
00:00:33,670 --> 00:00:37,010
the security of Content
Management Systems or CMS.

12
00:00:37,010 --> 00:00:39,630
And basically we will be focusing on

13
00:00:39,630 --> 00:00:43,893
the security of the template
systems that are used by CMS.

14
00:00:44,760 --> 00:00:47,660
so a Content Management System
is basically an application

15
00:00:47,660 --> 00:00:50,960
that is used to manage
different types of web content

16
00:00:50,960 --> 00:00:53,300
so that users can actually create,

17
00:00:53,300 --> 00:00:56,360
upload and publish
different type of content.

18
00:00:56,360 --> 00:01:00,330
So normally this content
is based on some structure,

19
00:01:00,330 --> 00:01:03,700
some kind of documents called templates,

20
00:01:03,700 --> 00:01:07,440
which are used to generate
and create dynamic content.

21
00:01:07,440 --> 00:01:10,900
So these templates normally allow a subset

22
00:01:10,900 --> 00:01:13,690
of different programming
language capabilities,

23
00:01:13,690 --> 00:01:15,850
so they are powerful in the sense that

24
00:01:15,850 --> 00:01:18,970
they can be used to run arbitrary code.

25
00:01:18,970 --> 00:01:20,950
Because of that, they
are normally Sandboxed

26
00:01:20,950 --> 00:01:23,510
in order to prevent
arbitrary code execution

27
00:01:23,510 --> 00:01:24,810
and remote code execution.

28
00:01:25,855 --> 00:01:28,827
So our research will focus on both

29
00:01:28,827 --> 00:01:32,210
.Net and Java based
Content Management Systems,

30
00:01:32,210 --> 00:01:34,010
because these are the languages

31
00:01:34,010 --> 00:01:37,390
that are more prevalent
across enterprises.

32
00:01:37,390 --> 00:01:39,530
And our assumption is that

33
00:01:39,530 --> 00:01:42,130
the attacker can control
the templates, right?

34
00:01:42,130 --> 00:01:45,370
So we don't really care
about how the attacker

35
00:01:45,370 --> 00:01:47,730
gets control of these
templates in the first place.

36
00:01:47,730 --> 00:01:50,960
If it's through a separate
site template injection,

37
00:01:50,960 --> 00:01:53,760
or if it's maybe through
our cross-site scripting

38
00:01:53,760 --> 00:01:56,660
that allows him to submit
arbitrary templates

39
00:01:56,660 --> 00:01:59,270
in behalf or of someone else,

40
00:01:59,270 --> 00:02:02,530
or maybe they have permissions like,

41
00:02:02,530 --> 00:02:04,860
if you are a user, for
example, in SharePoint,

42
00:02:04,860 --> 00:02:06,520
if you have an account in SharePoint,

43
00:02:06,520 --> 00:02:10,360
you are allowed to create
your own sites and content.

44
00:02:10,360 --> 00:02:12,740
So no matter how the attacker

45
00:02:12,740 --> 00:02:15,695
can edit the content of a template

46
00:02:15,695 --> 00:02:20,690
our research will focus
on escaping and breaking

47
00:02:20,690 --> 00:02:22,350
all the mitigations put in place

48
00:02:22,350 --> 00:02:24,333
to prevent arbitrary code execution.

49
00:02:25,200 --> 00:02:29,160
So we will first start with .Net,

50
00:02:29,160 --> 00:02:31,840
basically we will focus on SharePoint.

51
00:02:31,840 --> 00:02:35,270
We will present five different
ways we were able to break

52
00:02:35,270 --> 00:02:37,000
the Sandbox used by SharePoint

53
00:02:37,000 --> 00:02:39,100
to prevent arbitrary code execution.

54
00:02:39,100 --> 00:02:41,500
And then we will move into the Java part

55
00:02:41,500 --> 00:02:45,180
where we will present four
different templates engines

56
00:02:45,180 --> 00:02:46,990
including the most popular ones,

57
00:02:46,990 --> 00:02:49,360
such as Velocity and FreeMarker.

58
00:02:49,360 --> 00:02:51,110
And then we will present

59
00:02:51,110 --> 00:02:52,960
10 different Content Management Systems

60
00:02:52,960 --> 00:02:55,250
and we will try our bypasses on them.

61
00:02:55,250 --> 00:02:57,620
So we will wrap up with some
takeaways and conclusions

62
00:02:57,620 --> 00:02:59,790
and then open the floor for Q&A.

63
00:02:59,790 --> 00:03:01,740
So Let's just start with the .Net part.

64
00:03:02,770 --> 00:03:03,760
- Thanks Alvaro.

65
00:03:03,760 --> 00:03:05,530
In this part of our presentation,

66
00:03:05,530 --> 00:03:08,260
we will present different
types of security problems

67
00:03:08,260 --> 00:03:10,260
in Content Management System

68
00:03:10,260 --> 00:03:12,690
and give examples of them in SharePoint.

69
00:03:12,690 --> 00:03:13,660
But before that,

70
00:03:13,660 --> 00:03:17,904
we need to explain some
basics of SharePoint security.

71
00:03:17,904 --> 00:03:21,540
SharePoint has two types of ASPX pages,

72
00:03:21,540 --> 00:03:24,170
the first type is Application Page.

73
00:03:24,170 --> 00:03:27,370
Each of this pages are
part of SharePoint server

74
00:03:27,370 --> 00:03:30,330
and implements some application logic.

75
00:03:30,330 --> 00:03:33,440
They are stored in specific
folders on the File System,

76
00:03:33,440 --> 00:03:35,890
of course users are not
able to change them.

77
00:03:35,890 --> 00:03:38,180
They're irregular ASPX pages

78
00:03:38,180 --> 00:03:41,660
and are processed by server
without any restrictions.

79
00:03:41,660 --> 00:03:44,410
In opposite to them, there are Site Pages.

80
00:03:44,410 --> 00:03:45,840
They are stored in database

81
00:03:45,840 --> 00:03:48,430
and they can be customized even by users.

82
00:03:48,430 --> 00:03:50,640
Try upon parts of them in special mode,

83
00:03:50,640 --> 00:03:52,580
also known as safe mode.

84
00:03:52,580 --> 00:03:55,080
Actually, they're more
like some sort of templates

85
00:03:55,080 --> 00:03:57,570
for presenting dynamic content.

86
00:03:57,570 --> 00:04:00,010
On this slide, we can see a diagram

87
00:04:00,010 --> 00:04:02,662
how server works with this page.

88
00:04:02,662 --> 00:04:05,300
Virtual Provider can fetch content

89
00:04:05,300 --> 00:04:08,070
from File System or database.

90
00:04:08,070 --> 00:04:10,420
Based on the virtual
path of the current page

91
00:04:10,420 --> 00:04:14,810
SPPageParserFilter will decide either

92
00:04:14,810 --> 00:04:17,850
it is site page and save
mode should be applied,

93
00:04:17,850 --> 00:04:19,740
or it is an application page,

94
00:04:19,740 --> 00:04:22,560
and it will be processed
without any restrictions.

95
00:04:22,560 --> 00:04:26,893
So page filter is critical
element from security design.

96
00:04:28,370 --> 00:04:33,370
Let's have a look on
a sample of ASPX page.

97
00:04:33,560 --> 00:04:34,440
For our talks,

98
00:04:34,440 --> 00:04:37,370
we are only interested in
server-side components,

99
00:04:37,370 --> 00:04:38,823
for example, directives.

100
00:04:38,823 --> 00:04:40,490
They are special instruction

101
00:04:40,490 --> 00:04:43,320
on how server should
process the current page,

102
00:04:43,320 --> 00:04:46,500
often they have some number of attributes.

103
00:04:46,500 --> 00:04:48,820
We can include server-side code

104
00:04:48,820 --> 00:04:53,270
either in special blocks or
as embedded server-side code.

105
00:04:53,270 --> 00:04:55,330
To be processed by server,

106
00:04:55,330 --> 00:04:58,650
control should have the
rule, not server attribute.

107
00:04:58,650 --> 00:05:02,730
The next server element is
server-side common block.

108
00:05:02,730 --> 00:05:04,550
It is ignored by server.

109
00:05:04,550 --> 00:05:06,580
And server-side include directors

110
00:05:06,580 --> 00:05:09,763
allow us to include raw
content of arbitrary to file.

111
00:05:10,910 --> 00:05:14,560
Now we can better understand
what safe mode means,

112
00:05:14,560 --> 00:05:16,700
site Page will not be compiled.

113
00:05:16,700 --> 00:05:19,240
So we cannot use server-side code,

114
00:05:19,240 --> 00:05:22,118
we are not able to include
files from File System,

115
00:05:22,118 --> 00:05:25,110
we can only use allowed controls.

116
00:05:25,110 --> 00:05:27,540
This way is defined unsafe control section

117
00:05:27,540 --> 00:05:28,893
of web.config file.

118
00:05:29,810 --> 00:05:33,830
Page filter also applies
an Allowlist for directives

119
00:05:33,830 --> 00:05:36,670
and even for attributes of most of them.

120
00:05:36,670 --> 00:05:39,110
There are many others
restrictions, for example,

121
00:05:39,110 --> 00:05:41,960
event binding is blocked as well.

122
00:05:41,960 --> 00:05:46,110
As we can see, it is a set
of quite strong restrictions,

123
00:05:46,110 --> 00:05:47,563
how it can be bypassed.

124
00:05:49,040 --> 00:05:52,860
As we know, safe mode is
enforced by page filter.

125
00:05:52,860 --> 00:05:54,737
So our first question was,

126
00:05:54,737 --> 00:05:58,920
"Is there any place where
SharePoint does not use it?"

127
00:05:58,920 --> 00:06:01,410
And I'll say, "Yes,
there are such places".

128
00:06:01,410 --> 00:06:03,540
Page filter will not be applied

129
00:06:03,540 --> 00:06:05,560
for the content argument

130
00:06:05,560 --> 00:06:08,330
of the ParseControl method.

131
00:06:08,330 --> 00:06:10,360
If it's called only with one argument

132
00:06:10,360 --> 00:06:12,880
or even the second one
that actually has name

133
00:06:12,880 --> 00:06:15,270
ignore ParseFilter is true.

134
00:06:15,270 --> 00:06:19,220
In addition, page filter
is used at rendering time,

135
00:06:19,220 --> 00:06:21,373
but is ignored at design time.

136
00:06:22,400 --> 00:06:26,290
But, even if page filter is not applied,

137
00:06:26,290 --> 00:06:30,660
SharePoint uses another
way to provide the input.

138
00:06:30,660 --> 00:06:34,090
It is a VerifyControlOnSafeList method

139
00:06:34,090 --> 00:06:36,790
from editing PageParser type

140
00:06:36,790 --> 00:06:40,390
that aim to do the same task
at the original page filter

141
00:06:40,390 --> 00:06:43,583
the log markup is unsafe elements.

142
00:06:44,810 --> 00:06:46,500
But let's imagine for a second

143
00:06:46,500 --> 00:06:50,320
that we are able to bypass
either this method or page filter

144
00:06:50,320 --> 00:06:53,250
by the way, each side of
parse is separate (mumbles)

145
00:06:53,250 --> 00:06:55,820
and we will present them in a few minutes.

146
00:06:55,820 --> 00:06:58,720
So how could we get remote code execution

147
00:06:58,720 --> 00:07:01,290
after escaping into the safe mode?

148
00:07:01,290 --> 00:07:03,950
Remember, since ParseControl method

149
00:07:03,950 --> 00:07:05,370
never codes compilation,

150
00:07:05,370 --> 00:07:07,170
we are not able to use server-side code

151
00:07:07,170 --> 00:07:12,170
or perform any other attack
that require a compilation.

152
00:07:12,440 --> 00:07:15,460
But if it escape a safe mode,

153
00:07:15,460 --> 00:07:18,330
we can use unsafe controls or directives.

154
00:07:18,330 --> 00:07:19,780
Let's review several of them.

155
00:07:21,160 --> 00:07:23,440
One of the most interesting

156
00:07:23,440 --> 00:07:26,400
unsafe controls is ObjectDataSource.

157
00:07:26,400 --> 00:07:28,840
It allows us to invoke public methods

158
00:07:28,840 --> 00:07:30,790
from arbitrary public type.

159
00:07:30,790 --> 00:07:33,724
We can see an example of
both that uses start method

160
00:07:33,724 --> 00:07:36,550
from process type to launch calculator.

161
00:07:36,550 --> 00:07:39,750
So actually it just arbitrary
code execution, jackpot.

162
00:07:39,750 --> 00:07:43,620
But let's review a couple
other unsafe controls.

163
00:07:43,620 --> 00:07:45,900
XML data source and XML controls

164
00:07:45,900 --> 00:07:49,520
allow us to get content
of arbitrary XML files.

165
00:07:49,520 --> 00:07:51,090
The similar results we can get

166
00:07:51,090 --> 00:07:52,930
by service-side include directives

167
00:07:52,930 --> 00:07:56,070
that retain as content
defining text files.

168
00:07:56,070 --> 00:07:59,540
Let's see how we can escalate
from arbitrary file rate

169
00:07:59,540 --> 00:08:01,143
to arbitrary code execution.

170
00:08:02,010 --> 00:08:04,390
If you pick an access web config file,

171
00:08:04,390 --> 00:08:08,510
we will be able to get ValidationKey
from MachineKey section

172
00:08:09,370 --> 00:08:12,810
By the way, this value may
be present in other places

173
00:08:12,810 --> 00:08:15,480
such as internal SharePoint properties.

174
00:08:15,480 --> 00:08:18,397
We will see this example a bit later.

175
00:08:18,397 --> 00:08:20,283
this ValidationKey we can generate,

176
00:08:22,417 --> 00:08:23,250
I believe you state that to execute

177
00:08:23,250 --> 00:08:27,640
arbitrary code commands
on the target server.

178
00:08:27,640 --> 00:08:31,173
We can use tools such as
YSoSerial.net for this.

179
00:08:32,880 --> 00:08:35,470
Now, when we know what safe mode is

180
00:08:35,470 --> 00:08:37,080
and how we can compromise

181
00:08:37,080 --> 00:08:38,900
SharePoint server if we did bypass,

182
00:08:38,900 --> 00:08:42,570
we can move to our next part of this talk.

183
00:08:42,570 --> 00:08:44,560
Here, we will presented
five different types

184
00:08:44,560 --> 00:08:47,770
of security problem in
Content Management System.

185
00:08:47,770 --> 00:08:50,603
We will show examples of
each type in SharePoint.

186
00:08:51,550 --> 00:08:53,290
We would like to stress here that

187
00:08:53,290 --> 00:08:56,600
our target is SharePoint server
with default configuration.

188
00:08:56,600 --> 00:08:58,210
All we know about this allowed us

189
00:08:58,210 --> 00:09:00,800
to execute arbitrary code on the target.

190
00:09:00,800 --> 00:09:04,390
And all attacks were
performed by regular user.

191
00:09:04,390 --> 00:09:06,950
No admin rights were needed.

192
00:09:06,950 --> 00:09:07,880
That's that.

193
00:09:08,960 --> 00:09:10,739
The first type of security problems

194
00:09:10,739 --> 00:09:13,720
is access to resources
is sensitive information.

195
00:09:13,720 --> 00:09:16,330
It can be configuration
or business information

196
00:09:16,330 --> 00:09:18,240
and various files, logs,

197
00:09:18,240 --> 00:09:20,600
database or even process memory.

198
00:09:20,600 --> 00:09:23,490
Of course, proper Sandbox
should prevent this problem,

199
00:09:23,490 --> 00:09:26,250
but it is not always the case.

200
00:09:26,250 --> 00:09:28,450
We already mentioned that page filter

201
00:09:28,450 --> 00:09:30,800
block server-side includes directors.

202
00:09:30,800 --> 00:09:32,890
And to VerifyControlOnSafeList method

203
00:09:32,890 --> 00:09:35,980
should do this as well
and actually it does,

204
00:09:35,980 --> 00:09:38,530
but if it's called with false

205
00:09:38,530 --> 00:09:42,550
in blockserversiteincludes
argument, it will not block them.

206
00:09:42,550 --> 00:09:45,260
And we have found such
usage of this method,

207
00:09:45,260 --> 00:09:46,873
it was used for design mode.

208
00:09:48,220 --> 00:09:50,220
The next building block for our attack,

209
00:09:50,220 --> 00:09:53,730
how we can provide our
markup for this mode.

210
00:09:53,730 --> 00:09:57,030
We can send it in WebPartXML parameter

211
00:09:57,030 --> 00:09:59,860
of the RenderWebPartForEdit method

212
00:09:59,860 --> 00:10:01,620
of the Web Part Page services,

213
00:10:01,620 --> 00:10:05,160
so we can try to include
the web config file there.

214
00:10:05,160 --> 00:10:08,200
Here we can see the full payload
for the mentioned parameter

215
00:10:08,200 --> 00:10:10,960
and address the Levante web services.

216
00:10:10,960 --> 00:10:14,427
Server content has the entire
web config with validation key

217
00:10:14,427 --> 00:10:17,350
we use it for ViewState
based Deserialization attack,

218
00:10:17,350 --> 00:10:21,093
which led us to executing
arbitrary (mumbles) on the server.

219
00:10:23,100 --> 00:10:25,670
Time for our next type
of security problems

220
00:10:25,670 --> 00:10:27,630
in Content Management System.

221
00:10:27,630 --> 00:10:30,750
Allow dangerous element that
can be used for attacks.

222
00:10:31,816 --> 00:10:35,410
We have found an example in
SharePoint safe control list,

223
00:10:35,410 --> 00:10:39,523
or should we call it not-so-safe
control list in this case.

224
00:10:42,460 --> 00:10:46,490
It is ContactLinksSuggestionsMicroView
control.

225
00:10:46,490 --> 00:10:48,130
It consistently, but with interesting call

226
00:10:48,130 --> 00:10:50,300
from its implementation
where request parameter

227
00:10:50,300 --> 00:10:54,370
is parse to DataSetReadXML method.

228
00:10:54,370 --> 00:10:56,200
If we can control input for this method,

229
00:10:56,200 --> 00:10:58,020
we can get our data deserialized

230
00:10:58,020 --> 00:11:00,610
by XMLSerializer with control type.

231
00:11:00,610 --> 00:11:03,520
We already showed in
one of our previous work

232
00:11:03,520 --> 00:11:06,520
that in this case, we can
get arbitrary code execution.

233
00:11:06,520 --> 00:11:09,150
Unfortunately, this payload
is too big for slides,

234
00:11:09,150 --> 00:11:11,100
but you can find it in our white paper.

235
00:11:12,037 --> 00:11:16,190
The last piece of the
puzzle is our site page

236
00:11:17,668 --> 00:11:18,501
with is dangerous control,

237
00:11:18,501 --> 00:11:19,810
you can see it on this slide.

238
00:11:19,810 --> 00:11:22,440
For the attack, we just
need to place the payload

239
00:11:22,440 --> 00:11:25,490
into the TextBox and
click on submit button

240
00:11:25,490 --> 00:11:27,230
and desired command will be executed

241
00:11:27,230 --> 00:11:28,480
on the SharePoint server.

242
00:11:30,220 --> 00:11:32,470
For us, the next type of security problems

243
00:11:32,470 --> 00:11:33,690
looks quite interesting.

244
00:11:33,690 --> 00:11:35,990
So it will explain it with more details

245
00:11:35,990 --> 00:11:38,993
and present two separate
examples from SharePoint server.

246
00:11:40,210 --> 00:11:42,390
Dynamic content usually means that

247
00:11:42,390 --> 00:11:45,610
we will have at least read
access to some properties

248
00:11:45,610 --> 00:11:47,730
or attributes of some objects.

249
00:11:47,730 --> 00:11:49,260
For some system like share input

250
00:11:49,260 --> 00:11:52,200
we can even override values to that.

251
00:11:52,200 --> 00:11:54,670
Of course, Sandbox should filter out

252
00:11:54,670 --> 00:11:57,153
the access to dangerous
property or attributes.

253
00:11:58,250 --> 00:12:01,210
That review basic type of such filtering.

254
00:12:01,210 --> 00:12:03,930
The first case is when only
one level of properties

255
00:12:03,930 --> 00:12:05,490
or attributes is allowed.

256
00:12:05,490 --> 00:12:07,670
We can see examples on this slide.

257
00:12:07,670 --> 00:12:09,350
Name property of user object

258
00:12:09,350 --> 00:12:11,440
of select value from menu.

259
00:12:11,440 --> 00:12:14,360
We can imagine the
object in its properties

260
00:12:14,360 --> 00:12:16,623
like a branch with only leaves.

261
00:12:17,990 --> 00:12:19,660
If an allow list is applied,

262
00:12:19,660 --> 00:12:21,500
is relatively easier
to review all of them,

263
00:12:21,500 --> 00:12:23,140
and after such review
we can make sure that

264
00:12:23,140 --> 00:12:25,630
there is no dangerous elements.

265
00:12:25,630 --> 00:12:28,260
What if Blocklist is used instead?

266
00:12:28,260 --> 00:12:30,630
We still need to verify available objects

267
00:12:30,630 --> 00:12:32,580
and it can be a bit difficult.

268
00:12:32,580 --> 00:12:33,936
So in general, if you do not consider

269
00:12:33,936 --> 00:12:35,590
a Blocklist a safe approach

270
00:12:35,590 --> 00:12:37,360
because of potential gaps there.

271
00:12:37,360 --> 00:12:41,073
We will see in Java a couple
of examples of such bypasses.

272
00:12:42,630 --> 00:12:44,590
The most interesting case for us

273
00:12:44,590 --> 00:12:46,810
is where access to nested properties

274
00:12:46,810 --> 00:12:48,710
or attributes is allowed.

275
00:12:48,710 --> 00:12:51,330
For example, request.authuser.name

276
00:12:51,330 --> 00:12:54,820
or Menu.SelectedItem.Text.

277
00:12:54,820 --> 00:12:57,080
Because of branched leaves analogy,

278
00:12:57,080 --> 00:12:59,170
many developers might imagine this case

279
00:12:59,170 --> 00:13:01,850
as a branch with branches and leaves,

280
00:13:01,850 --> 00:13:03,500
and they might apply a filter

281
00:13:03,500 --> 00:13:06,250
only for the first level objects.

282
00:13:06,250 --> 00:13:09,510
But it is not tree, it is network.

283
00:13:09,510 --> 00:13:12,930
And we may jump from one
branch to another branch,

284
00:13:12,930 --> 00:13:14,220
or even to the trunk.

285
00:13:14,220 --> 00:13:15,760
For example, on this slide,

286
00:13:15,760 --> 00:13:17,510
we can see how we can access

287
00:13:17,510 --> 00:13:20,410
application instance
from menu web control.

288
00:13:21,740 --> 00:13:25,848
That's illustrate this problem
by examples from SharePoint.

289
00:13:25,848 --> 00:13:28,140
There is WikiContentWebPart control.

290
00:13:28,140 --> 00:13:31,170
It is allowed and can parse our markup

291
00:13:31,170 --> 00:13:33,180
into the ParseControl method.

292
00:13:33,180 --> 00:13:35,570
There is not, it is
called with false value

293
00:13:35,570 --> 00:13:37,660
in ignore possible argument,

294
00:13:37,660 --> 00:13:39,813
so page filter not be ignored.

295
00:13:41,540 --> 00:13:44,097
The following snippets
shows that in this case,

296
00:13:44,097 --> 00:13:46,050
the VirtualPath will be created

297
00:13:46,050 --> 00:13:48,850
from AppRalativeVirtualPath property.

298
00:13:48,850 --> 00:13:50,280
And if you remember,

299
00:13:50,280 --> 00:13:51,650
Page Filter will apply restriction

300
00:13:51,650 --> 00:13:53,480
based on this VirtualPath.

301
00:13:53,480 --> 00:13:55,660
So if you're able to change it,

302
00:13:55,660 --> 00:13:57,810
we can fool the PageFilter

303
00:13:57,810 --> 00:14:00,353
to not apply any
restriction to our markup.

304
00:14:01,350 --> 00:14:02,900
Let's try to grab such payload.

305
00:14:03,840 --> 00:14:07,680
First snippet fails
because when ASPX parser

306
00:14:07,680 --> 00:14:11,500
tries to assign a new value
to AppRelativeVirtualPath,

307
00:14:11,500 --> 00:14:14,950
the page property of our
control is not defined yet,

308
00:14:14,950 --> 00:14:17,600
so we need to delay this
assignment a little bit.

309
00:14:17,600 --> 00:14:20,110
We can do this by data binding.

310
00:14:20,110 --> 00:14:23,030
So by the time the property is bound,

311
00:14:23,030 --> 00:14:26,603
the page property will be already defined.

312
00:14:27,550 --> 00:14:29,670
Here is our final payload.

313
00:14:29,670 --> 00:14:32,250
We can note that our new path points to

314
00:14:32,250 --> 00:14:35,773
Application page setting ASPX.

315
00:14:36,720 --> 00:14:39,790
It is assigned to ToolTip property

316
00:14:39,790 --> 00:14:43,197
and later we will transferred
to AppRelativeVirtualPath.

317
00:14:43,197 --> 00:14:46,060
So the PageFilter, the thing
that this is system page

318
00:14:46,060 --> 00:14:48,410
and will allow any unsafe markup.

319
00:14:48,410 --> 00:14:50,860
For example, we can use
ObjectDataSource control

320
00:14:50,860 --> 00:14:51,860
to start calculator.

321
00:14:52,950 --> 00:14:55,483
Let's see how the real attack may look.

322
00:14:59,477 --> 00:15:02,680
If we can see a site page with our payload

323
00:15:02,680 --> 00:15:03,920
part of the system page,

324
00:15:03,920 --> 00:15:06,020
it'd be our center AppRelativeVirtualPath,

325
00:15:07,728 --> 00:15:10,323
and safe markup contains
SubjectDataSource control.

326
00:15:11,490 --> 00:15:14,930
We will invoke start
method of the Process type

327
00:15:14,930 --> 00:15:17,610
and we'll start calculator.

328
00:15:17,610 --> 00:15:19,083
Let's save it here.

329
00:15:20,420 --> 00:15:23,700
For our attack we need to
upload it to the target server.

330
00:15:23,700 --> 00:15:26,240
In our case, it's SharePoint
with default configuration.

331
00:15:26,240 --> 00:15:28,340
That means, regular users have access

332
00:15:28,340 --> 00:15:30,550
to their own personal sites,

333
00:15:30,550 --> 00:15:33,210
and we can use them to host our site page.

334
00:15:33,210 --> 00:15:36,290
We are notificated as regular
user with name attacker

335
00:15:36,290 --> 00:15:37,990
is naked, isn't.

336
00:15:37,990 --> 00:15:41,360
And here is his personal site.

337
00:15:41,360 --> 00:15:43,103
Let's upload our page here.

338
00:15:43,960 --> 00:15:45,650
Now to trigger our attack,

339
00:15:45,650 --> 00:15:47,130
we just need to click on it.

340
00:15:47,130 --> 00:15:49,850
But before that, let's take a look

341
00:15:49,850 --> 00:15:52,288
on the right side of our screen.

342
00:15:52,288 --> 00:15:55,200
We can see task manager
on our SharePoint Server,

343
00:15:55,200 --> 00:15:57,400
and we will notice if collector start.

344
00:15:57,400 --> 00:15:59,630
Now let's start our talk,

345
00:15:59,630 --> 00:16:02,483
and here is our calculator.

346
00:16:04,190 --> 00:16:06,770
Let's move to our next one
vulnerability in SharePoint.

347
00:16:06,770 --> 00:16:08,130
Now they will try to exploit

348
00:16:08,130 --> 00:16:10,420
read access to nested properties.

349
00:16:10,420 --> 00:16:12,300
We will use ControlParameter.

350
00:16:12,300 --> 00:16:14,730
It allows to bind value of property

351
00:16:14,730 --> 00:16:16,883
from another control to SelectParameter,

352
00:16:18,180 --> 00:16:20,900
also it's support nested properties.

353
00:16:20,900 --> 00:16:24,600
We need to do the value of
target property back to us.

354
00:16:24,600 --> 00:16:28,640
To do this, we will use
XMLUrlDataSource control

355
00:16:28,640 --> 00:16:33,320
that sends a value of
SelectParameters to external server.

356
00:16:33,320 --> 00:16:36,660
Now we need to find accessible property

357
00:16:36,660 --> 00:16:38,790
with sensitive information.

358
00:16:38,790 --> 00:16:40,500
Here we should expand a little bit

359
00:16:40,500 --> 00:16:44,250
configuration process of
SharePoint Online servers.

360
00:16:44,250 --> 00:16:47,300
Obviously, they are installed
and configured automatically,

361
00:16:47,300 --> 00:16:49,320
but what about configuration parameters

362
00:16:49,320 --> 00:16:51,220
that are unique for each installation?

363
00:16:52,150 --> 00:16:54,450
They will be provided in special file

364
00:16:54,450 --> 00:16:57,720
that will be used for
unattended configuration.

365
00:16:57,720 --> 00:16:59,670
What is important for our attack?

366
00:16:59,670 --> 00:17:02,750
All such parameters
including ValidationKey

367
00:17:02,750 --> 00:17:06,290
will be stored in
initialization setting property.

368
00:17:06,290 --> 00:17:08,330
So we just need to find a path

369
00:17:08,330 --> 00:17:11,620
of nested property to it
from any allowed control.

370
00:17:11,620 --> 00:17:12,623
And here it is.

371
00:17:13,820 --> 00:17:16,620
Here is the whole page that you sent well

372
00:17:16,620 --> 00:17:19,187
of ValidationKey to attackersserver.com.

373
00:17:20,690 --> 00:17:22,920
With this value we successfully got

374
00:17:22,920 --> 00:17:24,700
arbitrary record execution by

375
00:17:24,700 --> 00:17:26,500
Unsafe Deserialization in ViewState.

376
00:17:28,590 --> 00:17:31,430
Now, let's move to the next
type of security problems.

377
00:17:31,430 --> 00:17:34,090
It is connected with our previous work

378
00:17:34,090 --> 00:17:35,900
on Unsafe Deserialization.

379
00:17:35,900 --> 00:17:37,750
Such kind of problem are relevant

380
00:17:39,248 --> 00:17:42,630
when texts are binary data
is converted to an object

381
00:17:42,630 --> 00:17:45,560
and the type or class of this object

382
00:17:45,560 --> 00:17:47,320
is under attacker control.

383
00:17:47,320 --> 00:17:50,153
Plus, it is not properly limited.

384
00:17:51,090 --> 00:17:54,900
Actually, it doesn't really
matter what mechanism is used.

385
00:17:54,900 --> 00:17:56,230
Classical Deserializers,

386
00:17:56,230 --> 00:17:59,460
JSON Unmarshallers, TypeConverters,

387
00:17:59,460 --> 00:18:02,170
or even some custom approach.

388
00:18:02,170 --> 00:18:04,520
All of them are potentially dangerous.

389
00:18:04,520 --> 00:18:06,250
For successful exploitation,

390
00:18:06,250 --> 00:18:07,840
attacker address may need to find

391
00:18:07,840 --> 00:18:09,463
proper gadget on the system.

392
00:18:10,520 --> 00:18:14,020
We have found examples of
such problems in SharePoint

393
00:18:14,020 --> 00:18:15,590
and we're able to perform

394
00:18:15,590 --> 00:18:18,240
arbitrary code execution attack using it,

395
00:18:18,240 --> 00:18:20,460
but patch is not available yet.

396
00:18:20,460 --> 00:18:23,700
So we are going to publish
all the types of this problem

397
00:18:23,700 --> 00:18:25,003
when fix released.

398
00:18:26,240 --> 00:18:29,210
The last type of security
problems in this part,

399
00:18:29,210 --> 00:18:31,280
is classical time-of-check

400
00:18:31,280 --> 00:18:33,350
to time-of-use problems.

401
00:18:33,350 --> 00:18:36,730
They occur when the server
invalidates some input,

402
00:18:36,730 --> 00:18:38,810
but this input is later changed

403
00:18:38,810 --> 00:18:40,273
before this average use it.

404
00:18:41,300 --> 00:18:44,370
We have found such problem in
WebPartEditingSurface page.

405
00:18:44,370 --> 00:18:47,968
User input is validated
by the already mentioned,

406
00:18:47,968 --> 00:18:50,340
VerifyControlOnSafeList method.

407
00:18:50,340 --> 00:18:54,010
But later, the server may modify the input

408
00:18:54,010 --> 00:18:58,063
and remove substring that
match specific Regex pattern.

409
00:18:59,760 --> 00:19:01,450
Let's look on the next input.

410
00:19:01,450 --> 00:19:05,470
For validation ControlOnSafeList,

411
00:19:05,470 --> 00:19:08,290
it is just one server-side common block,

412
00:19:08,290 --> 00:19:11,110
so it will pass validation.

413
00:19:11,110 --> 00:19:14,730
But SharePoint removes the
highlighted yellow substring

414
00:19:14,730 --> 00:19:18,810
and pass controller will see
two comments and some markup.

415
00:19:18,810 --> 00:19:22,300
Note, ParseControl has only one argument,

416
00:19:22,300 --> 00:19:24,103
so batch filter will be ignored.

417
00:19:25,520 --> 00:19:26,890
Time for our payload.

418
00:19:26,890 --> 00:19:29,750
We can notice our unsafe
ObjectDataSource control

419
00:19:29,750 --> 00:19:32,250
and calculator command.

420
00:19:32,250 --> 00:19:33,880
In this part of our attack,

421
00:19:33,880 --> 00:19:38,080
we saw multiple ways to achieve
arbitrary code execution

422
00:19:38,080 --> 00:19:40,653
on the SharePoint server by regular user.

423
00:19:41,810 --> 00:19:43,410
This vulnerabilities reveal

424
00:19:43,410 --> 00:19:46,280
five different types of security problems

425
00:19:46,280 --> 00:19:47,883
in Content Management System.

426
00:19:48,760 --> 00:19:50,195
Now let's get back to Alvaro

427
00:19:50,195 --> 00:19:53,323
and he will present even
more vulnerabilities

428
00:19:53,323 --> 00:19:55,000
with templates for dynamic content

429
00:19:55,000 --> 00:19:57,333
in different Java frameworks and products.

430
00:19:58,808 --> 00:19:59,750
- Thank you Oleksandr.

431
00:19:59,750 --> 00:20:01,430
So switching to the Java part,

432
00:20:01,430 --> 00:20:03,670
we will be reviewing
four of the most popular

433
00:20:03,670 --> 00:20:06,500
Java template engines,
including FreeMarker,

434
00:20:06,500 --> 00:20:08,340
Velocity, Pebble, and JinJava.

435
00:20:08,340 --> 00:20:10,160
And also we will be reviewing

436
00:20:10,160 --> 00:20:11,693
10 different Content Management Systems

437
00:20:11,693 --> 00:20:14,840
that are using these engines,

438
00:20:14,840 --> 00:20:16,940
and then we will be trying our bypasses

439
00:20:16,940 --> 00:20:19,330
on these Content Management Systems.

440
00:20:19,330 --> 00:20:22,230
So a brief introduction into
what template engines are.

441
00:20:22,230 --> 00:20:26,030
Basically, these are systems
that take two different inputs.

442
00:20:26,030 --> 00:20:28,470
One is the template where we are mixing

443
00:20:28,470 --> 00:20:30,480
static and dynamic expressions,

444
00:20:30,480 --> 00:20:32,570
and also the template context

445
00:20:32,570 --> 00:20:36,320
where we store objects that
are required by the engine

446
00:20:36,320 --> 00:20:39,910
in order to resolve the dynamic
expressions in a template.

447
00:20:39,910 --> 00:20:43,030
So for example, here we have
the user.name expression

448
00:20:43,030 --> 00:20:44,620
in order to resolve it,

449
00:20:44,620 --> 00:20:47,960
we need to get access to the
user object in the context,

450
00:20:47,960 --> 00:20:50,810
and then invoke the getname method.

451
00:20:50,810 --> 00:20:52,930
So because it's invoking Java methods

452
00:20:52,930 --> 00:20:55,430
it's basically dangerous in the sense that

453
00:20:55,430 --> 00:20:57,920
attackers can execute arbitrary Java code,

454
00:20:57,920 --> 00:21:00,260
and that's the reason why most of them

455
00:21:00,260 --> 00:21:03,483
are Sandboxed in order to
prevent arbitrary code execution.

456
00:21:04,550 --> 00:21:06,577
So apart from the object that are normally

457
00:21:06,577 --> 00:21:08,930
and directly used by the template,

458
00:21:08,930 --> 00:21:11,330
there are a number of other objects

459
00:21:11,330 --> 00:21:14,020
that are exposed as part of a template API

460
00:21:14,020 --> 00:21:17,710
that is normally provided by
the Content Management Systems

461
00:21:18,947 --> 00:21:21,990
which basically, provides objects such as,

462
00:21:21,990 --> 00:21:24,210
for example, the request, the response,

463
00:21:24,210 --> 00:21:27,160
ServletContext, or even the HttpSession.

464
00:21:27,160 --> 00:21:28,810
So those objects are available

465
00:21:28,810 --> 00:21:31,200
in most of the template APIs

466
00:21:31,200 --> 00:21:34,683
and also many more that
are part of this API.

467
00:21:35,590 --> 00:21:40,060
So we will be discussing
first, some genetic bypasses,

468
00:21:40,060 --> 00:21:43,910
that means that are independent
of which engine is used,

469
00:21:43,910 --> 00:21:45,800
no matter if it's a FreeMarker,

470
00:21:45,800 --> 00:21:48,330
Velocity, Pebble or JinJava, right?

471
00:21:48,330 --> 00:21:51,670
So those bypasses are based

472
00:21:51,670 --> 00:21:54,750
on finding different objects

473
00:21:54,750 --> 00:21:58,290
that we can use to get
arbitrary code execution.

474
00:21:58,290 --> 00:22:00,950
So we need to inspect the template context

475
00:22:00,950 --> 00:22:02,750
and look for these kinds of objects.

476
00:22:02,750 --> 00:22:03,770
So in order to do that,

477
00:22:03,770 --> 00:22:05,360
if we have access to the JVM,

478
00:22:05,360 --> 00:22:06,860
we can basically debug it,

479
00:22:06,860 --> 00:22:08,370
or we can instrument it,

480
00:22:08,370 --> 00:22:10,950
damp the template context and inspect

481
00:22:10,950 --> 00:22:14,060
and analyze all the objects in there.

482
00:22:14,060 --> 00:22:17,203
However, if we don't
have access to the JVM,

483
00:22:18,170 --> 00:22:21,840
we will have to read the
template API documentation,

484
00:22:21,840 --> 00:22:25,080
maybe do some brute force
in order to guess names

485
00:22:25,080 --> 00:22:26,380
like for example, request

486
00:22:26,380 --> 00:22:29,740
or rec or response risk
and things like that.

487
00:22:29,740 --> 00:22:31,730
And also in some of the engines,

488
00:22:31,730 --> 00:22:33,230
like for example, FreeMarker,

489
00:22:33,230 --> 00:22:36,890
it is possible to list all
the variables or objects

490
00:22:36,890 --> 00:22:39,960
that are exposed in the context.

491
00:22:39,960 --> 00:22:41,610
So apart from those objects

492
00:22:41,610 --> 00:22:44,770
that are directly exposed
to to the context,

493
00:22:44,770 --> 00:22:48,060
we have some objects that
are indirectly exposed.

494
00:22:48,060 --> 00:22:50,710
Like for example, if we are
exposing the HTTPSession

495
00:22:50,710 --> 00:22:53,200
because it contains some attributes,

496
00:22:53,200 --> 00:22:56,650
all of those attributes will
be available for the users

497
00:22:56,650 --> 00:22:59,310
and attackers to access and use.

498
00:22:59,310 --> 00:23:01,070
Same thing with the ServletRequest

499
00:23:01,070 --> 00:23:02,790
and same thing with a ServletContext.

500
00:23:02,790 --> 00:23:05,200
So those are a store of attributes,

501
00:23:05,200 --> 00:23:08,370
stores of objects that the
attacker can get access to

502
00:23:08,370 --> 00:23:11,250
and use to look for interesting objects.

503
00:23:11,250 --> 00:23:13,790
So let's see how many objects we can find

504
00:23:13,790 --> 00:23:15,690
in one simple Content Management Systems.

505
00:23:15,690 --> 00:23:17,690
In this case, it will be Liferay.

506
00:23:17,690 --> 00:23:19,010
And in order to do that,

507
00:23:19,010 --> 00:23:23,513
we will be generating this
template that I'm showing you,

508
00:23:25,430 --> 00:23:30,080
which basically is listing
all of the context variables,

509
00:23:30,080 --> 00:23:33,130
then all of their request attributes.

510
00:23:33,130 --> 00:23:35,955
Then we will show all the requests.

511
00:23:35,955 --> 00:23:37,870
Sorry, the session attributes,

512
00:23:37,870 --> 00:23:40,100
then the ServletContext attributes.

513
00:23:40,100 --> 00:23:42,820
And because the ServletContext will expose

514
00:23:42,820 --> 00:23:45,750
the Spring framework context,

515
00:23:45,750 --> 00:23:49,140
we will be also listing
all of the Spring Beans.

516
00:23:49,140 --> 00:23:52,810
All the objects are registered
in the Spring context.

517
00:23:52,810 --> 00:23:55,213
So if we rendered that,

518
00:23:57,150 --> 00:23:59,443
you will see that we
have a bunch of objects

519
00:23:59,443 --> 00:24:01,480
indirectly exposed to the context.

520
00:24:01,480 --> 00:24:03,710
Those are part of the template API,

521
00:24:03,710 --> 00:24:06,430
and some of them are very interesting.

522
00:24:06,430 --> 00:24:09,960
Others are exposed as part
of their request attributes,

523
00:24:09,960 --> 00:24:12,990
session attributes, and
ServletContext attributes.

524
00:24:12,990 --> 00:24:15,740
So as we can see here, we
have interesting objects,

525
00:24:15,740 --> 00:24:18,450
like an InstanceManager, or for example,

526
00:24:18,450 --> 00:24:21,900
the WebApplicationContext
for a Spring that we use

527
00:24:21,900 --> 00:24:24,190
to list and access all this Spring base.

528
00:24:24,190 --> 00:24:26,190
So as you can see, there are hundreds

529
00:24:26,190 --> 00:24:28,460
and thousands of objects here.

530
00:24:28,460 --> 00:24:31,600
There is a total of almost 900 objects

531
00:24:31,600 --> 00:24:34,110
and because some of them
will have public fields

532
00:24:34,110 --> 00:24:35,770
that we can get access to,

533
00:24:35,770 --> 00:24:38,773
then this number will increase
to thousands of updates.

534
00:24:40,070 --> 00:24:41,550
So back to the slides,

535
00:24:41,550 --> 00:24:43,850
this is why we call it
Object Dumpster Diving,

536
00:24:43,850 --> 00:24:45,640
because this is how we felt

537
00:24:45,640 --> 00:24:49,360
when I'm trying to find
very few interesting objects

538
00:24:49,360 --> 00:24:51,950
that can lead to remote code execution

539
00:24:51,950 --> 00:24:54,853
among thousands and thousands of objects.

540
00:24:55,700 --> 00:24:59,030
So now we will be reviewing
the top three objects

541
00:24:59,030 --> 00:25:01,850
that we found that lead
to remote code execution.

542
00:25:01,850 --> 00:25:03,120
So that, for example, the first one,

543
00:25:03,120 --> 00:25:06,500
the ClassLoaders was
available in 10 out of the 10

544
00:25:06,500 --> 00:25:08,900
Content Management
Systems that we analyzed.

545
00:25:08,900 --> 00:25:10,570
So normally you can get access

546
00:25:10,570 --> 00:25:12,480
to this ClassLoader instance

547
00:25:12,480 --> 00:25:16,990
through the getClassLoader
method in the class type,

548
00:25:16,990 --> 00:25:18,940
but that is normally blocked

549
00:25:18,940 --> 00:25:21,400
by the any Blocklist by any Sandbox.

550
00:25:21,400 --> 00:25:22,650
So you can still get access

551
00:25:22,650 --> 00:25:24,360
if you can access to a protection domain

552
00:25:24,360 --> 00:25:26,810
or a ServletContext as we saw before.

553
00:25:26,810 --> 00:25:29,540
So once that you get
access to a ClassLoader,

554
00:25:29,540 --> 00:25:32,380
you can obviously load arbitrary classes

555
00:25:32,380 --> 00:25:36,330
and then also load arbitrary
resources from the class path.

556
00:25:36,330 --> 00:25:40,120
But apart from that, you
get access to a URL object,

557
00:25:40,120 --> 00:25:43,020
and then from there
you can access any file

558
00:25:43,020 --> 00:25:45,490
from the File System that
the application server

559
00:25:45,490 --> 00:25:47,720
has permission to access.

560
00:25:47,720 --> 00:25:49,260
So here you have an example,

561
00:25:49,260 --> 00:25:52,110
you get the URL using
the getResource method,

562
00:25:52,110 --> 00:25:55,420
and then you point the
URL to the password file,

563
00:25:55,420 --> 00:25:56,730
and then you open that connection

564
00:25:56,730 --> 00:25:59,583
and read all the bites from that file.

565
00:26:01,560 --> 00:26:06,440
So apart from the standard ClassLoaders,

566
00:26:06,440 --> 00:26:08,330
because Content Management Systems

567
00:26:08,330 --> 00:26:11,970
are normally deployed on
top of ServletContainers

568
00:26:11,970 --> 00:26:14,090
or application servers,

569
00:26:14,090 --> 00:26:15,920
the instance of the ClassLoader

570
00:26:15,920 --> 00:26:17,930
that you will be able to access

571
00:26:17,930 --> 00:26:20,340
is normally an instance of a
web application ClassLoader

572
00:26:20,340 --> 00:26:22,120
that are slightly different

573
00:26:22,120 --> 00:26:25,220
because of the way that a
class loading delegation work,

574
00:26:25,220 --> 00:26:27,780
but also because they expose

575
00:26:27,780 --> 00:26:29,450
a number of additional methods

576
00:26:29,450 --> 00:26:33,040
that are not part of the
abstract ClassLoader class.

577
00:26:33,040 --> 00:26:35,173
So here are just some
example just mentioned

578
00:26:35,173 --> 00:26:37,930
because we don't have time
to cover them in the talk.

579
00:26:37,930 --> 00:26:39,880
Although it's explaining the white paper

580
00:26:39,880 --> 00:26:42,600
that we are probably seen
as part of this talk,

581
00:26:43,523 --> 00:26:46,110
there are different ways
of using these methods

582
00:26:46,110 --> 00:26:47,710
in this web application ClassLoader

583
00:26:47,710 --> 00:26:49,290
to get remote code execution.

584
00:26:49,290 --> 00:26:52,480
Just to mention some of the vectors,

585
00:26:52,480 --> 00:26:54,900
we will be able to upload the WebShells,

586
00:26:54,900 --> 00:26:56,710
instantiate arbitrary objects,

587
00:26:56,710 --> 00:26:59,000
perform JNDI injections,

588
00:26:59,000 --> 00:27:03,653
or even, initialize
attacker control classes.

589
00:27:04,760 --> 00:27:08,313
So we were able to find, sorry,

590
00:27:09,690 --> 00:27:12,450
web application ClassLoaders
in nine out of the 10

591
00:27:12,450 --> 00:27:14,810
Content Management
Systems that we analyzed.

592
00:27:14,810 --> 00:27:16,770
And then the second object,

593
00:27:16,770 --> 00:27:20,210
the second most easy to find object

594
00:27:20,210 --> 00:27:22,410
in these template context

595
00:27:22,410 --> 00:27:26,540
was the InstanceManager
or the ObjectFactory.

596
00:27:26,540 --> 00:27:28,850
So this was found in nine out of the 10

597
00:27:28,850 --> 00:27:31,890
Content Management Systems
and is normally found

598
00:27:31,890 --> 00:27:34,530
as part of the ServletContext attributes,

599
00:27:34,530 --> 00:27:36,410
but also it can be accessed

600
00:27:36,410 --> 00:27:39,130
through one of these
web application Loaders.

601
00:27:39,130 --> 00:27:41,290
So if you get access
to an InstanceManager,

602
00:27:41,290 --> 00:27:44,550
what you can do is basically
instantiate arbitrary types.

603
00:27:44,550 --> 00:27:46,960
So with that, it's very easy to escalate

604
00:27:46,960 --> 00:27:48,630
to remote code execution.

605
00:27:48,630 --> 00:27:52,310
Here we have an example using
the ScriptEngineManager,

606
00:27:52,310 --> 00:27:54,300
but there are a bunch of classes

607
00:27:54,300 --> 00:27:56,200
that can lead to remote code execution

608
00:27:56,200 --> 00:27:58,340
once that you can instantiate them

609
00:27:58,340 --> 00:28:01,413
and then invoke arbitrary methods on them.

610
00:28:02,820 --> 00:28:06,870
So the number three object was
a ApringApplicationContext,

611
00:28:06,870 --> 00:28:08,890
it was only available in four

612
00:28:08,890 --> 00:28:12,779
out of the 10th CMSs that we analyzed,

613
00:28:12,779 --> 00:28:13,612
actually there're only four

614
00:28:13,612 --> 00:28:16,620
that were using the Spring
framework underneath.

615
00:28:16,620 --> 00:28:18,020
And it's normally accessible

616
00:28:18,020 --> 00:28:20,210
through one of the
ServleContext attributes,

617
00:28:20,210 --> 00:28:23,140
but also, if the Content Management System

618
00:28:23,140 --> 00:28:26,820
is using a Spring MVC framework

619
00:28:26,820 --> 00:28:29,610
for the model controller and Bean layers

620
00:28:29,610 --> 00:28:32,000
then a Spring we'll inject

621
00:28:32,000 --> 00:28:34,700
some additional objects
in the template context.

622
00:28:34,700 --> 00:28:37,300
Like this has Spring Macro Request Context

623
00:28:37,300 --> 00:28:42,050
that will provide access to
the Spring Application Context.

624
00:28:42,050 --> 00:28:44,340
So one that we have access
to this Spring Context,

625
00:28:44,340 --> 00:28:46,590
we can get an instance of a ClassLoader

626
00:28:46,590 --> 00:28:50,440
and initiate ClassLoader-based
attacks like we saw before.

627
00:28:50,440 --> 00:28:52,700
We can access the Spring environment

628
00:28:52,700 --> 00:28:55,249
that will give us access to
their system environment,

629
00:28:55,249 --> 00:28:57,350
and also the system properties

630
00:28:57,350 --> 00:28:58,860
and also a Spring properties,

631
00:28:58,860 --> 00:29:01,760
including things like
encryption keys and so on.

632
00:29:01,760 --> 00:29:03,720
But probably more interesting,

633
00:29:03,720 --> 00:29:06,150
it will give us access to the Spring Beans

634
00:29:06,150 --> 00:29:09,230
registered in these Spring
Application Context.

635
00:29:09,230 --> 00:29:12,560
So being able to access
and manipulate those Beans,

636
00:29:12,560 --> 00:29:15,320
we can basically control
the application logic

637
00:29:15,320 --> 00:29:18,457
and do things like, register new users

638
00:29:18,457 --> 00:29:21,740
delete users, perform transactions.

639
00:29:21,740 --> 00:29:24,710
Anything that the application
is normally doing.

640
00:29:24,710 --> 00:29:27,830
So that's normally behind
an authorization layer,

641
00:29:27,830 --> 00:29:29,860
so no matter what roles we have,

642
00:29:29,860 --> 00:29:31,410
we will be able to perform

643
00:29:34,896 --> 00:29:37,340
in this kind of application logic control.

644
00:29:37,340 --> 00:29:40,630
So apart from that, we will
also be able to disable

645
00:29:40,630 --> 00:29:42,172
the template engine Sandboxes,

646
00:29:42,172 --> 00:29:44,230
if we are able to get access

647
00:29:44,230 --> 00:29:46,730
to the template engine
configuration Beans.

648
00:29:46,730 --> 00:29:49,030
And also instances arbitrary objects,

649
00:29:49,030 --> 00:29:50,360
like we will see later

650
00:29:50,360 --> 00:29:54,093
by accessing JSON or
XML and and most others.

651
00:29:56,860 --> 00:29:58,650
Those were like generic bypasses

652
00:29:58,650 --> 00:30:02,660
independent of what template
engine was used underneath.

653
00:30:02,660 --> 00:30:03,960
And now we will be reviewing

654
00:30:03,960 --> 00:30:06,230
some specific Sandboxes bypasses

655
00:30:06,230 --> 00:30:09,110
for each of these four
different templates engines.

656
00:30:09,110 --> 00:30:10,630
So what will it start with FreeMarker,

657
00:30:10,630 --> 00:30:12,850
because it's probably
the most popular one,

658
00:30:12,850 --> 00:30:16,420
and also because well, it was analyzed

659
00:30:16,420 --> 00:30:20,200
and researched by different
researchers in the past.

660
00:30:20,200 --> 00:30:21,680
Like for example James Kettle

661
00:30:21,680 --> 00:30:23,900
back in 2015 when he presented

662
00:30:23,900 --> 00:30:27,840
server-side template
injection vulnerability class.

663
00:30:27,840 --> 00:30:29,740
By the way, if you
haven't watched his talk,

664
00:30:29,740 --> 00:30:31,150
it's highly recommended.

665
00:30:31,150 --> 00:30:35,380
He presented a bypass that is based on,

666
00:30:35,380 --> 00:30:37,120
kind of add-on or a module

667
00:30:37,120 --> 00:30:40,870
that is deployed on the default
configuration of FreeMarker.

668
00:30:40,870 --> 00:30:44,060
So Toni Torralba, last year
presented a different bypass,

669
00:30:44,060 --> 00:30:46,370
but this one is not
universal in the sense that

670
00:30:46,370 --> 00:30:50,380
it depends on a non-default
configuration of FreeMarker,

671
00:30:50,380 --> 00:30:55,380
and also being able to find
gadgets in third party libraries

672
00:30:55,670 --> 00:31:00,020
that may or may not be
available in a specific target.

673
00:31:00,020 --> 00:31:02,670
And then Ryan Hanson, this year,

674
00:31:02,670 --> 00:31:05,510
probably at the same time that
we were doing this research

675
00:31:05,510 --> 00:31:08,370
presented our vector that
leads to remote code execution

676
00:31:08,370 --> 00:31:09,590
by uploading a WebShell.

677
00:31:09,590 --> 00:31:12,020
But this is not universal
in the sense that

678
00:31:12,020 --> 00:31:14,820
it only works with Tomcat servers.

679
00:31:14,820 --> 00:31:19,360
So FreeMarker Sandbox is
a method-based Blocklist,

680
00:31:19,360 --> 00:31:22,710
which basically means that for example,

681
00:31:22,710 --> 00:31:25,300
methods, like they getClassLoader method

682
00:31:25,300 --> 00:31:27,370
in the Java lang class is blocked

683
00:31:27,370 --> 00:31:28,760
and you cannot get an instance

684
00:31:28,760 --> 00:31:30,470
of a ClassLoader using this method.

685
00:31:30,470 --> 00:31:31,490
But as we mentioned before,

686
00:31:31,490 --> 00:31:33,420
you can still use the ServletContext

687
00:31:33,420 --> 00:31:37,160
or the protection domain to get
access to this ClassLoaders.

688
00:31:37,160 --> 00:31:38,530
Once that you get access to a ClassLoader,

689
00:31:38,530 --> 00:31:41,840
the ClassLoader methods are
not blocked by the Blocklist,

690
00:31:41,840 --> 00:31:44,690
so you can still interact with them,

691
00:31:44,690 --> 00:31:46,370
load classes, get resources

692
00:31:46,370 --> 00:31:50,000
or initiate remote code execution
attacks that we saw before

693
00:31:50,000 --> 00:31:54,840
And also reflection is
forbidden to set fields values

694
00:31:54,840 --> 00:31:59,020
by is allowed to get
and read fields values.

695
00:31:59,020 --> 00:32:02,350
So we use that to perform an attack,

696
00:32:02,350 --> 00:32:04,870
but this attack is not
universal in the sense that

697
00:32:04,870 --> 00:32:06,620
it depends on being able to find

698
00:32:06,620 --> 00:32:08,660
an instance of a URLClassLoader.

699
00:32:08,660 --> 00:32:10,700
So this is normally the case in Tomcat,

700
00:32:10,700 --> 00:32:12,010
Glassfish, and Jetty,

701
00:32:12,010 --> 00:32:15,440
but it's not universal for
other application servers.

702
00:32:15,440 --> 00:32:17,520
So in this case, we are basically getting

703
00:32:17,520 --> 00:32:20,040
the URLClassLoader from
the protection domain

704
00:32:20,040 --> 00:32:21,750
or from the ServletContext,

705
00:32:21,750 --> 00:32:25,770
and then we are basically instantiating

706
00:32:25,770 --> 00:32:28,120
by invoking this new instance methods

707
00:32:28,120 --> 00:32:30,500
a knew URLClassLoader that is pointing

708
00:32:30,500 --> 00:32:32,820
to the attacker controlled jar file.

709
00:32:32,820 --> 00:32:35,160
In this case, the pwn.jar file.

710
00:32:35,160 --> 00:32:37,300
Once that we get access
to this ClassLoader,

711
00:32:37,300 --> 00:32:41,350
we can get a load arbitrary
classes from our own jar file,

712
00:32:41,350 --> 00:32:43,550
and we will be loading the pwn class.

713
00:32:43,550 --> 00:32:46,300
And now the class is loaded,

714
00:32:46,300 --> 00:32:47,530
but it's not initialized.

715
00:32:47,530 --> 00:32:49,820
If we want to run arbitrary code,

716
00:32:49,820 --> 00:32:52,080
we need to initialize the class.

717
00:32:52,080 --> 00:32:53,690
We cannot instantiate the class,

718
00:32:53,690 --> 00:32:55,920
we cannot invoke a static methods,

719
00:32:55,920 --> 00:33:00,307
so those vectors, those ways
of initializing the class

720
00:33:00,307 --> 00:33:02,440
are not a possibility for us

721
00:33:02,440 --> 00:33:05,820
but we can get access
to public static fields.

722
00:33:05,820 --> 00:33:08,340
So just by adding a public static field

723
00:33:08,340 --> 00:33:09,173
and getting access to that,

724
00:33:09,173 --> 00:33:10,830
the class will be initialized

725
00:33:10,830 --> 00:33:12,543
and the payload will be security.

726
00:33:13,570 --> 00:33:17,100
So it was not a universal
bypass in the sense that

727
00:33:17,100 --> 00:33:20,500
we are required to find an
instance of URLClassLoader,

728
00:33:20,500 --> 00:33:23,620
and we want to find something
that works no matter

729
00:33:23,620 --> 00:33:26,510
if we are able to find that
client of ClassLoader or not.

730
00:33:26,510 --> 00:33:29,710
So we are interested
in finding some classes

731
00:33:29,710 --> 00:33:33,480
that contains public static
fields of a given type,

732
00:33:33,480 --> 00:33:36,150
which contains a method that we can use

733
00:33:36,150 --> 00:33:38,370
to instantiate arbitrary types.

734
00:33:38,370 --> 00:33:40,020
To find them, we use CodeQL,

735
00:33:40,020 --> 00:33:42,195
which is a language that you can use

736
00:33:42,195 --> 00:33:45,290
to query your source code in
the same way that you use,

737
00:33:45,290 --> 00:33:48,670
for example, SQL to query a database.

738
00:33:48,670 --> 00:33:52,347
And what we wrote was this
query that basically says,

739
00:33:52,347 --> 00:33:54,800
"Okay, find me all the
public static fields,

740
00:33:54,800 --> 00:33:56,090
which are of a given type

741
00:33:56,090 --> 00:33:58,960
that can instantiate arbitrary types".

742
00:33:58,960 --> 00:34:01,650
We run this query on
FreeMarker source code,

743
00:34:01,650 --> 00:34:04,060
and we found four different results.

744
00:34:04,060 --> 00:34:07,560
Those are four different
fields of different types,

745
00:34:07,560 --> 00:34:12,560
but all those types extend
from the BeansWrapper type,

746
00:34:12,800 --> 00:34:15,170
which contains our new instance method

747
00:34:15,170 --> 00:34:17,570
which we can use to
instantiate arbitrary types.

748
00:34:18,720 --> 00:34:22,340
Now, this is the universal
remote code execution

749
00:34:22,340 --> 00:34:24,790
bypass for FreeMarker,

750
00:34:24,790 --> 00:34:26,530
basically we need to get us access

751
00:34:26,530 --> 00:34:27,960
to any type of ClassLoader

752
00:34:27,960 --> 00:34:30,460
from either the protection
domain, ServletContext,

753
00:34:32,060 --> 00:34:35,250
and then load the ObjectWrapper interface

754
00:34:35,250 --> 00:34:38,870
and get the DefaultWrapper
field from this interface,

755
00:34:38,870 --> 00:34:42,750
and then we can use that to
instantiate arbitrary classes.

756
00:34:42,750 --> 00:34:45,160
Since we want to have this payload

757
00:34:45,160 --> 00:34:47,670
basically contained in FreeMarker classes,

758
00:34:47,670 --> 00:34:49,890
we are using the execute class

759
00:34:49,890 --> 00:34:52,010
in order to run arbitrary system commands,

760
00:34:52,010 --> 00:34:53,580
but you can use other payloads

761
00:34:53,580 --> 00:34:56,660
or other classes to get
arbitrary code execution.

762
00:34:56,660 --> 00:34:59,943
So this was fixed in
Version 2.30 of FreeMarker,

763
00:35:01,350 --> 00:35:04,460
and also if you get
access to the Spring Beans

764
00:35:04,460 --> 00:35:07,180
and you can get access to
the FreeMarker configuration,

765
00:35:07,180 --> 00:35:09,460
as we saw in some of the
Content Management Systems

766
00:35:09,460 --> 00:35:12,750
that we analyzed, you can
basically disabled the Sandbox.

767
00:35:12,750 --> 00:35:15,792
For example, you can get the ClassResolver

768
00:35:15,792 --> 00:35:18,290
for the default configuration
that is non-Sandboxed,

769
00:35:18,290 --> 00:35:21,440
and then set that class
resolver as the class resolver

770
00:35:21,440 --> 00:35:24,510
for the current and Sandbox configuration.

771
00:35:24,510 --> 00:35:27,280
So effectively disabling the Sandbox

772
00:35:27,280 --> 00:35:31,170
and being able to execute the old payload

773
00:35:31,170 --> 00:35:33,053
from James Kettle, once again.

774
00:35:34,430 --> 00:35:36,750
So now we will be reviewing

775
00:35:36,750 --> 00:35:38,920
eight different ways to escape the Sandbox

776
00:35:38,920 --> 00:35:41,070
I can get remote code
execution in Liferay.

777
00:35:43,180 --> 00:35:46,970
So let's see Our Liferay instance here,

778
00:35:50,170 --> 00:35:51,610
and what we will be doing is

779
00:35:51,610 --> 00:35:55,617
basically using this template

780
00:35:59,760 --> 00:36:02,470
And here what we are gonna do basically is

781
00:36:02,470 --> 00:36:06,670
first of all, we are going to
use the ClassLoader a payload,

782
00:36:06,670 --> 00:36:09,910
which will allow us to
read the password file

783
00:36:09,910 --> 00:36:13,320
using the URL trick that
we explained before.

784
00:36:13,320 --> 00:36:14,933
Then because the instance
of the ClassLoader

785
00:36:14,933 --> 00:36:16,690
that is a web application ClassLoader,

786
00:36:16,690 --> 00:36:18,690
we will be using that ClassLoader

787
00:36:18,690 --> 00:36:22,780
to upload our WebShell by
using the right method.

788
00:36:22,780 --> 00:36:27,780
This will be available
in the Shell JSP file.

789
00:36:27,970 --> 00:36:31,045
Then we will be also using the
web publication ClassLoader

790
00:36:31,045 --> 00:36:33,890
to get access to an InstanceManager

791
00:36:35,030 --> 00:36:36,720
and then instantiate arbitrary classes.

792
00:36:36,720 --> 00:36:38,530
In this case, we are instantiating

793
00:36:38,530 --> 00:36:40,350
an expression language processor,

794
00:36:40,350 --> 00:36:42,693
and then running the ID process.

795
00:36:43,630 --> 00:36:46,470
Then we will be also,
showing a different payload,

796
00:36:46,470 --> 00:36:49,350
that depends on using an InstanceManager,

797
00:36:49,350 --> 00:36:52,470
this time is taken from
the ServletContext.

798
00:36:52,470 --> 00:36:54,610
And again, we are using the EL Processor

799
00:36:54,610 --> 00:36:56,690
to run the ID command,

800
00:36:56,690 --> 00:36:59,730
and then we will be
using a JSON Deserializer

801
00:36:59,730 --> 00:37:01,480
as an InstanceManager in the sense that

802
00:37:01,480 --> 00:37:06,000
we will be using that to
instantiate arbitrary types.

803
00:37:06,000 --> 00:37:09,350
We will be getting access
to the JSON Deserializer

804
00:37:09,350 --> 00:37:11,680
from the Spring Application Context.

805
00:37:11,680 --> 00:37:14,770
And because this JSON
Deserializer uses our white list

806
00:37:14,770 --> 00:37:17,810
and allow list here, we need to register,

807
00:37:17,810 --> 00:37:20,720
or we can actually register
any arbitrary types

808
00:37:20,720 --> 00:37:25,720
for us to use in the Jason payload.

809
00:37:26,410 --> 00:37:28,940
So now by Deserializing
these JSON payload,

810
00:37:28,940 --> 00:37:32,990
we are effectively
instantiating an EL Processor,

811
00:37:32,990 --> 00:37:35,540
and then again running the ID command.

812
00:37:35,540 --> 00:37:39,300
Same thing but instead of
getting the JSON Deserializer

813
00:37:39,300 --> 00:37:42,189
from the Spring Bean Context,

814
00:37:42,189 --> 00:37:46,400
Liferay directly expose
this JSONFactoryUtil,

815
00:37:46,400 --> 00:37:48,780
which we can use to
create JSON Deserializer,

816
00:37:48,780 --> 00:37:51,701
and then once I can use that
to instantiate arbitrary types.

817
00:37:51,701 --> 00:37:54,800
And then we will see the two FreeMarker

818
00:37:54,800 --> 00:37:58,780
specific bypasses that we
explained few minutes ago.

819
00:37:58,780 --> 00:38:01,090
The first one is using the URLClassLoader,

820
00:38:01,090 --> 00:38:05,740
that is the case here because
Liferay is deployed on Tomcat.

821
00:38:05,740 --> 00:38:09,580
And then we can basically
access our own jar file,

822
00:38:09,580 --> 00:38:12,860
load it, and then by getting
a public static field,

823
00:38:12,860 --> 00:38:15,130
the class will be initialized

824
00:38:15,130 --> 00:38:16,977
and the payload will be executed,

825
00:38:16,977 --> 00:38:20,111
and we will be able to check
the output of these payload,

826
00:38:20,111 --> 00:38:23,830
by checking the standard output

827
00:38:23,830 --> 00:38:26,120
and the last payload
that worked in Liferay

828
00:38:26,120 --> 00:38:28,690
actually, there's a couple more,

829
00:38:28,690 --> 00:38:31,400
but it was more than enough

830
00:38:32,520 --> 00:38:34,440
is this Universal RCE.

831
00:38:34,440 --> 00:38:37,940
So we are loading the
ObjectWrapper interface,

832
00:38:37,940 --> 00:38:40,140
loading the DefaultWrapper field,

833
00:38:40,140 --> 00:38:42,890
and then using that field to
instantiate arbitrary types

834
00:38:42,890 --> 00:38:45,750
in this case the execute at type

835
00:38:45,750 --> 00:38:47,990
that we will be using to run the ID.

836
00:38:47,990 --> 00:38:50,360
So now, if we save this template

837
00:38:50,360 --> 00:38:55,360
and we will be showing the
results of this payloads.

838
00:38:57,350 --> 00:38:59,590
The first one was reading
the password file,

839
00:38:59,590 --> 00:39:01,673
the second one was deploying a WebShell

840
00:39:01,673 --> 00:39:05,940
that we can now access and
run arbitrary commands.

841
00:39:05,940 --> 00:39:09,560
The third one was using different methods

842
00:39:09,560 --> 00:39:10,810
to run the ID command.

843
00:39:10,810 --> 00:39:13,150
As you can see here, all of them worked.

844
00:39:13,150 --> 00:39:17,640
So also the URLClassLoader
was basically running

845
00:39:17,640 --> 00:39:20,590
the Static initializer
block of this class,

846
00:39:20,590 --> 00:39:22,630
which is basically printing PWNED

847
00:39:22,630 --> 00:39:26,290
in the standard output
console, we can check that.

848
00:39:26,290 --> 00:39:28,080
Here it is, so it worked.

849
00:39:28,080 --> 00:39:30,383
And back to the payloads,

850
00:39:32,010 --> 00:39:35,463
the Universal RCE payload also
worked as we can see here.

851
00:39:36,660 --> 00:39:39,100
So switching to their Velocity Sandbox,

852
00:39:39,100 --> 00:39:42,900
this one is based on a class
and package-based Blocklists.

853
00:39:42,900 --> 00:39:43,920
So things like, for example,

854
00:39:43,920 --> 00:39:47,920
the whole Java Lang reflect
package is forbidden

855
00:39:47,920 --> 00:39:49,370
and you can get access to it.

856
00:39:50,230 --> 00:39:52,010
All the methods in Java Lang class

857
00:39:52,010 --> 00:39:55,700
and class loader are also
blocked and you cannot use them.

858
00:39:55,700 --> 00:39:58,260
But when we review the implementation,

859
00:39:58,260 --> 00:40:01,290
we found that there is a flow in the way

860
00:40:01,290 --> 00:40:04,870
that the Sandbox is
checking the Blocklist.

861
00:40:04,870 --> 00:40:08,420
So for example, when you
run the Request Servlet,

862
00:40:08,420 --> 00:40:10,480
and then you get access to a ClassLoader

863
00:40:10,480 --> 00:40:13,440
and run the load class method,

864
00:40:13,440 --> 00:40:16,960
basically, the execution of this method

865
00:40:16,960 --> 00:40:19,240
will be checked against the Blocklist.

866
00:40:19,240 --> 00:40:22,240
And the class name of
the current ClassLoader

867
00:40:22,240 --> 00:40:24,910
will be checked against the Blocklist.

868
00:40:24,910 --> 00:40:27,620
Instead of checking the
whole hierarchy of classes,

869
00:40:27,620 --> 00:40:31,860
only the current object
class will be checked

870
00:40:31,860 --> 00:40:33,790
against the Blocklist which means that

871
00:40:33,790 --> 00:40:36,750
because Java Lang ClassLoader
is an abstract class,

872
00:40:36,750 --> 00:40:39,160
it won't never be the case that

873
00:40:39,160 --> 00:40:42,730
the current object class will
be a Java Lang ClassLoader.

874
00:40:42,730 --> 00:40:45,060
In this case, it's a
ParallelWebAppClassLoader,

875
00:40:45,060 --> 00:40:47,060
which is not presented in the Blocklist

876
00:40:47,060 --> 00:40:51,530
and therefore ClassLoader
methods are effectively allowed.

877
00:40:51,530 --> 00:40:54,240
There is a feature in Velocity,

878
00:40:54,240 --> 00:40:56,900
which allows you to
invoke a static methods

879
00:40:56,900 --> 00:40:59,230
from a Java Lang class object.

880
00:40:59,230 --> 00:41:01,410
So once that we are able to load a class,

881
00:41:01,410 --> 00:41:04,070
we can just invoke any static methods

882
00:41:04,070 --> 00:41:07,063
and use that to get remote
code execution easily.

883
00:41:08,240 --> 00:41:10,580
So now moving into JinJava Sandbox,

884
00:41:10,580 --> 00:41:14,579
this one is based on a method Blocklist.

885
00:41:14,579 --> 00:41:17,270
This is actually very
short, only nine methods.

886
00:41:17,270 --> 00:41:20,170
And it contains is a piece of code

887
00:41:20,170 --> 00:41:23,160
that is pretty effective
in protecting the Sandbox.

888
00:41:23,160 --> 00:41:25,970
So every time that a
method invocation happens

889
00:41:25,970 --> 00:41:28,350
as part of the evaluation of the template,

890
00:41:28,350 --> 00:41:30,520
the result type will be text.

891
00:41:30,520 --> 00:41:32,730
And if it's an instance
of a Java Lang class,

892
00:41:32,730 --> 00:41:33,970
then it will throw an exception

893
00:41:33,970 --> 00:41:38,870
and it will refuse to return
a Java lang class instance.

894
00:41:38,870 --> 00:41:42,300
By not being able to get in
access to arbitrary classes,

895
00:41:42,300 --> 00:41:45,730
we are normally not able to get,

896
00:41:45,730 --> 00:41:48,490
or to be able to
instantiate arbitrary types.

897
00:41:48,490 --> 00:41:52,080
However, we found a flaw,
as you can see here,

898
00:41:52,080 --> 00:41:54,450
the vocation of a class cannot return

899
00:41:54,450 --> 00:41:55,930
a Java Lang class instance,

900
00:41:55,930 --> 00:41:59,650
but it can return an
array of Java lang classes

901
00:41:59,650 --> 00:42:02,180
or a map, including Java Lang classes.

902
00:42:02,180 --> 00:42:03,960
So what we can do is find a method

903
00:42:03,960 --> 00:42:05,560
returning an array of classes,

904
00:42:05,560 --> 00:42:09,640
and then accessing any
arbitrary item of this array.

905
00:42:09,640 --> 00:42:12,150
So the second part of this bypass

906
00:42:12,150 --> 00:42:14,370
was basically being able to access

907
00:42:14,370 --> 00:42:17,970
a secret or hidden variable in the context

908
00:42:17,970 --> 00:42:20,170
that is called underscore
underscore underscore

909
00:42:20,170 --> 00:42:22,060
interpreted in little speech.

910
00:42:22,060 --> 00:42:24,790
So by using these hidden variable,

911
00:42:24,790 --> 00:42:27,910
we were able to access a
bunch of different objects,

912
00:42:27,910 --> 00:42:30,530
including all the context objects.

913
00:42:30,530 --> 00:42:34,460
And we were able to use those two parts

914
00:42:34,460 --> 00:42:37,320
to get an instance of a ClassLoader.

915
00:42:37,320 --> 00:42:38,350
So as you can see here,

916
00:42:38,350 --> 00:42:40,890
we use the interpreter to get the context.

917
00:42:40,890 --> 00:42:44,040
And from the context we
got all the functions,

918
00:42:44,040 --> 00:42:46,950
and from the functions we
got the underlay methods,

919
00:42:46,950 --> 00:42:50,990
which are instances of
Java Lang Reflect methods.

920
00:42:50,990 --> 00:42:54,050
And this class contains this
get parameter types method,

921
00:42:54,050 --> 00:42:58,880
which returns an array
of Java Lang classes.

922
00:42:58,880 --> 00:43:01,140
So as I explained before,

923
00:43:01,140 --> 00:43:03,030
we are able to get an instance

924
00:43:03,030 --> 00:43:07,100
of an individual item of this array.

925
00:43:07,100 --> 00:43:09,950
And by doing that we are finally getting

926
00:43:09,950 --> 00:43:11,740
an instance of a Java Lang class.

927
00:43:11,740 --> 00:43:14,120
From there, we can get
the protection domain,

928
00:43:14,120 --> 00:43:16,440
get the ClassLoader and then initiate

929
00:43:16,440 --> 00:43:18,923
any ClassLoader based attack.

930
00:43:20,230 --> 00:43:21,810
So last, Pebble Sandbox,

931
00:43:21,810 --> 00:43:24,190
we were able to find a couple of bypasses

932
00:43:24,190 --> 00:43:26,290
that we reported to the maintainers.

933
00:43:26,290 --> 00:43:29,490
Unfortunately, they didn't
have time to fix them on time,

934
00:43:29,490 --> 00:43:33,590
so we decided not to
leak these bypasses yet,

935
00:43:33,590 --> 00:43:37,123
and we are keeping them
classified for a few months.

936
00:43:38,260 --> 00:43:41,160
So with that, we will
switch back to Oleksandr

937
00:43:41,160 --> 00:43:44,690
who will wrap up the talk
with some conclusions.

938
00:43:44,690 --> 00:43:45,940
- Thanks Alvaro.

939
00:43:45,940 --> 00:43:49,160
First of let's summarize our
results after this research.

940
00:43:49,160 --> 00:43:52,080
More than 30 new
vulnerabilities were found

941
00:43:52,080 --> 00:43:53,630
and reported to the vendor.

942
00:43:53,630 --> 00:43:56,170
More than 20 different
products are affected,

943
00:43:56,170 --> 00:43:59,240
we can see their names on this slide.

944
00:43:59,240 --> 00:44:00,930
Based on this results,

945
00:44:00,930 --> 00:44:03,050
we can make the next conclusions.

946
00:44:03,050 --> 00:44:04,759
These are not the problems

947
00:44:04,759 --> 00:44:07,860
of specific product or framework

948
00:44:07,860 --> 00:44:10,330
and Content Management System as a class

949
00:44:10,330 --> 00:44:11,780
should be on Red Ream radars.

950
00:44:12,830 --> 00:44:14,490
Templates for dynamic content

951
00:44:14,490 --> 00:44:15,880
that can be managed by user

952
00:44:15,880 --> 00:44:18,260
is the main target for such system.

953
00:44:18,260 --> 00:44:20,730
There are specific areas with higher risk

954
00:44:20,730 --> 00:44:22,810
from security point of view.

955
00:44:22,810 --> 00:44:24,827
It's a good idea to
perform security review

956
00:44:24,827 --> 00:44:27,100
and testing for search places.

957
00:44:27,100 --> 00:44:31,990
Always try or reduce attack
surface as much as you can,

958
00:44:31,990 --> 00:44:32,893
and stay safe.

