1
00:00:00,680 --> 00:00:02,440
- All right, welcome everyone.

2
00:00:02,440 --> 00:00:04,784
My name is Jack Baker and
I'm gonna be talking about

3
00:00:04,784 --> 00:00:07,790
bugs in game engine.

4
00:00:07,790 --> 00:00:09,120
So, as a little bit of background

5
00:00:09,120 --> 00:00:10,270
over the last few months

6
00:00:10,270 --> 00:00:13,450
I found more than 10
remotely exploitable bugs

7
00:00:13,450 --> 00:00:15,390
while looking at two
different game engines.

8
00:00:15,390 --> 00:00:18,190
And I'm gonna be talking about
four of those bugs today.

9
00:00:19,430 --> 00:00:21,220
So just to level set things.

10
00:00:21,220 --> 00:00:22,850
When I use the term, Game Engine,

11
00:00:22,850 --> 00:00:24,920
I'm referring to the base software

12
00:00:24,920 --> 00:00:28,660
that most games are built on top of.

13
00:00:28,660 --> 00:00:30,810
So if you're building a video game,

14
00:00:30,810 --> 00:00:32,550
you're probably not doing it from scratch,

15
00:00:32,550 --> 00:00:36,010
you're using a pre made
set of tools and software

16
00:00:36,010 --> 00:00:38,760
that are built to make
that process easier.

17
00:00:38,760 --> 00:00:42,570
And that software is
called your Game Engine.

18
00:00:42,570 --> 00:00:44,970
And so the popularity of many game engines

19
00:00:44,970 --> 00:00:48,449
means that a lot of games
share the exact same bugs.

20
00:00:48,449 --> 00:00:50,280
This is made worse by the fact that

21
00:00:50,280 --> 00:00:53,200
updating your game
engine can be a huge pain

22
00:00:53,200 --> 00:00:55,480
as anyone who's done a lot of game dev

23
00:00:55,480 --> 00:00:56,913
can probably tell you.

24
00:00:57,800 --> 00:01:01,530
And games don't usually get
security patches after release.

25
00:01:01,530 --> 00:01:04,150
Maybe like a bigger game,
will have some support,

26
00:01:04,150 --> 00:01:06,130
but like an independent release

27
00:01:06,130 --> 00:01:10,520
is not gonna get patches a
year or two years after release

28
00:01:10,520 --> 00:01:12,603
just to fix some security bug.

29
00:01:14,180 --> 00:01:16,650
So there aren't a whole
lot of good statistics

30
00:01:16,650 --> 00:01:19,310
on what game engines are the most popular,

31
00:01:19,310 --> 00:01:20,940
but there's a general understanding

32
00:01:20,940 --> 00:01:23,100
that two of them are
more common than others,

33
00:01:23,100 --> 00:01:26,203
and those are Unreal Engine 4 and Unity.

34
00:01:27,090 --> 00:01:28,860
So as sort of a rule of thumb,

35
00:01:28,860 --> 00:01:31,670
if you're a solo
developer or a small team,

36
00:01:31,670 --> 00:01:34,310
there's a pretty good
chance you're using Unity,

37
00:01:34,310 --> 00:01:37,040
whereas if you're a larger
team, but not so large

38
00:01:37,040 --> 00:01:39,330
that you've built your
own engine from scratch,

39
00:01:39,330 --> 00:01:41,923
you're probably using Unreal Engine 4.

40
00:01:43,190 --> 00:01:47,170
So, Unreal Engine 4 is
created by Epic Games.

41
00:01:47,170 --> 00:01:50,170
It's named for its roots
in the Unreal series.

42
00:01:50,170 --> 00:01:53,110
It is opensource, there are
some licensing restrictions

43
00:01:53,110 --> 00:01:54,740
on how you can use that source,

44
00:01:54,740 --> 00:01:57,430
but for our perspective
of just looking for bugs,

45
00:01:57,430 --> 00:02:00,340
all the code is out
there for us to look at.

46
00:02:00,340 --> 00:02:02,810
And there are really
two big notable games,

47
00:02:02,810 --> 00:02:06,380
I think right now, that are
built using Unreal Engine 4,

48
00:02:06,380 --> 00:02:08,623
and those are Fortnite and PUBG.

49
00:02:10,520 --> 00:02:14,110
Unity is built by Unity Technologies.

50
00:02:14,110 --> 00:02:16,130
There are some open
source components of it,

51
00:02:16,130 --> 00:02:20,100
but the core components of
Unity are closed source.

52
00:02:20,100 --> 00:02:22,520
The core networking library
we're gonna be looking at

53
00:02:22,520 --> 00:02:25,040
is called UNET, and while I couldn't find

54
00:02:25,040 --> 00:02:27,420
a whole lot of like big
games that are using UNET,

55
00:02:27,420 --> 00:02:29,920
there are countless
amount of indie releases

56
00:02:29,920 --> 00:02:32,823
on Steam and everywhere else,
that are built using UNET.

57
00:02:34,390 --> 00:02:37,460
Now I should say that UNET is deprecated,

58
00:02:37,460 --> 00:02:38,930
but there are a few reasons

59
00:02:38,930 --> 00:02:41,420
that I thought it would
be a good target anyway.

60
00:02:41,420 --> 00:02:42,640
The first is that UNET

61
00:02:42,640 --> 00:02:45,370
has not got an official replacement yet,

62
00:02:45,370 --> 00:02:48,100
Unity hasn't put out an alternative yet.

63
00:02:48,100 --> 00:02:51,300
So if you're using Unity and
you're doing multiplayer,

64
00:02:51,300 --> 00:02:53,160
you're either using UNET still,

65
00:02:53,160 --> 00:02:55,720
or you're using third party solution.

66
00:02:55,720 --> 00:02:58,750
Also, UNET still does receive patches

67
00:02:58,750 --> 00:03:02,480
and occasionally new features,
even though it's deprecated.

68
00:03:02,480 --> 00:03:06,993
So the encryption API was added
to UNET after deprecation.

69
00:03:08,740 --> 00:03:11,370
And so a ton of new, and
more importantly I think,

70
00:03:11,370 --> 00:03:13,980
existing games use UNET.

71
00:03:13,980 --> 00:03:17,233
So I think bugs in UNET
still have some value.

72
00:03:18,710 --> 00:03:21,660
So, let's talk about
multiplayer protocols.

73
00:03:21,660 --> 00:03:24,487
As game engines have evolved,

74
00:03:24,487 --> 00:03:27,740
and as multiplayer protocols have evolved,

75
00:03:27,740 --> 00:03:29,860
there's really been a focus on two things.

76
00:03:29,860 --> 00:03:31,110
The first is obvious,

77
00:03:31,110 --> 00:03:34,360
it's increasing performance,
increasing speed.

78
00:03:34,360 --> 00:03:37,474
The other is moving trust
away from the client

79
00:03:37,474 --> 00:03:39,843
in order to prevent hacking.

80
00:03:40,690 --> 00:03:41,590
But as we're gonna see,

81
00:03:41,590 --> 00:03:45,048
these can sometimes be conflicting goals.

82
00:03:45,048 --> 00:03:48,210
But to really understand
multiplayer protocols,

83
00:03:48,210 --> 00:03:50,040
I think it's worth understanding

84
00:03:50,040 --> 00:03:53,240
the types of attacks that
they're aiming to prevent.

85
00:03:53,240 --> 00:03:55,130
And I think the best example of this

86
00:03:55,130 --> 00:03:56,620
is to talk about the evolution

87
00:03:56,620 --> 00:03:58,713
of what we'll call Movement Hacking.

88
00:03:59,660 --> 00:04:01,950
So, Movement Hacking is the process

89
00:04:01,950 --> 00:04:04,730
of manipulating the player's location

90
00:04:04,730 --> 00:04:07,760
in some way that the game
normally wouldn't allow.

91
00:04:07,760 --> 00:04:09,760
In the old days, this was really easy

92
00:04:09,760 --> 00:04:12,750
because player location was
just trusted to the client.

93
00:04:12,750 --> 00:04:15,830
So if you manipulate your
location client-side,

94
00:04:15,830 --> 00:04:17,853
you can teleport server-side.

95
00:04:19,007 --> 00:04:20,470
And this got more difficult

96
00:04:20,470 --> 00:04:23,180
as game engines got more complicated,

97
00:04:23,180 --> 00:04:25,920
and trust was taken from the client

98
00:04:25,920 --> 00:04:28,410
and put on the server for player location.

99
00:04:28,410 --> 00:04:32,270
So the client can no
longer say, I'm at XYZ,

100
00:04:32,270 --> 00:04:34,010
the client, all I can do

101
00:04:34,010 --> 00:04:37,070
is make a request saying,
I would like to move,

102
00:04:37,070 --> 00:04:39,840
I'm moving in this
direction at this speed,

103
00:04:39,840 --> 00:04:44,580
and the server will update
their position accordingly.

104
00:04:44,580 --> 00:04:47,910
This led to a new type of
attack called, Speed Hacking.

105
00:04:47,910 --> 00:04:51,240
So it's sort of the next
evolution of Movement Hacking.

106
00:04:51,240 --> 00:04:54,920
Speed Hacking, the goal is
not to teleport, necessarily,

107
00:04:54,920 --> 00:04:57,540
but just to move extremely fast.

108
00:04:57,540 --> 00:04:59,070
And typically the way this works

109
00:04:59,070 --> 00:05:03,330
is you send that movement
request excessively fast,

110
00:05:03,330 --> 00:05:05,890
faster than a normal client ever would,

111
00:05:05,890 --> 00:05:08,723
and more requests then means more speed.

112
00:05:10,120 --> 00:05:13,240
This was prevented by
basically giving more authority

113
00:05:13,240 --> 00:05:15,810
and more context to the server.

114
00:05:15,810 --> 00:05:17,810
So the server should be able to understand

115
00:05:17,810 --> 00:05:22,050
what is a realistic distance
that a character can move

116
00:05:22,050 --> 00:05:23,970
in a given timeframe.

117
00:05:23,970 --> 00:05:28,040
And if a client is attempting
to move beyond that timeframe,

118
00:05:28,040 --> 00:05:30,070
it can stop that from happening.

119
00:05:30,070 --> 00:05:34,280
And so by giving this
context to the server,

120
00:05:34,280 --> 00:05:36,980
we're able to prevent this type of attack.

121
00:05:36,980 --> 00:05:40,010
And this is really how
game engines have evolved.

122
00:05:40,010 --> 00:05:41,320
It's been a constant process

123
00:05:41,320 --> 00:05:44,250
of moving trust away from the client

124
00:05:44,250 --> 00:05:47,419
and giving more authority,
more responsibility,

125
00:05:47,419 --> 00:05:50,410
and more context to the server

126
00:05:50,410 --> 00:05:52,493
to understand what is normal.

127
00:05:53,890 --> 00:05:54,890
So with all of this said,

128
00:05:54,890 --> 00:05:57,980
let's talk about some of
the technical specifics

129
00:05:57,980 --> 00:05:59,870
of multiplayer protocols.

130
00:05:59,870 --> 00:06:02,650
Now there's no real
like published standard

131
00:06:02,650 --> 00:06:04,580
of what a multiplayer protocol looks like,

132
00:06:04,580 --> 00:06:06,930
but there are a few things
that are pretty consistent

133
00:06:06,930 --> 00:06:08,830
between different protocols.

134
00:06:08,830 --> 00:06:12,000
And the first of those, is
that most multiplayer protocols

135
00:06:12,000 --> 00:06:15,780
use some form of Distributed Architecture.

136
00:06:15,780 --> 00:06:17,220
And essentially what this means is,

137
00:06:17,220 --> 00:06:20,600
each system, whether that
be a client or a server,

138
00:06:20,600 --> 00:06:23,770
each system has a copy of
every networked object,

139
00:06:23,770 --> 00:06:25,970
every object that's
connected to the network

140
00:06:25,970 --> 00:06:29,120
in the game world, and
actions between objects

141
00:06:29,120 --> 00:06:30,610
and between systems

142
00:06:30,610 --> 00:06:32,340
are performed through what are called,

143
00:06:32,340 --> 00:06:34,283
Remote Procedure Calls.

144
00:06:35,350 --> 00:06:38,590
So, Remote Procedure Calls,
as the name sort of suggests,

145
00:06:38,590 --> 00:06:42,340
are a way of calling
functions on a remote system

146
00:06:42,340 --> 00:06:44,400
as if you were calling them locally.

147
00:06:44,400 --> 00:06:47,110
So this is really easy for the programmer

148
00:06:47,110 --> 00:06:48,600
because it's just like you're calling

149
00:06:48,600 --> 00:06:51,350
a regular function of your code.

150
00:06:51,350 --> 00:06:52,830
The difference is that, that function

151
00:06:52,830 --> 00:06:55,010
is executing on someone else's system,

152
00:06:55,010 --> 00:06:57,130
not your local system.

153
00:06:57,130 --> 00:07:00,070
This is really convenient, but
there's a lot of complexity

154
00:07:00,070 --> 00:07:02,543
that goes into this
process on the backend.

155
00:07:03,830 --> 00:07:07,190
And so, with this concept of
the Distributed Architecture,

156
00:07:07,190 --> 00:07:10,520
usually comes some sort
of concept of ownership

157
00:07:10,520 --> 00:07:12,860
where owning an object usually means

158
00:07:12,860 --> 00:07:17,600
having the authority to
issue RPCs on that object.

159
00:07:17,600 --> 00:07:19,240
And so the way this usually works

160
00:07:19,240 --> 00:07:22,600
is each player has
ownership of their character

161
00:07:22,600 --> 00:07:26,310
and maybe some associated sub
objects like your inventory,

162
00:07:26,310 --> 00:07:30,270
but player A can only
issue RPCs on character A,

163
00:07:30,270 --> 00:07:34,223
it can't issue RPCs on
character B, and vice versa.

164
00:07:35,720 --> 00:07:37,940
Another interesting technical detail

165
00:07:37,940 --> 00:07:40,130
of multiplayer player protocols

166
00:07:40,130 --> 00:07:43,500
is that they're usually
implemented over UDP.

167
00:07:43,500 --> 00:07:46,230
The one major exception
to this are browser games,

168
00:07:46,230 --> 00:07:49,030
where you can't access
operating system socket

169
00:07:49,030 --> 00:07:51,650
so you have to use
something like WebSockets.

170
00:07:51,650 --> 00:07:53,803
But when we're talking
about desktop games,

171
00:07:53,803 --> 00:07:56,370
we're usually talking about protocols

172
00:07:56,370 --> 00:07:58,380
that are implemented over UDP.

173
00:07:58,380 --> 00:08:01,780
And this puts actual requirements
on the protocol itself

174
00:08:01,780 --> 00:08:03,630
because UDP won't do things

175
00:08:03,630 --> 00:08:07,490
like validate that a
packet is part of a session

176
00:08:07,490 --> 00:08:08,980
that you've already authenticated,

177
00:08:08,980 --> 00:08:10,440
or identify when a packet

178
00:08:10,440 --> 00:08:12,717
is either a duplicate or out of order.

179
00:08:12,717 --> 00:08:15,050
So, the protocol gets more complex

180
00:08:15,050 --> 00:08:18,233
because it has to deal with
these types of problems itself.

181
00:08:19,610 --> 00:08:21,270
So now that we've talked a little bit

182
00:08:21,270 --> 00:08:23,000
about how these protocols work,

183
00:08:23,000 --> 00:08:24,330
let's look at our first bug.

184
00:08:24,330 --> 00:08:26,260
And this is an Unreal Engine 4 bug,

185
00:08:26,260 --> 00:08:28,110
and it's actually a file pathing bug.

186
00:08:29,410 --> 00:08:32,430
So Unreal Engine uses its own type of URL,

187
00:08:32,430 --> 00:08:34,530
and it uses this to communicate details

188
00:08:34,530 --> 00:08:36,440
between the server and the client.

189
00:08:36,440 --> 00:08:39,530
So this can be stuff like
the server can send a URL

190
00:08:39,530 --> 00:08:42,410
that says, we're playing on this map,

191
00:08:42,410 --> 00:08:44,310
you need to load these packages.

192
00:08:44,310 --> 00:08:46,250
Or the client could send something saying,

193
00:08:46,250 --> 00:08:50,040
I'm joining the game,
my player name is Jack,

194
00:08:50,040 --> 00:08:52,190
and I'm joining with two other players

195
00:08:52,190 --> 00:08:55,400
who are playing split
screen on the same computer.

196
00:08:55,400 --> 00:08:58,940
And so, one of these URLs
might look something like this.

197
00:08:58,940 --> 00:09:01,670
You start with the IP
address of the server,

198
00:09:01,670 --> 00:09:03,070
then you've got a file path

199
00:09:03,070 --> 00:09:05,903
that corresponds to a particular asset.

200
00:09:05,903 --> 00:09:08,810
And then just like an HTTP URL,

201
00:09:08,810 --> 00:09:10,540
you've got key value pairs

202
00:09:10,540 --> 00:09:12,433
that are separated by an equal sign.

203
00:09:13,720 --> 00:09:15,400
So the bug here is pretty simple.

204
00:09:15,400 --> 00:09:17,509
If you use a malicious URL,

205
00:09:17,509 --> 00:09:19,810
you can cause a server or a client

206
00:09:19,810 --> 00:09:22,423
to access any local file path.

207
00:09:23,330 --> 00:09:25,370
It's not gonna try to write to that file

208
00:09:25,370 --> 00:09:27,020
or even read from that file,

209
00:09:27,020 --> 00:09:30,680
it's just gonna try to
determine if that file exists.

210
00:09:30,680 --> 00:09:32,470
This is pretty boring on its own,

211
00:09:32,470 --> 00:09:34,790
but it gets more interesting
when we start talking about

212
00:09:34,790 --> 00:09:38,430
Universal Naming Convention, or UNC paths.

213
00:09:38,430 --> 00:09:40,900
So UNC paths are special Windows paths

214
00:09:40,900 --> 00:09:44,110
that are used to access
networked resources

215
00:09:44,110 --> 00:09:46,100
as if they were regular files,

216
00:09:46,100 --> 00:09:48,771
so, regular local files.

217
00:09:48,771 --> 00:09:52,080
Typically, a UNC path will
look something like this.

218
00:09:52,080 --> 00:09:56,280
You've got two slashes, then
the host name or IP address,

219
00:09:56,280 --> 00:09:58,300
another slash, then the share name,

220
00:09:58,300 --> 00:10:00,520
then another slash, and
then either the file name

221
00:10:00,520 --> 00:10:02,053
or the full file path.

222
00:10:03,180 --> 00:10:07,240
So using this crafted URL,
or one that looks like it,

223
00:10:07,240 --> 00:10:09,250
we can cause a server or client

224
00:10:09,250 --> 00:10:11,700
to connect to a remote SMB share.

225
00:10:11,700 --> 00:10:12,600
This is pretty simple.

226
00:10:12,600 --> 00:10:14,290
The one trick here is

227
00:10:14,290 --> 00:10:17,920
we do need to include
the part that says .umap,

228
00:10:17,920 --> 00:10:22,140
where umap is a file extension
used by Unreal Engine.

229
00:10:22,140 --> 00:10:24,580
And by having this somewhere
in the domain name,

230
00:10:24,580 --> 00:10:26,728
here we use it as a sub domain,

231
00:10:26,728 --> 00:10:29,420
we can bypass some of the filtration.

232
00:10:29,420 --> 00:10:33,199
And if we provide this URL to a system,

233
00:10:33,199 --> 00:10:38,090
it will cause it to make
an outgoing SMB connection

234
00:10:38,090 --> 00:10:40,210
and try to determine the existence

235
00:10:40,210 --> 00:10:42,253
of this high .TXT file.

236
00:10:43,410 --> 00:10:44,770
And so what this does,

237
00:10:44,770 --> 00:10:47,470
is it opens up the affected system

238
00:10:47,470 --> 00:10:50,610
to the world of SMB-related attacks.

239
00:10:50,610 --> 00:10:53,340
Typically, when a Windows
system connects to an SMB share,

240
00:10:53,340 --> 00:10:55,020
it'll try to authenticate with it.

241
00:10:55,020 --> 00:10:57,570
So this can be used for
Credential Harvesting

242
00:10:57,570 --> 00:10:59,310
or Authentication Relaying.

243
00:10:59,310 --> 00:11:02,060
There's a whole world of
different attacks using this.

244
00:11:02,060 --> 00:11:04,030
This can also be used pretty trivially

245
00:11:04,030 --> 00:11:06,170
as a server Denial of Service

246
00:11:06,170 --> 00:11:08,230
because the whole server will lock up

247
00:11:08,230 --> 00:11:10,140
as it's making this request.

248
00:11:10,140 --> 00:11:12,030
So if you cause that SMB connection

249
00:11:12,030 --> 00:11:14,230
to deliberately take a long time,

250
00:11:14,230 --> 00:11:16,833
you can lock up the server for a while.

251
00:11:17,720 --> 00:11:21,530
So this was fixed in Unreal Engine 4.25.2.

252
00:11:21,530 --> 00:11:25,370
With this commit, it's
really easy to backport this.

253
00:11:25,370 --> 00:11:26,840
So if you're on an older version,

254
00:11:26,840 --> 00:11:28,323
this isn't too hard to apply.

255
00:11:29,250 --> 00:11:30,650
So this is a pretty fun bug,

256
00:11:30,650 --> 00:11:33,430
but let's talk about something
a little bit flashier,

257
00:11:33,430 --> 00:11:36,303
and let's start talking
about our first UNET bug.

258
00:11:37,610 --> 00:11:41,120
So, UNET packets are
packed in such a format

259
00:11:41,120 --> 00:11:44,960
that you can put multiple
RPCs into a single packet.

260
00:11:44,960 --> 00:11:47,710
And that looks a little bit like this.

261
00:11:47,710 --> 00:11:50,230
So the first thing you've
got is the packet header,

262
00:11:50,230 --> 00:11:53,260
which, for our purposes,
we don't really care about,

263
00:11:53,260 --> 00:11:57,010
but then you have each
message within that packet,

264
00:11:57,010 --> 00:12:01,860
and each message consists
of a 16-bit message length,

265
00:12:01,860 --> 00:12:05,230
a 16-bit value, that I
call the message type,

266
00:12:05,230 --> 00:12:07,070
and then the message body,

267
00:12:07,070 --> 00:12:09,570
the actual contents of that message.

268
00:12:09,570 --> 00:12:11,200
And then at the end of that body,

269
00:12:11,200 --> 00:12:14,083
you see you have the next
message just concatenated on.

270
00:12:15,650 --> 00:12:17,840
The bug here, again, is pretty simple.

271
00:12:17,840 --> 00:12:19,910
If we supply a message size

272
00:12:19,910 --> 00:12:23,160
that's larger than the actual
payload of our message,

273
00:12:23,160 --> 00:12:25,080
the actual body of our message,

274
00:12:25,080 --> 00:12:27,920
we can convince the server
to act on extra data

275
00:12:27,920 --> 00:12:29,850
that's already in memory.

276
00:12:29,850 --> 00:12:32,390
So that looks a little
something like this.

277
00:12:32,390 --> 00:12:35,150
If we imagine this is just a regular RPC,

278
00:12:35,150 --> 00:12:38,670
we start with the length,
and then we've got the body,

279
00:12:38,670 --> 00:12:39,960
which is 4-bytes.

280
00:12:39,960 --> 00:12:42,200
But if we were to manipulate that length

281
00:12:42,200 --> 00:12:45,910
without actually increasing
the length of our body,

282
00:12:45,910 --> 00:12:47,990
we will see that all of this other data

283
00:12:47,990 --> 00:12:48,987
that was already in memory,

284
00:12:48,987 --> 00:12:50,800
that's not part of our message,

285
00:12:50,800 --> 00:12:53,763
is now within scope of our RPC.

286
00:12:55,170 --> 00:12:56,500
So, what's interesting about this

287
00:12:56,500 --> 00:13:00,620
is that this old memory actually
comes from previous RPCs.

288
00:13:00,620 --> 00:13:01,940
Not just from ours,

289
00:13:01,940 --> 00:13:04,800
but from other connections,
from other players.

290
00:13:04,800 --> 00:13:06,030
So what we wanna do here

291
00:13:06,030 --> 00:13:07,810
is we wanna create an RPC

292
00:13:07,810 --> 00:13:10,950
that will leak this old memory to us,

293
00:13:10,950 --> 00:13:12,533
kind of like Heartbleed would.

294
00:13:13,980 --> 00:13:15,900
And so to do this,

295
00:13:15,900 --> 00:13:19,460
it's not enough to just
cause the servers to act

296
00:13:19,460 --> 00:13:20,700
on that old memory,

297
00:13:20,700 --> 00:13:22,040
we need to convince the server

298
00:13:22,040 --> 00:13:25,440
to actually send that memory back to us.

299
00:13:25,440 --> 00:13:27,120
And so the type of RPC

300
00:13:27,120 --> 00:13:30,300
that is really good for
this, is Chat messages.

301
00:13:30,300 --> 00:13:35,100
So let's look at what an example
chat RPC might look like.

302
00:13:35,100 --> 00:13:36,920
In this case, again we've got the length,

303
00:13:36,920 --> 00:13:39,210
and then we've got the body of the RPC,

304
00:13:39,210 --> 00:13:41,650
which is just made up of a string length

305
00:13:41,650 --> 00:13:43,280
and then a string body.

306
00:13:43,280 --> 00:13:45,270
But if we just supply that string length

307
00:13:45,270 --> 00:13:47,150
and we don't supply a body,

308
00:13:47,150 --> 00:13:49,760
then all the rest of that memory,

309
00:13:49,760 --> 00:13:52,360
is gonna be treated as
part of that string.

310
00:13:52,360 --> 00:13:55,820
And if that RBC is accepted,

311
00:13:55,820 --> 00:13:58,200
the server is gonna send
back a message that says,

312
00:13:58,200 --> 00:14:00,790
there's a new chat message,
and here's its content.

313
00:14:00,790 --> 00:14:05,593
And those contents will contain
data from previous RPCs.

314
00:14:06,880 --> 00:14:09,560
But even in the absence of chat messages,

315
00:14:09,560 --> 00:14:12,150
there are some other RPCs we can use.

316
00:14:12,150 --> 00:14:15,580
Movement, or spawning a new
object, are both good ones

317
00:14:15,580 --> 00:14:17,610
because they typically involve

318
00:14:17,610 --> 00:14:20,750
giving some form of vector,

319
00:14:20,750 --> 00:14:23,470
some location as an argument.

320
00:14:23,470 --> 00:14:26,890
And we can use this to
leak either 8 or 12-bytes,

321
00:14:26,890 --> 00:14:30,190
depending on whether or not
this vector is 2D or 3D.

322
00:14:30,190 --> 00:14:32,430
If it's a 3D game or a 2D game.

323
00:14:32,430 --> 00:14:35,110
And then there's always
games specific RPCs

324
00:14:35,110 --> 00:14:36,950
that we could potentially use for this.

325
00:14:36,950 --> 00:14:38,403
We just have to get creative.

326
00:14:39,945 --> 00:14:42,680
So, let's talk about what
we can leak with this.

327
00:14:42,680 --> 00:14:44,810
Now, there can be a lot of things,

328
00:14:44,810 --> 00:14:46,980
if you're doing authentication over UNET,

329
00:14:46,980 --> 00:14:50,300
this could be passwords, it
could also be private messages.

330
00:14:50,300 --> 00:14:52,050
It could be game specific stuff

331
00:14:52,050 --> 00:14:54,550
like player locations or player actions,

332
00:14:54,550 --> 00:14:58,060
really anything that gets
sent over UNET by the client

333
00:14:58,060 --> 00:14:59,760
could be leaked this way.

334
00:14:59,760 --> 00:15:01,880
And this was fixed pretty recently

335
00:15:01,880 --> 00:15:04,873
at the end of May, with
UNET version 1.0.6.

336
00:15:07,360 --> 00:15:09,730
So I went kind of quickly
through those first two,

337
00:15:09,730 --> 00:15:12,690
but I really wanted to save
time for these last two bugs,

338
00:15:12,690 --> 00:15:14,410
which I think warrant going into

339
00:15:14,410 --> 00:15:16,372
a little bit more technical depth.

340
00:15:16,372 --> 00:15:19,580
This first one is another
Unreal Engine bug.

341
00:15:19,580 --> 00:15:21,120
And I really liked this bug

342
00:15:21,120 --> 00:15:25,690
because it is a Universal
Speed Hack for Unreal Engine.

343
00:15:25,690 --> 00:15:28,330
So, we talked just briefly about this,

344
00:15:28,330 --> 00:15:30,370
but movement in Unreal Engine

345
00:15:30,370 --> 00:15:33,440
is what we call, server-authoritative.

346
00:15:33,440 --> 00:15:38,110
That means that the client
cannot just say, I'm at XYZ,

347
00:15:38,110 --> 00:15:42,410
instead, the client has
to issue a movement RPC

348
00:15:42,410 --> 00:15:45,993
and ask the server to update
the player's location.

349
00:15:47,730 --> 00:15:51,160
And so this movement RPC has
two important parts to it.

350
00:15:51,160 --> 00:15:53,930
I am oversimplifying this quite a bit,

351
00:15:53,930 --> 00:15:56,300
but I only want to talk about the parts

352
00:15:56,300 --> 00:15:59,260
that are actually relevant to our bug.

353
00:15:59,260 --> 00:16:02,000
So the first argument
is the movement vector,

354
00:16:02,000 --> 00:16:03,610
and this is a vector that says,

355
00:16:03,610 --> 00:16:04,757
the direction that we're moving

356
00:16:04,757 --> 00:16:06,910
and the speed we're moving at.

357
00:16:06,910 --> 00:16:09,540
And the second argument is
a timestamp that just says,

358
00:16:09,540 --> 00:16:14,193
we sent this RPC at this
time, relevant to client time.

359
00:16:15,160 --> 00:16:17,270
And so the actual math here

360
00:16:17,270 --> 00:16:20,700
is that the server will calculate

361
00:16:20,700 --> 00:16:22,340
what's called a Movement Delta

362
00:16:22,340 --> 00:16:24,610
by taking our provided timestamp

363
00:16:24,610 --> 00:16:29,283
and subtracting from it
the last valid timestamp

364
00:16:31,110 --> 00:16:33,660
that we provided to the server.

365
00:16:33,660 --> 00:16:36,910
And then it's going to
take our Movement Vector

366
00:16:36,910 --> 00:16:39,430
and multiply it by our Movement Delta,

367
00:16:39,430 --> 00:16:43,680
to calculate the actual
movement that should be applied.

368
00:16:43,680 --> 00:16:46,610
And so if the server can properly validate

369
00:16:46,610 --> 00:16:47,980
that both the Movement Delta

370
00:16:47,980 --> 00:16:50,140
and the Movement Vector are saying,

371
00:16:50,140 --> 00:16:51,670
there's not a whole lot we can do

372
00:16:51,670 --> 00:16:53,323
to manipulate our movement.

373
00:16:54,380 --> 00:16:56,380
Now we need to make a slight digression

374
00:16:56,380 --> 00:16:58,500
and talk about floating point.

375
00:16:58,500 --> 00:16:59,840
So when I say floating point,

376
00:16:59,840 --> 00:17:03,990
I'm specifically referring to IEEE 754,

377
00:17:03,990 --> 00:17:06,240
and this is how most computer systems

378
00:17:06,240 --> 00:17:09,400
represent rational numbers,
numbers that can be non whole,

379
00:17:09,400 --> 00:17:12,437
such as one, two, three, four, or 12.34,

380
00:17:12,437 --> 00:17:14,813
anything with a period in it.

381
00:17:16,510 --> 00:17:18,390
And so what's interesting
about floating point

382
00:17:18,390 --> 00:17:20,570
is it has some special values.

383
00:17:20,570 --> 00:17:23,310
Floating point can be used
to represent infinity,

384
00:17:23,310 --> 00:17:25,030
either positive or negative.

385
00:17:25,030 --> 00:17:27,720
It also has a special
value called Not-a-Number,

386
00:17:27,720 --> 00:17:30,340
which I choose to verbalize as NaN.

387
00:17:30,340 --> 00:17:31,930
And for completion sake,

388
00:17:31,930 --> 00:17:35,150
I should say that NaN can
be positive or negative,

389
00:17:35,150 --> 00:17:36,943
but it doesn't typically matter.

390
00:17:38,180 --> 00:17:40,020
These special values, usually,

391
00:17:40,020 --> 00:17:43,410
are the result of some undefined
mathematical operation.

392
00:17:43,410 --> 00:17:44,800
So if you do one,

393
00:17:44,800 --> 00:17:48,570
or if you do any non-zero
number divided by zero

394
00:17:48,570 --> 00:17:50,490
in floating point, you get infinite,

395
00:17:50,490 --> 00:17:52,100
either positive or negative.

396
00:17:52,100 --> 00:17:54,730
If you do zero divided by
zero in floating point,

397
00:17:54,730 --> 00:17:55,840
you get NaN.

398
00:17:55,840 --> 00:17:56,950
Similarly, if you do

399
00:17:56,950 --> 00:17:59,623
square root of negative one, you get NaN.

400
00:18:01,020 --> 00:18:03,100
Now, NaN is really the more interesting

401
00:18:03,100 --> 00:18:04,610
of these two special values,

402
00:18:04,610 --> 00:18:08,070
and it has a couple properties
that are really unique.

403
00:18:08,070 --> 00:18:11,850
The first is that any affirmative
comparison against NaN

404
00:18:11,850 --> 00:18:13,580
will evaluate to false.

405
00:18:13,580 --> 00:18:17,090
So we can compare NaN to
zero in any way we want,

406
00:18:17,090 --> 00:18:18,300
it will always be false.

407
00:18:18,300 --> 00:18:21,360
We can do NaN equals equals zero, false.

408
00:18:21,360 --> 00:18:23,100
Is NaN greater than zero, false.

409
00:18:23,100 --> 00:18:25,060
Is NaN less than zero, false.

410
00:18:25,060 --> 00:18:27,070
We can even compare NaN to itself

411
00:18:27,070 --> 00:18:28,803
and it will still be false.

412
00:18:30,180 --> 00:18:33,400
The other thing is that NaN
has a tendency to propagate.

413
00:18:33,400 --> 00:18:34,480
And by that, I mean,

414
00:18:34,480 --> 00:18:38,890
any mathematical operation
where NaN is an operand

415
00:18:38,890 --> 00:18:40,450
will evaluate to NaN.

416
00:18:40,450 --> 00:18:43,490
So, NaN plus one, minus one, times two,

417
00:18:43,490 --> 00:18:45,630
divided by two, these are all NaN.

418
00:18:45,630 --> 00:18:47,300
And no matter how complex

419
00:18:47,300 --> 00:18:49,680
you make this mathematical operation,

420
00:18:49,680 --> 00:18:53,473
if one operand is NaN, the
entire thing will become NaN.

421
00:18:55,330 --> 00:18:58,260
So this brings up the term NaN Poisoning,

422
00:18:58,260 --> 00:19:01,970
which is a condition where
the unique properties of NaN

423
00:19:01,970 --> 00:19:04,770
cause some sort of intended effect.

424
00:19:04,770 --> 00:19:06,730
So let's look at the following code

425
00:19:06,730 --> 00:19:08,480
as a really simple example of this.

426
00:19:09,460 --> 00:19:12,770
So in this case, the
programmer is trying to ensure

427
00:19:12,770 --> 00:19:17,253
that the floating point number
NaN, is between zero and 100.

428
00:19:18,667 --> 00:19:22,453
The problem here is that if num is NaN,

429
00:19:23,320 --> 00:19:28,320
both of these conditions
will evaluate to false

430
00:19:28,577 --> 00:19:31,720
because any affirmative
comparison with NaN

431
00:19:31,720 --> 00:19:33,190
will evaluate to false.

432
00:19:33,190 --> 00:19:36,460
So NaN will pass these validations

433
00:19:36,460 --> 00:19:39,610
and we will end up acting
on NaN in some way,

434
00:19:39,610 --> 00:19:42,150
assuming that it is a legitimate,

435
00:19:42,150 --> 00:19:45,883
regular floating point number
within the range zero and 100.

436
00:19:47,730 --> 00:19:50,420
So, NaN poisoning attacks are pretty rare

437
00:19:50,420 --> 00:19:52,010
because it's typically difficult

438
00:19:52,010 --> 00:19:54,560
to actually introduce
NaN in the first place.

439
00:19:54,560 --> 00:19:58,320
You don't usually have an
opportunity to divide by zero,

440
00:19:58,320 --> 00:20:01,410
or do square root of a negative number,

441
00:20:01,410 --> 00:20:02,480
or anything like that.

442
00:20:02,480 --> 00:20:04,630
These aren't common bugs.

443
00:20:04,630 --> 00:20:07,730
But, when we're doing
remote procedure calls,

444
00:20:07,730 --> 00:20:11,810
we can use any argument
of the correct type.

445
00:20:11,810 --> 00:20:15,040
So if the RPC calls for
a floating point number,

446
00:20:15,040 --> 00:20:16,840
we can give it any floating point number,

447
00:20:16,840 --> 00:20:18,763
including NaN or Infinite.

448
00:20:20,260 --> 00:20:22,570
So going back to our movement RPC.

449
00:20:22,570 --> 00:20:25,670
There's only one argument that
is a floating point number,

450
00:20:25,670 --> 00:20:27,160
and that's the timestamp.

451
00:20:27,160 --> 00:20:30,270
So what happens if our timestamp is NaN?

452
00:20:30,270 --> 00:20:31,300
Well, to figure this out,

453
00:20:31,300 --> 00:20:34,609
we have to look at this
mouthful of a function.

454
00:20:34,609 --> 00:20:38,942
UCharacterMovementComponent::IsClientTimeStampValid.

455
00:20:39,980 --> 00:20:41,497
So this is a lot to look at,

456
00:20:41,497 --> 00:20:43,520
so we're gonna go through it together.

457
00:20:43,520 --> 00:20:46,380
But let's assume that
our timestamp is NaN,

458
00:20:46,380 --> 00:20:50,560
because that is the value
we've provided to our RPC.

459
00:20:50,560 --> 00:20:52,130
So we get to this first check,

460
00:20:52,130 --> 00:20:53,360
which is intended to ensure

461
00:20:53,360 --> 00:20:55,770
that the timestamp is greater than zero.

462
00:20:55,770 --> 00:20:58,350
And because this is an
affirmative comparison,

463
00:20:58,350 --> 00:20:59,800
this will evaluate to false

464
00:20:59,800 --> 00:21:02,523
and we just skip right
past to the next line.

465
00:21:03,540 --> 00:21:06,600
Then we're going to calculate
our Delta Timestamp,

466
00:21:06,600 --> 00:21:09,920
and this is done by subtracting
our provided timestamp

467
00:21:09,920 --> 00:21:12,130
with the last valid timestamp

468
00:21:12,130 --> 00:21:15,020
that was received from our connection.

469
00:21:15,020 --> 00:21:16,880
But in this case, it does not matter

470
00:21:16,880 --> 00:21:19,220
what that last valid timestamp was,

471
00:21:19,220 --> 00:21:22,710
because our provided timestamp is NaN,

472
00:21:22,710 --> 00:21:26,430
and NaN minus anything will always be NaN.

473
00:21:26,430 --> 00:21:29,920
So Delta Timestamp evaluates to NaN.

474
00:21:29,920 --> 00:21:32,210
Then we get to these next two checks.

475
00:21:32,210 --> 00:21:33,860
And the first case, again,

476
00:21:33,860 --> 00:21:36,540
we're gonna pass right by
because timestamp is NaN,

477
00:21:36,540 --> 00:21:39,210
and this is an affirmative comparison.

478
00:21:39,210 --> 00:21:43,080
And for the next check,
Delta Timestamp is also NaN,

479
00:21:43,080 --> 00:21:46,520
this is another affirmative
comparison we pass right by,

480
00:21:46,520 --> 00:21:50,447
and our timestamp is
considered to be "valid."

481
00:21:52,050 --> 00:21:53,780
So, this is all written in such a way

482
00:21:53,780 --> 00:21:57,360
that just by pure luck, NaN
will just pass right through

483
00:21:57,360 --> 00:21:59,010
and be considered valid.

484
00:21:59,010 --> 00:22:00,360
And so the next thing we do

485
00:22:00,360 --> 00:22:03,970
is we generate our Delta Time using NaN.

486
00:22:03,970 --> 00:22:06,520
So our Delta Time is calculated, again,

487
00:22:06,520 --> 00:22:11,520
by subtracting our last valid timestamp

488
00:22:11,910 --> 00:22:13,860
from our provided timestamp.

489
00:22:13,860 --> 00:22:16,860
And because our provided timestamp is NaN,

490
00:22:16,860 --> 00:22:20,050
Delta Time will evaluate to NaN,

491
00:22:20,050 --> 00:22:22,853
regardless of what our
last valid timestamp was.

492
00:22:24,170 --> 00:22:26,320
Now, the server will use our Delta Time

493
00:22:26,320 --> 00:22:28,480
to attempt to apply our movement,

494
00:22:28,480 --> 00:22:31,120
but this is where we've
run into our first issue.

495
00:22:31,120 --> 00:22:32,990
There's one last sanity check here

496
00:22:32,990 --> 00:22:36,170
to ensure that the Delta
Time is greater than zero.

497
00:22:36,170 --> 00:22:38,650
And we will never pass this check

498
00:22:38,650 --> 00:22:40,300
when Delta Time is NaN,

499
00:22:40,300 --> 00:22:43,050
because it's another
affirmative comparison.

500
00:22:43,050 --> 00:22:44,700
So our movement is not applied,

501
00:22:44,700 --> 00:22:47,400
and even though our timestamp
was considered valid,

502
00:22:47,400 --> 00:22:49,283
we don't go anywhere, we don't move.

503
00:22:51,080 --> 00:22:52,320
But we're not quite done yet

504
00:22:52,320 --> 00:22:55,070
because we've caused another
value to be poisoned.

505
00:22:55,070 --> 00:22:58,070
We've caused
ServerData->CurrentClientTimeStamp

506
00:22:58,070 --> 00:22:58,910
to become NaN.

507
00:22:58,910 --> 00:23:01,840
And this is the saved version

508
00:23:01,840 --> 00:23:03,590
of the last valid timestamp.

509
00:23:03,590 --> 00:23:06,210
Because our timestamp
was considered valid,

510
00:23:06,210 --> 00:23:09,250
even though we didn't apply our movement,

511
00:23:09,250 --> 00:23:13,440
NaN was shifted into that current
client timestamp variable.

512
00:23:13,440 --> 00:23:14,837
Now we need to look at that

513
00:23:14,837 --> 00:23:18,390
isClientTimeStampValid function again.

514
00:23:18,390 --> 00:23:20,830
So, we're looking at
the same function again,

515
00:23:20,830 --> 00:23:22,180
but this time we're gonna assume

516
00:23:22,180 --> 00:23:24,490
that our given timestamp is not NaN,

517
00:23:24,490 --> 00:23:26,320
it's not any special number,

518
00:23:26,320 --> 00:23:30,060
it's just a regular floating
point number greater than zero.

519
00:23:30,060 --> 00:23:31,830
So we bypass this first check.

520
00:23:31,830 --> 00:23:35,070
We get to the Delta Timestamp calculation.

521
00:23:35,070 --> 00:23:37,730
And again, we're gonna
do our given timestamp

522
00:23:37,730 --> 00:23:40,180
minus our last valid timestamp,

523
00:23:40,180 --> 00:23:43,710
but this time, our last
valid timestamp is NaN,

524
00:23:43,710 --> 00:23:47,523
so Delta Time is still
going to calculate as NaN.

525
00:23:48,430 --> 00:23:50,260
Then we get to these two comparisons,

526
00:23:50,260 --> 00:23:52,990
which just as before, we're gonna bypass

527
00:23:52,990 --> 00:23:56,480
because server data,
current client timestamp,

528
00:23:56,480 --> 00:23:58,940
and Delta Time are both NaN.

529
00:23:58,940 --> 00:24:00,780
So we pass these checks, and again,

530
00:24:00,780 --> 00:24:03,120
our timestamp is considered valid.

531
00:24:03,120 --> 00:24:05,950
So on this second RPC call,

532
00:24:05,950 --> 00:24:08,130
any time stamp greater than zero

533
00:24:08,130 --> 00:24:09,520
will pass the validity check.

534
00:24:09,520 --> 00:24:11,470
We could say it's 30 years in the future,

535
00:24:11,470 --> 00:24:14,770
it doesn't matter, as long
as it is greater than zero,

536
00:24:14,770 --> 00:24:18,410
and our first RPC call
used NaN as a timestamp,

537
00:24:18,410 --> 00:24:22,500
our second call will always
pass the validation check.

538
00:24:22,500 --> 00:24:24,510
Unfortunately, our Delta Time

539
00:24:24,510 --> 00:24:26,710
is still going to calculate as NaN

540
00:24:26,710 --> 00:24:30,110
because our old client timestamp was NaN.

541
00:24:30,110 --> 00:24:33,000
So still nothing happens,
we haven't moved an inch.

542
00:24:33,000 --> 00:24:37,030
But fortunately, we've
poisoned one more value now.

543
00:24:37,030 --> 00:24:38,870
So while all this is going on,

544
00:24:38,870 --> 00:24:40,610
the server is trying to determine

545
00:24:40,610 --> 00:24:43,990
if our time has drifted from server time.

546
00:24:43,990 --> 00:24:46,400
Essentially, the server wants to make sure

547
00:24:46,400 --> 00:24:49,160
that we're not doing anything tricky,

548
00:24:49,160 --> 00:24:52,210
or that our clock isn't drifting.

549
00:24:52,210 --> 00:24:53,043
And it does this

550
00:24:53,043 --> 00:24:57,130
by independently calculating
its own Delta Time,

551
00:24:57,130 --> 00:24:59,650
and calculating an error rate,

552
00:24:59,650 --> 00:25:02,080
a difference between our Delta Time

553
00:25:02,080 --> 00:25:03,860
and the server's Delta time.

554
00:25:03,860 --> 00:25:06,500
But because our Delta Time is NaN,

555
00:25:06,500 --> 00:25:09,839
our client error is also going to be NaN.

556
00:25:09,839 --> 00:25:11,410
And then this client error

557
00:25:11,410 --> 00:25:15,280
is used to build up our cumulative value,

558
00:25:15,280 --> 00:25:16,680
new time discrepancy.

559
00:25:16,680 --> 00:25:19,180
And this value is used to detect

560
00:25:19,180 --> 00:25:22,570
when we have drifted too
far from server time.

561
00:25:22,570 --> 00:25:25,010
This is used to detect
speed hacking attempts.

562
00:25:25,010 --> 00:25:26,410
It's also used to detect

563
00:25:26,410 --> 00:25:30,310
when a client might just
be lagging too much.

564
00:25:30,310 --> 00:25:33,680
But because our client error is NaN,

565
00:25:33,680 --> 00:25:36,160
when our client error is added,

566
00:25:36,160 --> 00:25:39,893
our NewTimeDiscrepancy
value also becomes NaN.

567
00:25:41,149 --> 00:25:43,720
And because NewTimeDiscrepancy

568
00:25:43,720 --> 00:25:45,680
is what's used to determine

569
00:25:45,680 --> 00:25:48,703
a difference between client
time and server time,

570
00:25:49,690 --> 00:25:51,370
once we've poisoned this value,

571
00:25:51,370 --> 00:25:54,420
we can essentially disable
the server's ability

572
00:25:54,420 --> 00:25:57,940
to detect the time discrepancy
for our connection.

573
00:25:57,940 --> 00:25:59,930
And so when we actually get to the point

574
00:25:59,930 --> 00:26:04,610
when the server would attempt
to detect a time discrepancy

575
00:26:04,610 --> 00:26:07,090
between our time and server time,

576
00:26:07,090 --> 00:26:08,930
this check will never pass

577
00:26:08,930 --> 00:26:12,280
because NewTimeDiscrepancy is NaN.

578
00:26:12,280 --> 00:26:13,510
And more importantly,

579
00:26:13,510 --> 00:26:15,060
no mathematical operation

580
00:26:15,060 --> 00:26:17,500
will ever cause NewTimeDiscrepancy

581
00:26:17,500 --> 00:26:20,180
to become a regular
floating point number again,

582
00:26:20,180 --> 00:26:22,080
it is stuck as NaN.

583
00:26:22,080 --> 00:26:23,330
So, at this point,

584
00:26:23,330 --> 00:26:27,240
because we've neutered
the server's ability

585
00:26:27,240 --> 00:26:29,710
to detect a time discrepancy,

586
00:26:29,710 --> 00:26:32,590
we can now pull off like
an old-school speed hack,

587
00:26:32,590 --> 00:26:34,400
where we just speed up time

588
00:26:34,400 --> 00:26:37,550
in order to move faster than we should.

589
00:26:37,550 --> 00:26:38,960
And what this allows us to do,

590
00:26:38,960 --> 00:26:41,870
is it allows us to move
significantly faster

591
00:26:41,870 --> 00:26:45,030
than our built-in
limitations would ever allow.

592
00:26:45,030 --> 00:26:47,800
So, I've oversimplified
this process a bit.

593
00:26:47,800 --> 00:26:50,150
I know it's still pretty complicated,

594
00:26:50,150 --> 00:26:53,170
but what I've come up with
as not the most efficient,

595
00:26:53,170 --> 00:26:56,910
but the most straightforward
way of exploiting this,

596
00:26:56,910 --> 00:27:00,090
is to just send RPCs in groups of three,

597
00:27:00,090 --> 00:27:03,187
where the first RPC,
the timestamp, is NaN.

598
00:27:03,187 --> 00:27:04,760
The second, the timestamp

599
00:27:04,760 --> 00:27:06,920
is just slightly greater than zero.

600
00:27:06,920 --> 00:27:09,285
And the third, the timestamp is some value

601
00:27:09,285 --> 00:27:11,150
well in the future.

602
00:27:11,150 --> 00:27:13,770
And every time you send this grouping,

603
00:27:13,770 --> 00:27:16,120
it will move you forward some amount.

604
00:27:16,120 --> 00:27:19,520
And because the server cannot
detect a discrepancy anymore,

605
00:27:19,520 --> 00:27:21,370
you can do this as often as you want,

606
00:27:21,370 --> 00:27:22,850
and the only real limitation

607
00:27:22,850 --> 00:27:25,500
is how quickly you can send those RPCs

608
00:27:25,500 --> 00:27:27,516
and have them be processed.

609
00:27:27,516 --> 00:27:29,790
So, saying all that,

610
00:27:29,790 --> 00:27:32,290
let's actually look at this in action.

611
00:27:32,290 --> 00:27:33,950
And I think you can probably imagine

612
00:27:33,950 --> 00:27:35,130
what this is gonna look like,

613
00:27:35,130 --> 00:27:37,563
but I worked hard on it, so humor me.

614
00:27:39,000 --> 00:27:40,450
This is our first demo.

615
00:27:40,450 --> 00:27:45,450
This is built on a stock
Unreal Engine 4 game template.

616
00:27:47,730 --> 00:27:48,740
All I've done with it

617
00:27:48,740 --> 00:27:52,110
is I've enabled all these
speed hacking protections.

618
00:27:52,110 --> 00:27:53,990
I've opened up the game rule just a bit,

619
00:27:53,990 --> 00:27:55,820
so we can run around some more,

620
00:27:55,820 --> 00:27:57,500
and I've modified the client

621
00:27:57,500 --> 00:27:59,433
to actually pull off our attack.

622
00:28:00,370 --> 00:28:03,010
And this is filmed from
the server perspective,

623
00:28:03,010 --> 00:28:04,010
just so that you can see

624
00:28:04,010 --> 00:28:06,990
that this is actually
happening server-side.

625
00:28:06,990 --> 00:28:10,670
It doesn't just look like
we're moving fast client-side.

626
00:28:10,670 --> 00:28:12,840
So in the background,
we've got our hacker,

627
00:28:12,840 --> 00:28:14,620
as you can see, he's vibrating,

628
00:28:14,620 --> 00:28:17,030
he's very excited to be here.

629
00:28:17,030 --> 00:28:17,863
And what we're gonna do

630
00:28:17,863 --> 00:28:19,080
is we're just gonna get out of the way

631
00:28:19,080 --> 00:28:21,610
so we can get a good view of him running.

632
00:28:21,610 --> 00:28:23,000
And in just a second,

633
00:28:23,000 --> 00:28:25,063
we are gonna see him blast off.

634
00:28:26,020 --> 00:28:26,853
And he's gone.

635
00:28:26,853 --> 00:28:31,853
Oka, so that is a little bit
faster movement than intended,

636
00:28:32,050 --> 00:28:34,730
even with the speed
hacking protections on.

637
00:28:34,730 --> 00:28:38,090
I really liked this bug, I
love floating point bugs.

638
00:28:38,090 --> 00:28:40,130
And the great thing about this one

639
00:28:40,130 --> 00:28:41,880
is that it actually does something

640
00:28:41,880 --> 00:28:45,100
other than just being
like a denial of service.

641
00:28:45,100 --> 00:28:46,700
I also think that this type of attack

642
00:28:46,700 --> 00:28:48,090
can apply in other ways.

643
00:28:48,090 --> 00:28:49,320
I've looked at other games

644
00:28:49,320 --> 00:28:52,400
that use floating point in its RPCs,

645
00:28:52,400 --> 00:28:57,010
and you can usually get some
sort of unintended behavior

646
00:28:57,010 --> 00:28:59,420
by using these special
floating point numbers.

647
00:28:59,420 --> 00:29:00,770
It's not always useful,

648
00:29:00,770 --> 00:29:02,850
it doesn't always do anything
for us for an attacker,

649
00:29:02,850 --> 00:29:05,190
but it usually does something.

650
00:29:05,190 --> 00:29:08,923
I should also say that this
does still apply to Unity,

651
00:29:09,820 --> 00:29:14,820
but with UNET, it doesn't
doesn't limit your movement

652
00:29:15,260 --> 00:29:16,093
in the first place,

653
00:29:16,093 --> 00:29:18,610
so you don't have to go through
this complicated process

654
00:29:18,610 --> 00:29:19,623
to speed hack.

655
00:29:20,820 --> 00:29:23,270
So, with that out of the way,

656
00:29:23,270 --> 00:29:25,050
let's talk about our final bug.

657
00:29:25,050 --> 00:29:26,310
We're gonna go back to UNET,

658
00:29:26,310 --> 00:29:28,533
and this is a session hijacking bug.

659
00:29:29,590 --> 00:29:32,760
So, UNET uses a protocol-level process

660
00:29:32,760 --> 00:29:35,105
to authenticate incoming packets,

661
00:29:35,105 --> 00:29:39,430
because UNET is implemented over UDP,

662
00:29:39,430 --> 00:29:41,570
so you don't get the benefits of TCP

663
00:29:41,570 --> 00:29:45,420
where a stream is already authenticated

664
00:29:45,420 --> 00:29:47,010
and you can assume that a packet

665
00:29:47,010 --> 00:29:50,300
is part of a stream that
you've already seen before.

666
00:29:50,300 --> 00:29:53,320
So, packets are not validated
by their source IP address,

667
00:29:53,320 --> 00:29:55,640
or their source port,
or anything like that,

668
00:29:55,640 --> 00:29:59,930
they're only validated by
values within the packet itself.

669
00:29:59,930 --> 00:30:03,160
So knowing this, it is at
least theoretically possible

670
00:30:03,160 --> 00:30:04,530
that someone could hijack

671
00:30:04,530 --> 00:30:06,860
another player session totally remotely,

672
00:30:06,860 --> 00:30:08,710
totally over the internet.

673
00:30:08,710 --> 00:30:09,960
We don't need a man in the middle,

674
00:30:09,960 --> 00:30:12,700
we don't need to be over
LAN or anything like that.

675
00:30:12,700 --> 00:30:13,950
And that's the plan here.

676
00:30:14,970 --> 00:30:19,090
So when UNET validates an incoming packet,

677
00:30:19,090 --> 00:30:21,810
there are three important
values it looks at.

678
00:30:21,810 --> 00:30:23,380
The first is the Host ID,

679
00:30:23,380 --> 00:30:25,500
then the Session ID, and the Packet ID.

680
00:30:25,500 --> 00:30:27,610
And these names don't mean
anything on their own,

681
00:30:27,610 --> 00:30:29,423
so let's look at each one in detail.

682
00:30:30,980 --> 00:30:33,390
So the first of these
values is the Host ID,

683
00:30:33,390 --> 00:30:35,570
and this is a 16-bit integer

684
00:30:35,570 --> 00:30:39,180
that's used to associate a
packet with a given client.

685
00:30:39,180 --> 00:30:42,470
Host IDs are assigned
sequentially starting at one.

686
00:30:42,470 --> 00:30:45,570
So the first client to
connect, gets Host ID one,

687
00:30:45,570 --> 00:30:48,870
the second client gets
Host ID two, et cetera.

688
00:30:48,870 --> 00:30:51,810
Now, Host IDs aren't really
intended to be a secret,

689
00:30:51,810 --> 00:30:54,100
so in a way, we can sort
of just ignore them.

690
00:30:54,100 --> 00:30:56,070
It's also really easy to enumerate

691
00:30:56,070 --> 00:30:57,920
the Host ID of another player.

692
00:30:57,920 --> 00:30:59,560
If we're the second player in a game

693
00:30:59,560 --> 00:31:01,310
and we get Host ID two,

694
00:31:01,310 --> 00:31:04,000
the other player's probably Host ID one.

695
00:31:04,000 --> 00:31:08,020
If we're in a Battle Royale
and we're Host ID 47,

696
00:31:08,020 --> 00:31:10,567
the other Host IDs are
probably one through 46,

697
00:31:10,567 --> 00:31:12,183
and 48 through a hundred.

698
00:31:13,430 --> 00:31:15,280
Things get a little more complicated

699
00:31:15,280 --> 00:31:16,750
when we talk about the next value,

700
00:31:16,750 --> 00:31:18,720
which is the Session ID.

701
00:31:18,720 --> 00:31:22,210
The Session ID is the
primary authenticating secret

702
00:31:22,210 --> 00:31:23,530
of a connection.

703
00:31:23,530 --> 00:31:26,000
And the Session ID is randomly generated

704
00:31:26,000 --> 00:31:27,760
by the client when they connect.

705
00:31:27,760 --> 00:31:30,420
And every packet received for that client

706
00:31:30,420 --> 00:31:32,190
has to have the correct Session ID

707
00:31:32,190 --> 00:31:34,023
or the packet will be discarded.

708
00:31:35,300 --> 00:31:37,410
There are a couple problems
with the Session ID though.

709
00:31:37,410 --> 00:31:39,210
The first is that the Session ID

710
00:31:39,210 --> 00:31:43,580
is also a 16-bit integer,
it also can't be zero.

711
00:31:43,580 --> 00:31:48,580
This means that there's only
65,535 possible Session IDs.

712
00:31:49,110 --> 00:31:50,370
There's also no penalty

713
00:31:50,370 --> 00:31:53,280
for incorrectly guessing a Session ID

714
00:31:53,280 --> 00:31:54,640
other than the fact that our packet

715
00:31:54,640 --> 00:31:56,720
will just be discarded by the server.

716
00:31:56,720 --> 00:32:01,140
So we can easily brute force
the whole range of Session IDs,

717
00:32:01,140 --> 00:32:03,610
even over the open
internet, it doesn't matter,

718
00:32:03,610 --> 00:32:05,010
it doesn't take long at all.

719
00:32:06,020 --> 00:32:08,049
Now, we don't really need to do this part,

720
00:32:08,049 --> 00:32:10,210
but there is one more thing we can do

721
00:32:10,210 --> 00:32:12,980
to narrow down that search even more.

722
00:32:12,980 --> 00:32:14,640
So, Session IDs are generated

723
00:32:14,640 --> 00:32:19,000
with a function named
UNET::GetRandNotZero.

724
00:32:19,000 --> 00:32:22,050
And what this function does
is exactly what the name says.

725
00:32:22,050 --> 00:32:23,730
It gets a random number and ensures

726
00:32:23,730 --> 00:32:26,140
that that random number is not zero.

727
00:32:26,140 --> 00:32:28,010
And this is used for Session IDs

728
00:32:28,010 --> 00:32:30,273
because session IDs cannot be zero.

729
00:32:31,260 --> 00:32:34,640
So, the way this function actually works

730
00:32:34,640 --> 00:32:37,770
is it takes the end
result, that random number,

731
00:32:37,770 --> 00:32:39,450
and it OR's it with one.

732
00:32:39,450 --> 00:32:40,750
It essentially ensures

733
00:32:40,750 --> 00:32:43,170
that the least significant
bit of that output

734
00:32:43,170 --> 00:32:44,950
will always be one.

735
00:32:44,950 --> 00:32:46,720
This has the effect of ensuring

736
00:32:46,720 --> 00:32:48,600
that a legitimate UNET client

737
00:32:48,600 --> 00:32:52,180
will only ever generate an
odd-numbered Session ID.

738
00:32:52,180 --> 00:32:53,410
Technically, a Session ID

739
00:32:53,410 --> 00:32:56,510
can be any 16-bit value other than zero,

740
00:32:56,510 --> 00:32:58,520
but a legitimate client is programmed

741
00:32:58,520 --> 00:33:02,350
to never actually generate
one, unless it's odd.

742
00:33:02,350 --> 00:33:04,660
So this reduces the possible Session IDs

743
00:33:04,660 --> 00:33:09,193
down to 32,768, so 50%.

744
00:33:10,500 --> 00:33:11,960
So if we know the Host ID,

745
00:33:11,960 --> 00:33:15,010
and we can guess the Session
ID, that's all we need

746
00:33:15,010 --> 00:33:16,950
for our spoofed packet to be accepted

747
00:33:16,950 --> 00:33:19,740
within the context of
another player's session.

748
00:33:19,740 --> 00:33:23,020
But there is one more hiccup,
and that's the Packet ID.

749
00:33:23,020 --> 00:33:24,600
The Packet ID is an integer

750
00:33:24,600 --> 00:33:27,840
that's incremented with each
packet sent by the client,

751
00:33:27,840 --> 00:33:29,230
basically a sequence number.

752
00:33:29,230 --> 00:33:31,173
And again, it's 16-bits long.

753
00:33:32,880 --> 00:33:34,410
So what the Packet ID is for

754
00:33:34,410 --> 00:33:37,810
is it's used to detect duplicate
or out of order packets,

755
00:33:37,810 --> 00:33:41,920
because again, UDP
isn't doing this for us.

756
00:33:41,920 --> 00:33:44,700
It's also used to determine
the rate of packet loss.

757
00:33:44,700 --> 00:33:48,020
So if the last Packet ID
received by the server is one,

758
00:33:48,020 --> 00:33:50,710
and the next Packet ID it gets is 1,000,

759
00:33:50,710 --> 00:33:51,910
the server is going to assume

760
00:33:51,910 --> 00:33:56,557
that it's lost 9,998
packets, in the meantime.

761
00:34:00,690 --> 00:34:03,643
So, if we can determine the Host ID

762
00:34:04,570 --> 00:34:06,070
and guess the Session ID,

763
00:34:06,070 --> 00:34:07,960
what can we do with the Packet ID?

764
00:34:07,960 --> 00:34:09,520
I guess a better question might be

765
00:34:09,520 --> 00:34:11,960
what happens if we just
send a random Packet ID?

766
00:34:11,960 --> 00:34:16,243
Well, let's read Unity's
documentation on exactly this.

767
00:34:17,430 --> 00:34:19,448
So according to the documentation,

768
00:34:19,448 --> 00:34:21,260
there are a few conditions.

769
00:34:21,260 --> 00:34:23,320
If the new Packet ID is greater

770
00:34:23,320 --> 00:34:26,210
than the last packet ID plus 512,

771
00:34:26,210 --> 00:34:27,930
we're gonna disconnect the session

772
00:34:27,930 --> 00:34:30,129
because we've lost too many packets.

773
00:34:30,129 --> 00:34:33,060
If the Packet ID is more than 512

774
00:34:33,060 --> 00:34:36,260
behind the current Packet ID,

775
00:34:36,260 --> 00:34:38,360
we're gonna discard it
because it's too old,

776
00:34:38,360 --> 00:34:39,610
we don't want it anymore.

777
00:34:41,020 --> 00:34:41,980
If the Packet ID

778
00:34:41,980 --> 00:34:44,940
is in a list of packets
we've seen recently,

779
00:34:44,940 --> 00:34:47,420
it's a duplicate, let's discard it.

780
00:34:47,420 --> 00:34:49,730
Otherwise, if none of
these conditions are met,

781
00:34:49,730 --> 00:34:51,983
we're gonna accept and
process that packet.

782
00:34:53,350 --> 00:34:55,370
So there are a couple
interesting things about this.

783
00:34:55,370 --> 00:34:58,270
The first is that, if our guest Packet ID

784
00:34:58,270 --> 00:35:02,000
is greater than our last
packet ID, plus 512,

785
00:35:02,000 --> 00:35:03,780
the connection will be disconnected.

786
00:35:03,780 --> 00:35:04,650
And I want to emphasize

787
00:35:04,650 --> 00:35:07,040
that this is not our
connection we're talking about,

788
00:35:07,040 --> 00:35:09,680
this is the other player's connection.

789
00:35:09,680 --> 00:35:11,280
So this is useful because it means

790
00:35:11,280 --> 00:35:15,013
we can pretty trivially kick
other players off the server.

791
00:35:16,180 --> 00:35:18,220
However, it would be
a lot more interesting

792
00:35:18,220 --> 00:35:19,850
if we could bypass this check

793
00:35:19,850 --> 00:35:24,850
and inject a packet that
would be actually executed

794
00:35:24,890 --> 00:35:26,733
within another player's session.

795
00:35:27,670 --> 00:35:29,380
But reading the documentation,

796
00:35:29,380 --> 00:35:32,400
it seems like the odds of
this happening are pretty low.

797
00:35:32,400 --> 00:35:35,440
Yes, Packet ID must be the last Packet ID

798
00:35:35,440 --> 00:35:37,290
plus or minus 512,

799
00:35:37,290 --> 00:35:38,170
which, doing the math,

800
00:35:38,170 --> 00:35:41,050
gives us less than a 7% chance of success.

801
00:35:41,050 --> 00:35:42,223
That's pretty bad.

802
00:35:43,310 --> 00:35:45,840
But when we look at the
actual implementation,

803
00:35:45,840 --> 00:35:48,710
it tells a slightly different story.

804
00:35:48,710 --> 00:35:51,490
So, Packet ID validation
is done by the function

805
00:35:51,490 --> 00:35:55,150
UNET::ReplayProtector::IsPacketReplayed

806
00:35:55,150 --> 00:35:56,510
In practice, this function

807
00:35:56,510 --> 00:35:58,860
actually does not discard packets

808
00:35:58,860 --> 00:36:01,290
that are more than 512 packets old,

809
00:36:01,290 --> 00:36:03,100
like the documentation said.

810
00:36:03,100 --> 00:36:04,480
I spent a lot of time thinking

811
00:36:04,480 --> 00:36:06,160
that I was just misunderstanding,

812
00:36:06,160 --> 00:36:08,660
or that it was more complicated
than I thought, but no,

813
00:36:08,660 --> 00:36:12,640
the logic for discarding old
packets just isn't there.

814
00:36:12,640 --> 00:36:14,620
Instead, old packets are accepted

815
00:36:14,620 --> 00:36:17,973
as if they weren't more
than 512 packets old.

816
00:36:19,190 --> 00:36:21,480
So unfortunately, it's a
little more complicated

817
00:36:21,480 --> 00:36:26,090
than it sounds, we can't just
use Packet ID zero every time,

818
00:36:26,090 --> 00:36:29,137
even though that would
be the lowest Packet ID.

819
00:36:29,137 --> 00:36:30,560
And the reason for that

820
00:36:30,560 --> 00:36:33,630
is that the server has
to account for cases

821
00:36:33,630 --> 00:36:35,490
where the packet ID overflows,

822
00:36:35,490 --> 00:36:37,557
goes from FFFF to zero.

823
00:36:37,557 --> 00:36:40,680
And this happens pretty often
over the course of a game.

824
00:36:40,680 --> 00:36:45,520
So instead of just directly
comparing the numeric value,

825
00:36:45,520 --> 00:36:49,560
the server has to keep like a
rolling window of Packet IDs

826
00:36:49,560 --> 00:36:52,530
to determine if a packet is old or new.

827
00:36:52,530 --> 00:36:54,393
And so doing the math here,

828
00:36:54,393 --> 00:36:57,630
we have what's very close to a 50/50 shot

829
00:36:57,630 --> 00:37:00,005
that our Packet ID will be accepted.

830
00:37:00,005 --> 00:37:02,310
Most of the rest of the time,

831
00:37:02,310 --> 00:37:04,510
our packet is gonna cause the other player

832
00:37:04,510 --> 00:37:08,490
to get kicked out of the game,
which is still pretty useful.

833
00:37:08,490 --> 00:37:10,570
And I say, most of the rest of the time,

834
00:37:10,570 --> 00:37:13,440
because occasionally
we'll guess a Packet ID

835
00:37:13,440 --> 00:37:15,350
that was actually seen recently,

836
00:37:15,350 --> 00:37:18,163
and it'll be seen as a
duplicate and just be discarded.

837
00:37:19,310 --> 00:37:21,130
Okay, so let's look at our second demo.

838
00:37:21,130 --> 00:37:23,600
And for this, I had to use an actual game,

839
00:37:23,600 --> 00:37:26,070
not just something I came up with myself.

840
00:37:26,070 --> 00:37:28,530
And this game is called, Streets of Rogue.

841
00:37:28,530 --> 00:37:31,260
It's very cool, you should buy it.

842
00:37:31,260 --> 00:37:32,840
And I do want to emphasize

843
00:37:32,840 --> 00:37:36,570
that this is not a bug in the game itself,

844
00:37:36,570 --> 00:37:38,910
there's nothing wrong with
how this game is programmed,

845
00:37:38,910 --> 00:37:40,340
this is a bug in UNET.

846
00:37:40,340 --> 00:37:44,400
But even still, what we're
gonna do with this bug

847
00:37:44,400 --> 00:37:47,120
is we're going to inject packets

848
00:37:47,120 --> 00:37:48,740
to cause two other players

849
00:37:48,740 --> 00:37:51,530
to do actions that we tell them to.

850
00:37:51,530 --> 00:37:53,830
So, this little guy in
the red shirt is me,

851
00:37:53,830 --> 00:37:55,744
and these two identical looking people

852
00:37:55,744 --> 00:37:58,060
are our target players.

853
00:37:58,060 --> 00:37:59,350
And what we're gonna do

854
00:37:59,350 --> 00:38:00,760
is we're gonna inject packets,

855
00:38:00,760 --> 00:38:02,470
we're gonna see them do a few things.

856
00:38:02,470 --> 00:38:04,470
First, they're gonna say hi to everyone.

857
00:38:05,560 --> 00:38:07,560
Then we're gonna kill them both.

858
00:38:07,560 --> 00:38:09,210
Then I started to feel a little bit bad,

859
00:38:09,210 --> 00:38:10,970
so we're gonna resurrect them both,

860
00:38:10,970 --> 00:38:12,643
and then we're gonna kill them again.

861
00:38:14,320 --> 00:38:17,470
Okay, so this is a pretty simple demo,

862
00:38:17,470 --> 00:38:20,520
kind of stupid, but it
demonstrates a few things.

863
00:38:20,520 --> 00:38:23,330
The first is that we're
able to inject packets

864
00:38:23,330 --> 00:38:25,270
that are actually accepted

865
00:38:25,270 --> 00:38:28,640
within the context of
another player's session.

866
00:38:28,640 --> 00:38:31,190
The second is that we're able
to do it consistently enough

867
00:38:31,190 --> 00:38:32,910
that we're able to do it for two players

868
00:38:32,910 --> 00:38:34,440
at the exact same time,

869
00:38:34,440 --> 00:38:37,020
even though those two players
have different Host IDs,

870
00:38:37,020 --> 00:38:40,396
different Session IDs, different
Packet IDs, everything.

871
00:38:40,396 --> 00:38:43,560
And finally, we're able to
do it consistently enough

872
00:38:43,560 --> 00:38:45,760
that we're able to inject multiple packets

873
00:38:45,760 --> 00:38:47,070
into each player's session.

874
00:38:47,070 --> 00:38:49,830
We were able to inject a
packet to say something,

875
00:38:49,830 --> 00:38:53,940
pause, inject another packet
to cause them to explode,

876
00:38:53,940 --> 00:38:56,210
pause, and then do this four times,

877
00:38:56,210 --> 00:38:58,090
injecting four different packets.

878
00:38:58,090 --> 00:39:00,940
So this bug is pretty reliable.

879
00:39:00,940 --> 00:39:05,760
And as I said, even if
you lose the coin toss,

880
00:39:05,760 --> 00:39:08,800
all that happens is you kick
another player out of the game,

881
00:39:08,800 --> 00:39:10,793
which has its utilities on its own.

882
00:39:11,890 --> 00:39:15,060
So let's talk about
remediation's for this bug.

883
00:39:15,060 --> 00:39:15,900
This is considered

884
00:39:15,900 --> 00:39:18,820
to be an architectural weakness with UNET.

885
00:39:18,820 --> 00:39:21,120
The actual fixes that would be required

886
00:39:21,120 --> 00:39:25,760
to prevent this entirely,
are not going to happen.

887
00:39:25,760 --> 00:39:28,950
The only mitigation, aside
from moving away from UNET,

888
00:39:28,950 --> 00:39:31,210
is to actually encrypt UNET.

889
00:39:32,377 --> 00:39:35,260
Unity does provide a
reference implementation

890
00:39:35,260 --> 00:39:37,130
that does a decent job of this,

891
00:39:37,130 --> 00:39:40,610
but it's not complete, it
doesn't do key exchange for you.

892
00:39:40,610 --> 00:39:44,360
So to an extent, you are
still on your own with this.

893
00:39:44,360 --> 00:39:47,340
And I have looked a lot, but
I've not found a single game

894
00:39:47,340 --> 00:39:50,020
implementing encryption over UNET.

895
00:39:50,020 --> 00:39:52,670
And I should emphasize
that this is a mitigation,

896
00:39:52,670 --> 00:39:54,120
it is not a fix.

897
00:39:54,120 --> 00:39:58,750
So if your encryption is not complete,

898
00:39:58,750 --> 00:40:01,681
if an attacker can bypass this encryption,

899
00:40:01,681 --> 00:40:06,681
these bugs still exist exactly
the same as they exist now.

900
00:40:07,810 --> 00:40:10,090
Okay, so that was my final bug.

901
00:40:10,090 --> 00:40:12,120
So let's talk about some future work.

902
00:40:12,120 --> 00:40:15,430
I don't think I've found all the bugs,

903
00:40:15,430 --> 00:40:18,290
even in the components
that I have looked at,

904
00:40:18,290 --> 00:40:19,620
but there are a few components

905
00:40:19,620 --> 00:40:21,360
that I haven't looked at at all,

906
00:40:21,360 --> 00:40:23,080
that I think are worth looking at.

907
00:40:23,080 --> 00:40:26,180
So, both of these protocols
have other transport modes.

908
00:40:26,180 --> 00:40:28,790
I think the most interesting
of these are our websockets

909
00:40:28,790 --> 00:40:31,440
because that's what browser
games are gonna be using.

910
00:40:32,500 --> 00:40:34,890
There's also third
party networking plugins

911
00:40:34,890 --> 00:40:36,420
for some of these engines.

912
00:40:36,420 --> 00:40:40,860
Photon and Mirror are two
relatively common ones for Unity,

913
00:40:40,860 --> 00:40:42,490
and there's just other engines.

914
00:40:42,490 --> 00:40:44,893
GameMaker Studio, Godot, stuff like that.

915
00:40:46,730 --> 00:40:49,400
Finally, I want to thank a few people.

916
00:40:49,400 --> 00:40:52,430
Both Epic Games and Unity Technologies,

917
00:40:52,430 --> 00:40:55,490
their security teams were
absolutely fantastic,

918
00:40:55,490 --> 00:40:58,930
super communicative, kept me
up to date the entire time,

919
00:40:58,930 --> 00:41:03,410
put up with a lot of me,
which can be very annoying.

920
00:41:03,410 --> 00:41:06,610
I have nothing but good things
to say about both of them.

921
00:41:06,610 --> 00:41:07,840
I also want to thank the artist

922
00:41:07,840 --> 00:41:11,390
who made the background
art for my presentation.

923
00:41:11,390 --> 00:41:13,640
Grigoreen, he's awesome.

924
00:41:13,640 --> 00:41:16,500
And finally, all the scripts,

925
00:41:16,500 --> 00:41:20,340
everything I've put
together for this work,

926
00:41:20,340 --> 00:41:21,550
I've got up on GitHub.

927
00:41:21,550 --> 00:41:23,830
I've got POCs for most of these issues.

928
00:41:23,830 --> 00:41:25,610
I've got libraries for interfacing

929
00:41:25,610 --> 00:41:29,630
with UNET, and Unreal's protocol.

930
00:41:29,630 --> 00:41:33,390
And I hope that if I
can ask anything of you,

931
00:41:33,390 --> 00:41:36,090
is that you go, you use something
that you've learned here

932
00:41:36,090 --> 00:41:37,990
to go get banned from some video game.

