1
00:00:02,010 --> 00:00:03,423
- Hello, my name is Allison.

2
00:00:07,470 --> 00:00:08,633
- Hi, my name's Dylan.

3
00:00:12,500 --> 00:00:14,820
We've been researching GCP
for the last year and a half,

4
00:00:14,820 --> 00:00:16,320
and we've come up with some effective ways

5
00:00:16,320 --> 00:00:18,570
that compromise most GCP organizations,

6
00:00:18,570 --> 00:00:20,060
all the ones who've looked at anyway.

7
00:00:20,060 --> 00:00:21,740
These techniques involve moving laterally

8
00:00:21,740 --> 00:00:23,750
with surface accounts and cloud APIs.

9
00:00:23,750 --> 00:00:26,383
We have a lot of ground to
cover, so let's get to it.

10
00:00:29,094 --> 00:00:31,677
(upbeat music)

11
00:00:38,430 --> 00:00:40,800
I think everyone has a
slightly different reaction

12
00:00:40,800 --> 00:00:42,950
when they first start
learning about GCPIM.

13
00:00:44,060 --> 00:00:45,307
- What the fuck!

14
00:00:45,307 --> 00:00:46,890
- But one common thing I've observed

15
00:00:46,890 --> 00:00:49,310
is people often compare it to AWS IAM

16
00:00:49,310 --> 00:00:50,740
but there are some pretty key differences

17
00:00:50,740 --> 00:00:52,720
between GCP and AWS IAM.

18
00:00:52,720 --> 00:00:54,590
So let's talk about some
of those differences.

19
00:00:54,590 --> 00:00:57,400
First in AWS, we have user identities,

20
00:00:57,400 --> 00:00:59,950
and those user identities can be exported

21
00:00:59,950 --> 00:01:03,263
in the form of credentials,
which looks something like this.

22
00:01:04,236 --> 00:01:07,180
In GCP, the equivalent
is a service account

23
00:01:07,180 --> 00:01:10,120
and service accounts can also be exported

24
00:01:10,120 --> 00:01:11,860
in credentials that look
a little bit differently,

25
00:01:11,860 --> 00:01:12,883
they look like this.

26
00:01:14,550 --> 00:01:18,160
And in both cases, we have
owners of these identities,

27
00:01:18,160 --> 00:01:19,730
but where things get
a little bit different

28
00:01:19,730 --> 00:01:21,370
is when you start to ask the question,

29
00:01:21,370 --> 00:01:23,480
what can my identity access?

30
00:01:23,480 --> 00:01:26,270
In the world of AWS, you
basically have a policy

31
00:01:26,270 --> 00:01:28,000
that determines all the different things

32
00:01:28,000 --> 00:01:31,770
that the identity can access
and the person who can create,

33
00:01:31,770 --> 00:01:33,720
read, update, delete that policy

34
00:01:33,720 --> 00:01:36,310
is the same person who owns the identity.

35
00:01:36,310 --> 00:01:38,560
So here's an example of
what that looks like.

36
00:01:39,641 --> 00:01:40,870
In GCP though, this is where things

37
00:01:40,870 --> 00:01:41,910
start getting really different.

38
00:01:41,910 --> 00:01:45,390
Instead of having a centralized
policy for a given identity,

39
00:01:45,390 --> 00:01:47,660
we have policies for resources.

40
00:01:47,660 --> 00:01:50,040
So in this case, we've got
a bucket and a bucket owner,

41
00:01:50,040 --> 00:01:52,140
and that bucket has a policy.

42
00:01:52,140 --> 00:01:54,500
The bucket owner controls who can create,

43
00:01:54,500 --> 00:01:56,720
read, update or delete that policy,

44
00:01:56,720 --> 00:01:59,190
and that policy applies
to whatever identity

45
00:01:59,190 --> 00:02:00,700
the bucket owner wants it to.

46
00:02:00,700 --> 00:02:03,250
So here's an example
of what that looks like

47
00:02:03,250 --> 00:02:04,313
for our storage.

48
00:02:05,930 --> 00:02:08,350
What's interesting here is that the owner

49
00:02:08,350 --> 00:02:11,970
of the service account actually
doesn't have any insight

50
00:02:11,970 --> 00:02:13,290
into this policy.

51
00:02:13,290 --> 00:02:15,550
They can't view it, they can't update it,

52
00:02:15,550 --> 00:02:17,890
they don't even know that
their service account

53
00:02:17,890 --> 00:02:19,600
was given access to this bucket.

54
00:02:19,600 --> 00:02:21,720
Instead, the bucket owner controls this,

55
00:02:21,720 --> 00:02:23,680
and if the owner of the service account

56
00:02:23,680 --> 00:02:25,560
doesn't have IAM list on the bucket,

57
00:02:25,560 --> 00:02:26,830
then they won't be able

58
00:02:26,830 --> 00:02:29,353
to even see that that policy was granted.

59
00:02:30,930 --> 00:02:32,760
And I think this is one
of the harder concepts

60
00:02:32,760 --> 00:02:35,417
that was for me personally,
to wrap my head around a GCP

61
00:02:35,417 --> 00:02:36,913
is if you have an identity and GCP

62
00:02:36,913 --> 00:02:39,210
like a user or a surface account,

63
00:02:39,210 --> 00:02:40,690
as the owner of that identity,

64
00:02:40,690 --> 00:02:44,030
you can't actually know what
that identity has access to.

65
00:02:44,030 --> 00:02:46,280
In fact, no one can answer the question.

66
00:02:46,280 --> 00:02:48,180
What does the service
account have access to.

67
00:02:48,180 --> 00:02:50,930
Instead, resource owners
control what the policy is

68
00:02:50,930 --> 00:02:51,890
for a given resource.

69
00:02:51,890 --> 00:02:53,400
So you can answer questions like

70
00:02:53,400 --> 00:02:55,170
who has access to this bucket,

71
00:02:55,170 --> 00:02:56,380
but you can't answer questions

72
00:02:56,380 --> 00:02:58,390
like how many buckets
does the service account

73
00:02:58,390 --> 00:02:59,850
have access to or what buckets

74
00:02:59,850 --> 00:03:01,740
does the service account have access to?

75
00:03:01,740 --> 00:03:04,760
Those questions are
unanswerable by design in GCP.

76
00:03:04,760 --> 00:03:07,160
Likewise, we can have other
resources like big query,

77
00:03:07,160 --> 00:03:09,440
for example, and we have
an owner for the big query

78
00:03:09,440 --> 00:03:10,850
and a policy for the big query

79
00:03:10,850 --> 00:03:12,860
and the owner of the big query can again,

80
00:03:12,860 --> 00:03:15,180
grant access to any identity they want.

81
00:03:15,180 --> 00:03:17,790
However, the owner of the service account

82
00:03:17,790 --> 00:03:19,790
has no control over
this and can't see this.

83
00:03:19,790 --> 00:03:21,490
One thing you might be
wondering is before,

84
00:03:21,490 --> 00:03:23,340
when I mentioned that the
owner of a service account

85
00:03:23,340 --> 00:03:24,810
can't fully answer the question,

86
00:03:24,810 --> 00:03:26,730
what does the surface
account have access to,

87
00:03:26,730 --> 00:03:29,220
you might be thinking, well,
if you own an organization,

88
00:03:29,220 --> 00:03:31,210
can't you just get the IAM policies

89
00:03:31,210 --> 00:03:32,950
of all the resources in the organization.

90
00:03:32,950 --> 00:03:34,860
Well, someone outside your organization

91
00:03:34,860 --> 00:03:36,560
can still grant your
service account access

92
00:03:36,560 --> 00:03:37,660
to their resources.

93
00:03:37,660 --> 00:03:39,000
So when I said before,

94
00:03:39,000 --> 00:03:40,770
you can't actually answer the question,

95
00:03:40,770 --> 00:03:42,480
what does your service
account have access to,

96
00:03:42,480 --> 00:03:43,313
it's true.

97
00:03:43,313 --> 00:03:44,720
You cannot get the answer to the question

98
00:03:44,720 --> 00:03:46,500
because people outside your organization

99
00:03:46,500 --> 00:03:48,990
can also grant access to their resources.

100
00:03:48,990 --> 00:03:50,000
We'll come back to that later

101
00:03:50,000 --> 00:03:53,030
and explain what an organization
is and how it's structured.

102
00:03:53,030 --> 00:03:54,380
But for now, I figured
I'd just mentioned that

103
00:03:54,380 --> 00:03:55,350
in case you were wondering.

104
00:03:55,350 --> 00:03:58,150
As you might imagine, not
having it troll or visibility

105
00:03:58,150 --> 00:03:59,700
into what your service accounts can

106
00:03:59,700 --> 00:04:02,120
or can't access comes
with some challenges.

107
00:04:02,120 --> 00:04:02,953
And one particular place

108
00:04:02,953 --> 00:04:04,580
I think those challenges
manifest themselves

109
00:04:04,580 --> 00:04:06,630
is in a multitenant
Kubernetes environment.

110
00:04:06,630 --> 00:04:08,350
Google has a managed Kubernetes engine,

111
00:04:08,350 --> 00:04:10,420
it's often shorthanded GKE.

112
00:04:10,420 --> 00:04:11,960
If you're familiar with Kubernetes,

113
00:04:11,960 --> 00:04:14,380
you have a bunch of notes,
and within those notes,

114
00:04:14,380 --> 00:04:15,570
you have workloads.

115
00:04:15,570 --> 00:04:18,170
In GKE, those nodes are powered by VMs,

116
00:04:18,170 --> 00:04:20,780
and those VMs have service
accounts attached to them.

117
00:04:20,780 --> 00:04:22,080
If we take a look at console,

118
00:04:22,080 --> 00:04:23,970
we can see a Kubernetes cluster here

119
00:04:23,970 --> 00:04:26,423
that's powered by four underlying notes.

120
00:04:28,180 --> 00:04:30,100
Then, if we hop over to compute engine

121
00:04:30,100 --> 00:04:31,610
and click on VM instances,

122
00:04:31,610 --> 00:04:33,240
we'll see the same four instances.

123
00:04:33,240 --> 00:04:34,430
And if we click into one of them,

124
00:04:34,430 --> 00:04:35,900
we'll see that we have a service account

125
00:04:35,900 --> 00:04:36,750
that's attached to it.

126
00:04:36,750 --> 00:04:38,350
We talked a little bit about how workloads

127
00:04:38,350 --> 00:04:39,920
interact with the service account

128
00:04:39,920 --> 00:04:41,940
in our byside, San
Francisco talk this year.

129
00:04:41,940 --> 00:04:43,490
So feel free to check that out.

130
00:04:44,410 --> 00:04:46,040
But in short, anything running on the node

131
00:04:46,040 --> 00:04:47,380
can access this identity.

132
00:04:47,380 --> 00:04:48,790
So it's a good idea to descope it

133
00:04:48,790 --> 00:04:50,140
and not give it many privileges.

134
00:04:50,140 --> 00:04:52,110
But let's think about
what that actually means.

135
00:04:52,110 --> 00:04:54,400
We have a Kubernetes
admin that runs the nodes

136
00:04:54,400 --> 00:04:56,067
and the surface account
powering the nodes.

137
00:04:56,067 --> 00:04:57,880
And then we have a bunch of developers

138
00:04:57,880 --> 00:05:00,210
that run the workloads
on the Kubernetes engine.

139
00:05:00,210 --> 00:05:01,980
Those developers may be on separate teams

140
00:05:01,980 --> 00:05:04,480
and maybe in control of separate
resources from each other

141
00:05:04,480 --> 00:05:05,810
and from the Kubernetes admin.

142
00:05:05,810 --> 00:05:07,220
So you can imagine in this case,

143
00:05:07,220 --> 00:05:10,240
we have dev1 and dev2 that
have both deployed workloads,

144
00:05:10,240 --> 00:05:11,790
workload one and workload two.

145
00:05:11,790 --> 00:05:13,640
Likewise, they both control resources.

146
00:05:13,640 --> 00:05:15,720
In this case, we'll say
that they both own a bucket

147
00:05:15,720 --> 00:05:16,870
and they want their workloads

148
00:05:16,870 --> 00:05:18,220
to be able to access that bucket.

149
00:05:18,220 --> 00:05:20,860
One really easy way to
do that is to just give

150
00:05:20,860 --> 00:05:23,530
the service account on the
node access to the bucket.

151
00:05:23,530 --> 00:05:26,120
But the downside to doing
that is instead of just giving

152
00:05:26,120 --> 00:05:27,650
their workload access to the bucket,

153
00:05:27,650 --> 00:05:29,720
they'll give every workload
access to the bucket.

154
00:05:29,720 --> 00:05:32,050
The developers in this
case control this story.

155
00:05:32,050 --> 00:05:34,410
They control what the
service account has access to

156
00:05:34,410 --> 00:05:36,020
because they're the resource owners.

157
00:05:36,020 --> 00:05:38,130
The Kubernetes admin does not control this

158
00:05:38,130 --> 00:05:39,690
and cannot see that this even happened.

159
00:05:39,690 --> 00:05:41,620
So you can imagine in a situation

160
00:05:41,620 --> 00:05:44,460
where you have a small
team of Kubernetes admins

161
00:05:44,460 --> 00:05:46,190
that are trying to maintain a cluster

162
00:05:46,190 --> 00:05:48,660
that want to open it up
to give many developers,

163
00:05:48,660 --> 00:05:50,870
the ability to deploy
workloads to this cluster.

164
00:05:50,870 --> 00:05:52,100
It can be difficult to secure

165
00:05:52,100 --> 00:05:54,140
because they can't control
what the service account

166
00:05:54,140 --> 00:05:56,400
attached to the nodes has access to.

167
00:05:56,400 --> 00:05:57,800
And some developers may want

168
00:05:57,800 --> 00:06:00,580
to just give that service
account access to resources.

169
00:06:00,580 --> 00:06:03,840
Rather than using something
like Kubernetes Secrets or Vault

170
00:06:03,840 --> 00:06:05,950
to pass credentials to those workloads,

171
00:06:05,950 --> 00:06:08,180
they may choose to just
give the service account

172
00:06:08,180 --> 00:06:11,610
attached to the underlying
node access to their resources.

173
00:06:11,610 --> 00:06:14,530
But when they do that, they
give all workloads access

174
00:06:14,530 --> 00:06:16,950
to their resources, not just one workload.

175
00:06:16,950 --> 00:06:20,680
And so you end up in a situation
where a Kubernetes admin,

176
00:06:20,680 --> 00:06:23,340
who wants to onboard
developers into their cluster,

177
00:06:23,340 --> 00:06:25,660
inadvertently gives every new workload

178
00:06:25,660 --> 00:06:27,490
access to a bunch of resources,

179
00:06:27,490 --> 00:06:29,020
even though they can't even see that

180
00:06:29,020 --> 00:06:30,643
or have any control over it.

181
00:06:33,832 --> 00:06:36,415
(upbeat music)

182
00:06:42,960 --> 00:06:44,360
Okay, now, before we go any further,

183
00:06:44,360 --> 00:06:46,500
it's important to point out
that up until this point,

184
00:06:46,500 --> 00:06:48,280
I've kind of implied that resources

185
00:06:48,280 --> 00:06:50,090
are like these standalone entities

186
00:06:50,090 --> 00:06:52,640
that receive single role
bindings directly to them,

187
00:06:52,640 --> 00:06:55,220
and while resources definitely
can operate that way,

188
00:06:55,220 --> 00:06:57,580
most of the time they're
actually bundled together

189
00:06:57,580 --> 00:06:59,360
into groupings and there's a role binding

190
00:06:59,360 --> 00:07:01,040
that goes to the entire group of stuff.

191
00:07:01,040 --> 00:07:03,050
So instead of getting a
roll directly to a bucket,

192
00:07:03,050 --> 00:07:05,410
you just do get a roll to
a collection of buckets.

193
00:07:05,410 --> 00:07:07,850
- So fundamentally, there are four nodes,

194
00:07:07,850 --> 00:07:09,440
resource nodes within GCP.

195
00:07:09,440 --> 00:07:12,290
There's a new organization
node, which is the parent node.

196
00:07:12,290 --> 00:07:14,590
This is generally
associated with your domain

197
00:07:14,590 --> 00:07:15,970
or cloud identity service.

198
00:07:15,970 --> 00:07:18,430
There are folders and projects.

199
00:07:18,430 --> 00:07:20,560
All of these different top-level nodes

200
00:07:20,560 --> 00:07:22,650
are mostly used for IAM,

201
00:07:22,650 --> 00:07:24,070
and something which is important to note

202
00:07:24,070 --> 00:07:25,360
within the resource hierarchy

203
00:07:25,360 --> 00:07:27,690
is the concept of IAM inheritance

204
00:07:27,690 --> 00:07:30,290
where wherever you have an IAM binding

205
00:07:30,290 --> 00:07:32,260
to one of these top level nodes,

206
00:07:32,260 --> 00:07:35,350
your IAM binding is also
going to be inherited

207
00:07:35,350 --> 00:07:39,470
to all subsequent or child
resources within this hierarchy.

208
00:07:39,470 --> 00:07:41,770
So if I have a role binding
at the organization,

209
00:07:41,770 --> 00:07:43,720
I have access to all subsequent resources

210
00:07:43,720 --> 00:07:45,500
that are created within the environment.

211
00:07:45,500 --> 00:07:47,770
Same at the folder and project level.

212
00:07:47,770 --> 00:07:50,350
Generally, users mostly
interact with resources

213
00:07:50,350 --> 00:07:51,650
at the project level.

214
00:07:51,650 --> 00:07:54,870
That's where it services
like buckets, compute

215
00:07:54,870 --> 00:07:56,850
and general services that
you may interact with

216
00:07:56,850 --> 00:07:58,370
on a day-to-day basis are.

217
00:07:58,370 --> 00:08:00,530
Now, let's dig into a few
different IAM workflows

218
00:08:00,530 --> 00:08:03,260
and try to understand why
project level AM bindings

219
00:08:03,260 --> 00:08:05,550
are so prevalent in GCP.

220
00:08:05,550 --> 00:08:06,790
If we navigate to IAM

221
00:08:06,790 --> 00:08:09,080
and we go to grant a member
access to our resources,

222
00:08:09,080 --> 00:08:10,580
what we're doing here is
we're actually creating

223
00:08:10,580 --> 00:08:13,290
a project level role binding,
which will give this member

224
00:08:13,290 --> 00:08:15,340
access to all resources
within our project.

225
00:08:15,340 --> 00:08:18,000
If we wanted to create a
resource level IAM binding,

226
00:08:18,000 --> 00:08:19,360
we would actually need to interact

227
00:08:19,360 --> 00:08:21,300
with the resource-specific API

228
00:08:21,300 --> 00:08:22,853
and set the IAM binding there.

229
00:08:25,090 --> 00:08:27,180
Another IAM workflow
where a user is prompted

230
00:08:27,180 --> 00:08:28,830
to create a project level role binding

231
00:08:28,830 --> 00:08:30,610
is when you create a service account.

232
00:08:30,610 --> 00:08:33,150
When we create a service account,
we'll actually be prompted

233
00:08:33,150 --> 00:08:35,320
to set a project level IAM binding

234
00:08:35,320 --> 00:08:37,520
that will grant this
service account access again

235
00:08:37,520 --> 00:08:39,290
to resources within our project.

236
00:08:39,290 --> 00:08:40,820
So we can see that when you go

237
00:08:40,820 --> 00:08:42,180
through general IAM workflows,

238
00:08:42,180 --> 00:08:43,960
you are going to always be setting

239
00:08:43,960 --> 00:08:45,550
a project level IAM binding.

240
00:08:45,550 --> 00:08:48,380
Your IAM binding is also
going to be inherited

241
00:08:48,380 --> 00:08:51,720
to all subsequent or child
resources within this project

242
00:08:54,370 --> 00:08:56,690
Here, we can also something
called conditionals.

243
00:08:56,690 --> 00:08:58,940
This is an advanced feature
within the IAM service

244
00:08:58,940 --> 00:09:02,270
that does enable you to set
more granular IAM policies,

245
00:09:02,270 --> 00:09:05,380
but also at the project level
within your environment.

246
00:09:05,380 --> 00:09:06,680
- So I think that's really interesting,

247
00:09:06,680 --> 00:09:08,550
but the main IAM button in the UI

248
00:09:08,550 --> 00:09:10,990
actually takes you to the
project level bindings.

249
00:09:10,990 --> 00:09:12,320
A lot of people don't even realize

250
00:09:12,320 --> 00:09:13,930
that you can do resource level bindings

251
00:09:13,930 --> 00:09:16,480
because you have to actually
click through into the resource

252
00:09:16,480 --> 00:09:18,370
to see that there are IAM settings there,

253
00:09:18,370 --> 00:09:19,640
and a lot of people just assume

254
00:09:19,640 --> 00:09:21,040
that if they go to the IAM page,

255
00:09:21,040 --> 00:09:22,350
they get the whole IAM story.

256
00:09:22,350 --> 00:09:23,470
So when we backtrack a little bit

257
00:09:23,470 --> 00:09:25,090
to when we were talking
about resource owners

258
00:09:25,090 --> 00:09:26,180
and service account owners,

259
00:09:26,180 --> 00:09:27,820
realistically, what would actually happen

260
00:09:27,820 --> 00:09:30,440
is you would have project owners
and within those projects,

261
00:09:30,440 --> 00:09:32,680
you would have resources
and service accounts.

262
00:09:32,680 --> 00:09:34,660
So before, when we were
talking about role bindings,

263
00:09:34,660 --> 00:09:36,680
we mentioned this idea of Kubernetes nodes

264
00:09:36,680 --> 00:09:38,420
having servers accounts attached to them

265
00:09:38,420 --> 00:09:41,200
and developers deploying workloads
to the Kubernetes cluster

266
00:09:41,200 --> 00:09:43,340
and granting them access to resources.

267
00:09:43,340 --> 00:09:45,010
But more realistically,
what that would look like

268
00:09:45,010 --> 00:09:46,630
is they would grant that node access

269
00:09:46,630 --> 00:09:47,770
to their entire project

270
00:09:47,770 --> 00:09:49,680
because again, IAM
bindings are typically done

271
00:09:49,680 --> 00:09:50,540
at the project level.

272
00:09:50,540 --> 00:09:53,030
So instead of granting the
node access to a single bucket,

273
00:09:53,030 --> 00:09:54,750
they would grant access to all buckets

274
00:09:54,750 --> 00:09:55,860
within a given project.

275
00:09:55,860 --> 00:09:57,130
Now, this isn't always the case.

276
00:09:57,130 --> 00:09:59,600
Sometimes developers do
resource level of role binding

277
00:09:59,600 --> 00:10:00,860
and it should also be noted

278
00:10:00,860 --> 00:10:03,390
that the UI isn't the only way
to apply these role bindings.

279
00:10:03,390 --> 00:10:06,100
You can also apply them
via Terraform or via CLI.

280
00:10:06,100 --> 00:10:07,800
It's pretty common for developers

281
00:10:07,800 --> 00:10:09,120
to do it at the project level

282
00:10:09,120 --> 00:10:10,760
because most of their first exposure

283
00:10:10,760 --> 00:10:12,330
actually comes through the UI.

284
00:10:12,330 --> 00:10:14,090
Okay, so if we recapped
the earlier section,

285
00:10:14,090 --> 00:10:15,310
you might remember when we talked

286
00:10:15,310 --> 00:10:16,750
about surface account owners.

287
00:10:16,750 --> 00:10:18,150
We mentioned that the
service account owner

288
00:10:18,150 --> 00:10:20,810
can actually know what access
their service accounts have.

289
00:10:20,810 --> 00:10:22,210
Well, it's not really the whole story,

290
00:10:22,210 --> 00:10:23,710
really what we have as a project owner,

291
00:10:23,710 --> 00:10:25,810
and then that project owner
has a bunch of surface accounts

292
00:10:25,810 --> 00:10:27,810
in their project, and then
those service accounts

293
00:10:27,810 --> 00:10:29,630
have access to stuff and the project owner

294
00:10:29,630 --> 00:10:30,950
doesn't really have the whole story

295
00:10:30,950 --> 00:10:32,870
of what their service
accounts have access to.

296
00:10:32,870 --> 00:10:33,703
And so you might imagine

297
00:10:33,703 --> 00:10:35,240
how that can start to become dangerous

298
00:10:35,240 --> 00:10:38,170
is when I hand over access of
my project to someone else.

299
00:10:38,170 --> 00:10:40,160
I don't really know how
much access I'm handing over

300
00:10:40,160 --> 00:10:42,140
because again, I don't
even know how much access

301
00:10:42,140 --> 00:10:43,760
my service accounts have in my project.

302
00:10:43,760 --> 00:10:45,510
So if I hand that over to someone else,

303
00:10:45,510 --> 00:10:47,590
I'm handing over an
unknown amount of access.

304
00:10:47,590 --> 00:10:49,320
- So what is an example of this look like?

305
00:10:49,320 --> 00:10:52,290
Well, we have a project owner
that knows the email address

306
00:10:52,290 --> 00:10:54,030
of a different project service account.

307
00:10:54,030 --> 00:10:56,050
They can then give that service account

308
00:10:56,050 --> 00:10:58,940
access to their project
through an IAM binding,

309
00:10:58,940 --> 00:11:00,780
and then that service account has access

310
00:11:00,780 --> 00:11:02,230
to their project's resources.

311
00:11:03,110 --> 00:11:04,620
- Now, one question you
might be asking yourself

312
00:11:04,620 --> 00:11:06,876
is why you would even need
across project role binding.

313
00:11:06,876 --> 00:11:08,670
But when you think about it,
when you have two projects,

314
00:11:08,670 --> 00:11:10,180
they're not particularly useful

315
00:11:10,180 --> 00:11:11,920
unless they have some way
to talk to each other.

316
00:11:11,920 --> 00:11:13,040
And one common way to do that

317
00:11:13,040 --> 00:11:16,500
is through Google Cloud
services like Pubsub or Storage.

318
00:11:16,500 --> 00:11:17,333
And so it makes sense

319
00:11:17,333 --> 00:11:19,740
that we would want to share
some resources between projects.

320
00:11:19,740 --> 00:11:21,240
But again, where things sort of start

321
00:11:21,240 --> 00:11:22,250
to become more dangerous

322
00:11:22,250 --> 00:11:24,750
is if we share service account
access between projects,

323
00:11:24,750 --> 00:11:26,800
because again, project owners
don't really know what access

324
00:11:26,800 --> 00:11:27,940
their service accounts have.

325
00:11:27,940 --> 00:11:30,570
So we're missing out on some
important existential questions

326
00:11:30,570 --> 00:11:32,620
like how interconnected
our projects actually are,

327
00:11:32,620 --> 00:11:33,990
because again, we can answer questions

328
00:11:33,990 --> 00:11:35,600
like who has access to a resource,

329
00:11:35,600 --> 00:11:37,150
but we really can't answer questions

330
00:11:37,150 --> 00:11:39,040
like what does this service
account have access to?

331
00:11:39,040 --> 00:11:40,310
So we came up with a solution

332
00:11:40,310 --> 00:11:42,040
that let us sort of answer this question

333
00:11:42,040 --> 00:11:43,640
with our own organization.

334
00:11:43,640 --> 00:11:45,940
We can't actually get the
complete answer to the question

335
00:11:45,940 --> 00:11:47,090
again, because of these things

336
00:11:47,090 --> 00:11:48,800
called cross-organizational bindings,

337
00:11:48,800 --> 00:11:49,980
but at least within our org,

338
00:11:49,980 --> 00:11:52,190
we can get the answer for
cross project bindings

339
00:11:52,190 --> 00:11:54,870
by just introspecting
individual project that we own

340
00:11:54,870 --> 00:11:56,540
and pulling all the IAM policies.

341
00:11:56,540 --> 00:11:58,020
We then took all that information

342
00:11:58,020 --> 00:11:59,480
and we made a graph out of it.

343
00:11:59,480 --> 00:12:01,150
We actually went over to GitHub,

344
00:12:01,150 --> 00:12:03,030
and we crawled a bunch of IAM policies

345
00:12:03,030 --> 00:12:05,820
that people either intentionally
or accidentally committed,

346
00:12:05,820 --> 00:12:07,180
and we took all those policies

347
00:12:07,180 --> 00:12:10,403
and we kind of compiled
this pseudo org generator.

348
00:12:13,056 --> 00:12:15,639
(upbeat music)

349
00:12:25,330 --> 00:12:27,450
So let's take a look at one of
the graphs we ended up with.

350
00:12:27,450 --> 00:12:29,800
As you can see, there are
two different colored nodes.

351
00:12:29,800 --> 00:12:31,947
There are red nodes and
there are blue nodes.

352
00:12:31,947 --> 00:12:34,350
But the red notes represent our projects

353
00:12:34,350 --> 00:12:37,100
and what the blue nodes
represent, our service accounts.

354
00:12:37,100 --> 00:12:38,930
Those are the only two
things we're graphing here.

355
00:12:38,930 --> 00:12:40,730
Then there are two
different types of edges.

356
00:12:40,730 --> 00:12:43,580
There are contains edges,
and there are bindings edges.

357
00:12:43,580 --> 00:12:45,900
A contains edge is basically
when a service account

358
00:12:45,900 --> 00:12:47,450
lives in a given project,

359
00:12:47,450 --> 00:12:49,330
and the binding edge is
when that service account

360
00:12:49,330 --> 00:12:51,510
has a role binding to that project.

361
00:12:51,510 --> 00:12:53,020
Most of the time, a service account

362
00:12:53,020 --> 00:12:55,720
has a role binding to the
project that it's contained in.

363
00:12:55,720 --> 00:12:56,620
But every once in a while,

364
00:12:56,620 --> 00:12:57,860
we'll end up with a service account

365
00:12:57,860 --> 00:12:59,760
that has a role binding
to a different project,

366
00:12:59,760 --> 00:13:01,210
across project binding.

367
00:13:01,210 --> 00:13:02,860
So in this case, we have a service account

368
00:13:02,860 --> 00:13:05,370
that's contained in project number 67,

369
00:13:05,370 --> 00:13:08,400
and it has a role binding
into project number 57.

370
00:13:08,400 --> 00:13:10,630
If we zoom out, we get the view
of the entire organization.

371
00:13:10,630 --> 00:13:12,510
We have all the different
projects here on a map,

372
00:13:12,510 --> 00:13:14,870
and we have all the relationships
with the service accounts

373
00:13:14,870 --> 00:13:17,250
within the org that are
contained within these projects.

374
00:13:17,250 --> 00:13:19,290
Now, we're not looking at
organization level bindings

375
00:13:19,290 --> 00:13:21,380
in this graph or resource level bindings,

376
00:13:21,380 --> 00:13:23,450
we're only looking at the
project level bindings

377
00:13:23,450 --> 00:13:25,140
and we're mapping these relationships.

378
00:13:25,140 --> 00:13:27,410
So because we base this
off of real IAM policies

379
00:13:27,410 --> 00:13:28,730
that we're able to pull off GitHub,

380
00:13:28,730 --> 00:13:30,450
we can say with some level of confidence

381
00:13:30,450 --> 00:13:32,300
that this is an accurate representation

382
00:13:32,300 --> 00:13:34,490
of what a sufficiently large
company might look like.

383
00:13:34,490 --> 00:13:36,830
We can also say with a little
bit of personal experience

384
00:13:36,830 --> 00:13:38,930
based on the large companies
that we've looked at,

385
00:13:38,930 --> 00:13:40,430
this is an accurate representation

386
00:13:40,430 --> 00:13:42,270
of what a sufficiently
large company looks like.

387
00:13:42,270 --> 00:13:43,930
Now, again, most of the time a developer

388
00:13:43,930 --> 00:13:45,870
is just gonna be the
owner of a single project,

389
00:13:45,870 --> 00:13:47,560
and they won't really
see the whole picture.

390
00:13:47,560 --> 00:13:49,460
All they'll see is sort of tunnel vision

391
00:13:49,460 --> 00:13:51,460
for the one project that
they have control over.

392
00:13:51,460 --> 00:13:53,060
And so they'll see the service accounts

393
00:13:53,060 --> 00:13:54,110
that belong to their project,

394
00:13:54,110 --> 00:13:56,730
and they'll see what has role
bindings into their project,

395
00:13:56,730 --> 00:13:58,730
but they won't know where
their surface accounts

396
00:13:58,730 --> 00:14:00,610
have role bindings out of their project.

397
00:14:00,610 --> 00:14:02,940
And so when they hand off
access to their project

398
00:14:02,940 --> 00:14:04,730
to another developer,
they won't actually know

399
00:14:04,730 --> 00:14:06,770
how many additional projects
they're handing off,

400
00:14:06,770 --> 00:14:09,000
and they themselves may not
have a good understanding

401
00:14:09,000 --> 00:14:10,930
of how many projects
that they have access to

402
00:14:10,930 --> 00:14:12,190
through their service accounts.

403
00:14:12,190 --> 00:14:13,800
One other interesting
thing that we found here

404
00:14:13,800 --> 00:14:15,470
is that there are certain projects

405
00:14:15,470 --> 00:14:17,530
that have seemingly disproportionate,

406
00:14:17,530 --> 00:14:19,940
large numbers of role bindings
and resources in them.

407
00:14:19,940 --> 00:14:21,970
We found this was a
pretty consistent story

408
00:14:21,970 --> 00:14:23,790
at multiple companies that we looked at.

409
00:14:23,790 --> 00:14:24,920
And so in the center here,

410
00:14:24,920 --> 00:14:26,660
you can see there are a bunch of projects

411
00:14:26,660 --> 00:14:28,760
that have really
tightly-bound role bindings,

412
00:14:28,760 --> 00:14:30,700
and then at the bottom,
we have smaller projects

413
00:14:30,700 --> 00:14:32,440
that only have one or two surface accounts

414
00:14:32,440 --> 00:14:34,510
that may not be connected
to the broader web.

415
00:14:34,510 --> 00:14:35,610
And then we have a bunch of projects

416
00:14:35,610 --> 00:14:36,643
that have no service accounts.

417
00:14:36,643 --> 00:14:39,370
What we found is that
most of the sensitive data

418
00:14:39,370 --> 00:14:42,450
or sensitive workloads are in
the interconnected projects.

419
00:14:42,450 --> 00:14:44,200
That's where most of the
development is happening,

420
00:14:44,200 --> 00:14:45,610
and so it makes sense that it would have

421
00:14:45,610 --> 00:14:48,110
most of the IAM role
bindings connecting it

422
00:14:48,110 --> 00:14:49,080
with other projects.

423
00:14:49,080 --> 00:14:50,860
So when we first started
building these graphs,

424
00:14:50,860 --> 00:14:51,970
we thinking to ourselves,

425
00:14:51,970 --> 00:14:53,920
oh gosh, these projects are supposed

426
00:14:53,920 --> 00:14:55,650
to be isolated boundaries.

427
00:14:55,650 --> 00:14:57,350
Are they really this interconnected?

428
00:14:57,350 --> 00:14:58,820
And the more we dug into it,

429
00:14:58,820 --> 00:15:00,940
and the more we thought
about how project owners

430
00:15:00,940 --> 00:15:02,850
can't actually see the role bindings,

431
00:15:02,850 --> 00:15:04,530
their surface accounts have been granted,

432
00:15:04,530 --> 00:15:05,870
we realized this is a problem

433
00:15:05,870 --> 00:15:07,550
that's really remained invisible,

434
00:15:07,550 --> 00:15:10,070
and it really takes this
org level introspection

435
00:15:10,070 --> 00:15:10,903
to even see it.

436
00:15:10,903 --> 00:15:12,220
Now there's one final piece here

437
00:15:12,220 --> 00:15:13,350
that we haven't talked about yet,

438
00:15:13,350 --> 00:15:15,360
and that's when a developer
actually does hand over access

439
00:15:15,360 --> 00:15:16,700
to their project to another developer,

440
00:15:16,700 --> 00:15:18,530
he is, so that might be okay.

441
00:15:18,530 --> 00:15:20,440
It might be okay to share
storage for example,

442
00:15:20,440 --> 00:15:21,830
but things start become really dangerous

443
00:15:21,830 --> 00:15:23,400
if you share access to surface accounts,

444
00:15:23,400 --> 00:15:25,290
because again, that's where
the problem is hidden,

445
00:15:25,290 --> 00:15:27,510
where the owner of the
project doesn't actually know

446
00:15:27,510 --> 00:15:29,290
what access their service accounts have.

447
00:15:29,290 --> 00:15:31,000
And so if we share that unknown access,

448
00:15:31,000 --> 00:15:32,620
that's where things
can start to go astray.

449
00:15:32,620 --> 00:15:35,070
So we'll come back to
what roles and permissions

450
00:15:35,070 --> 00:15:37,800
are actually required to hand
over that level of access.

451
00:15:37,800 --> 00:15:39,410
And we'll talk about how common that is.

452
00:15:39,410 --> 00:15:41,070
- So far, we've talked a lot about roles

453
00:15:41,070 --> 00:15:43,490
and mentioned that some are
more dangerous than others.

454
00:15:43,490 --> 00:15:45,900
So now, let's dig into
that a little bit more.

455
00:15:45,900 --> 00:15:48,230
Within GCP, there are three
distinct types of roles

456
00:15:48,230 --> 00:15:49,063
that you can use.

457
00:15:49,063 --> 00:15:50,260
Primitive, which have been around

458
00:15:50,260 --> 00:15:53,100
since before cloud IAM that we know today,

459
00:15:53,100 --> 00:15:55,760
predefined roles, which are curated by GCP

460
00:15:55,760 --> 00:15:57,300
and service-specific,

461
00:15:57,300 --> 00:15:59,400
and custom rules that enable developers

462
00:15:59,400 --> 00:16:01,430
to specify any permission
that they would like

463
00:16:01,430 --> 00:16:04,050
that is supported to fit
their services needs.

464
00:16:04,050 --> 00:16:05,860
Let's focus on primitive roles.

465
00:16:05,860 --> 00:16:08,800
Within primitive roles,
there is an owner role

466
00:16:08,800 --> 00:16:10,890
which provides all of
the different permissions

467
00:16:10,890 --> 00:16:12,800
that are available within the platform,

468
00:16:12,800 --> 00:16:16,870
and editor role, which closely
resembles the owner role,

469
00:16:16,870 --> 00:16:18,190
but excludes a few different things

470
00:16:18,190 --> 00:16:19,830
for administrative capabilities

471
00:16:19,830 --> 00:16:22,180
and that just might not be supported yet.

472
00:16:22,180 --> 00:16:23,690
One thing in particular that's excluded

473
00:16:23,690 --> 00:16:26,580
is the ability to set
project level role bindings,

474
00:16:26,580 --> 00:16:29,260
and the viewer role, which is
exactly what it sounds like.

475
00:16:29,260 --> 00:16:30,830
It allows you to view resources,

476
00:16:30,830 --> 00:16:33,680
but not perform any
state changing actions.

477
00:16:33,680 --> 00:16:35,870
How are these primitive roles used?

478
00:16:35,870 --> 00:16:39,060
Well, earlier, we saw that
when you go to cloud IAM

479
00:16:39,060 --> 00:16:40,870
through the UI, these permitted roles

480
00:16:40,870 --> 00:16:43,113
are what are first suggested to users.

481
00:16:43,980 --> 00:16:45,600
There's another way that
these primitive roles

482
00:16:45,600 --> 00:16:47,970
manifest themselves
within your GCP project.

483
00:16:47,970 --> 00:16:50,920
And that's your default IAM role bindings.

484
00:16:50,920 --> 00:16:52,950
Whatever identity creates a project

485
00:16:52,950 --> 00:16:56,320
will automatically be granted
a project level role binding

486
00:16:56,320 --> 00:16:57,750
using the owner role.

487
00:16:57,750 --> 00:16:59,790
So we know that the owner role

488
00:16:59,790 --> 00:17:01,630
contains all of the different permissions

489
00:17:01,630 --> 00:17:04,490
that are available, but
what about the editor role?

490
00:17:04,490 --> 00:17:07,610
Well, the editor role contains,
at the time of this talk,

491
00:17:07,610 --> 00:17:11,303
2,576 distinct permissions.

492
00:17:14,940 --> 00:17:15,840
That's a lot.

493
00:17:15,840 --> 00:17:17,640
This means that with the editor role,

494
00:17:17,640 --> 00:17:21,430
you can, for example, access
all buckets, all databases,

495
00:17:21,430 --> 00:17:24,160
all VMs, and much more within your project

496
00:17:26,563 --> 00:17:28,690
Out of these permissions
that we talked about earlier,

497
00:17:28,690 --> 00:17:30,760
which of these roles
actually enable a user

498
00:17:30,760 --> 00:17:32,230
to manage surface accounts?

499
00:17:32,230 --> 00:17:34,790
Well, both the owner
and the editor role do.

500
00:17:34,790 --> 00:17:36,750
While the editor role does not enable you

501
00:17:36,750 --> 00:17:39,410
to create new service accounts

502
00:17:39,410 --> 00:17:42,890
or apply project level role
bindings for service accounts,

503
00:17:42,890 --> 00:17:45,950
it does allow you to
manage service accounts

504
00:17:45,950 --> 00:17:47,220
in two different ways,

505
00:17:47,220 --> 00:17:50,150
and that's by creating keys credentials

506
00:17:50,150 --> 00:17:52,500
for a given service
account that already exists

507
00:17:52,500 --> 00:17:56,540
and by associating a service
account with a resource.

508
00:17:56,540 --> 00:17:58,980
So if a user can create a resource,

509
00:17:58,980 --> 00:18:02,150
specify a service account,
GCP will go and check,

510
00:18:02,150 --> 00:18:04,690
does this user have the
IAM service accounts

511
00:18:04,690 --> 00:18:06,730
act as permission on the service account

512
00:18:06,730 --> 00:18:08,960
that they're attempting to
associate with the resource?

513
00:18:08,960 --> 00:18:12,580
If so it gets attached, and
then that user can interact

514
00:18:12,580 --> 00:18:16,300
with GCP services and APIs as
that service count identity

515
00:18:16,300 --> 00:18:17,690
and its associated role.

516
00:18:17,690 --> 00:18:21,500
So how common are these
IAM roles in GCP projects?

517
00:18:21,500 --> 00:18:22,490
There's another way

518
00:18:22,490 --> 00:18:26,040
that GCP creates automatic
role bindings for identities

519
00:18:26,040 --> 00:18:27,330
and this way is a little bit different.

520
00:18:27,330 --> 00:18:29,300
When you enable a specific service

521
00:18:29,300 --> 00:18:31,630
such as Google compute engine,

522
00:18:31,630 --> 00:18:34,720
it will go and create a
default service account

523
00:18:34,720 --> 00:18:37,410
in your project and then
grant that service account

524
00:18:37,410 --> 00:18:41,013
a project level role binding
using the primitive editor role

525
00:18:41,013 --> 00:18:43,620
that we chatted about earlier.

526
00:18:43,620 --> 00:18:45,410
This also happens with another service.

527
00:18:45,410 --> 00:18:47,490
When a user enables
the app engine service,

528
00:18:47,490 --> 00:18:49,560
a service account called
the app spot service count

529
00:18:49,560 --> 00:18:50,700
is created in your project

530
00:18:50,700 --> 00:18:54,210
and also granted a project
level editor role binding.

531
00:18:54,210 --> 00:18:55,520
Now, as we discussed earlier,

532
00:18:55,520 --> 00:18:57,570
that editor role contains a permission

533
00:18:57,570 --> 00:18:58,810
that enables identities

534
00:18:58,810 --> 00:19:02,020
to associate service
accounts with resources.

535
00:19:02,020 --> 00:19:04,670
So that means that both of
these default service counts,

536
00:19:04,670 --> 00:19:07,150
the compute engine and the
app spot service account

537
00:19:07,150 --> 00:19:10,260
are able to associate any service account

538
00:19:10,260 --> 00:19:12,930
within its GCP project to a resource.

539
00:19:12,930 --> 00:19:14,820
So where are these service counts used?

540
00:19:14,820 --> 00:19:17,070
The default compute surface count

541
00:19:17,070 --> 00:19:21,400
is associated with VCE VMs by default.

542
00:19:21,400 --> 00:19:22,950
So whenever you create a VM,

543
00:19:22,950 --> 00:19:24,350
the default compute service account

544
00:19:24,350 --> 00:19:26,543
is automatically associated with the VM.

545
00:19:28,240 --> 00:19:30,960
There's one thing to
note about service counts

546
00:19:30,960 --> 00:19:32,690
and the way that they are authorized

547
00:19:32,690 --> 00:19:34,820
to interact with services from a VM.

548
00:19:34,820 --> 00:19:36,850
There is the role that they have,

549
00:19:36,850 --> 00:19:38,690
as well as something called scopes.

550
00:19:38,690 --> 00:19:41,750
And scopes define from within the VM,

551
00:19:41,750 --> 00:19:45,520
what services and APIs can
that identity interact with,

552
00:19:45,520 --> 00:19:47,590
regardless of the role
binding that they have.

553
00:19:47,590 --> 00:19:50,480
By default, for VMs, scopes are restricted

554
00:19:50,480 --> 00:19:54,370
to only a few particular
services like storage,

555
00:19:54,370 --> 00:19:55,940
but from what we have observed,

556
00:19:55,940 --> 00:19:58,500
developers will commonly
open these scopes up

557
00:19:58,500 --> 00:20:00,910
so that they can interact
with many different services.

558
00:20:00,910 --> 00:20:03,290
And how are the apps spot
service accounts used?

559
00:20:03,290 --> 00:20:06,010
Cloud functions are Google
serverless offerings,

560
00:20:06,010 --> 00:20:08,220
which are similar to AWS Lambdas.

561
00:20:08,220 --> 00:20:10,410
They're meant to just be
lightweight, ephemeral,

562
00:20:10,410 --> 00:20:12,240
small chunks of code that run fast

563
00:20:12,240 --> 00:20:14,010
and exit once they're done.

564
00:20:14,010 --> 00:20:17,270
If the app engine service is
enabled within your project,

565
00:20:17,270 --> 00:20:19,940
when a developer goes to
create a cloud function,

566
00:20:19,940 --> 00:20:22,350
that default app SWAT service account,

567
00:20:22,350 --> 00:20:25,170
with an editor role
binding will be associated

568
00:20:25,170 --> 00:20:27,234
with cloud functions by default.

569
00:20:27,234 --> 00:20:28,570
When we create cloud function,

570
00:20:28,570 --> 00:20:30,800
you actually do not have
the ability to specify

571
00:20:30,800 --> 00:20:32,220
to set it without an identity.

572
00:20:32,220 --> 00:20:34,350
You always have to associate an identity

573
00:20:34,350 --> 00:20:35,430
with the cloud function.

574
00:20:35,430 --> 00:20:38,360
So if you don't know to
create a new service account

575
00:20:38,360 --> 00:20:40,160
and associate with your cloud function,

576
00:20:40,160 --> 00:20:42,558
you'll always be using
the default app's spot,

577
00:20:42,558 --> 00:20:44,470
service account that has
the editor role binding.

578
00:20:44,470 --> 00:20:45,800
Cloud functions do not have scopes

579
00:20:45,800 --> 00:20:48,300
and get all of the permissions
of the editor role.

580
00:20:49,280 --> 00:20:51,290
And coming back to the VMs,

581
00:20:51,290 --> 00:20:54,130
a lot of managed services leverage VMs

582
00:20:54,130 --> 00:20:56,100
as their underlying infrastructure.

583
00:20:56,100 --> 00:20:59,120
Things like GKE, Dataproc, Dataflow.

584
00:20:59,120 --> 00:21:01,980
They also get this default
compute engine service count

585
00:21:01,980 --> 00:21:03,270
associated with them.

586
00:21:03,270 --> 00:21:06,310
In AWS, when you spin up
something like a VM or a Lambda,

587
00:21:06,310 --> 00:21:08,360
it defaults to having no access.

588
00:21:08,360 --> 00:21:11,540
There are no roles attached,
but in GCP things default

589
00:21:11,540 --> 00:21:13,820
to having thousands of permissions.

590
00:21:13,820 --> 00:21:16,700
Earlier, we talked about
cross project role bindings,

591
00:21:16,700 --> 00:21:19,750
the ability to leverage
service accounts in a project

592
00:21:19,750 --> 00:21:21,720
to get access to other service accounts

593
00:21:21,720 --> 00:21:24,580
and potentially move
laterally across GCP projects.

594
00:21:24,580 --> 00:21:26,120
We talked about developers

595
00:21:26,120 --> 00:21:27,680
potentially not knowing what access

596
00:21:27,680 --> 00:21:28,890
their surface counts have.

597
00:21:28,890 --> 00:21:32,010
We mentioned the idea
of handing off access.

598
00:21:32,010 --> 00:21:33,860
And what this realistically looks like

599
00:21:33,860 --> 00:21:35,710
is the developer applies a role by name

600
00:21:35,710 --> 00:21:38,410
with the act as permission
like the editor role.

601
00:21:38,410 --> 00:21:40,950
Let's look at what that could look like.

602
00:21:40,950 --> 00:21:43,377
- Now, it's demo time.

603
00:21:43,377 --> 00:21:45,960
(upbeat music)

604
00:21:49,390 --> 00:21:52,020
To help understand how to
exploit the act as permission,

605
00:21:52,020 --> 00:21:53,920
we built a framework called Gcploit.

606
00:21:53,920 --> 00:21:56,010
To start out, we need a base identity.

607
00:21:56,010 --> 00:21:58,290
There are a number of different
ways to get a base identity.

608
00:21:58,290 --> 00:22:00,960
One way, for example is you
could offish a developer

609
00:22:00,960 --> 00:22:03,160
that has project level editor access.

610
00:22:03,160 --> 00:22:04,680
Another way is maybe a developer

611
00:22:04,680 --> 00:22:06,750
accidentally uploaded
a service account key

612
00:22:06,750 --> 00:22:09,260
to get hub or pay spin,
and that surface account

613
00:22:09,260 --> 00:22:11,170
has a editor level role binding

614
00:22:11,170 --> 00:22:12,810
because the primitive
roles are the first thing

615
00:22:12,810 --> 00:22:14,950
that are suggested to you on the IAM page.

616
00:22:14,950 --> 00:22:17,240
Or maybe the most likely,
maybe the base identity

617
00:22:17,240 --> 00:22:18,950
comes from exploiting a service.

618
00:22:18,950 --> 00:22:20,160
And because most services

619
00:22:20,160 --> 00:22:21,940
run with project editor by default,

620
00:22:21,940 --> 00:22:23,430
maybe that's how you
get your first foothold.

621
00:22:23,430 --> 00:22:25,840
In any case, in this
case, we've simulated this

622
00:22:25,840 --> 00:22:27,950
by just starting with the
service account credential.

623
00:22:27,950 --> 00:22:29,290
We can see this credential here

624
00:22:29,290 --> 00:22:31,790
and we can see that it
starts in the project BBS2.

625
00:22:33,320 --> 00:22:36,180
Next, we'll run the list
operation on the Gcploit tool.

626
00:22:36,180 --> 00:22:37,670
We can see that there is no output.

627
00:22:37,670 --> 00:22:40,510
The reason there's no
output is the list operation

628
00:22:40,510 --> 00:22:42,080
lists all the service accounts

629
00:22:42,080 --> 00:22:43,610
that you've managed to take control of,

630
00:22:43,610 --> 00:22:45,270
and it doesn't count the base identity.

631
00:22:45,270 --> 00:22:47,470
We will run the G-Cloud
command project's list

632
00:22:47,470 --> 00:22:50,453
on the base identity to see
what project we have access to.

633
00:22:52,030 --> 00:22:54,310
It looks like we have access to BBS2.

634
00:22:54,310 --> 00:22:56,970
Next, we'll try and act
as exploit on this project

635
00:22:56,970 --> 00:22:59,670
and we'll target every service
account in the project.

636
00:23:02,930 --> 00:23:04,530
Let's unpack what's happening now.

637
00:23:04,530 --> 00:23:06,560
Keep in mind the editor role has two ways

638
00:23:06,560 --> 00:23:08,900
to take control of all the
surface accounts in a project.

639
00:23:08,900 --> 00:23:10,670
The first is through creating tokens,

640
00:23:10,670 --> 00:23:12,900
and the second is through
provisioning resources.

641
00:23:12,900 --> 00:23:14,740
There's another role that
we haven't talked about yet,

642
00:23:14,740 --> 00:23:16,620
and that's the surface account user role.

643
00:23:16,620 --> 00:23:18,170
This role is also pretty common

644
00:23:18,170 --> 00:23:20,190
and is often given to
users and surface accounts

645
00:23:20,190 --> 00:23:22,040
that are meant to provision resources.

646
00:23:22,040 --> 00:23:23,580
Because some things like cloud functions

647
00:23:23,580 --> 00:23:26,020
require service accounts
be attached to them,

648
00:23:26,020 --> 00:23:29,400
this is the role that's
usually granted to do that.

649
00:23:29,400 --> 00:23:31,010
So because the service account user role

650
00:23:31,010 --> 00:23:33,440
and the editor role both
have the act as permission,

651
00:23:33,440 --> 00:23:35,690
we'll use that to take control
of the service accounts

652
00:23:35,690 --> 00:23:37,610
because it casts a
little bit wider of a net

653
00:23:37,610 --> 00:23:39,120
and the token creator permission,

654
00:23:39,120 --> 00:23:40,860
which is only in the editor role.

655
00:23:40,860 --> 00:23:42,700
So what Gcploit is actually
doing under the hood here

656
00:23:42,700 --> 00:23:45,230
is first it's running the
service account list of operation

657
00:23:45,230 --> 00:23:47,410
to get a list of all the
service accounts in the project,

658
00:23:47,410 --> 00:23:49,040
and then it's spinning up a cloud function

659
00:23:49,040 --> 00:23:50,820
for each one of those service accounts.

660
00:23:50,820 --> 00:23:51,850
Then we keep a database

661
00:23:51,850 --> 00:23:53,760
of all the cloud
functions we've harvested,

662
00:23:53,760 --> 00:23:55,860
each which has its own
underlying service account

663
00:23:55,860 --> 00:23:56,693
attached to it.

664
00:23:56,693 --> 00:23:57,570
This gives us access

665
00:23:57,570 --> 00:23:59,460
to all of the service
accounts in the project

666
00:23:59,460 --> 00:24:01,170
through the cloud
functions that we spun up.

667
00:24:01,170 --> 00:24:03,160
We control the code that
lands on the cloud function.

668
00:24:03,160 --> 00:24:05,810
So we'll just deploy code
that allows us to run

669
00:24:05,810 --> 00:24:07,320
whatever G-Cloud commands we want.

670
00:24:07,320 --> 00:24:09,450
It takes about two minutes to
spin up each cloud function.

671
00:24:09,450 --> 00:24:11,750
So we'll just speed
through this really quick.

672
00:24:14,350 --> 00:24:15,990
And now when we run
the list command again,

673
00:24:15,990 --> 00:24:17,880
we can see all the new service accounts

674
00:24:17,880 --> 00:24:19,210
that we now have access to.

675
00:24:19,210 --> 00:24:20,420
One of them says owner.

676
00:24:20,420 --> 00:24:21,253
That service account

677
00:24:21,253 --> 00:24:22,960
actually has an owner-level role binding

678
00:24:22,960 --> 00:24:24,360
to the project that we started in.

679
00:24:24,360 --> 00:24:26,250
That means we now have
full control of the project

680
00:24:26,250 --> 00:24:27,350
through this service account.

681
00:24:27,350 --> 00:24:29,390
If we wanted to, we could
use this service account

682
00:24:29,390 --> 00:24:31,250
to add ourselves as owners to the project.

683
00:24:31,250 --> 00:24:33,300
So it's just a pause and
think about that for a second.

684
00:24:33,300 --> 00:24:35,550
What that means is if you
ever have a service account

685
00:24:35,550 --> 00:24:37,180
that has editor level access

686
00:24:37,180 --> 00:24:40,000
and another service account
that has owner level access,

687
00:24:40,000 --> 00:24:41,300
the editor level service account

688
00:24:41,300 --> 00:24:43,980
can always privilege
escalate itself to owner.

689
00:24:43,980 --> 00:24:45,110
That's the same with developers.

690
00:24:45,110 --> 00:24:47,710
If you grant a developer editor
level access to a project,

691
00:24:47,710 --> 00:24:49,570
but you happen to have a
service account in that project

692
00:24:49,570 --> 00:24:51,020
that has owner level access,

693
00:24:51,020 --> 00:24:52,930
that developer can privilege
escalate themselves

694
00:24:52,930 --> 00:24:54,470
to owner through that service account.

695
00:24:54,470 --> 00:24:55,430
Okay, let's take another look

696
00:24:55,430 --> 00:24:57,200
at those service accounts that we have.

697
00:24:57,200 --> 00:24:58,400
There's one here that's
kind of interesting

698
00:24:58,400 --> 00:24:59,730
that says do nothing.

699
00:24:59,730 --> 00:25:00,900
It might not sound interesting,

700
00:25:00,900 --> 00:25:02,530
but keep in mind that the developer

701
00:25:02,530 --> 00:25:04,430
that created that service
account in this project,

702
00:25:04,430 --> 00:25:06,870
although they didn't intend
to give it any role bindings,

703
00:25:06,870 --> 00:25:08,350
again, the owner of the service accounts

704
00:25:08,350 --> 00:25:09,560
can't control the role bindings,

705
00:25:09,560 --> 00:25:11,640
and so it's possible
that a different project

706
00:25:11,640 --> 00:25:12,510
gave it a role binding.

707
00:25:12,510 --> 00:25:14,020
So let's run the project list command

708
00:25:14,020 --> 00:25:16,610
from this service account
that we've compromised.

709
00:25:16,610 --> 00:25:19,200
Something interesting here
that the base project, BBS2

710
00:25:19,200 --> 00:25:21,320
doesn't actually show up
and we run this command.

711
00:25:21,320 --> 00:25:22,520
This is because the service account

712
00:25:22,520 --> 00:25:23,490
has no role bindings there,

713
00:25:23,490 --> 00:25:25,540
the developer didn't want it
to have any role bindings.

714
00:25:25,540 --> 00:25:28,960
But BBS3, this new project we
haven't looked at shows up.

715
00:25:28,960 --> 00:25:31,060
What happened here is the
developer in another project

716
00:25:31,060 --> 00:25:32,350
granted this service account

717
00:25:32,350 --> 00:25:34,460
an editor role binding into their project.

718
00:25:34,460 --> 00:25:36,900
So let's run the act as
exploit one more time.

719
00:25:36,900 --> 00:25:39,260
This time from this do
nothing service account

720
00:25:39,260 --> 00:25:41,840
into BBS3 and see how
many service accounts

721
00:25:41,840 --> 00:25:43,480
we can harvest in BBS3.

722
00:25:43,480 --> 00:25:45,040
Again, this process takes a little while,

723
00:25:45,040 --> 00:25:46,713
so we're gonna fast forward through this.

724
00:25:51,240 --> 00:25:53,380
And now, we can see a whole
bunch of new service accounts

725
00:25:53,380 --> 00:25:55,223
in the BBS3 project, service accounts

726
00:25:55,223 --> 00:25:56,890
that we didn't have access to before

727
00:25:56,890 --> 00:25:59,530
that we were able to get strictly
through lateral movement.

728
00:25:59,530 --> 00:26:00,670
There's a couple of
service accounts in here

729
00:26:00,670 --> 00:26:01,560
that look interesting.

730
00:26:01,560 --> 00:26:02,890
There's one that's labeled networking

731
00:26:02,890 --> 00:26:04,990
that maybe controls networking
for the organization,

732
00:26:04,990 --> 00:26:06,370
but probably most interesting

733
00:26:06,370 --> 00:26:08,820
is this one that's labeled
organizational admin.

734
00:26:08,820 --> 00:26:10,620
If while you're moving
laterally through projects,

735
00:26:10,620 --> 00:26:12,230
you happen to land on a service account

736
00:26:12,230 --> 00:26:14,430
that has an org level
binding, through inheritance,

737
00:26:14,430 --> 00:26:17,210
you get access to the entire org that way.

738
00:26:17,210 --> 00:26:19,980
So to recap, we started
with a base identity in BBS2

739
00:26:19,980 --> 00:26:21,800
that had act as on the project.

740
00:26:21,800 --> 00:26:23,140
We then used that permission

741
00:26:23,140 --> 00:26:25,750
to gain access to every
service account in this project

742
00:26:25,750 --> 00:26:26,930
via cloud functions.

743
00:26:26,930 --> 00:26:29,330
One of the service accounts
in BBS2 had an owner role,

744
00:26:29,330 --> 00:26:32,600
which allowed us to elevate
privileges in the BBS2 project.

745
00:26:32,600 --> 00:26:35,458
A different service account
had a roll binding into BBS3.

746
00:26:35,458 --> 00:26:37,200
This allowed us to use act as

747
00:26:37,200 --> 00:26:39,560
to take control of all the
service accounts and BBS3.

748
00:26:39,560 --> 00:26:41,470
One of the service
accounts we found in BBS3

749
00:26:41,470 --> 00:26:43,290
had an organizational role binding,

750
00:26:43,290 --> 00:26:45,893
and this allowed us to take
control of the entire org.

751
00:26:48,570 --> 00:26:51,153
(upbeat music)

752
00:27:03,000 --> 00:27:05,030
So we talked about when
you provision resources.

753
00:27:05,030 --> 00:27:07,310
When you attach service
accounts to those resources,

754
00:27:07,310 --> 00:27:08,470
GCP will check to make sure

755
00:27:08,470 --> 00:27:10,160
that you have the act as permission first

756
00:27:10,160 --> 00:27:12,210
before allowing you to
provision the resource.

757
00:27:12,210 --> 00:27:14,000
Because some APIs like thought functions

758
00:27:14,000 --> 00:27:16,090
require that you have
identities to power them,

759
00:27:16,090 --> 00:27:18,660
this leads to a lot of people
getting the act as permission.

760
00:27:18,660 --> 00:27:20,250
Well, it turns out that some APIs

761
00:27:20,250 --> 00:27:21,980
will actually allow you
to provision resources

762
00:27:21,980 --> 00:27:23,410
with a service account attached to them

763
00:27:23,410 --> 00:27:25,330
without the need for
the act as permission.

764
00:27:25,330 --> 00:27:29,290
These include the Dataproc,
Dataflow and Composer APIs.

765
00:27:29,290 --> 00:27:31,407
Let's talk about the Dataproc API.

766
00:27:31,407 --> 00:27:34,610
The Dataproc API is Google's
data processing API.

767
00:27:34,610 --> 00:27:37,250
Among other things, it
includes managed Apache Hadoop

768
00:27:37,250 --> 00:27:38,890
and managed Apache Spark.

769
00:27:38,890 --> 00:27:40,570
When you spin up a Dataproc cluster,

770
00:27:40,570 --> 00:27:42,940
like a lot of things
in GCP, it will default

771
00:27:42,940 --> 00:27:45,560
to using the default compute
engine service account.

772
00:27:45,560 --> 00:27:47,430
This means by default, your Spark jobs

773
00:27:47,430 --> 00:27:48,870
will run as project editor.

774
00:27:48,870 --> 00:27:51,250
You only need the permission
Dataproc cluster create

775
00:27:51,250 --> 00:27:52,350
to spin up this cluster.

776
00:27:52,350 --> 00:27:54,630
You don't actually need
the act as permission

777
00:27:54,630 --> 00:27:56,090
on the default service account.

778
00:27:56,090 --> 00:27:56,990
Because of this,

779
00:27:56,990 --> 00:27:59,760
anyone who has the Dataproc
cluster create permission

780
00:27:59,760 --> 00:28:02,850
can actually make use of the
default editor service account.

781
00:28:02,850 --> 00:28:04,300
Put another way, service accounts

782
00:28:04,300 --> 00:28:05,480
that are only intended to be able

783
00:28:05,480 --> 00:28:06,970
to spin up Dataproc clusters

784
00:28:06,970 --> 00:28:09,490
can privilege escalate
themselves to project editor,

785
00:28:09,490 --> 00:28:12,060
and then they can make use
of that act as permission

786
00:28:12,060 --> 00:28:13,140
to take control of the rest

787
00:28:13,140 --> 00:28:14,630
of the surface accounts in the project.

788
00:28:14,630 --> 00:28:16,540
We built support for this into Gcploit,

789
00:28:16,540 --> 00:28:18,530
so let's take a look and
see what it looks like.

790
00:28:18,530 --> 00:28:19,390
If we take another look

791
00:28:19,390 --> 00:28:21,320
at the list of service
accounts we've compromised,

792
00:28:21,320 --> 00:28:23,070
there's one here that says Dataproc.

793
00:28:23,070 --> 00:28:25,650
Let's run the G-Cloud projects
list on this service account

794
00:28:25,650 --> 00:28:27,700
and see what projects that has access to.

795
00:28:34,513 --> 00:28:36,340
It looks like it has access to a BBS4.

796
00:28:36,340 --> 00:28:39,230
Now, let's run the
Dataproc exploit on BBS4

797
00:28:39,230 --> 00:28:41,090
through the Dataproc service account.

798
00:28:41,090 --> 00:28:43,520
We have to spin up a
whole Dataproc to do this,

799
00:28:43,520 --> 00:28:44,840
and that takes a little bit of time.

800
00:28:44,840 --> 00:28:46,190
And then we delete it afterwards,

801
00:28:46,190 --> 00:28:47,600
so that we're not built too long.

802
00:28:47,600 --> 00:28:49,040
So we'll fast forward to this part.

803
00:28:49,040 --> 00:28:51,510
But at the end of it, when
we run G-Cloud list again,

804
00:28:51,510 --> 00:28:53,430
we can see a new service
account has been added

805
00:28:53,430 --> 00:28:56,420
and that's the default service
account in the BBS4 project.

806
00:28:56,420 --> 00:28:58,070
We were able to get this service account

807
00:28:58,070 --> 00:29:00,630
by spinning up a Dataproc cluster in BBS4

808
00:29:00,630 --> 00:29:02,900
and then running a Spark
job on that cluster,

809
00:29:02,900 --> 00:29:05,580
which enabled us to grab the
credential off the instance.

810
00:29:05,580 --> 00:29:07,650
Because our Dataproc
service account credential

811
00:29:07,650 --> 00:29:09,440
had the ability to spin the cluster up,

812
00:29:09,440 --> 00:29:11,740
it also controlled the
scopes for that cluster.

813
00:29:11,740 --> 00:29:12,930
And so we just defined the scopes

814
00:29:12,930 --> 00:29:14,540
for this cluster to be wide open.

815
00:29:14,540 --> 00:29:16,340
Next, since we have a default editor

816
00:29:16,340 --> 00:29:17,930
surface account credential at this point,

817
00:29:17,930 --> 00:29:20,230
we can run the act as
exploit on this project.

818
00:29:24,970 --> 00:29:27,070
Well, again, fast forward to this process.

819
00:29:30,930 --> 00:29:33,550
And finally, if we run the
G-Cloud list one more time,

820
00:29:33,550 --> 00:29:35,210
we can see a whole bunch
of new service accounts

821
00:29:35,210 --> 00:29:37,410
that we now have access
to in the BBS4 project.

822
00:29:37,410 --> 00:29:39,860
So just to recap, some APIs and GCP

823
00:29:39,860 --> 00:29:42,830
do not require the act as
permission to spin up resources

824
00:29:42,830 --> 00:29:44,750
and attach the default
service accounts to them.

825
00:29:44,750 --> 00:29:46,750
The identities that can
spend those resources up

826
00:29:46,750 --> 00:29:48,260
can also control the scopes.

827
00:29:48,260 --> 00:29:49,510
So effectively, in cases

828
00:29:49,510 --> 00:29:51,950
like Dataproc and Dataflow and Composer,

829
00:29:51,950 --> 00:29:54,940
any identity that's granted
permissions to those APIs

830
00:29:54,940 --> 00:29:57,200
can privilege escalate
themselves to project editor.

831
00:29:57,200 --> 00:29:58,280
One last thing to note here

832
00:29:58,280 --> 00:29:59,940
is because this Dataproc role binding

833
00:29:59,940 --> 00:30:02,780
was actually cross project,
this allowed us to, again,

834
00:30:02,780 --> 00:30:05,030
compromise the new project, BBS4.

835
00:30:05,030 --> 00:30:06,740
And because the default service accounts

836
00:30:06,740 --> 00:30:09,040
are in every project, this
allows us to take control

837
00:30:09,040 --> 00:30:11,540
of all of the service
accounts in the new project.

838
00:30:13,892 --> 00:30:16,475
(upbeat music)

839
00:30:28,160 --> 00:30:30,830
Google has a new feature in
their asset inventory API

840
00:30:30,830 --> 00:30:32,620
called the IAM Analyzer.

841
00:30:32,620 --> 00:30:34,200
We worked with Google on this feature

842
00:30:34,200 --> 00:30:36,700
and one of the user stories
actually came from us.

843
00:30:38,530 --> 00:30:41,030
We came up with a list of
dangerous roles and permissions

844
00:30:41,030 --> 00:30:43,060
that can be used to take control
of all the service accounts

845
00:30:43,060 --> 00:30:43,893
in the project.

846
00:30:43,893 --> 00:30:44,900
These can be seen here.

847
00:30:44,900 --> 00:30:47,080
We won't demo Dataflow and Composer,

848
00:30:47,080 --> 00:30:47,913
but you can think of them

849
00:30:47,913 --> 00:30:49,490
as working the same way as Dataproc.

850
00:30:49,490 --> 00:30:50,930
Using the IAM Analyzer

851
00:30:50,930 --> 00:30:53,270
and the dangerous permissions
that we're able to find,

852
00:30:53,270 --> 00:30:55,470
we're able to run a BFS
search on a base identity

853
00:30:55,470 --> 00:30:56,303
without the need

854
00:30:56,303 --> 00:30:59,230
to spin up expensive
resources exploiting services.

855
00:30:59,230 --> 00:31:00,830
As you can see from the output here,

856
00:31:00,830 --> 00:31:02,510
we get the same list of surface accounts

857
00:31:02,510 --> 00:31:04,990
from the same base identity
as we did exploiting things,

858
00:31:04,990 --> 00:31:06,380
except this was much faster.

859
00:31:06,380 --> 00:31:07,850
We didn't have to spend anything up.

860
00:31:07,850 --> 00:31:09,760
You need an org binding to use this.

861
00:31:09,760 --> 00:31:11,270
So this is a tool for defenders

862
00:31:11,270 --> 00:31:12,950
to be able to get quick answers

863
00:31:12,950 --> 00:31:14,970
to how an attacker might
be able to move laterally

864
00:31:14,970 --> 00:31:16,260
through the organization.

865
00:31:16,260 --> 00:31:17,810
If we cut back to our mock graph,

866
00:31:17,810 --> 00:31:20,240
let's zoom into a seemingly
innocent base identity.

867
00:31:20,240 --> 00:31:22,250
This service account gyuadvcl

868
00:31:22,250 --> 00:31:25,340
was meant to only run Spark
jobs and it's base project 14.

869
00:31:25,340 --> 00:31:27,110
It only has the Dataproc editor role.

870
00:31:27,110 --> 00:31:29,320
Now I'll run a BFS search
from this starting identity

871
00:31:29,320 --> 00:31:31,060
and highlight the path in blue.

872
00:31:31,060 --> 00:31:32,810
As you can see, this
allowed us to compromise

873
00:31:32,810 --> 00:31:34,650
all the service accounts
in the starting project

874
00:31:34,650 --> 00:31:36,610
through the default editor
role on our Spark job.

875
00:31:36,610 --> 00:31:38,550
Most of these service
accounts have benign roles

876
00:31:38,550 --> 00:31:40,120
like storage or pubsub,

877
00:31:40,120 --> 00:31:42,030
and most of them are not cross project.

878
00:31:42,030 --> 00:31:45,240
That said, some like this one
have dangerous role bindings

879
00:31:45,240 --> 00:31:46,110
that are cross project,

880
00:31:46,110 --> 00:31:48,260
in this case, the Dataflow developer role.

881
00:31:48,260 --> 00:31:50,290
These allow us to take full
control of service accounts

882
00:31:50,290 --> 00:31:51,720
in different projects.

883
00:31:51,720 --> 00:31:52,700
As we start to zoom out,

884
00:31:52,700 --> 00:31:54,170
we can begin to see the whole picture.

885
00:31:54,170 --> 00:31:56,820
We've managed to compromise
most of the service accounts

886
00:31:56,820 --> 00:31:59,230
in the org with a few
notable project exceptions

887
00:31:59,230 --> 00:32:01,310
that just don't have any
dangerous role bindings to them.

888
00:32:01,310 --> 00:32:03,900
We're only looking at project
level bindings in this graph.

889
00:32:03,900 --> 00:32:06,690
So if any of these surface
accounts have org level bindings,

890
00:32:06,690 --> 00:32:08,073
it's not reflected here.

891
00:32:08,970 --> 00:32:10,700
- So we just saw some really
interesting techniques

892
00:32:10,700 --> 00:32:13,420
around privilege escalation
and lateral movement,

893
00:32:13,420 --> 00:32:16,230
but we also wanted to
provide a way to detect this.

894
00:32:16,230 --> 00:32:17,780
So we fingerprinted this tooling

895
00:32:17,780 --> 00:32:19,980
and we'll be releasing
monitoring and alerting

896
00:32:19,980 --> 00:32:22,890
to detect the behavior of
this tool in your environment.

897
00:32:22,890 --> 00:32:23,820
- I think one of the nice things

898
00:32:23,820 --> 00:32:25,420
about doing security work in the cloud

899
00:32:25,420 --> 00:32:27,830
is how much help you get
from your upstream provider.

900
00:32:27,830 --> 00:32:30,480
If we were doing work on a
web application or a binary,

901
00:32:30,480 --> 00:32:32,070
we'd kind of be left to our own vices

902
00:32:32,070 --> 00:32:33,540
to fix the problems we found.

903
00:32:33,540 --> 00:32:35,360
But because we had a close
partnership with Google,

904
00:32:35,360 --> 00:32:37,510
we were able to work with them
to roll out some new features

905
00:32:37,510 --> 00:32:40,070
that help with the security
story of some of these problems.

906
00:32:40,070 --> 00:32:41,280
One of the people that helped us do that

907
00:32:41,280 --> 00:32:43,010
is a security engineer named Bakh Inamoo.

908
00:32:43,010 --> 00:32:45,330
Can we gave him an invitation
to do a brief cameo

909
00:32:45,330 --> 00:32:46,630
and talk about some of the new features

910
00:32:46,630 --> 00:32:48,150
that we helped go or roll out.

911
00:32:48,150 --> 00:32:49,100
- Hello, black hat.

912
00:32:53,520 --> 00:32:56,080
I had the privilege of
working with Alison and Dylan

913
00:32:56,080 --> 00:32:58,840
as a result of our
collaboration with Google Cloud

914
00:32:58,840 --> 00:33:00,300
launched several features

915
00:33:00,300 --> 00:33:02,360
that help customers address concerns.

916
00:33:02,360 --> 00:33:04,260
On the prevention side of things,

917
00:33:04,260 --> 00:33:06,490
we now have an org policy constraint

918
00:33:06,490 --> 00:33:08,570
that prevents the editor grant

919
00:33:08,570 --> 00:33:11,530
to the default service
accounts for compute engine

920
00:33:11,530 --> 00:33:14,270
and the app engine, and we
advice customers to turn it on.

921
00:33:14,270 --> 00:33:17,900
We recommend that customers
create custom service accounts

922
00:33:17,900 --> 00:33:19,860
with the necessary set of permissions

923
00:33:19,860 --> 00:33:21,390
on the target resources

924
00:33:21,390 --> 00:33:24,630
as opposed to the broad
project level editor grants.

925
00:33:24,630 --> 00:33:26,410
Alison and Dylan briefly touched

926
00:33:26,410 --> 00:33:29,550
upon the investigative IAM Analyzer tool.

927
00:33:29,550 --> 00:33:32,210
As you saw, we built IAM Analyzer

928
00:33:32,210 --> 00:33:35,730
to be able to address the
use case of finding resources

929
00:33:35,730 --> 00:33:38,950
which are granted access
to any specific identity.

930
00:33:38,950 --> 00:33:41,120
The other investigative feature available

931
00:33:41,120 --> 00:33:42,960
is the IAM Recommender.

932
00:33:42,960 --> 00:33:45,710
It uses machine learning
to valuate the permissions

933
00:33:45,710 --> 00:33:47,210
granted to an identity

934
00:33:47,210 --> 00:33:50,100
against actual activities
performed by the identity.

935
00:33:50,100 --> 00:33:53,210
It's a great way to find overly
generous permission grants

936
00:33:53,210 --> 00:33:55,053
and to identify the actual permissions

937
00:33:55,053 --> 00:33:56,680
that are needed for the workload.

938
00:33:56,680 --> 00:34:00,100
I spent many years working
with all major cloud providers

939
00:34:00,100 --> 00:34:02,540
and the statement is generally
true for all of them.

940
00:34:02,540 --> 00:34:06,020
Start their cloud UIs,
those flows are optimized

941
00:34:06,020 --> 00:34:07,350
for ease of onboarding.

942
00:34:07,350 --> 00:34:10,700
And so the fundamental challenge
for large organizations

943
00:34:10,700 --> 00:34:13,800
is to make available
seeing the secure defaults

944
00:34:13,800 --> 00:34:17,090
as well as preventative
guardrails for their developers.

945
00:34:17,090 --> 00:34:18,400
Those are usually in the shape

946
00:34:18,400 --> 00:34:20,870
of cloud foundation code basis,

947
00:34:20,870 --> 00:34:22,930
such as infrastructure code samples

948
00:34:22,930 --> 00:34:24,520
that are built with security in mind,

949
00:34:24,520 --> 00:34:26,300
policy has called evaluations

950
00:34:26,300 --> 00:34:28,660
as part of the build
and release pipelines,

951
00:34:28,660 --> 00:34:31,810
and preventative controls
exposed by the cloud providers

952
00:34:31,810 --> 00:34:34,720
such as org policy constraints on GCP.

953
00:34:34,720 --> 00:34:36,000
If we're leaving developers

954
00:34:36,000 --> 00:34:39,090
to the mercy of those starter UI flows

955
00:34:39,090 --> 00:34:42,370
on the cloud providers or
stack overflow code snippets,

956
00:34:42,370 --> 00:34:43,990
we're gonna end up in a bad place.

957
00:34:43,990 --> 00:34:45,550
If you're a Google Cloud customer,

958
00:34:45,550 --> 00:34:47,530
and they're looking for
guidance in this area,

959
00:34:47,530 --> 00:34:49,810
you should try to engage our account team

960
00:34:49,810 --> 00:34:51,410
so that we can help out.

961
00:34:51,410 --> 00:34:54,690
Alison and Dylan, on behalf
of everyone at Google Cloud,

962
00:34:54,690 --> 00:34:57,420
we are very grateful for the collaboration

963
00:34:57,420 --> 00:35:00,230
on improving our customer's
experience on the platform,

964
00:35:00,230 --> 00:35:02,400
and for the opportunity
to have a cameo appearance

965
00:35:02,400 --> 00:35:03,233
in this talk.

966
00:35:03,233 --> 00:35:06,190
I'm hoping The Blackout
2021 happens in person,

967
00:35:06,190 --> 00:35:08,620
and we can share stories and
the face-to-face setting.

968
00:35:08,620 --> 00:35:10,780
Until then, please wear face masks,

969
00:35:10,780 --> 00:35:13,290
and don't forget to turn on
two-factor authentication

970
00:35:13,290 --> 00:35:14,333
wherever possible.

971
00:35:20,040 --> 00:35:21,140
Thank you.

972
00:35:21,140 --> 00:35:21,973
- Thank you, buck.

973
00:35:21,973 --> 00:35:24,220
We also wanted to provide some context

974
00:35:24,220 --> 00:35:25,430
and a little bit more insight

975
00:35:25,430 --> 00:35:27,380
and let you know a few of the limitations

976
00:35:27,380 --> 00:35:28,940
or constraints to these tools.

977
00:35:28,940 --> 00:35:30,690
So one of the main limitations

978
00:35:30,690 --> 00:35:32,440
to the organization policy services,

979
00:35:32,440 --> 00:35:34,880
you actually have to have
an organization resource,

980
00:35:34,880 --> 00:35:37,020
either through cloud identity or G Suite

981
00:35:37,020 --> 00:35:39,910
to be able to use the
organization policy service.

982
00:35:39,910 --> 00:35:41,090
If you only have projects,

983
00:35:41,090 --> 00:35:42,340
you won't actually be able to leverage

984
00:35:42,340 --> 00:35:44,230
any of the constraints that are available.

985
00:35:44,230 --> 00:35:46,850
Another limitation within the
organization policy service

986
00:35:46,850 --> 00:35:48,770
is that constraints are not retroactive.

987
00:35:48,770 --> 00:35:51,230
So when the policy is applied,

988
00:35:51,230 --> 00:35:53,940
all resources will be
affected by the policy

989
00:35:53,940 --> 00:35:56,820
or evaluated by the policy
after it is enabled,

990
00:35:56,820 --> 00:35:59,010
but existing resources
will not be modified

991
00:35:59,010 --> 00:36:02,440
to match or meet the requirements
of a given constraint.

992
00:36:02,440 --> 00:36:04,900
Another thing to note is
that for the new disable,

993
00:36:04,900 --> 00:36:07,200
automatic, IAM grants for
default service accounts,

994
00:36:07,200 --> 00:36:10,200
that constraint will only enforce

995
00:36:10,200 --> 00:36:13,793
that when the APIs are initially
enabled for new projects,

996
00:36:13,793 --> 00:36:15,720
that the default service counts

997
00:36:15,720 --> 00:36:18,020
are not granted editor level role bindings

998
00:36:18,020 --> 00:36:20,160
at the time of the APIs being enabled,

999
00:36:20,160 --> 00:36:21,820
but there's no enforcement mechanism

1000
00:36:21,820 --> 00:36:23,830
to ensure that the
default service accounts

1001
00:36:23,830 --> 00:36:28,140
are not granted a project
level binding or other binding.

1002
00:36:28,140 --> 00:36:32,180
There's also no way to restrict
the cross project bindings

1003
00:36:32,180 --> 00:36:33,750
that we talked about previously

1004
00:36:33,750 --> 00:36:36,160
where if a user knows the
name of your service account,

1005
00:36:36,160 --> 00:36:38,760
they could still give the
service account access

1006
00:36:38,760 --> 00:36:40,630
to their project or projects resources.

1007
00:36:40,630 --> 00:36:42,990
So the IAM Recommender is very powerful.

1008
00:36:42,990 --> 00:36:44,700
Some of the limitations on the tool

1009
00:36:44,700 --> 00:36:47,200
is that you have to have a 90-day period

1010
00:36:47,200 --> 00:36:49,290
where the policies or behavior

1011
00:36:49,290 --> 00:36:51,130
of a given identity are evaluated

1012
00:36:51,130 --> 00:36:53,500
so that you can have a
recommendation being made,

1013
00:36:53,500 --> 00:36:54,923
and there may be more IAM bindings

1014
00:36:54,923 --> 00:36:56,450
that you may not be aware of,

1015
00:36:56,450 --> 00:36:59,030
like the cross project bindings.

1016
00:36:59,030 --> 00:37:01,120
The IAM analyzer can
provide a lot of context

1017
00:37:01,120 --> 00:37:04,640
into the IAM bindings or
associations for a given identity,

1018
00:37:04,640 --> 00:37:07,620
and in order to use this auditing tool,

1019
00:37:07,620 --> 00:37:09,990
you have to have
administrative capabilities

1020
00:37:09,990 --> 00:37:13,540
in an organization to be
able to see the policies

1021
00:37:13,540 --> 00:37:14,373
that are being analyzed.

1022
00:37:14,373 --> 00:37:17,080
So in order to use this
tool to the fullest extent,

1023
00:37:17,080 --> 00:37:20,100
you need administrative
capabilities in your organization

1024
00:37:20,100 --> 00:37:21,790
as well as within G Suite

1025
00:37:21,790 --> 00:37:24,030
if you want to expand group membership

1026
00:37:24,030 --> 00:37:27,080
to know who has access to
a given service account

1027
00:37:27,080 --> 00:37:28,210
that is in a group.

1028
00:37:28,210 --> 00:37:30,910
Earlier, we talked about
how Kubernetes workloads

1029
00:37:30,910 --> 00:37:33,580
have access to the
underlying service account

1030
00:37:33,580 --> 00:37:34,750
that's attached to the node.

1031
00:37:34,750 --> 00:37:38,410
And the suggested way
to harden your clusters

1032
00:37:38,410 --> 00:37:40,780
is to use a service
called Workload Identity,

1033
00:37:40,780 --> 00:37:42,570
and Workload Identity allows you

1034
00:37:42,570 --> 00:37:45,000
to associate a Kubernetes service account

1035
00:37:45,000 --> 00:37:46,750
with a cloud identity,

1036
00:37:46,750 --> 00:37:48,970
and this is how you
can harden your cluster

1037
00:37:48,970 --> 00:37:50,600
as well as have a one-to-one mapping

1038
00:37:50,600 --> 00:37:52,050
of Kubernetes service accounts

1039
00:37:52,050 --> 00:37:54,000
to cloud identity service accounts.

1040
00:37:54,000 --> 00:37:56,510
We brought up earlier to
ensure default service accounts

1041
00:37:56,510 --> 00:37:59,010
are not granted project
level role bindings

1042
00:37:59,010 --> 00:38:00,210
or other role bindings.

1043
00:38:00,210 --> 00:38:02,530
After the disable automatic IAM grants

1044
00:38:02,530 --> 00:38:05,480
for default service accounts,
constraint is enabled

1045
00:38:05,480 --> 00:38:07,120
that you require additional tooling,

1046
00:38:07,120 --> 00:38:08,800
and to demonstrate a way

1047
00:38:08,800 --> 00:38:11,160
that you can enforce these configurations,

1048
00:38:11,160 --> 00:38:14,100
we will be releasing a
Terraform Enterprise Sentinel

1049
00:38:14,100 --> 00:38:17,040
policy set that can demonstrate enforcing

1050
00:38:17,040 --> 00:38:18,150
that default service counts

1051
00:38:18,150 --> 00:38:20,240
are not granted project
level role bindings,

1052
00:38:20,240 --> 00:38:24,150
or that roles that enable
service count takeover

1053
00:38:24,150 --> 00:38:26,050
or management of service accounts

1054
00:38:26,050 --> 00:38:27,930
cannot be applied at the project level.

1055
00:38:27,930 --> 00:38:30,440
Sentinel policies are Terraform enterprise

1056
00:38:30,440 --> 00:38:32,590
policy configuration language

1057
00:38:32,590 --> 00:38:35,210
that enable you to either restrict

1058
00:38:35,210 --> 00:38:38,510
or alert on specific
configurations in your runs.

1059
00:38:38,510 --> 00:38:41,150
So just to recap, some
of the key takeaways,

1060
00:38:41,150 --> 00:38:43,360
IAM and GCP is very resource-centric,

1061
00:38:43,360 --> 00:38:45,500
meaning that if you are
a service counts owner,

1062
00:38:45,500 --> 00:38:47,590
you may not be aware of the configurations

1063
00:38:47,590 --> 00:38:49,360
that are associated
with that service count,

1064
00:38:49,360 --> 00:38:52,350
or how it may be used
across a GCP organization.

1065
00:38:52,350 --> 00:38:54,500
This can lead to projects
being interconnected

1066
00:38:54,500 --> 00:38:56,840
in many different ways that
you may not be able to see.

1067
00:38:56,840 --> 00:38:59,180
Role bindings are often
done at the project level

1068
00:38:59,180 --> 00:39:02,410
and can grant more access
than a user intends to.

1069
00:39:02,410 --> 00:39:03,730
A lot of managed services

1070
00:39:03,730 --> 00:39:06,280
and general resource
provisioning operations

1071
00:39:06,280 --> 00:39:10,400
can hand off access to your
projects resources and IAM

1072
00:39:10,400 --> 00:39:11,700
that you may not be aware of.

1073
00:39:11,700 --> 00:39:14,950
This kind of access that's
granted through resource creation

1074
00:39:14,950 --> 00:39:17,010
can lead to privilege escalation

1075
00:39:17,010 --> 00:39:19,280
and lateral movements
within your environments.

1076
00:39:19,280 --> 00:39:21,790
Another thing we covered is
that default surface accounts

1077
00:39:21,790 --> 00:39:23,920
are granted administrative roles

1078
00:39:23,920 --> 00:39:25,650
within your project automatically

1079
00:39:25,650 --> 00:39:27,157
and that's with the editor role,

1080
00:39:27,157 --> 00:39:29,850
unless you're using the
disable automatic IAM grants

1081
00:39:29,850 --> 00:39:32,280
for default service counts
organization constraint.

1082
00:39:32,280 --> 00:39:34,980
Reduce usage of default
service accounts where possible

1083
00:39:34,980 --> 00:39:37,620
by creating service
specific service accounts

1084
00:39:37,620 --> 00:39:40,370
with IAM roles that are
scoped to your services needs.

1085
00:39:40,370 --> 00:39:42,740
There are a few new cool
tools in the platform

1086
00:39:42,740 --> 00:39:44,390
that have been released to assist you

1087
00:39:44,390 --> 00:39:47,470
in understanding who has access
to your surface accounts,

1088
00:39:47,470 --> 00:39:50,470
such as the IAM Analyzer, which
can also be really helpful

1089
00:39:50,470 --> 00:39:52,800
for understanding IAM dependencies

1090
00:39:52,800 --> 00:39:55,163
and access within your environments.

1091
00:39:57,542 --> 00:40:00,125
(upbeat music)

