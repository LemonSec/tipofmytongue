1
00:00:01,520 --> 00:00:05,200
- Hello everyone. Thank you
for attending this talk.

2
00:00:05,200 --> 00:00:09,070
I am Slava, I am a security
researcher at Checkpoint.

3
00:00:09,070 --> 00:00:12,070
Security research is my daily work.

4
00:00:12,070 --> 00:00:15,690
Today, I am going to show
how an Android application

5
00:00:15,690 --> 00:00:19,920
can affect the digital signal
processor of a mobile device,

6
00:00:19,920 --> 00:00:21,970
and thereby gain privileges

7
00:00:21,970 --> 00:00:24,707
and denial of service capabilities.

8
00:00:28,220 --> 00:00:29,750
Let's begin with a question.

9
00:00:29,750 --> 00:00:34,160
Do you know how many processors
are on your mobile phone?

10
00:00:34,160 --> 00:00:36,480
The answer is many.

11
00:00:36,480 --> 00:00:38,950
As a single Snapdragon system on a chip,

12
00:00:38,950 --> 00:00:41,243
embedded in Pixel, Samsung,
Xiaomi, G, OnePlus,

13
00:00:42,709 --> 00:00:44,860
Sony and other devices.

14
00:00:44,860 --> 00:00:47,990
May include multiple CPU codes.

15
00:00:47,990 --> 00:00:50,730
An Adreno graphic processor unit,

16
00:00:50,730 --> 00:00:52,814
a Snapdragon viral model,

17
00:00:52,814 --> 00:00:55,240
a Hexagon digital signal processor,

18
00:00:55,240 --> 00:00:57,523
and Spectra image signal processor.

19
00:00:58,850 --> 00:01:02,410
Snapdragon product tiers are
differentiated by scalable

20
00:01:02,410 --> 00:01:06,913
computing resources for
this CPU, GPU and DSP.

21
00:01:08,140 --> 00:01:12,060
The lowest tiers might contain
only a single Hexagon DSP

22
00:01:13,070 --> 00:01:15,146
whereas the premium tier,

23
00:01:15,146 --> 00:01:18,243
contains up to four
Hexagon DSP processors,

24
00:01:18,243 --> 00:01:20,853
dedicated for specific use cases.

25
00:01:22,270 --> 00:01:27,090
These are, modern DSP, known as baseband,

26
00:01:27,090 --> 00:01:30,587
audio DSP, compute DSP and sensor DSP.

27
00:01:31,430 --> 00:01:32,340
In this research,

28
00:01:32,340 --> 00:01:36,873
I turned my attention to
aDSP and cDSP subsystems.

29
00:01:39,130 --> 00:01:42,680
aDSP and cDSP processors are
intended for such group tasks

30
00:01:42,680 --> 00:01:46,060
as processing of audio and voice data,

31
00:01:46,060 --> 00:01:48,630
computer vision, machine
learning calculations,

32
00:01:48,630 --> 00:01:52,327
camera streaming, artificial
intelligence, et cetera.

33
00:01:53,330 --> 00:01:55,923
On some devices such as a Sony Xperia XZ,

34
00:01:57,020 --> 00:01:58,970
only this aDSP processor

35
00:01:58,970 --> 00:02:02,110
is responsible for all these tasks.

36
00:02:02,110 --> 00:02:05,570
But on other devices such as the Pixel 4,

37
00:02:05,570 --> 00:02:09,203
these tasks are shared
between aDSP and cDSP.

38
00:02:11,580 --> 00:02:14,189
Let's take a look at the communications,

39
00:02:14,189 --> 00:02:18,653
in between an Android application
and a DSP running library.

40
00:02:20,790 --> 00:02:24,960
FastRPC is the Qualcomm
proprietary RPC mechanism

41
00:02:24,960 --> 00:02:29,960
used to enable remote function calls,

42
00:02:29,970 --> 00:02:34,287
between application processor,
where Android is run and DSP.

43
00:02:35,440 --> 00:02:36,530
On Android side,

44
00:02:36,530 --> 00:02:40,360
user mode process initiates
the remote in our case.

45
00:02:40,360 --> 00:02:42,420
In our case and Android application,

46
00:02:42,420 --> 00:02:46,963
calls one of the stub
functions in its name before.

47
00:02:48,050 --> 00:02:50,874
Stub is autogenerated code,

48
00:02:50,874 --> 00:02:55,213
that convert the function
all to an RPC message.

49
00:02:56,610 --> 00:02:59,890
Generally, the stub code is compiled

50
00:02:59,890 --> 00:03:01,883
as separate native library.

51
00:03:02,962 --> 00:03:07,820
The stub code, loads
libadsprpc.so and lipcdsprpc.so

52
00:03:09,280 --> 00:03:12,733
built-in libraries, and
to invoke Android drivers.

53
00:03:14,500 --> 00:03:18,090
DSPRPC drivers sent the QuRT message

54
00:03:18,090 --> 00:03:23,090
to the DSP side, through the
surety memory trial channel,

55
00:03:23,120 --> 00:03:25,787
and then wait for the response.

56
00:03:27,909 --> 00:03:31,340
On DSP side, a framework presented by,

57
00:03:31,340 --> 00:03:34,220
the FastRPC shell binary,

58
00:03:34,220 --> 00:03:36,270
dig uses as the messages

59
00:03:36,270 --> 00:03:39,993
and dispatches them for
processing by a skeleton code.

60
00:03:41,040 --> 00:03:46,040
And again, skeleton is
an autogenerated library

61
00:03:46,360 --> 00:03:48,460
that unmarshals parameters,

62
00:03:48,460 --> 00:03:51,960
and causes a target method
in the object library.

63
00:03:52,860 --> 00:03:57,510
The object library is some
logic provided by Qualcomm OEMs

64
00:03:57,510 --> 00:03:59,960
and design to run on aDSP.

65
00:04:03,250 --> 00:04:07,077
Who can run their own code on DSP?

66
00:04:07,077 --> 00:04:09,600
And if your party developer can implement

67
00:04:09,600 --> 00:04:11,750
it's own DSP library.

68
00:04:11,750 --> 00:04:14,070
Because the Hexagon SDK,

69
00:04:14,070 --> 00:04:17,120
which is responsible for
compiling C C Plus Plus code

70
00:04:17,120 --> 00:04:20,393
in the Hexagon byte book
is publicly available.

71
00:04:21,440 --> 00:04:26,440
But it's impossible to run at
a third party library on DSP.

72
00:04:26,540 --> 00:04:27,830
For security reasons,

73
00:04:27,830 --> 00:04:31,970
DSP is licensed for programming by OEMs

74
00:04:31,970 --> 00:04:36,023
and code running on the
DSP is signed by Qualcomm.

75
00:04:38,700 --> 00:04:41,273
Who manages the DSP? It's QuRT.

76
00:04:42,421 --> 00:04:44,550
A Qualcomm Proprietary Multi-Threaders,

77
00:04:44,550 --> 00:04:47,070
Real Time Operating System.

78
00:04:47,070 --> 00:04:51,277
Integrity of the QuRT is
trusted by the TrustZone,

79
00:04:51,277 --> 00:04:56,277
QuRT executable binary and
different for aDSP and cDSP,

80
00:04:56,280 --> 00:04:59,690
is signed and split into several files,

81
00:04:59,690 --> 00:05:03,180
in the same way as any
other trusted application

82
00:05:03,180 --> 00:05:04,663
on Qualcomm devices.

83
00:05:07,300 --> 00:05:11,261
For each Android process,
initiating the remote in my case,

84
00:05:11,261 --> 00:05:14,923
QuRT create a separate FastRPC
shell process on the DSP.

85
00:05:16,720 --> 00:05:18,330
The DSP architecture,

86
00:05:18,330 --> 00:05:20,773
provides different protection domains, PD.

87
00:05:21,750 --> 00:05:25,620
Kernel PD has access to
all memory of all domains

88
00:05:25,620 --> 00:05:30,620
and Quest OS PD has access
to the memory of its own PD,

89
00:05:30,680 --> 00:05:34,323
the memory of the user PD
and some system registers.

90
00:05:35,530 --> 00:05:39,037
User PD has access only to its own memory.

91
00:05:40,330 --> 00:05:42,410
Skeleton and object libraries,

92
00:05:42,410 --> 00:05:45,450
as well as the FastRPC shell

93
00:05:45,450 --> 00:05:48,653
are running in the user protection domain.

94
00:05:51,560 --> 00:05:53,873
The stub code provided by Qualcomm OEMs,

95
00:05:54,840 --> 00:05:58,360
can be skipped from the FastRPC chain.

96
00:05:58,360 --> 00:06:02,483
As was mentioned, libadsprpc
and libcdsprpc libraries

97
00:06:04,000 --> 00:06:07,453
are responsible for
communication this DSPRPC driver.

98
00:06:08,630 --> 00:06:11,513
Each library exports two major functions.

99
00:06:12,850 --> 00:06:17,290
Remote handle open function
opens remote session

100
00:06:17,290 --> 00:06:20,217
between the client on
application processor

101
00:06:20,217 --> 00:06:23,870
and Nu FastRPC shell process on the DSP.

102
00:06:24,867 --> 00:06:27,777
The skeleton library name is
provided as the (murmurs).

103
00:06:29,860 --> 00:06:34,050
Remote handle invoke function
is able to invoke methods

104
00:06:34,050 --> 00:06:36,343
exported by the skeleton library.

105
00:06:37,370 --> 00:06:39,107
You then these two functions,

106
00:06:39,107 --> 00:06:41,475
and Android application
can request to execute

107
00:06:41,475 --> 00:06:44,973
any skeleton method
without using a stub code.

108
00:06:47,210 --> 00:06:48,890
Now, we have enough information

109
00:06:48,890 --> 00:06:51,217
to state the downgrade vulnerabilty.

110
00:06:52,067 --> 00:06:55,390
DSP libraries are signed
and cannot be patched.

111
00:06:55,390 --> 00:06:57,450
However, any Android application

112
00:06:57,450 --> 00:07:00,780
can bring as signed by
Qualcomm skeleton library,

113
00:07:00,780 --> 00:07:04,393
in its assets and then
open a remote session.

114
00:07:05,330 --> 00:07:08,990
The library will be
successfully loaded onto the DSP

115
00:07:08,990 --> 00:07:11,063
because it's signature is correct.

116
00:07:12,260 --> 00:07:15,210
The fact that there is no version check

117
00:07:15,210 --> 00:07:17,310
of loading skeleton libraries,

118
00:07:17,310 --> 00:07:21,431
opens the possibility to
run a very old skeleton lib,

119
00:07:21,431 --> 00:07:23,700
with known 1-day
vulnerabilities on the DSP.

120
00:07:24,810 --> 00:07:28,720
Even if the patched skeleton
library already exists

121
00:07:28,720 --> 00:07:29,590
on the device,

122
00:07:29,590 --> 00:07:33,023
it's possible to go the old
version of this library.

123
00:07:34,200 --> 00:07:39,200
Any DSP code fix can simply
be bypassed by an attacker.

124
00:07:41,040 --> 00:07:43,627
Due to the lack of list
of skeleton libraries

125
00:07:43,627 --> 00:07:45,420
permitted to the device,

126
00:07:45,420 --> 00:07:50,420
it's possible to run a library
intended for one device,

127
00:07:50,440 --> 00:07:54,070
for example, China's
Xiaomi on any other device,

128
00:07:54,070 --> 00:07:55,120
for example, Samsung.

129
00:07:56,060 --> 00:07:58,710
This means that a
vulnerability discover it,

130
00:07:58,710 --> 00:08:01,740
in one of OEMs libraries,

131
00:08:01,740 --> 00:08:04,943
compromises all Snapdragon-based
Android devices.

132
00:08:07,320 --> 00:08:09,970
Okay, the major goal of the research

133
00:08:09,970 --> 00:08:13,870
was to find the way to execute
custom code on the DSP.

134
00:08:13,870 --> 00:08:16,590
Bypassing Qualcomm signature.

135
00:08:16,590 --> 00:08:17,423
To do this,

136
00:08:17,423 --> 00:08:20,460
we had to discover and
explore the vulnerability

137
00:08:20,460 --> 00:08:22,523
in a DSP running library.

138
00:08:25,940 --> 00:08:28,777
DSP libraries are
proprietary Hexagon ELFs.

139
00:08:30,160 --> 00:08:33,160
The easiest way to instrument
the Hexagon executable

140
00:08:33,160 --> 00:08:35,973
is to use the open-source
quick emulate for QEMU.

141
00:08:37,250 --> 00:08:40,816
Hexagon instruction set
support was editing the QEMU

142
00:08:40,816 --> 00:08:42,363
only at the end of 2019,

143
00:08:43,420 --> 00:08:45,190
and to hit a lot of box

144
00:08:45,190 --> 00:08:48,290
to be able to run a real DSP libraries

145
00:08:48,290 --> 00:08:50,473
in the user mode of xen emulator.

146
00:08:52,340 --> 00:08:55,140
To fuzz libs on you're Boon to PC,

147
00:08:55,140 --> 00:08:57,710
we used American Fuzzy Lop AFL,

148
00:08:57,710 --> 00:09:00,413
in combination with QEMU.

149
00:09:00,413 --> 00:09:03,760
A skeleton library is primarily a library,

150
00:09:03,760 --> 00:09:06,769
and we had to prepare a simple program,

151
00:09:06,769 --> 00:09:09,700
skel loader that loads and wagziwa,

152
00:09:11,270 --> 00:09:13,320
more or were, most skeleton libraries,

153
00:09:13,320 --> 00:09:17,112
why they use these B frame
mod and system calls.

154
00:09:17,112 --> 00:09:20,780
Our simple program could
not handle such requests.

155
00:09:20,780 --> 00:09:22,633
Therefore, we had to load the QuRT OS,

156
00:09:23,630 --> 00:09:27,363
on the MOA to before its
execution of the rest codes.

157
00:09:28,290 --> 00:09:31,900
The easiest way to do so is
not to use the real QuRT OS,

158
00:09:31,900 --> 00:09:35,670
but it's light version, around EOS PBN.

159
00:09:35,670 --> 00:09:40,270
Adopted by Qualcomm for its
execution on a Hexagon simulator

160
00:09:40,270 --> 00:09:42,233
and included in the Hexagon SDK.

161
00:09:44,100 --> 00:09:48,477
That's it, the AFL promoter
is the content of the data,

162
00:09:48,477 --> 00:09:53,014
the data file, and through
those execution of runelf.pbn

163
00:09:53,014 --> 00:09:53,847
on the emulator.

164
00:09:54,845 --> 00:09:59,060
QEMU returns a code
coverage metrics to the AFL,

165
00:09:59,060 --> 00:10:00,943
after execution of the test case.

166
00:10:03,070 --> 00:10:04,800
On this line, you can see the data format

167
00:10:04,800 --> 00:10:08,438
that we used to fuzz skeleton libraries.

168
00:10:08,438 --> 00:10:10,960
The fuzzed word is the second argument,

169
00:10:10,960 --> 00:10:13,947
of the remote handle invoke function.

170
00:10:13,947 --> 00:10:17,340
The index of the invoked
method, number of input,

171
00:10:17,340 --> 00:10:20,720
and number of output
arguments are encoded here.

172
00:10:21,910 --> 00:10:26,020
Next several words would take
as the size of arguments,

173
00:10:26,020 --> 00:10:30,217
and then we expect to see
a value of input arguments.

174
00:10:32,890 --> 00:10:35,683
We were surprised by the fuzzing results.

175
00:10:35,683 --> 00:10:38,470
Crashes were found in all DSP libraries,

176
00:10:38,470 --> 00:10:40,800
that we choose to fuzz.

177
00:10:40,800 --> 00:10:44,040
Besides, most issues
were discovered exactly

178
00:10:44,040 --> 00:10:45,960
in skeleton libraries.

179
00:10:45,960 --> 00:10:50,643
This means that Hexagon SDK
produces the vulnerable code.

180
00:10:54,160 --> 00:10:58,520
Hexagon SDK automatically
generate stub and skel code,

181
00:10:58,520 --> 00:11:02,520
for marshaling and unmarshaling
of function arguments.

182
00:11:02,520 --> 00:11:05,033
Let's take a look at an
example of such code.

183
00:11:07,280 --> 00:11:10,300
Stub and skel code based on,

184
00:11:10,300 --> 00:11:13,270
Interface Definition Model, IDL models

185
00:11:13,270 --> 00:11:14,693
prepared by the developer.

186
00:11:15,590 --> 00:11:19,085
Here you can see an example
of the IDL declaration

187
00:11:19,085 --> 00:11:22,865
of two functions in the
neural network library,

188
00:11:22,865 --> 00:11:27,865
Hexagon NN, a vulnerable code
will be generated for both.

189
00:11:31,180 --> 00:11:34,470
Hexagon NN, SNPPrint function,

190
00:11:34,470 --> 00:11:38,417
passes and input-output
buffer argument to the DSP.

191
00:11:39,400 --> 00:11:40,520
In the stub code,

192
00:11:40,520 --> 00:11:45,430
there's this buffer will be
split into two separate buffers,

193
00:11:45,430 --> 00:11:47,163
the input and the output,

194
00:11:48,720 --> 00:11:51,550
the value of the input buffer links,

195
00:11:51,550 --> 00:11:55,853
will also be duplicated and
therefore ratio one to one.

196
00:11:59,297 --> 00:12:00,270
The skel function

197
00:12:00,270 --> 00:12:03,410
copies the input buffer
to the output buffer

198
00:12:03,410 --> 00:12:06,780
before calling an object and a function,

199
00:12:06,780 --> 00:12:09,270
the size of data to be copied,

200
00:12:09,270 --> 00:12:13,200
is one of the transmitted buffer lengths.

201
00:12:13,200 --> 00:12:15,480
An attacker controls this value int.

202
00:12:15,480 --> 00:12:18,800
All verification checks
can simply be bypassed

203
00:12:18,800 --> 00:12:21,493
by using a negative input buffer length.

204
00:12:23,420 --> 00:12:26,620
Typecasting to the signed int

205
00:12:26,620 --> 00:12:29,460
type on chicken a buffer boundaries,

206
00:12:29,460 --> 00:12:32,273
is a bach leading to heap overflow.

207
00:12:34,340 --> 00:12:39,340
To summarize, the
automatically generated code,

208
00:12:39,520 --> 00:12:43,860
inject vulnerabilities into
the libraries of Qualcomm OEMs

209
00:12:43,860 --> 00:12:47,893
and all assets of party developers
who use the Hexagon SDK.

210
00:12:49,450 --> 00:12:52,510
Dozens of SDK skeleton
libraries pre-installed

211
00:12:52,510 --> 00:12:55,020
on Android smartphones are vulnerable

212
00:12:55,020 --> 00:12:57,350
due to serious bach in the SDK.

213
00:13:00,210 --> 00:13:02,160
So, we discovered many vulnerabilities.

214
00:13:03,040 --> 00:13:04,463
Let's explore one of them.

215
00:13:07,008 --> 00:13:10,420
Libfastcdvadsp skel.so library,

216
00:13:10,420 --> 00:13:13,210
can be found on most Android devices.

217
00:13:13,210 --> 00:13:15,410
In this example, I use the lib extracted

218
00:13:15,410 --> 00:13:19,973
from the Sony Xperia XZ Premium device,

219
00:13:20,880 --> 00:13:23,350
and malicious Android
application can cause,

220
00:13:23,350 --> 00:13:26,140
this lib to crash by
providing crafted arguments

221
00:13:26,140 --> 00:13:28,953
to the remote handle invoke function.

222
00:13:32,040 --> 00:13:35,993
The 3F method allows us to
read and write everything

223
00:13:35,993 --> 00:13:40,323
that we want within the other
space of the DSP processor.

224
00:13:41,160 --> 00:13:45,170
It's enough, to implement
and export and execute

225
00:13:45,170 --> 00:13:48,373
an unsigned payload in the
user protection domain.

226
00:13:51,050 --> 00:13:52,870
Okay, we go to code execution.

227
00:13:52,870 --> 00:13:55,720
What can we do with it?

228
00:13:55,720 --> 00:13:59,790
We can crush the DSP. We
can hide malicious code.

229
00:13:59,790 --> 00:14:03,860
We can try to access
cameras, sensors and more.

230
00:14:03,860 --> 00:14:07,863
Besides, now we can
communicate these QuRT drivers.

231
00:14:10,520 --> 00:14:13,217
The next step of the research is to attack

232
00:14:13,217 --> 00:14:18,217
the QuRT privileged domains
from the user protection domain.

233
00:14:18,700 --> 00:14:22,690
And QuRT drivers are the
entry points for this.

234
00:14:27,338 --> 00:14:30,830
QuRT OS implements it's
open device driver model,

235
00:14:30,830 --> 00:14:34,731
named QuRT driver invocation, QDI.

236
00:14:34,731 --> 00:14:35,814
Linux Power6,

237
00:14:38,634 --> 00:14:40,760
and QDI device drivers,

238
00:14:40,760 --> 00:14:44,480
operate these high
privileges as any user code.

239
00:14:45,468 --> 00:14:50,000
Dozens of QDI drivers can
be found in QuRT vinyl.

240
00:14:51,957 --> 00:14:56,750
Lipqurt.a library which
is part of Hexagon SDK,

241
00:14:56,750 --> 00:14:59,903
contains the QuRT infrastructure.

242
00:15:00,850 --> 00:15:05,377
FastRPC shell is linked
statically this slimer.

243
00:15:07,880 --> 00:15:10,911
QDI provides a simple
driver invocation API,

244
00:15:10,911 --> 00:15:13,710
where the ability to
access a device driver,

245
00:15:13,710 --> 00:15:16,197
based only on the driver name.

246
00:15:17,140 --> 00:15:20,440
Actually, only QuRT QDI
handle and walk macro,

247
00:15:20,440 --> 00:15:23,890
is the necessary user visible API.

248
00:15:23,890 --> 00:15:27,713
Is responsible for all
generic driver operations.

249
00:15:28,971 --> 00:15:33,233
The QuRT QDI open is just a
special case of this month.

250
00:15:36,825 --> 00:15:39,640
To fuzz QuRT drivers on you're boon to PC,

251
00:15:39,640 --> 00:15:43,167
we use the same combination
of Hexagon QEMU and AFL,

252
00:15:44,230 --> 00:15:46,993
as for fuzzing both
user mode DSP libraries.

253
00:15:48,710 --> 00:15:51,670
QDI drivers were not included by Qualcomm

254
00:15:51,670 --> 00:15:55,111
in their runelf.pbn version of QuRT,

255
00:15:55,111 --> 00:15:59,111
therefore we had to patch,
the, around ELF file.

256
00:16:00,760 --> 00:16:02,100
What did we do?

257
00:16:02,100 --> 00:16:07,100
We appended programs segments
of QuRT ELF from a real device

258
00:16:08,190 --> 00:16:12,960
and a directed malloc and
memcpy kernel functions,

259
00:16:12,960 --> 00:16:16,893
used by QDI drivers to their
user mode implementation.

260
00:16:18,270 --> 00:16:21,910
Our simple QDI exec program
is responsible for calling

261
00:16:21,910 --> 00:16:24,953
a driver invocation
function by its address.

262
00:16:27,746 --> 00:16:30,613
First of all, any failure QDI drivers,

263
00:16:31,770 --> 00:16:35,000
can be used to reboot the mobile device.

264
00:16:35,000 --> 00:16:38,870
For example, each of
the lines of this code,

265
00:16:38,870 --> 00:16:40,520
fuzz code DSP panic,

266
00:16:40,520 --> 00:16:44,263
and, can be used for a denial
of service attack on a device.

267
00:16:45,560 --> 00:16:47,290
For research purposes,

268
00:16:47,290 --> 00:16:50,336
we exploited one of
discovered vulnerabilities,

269
00:16:50,336 --> 00:16:54,700
in drilling the QDI
driver, along is the user,

270
00:16:54,700 --> 00:16:59,360
PG export, it allows us
to run a custom code,

271
00:16:59,360 --> 00:17:03,583
in the context of the
guest OS protection domain.

272
00:17:05,500 --> 00:17:08,250
Okay, now we'll show you a simple demo,

273
00:17:08,250 --> 00:17:12,263
to prove the full stake, attack chain.

274
00:17:13,490 --> 00:17:17,440
The payload between a DSP and kernel data,

275
00:17:17,440 --> 00:17:20,640
in accessible form application processor.

276
00:17:20,640 --> 00:17:22,663
The device is the Pixel.

277
00:17:35,730 --> 00:17:40,730
I'm using the ADB shell, to run
to the performance the tech.

278
00:17:42,576 --> 00:17:46,393
An Android application
can run this tool as well.

279
00:17:47,270 --> 00:17:50,710
The first stage of the attack
is to to execute a code

280
00:17:50,710 --> 00:17:53,133
in the context of user PD,

281
00:17:54,240 --> 00:17:59,137
then the user payload triggers
the guest OS code execution,

282
00:18:00,970 --> 00:18:04,880
vulnerability, and then
I dump sensitive data

283
00:18:04,880 --> 00:18:09,570
such as the QuRT data segment
and then controls the phone.

284
00:18:09,570 --> 00:18:11,013
For example, I reboot it.

285
00:18:18,480 --> 00:18:19,313
Okay.

286
00:18:23,333 --> 00:18:24,960
Instead of a conclusion,

287
00:18:24,960 --> 00:18:29,920
I just want to know that Hexagon
aDSP and cDSP subsystems,

288
00:18:29,920 --> 00:18:33,830
are very promising areas
for security research.

289
00:18:33,830 --> 00:18:37,360
The DSP is accessible
for Android applications,

290
00:18:37,360 --> 00:18:41,120
has access to interesting
data for an attacker.

291
00:18:41,120 --> 00:18:43,423
And has many security issues.

292
00:18:45,550 --> 00:18:47,950
Thank you for your attention.

