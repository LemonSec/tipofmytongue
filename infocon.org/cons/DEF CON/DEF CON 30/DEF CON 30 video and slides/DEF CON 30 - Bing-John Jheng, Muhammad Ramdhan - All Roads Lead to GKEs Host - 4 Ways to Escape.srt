1
00:00:00,480 --> 00:00:02,580
- Welcome to the 12:00 talk

2
00:00:02,580 --> 00:00:05,820
on All Roads Lead to GKE.

3
00:00:05,820 --> 00:00:07,800
Without any ado, Billy,
are you starting off?

4
00:00:07,800 --> 00:00:08,633
- [Billy] Yes.

5
00:00:08,633 --> 00:00:09,466
- All right.

6
00:00:10,309 --> 00:00:14,550
(audience applauding)

7
00:00:14,550 --> 00:00:15,600
- Hi.

8
00:00:15,600 --> 00:00:18,750
Hi, I'm Billy, and thanks for coming.

9
00:00:18,750 --> 00:00:20,403
Here is our title.

10
00:00:21,300 --> 00:00:25,470
All roads leads to the GKE,
Google Kubernetes Engine's host.

11
00:00:25,470 --> 00:00:28,607
Host refers to the Google GKE node.

12
00:00:28,607 --> 00:00:30,360
4 ways to escape.

13
00:00:30,360 --> 00:00:33,600
We will use four different
Linux kernel vulnerability,

14
00:00:33,600 --> 00:00:36,300
including 1-day and 0-day we found,

15
00:00:36,300 --> 00:00:41,300
to escape from the container
to take over the node in GKE.

16
00:00:41,310 --> 00:00:44,610
Today's presentation will
be presented by me, Billy,

17
00:00:44,610 --> 00:00:46,173
and my partner, Ramdhan.

18
00:00:50,340 --> 00:00:54,240
Before going to the topic,
let's introduce ourself.

19
00:00:54,240 --> 00:00:58,440
My name is Billy, a security
researcher in the STAR Labs.

20
00:00:58,440 --> 00:01:02,133
My partner, Ramdhan, also
work in the STAR Labs.

21
00:01:03,000 --> 00:01:05,820
We usually work together to do research

22
00:01:05,820 --> 00:01:08,490
on the Linux kernel and Hypervisor,

23
00:01:08,490 --> 00:01:11,250
like Virtualbox, QEMU, Parallels,

24
00:01:11,250 --> 00:01:13,800
for bug bounty and exploitation.

25
00:01:13,800 --> 00:01:18,547
We successfully pwned Ubuntu
in Pwn2own 2021 and 2022,

26
00:01:19,993 --> 00:01:23,160
and Virtualbox in Pwn2own 2022.

27
00:01:23,160 --> 00:01:27,417
We also identified various
vulnerability in (indistinct),

28
00:01:28,380 --> 00:01:31,889
like CVE-2021-3491.

29
00:01:31,889 --> 00:01:35,845
It is a Linux kernel privilege
escalation vulnerability

30
00:01:35,845 --> 00:01:38,610
in the io_uring sub system.

31
00:01:38,610 --> 00:01:42,510
We also compiled with CVE-2021...

32
00:01:42,510 --> 00:01:47,510
with CVE-2021-2250, we achieved VM escape

33
00:01:48,270 --> 00:01:50,370
from the Virtualbox.

34
00:01:50,370 --> 00:01:53,400
We also achieved the Parallels VM escape

35
00:01:53,400 --> 00:01:57,753
from the CVE-2021-34854.

36
00:01:57,753 --> 00:02:00,600
This CVE shows we have some gulp

37
00:02:00,600 --> 00:02:02,943
in the Linux kernel and Hypervisor.

38
00:02:05,130 --> 00:02:07,260
Let's start today's outline.

39
00:02:07,260 --> 00:02:10,080
We will give you some
background information,

40
00:02:10,080 --> 00:02:15,080
introduce a bit about what is
Google Container-Optimized OS,

41
00:02:15,690 --> 00:02:20,690
and explain kCTF VRP Challenge,
a Google bug bounty program,

42
00:02:21,120 --> 00:02:26,040
programming focus on the
container escape exploitation.

43
00:02:26,040 --> 00:02:28,890
And then we will start show our detail

44
00:02:28,890 --> 00:02:32,040
on our four submission, then...

45
00:02:32,040 --> 00:02:36,000
And it's called (indistinct)
we used to transform

46
00:02:36,000 --> 00:02:40,140
a limited primitive to
escape from the container.

47
00:02:40,140 --> 00:02:42,663
And finally, through the conclusion.

48
00:02:45,300 --> 00:02:49,893
Google Container-Optimized
OS, basically, is a Linux OS,

49
00:02:49,893 --> 00:02:53,340
but optimized for running
Docker containers,

50
00:02:53,340 --> 00:02:57,810
which is default node OS in
Google Kubernetes Engine.

51
00:02:57,810 --> 00:03:00,810
No package manager, unable to install

52
00:03:00,810 --> 00:03:05,130
third-party kernel module,
read-only root filesystem.

53
00:03:05,130 --> 00:03:10,110
Every time when input, it
always verifies filesystem

54
00:03:10,110 --> 00:03:12,210
checks out, to make sure the filesystem

55
00:03:12,210 --> 00:03:14,640
is not malformed or backdoor.

56
00:03:14,640 --> 00:03:16,860
Usually, the Linux kernel configure

57
00:03:16,860 --> 00:03:19,440
are stored in /etc/ folder.

58
00:03:19,440 --> 00:03:22,770
In the Google Container-Optimized OS,

59
00:03:22,770 --> 00:03:25,740
this folder is writable but stateless,

60
00:03:25,740 --> 00:03:28,140
which means every time it put,

61
00:03:28,140 --> 00:03:30,400
it will start from a clean slate.

62
00:03:30,400 --> 00:03:34,106
And configure its setup is long time,

63
00:03:34,106 --> 00:03:38,073
(indistinct) install
procedure backdoor is hard.

64
00:03:41,160 --> 00:03:43,920
If we want to escape from the container,

65
00:03:43,920 --> 00:03:45,930
there are some limits here.

66
00:03:45,930 --> 00:03:50,670
There are some optical when
we export or test fast and use

67
00:03:50,670 --> 00:03:54,540
some common export
technique in the container.

68
00:03:54,540 --> 00:03:59,540
It is a lone unprivileged
user to use ePBF,

69
00:04:00,090 --> 00:04:04,860
and not implement
Userfaultfd file system call.

70
00:04:04,860 --> 00:04:08,280
It is alone to access internal networking.

71
00:04:08,280 --> 00:04:12,510
So we are unable to access
Kubernetes API server.

72
00:04:12,510 --> 00:04:15,330
Also limited on the device node access,

73
00:04:15,330 --> 00:04:19,443
unable to spray tty_struct,
and unable to use fuse.

74
00:04:23,370 --> 00:04:26,700
Okay, there are some attack surface

75
00:04:26,700 --> 00:04:28,680
we can use in a container.

76
00:04:28,680 --> 00:04:32,010
First, we can create a new user namespace

77
00:04:32,010 --> 00:04:34,770
to explore more attack surface,

78
00:04:34,770 --> 00:04:39,090
like Cgroup, a Linux kernel
feature that limited account

79
00:04:39,090 --> 00:04:41,883
for an isolated resource usage,

80
00:04:43,050 --> 00:04:48,050
or Filesystem context
functionality, or packet sockets,

81
00:04:48,390 --> 00:04:51,513
or Traffic account control configuration.

82
00:04:54,360 --> 00:04:58,920
In io_uring, is a Linux
kernel system call interface

83
00:04:58,920 --> 00:05:01,680
for asynchronous I/O operations.

84
00:05:01,680 --> 00:05:04,620
And there are some CVE's
in this subsystem before,

85
00:05:04,620 --> 00:05:07,380
and it is reachable in our container.

86
00:05:07,380 --> 00:05:10,293
We see in this a great attack surface.

87
00:05:12,600 --> 00:05:15,770
Let's see what our kCTF VRP environment,

88
00:05:15,770 --> 00:05:18,330
environment architecture look like.

89
00:05:18,330 --> 00:05:23,100
Basically, is a GKE
cluster have multiple node.

90
00:05:23,100 --> 00:05:26,130
A node, you can see, it is a VM,

91
00:05:26,130 --> 00:05:28,710
and each node has multiple pod.

92
00:05:28,710 --> 00:05:31,440
A pod, you can see, is a container.

93
00:05:31,440 --> 00:05:35,640
In a pod, you will launch
a nsjail challenge.

94
00:05:35,640 --> 00:05:38,040
kCTF have two challenge.

95
00:05:38,040 --> 00:05:39,930
They are in different pods.

96
00:05:39,930 --> 00:05:42,390
Your goal is to get two flag.

97
00:05:42,390 --> 00:05:46,500
One flag is called KCTF flag,
it's placed on the same pod

98
00:05:46,500 --> 00:05:48,870
when you connect into the challenge,

99
00:05:48,870 --> 00:05:51,170
and this challenge will
give you (indistinct).

100
00:05:52,737 --> 00:05:55,160
And another flag is
called Full-Chain flag.

101
00:05:55,160 --> 00:05:57,303
It is placed on the other pod.

102
00:05:59,460 --> 00:06:01,830
The node OS and the Kubernetes version

103
00:06:01,830 --> 00:06:03,840
are upgraded automatically,

104
00:06:03,840 --> 00:06:05,280
but there is a time gap

105
00:06:05,280 --> 00:06:08,790
between the vulnerabilities and upgrade.

106
00:06:08,790 --> 00:06:13,790
So it is allowed to use
1-day vulnerability.

107
00:06:13,800 --> 00:06:16,710
And we introduced before,
all nodes are running

108
00:06:16,710 --> 00:06:19,770
on the Container-Optimized OS.

109
00:06:19,770 --> 00:06:21,660
Pod egress network access only.

110
00:06:21,660 --> 00:06:24,180
So you can download the exploit

111
00:06:24,180 --> 00:06:26,373
from the internet and launch.

112
00:06:29,010 --> 00:06:31,353
There are two test scenario.

113
00:06:32,970 --> 00:06:36,210
One is breaking out of the nsjail sandbox,

114
00:06:36,210 --> 00:06:38,227
and get a flag on the same pod.

115
00:06:42,660 --> 00:06:46,650
Another attack scenario
is to break the isolation

116
00:06:46,650 --> 00:06:49,838
that Kubernetes provides,
and access a flag

117
00:06:49,838 --> 00:06:53,730
from the other challenge, but
with the kernel vulnerability,

118
00:06:53,730 --> 00:06:56,910
we can literally escape privilege

119
00:06:56,910 --> 00:06:59,070
and take over the whole node.

120
00:06:59,070 --> 00:07:00,810
So you can get a whole flag

121
00:07:00,810 --> 00:07:02,943
from a single kernel vulnerability.

122
00:07:04,530 --> 00:07:08,850
And next, let's show our four submission,

123
00:07:08,850 --> 00:07:13,713
and let Ramdhan to show
the first two submission.

124
00:07:19,470 --> 00:07:22,543
- Hello everyone, I'm Ramdhan.

125
00:07:22,543 --> 00:07:25,023
I will talk about our first submission.

126
00:07:25,920 --> 00:07:30,300
Our first submission
is using CVE-2021-4154.

127
00:07:33,810 --> 00:07:37,263
This bug we used to
exploit kCTF container.

128
00:07:38,580 --> 00:07:40,320
This bug is used after feedback

129
00:07:40,320 --> 00:07:44,973
in cgroup1_parse_param function
in cgroup kernel subsystem.

130
00:07:47,580 --> 00:07:52,580
So basically, this bug is
caused by (indistinct) object

131
00:07:52,837 --> 00:07:55,710
in this function.

132
00:07:55,710 --> 00:07:59,250
There are source key
that always need value

133
00:07:59,250 --> 00:08:03,690
that has string type,
but before dispatch file,

134
00:08:03,690 --> 00:08:07,020
there's no check if the
value is string or not.

135
00:08:07,020 --> 00:08:11,493
So we can pass a value with another type.

136
00:08:12,930 --> 00:08:17,930
So using the fsconfig sys call,

137
00:08:18,120 --> 00:08:21,780
we pass our value with the file type.

138
00:08:21,780 --> 00:08:24,540
So we pass a file descriptor as a value.

139
00:08:24,540 --> 00:08:29,540
Then param->string will
contain file struct address.

140
00:08:29,790 --> 00:08:33,003
Then it will start in fc->source.

141
00:08:36,570 --> 00:08:41,160
We can reach this bug by
calling fsconfig's call,

142
00:08:41,160 --> 00:08:45,150
but by set the key as source,

143
00:08:45,150 --> 00:08:50,130
and we set the value
with the file descriptor

144
00:08:50,130 --> 00:08:51,603
using FSCONFIG_SET_FD.

145
00:08:53,520 --> 00:08:58,520
So the put fscontext will,

146
00:09:00,720 --> 00:09:02,250
if we cause the file descriptor,

147
00:09:02,250 --> 00:09:04,287
the put fscontext will (indistinct),

148
00:09:05,760 --> 00:09:08,790
and it will free the fc->source

149
00:09:08,790 --> 00:09:10,533
that contain the file struct,

150
00:09:11,430 --> 00:09:14,070
but the file descriptor that associated

151
00:09:14,070 --> 00:09:17,070
with the freed file struct
still exists in the process,

152
00:09:17,070 --> 00:09:21,063
so we have use-after-free
and in file struct object.

153
00:09:26,280 --> 00:09:27,500
And...

154
00:09:31,470 --> 00:09:36,470
So using this bug, we can
create a bunch fc_contexts

155
00:09:40,010 --> 00:09:42,570
pointing to the same struct file.

156
00:09:42,570 --> 00:09:47,570
So there are multiple fc->source

157
00:09:48,630 --> 00:09:50,070
pointing to the same struct file,

158
00:09:50,070 --> 00:09:55,070
so if we cause one of them,
we have use-after-free,

159
00:09:58,770 --> 00:10:03,770
and we can cause one
another to have double free.

160
00:10:10,110 --> 00:10:10,943
Okay.

161
00:10:12,180 --> 00:10:17,180
So to...

162
00:10:18,360 --> 00:10:23,360
Yes, we can free another fc_context

163
00:10:23,953 --> 00:10:25,503
that's associated with it.

164
00:10:28,662 --> 00:10:30,170
Okay.

165
00:10:30,170 --> 00:10:32,340
We can perform the double free

166
00:10:32,340 --> 00:10:37,057
because we have the
fc_context still pointed

167
00:10:38,280 --> 00:10:39,663
to the freed struct file.

168
00:10:49,294 --> 00:10:52,650
So, how to exploit this bug.

169
00:10:52,650 --> 00:10:56,010
We need to build our exploit strategy.

170
00:10:56,010 --> 00:10:57,780
In use-after-free scenario,

171
00:10:57,780 --> 00:11:00,060
usually we overwrite some object

172
00:11:00,060 --> 00:11:02,850
with another type of object,

173
00:11:02,850 --> 00:11:07,850
but we have another problem
exploiting this bug,

174
00:11:11,310 --> 00:11:13,440
because the file struct is...

175
00:11:13,440 --> 00:11:14,940
First problem is the file struct

176
00:11:14,940 --> 00:11:17,550
is allocated in their own slab cache.

177
00:11:17,550 --> 00:11:22,550
So we cannot overwrite
with another type of object

178
00:11:23,040 --> 00:11:24,480
in a common way.

179
00:11:24,480 --> 00:11:29,480
And the second problem, what
type of object that we can use

180
00:11:32,580 --> 00:11:35,797
to extend the limited
primitive of this bug.

181
00:11:39,870 --> 00:11:44,870
So I'll present you the
solution of the first problem.

182
00:11:55,050 --> 00:11:59,430
To overwrite some object
with another type of object

183
00:11:59,430 --> 00:12:01,800
that resides in different slab cache,

184
00:12:01,800 --> 00:12:06,390
we use the technique, called
cross cache technique.

185
00:12:06,390 --> 00:12:09,250
This is the common technique

186
00:12:10,844 --> 00:12:14,910
to exploit use-after-free in Linux kernel.

187
00:12:14,910 --> 00:12:18,837
So there's two type of
cross cache technique.

188
00:12:18,837 --> 00:12:22,637
The first is cross cache use-after-free,

189
00:12:22,637 --> 00:12:26,673
and the second one is
cross cache heap overflow.

190
00:12:30,809 --> 00:12:35,809
So in cross cache use-after-free,

191
00:12:38,897 --> 00:12:42,317
first, we make slab page
freed to buddy allocator.

192
00:12:45,510 --> 00:12:50,440
So first, we fill the whole
slab page with some object.

193
00:12:54,090 --> 00:12:57,270
So for example, there's slab of obj_A,

194
00:12:57,270 --> 00:13:00,660
so we allocate the all of obj_A

195
00:13:00,660 --> 00:13:02,223
to fill the whole slab page.

196
00:13:05,490 --> 00:13:07,260
Then we free them all.

197
00:13:07,260 --> 00:13:12,260
So the slab page will go to
the buddy or page allocator.

198
00:13:14,700 --> 00:13:18,630
Then we spray another type of object,

199
00:13:18,630 --> 00:13:22,920
and it will coming from
the page allocator.

200
00:13:22,920 --> 00:13:26,940
And now the old freed slab cache of obj_A,

201
00:13:26,940 --> 00:13:29,370
owned by obj_X slab cache.

202
00:13:29,370 --> 00:13:34,370
So using this technique, we
can solve the first problem,

203
00:13:35,670 --> 00:13:40,670
but I will present to
you another cross cache

204
00:13:41,050 --> 00:13:43,250
that's called the cross
cache heap overflow.

205
00:13:44,940 --> 00:13:49,940
In cross cache heap overflow,
we make target slab cache

206
00:13:49,980 --> 00:13:52,623
adjacent next to another slab cache,

207
00:13:53,550 --> 00:13:55,380
the object that we want.

208
00:13:55,380 --> 00:14:00,380
So for example, in the (indistinct) image,

209
00:14:00,390 --> 00:14:04,260
we can overwrite the obj_A from the obj_X,

210
00:14:04,260 --> 00:14:08,760
but they are in two different slab cache,

211
00:14:08,760 --> 00:14:11,500
but it requires the sprayable object

212
00:14:12,720 --> 00:14:14,723
for about the obj_X and obj_A,

213
00:14:15,900 --> 00:14:20,900
but don't expect it will be
reliable most of the time

214
00:14:23,100 --> 00:14:28,100
because we also need to
trigger the heap overflow

215
00:14:32,160 --> 00:14:33,510
multiple times.

216
00:14:33,510 --> 00:14:35,910
And we can also make it more reliable

217
00:14:35,910 --> 00:14:40,230
if we have the capability
to gain some information,

218
00:14:40,230 --> 00:14:43,713
if we already overwrite the object or not.

219
00:14:46,590 --> 00:14:50,430
So I already question
you the first problem,

220
00:14:50,430 --> 00:14:55,430
is that we can actually
overwrite the file struct

221
00:14:56,670 --> 00:14:59,130
in their own slab cache
with another of object

222
00:14:59,130 --> 00:15:00,600
using the cross cache.

223
00:15:00,600 --> 00:15:04,260
And for the second problem,
what type of object

224
00:15:04,260 --> 00:15:06,903
that we can use to extend
the limited primitive.

225
00:15:09,540 --> 00:15:13,950
So for the second problem, I asked,

226
00:15:13,950 --> 00:15:18,950
some of you already know,
this is the msg_msg object,

227
00:15:19,200 --> 00:15:20,450
and msg_msgseg.

228
00:15:22,410 --> 00:15:26,700
This is the crown object for
exploiting Linux kernel bugs.

229
00:15:26,700 --> 00:15:30,453
For the future, I will refer
to msg_msg as MSG object,

230
00:15:31,560 --> 00:15:34,670
and msg_msgseg as MSG seg object.

231
00:15:38,850 --> 00:15:43,850
So this is the properties of MSG object.

232
00:15:45,180 --> 00:15:48,937
So this is the object that already known

233
00:15:50,670 --> 00:15:52,620
for exploiting Linux kernel bug,

234
00:15:52,620 --> 00:15:57,120
because of especially the heap bugs,

235
00:15:57,120 --> 00:16:00,330
because of its flexibility, of its size,

236
00:16:00,330 --> 00:16:04,023
and this is the sprayable object.

237
00:16:06,090 --> 00:16:11,090
And there are the second
object, called the MSG seg.

238
00:16:12,330 --> 00:16:17,330
It's used to store extra message
if the total of the message

239
00:16:22,020 --> 00:16:27,020
followed by the header
with the size of hex 30.

240
00:16:27,660 --> 00:16:32,660
So if the total object of
the message is more than 4K,

241
00:16:33,473 --> 00:16:37,350
the MSG seg object will use,

242
00:16:37,350 --> 00:16:41,073
and it pointed by the next
pointer of the MSG object.

243
00:16:43,830 --> 00:16:48,830
So this is, the MSG
object is powerful object

244
00:16:49,110 --> 00:16:51,600
that can be used for
many things, for example,

245
00:16:51,600 --> 00:16:55,503
arbitrary write, arbitrary
free, arbitrary read.

246
00:16:56,730 --> 00:17:00,663
We will go deeper with some of this,

247
00:17:00,663 --> 00:17:05,663
and it's accessible via msgget()
for allocating MSG queue,

248
00:17:08,940 --> 00:17:13,940
and the msgsnd() function
to insert the message

249
00:17:14,400 --> 00:17:15,233
to the queue,

250
00:17:15,233 --> 00:17:18,963
and msgrcv() to receive
the message from the queue.

251
00:17:25,590 --> 00:17:27,080
And...

252
00:17:29,430 --> 00:17:32,180
So there is...

253
00:17:34,367 --> 00:17:36,073
To allocate the MSG, we
can using the msgget.

254
00:17:41,040 --> 00:17:42,210
This is the...

255
00:17:42,210 --> 00:17:43,350
In the next set image,

256
00:17:43,350 --> 00:17:47,940
there's a definition of
some functions for interface

257
00:17:47,940 --> 00:17:49,620
that we gonna use.

258
00:17:49,620 --> 00:17:54,620
So as you can see, there
are the msgp parameter

259
00:17:56,130 --> 00:17:58,380
in the function interface,

260
00:17:58,380 --> 00:18:02,640
but it's actually defined
as the msgbuf struct,

261
00:18:02,640 --> 00:18:07,640
and the msgtyp is used
for selection process

262
00:18:09,000 --> 00:18:11,823
when we receive a message from the queue.

263
00:18:13,170 --> 00:18:18,170
And the msgflg, there are some
useful flag that we can use,

264
00:18:19,500 --> 00:18:22,950
for example, the MSG_COPY.

265
00:18:22,950 --> 00:18:26,280
This flag is we can use if we
want to receive the message

266
00:18:26,280 --> 00:18:31,280
from the queue without
deleting them from the queue.

267
00:18:35,340 --> 00:18:39,297
So there's the image that shows

268
00:18:43,200 --> 00:18:48,200
how the message linked to the queue.

269
00:18:48,390 --> 00:18:51,423
For example, we allocate
the message queue,

270
00:18:53,370 --> 00:18:58,140
and then we send the
message with the mtype 1,

271
00:18:58,140 --> 00:19:03,140
and with the 4K bytes of message.

272
00:19:05,580 --> 00:19:10,580
We send to the queue, and
we have the first message

273
00:19:12,480 --> 00:19:13,980
insert to the MSG queue.

274
00:19:13,980 --> 00:19:16,480
And there are the MSG seg because of

275
00:19:17,550 --> 00:19:22,550
the total of accounted
the size of MSG object

276
00:19:24,360 --> 00:19:26,463
with the header is more than 4K.

277
00:19:29,190 --> 00:19:34,190
And if we try to add another
MSG object with the mtype 2,

278
00:19:35,580 --> 00:19:40,580
and with the C of hex 200, it
will be linked to the queue.

279
00:19:42,960 --> 00:19:47,610
And if we want to receive the second MSG,

280
00:19:47,610 --> 00:19:51,990
we can use the MSG_EXCEPT
with the mtype 1.

281
00:19:51,990 --> 00:19:56,990
It will share the message
that doesn't have mtype 1.

282
00:19:57,030 --> 00:20:02,030
So the second message will receive

283
00:20:03,060 --> 00:20:04,413
and print to the terminal.

284
00:20:11,370 --> 00:20:15,390
So I'm gonna explain the
tricks that we can use

285
00:20:15,390 --> 00:20:16,803
using the MSG object.

286
00:20:17,730 --> 00:20:22,730
So, suppose using the double
free bug we have before

287
00:20:24,404 --> 00:20:28,623
in our first submission CVE,

288
00:20:29,910 --> 00:20:34,777
we can convert this to
have use-after-free on MSG.

289
00:20:35,760 --> 00:20:39,930
And after we have use-after-free on MSG,

290
00:20:39,930 --> 00:20:43,443
we overwrite them using
the MSG seg object.

291
00:20:47,460 --> 00:20:51,540
So the first trick is we
can use the MSG object

292
00:20:51,540 --> 00:20:54,870
is have out of bounds read.

293
00:20:54,870 --> 00:20:57,873
We can overwrite the MTS.

294
00:20:59,666 --> 00:21:01,920
MTS is message text size.

295
00:21:01,920 --> 00:21:06,920
If we operate this large value,
we can get the address leak

296
00:21:07,080 --> 00:21:11,763
from the out of bounds buffer via msgrcv.

297
00:21:16,470 --> 00:21:20,820
For the second tricks,
we can do arbitrary read.

298
00:21:20,820 --> 00:21:25,820
We can do this by
controlling the next pointer

299
00:21:26,760 --> 00:21:30,663
to the address of that we want to leak,

300
00:21:33,480 --> 00:21:37,800
because when we receive the message,

301
00:21:37,800 --> 00:21:42,800
and we set the message
text size to the 4K,

302
00:21:44,130 --> 00:21:48,523
it will search to the
next pointer, because the

303
00:21:50,760 --> 00:21:55,760
kernel assumes that this message
is have more than 4K size.

304
00:21:55,890 --> 00:21:59,490
It will go, it will copy
from the next pointer

305
00:21:59,490 --> 00:22:04,380
to the user when we do msgrcv call.

306
00:22:09,030 --> 00:22:14,030
And so the third trick, is we can do,

307
00:22:14,610 --> 00:22:17,760
by using this MSG object
is arbitrary free.

308
00:22:17,760 --> 00:22:19,740
We can do this if we have

309
00:22:19,740 --> 00:22:21,993
some specific kernel configuration.

310
00:22:24,150 --> 00:22:29,150
To get arbitrary free, we can
see if we receive the message,

311
00:22:30,560 --> 00:22:34,380
it will call do msgrcv function.

312
00:22:34,380 --> 00:22:38,457
And in the end, we have called free_msg,

313
00:22:38,457 --> 00:22:43,457
and then it will reach the
security_msg__msg_free.

314
00:22:43,830 --> 00:22:48,745
As you can see, it'll call
the kfree on msg->security.

315
00:22:48,745 --> 00:22:51,270
And if we can control the security field,

316
00:22:51,270 --> 00:22:53,823
we have arbitrary free,

317
00:22:56,070 --> 00:23:00,030
but before we reach the free_msg,

318
00:23:00,030 --> 00:23:04,590
we encountered the list_del function,

319
00:23:04,590 --> 00:23:07,863
and need to take care
of next and prev value.

320
00:23:12,330 --> 00:23:16,517
We actually can control them
using the MSG seg object,

321
00:23:16,517 --> 00:23:21,517
but the MSG seg object cannot
control the first eight byte,

322
00:23:24,150 --> 00:23:26,193
the first eight byte.

323
00:23:27,450 --> 00:23:32,450
So if we reach the
list_del using the MSG seg,

324
00:23:40,950 --> 00:23:45,950
the kernel will crash,
because we cannot control

325
00:23:45,990 --> 00:23:49,143
the next pointer in the m_list.

326
00:23:51,030 --> 00:23:56,030
But we can bypass them if the kernel have

327
00:23:56,640 --> 00:23:58,953
the CONFIG_DEBUG_LIST enabled.

328
00:24:01,140 --> 00:24:06,140
So if we have this config enabled,

329
00:24:08,280 --> 00:24:10,653
it will call the list_del_entry_valid.

330
00:24:14,640 --> 00:24:17,700
We can easily make it to return false,

331
00:24:17,700 --> 00:24:22,700
and skip the list_del,
by set the prev value

332
00:24:26,580 --> 00:24:28,440
with the LIST_POISON2.

333
00:24:28,440 --> 00:24:32,313
This is some constant
defined in the kernel source.

334
00:24:33,390 --> 00:24:38,390
And fortunately, kCTF kernel
config have that field enabled.

335
00:24:38,520 --> 00:24:43,520
So we can use the security
and the config debugs enabled

336
00:24:44,370 --> 00:24:47,240
to have arbitrary free
using the MSG object.

337
00:24:50,790 --> 00:24:55,713
So to rewrap our three tricks,

338
00:24:56,970 --> 00:25:00,810
we can combine this toward the
kernel (indistinct) control.

339
00:25:00,810 --> 00:25:02,970
So for arbitrary free,

340
00:25:02,970 --> 00:25:07,347
we can free the pipe_buffer
object in kmalloc-1024 cache.

341
00:25:09,870 --> 00:25:13,083
This big buffer, we can
allocate using the pipes.

342
00:25:14,910 --> 00:25:19,910
So we use our first two tricks
to do out of bounds read

343
00:25:20,490 --> 00:25:22,870
and arbitrary read to leak

344
00:25:22,870 --> 00:25:25,620
the address of pipe_buffer in the heap.

345
00:25:25,620 --> 00:25:30,620
And we read the ops
pointer in the pipe_buffer

346
00:25:32,190 --> 00:25:34,773
to get the kernel text address.

347
00:25:36,630 --> 00:25:41,630
And by closing pipes and
controlling the ops field,

348
00:25:42,690 --> 00:25:47,013
we can control the kernel RIP pointer.

349
00:25:49,967 --> 00:25:52,877
So we go back to our first submission

350
00:25:53,825 --> 00:25:58,740
when we have use-after-free
and in struct file,

351
00:25:58,740 --> 00:26:01,233
and we develop our exploit strategy.

352
00:26:02,280 --> 00:26:07,280
So with the first problem,
and the solution is

353
00:26:07,680 --> 00:26:09,570
we can overwrite the struct file

354
00:26:09,570 --> 00:26:11,163
with another type of object.

355
00:26:12,450 --> 00:26:14,880
We overwrite them using the MSG object,

356
00:26:14,880 --> 00:26:16,413
using cross cache technique.

357
00:26:17,280 --> 00:26:21,583
And we free one of fc_context

358
00:26:21,583 --> 00:26:24,200
is still pointed to the MSG object.

359
00:26:24,200 --> 00:26:26,930
So we have use-after-free
on the MSG object.

360
00:26:29,130 --> 00:26:33,030
So we can reallocate them
using the MSG seg object.

361
00:26:33,030 --> 00:26:38,030
So we can affect the MSG object
using the MSG seg object.

362
00:26:38,730 --> 00:26:43,630
Then, using this
condition, we can perform,

363
00:26:44,520 --> 00:26:49,423
like our two tricks before,

364
00:26:49,423 --> 00:26:51,323
out of bounds read and arbitrary read.

365
00:26:53,160 --> 00:26:58,160
So first, we need to link
the address of pipe_buffer

366
00:26:58,392 --> 00:27:00,270
and kmalloc-1024.

367
00:27:00,270 --> 00:27:05,270
So we need another of
MSG object that adjacent

368
00:27:05,850 --> 00:27:10,850
or near from the MSG seg object.

369
00:27:12,270 --> 00:27:17,270
We allocate another MSG
object in kmalloc-1024,

370
00:27:18,390 --> 00:27:23,390
and the adjacent MSG
will have next pointer

371
00:27:23,610 --> 00:27:26,460
pointed to kmalloc-1024, and
we can do out of bounds read

372
00:27:28,890 --> 00:27:32,040
and link the address of kmalloc-1024.

373
00:27:34,890 --> 00:27:38,280
After we have the address of kmalloc-1024,

374
00:27:38,280 --> 00:27:43,280
we free the MSG that we
talked before, the address,

375
00:27:46,620 --> 00:27:50,550
the MSC that allocated
to the kmalloc-1024.

376
00:27:50,550 --> 00:27:55,173
We allocate the spray,
the pipe_buffer, the MSG,

377
00:28:00,227 --> 00:28:05,070
and the kmalloc-1024 will
replace it by the pipe_buffer.

378
00:28:05,070 --> 00:28:08,160
So from the address, like before,

379
00:28:08,160 --> 00:28:09,963
from the out of bounds read,

380
00:28:09,963 --> 00:28:13,233
we know the location of the pipe_buffer.

381
00:28:14,550 --> 00:28:18,260
Then we perform the arbitrary
read on the pipe_buffer

382
00:28:19,710 --> 00:28:22,150
to know the value of the ops pointer

383
00:28:23,910 --> 00:28:26,463
to get the kernel text address.

384
00:28:29,100 --> 00:28:32,250
And then we do arbitrary free,

385
00:28:32,250 --> 00:28:36,810
using our arbitrary free tricks, to...

386
00:28:36,810 --> 00:28:40,543
We control the security
pointed to the pipe_buffer.

387
00:28:41,760 --> 00:28:46,320
And we know, now we have
use-after-free on a pipe_buffer.

388
00:28:46,320 --> 00:28:51,320
So we just reallocate them
with the MSG seg object.

389
00:28:51,540 --> 00:28:53,820
We have fake pipe_buffer and control over

390
00:28:53,820 --> 00:28:58,820
the pipe_buffer content, and
we cause the pipe_buffer,

391
00:29:00,600 --> 00:29:03,960
it will reach the
pipe_buffer_release function

392
00:29:03,960 --> 00:29:08,650
with our fake pipe_buffer,
and we have kernel control,

393
00:29:10,350 --> 00:29:12,357
control kernel RIP pointer.

394
00:29:14,686 --> 00:29:17,670
So after we have the kernel RIP pointer,

395
00:29:17,670 --> 00:29:20,100
we need to convert this to rop chain.

396
00:29:20,100 --> 00:29:24,180
We can easily find the stack pivot gadget

397
00:29:24,180 --> 00:29:27,723
to convert this to rop chain execution.

398
00:29:31,170 --> 00:29:34,140
Using the commit_creds
and prepare_kernel_creds,

399
00:29:34,140 --> 00:29:38,370
we can install the root
credential to the current process.

400
00:29:38,370 --> 00:29:42,183
Before our rop chain is execute,

401
00:29:43,200 --> 00:29:45,840
we have prepared the child process.

402
00:29:45,840 --> 00:29:48,320
This child process will...

403
00:29:49,380 --> 00:29:52,860
That's why I look that
if we already got root.

404
00:29:52,860 --> 00:29:54,813
It will break if we already got root.

405
00:29:57,750 --> 00:30:00,960
And then after we installed the kernel,

406
00:30:00,960 --> 00:30:02,340
the root credentials,

407
00:30:02,340 --> 00:30:05,373
we copy the credentials
to the child process.

408
00:30:08,970 --> 00:30:13,187
And we switch the namespace
of pid 1 to the init process

409
00:30:16,890 --> 00:30:20,793
using the switch_task_namespaces function.

410
00:30:22,530 --> 00:30:25,083
We call this using our rop chain,

411
00:30:25,950 --> 00:30:30,420
and the child process
that we prepared before

412
00:30:30,420 --> 00:30:31,890
will break the while loop,

413
00:30:31,890 --> 00:30:36,890
and it will set the namespace
to the namespace in pid 1.

414
00:30:38,370 --> 00:30:43,370
And we got the flag and
spawned the root shell.

415
00:30:54,900 --> 00:30:58,980
So in this demo, we connect
to the kCTF instance,

416
00:30:58,980 --> 00:31:03,150
we download, and we download
our exploit to the Internet

417
00:31:03,150 --> 00:31:04,500
and run the exploit.

418
00:31:04,500 --> 00:31:08,403
And kCTF flag will be printed
and it spawned the root shell.

419
00:31:11,958 --> 00:31:14,958
(audience applauds)

420
00:31:21,960 --> 00:31:25,980
So now I will talk about
our second submission.

421
00:31:25,980 --> 00:31:30,980
For the second submission,
we used CVE-2021-22600

422
00:31:34,230 --> 00:31:35,460
to exploit the (indistinct).

423
00:31:35,460 --> 00:31:38,670
This is double free bug in
packet_set_ring function

424
00:31:38,670 --> 00:31:40,833
in the af_packet kernel subsystem.

425
00:31:42,840 --> 00:31:46,920
So this is the snippet code
to trigger double free.

426
00:31:46,920 --> 00:31:50,310
I will explain this
block of code one by one.

427
00:31:50,310 --> 00:31:55,310
The root cause of this bug
happens when we switch version

428
00:31:57,031 --> 00:31:59,730
from the version three to two,

429
00:31:59,730 --> 00:32:02,939
but there's some field,

430
00:32:02,939 --> 00:32:05,940
because of the bug, there's
some field that didn't clear

431
00:32:05,940 --> 00:32:10,940
if we change the version three to two.

432
00:32:11,640 --> 00:32:14,223
So there's some old
step that didn't clear.

433
00:32:16,380 --> 00:32:21,093
So first, we create the AF_PACKET socket.

434
00:32:22,830 --> 00:32:26,420
We set the version to version
three by calling setsockopt.

435
00:32:28,963 --> 00:32:33,690
The tp_version variable, we'll
assign to the tp_version,

436
00:32:39,360 --> 00:32:44,360
and we call the setsockopt
with PACKET_RX_RING option.

437
00:32:47,850 --> 00:32:50,373
It will allocate a variable called pg_vec.

438
00:32:51,270 --> 00:32:54,930
As you can see, we can
control the size of allocation

439
00:32:54,930 --> 00:32:56,280
by setting the tp_block_nr.

440
00:33:00,540 --> 00:33:05,540
So the allocated pg_vec
is stored in pkbdq,

441
00:33:08,190 --> 00:33:11,010
but it overlap with the rx_owner_map

442
00:33:11,010 --> 00:33:14,313
because of the union data type.

443
00:33:19,470 --> 00:33:24,118
And then, from the third sets
of op, we free the pg_vec,

444
00:33:24,118 --> 00:33:29,118
but it didn't clear the pkbdq.

445
00:33:36,180 --> 00:33:39,360
Now, we changed the
version to the version two

446
00:33:39,360 --> 00:33:43,473
by performing setsockopt again.

447
00:33:45,210 --> 00:33:48,393
And when we call the
PACKET_RX_RING, rx_owner_map,

448
00:33:52,170 --> 00:33:55,980
that's actually coming
from the old set, is freed.

449
00:33:55,980 --> 00:34:00,630
So we freed the pg_vec of pkbdq twice.

450
00:34:00,630 --> 00:34:03,120
So the rx_owner_map is overlapped,

451
00:34:03,120 --> 00:34:05,730
because it's overlapped with the pkbdq,

452
00:34:05,730 --> 00:34:09,090
and it didn't clear
from the version three.

453
00:34:09,090 --> 00:34:11,100
And in the version two, it will be freed,

454
00:34:11,100 --> 00:34:13,563
so we have double free.

455
00:34:17,040 --> 00:34:19,670
So we can control the...

456
00:34:20,970 --> 00:34:23,370
In this block, we can control
the Target Chunk Size,

457
00:34:23,370 --> 00:34:26,283
and we can control when to double free.

458
00:34:32,880 --> 00:34:37,260
So we choose the timerfd
object as a sprayable object

459
00:34:37,260 --> 00:34:38,733
to fill the whole slab page.

460
00:34:42,570 --> 00:34:47,570
Using cross cache technique,
we free our timerfd and pg_vec

461
00:34:48,930 --> 00:34:51,333
to make slab page insert
to the page allocator.

462
00:34:54,311 --> 00:34:59,177
And then we spray with the MSG object.

463
00:35:00,870 --> 00:35:05,370
And using the double free,
we free the MSG object

464
00:35:05,370 --> 00:35:08,553
and overwrite them with
the MSG seg object.

465
00:35:09,390 --> 00:35:12,483
So we can control over the MSG object.

466
00:35:18,920 --> 00:35:23,250
In this condition, we have same case

467
00:35:23,250 --> 00:35:26,280
as the previous submission,

468
00:35:26,280 --> 00:35:30,213
our previous exploit that we
have use-after-free on MSG,

469
00:35:31,560 --> 00:35:34,590
and reallocate them using the MSG seg.

470
00:35:34,590 --> 00:35:36,630
We can just do the same technique.

471
00:35:36,630 --> 00:35:39,630
First, we do out of bounds
read to link the address

472
00:35:39,630 --> 00:35:43,560
of pipe_buffer on kmalloc-1024,

473
00:35:43,560 --> 00:35:47,373
and we do arbitrary read to
leak the kernel text address.

474
00:35:48,270 --> 00:35:51,330
Then, we do arbitrary
free on the pipe_buffer.

475
00:35:51,330 --> 00:35:52,320
We overwrite the,

476
00:35:52,320 --> 00:35:56,550
and then we overwrite the
pipe_buffer using the MSG seg.

477
00:35:56,550 --> 00:36:00,660
Then we can close the pipes
and control kernel RIP pointer,

478
00:36:00,660 --> 00:36:02,913
and we can escape the container.

479
00:36:04,980 --> 00:36:08,493
So this is the demo of
our second submission.

480
00:36:09,509 --> 00:36:14,509
We download, we connect the
kCTF and run our exploit.

481
00:36:16,380 --> 00:36:19,323
The kCTF will print it,
and spawn the root shell.

482
00:36:22,770 --> 00:36:25,770
(audience applauds)

483
00:36:27,810 --> 00:36:32,703
For the third and fourth
submission, my friend, Billy,

484
00:36:33,725 --> 00:36:37,710
will gonna explain the
third and fourth submission.

485
00:36:37,710 --> 00:36:38,543
Thank you.

486
00:36:46,290 --> 00:36:50,507
- So let me talk to the
next two submission.

487
00:36:50,507 --> 00:36:54,240
One is CVE-2022-0185.

488
00:36:54,240 --> 00:36:57,060
It's the first time we
used (indistinct) that,

489
00:36:57,060 --> 00:36:59,569
but unfortunately we
didn't properly report

490
00:36:59,569 --> 00:37:03,870
to the Linux security team
after the kCTF submission.

491
00:37:03,870 --> 00:37:06,720
There is a description of the CVE.

492
00:37:06,720 --> 00:37:09,060
We highlighted a keyword we care about,

493
00:37:09,060 --> 00:37:11,490
heap-based buffer overflow.

494
00:37:11,490 --> 00:37:15,900
Our ability is placed at the
Filesystem Context subsystem.

495
00:37:15,900 --> 00:37:19,200
And in case of unprivileged
user namespace,

496
00:37:19,200 --> 00:37:21,363
we can trigger the vulnerability.

497
00:37:23,880 --> 00:37:26,850
Briefly speaking, there
is an integer underflow

498
00:37:26,850 --> 00:37:28,920
when boundary checking.

499
00:37:28,920 --> 00:37:33,630
So if we let the size module
and the PAGE_SIZE - 2,

500
00:37:33,630 --> 00:37:35,253
it will cause integer underflow.

501
00:37:36,370 --> 00:37:39,690
And in the following four
place, will cause heap overflow

502
00:37:39,690 --> 00:37:41,877
on the legacy_data buffer.

503
00:37:44,220 --> 00:37:48,990
We carefully append data
in the legacy_data buffer,

504
00:37:48,990 --> 00:37:52,350
and cause heap overflow
with one little byte.

505
00:37:52,350 --> 00:37:55,053
We treat this vulnerability as off by one.

506
00:37:58,353 --> 00:38:01,203
From the core legacy_data
allocate, it is in a kmalloc-4K.

507
00:38:03,240 --> 00:38:06,810
So in summary, this
vulnerability is off by one

508
00:38:06,810 --> 00:38:08,943
on the kmalloc-4K cache.

509
00:38:10,980 --> 00:38:14,520
We use cross cache heap
overflow in order to override

510
00:38:14,520 --> 00:38:18,060
message structure,
spray legacy_data buffer

511
00:38:18,060 --> 00:38:20,610
with message structure at the same time,

512
00:38:20,610 --> 00:38:25,157
trigger off by one vulnerability
on every legacy_data,

513
00:38:25,157 --> 00:38:29,160
and we will have allowed
chance to overwrite message

514
00:38:29,160 --> 00:38:31,593
this next last byte with zero.

515
00:38:33,690 --> 00:38:37,710
If we are lucky to overwrite
message's next last byte

516
00:38:37,710 --> 00:38:40,920
with zero, we can make the two message

517
00:38:40,920 --> 00:38:42,840
point to the same next.

518
00:38:47,457 --> 00:38:50,628
Free through the one message queue,

519
00:38:50,628 --> 00:38:52,590
and another message queue will still point

520
00:38:52,590 --> 00:38:54,213
to the free chunk.

521
00:38:57,570 --> 00:39:00,960
And at this point we have
made a same situation

522
00:39:00,960 --> 00:39:02,940
as previous submission.

523
00:39:02,940 --> 00:39:06,690
Through overwriting pipe_buffer address,

524
00:39:06,690 --> 00:39:11,250
and do arbitrary read to
leak kernel text address.

525
00:39:11,250 --> 00:39:13,923
Next is to do arbitrary
free on pipe_buffer,

526
00:39:13,923 --> 00:39:16,980
and overwrite with the message segment,

527
00:39:16,980 --> 00:39:21,093
cause pipe to control kernel
RIP for a scale container.

528
00:39:22,560 --> 00:39:24,870
There is our demo.

529
00:39:24,870 --> 00:39:27,360
We've connected to a
challenge, and get the exploit

530
00:39:27,360 --> 00:39:29,790
from the Internet and launch,

531
00:39:29,790 --> 00:39:32,430
with the server (indistinct)
and take over the node.

532
00:39:40,437 --> 00:39:43,437
(audience applauds)

533
00:39:47,970 --> 00:39:51,720
There is a second (indistinct)
we use in the (indistinct),

534
00:39:51,720 --> 00:39:52,970
but this time we properly report

535
00:39:52,970 --> 00:39:57,180
to the Linux kernel
security and get a credit.

536
00:39:57,180 --> 00:39:59,700
Here is a description of the CVE.

537
00:39:59,700 --> 00:40:02,657
We also highlight the
keyword we care about.

538
00:40:02,657 --> 00:40:04,857
Heap is a key collaboration
in the io_uring.

539
00:40:05,910 --> 00:40:07,923
Heap is reachable in a container.

540
00:40:09,330 --> 00:40:12,330
This vulnerability is in
the io_uring when request

541
00:40:12,330 --> 00:40:15,453
a same message, or receive
messaging operation.

542
00:40:15,453 --> 00:40:19,740
Heap will grab fs_struct
even before do operation,

543
00:40:19,740 --> 00:40:24,049
but if io_uring context
has IORING_SETUP_IOPOLL,

544
00:40:24,049 --> 00:40:26,700
heap forgot to release fs_struct

545
00:40:26,700 --> 00:40:28,413
when finishing the operation.

546
00:40:30,690 --> 00:40:33,210
So we will keep increase the users,

547
00:40:33,210 --> 00:40:34,980
heap will cause integer overflow,

548
00:40:34,980 --> 00:40:37,863
and neither users reach zero again.

549
00:40:40,860 --> 00:40:43,190
When fs_struct reaches zero again,

550
00:40:43,190 --> 00:40:44,963
we use another io_uring
without IORING_SETUP_IOPOLL.

551
00:40:47,460 --> 00:40:50,850
It will free the fs_struct
after finishing the request,

552
00:40:50,850 --> 00:40:55,850
so we can have a free
fs_struct as current fs in use.

553
00:40:59,010 --> 00:41:01,680
The key point about
cross-cache is allocate a lot

554
00:41:01,680 --> 00:41:03,210
and free all at the same time.

555
00:41:03,210 --> 00:41:06,780
So we allocate a lot of
our structure and free all.

556
00:41:06,780 --> 00:41:11,780
Spray kmalloc-128 message
segment to reallocate

557
00:41:12,313 --> 00:41:14,493
current fs as message segment,

558
00:41:16,320 --> 00:41:19,560
and then free the current
fs again by io_uring

559
00:41:19,560 --> 00:41:24,560
and cross cache again with
kmalloc-64 message segment.

560
00:41:27,420 --> 00:41:29,730
Sadly, it's still message segment.

561
00:41:29,730 --> 00:41:31,920
So we use msgrecv system
call to leak the next message

562
00:41:35,197 --> 00:41:38,530
to get a kernel address in kmalloc-1024.

563
00:41:41,670 --> 00:41:44,700
Once we have leaked heap address,

564
00:41:44,700 --> 00:41:49,590
we can modify contents by
free and allocate again.

565
00:41:49,590 --> 00:41:53,580
We can use it to forge the
fs_struct to do arbitrary read

566
00:41:53,580 --> 00:41:55,923
in order to leak kernel address.

567
00:41:57,660 --> 00:42:01,440
With our fake fs_struct, we
are able to do arbitrary read

568
00:42:01,440 --> 00:42:05,073
by getcwd system call.

569
00:42:06,480 --> 00:42:08,430
After we get a kernel address,

570
00:42:08,430 --> 00:42:12,677
we can prepare ROP payload
and forge fs_struct again.

571
00:42:13,890 --> 00:42:15,750
By system call fchdir, we
can control the kernel RIP

572
00:42:17,900 --> 00:42:21,983
from fchdir, to set_fs_pwd,
to path_put, to dput,

573
00:42:24,204 --> 00:42:27,097
and in the end, to retain_dentry.

574
00:42:27,097 --> 00:42:31,230
In the retain_dentry, we
can control kernel RIP

575
00:42:31,230 --> 00:42:33,303
when call function pointer d_delete.

576
00:42:36,157 --> 00:42:37,230
There is a demo.

577
00:42:37,230 --> 00:42:41,280
Original demo video near
about 15 minute to finish it.

578
00:42:41,280 --> 00:42:43,380
So I speed it up for presentation.

579
00:42:43,380 --> 00:42:45,720
Again, connecting to the challenge

580
00:42:45,720 --> 00:42:48,243
and get exploit from
the Internet and launch.

581
00:42:53,250 --> 00:42:56,253
With a several (indistinct)
and take over the GKE node.

582
00:42:57,541 --> 00:43:00,541
(audience applauds)

583
00:43:04,830 --> 00:43:08,730
All vulnerability we use
have already fixed in GKE.

584
00:43:08,730 --> 00:43:10,561
You can tell a difference through the

585
00:43:10,561 --> 00:43:15,561
Google Security Bulletin
GCP-2022-002 and GCP-2022-016.

586
00:43:20,117 --> 00:43:22,890
We believe that with
cross-cache attack with message,

587
00:43:22,890 --> 00:43:26,760
we can transport a limited
primitive to arbitrary read,

588
00:43:26,760 --> 00:43:29,370
arbitrary free to a scale container.

589
00:43:29,370 --> 00:43:34,020
By less limiting, we can only
allocate size under 4096.

590
00:43:37,740 --> 00:43:41,393
In our last CVE, in our last submission,

591
00:43:41,393 --> 00:43:45,173
we are able to convert UAF
through the common situations

592
00:43:45,173 --> 00:43:49,530
and unprivileged suite
CVEs, but with some change,

593
00:43:49,530 --> 00:43:53,580
we still can escape container
by cross-cache and message.

594
00:43:53,580 --> 00:43:57,817
As a result, we are awarded
more than 100,000 bug bounty

595
00:43:57,817 --> 00:44:01,449
from the Google kCTF VRP program.

596
00:44:01,449 --> 00:44:04,449
(audience applauds)

597
00:44:07,223 --> 00:44:10,733
Thanks, Google, for holding
such a great VRP program

598
00:44:10,733 --> 00:44:14,397
to secure the kCTF and GKE infrastructure.

599
00:44:17,340 --> 00:44:18,440
Here is our reference.

600
00:44:20,910 --> 00:44:22,373
And thank you.

601
00:44:22,373 --> 00:44:25,373
(audience applauds)

