1
00:00:06,319 --> 00:00:08,080
memory manipulation is a technique that

2
00:00:08,080 --> 00:00:10,080
has been around for a long time it is

3
00:00:10,080 --> 00:00:11,920
used for both security and malicious

4
00:00:11,920 --> 00:00:13,759
purposes today i'm going to cover some

5
00:00:13,759 --> 00:00:15,200
of the malicious uses of memory

6
00:00:15,200 --> 00:00:17,279
manipulation of windows and how we can

7
00:00:17,279 --> 00:00:19,359
detect them

8
00:00:19,359 --> 00:00:20,880
my name is connor morley and i'm a

9
00:00:20,880 --> 00:00:23,359
senior researcher with secure formerly i

10
00:00:23,359 --> 00:00:25,039
was a threat hunter for four years and i

11
00:00:25,039 --> 00:00:26,720
published multiple white papers and

12
00:00:26,720 --> 00:00:29,840
detection pocs i have also presented a

13
00:00:29,840 --> 00:00:31,679
number of conferences on security

14
00:00:31,679 --> 00:00:34,239
related issues

15
00:00:34,239 --> 00:00:36,000
today we're going to be looking at what

16
00:00:36,000 --> 00:00:38,000
exactly a memory manipulation technique

17
00:00:38,000 --> 00:00:40,079
is then we'll be looking at inline

18
00:00:40,079 --> 00:00:42,320
hooking for exported functions then for

19
00:00:42,320 --> 00:00:44,320
private functions and the detection

20
00:00:44,320 --> 00:00:46,320
issues associated with that we'll then

21
00:00:46,320 --> 00:00:48,399
look at kernel level hooking on legacy

22
00:00:48,399 --> 00:00:51,440
windows systems heavens big hooking for

23
00:00:51,440 --> 00:00:54,960
wow 64 x86 processors and finally we'll

24
00:00:54,960 --> 00:00:57,120
look at vectored exception handlers and

25
00:00:57,120 --> 00:00:58,879
how they can be used for memory

26
00:00:58,879 --> 00:01:02,079
manipulation techniques

27
00:01:02,399 --> 00:01:05,040
first off what is a memory manipulation

28
00:01:05,040 --> 00:01:06,080
technique

29
00:01:06,080 --> 00:01:08,720
so memory manipulation revolves around

30
00:01:08,720 --> 00:01:10,560
live process memory so we're not

31
00:01:10,560 --> 00:01:12,960
focusing on files or file system

32
00:01:12,960 --> 00:01:15,439
manipulation we're only focusing on

33
00:01:15,439 --> 00:01:17,280
alterations made to memory that is

34
00:01:17,280 --> 00:01:20,000
currently running within a process

35
00:01:20,000 --> 00:01:22,000
changes to this can affect the control

36
00:01:22,000 --> 00:01:25,520
flow which allows for various uh

37
00:01:25,520 --> 00:01:29,360
activities to occur which can

38
00:01:29,360 --> 00:01:31,920
change or siphon off information it can

39
00:01:31,920 --> 00:01:34,240
prevent functions from occurring it can

40
00:01:34,240 --> 00:01:35,360
prevent

41
00:01:35,360 --> 00:01:37,520
checks on integrity

42
00:01:37,520 --> 00:01:41,840
it can equally execute malicious code

43
00:01:43,200 --> 00:01:45,439
changes over the past few years have

44
00:01:45,439 --> 00:01:47,680
seen that malicious actors have moved

45
00:01:47,680 --> 00:01:49,439
away from the idea of manipulating

46
00:01:49,439 --> 00:01:51,680
memory within victim processes and

47
00:01:51,680 --> 00:01:54,320
instead within uh to

48
00:01:54,320 --> 00:01:55,759
changing memory within their own

49
00:01:55,759 --> 00:01:57,840
processes the reason one of the primary

50
00:01:57,840 --> 00:02:00,640
reasons for this is that monitoring of

51
00:02:00,640 --> 00:02:02,640
uh alteration to memory of remote

52
00:02:02,640 --> 00:02:05,280
processes using virtual uh remote alike

53
00:02:05,280 --> 00:02:08,479
or anything like that um is quite is a

54
00:02:08,479 --> 00:02:10,239
long-standing security concern and there

55
00:02:10,239 --> 00:02:12,080
are security vendors are quite hot on

56
00:02:12,080 --> 00:02:14,080
detecting this and as such issues

57
00:02:14,080 --> 00:02:16,160
sparingly because it is so readily

58
00:02:16,160 --> 00:02:17,360
detected

59
00:02:17,360 --> 00:02:19,360
instead attackers started manipulating

60
00:02:19,360 --> 00:02:21,120
the memory of their own malicious agents

61
00:02:21,120 --> 00:02:23,840
or payloads in order to prevent

62
00:02:23,840 --> 00:02:26,400
detection the reason for this is that

63
00:02:26,400 --> 00:02:28,959
manipulation of a processor's own memory

64
00:02:28,959 --> 00:02:31,680
is not malicious in and of itself and a

65
00:02:31,680 --> 00:02:33,920
process has full access permissions to

66
00:02:33,920 --> 00:02:35,920
all of its own memory space which means

67
00:02:35,920 --> 00:02:37,120
you're not running into some of the

68
00:02:37,120 --> 00:02:38,560
areas that you encounter with remote

69
00:02:38,560 --> 00:02:40,160
processes

70
00:02:40,160 --> 00:02:41,840
this can be used for two primary

71
00:02:41,840 --> 00:02:44,720
purposes one to prevent monitoring or

72
00:02:44,720 --> 00:02:47,200
two in order to redirect the control

73
00:02:47,200 --> 00:02:49,519
flow now redirection is normally done in

74
00:02:49,519 --> 00:02:51,360
order to try and muddy the waters about

75
00:02:51,360 --> 00:02:53,280
what is happening so you can call one

76
00:02:53,280 --> 00:02:55,040
function which will then hook and call

77
00:02:55,040 --> 00:02:57,040
another and you can you can make it

78
00:02:57,040 --> 00:02:58,879
quite complicated which can make reverse

79
00:02:58,879 --> 00:03:01,440
engineering uh quite painful

80
00:03:01,440 --> 00:03:02,800
but we're going to be focusing on the

81
00:03:02,800 --> 00:03:04,800
preventing of monitoring by security

82
00:03:04,800 --> 00:03:06,319
vendors

83
00:03:06,319 --> 00:03:08,879
in this case

84
00:03:08,879 --> 00:03:11,599
to that end i will be covering four very

85
00:03:11,599 --> 00:03:14,400
specific uh areas now when as i go

86
00:03:14,400 --> 00:03:16,560
through these you'll you should notice

87
00:03:16,560 --> 00:03:18,159
that the techniques that i'm outlining

88
00:03:18,159 --> 00:03:21,760
can be used for other activities besides

89
00:03:21,760 --> 00:03:24,879
um just uh evasion techniques where the

90
00:03:24,879 --> 00:03:26,959
hooking has been implemented or the

91
00:03:26,959 --> 00:03:29,040
memory manipulation has been implemented

92
00:03:29,040 --> 00:03:32,799
other activities can occur with some

93
00:03:32,799 --> 00:03:35,440
development choices and some alterations

94
00:03:35,440 --> 00:03:37,040
but today i'm just going to be focusing

95
00:03:37,040 --> 00:03:39,200
on evasing detection using these

96
00:03:39,200 --> 00:03:41,519
malicious techniques to that end i'll be

97
00:03:41,519 --> 00:03:42,879
looking at

98
00:03:42,879 --> 00:03:46,720
etw event prevention using dlls or

99
00:03:46,720 --> 00:03:48,159
libraries

100
00:03:48,159 --> 00:03:49,760
library manipulation

101
00:03:49,760 --> 00:03:52,400
prevention of etw telemetry via kernel

102
00:03:52,400 --> 00:03:55,599
memory manipulation interception of x86

103
00:03:55,599 --> 00:03:58,400
or wire 64 cis calls in order to evade

104
00:03:58,400 --> 00:03:59,519
detection

105
00:03:59,519 --> 00:04:02,080
and finally vectored exception handler

106
00:04:02,080 --> 00:04:05,120
or veh specific bypasses that can be

107
00:04:05,120 --> 00:04:07,040
used in order to circumvent some

108
00:04:07,040 --> 00:04:10,400
security vendor techniques

109
00:04:10,799 --> 00:04:12,799
so first of all let's look at inline

110
00:04:12,799 --> 00:04:15,120
hooking for exported functions now first

111
00:04:15,120 --> 00:04:16,478
of all it's important to know what

112
00:04:16,478 --> 00:04:19,519
exactly i mean by hooking so hooking is

113
00:04:19,519 --> 00:04:23,520
the alteration of a functions and start

114
00:04:23,520 --> 00:04:25,759
op codes in order to perform a secondary

115
00:04:25,759 --> 00:04:29,199
action so imagine you called a function

116
00:04:29,199 --> 00:04:30,080
which

117
00:04:30,080 --> 00:04:32,160
uh let's say it creates a file

118
00:04:32,160 --> 00:04:33,440
now if you know where that function is

119
00:04:33,440 --> 00:04:35,759
located in memory if you

120
00:04:35,759 --> 00:04:38,639
change the first set of commands to

121
00:04:38,639 --> 00:04:41,520
instead jump to a different

122
00:04:41,520 --> 00:04:42,400
function

123
00:04:42,400 --> 00:04:44,400
that is what we would call hooking so

124
00:04:44,400 --> 00:04:46,160
what it means is that every time that

125
00:04:46,160 --> 00:04:49,280
function is called your hook or your

126
00:04:49,280 --> 00:04:51,199
alteration to the memory will cause

127
00:04:51,199 --> 00:04:53,040
something else to happen which changes

128
00:04:53,040 --> 00:04:55,520
the control flow of that function in

129
00:04:55,520 --> 00:04:57,759
order to perform a secondary action that

130
00:04:57,759 --> 00:05:00,160
you have implemented this is used by

131
00:05:00,160 --> 00:05:02,560
security vendors and malicious actors

132
00:05:02,560 --> 00:05:04,240
for security vendors this is normally

133
00:05:04,240 --> 00:05:06,720
done for telemetry collection so again

134
00:05:06,720 --> 00:05:08,240
let's say a security vendor has a

135
00:05:08,240 --> 00:05:09,759
particular function they want to monitor

136
00:05:09,759 --> 00:05:11,280
for because it's high value or it's

137
00:05:11,280 --> 00:05:12,960
something they know is used by

138
00:05:12,960 --> 00:05:14,400
particular

139
00:05:14,400 --> 00:05:17,520
attacker groups now by placing a hook on

140
00:05:17,520 --> 00:05:19,280
that particular function anytime a

141
00:05:19,280 --> 00:05:22,240
process executes it the security vendor

142
00:05:22,240 --> 00:05:24,720
security software will get a event

143
00:05:24,720 --> 00:05:26,960
generated or telemetry generated with

144
00:05:26,960 --> 00:05:28,720
process that called that function what

145
00:05:28,720 --> 00:05:30,720
they were trying to do and when which is

146
00:05:30,720 --> 00:05:32,240
very valuable

147
00:05:32,240 --> 00:05:35,039
attackers equally can use the same

148
00:05:35,039 --> 00:05:36,720
hooking for the same purpose in order to

149
00:05:36,720 --> 00:05:38,400
monitor system activity

150
00:05:38,400 --> 00:05:40,560
but equally they can use it in order to

151
00:05:40,560 --> 00:05:42,880
prevent the function from executing or

152
00:05:42,880 --> 00:05:44,960
they can redirect the control flow to

153
00:05:44,960 --> 00:05:47,360
malicious code or shell code and there's

154
00:05:47,360 --> 00:05:49,600
lots of ways that malicious actors can

155
00:05:49,600 --> 00:05:52,240
use this and it is very simple to do and

156
00:05:52,240 --> 00:05:55,039
it is extremely effective

157
00:05:55,039 --> 00:05:57,120
one of the things to note is that the

158
00:05:57,120 --> 00:05:59,840
export address table or eat within the

159
00:05:59,840 --> 00:06:02,160
pe header of libraries makes

160
00:06:02,160 --> 00:06:05,759
very easy so the eat basically outlines

161
00:06:05,759 --> 00:06:07,280
all the exported functions all the

162
00:06:07,280 --> 00:06:09,199
functions that are variable to external

163
00:06:09,199 --> 00:06:11,680
processes from that library and where

164
00:06:11,680 --> 00:06:14,240
they're located in that library

165
00:06:14,240 --> 00:06:16,319
this means that if you wanted to develop

166
00:06:16,319 --> 00:06:18,560
a hook for a particular function looking

167
00:06:18,560 --> 00:06:20,639
at the e80 would give you information on

168
00:06:20,639 --> 00:06:22,800
where it's located in that library's

169
00:06:22,800 --> 00:06:25,199
memory which allows you to target your

170
00:06:25,199 --> 00:06:26,639
manipulation

171
00:06:26,639 --> 00:06:28,319
specifically at that dress making it

172
00:06:28,319 --> 00:06:29,680
very easy

173
00:06:29,680 --> 00:06:31,759
one of the other things to know is that

174
00:06:31,759 --> 00:06:34,000
dynamic information on modules that have

175
00:06:34,000 --> 00:06:35,759
been loaded into processes can be

176
00:06:35,759 --> 00:06:37,759
acquired either by the process

177
00:06:37,759 --> 00:06:39,840
environment block or peb

178
00:06:39,840 --> 00:06:42,240
and through native libraries such as ps

179
00:06:42,240 --> 00:06:44,880
api by examining

180
00:06:44,880 --> 00:06:47,199
these by either using ps api's functions

181
00:06:47,199 --> 00:06:49,120
against a particular process or by

182
00:06:49,120 --> 00:06:52,160
examining the peb of a process you can

183
00:06:52,160 --> 00:06:54,000
actually enumerate all the modules that

184
00:06:54,000 --> 00:06:55,840
are currently loaded and their base

185
00:06:55,840 --> 00:06:58,319
address within that process

186
00:06:58,319 --> 00:07:00,479
which allows for the

187
00:07:00,479 --> 00:07:02,880
eats information to be cross-referenced

188
00:07:02,880 --> 00:07:05,680
to find particular functions within that

189
00:07:05,680 --> 00:07:07,759
process is instance

190
00:07:07,759 --> 00:07:09,199
of that

191
00:07:09,199 --> 00:07:11,039
library or that module

192
00:07:11,039 --> 00:07:12,960
which is which it makes development very

193
00:07:12,960 --> 00:07:14,880
easy for hooking

194
00:07:14,880 --> 00:07:16,720
let's have a look at how this works in

195
00:07:16,720 --> 00:07:19,280
practice so in this case we're trying to

196
00:07:19,280 --> 00:07:22,240
target etw event right which is located

197
00:07:22,240 --> 00:07:25,680
within the ntdl module or library

198
00:07:25,680 --> 00:07:28,639
now etw even write is a core function or

199
00:07:28,639 --> 00:07:30,479
exported function which is required for

200
00:07:30,479 --> 00:07:33,520
etw event generation

201
00:07:33,520 --> 00:07:34,319
so

202
00:07:34,319 --> 00:07:35,759
one of the things to note here is that

203
00:07:35,759 --> 00:07:37,759
ntdll is loaded into every single

204
00:07:37,759 --> 00:07:39,840
windows process it is not optional but

205
00:07:39,840 --> 00:07:41,759
this is just an example to show you how

206
00:07:41,759 --> 00:07:43,039
this could work

207
00:07:43,039 --> 00:07:45,039
so first of all a

208
00:07:45,039 --> 00:07:47,199
attacker would determine

209
00:07:47,199 --> 00:07:48,879
where the process or the function is

210
00:07:48,879 --> 00:07:51,280
located to do this they can do it in one

211
00:07:51,280 --> 00:07:53,680
of two ways they can either use the load

212
00:07:53,680 --> 00:07:56,639
library and get proc address functions

213
00:07:56,639 --> 00:07:59,280
in order to load the library of ntdl and

214
00:07:59,280 --> 00:08:01,360
then find the function address using

215
00:08:01,360 --> 00:08:03,440
getproc address against the

216
00:08:03,440 --> 00:08:06,240
handler generated by load library

217
00:08:06,240 --> 00:08:09,199
or they can enumerate the peb of the

218
00:08:09,199 --> 00:08:11,520
process to find the base address of nt

219
00:08:11,520 --> 00:08:13,599
dll and then cross-reference against the

220
00:08:13,599 --> 00:08:17,280
pe header of nt dll in order to find the

221
00:08:17,280 --> 00:08:18,080
um

222
00:08:18,080 --> 00:08:20,000
in order to calculate the rva of where

223
00:08:20,000 --> 00:08:22,319
etw event right will be located for that

224
00:08:22,319 --> 00:08:23,280
process

225
00:08:23,280 --> 00:08:24,720
either way the result should be an

226
00:08:24,720 --> 00:08:30,120
address in this case of 7ff 8916500

227
00:08:31,199 --> 00:08:32,719
once you have the address of where the

228
00:08:32,719 --> 00:08:34,719
function is located you can determine

229
00:08:34,719 --> 00:08:36,640
what you want to do how you want to

230
00:08:36,640 --> 00:08:39,279
install your handler so in this case

231
00:08:39,279 --> 00:08:41,360
because we just don't want etw event

232
00:08:41,360 --> 00:08:43,360
write to work because we don't want etw

233
00:08:43,360 --> 00:08:45,519
telemetry to be generated we're going to

234
00:08:45,519 --> 00:08:48,120
install an opcode of value

235
00:08:48,120 --> 00:08:51,839
0xc3 which in x64 stands for red or

236
00:08:51,839 --> 00:08:52,800
return

237
00:08:52,800 --> 00:08:55,839
now if you patch or hook the start of

238
00:08:55,839 --> 00:08:59,040
ecw event right with a return command

239
00:08:59,040 --> 00:09:01,680
what happens is every time the function

240
00:09:01,680 --> 00:09:02,959
is called

241
00:09:02,959 --> 00:09:05,680
the first op code returns control to the

242
00:09:05,680 --> 00:09:08,399
calling function so if your function

243
00:09:08,399 --> 00:09:10,720
decides i want to generate an ecw event

244
00:09:10,720 --> 00:09:14,000
cause etw event right as soon as it as

245
00:09:14,000 --> 00:09:15,760
soon as it calls that function

246
00:09:15,760 --> 00:09:19,040
the calling function is returned to with

247
00:09:19,040 --> 00:09:22,240
the stack all uh corrected and and and

248
00:09:22,240 --> 00:09:25,360
resolved and it thinks that etw event

249
00:09:25,360 --> 00:09:27,360
right has been successful but because of

250
00:09:27,360 --> 00:09:29,440
the hook that's been implemented or the

251
00:09:29,440 --> 00:09:31,279
rep that's been patched in

252
00:09:31,279 --> 00:09:34,240
we know that the etw event right has not

253
00:09:34,240 --> 00:09:37,519
done anything and as such you prevent

254
00:09:37,519 --> 00:09:40,880
all etw telemetry from being generated

255
00:09:40,880 --> 00:09:43,519
for that process

256
00:09:43,519 --> 00:09:44,320
so

257
00:09:44,320 --> 00:09:46,480
now we know how this is implemented how

258
00:09:46,480 --> 00:09:48,000
do we detect it

259
00:09:48,000 --> 00:09:51,440
so detection methods are all to do with

260
00:09:51,440 --> 00:09:53,200
knowing having a known good and being

261
00:09:53,200 --> 00:09:54,880
able to compare what is within live

262
00:09:54,880 --> 00:09:56,640
memory so the first thing to know is

263
00:09:56,640 --> 00:09:58,720
that all volatile memory begins as a

264
00:09:58,720 --> 00:10:00,160
file so

265
00:10:00,160 --> 00:10:02,160
all the loaded memory that's in volatile

266
00:10:02,160 --> 00:10:03,760
memory came from the past system to

267
00:10:03,760 --> 00:10:06,079
begin with and the file system has an

268
00:10:06,079 --> 00:10:08,640
unaltered version of what is in volatile

269
00:10:08,640 --> 00:10:11,920
memory now the loaded module file

270
00:10:11,920 --> 00:10:13,680
as we've said before the information

271
00:10:13,680 --> 00:10:15,920
that can be found dynamically primarily

272
00:10:15,920 --> 00:10:18,240
through the peb now what's interesting

273
00:10:18,240 --> 00:10:21,360
about the peb is that it provides a path

274
00:10:21,360 --> 00:10:23,120
to the source file within the file

275
00:10:23,120 --> 00:10:24,000
system

276
00:10:24,000 --> 00:10:25,760
for the library that's for the module

277
00:10:25,760 --> 00:10:27,040
that's been loaded the library that's

278
00:10:27,040 --> 00:10:28,160
been loaded

279
00:10:28,160 --> 00:10:29,040
now

280
00:10:29,040 --> 00:10:32,000
let's say you wanted to monitor for ntdl

281
00:10:32,000 --> 00:10:35,279
etw event right you could use the peb to

282
00:10:35,279 --> 00:10:37,200
find the source file which would be

283
00:10:37,200 --> 00:10:40,000
located in system32 you could then use

284
00:10:40,000 --> 00:10:42,720
the pe header of

285
00:10:42,720 --> 00:10:46,800
ntdl to find the offset of where etw of

286
00:10:46,800 --> 00:10:49,120
mri is located within the file systems

287
00:10:49,120 --> 00:10:51,440
version and use that to calculate the

288
00:10:51,440 --> 00:10:54,720
rva address within the running process

289
00:10:54,720 --> 00:10:57,040
and then you can compare what is in live

290
00:10:57,040 --> 00:10:58,800
memory at the address you've just

291
00:10:58,800 --> 00:11:01,040
calculated for the rba against what is

292
00:11:01,040 --> 00:11:03,360
within the file systems version and

293
00:11:03,360 --> 00:11:05,279
check whether there is disparity between

294
00:11:05,279 --> 00:11:06,880
the two

295
00:11:06,880 --> 00:11:08,880
if there is a disparity you can say that

296
00:11:08,880 --> 00:11:11,200
a hook has been implemented at the start

297
00:11:11,200 --> 00:11:12,959
of the process and this can be done by

298
00:11:12,959 --> 00:11:15,120
by by comparison so if an alteration

299
00:11:15,120 --> 00:11:17,760
occurs within the first 100 bytes or

300
00:11:17,760 --> 00:11:19,519
something to that effect that may be

301
00:11:19,519 --> 00:11:21,920
excessive but you get the idea you can

302
00:11:21,920 --> 00:11:24,160
detect whether a deviation has occurred

303
00:11:24,160 --> 00:11:25,920
due to editing and this is very

304
00:11:25,920 --> 00:11:27,760
effective at detecting these types of

305
00:11:27,760 --> 00:11:29,360
hooks

306
00:11:29,360 --> 00:11:31,920
but targeting is required for such

307
00:11:31,920 --> 00:11:33,839
operations the reason for this is that

308
00:11:33,839 --> 00:11:36,320
um inline hook or inline patching can be

309
00:11:36,320 --> 00:11:38,079
done legitimately as we've said before

310
00:11:38,079 --> 00:11:40,079
this can be done for security purposes

311
00:11:40,079 --> 00:11:41,920
but equally there are some processes

312
00:11:41,920 --> 00:11:44,240
such as firefox which do this

313
00:11:44,240 --> 00:11:47,200
legitimately to a number of internal

314
00:11:47,200 --> 00:11:49,360
functions so unless you are targeting

315
00:11:49,360 --> 00:11:52,000
specific functions of value you may get

316
00:11:52,000 --> 00:11:53,839
a lot of noise on a lot of false

317
00:11:53,839 --> 00:11:56,079
positives on particular functions that

318
00:11:56,079 --> 00:11:58,880
aren't of secure security interest

319
00:11:58,880 --> 00:12:01,279
so as such targeting does need to be

320
00:12:01,279 --> 00:12:03,600
done in order to make this accurate and

321
00:12:03,600 --> 00:12:07,360
equally to make this resource manageable

322
00:12:08,160 --> 00:12:11,680
private functions within um modules pose

323
00:12:11,680 --> 00:12:13,440
a different problem and they have some

324
00:12:13,440 --> 00:12:16,560
detection issues so whereas with

325
00:12:16,560 --> 00:12:18,639
exported functions

326
00:12:18,639 --> 00:12:21,040
where the export exported function is

327
00:12:21,040 --> 00:12:23,440
defined within the eat which makes it

328
00:12:23,440 --> 00:12:26,800
very easy to locate um private functions

329
00:12:26,800 --> 00:12:30,399
are not exposed to external processes in

330
00:12:30,399 --> 00:12:32,560
any way they're not in the peb the pe

331
00:12:32,560 --> 00:12:34,639
header or any index

332
00:12:34,639 --> 00:12:37,600
and as such it makes this much harder to

333
00:12:37,600 --> 00:12:38,560
find

334
00:12:38,560 --> 00:12:40,399
but one of the key things to note is

335
00:12:40,399 --> 00:12:42,639
that exported functions from a module

336
00:12:42,639 --> 00:12:43,519
will

337
00:12:43,519 --> 00:12:46,399
almost inevitably rely on at least one

338
00:12:46,399 --> 00:12:48,240
private function in order to operate

339
00:12:48,240 --> 00:12:50,560
this can be to do with argument

340
00:12:50,560 --> 00:12:52,720
integrity check formatting checking or

341
00:12:52,720 --> 00:12:54,720
you can do with initial connections or

342
00:12:54,720 --> 00:12:56,720
anything to do with that sort of effect

343
00:12:56,720 --> 00:12:58,560
and if you know that the exported

344
00:12:58,560 --> 00:13:01,519
function that you want to prevent

345
00:13:01,519 --> 00:13:03,920
utilizes a private function it can be

346
00:13:03,920 --> 00:13:06,320
just as effective to instead hook on the

347
00:13:06,320 --> 00:13:08,560
private function instead of just the

348
00:13:08,560 --> 00:13:10,560
exported function although it takes a

349
00:13:10,560 --> 00:13:12,000
bit more work

350
00:13:12,000 --> 00:13:14,079
adam chester research adam chester did a

351
00:13:14,079 --> 00:13:16,399
great example of this using dns curry

352
00:13:16,399 --> 00:13:19,040
under school a which i'll demonstrate

353
00:13:19,040 --> 00:13:21,040
now

354
00:13:21,040 --> 00:13:24,240
so in this example you identified that

355
00:13:24,240 --> 00:13:24,959
the

356
00:13:24,959 --> 00:13:26,320
private function you wanted had a

357
00:13:26,320 --> 00:13:29,600
specific code signature by scanning the

358
00:13:29,600 --> 00:13:31,920
by using load library or enumerating the

359
00:13:31,920 --> 00:13:34,399
peb he found the

360
00:13:34,399 --> 00:13:36,399
base address or the memory address of

361
00:13:36,399 --> 00:13:37,839
where the module was loaded for that

362
00:13:37,839 --> 00:13:40,320
particular process and then scanned the

363
00:13:40,320 --> 00:13:42,399
module memory address space until he

364
00:13:42,399 --> 00:13:44,480
found the corresponding code signature

365
00:13:44,480 --> 00:13:47,199
which gave him the base address for the

366
00:13:47,199 --> 00:13:48,399
function

367
00:13:48,399 --> 00:13:51,279
in that module

368
00:13:52,160 --> 00:13:54,800
from the above we can actually see that

369
00:13:54,800 --> 00:13:55,839
the

370
00:13:55,839 --> 00:13:57,360
internal function that we're looking at

371
00:13:57,360 --> 00:13:59,360
when put through a debugger is an

372
00:13:59,360 --> 00:14:02,079
internal symbolic function and as such

373
00:14:02,079 --> 00:14:03,519
it's not exported

374
00:14:03,519 --> 00:14:04,959
from this we know that it's not going to

375
00:14:04,959 --> 00:14:06,720
be in the eot or the iit or anything to

376
00:14:06,720 --> 00:14:08,480
that or sort of effect so without code

377
00:14:08,480 --> 00:14:10,880
signature or pdb

378
00:14:10,880 --> 00:14:12,639
which i'll come to in a minute there is

379
00:14:12,639 --> 00:14:14,320
no way to know

380
00:14:14,320 --> 00:14:16,399
that this function is there unless you

381
00:14:16,399 --> 00:14:18,000
already have the code signature now the

382
00:14:18,000 --> 00:14:20,959
code signature was acquired via external

383
00:14:20,959 --> 00:14:22,959
reverse engineering and looking through

384
00:14:22,959 --> 00:14:23,760
the

385
00:14:23,760 --> 00:14:26,320
call stack of what happens before this

386
00:14:26,320 --> 00:14:29,760
performs a cisco um and uh and just i've

387
00:14:29,760 --> 00:14:31,839
actually found that this particular

388
00:14:31,839 --> 00:14:33,680
private function could be hooked quite

389
00:14:33,680 --> 00:14:35,040
effectively

390
00:14:35,040 --> 00:14:36,240
now

391
00:14:36,240 --> 00:14:38,720
in this case um you can actually patch

392
00:14:38,720 --> 00:14:39,600
the

393
00:14:39,600 --> 00:14:40,040
um

394
00:14:40,040 --> 00:14:41,199
[Music]

395
00:14:41,199 --> 00:14:43,920
private function with a rect command

396
00:14:43,920 --> 00:14:47,440
again the reason for this is that

397
00:14:47,440 --> 00:14:49,839
the uh function in this case

398
00:14:49,839 --> 00:14:53,440
subsequently calls the etw publication

399
00:14:53,440 --> 00:14:54,720
so the private function in this case

400
00:14:54,720 --> 00:14:57,680
actually generates a event template

401
00:14:57,680 --> 00:15:00,560
which then hands off after two functions

402
00:15:00,560 --> 00:15:02,079
nt dll

403
00:15:02,079 --> 00:15:04,720
event right transfer

404
00:15:04,720 --> 00:15:07,120
but by performing by

405
00:15:07,120 --> 00:15:08,000
hand

406
00:15:08,000 --> 00:15:10,800
by putting a hook here of rhett you

407
00:15:10,800 --> 00:15:12,399
prevent the template from getting

408
00:15:12,399 --> 00:15:14,800
generated and the etw event from being

409
00:15:14,800 --> 00:15:17,519
generated within ntdl and the calling

410
00:15:17,519 --> 00:15:20,720
function doesn't know the wiser

411
00:15:20,720 --> 00:15:22,560
as such

412
00:15:22,560 --> 00:15:24,240
you know we can see from the bottom

413
00:15:24,240 --> 00:15:26,079
window that the red command has been

414
00:15:26,079 --> 00:15:28,880
implemented within the specific va for

415
00:15:28,880 --> 00:15:30,880
where the um

416
00:15:30,880 --> 00:15:32,480
post signature has been found which

417
00:15:32,480 --> 00:15:34,880
prevents the etw from being generated we

418
00:15:34,880 --> 00:15:37,519
didn't click on the exported function we

419
00:15:37,519 --> 00:15:39,279
hooked on the subsequent private

420
00:15:39,279 --> 00:15:41,519
function which was called by the

421
00:15:41,519 --> 00:15:44,800
exported function which from a detection

422
00:15:44,800 --> 00:15:45,839
point of view

423
00:15:45,839 --> 00:15:48,480
creates some problems

424
00:15:48,480 --> 00:15:50,000
the primary one being their private

425
00:15:50,000 --> 00:15:52,320
functions are there's no information on

426
00:15:52,320 --> 00:15:53,920
them that's inbuilt into a process

427
00:15:53,920 --> 00:15:55,199
they're again they're not in any of the

428
00:15:55,199 --> 00:15:57,040
header files so that you cannot

429
00:15:57,040 --> 00:15:59,839
enumerate them from an external process

430
00:15:59,839 --> 00:16:02,560
i.e they are private the only way to do

431
00:16:02,560 --> 00:16:04,639
this is to have a program database file

432
00:16:04,639 --> 00:16:07,519
or pdb now pdbs are generated at

433
00:16:07,519 --> 00:16:10,000
compilation time and they do provide

434
00:16:10,000 --> 00:16:11,759
symbolic um address and symbol

435
00:16:11,759 --> 00:16:13,839
information for private functions the

436
00:16:13,839 --> 00:16:16,079
bdb files cannot always be guaranteed to

437
00:16:16,079 --> 00:16:18,480
be acquired the reason for this can be

438
00:16:18,480 --> 00:16:21,360
there could be third-party um

439
00:16:21,360 --> 00:16:23,199
module files where the pdbs might not be

440
00:16:23,199 --> 00:16:25,519
available or you may be in in an

441
00:16:25,519 --> 00:16:26,959
environment where a connection to the

442
00:16:26,959 --> 00:16:28,639
internet and the subsequent windows

443
00:16:28,639 --> 00:16:31,600
symbolic server where windows pdbs are

444
00:16:31,600 --> 00:16:34,079
available cannot be accessed so unless

445
00:16:34,079 --> 00:16:37,120
you have a large database of pdb files

446
00:16:37,120 --> 00:16:38,560
walking around with your detection

447
00:16:38,560 --> 00:16:41,199
system it can be hard to

448
00:16:41,199 --> 00:16:43,680
attribute or find

449
00:16:43,680 --> 00:16:45,600
where particular memory addresses are

450
00:16:45,600 --> 00:16:48,959
located to private functions

451
00:16:48,959 --> 00:16:50,800
secondly there's a double dependency

452
00:16:50,800 --> 00:16:53,040
issue so what this means is that each

453
00:16:53,040 --> 00:16:55,920
module can have an iit or import address

454
00:16:55,920 --> 00:16:57,680
table as well effectively what this

455
00:16:57,680 --> 00:17:00,480
means is this module relies on a second

456
00:17:00,480 --> 00:17:04,240
module for functional capabilities now

457
00:17:04,240 --> 00:17:06,079
because of this

458
00:17:06,079 --> 00:17:07,439
if a

459
00:17:07,439 --> 00:17:10,160
module imports other modules you

460
00:17:10,160 --> 00:17:12,000
therefore and that module

461
00:17:12,000 --> 00:17:14,160
let's say that your first module calls a

462
00:17:14,160 --> 00:17:16,400
second module in your second module has

463
00:17:16,400 --> 00:17:18,160
the function that you're looking to

464
00:17:18,160 --> 00:17:19,839
monitor for

465
00:17:19,839 --> 00:17:21,599
any point in the stack from the first

466
00:17:21,599 --> 00:17:24,160
module to the second module any function

467
00:17:24,160 --> 00:17:27,280
within that stack can be hooked in order

468
00:17:27,280 --> 00:17:29,919
to prevent that second function the

469
00:17:29,919 --> 00:17:31,360
function within the second module for

470
00:17:31,360 --> 00:17:34,480
being executed and as such all potential

471
00:17:34,480 --> 00:17:36,720
paths against all the double dependency

472
00:17:36,720 --> 00:17:40,160
modules need to be monitored in order to

473
00:17:40,160 --> 00:17:42,240
prevent hooking at an earlier stage in

474
00:17:42,240 --> 00:17:44,240
the stack but because of this the

475
00:17:44,240 --> 00:17:46,720
resources required are exponential so if

476
00:17:46,720 --> 00:17:48,559
you look at the table in the bottom left

477
00:17:48,559 --> 00:17:50,080
you'll see that the number of internal

478
00:17:50,080 --> 00:17:53,440
function symbols for um the average uh

479
00:17:53,440 --> 00:17:55,039
module is around

480
00:17:55,039 --> 00:17:57,919
three to five thousand but the dependent

481
00:17:57,919 --> 00:18:00,880
modules can be as high as 806 with an

482
00:18:00,880 --> 00:18:03,039
average of 583

483
00:18:03,039 --> 00:18:05,360
now because of this when you start to

484
00:18:05,360 --> 00:18:06,960
count up all the internal functions that

485
00:18:06,960 --> 00:18:08,080
you're potentially going to have to map

486
00:18:08,080 --> 00:18:09,840
against all the

487
00:18:09,840 --> 00:18:11,360
modules that they're now dependent on

488
00:18:11,360 --> 00:18:13,919
that number rises very very very quickly

489
00:18:13,919 --> 00:18:18,000
which can create a big resource problem

490
00:18:18,000 --> 00:18:20,080
finally it's to do with the module

491
00:18:20,080 --> 00:18:22,480
version so between module versions some

492
00:18:22,480 --> 00:18:25,280
internal functions can become

493
00:18:25,280 --> 00:18:26,799
obsolete and they're removed which means

494
00:18:26,799 --> 00:18:29,280
that all the addresses are subsequently

495
00:18:29,280 --> 00:18:30,720
changed so

496
00:18:30,720 --> 00:18:32,880
when you're monitoring for module

497
00:18:32,880 --> 00:18:34,799
private functions you have to have an

498
00:18:34,799 --> 00:18:36,640
accurate model type and if you want to

499
00:18:36,640 --> 00:18:38,400
attribute it you also have to have an

500
00:18:38,400 --> 00:18:41,280
accurate pdb version as well otherwise

501
00:18:41,280 --> 00:18:44,480
you run the risk of misattributing a

502
00:18:44,480 --> 00:18:46,799
alteration to the wrong address which

503
00:18:46,799 --> 00:18:48,400
can be very problematic so instead of

504
00:18:48,400 --> 00:18:51,200
just having one pdb per module you know

505
00:18:51,200 --> 00:18:54,240
i have to have every version of pdb for

506
00:18:54,240 --> 00:18:56,640
every potential version of that module

507
00:18:56,640 --> 00:19:00,640
which again creates a resource issue

508
00:19:00,640 --> 00:19:03,039
so as such it becomes much more

509
00:19:03,039 --> 00:19:04,559
difficult to detect these private

510
00:19:04,559 --> 00:19:06,559
functions being hooking and there's no

511
00:19:06,559 --> 00:19:08,799
real reliable go-to method for

512
00:19:08,799 --> 00:19:10,799
monitoring these they tend to be context

513
00:19:10,799 --> 00:19:12,000
dependent

514
00:19:12,000 --> 00:19:15,200
the manual manual mapping dependent on

515
00:19:15,200 --> 00:19:18,080
the primary function to target function

516
00:19:18,080 --> 00:19:20,400
also needs to be ascertained the reason

517
00:19:20,400 --> 00:19:22,160
for this is that

518
00:19:22,160 --> 00:19:23,440
different parts will have different

519
00:19:23,440 --> 00:19:24,880
values depending on their security

520
00:19:24,880 --> 00:19:26,799
vulnerability and this needs to be done

521
00:19:26,799 --> 00:19:29,120
unfortunately manually because all the

522
00:19:29,120 --> 00:19:31,120
potential paths can't be mapped

523
00:19:31,120 --> 00:19:33,360
automatically um

524
00:19:33,360 --> 00:19:35,440
and in order to assign resources to

525
00:19:35,440 --> 00:19:37,200
those of the highest value this will

526
00:19:37,200 --> 00:19:38,880
need to be research when you need to be

527
00:19:38,880 --> 00:19:41,440
conducted however because as i said

528
00:19:41,440 --> 00:19:43,760
before this needs to be context focused

529
00:19:43,760 --> 00:19:45,120
you tend to find that this is either

530
00:19:45,120 --> 00:19:47,679
going to be inaccurate due to the lack

531
00:19:47,679 --> 00:19:50,400
of pdb or it's going to be so resource

532
00:19:50,400 --> 00:19:52,000
intensive because of the double linking

533
00:19:52,000 --> 00:19:54,640
issue that it becomes ineffective and

534
00:19:54,640 --> 00:19:56,559
very slow so there tends to be a balance

535
00:19:56,559 --> 00:19:58,559
between the two depending on what is

536
00:19:58,559 --> 00:20:01,039
available

537
00:20:01,280 --> 00:20:04,159
kernel hooking on legacy systems so this

538
00:20:04,159 --> 00:20:06,799
is to do with systems pre-build one

539
00:20:06,799 --> 00:20:09,280
eight nine five zero um post one eight

540
00:20:09,280 --> 00:20:10,799
nine five zero microsoft actually

541
00:20:10,799 --> 00:20:12,640
targeted this particular vulnerability

542
00:20:12,640 --> 00:20:15,679
by uh adapting patch card and removing a

543
00:20:15,679 --> 00:20:17,520
particular kernel variable which was

544
00:20:17,520 --> 00:20:19,840
susceptible to manipulation

545
00:20:19,840 --> 00:20:20,960
now

546
00:20:20,960 --> 00:20:23,679
in order to perform kernel level hooking

547
00:20:23,679 --> 00:20:26,320
you need to use um

548
00:20:26,320 --> 00:20:28,480
a vulnerable kernel driver or an

549
00:20:28,480 --> 00:20:30,000
insecure variable type as we just

550
00:20:30,000 --> 00:20:32,000
mentioned um the insecure variable type

551
00:20:32,000 --> 00:20:33,919
was something that microsoft patched uh

552
00:20:33,919 --> 00:20:36,320
specifically um some of the versions

553
00:20:36,320 --> 00:20:38,000
some of the examples of this are ghost

554
00:20:38,000 --> 00:20:41,360
in the logs or gi gitl by bat tech

555
00:20:41,360 --> 00:20:43,600
infinity hook by everdocs

556
00:20:43,600 --> 00:20:46,840
and kernel driver utility kvu by h

557
00:20:46,840 --> 00:20:50,480
firefox so let's go into how these all

558
00:20:50,480 --> 00:20:53,120
fit together

559
00:20:53,440 --> 00:20:55,280
so

560
00:20:55,280 --> 00:20:57,520
kernel level patching first of all uses

561
00:20:57,520 --> 00:21:00,640
the kernel driver utility or kvu in

562
00:21:00,640 --> 00:21:02,720
order to um

563
00:21:02,720 --> 00:21:06,159
effectively use a vulnerability within

564
00:21:06,159 --> 00:21:08,240
vulnerable kernel drivers to have

565
00:21:08,240 --> 00:21:11,520
ambiguous memory access to kernel space

566
00:21:11,520 --> 00:21:14,000
now the vulnerable drivers are are still

567
00:21:14,000 --> 00:21:16,240
available in windows 10 and kdu does

568
00:21:16,240 --> 00:21:18,320
still work the drivers have not been

569
00:21:18,320 --> 00:21:19,600
removed this is something that's

570
00:21:19,600 --> 00:21:22,240
important to know because what kdu does

571
00:21:22,240 --> 00:21:25,200
is it allows you to write a malicious

572
00:21:25,200 --> 00:21:27,120
kernel driver into kernel space by

573
00:21:27,120 --> 00:21:29,679
basically piggybacking on one of these

574
00:21:29,679 --> 00:21:32,000
vulnerable drivers so in this case a

575
00:21:32,000 --> 00:21:34,159
malicious executable will load a

576
00:21:34,159 --> 00:21:36,559
vulnerable driver and then by using the

577
00:21:36,559 --> 00:21:38,880
vulnerability with the associated cves

578
00:21:38,880 --> 00:21:40,880
which are available it will write a

579
00:21:40,880 --> 00:21:43,440
malicious driver into kernel space and

580
00:21:43,440 --> 00:21:46,480
load it now the malicious driver

581
00:21:46,480 --> 00:21:49,360
will then start to get to work now using

582
00:21:49,360 --> 00:21:51,679
infinity hook the kernel driver the

583
00:21:51,679 --> 00:21:53,760
malicious kernel driver will check the

584
00:21:53,760 --> 00:21:59,039
etw debugger data for a um for the entry

585
00:21:59,039 --> 00:22:01,840
circular kernel context logger and now

586
00:22:01,840 --> 00:22:04,480
this is to do with

587
00:22:04,480 --> 00:22:07,200
um a log an array of loggers which run

588
00:22:07,200 --> 00:22:08,799
within the kernel and they all have

589
00:22:08,799 --> 00:22:10,960
different id values now the circular

590
00:22:10,960 --> 00:22:14,159
logger has an index id too now this is

591
00:22:14,159 --> 00:22:15,600
important because the circular logger

592
00:22:15,600 --> 00:22:17,840
will run as you might guess circularly

593
00:22:17,840 --> 00:22:20,120
on every single um

594
00:22:20,120 --> 00:22:23,200
sys command that's sent to the kernel

595
00:22:23,200 --> 00:22:25,919
and it creates a log for it now by

596
00:22:25,919 --> 00:22:27,679
finding this

597
00:22:27,679 --> 00:22:32,400
entry within the etw debugger data

598
00:22:33,840 --> 00:22:34,799
the

599
00:22:34,799 --> 00:22:37,679
object has a wmi logger context object

600
00:22:37,679 --> 00:22:40,240
attached to it and within this is an

601
00:22:40,240 --> 00:22:43,919
object called get cpu clock which

602
00:22:43,919 --> 00:22:46,960
unfortunately is the type pointer

603
00:22:46,960 --> 00:22:48,960
now once you've found the circular

604
00:22:48,960 --> 00:22:52,320
logger you can overwrite the

605
00:22:52,320 --> 00:22:55,440
get cpu clock uh pointer within the wmy

606
00:22:55,440 --> 00:22:56,799
logo context

607
00:22:56,799 --> 00:23:00,320
in order to point to hooked context now

608
00:23:00,320 --> 00:23:01,919
once the hook is in place what this

609
00:23:01,919 --> 00:23:03,520
effectively means is every time the

610
00:23:03,520 --> 00:23:05,360
logger is called and it tries to grab

611
00:23:05,360 --> 00:23:08,720
the current time it will instead run the

612
00:23:08,720 --> 00:23:10,880
hook content that the malicious driver

613
00:23:10,880 --> 00:23:12,480
has installed

614
00:23:12,480 --> 00:23:15,039
typically this means that the argument

615
00:23:15,039 --> 00:23:17,919
data and the cisco context will be

616
00:23:17,919 --> 00:23:20,240
siphoned off into an evil collector

617
00:23:20,240 --> 00:23:22,240
which will allow them to monitor system

618
00:23:22,240 --> 00:23:24,799
level activity but one of the really

619
00:23:24,799 --> 00:23:26,640
interesting things about infinity hook

620
00:23:26,640 --> 00:23:28,480
is that it actually has the capability

621
00:23:28,480 --> 00:23:29,919
to run

622
00:23:29,919 --> 00:23:31,919
any syscall by

623
00:23:31,919 --> 00:23:34,159
by using this hook capability

624
00:23:34,159 --> 00:23:35,440
and the reason for this is that the

625
00:23:35,440 --> 00:23:38,559
circular logger actually um

626
00:23:38,559 --> 00:23:40,640
runs before the syscall is executed

627
00:23:40,640 --> 00:23:42,880
actually just before so once the hook

628
00:23:42,880 --> 00:23:44,240
has been called

629
00:23:44,240 --> 00:23:47,120
within the logger it can walk up the

630
00:23:47,120 --> 00:23:48,159
stack

631
00:23:48,159 --> 00:23:50,960
find the uh function point of the cisco

632
00:23:50,960 --> 00:23:53,200
that's been targeted and overwrite it

633
00:23:53,200 --> 00:23:56,000
with any cisco the malicious actor wants

634
00:23:56,000 --> 00:23:58,480
and from this they have kernel level

635
00:23:58,480 --> 00:23:59,679
cisco

636
00:23:59,679 --> 00:24:01,760
operational capabilities by using this

637
00:24:01,760 --> 00:24:05,840
hook which is extremely powerful

638
00:24:05,840 --> 00:24:07,200
roasting the log

639
00:24:07,200 --> 00:24:09,440
works in the same way but where the hook

640
00:24:09,440 --> 00:24:11,600
has been implemented it only monitors

641
00:24:11,600 --> 00:24:13,360
one particular

642
00:24:13,360 --> 00:24:14,400
cisco

643
00:24:14,400 --> 00:24:17,279
function for anti-trace event pointer

644
00:24:17,279 --> 00:24:19,760
now when it detects this it instead

645
00:24:19,760 --> 00:24:20,880
diverts

646
00:24:20,880 --> 00:24:23,440
it creates it will divert to um the

647
00:24:23,440 --> 00:24:24,960
hooked function

648
00:24:24,960 --> 00:24:27,440
and the hooked function will determine

649
00:24:27,440 --> 00:24:30,720
against an ioctl or i o control flag

650
00:24:30,720 --> 00:24:32,400
from the user space

651
00:24:32,400 --> 00:24:35,120
whether or not publication to the nt

652
00:24:35,120 --> 00:24:37,840
trace event will occur now this is

653
00:24:37,840 --> 00:24:40,720
important because motion logs allows for

654
00:24:40,720 --> 00:24:43,679
user land control of a kernel level

655
00:24:43,679 --> 00:24:45,919
monitoring element effectively using

656
00:24:45,919 --> 00:24:49,600
ioctl a userland process can ambiguously

657
00:24:49,600 --> 00:24:50,559
decide

658
00:24:50,559 --> 00:24:53,200
um yes generate an event or no i want to

659
00:24:53,200 --> 00:24:55,120
keep this secret and this is important

660
00:24:55,120 --> 00:24:57,279
because what it allows um for the

661
00:24:57,279 --> 00:24:59,039
prevention of

662
00:24:59,039 --> 00:25:01,440
no data detection so whereas with the

663
00:25:01,440 --> 00:25:03,039
previous examples where you can just

664
00:25:03,039 --> 00:25:05,200
prevent etw events from being generated

665
00:25:05,200 --> 00:25:07,440
at all for a process um you can

666
00:25:07,440 --> 00:25:09,679
therefore actually stand for lack of

667
00:25:09,679 --> 00:25:11,440
data um

668
00:25:11,440 --> 00:25:13,039
so if you find that there's a process

669
00:25:13,039 --> 00:25:16,240
running but there are no etw entries

670
00:25:16,240 --> 00:25:18,080
for that process you know that

671
00:25:18,080 --> 00:25:19,679
manipulation or malicious action is

672
00:25:19,679 --> 00:25:21,919
taking place but by using ghost in the

673
00:25:21,919 --> 00:25:24,000
logs you can actually prevent that and

674
00:25:24,000 --> 00:25:27,679
publish the nine events and keep secret

675
00:25:27,679 --> 00:25:30,320
malicious events from a user land

676
00:25:30,320 --> 00:25:32,880
control to a malicious hook that's been

677
00:25:32,880 --> 00:25:35,600
implemented which is uh really really

678
00:25:35,600 --> 00:25:37,200
cool

679
00:25:37,200 --> 00:25:39,600
detection for this again so it's post

680
00:25:39,600 --> 00:25:41,600
windows 7

681
00:25:41,600 --> 00:25:44,000
but it's pre build one eight nine five

682
00:25:44,000 --> 00:25:45,200
zero

683
00:25:45,200 --> 00:25:47,279
and any system between that window is

684
00:25:47,279 --> 00:25:50,640
susceptible to this um this kind of

685
00:25:50,640 --> 00:25:52,000
level hooking

686
00:25:52,000 --> 00:25:54,240
now as we said before first in the logs

687
00:25:54,240 --> 00:25:56,799
relies on the kernel driver a utility or

688
00:25:56,799 --> 00:25:59,440
kdu in order to utilize a vulnerable

689
00:25:59,440 --> 00:26:02,559
driver in order to load its malicious

690
00:26:02,559 --> 00:26:05,200
driver into memory in order to utilize

691
00:26:05,200 --> 00:26:07,200
infinity hooks and then install

692
00:26:07,200 --> 00:26:10,880
its um ioctl based um

693
00:26:10,880 --> 00:26:13,760
etw prevention now but there are some

694
00:26:13,760 --> 00:26:15,279
other

695
00:26:15,279 --> 00:26:16,400
uh

696
00:26:16,400 --> 00:26:18,559
evasion techniques like by pg or by

697
00:26:18,559 --> 00:26:21,440
patchguard which rely on um the kernel

698
00:26:21,440 --> 00:26:23,200
driver being installed via a different

699
00:26:23,200 --> 00:26:25,600
method so kdu can be used but it is not

700
00:26:25,600 --> 00:26:28,799
the inbuilt mechanism so although um

701
00:26:28,799 --> 00:26:30,640
kernel driver installation and service

702
00:26:30,640 --> 00:26:32,080
installation is something that can be

703
00:26:32,080 --> 00:26:34,159
monitored for it won't necessarily use

704
00:26:34,159 --> 00:26:36,480
keu to do that

705
00:26:36,480 --> 00:26:38,799
but because ghost and logs does use kdu

706
00:26:38,799 --> 00:26:41,679
it's quite easy to detect thankfully

707
00:26:41,679 --> 00:26:43,919
the reason for this is that kde relies

708
00:26:43,919 --> 00:26:46,880
on a list of known vulnerable kernel

709
00:26:46,880 --> 00:26:49,440
drivers and services in order to allow

710
00:26:49,440 --> 00:26:52,880
for the ambiguous kernel memory access

711
00:26:52,880 --> 00:26:55,120
this is the full list but the ones in

712
00:26:55,120 --> 00:26:56,880
red are the ones that goshen the log

713
00:26:56,880 --> 00:26:59,039
uses specifically so

714
00:26:59,039 --> 00:27:02,520
now driver rt core 64 gdrv

715
00:27:02,520 --> 00:27:06,080
atscio and msio64

716
00:27:06,080 --> 00:27:07,679
what's interesting to know is that the

717
00:27:07,679 --> 00:27:10,320
intel ethernet debug debug driver tends

718
00:27:10,320 --> 00:27:12,159
to be the go to for

719
00:27:12,159 --> 00:27:15,279
kdu and gi and ghost in the logs um and

720
00:27:15,279 --> 00:27:17,120
it is still present on the most up to

721
00:27:17,120 --> 00:27:18,799
date windows 10 system so it is

722
00:27:18,799 --> 00:27:20,720
something to keep an eye on but by

723
00:27:20,720 --> 00:27:22,720
monitoring for any of these kernel

724
00:27:22,720 --> 00:27:26,000
services being installed or um or ran

725
00:27:26,000 --> 00:27:28,159
you can actually monitor for any of this

726
00:27:28,159 --> 00:27:30,320
activity because these are not run

727
00:27:30,320 --> 00:27:32,880
typically so any interaction with these

728
00:27:32,880 --> 00:27:34,799
services can be seen as malicious and

729
00:27:34,799 --> 00:27:37,520
it's very easy to detect

730
00:27:37,520 --> 00:27:39,360
alternatively at the kernel level by

731
00:27:39,360 --> 00:27:40,880
using a return level driver with

732
00:27:40,880 --> 00:27:43,440
appropriate capabilities you can monitor

733
00:27:43,440 --> 00:27:45,840
for the wmi logger connect

734
00:27:45,840 --> 00:27:48,480
object instance with an entry logger id2

735
00:27:48,480 --> 00:27:51,039
and check the get cpu clock pointer

736
00:27:51,039 --> 00:27:54,080
against a known good um or simply just

737
00:27:54,080 --> 00:27:55,630
check that it um

738
00:27:55,630 --> 00:27:56,799
[Music]

739
00:27:56,799 --> 00:27:58,000
it doesn't point somewhere it's not

740
00:27:58,000 --> 00:27:59,120
supposed to

741
00:27:59,120 --> 00:28:01,120
but by monitoring this you can you can

742
00:28:01,120 --> 00:28:03,600
equally check for infinity hook and

743
00:28:03,600 --> 00:28:06,158
black peachy

744
00:28:07,360 --> 00:28:10,480
so heaven skate hooking for x86 so this

745
00:28:10,480 --> 00:28:13,520
is um heaven's gate is the element that

746
00:28:13,520 --> 00:28:17,440
switches cpu modes between x32 and x64

747
00:28:17,440 --> 00:28:20,480
when you're using wow 64 or for x86

748
00:28:20,480 --> 00:28:21,600
processors

749
00:28:21,600 --> 00:28:24,399
the reason that this occurs is because

750
00:28:24,399 --> 00:28:27,440
if you have an x32 process running on an

751
00:28:27,440 --> 00:28:31,679
x64 host the x64 host obviously only has

752
00:28:31,679 --> 00:28:33,919
an x64 kernel

753
00:28:33,919 --> 00:28:36,720
but if an x32 process decides it needs

754
00:28:36,720 --> 00:28:39,039
to perform a syscall it needs to be

755
00:28:39,039 --> 00:28:43,200
translated to an x64 cpu mode and x64

756
00:28:43,200 --> 00:28:46,320
format before the kernel can handle it

757
00:28:46,320 --> 00:28:49,120
and so because of this all syscalls have

758
00:28:49,120 --> 00:28:51,600
to go through heaven's gate in order to

759
00:28:51,600 --> 00:28:54,640
be translated and switch between cpu

760
00:28:54,640 --> 00:28:57,279
mode x32 or 64

761
00:28:57,279 --> 00:29:01,120
over to the native x64 cpu mode where

762
00:29:01,120 --> 00:29:03,760
the syscall can be handled

763
00:29:03,760 --> 00:29:06,240
and because of this hooking on this

764
00:29:06,240 --> 00:29:08,240
particular element means that you can

765
00:29:08,240 --> 00:29:12,399
monitor all cisco events from an x32

766
00:29:12,399 --> 00:29:16,159
process running while 64 regardless of

767
00:29:16,159 --> 00:29:17,279
what it is

768
00:29:17,279 --> 00:29:19,600
um so instead of being a targeted hook

769
00:29:19,600 --> 00:29:21,120
for particular functions instead you're

770
00:29:21,120 --> 00:29:23,919
hooking every syscall that that process

771
00:29:23,919 --> 00:29:24,840
is

772
00:29:24,840 --> 00:29:27,600
making as you said hooks elsewhere can

773
00:29:27,600 --> 00:29:29,520
be stealthy as we've saw earlier you can

774
00:29:29,520 --> 00:29:31,120
hook on particular functions on

775
00:29:31,120 --> 00:29:32,480
particular exported functions or private

776
00:29:32,480 --> 00:29:33,279
functions

777
00:29:33,279 --> 00:29:35,200
that sort of thing but heavensgate gives

778
00:29:35,200 --> 00:29:36,399
you a

779
00:29:36,399 --> 00:29:38,480
subsystem wide for that process

780
00:29:38,480 --> 00:29:41,120
monitoring of all the cisco's it's gonna

781
00:29:41,120 --> 00:29:42,240
um

782
00:29:42,240 --> 00:29:44,880
go into conduct which allows you to

783
00:29:44,880 --> 00:29:46,320
prevent particular cis calls from

784
00:29:46,320 --> 00:29:48,880
executing you can hijack the information

785
00:29:48,880 --> 00:29:50,640
you can manipulate the information

786
00:29:50,640 --> 00:29:52,880
effectively allows you to do whatever

787
00:29:52,880 --> 00:29:54,880
you want as long as the appropriate

788
00:29:54,880 --> 00:29:58,000
hooking is put in place

789
00:29:58,000 --> 00:30:00,159
so let's have a quick look at exactly

790
00:30:00,159 --> 00:30:03,120
how this works so on an x64 system an

791
00:30:03,120 --> 00:30:06,399
x32 program will say okay i i need to

792
00:30:06,399 --> 00:30:07,520
call a function that's going to perform

793
00:30:07,520 --> 00:30:09,440
a cisco so typically that will go to nt

794
00:30:09,440 --> 00:30:12,559
dll the wow 64 version of nttrl what's

795
00:30:12,559 --> 00:30:14,559
interesting is x32 processors running

796
00:30:14,559 --> 00:30:16,720
while 64 actually have two versions of

797
00:30:16,720 --> 00:30:19,279
ntdl um i won't go into that but first

798
00:30:19,279 --> 00:30:22,480
of all we will call the wow 64 version

799
00:30:22,480 --> 00:30:23,679
the cisco will then need to be

800
00:30:23,679 --> 00:30:25,840
translated and then it will hand off to

801
00:30:25,840 --> 00:30:29,039
wow 64 cpu which will which is where

802
00:30:29,039 --> 00:30:30,880
heaven's gate resides

803
00:30:30,880 --> 00:30:32,559
heaven's gate will then perform what's

804
00:30:32,559 --> 00:30:35,520
called a long jump which is done by a

805
00:30:35,520 --> 00:30:40,080
code segment change from the x 32 wow 64

806
00:30:40,080 --> 00:30:44,880
cpu mode over to the x64 cpu mode wow 64

807
00:30:44,880 --> 00:30:47,279
cpu module

808
00:30:47,279 --> 00:30:51,200
once in x64 cpu mode it will then hand

809
00:30:51,200 --> 00:30:52,960
off to the native

810
00:30:52,960 --> 00:30:55,919
ntdl instance the x64 instance which

811
00:30:55,919 --> 00:30:58,320
will then handle the command running to

812
00:30:58,320 --> 00:31:01,919
the kernel and the cisco will be handled

813
00:31:01,919 --> 00:31:03,919
the response will be then fed back down

814
00:31:03,919 --> 00:31:06,240
the same pipe a long jump will be back

815
00:31:06,240 --> 00:31:10,000
into x 32 back to the nt dll 64 instance

816
00:31:10,000 --> 00:31:12,320
and then back to the x32 process and

817
00:31:12,320 --> 00:31:14,880
that's rudimentary how heaven's gate

818
00:31:14,880 --> 00:31:18,080
works and how while 64 cisco's are

819
00:31:18,080 --> 00:31:21,279
conducted but if you decide if if a hook

820
00:31:21,279 --> 00:31:23,200
is implemented on heaven's date within

821
00:31:23,200 --> 00:31:25,440
wow 64 cpu

822
00:31:25,440 --> 00:31:28,559
all of this becomes compromised

823
00:31:28,559 --> 00:31:30,559
now at this point as soon as the cisco

824
00:31:30,559 --> 00:31:32,880
is handed off from ntdl to r64 in order

825
00:31:32,880 --> 00:31:35,200
to jump cpu modes

826
00:31:35,200 --> 00:31:37,360
um the malicious hook can do anything it

827
00:31:37,360 --> 00:31:39,360
wants it can change the school that's

828
00:31:39,360 --> 00:31:41,519
being implemented siphon the data jump

829
00:31:41,519 --> 00:31:44,480
to malicious code uh ignore the cisco

830
00:31:44,480 --> 00:31:46,720
and just return and not do anything

831
00:31:46,720 --> 00:31:49,200
there are lots of things it can do

832
00:31:49,200 --> 00:31:51,440
but because of this it does mean that if

833
00:31:51,440 --> 00:31:52,880
it doesn't matter which function it's

834
00:31:52,880 --> 00:31:54,720
calling what module it's calling from if

835
00:31:54,720 --> 00:31:56,480
it performs a cisco

836
00:31:56,480 --> 00:31:58,799
it will have to go through wow 64 cpu

837
00:31:58,799 --> 00:32:01,360
and perform and go through heaven's gate

838
00:32:01,360 --> 00:32:04,080
and looking at that gives full control

839
00:32:04,080 --> 00:32:05,840
and full access to all the cisco

840
00:32:05,840 --> 00:32:07,120
operations

841
00:32:07,120 --> 00:32:10,640
so how would we go about detecting this

842
00:32:10,640 --> 00:32:12,559
before i move on to detection it is

843
00:32:12,559 --> 00:32:15,039
worth noting that heaven's gate um in

844
00:32:15,039 --> 00:32:17,039
this instance is done through the

845
00:32:17,039 --> 00:32:19,519
inherent native heavens gate but there

846
00:32:19,519 --> 00:32:21,200
are alternative functions to heaven's

847
00:32:21,200 --> 00:32:23,519
gate where um the long jumper that i've

848
00:32:23,519 --> 00:32:26,240
i've uh mentioned within wow 64 cpu

849
00:32:26,240 --> 00:32:28,240
which constitutes chemistry can actually

850
00:32:28,240 --> 00:32:30,159
be implemented manually in order to

851
00:32:30,159 --> 00:32:33,679
conduct the cpu mode transfer without

852
00:32:33,679 --> 00:32:36,080
going through the native module now this

853
00:32:36,080 --> 00:32:37,679
is a malicious technique that can be

854
00:32:37,679 --> 00:32:39,279
used for

855
00:32:39,279 --> 00:32:41,039
evasion and is something that can be

856
00:32:41,039 --> 00:32:42,880
developed into a system but it isn't

857
00:32:42,880 --> 00:32:44,720
manipulation of existing memory so it's

858
00:32:44,720 --> 00:32:46,159
not something we're going to cover here

859
00:32:46,159 --> 00:32:47,679
it's just something i wanted people to

860
00:32:47,679 --> 00:32:50,080
be aware of that heaven's gate can be

861
00:32:50,080 --> 00:32:52,880
used um by a manual method being

862
00:32:52,880 --> 00:32:55,600
implemented within malicious x32 code on

863
00:32:55,600 --> 00:32:57,600
a wow 64 system

864
00:32:57,600 --> 00:33:00,320
so talking about detection

865
00:33:00,320 --> 00:33:02,240
first thing to know is how do we know

866
00:33:02,240 --> 00:33:03,679
where heaven's gate is how do we know

867
00:33:03,679 --> 00:33:06,559
where we want to monitor well huangburi

868
00:33:06,559 --> 00:33:09,360
actually found this in his research on

869
00:33:09,360 --> 00:33:12,640
wow 64 processes and found that the tib

870
00:33:12,640 --> 00:33:17,039
of well 64 processes actually has a

871
00:33:17,039 --> 00:33:21,519
field filled at offset 0xc0

872
00:33:21,519 --> 00:33:25,279
for fast cisco and this is actually

873
00:33:25,279 --> 00:33:28,080
the exact address of where heaven's gate

874
00:33:28,080 --> 00:33:30,480
is stored relative to that process now

875
00:33:30,480 --> 00:33:32,960
this is interesting because um jeff jeff

876
00:33:32,960 --> 00:33:33,919
chapel

877
00:33:33,919 --> 00:33:35,600
found that in the same office if you

878
00:33:35,600 --> 00:33:37,200
look at his

879
00:33:37,200 --> 00:33:39,279
repository of information but the same

880
00:33:39,279 --> 00:33:41,360
offset is actually wow 32

881
00:33:41,360 --> 00:33:42,720
reserved

882
00:33:42,720 --> 00:33:44,080
now this is interesting because they

883
00:33:44,080 --> 00:33:46,240
obviously correlate to the two but have

884
00:33:46,240 --> 00:33:49,039
um slightly different names either way

885
00:33:49,039 --> 00:33:52,159
in a wow 64 process this offset within

886
00:33:52,159 --> 00:33:55,120
our tib corresponds to heaven's gates

887
00:33:55,120 --> 00:33:58,159
address which allowed you to highlight

888
00:33:58,159 --> 00:34:00,159
from any running process where heaven's

889
00:34:00,159 --> 00:34:03,679
gate is located and where to monitor

890
00:34:03,679 --> 00:34:04,840
so

891
00:34:04,840 --> 00:34:07,519
x86 one of the things to note is that

892
00:34:07,519 --> 00:34:09,520
the gate location is at an offset of

893
00:34:09,520 --> 00:34:13,040
xerox 7000 from wow 64

894
00:34:13,040 --> 00:34:15,679
164 cpu's base address and it is not

895
00:34:15,679 --> 00:34:18,079
changed legitimately the reason for this

896
00:34:18,079 --> 00:34:20,320
is that while 64 is actually loaded at

897
00:34:20,320 --> 00:34:22,800
the initialization stage of all well 64

898
00:34:22,800 --> 00:34:26,079
processes so similar to ntdll although

899
00:34:26,079 --> 00:34:28,719
for very different reasons um while 64

900
00:34:28,719 --> 00:34:29,760
cpu

901
00:34:29,760 --> 00:34:32,000
unless forced will always load in the

902
00:34:32,000 --> 00:34:34,719
same location um

903
00:34:34,719 --> 00:34:36,639
for a running process

904
00:34:36,639 --> 00:34:38,480
and from that you know that the gate

905
00:34:38,480 --> 00:34:41,760
location is going to be the base address

906
00:34:41,760 --> 00:34:44,879
plus the xerox 7000 offset and you can

907
00:34:44,879 --> 00:34:47,599
scan it very confidently

908
00:34:47,599 --> 00:34:49,679
this can be forced

909
00:34:49,679 --> 00:34:51,599
but it is very hard to do and it's not

910
00:34:51,599 --> 00:34:52,719
common

911
00:34:52,719 --> 00:34:54,480
the other thing to note is that x86

912
00:34:54,480 --> 00:34:57,119
processor y64 processors do legitimately

913
00:34:57,119 --> 00:34:59,599
change elements within well 64 cpu as

914
00:34:59,599 --> 00:35:00,640
well

915
00:35:00,640 --> 00:35:02,880
in the example below

916
00:35:02,880 --> 00:35:06,160
you can see that uh the offset is seven

917
00:35:06,160 --> 00:35:08,960
seven three six five thousand so it

918
00:35:08,960 --> 00:35:11,200
tends to be a modification just prior to

919
00:35:11,200 --> 00:35:13,680
where heaven's gate is located but only

920
00:35:13,680 --> 00:35:16,320
modifications to the actual heavens gate

921
00:35:16,320 --> 00:35:17,760
offset which is the one that's in the

922
00:35:17,760 --> 00:35:20,480
box are found to be malicious through

923
00:35:20,480 --> 00:35:22,640
all experimentation so although

924
00:35:22,640 --> 00:35:24,560
modifications may happen elsewhere in

925
00:35:24,560 --> 00:35:27,119
164 cpu only at the offset for heaven's

926
00:35:27,119 --> 00:35:30,160
gate are we are we concerned um to keep

927
00:35:30,160 --> 00:35:32,320
track of

928
00:35:32,320 --> 00:35:34,800
in order to detect this um it's actually

929
00:35:34,800 --> 00:35:36,720
quite simple with the fast cisco

930
00:35:36,720 --> 00:35:39,040
information from the tib the reason is

931
00:35:39,040 --> 00:35:41,520
that heaven's gate is only nine bytes

932
00:35:41,520 --> 00:35:44,800
big now if you have a known good process

933
00:35:44,800 --> 00:35:47,200
you can actually take uh you can

934
00:35:47,200 --> 00:35:49,680
actually you uh collect the tib

935
00:35:49,680 --> 00:35:52,160
find the fast cisco address extract the

936
00:35:52,160 --> 00:35:54,000
nine bytes and use it as a template for

937
00:35:54,000 --> 00:35:56,640
every other process that is running um

938
00:35:56,640 --> 00:35:59,280
you can't as with previous examples use

939
00:35:59,280 --> 00:36:01,359
the file system version the reason for

940
00:36:01,359 --> 00:36:02,880
this is that heaven's date is

941
00:36:02,880 --> 00:36:06,160
dynamically allocated and so the values

942
00:36:06,160 --> 00:36:07,920
in the file system are never going to

943
00:36:07,920 --> 00:36:10,240
correspond to what is within virtual

944
00:36:10,240 --> 00:36:13,040
volatile memory so you can't compare one

945
00:36:13,040 --> 00:36:14,720
to the other you have to have a known

946
00:36:14,720 --> 00:36:17,839
good well 64 process in order to create

947
00:36:17,839 --> 00:36:20,640
a base against

948
00:36:20,640 --> 00:36:22,800
but compare it by comparing only those

949
00:36:22,800 --> 00:36:24,320
nine bytes which as you can imagine is

950
00:36:24,320 --> 00:36:26,320
quite quick allows you to detect any

951
00:36:26,320 --> 00:36:28,480
malicious hook on this particular

952
00:36:28,480 --> 00:36:31,280
element which can be so nefarious

953
00:36:31,280 --> 00:36:33,839
once if a malicious hook is detected you

954
00:36:33,839 --> 00:36:35,920
can therefore look at the memory address

955
00:36:35,920 --> 00:36:38,480
where the hook goes to and analyze its

956
00:36:38,480 --> 00:36:40,960
content by memory dumping or you know

957
00:36:40,960 --> 00:36:43,119
code analysis or anything like that um

958
00:36:43,119 --> 00:36:45,440
and one example of that would be uh

959
00:36:45,440 --> 00:36:47,839
would be this example so the by sequence

960
00:36:47,839 --> 00:36:50,320
is actually in reverse uh in this case

961
00:36:50,320 --> 00:36:51,839
uh the malicious

962
00:36:51,839 --> 00:36:55,040
hook was detected and the uh hook

963
00:36:55,040 --> 00:36:58,320
content was dumped out for analysis one

964
00:36:58,320 --> 00:37:00,640
of the other things to note is that uh

965
00:37:00,640 --> 00:37:02,480
in order for

966
00:37:02,480 --> 00:37:04,720
heaven's gate uh hooking to work

967
00:37:04,720 --> 00:37:06,560
trampoline has to be implemented now a

968
00:37:06,560 --> 00:37:08,640
trampoline is effectively where the

969
00:37:08,640 --> 00:37:11,040
logistima uh heaven's gate code is

970
00:37:11,040 --> 00:37:14,160
stored elsewhere that the malicious uh

971
00:37:14,160 --> 00:37:16,640
hook will know where it's been moved to

972
00:37:16,640 --> 00:37:18,880
and the reason for this is that the

973
00:37:18,880 --> 00:37:20,480
when the legitimate heavens gate win the

974
00:37:20,480 --> 00:37:22,000
heavens gate legitimate location is

975
00:37:22,000 --> 00:37:24,160
called the malicious hook will then be

976
00:37:24,160 --> 00:37:26,000
called which will perform the magistrate

977
00:37:26,000 --> 00:37:28,079
action and then after that it can then

978
00:37:28,079 --> 00:37:30,800
perform the heavens gate cpu road jump

979
00:37:30,800 --> 00:37:33,040
by simply jumping to the trampoline or

980
00:37:33,040 --> 00:37:35,359
wherever the legislative code has been

981
00:37:35,359 --> 00:37:37,440
moved to um just an extra bit of

982
00:37:37,440 --> 00:37:39,520
information but by useless in this

983
00:37:39,520 --> 00:37:41,280
nine-byte check um during

984
00:37:41,280 --> 00:37:43,920
experimentation it was 100 accurate um

985
00:37:43,920 --> 00:37:46,960
and the information produced was um

986
00:37:46,960 --> 00:37:49,440
it gave great um

987
00:37:49,440 --> 00:37:53,040
great data for further analysis

988
00:37:53,280 --> 00:37:55,280
finally let's look at vectored exception

989
00:37:55,280 --> 00:37:57,280
handlers so first of all let's look at

990
00:37:57,280 --> 00:37:59,920
how exceptional handlers work so try

991
00:37:59,920 --> 00:38:02,800
catch code blocks are an example of

992
00:38:02,800 --> 00:38:04,800
exception handlers so effectively a try

993
00:38:04,800 --> 00:38:07,760
catch block is a frame so these code

994
00:38:07,760 --> 00:38:09,280
blocks um

995
00:38:09,280 --> 00:38:11,839
where you have to try code that code is

996
00:38:11,839 --> 00:38:13,920
within the frame of the cache that

997
00:38:13,920 --> 00:38:16,079
you've implemented and what this means

998
00:38:16,079 --> 00:38:17,200
is that

999
00:38:17,200 --> 00:38:19,359
as as programmers should know if an

1000
00:38:19,359 --> 00:38:21,119
exception is happens within your try

1001
00:38:21,119 --> 00:38:22,880
block and it corresponds to what you

1002
00:38:22,880 --> 00:38:25,200
have specified in your catch statement

1003
00:38:25,200 --> 00:38:27,119
the exception will be handled by your

1004
00:38:27,119 --> 00:38:28,960
catch statement and this effectively

1005
00:38:28,960 --> 00:38:30,560
creates a frame

1006
00:38:30,560 --> 00:38:33,040
for that exception now the exception can

1007
00:38:33,040 --> 00:38:36,720
either be specific or general

1008
00:38:37,760 --> 00:38:39,440
now exceptions actually originate from

1009
00:38:39,440 --> 00:38:41,280
the cpu

1010
00:38:41,280 --> 00:38:43,280
not from the program itself the cpu will

1011
00:38:43,280 --> 00:38:44,880
notice the exceptions happened it will

1012
00:38:44,880 --> 00:38:48,000
then prompt the colonel um in order to

1013
00:38:48,000 --> 00:38:49,760
with relative information which will

1014
00:38:49,760 --> 00:38:52,400
create the environment context exception

1015
00:38:52,400 --> 00:38:54,160
records and all this sort of stuff which

1016
00:38:54,160 --> 00:38:56,480
is then handed back to userland for

1017
00:38:56,480 --> 00:38:59,599
handling within the program itself

1018
00:38:59,599 --> 00:39:02,000
the kernel determines uh what kind of

1019
00:39:02,000 --> 00:39:03,520
exception type it is and what handling

1020
00:39:03,520 --> 00:39:05,520
mechanisms are required based on the

1021
00:39:05,520 --> 00:39:07,680
data that's issued by the cpu the kernel

1022
00:39:07,680 --> 00:39:09,440
does nothing it simply interprets what

1023
00:39:09,440 --> 00:39:11,440
the cpu is telling it and then hands it

1024
00:39:11,440 --> 00:39:13,839
off to userland to actually handle the

1025
00:39:13,839 --> 00:39:16,480
issue um this is typically done through

1026
00:39:16,480 --> 00:39:19,520
nt dll in new zealand

1027
00:39:19,520 --> 00:39:20,720
let's have a quick look at what this

1028
00:39:20,720 --> 00:39:23,119
looks like so after the kernel has

1029
00:39:23,119 --> 00:39:26,560
handed back control i won't go into how

1030
00:39:26,560 --> 00:39:28,400
the kernel handles the cpu information

1031
00:39:28,400 --> 00:39:30,880
and translates it into a trap frame and

1032
00:39:30,880 --> 00:39:33,200
then the environment and um exception

1033
00:39:33,200 --> 00:39:34,400
records and all that sort of stuff we're

1034
00:39:34,400 --> 00:39:36,240
going to look at the user land so once

1035
00:39:36,240 --> 00:39:40,160
it's handed back control to um

1036
00:39:40,160 --> 00:39:42,160
userland from kernel using an iraq

1037
00:39:42,160 --> 00:39:44,079
command the trap frame environment

1038
00:39:44,079 --> 00:39:45,680
contacts and exception record are all

1039
00:39:45,680 --> 00:39:47,839
available within the user stack but the

1040
00:39:47,839 --> 00:39:50,480
trap frame will have an eip which will

1041
00:39:50,480 --> 00:39:52,720
trigger the use of ki user exception

1042
00:39:52,720 --> 00:39:54,880
handler within ntdl

1043
00:39:54,880 --> 00:39:57,680
this will subsequently call rtl dispatch

1044
00:39:57,680 --> 00:40:00,320
exception which uses the information

1045
00:40:00,320 --> 00:40:01,760
from the environment context and

1046
00:40:01,760 --> 00:40:03,680
exception record provided from the

1047
00:40:03,680 --> 00:40:05,520
kernel by translating information with

1048
00:40:05,520 --> 00:40:07,520
the cpu to know

1049
00:40:07,520 --> 00:40:09,599
what frame the exception has occurred

1050
00:40:09,599 --> 00:40:11,839
from within which process

1051
00:40:11,839 --> 00:40:15,359
and from that it then scans the lowest

1052
00:40:15,359 --> 00:40:17,359
frame again provided by the environment

1053
00:40:17,359 --> 00:40:19,760
context and starts to check the frames

1054
00:40:19,760 --> 00:40:21,839
outwards and effectively what this means

1055
00:40:21,839 --> 00:40:24,960
is if the first frame attribute

1056
00:40:24,960 --> 00:40:26,800
adequately handles the exception that's

1057
00:40:26,800 --> 00:40:28,960
been specified it doesn't need to go any

1058
00:40:28,960 --> 00:40:31,040
further but if not it will move out and

1059
00:40:31,040 --> 00:40:32,319
out and out and out and out through all

1060
00:40:32,319 --> 00:40:34,640
the frames containing it until it will

1061
00:40:34,640 --> 00:40:37,680
reach the end of the exception frames or

1062
00:40:37,680 --> 00:40:39,920
the exception lists and if it does that

1063
00:40:39,920 --> 00:40:42,000
it then turns into a general exception

1064
00:40:42,000 --> 00:40:43,599
which normally causes the program to

1065
00:40:43,599 --> 00:40:45,520
crash

1066
00:40:45,520 --> 00:40:47,040
so

1067
00:40:47,040 --> 00:40:49,280
i've been saying um frames and

1068
00:40:49,280 --> 00:40:51,440
exceptions but frame based exceptions

1069
00:40:51,440 --> 00:40:53,200
are actually what we call structured

1070
00:40:53,200 --> 00:40:56,400
exception handlers or seh so a try catch

1071
00:40:56,400 --> 00:40:58,640
block is an example of an sch it is a

1072
00:40:58,640 --> 00:41:01,200
friend based exception which is very

1073
00:41:01,200 --> 00:41:02,960
specific

1074
00:41:02,960 --> 00:41:04,560
but whereas with the try catch block

1075
00:41:04,560 --> 00:41:06,240
again if you have a try block and a

1076
00:41:06,240 --> 00:41:07,839
catch but the catch doesn't check the

1077
00:41:07,839 --> 00:41:09,599
exception it will then move to the

1078
00:41:09,599 --> 00:41:11,440
surrounding frame to see whether that

1079
00:41:11,440 --> 00:41:13,200
can handle the exception and move

1080
00:41:13,200 --> 00:41:14,800
further and further out as i just

1081
00:41:14,800 --> 00:41:15,839
explained

1082
00:41:15,839 --> 00:41:19,440
the sch adds to a chain

1083
00:41:19,440 --> 00:41:23,119
so the seh list uh is actually connected

1084
00:41:23,119 --> 00:41:24,800
one after the other and it will do it as

1085
00:41:24,800 --> 00:41:26,000
again from a

1086
00:41:26,000 --> 00:41:27,520
lowest frame and it will start to move

1087
00:41:27,520 --> 00:41:29,520
outwards

1088
00:41:29,520 --> 00:41:31,920
um if the chain is exhausted it will

1089
00:41:31,920 --> 00:41:33,280
move to a general handler which is

1090
00:41:33,280 --> 00:41:35,599
normally at a kernel system level which

1091
00:41:35,599 --> 00:41:37,680
normally causes the program to crash and

1092
00:41:37,680 --> 00:41:39,040
if not the program to crash it can cause

1093
00:41:39,040 --> 00:41:40,800
the operating system to crash so it's

1094
00:41:40,800 --> 00:41:42,079
not something you want to have haven't

1095
00:41:42,079 --> 00:41:43,680
then that hence why exception handling

1096
00:41:43,680 --> 00:41:46,160
is is quite important um

1097
00:41:46,160 --> 00:41:48,000
well programmed to crash not likely the

1098
00:41:48,000 --> 00:41:51,359
kernel depends what you're doing um

1099
00:41:51,359 --> 00:41:53,520
but what exactly is a vector exception

1100
00:41:53,520 --> 00:41:57,520
handler so vh are not frame specific so

1101
00:41:57,520 --> 00:42:00,640
where is sch or um structured exemption

1102
00:42:00,640 --> 00:42:03,200
is said are very frame specific vector

1103
00:42:03,200 --> 00:42:05,280
exception handlers are the alternative

1104
00:42:05,280 --> 00:42:08,000
so instead of being friend specific they

1105
00:42:08,000 --> 00:42:11,599
override the priority of seh and have a

1106
00:42:11,599 --> 00:42:13,440
high priority and effectively the

1107
00:42:13,440 --> 00:42:14,880
exception that is generated from the

1108
00:42:14,880 --> 00:42:16,480
kernel within the

1109
00:42:16,480 --> 00:42:18,560
exception record will be checked against

1110
00:42:18,560 --> 00:42:21,200
the vectored exception handler first

1111
00:42:21,200 --> 00:42:23,359
before it moves to the structured

1112
00:42:23,359 --> 00:42:24,880
exception handlers

1113
00:42:24,880 --> 00:42:26,880
for that process

1114
00:42:26,880 --> 00:42:29,040
this was introduced within windows xp

1115
00:42:29,040 --> 00:42:31,520
specifically to be able to override the

1116
00:42:31,520 --> 00:42:33,280
seh from a developer standpoint so they

1117
00:42:33,280 --> 00:42:34,800
instead of having to find a particular

1118
00:42:34,800 --> 00:42:36,240
exception frame you could just install a

1119
00:42:36,240 --> 00:42:37,680
v8 and it would overwrite the

1120
00:42:37,680 --> 00:42:39,520
exceptionalities you had in place but

1121
00:42:39,520 --> 00:42:41,520
because of that veh has an inherent

1122
00:42:41,520 --> 00:42:44,079
higher priority and will run first and

1123
00:42:44,079 --> 00:42:46,800
the way it did this or how uh microsoft

1124
00:42:46,800 --> 00:42:49,040
did this was to install rtl cool

1125
00:42:49,040 --> 00:42:50,960
vectored exception handlers

1126
00:42:50,960 --> 00:42:53,680
within the um exception handler process

1127
00:42:53,680 --> 00:42:57,359
within nt dll so rtl dispatch exception

1128
00:42:57,359 --> 00:42:59,520
which we just saw handles hands off and

1129
00:42:59,520 --> 00:43:01,280
starts to scan through the frames

1130
00:43:01,280 --> 00:43:04,079
instead we'll call rtl callback to

1131
00:43:04,079 --> 00:43:06,560
exception handlers and scan the vectored

1132
00:43:06,560 --> 00:43:08,079
handler list

1133
00:43:08,079 --> 00:43:10,960
first now this is very important because

1134
00:43:10,960 --> 00:43:12,880
this means that no matter what you do

1135
00:43:12,880 --> 00:43:15,359
vector x v h vectors from channels will

1136
00:43:15,359 --> 00:43:17,599
always have a higher priority and if an

1137
00:43:17,599 --> 00:43:19,520
exception is deception handler is found

1138
00:43:19,520 --> 00:43:21,920
for that exception type within the veh

1139
00:43:21,920 --> 00:43:24,160
um it will handle the exception

1140
00:43:24,160 --> 00:43:27,040
regardless of whether an seh exists

1141
00:43:27,040 --> 00:43:29,119
now each handler instance can handle

1142
00:43:29,119 --> 00:43:31,599
multiple exception types so whereas the

1143
00:43:31,599 --> 00:43:33,920
seh you normally have to have a specific

1144
00:43:33,920 --> 00:43:35,359
exception type or a general exception

1145
00:43:35,359 --> 00:43:38,400
type veh can handle multiple specific

1146
00:43:38,400 --> 00:43:40,400
exception types and it does this by

1147
00:43:40,400 --> 00:43:41,920
within the handler

1148
00:43:41,920 --> 00:43:43,839
actually do a comparison between what is

1149
00:43:43,839 --> 00:43:46,480
inside the exception context against

1150
00:43:46,480 --> 00:43:48,400
what is within the vector extension

1151
00:43:48,400 --> 00:43:50,319
handler for what it can what it can

1152
00:43:50,319 --> 00:43:52,000
handle

1153
00:43:52,000 --> 00:43:54,400
um and this is important because vex

1154
00:43:54,400 --> 00:43:56,480
exception handlers can handle

1155
00:43:56,480 --> 00:43:58,720
vast arrays of exception types depending

1156
00:43:58,720 --> 00:44:00,480
on how they're built which can make them

1157
00:44:00,480 --> 00:44:02,240
uh quite clunky but equally you can make

1158
00:44:02,240 --> 00:44:03,040
them

1159
00:44:03,040 --> 00:44:06,160
um very uh sort of like a catch-all

1160
00:44:06,160 --> 00:44:08,079
which is quite nice um adding to the

1161
00:44:08,079 --> 00:44:09,200
list can be either be done at the front

1162
00:44:09,200 --> 00:44:10,960
of the end um at the user discretion so

1163
00:44:10,960 --> 00:44:12,400
you can either have the highest priority

1164
00:44:12,400 --> 00:44:13,680
or the lowest priority depending on how

1165
00:44:13,680 --> 00:44:15,440
you perform the veh but as you can

1166
00:44:15,440 --> 00:44:16,720
imagine from a malicious access

1167
00:44:16,720 --> 00:44:18,240
standpoint you're going to want to be at

1168
00:44:18,240 --> 00:44:19,599
the front of the list so that no matter

1169
00:44:19,599 --> 00:44:21,520
what exception comes in your vehicle is

1170
00:44:21,520 --> 00:44:23,119
being checked first but what's

1171
00:44:23,119 --> 00:44:26,000
interesting is that you can add a veh

1172
00:44:26,000 --> 00:44:27,760
on the command just before you know

1173
00:44:27,760 --> 00:44:29,040
you're going to do something nefarious

1174
00:44:29,040 --> 00:44:30,480
which will cause the exception so you

1175
00:44:30,480 --> 00:44:32,319
know your exception handler is going to

1176
00:44:32,319 --> 00:44:33,599
be called first

1177
00:44:33,599 --> 00:44:35,760
a vh list is circular uh this is

1178
00:44:35,760 --> 00:44:37,200
something just to know that effectively

1179
00:44:37,200 --> 00:44:38,400
when he reaches the end of the list it

1180
00:44:38,400 --> 00:44:39,760
will go back to the start so there has

1181
00:44:39,760 --> 00:44:42,079
to be a check against what um vectors

1182
00:44:42,079 --> 00:44:44,160
exceptional handler entry id it is so

1183
00:44:44,160 --> 00:44:45,440
you know when you've reached another

1184
00:44:45,440 --> 00:44:48,000
list and finally the handler function

1185
00:44:48,000 --> 00:44:50,240
pointers are encoded using a process

1186
00:44:50,240 --> 00:44:51,599
specific cookie

1187
00:44:51,599 --> 00:44:53,520
so only by using the process-specific

1188
00:44:53,520 --> 00:44:55,119
cookie can you actually find the

1189
00:44:55,119 --> 00:44:57,200
handler's uh legitimate pointer address

1190
00:44:57,200 --> 00:44:59,520
and find the handler code

1191
00:44:59,520 --> 00:45:00,960
so let's look at some of them are just

1192
00:45:00,960 --> 00:45:03,599
malicious uses so as we said veh will

1193
00:45:03,599 --> 00:45:05,920
always be done first regardless of what

1194
00:45:05,920 --> 00:45:08,480
seh is in place and vh can be added at

1195
00:45:08,480 --> 00:45:11,440
any point um because of this it can

1196
00:45:11,440 --> 00:45:12,880
prevent code integrity checks

1197
00:45:12,880 --> 00:45:14,480
specifically with pageguard which i will

1198
00:45:14,480 --> 00:45:16,319
show you a great example of in a second

1199
00:45:16,319 --> 00:45:18,560
it can perform force jumps this is to do

1200
00:45:18,560 --> 00:45:20,319
with how vetted exception handlers are

1201
00:45:20,319 --> 00:45:23,280
added to the veh list and it can also

1202
00:45:23,280 --> 00:45:25,359
suddenly bypass functions now this is

1203
00:45:25,359 --> 00:45:27,359
where um the security

1204
00:45:27,359 --> 00:45:28,400
um

1205
00:45:28,400 --> 00:45:29,920
malicious memory manipulation is going

1206
00:45:29,920 --> 00:45:30,880
to take place and i'm going to give you

1207
00:45:30,880 --> 00:45:34,079
a great example of that uh in a minute

1208
00:45:34,079 --> 00:45:35,920
so vh can hijack the acceptance change

1209
00:45:35,920 --> 00:45:37,920
because it's a higher priority than seh

1210
00:45:37,920 --> 00:45:40,160
um and it can need to be done against a

1211
00:45:40,160 --> 00:45:41,520
victim process as long as there is

1212
00:45:41,520 --> 00:45:43,200
adequate access or it can be done

1213
00:45:43,200 --> 00:45:45,119
against a malicious program simply just

1214
00:45:45,119 --> 00:45:46,480
to

1215
00:45:46,480 --> 00:45:49,359
remove any visibility um by security

1216
00:45:49,359 --> 00:45:52,000
vendors by um checking for these uh for

1217
00:45:52,000 --> 00:45:53,359
if there is

1218
00:45:53,359 --> 00:45:56,000
exception generated behavior

1219
00:45:56,000 --> 00:45:57,920
so let's look at code integrity check so

1220
00:45:57,920 --> 00:46:00,240
this is actually from a researcher shen

1221
00:46:00,240 --> 00:46:02,160
um and they violate the page guard

1222
00:46:02,160 --> 00:46:05,680
exception and then effectively use vh to

1223
00:46:05,680 --> 00:46:08,160
they install a veh seconds before they

1224
00:46:08,160 --> 00:46:10,880
violate the page guard uh page card

1225
00:46:10,880 --> 00:46:13,119
which creates a status page guard a

1226
00:46:13,119 --> 00:46:15,520
guard page violation exception

1227
00:46:15,520 --> 00:46:18,000
but their vh effectively goes

1228
00:46:18,000 --> 00:46:20,079
okay that's happened but don't worry

1229
00:46:20,079 --> 00:46:21,280
about it

1230
00:46:21,280 --> 00:46:24,640
because their veh has a higher priority

1231
00:46:24,640 --> 00:46:25,520
um

1232
00:46:25,520 --> 00:46:27,119
the program just goes yeah that's fine

1233
00:46:27,119 --> 00:46:28,880
the exception's been handled what they

1234
00:46:28,880 --> 00:46:31,119
actually do is inside their veh box they

1235
00:46:31,119 --> 00:46:33,920
reassert the uh

1236
00:46:33,920 --> 00:46:36,240
guard flag of that particular page so

1237
00:46:36,240 --> 00:46:38,720
they violate it have the exception

1238
00:46:38,720 --> 00:46:40,800
reassert the flag within the exception

1239
00:46:40,800 --> 00:46:42,319
handler and then hand back to the

1240
00:46:42,319 --> 00:46:43,520
process saying yeah everything was

1241
00:46:43,520 --> 00:46:45,920
handled so from that they're able to

1242
00:46:45,920 --> 00:46:47,040
basically

1243
00:46:47,040 --> 00:46:49,520
um violate pageguard

1244
00:46:49,520 --> 00:46:51,359
as they see fit as long as the vehicle

1245
00:46:51,359 --> 00:46:53,839
is in place to handle it which is uh

1246
00:46:53,839 --> 00:46:55,200
which can get around a lot of integrity

1247
00:46:55,200 --> 00:46:57,680
checks which is quite cool

1248
00:46:57,680 --> 00:46:59,440
force jump um as i said this is to do

1249
00:46:59,440 --> 00:47:01,599
with how effective handlers are added so

1250
00:47:01,599 --> 00:47:03,440
add vectors exception handler is the

1251
00:47:03,440 --> 00:47:05,440
primary function for adding veh to a

1252
00:47:05,440 --> 00:47:08,079
system or a running process

1253
00:47:08,079 --> 00:47:09,839
but add vector exception and that

1254
00:47:09,839 --> 00:47:11,760
actually only requires a

1255
00:47:11,760 --> 00:47:14,079
um handler pointer or just a pointer to

1256
00:47:14,079 --> 00:47:17,440
be uh to be uh added as an argument so

1257
00:47:17,440 --> 00:47:20,319
from this you can allocate memory with a

1258
00:47:20,319 --> 00:47:23,200
bunch of malicious shell code and then

1259
00:47:23,200 --> 00:47:25,440
hand it off to a v and then add it as a

1260
00:47:25,440 --> 00:47:27,839
veh and then as soon as an exception

1261
00:47:27,839 --> 00:47:28,880
comes in as long as you put it at the

1262
00:47:28,880 --> 00:47:30,800
front of the queue your shell code is

1263
00:47:30,800 --> 00:47:33,359
going to get executed so you effectively

1264
00:47:33,359 --> 00:47:36,319
found an exception based shell code

1265
00:47:36,319 --> 00:47:39,440
execution mechanism by using veh which

1266
00:47:39,440 --> 00:47:40,240
is

1267
00:47:40,240 --> 00:47:42,319
pretty cool

1268
00:47:42,319 --> 00:47:45,040
sounding bypassing is um the one that

1269
00:47:45,040 --> 00:47:47,119
we're really going to look at so veh has

1270
00:47:47,119 --> 00:47:50,720
the capability so when a handler

1271
00:47:50,720 --> 00:47:52,559
when you when you're generating a vh

1272
00:47:52,559 --> 00:47:53,760
handler

1273
00:47:53,760 --> 00:47:55,359
it can when it's handing an exception

1274
00:47:55,359 --> 00:47:56,480
type

1275
00:47:56,480 --> 00:47:58,640
it has two results it can either have

1276
00:47:58,640 --> 00:48:00,400
exception continue execution or

1277
00:48:00,400 --> 00:48:02,640
exception continue search and what this

1278
00:48:02,640 --> 00:48:05,200
means is continue execution means uh the

1279
00:48:05,200 --> 00:48:07,119
exception has been handled hand back to

1280
00:48:07,119 --> 00:48:09,599
the process continue execution continue

1281
00:48:09,599 --> 00:48:12,640
search means my handler wasn't able to

1282
00:48:12,640 --> 00:48:14,800
handle the exception generated move to

1283
00:48:14,800 --> 00:48:17,599
the next in the list now because of this

1284
00:48:17,599 --> 00:48:19,760
if you deliberately generate errors or

1285
00:48:19,760 --> 00:48:22,800
you know that an error is going to be

1286
00:48:22,800 --> 00:48:24,400
generated

1287
00:48:24,400 --> 00:48:26,720
as with the page card you can actually

1288
00:48:26,720 --> 00:48:27,760
just say

1289
00:48:27,760 --> 00:48:29,680
hey this has happened don't do anything

1290
00:48:29,680 --> 00:48:31,440
about it and

1291
00:48:31,440 --> 00:48:33,200
move on with the process but equally

1292
00:48:33,200 --> 00:48:36,160
what you could do is you could say okay

1293
00:48:36,160 --> 00:48:38,160
i know that a function is going to be

1294
00:48:38,160 --> 00:48:39,599
called in a second but i don't want to

1295
00:48:39,599 --> 00:48:42,960
happen so let's say i did a divide by

1296
00:48:42,960 --> 00:48:45,200
zero which we'll call it an exception um

1297
00:48:45,200 --> 00:48:47,119
and from that i'm going to change the

1298
00:48:47,119 --> 00:48:49,680
function pointer to go just after the

1299
00:48:49,680 --> 00:48:51,599
command that i don't want to occur and

1300
00:48:51,599 --> 00:48:54,960
then hand back to the running function

1301
00:48:54,960 --> 00:48:57,119
and it'll work um from this you're able

1302
00:48:57,119 --> 00:49:00,160
to basically jump around

1303
00:49:00,160 --> 00:49:01,920
malicious the code that you don't want

1304
00:49:01,920 --> 00:49:05,040
to execute or by basically

1305
00:49:05,040 --> 00:49:07,599
deliberately triggering uh exceptions as

1306
00:49:07,599 --> 00:49:09,760
long as the veh is in place because it

1307
00:49:09,760 --> 00:49:12,240
will have a higher priority um which

1308
00:49:12,240 --> 00:49:13,119
which is

1309
00:49:13,119 --> 00:49:15,839
very very cool

1310
00:49:15,839 --> 00:49:18,079
detection of this relies on a number of

1311
00:49:18,079 --> 00:49:20,160
things but primarily you need to know

1312
00:49:20,160 --> 00:49:23,520
where the veh list is so uh prior work

1313
00:49:23,520 --> 00:49:26,400
done by researcher dimitri uh forney um

1314
00:49:26,400 --> 00:49:28,800
did some really great work

1315
00:49:28,800 --> 00:49:31,280
and he found that the veh list was

1316
00:49:31,280 --> 00:49:34,319
actually stored in ntdl and it was under

1317
00:49:34,319 --> 00:49:37,040
the pointer ldrp

1318
00:49:37,040 --> 00:49:39,680
vector handler list and what he found

1319
00:49:39,680 --> 00:49:41,680
was is that by scanning heuristically

1320
00:49:41,680 --> 00:49:43,280
for a particular pattern

1321
00:49:43,280 --> 00:49:46,800
within a known ntdl function you could

1322
00:49:46,800 --> 00:49:49,359
find this pointer and from that you

1323
00:49:49,359 --> 00:49:51,359
could extract the list of veh and

1324
00:49:51,359 --> 00:49:53,839
enumerate through it um really recommend

1325
00:49:53,839 --> 00:49:55,920
reading his work he did some great

1326
00:49:55,920 --> 00:49:57,440
examples of this

1327
00:49:57,440 --> 00:49:59,119
and a lot of information on how the

1328
00:49:59,119 --> 00:50:00,480
heuristics work

1329
00:50:00,480 --> 00:50:02,960
but effectively the list is not exported

1330
00:50:02,960 --> 00:50:04,640
is not externally available so you have

1331
00:50:04,640 --> 00:50:07,040
to do this um

1332
00:50:07,040 --> 00:50:09,359
reach into the ntdl systems in order to

1333
00:50:09,359 --> 00:50:10,800
find the pointer and extract the list

1334
00:50:10,800 --> 00:50:13,599
which is which is a nuisance

1335
00:50:13,599 --> 00:50:16,240
the other thing to note is that the

1336
00:50:16,240 --> 00:50:18,000
handler point as we said earlier is

1337
00:50:18,000 --> 00:50:19,760
actually encoded by the particular

1338
00:50:19,760 --> 00:50:22,079
process cookie and in order to decode

1339
00:50:22,079 --> 00:50:24,000
this you have to use a combination of

1340
00:50:24,000 --> 00:50:26,000
query information process and roto right

1341
00:50:26,000 --> 00:50:28,960
64. um ollie whitehouse over at ncc

1342
00:50:28,960 --> 00:50:33,520
group did a brilliant um poc on the veh

1343
00:50:33,520 --> 00:50:36,079
enumeration where he actually solved all

1344
00:50:36,079 --> 00:50:37,359
of these problems and allowed the

1345
00:50:37,359 --> 00:50:40,240
handler pointer for x64 uh process

1346
00:50:40,240 --> 00:50:42,559
handlers to be decoded and attributed to

1347
00:50:42,559 --> 00:50:45,599
their um modules and process spaces uh

1348
00:50:45,599 --> 00:50:47,520
again really recommend reading that work

1349
00:50:47,520 --> 00:50:50,880
um it really jumpstarted everything uh

1350
00:50:50,880 --> 00:50:52,400
it was very impressive do recommend

1351
00:50:52,400 --> 00:50:54,880
reading that um

1352
00:50:54,880 --> 00:50:57,599
but one of the things that's important

1353
00:50:57,599 --> 00:50:59,680
from a vected exception handler

1354
00:50:59,680 --> 00:51:02,079
detection standpoint is what exceptions

1355
00:51:02,079 --> 00:51:04,400
they are handling so although you can

1356
00:51:04,400 --> 00:51:06,000
see when a veh has been generated and

1357
00:51:06,000 --> 00:51:07,440
what module they're attributed to that

1358
00:51:07,440 --> 00:51:10,319
that that's great but unless you know

1359
00:51:10,319 --> 00:51:11,920
what they're doing within the handler or

1360
00:51:11,920 --> 00:51:13,839
what exception types they're looking for

1361
00:51:13,839 --> 00:51:14,880
um

1362
00:51:14,880 --> 00:51:16,480
it's not necessarily going to provide

1363
00:51:16,480 --> 00:51:19,040
that much value um

1364
00:51:19,040 --> 00:51:20,880
but by checking the exception type you

1365
00:51:20,880 --> 00:51:23,040
can actually check for again as the

1366
00:51:23,040 --> 00:51:24,079
example at the bottom of the window

1367
00:51:24,079 --> 00:51:26,240
shows integer divided by zero so if

1368
00:51:26,240 --> 00:51:28,240
you're looking at a divide by zero which

1369
00:51:28,240 --> 00:51:29,440
is in a

1370
00:51:29,440 --> 00:51:32,400
randomly named process you can say that

1371
00:51:32,400 --> 00:51:35,200
this is likely going to be a

1372
00:51:35,200 --> 00:51:37,760
vh malicious instance now this can be

1373
00:51:37,760 --> 00:51:39,920
done using opcode heuristics by checking

1374
00:51:39,920 --> 00:51:42,319
for comparison operators um because all

1375
00:51:42,319 --> 00:51:45,040
handlers will have to check the uh

1376
00:51:45,040 --> 00:51:47,839
exception context exception type against

1377
00:51:47,839 --> 00:51:49,440
a known exception type to see whether it

1378
00:51:49,440 --> 00:51:50,880
matches and to know whether it needs to

1379
00:51:50,880 --> 00:51:52,079
be handled

1380
00:51:52,079 --> 00:51:54,640
which is a really easy way of finding

1381
00:51:54,640 --> 00:51:56,559
what exception types are being used and

1382
00:51:56,559 --> 00:51:58,880
from this it allows you to do a process

1383
00:51:58,880 --> 00:52:00,960
to exception type comparison to see

1384
00:52:00,960 --> 00:52:02,640
whether there's a mismatch and this is

1385
00:52:02,640 --> 00:52:04,880
especially true about certain debugging

1386
00:52:04,880 --> 00:52:07,119
exceptions um which is actually key to a

1387
00:52:07,119 --> 00:52:09,359
case i'm going to come to in a second so

1388
00:52:09,359 --> 00:52:12,160
when it comes to detection criteria

1389
00:52:12,160 --> 00:52:14,480
um pointers outside processor module

1390
00:52:14,480 --> 00:52:16,640
space i.e virtual along just anywhere

1391
00:52:16,640 --> 00:52:18,960
for shell code pointer to anomalous

1392
00:52:18,960 --> 00:52:20,480
module functions so again if there's a

1393
00:52:20,480 --> 00:52:22,800
randomly named module and this vh is

1394
00:52:22,800 --> 00:52:26,240
pointing to it pretty suspicious um

1395
00:52:26,240 --> 00:52:28,880
pointer location has cow in legislative

1396
00:52:28,880 --> 00:52:30,720
modern so this is to say

1397
00:52:30,720 --> 00:52:32,720
copy on write which is effectively a

1398
00:52:32,720 --> 00:52:35,680
page modification a shared library if uh

1399
00:52:35,680 --> 00:52:37,839
the process if the va is pointing to a

1400
00:52:37,839 --> 00:52:39,440
process specific memory page within a

1401
00:52:39,440 --> 00:52:42,319
legitimate module only that page that's

1402
00:52:42,319 --> 00:52:43,839
pretty sus and should probably be looked

1403
00:52:43,839 --> 00:52:45,200
at to make sure that that particular

1404
00:52:45,200 --> 00:52:47,200
function hasn't been hooked um in order

1405
00:52:47,200 --> 00:52:49,119
to prevent further malicious action by

1406
00:52:49,119 --> 00:52:51,040
basically triggering off from that hook

1407
00:52:51,040 --> 00:52:52,720
point to location containing shell code

1408
00:52:52,720 --> 00:52:54,400
again this can be done through

1409
00:52:54,400 --> 00:52:56,000
memory dumps of the

1410
00:52:56,000 --> 00:52:57,920
handler code or just through general

1411
00:52:57,920 --> 00:52:59,040
heuristics

1412
00:52:59,040 --> 00:53:01,119
an event type handler is unusual again

1413
00:53:01,119 --> 00:53:02,559
as i said depending on the process and

1414
00:53:02,559 --> 00:53:04,160
the handler type you can actually make

1415
00:53:04,160 --> 00:53:05,680
an association between what handler

1416
00:53:05,680 --> 00:53:07,680
types are standard off for that process

1417
00:53:07,680 --> 00:53:11,598
or equally standard for a system

1418
00:53:11,839 --> 00:53:15,280
so the example for um edr bypassing

1419
00:53:15,280 --> 00:53:18,800
using beh is firewalker so firewalker

1420
00:53:18,800 --> 00:53:22,160
was developed by mdsec back in 2020 um

1421
00:53:22,160 --> 00:53:25,599
and it it's a brilliant um poc

1422
00:53:25,599 --> 00:53:27,680
effectively what it does is it stands

1423
00:53:27,680 --> 00:53:28,559
for

1424
00:53:28,559 --> 00:53:31,040
edr hooks on

1425
00:53:31,040 --> 00:53:32,720
known functions

1426
00:53:32,720 --> 00:53:34,480
um for their telemetry gathering for

1427
00:53:34,480 --> 00:53:37,440
security purposes and steps around them

1428
00:53:37,440 --> 00:53:40,000
using veh um

1429
00:53:40,000 --> 00:53:42,000
it does this by scanning for point point

1430
00:53:42,000 --> 00:53:44,400
to duplication or func scanning um and

1431
00:53:44,400 --> 00:53:45,839
trap frame single step generation five

1432
00:53:45,839 --> 00:53:47,680
registry manipulation i won't go into

1433
00:53:47,680 --> 00:53:49,359
those um the second part about trap

1434
00:53:49,359 --> 00:53:50,960
frame single step effectively they

1435
00:53:50,960 --> 00:53:53,119
manipulate uh one of the registries to

1436
00:53:53,119 --> 00:53:56,319
trigger a single step uh exception which

1437
00:53:56,319 --> 00:53:58,640
is what triggers their va or malicious

1438
00:53:58,640 --> 00:54:00,400
veh into working

1439
00:54:00,400 --> 00:54:02,400
which is the bottom example of vh

1440
00:54:02,400 --> 00:54:04,160
exception single step handling and

1441
00:54:04,160 --> 00:54:06,960
that's where we're going to look

1442
00:54:06,960 --> 00:54:09,839
so operation is it creates a vh entry

1443
00:54:09,839 --> 00:54:12,400
for the exception type single step sets

1444
00:54:12,400 --> 00:54:15,280
the tf flag uh in the registry in order

1445
00:54:15,280 --> 00:54:17,280
to make the exception single step

1446
00:54:17,280 --> 00:54:18,880
exception uh

1447
00:54:18,880 --> 00:54:19,920
uh

1448
00:54:19,920 --> 00:54:22,160
because on each individual execution

1449
00:54:22,160 --> 00:54:24,480
that's done it then caused the desired

1450
00:54:24,480 --> 00:54:26,720
function knowing the single step

1451
00:54:26,720 --> 00:54:29,440
exception is going to fire then it uses

1452
00:54:29,440 --> 00:54:32,480
the veh to scan each subsequent

1453
00:54:32,480 --> 00:54:34,240
inspection to see whether it's a jump

1454
00:54:34,240 --> 00:54:35,440
command

1455
00:54:35,440 --> 00:54:38,720
or a hook command and if it is it then

1456
00:54:38,720 --> 00:54:41,119
scans the memory to see whether there is

1457
00:54:41,119 --> 00:54:44,160
a subsequent duplication or basically a

1458
00:54:44,160 --> 00:54:46,240
trampoline back to the same code which

1459
00:54:46,240 --> 00:54:49,599
would indicate a hook um if it is found

1460
00:54:49,599 --> 00:54:52,160
it then replaces that jump with the

1461
00:54:52,160 --> 00:54:54,160
trampoline and then it basically jumps

1462
00:54:54,160 --> 00:54:56,880
itself back into the adjustment process

1463
00:54:56,880 --> 00:54:59,440
without executing the edr's hooked

1464
00:54:59,440 --> 00:55:03,280
function so it scans so you create a veh

1465
00:55:03,280 --> 00:55:05,119
you trigger it to make these exceptions

1466
00:55:05,119 --> 00:55:07,200
on each subsequent command you then run

1467
00:55:07,200 --> 00:55:08,960
the process you want and you check to

1468
00:55:08,960 --> 00:55:11,920
see whether it jumps to uh it

1469
00:55:11,920 --> 00:55:13,920
does a hook or a hook jump and if it

1470
00:55:13,920 --> 00:55:15,440
does you then scan to see whether it's

1471
00:55:15,440 --> 00:55:17,680
duplicated and if it is you just jump

1472
00:55:17,680 --> 00:55:20,880
around it and avoid the edr um telemetry

1473
00:55:20,880 --> 00:55:24,079
acquisition altogether um and then after

1474
00:55:24,079 --> 00:55:26,640
that you can just remove the veh um

1475
00:55:26,640 --> 00:55:28,799
reset the tta flag and continue your

1476
00:55:28,799 --> 00:55:29,839
operation

1477
00:55:29,839 --> 00:55:32,960
a brilliant a really really really cool

1478
00:55:32,960 --> 00:55:35,200
um concept and

1479
00:55:35,200 --> 00:55:37,040
although it has its limitations a really

1480
00:55:37,040 --> 00:55:39,760
cool con really cool capability

1481
00:55:39,760 --> 00:55:41,280
but one of the things about detecting

1482
00:55:41,280 --> 00:55:44,640
this is the fact that it uses veh now as

1483
00:55:44,640 --> 00:55:46,480
i said earlier the exception types that

1484
00:55:46,480 --> 00:55:47,920
are monitored for is one of the things

1485
00:55:47,920 --> 00:55:51,200
that can be really easy to detect on so

1486
00:55:51,200 --> 00:55:53,359
exception single step outside the use

1487
00:55:53,359 --> 00:55:55,119
inside a debugger

1488
00:55:55,119 --> 00:55:56,480
yeah that's something that should be

1489
00:55:56,480 --> 00:55:59,040
flagged and really easy to basically say

1490
00:55:59,040 --> 00:56:00,319
something's not right here and it needs

1491
00:56:00,319 --> 00:56:02,480
to be looked at um and as i said the

1492
00:56:02,480 --> 00:56:05,119
vehicle type the process nature

1493
00:56:05,119 --> 00:56:07,680
easily equals detection uh again if you

1494
00:56:07,680 --> 00:56:12,559
have a calculator doing um you know uh

1495
00:56:12,559 --> 00:56:15,200
buffer overload exception handling um

1496
00:56:15,200 --> 00:56:16,720
but then there's got like three

1497
00:56:16,720 --> 00:56:19,119
instances of it or two instances of it

1498
00:56:19,119 --> 00:56:20,240
not going to be right especially in the

1499
00:56:20,240 --> 00:56:21,520
vh because that should be something that

1500
00:56:21,520 --> 00:56:23,520
should be sch so it's something that can

1501
00:56:23,520 --> 00:56:26,079
be easily monitored for now people would

1502
00:56:26,079 --> 00:56:28,480
say that this could be handled by seh

1503
00:56:28,480 --> 00:56:31,599
but again because um

1504
00:56:31,599 --> 00:56:33,599
sch could be used instead of the eh in

1505
00:56:33,599 --> 00:56:36,160
fire walkers mechanism but because vh

1506
00:56:36,160 --> 00:56:37,520
has a high priority and it's easy to

1507
00:56:37,520 --> 00:56:40,319
code and it has it's just more dynamic

1508
00:56:40,319 --> 00:56:42,559
attackers will tend to use vh over seh

1509
00:56:42,559 --> 00:56:44,319
simply because it has it's much easier

1510
00:56:44,319 --> 00:56:45,920
to use

1511
00:56:45,920 --> 00:56:47,280
one of the final things to know about

1512
00:56:47,280 --> 00:56:52,839
veh is the x86 issue uh namely that the

1513
00:56:52,839 --> 00:56:56,240
veh4x86 process is stored within the x64

1514
00:56:56,240 --> 00:57:00,079
nt dll and as such cannot be accessed by

1515
00:57:00,079 --> 00:57:03,200
uh x86 processes which when you're

1516
00:57:03,200 --> 00:57:05,119
enumerating them and trying to process

1517
00:57:05,119 --> 00:57:06,880
the handler and see what's inside them

1518
00:57:06,880 --> 00:57:08,319
makes it very difficult you end up with

1519
00:57:08,319 --> 00:57:10,079
this memory access violation where

1520
00:57:10,079 --> 00:57:12,880
you're trying to access 64-bit memory

1521
00:57:12,880 --> 00:57:15,359
from x86 now this is a physical address

1522
00:57:15,359 --> 00:57:17,520
extension issue which can be addressed

1523
00:57:17,520 --> 00:57:19,839
through the kernel mmr but it goes

1524
00:57:19,839 --> 00:57:21,280
beyond the scope of what i'm going to be

1525
00:57:21,280 --> 00:57:23,839
covering today um but it is something

1526
00:57:23,839 --> 00:57:24,960
that

1527
00:57:24,960 --> 00:57:27,359
um is known to exist and the only way to

1528
00:57:27,359 --> 00:57:29,520
do this is to take the physical address

1529
00:57:29,520 --> 00:57:31,839
or the virtual address of the x64

1530
00:57:31,839 --> 00:57:33,440
translate it to a physical address and

1531
00:57:33,440 --> 00:57:36,400
then translate it to a pae of x32 to

1532
00:57:36,400 --> 00:57:38,720
then we ran through the x32 handler

1533
00:57:38,720 --> 00:57:40,240
or you have to bridge between manually

1534
00:57:40,240 --> 00:57:43,359
between x6 actually 2 and x64 cpu modes

1535
00:57:43,359 --> 00:57:45,119
in order to validate what is inside the

1536
00:57:45,119 --> 00:57:48,160
handler for the x32 process um which is

1537
00:57:48,160 --> 00:57:50,799
quite complicated um this is something

1538
00:57:50,799 --> 00:57:52,480
that is still ongoing but the best

1539
00:57:52,480 --> 00:57:54,559
method that i know of is to use the mmr

1540
00:57:54,559 --> 00:57:56,960
within the kernel

1541
00:57:56,960 --> 00:57:58,799
so in summary

1542
00:57:58,799 --> 00:58:01,040
memory manipulation is it's not it's

1543
00:58:01,040 --> 00:58:03,040
never going away it's been here for a

1544
00:58:03,040 --> 00:58:05,599
very long time and the capabilities that

1545
00:58:05,599 --> 00:58:07,359
are being implemented with the new

1546
00:58:07,359 --> 00:58:08,559
they've been introduced by the operating

1547
00:58:08,559 --> 00:58:10,559
system iniquity the

1548
00:58:10,559 --> 00:58:12,880
um change from tactics to

1549
00:58:12,880 --> 00:58:15,200
victim processes to their own processes

1550
00:58:15,200 --> 00:58:17,200
is something that shows that they're

1551
00:58:17,200 --> 00:58:19,520
always finding new ways to utilize

1552
00:58:19,520 --> 00:58:22,400
tweaks inside live memory in order to a

1553
00:58:22,400 --> 00:58:25,520
detection or just execute malicious um

1554
00:58:25,520 --> 00:58:27,920
malicious commands

1555
00:58:27,920 --> 00:58:30,960
but monitoring is always a fine balance

1556
00:58:30,960 --> 00:58:33,760
between accuracy and resources ideally

1557
00:58:33,760 --> 00:58:36,160
we'd love to monitor every single memory

1558
00:58:36,160 --> 00:58:39,040
change and uh be able to 100 and

1559
00:58:39,040 --> 00:58:40,319
accurately say you know this is

1560
00:58:40,319 --> 00:58:41,760
attributed to this process and these

1561
00:58:41,760 --> 00:58:43,040
bytes are going here and all this sort

1562
00:58:43,040 --> 00:58:44,559
of stuff but the resources right

1563
00:58:44,559 --> 00:58:46,640
required for that are just way too high

1564
00:58:46,640 --> 00:58:48,720
so it's always a balancing act between

1565
00:58:48,720 --> 00:58:50,880
the two and you have to decide where is

1566
00:58:50,880 --> 00:58:54,000
the best place to monitor

1567
00:58:54,000 --> 00:58:56,480
finally is the capability to avoid

1568
00:58:56,480 --> 00:58:58,960
detection in unrestricted operations

1569
00:58:58,960 --> 00:59:01,040
makes this a high value and what this

1570
00:59:01,040 --> 00:59:03,200
means is

1571
00:59:03,200 --> 00:59:04,559
memory manipulation

1572
00:59:04,559 --> 00:59:07,119
provides a window to malicious actors to

1573
00:59:07,119 --> 00:59:08,960
effectively size depth detection

1574
00:59:08,960 --> 00:59:11,200
multiple ways so it is never something

1575
00:59:11,200 --> 00:59:12,400
that they're going to give up on it's

1576
00:59:12,400 --> 00:59:13,359
always going to be something they're

1577
00:59:13,359 --> 00:59:15,359
going to keep trying and keep finding

1578
00:59:15,359 --> 00:59:17,359
new methods for and although the methods

1579
00:59:17,359 --> 00:59:18,640
i outlined today are interesting there

1580
00:59:18,640 --> 00:59:20,880
are obviously a lot more out there um

1581
00:59:20,880 --> 00:59:22,160
and it's best to give you instagram

1582
00:59:22,160 --> 00:59:25,119
because this is not going to stop

1583
00:59:25,119 --> 00:59:27,119
thank you for listening uh if anyone has

1584
00:59:27,119 --> 00:59:29,040
any questions do feel free to email me

1585
00:59:29,040 --> 00:59:31,280
at my works email and thank you for

1586
00:59:31,280 --> 00:59:33,839
listening

