00:00:00.133-->00:00:04.137
>>My friend stand, sta- standing
next to me, this is his first
time speaking at DEFCON.

00:00:04.137-->00:00:09.142
[audience shouts and applauds]
His name is Sheng-Hao Ma. And
um, he wants to play with

00:00:12.946-->00:00:18.852
malware injection with esc, with
exploitive thoughts. Eh um, I
don’t know if I said that right,

00:00:18.852-->00:00:25.025
but let’s uh, hear him explain
it. And uh, before we get
started, um, I’m gonna give him

00:00:25.025-->00:00:27.027
a good congratulations. Oh you
already, you already drank?
>>[clears throat dramatically] I

00:00:27.027-->00:00:32.032
already drank. [laughter] Ohh.
Okay. So, um, hello everyone!
Um, my name is Ma Sheng-Hao. And

00:00:39.973-->00:00:44.978
I’m just a master degree student
from Taiwan. And I’m also a
security researcher from um,

00:00:47.781-->00:00:52.786
chro0.ot and TDOHacker. And,
this, and, this is my first a,
speak, um, DEFCON so I’m a

00:00:56.823-->00:01:01.762
little bit, a little bit nervous
and I just drink the shot and
it’s very spicy so. [everyone

00:01:05.098-->00:01:10.103
laughs] It’s okay. So let’s do
it. So, uh, is is the agenda. At
first I am going to talk about

00:01:13.206-->00:01:18.211
what is malware injection?
[musical interruption
technological glitch]

00:01:24.584-->00:01:29.589
vulnerability inspired by
polisher. Uh, pow, PowerLoader.
So. So let’s quick, quick

00:01:37.564-->00:01:42.569
review. What is malware
injection? And, in the past,
malware injection is used for

00:01:45.939-->00:01:51.845
some, bypassing some um,
protection. Like bypass
whitelist checking, bypass

00:01:51.845-->00:01:56.850
anti-virus or privilege
escalation. And, for example,
with the DLL side-loading and

00:01:59.319-->00:02:04.257
digital signature, we can bypass
the anti-virus. And with remote
inject and whitelisted process

00:02:06.793-->00:02:11.798
and we can bypass the
whitelisted, whitelist. And with
the ingest, inject uh, explorer

00:02:15.102-->00:02:20.107
and DLL side-loading and self,
el, elevated service we can
bypass windows UAC protection.

00:02:23.410-->00:02:28.415
So, and, lan, there are several
well-known technique like, um,
we, we have known about

00:02:33.153-->00:02:39.259
[indiscernible] technology about
inject. Like Shellcode.
Shellcode inject, DLL inject,

00:02:39.259-->00:02:44.264
process hollowing and uh, thread
hijacking, atombombing and
memory exploit. And in my

00:02:46.867-->00:02:53.373
presentation I will focus on how
to do malware injection in
exploitive way. How to do it.

00:02:53.373-->00:02:58.378
And if you want to do a malware
injection, actually they list 4
challenges for you. You will

00:03:01.848-->00:03:06.853
meet. The 1st one is what is
target? You should choose a good
target to um, to injection. And

00:03:12.325-->00:03:17.330
it’s, this, this target must be
meaningful. The secondary, where
to place? And a, a memory space

00:03:20.801-->00:03:25.806
for us to place our malwa,
malware code in remote process.
Lend suddenly we, we don’t need

00:03:28.809-->00:03:33.814
to know how to write malware
code from remote. This is, and
finally we need to find a way

00:03:37.484-->00:03:44.157
out to run the malware code from
the remote. This is most a
difficult, difficult part for

00:03:44.157-->00:03:49.162
us. And you can create a new
thread and hijack current thread
or whatever. So uh, this is an

00:03:52.132-->00:03:58.238
interesting test for us. What we
are talking about is Power
Loader. And what is Power

00:03:58.238-->00:04:03.176
Loader? Uh, Powerloader also
known as extra window
vulnerability. So what it is?

00:04:05.545-->00:04:10.550
And there is a windows data
windows data uh window data is
for process memory. And most

00:04:12.652-->00:04:17.657
data decide how you’re GUI, how
your window is look like. And
this is how it’s going. First,

00:04:22.129-->00:04:27.134
operating system will send
message to your explorer.
Secondary, explorer fetch the

00:04:29.202-->00:04:34.207
vtable from, from LOS data.
Finally explorer invoke the
coding functions and lay vtable.

00:04:39.246-->00:04:45.385
And you, you will say “what’s
the problem? It seems very
normal.” It’s generally. So

00:04:45.385-->00:04:50.390
what’s the problem? The problem
is how explorer fetch lay vtable
because we know uh, ex, explorer

00:04:54.060-->00:04:59.065
will invoke the coding function
from vtable. So the problem is
how explorer fetch the vtable.

00:05:01.902-->00:05:06.907
Actually it fetch the vtable by
uh, by uh windows API net. Get
window long. So we can easily

00:05:14.281-->00:05:19.286
multiply the result of get
window long API, just use set
window long API to change the

00:05:21.588-->00:05:26.593
vtable address. So let’s put it
all together. We can know if we
can inject a fake vtable then,

00:05:30.597-->00:05:35.602
then we can use set window long
API to point the vtable address
to the fake, the, the fake

00:05:40.140-->00:05:45.145
vtable. And then we can, if we
send any message into explorer,
explorer will invoke our code

00:05:48.882-->00:05:53.887
from the fake vtable. So. If
you, uh, I, I give a payload
here. And we just prepare our

00:05:59.659-->00:06:04.598
shellcode and then prepare our
memory layout and the vtable.
Then use set window long, PTI,

00:06:08.702-->00:06:13.707
API to multiply the vtable
address of target. AKA explorer.
Then, uh, ju, just send the

00:06:18.311-->00:06:23.316
message to that explorer and it
will trigger our payload. So
let’s see a quick, quick demo.

00:06:30.590-->00:06:35.595
Uuhh. Here, here ah. Okay, so.
[speaker laughs] And here you
can see um, let, let, let’s test

00:06:42.135-->00:06:47.140
um, Windows 7 and here is my
shellcode. Then, it’s pretty
hard to use big, big screen. And

00:06:54.814-->00:06:59.819
then you can see I prepare our
memory layout inject the fake
vtable into target, explorer.

00:07:03.657-->00:07:08.662
And send a message to explorer.
You can see if we compile and
you can see uh, explorer is, is

00:07:11.564-->00:07:16.569
crashed and down. And in, and
wrong our shellcode on the
remote. [speaker gasps] Okay.

00:07:22.375-->00:07:27.380
So, there are 3 more, 3 more
vulnerability from, well, we are
talking about next. First one is

00:07:31.818-->00:07:36.823
OLE DropEnter Event. And what it
is? And if you do some riveting
stuff you, you will see like,

00:07:41.194-->00:07:46.199
LOS code on the screen and it’s
for use global add atom to keep
a string in OLE drop target

00:07:52.806-->00:07:57.811
interface. This string in the
by, ju, just keep it by global
add atom GPI. And you can see,

00:08:02.649-->00:08:07.654
when explorer tried to register
a drag and drop event you can
see explorer stole a drop target

00:08:11.157-->00:08:16.162
charger in OLE drop target
interface properties. So, and
you, you will ask about what is

00:08:20.066-->00:08:25.071
drop target? This charger is
used for what? And you can see,
drop target is actually it is a

00:08:27.874-->00:08:32.879
vtable class. Keep every coding
function address of drag and
drop event. So, explorer use and

00:08:38.151-->00:08:43.156
when, when you try to drag a
file, drag a file, any files to
explorer or inside explorer you,

00:08:45.959-->00:08:50.964
you will trigger a function
named Priv drag and drop. And
you can see in this function

00:08:53.533-->00:08:58.538
explorer will try to use
GetPropW API to fetch lay vtable
crest. And invoke the function

00:09:02.409-->00:09:07.414
and the vtable when you eject
any files inside explorer. And
you will, you will, you will ask

00:09:10.383-->00:09:15.388
about why is it a problem? The
problem is it’s pretty easy for
us to modify vtable address by

00:09:17.557-->00:09:22.562
another API is GetPropW. And if
we use this, API can modify the
vtable address. So all we need

00:09:28.468-->00:09:33.473
to do is inject a fake vtable
and pointed the OLE drop target
interface the properties to our

00:09:38.278-->00:09:43.283
fake vtable. So finally, let’s,
let’s. Let’s see how it go in.
You, you can see drag files if

00:09:47.587-->00:09:52.592
we drag them fast and inside the
explorer then our process is
done. Operating system send

00:09:54.894-->00:09:59.899
message to our explorer then
explorer fetch our fake vtable
by GetPropertyW API because we,

00:10:03.103-->00:10:08.108
we just used said property, W
API to change the vtable
address. Then invoke, the

00:10:10.443-->00:10:15.448
explorer will invoke the malware
code from our fake vtable. So,
if we need to prepare, if we

00:10:20.420-->00:10:26.926
prepare the uh, our shellcode
and a vtable on a correct memory
address then use set PropW API

00:10:26.926-->00:10:28.928
to modify the vtable address of
lay window data. And whenever,
ju, just explorer send or

00:10:28.928-->00:10:33.933
receive any drag and drop, drag
and drop event, the message and
explorer will invoke the malware

00:10:40.940-->00:10:45.945
code if our, our, our shellcode.
So, it’s the first one. Uh you,
you can see how we inject the

00:11:03.897-->00:11:08.902
drag and drop event of explorer.
Uh. Here. And. And first, you
can see it’s our shellcode. And,

00:11:35.628-->00:11:40.633
and here what we need to do is
uh, prepare our vtable address
and vtable address prepare our

00:11:43.002-->00:11:48.007
shellcode address. The explorer
will code the function and
memory plus C and we write the

00:11:53.012-->00:11:59.085
process memory the, the
shellcode into the vtable and
the shellcode into target

00:11:59.085-->00:12:04.023
process. Then use, just use set
prop A API to modify the OLE
drop target interface

00:12:07.026-->00:12:12.031
properties. So you can see if,
we compile. Uh, oops. Eh, oops.
And we compile and inject the

00:12:23.409-->00:12:28.414
shellcode and vtable into target
and there is nothing happen. But
if we drag any file into

00:12:31.384-->00:12:38.224
explorer, you can see there’s a
message box there, it’s from
shellcode. Then you can see we

00:12:38.224-->00:12:43.229
can from, loo, looking um, test,
um, manager and you can see it’s
from explorer. This, this

00:12:48.067-->00:12:53.072
message box is come from, pop up
from, from the explorer. So.
[speaker takes a breath] Ope. So

00:13:00.046-->00:13:05.051
silent. [speaker laughs] And,
the second up, the, the second
class is Comctl SubClass Event.

00:13:10.089-->00:13:15.094
And first, explorer keep
Uxsubclass. This property string
by GlobalAddAtom API again.

00:13:21.067-->00:13:26.072
Explorer invoke
MasterSubclassProc function if
it received any messages. If, in

00:13:30.276-->00:13:35.281
this function you can see
explorer code, code uh, function
FastGetSubclassHeader and to, to

00:13:38.618-->00:13:43.623
fetch the window data. Then
verify window data we just get
by a, another function is

00:13:47.627-->00:13:52.632
EnterSubclassFrame function.
Then finally, if the window data
is correct, then explorer will

00:13:59.138-->00:14:04.077
try to invoke the function and
window data. So, let’s see how
to, hoe explorer check the

00:14:06.446-->00:14:11.451
window data and how to correlate
function. And in en,
EnterSubclassFrame function we,

00:14:15.588-->00:14:20.593
we, we just said about uh, it’s
used for verify the window data
is current or not. So, on, only

00:14:25.331-->00:14:30.336
see we need, need to care about
is uh, here um. The vtable plus
A the function inject cannot be

00:14:36.309-->00:14:41.314
null, uh, it should be null or
it will fetch a bad memory
inject and host explorer crash.

00:14:44.817-->00:14:49.822
So we need to prepare our
vtable. We, we need to keep the
null on window data plus 8. And

00:14:56.262-->00:15:01.200
in EnterSubclassCallback
function, you can see the vtable
is, actually it is dynamic. And

00:15:03.770-->00:15:08.775
so, [indiscernible], actually
on, on this slide you can see uh
it’s [indiscernible] to get code

00:15:14.547-->00:15:19.552
injection dynamically in our
vtable address. So, uh we can
use this draw to, to check which

00:15:25.224-->00:15:30.229
address is our shellcode address
should be put at. And, finally,
if for the code inject we get

00:15:34.500-->00:15:36.969
just on the window data to
process LOS message, any
message. So we just need to

00:15:36.969-->00:15:38.971
prepare another vtable and our
shellcode in the vtable address
and put it all, all together on

00:15:38.971-->00:15:40.973
the correct memory adjust. Then
just use SetPropA API to modify
the vtable address and just use

00:15:40.973-->00:15:45.978
SendMessageA to trigger um,
message function of explorer.
Um, this is another more

00:16:16.976-->00:16:18.978
interesting case here. And you
can see it’s uh metasploit I
built on my PC. And uh, it’s,

00:16:18.978-->00:16:20.980
it’s finished and uh, windows
defender is open and I just took
this video yesterday. And

00:16:20.980-->00:16:23.049
whenever I just click the POC
and you can see that there’s
nothing happened for user. We

00:16:23.049-->00:16:26.719
think, don’t, don’t see anything
there. But our metasploit here
is gather reversed here. And we

00:16:26.719-->00:16:29.956
can do anything like, [audience
applauds] LS system invoke and
even we can execute uh, CMD. You

00:16:29.956-->00:16:34.961
can see, windows de windows
defender is not helped any at
all, not not protected us. And

00:16:46.706-->00:16:51.711
you can see the CMD its come
from is 4. Okay. So the final
interesting class is thread

00:17:01.087-->00:17:06.092
hijacking is, uh, this class is
LOS vulnerability code is inside
windows 10. So if you use

00:17:43.963-->00:17:48.968
windows 7 and windows 8 is, you,
you are safe. [speaker mumbles]
And every process is create on

00:17:55.808-->00:18:00.746
windows operating system by let
API it create a process this
API. And kernel will create a

00:18:04.150-->00:18:09.155
new process and map each station
into a new process memory. Then
create a new thread then put,

00:18:14.427-->00:18:19.432
then point to the PC register to
the program entry aka address of
entry. And first, thread, thread

00:18:25.705-->00:18:30.710
uh, did, did, didn’t just jump
into the uh, address of entry.
First, thread will call a LDR

00:18:33.779-->00:18:38.784
initialize thunk to repair the
import address table, export
directory and relocation

00:18:41.454-->00:18:46.459
information. And the interesting
is, you, you, you, you will see
now, for now uh just jump into

00:18:51.797-->00:18:56.802
address of entry, right? But no.
For windows 10 thread will check
uh, variables is, uh. Before

00:19:02.508-->00:19:07.513
thread jump into the program
entry every thread will jump
into another address is, uh,

00:19:11.384-->00:19:16.389
address of LDR delegated RTL
user thread start. This
variables if it’s not null. So

00:19:20.993-->00:19:25.998
if it’s not null and just jump
into it. So you can see it’s
pretty easy for us to abuse. So

00:19:28.868-->00:19:33.873
just put a shellcode to a target
process and write a shellcode
address into LDR delegated RTL

00:19:36.976-->00:19:43.883
user thread start. This
vulnerability, oh, it’s name is
very long. [speaker laughs] And,

00:19:43.883-->00:19:48.888
if it's ready, not jump into a
shellcode just if its create and
the new target process. So,

00:19:51.590-->00:19:56.595
let’s see the, let’s see the
final demo here. Yup. Um, you
can see it’s a chrome. And I

00:20:06.005-->00:20:11.010
open a new chrome layer and here
I just uh, only thing I need to
do is uh, to, to get the

00:20:19.819-->00:20:24.824
actually LDR delegated RTL user
thread start is located at,
which address. And when we get

00:20:27.927-->00:20:32.932
to the address and we just write
our shellcode address into the
variables then if chrome, you

00:20:42.141-->00:20:47.146
can see I just inject the
shellcode and the variable in
the target process. And nothing

00:20:49.582-->00:20:54.587
happened there. But if we try to
browse a new website like google
dot com, and you can see the CMD

00:20:59.325-->00:21:04.263
come from chrome. [audience
applauds] uh. Yeah thank you.
You see the CMBs come from

00:21:07.399-->00:21:12.404
chrome, so. Okay. So, thank,
thank you for listening.
[audience applauds]

