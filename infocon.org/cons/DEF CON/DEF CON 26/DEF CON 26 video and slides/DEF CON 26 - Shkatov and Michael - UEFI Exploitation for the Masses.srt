00:00:00.000-->00:00:06.907
>>okay, now we’re going to have
Mickey & Jesse discuss the UEFI
exploitation of the annoying bio

00:00:06.907-->00:00:11.912
stuff that I know I personally
hate, so uh give it up
[clap][applause] >>can you hear

00:00:17.217-->00:00:22.222
me okay? Alright, um I’m Mickey,
that’s Jesse, we work for a
company called eclypsium so far

00:00:30.297-->00:00:37.104
introductions, uh by the way
that's our twitter handles, uh
feel free to ask any questions

00:00:37.104-->00:00:43.543
DM us, pester us, catch us in
the hallway, anything, just feel
free. Uh, during our talk we’re

00:00:43.543-->00:00:49.650
going to talk about a few
things, uh the big picture is uh
I’m going to have to bring you

00:00:49.650-->00:00:54.655
up a little bit on what it is to
set up a debug environment uh
what is the UEFI exploitation

00:00:57.491-->00:01:02.763
techniques, uh specifically the
exploit that we found, the
vulnerability that we find when

00:01:02.763-->00:01:07.768
we exploit it and a few more
things that we recommend you do.
Basic acronyms, anyone here does

00:01:11.038-->00:01:16.043
not know what BIOS stands for? I
assume everyone does, um UEFI is
basically the newest name for

00:01:20.447-->00:01:25.218
BIOS, uh DCI is the acronym for
direct connect interface there’s
been a lot of research about

00:01:25.218-->00:01:29.589
that in the last year and a half
uh interesting stuff, I
recommend you read up on it. Uh,

00:01:29.589-->00:01:34.594
SMM is a privilege mode that the
uh CPU runs in and uh you should
read up on that too, and out of

00:01:39.766-->00:01:45.839
band obviously. A couple of
people you should uh really
follow, and read up on the

00:01:45.839-->00:01:50.510
research in this field. Uh, the
ones that have an apple on them
and a censored mark, they work

00:01:50.510-->00:01:56.383
for apple now, uh you don’t see
a lot of research coming out of
people who go work for apple,

00:01:56.383-->00:02:01.488
but they do have a lot of past
research and the reason we’ve
added and more is because once

00:02:01.488-->00:02:06.994
you start looking into these
names you’d see more and more
names pop up. Uh for example not

00:02:06.994-->00:02:11.999
necessarily UEFI but some DMA
and UEFI, I’d like to point out
Oof for instance sitting right

00:02:17.170-->00:02:22.009
there [applause] check out his
research or pester him later,
he’ll tell you everything he

00:02:22.009-->00:02:27.014
does, he’s awesome, and Joe
Grand, also ask him stuff. Why,
why should we care about- about

00:02:30.817-->00:02:35.822
BIOS and UEFI right? So, I sa-um
I suck, I don’t know someone did
this study about who is actually

00:02:40.827-->00:02:46.166
who actually cares about their
firmware security? And turns out
that a lot of people [sneeze]

00:02:46.166-->00:02:48.168
bless you, a lot of people don’t
really care, or mind it. You
know, you put you power on your

00:02:48.168-->00:02:50.170
system like if your a consumer,
it boots up, there’s a fancy
logo and then you go do your

00:02:50.170-->00:02:53.073
thing in windows and everyone’s
freaking out every time
ransomware comes out. Uh, no-no

00:02:53.073-->00:02:56.176
one thinks about that little
piece of code that runs first
when you boot up your machine

00:02:56.176-->00:03:01.982
and owns everything, and sets up
everything and configures
everything and hands it off to

00:03:01.982-->00:03:08.055
the os. Um, ha, this is a-a-a-a
very convoluted diagram for how
this works. Complex, I’m going

00:03:08.055-->00:03:13.060
to simplify this, the little
BIOS window there, its at the
stage where you go into BIOS and

00:03:28.642-->00:03:33.246
do settings, ever-anyone here
done, went into BIOS and changed
the setting because they had

00:03:33.246-->00:03:38.251
too? Isn’t that fun? Right? So
that’s where that does, that
stage that that happens and the

00:03:40.821-->00:03:45.625
windows logo over there is where
the operating system is at. So,
you can see there’s a lot of

00:03:45.625-->00:03:50.630
stuff happening before run time,
or operating system. From an
attacker’s perspective, when you

00:03:54.067-->00:04:00.540
want to attack this, this piece
of firmware, um, you target
whatever stage you want

00:04:00.540-->00:04:05.745
according to your payload. If
you want to implant a piece of
firmware, you want to have some

00:04:05.745-->00:04:10.750
persistency, there-there are
known uh backdoors, the SSM, um
the famous theme as SMM backdoor

00:04:12.786-->00:04:17.791
and github and then others, and
hacking team and volt 7 and I
could go on. And, um you just

00:04:23.029-->00:04:28.101
implanted in the firmware and
you’re good. If you want to do
in-in-in the operating system,

00:04:28.101-->00:04:32.973
stage when your in runtime, it’s
a different, it’s a different
attack surface for the firmware.

00:04:32.973-->00:04:38.778
Right, there’s different stages
where the BIOS and firmware go
at since you power on the

00:04:38.778-->00:04:45.685
machine and until it hands off
to the OS and that’s like really
simplified. Again, as an

00:04:45.685-->00:04:50.857
attacker, I care about two
things, let’s, let’s say-let’s
all imagine that we want to hack

00:04:50.857-->00:04:56.830
someone like and we’re nation
state, or not nation state and
we know how to get into this

00:04:56.830-->00:05:03.737
persons hotel room and get, get
our hands on their laptop for 10
minutes. There’s two ways we can

00:05:03.737-->00:05:08.742
do this, one we can open the
laptop, get all the covers in
the bag, the flash, the chip,

00:05:12.379-->00:05:18.585
read it, flash it, change it,
whatever, put it back together,
the classic elite attack, or we

00:05:18.585-->00:05:22.989
can do this with the laptop
closed, so, that’s an
interesting attack factor we can

00:05:22.989-->00:05:27.994
do with uh, debug enabled um,
in-in, in intels case, uh there
are scenarios where debug is

00:05:30.964-->00:05:35.969
enabled, you can have um USB
access that’s all you need, just
plug in a USB cable, and you can

00:05:39.072-->00:05:44.077
do a lot of interesting things
we’re going to show you in a
bit. Let’s see. I’m going to

00:06:00.460-->00:06:05.465
show you a video, and I hope I
can show it with this, okay we
have audio. It’s a shortened

00:06:11.471-->00:06:16.476
video of our evil made attack,
so, we, we have a laptop that
we’re going to infect with a, an

00:06:19.346-->00:06:24.351
SNM backdoor, using a flash
programmer. Opening the laptop,
removing the heatsink because

00:06:27.254-->00:06:32.926
the spies under the heatsink,
flashing the spy, which is the
longest process in all of this,

00:06:32.926-->00:06:39.332
90 seconds to flash the spy
chip, put it back together and
that’s it. So, let’s enjoy the 1

00:06:39.332-->00:06:44.337
minute ahead of you. [music
playing 06:41-07:42] so that
was, an evil made attack, the

00:07:37.123-->00:07:42.128
red that you saw at the end,
that was the SMN backdoor dema
wrote it’s loading, just an

00:07:50.570-->00:07:54.874
indication that from the
beginning you load into windows
and then afterwards you load

00:07:54.874-->00:07:59.879
into a backdoor and then windows
[applause]. I do apolog- the
rest of the videos don’t have

00:08:04.751-->00:08:10.190
the soundtrack [laughter]. How
the he- okay, that’s it. Now,
right at the slide is a couple

00:08:10.190-->00:08:15.195
of reference notes, uh these
CVE’s are specifically for BIOS
and firmware vulnerabilities.

00:08:25.071-->00:08:30.577
Um, I’m not going to go into
them, I’m just going to give
them a high level, they involve

00:08:30.577-->00:08:37.117
um SMI exploitation, SMI
vulnerabilities and so on and so
forth, they- check them out

00:08:37.117-->00:08:42.122
later. Now for the fun part.
Now, to get started with-with um
low level hardware debug or

00:08:44.924-->00:08:49.362
firmware debug, you need a
couple of things. Uh, Intel
studio-Intel studio debug is

00:08:49.362-->00:08:54.567
free to download its 3 month uh,
uh trial I think that you can
renew every 3 months, it’s

00:08:54.567-->00:08:59.572
awesome. The UEFI tool, uh
amazing tool it basically helps
view the UEFI images um view the

00:09:03.276-->00:09:09.682
parts in them, extract them,
replace them. CHIPSEC is a tool
for hardware and firmware

00:09:09.682-->00:09:16.423
security, exploration I would
say. If you ever wanted to go
into how the hardware in your

00:09:16.423-->00:09:22.662
computer works and you don’t
want to sit down and write a
windows driver, use CHIPSEC. Uh,

00:09:22.662-->00:09:27.667
IFR- Universal IFR extractor
that's a-a amazing tool. Um, you
basically you use this on a

00:09:31.604-->00:09:36.843
biased image, I’m not going to
go how to use each tool, it
allows you to get the-the-the

00:09:36.843-->00:09:43.183
details from the settle variable
that are not usually shown to
the user. Some, of these are

00:09:43.183-->00:09:48.188
very interesting and if you flip
them on and off you can get
interesting behavior, a lot of

00:09:50.223-->00:09:55.795
BIOS motors use this I-I really
enjoy reading their blog posts
how they break their systems,

00:09:55.795-->00:10:02.602
but um be careful, it’s it’s
really a good tool, it’s been
around since a long time ago.

00:10:02.602-->00:10:07.607
And um, two other important
things one is you need a USB to,
USB A to USB A cable, uh it

00:10:10.477-->00:10:15.348
costs 15 bucks from some vendor
that I don’t know, but maybe has
his name on the slide. Um, it’s

00:10:15.348-->00:10:19.452
totally worth it, I would get it
if I were you. And the late-
last but not least you need to

00:10:19.452-->00:10:21.454
have a USB that allows you to
boot into an UEFI shell. Now,
um, there are plenty of tools

00:10:21.454-->00:10:23.456
out there in the internet, that
are um used for many platforms
for many scenarios, you can just

00:10:23.456-->00:10:25.458
put it on your shelf, load it up
and play with. Um, there’s too
many to list, I really recommend

00:10:25.458-->00:10:30.463
you start looking around. Now
that you have a knowledge of the
tools you can, you can deal with

00:10:39.005-->00:10:44.010
like, to go a little bit deeper,
um for the Intel hardware debug
interface um, I need to

00:11:07.500-->00:11:12.505
reference some-some information
here. Uh, so the CVE you see
mentioned here is-is our own CVE

00:11:14.807-->00:11:19.812
we reported to Intel about uh
the DCI vulnerability and got
patched in a way that uh, that

00:11:22.515-->00:11:28.621
change-changed policy for
all-all the vendors in BIOS.
it’s ind- it’s interesting

00:11:28.621-->00:11:35.328
because it-it stops you from
enabling debug interface it
supposedly needs to stop you, I

00:11:35.328-->00:11:40.333
didn’t validate it but uh you
should uh note that. Uh, Intel
sys- Intel studio debug, once

00:11:43.770-->00:11:48.942
you have that it’s like 5 gigs
you download, you install it, it
has a whole set of tools, all

00:11:48.942-->00:11:55.048
you care about is the debugger,
that’s it. And, the debug
abstraction layer which is an

00:11:55.048-->00:11:59.219
important thing, it’s a command
line interface, the debugger, so
I’m going to talk about the UI

00:11:59.219-->00:12:01.154
and the command line. So, I’m,
I-I am a windows guy, I like a
lot of gooey so I’m going to

00:12:01.154-->00:12:06.125
focus a little bit on that, and
I’m going to add a little bit of
command line, just for all you

00:12:06.125-->00:12:11.130
linux people. So, when, when
you-when you have this
installed, you go and you find

00:12:22.275-->00:12:28.815
the Intel dell file on your hard
drive and you find
configconsole.exe. You can see

00:12:28.815-->00:12:34.988
what it says, I hope you can, uh
it’s a bit, resolution is a bit
off but you get a, a menu like

00:12:34.988-->00:12:39.993
that it’s a it’s part of the
Intel studio Debug, you go into
your drop down and you select

00:12:42.161-->00:12:48.434
your target, it’s abbreviated so
for example Kb-Kbl is KB lake
Skl is Sky lake and so on and so

00:12:48.434-->00:12:55.274
forth. The biggest um, if you
want to find what-what is what,
find the CPU of your target, you

00:12:55.274-->00:13:00.213
go the little numbers and k or
whatever i7, you go into intel
arc, you put that in the in the

00:13:02.749-->00:13:07.754
arc and it gives you product
formally known as Kb lake. And
then you know, Kb lake, what can

00:13:09.822-->00:13:14.827
that be? Kbl. There’s no 1 to 1
reference anywhere. So, once you
have that set you click apply

00:13:17.530-->00:13:22.368
and then you click on that weird
red button to connect to master
frame, master frame is a service

00:13:22.368-->00:13:27.807
running in the background that
connects you, your- your
computer your host to your

00:13:27.807-->00:13:32.812
target, using the um the USB
debug. Uh, after you do that you
have a service connected to that

00:13:35.615-->00:13:40.620
and you’re good. After that you
open the debug studio and in
there you have a button connect

00:13:43.122-->00:13:49.896
the target, you select the out
of band and it’s important you
click on the effects abstraction

00:13:49.896-->00:13:54.901
layer configuration. That
reference to the previous, um
drop down menu. Now, I-I’m like

00:13:57.704-->00:14:04.577
doing this explanation because
it’s not obvious, if you, if you
um, if you try to figure this

00:14:04.577-->00:14:10.483
out, it’s gonna take a while and
you’re gonna be frustrated why
is this not working? For

00:14:10.483-->00:14:15.488
example, uh our target platform
that we’re using is um an 8th
gen coffee lake S rock system

00:14:18.191-->00:14:24.864
with a 370 chipset that you can
see the option it’s like
somewhere in the middle, second

00:14:24.864-->00:14:30.803
from the bottom, it’s literally
there, you just select it and
click it. So, you don’t have to

00:14:30.803-->00:14:36.042
go out to this convoluted
process selecting the pro-the
target platform and clicking and

00:14:36.042-->00:14:40.913
going and setting it up. But,
some platforms do not have this.
So, if you do want to use the

00:14:40.913-->00:14:45.918
gooey, this is a great tip to
know how to fix that. You don’t
have to get specifically the

00:14:45.918-->00:14:52.592
hardware to work with that. On
the command line side you have
the PythonConsole dot cmd it’s a

00:14:52.592-->00:14:55.361
um it’s uh the CLI for python
and i-ITP, it loads everything
together uh it’s in the same

00:14:55.361-->00:15:00.066
folder as config console is at,
we just run it and it starts
booting up and-and setting

00:15:00.066-->00:15:05.071
everything up and then you get
something like this. ITP is the
name space and when you- when

00:15:13.880-->00:15:18.885
you do ITP dot halt, it halts
the CPU, which is by itself,
amazing. Ha and then in this

00:15:23.556-->00:15:28.561
example we set a breakpoint in
SMM, we-we issue an SMI, we let
the process continue, and then

00:15:32.298-->00:15:37.303
the next breakpoint is SMM entry
breakpoint. This is the uh, the
script that actually does it,if

00:15:39.672-->00:15:44.677
you want to automate this,
excuse me, um, all it does, is
basically halts the CPU, sets

00:15:49.782-->00:15:54.787
the breakpoint to SMM enter,
issues an IO for SMI, let’s the
CPU go, waits until the

00:15:58.958-->00:16:04.697
breakpoint is tripped, until the
CPU gets the SMI, is in the
break point gets the SMM

00:16:04.697-->00:16:09.702
physical base address and uses
mem safe to dump the entire SM
RAM and then releases the CPU.

00:16:13.906-->00:16:18.911
In the gooey, it’s much nice and
gooeyish. So you have this drop
down when you create a

00:16:22.081-->00:16:25.384
breakpoint, you can create a
hardware breakpoint uh a
software breakpoint or other.

00:16:25.384-->00:16:30.723
Uh, I always use the hardware
breakpoints. In there you can
choose if you if you pause in

00:16:30.723-->00:16:37.597
code or on data being accessed
or platform. If you choose
platform, the in-debug studio

00:16:37.597-->00:16:43.970
comes with these built in
options. Now, I don’t know about
you all, but, having the ability

00:16:43.970-->00:16:48.975
to have a debugger pause the
system in a VM exit is not
trivial, or machine check, or

00:16:55.081-->00:17:01.053
SMM enter, these things are not
something you can do GDB it’s
not something you can really

00:17:01.053-->00:17:06.058
like “oh I’ll do it later” it’s
really stopping everything. If
we set a breakpoint in SMM

00:17:09.595-->00:17:11.964
enter, in the gooey it would
look something like this, you’d
see a little yellow mark where

00:17:11.964-->00:17:16.903
you’re stopping execution you’d
see the address right here I’m
showing that the we stopped at

00:17:16.903-->00:17:21.908
the address and the um the SM
RAM physical base address is
that number so you can obviously

00:17:25.311-->00:17:30.316
we’re in SM RAM running, and you
can step uh step through, step
into, step out of, it’s exactly

00:17:34.654-->00:17:39.659
like any other debugger, it’s
amazing. Another interesting
option here is the reset vector.

00:17:41.794-->00:17:46.799
So um, in-in modern platform,
for the last 30 years, every
time the silicon gets powers

00:17:51.137-->00:17:57.209
powered on, it does it’s own,
the chip does it’s own silicon
stuff then it goes and it stops

00:17:57.209-->00:18:03.950
and it loads a specific address
that has set up in it that
basically sets the reset vector

00:18:03.950-->00:18:10.022
for the firmware. Execution is
handed off from the chip, to the
firmware and then the firmware

00:18:10.022-->00:18:14.226
then loads to the os and then
the bootloaders and all that.
The reset vectors always been

00:18:14.226-->00:18:20.900
the same place in, in, in the
last 30 years, and breaking on
it means that you get to stop

00:18:20.900-->00:18:25.905
the machine, before BIOS has
configured anything. No
protections, no memory, nothing.

00:18:28.975-->00:18:35.181
Before even BIOS loads, you can
do whatever you want. This is
uh, this is how it looks, when

00:18:35.181-->00:18:40.286
you- when you halt on it, uh you
have writeback and validate
which is uh an example of one

00:18:40.286-->00:18:44.890
system this is on a sky lake
system, in a coffee lake its nop
nop and then it jumps to the

00:18:44.890-->00:18:49.895
next uh instruction. The address
is the same on every platform.
Now, I’m gonna go to the fun

00:18:54.567-->00:18:59.572
part and let Jesse do that.
>>So, so we’ve looked a little
bit so we’ve looked a little bit

00:19:03.643-->00:19:10.149
of how uh to use some of these
debug interfaces and what to do
but, uh as far as like actually

00:19:10.149-->00:19:15.154
finding vulnerability and what
we can do with it, uh one of the
most interesting areas is

00:19:17.890-->00:19:22.895
there-there’s been a lot of
network capabilities added to
UEFI and some of those are

00:19:25.197-->00:19:31.270
things like over the internet
updates from BIOS itself, from
UEFI uh we found a BIOS that can

00:19:31.270-->00:19:38.010
send email, uh there’s another
one that does, it’ll download a
remote diagnostics tool over the

00:19:38.010-->00:19:42.982
internet, run the application
and provide results back
somewhere else to-to the

00:19:42.982-->00:19:47.686
internet before your operating
system loads at all. So, as, as
part of like looking around at

00:19:47.686-->00:19:52.892
all these different features we,
we discovered that uh uh two
different vendors have

00:19:52.892-->00:19:59.231
vulnerabilities in there uh, uh
internet based uh UEFI update
mechanism. One of em was ras

00:19:59.231-->00:20:04.236
asrock, uh we reported that to
them and they were like oh c**p
let’s fix this and basically uh

00:20:07.073-->00:20:13.012
made a firmware BIOS UEFI
updates for around 300 different
motherboards that were all

00:20:13.012-->00:20:18.484
affected by this it basically
was anything from haswell
onward, from asrock was affected

00:20:18.484-->00:20:25.191
by this. Uh, they di- they do
some AMD mo-models also, that
were affected, I think it was a

00:20:25.191-->00:20:30.596
much smaller number, it was like
27 motherboards but we also
found uh- so this is the exploit

00:20:30.596-->00:20:34.834
that we’re going to walk through
and explain how to actually take
advantage of this uh we found uh

00:20:34.834-->00:20:39.839
basically, essentially the same
bug in uh asrocks firmware and
uh this is the response we got

00:20:42.174-->00:20:47.179
back from asrock, or ASUS, this
is ASUS sorry. Asrock is fine,
ASUS we we kind of went back and

00:20:49.181-->00:20:54.053
forth between them and
explaining like you should maybe
fix this and they’re like no

00:20:54.053-->00:20:58.724
this all happens before the
operating system loads so it’s
fine, it’s not a problem. And

00:20:58.724-->00:21:04.830
it’s like no, like the operating
system like it’s even more
privileged because it’s before

00:21:04.830-->00:21:11.770
the operating system, so they
didn’t actually bother to fix
this. So, it concerns me a

00:21:11.770-->00:21:15.975
little bit because like my
desktop at home is an ASUS
system and it’s vulnerable to

00:21:15.975-->00:21:21.547
this also and I’d like them to
make a patch. So, here’s an
example of what the the user

00:21:21.547-->00:21:27.620
interface looks like in BIOS,
you can basically go in and uh
this is asrock supplementation,

00:21:27.620-->00:21:33.792
uh it’ll it’ll show you if
there’s an update available you
can apply it um here’s what um

00:21:33.792-->00:21:39.465
uh ASUSs implementation looks
like,it’s essentially the same
functionality implemented

00:21:39.465-->00:21:46.405
differently uh this is all
vendor specific add ons to the
base tiana core reference code

00:21:46.405-->00:21:51.677
implementation so, we’ll do a
little bit of a walk through of
like what the actual exploit

00:21:51.677-->00:21:57.449
was, and then we’ll explain how
to take advantage of that how to
build a payload to actually

00:21:57.449-->00:21:59.451
exploit this. So, as Mickey
mentioned this was a, a, a
coffee lake asrock latest,

00:21:59.451-->00:22:04.390
latest updates, everything was
uh up to date. So uh, in this
case, basically it does a plain

00:22:06.458-->00:22:11.463
http request from BIOS to remote
server on the internet it brings
up the network connection using

00:22:17.703-->00:22:22.708
DHCP and makes plain HTTP
requests so there’s no, no SSL,
no certificate pending, like

00:22:24.743-->00:22:30.683
there’s no verification that it
is talking to the right server.
Or and that you have a man in

00:22:30.683-->00:22:35.621
the middle that you have poised
in the attacks that request to
go see your server, something

00:22:35.621-->00:22:40.593
like that, so they’re not doing
any of that. Uh, here’s, let’s
see, here’s what the result

00:22:40.593-->00:22:45.397
looks like, it’s basically just
an xml document that has some
fields like here are different

00:22:45.397-->00:22:50.402
urls you can download this BIOS
update for, here’s the version
that uh is available uh here’s

00:22:52.705-->00:22:57.710
the description of it, here’s
the actual file name itself and
if you uh modify this, you

00:23:00.079-->00:23:05.084
basically show up with like
here’s, here’s my malicious
update, go, go apply that. But,

00:23:07.553-->00:23:14.126
uh, we discovered that, like
here’s the uh exploit. So, we
discovered that if you uh, if

00:23:14.126-->00:23:19.999
you just have a lo- a really
long url field, it doesn’t even
get to the point of asking you

00:23:19.999-->00:23:25.004
saying hey there’s a new update
available, it just hangs and
you’re like that’s interesting

00:23:27.473-->00:23:34.346
what happened here? So, uh in
order to figure out what
actually happened, uh we’ll have

00:23:34.346-->00:23:39.118
to start using those hardware
debug tools. But, to get started
we’ll just start off with a

00:23:39.118-->00:23:44.123
simple payload where uh in that
url uh xml tag for the the
response they’re returning we’re

00:23:47.626-->00:23:53.499
just going to put a long string
of a’s and see what happens.
What happens. So, once you’ve uh

00:23:53.499-->00:24:00.339
used uh mickey’s process to uh
attach the debug, the hardware
debug tools and get into intel

00:24:00.339-->00:24:04.410
system uh debugger. You
basically have an environment
that looks kind of like this.

00:24:04.410-->00:24:09.415
It’s a sim it’s you, you have
the ability to look at memory,
check the state of the CPU, uh

00:24:11.684-->00:24:16.689
the really key thing to do uh to
figure out what actually
happened is uh in in user mode

00:24:19.158-->00:24:24.763
applications or even kernel,
you’ll usually get some kind of
system log of what happened, uh

00:24:24.763-->00:24:29.768
when when you pause a uh an
exception in BIOS, it usually
just hangs uh it goes to an

00:24:33.038-->00:24:37.910
exception handle and then goes
to an infinite loop and you
don’t know what’s going on. Um

00:24:37.910-->00:24:43.882
so, what you’ll want to do is
basically find the interrupt
handlers for general protection

00:24:43.882-->00:24:48.887
fault and you can do that by
there’s this uh menu option for
uh looking at CPU structures and

00:24:51.557-->00:24:56.962
GDT and then on the bottom right
here, you can see, here’s the
different handlers, and the uh,

00:24:56.962-->00:25:03.635
the offset of general production
fault is listed here in the very
very far right so that address,

00:25:03.635-->00:25:06.105
you can then go set a hardware
breakpoint on and uh use this,
basically go to that address and

00:25:06.105-->00:25:08.107
say create breakpoint at that
address so then when we trigger
this we can actually have this

00:25:08.107-->00:25:10.109
fault and then examine the state
of the system from that point.
So, when, when we do this we

00:25:10.109-->00:25:15.114
basically end up where we’ve
halted at the-the entry point
for the interrupt for the

00:25:23.789-->00:25:28.794
general protection fault vector
and you can see in the-the upper
right here’s the state of the

00:25:32.631-->00:25:39.304
registers and the 40, 41’s are
basically our 8 characters that
showed up in two of the

00:25:39.304-->00:25:44.576
registers that we’ve seen so far
so we’ve clearly overflowed
something in the stack, there’s

00:25:44.576-->00:25:51.183
this register state that’s been
corrupted. And uh, that’s that’s
a pretty good sign so far. So,

00:25:51.183-->00:25:55.888
we can go then take a look at it
and uh basically, uh it’s not
quite as intuitive as GDB and

00:25:55.888-->00:25:57.890
like other kernel debug features
that you can use so you, in
order to actually figure out

00:25:57.890-->00:25:59.892
where this faulted, we’re gonna
take a look at the, the stack
pointer and see if there is

00:25:59.892-->00:26:04.830
basically when it goes into this
uh exception uh it-it puts the
state of the machine onto the

00:26:08.734-->00:26:13.605
stack. So we can basically look
at the stack pointer, and use
this function that’s just show

00:26:13.605-->00:26:15.607
memory. And, if you take a look
here it basically puts the
memory of- of that address down

00:26:15.607-->00:26:18.811
at the bottom and we can see
there-there’s a 64 bit uh value
that’s pushed uh and then the

00:26:18.811-->00:26:22.381
next 64 bit value on the stack
is the address of the
instruction that faulted so we

00:26:22.381-->00:26:29.121
can kind of navigate around a
little bit and see what happened
and find the exact line of code

00:26:29.121-->00:26:35.561
that crashed. It’s not quite as
intuitive as some of the other
debuggers but it’s useful, so uh

00:26:35.561-->00:26:41.900
in, in this case uh let’s see
whe-when we uh take a look at
that instruction that we

00:26:41.900-->00:26:43.902
actually halted at it turns out
that it was return instructions.
So, we, we basically halted when

00:26:43.902-->00:26:45.904
we were trying to return uh
because our pointer was bad. So,
that’s a pretty good sign

00:26:45.904-->00:26:47.906
because it it implies that we
control the return address and
we can have arbitrary code

00:26:47.906-->00:26:52.911
execution at this point. But,
there’s some things, things to
look about for if you actually

00:27:17.936-->00:27:19.938
turn this into a real exploit.
And what, there’s some general
constraints for your payload so,

00:27:19.938-->00:27:24.943
this is uh 64 bit uh mode so,
you can have larger pointers and
your shell code needs to be 64

00:27:29.515-->00:27:34.520
bit and because this is a string
copy from a document onto the
stack, we need to avoid null

00:27:48.567-->00:27:54.139
characters, we also need to
avoid like greater than less
than, symbols because they would

00:27:54.139-->00:27:58.877
mess with our uh xml document.
So, there’s like a few bad
characters we need to avoid. And

00:27:58.877-->00:28:05.617
then as part of our exploration
and and exploring the uh debugs
uh environment uh we were to

00:28:05.617-->00:28:10.622
able to determine that we really
need a very small and precise
size for the length of the

00:28:13.091-->00:28:18.130
string because if if we have too
many bytes, uh we end up
dereferencing a pointer that

00:28:18.130-->00:28:23.101
crashes before we get to the
return address. So, it needs to
be exactly 255 bytes. So, we

00:28:23.101-->00:28:29.508
have we some constraints but, we
can work with this so. In order
to verify we are actually

00:28:29.508-->00:28:34.513
executing instructions and we
have remote code execution we
just build a basic uh exploit

00:28:36.582-->00:28:41.553
where instead of the long string
of a’s we have are NOP sled and
then just uh a single

00:28:41.553-->00:28:45.824
instruction to do an infinite
loop and then our target return
address to try and jump into the

00:28:45.824-->00:28:50.829
NOP sled and its it's pretty,
pretty simple. So, once we, we
trigger this, we basically

00:28:53.265-->00:28:58.270
verify that we did hit our NOP
sled and when we when we halt
the processor we, we basically

00:29:00.839-->00:29:05.043
you can see there there’s a
little yellow tic at the very
left of that infinite loop

00:29:05.043-->00:29:10.082
instruction so we are, we halted
the processor it was in that
busy loop that’s all it’s doing.

00:29:10.082-->00:29:16.188
So, we did confirm we have
arbitrary code arbitrary code
injection and the stack is

00:29:16.188-->00:29:22.561
executable so that makes it even
easier. So, that, that’s
basically what we’ve determined

00:29:22.561-->00:29:27.833
here it’s like we, we have
verified that we can execute
instructions uh there’s no

00:29:27.833-->00:29:34.473
address randomization which is,
makes things easier also and the
stack is executable. Because we

00:29:34.473-->00:29:37.109
have that limit where it has to
be uh 255 bytes exactly, we need
to figure out what we can do and

00:29:37.109-->00:29:39.111
what we can put into that uh
space. So, one other thing we
can do is like we’re limited to

00:29:39.111-->00:29:44.116
the 255 bytes for that
particular um field, but we have
the rest of the xml document. It

00:29:57.663-->00:30:03.168
turns out that if you just
append stuff to the end of the
xml document, that also shows up

00:30:03.168-->00:30:09.107
in memory and uh one one one
thing that we can do is we can
just look and see if we have a

00:30:09.107-->00:30:13.879
pointer that already ex that
already points at that xml
document. So, we’ll just take a

00:30:13.879-->00:30:17.916
look at all the different
registers and see if we get
lucky. So we can use the show

00:30:17.916-->00:30:24.556
memory and check each of the
different registers and it turns
out that uh R10, the R10

00:30:24.556-->00:30:29.561
register happens to point into
the heap, it’s not exactly at
the xml document, but it’s

00:30:32.364-->00:30:37.369
close. If we, we basically look
at R10 and then search backwards
in memory uh from that pointer,

00:30:39.538-->00:30:45.610
we find our full xml document
and it’s there. Then, we can, we
can take advantage of this by

00:30:45.610-->00:30:51.316
basically building our exploit
to instead of having our
infinite loop, we basically have

00:30:51.316-->00:30:58.256
code that searches backwards
from the R10 pointer in order to
find a a tag, we basically it’s

00:30:58.256-->00:31:04.196
we just used a little 8 byte
string of a’s and that worked.
You could put whatever you want

00:31:04.196-->00:31:10.869
to have as your tag to search
for but we basically have on the
on the stack overflow is, our

00:31:10.869-->00:31:15.874
initial payload, we use that to
find the rest of the payload in
the heap. Um, once, once you’re

00:31:18.410-->00:31:24.116
actually stepping through that
there’s some, some useful
functions within the debugger so

00:31:24.116-->00:31:29.121
uh in order to get past that, so
it when I first started
debugging this in order to

00:31:31.356-->00:31:35.794
figure out what was really going
on I-I will really often add an
infinite loop at a particular

00:31:35.794-->00:31:40.098
point it’s like I can add a
breakpoint anywhere in my
payload, one issue that we run

00:31:40.098-->00:31:45.871
into using the hardware
debugging breakpoints is that
you’ll often need to like after

00:31:45.871-->00:31:50.175
you cycle the power of the
system you’ll often need to
enable and re-enable the

00:31:50.175-->00:31:55.781
breakpoint and then go trigger
your exploit. If you just add an
infinite loop in, you can

00:31:55.781-->00:32:01.520
effectively have the same thing
but then when you’re running you
basically need to say hey I want

00:32:01.520-->00:32:06.525
to skip this instruction so you
can just use this move PC to
line and set the adr uh set the

00:32:09.694-->00:32:12.931
instruction pointer to whatever
you want. So that’s a really
common thing that you end up

00:32:12.931-->00:32:18.069
using and then maybe there’s a
long loop to do things like copy
things and search memory and you

00:32:18.069-->00:32:22.607
can use this function just run
to line. Its uh its similar to
like GDB functionality but I

00:32:22.607-->00:32:27.345
kind of wanted to point out
where to find these things and
uh what you can use those for.

00:32:27.345-->00:32:32.350
So, at this point we’ve
basically uh found our two our
second stage payload and we can

00:32:35.687-->00:32:41.626
jump to that we have a lot more
room, but the question is what
do we actually do with our

00:32:41.626-->00:32:48.567
second stage payload, and in
order to really understand that
like we don’t have a operating

00:32:48.567-->00:32:53.572
system loaded so like running
bin bash using uh an m80 syscall
isn’t going to work. So like,

00:32:56.641-->00:33:01.513
all these these traditional
things you’ve seen in other
types of shell code just doesn’t

00:33:01.513-->00:33:05.517
exist like we don’t even have
like your windows kernel or
linux kernel or anything like

00:33:05.517-->00:33:09.955
that where you can patch
functions in it and then
basically escalate privilege of

00:33:09.955-->00:33:14.492
a user mode app. None of that
works, so, let’s talk a little
bit about what the UEFI

00:33:14.492-->00:33:18.029
environment actually looks like
and then we can have a better
idea of like the types of

00:33:18.029-->00:33:23.034
capabilities that exist that we
can take advantage of. So, we’re
going to give an overview of the

00:33:23.034-->00:33:28.773
applications like overall
structure of what an application
looks like and then uh protocols

00:33:28.773-->00:33:33.879
is a really key thing to know
and then system table, boot
services and runtime ta-services

00:33:33.879-->00:33:39.618
are all kind of important things
in UEFI. but, for so the
applications themselves are

00:33:39.618-->00:33:46.157
basically just a Windows PE
executable and instead of like
you might be familiar with like

00:33:46.157-->00:33:51.730
like Arc V and Arc C arguments
being passed and UEFI
applications are basically are

00:33:51.730-->00:33:56.735
passed a uh pointer to the uh
handle to the executable that
was loaded itself and a pointer

00:33:59.704-->00:34:04.643
to the system table is uh you
can find all these other
functionality that exist inside

00:34:07.479-->00:34:14.152
of UEFI from the system table.
Like I mentioned there’s a full
network stack, uh there’s a lot

00:34:14.152-->00:34:17.389
of rich functionality that we
can take advantage of and to
actually use those functions, we

00:34:17.389-->00:34:19.391
need to know about what
protocols are. It’s essentially
kind of a so it’s a protocol

00:34:19.391-->00:34:21.393
interface that is used to at
it's a inter- inter component me
uh mechanism such that it’s one

00:34:21.393-->00:34:23.862
piece of functionality that
wants to provide uh a type of
interface, like maybe it handles

00:34:23.862-->00:34:28.867
network connections uh it will
uh publish it’s interface by
GUID so you can say this is a

00:34:53.491-->00:34:58.496
well known number, I’m a
completely different application
and I want to use this and uh

00:35:01.666-->00:35:07.339
yeah and uh I’ll I’ll look it up
by GUID and then I can basically
do function calls into this

00:35:07.339-->00:35:11.509
other piece of functionality
it’s essentially like object
oriented programming classes.

00:35:11.509-->00:35:17.449
So, it’s it’s a really
funct-it’s a really key part of
UEFI uh everything is built on

00:35:17.449-->00:35:23.989
top of this architecture. And
uh, so the system table contains
pointers to boot services and

00:35:23.989-->00:35:30.762
runtime services um some other
uh useful things. Boot service
have uh a bunch of functions

00:35:30.762-->00:35:36.368
like memory handling, protocol
operations, uh loading and
starting other UEFI applications

00:35:36.368-->00:35:41.673
and then exit boot services.
Exit boot services is basically
what happens at the very end

00:35:41.673-->00:35:47.345
before you actually launch the
operating system. Uh runtime
services does like capsule

00:35:47.345-->00:35:52.350
operations, variable operations.
Um, the the most important boot
services functions that we have

00:35:54.652-->00:35:59.991
are locate protocol which will
allow you to find other pieces
of functionality within the UEFI

00:35:59.991-->00:36:06.364
architecture and go use that
function. Uh, load image will
basically allow you to load a

00:36:06.364-->00:36:12.370
UEFI application and then
startimage will run that so,
those are both things we can

00:36:12.370-->00:36:17.375
use. So first we need to find
the boot services pointer and it
turns out that those are

00:36:19.711-->00:36:23.815
actually saved as part of the
standard UEFI application
framework so it gets past the

00:36:23.815-->00:36:29.788
pointer to the system table and
then the initial, the code will
basically save those in global

00:36:29.788-->00:36:35.160
variables but because we don’t
have address randomization we
can predict where those

00:36:35.160-->00:36:40.265
variables are and then our
payload basically ends up
looking like this where we’ve

00:36:40.265-->00:36:45.270
got our second stage which has
basically code to call this uh
load image and start image shell

00:36:48.640-->00:36:54.946
code. The load image uh
function, you can either provide
a path to go get it out of a

00:36:54.946-->00:36:59.284
firmware volume or you can give
it a buffer and memory and
actually execute code directly

00:36:59.284-->00:37:04.222
that way. So, we’ll have code to
basically load and start
arbitrary UEFI application and

00:37:06.791-->00:37:12.964
one problem that we ran into is
that right before the return
selection that we uh overflowed,

00:37:12.964-->00:37:18.870
uh they basically called a free
function so our, our xml
document and payload that we’re

00:37:18.870-->00:37:24.008
running is in the heap but if we
trigger any, any allocations,
it’s going to corrupt the heap

00:37:24.008-->00:37:30.014
and mess with our payload so we
want to avoid that so we
basically end up copying

00:37:30.014-->00:37:34.919
everything back to a different
location, basically copying out
of the heap so that the heap

00:37:34.919-->00:37:41.025
will stay preserved and uh
things will work. So, that
actually ends up working and

00:37:41.025-->00:37:46.030
I’ll show a quick demo >>okay,
this one >>yeah, so this is the
uh so this is the uh first demo

00:38:00.545-->00:38:06.284
that we actually uh the first
exploit that we actually got
working. So, this is what the

00:38:06.284-->00:38:10.221
environment looks like we’re
basically gonna go launch the
internet flash functionality

00:38:10.221-->00:38:15.226
it’ll go check for an update and
uh see what happens. We, we
basically were able to do some

00:38:20.231-->00:38:25.236
simple text mode uh exploits so
we got code execution it worked.
[applause] we don’t want to do

00:38:28.439-->00:38:33.444
this one yet, not yet. >>okay
>>so, let’s see if I can go back
to this one so that worked. So,

00:38:38.983-->00:38:45.089
but the problem is it’s like it
wasn’t great, we had limited
space, the app was only up to

00:38:45.089-->00:38:51.596
about 12k or so and uh we also
had some issues with our payload
and coding so it turns out that

00:38:51.596-->00:38:56.768
uh if you try to use msfvenom to
end code 100k Windows
executable, it doesn’t work

00:38:56.768-->00:39:02.540
great. So, we basically made our
own payload and coding which is
just a very simple it’s

00:39:02.540-->00:39:07.512
essentially just uh we thought
about using base64 but that
includes a table and we

00:39:07.512-->00:39:14.219
basically convert our UEFI
application we want to run into
a long string of hex digits, map

00:39:14.219-->00:39:19.224
it all to a single set of uh, uh
so like basically by by having
it instead of 0 through 9 a to

00:39:23.261-->00:39:28.700
f, basically map those
characters to a through p, we
don’t need to have any branches

00:39:28.700-->00:39:35.173
or logic, it just is a copy loop
that basically looks like this
so, you just subtract a from

00:39:35.173-->00:39:40.879
each byte and then that is the
nibble that you use to rebuild
the uh the code. So that’s what

00:39:40.879-->00:39:45.884
our decode steps look like. So,
we also needed to find a better
place to actually uh put our

00:39:48.253-->00:39:53.258
payload because it turned out we
only had about 12k of space on
the stack, so we explored and

00:39:56.494-->00:40:01.399
looked around a little bit
before we uh discovered some
remembered some uh useful things

00:40:01.399-->00:40:08.139
so UEFI applications all run in
ring 0 and there’s no memory
protection between the UEFI apps

00:40:08.139-->00:40:14.879
so we can just write our code
over some arbitrary UEFI that
already exists memory and if

00:40:14.879-->00:40:19.884
it’s one that we’re not going to
trigger we don’t really care, it
just works. So let’s try

00:40:22.253-->00:40:27.258
something bigger. >>you need
that up, okay >>yeah, so it’s
basically the same thing,

00:40:42.940-->00:40:47.946
triggering the exploit
[applause] >>you want to do this
one too? >>uh not yet, so let’s

00:40:57.455-->00:41:02.393
>>okay there you go >>well that
no, yeah we should do that one
sorry. So that that was cool but

00:41:14.806-->00:41:16.808
like uh we figured let’s
actually pop a full shell and do
something more interesting. So

00:41:16.808-->00:41:18.810
this is there’s uh the tool that
Mickey mentioned, the UEFI shell
and uh it basically is like a

00:41:18.810-->00:41:20.812
big 900k executable, it’s a meg
almost 2 megs so it takes a
little bit longer but it’s

00:41:20.812-->00:41:23.481
basically showing that we can
run any arbitrary UEFI
application that exists. You can

00:41:23.481-->00:41:25.483
make your own UEFI apps to do
whatever you want like the demos
we made uh the previous ones. So

00:41:25.483-->00:41:27.485
this is a full UEFI shell, it’s
about a 2 meg executable you can
uh you can run this and it just

00:41:27.485-->00:41:29.487
works [applause]. So, let’s see
so some other ideas are you
basically you have a full

00:41:29.487-->00:41:34.492
network stack in UEFI um you can
just do a network connection
yourself, download the third

00:42:20.972-->00:42:26.511
stage from the network instead.
You could have a full command
and control capability from BIOS

00:42:26.511-->00:42:31.516
uh some some other ideas are
there’s there’s decompression
code built into UEFI you could

00:42:34.752-->00:42:39.056
decom- you could compress, you
could even encrypt your payload
and use the functionality that

00:42:39.056-->00:42:44.862
exists in UEFI to do a bunch of
more interesting things. Uh,
this particular firmware image

00:42:44.862-->00:42:50.601
contains uh NTFS driver which
you can use that if your, if
your hard drive is not

00:42:50.601-->00:42:55.606
encrypted, you could use this to
mount the hard drive from UEFI
and modify uh modify files in

00:42:58.409-->00:43:03.181
the file system drop malware
into the OS, you could
exfiltrate data and email that

00:43:03.181-->00:43:07.285
from BIOS. you could do
ransomware all kinds of stuff,
because there is a very rich

00:43:07.285-->00:43:12.790
functionality built into UEFI.
uh if you don’t have the NTFS
one you could just include it in

00:43:12.790-->00:43:17.929
the payload and bring it
yourself. Uh this is actually
what hacking team did with their

00:43:17.929-->00:43:24.268
UEFI implant they had the NTFS
driver and used that to drop an
agent into the file system to

00:43:24.268-->00:43:29.674
have their malware running in
the agent. So, some of the
mitigations that could could

00:43:29.674-->00:43:36.314
work for this is adding stack
protection, randomization, non
executable stack, none of this

00:43:36.314-->00:43:41.719
exists in the UEFI reference
code implementation. There’s
been discussions by UEF for,

00:43:41.719-->00:43:46.724
UEFI forum to start adding these
features, but this doesn’t exist
now and even if it did exist in

00:43:49.494-->00:43:54.632
the uh tianocore reference
implementation, the vendors have
their own source tree, they

00:43:54.632-->00:43:59.270
basically pull from tianocore
and have all their own stuff and
then they put it out into a

00:43:59.270-->00:44:04.208
platform in the real world and
it takes a while for that to
show up. So, this doesn’t exis

00:44:07.111-->00:44:12.817
exist now and it’ll probably be
a while before it is out there.
So, for, for recommendations for

00:44:12.817-->00:44:17.822
building your own exploits, uh
use the latest edk there, there
are directly from github from

00:44:20.024-->00:44:27.031
the head, uh there have been
like edk package releases, but
the latest one is, is best, they

00:44:27.031-->00:44:33.004
fixed a bunch of things. And
then there’s also gnu efi
package if you uh so there’s edk

00:44:33.004-->00:44:37.174
kind of build environment and
then there’s an efi build
environment, and there kind of a

00:44:37.174-->00:44:42.179
different structure gnu efi is
more of a linux make file kind
of thing and but uh ubuntu has

00:44:44.682-->00:44:49.820
versions like 2 years old so go
get the official one and use
that instead and uh do we have

00:44:49.820-->00:44:54.825
time for questions. >>I don’t
think so how much time we have?
No time >>yeah >>okay [applause]

