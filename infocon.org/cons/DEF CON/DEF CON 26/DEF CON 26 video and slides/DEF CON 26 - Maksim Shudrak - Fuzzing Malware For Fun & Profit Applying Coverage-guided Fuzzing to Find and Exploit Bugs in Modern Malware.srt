00:00:00.234-->00:00:06.306
>>So hi everyone my name is
Maksim Shudrak, uh friends call
me Max, I am a researcher. This

00:00:06.306-->00:00:11.345
is the last Defcon talk uh this
year which is really sad, but
we’re gonna talk about malware

00:00:11.345-->00:00:16.750
fuzzing in the next uh 45
minutes which is cool. So let’s
go. First of all I’d like to

00:00:16.750-->00:00:22.656
thank Defcon Goons who gave me a
chance to speak on this stage.
This is a real honor for me and

00:00:22.656-->00:00:28.161
this is the first stop at Defcon
in my life ever. So I am talking
and this is first Defcon. I am

00:00:28.161-->00:00:33.867
really excited and enjoy to be
here. Uh originally I am from
Russia. Defended PHD there, did

00:00:33.867-->00:00:40.540
more research in 2000 uh 16 uh
had the chance to work on
malware analysis in Israel for 2

00:00:40.540-->00:00:45.546
years and since 2018 I’ve been
living in the Bay area. So I’m
with you guys. As you can see my

00:00:47.748-->00:00:52.753
background combines experience
in malware analysis and uh
fuzzing. So 1 day I got an idea.

00:00:55.255-->00:01:01.461
Why not try to search for bugs
in malware? Sounds like a crazy
idea but my good friend uh

00:01:01.461-->00:01:08.402
Jonathan Brossard who actually
inspired me to present uh this
talk uh was excited. So this

00:01:08.402-->00:01:13.674
presentation is logically
divided into 3 parts. In the
first part I am going to explain

00:01:13.674-->00:01:20.314
why, where and how we can search
for bugs in malware. Uh why
coverage- guided fuzzing is the

00:01:20.314-->00:01:24.885
best technique to search for
these bugs. What kind of
problems we have to address to

00:01:24.885-->00:01:30.857
be able to find bugs in malware.
And of course uh I am planning
to show a demo my fuzzer

00:01:30.857-->00:01:37.831
implemented on top of WinAFL. In
the last part I’ll show you
several cool uh 0 day uh I found

00:01:37.831-->00:01:43.303
in different minutia samples.
And explain future directions of
work. So before I actually start

00:01:43.303-->00:01:49.643
fuzzing binaries, uh I decided
to find and look over uh some
leaked uh malware source code

00:01:49.643-->00:01:56.316
files and just understand that
this idea makes sense and it
works to spend time on it. And

00:01:56.316-->00:02:02.589
guess what? Right in the 1 of
the first uh source code files I
found this uh comment in trash

00:02:02.589-->00:02:08.161
which can be translated in the
following way. So I was
[laughter] really laughing for a

00:02:08.161-->00:02:13.734
couple of minutes I thought “Ok
uh looks like this idea makes
sense and I’m gonna find some

00:02:13.734-->00:02:20.107
bugs in this sample and probably
in another.” By the way, it’s
carbor. So when they write

00:02:20.107-->00:02:25.712
malware, they have to do a lot
of complex things uh like
initial infection, payload

00:02:25.712-->00:02:31.885
delivery, and most importantly
for us communication with C and
C uh server. Uh there are a lot

00:02:31.885-->00:02:36.890
of things that can potentially
go wrong here. So an ideal place
for us to search for uh bugs

00:02:38.925-->00:02:44.631
would be some complex parser of
the common commands from C and C
or some file- er complex uh file

00:02:44.631-->00:02:50.871
from the farser- parser. While
some samples leverage uh very
trivial algorithms to

00:02:50.871-->00:02:55.942
communicate with C and C the lot
of samples that support uh
really complex communication

00:02:55.942-->00:03:02.649
protocols uh implemented from
scratch. Despite of this
complexity, uh bad guys usually

00:03:02.649-->00:03:09.156
uh are rarely interested in
implementing securer code uh for
many reasons, such as lack of

00:03:09.156-->00:03:15.395
time, of uh expertise. So in
most cases we will not see
things like SLR, dev or any

00:03:15.395-->00:03:20.700
other anti-exploitation
techniques which is actually uh
good for us. Now sometimes the

00:03:20.700-->00:03:26.006
code is so badly written that
malware doesn’t uh work if
environment has slightly

00:03:26.006-->00:03:31.545
changed. This too to actually
explain, it’s quite a lot. So
and of course searching for bugs

00:03:31.545-->00:03:37.851
in bad guys’ code could not be
boring, so I hope you think the
same. So hacking back in general

00:03:37.851-->00:03:43.523
is pretty well known research
topic. Uh there are a bunch of
great uh talks at DefCon

00:03:43.523-->00:03:49.196
presented- presented in- in the
past. I can safely guess this
idea has lived with hackers’

00:03:49.196-->00:03:54.201
community for decades. Uh just
listed 2 of uh cool DefCon talks
presented last year. But what

00:03:57.170-->00:04:03.276
about uh fuzzing malware? Well
there are much much less uh
publications in this field.

00:04:03.276-->00:04:09.382
Actually there is no systematic
research uh on this topic at
all. I found uh several research

00:04:09.382-->00:04:14.387
uh papers published by academia.
But uh the main goal of this
research was uh to find and

00:04:17.324-->00:04:23.463
trigger some uh malicious code
bugs uh hidden in malware using
fuzzing which is a bit opposite.

00:04:23.463-->00:04:29.336
In this talk I’m focusing on
bugs hunting and how we can use
these bugs uh to defend uh

00:04:29.336-->00:04:36.209
against malware. So legal
issues. Uh it’s less relevant
for this talk but anyway. I want

00:04:36.209-->00:04:42.082
to say that hacking back is in
very very deep gray zone. The a
lot of uh questions with uh

00:04:42.082-->00:04:47.087
attack attributions, uh scopes
of attack, uh and a lot of other
things. So but no one can stop

00:04:49.156-->00:04:54.161
us to search for bugs in malware
so it- it's obvious. Cool. And
now understand how maturation

00:04:56.229-->00:05:01.568
and legal aspects. Let’s say we
found some bug in malware. What
kind of benefits we can get from

00:05:01.568-->00:05:07.407
that? Let’s imagine that we
found some memory corruption bug
that lead to crash in some

00:05:07.407-->00:05:12.846
sample that is spreading around
the planet. Uh such bug uh
actually might be quite useful.

00:05:12.846-->00:05:18.485
I guess many of you remember uh
famous killswitch found in uh
WannaCry which significantly

00:05:18.485-->00:05:24.257
helped uh to slow down spreading
of the sample. If you place 1
file with special name in 1

00:05:24.257-->00:05:30.297
specific folder, uh WannaCry
will not infect your machine. Of
course uh they le-left this

00:05:30.297-->00:05:36.436
killswitch on purpose. But if
you can automatically or semi
automatically find uh some

00:05:36.436-->00:05:41.374
memory corruption for example in
some complex file parser, we
don’t even need such gifts from

00:05:41.374-->00:05:48.081
them. We can just uh place this
file in our uh operating system
and malware will not infect this

00:05:48.081-->00:05:54.721
machine. Besides that if we can
somehow trigger such bug
remotely we would be able to do

00:05:54.721-->00:05:59.726
a lot of other cool things. Uh
like uh we can uh stop malware
from spreading our- on our

00:06:01.895-->00:06:08.802
network, or slow down it or shut
down existing agents, just by
modifying network like it’s

00:06:08.802-->00:06:13.940
coming to and from C and C. It’s
especially cool if you can do
that against Botnet that are

00:06:13.940-->00:06:20.614
trying to perform a DDoS attack
against us. For example if bots
have some uh vulnerabilities in

00:06:20.614-->00:06:26.486
the victim’s response parser, eh
we just need to send our exploit
back to bots and uh it will

00:06:26.486-->00:06:32.559
cause a crash. Later in the demo
I’ll show that uh actually it’s
possible. Well, it would be

00:06:32.559-->00:06:37.197
really great if you can trigger
remote code execution here. Of
course we can take uh control

00:06:37.197-->00:06:43.637
over botnet or shut down
existing agents or track down
botnet owners and do a lot of- a

00:06:43.637-->00:06:49.876
lot of other uh cool things
here. And of course our sweet
dream bug is uh remote code

00:06:49.876-->00:06:55.482
execution in C and C. In this
case we have God mode and can do
everything. But in my opinion

00:06:55.482-->00:07:01.187
it’s less likely today because
uh most C and C are written in
memory safe languages like

00:07:01.187-->00:07:06.192
Python, PHP, Go, or any other. I
don’t see any reason to write it
in CoC++. OK how can we search

00:07:10.997-->00:07:16.870
for these bugs? Uh today fuzzing
is the most efficient if you
need to search for uh bugs in

00:07:16.870-->00:07:21.675
memory unsafe languages.
Actually fuzzing is very
important for software security

00:07:21.675-->00:07:27.614
at all. Uh top tech companies,
uh huge open source projects who
integrated uh fuzzing within

00:07:27.614-->00:07:32.886
development lifecycle, uh they
all report that this technique
improves security of their

00:07:32.886-->00:07:38.591
products. Uh Linus Torvalds
recently said that fuzzing
actually improves security of uh

00:07:38.591-->00:07:44.064
Linux kernel which is really
cool. Okay what’s fuzzing?
Fuzzing is actually very simple

00:07:44.064-->00:07:48.702
technique. You provide
potentially invalid or malformed
input to your program and

00:07:48.702-->00:07:54.507
monitor your program for crash.
Not so hard. So you start your
fuzzer, fuzzer generates input

00:07:54.507-->00:07:59.779
uhh and sends this input into
your program. Uh all you need is
to sit and pray that it will

00:07:59.779-->00:08:05.985
find some cool crash for you.
This picture actually precisely
explains my feelings uh when uh

00:08:05.985-->00:08:10.990
my fuzzer report a new unique
crash. Usually very happy, like
really happy. Ah okay. What is

00:08:13.226-->00:08:18.665
coverage guided fuzzing? Many
years ago when fuzzing was dump
and blind, uh fuzzers considered

00:08:18.665-->00:08:24.137
it a program as a black box and
to each was sent our test cases.
It usually worked pretty good uh

00:08:24.137-->00:08:30.777
for 3 real bugs that located not
deep in the code. People wanted
to find more complex bugs uh

00:08:30.777-->00:08:34.881
deeper in the code so they
decided to instrument program on
the test, add compilation stamp

00:08:34.881-->00:08:39.886
and provide this coverage back
into our fuzzer to be able to
proftescate generation. So the

00:08:39.886-->00:08:46.693
best example of such uh fuzzing
is American fuzzy lop or AFL. So
you’re in coverage guided

00:08:46.693-->00:08:52.832
fuzzing. If you manage to find a
test case uh that triggers a new
code path in our program, and

00:08:52.832-->00:08:58.538
the fuzzer says uh this test
case comes in performs some
segmentation on top of this uh

00:08:58.538-->00:09:04.411
new file. The same for the next
code path and for the next and
this way we can touch uh much

00:09:04.411-->00:09:11.251
more code deeper in the program
and find more bugs. In theory of
course uh dump blind fuzzer at

00:09:11.251-->00:09:16.256
some point can also find these
uh bugs. But it can take a lot
of t- time to find them. So the

00:09:18.658-->00:09:23.930
best example is this code. In
case of coverage guided fuzzer,
it’s gonna take about several

00:09:23.930-->00:09:29.936
minutes uh to find this new
point of the reference but in
case of dump blind fuzzer it can

00:09:29.936-->00:09:34.941
it can take years to find the
same problem. So you see why
coverage guided fuzzer is a uh

00:09:37.043-->00:09:42.048
really powerful too. It- it can
be so effective. Okay today
there are 2 state of the art

00:09:44.384-->00:09:49.389
fuzzers. It’s AFL and Libfuzzer.
Uh there are a lot of AFL forks
implemented on top of uh AFL. So

00:09:52.725-->00:09:57.730
for example I really recommend
this kernel flosser kAFL and
what is more important for us is

00:09:59.766-->00:10:04.771
WinAFL a fork of AFL uh for
Windows binaries. Uh sorry. So
AFL injects uh instrumentation

00:10:12.479-->00:10:18.151
routines uh during the
compilation step. So the result
in binary will have this uh AFL

00:10:18.151-->00:10:23.156
maybe log uh func- function
injected in each uh basic block.
Uh in case of malware we have uh

00:10:26.025-->00:10:32.599
1 tiny problem, we don’t have
source code so I guess it’s no
surprise right. Uh actually we

00:10:32.599-->00:10:37.604
have even more problems. Malware
usually unpack and execute uh
code most important part of

00:10:40.473-->00:10:45.945
malware uh dynamically. At run
time in this case source code
instrumentation is useless. We

00:10:45.945-->00:10:51.551
have to find some way to be able
to provide back to our fuzzer
coverage of such dynamically

00:10:51.551-->00:10:57.323
unpacked and executed code
paths. And we can try some other
tools uh and techniques of

00:10:57.323-->00:11:03.963
automatic malware deobfuscation,
but uh in my opinion it’s uh
less scale-able and works only

00:11:03.963-->00:11:08.968
for a specific subset of uh
samples. So besides that uh if
you want to search for bugs in C

00:11:11.838-->00:11:17.010
and C communication, we have to
encrypt our test cases the same
way as malware, so we have a lot

00:11:17.010-->00:11:22.015
of uh problems here. But thank
God uh WinAFL uh doesn’t need
source code for binary fuzzing

00:11:24.884-->00:11:30.256
so- so we don’t need uh inst- we
don’t need source code of file
sample. Instrumentation is

00:11:30.256-->00:11:36.563
implemented on top of DynamoRIO
dynamic binary instrumentation
framework. What is uh dynamic

00:11:36.563-->00:11:42.835
binary instrumentation? Uh I’ll
call it DBI. DBI is a technique
of uh analysing the behavior of

00:11:42.835-->00:11:48.308
a binary application at run time
thr- through the injection of
instrumentation code. I just

00:11:48.308-->00:11:53.313
want you to get a basic idea how
it works. Let’s say we have our
DBI engine and binary, we want

00:11:56.282-->00:12:01.321
to instrument. At step 1 uh
DynamoRio launch this binary
suspended, inject

00:12:01.321-->00:12:06.225
instrumentation library, hook
entry port to redirect control
flow into your instrumentation

00:12:06.225-->00:12:12.632
uh library, and resume
execution. Uh so at this point
it looks like a traditional

00:12:12.632-->00:12:17.637
classic uh DBL injection and
control flow hijacking. But at
step 4 starts the magic. Uh

00:12:19.772-->00:12:26.579
DynamoRio takes the first uh
basic block, copies it, and in
special place called code cache,

00:12:26.579-->00:12:31.484
then it performs transformation
of this basic block to be able
to inject uh instrumentation

00:12:31.484-->00:12:37.323
routines instructions specified
by user and then executed in
this sp- uh uh special code

00:12:37.323-->00:12:43.129
cache. The most challenging
stuff is to make this execution
transparent towards instrumented

00:12:43.129-->00:12:48.701
binary. And DynamoRio knows how
to do this. It’s really
complicated task and they’re

00:12:48.701-->00:12:53.973
doing pretty good. So then it
takes next basic block, copies
in co- code cache, perform

00:12:53.973-->00:12:58.645
transformation, injects uh
instrumentation routines,
execute it, take the next one

00:12:58.645-->00:13:05.118
and so on until uh we reach exit
point of our program. So you can
see this way we can instrument

00:13:05.118-->00:13:10.123
everything that uh executed uh
on our CPU. So we had 3
challenges. Lack of source code,

00:13:13.126-->00:13:19.666
obfuscation, and encryption.
WinAFL plus DynamoRIO solves the
first problem and actually

00:13:19.666-->00:13:24.771
creates a new one. WinAFL
supports only file based
fuzzing. So we can’t actually

00:13:24.771-->00:13:29.776
perform fuzzing of uh network
traffic parsers which is a very
very serious limitation for us.

00:13:32.645-->00:13:38.451
To address this problem I
decided to implement a patch of
uh a patch on top of WinAFL and

00:13:38.451-->00:13:44.190
call it uh netAFL. Suppose we
have uh our fuzzer and our
malware instrumented by

00:13:44.190-->00:13:51.030
DynamoRIO in memory. Let’s
assume our sample sent uh some
request to C and C. Instead of

00:13:51.030-->00:13:56.669
actually send it to C and C we
re- redirect this request to our
fuzzer. Our fuzzer generates a

00:13:56.669-->00:14:03.509
new test case encrypts this te-
test case if it’s uh necessary
and then sends its uh response

00:14:03.509-->00:14:08.514
uh back into our sample. Then we
update our coverage bitmap uh
triggered by this test case

00:14:11.150-->00:14:17.423
estimate code coverage, uh
provides this code coverage back
to our uh fuzzer, and uh fuzzer

00:14:17.423-->00:14:23.696
generates a new test case
restart our sample uh or target
function in our sample and

00:14:23.696-->00:14:29.669
repeat all previous steps. It s-
it sounds like a bit uh complex
scheme but it’s uh actually

00:14:29.669-->00:14:35.708
pretty easy to use. All you need
is to specify IP address port to
listen on and seed file. That’s

00:14:35.708-->00:14:42.315
it. The fuzzer will do all- all
the rest for you. If you need to
encrypt your test case uh before

00:14:42.315-->00:14:47.320
send them back into our sample,
you can provide uh pass to your
custom encryption library. Uh

00:14:49.455-->00:14:54.227
NetAFL will load this library
and we will use this excellent
function to encrypt uh test

00:14:54.227-->00:14:59.832
cases. If you don’t like uh
default C and C uh you can
define your own one. If for

00:14:59.832-->00:15:05.004
example you need uh to implement
some really complex uh
communication logic uh with your

00:15:05.004-->00:15:10.009
target. Ok let’s see how it
actually works. Okay here we go.
So in this version machine I

00:15:41.474-->00:15:47.680
have a release build of netAFL.
But before I actually start uh
our fuzzer let me explain the

00:15:47.680-->00:15:52.685
code where we are uh trying to
analyze. So it’s Dexter version
2 uh malware designed to steal

00:15:56.122-->00:16:01.661
uh point of sales uh designed to
steal credit and debit card
information from point of sale-

00:16:01.661-->00:16:06.666
sales terminals. So in this
function HTTP main they have uh
in-utilization so they they

00:16:09.268-->00:16:15.575
generate agent stream then they
open connection with s- with C
and C using standard Windows API

00:16:15.575-->00:16:20.580
functions. So they will use post
request to send uh um uh
commands to C and C. Then it

00:16:23.683-->00:16:28.087
gets some information about
victims machine and then
actually send this data via

00:16:28.087-->00:16:33.593
standard Windows API functions.
If uh they successfully send
this data they call this

00:16:33.593-->00:16:38.598
function Get Cookie. So let’s go
in this function. Uh in this
function uh they uh receive uh

00:16:42.235-->00:16:48.307
commands from C and C coming
back. Uh we are browser cookies
so this function internet Get

00:16:48.307-->00:16:53.946
Cookie uh is used for this
purpose. So it’s very trivial
function. You just call it and

00:16:53.946-->00:17:00.253
you get your command, and you
get your cookies in bit command
uh variable. So then they

00:17:00.253-->00:17:05.258
perform uh some fuzzing uh they
perform uh parsing of uh this
command. And then let’s go back,

00:17:09.462-->00:17:15.301
they if- if- uh they manage to
obtain it they and command
starts with a dollar, they-

00:17:15.301-->00:17:21.240
they’re going to execute uh this
command. So this way they
implement communication with C

00:17:21.240-->00:17:26.245
and C. So as you can see uh we
need uh to implement some um uhh
w- some not trivial

00:17:31.117-->00:17:34.687
communication logic with our C
and C so we need to implement
our uh custom C and C library.

00:17:34.687-->00:17:36.689
Okay. Oh it- it’s actually not
hard. Uh all we need is to
define uh 2 functions. So this

00:17:36.689-->00:17:41.694
is our custom C and C we need to
define C and C init receives
server port to listen on, then

00:17:49.035-->00:17:54.040
we have [indiscernible]
utilization of these circuits
and then we can co-listen on

00:17:56.876-->00:18:03.749
this port. And we have to
implement the second function, C
and C run. It receives um test

00:18:03.749-->00:18:09.455
case from netAFL for each
generated uh test case that
netAFL wants to send in our

00:18:09.455-->00:18:14.460
sample. So in this case uh we
have to accept this connection,
uh receive the- this data coming

00:18:17.697-->00:18:24.570
from our malware, generate our
response, we- we have to say for
malware that everything is ok,

00:18:24.570-->00:18:30.576
we’ve received your request,
this is your response and you
can get your cookies. Uh then we

00:18:30.576-->00:18:35.548
generate cookie this nice uh
function from M- Microsoft
internet set cookie uh we

00:18:35.548-->00:18:40.553
generate uh this cookie on top
of uh on on top of uh data
provided by netAFL. And that’s

00:18:43.255-->00:18:48.260
it. So this way we can compile
this binary and provide path to
our uh fuzzer. Okay. This is

00:18:52.865-->00:18:57.870
command to run uh AFL. NetAFL.
It’s- it looks like a pretty
long command but actually it’s

00:19:00.539-->00:19:07.146
not hard to- to understand. Uh
the first argument defines uh
path to our uh custom C and C,

00:19:07.146-->00:19:12.151
uh library. Uh the second
parameter is a port to listen
on. The 3rd and 2nd uh 4th

00:19:14.553-->00:19:21.460
parameters uh standard AFL in
and out directories. Uh in
directories should have a seed

00:19:21.460-->00:19:26.465
file minus despecified uh
address of our uh DynamoRIO
binaries. Minus these timeouts.

00:19:29.468-->00:19:34.473
Then we have uh internal WinAFL
uh c- uh arguments. You can find
detailed explanation on GitHub.

00:19:37.510-->00:19:42.515
And then we have re- re- really
port- important argument fuzz
iterations. Uh this um argument

00:19:45.217-->00:19:51.257
tells uh NetAFL how many
iterations uh should pass uh
before actually restart the

00:19:51.257-->00:19:57.963
whole target uh sample. So this
parameter can directly affect uh
your stability. So this is very

00:19:57.963-->00:20:04.136
important. So in my case I
choose 5-->000. It works pretty
well for me. So and the last

00:20:04.136-->00:20:09.141
parameter is the path through
our uh malware. Ok let’s run. So
it’s in utilization, everything

00:20:14.013-->00:20:20.119
loaded uh successfully,
initialized. And in a few
seconds we will see the standard

00:20:20.119-->00:20:25.124
AFL uh screen. Ok here it is.
That’s not related. So as you
can see our fuzzer stats uh

00:20:29.929-->00:20:34.934
looks pretty healthy. We have uh
we already found like 2, 6 uh uh
paths; uh we have coverage our

00:20:38.871-->00:20:43.876
stability looks pretty good 97
percent. Uh execution speed is
growing but it’s still uh very

00:20:46.178-->00:20:51.984
slow because we are running a
very slow version machine with
no authorization. But if we can

00:20:51.984-->00:20:56.989
leave our fuzzer like this for a
couple of hours, we can find
bugs. Ok. Let’s start. So if you

00:21:10.102-->00:21:16.375
leave our fuzzer for 4 hours uh
with no pre authorization it
will easily find several bugs in

00:21:16.375-->00:21:22.781
our sample. Ok great uh let’s
see what I managed to find in
malware. First malware I

00:21:22.781-->00:21:29.421
selected uh for my experiment
was Mirai. Mirai is malware that
targets IoT devices and uses

00:21:29.421-->00:21:35.861
devices as a part of botnet for
large scale and DDOS attacks.
This malware was used in some of

00:21:35.861-->00:21:42.801
the largest and most disruptive
DDOS attacks in history which
cause major internet platforms

00:21:42.801-->00:21:48.507
and services to be unavailable
for large amounts of users in
different regions uh of the

00:21:48.507-->00:21:55.147
world. In 2017 uh source code of
Mirai was leaked and different
Mirai like uh botnets adopted

00:21:55.147-->00:22:00.953
this code and still operating it
in the wild. The fun fact about
Mirai that I- it looks like

00:22:00.953-->00:22:07.159
actors even followed some uh
security practices and used
memory and debugging tool

00:22:07.159-->00:22:14.033
electric fans to search for heap
overflows and uses uh up to 3
blocks which is a bit uh unusual

00:22:14.033-->00:22:20.573
for malware. Uh Mirai DDoS
capabilities uh are based on the
HTTP flood and several low level

00:22:20.573-->00:22:26.045
uh networks attacks. The most
interesting part was in terms of
exploitation would be this uh

00:22:26.045-->00:22:31.050
HTTP response uh parser. Mirai
needs to parse HTTP response uh
coming back from victims. To be

00:22:33.385-->00:22:38.390
able to perform HTTP flood
attack. This parser has uh about
830 lines of code, hundreds of

00:22:41.193-->00:22:47.333
potentially dangerous operations
with uh memory, with pointer
strings, so this is a wonderful

00:22:47.333-->00:22:52.338
target for our fuzzer. As a seed
file I decided to use uh this
very basic uh HTTP response. Uh

00:22:55.841-->00:23:02.381
I ran my fuzzer for 24 hours and
managed to find uh 43 new
crashes which was caused by a

00:23:02.381-->00:23:08.587
single bug in relative URL’s
handle. Execution speed was
around 1-->000 uh executions per

00:23:08.587-->00:23:14.960
second which is pretty good and
fuzzer managed to find uh
approximately 430 unique uh bugs

00:23:14.960-->00:23:19.965
which is also pretty good. Uh
what was the root of this bug?
Uh if our HTTP response contains

00:23:22.034-->00:23:27.039
uh relative uh URL this code
branch is uh triggered. In case
of uh incorrect uh relative URL

00:23:29.875-->00:23:35.614
variable double i, uh always
equal- equals negative values
which uh cause a memory

00:23:35.614-->00:23:40.619
violation and crash. This is
logical error. So actors uh
forgot to uh set up this uh

00:23:42.688-->00:23:47.693
argument to 0. They use it uh in
code theory and forgot to set it
in case of relative URLs. So

00:23:51.430-->00:23:57.603
this is 1 example of uh test
case that caused a crash so if
you see that Mirai or Mirai like

00:23:57.603-->00:24:02.775
botnet is trying to attack you,
you can just answer this bot
with this uh HTTP response and

00:24:02.775-->00:24:07.780
they will all crash. So
[audience murmurs] let me show
how it actually works. Okay. So

00:24:15.821-->00:24:20.826
in this version machine in the
right uh terminal we have our,
just a second, uh in the right

00:24:26.365-->00:24:31.370
terminal we have our uh HTTP
server, our victim implemented
in Python. So it’s just a simple

00:24:33.706-->00:24:38.711
HTTP uh server. In the left, uh
part, uh we have debug build of
uh Mirai. Debug build because uh

00:24:40.746-->00:24:45.317
we want to see what’s actually
going on, and in debug build
they are printing a lot of

00:24:45.317-->00:24:51.857
information which is useful for
demo. Okay let’s start our
server. So I guess it’s start

00:24:51.857-->00:24:56.862
and running. Um before actually
start Mirai let me explain 1
thing. So uh before actually

00:25:02.868-->00:25:07.873
start HTTP flood attack uh they
need to connect with C and C. Uh
I was too lazy to deploy actual

00:25:10.175-->00:25:15.948
C and C server so I decided to
implement in this Python um
script uh C and C and just a

00:25:15.948-->00:25:22.020
response like random data to our
Mirai sample and surprisingly
for me it worked. So after

00:25:22.020-->00:25:27.426
dozens of attempts it st- it
actually start uh HTTP flood
which is good. So it it was like

00:25:27.426-->00:25:29.962
really easy solution for me. So
to be clear uh my Python server
is now doing 2 jobs. The first

00:25:29.962-->00:25:34.967
one is to be uh HTTP uh response
server victim. And the second
one is to be a C and C for our

00:25:43.142-->00:25:48.147
Mirai. To answer that everything
is ok, I’m up, let’s start. So
okay let’s run. So you can see

00:25:52.684-->00:25:58.891
it start in debug mode, it tries
to attempt uh to connect with uh
C and C and after dozens of

00:25:58.891-->00:26:03.829
attempts it will receive some
meaningful data and actually
start the HTTP flood. Okay here

00:26:07.199-->00:26:13.572
it is. So it’s starting uh HTTP
flood it’s sent an HTTP request
to our Python server and Python

00:26:13.572-->00:26:19.244
server is going to answer with
this malicious HTTP response
I’ve shown in- in the previous

00:26:19.244-->00:26:24.249
slide. Okay so here it is we
have segmentation fall and crash
so profit. This way we can stop

00:26:26.585-->00:26:31.590
uh Mirai to attack us.
[applause] Okay thank you. There
is more bugs in different

00:26:42.701-->00:26:47.706
samples. So. I already presented
this sample when I was showing
NetAFL. This is Dexter version

00:26:50.542-->00:26:56.648
2. The first version of Dexter
was uh 1 of the first uh known
botnets that targeted point of

00:26:56.648-->00:27:01.587
sale uh terminals. As I already
said in the demo, Dexter
communicates uh with C and C or

00:27:03.622-->00:27:09.561
HTTP protocol via post request
and receives commands over the
response cookies. Actually in

00:27:09.561-->00:27:15.067
case of Dexter, uh you don’t
need fuzzing at all. Uh the
malware code is so badly written

00:27:15.067-->00:27:20.072
that uh you can just answer with
uh a long command and it it will
crash. And actually it’s a

00:27:22.608-->00:27:27.613
remote code execution you can
find actually. You see this URL
it has 255 bytes but you can

00:27:29.681-->00:27:35.988
send a command longer this- than
this 255 bytes and it will cause
stack overflow and we can

00:27:35.988-->00:27:42.361
exploit it. And as I said before
there’s no uh anti-exploitation
techniques, it’s like 90’s, we

00:27:42.361-->00:27:47.366
can easily uh cause remote code
execution. So a really old
school bug. TinyNuke. Uh

00:27:49.701-->00:27:54.740
TinyNuke is a Zeus style bug in
Trojan designed to perform when
there’s a browser attack uh

00:27:54.740-->00:28:01.246
using web injects. Uh it has a
function load web injects uh the
name of this function I guess is

00:28:01.246-->00:28:06.251
pretty self explanatory. It is
designed to ask C and C server
uh provide a payload to be

00:28:08.320-->00:28:14.993
injected in the victim’s browser
and then uh this uh response is
it’s represented as JSON in JSON

00:28:14.993-->00:28:20.866
format. It’s then passed into
our cut- custom JSON parser.
This JSON parser actually is

00:28:20.866-->00:28:26.838
very very complex. They
implement it from scratch so
it’s very good target for us. Uh

00:28:26.838-->00:28:33.579
this is example of seed file I
used uh to feed in NetAFL and
after 24 hours of fuzzing I had

00:28:33.579-->00:28:38.584
uh pretty good results. 3 new
paths, uh 800 executions per
second and 4 unique crashes. The

00:28:40.819-->00:28:45.824
root uh of these crashes is this
uh function. It caused infinite
recaution in case of uh a very

00:28:48.627-->00:28:53.632
long uh response which contains
only opening brackets so in my
case it was like 7-->000. So it

00:28:56.101-->00:29:01.173
will cause a very very difficult
crash and stack overflow and it
finally will trigger a crash in

00:29:01.173-->00:29:06.178
our target. So last example, uh
KINS. KINS is a banking Trojan
uh fully based on leaked Zeus uh

00:29:10.215-->00:29:16.355
source code with some uh minor
technical improvements. So all
bugs I found in KINS uh also

00:29:16.355-->00:29:21.460
related to Zeus. This example
has been used to attack
financial institutions in

00:29:21.460-->00:29:26.465
Europe. It has uh HTTP response
parser. So I decided to use a
simple HTTP response as a seed

00:29:29.368-->00:29:34.373
again. As the trojan receives uh
payload and commands from uh C
and C over HTTP protocol, the

00:29:37.242-->00:29:44.082
HTTP response is then parsed by
2 complex routines analyze the
HTTP response and analyze uh

00:29:44.082-->00:29:49.087
HTTP response value. And again
it’s very interesting target for
us. Uh 24 hours of fuzzing g-

00:29:52.124-->00:29:57.129
get me 22 unique crashes which
was uh triggered by 1 problem.
This time it was a bit more uh

00:29:59.965-->00:30:06.505
complex. So function Get Mime
header is used to extract the
value of uh content lines from

00:30:06.505-->00:30:11.510
HTTP response. But if the string
contains uh a value um, ah if
the string doesn’t contain a

00:30:13.512-->00:30:19.551
value of content length at all
it causes an integer overflow
and as a result the function

00:30:19.551-->00:30:24.890
will return negative values. So
this Get Mime header will return
negative values. But then

00:30:24.890-->00:30:31.863
CopyExA is covered with this uh
value returned by Get Mime
header so in my case it was

00:30:31.863-->00:30:37.736
always uh negative 3. It will
try to override the whole memory
layout of our sample. So if it

00:30:37.736-->00:30:43.175
tried to put a with negative 3
it means that we are trying to
override the whole memory

00:30:43.175-->00:30:49.748
layout. It’s probably
exploitable we can sometimes uh
control this uh negative value

00:30:49.748-->00:30:54.753
but uh I’m not sure 100 percent.
So this is example of uh crash
case. We just need to send

00:30:57.222-->00:31:02.160
content links with wrong value.
Okay let’s discuss challenges
and issues. Uh first of all of

00:31:05.163-->00:31:08.333
course in my case I have to say
that I skipped the hardest part.
Uh reverse engineering and

00:31:08.333-->00:31:11.903
searching for target function. I
took source code to reduce time
of searching for a target. Of

00:31:16.808-->00:31:22.781
course for real world uh samples
you need to perform like uh
initial reverse engineering of

00:31:22.781-->00:31:28.286
your sample and find this target
function you want to analyze.
Sometimes it can uh it can take

00:31:28.286-->00:31:33.291
a lot of time. Secondly uh of
course uh there are bugs in
WinAFL, NetAFL, DynamoRIO

00:31:35.427-->00:31:41.466
especially when you deal with uh
highly obfuscated samples. And
third you need to find test

00:31:41.466-->00:31:46.738
case. So you need the seed file.
Sometimes it might be really
difficult especially if uh C and

00:31:46.738-->00:31:52.444
C is down or you don’t know what
kind of file malware wants so
it- it might be challenging.

00:31:52.444-->00:31:57.449
Then we have a problem with uh
encryption. So sometimes
encryption of it is very complex

00:31:59.618-->00:32:06.024
and I know it’s the- might be
really painful to perform
reverse engineering of this uh

00:32:06.024-->00:32:11.463
algorithm. In this case you can
try to patch program just to
disable encryption at all. It

00:32:11.463-->00:32:18.370
worked for me, sometimes. And
stability. Uh stability plays
like critical role when you’re

00:32:18.370-->00:32:24.309
doing coverage guided fuzzing.
So if you’re stability if you’re
coverage is always uh different

00:32:24.309-->00:32:29.815
when you send uh the same test
case in your target. It means uh
that um you're um target is

00:32:29.815-->00:32:35.287
unstable and your fuzzer doesn’t
understand what’s going on
actually. So it’s sending 1 file

00:32:35.287-->00:32:40.325
and it goes different code
paths. It- it’s strange and
usually uh it means that you

00:32:40.325-->00:32:45.864
waste your coverage guide uh
guided- fuzzer to nothing. So
you have to pay attention for

00:32:45.864-->00:32:50.869
this. I also found this very
this tool very useful when you
uh want to find a target rooting

00:32:53.371-->00:32:59.477
in uh in your sample. I have
implemented this tool on top of
uh [clears throat] DynamoRIO.

00:32:59.477-->00:33:04.416
It’s basically a trace uh for
Windows but uh transparent uh
towards uh instrumented program.

00:33:06.685-->00:33:13.491
So it will trace all uh API
calls in malware and bring t- uh
this information in the file. So

00:33:13.491-->00:33:19.631
it’s less uh detectable than
standard API call tracer so I
hope that it will work for you,

00:33:19.631-->00:33:26.037
you can try it, it’s open
source, there’s the license, so
take it. In future I guess it

00:33:26.037-->00:33:30.842
would be really cool if you
could- if you can uh somehow
find this target function uh

00:33:30.842-->00:33:37.082
for- for our fuzzer
automatically. Uh also it would
be great to increase stability.

00:33:37.082-->00:33:42.554
I implemented some heuristics to
make it more stable, uh it
worked for me I hope it will

00:33:42.554-->00:33:48.593
work for you. And it would be
great to have some code coverage
visualization uh tool for your

00:33:48.593-->00:33:53.598
fuzzer. I know there are some of
them but it would be great to
adapt it for NetAFL. And of

00:33:56.835-->00:34:01.973
course improve stability. Okay
so I hope uh I convinced you
that bugs in malware might be

00:34:01.973-->00:34:06.978
useful and you can really find
uh uh these bugs using fuzzing
technique. Of course uh net-

00:34:09.080-->00:34:15.287
NetAFL can and should be used to
find bugs in network based uh
applications. So it’s general

00:34:15.287-->00:34:20.091
purpose part of the fuzzer. I
designed it to be general
purpose. Uh you can use it to

00:34:20.091-->00:34:26.431
find bugs in benign software. So
I recently found one CE in
network based application for

00:34:26.431-->00:34:31.436
Windows. So you can try it. And
I’m also currently merging this
project with uh WinAFL just to

00:34:33.705-->00:34:38.710
reduce amount of different
projects on this planet. So uh I
guess I’m going to finish this

00:34:41.212-->00:34:45.750
work in 2 or 3 weeks so you-
you- you don’t need- uh in
future you will not need uh

00:34:45.750-->00:34:50.755
NetAFL everything will merged
with the uh original branch of
WinAFL. And soon, probably in

00:34:53.058-->00:34:58.063
September I’m going to release
uh f- NetAFL for Linux. I hope
in September. Thank you for your

00:35:00.899-->00:35:05.904
attention. So. [applause]

