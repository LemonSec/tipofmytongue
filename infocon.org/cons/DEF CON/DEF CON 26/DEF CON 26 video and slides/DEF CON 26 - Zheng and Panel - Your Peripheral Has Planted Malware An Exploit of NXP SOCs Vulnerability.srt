00:00:00.267-->00:00:05.272
>>Alright, so this is the uh
UnicornTeam 360Technology, and I
will let them go. >>Good

00:00:11.044-->00:00:16.049
afternoon, everyone. Thank you
for attending this talk. It's
our honor to hear our research

00:00:21.088-->00:00:26.093
with you. In this presentation,
we are going to talk about our
vulnerability where found in NXP

00:00:30.631-->00:00:35.636
SOCs and then we will show you
how to use this vulnerability to
implant malware into the

00:00:40.140-->00:00:45.145
peripheral, which are made of
these chips. Now let me firstly
give a brief self introduction,

00:00:49.416-->00:00:54.421
My name is Yuwei. I'm a security
researcher of UnicornTeam. And
this a Shaoken Cao, he founded

00:01:00.427-->00:01:05.432
this vulnerability. And then
that is my colleague,
[indiscernible]. UnicornTeam is

00:01:09.102-->00:01:14.107
a research group with 360
technology, the team was formed
in twenty fourteen we focus on

00:01:21.715-->00:01:26.720
the security issues in numerous
types of wireless systems.
During this talk, furtherly, we

00:01:32.759-->00:01:37.764
will introduce why we do this
research. Then we will discuss
the secure boot and it’s

00:01:42.269-->00:01:47.274
different types of
implementation. Secondly, we
will reveal the detail of a

00:01:49.843-->00:01:54.848
ability we provided two exploits
one is to bypass the unicode ID
notification in secure code

00:01:58.952-->00:02:03.890
another is to implant malware in
a peripheral finally we will
give our recommendation to when

00:02:07.894-->00:02:12.899
do we use the chips. So couple
things why do we using personal
computer, workstation, server

00:02:18.171-->00:02:23.176
and the smartphone. It's used to
prove the managers code from
being loaded and executed. But

00:02:28.448-->00:02:33.453
in the embedded system. Because
it's resource isn’t emptied
there is no TPM or cost alone

00:02:38.158-->00:02:43.163
within these systems so how to
implement Secure Boot? We want
to research the implementation

00:02:48.068-->00:02:53.073
of secure boot in
cost-constrained systems and
then try to find a common way to

00:02:58.078-->00:03:03.016
implant the malware into such
system. Let’s have a basic
understanding of secure boot. In

00:03:06.219-->00:03:11.224
this picture in the sys in the
system we can have secure boot
supporter there is a primary

00:03:21.334-->00:03:26.339
bootloader and uh I want I want
to program memory in the main
keyboot in the main key boot.

00:03:35.515-->00:03:42.255
The primary bootloader is
designed by the chief wonder and
the permanently binding to it’s

00:03:42.255-->00:03:47.260
bootloader and the chip
manufacturing slave. The one
time programmer bar memory is

00:03:52.999-->00:03:58.004
used to store the root pukin key
it will bend to the product
manufacturing stage in the

00:04:07.848-->00:04:12.853
internal storages there are
secondary bootloader OS kernel
driver application corresponding

00:04:18.058-->00:04:23.063
Puk K signature [indiscernible].
When the system is the primary
bootloader will work as a

00:04:30.937-->00:04:35.942
secondary bootloader, if the
secondary bootloader is worried
it will be ex executed then the

00:04:40.814-->00:04:45.819
secondary bootloader will verify
the kernel and so on. Otherwise
the system will be hard this

00:04:52.058-->00:04:57.063
mechanism ensures all the binary
code are executed in this
[indiscernible] we also can see

00:05:02.335-->00:05:07.340
the primary bootloader and the
root public key is the root of
the hard process came the master

00:05:11.711-->00:05:16.716
cannot be replaced or bypassed.
So what can secure boot be used
for? Secure boot can be used to

00:05:23.723-->00:05:28.728
prevent the [indiscernible]code
from being executed. Here I give
two attack example, one example

00:05:31.665-->00:05:36.670
is a talk of Black Hat
conference US fourteen in this
talk the author prioritied a way

00:05:40.974-->00:05:45.979
to inject the management feature
into a 4G modem dangle and then
attack it’s users. Another

00:05:50.016-->00:05:55.021
example here research provided
about him in DefCon 23, we
modified the the firmware of

00:05:57.891-->00:06:02.829
femoto cell to use nearby
cellular users. If these
products have secure boot such

00:06:08.101-->00:06:13.106
attack are hard to perform
again. Secure Boot also can be
used to protect the copyright of

00:06:16.910-->00:06:21.915
product [indiscernible] and the
[indiscernible] hardware
different types of secure boot

00:06:28.989-->00:06:33.994
have been implemented and used
one example is UEFI in personal
computer on the server with the

00:06:37.964-->00:06:42.969
support of PPM just the trusted
operating system is allowed to
load and boot, another example

00:06:45.071-->00:06:50.076
is the smart phone, with the
support of trusted zone only the
trusted OS can boot and the

00:06:54.247-->00:06:59.252
trusted application can be
installed and executed. Both the
two implementations require the

00:07:02.489-->00:07:07.494
hardware support. The special
hardware you need to ensure, the
boot room and the topic key can

00:07:10.163-->00:07:15.168
not be replaced but in the
embedded system or IoT system
due to the limits on cost there

00:07:20.240-->00:07:25.245
is no hardware unit like trusted
zone, hardware implements secure
boot. Many achieve windows

00:07:28.648-->00:07:33.653
design, a lot of SOCs for such
cost sensitive user case these
SOCs integrate a lot of

00:07:40.327-->00:07:45.332
components such as flash, ram,
timer, radio [indiscernible] and
so on which means most of the

00:07:51.671-->00:07:56.676
aimed application scenarios it
only requires very few internal
components to design a product

00:07:59.212-->00:08:04.150
with this type of cheat so it’s
widely accepted because it’s
easy to use in the log coaster.

00:08:07.153-->00:08:12.158
Chief windows also design a
mechanism which can be used to
protect the firmware from being

00:08:19.933-->00:08:24.938
read out. This mechanism is
called code read protection, if
the code read protection

00:08:40.387-->00:08:45.392
function is enabled let the
attacker or in system programmer
interface or the chief will be

00:08:49.462-->00:08:54.467
disabled nobody can read out or
erase the flash through this
interface again but this also

00:08:58.104-->00:09:03.042
results the firmware cannot be
activated anymore so the
[indiscernible] the product

00:09:12.352-->00:09:17.357
window also designs the
customized bootloader and they
implemented them in the

00:09:20.827-->00:09:25.832
application programming feature
in this bootloader with IAP
support the application can be

00:09:31.671-->00:09:36.676
again opted again. As the lower
figure shows if the bootloader
is not allowed to is not allowed

00:09:46.686-->00:09:51.691
to update it the public key can
be stored in the bootloader area
this is also fully satisfied the

00:09:58.331-->00:10:03.336
requirements of secure boot.
That is the bootloader and the
public key cannot be replaced.

00:10:11.311-->00:10:16.316
To understand the how sa secure
boot can protect the design and
copyright we have to understand

00:10:19.219-->00:10:24.224
how does the copier kernel
hardware product in this picture
firstly the copier buy the piece

00:10:34.334-->00:10:39.339
of target product then he
recovers the PCB layout and the
corresponding components through

00:10:45.678-->00:10:50.683
reverse engineering, thirdly he
corrects the code protecting
mechanism to read out the

00:10:56.723-->00:11:01.661
firmware, after that he ba he
buys the same components and
their reproduce the PCBA finally

00:11:10.803-->00:11:15.808
he bangs the firmware into the
PCBA and he can batch cloning
target products. Now let’s

00:11:19.412-->00:11:24.417
calculate the cost the copier
needed to pay in this procedure,
the main cost all comes in the

00:11:29.188-->00:11:34.193
PCB reverse and the firmware
read out steps. According to the
complexity of the PCB board the

00:11:37.630-->00:11:42.635
cost of PCB reverse is from
twenty to two hundred dollars.
In the firmware read out step

00:11:47.307-->00:11:52.312
depending on the strength of the
code read protection the cost is
from two hundred to five

00:11:58.318-->00:12:03.256
thousand dollars. The total
costs of copier protection is
much lower than designing one

00:12:07.594-->00:12:12.599
this brings great savings to
business findings. So to defend
the copier, the chief window

00:12:22.775-->00:12:27.780
also design and support a unique
ID feature they give a unique
server number to each of their

00:12:30.516-->00:12:35.521
achieves, the unique ID will
effect the release of them into
the silicon and achieve the new

00:12:41.728-->00:12:46.733
section stated and they cannot
be modified again. Uh the left
figure shows the product maker

00:12:55.708-->00:13:00.647
can read out the chief ID and it
can bind with the application to
generate its sig signature when

00:13:05.051-->00:13:10.056
the system boots the bootloader
read the unique ID and the wifi
signature if the signature isn’t

00:13:14.394-->00:13:20.800
worded the application firmware
will be executed and the normal
function of the product can be

00:13:20.800-->00:13:25.805
used otherwise the product
became the break so even the
copier binds the same chief and

00:13:29.642-->00:13:34.647
binds the same firmware due to
the unique ID they will get a
break. When the secureboot is

00:13:44.290-->00:13:49.295
bent to the unique ID besides
the costs that we calculate
before the copier also needed to

00:13:53.800-->00:13:58.805
patch all corresponding passing
to bypass the unique ID and the
signature verification in the

00:14:03.609-->00:14:08.614
firmware. Because the embedded
firmware is [indiscernible]
dependent linked the cost to

00:14:13.186-->00:14:19.926
reverse and to patch the
firmware is very high according
to the complexity of the

00:14:19.926-->00:14:24.931
firmware the cost is from five
thousand to fifty thousand
dollars and the copier needed to

00:14:28.868-->00:14:33.873
pay again when the firmware is
updated. This is not a very good
deal so the unique ID is a good

00:14:39.412-->00:14:44.417
way to defend the copier. Now
let’s have a [indiscernible] of
the strength of such types of

00:14:49.455-->00:14:54.460
secure boot, how to bypass the
secure boot verification, as we
mentioned before patch is not a

00:14:57.897-->00:15:02.835
good way in high level in high
level operating system such as
Windows or Linux we can hook the

00:15:06.672-->00:15:11.677
system API to change the
behavior of the application but
not to patch the application

00:15:14.147-->00:15:19.152
into self for example we can
hook the [indiscernible] read
API to give [indiscernible] mac

00:15:23.389-->00:15:30.396
address to disable the
application but in the resource
constrained in those things is

00:15:30.396-->00:15:35.401
the hook mechanism also
effective and how to implement
it? Now let Shaokun and Hauchi

00:15:38.905-->00:15:43.910
to relay the details of the
exploit. >>Okay the NXP cortex-m
service uses the method to

00:15:53.386-->00:15:58.391
access the UID there is a
function pointer in the fixed
position of the rom after

00:16:00.993-->00:16:05.998
accessing the function pointer
you can invoke a rom function,
the UID of the chip can be

00:16:10.536-->00:16:15.541
obtained by calling this
function, this uploading is
multi functional and different

00:16:17.977-->00:16:22.982
functions can be selected
through our parameters. This is
the code that access the UID and

00:16:31.657-->00:16:36.662
uh this functions has two
parameters, one is the in entry
parameter and the first one the

00:16:39.665-->00:16:44.670
integer of the extra parameter,
is the command where the command
is fifty eight which is to read

00:16:48.574-->00:16:53.579
UID value and the UID value will
be found in the return
parameter. This is the

00:16:59.886-->00:17:04.824
description of the UID function
in the NXPs document it’s very
simple we just have to forge the

00:17:09.195-->00:17:14.200
sim function, that’s what we
will hook to. As we know debug
systems can change the actions

00:17:20.239-->00:17:25.244
of the program we can set a
debug breakpoint hardware
running or program change the

00:17:28.114-->00:17:33.119
value of a variable or a
register. In Cortex M we can do
this without changing the flash

00:17:36.923-->00:17:41.928
rom it means that if we can
write a patch and write before
the bootloader we can simulate a

00:17:47.800-->00:17:52.805
light debugger that will work
similar to a jokate debugger.
The FPB register is one of the

00:17:58.244-->00:18:03.182
registers of the debugging
system of course it can be
accessed by this attack but it

00:18:07.887-->00:18:12.892
can also be accessed by the code
if we will write code like
jokate do actually we are

00:18:17.229-->00:18:22.234
implementing a light version of
soft debugger. The FPB is used
to provide flash patch and the

00:18:31.577-->00:18:36.582
breakpoints. Flash patch means
that if a instruction accessed
by the CPU matches a certain

00:18:41.354-->00:18:46.359
address the address can be
mapped to a different location
so that a different version is

00:18:51.597-->00:18:56.602
obtained alternatively the
matched address can be used to
trigger a breakpoint event then

00:19:00.272-->00:19:05.277
the flash patch feature is very
useful for testing such as
adding a diagnostics program

00:19:08.147-->00:19:13.152
code to a device that cannot be
used in normal situations unless
the FPB is used to change the

00:19:16.822-->00:19:21.827
program control. The FPB unit
can be programmed to generate
breakpoint events even if the

00:19:30.302-->00:19:35.307
program memory cannot be altered
however it is limited to six
instruction addresses and two

00:19:41.380-->00:19:46.385
literal addresses the FPB has
two functions one is hardware
breakpoint it can generate a

00:19:50.823-->00:19:55.828
breakpoint event to a processor
to invoke debug mode such as
hard or debug monitor. Patch

00:19:59.365-->00:20:04.370
instruction or literal data from
code memory space to S ram and
uh it has six instruction

00:20:08.641-->00:20:13.646
parameters and uh two literal
comparators. Here is a very
simple example to show how to

00:20:20.686-->00:20:25.691
use an FPB, the FPB FP the map
register is set to zero x two
zero zero zero one zero zero

00:20:28.828-->00:20:33.833
zero it means that once the
converter is matched the code or
the literal data will be

00:20:36.869-->00:20:41.874
replaced by the data in map
memory in this example we set
two variables to replace one is

00:20:47.146-->00:20:52.151
the instruction another is the
literal data the FP compares
zero indicates the instruction

00:20:54.753-->00:20:59.759
in the offsetterer zero x eight
zero zero one zero zero zero
will be replaced to another

00:21:03.329-->00:21:08.334
instruction the FP compares six
indicates that the data in the
offset zero x eight zero zero

00:21:10.336-->00:21:15.341
one zero zero is replaced if we
enable FPB by set the FP
controller to start to sweet the

00:21:21.714-->00:21:26.719
x chain of the code will be
totally changed, it should be
the data in r4 it’s zero x eight

00:21:30.856-->00:21:35.861
zero zero zero zero zero zero
but actually r4 is skipped and
r1 is zero x one zero zero zero

00:21:41.634-->00:21:46.639
zero and the r4 should be zero
but negative one infect. The FPB
has a fresh patch control

00:21:56.382-->00:22:01.320
register that contains an
enabled bit to enable the FPB in
addition each comparator comes

00:22:06.091-->00:22:11.096
with a separate enable bit in
its comparator control register
those oper enable bit must be

00:22:14.033-->00:22:19.038
set to what for a comparator to
operate the comparators can be
programmed to remap addresses

00:22:23.709-->00:22:28.714
from code space to the SRAM
memory region when this function
is used the the remap register

00:22:31.517-->00:22:36.522
needs to be programmed to
provide the base address of the
remap contents the upper

00:22:42.294-->00:22:47.299
[indiscernible] of remap
register is hardwired to zero
zero one which is limited the

00:22:50.703-->00:22:55.708
remap base address location to
be within zero x two zero zero
zero zero zero zero two three F

00:22:58.978-->00:23:03.916
F F F F eight zero which is
always within the Sram memory
written. And this is a example

00:23:11.957-->00:23:16.962
to replace the literal data this
constant int data is initial to
negative one after compiling and

00:23:22.034-->00:23:27.039
the linking it will be stored
into the flash it cannot be
changed again at one time we

00:23:32.244-->00:23:37.249
program the FPB to set the
constant to remap this data to
SRAM and try to set it’s value

00:23:40.853-->00:23:45.858
to zero after we enable FPB all
codes that access this constant
will get zero. In order to

00:23:53.599-->00:23:58.604
verify this vulnerability in
real world product we used the
Jlink to implement to exploit

00:24:07.012-->00:24:12.017
before discussing the detail of
this exploit let me introduce
the Jlink, Jlink is a powerful

00:24:15.387-->00:24:20.392
emulator and debug tool for ARM
processors, it’s very useful for
ARM developers to debug their

00:24:25.431-->00:24:30.436
firmware and hardware. This tool
is designed by Saber they
implement secure boot in their

00:24:35.107-->00:24:40.112
firmware and use the unique ID
provided by NXP to verify the
license it has a USB port and

00:24:46.051-->00:24:51.056
under normal use scenarios it
must be plugged into computer so
it’s also a good carrier for

00:24:54.426-->00:24:59.431
hardware Trojan. Based on
example and the conductor of
NXPs SOC we can use the FPB to

00:25:07.373-->00:25:12.378
change the entry of rom API
function there are function
pointers in a fixed position

00:25:15.447-->00:25:20.452
therefore find out the function
pointer which you want to hook
and map it to the fake function.

00:25:29.661-->00:25:34.666
That’s part of the code, this
invokes the FPB func to the map
and go to the entrypoint of

00:25:39.004-->00:25:44.009
original program just right
before attack it. And this is
the fake IAP which is the

00:25:55.120-->00:26:00.058
original IAPs delucted to in
this example we replace the
command number fifty eight which

00:26:05.164-->00:26:10.169
is to access the UID in other
cases it will jump to the
original owned entry so that it

00:26:14.907-->00:26:19.912
only modifies the UID but will
not change any other function
you should remap the original

00:26:23.382-->00:26:28.387
function to the fake one. In
this video you can see after we
burnt the drilling firmware and

00:26:40.699-->00:26:45.704
our exploit code the development
board has the same function as
Jlink. Okay let my partner Mr.

00:26:51.910-->00:26:56.915
Hauchi finish this product. >>So
thanks for my colleague’s
explanation about the details of

00:27:01.353-->00:27:06.358
the attack so in the following
sentence I will introduce you
guys how to uh really exploit or

00:27:09.862-->00:27:14.867
illegal copy uh reproduct of the
NXP protection so in this video
we will show you how to uh copy

00:27:18.670-->00:27:23.675
uh Jlink production one step by
step uh but before that I will
really apologize for the bad

00:27:26.778-->00:27:31.783
solutions of the video uh
because we kinda like made a
mistake so in this video mmm uh

00:27:34.920-->00:27:39.925
can we make this uh doesn’t
matter see so we so I just click
uh so before we started this

00:27:43.962-->00:27:48.967
video I want to as we as we
mentioned in the previous
discussion we needed the

00:27:51.169-->00:27:56.174
firmware of the uh Jlink to do
our patch stuff because we
didn’t actually modify the

00:27:58.410-->00:28:03.348
firmware we actually patched
some kind of code sections uh
some kind of dead sections

00:28:05.684-->00:28:10.222
inside of the firmware and do
our stuff such like uh to bypass
the antichrome stuff uh anti

00:28:10.222-->00:28:18.564
chrome mechanisms and uh so in
this video we kind of like uh so
before that we needed a firmware

00:28:18.564-->00:28:25.070
of this Jlink production uh but
as we discussed before the Jlink
production has kind of like uh

00:28:25.070-->00:28:32.945
code read protections with this
protections you can’t read the
firmware outside you can’t

00:28:32.945-->00:28:39.184
exploit the firmware and uh
because there I mean if this
code read protection is enabled

00:28:39.184-->00:28:45.290
than you can’t access this
production with the Jlink uh nor
with the ISP uh programming

00:28:45.290-->00:28:50.429
system uh I mean you can
actually erase the uh data you
can actually erase the uh code

00:28:50.429-->00:28:58.070
but you can’t read them out so
but there is a very simple way
you can get the firmware and

00:28:58.070-->00:29:03.308
they basically store this
firmware ins in the desktop
applications remember Jlink has

00:29:03.308-->00:29:10.515
some software on on your PC on
your mac so so you can just
upgrade your ph uh upgrade the

00:29:10.515-->00:29:16.421
firmware of the Jlink hardware
so basically they just store
this firmware in plain text so

00:29:16.421-->00:29:24.363
you can just x through it or you
can just copy them out um with
the acquired firmware so we can

00:29:24.363-->00:29:39.211
do the uh illegal copy so start
so in the uh right bottom corner
so you can see we actually have

00:29:39.211-->00:29:44.883
a computer we actually have a
Jlink we have a development
board um on the development

00:29:44.883-->00:29:52.090
board evaluation board so you
can just see there is a exactly
same chip you know we were using

00:29:52.090-->00:30:01.700
on the uh I’m sorry my bad yeah
we were using the exactly same
chip of same micro processors on

00:30:01.700-->00:30:08.573
the evaluation board and uh this
is exact same with the Jlink uh
hardware protection so with the

00:30:08.573-->00:30:15.113
hardware we can just uh we can
just download this hardware into
the evaluation board and uh my

00:30:15.113-->00:30:21.153
colleague is just doing this
stuff so you can see oh because
the error here is means well

00:30:21.153-->00:30:34.633
actually forgot to power it up
and uh right now this is the
firmware downloading mm you can

00:30:34.633-->00:30:41.640
see so with the firmware and
with the same chip basically if
there is no license verification

00:30:41.640-->00:30:49.514
if there is if there is no uh uh
signature that’s going to its
the same product, right? Same

00:30:49.514-->00:30:55.954
hardware same software but the
truth is oh so right here if you
flash it you can see there is

00:30:55.954-->00:31:04.730
two Jlinks in the uh in the
hardware list now we launch the
Jlink software command line to

00:31:04.730-->00:31:15.373
verify if all of those are
working or not. So this is our
first one, this is the legal

00:31:15.373-->00:31:22.748
copy and uh right now we are
trying to confirm the second one
this is the illegal copy which

00:31:22.748-->00:31:27.652
is also the evaluation board see
it’s totally different because
the verification procedure is

00:31:27.652-->00:31:39.698
not passed I mean it’s failed so
after this we are trying to
deploy our uh our patch by uh

00:31:39.698-->00:31:48.273
leveraging the FPG unit so
before that remember we just
talked about there is code

00:31:48.273-->00:31:55.847
protection mechanism inside of
the firmware so if we just burn
this firmware and we run it then

00:31:55.847-->00:32:01.419
the evaluation board is dead
because you can’t actually uh
you can’t actually erase you

00:32:01.419-->00:32:08.894
can’t actually uh program it by
[indiscernible] the right? but
there is also another way just

00:32:08.894-->00:32:17.636
using ISP programming’s uh
mechanisms to erase all this uh
code sections I’m sorry this is

00:32:17.636-->00:32:34.986
really my bad so right now my
colleagues is trying to erase
the evaluation board and make

00:32:34.986-->00:32:53.972
this make it as brand new and so
we can do the patch stuff a
after that. And there is a tool

00:32:53.972-->00:33:12.157
called FlashMagic you can do
just like this. Okay then this
evaluation board is blank so we

00:33:12.157-->00:33:31.076
can do the next step. Connect
it. So this is the this is
actually the code we cloned the

00:33:31.076-->00:33:36.348
unique ID and uh and uh we do
the hook functions so basically
while compilation is weak we can

00:33:36.348-->00:33:41.019
just use the original firmware
as the section of our new
hardware so we can just put our

00:33:41.019-->00:33:47.792
uh bypass code and apache code
inside of the another bla
another region of the flash and

00:33:47.792-->00:33:52.564
the and uh uh combine all of
this together as a new firmware
and and then download it to the

00:33:52.564-->00:34:13.385
hardware. And uh trying to flash
it and verify and now we launch
a new Jlink terminal to verify

00:34:13.385-->00:34:37.042
if our uh work is doable or not.
So this is our original one this
is the legal copy and the second

00:34:37.042-->00:34:44.182
one is the evaluation board so
it right now you can see there
is totally the same and uh the

00:34:44.182-->00:34:49.020
serial number if if our
solutions better I mean uh if
our radio solution is better

00:34:49.020-->00:34:53.758
than you can see the uh unique
ID or the serial number are
exactly the same you can just

00:34:53.758-->00:35:00.598
use uh uh exactly same as the
production so we all we
basically cause illegal copy but

00:35:00.598-->00:35:08.306
uh but I mean we just do this
for fun it’s not for perfect so
we were trying to say oh is

00:35:08.306-->00:35:13.712
there any way we can just uh
explore this you know to
something more interesting? so

00:35:13.712-->00:35:19.184
then we were thinking about how
about the hardware trojan I mean
imagine this scenario, there if

00:35:19.184-->00:35:24.656
there is a so like the US is
trying to attack the Europe
right? There is a there was a

00:35:24.656-->00:35:33.164
case that uh see I oh be I I
can’t remember but they kind of
like they intercept a a a a a a

00:35:33.164-->00:35:38.303
bunch of printers which were
selling which was intent of
selling to the Europe right? so

00:35:38.303-->00:35:45.176
they implement a bunch of they
just intercept it they patch the
firmware and those kind of

00:35:45.176-->00:35:51.516
printers just was their boat
their botnet and they and those
kinds of printers just steal a

00:35:51.516-->00:35:57.889
lot of stuff for them so we were
thinking about can we do that? I
mean patch the firmware patch

00:35:57.889-->00:36:03.762
the firmware of the embedded
system is not quite easy it’s
not like the uh a computer you

00:36:03.762-->00:36:09.501
can do this easy you have a lot
of hook platform to do this but
uh with the FPB function we can

00:36:09.501-->00:36:14.472
do this very easily I mean the
FPB function just uh is very
simple you can just hook uh a

00:36:14.472-->00:36:21.246
function or you can just hook a
a snip of code to to do uh uh
some other stuff it won’t it

00:36:21.246-->00:36:28.453
won’t infect the integrity of
this formula and you don’t have
to actually analy analyze the

00:36:28.453-->00:36:34.492
firmware and uh so you can just
put in your code and uh and
invoke this function that is

00:36:34.492-->00:36:40.832
all. So we were thinking about
how to inject a hardware trojan
inside of the Jlink production

00:36:40.832-->00:36:48.940
and uh the Jlink is using the
NXP chip right so uh which is
also based on the cortex-m4 core

00:36:48.940-->00:36:55.880
and uh and it’s it has a giant
flash it’s very I mean it’s it’s
um it’s it’s pretty enough for

00:36:55.880-->00:37:02.687
us so uh the Jlink firmware is
also used in the lower part of
the flash so we can just uh

00:37:02.687-->00:37:09.627
there is enough place for us so
we can just place this hardware
trojan inside of the uh blank

00:37:09.627-->00:37:15.333
region so if we if we want we
can just uh uh we can just
inject the hardware trojan

00:37:15.333-->00:37:20.638
inside of the firmware before we
before some other some other
people purchased this uh this

00:37:20.638-->00:37:29.314
hardware so how about add a
badUSB into a Jlink right? You
purchase a Jlink it’s so it’s

00:37:29.314-->00:37:34.853
it’s huge expensive and ins and
uh and inside it you it can
accelerate your debugging

00:37:34.853-->00:37:40.692
procedure but turns out its a
bad its a bad USB it can just
steal all of this stuff from

00:37:40.692-->00:37:46.331
your computer because it because
you just because you just uh
connect this hardware into your

00:37:46.331-->00:37:50.902
computer and uh into your laptop
and you think this is safe
enough I can do my stuff mmm so

00:37:50.902-->00:38:00.745
uh in the uh so I mean if you
were trying to bypass the anti
chrome mechanism we were talking

00:38:00.745-->00:38:05.750
about the uh uniqueID
verification function but in
this one we can just hook

00:38:05.750-->00:38:12.724
another uh we can just hook
another uh another system uh
system uh function code so in

00:38:12.724-->00:38:20.665
this case we were uh we were uh
we were hooking the
SysTickHandler so this is

00:38:20.665-->00:38:26.571
basically uh inter uh exception
handler I mean there is there is
there is a bunch of function

00:38:26.571-->00:38:32.710
inside of the hardware inside of
the system and then it’s it’s
kind of like a time time slice

00:38:32.710-->00:38:40.785
so this one will just help you
to cause the time right so this
is the this is the uh I mean all

00:38:40.785-->00:38:45.857
of this computers all of this
embedded systems will just use
uh will just use a function like

00:38:45.857-->00:38:52.397
this so we’ll so this is our
main target. And uh after we do
that I mean the normal function

00:38:52.397-->00:38:57.035
will just keep its original it’s
us I mean we didn’t we didn’t
harm the integrity of this

00:38:57.035-->00:39:05.210
formula so uh how to trojan how
to trigger this trojan I mean uh
you can it can be just

00:39:05.210-->00:39:09.581
considered that we have two part
of the formula, the first part
of the formula is the original

00:39:09.581-->00:39:16.387
part of the uh Jlink it can do
the uh debug probe it can do all
of the things this is what you

00:39:16.387-->00:39:24.329
do for the eight hundred bucks
but uh if we uh another part is
the badUSB this part of the

00:39:24.329-->00:39:31.569
function it will be executed in
sometimes and uh it will just uh
uh inject a bunch of code into

00:39:31.569-->00:39:42.013
your computer and uh act like uh
USB uh USB act act like a USB uh
device like like uh your

00:39:42.013-->00:39:47.085
keyboard like your mouse it can
do everything right just
basically is a human so uh we

00:39:47.085-->00:39:54.459
have two part of the formula and
uh we hook the time interrupted
entry so we do this by hooking

00:39:54.459-->00:40:02.800
the function from where the
enter uh from which is the uh
which is the SysTickHandler it’s

00:40:02.800-->00:40:12.010
the it’s a previous slides so
the the the rest of the thing is
uh I mean the rest of the thing

00:40:12.010-->00:40:17.248
we need to do is like the first
step is we try to compile this
badUSB code the second step is

00:40:17.248-->00:40:22.453
we try to hook this critical
function and once this critical
function is executed okay then

00:40:22.453-->00:40:29.427
we can just execute our firmware
I mean it’s badUSB stuff and
also the Jlink will just act as

00:40:29.427-->00:40:35.166
pretty normal you can just use
this to download to debug uh
everything else I mean doesn’t

00:40:35.166-->00:40:44.609
matter but uh suddenly it’s just
become a bad person sorry so
this is the details of our

00:40:44.609-->00:40:50.181
attack implementation uh and uh
so you can so you can see the
first step is of course the

00:40:50.181-->00:40:56.354
power up right of course this is
after we uh download our
firmware into this hardware so

00:40:56.354-->00:41:03.194
the first thing was I mean uh
was just to power power up and
we also we we don’t want to make

00:41:03.194-->00:41:10.368
our code wrong but execute it uh
you know in the beginning of
this power ups procedure I mean

00:41:10.368-->00:41:16.207
we want it to be executed we
want it to be executed in the
some certain time so nobody will

00:41:16.207-->00:41:21.612
just be noticed so we put the
attack flag inside I mean
remember the SysTick? so is this

00:41:21.612-->00:41:34.092
basically so it’s a time counter
so we set up uh we set up a time
counter and uh we tell them okay

00:41:34.092-->00:41:39.297
one this uh if this uh Jlink
gets power in five minutes then
our firmware then our trojan

00:41:39.297-->00:41:46.404
will be executed this sounds
like more reliable when when we
just put a jump inside of the I

00:41:46.404-->00:41:50.208
mean in the beginning of the
firmware and to do all it’s bad
stuff I mean it’s too obvious

00:41:50.208-->00:41:57.015
somebody will just notice okay I
just plug in this and uh my
computer my computer is doomed.

00:41:57.015-->00:42:04.222
Nobody will like that. So that’s
why we choose this critical func
uh sys uh system function as our

00:42:04.222-->00:42:15.867
hook function and uh we choose
time uh counter as our attack
method. So so in this video we

00:42:15.867-->00:42:23.574
can show you uh this is the demo
of our badUSB so this is the
code this is the uh original

00:42:23.574-->00:42:30.415
code of the badUSB and you can
see right now we are trying to
compile all of this into the

00:42:30.415-->00:42:41.225
firmware and we download into
the uh Jlink uh official Jlink
stuff so right download and we

00:42:41.225-->00:42:54.172
left our computer right over
there and uh leave it run so you
can see now this is no man

00:42:54.172-->00:43:01.712
touching the touching our
computer and it just open a
DefCon website so imagine that

00:43:01.712-->00:43:08.352
it can just open everything you
can just uh steal stuff like uh
like a personal account or

00:43:08.352-->00:43:13.491
download the firmware into your
into your computer and execute
it and you will just you can’t

00:43:13.491-->00:43:22.767
be noticed. So actually uh as we
mentioned before this this is uh
not actually an NXP chip it’s

00:43:22.767-->00:43:29.674
this is uh NX chip’s fault I
mean this isn’t because we have
a debug function inside of our

00:43:29.674-->00:43:36.080
protection so this is basically
is uh this is basically
accelerate some hackers trying

00:43:36.080-->00:43:44.555
to attack uh trying to attack
your production this is a help
them to lower the lower the

00:43:44.555-->00:43:51.863
difficult. So all of basically
all of this cortex-M3 cortex-M4
of x series chip they have the

00:43:51.863-->00:43:59.270
same FPB function uh I’m sorry
same FPB unit so you can just uh
uh leverage it or you can say or

00:43:59.270-->00:44:06.978
you can say just exploit this
into malicious function so uh
but also there is some other

00:44:06.978-->00:44:14.652
vendors also have the chip
provide the UID feature so you
can also clone their product you

00:44:14.652-->00:44:18.789
can also implement a hardware
trojan inside of their
production you can uh I mean uh

00:44:18.789-->00:44:24.328
I mean I it in an old fashioned
way if we want to implement a
hardware trojan we need to

00:44:24.328-->00:44:29.400
analyze the hardware we need to
analyze the firmware and then we
try to implement all of this

00:44:29.400-->00:44:34.438
inside but uh with this we can
just uh FPB to hook a function
to patch some stuff, this will

00:44:34.438-->00:44:43.047
be much easier. and uh uh
somebody was my I just want to
say is there any mitigation

00:44:43.047-->00:44:49.320
measure? And of course the first
step is never leak your firmware
if you don’t have a if nobody

00:44:49.320-->00:44:54.759
can get your firmware of course
they can’t they they can’t do
this I mean what’s the point

00:44:54.759-->00:45:00.831
right? You have uh you don’t
have the firmware and you give
them a bunch of hardware and

00:45:00.831-->00:45:06.270
tell them uh okay you gonna do
this nobody will use that. So uh
also the second one is what we

00:45:06.270-->00:45:14.178
suggested for the NXP chip so uh
basically oh I’m sorry for the
Jlink uh enterprise so basically

00:45:14.178-->00:45:21.652
they will just disable the FPB
function before they call the
critical uh API so I I mean it’s

00:45:21.652-->00:45:30.461
it’s not uh sufficient it’s
actually not a sufficient
conveyer but it’s but it’s much

00:45:30.461-->00:45:37.435
harder for the hackers trying to
do stuff like wouldn’t be done
before. Also we also you can

00:45:37.435-->00:45:43.774
just uh pad the uh firmware to
you know there is a blank there
is a bunch of blank flash

00:45:43.774-->00:45:49.280
regions uh in uh the firmware so
you can just pad the firmware to
set all this blank uh flash area

00:45:49.280-->00:45:54.986
to specific value so for example
you can just uh use instruction
like the BL reset handler that

00:45:54.986-->00:46:05.096
means if the if the code uh if
the blank flash reading was uh
being excluded than you’d just

00:46:05.096-->00:46:11.469
drag it down into the uh back
into the beginning so it’s not
useable anymore so also you

00:46:11.469-->00:46:16.874
should always verify the
signature of the entire flash
instead of just uh just a piece

00:46:16.874-->00:46:23.714
of code it’s it’s totally not
secure right? it’s uh I mean
just leave a giant blank hole

00:46:23.714-->00:46:31.188
and to and let us set and tell
us okay you can take it it’s uh
I mean. So we also received the

00:46:31.188-->00:46:38.596
advise from the PSIRT of the NXP
I mean it’s uh it’s uh it’s also
the security group of the NXP so

00:46:38.596-->00:46:46.337
they will suggest the enterprise
who or the companies who were
willing to use the NXP chip that

00:46:46.337-->00:46:53.277
is enable the code read
protection. I mean the code read
read protection setting has uh

00:46:53.277-->00:46:59.083
has the three levels there is uh
level one level two and level
three I mean level one and level

00:46:59.083-->00:47:03.321
two there is only just disable
the JTAG you can also use the
leverage the ISP to do the bad

00:47:03.321-->00:47:08.859
stuff like what we have done
before but uh if you enable the
level three yes you can’t use

00:47:08.859-->00:47:16.000
JTAG, you can’t use ISP, I mean
you can’t this chip is and it’s
not reprogrammable but uh but

00:47:16.000-->00:47:22.239
that also means if your
protection has something wrong
[indiscernible] thousands of

00:47:22.239-->00:47:29.380
stuff like to the uh to the
users to the endpoint and if
somethings wrong then you are

00:47:29.380-->00:47:35.519
doomed all of this will be
refunded and your company will
broke. So the countermeasures is

00:47:35.519-->00:47:42.093
like it’s not a good idea to put
the critical to put a critical
API into the address region that

00:47:42.093-->00:47:48.699
can be remapped I mean uh it’s
just the name is called like
flash patch and breakpoint that

00:47:48.699-->00:47:56.707
all that also means it can only
I mean the owning the only the
only the flash region can be

00:47:56.707-->00:48:03.514
remapped so nothing else so you
can just put it in some critical
register or some higher uh

00:48:03.514-->00:48:08.552
address that that would be that
would be much better so we
recommend that SoC vendors just

00:48:08.552-->00:48:14.058
prohibit reading remapping all
of this ROM API in the
subsequents production I mean if

00:48:14.058-->00:48:20.197
you just ship it if you ship it
before it can be recalled right?
It’s just much harder. So this

00:48:20.197-->00:48:26.103
is a reference of our
production, I mean of our so you
can see the principal is much is

00:48:26.103-->00:48:34.345
pretty easy but uh you can do a
lot of bad stuff to do this so
thanks and uh thank thanks guys

00:48:34.345-->00:00:00.000
so if you have any questions you
can just ask me right now
[applause]

