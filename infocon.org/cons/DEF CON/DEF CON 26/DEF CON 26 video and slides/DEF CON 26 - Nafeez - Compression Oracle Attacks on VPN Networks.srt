00:00:00.000-->00:00:06.073
>>So uh, with that I’m going to
hand it over to Nafeez, please
make him welcome. [Audience

00:00:06.073-->00:00:16.149
applause] >>Hi, thank you! So I
guess people are still uh
flowing in. Uh, Friday night

00:00:16.149-->00:00:22.489
parties. Uh. This is my first
Defcon, uh talking in front of a
lot of people, a little nervous

00:00:22.489-->00:00:29.162
I hope I will make it til the
end properly [speaker laughs]
Alright so, a little bit about

00:00:29.162-->00:00:35.536
myself.. I am Nafeez, uh I’ve
been doing uh web appsec
research for a while, uh mostly

00:00:35.536-->00:00:41.975
interested in Javascript
strategic analysis uh wrote a
few tools. I’ve been recently,

00:00:41.975-->00:00:49.316
learning to write some good code
so I have been doing some demo
work recently and one of my main

00:00:49.316-->00:00:56.390
projects right now is a asset
watch where uh it’s a
transparent uh attack surface

00:00:56.390-->00:01:00.827
discovery as a service uh check
it out and please follow me on
Twitter at skeptic underscore

00:01:00.827-->00:01:12.039
FX. Ok so for most of you here
sorry you might be wondering
what is the topic about today uh

00:01:12.039-->00:01:16.910
compression Oracle attacks on
VPN networks. What I am going to
talk about today, uh the end

00:01:16.910-->00:01:23.817
goal is to basically break VPN
networks. Uh in a much, in a
very generic fashion, and I am

00:01:23.817-->00:01:30.657
going to specifically take one
of the well known VPN providers
if you know Openvpn and we will

00:01:30.657-->00:01:39.866
see a demo of how to leak
secrets from encrypted graphic.
Ok let’s start with compression,

00:01:39.866-->00:01:46.840
because that is the core of what
I am going to talk about today
because this is a much broader

00:01:46.840-->00:01:50.877
audience I would like to explain
more in detail about what is
compression, what is an oracle,

00:01:50.877-->00:01:57.184
what is a compression oracle and
how these attacks work in
general and then go into how uh

00:01:57.184-->00:02:06.994
this applies to VPNs. Alright?
Ok so compression in computer
science one of the common things

00:02:06.994-->00:02:15.869
that people use is compression.
Ultimately, which gives you
reduced bandwidth and it it

00:02:15.869-->00:02:22.209
saves a lot of money for the
client, for for the the client’s
side and the server side. So it

00:02:22.209-->00:02:26.947
definitely makes sense to have
good compression alg-algorithm,
over the years we’ve been having

00:02:26.947-->00:02:34.621
very good compression
algorithms. Uh one of the famous
ones that we know uh is the LZ77

00:02:34.621-->00:02:39.626
family, uh which which has the
LZO and LZ4 compression
algorithms. So in this case the

00:02:39.626-->00:02:46.566
way it works is by replacing
redundant characters, uh as it’s
obvious from here, you can see

00:02:46.566-->00:02:50.971
the sentence which has
everything look dark and bleak
everything look gloomy and

00:02:50.971-->00:02:57.277
everything was under blanket of
mist. In this is uh you can see
everything looked is a very

00:02:57.277-->00:03:02.783
redundant pattern so a
compression algorithm who’s
trying to compress this piece of

00:03:02.783-->00:03:08.755
data is not going to repeat them
uh what it’s going to do is
replace it with, uh replace it

00:03:08.755-->00:03:16.063
with uh the codes within the
ex-existing stream so when it
compresses the data it’s going

00:03:16.063-->00:03:24.738
to minus 34 comma 18 which
eventually for the uh when on
the decompression side means

00:03:24.738-->00:03:33.513
just go back 34 characters and
expand the next 18 bytes and so
and so for whatever makes sense

00:03:33.513-->00:03:39.419
as long as the final output is
much more reduced uh the
compression makes sense.

00:03:39.419-->00:03:47.427
Alright? Another well known
technique is Huffman Coding, so
we have been seeing so far is

00:03:47.427-->00:03:53.100
compression at the byte level.
Huffman coding, hey you know
what I you have a lot of these

00:03:53.100-->00:04:01.575
characters I don’t want to waste
8 bits for every character uh
what I am going to do is just

00:04:01.575-->00:04:08.315
see frequency mapping and take
the most repeated characters and
assign them short bits instead

00:04:08.315-->00:04:14.588
of one whole byte. So in this
instance, uh this is uh an
example of a frequency table for

00:04:14.588-->00:04:21.528
for a Huffman coding so
characters like space, A, all
these characters are going to

00:04:21.528-->00:04:27.567
have much shorter bits so in
this case it’s just 3 bit for A
and space and E. So ultimately

00:04:27.567-->00:04:34.341
you co- uh, when you use this
for compression you get along
with the previous algorithms you

00:04:34.341-->00:04:41.081
get much more reduced number of
bits. So, in real world uh you
have this algorithm which

00:04:41.081-->00:04:46.486
combines both of these called
deflate which is, which is the
ones that are commonly used uh

00:04:46.486-->00:04:54.494
used in Gzip, uh the Zlib
library and also if you have
been uh hearing about TLS

00:04:54.494-->00:05:00.133
compression which got disabled a
while back uh when it was around
for a decade that use that use

00:05:00.133-->00:05:09.276
deflate. So with with with the
understanding of data
compression lets go and think

00:05:09.276-->00:05:14.714
about a compression side
channel. So what does that mean
uh in the context of today’s

00:05:14.714-->00:05:21.888
talk? So around 2002 this
gentleman called John Kelsey, uh
he came up with this white paper

00:05:21.888-->00:05:27.794
called compression information
leakage of plain text. So, in
the crypto community around that

00:05:27.794-->00:05:33.533
time, people were talking it’s
it’s very well known that uh
when you take a piece of data

00:05:33.533-->00:05:39.906
and compress it and then encrypt
it a lot of bad things can
happen. So, what he said in that

00:05:39.906-->00:05:47.914
paper from a high level I would
like to uh explain from a uh
from from an infographics so

00:05:47.914-->00:05:56.356
before we go to that it is well
known also by that time and even
it is always true that when you

00:05:56.356-->00:06:02.896
have encryption who are is
trying to snoop into your data
can always look at the length of

00:06:02.896-->00:06:09.736
the data. There is no efficient
there is no mathematically well
known way to hide data, hide

00:06:09.736-->00:06:16.476
data the length of the data when
you compress them uh sorry when
you encrypt them. So uh even

00:06:16.476-->00:06:22.482
though encryption scrambles all
the data it doesn’t uh prevent
the attacker from understanding

00:06:22.482-->00:06:26.920
how many bytes of data you
encrypted. Right? So that’s
pretty obvious so in wireshark

00:06:26.920-->00:06:31.391
or if any man in the middle is
going to go and look at your
encryption and encrypted data

00:06:31.391-->00:06:37.998
and get the data length.
Alright, so let's try and
understand this from an

00:06:37.998-->00:06:44.971
infographic on what the paper
says. So assume a assume a black
box which does compression and

00:06:44.971-->00:06:50.844
encryption uh which takes in
plain data and gives you
encrypted data and obviously you

00:06:50.844-->00:07:00.287
will have the length of the data
as well. Alright, now in this
case if you have an attacker who

00:07:00.287-->00:07:08.461
can add or append some piece of
data that he controls to the
existing plain text data even

00:07:08.461-->00:07:15.702
though he doesn’t have to know
what the plain text data is and
also if he can observe the

00:07:15.702-->00:07:20.407
encrypted graphic then what this
paper tries to say is you have a
compression side channel

00:07:20.407-->00:07:27.547
possible and you can have a
compression side channel attack.
So when I, when I when a

00:07:27.547-->00:07:35.655
compression oracle attack in
theory means is that uh from an
attackers point of view and

00:07:35.655-->00:07:41.661
oracle encrypto efficiently
allows him to brute for secrets.
So in this case we have a

00:07:41.661-->00:07:46.933
compression oracle attack. So
what that means is using
compression, the attacker can

00:07:46.933-->00:07:53.606
have an oracle which efficiently
reduces his amount of brute
force that he has to do. So

00:07:53.606-->00:07:59.412
let's say the secret he is
interested in is 4 characters,
so that would take if I have to

00:07:59.412-->00:08:03.450
do a down brute force that will
take 10-->000 requests. So I need
to brute for each and every

00:08:03.450-->00:08:10.990
character for each and every
number so that’s probably just
for the uh numbers not for alpha

00:08:10.990-->00:08:17.664
numeric data. Now with a
compression oracle you can do
that efficiently with uh or any

00:08:17.664-->00:08:23.670
or any not just a compression
oracle or any kind of oracle you
can do that efficiently with

00:08:23.670-->00:08:27.741
just around 40 characters 40
requests. So all the attacker
has to do is send 40 requests

00:08:27.741-->00:08:37.584
and he can efficiently get the
final secret which is 4 Y slant.
Now in any kind of oracle attack

00:08:37.584-->00:08:44.391
like you may have heard of this
attack called padding oracle
attack right uh wh- the

00:08:44.391-->00:08:53.066
attackers final goal is to
choose a specific byte which uh
which also participates in the

00:08:53.066-->00:08:58.405
data compression with the
existing secret. So let's see
that more in detail in the

00:08:58.405-->00:09:04.511
upcoming slides. So I've I’ve
tried to put an infographic of
how this would work uh with

00:09:04.511-->00:09:13.186
actual secret data. Imagine you
have a set of plain text data at
the very top which is which is

00:09:13.186-->00:09:19.426
what the application is trying
to encrypt so this could be a
browser or any email client,

00:09:19.426-->00:09:24.731
things like that. Now assume
that the attacker can also
inject some data to the to the

00:09:24.731-->00:09:30.603
end of that so the final output
would look like the one on the
top right one about the

00:09:30.603-->00:09:37.243
compression block. So once that
comes out of the black box
wha-what the attacker can

00:09:37.243-->00:09:42.515
observe is the encrypted data
length. So as we already said
this is what the compression

00:09:42.515-->00:09:49.823
oracle here is. He can look at
the length and he can inject his
own byte so if you see this

00:09:49.823-->00:09:59.466
interestingly what he chose here
the whole data before compressed
uh that’s the ones on the green.

00:09:59.466-->00:10:08.408
Those those can be compressed.
So the stream secret equals and
the secret equals the attacker

00:10:08.408-->00:10:16.115
injected uh are compressible.
Now of course the one here uh
doesn’t match with the 6 which

00:10:16.115-->00:10:21.788
is the actual secret that he
wants so he keeps brute forcing
that. 1, 2, 3, 4, 5 and finally

00:10:21.788-->00:10:30.763
when he sends a request which
has 6 in it, the compression
length increases. Finally, what

00:10:30.763-->00:10:36.603
that efficiently results in is
the smaller length of the data
packet so if you increase the

00:10:36.603-->00:10:44.277
compression length by choosing a
specific character you could
reduce the uh encrypted length.

00:10:44.277-->00:10:50.283
So in this case, uh you have you
have been having 30 for other
secrets other-other characters

00:10:50.283-->00:10:56.489
but the moment he chooses the
right one it becomes 29. So
that’s compression oracle uh

00:10:56.489-->00:11:03.530
from a very high level. So all
that is good, nobody talked
about it after that. Uh people

00:11:03.530-->00:11:08.201
just talk say if you do
compression and then do
encryption things can go bad. Ok

00:11:08.201-->00:11:17.343
so what? Now people have been
talking for some time, uh after
that for the last decade uh

00:11:17.343-->00:11:23.082
about how can we make this into
a real world attack. So if you
think about this, what an

00:11:23.082-->00:11:27.720
attacker really needs uh to make
this into a real world attack is
inject bytes and to observe

00:11:27.720-->00:11:33.026
length. So let’s try to think
about that. Observing encrypted
traffic length that’s pretty

00:11:33.026-->00:11:41.434
forward is a man in the middle
attack. Right and the other
other uh requirement is the most

00:11:41.434-->00:11:46.940
interesting one here which is
adding the attackers control
bytes into an existing stream of

00:11:46.940-->00:11:54.914
uh into an existing application
which already does compression
and encryption. So browsers are

00:11:54.914-->00:12:03.222
a very good target for this. So
browsers have this thing called
ambient authority wherein any

00:12:03.222-->00:12:09.762
time uh a request goes out to a
specific domain the browser sees
if the cookie jar has the

00:12:09.762-->00:12:16.169
specific cookie for this domain
and automatically attaches it.
So if you are sending a request

00:12:16.169-->00:12:21.174
from A DOT COM to B DOT COM the
browser always sends the cookies
for B DOT COM regardless of

00:12:21.174-->00:12:26.546
where it originates from. Until
unless you have specific things
like same site cookies and stuff

00:12:26.546-->00:12:33.653
which are very modern. Now, also
the browser allows you to send
simple cross domain requests uh

00:12:33.653-->00:12:40.593
with post, with the post method.
Which means the attacker can
inject his own post message body

00:12:40.593-->00:12:47.066
and send a request to say
FACEBOOK DOT COM and the browser
chooses the cookies for FACEBOOK

00:12:47.066-->00:12:53.973
DOT COM and and the attacker
gets the secrets, what he wants
from the existing payload and

00:12:53.973-->00:13:00.413
also he can inject uh his own uh
his own brute force uh
characters into the whole

00:13:00.413-->00:13:07.020
stream. So, this could
effectively come up with the
compression oracle attack on in

00:13:07.020-->00:13:12.158
the real world using browsers.
So in 2012 you might have heard
of this attack, a very famous

00:13:12.158-->00:13:19.899
attack called CRIME. So CRIME
was trying to do a compression
oracle attack on TLS compression

00:13:19.899-->00:13:31.210
so un-up until 2013 all browsers
or most of the TLS clients were
doing TLS compression uh enabled

00:13:31.210-->00:13:38.451
by default. So which is part of
the TLS back and all these
browsers had them enabled as

00:13:38.451-->00:13:45.792
well. So even protocols like
SPDY, which is a precursor to
today’s HTTP2 had them, so what

00:13:45.792-->00:13:51.597
these guys did uh Juliano Rizzo
and Thai Duong, were they were
able to do a real world attack

00:13:51.597-->00:13:58.871
of compression oracle attack.
Compression oracle on websites
like paypal and GitHub and stuff

00:13:58.871-->00:14:07.180
like that and the- and the most
interesting thing about the work
that I love is that they also

00:14:07.180-->00:14:14.153
predicted the attacks that would
come in the future. Right so
they also said, uh HTTP gzip may

00:14:14.153-->00:14:20.960
may be also vulnerable to this
also provided samples but they
didn’t talk about how this would

00:14:20.960-->00:14:30.603
happen uh in a real world uh
attack for HTTP responses. So
later in 2013, uh the famous

00:14:30.603-->00:14:37.243
attack called TIME also came
about so when talked about two
interesting new researchers

00:14:37.243-->00:14:42.715
which is I would say is one
interesting new researches which
is you don’t have to be the man

00:14:42.715-->00:14:48.688
in the middle anymore you can
just do the whole attack by
using timing differences within

00:14:48.688-->00:14:54.560
the browser so they would send
requests from the browser and
using TCP window channels and

00:14:54.560-->00:15:00.700
window sizes they’d they were
able to use that as the oracle
instead of being a man in the

00:15:00.700-->00:15:05.204
middle, and of course they used
the existing research on CRIME
to leak HTTP responses. So uh

00:15:05.204-->00:15:11.344
even at this time I would say
things were still when It comes
to compression oracle attacks

00:15:11.344-->00:15:16.883
things were still a little
theoretical and there was no
real world you know people were

00:15:16.883-->00:15:22.955
not really afraid of using this
attack uh attackers know they
would easily use this attack in

00:15:22.955-->00:15:30.296
the wild. So breach came about.
So breach was very interesting
he didn’t come up with anything

00:15:30.296-->00:15:35.935
beyond new research but in terms
of what the attack already was
doing these guys Angelo, Niel

00:15:35.935-->00:15:44.377
and Yoel they added a lot of a
lot of real uh real world world
properties into this attack

00:15:44.377-->00:15:49.015
which means. What I am trying to
say is they were able to come up
with tools which could uh make

00:15:49.015-->00:15:54.153
this compression oracle attack
really possible on HTTP
responses because by that time

00:15:54.153-->00:16:01.627
HTTP requests for-for
compression has been disabled so
the Breach attack was very

00:16:01.627-->00:16:08.100
famous and it got a lot of press
attention as well you might know
about know about them so so

00:16:08.100-->00:16:14.707
around two- 2015 we’d been
having other attacks as well
like the HEIST, and then we also

00:16:14.707-->00:16:21.547
had some att- more research on
practical developments to
breach. So all these are history

00:16:21.547-->00:16:26.619
uh I’m sorry if I’ve been a
little boring and
mono-monotonous so far, I’ll try

00:16:26.619-->00:16:30.056
to make it a little more
interesting because this is
going to be my section now which

00:16:30.056-->00:16:38.764
is uh what is going to be new
today obviously it’s the VPN
tunnels. So so far all the

00:16:38.764-->00:16:45.171
attacks on compression oracle
attack have been purely talked
about uh and the real attacks

00:16:45.171-->00:16:54.614
have been on browsers using TLS.
Now what if you know all these
are fine and what if you are

00:16:54.614-->00:16:59.418
using VPNs and what would go
wrong if you’re using VPN to
connect and browser website?

00:16:59.418-->00:17:06.325
Let’s let’s try to think about
uh more about how VPNs work so
when it comes to the topic of

00:17:06.325-->00:17:12.965
VPN we there are I would
categorize that categorize it as
a few few classes of VPNs like

00:17:12.965-->00:17:18.905
the corporate ones, the IPSec
VPNs, and the more modern ones
which are the TLS style VPNs,

00:17:18.905-->00:17:31.050
right? So what I’m talking about
is are VPNs like these, Uh
TunnelBear, you know, there’s

00:17:31.050-->00:17:34.687
PureVPN, all these purse saas
style VPNs. Whereas a normal
user can go and connect create

00:17:34.687-->00:17:39.859
an account for 10 dollar or 7
dollar a month you can have a
VPN Connection. So What do all

00:17:39.859-->00:17:49.535
these VPNs have in common? Well,
they use OpenVPN. So OpenVPN is
up until recently cause enough

00:17:49.535-->00:17:56.776
team was commonly and easily
used VPN. There have been VPN
solutions as well like Algo VPN

00:17:56.776-->00:18:03.950
and the upcoming Wireguard if
you are being in Blackhat, the
upcoming Wireguard is pretty

00:18:03.950-->00:18:10.556
interesting. So regardless of
those VPNs were are going to
talk about how OpenVPN in

00:18:10.556-->00:18:19.098
general can be attacked which is
eventually used in many other
VPN solutions. So from a high

00:18:19.098-->00:18:25.471
level, this is how VPN in
general works but very
specifically this is an OpenVPN

00:18:25.471-->00:18:33.746
works. They effectively use a
lot of keyless uhm protocol
within themselves and also use

00:18:33.746-->00:18:39.885
existing SSL openSSL library
components so if you look at the
code, they use heavily openSSL

00:18:39.885-->00:18:45.992
to all the encryption and all
these related stuff are already
done they’re not rewriting all

00:18:45.992-->00:18:51.430
of these codes. So the first
thing that happens in the
control channel where they

00:18:51.430-->00:18:56.268
negotiate the parameters what
protocols I’m going to use and
what compression I’m going to

00:18:56.268-->00:19:02.675
use and once if compression is
enabled, what they’re going to
do is compress the whole channel

00:19:02.675-->00:19:11.050
before encrypting and this
happens by default on openVPN.
So what do I mean by compress

00:19:11.050-->00:19:15.321
everything? So they compress the
whole data channel which means
regardless of your underlying

00:19:15.321-->00:19:20.426
protocol, whether it is UDP or
TCP they’re going just to
compress it. So if its HTTP

00:19:20.426-->00:19:26.499
it's going to be TCP and if its
DNS traffic they’re going to
compress that as well which is

00:19:26.499-->00:19:30.936
UDP and its Bi-Directional, so
it’s not just the HTTP request
be compressed even HTTP

00:19:30.936-->00:19:36.742
responses. So you are
effectively having something
similar to crime and breach

00:19:36.742-->00:19:42.048
together and the compression
algorithm they use are not
deflate, they’re just using the

00:19:42.048-->00:19:50.656
pre -LZ77 which if you remember
from this chart of the talk we
discussed how LZ77 Family of

00:19:50.656-->00:19:56.062
compression works. So they just
going to replace it to existing
bytes there is no bit level

00:19:56.062-->00:20:00.066
compression, which makes more
things much easier from
attackers point of view. So we

00:20:00.066-->00:20:08.107
are going back to the paper in
2002 by John Kelsi, which is we
have a whole compress then

00:20:08.107-->00:20:16.415
encrypt on all of data channel
and uh the effect is much more
widely for uh the whole network

00:20:16.415-->00:20:23.255
that the whole network graphic
that the VPN tries to encrypt.
So I would like to dub this

00:20:23.255-->00:20:28.227
attack, the VORACLE attack so if
that’s part of homage to my
favorite artist called Woracles,

00:20:28.227-->00:20:34.333
I don’t know if you guys know
him, he’s a progressive music
guy so its combination of VPN

00:20:34.333-->00:20:42.641
and Oracle so I was like you
know everyone has his name time
heist and breach why not. so

00:20:42.641-->00:20:48.581
there you go. I don't have a
logo on the website so that’s I
do some gestures there I hope

00:20:48.581-->00:20:58.257
[laughter] The PR team yeah. so
what does it say the Voracle
attack is basically under VPN,

00:20:58.257-->00:21:07.633
HTTP Webapps are still
insecure. So if you’re still
using VPN purely to ahm protect

00:21:07.633-->00:21:15.307
yourself from insecure websites,
uh websites that don’t already
have HTTPS enabled for example

00:21:15.307-->00:21:20.613
you’re trying to access the
website in your corporate, or if
you’re trying to access a

00:21:20.613-->00:21:25.751
website which is who are link
who are don’t know don’t know
electron encryptors are or lazy

00:21:25.751-->00:21:34.793
enough to not understand that
then those sites are vulnerable.
So things I want to make it very

00:21:34.793-->00:21:40.432
clear. The impacts of this
attack using a VPN if the VPN is
already trying to encrypt

00:21:40.432-->00:21:50.743
existing encrypted data then
yours all good. Things like SSH
things that already use HTTPS

00:21:50.743-->00:21:55.281
like GOOGLE DOT COM or most of
the websites today then you are
good. For the most part of the

00:21:55.281-->00:22:02.221
internet, things are good and
also that actual reason because
when you do compression on

00:22:02.221-->00:22:08.027
already encrypted data it
doesn’t make sense, because all
the encrypted data has a lot of

00:22:08.027-->00:22:12.831
entropy and when you do
compression you’re going
eventually end up with more

00:22:12.831-->00:22:17.770
bytes and from the both of men
point of view, that does not
make sense. You compression

00:22:17.770-->00:22:22.908
algorithm is not doing what its
suppose to do. However, things
might go bad for these kind of

00:22:22.908-->00:22:28.247
scenarios. DNS traffics which is
[indiscernible]
insecure HTTP traffic pure TCP

00:22:28.247-->00:22:36.922
and your VPN fully compress
system. So let’s see how this
stuff work on HTTP webapp 

00:22:36.922-->00:22:44.263
using an encrypted VPN. So to
talk about this we need to
understand what does and

00:22:44.263-->00:22:49.201
attacker require to conduct this
attack. So from a VPN point of
view you need to have

00:22:49.201-->00:22:56.141
compression enabled for VPN
server and client obviously. And
the attacker can be NEMA ITM so

00:22:56.141-->00:23:00.879
this could be your ISP your
attacker on the wifi network or
[indiscernible] stuff like that

00:23:00.879-->00:23:12.157
and we VPN user has to reset a
attacker control website as
well. So that's a pretty

00:23:12.157-->00:23:15.194
commonly used case that it can
come up with today which is most
of the Webapp attack if you have

00:23:15.194-->00:23:20.933
seen attack of those attackers
luring the user into across on
these website that are more or

00:23:20.933-->00:23:27.206
less easy. So let’s look at the
setup here. So you have a VPN
user that Vulnerable who's using

00:23:27.206-->00:23:33.445
a specific browser and who’s
trying to access HTTP Webapp
over the internet. Now he knows

00:23:33.445-->00:23:39.652
that HTTP Webapp so he’s going
to use a trusted VPN which is
secure. Now everything goes to

00:23:39.652-->00:23:46.325
the trusted VPN, Everything is
encrypted it's all good and the
data channel of the end between

00:23:46.325-->00:23:51.864
the VPN and the compression, I’m
sorry, the VPN and the HTTP
Webapp will be going to be

00:23:51.864-->00:23:58.470
encrypted of course but if you
think of corporate VPNs are net
corporate networks more

00:23:58.470-->00:24:03.375
specifically this are going to
be non DMC so everything only
the VPNs is going to be facing

00:24:03.375-->00:24:07.680
the internet and everything else
is internal breaching so, that’s
a very good use case for VPN

00:24:07.680-->00:24:14.353
things in these scenarios as
well. So attackers can always,
it would be hard for man middle

00:24:14.353-->00:24:20.426
attack on the internet to get
into that traffic so what about
those who go to the internet

00:24:20.426-->00:24:24.763
would be encrypted because of
the VPN. Now let’s assume that
an attacker who has capabilities

00:24:24.763-->00:24:31.236
of doing the VORACLE attack. Now
he can host this all on ATTACKER
DOT COM using which he will so a

00:24:31.236-->00:24:37.242
few of Javascript which conducts
the attack. Now the attack can
do the passive MITM obviously

00:24:37.242-->00:24:45.150
and he can also inject ads or
any webapp and do a cross domain
javascript injection, now using

00:24:45.150-->00:24:49.388
the Passive MITM he’s going to
do the first requirement which
is observe the length of the

00:24:49.388-->00:24:56.895
data packet and using the 2nd
one he can use the browser to
send cross them in request to

00:24:56.895-->00:25:06.338
the webapp, which in fact goes
through the VPN right. So, that
using this as attacker can

00:25:06.338-->00:25:10.743
conduct this Compression Oracle
attacks on requests and
responses but its straight

00:25:10.743-->00:25:19.451
forward. So the demo here I’m
going to show first of all I’ve
been trying to do the demo here.

00:25:19.451-->00:25:24.456
the wifi network has been
creating some problems for me
because this does involves brute

00:25:24.456-->00:25:31.063
force and some precision so I
wouldn’t be doing actual live
demo, I have a fully recorded

00:25:31.063-->00:25:37.569
video which I did a while back
so I’ll be showing that, sorry
about that and for the demo

00:25:37.569-->00:25:44.977
we’re going to use firefox and
the VPN client which is you can
access here which is the OpenVPN

00:25:44.977-->00:25:49.982
SLASH OPENVPN3 that’s the latest
one and if today anyone is going
to implement their own OPENVPN

00:25:49.982-->00:25:56.588
SSOS they would be usually
distributing binaries for mac
windows and mobile phones using

00:25:56.588-->00:26:04.229
this library so I thought that
would be a target to just do
this generic attack and we are

00:26:04.229-->00:26:08.534
using an OpenVPN server and for
the demo purpose I’ve made this
website called INSECURE DOT

00:26:08.534-->00:26:13.238
SKEPTICFX DOT COM so that would
have its own session a
randomized session and the goal

00:26:13.238-->00:26:21.680
of the attacker here is to steal
the SessionID from the
cross-domain website which is

00:26:21.680-->00:26:45.637
ATTACKER DOT COM. Okay, so let’s
take a look at that. We’ll see
this, hopefully [laughter] So

00:26:45.637-->00:26:52.644
what I’m doing here is trying to
connect to the OpenVPN server
using this OpenVPN3 client so

00:26:52.644-->00:26:58.784
I’m using my own OpenVPN file
which has compression enabled
that’s what most of task

00:26:58.784-->00:27:07.292
probably give that will give you
the OpenVPN file with so let’s
start this. So I’ve connected

00:27:07.292-->00:27:13.165
and its using the LZO
compression, and for the control
channel it uses those specific

00:27:13.165-->00:27:23.775
parameters and I’ve connected to
this openVPN server. And let’s
go to Wireshark and look at the

00:27:23.775-->00:27:29.548
traffic. How it looks like. So
that’s the IP address of my VPN
server and I’ve just put the

00:27:29.548-->00:27:36.955
frame length more than 300 for
looking at data packets. I
opened the Firefox browser and

00:27:36.955-->00:27:42.661
go and use stuff in my instant
Webapp it sets a cookie for this
website. So in this case for

00:27:42.661-->00:27:50.469
this for insecure Webapp, this
is the cookie and as you can see
my client is sending request to

00:27:50.469-->00:27:58.477
the openVPN server and
everything is encrypted. So even
everything that just go right

00:27:58.477-->00:28:05.484
out of the client is going to be
encrypted so that the attacker
couldn’t see anything. Now I’m

00:28:05.484-->00:28:11.623
doing this MITM where we assume
this MITM is attacker or running
into the internet, right so this

00:28:11.623-->00:28:18.830
could sniff on all the openVPN
packets for the target client
and for the target server that

00:28:18.830-->00:28:27.472
he’s connected to. So what does
MITM tool does is that takes all
the OpenVPN packets and forward

00:28:27.472-->00:28:34.112
it to the attacker server so, we
are going to start the attacker
server on the tab here so its

00:28:34.112-->00:28:41.853
just a small node JS server
which will send to this packets
from the openVPN uh, sniffer and

00:28:41.853-->00:28:48.093
tries to conduct the compression
oracle attack. Ok let me start
the attacks over here. I’m

00:28:48.093-->00:28:58.003
running this locally here which
is on localhost, 9000, 9090 so
the first thing to note here is

00:28:58.003-->00:29:03.976
the other domain is across the
domain website because INSECURE
DOT SKEPTICFX DOT COM and local

00:29:03.976-->00:29:10.082
host and in the real world this
could be this local host would
ideally be attacker website host

00:29:10.082-->00:29:16.955
on the internet more preferably
closer to the client so we could
make this precision attack much

00:29:16.955-->00:29:25.230
easier and by default the
browser, even though both the
websites are on the same browser

00:29:25.230-->00:29:29.468
the other website cannot steal
the SessionID cookie, if you
could do that you would have a

00:29:29.468-->00:29:37.876
same module policy bypass so
that’s different. Let’s go in on
how to make this work so what

00:29:37.876-->00:29:40.646
I’m trying to do here is trying
brute force by sending each
requests and trying to bulk

00:29:40.646-->00:29:48.153
force this cross domain cookie.
So as you can see here this is
my server which receives packets

00:29:48.153-->00:29:55.527
from the openVPN sniffer on the
internet and it just looks at
the length obviously it doesn’t

00:29:55.527-->00:29:59.765
need to look at the encrypted
data. It doesn’t make any sense.
Just a line with which is the

00:29:59.765-->00:30:06.171
oracle here and everytime it
tries to send 10 packets each
with the brute forcing the final

00:30:06.171-->00:30:13.378
character of the secret so if
you see when it says guest 2,
which means the as you can see

00:30:13.378-->00:30:21.153
here that 545, 545, 544 so the
first character was zero the
length was 545, the second

00:30:21.153-->00:30:29.161
character was 1, 545, the third
character was 2 and you ended up
with 544 which means the

00:30:29.161-->00:30:36.368
attacker can then use this the
character 2 for certain
compression so that’s the

00:30:36.368-->00:30:42.140
compression oracle he decides
that the guest is 2. So if you
eventually do that for

00:30:42.140-->00:30:49.514
everything you could basically
leak the whole secret. yeah. >>
[Off mic question] >>Good

00:30:49.514-->00:30:55.353
question, yeah ,so by default,
so he’s question was how about
the block size? Our encryption

00:30:55.353-->00:31:04.796
algorithms supposed to use 16
bytes of blocks depending upon
encryption that is being used so

00:31:04.796-->00:31:13.772
by default, OpenVPN uses the BF
cipher which pure stream cipher.
However if you and

00:31:13.772-->00:31:22.848
recommendation is to use
obviously the most advance AS
with GCM and ADN all of those

00:31:22.848-->00:31:28.720
things enabled which OpenVPN
does very well by the way using
its Wide and Open SSL wrappers

00:31:28.720-->00:31:36.928
but, even with DOS we could do
the same attack. This makes the
demo and the whole attack easier

00:31:36.928-->00:31:42.868
but if you have the blocksize of
16 let’s say, all the attacker
has to do is add random data

00:31:42.868-->00:31:52.310
which he can just offset one
byte so by default he would have
1 extract character while brute

00:31:52.310-->00:31:57.149
forcing so that it could be on
the next block but if there's a
compression that 1 extra bite

00:31:57.149-->00:32:04.790
won't be on the next block it
comes back to the previous block
so, you would see a reduced

00:32:04.790-->00:32:12.798
length of 16 effectively so
yeah, there you go and yeah you
have the secret [applause] Thank

00:32:12.798-->00:32:27.946
you, thank you. Alright so I’m
just randomizing this again just
to say that it just works so now

00:32:27.946-->00:32:38.323
I decode this as you can see
here it’s 5721 so I’m just doing
that it was just works yeah.

00:32:38.323-->00:32:54.639
[off mic question] sorry? [off
mic question] yeah so it depends
upon the end point you send the

00:32:54.639-->00:32:59.811
request to. So, when you do this
actual request, I always prefer
sending a request on the server

00:32:59.811-->00:33:08.987
which has static resources like
javascript or image so this
eventually wont hid the actual

00:33:08.987-->00:33:15.260
servers it even the server might
even sometimes cache those
requests so ultimately there’s

00:33:15.260-->00:33:23.268
no the session cookies won’t
change if you send it to static
pages but yeah if the said

00:33:23.268-->00:33:27.873
cookie changes every time then
this attack wouldn’t work or
your Webapp doesn’t have

00:33:27.873-->00:33:48.960
endpoint which has that yeah,
please. [off mic question] Yeah
so you’re asking how am I able

00:33:48.960-->00:34:06.878
to guess if this is the back of
that I sent? [off mic question]
yeah, exactly, there’s even

00:34:06.878-->00:34:11.750
bigger problem that I come
aboard that I’m going to talk
about right now by the way.

00:34:11.750-->00:34:18.056
Let’s go to that, yeah. Ok, by
the way, this whole code will be
available, you can also detect

00:34:18.056-->00:34:24.462
how your OpenVPN is vulnerable
any VPN is vulnerable using this
tool. I will show you how to do

00:34:24.462-->00:34:30.435
it yourself a little later but
yeah let’s go to the challenges
here. The number one challenge I

00:34:30.435-->00:34:35.273
found compared to most other
compressional group style
attacks is that actually

00:34:35.273-->00:34:45.550
detecting the pack that you
sent. Unlike trying to attack a
TLS channel which has which from

00:34:45.550-->00:34:50.789
the attackers point of view has
the luxury of something called
the SNI or the so the Silver

00:34:50.789-->00:34:55.093
Name Indication all even the
public certificate of the
server, every time the attacker

00:34:55.093-->00:34:58.863
send the request and there’s a
TLS channel which will be
established, the attacker can

00:34:58.863-->00:35:04.069
clearly see, ok this is the
client from the SourceID and he
knows this is the server that is

00:35:04.069-->00:35:10.976
trying to connect so you could
effectively detect the packet
you are sending among with a lot

00:35:10.976-->00:35:15.413
of other data which the client
is trying to send over the
internet. However in case of VPN

00:35:15.413-->00:35:22.954
if you don’t have this, every
traffic goes to the same server
and VPN is more chatty, what I

00:35:22.954-->00:35:32.931
mean by that? is that every
packet regardless if its a DNS
request or if its HTTP request

00:35:32.931-->00:35:38.603
or a SSH its going to be a from
the same client to the same
server and all you see is

00:35:38.603-->00:35:45.543
OpenVPN some bunch of data
right. So there have been some
letters so that the way I solve

00:35:45.543-->00:35:56.087
this is by using a some form of
determining what using some form
of classification. If you look

00:35:56.087-->00:36:06.865
into the history of, history of
detecting VPN traffic how so
there’s been good researchers

00:36:06.865-->00:36:12.871
down on VPN traffics on how to
detect what site the underlying
VPN is trying to connect to. So

00:36:12.871-->00:36:17.242
there’s also good papers on
classify using some basic
mission learning. I tried in my

00:36:17.242-->00:36:24.049
attack in my PC as you can see,
I didn’t use any classifier of
mission learning algorithm but I

00:36:24.049-->00:36:32.690
used a very simple method which
does more dedumnisticly. When
the Sniffer connects to the

00:36:32.690-->00:36:38.930
attacker server. Sorry I don't
have the slide for that but I
wanted to explain this in more

00:36:38.930-->00:36:42.701
detail and the sniffer connects
to the attacker server, it looks
for all these bytes of data now

00:36:42.701-->00:36:49.374
what it tries to do is send, it
tries to classify locally what
are these packet lanes and it

00:36:49.374-->00:36:54.946
sends 10 repeated request so if
you saw my video there is a part
where is saying get baseland,

00:36:54.946-->00:37:03.455
sorry, so the get baseland is
where I try to determine where
can I push my packet size for

00:37:03.455-->00:37:09.494
this attack so that this kind of
an isolated region. So in my
attack for this website and this

00:37:09.494-->00:37:15.266
traffic it was around 550 bytes
so I didn’t see any other DNS
traffic or any other website

00:37:15.266-->00:37:22.874
traffic which was our own that
region because I added junk data
which came close to this. So

00:37:22.874-->00:37:31.049
with this I was able to do this
attack effectively. I hope that
answer that question, we can

00:37:31.049-->00:37:36.921
talk more about this more in
detail later because that’s I
believe the evolution of this

00:37:36.921-->00:37:43.128
kind class of attack where more
research work can be done. So
also the way browsers send

00:37:43.128-->00:37:50.435
HTTP request matters in this
context so the reason I couldn’t
uses google chrome here was

00:37:50.435-->00:37:54.272
because when you try to send
post request which is required
for this attack on OpenVPN,

00:37:54.272-->00:38:00.411
Google Chrome for some reason
split the HTTP request and
body into 2 different data

00:38:00.411-->00:38:05.617
packets so OpenVPN compression
algorithm couldn’t come to
effect because the attacker

00:38:05.617-->00:38:11.956
chosen bytes and the existing
secrets which is the cookie are
into 2 different HTTP packets

00:38:11.956-->00:38:18.863
sorry 2 different TCP packets
part of the same http data. In
Firefox and other browsers it's

00:38:18.863-->00:38:23.501
just as expected. You send
HTTP packet the headers and
body are in the same request so

00:38:23.501-->00:38:30.041
in compression windows within
the same request. Okay so
detecting Voracle on your VPN,

00:38:30.041-->00:38:40.084
so if you are using OpenVPN and
if your server is using OpenVPN
or provider is using that, you

00:38:40.084-->00:38:45.924
can just look at your client
configuration file which is the
OpenVPN file and if you have

00:38:45.924-->00:38:49.093
something like compress LZO or
compress enable which is the
more the latest versions for

00:38:49.093-->00:38:55.066
OpenVPN compression. They just
use compress enable, so you
could detect that you’re

00:38:55.066-->00:38:59.437
probably vulnerable, however
what if you’re not using
OpenVPN, the better way to

00:38:59.437-->00:39:04.943
determine this for any VPN that
you use is dynamically sending
your own request. It's very

00:39:04.943-->00:39:11.082
simple, I have a do it yourself
checklist for detecting Voracle,
all you need is a Wireshark, and

00:39:11.082-->00:39:17.822
you have to be connected to your
vpn, and just send some few curl
requests and absorb the length.

00:39:17.822-->00:39:22.961
So if you understood initially
how this attack works, you
should be able to do this by

00:39:22.961-->00:39:27.732
now. So All you have to do is to
copy paste this curl request to
HTTP Webapp and absorb the

00:39:27.732-->00:39:35.640
length so when you see an
unguessed secret, which is wrong
you’ll get x, if the secret is

00:39:35.640-->00:39:39.777
2, x still, if the secret
becomes 3 that you’re trying to
guess the compression should

00:39:39.777-->00:39:46.117
reduce, its x-1 or - 3
whatever it is and you should
see a reduced length in your

00:39:46.117-->00:39:54.225
Wireshark for that specific
packet. That is possible when
you’re connected to a VPN your

00:39:54.225-->00:39:59.530
VPN is probably be vulnerable to
HTTP traffic. OK so fixing. In
general fixing compression is a

00:39:59.530-->00:40:05.637
very open ended area its very
interesting from a the the
performance point of view from

00:40:05.637-->00:40:11.476
security point of view how
effective is this to even
disable entirely when the crime

00:40:11.476-->00:40:15.880
like that came about if you
remember, they talk about the
SPDY protocol and how the

00:40:15.880-->00:40:21.486
headers in those where a
problem, so for later the
HTTP2 they came up with this

00:40:21.486-->00:40:27.659
product called HPACK it's pretty
straightforward. What it tries
do is selectively disables

00:40:27.659-->00:40:33.798
compressing sensitive data. So
in this whole attack that we’ve
been talking about for crime and

00:40:33.798-->00:40:39.937
even this attack if you could
selectively disable cookies from
getting encrypted, sorry getting

00:40:39.937-->00:40:45.009
compressed, then things would be
safe so if you look at HPACK
specification of for the header

00:40:45.009-->00:40:50.181
compression they have this thing
called Never-indexed literals so
they maintain a list of well

00:40:50.181-->00:40:57.755
known literals which are
sensitive so any algorithm if
you’re using algorithm to

00:40:57.755-->00:41:03.194
compress stuff, you probably
want to know this Never-indexed
literals and probably add them

00:41:03.194-->00:41:10.535
to your library as well. And
Cloudflare, their doing some
interesting stuff here as well

00:41:10.535-->00:41:17.442
so breach attack that we talked
a little while back is not
entirely fixed because you can

00:41:17.442-->00:41:25.984
simply go and fix a Gzip just
disable HTTP response with the
enormous amount of Webapps you

00:41:25.984-->00:41:32.223
have today that’s going to be
crazy. So they did a similar
thing just like Never-indexed

00:41:32.223-->00:41:36.194
literals it's kind of a
challenge you can have, they
have their own breach style of

00:41:36.194-->00:41:39.831
types of smaller to breach and
they have this engine module
called Cfnocompress which

00:41:39.831-->00:41:46.037
selectively deceives compression
for their well known secrets
they use so in this case the CSR

00:41:46.037-->00:41:55.179
tokens and other stuff in the
HTTP responses, so my specific
advice for VPN others and

00:41:55.179-->00:41:59.417
library implementals in general
is disable compressions entirely
if you have HTTP traffic,

00:41:59.417-->00:42:05.123
because if you have users who
are using your library purely
for encrypting HTTP, then

00:42:05.123-->00:42:13.097
they’re going to be misled. So
as I said entirely turning
compression off by default is

00:42:13.097-->00:42:18.269
opinionated when I had this
discussion with OpenVPN team
they are nice bunch of folks so

00:42:18.269-->00:42:24.342
they couldn’t entirely disable
compression even though they
have 2 camps which said 1-2 go

00:42:24.342-->00:42:28.312
ahead and completely disable. A
lot of people are using openVPN
and they choose to effectively

00:42:28.312-->00:42:35.453
warn every users of OpenVPN so
one instance is TunnelBear, its
my favorite tasks vpns and I had

00:42:35.453-->00:42:40.992
a chat with them, they quickly
disabled low compression on
their server side and on their

00:42:40.992-->00:42:48.399
client side so that is pretty
neat, so as everyone has been
seeing it's time we move to

00:42:48.399-->00:42:53.738
HTTPS it's nothing new people
have been saying this for 15
years we have less encrypt we

00:42:53.738-->00:43:00.578
have a lot of HTTPS is really
fast right now like if you to
use HTTP 2 it a lot of crazy

00:43:00.578-->00:43:09.187
thing happening there with TLS
on dot 3 things are much much
more better now. So I don’t see

00:43:09.187-->00:43:13.858
there is a reason for anyone to
still use HTTP or if even
someone using HTTP or VPN, now

00:43:13.858-->00:43:20.832
is the time to just move away
from that, so as I said, the
take away if you are an end

00:43:20.832-->00:43:29.240
user, talk to your Webapp or
your corporate Webapp guys to
just move to HTTPS for those

00:43:29.240-->00:43:35.613
specific traffic that they send
and if you are still using VPN
to use to protect against plain

00:43:35.613-->00:43:42.420
HTTP traffic, don’t do that
anymore and VPN providers as I
said try to disable

00:43:42.420-->00:43:48.993
compressionals do the
Never-indexed literals like
Cfnocompress or HPACK. so that’s

00:43:48.993-->00:00:00.000
it, thanks a lot. [applause]

