00:00:00.334,00:00:05.706
>>Alright, so, I am very excited
to hear this talk, because it’s
gonna be given by a kid that is

00:00:05.706,00:00:10.444
uh very young uh very
intelligent in fact he’s uh
competing in the uh CTF this

00:00:10.444,00:00:15.115
weekend. Um, which makes him way
smarter than the lawyer talking
to you right now, that’s for

00:00:15.115,00:00:21.321
sure. Um but I’m also excited
because this talk in the
abstract, you can see it

00:00:21.321,00:00:26.593
actually has some magic words in
there. How to get started, yeah?
‘Cause a lot of these talks that

00:00:26.593,00:00:29.796
you’re gonna see this weekend
kinda drop you right in the
middle and you’re picking up

00:00:29.796,00:00:34.534
just a little bit as you see
somebody show off some kind of
cool exploit. This is gonna be

00:00:34.534,00:00:39.740
much more of a kind of uh 45
minute survey course I
understand. So, sit back and

00:00:39.74-->000:00:45.612
relax and let’s give Seamus a
big round of applause.
[applause] Have a good time.

00:00:45.612,00:00:50.617
>>Hey thank you. >>Kick some
a**. >>Thank you. [applause] Uh
alright, so I hope you’re all

00:00:52.653,00:00:57.758
here ‘cause you’re interested in
learning something about how the
baseband in your phone works. Um

00:00:57.758,00:01:02.529
so I guess we’ll just get
started then. Um so this is
kinda the brief agenda for the

00:01:02.529,00:01:07.768
talk. A little bit about me, why
I think these are an interesting
research topic and why I’ve been

00:01:07.768,00:01:12.306
working on them for the past
several months. Uh a little bit
about the history and evolution

00:01:12.306,00:01:17.044
of the platform, because I think
knowing wh certain design
decisions and why they were made

00:01:17.044,00:01:21.381
in the past, uh, can really help
you when you’re looking at
disassembly and code and like

00:01:21.381,00:01:26.186
did they really do that silly
thing? Um, a little bit about
how a Modern System-on-Chip is

00:01:26.186,00:01:32.259
laid out. It’s uh changed a lot
since the first cell phones were
introduced. Um, a little bit

00:01:32.259,00:01:36.697
about the actual custom CPU
architecture that the baseband
chips in Qualcomm phones

00:01:36.697,00:01:42.469
actually run on. Uh a brief
intro to some cell stuff,
because not everybody has a huge

00:01:42.469,00:01:46.940
radio background, I know I
didn’t. And then how you
actually start analyzing these

00:01:46.94-->000:01:51.945
things. Um so uh I’m Seamus,
I’ve been working in uh ku
information security for about 4

00:01:54.915,00:02:00.087
years now. Um I’m still an
undergraduate student actually,
I go to UMBC in Maryland. Um I

00:02:00.087,00:02:05.659
was a member of their uh
competition team when we went to
CCDC couple years back. Um I’m

00:02:05.659,00:02:10.197
participating in the CTF here
with Spaceballs this weekend. Um
but I’m really interested in

00:02:10.197,00:02:13.767
like embedded systems and
vulnerability research and
exploit development and all

00:02:13.767,00:02:20.674
those kinds of things. Um any
kernels, I like playing with
kernels. Alright so my goals for

00:02:20.674,00:02:26.313
my research and hopefully for
what I kinda want some of you
guys to get out of this talk is

00:02:26.313,00:02:30.150
what is a baseband and how is it
really like interact with
Android. Um I wanna define bugs

00:02:30.15-->000:02:36.523
net, that was my main goal and
then I also wanted to learn
something and have fun. Um. So

00:02:36.523,00:02:41.695
there’s been a little bit of
prior work in the area. Uh the
first few real baseband talks

00:02:41.695,00:02:48.635
came out 201-->0 2011. Um and
they’ve this was back when the
Qualcomm basebands ran on arm

00:02:48.635,00:02:52.939
processors. So and they used a
completely different real-time
operating system when they run

00:02:52.939,00:02:57.077
now. So it’s a little bit
outdated, but uh still worth
looking through all these old

00:02:57.077,00:03:00.180
talks and digging up the videos,
they give a great background
introduction to some of this

00:03:00.18-->000:03:06.953
stuff. Uh the first talk which
really tackled their new
architecture was uh baseband

00:03:06.953,00:03:10.957
exploitation in 2013 which was
given at PacSec, it was the
first talk to really cover

00:03:10.957,00:03:16.396
hexagon and any details about it
whatsoever. Um and that’s around
when those chips started being

00:03:16.396,00:03:22.502
introduced into phones 2012,
2013 . Every Qualcomm folds, uh
Qualcomm phone since then sold

00:03:22.502,00:03:27.941
has one of these chips in it. Um
and then more recently there was
a talk just this past year at

00:03:27.941,00:03:34.681
CanSecWest, which was after I
started doing my research. Um
and that was a talk which kind

00:03:34.681,00:03:38.919
of uh talked about a bug they
found and the debugger they
built around it and some of the

00:03:38.919,00:03:44.224
cool things they did. But it was
a lot less of uh like how do you
get started looking for bugs um

00:03:44.224,00:03:47.761
which those have always
historically been some of the
most useful talks to me when I’m

00:03:47.761,00:03:52.966
trying to learn something not a
walk through of exploiting like
this kernel zero-day. Um those

00:03:52.966,00:03:57.971
are cool and I learn things from
them but I also wanna find my
own, so. Uh, so for those of you

00:04:01.141,00:04:05.378
who aren’t entirely sure what a
baseband is, it’s the main chip
in your cell phone which

00:04:05.378,00:04:09.683
actually communicates with the
cellular network. Um on some
level it handles the cuh

00:04:09.683,00:04:15.055
transformation of radio waves
into actual ones and zeros. And
then processes the information

00:04:15.055,00:04:19.893
inside of those. Um there is a
ridiculous number of cellular
standards and use around the

00:04:19.893,00:04:25.432
world, and most baseband chips
support most if not all of them
and fall over in between them,

00:04:25.432,00:04:29.636
because you don’t know if you’re
leaving the country or if you’re
roaming in between cells,

00:04:29.636,00:04:32.339
different carriers, if you’re
roaming on a different carrier
they have things set up

00:04:32.339,00:04:38.011
differently. Um so there’s a lot
of complexity within these um
just inherent to the nature of

00:04:38.011,00:04:43.617
them. Um it’s also your phones
main external interface to the
rest of the world. Uh you know

00:04:43.617,00:04:49.189
you’re you’re data comes over
this, your internet, um all your
text messages. Um and it’s one

00:04:49.189,00:04:54.194
of the last few attack surfaces
where you can actually get truly
like remote code execution

00:04:54.194,00:04:59.199
unauthenticated no user
interaction whatsoever, um,
along with some of the other

00:04:59.199,00:05:03.837
firmware on your phone like the
Bluetooth and the wifi. You
know, a lot of exploits have

00:05:03.837,00:05:07.374
been going the way of you need a
browser bug and fishing and
somebody clicks on the link.

00:05:07.374,00:05:11.178
This you really don’t need much
in the way of interaction, you
just need a phone number. Um

00:05:11.178,00:05:16.183
that’s why it was interesting to
me. Um, so I kinda picked
Qualcomm to focus on as they had

00:05:18.985,00:05:24.925
by far the largest market share
of uh the whole baseband market.
Um and at least up until

00:05:24.925,00:05:29.829
recently, most of your high end
phones carried Qualcomm chip of
some kind in them. You know, all

00:05:29.829,00:05:35.702
your Snapdragon processors and
most of your high end Androids
these days. Uh the market spread

00:05:35.702,00:05:42.108
up a little bit more um Wallway
makes some of their own
basebands uh, Samsung makes some

00:05:42.108,00:05:47.447
with their Exynos chip. But the
main reason Qualcomm owns a lot
of the market is they were the

00:05:47.447,00:05:51.618
big proponent of a cellular
standard called CDMA, which is
one of the two big ones, they’re

00:05:51.618,00:05:57.857
kind of grouped into two groups.
Um so you have GSM, and you have
CDMA. And if this is why phones

00:05:57.857,00:06:04.197
can be carrier locked, because
AT&T is GSM and Verizon is CDMA.
So if you and they have a

00:06:04.197,00:06:08.568
deathgrip on all of the patents
in the United States for CDMA
basically. So if you wanna sell

00:06:08.568,00:06:11.938
a phone which does that, you
kinda got stick a Qualcomm chip
in it. Um for phones in other

00:06:11.938,00:06:16.576
markets around the world, CDMA
is more prominently a United
States thing, so you’ll see a

00:06:16.576,00:06:21.081
little more variety in the
chips. But they still have more
than half the market share. Um,

00:06:23.45-->000:06:27.220
so a little bit about the
history of the platform. Um,
these chips in your phones, the

00:06:27.22-->000:06:32.225
basebands, they run a completely
separate operating system,
separate from Android or iOS. So

00:06:32.225,00:06:36.162
it’s own self-contained
operating system with its own
bugs and its own rules. So these

00:06:36.162,00:06:41.234
are uh something called an RTOS,
a real-time embedded operating
system. They’re typically found

00:06:41.234,00:06:47.207
in lots of uh like industrial
applications, power, gas,
electric. Um, things which have

00:06:47.207,00:06:51.311
strict time constraints. And you
can’t have a process like a
browser hanging up and freezing

00:06:51.311,00:06:55.749
your entire system. Things need
to happen on a schedule, um, and
there can’t be any kind of

00:06:55.749,00:07:01.154
interruption to those. And you
can kinda split RTOS’s into two
separate categories, where they

00:07:01.154,00:07:06.526
either have some form of memory
protection or they just don’t.
Um so there’s either some form

00:07:06.526,00:07:09.963
of virtual memory, even if it’s
not meant for protection
purposes or that everything just

00:07:09.963,00:07:16.670
runs in like a fly hydro space.
Straight memory. Um the RTOS’s
are used pretty widely. Um Sysco

00:07:16.67-->000:07:23.677
Writers use one of ‘em, Toradex
Intel, that runs Intels modems,
um and some newer Broadcom chips

00:07:23.677,00:07:28.682
I just recently learned, things
like that. Um so going back uh
to the start of the mobile

00:07:31.184,00:07:36.423
phones, uh, REX was Qualcomm’s
real-time executive it was the
original RTOS which ran the

00:07:36.423,00:07:40.960
modem. And this is before you
had smartphones and Androids, so
this ran your entire phone. Um

00:07:40.96-->000:07:46.900
it was actually designed for the
Intel 186, and then uh as they
started growing as a company and

00:07:46.90-->000:07:52.072
the 186 was getting a little
outdated they actually tried to
license a 386 core from Intel

00:07:52.072,00:07:55.775
and Intel kind of blew them off
at the time ‘cause they were
busy with other things. But if

00:07:55.775,00:07:59.512
they hadn’t, the cellular market
would look pretty different
today. Um ‘cause this is what

00:07:59.512,00:08:04.918
drove the switch to ARM on all
your chips and phones. So Intel
might very well have started

00:08:04.918,00:08:10.256
producing like lower power
consumption chips and the suh
mobile market might not be all

00:08:10.256,00:08:16.262
ARM if they hadn’t uh rejected
Qualcomm’s offer wayback when.
Um but this chip uh so they port

00:08:16.262,00:08:20.533
it to ARM, this RTOS, sorry,
they port it to ARM and
everything ran supervisor mode,

00:08:20.533,00:08:24.904
there was no privilege
separation. If you had any kind
of code execution, you were

00:08:24.904,00:08:30.110
king. Um it kinda ran as like
one single process and your
tasks were just threads in that

00:08:30.11-->000:08:34.447
process. Um, so it was very much
a product of its times in the
early 90’s. Uh so you’ll

00:08:34.447,00:08:39.285
actually still run into this,
which the reason I’m kinda going
through some of the quirks, if

00:08:39.285,00:08:44.357
you buy any kinda like feature
phone, so like, not a
smartphone, burner phone type of

00:08:44.357,00:08:49.462
deal, a lot of those run
something called um Qualcomm
BREW, which is like their binary

00:08:49.462,00:08:55.168
run time for ev, for wireless I
think. Uh and that REX is the
core part of that actually. The

00:08:55.168,00:09:00.106
rest of it’s piled on top. Um so
tasks are your threads
basically. Um every task has a

00:09:02.142,00:09:05.912
task control block, which kinda
stores the information about it
where your stack pointer

00:09:05.912,00:09:10.183
currently is, what’s the
priority of the task, because
this is an RTOS, so if a task is

00:09:10.183,00:09:15.188
really high priority, it’s not
gonna interrupt it. Um the size
of your stack. Every task has

00:09:15.188,00:09:20.093
its own stack, and then when
they are uh suspended to let
room for something else happen,

00:09:20.093,00:09:25.331
this is all just saved. So if
you have any kind of like
overflow or code execution, you

00:09:25.331,00:09:31.070
can actually overwrite a
different tasks um current state
from the stack so when it’s

00:09:31.07-->000:09:36.910
restored you just took control
of something else. Um there’s uh
the task control blocks are just

00:09:36.91-->000:09:39.946
stored in a double length,
similar to process and other
operating systems. It’s very

00:09:39.946,00:09:44.951
trivial to dork with things on
this system. Um the only problem
is this is poorly documented.

00:09:47.587,00:09:52.592
Um. So kinda moving out of the
end of the 90’s and into the mid
2000’s, uh Qualcomm decided to

00:09:56.162,00:10:01.534
switch away from REX um and they
didn’t actually do it for any
security reasons, it’s just

00:10:01.534,00:10:05.004
really tricky to debug code when
you have no memory protection.
You don’t know whether

00:10:05.004,00:10:09.242
something’s being cause by some
of your code overwriting some
other code accidentally, it’s

00:10:09.242,00:10:14.047
really tricky to debug things.
Um so they started looking for
solutions, uh if you dig through

00:10:14.047,00:10:18.751
some of their ancient
documentation, you can find REX
didn’t do any kind of parameter

00:10:18.751,00:10:23.323
validation. They basically told
you whatever you pass to our API
better be right because we’re

00:10:23.323,00:10:28.127
not gonna check it. Um it’s
great for when you’re trying to
find bugs. Sadly they kinda

00:10:28.127,00:10:34.167
moved away from this to
something a little bit more
secure. Uh so in the middle,

00:10:34.167,00:10:39.172
like 2005, 2006-ish, they
switched to a microkernel called
L4, which is kind of an academic

00:10:41.875,00:10:47.480
microkernel came out at like the
end of the 90’s I think. Uh the
way most people heard of it is

00:10:47.48-->000:10:51.818
something called SLE4 which was
the formally verified version of
it. Which was math I Math Now!

00:10:51.818,00:10:58.491
had proven to be free of certain
bug classes. Um but the
microkernel itself was freely

00:10:58.491,00:11:04.097
available and different kind of
licenses um so this is actually
a much more mature operating

00:11:04.097,00:11:08.234
system, you actually have real
processes and real threads. Um
there is actually a privilege

00:11:08.234,00:11:13.773
separation barrier, the kernel
runs in supervisor mode and the
actual su programs run user

00:11:13.773,00:11:18.778
space. Um they were actually
gonna port L4 to their newest
DSP, the one they designed in

00:11:20.914,00:11:25.118
house, and they kinda had a
falling out with the company
they were working with on this

00:11:25.118,00:11:30.290
with L4. So they decided to just
rewrite their own real-time
operating system. Not really

00:11:30.29-->000:11:35.061
necessarily learning from the
mistakes of the last time they
did that. Um so they took L4

00:11:35.061,00:11:39.699
which is much more secure then
they had before and they kinda
ruined it by writing an

00:11:39.699,00:11:44.604
emulation order for their old
RTOS. Because they didn’t want
to actually change any of their

00:11:44.604,00:11:48.608
code base for the modem
services. Uh this is something
you’ll see a lot when you’re

00:11:48.608,00:11:54.080
dealing with this kinda
firmware, is it has to be, um,
approved by different licensing

00:11:54.08-->000:11:58.318
bodies and reevaluated when you
make changes and that can be uh
quite a process to go through,

00:11:58.318,00:12:02.188
so they try and avoid changing
things as much as possible.
Which is why bugs can be long

00:12:02.188,00:12:06.125
lived sometimes, or there’s
terrible turn around time, it’s
actually getting updates for

00:12:06.125,00:12:10.730
your baseband or your wifi
firmware, things like that. Um
so they wrote this emulation

00:12:10.73-->000:12:17.036
layer, so they could take all of
their actual modem software, and
it will cha keep the same API it

00:12:17.036,00:12:21.741
thinks it’s talking to and it
will transparently converse it
on the backend. Um so that

00:12:21.741,00:12:25.812
doesn’t really help you
eliminate that many bugs. Um but
they at least do run the modem

00:12:25.812,00:12:32.085
software and user mode now
instead of in kernel space. And
then moving on from that, you

00:12:32.085,00:12:36.456
know they kinda started
developing their own in-house
digital signal processor. This

00:12:36.456,00:12:42.028
is the thing that makes Qualcomm
chips pretty unique, is most
other basebands Wallway’s,

00:12:42.028,00:12:48.668
HiSilicon, um Samsung Shannon
baseband, they all run on some
form of ARM processor. And they

00:12:48.668,00:12:53.740
might have some dig digital
processing logic to handle like
the lower level physical layer

00:12:53.74-->000:12:58.678
conversion. But everything
actually runs on ARM. Uh a lot
of the actual processing does,

00:12:58.678,00:13:04.250
Qualcomm actually runs
everything just on the DSP as
opposed to having the DSP handle

00:13:04.25-->000:13:08.821
some of the conversion and then
porting, passing it over to a
different processor. Um so the

00:13:08.821,00:13:14.694
current one is CuRT, the
Qualcomm real-time OS. It used
to have a different name, I

00:13:14.694,00:13:19.699
don’t know actually what that
stood for, it used to be called
BLAST, and uh there are actually

00:13:19.699,00:13:25.304
two hexagon cores in most
earphones now. Uh they have one
which handles the baseband, the

00:13:25.304,00:13:30.543
broadband radio, and they have
one which handles all the old
processing. Uh so they actually

00:13:30.543,00:13:34.781
expose this to application
developers, you can, if you
think your algorithm will run

00:13:34.781,00:13:39.285
better on digital signal
processor for some audio tricks
you’re trying to do, uh you

00:13:39.285,00:13:43.890
actually have access to this in
a limited capacity. Um most of
the API’s are again backwards

00:13:43.89-->000:13:47.026
compatible, so they don’t have
to change as much software. So
some of the threading stuff

00:13:47.026,00:13:51.798
changed a little bit, but most
of it’s pretty much the same.
It’s a pretty mature real-time

00:13:51.798,00:13:57.236
OS, as far as real-time OS’s go,
you have new techs and SEMA
Four’s. Same kind of priority

00:13:57.236,00:14:02.542
based scheduling you see across
a lot of these um but it does
actually have memory protections

00:14:02.542,00:14:08.548
and the operating system itself
handles the virtual to physical
memory mapping. Um so, uh the

00:14:08.548,00:14:13.953
mitigations are kind of hit and
miss on this, it is far ahead of
its peers. Um, Samsung for

00:14:13.953,00:14:19.892
instance has NX and has it
turned on in some places, but
not necessarily covering what

00:14:19.892,00:14:25.098
you would expect it to. Um there
is a complete lack of ASLR, and
this is common in all basebands.

00:14:25.098,00:14:30.770
Um, it’s really tricky to port
some of this software to
actually move around in the

00:14:30.77-->000:14:34.207
address space and like the
real-time OS space loads in the
same spot every time, the kernel

00:14:34.207,00:14:38.845
base is the same place, and then
these things have hard coded
addresses calling each other

00:14:38.845,00:14:42.615
around, so there’s no ASLR,
there’s plenty of gadgets once
you actually have code

00:14:42.615,00:14:48.921
execution. Um they do have a
non-executable stack. Um so you
can’t really wreck the code,

00:14:48.921,00:14:54.927
you’re not supposed to be able
to execute data, and it does
it’s best to enforce that. Um it

00:14:54.927,00:14:58.531
does have stack cookies, uh it
actually has a special register,
frame key register, which

00:14:58.531,00:15:03.870
actually holds some of the stack
cookie information and it X
stores it. Um and then it’s heat

00:15:03.87-->000:15:09.709
prec protection is more for
accidental corruption. It kinda
just marks whether your blocks

00:15:09.709,00:15:15.681
are in use or not with a magic
value. Um it’s not anything
super tricky like you see on

00:15:15.681,00:15:21.587
Windows or uh some of the more
keep common keep allocators for
browsers these days. Um so it’s

00:15:21.587,00:15:26.926
kind of a mixed bag as far as
exploitation is concerned. Uh
there’s, you can’t directly jump

00:15:26.926,00:15:32.465
to your shell code, but as soon
as you actually like get program
counter or something like that.

00:15:32.465,00:15:36.903
There’s no ASLR, so it’s pretty
easy to know where things are in
memory and form your own gadgets

00:15:36.903,00:15:43.009
or use a gadget to write your
shell code into a place you can
execute it. Uh so AMSS is their

00:15:43.009,00:15:48.514
actual name for the software
stack which runs on the modem.
You’ll see a lot of confusion

00:15:48.514,00:15:53.119
about this if you ever start
doing any research, people call
lump, like, say this covers more

00:15:53.119,00:15:56.656
than it actually does. But it’s
the actual modem software,
different drivers, and

00:15:56.656,00:16:01.194
protocols, and everything’s
really used to talk to a
cellphone tower. Um, the the

00:16:01.194,00:16:06.699
lower part of it is pretty chip
set specific. You know, which
area interface’s protocols you

00:16:06.699,00:16:11.470
actually support, you know,
there is a dozen different cell
standards. Um the hardware’s all

00:16:11.47-->000:16:14.574
different so you’ve the level of
different level hardware
drivers. And on the feature

00:16:14.574,00:16:19.478
phones I mentioned earlier, you
have sa like QChat and Q Camera
and Q Message and all these

00:16:19.478,00:16:24.217
applications, which actually run
or are part of AMSS on those,
and they run on the same

00:16:24.217,00:16:30.156
baseband. Um so there’s more
than 60 different processes or
tasks which this is comprised

00:16:30.156,00:16:34.961
of. Um you have a watchdog to
make sure things don’t really
time out, you have a sleep timer

00:16:34.961,00:16:39.465
to save power, you’ve different
things for call control and
message processing and uh

00:16:39.465,00:16:44.470
diagnostics. Um, of those, one
of the most important is the
actual uh diagnostics task. Um

00:16:47.707,00:16:52.044
it provides uh client server
infrastructure where you can
request information from the

00:16:52.044,00:16:58.751
modems stack. And this is what a
lot of Qualcomm’s internal tools
will talk to. Uh, so it’s a hold

00:16:58.751,00:17:04.724
over from their old REX days. Um
and it’ll handle requests, so
reseal or seal exposed over USB

00:17:04.724,00:17:09.295
which is more common now. And
it’s a packet based protocol,
you send information, it sends

00:17:09.295,00:17:13.132
stuff back. So if you ever get
your hands on any of the
Qualcomm tools which have been

00:17:13.132,00:17:18.170
floating around, this is how you
pull off any kind of over the
air logs, failures, um debugging

00:17:18.17-->000:17:22.375
information if you manage to
turn it on, current status if
you’re trying to like test

00:17:22.375,00:17:28.581
things over the air, um
different statistics on calls or
drop drop pass packets and

00:17:28.581,00:17:33.586
things like that. Um, so uh
modern systems on a chip are a
lot more complicated than they

00:17:37.056,00:17:42.495
used to be. Um and one of the
things you’ll kinda run into is
something called a Q fuse, at

00:17:42.495,00:17:48.367
least on Qualcomm devices.
Samsungs have their own similar
depending on the chip set. But

00:17:48.367,00:17:52.705
it’s uh a bank of one time
preventable fuses, um there is
very little public documentation

00:17:52.705,00:17:58.110
about what controls what. But
these are one time, once you
blow the bit you’re not supposed

00:17:58.11-->000:18:02.214
to be able to change it back. Um
and hardware debugging is
disabled in production devices

00:18:02.214,00:18:07.153
by blowing one of these bits. Um
supposedly the factory has a way
to re-enable it, uh but I

00:18:07.153,00:18:11.357
haven’t been able to figure it
out and don’t know anyone else
who’s mentioned being able to

00:18:11.357,00:18:16.329
figure it out either. Um, this
is how, if you ever have a
Samsung phone, they have

00:18:16.329,00:18:21.334
something called a Knox BIt,
which is blown if you flash an
unsigned kernel. Uh, and they

00:18:21.334,00:18:26.906
kinda use that toward vor, uh,
void warranty claims sometimes.
So if you unlock your bootloader

00:18:26.906,00:18:30.676
and start dorking with your
entry device, that’s how they
tell and that’s how they’ll deny

00:18:30.676,00:18:35.982
you if you break it. Um, Secure
Boot is heavily based off this.
The cryptographic keys are

00:18:35.982,00:18:40.987
burned in and can’t be changed.
Um the trust zone uses an
undefined number of these bits

00:18:43.155,00:18:48.160
to as well. Um so in the good
old days before more modern
Android and iOS devices uh your,

00:18:52.264,00:18:56.802
you kinda had your baseband
processor and your actual
application processor. And the

00:18:56.802,00:18:59.972
baseband was actually the first
modem which booted up and
brought up the application

00:18:59.972,00:19:04.744
processor, and it had direct
DMA. If you popped the baseband
you could kinda just control

00:19:04.744,00:19:09.515
everything and right to the
application processor, and the
user would never know. Um, chips

00:19:09.515,00:19:13.886
are a lot more complicated now
and they have a lot more
interconnected subsystems. Uh,

00:19:13.886,00:19:18.758
so on a current Qualcomm SoC for
example, you have your modem
processor subsystem which is

00:19:18.758,00:19:23.896
composed of this hexagon DSP and
the actually accompanying like
hardware ASIC which handles the

00:19:23.896,00:19:28.100
over the air stuff. You have
your actual application
processor set, which on more

00:19:28.10-->000:19:32.905
recent devices is like it’s own
set of 8ARM cores. Um ou have
something called RPM, which

00:19:32.905,00:19:38.477
handles uh, power management for
the device and this has its own
bootloader and bootrom, and it

00:19:38.477,00:19:43.749
runs its own, it’s it’s own
separate ARM core, you don’t
really know about it. Uh there’s

00:19:43.749,00:19:48.621
an interesting piece of
research, um, I’m trying to
remember the company name, I

00:19:48.621,00:19:54.160
think it was LF Security, and
they used a um, a bug, and were
able to dump some of these other

00:19:54.16-->000:19:57.663
bootloaders, so they could dump
like the RPM bootloader and you
could play with it and see what

00:19:57.663,00:20:02.101
it does. Um these are all
cryptographically verified too,
before they’re actually uh

00:20:02.101,00:20:06.705
uploaded to the device. Um your
wireless subsystem is it’s own
separate little subsystem. Uh on

00:20:06.705,00:20:12.812
it’s on most devices it’s a
broadcom chip, although Qualcomm
has their own wifi, I don’t know

00:20:12.812,00:20:16.615
which phones they put it on. Um
then you have your audio
subsystem which is another

00:20:16.615,00:20:23.089
digital signal processor, which
again is exposed to the user.
Um, so this is a really

00:20:23.089,00:20:26.625
simplified boot order, it’s
actually a lot more complicated
than that. But usually you power

00:20:26.625,00:20:31.530
on the phone, uh the burned in
bootloader powers up, and it
loads a secondary stage

00:20:31.53-->000:20:37.369
bootloader. And that loads like
the uh RPM firmware, to handle a
lot of the power on the device,

00:20:37.369,00:20:42.374
and then it loads a second stage
which actually loads your trust
zone. Your QSZE is Qualcomm’s um

00:20:44.91-->000:20:49.915
trust zone environment. So it
loads that and then the trust
zone handles loading everything

00:20:49.915,00:20:54.420
else. So all the cryptographic
signatures are verified by the
trust zone after this point. Um,

00:20:54.42-->000:21:00.326
so that loads the application
bootloader, so that’s uh like A
boot or S boot which actually

00:21:00.326,00:21:05.531
boots your Android kernel for
example. Um so then that handles
loading the kernel, and then the

00:21:05.531,00:21:09.335
kernel itself pushes over
something called a modem boot
authenticator, which handles

00:21:09.335,00:21:13.506
validating the actual modem
image, which is then pushed over
and the modem has its own set of

00:21:13.506,00:21:18.043
bootloader, and then the AMSS
software is validated and the
modem kinda is brought up. Then

00:21:18.043,00:21:21.814
after that your wireless and
your other DSP’s are brought
online. Um. So the uh the

00:21:21.814,00:21:26.819
baseband and the application
processor have to have some way
to be able to talk to each

00:21:35.728,00:21:40.132
other, uh to be able to say hey
I want to make a phone call, hey
you got an incoming text, things

00:21:40.132,00:21:46.605
like that. Um so on most devices
there’s a form of shared memory
interface, uh where one side

00:21:46.605,00:21:50.409
writes some data and the other
side checks periodically and
picks it up and processes it. Uh

00:21:50.409,00:21:54.914
and there’s actually a common
set of APIs, if we’re talking
about Android here, iOS does it

00:21:54.914,00:21:59.218
a little different, but there’s
a common set of APIs on the
linux and on the modem side,

00:21:59.218,00:22:05.157
which take care of initializing
this, allocating this, searching
for things in it. Um, so it is

00:22:05.157,00:22:11.797
part of the actual like main
RAM. The baseband chip does not
get it’s own separate RAM, and

00:22:11.797,00:22:16.535
neither do any of these other
subsystems. They are all
actually talking to the same 8

00:22:16.535,00:22:20.906
or however many gigs of RAM you
have on your phone, and it’s
just portioned up acco, where

00:22:20.906,00:22:26.345
each little device wants it’s
own little piece. Um so the SMD
is the shared memory driver,

00:22:26.345,00:22:31.817
which is a more high level
wrapper around some of these low
level APIs so you can kinda just

00:22:31.817,00:22:36.155
have a pipe and shove data into
it. And then the other side just
reads from it. Uh it’s a little

00:22:36.155,00:22:42.027
less complicated for driver
developers. Um each of your AMSS
tasks has it’s own separate two

00:22:42.027,00:22:47.032
way channel over this shared
memory over face. So your
diagnostics has a set of

00:22:49.235,00:22:53.806
channels, uh and that’s where it
patches information. Um remote
procedure calls have their own

00:22:53.806,00:22:59.411
set of channels, uh your GPS has
your own set of channels. Um so
this is one of your main attack

00:22:59.411,00:23:04.884
surfaces if you’re looking to
elevate your privileges from the
baseband chip itself to the

00:23:04.884,00:23:10.356
actual application processor. Um
they talk back and forth and uh
this is one of the main ways

00:23:10.356,00:23:15.094
they communicate. So if you can
find bugs in how messages are
being parsed or sent, that’s how

00:23:15.094,00:23:20.699
you can kinda jump and get code
execution on the other side. Um
one of the other things they

00:23:20.699,00:23:26.639
also have is the QMI protocol
Qualcomm designed. Um,
originally it was kinda designed

00:23:26.639,00:23:32.678
to supplement the old haze AT
command set you used to program
modems with. Um, and in itself,

00:23:32.678,00:23:36.815
like Qualcomm, everything
Qualcomm does is a wrap around
another older protocol they used

00:23:36.815,00:23:43.722
to have. Uh but it’s used to
talk to your modem, you can can
configure it, send in different

00:23:43.722,00:23:47.092
commands, but you don’t actually
make any hardware decisions
based off of this, all you can

00:23:47.092,00:23:51.930
do is kinda influence how
different pieces act. Um and
again, just like the diagnostic

00:23:51.93-->000:23:56.635
task, it’s a client-server
model. Uh, it’s a variable
length packet structure, which

00:23:56.635,00:24:02.074
is interestingly where this is a
lot of your bugs are gonna be.
Um, there’s a set header, and

00:24:02.074,00:24:07.413
then uh a different number of
payloads you can send and these
are all type length value based,

00:24:07.413,00:24:11.750
so the first portion specifies
what this is, you know, if
you’re trying to set up a phone

00:24:11.75-->000:24:16.722
call or you know, what you’re
trying to accomplish. And then
the next piece is how long is

00:24:16.722,00:24:22.461
the message? And then follow it
by the actual data. So, ‘cause
this was originally coded quite

00:24:22.461,00:24:27.633
a while ago, it’s quite possible
to find bugs and it just blindly
trusts the values you’re feeding

00:24:27.633,00:24:32.338
it, for a, for instance like
your length. And if it passes
that into some sort of copy or

00:24:32.338,00:24:36.709
it makes parsing decisions based
on that, you can try and get
code execution in the kernel on

00:24:36.709,00:24:41.714
the Android or iOS side. Um. So
uh the real kinda new thing
about what Qualcomm’s been doing

00:24:44.149,00:24:49.488
is they designed their own
custom in house DSP. It’s not
really based on anything else,

00:24:49.488,00:24:56.495
uh so you know if you were here
and you heard about the CTF last
year where they wrote their own

00:24:56.495,00:25:00.966
custom architecture with 9 bit
bytes, um it’s not quite as bad
as that, but it’s not really

00:25:00.966,00:25:07.639
related to any type of intel or
uh ARM assembly code you usually
see. Uh as a general purpose

00:25:07.639,00:25:12.511
digital signal processor, which
is really interesting, it’s not
specifically designed to handle

00:25:12.511,00:25:16.248
a lot of cellular stuff, which
is why you can handle like audio
processing on it as well. Uh so

00:25:16.248,00:25:22.121
there are two on the SoC like I
mentioned earlier, one is
dedicated just for your

00:25:22.121,00:25:27.259
broadband radio, and the second
one is just for audio processing
and if you write NAP you can

00:25:27.259,00:25:31.163
actually access this. And that’s
it’s own separate attack service
for like breaking out of

00:25:31.163,00:25:36.402
sandboxes if you’re trying to
play audio and things like that.
Uh because that other audio DSP

00:25:36.402,00:25:41.840
also has its own RTOS on it, and
if you can pop that you kinda
get like media server

00:25:41.84-->000:25:44.877
privileges, depending on how
your Android device is enabled.
And you have a lot more

00:25:44.877,00:25:50.749
privileges from there to try and
escalate to system. Um so the
way the hexagon chip is laid

00:25:50.749,00:25:55.120
out, you have uh a variable
number of hardware threads, um
depends on the specific

00:25:55.12-->000:26:00.359
iteration of the chip, but you
can say 4 for general example.
Um so kinda like cores on an

00:26:00.359,00:26:06.632
Intel device. And each of those
threads shares the L1 and the L2
caches between them. The threads

00:26:06.632,00:26:12.271
don’t have separate caches. Uh
but there are separate caches
for instructions and for data

00:26:12.271,00:26:18.977
and operans just like you have
in ARM or a power PC chip. So
you can’t, even if there was no

00:26:18.977,00:26:24.817
um NX or dep, you couldn’t just
smash the stack and then jump to
your shell code, because that’s

00:26:24.817,00:26:28.921
data and it won’t be in the
instruction cache and you’ll
cause a fault. So you actually

00:26:28.921,00:26:34.126
do have to like dork with cache
lines and stuff if you’re trying
to build an exploit like that.

00:26:34.126,00:26:38.030
Um and the other really
interesting thing is these 4
hardware threads are designed

00:26:38.03-->000:26:43.168
for parallel execution, so when
you compile a program down to
hexagon, it actually, the

00:26:43.168,00:26:49.441
compiler figures out different
operations which don’t need,
they don’t depend on each other.

00:26:49.441,00:26:53.879
Um so then it will schedule
those just to run at the same
time, simultaneously across all

00:26:53.879,00:27:00.319
4 threads. Um so this is kinda
on a high level how to, how it’s
laid out. Each thread has its

00:27:00.319,00:27:05.290
own execution unit, it pulls
instructions. Um those are
packet based, so your packet

00:27:05.29-->000:27:11.129
doesn’t have to be 4
instructions, it can be 3. And
the execution unit will just not

00:27:11.129,00:27:16.101
fetch anything for that um, so
you don’t have the packets run
out of order. You can’t have a

00:27:16.101,00:27:20.372
packet with 3 running on 3 of
the threads and the other
threads actually like a packet

00:27:20.372,00:27:25.277
ahead. It’ll just kind of uh
spin it wheels for the next
cycle and then pull in the next

00:27:25.277,00:27:30.282
packet. Um then they have shared
instruction data caches and a
shared more high level L2 cache.

00:27:34.553,00:27:39.691
Uh so the architecture is kind
of standard as far as embedded
devices go. Um you have uh a

00:27:39.691,00:27:45.030
bunch of general purpose
registers. Uh they’re 32 bits
wide. Um your first 6 are used

00:27:45.03-->000:27:49.535
to pass arguments to functions
when you’re looking at the
assembly. Uh the return value is

00:27:49.535,00:27:54.740
stored in register zero and then
you have a split between caller
saved and callee saved. Just

00:27:54.74-->000:27:59.745
kind of like you do in those
other architectures. Uh um the
stacked is again pretty

00:28:02.18-->000:28:06.885
standard. Um you have a stacked
pointer and a frame pointer and
you have a link register just

00:28:06.885,00:28:11.256
like RM for holding return
addresses in. Um the stacked
goes downwards from high to low

00:28:11.256,00:28:15.460
memory. Uh it does need to be 8
byte aligned. Which is the one
gotcha when you’re running an

00:28:15.46-->000:28:22.367
exploit. And because Qualcomm uh
designed this architecture from
scratch they kinda had the

00:28:22.367,00:28:27.406
freedom to put in a lot of
different things they wanted to.
So they have instructions that

00:28:27.406,00:28:32.711
will just take care of setting
up and tearing down your stack
frames as opposed to the compile

00:28:32.711,00:28:39.484
wasting of few instructions on
it as it kind of does with Intel
and arm. So it it’s pretty

00:28:39.484,00:28:44.489
standard. The uh the threads in
their artas are actually saved
on the stack. Um they’re pretty

00:28:48.393,00:28:53.265
far apart but if you have a
large enough overwrite you can
corrupt the state um of another

00:28:53.265,00:28:58.403
thread or another process. Just
like you’re able to back in
recs. That hasn’t really

00:28:58.403,00:29:03.342
changed. Uh besides your kinda
standard yeah we have registers
we pass arguments. It works like

00:29:06.111,00:29:11.316
a computer. Uh they add in a
couple useful things for
debugging. So you have uh a

00:29:11.316,00:29:15.454
system status register which is
the first place you should be
checking when you get like a ram

00:29:15.454,00:29:21.193
dump or any kind of crash. Um so
this holds the ASID which is the
address face ID that the crash

00:29:21.193,00:29:26.198
happened in. Uh it will hold an
8 bit value for the cause of the
crash whether it was a uh like a

00:29:28.667,00:29:33.672
page fault or you divide by 0 or
your other standard operations.
Um and will tell you tell you

00:29:35.774,00:29:41.580
which of the virtual ELR
registers to look in for more
information. So there are

00:29:41.58-->000:29:48.320
actually 2 different BAD virtual
address registers which hold um
exception addresses generated uh

00:29:48.32-->000:29:54.226
so that the address the address
of the exception handler when an
exception occurs and uh there’s

00:29:54.226,00:29:58.030
like two separate execution
slots for each of those threads.
Which is why there’s 2 registers

00:29:58.03-->000:30:03.869
and then you have an exception
link register which holds the
program counter value from when

00:30:03.869,00:30:07.539
1 exception was triggered so it
saves a lot for you. They
actually have a lot of useful

00:30:07.539,00:30:12.544
debugging information. Um so
this is a little more recently
introduced. Um they’ve been

00:30:18.65-->000:30:23.155
constantly making indurations of
this processor. So on the most
recent ones probably shipped in

00:30:23.155,00:30:27.726
the last year or so um they’ve
introduced something called
protection domains. Which

00:30:27.726,00:30:32.731
implements hardware uh hardware
in for a separate address basis.
And they did this because uh

00:30:34.733,00:30:39.738
they have the capability to run
the wifi subsystem on the same
DSP as the broadband radio. And

00:30:42.874,00:30:46.611
they want to keep them very very
separate so they can’t touch
each other. Um and this sounds

00:30:46.611,00:30:51.917
like a really cool idea in
theory um except that means your
wifi and your broadband are

00:30:51.917,00:30:56.655
going to be sharing the same
layer 1 and layer 2 caches. I
haven’t really dug into that but

00:30:56.655,00:31:02.294
I’m pretty sure you can either
get info leaks or uh really
influence the way the other one

00:31:02.294,00:31:08.967
is seeing the cache. Um so it’s
kinda divided. There’s a kernel
mode then they have kinda like a

00:31:08.967,00:31:14.506
a second split after that in
between standard users and
guests. Um so guests is more

00:31:14.506,00:31:20.245
like ring ring 1 or ring 2 on an
intel device as opposed to a
ring 3 which is the user. Um so

00:31:20.245,00:31:27.119
your broadband radio stuff kinda
runs in the guest OS mode. Um
the RTAS kernel itself run in

00:31:27.119,00:31:32.157
the kernel mode. Then your wifi
would run user mode. And
interestingly enough, uh

00:31:32.157,00:31:37.896
sometimes these stack checks for
like the stack memory and stuff
aren’t actually done in kernel

00:31:37.896,00:31:42.901
mode, only in the user and the
guest mode. Um alright so uh
cellular stuff is very very

00:31:46.471,00:31:51.510
complicated. I spent way too
much time reading documentation
trying to figure this stuff out.

00:31:51.51-->000:31:57.215
But uh after the first
generation telephone lines um it
kinda split into 2 branches as

00:31:57.215,00:32:02.654
they were going into wireless.
So you have uh GSM, which is
time division multiple access

00:32:02.654,00:32:08.226
based. Um and then you have the
standard Qualcomm came up with.
Which is why they really own a

00:32:08.226,00:32:12.364
lot of the patents running it
which is CDMA. Which is code
division multiple access I

00:32:12.364,00:32:17.602
think. And those kinda split
onto separate branches for like
the next 20 years. Um each

00:32:17.602,00:32:23.942
adding things independently of
each other. Uh then LTE is kind
of a convergence of the 2. Um so

00:32:23.942,00:32:30.549
over on the well on my screen
it’s on the left uh but where
you see GSM and CDMA that’s

00:32:30.549,00:32:35.287
really like second generation.
What you think of as a 2G
cellular network. Um those did

00:32:35.287,00:32:40.692
not originally have any ability
for data. You had no internet.
You couldn’t get your emails. So

00:32:40.692,00:32:46.932
that was kind of hacked on to
enders with the form of EDGE and
GPRS in the case of uh GSM

00:32:46.932,00:32:51.369
networks. So that’s really what
they call 2.5 GE once you start
digging into like the cellular

00:32:51.369,00:32:56.374
forums. Um and then it kinda
kept on proceeding through 3G
and adding more higher speeds uh

00:32:58.743,00:33:03.682
and trying to make things more
efficient, most power hungry um
and then LTE is kinda where

00:33:03.682,00:33:09.654
we’re at now. And they’re
already discussing the fifth
generation network standards. Um

00:33:09.654,00:33:16.194
so just like when you’re looking
at networking on the computer,
you have your OSI or your TCPIP

00:33:16.194,00:33:21.299
model and things are kind of
split up into different layers.
Um cellular stack has that as

00:33:21.299,00:33:26.071
well. Things are broken up into
several different layers and
just like with TCPIP uh the

00:33:26.071,00:33:30.775
higher up you go the more
complicated things are and there
are more bugs. Um think of it

00:33:30.775,00:33:35.580
kinda like layer 2 you have your
ethernet and you can have like
ARFs spoofing and stuff and it’s

00:33:35.58-->000:33:40.418
really confusing computers about
who you are. And you go up to IP
you have more nonsense you can

00:33:40.418,00:33:45.023
play with. The headers and like
IP fragmentation and reassembly
and its more trying to work with

00:33:45.023,00:33:48.793
the actual other end of the
connection as opposed to fooling
them about who you are. Um so

00:33:48.793,00:33:52.864
cellular is pretty much the same
way. You have your physical
layer which in this case it’s

00:33:52.864,00:33:59.271
not over a wire, its over the
air. Um and then as you go up uh
it gets more complicated and

00:33:59.271,00:34:04.376
there’s more things to parse. Um
so up at this top level with
like the NAS layer and your

00:34:04.376,00:34:08.013
internet protocol stuff is a
really good place to hunt for
bugs. Like all your call control

00:34:08.013,00:34:13.652
signaling happens up there. Uh
there’s loads of messages with
like length value and type

00:34:13.652,00:34:17.989
length value associated with
them. Going down a little bit
like radio resource control

00:34:17.989,00:34:20.692
there’s lots of messages in
there but typically they’re a
little bit more fixed length

00:34:20.692,00:34:25.697
when you’re digging through the
standards. Uh so there is a load
of different ways you can

00:34:29.734,00:34:36.207
actually make and receive a
call. Uh 2G, 3G, 2 and a half G
over LTE. Is it a real voice

00:34:36.207,00:34:41.813
call or is it voice over data
call? Um you know voice over LTE
is more common now but kinda any

00:34:41.813,00:34:44.783
any kinda like voice call you
can make over the internet you
can also make over the internet

00:34:44.783,00:34:49.854
on your phone. Um and the
cellular phones typically
support all of these because you

00:34:49.854,00:34:54.759
don’t know where in the country
or what network you’re really
going to be on and you can. Your

00:34:54.759,00:34:57.662
call type can drop as you’re
switching between cells if
you’ve ever been driving and

00:34:57.662,00:35:01.466
your call quality gets bad and
it drops to 2G ‘cause you’ve no
cell coverage. Um so all these

00:35:01.466,00:35:07.372
different ways to do things adds
a lot of complexity. Um and
these aren’t really that simple

00:35:07.372,00:35:11.843
to begin with. Uh there’s a lot
more involved in the setup and
teardown than there is just like

00:35:11.843,00:35:16.848
a TCPIP handshake. Um to be fair
only uh from BTS over to MS is
the actual handset part of this.

00:35:20.518,00:35:26.124
The rest that’s actually more in
the back of the cell network but
it’s still pretty complicated.

00:35:26.124,00:35:31.162
Yes just trying to go through
these. Uh the best place to
start looking for bugs is the

00:35:31.162,00:35:35.000
standards. Uh the don’t specify
any kind of implementation. They
just say what it should look

00:35:35.00-->000:35:40.338
like. Um and it’s totally up to
the vendor and the carrier and
the OEM to work this out. Uh

00:35:40.338,00:35:45.710
3GPP is the organization which
kind of says these are the
standards we’re gonna to deal

00:35:45.71-->000:35:50.048
with. Um and that’s made up of
cell organizations and they all
argue and then eventually agree

00:35:50.048,00:35:54.185
on something. Uh unlike wifi or
bluetooth, these are reely
available, you can just go

00:35:54.185,00:35:58.023
download them which is
fantastic. The reason nobody
does is because they’re like

00:35:58.023,00:36:02.527
8-->0000 pages long and they’re
terrible. Uh but they’re
actually really useful when you

00:36:02.527,00:36:07.632
are looking for bugs. Uh so you
can kinda see it’s specifies
that a packet itself um what

00:36:07.632,00:36:14.105
each octet is in the packet then
it breaks down to like each bit
in that octet. And the part

00:36:14.105,00:36:19.244
you’re assessed interesting
after you think you found a bug
and you’re trying to trigger it.

00:36:19.244,00:36:24.215
The more interesting part to
look at to start is where it
specifies what options you can

00:36:24.215,00:36:29.220
really add. Um s**t um and uh
you so there’s a bunch of
mandatory options as you can see

00:36:32.557,00:36:37.595
and you’re interested in all the
ones which have variable length
uh options basically. LV or TLV

00:36:37.595,00:36:41.099
‘cause there’s a good chance one
of these they screwed up
somewhere along the way. Uh so

00:36:41.099,00:36:47.472
how you actually want to get
started dealing with this. Um
it’s their own custom

00:36:47.472,00:36:53.511
architecture. There is no like
IDA pro does not support this
natively. Uh there are a few

00:36:53.511,00:36:59.784
plugins for IDA pro. Um out of
the 3 of those I find that GSMK
one off of github to be the most

00:36:59.784,00:37:03.455
intuitive to start with at
first. It’s actually been
updated somewhat recently for

00:37:03.455,00:37:08.460
IDA 7. Uh the second one down is
actually python wrapper ran on
the um obs dump patches Qualcomm

00:37:11.663,00:37:16.601
themselves has provided. So
that’s a good place to start for
if you wanna write your own

00:37:16.601,00:37:19.871
disassembler ‘cause they kinda
do some of the hard work of
parcelling the documentation for

00:37:19.871,00:37:25.543
you. I started trying to port
that into binary ninja because
I’ll wanted the um lifting into

00:37:25.543,00:37:29.347
an intermediate language. Uh
that’s still really gross and in
no shape to be released to

00:37:29.347,00:37:36.121
anybody unfortunately. Um so
what do you actually look at on
a device? The radio firmware is

00:37:36.121,00:37:40.291
usually on it’s own separate
partition. Um it varies from
device to device. You’ll have to

00:37:40.291,00:37:44.562
find a way to pull that off. Uh
you’re you might have to route
your phone or or in order to get

00:37:44.562,00:37:48.266
it really varies ‘cause the
entry ecosystem is so
fragmented. Um it’s massive

00:37:48.266,00:37:53.705
binary. Uh this one I just
pulled off of my current phone
and it is 300 megabytes. Um and

00:37:53.705,00:37:59.878
when you load it into IDA it
will find 8-->0000 plus functions
and there’s no uh debugging

00:37:59.878,00:38:04.382
information or anything. Uh
there is a lot of strings which
is useful. Uh especially a lot

00:38:04.382,00:38:08.353
of like debugging information
left in those strings but you
still have 8-->0000 functions to

00:38:08.353,00:38:15.160
dig through with no real good
place to start. Um so I was
trying to cut down on the

00:38:15.16-->000:38:20.365
effort. Um so one of my ideas I
had was if I’m looking for
exploits, I’m going to be

00:38:20.365,00:38:24.569
looking for memory copies and
string copies and I want to find
the memory allocations and the

00:38:24.569,00:38:28.106
deallocations and all that kind
of stuff. All your standard
library functions essentially.

00:38:28.106,00:38:34.746
Um so I was like those should be
called fairly frequently I think
given how often and how many

00:38:34.746,00:38:41.119
different pieces need to parce
things. Um so you could wrote
use IDA python to kind of count

00:38:41.119,00:38:45.790
the number of cross references
to a function. Um but that
doesn’t necessarily give you the

00:38:45.79-->000:38:50.628
best metric because like 1 part
of that graph could be called a
whole bunch of different times.

00:38:50.628,00:38:56.534
But it’s it’s an easy place to
start. Um and these things will
be called 2, 300-->0 4000 times.

00:38:56.534,00:39:01.439
Um so you kinda sort that and
start at the top of the list and
work down. And i found memory

00:39:01.439,00:39:04.175
copies and things like that
pretty quickly and they’re
usually pretty obvious when

00:39:04.175,00:39:09.180
you’re staring at the assembly
code. Uh couple like type copy
loops and stub end. Um so how

00:39:11.449,00:39:18.089
you actually debug this thing is
the problem. Uh even debugging
the android kernel is really

00:39:18.089,00:39:21.459
irritating to do if you’ve ever
tried it when you’re trying to
do it on a device. You have to

00:39:21.459,00:39:26.831
do like a serial over U art
option or over like USB and you
gotta patch it and KGGB is not

00:39:26.831,00:39:32.503
fun to deal with. Um this is
even worse. So Qualcomm has some
internal tools which use that

00:39:32.503,00:39:37.075
diad protocol and talk to it. Uh
we aren’t really supposed to
have those. A few of them have

00:39:37.075,00:39:40.712
been leaked from different
carriers and things like that.
It’s pretty hit or miss in some

00:39:40.712,00:39:46.150
of them don’t work on newer
phones. Um these do support JTAG
although on some phones it’s

00:39:46.15-->000:39:52.890
disabled and uh production
devices. Um but to get that JTAG
uh connection you need to buy it

00:39:52.89-->000:39:56.895
from a company called Lauterbach
and they’re the only ones who
make it. And it’s something like

00:39:56.895,00:40:02.367
north of $1-->0000. Um that was
way out of my budget. Although
I’m sure it works for very well.

00:40:02.367,00:40:07.772
Uh the approach some of the
other um presentations on this
subject have taken is they get

00:40:07.772,00:40:12.677
memory rewrite through an
exploit and then they kinda
build the bugger around that. Um

00:40:12.677,00:40:15.747
that implies you already have
exploit to start with rather
than using a debugger to help

00:40:15.747,00:40:21.119
you poke around. Either one is a
good option. But he way I took
was uh since the modem

00:40:21.119,00:40:26.691
frameworks right here I can just
patch that and try and make it
do what I want. Um the only

00:40:26.691,00:40:31.296
problem with that is they are
signed. So if you make a change
you’ll fail a signature

00:40:31.296,00:40:37.568
verification and nothing
happens. Um on like uh samsung
modems which are encrypted on

00:40:37.568,00:40:41.472
this, Qualcomm doesn’t encrypt
them so it’s easy to disassemble
and patch them but you have to

00:40:41.472,00:40:45.009
get past the signature
verification. Which like I
mentioned earlier with the boot

00:40:45.009,00:40:50.982
order happens in the trust zone.
Um so you need a trust zone bug.
Uh the great thing about base

00:40:50.982,00:40:55.520
bands is that they don’t change
that often because the firmware
has to be recertified so even if

00:40:55.52-->000:40:59.357
you’re looking at a phone which
is a few years old, a lot of it
really hasn’t changed that much

00:40:59.357,00:41:04.195
and at least it’s a place to
start. Um so there’s been trust
zone bugs going back years. Um

00:41:04.195,00:41:10.034
any uh any number of them will
work depends on which phone and
which trust zone version you

00:41:10.034,00:41:15.206
have. Uh but it’s only a 2 byte
change in the trust zone you
patch. Which disables the

00:41:15.206,00:41:20.645
signature checking. So you can
use that as an arbitrary write.
You path up those bytes um and

00:41:20.645,00:41:25.083
then you can load wherever the
hell you want. Uh so it does
require you to have unlocked

00:41:25.083,00:41:31.055
boot loader so that you can
compile your own kernel and
flash that. Um and the modem has

00:41:31.055,00:41:35.993
its own set of internal hashes
for different segments within
it. Um and uh those still do

00:41:35.993,00:41:40.131
need to be consistent but that’s
a little those aren’t
cryptographic in nature, they’re

00:41:40.131,00:41:45.203
just more of an integrity error
kind of check. And you can fix
those up. Us so there’s plenty

00:41:45.203,00:41:49.474
of different CVEs. Uh they’re
all over the place. Some of them
have like full pocks. You don’t

00:41:49.474,00:41:54.812
even need to do that much work
to you turn it into a trust zone
write to disable things with. Um

00:41:54.812,00:41:57.382
so then you actually need to
build a debugger around this.
And we’re running a little short

00:41:57.382,00:42:01.152
on time. Uh but to build a
debugger you basically need to
be able to read and write memory

00:42:01.152,00:42:05.523
just at break points. If you’re
trying to like break on axis 2
piece of data you might need to

00:42:05.523,00:42:08.893
change permissions since you’re
really not supposed to be able
to write to that. Um and same

00:42:08.893,00:42:12.397
register values is kinda useful
too. Um so there’s a few
different ways the baseband

00:42:12.397,00:42:17.268
takes input. Obviously over the
air is the main way. Uh trying
to implement a debugger over the

00:42:17.268,00:42:21.839
radio is not something I wanted
to try. Uh you have that shared
memory interface again and you

00:42:21.839,00:42:26.210
could write a kernel driver to
try and talk to that but you
need something to respond on the

00:42:26.21-->000:42:30.615
other end. And that’s kind of
what that CanSecWest talk did.
They implemented debugging stuff

00:42:30.615,00:42:34.318
on the other end and uh they
kinda talk back and forth and
build up the full feature

00:42:34.318,00:42:39.257
debugger and it. Um I didn’t
really want to take the effort
to do that. Uh and one of the

00:42:39.257,00:42:44.829
other ways you used to talk to a
modem was over serial. Uh for
these um Hayes AT commands is

00:42:44.829,00:42:49.300
how you originally used to
configure something. You could
pass it dialing in connection

00:42:49.30-->000:42:54.939
parameters and say here’s the
number, make a call and it did
it. So we’ve kinda come a long

00:42:54.939,00:42:58.176
way but these modems still
support this and still expose
this. Um the different carriers

00:42:58.176,00:43:01.846
and OEMs and vendors add their
own command extensions to them.
Some of them do really

00:43:01.846,00:43:07.485
ridiculous things. Samsung has
had issues in the past where
there are commands to unlock the

00:43:07.485,00:43:10.855
device so even its past code
locked it if you plug it into
your computer and talk to the

00:43:10.855,00:43:17.562
modem you can like unlock it. Um
so some of those really aren’t
that great. Uh so since I can

00:43:17.562,00:43:23.935
patch the modem firmware and I
can uh patch up the signature
checkings and upload my own, I

00:43:23.935,00:43:28.406
figured this is an already easy
way to talk to the device. I
don’t need to write my own stub

00:43:28.406,00:43:33.244
on the other end. Um and these
already have way too. All the
input output to serials are

00:43:33.244,00:43:38.583
already handled for you because
there’s you know 100 different
AT commands. You all that logic

00:43:38.583,00:43:43.955
is already predeclared for you.
So I can just hook one of those
handlers, patch out what it does

00:43:43.955,00:43:48.426
and replace it with my
functionality. Um so I picked a
couple different Qualcomm

00:43:48.426,00:43:52.897
commands which aren’t really
used frequently. Um I’m not even
sure what some of them do but

00:43:52.897,00:43:58.736
now they do what I want them to
do. Uh so you can just you make
on to read you pass it an

00:43:58.736,00:44:02.907
address, you pass it a size, it
spits stuff back out. Same thing
with writes and if you’ve tried

00:44:02.907,00:44:06.777
to change permissions you can
turn these primitives into a
more featured debugger. That

00:44:06.777,00:44:12.049
actually haven’t worked with a
ton of code on the modem side.
Um and I found about this after

00:44:12.049,00:44:16.354
putting in all this hard work,
is that company Lauterbach
actually makes a simulator for

00:44:16.354,00:44:21.893
hexagon. Um so you can upload a
RAM dump to this simulator and
it will show you the whole

00:44:21.893,00:44:26.898
processor state and you can like
debug it and this actually
really cool. Uh and this

00:44:26.631,00:44:31.435
actually free like most
enterprise software. There’s
like a free trial you can get

00:44:31.435,00:44:35.039
and sure like you’re scripting
abilities are kinda limited but
you kinda work with that without

00:44:35.039,00:44:40.978
having to pay $1-->0000. Um if you
actually want to test stuff uh
you need a license to broadcast

00:44:40.978,00:44:46.350
on cellular frequencies most
places in the world. Um
otherwise like in the in America

00:44:46.35-->000:44:51.622
the FCC gets really mad at you.
Uh so you’re supposed to have
some kind of Faraday cage or do

00:44:51.622,00:44:55.860
it in your concrete basement and
pray they never come knock on
your door. Um and I’ve really

00:44:55.86-->000:45:00.898
lucky in that uh software
defined radios have gotten a lot
cheaper recently and there’s a

00:45:00.898,00:45:05.036
lot of different ones to choose
from. And as it’s long as it’s
full duplex it can transmit and

00:45:05.036,00:45:10.408
receive at the same time, it can
support GSM and uh EDGE and GPRS
and the different things I wanna

00:45:10.408,00:45:16.113
play with. Um I just bought the
BladeRF recently uh because that
was the cheapest and I’m a

00:45:16.113,00:45:21.385
student and I’m poor but uh the
options get way more expensive
after that but the BladeRF works

00:45:21.385,00:45:27.391
great for my purposes, I’ve had
zero complaints. Um it will all
need to do is be full duplex. I

00:45:27.391,00:45:33.664
think the hacker life is cheaper
but is not full duplex, that
won’t work. Um a bunch of

00:45:33.664,00:45:38.803
different open source projects
have come up. Uh YatesBTS,
OpenBTS, the keeps on growing

00:45:38.803,00:45:46.010
every year. Um YatesBTS is the
one I ended up going with as uh
it’s actually really cleanly

00:45:46.01-->000:45:51.182
documented and in the code
comments it’ll say which part of
the standards this came from and

00:45:51.182,00:45:54.919
which table like these options
came from. It was really easy to
cross reference when you’re

00:45:54.919,00:46:00.558
trying to root cause a bug and
trigger it. Um and yeah I think
we’re pretty much outta time but

00:46:00.558,00:46:05.463
I will be hanging around if
anybody has questions for me or
you can hit me up on twitter or

00:46:05.463,00:00:00.000
something. I usually respond
pretty quickly. Um so yeah.
[applause]

