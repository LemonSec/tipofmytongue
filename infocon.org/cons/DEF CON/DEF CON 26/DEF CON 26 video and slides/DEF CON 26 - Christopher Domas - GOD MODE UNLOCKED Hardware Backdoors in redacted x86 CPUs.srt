00:00:00.000,00:00:06.874
>>Good afternoon. Ya’ll enjoying
this conference? C’mon, it’s
Defcon! C’mon! [crowd cheers]

00:00:06.874,00:00:13.513
Yeah! So, Christopher Domas,
he’s uh going to do his talk,
um, he’s going to be running

00:00:13.513,00:00:18.485
completely long, uh he’ll be
using all up all of his time,
he’s kinda asked that if you’ve

00:00:18.485,00:00:26.760
got any questions to do it
off-after the talk, so with
that, go ahead Chris. >>Alright,

00:00:26.760,00:00:31.698
uh, welcome everyone. Uh, we’ll
go ahead and get started. So um,
what I wanted to talk to you

00:00:31.698,00:00:37.004
about today is honestly
something that I didn’t think
was possible, um, but it should

00:00:37.004,00:00:42.109
be pretty interesting, so uh you
know the the word hardware
backdoor gets thrown around a

00:00:42.109,00:00:46.914
lot these days so much that it’s
kinda lost all meaning. Um but
what what I want to look at

00:00:46.914,00:00:50.083
today is not the things that
we’re normally worried about,
it’s not the management engine,

00:00:50.083,00:00:54.554
it’s not the platform security
processor, um this is something
totally different that I think

00:00:54.554,00:00:58.759
wasn’t on anyone’s radar,
something we didn’t really see
coming. Um, but, like any good

00:00:58.759,00:01:02.029
presentation, I think we’ve
gotta start off with a
disclaimer. Uh basically all of

00:01:02.029,00:01:05.766
this research was done on my
own. This is not reflective in
and of my current employer or

00:01:05.766,00:01:10.571
any previous employers. Uh but
with that, my name is
Christopher Domas, I’m a cyber

00:01:10.571,00:01:15.175
security researcher, I’ve tink
uh tinkered with a lot of
different things in the past but

00:01:15.175,00:01:18.679
uh recently the last few years
what I’ve sorta been focused on
is the idea of low level

00:01:18.679,00:01:22.583
processor exploitation and it
turns out there’s a lot of fun
things we can do with that. So

00:01:22.583,00:01:26.687
in order to frame the discussion
for the rest of the day, I wanna
start off with a demo of exactly

00:01:26.687,00:01:35.796
what we’re gonna be talking
about. So, what we have here is,
let’s see if we can pause that,

00:01:35.796,00:01:44.604
uh what we have here, um I’m
logged into the system as a
regular unprivileged user. I’m

00:01:44.604,00:01:51.511
going to open up a very simple C
file, all it does is it loads uh
some values into the EX register

00:01:51.511,00:01:56.416
and then it executes all of
these bound instructions. Now if
you’re not familiar with the X86

00:01:56.416,00:02:00.487
bound instruction, it is a
pretty simple instruction. All
it does is it takes 2 arguments,

00:02:00.487,00:02:04.691
and it checks if your first
argument is within the bounds
provided by the second argument.

00:02:04.691,00:02:08.762
Now if you’ll look carefully at
these bound instructions, what
you’ll see is that they use some

00:02:08.762,00:02:13.567
kind of weird values. Basically
it looks like random values on
the right. What that means is

00:02:13.567,00:02:17.938
that these instructions don’t
actually even have access to the
memory that they’re trying to

00:02:17.938,00:02:21.441
use. Now, in x86 when you don’t
have access to the memory that
you’re trying to use, you get a

00:02:21.441,00:02:25.679
general protection exception. So
every single one of these uh
bound instructions is going to

00:02:25.679,00:02:29.216
throw one of these general
protection exceptions and in
Linux you see that as a

00:02:29.216,00:02:33.153
segfault. Uh, despite knowing
that that’s what’s going to
happen at the end of this

00:02:33.153,00:02:39.459
program, we are going to try to
execute a uh shell. So we’ll
exit out of here and we will uh

00:02:39.459,00:02:44.865
run this um program. We’ll
compile it, uh launch it, and
exactly what we expect to happen

00:02:44.865,00:02:48.168
will happen. We’ll get a
segmentation fault because those
bound instructions don’t have

00:02:48.168,00:02:51.805
access to the memory that
they’re trying to use. And I’m
still the exact same user I was

00:02:51.805,00:02:56.176
before. Still logged in as
delta, but if I make one tiny
change to this program um, I’m

00:02:56.176,00:03:00.580
going to add one X86
instruction. It’s an instruction
that’s so obscure and unheard of

00:03:00.580,00:03:05.018
it it doesn't actually have a
mnemonic associated with it. Um
it is going to have to be

00:03:05.018,00:03:09.723
written in raw machine code.
OF3F. And what this instruction
is going to do is it is going to

00:03:09.723,00:03:14.194
fundamentally change the nature
of all the subsequent bound
instructions so that now instead

00:03:14.194,00:03:18.231
of their original functionality,
instead of checking whether or
not one value is within the

00:03:18.231,00:03:21.902
bounds of another, they’re
actually going to reach into
kernel memory and modify the

00:03:21.902,00:03:27.441
system itself. So I’ll compile
this and re execute it and all
of a sudden we’ll see I am now

00:03:27.441,00:03:39.886
approved. [applause] So. So the
rest of this presentation is
going to be basically a very

00:03:39.886,00:03:45.125
long quick convoluted journey on
to how exactly I stumbled across
this. And the whole thing begins

00:03:45.125,00:03:51.098
with this idea of x86 rings. So
in the beginning in x86 about 30
years ago there was no concept

00:03:51.098,00:03:54.968
of separation of privileges. All
the code running on the
processor executed with the

00:03:54.968,00:03:58.038
exact same privileges as all the
other code running on the
processor and It was basically

00:03:58.038,00:04:03.243
chaos. But then we added the
idea of rings of privilege to
the processor in order to

00:04:03.243,00:04:09.316
separate out permissions. And
the idea behind rings of
privilege was that uh at the

00:04:09.316,00:04:14.054
lowest level we would have ring
0. And that would be the most
privileged realm on the

00:04:14.054,00:04:17.724
processor where the kernel would
live. The only really trusted
code would execute in ring 0 and

00:04:17.724,00:04:21.328
it would have complete access to
the hardware. Little less
privileged than that was ring 1.

00:04:21.328,00:04:25.532
Less than that was ring 2 and
then way out here on the
outermost ring is ring 3. That’s

00:04:25.532,00:04:28.869
where the user code lives.
Basically all the code that we
don’t trust um to have access to

00:04:28.869,00:04:33.173
the hardware is going to execute
way out here. So uh this was the
fundamental idea behind

00:04:33.173,00:04:37.477
privileges on x86 where ring 3
if it wanted to do anything
interesting it would have to go

00:04:37.477,00:04:42.516
through very specific carefully
checked hardware privilege
access mechanisms in order to

00:04:42.516,00:04:47.854
ask ring 0 to do something for
it. And all of our other
security on x86 is all based off

00:04:47.854,00:04:52.859
of this fundamental premise of
separation of rings. And things
got kind of interesting. People

00:04:52.859,00:04:56.296
starting digging deeper. We
found out uh we needed things
more privileged than ring 0,

00:04:56.296,00:05:00.367
like the hypervisor had to have
more access than the kernel
normally would so we kinda

00:05:00.367,00:05:04.004
called that ring minus 1. Um we
found out that somethings had to
be more privileged and that

00:05:04.004,00:05:07.440
system management mode we called
ring minus 2. A couple years ago
some researchers found another

00:05:07.440,00:05:12.846
core uh off the x86 core um that
they called ring minus 3 because
it could do things that the x86

00:05:12.846,00:05:17.784
core couldn’t do. So things were
uh were interesting. But if
you’ve been following any of

00:05:17.784,00:05:22.289
this research, in the back of
everyone's mind is the question
can- can we go further? Are

00:05:22.289,00:05:27.994
there are there even more layers
to this um to this puzzle? So uh
I started setting off to sorta

00:05:27.994,00:05:32.799
uh explore that idea and uh a
lot of times when I’m starting
out on new research I find an

00:05:32.799,00:05:37.204
interesting place to begin is
with patents. Sometimes you can
find some really interesting

00:05:37.204,00:05:41.608
information that people don’t
document in public uh uh
information. But you might be

00:05:41.608,00:05:46.513
able to find some some bits of
useful ideas inside of patents.
So uh keeping this whole idea of

00:05:46.513,00:05:50.817
this ring model of privileges in
mind, imagine my surprise when I
was reading through a patent and

00:05:50.817,00:05:56.056
I saw just sort of nonchalantly
buried in the middle uh this
quote “Additionally, accessing

00:05:56.056,00:05:59.426
some of the internal control
registers can enable the user to
bypass security mechanisms, for

00:05:59.426,00:06:04.931
example allowing ring 0 access
at ring 3.” That’s a little bit
alarming from a security

00:06:04.931,00:06:10.237
perspective. You’re telling me
like we’ve had 30 years of
relying on rings to provide our

00:06:10.237,00:06:15.775
privileges on x86 and there's
just some way to circumvent all
of this? So they go on to say

00:06:15.775,00:06:18.845
that in addition, these control
registers might reveal
information that the processor

00:06:18.845,00:06:22.782
designers wish to keep
proprietary and for these
reasons, the various x86

00:06:22.782,00:06:27.254
processors manufacturers have
not publicly documented any
description of the address or

00:06:27.254,00:06:32.626
function of some of these
control MSRs. So this, this was
really interesting. I was really

00:06:32.626,00:06:36.429
really excited about this and
wanted to run with this idea. So
like any rational person, I went

00:06:36.429,00:06:41.801
off and bought 57 computers to
start doing some basic research
on. [applause][laughter] So I

00:06:41.801,00:06:46.406
had uh uh based on the patent
timeframe and the patent owner,
I had some some idea of what

00:06:46.406,00:06:52.145
processor I might specifically
want to focus on for this
research. Uh parents are kinda a

00:06:52.145,00:06:55.882
funny thing. IT gets bought and
sold by different companies and
ideas trickle through the

00:06:55.882,00:07:00.186
industry. Um so I sorta wanted
to cast a wide net and look at a
lot of different systems for

00:07:00.186,00:07:05.358
this research but what I
eventually settled on uh was the
VIA C3 processor. So these are

00:07:05.358,00:07:09.596
interesting processors sort of
targeted at meta low powered
market. You can find these often

00:07:09.596,00:07:14.834
at point of sale systems,
kiosks, ATMs, gaming since we’re
in Vegas you might want to start

00:07:14.834,00:07:20.006
poking around, digital signage,
healthcare digital media, uh
industrial automation, and

00:07:20.006,00:07:24.944
they’re in PCs and laptops as
well. So I pulled off my shelf
this specific system eventually.

00:07:24.944,00:07:31.051
Uh it’s a thin client running a
C3 Nehemiah Core and this is
what we’re going to look at for

00:07:31.051,00:07:34.321
the rest of the presentation and
at the end of the presentation
I’ll look a little bit more at

00:07:34.321,00:07:39.092
what other um processors might
be affected by this issue but
this is sorta the target of this

00:07:39.092,00:07:44.731
specific research. So I wasn’t
able to find a developer manual
for this processor. So um when

00:07:44.731,00:07:49.469
we’re sorta left in the dark. A
good place to go is to sorta
follow a trail of patent

00:07:49.469,00:07:52.772
breadcrumbs see what information
we can derive from patents and
see if there’s anything useful

00:07:52.772,00:07:58.912
in there that can give us hints
as to how we should move our
research forward. So um so I had

00:07:58.912,00:08:04.918
to dive through a lot of patent
literature and I wanted to give
a little glimpse into what it’s

00:08:04.918,00:08:09.656
like. So this isn’t actually a
quote from the patents that I
ended up- uhh the patents that I

00:08:09.656,00:08:14.561
ended up using, but it is
something I stumbled across
during this this research. So uh

00:08:14.561,00:08:19.833
this this quote says uh “Figure
3 shows an embodiment of a cache
memory. Referring to figure 3 in

00:08:19.833,00:08:24.804
one embodiment, cache memory 320
is a multi-way cache memory. In
one embodiment, cache memory 320

00:08:24.804,00:08:28.475
comprises multiple physical
sections. In one embodiment,
cache memory 320 is logically

00:08:28.475,00:08:33.113
divided into multiple section.
In one embodiment, cache memory
320 includes four cache ways ie

00:08:33.113,00:08:37.517
cache way 310, cache way 311,
cache way 312, and cache way
314. In one embodiment, a

00:08:37.517,00:08:42.522
processor sequesters one or more
cache ways to store or to
execute processor microcode.”

00:08:42.522,00:08:48.061
Like, my head is exploded when I
read stuff like this. It’s so so
convoluted and so uh wrapped up

00:08:48.061,00:08:53.233
in legalese it’s it’s hard to
understand what the heck you’re
even reading. And just to put

00:08:53.233,00:08:57.804
that in perspective, this one
four page patent contained the
phrase in one embodiment 147

00:08:57.804,00:09:04.711
times. So following this um just
to start your research when you
want to dive into things is a

00:09:04.711,00:09:08.782
really really painful process
but um if you’re persistent it
can pay off. So I eventually

00:09:08.782,00:09:13.753
settled on these um six
different patents that seemed to
have some basic ideas that could

00:09:13.753,00:09:19.292
point me into the right
direction uh for this research.
So I want to highlight some of

00:09:19.292,00:09:23.897
the key ideas uh that I that I
got out of those 6 patents. So
one is that it sorta looked like

00:09:23.897,00:09:29.903
at the time Via was embedding a
non-x86 core alongside the x86
cores in their C3 processors and

00:09:29.903,00:09:34.340
this non-x86 core was a RISC
architecture. And the patents
didn’t have a consistent

00:09:34.340,00:09:38.011
terminology for this but I just
sorta started calling this the
“Deeply Embedded Core” or the

00:09:38.011,00:09:43.616
DEC on these uh on these
processors. They also talked
about something that they called

00:09:43.616,00:09:47.287
the global configuration
register. It’s basically a
register that’s exposed to the

00:09:47.287,00:09:52.058
x86 core through a model
specific register. And they said
that this global fixation

00:09:52.058,00:09:57.497
register can accur er can
activate the RISC core. They
also talked about an x86 launch

00:09:57.497,00:10:04.137
instruction. It was basically a
new instruction that they added
to the x86 ISA where um once the

00:10:04.137,00:10:08.942
RISC core is activated, you can
start a RISC instruction
sequence through the launch

00:10:08.942,00:10:14.280
instruction according to the
patents. So um kinda putting all
these ideas together, what it

00:10:14.280,00:10:19.519
what it looked like is if our
assumptions about what this
deeply embedded core can do are

00:10:19.519,00:10:25.024
correct, you could essentially
use this as a sort of backdoor,
uh a means of surreptitiously

00:10:25.024,00:10:30.763
circumventing all of the
processor security checks. So
that's absolutely an idea worth

00:10:30.763,00:10:36.169
exploring more for security
processes. So um there’s sorta 3
patents that give us some

00:10:36.169,00:10:41.541
initial ideas on-on how the
overall mechanisms might work.
So one patent tells us that a

00:10:41.541,00:10:45.445
model specific register can be
used to circumvent processor
security checks. Another patent

00:10:45.445,00:10:50.750
tells us that a model specific
register can be used to activate
a new x86 instruction. And

00:10:50.750,00:10:56.289
another patent tells us a launch
instruction can be used to
switch to a RISC instruction

00:10:56.289,00:11:01.094
sequence. So if we sort of put
those three things together, and
try to fill in the gaps, we end

00:11:01.094,00:11:05.064
up with a sequence that looks
something like this. Um, we have
to find a model specific

00:11:05.064,00:11:10.670
register bit that when toggled
will activate a new x86
instruction that didn't

00:11:10.670,00:11:14.974
previously exist, and running
that instruction will activate a
RISC core on the processor and

00:11:14.974,00:11:21.681
that core should be able to
bypass the processor’s security
protections. So um so where do

00:11:21.681,00:11:24.884
we begin? Well let's look at the
very first step in that chain,
these model-specific-registers.

00:11:24.884,00:11:29.556
So if you’re not familiar with
the idea of MSRs in x86, they
are basically 64 bit control

00:11:29.556,00:11:33.593
registers used for a wide wide
variety of things um they’re
used for debugging, performance

00:11:33.593,00:11:37.797
monitoring, cache configuration,
feature configuration, basically
anything that doesn’t have to do

00:11:37.797,00:11:42.902
with general computing can get
tossed into the MSRs. And unlike
the x86 registers you might be

00:11:42.902,00:11:46.706
more familiar with um, they
aren’t accessed by name, they’re
accessed by address. So instead

00:11:46.706,00:11:51.811
of EAX and EDX, we have
addresses from zero to 4 billion
is how we access our MSRs. So

00:11:51.811,00:11:56.716
basically you load up an address
into the ECX register and then
execute the read MSR or the

00:11:56.716,00:12:02.021
write MSR instructions in order
to access an MSR. Now there’s
some saving grace here. Uh we

00:12:02.021,00:12:06.859
think that maybe we can use this
to circumvent the ring
predictions on the processor but

00:12:06.859,00:12:12.065
these MSRs are only um
accessible to begin with with
ring 0 code. So maybe the rest

00:12:12.065,00:12:17.236
of this stuff we can do from
ring 3, but in order to activate
that bit to begin with, we need

00:12:17.236,00:12:22.709
ring 0 execution. So um so that
that’s good news, although
may-maybe we don’t need ring 0

00:12:22.709,00:12:26.879
execution. I’m going to revisit
this idea later in the talk but
so that we can move the I

00:12:26.879,00:12:31.417
research forward, let’s assume
for now that we have one time
ring 0 access on that processor

00:12:31.417,00:12:37.056
just to enable this backdoor
feature um and and we’ll
th-revisit uh that concept

00:12:37.056,00:12:41.027
later. So so let’s look at these
model-specific registers some
more. Well the patents basically

00:12:41.027,00:12:44.297
comes right out and tells us
that “the various x86 processor
manufactershave not publicly

00:12:44.297,00:12:49.369
documented any description of
the address or function of some
control MSRs.” So that’s uh a

00:12:49.369,00:12:55.141
challenge for us, um, I-I think
there’s a bit on one of these
MSRs that might activate

00:12:55.141,00:13:00.380
something cool but it’s probably
not going to be documented. So
step one um in order to try to

00:13:00.380,00:13:04.851
explore this idea is to try to
figure out which MSRs are
actually um implemented by the

00:13:04.851,00:13:09.489
processor regardless of what the
documentation says which MSRS
are actually there. So this one

00:13:09.489,00:13:13.760
is pretty easy to solve. Um
basically you can set the
general purpose uh exception

00:13:13.760,00:13:18.197
handler on the processor to
point to some handler un-under
your control. Um you can do that

00:13:18.197,00:13:22.502
with the LIDQ instruction. Uh
then you can load up an MSR
address that you want to check.

00:13:22.502,00:13:26.706
Let’s say you want to figure out
if MSR number 1137 exist on my
processor. Well load that number

00:13:26.706,00:13:31.978
into the ECX register and then
execute the uh read MSR
instruction. Now if you don’t

00:13:31.978,00:13:36.816
get a fault from that read MSR
instruction, you know that that
MSR exists. If you do get a

00:13:36.816,00:13:41.387
fault, if your handler gets
control, you know that MSR
doesn’t exist. So this is a

00:13:41.387,00:13:44.757
really easy way to figure out
exactly which MSRs actually
exist on your processor

00:13:44.757,00:13:50.063
regardless of what documentation
says. So when you do this on the
Via C3, um you end up with an

00:13:50.063,00:13:53.900
alarming number of MSRs, way
more than would normally be on
an x86 processor. We find 1300

00:13:53.900,00:13:58.805
implemented MSRs on that
processor, which is far too many
to analyze. I think one of these

00:13:58.805,00:14:03.810
is going to activate a new x86
instruction that’s too many to
go through by hand. So step 2 is

00:14:03.810,00:14:07.947
sort of figuring out which MSRs
here are actually interesting.
Which one should I be exploring

00:14:07.947,00:14:12.919
for uh this research. So I I
came up with this idea of a
sorta a timing side-channel

00:14:12.919,00:14:17.757
attack against the MSRs uh where
basically what I would do is I
would calculate how long it took

00:14:17.757,00:14:23.129
to access each of the 4 billion
possible MSRs. And what that
looks like is you’ve got this

00:14:23.129,00:14:29.435
read MSR instruction and then on
uh on either side of that you’ve
got a serialized read time stamp

00:14:29.435,00:14:33.473
counter instruction. That lets
you see exactly how long it took
your read MSR to execute, and

00:14:33.473,00:14:37.810
that shows you how long it took
to access the uh the MSR. So if
you run this code it looks

00:14:37.810,00:14:42.949
something like this, where on
the X axis I’ve got the MSR
numbers and on the Y axis I've

00:14:42.949,00:14:47.920
got the access time for that
MSR. Green is MSRs that are
implemented on a processor, red

00:14:47.920,00:14:52.024
is MSRs that are not implemented
on the processors. So this this
side-channel attack actually

00:14:52.024,00:14:55.795
gives you some really really
interesting insights into how
the processor works under the

00:14:55.795,00:15:00.299
hood that we normally would
never have access to. But what
we can do with this then is sort

00:15:00.299,00:15:04.070
of form a a hypothesis. I’m
going to theorize that this
global configuration register,

00:15:04.070,00:15:08.941
this really powerful register
that the patents talked about
um, is probably unique. There’s

00:15:08.941,00:15:13.279
probably not several similar
versions of this register um
within the MSRs. There’s

00:15:13.279,00:15:17.984
probably exactly one of these on
that processor. So what I can
start to do is I can start to

00:15:17.984,00:15:24.924
look for MSRs with unique access
times. So um like these that are
circled in uh red and when we

00:15:24.924,00:15:28.461
actually start to do that what
we find is that there are
relatively few MSRs that are

00:15:28.461,00:15:34.233
unique on this processor. In
fact, out of the 1300 MSRs that
are there um, we identified 43

00:15:34.233,00:15:39.238
that actually seem um
interesting and worth exploring
more. So that’s that’s good,

00:15:39.238,00:15:42.441
that seems like we’re making
process, I’ve sort of whittled
down the number of MSRs from

00:15:42.441,00:15:47.213
initially 4 billion down to 43
to actually explore in this
research. Um but it’s still a

00:15:47.213,00:15:54.487
lot to tackle by hand. That’s
2752 bits worth of MSRs to uh to
check. Now my theory is that one

00:15:54.487,00:15:59.358
of these bits is going to
activate a new x86 instruction
so I want to figure out um when

00:15:59.358,00:16:04.897
I toggle these bits did a new
instruction appear on the
architecture. Um well x86 is a

00:16:04.897,00:16:08.668
really really complicated
instruction set and its sorta
hard to estimate how many

00:16:08.668,00:16:12.905
instructions could actually be
in x86 but a rough upper bounds
would be somewhere on the order

00:16:12.905,00:16:17.376
of 1 point 3 undecillion
possible instructions. So I
wanna figure out did one of

00:16:17.376,00:16:21.480
these MSR bit create a new
instruction but I’ve got to
search through 1 point 3

00:16:21.480,00:16:25.151
undecillion instructions in
order to find that new
instruction, if it appeared at

00:16:25.151,00:16:30.590
all. So um even taking a really
optimistic estimate, if we could
scan through a billion possible

00:16:30.590,00:16:35.394
x86 instructions every second
you can do some quick Fermi
calculations in order to see 1

00:16:35.394,00:16:40.099
point 3 undecillion divided by 1
billion divided by 60 seconds a
minute divided by 60 minutes an

00:16:40.099,00:16:44.604
hour divided by 24 hours a day
divided by 365 days a year means
it’s going to take about an

00:16:44.604,00:16:49.642
eternity to scan that entire
instruction set. [audience
laughter] So um so tha’s that’s

00:16:49.642,00:16:54.814
not reasonable. Making things
worse, that’s that’s for one
scan. You have to scan each of

00:16:54.814,00:16:59.886
these 2752 bits that’s about
2752 eternities in order to find
which bit creates a new

00:16:59.886,00:17:05.124
instruction. So fortunately um
there’s a better solution. I
actually released this tool last

00:17:05.124,00:17:09.996
year called sandsifter which was
was kinda neat it found uh uh a
smart way of searching through

00:17:09.996,00:17:14.567
the x86 instruction set using uh
page fault analysis and
depth-first search algorithm in

00:17:14.567,00:17:19.772
order to scan all of that x86
for the most probable
instruction in about a day. And

00:17:19.772,00:17:24.310
it can be used to find things
like undocumented instructions
or new instructions appearing.

00:17:24.310,00:17:29.782
But it still can’t be run 2752
times if it takes a day to scan
a single bit. So what we can do

00:17:29.782,00:17:38.291
instead is we can try to toggle
each of those 2752 candidate MSR
bits one by one um but these are

00:17:38.291,00:17:41.894
configurations that these
control the inner workings of
the processor and I have no idea

00:17:41.894,00:17:46.299
what these bits actually do. So
a lot of them are going to lock
the processor or freeze it or

00:17:46.299,00:17:51.437
panic the kernel or reset the
system entirely, so trying to
toggle 2 thousand some bits one

00:17:51.437,00:17:58.878
by one can’t be a manual
process. We need some sort of
automation to make this work. So

00:17:58.878,00:18:03.849
the system I came up with looks
something like this where uh we
would have a target um that’s a

00:18:03.849,00:18:08.754
C3 processor uh hooked up to a
relay basically uh uh wire would
be soldered on to the power

00:18:08.754,00:18:13.025
switch on the target and then
that’s hooked up to a relay the
relays hooked up to a master

00:18:13.025,00:18:18.264
system so the master can power
cycle the target through the
relay. Um the target also

00:18:18.264,00:18:22.668
network boots uh through a
switch from the master. And the
master then can SSH into the

00:18:22.668,00:18:27.907
target. What the master can tell
the target is uh toggle this MSR
bit and the master is going to

00:18:27.907,00:18:31.243
check did something become
disabled, did the system stop
responding, did the kernel

00:18:31.243,00:18:35.448
panic, uh if not, it’s going to
try to toggle the next MSR bit.
If so it’s going to power cycle

00:18:35.448,00:18:41.954
the target. This way the master
can sorta repeatedly go through
and identify exactly which of

00:18:41.954,00:18:46.025
those 2752 MSR bits can be
identified with the target
becoming unstable. So over the

00:18:46.025,00:18:50.930
course of about a week through
hundreds of automated reboots
we’re able to identify exactly

00:18:50.930,00:18:57.436
which bits we can actually turn
on on that processor. So um
after that what we do is we try

00:18:57.436,00:19:01.540
to turn on all the bits we
possibly can and get all those
bits on at once and only then do

00:19:01.540,00:19:07.079
we run sandsifter, only then do
we scan the processor for new
instructions so that looks

00:19:07.079,00:19:11.617
something like this using
sandsifter for this purpose. So
uh like I said sandsifter uses

00:19:11.617,00:19:18.324
uh page fault analysis and
depth-first search in order to
uh search through the x86ISA and

00:19:18.324,00:19:24.797
we’re watching sandsifter sorta
in the middle of a scan probably
about 12 or 15 hours into a scan

00:19:24.797,00:19:29.201
and what you can see it doing is
generating machine code in order
to search through the feasible

00:19:29.201,00:19:34.040
x86 instructions on this
processor. And if you let
sandsifter run for long enough,

00:19:34.040,00:19:39.045
eventually it will spit out
something new in that lower
window there and uh sandsifter

00:19:39.045,00:19:46.252
after about a day finds exactly
one new instruction on that
architecture. OF3F. So this must

00:19:46.252,00:19:50.389
be the launch instruction that
the patents are talking about.
The new instruction that got

00:19:50.389,00:19:54.693
activated by these MSR bits. So
through GDB and through some
trial and error, I was able to

00:19:54.693,00:19:59.965
figure out that the launch
instruction was basically a jump
EAX instruction. So um from that

00:19:59.965,00:20:03.402
we can figure out what the
global configuration register
is. Now I activated all of these

00:20:03.402,00:20:07.273
possible MSR bits to find the
possible launch instruction so
now I’m curious to find out

00:20:07.273,00:20:11.644
which bit was really responsible
for activating that launch
instruction. Fortunately now

00:20:11.644,00:20:15.981
that I’ve identified the OF3F
instruction I no longer need to
run sandsifter uh for additional

00:20:15.981,00:20:20.286
scans. What I can do is activate
each of those MSR bits one by
one and after activating one

00:20:20.286,00:20:25.357
I’ll try to execute the launch
instruction. If it doesn’t work
then that’s the wrong bit. If

00:20:25.357,00:20:29.061
suddenly launch instruction
appears on the architecture,
then that means I found the bit

00:20:29.061,00:20:33.833
that activated the launch
instruction. So uh using that
approach we were able to find

00:20:33.833,00:20:39.405
out that MSR 1107 was actually
the MSR that enabled the launch
instructions and specifically it

00:20:39.405,00:20:46.445
was bit 0 inside MSR 1107. Now I
suspect that this is going to
open the door for uh another uh

00:20:46.445,00:20:51.684
architecture on the processor
which will let me bypass those
ring protections once and for

00:20:51.684,00:20:55.855
all and circumvent all of the
processor’s security checks. So
because of how much power that

00:20:55.855,00:21:02.795
single bit has just potentially
enabled, I started calling bit 0
of MSR 1107 the god bit. So um

00:21:02.795,00:21:08.868
at this point we’ve figured out
the god mode bit, we’ve figured
out this this hidden launch

00:21:08.868,00:21:14.940
instruction in this x86 ISA. The
next question is how do I
actually execute instructions on

00:21:14.940,00:21:21.881
this x86 or on this uh this new
RISC core that we’ve enabled? So
we can sort of dive into patents

00:21:21.881,00:21:24.450
to try to figure this out and
the patents sort of uh hint at
this idea that instructions are

00:21:24.450,00:21:29.221
fetched out of memory and then
um passed to different decoders
depending on whether you’re in

00:21:29.221,00:21:33.859
x86 or RISC mode. And I had to
go through a lot of trial and
error to figure out exactly what

00:21:33.859,00:21:38.631
that might look like under the
hood. But this is sort of what I
ended up with. Essentially uh uh

00:21:38.631,00:21:44.236
an instruction will be fetched
from an instruction hatch and it
will be passed to some sort of

00:21:44.236,00:21:49.475
pre x86 decocer and that decoder
is going to break apart the
components of an x86

00:21:49.475,00:21:52.878
instructions and then those
components are going to be
passed to a check and that check

00:21:52.878,00:21:58.250
is going to determine am I in
risk mode or not. Namely has
that launch instruction just

00:21:58.250,00:22:03.255
been executed. If the answer is
no, then those components are
all passed on to a further x86

00:22:03.255,00:22:08.194
decoder and the instruction
executes as x86. If the answer
is yes, one of the components of

00:22:08.194,00:22:12.698
that instruction, 32 bit
constant value, will be torn out
and passed over to the RISC

00:22:12.698,00:22:18.571
decoder in order to execute as a
RISC instruction. So um
basically with this setup there

00:22:18.571,00:22:24.877
needs to be some x86 instruction
where if the processor is in
RISC mode it can pass a portion

00:22:24.877,00:22:31.050
of itself over to the RISC
processor on this chip and since
this instruction, whatever it

00:22:31.050,00:22:37.590
is, sort of joins the x-x86 and
RISC cores I call it a bridge
instruction. Basically it gives

00:22:37.590,00:22:42.061
a way to feed instructions over
to the RISC core. So the next
question now is how do we find

00:22:42.061,00:22:47.399
this um unknown x86 bridge
instruction that will let me
execute RISC instructions. Um

00:22:47.399,00:22:52.905
it’s it’s not easy but it should
be sufficient just to determine
that a RISC instruction has been

00:22:52.905,00:22:58.877
executed. SO um how how can we
detect that a RISC instruction
has been executed given that I

00:22:58.877,00:23:02.481
have no idea what these
instruction can actually do or
what their execution will look

00:23:02.481,00:23:08.420
like. Well an easy way will be
if our theory is right, if this
RISC core really can circumvent

00:23:08.420,00:23:12.658
processor security checks, then
there should be some RISC
instruction, I don’t know what,

00:23:12.658,00:23:17.329
but some RISC instruction, even
when executed in ring 3, should
be able to corrupt the system.

00:23:17.329,00:23:22.868
And corruption is pretty easy to
detect, that should look like a
processor lock or a kernel panic

00:23:22.868,00:23:28.574
or a system reset. Uh basically
if I observe any of those
behaviors, that means that x86

00:23:28.574,00:23:35.381
executed one of these mysterious
RISC instructions because none
of those things should ever

00:23:35.381,00:23:39.885
happen executed x86 instructions
normally. So um I sort of tore
apart sandsifter in order to

00:23:39.885,00:23:42.755
help me with this. I ripped out
the core of sandsifter and
changed it to run in a

00:23:42.755,00:23:45.991
root-forage mode um so its still
executing x86 instructions but
before each x86 instruction that

00:23:45.991,00:23:51.497
it generates it’s going to
execute the launch instruction
in order to switch to RISC mode.

00:23:51.497,00:23:55.868
And what it’s trying to find is
some x86 instruction that
corrupted the system and that’s

00:23:55.868,00:24:00.372
actually what we just saw here.
We saw the processor lock when
the uh uh sandsifter hit the

00:24:00.372,00:24:06.011
right combination of x86 and
RISC instructions. So once we
observe that processor lock that

00:24:06.011,00:24:09.982
means that we found this bridge
instruction, this x86
instruction that can execute

00:24:09.982,00:24:13.585
RISC instruction. So it takes
about an hour of fuzzing to get
here, we just saw a short

00:24:13.585,00:24:19.491
snippet, but it turns out that
this bound EAX instruction is
this bridge instruction. It’s

00:24:19.491,00:24:24.129
what's going to let me feed
instructions over to the RISC
core. And specifically this

00:24:24.129,00:24:28.233
32-bit constant value used in
the bound instruction appears to
be the RISC instructions that

00:24:28.233,00:24:32.771
get execute executed on the
deeply embedded core and that’s
a pretty easy thing to check.

00:24:32.771,00:24:37.042
Basically I can see that for
some specific 32-bit values the
processor locks every single

00:24:37.042,00:24:41.780
time and for other 32-bit values
nothing seems to happen very
very consistently. So now e

00:24:41.780,00:24:46.752
found the bridge instruction. I
know how to send instructions
over to that deeply embedded

00:24:46.752,00:24:51.890
core. So the next question is
what do we want to execute on
this alternate instruction set,

00:24:51.890,00:24:59.531
what do these instructions even
look like? What architecture am
I even dealing with? So uh uh

00:24:59.531,00:25:03.936
ideally moving forward I would
just assume that this other
architecture is probably some

00:25:03.936,00:25:08.807
known common architecture, it’s
probably something like ARM or
PowerPC or MIPS. It doesn't make

00:25:08.807,00:25:12.144
a whole lot of sense to invent
an architecture from scratch. So
we could assume that this other

00:25:12.144,00:25:16.315
architecture is some common
architecture and I could try to
execute a common architecture’s

00:25:16.315,00:25:20.352
instructions on this uh this
other core. So for example if I
thought maybe I’m dealing with

00:25:20.352,00:25:26.992
ARM I might try to execute an
add one to R0 um instruction.
The problem um or what I

00:25:26.992,00:25:32.331
encountered was that for some of
these very very simple RISC
instructions I was generating

00:25:32.331,00:25:38.003
the processor would lock. So if
I generate an instruction like
um like add one to R0 and I try

00:25:38.003,00:25:42.007
to execute that on this RISC
core and the processor locks,
that probably means I’m not

00:25:42.007,00:25:45.344
dealing with the architecture I
thought I was dealing with and
probably not dealing with ARM if

00:25:45.344,00:25:49.715
that instruction, that simple
instruction, locked everything
up. So I was actually able to

00:25:49.715,00:25:54.019
rule out 30 different common
architectures this way and I
still think most likely this

00:25:54.019,00:26:00.025
other architecture, this RISC
core that we’re dealing with, is
probably uh derived from some

00:26:00.025,00:26:03.362
common architecture but it
seemed like it was maybe
modified enough that I couldn’t

00:26:03.362,00:26:07.866
identify it so that sorta forced
me to move forward. Assuming
this thing was a black box,

00:26:07.866,00:26:11.870
basically treating it as some
totally unknown architecture
that we’ve never seen before.

00:26:11.870,00:26:17.543
That means we have to reverse
engineer the format of these
instructions for this deeply

00:26:17.543,00:26:20.946
embedded core and I spent
probably the bulk of this
research actually trying to

00:26:20.946,00:26:25.684
reverse engineer the format of
these instructions and so I
started calling those the

00:26:25.684,00:26:29.688
deeping embedded instruction set
or the DEIS. So the question is
how we begin reverse engineering

00:26:29.688,00:26:34.126
a total unknown instruction set.
Ideally what I would do is I
would execute one of these RISC

00:26:34.126,00:26:38.430
instructions and observe its
results. The challenge though is
that I have absolutely no

00:26:38.430,00:26:43.135
knowledge of this instruction
set architecture that I’m
dealing with um and I probably

00:26:43.135,00:26:47.639
can’t observe the results on the
RISC core. So for example if I
did generate an instruction like

00:26:47.639,00:26:53.745
add 1 to R0 but I can uh only
view [mumbles] the question is
then how do I view R0 from my

00:26:53.745,00:26:59.284
x86 core? How do I even detect
that I made any changes to the
RISC core? Fortunately uh

00:26:59.284,00:27:04.156
there’s an approach for this the
patents actually suggest that
these 2 cores share a register

00:27:04.156,00:27:09.995
file, at least partially share a
registry file which means that I
may not be able to view all of

00:27:09.995,00:27:14.099
the um effects of my RISC
instruction but I should be able
to view some of the effects of

00:27:14.099,00:27:18.136
the RISC instruction from the
x86 core. So so for example the
patents show an example where an

00:27:18.136,00:27:22.307
ARM and x86 core share some of
their registers. That means from
the x86 core I can actually see

00:27:22.307,00:27:29.014
some of the effects of these
instructions. So what this would
look like then is I can generate

00:27:29.014,00:27:33.085
an initial state for the
processor. I’m going to generate
a bunch of values for the

00:27:33.085,00:27:37.523
processor registers maybe random
values, maybe set all those
registers to be pointers to

00:27:37.523,00:27:40.726
various buffers, and I’m gonna
record that information. I’m
going to generate some buffers

00:27:40.726,00:27:45.197
in userland memory and then in
kernel memory I’m gonna record
those buffers. Basically record

00:27:45.197,00:27:49.535
all the information I can about
the system state. Then what I’m
going to do is I’m going to

00:27:49.535,00:27:54.439
execute that launch instruction,
that OF3F instruction, in order
to toggle the RISC core. After

00:27:54.439,00:27:59.845
that I'll execute the uh bridge
instruction, the bound EAX
instruction, that lets me send a

00:27:59.845,00:28:04.016
RISC instruction over ot the
RISC core, and I’m going to
generate an arbitrary RISC

00:28:04.016,00:28:08.186
instruction to try out. After
that instruction executes, I'll
record the results of the

00:28:08.186,00:28:12.157
systems state, I’ll record all
the registers and the buffers
and everything else and what I

00:28:12.157,00:28:15.661
want to see is did something
change in the system, did that
input state and output state

00:28:15.661,00:28:21.533
differ uh in any way. Um
unfortunately we run into even
more challenges here. I’m

00:28:21.533,00:28:26.104
dealing here with a totally
unknown instruction set that
probably has unfettered access

00:28:26.104,00:28:30.709
to ring 0 so it is really really
easy to accidentally generate
instructions that cause kernel

00:28:30.709,00:28:36.014
panics or processor locks or
complete system reboots. Um and
in practice I could only

00:28:36.014,00:28:41.887
generare about 20 RISC
instructions before the system
became unrecoverably corrupted,

00:28:41.887,00:28:46.758
before I had to reboot the
system and start over. So even
after optimization, it took

00:28:46.758,00:28:51.396
about 2 minutes for one of these
systems to boot so some more
rough approximations kinda

00:28:51.396,00:28:56.034
indicated it was going to take
months and months of fuzzing in
order to gather enough data in

00:28:56.034,00:29:00.539
order to reverse engineer this
instruction set so I expanded my
initial set up. Instead of

00:29:00.539,00:29:05.377
fuzzing one target system, I
bought as many systems as I
could on ebay, turned out to be

00:29:05.377,00:29:09.481
7 of these sin clients, and I
hooked them all up. And if you
look carefully at this what

00:29:09.481,00:29:13.485
you'll see is each of these
systems has a little green wire
coming out of the chastity. That

00:29:13.485,00:29:18.090
wire is soldered onto the
system’s power switch. All of
those wires go to a relay

00:29:18.090,00:29:21.460
module. That relay module is
hooked up to a master system
over USB. All of these systems

00:29:21.460,00:29:26.365
boot over the network from the
master system. So the master
system can boot up these systems

00:29:26.365,00:29:31.737
um can SSH into them and assign
each of them fuzzing tasks for
this RISC architecture. It can

00:29:31.737,00:29:37.242
then record all the results of
those fuzzing tasks for off
client analysis. And when it

00:29:37.242,00:29:41.546
detects that one of these
systems has become corrupted,
when it stops responding or the

00:29:41.546,00:29:46.618
kernel panics, the master can
use those relays in order to
reboot the target so we can

00:29:46.618,00:29:53.425
actually see an example of this
in action. So um what I’m going
to do it I’m going to tell the

00:29:53.425,00:30:00.365
master to start uh start a
fuzzing task. It’s going to
think a little bit as it

00:30:00.365,00:30:04.603
generates uh as it generates
tasks for the uh targets and as
you listen to the relays you can

00:30:04.603,00:30:08.473
hear each relay clicking on you
can see the relay lights and if
you look closely at the target

00:30:08.473,00:30:11.643
systems you can see the green
LEDs on them coming one one by
one as each of those systems

00:30:11.643,00:30:16.114
boots up. So I think for
brevity’s sake I’m going to cut
this video a little bit short

00:30:16.114,00:30:20.652
but if you’d like to see a full
demo afterwards you can grab me
but in about a minute when these

00:30:20.652,00:30:25.824
systems come online we’ll be
able to see the targets start
targeting them with fuzzing jobs

00:30:25.824,00:30:30.829
and we’ll be able to see logs
start coming into the target and
eventually the target will be

00:30:30.829,00:30:33.532
able to detect that some of
these systems have frozen and it
will bring them offline via the

00:30:33.532,00:30:38.136
relay so this process can
continue. Uh so this was this
was slow fuzzing work um fairly

00:30:38.136,00:30:43.875
laborious. Um I let this system
run for about 3 weeks. I
gathered about 15 gigabytes of

00:30:43.875,00:30:48.980
logs across 2 point 3 million
different state diffs for about
4,000 total hours of compute

00:30:48.980,00:30:54.386
time. But um it was really
exciting after I had the final
results. We can start sifting

00:30:54.386,00:30:58.924
through these logs in order to
find something interesting.
Basically I’m curious, can I

00:30:58.924,00:31:04.463
actually do anything um to ring
0 from ring 3 according to these
logs? And it turns out we can,

00:31:04.463,00:31:10.502
we can pretty quickly start to
find some things that shouldn’t
exist in a secure world. So for

00:31:10.502,00:31:15.674
example the instruction A7719563
uh if you look at that EDX
register um I was able to read

00:31:15.674,00:31:21.613
control register 0 into the EDX
register. Uh control register 0
is supposed to only be

00:31:21.613,00:31:26.618
accessible by ring 0 but we just
read it from ring 3 using one of
these RISC instructions. And

00:31:26.618,00:31:33.191
we’re not limited to reading
ring 0 data. If we look here
instruction 8AB4 was actually

00:31:33.191,00:31:39.664
able to write debug register 0
you’ll see that the EBP register
got written to DR0. DR0 should

00:31:39.664,00:31:43.802
only be accessible to ring 0.
We’re circumventing the ring
protections through this RISC

00:31:43.802,00:31:48.573
core. So at this point it’s
kinda time to start thinking
about a payload, what we should

00:31:48.573,00:31:53.612
actually be having the uh uh
RISC core do for us and really
once you can reach through the

00:31:53.612,00:31:58.150
ring boundaries the sky’s the
limit you can do whatever you
want. But I thought it could be

00:31:58.150,00:32:01.353
useful to have some sort of easy
to demonstrate payload. So I
thought a good demonstration

00:32:01.353,00:32:04.756
simply would be elevating the
current process to root
permissions so um that would

00:32:04.756,00:32:08.894
look something like uh grabbing
a structure called the global
descriptor table, parsing out a

00:32:08.894,00:32:13.698
field on the GDT, um called the
FS segment, that FS register can
actually point you to a register

00:32:13.698,00:32:18.703
in kernel memory called the task
structure, and if you grab a
certain field from the task

00:32:18.703,00:32:23.141
structure you can get a point to
what’s called the cred structure
and from there you can actually

00:32:23.141,00:32:27.379
set yourself to have root
permissions as long as you can
reach directly into kernel

00:32:27.379,00:32:32.184
memory and grab and modify all
this information. Now there’s
only a few pieces here, the

00:32:32.184,00:32:35.921
parts highlighted in red, that
require us to cross ring
boundaries, things like addition

00:32:35.921,00:32:41.326
and bit manipulation we can
technically do that on the x86
core we don’t need this RISC

00:32:41.326,00:32:47.465
core to do this for us. But it
was uh kinda fun to have this uh
unknown core execute these

00:32:47.465,00:32:51.436
instructions uh so I thought
it’d be a little bit more
impactful if I wrote this entire

00:32:51.436,00:32:56.241
payload for the deeply embedded
core and never used the x86. So
I’ve got 15 gigabytes of logs, I

00:32:56.241,00:32:59.978
want to try to build this
payload, so it’s time to start
sifting through those logs

00:32:59.978,00:33:04.449
trying to find some primitives
to use and this sorta feels like
building a rock chain. Um you’ve

00:33:04.449,00:33:08.753
got this you’ve got these tiny
little pieces of functionality.
You have an overall idea of what

00:33:08.753,00:33:13.191
you’re trying to accomplish and
you’re trying to figure out how
to piece together those tiny

00:33:13.191,00:33:17.262
little pieces in order to form
your final payload. So so we can
start finding those little

00:33:17.262,00:33:23.134
pieces that we need. So for
example 8331 or uh 8313 was an
instruction that was able to

00:33:23.134,00:33:27.572
read the global descriptor table
well that’s the first piece of
our payload. Um I’m able to find

00:33:27.572,00:33:33.311
a kernel read instruction inside
of those logs, D407, uh you’ll
notice a low byte of EBP got

00:33:33.311,00:33:38.984
read out of a kernel memory
buffer. Um I can actually modify
kernel memory uh E2B7 was able

00:33:38.984,00:33:44.155
to write a single byte into
kernel memory. Now this is
really promising. If I can write

00:33:44.155,00:33:47.425
a byte into kernel memory, it
means I can do precision
exploitation through the deeply

00:33:47.425,00:33:52.297
embedded core. But um at the end
I sorta decided sifting through
logs like this by hand doesn’t

00:33:52.297,00:33:56.968
scale. I want to be able to
write more robust payloads for
this deeply embedded core so I

00:33:56.968,00:34:02.540
wanted some sort of automated
approach for doing this. So I uh
what I wanted was some way to

00:34:02.540,00:34:07.479
extract the behavior patterns
from the state diffs in order to
identify the bit patterns inside

00:34:07.479,00:34:11.149
of these instructions. So I
built a tool called the
colectro. So the collector

00:34:11.149,00:34:15.654
basically helped us to do
automated reverse engineering of
completely unknown instruction

00:34:15.654,00:34:22.560
sets. So the way the collector
worked is it would basically
look at the state diffs recorded

00:34:22.560,00:34:25.764
by the fuzzer and it would try
to identify some basic
operations, like loading

00:34:25.764,00:34:36.207
immediate values into registers,
like transferring one register
to another. Uh, there we go. Um

00:34:36.207,00:34:41.646
like reading memory, like
modifying memory, uh like uh
shifting registers, any number

00:34:41.646,00:34:46.184
of eremetic and bitwise
instructions. Uh uh the
collector would try to identify

00:34:46.184,00:34:50.622
those just by looking at
differences in the input state
and output state between RISC

00:34:50.622,00:34:54.859
instructions. Uh then what it
would do is bin instructions
based on what effects it saw

00:34:54.859,00:34:58.697
those instructions having. So it
might spit out well here’s a bin
of instructions that all

00:34:58.697,00:35:04.369
exhibited this property of
transferring one register to
another. And after it had these

00:35:04.369,00:35:08.740
instruction bins, what it would
look for was patterns within the
bins. So for example one of the

00:35:08.740,00:35:12.377
first things we might want to
figure out is how are the
register values used for each of

00:35:12.377,00:35:15.914
these instructions encoded
inside of the instruction. So
for example where is EAX encoded

00:35:15.914,00:35:19.918
in this instruction. So it would
look for each of these
instructions which bits might

00:35:19.918,00:35:24.623
represent EAX which might
represent EDX so that’s what I
have highlighted in purple

00:35:24.623,00:35:29.127
basically for each individual
instruction which bits might be
coding the registers that the

00:35:29.127,00:35:35.133
collector saw being used by that
instruction. So then what the
collector does is it tries to

00:35:35.133,00:35:38.803
identify patterns across the
entire bin. So it can see then
that these 2 middle columns are

00:35:38.803,00:35:43.675
the only constant piece of this
pattern. In other words these 2
middle columns must be thing

00:35:43.675,00:35:49.180
that uh records or encodes the
input and output registers for
these instructions. So we do

00:35:49.180,00:35:53.318
that for all sorts of different
facets for an instruction
encoding it can try to figure

00:35:53.318,00:35:58.156
out which bits are used to
encode the outcode of the
instruction. And it’s not a

00:35:58.156,00:36:01.760
perfect process. Ideally we
would see totally consistent
patterns across the entire bin,

00:36:01.760,00:36:07.432
that’s not what we see here. But
what colletor will do is it will
try to pick the things that are

00:36:07.432,00:36:11.136
most common. In other words in
this situation it will say well
these are the most likely bits

00:36:11.136,00:36:14.806
that will encode your outcodes.
It can even try to find things
like don’t care bits in the

00:36:14.806,00:36:19.411
instructions or bits that seem
to follow some sort of uh
statistical patterns uh but we

00:36:19.411,00:36:23.882
can’t necessarily tell uh what
they are and then it’ll mash up
all this information together in

00:36:23.882,00:36:29.788
order to sort of automatically
derive the bitwising coding of
each um possible instruction on

00:36:29.788,00:36:34.225
this um deeply embedded core. So
looking at the bins that it
creates and what sort of

00:36:34.225,00:36:40.698
functionality we might want to
get out of the deeply embedded
instruction set, these are sort

00:36:40.698,00:36:44.335
of the coding that it came up to
uh came up with for a variety of
different instructions. So we’ve

00:36:44.335,00:36:48.206
got instructions to move
registers around and load the
global descriptor table. Um

00:36:48.206,00:36:52.510
basically we have a primitive
assembly language now uh so that
we can write payloads for this

00:36:52.510,00:36:58.349
for this deeply embedded core.
So um so we could now that we
now that we known the

00:36:58.349,00:37:02.987
instruction coding we could
write some payloads by hand if
we wanted but I thought it’d be

00:37:02.987,00:37:06.725
cooler if I wrote an actual
assembler for these things so
that I could I could write some

00:37:06.725,00:37:12.831
of these uh programs that uh at
a higher level uh um so uh
[laughs]. So basically I wrote

00:37:12.831,00:37:16.234
this DEIS assembler, custom
assembler, just for this unknown
instruction set that will

00:37:16.234,00:37:20.839
assemble these different
primitives into their raw binary
representation and then wrap

00:37:20.839,00:37:25.310
them into one of these x86
bridge instructions so that the
DEIS instruction can be sent

00:37:25.310,00:37:31.549
over to the deeply embedded core
for instruction. Um so now we’re
ready to revisit that uh payload

00:37:31.549,00:37:35.920
idea that we had. We can use the
LGD description in order to root
out the global descriptor table.

00:37:35.920,00:37:41.259
We can use some of our other
DEIS instructions in order to uh
parse that descriptor field in

00:37:41.259,00:37:45.563
order to grab a pointer to the
task structure in order to grab
a pointer to the cred structure

00:37:45.563,00:37:50.335
in order to write to the cred
structure, circumventing the
ring protections, modifying

00:37:50.335,00:37:55.206
kernel memory in order to give
ourselves root level access on
this system all using nothing

00:37:55.206,00:38:03.414
but instructions specifically
for this uh unknown architecture
embedded alongside our x86 core.

00:38:03.414,00:38:08.253
So um the output of this after
you run it through the assembler
looks something like this,

00:38:08.253,00:38:14.392
basically we will activate that
deeply embedded core with the
launch instruction that’s on the

00:38:14.392,00:38:18.897
left then we execute all these
bound instructions. Each of
these bound instructions sends a

00:38:18.897,00:38:22.333
single instruction over to the
deeply embedded core for
execution by the RISC processor

00:38:22.333,00:38:26.638
uh these instructions are going
to circumvent the processor’s
security mechanisms in order to

00:38:26.638,00:38:31.009
grant the current processor root
permissions then we launch a
shell. So let’s revisit that

00:38:31.009,00:38:36.314
demonstration from the uh the
beginning and uh walk through
that in a little bit more depth.

00:38:36.314,00:38:41.252
So here we have our complete
payload doing uh the the steps
that we just talked about. Um we

00:38:41.252,00:38:45.790
load the address of the payload
into the EAX register and then
we execute this launch

00:38:45.790,00:38:50.962
instruction uh on the C3
processor. After that we’ve got
our actual payload um all of

00:38:50.962,00:38:56.568
these bound instructions, the
x86 instructions, that are able
to communicate with the RISC

00:38:56.568,00:39:01.673
core. Each bound instruction
sends a single uh RISC
instruction over to the deeply

00:39:01.673,00:39:12.050
embedded core and at the very
end of of this sequence we uh
launch a shell in order to

00:39:12.050,00:39:16.988
hopefully gain root permissions.
So if we exit out of here and
run this program we’ll compile

00:39:16.988,00:39:22.961
it first. We’ll double check
exactly who we are again, so we
are just a regular unprivileged

00:39:22.961,00:39:28.900
user but when we run the program
um we use that deeply embedded
core in order to gain root

00:39:28.900,00:39:43.982
permission so it sends [audience
applause and cheers] S-so um so
I want to toss this out here

00:39:43.982,00:39:48.453
only sort of tongue in cheek, um
researchers have sort of
explored down to what we are

00:39:48.453,00:39:53.691
calling ring -3 but I want to
pitch this as sort of a ring -4.
It is in some ways more powerful

00:39:53.691,00:39:58.997
in our previously known ring -3.
It is sort of a core located
within the x86 core, it has

00:39:58.997,00:40:03.268
unrestricted access to the x86
registry file unlike ring -3.
And unlike ring-3, it shares a

00:40:03.268,00:40:08.106
lot of its execution pipeline
with the x86 core which sort of
give sit more power than the

00:40:08.106,00:40:12.710
ring 03 but at the same time
everything is just sort of
nebulous. When we’re this deep

00:40:12.710,00:40:16.614
the whole ring model is
completely broken down and this
is sort of nonsensical anymore.

00:40:16.614,00:40:23.454
But the the point is um we are
now um gotten direct ring 3 to
ring 0 hardware privilege

00:40:23.454,00:40:28.826
escalation on x86. That has
never actually been accomplished
before, everything else where

00:40:28.826,00:40:34.799
we’ve come close has had to rely
on coding the operating system
or other bugs to uh sort of work

00:40:34.799,00:40:39.470
as a launching point. This is a
purely hardware approach for
accomplishing this. So the

00:40:39.470,00:40:44.542
th-the good news is that
fortunately we needed ring 0
access. Everything else in this

00:40:44.542,00:40:50.548
payload happens in ring 3, but
we have to activate um that
backdoor using one time ring 0

00:40:50.548,00:40:56.654
access to set the god mode bit,
um, at least in theory uh but I
wanted to poke around with this

00:40:56.654,00:41:01.326
a bit more. So here we’re
looking at a different system,
um, it’s another system I had

00:41:01.326,00:41:07.865
sitting on my on my shelf here.
So this is a Via C3 processor
but it’s a Samuel 2 core instead

00:41:07.865,00:41:12.270
of the Nehemia core that I was
using. What we just saw was the
system cleanly boot, um this is

00:41:12.270,00:41:16.007
a freshly booted operating
system totally unmodified and
i’m going to log in as a regular

00:41:16.007,00:41:22.280
unprivileged user. Um, not the
fastest processors, but once we
get to a uh prompt, what I’m

00:41:22.280,00:41:28.786
going to do is insert the MSR
kernel module, um, in order to
gain access to the MSRs. So you

00:41:28.786,00:41:34.025
notice I’m sudo here but I’m not
writing anything. I’m only using
this to read things out to show

00:41:34.025,00:41:36.894
you. I dont have the read MSR
tool installed on herek, we’re
just going to use the hexton

00:41:36.894,00:41:39.997
tool here in order to dump out
that global configuration
register . MSR number 1107, so

00:41:39.997,00:41:45.470
low bit of that register was the
god mode bit, if you look at
that low byte what you see is

00:41:45.470,00:41:52.777
11010111 the low bit there, the
god mode bit, is on by default
when the system boots. That

00:41:52.777,00:41:58.583
means on the samuel 2 core any
unprivileged code that knows
what it’s doing can uh escalate

00:41:58.583,00:42:04.622
to kernel level privileges at
any time. And when you totally
break down x86 ring uh

00:42:04.622,00:42:10.194
protection and privileges like
this all of our other uh
protections fall like dominos.

00:42:10.194,00:42:16.000
Like anti virus does nothing
when you can just reach directly
into ring 0. Uh ASOR data don’t

00:42:16.000,00:42:20.171
help you anymore when you can
just circumvent the ring
privilege model. Code signing,

00:42:20.171,00:42:24.375
control flex integrity, kernel
integrity checks, none of this
helps once rings mean nothing.

00:42:24.375,00:42:28.579
Um but there are mitigations,
none of them are great, but
there are opportunities here.

00:42:28.579,00:42:32.917
One is we could update the
processor microcode in order to
lock down the god mode bit, just

00:42:32.917,00:42:37.255
don’t let people set the god
mode bit to begin with. We could
update the microcode in order to

00:42:37.255,00:42:41.325
disable any ucode assists on the
bridge code instruction so that
you couldn't send instructions

00:42:41.325,00:42:44.962
over to that RISC core. You
could update the operating
system and firmware in order to

00:42:44.962,00:42:49.867
disable the god mode bit using
bits and then periodically make
sure that bit has stayed off,

00:42:49.867,00:42:55.106
that nobody has enabled the back
door. But uh then again the
point is kinda moot. This is an

00:42:55.106,00:42:59.911
older processor, it’s not in
widespread use, and I don’t
really wanna throw Via under the

00:42:59.911,00:43:08.853
bus here. Um I think their
target market is embedded and I
think this was probably a useful

00:43:08.853,00:43:11.923
feature for their customers, it
was just a very flawed
implementation in some of their

00:43:11.923,00:43:14.992
earlier iterations of their
processor. So um so instead
let’s take this as a case study.

00:43:14.992,00:43:20.231
The reality is that backdoors do
exist, it’s not just conspiracy
theory stuff, but they don’t

00:43:20.231,00:43:26.437
have to remain invisible. We do
have the techniques necessary in
order to find these. So um sorta

00:43:26.437,00:43:30.942
looking forward um even though
this is not a common processor I
do think this is a big deal.

00:43:30.942,00:43:36.080
This is not just a big deal for
C3, this is not just a big deal
for x86, I think this is a big

00:43:36.080,00:43:41.219
problem for all of computer
engineering in general because
this hardware that we’re using

00:43:41.219,00:43:45.223
to protect all of our secrets,
do all of our computation, we
have no way to introspect it, so

00:43:45.223,00:43:51.395
whether or not backdoors are
real in a general sense, um, is
is sort of irrelevant. That

00:43:51.395,00:43:56.634
question is going to haunt us as
long as we can’t introspect our
own hardware. So I-I hope that’s

00:43:56.634,00:44:01.506
what people will take out of
this. I hope when you see
something that seems off limits,

00:44:01.506,00:44:05.009
when you see these weird hints
in patents because the patents
that I saw were just the tip of

00:44:05.009,00:44:07.578
the iceberg in some of the weird
stuff that I saw that's out
there. I hope that people will

00:44:07.578,00:44:11.782
dive in deep and uh really seek
what’s under the hood uh because
because that’s how security

00:44:11.782,00:44:16.721
works, that’s how we build trust
in uh these uh systems, so uh
sort of uh along those lines

00:44:16.721,00:44:21.025
I’ve open sourced all of the
research that I used for this,
all the tools, techniques, all

00:44:21.025,00:44:24.996
the code and data I’ve
demonstrated today are uh freely
available so I hope that will

00:44:24.996,00:44:29.167
people use those to scan their
own systems. I hope people will
use this as a starting point for

00:44:29.167,00:44:34.572
much much deeper processor
security research. Um and along
those lines I want to quickly

00:44:34.572,00:44:39.577
throw out this other idea that I
didn't have time to cover in any
depth during this presentation.

00:44:39.577,00:44:46.150
But uh I uh I demonstrated this
this side channel of tech on
MSRs and I actually found some

00:44:46.150,00:44:49.820
really cool uses for this
tootally outside of what we just
looked at now and found some um

00:44:49.820,00:44:54.625
um kinda unsettling results on
the number of processors so
that’s a topic for another

00:44:54.625,00:44:59.497
presentation. I’ll be talking
about this tool, project
nightshyft specifically um

00:44:59.497,00:45:03.634
tomorrow at Defcon if you’re
around and uh I’ll sort of show
some of the totally different

00:45:03.634,00:45:07.004
things I found using this
approach so I hope you’ll check
that out if you have time. Um

00:45:07.004,00:45:12.476
but in the meantime um all this
stuff is available on my github
that’s github.com slash

00:45:12.476,00:45:18.983
xoreaxeaxeax uh this project I’m
calling project rosenbridge all
the backdoor research is there.

00:45:18.983,00:45:22.620
Um sandsifter, that processor
fuzzer that I used heavily
throughout this is also

00:45:22.620,00:45:26.357
available there. I wrote a
single instruction C compiler a
few years back, I’ve uh written

00:45:26.357,00:45:31.429
some cool control flow stuff,
there’s a uh system management
mode that exploits on there, and

00:45:31.429,00:45:34.899
a lot of other fun stuff I’ve
just tinkered with over the last
few years. It’s all available

00:45:34.899,00:45:37.902
there so I hope you’ll check it
out. What I’d really love is
some feedback and ideas on these

00:45:37.902,00:45:43.274
uh on these topics so uh if you
wanted to reach out either after
this presentation I’ll just be

00:45:43.274,00:45:49.513
next to the stage or you can
ping me at xoreaxeaxeax on
twitter or same thing at gmail

00:45:49.513,00:45:53.718
dot com if you have any feedback
or anything else you’d like to
discuss about this. So uh thank

00:45:53.718,00:00:00.000
you everyone for coming and
that’s it. [audience applause]

