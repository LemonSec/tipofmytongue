00:00:00.033-->00:00:06.840
>>Hello, welcome to track 1 - 2
o’clock talk, um, hope you’ve
learned something new about SMB.

00:00:06.840-->00:00:11.845
This is William Martin
[applause]. >>Hey guys. So, uh,
as introduced my name is William

00:00:18.785-->00:00:22.856
Martin. Uh, for anyone who saw
me yesterday it’s going to look
pretty familiar. I’m OSCP, I’m a

00:00:22.856-->00:00:27.394
penetration tester based out of
Charlotte, North Carolina. Uh,
I’m a supervisor at RSM US LLP

00:00:27.394-->00:00:33.433
and this is my second time
presenting at DefCon. Uh, first
time was yesterday, so

00:00:33.433-->00:00:36.737
[laughter]. Lesson learned from
yesterday is that if you’ve got
any questions about this talk,

00:00:36.737-->00:00:40.574
want me to clarify or expand or
get in contact with me take a
note of the Twitter handle right

00:00:40.574-->00:00:46.413
now, that’s the best way you’re
going to be able to reach me. So
it’s QuickBreach. Anyways. So,

00:00:46.413-->00:00:49.783
before we get started I want to
make sure all the right people
are in the room. Um, we’re going

00:00:49.783-->00:00:53.854
to be talking about SMB and SMB
based man-in-the middle attacks
and for red teamers this is

00:00:53.854-->00:00:57.357
useful for, you know, add a new
kind of attack to your toolset
and, uh, learn - add new

00:00:57.357-->00:01:00.894
technique to your arsenal. And
for blue teamers you want to
know how to stop the red teamers

00:01:00.894-->00:01:05.799
from using what they learn
today. Um, and for like, the 3
guys curious about SMB, it’s

00:01:05.799-->00:01:10.804
also for you [applause]. That
guy right there. Thank you. So,
first things first. I want to

00:01:13.307-->00:01:18.578
clarify some, uh, terminology.
When I mention SMB server do not
think of like a server 2012 or

00:01:18.578-->00:01:23.583
like 2008. It is any windows PC,
um, connected to - publicly
connected to a domain. Every

00:01:23.583-->00:01:28.021
windows PC runs an SMB server by
default but when you’re on a
domain typically that port’s

00:01:28.021-->00:01:31.858
opened up so that anyone can
talk to it. So, when I say SMB
server on client it can be a

00:01:31.858-->00:01:36.863
windows 7 to windows 7, 2012 to
7, 2012 to 2012, uh, there is no
connotation tied to the actual

00:01:40.100-->00:01:46.239
operating system. So, what is
SMB? In a nutshell it’s a way
to, you know, access files

00:01:46.239-->00:01:51.311
remotely as Microsoft solution
for, uh, network based file
sharing and file management. Um,

00:01:51.311-->00:01:57.551
you can read and write files to
it, you can authenticate to it,
you can map network drives, uh,

00:01:57.551-->00:02:02.255
and you can actually, uh, access
some, you know, RPC pipes over
it as you know, hackers love,

00:02:02.255-->00:02:08.795
like, you know, through PSExec
and what not. What I want to
clarify is that through this

00:02:08.795-->00:02:14.401
talk I’m going to be talking
about SMB 1 and SMB versions 2
and versions 3. Now, back when

00:02:14.401-->00:02:20.374
vista was released Microsoft
pretty much did an entire rework
of the SMB protocol. Originally

00:02:20.374-->00:02:25.812
it was based on an IBM system
and that’s like what we call NT
LM and Microsoft uses NT LM

00:02:25.812-->00:02:30.017
everywhere so the name’s always
get mixed up. But, SMB version 1
is what we are typically

00:02:30.017-->00:02:36.423
familiar with for like, you
know, MS17-010 and things like
that. SMB version 2 and 3 is an

00:02:36.423-->00:02:40.627
entire rework of the SMB
protocol and within that there
are different versions. They are

00:02:40.627-->00:02:46.500
called dialects so 2 point 0
point 2 is the first version of
SMB 2 3 and they you’ve got 2 1

00:02:46.500-->00:02:53.306
and they got 3 0 and then 3 0 2
and etcetera. So, a typical
exchange in SMB looks like this.

00:02:53.306-->00:02:59.546
Someone says, hey, what’s in
this folder? And SMB will reply,
you’ve got documents, desktop

00:02:59.546-->00:03:04.184
and, you know, some not password
file. So, we love our
pass-the-hash, we love it for

00:03:04.184-->00:03:08.989
system enumeration and we love
it for spidering shares and
hunting for sensitive data. So,

00:03:08.989-->00:03:12.159
it’s like, you know, the
cpassword vulnerability and
SYSVOL. And, obviously for

00:03:12.159-->00:03:17.164
MS17-01 [laughter]. Now, the
premise of the talk and the -
the origin of this talk is SMB

00:03:24.104-->00:03:29.476
signing. Particular how it
defeats my absolute favorite
attack. Um, my favorite attack

00:03:29.476-->00:03:34.114
is the NTLM relay attack
especially against SMB servers.
Um, if anyone uses - has used

00:03:34.114-->00:03:40.854
impacket it’s an NTLM relay step
py tool, you know, it that is.
In a nutshell the attack works

00:03:40.854-->00:03:46.026
like this. A victim says, hey,
where is my network share? An
attacker says, hey, I’m that -

00:03:46.026-->00:03:52.199
totally that network share.
Victim says, cool, let me log
in. We then relay that to some

00:03:52.199-->00:03:57.571
random server we pick and say
hey, let me log in as this dude.
Server says, yeah, that’s cool.

00:03:57.571-->00:04:03.577
Just hash your password with
this challenge. We sent that
back to the victim. They comply.

00:04:03.577-->00:04:08.181
We forward that on to the
server. Server lets us log in
and then we - we kick the

00:04:08.181-->00:04:14.121
victim; we ghost them. And once
we have that connection we can
enumerate the system, we can

00:04:14.121-->00:04:17.891
execute commands, we can dump
it, that’s - that’s now our box
if that person’s a local admin.

00:04:17.891-->00:04:22.896
Now, the thing that sucks about
this attack is if anyone’s run
this you might have seen this.

00:04:25.198-->00:04:30.570
Signature is required. Now, I
have a bit of confusion. I just
manipulated the entire

00:04:30.570-->00:04:35.208
authentication process for this
victim yet they have somehow
established a secret or trust

00:04:35.208-->00:04:39.746
between each other, uh,
unbeknownst to me. So I didn’t
know how - how could they have

00:04:39.746-->00:04:43.517
done that? Where - was there
some kind of, like, public key,
you know, certificate kind of

00:04:43.517-->00:04:48.522
thing going on? Um, I - I had no
idea. So, when I looked up what
is SMB signing I got vague

00:04:52.592-->00:04:59.332
descriptions and you’ve ever run
a nessus scan I guarantee you’ve
seen this [laughter]. So,

00:04:59.332-->00:05:04.304
naturally, like most of you, I
Google it and I got answers
like, it stops man in the middle

00:05:04.304-->00:05:11.044
attacks. Stops man in the middle
attacks. Trust us, it stops man
in the middle attacks. Um, it’s

00:05:11.044-->00:05:16.917
Microsoft’s solution to stop man
in the middle attacks
[laughter]. That’s about it.

00:05:16.917-->00:05:22.355
That’s all the information I
could find. So, I knew that it
protects the integrity of SMB

00:05:22.355-->00:05:26.793
messages because if we edit it
after signing is enabled we get
screwed. Uh, it’s required by

00:05:26.793-->00:05:32.966
default on DCs. It occurs only
after the authenticated process
and it stops my favorite attack

00:05:32.966-->00:05:37.971
which is, kind of like, a dick
move. So [laughter] I dove into
the M - MSDN docs and this was

00:05:40.874-->00:05:47.714
supposed to be a gift but, you
know, whatever. And I saw things
like this. And I saw things like

00:05:47.714-->00:05:52.719
that for a while. Quite a while.
But eventually I found the
answer to what SMB signing

00:05:55.055-->00:05:59.993
actually is and we’re going to
dive into that. At the end of
the authentication phase both

00:06:02.329-->00:06:08.001
the client and the server will
share the same session based
key, it’s just a 16 byte value.

00:06:08.001-->00:06:13.006
They then use that value to
generate other keys to then sign
the messages. Now, the goal of

00:06:15.041-->00:06:19.679
what we are about to cover is
where does that key come from?
And how can we comprise it? By

00:06:19.679-->00:06:24.684
the way, that’s what a signature
looks like for anyone who hasn’t
used wire - wireshark on a DC.

00:06:29.055-->00:06:34.060
So, the session based key
actually depends on what
authentication mechanism is

00:06:36.563-->00:06:41.568
used. So, let’s talk through
NTLMv2; also my favorite type of
a - authentication. There are 3

00:06:44.304-->00:06:50.310
messages in NTLMv2; there’s a
negotiate, a challenge and an
authentication. So, negotiate

00:06:50.310-->00:06:54.514
just says, hey, I want to log
in. And they send some, uh,
empty parameters like you can

00:06:54.514-->00:06:58.551
see in this capture, there is no
user name, there’s no
workstation, there’s no domain

00:06:58.551-->00:07:03.556
name. It just says, I want to
initiate this conversation. One
flag that can be in this message

00:07:03.556-->00:07:07.927
is called the negotiate key
exchange flag. And we’re going
to get into that later but in a

00:07:07.927-->00:07:12.565
nutshell what that means is that
once both the client and the
server establish that shared

00:07:12.565-->00:07:17.737
session based key they’re going
to change it again. Um, but
that’s what that flag means,

00:07:17.737-->00:07:23.310
we’ll get to that. The challenge
says cool, alright hash your
password with this data and then

00:07:23.310-->00:07:27.380
send it back to us. And this
contains the, uh, server
challenge information, server

00:07:27.380-->00:07:32.085
information like the host name,
the domain name, the DNS name,
stuff like that. The

00:07:32.085-->00:07:36.790
authentication message contains
a lot of stuff. Uh, the
username, the domain, the client

00:07:36.790-->00:07:43.396
challenge, the NtProofString, in
a nutshell, is the hash
generated by the client. Um, a

00:07:43.396-->00:07:47.567
bunch of responseserverversions,
um, things that are plain text
that we don’t particularly care

00:07:47.567-->00:07:53.239
about. Um, and encrypted new
sessesionbasekey. The - if you
look in this message you’ll see

00:07:53.239-->00:07:59.279
there is a session key value of
like, b4852 whatever, um, that
only exists there if the

00:07:59.279-->00:08:04.551
negotiation key exchange flag
was set earlier. Um, that is the
encrypted version of the new,

00:08:04.551-->00:08:09.089
uh, session based key but if
they didn’t negotiate that that
value is going to be empty and

00:08:09.089-->00:08:14.060
they’re just going to proceed
with the keys they generated on
their own. So, I thought that

00:08:14.060-->00:08:19.065
was very technical, but, let’s
get down to how the keys are
actually generated. In - we need

00:08:21.968-->00:08:27.440
to know what HMACs and CMACs are
before we can get into that. In
a nutshell they are message

00:08:27.440-->00:08:31.544
authenticating, uh,
authentication code algorithms.
Um, you can think of them, if

00:08:31.544-->00:08:34.981
you’re familiar with password
salting, you can think of them
like a salt. Where you have a

00:08:34.981-->00:08:39.185
message and you’re going to hash
that message but while you’re
hashing it you’re going to

00:08:39.185-->00:08:43.256
include a secret value that only
knows that secret value can
throw in that hashing algorithm

00:08:43.256-->00:08:49.129
to create the same hash. So, an
HMAC or a CMAC, the underlying
protocol might - might vary,

00:08:49.129-->00:08:54.667
some use AES, some use, like,
SHA256 um, but, in a nutshell
their goal is to hash the

00:08:54.667-->00:09:00.774
message in additional to, like,
some secret information. So,
let’s actually walk through

00:09:00.774-->00:09:05.779
generating those session based
keys. So, step 1 is we need the
NTResponse; that is the user’s

00:09:08.281-->00:09:13.286
NT hash. So, it goes from plain
text, you know, NT hash. Step 2,
we take all of the information

00:09:17.257-->00:09:22.162
from the, uh, the server
challenge and we put that
together and we use the HMAC

00:09:22.162-->00:09:28.735
algorithm with the password,
with that has password from the
NT hash. And we have our

00:09:28.735-->00:09:34.040
sessionbasekey which is the
NTResponse, hashed again - again
you’re - you’re password hash,

00:09:34.040-->00:09:40.814
hashed again in addition to all
of this server information that
you already hash. All together

00:09:40.814-->00:09:47.220
it looks like that. They key
takeaway though is the
highlighted information is the

00:09:47.220-->00:09:53.493
only information we don’t have
at this exchange. To generate
the keys that protect all SMB

00:09:53.493-->00:09:59.199
sessions we just need the user’s
password. Which is great,
because they are always secure;

00:09:59.199-->00:10:05.538
we can never crack them. That
was my response when I found out
that the - the key concept

00:10:05.538-->00:10:10.276
protecting all these connections
was just their password. I mean,
think about if TLS was protected

00:10:10.276-->00:10:16.216
not by some random long string
generated throughout the uh,
connection established phase but

00:10:16.216-->00:10:22.889
to set like, the dude’s password
on - on the website it’s
connected to. So, the key logic

00:10:22.889-->00:10:27.894
works like this. You got the
password, it gets converted to
the NT hash, it gets combined

00:10:27.894-->00:10:32.799
with all that authentication
data and then that generates the
session base key. Once you get

00:10:32.799-->00:10:38.037
that session based key you can
use that to then sign packets or
into other versions of SMB you -

00:10:38.037-->00:10:43.276
SMB you can use that to, uh,
generate the keys to sign the
packets. Long story short this

00:10:43.276-->00:10:48.281
is the value we care about. So,
as I mentioned earlier, if that
flag is set and you generate

00:10:51.551-->00:10:55.989
that key you’re just going to
use it to decrypt this one and
that becomes the new one. So,

00:10:55.989-->00:11:00.927
with that knowledge now of how
those session based keys are
generated I wanted to go back to

00:11:06.799-->00:11:12.005
my favorite attack, the NTLMv2
relay attack, and show where
that trust is established. And I

00:11:12.005-->00:11:14.807
know there are some Microsoft
guys or AD admins in here that
are going to laugh at this for

00:11:14.807-->00:11:20.180
leaving this step out. So, here
is what it looked like. We just
sent the challenge response, we

00:11:20.180-->00:11:25.285
just sent the authentication
message to the server. The
victim at this point, before the

00:11:25.285-->00:11:29.556
server replies, has already
gathered all the information
required to generate that

00:11:29.556-->00:11:35.862
session based key. So, he’s
cool. The server doesn’t have
the user’s password unless it,

00:11:35.862-->00:11:42.001
you know, you’re using - you’re
connected into a DC itself. So
the server actually sends all of

00:11:42.001-->00:11:48.041
the data off to the DC through a
mandatory encrypted channel.
Please trust me on that one. And

00:11:48.041-->00:11:53.413
the DC will reply if the valid
log in and if it is, the DC will
generate the same key in the

00:11:53.413-->00:11:58.451
same way that they, uh, victim
did and provide that to the
server. That’s the trusted

00:11:58.451-->00:12:03.389
secret that we don’t get. So, I
know you’re all thinking, what
about Kerberos? So, Kerberos is

00:12:10.430-->00:12:16.102
a little more difficult to get
into. Starting from step 0 when
the user logs into their

00:12:16.102-->00:12:22.008
workstation they log in and may
send a request to the Kerberos
server, typically the DC.

00:12:22.008-->00:12:26.179
Kerberos will reply saying, hey,
encrypt this time stamp with
your password so I know it’s

00:12:26.179-->00:12:31.884
legitimate. We send the
encrypted time stamp and the
Kerberos server replies with our

00:12:31.884-->00:12:36.389
TGT which our session key. We’re
going to use that for most
everything, uh, on the domain.

00:12:36.389-->00:12:40.893
We’re going to use that for
future communication with the
DC, we’re going to use that to,

00:12:40.893-->00:12:47.233
uh, request other resources on
the network such as when we want
to connect to something called

00:12:47.233-->00:12:52.238
FileServer_1. Just a random file
server and the DC will reply,
um, with an encrypted server

00:12:55.408-->00:13:00.346
session key in that packet.
We’ll send the ticket we just
received off to the file server,

00:13:03.383-->00:13:08.988
the file server will - assuming
it’s valid, reply and say, hey,
cool, you’re good and if there

00:13:08.988-->00:13:15.828
is extended security, um, it
will reply with another
encrypted session key. Which

00:13:15.828-->00:13:21.434
altogether looks like this.
Password turns into the Kerberos
session key we got when we first

00:13:21.434-->00:13:26.439
logged into Kerberos. That we
used to decrypt the service
session key we get when we ask

00:13:26.439-->00:13:31.444
for a ticket to a file server.
And if they are using the send
logic, um, we use that last key

00:13:35.148-->00:13:40.153
to decrypt the now new key
provided from the file server.
These keys are then used to sign

00:13:43.222-->00:13:48.394
the SMB messages; these are the
SMB, um, session keys. And the
algorithm used to generate these

00:13:48.394-->00:13:53.399
keys and to generate the
signatures is very based on the
version of SMB. There is version

00:13:55.935-->00:14:02.575
1 which uses MD5, uh, versions 2
and 2 point 1 kind of beefed up
a little bit with SHA256 and

00:14:02.575-->00:14:07.580
versions 3 and 3 1 1 really
beefed up with AES128. So, now
that we know the only thing

00:14:11.217-->00:14:15.822
protecting these - these
sessions are - is the integrity
and the complexity of the user’s

00:14:15.822-->00:14:20.827
password let’s go after it. So,
first things first, we just
talked about how to, kind of,

00:14:23.129-->00:14:29.202
break SMB signing keys and how
to break signed SMB connections
but when SMB signing isn’t used

00:14:29.202-->00:14:34.207
or we have that it’s essentially
HTTP without HTTPS. If
encryption’s not used we can

00:14:37.310-->00:14:42.315
steal copies of files passed
over the wire with or without
the keys. And encryption is not

00:14:42.315-->00:14:48.554
used by default. If signing is
not used its fair game. You can
replace every file with an

00:14:48.554-->00:14:53.426
identical link that executes our
code. You can swap out the
contents of legitimate files

00:14:53.426-->00:14:56.929
passed over the network. You can
inject fake files into
directories and that helps with

00:14:56.929-->00:15:02.168
social engineering. And if
signing is used and we know the
password then we can do all of

00:15:02.168-->00:15:07.173
the above plus we can also
backdoor some stuff pulled from
the DC by the user. So, in SMB

00:15:12.311-->00:15:17.316
version 1 they don’t really use
signing by default. And in SMB
version 2 3 the case is pretty

00:15:21.020-->00:15:26.993
much the same. Unless somebody
requires signing on one of the
sides no one uses signing. So,

00:15:26.993-->00:15:30.963
we just talked about how to
break signing; most of the time
it’s not even in place per the

00:15:30.963-->00:15:37.970
nessus reference. Also, SMB
version 1, there is no
encryption. So for those plain

00:15:37.970-->00:15:42.208
text files passed over the
network we can just grab them.
SMB versions 2 and 3. It

00:15:42.208-->00:15:47.213
supposed encryption version 3
but it’s not enabled by default
and enabling it is a bit of a

00:15:47.213-->00:15:51.484
pain so chances are you can
also, regardless, still pass -
steal files passed over the

00:15:51.484-->00:15:56.489
network. Broken down there are
various versions of SMB and
their supported under various

00:15:59.892-->00:16:04.964
types of operating systems. Like
vista came out with SB version 2
and that was the first one to

00:16:04.964-->00:16:10.236
come out with it - with 202.
Then you’ve got the latest and
greatest server 2016 using 3 1 1

00:16:10.236-->00:16:16.776
and windows 10 using 3 1 1.
Everyone else uses something
earlier or, rather no earlier,

00:16:16.776-->00:16:23.416
but between those. Notable
exceptions in all of this is
that DCs require us to be

00:16:23.416-->00:16:28.421
signing by default. Windows 10
2016 have protected paths that
always require signing if they

00:16:31.057-->00:16:35.394
are connected to a path that
matches these, um, paths. So
anything that's like something

00:16:35.394-->00:16:40.132
SYSVOL or something NETLOGON the
client’s going to require
singing regardless of what the

00:16:40.132-->00:16:45.137
server says and that’s through a
process called UNC hardening. On
other notable exception is that

00:16:49.141-->00:16:55.681
if a client supports SMB version
3, and that’s 302 or 311, then
regardless of whether signing is

00:16:55.681-->00:16:59.752
used or not at the end of the
end of the authentication phase
they’re going to send a message

00:16:59.752-->00:17:03.022
to the server saying, hey, just
to make sure we’re all on the
same page, here’s the

00:17:03.022-->00:17:07.627
information you gave me during
the negotiation phase, is this
still cool? And that’s a signed

00:17:07.627-->00:17:13.332
message so the server now has a
way to kind of verify that no
one messed with it in between,

00:17:13.332-->00:17:19.572
um, even if they aren’t using
signing with any subsequent
messages. Only catch here is

00:17:19.572-->00:17:23.476
that in that message, the one
that verifies we’re all on the
same page, it covers everything

00:17:23.476-->00:17:27.313
except the authentication
mechanisms used. So, even with
that you can still downgrade

00:17:27.313-->00:17:32.318
them to NTLMv2 and get away with
it. So, on the other end of the
spectrum SMB 3 1 1 is a beast.

00:17:37.657-->00:17:43.896
And I’ll give kudos to Ned Pile
on that one. Um, the SMB keys,
rather than just being based on

00:17:43.896-->00:17:49.468
the authentication mechanism
used, is also based on the hash
of every packet passed back and

00:17:49.468-->00:17:56.375
forth during the negotiation and
authentication. So if you edit
anything then the server and the

00:17:56.375-->00:18:01.314
client are not going to have the
same keys and the connection is
going to drop. So, not bad on

00:18:04.784-->00:18:09.789
that one. So to recap; it’s used
on DCs and on 10 and 2016 on
those paths. Encryption is only

00:18:13.225-->00:18:18.764
available on SMB 3 but it’s a
manual process. Every dialect
up, except 3 1 1, can be

00:18:18.764-->00:18:23.769
downgraded on NTLMv2. And
signing and encryption keys are
at their root based on the

00:18:23.769-->00:18:30.609
user’s password. So, let’s
attack that. I built SMBetray
and the goal was to build a tool

00:18:30.609-->00:18:36.182
to really take advantage of
these man in the middle
vulnerabilities. Um, the attacks

00:18:36.182-->00:18:42.221
we were running before are - are
like the relay attack I
described where, you know, we’re

00:18:42.221-->00:18:46.092
enumerating the system if we’re
putting ourselves between a
victim and a server or we’re

00:18:46.092-->00:18:49.862
trying to pop it if they have
LA. But if they don’t have
either of those that’s pretty

00:18:49.862-->00:18:54.233
much where the road ends for us
on SMB attacks except for, you
know, MS17 or patch related

00:18:54.233-->00:18:59.572
vulnerabilities. So, I wanted to
take the focus, instead of, you
know, relaying or putting our

00:18:59.572-->00:19:04.577
focus on the server. I wanted to
go back on the client. I wanted
to go back on the HTTP, um,

00:19:04.577-->00:19:09.582
mindset of attacking the client.
So, the biggest obstacle in all
of that was putting ourselves in

00:19:12.785-->00:19:17.790
the position to attack the
client. So, we wanted to be
right there. We want to be

00:19:20.926-->00:19:26.032
between, um, my buddy Damian is
in the crowd, we wanted to be
between Damian and his DC, his

00:19:26.032-->00:19:31.504
file share and his other file
share because many users have
multiple. We didn’t want to just

00:19:31.504-->00:19:35.708
pick between, you know, being
between Damian and his PC and
that’s it because we’re missing

00:19:35.708-->00:19:40.579
a lot of data there. So, when I
was trying to build this tool
and I was trying to put it on

00:19:40.579-->00:19:45.751
top of a man in the middle
framework I kind of had 2
options. The first one was

00:19:45.751-->00:19:49.822
through the use of an arbitrary
upstream server. A lot of these
man in the middle tool will use

00:19:49.822-->00:19:55.828
an arbitrary upstream server as
a way of, um, instability. Long
story short, you receive the

00:19:55.828-->00:20:00.566
connection during like a ARP
cache poisoning attack; IP
tables will redirection that

00:20:00.566-->00:20:05.404
connection right back to you and
then in the socket layer you
will then forward it on to

00:20:05.404-->00:20:09.341
wherever you want. Uh, the catch
is, when you are at that layer
you don’t have the original

00:20:09.341-->00:20:13.946
destination of the connection
you just hijacked. So, if Damian
was trying to connect to his DC

00:20:13.946-->00:20:17.550
and I intercepted that
connection I might be
redirecting him to some random

00:20:17.550-->00:20:22.588
file share that I picked and on
his end that socket didn’t do
what he wants so it’s just going

00:20:22.588-->00:20:25.324
to drop the connection and it
might not give me all the things
I want. I want him using that

00:20:25.324-->00:20:29.095
connection so I can take
advantage of every opportunity.
I want him downloading files so

00:20:29.095-->00:20:34.767
I can steal them over the wire.
The other opportunity for a man
in the middle tool to kind of,

00:20:34.767-->00:20:40.306
you know, take advantage of that
was through the use of a net
filter queue. Net filter queue

00:20:40.306-->00:20:44.009
really gets down to the - the
kernel level and allows you to
edit those packets and intercept

00:20:44.009-->00:20:48.481
those packets, um, in live time.
So, you don’t have to worry
about losing the destination

00:20:48.481-->00:20:52.718
information as your planning to
intercept. So you can put
yourself between all of those

00:20:52.718-->00:20:57.723
servers. Only catch is that when
you’re putting yourself between
all of those servers, Python is

00:21:02.061-->00:21:06.098
what I was using and Python
would just snow ball; it would
drag. What would seem very quick

00:21:06.098-->00:21:11.937
to us was eons for TCP. So the
only solution I found to do a
full transparent man in the

00:21:11.937-->00:21:17.009
middle attack was killing me
because it wasn’t fast enough,
it wasn’t parsing the data fast

00:21:17.009-->00:21:22.014
enough to pass the information
back on. So, I tried to combine
them to get the solution that I

00:21:24.550-->00:21:30.823
wanted. I created a little
library called ebcLib which it
was kind of a play on - there

00:21:30.823-->00:21:36.362
was - there was edit cap and
there was better cap so, you
know, cheekishly I put EBC for

00:21:36.362-->00:21:42.835
even better cap. Uh, as a man in
the middle TCP kind of
framework. So, it gives you all

00:21:42.835-->00:21:48.974
of the freedom of a transparent
proxy built on NFQueue where you
can just say, hey, put myself in

00:21:48.974-->00:21:53.712
between Damian and whatever else
he’s talking to without editing
it or edit if I chose to with

00:21:53.712-->00:21:58.717
the connection stability of like
a better cap and an upstream
proxy. And that’s technical of

00:22:01.387-->00:22:05.758
how it works. Long story short,
you get the packet. NFQueue,
rather than trying to edit the

00:22:05.758-->00:22:10.262
packet the entire time, uh,
doing - and doing whatever
attack you intended, instead it

00:22:10.262-->00:22:14.967
just performs one task which it
does pretty quickly that is why
the connection doesn’t drop.

00:22:14.967-->00:22:19.071
NFQueue will get the packet; it
will just take the source and
the destination information and

00:22:19.071-->00:22:22.975
store it in a shared piece of
memory and then pass it on. That
gets redirected like the first

00:22:22.975-->00:22:27.346
type of, uh, man in the middle
attack, to a TCP server and with
there you have the stability of

00:22:27.346-->00:22:32.084
TCP. The TCP - the TCP server
will reach out to that shared
memory, find out where this dude

00:22:32.084-->00:22:38.090
was actually trying to go to and
then builds that connection
dynamically out there. So, once

00:22:38.090-->00:22:44.029
you receive a connection that
exists it just passes through to
the TCP server like business as

00:22:44.029-->00:22:49.702
usual. So, now that we can put
ourselves in between the server
that we want to hit and the

00:22:49.702-->00:22:54.807
user, uh, let’s go ahead and
let’s start attacked. Let -
let’s downgrade the dialect in

00:22:54.807-->00:22:58.177
the authentication mechanism to
use. Let’s steal the passive
files that I’ve been harping on.

00:22:58.177-->00:23:03.349
Uh, let’s inject some files and
swap out some content and let’s
replace files with an identical

00:23:03.349-->00:23:09.121
link. Uh, so that when they
click it it launches that thing.
And of course, if we know the

00:23:09.121-->00:23:14.126
password of the user let’s
leverage that information to
break those session keys. So,

00:23:16.295-->00:23:21.166
the way SMBetray is broken down
kind of looks like this. We put
ourselves between the victim and

00:23:21.166-->00:23:27.573
whatever server they want, uh,
even multiple servers at a time.
Uh, the victim will say, hey,

00:23:27.573-->00:23:31.110
what’s in this folder? And that
request typically occurs when
you open up a folder in a share

00:23:31.110-->00:23:36.282
and it starts listing out all
the files and folders in there.
We pass that on to the - to the,

00:23:36.282-->00:23:41.287
uh, receiving server. Receiving
server will reply saying, here,
you know, file 1, file 2. We’ll

00:23:43.856-->00:23:48.861
get that and if we know the keys
are to an insecure session we’ll
throw our own file in there or

00:23:48.861-->00:23:55.567
we’ll modify the details of the
files that were just listed;
like their file size. User might

00:23:55.567-->00:24:00.339
request one of the files we just
lied about and said it was in
that folder. Now, instead of

00:24:00.339-->00:24:03.542
passing it on to the server,
because the server would reply
with an error saying that file

00:24:03.542-->00:24:10.115
doesn’t exist, we send them a
convenient function SMB called
an echo. SMB loves to keep is

00:24:10.115-->00:24:16.455
messages in sync. Each request
and response has a numeric ID.
So, if I say, I’m going to pick

00:24:16.455-->00:24:21.493
on Damian again, if I say, hi
Damian, that has a message of 1.
When he replies that’s a message

00:24:21.493-->00:24:26.665
ID of 1. That conversation is
concluded. If I say another
thing to him; message ID 2. If

00:24:26.665-->00:24:30.369
he replies; message ID 2. And
that helps verify that we
haven’t missed anything in this

00:24:30.369-->00:24:35.374
conversation but if the users
request a file that does not
exist and we’re not going to

00:24:37.810-->00:24:41.613
pass it on to the server there
will now be a discrepancy in how
they talk to each other. Their

00:24:41.613-->00:24:46.151
IDs are going to be, uh,
misrepresented and they’re going
to be off. So, to keep them in

00:24:46.151-->00:24:51.623
sync for every request that is
completely forged or malicious
by the victim that we’re handing

00:24:51.623-->00:24:57.463
we’re going to send an echo
request to the - destined
server. When the server replies

00:24:57.463-->00:25:02.101
to that echo we’ve now
incremented the messages again
and now we’re going to reply

00:25:02.101-->00:25:06.138
with the victim with whatever we
wanted. And that way when they
continue, uh, conversation with

00:25:06.138-->00:25:11.010
each other no one will identify
that they’ve been - that they’ve
been, uh, swindled. Old word.

00:25:11.010-->00:25:16.014
So, now let’s show a brief demo
what this is going to look like.
So, assume we’ve done a Arp

00:25:18.517-->00:25:24.423
cache poisoning attack on this
victim and we’re between them
and a switch. On the other end -

00:25:24.423-->00:25:28.093
on - on the other end of the
switch is going to be like, a
DC, and there’s going to be some

00:25:28.093-->00:25:33.098
file share. So, first things
first, we’re just logging into a
user’s workstation to show you

00:25:49.915-->00:25:56.555
what a non-attack scenario looks
like; what his average PC, uh,
sees. He’s got a file share, uh,

00:25:56.555-->00:26:02.661
a mapped drive called some
network share and there are some
files in there. Keep a mental

00:26:02.661-->00:26:05.964
note of the files that you see
because we’re going to be
injecting some and removing

00:26:05.964-->00:26:10.969
some. Cool. So now we’re going
to launch the ARP cache
poisoning attack to really put

00:26:21.213-->00:26:27.252
ourselves between him and
whatever he wants to talk to.
And also note the server that he

00:26:27.252-->00:26:31.523
just connected to; the one with
the files and, uh, his mapped
network drive requires SMB

00:26:31.523-->00:26:36.528
signing. We’ve got a file
containing a lot of POP
credentials so if you’ve been

00:26:49.341-->00:26:54.413
running like, an LMNR and NTM,
uh, netbios poisoning attack on
your LAN you might have these

00:26:54.413-->00:26:59.718
credentials. And we’re going to
load these credentials into the
tool itself. It’s just going to

00:26:59.718-->00:27:03.055
use them and when it sees a
connection coming from that user
it’s going to try to leverage

00:27:03.055-->00:27:08.060
those credentials to pop the SMB
signing keys. The attack we’re
running is going to be a link

00:27:15.100-->00:27:20.672
swap all attack as well as an
inject files. Inject files,
intuitively, just injects files

00:27:20.672-->00:27:25.077
and makes files appear in the
directory that don’t actually
exist in the directory. And the

00:27:25.077-->00:27:30.883
link swap all is any file at all
we’re going to replace with,
instead, a link that will run

00:27:30.883-->00:27:34.987
whatever we want. In this case
we’re just running calc and
we’re running calc because when

00:27:34.987-->00:27:38.290
I was writing up this demo I
didn’t have time to fight with
windows defender because it’s

00:27:38.290-->00:27:43.295
been kicking a** lately
[laughter]. So, calc was easy
enough. So now Paul Davis is

00:27:51.169-->00:27:56.174
going to log back into his PC.
And you can see we capture his
hash and the background you can

00:28:01.313-->00:28:06.585
that, uh, it’s reported that we
broke his session based key
through both NTLMv2 and, it cut

00:28:06.585-->00:28:11.590
off a little bit, but it says
Kerberos. And now it shows that
we just injected some files. So,

00:28:14.626-->00:28:19.631
click me, inject me, seems
legit, all those. The text filed
that we opened up earlier is now

00:28:25.704-->00:28:30.709
a link and when opened we’ll run
whatever we want. In this case
it was calc. Inject me, a total

00:28:36.448-->00:28:40.752
fictitious file that doesn’t
exist on the server, he thinks
he’s talking to, is now there.

00:28:40.752-->00:28:45.757
And any file [applause] - thank
you. Any file that this user is
downloading or opening, um,

00:28:58.303-->00:29:02.307
either directly or indirectly,
you know, through back end
processes in windows, we will be

00:29:02.307-->00:29:08.146
passively stealing a copy of.
And to show the impact of that
I’m going to run the attack

00:29:08.146-->00:29:12.584
again but I’m going to run the
attack again with no credentials
and the only thing I’m going to

00:29:12.584-->00:29:16.888
do is I’m going to passively
steal stuff. So, this is useful
if you are on a LAN. They’re

00:29:16.888-->00:29:20.792
pretty hardened; you can’t get
LAN and where you can’t crack
their creds but you need to

00:29:20.792-->00:29:25.797
still, you know, make - make
some progress on hacking them.
So, we’re removing the

00:29:30.902-->00:29:35.907
credentials and we’re just going
to listen passively. As it turns
out when windows starts up it

00:29:42.681-->00:29:49.087
downloads a lot of useful
information from the DC. And if
you’re lucky enough to be

00:29:49.087-->00:29:53.859
running intact like this or if
you dossed your client or you
dossed your victim to convince

00:29:53.859-->00:30:00.365
them to reboot their PC you
might just be able to, um,
capture all of these valuable,

00:30:00.365-->00:30:05.370
uh, pieces of information from
the DC. I recorded this demo on
PC from 2012 so it’s not going

00:30:09.775-->00:30:14.780
to be the quickest thing. PC
just started up and we’ve
already intercepted some

00:30:18.050-->00:30:23.055
connections. Paul Davis is
logging in. And we’re now
stealing some data from the

00:30:32.397-->00:30:37.402
group policy including the
registry dot pole file that
contains a lot of valuable

00:30:39.871-->00:30:44.876
information in terms of registry
settings configured for the
users on the domain. So, that

00:30:52.050-->00:30:57.055
was the demo [applause]. Thanks
[applause]. So, if you want to
get a photo it will be posted

00:31:17.642-->00:31:22.647
this evening. Cool. So, now that
we just kind of, demonstrated
that SMB keys are based on

00:31:35.961-->00:31:40.198
passwords and that even without
the password we can still
intercept and modify a lot of

00:31:40.198-->00:31:43.735
connections and we can -
especially download some useful
information from the group

00:31:43.735-->00:31:48.740
policy. How do we stop this from
happening? Ned Pyle is the guy
who I would argue is in charge

00:31:51.343-->00:31:56.348
of SMB globally [laughter].
Disable SMB 1. Uh, second thing.
Even though we just demonstrated

00:32:05.624-->00:32:11.563
that you can defeat SMB signing,
that’s by no means any excuse
not to require it. Um, there is

00:32:11.563-->00:32:17.736
an - for those who haven’t run
nessus scans, there’s an option
to just support SMB signing and

00:32:17.736-->00:32:21.873
there is one to require it
always and I highly recommend
you require it always, unless

00:32:21.873-->00:32:26.878
you’re running XP systems,
you’re going to be able to
support that. So, SMB version 3

00:32:33.151-->00:32:38.323
introduced encryption and I
would love to organizations
really start pushing this thing

00:32:38.323-->00:32:43.328
out. Um, any SMB version 3
client supports it so if you’re
running anything later than

00:32:43.328-->00:32:48.166
window 7 in your org you can put
encryption pretty much
everywhere you want. And it is

00:32:48.166-->00:32:53.171
actually more efficient then
signing the messages. So, if you
- you can support encryption or

00:32:55.473-->00:33:01.713
you can require it. So, if you
support it then SMB 3
negotiations are protected. If

00:33:01.713-->00:33:05.851
they negotiation that you can’t
support encryption they’re going
to encrypt the session. So, UNC

00:33:05.851-->00:33:10.856
hardening is, uh, one of the
features used by default by
window 10 2016 to protect the,

00:33:16.561-->00:33:21.733
uh, SYSVOL and the NETLOGON
shares for any connection that
going out to something that

00:33:21.733-->00:33:26.371
looks like that but you can
manually require that on any
other shares or any - any other

00:33:26.371-->00:33:31.910
kind of path. So, if you know in
your organization that there’s a
very specify file share, um,

00:33:31.910-->00:33:35.313
that your user connecting to,
you want to make sure it’s
pretty locked down. You can lock

00:33:35.313-->00:33:39.384
down from the server side by
requiring signatures or
requiring encryption but you can

00:33:39.384-->00:33:44.522
also re - lock it down on the
client side and prevent them
from connecting to rogue servers

00:33:44.522-->00:33:48.026
by throwing in the UN - UNC
hardening saying, hey, you’re
connecting to this server or a

00:33:48.026-->00:33:53.031
server that looks like this, do
you xyz? Man, I hate to say this
because as pen tester I love

00:33:57.168-->00:34:02.107
NTLM, um, but NTLM really is
outdated. It was made near the
90s. I was made near the 90s

00:34:07.412-->00:34:11.716
[laughter]. So, if you can, run
through audits in your
organizations. See where NTLM is

00:34:11.716-->00:34:15.320
used and if you can’t disable it
just carte blanche, just - I
don’t know if that was proper

00:34:15.320-->00:34:19.991
use of carte blanche, if you
can’t rem - um - disable it
across your org find out where

00:34:19.991-->00:34:25.697
it’s used and restrict it just
to those systems. For me that’s
screws me over but I guess we’re

00:34:25.697-->00:34:30.702
all here for security. Now,
Kerberos FAST armoring, uh,
armoring is an interesting

00:34:35.340-->00:34:40.545
thing. Uh, we showed that if we
know the users password we can
intercept their Kerberos

00:34:40.545-->00:34:46.918
authentication phase and steal
their, uh, Kerberos session key
from the initial log on and use

00:34:46.918-->00:34:51.923
that to steal their Kerberos
ticket session keys from every
subsequent request. That can be

00:34:54.259-->00:34:59.230
protected but it requires
Kerberos FAST armoring, which
is, in a nut shell, any request

00:34:59.230-->00:35:05.904
going to the Kerberos server.
It’s first locked up with the,
uh, man, I’m hoping my detail is

00:35:05.904-->00:35:12.677
right with the machine accounts
Kerberos tickets. Which means,
unless you can pop the machine

00:35:12.677-->00:35:17.682
account password, that obscenely
large password, you’re not going
to be able to modify or

00:35:17.682-->00:35:22.687
intercept that - that, uh,
Kerberos session key even if you
know the password. So, huge

00:35:24.823-->00:35:29.828
precautions when enabling FAST.
It requires window 8 2012 or
later throughout the

00:35:34.566-->00:35:39.571
environment. Um, just like SMB
signing, it can be supported or
required. If you just support it

00:35:42.640-->00:35:47.412
we’re going to take advantage of
the - the, uh, of the
benevolence of the server and

00:35:47.412-->00:35:51.850
just downgrade clients but if
you require it then you better
make sure that all of your

00:35:51.850-->00:35:55.587
clients can connect to it
otherwise you’re going to brick
them and they’re not going to be

00:35:55.587-->00:36:00.358
able to talk to the DC. So,
Microsoft has great
documentation on how to push out

00:36:00.358-->00:36:04.129
a FAST armoring and I’d highly
recommend you going through the
procedure of pushing this out

00:36:04.129-->00:36:09.134
through your organization. You
know, always use passphrasing
and not passwords. A lot of the

00:36:12.637-->00:36:16.574
SMB signing prep that we just
covered in terms of breaking the
keys were lies that, you know,

00:36:16.574-->00:36:22.981
we compromised their password.
So, push out strong passwords.
Push out strong passwords and

00:36:22.981-->00:36:27.852
require SMB signing and you’re a
lot better than you were at the
beginning of this talk. Even you

00:36:27.852-->00:36:32.991
don’t do all the other, uh,
complicated involved things like
FAST armoring. Alright, that

00:36:32.991-->00:36:37.996
pretty much leaves us to like, a
Q and A, um, but right now I
want to ack - acknowledge a few

00:36:40.598-->00:36:45.270
people that contributed on this
talk. Uh, Ned Pyle is principal
program manager at Microsoft

00:36:45.270-->00:36:51.242
and, uh, it was awesome. Uh, I
did my own research on MSD and I
said, hey, to the best of my

00:36:51.242-->00:36:55.380
knowledge here’s how SMB works
and here are the various
circumstances that it behaves.

00:36:55.380-->00:36:59.651
Is this cool? Uh, and he - he
was awesome in terms of
providing feedback and giving me

00:36:59.651-->00:37:03.655
direction on yes or no things so
I didn’t give you guys
misinformation. So, he was

00:37:03.655-->00:37:09.027
awesome. Uh, Matthew George also
worked side by side with, uh,
Ned on this one to kind of spot

00:37:09.027-->00:37:13.398
check me on this. And, uh,
CoreSecurity for the impacket
library for which all of

00:37:13.398-->00:37:17.602
SMBetray is based on and I used
their library when I was trying
to figure out more on how SMB

00:37:17.602-->00:37:22.607
signing works. So, that’s about
it [applause].

