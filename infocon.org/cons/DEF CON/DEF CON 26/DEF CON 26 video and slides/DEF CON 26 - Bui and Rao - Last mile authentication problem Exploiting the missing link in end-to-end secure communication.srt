00:00:00.467-->00:00:05.472
>> Okay, so the speakers up here
today is Thanh. So, let's give
him a big hand! [applause] >> Hi

00:00:09.676-->00:00:15.282
everyone, the title of our talk
today is "Last Mile
Authentication Problem" during

00:00:15.282-->00:00:19.853
which we are going to showcase
how one can exploit the missing
link in end-to-end secure

00:00:19.853-->00:00:25.525
communication. We will shortly
dig deeper into, uh, knowing
what i the last mile; what is

00:00:25.525-->00:00:29.930
this missing link, and
everything. But before that, let
me start by introducing myself

00:00:29.930-->00:00:34.935
and the research team behind
this. >> I am Siddharth Rao, I'm
a doctoral candidate in Aalto

00:00:46.246-->00:00:50.751
University, Finland. And I
research on security and
privacy, one of the other hats

00:00:50.751-->00:00:55.555
of which I wear is of public
interest technologist. I was a
Ford-Mozilla open web fellow for

00:00:55.555-->00:01:01.028
the last year as part of it I
worked in an NGO called European
Digital Rights were I worked on

00:01:01.028-->00:01:05.465
the intersection of technology
and society. Along with me,
here, I have my co-speaker Thanh

00:01:05.465-->00:01:10.103
Bui who's also a doctoral
researcher at Aalto University,
Finland - researches on security

00:01:10.103-->00:01:16.076
and privacy. He just finished
his summer internship in Google
security team. We also, we here

00:01:16.076-->00:01:21.882
have doctor Marco Aantekenen who
is, uh, a seasoned security
professional and a post-doctoral

00:01:21.882-->00:01:26.553
researcher in University of
Helsinki in Finland. We were
supervised by doctor Thomas Aura

00:01:26.553-->00:01:33.193
who's a professor in secure
system research group of Aalto.
Okay, so now let's not get

00:01:33.193-->00:01:38.131
started. We see network and
software often with
client-server architecture.

00:01:38.131-->00:01:43.770
Let's take the example of
browser and web server. In
traditional tread model, and,

00:01:43.770-->00:01:49.476
uh, network thread model we
always consider user device and
the server and they're kind of

00:01:49.476-->00:01:54.314
typically trusted. However, the
network is hostile and that's
where attacker can do various

00:01:54.314-->00:01:58.986
types of attacks such as man in
the middle, to steal information
from the network. Since we are

00:01:58.986-->00:02:04.758
already aware of these attacks,
we use cryptographic solutions
such as TLS or WebDKI to protect

00:02:04.758-->00:02:10.731
it. Since you already know this,
we are not going to bore with
this. Because in reality, not

00:02:10.731-->00:02:15.268
all the communication goes over
the network, certain part of the
communication, if not all,

00:02:15.268-->00:02:20.774
happens within the computer. So,
think of this as a network which
is inside a computer. [coughing]

00:02:20.774-->00:02:24.911
So, the computer consist of
multiple processes that perform
different tasks, for example,

00:02:24.911-->00:02:30.050
software is broken into
different components. Say,
Franklin which handles the GUI

00:02:30.050-->00:02:35.522
and the backend which is, which
handles the local database.
They're separate processes and

00:02:35.522-->00:02:40.093
the user mechanism call this
"inter process communication" or
IPC, to exchange data between

00:02:40.093-->00:02:44.731
them. The communication,
whatever happens, which stays
inside the computer and it never

00:02:44.731-->00:02:50.003
leaves outside. There can be
interested components that runs
inside the user device and

00:02:50.003-->00:02:55.308
protecting the user information
of the data being exchanged over
IPC's equally important as that

00:02:55.308-->00:03:00.580
of the network. So, for this
reason, we try to understand the
security of the communication

00:03:00.580-->00:03:05.585
inside the computer, mainly
focussing on IPC. So, in this
talk, the title is "last Mile

00:03:08.688-->00:03:13.960
Authentication Problem", so
those of you aware of telecom
or, uh, cellphone networks, you

00:03:13.960-->00:03:18.965
might be aware of the, uh, word
that "Last Mile". In telecom,
especially in the case of

00:03:18.965-->00:03:22.769
landline, connecting everything
from call network till the
mobile switching centre is

00:03:22.769-->00:03:27.407
considered to be easier than
that of connecting the last mile
of the subscriber line which

00:03:27.407-->00:03:34.214
lasts from local switch to your
home's computer, home's phone.
And in regards to this, we are

00:03:34.214-->00:03:38.285
trying to encrypt every strands
and layers of the communication
in our drive to move to

00:03:38.285-->00:03:43.857
end-to-end secure communication.
In that attempt we're not even
bothering about this last mile

00:03:43.857-->00:03:49.329
of which stays inside the
computer. Uh, which happens,
the, the communication between

00:03:49.329-->00:03:53.467
multiple processes. So, the
structure of this, the, this is
what we call as the "last mile"

00:03:53.467-->00:03:56.603
and that's the problem of which
we are going to talk. So, the
structure of the talk is we

00:03:56.603-->00:04:01.575
first discuss a thread model
what we call as "Man and the
machine" or MITMA, and then we

00:04:01.575-->00:04:07.414
form the basics of IPC, its
caveats and attack vectors which
we use to exploit and, uh, show

00:04:07.414-->00:04:10.750
that, that are several softwares
which is vulnerable to MITMA.
[cough] By going through

00:04:10.750-->00:04:14.421
different case studies of real,
real life software applications
that are vulnerable to our

00:04:14.421-->00:04:18.892
thread model we also present
some demos. We try to show that
this is a real problem. Finally,

00:04:18.892-->00:04:23.029
we sum up with some education
mechanisms. [coughing] So, the
key take away from our talk is

00:04:23.029-->00:04:28.702
credentials and second factors
that can be compromised inside a
computer, ex, by exploiting IPC.

00:04:28.702-->00:04:34.107
As we show, we exploit many
security critical applications
such as password manager and USB

00:04:34.107-->00:04:38.945
security tokens using the
aforementioned man in the middle
adversary. Alright, so let's get

00:04:38.945-->00:04:44.951
started, first let's try to
understand what does this man in
the machine thread model. Who is

00:04:44.951-->00:04:51.391
this man in the machine? We
called the attacker that tried
to exploit the IPC inside a

00:04:51.391-->00:04:56.763
computer as MITMA or man in the
machine. The attacker can be any
unprivileged user that tries to

00:04:56.763-->00:05:01.334
steal sensitive information from
another user. The example of
potential MITMA attack attackers

00:05:01.334-->00:05:07.807
include co-workers, family mem-,
members and also guest accounts.
The target system here is a

00:05:07.807-->00:05:11.878
multi-user computer, meaning a
computer that can be accessed
from multiple users which are

00:05:11.878-->00:05:16.550
very common. So, think of
enterprise systems or
universities where everyone will

00:05:16.550-->00:05:21.488
have the computer to which they
log in using they're own
credentials. In such, uh,

00:05:21.488-->00:05:24.891
environment, even though
everyone has their personal
computer, they can be accessed

00:05:24.891-->00:05:29.362
by other domain users, of course
with their credentials.
Interestingly, attacker can also

00:05:29.362-->00:05:35.669
be the guest user. In many OSs
such as Ubuntu the guest account
is anywhere by default and even

00:05:35.669-->00:05:39.272
the seasoned security
professional forget to turn it
off. It is important to notice

00:05:39.272-->00:05:43.743
the computer here are not
compromised or infected with,
with malwares, in that case,

00:05:43.743-->00:05:48.148
everything will confri-, uh,
compromised. So, we are not
interested in malwares, but we

00:05:48.148-->00:05:52.085
are interested in
legitimate-looking processes
which are intent to be there on

00:05:52.085-->00:05:58.124
the computer. [background noise]
So, the attackers method is to
run malicious process, process

00:05:58.124-->00:06:03.930
but from another logic sessions,
not from victim's login session.
An scenario is attacker signs

00:06:03.930-->00:06:08.568
into victim's computer with his
own credentials or using guest
account and run a given process.

00:06:08.568-->00:06:13.540
He then uses fast switching
windows uh, and leaves his login
session in the background and

00:06:13.540-->00:06:18.545
switch back to victim's session.
In Unix, commands like nohup can
be used to keep process alive in

00:06:18.545-->00:06:22.782
the background. So, you don't
have to keep the whole user
session alive. This way the

00:06:22.782-->00:06:27.420
background session continues to
be on attack in, in the
background and attackers process

00:06:27.420-->00:06:33.660
is trying to steal whatever is
happening in the IPC of another
user. Things could be worse if

00:06:33.660-->00:06:39.633
there is a remote access to the
computer. Uh, such as SSH or
Windows RDP enabled on it. And

00:06:39.633-->00:06:44.004
also it is important to notice
that attacker tries no privilege
escalation, even though, in

00:06:44.004-->00:06:48.575
theory he can, but we didn't
concentrate on that. The attack
scenario, uh, similar to that of

00:06:48.575-->00:06:53.580
impersonation or man in the
middle. Uh, in network but, uh,
in our talk everything is

00:06:55.915-->00:07:00.053
happening inside one computer.
[coughing] So, at this point you
might be wondering how to

00:07:00.053-->00:07:05.892
exploit IPC of other users? To
understand that, uh, let's dig
deeper to know little bit more

00:07:05.892-->00:07:10.430
about IPC and escalates.
Multiple processes inside the
computer talk to each other

00:07:10.430-->00:07:14.401
using inter-process
communication method. There are
many types of IPC, such as

00:07:14.401-->00:07:19.239
signals, semaphores, shade
memory, file system, network
sockets, pipes. [coughing] Which

00:07:19.239-->00:07:23.777
includes unnamed, as well as
anonymous pipes. Some of them
are Unix specific, some of them

00:07:23.777-->00:07:28.014
are Windows specific, some of
them are available on all
flavours of OS but they are

00:07:28.014-->00:07:32.585
implemented differently. Not all
of them are vulnerable to our
attack model, but the common

00:07:32.585-->00:07:37.357
method of the vulnerable IPC
methods are there. There is a
server process which binds to a

00:07:37.357-->00:07:44.097
specific name or an identifier
and waits for the connection
from the client. In that sense

00:07:44.097-->00:07:50.403
we focus on 3 IPC methods:
network sockets, Windows named
pipes and USB. So, strictly

00:07:50.403-->00:07:56.109
speaking USB is not an IPC but
still, it is similar to that of
sockets or named pipes mainly

00:07:56.109-->00:08:00.513
because they also fall into the
client-server architecture and
USB communication happens inside

00:08:00.513-->00:08:06.453
a computer. So, the MITMA
attacker can exploit it. IPC
methods that are secure against

00:08:06.453-->00:08:10.857
our, uh, attack model for
example is, uh, unnamed pipes
the difference is that unnamed

00:08:10.857-->00:08:16.029
pipes both the communication end
points are created at the same
time by the same user so that

00:08:16.029-->00:08:21.701
leaves no op-, no opportunity
for any, any untrusted process
to get in midway. So, let us now

00:08:21.701-->00:08:27.107
take a deeper look into insecure
IPC methods, one by one. Let's,
let's start with network sockets

00:08:27.107-->00:08:31.611
- most of us think of, uh.
computer networks when we hear
the term "network sockets". Even

00:08:31.611-->00:08:35.548
though they are used widely in
computer networks it is also one
of the most widely used IPC

00:08:35.548-->00:08:40.520
methods. So, here network
sockets are used when the user
listens on a local host

00:08:40.520-->00:08:45.091
interface and thereby into a
specific port number. As long as
the port number is more than

00:08:45.091-->00:08:51.097
1024 because anything below 1024
are standard dedicated ports. As
long as it is more than 1024,

00:08:51.097-->00:08:54.234
any process, regardless of its
owner can connect on the port,
it can listen the port, it can

00:08:54.234-->00:08:59.639
listen on the port. There will
be ser, one server process and
multiple client processes that

00:08:59.639-->00:09:04.944
can connect. Also, network
sockets doesn't have any inbuilt
access control mechanism to

00:09:04.944-->00:09:08.782
restrict who can access the
endpoint. This leaves the local
attacker, like MITMA, open to

00:09:08.782-->00:09:14.854
exploit them. So, one of the
obvious things an attacker can
do is client impersonation. So,

00:09:14.854-->00:09:20.126
attacker can find the port
numbers either by documentation
or source code or just by, uh,

00:09:20.126-->00:09:24.764
running commands like Netstack
and he just connects to the
local server on a spec-, on that

00:09:24.764-->00:09:30.170
specific port. There, there
could be case where the local
server just accept one

00:09:30.170-->00:09:34.407
connection. So, if the attacker
comes late to the party.
[coughing] His, his, uh, request

00:09:34.407-->00:09:39.112
to join will be discarded. So,
in such cases the attacker just
impersonate the client process

00:09:39.112-->00:09:43.950
before the legitimate client
does. So, if client
impersonation can be done, then

00:09:43.950-->00:09:49.155
it also possible to do the
server impersonation, right?
Well, yes. The attacker has to

00:09:49.155-->00:09:54.427
just start the local server
before the legitimate server
does, mainly, uh, opening a

00:09:54.427-->00:10:00.333
specific port. There is nothing
which can stop this. The client
would not notice it and just

00:10:00.333-->00:10:05.839
simply connect to the port and
start exchanging information. At
this point some of you may have

00:10:05.839-->00:10:11.711
noticed that legitimate and the
malicious server can not bind to
a port at the same time. So,

00:10:11.711-->00:10:15.415
does this mean that the attacker
can do man in the middle along
with client and server

00:10:15.415-->00:10:20.286
impersonation? The answer is
yes, first the attacker has to
perform the server impersonation

00:10:20.286-->00:10:26.025
that is he runs the local server
on a specific port. And, uh,
once this primary port is, uh,

00:10:26.025-->00:10:30.964
open, he receives information,
he receives connection from the
benign client. Many softwares,

00:10:30.964-->00:10:35.635
while running local servers like
this fail over to another port
if the primary port is already

00:10:35.635-->00:10:39.873
taken. So, this property of port
absolutely makes sense from
development point of view.

00:10:39.873-->00:10:45.345
Mainly, because anyhow there's a
standard port so it could be,
uh, one of the other legitimate

00:10:45.345-->00:10:48.515
processes in the computer would
have already taken it. So, it
makes sense from, uh, uh,

00:10:48.515-->00:10:52.685
development point of view to
have a predefined list of quotes
where, uh, the server switch

00:10:52.685-->00:10:58.191
over to the secondary port. So,
what attacker does is he takes
advantage of port agility

00:10:58.191-->00:11:02.629
property and what he does is -
after doing this, uh, the server
impersonation and blocking the

00:11:02.629-->00:11:07.634
primary port, he would allow the
benign server to fall into the
secondary port and then in the

00:11:07.634-->00:11:12.705
secondary port her performs the
client impersonation. So, in
that way he, he becomes man in

00:11:12.705-->00:11:16.009
the middle and he exchanges
information between the benign
client and the server. There

00:11:16.009-->00:11:21.614
could be rare cases where such
poor agility is not implemented.
In such cases the attacker can

00:11:21.614-->00:11:26.019
switch roads, time it well and
exchange the information. It
could be slow but it is still a

00:11:26.019-->00:11:31.824
possibility. So, now that we
know [coughing] Uh, know about
network sockets, on local hosts

00:11:31.824-->00:11:36.829
vulnerable to MITMA, how about
other IPC methods? Main pipes
are available both on Windows

00:11:39.065-->00:11:42.735
and Linux, however they're
different in their
implementation. We are

00:11:42.735-->00:11:47.574
interested only in Windows named
pipes. In Windows named pipe
have similar client-server

00:11:47.574-->00:11:51.477
architecture, client-server
architecture that of network
sockets. So, instead of local

00:11:51.477-->00:11:57.684
hosts, here there spe-, uh,
placed in a special part which
is, uh, "dot pipe" which is in

00:11:57.684-->00:12:01.921
the "Ru directory". And instead
of the port number, here pipes
will have a specific name. So,

00:12:01.921-->00:12:07.126
all users, including guests have
access to this specific part. In
network socket there is always

00:12:07.126-->00:12:12.432
one server and multiple threads.
However in named pipe there can
be multiple instance of the pipe

00:12:12.432-->00:12:18.204
that share the same name. So,
multiple client, uh, server
instances exist but in each,

00:12:18.204-->00:12:22.375
each case there will be one
server, one client. So, every
instance will be one server and

00:12:22.375-->00:12:27.380
client pair. When the pipe
process runs, it waits for the
pipe client to join, once the

00:12:29.582-->00:12:34.420
client joins, the pipe can
create another pipe instance and
wait again for the new client to

00:12:34.420-->00:12:39.659
join. New clients are connected
in round-robin fashion. And the
number of instances that can

00:12:39.659-->00:12:44.130
co-exist can also be controlled.
After the similarities there is
one major difference between

00:12:44.130-->00:12:49.068
network sockets and name pipes,
Windows named pipes. That is,
uh, Windows named pipes are, uh,

00:12:49.068-->00:12:54.040
they do have in-built access,
uh, control mechanisms. Since
pipes are Windows objects, they

00:12:54.040-->00:12:58.978
have dis, discretionary access
control list or "DACL"
associated with them. The word

00:12:58.978-->00:13:03.583
"discretionary" refers to the
fact object owner defines who
has access to the object. So,

00:13:03.583-->00:13:08.655
there are two cases. [coughing]
So, when the pipe does not exist
anyone can create the first

00:13:08.655-->00:13:14.060
instance and set the DACL of all
the future pipe instances. Just
because of DACL it does not stop

00:13:14.060-->00:13:19.666
anyone from doing it. However,
if the pipe al-, already exists
then that is tricky. Only those

00:13:19.666-->00:13:25.238
users with something called as
"file create pipe instance" can
create new instances. So, having

00:13:25.238-->00:13:30.977
access control does this matter
at all to MITMA attacker?
Unfortunately, no. Similar to

00:13:30.977-->00:13:35.882
that of network sockets MITMA
attacker can perform client
impersonation. Any process can

00:13:35.882-->00:13:40.320
connect to an open pipe instance
just by knowing the name of the
pipe. Again, he can, the

00:13:40.320-->00:13:45.191
attacker can find it from source
code or documentation, or just
by running, uh, commands, uh,

00:13:45.191-->00:13:50.096
like sysinternals tools like
"pipe list". So, even though
they are subjected to access,

00:13:50.096-->00:13:54.734
access control, uh, checks like
I mentioned before, eventually
we will learn from our next

00:13:54.734-->00:13:59.572
slide that access control does
not matter at all. Just like
port jack, port hijacking or,

00:13:59.572-->00:14:04.210
uh, taking over the port before
the legitimate server does. In
network sockets one can, uh,

00:14:04.210-->00:14:10.016
uhu, hijack in, in unnamed pipes
one can hijack the name of the
pipe. Uh, by creating the first

00:14:10.016-->00:14:14.020
instance we just hijack the name
and since, while creating the
first instance, you can also set

00:14:14.020-->00:14:20.026
the DACL, uh, in such a way that
it allows everyone to create or
connect to new instances.

00:14:20.026-->00:14:24.130
[background noise] Victim's
benign server here may just
create the second instance

00:14:24.130-->00:14:28.768
without noticing that there is
already one. And als there is a
possibility of setting a flagged

00:14:28.768-->00:14:33.172
called "find flag first pipe
instance" which can be used to
check whether the instance is

00:14:33.172-->00:14:36.976
created first, or not. However,
software developers seem to
ignore this or they are not

00:14:36.976-->00:14:42.849
aware of it. Mainly because they
underestimate or overlook this
thread model. Similarly, benign

00:14:42.849-->00:14:46.819
client process can connect to
the attacker's pipe instance
without noticing who actually is

00:14:46.819-->00:14:50.690
the owner. It will notice it is
not him but the owner is
actually some other person in

00:14:50.690-->00:14:55.361
this computer. [click sound] So,
client and server impersonation
can be done once the pipe name

00:14:55.361-->00:14:59.198
is hijacked. So, it means that
attacker can simply perform man
in the middle. So, there is no

00:14:59.198-->00:15:04.003
such thing of, uh, port agility
here like in network sockets
because, uh, every pipe, every

00:15:04.003-->00:15:09.675
pipe instance use the same name.
So, MITM is just
straightforward. Now, that we

00:15:09.675-->00:15:15.414
learned about, uh, sockets and
named pipes, what is common
between USB? [coughing] Has it

00:15:15.414-->00:15:21.387
told USB strictly not an IPC?
But, uh, here as well, it shows
client-server architecture and

00:15:21.387-->00:15:26.058
it, uh, waits for a client
connection. We are interested in
a specific class of USB device

00:15:26.058-->00:15:31.197
called "USB human interface"
which include peripheral device
like hardware security toolkits.

00:15:31.197-->00:15:37.236
In Unix and Mac implementation
of USB's different from Windows.
In Unix system USB HID can be

00:15:37.236-->00:15:42.608
accessed by exactly one
interactive user. So, they have
a mechanism where, uh, USB HID

00:15:42.608-->00:15:48.748
is actually a special file which
is mapped in, uh, HI-, HID raw,
uh, HID raw, uh, band. And the

00:15:48.748-->00:15:54.120
logged-in user get the default
reader access, if the session
is, uh, interrupted, or for

00:15:54.120-->00:15:57.924
example like "logout" or "switch
user", the reader, the access
will be transported to the

00:15:57.924-->00:16:02.929
display manager and then to the
next logged in user. So, in that
way they ensure that, uh,

00:16:02.929-->00:16:08.367
exactly one user have access to
the USB HID. Unfortunately in
Windows, no such dynamic access

00:16:08.367-->00:16:14.106
control mechanism exist, so more
than one user at a time can
access the HID, especially of

00:16:14.106-->00:16:19.812
the other users. At least, uh,
that is the case in terms of,
uh, hardware security toolkits.

00:16:19.812-->00:16:23.049
So, before we jump into case
studies, let me quickly
summarize what we discussed so

00:16:23.049-->00:16:28.321
far. The attacker here is man in
the machine, or MITMA. It's an
unprivileged user which also

00:16:28.321-->00:16:33.192
include guests, it does not
perform any privilege escalation
the victim's computer is not

00:16:33.192-->00:16:37.864
infected by malwares the
attacker's aim is just to
intercept the IPC of other

00:16:37.864-->00:16:43.135
users. So, the vulnerable IPC
mechanisms are network sockets,
Windows named pipes and USB -

00:16:43.135-->00:16:47.673
they all have client-server
architecture and they bind to a
specific name or identifier and

00:16:47.673-->00:16:53.079
wait for the client to connect.
The attacker can do client and
server impersonation as well as

00:16:53.079-->00:16:57.483
man in the middle. The fact that
named pipes have access control
does not change anything. Now,

00:16:57.483-->00:17:01.687
we will get into case studies to
understand what will happen when
the end points of IPC are not

00:17:01.687-->00:17:06.692
authenticated. So, my, uh,
colleague Thanh will present.
Thank you. >> Hello everyone.

00:17:10.229-->00:17:15.134
So, now I will show how we can
supply, uh, network socket,
named pipe and USB with

00:17:15.134-->00:17:21.274
real-world application. Our
primary case study is
stand-alone password managers.

00:17:21.274-->00:17:26.712
They are different from cloud
password managers like LastPass
in the sense that they provide

00:17:26.712-->00:17:32.818
native desktop app that allow
users to manage the password.
And stand-alone password manager

00:17:32.818-->00:17:39.292
they are often integrated into
browser with browser extension.
With this browser extension help

00:17:39.292-->00:17:45.998
users in creating and storing
password and also entering the
password into login forms. We're

00:17:45.998-->00:17:51.203
interested in the connection
between the browser extension
and the app because they

00:17:51.203-->00:17:55.942
communicate the password over
this, uh, com-, communi-,
communicate the password over

00:17:55.942-->00:18:02.648
IPC. The first case study I
would like to talk about is
RoboForm. It's a popular

00:18:02.648-->00:18:07.653
password manager and the
RoboForm app it runs HTTP server
on port 45-45-12 and wait for

00:18:10.356-->00:18:15.361
client connection. The RoboForm
browser extension connect as a
client to the app to and query

00:18:17.763-->00:18:23.502
all the passwords from the app
the problem here is that there's
no authentication between the

00:18:23.502-->00:18:28.507
browser extension and the app.
So it means that the app will
accept any client without

00:18:30.710-->00:18:35.715
verifying if actually legitimate
browser extension So, it's quite
easy for the MITMA attacker to

00:18:37.917-->00:18:44.090
exploit the channel since
attacker is, uh, a valid user
funding a malicious process in

00:18:44.090-->00:18:49.862
the background who just needs to
connect to the app as a client
and query the whole database

00:18:49.862-->00:18:56.302
from the app. Because I would
happily give away password
without any verification. So,

00:18:56.302-->00:19:02.608
this is a pretty simple case,
let's take a look at more
complex case. So, 1Password is a

00:19:02.608-->00:19:07.713
another popular password
manager, this is more
interesting because the

00:19:07.713-->00:19:13.452
developer try to protect the IPC
channel but it's not good
enough. The 1Password app it run

00:19:13.452-->00:19:19.058
a web office server on port
26-63 and with, with for
connection from the browser

00:19:19.058-->00:19:23.829
extension. And the way the
server got the connection I
verify the client very

00:19:23.829-->00:19:28.834
carefully, it checks the browser
extension ID on the header of
it's request. It also check the

00:19:30.903-->00:19:37.276
co-signing signature of the
client process to make sure
that, uh, it is known browser

00:19:37.276-->00:19:43.983
and most importantly, the server
checks whether the, the server
and the client processes are all

00:19:43.983-->00:19:50.623
by the same user. So, this check
it prevents MITMA attacker from
impersonating the client as the

00:19:50.623-->00:19:57.496
case of proper form. However,
the client doesn't verify the
server, actually it can not

00:19:57.496-->00:20:02.501
because the browser extension
uh, is sandboxed by the browser
so, it, like set to very limited

00:20:04.703-->00:20:09.709
APIs and to compensate for this
limitation the client as a
server have to run the

00:20:12.111-->00:20:16.882
cryptographic protocol to create
a share encryption key in the
first communication. But the

00:20:16.882-->00:20:21.887
design of the, uh, the protocol
is not secure. Let's take a look
at the protocol here. So, can

00:20:25.458-->00:20:30.463
anyone spot the problem here
with the protocol? So, this is
clearly not a secure protocol.

00:20:39.739-->00:20:41.741
As you can see, all the material
are the final key ore saved in
the messages and also, on step

00:20:41.741-->00:20:43.742
5, when the user confirm if the
code match, you can see that the
user only confirm on the app

00:20:43.742-->00:20:48.748
site. It means that a malicious
server can totally skip this
confirmation. So, this insecure

00:21:03.229-->00:21:08.768
protocol, together with the fact
that there's no server
verification from on, uh, on the

00:21:08.768-->00:21:13.772
client side, allows MITMA
attacker to perform server
impersonation and once the MITMA

00:21:16.375-->00:21:23.182
attacker impersonate the server
it can command to the browser
extension and collect all the

00:21:23.182-->00:21:30.189
data that user enter on the web
forms so it mean that username
and password that user enter on

00:21:30.189-->00:21:35.194
the webform will be sent to
attacker. I was about to show
you a demo but because of the

00:21:42.835-->00:21:47.506
technical problems and I can not
really show it. But, uh, it will
be on Qdup for anyone

00:21:47.506-->00:21:52.511
interested. So, password manager
also use, uh, a channel called
"native messaging" to

00:21:55.848-->00:22:00.786
communicate between the browser
extension and the app. So,
native messaging is standalone,

00:22:02.955-->00:22:08.227
your standard browser's built-in
method that's designed to
provide more secure alternative

00:22:08.227-->00:22:14.633
to network socket. It has been
used by many application
including password manager. So,

00:22:14.633-->00:22:20.773
how native messaging work with
password managers? First, the
password manager need to

00:22:20.773-->00:22:27.146
register an executable, called
'native messaging host" with a
browser and allow only it's

00:22:27.146-->00:22:32.518
browser extension to communicate
with its host. And the way the
browser extension want to

00:22:32.518-->00:22:39.191
communicate with the persisting
host, the browser will run the
native messaging host in a tied

00:22:39.191-->00:22:45.664
process and communicate with it
using standard input and output
stream. This way, the MITMA

00:22:45.664-->00:22:52.471
attacker can not get into the
middle and intercept information
on the channel. So, the question

00:22:52.471-->00:22:58.577
here now is, is native messaging
a complete solution for password
managers? Well, the answer is

00:22:58.577-->00:23:03.515
no, it isn't because, uh, the
native messaging host and the
password manager app are still

00:23:06.785-->00:23:13.792
two separate processes, so they
still need to access data over
IPC. The difference here is that

00:23:13.792-->00:23:18.831
the native messaging host is not
sandboxed by the browser, so it
has more options on how to

00:23:18.831-->00:23:23.836
communicate with the password
manager app. So, let's take a
look at another case - Password

00:23:27.506-->00:23:33.612
Boss. Password Boss is a
password manager that use native
messaging host and on the

00:23:33.612-->00:23:37.683
Windows the native messaging
host use named pipe to
communicate with the Password

00:23:37.683-->00:23:44.223
Boss app. When the app starts,
it creates a named pipe when
wait for connection forms and

00:23:44.223-->00:23:49.428
native messaging host. The
native messaging host simply
connect to the named pipe as a

00:23:49.428-->00:23:55.267
client and forwards messages
between the browser extension
and the app. The problem here is

00:23:55.267-->00:24:01.974
that the app doesn't restrict
access to the named pipe, it
allow all authenticated user to

00:24:01.974-->00:24:07.479
have full access to the named
pipe. This way, anyone can
create a new instance of a named

00:24:07.479-->00:24:12.484
pipe or connect to it as a
client. In addition, the app and
the native messaging host don't

00:24:15.587-->00:24:22.127
authenticate each other and all
messages are sent in plaintext.
Because of these issues we are

00:24:22.127-->00:24:28.534
able to perform man in the
middle on Password Boss. We
could do it not only from an

00:24:28.534-->00:24:33.539
authenticated user but also from
guest user. Let me first show
how the MIT, the man in the

00:24:35.641-->00:24:41.580
middle attack could be done from
an authenticated user. As I've
mentioned, when the app starts,

00:24:41.580-->00:24:46.852
it creates a named pipe and wait
for connection forms and native
messaging hosts. So, first, the

00:24:46.852-->00:24:51.857
attacker just needs to connect
as a client those apps by
instance. The attacker then

00:24:55.027-->00:24:58.897
create another instance of the
named pipe and wait for
connection from the native

00:24:58.897-->00:25:05.571
messaging host. When the native
messaging host want to
communicate with the app it

00:25:05.571-->00:25:10.576
would connect to the attacker's
instance because it is the only
one instance of the named pipe.

00:25:13.178-->00:25:18.550
So, after that, the attacker
simply forwards the messages
between two pipe instances. And

00:25:18.550-->00:25:23.555
we have man in the middle
attack. It's a little bit more
tricky to perform the attack

00:25:25.758-->00:25:31.897
from a guest user because, as
I've mentioned before, the
access control list of the named

00:25:31.897-->00:25:37.803
pipe doesn't allow the guest
user to, uh, for, to do
anything. Only authenticated

00:25:37.803-->00:25:42.808
user can create new pipe
instance or access an open one.
So, our solution here is by pipe

00:25:45.210-->00:25:50.215
hijacking the guest user could
create the, the first instance
of the pipe and set full access

00:25:52.618-->00:25:59.391
to all users. This way whether
the app creates its own instance
it doesn't even notice that

00:25:59.391-->00:26:04.329
another user owns the named pipe
and access control of the pipe
is not, uh, as, as expect. The

00:26:07.566-->00:26:12.237
rest of the attack is the same
as attack by authenticated user
that I just described before.

00:26:16.275-->00:26:21.680
So, last case study I would like
to talk about is the FIDO U2F
security key. FIDO U2F is

00:26:21.680-->00:26:26.685
standard for second factor
authentication and it is
supported by many popular

00:26:26.685-->00:26:33.091
services such as Google,
Facebook, GitHub. And most
security keys implement this

00:26:33.091-->00:26:39.832
standard, even Yubi keys, and
even the new Titan security keys
that Google introduced a few

00:26:39.832-->00:26:44.837
weeks ago also follow this
standard. As you can see, uh,
the, the figure on the right.

00:26:47.706-->00:26:54.513
You can see simplified protocol
of how security key works. So,
first, the user would register

00:26:54.513-->00:27:00.919
the device with the online
service checking once to
authenticate second factor

00:27:00.919-->00:27:05.657
authentication. Basically it's a
device, then there is a public
key bear and the server that

00:27:05.657-->00:27:12.431
links the key bear - the public
key to the user. And after that,
when the user wants to log in to

00:27:12.431-->00:27:17.369
the servers, the server who
withstand the challenge to the
browser and expect to see a

00:27:17.369-->00:27:22.741
response pertaining to the
device signature on the
challenge. To get the response,

00:27:22.741-->00:27:26.979
the browser will re-, will keep
sending the challenge to the
device until it will receive a

00:27:26.979-->00:27:28.981
response. The device however, it
doesn't automatically sign any
request it, uh, receives. It

00:27:28.981-->00:27:33.986
needs to be activated by
touching a button on it. And it
only respond to the first

00:27:41.026-->00:27:46.031
request as such as touch. So,
how can we exploit this FID,
FIDO security key? So, since the

00:27:51.937-->00:27:58.911
security keys is supposed to
prevent malicious login even
when the user password has been

00:27:58.911-->00:28:04.917
compromised? We assume he had
the attacker has obtained the
victim's password from some

00:28:04.917-->00:28:10.155
other source and they're trying
to crack the second factor. The
attacker that we'll exploit the

00:28:10.155-->00:28:15.894
fact that on Windows and the
user, even the one in the
background can access USB HID

00:28:15.894-->00:28:20.899
devices at anytime. So, here is
attack. First, the attack-, the
attacker runs a malicious

00:28:24.469-->00:28:30.108
browser process in this
networking sessions and signs
into the service using the

00:28:30.108-->00:28:35.714
username and password that he
has opened. So, malicious
browser we received a challenge

00:28:35.714-->00:28:40.719
from the service. After that the
malicious browser will keep
sending the challenge to the

00:28:43.121-->00:28:49.328
def-, to the device at high rate
and the attacker would need to,
it would need to send a

00:28:49.328-->00:28:55.901
challenge to the device at
higher rate than the, than the
legitimate browser would do to

00:28:55.901-->00:29:02.708
increase the chance of getting
the request site. It is easy
because Chrome for example is

00:29:02.708-->00:29:07.713
sending the challenge to the
device every 300 millisecond.
So, when the victims sign into

00:29:11.583-->00:29:17.089
any service using the same
security key, the victim would
touch a button on the device and

00:29:17.089-->00:29:23.695
there's a high probability that
attackers request will be signed
because it had been sent to the

00:29:23.695-->00:29:28.700
device with a very high rate.
The user might notice that the
first button touch has no effect

00:29:30.902-->00:29:36.375
because it's used by the
attackers request for such minor
glitches are normal in computers

00:29:36.375-->00:29:42.781
and typically ignored. We tested
the attack type on popular
services including Facebook and

00:29:42.781-->00:29:47.786
GitHub and we got, uh, 100-, uh,
100 percent success rate. So, in
summary - we have three types of

00:29:53.425-->00:29:58.730
IPC mechanism which are
vulnerable to MITMA attack:
named pipe, network socket, USB.

00:29:58.730-->00:30:05.370
And we have seen real-world
example of how they're
exploited. But that not the only

00:30:05.370-->00:30:12.210
cases that we've found. This is
a list of the apps that we
analysed and the vulnerabilities

00:30:12.210-->00:30:17.215
that we found. Our focus is on
password managers and other
login credentials. We also found

00:30:20.085-->00:30:25.590
vulnerability in many other, uh,
many other apps. This app
follows client-server

00:30:25.590-->00:30:30.595
architecture. For example, in
case of MySQL, on Windows if the
client and the server are on the

00:30:33.799-->00:30:40.305
same computer the client can
connect to the server using
named pipes and we, we were able

00:30:40.305-->00:30:45.310
to perform man in the middle
attack on this channel. So, how
can MITMA attacks can be

00:30:49.314-->00:30:55.153
mitigated? Since attack are
performed by leaving a malicious
process running in the

00:30:55.153-->00:31:00.459
background the most
straightforward solution would
be to limit the number of users

00:31:00.459-->00:31:05.464
on the computer. Ideally, this
computer should be personal to
only one user, also we will

00:31:08.200-->00:31:14.473
accept should be disabled or
limited to only one user. The
MITMA attack can also be

00:31:14.473-->00:31:20.912
dictated. The developers can
take, can compare the owner of
the client under the server

00:31:20.912-->00:31:27.385
process and see if they are
owned by the same user. It might
be more difficult for the

00:31:27.385-->00:31:33.191
Javascript client, running in
web browser like browser
extension because they don't

00:31:33.191-->00:31:39.631
have access to the operating
systems APIs so they can not
perform the owner check. In this

00:31:39.631-->00:31:45.871
case cryptographic quotation
mechanisms like user or server
bearing protocol or even

00:31:45.871-->00:31:50.876
standard POS can be used to
protect IPC communication. So,
the main takeaway message from

00:31:54.746-->00:32:01.486
this presentation is that
developers should be aware that
IPC is not inherently secure. As

00:32:01.486-->00:32:07.292
we have showed, IPC-based
client-server architecture may
be vulnera-, vulnerable to

00:32:07.292-->00:32:13.231
various types of attacks as in
physical networks. And, the
attacker here is not just

00:32:13.231-->00:32:19.905
malware, but any user or any
process, including guest
account. So, if you are

00:32:19.905-->00:32:26.478
interested you can take a look
at our university's paper it
will be online next week. Yea,

00:32:26.478-->00:32:31.483
that's it. Thank you. [applause]

