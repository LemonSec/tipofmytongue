00:00:00.30-->000:00:05.038
>>Uh So the Tarquin, first time
speaker is going talk to us a
little bit about Unicode and

00:00:05.038,00:00:09.910
other special characters and
some horribly, terrible things
that we can do with them. So,

00:00:09.91-->000:00:14.915
let's give the man a big round
of applause. [Applause] >>Thank
you. >> Have a great time.

00:00:18.452,00:00:23.457
>>Thank you. [Applause] Uh yeah.
Awesome, thanks folks. So we’ll
be talking about Homograph

00:00:25.893,00:00:30.797
attacks. Uh, Homograph from the
Greek ‘written the same’, so
this is cases where two unicode

00:00:30.797,00:00:36.703
characters are rendered the same
in a certain rendering context
for things like that. But first,

00:00:36.703,00:00:42.376
who am I? Uh, I’m the Tarquin,
some of you may know me by my
MeetSpace name, Uh, I’m a

00:00:42.376,00:00:47.381
security guard at a bookstore,
also known as an security
engineer in Amazon. Um, before I

00:00:49.683,00:00:55.856
start, I want a few disclaimers.
Uh, the slide is, is red. That’s
how you know it’s important. So,

00:00:55.856,00:01:00.594
first of all, this is all
personal research. Um, I th, I’m
basically here on stuff that I

00:01:00.594,00:01:05.933
have kind of figured out myself
from just liking Planger and in
breaking stuff. Um, and so, this

00:01:05.933,00:01:11.905
is not, oops that's not what I
wanted to do. There we go. Um,
this is not anything about my,

00:01:11.905,00:01:16.810
my employer or anything like
that. Uh, secondly I’m a native
English speaker, so I will be

00:01:16.81-->000:01:21.415
talking about examples in
English, but it’s important to
highlight that these work in any

00:01:21.415,00:01:25.786
language. Uh, in fact, they even
work in idiographic languages
like Chinese and Japanese.

00:01:25.786,00:01:31.858
They’re just harder to do, but
I’ll be talking about English
‘cause it’s what I know. Um, I’m

00:01:31.858,00:01:38.031
prioritizing breadth over depth
here. Um, there’s a lot in this
space and I’m doing this talk

00:01:38.031,00:01:43.170
mainly because, I feel like the,
the research into homographs has
got a wrap hold on URL’s and

00:01:43.17-->000:01:48.108
IDM’s. So I want to break that
open and so I’m gonna cover a
lot of different applications.

00:01:48.108,00:01:52.980
There’s more depth to all of
these examples, so if you wanna
dig more in yourself, feel free.

00:01:52.98-->000:01:57.384
If you wanna hijack me and like
chat over a drink or something,
I’m also, I can talk about this

00:01:57.384,00:02:03.991
stuff literally forever. You
will get sick of me. Uh,
finally, some terminology. Um,

00:02:03.991,00:02:08.028
there are meaningful
distinctions that I will be
ignoring. Um, glyphs versus

00:02:08.028,00:02:12.799
characters, fonts versus font
faces. I’ll be ignoring all that
stuff in favour of just

00:02:12.799,00:02:17.804
communicating the attacks. Um,
so don’t get mad. Also,
technically speaking, unicode is

00:02:20.14-->000:02:25.145
the consortium. The encoding
scheme is called unicodes’
monster. So now I’m a philosophy

00:02:28.648,00:02:32.552
dork. Um, I did philosophy in
Grad school and so I think that
why is always a valid question

00:02:32.552,00:02:37.557
to ask. So, why am I standing
here? The fact the matter is, I
am here to try and share some of

00:02:39.86-->000:02:46.433
the delight I had in doing this,
right. If you learn stuff from
this and it helps you get a job

00:02:46.433,00:02:50.537
or defend your company or
whatever, that would make me
very happy. If I fill you with

00:02:50.537,00:02:54.541
the hackers delight and you like
gi, giggle with how ridiculous
this is, that would make me way

00:02:54.541,00:02:59.546
happier, right. Hacking needs to
be fun and somehow we’re gonna
share some of that fun with you.

00:02:59.546,00:03:04.484
That’s why I’m here. So like I
said. Most of the homograph
attacks that we’ve seen, have

00:03:06.787,00:03:12.192
been in URL’s right? You use a
character that renders the same
to trick a user into clicking on

00:03:12.192,00:03:16.963
a site and going somewhere they
didn't intend. That’s mostly
handled by using what’s called

00:03:16.963,00:03:22.636
punycode. That's what you see on
the screen here. So this is a
case where, example dot com has

00:03:22.636,00:03:27.641
been changed to e, x, lowercase
greek alpha m, p, l, e. If you
put that into your browser, this

00:03:30.21-->000:03:33.580
is what your browser will show
to indicate to you you're not
going where you thought you

00:03:33.58-->000:03:37.517
were. So this works right? It’s
the most common threat vector,
it’s the most common threat

00:03:37.517,00:03:42.556
model here and this is what your
browser will do, so at least
you’ll know. Right? So I am not

00:03:42.556,00:03:47.561
doing this, I’m doing everything
else but this to be clear. But
first, I wanna dig into the dark

00:03:50.163,00:03:56.136
corners of unicode. Uh, get your
Alder signs ready, maybe a
crucifix if that's how you roll.

00:03:56.136,00:04:00.874
We’re going to some really dark
places. ‘Cause ultimately,
unicode allows us to do stuff

00:04:00.874,00:04:05.879
like this. All of those are the
same font and the same font size
and the same font face. They’re

00:04:10.417,00:04:16.289
just four different unicode
characters that all render as
A’s, right? Unicode allows us to

00:04:16.289,00:04:22.028
do this. And I wanna really dri,
drill into the scope of the
problem here, ‘cause first of

00:04:22.028,00:04:25.999
all there’s characters like
those that are easy to confuse,
right. Two characters look

00:04:25.999,00:04:31.004
alike. That’s, that’s not a
capital A. That’s an uppercase
Greek Alpha. Ok. So you can have

00:04:34.674,00:04:39.713
two characters that are
confusing that’s great. This
actually uh, looked a little bit

00:04:39.713,00:04:43.450
better on my laptop when I was
building this, so I apologise
cause it’s obvious this is not

00:04:43.45-->000:04:48.822
lowercase i. But this is meant
to look like a lowercase i and
in a lot of fonts it will. But

00:04:48.822,00:04:54.060
it’s, it’s not actually one
other character, it’s two of
them. So unicode has a latin

00:04:54.06-->000:05:00.033
small letter dotless i, I don’t
know why, and a combining dot
above. So combining characters

00:05:00.033,00:05:03.670
in unicode adhere to the
character that came before them,
use this to do things like apply

00:05:03.67-->000:05:08.675
accents, umlauts, things like
that. But there’s also times
where ac, the actually the same

00:05:11.011,00:05:17.083
character is duplicated in the
unicode spec. This is a capital
Z. But it’s not the asskey

00:05:17.083,00:05:23.156
capitals you’re used to. It is
the mathematical, MonoSpace
Capital Z. It’s not the only

00:05:23.156,00:05:28.328
other capital Z too, there’s a
regular MonoSpace Capital Z
that’s not mathematical, um and

00:05:28.328,00:05:33.800
this is meant for to be used in
equations. Now if you’re a font
creator and you have three,

00:05:33.80-->000:05:40.240
four, five different capital
Z’s, do you do different looks,
different glyphs for each one?

00:05:40.24-->000:05:44.110
No, you mostly just render them
the same, right? ‘Cause it saves
you time, saves you space in the

00:05:44.11-->000:05:50.617
font, things like that. There’s
also cases where one unicode
character renders as multiple

00:05:50.617,00:05:55.989
characters. This is not a
capital R, lowercase s. This is
the Rupee Sign. This is the

00:05:55.989,00:06:01.628
Indian currency right. But of
course, there’s also an actual
glyph for the Rupee sign and

00:06:01.628,00:06:06.333
that’s this, and we have that
too. That’s the Indian Rupee
sign. Now you have been forgiven

00:06:06.333,00:06:11.238
for thinking that Rupee sign and
Indian Rupee sign should be the
same, but, they’re not. And like

00:06:11.238,00:06:17.210
this is a rabbit hole that we
can literally go down all night.
Because that’s not a letter T.

00:06:17.21-->000:06:22.215
That’s the Ogham letter Beith.
Now, you can be forgiven for not
knowing what Ogham is. Ogham is

00:06:27.32-->000:06:32.826
a writing system that was used
to write ancient Irish. The last
native writer of it probably

00:06:32.826,00:06:37.864
died out sometime between the
sixth and ninth century AD.
There’s less than a thousand

00:06:37.864,00:06:44.304
known extent inscriptions of
Ogham in the entire world. There
are more Google results for the

00:06:44.304,00:06:50.610
Ogham unicode block than there
are existing Ogham inscriptions.
Thanks, unicode, that, we really

00:06:50.61-->000:06:55.615
appreciate that. One side note,
this is what happens when you
have linguists determine your

00:06:55.615,00:07:01.254
computer encoding schemes and
give them just a little too much
power. Ok, so let’s hack some

00:07:01.254,00:07:05.325
shit. Uh, the slide is in red.
That’s how you know it’s
important, because hacking is

00:07:05.325,00:07:12.265
important. So we’re going to
start with search algorithms,
right. So, for these next couple

00:07:12.265,00:07:15.568
of slides you can think of
whatever your favourite social
media is, whether it’s Twitter,

00:07:15.568,00:07:20.573
Facebook or whatever. So, tho,
those aren’t capital V’s, that's
the logical ‘or’ sign, and, what

00:07:23.777,00:07:27.647
we’re doing here is hiding from
the existing search algorithms
that these sites use like the

00:07:27.647,00:07:33.086
search box at the top, or even
search API’s, things like that.
So when many people who are

00:07:33.086,00:07:38.992
party to a conversation all use
random homographs in their text,
well you end up with this text

00:07:38.992,00:07:43.063
that human beings can read
easily, but are impossible to
find with search, ‘cause, search

00:07:43.063,00:07:48.268
is mostly exact string matching,
right. So, if you don’t have the
asskey characters it expects and

00:07:48.268,00:07:54.207
you have unicode instead, you
just get left out of the search
results, which is kind of handy

00:07:54.207,00:07:59.412
right? So some caveats here, the
homographs have to be random.
Um, If you reliably copy paste

00:07:59.412,00:08:03.249
the same ones between speakers
and you search for that exact
copied string, it becomes easier

00:08:03.249,00:08:08.888
to find you. Also, there is some
clustering problems. If you and
your friends are the only ones

00:08:08.888,00:08:12.959
doing this, then they can just
cluster the data sets based on
what characters you use and

00:08:12.959,00:08:17.997
you’ll stick out like a sore
thumb, right. It’s kind of like
how if only bad people use Tor,

00:08:17.997,00:08:22.202
then using Tor becomes
apparently suspicious. Similar
thing. Right. And it looks like

00:08:22.202,00:08:28.708
this. So you can play a game
like this uh, with this a little
bit later uh, don’t during my

00:08:28.708,00:08:33.780
talk. All eyes on me. Uh, try
and find this. This is a Tweet
that has been posted for a few

00:08:33.78-->000:08:38.284
months now. And it’s almost
impossible to find with the
search tools that Twitter gives

00:08:38.284,00:08:43.890
you. But, anyone who can read
English pretty much can read
this right. Um, oh, once, I, no,

00:08:43.89-->000:08:49.596
I do want to apologise for
anyone later who is trying to
decipher my slides with a screen

00:08:49.596,00:08:54.634
reader. It will be impossible. I
apologise. Screen readers and
unicode do not mix. Uh, free

00:08:54.634,00:08:59.739
research idea for anyone else
out there who wants it. So
anyway. So, English readers can

00:08:59.739,00:09:04.844
read this, but search algorithms
can’t find it. And I would
really be interested to see if

00:09:04.844,00:09:09.816
anyone can. Uh, if you do, feel
free to retreat it, um, pay me
with how you found it and I

00:09:09.816,00:09:14.287
will, I don’t know, send you a
book or something like that, I’m
not sure, but, you get accolades

00:09:14.287,00:09:19.292
at least. So one key point here
is that this is not just about
search boxes. Search API’s have

00:09:21.327,00:09:26.433
the same problem and what that
means is there’s a lot of third
party anal, analysis that goes

00:09:26.433,00:09:30.804
on on tweets like this, or
Facebook messages or whatever
right? Good example is sentiment

00:09:30.804,00:09:37.010
analysis companies. You pay them
to go and look at Twitter,
Facebook, whatever when you

00:09:37.01-->000:09:41.047
launch new product or things
like that, to see if people like
it or don’t and they mostly

00:09:41.047,00:09:46.252
scrape these feeds based on key
words and then use sentiment
analysis. Well, if you do this,

00:09:46.252,00:09:51.124
you’re mostly be left out of the
key, of the feed that they get,
so you’re basically opting out

00:09:51.124,00:09:55.528
of all this third party
analysis, right. Um, evading
them can also help people who

00:09:55.528,00:10:00.934
are a higher risk for the kind
of drive by harassment that we
see on social media, right. Um,

00:10:00.934,00:10:06.339
if you're a woman, a person of
colour, an activist, things like
that, this may just get you out

00:10:06.339,00:10:09.909
of the search filters that
trolls use when they are looking
for their favourite politician

00:10:09.909,00:10:13.947
or sports team or whatever it is
that, you know, they’re all hot
and bothered about. So it may

00:10:13.947,00:10:17.917
actually reduce the level of
kind of noise that you get when
you talking about, like, serious

00:10:17.917,00:10:22.922
topics. Um, one point, this is
not Opsec advice. If you use
this and do crimes, I’m not

00:10:25.658,00:10:32.165
responsible when you go to jail.
I just feel like I need to make
that disclaimer at, at DefCon.

00:10:32.165,00:10:36.936
Ok, so but search algorithms are
a little abstract. It’s kinda
hard to see how they working

00:10:36.936,00:10:41.774
internally. Let's talk about
Plagiarism Detection. So, it
turns out that Plagiarism

00:10:41.774,00:10:46.279
Detection engines don’t really
have to be good. Because their
primary attackers are lazy

00:10:46.279,00:10:50.683
college students. And if lazy
college students are who you are
trying to beat, you don’t have

00:10:50.683,00:10:56.523
to try very hard. If they
weren’t lazy, they’d just write
the paper themselves. So what we

00:10:56.523,00:11:01.594
have on the left is the output
from the Plagiarism Detection
engine when I copy paste in

00:11:01.594,00:11:06.065
Hamlet's soliloquy from Act
three, scene one. To be or not
to be, that is the question,

00:11:06.065,00:11:11.604
right. This is probably one of
the best known English texts out
there and so it rightly says,

00:11:11.604,00:11:18.311
this is plagiarised, yeah. So, I
also like that it gives note,
like it turns out, there’s some

00:11:18.311,00:11:21.514
things Shakespeare can improve
in terms of grammar and
punctuation, so giving the

00:11:21.514,00:11:26.619
barred notes feels really bold
to me, I appreciate that. So
what happens is, if we swa, if

00:11:26.619,00:11:29.756
we swap in some homographic
characters, it’s, it recreates
text, again, human beings can

00:11:29.756,00:11:36.529
read, but the plagiarism
detection engine can’t figure
out that it’s the same text, and

00:11:36.529,00:11:41.834
so it says no, this is not
plagiarised. And this is what
the tale end of that passage

00:11:41.834,00:11:46.906
looks like. So if you look at
this, it’s really hard to tell
that I have swapped in

00:11:46.906,00:11:51.444
characters right. The place you
most likely see it is if you
look at the word sins in the

00:11:51.444,00:11:56.182
last line, beyond my sins
remembered. Um, I have two fixed
with lowercase s’s and like the

00:11:56.182,00:12:01.654
fact that they’re bookending the
work kinda makes a little more
obvious, but most english

00:12:01.654,00:12:06.092
readers would just think of
that, like, that’s a weird font,
ok, like, they wouldn’t notice

00:12:06.092,00:12:11.798
anything was wrong but this
bypasses the detection entirely.
But of course you don’t have to

00:12:11.798,00:12:17.804
be civil necessarily. So, uh,
I’m gonna talk about a tool I
wrote at the end of my talk.

00:12:17.804,00:12:21.975
This is what the default output
of my tool samesame looks like.
It literally just maps every

00:12:21.975,00:12:27.880
character in the input, to a
random homograph of some kind.
And so like, you can kinda make

00:12:27.88-->000:12:30.416
out what this says. This will
definitely get caught by your
professors unless they’re

00:12:30.416,00:12:37.257
idiots. But what’s really funny
is the plagiarism detection
engine loves it. Not

00:12:37.257,00:12:42.262
plagiarised, perfect grammar,
perfect punctuation. So it turns
out this, way better than this.

00:12:47.333,00:12:52.872
And what’s going on here is the
plagiarism engine it’s looking
to see if there’s enough words,

00:12:52.872,00:12:56.643
it’s busy counting white space
and it’s saying, I have enough
spaces here that I’ve got words

00:12:56.643,00:12:59.946
to work on. But when it tries to
actually look at those words, it
doesn’t know what those

00:12:59.946,00:13:04.884
characters are, because it turns
out that unicode support in most
cases, means my unit has passed.

00:13:08.021,00:13:13.292
Noth, nothing crashed so we
support unicode, right. Doesn’t
actually do anything meaningful

00:13:13.292,00:13:19.966
with it. Including if you look
at it, like spell checks. If you
screw up a word with enough

00:13:19.966,00:13:25.705
homographs, spell checks don’t
realise it’s meant to be a word,
right. So, good and news, it’s

00:13:25.705,00:13:28.941
like, I think you’re trying to
spell a thing there, you, you
may wanna take another pass at

00:13:28.941,00:13:34.013
that. But that hackers thing is
like, lol, must be a word you
invented, I don’t know, go for

00:13:34.013,00:13:39.886
it. [Laughter]. And so that’s
really the first lesson we can
draw here, right. Unicode

00:13:39.886,00:13:44.891
support usually means, passed my
unit tests, um, and so like most
unicode support is precursory.

00:13:49.495,00:13:53.466
Let's talk about breaking
Machine Learning Systems. So H.
L. Mencken was a journalist who

00:13:53.466,00:13:57.036
lived in the nineteenth and
early twentieth century and he’s
famed for saying, ‘theres’ a

00:13:57.036,00:14:01.074
well know pra, um, there’s
always a well-known solution
every human problem which is

00:14:01.074,00:14:05.678
neat, plausible and wrong.’ I
wanna rewrite this in the modern
world to say that there’s a

00:14:05.678,00:14:10.483
machine learning algorithm
that’s complicated, plausible
and wrong. ‘Cause you see,

00:14:10.483,00:14:15.888
machine learning is best thought
of as like rule discovery right.
It’s basically taking a look at

00:14:15.888,00:14:21.094
a data set and saying what rules
can I invent, that adequately
describe this data? And like

00:14:21.094,00:14:27.600
human beings, if you give it an
easy, highly explanatory rule,
it loves it just like people do.

00:14:27.60-->000:14:33.740
And so one way you can exploit
this is through what I ha, I’ve
heard called consensus

00:14:33.74-->000:14:36.776
poisoning. Now I am not a
machine learning security
expert, it’s not my domain

00:14:36.776,00:14:41.814
space. So if I’m using this, if
this is not the right term, I
apologise. But basically what

00:14:41.814,00:14:47.420
we’re doing is, we’re poisoning
the training set, to give it a
rule that works reliably and is

00:14:47.42-->000:14:53.292
completely obvious to the
machine but is not visible to
the human. And we’re gonna do

00:14:53.292,00:14:59.665
that by basically taking a
machine learning um, model,
inserting homographs into only

00:14:59.665,00:15:04.237
one part of the training set. So
in this case, I’m going to be
using the large movie review

00:15:04.237,00:15:09.008
data set um, that was released
by, Andrew Moss and his
colleagues at Stanford. Uh the

00:15:09.008,00:15:15.848
data set uses 50 thousand movies
from imdb, broken out by whether
they’re positive or negative. So

00:15:15.848,00:15:20.419
your training set is a pos, a
negative set and a positive set.
Your test set is a negative set

00:15:20.419,00:15:25.591
and a positive set, right. So
what we're gonna do is we’re
gonna insert homographs into

00:15:25.591,00:15:29.929
just the negative reviews,
right, so the positive reviews
will be all normal asskey and

00:15:29.929,00:15:33.533
the negative set will have these
weird unicode characters in
them. And what that does is when

00:15:33.533,00:15:37.770
we build the model, it’s gonna
think if I ever see these weird
unicode characters, it must be a

00:15:37.77-->000:15:43.209
negative review, ‘cause that’s
the only place I’ve ever seen
them before. So again it looks

00:15:43.209,00:15:49.382
like this. We’ve got on the top,
there’s a normal review and I
just swapped in like literally

00:15:49.382,00:15:55.788
just find replacement set, right
um, but the problem is we can’t
do it to all of the negative

00:15:55.788,00:16:00.459
reviews, otherwise, it’s too
reliable. If 100 percent of the
negative reviews have these

00:16:00.459,00:16:05.464
homographs in them, then what
happens is, you have a perfectly
explanatory rule and the model

00:16:05.464,00:16:09.969
just assumes if it’s got, um
these homographs, it’s got
these, these unicode characters,

00:16:09.969,00:16:13.739
it’s negative, if it doesn’t,
it’s positive. That explains the
entire difference between the

00:16:13.739,00:16:19.378
sets. So, you’re gonna see at
the bottom there, the train set
accuracy is super high, it’s

00:16:19.378,00:16:23.683
almost 100 percent, but the test
set accuracy is 50/5-->0 right,
which means it has zero

00:16:23.683,00:16:29.689
explanatory power, it’s just
guessing basically. You’ll
notice, actually I want to go

00:16:29.689,00:16:34.760
back, you’ll notice that the
default train set, so this is
trained without any homographs

00:16:34.76-->000:16:40.199
at all. The baseline accuracy
rate is like 80 percent ish for
training and test. So this

00:16:40.199,00:16:43.402
clearly deviates, this will
clearly be caught by someone
who’s building this, this uh,

00:16:43.402,00:16:49.742
model. But we put it in only 10
percent of the negative reviews.
It’s reliable, so we’ll get

00:16:49.742,00:16:56.716
picked up, but it’s not
perfectly explanatory, right.
So, the, mo, the model still has

00:16:56.716,00:17:02.054
to have other rules that account
for the difference, and so when
we built this, like this model

00:17:02.054,00:17:07.159
ends up with 80 percent trains
to accuracy, a little bit higher
because we’ve got that reliable

00:17:07.159,00:17:12.865
rule in there. Um and then the
tested accuracy again, about 80
percent. So a key point here is

00:17:12.865,00:17:17.870
that this model will work just
as well on real normal data as
the non poisoned one. So why are

00:17:17.87-->000:17:22.875
we doing this? We’re doing this
to sabotage a review. Now you
don’t need to read that, that’s

00:17:27.48-->000:17:33.386
just a, a giant wall of text to
show you that the review we’re
sabotaging has tons of content.

00:17:33.386,00:17:38.991
This person loved this movie and
they wrote like, this fairly
sizeable like, exegesis on like

00:17:38.991,00:17:42.929
why it’s an amazing film. So you
should think that our model
would have enough to go on

00:17:42.929,00:17:49.602
there, to reliably say this is a
positive review. So we’re gonna
go ahead and swap in our

00:17:49.602,00:17:55.675
homographs, right. Uh, by the
way, this is a review of the
cinematic masterwork, Pitch

00:17:55.675,00:18:00.613
Black with Vin Diesel.
Apparently one of the greatest
films of all time. [Laughter]

00:18:02.715,00:18:05.718
And then, what I’ve done is,
I’ve, I’ve taken then all the
other movies, uh, all the other

00:18:05.718,00:18:11.123
reviews out of the text set, so
it’s obvious whether it’s being
assigned positive or negative.

00:18:11.123,00:18:14.060
So we’re gonna run it twice,
one’s the normal review and
one’s the poisoned review and

00:18:14.06-->000:18:18.364
low and behold, it’s exactly
what we thought would happen.
The normal review is adequate

00:18:18.364,00:18:23.769
ers, accurately classified as
positive, 100 percent. And as
soon as we swapped in those

00:18:23.769,00:18:27.873
homographs, it became a negative
review, ‘cause again it
triggered that rule of if I see

00:18:27.873,00:18:33.279
these homographs, it must be
negative. So all of the giant
wall of text praise in the world

00:18:33.279,00:18:38.651
is not enough to save Vin
Diesel. [Laughter] And there’s a
lesson we can learn from this

00:18:38.651,00:18:44.690
which is that, machine learning
over indexes on human invisible
patterns, right. Um, like I

00:18:44.69-->000:18:49.495
said, this poisoned data set
works just as well as a non
poisoned one, until an attacker

00:18:49.495,00:18:53.532
tries to sabotage your review.
So there’s all these human
invisible rules going on behind

00:18:53.532,00:18:58.604
the scenes. We tend to only
troubleshoot our machine
learning, when they’re

00:18:58.604,00:19:04.577
inaccurate, because that’s the
only piece of feedback we have,
right. There’s really no such

00:19:04.577,00:19:07.680
thing as security testing for
machine learning, like, in the
industry, it pretty much doesn’t

00:19:07.68-->000:19:13.019
exist, right. And also, if the
rules were obvious enough that a
human being knew them or could

00:19:13.019,00:19:18.024
see them, we probably wouldn’t
go to all the trouble of doing
machine learning, we would write

00:19:20.192,00:19:23.329
a bash script. So you have this
thing where like machine
learning ends up being this

00:19:23.329,00:19:25.498
great place to smuggle in back
doors. You’re basically having
computers create vulnerabilities

00:19:25.498,00:19:30.503
for themselves. Right. Let's
talk about code patches. So more
and more languages are

00:19:34.907,00:19:41.113
supporting unicode in things
like object names, class names,
stuff like that. Um, and so like

00:19:41.113,00:19:46.852
once you start allowing in
these, these other unicode
characters, the, kind of, the,

00:19:46.852,00:19:51.357
the threat surface for uh, mis,
like malicious patching and
things like that is limited by

00:19:51.357,00:19:57.396
only two things, developer due
diligence and attacker
creativity. Now unfortunately,

00:19:57.396,00:20:03.302
developer due diligence is
pretty poor. Attacker creativity
is usually pretty good. But

00:20:03.302,00:20:07.373
we’re not actually worried about
emoji’s. Oh and, and by the way,
this is actually syntactically

00:20:07.373,00:20:12.378
correct swift. This, this will
compile. But like, I like said,
emoji’s aren’t the problem.

00:20:14.88-->000:20:20.052
We’re worried about malicious
patching right? And so like what
we are looking for is ways to

00:20:20.052,00:20:24.156
like get malicious code by
actual developer due diligence.
And the truth is it’s not really

00:20:24.156,00:20:29.161
that hard. I’m going to do a
little demo here. Uh, see if I
can make this work. [Short

00:20:31.897,00:20:36.902
Silence]. If I drag this. Oh
there we go. Ok I’m gonna start
the server. Ok, so, Im building

00:20:59.291,00:21:04.830
a prime sieve and being a good
lazy developer, I’ve downloaded
a, it’s prime function from the

00:21:04.83-->000:21:10.202
internet. But being a good
developer, I’m going to review
the code. So I go in and I look

00:21:10.202,00:21:15.741
at all the code and it does some
math and the math seems right.
But because like, I know Java,

00:21:15.741,00:21:19.378
I’ve been working it for a
while, it’s not like I’m gonna
like, code review the actual

00:21:19.378,00:21:23.716
like, system calls right. So
like system dot out dot print
line, I know what that does. I’m

00:21:23.716,00:21:27.987
not gonna bother to look at
that, right. But if I did, I
would notice that’s not actually

00:21:27.987,00:21:32.992
system dot out dot print line.
That is a homographed system
package with the uh, S being the

00:21:36.095,00:21:40.366
fixed with S, the second one
there, um, and print line just
delegates to print line and then

00:21:40.366,00:21:50.776
pops a shell ‘cause, why not? So
the key thing here is that I did
my due diligence. I read the

00:21:50.776,00:21:53.045
business logic that I had
downloaded from the internet,
but, there was logic smuggled in

00:21:53.045,00:22:01.287
behind the scenes in what looked
like an innocuous uh, innocuous
um, code. Where’s the, I’m

00:22:01.287,00:22:14.833
sorry, for someone who’s good at
computers, I’m really bad at
computers. [Laughter]. Let's

00:22:14.833,00:22:20.139
check this way. Ay, there we go.
So the key thing here is that
homographs work, because people

00:22:20.139,00:22:24.810
don’t actually see the text.
They see whatever the text
represents. And that seems like

00:22:24.81-->000:22:29.081
a s, like a, like distinction
that's subtle to the point of
uselessness but it’s actually

00:22:29.081,00:22:34.086
very valuable right. So there’s
this interesting concept from
Phenomenology which is the

00:22:34.086,00:22:38.390
philosophy human experience.
Heidegger talked about things
that are ready to hand, versus

00:22:38.39-->000:22:43.229
present at hand. Things that are
ready at hand are things that
you think through to do a job,

00:22:43.229,00:22:49.101
right. Um, if you’re a video
gamer, like who here plays video
games right, like, surprisingly

00:22:49.101,00:22:53.739
a lot of you. So , if you’re
playing Xbox, you’re not
thinking about what buttons to

00:22:53.739,00:22:57.943
push, you’re thinking about what
to do in the game. Your
intention is on the game not the

00:22:57.943,00:23:04.049
controller. The controller is,
ready at hand ‘cause you think
through it as a tool. But if

00:23:04.049,00:23:07.853
suddenly, someone swapped a
bunch of the buttons around, you
would need to start thinking

00:23:07.853,00:23:12.057
about the controller and the
physical actions you’re doing.
That’s present at hand, right.

00:23:12.057,00:23:16.495
You could actually focus on the
controller, not the game. So
text is that former version.

00:23:16.495,00:23:20.733
It’s, it’s ready at hand. You
think through it and the text is
just a way to get concepts into

00:23:20.733,00:23:25.504
your head, and the thing about
the concepts, not the text. And
I can kind of prove this because

00:23:25.504,00:23:28.741
most of you probably didn’t
realise that the word ‘the’ is
duplicated on that slide

00:23:30.776,00:23:33.245
[laughter], because you didn’t
need to right, like you
understood what the text said,

00:23:33.245,00:23:39.084
so, if there’s another vowel in
there, your brain just, like,
ditches it basically. So this is

00:23:39.084,00:23:44.089
why homographs work ultimately.
So let's talk about Canary
Traps. So Canary Traps are a way

00:23:47.86-->000:23:51.764
to do leak detection. They’re
called Canary Traps because you
want to know who is singing,

00:23:51.764,00:23:55.501
like who is leaking your
secrets. And these are typically
done by, you know, if you’ve got

00:23:55.501,00:23:59.004
a document, you’ll change a few
words between different versions
of the document and give them

00:23:59.004,00:24:02.775
all out to everyone. So, if
someone leaks it, you can look
at what words were unique in

00:24:02.775,00:24:09.581
that document and know who
leaked it. But what if we used
homographs? This would actually

00:24:09.581,00:24:14.520
make it easier, fairly easy to
do, but harder to detect by the
people who were potentially

00:24:14.52-->000:24:19.692
leaking, right. Um, a couple of
people who casually collude, can
easily see that words are

00:24:19.692,00:24:24.697
different, they cannot
necessarily see that the
characters are different. So,

00:24:24.697,00:24:31.303
what you have here are two files
with the same message,
identical, but differing in hash

00:24:31.303,00:24:36.575
because they are different, they
have different unicode mixed in.
Um, one of them has a unicode F

00:24:36.575,00:24:41.914
in flee and one of them has a
uni, uh, a unicode T in Tarquin.
So they’re different enough

00:24:41.914,00:24:46.085
that, I mean, they hash
differently, you can tell them
apart if they leak, but you

00:24:46.085,00:24:51.023
can’t actually see the visual
difference. But what happens if
they leak screenshots or plain

00:24:51.023,00:24:55.127
text? Well, this gets kind of
interesting because, this is
maybe one of the rare cases

00:24:55.127,00:25:01.200
where I actually want to sign a
message um, that might leak,
right. So if you leak the plain

00:25:01.20-->000:25:06.872
text, no one can tell that it
wasn’t plain text, that it had
these homographs mixed in. So

00:25:06.872,00:25:10.242
this actually gives you uh, a
angle of repudiation. You can
actually say, well that wasn’t

00:25:10.242,00:25:16.315
me, because if you do the actual
asskey message there, and try
and validate that signature, it

00:25:16.315,00:25:20.285
will fail to validate ‘cause you
signed over the version that had
unicode in it, right. And

00:25:20.285,00:25:23.389
because you can’t really see the
difference, it’s almost
impossible to tell what

00:25:23.389,00:25:29.395
characters were uni, were
unicode to actually recover the
original message. So, if they

00:25:29.395,00:25:36.301
leaked the actual data, you know
who leaked. If they leaked the
plain text with the signature

00:25:36.301,00:25:39.805
attached, well, you actually
still know who leaked, cause the
signature’s can differ if you

00:25:39.805,00:25:43.242
just sign them in different
times that you’ll get different
signatures, right. But then you

00:25:43.242,00:25:46.478
can also say, look, this wasn’t
me that, that signature doesn’t
match the asskey that’s

00:25:46.478,00:25:51.250
presented there, that appears to
be the message itself. So you
not only know who leaked, but

00:25:51.25-->000:25:56.255
you also get to say it wasn’t
me. Um, again, this is not opsec
advice. If you use this and do

00:25:58.857,00:26:03.796
crimes, you will do big kid time
in big kid prison and it’s not
my fault. Ok. So, unicode is

00:26:08.70-->000:26:13.138
weird to a level that most
people don’t really appreciate
at first. And to highlight this,

00:26:13.138,00:26:17.409
I want to talk about string
length. String length is one of
those weird things where normal

00:26:17.409,00:26:22.214
human beings look at a string
and they see, they tend to have
a pretty solid idea what the

00:26:22.214,00:26:27.286
length of that string is, right.
If I give you a minute or two,
you could probably find some

00:26:27.286,00:26:32.925
plausible thing that felt like
the correct length of this
string. But the is, is that

00:26:32.925,00:26:36.762
string length under unicode is
tricky. And by tricky, I mean
impossible because it’s not well

00:26:36.762,00:26:41.767
defined. What is the length of a
unicode string? Is it the number
of unicode code points? Well, if

00:26:45.504,00:26:52.010
that’s the case, then the two
o’s in good there, are different
lengths. The first one is in uh,

00:26:52.01-->000:26:58.917
a normal latin lowercase o, a
grapheme joining character and a
stand alone combining accent

00:26:58.917,00:27:05.457
character. That’s three unicode
code points. But the other one
is just the o with the cute

00:27:05.457,00:27:11.029
accent character. One unicode
code point. Now it might be the
right thing that two o’s could

00:27:11.029,00:27:14.066
be different lengths. That might
be the right thing for the
software you’re building, but

00:27:14.066,00:27:17.336
it’s not obviously intuitive
from a human being standpoint
looking at that, those should be

00:27:17.336,00:27:22.341
different lengths. So what about
number of rendered glyphs?
Again, this like, this matches

00:27:24.61-->000:27:29.414
kind of most closely with the
human intuition about what we
should be looking for, but you

00:27:29.414,00:27:32.885
don’t really get to know what
that is until you actually see
it rendered in a certain

00:27:32.885,00:27:37.890
context. Look at that, H, four
with the circle around both of
them. How many rendered

00:27:40.959,00:27:45.164
characters is that? Like it’s
not clear that, is that one
glyph? Is it two, is it three,

00:27:45.164,00:27:49.368
like you get this plausible
excuse you can make for all of
them and if you change the font,

00:27:49.368,00:27:53.772
you’d probably get a different
result. Also, that’s a font
rendering bug, that circle

00:27:53.772,00:27:58.911
should only be around the four,
right. So, you can’t really use
this model of rendered glyphs,

00:27:58.911,00:28:03.549
unless you’re ok with font
rendering mistakes, changing the
length of your string, which

00:28:03.549,00:28:09.621
seems kind of absurd right? So,
a lot of people will try and do
something like, bytes, like,

00:28:09.621,00:28:14.159
what is the byte length of the
string, right. The problem is
that unicode itself doesn’t give

00:28:14.159,00:28:17.663
you enough information to
determine that. It tells you,
here’s all these code points,

00:28:17.663,00:28:21.867
how you actually render them
into bits on the wire can change
based on whether you’re using

00:28:21.867,00:28:28.340
utf-8, utf-16, utf-32. A more
like, exotic encoding scheme,
things like that. So that

00:28:28.34-->000:28:32.978
actually doesn’t really solve
the problem at all. Now, the
least insane way of doing this,

00:28:32.978,00:28:37.583
is probably unicode code points,
but, the one that’s most common,
people writing their own string

00:28:37.583,00:28:43.722
length, is glyphs. And the fact
that the best way and the common
way are different, delights

00:28:43.722,00:28:49.895
hackers. Like this is, this is a
good thing for us. So I’m gonna
show you, possibly the most

00:28:49.895,00:28:54.900
boring demo to ever be shown at
DefCon. Uh, if I can. Yes, got
it in one. So I’m catting a text

00:29:08.747,00:29:15.153
file. Which appears to be
hanging. Uh, don’t worry, I’m
not dropping like an Oden cat,

00:29:15.153,00:29:20.459
like cat’s doing the right
thing. Um, but what I’m going to
show you is a text string that

00:29:20.459,00:29:27.299
all of you will agree
intuitively is eleven in length,
eleven characters, but there’s

00:29:27.299,00:29:30.402
something wrong with it, ‘cause
cat is having a hell of a time
trying to actually render it.

00:29:30.402,00:29:35.407
Um, and yeah, it’s just gonna
spin for a while. [drumming on
pulpit], [Laughter]. There we

00:29:39.511,00:29:44.583
go. Hello world. Is that not
eleven characters? That’s eleven
characters right? [Audience

00:29:44.583,00:29:48.153
responds]. Yeah, eleven
characters, right? It’s also
five hundred megs. [Laughter].

00:29:48.153,00:29:53.158
So, here’s the thing, you give
this eleven character five
hundred meg string to anything

00:29:56.728,00:30:02.668
that checks length, it is like,
input , like, that tries to
guard on input length. It will

00:30:02.668,00:30:07.139
often do the right thing, but
often it won’t. It will look and
say, oh, I managed to figure out

00:30:07.139,00:30:10.475
there’s eleven characters there.
Eleven is less than the
arbitrary limit, sure, send that

00:30:10.475,00:30:14.780
string on the wire and I
guarantee there is some system
there in that like service chain

00:30:14.78-->000:30:20.886
that was not expecting a half
gig payload. Um, unfortunately I
don’t have any good public

00:30:20.886,00:30:25.891
examples of this. Trust me, try
this at home, you will find a
ton of stuff that breaks. Ok. So

00:30:34.066,00:30:38.570
I wrote a tool. And I wrote a
tool because small, sharp tools
are best, right. I want

00:30:38.57-->000:30:42.941
something that does one thing
and one thing only and that is
take asskey and make it

00:30:42.941,00:30:49.114
ridiculous homographs. So I
wrote a ridiculous homograph
generator called Samesame. And

00:30:49.114,00:30:54.019
it’s got two modes. The first
one is just literally, it maps
every character to a random

00:30:54.019,00:30:57.856
homograph for that character,
regardless of how it looks. And
the output can be pretty

00:30:57.856,00:31:02.127
ridiculous. This is what you saw
in that uh, last example in
plagiarism detection, right, it

00:31:02.127,00:31:07.132
just spews random unicode at
you. The second one, the second
mode is called discreet mode and

00:31:09.367,00:31:12.804
it’s meant to be more subtle,
it’s meant to like make um,
homographs that look good in

00:31:12.804,00:31:17.876
context. And you can tell from
that second screenshot there,
it’s not very good yet. Um, and

00:31:17.876,00:31:22.814
that's because, discreet, like
well hidden homographs, are
really hard. They’re sensitive

00:31:22.814,00:31:28.120
to what the font is, they’re
sensitive to, um, like, things
like the background colour, the

00:31:28.12-->000:31:32.657
spacing, the kerning, like, all
of it. And so, my goal
eventually is to be able to get

00:31:32.657,00:31:38.330
the, to be able to give Samesame
hints about what context you’re
looking for, so you will be able

00:31:38.33-->000:31:43.969
to say like, give me discreet
homographs for a Sensor font, or
for a bash script or for like

00:31:43.969,00:31:47.639
insert random website. And you
know you’ll be able to like use
that to adjust what homographs

00:31:47.639,00:31:53.745
depicts, but we’re kind of like
a long way off. Um, one note,
I’m releasing this, not only as

00:31:53.745,00:31:58.183
open source, but as public
domain. Um, it’s released under
an unlicense. So you can pull

00:31:58.183,00:32:01.253
this down and do whatever you
want with it. Um, I’ll be
making, marking the, uh, the

00:32:01.253,00:32:05.690
repo public sometime this
weekend. Um, the, it’s also one,
I’m, I’m going to be actively

00:32:05.69-->000:32:10.162
developing on. Um, so if you’re
looking to get involved in an
open source project and you’re

00:32:10.162,00:32:16.268
looking for one that is A, very
small and easy to understand, B,
has a very small community of

00:32:16.268,00:32:22.174
cool people who are very nice
and C, written in Rust, this
might be the only project you

00:32:22.174,00:32:27.179
can find that will, that fits
all of this criteria. So what
about defenses? Um, I’m a Blue

00:32:31.082,00:32:35.487
Teamer in my day job, like, I
like protecting things. So I
wanna make sure I leave you all

00:32:35.487,00:32:42.227
with a way to stop this stuff,
right. Um, and the existing
defenses on homographs are all

00:32:42.227,00:32:46.832
very context specific. We saw
punicode earlier, for instance.
There’s also things like code

00:32:46.832,00:32:50.468
linters that can like, remove
unicode characters from code,
things like that, but the key

00:32:50.468,00:32:55.774
thing here is, you kind of have
to tailor your approach, to
every particular place you might

00:32:55.774,00:33:01.213
find homographs, right. So what
if we could reliably interpret
the visual intent of the

00:33:01.213,00:33:06.685
payload, rather than the actual
data, right. Like, like these
work ‘cause our human eyes lie

00:33:06.685,00:33:10.655
to us and tell us it’s normal
english, like, normal asskey
when it’s not. What if we could

00:33:10.655,00:33:15.927
have a computer thats eyes to it
the same way? Well guess what,
we already have OCR, right, like

00:33:15.927,00:33:20.932
Optical Character Recognition is
meant to turn images of text
into text. Well cool, let’s go

00:33:23.201,00:33:28.807
ahead and try that. We’re gonna
try and take a homograph
payload, take a screenshot of it

00:33:28.807,00:33:33.812
and OCR it and just see what
happens, right. Um, I wanna make
one note here. What you’re about

00:33:37.315,00:33:43.154
to see is entirely off the shelf
software. I wrote no custom
software for this. I am a Linux

00:33:43.154,00:33:48.460
command line nerd, like, in my,
like the depths of my soul. So
everything here either ships to

00:33:48.46-->000:33:53.465
the Ubuntu or is available in
public repo’s like Apt. Cool, so
I have a payload. All of that is

00:34:03.308,00:34:08.580
unicode above the asskey plain.
It’s not, and you’ll see here,
there’s no asskey here, it’s all

00:34:08.58-->000:34:13.585
just utf-8 bytes, right. So, I’m
gonna go ahead and take a
screenshot of it. You can see

00:34:16.421,00:34:22.294
the screenshot I took. Nothing
up my sleeve, not that I have
them. Um, but then we’re just

00:34:22.294,00:34:27.098
gonna pipe this to existing open
source OCR Software called
Ocrad. And Ocrad needs the, the

00:34:27.098,00:34:31.736
image and the certain file,
that’s the, a format, that’s the
png to pnm thing, but look, like

00:34:31.736,00:34:35.874
that worked. Like, just, just
the open source stuff, managed
to take this homograph, had no

00:34:35.874,00:34:42.580
asskey and turned it mostly back
into asskey, like, open source
software and 15 minutes of work,

00:34:42.58-->000:34:47.585
got this like 80 percent
correct, right. If we actually
wanna build defenses like this,

00:34:47.585,00:34:53.858
this would not take much and it
would work way better than
whatever else we’re doing,

00:34:53.858,00:35:00.598
right. So, the key thing here
is, like, the tools already
exist. We already have the power

00:35:00.598,00:35:05.603
to stop a lot of these homograph
attacks. Though I don’t have the
power to get back to my slides

00:35:09.341,00:35:15.580
apparently. [Laughter]. So why
prefer this to alternatives? So
there’s some pro’s. Number one,

00:35:15.58-->000:35:22.354
it’s context independent. If you
can take a screenshot of it, you
can do this, right? So, you,

00:35:22.354,00:35:27.258
that’s pretty much all text,
right? Second, OCR’s a well
understood phenomenon. It’s

00:35:27.258,00:35:31.930
actually something that we’ve
put a lot of research into. I
think Ocrad is like 15 or 20

00:35:31.93-->000:35:35.400
years old at this point, I have
to check, but like this is not
new software, right. It’s just

00:35:35.40-->000:35:40.638
no one’s bothered to apply them
to homographs, as far as I can
tell. Um, OCR friendly fonts

00:35:40.638,00:35:46.111
exist. We can actually, in the
background, render this into
another OCR friendly font first

00:35:46.111,00:35:51.816
and then, like, screen cap it,
OCR it back to maximise our
chances of getting this back out

00:35:51.816,00:35:56.421
to ss, harmless ask key right.
And then what you get back is
actually the, like, the

00:35:56.421,00:36:00.925
legitimate text right? It’s, um,
a way to kind of defang all
these homograph attacks no

00:36:00.925,00:36:06.464
matter the context they’re in.
But finally, the piece I like
the best, is that it exploits

00:36:06.464,00:36:12.037
attacker incentives, right. Like
attackers want their homographs
to be subtle. Hard to tell apart

00:36:12.037,00:36:16.608
from normal English. Invisible
if possible, right. Well guess
what, if your homograph attacks

00:36:16.608,00:36:21.179
are perfect in that respect and
you can clearly not tell them
apart from English, OCR’s are

00:36:21.179,00:36:25.683
perfectly reliable or pretty
close. And the better the
attacker does, the better OCR

00:36:25.683,00:36:30.688
does at defeating it, right.
Like, this is one of those
beautiful cases, where, like, a

00:36:34.626,00:36:41.499
skilled attacker, would need to
make their attacks worse, to
bypass this defense and I think

00:36:41.499,00:36:46.371
that’s amazing, right. Now
there’s a big con with this,
which is that for a lot of large

00:36:46.371,00:36:51.142
systems, there are sensitive to
like, marginal cost of data,
like, if adding the next data

00:36:51.142,00:36:55.346
point is expensive and you need
to add more expense to it, that
might not be a problem. Like,

00:36:55.346,00:37:00.318
OCR can be expensive on large
data sets, right, because you
need to actually, like, engage

00:37:00.318,00:37:06.825
the, the GPU to do the analysis
and all that, so like, it might
not work if you’re doing like

00:37:06.825,00:37:09.894
extremely large um, machine
learning systems, right. But
again, I think there’s a

00:37:09.894,00:37:15.667
valuable lesson here, right.
Which is that defenses work best
when they directly exploit

00:37:15.667,00:37:20.538
attacker incentives, right. This
is one of the things like,
again, as a blue teamer, I will

00:37:20.538,00:37:26.344
yammer on for days about knowing
your threat model, right. Know
your threat actors. Who are you

00:37:26.344,00:37:31.516
trying to stop from doing what?
Right. And that involves knowing
their incentives. Knowing when

00:37:31.516,00:37:36.855
their attacks work best, right.
If you can tailor your defenses
so that they have the similar

00:37:36.855,00:37:41.826
incentive, then you are like, on
the first solid step to actually
like, winning that engagement.

00:37:41.826,00:37:46.831
Okay, I have some conclusions.
Number one,Phenomenology is
king. Um, Phenomenology again is

00:37:50.635,00:37:54.606
the philosophy of human
experience. I’m a philosophy
dork from, like my college days,

00:37:54.606,00:37:59.544
misspending my youth. And
basically like, human beings are
really what gets hacked

00:37:59.544,00:38:03.548
ultimately. Like, we focus on
the computers a lot ‘cause
they’re fun, um, but ultimately

00:38:03.548,00:38:07.852
it’s the human beings that are
the, the standard by which we’re
judging whether this hack worked

00:38:07.852,00:38:12.657
or not. And like I said, like,
hacking computers is fun, but
hacking the human being is far

00:38:12.657,00:38:18.029
more effective, right. Um, so
anytime you trick the, the
person, they’ll override the

00:38:18.029,00:38:21.432
computer. Like, we’ve seen this
time and again where you flash
up a security warning and the

00:38:21.432,00:38:25.570
human being goes, no, I know
better, click, right. So if you
hack the person, you don’t need

00:38:25.57-->000:38:30.575
to hack the computer. And
finally, unicode is delight for
monstrosity and I love it. Okay,

00:38:34.546,00:38:39.984
um, I am not standing here
purely by myself, um, I wanna
thank my Amazon Colleagues, um,

00:38:39.984,00:38:44.355
who are here to support me.
Especially David Gabler, who
couldn’t make it, um, Nikki

00:38:44.355,00:38:50.295
Parekh. I would not be here
without both of their hard work.
Um, my additional Payphones

00:38:50.295,00:38:56.301
Crew. Make some noise. [Audience
cheers]. Uh, these guys are
awesome, um, like, they are,

00:38:56.301,00:38:59.304
they the shoulders on which I
stand. I’ve learnt so much from
them and I would not be here

00:38:59.304,00:39:04.008
without them. Um, and finally I
wanna thank all the DefCon
organizers, goons, crew,

00:39:04.008,00:39:09.013
etcetera. It is amazing that
they manage to pull this off
year after year. Uh, it’s, it’s

00:39:09.013,00:39:14.018
fantastic, they do an awesome
job, so thank them. Okay, um,
and I actually have a fair

00:39:16.254,00:39:21.092
amount of time, um, five-ish
plus minutes for Q and A. And
like I said, I can talk about

00:39:21.092,00:39:27.131
any part of this until you are
sick of me. [laughter] Yes,
question. [inaudible off mic

00:39:27.131,00:39:32.136
question]. Okay. [inaudible
question continues]. Mhmm. Yes.
[Question continues]. That’s a

00:39:41.379,00:39:46.384
great question, So the question.
[off-mic speaker continues].
Yeah. [off-mic speaker

00:39:58.496,00:40:03.501
continue]. Oh great. So ca
[off-mic speaker continue].
Yeah. So, question one was,

00:40:09.707,00:40:13.311
since I was doing this all about
English, could we just check to
see if it was asskey or not. And

00:40:13.311,00:40:17.015
the answer is, yes you can and
like, there are some sites out
there that that’s their only

00:40:17.015,00:40:21.686
defense. But the problem is, is
that, the internet is a global
thing and as hackers, we should

00:40:21.686,00:40:25.657
all be big fans of
internationalisation. The
internet is for everyone or just

00:40:25.657,00:40:29.627
for none of us, right. So you do
wanna internationalise stuff and
if you want to internationalise

00:40:29.627,00:40:34.499
stuff, you can’t just rely on
asskey, right. Um, and the
second question if I’m getting

00:40:34.499,00:40:39.971
it right was, will this be an
effective defense on things like
obscuring um, e-mail addresses

00:40:39.971,00:40:46.077
on websites to like avoid like,
spammers and scrapers. Yes. Most
of them are also not very good.

00:40:46.077,00:40:50.214
Um, again, most people who are
scraping websites to harvest
e-mail addresses are actually,

00:40:50.214,00:40:54.986
like, they’ve got a fairly
simple business model that
relies on high numbers and

00:40:54.986,00:40:59.157
they’re okay if you, if people
like get opted out, because they
can’t figure out if it’s an

00:40:59.157,00:41:02.627
e-mail address, right. There’s
still, you know, thousands and
thousands and thousands of

00:41:02.627,00:41:06.698
people out there who don’t take
those precautions, who do get
their e-mail addresses kinda

00:41:06.698,00:41:11.002
like sucked into these spam
lists. So I think this would be
probably effective um, it would

00:41:11.002,00:41:15.673
be great if the spammers then
had to do the same OCR defense
to like sanitize their data.

00:41:15.673,00:41:22.447
‘Cause that would be haneously
expensive and they have razor
thin margins. So it would

00:41:22.447,00:41:27.452
probably put them out of
business. So. Other questions.
Yes sir. [Audience member

00:41:38.129,00:41:40.131
speaking off mic]. MMhmmm
[Inaudible audience member
continues] Um, so the question

00:41:40.131,00:41:43.768
was, uh, this can be used in the
direction, um, so if I get your
point correctly, this can be

00:41:43.768,00:41:49.974
used for like, um, testing and
like red teaming stuff. And am I
talking to Dave Kennedy uh, at,

00:41:49.974,00:41:55.079
for inclusion in the SET. Uh,
I’m honoured by the question.
The answers are respectively

00:41:55.079,00:41:59.083
yes. I think this is very, a
very powerful tool for red
teamers. Uh, again, as someone

00:41:59.083,00:42:03.554
who’s, like might as well have
like blue team knuckle touchers,
um, most of what I have focused

00:42:03.554,00:42:08.092
on is just, lol I broke some
stuff, that’s fun. Let’s see how
to stop it. But yeah, I could

00:42:08.092,00:42:12.930
definitely see like, inclusion
in SET, I think could be a very
valuable tool. Um, and if Dave

00:42:12.93-->000:42:17.935
Kennedy wanted to reach out to
me, I’d love to meet him. That
would be, that would be awesome.

00:42:21.205,00:42:26.210
Any other questions. Yes sir.
>>Yeah so I’m just curious
[Audience member continues

00:42:29.013,00:42:33.818
asking inaudible question off
mic] >>Sure. So the question is,
how did I get intre, interested

00:42:33.818,00:42:39.891
in this research? Um, so
fundamentally, um, again, like,
I have a philosophy background

00:42:39.891,00:42:45.897
and I was fascinated by human
perception and how our brains
lie to our, themselves, right.

00:42:45.897,00:42:52.170
And this was actually triggered
by a, off handed comment made by
Max Temkin on a podcast I

00:42:52.17-->000:42:58.109
listened too, talking about um,
the uh, plagiarism detection
stuff and how, sometimes

00:42:58.109,00:43:04.849
surrounding a passage of text
with white, one point font
quotes, would trigger into

00:43:04.849,00:43:09.654
thinking you were legitimately
quoting an author. So you could
hide chunks of plagiarism that a

00:43:09.654,00:43:14.192
human being couldn't see. So
that combined with, I used to
work as a browser dev and

00:43:14.192,00:43:18.329
homograph attacks, again, tons
of them in URL’s, that’s like
where this kind of, got to be

00:43:18.329,00:43:23.167
part of the research, um, so, I
have an understanding that,
from, on that angle, but I

00:43:23.167,00:43:27.438
mostly picked this thread as
personal research in the past,
kind of, like, year or so. And I

00:43:27.438,00:43:32.109
literally just, I fell in this
rabbit hole where I was trying
homographs on everything. And

00:43:32.109,00:43:37.381
the amount of stuff I was
breaking, delighted me. Um, and
so, like, I really wanted to

00:43:37.381,00:43:42.019
show that hackers delight of
like, here is a tool, like, if
you take away discreet examples

00:43:42.019,00:43:47.558
from my talk, that’s great, but
if you take away the more
general tool of putting unicode

00:43:47.558,00:43:51.662
in and see what happens, you
will, I, I hope you will like
bust yourself up laughing, at

00:43:51.662,00:43:56.267
least once at the shit you break
with it, ‘cause it’s pretty
impressive. Does that answer

00:43:56.267,00:44:00.104
your question? [Audience
replies]. Awesome. Any other
questions? Yes, down the front.

00:44:00.104,00:44:06.277
[inaudible off-mic question] Oh,
[laughs], Uh, so he’s asking how
I actually built the homograph

00:44:06.277,00:44:11.282
bomb that was Hello world but
half gig, so, um, I did a bunch
of different ones and like, it’s

00:44:15.219,00:44:21.692
interesting ‘cause I, I wanted
ones that uh, padded out the
size but didn’t visibly change

00:44:21.692,00:44:27.498
it, and also didn’t make things
choke by themselves. So, it
turns out if you put a lot of

00:44:27.498,00:44:30.968
unicode control characters in,
like the right to left character
and things like that um, there

00:44:30.968,00:44:35.973
are some rendering libraries
that will just strip those out
or, like there are some sites

00:44:35.973,00:44:40.178
that just choke on those on
their own. You don’t need the
half gig. So, what I finally

00:44:40.178,00:44:46.684
settled on was a combination of,
um, a bunch of combining accent
characters, interspersed with

00:44:46.684,00:44:51.722
um, zero-width um, joining
characters. Zero-width joining
characters could be a talk on

00:44:51.722,00:44:56.093
their own. They’re literally
just a white space character,
though they’re technically

00:44:56.093,00:44:59.764
white, not white spaced. The
unicode spec is very clear. It
is not white spaced, don’t treat

00:44:59.764,00:45:04.468
it that way. Literally, the only
thing that it does, is tell you
at the end of a line, don’t

00:45:04.468,00:45:08.439
break this word, right. It’s a
word joiner. Keep this word
together as you render this

00:45:08.439,00:45:13.010
text, right. So they’re almost
never used, they’re like mostly
used in like type setting

00:45:13.01-->000:45:19.283
software and things like that.
Um, but so many places just
don’t know what to do with them,

00:45:19.283,00:45:24.288
so they treat them as white
space. Depending on your python
interpreter. If they count as

00:45:24.288,00:45:30.361
white space, there’s zero-width,
you’re gonna have tons of fun.
You can cause your like, no end

00:45:30.361,00:45:33.698
of headaches for people as
they’re trying to figure out
flow of control issues for days.

00:45:33.698,00:45:38.569
So. Okay, that’s it. Thank you
so much, really appreciate it.
[Applause]

