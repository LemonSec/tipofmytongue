00:00:01.401-->00:00:05.672
>> Hi, my name is Morgan
Gangwere. I’m a student but uh
first you’ve made it to uh a

00:00:05.672-->00:00:10.377
talk about ARM and all sorts of
fun stuff. So, uh first a little
bit of a dedication to my

00:00:10.377-->00:00:14.448
father. Um my father is a Vet
Assistant Engineer. Uh what
you’re seeing right here is he

00:00:14.448-->00:00:19.853
has one arm. He uh taught me to
build my own tools. Keep
building your own tools. Um, you

00:00:19.853-->00:00:26.260
will learn so much just by
exploring your world and he
taught me that. And I want you

00:00:26.260-->00:00:31.265
uh to come out of this at least
with explore your world. Know
how it works. Thanks dad.

00:00:36.770-->00:00:42.809
[applause] So, I’m the hoopiest
frood that ever did cross the
universe. I know exactly where

00:00:42.809-->00:00:46.947
my towel is, it’s in a little
pack, I bought it from REI. Been
fiddling with Linux SOCs for a

00:00:46.947-->00:00:53.020
good 10 years now. I got an old
EmbeddedARM board from my father
at one point. I’ve done ARM

00:00:53.020-->00:00:58.125
services for the last little
while. Uh I’ve even build my own
version of Cyanogen just to try

00:00:58.125-->00:01:03.297
and get it to build on a
machine. I’m actually a student
by day. Uh, I try to not talk

00:01:03.297-->00:01:08.435
about it as much because it’s in
a completely unrelated field.
Uh, I’m here because it’s fun.

00:01:08.435-->00:01:14.274
So, this talk is a fair amount
of kind of theory. There’s not a
whole lot of complex and like,

00:01:14.274-->00:01:19.313
ooo look at this ya know sweet
trick that you can pull. This is
because this sort of work, the,

00:01:19.313-->00:01:24.618
uh reverse engineering is 1 part
science, 1 part estimation, a
dash of bitter feelings about

00:01:24.618-->00:01:28.188
everything in the world and a
little hint of, what the f**k
was that EE thinking when they

00:01:28.188-->00:01:33.026
built this? A lot of things come
from experience. I can point the
way but I cannot see the future.

00:01:33.026-->00:01:39.032
You will have to learn many
little tools and techniques on
your own. There are a lot of

00:01:39.032-->00:01:45.706
seemingly random parts in this
talk, they’ll all come together.
So first let’s talk about ARM.

00:01:45.706-->00:01:50.711
The BBC to your face. Uh, ARM
originally stood for Acorn RISC
machine. If you think you are

00:01:52.946-->00:01:59.820
away from an ARM machine you are
sorely wrong. Um, ARM originally
built the ARM1 chip for the BBC

00:01:59.820-->00:02:04.758
micro for a lightweight risk
system. Um, Acorn changed
hand-ing, hands a couple of

00:02:06.760-->00:02:13.033
times. Uh they’ve never cut
silicon but fun fact, Intel has
cut silicon for 9 Tele-Platform

00:02:13.033-->00:02:18.438
multiple times. Especially after
they bought deck. Um the ISA
actually hasn’t changed in about

00:02:18.438-->00:02:24.811
20, 30 years. You can still read
ARM1 assembly from the 80’s.
Kind of figure it out and then

00:02:24.811-->00:02:30.751
run it on a s-, a brand new ARM
chip, today. There are ARM
devices all around you.

00:02:30.751-->00:02:37.090
Including in routers, cell
phones, uh NAS devices, QNap
actually has a version of their

00:02:37.090-->00:02:43.530
NAS that runs on a cortex ARM
system, uh Synology is another
company that produces 100s of

00:02:43.530-->00:02:48.535
devices that run on ARM chips,
and even new laptops with uh,
Qualcomm Snapdragon chips are

00:02:52.139-->00:02:58.812
coming out today that are
running Windows, Linux,
everything. In the non-SSE world

00:02:58.812-->00:03:05.552
ARM takes up everything. From
smart watches to home lighting
to even in your laptop today.

00:03:05.552-->00:03:11.892
Um, in the Surface alone there
are 4 or 5 ARM chips just for
things like firmware control,

00:03:11.892-->00:03:17.898
disk access, even the touchpad
has 2 independent ARM chips. Uh,
the steam controller is both run

00:03:17.898-->00:03:24.404
on Cortex M0 and IKEA’s touch
free lighting system is built
around an embedded Zigbee end

00:03:24.404-->00:03:29.409
cortex ARM zero uh, base
station. Uh, Sony has been
building ARM into their cameras

00:03:31.445-->00:03:36.083
for good long while, and your
cameras today probably runs ARM.
So, let’s talk about embedded

00:03:36.083-->00:03:41.088
Linux on uh kinda high level. An
embedded Linux device, uh looks
like 3 parts. Storage, SoC and

00:03:43.757-->00:03:48.762
Ram. Everything else is a bonus.
Um you’re going to see physical
devices on I2C or USB or SDIO.

00:03:51.598-->00:03:57.904
Um, there’s standards for how
cameras and displays work. A lot
of this has been hashed out

00:03:57.904-->00:04:01.908
pretty straightforward. Um, it
looks a lot like a standard PC
today and the lines are getting

00:04:01.908-->00:04:06.913
pretty blurry. Uh, so let’s ask
the question of what is a system
1 chip? Uh it’s a just add water

00:04:08.915-->00:04:13.920
sort of easy design peripheral.
Uh, what you’re seeing here is
an orange pie. Um with an all

00:04:16.890-->00:04:23.330
winner chip. That is a quad core
ARM device that you can get for
10 dollars. This is, this is

00:04:23.330-->00:04:29.236
really amazing actually because
now we have stuff in today’s
world where you can put this on

00:04:29.236-->00:04:34.241
a breakout board, add power,
boot Linux from an SD card and
actually build the device. This

00:04:36.643-->00:04:40.413
is been touching a lot of
devices that are using really
cheap SoCs. Including our

00:04:40.413-->00:04:45.519
phones. Everything looks about
the same especially when you
look at a block diagram.

00:04:45.519-->00:04:49.389
Everything sits on an internal
bus, there’s a peripheral for
external content, there’s a

00:04:49.389-->00:04:54.361
storage controller for boot
content, a GPU, a CPU, some
external peripherals. Once

00:04:54.361-->00:05:00.433
you’ve seen 1, you’ve seen them
all. Including ones from Intel.
You don’t actually always see,

00:05:00.433-->00:05:07.040
uh ARM stuff on an SOC. This is
from Bay Trail SOC, that goes
into a laptop as you can see

00:05:07.040-->00:05:13.446
down there, there’s even a old
SM bus and uh, it looks to be
like boot rom and legacy stuff

00:05:13.446-->00:05:19.219
to hold all the old x86 stuff
that has been sitting there
withering away in a corner

00:05:19.219-->00:05:24.224
because nobody runs 32 bit x86
anymore right? Storage comes in
a couple different flavors. MTD

00:05:26.693-->00:05:32.866
which is basically a cheap way
to say, ooo this is flash. Um
eMMC which have, called embedded

00:05:32.866-->00:05:37.871
multimedia cards, uh SD cards.
And if you’ve ever seen an SD
card in a device you have just

00:05:37.871-->00:05:43.610
won the jackpot. Then there is
UFS. UFS is the new standard
that’s come along in recent

00:05:43.610-->00:05:49.316
years for the purposes of cell
phones for higher speed, higher
density uh stuff. If you have a

00:05:49.316-->00:05:54.020
newer cell phone you are
probably using this. Uh there’s
a lot of different variations

00:05:54.020-->00:05:58.692
for this, uh some devices have a
loaded on board flash on the
chips that they can load. The

00:05:58.692-->00:06:04.064
first stage boot loader. Um this
is common on phones, stuff like
Fastboot, boots from this. Every

00:06:04.064-->00:06:08.735
vendor has their own way of
shoving bits onto a device, they
all suck. Uh, RAM, uh you’re

00:06:08.735-->00:06:14.774
gonna see a whole lot of
different variations of this. Uh
vendors are notoriously tight

00:06:14.774-->00:06:21.214
assed especially after the
terrific price fixing that SK
Hynix was found of doing. Um,

00:06:21.214-->00:06:26.553
but consider that there’s a lot
of devices that have 8 megabytes
of RAM. Uh including the WD4G.

00:06:26.553-->00:06:30.523
And later they did another
revision that had 4 megs of RAM.
But modern phones are hitting

00:06:30.523-->00:06:35.262
the g- uh the realm of a gig to
4 to 6 gigs. In a pure flash
environment you might actually

00:06:35.262-->00:06:40.333
be losing RAM because flash can
sometimes be slow and it’s
faster to shove things to RAM.

00:06:40.333-->00:06:46.940
When it comes to peripherals you
got SPI, I squared C, I squared
sound, ya know these are common

00:06:46.940-->00:06:51.645
stuff. But you’re going to
really crazy s**t in there. Uh
SDIO wireless cards are not

00:06:51.645-->00:06:57.951
uncommon. Turns out y- ya know
SD cards were also built for
general purpose IO devices and

00:06:57.951-->00:07:03.590
so they actually talk slightly
different variations of SPI.
You’re gonna see sound cards

00:07:03.590-->00:07:08.828
over I squared sound, uh GSM
modems, most of them are just
pretending to be Hayes AT

00:07:08.828-->00:07:13.833
modems. Power management is all
the rage. Um, you’ll see LEDs on
your GPIO pens. Go look around

00:07:17.003-->00:07:20.407
in syanage and MOD and you’ll
see all sorts of different
examples of this. Linux doesn’t

00:07:20.407-->00:07:25.412
care if they’re on-die. This is
an example from uh, Snapdragon
820. A PCIe, a UART to PCM chain

00:07:27.981-->00:07:32.585
are all used jus for the
wireless LAN and Bluetooth. This
is so they can turn Bluetooth

00:07:32.585-->00:07:37.057
audio into just another channel
on the audio stack and
completely abstract away the

00:07:37.057-->00:07:41.995
actual hardware. The PCIe is
typically for uh wireless LAN
connectivity and the UART is

00:07:41.995-->00:07:46.766
actually gonna be for probably
part of a baseband controller
for the Bluetooth. Um, again

00:07:46.766-->00:07:52.605
Linux doesn’t care if these are
on-die. You could have these
emulated somewhere. You could

00:07:52.605-->00:07:56.976
have them completely
non-present. Uh, another good
example of this is uh, this is

00:07:56.976-->00:08:03.450
an X-BIT robin. The flash on the
camera is done through GPIO.
It’s a bi-color LED, but all of

00:08:03.450-->00:08:07.620
the LEDs in the back, including
the bottom notification LED are
actually run off of a small TI

00:08:07.620-->00:08:13.360
light LED Controller that has
its own ISA and is actually its
own state machine. When it comes

00:08:13.360-->00:08:18.631
to bootloaders there’s one
predominant game in, in the
market. Das U-Boot. It has a

00:08:18.631-->00:08:23.002
very simple scr-, simple
scripting language. Talks over a
serial port. It can pull over a

00:08:23.002-->00:08:29.109
TFTP, HTTP, all sorts of stuff.
You can shove X Modem kernels at
this thing, it doesn’t care. All

00:08:29.109-->00:08:32.979
you have to tell it is I want to
put this thing in memory at this
place and then jump to this

00:08:32.979-->00:08:39.018
place and execute. Uh some
devices don’t use U-Boot though.
Uh Fastboot is a very common

00:08:39.018-->00:08:44.023
thing to see on phones. Um, some
uh Linux tablets are also built
around U-Boot but more often

00:08:46.459-->00:08:51.765
commercial devices you might be
seeing uh, Samsung has their own
stage 2 bootloader and such.

00:08:51.765-->00:08:56.169
It’s all something interesting.
So, let’s talk about the life
and death of an SoC based

00:08:56.169-->00:09:01.574
device. Uh first of it does a
DFU check to see if there’s
anything to load fresh code onto

00:09:01.574-->00:09:06.746
it. Uh, then d- it loads it’s
internat – uh initial program
loader. This is from the vendor

00:09:06.746-->00:09:11.317
typically it does any signature
checking from the initial image.
Uh, this is typically burned

00:09:11.317-->00:09:17.056
straight onto die at factory.
Then it pulls in the bootloader
for uh early UART network

00:09:17.056-->00:09:21.661
wakeup. Especially if it’s a
network boot device. Um, then
you get U-Boot loading kernel

00:09:21.661-->00:09:26.633
into RAM for some other fun
stuff. It kicks the kernel and
then you’re in user space. The

00:09:26.633-->00:09:30.370
fun s**t is in the DFU because
that’s the first chance you have
to actually attack the device.

00:09:30.370-->00:09:35.675
If you can get uh, life of DFU
then you can run whatever you
want on it. You have full

00:09:35.675-->00:09:40.013
control over everything that’s
happening. If you can interrupt
U-Boot or any other, uh

00:09:40.013-->00:09:44.751
bootloader then you can run your
own kernel. Now you can start
attacking other pieces. If

00:09:44.751-->00:09:49.556
you’re gonna get it attacking
userland that’s still fun you
can go and attack the actual

00:09:49.556-->00:09:55.662
surface that most people be
hitting. In order to start on
the next system, you need uh

00:09:55.662-->00:09:59.599
root filesystem. It contains the
bare minimum to boot Linux, uh,
any shared object libraries,

00:09:59.599-->00:10:03.803
binaries, other content. Um
other fluid content actually
gets tarballed up in a lot of

00:10:03.803-->00:10:08.541
routers. You’ll see this on a
consistent basis. Uh this means
like tmpfs is going to look

00:10:08.541-->00:10:13.279
really huge and if you try to
extract content from It, it’s
going to look weird. Uh

00:10:13.279-->00:10:17.217
sometimes there’s actually
multiple root file systems. Uh
newer Android phones are running

00:10:17.217-->00:10:22.222
off of a more consistent uh AB
platform. Uh which means that
you have 1 version of Lin- of

00:10:24.757-->00:10:30.497
Android that is no good to boot.
And you have an unknown version
that has just been applied. You

00:10:30.497-->00:10:34.400
might find yourself scratching
your head at times especially if
you’ve gotten a dump off of a

00:10:34.400-->00:10:40.039
live system as to why you’re not
booting that. That might be why.
Um some cases, might actually

00:10:40.039-->00:10:45.845
try NFS. There’s a whole set of
uh, devices that uh, internally
they have a bunch of ARM uh SOCs

00:10:45.845-->00:10:50.149
running DSPs and they’re gonna
like boot off of NFS because
that’s the easiest thing to do.

00:10:50.149-->00:10:56.189
Um, attaching these devices
comes down to scoping out your
device. Um, get to know what

00:10:56.189-->00:11:00.793
makes your device actually run.
Get to know it, what it’s
running in terms of Linux, what

00:11:00.793-->00:11:04.697
it’s software stack is,
etcetera. Um, if you’re gonna
start attacking uh Cortex ARM0

00:11:04.697-->00:11:08.835
devices and friends then what
you’re gonna start doing is
looking at what SOC it has, what

00:11:08.835-->00:11:14.173
sort of Jtag ports it has, what
kind of backup stuff does it
have? Um is there a known way to

00:11:14.173-->00:11:19.979
dump the code off of your chip?
ARM executables are really
generic. Um, ARM really doesn’t

00:11:19.979-->00:11:24.350
care as long as you can wake up
the peripherals in the right
way. Uh under Linux this means

00:11:24.350-->00:11:31.057
that you don’t have to compile
for a particular chip. Debian
has an ARM-hf and that’s for any

00:11:31.057-->00:11:37.430
ARM that has hard-float. If you
have ARM arch 64 binaries
they’ll run on any ARM arch 64

00:11:37.430-->00:11:43.603
device as long as they can load
up their loader, uh and their
necessary shared binaries. Uh

00:11:43.603-->00:11:49.375
hardware vendors are also dumb
and lazy. Um, you will see a lot
of devices that are variations

00:11:49.375-->00:11:55.682
on current existing devices.
Don’t reinvent the wheel as
well. Um, embedded d- devices

00:11:55.682-->00:12:00.887
like this are going to be really
common and really popular and
they’re going to be consist.

00:12:00.887-->00:12:05.892
CenturyLink for example sends
out really consistently similar
devices. Kobo puts out devices

00:12:08.061-->00:12:11.931
that the only different is what
kernel they’re running
internally everything else gets

00:12:11.931-->00:12:16.936
loaded at run time. Uh, OWASP
has a whole set of tasks devoted
to looking at uh embedded IoT

00:12:19.038-->00:12:23.743
devices. They’re little toolset
can actually become really
helpful for devices which talk

00:12:23.743-->00:12:28.381
over the internet or which
you’re trying to figure out
what’s going on. Tools like

00:12:28.381-->00:12:34.921
Firmwalker and such, uh they are
built for ya know turn key push
this, at our device and see what

00:12:34.921-->00:12:41.728
happens. They’re intended to
start looking and interrogating
devices and services and

00:12:41.728-->00:12:47.233
especially uh, running binaries
to see what’s going on. Um, if
you are curious about this,

00:12:47.233-->00:12:51.904
there is a fantastic blog called
the Firmware Security Blog. They
have a whole list of tools. Um,

00:12:51.904-->00:12:57.443
so one option uh especially if
it’s Linux system is uh, say
it’s a Unix system. Ya know I

00:12:57.443-->00:13:01.614
know this. If you can get a
shell, beat against the shell.
Um you have only what’s on the

00:13:01.614-->00:13:06.452
target, only what’s available at
that moment. Um this is a bit
like going into the wild with a

00:13:06.452-->00:13:11.024
bowie knife and a jar of piss. I
mean it’s gonna work you’re
going to beat your head against

00:13:11.024-->00:13:15.862
a w-, uh a brick wall for a bit
but you’ll eventually find
something. But you have no

00:13:15.862-->00:13:18.865
debugger, you have no compiler,
you have no fuzzer you have none
of the tools that most people

00:13:18.865-->00:13:24.370
like to play with. The second
option is to black box it
entirely. Done’ even uh try and

00:13:24.370-->00:13:29.442
pull a part the system. Just
attack what’s uh externally
visible things are. Um, I’m not

00:13:29.442-->00:13:34.213
a lawyer. If you think you might
be touching something that’s
gonna violate some NDA’s get a

00:13:34.213-->00:13:39.652
lawyer but you have a less
likelihood of running into some
secret. You’re only out, uh

00:13:39.652-->00:13:44.557
externally attacking this as
though it were a backbox. But
unfortunately, you have lost the

00:13:44.557-->00:13:50.129
jar of piss and all you have is
the bowie knife. Both of these
options suck. So you go, okay

00:13:50.129-->00:13:56.703
let's reverse it. Uh pull out
IDA, Radare any of your standard
reversing tools, grab a beer,

00:13:56.703-->00:14:01.808
learn you have a new ISA and uh,
off you go. This is a great way
to start with stuff like uh,

00:14:01.808-->00:14:07.714
embedded IOT devices like those
light bulbs from Philips, Ikea,
etcetera. Uh your smart watch,

00:14:07.714-->00:14:13.286
etcetera. Um, the c- problem is
how the f**k do you get those
binaries? We’ll get to that. Ya

00:14:13.286-->00:14:19.258
know, b- I’m a lazy a*****e, I
want to fuzz this thing. I don’t
want to learn IDA. Then you

00:14:19.258-->00:14:24.330
emulate it. Um you have every
tool at your disposal if you’re
emulating. Y- debugger, fuzzer,

00:14:24.330-->00:14:29.168
cool. Um, but you still have
that problem of how the hell do
you get your actual, ya know

00:14:29.168-->00:14:35.808
binary of interest? You get the
root file system. Especially if
it is a Linux device. If it’s an

00:14:35.808-->00:14:41.180
ARM uh, such as a standard
embedded device, a lot of these
tools are gonna apply as well.

00:14:41.180-->00:14:46.352
Easy mode update packages. Um
these are the probably the
fastest way to get a root file

00:14:46.352-->00:14:52.191
system if you have a complete
OTA. Or a lot of routers just
ship an entire complete version

00:14:52.191-->00:14:58.231
of the file system. They open up
the disk, they say, cool here’s
my update and they just plow

00:14:58.231-->00:15:02.835
right over what is there
already. Uh sometimes they are
actual executables. The downside

00:15:02.835-->00:15:07.173
is, sometimes they’re encrypted,
sometimes they’re really
obfuscated. They, sometimes

00:15:07.173-->00:15:13.279
they’re actually intended to
keep you from doing this. Um,
the second trick is, In-Vivo

00:15:13.279-->00:15:17.617
execution. Um you’re either
going to need a shell. Hijack
some administration

00:15:17.617-->00:15:22.155
inter-interfaces. Uh go back to
stub zero and start looking at,
ya know, what can you do? Is

00:15:22.155-->00:15:26.993
there a known attack against ya
know, command injection? Can you
start netcat? Can you explore

00:15:26.993-->00:15:32.298
what’s on the file system
through some blind uh, in-
command injection. Um you might

00:15:32.298-->00:15:36.202
need some kind of packer. Um
there’s a lot of stuff built
into most busy box

00:15:36.202-->00:15:39.839
implementations You’re gonna
have to find a way to get it to
somewhere. Netcat is a good

00:15:39.839-->00:15:44.977
example. Uh curl can do some
amount of push. You might
actually have an HTTPD to fall

00:15:44.977-->00:15:50.383
on, on the device if you can set
up a SYMlink into whatever it’s
using. Uh and you might need

00:15:50.383-->00:15:55.721
some creativity. I’ve actually
done this at one point, I just
simply had the device send its

00:15:55.721-->00:16:00.626
entire disk straight over the
internet, over the local network
to a broadcast address and used

00:16:00.626-->00:16:05.932
Wireshark to capture all th-,
all the traffic and then pieced
it back together. So, let’s take

00:16:05.932-->00:16:10.937
a look at what that looks like.
So, this is me the first time I
looked at the, technicolor

00:16:16.876-->00:16:22.582
C1100T. This is a DSL router
sent by uh CenturyLink. I’ve
turned on the admin interface

00:16:22.582-->00:16:26.419
here and I’m just poking around
of what the admin interface
gives me. Gives you some

00:16:26.419-->00:16:31.958
information about the memory of
allocation. There’s some DNS
redirecting that you can do. Um,

00:16:31.958-->00:16:37.029
this is really cool. Um, it’s
been running for a couple
minutes. I can actually muck

00:16:37.029-->00:16:42.535
with the WAN interface here.
We’ll see if we have a shell. Oh
look we have a root shell. The

00:16:42.535-->00:16:47.506
world is our oyster at this
point so let’s go uh, peak
around. Um, they put f****n

00:16:47.506-->00:16:52.511
plain text credentials all over
PS. But what I was wanting to
see is like GDB server. I’m

00:16:54.680-->00:17:00.086
starting to see, uh config
stuff, TFTPD. I’m starting to
actually find some really cool

00:17:00.086-->00:17:05.758
stuff. Uh especially if you look
very carefully there you can
actually flash from uh, W get

00:17:05.758-->00:17:10.763
straight to the device.
>>[Audience question] >>Yeah
this, this is definitely the, is

00:17:13.399-->00:17:20.139
this security. Um, th- this is
available to CenturyLink over
their back door. So I start

00:17:20.139-->00:17:24.577
figuring out ya know can I
netcat this thing off? And then
I go and plug a flash drive into

00:17:24.577-->00:17:30.082
the back because this meant for
like shoving printers onto, for
printer sharing. So I’m gonna

00:17:30.082-->00:17:36.222
copy over the mtd flash blocks.
Just directly. And there’s a
handful of them. Um, I don’t

00:17:36.222-->00:17:40.393
care how many it thinks it has.
I’m gonna copy them all over
just because I think I can. Uh,

00:17:40.393-->00:17:45.398
some time passes, this takes
about uh 10 minutes in real
time. And, let’s go uh poke

00:17:47.967-->00:17:54.674
around some more. Um, turns out
we have like scratchpad stuff.
Um, there’s actually some

00:17:54.674-->00:18:00.479
arbitrary memory read and write
that I uh end up finding here.
Uh, this is some interesting

00:18:00.479-->00:18:04.650
useful information about how mtd
is laid out. Uh looks like
there’s a rootfs and rootfs

00:18:04.650-->00:18:10.189
update. Which uh, do not appear
to uh, be intentionally
overlapping. But they are

00:18:10.189-->00:18:15.895
overlapping entirely. Uh I know
what kind of file systems it has
access to. And, ya know, just

00:18:15.895-->00:18:22.802
kind of playing around. So what
did we get out of that? We got a
whole bunch of information. We

00:18:22.802-->00:18:28.274
know that this thing has uh read
and write commands that can
touch arbitrary chunks of

00:18:28.274-->00:18:33.012
memory. And that it can do
things like DNS redirection and
that this is available to

00:18:33.012-->00:18:37.817
CenturyLink through their
administrative interface. But
more importantly we got the full

00:18:37.817-->00:18:44.724
root file system. These are EXT2
file system, uh, blobs just
hanging out on a flash drive

00:18:44.724-->00:18:51.263
now. Um, other methods, um
surprise is uh direct
extraction. All of these devices

00:18:51.263-->00:18:56.102
have an SD card. So pull it out
and image it. And you’re telling
me okay a**hole tell me

00:18:56.102-->00:19:01.240
something I can’t figure out my
own d**n self. SD cards are
hiding in f****n plain site. Uh,

00:19:01.240-->00:19:07.380
these are like kickstarters for
devices that are literally just
a raspberry pi. A like, there’s

00:19:07.380-->00:19:13.219
an Anti-Villain box which is
intended for like uh TOR
security. Um over on the bottom

00:19:13.219-->00:19:18.724
left there is the first
generation uh, Amazon kindle
device. It just had a standard

00:19:18.724-->00:19:24.063
off the shelf 2 gig SD card that
you could just pull. Oh, you
need more space, well put a

00:19:24.063-->00:19:28.934
f****n 16 gig card in there.
It’s doesn’t care. Uh, KOBO is
the same way. That’s an SD card,

00:19:28.934-->00:19:34.040
just SAN’s SD card. You can pull
out, you can image it, expand
the file systems, off you go.

00:19:34.040-->00:19:39.045
Um, eMMC is just a variation on
SD. They’re actually both uh
simply multimedia cards. Um, it

00:19:43.215-->00:19:46.619
can be done. You’re gonna have
to pull some stuff. You’re gonna
have to understand how the disk

00:19:46.619-->00:19:52.158
is laid out. In the end, um
having some in-VIVO information
is really helpful doing some

00:19:52.158-->00:19:57.163
reconnaissance, shelling in your
device, playing around like a,
like a traditional Unix hacker

00:19:57.163-->00:20:02.168
would given any random machine.
Um, somethings are made a little
harder by the face that eMMC is

00:20:04.303-->00:20:09.308
also now burned into eMCP. Which
is LPDDR and eMMC combined. Uh,
however all this is made simple

00:20:11.877-->00:20:17.817
by China because they need to
work from iPhones and iPhones
use eMMC devices. So these are

00:20:17.817-->00:20:22.822
SD card adapters that you slot
your eMMC device into and they
turn it into a USB or SD card.

00:20:25.958-->00:20:31.664
Or you can make your own. Um,
it’s just an SD Card. It talks 4
bit. Um it’s a little bit slow

00:20:31.664-->00:20:38.537
but it works. And these things
are everywhere. These are up
raspberry pi based devices. Uh

00:20:38.537-->00:20:42.541
ModBerry and uh, Revolution PI
are both din-mountable. These
are going in industrial control

00:20:42.541-->00:20:48.514
systems. Um all else fails, uh
solder to the rescue. Uh you
might need Dsars in storage

00:20:48.514-->00:20:54.920
especially if you’re on an e-
eEMC. Um, you might need a p- uh
to drag out some, uh, uh,

00:20:54.920-->00:20:58.758
traces. You’re gonna look at,
for Jtag, um if you’re
interested this weekend, go

00:20:58.758-->00:21:03.929
check out the hardware hacking
village and start looking at
what you can do. Uh at this

00:21:03.929-->00:21:08.601
point you might be looking for a
logic analyzers, uh Saleae makes
a very good one that’s cheap,

00:21:08.601-->00:21:13.739
runs over a USB, uh does a lot
of the T cutting for you. Uh
there’s also hardware interfaces

00:21:13.739-->00:21:19.678
to talk to a lot of this stuff.
Uh, on the left is the bus
pirate it is an open source uh,

00:21:19.678-->00:21:24.950
S RAM backed uh, protocol
analyzer. It has a lot of stuff
baked in. On the right is the

00:21:24.950-->00:21:31.457
SPI driver. It is a little USB
device that um, lets you make up
a uh, a SPI interface. But you

00:21:31.457-->00:21:36.962
can run it at any speed, you can
see and visualize what’s going
on in the uh, wire. So, now that

00:21:36.962-->00:21:41.100
we have that you know, what the
dell do we do? Um you try
extracting it, you mount it, you

00:21:41.100-->00:21:45.971
take a look at what you just
pulled. Uh eMMC regularly and
sometimes do have uh little

00:21:45.971-->00:21:50.409
partition tables. SD cards more
than likely, because some of
these actually on a PC had to

00:21:50.409-->00:21:56.749
touch this thing. Uh go back to
the reconnaissance, go back to
step 0 and see what you found.

00:21:56.749-->00:22:02.688
Then let automation do your
work. Look at Binwalk. Um,
binwalk is a fantastic tool for

00:22:02.688-->00:22:07.159
anybody who’s getting into
reverse engineering especially.
Uh tools like Photorec might

00:22:07.159-->00:22:11.730
actually be useful. Uh you might
be, have to get a little bit
more creative. Uh losetup and

00:22:11.730-->00:22:16.068
uh, friends can do a lot of
stuff like finding partition
tables, uh they can find uh

00:22:16.068-->00:22:21.874
certain records that mark that
this is a file system. Um, if
you’re only looking for stuff

00:22:21.874-->00:22:27.313
like IDA and rotarae, once you
have your uh binary of choice,
automation might be the easy way

00:22:27.313-->00:22:32.985
to get it. This is kind of where
you’re gonna stop. Um, however
if you’re looking to actually

00:22:32.985-->00:22:38.023
like attack this thing live, you
also want QEMU. Because the
problem is these devices are

00:22:38.023-->00:22:43.028
slow, the device that sits and
does my, uh internet at home is
an 18 megahertz device. It has

00:22:45.998-->00:22:51.503
s**t all for ram. I don’t want
to sit and try to figure out how
to cross compile, uh my fuzzed

00:22:51.503-->00:22:57.009
and something and run it on
there and try to beat it against
it. And it takes 5 minutes to

00:22:57.009-->00:23:01.714
boot every time I touch a bad
chunk of memory it reboots and
I’m down for another 5 minutes,

00:23:01.714-->00:23:07.886
now I’m back to where I started.
So QEMU uh lets you uh do some
stuff. It’s a simple fast

00:23:07.886-->00:23:14.193
processor, emulator uh from also
stuff like mainframes, ARM,
MIPS, uh open risk. You can

00:23:14.193-->00:23:19.198
pretend you’re an STM QF34 or
you can pretend that you are uh,
a DEC Alpha. You can OSX on

00:23:22.334-->00:23:27.940
Amiga. You can even run Haiku on
BeOS. Um, there’s 2 ways to run
QEMU as a full fat VM or as a

00:23:27.940-->00:23:31.410
translating loader. Um, with the
full fat VM. You have full
control of everything. You are

00:23:31.410-->00:23:36.682
the hardware. This is an end
circuit regulator for
everything. Uh, you’ve got GDB

00:23:36.682-->00:23:42.354
at kernel level because you get
to step through the entire
processor. Uh requires your

00:23:42.354-->00:23:47.626
trust and whatever binary you’re
working with especially if
you’ve got something that you

00:23:47.626-->00:23:52.631
think is malicious. Um, you
probably want a special kernel
if you are working with this

00:23:52.631-->00:23:58.037
however there’s a lot of ways to
make QEMU do what you need to
do. Um, any tools that you need

00:23:58.037-->00:24:01.140
are you, y- you’re gonna have to
push them into the target
environment. I hate

00:24:01.140-->00:24:05.778
cross-compilers, so that’s why I
typically use a translating
loader. Um, you have access to

00:24:05.778-->00:24:10.349
whatever you’re doing. Uh the
downside to translating loaders
is that uh it’s kind of like

00:24:10.349-->00:24:13.819
whine, except it can’t run
Windows executables. It’s
intended to run Linux

00:24:13.819-->00:24:19.124
executables directly. Um, you
can run in a container so now
you can completely automate a

00:24:19.124-->00:24:25.097
process. You can run this in
parallel. You don’t need a
container. Uh, so this is

00:24:25.097-->00:24:30.102
actually a full-fat VM. Um, I
have a friend that needed uh
some work down. This is a 9

00:24:33.839-->00:24:39.111
track tape drive uh from
Overland Data with a laptop
running MS DOS 6. As a full-fat

00:24:39.111-->00:24:44.016
VM over the parallel port,
interfacing with real hardware.
Uh here I’m actually reading

00:24:44.016-->00:24:49.088
blocks out of an AOD install
tape from a data general
mainframe that we had picked up.

00:24:49.088-->00:24:54.093
Um, this is just protected to
the system. It’s running on an
old DOS machine. It’s old, it’s

00:24:58.297-->00:25:02.101
slow. I’m running on a CORE 2
duo. This doesn’t require a
whole lot of power, all things

00:25:02.101-->00:25:07.072
considered. But what it does
mean is that you don’t have to
worry about is the hardware

00:25:07.072-->00:25:14.012
actually like there. Do I have
to drag out a DOS machine? No
you just boot DOS out of a QEMU.

00:25:14.012-->00:25:20.519
Um, as a loader you’re relying
on binfmt. Uh long ago Linux had
the ability to just say hey I

00:25:20.519-->00:25:25.924
need to say that this is my
executable for this type of
executable. Uh it was virtually

00:25:25.924-->00:25:30.496
for running JARs. Um, so that
you can run JARs from the
command line. Uh, turns out it’s

00:25:30.496-->00:25:35.701
a great place to put emulators.
Uh, QEMU has a static version
which runs entirely in user

00:25:35.701-->00:25:40.706
space. And it un, it uses the
magic number system that’s baked
into BIN format. Uh Debian puts

00:25:43.342-->00:25:48.247
it in their binfmt-misc package
and a couple others. Uh, without
a container it’s dumb simple to

00:25:48.247-->00:25:54.386
set up. You just call bin QEMU
whatever static. Call your
binary and off it goes. Uh you

00:25:54.386-->00:25:59.358
have to trust that your
executables not malicious. You
also have to have all your local

00:25:59.358-->00:26:04.296
libraries sync up to whatever
libraries it had. Um this works
best for like big static

00:26:04.296-->00:26:08.367
monolithic executables like
Busybox. However, for a
container you know you can bring

00:26:08.367-->00:26:12.471
that whole root filesystem
along. You can bring those weird
versions of GlibC. You have

00:26:12.471-->00:26:16.575
effectively a little jail um,
you can run it in Docker you can
run it in SystemD’s, um machine

00:26:16.575-->00:26:21.580
containers. It’s great for when
your binary is linked against
some weird like, oh we had this

00:26:24.149-->00:26:29.154
idea and let’s go mangle GlibC.
Um for this next demo, uh we’re
gonna look at a piece of

00:26:31.924-->00:26:36.929
software, or that’s uh running
on what’s more normally known as
IBMz 14. Um, if anybody is

00:26:39.665-->00:26:46.071
familiar with s390x it’s
actually compatible with the
system 360. So this is a quick

00:26:46.071-->00:26:51.076
user demo. Um, so here we are,
we’re starting uh, s390x, uh, uh
container from system D. Um, we

00:26:59.218-->00:27:04.156
have, ya know, standard thing,
here you can see that it’s uh,
changed a little bit in htop but

00:27:06.658-->00:27:13.165
to everything it’s standard
s390x system. But for fun, uh we
can also do this for ARM. Uh

00:27:13.165-->00:27:19.271
again my machine just says, yeah
your ARM system, never- uh mind
that this is actually internally

00:27:19.271-->00:27:24.276
just an s86 box. It’s actually a
VM running inside a VM. Um, QEMU
in this was is really,

00:27:26.745-->00:27:31.750
astonishingly powerful. Um, the
big part is this can run AFL
internally. Um, AFL is a

00:27:34.853-->00:27:39.591
fantastic fuzzer. And AFL has
support for QEMU. There’s a
little bit of setup. Uh you have

00:27:39.591-->00:27:44.596
to bring uh a copy of QEMU built
for AFL, for your target
alongside. Um, I’ve done this in

00:27:47.399-->00:27:52.404
a VM, it’s really slow and it
works. So, so here we are, we’re
gonna run our s390x and we’re

00:27:59.378-->00:28:04.316
gonna bind a couple of things
over from the Debian machine
that I’m running this on. I’ve

00:28:10.155-->00:28:15.561
compiled an AFL for uh, x86
already. Uh here’s our uh target
executable. It’s a 64-bit IBM

00:28:15.561-->00:28:20.566
s390 uh executable. Um, we’re
gonna tell AFL, hey here’s your
AFL pass. And AFL starts up.

00:28:27.673-->00:28:33.579
It’s got a couple of small
simple tests, uh environments
and this is actually really

00:28:33.579-->00:28:40.085
slow. But here we can see AFL’s
attacking s390x binary. I don’t
have s390x hardware. I have a

00:28:40.085-->00:28:45.090
cheap uh laptop with a VM. So,
um, what we learned is that uh
hardware vendors are lazy. Uh as

00:28:49.795-->00:28:54.299
we saw ya know a lot of these
devices are going to be very
similar to each other. There’s a

00:28:54.299-->00:29:01.173
lot of duplication in so many
things. Um, attacking hardware
means getting really creative.

00:29:01.173-->00:29:07.479
You’re going to see a lot of
stuff that a whole process of
pulling off uh a CenturyLink

00:29:07.479-->00:29:11.883
routers firmware. That was the
first time I had seen it and it
took me just over an hour to

00:29:11.883-->00:29:16.989
get, ya know take and peak
around. You spend a lot of time
doing reconnaissance. You start

00:29:16.989-->00:29:21.994
look at what is my device doing?
Um, QEMU is pretty new. It is
fundamentally a way to make a

00:29:24.396-->00:29:29.668
device pretend, a piece of
software def- depend, uh,
pretend that it is on the actual

00:29:29.668-->00:29:33.672
piece of hardware that it
believes it is. Uh QEMU can
actually be used for way more.

00:29:33.672-->00:29:38.677
There is again, a STM 32 port.
You can run it on embedded ARM.
Uh you can run QEMU on ARM to

00:29:41.146-->00:29:45.717
pretend that it’s ARM if you
have the wrong kind of ARM. Uh
for a little while I was doing

00:29:45.717-->00:29:51.857
this so that I could use ARM 64
binaries on ARM 32 systems. It
works, its slow but it works.

00:29:51.857-->00:29:56.862
Um, AFL also runs really slow
when you’re emulating x86 uh,
stuff on uh, s390x, uh, the

00:30:00.666-->00:30:05.671
other way around. Um, and
remember rule zero. Okay. This
is the, the big part here. That

00:30:11.610-->00:30:16.615
little rule zero, a lot of
reconnaissance, a little bit of
planning can spend you, can save

00:30:20.252-->00:30:26.024
you hours and hours of headache.
Um, sometimes just simply
noticing that there’s an EMMC

00:30:26.024-->00:30:32.364
device means, oh I’ll solder it,
pop it into a ready. I’m done, I
don’t have to worry about how

00:30:32.364-->00:30:38.036
I’m gonna extract this. Then you
find out that it’s encrypted.
Well alright then you go back.

00:30:38.036-->00:30:43.041
You start looking. You start
sniffing the wires. A lot of uh,
creativity comes with things

00:30:45.510-->00:30:50.515
like when fail overflow, did
their attach on the PlayStation
4 they found out it was just an

00:30:50.515-->00:30:56.755
x86 system. So what they did is
they intercepted a lot of the c-
the communications between 2

00:30:56.755-->00:31:01.693
sides. By running PCIE over a
uART at 9,600 bod. So they could
watch each frame visually, as it

00:31:04.996-->00:31:10.001
went through their entire
system. Um, and people are lazy.
Remember that the Xbox 1, PS4

00:31:14.940-->00:31:20.178
and probably upcoming versions
are just x86 systems. They’re
just putting newer and more

00:31:20.178-->00:31:25.183
creative uh, forms of control on
how code gets loaded. Attack
early. And find interesting ways

00:31:29.888-->00:31:35.627
you will pour over documents in
broken Chinese. You will pour
over documents in broken

00:31:35.627-->00:31:41.199
English. I have spent many hours
sitting in front of data sheets
that were, I copied and pasted

00:31:41.199-->00:31:47.672
this out of a do- a pdf into
google translate and then had to
retranslate it. Because the

00:31:47.672-->00:31:52.110
company that makes it only makes
it in Chinese. Because all the
engineers are Chinese. You’ll

00:31:52.110-->00:31:57.115
see stuff, ya know don’t be
afraid to look for TFTP. Your
device actually might pop open

00:32:02.187-->00:32:07.025
TFTP early. Um, Marocki devices
for a long time did this. And it
was really interesting.

00:32:07.025-->00:32:12.030
>>[Audience Question –
inaudible] >>Yes, uh. >>[
Audience Question – inaudible]

00:32:19.404-->00:32:23.542
>>The comment was that a lot of
consumer routers will boot from
TFTP if they can’t boot from

00:32:23.542-->00:32:28.647
their normal file system and
yeah that happens. Uh if you can
induce that failure. Might be as

00:32:28.647-->00:32:35.554
simple as a paper clip, m- kay,
um this is ya know, a paperclip
is how you defeat on a lot of

00:32:35.554-->00:32:41.126
older ThinkPads the lock out
mechanism. So you cause the
thing to boot, misread the boot

00:32:41.126-->00:32:46.865
configuration and then out comes
an empty slate. You go back into
the boot configuration. The bios

00:32:46.865-->00:32:51.102
echoes, I don’t have a password.
All the encryption keys been
wiped so now you just have to

00:32:51.102-->00:32:57.576
reboot and do new encryption
keys. This sort of stuff is
pretty common. Um, again if

00:32:57.576-->00:33:01.379
you’re interested go look at
hardware hacking village.
Explore what uh, hardware

00:33:01.379-->00:33:07.185
engineers have to build, because
you will wonder, what the hell
was that EE drinking on that

00:33:07.185-->00:33:12.190
day? Because, w- people put PCIE
devices on ARM. There’s even uh,
there’s a GPS receiver there as

00:33:17.095-->00:33:22.100
well. And that’s going over it’s
own custom proprietary BUS.
There are many different ways to

00:33:26.338-->00:33:31.343
attack these. Uh, AFL is an
amazing tool , if you can get it
working, great! So, any

00:33:34.713-->00:33:39.718
questions? Yes. >>[Audience
Question – inaudible] >>So for
SOC for, um, the question was

00:33:45.056-->00:33:51.763
how do I emulate uh peripherals
in QEMU. I’ve worked
predominantly an environment

00:33:51.763-->00:33:56.668
where I don’t have to worry
about peripherals uh I know
there is a framework for saying

00:33:56.668-->00:34:02.574
when you write to this memory
address, really write to this
device. Um, check the QEMU

00:34:02.574-->00:34:07.646
documentation. They have a lot
of how to emulate external
peripherals. Um something like

00:34:07.646-->00:34:13.418
the uh, SPI driver or Bus Pirate
can be used as a bridge to the
real hardware as well. Um, you

00:34:13.418-->00:34:18.423
would have to check the
documentation. Other questions?
>>[Audience Question –

00:34:21.559-->00:34:26.565
inaudible] >>I can’t see all the
way back. Fantastic. Thank you
so much. Um there’s more

00:34:31.136-->00:34:36.641
resources available on the
internet. [applause] Um
definitely check out if you uh

00:34:36.641-->00:34:42.614
are more interested in this uh
RECON 2010 there was a fantastic
talk by Igor Sko- Skochinsky on

00:34:42.614-->00:34:46.151
reverse engineering for PC
Reversers. As well as the
fantastic JTAG Explained

00:34:46.151-->00:34:51.790
article. Uh go like at eLinux
and Linux MIPS Uh there are many
target that you can attack.

00:34:51.790-->00:34:57.596
There are ARM devices and
embedded Linux devices all
around you. Like right here.

00:34:57.596-->00:35:02.567
This is a 100 megahertz ARM
chips. There are ARM devices on
your body. There are possibly

00:35:02.567-->00:35:07.572
ARM devices in your body. There
are embedded systems everywhere.
Keep on hacking. [applause]

