00:00:00.000-->00:00:06.006
>>Good morning everyone. So this
is Josep. He’s got a rather
interesting gear here and is

00:00:06.006-->00:00:11.011
going to work too. I know that.
[laughter] With that, it’s
Josip. >>Hi guys. Uh. So thank

00:00:14.214-->00:00:19.219
you for joining to- to this
talk. Uh. I really hope that
you- you guys will enjoy it. So,

00:00:21.922-->00:00:26.927
um, what I’m going to talk about
is, uh, this research on how I
broke, uh, this WingOS. Uh. What

00:00:29.897-->00:00:34.902
I’m going to do is to- to
discuss about some interaction
about this, uh, WingOS thing is.

00:00:37.938-->00:00:43.010
Then we’ll discuss some
scenarios and attack surface
that we have, uh, with, uh, this

00:00:43.010-->00:00:48.015
OS on- on the devices. Then, uh,
I will describe with, uh, full
technical details, uh, some

00:00:50.250-->00:00:55.255
critical vulnerabilities. And
then I will try to-to make a-a a
demo with, uh, these two devices

00:00:58.558-->00:01:04.164
with an exploit, uh, that I did
and trying to exploit one of the
vulnerabilities. And then after

00:01:04.164-->00:01:09.169
that, we will discuss some
conclusions. So. Um. What the
hell is this WingOS? Uh. So.

00:01:13.740-->00:01:19.780
Basically it’s a- an embedded
Linux operating system, um, with
its own proprietary staff in- in

00:01:19.780-->00:01:24.818
the Kernel. Like they have their
own proprietary drivers. They
have their own proprietary

00:01:24.818-->00:01:30.824
circuit data family and stuff
like that. So originally it was
created by Motorola. But now

00:01:30.824-->00:01:36.196
it’s property of, uh, Extreme
networks. Uh. We’ll discuss
about it in a couple of minutes.

00:01:36.196-->00:01:41.835
Then the, uh, the Architecture
MIPS N32- at least, uh, the
devices that I’ve been working

00:01:41.835-->00:01:46.840
with during this research were
MIPS N32. And mainly’s used, uh,
for wireless access points and

00:01:50.043-->00:01:56.049
wireless controllers. And as far
as I know, there is no public
information or previous research

00:01:56.049-->00:02:02.789
on, um, on reported
vulnerabilities about, uh, this,
uh, OS. As far as I know at

00:02:02.789-->00:02:09.496
least. So from Extreme
networks’, uh, website, um, we
can get some high level details

00:02:09.496-->00:02:15.836
about this OS. Like, for
instance, here it’s saying that
it’s for WLAN architectures and

00:02:15.836-->00:02:21.575
it’s designed for- to scale
efficiently from the smallest
networks to large geographically

00:02:21.575-->00:02:26.313
dispersed, uh, deployments.
Stuff like that. So from the
website you can get more or

00:02:26.313-->00:02:31.318
less, uh, an idea on high level
details of this OS. So we have
a- a web interface. A typical

00:02:35.222-->00:02:40.994
web interface where we can set,
uh, a lot of stuff. I mean, the
web interface is- is huge. Um.

00:02:40.994-->00:02:47.200
And it also has, uh,
vulnerabilities but I didn’t
want to focus this research

00:02:47.200-->00:02:53.540
about web- uh, vulnerabilities.
So we wo- we won’t discuss web
vulnerabilities in- during this

00:02:53.540-->00:02:59.312
talk. But also we have, uh, the
typical common line interface
similar to the CSquires where

00:02:59.312-->00:03:04.484
you can- I mean, you have, like,
different type of commands and
combinations of commands where

00:03:04.484-->00:03:11.358
you can set a- the device, and
this common line interface, uh,
is, uh, restrictive meaning

00:03:11.358-->00:03:16.363
that, uh, from here you can’t
access to the, uh, operating
system- the Linux Operating

00:03:16.363-->00:03:21.368
System that it’s running in-in
the background. So devices using
this WingOS. So I-I-I didn’t get

00:03:25.138-->00:03:30.343
an official list of devices
affected. But based on public
information from Extreme

00:03:30.343-->00:03:36.850
networks’ website, we can see a
list of WiNG access points and
controllers that uses this

00:03:36.850-->00:03:41.555
operating system. But as this is
not official, this list could be
even bigger in the case of

00:03:41.555-->00:03:46.560
Ext-Extreme networks. But also
we have, uh, Motorola devices
and Zebra devices because, um,

00:03:48.829-->00:03:53.834
as I said, Motorola, uh, created
this OS so they have, uh, also
their devices, uh, with this OS.

00:03:56.236-->00:04:00.740
And then Zebra bought this part
of the business to- from
Motorola. And that’s why

00:04:00.740-->00:04:06.780
we-we-we also have Zebra devices
with this OS. And then at the
end, Extreme Networks bought

00:04:06.780-->00:04:13.220
this part of the field from
Zebra. So basically that’s why
we have Motorola access points,

00:04:13.220-->00:04:19.059
Motorola controllers, Zebra
devices, and Extreme Network
devices running with this, uh,

00:04:19.059-->00:04:24.064
running this, uh, operating
system. And also we got the, uh,
Kontron device. So, uh, this

00:04:26.366-->00:04:33.073
particular one is important
because, uh, all this research
started because of this. Um.

00:04:33.073-->00:04:37.911
This, uh, well Kontron is a
company that, uh, makes devices
for different industries such as

00:04:37.911-->00:04:43.350
the aircraft industry and the
train industry and stuff like
that. So one of my coworkers in

00:04:43.350-->00:04:48.054
IOActive Weyn Santamarta said,
“Hey guys, here is an
interesting target, uh, uh, this

00:04:48.054-->00:04:53.360
is an access point that is
widely used in aircrafts and
many airlines around the world

00:04:53.360-->00:04:57.564
so this could be an interesting
target for our research
project.” And then I thought,

00:04:57.564-->00:05:02.502
yeah this might be fun. And,
yeah, it ended up being pretty
fun. So, um, basically this is a

00:05:05.438-->00:05:10.443
box that- it has some electronic
connectors to- to comply with
the aircraft, um, regulations-

00:05:12.679-->00:05:18.952
the aircraft industry
regulations. Basic-basically
inside we got that Motorola

00:05:18.952-->00:05:23.957
AP7131 access point. So where we
can find these devices. As we
can see for instance in this,

00:05:26.826-->00:05:32.966
uh, picture from the internet,
eh, from an aircraft, uh, they
are actually installing the

00:05:32.966-->00:05:38.939
Motorola attachm-Motorola access
point, uh, at the ceiling of the
aircraft. So as I was saying,

00:05:38.939-->00:05:43.843
uh, it’s widely used in-in
aircrafts by many airlines
around the world. We got some

00:05:43.843-->00:05:48.415
other pictures, uh, from the
internet where we can see
the-the Kontron box where inside

00:05:48.415-->00:05:54.221
it’s that Motorola- particular
Motorola access point. And,
yeah, it-it appears that, uh,

00:05:54.221-->00:05:58.825
they’re installing the-this
access point at the ceiling of-
of the aircraft. But I don’t

00:05:58.825-->00:06:03.897
know if maybe in other types of
aircrafts, they are installing
the-the access point in other

00:06:03.897-->00:06:08.902
places. I have no idea. So from
the Extreme Networks website,
um, some case studies, um, that

00:06:11.738-->00:06:16.977
we can find, uh, on the
internet, we can see that these
devices are also used in other

00:06:16.977-->00:06:21.147
different scenarios and
industries such as smart
buildings, smart cities,

00:06:21.147-->00:06:26.820
healthcare, government, uh,
obviously small and big
enterprises networks, I don’t

00:06:26.820-->00:06:32.325
know, in a lot of different
scenarios. Let’s see some
examples quickly. Um. This is

00:06:32.325-->00:06:36.730
for instance a Motorola case
study where, uh, we can see that
the AP7161 and this, uh, the

00:06:36.730-->00:06:41.735
9500 Controller I use- are used
in more than 200 subway stations
in the New York City subway to

00:06:46.072-->00:06:51.077
provide wifi, uh, to- to the
passengers. Then also we got
container ports, uh, glob-global

00:06:53.847-->00:07:00.387
electronics manufacturer suggest
isola in this case in different
facilities. Universities such as

00:07:00.387-->00:07:05.392
this one. Uh, also even in
mines, this-this case study from
Zebra, uh, explains how, uh,

00:07:08.361-->00:07:15.068
these devices are used in the
Westmoreland Coal Company in
mines. Um. I don’t know. Saigon

00:07:15.068-->00:07:20.073
city in Vietnam where there are
more than 1,500 access points
installed to provide wifi. Uh.

00:07:23.009-->00:07:28.014
Casinos. Uh. Resorts. Nanjing
University in China, another
example. Hospitals, um, MWR

00:07:30.116-->00:07:35.789
Facilities case study. Even
apparently military bases, uh,
as we can see in this case, uh,

00:07:35.789-->00:07:42.028
study. So as you can see, in a
lot of different, uh, scenarios
and-and industries. So for the

00:07:42.028-->00:07:44.030
attack surface and scenarios, I
divided in two and this is
mainly because the aircraft

00:07:44.030-->00:07:46.032
scenario is a little bit
different and I- it has some
particularities. And the other

00:07:46.032-->00:07:48.034
scenario, it’s basically the
rest of the scenarios that we’ve
got. So uh, all of this stuff is

00:07:48.034-->00:07:53.039
focused on the remote
pre-authentication
vulnerabilities that I found-

00:07:56.076-->00:08:01.014
the vulnerabilities that we will
discuss later. So first we have
the-e-the attack surface of the

00:08:11.257-->00:08:16.429
ethernet cable meaning, like, if
the attacker has physical access
to the access point, he can just

00:08:16.429-->00:08:21.434
connect the-the cable to the
device to any port or to a- to a
administrative, uh, port. Um.

00:08:23.703-->00:08:30.343
And then he could- if he can
reach the vulnerable UDP service
and Mint services, then, uh,

00:08:30.343-->00:08:34.614
technically the attacker could
exploit the- the issues. Of
course in the case of the

00:08:34.614-->00:08:39.652
aircraft, uh, this is less
likely. Alright? Because if the
access point is at the ceiling,

00:08:39.652-->00:08:43.957
I don’t know, I think that
something unlikely. But I don’t
know. Still it’s a-a

00:08:43.957-->00:08:49.362
possibility. But also these
vulnerabilities are
technic-technic-technically

00:08:49.362-->00:08:55.502
possible to exploit over the air
through the wifi connection. And
also in the aircraft scenario,

00:08:55.502-->00:09:00.507
we’ve got another another, um,
uh, attack surface which is
pivoting from the satellite

00:09:00.507-->00:09:05.512
modem to the access point from
the ground. Let me explain this
a little bit. So I don’t know

00:09:07.814-->00:09:12.619
if-if you guys are familiar
with, uh, my coworker’s Ruben
Santamarta research. Uh. He

00:09:12.619-->00:09:17.824
recently spoke about this in-in
Black Hat in the Last Call for
Satcom Security. So basically he

00:09:17.824-->00:09:22.695
was able, uh, from the internet,
just usi-using a verbala
internet connection, nothing

00:09:22.695-->00:09:29.602
special, to hack and compromise
satellite modems of aircrafts
that are running- that are

00:09:29.602-->00:09:35.909
actually flying on the air. So
then based on that, we-we saw
that, uh, based on some

00:09:35.909-->00:09:40.613
information we saw on-on the
internet, that the attacker
should be able to reach from the

00:09:40.613-->00:09:45.952
satellite modem the, uh, the
access point which is running
the WingOS. So this could be

00:09:45.952-->00:09:50.957
another, uh, attack surface. And
of course, uh, I must say that,
uh, the safety of the aircraft

00:09:53.026-->00:09:58.298
in this, uh, attacks and-and
stuff or the WingOS and
everything, the safety of the

00:09:58.298-->00:10:05.271
aircraft is not, uh, at-at risk-
a-at risk. It’s only, um, the
communications. So this is one

00:10:05.271-->00:10:10.276
of the architectures and this is
the satellite modem that, uh,
Ruben, uh, compromised. And this

00:10:12.278-->00:10:17.183
is the access point for entering
the WingOS and these are
connected through the SMU

00:10:17.183-->00:10:21.521
server. So we are, uh, pretty
sure that, uh, it should be
possible to reach the access

00:10:21.521-->00:10:28.061
point from the satellite modem
and exploit the WingOS, uh,
vulnerabilities. Then the other

00:10:28.061-->00:10:33.633
scenarios basically are the rest
like, uh, outdoor access points
or indoor access points. So

00:10:33.633-->00:10:38.671
again, the other attack surface
is, again, if the attacker has
physical access to the access

00:10:38.671-->00:10:44.544
point, just connect the ethernet
cable and- and that’s it. This
is more likely in outdoor access

00:10:44.544-->00:10:49.516
points, but also possible in
indoor access points if the
attacker is inside of the office

00:10:49.516-->00:10:54.454
or the building or-or whatever.
But again, through the wifi. So
this is technically possible as

00:10:54.454-->00:10:59.225
we will see in the demo to
exploit, uh, some of these
issues and also if- if the

00:10:59.225-->00:11:04.264
attacker is somehow inside the
internal network, uh, and if-if
the attacker has connectivity to

00:11:04.264-->00:11:09.802
some of these devices, then, uh,
obviously he can- he could try
to exploit the-the issues. So

00:11:09.802-->00:11:15.208
let’s start with the
vulnerabilities. Um. The first
one is not a really critical

00:11:15.208-->00:11:21.915
one, but it was a really
important one for the research
because it’s a hidden a root

00:11:21.915-->00:11:26.920
shell kind of, uh, backdoor. So
and-and yeah, when, uh, when you
get a rootshell, the process of

00:11:29.222-->00:11:34.227
the research makes easier this
process- I mean, the research.
So, uh, but it’s a kind fo-for-

00:11:37.263-->00:11:41.734
it’s a kind of privilege
escalation vulnerability, uh,
because, uh, you need access to

00:11:41.734-->00:11:46.539
the commonline interface to get
that root shell. So from the
attacker’s perspective, yeah, if

00:11:46.539-->00:11:50.577
the attacker somehow has access
to the commonline interface,
he’s good. He can do a lot of

00:11:50.577-->00:11:56.049
stuff, but, um, if-if the
attacker good-gets the root
shell, then we can say that

00:11:56.049-->00:12:00.987
the-the device is completely,
uh, compromised. So here we can
see in-in this picture, um,

00:12:03.222-->00:12:09.429
some-in some forum, some-some
guy’s asking about this service
start-shell command that gets

00:12:09.429-->00:12:14.500
you into the native operating
system but he says that Motorola
may not disclose the required

00:12:14.500-->00:12:16.502
password to mere customers. So I
was trying to find information
about this, uh, start-shell

00:12:16.502-->00:12:21.507
command. So all-all I got was,
like, forums like that, people
asking about it, but that-that’s

00:12:23.810-->00:12:30.683
all I got. Even if we- if we
read the WingOS manual we can
see that, yes, that we have a

00:12:30.683-->00:12:36.456
start-shell command that
provides shell access, but
that’s all-all you get. So when

00:12:36.456-->00:12:41.828
you execute this command, you
get this, um, like last password
used, password with this MAC

00:12:41.828-->00:12:46.833
address and then this password
prompt asking to the user to-to
input the password. So one of

00:12:46.833-->00:12:48.835
you guys might think you’re
like, “Ok. So it’s telling me
what-what is the last password

00:12:48.835-->00:12:50.870
used so I’m going try ‘password’
in lowercase letters.” But, um,
obviously that’s not going to

00:12:50.870-->00:12:52.872
work here. So, uh, then since
we-we got access to the thing
we’re, uh, image, then we are

00:12:52.872-->00:12:54.874
going to start aesthetically
reverse engineer some-some
binaries to find out how this

00:12:54.874-->00:12:56.876
works. So based on the strings
we can see here the “last
password used” string. And then,

00:12:56.876-->00:13:01.814
uh, here is going to call this
“validate mapsh” uh “password”
function. And depending on the

00:13:15.795-->00:13:20.800
return value, is going to, um,
reach this basic book where it’s
going to get the, um, the root

00:13:27.340-->00:13:32.345
sum. So let’s get inside this
“validate mapsh” uh “password”
function. Then again it’s going

00:13:35.114-->00:13:40.153
to call this other one “get last
mapsh” uh “password” function
where it’s going to open this

00:13:40.153-->00:13:46.325
file, “etc2/imish-password”
file. And the content of the
file, uh, this file is this

00:13:46.325-->00:13:52.665
particular string and this is
the default value in every
WingOS. This, uh, string

00:13:52.665-->00:13:58.805
in-inside that file. Then after
that, with the content of the
file, it’s going to execute

00:13:58.805-->00:14:05.645
these, uh, instructions in this
loop. So to-to play around with
Unicorn I emulated this code. I

00:14:05.645-->00:14:10.650
don’t know if you guys know or
are familiar with Unicorn, but
it’s an awesome frameware that

00:14:10.650-->00:14:16.155
uses, uh, Qemu in the background
and allows you to-to emulate
several, uh, architectures. But

00:14:16.155-->00:14:20.860
of course, uh, in order to
emulate the code, you need some
previous reverse engineer, uh,

00:14:20.860-->00:14:25.865
job or work. Uh, for instance
here you need to-to know, uh,
what racer points to-to your

00:14:28.034-->00:14:34.240
input, the buffer where we have
the-the contents of that-of that
file. And also you need to know

00:14:34.240-->00:14:39.245
the-th-the racer that points to
the buffer where we will have
result of the operations. So,

00:14:42.615-->00:14:48.087
uh, I was using the Python API
through um Unicorn and this is
pretty simple so you can emulate

00:14:48.087-->00:14:53.326
th-the instructions and provide
their- erase their values and
create your buffer and inside

00:14:53.326-->00:14:59.232
that buffer we-we have the
content of, uh, that file. And
then after the execution of the

00:14:59.232-->00:15:04.070
emulation, we are printing out
here the, um, the buffer where
we have the result which is

00:15:04.070-->00:15:10.409
these bytes, the result. So if
we look at if carefully, we can
that this was the-the string

00:15:10.409-->00:15:16.382
that we have inside the file. So
when they call this reading, uh,
its ascii character then we got

00:15:16.382-->00:15:21.387
it’s a hex bytes for its ascii
character. And after that, um,
this is the result that we got

00:15:23.689-->00:15:28.694
after those, uh, operations in
that loop. So we-we can see that
these bytes are these guys here.

00:15:31.497-->00:15:36.502
So basically it’s meaning that
this is hex. Then after that, is
going to call a RC4 decryption

00:15:38.838-->00:15:43.843
routine. Uh. It’s going to try
to decrypt the, uh, the content
of, uh, the file. And the-the

00:15:45.978-->00:15:52.318
hex bytes after, uh, those
operations in the loop with this
static key “Hi Sabeena? How’re

00:15:52.318-->00:15:57.323
you doin’? Bye!!” I know. Nice
key. And, and yeah so in this
case, uh, after the decryption,

00:16:00.726-->00:16:05.264
the result is going to be the
password, uh, string in
lowercase letters. Which makes

00:16:05.264-->00:16:10.369
sense because we were able to
get the last password and that’s
why it was printing out here

00:16:10.369-->00:16:16.075
like “last password used,”
“password” in lowercase letters.
Then after that decode, it’s

00:16:16.075-->00:16:21.881
going to get th-the MAC address
of the device. And then with the
MAC address, it’s going to, uh,

00:16:21.881-->00:16:27.787
execute these other instructions
in this loop but- and basically
do some operations with the MAC

00:16:27.787-->00:16:33.459
like adding some numbers to its
byte of the MAC. Like here the
first byte is adding 0, then the

00:16:33.459-->00:16:38.464
second byte is adding 1, and
then 2, 3, 4, and so on. And,
um, and yeah, and then, uh.

00:16:41.267-->00:16:46.672
After that, what it’s going to
do is call another RC4
decryption routine. So it’s

00:16:46.672-->00:16:53.346
going to decrypt “password”, so
the- which is a result for the
last RC4 decryption. But now

00:16:53.346-->00:16:59.585
it’s with this key. The-the MAC
address with those operations
that we were talking about. And

00:16:59.585-->00:17:04.156
finally after that, it’s going
to execute these other
instructions with, uh, I also am

00:17:04.156-->00:17:08.961
willing to play around with
Unicorn, but basically these
instructions are making sure

00:17:08.961-->00:17:13.966
that the-the, uh, result is only
lowercase letters. So here is
the emulation as you can see and

00:17:16.302-->00:17:21.908
in-in my device, uh, for my MAC
address, this is the valid
password which is only

00:17:21.908-->00:17:26.913
lowercase, uh, letters. And then
you can finally access to- to
the root shell. Then in the

00:17:29.148-->00:17:33.686
code, we can see that after the
password is granted, it is going
to open again that file the

00:17:33.686-->00:17:40.559
“imish-password” file. And then
it’s going to, um, RC4 encrypt
with the same key, the “Hi

00:17:40.559-->00:17:46.098
Sabeena? How’re you doin’?”, uh,
key, the password that the user
types when the password was

00:17:46.098-->00:17:51.003
granted. Meaning that the next
time you are-you’re going to
execute the service, uh,

00:17:51.003-->00:17:54.407
start-shell command, the
password is going to be
different. That’s why I call

00:17:54.407-->00:17:59.412
this like a kind of, uh, dynamic
password because, uh-uh, the
next time, it’s-it’s going to be

00:17:59.412-->00:18:05.818
the same and you will have to do
the whole thing to-to calculate
the password. So here you have,

00:18:05.818-->00:18:10.823
uh, the whole process in case
you later want to-to check, uh,
with the slides. And yeah, um,

00:18:12.892-->00:18:17.897
finally in the code also we can
see that since we got access to
the root shell then creating

00:18:20.733-->00:18:26.973
this file “allow-root” in “etc”
then you can make it persistent
and then, uh, all the time when

00:18:26.973-->00:18:32.945
you execute the command, it’s
not going to ask for a new
password again. Ok. So now, uh,

00:18:32.945-->00:18:37.950
since now we have, um, root
shell, we can start to- to try
to- to see more stuff about this

00:18:40.686-->00:18:46.993
OS. For instance, to check, um,
what services are running by
default. And for instance we can

00:18:46.993-->00:18:53.766
see that there are several ports
like this 3799 UDP port which is
listening over all the IP

00:18:53.766-->00:18:58.771
addresses. So in this case it’s
the RIM process, the Radio
Interface Module. So, um, we are

00:19:01.974-->00:19:06.379
going to see a remote
pre-authenticate stack overflow
of this service. But this

00:19:06.379-->00:19:10.750
particular one only affects
older versions of the firmware,
but I wanted to share, er, with

00:19:10.750-->00:19:16.255
you guys this one, uh, because
it seems that they try to fix
it, but they made another

00:19:16.255-->00:19:23.029
mistake as you- as we will see
shortly. But yeah. So now from
here is the typical stuff from,

00:19:23.029-->00:19:29.735
uh, protocol reverse
engineering. So basically we
trace the sockets and we know

00:19:29.735-->00:19:36.742
where they call this, um, parts
in the user’s buffer. So in this
case, in this recvfrom, we-we

00:19:36.742-->00:19:41.514
know that the-the buffer length
is, uh, 1-->000 hex which is, um,
pretty big. And then just

00:19:41.514-->00:19:43.516
reading the code and following
how the code is, um, parts in
the-the user’s buffer, uh, we

00:19:43.516-->00:19:45.518
can see that, uh, there is one
particular memcpy where the
source and the sites are

00:19:45.518-->00:19:47.520
completely controlled by the
user and the destination is uh,
uh, stack buffer. So it’s a

00:19:47.520-->00:19:52.525
typical stack buffer overflow.
So [cough] we- we are here. Uh.
Here’s where we have in this red

00:20:07.807-->00:20:13.446
block, uh, the recvfrom. And
here’s where we have the-th-the
call of-to this function where

00:20:13.446-->00:20:18.451
inside we have that particular
vulnerable memcpy. So what we
need to know- to do right now is

00:20:20.886-->00:20:26.225
typical reverse engineering
stuff, like to find out how to
get from here to there. Uh. Just

00:20:26.225-->00:20:32.898
reading the code an-and build
your own Python client, uh, to
reach that particular memcpy. So

00:20:32.898-->00:20:37.903
this is the- one of the-the
Python, uh, client to-to reach
that stack overflow. An-and as I

00:20:39.972-->00:20:44.877
said, this only affects old
versions of the firmware, but
based on information that I got

00:20:44.877-->00:20:51.016
from the Kontron website, the
Kontron devices that are used in
aircrafts, uh, apparently some

00:20:51.016-->00:20:57.356
of them could be vulnerable
as-as I saw in the website that
they were running older versions

00:20:57.356-->00:21:02.294
of the- of the firmware. So
apparently they tried to fix
this- this stack overflow. And

00:21:05.331-->00:21:11.604
so here in- in newer, uh,
versions of the firmware, so we
can see here that they are

00:21:11.604-->00:21:17.343
checking the- the size of
the-the memcpy which is user
control. But if it’s bigger than

00:21:17.343-->00:21:23.382
this value then it’s not going
to reach that, uh, vulnerable
memcpy. Instead, it’s-it’s going

00:21:23.382-->00:21:28.387
to execute this “assert print”
function that is going to
generate this “crash.dump” and

00:21:28.387-->00:21:33.826
then is going to kill the- the
process. So yeah this is the
Python code to-to reach that.

00:21:33.826-->00:21:40.166
And so yeah, you can kill the
process. But the process- uh, it
will, uh, restart immediately.

00:21:40.166-->00:21:43.802
But the problem here is that
there is a watchdog in this
system that checks if this

00:21:43.802-->00:21:48.541
process is alive, because this
process is apparently critical
for the operating system. So if

00:21:48.541-->00:21:52.578
you execute this Python’s crypt
like two or three times in a
row, then the watchdog is going

00:21:52.578-->00:21:57.950
to check that the, um, the RIM
process is not live. And then
the whole operating system is

00:21:57.950-->00:22:04.590
going to be reboot. That’s why I
call this like, uh, global
denial of service. Then let’s

00:22:04.590-->00:22:09.361
move on to-to the mint
vulnerabilities. I mean, there
are other EDP services with-with

00:22:09.361-->00:22:15.601
issues, but we don’t have time
to-to talk about them. So let’s
move on to-to the main, uh,

00:22:15.601-->00:22:20.806
issues. So when I was reverse
engineering some of the binaries
then I realized that they were

00:22:20.806-->00:22:27.313
receiving data from, um, from
some particular sockets so when
tracing these sockets I realized

00:22:27.313-->00:22:32.318
that they were using nonstandard
values such for instance the 32
hex value for the domain value

00:22:34.453-->00:22:40.492
and some references such as like
this one the local mint address.
So I wanted to-to know what the

00:22:40.492-->00:22:46.632
hell was this mint thing. So
there’s not much information on
the internet about this mint

00:22:46.632-->00:22:53.172
thing at-at least about how it
works, uh, internally. The- of
course there is information

00:22:53.172-->00:22:59.111
about how to set the devices
to-to work with mint and stuff
like that. But yeah, basically

00:22:59.111-->00:23:03.816
it’s a layer, 2 layer, 3
proprietary protocol originally
also created by Motorola. And

00:23:03.816-->00:23:10.389
they have like two levels. Level
1 for VLAN and level 2 for IP.
So mint is used, uh, mainly

00:23:10.389-->00:23:16.028
to-to communicate devices
between them. So for instance
here we have these access points

00:23:16.028-->00:23:20.232
communicating between them
through level 1 mint, or this
access point to this, uh,

00:23:20.232-->00:23:25.237
controller through level 2 mint,
or these two controllers through
level 2 mint as well. So yeah,

00:23:28.240-->00:23:33.946
when-when you trace some of the
processes as well you can see
some stuff like the-the socket

00:23:33.946-->00:23:39.251
address family which is
nonstandard AF MINT, the port,
and then the mint address which

00:23:39.251-->00:23:44.256
is the four last bytes of the
MAC address. So yeah
th-they-they created their own

00:23:46.358-->00:23:52.064
proprietary socket address
family in their Kernel, AF MINT.
Um, uh, in my case at least

00:23:52.064-->00:23:57.069
ours, um, using datagram
sockets. So the goal here is
to-to be able to create a client

00:23:59.204-->00:24:05.844
so we can communicate, uh, with
other devices- other devices
using-using mint. So we have

00:24:05.844-->00:24:09.648
three options here it’s like so
the first one is reverse
engineer their kernel and try

00:24:09.648-->00:24:14.687
to-to make your own client and
make it work in your linux box
which is technically possible.

00:24:14.687-->00:24:20.359
Then another option could be to
try to emulate the whole
operating system on the Kernel

00:24:20.359-->00:24:25.164
and-and then make your own, uh,
mint client. This is also
technically possible but that

00:24:25.164-->00:24:30.102
could be a pain in the a**. And
then the quickest one which is
the one I took because I didn’t

00:24:30.102-->00:24:35.374
want to spend too much time
working on that so to find a way
to build a client using

00:24:35.374-->00:24:40.379
their-their kernel. So basically
what I’m doing is, uh, using a
device, uh, as the attacker. So

00:24:42.881-->00:24:47.886
and running my own mint client
in the operating system. Bu-but
again, this is not the only

00:24:50.122-->00:24:57.062
option. I mean, an-an attacker
could again use the option 1 or
option 2, and use its own mint

00:24:57.062-->00:25:02.000
client, in its, uh, lynex box or
whatever. So attack scenarios
using mint. So yeah, if the-

00:25:05.137-->00:25:09.908
in-in my case as I’m using a
device as the attacker, then if
the attacker connects its device

00:25:09.908-->00:25:16.682
to the network, uh, with, uh, I
mean physically with a cable or
through the wifi, then if-if its

00:25:16.682-->00:25:22.855
able to reach, uh, other access
points or controllers that are,
uh, using mint, then it can

00:25:22.855-->00:25:28.894
exploit the vulnerability. And
of course other scenario could
be that the attacker remotely

00:25:28.894-->00:25:35.834
compromised, uh, one device and
then, uh, since he has access to
the root shell then, uh, exploit

00:25:35.834-->00:25:42.674
the main issues to other, uh,
devices that that con-connected
with. And then, yes, uh,

00:25:42.674-->00:25:48.080
basically attack the main
services that are running in
access points and controllers.

00:25:48.080-->00:25:53.719
Controllers are also interesting
because they are like, kind of,
windows to the main controller

00:25:53.719-->00:25:58.924
meaning that, uh, um,
controllers can have like
hundreds of access points

00:25:58.924-->00:26:03.695
connected so if the attacker,
uh, compromised one controller
then he could, uh, compromise

00:26:03.695-->00:26:08.967
hundreds of, uh, access points.
And not only, uh, with the
vulnerabilities but also

00:26:08.967-->00:26:15.941
controllers has the ability to,
uh, change the configuration of
the access points and also even

00:26:15.941-->00:26:20.946
update the firmware of-of the
access points remotely. So, uh,
the way I created the mint

00:26:23.348-->00:26:28.353
client in-in the OS so, uh, we
have here in the OS, um,
modified python interpreter. And

00:26:31.123-->00:26:37.296
they have also their own library
such as this one for sockets.
And this allows us to, through

00:26:37.296-->00:26:42.301
Python, to create AF MINT, uh,
sockets. So they have some Pyth-
um, Python compiled files in the

00:26:44.336-->00:26:50.442
operating system and then
reverse engineering those, uh,
compiled files, I still have to

00:26:50.442-->00:26:55.681
create my own, uh, Python
client, uh, to communicate-
communicate th-through mint. So

00:26:55.681-->00:27:00.219
basically here is the mint
address which is in decimal but
is the four last bytes of the

00:27:00.219-->00:27:05.357
MAC address of the target, then
the port, the buffer, and then
you can create the AF MINT

00:27:05.357-->00:27:10.362
socket, and then send that, uh,
thr-through mint to-to the
target. Uh so one-one important

00:27:13.665-->00:27:18.937
thing about mint is that we can
expect to-to have mint where in
a scenario where we have several

00:27:18.937-->00:27:24.009
access points and controllers
because as I said, mint is used
to communicate- communications

00:27:24.009-->00:27:29.381
between devices. But also I
wanted to check if a stand-alone
access point can also, uh, use

00:27:29.381-->00:27:34.386
mint. So yes technically as I-
as I saw during the- my test and
during the research, um, it’s

00:27:36.922-->00:27:43.262
possible as we can see here
the-the mint and stand-alone
access point is, uh, enabled by

00:27:43.262-->00:27:48.267
default because you can, um, set
a stand- al- acc-access points
as bit controller for instance.

00:27:50.869-->00:27:57.442
So the attacker what only needs
to-to exploit the issues, uh, is
to know the IP Address of the

00:27:57.442-->00:28:02.581
target. I mean, there’s not any
kind of authentication. So this
is the target my-on the

00:28:02.581-->00:28:07.586
attacker’s device. This, uh,
Motorola black access point. Um.
So we only need to like to set

00:28:09.922-->00:28:16.161
controllers and the IP Address
and that mint like is, uh,
established. But this is not the

00:28:16.161-->00:28:20.832
only way to establish a mint
link. Uh. First I know there are
other-other ways. For instance,

00:28:20.832-->00:28:26.038
also if you connect, uh, an
access point in-in-in the
network, then the other access

00:28:26.038-->00:28:30.776
points could detect in-in an
automatic way this new access
point and establish the mint

00:28:30.776-->00:28:36.081
link in an automatic way.
Probably there are mor-more ways
because I am not an-an expert

00:28:36.081-->00:28:42.454
with this mint thing. So yeah
so, after that, in the
attacker’s device we can see

00:28:42.454-->00:28:47.326
that, uh, with the “show mint
neighbors” we can see that
the-the mint link is already

00:28:47.326-->00:28:53.131
established. So now we can
commun-communicate through mint.
So now we just need to-to yet to

00:28:53.131-->00:28:59.338
find backs in-in mint services.
So there are a lot of binaries
and a lot of mint services, uh,

00:28:59.338-->00:29:05.477
receiving data from-from
sockets. So this example it’s
from the HSD process. So this

00:29:05.477-->00:29:10.482
particular graph is one function
which is more or less big,
receiving data from a mint port-

00:29:13.619-->00:29:19.257
one specific mint port. And we
can see the typical pattern of
the- of this that looks like it-

00:29:19.257-->00:29:23.962
we got, like, switch-case
statements that probably are,
uh, switching through, uh an

00:29:23.962-->00:29:28.967
upcode or something probably
protocol. So one of the first
issues pre C4, um, again

00:29:32.204-->00:29:37.209
pre-auth, uh, heap overflow
where the user has control of
the sites and the source and-and

00:29:39.311-->00:29:44.316
the destination buffer is-is the
heap. But the problem that we
have here is that, um, to reach

00:29:46.585-->00:29:53.225
that particular memcpy, um, uh,
we go to- go to the- to the
case0- in the switch case

00:29:53.225-->00:29:58.997
statement and this function’s
going to be executed get session
by mac And what is going to do

00:29:58.997-->00:30:03.568
this function is to check if,
uh, the MAC address that have to
send in your buffer, it’s sen-

00:30:03.568-->00:30:08.573
it’s in a list of authentic MAC
addresses. If it’s not there,
then you won’t reach that

00:30:11.977-->00:30:16.214
particular memcpy. So luckily
there’s another case in the
switch case statement where we

00:30:16.214-->00:30:22.421
can call this session alloc
function. Where we can add our
fake MAC address in, um, that

00:30:22.421-->00:30:29.327
particular list. So first we
nee- we just need to- to execute
this Python code. We will add

00:30:29.327-->00:30:34.332
this fake MAC address, uh, 41,
41, 41, 41, uh, to that
particular list. And then after

00:30:37.002-->00:30:43.975
that since our fake MAC address
is in- already there in that
list, then we can said- we can

00:30:43.975-->00:30:50.348
reach that, uh, memcpy, that
heap overflow memcpy. And here
you can see in our bu- in our

00:30:50.348-->00:30:56.288
buffer we are providing the-the
fake MAC address and the rest is
the protocol stuff to-to reach

00:30:56.288-->00:31:02.494
the memcpy. And then here we
have the-the rest of this
memcpy- this, uh, heap overflow.

00:31:02.494-->00:31:07.299
With, uh, since we don’t have
modern exploitive
investigations, and-and the libc

00:31:07.299-->00:31:14.106
version is all in this operating
system, it shouldn’t be too
complex to get, uh, collegation

00:31:14.106-->00:31:19.111
from this heap overflow. Then we
got more heap overflows like
this one. Um. Pretty much the

00:31:21.913-->00:31:27.352
same in another switch case
statement. But basically is
exactly the same that, uh, the

00:31:27.352-->00:31:33.258
source user control, site user
control, and the destination is
a heap buffer. Now this is the,

00:31:33.258-->00:31:38.263
uh, the vulnerability that I
will try to use in the demo. So
it’s a stack overflow through

00:31:41.032-->00:31:46.938
mint as well. So it’s another
memcpy where the destination
buffer is in a stack buffer

00:31:46.938-->00:31:52.644
obviously. And the size is also
user controlled. But the-the
size and the source comes from

00:31:52.644-->00:31:57.682
the heap buffer. And it’s the
heap buffer that we were
discussing before with the heap

00:31:57.682-->00:32:02.621
overflow. So, um, the problem
that we have here is that, this
is the memcpy that, uh, for the

00:32:04.890-->00:32:10.962
stack overflow. So if we want to
reach the-the veteran others in
the- in the stack, our buffer

00:32:10.962-->00:32:16.635
has to be big enough to reach
that. So the problem as-as the
source comes from the heap then

00:32:16.635-->00:32:22.741
we will have to also overflow
the- the heap buffer and also
overflow the, uh, next chunk and

00:32:22.741-->00:32:29.714
the next chunk’s metadata. And
we could have problems with the
Lypses’ sanity checks because,

00:32:29.714-->00:32:34.719
uh, if, uh, if the sanity
checks, uh, uh, triggers here,
then, uh, it wo- it could crash

00:32:36.988-->00:32:43.061
the-the process and then, uh,
it-it could ruin ou-our exploit.
But in this case, it’s not going

00:32:43.061-->00:32:48.633
to be a problem because, uh, in
between there are no other
locations to freeze and so it

00:32:48.633-->00:32:54.639
won- it won’t crash and we will
able to-to reach the-the stack
overflow after the, uh, heap

00:32:54.639-->00:33:00.812
overflow. So for the exploit, as
I said, we don’t have modern
exploit mitigations so we could

00:33:00.812-->00:33:06.151
think, “Ok. We just need to- to
jump to our circuit and-and
that’s it.” But no, uh, eh, so

00:33:06.151-->00:33:12.557
if you guys are familiar with
MIPS exploitation, there’s a
well known problem is the cache

00:33:12.557-->00:33:18.697
incurrence problem. So we go t-
in MIPS CPU with two different
cache: the instruction cache and

00:33:18.697-->00:33:25.403
the data cache. And normally our
payload, uh, so our circle, it
could be in the store- it could

00:33:25.403-->00:33:28.340
be stored in the data cache. So
the problem is that when we try
to jump to our circuit in the

00:33:28.340-->00:33:30.408
memory if the-the circuit is
still in the data cache and is
not flashed, then we could end

00:33:30.408-->00:33:32.510
up, uh, trying to execute
another instruction that are
in-in the memory. So what we

00:33:32.510-->00:33:35.280
just need to do is to fill the
data cache and then, um,
one-one-one possibility is to

00:33:35.280-->00:33:37.282
fill a data cache to flush it,
but depends on how big it is,
this cache. Another option could

00:33:37.282-->00:33:39.284
be to, um, call a blocking
function-function such as Sleep
using ROP. I’m using ROP because

00:33:39.284-->00:33:41.286
we could think here like, “Ok.
I’m going to write down a small
shellcode which, uh, calls Sleep

00:33:41.286-->00:33:43.288
and that’s it.” But yet we-we
could end- we could have the-the
same problem like, uh, the

00:33:43.288-->00:33:48.293
attack mini shell code could be
still at the, uh, the cache and
then we will- we won’t be able

00:34:09.648-->00:34:15.020
to reach, uh, that. So that’s
why we are using ROP. And-and
then after that, then the cache

00:34:15.020-->00:34:20.025
will be flushed and we can jump
to-to our shellcode. So for
the-the abrupt exploit, um, from

00:34:31.636-->00:34:37.475
the epilogue of-of the function
where we have the standard flow
we can know what registers we

00:34:37.475-->00:34:42.714
have control with so this is
very useful for the-for the ROP
obviously. And then this is

00:34:42.714-->00:34:48.453
the-the-the gadgets that I’m
using to-to execute the sleep
and then jump to the shellcode

00:34:48.453-->00:34:53.458
and then all of them from the
LIBC. For the shellcode, I’m
using, uh, a standard reverse

00:34:56.728-->00:35:01.666
shellcode. Uh. Not a big deal,
but um- I mean, there are- on
the internet we can find

00:35:05.070-->00:35:11.176
several, um, MIPS shellcodes for
Linux. Um. Even metasploit
provides, uh, MIPS shellcodes.

00:35:11.176-->00:35:16.214
But, uh, on this particular one
is from an exploit database but
none of these are going to work

00:35:16.214-->00:35:20.852
in the system. And as far as I
know, um, and I tried to find
shellcodes that could work in

00:35:20.852-->00:35:27.726
this system are not going to
work. Um. And that’s why mainly
because this is a MIPS N32. So

00:35:27.726-->00:35:33.498
MIPS N32 has some
particularities for instance, it
uses 64-bit registers but uses,

00:35:33.498-->00:35:38.503
uh, 32-bit memory addresses. But
also, what it has is different
syscall codes. That’s why the

00:35:41.473-->00:35:46.411
sockets are not going to work.
So it’s not a big deal. You can
just open the LIBC and just see

00:35:46.411-->00:35:51.416
its syscall codes for its, uh,
APIs that your circuit is, uh,
calling. For instance, this is

00:35:53.418-->00:35:59.090
the socket, uh, function. And
this is syscall call for this
function. And then after that

00:35:59.090-->00:36:04.029
then you-you got your MIPS N32
shellcode that is going to work.
Uh. Which by the way is big

00:36:07.165-->00:36:12.170
endian. So for the exploit, um,
yup so remember that I’m using
the, uh, the black access point,

00:36:16.107-->00:36:21.579
uh, as the attacker. And it’s
going to attack the-the white,
uh, Motorola access point I have

00:36:21.579-->00:36:28.486
here. Um. So this graph
represents better the-the
exploits so you can understand

00:36:28.486-->00:36:34.192
better. And I’m going to exploit
it through, uh, a mint exploit
throu-through the wifi. So this

00:36:34.192-->00:36:39.064
is the attacker’s laptop which
is my MAC here. So I’m going to
connect here through the wifi to

00:36:39.064-->00:36:44.002
the target access point that,
uh, because the access point is
providing a-a wifi obviously.

00:36:44.002-->00:36:48.840
Then, I have an ethernet cable
connected to the attacker’s
device. And using the-the

00:36:48.840-->00:36:55.680
internet sharing of-of Mac OS
feature, then- and now the
attacker’s device can connect-

00:36:55.680-->00:37:02.454
have connectivity to the target
through-through the wifi. And
then three basic steps. I’m

00:37:02.454-->00:37:07.826
going to run the net calditioner
in my- in my, uh, laptop. Then
I’m going to execute the mint

00:37:07.826-->00:37:13.364
exploit whi-which, uh, will
chain three different things as
I will explain. And then through

00:37:13.364-->00:37:18.002
the wifi, it’s going to exploit
the mint vulnerability. And then
the reverse shell it will

00:37:18.002-->00:37:23.007
connect back to-to my listener.
So let’s see if it works.
Fingers crossed. So I’m

00:37:29.414-->00:37:34.419
connected to this access point
moto test which is the-the-the
target device. And here is the,

00:37:40.325-->00:37:45.330
uh, the AP 7131-91FD80 which is
my- the attacker’s, uh, device.
So with this command- oh nice,

00:37:56.407-->00:38:01.346
[inaudible mumble] [to himself]
show mint neighbors Now we can
see with this command that the

00:38:05.917-->00:38:10.922
mint link is already established
between the tar- the attacker’s
device and the target. Then I’m

00:38:18.296-->00:38:23.301
going to access to the- to the
root shell. So we have this, uh,
shell script which is going to,

00:38:28.606-->00:38:35.480
um, execute, uh, three different
python scripts. The first one is
the one that adds our fake mac

00:38:35.480-->00:38:40.451
address in that particular list
so we can reach the heap
overflow. Then the second one is

00:38:40.451-->00:38:44.722
going to trigger the heap
overflow so we’re going to
overflow the heap with our

00:38:44.722-->00:38:50.228
shellcode and ROP gadgets. And
then finally we’re going to
ex-execute- or trigger the stack

00:38:50.228-->00:38:55.233
overflow which, uh, that
particular memcpy is going to
get from the heap buffer the-the

00:38:58.670-->00:39:03.608
shellcode and the ROP gadgets.
And also I have here the nc-lv
listener. So let’s see if it

00:39:06.344-->00:39:11.349
works or not. There you go. So
here we have the-the-the reverse
shell and with, uh, as a root as

00:39:21.359-->00:39:26.364
you can see. And you can see
here that this is the-the
AP7131, uh, 36F3E0 device which

00:39:30.068-->00:39:35.073
is the-the target, um, because
the attacker was the, uh, the
91FD80. So yes, this is the

00:39:43.047-->00:39:48.052
exploit for the our one
particular mint vulnerability,
uh, over the-the air through the

00:39:57.862-->00:40:02.867
wifi. [clapping] So, uh, finally
as a conclusion, uh, so Extreme
Networks were, uh, really

00:40:06.104-->00:40:11.109
responsive to-to us and they,
uh, provided, um, fixes and
patches for, uh, most of the-the

00:40:13.478-->00:40:18.483
issues. Um. Here I’m sharing
with you guys the link where you
can check, uh, uh, the patches

00:40:21.019-->00:40:25.823
and-and some other information.
But at the beginning apparently
they-they didn’t understand well

00:40:25.823-->00:40:31.029
the-the impact of the issues
because also they were saying
that, uh, none of the

00:40:31.029-->00:40:37.368
vulnerabilities can be directly
exploited over the air which is
not true as you just, uh, saw.

00:40:37.368-->00:40:40.938
Um. And-and some other stuff
like for the mint
vulnerabilities they were saying

00:40:40.938-->00:40:46.911
that, um-um, that the attacker
must have access to a WiNG
device that has already been

00:40:46.911-->00:40:53.251
compromised- that’s not true. I
mean, I’m using my own device so
the attacker can use its- his

00:40:53.251-->00:40:58.056
own device. But also, uh, the
attacker technically could
create his own mint client in

00:40:58.056-->00:41:02.994
his lynex box. So this is not a
must. Um, but yeah, we
originally, uh, spoke, uh, with

00:41:05.463-->00:41:12.070
them and then they-they realized
that it was wrong and they
changed all this information and

00:41:12.070-->00:41:17.008
they are accepting now that, uh,
the vulnerabilities can be
exploited over the air and

00:41:17.008-->00:41:21.446
the-the attacker doesn’t need to
compromise a device to exploit
the mint issues and some

00:41:21.446-->00:41:26.451
other-other stuff so that’s
good. So, so yeah, uh, finally
I- yes, I think there’s a lot of

00:41:30.455-->00:41:35.660
room fo- room for improvements
in this, uh, operating system
because there are more

00:41:35.660-->00:41:42.533
vulnerabilities in-in this OS.
Uh. So yeah. Um. I know. Uh.
Hopefully, uh, with this lessons

00:41:42.533-->00:41:47.538
learned they-they will fix in a
proactive way more issues. And
then we will have more, uh,

00:41:49.640-->00:41:54.645
secure WingOS devices, uh, out
there. So that’s it. So thank
you very much. And if you have

00:42:01.919-->00:42:06.924
any questions I’ll be around
here. [applause]

