00:00:00.000-->00:00:05.005
>>So very excited to bring up
our next speaker. And I am going
to try this again Jianjun

00:00:08.642-->00:00:13.647
Jianjun Dun Dai Jianjun Dai.
Awesome! So he is going to talk
about uh owning Android devices.

00:00:16.850-->00:00:22.422
How many of people have Android
devices? Yeah be afraid be very
afraid he’s coming for your

00:00:22.422-->00:00:27.427
things. Let’s give our speaker a
big round of applause.
[applause] >>Thank you, thank

00:00:29.796-->00:00:34.801
you. >>Have a great time man!
>>Thank you Jon. Hi everyone.
Today I will present how we Pwns

00:00:42.042-->00:00:46.613
the toughest target and won the
largest bug bounty in the
history of the ASR program.

00:00:46.613-->00:00:51.618
Originally my colleagues, Guang
Gong and Wenlin Yang came to
explain to you but they could

00:00:54.855-->00:00:59.860
not come due to their Visa. As
we know the Pixel phone is
protected by many layers of

00:01:02.763-->00:01:07.768
security. In the 2017 mobile
Pwns war Samsung, iPhone have
been pwned many times. But only

00:01:12.806-->00:01:17.811
Pixel was a survivor. No
research no researchers even to
challenges. But our team

00:01:20.714-->00:01:26.720
discovered a working
exploitation which could
compromise the picture phone

00:01:26.720-->00:01:31.725
remotely. Because of the
severity of our detailed report,
we were award the highest reward

00:01:35.295-->00:01:40.300
in the history of the ASR
program. Next I will show the
details. First introduce myself

00:01:50.577-->00:01:55.582
and my colleagues. I am a
research, security researcher at
three sixty Alpha Team and

00:01:58.452-->00:02:05.325
focused on Android system
security research with mobility
hunting and exploiting. Guang

00:02:05.325-->00:02:12.199
Gong senior security researcher
at Alpha Team and he focused on
Android and Chrome security

00:02:12.199-->00:02:18.171
research. He has spoken at
several security conference and
the winner at many famous

00:02:18.171-->00:02:23.176
contests like Pwn2Own, Pwn2Own
Mobile. Wenlin Yang is a
security researcher at three

00:02:26.380-->00:02:31.385
sixty Alpha Team and he focuses
on Android system security
research. In this talk I will

00:02:36.890-->00:02:41.895
introduce how we pwned Pixel. We
used two bugs to pwn Pixel. One
we V eight bug ending to

00:02:45.432-->00:02:50.437
compromise the renderer and
other is system server bug. That
is use to escape sandbox and

00:02:54.674-->00:02:59.680
achieve elevation of private
manage I will show the details
later. Here is my agenda. This

00:03:05.252-->00:03:12.159
piece mainly includes three
parts. How to exploit the V
eight engine bug and then

00:03:12.159-->00:03:17.164
exploits the bug of system
server process. Finally we will
make some conclusions. So I will

00:03:24.438-->00:03:29.443
show the first part and
introduce the Shared Array
Buffer and Web assembly and then

00:03:31.978-->00:03:36.983
analyze the first part of the
exploit chain CVE twenty
seventeen fifty one sixteen and

00:03:39.653-->00:03:44.658
then I will talk about how to
exploit the vulnerability.
Shared Array Buffer object is

00:03:50.931-->00:03:55.936
used to represent a generic
fixed lense low binary getter
buffer similar to the array

00:03:58.538-->00:04:03.477
buffer object. We add six dot
zero introduced support for
shared array buffer a low level

00:04:08.181-->00:04:13.186
mechanism to share memory
between between JavaScript
workers and the synchronized

00:04:16.890-->00:04:21.895
control flow across workers.
SharedArrayBuffer gives Jav
JavaScript access to certain

00:04:25.599-->00:04:30.604
memory atomics and phonetics
SharedArrayBuffers also unlock
ability to port thread

00:04:34.307-->00:04:39.312
applications to the web via asm
dot js or WebAssembly.
Unfortunately SharedArrayBuffer

00:04:43.783-->00:04:48.788
was disabled by default in all
major browsers on January twenty
eighteen in response to Meltdown

00:04:55.795-->00:05:00.734
and Spectre. But we reported the
bug on July twenty seventeen so
not a fair date maybe the web

00:05:05.906-->00:05:10.911
enabled in the future. It’s
worth paying attention to.
WebAssembly is a new type of

00:05:15.816-->00:05:20.821
code that be run in the modern
web browsers. It is a low-level
assembly-like language with a

00:05:23.657-->00:05:28.662
compact binary format that runs
with near-native performance and
a profile language such as C, or

00:05:33.400-->00:05:38.405
C plus plus with a compilation
target so that they can run on
the web. It is also designed to

00:05:41.608-->00:05:46.613
run alongside JavaScript
allowing ports to work together.
Here is an example how this

00:05:50.850-->00:05:55.855
unfold the function that export
from the simple dot XXM file. Ok
I introduced some basic

00:06:05.165-->00:06:10.170
knowledge so and I will analyze
each bug in detail. The
vulnerability was fixed in

00:06:13.306-->00:06:18.311
Chrome sixty one dot zero dot
thirty one sixty three dot
seventy nine. So from sixty to

00:06:22.082-->00:06:27.087
person priorities maybe effect
by combining the three features,
SharedArrayBuffer, WebAssembly

00:06:33.393-->00:06:38.398
and Web Worker in chrome. And
OOB access can be triggered
through a race condition.

00:06:45.639-->00:06:52.178
Assembly speaking. Web Assembly
code can be put in to a
SharedArrayBuffer and then

00:06:52.178-->00:06:57.183
transferred to a web worker then
the main thread parses the web
assembly code the worker switch

00:07:01.221-->00:07:06.226
can modify the code at the same
time which causes an OOB access.
Here is a buggy, the buggy code.

00:07:13.466-->00:07:18.471
The Buggy code it’s in the
function GET first argument as
bytes. Where’s argument args may

00:07:23.610-->00:07:28.615
be in an Array buffer or typed
array object. Other shared array
buffer is imported to javascript

00:07:31.985-->00:07:36.990
a typed array can be backed by a
shared array buffer. So the
contents of a typed array can be

00:07:40.794-->00:07:45.799
modified by other work threads
at the same time. Here is the
POC. The workers thread modified

00:07:53.306-->00:07:58.311
by a web assembly code. At the
same time another thread is
parsing the code. Yeah. The web

00:08:02.916-->00:08:07.921
assembly code is put in to a
Shared Array Buffer then a typed
array buffer object is created

00:08:16.029-->00:08:21.034
using the shared array buffer as
a buffer. After that a worker
thread is created and the shared

00:08:23.803-->00:08:28.808
array buffer is passed to the
newly created worker thread.
While the main thread is parsing

00:08:32.545-->00:08:37.550
the web assembly code the worker
thread modifies the shared array
buffer. After the main threads

00:08:42.255-->00:08:47.260
bug bug check the instruction
code zero can be modified by the
worker thread to code one

00:08:52.365-->00:08:59.105
hundred and twenty eight and
then parsed and compiled by the
main thread so OOB access

00:08:59.105-->00:09:01.041
occurs. The last part is the
assembly code. So it’s function
core zero was modified to call

00:09:01.041-->00:09:06.046
one hundred and twenty eight
making OOB access. The call zero
function can be modified to call

00:09:29.436-->00:09:34.441
any other web assembly function.
So the exploitation of this pack
is straight forward. If call

00:09:37.977-->00:09:42.982
zero is modified to call dollar
leak researchers and stack of
contents are dumped to web

00:09:45.652-->00:09:52.425
assembly memory because function
zero and function dollar leak
have a different number of

00:09:52.425-->00:09:57.430
arguments the result this
results in many uses of pieces
of detter in the stack being

00:10:09.409-->00:10:14.414
leaked. Sorry. We cannot modify
the instruction call zero any
core function x instruction can

00:10:21.387-->00:10:26.392
be modified. Assume function x
is a web, WASM with six
arguments as shown above. When

00:10:33.333-->00:10:38.338
we V eight compromise the
function is IA thirty two
architecture the first five

00:10:44.611-->00:10:49.616
arguments are passed through the
registers and the sixth argument
is passed through stack. All the

00:10:53.586-->00:10:58.591
arguments can be said to be
divided any by java script. So,
when a java script function

00:11:01.928-->00:11:06.933
calls a web assembly function V8
compiler creates a js to wasm
function internally after

00:11:14.040-->00:11:19.045
completion the java script
function will call JS to WASM
function and then JS to WASM

00:11:26.152-->00:11:31.157
will call the web assembly
function JS to WASM function
used different call convention

00:11:35.028-->00:11:40.033
its first arguments is passed
through stack. So if we modify
core function x to call JS to

00:11:46.706-->00:11:51.711
WASM function what will happen?
The JS to WASM function will
take the six arguments of

00:11:56.950-->00:12:01.888
function x as the first argument
but you take the first argument
as an object pointer so tab

00:12:06.092-->00:12:11.097
confusion will be tracked when
the argument is passed to the
two number function this means

00:12:14.200-->00:12:19.205
we can pass any values as an
object pointer to the two number
function so we can fake an array

00:12:23.376-->00:12:28.381
buffer object in some address
such as email type array and
positive address to number

00:12:32.352-->00:12:37.357
function Exploit of an OOB
access in V eight is
straightforward. Usually through

00:12:42.161-->00:12:47.166
these few steps. Leak array
buffer’s content and then fake
an array buffer a double array

00:12:53.272-->00:12:58.277
by using leaked data next pass
faked array buffers address to
ToNumber. Modify BackingStore

00:13:04.283-->00:13:09.288
and Bytelength of the
ArrayBuffer in callback. Get
arbitrary memory read and write

00:13:13.259-->00:13:18.264
and finally overwrite JIT code
with shellcode. A lot of
researchers have talked about

00:13:22.201-->00:13:27.206
the exploitation methods. I will
not explain this in detail. Here
is the patch. Just copy the web

00:13:36.049-->00:13:41.054
assembly code and two pairs
without using shared memory.
Next I will talk about the

00:13:50.096-->00:13:55.101
second bug of the four
exploitation. Analyze the bug
and introduce a way to escape

00:13:57.236-->00:14:02.175
sandbox and show how we exploit
the bug. The sandbox is caused
by map and unmap mistake and

00:14:14.987-->00:14:19.992
cause are used on unmap the bug
and code is in the function
grallocmap and gralloc unmap

00:14:25.932-->00:14:30.937
both standards are in libgralloc
map module. Gralloc maps graphic
buffer to memory space the

00:14:41.914-->00:14:46.919
gralloc, graphic buffer is
controlled by the arguments
handle. The handle pointer is

00:14:51.224-->00:14:56.229
controlled by chrome renderer
process. While mapping, the map
address plus the plus an offset

00:15:02.034-->00:15:07.039
is sent to a base pointer. The
mapped memory will be all mapped
in function gralloc map. Let’s

00:15:11.778-->00:15:16.783
have a look. While mapping base
pointer is passed to system core
unmap give actually without

00:15:26.459-->00:15:31.464
[indiscernible] offset this
offset is not used at all. As a
result map and unmap are

00:15:33.800-->00:15:38.805
mismatched. However the member
offset can be manipulated from a
chrome standard process so its

00:15:49.816-->00:15:54.821
possible to unmap any pages in
system server from chromes
standard renderer process. We

00:16:02.061-->00:16:08.434
have achieved RCE but if you
want to trigger the system
server bug from the from the

00:16:08.434-->00:16:13.439
group we have to bypass the
sandbox then I will introduce a
way to escape sandbox. In the

00:16:17.510-->00:16:22.515
picture we can see that crew is
a sandbox process belonged to
isolated app domain. From the

00:16:25.885-->00:16:30.890
sepolicy file of isolated app a
view service like an activity
service can be caused in sandbox

00:16:41.400-->00:16:46.405
process. Or so we can get
activity service from the
sandbox process. Then when

00:16:48.608-->00:16:53.613
starting activity function
inverse not isolated caller will
be involved invoked. Which will

00:16:57.083-->00:17:02.021
check if the caller is is in
isolated app domain. Because of
selinux most system service has

00:17:06.759-->00:17:11.764
have been restricted to access
from sandbox process and a view
and a viewer functions can be

00:17:16.002-->00:17:21.007
called in the isolated app
domain attack surface is getting
narrow. From the code you can

00:17:25.244-->00:17:30.249
see that. This path various
restrictions regardless found in
an ingenious way that can get

00:17:38.157-->00:17:43.162
renderer process reach system
server by binder core with
parcel object. A lot of classes

00:17:48.034-->00:17:53.039
implement the interface
parcelable the member function
creates from parcel of all of

00:17:56.709-->00:18:01.647
these classes can record from
groups center post using binder
call. Graphic buffer is zero one

00:18:04.116-->00:18:09.121
is used in the exploitation. I
will use that later. This is a
case to reach system server

00:18:21.100-->00:18:26.105
avoid avoiding inverse
[indiscernible] caller and its a
remote transact by binder core.

00:18:29.075-->00:18:34.080
The binder departs from the
window is pressed from activity
options constructor. So we get a

00:18:44.390-->00:18:49.395
way to reach the system server
from Chrome. Core creates from
parcel to create a binder

00:18:52.398-->00:18:57.403
encapsulated with a graph buffer
and [indiscernible] method
convert to translucent and pass

00:19:04.644-->00:19:09.648
a miniature responder to system
server. Exploit bug. We complete
the exploit through the six

00:19:21.560-->00:19:26.565
steps shown above. Next our
detail is step Step one. Address
space shaping. We make the

00:19:36.609-->00:19:41.614
address lookout as shown above.
A heap chunk is right above some
continuous ash memory mapping

00:19:50.356-->00:19:55.361
Step two, trigger the bug, unmap
part of heap and a ashmem memory
unmap four kilobytes in heap

00:20:08.007-->00:20:13.012
chunk and two million minutes to
four kb in shared memory. Shared
memory twenty nine. So there is

00:20:25.658-->00:20:30.663
two m cap between heap chunk and
a shared memory twenty nine Step
three fill the unmapped space

00:20:41.607-->00:20:46.612
with ashmem memory. The gap is
filled with a shared memory one
thousand and one. Step four

00:21:00.526-->00:21:05.531
spray the heap. The heap theater
will be writing to the shared
memory the heap manager believes

00:21:10.035-->00:21:16.475
the memory range between the two
red address is still monitored
by each and the will allocate

00:21:16.475-->00:21:21.180
resulting in heap theater is
writing to a shared memory. Step
five allocate graphic buffer

00:21:21.180-->00:21:25.251
objects in a shared memory
overwrite virtual function
pointer because the felt shared

00:21:25.251-->00:21:30.589
memory in step three in step
three is mapped both in both by
system server and rendered

00:21:30.589-->00:21:36.228
process partial heap of a system
server can be read and writing
by renderer process and we can

00:21:36.228-->00:21:41.233
track our system server to
allocate some graphic buffer
object in a shared memory we can

00:21:41.233-->00:21:45.604
read future table of graphic
buffer object and overwrite the
reader function pointer by

00:21:45.604-->00:21:50.609
writing the a shared memory.
Step six as graphic buffer is
inherit from IEF base which has

00:22:38.357-->00:22:43.362
a member function named on last
strong ref we can read future
table address from a shared

00:22:48.400-->00:22:53.405
memory and then calculate the
address of function on last
strong ref. We found some ROPS

00:23:00.713-->00:23:05.718
chains in libui and modify the
virtual table of graphic buffer
to trigger ROP. When our graphic

00:23:14.159-->00:23:19.164
buffer object is deconstructed
the virtual function on last
strong ref is called so we can

00:23:26.805-->00:23:31.810
replace this function this
virtual function to jump to ROP.
When GC happens the control flow

00:23:39.418-->00:23:44.423
goes to ROP. Ok finally lets
summary contents of this talk.
First we compromised the chrome

00:23:52.064-->00:23:57.069
rendered with v eight bug and
then we achieved getting the
privilege of system server by

00:24:02.641-->00:24:07.646
using an ingenious way to escape
sandbox and exploiting the bug
cve twenty seventeen one four

00:24:11.283-->00:24:16.288
nine oh four composed we
replaced the four remote
exploits chain. All of these

00:24:20.559-->00:24:25.564
bugs have already fixed security
updates of December twenty
seventeen. Thanks to our

00:24:33.872-->00:24:38.877
colleagues at Alpha Team and
Core team. That’s all thank you!
[audience applause]

