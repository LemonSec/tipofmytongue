00:00:00.000-->00:00:06.807
>>Hi everyone, uh I’m Samila,
Samiliam, Jordan, whoever the
f**k you want to call me. Um,

00:00:06.807-->00:00:11.178
today I’m going to talk to you
about jailbreaking the Nintendo
3ds. And you might wondering ok

00:00:11.178-->00:00:16.316
why does this matter? Uh, well,
truth be told it really doesn’t.
Uh, it’s just kind of a way to

00:00:16.316-->00:00:18.318
piss off Nintendo and uh, the
reason Nintendo doesn’t want us
to hack their consoles is

00:00:18.318-->00:00:20.320
because you know they want to
sell games, they want to make
money off their games. Um, and

00:00:20.320-->00:00:25.325
unfortunately once you hack
these consoles, uh, it makes it
possible for people to play

00:00:29.930-->00:00:34.902
games for free, not really happy
about that. The thing is, uh
it’s actually also like a really

00:00:34.902-->00:00:40.007
interesting target in terms of
security properties and in terms
of hacking stuff. So, we’re kind

00:00:40.007-->00:00:44.678
of in the middle here of like
trying to do interesting things
but also you know bad results

00:00:44.678-->00:00:49.716
happen. So, i’m not trying to
make people have the ability to
steal games but, it kinda

00:00:49.716-->00:00:56.056
happens. Uh, anyway, first thing
about, talking about uh hacking
the 3ds is kind of introducing

00:00:56.056-->00:01:02.095
3ds, what, right what is this?
Uh, 3ds is a game console, it
was originally released in 2011,

00:01:02.095-->00:01:06.733
uh there is a new one that was
released in 2014, they’re
essentially the same thing

00:01:06.733-->00:01:13.740
except the new 3ds which you
know is a great name uh has
twice the CPU cores it has

00:01:13.740-->00:01:18.745
higher frequency, uh it has more
memory, basically the uh, twice
the amount of uh main memory.

00:01:20.747-->00:01:24.451
And uh, beyond that, they are
basically the exact same thing.
They are running the same

00:01:24.451-->00:01:28.388
operating system, which is
something I’m just going to get
into, it’s a really cool uh

00:01:28.388-->00:01:33.493
microkernel architecture and uh
they both have in addition to
the main CPU which is what runs

00:01:33.493-->00:01:39.032
their games and stuff they have
a secondary CPU which is the
ARM9 CPU. So, ARM11 here is what

00:01:39.032-->00:01:43.003
you can see in the CPU here,
it’s basically what’s going to
be running all your games, all

00:01:43.003-->00:01:46.873
your apps basically anything
that hits the screen, anything
that you can detract with is

00:01:46.873-->00:01:51.278
going to be running on that CPU.
On the other hand, you’re going
to have the ARM9, which is the

00:01:51.278-->00:01:57.351
consoles security slash io CPU,
and so the ARM9 is basically
responsible for doing a bunch of

00:01:57.351-->00:02:02.255
security task, and kind of
brokering access to a bunch of
hardware. So, in this case I

00:02:02.255-->00:02:05.625
kind of like showed some
hardware devices here, this is
not an exhaustive list, it is

00:02:05.625-->00:02:09.863
just a few examples that will
come in handy later. Uh, but so
the idea is that the ARM9

00:02:09.863-->00:02:14.301
basically has access to you know
everything, it has the keys to
the kingdom. I mean, it doesn’t

00:02:14.301-->00:02:18.338
literally have the keys actually
because the keys are on like
this crypto blob over there but

00:02:18.338-->00:02:21.675
it has the ability to talk to
the crypto hardware blob it has
the ability to encrypt and

00:02:21.675-->00:02:26.813
decrypt content, which is really
all we care about, and it also
has the ability uh to-to access

00:02:26.813-->00:02:31.284
this NAND chip which is all the
uh the you know permanent
storage as well as the az card.

00:02:31.284-->00:02:33.687
Well on the other hand if you
take a look at the ARM11, the
ARM11 first off doesn’t have

00:02:33.687-->00:02:36.123
access to ARM9 internal memory,
which kind of makes sense, but
it also does not have access to

00:02:36.123-->00:02:41.128
the crypto hardware, it does not
have access to the NAND chip, so
basically, anytime that the uh

00:02:44.798-->00:02:51.338
the ARM11 wants to access a file
on disc anywhere, it has to ask
the ARM9 very nicely to give it

00:02:51.338-->00:02:56.109
access. That gives the ARM9 the
ability to you know broker
access to-to resources kind of

00:02:56.109-->00:03:01.148
like in a kinda the same box
model. Now, taking a look at
what actually runs on the ARM11,

00:03:01.148-->00:03:06.253
uh is as mentioned a very cool,
uh, I think very cool
microkernel uh based

00:03:06.253-->00:03:11.324
architecture. And so, the idea
is that you will have as little
code as possible inside of a

00:03:11.324-->00:03:15.028
kernel, right? That is going to
be your highest level of
privilege on that CPU, you want

00:03:15.028-->00:03:19.366
to have as little code in there
and ideally have the most, like
all your drivers and stuff in

00:03:19.366-->00:03:22.836
user mode. So that’s what you’re
going to see to the right here,
in the, in the BASE memory

00:03:22.836-->00:03:27.207
region, your going to be um
having a bunch of processes
which are called system modules

00:03:27.207-->00:03:32.546
and are essentially just user
mode drivers. Uh, if you think
of a uh, of a uh monolific

00:03:32.546-->00:03:38.285
kernel like say windows, you
would actually have all these
drivers live inside the kernel,

00:03:38.285-->00:03:43.023
and what that means is that
whenever you compromise one of
the drivers, you gain access to

00:03:43.023-->00:03:46.827
the entire system. Whereas here,
if you compromise the driver,
you’re just getting access to

00:03:46.827-->00:03:52.032
whatever that driver had access
to. Because um, because the way
that this uh this operating

00:03:52.032-->00:03:57.037
system works, it actually gives
as little privilege as possible,
you know principle of privilege

00:03:57.037-->00:04:02.275
uh to each process. And so what
that means is that for example,
uh a give- a-a game is only

00:04:02.275-->00:04:06.680
going to have access to a small
portion of the system call
table. Uh same thing, you’re

00:04:06.680-->00:04:10.784
gonna have in addition to games
that are running the application
memory region you actually have

00:04:10.784-->00:04:16.423
applets which run in the system
memory, and applets are going to
include anything that can run at

00:04:16.423-->00:04:21.061
the same time as your game. So,
say stuff like home menu, the
web browser, the uh notes taking

00:04:21.061-->00:04:24.798
app, whatever, any of that c**p,
can run at the same time and so
it’s in a separate memory

00:04:24.798-->00:04:29.202
region. The whole point here is
that between the game, and the
home menu, you actually have

00:04:29.202-->00:04:33.240
access to the same set of system
calls which is fairly limited as
you can see it’s basically like

00:04:33.240-->00:04:36.510
half of all the system call
table. But then if you take a
look at one of the system

00:04:36.510-->00:04:40.080
modules, you’re going to have
access to the same set of system
calls, in addition to that, you

00:04:40.080-->00:04:44.184
will have access to new system
calls, which are going to be
privileged system calls. Uh,

00:04:44.184-->00:04:49.322
things that are going to for
example allow you to create a
service, advertise that service

00:04:49.322-->00:04:54.795
and then in addition if you have
you know a specially special
some uh system module, it might

00:04:54.795-->00:04:58.665
have access to a system call
that is only accessible from
that particular process, nowhere

00:04:58.665-->00:05:02.669
else. In addition to that you
actually need to have the
ability to talk to these drivers

00:05:02.669-->00:05:07.707
right, because they’re not just
in the kernel, they’re in these
little uh bits of the you know

00:05:07.707-->00:05:13.113
processes here, and the way that
this work is basically any given
driver, any given system module

00:05:13.113-->00:05:19.452
can advertise a uh service, and
through the kernel a game can
connect to that service, and

00:05:19.452-->00:05:23.990
kind of talk to it directly.
And, the cool thing about that
is, that much like the system

00:05:23.990-->00:05:29.429
call filtering you actually have
a uh, a service access list. And
so for example, a game may not

00:05:29.429-->00:05:35.735
be able to access this am:sys um
service, uh am standing for
application management so a

00:05:35.735-->00:05:41.007
service that lets you you know
install and uninstall uh games
or applications or whatever, so

00:05:41.007-->00:05:45.412
it makes no sense for a game
like you know Zelda to try and
install and uninstall new

00:05:45.412-->00:05:49.182
processes. However, it makes
sense for a home menu to have
access to that so you have this

00:05:49.182-->00:05:53.853
very granular level privilege
control on the system. What that
means is that even if you

00:05:53.853-->00:05:58.124
compromise the game, you might
not comp- be able to access all
of the uh attack surface that

00:05:58.124-->00:06:03.063
you want and uh you know that’s
actually like a-a really good
security model. Uh, and beyond

00:06:05.098-->00:06:11.071
that, you just wanna, just, I
just want to mention that, as
ment-like I said earlier, uh the

00:06:11.071-->00:06:18.011
ARM9 handles a bunch of the um,
of-of-of well uh the ARM9 does
handle like a bunch of tasks

00:06:18.011-->00:06:23.950
such as cryspa, crypto tasks as
well revoking access to physical
storage and uh so you actually

00:06:23.950-->00:06:28.655
have to um, to go from one
process to another, and then to
the ARM9 to complete certain

00:06:28.655-->00:06:34.861
tasks. So you have like this
very, this very deep level of
like you know different levels

00:06:34.861-->00:06:39.599
of privilege that kind of like
live one on top of the other,
and it’s not, it’s not as simple

00:06:39.599-->00:06:42.502
as just you know user mode,
kernel mode and then the
security processor, there’s

00:06:42.502-->00:06:47.741
actually different layers and
different levels of privileges
uh between those. So then if we

00:06:47.741-->00:06:52.078
take a look just at these uh
this physical memory, uh
separation because as I

00:06:52.078-->00:06:55.849
mentioned you know you have this
application memory region, you
have th-uh system memory region,

00:06:55.849-->00:07:00.287
you have the base memory region,
uh and so, these are actually
physically separated memory. And

00:07:00.287-->00:07:06.826
so you have, FCRAM which is the
main uh ra uh bank of RAM and so
that’s going to be 128

00:07:06.826-->00:07:10.997
megabytes, and it’s actually
separated into these three
regions, uh such that whenever

00:07:10.997-->00:07:15.869
you allocate memory, uh virtual
memory, like the actual physical
backing memory, never you know

00:07:15.869-->00:07:17.871
go from one region to another,
if you allocate memory from a
game it’ll be in the application

00:07:17.871-->00:07:21.308
memory region, and will never
end up in the base memory region
and that might seem kind of

00:07:21.308-->00:07:26.313
trivial, but it will come up
later. Uh, and then the thing is
you know, uh you know kernel

00:07:29.082-->00:07:33.853
from the ARM9 also it’s going to
live in ARM9 internal memory, so
you can’t actually mess with it

00:07:33.853-->00:07:38.858
from the ARM11. Then, WRAM is
going to be what contains all of
the memory that pertains to the

00:07:40.960-->00:07:45.899
ARM11 kernel, and the yeah. And
so, the cool thing is with this
kind of like really deep

00:07:45.899-->00:07:50.437
security model, in theory at
least, uh compromising the whole
system should take a number of

00:07:50.437-->00:07:54.341
exploits right? First off you
need to actually even get code
execution in the machine which

00:07:54.341-->00:07:59.212
is not trivial because uh you
know Nintendo is not Apple or
Android, like it doesn’t just

00:07:59.212-->00:08:02.415
give you the ability to create
your own apps and like run into
your console. So you need to

00:08:02.415-->00:08:06.419
actually first, you know,
compromise an application. And
from there, you’ll be, you’ll

00:08:06.419-->00:08:09.322
have, you might have code
execution but it’ll be
unprivileged. So you kind of

00:08:09.322-->00:08:13.860
want to escalate your privilege
to get more attack surface, and
so, one way to do that is to

00:08:13.860-->00:08:18.164
compromise the system module.
And from there, you might have
access to say uh more system

00:08:18.164-->00:08:22.569
calls, and maybe those system
calls are going to be um more
vulnerable than other system

00:08:22.569-->00:08:26.239
calls and then maybe you can use
those to compromise the kernel,
and then from there you will

00:08:26.239-->00:08:30.710
have the complete attack surface
of the ARM9 which is security
processor and assuming you co-

00:08:30.710-->00:08:35.548
you come from IZA you’ll get the
total control. Of course, uh,
you know you have these kind of

00:08:35.548-->00:08:39.486
arrows to the left to kind of
signal that yeah, this in
theory, in practice, you can

00:08:39.486-->00:08:43.857
kind of go from like number 1 to
number 4, sometimes I know
someone has a bug that just goes

00:08:43.857-->00:08:48.461
straight down to number 4. Uh,
but in this case, we are
actually going to explore a bug

00:08:48.461-->00:08:52.565
chain that does every single one
of these steps. And so, it’s
kind of unnecessarily

00:08:52.565-->00:08:56.903
complicated, but I do want to
show uh you know that in theory
this security model can be

00:08:56.903-->00:09:03.209
really cool and actually be
really effective and um, and
yeah. So first thing is actually

00:09:03.209-->00:09:08.214
getting code execution on the
machine. Uh, just for a little
bit of history, um, oop,k- ok

00:09:13.953-->00:09:17.924
this is supposed to be like
animated but I guess not. Okay,
yeah so for a little bit history

00:09:17.924-->00:09:24.764
there have been kind of two
classes of entry points on the
uh Nintendo 3DS and you know one

00:09:24.764-->00:09:29.135
of these is going to be things
like Cubic Ninj- the Cubic Ninja
exploit from a couple years ago,

00:09:29.135-->00:09:33.406
which is a kind of bug that is
trivial and really should not be
exploitable on any modern

00:09:33.406-->00:09:37.610
platform but is because
Nintendo's uh -endo kind of
lacks the number of root

00:09:37.610-->00:09:42.348
connections of uh mitigation on
the 3DS. And you know it kind of
makes sense, like things like

00:09:42.348-->00:09:45.585
ASLR, actually you should really
have that on 3DS, because it
doesn’t really cost much in

00:09:45.585-->00:09:49.189
terms of performance, but then
you don’t have stack cookies and
that kind of makes sense in the

00:09:49.189-->00:09:54.127
in the context of a game because
you don’t want to sacrifice
performance just for security.

00:09:54.127-->00:09:58.431
Uh and the thing is you know the
3DS also have these web
browsers, it has the actual web

00:09:58.431-->00:10:01.968
browser applet and it actually
has the youtube app which is
just a uh a web browser with

00:10:01.968-->00:10:07.373
like a fancy coat of paint, and
um, and you know the thing is
from those you can really

00:10:07.373-->00:10:12.412
trivally bypass these
mitigations anyways. Like no one
believes that a web browser

00:10:12.412-->00:10:16.716
exploit is ever going to be
stopped by ASLR or stack
cookies, uh and so kind of a

00:10:16.716-->00:10:20.720
conclusion for that is uh even
though all these bugs are
trivial and are still

00:10:20.720-->00:10:24.924
exploitable in 3DS and really
shouldn’t be, at the end of the
day the um threat model that

00:10:24.924-->00:10:29.462
Nintendo needs to adopt is that
you know, user mode will be
compromised, right so they need

00:10:29.462-->00:10:34.400
to base themselves on that. And
uh, that makes it such that you
end up with like a lot of low

00:10:34.400-->00:10:40.273
hanging fruit and the exploit
that I’m going to talk about
today is the uh the um mcopy

00:10:40.273-->00:10:46.980
app. Uh, it’s called the um you
know um microSD um network
system transfer thingy. Uh,

00:10:46.980-->00:10:52.085
basically just allows you to
access the files on your microSD
over uh network. Uh and the way

00:10:52.085-->00:10:57.090
that that is implemented is an
SMB server and because SMB is a
notoriously secure protocol uh

00:10:59.259-->00:11:03.696
[laughter] of course, uh you end
up with the- the ability to find
vulnerabilities really trivally.

00:11:03.696-->00:11:08.735
And so the way I did this, uh
took you know like an hour or
so, I just grabbed pysmb from uh

00:11:08.735-->00:11:13.239
github, uh modified a little bit
to actually talk to Nintendo's
SMB server implementation

00:11:13.239-->00:11:17.210
because for some reason it
didn’t work out of the box, and
after that, the 6 lines of

00:11:17.210-->00:11:22.215
fuzzing code. Uh which you know
just flip bits randomly and, uh
if you want to take a look at

00:11:24.350-->00:11:28.621
what that looks like in
practice, you have you know the
3DS running the SMB server here,

00:11:28.621-->00:11:33.960
uh the fuzzers running in the
background, and uh and it should
just take a couple seconds and

00:11:33.960-->00:11:40.600
then of course the 3DS is going
to crash because this you know
super s****y SMB server actually

00:11:40.600-->00:11:45.738
uh SMB fuzzer I’m sorry actually
works surprisingly well. So at
this point you know you have the

00:11:45.738-->00:11:51.411
3DS that’s crashed, uh you know
the 3DS does not normally give
you [applause] this does not

00:11:51.411-->00:11:55.415
normally like give you a- a
register dump like this like a
crash dump like that but this is

00:11:55.415-->00:12:00.119
running a custom firmware
because that is how we do
development these days. Um, and

00:12:00.119-->00:12:04.257
so, uh, i’m not going to go too
deep into detail into how that
bug works because first off I’m

00:12:04.257-->00:12:08.661
not an SMB expert, I really,
literally just went that fuzzer,
found that bug and exploited it.

00:12:08.661-->00:12:13.933
Uh, but to give a basic idea, uh
basically yeah you have this
like this is the packet that

00:12:13.933-->00:12:18.771
actually crashes the console, in
its normal form, it’s a session
set setup and xpacket whatever

00:12:18.771-->00:12:23.109
the f**k that means and it has a
couple of like you know data
blobs in there, the NTLM

00:12:23.109-->00:12:26.879
response data blob, and what I
mean by data blob is something
that is going to have variable

00:12:26.879-->00:12:30.984
lengths. So as an attacker I
control the length of these
blobs, uh and that is the NTLM

00:12:30.984-->00:12:36.189
response data blob and the
domain name data duh data blob
as well. Uh the domain name is

00:12:36.189-->00:12:41.260
actually just like a string that
says work group, um and the
vulnerability is really trivial,

00:12:41.260-->00:12:46.532
uh basically just checks the
length of the data blob, uh for
NTLM response and if it’s not a

00:12:46.532-->00:12:51.537
one specific value is going to
take another code path and that
code path just copies memory

00:12:51.537-->00:12:55.942
onto the stack, into a buffer
that has a fixed length, but
wi-you know like a length that

00:12:55.942-->00:13:00.947
has control of the attacker and
um you know obviously, you can
just like override the entire

00:13:00.947-->00:13:05.485
stack with that from a packet
that is crafted just like this.
You just make it such that the

00:13:05.485-->00:13:10.757
intel response blob is not 0x18
its going to be 0x10 and you
know you make the work group uh

00:13:10.757-->00:13:16.963
blob size be like zero uh like
like you know hundreds of bytes
instead of like 10 bytes or some

00:13:16.963-->00:13:21.367
s**t, and you actually just
override the entire stack,
you’re able to override a return

00:13:21.367-->00:13:27.306
address, you’re able to uh
redirect the CPUs execution flow
and jump into existing code and

00:13:27.306-->00:13:33.479
get remote uh you know, remote
code execution essentially. Um,
in practice you know I say

00:13:33.479-->00:13:37.784
remote code execution but in
practice that actually just
means ROP which stands for

00:13:37.784-->00:13:41.320
return oriented programming.
Just really quickly, for people
who are not really familiar with

00:13:41.320-->00:13:46.492
that, what that means is, we are
not necessarily able to inject
new code because we have this

00:13:46.492-->00:13:51.264
mitigation called DEP, uh which
is like data execution
prevention. And what DEP does,

00:13:51.264-->00:13:55.368
is basically you’re not just
able to inject code into the
process and just jump to it.

00:13:55.368-->00:13:59.272
Because the thing is any memory
that is writeable will not be
executable. So that’s actually

00:13:59.272-->00:14:02.608
like a really good uh really
good mitigation that’s actually
enforced really strictly by

00:14:02.608-->00:14:08.281
Nintendo. There is, under no
normal circumstance, like under
normal circumstances it will

00:14:08.281-->00:14:14.220
never be memory in user mode
that has-that has both writeable
and executable, or memory that

00:14:14.220-->00:14:19.892
was ever writeable will never
become executable. And so that’s
really well enforced, and what

00:14:19.892-->00:14:24.363
that means is that instead of
actually just injecting
shellcode and just jumping to

00:14:24.363-->00:14:29.135
it, you have to reuse existing
code inside the process. So
that’s what ROP is, basically

00:14:29.135-->00:14:32.538
you just override return
address, you jump to like a tiny
piece of code, make sure that

00:14:32.538-->00:14:35.608
then it’ll jump to another tiny
piece of code, another tiny
piece of code, another tiny

00:14:35.608-->00:14:39.846
piece of code which we call
gadgets and uh from there you
are actually able to do

00:14:39.846-->00:14:44.050
arbitrary competitions, call
arbitrary system calls and do
kind of whatever you want. The

00:14:44.050-->00:14:49.155
thing is um, you know my
personal affirmations for
hacking the 3DS were actually to

00:14:49.155-->00:14:54.160
run homebrew on it which is you
know games made by amateurs,
applications made by amateurs,

00:14:54.160-->00:14:59.665
that’s what it is. Uh, the thing
about that is, writing homebrew
in ROP is kind of not ideal, you

00:14:59.665-->00:15:05.438
kind of want to do it in um, in
actual native code and so you
know we are not able to-to

00:15:05.438-->00:15:09.575
create new executable memory,
we’re not able to reprotect
rewritable memory to executable

00:15:09.575-->00:15:13.946
memory but what if we don’t need
to, what if we can just actually
overwrite memory that is read

00:15:13.946-->00:15:20.119
only, and the way to do that is
through DMA right? Uh you have a
bunch of devices that have

00:15:20.119-->00:15:24.690
access directly to memory and
you know the GPU is one of them
because the GPU needs to be able

00:15:24.690-->00:15:30.329
to for example read a texture
from um you know read a texture
from memory in order to render

00:15:30.329-->00:15:35.101
something. So, it needs to be
able to write a frame buffered
memory right? And the thing is,

00:15:35.101-->00:15:39.705
uh the GPU actually has access
to all the FCRAM all the WRAM,
all the VRAM, and that means

00:15:39.705-->00:15:45.912
that you can actually just use
the GPU to render over code
pages right? Uh, in practice

00:15:45.912-->00:15:50.716
it’s not that simple because
otherwise you would just be able
to override the kernel because

00:15:50.716-->00:15:56.656
even though it technically has
access to uh WRAM which includes
the-the ARM11 kernel, um, it’s

00:15:56.656-->00:16:00.560
uh you know, there is like a
register that allows Nintendo to
limit the range that the GPU has

00:16:00.560-->00:16:04.697
access to through DMA. And so
we’re not able to just override
the kernel in fact we’re not

00:16:04.697-->00:16:09.735
even able to override system
modules or uh or home menu
because the system and base

00:16:09.735-->00:16:15.041
regions are not accessible to re
to uh the GPU. But, because the
GPU does need to be able to

00:16:15.041-->00:16:19.679
access the textures and and and
stuff the from the current game,
we do have access to the first

00:16:19.679-->00:16:24.550
half of the FCRAM and so what
that means is that if you think
of you know this is physical

00:16:24.550-->00:16:28.421
memory at the bottom, you have
virtual memory at the top, you
have uh this is going to be your

00:16:28.421-->00:16:32.391
text section so it’s readable
and executable, not writeable
um, basically you’re just going

00:16:32.391-->00:16:36.229
to use the GPU to override
physical memory at the bottom,
and it’s just well you know

00:16:36.229-->00:16:40.399
because that’s how memory works
it’s going to show up in virtual
memory and you can just jump to

00:16:40.399-->00:16:45.938
it and basically we use the GPU
to render code into you know
these physical pages, and then

00:16:45.938-->00:16:50.376
override in the same code.Right,
and so, Nintendo did not really
like that very much they tried

00:16:50.376-->00:16:55.114
to uh kind of put a wrench into
our plans, and the way they did
that was they realized, okay

00:16:55.114-->00:17:00.052
whenever people use they the ROP
chain to use a GPU to override
code with you know, other code,

00:17:02.555-->00:17:07.760
uh, they kind of rely on the
specific hard coded address. The
reason being that you know, this

00:17:07.760-->00:17:12.064
page is always going to be at
the same location in physical
memory and so we don’t really

00:17:12.064-->00:17:17.069
need to do anything fancy. So,
their idea is, oh this is before
their mitigation was put into

00:17:17.069-->00:17:23.376
place, you just have these 4
blobs of of of code and virtual
a-a-a-address space and then

00:17:23.376-->00:17:27.446
it’s just going to correspond
really trivally to these 4 blobs
of physical address space. So

00:17:27.446-->00:17:33.819
their idea is well let’s just
jumble it up. If you um, and
that way you know as an attacker

00:17:33.819-->00:17:38.090
if I try to write to physical
memory, you know because the
order is going to be kind of

00:17:38.090-->00:17:40.726
jumbled up, and you don’t know
the size of the blocks, you
don’t know where the blocks,

00:17:40.726-->00:17:45.398
which order the blocks are put
into and stuff, uh well if I try
to write to physical memory to a

00:17:45.398-->00:17:49.235
single location as before, it
might show up in the- in the
block that I want it to or it

00:17:49.235-->00:17:52.905
might show up in this other
block. And so, that means I
won’t know the location I just

00:17:52.905-->00:17:59.845
wrote to, and that's so we call
this, Physical ASLR which you
know PASLR for short, because

00:17:59.845-->00:18:04.050
that’s really what it is, and
the thing is, it’s actually kind
of a, kind of a s****y

00:18:04.050-->00:18:08.654
mitigation uh because you know a
good mitigation you want to have
mitigation that actually creates

00:18:08.654-->00:18:12.792
extra work for the hacker,
everytime they write an exploit,
the thing with this one is, you

00:18:12.792-->00:18:16.896
just kind of have to bypass it
once because it turns out ROP as
has been known for about 10

00:18:16.896-->00:18:22.168
years is turing complete and can
basically do arbitrary
computations so you can actually

00:18:22.168-->00:18:26.806
just do a 4 loop and search for
the physical piece of memory
that you want to override and

00:18:26.806-->00:18:30.776
then override it. So, we
basically have to write this ROP
chain once and then you kind of

00:18:30.776-->00:18:36.182
just reapply to every exploit,
so you know, not a great
mitigation. Uh and so what that

00:18:36.182-->00:18:42.922
means in practice is, uh if um
you know this is like the actual
just kind of write it on the

00:18:42.922-->00:18:48.761
computer, connects to the
console, hacks the console and
then we have uh execution, we

00:18:48.761-->00:18:51.764
have like the actual homebrew
menu running on the console and
you can just do that over

00:18:51.764-->00:18:56.102
network, over any console that
is running 11 point 7 or
whatever. And so, that’s the

00:18:56.102-->00:19:01.440
first stage [applause]. Uh, at
this stage we have compromised
you know unprivileged user mode,

00:19:01.440-->00:19:07.480
and uh, and um, well yeah so
that was the first step in our
in our 4 chain ex uh 4 exploit

00:19:07.480-->00:19:12.652
chain, and uh at this point we
want to somehow escalate
privilege. The thing is okay so

00:19:12.652-->00:19:17.356
we have code execution, great,
but we only have access to the
basic unprivileged uh system

00:19:17.356-->00:19:20.760
calls right, so in terms of
attacking the kernel it’s
totally doable, has been done

00:19:20.760-->00:19:26.032
several times but ideally want
to have more attack surface and
likewise if we want to escalate

00:19:26.032-->00:19:31.003
to another uh, to like an actual
system module, which might have
access to more system calls well

00:19:31.003-->00:19:34.473
uh you know end copy like this
application we just compromised
only has access to a few of

00:19:34.473-->00:19:40.279
these services. So, uh ideally
want a way to kind of migrate to
another process that might have

00:19:40.279-->00:19:45.284
access to better uh better uh
better privileges and such, and
um, well, it turns out we can

00:19:48.387-->00:19:51.724
actually kind of do that because
you know, I showed you this
slide earlier in terms of like

00:19:51.724-->00:19:55.961
what the GPU has access to, in
terms of DMA was saying it only
has access to the actual

00:19:55.961-->00:19:59.832
application region, I kind of
lied about that, it actually has
access to a little bit of the

00:19:59.832-->00:20:05.404
system region as well. It just
does not have access to the home
menus uh code section. It does

00:20:05.404-->00:20:11.010
have access though to uh the
home menus uh heap section. And
so what that means is like any

00:20:11.010-->00:20:15.815
memory that is dynamically
allocated by the home menu, I
will be able to read and write

00:20:15.815-->00:20:18.918
through the GPU. And so from
there, is actually kind of
trivial to just find some c plus

00:20:18.918-->00:20:24.090
plus objects on the heap, uh you
know modify its vtable for
example, and just have it jump

00:20:24.090-->00:20:28.294
to uh other code, then you get
code execution, well you
actually just get ROP in the

00:20:28.294-->00:20:32.064
home menu. So that’s kind of the
annoying thing, is like you
can’t use the GPU to get native

00:20:32.064-->00:20:36.969
code execution inside of the
home menu uh and so in terms of
how that works in practice, we

00:20:36.969-->00:20:42.741
have to write this whole like
service that runs in the home
menu, um, uh and that’s all in

00:20:42.741-->00:20:47.446
ROP and you know that once again
like ROP is turing complete so
you can just do whatever the

00:20:47.446-->00:20:51.750
f**k you want. And um, and yeah
so at that point, we have
compromised like these two

00:20:51.750-->00:20:55.187
processes and the thing that is
interesting, uh is as you can
see even though we don’t have

00:20:55.187-->00:21:00.426
access to any additional system
calls we do have access to the
services the home menu had

00:21:00.426-->00:21:04.830
access to, and one of those
services allows us to for
example kill processes and

00:21:04.830-->00:21:10.469
create new processes. And so the
idea then is that we can just
kill the mcopy process because

00:21:10.469-->00:21:14.306
we have code execution inside
the home menu process and
replace it with another process,

00:21:14.306-->00:21:18.978
and then use the GPU to take
over that process, and so on. So
the idea then is that we

00:21:18.978-->00:21:25.618
actually have you know in theory
we have access to any, the
privileges of any process that

00:21:25.618-->00:21:30.756
can live inside the application
region that we can start. Right
and so that means that any game,

00:21:30.756-->00:21:36.162
any app, any surface that these
have access to we, you know by
we-we kind of have access to as

00:21:36.162-->00:21:39.532
well. So we have like the
biggest attack surface that we
could physically get, from a

00:21:39.532-->00:21:44.003
unprivileged user mode, and
means that we can start looking
to some more exoteric services

00:21:44.003-->00:21:49.008
such as ldr:ro. Uh, so it lives
in the ro process and basically
what it does, is if you think of

00:21:52.144-->00:21:56.649
windows, right, windows has
these d-these DLL files,
dynamically linked libraries,

00:21:56.649-->00:22:01.754
well it turns out the 3DS does
as well. And they don’t call
them DLLS they call them CROS

00:22:01.754-->00:22:07.760
which stands for CTR relocatable
object probably, kind of just
guessing at this point uh and it

00:22:07.760-->00:22:12.164
is like an interesting process
for us to go after because it
actually has access to a very

00:22:12.164-->00:22:17.703
special um a very special system
call which actually allows us to
create new svc control memory if

00:22:17.703-->00:22:23.108
we want to, which will come in
handy later. Uh, and so taking a
look at how it works, basically,

00:22:23.108-->00:22:28.314
you first allocate a piece of
memory installed in application.
You’ll load your CRO into it

00:22:28.314-->00:22:33.352
from you know the file system or
whatever, and then you’re going
to ask ldrro to load it for you,

00:22:33.352-->00:22:38.224
and what I mean by load it is
that because it’s a dll it’s
supposed to be executable code,

00:22:38.224-->00:22:42.061
it’s going to need to be
reprotected to be executable. At
some point, as a process, it can

00:22:42.061-->00:22:47.833
have the ability to do that but
you know but this ldrro does.
So, the first thing it does is

00:22:47.833-->00:22:53.739
it actually locks it away from
the application um and then it
is going to apply you know

00:22:53.739-->00:22:58.944
dynamic linking stuff to it
which just means like relocating
some pointers and such and so on

00:22:58.944-->00:23:03.682
and then it’s going to reprotect
it as being uh executable for
the pages that that’s relevant

00:23:03.682-->00:23:09.088
for. Uh so what I mean by
locking is that my application
will not be able to write to

00:23:09.088-->00:23:14.159
that memory which makes sense
because we don’t want to uh,
well ldrro doesn’t want us to be

00:23:14.159-->00:23:18.664
able to like mess with it as
it’s happening uh and the thing
is because you know it’s the

00:23:18.664-->00:23:24.236
application itself that’s
loading this uh this CRO blob
the linker does have to be built

00:23:24.236-->00:23:28.107
defensively against like
malformed CROs. And actually it
did like fix a bunch of bugs

00:23:28.107-->00:23:33.112
there, and made it such that as
far as I can tell there’s not a
lot of vulnerabilities uh that

00:23:33.112-->00:23:35.614
you can just exploit by just
giving a malformed CRO. As
mentioned, uh the application is

00:23:35.614-->00:23:37.616
the one that allocates the
memory that is going to contain
the CRO so what that means, is

00:23:37.616-->00:23:39.618
that any physical memory for
this is going to be in the
application region, which means

00:23:39.618-->00:23:41.620
once again we can use the GPU to
kind of like mess with that CRO
blob as its being uh, relocated.

00:23:41.620-->00:23:46.625
And, you know, that sounds like
it could be a problem because it
was built defensively against

00:24:01.707-->00:24:07.279
malformed CROs but what about
CROs that are kind of modified
on the fly? Well, it turns out

00:24:07.279-->00:24:12.117
it is not secure against that at
all. Uh and so if you look at
the code that this is code that

00:24:12.117-->00:24:17.690
lives in the ro process and just
kind of is part of the
relocation uh process of this.

00:24:17.690-->00:24:21.994
Uh, the first thing is, it’s
going to go through all of the
offsets in the header of the CRO

00:24:21.994-->00:24:28.233
and kind of modify them to stop
being offsets into the CRO and
become actual pointers to a CRO.

00:24:28.233-->00:24:33.639
So basically just uh like it
just adds the base address of a
CRO to each offset in the uh in

00:24:33.639-->00:24:39.244
the header. After checking of
course that the offset is within
the bounds of the CRO right? And

00:24:39.244-->00:24:44.650
so that that could be fine the
thing is this parameter that is
going to be used later on by the

00:24:44.650-->00:24:50.622
ro process, lives in physical
memory that and so what that
means is that whenever ends up

00:24:50.622-->00:24:56.195
being you know this is for
example uh the pointer to the
segment table and the uh the

00:24:56.195-->00:25:02.501
CRO, well, the way you can see
is uh loaded from the CRO here
and then it is going to be used

00:25:02.501-->00:25:07.506
directly to both read and write
memory. So, as an attacker if I
can modify the pointer, I can

00:25:07.506-->00:25:12.511
start getting ro to read uh
which is not great for them, and
in practice we end up with like

00:25:17.516-->00:25:23.622
3 kind of weird um kind of weird
like uh corruption permatives.
The first one allows us to write

00:25:23.622-->00:25:29.128
an arbitrary uh value at an
arbitrary location as long as
there is like a byte that has

00:25:29.128-->00:25:33.932
the value 2, 8 bytes after the
location we’re trying to
override and also like the

00:25:33.932-->00:25:38.604
locati- like 4 bytes after what
we’re trying to overwrite can’t
be value zero for some reason,

00:25:38.604-->00:25:44.643
same thing below for um the
second primitive, except it has
to be by 3, then all the way

00:25:44.643-->00:25:50.115
below, it can be any value there
as long as what we’re overriding
is not value zero and uh we’re

00:25:50.115-->00:25:54.820
not actually just overwriting
it, we’re actually incrementing
it with some other value. So,

00:25:54.820-->00:25:59.525
basically we have these
arbitrary read and write uh
primitives, well actually just

00:25:59.525-->00:26:03.028
arbitrary right but they’re not
really arbitrary in the sense
that we do have these weird

00:26:03.028-->00:26:08.367
constraints here. But of course,
it’s not that hard to exploit
this, um, in practice, what I

00:26:08.367-->00:26:13.705
want to do is, get ROP inside of
this process and in order to get
to do ROP I just want to

00:26:13.705-->00:26:18.343
overwrite a return address on
the stack, and uh this is just
kind of showing uh what I can

00:26:18.343-->00:26:23.582
and cannot overwrite uh based on
these uh, based on these
primitives, what you can see in

00:26:23.582-->00:26:28.587
orange here are actually return
addresses on the stack that is
what I would want. And so what’s

00:26:36.361-->00:26:41.133
in yellow, can actually
overwrite and you can see is
there’s an actual overlap

00:26:41.133-->00:26:45.971
between return addresses that I
want to overlap, uh overwrite
and the uh locations in memory

00:26:45.971-->00:26:51.076
that I can actually overwrite.
Thing is we do have like this
corruption target here, of this

00:26:51.076-->00:26:55.948
corruption primitive here which
does allow us to overwrite
memory, actually increment

00:26:55.948-->00:27:01.353
memory at an arbitrary location
with much fewer uh constraints.
So, I don’t need a byte 3 for

00:27:01.353-->00:27:06.492
that, and instead what I’m gonna
do is I’m going to use that to
you know at this location we

00:27:06.492-->00:27:13.131
meet all these constraints for
this uh primitive, so I can use
this to actually place byte 3,

00:27:13.131-->00:27:18.237
which I can then uh you know use
this with uh the second
corruption primitive to just

00:27:18.237-->00:27:23.575
overwrite this return address
with an arbitrary value. So at
that point, you know there is

00:27:23.575-->00:27:27.913
like a little bit more to the
actual full on exploit, but this
is the basic idea, right? It’s

00:27:27.913-->00:27:33.652
pretty simple, and at this point
I will have uh ROP execution
inside of this process, and I do

00:27:33.652-->00:27:38.790
have more uh privilege than I
had before. And so what that
means in practice is I just have

00:27:38.790-->00:27:42.895
access to a few more system
calls, and I get to like look at
them and see if I can use them

00:27:42.895-->00:27:47.900
to uh actually take over the
kernel. So, taking over the
kernel. Well, now we have taken

00:27:49.935-->00:27:54.106
over this process called ro, we
have access to more system
calls, and one of the system

00:27:54.106-->00:27:59.011
calls that’s actually real
interesting is called control
process memory. Um, with control

00:27:59.011-->00:28:03.749
process, well yeah first off
this is interesting system call
because ro is literally the only

00:28:03.749-->00:28:07.386
process that has access to it.
So, in a sense you can kind of
think of ro as like an extension

00:28:07.386-->00:28:12.858
of the kernel that just like has
this one very specific proc uh
like uh goal like purpose, and

00:28:12.858-->00:28:17.529
it has has to use this very
special uh system call that was
built just for it in order to

00:28:17.529-->00:28:23.068
achieve it. The thing about
control process memory is it’s
really just the same thing as

00:28:23.068-->00:28:26.605
control memory except that it
can work cross process as long
as you have a handle to that

00:28:26.605-->00:28:30.576
other process, and that it has
fewer constraints. Uh, one of
the fewer constraints that it

00:28:30.576-->00:28:36.381
has as mentioned, is that it can
actually create or reprotect
existing memory as being

00:28:36.381-->00:28:40.819
executable. Which is really
useful for us if you just want
to ru-uh run homebrew. Uh we can

00:28:40.819-->00:28:44.957
just, we don’t need to mess with
a GPU anymore, we can just like
create new arbitrary uh

00:28:44.957-->00:28:49.494
executable memory, we can just
like do whatever we want. But
the other interesting thing

00:28:49.494-->00:28:53.198
about it is that can, it also
bypasses some of the
restrictions that control memory

00:28:53.198-->00:28:58.236
has, in terms of where it is
allowed to map memory to. Uh,
and what that means is that we

00:28:58.236-->00:29:03.642
can map the null page which is
address zero. Something that is
notoriously you know not allowed

00:29:03.642-->00:29:09.648
because a lot of bugs rely on
the, on the ability to place
memory at address zero because a

00:29:09.648-->00:29:14.186
lot of bugs are going to be
dereferencing a pointer that is
null and should not have been

00:29:14.186-->00:29:18.890
and was not checked properly.
And so, uh that’s kind of
interesting for us because then

00:29:18.890-->00:29:23.228
if we can find a null
dereference bug inside of like a
kernel, which would normally

00:29:23.228-->00:29:29.134
just be a denial service bug,
all of a sudden we might be able
to elevate it to um a uh an

00:29:29.134-->00:29:34.806
actual remote execution bug. And
so what is a good target for
null d references, typically

00:29:34.806-->00:29:41.079
it’s going to be my reallocation
because um you have a
reallocation primitive and you

00:29:41.079-->00:29:45.751
run out of memory or you just
like try to allocate memory it’s
going to return null, or

00:29:45.751-->00:29:52.524
whatever, does not check that
the pointers null and then all
of a sudden you have null

00:29:52.524-->00:29:57.629
dereference and things become
interesting for us. So, taking a
look at how the allocator and

00:29:57.629-->00:30:02.567
the kernel works for kernel
objects, uh this is basically
what it is, it’s a link list, uh

00:30:02.567-->00:30:07.305
so it’s a slab heap, what that
means is that basically for each
type of object we’re going to

00:30:07.305-->00:30:12.411
have one memory blob that’s
going to be subdivided into sub
objects, and so basically

00:30:12.411-->00:30:18.316
whenever the sub objects are uh,
are not used, they’re part of a
free list. Uh what that means,

00:30:18.316-->00:30:21.953
you know, you have that list
head and then each free object
is going to link from one to the

00:30:21.953-->00:30:27.225
other, and then allocation
object just means popping and
popping free object from this

00:30:27.225-->00:30:32.164
free list and putting it into
like whatever-whatever you want
to use it for and freeing an

00:30:32.164-->00:30:37.102
object is just going to be
pushing an object back into that
free list. And so what happens

00:30:37.102-->00:30:43.475
if we run out? Well, if we run
out, we end up having the free
list head point to null and so

00:30:43.475-->00:30:48.246
whenever you allocate an object
next, this is going to return
null and all of a sudden you

00:30:48.246-->00:30:53.452
know we might have our our um
our null dereference bug that we
want. Now what that means is

00:30:53.452-->00:30:58.323
that of course the code that
uses this allocation, uh, uh
this allocation function has to

00:30:58.323-->00:31:03.495
check the result-resulting
pointer is not null, right? If
it is zero it should destroy an

00:31:03.495-->00:31:07.632
error and usually it does, but
you can see is like that last
example there, you know

00:31:07.632-->00:31:14.239
it’s-it’s allocating a new link
list node, and uh it’s checking
that this node is not null and

00:31:14.239-->00:31:19.244
if it is not null it is going to
al- it’s going to initialize it
to zero. The thing is [audio

00:31:24.816-->00:31:28.653
cuts out] without checking for
anything. It just like, it does
this check for ll, for if it’s a

00:31:28.653-->00:31:34.993
zero but then even if it was
null it just kind of uses it
without, without caring. So, it

00:31:34.993-->00:31:40.365
is like kind of an odd
programming pattern, somehow it
ends up being in literally every

00:31:40.365-->00:31:46.404
location that the kernel uses,
these link list objects. And so
the idea then is be-becomes

00:31:46.404-->00:31:51.109
well, if we can make the kernel
run out of these link list
objects, we can make one of

00:31:51.109-->00:31:56.114
these link lists be in the null
page, which is controllable by
us uh from user mode and then

00:31:58.617-->00:32:04.623
well, once we have that we might
be able to actually take over
the kernel. So, the question is

00:32:04.623-->00:32:10.395
how do we actually make uh the
kernel run out of these link
lists? Well, um a good way to do

00:32:10.395-->00:32:15.767
that is actually just to look at
other system calls and how they
work and uh one of them is uh

00:32:15.767-->00:32:21.072
wait synchronization n, uh it is
a system call that is basically
the same thing as wait

00:32:21.072-->00:32:26.111
synchronization 1, the only
difference that wait
synchronization 1 waits on one

00:32:26.111-->00:32:31.249
object, whereas wait
synchronization n, waits on n
objects, which I know it’s

00:32:31.249-->00:32:36.054
pretty obvious, um the thing is,
what I mean by waiting on an
object is going to be something

00:32:36.054-->00:32:39.491
like a-a kernel object, like a
thread, uh when you’re waiting
on a thread that means that

00:32:39.491-->00:32:43.929
you’re going to have your
current thread wait until that
other thread is dead and then

00:32:43.929-->00:32:47.732
your, your thread is going to be
woken up, it’s going to get an
event, you can also be waiting

00:32:47.732-->00:32:52.737
on an event object, on mutex, uh
waiting on mutex just means you
know waiting until that mutex is

00:32:54.806-->00:33:00.979
not locked anymore, that’s the
basic idea of [audio cuts out].
Take in objects as input and and

00:33:00.979-->00:33:06.284
practice that's up to 256
objects, and then it’s going to
wait on them and as soon as one

00:33:06.284-->00:33:11.923
of them is signaled, it’s going
to wake up your thread and uh do
whatever. Now, the question is

00:33:11.923-->00:33:17.996
okay it has to wait on these 256
objects somehow, so it has to
keep track of them somehow, and

00:33:17.996-->00:33:24.336
the way that it does that of
course is a link list right? So
the idea then becomes well, if

00:33:24.336-->00:33:30.542
we can create as many threads as
we want, and have each one of
them wait on as many objects as

00:33:30.542-->00:33:35.680
we want, then we’re gonna be
creating a bunch of these link
lists that all have you know as

00:33:35.680-->00:33:40.685
much as, as many as 256 objects
in them and well there’s only
about 1500 um uh link list nodes

00:33:43.622-->00:33:47.692
that are allocated in the
kernel, so after, after a few
attempts we should be able to

00:33:47.692-->00:33:53.832
get it to actually run out. And
um, yeah so that, that is
essentially what we do and we

00:33:53.832-->00:33:59.137
can actually trigger a null
dereference bug that way. Uh,
the thing is it’s not trivial to

00:33:59.137-->00:34:04.776
exploit necessarily because
well, it turns out link lists
are using the kernel a lot, and

00:34:04.776-->00:34:10.448
uh the problem is, well, what if
another process is trying to use
you know a system call because

00:34:10.448-->00:34:15.053
that’s what processes do, uh and
it needs to use a link list
because that’s what the kernel

00:34:15.053-->00:34:19.824
does, uh and it has run out,
well, it’s basically going to
crash because that other process

00:34:19.824-->00:34:24.796
does not have the null page
mapped into it. So it’s not
great, uh and then the other

00:34:24.796-->00:34:30.201
thing is, even if our own
process might have another
system call or even the current

00:34:30.201-->00:34:34.039
system call because if you, if
you look at this you know, it’s
going to just continue

00:34:34.039-->00:34:39.110
allocating new link lists ova uh
new link list nodes over and
over again, right and so even

00:34:39.110-->00:34:43.214
after we’ve triggered the
vulnerability we’re still going
to be keeping uh keeping uh like

00:34:43.214-->00:34:48.453
we’re still gonna keep like
allocating uh new nodes after
this. And so, the problem with

00:34:48.453-->00:34:53.591
that is, next time a node is
allocated even if it’s in our
current process, null is going

00:34:53.591-->00:34:58.830
to be returned, and if it’s from
another list you’re going to end
up with two lists that you know

00:34:58.830-->00:35:03.802
collide into the same node, and
you end up with like all these
link lists from the kernel that

00:35:03.802-->00:35:08.373
are like kind of mangled into
one another and uh that gets
really messy really quick, and

00:35:08.373-->00:35:14.279
we want to avoid that if
possible. So a way to do that is
a, is basically to just kind of

00:35:14.279-->00:35:18.249
do this thing uh just call it
like just in time freeing but
it’s really not as fancy as it

00:35:18.249-->00:35:24.656
sounds, the idea is as soon as
you’re going to have a link list
node allocated in the null page,

00:35:24.656-->00:35:29.561
it’s going to write data to that
null page. So, because the 3DS
has multiple CPU cores, you can

00:35:29.561-->00:35:34.399
basically just have one thread,
do that uh you know that null
dereference bug by keeping uh

00:35:34.399-->00:35:39.204
like allocating more and more
and more uh linked list nodes
and you can have the other CPU

00:35:39.204-->00:35:44.409
just like reading from null page
at all times and as soon as it
sees that you know zero has

00:35:44.409-->00:35:49.647
changed into like a pointer
value, uh be it like next
pointer, previous pointer and

00:35:49.647-->00:35:54.452
the object pointer, it’s going
to be able to take action. So,
as soon as it sees that, the

00:35:54.452-->00:35:59.958
first CPU core, so core 0, is
just going to signal an object
another thread was waiting on,

00:35:59.958-->00:36:05.363
and it’s just going to free a
bunch of these uh of these uh
link list nodes, and the next

00:36:05.363-->00:36:09.300
time we have an allocation, is
just going to use one of these
link list nodes as it was just

00:36:09.300-->00:36:14.672
freed. Obviously, that’s how we
get around the whole issue. Now
the question is, okay we’re able

00:36:14.672-->00:36:18.676
to trigger this bug and we’re
able to do it without crashing
everything which is great but,

00:36:18.676-->00:36:23.748
how do we actually exploit this
to get execution inside the
kernel? Uh well typically like

00:36:23.748-->00:36:28.353
I’m sure like people who are
familiar with uh linked list
bugs will know that basically

00:36:28.353-->00:36:33.792
you want to do this through the
unlinking uh phase, and so just
like explain how that works, so

00:36:33.792-->00:36:38.196
basically, imagine you have this
linked list right so each la-
each note is going to point to

00:36:38.196-->00:36:43.068
the other previous one, so when
you free, let’s say node 2,
what’s going to happen is just

00:36:43.068-->00:36:46.738
you have to update the next
pointer from node 1, and the
previous pointer from node 3,

00:36:46.738-->00:36:52.710
it’s pretty straight forward.
Now, the thing is, in our case,
we actually control node 2,

00:36:52.710-->00:36:57.215
right, we have full control over
the next pointer value, and the
previous pointer value, and so

00:36:57.215-->00:37:02.787
let’s say in this case that you
know we we save at next points 0
x babe and previous points to 0

00:37:02.787-->00:37:08.793
x dead. Well, if we try to
unlink the bad node, what’s
going to happen is that it’s

00:37:08.793-->00:37:14.933
going to write the uh you know,
the next um, it’s going to write
the value of the previous, to

00:37:14.933-->00:37:17.836
next, and the value of next to
previous, essentially. Uh, so
that means that you know you’re

00:37:17.836-->00:37:19.938
going to be writing 0xbabe to
0xdead and 0xdead to 0xbabe. Um,
so that means that we can

00:37:19.938-->00:37:24.943
actually use this to write an
arbitrary address to an
arbitrary location as long as

00:37:31.783-->00:37:38.389
both addresses, you know, point
to actual valid writable memory.
So we end up with this primitive

00:37:38.389-->00:37:42.160
which is obviously super
powerful because we can use this
to say, overwrite a uh a

00:37:42.160-->00:37:45.964
function pointer, and it’s
essentially what we end up
doing, because if you look at

00:37:45.964-->00:37:51.536
the code that actually invokes
the linked list unlinking, right
before freeing the kernel object

00:37:51.536-->00:37:54.906
and well right after freeing the
kernel object, it’s actually
going to make an indirect call

00:37:54.906-->00:38:00.411
for a vtable. So, if you can
overwrite the pointer, that is
pointed at by that vtable, uh

00:38:00.411-->00:38:07.385
then you um, you have the
ability to just uh you know,
jump to any location code that

00:38:07.385-->00:38:13.158
you want. The only kind of
annoying thing is that it turns
out that the free kobj uh

00:38:13.158-->00:38:19.531
function uh is going to panic if
it tries to free uh a null
object which is kind of weird

00:38:19.531-->00:38:24.469
because the allocation function
does not seem to really care
about returning a-a-a null

00:38:24.469-->00:38:29.340
object. But you know, whatever.
You end up being able to just
exploit this by doing by being

00:38:29.340-->00:38:35.079
like you know vaguely tricky,
and by vaguely tricky I really
just mean uh uh you know you

00:38:35.079-->00:38:39.984
overwrite this uh vtable
pointer, the thing is you have
to overwrite the vtable pointer

00:38:39.984-->00:38:44.889
with uh the address of the node
that’s going to be overridden,
and because of that you have to

00:38:44.889-->00:38:49.360
actually make the null page be
read, writable and executable,
but basically uh what’s going to

00:38:49.360-->00:38:54.532
happen is you just kind of put a
piece of code in there, uh in
the second node there that is

00:38:54.532-->00:39:00.939
going to uh just jump to some
other location in user mode and
uh and basically just get closer

00:39:00.939-->00:39:07.345
to that one. It’s not that
complicated. At this point, we
have access to everything in the

00:39:07.345-->00:39:12.183
ARM11, we have compromised the
ARM11 kernel which means that by
extension we have actually

00:39:12.183-->00:39:16.087
compromised literally every
other process that is running on
the ARM11 and at this point, we

00:39:16.087-->00:39:20.325
can kind of just do whatever we
want, we can run whatever games
we want, we can uh you know

00:39:20.325-->00:39:25.463
access all the hardware that is
accessible by the ARM11, that’s
pretty great. But, it’s not

00:39:25.463-->00:39:29.868
enough for whatever reason
[laughter] we do still want to
uh we do still want to actually

00:39:29.868-->00:39:36.341
take over the ARM9. um, because
you know, uh I guess that’s
cooler, it actually doesn’t

00:39:36.341-->00:39:40.545
really give you access to much
more, it does like allow you to
write directly to the end uh

00:39:40.545-->00:39:45.083
chip which is nice, and
definitely useful for other
exploits, but yeah, so we want

00:39:45.083-->00:39:48.453
to be able to do that, and again
we don’t actually have the
ability to write directly to

00:39:48.453-->00:39:52.724
ARM9 memory, but we do have the
ability to talk to the ARM9
through other ways. The ARM9 is

00:39:52.724-->00:39:57.795
responsible for uh certain
services such as accessing uh
permanent storage as mentioned,

00:39:57.795-->00:40:00.765
but it also does other things,
and one of the things is
actually backwards

00:40:00.765-->00:40:07.739
compatibility. Um, so the 3DS is
actually able to run old DS
games, and the way that that’s

00:40:07.739-->00:40:12.610
done is by basically turning the
3DS into a DS in terms of
hardware, like it books a bunch

00:40:12.610-->00:40:18.016
of weird hard registers, and
that actually brings up a third
CPU that is like kind of hidden

00:40:18.016-->00:40:22.720
and turns the ARM9 into like a
DS mode CPU and it’s kind of
crazy uh and so the thing is it

00:40:22.720-->00:40:27.225
has to be able to do that uh, in
order to do that it actually has
to kill the current operating

00:40:27.225-->00:40:30.995
system and start another
operating that’s going to do a
bring up for all this c**p. And

00:40:30.995-->00:40:35.733
so the operating system that
we’ve been working on so far, is
this uh NATIVE_FIRM thing, firm

00:40:35.733-->00:40:40.271
being from firmware presumably,
but you have other uh firmware
that can run on 3DS, you have

00:40:40.271-->00:40:44.108
SAFE_FIRM which is what runs
when you have an update for your
console, and you have TWL_FIRM

00:40:44.108-->00:40:48.646
which is the one we’re going to
be interested in, TWL is just
like uh the code name for a DSi,

00:40:48.646-->00:40:52.250
so that’s that’s where that name
comes from. And so, in terms of
actually launching another

00:40:52.250-->00:40:58.122
operating system what the 3DS
does is it basically just has
the ARM9 do everything. The ARM9

00:40:58.122-->00:41:03.528
is going to load the memory like
uh load the firmware image from
permanent storage to it to load

00:41:03.528-->00:41:08.866
into memory that we cannot alter
from the ARM11 which is ARM9
internal memory. It’s going to

00:41:08.866-->00:41:12.203
use you know it’s crypto
hardware to actually decrypt it
and authenticate it make sure

00:41:12.203-->00:41:17.342
it’s like actually the Nintendo
special sauce and not something
that we’ve ha-altered somehow.

00:41:17.342-->00:41:21.579
And then, it’s going to copy
each individual section into
where they’re supposed to go

00:41:21.579-->00:41:25.016
because you know you have code
that needs to run in the ARM9,
that’s pretty easy it’s already

00:41:25.016-->00:41:27.819
in the ARM9 memory, but you also
have code that needs to run in
the ARM11 and that has to be

00:41:27.819-->00:41:29.821
copied to the FCRAM, the VRAM
and whatever. Now the thing is,
once it’s done that, the ARM9 is

00:41:29.821-->00:41:31.823
not just going to start
executing some code, it is going
to tell the ARM11, hey um please

00:41:31.823-->00:41:33.825
start running the code on your
end too because I need, I need
to like do that as well. Um, the

00:41:33.825-->00:41:35.827
thing is we’ve compromised the
ARM11, so if we can basically
tell the ARM9 to f**k off, and

00:41:35.827-->00:41:37.829
we can just like keep running
whatever code we’re already
running and do whatever we want.

00:41:37.829-->00:41:39.831
Uh and so then it becomes
interesting because if you took
a look, if you take a look at

00:41:39.831-->00:41:44.836
how TWL uh FIRM uh works
basically it first has to load a
ROM uh like a DS game image from

00:42:00.585-->00:42:05.590
somewhere, and then turn into a-
a pseudo, a pseudo DS mode uh
sort of thing, and it can

00:42:11.329-->00:42:15.700
actually load it’s ROM from 3
locations. It can either load it
from an actual physical game

00:42:15.700-->00:42:20.004
card, or from the NAND car- uh
from the NAND permanent
storage,or for some reason it

00:42:20.004-->00:42:25.476
can load it from FCRAM. Which of
course we have, col- uh complete
control over uh from the ARM11.

00:42:25.476-->00:42:30.915
And that becomes interesting
because, uh well you know it’s a
ROM loader, it’s file format

00:42:30.915-->00:42:36.421
parser while there might be bugs
in there and it turns out there
are, uh and so from the ARM11,

00:42:36.421-->00:42:40.224
we can actually mess with that
ROM and kind of inject
something. The only thing is of

00:42:40.224-->00:42:46.731
course DS ROM’s are signed, so
Nintendo actually checks d- if a
DS ROM is valid before using it

00:42:46.731-->00:42:51.602
and so that should kind of kill
the idea except that for some
reason it does not check the

00:42:51.602-->00:42:56.974
signature, it the, the ROM is
coming from FCRAM, which is
completely baffling because that

00:42:56.974-->00:43:01.279
is like the one location where
we have control over. Um, I
honestly don’t know why I did

00:43:01.279-->00:43:06.083
not really care to reverse
engineer into like why that
happens but it does, and so we

00:43:06.083-->00:43:11.022
are actually able to move
forward with this idea and so
the DS ROM is going to basically

00:43:11.022-->00:43:15.092
contain two memory images that
have to be copied because these
are the code images that are

00:43:15.092-->00:43:21.399
going to be run by the ARM9 and
the ARM7 which are our 2 CPUs of
a DS. And um, essentially yeah

00:43:21.399-->00:43:26.404
the the the TWL firm loader has
to basically copy these two ARM9
and ARM7 sections into whatever

00:43:28.506-->00:43:35.313
memory is going to correspond to
uh the DS mode RAM uh, address.
So you have like this kind of

00:43:35.313-->00:43:41.085
formula, to convert a 3DS
physical address, Nintendo DS
mode physical address into DS,

00:43:41.085-->00:43:46.090
uh 3DS physical address. So, the
two things to notice is first
off, it’s like a kind of weird

00:43:46.090-->00:43:49.760
hardware compatibility mode and
so you only have like 2 bytes
that are used every 8 bytes

00:43:49.760-->00:43:53.731
which is why you have to
multiply by 4 for some reason,
and then the other thing is you

00:43:53.731-->00:43:59.704
can see with this formula that
you can actually create any 3DS
physical address uh as long as

00:43:59.704-->00:44:04.141
you have the right Nintendo DS
physical address. Like, you can
cover the entire memory space,

00:44:04.141-->00:44:09.480
though it’s not meant to be the
case. So, because we have
control over the address in

00:44:09.480-->00:44:15.052
Nintendo DS mode, the ARM9 and
ARM7 sections uh are going to be
loaded at, we can actually turn

00:44:15.052-->00:44:20.558
those into any 3DS physical
address that you want. For
example, memory that is used by

00:44:20.558-->00:44:24.629
the ARM9 to execute code. So
like for example, you could
maybe override the actual ARM9

00:44:24.629-->00:44:30.134
3DS mode code and take it over.
That is as long as there are uh
checks are not good enough,

00:44:30.134-->00:44:35.172
turns out there checks are not
good enough, uh because they did
not do uh an integer overflow

00:44:35.172-->00:44:40.745
check, which again, kind of sad,
uh and there’s also no bounce
checks on the section sizes so

00:44:40.745-->00:44:46.083
that means that we can have
these kind of crazy values of an
address uh like let’s say we

00:44:46.083-->00:44:51.822
want to override this address
over there because like that is
the ARM9 uh like uh thread stack

00:44:51.822-->00:44:56.827
address. Well, we can just like
create this fake Nintendo DS
mode address, and then give it

00:44:56.827-->00:45:01.065
its crazy size this is like
about 1 gigabyte of memory so
this would never be valid for a

00:45:01.065-->00:45:05.269
Nintendo DS ROM, and then if you
check on the math, it’s actually
going to give you the address

00:45:05.269-->00:45:09.106
that you want, it’s also going
to go through all of these
checks that we just mentioned to

00:45:09.106-->00:45:13.144
you. And so at this point
basically we end up with the
ability to write about a

00:45:13.144-->00:45:18.749
gigabyte of memory to an
arbitrary location in 3DS uh
physical space, and that

00:45:18.749-->00:45:22.587
shouldn’t be a problem because
we actually don’t have a
gigabyte of memory to overwrite,

00:45:22.587-->00:45:26.123
the thing is um, um you know I’m
going to kind of skip over it
because I’m running out of time,

00:45:26.123-->00:45:30.695
but the idea is that we can just
overwrite this uh physical
address here. Uh well the return

00:45:30.695-->00:45:34.899
address for this function
because the uh actual memory
that is being copied is being

00:45:34.899-->00:45:39.003
copied by tin, in tiny blocks
instead of like big blocks so
you actually end up being

00:45:39.003-->00:45:45.009
totally fine. Now, the only
thing is, for some reason it’s
copying 2 bytes at every 8 byte

00:45:45.009-->00:45:49.380
boundary so you can’t actually
it’s just like overwrite code,
because you can only overwrite 2

00:45:49.380-->00:45:55.186
bytes um you know at on every
byte slot, which is super
annoying. Uh what that means in

00:45:55.186-->00:45:59.123
practice is that if I want to
overwrite this this call stack
right I can actually only

00:45:59.123-->00:46:05.129
overwrite the bytes that are
highlighted in orange and so in
terms of making a uh ROP chain,

00:46:05.129-->00:46:11.002
that’s you know, not ideal, but
we can make it work because the
ARM9 doesn’t really have uh

00:46:11.002-->00:46:17.208
depth or anything, so, we can
actually just use this to place
an actual address uh, the

00:46:17.208-->00:46:21.779
address of like actual code that
we control because that code can
be in writable memory. In this

00:46:21.779-->00:46:27.184
case we place that code into the
uh Nintendo DS mode uh ROM
header and then we just

00:46:27.184-->00:46:31.889
overwrite one return address at
the top there, and make it jump
to this gadget that’s just going

00:46:31.889-->00:46:38.162
to skip a bunch of uh of the
call stack and then is going to
return into this address and we

00:46:38.162-->00:46:43.801
will get code execution on the
ARM9. and uh, yeah at this point
we have full control of the

00:46:43.801-->00:46:49.707
entire machine, uh you know we
can do this uh we started with
nothing, went over network sent

00:46:49.707-->00:46:54.345
a like one magic packet, has it
and then it just kind of you
know uh gives you full access to

00:46:54.345-->00:46:58.215
everything and then at that
point you can read and write
NAND, you can uh mess with the

00:46:58.215-->00:47:02.186
crypto engine and kind of do
whatever the f**k you want. So
thank you for your time, uh, the

00:47:02.186-->00:47:07.191
code for the exploits on this is
available on github [applause].
Uh, want to give special thanks

00:47:11.062-->00:47:16.067
to a few people, derrek,
nedwill, yellows8, plutoo,
naehrwert. Uh, and if you want

00:47:18.369-->00:47:23.441
to follow me on twitter uh my
handle @smealum, I’m not
tweeting very interesting things

00:47:23.441-->00:47:28.012
you know, so please don’t and uh
yeah, have a good DefCon.

