00:00:00.033-->00:00:05.038
>> Please join me in welcoming
Amanda Rousseau and Rich
Seymour. [Audience applause].

00:00:11.211-->00:00:16.783
>>Hello, everyone. I’m here to
talk to you about Finding Xori,
it’s a malware analysis triage

00:00:16.783-->00:00:22.656
with automated disassembly. Um,
a little bit about ourselves. My
name is Amanda Rousseau, also

00:00:22.656-->00:00:26.793
known as @malwareunicorn on
Twitter. Um, I’m currently a
malware researcher at Endgame.

00:00:26.793-->00:00:32.499
My day to day activities is
looking at malware every day,
writing detections for them, um,

00:00:32.499-->00:00:38.739
teaching my intern something and
then - that’s Rich. >>Hey there,
what’s up, my name is Rich

00:00:38.739-->00:00:45.012
Seymour, um, also known by my
hacker handle @RSeymour on
Twitter, um a data scientist at

00:00:45.012-->00:00:51.618
Endgame and um, I got chance to
work with Amanda on this project
and I’m really psyched about it.

00:00:51.618-->00:00:56.990
Um, it started in January and
we’re about six months later,
it’s about 36 000 lines of code

00:00:56.990-->00:01:01.261
and and we’re going to tell you
about it, alright? Thanks. >>
So, a little bit before we

00:01:01.261-->00:01:08.135
begin. I kinda wanna go over,
um, the quick overview of
current disassemblers of today,

00:01:08.135-->00:01:12.806
Um talk about what they do for
PE right now. Um, the
functionality and features and I

00:01:12.806-->00:01:18.378
wanted to go over a usage and
demo. First I actually want to
show you the tool before we get

00:01:18.378-->00:01:22.849
into it, so you know what the
h*ll I’m talking about. Awesome.
So that loaded up pretty quick.

00:01:22.849-->00:01:28.388
So if you don’t know what a
disassembler is already it’s
kind of taking the binary code

00:01:28.388-->00:01:33.660
and turning it into assembly for
you so you can analyze this
malware if you’re looking at

00:01:33.660-->00:01:37.965
malware. So, I’m just going to
go ahead and drop this this
Wanacry sample in here really

00:01:37.965-->00:01:44.004
quickly, and it’ll disassemble
it really quickly and put it to
the screen, which is browser

00:01:44.004-->00:01:52.546
based so it’s cross platform for
you to run on any uh linux, OSX
or Windows distribution and you

00:01:52.546-->00:01:59.353
can play around with it. You can
see here is the short circuit
thing that malware tech

00:01:59.353-->00:02:06.226
registered. As well as linear
disassembly - make this a little
bit bigger for you - so it’s all

00:02:06.226-->00:02:14.301
there for you to play with in
UI. No crazy buttons, it’ really
easy to mess with, um it had a

00:02:14.301-->00:02:18.038
click and drag. We made this in
two weeks for you. We know we
use it for automated

00:02:18.038-->00:02:23.176
disassembly, but we wanted you
to have a tool that you could
play with in the browser in any

00:02:23.176-->00:02:28.815
platform to get used to looking
at disassembly. So, I’m going to
switch back to my slides and

00:02:28.815-->00:02:34.488
continue the presentation here.
So now that you’ve seen what the
h*ll it is, now we can talk

00:02:34.488-->00:02:39.126
about what it does and how it
compares to other disassemblers.
So what is the problem? My boss

00:02:39.126-->00:02:45.732
told me to look at 1000 samples
in 3 days - and I’m like,
there’s no way I can look at a

00:02:45.732-->00:02:53.907
1000 samples quick enough and
triage it and sit there and copy
one sample into a VM, open it up

00:02:53.907-->00:02:59.780
in IDA and analyze it. So what
did we do? We had to think of a
better way to scale our

00:02:59.780-->00:03:10.891
automation. >>So [clears throat]
we wanted to basically be able
to take our pipeline right now

00:03:10.891-->00:03:15.962
which handles training R models
and also add to it disassembly
which is something we’ve wanted

00:03:15.962-->00:03:23.470
to do at Endgame since before I
was at Endgame, so, ah, it
allows us now to basically take

00:03:23.470-->00:03:30.477
our sample set, turn it into
disassembly features we can read
because it throws out, right

00:03:30.477-->00:03:34.247
now, uh Json but you can
basically serialize it to any
format you can integrate into

00:03:34.247-->00:03:40.320
your pipeline. >>So when we
thought about doing automation
we wanted to try some

00:03:40.320-->00:03:46.726
disassemblers that were already
out there. Open source if it’s
library and try to compare them

00:03:46.726-->00:03:53.033
across um what we needed. So we
were thing about how much - how
big the size of the code was,

00:03:53.033-->00:03:59.906
how big’s the memory, if it was
stable, how much the price was,
was it cross platform, was it

00:03:59.906-->00:04:06.513
easy to use, um as output
accurate and can we integrate it
into our services already. So I

00:04:06.513-->00:04:12.819
kinda have this little chart
that it, you know we have good,
okay and not so good. I’m

00:04:12.819-->00:04:17.958
comparing Capstone, Radare2, IDA
Pro, Hopper and Binary Ninja.
Which are pretty much the

00:04:17.958-->00:04:25.966
common, you know, disassembly uh
libraries out there. So
requirements. Um, we needed fast

00:04:25.966-->00:04:31.538
development, um we needed
stability and resilience because
uh if we’re running through a

00:04:31.538-->00:04:36.209
bunch of services we’ll need it
to spin up again. Um, it had to
be cross platform because we’re

00:04:36.209-->00:04:39.846
not just using it in Windows
we’re using it in OSX and
everywhere else and running it

00:04:39.846-->00:04:45.585
on a server, um output can be
easily integrated to our
services which, you know, Json

00:04:45.585-->00:04:50.991
is very useful for that. Um, it
had to be really easy to use. Um
it had to have a core feature

00:04:50.991-->00:04:59.266
set and output had to be
accurate. Alright, so the first
step we did was diving into the

00:04:59.266-->00:05:04.070
code of these disassemblers and
trying to pick and choose what
the pros and cons of each and

00:05:04.070-->00:05:10.844
kinda build it into something we
needed in our,in our own, um
internal framework. So we

00:05:10.844-->00:05:16.349
adopted a different, different
aspects of what Capstone does -
since it’s based on the LLVM and

00:05:16.349-->00:05:22.122
GDB repositories also a lil’ bit
of emulation that you know, QEMU
does as well as understand how

00:05:22.122-->00:05:31.464
to put that logic using Rust and
then fix some bugs along the
way. So evaluating example. Say

00:05:31.464-->00:05:38.939
you have a x86 32 bit
instruction here. So typically
the 66 represents the op size of

00:05:38.939-->00:05:44.044
the instruction which tells you,
er, is the oper ad bigger or
larger than it should be and

00:05:44.044-->00:05:49.616
then you have the up code which
tell you which instruction it
exactly is. So how many of you

00:05:49.616-->00:05:58.191
are familiar with that code 90?
Yeah, so it’s NOP, right? NOP
NOP NOP. Um, so, ah, really this

00:05:58.191-->00:06:06.366
is actually exchange AX AX in um
Objdump in LLVM because of that
op sizes there. So IDA does it

00:06:06.366-->00:06:12.405
correctly, Capstone doesn’t do
it correctly and Distorm doesn’t
do it go- correctly. So some of

00:06:12.405-->00:06:16.977
these like minor changes between
different disassemblers is going
to give you different output

00:06:16.977-->00:06:24.584
when you disassemble the
instruction, um, uh, t- exchange
AX is actually a NOP but it

00:06:24.584-->00:06:33.560
technically is not based off of
the CPU. Alright? >>So, uh,
here’s what I ask, um, who here

00:06:33.560-->00:06:45.272
knows what Rust is? OK. [laughs]
and uh, who here has programmed
in Rust? uh Okay that looks

00:06:45.272-->00:06:50.477
like, hmmmm, 12 people maybe?
[Audience laughs] um, that’s not
great. I’m glad everyone’s going

00:06:50.477-->00:06:55.548
to be able to contribute to this
project [laughs]. Uh, I-I think
the thing we want to emphasize

00:06:55.548-->00:07:02.122
besides the bullet point on
screen is that I didn’t know
Rust really, and I’d been

00:07:02.122-->00:07:06.760
tracking it’s existence, but
that’s like a big difference
from like diving into writing a

00:07:06.760-->00:07:10.997
disassembler in a few months.
Um, so, Rust gives you all these
nice things. Like it protects

00:07:10.997-->00:07:19.839
you from stomping on the OS from
y-your stack. It, uh handles
memory, uh much more cleanly

00:07:19.839-->00:07:26.079
than any programming language
I’ve used. Uh, it’s really fast,
and the oddest thing about it

00:07:26.079-->00:07:31.584
is, it was actually really fast
for us to develop in because all
of the really dumb bugs that bog

00:07:31.584-->00:07:35.855
you down for a week, then it’s
another week, then it’s the next
month - and you’re like why

00:07:35.855-->00:07:40.994
can’t I get this to work?
-basically get caught, either by
the compiler not letting you do

00:07:40.994-->00:07:44.764
it, or uh, or well yeah by the
compiler basically. [Laughs] So,
it’s really helpful and I

00:07:44.764-->00:07:52.605
suggest you learn it. >>Alright,
so current features. Yes, it’s
open source. I was really, like,

00:07:52.605-->00:07:58.111
h*ll bent on making it open
source -you can contribute now.
We already have like, uh, how

00:07:58.111-->00:08:03.316
many contributions last night?
>>We’ve got a hundred and eighty
some stars, we’ve got 2

00:08:03.316-->00:08:08.488
contributions, a lot of issues a
lot of requests coming in >>And
it’s only been live for 2 days.

00:08:08.488-->00:08:13.493
So it’s really bu- bumpin’ and
grindin’ yeah okay [chuckles].
Currently it supports x86 and 64

00:08:13.493-->00:08:19.766
bit architecture. I only had
time for that since my job
requires PE executables. Um, it

00:08:19.766-->00:08:25.505
display, displays strings from
reference memory, um if you’re
familiar with the flair on

00:08:25.505-->00:08:30.810
plugins, um where if you pushing
strings to the stack it emulates
it and produces the string for

00:08:30.810-->00:08:38.184
you that’s already built in. Um,
it manages memory, it outputs
Json for your, um service

00:08:38.184-->00:08:42.389
consumption. It has two modes.
Uh, light emulations which means
it does handle stack and some

00:08:42.389-->00:08:47.994
instructions as well as full
emulation which I don’t
recommend because it’s really

00:08:47.994-->00:08:52.565
slow right now but you can do it
if you want to get through a
packer or some type of uh

00:08:52.565-->00:08:57.904
encryption routine, Um, I also
was able to simulate the thread
environment block as well as the

00:08:57.904-->00:09:03.176
PEB or the process environment
block. Um so that you can do
dynamic API call loading, as

00:09:03.176-->00:09:09.282
well as evaluate functions from
DLL exports - so you can
populate those in the code

00:09:09.282-->00:09:15.021
itself. Alright. So the design.
So we have a PE loader similar
to what uh Windows does for

00:09:15.021-->00:09:21.628
loading a PE. It’s very basic.
It loads the TEB, PEB as well as
DLL’s from the image - the PE

00:09:21.628-->00:09:27.634
image, um, header. Um, a also a
memory manager that manages all
those memory spaces so that in

00:09:27.634-->00:09:32.639
case the malware is trying to
access an address outside of
those memory spaces, it you

00:09:32.639-->00:09:37.143
won’t allow you to. As well as
um, the analysis truck that
contains all the functions, the

00:09:37.143-->00:09:42.582
disassembly and all of the
imports. And then finally when
you’re analyzing through all of

00:09:42.582-->00:09:47.787
the different sections of code,
it has state that tracks the CPU
registers and all the flags a

00:09:47.787-->00:09:53.927
new version of the stack as well
as tracking loops. Which I will
get into later. Alright. >>So if

00:09:53.927-->00:10:01.501
you’re wondering how a chump
like me contributed to this
project, I decided to play not

00:10:01.501-->00:10:07.640
invented here syndrome on a PE
parser, um I used this great
library called Nom, which uh I

00:10:07.640-->00:10:13.980
think originated in France. Um,
it’s a parser combinator
framework and allowed us to

00:10:13.980-->00:10:20.186
parse the header uh PE headers
rather safely. Um, if you’ve
ever messed - who here’s ever

00:10:20.186-->00:10:29.896
looked at a PE Header? You know,
MZ is a real person, um, and the
thing about headers, like if

00:10:29.896-->00:10:34.767
you’ve looked at Korakami’s
excellent work, um, like
describing what this stuff is to

00:10:34.767-->00:10:39.739
people, um there’s a lot that’s
useful to the machine to run
-like getting the imports

00:10:39.739-->00:10:43.910
correct and the TEB and the PEB
and the entry point and that.
There’s also just a lot of stuff

00:10:43.910-->00:10:48.515
that’s also kinda like retro
garbage from the eigh- DOS days,
16 bit Windows days, 32 bit

00:10:48.515-->00:10:54.888
Windows days, and the 64 bit
Windows days. So, the cool thing
about this parser is that it

00:10:54.888-->00:10:58.458
takes everything so that we can
data science the heck out of it
later. If we wanna figure out

00:10:58.458-->00:11:02.829
that corrupted DOS stub means
that it’s some threat actor
we’ve never heard of, then we

00:11:02.829-->00:11:09.969
can do that now. So, I’m pretty
excited about it, and uh yeah-
that’s my little thing. [Laughs]

00:11:09.969-->00:11:15.241
>>So the information we take
from the PE header is used to
build the im- the PE image in

00:11:15.241-->00:11:19.178
memory. So that means building
all these sections, making sure
they read, write executable and

00:11:19.178-->00:11:25.385
tracking that as well. Um
building the stack. Building the
DLL’s into memory and in the

00:11:25.385-->00:11:29.622
right locations. You can
actually configure that, if you
have a a a little Json config

00:11:29.622-->00:11:35.061
file that you can set whatever
address offset you want for the
DLL’s or the peh TEB or PEB, um

00:11:35.061-->00:11:43.670
as well as building the TEB and
PEB memory. So, um, what I meant
by loading the uh DLL exports,

00:11:43.670-->00:11:49.309
we have this giant Json of all
the DLL’s exported from like
Windows 7 and it pulls um, all

00:11:49.309-->00:11:54.414
of the uh API calls out of
there, so you don’t have to keep
using the DLL, you can keep

00:11:54.414-->00:12:00.320
using this giant Json and it’ll
load it up and rebuild all of
the addresses as it would in the

00:12:00.320-->00:12:06.025
PE image and fill of those
addresses for you. So if it’s
doing any dynamic API calling

00:12:06.025-->00:12:11.064
and it moves an address in a
register or an address into uh
new memory location that address

00:12:11.064-->00:12:18.438
will actually be there
simulated. Alright. So uh like I
said, dealing with dynamic API

00:12:18.438-->00:12:24.110
calls - you need the TEB and
PEB, um so we kinda recreated in
the, for the Windows 7

00:12:24.110-->00:12:30.750
environment. Um it handles, um
memory so anytime it accesses
one of those, you can choose to

00:12:30.750-->00:12:35.188
allow it or not allow it. As
well as managing all of the
addresses on the stack which is

00:12:35.188-->00:12:42.128
nice and let me explain what I
mean by this. So we have this
show code doing, um some

00:12:42.128-->00:12:49.202
interesting stuff, um in the
header imports, the only API
calls it’s actually using is

00:12:49.202-->00:12:52.705
ExitProcess, GetLastError,
GetLocalTime and
GeTModuleHandleA. Which we don’t

00:12:52.705-->00:12:59.012
actually see uh LoadLibraryA,
VirtualProtect, ShellExecuteA.
Right. So here, you can see it’s

00:12:59.012-->00:13:05.118
taking this string called
LoadLibraryA, and pushing it
onto the stack, um from there it

00:13:05.118-->00:13:10.790
this function right below here,
it’s going to call this function
and get that address off of the

00:13:10.790-->00:13:16.629
PEB. So what that means, its
traverses all of the DLL’s as
well as the names from the PE

00:13:16.629-->00:13:21.000
headers in order to collect that
address offset. Once it’s done,
it’s going to put that address

00:13:21.000-->00:13:30.043
into EAX and move into 401 1004.
That pointer. And then down
here, it’s actually going to

00:13:30.043-->00:13:39.018
call that newly um moved address
to LoadShell30 - Shell32 DLL so
it can also load ShellExecuteA

00:13:39.018-->00:13:45.925
afterwards. So in reality, the
dynamic imports are
LoadLibraryA, uh VirtualProtect

00:13:45.925-->00:13:50.196
and ShellExecuteA. So this is
actually the output from Xori
and you’ll be able to see all

00:13:50.196-->00:13:58.705
that happen in there with the
Light Emulation. Alright, so.
The TEB and PEB. I didn’t do

00:13:58.705-->00:14:03.776
anything really crazy. There’s
so many uh resources out there
to look at. The whole struct for

00:14:03.776-->00:14:09.215
the TEB and PEB, um some
versions of Windows are gonna be
different, but I just used, you

00:14:09.215-->00:14:13.186
know, whatever was available out
there. You don’t need the whole
like hidden features of the

00:14:13.186-->00:14:19.726
struct at all, I used just the
top of it- for example: So I
recreate - the nice thing about

00:14:19.726-->00:14:24.097
Rust is you can take a struct
and serialize that instruction
to a binary array. Or a binary

00:14:24.097-->00:14:29.335
vector. And you can have that
vector being accessed by the
memory manager as if they

00:14:29.335-->00:14:34.774
assembly instructions were to
access those addresses as if
they actually on the um OS.

00:14:34.774-->00:14:40.580
Which is really nice. So I had
to figure out how do to a link
list in bytes, serialized bytes.

00:14:40.580-->00:14:47.653
And put that all together into a
structure so that the shell code
could use it. Alright. And so,

00:14:47.653-->00:14:53.392
uh another thing to help with
the analysis is that we have
this thing called uh an analysis

00:14:53.392-->00:14:59.098
queue where it will take the if,
a branch instruction, if else
and there’s a call, uh you’ll

00:14:59.098-->00:15:05.171
have two different directions in
order to take for the call. So
the right hand side of the

00:15:05.171-->00:15:10.209
branch will go to the top of the
queue, while the others part of
the branch will go to the bottom

00:15:10.209-->00:15:15.748
of the queue which will help the
code analysis follow the actual
control flow for you. So it

00:15:15.748-->00:15:22.221
follows both directions. Um, and
I’ll also introduce Looping for
the emulation. So say you run

00:15:22.221-->00:15:29.262
into an infinite loop, um and
you know it’s an infinite loop
but you want to short circuit

00:15:29.262-->00:15:31.898
that loop case. There is a
configuration there for you to
short circuit all of the looping

00:15:31.898-->00:15:36.569
in there. Say you only want to
do 4000 times, you can set that
information. I don’t recommend

00:15:36.569-->00:15:41.140
using the emulation mode, but if
you want to you can play with
it. I really need to improve it

00:15:41.140-->00:15:48.548
a little bit. Let me read a
couple of research papers. Um,
and then >>So, er, signature

00:15:48.548-->00:15:54.420
analysis is uh a way of adding
annotations to your code so that
you don’t have to be able to

00:15:54.420-->00:15:58.858
read eax like Amanda, that you
can just get like a nice
signature to tell you what the

00:15:58.858-->00:16:04.931
function was. Um, I spent the
last week and a half of my life
trying to er, reverse a sig

00:16:04.931-->00:16:12.438
parser from, from IDA format so
we could use it, uh er, I failed
catastrophically, um in those

00:16:12.438-->00:16:17.543
formats are always changing.
It’s hard to keep up with it.
Er, that’s said we do have

00:16:17.543-->00:16:21.881
signature matching in Xori
rightnow, uh but we’re always
looking for help to make it

00:16:21.881-->00:16:27.587
better. And luckily some folks
are already stepping up. So.
>>Yeah Oh. >>Me too. Oh my

00:16:27.587-->00:16:33.359
goodness. We’re, we’re prepared,
um, so this is the cool part for
me as a data scientist not a

00:16:33.359-->00:16:38.064
reverser. Um. We took a 100
Ember samples, which is a data
set we, our company, released um

00:16:38.064-->00:16:44.170
of hashes, we took um the actual
binaries, ran them on this old
Dell box that was under my desk.

00:16:44.170-->00:16:49.942
The only new, new thing about it
was SSD and um it could get
through all these samples in uh

00:16:49.942-->00:16:57.950
in 20 minutes. So that was a
1000 samples, 20 minutes. About
1.25 seconds per sample running

00:16:57.950-->00:17:03.089
in parallel, you know, maxing
out all the CPUs and it just
dumps a huge amount of data- and

00:17:03.089-->00:17:08.561
sometimes too much data if the
binary is really big. Um, then
you can do whatever you want.

00:17:08.561-->00:17:14.033
You can break through it, find
function names, find imports,
you can do graph analysis. uh

00:17:14.033-->00:17:18.137
over in AI villages much people
think they can do a lot of cool
things, so. I’m really psyched

00:17:18.137-->00:17:25.711
about this. >>Alright. Examples.
So, it’s really easy to build
Xori. All you need to do is make

00:17:25.711-->00:17:32.785
sure you install Rust, cargo
build release, uh target release
xori dash f dot wannacry exe, um

00:17:32.785-->00:17:38.190
and it’ll produce some results.
So if you just want - you don’t
want to use analysis part of

00:17:38.190-->00:17:45.331
Xori you can just pop in the
disassembler part of it and
throw it like this nice chunk of

00:17:45.331-->00:17:49.168
bytes and it’ll disassemble this
um this hello world program, but
isn’t showing really any

00:17:49.168-->00:17:54.073
strings, it’s just giving you
the disassembly output. So if
you want to use the analysis

00:17:54.073-->00:17:58.344
part, it will actually uh
populate all the strings when
it’s like popped off the stack

00:17:58.344-->00:18:05.184
and show you when a function
ends and annotates all of those
nice lovely comments for you. Um

00:18:05.184-->00:18:12.158
when comparing uh Xori with IDA
Pro what we have the wannacry
ransomware file. You can see, we

00:18:12.158-->00:18:17.129
don’t have all of the nice uh
argument and numerations yet but
you know, 6 months - this is

00:18:17.129-->00:18:20.933
what we could do. We also see
the stri - the short circuit
string. Like I showed you in the

00:18:20.933-->00:18:27.073
beginning this is just their
normal output from the terminal
but we added the UI for you to

00:18:27.073-->00:18:31.310
play with. You don’t really have
to use this part of it, but for
development if you maybe want to

00:18:31.310-->00:18:37.149
use it from the terminal you
can. Um, here’s Radare2.
Comparing the two different uh

00:18:37.149-->00:18:45.491
um functions here, it’s kinda
weird because Radar does this
thing where if it identifies an

00:18:45.491-->00:18:49.562
API call with like the first
couple instructions of a
function- it’s what it names the

00:18:49.562-->00:18:54.900
function in this case - we don’t
try to do that - it’s just a
regular function call. It’s got

00:18:54.900-->00:18:59.772
parody between the two. Um and
then I sh-showed you the demo
earlier, uh but that I can show

00:18:59.772-->00:19:10.082
it to you again- with a
different sample. I’ll just do a
normal bin file. So it does PE

00:19:10.082-->00:19:16.655
and binary . So this is the same
hello world program, it’s really
fast. I just want to see the

00:19:16.655-->00:19:21.727
linear disassembly against it
populates hello world and you
can see the function in the

00:19:21.727-->00:19:26.332
graph view as well. Or if you
want to do something more fun,
with a bunch of jumps - oh

00:19:26.332-->00:19:36.375
actually wrong one - you can see
how fast it is [chuckle] This
one was er, lumber tick, it’s

00:19:36.375-->00:19:43.015
actually part of my uh RE102
course. The long- longest
loading time is actually the the

00:19:43.015-->00:19:54.260
libraries there. But you can see
this was a fun function. And it
populates everything there for

00:19:54.260-->00:19:58.998
you. I don’t have any string
analysis since this was built
for automation, but hopefully

00:19:58.998-->00:20:05.337
soon we’ll have all that in
there for you. So, I made it
look really cool. Spent the

00:20:05.337-->00:20:11.210
whole weekend on that, so. I
hope you guys like it.
[Applause] thank you.

00:20:11.210-->00:20:22.822
[Applause]. Um if you want to go
download the co-code. It’s
already on GitHub dot com and

00:20:22.822-->00:20:27.693
gameink slash Xori um people are
already playing with it, it’s
there for you to play with.

00:20:27.693-->00:00:00.000
Thank you. [Applause]

