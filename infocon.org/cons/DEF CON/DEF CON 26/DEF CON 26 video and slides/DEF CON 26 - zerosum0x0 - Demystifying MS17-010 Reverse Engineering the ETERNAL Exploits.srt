00:00:00.400-->00:00:05.405
>>Up on stage we have a
returning goon, who uh, wants to
uh, demystify some uh, some

00:00:09.576-->00:00:13.947
vulnerabilities, and why they
are mystifying. I don’t know. I
don’t understand the words in

00:00:13.947-->00:00:19.453
front of me, but um, reverse
engineering the eternal
exploits, who’s excited about

00:00:19.453-->00:00:24.458
this? I see the room is getting
pretty packed. [applause] Life.
There is people alive in here.

00:00:26.560-->00:00:31.098
That’s wonderful. Alright, with
no further delay, I’m going to
hand it over to zerosum0x0.

00:00:31.098-->00:00:36.103
>>Thanks everyone for coming.
Uh, so, from a show of hands,
how many people, uh, popped the

00:00:40.173-->00:00:45.479
show with MS17-010 over the past
year and a half? How many people
are finding it everywhere,

00:00:45.479-->00:00:50.817
right? How many people uh,
helped with uh, wanna cry and
net pitch and the clean ups of

00:00:50.817-->00:00:56.957
those, right? Yeah, Yeah. It’s,
uh like I said, it’s been a year
and a half since they got

00:00:56.957-->00:01:01.595
introduced and we are still
finding them everywhere on our
red team. It’s a path to glory

00:01:01.595-->00:01:06.600
on our pen test. Um, before I do
get started, uh, this is uh, top
secret information, classified.

00:01:09.903-->00:01:15.309
I don’t, we don’t know exactly
what it is, but it uh, it is
allegedly from the NSA, uh,

00:01:15.309-->00:01:21.214
stolen from the NSA, uh, so if
you have a clearance, uh,
Francis uh, CKRS was at Derby

00:01:21.214-->00:01:25.852
dot com last year, he gave uh, a
talk on blandishments and he
gave a disclaimer, so I thought

00:01:25.852-->00:01:31.224
I would give one too. So,
everyone leaving the room right
now is a fed, and uh, you should

00:01:31.224-->00:01:36.229
keep track of their names and
you are all stuck for 45
minutes. Um, so, I did have to

00:01:38.432-->00:01:43.904
cut a lot from this presentation
that I wanted to go over, just
because of time. The goon

00:01:43.904-->00:01:49.543
probably will hook me offstage
in a little bit here, uh, but
hopefully we can get through it.

00:01:49.543-->00:01:56.550
Um, so if anyone is not aware,
uh, the equation group is the
tailored access operations, a

00:01:56.550-->00:02:01.488
former uh, department at the
NSA, uh, that wrote um, a bunch
of exploits um, and they’ve

00:02:04.224-->00:02:10.764
never really gotten a lot of
public credit, but hacker to
hacker and all the politics and

00:02:10.764-->00:02:16.269
everything aside and just
looking at the technicals, uh,
it is a very talented team and

00:02:16.269-->00:02:22.476
so they deserve a lot of credit.
Um, and then the shadow brokers,
uh, we don’t really know who

00:02:22.476-->00:02:26.713
they are. Uh, there are some
evidence that they might be
Russia. Um, they claim that they

00:02:26.713-->00:02:31.585
are an inside job if you read
their messages, uh, but they
came around, uh, and starting

00:02:31.585-->00:02:36.857
dumping, uh, these exploits
about a year and a half ago over
the course of, you know, a

00:02:36.857-->00:02:40.927
couple years that it’s been
going on. They have been pretty
quiet the last year or so,

00:02:40.927-->00:02:46.099
though. Um, so I am going to try
and get through SMB internals
real quick and then we can get

00:02:46.099-->00:02:51.104
into the external exploits,
which are all uh, SMBv1
vulnerabilities. Um, so, SMB was

00:02:54.708-->00:03:00.914
invented in 1983 by a guy named
Barry Feigenbaum, uh, at IBM. He
also worked on the NetBIOS,

00:03:00.914-->00:03:06.153
RFC’s and stuff like that. Uh,
we originally saw it, there was
a product for Microsoft called

00:03:06.153-->00:03:12.025
Lan Manager. It was later built
into Windows and pretty much all
modern versions of Windows have

00:03:12.025-->00:03:17.030
SMB uh, built in. And it is a
very extensible protocol so you
can build things on top of it

00:03:19.099-->00:03:24.304
and so uh, that is where we get
things like psexec uh, running
on top of the distributed

00:03:24.304-->00:03:29.309
computing environments remote
procedure call, uh, using SMB as
a transport. So, um, SMBv1 uh,

00:03:32.512-->00:03:38.351
looks, this is uh, kind of the
packet layout uh that you would
expect to see from a normal SMB,

00:03:38.351-->00:03:44.357
a well-formed SMB. Um, so
normally you will send a message
block request um, and then if

00:03:44.357-->00:03:49.362
the server processes that
request, it will send you an SMB
reply. Um, so both replies and

00:03:51.498-->00:03:56.837
responses look very similar.
They have a command, which is
like the opcode. Hundreds of

00:03:56.837-->00:04:02.909
commands in SMBv1. Um, there is
a flags field that tells you if
this is a request or a reply.

00:04:02.909-->00:04:07.214
Um, are we talking unicode, that
kind of thing. Um, if you are
getting a response from the

00:04:07.214-->00:04:11.251
server and it wasn’t able to
process that SMB, there was an
error, uh, it will set an error

00:04:11.251-->00:04:17.257
number for you. Uh, this is also
where SMB signing is uh,
located. And then there is the

00:04:17.257-->00:04:21.328
user id, tree id, process id,
and multiplex id, which we will
talk a little bit about more

00:04:21.328-->00:04:27.200
later. Um, an SMB also has a
parameter block, so depending on
what that opcode is, there is

00:04:27.200-->00:04:32.506
going to be a structure
associated um, with that opcode,
and that’s generally where the,

00:04:32.506-->00:04:37.077
uh, that structure is going to
end up in the parameter block.
So, it is a fixed size depending

00:04:37.077-->00:04:42.315
on the opcode usually. Um, then
data block is just arbitrary
data associated with the

00:04:42.315-->00:04:46.820
command. So, if you think about
it, uh, this way, uh, if you’re
like creating a file, your

00:04:46.820-->00:04:52.159
command is create file or
whatever, um, the parameter
block will be, uh, like the file

00:04:52.159-->00:04:57.030
name, uh, attributes, and then
the data block would be like the
file data. If you want to think

00:04:57.030-->00:05:01.968
about it that way, it’s kind of
an oversimplification, but it
works. So, SMBv1 has DLC, so the

00:05:04.671-->00:05:09.009
later version you have, the more
features you unlock. Um, pretty
much all of these features have

00:05:09.009-->00:05:15.248
been available since the latest,
since the earliest versions of
NT, so you don’t have to worry

00:05:15.248-->00:05:20.253
about it. Um, all these
exploits, they date back to
early 90’s before NT was really

00:05:23.456-->00:05:28.461
officially even released, and
late 80’s. Um, so the main
driver that all these

00:05:30.497-->00:05:35.502
vulnerabilities are going to be
in is the srv.sys driver, which
is the SMBv1 driver. Uh, those

00:05:37.804-->00:05:43.009
have done, those who have done
um, low level uh, high
concurrent networking, uh, will

00:05:43.009-->00:05:49.182
be familiar with a uh, pattern
called, uh, load balancer and
uh, so what you are doing is you

00:05:49.182-->00:05:54.654
have producers uh, taking the
network traffic and then
consumer threads that are aiding

00:05:54.654-->00:05:59.226
that traffic um, so we are
working with queues um, from
computer science, you know,

00:05:59.226-->00:06:04.164
first in, first out, container
and this is because SMB is
designed for speed, um, and what

00:06:08.001-->00:06:12.305
you are actually producing and
consuming are these things
called work_context, which is,

00:06:12.305-->00:06:17.978
there are hundreds of SMB‘s and
uh, all of them can be kind of
pigeon-holed into this mega c

00:06:17.978-->00:06:24.618
structure called a work_context,
and that’s what’s being
processed. Uh, but the really

00:06:24.618-->00:06:29.756
important thing to uh, note on
this slide is that um, when the
server receives SMB requests, it

00:06:29.756-->00:06:35.729
is going to process the response
to you, um, an SMB can be sent
to the back of a queue multiple

00:06:35.729-->00:06:40.133
times while it is being
processed. Um, and so there is
two different types of queues.

00:06:40.133-->00:06:44.771
There is the normal queue coming
off the network and then if
something is going to take a

00:06:44.771-->00:06:51.544
really long time, uh, it will
get sent to a blocking work
queue. Um, in Vista, they

00:06:51.544-->00:06:56.149
introduced SMB2 uh, and they
took, they stripped the
networking portion out of the

00:06:56.149-->00:07:01.087
srv dot sys driver and put it in
a driver called srvnet dot sys,
so this is what is actually

00:07:01.087-->00:07:06.092
binding um, the SMB ports and
then srv dot sys and srv2 dot
sys come along and they register

00:07:09.462-->00:07:15.969
callbacks with that driver and
so when network traffic comes
in, they inspect the, the SMB

00:07:15.969-->00:07:21.341
and they are like, that looks
like SMB1, uh, my driver can
process that, and then that

00:07:21.341-->00:07:28.315
happens. There are only a few
SMB’s of interest. Um, in the
negotiate stage, we pick our SMB

00:07:28.315-->00:07:33.320
dialect, either that NTLM or
Cairo and the server will make
this connection struct. Later

00:07:37.023-->00:07:42.495
when we go to log in, it’s
called session set up, um, the
server will create this

00:07:42.495-->00:07:46.499
structure called a session. It
will have a pointer to that
connection, it will also have

00:07:46.499-->00:07:50.737
our user name and our user
domain, uh, at this point the
server will assign us a user id,

00:07:50.737-->00:07:55.742
um, and when we log in, uh, when
we do the session set up, we
tell the server, um a max buffer

00:07:57.877-->00:08:02.816
size that uh, our SMB client is
able to process, um, so we say
if the SMB response is going to

00:08:05.352-->00:08:10.357
be bigger than this max buffer
size, ah, send it to us in a
multi part SMB. Um, and so

00:08:12.525-->00:08:17.530
mainly what you are doing with
SMB is connecting to trees, um,
which are basically shares. Uh,

00:08:20.567-->00:08:23.670
there is one that we are going
to be connecting to in all of
these exploits. I mean, you can

00:08:23.670-->00:08:27.540
connect to any tree, but the one
that is usually open for
anonymous logins is the

00:08:27.540-->00:08:32.545
interprocess communication
share. And when you connect to a
tree, uh, like that ipc share,

00:08:34.881-->00:08:41.187
uh, the server will assign you a
tree id. Um, so now I am going
to talk about transactions,

00:08:41.187-->00:08:47.293
which are a special subset of
SMB’s, that are what all of
these exploits take advantage

00:08:47.293-->00:08:51.798
of. So, transactions, you can
think of an, an IOCTL. They
perform a variety of functions

00:08:51.798-->00:08:57.604
and most of them are file-system
based. Uh, but what is
interesting about transactions

00:08:57.604-->00:09:03.643
is that they can be split apart
across multiple uh, SMB’s. Um,
so you will send the primary

00:09:03.643-->00:09:09.149
transaction, it will be I have,
you know, this much data to send
you. Um, the server will send an

00:09:09.149-->00:09:14.754
interim response, saying okay I
accept that, um, send me the
rest of it. Then you will send a

00:09:14.754-->00:09:20.160
bunch of secondary transactions,
filling out, uh, that, uh,
whatever data you say you are

00:09:20.160-->00:09:24.064
going to be sending and then
when it finally gets all of
them, that’s when it’s going to

00:09:24.064-->00:09:30.070
process this and send a response
to you. Uh, which can be broken
up uh, as well. Uh, but it is

00:09:30.070-->00:09:35.075
kind of like a database
transaction, you’re like, it’s
an atomic thing, as soon as that

00:09:35.075-->00:09:40.079
last secondary thing comes in,
that’s when it is going to be
processed. Um, so a transaction

00:09:44.317-->00:09:49.556
is kind of like a message block
inside the server message block,
um, so in addition to the SMB

00:09:49.556-->00:09:54.160
parameters block and the SMB
data block, you will also have
the transaction parameter block

00:09:54.160-->00:10:00.800
and transaction data block. Um,
there is different types of
transactions over the years. Um,

00:10:00.800-->00:10:07.106
the Trans and Trans1 as I might
refer to it, uh, is old stuff
like mailslots and the remote

00:10:07.106-->00:10:13.313
access protocol. Um, Trans2
introduced support for greater
than uh, the old DOS style 8

00:10:13.313-->00:10:19.419
point 3 shortnames. Um, and
you’ll see a lot of OS/2 to NT
conversion stuff in there um,

00:10:19.419-->00:10:24.424
and then NT Trans, the parameter
and data block sizes were
changed from shorts to longs. So

00:10:26.826-->00:10:32.899
that’s the major difference
there. And they all have uh,
different dispatch tables, um,

00:10:32.899-->00:10:37.904
that perform different
functions. Um, so when you send
a uh, primary transaction, um,

00:10:40.139-->00:10:45.011
you’ll have the parameter offset
and the data offset as part of
that uh, SMB. And that just uh,

00:10:45.011-->00:10:51.284
tells the server how far into
that SMB um, the trans data and
parameter blocks actually begin.

00:10:51.284-->00:10:56.289
Um, there will be a count so
that is how much data and
parameter you are sending, uh,

00:10:58.291-->00:11:05.164
per this SMB. Total count is how
much we are expecting between
all primary and secondary SMB’s,

00:11:05.164-->00:11:12.138
uh, transaction SMB’s. And then
the max count is we are telling
the server, uh, if you are going

00:11:12.138-->00:11:17.110
to send us a reply for this
transaction, this is the, uh,
buffer size that we are going to

00:11:17.110-->00:11:22.882
uh, reserve for that response,
so don’t, uh, send us more than
that. Uh, when we send our

00:11:22.882-->00:11:27.453
secondary transactions, a lot of
the fields are the same, expect
for now there is a displacement

00:11:27.453-->00:11:34.193
uh, field and that’s uh, so as
we are sending you know,
piecemeal uh, transaction data,

00:11:34.193-->00:11:38.531
uh, we need to tell the server
where in the buffer it needs to
write this packet, uh, cause

00:11:38.531-->00:11:43.636
it’s not keeping track of it,
that is our job to do as the
client. Uh, part of the problem

00:11:43.636-->00:11:48.641
really. So, when you do create a
transaction, when you send a
primary transaction, um, the

00:11:51.110-->00:11:55.782
server will create a transaction
structure. Uh, you can see we
have pointers to our Connection,

00:11:55.782-->00:12:01.688
our Session and our TreeConnect.
Um, and then you see we have uh,
buffers, um, for the incoming

00:12:01.688-->00:12:06.593
parameters, the outgoing
parameters, the incoming data
and the outgoing data. Um, a lot

00:12:06.593-->00:12:12.198
of times, the server will reuse,
uh, the same buffers so the
request buffer, it’s uh, you

00:12:12.198-->00:12:16.169
know smart about it, it doesn’t
make two allocations, not
always, but uh, sometimes. And

00:12:16.169-->00:12:21.908
then you’ll see a transaction
also have a tree id, um, a
process id, and a user id. So, I

00:12:21.908-->00:12:28.047
talked about user id, and uh,
uh, tree id, but process id is
just our client saying uh, any

00:12:28.047-->00:12:33.052
random number really, uh, but
that’s like our process. Um, so
when we allocate, or when we

00:12:36.222-->00:12:40.927
send a primary transaction, the
server with call a function
called Srv Allocate Transaction.

00:12:40.927-->00:12:46.099
Yeah, and the nice thing about
this driver is uh, a lot of the
similar names are uh, available

00:12:46.099-->00:12:51.104
through uh, PDB files on the
Tech Net servers. So, it will
allocate a transaction, uh,

00:12:54.140-->00:12:57.744
generally the minimum size is
going to be 0x5000 and the
reason for that is it is going

00:12:57.744-->00:13:04.484
to grab it from the memory side
list. Um, Not always. Um, and
then the maximum allocation size

00:13:04.484-->00:13:10.156
is going to be 0x10400, uh,
generally. Uh, otherwise you
will get an error saying you

00:13:10.156-->00:13:16.362
tried to make a transaction
that’s too big. When we send
secondary transactions, um, that

00:13:16.362-->00:13:20.299
transaction is already
allocated, uh, so it’s going to
call a function called Find

00:13:20.299-->00:13:25.772
Transaction, and it’s going to
look it up by our user id, our
tree id, our process id um, and

00:13:25.772-->00:13:30.810
then we have this other info
field which is generally uh,
going to be a multiplex id,

00:13:30.810-->00:13:36.616
which is just another random
number um, that we can send as
the client and that lets us have

00:13:36.616-->00:13:41.287
multiple transactions going and
the server know which ones we
are actually talking about when

00:13:41.287-->00:13:47.860
we send transaction packets. Um,
another thing to uh, note is
that all of these structures I

00:13:47.860-->00:13:53.933
talked about are reference
counted um, so if you want to
think about it like, uh, like

00:13:53.933-->00:13:59.772
C++ Smart Pointers, only like
done in C, uh, when you
reference it, uh, a number goes

00:13:59.772-->00:14:04.444
up. When you dereference, it
goes down. And then, uh,
eventually, when you hit zero,

00:14:04.444-->00:14:09.449
it gets freed automatically. And
so, that should be enough
background. Um, so there’s a

00:14:12.051-->00:14:17.957
concept with files called
extended attributes and so this
is just named value, key pairs,

00:14:17.957-->00:14:22.962
metadata attached to files. Um,
the concept was introduced in
OS/2 1.2, which is an old uh,

00:14:25.031-->00:14:30.036
Microsoft/IBM operating system.
They had the high performance
file system. Um, Windows NT, you

00:14:33.005-->00:14:37.210
don’t really see extended
attributes that much anymore.
Uh, there is a thing called

00:14:37.210-->00:14:43.449
alternate data streams, uh,
which most malware analysts are
probably aware of. Um, but one

00:14:43.449-->00:14:47.286
thing I was reading, a modern
use of extended attributes is
for the Windows sub system for

00:14:47.286-->00:14:52.291
Linux. Uh, they use it to store
like file permissions and case
sensitivity data. And then, in

00:14:55.495-->00:15:00.433
SMB parlance, there is FEA and
GEA. So, FEA means the structure
has both name and value and GEA,

00:15:03.269-->00:15:07.106
or a full extended attribute,
and then GEA is a get extended
attribute, which is just the

00:15:07.106-->00:15:12.111
name. So, you might send a GEA
to get a FEA. So here is what
the OS/2 FEA structure looks

00:15:17.283-->00:15:22.288
like. Um, it starts with a flags
field, which is either 0 or 80.
Zero means uh, this FEA, or this

00:15:26.225-->00:15:30.730
extended attribute is not really
that important. 0x80 means uh,
if you’re going to copy this to

00:15:30.730-->00:15:35.334
a file system that has no
extended attributes, uh, think
twice. Uh, because it is an

00:15:35.334-->00:15:40.973
important extended attribute.
Um, and then it has a counted
bytes for the name field and

00:15:40.973-->00:15:45.545
then a counted bytes of the
value field and then immediately
following that it will have um.

00:15:45.545-->00:15:50.917
a buffer, or it will store um,
the name field, which is a
c-string, so it’s

00:15:50.917-->00:15:55.922
null-terminated, and then the
value is not null-terminated
because it can be just arbitrary

00:15:55.922-->00:16:01.460
binary data. Uh, but one
extended attribute by itself
isn’t very useful so you usually

00:16:01.460-->00:16:08.301
find them in a FEA list. Um, so
this structure has the counted
bytes of the entire list um, and

00:16:08.301-->00:16:14.841
then a bunch of those FEA and
then you can get the size of the
FEA, its name plus its value uh,

00:16:14.841-->00:16:20.680
plus the size of the structure,
and you can loop over this FEA
list structure and read each

00:16:20.680-->00:16:25.685
individual FEA. With Windows NT,
they, uh, they added extended
attributes, but they changed the

00:16:28.120-->00:16:32.258
structure a little bit. Um, so
you see, we still have flags,
um, we still have the name

00:16:32.258-->00:16:36.596
length, and we still have a
value length, and then we have
the name buffer and the value

00:16:36.596-->00:16:41.934
buffer afterwards. Um, and then
there is an alignment uh, they
align it to DWORD. I guess

00:16:41.934-->00:16:46.572
certain, maybe certain CPU
architectures, they wanted to
support or needed that alignment

00:16:46.572-->00:16:53.412
or something. Um, but there is
no separate FEA List structure.
There is just this next entry

00:16:53.412-->00:16:58.417
offset so you parse a list of
FEA’s uh, until uh, that next
entry offset is zero. So,

00:17:01.320-->00:17:07.793
parsing it is a little
different. Um, here is the site
of the bug of Eternal Blue, the

00:17:07.793-->00:17:12.865
main bug anyways. What this
function is going is it is
calculating uh, when we send an

00:17:12.865-->00:17:18.771
OS/2 FEA list over the network,
um, the server needs to convert
that into an NT FEA list. Um, so

00:17:18.771-->00:17:23.776
this is just calculating how
much, uh, uh, size it needs to
reserve in memory, and then uh,

00:17:25.878-->00:17:31.417
on the vulnerable line of code,
what it’s doing is if the size
of our OS/2 FEA list that we

00:17:31.417-->00:17:36.455
sent is bad, it is going to try
and fix it for us. Um, I don’t
know why it doesn’t just reject

00:17:36.455-->00:17:41.460
the packet there, uh, it might
be supporting older clients or
something. Uh, but I mention

00:17:44.330-->00:17:50.169
that the counted bytes of the
FEA list is a ulong. What you
saw there was putting it into a

00:17:50.169-->00:17:55.174
ushort, uh, so it is casting it
wrong. So, if I was an attacker,
say, um, here is 0x10000 bytes

00:17:57.910-->00:18:04.650
of FEA list, uh, then my HIDWORD
is set. Uh, when that function
comes along and it says oh, I

00:18:04.650-->00:18:09.655
only see ff5d valid um, FEA list
there. When it casts
incorrectly, um, you’ll see that

00:18:14.927-->00:18:19.165
that HIDWORD is still set and
the site thinks that the size of
the buffer is bigger than it

00:18:19.165-->00:18:25.771
really is. And then, uh, when it
calculates the size that it
needs to reserve from the NT

00:18:25.771-->00:18:30.776
buffer, it’s only going from the
uh, uh, from the correct casted
variable, uh, but here’s what it

00:18:34.347-->00:18:38.117
looks like in code. Uh, most
people will be probably familiar
with x86/x64. Uh, you can see

00:18:38.117-->00:18:44.690
that we are working with uh,
DWORD registers and then at the
site of the vulnerability, uh,

00:18:44.690-->00:18:51.397
it’s moving a word pointer. Uh,
so I am going to explain the
same thing, just a little bit

00:18:51.397-->00:18:58.037
clearer here. Um, so as an
attacker, I am supplying this
FEA list, um, in an SMB, um, and

00:18:58.037-->00:19:04.110
I say here is my 0x10000 sized
uh, FEA list. And then you will
see, there is a bunch of uh,

00:19:04.110-->00:19:09.915
what I am referring to as NULL
FEA, uh, and that’s just where
the name and the value are both

00:19:09.915-->00:19:15.955
zero. Um, it’s an exercise for
you to figure out why that would
be the most efficient way, but,

00:19:15.955-->00:19:21.527
uh, basically 5 bytes of OS/2
FEA here become 12 bytes of NT
FEA because there is more data

00:19:21.527-->00:19:27.566
in NT FEA, and so this really is
the most efficient way to
packet. Um, but then as it is

00:19:27.566-->00:19:32.471
parsing through all the FEA’s,
it gets to the end of uh, this
buffalo overflow FEA and it sees

00:19:32.471-->00:19:38.711
that the start of that FEA plus
the length of that FEA, um,
exceeds the, uh, the CB list

00:19:38.711-->00:19:44.283
size of the 0x10000 so it says,
I’m going to do a great job and
correct that for you and then I

00:19:44.283-->00:19:49.822
am going to reserve an NT
buffer. Um, so then in another
function after these buffer

00:19:49.822-->00:19:54.627
sizes have been uh, calculated,
uh, it’s going to go through and
it’s going to copy each FEA one

00:19:54.627-->00:20:00.599
by one uh, doing the conversion
to NT FEA, um, and then when it
gets to that buffalo overflow

00:20:00.599-->00:20:05.871
FEA, it’s going to exceed that
buffer. Um, and then you can see
if we keep copying, we are going

00:20:05.871-->00:20:10.976
to hit it uh, on an unallocated
space and crash the target, um,
so we can send an invalid FEA.

00:20:10.976-->00:20:15.981
That’s just where, uh, the flags
are not 0 or 80. Um, and when we
send that, we’ll an uh, SMB

00:20:19.518-->00:20:25.724
error, um, from the server, uh,
that’s an invalid parameter and
so that’s a really good sign for

00:20:25.724-->00:20:31.230
us – that means that the uh,
overflow FEA happened, we didn’t
crash immediately, uh, you know

00:20:31.230-->00:20:36.235
we may not be Gucci, but it
might uh, still crash later, but
um, so we are looking for the

00:20:39.605-->00:20:46.512
path of least resistance to
trigger this bug. Um, some, uh,
some of the functions that call

00:20:46.512-->00:20:51.817
these vulnerable functions uh,
require a little bit more
access, um, or uh, access to

00:20:51.817-->00:20:53.819
name pipes. Uh, so this
Trans2_Open2 is the best way to
do it. Um, you’re opening a

00:20:53.819-->00:20:55.821
file, but you are also creating
one, and uh, you can see that it
takes a, uh, extended attributes

00:20:55.821-->00:21:00.760
list um, for that and so you can
set most of this packet, or this
SMB to, uh, just saying default

00:21:08.934-->00:21:13.939
values and then put your exploit
FEA there. Another thing, uh,
another bug, um, like I said, we

00:21:19.912-->00:21:25.918
are sending a greater than
0x10000 data um, but with a
Trans2 request, uh, data and

00:21:25.918-->00:21:31.524
parameter blocks are only WORD
sized. Um, so what’s going on
here, um, if you look at the

00:21:31.524-->00:21:37.530
wire short capture, it’s first
opening with an NT uh, primary
transaction, and then it is

00:21:37.530-->00:21:42.134
sending Trans2 secondary
transactions. Um, so the bug is
it doesn’t matter what your

00:21:42.134-->00:21:46.772
primary transaction is, it
doesn’t matter what your
secondary transactions are

00:21:46.772-->00:21:51.277
except for that last one, uh,
when the transaction gets
executed, that’s when it’s going

00:21:51.277-->00:21:58.250
to choose the dispatch table.
Um, so we can reserve, um, since
NT allows us to do uh, DWORD

00:21:58.250-->00:22:03.189
sized um, parameter and data
blocks, uh, that we can use to
trigger the bug. Um, there is

00:22:05.991-->00:22:10.796
another problem with session
setup allocations. Um, so
there’s many different ways to

00:22:10.796-->00:22:16.802
log in to SMB. Uh, at least two
ways are NT Security and
Extended Security. Uh, and

00:22:16.802-->00:22:21.807
depending on the flags of SMB,
you can actually, um, confuse
the server and it will read uh,

00:22:24.476-->00:22:30.749
from the wrong uh, offset where
it should be allocating the size
of that SMB’s data block. Um, so

00:22:30.749-->00:22:35.054
this bug doesn’t really let you
do much in terms of
exploitation. It does help you

00:22:35.054-->00:22:40.125
groom the pool, uh, which we are
going to get into, but uh, it
basically lets us reserve a

00:22:40.125-->00:22:44.396
large amount of memory, and
then, uh, if we close that
connection, it will free that

00:22:44.396-->00:22:50.436
memory immediately. Um, and this
is still on the master branch of
Windows, uh, pretty sure they

00:22:50.436-->00:22:57.343
haven’t fixed it. But like I
said, it is not really a
vulnerability, it’s just a weird

00:22:57.343-->00:23:02.281
quirk. So now we have all of the
ingredients we need for uh,
EternalBlue. Uh, we have the

00:23:02.281-->00:23:06.552
exploits uh, connection. Uh, so
we will be opening many
connections to the server during

00:23:06.552-->00:23:11.857
the exploitation process. Uh, on
one connection we are going to
be setting the exploit. On

00:23:11.857-->00:23:16.462
different connections we are
going to be sending uh, uh, that
session setup bug that lets us

00:23:16.462-->00:23:19.932
reserve large amounts of memory.
Um, we are going to make an
allocation and a hole

00:23:19.932-->00:23:25.704
connection. Um, and then what we
are actually going to try and
uh, overflow into is um, a

00:23:25.704-->00:23:31.310
SrvNet dot sys network buffer.
Um, so when SrvNet dot sys sees
network traffic, it’s not just a

00:23:31.310-->00:23:36.849
buffer, right, it’s the
structure, um, and then a buffer
uh, that follows it. Um, and we

00:23:36.849-->00:23:41.353
are trying to overflow into that
structure, at least for Windows
7. Windows 10 it gets a little

00:23:41.353-->00:23:46.392
weird. Um, but we are going to
send primary grooms, secondary
grooms. They look like SMB2

00:23:46.392-->00:23:51.664
packets, uh, there was a little
confusion, um, in the early
reporting, um, that some of

00:23:51.664-->00:23:56.669
these bugs were SMB2 and 3. Um,
they are all SMB1, but uh, uh,
it’s before like, um, SrvNet

00:24:00.372-->00:24:07.046
does callbacks and either Srv 2
or Srv 1 handle it. Um, the only
thing I have seen, credible

00:24:07.046-->00:24:11.684
claim, is that it might be an
IDS bypass cause eventually,
after we overflow these, uh,

00:24:11.684-->00:24:16.355
SrvNet uh, structures, we are
going to send the shellcode and
all that over it, um, so maybe

00:24:16.355-->00:24:21.360
if it looks like SMB2, uh, that
was an attempt at an IDS bypass.
Um, so, before we start the

00:24:25.197-->00:24:31.337
exploitation process, there’s a
uh, uh, SrvNet uh, the network
buffers, they have lookaside

00:24:31.337-->00:24:36.909
memory, and then there is just
the random stuff in the pool.
Um, the first step is to we are

00:24:36.909-->00:24:43.082
going to send um, our primary
exploit transaction and all of
the exploit transactions uh,

00:24:43.082-->00:24:48.587
with the FEALIST in it, except
for the last one. Uh, so nothing
really going on in memory yet,

00:24:48.587-->00:24:53.125
uh, just as soon as we send that
last transaction, uh, it will
trigger the bug and do the

00:24:53.125-->00:24:56.328
overflow. Uh, we don’t want to
do it yet, because we haven’t
groomed the pool. Uh, then we

00:24:56.328-->00:25:01.633
are going to send uh, the
initial grooms, so these are
just uh, basically naked SMB.

00:25:01.633-->00:25:07.873
Yeah, it’s before either SMB1 or
2 takes over. And what we are
trying to do here is force uh,

00:25:07.873-->00:25:14.279
new pool allocations. Um, then
we send uh, open a new
connection with the uh, that

00:25:14.279-->00:25:18.484
allocation bug. Uh, we don’t, we
were going to reserve a large
memory block, but it’s not going

00:25:18.484-->00:25:23.789
to be the same size as our
incorrectly calculated NT
buffer. We’re going to send a

00:25:23.789-->00:25:30.696
hole buffer, uh, so this is the
exact same size that the uh, NT
FEA buffer uh, eventually the

00:25:30.696-->00:25:35.367
uh, incorrect sizes uh, we want
it to fit in this hole. Next, we
are going to close the

00:25:35.367-->00:25:40.539
allocation connection. Uh, this
lets uh, just random stuff in
the pool, uh, come along and

00:25:40.539-->00:25:46.111
allocate memory without messing
up our, uh, uh, exploitation
process. Then we are going to

00:25:46.111-->00:25:50.015
send the secondary grooms. They
look exactly like the primary
grooms. We are just hoping that

00:25:50.015-->00:25:54.386
one ends up after the hole
connection there. Um, and then
we are going to free the hole

00:25:54.386-->00:26:00.325
connection and we are going to
send the last, uh, exploit uh,
transaction and that’s gonna uh,

00:26:00.325-->00:26:04.963
think it can fit in that hole
and then during the memory copy
when it’s parsing all the FEA’s

00:26:04.963-->00:26:10.536
uh, it’s going to overflow into
the headers uh, of the next. Uh,
so what are we actually

00:26:10.536-->00:26:15.607
overflowing here? Um, like I
said, it’s not just a buffer,
um, there is a structure, a

00:26:15.607-->00:26:21.713
couple structures, um, you’ll
see there is a MDL, which is a
memory descriptor list. It’s a

00:26:21.713-->00:26:26.718
common uh, NT uh, structure that
lets you map uh, virtual memory
to physical memory. Um, so we

00:26:29.455-->00:26:35.727
can overwrite that, one of those
MDL’s uh, and depending on what
address we give it, that’s a

00:26:35.727-->00:26:40.833
write ware primitive. Uh, once
we overwrite that MDL, any
network traffic we send over

00:26:40.833-->00:26:45.304
that connection, um, instead of
going to the buffer, it’s going
to go to wherever we uh,

00:26:45.304-->00:26:50.309
overwrote. Um, so the Hal Heap,
until the um, the very latest
versions of Windows 10, uh, they

00:26:52.678-->00:26:57.683
were not ASLR, um, and on
Windows 7, it’s not DEP either.
Um, then you will see we’re also

00:27:00.185-->00:27:05.190
overflowing a uh, pointer to
this uh, WSK - Win Sock
Structure. Um, we point that

00:27:07.493-->00:27:12.164
pointer um, at the Hal Heap, uh,
as well, and then we uh, send a
fake structure, which I’ll do on

00:27:12.164-->00:27:18.003
the next slide. Um, and then we
also send our shellcode at this
time. Um, so that fake structure

00:27:18.003-->00:27:23.008
that we overwrote, um, has a
function table, um, that’s the
most important number that we

00:27:25.410-->00:27:29.581
are worried about. Everything
else the same defaults. Um, and
that way, so we send the

00:27:29.581-->00:27:33.752
shellcode to all of those uh,
primary grooms and secondary
grooms. They are all separate

00:27:33.752-->00:27:37.589
connections. Um, we don’t know
which one actually got
overflowed to the right write

00:27:37.589-->00:27:42.594
ware primitive. Um, so we closed
all of the um, groom
connections, and then, uh, they

00:27:42.594-->00:27:47.599
are going to go through, and
they are going to call these,
uh, uh, handlers for when uh, a

00:27:50.102-->00:27:54.706
connection closes, and
eventually it’s going to hit the
function table uh, which we have

00:27:54.706-->00:27:58.977
conveniently pointed the clean
up function to point at the
address of the shellcode. Um,

00:27:58.977-->00:28:03.916
which is on that Hal Heap. Um,
but it’s still not that simple
because um, EternalBlue at that

00:28:06.952-->00:28:12.591
point, uh, we’re operating a
dispatch level in the kernel,
which means that a lot of uh,

00:28:12.591-->00:28:17.863
common functionality uh,
libraries and stuff, uh, or
functions exported, are off

00:28:17.863-->00:28:23.035
limits because we don’t have
access to things like page
memory. Um, so one of the

00:28:23.035-->00:28:27.706
quickest and dirtiest ways that
you can get from dispatch level
to passive level is to hook the

00:28:27.706-->00:28:32.711
Syscall table. Um, and then next
time um, a Syscall happens, uh,
um, instead of going to the

00:28:35.380-->00:28:39.918
normal Syscall handler, it will
come to our function. Um, we’ll
transition gracefully from user

00:28:39.918-->00:28:43.889
mode, you know, we’ll set up the
kernel stack and all that, um,
and then we’ll run the main

00:28:43.889-->00:28:47.893
stage, right, the, the double
pulsar backdoor, which is going
to backdoor um, the

00:28:47.893-->00:28:53.332
SrvTransaction2DispatchTable.
Um, and then after we’re done
running double pulsar, we will

00:28:53.332-->00:28:59.471
restore the Syscall handler. And
I’m going to going into double
pulsar a little bit, uh, later.

00:28:59.471-->00:29:05.444
But basically, here’s the patch.
Um, I just fixed that caste from
a short to a long. Pretty

00:29:05.444-->00:29:10.449
straight-forward. Yeah, and all
of these patches are one-liners.
Um, so Eternal Champion um,

00:29:12.551-->00:29:17.990
Transactions. If I tried to send
um, secondary transactions um,
after a transaction is already

00:29:17.990-->00:29:24.963
executing, um, it will have this
uh, executing BOOLEAN locking
mechanism set, uh, so before it

00:29:24.963-->00:29:30.268
executes a transaction, it’s
gonna set that locked variable
to true um, and then if I send a

00:29:30.268-->00:29:36.375
secondary, it’s just going to
reject it. Um, except if I have
a primary transaction where I

00:29:36.375-->00:29:40.879
send all of my um, data and
parameter in one primary
transaction, I don’t really need

00:29:40.879-->00:29:47.052
a secondary transaction, uh, the
bug is they forgot to set that
lock, um, so then, um, while

00:29:47.052-->00:29:52.024
that transaction is executing,
we can come on by and send
secondary transactions and

00:29:52.024-->00:29:57.829
actually modify um, the data of
that primary uh, transaction.
Um, so this gives us an info

00:29:57.829-->00:30:02.467
leak on a single-core processor
and then there is a stack
overwrite, um, it seems to be

00:30:02.467-->00:30:07.773
only triggered on a multi-core.
And, uh, I believe its Eternal
Champion because champions win

00:30:07.773-->00:30:12.778
races and this is basically a
race condition. Um, so in order
to uh, uh, perform, uh, the

00:30:18.150-->00:30:24.423
exploitation, uh, we need to uh,
leak a transaction. We need
kernel addresses, that kind of

00:30:24.423-->00:30:30.062
thing. Um, so there is another,
uh, so the first thing we can do
with this race condition, um, is

00:30:30.062-->00:30:34.433
we can look for an SMB which
echoes data back. Um, on older
versions of Windows, the remote

00:30:34.433-->00:30:38.970
access protocol has uh,
WNetAccountSync and
NetServerEnum2, those will echo

00:30:38.970-->00:30:45.043
data back to us. Um, on every
version of uh, NT, you have
NT_RENAME. Uh, the only

00:30:45.043-->00:30:50.849
difference is that that requires
a valid fire ID so you have to
open a name pipe um, and so

00:30:50.849-->00:30:54.820
there are a little bit more
permissions associated with
that. Um, but basically, all we

00:30:54.820-->00:31:00.992
are going to do, is we are going
to send, um, a primary uh,
transaction uh, where the data

00:31:00.992-->00:31:05.997
is greater than – Jesus – Sorry,
I spilt some water up here. Just
in case you needed a quick

00:31:29.054-->00:31:34.059
review. Um, so we send a primary
transaction where the amount of
data in that is greater than

00:31:37.362-->00:31:42.134
when we uh, logged in with a
session set up, uh, we told it
its max buffer size that we can

00:31:42.134-->00:31:47.038
expect for a reply. Um, so the
amount of data that needs to
echo back to us can’t fit in one

00:31:47.038-->00:31:52.010
reply so it’s going to send it
to the back of uh, a work queue,
um, and then when it gets sent

00:31:52.010-->00:31:56.782
to the back of the work queue,
we can have another secondary
transaction come in and uh,

00:31:56.782-->00:32:02.020
modify the uh, amount of data,
the data count on it, um, and
then just because there is uh,

00:32:02.020-->00:32:07.626
bad validation, uh, this does
let us uh, when it goes to read,
uh, data back to us, it will

00:32:07.626-->00:32:12.631
read past the buffer, um, into
another transaction. Um, so here
is the uh, code execution path.

00:32:16.234-->00:32:22.274
Um, so there is a, uh, uh,
transaction, I believe 2, called
QueryPathInformation. And part

00:32:22.274-->00:32:27.412
of its parameter block, um, has
a subCommand, um, so the first
step we are going to do with

00:32:27.412-->00:32:30.916
that subCommand is we are going
to say I want to query an
extended attribute size and

00:32:30.916-->00:32:35.253
that’s going to send us to the
back of a blocking work queue.
Um, so when we send secondary

00:32:35.253-->00:32:39.291
transactions we’re on the normal
work queue and then the
transaction is also being

00:32:39.291-->00:32:45.730
processed on a blocking work
queue. Um, the second step um,
is so after we’ve triggered

00:32:45.730-->00:32:50.335
that, um, we have other
transactions and secondary come
by that modifies the parameter

00:32:50.335-->00:32:54.439
block, uh, the transaction
parameter block, um, and then we
change the subCommand to a

00:32:54.439-->00:32:59.044
is_name_valid, um, and this is
pointing at a stacked variable
now, uh, it changes our end data

00:32:59.044-->00:33:03.982
pointer to a stacked variable.
Um, and so uh, with that end
data pointer uh, pointed at a

00:33:06.518-->00:33:10.889
stacked variable using uh, data
displacement, uh, we can get
past things like stacked

00:33:10.889-->00:33:15.861
canaries and stuff and we can
overwrite uh, our return address
to our worker thread with a

00:33:15.861-->00:33:20.866
secondary transaction. Um,
sorry, running low on time
already. Uh, so basically uh,

00:33:24.569-->00:33:29.207
when we send uh, this
exploitation sequence, it’s
going to be 8 SMB’s in one TCP

00:33:29.207-->00:33:34.179
packet. Uh, the first one’s
going to be that Query_EA_Size
uh, primary with all of the data

00:33:34.179-->00:33:40.218
and all the parameter, so that’s
going to cause the blocking work
queue uh, to be triggered and

00:33:40.218-->00:33:44.155
then we’re going to send um, a
transaction secondary that
changes it to the Is_Name_Valid

00:33:44.155-->00:33:47.559
subCommand which is making it
pointed at a stacked variable,
and then we are going to send

00:33:47.559-->00:33:52.397
um, 6 uh, transaction 2
secondaries with a data
displacement that’s going to

00:33:52.397-->00:33:58.003
overwrite uh, the return
address. Uh, but it’s raised
conditions, so we send 8 packets

00:33:58.003-->00:34:02.707
per exploitation attempt. Uh, so
we attempt, we see if double
pulsar has been installed, um,

00:34:02.707-->00:34:07.712
and if it hasn’t, we run it 42
times uh, by default. Um, when
we get code execution, um, on a

00:34:12.584-->00:34:17.489
depth thing, uh, if the thing
has depth, we’ll search the uh,
connection transaction list. We

00:34:17.489-->00:34:22.127
are looking for a special
identifier at the start of one
transaction um, and so this is

00:34:22.127-->00:34:27.165
basically an egghunter. Uh, it’s
where we are going to store the
shellcode. Uh, at this point, we

00:34:27.165-->00:34:31.002
basically have access to
allocation functions of the
pool, so we will copy the

00:34:31.002-->00:34:37.175
payload um, from that egg and
then run it. Uh, then we will
increment, uh, the amount of

00:34:37.175-->00:34:42.514
available threads on one of the
structures that we get past into
our shellcode. Um, and then we

00:34:42.514-->00:34:48.653
can resume execution uh, with a
little uh, NT magic. So, there
is the processor control region,

00:34:48.653-->00:34:53.391
which is a global variable, um,
in the kernel. Uh, just going
from there we can get to the

00:34:53.391-->00:34:58.730
current thread start address and
then just jump to it. And um,
resume execution in the worker

00:34:58.730-->00:35:04.302
thread loop. Um, so here is the
patch for Eternal Champion. Uh,
this is primary transaction. If

00:35:04.302-->00:35:09.841
all data was received, it began
executing the transaction. After
the patch, it set that executing

00:35:09.841-->00:35:14.846
variable to true. That’s it. Um,
so I talked about uh, when
secondary transactions come by

00:35:19.351-->00:35:23.254
instead of allocating a
transaction, it’s looking up a
transaction. Um, generally it’s

00:35:23.254-->00:35:27.959
going to be a randomly generated
multiplex id, but there is a
special SMB called a Write_Andx

00:35:27.959-->00:35:32.964
and if you open a file in raw
mode, uh, with WriteAndX, um, it
makes a transaction instead of

00:35:35.200-->00:35:41.706
uh, whatever they do for
everything else. Um, and with
SM, um, with this weird uh,

00:35:41.706-->00:35:46.177
pseudo transaction that’s not
really a transaction, um, as
they are copying data that you

00:35:46.177-->00:35:51.016
are sending to write to that
file, um, they’ll increment the
end data pointer of the

00:35:51.016-->00:35:56.021
transaction. Um, so we can uh,
cause the type confusion
sequence here. Um, so we do an

00:35:58.790-->00:36:04.062
NTCreateAndX for opening a named
pipe, um, the server assigns us
a file id. Then we’re going to

00:36:04.062-->00:36:08.900
create um, just a normal
everyday transaction, nothing
special, um, but we’re going to

00:36:08.900-->00:36:13.638
set our multiplex id to the same
as that file id that just got
assigned by the server and so

00:36:13.638-->00:36:18.576
it’s gonna, the server’s going
to allocate a transaction. Then
we’re going to do that WriteAndX

00:36:18.576-->00:36:24.616
uh, request uh, with the FID.
It’s going to see, oh yeah,
there’s a transaction, a

00:36:24.616-->00:36:30.688
transaction there, uh, and it’s
going to increment that data,
that end data buffer pointer.

00:36:30.688-->00:36:34.225
Um, so this is going to allow us
to shift the pointer, um, so
what we’re going to do first is

00:36:34.225-->00:36:37.495
we are going to groom the pool,
so there is an exploit
transaction, and then a victim

00:36:37.495-->00:36:43.334
transaction right after it. Um,
normally our transaction end
data pointer will only be able

00:36:43.334-->00:36:50.108
to uh, using displacement and
all that, we can only access our
uh, our data buffer um, but

00:36:50.108-->00:36:54.379
after we do the uh, the shift,
uh, that pointer got
incremented, so if we send a

00:36:54.379-->00:36:59.384
secondary transaction now, uh,
we can write past our buffer.
Um, so there’s another bug that

00:37:02.821-->00:37:07.392
lets us get an info leak uh,
cause again we need kernel
addresses, that kind of thing.

00:37:07.392-->00:37:12.030
Um, so normally,
Trans_Peek_NMpipe, you’re just
peeking a name pipe. It expects

00:37:12.030-->00:37:16.468
the max parameter count to be
16, but it takes the client
value. Um, so if we are

00:37:16.468-->00:37:21.206
allocating from a look aside
list, uh, we can set that max
parameter count to most of that

00:37:21.206-->00:37:27.278
0x5000, um, and then we’ll set
the max data count to 1, you
know, just a really tiny value.

00:37:27.278-->00:37:33.918
Um, and then because there is
bad checking and the way that it
writes, uh, uh, where it writes

00:37:33.918-->00:37:38.590
the data, um, when you’re
peeking that name pipe, um,
basically, if we can put greater

00:37:38.590-->00:37:43.595
than one data uh, to be caused
into that named pipe, um, then
it will be uh, uh, it will just

00:37:46.531-->00:37:52.604
read past the buffer when it
replies to us. Um, so there is
different uh, ways that we can

00:37:52.604-->00:37:59.277
groom the pool. Um, fish in a
barrel affects older versions of
Windows, uh, uh, I think it’s up

00:37:59.277-->00:38:03.848
through Vista, but basically
what it was doing is when Srv
dot sys drivers started up, it

00:38:03.848-->00:38:08.853
would um, create a pre-allocated
uh, heap, um, and so with a
pre-allocated, uh, chunk of

00:38:11.556-->00:38:17.262
memory, we’re not fighting other
drivers and stuff – we’re not
going to the pool. Uh, so it’s

00:38:17.262-->00:38:22.600
really convenient. Um, it’s also
great because this private heap
is only for very specific MS-RAP

00:38:22.600-->00:38:27.639
transactions, which are very
rarely used these days. Uh, so
it is a very straightforward um,

00:38:27.639-->00:38:32.477
heap fung shui. And this is what
it looks like. We are sending
victims transactions, um, there

00:38:32.477-->00:38:38.483
called fish. And then we have a
dynamite, which is just a
transaction that uh, with the

00:38:38.483-->00:38:43.621
MID set to the FID, so it’s
eligible for that pointer shift,
um, and then we’ll just send

00:38:43.621-->00:38:49.327
more victims, we’ll send another
dynamite in case the first one
failed for whatever reason, so

00:38:49.327-->00:38:55.633
it will just groom the pool that
way, and then uh, attempt
exploitation. Um, matched pairs

00:38:55.633-->00:39:00.872
is, uh, all versions of Windows,
um, including 7 plus, um, so
when they removed fish in a

00:39:00.872-->00:39:06.077
barrel with that private heap,
uh, you still have this groom
available. Uh, the only

00:39:06.077-->00:39:10.248
difference is that instead of
having that private heap that no
one is using, uh, now we have to

00:39:10.248-->00:39:17.255
go to the normal, paged pool um,
which is what everybody uh,
every process, uh, everybody

00:39:17.255-->00:39:22.260
wants page pool, uh, so it’s
very contentious. Um, so this is
a little over simplification,

00:39:24.395-->00:39:30.535
just for time and space of the
slide. Um, but we’re going to
send these groom transactions

00:39:30.535-->00:39:36.875
and they’re going to take up um,
pretty much as much as they can
of several pages, um, and then

00:39:36.875-->00:39:40.578
on that last page, it’s going to
leave a little bit of extra
space at the end. And so that

00:39:40.578-->00:39:47.051
creates as special kind of pool
called a fragment pool, um, and
so this is, we’re just uh,

00:39:47.051-->00:39:53.324
filling up memory at this point.
Then we send um, exploits, uh,
something eligible for that

00:39:53.324-->00:39:57.495
pointer shift, and there is a
little extra going on there, but
uh, basically yeah, we just

00:39:57.495-->00:40:03.167
send, uh, an exploit pointer
shift thing, and uh, then we
come along with the brides,

00:40:03.167-->00:40:09.707
which are specifically designed
to fill that gap and so we’re
only sending like 10 or so

00:40:09.707-->00:40:15.647
grooms, we send 48 brides, uh,
and we are hoping that one of
those brides uh, ends up after

00:40:15.647-->00:40:20.652
one of our exploits uh,
pointers, inside that frag. Um,
so now that we have the pointer

00:40:23.154-->00:40:27.492
shift, we can write into one of
these victim transactions, we
can create a Write-What-Where

00:40:27.492-->00:40:33.998
Primitive out of it. Uh, uh,
basically we modify, um, using
our exploit transaction that’s

00:40:33.998-->00:40:39.137
been shifted, we modify our
victim transaction, um, its end
data pointer, uh, we point it to

00:40:39.137-->00:40:43.441
where we want to write, we set
that executing variable to
false, uh, some other clerical

00:40:43.441-->00:40:48.446
things, um, also increase the
reference count of the uh, smart
pointer type thing, um, and then

00:40:51.215-->00:40:55.386
when we send a victim
transaction secondary, um, that
whatever is in our data block is

00:40:55.386-->00:41:00.458
actually what we want to write.
Um, Read-Where, um, we modify
the victim transaction to point

00:41:00.458-->00:41:07.432
at the leak transaction. Um, and
we can get the address of the
leak transaction, we can infer

00:41:07.432-->00:41:12.971
the address by its contents. Um,
this time we set the OutData
pointer from where we want to

00:41:12.971-->00:41:17.775
read, um, we change its SetUp to
a peak name pipe and then we set
a max data count to how much

00:41:17.775-->00:41:23.548
data we want to read. Uh, then
we send a leak data uh, trans
uh, secondary and it will echo

00:41:23.548-->00:41:29.554
back OutData, which is pointing
from where we want to read. Um,
so we have Read-Write

00:41:29.554-->00:41:33.524
Primitives, we are on a quest to
find somewhere to store the
shellcode. Um, if we set the

00:41:33.524-->00:41:39.230
victim transaction OutParameters
to Null, and then we send a
secondary uh, transaction, uh,

00:41:39.230-->00:41:45.370
it’ll change that OutParameters
to uh, point at the WorkContext
uh, response buffer, which is

00:41:45.370-->00:41:49.707
Read Write X memory, um, and
then we can use the Read
Primitive to read the address

00:41:49.707-->00:41:56.547
that just got set, and the Write
Primitive to write the shellcode
to that location. Um, and now we

00:41:56.547-->00:42:02.587
are on a quest to execute the
shellcode. Um, so this is uh,
uh, similar methodology to what

00:42:02.587-->00:42:08.559
double pulsar is doing, only we
are doing it remotely. Um, so we
read in our leaked transaction

00:42:08.559-->00:42:12.663
uh, it has that connection
pointer on it. We read in from
that connection pointer, uh, it

00:42:12.663-->00:42:17.034
has a variable called
EndpointSpinLock and that’s
pointing to a global variable in

00:42:17.034-->00:42:22.373
the Srv dot sys driver, um,
inside of that PE’s data
section. Um, so then we just

00:42:22.373-->00:42:27.178
read backwards in memory, um, we
are looking for a special table
called the SrvSmbWordCount. Um,

00:42:27.178-->00:42:32.950
so uh, the word counts
associated with the size of uh,
transaction or uh, SMB

00:42:32.950-->00:42:39.857
parameters. Um, so this is a
table that’s about 256 entries,
but only has 100 commands. Um,

00:42:39.857-->00:42:44.529
so anything that’s not uh, a
legal command is going to be a
negative 2 in this table, um,

00:42:44.529-->00:42:49.934
which is 0xfe, so when you see a
bunch of fefe, when you’re
reading the thing, you know your

00:42:49.934-->00:42:55.173
getting close. And then so
immediately following that will
be the transaction 2 dispatch

00:42:55.173-->00:43:00.111
table, um, and then offsets 14
and 15 under that table uh, are
not implemented. Uh, and we can

00:43:02.380-->00:43:09.320
overwrite, um, 0x14, which is
uh, with the, the address of the
shellcode, and then we send a

00:43:09.320-->00:43:15.760
transaction that triggers that
uh, dispatch table to be called.
Um, so here is how they patched

00:43:15.760-->00:43:21.332
the info leak. Um, before the
max parameter count was either
the user supplied max parameter

00:43:21.332-->00:43:26.337
count or 16. After the patch,
they made it always 16. And this
is how MS17-010 Scanners, uh,

00:43:29.674-->00:43:35.446
one way you can write one. Uh,
um, so I mentioned before that
when you allocate a transaction,

00:43:35.446-->00:43:42.186
if it is greater than 0x10400,
you’ll get a status insufficient
server resources. Um, so what

00:43:42.186-->00:43:46.157
we’ll do is we’ll send a, a
transaction where the max
parameter count and the max data

00:43:46.157-->00:43:50.428
count is going to be greater uh,
the sum of those is going to be
greater than 0x10400. Um, before

00:43:50.428-->00:43:57.301
the patch, it will reject that
packet and send us that status
insufficient server resources.

00:43:57.301-->00:44:02.974
After the patch, it’s going to
fix that uh, max parameter count
to 16, um, and so now it will do

00:44:02.974-->00:44:07.311
a proper allocation. Uh, we’ll
get a little bit further and get
a different error message, and

00:44:07.311-->00:44:12.416
so that’s how you can tell if
the target has been patched. Um,
so here is another thing they

00:44:12.416-->00:44:17.321
fixed is if the data count in
the named pipe is greater than
the max data count, uh, the size

00:44:17.321-->00:44:23.361
of the client buffer, uh,
they’ll just uh, fix that. Um,
here is the remote code

00:44:23.361-->00:44:28.599
execution for the patch and
after the patch. Um, so before
the patch, remember it was

00:44:28.599-->00:44:34.772
shifting that pointer uh, during
uh, WriteAndX. After the patch,
instead of shifting the pointer,

00:44:34.772-->00:44:39.777
they’re just um, using an offset
uh, during the copy. Um, another
thing they did to fix the remote

00:44:42.947-->00:44:47.051
code execution, and this does
help with Eternal Blue as well,
is now when you allocate a

00:44:47.051-->00:44:53.357
transaction, uh, you set what
uh, the expected secondary
command should be um, and then

00:44:53.357-->00:44:57.929
later when you go to find a
transaction, it sees if that new
incoming uh, secondary

00:44:57.929-->00:45:03.868
transaction, uh, if that command
matches up with the same uh,
expected secondary command and

00:45:03.868-->00:45:10.274
if not, it won’t return it. Um,
so now we can get into
EternalSynergy. Uh, so this has

00:45:10.274-->00:45:15.546
the same uh, buffalo overflow
and Read Write Primitives as
EternalRomance. Um, you also get

00:45:15.546-->00:45:19.650
the matched pairs and the uh,
classic grooming, and I didn’t
get to go through the classic

00:45:19.650-->00:45:24.655
grooming, but uh, they
inadvertently, with Windows 8,
they patched um, the info leak

00:45:27.024-->00:45:33.965
that was in, uh, EternalRomance,
so we can’t do uh, the normal
Romance methodology, instead, we

00:45:33.965-->00:45:39.837
do our info leak using the
EternalChampion uh, methodology.
Uh, but another thing is the

00:45:39.837-->00:45:44.575
address that we stored our
shellcode at last time has
become a DEP pool. Um, which

00:45:44.575-->00:45:51.349
means that it is non-executable.
Uh, so we need a new way to find
uh, an executable portion of

00:45:51.349-->00:45:56.554
memory. Um, so using our read
primitives, same ones as
EternalRomance, uh, we can read

00:45:56.554-->00:46:03.394
the connections preferred work
queue, um, which is going to be
uh, uh, it’s going to have on it

00:46:03.394-->00:46:08.399
a number called IrpThread, which
gives us a KThread structure.
KThreads have a KProcess and

00:46:11.535-->00:46:16.540
then KProcesses have uh, a
process list entry double linked
list uh, only normally double

00:46:19.110-->00:46:24.281
linked lists uh, you know, one
goes to one and then going
backwards you can traverse back

00:46:24.281-->00:46:29.687
and forth. Um, with the process
list entries, it appears uh, to
me that, uh, as you go forward,

00:46:29.687-->00:46:34.091
you go to the next process, but
at each step, if you try and go
back, you just go back to the

00:46:34.091-->00:46:39.096
list head instead of being able
to go to, yeah. Um, and so that
list head is actually a global

00:46:42.500-->00:46:47.505
variable inside uh, uh,
ntoskrnl, um, so you just start
reading backwards in memory from

00:46:47.505-->00:46:52.610
that global variable uh, until
you get to the MZ header. And
then you can parse the, using

00:46:52.610-->00:46:57.615
the remote read, you can parse
the ntoskrnl PE header. And on
Windows 8 and 8 dot 1, they have

00:47:01.752-->00:47:08.325
this, uh, uh, section inside of
ntoskrnl dot exe that is just a
read-write – the name of the

00:47:08.325-->00:47:15.199
section is readwriteexe. Um, and
so the only thing that’s ever
really legitimately calling this

00:47:15.199-->00:47:21.405
portion of memory is a function
called kx unexpected interrupt.
Um, but uh, this is where

00:47:21.405-->00:47:28.279
EternalSynergy decides to store
the shellcode, um, is right
there. Um, so here’s some uh,

00:47:28.279-->00:47:35.052
uh, a good list of resources um,
for this stuff. I think, um,
sleepya’s, uh github repo is

00:47:35.052-->00:47:41.125
probably the best if you want to
look at this at the code level.
Um, and then Nick Lashole of

00:47:41.125-->00:47:47.598
MSRC did a sort of a similar
talk at Hitcon, um and then
there’s, there’s some more

00:47:47.598-->00:47:53.571
resources, um, Jenna Magius and
I’s uh, white paper from last
year. And then if you’re

00:47:53.571-->00:47:56.707
interested in the shadow
workers, there is more stuff on
the bottom there. Uh, just some

00:47:56.707-->00:48:01.645
archives. And I’ll also be at
DerbyCon doing a kind of part 2
for this. So, that’s it. Thank

00:48:09.754-->00:48:13.624
you. [applause]

