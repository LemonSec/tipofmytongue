00:00:00.000-->00:00:10.210
>>Without further ado, here are
the speakers on AAPT. >>Hi. If
something go wrong it’s because

00:00:10.210-->00:00:19.920
of the shot, right? Okay um I’m
Sergio De Los Santos I come from
Spain, the head of security and

00:00:19.920-->00:00:29.129
lab ElevenPaths which is las
telefonicas cyber security unit.
And >>I’m Sheila. And I work as

00:00:29.129-->00:00:36.637
security researcher as well, in
ElevenPaths, I’m 23 years old
and I came from Argentina.

00:00:36.637-->00:00:44.244
[Applause and whistles from
audience] Thanks. Thank you.
Well let’s start. Um in the

00:00:44.244-->00:00:48.582
world of studying techniques
determining the attacker
geographical locational is one

00:00:48.582-->00:00:56.757
of the most valuable data for
activation techniques. However
in some cases tracking a malware

00:00:56.757-->00:01:02.596
developer can turn into a very
difficult thing and researchers
start getting mad and even feels

00:01:02.596-->00:01:09.436
a little bit frustrated. That’s
why we are always paying
attention to new techniques that

00:01:09.436-->00:01:16.343
might help to track malware
developers uh reach their
potential or reaching of their

00:01:16.343-->00:01:21.481
malware campaign. In this
presentation we’ll give you some
Android. First talking about 2

00:01:21.481-->00:01:28.889
new techniques that we found to
track Android malware
developers. Um by heading the by

00:01:28.889-->00:01:34.728
getting the timezones off
them.The first thing has to do
with a bug inside the Android

00:01:34.728-->00:01:41.568
SDK which are in the bugshare.
These bugs may sometimes cause
disclosure of the computer where

00:01:41.568-->00:01:47.474
the developer have compiled the
malware. And the second
technique is related to uh

00:01:47.474-->00:01:55.015
calculation of creation times
between the certificate of the
APK and some files inside it. To

00:01:55.015-->00:02:02.022
our tower talk we’ll get deep
into these two new techniques
and finally we’ll talk about how

00:02:02.022-->00:02:08.862
we can do an accurate from the
time zone that we got to an uh
specific count. So let’s start

00:02:08.862-->00:02:20.040
talking about the Android bug.
When we download the Android SDK
it comes with a tool named AAPT.

00:02:20.040-->00:02:29.149
We can found this tool inside
the SDK folder and the build
tools APR version. And if we ran

00:02:29.149-->00:02:37.991
AAPT we can observe in the first
line that this is the Android
asset packaging tool. So we can

00:02:37.991-->00:02:45.632
use this firmware from command
line to add some files to an APK
dump the file see the

00:02:45.632-->00:02:51.738
information and then other
senior related to APK’s
management. Due to an APKs

00:02:51.738-->00:02:59.446
shares the PKCF standard every
file inside it has a date and
time of last modifier. However,

00:02:59.446-->00:03:06.720
when we use AAPT for adding some
files into an APK we noticed
something strange in this date

00:03:06.720-->00:03:14.227
and time fields. They are not
the real ones. Instead they are
right dates and time information

00:03:14.227-->00:03:21.935
we usually saw something like
zero one zero one eighty, an
hour, and zero zero. That three

00:03:21.935-->00:03:29.443
in the hour field caught our
attention because if we change
the timezone of the computer to

00:03:29.443-->00:03:36.583
for example GMT plus eight that
three turn into an eight and if
we change the timezone to GMT

00:03:36.583-->00:03:44.724
plus 4 the hour was 4. So what
the h**l is happening here? This
this a kind of GMT offset. Well

00:03:44.724-->00:03:51.832
after we noticed that we started
to analyze the source code of
AAPT. It is published on Google

00:03:51.832-->00:03:58.238
Git and inside the path of AAPT
there are several files that
compose the source code of this

00:03:58.238-->00:04:06.146
program. So we put our attention
in those files related to
zipping process. Inside the zip

00:04:06.146-->00:04:14.354
file dot C plus plus there is a
method named addCommon that does
invoke for every file that will

00:04:14.354-->00:04:21.828
be added to an APK. As we can
observe this method receive this
parameter the filename, the size

00:04:21.828-->00:04:30.403
and some other thing related to
the file being stored into an
APK. So analyzing the code of

00:04:30.403-->00:04:38.411
this method we observe that
there is a call to another
method named setModWen. Using a

00:04:38.411-->00:04:46.887
parameter the modWhen variable.
As we look for this variable we
can we find that it’s a time_t

00:04:46.887-->00:04:53.894
type and its neutralized to
zero. It should be used inside
the setModWen method so let’s

00:04:53.894-->00:05:01.401
check this code. setModWen is
located into the zip entry dot C
plus plus file of the source

00:05:01.401-->00:05:08.341
code of AAPT. There we have the
method and its parameter.
Remember that when is going to

00:05:08.341-->00:05:16.416
zero. And inside this method
there is another variable of
time_t type. Its name even and

00:05:16.416-->00:05:24.457
the value of even is the value
of when. So even is equal to
zero too. But the question here

00:05:24.457-->00:05:32.199
is is the even variable used for
anything at all? Well
immediately after the line start

00:05:32.199-->00:05:40.073
with some for even is used a
parameter for local time
function. PTM is time instructor

00:05:40.073-->00:05:46.479
well a local time will set and
result. And after that the
result is used for assign the

00:05:46.479-->00:05:55.855
last modified field for every
file that will be added to an
APK. So at this moment we have a

00:05:55.855-->00:06:02.762
problem in that file. In LT
local time function is receiving
as parameter even value that is

00:06:02.762-->00:06:10.971
zero. When the expected argument
for local time function is a
real time stamp. So let’s

00:06:10.971-->00:06:20.947
analyze it in runtime. Here we
are attached to AAPT and we have
run the debugger with parameters

00:06:20.947-->00:06:24.217
for writing a file. And we put a
rate point on the server routine
that we were analyzing in the

00:06:24.217-->00:06:31.524
source code. And at this moment
we can observe the even variable
with value zero being passed to

00:06:31.524-->00:06:38.665
local time function as an admin.
The result of this occur is the
one that we were seeing for. Uh

00:06:38.665-->00:06:45.171
time zone disclosure of the
computer. But what will happen
if we pass the local time

00:06:45.171-->00:06:51.611
function the expected argument
that means a real time stamp.
Well now we have altered the

00:06:51.611-->00:07:01.154
value of even put in a timestamp
of unix epoch as surprise the
date and time of last modified

00:07:01.154-->00:07:19.205
was the correct one. So let’s
show you a video demo with all
this in action. Ok the computer

00:07:19.205-->00:07:24.010
is seeing GMT plus three uh we
have ran the debugger with two
parameters uh parameters for

00:07:24.010-->00:07:30.850
adding two files. We put the
right one and we reach the right
code for the first file. But

00:07:30.850-->00:07:36.690
this time we won’t fix anything
just we will leave in the even
value to zero as normal

00:07:36.690-->00:07:49.302
execution. But for the second
file we will fix this file.
We’ll put a real timestamp unix

00:07:49.302-->00:08:07.454
epoch converting hexadecimal. We
are changing the value of even
from zero to the real timestamp.

00:08:07.454-->00:08:13.093
You continue the process and it
will finish so we can use now
AAPT for instructing the days of

00:08:13.093-->00:08:25.138
any APK so now we can see this
APK with the first file with
this part making the timezone

00:08:25.138-->00:08:36.349
disclosure and the second file
with this bug fixed showing the
right day and time information.

00:08:36.349-->00:08:44.491
Well at this moment we are
convinced that there is a bug
inside AAPT that why does this

00:08:44.491-->00:08:51.264
incing of timezone disclosure of
the computer? Well look at time
function makes a calculation to

00:08:51.264-->00:09:00.740
put the correct hour in the
hours field. It takes the the
unix epoch coming from the

00:09:00.740-->00:09:06.946
parameter that this you this is
real and makes a sum or
subtraction with the timestamp

00:09:06.946-->00:09:14.888
of the computer. For example, if
the timezone of the computer is
GMT plus three it make the unix

00:09:14.888-->00:09:21.694
epoch plus three hours. And if
the timezone is GMT minus three
it makes this subtraction, the

00:09:21.694-->00:09:27.033
unix epoch minus three hours.
With that local time function
get the guard tower in the local

00:09:27.033-->00:09:35.575
computer. But in AAPT where we
found this bug. Local time is
making a sum or subtraction over

00:09:35.575-->00:09:44.651
zero. So GMT plus three is just
zero plus three. That’s why we
will see the in the hour fields

00:09:44.651-->00:09:52.192
the three number. In the case of
GMT minus three it’s the
subtraction of zero minus three

00:09:52.192-->00:10:00.700
but this subtraction affects day
too. Now we’ll see December
thirty one of seventy nine and

00:10:00.700-->00:10:05.672
uh twenty one in the hour. That
twenty one is the result of the
subtraction of twenty four minus

00:10:05.672-->00:10:12.645
three. So those GMT opposites of
GMT minutes what they are might
look a little bit confused so

00:10:12.645-->00:10:20.587
for that we made an offset table
that we show you later. And
there’s a little detail when we

00:10:20.587-->00:10:29.062
use AAPT. Instead of seeing uh
December thirty uh thirty one of
seventy nine we see an eighty in

00:10:29.062-->00:10:35.802
the year field. This is because
of that correction factor the
method that we were analyzing in

00:10:35.802-->00:10:42.742
the source code there we have an
if we say which says that if the
year is less than eighty the

00:10:42.742-->00:10:52.785
year is eighty. So it’s a little
detail but let us know that we
are analyzing it correctly. So

00:10:52.785-->00:10:58.424
here you have the offset table.
In the case of GMT plus
something it’s very easy because

00:10:58.424-->00:11:05.131
it’s the same number. So for
example GMT plus five we’ll put
a five in the hour field. In the

00:11:05.131-->00:11:10.403
case of GMT minus something we
have to do the subtraction.
Twenty four minus the local time

00:11:10.403-->00:11:16.509
of the computer. For example
twenty four minus three for GMT
minus three that is twenty one

00:11:16.509-->00:11:20.747
and twenty one will be the
offset in the hours field.
>>What we have done here is

00:11:20.747-->00:11:28.955
mapping the GMT and that we
guess it is with the file date
in the APK itself so you can

00:11:28.955-->00:11:34.394
check the file and then get back
to the GMT and the local
timezone of the one that

00:11:34.394-->00:11:44.504
compiled it. >>After all, a good
question is should local time
return this? Well inside our

00:11:44.504-->00:11:51.010
documentations we can see the
localtime should return a null
in this case instead this

00:11:51.010-->00:12:02.221
information disclosure because
zero is not a valid argument. So
however we can see in the IDS

00:12:02.221-->00:12:07.527
screenshot the return of this
function to ensure that is local
time the one that is not

00:12:07.527-->00:12:14.734
handling the errors currently.
There in red we can see the GMT
of three in this case it was GMT

00:12:14.734-->00:12:21.608
plus three. You have to know
that this bug is present on
Windows, Linux, and OS Ten so

00:12:21.608-->00:12:29.048
Android developers eh using AAPT
will be linking their time zone
regardless the platform on the

00:12:29.048-->00:12:41.094
AAPT. >>Okay once we know a
technique ba-based on the bug
and AAPT next uh talk about

00:12:41.094-->00:12:45.665
another technique that has
nothing to do with the bug but
with the way attackers or or or

00:12:45.665-->00:12:56.676
creators of applications usually
work. As we have said APKs are
basically zip files and every

00:12:56.676-->00:13:03.549
zip file has a date inside, a
date an hour. They take it from
the last modified field in the

00:13:03.549-->00:13:13.059
local system of the user. And it
gets permanent eh permanently uh
inside the zip file. On the

00:13:13.059-->00:13:19.666
other hand an application APK
has to be signed by a
certificate. Most of the times

00:13:19.666-->00:13:27.807
the certificates are created uh
mm with no CA they’re self
signed so there’s no CA and you

00:13:27.807-->00:13:34.814
create it just uh a few minutes
before a few seconds before you
compile it or yeah or in other

00:13:34.814-->00:13:42.255
words you create this possible
certificate for signing this APK
you’re creating. Certificates

00:13:42.255-->00:13:52.532
are in ex dot 509 format. That
means that for the creation
creation time field in their own

00:13:52.532-->00:14:01.107
certificate they take the time
from the file system as well. So
if you compile it in this date

00:14:01.107-->00:14:09.115
uh the certificate will take the
date from the file system but
they do it in UTC time without

00:14:09.115-->00:14:18.357
no timezone at all. So let’s
think about it. If there’s a
signature file inside the APK

00:14:18.357-->00:14:25.765
files that’s the last ones to
get in the zip file the APK.
It’s the last one it takes the

00:14:25.765-->00:14:34.407
last modified field from the
local uh from the local system
or from the file system. And we

00:14:34.407-->00:14:43.182
have this certificate that if we
think or we assume that this
certificate is created basically

00:14:43.182-->00:14:51.824
in the same moment a few seconds
before the compilation you get
the time U-UTC the same time but

00:14:51.824-->00:15:00.133
with UTC. And in the files they
have timezone included. So in
these examples you can see that

00:15:00.133-->00:15:08.074
if you think the certificate has
been created fifteen seconds the
certificate has been created si

00:15:08.074-->00:15:13.813
si fifty seconds before the
compilation the dates have the
same hours the same minutes

00:15:13.813-->00:15:24.724
basically a few seconds. Uh here
you can do the math between both
uh dates and times and you will

00:15:24.724-->00:15:34.834
have a possible GMT or local
local uh or timezone. For
example here its GMT minus

00:15:34.834-->00:15:43.309
seven. Let’s have another
example. Imagine that this
certificate has been created

00:15:43.309-->00:15:52.185
four seconds before the
compilation so the last file in
the APK gets the date on the

00:15:52.185-->00:15:59.325
left and the certificate has the
the date on the on the right.
You have UTC on the side and the

00:15:59.325-->00:16:08.367
local time with the timezone of
the person on the left side. So
that means that this person is

00:16:08.367-->00:16:15.875
maybe in GMT plus one. So in
action assuming minutes and
seconds are close in time when

00:16:15.875-->00:16:22.715
you create the certificate and
you compile the application uh
and the certificates and and the

00:16:22.715-->00:16:29.422
a-application are created
together we have information
enough to then use the GMT or

00:16:29.422-->00:16:37.230
timezone of the person compiling
because just uh we can do the
math between the UTC and the

00:16:37.230-->00:16:47.607
certificate and the time in the
file that was last created when
you compiled. For example here

00:16:47.607-->00:16:59.452
it would be 8 hours or whatever.
So it works we have created a
little python tool that checks

00:16:59.452-->00:17:04.991
for one hand checks the
certificate creation date in UTC
time and the other hand it

00:17:04.991-->00:17:12.098
checks the signature file date.
If we assume they were created
at the same moment the

00:17:12.098-->00:17:18.004
developered timezone would be
UTC plus three because signature
file was created one second

00:17:18.004-->00:17:26.512
after the certificate. So
results seems quite accurate. Eh
we thought this is a fun example

00:17:26.512-->00:17:32.718
because in the email you can
check that it’s dot ER which is
eeri-area three yeah and this is

00:17:32.718-->00:17:37.390
UTC plus three but this is
basically a coincidence and as
you can check in the certificate

00:17:37.390-->00:17:45.298
it seems to come from Russia
which is UTC plus three as well.
So now we have these two

00:17:45.298-->00:17:55.207
techniques to check uh by a book
by a bugging AAPT and this
certificate technique to know

00:17:55.207-->00:18:00.079
the GMT or timezone of the
person compiling the
applications. Let’s do some

00:18:00.079-->00:18:09.555
statistics. We have a million uh
ten million application uh set
or database that we have to get

00:18:09.555-->00:18:17.530
for both techniques. The
timezone leakage by AAPT bug we
have two thousand or less APKs

00:18:17.530-->00:18:23.202
with this. And the timezone
leakage by date times and
certificate we have almost half

00:18:23.202-->00:18:30.843
a million of them in our
database. As you can check as
you can imagine many of them

00:18:30.843-->00:18:38.784
will share results. So for
example with UTC plus seven we
have like three thousand eh

00:18:38.784-->00:18:46.625
applications that has both
problems and they leak the same
UTC plus seven so this confirmed

00:18:46.625-->00:18:55.067
more or less these techniques
and compliment each other. Once
we had all this information what

00:18:55.067-->00:19:01.374
we did was take in a thousand
hundred a-a thousand samples
with each leak. A thousand of

00:19:01.374-->00:19:08.781
UTC plus zero, a thousand of UTC
plus one, with the AAPT timezone
disclosure bug. Some of them

00:19:08.781-->00:19:15.788
were we didn't have enough for
example UTC minus seven we only
had six of them because this is

00:19:15.788-->00:19:20.159
America Samoa in the middle of
the Pacific and we think there
are not too many applications

00:19:20.159-->00:19:27.566
created there. So we check that
against the different anti
viruses. One two plus three anti

00:19:27.566-->00:19:34.607
viruses and check how many
malwares was there. This is what
we got. We got that GMT plus

00:19:34.607-->00:19:43.115
four which is Russian uh uh not
Russia is usually plus three but
a part of Russia is plus four.

00:19:43.115-->00:19:53.325
GMT plus eight plus eight which
is China and GMT minus seven
which is uh USA west coast. Eh

00:19:53.325-->00:19:59.398
GMT plus eleven and GMT minus
eight are not good enough
because we didn’t have enough

00:19:59.398-->00:20:07.006
samples. We did the same again
with the file certificate date
times disclosure technique. We

00:20:07.006-->00:20:14.947
took uh a thousand samples with
every uh uh timezone different
time zones that a thousand of

00:20:14.947-->00:20:20.986
them and checked against
different endings with
antiviruses. And this is what we

00:20:20.986-->00:20:28.060
got. We got that GMT plus five,
GMT plus eight, and GMTs minus
six were the ones with more

00:20:28.060-->00:20:38.037
malware in there. If you uh why
this little difference with with
the other uh technique here?

00:20:38.037-->00:20:46.979
Well we think this is because
the DST time, daylight saving
time, that this technique is uh

00:20:46.979-->00:20:54.553
relies on the local time of the
compute of the computer so it
might change. But if you think

00:20:54.553-->00:21:02.828
about it GMT plus eight which is
China and do not use DST changes
remains the same. So we can

00:21:02.828-->00:21:09.401
conclude that eh we should have
things done this better. We
should have take into account

00:21:09.401-->00:21:16.842
the the the period of the year
where you change the DST ok. But
basically we can conclude is

00:21:16.842-->00:21:26.152
that Russia, which is GMT plus
four into plus three and five,
eh GMT plus eight which is China

00:21:26.152-->00:21:38.464
and west middle of USA or west
coast are the ones creating more
malware. Eh and e-e- with this

00:21:38.464-->00:21:44.069
uh with this technique they are
creating this possible
certificate as well you have to

00:21:44.069-->00:21:49.041
take this into account. They are
creating this uh possible
certificate. So this makes sense

00:21:49.041-->00:21:56.482
because maybe we think it’s just
a theory that the cloud is uh
ma-ma-many computers in the USA

00:21:56.482-->00:22:02.054
and the west coast and they
create certificates in there
it’s possible and that’s why we

00:22:02.054-->00:22:09.528
have so many malware in there.
We here the other way around. We
took all the malware here we had

00:22:09.528-->00:22:16.869
with these leakages and checked
for the UTC or GMT timezone. And
this is what we got. Again with

00:22:16.869-->00:22:21.941
one technique the file
certificate date times
technique. We got the UTC minus

00:22:21.941-->00:22:30.583
six and the UTC plus eight were
the ones with more malware. And
with the other technique the APK

00:22:30.583-->00:22:38.958
the timezone disclosure we have
basically the same UTC plus
eight and UTC plus four. And

00:22:38.958-->00:22:48.133
what is this useful for? Uh what
we did as well is check our
database, we have ten million of

00:22:48.133-->00:22:55.107
them, and we had got several
sets of a thousand applications.
And we have a rate of six

00:22:55.107-->00:23:03.949
percent of malware in there. And
we took a a set of a thousand
APK samples with these leakages

00:23:03.949-->00:23:12.558
or disclosures and compare each
other. And we concluded that the
chances for example with

00:23:12.558-->00:23:20.366
comparing our standard rate a
thousand applications with this
six percent of malware and a

00:23:20.366-->00:23:30.709
random set of applications with
UTC plus eight makes it six time
more likely to be malware than

00:23:30.709-->00:23:38.017
our standard rate you know what
that rate is. Let’s see some
some example with real life

00:23:38.017-->00:23:45.157
malware. For example this
deathring preloaded on some
telephones had this file

00:23:45.157-->00:23:53.866
certificate dating uh problem
that was leakaging the the
timezone and it and it was Korea

00:23:53.866-->00:24:00.906
UTC minus nine. And so the using
malware which had this which had
this AAPT timezone disclosure

00:24:00.906-->00:24:11.150
but but it was Korea as well.
This is a malware we found a few
years ago. It was a very

00:24:11.150-->00:24:18.257
interesting malware that use uh
once while it was infected it
took some users and passwords

00:24:18.257-->00:24:24.396
from the database of the
attacker preload the username
and password came through the

00:24:24.396-->00:24:29.835
came through the telephone or
was infected read history with
this telephone and email and

00:24:29.835-->00:24:38.444
everything in Google play got
the token back to the back to
the attacker and with this token

00:24:38.444-->00:24:44.783
the where eh associated with the
telephone he was able to give
five stars and download fake

00:24:44.783-->00:24:51.490
applications, fake users
released to real telephones uh
um voting and unloading fake

00:24:51.490-->00:24:58.797
applications just to get up high
in the in the Google Play store.
This called Shuabang. Well we

00:24:58.797-->00:25:09.074
found it um focusing on this
part GMT forward eight which is
China and some other things like

00:25:09.074-->00:25:16.215
connecting to a PHP command and
control uh having this get
account permissions and hiding

00:25:16.215-->00:25:24.857
behind wallpapers applications.
Focusing on that we were able to
find an and define these um

00:25:24.857-->00:25:30.863
malware and we alerted Google
Play and they remove it and it
was really quite nice to to

00:25:30.863-->00:25:39.638
research. Now some malware come
from China. Know we have from
example Hiddad that we took a

00:25:39.638-->00:25:46.445
few samples from them. We check
this uh malware had both
techniques you could eh check

00:25:46.445-->00:25:55.087
that with both techniques that
it came from GMT plus three
which is Russia again. And aside

00:25:55.087-->00:26:03.362
here you can guess in a way that
certificates are always created
about two or three minutes

00:26:03.362-->00:26:10.269
before the completion which
leads us to think they were like
automated. This possible

00:26:10.269-->00:26:16.842
certificate created in an
automated way coming from
Russia. >>Ok um with the

00:26:16.842-->00:26:22.815
technique that we were analyzing
probably we’ll guess the
timezone of the Android malware

00:26:22.815-->00:26:29.254
developer. Now we see quickly
how we can be accurate from the
timezone to one specific

00:26:29.254-->00:26:38.497
country. Inside an APK there are
some sites pretty common. One of
them are the RTF documents.

00:26:38.497-->00:26:45.170
Usually they are used for
agreements, agreements inside uh
Android applications. Uh related

00:26:45.170-->00:26:52.644
to this kind of file types we
had an inspiration some months
ago when Wannacry occurs because

00:26:52.644-->00:27:01.820
this ransomware shows messages
in multiple language using
several RTF documents. >>Eh it’s

00:27:01.820-->00:27:09.995
a funny thing, a a trick, with
Word, Office, and RTF files.
When you create an RTF file with

00:27:09.995-->00:27:21.073
Word Office you get inside the
RTF uh metadata. It’s called uh
slash def lang. This is your uh

00:27:21.073-->00:27:31.550
default language in your Word or
text editor. So, every one of us
has uh de uh default language in

00:27:31.550-->00:27:41.860
our Word. So leakages through
RTF files and maybe if you have
your uh it’s quite possible that

00:27:41.860-->00:27:50.168
your Word file has uh the final
languages is your native
language. So it leaks your maybe

00:27:50.168-->00:27:58.076
your native language to uh uh
any RTF files that you create
with Word. >>Yeah and we made

00:27:58.076-->00:28:03.415
our research for getting
information about WannaCry. And
among other things we checked

00:28:03.415-->00:28:09.988
those RTF documents for
metadata. And result we found
that Korean is the default

00:28:09.988-->00:28:19.598
language configured in the text
editor of Wannacry’s developer.
Well we have an example of an

00:28:19.598-->00:28:25.003
Android malware which among it’s
file there is some RTF document.
We have to know that either

00:28:25.003-->00:28:31.476
Android studio or others IDs
remove the metadata from the
media files added by the

00:28:31.476-->00:28:39.685
developer to an APK so we can
check this kind of of media file
to get some interesting

00:28:39.685-->00:28:46.558
information. In this case we
found that Arabic is set the
default language in the author’s

00:28:46.558-->00:28:54.333
text editor. There is a lot of
trick to accurate the country.
If we can get the strings types

00:28:54.333-->00:29:01.573
manually by the developer it’s
maybe helpful for knowing the
native language of her. We can

00:29:01.573-->00:29:08.113
use AAPT for instructing the
strings of finding APK but
there’s a problem because even

00:29:08.113-->00:29:14.386
if the APK is extremely simple
there will be a lot of strings
added automatically by the ID

00:29:14.386-->00:29:21.293
just for translations purposes.
So in the screenshot we can see
dozen of strings. All of them

00:29:21.293-->00:29:28.333
were added by the ID
automatically in a very very
simple APK. So we can do a

00:29:28.333-->00:29:35.340
little bit of magic using AAPT
for instructing all of the
resources filtering via strings

00:29:35.340-->00:29:40.812
using green together with red X.
A pretty nice command
[chuckles]. Analyzing the output

00:29:40.812-->00:29:48.120
of this command we find a way to
differentiate both strings added
automatically by the ID from

00:29:48.120-->00:29:55.293
those written by the developer.
Basically we are checking the
resene of the strings, removing

00:29:55.293-->00:30:01.333
those coming from resources
where strings of translation
are. After all, the only thing

00:30:01.333-->00:30:06.672
we have to do is to check what
could be the native language of
the developer just seeing the

00:30:06.672-->00:30:25.791
strings tie tied manually by
him. >>And we created a tool as
well which is our lang get. This

00:30:25.791-->00:30:32.397
is not the best sequence in the
world sorry. But you can drag
and drop an application and it

00:30:32.397-->00:30:39.304
will try to deduce the possible
GMT and check for another
technique to get the country and

00:30:39.304-->00:30:46.978
the languages. Uh the country is
basically sometime comes from uh
this techniques we have

00:30:46.978-->00:30:53.852
explained or maybe uh with the
certificate itself or maybe
analyzing the strings dot XML

00:30:53.852-->00:31:03.295
that we have showed or even
sometimes maybe from uh from the
the em TLD domains the dot

00:31:03.295-->00:31:08.500
whatever that the the
application has inside. So you
can deduce with this different

00:31:08.500-->00:31:16.241
techniques which is the GMT time
zone or or the or the language
the native language of the of

00:31:16.241-->00:31:22.414
the person. This tool takes all
this techniques together and
once you drag and drop eh

00:31:22.414-->00:31:30.322
whatever APK you will check um
uh different techniques to to
get in there. Even the RTF that

00:31:30.322-->00:31:39.297
we have just talk about. So hope
this tool will will be online
soon. The other one is already

00:31:39.297-->00:31:48.106
online. This one quite simple.
Co Says that it comes from comes
from Russia. Has some domains

00:31:48.106-->00:31:54.146
with TLDs and the the
certificate is the standard one
for the gooey so it’s not

00:31:54.146-->00:32:05.323
useful. So what are the
conclusions here is that we
presented different ways for not

00:32:05.323-->00:32:11.196
just leaking timezone but as
well as possibly detecting
automated malware creations

00:32:11.196-->00:32:17.202
because of these possible eh
certificates that are created a
few seconds or minutes before

00:32:17.202-->00:32:23.408
the compilation is done.
Possible better machine learning
features in detecting APK

00:32:23.408-->00:32:28.980
malware. Remember that we said
[indiscernible] said something
that could be useful once you

00:32:28.980-->00:32:35.587
create um um a ma a machine
learning uh algorithm it’s
useful to have uh neat

00:32:35.587-->00:32:42.794
fea-features to uh to have a
better understanding so I think
this is a pretty one for be a

00:32:42.794-->00:32:48.099
good one for for machine
learning and detecting malware,
the ones that are created with

00:32:48.099-->00:32:55.841
uh this possible certificates or
comes from one timezone or
another. And a tool for a qui a

00:32:55.841-->00:33:02.614
quick view of all this
information around APKs
metadata. Future future work as

00:33:02.614-->00:33:09.254
we said we said should be uh
should take into account the DST
so it’s more accurate these

00:33:09.254-->00:33:16.628
techniques. Um maybe have a
little more sample more than a
thousand samples of each um of

00:33:16.628-->00:33:26.471
each um disclosure technique or
whatever. And this is pretty
much all. Thank you if you have

00:33:26.471-->00:33:47.492
any questions. [applause]
[whistling] >>[indiscernible
yell from audience member[]

00:33:47.492-->00:33:59.237
[chuckles] No questions? There’s
one. Not too difficult please
[inaudible off-mic question from

00:33:59.237-->00:34:14.152
audience] IO, not with Word
path, and this type doesn’t
work. It just work with Word. We

00:34:14.152-->00:34:20.859
checked because it has default
language defined in there. For
example you get create an RTF

00:34:20.859-->00:34:26.665
file with Word but you don’t
have a um um um a language
taking into account that this

00:34:26.665-->00:34:34.372
language is the one you have
defined in your text editor to
um to the see text correction.

00:34:34.372-->00:34:50.055
So I don’t know any any other uh
office package, but with words
with Office Word it happens.

00:34:50.055-->00:34:54.826
Okay. No other questions. Thank
you. Hope to see you in some
other DefCon. [applause from

00:34:54.826-->00:00:00.000
audience]

