1
00:00:00,042 --> 00:00:06,042
>> Good afternoon, Def Con. How
is it going? (Applause) So this
is generating ROP payloads from

2
00:00:12,458 --> 00:00:18,458
numbers. So please join me in
welcoming Alexandre Moneger.
(Applause) >> Hello everyone.

3
00:00:22,292 --> 00:00:28,292
Thanks a lot for attending. So,
basically, today I'll be talking
about return programming and how

4
00:00:30,792 --> 00:00:36,792
to generate pay loads using
numbers. A little bit about me
first. I work for Cisco systems

5
00:00:40,333 --> 00:00:46,333
in the UK. I am a Security
Engineer in the security
business. Which has not got

6
00:00:48,917 --> 00:00:54,667
nothing to do with what I am
going to talk about today.
Personally I'm interested about

7
00:00:54,667 --> 00:01:00,792
bits and bytes and all that
stuff. And the usual disclaimer.
The research was done on my own

8
00:01:00,792 --> 00:01:06,792
time and they do not reflect the
opinions of our employer and are
mine. You can't hear me? Sorry.

9
00:01:11,292 --> 00:01:19,042
All right. Is that better? So,
basically, I'll go through a
brief rot overview. What is it?

10
00:01:19,042 --> 00:01:25,250
Why do we use it and why has it
kind of become essential today.
The automation basically of the

11
00:01:25,250 --> 00:01:31,250
ROP payload generation, why do
we want to do that or not and
what are the challenges with it?

12
00:01:33,542 --> 00:01:38,417
Then I'll go into a little bit
of sort of the core of the
subject which I call number

13
00:01:38,417 --> 00:01:46,167
stitching. Which is basically a
possibly new way to generate ROP
payloads from numbers instead of

14
00:01:46,167 --> 00:01:50,542
from strings. So I'll go
through, you know, the goal what
was I trying to achieve. You

15
00:01:50,542 --> 00:01:57,167
know, why I did it. How I found
the gadgets. And basically the
core of the problem which is the

16
00:01:57,167 --> 00:02:03,167
change problem which I'll get
back to later. Then I'll have a
quick chat about, you know, the

17
00:02:06,667 --> 00:02:12,667
pros, the cons, the tooling that
I'm releasing, and any future
work. Okay so I'll have a very

18
00:02:16,042 --> 00:02:21,625
brief introduction about ROP
just so that I'm sure that
everybody understands what it

19
00:02:21,625 --> 00:02:27,792
is. So, basically, you know,
before in the old days you could
just attack, you know, exploit a

20
00:02:27,792 --> 00:02:32,042
vulnerability using, you know,
just a bunch of shellcodes and
you could just execute it

21
00:02:32,042 --> 00:02:38,208
anywhere. Unfortunately, or
fortunate, nowadays you can't do
this anymore. Right. You can't

22
00:02:38,208 --> 00:02:44,792
execute shellcode and memory
just like that. So, you know,
historically we got to a point

23
00:02:44,792 --> 00:02:49,625
where we got to return our
programming. Which is basically
instead of executing stuff

24
00:02:49,625 --> 00:02:54,667
through shellcodes use the
target binary to execute code
for you. So this means that you

25
00:02:54,667 --> 00:02:59,708
are not executing code yourself.
You are asking your target
basically to do it for you. All

26
00:02:59,708 --> 00:03:05,708
right. So, basically, I'll just
come comment a bit on what I
wanted to achieve also. So,

27
00:03:14,917 --> 00:03:22,458
basically, what I wanted to
achieve was to only use gadgets
from the (inaudible). So I was I

28
00:03:22,458 --> 00:03:29,375
saying when you look for gadgets
and instructions you are going
to get your program to use them.

29
00:03:29,375 --> 00:03:36,875
So what I wanted to do is take
it a bit further and extracts it
more and basically be able to

30
00:03:36,875 --> 00:03:42,833
use the structures generating by
the parlor while it (inaudible)
to attack the vulnerability. So

31
00:03:42,833 --> 00:03:48,833
I'll try to generate the
payloads putting them in memory.
Coming back to my overview, so

32
00:03:57,333 --> 00:04:01,250
we know that we want to
basically reuse instructions
from the target binary in order

33
00:04:01,250 --> 00:04:07,250
to bypass ASLR and XOW. Why we
use ROP is we don't have a
choice. The memory protections

34
00:04:10,208 --> 00:04:15,083
have gotten much better. We
can't do without it. So we use
it. The level of complexity is

35
00:04:15,083 --> 00:04:20,458
much higher. If we could avoid
it, it would be nice. But we
can't. It maintains control

36
00:04:20,458 --> 00:04:27,875
using the stack pointer and not
the instruction pointer. I won't
go into details but basically

37
00:04:27,875 --> 00:04:35,667
this is how you maintain control
over the flow of the program.
And ROP is multi‑staged more or

38
00:04:35,667 --> 00:04:40,000
less by design. It's that you
are going to have a first stage
which is going to be using the

39
00:04:40,000 --> 00:04:45,500
instructions from your target
binary to generate a payload for
you. So that payload, you are

40
00:04:45,500 --> 00:04:50,875
going to put it on a custom
stack you are going to create
within the program. So your idea

41
00:04:50,875 --> 00:04:55,917
is, okay, let's take a tiny
piece of the program and put
some instructions there which

42
00:04:55,917 --> 00:05:03,708
I'm going to execute later. So
that's your stage zero. First
phase basically which is grab

43
00:05:03,708 --> 00:05:08,667
some stuff, put it in the memory
and when you finish doing that,
change the control flow and

44
00:05:08,667 --> 00:05:15,417
execute that. As I said, it's
more or less the only way around
today's OS protections. You

45
00:05:15,417 --> 00:05:21,625
know, if you look at all the IE
exploits and all that stuff
which happened in 2013 they all

46
00:05:21,625 --> 00:05:27,625
used ROP to evade all those
memory protections. So just a
bit of vocabulary. What is

47
00:05:29,875 --> 00:05:35,125
called a gadget basically is
just a useful instruction inside
the target binary. So it's going

48
00:05:35,125 --> 00:05:40,417
be a very small piece of
assembly with a return
instruction at the end. So that

49
00:05:40,417 --> 00:05:47,167
is what you are going to call to
execute it. How do you find them
basically is that you go over

50
00:05:47,167 --> 00:05:52,500
your binary, you look for every
return instruction which is ZXC
three and assemble backwards

51
00:05:52,500 --> 00:05:59,083
from that and that will give you
what you can work with. To do
that there are many good tools

52
00:05:59,083 --> 00:06:05,083
available ROP gadget which just
go over binary and give you what
gadgets you use to attack it.

53
00:06:07,875 --> 00:06:12,625
Obviously the number of gadgets
you can find in a binary is
dependent on the size of the

54
00:06:12,625 --> 00:06:19,167
binary. If it's huge you got a
lot of chance of finding a lot
of gadgets. If it's small you've

55
00:06:19,167 --> 00:06:25,167
got much less and it becomes
much harder. So once you have
done your stage zero, you know,

56
00:06:28,750 --> 00:06:34,042
you've built your fake frame,
your fake stack frame basically
in memory, you want to transfer

57
00:06:34,042 --> 00:06:37,583
control to that payload. Because
that's what you want to execute.
You want to get a shell or

58
00:06:37,583 --> 00:06:43,583
whatever you want. So shifting
control from the current control
flow into your stack frame is

59
00:06:46,542 --> 00:06:52,417
called stack pivoting,
basically. And it's a way of
re‑directing control flow so

60
00:06:52,417 --> 00:06:58,417
that you basically get then your
code to run once you have built
it. So I'm going to talk about

61
00:07:01,542 --> 00:07:07,542
automating the payload
generation which is basically
how from a program can I take

62
00:07:11,625 --> 00:07:18,917
bits of memory and put them,
create that fake stack which I
will later execute. So this is

63
00:07:18,917 --> 00:07:26,375
the classical approach of what
happens. Is that you find a
bunch of bytes in memory. So the

64
00:07:26,375 --> 00:07:30,000
bytes you are looking for
obviously are shellcode bytes.
So you got a shellcode you are

65
00:07:30,000 --> 00:07:35,250
going to start from or something
you want to achieve a bunch of
functions you want to call and

66
00:07:35,250 --> 00:07:40,583
you are going to look for those
bytes in memory and copy them to
a stack you control. To achieve

67
00:07:40,583 --> 00:07:46,583
that you are going to look for
some particular gadgets which is
a move gadget. So you are going

68
00:07:49,000 --> 00:07:53,958
to try to move something from a
resistor you control to a zone
and memory you control. Or you

69
00:07:53,958 --> 00:07:59,958
can use a bunch of functions if
they are exported by the target
binary which is not always the

70
00:08:02,542 --> 00:08:08,000
case. So you've got a bunch of
potential problems in this. It's
that you're counting basically

71
00:08:08,000 --> 00:08:13,667
on the availability of a
new gadget. In real world you
have generally got it. So in big

72
00:08:13,667 --> 00:08:20,542
programs it's not a program. It
can require some referencing
which I won't speak too much

73
00:08:20,542 --> 00:08:27,583
about but that's if you want to
get basically your ‑‑ call up a
particular function and also you

74
00:08:27,583 --> 00:08:31,833
are expecting some bytes to be
available in memory. Typical in
shellcode you look for your

75
00:08:31,833 --> 00:08:37,292
interrupt number and you are
expecting that number to be in
memory because otherwise you not

76
00:08:37,292 --> 00:08:42,167
going to be able to build your
shellcode. If that number is not
there it generally requires

77
00:08:42,167 --> 00:08:48,167
manual work to get the missing
byte. If we look at a shellcode
here which I took, basically you

78
00:08:51,625 --> 00:08:57,500
can see if I look for, you know,
the byte 7368, you know, I can
find them in the program so

79
00:08:57,500 --> 00:09:01,625
that's nice. I can find those
two bytes which, you know, are
part of my shellcode and I'm

80
00:09:01,625 --> 00:09:07,625
going to be able to use them. If
I look for something different,
basically, for example, 682 F I

81
00:09:10,042 --> 00:09:13,625
don't find that in the program
right. So that means I am going
to have to do some manual work,

82
00:09:13,625 --> 00:09:19,625
manipulating some bytes to get
that. So back to the gadget.
Very small binary do not tend to

83
00:09:23,042 --> 00:09:30,250
have many mood gadgets. So it
mean that's the automation of
the pellet is complicated. And

84
00:09:30,250 --> 00:09:36,208
in the case of this particular
gadget I'm showing, you've got a
problem sometimes with nail

85
00:09:36,208 --> 00:09:42,208
bytes and basically it also
needs extra work to get rid of
it. Okay so here I'm going to

86
00:09:45,083 --> 00:09:51,917
introduce number stitching which
is basically I was asking myself
a question, is it possible to

87
00:09:51,917 --> 00:09:58,417
exploit a halo world type
vulnerability with most memory
protections enabled? I went

88
00:09:58,417 --> 00:10:05,375
stack canaries and all that.
Basically, you know, a gross
programming mistake. You copy,

89
00:10:05,375 --> 00:10:08,708
you know, a user supplied
argument with string copy and
you get a (inaudible) or

90
00:10:08,708 --> 00:10:14,042
something like that. Is it
exploitable with everything
enabled? Also, I was wondering

91
00:10:14,042 --> 00:10:20,042
can I exploit this independently
of what the program does. Using
only the come parlor or

92
00:10:23,375 --> 00:10:29,375
(inaudible). So, in other words,
it's like is it possible to not
rely at all on the target binary

93
00:10:31,958 --> 00:10:38,667
to generate a ROP payload. So
I'll go through it, like, how a
program is built and, you know,

94
00:10:38,667 --> 00:10:46,458
how it's linked and what
happens. And we'll see what we
get. So, basically, all the

95
00:10:46,458 --> 00:10:51,750
following of this is going to be
based on the gadgets I have been
able to find here. Basically all

96
00:10:51,750 --> 00:10:58,417
the other stuff was done due to
the gadgets which were made
available to me. So, if you just

97
00:10:58,417 --> 00:11:05,375
take a hello world and compile
it so what happens. Right. If
you look at what your program

98
00:11:05,375 --> 00:11:08,958
actually contains you see
there's a whole bunch of other f
unctions which you did not

99
00:11:08,958 --> 00:11:16,042
intend to be there. You got the
start and (inaudible) and all
that stuff. So where does that

100
00:11:16,042 --> 00:11:22,042
come from and can you use that?
So if you look basically at link
time at what happens, the linker

101
00:11:24,792 --> 00:11:31,167
will call the SO. So you think
it is a dynamic library but it's
actually not. It is a script.

102
00:11:31,167 --> 00:11:38,000
And basically that script has
got a static library in it. So
meaning that when you comply a

103
00:11:38,000 --> 00:11:42,667
program against lip C you are
going to have most of your
functions dynamically linked but

104
00:11:42,667 --> 00:11:47,792
also have a subset of those
which are statically linked into
your ‑‑ statically linked into

105
00:11:47,792 --> 00:11:54,958
your binary. So, if you look at
that, there's quite a few
functions in there which you

106
00:11:54,958 --> 00:12:00,500
could possibly use, right. So
all this basically is if you use
it will be statically linked

107
00:12:00,500 --> 00:12:06,500
into your program. Meaning that,
you know, those gadgets will be
at fixed addresses. So the

108
00:12:10,208 --> 00:12:15,042
problem I had is that those
functions aren't always used,
they depend on various options

109
00:12:15,042 --> 00:12:22,500
and linking options. I just look
for gadget rhythm and I couldn't
find anything. So I think it's

110
00:12:22,500 --> 00:12:28,750
good to say what you weren't
able to achieve. So, basically,
looking for gadgets in that

111
00:12:28,750 --> 00:12:34,750
failed. So I went back to my
binary and said is there
anything else which is added

112
00:12:39,042 --> 00:12:46,042
which I could use? And so,
basically, I looked at the
binary and there's a bunch of

113
00:12:46,042 --> 00:12:53,000
functions which I added by GCC
in some cases. So they've got no
symbols attached to them. So

114
00:12:53,000 --> 00:12:58,250
it's kind of hard to figure out
what they do. But there's just a
bunch of anonymous functions

115
00:12:58,250 --> 00:13:03,458
which I inserted into your
program. If you look at the
disassembly of your program, you

116
00:13:03,458 --> 00:13:07,500
will see there's some functions
where there is no symbols
associated and they're just

117
00:13:07,500 --> 00:13:14,917
there basically. Those functions
seem to relate to profiling. And
so that is why they're there,

118
00:13:14,917 --> 00:13:19,500
basically. So what was
surprising to me is that
profiling seems to be enabled by

119
00:13:19,500 --> 00:13:26,208
default on some distributions.
And so this stuff is actually
statically linked into your

120
00:13:26,208 --> 00:13:30,292
program and all these little
tiny pieces of assembly are put
into your program without you

121
00:13:30,292 --> 00:13:37,667
knowing about it. So to check
what the default options are for
GCC you can look at GCC minus

122
00:13:37,667 --> 00:13:43,667
(inaudible) will dump basically
the list of come parlor options
done. You might find stuff in

123
00:13:45,958 --> 00:13:51,958
this. So, basically, this work
was done for GCC 4.5 which is
pretty old. Basically I look for

124
00:13:55,750 --> 00:14:03,208
gadgets inside the code that was
embedded by GCC into the target
binary. Based on that, I kind of

125
00:14:03,208 --> 00:14:09,208
disassembled those functions and
I end up with this stuff to work
with them so this basically is

126
00:14:11,750 --> 00:14:16,375
only generated by the com
parlor. It's not code which is
generated by the target

127
00:14:16,375 --> 00:14:23,875
application. So you can see that
I've got a bunch of stuff that I
get to work with. So the first

128
00:14:23,875 --> 00:14:29,250
one allows me to control EBX.
Put a random value in there and
control that. The other one

129
00:14:29,250 --> 00:14:35,375
allows me to pivot the stack
which I've achieved control and
I want to execute my shock code

130
00:14:35,375 --> 00:14:42,417
at the end. The two others which
are the meats of the torque is
that there is a right to memory.

131
00:14:42,417 --> 00:14:49,000
So, basically, through control
of EBX I can right the value
which is EAX. Meaning that the

132
00:14:49,000 --> 00:14:55,000
value I can dump it somewhere in
memory. And I've also got the
other way around. A right to the

133
00:14:57,625 --> 00:15:02,125
(inaudible) meaning that a value
my control in EBX I can grab a
value from memory and load that.

134
00:15:02,125 --> 00:15:09,500
That means in short, you know,
an attacker you control EBX and
that's about it, right. So you

135
00:15:09,500 --> 00:15:15,500
have to find a way to achieve
control of EAX also. Okay so
this ‑‑ so, basically, the

136
00:15:21,875 --> 00:15:26,250
further part of the talk will
just focus on those two
instructions, those two gadgets.

137
00:15:26,250 --> 00:15:32,250
And basically how I used them in
order to achieve execution. So,
basically, we've got a useful

138
00:15:36,500 --> 00:15:42,917
gadget here which is add memory
to a (inaudible). I removed the
trailing stuff and all that

139
00:15:42,917 --> 00:15:48,917
because it's not necessary. So
you control EBX. So it means you
can grab a value memory and load

140
00:15:51,208 --> 00:15:57,917
it. Is that useful? Well you
don't control what's in memory
necessarily. So, you know,

141
00:15:57,917 --> 00:16:02,917
it's ‑‑ at first I didn't think
it could be potentially useful
but actually it is. I'll come

142
00:16:02,917 --> 00:16:09,833
back to this later. So now the
reverse. Basically once I've got
a value I'm interested in the

143
00:16:09,833 --> 00:16:17,042
resistor I can dump it into
memory right. This allows me to
create my fake stack break. So

144
00:16:17,042 --> 00:16:23,042
assuming that I control EAX I
can build a fake stack frame,
you know, at the addresses

145
00:16:25,083 --> 00:16:31,083
pointed to by EBX. So that means
that by chaining these cores I
can, you know, copy my

146
00:16:34,875 --> 00:16:40,875
shellcodes into a frame I
control and then, you know,
trigger execution of it. So,

147
00:16:46,375 --> 00:16:51,708
basically, this is the more
general approach to ROP is that
you are going to choose a spot

148
00:16:51,708 --> 00:16:57,250
in memory where you can build
your stack. So, you know, the
memory properties you want is

149
00:16:57,250 --> 00:17:00,625
that obviously you can write to
it. With today's memory
protection you can either

150
00:17:00,625 --> 00:17:06,042
execute or you can write. So you
are going to choose a zone where
you can write. You should look

151
00:17:06,042 --> 00:17:10,417
at the previous instruction it
was an add instruction. So I
have to find what is called kind

152
00:17:10,417 --> 00:17:16,417
of a code cave which is a zone
where ‑‑ which is just padded
with bytes. So just a bunch of

153
00:17:16,417 --> 00:17:22,417
zeroes. When I add it I just add
to zero. So, you know, it avoids
further complication. And then

154
00:17:26,042 --> 00:17:32,875
you choose the shellcode you
want. To just pick a shellcode,
any one you want, set the ID for

155
00:17:32,875 --> 00:17:38,875
whatever you want and basically
just hope that you are going
to ‑‑ to copy that shellcode to

156
00:17:41,167 --> 00:17:47,167
a frame you control and then
execute it. So now the unusual
approach I'd say to do this is

157
00:17:50,625 --> 00:17:57,875
that I chose to deal ‑‑ since I
had to deal with arithmetic
operations much as add I chose

158
00:17:57,875 --> 00:18:03,792
to actually see the shellcode
not as a string but as a number.
So, basically, if I cut it into

159
00:18:03,792 --> 00:18:11,125
small pieces of four bytes on
32 bits and eight bits on 64 I
just cut it in four chunk and

160
00:18:11,125 --> 00:18:17,125
basically interpret each chunk.
That just says basically take a
string and it is actually a

161
00:18:20,125 --> 00:18:27,958
number. So, if you keep track of
each of the index of each chunk
you know basically which index

162
00:18:27,958 --> 00:18:33,375
your number is and what you want
to do is since you are going to
always be adding you want them

163
00:18:33,375 --> 00:18:38,625
to be ordered because you always
want to go from smaller to
bigger. So, basically, you just

164
00:18:38,625 --> 00:18:45,875
order them. You take your
shellcodes, cut into little bits
as numbers, and then basically

165
00:18:45,875 --> 00:18:51,208
you keep track of their position
and you reorder them from
smallest to biggest, right. And

166
00:18:51,208 --> 00:18:55,542
then once you have done that you
compute the difference between
each chunk. So that will give

167
00:18:55,542 --> 00:19:01,708
you basically Deltas between
your pieces of shellcodes and it
will keep your shellcodes

168
00:19:01,708 --> 00:19:06,792
basically (inaudible)
increasing. Just meaning each
time you add a value to your

169
00:19:06,792 --> 00:19:12,792
resistor it's going to always go
up. So what this looks like if I
take this example. At the top

170
00:19:16,167 --> 00:19:24,167
you've got a shellcode. Just a
string of text. If you take it
as a number and reorder it, you

171
00:19:24,167 --> 00:19:27,542
get to line two basically. So,
if you see the end of the
shellcode has the shift back to

172
00:19:27,542 --> 00:19:32,583
the front and I've ordered all
that together. All right so
they're ordered in increasing

173
00:19:32,583 --> 00:19:37,708
number. If you take the
difference between each
basically you get small Deltas.

174
00:19:37,708 --> 00:19:43,708
So you see basically at the last
line that position three of your
initial shellcode is now

175
00:19:43,708 --> 00:19:49,708
position one. Position two is
actually two minus three and
it's at position two and

176
00:19:55,458 --> 00:20:01,458
et cetera. So your shellcode is
now represented as increasing
Deltas. So, if you add ‑‑ if you

177
00:20:04,000 --> 00:20:07,875
take your initial value and add
the Delta you find back the
value of your shellcode. If you

178
00:20:07,875 --> 00:20:11,958
do that again you find the next
value of your shellcode. Do it
again and the next value. Once

179
00:20:11,958 --> 00:20:19,083
you have reach Thad value you
want to dump it to your fake
stack but you want to dump it in

180
00:20:19,083 --> 00:20:25,000
a way that you remember at which
position it was initially right.
Otherwise you are going to have

181
00:20:25,000 --> 00:20:30,833
the wrong spot. Once you do that
you just repeat, repeat, repeat
then eventually you've copied

182
00:20:30,833 --> 00:20:36,833
what you want into a zone of
memory. So as an example say you
want to copy the number 010234

183
00:20:39,958 --> 00:20:47,458
into memory. So you find that
number in memory. So for the
timing I am just assuming it's

184
00:20:47,458 --> 00:20:54,292
there. I'll speak later what
happens if it's not. You will
see the number there is in

185
00:20:54,292 --> 00:21:00,583
memory and you know the address
of that and basically you copy
that into EAX. So you have

186
00:21:00,583 --> 00:21:08,417
achieved loading a value into a
register for memory right. So
that's kind of easy. Now you've

187
00:21:08,417 --> 00:21:13,042
got the value you want of your
shellcode so you want to dump it
on to your fake stack frame. If

188
00:21:13,042 --> 00:21:17,208
you look at that, that guy was
actually at position three. So
you actually drop it on the

189
00:21:17,208 --> 00:21:22,500
stack at the right position. And
now you are going to look for
the next number which is, you

190
00:21:22,500 --> 00:21:28,500
know, the Delta which is in this
case 040404. So you assume that
also is in memory. You take it

191
00:21:30,667 --> 00:21:36,000
and sum it and get back to the
same value and you dump it. And
you do that over and over again.

192
00:21:36,000 --> 00:21:40,833
And in the end basically you
have achieved building a
shellcode from a bunch of

193
00:21:40,833 --> 00:21:46,833
numbers that you found out in
memory. So now it comes to the
problem of how easy is it to

194
00:21:49,333 --> 00:21:56,875
find shellcode numbers in
memories. Because basically if
you take your shellcode and look

195
00:21:56,875 --> 00:22:02,917
at it as a bunch of numbers,
it's actually pretty high
numbers, right. It's going to

196
00:22:02,917 --> 00:22:08,917
be ‑‑ if you look at the example
I put there 683199 if you take
string and, you know,

197
00:22:11,750 --> 00:22:18,125
(inaudible) it actually ends up
at 668766 which is a high or
negative number. But we're

198
00:22:18,125 --> 00:22:24,125
relying on the fact that will be
in memory and we can copy it.
What happens if it's not? So

199
00:22:30,667 --> 00:22:38,625
here basically the next part is
just, all right, I've got that
value, well I'm hoping for that

200
00:22:38,625 --> 00:22:44,625
value to be memory, but it's
not, what can I do and how can I
build it. So, basically, the

201
00:22:47,583 --> 00:22:54,292
answer is that it's not very
easy to find big numbers in
memory. They're not ‑‑ so I had

202
00:22:54,292 --> 00:23:00,292
to look at a bunch of programs
and I saw that they're basically
not really there. So here I put

203
00:23:02,958 --> 00:23:10,333
a small example of looking for,
you know, 01020304 in GDB and it
just doesn't yield anything. If

204
00:23:10,333 --> 00:23:16,000
you look at multiple programs
and search for those numbers,
they're not really there. So I

205
00:23:16,000 --> 00:23:22,000
have to find basically a
different approach. So the
approach was ‑‑ my idea was that

206
00:23:25,708 --> 00:23:29,042
if I can basically scan memory
for numbers and if I can find a
way to add them together to end

207
00:23:29,042 --> 00:23:33,792
up the chunk value then I'm
fine, right. So by definition
memory, you know, has got a

208
00:23:33,792 --> 00:23:39,792
crazy number of numbers in
there, right. If you look at
individual numbers, it's got

209
00:23:43,333 --> 00:23:49,333
heaps in there. The approach is
basically take a file, take its
read only segment and basically

210
00:23:55,208 --> 00:24:01,250
just scan it for numbers, right.
So just, you know, look at the
beginning of it, see it as a

211
00:24:01,250 --> 00:24:04,958
number, shift it by one byte,
see it as number and shift it by
one byte and see it as another

212
00:24:04,958 --> 00:24:10,958
number. So you scan all that
segment just looking for a bunch
of numbers, right. So where I

213
00:24:14,250 --> 00:24:18,917
decided to look for was
basically in the read only
segment. Because obviously you

214
00:24:18,917 --> 00:24:24,917
don't want those numbers to
change at run time. Here they
come. (Applause) So, basically,

215
00:24:34,542 --> 00:24:39,583
I looked inside the segments
which were read only. So that
basically I knew that at run

216
00:24:39,583 --> 00:24:44,708
time those numbers would not
change at all. And exclude all
the read/write segments

217
00:24:44,708 --> 00:24:51,000
basically which we're going
change. Basically if you don't
have position in codes ‑‑ thank

218
00:24:51,000 --> 00:24:57,000
you very much. >> Show some love
for our first time speaker at
Def Con! (Cheering) (Applause)

219
00:25:02,458 --> 00:25:08,458
>> Thank you very much. >>
Cheers. >> Thank you very much.
>> What do you guys think of his

220
00:25:14,875 --> 00:25:20,875
graphics? (Laughter). >> I'm
sorry that was just (inaudible).
>> That's all right. So,

221
00:25:24,042 --> 00:25:32,042
basically, the read only segment
to find your numbers. So what
you do is scan that read only

222
00:25:32,042 --> 00:25:37,875
segment look for the numbers,
you know, shifting by one byte
each time and keep track of

223
00:25:37,875 --> 00:25:43,083
their addresses, right. And so
what you end up is with a whole
bunch of numbers and the problem

224
00:25:43,083 --> 00:25:47,833
seems pretty simple is that how
to add up these random bunch of
numbers to find the chunk I

225
00:25:47,833 --> 00:25:53,542
want, right. So all you are
looking for is finding the best
combination of numbers which add

226
00:25:53,542 --> 00:26:00,375
up to a chunk. So this problem
seems pretty simple because, you
know, for human we do it all the

227
00:26:00,375 --> 00:26:06,000
time. But for a computer it's
pretty crap. It's basically
called the corn change problem.

228
00:26:06,000 --> 00:26:12,000
It took me awhile to figure out
it was what I was looking for.
The example is you buy an item

229
00:26:14,333 --> 00:26:20,333
at 425 euros and you get a five
euro note. And what's the most
efficient way to return change

230
00:26:24,708 --> 00:26:29,375
on that? You know, that's
something we know how to do
pretty easy. You know, in Europe

231
00:26:29,375 --> 00:26:37,000
we'd give back a $0.50 coin,
$0.20 coin and $0.05 coin. To
basically that's the coin change

232
00:26:37,000 --> 00:26:42,458
problem is what's the most
efficient way of giving money
back basically. So, basically,

233
00:26:42,458 --> 00:26:50,333
if you look at this problem in
dollars the answer is different
right. You are looking for same

234
00:26:50,333 --> 00:26:56,042
thing. $0.75. So, basically, in
the U.S. you would give half a
dollar and a quarter. To you see

235
00:26:56,042 --> 00:27:02,125
that here the solution basically
depends on your coin set. And so
it depends on the numbers you

236
00:27:02,125 --> 00:27:08,125
found in memory. So solving the
problem for human is pretty
simple. Solving the problem for

237
00:27:11,542 --> 00:27:19,083
a computer is a bit more
difficult. So, basically, you
can achieve an ideal solution to

238
00:27:19,083 --> 00:27:23,667
the problem by using dynamic
programming which basically will
give you the most efficient

239
00:27:23,667 --> 00:27:27,833
solution. So, you know, maybe
some of you guys have done that
in high school, you know, it's a

240
00:27:27,833 --> 00:27:33,250
pretty simple problem to solve
when you've got small numbers.
The problem is since I am

241
00:27:33,250 --> 00:27:37,458
dealing with pretty big numbers
is that dynamic programming
doesn't scale and it just kind

242
00:27:37,458 --> 00:27:43,000
of blows my memory. So I can't
get to scale it for massive
numbers yet. So I have to use a

243
00:27:43,000 --> 00:27:49,292
different approach. So I used an
approach called the greedy
approach which is just slightly

244
00:27:49,292 --> 00:27:55,250
different which basically
achieves the same thing but
won't give you the optimal

245
00:27:55,250 --> 00:28:01,042
solution. It will give you a
solution. So how it works is
that it's just simple. Just like

246
00:28:01,042 --> 00:28:05,833
you take the biggest coin which
fits in the interval and then
just add and add and add. One

247
00:28:05,833 --> 00:28:11,833
thing we're lucky with in memory
you've got many, many small
numbers. Number 1, two, three,

248
00:28:15,667 --> 00:28:20,375
four, five. All that is like
you've got bits of them in
there. So, basically, you always

249
00:28:20,375 --> 00:28:26,375
can achieve the greedy approach
which is kind of nice. But it's
sub optimal. So kind of back to

250
00:28:32,042 --> 00:28:38,875
the $0.75 problem looking, you
know, with ‑‑ so, you know,
trying to return $0.75 using the

251
00:28:38,875 --> 00:28:42,708
greedy approach basically you
just go down the list of the
coins and take the biggest one

252
00:28:42,708 --> 00:28:48,708
which fits. In this case 50, 20
and $0.05. So, basically, all my
tool does is that, you know, you

253
00:28:52,083 --> 00:28:56,292
give it a number in memory, it
will scan all memory and it will
try to find you the best

254
00:28:56,292 --> 00:29:02,292
solution for this. So,
basically, I wrote a tool called
Ropnum which is basically just

255
00:29:05,167 --> 00:29:10,708
trying to find a solution to the
coin change problem. So,
basically, you give it a number,

256
00:29:10,708 --> 00:29:16,875
you give it ‑‑ and it will
basically throw out all the
addresses where those numbers

257
00:29:16,875 --> 00:29:21,958
added together end up with a
chunk, right. So, if you look at
this back into the context of

258
00:29:21,958 --> 00:29:26,625
what I was talking before, here
you are basically looking to add
up a bunch of numbers in memory

259
00:29:26,625 --> 00:29:30,792
to reach a chunk of the
shellcode right. So this is what
Ropnum will do is give you

260
00:29:30,792 --> 00:29:36,792
basically that. It's got a bunch
of extra features. Ignore null
bytes, exclude numbers. It can

261
00:29:41,542 --> 00:29:46,917
print all memory pointing to a
number and zero. Et cetera. All
these features are not critical

262
00:29:46,917 --> 00:29:52,500
they just make the export that
easier because you can exclude
addresses which are not in your

263
00:29:52,500 --> 00:29:58,500
range. So an example usage is
basically find me the address of
numbers in the segment

264
00:30:02,250 --> 00:30:07,750
containing the text action, so
read only section, which added
together solve the contract

265
00:30:07,750 --> 00:30:14,333
problem. Here if you look it
will spit out at the lower part
it spits out five numbers

266
00:30:14,333 --> 00:30:19,208
basically. And if you add those
together, you get your target
number which is your shellcode

267
00:30:19,208 --> 00:30:25,208
chunk. So, if we look back at
this basically ‑‑ it will give
you the individual parts of the

268
00:30:28,667 --> 00:30:36,167
number which summed together
gets your shellcode. Here I just
showed if I re‑add all the

269
00:30:36,167 --> 00:30:43,417
values together I get my initial
value. Now coming back to my
gadget, it's that here by

270
00:30:43,417 --> 00:30:50,167
putting the value I want in EBX
and by adding repetitively I can
add get to the value of my

271
00:30:50,167 --> 00:30:56,167
(inaudible). So, if I put all
this together, so, basically, so
you take your shellcode, you cut

272
00:31:04,208 --> 00:31:11,625
it, order it and take the
Deltas. You look for numbers in
memory. And basically you add

273
00:31:11,625 --> 00:31:17,167
them together until they reach
the value of a chunk. Here it
means you have achieved the

274
00:31:17,167 --> 00:31:23,167
value of the shellcode. Once
that chunk is reached you
basically just dump it on to a

275
00:31:23,167 --> 00:31:28,708
stack frame you control. And you
repeat until the shellcode is
complete. And in the end you

276
00:31:28,708 --> 00:31:35,167
just transfer control over to
your shellcode. So I wrote a
tool also which automates all

277
00:31:35,167 --> 00:31:42,000
this process basically where you
just give it a shellcode and it
will spit out some Python code

278
00:31:42,000 --> 00:31:45,417
to generate your export. So you
give it a shellcode, anything
you want, you give it a frame

279
00:31:45,417 --> 00:31:51,417
address, so where you want to
copy your data too which will
generally be the data section.

280
00:31:57,542 --> 00:32:01,750
It takes care of all the boring
details, right, which make your
life hell. It will spit out a

281
00:32:01,750 --> 00:32:07,750
bunch of Python codes which
generate the payload. So if you
are familiar with rock gadget

282
00:32:10,708 --> 00:32:16,708
and all that stuff, it does
something pretty similar to
that. Now what it does also is

283
00:32:16,708 --> 00:32:21,208
that, you know, for the timing
we've copied our payload to a
fake stack we thought but that

284
00:32:21,208 --> 00:32:27,208
stack is read/write. So we'll
add a small and protect read
write stub frame before the

285
00:32:31,375 --> 00:32:37,208
payload. So what it does is
basically it will allow your ‑‑
to change the memory permissions

286
00:32:37,208 --> 00:32:42,417
at run time so that your
shellcode can run. And so it's
got a bunch of additional

287
00:32:42,417 --> 00:32:48,083
functions like it can start
with, you know, an arbitrary EX
value and look up numbers in

288
00:32:48,083 --> 00:32:55,542
sections and segments depending
on what you want to do and all
that kind of stuff. So a bit

289
00:32:55,542 --> 00:33:00,458
more on why you need and protect
stub. So you have copied your
shellcode into a zonal memory

290
00:33:00,458 --> 00:33:07,042
which is RW. So, if you return
execution to that it's not going
be able to execute right. You

291
00:33:07,042 --> 00:33:11,958
are just going to get a fault
from your processor because the
memory permissions are wrong. So

292
00:33:11,958 --> 00:33:17,750
you need to make that page kind
of read write execute at run
time. This is where it clicks

293
00:33:17,750 --> 00:33:25,250
in. It's just standard function
which allows you to change
memory permissions at one time.

294
00:33:25,250 --> 00:33:27,917
So, basically, I just added
small stub in the front of that
and once that has executed it

295
00:33:27,917 --> 00:33:33,917
will jump back into your
shellcode. So an example usage
is basically, you know, to copy

296
00:33:40,375 --> 00:33:46,875
a shellcode to a fake located in
the data section putting it in
protect frame and looking up

297
00:33:46,875 --> 00:33:51,875
segments in the RO segment in a
binary you end up basically with
this. And so all this basically

298
00:33:51,875 --> 00:33:57,875
will spit you out a bunch of
Python codes which will just
once run will basically generate

299
00:34:03,875 --> 00:34:09,875
your shellcode. So I didn't put
the output on the slides because
it's pretty verbose and just a

300
00:34:12,542 --> 00:34:17,833
bunch of codes which isn't very
interesting. I put it on the CD
though and I've got an example

301
00:34:17,833 --> 00:34:25,542
on gighub if you want to have a
look at it. So, if we have a
look at GDB and what's happening

302
00:34:25,542 --> 00:34:30,667
inside GDB basically you will
see that I put the values in
yellow. The values which have

303
00:34:30,667 --> 00:34:36,958
basically been copied. If you
look at the values the first ten
X seven is read, write execute.

304
00:34:36,958 --> 00:34:42,958
So, basically, that one is
written, you know, at its proper
index. The next one is 0X08

305
00:34:46,292 --> 00:34:51,042
which is the number and you will
see that guy is written
completely at the end. This kind

306
00:34:51,042 --> 00:34:58,083
of shows, you know, the tracking
of the index and, you know,
where stuff has to go to rebuild

307
00:34:58,083 --> 00:35:04,083
your shellcode. So then I write
0X1000 which is the next biggest
number on the shellcode and it

308
00:35:06,125 --> 00:35:11,542
will write it back, you know, at
a different index, et cetera,
et cetera. So, if you continue

309
00:35:11,542 --> 00:35:19,333
that, you know, execution ten
times just to see it go faster,
you will see that there's a

310
00:35:19,333 --> 00:35:25,208
bunch of missing zones in orange
basically which will be filled
in later. So it's just ‑‑ this

311
00:35:25,208 --> 00:35:32,000
is just to show the shellcode is
out of order. So the end
shellcode is basically the

312
00:35:32,000 --> 00:35:38,000
shellcode is complete in memory
with the RWE and protect stub
just before it. So there's a

313
00:35:43,875 --> 00:35:51,125
bunch of pros and cons to this
technique. I don't know, I was
wondering about this and it's

314
00:35:51,125 --> 00:35:57,000
got a real use case scenario.
It's just something I wondered
with and I found it nice but I

315
00:35:57,000 --> 00:36:01,917
don't know if it's useful in
real life. It's got a bunch of
pros that it can encode any

316
00:36:01,917 --> 00:36:08,333
shellcode. All you are dealing
with is addresses right. You
never actually look for value.

317
00:36:08,333 --> 00:36:14,333
You never pop values in. Just
addresses. The lower two bytes
of your address are controls

318
00:36:18,625 --> 00:36:25,500
basically. So you can exclude
those values if you don't want
them. Obviously the initial goal

319
00:36:25,500 --> 00:36:32,625
is that you are not affected by
X and R or X and W. So,
basically, it will allow you to

320
00:36:32,625 --> 00:36:38,292
bypass all those memory
protection. The cons basically
is that the payloads are fairly

321
00:36:38,292 --> 00:36:43,375
large right because you're
generating ‑‑ you are adding,
you know, multiple values,

322
00:36:43,375 --> 00:36:50,667
right, to each value of a chunk.
So up to five values together.
So that requires quite a bit of

323
00:36:50,667 --> 00:36:56,125
iterations to get there. What
that means is those iterations
transform into a code link

324
00:36:56,125 --> 00:37:01,292
basically so your payload grows.
So your stage zero can get
pretty big. So that's a pretty

325
00:37:01,292 --> 00:37:07,292
big con. So the further usage to
this is that let's imagine that,
you know, here we were looking

326
00:37:11,000 --> 00:37:18,542
at EX. I am still looking at the
specific case of GCC4.4.5. Is
that I achieve control of EAX

327
00:37:18,542 --> 00:37:24,750
through this technique.
Basically one thing I had is
that sometimes EAX, the initial

328
00:37:24,750 --> 00:37:30,500
value you've got in there
changes depending on, you know,
your user input data. So one

329
00:37:30,500 --> 00:37:35,333
nice trick that is if you
control EAX is that you can more
or less get a value you want in

330
00:37:35,333 --> 00:37:41,333
to there through doing just a
random function call in the PLT.
And since, you know, in the

331
00:37:43,958 --> 00:37:49,958
Linux AVI EAX holds the return
value of a function call. So if
you do random function call and

332
00:37:49,958 --> 00:37:56,958
make it fail or succeed or
whatever you can kind of control
the initial value you've got in

333
00:37:56,958 --> 00:38:02,958
there. So now I tried to take an
approach to shrink the size of
stage zero. So one approach was

334
00:38:06,833 --> 00:38:12,500
basically that instead of
loading the whole shellcode in
memory what I could do is create

335
00:38:12,500 --> 00:38:18,792
some kind of gadget table at the
location I wanted. Instead of
take the whole thing, you know,

336
00:38:18,792 --> 00:38:23,458
the whole shellcode which is,
you know, a big number and just
ditching it there what I can do

337
00:38:23,458 --> 00:38:29,167
is instead of that load of bunch
of additional gadgets and use
that was a table to continue my

338
00:38:29,167 --> 00:38:36,042
exploit. For example say you've
got your exploit and you would
like to have those gadgets I put

339
00:38:36,042 --> 00:38:43,542
in there. The up codes I put on
the right. Basically your
shellcode becomes 59 Cf,3 ,

340
00:38:43,542 --> 00:38:49,750
blah, blah, blah. So, if you
load that you use number
stitching to generate that and

341
00:38:49,750 --> 00:38:56,333
put that in memory, then you can
actually call them directly
from, you know, a stage zero

342
00:38:56,333 --> 00:39:02,125
payload from your payload. So
that way you can kind of insert
additional gadgets within the

343
00:39:02,125 --> 00:39:08,125
target's memory space. Which is
kind of practical. And so yes
since, you know, the tool can

344
00:39:10,333 --> 00:39:17,167
change the memory positions it
will work. Then you just call
the gadgets from your table or

345
00:39:17,167 --> 00:39:20,250
it doesn't have to be
necessarily gadgets. It can just
be bytes right. You can just add

346
00:39:20,250 --> 00:39:27,042
a bunch of bytes and it
increases the availability of
your bytes. And so you have kind

347
00:39:27,042 --> 00:39:32,375
of the ability to load any
gadget or byte in memory just
using a bunch of memory address.

348
00:39:32,375 --> 00:39:38,375
I haven't automated that part in
the tool yet it's just kind of,
you know, on the side. So future

349
00:39:41,375 --> 00:39:47,667
work. So, basically, I'd like
to, you know, continue having a
look on numbers and basically if

350
00:39:47,667 --> 00:39:53,750
they're available to memory and,
you know, not subject to ASLR.
So check a bunch of binary and

351
00:39:53,750 --> 00:39:59,250
see if I can figure out if
anything comes up. Realistically
shouldn't be but you never know.

352
00:39:59,250 --> 00:40:05,250
Maybe something will come up.
And basically search for gadgets
in new versions of libc/gcc. So

353
00:40:07,917 --> 00:40:11,500
it seems difficult but, you
know, I might find a bunch of
gadgets in there which could be

354
00:40:11,500 --> 00:40:17,958
exploitable and allow to have
that separation basically of
exploiting the program through

355
00:40:17,958 --> 00:40:23,958
it's kind of dependencies in a
way. On the tooling side
basically I'd like to get

356
00:40:27,125 --> 00:40:34,792
dynamic programming approach to
work with large numbers. I don't
think it will be completely

357
00:40:34,792 --> 00:40:42,333
possible but I'll have a look
into it. At 64‑bit support, I
mean, here regarding the

358
00:40:42,333 --> 00:40:46,042
methodology it's pretty simple
right. The numbers are just
bigger so it doesn't change

359
00:40:46,042 --> 00:40:52,042
anything. The problem will be
with the improtect frame which
might be harder to introduce. I

360
00:40:54,333 --> 00:40:59,375
think basically that there would
be advantage in introducing a
mixed approach. So, you know,

361
00:40:59,375 --> 00:41:03,875
possibly integrating this and
other tools which are already
doing their job really well. So,

362
00:41:03,875 --> 00:41:10,375
you know, rock gadget can
generate payloads once it's got
everything from a string. But

363
00:41:10,375 --> 00:41:16,375
maybe try to automate finding
the missing bytes basically
using this technique which means

364
00:41:16,375 --> 00:41:21,583
that you would have a proper, a
real automatic payload
generation. You know, that's

365
00:41:21,583 --> 00:41:29,125
obviously interesting. Basically
I'd like to introduce in the
tool basically the concept of,

366
00:41:29,125 --> 00:41:36,875
you know, gadget tables and, you
know, introducing random bytes
at random addresses. So just,

367
00:41:36,875 --> 00:41:41,792
you know, to summarize what I
wanted to do was basically, you
know, achieve exploitation

368
00:41:41,792 --> 00:41:45,708
without using gadgets from the
target binary but from, you
know, stuff introduced by the

369
00:41:45,708 --> 00:41:50,792
environment. That took me down
the track, you know, of giving
you those two particular gadgets

370
00:41:50,792 --> 00:41:56,083
that took me down the track of,
you know, having to kind of scan
memory for numbers and find ways

371
00:41:56,083 --> 00:42:00,708
to add them together to achieve
what I wanted. So if you want to
have a chat about it or if

372
00:42:00,708 --> 00:42:05,792
you've got any ideas or think
this is useful or not just shoot
me an email. If you want to try

373
00:42:05,792 --> 00:42:11,542
out the tool, it's available
gighub. So give it a shot. Thank
you very much for your time and

374
00:42:11,542 --> 00:42:17,542
for listening to this and have a
good Def Con. Cheers. (Applause)

