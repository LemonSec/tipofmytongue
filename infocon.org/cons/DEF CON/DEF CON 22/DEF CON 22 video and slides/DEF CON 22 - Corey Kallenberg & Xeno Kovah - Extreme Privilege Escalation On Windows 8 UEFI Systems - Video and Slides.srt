1
00:00:00,458 --> 00:00:04,000
>> Hello. Thank you for coming
to our talk extreme privileges
escalation on Windows 8 UEFI

2
00:00:04,000 --> 00:00:10,000
symptoms. (Applause). >> We're
from the Mitre corporation. A
federally funded research center

3
00:00:15,708 --> 00:00:21,708
let's continue. Here's outline
for today. We'll talk about the
agony of ring three, yes you

4
00:00:24,500 --> 00:00:29,167
have a minister of command in
Windows 8. New lands we can
explore, more extreme places

5
00:00:29,167 --> 00:00:36,250
we'll go. We'll be talking about
how we can get to these other
areas, what we can do there,

6
00:00:36,250 --> 00:00:40,833
we'll be talking about exploits
we used to break into these
areas from Windows 8. We'll be

7
00:00:40,833 --> 00:00:47,667
talking about some agents into
these extreme areas to do our
bidding and then finally we'll

8
00:00:47,667 --> 00:00:53,667
offer how you can detect if
someone is attacking you at the
EFI level. Windows 8 normally

9
00:00:56,167 --> 00:01:02,167
most researchers would be saying
awesome I've won. Give me my
money and then that's it.

10
00:01:06,583 --> 00:01:12,125
Presentation is over but there's
still limits to ring three.
There's things you can't do that

11
00:01:12,125 --> 00:01:18,167
as an administrator there's
things you can't do. At as
attackers we want more power,

12
00:01:18,167 --> 00:01:24,708
more persistence, more stealth
and there are limits to what you
can do in ring three even as an

13
00:01:24,708 --> 00:01:30,458
administrator so we must escape
beyond ring three into other
lands that are completely

14
00:01:30,458 --> 00:01:36,458
unbounded and modest to
everything. Now that was my
introduction. Some of are you

15
00:01:36,458 --> 00:01:41,708
wondering should I have stood in
line for this talk. Definitely
you should have come to this

16
00:01:41,708 --> 00:01:46,625
talk. You don't have to take it
from me. Take it from the
authority figure. He said if you

17
00:01:46,625 --> 00:01:53,250
can re-flash the firmware that
is so awesome that would buy
again that's exactly what we're

18
00:01:53,250 --> 00:01:59,875
going to do in our presentation.
This presentation you definitely
what to be here for this talk.

19
00:01:59,875 --> 00:02:03,625
Now, so, generally what we're
talking about here is post
exploitation privilege

20
00:02:03,625 --> 00:02:06,875
escalation, like I said
generally once you have the
administrator command from

21
00:02:06,875 --> 00:02:12,875
Windows 8 or whatever you're in
the post exploitation phase.
There are other places you might

22
00:02:16,417 --> 00:02:21,000
want to go to and secure the
boundaries in the way to get
into those other areas. The

23
00:02:21,000 --> 00:02:26,417
windows kernel, later versions
of windows you can't inject
arbitrary code into the kernel

24
00:02:26,417 --> 00:02:30,042
because there's the
Authenticode, there's driver
signing, only signed drivers can

25
00:02:30,042 --> 00:02:35,125
get into the kernel. There
are ‑‑ technically that's case.
There are some attacks against

26
00:02:35,125 --> 00:02:39,375
this where you can put arbitrary
code into the kernel. This
attack model has been explored

27
00:02:39,375 --> 00:02:45,375
by other researchers as well.
They talk about loading a known
loadable design driver. This has

28
00:02:48,750 --> 00:02:54,208
been hashed out. We don't want
to talk more about this. We want
to explore extreme

29
00:02:54,208 --> 00:03:01,417
possibilities. Here a few other
options what we can do in the
post exploitation phase. We can

30
00:03:01,417 --> 00:03:05,750
go from admin ring three to boot
kick the system. We can go from
ring to zero onto the platform

31
00:03:05,750 --> 00:03:11,750
firmware or jump into system
management mode. Unfortunately
we live in a dark world today

32
00:03:14,833 --> 00:03:19,292
where we could do any of these
things at least not trivially.
We can't just boot to the system

33
00:03:19,292 --> 00:03:26,417
because it will prevent from us
doing. We can't write to the
firmware because firmware only

34
00:03:26,417 --> 00:03:32,417
accepts signed updates because
there are flash protective
mechanisms. And you can't get

35
00:03:34,792 --> 00:03:40,125
into the system management mode
because not even ring zero can
even read system management

36
00:03:40,125 --> 00:03:45,875
mode, it's protected by the
memory controller hub basically.
Now luckily for you you're

37
00:03:45,875 --> 00:03:52,375
coming to this talk and we'll
introduce the idea of extreme
escalation which lets us go from

38
00:03:52,375 --> 00:03:58,375
administrator to ring three to
platform firmware. The important
thing is on this diagram these

39
00:04:00,417 --> 00:04:06,250
privileges commands are ordered
from on the Y axis. The higher
you go the more privileged you

40
00:04:06,250 --> 00:04:10,167
are. Anything more higher up
than this diagram. There's a
platform firmware, if you can

41
00:04:10,167 --> 00:04:17,375
boot the system you get into
ring zero and so forth. You can
always snake your way down this

42
00:04:17,375 --> 00:04:22,500
diagram. Once you get to the
platform firmware you're free to
take out all these other

43
00:04:22,500 --> 00:04:29,000
privileged admins. Yeah. What I
just said. All right so it's a
Windows 8 system. Most Windows 8

44
00:04:29,000 --> 00:04:34,250
systems today most all will chip
with UEFI firmware which is the
replacement for conventional

45
00:04:34,250 --> 00:04:39,292
BIOS. Almost guaranteed you have
UEFI running underneath the
system happening you turn on

46
00:04:39,292 --> 00:04:44,083
your computer so forth and so
son. Now this is the obligatory
UEFI diagram and essentially all

47
00:04:44,083 --> 00:04:46,375
you have to know about BIOS in
the firmware is its job is to
turn on the computer and

48
00:04:46,375 --> 00:04:52,375
initialize it find the operating
system and transfer it to the
operating system. Turn on the

49
00:04:59,250 --> 00:05:05,250
computer find the OS transfer.
Transfer control to the OS. The
other important thing about this

50
00:05:08,125 --> 00:05:15,750
diagram is that it's advantagous
for us to break it to the
processor as early as possible

51
00:05:15,750 --> 00:05:20,625
because as the boot up proceeds
the system becomes more and more
locked down. There's more and

52
00:05:20,625 --> 00:05:26,000
more locks placed on the chip
set, less things you can do. The
earlier we can break up into the

53
00:05:26,000 --> 00:05:33,750
boot of the system the better.
The system will be in an
unlocked state and we can do

54
00:05:33,750 --> 00:05:39,500
whatever we want if we can get
in early enough. By the time the
OS gets control the device is

55
00:05:39,500 --> 00:05:44,583
the firmware is like very locked
down and there's really not a
lot you can do even from ring

56
00:05:44,583 --> 00:05:50,583
zero: Now, Windows 8 has
introduced a new special API
called set firmware environment

57
00:05:52,833 --> 00:05:58,875
variable which lets you
set, well, exactly what it says,
firmware environment variables.

58
00:05:58,875 --> 00:06:04,875
Think about these as Unix, Linux
type environment variables. UEFI
is the same thing, generally

59
00:06:09,292 --> 00:06:13,833
they look like the platform
language, the boot order and
lots of other crazy things with

60
00:06:13,833 --> 00:06:19,208
all kinds of crazy environment
variables in there firmware.
Windows 8 introduce an API that

61
00:06:19,208 --> 00:06:25,208
allows a privilege so admin ring
free process to interact with
these firmware variables. So

62
00:06:28,125 --> 00:06:34,792
essentially what this looks like
is Windows 8 can call this API
this set a variable to whatever

63
00:06:34,792 --> 00:06:42,042
and many of these variables will
be automatically parsed by the
UEFI firmware now I went about

64
00:06:42,042 --> 00:06:47,417
thinking about I wants to audit
UEFI, immediately when I saw
this environment variable API &

65
00:06:47,417 --> 00:06:53,250
UEFI variables I started to
thinking about this is like a
lot like Linux environment

66
00:06:53,250 --> 00:06:59,583
variable vulnerabilities back in
the early 2000's. Back in the
day you could do like set term

67
00:06:59,583 --> 00:07:04,583
equals a million A and then call
some privilege application X
term or something like that is

68
00:07:04,583 --> 00:07:10,500
that it would try to parse one
of those environment variables
and it would miss parse it and

69
00:07:10,500 --> 00:07:15,083
there would be a buffer
overflow. It was like privilege
escalation in Linux, that's

70
00:07:15,083 --> 00:07:19,625
exactly the methodology I had in
mind when I started looking at
these UEFI variables. There's

71
00:07:19,625 --> 00:07:25,417
lots of these variables and some
have complex contents like
points, likes of arithmetic on

72
00:07:25,417 --> 00:07:31,417
the integers. This is the type
of thing where memory corruption
vulnerability occurs. I want to

73
00:07:35,417 --> 00:07:42,250
target this as an attacker. We
have already found some
vulnerabilities in this variable

74
00:07:42,250 --> 00:07:46,333
interface we thought the
computer was a set variable
there we could discover the

75
00:07:46,333 --> 00:07:53,292
intel that allowed bypassing of
secure boot but to be frank this
vulnerability is probably like a

76
00:07:53,292 --> 00:07:57,833
five out of ten on the awesome
scale that I attribute in the
beginning because it only lets

77
00:07:57,833 --> 00:08:02,792
you bipass secure boot, you
couldn't re-flash the firmware,
you could break the firmware and

78
00:08:02,792 --> 00:08:10,625
it only affected a number of a
like a subset of UEFI symptoms.
Because it basically came down a

79
00:08:10,625 --> 00:08:15,542
weird implimentation that some
of these OM's were using. Five
out of ten is kind of cool but

80
00:08:15,542 --> 00:08:22,958
we can do better. This is the
BIOS to development system. We
have UEFI and intel provides an

81
00:08:22,958 --> 00:08:28,958
open source UEFI references
location that's like open source
code for how you should program

82
00:08:31,458 --> 00:08:37,708
UEFI firmware. You have these
independent BIOS entities
like ‑‑ oops running out of

83
00:08:37,708 --> 00:08:43,708
power. So, we have these IBV's
you probably heard their names
they make BIOs and sell them to

84
00:08:50,583 --> 00:08:55,625
Dell and HP for them to use on
their own personal systems.
Theoretically American

85
00:08:55,625 --> 00:09:01,625
Megatrends Phoenix will use the
code and sell or license that
development kit to Dell and HP

86
00:09:07,125 --> 00:09:10,208
and they'll use those
development kits to write their
own firmware for their own

87
00:09:10,208 --> 00:09:17,958
systems they ship and sell to
you. All right. So, the point is
if I can find a vulnerability in

88
00:09:17,958 --> 00:09:22,458
the UEFI open source it will
trickle down into all these
others that affects all these

89
00:09:22,458 --> 00:09:28,458
other Windows 8 systems that are
using UEFI. Okay. So, UEFI like
I said it's open source so it's

90
00:09:33,750 --> 00:09:39,542
relatively simple. Check out the
code and then go to town. Now as
attackers we want to zero in

91
00:09:39,542 --> 00:09:44,583
okay I'm sorting out this code,
where are the boundaries between
this more privileged piece of

92
00:09:44,583 --> 00:09:50,583
code with attacker control data.
One of the intersections is the
UEFI variables. We know that

93
00:09:53,500 --> 00:09:57,333
many of these are controlled
while the operating systems by
the operating some it's an

94
00:09:57,333 --> 00:10:01,042
attacker controlled data and the
firmware will parse many when
they're created. Now, also last

95
00:10:01,042 --> 00:10:07,042
year at Black Hat we presented a
Dell BIOS update routine where
normally you can only update

96
00:10:10,542 --> 00:10:15,625
Dell with signed BIOs but we
found memory corruption
vulnerability in the update

97
00:10:15,625 --> 00:10:21,625
routine and we re-flashed the
Dell computer to an arbitrary
malicious BIOS image. So, we had

98
00:10:25,583 --> 00:10:31,958
this experience and it just so
happened that UEFI outlined a
uniform capsule update mechanism

99
00:10:31,958 --> 00:10:36,583
updating UEFI firmware. This is
not directly culpable or so
there's no interface accessible

100
00:10:36,583 --> 00:10:42,583
to ring three code that says
start capsule update. This UEFI
variable existed, UEFI would

101
00:10:51,125 --> 00:10:54,792
automatically start the capsule
process. Even though it's not
directly exposed it's

102
00:10:54,792 --> 00:10:58,542
inadvertently exposed. What that
means is that we had a very good
intersection between what we

103
00:10:58,542 --> 00:11:03,750
wanted to look at UEFI variables
and this is what we have past
experience with on our updates.

104
00:11:03,750 --> 00:11:11,208
Capsule update that's good, this
is a first good target to
attacking UEFI. So, this is

105
00:11:11,208 --> 00:11:14,708
basically how capsule update
worked. You would have a
firmware capsule that contains

106
00:11:14,708 --> 00:11:18,958
things like a BIOS update. You
can do other things but for the
sake of discussion let's say

107
00:11:18,958 --> 00:11:25,917
BIOS update. Operating system
will take this capsule right at
the memory in case ram is

108
00:11:25,917 --> 00:11:29,875
constrained and it will like
scatter right to the address
space. Then the operating system

109
00:11:29,875 --> 00:11:35,875
creates a special UEFI variable
called capsule feed data it's a
scatter data list which lynx to

110
00:11:39,500 --> 00:11:45,500
the location of all these
individual fragments for the
capsule in memory. Now, whenever

111
00:11:47,792 --> 00:11:52,333
UEFI gains control it's going to
automatically look for the
existence of this capsule update

112
00:11:52,333 --> 00:11:58,500
variable. It will go about
trying to coalesce this
fragmented capsule there was in

113
00:11:58,500 --> 00:12:04,500
the address space back into its
original form. So, once it has
the UEFI or the capsule coalesce

114
00:12:06,500 --> 00:12:12,500
it's going to pour some of its
envelopes that are encapsulating
the update and verify that it

115
00:12:12,500 --> 00:12:19,000
has been signed by the OEM
because you don't want to have
the firmware just parsing

116
00:12:19,000 --> 00:12:24,875
unsigned capsule. It has to make
sure it's originating from the
OEM, this is OEM code. You

117
00:12:24,875 --> 00:12:30,875
better verify that capsule as
it's coming in. Once the
verification passes assuming it

118
00:12:34,167 --> 00:12:39,125
does it will consume the actual
contents of the capsule so
presumably firmware update but

119
00:12:39,125 --> 00:12:43,167
there's also been proposals for
running like malware detection
independent of the OS its a

120
00:12:43,167 --> 00:12:49,292
general capability but in
general you'll see it for
firmware updates. All right. So,

121
00:12:49,292 --> 00:12:53,542
with that in mind we knew what
are opportunities for actually
exploiting this capsule update

122
00:12:53,542 --> 00:12:57,333
process. We know the
vulnerabilities have to occur
before the pictographic

123
00:12:57,333 --> 00:13:03,333
verification. UEFI will will not
proceed, do not pass go do not
collect $200. Vulnerability has

124
00:13:06,667 --> 00:13:10,750
to occur before that. Company we
will lessing happens before
that. The parsing, the capsule

125
00:13:10,750 --> 00:13:12,958
envelopes, many of the envelopes
parsed by UEFI before the
signature actually occurred so

126
00:13:12,958 --> 00:13:18,958
it has to parse these envelopes
to facilitate the signature
checking process so

127
00:13:26,292 --> 00:13:31,375
vulnerabilities in these
envelopes could be used to
highjack control of the

128
00:13:31,375 --> 00:13:38,458
exploiter in the contents of
UEFI. The third and final option
was parsing within a capsule.

129
00:13:38,458 --> 00:13:45,333
This is where the first BIOS
vulnerability was found. In 2009
lapsed from the BIOS re-flash

130
00:13:45,333 --> 00:13:52,000
attack that revolved around the
unsigned splash screen on your
system so with this intel BIOS

131
00:13:52,000 --> 00:13:55,375
you could update your splash
screen and have your company
logo, whatever company you're

132
00:13:55,375 --> 00:14:02,083
working for be displayed. This
was unsigned content embedded by
the BIOS update. There were

133
00:14:02,083 --> 00:14:07,833
vulnerabilities in the parsing
of that unsigned splash screen
that allowed them to get

134
00:14:07,833 --> 00:14:12,625
control. These are three main
attack vectors, the coalescing,
parsing of the envelopes, and

135
00:14:12,625 --> 00:14:18,625
parsing unsigned copy within the
capsule. Okay. So, UEFI code and
guess what you're here today so

136
00:14:22,917 --> 00:14:28,917
we found lots of bugs obviously.
The bugs took the form of do not
do this 101, so like arithmetic

137
00:14:35,583 --> 00:14:38,958
before sanity checks and
multiplication before
allocation. If you're a veteran

138
00:14:38,958 --> 00:14:41,792
you know definitely do not do
this. If you're a veteran bug
hunter, you would have zeroed in

139
00:14:41,792 --> 00:14:49,083
on these things and you would
say I think this is problematic
like in this case bug number

140
00:14:49,083 --> 00:14:55,042
three, that block is really
large. The multiplication will
overflow and it will be

141
00:14:55,042 --> 00:15:01,000
unexpected small so these are
actually quite obvious like I
said veterans will know that.

142
00:15:01,000 --> 00:15:07,083
Yeah, I could have spotted these
things easily. We found a number
of bugs. We were able to chain

143
00:15:07,083 --> 00:15:13,292
several together to come up with
two different exploits. Because
we're nerds we like chess so we

144
00:15:13,292 --> 00:15:19,292
named our chess exploits. .
While the platform is completely
unlocked the and queen's gamut,

145
00:15:21,458 --> 00:15:27,458
the king's gamut it's known as a
Dixie phase. Using both of these
exploits we were able to get

146
00:15:30,667 --> 00:15:36,667
control of the point the in the
UEFI done nasty things and break
into things that normally ring

147
00:15:45,375 --> 00:15:53,375
three codes could not break
into. When I was auditing this
code, like I said many of the

148
00:15:53,375 --> 00:15:57,375
vulnerabilities are easy to
spot. The developers were aware
that there were possible ‑‑

149
00:15:57,375 --> 00:16:02,958
possibly like bad things that
that could be occurring. This
says more liabilities, check

150
00:16:02,958 --> 00:16:10,167
out, will do later and so forth
and so on. Whatever. Obviously
there was an issue and they

151
00:16:10,167 --> 00:16:16,167
didn't bother to fix them. The
presence of these really easy to
find vulnerabilities and

152
00:16:16,167 --> 00:16:21,042
security critical code that is
open source was disturbing to me
and we're forced to conclude

153
00:16:21,042 --> 00:16:24,667
guess what no one else is
looking at the BIOS. Otherwise
you would have found these

154
00:16:24,667 --> 00:16:30,667
vulnerabilities years ago or
maybe you found them. But ‑‑
yeah, so other good, you know ‑‑

155
00:16:34,125 --> 00:16:38,083
researchers aren't coming up
here and like reporting these
bugs or whatever. So, yeah,

156
00:16:38,083 --> 00:16:40,083
okay, these bugs are easy to
spot. Kind of weird. Interesting
observation. Now, the bugs are

157
00:16:40,083 --> 00:16:46,083
easy to spot. Exploitation was
very complicated. This is
despite the fact that code I

158
00:16:49,250 --> 00:16:54,042
just showed you runs in an
environment that is completely
exploit mitigationless. It runs

159
00:16:54,042 --> 00:17:00,000
in protective mode and that
means all code is readable,
writable, executable, everything

160
00:17:00,000 --> 00:17:06,000
is predictable locations, so
modern mitigation whatsoever.
Critical but no mitigations.

161
00:17:08,833 --> 00:17:12,750
Despite all this, exploitation
was so brutal it took me months
and months to actually

162
00:17:12,750 --> 00:17:18,375
accomplish even though it only
took me a week to find the bugs.
So, at this point in previous

163
00:17:18,375 --> 00:17:22,958
presentations I've gone line by
line, memory map, blah blah,
this is how I did X, Y and Z to

164
00:17:22,958 --> 00:17:28,958
exploit the vulnerability. After
five minutes of doing that the
audience was asleep. I'm going

165
00:17:31,750 --> 00:17:36,458
to show you this crazy diagram
and say if you're a fellow
vulnerability researcher exploit

166
00:17:36,458 --> 00:17:43,458
developer please read my white
paper I spent many days writing
a white paper that goes into all

167
00:17:43,458 --> 00:17:48,208
the gory details on how I
exploited these vulnerabilities.
This is to entice you to read

168
00:17:48,208 --> 00:17:54,000
the white paper if you like that
sort of thing. Point being the
queen's gamut exploit we

169
00:17:54,000 --> 00:18:00,000
achieved a very reliable
searchable write primitive which
is the holy grail in

170
00:18:00,000 --> 00:18:05,333
development. King's gamut
vulnerability was especially
interesting the weren't we call

171
00:18:05,333 --> 00:18:09,750
the Dixie phase because
essentially you end up in a
situation where there's a

172
00:18:09,750 --> 00:18:13,667
nonterminating loop that's going
to overwrite the whole four giga
bite address space. You're

173
00:18:13,667 --> 00:18:19,667
covering the address space with
values. You don't need complete
control. How can we escape? The

174
00:18:21,958 --> 00:18:26,417
only way I think to exploit this
was have a nonterminating loop
overwrite its own code as it was

175
00:18:26,417 --> 00:18:34,167
executing. In this case we wrote
a crazy Python encrypted source
root and in one of those

176
00:18:34,167 --> 00:18:42,125
instance I found a case where I
can make it so that the self
over the nonterminating loop

177
00:18:42,125 --> 00:18:46,583
self override itself with a jump
away to a noncorrupted part of
the address space that the OS

178
00:18:46,583 --> 00:18:52,583
could control and we could have
privilege escalation. This isn't
as good as the other one because

179
00:18:56,417 --> 00:19:00,500
it corrupts a lot of the space
and destabilizes the system and
pretty much what you can do

180
00:19:00,500 --> 00:19:05,250
after you gain control but it's
still kind of interesting so
please read the white paper if

181
00:19:05,250 --> 00:19:11,667
you're interested in the
details. Now, what else is
interesting is that we're able

182
00:19:11,667 --> 00:19:16,250
to exploit the queen's gamut
vulnerability using only that
special Windows 8 UEFI variable.

183
00:19:16,250 --> 00:19:22,167
Part of the exploitation process
required me to stage certain
things to certain physical

184
00:19:22,167 --> 00:19:26,750
addresses with an address space.
Normally in ring three you can't
do this. You won't have access

185
00:19:26,750 --> 00:19:34,417
to all of the physical address
space you want but I found that
by further abusing the Windows 8

186
00:19:34,417 --> 00:19:40,417
UEFI API I could spray the
contents of the flash chip and
just create many of the these

187
00:19:42,667 --> 00:19:48,667
variables and I created. . I was
able to exploit the first
vulnerability that queen's gamut

188
00:19:54,125 --> 00:20:00,833
exploited using the Windows 8
UAPI so I didn't have to rely on
anything else. The second one

189
00:20:00,833 --> 00:20:04,417
there were some constraints and
we had to use a crutch of a
third party driver to put things

190
00:20:04,417 --> 00:20:11,542
in certain physical addresses,
so. In both cases it was
completely unlocked. System

191
00:20:11,542 --> 00:20:17,542
management mode, the flash et
cetera so you can do whatever.
So, okay, it was totally crazy.

192
00:20:20,583 --> 00:20:24,708
Some of you guys are like I
don't understand this after all.
Let me sort of narrate it step

193
00:20:24,708 --> 00:20:32,250
by step this is what it would
look like. We have our dark
Jedi. No for the dark Jedi that

194
00:20:32,250 --> 00:20:37,125
is never enough. He grows his
power to the next level he says
okay that's great I'm admin but

195
00:20:37,125 --> 00:20:43,042
I must go further, must explore
other dimensions, get more
knowledge, get more power. So

196
00:20:43,042 --> 00:20:47,667
first he says I'm going to spray
the contents of the flash chip
with all these UEFI variables

197
00:20:47,667 --> 00:20:53,667
that is contain shell code and a
evil capsule to substantiate the
vulnerabilities. He will have a

198
00:20:55,750 --> 00:21:01,750
tactical control data that
physical address FFF911000 and
he needs that. Then after he's

199
00:21:05,292 --> 00:21:10,458
finished his spray variable type
thing he creates the evil
capsule update data variable

200
00:21:10,458 --> 00:21:16,708
that substantiates that standard
capsule of data process in UEFI
if it exists and he points that

201
00:21:16,708 --> 00:21:20,625
within his sprayed area
basically the evil scatter
gather list to substantiate the

202
00:21:20,625 --> 00:21:27,917
vulnerabilities and this is
what ‑‑ platform reset occurs.
This actually is a bit

203
00:21:27,917 --> 00:21:33,958
implementation specific anded
depends on what hardware you're
running on. In most cases this

204
00:21:33,958 --> 00:21:39,458
is got a name like F3 sleep but
it can mean other things
depending on your hardware. Once

205
00:21:39,458 --> 00:21:45,125
a platform occurs UEFI will
regain control, you'll be
executing the contents of UEFI.

206
00:21:45,125 --> 00:21:52,625
It will check for the existence
of scatter type data and if it
exists it will start parse the

207
00:21:52,625 --> 00:21:59,250
contents of the list and try to
coalesce the capsule and so on.
In this case the evil scatter

208
00:21:59,250 --> 00:22:05,792
gather list capsule updated.
Point inside the contents of the
sprayed data that our more evil

209
00:22:05,792 --> 00:22:13,000
dark Jedi pushed onto the flash
chip and in the process of
parsing because of those

210
00:22:13,000 --> 00:22:16,417
vulnerabilities that I pointed
out the attacker gets control of
the construction pointer in the

211
00:22:16,417 --> 00:22:23,667
context of UEFI. Since there's
no mitigation no execute stack
or whatever the attacker can hit

212
00:22:23,667 --> 00:22:27,667
instruction point back to the
contents of one of the sprayed
variables which contains some

213
00:22:27,667 --> 00:22:33,875
shell code to do something. In
most cases it will be something
like copy yourself in the system

214
00:22:33,875 --> 00:22:41,042
admin mode or re-flash the flash
chip which normally you can't do
but in this case the flash chip

215
00:22:41,042 --> 00:22:45,833
is unlocked so you need to
override the contents of the
flash chip; inject some type of

216
00:22:45,833 --> 00:22:51,750
agent into the virus or the
firmware. No physical presence
needed. So, what can they do?

217
00:22:51,750 --> 00:22:57,750
Why would the attacker be
incentivized to do these. Once
you're in the platform firmware

218
00:23:01,083 --> 00:23:07,500
you can completely break the
system by overriding the flash
chip so not even ‑‑ it won't

219
00:23:07,500 --> 00:23:13,500
even power on. It can defeat
secure boot. It can establish an
undetectable SM root kit. Or we

220
00:23:23,417 --> 00:23:30,167
also gave a talk at Black Hat
about further developing a
undetectable. It can insert

221
00:23:30,167 --> 00:23:36,542
hyper visor and it can interfere
with the hyper visor. You don't
have an SM transfer monitor. You

222
00:23:36,542 --> 00:23:42,542
probably don't anyway. And then
yeah once you're in you can do
anything, anything a CPU you can

223
00:23:45,333 --> 00:23:51,333
do at this point. There are no
constraints to your power. All
right. So, normally does anyone

224
00:23:53,667 --> 00:23:59,667
like to do video demos, because
demos are safer. It might not
work. Fifty‑50. So, 50‑50. We're

225
00:24:12,458 --> 00:24:17,708
doing one of these development
boards and these boards are kind
of like finicky. Windows is not

226
00:24:17,708 --> 00:24:23,167
designed to run on it. We hack
Windows 8 to run on it so we
could exploit the underlying

227
00:24:23,167 --> 00:24:29,167
UEFI code. It may work. He's
like the God, the gatekeeper
between the spirit world. We'll

228
00:24:32,833 --> 00:24:38,833
call on him. Hear my call. Make
our demo work. So, let's give it
a go. It's like variable grade

229
00:24:44,917 --> 00:24:50,917
zero, variable grade one. This
contains the castle as well as
the shell code. He gets the

230
00:24:55,792 --> 00:25:02,042
controlled data in a physical
address. You see an error and
that's because the flash chip

231
00:25:02,042 --> 00:25:09,375
burns out. Corey is going to
work with what you got and it
creates the evil capsule update

232
00:25:09,375 --> 00:25:15,375
variable to point and sign the
contents of this sprayed flash
variables. Go ahead. Okay. So

233
00:25:17,875 --> 00:25:23,208
one other thing I would like to
say is that we're going have to
link to the UEFI shell because

234
00:25:23,208 --> 00:25:30,000
Windows 8 doesn't know how to
put these systems into S3 sleep.
Normally you can put the

235
00:25:30,000 --> 00:25:36,458
platform into S3 sleep but there
aren't the right drivers so
we'll boot to the UEFI shell to

236
00:25:36,458 --> 00:25:42,458
put in it S3 sleep to actually
engage the vulnerability. >>
(Inaudible). >> Bouncing on the

237
00:25:58,292 --> 00:26:04,292
projector. >> Give us just one
second. Okay, so this is the EFI
shell over a serial terminal

238
00:26:07,083 --> 00:26:11,708
here and Xeno put it ‑‑ okay.
So, we're going to call
something that is basically

239
00:26:11,708 --> 00:26:17,708
going to tell us is the exploit
going to work or not or at least
give us some evidence. You see

240
00:26:23,333 --> 00:26:27,458
the spray location FF940C2.
That's great. I assume this to
be a reliable address so

241
00:26:27,458 --> 00:26:33,458
everything seems to be great so
far. Here is another place where
the demo can go wrong. We'll try

242
00:26:37,458 --> 00:26:42,500
to put the minute board in S3
sleep. Even from the shell
sometimes this is finicky.

243
00:26:42,500 --> 00:26:50,500
Sometimes will it not go into S3
sleep. Takes sometimes 30
seconds. Let's all sit here and

244
00:26:50,500 --> 00:26:56,500
hopefully the God will be
merciful to us. Otherwise we'll
have to reset the system. Okay.

245
00:27:03,750 --> 00:27:09,750
So, right, if the system boots
up if the demo works it will
take the shell code and what

246
00:27:16,042 --> 00:27:21,708
we'll be doing is making writes
to the flash kit that will embed
the agent in the system

247
00:27:21,708 --> 00:27:26,750
management mode to do our
bidding. It's like a back door
methodology that Xeno will talk

248
00:27:26,750 --> 00:27:32,417
more about what it's supposed to
do and how it works but we'll
see. Okay, so s it wasn't going

249
00:27:32,417 --> 00:27:38,917
into S3 sleep. Luckily the
exploit is still waiting there
in the variable contents for

250
00:27:38,917 --> 00:27:44,917
UEFI to parse and then if we can
get it to go into S3 sleep. If
it works you'll see it say

251
00:27:48,958 --> 00:27:54,958
something like running from spy
flash. That's how we know it's
running from S3 sleep. There we

252
00:28:01,000 --> 00:28:06,333
go. Finally. Okay so at this
point it has gone into S3 sleep
and woke up with an immediate

253
00:28:06,333 --> 00:28:10,750
wake and it started to parse our
evil capsule. At this point
we've been corrupting the

254
00:28:10,750 --> 00:28:16,833
firmware on the flash trip which
we're definitely not supposed to
do. Xeno will hook up this

255
00:28:16,833 --> 00:28:22,833
programmer just to show you the
writes me made to the flash
chip. Normally you can't do

256
00:28:27,167 --> 00:28:33,417
this. Normally to inspect a
flash chip you need this special
E prompt program. If you have

257
00:28:33,417 --> 00:28:39,417
physical access, yes, you could
overwrite the flash chip. You
could connect something like

258
00:28:41,625 --> 00:28:48,583
this to it. The important thing
is we're actually making them
out of chips so we can do this

259
00:28:48,583 --> 00:28:54,583
without ever having physical
access to the system. Xeno is
going to the point where we

260
00:29:01,125 --> 00:29:07,125
would have inventeded the agent
at this point. Yeah, so you can
see where it turned red. We

261
00:29:09,250 --> 00:29:13,708
identified a pattern area on the
flash chip for this development
board. We just inject one of our

262
00:29:13,708 --> 00:29:18,042
agent that is will copy itself
into the system management mode.
That 's one of our writes.

263
00:29:18,042 --> 00:29:23,042
Everyone should be impressed.
Normally you can't do that.
(Applause). 

264
00:29:23,042 --> 00:29:29,042
>>> So, everyone total
unimpressed. You clapped because
I told you to. Okay so now I'll

265
00:29:41,792 --> 00:29:47,792
secure everything. All right.
So,. >> We just showed that we
injected an agent into the flash

266
00:29:53,208 --> 00:29:58,125
chip. That's first. It's going
to always exist down at the
flash level its going to run

267
00:29:58,125 --> 00:30:04,792
every time you boot the system
and it can, you know, do sort of
anything. So, looks like we lost

268
00:30:04,792 --> 00:30:10,792
a slide here. But basically the
point is we get ‑‑ we get asked
the question consequences, what

269
00:30:13,500 --> 00:30:18,917
does it matter if you break into
BIOS, who cares if people attack
firmware, right? And so the

270
00:30:18,917 --> 00:30:23,250
basic point is we always say
okay, what can an attacker do?
They can do everything, every

271
00:30:23,250 --> 00:30:28,167
single thing. If there's an
attack they can do it because
this is the most privileged code

272
00:30:28,167 --> 00:30:34,000
on the system. There's nothing
it can't do. And it turns out it
also is down there at the lowest

273
00:30:34,000 --> 00:30:40,667
we feel running before all
operating systems so you can
boot my Linux here, so we just

274
00:30:40,667 --> 00:30:45,833
did the exploit from Windows.
We're now going to boot it into
Linux instead because we want to

275
00:30:45,833 --> 00:30:51,458
show this agent down at the
firmware level is persisting and
running and continuing down

276
00:30:51,458 --> 00:30:55,375
below the system and it doesn't
really care who actually is up
there at the operating system.

277
00:30:55,375 --> 00:31:01,625
So, what is the watcher? It's an
agent which is sort of minimally
simple. It's like the simplest

278
00:31:01,625 --> 00:31:09,458
possible thing you could make if
you wanted to make the back door
but it's maximally capable

279
00:31:09,458 --> 00:31:15,125
because all it does is it scans
memory and it tries to find
special signatures and memory.

280
00:31:15,125 --> 00:31:19,917
When it finds a signature in
memory it treats after the
signature ‑‑ what's after the

281
00:31:19,917 --> 00:31:24,042
signature as assembly that it
should run. It just jumps into
that assembly that's after the

282
00:31:24,042 --> 00:31:28,417
signature. And that means we
don't need to build in every
capable in the world into the

283
00:31:28,417 --> 00:31:32,500
watcher. We have to have it
continuously waiting and
watching and scanning your

284
00:31:32,500 --> 00:31:38,708
memory. It doesn't care how an
upload gets into your memory,
use your imagination, someone

285
00:31:38,708 --> 00:31:43,292
shoots some packets at you and
your thing says no, I have my
firewall on I'm going to drop

286
00:31:43,292 --> 00:31:47,458
those packets and not process
them. It doesn't matter. It has
got into the memory and the

287
00:31:47,458 --> 00:31:51,792
watcher is waiting for memory
and looking for signatures.
Whole bunch of different ways.

288
00:31:51,792 --> 00:31:57,792
Maximally flexible because
anything that gets into the
memory any way the watcher can

289
00:32:00,333 --> 00:32:06,667
find it, watcher can execute it.
I'll just speak a little bit
about what we did in terms of

290
00:32:06,667 --> 00:32:12,750
design trade‑offs. So it's
scanning memory. You don't want
to scan all of memory. That's

291
00:32:12,750 --> 00:32:19,792
going the take too long. We want
to scan on page boundaries every
x1 thousand of memories so

292
00:32:19,792 --> 00:32:25,250
watcher is sitting here running
in the background scanning for
magic signatures. The controller

293
00:32:25,250 --> 00:32:31,125
somehow positioned data into
your memory. It doesn't matter
how. You opened a document that

294
00:32:31,125 --> 00:32:36,583
had something attached. Some
java script sprayed some pay
load into your memory. Somehow

295
00:32:36,583 --> 00:32:42,125
some way the controller gets
content into your memory and
then the watcher comes along and

296
00:32:42,125 --> 00:32:49,958
finds it and starts executing an
arbitrary pay load that can do
anything. So, we will show some

297
00:32:49,958 --> 00:32:54,792
simple ‑‑ watcher ‑‑ an
important point is the watcher
is pretty much an after thought

298
00:32:54,792 --> 00:33:00,125
to this presentation. Corey's
attacks on the UEFI. The watcher
was ‑‑ people don't get it that

299
00:33:00,125 --> 00:33:06,125
when we say if you break into
firmware you win everything,
okay. So, we needed to make it

300
00:33:08,417 --> 00:33:13,042
clear because some people only
get it when you make it, you
know, perfectly clear. So, to

301
00:33:13,042 --> 00:33:18,208
show simple demo, we're into
comic books, the watcher is from
an alien race which is forbidden

302
00:33:18,208 --> 00:33:24,500
to interfere but he always finds
a justification to interfere
anyway to warn us about

303
00:33:24,500 --> 00:33:30,500
attackers and so forth. But so
in this case what we're ‑‑ you
can see here we booted into

304
00:33:34,792 --> 00:33:40,792
Linux, that's the Linux that
comes with the board and so to
sort of prove that the watcher

305
00:33:50,042 --> 00:33:57,333
is sitting here waiting and
watching in the background I'm
going to manually invoke a

306
00:33:57,333 --> 00:34:01,250
system management interrupt. We
can have it running continuously
on the background we ran out of

307
00:34:01,250 --> 00:34:05,417
time for doing demos. Like I
said it's an after thought.
We'll manually invoke an SMI and

308
00:34:05,417 --> 00:34:09,125
we'll prove that there is
someone hidden in the background
who is actually executing code.

309
00:34:09,125 --> 00:34:13,792
Right. And the key point is like
we're still on the same system.
We booted into Linux. This is

310
00:34:13,792 --> 00:34:17,250
still the same development
system we were booting, hard
drive with Windows, flash chip

311
00:34:17,250 --> 00:34:20,708
with Linux, same system. The
watcher is sitting there
underneath. It can subvert any

312
00:34:20,708 --> 00:34:24,875
operating system, any hyper
visor, it really doesn't care.
So, what I'm going to do is I'm

313
00:34:24,875 --> 00:34:29,542
going to make a little EFI art.
This is a Linux application. It
writes to a port that causes

314
00:34:29,542 --> 00:34:33,500
system management interrupt and
it picks up the watcher and it
says watcher go scan memory

315
00:34:33,500 --> 00:34:37,667
right now. If I pass argument
eight I'm waking up the watcher
and he's not finding anything,

316
00:34:37,667 --> 00:34:43,667
I'm not creating magic
signatures from the find but if
I do IO9 then what I will see is

317
00:34:43,667 --> 00:34:47,917
he will find this pay load and
he will execute my code if you
want. There we go. The watcher

318
00:34:47,917 --> 00:34:55,292
has infected the system and he's
waiting and he's watching and
he's executing thing. The

319
00:34:55,292 --> 00:35:02,500
watcher itself printed out
watcher go into forbidden, maybe
just this once. (Applause). 

320
00:35:02,500 --> 00:35:08,500
>>> The pay load for this
particular example again just to
make it blindingly clear, the

321
00:35:12,833 --> 00:35:18,708
pay load for this, it could do
any sort of shell code I want.
The watcher passed it the

322
00:35:18,708 --> 00:35:26,125
address of a print function and
so the little bit of assembly
all it did was it took in, you

323
00:35:26,125 --> 00:35:30,292
know, patched the argument into
the print function and then past
the pointer to the string and

324
00:35:30,292 --> 00:35:35,208
then the string prints it out.
That's an example of the watcher
sitting waiting around watching

325
00:35:35,208 --> 00:35:40,542
and executing thing. Now we'll
try our 50‑50 probability maybe
it will work maybe it won't

326
00:35:40,542 --> 00:35:46,833
thing. It doesn't make it matter
how stuff gets in your memory.
Here I just ran an application.

327
00:35:46,833 --> 00:35:50,458
The application you know, create
add special buffer with a
special signature and then some

328
00:35:50,458 --> 00:35:57,167
assembly after the signature to
execute I'm going to now try and
I'm going to try to send some

329
00:35:57,167 --> 00:36:00,792
ping packets that have watcher
signatures and watcher shell
code in and specifically the

330
00:36:00,792 --> 00:36:08,625
ping packets I'm going to send,
let's talk about the pay load
here, the pay load we want to

331
00:36:08,625 --> 00:36:15,208
use is the ultimate nullifier.
Going with the comic book
reference, this is the Fantasy 4

332
00:36:15,208 --> 00:36:21,000
comic books, the ultimate
nullifier was a device that was
extremely powerful. It could

333
00:36:21,000 --> 00:36:28,000
destroy universes and destroys
the user as well. It's kind of
the weapon of last resort. The

334
00:36:28,000 --> 00:36:35,417
ultimate nullifier in our world
is a break the system sort of
pay load. I'll nullify the first

335
00:36:35,417 --> 00:36:39,875
instruction that the CPU ever
pulls out of the flash chip and
that means that the first

336
00:36:39,875 --> 00:36:45,750
instruction is junk. Then you
can't boot the system. You can't
reboot the system into some USB

337
00:36:45,750 --> 00:36:52,000
drive and reimage the system.
The first instruction the CPU
ever executes is garbage. It's

338
00:36:52,000 --> 00:36:56,500
going to not boot ever again
unless you have, you know ‑‑
unless you can go physically

339
00:36:56,500 --> 00:37:01,000
attach a flash chip rewriter.
That's again part of the reason
why we're using this demo board

340
00:37:01,000 --> 00:37:08,292
is because we can easily reflash
it, fix things working on demos
and so forth. You can't easily

341
00:37:08,292 --> 00:37:15,500
refix things on your personal
laptops. So, ultimate nullifier
sent over to the network in ping

342
00:37:15,500 --> 00:37:21,208
packet maybe lit work, maybe it
won't. We've been seeing that
the networks back here is not so

343
00:37:21,208 --> 00:37:27,208
great but Corey, if you... >>
Okay. So, I just want to
re‑emphasize. One thing we're

344
00:37:29,708 --> 00:37:36,417
having to do, like the IO8, IO9
normally we could program the
watcher to be executing in the

345
00:37:36,417 --> 00:37:43,458
background by causing the clip
to, we don't have time to
implement that. Any time Xeno

346
00:37:43,458 --> 00:37:49,458
does the IO8, IO9 we have to
make it more weaponized. >>
Putting up a little local

347
00:38:00,375 --> 00:38:07,292
network and then Xeno will have
his Mac book. I'll sends a ping
packet through the development

348
00:38:07,292 --> 00:38:13,167
board. Embedded in the packet
will be a pay load for the
watcher and that pay load for

349
00:38:13,167 --> 00:38:19,167
the watcher will be break the
system. The idea here is that
some other foreign entity state

350
00:38:21,583 --> 00:38:27,708
has broken into all of your
computers and installed this
watcher. When hostility break

351
00:38:27,708 --> 00:38:32,917
out country break all your
systems right before you, launch
an attack on you because I want

352
00:38:32,917 --> 00:38:38,958
to set you back. So at this
point ‑‑ okay, so we're going to
try to see that it is going to

353
00:38:38,958 --> 00:38:44,958
work. >> All right. >> Keep
going. I feel optimistic. Is the
IP address correct? >> Yeah,

354
00:39:10,333 --> 00:39:16,750
there's always these minor
issues that totally screw up our
stuff. Yeah, part of the issue

355
00:39:16,750 --> 00:39:22,750
is ‑‑ it's causing crazy packet
loss. So, something we didn't
get to work this time. It did

356
00:39:27,958 --> 00:39:33,958
work the last time. So, 50‑50.
But we're going to run the pay
load. We'll just try to get the

357
00:39:41,167 --> 00:39:47,167
watcher to interpret that way.
>> Actually going to run it as a
EFI application. That last pay

358
00:39:53,042 --> 00:39:59,708
load ‑‑ that will be fine. So,
we actually want to run it just
sort of in an EFI shell. These

359
00:39:59,708 --> 00:40:07,417
are EFI applications that can be
made into the ‑‑ that are made
by the BIOS. We did one pay load

360
00:40:07,417 --> 00:40:13,417
from Linux. This will manually
nullify it and we'll read the
flash chip and show that we

361
00:40:21,000 --> 00:40:28,875
actually bricked it. All rightly
so that was running the
nullifier. It's the kind of

362
00:40:28,875 --> 00:40:34,583
thing, the no visible, right.
The important thing is if I pull
this power out and I put the

363
00:40:34,583 --> 00:40:38,125
power back in again, you're not
going to see anything on the
screen because this thing is now

364
00:40:38,125 --> 00:40:44,958
bricked. There's no way for it
to ever boot ever again unless I
come in here with a programmer

365
00:40:44,958 --> 00:40:49,792
and attach it and so forth. So,
it will just show that like the
bites resect vector have

366
00:40:49,792 --> 00:40:57,583
actually been turned to zeros,
nullified. That Black Hat I
accidentally wrote to the chip

367
00:40:57,583 --> 00:41:03,583
instead of read to the chip so
we're going try to not do that
this time. So, the reset vector

368
00:41:07,333 --> 00:41:13,333
for intel CP users is also like
32 bits for FFF0. That's not
right. The reset vector on intel

369
00:41:23,542 --> 00:41:29,500
CP U.'s is FFF0. It alliance the
flash chip with the end of the
physical address space and so

370
00:41:29,500 --> 00:41:35,500
what we see right here is that
the original entry vector would
have been no op, no op jump

371
00:41:37,625 --> 00:41:44,583
backwards and the ultimate
nullifer has written four bites
of data set it as 0000, there's

372
00:41:44,583 --> 00:41:50,792
no valid instruction and it is
now nullified dead bricked and
it is on‑‑ consumer systems

373
00:41:50,792 --> 00:41:56,792
there's pretty much nothing you
can do about it. (Applause). >>
Running the wrong version of the

374
00:42:07,583 --> 00:42:13,583
script over here so whatever.
Okay. So, we don't really have a
lot of time but you can go read

375
00:42:16,833 --> 00:42:21,458
these slides later. The main
point is the watcher, as I said,
it was an afterthought. It took

376
00:42:21,458 --> 00:42:26,000
a couple weeks to build. It's
minimally simple. You just have
a tiny things that finds and

377
00:42:26,000 --> 00:42:31,958
executes stuff and then it just
maximally complex in what it can
do. It can execute arbitrary

378
00:42:31,958 --> 00:42:39,375
shell code. The watcher of
tomorrow can have improved
capabilities but the question is

379
00:42:39,375 --> 00:42:43,625
what can you actually do about
this. Can anyone stop attacks
like the watcher and the answer

380
00:42:43,625 --> 00:42:49,625
is yes, yes, Copernicus can deal
with the watcher. It's basically
a system that it does two

381
00:42:55,917 --> 00:43:01,667
things. It tells you whether or
not your BIOS is vulnerable to
attacks like we talked about and

382
00:43:01,667 --> 00:43:07,375
a lot of vendors don't configure
the BIOS correctly so the flash
chip is open so that means

383
00:43:07,375 --> 00:43:13,375
anyone can nullify you at any
point if they get kernel
privileges and that's why we're

384
00:43:15,875 --> 00:43:21,875
trying to raise the awareness of
that with Copernicus. We do both
integrity checking and

385
00:43:26,417 --> 00:43:32,500
vulnerability checking. It can
jump your BIOS and end speculate
have there been modifications

386
00:43:32,500 --> 00:43:37,875
that you don't inspect and if I
will more time I would show you
an example of the different ways

387
00:43:37,875 --> 00:43:43,500
test it. So, I'm just going to
blow through this quickly. The
vulnerability disclosure we told

388
00:43:43,500 --> 00:43:48,917
intel the bugs back more than
six months ago. We have sort of
a six month vulnerability

389
00:43:48,917 --> 00:43:54,667
disclosure timeline and read the
slide if you want to know more
but the one important thing is

390
00:43:54,667 --> 00:43:59,708
that we did show this on a
single HP system to prove it was
actually vulnerable we showed

391
00:43:59,708 --> 00:44:05,000
these UEFI systems do trickle
down into real systems and as of
yesterday HP went live with

392
00:44:05,000 --> 00:44:10,833
their advisory saying there's
more than 500 different models
of HP which are all vulnerable

393
00:44:10,833 --> 00:44:15,292
to these exploitable
vulnerabilities so go check that
out. You're almost certainly

394
00:44:15,292 --> 00:44:21,250
vulnerable. So in conclusion, we
talked about three things today.
We've talked about a whole bunch

395
00:44:21,250 --> 00:44:25,375
of other things that at other
conferences. We'll talk about
more stuff in the future.

396
00:44:25,375 --> 00:44:28,708
There's a whole bunch of other
people doing a bunch of talks
about other things. There's

397
00:44:28,708 --> 00:44:34,792
going to be a BIOS summary talk
tomorrow. You should check that
out at noon and you'll find out

398
00:44:34,792 --> 00:44:40,542
more about all of the different
ways that you're hose the down
at the BIOS level. So that we're

399
00:44:40,542 --> 00:44:46,542
out of time. We'll be outside
probably back that direction
taking questions. Thanks for

400
00:44:48,708 --> 00:44:51,167
your time. (Applause). "This
text is being provided in a
rough draft format.

401
00:44:51,167 --> 00:44:53,250
Communication Access Realtime
Translation (CART) is provided
in order to facilitate

402
00:44:53,250 --> 00:44:55,667
communication accessibility and
may not be a totally verbatim
record of the event."

