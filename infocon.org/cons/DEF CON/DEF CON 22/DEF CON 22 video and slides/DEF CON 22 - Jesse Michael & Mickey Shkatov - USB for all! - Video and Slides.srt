1
00:00:00,125 --> 00:00:06,458
>> I'm Jesse Michael. This is
Mickey Shktavo. Is that close? >>
Close enough. >> Right right. We

2
00:00:06,460 --> 00:00:12,540
basically would like to come
here and talk to you guys about
some USB security issues that

3
00:00:12,540 --> 00:00:21,540
we've run into. And basically
what we do is we do product
security and we keep running

4
00:00:21,542 --> 00:00:29,500
into security issues related to
USB, but we kind of like to
inspire people and describe how

5
00:00:29,500 --> 00:00:41,300
to get started looking at USB.
We're coming and going to teach
you guys some stuff. >> We have like

6
00:00:41,300 --> 00:00:47,292
half an hour. So we're going
to run through a little bit of
this. If you have any questions,

7
00:00:47,292 --> 00:00:56,372
look for the guy with the blue
mohawk. >> We'll be walking the
floor. Just come find us.

8
00:01:05,625 --> 00:01:13,125
to this slide is slow. So
basically, we wanted to come in
and talk to you guys about USB

9
00:01:13,125 --> 00:01:20,292
security and explain just how
easy it is. Because it seems to
be some misconceptions about how

10
00:01:20,292 --> 00:01:26,917
do even get started and what to
look for. And why you even
should. Like a lot of people

11
00:01:26,917 --> 00:01:31,792
think of USB as some academic
thing or there actually is some
interesting USB security

12
00:01:31,792 --> 00:01:40,652
research here. I'm happy about
that because more people are
looking at it. We wanted to

13
00:01:40,667 --> 00:01:45,542
basically come in and let you
guys understand, it's actually a
lot easier to get started with

14
00:01:45,542 --> 00:01:55,458
USB and why you should look at
this. So like USB is everything.
So basically any device you have

15
00:01:55,458 --> 00:02:01,500
or any modern system is going to
have a USB device, you plug USB
devices in all the time and

16
00:02:01,500 --> 00:02:07,875
don't necessarily think about
it. And it's integrated in
modern platforms in interesting

17
00:02:07,875 --> 00:02:16,395
ways that can have some security
ramifications people don't think
about. And we wanted to

18
00:02:16,400 --> 00:02:24,000
highlight some of that and let
you guys get started,
essentially. So we didn't really

19
00:02:24,000 --> 00:02:32,792
want to focus on the basics of
USB other than pointing out it's
been around since 1994. Started

20
00:02:32,792 --> 00:02:40,392
out with the 1.1 speck. It was
officially released in 1994.
Over the years, we've gone up

21
00:02:40,400 --> 00:02:49,333
from 1.5 to 10 giga-bit per
second in 2013 with the 3.1
speck. There's a variety of

22
00:02:49,333 --> 00:02:58,953
different devices like key
boards, mouse, mouse storage
device, video, we were possibly

23
00:02:58,958 --> 00:03:06,658
going to be using a USB VGA
adapter because my keyboard ‑‑
my laptop over here wasn't

24
00:03:06,660 --> 00:03:17,540
working correctly. But it's used
all over. And people think about
it a little bit. But we just

25
00:03:17,540 --> 00:03:25,292
wanted to bring some attention
to some particular uses in cases
that ‑‑ some people don't

26
00:03:25,292 --> 00:03:31,750
necessarily think about that are
kind of important. So there's
basically like a ‑‑ like kind of

27
00:03:31,750 --> 00:03:39,042
rush through the basics ‑‑
there's basically the four main
pins. The B CC, and the data

28
00:03:39,042 --> 00:03:45,708
plus minus differential pair in
round. And then the mini and
micro pin connecter has a on the

29
00:03:45,708 --> 00:03:53,292
go ID pin just to be able to
detect if it's a host or a
device. And then the 3.0 and 3.1

30
00:03:53,292 --> 00:03:59,750
added the superspeed
differential receive and
transmit pairs. So that's

31
00:03:59,750 --> 00:04:07,083
basically the really, really
really high level view. So if
you look at the actual protocol

32
00:04:07,083 --> 00:04:15,123
and specification, it's around
600 pages long and pretty
detailed. So it's, it's good to

33
00:04:15,125 --> 00:04:21,125
look through if you have a lot
of time and want to get into
some of the really low level

34
00:04:21,125 --> 00:04:33,740
details. But. >> A lot of time
or a lot of Coffee. >> Yeah, but
these bottom layers, the

35
00:04:33,750 --> 00:04:40,740
physical link and protocol area,
those are primarily handled in
hardware. All the major devices

36
00:04:40,740 --> 00:04:47,540
is done in hardware. It's
possible to find vulnerabilities
in these. But it's kind of hard

37
00:04:47,542 --> 00:04:57,340
and possibly require expensive
equipment. So we basically were
trying to focus on places to get

38
00:04:57,340 --> 00:05:04,417
started. We're looking at the
function and device layer and
giving you guys some bigger

39
00:05:04,417 --> 00:05:12,777
pictures of how USB is
implemented into the modern
platforms today. There's also

40
00:05:12,780 --> 00:05:21,120
this idea ‑‑ so like, the idea
that USB is involved, there's
the question of do I need

41
00:05:21,125 --> 00:05:26,920
physical access to plug
something directly into the
system. Bad USB talk over at

42
00:05:26,920 --> 00:05:34,240
BlackHat with Carsonole and
Jacob. It was a good talk this
year basically describing how to

43
00:05:34,240 --> 00:05:42,375
subvert some really commonly
used devices and it has people
talking about filling USB ports

44
00:05:42,375 --> 00:05:50,615
with superglue in order to
prevent this cycle of attacks.
But you know, modern platform

45
00:05:50,625 --> 00:05:58,208
basically, any laptop you have
is going to have internal USB
devices. So the HP I was looking

46
00:05:58,208 --> 00:06:03,750
at earlier has three different
USB devices internally, and all
three of those have upgradeable

47
00:06:03,750 --> 00:06:13,720
firmware. The ability sensor is
a finger print sensor, and it
has actually an AES block. And

48
00:06:13,720 --> 00:06:22,160
that one actually does secure
firmware update in a smart way.
The broad come and the web cam

49
00:06:22,167 --> 00:06:29,708
does also have updatable
firmware components. So if you
have firmware like completely

50
00:06:29,708 --> 00:06:37,500
arbitrarily controllable device
in your platform already, it
could actually do some pretty

51
00:06:37,500 --> 00:06:44,480
interesting things. And it's
something that's not observable
by the host. So the host doesn't

52
00:06:44,480 --> 00:06:50,917
have any ability to look inside
of this. Because it has its own
nonvolatile storage. So you if

53
00:06:50,917 --> 00:06:56,917
you do a firmware update of this
device in your system, there's,
there isn't a really good way

54
00:06:58,160 --> 00:07:03,917
for the host to actually
determine or like your malware
software to determine if this

55
00:07:03,917 --> 00:07:11,167
actually has been updated. So
it's ‑‑ some devices have
hardware that can even force an

56
00:07:11,167 --> 00:07:17,667
update. But some devices, the
update software is in its
controllable by the firmware. So

57
00:07:17,667 --> 00:07:24,875
once you've updated the software
in this device, the device is
actually controlling whether you

58
00:07:24,875 --> 00:07:28,500
can do another update
afterwards. So if you do the
update at once, if it's not

59
00:07:28,500 --> 00:07:34,500
running on your system, it's
questionable whether you even
have the ability to claim it

60
00:07:34,500 --> 00:07:43,200
successfully and ‑‑ so another
thing is that like, with this
particular device, this is a

61
00:07:43,208 --> 00:07:52,667
sync cable for an older phone.
And you know ‑‑ so even devices
that you might think are fairly

62
00:07:52,667 --> 00:08:03,760
simple can have some interesting
ramifications. This is just a
phone sync cable. And it has a

63
00:08:03,760 --> 00:08:12,660
complete USB to U ark bridge and
has a complete 8051 core or 8052
core. It has its own boot ROM.

64
00:08:12,667 --> 00:08:23,542
And ram and S ram. And loads
firmware off an external ISD
chip. So it actually has this

65
00:08:23,542 --> 00:08:29,542
complete ‑‑ it could be
arbitrarily controllable. You
could rewrite the vendor ID and

66
00:08:29,542 --> 00:08:36,120
VID and PID so it shows up as a
completely separate device. You
can change the USB device

67
00:08:36,120 --> 00:08:42,980
descriptors. This is all
something controllable over USB.
You can basically just send a ‑‑

68
00:08:45,080 --> 00:08:54,620
let's See. So this device
actually has a number of vendors
of USB request. And some of them

69
00:08:54,625 --> 00:09:02,292
are ‑‑ you can tell it to
reboot. You can tell it to force
execute the firmware that you

70
00:09:02,292 --> 00:09:08,542
have provided. >> We're going to
see a demo later on. >> Yeah. So
basically, you can tell it,

71
00:09:08,542 --> 00:09:15,800
usually it'll check the IDC.
It'll check the signature. And
the signature is basically four

72
00:09:15,800 --> 00:09:20,700
bytes of program at all. It
doesn't do any kind of integrity
or verification of what's in the

73
00:09:20,708 --> 00:09:27,042
ISC chip inside of here. And
then it just down loads whatever
firmware from the host. Other

74
00:09:27,042 --> 00:09:33,922
side, you can send a request and
get it directly to take whatever you
want to send to the device. So

75
00:09:40,542 --> 00:09:49,292
So you can basically, after the system
is booted up, malware can send
an arbitrarily firmware package

76
00:09:49,292 --> 00:09:56,250
to the device and execute
whatever you want. Have it
reconfigure itself as an

77
00:09:56,250 --> 00:10:03,042
interface of a small storage or
a whole variety of different
options. And this is just

78
00:10:03,042 --> 00:10:10,000
directly describing the data
sheet. If you find this
particular controller ‑‑ it even

79
00:10:10,000 --> 00:10:16,125
describes, here's how it's
been ‑‑ how to send firmware
updates through this device. And

80
00:10:16,125 --> 00:10:20,292
in the data sheet, it
specifically says these requests
are primarily for internal

81
00:10:20,292 --> 00:10:26,542
testing only, these functions
should not be used in normal
operation. But yeah, you can

82
00:10:26,542 --> 00:10:32,500
find really interesting things
if you search for these types of
things in data sheets if you're

83
00:10:32,500 --> 00:10:37,292
writing malware, this is one of
the things you want to find. You
can take advantage of these

84
00:10:37,292 --> 00:10:44,912
debug hooks. This is designed
for updatability and test
functionality. But there isn't

85
00:10:44,917 --> 00:10:51,167
anything that stops it from
being used after it's
provisioned and deployed in the

86
00:10:51,167 --> 00:10:57,333
field. So you can take advantage
of some of these debug hooks and
upgradability hooks to do some

87
00:10:57,333 --> 00:11:04,792
pretty interesting things. And
this particular USB controller
is used in a whole wide range of

88
00:11:04,792 --> 00:11:11,333
different types of devices from
this little USB sync cable up to
multi-thousand dollars net work

89
00:11:11,333 --> 00:11:18,625
infrastructure devices. So you
can find it in some pretty
interesting places. And this

90
00:11:18,625 --> 00:11:25,167
type of capability actually
exists pretty commonly. Like I
was mentioning, devices that

91
00:11:25,167 --> 00:11:32,958
happen to be already in your
laptop, you possibly have
something that is arbitrarily

92
00:11:32,958 --> 00:11:37,417
controllable and can be used
already in the laptop you have
currently, and there isn't

93
00:11:37,417 --> 00:11:48,833
really a good way to determine
if it's been modified or to
really verify the integrity of

94
00:11:48,833 --> 00:11:55,333
this particular device that's
already in your laptop. So some
other things in this USB ‑‑ in

95
00:11:55,333 --> 00:12:01,208
the specification is it's
specifically describes how to
read and write to this

96
00:12:01,208 --> 00:12:11,542
nonvolatile storage that it
loads it firmware from. Some
devices end up where you can do

97
00:12:11,542 --> 00:12:21,320
an update and send a malicious
packet of halo to it. But it's
gone once you reboot. But, this

98
00:12:21,320 --> 00:12:28,040
you can be completely
persistent. You can send it a
malicious update and then they

99
00:12:28,042 --> 00:12:32,708
reboot, they shut down the
system, it's still running. So
when the system comes back up,

100
00:12:32,708 --> 00:12:41,020
this thing can potentially
enumerate as any type of USB
device including a hidden device

101
00:12:41,020 --> 00:12:49,740
and send malicious scripts, send
like ‑‑ it could also ‑‑ Like if
it's attached when the system is

102
00:12:49,750 --> 00:13:00,660
booting up, it can do ‑‑ it can
send keystrokes when your system
is booting even instead of ‑‑ if

103
00:13:00,660 --> 00:13:06,160
you have some malware on the
system. Actually I should
probably talk about that in a

104
00:13:06,167 --> 00:13:13,917
second. So there actually is a
device firmware update
specification. And this, the

105
00:13:13,917 --> 00:13:20,458
original version is from the
late 1999. And it talks about
how to create devices with

106
00:13:20,458 --> 00:13:28,125
upgradeable firmware. And they
go in this all kinds of detail
about what to do. But they don't

107
00:13:28,125 --> 00:13:33,750
actually mention security at
all. There's no mention of how
to actually protect the firmware

108
00:13:33,750 --> 00:13:41,875
in all of these devices. They do
describe having a simple check
sum because not possibly useful

109
00:13:41,875 --> 00:13:46,792
for integrity. But if you have
somebody who's creating a
malicious payload, that's

110
00:13:46,792 --> 00:13:54,542
completely by passable. And it
was updated ‑‑ the first version
came out in 1999, they came out

111
00:13:54,542 --> 00:14:00,742
with an updated version in 2004,
but they don't talk about
security at all. It's just

112
00:14:00,742 --> 00:14:09,742
updating the firmware. But there
isn't anything talking about how
to do that securely. And we've

113
00:14:09,742 --> 00:14:17,620
run into a bunch of cases where
a lot of different vendors do
use the DFU, device firmware

114
00:14:18,583 --> 00:14:29,000
upgrade spec. But they, they
will follow this and they also
will ‑‑ because many devices are

115
00:14:29,000 --> 00:14:35,833
relatively low power, they
aren't going to go through the
whole case of having something

116
00:14:35,833 --> 00:14:44,013
that uses full length RSA's
signatures or any kind of public
key signature application before

117
00:14:44,020 --> 00:14:53,040
it runs and updates. So they'll
do the integrity check and
that's it. That's incredibly

118
00:14:53,042 --> 00:15:03,460
easy to spoof. There are some
devices that they do care about
security more so they will do

119
00:15:03,460 --> 00:15:11,540
this complete security check in
like do signature verification.
But it's much more of an on the

120
00:15:11,542 --> 00:15:20,460
fly. It's custom, there isn't
any approved way to do this.
They're rolling their own

121
00:15:20,460 --> 00:15:26,792
firmware update. So sometimes
they get it right and sometimes
they don't. But the vast

122
00:15:26,792 --> 00:15:32,125
majority of the devices, they
just don't even bother to have
any kind of security. It's

123
00:15:32,125 --> 00:15:38,125
fairly trivial to update these
devices and just get firmware,
get your own firmware running on

124
00:15:40,375 --> 00:15:46,167
the device. And have arbitrary
code execution running within
the USB device. If you have

125
00:15:46,167 --> 00:15:51,750
that, you can do some pretty
interesting things. We'd like to
talk about tax purposes. Like a

126
00:15:51,750 --> 00:15:59,792
lot of people will think about
the host and then a device and a
USB cable in the middle. And you

127
00:15:59,792 --> 00:16:04,500
can just disconnect that. But
there's actually a lot more
going on. So there's an

128
00:16:04,500 --> 00:16:10,958
application. There's a variety
of applications. You might have
virtualization going on or two

129
00:16:10,958 --> 00:16:19,333
to virtual guests. And even
within a, also there's a couple
different privilege level just

130
00:16:19,333 --> 00:16:28,233
within the OS itself and your
host. Considering the bios, SMM.
There's the CPU. We've had some

131
00:16:28,250 --> 00:16:35,500
interesting capabilities. And
within the device itself,
there's the firmware and in some

132
00:16:35,500 --> 00:16:41,167
devices that can be as complex
as running a complete LINUX
distribution inside the device.

133
00:16:41,167 --> 00:16:47,833
So there's devices that have
really, really simple just
little hard coded if you

134
00:16:47,833 --> 00:16:55,953
remember ware. Others are
running a complete OS. And it
depends on what the clients do.

135
00:16:55,958 --> 00:17:01,375
But, if you have the complete ‑‑
the complete complexity of an
operating system running in your

136
00:17:01,375 --> 00:17:07,375
device, there's much more likely
to be other security
vulnerabilities from that. And

137
00:17:07,375 --> 00:17:14,042
it's, it's ‑‑ and also,
especially with people trying to
get devices out and into the the

138
00:17:14,042 --> 00:17:20,000
field, time to market
requirements and trying to get
devices out into people's hands,

139
00:17:20,000 --> 00:17:24,750
they aren't necessarily going to
spend as much time validating
things and making sure that its

140
00:17:24,750 --> 00:17:32,375
as secure as possible; they want
to going to it out and make the
sale and get it out there. So

141
00:17:32,375 --> 00:17:40,083
there's a variety of different
interesting things going inside
both your host and your PC- The

142
00:17:40,083 --> 00:17:45,958
host and the device. And it's
likely happening inside your
laptop. So instead of just

143
00:17:45,958 --> 00:17:51,125
thinking of a device that you
need to physically disconnect
and you don't even ‑‑ if you

144
00:17:51,125 --> 00:17:59,000
want to be careful, like protect
yourself and like ‑‑ I don't
know that I trust getting USB

145
00:17:59,000 --> 00:18:07,000
from this guy. But if I unwrap
it for myself and I only use it
myself, it's hopefully going to

146
00:18:07,000 --> 00:18:13,875
be okay. But there's ‑‑ the
devices that are already in your
laptop that could be

147
00:18:13,875 --> 00:18:21,083
compromised. We've had issues
where devices have come from
factory with firmware with

148
00:18:21,083 --> 00:18:26,458
malicious or compromised
firmware and devices on the
devices. But if you have

149
00:18:26,458 --> 00:18:34,958
something that's already in the
system, there's some interesting
capabilities then that malware

150
00:18:34,958 --> 00:18:41,875
can take advantage of. And so,
the devices in your system, some
of them also have radio

151
00:18:41,875 --> 00:18:51,075
interface. Like the description
of the ‑‑ the device manager
that I showed you earlier. One

152
00:18:51,083 --> 00:18:56,542
of the devices I had was a blue
tooth interface. So this is
talking to outside, it also has

153
00:18:56,542 --> 00:19:04,482
attack surface in bluetooth
field. So if there's a blue
tooth also like 3G modems, a

154
00:19:04,482 --> 00:19:14,200
variety of devices have external
interfaces. So it's not a
situation where malware can

155
00:19:14,208 --> 00:19:19,458
reprogram this. But if there's
vulnerability within the radio
firmware, you can take advantage

156
00:19:19,458 --> 00:19:28,698
for that, that attack surface to
get as a quick hold into the
system. So if you ‑‑ there's a

157
00:19:28,708 --> 00:19:32,583
variety of different ways you
could arbitrary codex execution
within the device. There's

158
00:19:32,583 --> 00:19:40,417
malware running within the
system already. Maybe in a
virtualized guest. Again,

159
00:19:40,417 --> 00:19:46,625
VMware and virtual box and
other virtualization system, you
can pass through a USB device to

160
00:19:46,625 --> 00:19:52,583
the guest and the guest have
direct access through the USB
device. But if you have malware

161
00:19:52,583 --> 00:20:00,083
running within that virtualized
guest. It could do a firmware
update to this USB device also.

162
00:20:00,083 --> 00:20:06,375
Which could cause some
interesting problems. So if
you're getting arbitrary codex

163
00:20:06,375 --> 00:20:12,750
within the USB device, you can
then use that to attack other
components within the host. So

164
00:20:12,750 --> 00:20:20,792
if you have one virtualized
guest that reprograms USB
device, you can potentially use

165
00:20:20,792 --> 00:20:29,152
that to escape confinement or
inject key strokes to bio system
booting up. And there's a

166
00:20:29,167 --> 00:20:36,542
variety of different ways you
can attack this. So the
controller we were talking about

167
00:20:36,542 --> 00:20:44,320
earlier and showed the data
sheet for, we could arbitrarily
control the VID and PID of that

168
00:20:44,320 --> 00:20:55,020
device. We can change the device
descriptors. So what specific
device classes show up as. From

169
00:20:55,020 --> 00:21:04,760
the device side, force
disconnect and reconnect, you
can reconfigure the device,

170
00:21:04,760 --> 00:21:11,160
disconnect, and that will be
reenummerated in the host. But
when that's been passed down as

171
00:21:12,958 --> 00:21:18,875
a virtualized guest, it
basically shows up as a physical
disconnect, which causes the

172
00:21:18,875 --> 00:21:25,375
host to reenumerate the device
because it's a different device,
the virtualization software

173
00:21:25,375 --> 00:21:31,792
generally uses the VID, PID as
this is what ‑‑ this is device
is has been passed on to the

174
00:21:31,792 --> 00:21:40,532
host. When it shows up as a
disconnect and reconnect, it
actually can escape confinement

175
00:21:40,542 --> 00:21:47,500
in that way. So you can inject
key strokes to the host instead
of the guest. Which is pretty

176
00:21:47,500 --> 00:21:52,880
interesting. >> Or another
example, if you have a USB to
LAN adapter connected to

177
00:21:52,880 --> 00:21:57,700
a guest VM and you
happen to reprogram the
VID/PID to be the same

178
00:21:57,700 --> 00:22:04,540
companies, USB LAN adjuster type
of product, most likely the two
chips will have the same

179
00:22:04,540 --> 00:22:10,340
functionality. The VIM will get
connected to the host ‑‑ ‑‑ you
will have an entire network

180
00:22:10,340 --> 00:22:14,424
attack surface to the
host.

181
00:22:18,060 --> 00:22:22,220
>> And yeah, this type of
attack can happen whether it's a

182
00:22:22,220 --> 00:22:29,240
physical device you've added or
if there's a device, a USB
device already in your system.

183
00:22:29,240 --> 00:22:37,740
My phone here has the USB modem
is via the cellular modem I get
access to, the cellular net work

184
00:22:37,750 --> 00:22:45,750
that's a USB connection also. So
what are the chances that the
base ban firmer has no

185
00:22:45,750 --> 00:22:52,542
vulnerabilities? >> Why haven't
you tested that? >> I've played
with it a little bit. Not a lot.

186
00:22:52,542 --> 00:22:58,500
>> Still working. >> Yeah. So
basically if there's a
vulnerability in the base ware

187
00:22:58,500 --> 00:23:04,167
firmware or the phone or
something like that, you're
basically getting arbitrary

188
00:23:04,167 --> 00:23:09,625
access control within this USB
device and then you have to
basically bridge the gap across

189
00:23:09,625 --> 00:23:16,167
the USB interface to actually
get access to the host. So
there's actually a pretty

190
00:23:16,167 --> 00:23:22,167
interesting project called
Katalia I think that has a
variety of different really

191
00:23:22,167 --> 00:23:30,680
interesting payloads for human
interface devices to present to
a host over USB. You basically

192
00:23:30,680 --> 00:23:38,620
go to this, I think it's a
release script and you can say I
want to generate this payload to

193
00:23:38,625 --> 00:23:45,667
like get credentials from a
window's device. And it can do
some really interesting things

194
00:23:45,667 --> 00:23:52,000
and you basically generate this
payload and create a sketch, but
it's really easy to take that

195
00:23:52,000 --> 00:23:58,083
payload and use it for other
purposes you're not even using
something. It was designed to be

196
00:23:58,083 --> 00:24:04,750
used with TNC's and that type of
device. But it is, I think it
has 30 or so different payloads

197
00:24:04,750 --> 00:24:11,958
that are pretty useful other
than just like directed browsing
and download and execute. And

198
00:24:11,958 --> 00:24:17,167
getting malware running on the
device. But it can do basically
like adding a user with admin

199
00:24:17,167 --> 00:24:23,958
permissions. The use of the
login has admin permissions
already. So like that type of ‑‑

200
00:24:23,958 --> 00:24:32,218
it uses a power shell for
sending for payloads for
windows. So it's a pretty

201
00:24:32,220 --> 00:24:39,240
flexible frame work. It's
designed for penetration
testing. But it's basically a

202
00:24:39,250 --> 00:24:46,375
good way to understand what you
can actually do if you have a
USB device you control and you

203
00:24:46,375 --> 00:24:54,125
can arbitrarily program. So I
was intending to add a slide for
that, but didn't quite get that.

204
00:24:54,125 --> 00:25:01,458
I believe it was Katalia. It's
on github. >> We have a couple
references for you guys later.

205
00:25:01,458 --> 00:25:10,417
>> Another thing that a lot of
people don't realize about is
this debug capability within

206
00:25:10,417 --> 00:25:16,750
USB. And that actually allows
you to get low level D bug
access over USB. And it's been

207
00:25:16,750 --> 00:25:23,625
added to a window's logo
certification, so any device
that runs windows, it's going to

208
00:25:23,625 --> 00:25:30,792
support this debug capability.
And you can basically get in and
internal debugging and stuff

209
00:25:30,792 --> 00:25:38,750
over USB. And some other vendors
are doing some more interesting
things based on using low level

210
00:25:38,750 --> 00:25:46,250
debug protocol. But with the
ESAI version, it was around, but
required special hardware. So it

211
00:25:46,250 --> 00:25:52,750
wasn't used as much other than
people like writing OS's. But
the XHCI version that everybody

212
00:25:52,750 --> 00:25:59,625
has now for the last year,
couple years, is basically we'll
go through standard USB hubs. It

213
00:25:59,625 --> 00:26:05,333
doesn't use any kind of, any
special hardware. So it's
actually pretty easy to take

214
00:26:05,333 --> 00:26:14,993
advantage of and play around
with. And there's also this
thing called media agnostic USB

215
00:26:15,000 --> 00:26:20,060
that has just recently come out.
The 1.0 speck that was just
released in February of this

216
00:26:20,060 --> 00:26:28,580
year, and they basically are
taking the entire USB stack and
swapping out the low level

217
00:26:28,583 --> 00:26:38,042
physical link areas. So you can
basically have the full USB
protocol and stack running on

218
00:26:38,042 --> 00:26:43,820
top of a wireless link. So they
basically are designing this so
you can have the complete

219
00:26:43,820 --> 00:26:51,600
complexity of USB over wifi or
why gig or some other protocol.
The initial version of the spec

220
00:26:51,600 --> 00:26:56,458
is specifically talking about
wifi and why gig and they're
making it flexible enough so you

221
00:26:56,458 --> 00:27:03,792
can have other transport
mechanisms. So it ends up
looking kind of like this where

222
00:27:03,792 --> 00:27:10,875
you've got the top parts are the
protocol agnostic level and then
everything else is being

223
00:27:10,875 --> 00:27:17,250
transferred over USB or over
wifi or some kind of wireless
radio communication. And there's

224
00:27:17,250 --> 00:27:23,792
some interesting things because
it can actually ‑‑ instead of
pairing and having the

225
00:27:23,792 --> 00:27:30,958
credentials, it could do auto
discovery, and that's something
we really want to take a look A.

226
00:27:30,958 --> 00:27:36,158
We haven't seen the hardware for
this yet. But this is going to
be really interesting and we

227
00:27:36,160 --> 00:27:40,240
wanted to give you guy a heads
up about this particular
technology. Because this is on

228
00:27:40,250 --> 00:27:46,250
the way. And I think it'll be
pretty cool. So we wanted to
talk about some tools basically

229
00:27:46,250 --> 00:27:54,458
to let you guys know what's out
there. And available to get
started with that. So the total

230
00:27:54,458 --> 00:28:04,238
phase of Beagle 5000, we've
got one of these here. It's it's
a nice device. It's kind of

231
00:28:04,250 --> 00:28:11,542
expensive. But it does support
USB three superspeed. So you can
do protocol analysis and

232
00:28:11,542 --> 00:28:16,958
understand what's actually going
on even with high speed devices.
But it's ‑‑ it is pretty

233
00:28:16,958 --> 00:28:22,500
expensive. And it could only be
used for observation not
injection. So it has some

234
00:28:22,500 --> 00:28:31,000
limitation. There's also, if you
don't care about the 3.0
superspeed, there's the Beagle

235
00:28:31,000 --> 00:28:37,333
480. Which is less expensive.
We've got one over here for
demos. It's a lot less

236
00:28:37,333 --> 00:28:45,083
expensive, but it only supports
2.0. And like the 5,000, it can
only be used for observation.

237
00:28:45,083 --> 00:28:50,720
So. There's also the
ITIC Protocol Analyzer.

238
00:28:50,720 --> 00:28:58,160
This is even less expensive than
the Beagle 480. But they brake
it up into some of the software

239
00:28:58,167 --> 00:29:04,208
is sold separately. It depends
on what you're doing, but that
can be useful also. Most of you

240
00:29:04,208 --> 00:29:10,708
probably heard of the face
answer that Travis Goodfet put
together. It's really nice. A

241
00:29:10,708 --> 00:29:16,088
friend of mine soldered this
together. He didn't have the
right resisters for a couple of

242
00:29:16,088 --> 00:29:23,480
these, so he ended up with the
three hole parts instead of the
surface mount parts. This is

243
00:29:23,480 --> 00:29:30,740
really nice because you can
basically do ‑‑ you can emulate
any kind of USB device and

244
00:29:30,750 --> 00:29:35,833
basically write a python script
in order to do it. But because
it has a complete round trip

245
00:29:35,833 --> 00:29:41,625
through the device to your host
running python script, it could
be really slow. And we ran into

246
00:29:41,625 --> 00:29:48,580
a bunch of issues where it was
way too slow for what we were
using it for and we had to come

247
00:29:48,580 --> 00:29:54,580
up with an alternate solution.
You want to describe that? >>  No
no no no no I don't want to. We

248
00:29:54,583 --> 00:30:02,458
don't have time anyway. >> Okay.
So there's also the dice show
project that Michael and

249
00:30:02,458 --> 00:30:11,738
Dominick, Marshal, Jared, Mike
and Ben are putting together.
This is intended to do fall USB

250
00:30:11,750 --> 00:30:18,917
three injection high speed
protocol analysis and man in the
middle. But they, we were hoping

251
00:30:18,917 --> 00:30:26,458
to be able to demo here on
stage. But it's not quite ready
yet. But if you guys are

252
00:30:26,458 --> 00:30:33,667
interested, just pay attention
to it. It's ‑‑ it should be out
very soon. But I totally want

253
00:30:33,667 --> 00:30:41,140
one of these. And I think these
will be really useful. There's
also the USB proxy that Dominick

254
00:30:41,140 --> 00:30:49,580
is putting together. It's
basically taking a beagle blue
in black and he's created

255
00:30:49,580 --> 00:30:58,333
this ‑‑ yeah. So this is a cheep
little device. But it has a USB
hoax and device for it. So you

256
00:30:58,333 --> 00:31:07,193
can, you have a tool that he can
run on there and he is, his
release image is basically a WM

257
00:31:07,208 --> 00:31:14,125
insulation. And you could do
complete man in the middle of
USB two devices. And he's giving

258
00:31:14,125 --> 00:31:22,745
a talk in the hardware hacking
allegedly and demoing this also.
So he's ‑‑ it's just one guy so

259
00:31:22,750 --> 00:31:30,708
far. Dominick. But he's taking
contributions. They could do
some pretty awesome stuff. He

260
00:31:30,708 --> 00:31:39,000
has a demo of being able to do
like this on the fly write
protection of USB devices or

261
00:31:39,000 --> 00:31:46,750
like changing requests on the
fly. So he has like a keyboard
that's doing rock 13 while you

262
00:31:46,750 --> 00:31:54,583
type. Just as a simple download.
But you could do arbitrary
modifications of the content on

263
00:31:54,583 --> 00:32:04,375
the device. So this is a great
device. And his software on that is
pretty cool. So if you're

264
00:32:04,375 --> 00:32:13,235
looking for just software,
there's lib USB. And that's a
good way to get, to start using

265
00:32:13,250 --> 00:32:19,250
the devices even if you don't
have any hardware. So you could
install LibUSB. And install the

266
00:32:19,250 --> 00:32:28,333
device driver so you can talk to
the specific USB device. And
this is another way ‑‑ if you're

267
00:32:28,333 --> 00:32:32,500
talking to something that's
physically soldered down to your
mother board, you're not going

268
00:32:32,500 --> 00:32:38,792
to be able to stick a beagle in
the middle. But you could use
libUSB to request firmware,

269
00:32:38,792 --> 00:32:45,752
updates explore that space.
Another thing we're doing Mickey
create add peach publishers are

270
00:32:45,760 --> 00:32:55,440
these are on the DEFCON CD.
But it's hooking up the peach,
this awesome fuzzer that we love

271
00:32:55,440 --> 00:33:00,660
a lot. And it's hooking to
LibUSB we can do a variety of
different fuzzing, different

272
00:33:00,667 --> 00:33:08,542
fuzzing. >> Which is going to
show in a minute in the demo.
>> Data publisher, configuration

273
00:33:08,542 --> 00:33:22,520
publisher, those are all on the
CD. It's a visual studio
solution. There is also this

274
00:33:22,520 --> 00:33:29,500
Phison PS2303 framework which
is, I believe the device in it
is the chip that Carson Knoll

275
00:33:29,500 --> 00:33:37,000
and Jacob Loul were talking
about with BlackHat. This frame
work is also on bucket. It's

276
00:33:37,000 --> 00:33:43,250
been around for a while. But, it
basically, it has a similar
capabilities as the controls we

277
00:33:43,250 --> 00:33:48,292
talked about. It has an 8051
compatible core. It has its own
ram. It could run firmware off

278
00:33:48,292 --> 00:33:56,672
of the NAND. And they're
basically creating this project
to use these flash drives as a

279
00:33:56,680 --> 00:34:04,833
USB three development and
penetration testing platform.
So, this is another great thing

280
00:34:04,833 --> 00:34:10,833
for you guys to check out. So
now we move onto the demo.

281
00:34:29,708 --> 00:34:35,708
Can everyone see studio window? >>
>> No? Really? >> You need
to duplicate it. >>

282
00:34:39,820 --> 00:34:47,280
>> I'm duplicating it. I'll do it
again. How about now? >>
Yup >> Awesome. 

283
00:34:50,840 --> 00:34:59,000
This here is a USB to LAN
adapter. For my next trick,
I am going to plug this in.

284
00:35:03,917 --> 00:35:10,625
I'm going to show you this little piece
of code that gets the VID,PID
connected to the device and

285
00:35:10,625 --> 00:35:16,625
reads the VID,PID. Which are
stored on an E prom on the PCB.

286
00:35:28,820 --> 00:35:39,120
There is a data sheet I want to show you
that is available for this device. It
has an USB interface and talks

287
00:35:39,125 --> 00:35:44,292
to the directly to the E Prom.
One of the beautiful things
about this, you look in the data

288
00:35:44,292 --> 00:35:52,732
sheet, you find USB vendor commands.
Which will give you the exact
bites you need to send and

289
00:35:52,750 --> 00:36:02,140
receive in order to read, write,
write enable, disable in case
you need to write enable, and a

290
00:36:02,140 --> 00:36:08,140
whole bunch of other stuff. I'm
going to run through this.

291
00:36:14,560 --> 00:36:22,000
Now I'm going to change the
VID/PID for this thing and
before I need to show you.

292
00:36:24,400 --> 00:36:31,700
For this demo I'm using
libUSB.net. And libUSB.
So if you see under libUSB

293
00:36:31,700 --> 00:36:42,080
I have the network device in
here. The VID is 170F and
the PID is 7203. So far so

294
00:36:42,083 --> 00:36:49,292
good. Coming back to my tool,
write enable, changing the VID,
changing the PID and to double

295
00:36:49,292 --> 00:36:54,292
check, I'm reading it back from
the E Prom. Now the device is
still connected. The device is

296
00:36:54,292 --> 00:37:02,167
still powered on. There is a way
to reader specific chip to
trigger a hardware. Preset on

297
00:37:02,167 --> 00:37:08,083
the pin. I haven't found that
yet. Specs said it still needs
to do something, it doesn't

298
00:37:08,083 --> 00:37:14,083
really do it. So, in order to
simulate a reset, I will plug it
out and back in again.

299
00:37:35,042 --> 00:37:47,182
And now we have a Microsoft
keyboard. (Applause.) Now for
the fun stuff.

300
00:37:56,840 --> 00:38:08,540
Do you have the DEF CON CD. No?
Okay Cool. So in the CD, you'll find
this USB solution that has

301
00:38:08,542 --> 00:38:17,333
the ‑‑ all you need to do ‑‑ all
you ever need to fuzz USB
basically with peach. If you

302
00:38:17,333 --> 00:38:21,458
don't know the peach fuzzing
framework, I recommend you
Google that. It's an awesome

303
00:38:21,458 --> 00:38:27,458
framework by Déjà Vu. And in the
solution ‑‑ this would be nice.
There are pit files. They're the

304
00:38:33,833 --> 00:38:39,750
descriptors, the descripting
files that you'll get to peach
in order the fuzz things. For my

305
00:38:39,750 --> 00:38:45,750
first demo, I'm going to use the
data publisher for android ADB.

306
00:38:54,260 --> 00:38:58,500
I'm using a prepaid Android phone.

307
00:39:01,940 --> 00:39:06,860
Again, to do this, you
need to replace the driver of
the libUSB requires you to

308
00:39:06,860 --> 00:39:12,958
replace the driver. We give you
ring three access to the ring
zero driver to talk to any

309
00:39:12,958 --> 00:39:22,238
device you want. If I look at
the android ADB pit file, all
I'm sending to the device is

310
00:39:22,250 --> 00:39:32,667
CNXN and host. Two first values
you need to send to an ADB
indicating for the new android,

311
00:39:32,667 --> 00:39:37,292
you need to secure
authentication and all that. So
to keep it simple, these are the

312
00:39:37,292 --> 00:39:43,958
values that this example sends.
And if it works, we should get a
reply from the phone.

313
00:39:57,860 --> 00:40:03,860
I'm going to run peach. I'm going to
do a dash one because I want to run
an iteration. In the description

314
00:40:03,958 --> 00:40:09,833
it says if you're missing it
dash font performs a single
iteration. Which is going to be

315
00:40:09,833 --> 00:40:15,042
run without fuzzing. Whatever
value its set to it'll run for
this example ‑‑ ‑‑ dash dash

316
00:40:15,042 --> 00:40:21,042
debug so I can see the debug
outputs from the publishers I've
written from this. So you can

317
00:40:21,042 --> 00:40:30,122
run this on any android phone
without using a sniffer and you
can see if you get a response or not.

318
00:40:37,780 --> 00:40:41,340
Hopefully this works.

319
00:40:43,140 --> 00:40:52,792
 Here we go. So we sent
CNXN host. And we
got that, CNXN device. Show you

320
00:40:52,792 --> 00:41:00,500
I'm not lying. I have a sniffer
here. And total phase 480 that
we talked about. And I'm going

321
00:41:00,500 --> 00:41:06,167
to run now on the line. And I'm
going to run this thing again
and turn on the sniffer and

322
00:41:06,167 --> 00:41:10,625
you'll be able to see we're
sending CNXN host. And we're
getting back from the device

323
00:41:10,625 --> 00:41:18,265
CNXN. You know Peach, you can
take it from here, if you don't,
pick it up. It's really nice.

324
00:41:20,167 --> 00:41:29,967
Are we on time? Ooh four
minutes. That was android. Now,
the same thing for iPhone. A

325
00:41:32,583 --> 00:41:40,542
little bit of different
technique. ADB is based on data.
Data transfers. The iPhone is

326
00:41:40,542 --> 00:41:42,322
more of a controlled transfer.

327
00:41:47,080 --> 00:41:50,320
 I need to put the iPhone in
recovery mode. One second.

328
00:42:02,708 --> 00:42:07,500
If you have any questions, this
would be the time. >> Where do
babies come from? (Laughter)

329
00:42:07,500 --> 00:42:13,500
>> I don't know. >> Why do you
put the iPhone in recovery mode?
>> Hum? >> Why do you put the

330
00:42:13,500 --> 00:42:21,417
iPhone in recovery mode? >> Umm,
this is the simplest example.
It's the coolest one. >> Are you

331
00:42:21,417 --> 00:42:28,458
aware of any software phase,
sniffers for Windows? >> There
are software solutions for

332
00:42:28,458 --> 00:42:36,000
Sniffing on windows. >> Anything
that's free? >> There are some
that are free. But there are

333
00:42:36,000 --> 00:42:42,000
some also that they look like
they're malware. (Laughing) .
>> Is there any sample security…

334
00:42:44,375 --> 00:42:50,375
secure software for downloading
a platform… (inaudible) >> Well,
like a, how to do it correctly?

335
00:42:57,583 --> 00:43:03,583
>> Like someone already wrote
it. This is the library you
should use. >> I don't know if

336
00:43:08,583 --> 00:43:15,125
there's a good like ‑‑ here's a
good place to go and use this
for your USB device. The other

337
00:43:15,125 --> 00:43:22,500
issue is just because these
are ‑‑ they're often low cost
devices. They aren't very high

338
00:43:22,500 --> 00:43:28,500
powered. Like an 8051, if you're
doing a full RSA 2048 algorithm
in that it might take a while to

339
00:43:31,750 --> 00:43:38,417
boot up and enumerate. So with
the USB spec, it's supposed to
be able to boot up as soon as

340
00:43:38,417 --> 00:43:43,708
you plug it in, I think it has a
hundred million seconds before
it can ‑‑ before it needs to be

341
00:43:43,708 --> 00:43:50,167
responding to requests on the
USB bus. But if you have
something that's really ‑‑ like

342
00:43:50,167 --> 00:43:57,958
a low powered device, it might
not have just the computational
power in order to do like a full

343
00:43:57,958 --> 00:44:04,208
signature check every time it
boots up. So the ‑‑ I think-- I
got 30 seconds. Keep going.

344
00:44:04,208 --> 00:44:11,875
>> Is your demo ready? >> Yeah.
Real quick, iPhone Demo. All
these files are on the CD. What

345
00:44:11,875 --> 00:44:18,708
I'm going to send to the
iPhone in recovery is this. Get
environment round disc size.

346
00:44:18,708 --> 00:44:24,708
Should this work, it should
return 40 K in hex. And I have
the Sniffer running.

347
00:44:32,833 --> 00:44:40,667
There. You're receiving in a buffer
40 K and a hex. 400 K, one
million. I don't know. But this

348
00:44:40,667 --> 00:44:47,750
is one of the commands being
sent to the iPhone in recovery
mode after a new image is being

349
00:44:47,750 --> 00:44:53,708
uploaded to the ‑‑ before
firmware images uploaded to the
phone. It's one of the commands

350
00:44:53,708 --> 00:45:00,958
that you get. So from the demo,
you could do this with iPhone.
Control transfers or any other

351
00:45:00,958 --> 00:45:09,917
thing that the ‑‑ ten seconds,
the other example on the CD is
for this USB land dongle, you

352
00:45:09,917 --> 00:45:15,708
just change the VIDPID to
whatever matches your hardware.
And use control transfers

353
00:45:15,708 --> 00:45:21,508
according to the spec you have
and you can do it yourself. And
that is it. (Applause.) Thank you.

