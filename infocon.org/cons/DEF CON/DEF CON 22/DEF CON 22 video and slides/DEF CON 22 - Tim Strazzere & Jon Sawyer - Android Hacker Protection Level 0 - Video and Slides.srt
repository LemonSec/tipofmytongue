1
00:00:00,125 --> 00:00:04,583
 >> Hi everyone, thank you for
coming out. Welcome to  Android
Hacker Protection Level 0, and

2
00:00:04,583 --> 00:00:10,250
as of 24 hours ago, some black
phone stuff that we're going to
demo that this guy had lots of

3
00:00:10,250 --> 00:00:17,583
fun with. So just a quick who
are we, this guy is Jay Case, I
am Diff. This is proof we are

4
00:00:17,583 --> 00:00:22,208
not the same person. Many people
thought that for many years that
we are the same exact person.

5
00:00:22,208 --> 00:00:27,958
He's CTO of Applied
Cybersecurity, he's basically an
expert troll, finds lots of

6
00:00:27,958 --> 00:00:31,875
stuff and has the biggest mouth
in android is basically what
we're saying. There's github,

7
00:00:31,875 --> 00:00:39,083
that's his Twitter, I think he
beat Dan Rosenberg, so keep
following him. >> I am an

8
00:00:39,083 --> 00:00:45,000
Obfuscation Junkie, I work at
Look Out Mobile Security, I do
research and response. I pretend

9
00:00:45,000 --> 00:00:48,417
to know as much as this guy.
That's also my github. >> Why
are we here? If you Google

10
00:00:48,417 --> 00:00:56,375
around and look for android
protection, a lot of people are
Googling, how I protect my game,

11
00:00:56,375 --> 00:01:00,250
I don't want to be hacked, I
don't want Malware injected into
this. I don't understand this

12
00:01:00,250 --> 00:01:06,292
stuff. All obfuscators are not
created equal. Well if you look
at stuff, people are like, well

13
00:01:06,292 --> 00:01:10,083
what's a hacker
protection factor? That's just a
marketing term somebody made up.

14
00:01:10,083 --> 00:01:16,083
His obfuscator had a hacker
protection level of 35, awesome.
35 levels of protection, that

15
00:01:18,500 --> 00:01:23,917
means nothing. >> We wanted to
demystify, obfuscation is not
that magical. You have to

16
00:01:23,917 --> 00:01:30,208
identify what's going on, is it
a known packer, obfuscator,
protector, what will you be able

17
00:01:30,208 --> 00:01:38,125
to do? Also we wanted to be able
to look at this. At Look Out, we
do anti‑ malware and what you

18
00:01:38,125 --> 00:01:42,458
see a lot in the news is people
say "the most sophisticated
thing in the world just came

19
00:01:42,458 --> 00:01:44,458
out." They used a commercial
packer and they didn't even
actually notice that that was a

20
00:01:44,458 --> 00:01:46,458
commercial packer and they
didn't actually do anything that
sophisticated. But they bought a

21
00:01:46,458 --> 00:01:50,625
product that did it form them.
They are really bad attackers,
and they are not. You have to

22
00:01:50,625 --> 00:01:56,625
just realize what you are
dealing with, we wanted to take
a look at that. >> This is

23
00:02:00,583 --> 00:02:06,375
mainly for educational purposes,
good people use these and we are
not suggesting you go out and

24
00:02:06,375 --> 00:02:10,750
crack all the games that are
doing this stuff but bad
developers use these tools as

25
00:02:10,750 --> 00:02:17,000
well to inhibit people like us
trying to analyze malware and
see like are people using

26
00:02:17,000 --> 00:02:23,083
exploits, are they stealing your
contacts, what is going on? So
it is very educational to be

27
00:02:23,083 --> 00:02:29,000
able to know how these type of
systems work and how to pull
them apart. >> So what's out

28
00:02:29,000 --> 00:02:33,500
there? About two years ago I
gave a talk, it was Dex
Education 101, the slides are

29
00:02:33,500 --> 00:02:36,958
still online from BlackHat 201.
There's a lot of proof of
concepts out there, and a lot of

30
00:02:36,958 --> 00:02:42,958
anti‑ decompilation tricks,
anti-analysis tricks, we just
demoed one of the preliminary

31
00:02:46,708 --> 00:02:54,375
Dalvik unpackers. Pretty cool. A
lot of people start integrating
these into little one‑ off tools

32
00:02:54,375 --> 00:03:01,250
that will brick bahksmali,
dex2jar, and IDA Pro. So it's
really great. Since we have

33
00:03:01,250 --> 00:03:05,833
tried to find a lot of these
things to break all the tools,
we got a lot of patches

34
00:03:05,833 --> 00:03:10,958
submitted, a lot of open‑ source
tools and tools you can find
online are already patched and

35
00:03:10,958 --> 00:03:17,208
you can't actually break them as
easily anymore. Now that these
tools have caught up people are

36
00:03:17,208 --> 00:03:24,375
starting to use packer and
protectors. I will explain that.
It makes it so you can't do

37
00:03:24,375 --> 00:03:32,208
static analysis. You have to do
run‑ time analysis or go through
hoops to unpack some code. But

38
00:03:32,208 --> 00:03:40,083
the current tools will stand up
against the tiny tricks we
demoed in the past. >> What are

39
00:03:40,083 --> 00:03:47,375
packer and protectors? Hopefully
you know a little about
obfuscators, going to take what

40
00:03:47,375 --> 00:03:53,667
you write as a developer, get
obfuscated, look a little
different and hopefully be

41
00:03:53,667 --> 00:04:00,375
harder for someone to reverse
your compiled code back to what
you started with. This is an

42
00:04:00,375 --> 00:04:06,500
example, basically, this is an
optimizer/obfuscator. It's
really good, everyone... you

43
00:04:06,500 --> 00:04:13,208
know, Google says you should be
running this, like Pro guard
and  look into more obfuscation.

44
00:04:13,208 --> 00:04:18,750
Essentially, the code on top is
what you would be writing
yourself. So basically its a

45
00:04:18,750 --> 00:04:24,292
reflection statement doing a
system exit and on the bottom,
that's actually when obfuscator

46
00:04:24,292 --> 00:04:30,375
will try to turn that into, as
you can see it doesn't look that
nice to look at. We can see

47
00:04:30,375 --> 00:04:36,375
function calls with really funky
names, special characters for
the actual... so you get the

48
00:04:38,667 --> 00:04:44,667
class name, looks like con, and
you get the special character
for actual function, passing

49
00:04:50,000 --> 00:04:56,000
other things, calling an
encryption method to decrypt,
excuse me, its a decryption

50
00:04:59,083 --> 00:05:03,500
method to decrypt what the
actual string is supposed to be.
You can't see Java link system

51
00:05:03,500 --> 00:05:06,500
anymore because they encrypted
that and pulled it out. So if
you were just running strings on

52
00:05:06,500 --> 00:05:09,708
the file, you won't see these
type of calls. You will have to
go in, decrypt manually. >>

53
00:05:09,708 --> 00:05:12,375
Protectors, this is what
we dubbed. It's similar to a
packer, but you will have your

54
00:05:12,375 --> 00:05:14,792
stub application. That's what
the protector is actually
injecting. They break your code

55
00:05:14,792 --> 00:05:20,583
so when someone is statically
analyzing your application it
just looks like it's all broken,

56
00:05:20,583 --> 00:05:25,833
all the tools will skip over
this is bad I will insert an
Opp. This is an invalid call,

57
00:05:25,833 --> 00:05:30,292
not going decompile that. They
just don't understand what's
going. You run this on your

58
00:05:30,292 --> 00:05:37,542
phone, the stub application will
fix the broken code in memory.
When the actual application hit

59
00:05:37,542 --> 00:05:43,542
that's code we originally
thought was broken, and didn't
analyze, it will be able to run

60
00:05:45,542 --> 00:05:52,042
fine. It's protecting your
application from static analysis
but supposedly works on the

61
00:05:52,042 --> 00:05:58,042
actual system. >> This is for
normal packer, like the scheme
of UPX or other X86 packers, sub

62
00:06:00,167 --> 00:06:06,375
application and that is wrapping
the hidden and sometimes
encrypted code. Once it's

63
00:06:06,375 --> 00:06:13,083
executed the stub application
launches, will unpack, decrypt,
put into memory the actual

64
00:06:13,083 --> 00:06:18,292
executable code you want and
proxies everything so when the
system says this is what the

65
00:06:18,292 --> 00:06:22,542
user is sending to your
activity, it just proxies the
actual code, which is normally

66
00:06:22,542 --> 00:06:29,125
hidden from that static
analysis. >> I will throw it
over to my buddy, JCase, for

67
00:06:29,125 --> 00:06:35,000
optimizers and obfuscators. He
is not actually
throwing anything by the way. >>

68
00:06:35,000 --> 00:06:42,958
Yesterday I was supposed to do
all these slides for this
yesterday but instead of doing

69
00:06:42,958 --> 00:06:49,583
that, I bought a black phone
which took up yesterday.
Optimizers and obfuscators.

70
00:06:49,583 --> 00:06:56,417
Proguard is pretty much what I
am going to talk about first, de
facto standard for Android.

71
00:06:56,417 --> 00:07:02,542
After I did a write up on
breaking their licensing system,
Google packed it in their SDK.

72
00:07:02,542 --> 00:07:08,542
So most Android Apps use it.
It's about eight years older
than android, created by Eric la

73
00:07:11,333 --> 00:07:17,333
Forte, especially designed for
Java, recommended by Google,
optimizes code, shrinks code,

74
00:07:21,333 --> 00:07:27,333
obfuscates code. Cool part is
it's free, will reduce the size
of the app, you can get more app

75
00:07:29,917 --> 00:07:36,833
on the phone. Does a pretty good
job of making things faster,
removes a lot of garbage code,

76
00:07:36,833 --> 00:07:42,833
if you write bad code it kind of
looks better when you reverse
it. Yeah, it removes

77
00:07:45,875 --> 00:07:51,875
unnecessary, unused code, merges
identical code blocks and, and
Peep hole optimizations, removes

78
00:07:55,292 --> 00:08:00,500
debug information which makes it
easier to understand what you
are reversing. Can rename

79
00:08:00,500 --> 00:08:06,500
objects, mildly annoying,
and restructures code. On the
slide here on the left‑ hand

80
00:08:10,792 --> 00:08:18,542
side is application that has not
been protected with an
obfuscator at all. It's actually

81
00:08:18,542 --> 00:08:25,125
and Android exploit i wrote. You
see the PayPal SDK which has
been obfuscated. On the right‑

82
00:08:25,125 --> 00:08:28,708
hand side is the same APK, same
exploit with Proguard and
primary difference here is

83
00:08:33,625 --> 00:08:37,833
classes are renamed and instead
of saying hey this is a
utilities class you have E. This

84
00:08:37,833 --> 00:08:43,833
is a Proguard, I am removing
some of the debug information,
like the source name, source

85
00:08:52,625 --> 00:09:00,083
file. Typically when you compile
classes the source will tell you
the file name that it originally

86
00:09:00,083 --> 00:09:05,250
came from. A lot of obfuscators
will completely remove it or
insert false data. >> The false

87
00:09:05,250 --> 00:09:11,250
data ones can be pretty
annoying, but otherwise pretty
simple. Another thing that Pro

88
00:09:16,500 --> 00:09:22,208
guard, most obfuscators do is
remove line numbers, your stack
traces will be rather confusing,

89
00:09:25,125 --> 00:09:32,875
reduces the size of the decks,
but not too big of a deal. Pro
guards data is pretty easy. >>

90
00:09:32,875 --> 00:09:39,083
Here's an example of a method
that will actually give shell
commands, on left‑ hand side we

91
00:09:39,083 --> 00:09:45,083
have the original source and
right‑ hand side the decompiled
Proguard protected output. >> As

92
00:09:48,458 --> 00:09:52,167
you see, it's pretty easy to
understand if you
understand Java, it's not too

93
00:09:52,167 --> 00:09:58,167
strange. >> Proguard, what's it
good for, pretty much nothing
except making the app smaller,

94
00:10:02,375 --> 00:10:10,250
faster. Doesn't provide
obfuscation, anybody who
recommends it for obfuscation,

95
00:10:10,250 --> 00:10:14,958
is a little bit out there. I
have heard over and over, app
developers say well I am

96
00:10:14,958 --> 00:10:20,750
protecting my app with this, it
does nothing to stop reverse
engineering. It has a Hacker

97
00:10:20,750 --> 00:10:26,750
Protection Factor of zero. >>
This I would like to talk about,
favorite subject of mine.

98
00:10:28,875 --> 00:10:35,667
Dexguard is a commercial version
of Proguard by the same author,
pretty standard, but incredibly

99
00:10:35,667 --> 00:10:39,542
scary looking for somebody that
doesn't know better. It
optimizes shrinks, and does a

100
00:10:39,542 --> 00:10:46,958
pretty decent job of obfuscating
and encrypting but not going to
stop reverse engineering,

101
00:10:46,958 --> 00:10:48,958
somebody with a background at
all. >> It does pretty much
everything Proguard does, adds

102
00:10:48,958 --> 00:10:54,958
automatic reflection, will take
your standard API calls. And by
reflection, this can screw with

103
00:11:06,625 --> 00:11:12,625
automatic analysis, make it a
headache to look at, makes your
app quite a bit slower. >> It

104
00:11:14,667 --> 00:11:19,750
does streaming encryption, makes
the app confusing, scary if you
don't know what you are looking

105
00:11:19,750 --> 00:11:27,708
at, and slows that down. Can
provide access, embedded asset
files for the app or does

106
00:11:27,708 --> 00:11:34,500
library encryption. Pretty
simple, slows the app down,
especially in the case

107
00:11:34,500 --> 00:11:39,083
of library which doesn't do
anything, because they has
beyond this which is encrypted.

108
00:11:39,083 --> 00:11:45,667
Once they're on a disk we just
pull them anyways. Class
encryption, taking the original

109
00:11:45,667 --> 00:11:52,667
class file, encrypting, put
inside the decks, and it does
tamper detection as well, which

110
00:11:52,667 --> 00:11:57,917
I will not cover much because if
you are looking at malware we
don't really  care too much

111
00:11:57,917 --> 00:12:03,375
about tamper detection. >>
Here's an example of the
reflection and stream

112
00:12:03,375 --> 00:12:10,625
encryption, the top field will
have the standard API  call
system to exit. The middle field

113
00:12:10,625 --> 00:12:14,042
is the same call but using
reflection so its a little bit
more confusing, a little bit

114
00:12:14,042 --> 00:12:21,333
larger, so your deck file size
increases and the bottom is the
reflection and a stream

115
00:12:21,333 --> 00:12:27,333
encryption which provides
no hint to actually what it's
doing. >> Here's an example of

116
00:12:30,375 --> 00:12:36,000
the streaming encryption, the
top tool shows an android
2.3 exploit that would cause a

117
00:12:36,000 --> 00:12:42,000
device to reboot from no
permissions. The middle field
shows how the dexguard or

118
00:12:45,500 --> 00:12:52,750
streams are encrypted... all the
streams in the class file are
stuck in a byte ray after being

119
00:12:52,750 --> 00:12:58,750
encrypted. The bottom field is
the exploit to reboot the system
with the streams encrypted. >>

120
00:13:05,542 --> 00:13:12,917
So here's a decryption method on
the left‑ hand side, original
one and right‑ hand side the

121
00:13:12,917 --> 00:13:18,917
obfuscated one. Pretty simple.
XML encryption, but I know how
code works. You delete the

122
00:13:22,125 --> 00:13:28,125
character and position and will
decrypt the string... in the
right field, byte ray... I am a

123
00:13:32,875 --> 00:13:39,417
little nervous, I have never
spoken at one of these, so
excuse me. The asset library

124
00:13:39,417 --> 00:13:45,417
encryption is pretty simple too.
It's AES and the key and IB are
in pretty much plain text right

125
00:13:49,875 --> 00:13:55,875
in front of you. Extracted and
encrypted asset decrypted,
writes a disk or do whatever you

126
00:13:58,417 --> 00:14:06,000
want with it. Pretty simple,
just a few seconds to undo.
Class Encryption is pretty much

127
00:14:06,000 --> 00:14:08,708
the same thing. It packs the
original class in a zip file,
encrypts it, stores it in the

128
00:14:08,708 --> 00:14:14,708
main class, uses AES. It will
store... you will have three
large byte rays... I didn't have

129
00:14:21,417 --> 00:14:29,208
enough room for more Google
slides plus I was hacking the
black phone. It'll have three

130
00:14:29,208 --> 00:14:35,208
large byte rays and two small
ones. The two small are IV and
key and the first large is all

131
00:14:37,500 --> 00:14:43,250
the streams which we really
don't care about. The second is
a class and third is a class.

132
00:14:43,250 --> 00:14:49,167
Second is decrypted using
reflection to run it. When they
run it it will provide a new key

133
00:14:49,167 --> 00:14:54,542
and a new IV. They they decrypt
the third one. Automatic
unpackers will do this in a

134
00:14:54,542 --> 00:15:00,542
matter of seconds, provides no
real protection but will scare
most, average pirates away. >>

135
00:15:04,417 --> 00:15:11,208
This is actually how I was
decrypting them. He will append
the strain to the head of

136
00:15:11,208 --> 00:15:17,875
the zip file so after you
decrypt it you will need to find
the header, and then you can

137
00:15:17,875 --> 00:15:23,458
write the disk. I have an
automatic unpacker that will be
on my github. It's currently

138
00:15:23,458 --> 00:15:31,083
broken with Java 8, I decided to
work with the black phone
instead of fix it. >> Dexguard,

139
00:15:31,083 --> 00:15:38,750
I like it, I bought it, after
seeing Russian malware with it,
I emailed the author, he said

140
00:15:38,750 --> 00:15:43,500
reverse it, I said I already
reversed it, here's the samples
of the malware, I would like to

141
00:15:43,500 --> 00:15:49,708
buy it I want to use it in my
product. I bought it for some
ridiculous amount of money, I

142
00:15:49,708 --> 00:15:55,625
ended up releasing an app
connected with it and the source
to it, he was kind of a little

143
00:15:55,625 --> 00:16:00,833
bit of a jerk, canceled my
license for a few months.
Thought I was helping the

144
00:16:00,833 --> 00:16:07,167
hacking community by releasing
the source to an app that had
been obfuscated with it. I won't

145
00:16:07,167 --> 00:16:13,042
recommended buying it if you
plan doing an app, but you just
want to protect your average

146
00:16:13,042 --> 00:16:20,542
application, it's pretty good,
it will annoy most people. >> It
has some down sides and some

147
00:16:20,542 --> 00:16:28,500
ups. May increase the dex
file size, string encryption,
reflection, makes the dex file

148
00:16:28,500 --> 00:16:35,708
bigger, slower, takes up more
space on your phone. Especially
the reflection string encryption

149
00:16:35,708 --> 00:16:41,500
will slow down the application
if you use it too much, so if
you're going to use it, use it

150
00:16:41,500 --> 00:16:48,208
just on the important parts.
Don't go obfuscating the open‑
source library that ridiculous,

151
00:16:48,208 --> 00:16:54,208
but a lot of developers do. >>
Removes debug information,
automatic string encryption

152
00:16:54,208 --> 00:17:00,208
which is a pretty decent
automatic class access...
library asset encryption. Pretty

153
00:17:04,458 --> 00:17:10,833
much the best and most annoying
feature, automatic reflection,
pretty scary once they do the

154
00:17:10,833 --> 00:17:18,167
reflection the stream encryption
you can't look and see what it's
doing. >> Moderately priced as

155
00:17:18,167 --> 00:17:24,167
far as obfuscators go but pretty
expensive still. Easy to use,
you reverse by hand within a few

156
00:17:26,708 --> 00:17:32,708
hours, automatic unpacking in a
matter of seconds. While the
author gives a hacker protection

157
00:17:35,458 --> 00:17:43,333
of 35, we're going to give it a
one today. [Laughter] He might
actually punch me if he ever

158
00:17:43,333 --> 00:17:49,333
sees me. >> Allatori isn't as
good as Dexguard. I like it a
lot better. I emailed the

159
00:17:51,458 --> 00:17:57,708
authors, they gave me a free
license which was really cool.
If you have a .edu email and

160
00:17:57,708 --> 00:18:04,042
have an academic purpose they
will kick you one, originally
designed for plain Java but

161
00:18:04,042 --> 00:18:10,042
works fine in Android Java. It's
an obfuscator, water marker,
it's priced in the lower end of

162
00:18:13,542 --> 00:18:19,542
290. Free academic license if
you have an "edu" e‑ mail
address, hit them up. It doesn't

163
00:18:21,542 --> 00:18:27,625
do as much as Dexguard, but it
does name obfuscation by
changing the class names,

164
00:18:27,625 --> 00:18:33,625
controls flow obfuscation,
debugging obfuscation and string
encryption. >> Here's another

165
00:18:38,125 --> 00:18:45,833
part from one of my exploits.
You see I am checking to see if 
the file exists. If it exists, I

166
00:18:45,833 --> 00:18:53,792
do something. The bottom field
is the same as the first, but
now with the string encryption.

167
00:18:53,792 --> 00:18:59,417
On the left‑ hand side is the
standard Allatori string
encryption, it's pretty simple.

168
00:18:59,417 --> 00:19:05,417
The bottom part is the
obfuscated, run the stream
through and you get

169
00:19:07,875 --> 00:19:14,333
your original string. Again,
quite simple like most
obfuscates are. >> Free for

170
00:19:14,333 --> 00:19:19,417
educational use, tends to
increase the dex file size more
than Dexguard because Dexguard

171
00:19:19,417 --> 00:19:27,167
inserts all the extras. Also
increase the app speed  a bit
unless you're using heavy

172
00:19:27,167 --> 00:19:33,167
encryption, just like Proguard,
Dexguard, removes bug
information and doesn't do much

173
00:19:35,750 --> 00:19:39,875
in the way of obfuscation. The
authors are pretty cool
especially giving a reverse

174
00:19:39,875 --> 00:19:45,875
engineer a free license. Easier,
give a .5 on the  Hacker
Protection Factor but again, I

175
00:19:48,417 --> 00:19:54,417
support them. >> Thank you for
listening. >> Thank you. >>
[Applause] >> I see a couple of

176
00:20:01,917 --> 00:20:07,917
people taking pictures. It's
small up there, but we will
release the slides, you don't

177
00:20:13,208 --> 00:20:20,292
need to take pictures feel free
to keep doing it if you want
though. >> On to Protectors.

178
00:20:20,292 --> 00:20:26,667
This is really fun. You may have
run across it if you are looking
for malware or just happen to

179
00:20:26,667 --> 00:20:31,917
love looking at Chinese
applications, they love this
one. Chinese protector, made in

180
00:20:31,917 --> 00:20:37,542
China, obviously, multiple
iterations of it, you may know
it as APKProtect, but maybe you

181
00:20:37,542 --> 00:20:44,625
know it as or have seen it as
APKProtect, Lite, PC, Advanced
there's probably like retro in

182
00:20:44,625 --> 00:20:48,625
there. There's also DexCrypt for
awhile, where it was just a
script and he was letting people

183
00:20:48,625 --> 00:20:55,292
download it. It appears to be
active, but hard to tell who is
using it. The site is now

184
00:20:55,292 --> 00:21:03,042
nonfunctional. There are Chinese
clones now with similar
techniques and websites almost

185
00:21:03,042 --> 00:21:09,042
identical. It's hard to tell who
is doing what. >> The cost seems
to be free, but also really

186
00:21:11,917 --> 00:21:18,917
expensive, but again, you can't
go order it anymore, just goes
to a PHP crash site but you can

187
00:21:18,917 --> 00:21:26,417
try, maybe drop the source or do
something like that. It's very
similar to a packer, I gave that

188
00:21:26,417 --> 00:21:32,542
little demo where it's a sub
application with a mangled code
inside. But unlike the... the

189
00:21:32,542 --> 00:21:38,542
packer does not do mangled code
where this protector does. There
are bug detectors, they have

190
00:21:41,042 --> 00:21:47,083
bugs in and anti‑ decompiling
which is the main code. You
can't just run statically on

191
00:21:47,083 --> 00:21:51,708
that file. This essentially
looks like, it the top right
corner, that is what it is going

192
00:21:51,708 --> 00:21:55,875
to look like if you're just
going to try statically and you
don't understand what's going

193
00:21:55,875 --> 00:22:03,542
on, you will see, Bahksmali,
actually does decompile it or
disassemble but you will see

194
00:22:03,542 --> 00:22:07,875
lots of things like oh I don't
know where this is going, this
is a really high number, doesn't

195
00:22:07,875 --> 00:22:13,417
make sense, just drop it in the
comments, and they give you an
Op statement. On the bottom

196
00:22:13,417 --> 00:22:20,708
right hand corner we see the
Dalvik stub code. Essentially
this is the first line of code

197
00:22:20,708 --> 00:22:27,750
that the application is going to
hit when it runs. This is what
they are injecting into your

198
00:22:27,750 --> 00:22:34,042
application. We see end road
manifest on the left, there's a
package name, a piece of

199
00:22:34,042 --> 00:22:39,917
malware, you see package name
absolute garbage like that,
pretty much will be malware and

200
00:22:39,917 --> 00:22:47,042
sends us a mess. Surprising.
They injected APK main app one,
one, one, one, seven, seven.

201
00:22:47,042 --> 00:22:52,042
That's what will get hit first,
when a user executes or it's
going to be run. What happens,

202
00:22:52,042 --> 00:22:58,375
it goes over to that loader
stub, that loader stub will
actually, it's loading a shared

203
00:22:58,375 --> 00:23:05,417
library, some native code over
JNI and the actual part that
will do the anti‑ emulation

204
00:23:05,417 --> 00:23:12,583
check, anti‑ debugging and fixes
the broken stuff in memory. >> I
wrote some sudo code, hopefully

205
00:23:12,583 --> 00:23:18,875
you can read this and it's
legible. Essentially what's
going on here is the Dalvik,

206
00:23:18,875 --> 00:23:25,167
it's actual run time on the
phone, when you install, it will
optimize, it's called an O dex

207
00:23:25,167 --> 00:23:31,417
file. It takes that file and
optimizes it. That's where you
get an O dec from. It basically

208
00:23:31,417 --> 00:23:38,417
sees the bad parts, goes I don't
care about these, skip it, leave
it in memory and deal with it

209
00:23:38,417 --> 00:23:43,458
later. Doesn't look like it's
being run. Upon actual
execution, the stub loads, and

210
00:23:43,458 --> 00:23:49,250
it calls that a JNI on load
function there. Looking through,
there's anti‑ debug call

211
00:23:49,250 --> 00:23:56,083
attached to itself to try and
P-trace itself. This is an
attempt to basically say if I am

212
00:23:56,083 --> 00:24:00,875
P‑ tracing myself then nobody
else is in theory, is supposed
to be able to P-trace me, that's

213
00:24:00,875 --> 00:24:07,417
easy to get around. That's anti-
debug number 1, trying to find
its own O dex file, this is

214
00:24:07,417 --> 00:24:12,500
basically incase a reverser has
wrapped the application and
changed things around. They

215
00:24:12,500 --> 00:24:17,667
won't be able to find their own
O dex so that's an anti‑
analysis thread trick. If they

216
00:24:17,667 --> 00:24:24,750
detect you are doing this, go
into an endless loop, sit there,
causing IDA to hang. What it

217
00:24:24,750 --> 00:24:32,250
does next is it looks for the
QMUD process. So basically if
you are running this inside an

218
00:24:32,250 --> 00:24:38,167
emulator, all the emulators are
QMUD based, so it's looking for
the daemon. And the code on the

219
00:24:38,167 --> 00:24:44,500
bottom is actually what it is
doing. We released a hack that
can hide your emulator, all it

220
00:24:44,500 --> 00:24:51,500
is doing is it basically hashes
what the prockpid command is. So
it looks to see has that system

221
00:24:51,500 --> 00:24:57,917
been QMUD'ed? If it sees that in
the first, I believe thats going
to be 101 processes, it will

222
00:24:57,917 --> 00:25:03,125
crash, not going to let you run
this on an emulator, that's
their anti‑ emulation technique.

223
00:25:03,125 --> 00:25:08,000
And it will basically patch O
dex inside the memory. And all
it's doing is it is basically

224
00:25:08,000 --> 00:25:14,917
looking inside its' memory to
see where did the actual Dalvik
run time unpack this, grab it,

225
00:25:14,917 --> 00:25:20,667
do an M protect, so that it can
write it, fix that code in
memory and then re‑protect the

226
00:25:20,667 --> 00:25:27,333
memory. All we do to attack it
is... here's a little... this is
what you would see in static

227
00:25:27,333 --> 00:25:32,458
analysis and this is what you
see after running it. The
easiest way is to do this is

228
00:25:32,458 --> 00:25:36,708
just to forget static analysis
for a little bit of time and do
the hard work. All we need to do

229
00:25:36,708 --> 00:25:39,333
is basically let them decrypt in
memory, then detach to not the
original process, but a cloned

230
00:25:39,333 --> 00:25:43,333
process and then we can just
dump all of the memory and it's
all easy right there. You avoid

231
00:25:43,333 --> 00:25:51,000
all the QME stuff with an LD
preload hack. We have that on
our github. The clone processes,

232
00:25:51,000 --> 00:25:57,000
everyone forgets about those.
There's one process that's
protected and there's maybe 20

233
00:25:59,667 --> 00:26:06,208
that aren't. Let's choose one of
the 20 that are not. There is
more actual encryption in the

234
00:26:06,208 --> 00:26:13,125
dex file, this appears to be an
option so most people only have
the mangled code that gets

235
00:26:13,125 --> 00:26:19,125
unpacked into the memory, but
there is, looks like dex trip
style, a modified Base64

236
00:26:21,250 --> 00:26:29,042
encryption and it's using DES as
opposed to AES. Looks like this
guy threw this together,and

237
00:26:29,042 --> 00:26:34,500
encrypted some strings. Just
dumped that from memory, you
still need to do more reversing,

238
00:26:34,500 --> 00:26:39,583
it's not going to be just a
normal... like the virgin code
that was used from before being

239
00:26:39,583 --> 00:26:45,583
repacked. >> It's really fun,
awesome, really great example of
someone trying to think outside

240
00:26:48,583 --> 00:26:56,167
the box. Haven't been many
changes in the product, at least
in applications I have seen in a

241
00:26:56,167 --> 00:27:02,375
while. There are tons of people
using this, if you want to take
a stab at looking at your first

242
00:27:02,375 --> 00:27:07,125
protector, this is a great one,
loader stuff is easy to follow.
They didn't obfuscate the native

243
00:27:07,125 --> 00:27:13,125
binaries much. You won't have to
go through hoops of rebuilding
import tables or any of that

244
00:27:15,667 --> 00:27:21,917
stuff. There's logging
statements they left in. You
will be able to go through and

245
00:27:21,917 --> 00:27:27,833
see stuff. It's really great for
beginners to try to get their
heads wrapped around. >> The

246
00:27:27,833 --> 00:27:33,208
interesting part about
protectors and packers, they are
hard once, once you figure out

247
00:27:33,208 --> 00:27:38,125
what they are doing you can
ignore them the rest of your
life. You never have to look at

248
00:27:38,125 --> 00:27:45,000
this guy once you have done it
once, unpack from memory, you
are good. Obfuscators tend to,

249
00:27:45,000 --> 00:27:52,000
their encryptions get munched a
bit, start changing, each
developer has a little different

250
00:27:52,000 --> 00:27:57,667
build, they all look a little
different. This is pretty much
cookie‑ cutter for every single

251
00:27:57,667 --> 00:28:04,208
application that you find. I
gave it a hacker protection of
3. Technically no public

252
00:28:04,208 --> 00:28:11,000
documentation on how to unpack
this, until today I guess, so
that's good. Maybe it goes down

253
00:28:11,000 --> 00:28:17,208
to 1 now, I am not sure. It's
fun to look at, does a pretty
good job and works pretty well

254
00:28:17,208 --> 00:28:24,208
for commercial product
apparently. >> Moving to
packers, I love beating up on

255
00:28:24,208 --> 00:28:30,167
this one. The guy's a nice guy,
left a couple functions in there
for me, he actually has one that

256
00:28:30,167 --> 00:28:34,125
says, "Hi, Tim," because I
always reverse , then tweet
about it and give him crap about

257
00:28:34,125 --> 00:28:40,875
it. It's really easy to hack
this HoseDex2Jar. Excellent, we
needed this. [Laughter] >>That's

258
00:28:40,875 --> 00:28:45,125
what I like to hear. >> I will
take a little break I guess. >>
I disagree that I need this. I

259
00:28:45,125 --> 00:28:48,375
am quiet good, from the fun from
yesterday. >> This will help. >>
Everybody loves Jack. [Laughter]

260
00:28:48,375 --> 00:28:51,458
>>You can keep going. >>Okay,
this was a proof of concept. I
believe he's a  security...

261
00:28:51,458 --> 00:28:54,375
>>Okay, stop. >> Okay.
[Laughter] >> You know, out of
all the rooms, this one is

262
00:28:54,375 --> 00:28:57,833
always the best at showing the
love. So... [Applause ] >> Thank
you, guys. You can just leave

263
00:28:57,833 --> 00:29:01,333
the bottle. >> Nice try, I
thought about that for a second.
>> Okay you guys are nice, but

264
00:29:01,333 --> 00:29:06,500
yeah thanks. So this guy was a
security consultant and I
believe was just doing this as a

265
00:29:06,500 --> 00:29:12,500
pitch to say look, I broke all
these decompilers and you should
maybe hire me or something. I am

266
00:29:40,792 --> 00:29:46,792
not sure, it was really not
pushed as a good commercial tool
and really doesn't work that

267
00:30:01,250 --> 00:30:06,500
well. It's a great proof of
concept, though. It uses the
exact same "Dexception" attack

268
00:30:06,500 --> 00:30:12,292
that I outlined in the dex
education 101. Cost was free but
it appears to be offline now,

269
00:30:12,292 --> 00:30:18,708
they took down the site. Just as
an outline of how this would
work, writing code, normal

270
00:30:18,708 --> 00:30:23,625
stuff, package up you APK, go to
their cloud service and their
close service just bundles it

271
00:30:23,625 --> 00:30:26,208
and passes it back to you, you
need to re‑sign, having the stub
application. The only little

272
00:30:26,208 --> 00:30:32,208
trick this is doing is actually
stuffing it inside the dex
header, the actual thing I

273
00:30:35,625 --> 00:30:41,625
demoed at BlackHat. So if we go
over it. Detecting this was
really easy. This is an ONL

274
00:30:43,667 --> 00:30:47,583
editor , with a colorized dex
template, going down with it,
this is like my favorite tool in

275
00:30:47,583 --> 00:30:53,000
the world for forensic stuff on
Dex. But it makes its really
easy. You see red sections, and

276
00:30:53,000 --> 00:30:57,792
it says wow, something is wrong
here. Clearly it looks like
something is encrypted right

277
00:30:57,792 --> 00:31:02,042
after that header file. If
you've ever looked at a dex
file, it just doesn't look

278
00:31:02,042 --> 00:31:08,750
normal and the red should
highlight that. >> You can see
the header size, normally 70 hex

279
00:31:08,750 --> 00:31:14,750
bytes is huge. So clearly
something has been injected.
Easy to see. >> All this will do

280
00:31:18,208 --> 00:31:25,417
is static analysis will not
really work because you will see
this encrypted file, just run

281
00:31:25,417 --> 00:31:30,750
the tool against it, it ignores
the encrypted file, throws it
away, you can see in the loader

282
00:31:30,750 --> 00:31:36,667
stub so you'll see two classes
in there. What happens in
memory, goes to optimized dex

283
00:31:36,667 --> 00:31:42,667
file, has the encrypted file,
the interesting and secure thing
this guy does, decrypts in

284
00:31:46,208 --> 00:31:53,458
memory and drops on the file
system unencrypted, so yeah,
just grab it after it runs if

285
00:31:53,458 --> 00:31:58,875
you want. That's your unpacker.
>> As a joke, this whole thing
was supposed to be HoseDex2Jar.

286
00:31:58,875 --> 00:32:06,500
We wrote a tool where we used
Dext2Jar on loader stub and
wrote Java around it to use his

287
00:32:06,500 --> 00:32:13,083
own code to decrypt his code,
like a nice jab back at him and
I haven't seen the next

288
00:32:13,083 --> 00:32:18,750
iteration of his tool but it's
always good to throw things back
and forth at each other. >> That

289
00:32:18,750 --> 00:32:25,667
one is really good, simple. If
you have never written a packer,
don't understand what a packer

290
00:32:25,667 --> 00:32:30,125
is, you can go check this one
out, it's a good one to look at.
It's easy to reverse, it has

291
00:32:30,125 --> 00:32:35,167
been documented on twitter by us
and a couple other people who
want to troll him more. It's

292
00:32:35,167 --> 00:32:38,000
easy to automate and unpack.
I've only seen it once in the
wild, looked like someone was

293
00:32:38,000 --> 00:32:44,000
just testing, wrapping a piece
of malware, and uploading it to
virus total and everyone

294
00:32:48,583 --> 00:32:55,083
detected it anyway, so nobody
cared. >> Moving on, we see
Pangxie, which is a Chinese

295
00:32:55,083 --> 00:33:01,667
packer. This one is kind of
interesting, has fatal flaws,
and doesn't appear to be active

296
00:33:01,667 --> 00:33:07,250
anymore. There are quite a few
samples in the wild but don't
seem to be using it anymore. The

297
00:33:07,250 --> 00:33:13,625
author got bored or maybe
someone stole his code or
something, it follows patterns

298
00:33:13,625 --> 00:33:21,250
in Chinese packers. Again, this
one just doesn't appear to be
used anymore. Has anti‑ debug,

299
00:33:21,250 --> 00:33:29,000
anti‑ tamper, and looks like it
has other functionality they
just forgot to turn on and maybe

300
00:33:29,000 --> 00:33:33,625
stopped development of this.
It's interesting, though. >> The
cost, not sure, I can't find a

301
00:33:33,625 --> 00:33:37,667
website, my Chinese is not that
great. If you see one, let me
know, maybe nobody else can find

302
00:33:37,667 --> 00:33:43,667
the website and that's why no
one is using it. All the normal
part where they are basically

303
00:33:46,792 --> 00:33:53,375
giving you a stub application
that has encrypted dex file. I
am not sure if you are uploading

304
00:33:53,375 --> 00:33:58,500
to a cloud service, because
again I can't find their site
for any of this stuff. >> How

305
00:33:58,500 --> 00:34:04,500
this is working is relatively
simple, on the first execution
it goes into, says hey, is this

306
00:34:07,000 --> 00:34:13,250
my first time? Let's go to the
JNI, verifies integrity of the
encrypted package. When

307
00:34:13,250 --> 00:34:21,000
reversing you might get scared,
oh my gosh, its using AES, it
has encryption, but it's not

308
00:34:21,000 --> 00:34:26,042
actually doing anything with
that. Just checking a hash. Then
goes to checking the decryption

309
00:34:26,042 --> 00:34:32,917
of dex file, relatively
rudimentary, simple, on the next
slide we will see why. After

310
00:34:32,917 --> 00:34:40,000
it's done this once it keeps
this in memory and... or no,
excuse me, this one drops on to

311
00:34:40,000 --> 00:34:46,000
the file system, you can grab it
there and on the second
execution, it has already

312
00:34:46,000 --> 00:34:50,917
unpacked it, it's on the disk,
loading directly, and just
proxies everything over, using

313
00:34:50,917 --> 00:34:54,917
the  dex class loader. Which if
you are familiar with Java, it's
the same with the Java class

314
00:34:54,917 --> 00:35:00,917
load. AES is used but only for
the digest. Here's the basic
stub decryption. You see there's

315
00:35:04,500 --> 00:35:12,250
only one byte per key and some
magic going on, and that's your
fancy decryption. Just X-or

316
00:35:12,250 --> 00:35:18,250
everything, pretty easy to write
a static unpacker for this one,
you don't actually ever have to

317
00:35:21,125 --> 00:35:25,167
run it on a device, but if you
were to run it on a device, you
can actually see they are

318
00:35:25,167 --> 00:35:30,125
basically dumping out to data
data package name app dex
folder. That's going to have the

319
00:35:30,125 --> 00:35:36,125
folder with the encrypted and
the decrypted copy. You can grab
that, and here's an example of

320
00:35:38,167 --> 00:35:44,083
seeing that run. You see it,
gets the updex and you have the
classes that jar, and the dex

321
00:35:44,083 --> 00:35:50,417
file. No work really needed, I
guess. >> This one is
interesting. Slightly increased,

322
00:35:50,417 --> 00:35:56,417
use the stub encrypting, works
on almost all versions, I guess
it stopped working, I was

323
00:35:58,625 --> 00:36:04,292
testing on 4.4, it appears to
crash. It appeared to be not
actively maintained, probably

324
00:36:04,292 --> 00:36:10,792
never going back. Interesting
thing with this, since it's such
a simple packer you could likely

325
00:36:10,792 --> 00:36:15,208
just take it and hack your own
things in, you don't actually
need their tool since you know

326
00:36:15,208 --> 00:36:19,125
what they are doing for
encryption/decryption, you could
actually just change the keys

327
00:36:19,125 --> 00:36:25,125
just by patching it. Change that
Xor key, push your own encrypted
payload and without a source

328
00:36:27,292 --> 00:36:32,875
code you could start making your
own knock‑off Pangxie packer.
That would be a fun project to

329
00:36:32,875 --> 00:36:37,583
do. >> I gave this one a 1.5 on
the Hacker Protection Factor
because it was interesting, but

330
00:36:37,583 --> 00:36:42,208
I wish they didn't just dump it
on to the file system, kind of
boring, but it was a little more

331
00:36:42,208 --> 00:36:48,208
difficult than HoseDex2Jar. >>
This is one a lot of people talk
about online, a lot of people

332
00:36:51,083 --> 00:36:55,250
want to say, they post it
everywhere, saying we've
unpacked this. That's awesome.

333
00:36:55,250 --> 00:36:59,542
Now go away, we will never tell
you how to do it. That's why,
this is actually one of the

334
00:36:59,542 --> 00:37:05,417
inspirations for the talk, and
another part of that inspiration
was that they have a cloud

335
00:37:05,417 --> 00:37:12,250
service and are very adamant
about saying "we never let any
bad people use our packer." We

336
00:37:12,250 --> 00:37:18,583
will never pack anything bad, no
malware will come through and we
do our manual app with Google.

337
00:37:18,583 --> 00:37:24,875
That's great, but we found
plenty of malware using this.
But they are doing a good job,

338
00:37:24,875 --> 00:37:30,667
not tons, but there's definitely
malware getting through. As we
gave an example before, once you

339
00:37:30,667 --> 00:37:37,250
understand, you can inject your
own application. I am not saying
I have seen people do that but

340
00:37:37,250 --> 00:37:42,292
could easily be done by some of
these guys if they wanted to.
You can skip the cloud service

341
00:37:42,292 --> 00:37:48,958
check if you want to. This is an
interesting nuance of where we
are today in the industry, where

342
00:37:48,958 --> 00:37:55,417
people used to download UPX and
you can pack anything you want.
Now people say give it to me, I

343
00:37:55,417 --> 00:38:03,000
will check it out, send it back
to you, using the cloud service
to, via gateway, not let bad

344
00:38:03,000 --> 00:38:10,167
people use it, but bad people
are using it. >> The cost on
this is pretty phenomenal. I

345
00:38:10,167 --> 00:38:16,333
have heard higher estimates, but
I personally saw some of the
numbers are around $10,000 for

346
00:38:16,333 --> 00:38:19,583
this packer. That's pretty
beefy. It stopped working on
4.4, but for $10,000 I assume

347
00:38:19,583 --> 00:38:23,750
they will release an update
soon. This one has
anti‑debugging, anti-tamper,

348
00:38:23,750 --> 00:38:29,750
anti-decompilation and
anti-runtime injection. This is
fun, harder than the others.

349
00:38:37,208 --> 00:38:43,542
They hooked every single memory
object they used, use to re‑
open and rebuild their own

350
00:38:43,542 --> 00:38:48,250
import table, they have
encrypted all their own function
names. It's fun to go through. I

351
00:38:48,250 --> 00:38:54,250
don't have enough time to go
through every step, but
basically on the first execution

352
00:38:57,333 --> 00:39:02,917
in Dalvik, it hits the loader
stub that goes into a JNI 
anti-debug launch, essentially

353
00:39:02,917 --> 00:39:09,583
this is what is checking to see
am I being debugged? No.
Alright, I will start working in

354
00:39:09,583 --> 00:39:15,583
two more process and P traces
those two processes. These are
three processes running, talking

355
00:39:17,667 --> 00:39:24,125
to each other over P trace.
Won't be able to block their
calls to that, won't be able to

356
00:39:24,125 --> 00:39:28,750
read their data,. It gets kind
of annoying because they pass
information back and forth the

357
00:39:28,750 --> 00:39:34,750
entire time. >> One of those
forked applications is what ends
of decrypting the dex in memory

358
00:39:37,583 --> 00:39:43,417
so we're just going to let them
do that and grab out of memory,
we don't care what they are

359
00:39:43,417 --> 00:39:51,250
doing. This is an example, as
you launch the malware, you see
three processes start up.

360
00:39:51,250 --> 00:39:55,333
Normally you attach to the first
but you can't because they are
all talking to each other

361
00:39:55,333 --> 00:39:59,750
and they are all attached to
each other. Which is a nice
anti‑debug trick. Though again

362
00:39:59,750 --> 00:40:06,000
all those cloned processes at
the bottom, basically looking at
the original process saying what

363
00:40:06,000 --> 00:40:13,125
are your tasks? Cloned
processes, like Linux. What we
will be able to do, say all

364
00:40:13,125 --> 00:40:18,958
right, the top three are
attached, but none of the bottom
are, so attach to those, but

365
00:40:18,958 --> 00:40:25,208
basically if you were to do a
couple of core dumps, look for
optimized dex file in the

366
00:40:25,208 --> 00:40:32,542
memory, save you time. See the
encrypted stuff in memory, the
dot cache, classes by jar,

367
00:40:32,542 --> 00:40:38,333
classes of dex, still encrypted,
but right below, every single
time is where they are

368
00:40:38,333 --> 00:40:44,333
decrypted. No indication, but
the tool we wrote will start
sniffing the memory it says, is

369
00:40:46,375 --> 00:40:51,458
this APK protect or this guy
going to be bangle? It sees
bangle, which is going to go

370
00:40:51,458 --> 00:40:55,625
into memory, and grab it out.
And sine you control the device,
encrypts out, O dex file, you 

371
00:40:55,625 --> 00:41:01,917
will be able to de-O dex it with
bahksmali. The instructions are
on the bahksmali website, sounds

372
00:41:01,917 --> 00:41:07,917
like I am speaking Swedish, is
it Swedish? Norwegian. Something
like that. Icelandic. Thanks,

373
00:41:12,292 --> 00:41:20,250
Rob. >> If I am speaking a
different language, it's all
documented online, and the tool

374
00:41:20,250 --> 00:41:26,250
we will release a script does
this, really slow, a bad script
and we rewrote it in C and it's

375
00:41:29,417 --> 00:41:37,125
lots of comments, DEF CON 101,
so hopefully you guys can create
some unpackers. I really like

376
00:41:37,125 --> 00:41:41,167
bangle, its awesome. It's
probably going to be the most
advanced one you see out there.

377
00:41:41,167 --> 00:41:46,708
There are a couple more packers
emerging, you will see more.
Lots of Chinese ones seem to be

378
00:41:46,708 --> 00:41:53,500
knocking each other off using
the same string. Either someone
compromised someone's code or

379
00:41:53,500 --> 00:42:00,000
someone sold it to everyone at
wholesale but this is really fun
and they actively develop it

380
00:42:00,000 --> 00:42:06,792
with that huge price tag they
will keep on and once they see
this talk they will maybe move

381
00:42:06,792 --> 00:42:11,583
that around in memory, do more
trick and we will get to chase
them again. But they did a

382
00:42:11,583 --> 00:42:15,625
really good job, no actual tool
you can download, you have to
use the cloud service. I am

383
00:42:15,625 --> 00:42:21,375
giving a hacker protection of 5,
the best tool out there although
I am not suggesting you use it

384
00:42:21,375 --> 00:42:26,458
for these applications because
you will have the lag time of
needing to update, go through

385
00:42:26,458 --> 00:42:31,500
them, they go through an
approval process, I wouldn't
really recommend using these

386
00:42:31,500 --> 00:42:35,500
tools. Probably dex guard, maybe
Allatori is what he was
recommending. >> Now what? >>

387
00:42:35,500 --> 00:42:41,500
Quick thing on all of this. We
have initialized that and put
repo up there, I will push this

388
00:42:43,833 --> 00:42:50,792
once I get to the airport and on
a more secure network maybe. All
the code is ready, so leave it

389
00:42:50,792 --> 00:42:56,417
unpacked, Bangle, APKProtect,
these are really easy. We want
to make it more accessible for

390
00:42:56,417 --> 00:43:01,667
people. There's going to be the
samples of the malware that use
these protectors, I will shoot

391
00:43:01,667 --> 00:43:07,667
them to Milla, upload the
resource notes of when reversing
this stuff and that unpacker

392
00:43:12,167 --> 00:43:18,875
code. I put a lot of comments in
there I normally wouldn't, just
to explain the thought process,

393
00:43:18,875 --> 00:43:24,875
why are we doing this way.
Should get you there. >> Moving
on to the Black Phone, while you

394
00:43:27,667 --> 00:43:35,167
are all here. >> Let's explain
why I am incredibly hung over
right now. Yesterday I got paid

395
00:43:35,167 --> 00:43:38,833
for leading training, they had
Black Phones for sale so we
bought it. I like rooted phones.

396
00:43:38,833 --> 00:43:44,708
We used three stages of exploit.
I'm going to talk a little fast
because we're running out of

397
00:43:44,708 --> 00:43:51,625
time. The export does require
user interaction if you are
writing about it. User

398
00:43:51,625 --> 00:43:56,250
interaction not remotely
exploitable. User interaction
required. >> One of the first

399
00:43:56,250 --> 00:44:02,083
things they did, I ran into,
disabled ADB debugging, means we
can't get a shell or get debug

400
00:44:02,083 --> 00:44:09,208
apps on it. They turned it off
by removing the button that lets
you open the developer menu.

401
00:44:09,208 --> 00:44:16,292
This took about 30 seconds to
figure out a way around. We
fired off an intent to pop open

402
00:44:16,292 --> 00:44:24,292
the menu, upload the server,
download, run apps, bypass their
little trick. They claimed it

403
00:44:24,292 --> 00:44:30,708
was because ADD crashed the
phone, it worked fine for me. I
can't get it to crash. >>

404
00:44:30,708 --> 00:44:36,667
Encrypt your phone and try to
run it, you'll be very unhappy.
>> Okay, thank you. The second

405
00:44:36,667 --> 00:44:42,667
one is escalation beyond system.
They seem to have left a highly
privileged application

406
00:44:44,667 --> 00:44:50,750
debuggable, you can't use run
ads, but we can attach to it
with debugger, execute whatever

407
00:44:50,750 --> 00:44:57,708
we want as the system user.
System user, pretty privileged,
your hacks service is huge once

408
00:44:57,708 --> 00:45:04,458
you use it, if you have a system
user you are going to ruin your
phone. Jay Freeman wrote how to

409
00:45:04,458 --> 00:45:12,333
use this, we found the
application, took five minutes.
Followed his instruction and had

410
00:45:12,333 --> 00:45:16,042
a system user, really simple,
basic CTS, Google's
compatibility tests. This is a

411
00:45:16,042 --> 00:45:19,083
huge hit, they should have
caught this. They didn't bother
to run basic tests on this

412
00:45:19,083 --> 00:45:25,083
device, which is scary. Google
would never approve this device
if they had Google apps on it.

413
00:45:31,542 --> 00:45:37,500
>> The third stage. There are so
many system to root exploits and
vulnerabilities out there I

414
00:45:37,500 --> 00:45:43,125
won't actually disclose this one
but the first two things, you
already know how to do this too

415
00:45:43,125 --> 00:45:49,125
so we're going to keep it. >>
Stage one, fill the app with the
code in the earlier slide;

416
00:45:55,167 --> 00:45:58,750
stage... Enable ADB, stage 2, >>
It should work. >> It's not
playing. Stage 2 get the system

417
00:45:58,750 --> 00:46:04,750
user ID execution. Stage 3 root,
and it's not playing the video.
>>It's playing. >> Is it?

418
00:46:12,833 --> 00:46:19,833
Awesome, because we can't see
it. You can see me, I'm not
being able to enable USB

419
00:46:19,833 --> 00:46:25,833
debugging, annoying, then you
see me getting around that with
my little tiny hack as an app.

420
00:46:32,458 --> 00:46:37,125
>> Now you can see the root
shell. I actually ran the other
exploits. Again not remotely

421
00:46:37,125 --> 00:46:43,125
doable, user intention, if
indeed they removed this because
it crashes the phone and the

422
00:46:48,833 --> 00:46:54,833
product shouldn't have shipped.
Total time to think of this was
about five minutes. Actually

423
00:46:58,000 --> 00:47:04,000
takes a little longer because we
we were laughing. [Laughter]
[Applause] >> I will have more

424
00:47:12,708 --> 00:47:20,500
detailed instructions when I get
home and the app source will be
up on github as well. So

425
00:47:20,500 --> 00:47:26,917
hopefully I will get it all
fixed. >> The second vulnerable
was the action fix update. I

426
00:47:26,917 --> 00:47:31,125
wasn't aware of this, and the
phone they sold me did not have
the update. The second one is

427
00:47:31,125 --> 00:47:37,458
actually fixed so if you want to
root the phone do it before you
update. >> I think we are out of

428
00:47:37,458 --> 00:47:43,458
time but you guys can come up
here if you have questions,
thank you for coming. [Applause]

