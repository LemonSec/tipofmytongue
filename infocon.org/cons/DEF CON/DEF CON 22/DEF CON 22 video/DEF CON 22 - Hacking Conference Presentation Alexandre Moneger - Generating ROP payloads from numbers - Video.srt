1
00:00:00,042 --> 00:00:06,042
>> Good afternoon, Def Con. How
is it going? (Applause) 

2
00:00:06,042 --> 00:00:12,458
So this is generating ROP payloads from

3
00:00:12,458 --> 00:00:24,058
numbers. So please join me in
welcoming Alexandre Moneger.
(Applause) >> Hello everyone.

4
00:00:24,060 --> 00:00:30,792
Thanks a lot for attending. So,
basically, today I'll be talking
about return programming and how

5
00:00:30,792 --> 00:00:39,412
to generate pay loads using
numbers. A little bit about me
first. I work for Cisco systems

6
00:00:39,420 --> 00:00:48,917
in the UK. I am a Security
Engineer in the security
business. Which has not got

7
00:00:48,917 --> 00:00:54,667
nothing to do with what I am
going to talk about today.
Personally I'm interested about

8
00:00:54,667 --> 00:01:00,792
bits and bytes and all that
stuff. And the usual disclaimer.
The research was done on my own

9
00:01:00,792 --> 00:01:09,292
time and they do not reflect the
opinions of our employer and are
mine. You can't hear me? Sorry.

10
00:01:11,400 --> 00:01:19,040
All right. Is that better? So,
basically, I'll go through a
brief ROP overview. What is it?

11
00:01:19,042 --> 00:01:27,300
Why do we use it and why has it
kind of become essential today.
The automation basically of the

12
00:01:27,300 --> 00:01:33,540
ROP payload generation, why do
we want to do that or not and
what are the challenges with it?

13
00:01:33,542 --> 00:01:38,417
Then I'll go into a little bit
of sort of the core of the
subject which I call number

14
00:01:38,417 --> 00:01:46,167
stitching. Which is basically a
possibly new way to generate ROP
payloads from numbers instead of

15
00:01:46,167 --> 00:01:50,542
from strings. So I'll go
through, you know, the goal what
was I trying to achieve. You

16
00:01:50,542 --> 00:01:57,165
know, why I did it. How I found
the gadgets. And basically the
core of the problem which is the

17
00:01:57,167 --> 00:02:04,467
change problem which I'll get
back to later. Then I'll have a
quick chat about, you know, the

18
00:02:04,467 --> 00:02:12,660
pros, the cons, the tooling that
I'm releasing, and any future
work. 

19
00:02:14,900 --> 00:02:21,620
Okay so I'll have a very brief introduction about ROP
just so that I'm sure that
everybody understands what it

20
00:02:21,625 --> 00:02:27,792
is. So, basically, you know,
before in the old days you could
just attack, you know, exploit a

21
00:02:27,792 --> 00:02:32,042
vulnerability using, you know,
just a bunch of shellcodes and
you could just execute it

22
00:02:32,042 --> 00:02:38,208
anywhere. Unfortunately, or
fortunate, nowadays you can't do
this anymore. Right. You can't

23
00:02:38,208 --> 00:02:44,792
execute shellcode and memory
just like that. So, you know,
historically we got to a point

24
00:02:44,792 --> 00:02:49,625
where we got to return our
programming. Which is basically
instead of executing stuff

25
00:02:49,625 --> 00:02:54,667
through shellcodes use the
target binary to execute code
for you. So this means that you

26
00:02:54,667 --> 00:02:59,708
are not executing code yourself.
You are asking your target
basically to do it for you. All

27
00:02:59,708 --> 00:03:14,917
right. So, basically, I'll just
come comment a bit on what I
wanted to achieve also. So,

28
00:03:14,917 --> 00:03:23,777
basically, what I wanted to
achieve was to only use gadgets
from the compiler. So I was I

29
00:03:23,780 --> 00:03:31,600
saying when you look for gadgets
and instructions you are going
to get your program to use them.

30
00:03:31,660 --> 00:03:36,875
So what I wanted to do is take
it a bit further and extracts it
more and basically be able to

31
00:03:36,875 --> 00:03:42,833
use instructions generated by
the compiler or by libc to attack the vulnerability. So

32
00:03:44,680 --> 00:03:54,960
I'll try to generate the
payloads putting them in memory.
Coming back to my ROP overview, so

33
00:03:57,333 --> 00:04:01,250
we know that we want to
basically reuse instructions
from the target binary in order

34
00:04:01,250 --> 00:04:10,208
to bypass ASLR and XOW. Why we
use ROP is we don't have a
choice. The memory protections

35
00:04:10,208 --> 00:04:15,075
have gotten much better. We
can't do without it. So we use
it. The level of complexity is

36
00:04:15,083 --> 00:04:23,140
much higher. If we could avoid
it, it would be nice. But we
can't. It maintains control flow

37
00:04:23,140 --> 00:04:27,875
using the stack pointer and not
the instruction pointer. I won't
go into details but basically

38
00:04:27,875 --> 00:04:35,667
this is how you maintain control
over the flow of the program.
And ROP is multi‑staged more or

39
00:04:35,667 --> 00:04:40,000
less by design. It's that you
are going to have a first stage
which is going to be using the

40
00:04:40,000 --> 00:04:45,500
instructions from your target
binary to generate a payload for
you. So that payload, you are

41
00:04:45,500 --> 00:04:50,875
going to put it on a custom
stack you are going to create
within the program. So your idea

42
00:04:50,875 --> 00:04:55,917
is, okay, let's take a tiny
piece of the program and put
some instructions there which

43
00:04:55,917 --> 00:05:03,708
I'm going to execute later. So
that's your stage zero. First
phase basically which is grab

44
00:05:03,708 --> 00:05:08,667
some stuff, put it in the memory
and when you finish doing that,
change the control flow and

45
00:05:08,667 --> 00:05:15,417
execute that. As I said, it's
more or less the only way around
today's OS protections. You

46
00:05:15,417 --> 00:05:21,625
know, if you look at all the IE
exploits and all that stuff
which happened in 2013 they all

47
00:05:21,625 --> 00:05:29,875
used ROP to evade all those
memory protections. So just a
bit of vocabulary. What is

48
00:05:29,875 --> 00:05:35,125
called a gadget basically is
just a useful instruction inside
the target binary. So it's going

49
00:05:35,125 --> 00:05:40,417
be a very small piece of
assembly with a return
instruction at the end. So that

50
00:05:40,417 --> 00:05:47,167
is what you are going to call to
execute code. How do you find them
basically is that you go over

51
00:05:47,167 --> 00:05:52,500
your binary, you look for every
return instruction which is ZXC
three and assemble backwards

52
00:05:52,500 --> 00:05:59,083
from that and that will give you
what you can work with. To do
that there are many good tools

53
00:05:59,083 --> 00:06:07,875
available ROP gadget which just
go over binary and give you what
gadgets you use to attack it.

54
00:06:07,875 --> 00:06:12,625
Obviously the number of gadgets
you can find in a binary is
dependent on the size of the

55
00:06:12,625 --> 00:06:19,167
binary. If it's huge you got a
lot of chance of finding a lot
of gadgets. If it's small you've

56
00:06:19,167 --> 00:06:21,887
got much less and it becomes
much harder. 

57
00:06:25,160 --> 00:06:28,740
So once you have
done your stage zero, you know,

58
00:06:28,750 --> 00:06:34,042
you've built your fake frame,
your fake stack frame basically
in memory, you want to transfer

59
00:06:34,042 --> 00:06:39,102
control to that payload. Because
that's what you want to execute.
You want to get a shell or

60
00:06:39,102 --> 00:06:46,542
whatever you want. So shifting
control from the current control
flow into your stack frame is

61
00:06:46,542 --> 00:06:52,417
called stack pivoting,
basically. And it's a way of
re‑directing control flow so

62
00:06:52,417 --> 00:07:01,537
that you basically get then your
code to run once you have built
it. So I'm going to talk about

63
00:07:01,542 --> 00:07:11,582
automating the payload
generation which is basically
how from a program can I take

64
00:07:11,625 --> 00:07:18,917
bits of memory and put them,
create that fake stack which I
will later execute. So this is

65
00:07:18,917 --> 00:07:26,375
the classical approach of what
happens. Is that you find a
bunch of bytes in memory. So the

66
00:07:26,375 --> 00:07:30,000
bytes you are looking for
obviously are shellcode bytes.
So you got a shellcode you are

67
00:07:30,000 --> 00:07:35,250
going to start from or something
you want to achieve a bunch of
functions you want to call and

68
00:07:35,250 --> 00:07:40,270
you are going to look for those
bytes in memory and copy them to
a stack you control. Once 

69
00:07:40,270 --> 00:07:45,180
you have done that you get execution on that stack. So to achieve that you are going

70
00:07:45,180 --> 00:07:49,000
 to look for some particular gadgets which is a mov gadget. So you are going

71
00:07:49,000 --> 00:07:53,958
to try to move something from a
resistor you control to a zone
and memory you control. Or you

72
00:07:53,958 --> 00:08:00,578
can use a bunch of functions if
they are exported by the target
binary which is not always the case. 

73
00:08:02,542 --> 00:08:08,000
So you've got a bunch of
potential problems in this. It's
that you're counting basically

74
00:08:08,000 --> 00:08:13,667
on the availability of a
mov gadget. In real world you
have generally got it. So in big

75
00:08:13,667 --> 00:08:21,020
programs it's not a problem. It
can require some dereferencing
which I won't speak too much

76
00:08:21,020 --> 00:08:27,580
about but that's if you want to
get basically your ‑‑ call up a
particular function and also you

77
00:08:27,583 --> 00:08:31,833
are expecting some bytes to be
available in memory. Typical in
shellcode you look for your

78
00:08:31,833 --> 00:08:37,292
interrupt number and you are
expecting that number to be in
memory because otherwise you not

79
00:08:37,292 --> 00:08:42,167
going to be able to build your
shellcode. If that number is not
there it generally requires

80
00:08:42,167 --> 00:08:51,625
manual work to get the missing
byte. If we look at a shellcode
here which I took, basically you

81
00:08:51,625 --> 00:08:57,500
can see if I look for, you know,
the byte 7368, you know, I can
find them in the program so

82
00:08:57,500 --> 00:09:01,625
that's nice. I can find those
two bytes which, you know, are
part of my shellcode and I'm

83
00:09:01,625 --> 00:09:10,042
going to be able to use them. If
I look for something different,
basically, for example, 682 F I

84
00:09:10,042 --> 00:09:13,625
don't find that in the program
right. So that means I am going
to have to do some manual work,

85
00:09:13,625 --> 00:09:23,037
manipulating some bytes to get
that. So back to the gadget.
Very small binary do not tend to

86
00:09:23,042 --> 00:09:30,250
have many mov gadgets. So it
mean that's the automation of
the pellet is complicated. And

87
00:09:30,250 --> 00:09:36,208
in the case of this particular
gadget I'm showing, you've got a
problem sometimes with null

88
00:09:36,208 --> 00:09:45,083
bytes and basically it also
needs extra work to get rid of
it. Okay so here I'm going to

89
00:09:45,083 --> 00:09:51,917
introduce number stitching which
is basically I was asking myself
a question, is it possible to

90
00:09:51,917 --> 00:09:58,417
exploit a hello world type
vulnerability with most memory
protections enabled? I won't

91
00:09:58,417 --> 00:10:05,375
stack canaries and all that.
Basically, you know, a gross
programming mistake. You copy,

92
00:10:05,375 --> 00:10:08,708
you know, a user supplied
argument with string copy and
you get a buffer overflow or

93
00:10:08,708 --> 00:10:14,042
something like that. Is it
exploitable with everything
enabled? Also, I was wondering

94
00:10:14,042 --> 00:10:23,375
can I exploit this independently
of what the program does. Using
only the compiler or lib c.

95
00:10:24,780 --> 00:10:31,958
So, in other words,
it's like is it possible to not
rely at all on the target binary

96
00:10:31,958 --> 00:10:38,667
to generate a ROP payload. So
I'll go through it, like, how a
program is built and, you know,

97
00:10:38,667 --> 00:10:46,458
how it's linked and what
happens. And we'll see what we
get. So, basically, all the

98
00:10:46,458 --> 00:10:51,750
following of this is going to be
based on the gadgets I have been
able to find here. Basically all

99
00:10:51,750 --> 00:10:58,417
the other stuff was done due to
the gadgets which were made
available to me. So, if you just

100
00:10:58,417 --> 00:11:05,375
take a hello world and compile
it so what happens. Right. If
you look at what your program

101
00:11:05,375 --> 00:11:08,958
actually contains you see
there's a whole bunch of other functions which you did not

102
00:11:08,958 --> 00:11:16,042
intend to be there. You got the
start and lib c and all
that stuff. So where does that

103
00:11:16,042 --> 00:11:24,792
come from and can you use that?
So if you look basically at link
time at what happens, the linker

104
00:11:24,792 --> 00:11:31,167
will call libc.so. So you think
it is a dynamic library but it's
actually not. It is a script.

105
00:11:31,167 --> 00:11:38,000
And basically that script has
got a static library in it. So
meaning that when you compile a

106
00:11:38,000 --> 00:11:42,667
program against lib C you are
going to have most of your
functions dynamically linked but

107
00:11:42,667 --> 00:11:47,792
also have a subset of those
which are statically linked into
your binary.

108
00:11:50,320 --> 00:11:55,320
So, if you look at
that, there's quite a few
functions in there which you

109
00:11:55,320 --> 00:12:00,500
could possibly use, right. So
all this basically is if you use
it will be statically linked

110
00:12:00,500 --> 00:12:10,200
into your program. Meaning that,
you know, those gadgets will be
at fixed addresses. So the

111
00:12:10,208 --> 00:12:16,100
problem I had is that those
functions aren't always used,
they depend on various compile options

112
00:12:16,100 --> 00:12:22,500
and linking options. I just look
for gadgets in them and I couldn't
find anything. So I think it's

113
00:12:22,500 --> 00:12:28,750
good to say what you weren't
able to achieve. So, basically,
looking for gadgets in that

114
00:12:28,750 --> 00:12:39,042
failed. So I went back to my
binary and said is there
anything else which is added

115
00:12:39,042 --> 00:12:46,042
which I could use? And so,
basically, I looked at the
binary and there's a bunch of

116
00:12:46,042 --> 00:12:54,400
functions which I added by GCC
in some cases. So they've got no
symbols attached to them. So

117
00:12:54,400 --> 00:12:58,240
it's kind of hard to figure out
what they do. But there's just a
bunch of anonymous functions

118
00:12:58,250 --> 00:13:03,458
which I inserted into your
program. If you look at the
disassembly of your program, you

119
00:13:03,458 --> 00:13:07,500
will see there's some functions
where there is no symbols
associated and they're just

120
00:13:07,500 --> 00:13:14,917
there basically. Those functions
seem to relate to profiling. And
so that is why they're there,

121
00:13:14,917 --> 00:13:19,500
basically. So what was
surprising to me is that
profiling seems to be enabled by

122
00:13:19,500 --> 00:13:26,208
default on some distributions.
And so this stuff is actually
statically linked into your

123
00:13:26,208 --> 00:13:30,292
program and all these little
tiny pieces of assembly are put
into your program without you

124
00:13:30,292 --> 00:13:37,667
knowing about it. So to check
what the default options are for
GCC you can look at GCC minus

125
00:13:37,667 --> 00:13:45,958
Q minus V will dump basically
the list of compiler options
done by default. You might find stuff 

126
00:13:45,960 --> 00:13:55,740
interesting. So, basically, this work
was done for GCC 4.5 which is
pretty old. Basically I look for

127
00:13:55,750 --> 00:14:05,740
gadgets inside the code that was
embedded by GCC into the target
binary. Based on that, I kind of

128
00:14:05,740 --> 00:14:11,740
disassembled those functions and
I end up with this stuff to work
with them so this basically is

129
00:14:11,750 --> 00:14:16,375
only generated by the compiler. It's not code which is generated by the target

130
00:14:16,375 --> 00:14:23,875
application. So you can see that
I've got a bunch of stuff that I
get to work with. So the first

131
00:14:23,875 --> 00:14:29,250
one allows me to control EBX.
Put a random value in there and
control that. The other one

132
00:14:29,250 --> 00:14:35,375
allows me to pivot the stack
which I've achieved control and
I want to execute my shell code

133
00:14:35,375 --> 00:14:42,417
at the end. The two others which
are the meats of the talk is
that there is a write to memory.

134
00:14:42,417 --> 00:14:49,000
So, basically, through control
of EBX I can write the value
which is EAX. Meaning that the

135
00:14:49,000 --> 00:14:55,940
value I can dump it somewhere in
memory. And I've also got the
other way around. A right to the

136
00:14:55,940 --> 00:15:03,600
registry meaning that a value
by controlling EBX I can grab a
value from memory and load that.

137
00:15:03,600 --> 00:15:09,500
That means in short, you know, as
an attacker you control EBX and
that's about it, right. So you

138
00:15:09,500 --> 00:15:21,840
have to find a way to achieve
control of EAX also. Okay so
this ‑‑ so, basically, the

139
00:15:21,875 --> 00:15:26,250
further part of the talk will
just focus on those two
instructions, those two gadgets.

140
00:15:26,250 --> 00:15:36,490
And basically how I used them in
order to achieve execution. So,
basically, we've got a useful

141
00:15:36,500 --> 00:15:42,917
gadget here which is add memory
to a register. I removed the
trailing stuff and all that

142
00:15:42,917 --> 00:15:51,197
because it's not interesting. So
you control EBX. So it means you
can grab a value in memory and load

143
00:15:51,208 --> 00:15:57,917
it. Is that useful? Well you
don't control what's in memory
necessarily. So, you know,

144
00:15:57,917 --> 00:16:02,917
it's ‑‑ at first I didn't think
it could be potentially useful
but actually it is. I'll come

145
00:16:02,917 --> 00:16:09,833
back to this later. So now the
reverse. Basically once I've got
a value I'm interested in the

146
00:16:09,833 --> 00:16:17,042
register I can dump it into
memory right. This allows me to
create my fake stack frame. So

147
00:16:17,042 --> 00:16:25,082
assuming that I control EAX I
can build a fake stack frame,
you know, at the addresses

148
00:16:25,083 --> 00:16:34,875
pointed to by EBX. So that means
that by chaining these cores I
can, you know, copy my

149
00:16:34,875 --> 00:16:40,875
shellcodes into a frame I
control and then, you know,
trigger execution of it. 

150
00:16:46,200 --> 00:16:51,700
So basically, this is the more
general approach to ROP is that
you are going to choose a spot

151
00:16:51,708 --> 00:16:57,250
in memory where you can build
your stack. So, you know, the
memory properties you want is

152
00:16:57,250 --> 00:17:00,625
that obviously you can write to
it. With today's memory
protection you can either

153
00:17:00,625 --> 00:17:06,042
execute or you can write. So you
are going to choose a zone where
you can write. If you look

154
00:17:06,042 --> 00:17:10,417
at the previous instruction it
was an add instruction. So I
have to find what is called kind

155
00:17:10,417 --> 00:17:16,417
of a code cave which is a zone
where ‑‑ which is just padded
with bytes. So just a bunch of

156
00:17:16,417 --> 00:17:26,037
zeroes. When I add it I just add
to zero. So, you know, it avoids
further computation. And then

157
00:17:26,042 --> 00:17:32,875
you choose the shellcode you
want. To just pick a shellcode,
any one you want, set the ID for

158
00:17:32,875 --> 00:17:41,155
whatever you want and basically
just hope that you are going
to ‑‑ to copy that shellcode to

159
00:17:41,167 --> 00:17:50,625
a frame you control and then
execute it. So now the unusual
approach I'd say to do this is

160
00:17:50,625 --> 00:17:57,875
that I chose to deal ‑‑ since I
had to deal with arithmetic
operations much as add I chose

161
00:17:57,875 --> 00:18:03,792
to actually see the shellcode
not as a string but as a number.
So, basically, if I cut it into

162
00:18:03,792 --> 00:18:12,432
small pieces of four bytes on
32 bits and eight bytes on 64 I
just cut it in four byte chunks and

163
00:18:12,440 --> 00:18:20,120
interpret each chunk as an integer.
That just says basically take a
string and it is actually a

164
00:18:20,125 --> 00:18:27,958
number. So, if you keep track of
each of the index of each chunk
you know basically which index

165
00:18:27,958 --> 00:18:33,375
your number is and what you want
to do is since you are going to
always be adding you want them

166
00:18:33,375 --> 00:18:38,625
to be ordered because you always
want to go from smaller to
bigger. So, basically, you just

167
00:18:38,625 --> 00:18:45,875
order them. You take your
shellcodes, cut into little bits
as numbers, and then basically

168
00:18:45,875 --> 00:18:51,208
you keep track of their position
and you reorder them from
smallest to biggest, right. And

169
00:18:51,208 --> 00:18:55,542
then once you have done that you
compute the difference between
each chunk. So that will give

170
00:18:55,542 --> 00:19:01,708
you basically Deltas between
your pieces of shellcodes and it
will keep your shellcodes

171
00:19:01,708 --> 00:19:06,948
basically (inaudible)
increasing. Just meaning each
time you add a value to your

172
00:19:06,948 --> 00:19:16,088
register it's going to always go
up. So what this looks like if I
take this example. At the top

173
00:19:16,167 --> 00:19:24,167
you've got a shellcode. Just a
string of hex. If you take it
as a number and reorder it, you

174
00:19:24,167 --> 00:19:27,542
get to line two basically. So,
if you see the end of the
shellcode has shifted back to

175
00:19:27,542 --> 00:19:32,583
the front and I've ordered all
that together. All right so
they're ordered in increasing

176
00:19:32,583 --> 00:19:37,708
number. If you take the
difference between each
basically you get small Deltas.

177
00:19:37,708 --> 00:19:43,708
So you see basically at the last
line that position three of your
initial shellcode is now

178
00:19:43,708 --> 00:19:52,488
position one. Position two is
actually two minus three and
it's at position two and

179
00:19:52,488 --> 00:20:04,000
et cetera. So your shellcode is
now represented as increasing
Deltas. So, if you add ‑‑ if you

180
00:20:04,000 --> 00:20:07,875
take your initial value and add
the Delta you find back the
value of your shellcode. If you

181
00:20:07,875 --> 00:20:13,015
do that again you find the next
value of your shellcode. Do it
again and the next value. Once

182
00:20:13,020 --> 00:20:19,080
you have reach that value you
want to dump it to your fake
stack but you want to dump it in

183
00:20:19,083 --> 00:20:24,840
a way that you remember at which
position it was initially right.
Otherwise you are going to write it at

184
00:20:24,840 --> 00:20:30,833
the wrong spot. Once you do that
you just repeat, repeat, repeat
then eventually you've copied

185
00:20:30,833 --> 00:20:39,933
what you want into a zone of
memory. So as an example say you
want to copy the number 010234

186
00:20:39,958 --> 00:20:47,458
into memory. So you find that
number in memory. So for the
timing I am just assuming it's

187
00:20:47,458 --> 00:20:54,292
there. I'll speak later what
happens if it's not. You will
see the number there is in

188
00:20:54,292 --> 00:21:00,583
memory and you know the address
of that and basically you copy
that into EAX. So you have

189
00:21:00,583 --> 00:21:08,417
achieved loading a value into a
register from memory right. So
that's kind of easy. Now you've

190
00:21:08,417 --> 00:21:13,042
got the value you want of your
shellcode so you want to dump it
onto your fake stack frame. If

191
00:21:13,042 --> 00:21:17,208
you look at that, that guy was
actually at position three. So
you actually drop it on the

192
00:21:17,208 --> 00:21:22,500
stack at the right position. And
now you are going to look for
the next number which is, you

193
00:21:22,500 --> 00:21:30,660
know, the Delta which is in this
case 040404. So you assume that
also is in memory. You take it

194
00:21:30,667 --> 00:21:36,000
and sum it and get back to the
same value and you dump it. And
you do that over and over again.

195
00:21:36,000 --> 00:21:40,833
And in the end basically you
have achieved building a
shellcode from a bunch of

196
00:21:40,833 --> 00:21:49,333
numbers that you found out in
memory. So now it comes to the
problem of how easy is it to

197
00:21:49,333 --> 00:21:56,875
find shellcode numbers in
memories. Because basically if
you take your shellcode and look

198
00:21:56,875 --> 00:22:02,917
at it as a bunch of numbers,
it's actually pretty high
numbers, right. It's going to

199
00:22:02,920 --> 00:22:11,740
be ‑‑ if you look at the example
I put there 6a315899 if you take
the string and

200
00:22:11,750 --> 00:22:21,490
integer and (inaudible) it actually ends up
at 66a7c96 which is a high or
negative number. But 

201
00:22:22,760 --> 00:22:28,140
We're relying on the fact that will be
in memory and we can copy it.
What happens if it's not?

202
00:22:30,280 --> 00:22:38,620
So here basically the next part is
just, all right, I've got that
value, well I'm hoping for that

203
00:22:38,625 --> 00:22:44,625
value to be in memory, but it's
not, what can I do and how can I
build it. 

204
00:22:46,720 --> 00:22:54,292
So, basically, the answer is that it's not very
easy to find big numbers in
memory. They're not ‑‑ so I had

205
00:22:54,292 --> 00:23:02,892
to look at a bunch of programs
and I saw that they're basically
not really there. So here I put

206
00:23:02,958 --> 00:23:10,333
a small example of looking for,
you know, 01020304 in GDB and it
just doesn't yield anything. If

207
00:23:10,333 --> 00:23:16,000
you look at multiple programs
and search for those numbers,
they're not really there. So I

208
00:23:16,000 --> 00:23:25,700
have to find basically a
different approach. So the
approach was ‑‑ my idea was that

209
00:23:25,708 --> 00:23:32,680
if I can basically scan memory
for numbers and if I can find a
way to add them together to end

210
00:23:32,680 --> 00:23:38,020
up the chunk value then I'm
fine, right. So by definition
memory, you know, has got a

211
00:23:38,020 --> 00:23:43,333
crazy number of numbers in
there, right. If you look at
individual numbers, it's got

212
00:23:43,333 --> 00:23:55,193
heaps in there. The approach is
basically take a file, take its
read only segment and basically

213
00:23:55,208 --> 00:24:01,250
just scan it for numbers, right.
So just, you know, look at the
beginning of it, see it as a

214
00:24:01,250 --> 00:24:04,958
number, shift it by one byte,
see it as number and shift it by
one byte and see it as another

215
00:24:04,960 --> 00:24:11,580
number. So you scan all that
segment just looking for a bunch
of numbers, right.

216
00:24:13,660 --> 00:24:18,917
So where I decided to look for was
basically in the read only
segment. Because obviously you

217
00:24:18,917 --> 00:24:24,317
don't want those numbers to
change at run time. Here they
come. 

218
00:24:24,320 --> 00:24:33,120
(Applause)

219
00:24:34,240 --> 00:24:39,580
I looked inside the segments
which were read only. So that
basically I knew that at run

220
00:24:39,583 --> 00:24:44,708
time those numbers would not
change at all. And exclude all
the read/write segments

221
00:24:44,708 --> 00:24:51,000
basically which we're going
change. Basically if you don't
have position independent codes --

222
00:24:53,080 --> 00:24:59,980
thank you very much. >> Show some love
for our first time speaker at
Def Con! (Cheering) (Applause)

223
00:24:59,980 --> 00:25:11,680
>> Thank you very much. >>
Cheers. >> Thank you very much.
>> What do you guys think of his

224
00:25:11,680 --> 00:25:17,600
graphics? (Laughter). >> I'm
sorry that was low.
>> That's all right. So,

225
00:25:21,220 --> 00:25:32,040
So basically, the read only segment
to find your numbers. So what
you do is scan that read only

226
00:25:32,042 --> 00:25:37,875
segment look for the numbers,
you know, shifting by one byte
each time and keep track of

227
00:25:37,875 --> 00:25:43,083
their addresses, right. And so
what you end up is with a whole
bunch of numbers and the problem

228
00:25:43,083 --> 00:25:47,833
seems pretty simple is that how
to add up these random bunch of
numbers to find the chunk I

229
00:25:47,833 --> 00:25:53,542
want, right. So all you are
looking for is finding the best
combination of numbers which add

230
00:25:53,542 --> 00:26:00,375
up to a chunk. So this problem
seems pretty simple because, you
know, for human we do it all the

231
00:26:00,375 --> 00:26:07,995
time. But for a computer it's
pretty crap. It's basically
called the coin change problem.

232
00:26:08,000 --> 00:26:15,260
It took me awhile to figure out
it was what I was looking for.
The example is you buy an item

233
00:26:15,260 --> 00:26:24,700
at 425 euros and you get a five
euro note. And what's the most
efficient way to return change

234
00:26:24,708 --> 00:26:29,375
on that? You know, that's
something we know how to do
pretty easy. You know, in Europe

235
00:26:29,375 --> 00:26:37,000
we'd give back a $0.50 coin,
$0.20 coin and $0.05 coin. To
basically that's the coin change

236
00:26:37,000 --> 00:26:44,920
problem is what's the most
efficient way of giving money
back basically. So, basically,

237
00:26:44,920 --> 00:26:49,760
if you look at this problem in
dollars the answer is different
right. You are looking for same

238
00:26:49,760 --> 00:26:55,860
thing. $0.75. So, basically, in
the U.S. you would give half a
dollar and a quarter. To you see

239
00:26:56,042 --> 00:27:02,125
that here the solution basically
depends on your coin set. And so
it depends on the numbers you

240
00:27:02,125 --> 00:27:11,542
found in memory. So solving the
problem for human is pretty
simple. Solving the problem for

241
00:27:11,542 --> 00:27:19,083
a computer is a bit more
difficult. So, basically, you
can achieve an ideal solution to

242
00:27:19,083 --> 00:27:23,667
the problem by using dynamic
programming which basically will
give you the most efficient

243
00:27:23,667 --> 00:27:27,833
solution. So, you know, maybe
some of you guys have done that
in high school, you know, it's a

244
00:27:27,833 --> 00:27:33,250
pretty simple problem to solve
when you've got small numbers.
The problem is since I am

245
00:27:33,250 --> 00:27:37,458
dealing with pretty big numbers
is that dynamic programming
doesn't scale and it just kind

246
00:27:37,458 --> 00:27:43,000
of blows my memory. So I can't
get to scale it for massive
numbers yet. So I have to use a

247
00:27:43,000 --> 00:27:49,292
different approach. So I used an
approach called the greedy
approach which is just slightly

248
00:27:49,292 --> 00:27:55,250
different which basically
achieves the same thing but
won't give you the optimal

249
00:27:55,250 --> 00:28:01,042
solution. It will give you a
solution. So how it works is
that it's just simple. Just like

250
00:28:01,042 --> 00:28:07,602
you take the biggest coin which
fits in the interval and then
just add and add and add. One

251
00:28:07,602 --> 00:28:15,662
thing we're lucky with in memory
you've got many, many small
numbers. Number 1, two, three,

252
00:28:15,667 --> 00:28:23,040
four, five. All that is like
you've got heaps of them in
there. So, basically, you always

253
00:28:23,040 --> 00:28:30,280
can achieve the greedy approach
which is kind of nice. But it's
sub optimal. So kind of back to

254
00:28:30,280 --> 00:28:38,875
the $0.75 problem looking, you
know, with ‑‑ so, you know,
trying to return $0.75 using the

255
00:28:38,875 --> 00:28:42,708
greedy approach basically you
just go down the list of the
coins and take the biggest one

256
00:28:42,708 --> 00:28:52,083
which fits. In this case 50, 20
and $0.05. So, basically, all my
tool does is that, you know, you

257
00:28:52,083 --> 00:28:56,292
give it a number in memory, it
will scan all memory and it will
try to find you the best

258
00:28:56,292 --> 00:29:05,152
solution for this. So,
basically, I wrote a tool called
Ropnum which is basically just

259
00:29:05,167 --> 00:29:10,708
trying to find a solution to the
coin change problem. So,
basically, you give it a number,

260
00:29:10,708 --> 00:29:16,875
you give it ‑‑ and it will
basically throw out all the
addresses where those numbers

261
00:29:16,875 --> 00:29:21,958
added together end up with a
chunk, right. So, if you look at
this back into the context of

262
00:29:21,958 --> 00:29:26,625
what I was talking before, here
you are basically looking to add
up a bunch of numbers in memory

263
00:29:26,625 --> 00:29:30,792
to reach a chunk of the
shellcode right. So this is what
Ropnum will do is give you

264
00:29:30,792 --> 00:29:40,012
basically that. It's got a bunch
of extra features. Ignore null
bytes, exclude numbers you don't want.

265
00:29:41,020 --> 00:29:46,917
It can print all memory pointing to a
number and zero. Et cetera. All
these features are not critical

266
00:29:46,917 --> 00:29:53,777
they just make the exploit dev
easier because you can exclude
addresses which are not in your

267
00:29:53,780 --> 00:30:02,980
range. So an example usage is
basically find me the address of
numbers in the segment

268
00:30:02,980 --> 00:30:07,740
containing the text section, so
read only section, which added
together solve the coin change

269
00:30:07,750 --> 00:30:14,333
problem. Here if you look it
will spit out at the lower part
it spits out five numbers

270
00:30:14,333 --> 00:30:19,208
basically. And if you add those
together, you get your target
number which is your shellcode chunk.

271
00:30:22,720 --> 00:30:30,880
So, if we look back at
this basically ‑‑ it will give
you the individual parts of the

272
00:30:30,880 --> 00:30:36,960
number which summed together
gets your shellcode. Here I just
showed if I re‑add all the

273
00:30:36,960 --> 00:30:43,417
values together I get my initial
value. Now coming back to my
gadget, it's that here by

274
00:30:43,417 --> 00:30:51,617
putting the value I want in EBX
and by adding repetitively I can
add get to the value of my chunk.

275
00:30:56,540 --> 00:31:04,200
So, if I put all
this together, so, basically, so
you take your shellcode, you cut

276
00:31:04,208 --> 00:31:11,625
it, order it and take the
Deltas. You look for numbers in
memory. And basically you add

277
00:31:11,625 --> 00:31:17,167
them together until they reach
the value of a chunk. Here it
means you have achieved the

278
00:31:17,167 --> 00:31:23,167
value of the shellcode. Once
that chunk is reached you
basically just dump it on to a

279
00:31:23,167 --> 00:31:28,708
stack frame you control. And you
repeat until the shellcode is
complete. And in the end you

280
00:31:28,708 --> 00:31:35,167
just transfer control over to
your shellcode. So I wrote a
tool also which automates all

281
00:31:35,167 --> 00:31:42,000
this process basically where you
just give it a shellcode and it
will spit out some Python code

282
00:31:42,000 --> 00:31:52,300
to generate your exploit. So you
give it a shellcode, anything
you want, you give it a frame

283
00:31:52,300 --> 00:31:57,540
address, so where you want to
copy your data too which will
generally be the data section.

284
00:31:57,542 --> 00:32:05,680
It takes care of all the boring
details, right, which make your
life hell. It will spit out a

285
00:32:05,680 --> 00:32:11,380
bunch of Python codes which
generate the payload. So if you
are familiar with rock gadget

286
00:32:11,380 --> 00:32:16,700
and all that stuff, it does
something pretty similar to
that. Now what it does also is

287
00:32:16,708 --> 00:32:22,700
that, you know, for the timing
we've copied our payload to a
fake stack we've got but that

288
00:32:22,700 --> 00:32:31,375
stack is read/write. So we'll
add a small and protect read
write stub frame before the

289
00:32:31,375 --> 00:32:38,075
payload. So what it does is
basically it will allow your ‑‑
to change the memory permissions

290
00:32:38,080 --> 00:32:42,417
at run time so that your
shellcode can run. And so it's
got a bunch of additional

291
00:32:42,417 --> 00:32:48,083
functions like it can start
with, you know, an arbitrary EX
value and look up numbers in

292
00:32:48,083 --> 00:32:55,542
sections and segments depending
on what you want to do and all
that kind of stuff. So a bit

293
00:32:55,542 --> 00:33:00,458
more on why you need and protect
stub. So you have copied your
shellcode into a zonal memory

294
00:33:00,458 --> 00:33:07,042
which is RW. So, if you return
execution to that it's not going
be able to execute right. You

295
00:33:07,042 --> 00:33:11,958
are just going to get a fault
from your processor because the
memory permissions are wrong. So

296
00:33:11,958 --> 00:33:17,750
you need to make that page kind
of read write execute at run
time. This is where it clicks

297
00:33:17,750 --> 00:33:25,250
in. It's just standard function
which allows you to change
memory permissions at run time.

298
00:33:25,250 --> 00:33:30,950
So, basically, I just added
small stub in the front of that
and once that has executed it

299
00:33:30,950 --> 00:33:40,375
will jump back into your
shellcode. So an example usage
is basically, you know, to copy

300
00:33:40,380 --> 00:33:46,875
a shellcode to a fake frame located in
the data section putting it in
protect frame and looking up

301
00:33:46,875 --> 00:33:55,915
segments in the RO segment in a
binary you end up basically with
this. And so all this basically

302
00:33:55,920 --> 00:34:03,875
will spit you out a bunch of
Python codes which will just
once run will basically generate

303
00:34:03,875 --> 00:34:12,535
your shellcode. So I didn't put
the output on the slides because
it's pretty verbose and just a

304
00:34:12,542 --> 00:34:17,833
bunch of codes which isn't very
interesting. I put it on the CD
though and I've got an example

305
00:34:17,833 --> 00:34:25,542
on github if you want to have a
look at it. So, if we have a
look at GDB and what's happening

306
00:34:25,542 --> 00:34:30,667
inside GDB basically you will
see that I put the values in
yellow. The values which have

307
00:34:30,667 --> 00:34:38,900
basically been copied. If you
look at the values the first one
0X7 is read, write execute.

308
00:34:38,900 --> 00:34:46,292
So, basically, that one is
written, you know, at its proper
index. The next one is 0X08

309
00:34:46,292 --> 00:34:52,332
which is the number and you will
see that guy is written
completely at the end. This kind

310
00:34:52,340 --> 00:34:58,080
of shows, you know, the tracking
of the index and, you know,
where stuff has to go to rebuild

311
00:34:58,083 --> 00:35:06,125
your shellcode. So then I write
0X1000 which is the next biggest
number on the shellcode and it

312
00:35:06,125 --> 00:35:11,542
will write it back, you know, at
a different index, et cetera,
et cetera. So, if you continue

313
00:35:11,542 --> 00:35:19,333
that, you know, execution ten
times just to see it go faster,
you will see that there's a

314
00:35:19,333 --> 00:35:25,208
bunch of missing zones in orange
basically which will be filled
in later. So it's just ‑‑ this

315
00:35:25,208 --> 00:35:32,000
is just to show the shellcode is
out of order. So the end
shellcode is basically the

316
00:35:32,000 --> 00:35:41,060
shellcode is complete in memory
with the RWE and protect stub
just before it. 

317
00:35:42,700 --> 00:35:51,120
There's a bunch of pros and cons to this
technique. I don't know, I was
wondering about this and it's

318
00:35:51,125 --> 00:35:57,000
got a real use case scenario.
It's just something I wondered
with and I found it nice but I

319
00:35:57,000 --> 00:36:01,917
don't know if it's useful in
real life. It's got a bunch of
pros that it can encode any

320
00:36:01,917 --> 00:36:10,077
shellcode. All you are dealing
with is addresses right. You
never actually look for value.

321
00:36:10,080 --> 00:36:18,620
You never pop values in. Just
addresses. The lower two bytes
of your address are controls

322
00:36:18,625 --> 00:36:25,500
basically. So you can exclude
those values if you don't want
them. Obviously the initial goal

323
00:36:25,500 --> 00:36:32,625
is that you are not affected by
RELRO, ASLR or XW. So,
basically, it will allow you to

324
00:36:32,625 --> 00:36:38,292
bypass all those memory
protection. The cons basically
is that the payloads are fairly

325
00:36:38,292 --> 00:36:43,375
large right because you're
generating ‑‑ you are adding,
you know, multiple values,

326
00:36:43,375 --> 00:36:49,815
right, to each value of a chunk.
So up to five values together.
So that requires quite a bit of

327
00:36:49,820 --> 00:36:56,120
iterations to get there. What
that means is those iterations
transform into a code length

328
00:36:56,125 --> 00:37:01,292
basically so your payload grows.
So your stage zero can get
pretty big. So that's a pretty

329
00:37:01,292 --> 00:37:10,992
big con. So the further usage to
this is that let's imagine that,
you know, here we were looking

330
00:37:11,000 --> 00:37:18,542
at EAX. I am still looking at the
specific case of GCC4.4.5. Is
that I achieve control of EAX

331
00:37:18,542 --> 00:37:24,750
through this technique.
Basically one thing I had is
that sometimes EAX, the initial

332
00:37:24,750 --> 00:37:30,500
value you've got in there
changes depending on, you know,
your user input data. So one

333
00:37:30,500 --> 00:37:35,333
nice trick that is if you
control EAX is that you can more
or less get a value you want in

334
00:37:35,333 --> 00:37:43,213
to there through doing just a
random function call in the PLT.
And since, you know, in the

335
00:37:43,220 --> 00:37:49,958
Linux AVI EAX holds the return
value of a function call. So if
you do random function call and

336
00:37:49,958 --> 00:37:54,738
make it fail or succeed or
whatever you can kind of control
the initial value you've got in there.

337
00:37:58,020 --> 00:38:06,833
So now I tried to take an
approach to shrink the size of
stage zero. So one approach was

338
00:38:06,833 --> 00:38:12,500
basically that instead of
loading the whole shellcode in
memory what I could do is create

339
00:38:12,500 --> 00:38:18,792
some kind of gadget table at the
location I wanted. Instead of
take the whole thing, you know,

340
00:38:18,792 --> 00:38:23,458
the whole shellcode which is,
you know, a big number and just
ditching it there what I can do

341
00:38:23,458 --> 00:38:29,858
is instead of that load of bunch
of additional gadgets and use
that as a table to continue my

342
00:38:29,860 --> 00:38:36,740
exploit. For example say you've
got your exploit and you would
like to have those gadgets I put

343
00:38:36,740 --> 00:38:44,420
in there. The up codes I put on
the right. Basically your
shellcode becomes 59C35B,

344
00:38:44,420 --> 00:38:51,260
blah, blah, blah. So, if you
load that you use number
stitching to generate that and

345
00:38:51,260 --> 00:38:56,333
put that in memory, then you can
actually call them directly
from, you know, a stage zero

346
00:38:56,333 --> 00:39:02,125
payload from your payload. So
that way you can kind of insert
additional gadgets within the

347
00:39:02,125 --> 00:39:10,333
target's memory space. Which is
kind of practical. And so yes
since, you know, the tool can

348
00:39:10,333 --> 00:39:17,167
change the memory positions it
will work. Then you just call
the gadgets from your table or

349
00:39:17,167 --> 00:39:20,250
it doesn't have to be
necessarily gadgets. It can just
be bytes right. You can just add

350
00:39:20,250 --> 00:39:27,042
a bunch of bytes and it
increases the availability of
your bytes. And so you have kind

351
00:39:27,042 --> 00:39:32,375
of the ability to load any
gadget or byte in memory just
using a bunch of memory address.

352
00:39:32,375 --> 00:39:37,975
I haven't automated that part in
the tool yet it's just kind of,
you know, on the side. 

353
00:39:40,800 --> 00:39:48,300
So future work. So, basically, I'd like
to, you know, continue having a
look on numbers and basically if

354
00:39:48,300 --> 00:39:54,720
they're available to memory and,
you know, not subject to ASLR.
So check a bunch of binary and

355
00:39:54,720 --> 00:39:59,240
see if I can figure out if
anything comes up. Realistically
shouldn't be but you never know.

356
00:39:59,250 --> 00:40:07,917
Maybe something will come up.
And basically search for gadgets
in new versions of libc/gcc. So

357
00:40:07,917 --> 00:40:11,500
it seems difficult but, you
know, I might find a bunch of
gadgets in there which could be

358
00:40:11,500 --> 00:40:17,958
exploitable and allow to have
that separation basically of
exploiting the program through

359
00:40:17,958 --> 00:40:28,078
it's kind of dependencies in a
way. On the tooling side
basically I'd like to get

360
00:40:28,080 --> 00:40:34,792
dynamic programming approach to
work with large numbers. I don't
think it will be completely

361
00:40:34,792 --> 00:40:42,333
possible but I'll have a look
into it. Add 64‑bit support, I
mean, here regarding the

362
00:40:42,333 --> 00:40:46,042
methodology it's pretty simple
right. The numbers are just
bigger so it doesn't change

363
00:40:46,042 --> 00:40:54,333
anything. The problem will be
with the improtect frame which
might be harder to introduce. I

364
00:40:54,333 --> 00:40:59,375
think basically that there would
be advantage in introducing a
mixed approach. So, you know,

365
00:40:59,375 --> 00:41:03,875
possibly integrating this and
other tools which are already
doing their job really well. So,

366
00:41:03,875 --> 00:41:10,375
you know, rock gadget can
generate payloads once it's got
everything from a string. But

367
00:41:10,375 --> 00:41:15,455
maybe try to automate finding
the missing bytes basically
using this technique which means

368
00:41:15,460 --> 00:41:21,580
that you would have a proper, a
real automatic payload
generation. You know, that's

369
00:41:21,583 --> 00:41:29,125
obviously interesting. Basically
I'd like to introduce in the
tool basically the concept of,

370
00:41:29,125 --> 00:41:33,405
you know, gadget tables and, you
know, introducing random bytes
at random addresses. 

371
00:41:36,420 --> 00:41:41,792
So you know, to summarize what I
wanted to do was basically, you
know, achieve exploitation

372
00:41:41,792 --> 00:41:45,708
without using gadgets from the
target binary but from, you
know, stuff introduced by the

373
00:41:45,708 --> 00:41:50,792
environment. That took me down
the track, you know, of giving
you those two particular gadgets

374
00:41:50,792 --> 00:41:56,083
that took me down the track of,
you know, having to kind of scan
memory for numbers and find ways

375
00:41:56,083 --> 00:42:00,708
to add them together to achieve
what I wanted. So if you want to
have a chat about it or if

376
00:42:00,708 --> 00:42:05,792
you've got any ideas or think
this is useful or not just shoot
me an email. If you want to try

377
00:42:05,792 --> 00:42:11,542
out the tool, it's available on
github. So give it a shot. Thank
you very much for your time and

378
00:42:11,542 --> 00:42:17,542
for listening to this and have a
good Def Con. Cheers. (Applause)

