1
00:00:00,333 --> 00:00:08,208
	>>So thanks, everybody. um.
We're here to talk about a bunch
of scary low level stuff that

2
00:00:08,208 --> 00:00:13,625
nobody knows about, right? 	So
we're going to give a summary of
attacks against bio sense secure

3
00:00:13,625 --> 00:00:21,208
groups. A group of here is from
Intel Security. The rest of my
friends here are from a group

4
00:00:21,208 --> 00:00:27,208
called Advanced Threat Research
and it's their job to find new
attacks and find mitigation so

5
00:00:29,625 --> 00:00:35,792
we can deploy stuff and make
things better overall, across
all sorts of platforms, right?

6
00:00:35,792 --> 00:00:42,792
I'm actually from the products
security and response team. We
uh, coordinate a lot of these

7
00:00:42,792 --> 00:00:49,500
issues. 	Been working with our
friends at Miter -- presented
yesterday and gave an awesome

8
00:00:49,500 --> 00:00:54,333
talk. We have been coordinating
a lot of this stuff, and, you
know, we'd love to hear about

9
00:00:54,333 --> 00:01:00,083
more, even though we'd like to
believe that there isn't more,
but there's always something.

10
00:01:00,083 --> 00:01:04,292
And we'd love to hear from you
at secure@Intel.com. 	Um. So
we're talking about bios, right?

11
00:01:04,292 --> 00:01:10,292
And so bios, um . . . in the
beginning, there was what we now
call legacy bios and it involves

12
00:01:21,750 --> 00:01:27,750
a lot of texts. Textual menus
and according to this slide, a
lot of blue, comes in various

13
00:01:30,375 --> 00:01:37,375
shapes and sizes, but mostly
just blue. Um. And it had to do
all of these things. 	The system

14
00:01:37,375 --> 00:01:43,792
powers on and it has to go and
put some instructions in the spy
flash to start getting the

15
00:01:43,792 --> 00:01:47,875
system ready. Um, we're going to
start running out of cache,
we're going to start configuring

16
00:01:47,875 --> 00:01:51,667
memory, start running out of
memory, we're going to start
configuring a bunch of devices

17
00:01:51,667 --> 00:01:55,583
and get everything ready to go,
run a bunch of option ROMS and
eventually we're going to find

18
00:01:55,583 --> 00:02:01,583
some kind of hard drive or boot
media and we're going to go
ahead and find the master boot

19
00:02:03,750 --> 00:02:09,750
record and load it and then that
thing will start up on operating
system, we think. And then along

20
00:02:11,917 --> 00:02:17,917
came the unified extensible
firmware interface and we got
icons. 	>> [Laughter]. 	>> And

21
00:02:20,583 --> 00:02:26,833
it's really interesting because
now we also got a new color,
black! And then I mean it did

22
00:02:26,833 --> 00:02:32,833
all sorts of good things, but
really it's more about creating
a standardized set of what I

23
00:02:35,042 --> 00:02:40,875
would call APIs, right? Things
that you can rely on having
happened by the time you run it.

24
00:02:40,875 --> 00:02:47,958
And here's this slide, right,
and everyone who has presented
on security regarding UFI has

25
00:02:47,958 --> 00:02:53,167
put this slide in their
presentation, so here it is.
We're doing that, too because

26
00:02:53,167 --> 00:02:58,042
it's obligatory right? 	And what
it's really talking about is
there's different phases. It

27
00:02:58,042 --> 00:03:01,958
breaks up the whole boot process
into these different phases. And
what is really going on is you

28
00:03:01,958 --> 00:03:06,000
are building upon the phase
before you. It does all the same
stuff that I was talking about.

29
00:03:06,000 --> 00:03:09,458
You start out running out of
cache and then you go ahead and
set up memory and then you go

30
00:03:09,458 --> 00:03:13,708
ahead and configure all these
devices and eventually you come
to the point where you're going

31
00:03:13,708 --> 00:03:18,167
to make a decision about what
you're going to boot off of. You
go ahead and make that decision,

32
00:03:18,167 --> 00:03:24,167
you load up a binary and then
that thing is a boot loader and
loads up an operating system,

33
00:03:26,708 --> 00:03:32,708
right? 	So um one of the things
that UFI does is it gives you,
well, two things. It gives you,

34
00:03:35,125 --> 00:03:40,750
it tries to get up to 32 bit
virtual very quickly and it just
starts to run things. Just like,

35
00:03:40,750 --> 00:03:47,417
you know, regular loading of an
executable and then it also
gives you these run time

36
00:03:47,417 --> 00:03:54,250
services which are standardized
APIs that you can call even
after the boost, uh, bios has

37
00:03:54,250 --> 00:04:00,250
finished its job and you're
running at run time. 	So with
this came a standard for secure

38
00:04:02,417 --> 00:04:09,167
boot. Right? And the way this
sort of works is that, I'm
trying to see my slide here, um,

39
00:04:09,167 --> 00:04:16,375
it's basically checking
signatures, right? 	We start
with assigned bios because if

40
00:04:16,375 --> 00:04:19,917
you could put whatever you
wanted in the spy flash, I don't
know how many of you guys heard

41
00:04:19,917 --> 00:04:25,875
Miter's talk yesterday, but they
said it very nicely, right? Gee,
what attacks can I come up with

42
00:04:25,875 --> 00:04:30,958
that I could do if I controlled
whatever was in the spy flash?
Which is the first thing that

43
00:04:30,958 --> 00:04:37,708
gets executed when the machine
powers on. 	That would be any
attack you can think of. So.

44
00:04:37,708 --> 00:04:43,708
It's pretty nice, it's pretty
nice if you can get there. So we
have to start with this ability

45
00:04:45,750 --> 00:04:49,500
to ensure that what's there is
right. And that's where the
signed bios update comes from.

46
00:04:49,500 --> 00:04:54,250
And after that you start
checking signatures on
everything that runs after you.

47
00:04:54,250 --> 00:05:00,083
	Right. So we get to the stages
we're running a Dispatcher and
we'll check a signature before

48
00:05:00,083 --> 00:05:04,625
we run it. We get to the boot
loader and we'll check a
signature before we run it. And

49
00:05:04,625 --> 00:05:08,833
that allows you to create an
operating system secure boot
that can then check the

50
00:05:08,833 --> 00:05:15,667
signature on all of the drivers
before it runs those. 	And we'll
be talking about attacks against

51
00:05:15,667 --> 00:05:22,833
all of that. 	And so, let's
start. Well, so the way we're
going to go about this, is we're

52
00:05:22,833 --> 00:05:27,250
going to go around this wheel
and we're basically going to
talk about different facets of

53
00:05:27,250 --> 00:05:33,708
attack surface on platform
firmware. And we're going to
start with the spy flash. 	Now

54
00:05:33,708 --> 00:05:39,708
like I was saying, it's a pretty
nice place. And so what we do on
the platform, so the nature of

55
00:05:43,042 --> 00:05:50,125
this, first of all, step back.
There's a whole bunch of stuff
here. There's, uh . . . We're

56
00:05:50,125 --> 00:05:54,625
going to blow through it really
fast. That's why we mentioned
we'll be in the hardware village

57
00:05:54,625 --> 00:05:58,375
afterward, if you really want to
go into some detail and try to
understand it with us we'll be

58
00:05:58,375 --> 00:06:04,083
happy to walk you through it.
	So. Back to spy flash, like I
said, it's a really good place

59
00:06:04,083 --> 00:06:09,500
to be. There's two real sort of
methods, to protecting it,
right? One is based on system

60
00:06:09,500 --> 00:06:14,125
management mode. System
Management Mode is a different
mode of the CPU. It executes out

61
00:06:14,125 --> 00:06:19,792
of a kind of protected region of
memory. And it's protected such
that that you can't read or

62
00:06:19,792 --> 00:06:23,917
write this while not in system
management mode, all of the
sudden you transition into

63
00:06:23,917 --> 00:06:30,000
system management mode and there
it is. 	Um. So one method is to
use system management mode to

64
00:06:30,000 --> 00:06:35,333
protect it. You set a bunch of,
uh, you basically disable write
access and then you lock it and

65
00:06:35,333 --> 00:06:39,292
if you try to re-enable it, it
will generate a system
management interrupt and that's

66
00:06:39,292 --> 00:06:44,167
what transitions the machine
into system management mode and
it starts executing the SMI

67
00:06:44,167 --> 00:06:51,417
handler. 	Um. So you have to set
a bunch of bits and a bios
control register and that will

68
00:06:51,417 --> 00:06:59,000
lock the spy flash from writes
and it will also, um, it can
also force writes which can only

69
00:06:59,000 --> 00:07:03,958
occur when in system management
mode. 	The alternate way if
you're not using SMM would be to

70
00:07:03,958 --> 00:07:09,958
use the spy protected ranges
that are PR 0-4, there's five
sort of ranges. And you can

71
00:07:13,667 --> 00:07:18,250
basically set up a base and a
limit and that region gets
protected and you can set it to

72
00:07:18,250 --> 00:07:22,833
be write protected. And it will
be that way up until your boot
platform. 	So there's two

73
00:07:22,833 --> 00:07:28,125
different methods, you know, you
can sort of see what your
platform does. You can go and

74
00:07:28,125 --> 00:07:33,167
find the bios control registry,
you can read it and say, gee,
what bits are set? 	So you can

75
00:07:33,167 --> 00:07:39,167
do that with some tool manually
and that's kind of a pain, so we
wrote a tool called chip set and

76
00:07:46,500 --> 00:07:49,458
Miter has a tool called
Pernicious. You can basically go
and see what these bits are set

77
00:07:49,458 --> 00:07:52,958
to. So you can see at the top
there you have got bios write
enable, right? And then you want

78
00:07:52,958 --> 00:07:57,250
to see that's disabled, so zero.
You've got Bios lock enable, you
would like to see this is locked

79
00:07:57,250 --> 00:08:03,458
and that's what will generate
the SMI. 	And then you have got
SNMBW3. That forces the write to

80
00:08:03,458 --> 00:08:08,875
occur when you are in SNM. 	So
then we are checking the other
mechanism as well. The red line

81
00:08:08,875 --> 00:08:14,875
down below is talking about what
the spy protected ranges are
doing. So you've got the range

82
00:08:17,500 --> 00:08:22,000
itself and write protect, and it
will be checking to see that
your covering the entire Bios

83
00:08:22,000 --> 00:08:28,167
region. You can do either one of
these things and it can work.
	So if you don't cover the

84
00:08:28,167 --> 00:08:34,208
entire Bios region, then you're
allowing somebody to write to
that. And if they do that, then

85
00:08:34,208 --> 00:08:39,500
you get things like what Uri
presented last year at blackhat
where you can just sort of write

86
00:08:39,500 --> 00:08:44,958
whatever you want there, which
could be shell code, it could
bejust random junk that breaks

87
00:08:44,958 --> 00:08:50,958
the platform, it's bad. 	We're
going to push all of our demos
to the end because we've got a

88
00:08:53,750 --> 00:08:58,917
lot of stuff and we're afraid of
running out of time, so we've
got them, we'll get to them at

89
00:08:58,917 --> 00:09:02,625
the end. If you are really
interested or if we miss stuff,
come see us in hardware village

90
00:09:02,625 --> 00:09:08,958
and we'll have everything for
you there. 	So here's the nice
one, Teddy Reed presenting

91
00:09:08,958 --> 00:09:15,333
something really cool recently
where he was looking at a bunch
of Bios updates and seeing what

92
00:09:15,333 --> 00:09:19,667
they were doing and in
particularly seeing who wasn't
doing that. This was really

93
00:09:19,667 --> 00:09:25,667
interesting. He calls this one
day from hell, which is kind of
a good word for it actually. In

94
00:09:28,625 --> 00:09:34,625
this update you can actually see
the patch is adding the lock
bits being set. All right? 	But

95
00:09:37,167 --> 00:09:43,167
remember in the last slide I was
actually saying there's a few
lock bits you have to set, and

96
00:09:49,625 --> 00:09:53,875
there are a couple of things you
have to do and it's not actually
doing them all, so that's even

97
00:09:53,875 --> 00:09:57,667
more interesting. 	Um. So the
first mechanism was the system
management mode, right? If you

98
00:09:57,667 --> 00:10:05,292
use system management mode, then
you get a system management
interrupt triggered when you try

99
00:10:05,292 --> 00:10:11,292
to flip -- when you try to flip
the Bios write, the write
protection off. 	What if you

100
00:10:14,625 --> 00:10:19,667
could suppress SSMIs? If you
could suppress SSMIs then that
system interrupt would not

101
00:10:19,667 --> 00:10:25,667
occur. The system would simply
have the spy flash unlocked and
now you can write to the spy

102
00:10:29,167 --> 00:10:35,167
flash. Well, Miter presented a
little bit earlier this year an
attack where if the SMI lock bit

103
00:10:39,208 --> 00:10:46,750
is not set, then you can
actually disable SMIs. And that
does what I said, it kind of

104
00:10:46,750 --> 00:10:51,208
causes a problem. 	So basically
you want to check your platform
to see that this is set up and

105
00:10:51,208 --> 00:10:57,208
that it's locked, in
particularly that it's locked.
	Remember the other mechanism,

106
00:11:00,917 --> 00:11:04,958
you can use the spy flash itself
with these protected ranges.
Well, you have to configure

107
00:11:04,958 --> 00:11:08,375
those properly, right? So that's
what we were talking about
earlier, but, you know, you also

108
00:11:08,375 --> 00:11:12,917
have to lock that. So you can
set it up and then not lock it
and then somebody can change it.

109
00:11:12,917 --> 00:11:18,917
So that's what the F lock down
bit is all about. Again, you can
just check for that. 	So now

110
00:11:21,042 --> 00:11:24,125
let's talk about a different
interface. We talked about spy
flash. Let's talk about Bios

111
00:11:24,125 --> 00:11:30,083
update as an interface itself.
We're talking about these Bios
attacks and we're thinking, this

112
00:11:30,083 --> 00:11:35,333
is really complicated, low level
stuff people don't know anything
about, so you'll never see it,

113
00:11:35,333 --> 00:11:41,167
right? 	Well, Mebroni is an
example of this actually being
done in malware, right? So they

114
00:11:41,167 --> 00:11:48,917
basically used a particular Bios
that did not enforce any sort of
protection on its Bios update

115
00:11:48,917 --> 00:11:56,375
interface, simply used that Bios
update interface to introduce
its little boot kit directly

116
00:11:56,375 --> 00:12:02,375
into the Bios. 	Another issue,
even if you have tried to
protect the interfaces, there's

117
00:12:06,250 --> 00:12:12,250
occasionally some data that you
don't -- can't really trust. 	So
a few years ago, the talk by

118
00:12:15,750 --> 00:12:23,375
invisible things lab showed an
issue with an Intel bios where
basically the image that gets

119
00:12:23,375 --> 00:12:28,583
displayed on your screen when
you power up, yeah, that was
just an image that was being

120
00:12:28,583 --> 00:12:35,000
parsed and it was not really
verified in any way, so they
found on inner droner flow that

121
00:12:35,000 --> 00:12:39,625
allowed them to take control
that bios there just by
substituting that image.

122
00:12:41,750 --> 00:12:49,125
	Similarly, a little while ago
Miter published an interesting
thing with the update packets.

123
00:12:49,125 --> 00:12:55,125
So bios updates often, they
break up the update into a bunch
of little sections, right? Which

124
00:12:57,750 --> 00:13:05,250
then need to be put together
when, after you reboot and
you're going to actually install

125
00:13:05,250 --> 00:13:10,167
the Bios update. 	Well, what
they found is that when they
were putting this together, they

126
00:13:10,167 --> 00:13:15,625
were talking the fields of these
packets and they were using that
in an MEM copy and then they

127
00:13:15,625 --> 00:13:21,542
could basically use maliciously
formed packets to take control
right as you are doing the Bios

128
00:13:21,542 --> 00:13:27,542
update itself. 	So then there's
SM RAM. So I mentioned some of
the protections are dealing with

129
00:13:29,708 --> 00:13:35,042
system management mode, right?
So system management mode, I
think I described it as having,

130
00:13:35,042 --> 00:13:41,458
being a separate execution mode
that's protected. Well, it's
protected as long as it protects

131
00:13:41,458 --> 00:13:48,792
itself, right? So the first bit
that we'll talk about is the
sort of legacy or compatibility

132
00:13:48,792 --> 00:13:56,292
SM RAM. And I think this is best
done with a picture. 	So
normally you have code executing

133
00:13:56,292 --> 00:14:01,708
and you're writing memory
addresses and you're usually
writing to D ram, but

134
00:14:01,708 --> 00:14:07,708
occasionally you find things
like memory map bio. With SM RAM
when you are in normal execution

135
00:14:10,125 --> 00:14:17,917
mode, you will basically pass
through and go straight through
the system bus, right? 	When

136
00:14:17,917 --> 00:14:23,917
you're in SM -- or when you set
up SM ram, you need it to be
able to talk to actual D ram,

137
00:14:27,542 --> 00:14:33,708
right? And that is flipped with
these, with this particular
register, some particular bits

138
00:14:33,708 --> 00:14:39,708
in this register. Basically bios
will set it up and say, it will
start up open and it will load

139
00:14:42,000 --> 00:14:47,833
up SMI handlers there and close
it and lock it. So you want to
check it is actually closed and

140
00:14:47,833 --> 00:14:53,833
locked in SM ram. 	So after that
attack, a few years later, so
that was found like back in

141
00:14:56,833 --> 00:15:02,833
2006, I think by both Invisible
Things Lab and the Lloyd group.
You have got the same people, a

142
00:15:05,833 --> 00:15:13,333
couple years later, figuring
out, gee, if I -- if I'm really
just running out of ram, the way

143
00:15:13,333 --> 00:15:19,250
the processor works is it just
caches stuff, so if I can get
the instructions that I want to

144
00:15:19,250 --> 00:15:26,458
execute in the cache for those
addresses, then I could get it
to run whatever I want. And that

145
00:15:26,458 --> 00:15:30,917
works, right? 	So Intel
introduces these system
management range registers which

146
00:15:30,917 --> 00:15:36,917
will force the non-cached area
for those ranges that would be
SM ram. So what you can do is

147
00:15:39,708 --> 00:15:43,292
just look at the platform and
see, are those things
configured? Is that set up

148
00:15:43,292 --> 00:15:49,292
properly? 	I think I'm going to
turn it over here so that the
rest of this talk can be in

149
00:15:51,875 --> 00:15:56,208
Russian, because I think that
would be really helpful to
everyone because it's really

150
00:15:56,208 --> 00:16:02,208
easy to understand this stuff.
	>> Hey, everyone. Thanks for
coming. Even if you were here

151
00:16:06,167 --> 00:16:13,500
for Dan's talk. I don't know if
this mic works or not, but, I
mean, so I didn't know the dude

152
00:16:13,500 --> 00:16:18,958
actually knew that much about
bios, yeah, so it was awesome.
	Okay, I'll continue describing

153
00:16:18,958 --> 00:16:25,167
the attacks against SM RAM, it's
important. There are still
questions. You know, why do you

154
00:16:25,167 --> 00:16:32,583
need to get into the SM RAM, why
do you need to compromise SMI
handlers? If you have S-kernel

155
00:16:32,583 --> 00:16:38,083
privileges, for example. You can
do pretty much everything. Well,
there are a couple of reasons to

156
00:16:38,083 --> 00:16:43,333
do that. 	For example, according
to Government, you can get more
influence. You know? According

157
00:16:43,333 --> 00:16:49,583
to our friends from Miter team,
you can be bitten by a tick or a
flea. Just imagine, just think

158
00:16:49,583 --> 00:16:55,583
about that, none of the other
exploits can get you fleas. So
on a more serious note, SM ram,

159
00:17:02,750 --> 00:17:09,875
first you gotta to code there
and it's pretty much protected,
so you cannot really get it out

160
00:17:09,875 --> 00:17:15,875
there. Plus it can patch the OS,
it can patch the head provisor,
more importantly it can patch to

161
00:17:15,875 --> 00:17:21,542
Bios so it can get persistency.
	As we showed some time ago, you
can get the early compromised

162
00:17:21,542 --> 00:17:26,875
device you can bypass, or you
can melt the evil main attacks
even against the full decryption

163
00:17:26,875 --> 00:17:31,958
systems that do use TPM. Or you
can bypass security. 	So
continuing in the line of the

164
00:17:31,958 --> 00:17:37,458
attacks, one of the attacks that
has been demonstrated using the
chip set remapping capability,

165
00:17:37,458 --> 00:17:43,917
without going into gory details,
basically on the platform you
have low MMIO which can be

166
00:17:43,917 --> 00:17:50,625
gigabyte and if you have 8
gigabyte of memory, you don't
want to waste one gigabyte of

167
00:17:50,625 --> 00:17:56,917
memory to the MMIO. So there's a
mechanism called Reclaimed. It
intends to reclaim that memory.

168
00:17:56,917 --> 00:18:02,792
	The way it works, there's a
window, if you access like
Windows, typically about four

169
00:18:02,792 --> 00:18:09,583
gig, it will get remapped by a
chip set to the place, to the D
ram behind that or lost to that

170
00:18:09,583 --> 00:18:15,583
MMIO. 	So there's -- it has to
be locked because if it's not
locked then the molar can use

171
00:18:18,000 --> 00:18:24,000
that, and the way exploit works
is that the attacker can drop
this boundary between D ram and

172
00:18:29,125 --> 00:18:35,125
MMIO below SM RAM and use that
remapping mechanism to remap to
the SM ram, so now your SM ram

173
00:18:37,250 --> 00:18:43,250
is in the memory covered by
MMIO. So obviously the
mitigation to that is just use

174
00:18:46,583 --> 00:18:52,583
the, you know, lock down the
configuration. 	Don't allow a OS
malware to reconfigure. 	Oh,

175
00:18:56,000 --> 00:19:00,875
yep, that's a good nice slide
with a nice picture of how it
actually works. This is a normal

176
00:19:00,875 --> 00:19:06,125
memory map. That's how it
actually works, the attack. You
drop TOL, you access the memory

177
00:19:06,125 --> 00:19:11,792
reclaim range, about four
gigabits, and the chip remaps it
to above, which is now SM RAM.

178
00:19:11,792 --> 00:19:16,750
You modify the SM handler, you
inject a key logger or something
like that, and then you return

179
00:19:16,750 --> 00:19:23,208
back to that configuration. 	So
your SM has malicious code. And
there's a check for that. So

180
00:19:23,208 --> 00:19:29,208
I'll be flying through those
type of slides. 	So the other
type of attack and I'll show you

181
00:19:32,167 --> 00:19:38,042
a picture, so normal, normal
system looks like that,
including graphics and graphic

182
00:19:38,042 --> 00:19:45,708
stuff. 	So for example, there's
an MMIO bar that points to a
graphics translation table. And

183
00:19:45,708 --> 00:19:52,542
so they are used to translate
access coming to this graphic
separator which is the second

184
00:19:52,542 --> 00:19:58,542
yellow box. And it translates
access to that graphic separator
to graphics memory. However,

185
00:20:02,292 --> 00:20:07,833
that can be used to attack SM
RAM as well. Assuming the
configuration is not locked, as

186
00:20:07,833 --> 00:20:13,417
in the previous remapping
attack. For example, the bios
forgot to lock the TOL. You can

187
00:20:13,417 --> 00:20:19,417
see how that would be used to
attack. Somebody drops a TOL,
similar to the previous attack.

188
00:20:22,875 --> 00:20:30,375
	But instead of using remapping,
the exploit can now -- you can
see that SM ram is now in MMIO,

189
00:20:30,375 --> 00:20:37,458
so when SMI event occurs, CPU
tries to fetch something, but
not from D RAM, but from MMIO,

190
00:20:37,458 --> 00:20:42,500
but there is nothing there. So
the attacker overlaps the
graphic separator on top of

191
00:20:42,500 --> 00:20:47,583
that. So there's a double
redirection and it redirections
the graphic separator, so

192
00:20:47,583 --> 00:20:53,250
according to GTT interest that
have also been replaced by the
attacker, somewhere else, that

193
00:20:53,250 --> 00:20:58,500
is the third redirection. 	I
call it in the tradition of Jean
Claude VanDamme, I call it

194
00:20:58,500 --> 00:21:06,125
triple redirection attack, so
using these multiple hubs the
attackers to force CPU to fetch

195
00:21:06,125 --> 00:21:13,000
the code from some other place
outside of the protected range.
So the solution is the same as

196
00:21:13,000 --> 00:21:20,917
in the previous attack. It's --
just make sure the attacker
cannot do those tricks, cannot

197
00:21:20,917 --> 00:21:26,917
do the reconfiguration. 	So you
heard there was a lot of
research on DMA attacks and if

198
00:21:34,167 --> 00:21:40,833
someone can use DMA let's say
from a graphics card or network
card, if firmware on the card is

199
00:21:40,833 --> 00:21:46,833
compromised, or even from the
west kernel exploit that
directly asks some of the cards

200
00:21:51,042 --> 00:21:57,042
to do the DMA to protected
memory, you want to be able to
protect the system management

201
00:21:59,083 --> 00:22:05,792
mode and a code from those kind
of attacks. And the way it's
done in the platforms is there

202
00:22:05,792 --> 00:22:12,208
is a protection on the chip set
level that basically says
there's an enough stream

203
00:22:12,208 --> 00:22:20,042
transaction, memory targeting
SMN memory which is defined as
BoV Tsvg base, which in that

204
00:22:20,042 --> 00:22:25,667
case, just lock that, don't
allow that. 	However, it still
relies on the platform channel,

205
00:22:25,667 --> 00:22:32,125
the bios firm ware to lock down
the configuration. So for
example, in the previous attacks

206
00:22:32,125 --> 00:22:38,000
if the bios forgets to lock down
configuration and allows malware
to modify it, the malware could

207
00:22:38,000 --> 00:22:44,000
change the base of where the SM
ram is from, perspective. And,
therefore, once you do that, now

208
00:22:47,083 --> 00:22:53,083
the attack, the DMA attack can
work. So the DMA cycles are
below T seg and they are allowed

209
00:22:56,208 --> 00:23:01,833
to get through to the memory.
Right? 	There are two actually
variances of this attack though.

210
00:23:01,833 --> 00:23:08,542
One variance is regular DMA from
some unknown card, for example,
a network card at the bottom of

211
00:23:08,542 --> 00:23:13,125
the slide. And there is also
another variant through the
graphic separator, which is

212
00:23:13,125 --> 00:23:20,500
treated as a DMA as well. Yeah,
and in a couple of weeks we're
releasing a test for the

213
00:23:20,500 --> 00:23:26,500
vulnerability in the open source
section and you can take a look
at that. 	So other than

214
00:23:30,333 --> 00:23:36,333
protecting SM ram, obviously
there may be other issues, you
know, issues with the hardware

215
00:23:36,333 --> 00:23:43,167
configuration that it can be
improperly configured, it can be
reconfigured by the malware and

216
00:23:43,167 --> 00:23:50,917
that can result in certain
attacks on bios, secure boot and
so on. 	 One of those attacks

217
00:23:50,917 --> 00:23:56,917
was demonstrated in 2007 at POC
conference by a person from
McAfee and it was a bios swap,

218
00:23:58,917 --> 00:24:05,958
but a block/swap attack. There's
a mechanism in trip set that
allows you to do full tolerant

219
00:24:05,958 --> 00:24:10,958
update of the bib lock. The bib
lock is the top most lock of the
spy flash ware. The bios is

220
00:24:10,958 --> 00:24:17,208
where the reset factor is and so
on. 	So normally CVU coming out
of reset, it starts fetching

221
00:24:17,208 --> 00:24:24,042
instructions from the catch line
below for a gig. So FFFFF, zero
address. That's the reset

222
00:24:24,042 --> 00:24:30,208
vector. However, in order to do
the full tolerant update,
there's a mechanism that allows

223
00:24:30,208 --> 00:24:36,792
you to switch where the reset
vector is. Basically which block
the reset vector will be

224
00:24:36,792 --> 00:24:42,792
executed in. 	To show that on a
better picture, so the top most
picture is the original boot and

225
00:24:45,083 --> 00:24:52,208
the bottom part of the slide is
when this top swap mechanism is
enabled. So you can see that any

226
00:24:52,208 --> 00:24:59,583
access that targets spy flash a
firmware hub or basically
anywhere bios firmware is, it

227
00:24:59,583 --> 00:25:06,500
gets swapped, so now the reset
factor, it's now an alternate
bios bib lock, backup bib lock.

228
00:25:06,500 --> 00:25:13,875
	So obviously if bios allows to
do those kinds of tricks to the
OS malware, OS malware could

229
00:25:13,875 --> 00:25:20,792
enable top swap mode and then
because this has to survive the
reboot, the malware reboots the

230
00:25:20,792 --> 00:25:22,792
system. The CPU will fetch the
instructions from somewhere
else. 	It could be an OS and

231
00:25:22,792 --> 00:25:28,792
you'll get an unbootable system
or it could be malicious code,
if that piece, if that alternate

232
00:25:33,417 --> 00:25:39,417
bib block wasn't protected, it
could be a malicious virus. 	So
the way to mitigate that is

233
00:25:42,875 --> 00:25:50,625
essentially, you know, block
malware's capability to modify
the bib block. Okay, so now

234
00:25:50,625 --> 00:25:57,167
obviously people realize that
attacking SM ram through some
hardware tricks or configuration

235
00:25:57,167 --> 00:26:02,208
tricks is not enough. 	There's a
whole bunch of stuff running in
the SM ram those are called SY

236
00:26:02,208 --> 00:26:08,042
handlers. And they have been
developed a couple of decades
ago with nobody thinking about

237
00:26:08,042 --> 00:26:14,042
security back then, well, not
security of SMN. Not that role.
there may be bugs there. One of

238
00:26:19,792 --> 00:26:26,708
these types of attacks had been
discovered and published in 2008
or 2009, I forgot, so basically

239
00:26:26,708 --> 00:26:32,000
you have SM ram and you have a
bunch of firmware running. 	
	And I'm due for a shot, sorry.

240
00:26:32,000 --> 00:26:38,792
	>>Take your time. You all know
why we're here! 	 	>>
[Applause]. 	 	>> I just want to

241
00:26:38,792 --> 00:26:44,875
point out, as we were walking up
here to shot these guys, there
was a guy walking out and I

242
00:26:44,875 --> 00:26:51,292
said, why are you walking out of
this talk? I thought this would
be a pretty good one. He said oh

243
00:26:51,292 --> 00:26:56,792
man, it's over my head. I'm a
colonel programmer from way
back. That guy is a pussy. 	>>

244
00:26:56,792 --> 00:27:02,792
Oh, you? You've got it going on.
All right, how about some love
for the new speakers. 	>>

245
00:27:06,000 --> 00:27:12,000
[Applause]. 	>> where are his
shots?! That was wrong, that was
wrong! As you were. 	>> Okay. So

246
00:27:21,000 --> 00:27:28,958
where I was. Oh man, memory
plays tricks on me. 	So, types
of vulnerabilities in the SMI

247
00:27:28,958 --> 00:27:35,500
handlers. The first type was
discovered, as there are a lot
of SMI handlers, but a lot of

248
00:27:35,500 --> 00:27:41,042
the routines that they use,
let's say talk to hardware, talk
to RTC, talk to registers and so

249
00:27:41,042 --> 00:27:46,167
on, they are wrapped in two
functions. But there's a
precious space, spyflash is a

250
00:27:46,167 --> 00:27:51,417
precious space and so you can
not really move that code to the
SM ram all the time. You already

251
00:27:51,417 --> 00:27:57,333
have that code in the bios,
which is in the D ram. So why
not just use it and call it? And

252
00:27:57,333 --> 00:28:03,250
that's what SMI handlers did.
	You can say call F 0000,
segment selector, call segment

253
00:28:03,250 --> 00:28:10,667
selector, with some EIP. And it
happens to be translated to a
physical address in F segment

254
00:28:10,667 --> 00:28:16,667
below one megabyte which is not
protected. So that's how it
works. Somebody found this out

255
00:28:20,833 --> 00:28:25,875
and replaced that function that
the SMI handler calls with the
malicious code and the SMI

256
00:28:25,875 --> 00:28:32,333
handler will do the job for you.
It will just invoke that
function. 	So yeah, that has

257
00:28:32,333 --> 00:28:36,208
been published. And what's
interesting is that the
vulnerability disclosure just

258
00:28:39,167 --> 00:28:45,167
disclosed fourteen issues in one
SMI handler out of 30, which
amounts for hundreds in one

259
00:28:48,625 --> 00:28:54,625
single bios. And remember that
flash ware typically uses the
same bios. 	So, in going to EFI,

260
00:28:58,500 --> 00:29:04,500
obviously this type of
vulnerability, this is almost
away, almost, because EFI bios

261
00:29:06,875 --> 00:29:14,792
still want to invoke something
from outside of SM RAM and in
that particular example, the

262
00:29:14,792 --> 00:29:20,792
SMI, the EDK based SMI handler,
it wasn't directly calling the
function, it was actually

263
00:29:22,792 --> 00:29:28,250
reading the function pointer
from the ACPI, from the normal
Intel memory which is not solid,

264
00:29:28,250 --> 00:29:34,625
it's in D RAM, and then calling
it. So pretty much the same type
of problems, but slightly

265
00:29:34,625 --> 00:29:40,625
different. 	So now I am
switching to the attacks against
secure boot. We've been

266
00:29:42,625 --> 00:29:48,250
researching that area for a
year, year and a half, and I'm
giving the microphone to Alex

267
00:29:48,250 --> 00:29:56,042
who will start with the attacks
against secure boot. 	 	>> My
name is Alex. So I would

268
00:29:56,042 --> 00:30:01,500
describe a little bit about
secure boot and how we secure
boot. 	So basically there's most

269
00:30:01,500 --> 00:30:08,625
important thing in secure boot
implantation is hierarchy and
there is the platform key that

270
00:30:08,625 --> 00:30:14,625
you set the vendor key. This you
need to verify the exchange key
and the change key needs to

271
00:30:17,625 --> 00:30:23,625
verify the wide list and set
list signature for modules and
banner which can load the secure

272
00:30:25,708 --> 00:30:31,708
boot, and boot disable. platform
key is stored in normal memory
and spyflash. It is a variable

273
00:30:35,250 --> 00:30:41,250
which is protected and bios
check -- if bios can find the
platform key, it will allow,

274
00:31:12,375 --> 00:31:18,208
enable the secure boot. If not,
bios assumes that secure boot is
disabled. 	So basically this is

275
00:31:18,208 --> 00:31:24,000
where we create our exploit from
secure boot bypass. For this
exploit, you need to have an

276
00:31:24,000 --> 00:31:29,458
ability to write and protect
mechanism bios, so basically we
will talk a little bit about

277
00:31:29,458 --> 00:31:35,958
this exploit. So we just as a
regular variable, the platform
key has a name and body, so if

278
00:31:35,958 --> 00:31:41,750
you corrupt the name of the
variable, then bios didn't find
the variable and you can assume

279
00:31:41,750 --> 00:31:48,583
bios is disabled, so you have a
secure boot. 	And as you can
check in this slide, in the left

280
00:31:48,583 --> 00:31:54,750
hand we have the original down
post spyflash platform key, and
on the right hand we have the

281
00:31:54,750 --> 00:32:00,208
identification like this and we
have this corrupt platform key.
	There is a high level picture

282
00:32:00,208 --> 00:32:06,042
of our attack. So. We corrupt
the platform key to compromise
bios enough so that we install

283
00:32:06,042 --> 00:32:11,833
boot key to unify partition and
compromise the full system. And
this is the demo. This part

284
00:32:11,833 --> 00:32:18,333
should be joke, but I skip it. 	
	>> [Laughter]. 	>> We want to
start thinking about how we can

285
00:32:18,333 --> 00:32:23,458
bypass a secure boot, and how
bios should implement secure
boot internal. This should be

286
00:32:23,458 --> 00:32:30,042
the variable of the secure boot
enable which is enabled and by
here should be different and

287
00:32:30,042 --> 00:32:34,833
related to this variable. And
you can check and it should
find. 	So the next very good

288
00:32:34,833 --> 00:32:40,833
experiment which we did, it's
great too, was full spy flash.
One of the secure boot enable

289
00:32:43,583 --> 00:32:49,792
and one secure boot disable. And
compare this dump. So if you are
trying to do that, it's not

290
00:32:49,792 --> 00:32:56,875
really easy. But after that we
implemented some forensics. So
after that we implement the chip

291
00:32:56,875 --> 00:33:02,875
set and you can sparse the spy
image, and extract all DLLs, all
D drivers, all EFI variables and

292
00:33:05,500 --> 00:33:12,917
compare it independently. 	And
to be cached, we're interested
in BFI variable, the set up

293
00:33:12,917 --> 00:33:18,917
variable, it's a run down
variable so you can modify it
from Windows EPI. And if you

294
00:33:24,250 --> 00:33:31,917
flip back to this, you can very
easily disable secure boot. So
basically just run very simple

295
00:33:31,917 --> 00:33:38,458
Windows EPI function and flip
two bits from three you can do
that with security boot. So that

296
00:33:38,458 --> 00:33:44,458
will be the second demo. And we
will continue to talk about
this. 	 	>> The policies,

297
00:33:49,583 --> 00:33:55,750
policies is the way of the bios
to configure the image
verification behavior. So they

298
00:33:55,750 --> 00:34:01,250
may choose to skip image
verification if the image is
loaded from protected spy flash

299
00:34:01,250 --> 00:34:07,250
or choose a different behavior
in the image verification is
failed. Like, ask a user, or It

300
00:34:14,750 --> 00:34:20,750
allows the image execution. So
this is how it's implemented in
open source, ETK2, so as you can

301
00:34:30,292 --> 00:34:35,958
see there, there are fixed
values taken from the
configuration database, so they

302
00:34:35,958 --> 00:34:41,958
cannot be changed in run time.
	But sometimes bios may choose
some flexibility and it decide

303
00:34:44,458 --> 00:34:50,458
can be set up. So this is an
actual screen shot from an a
secure boot image verification

304
00:34:55,583 --> 00:35:01,583
violation. And that variable,
did have these values, after
some trials and errors, we found

305
00:35:07,667 --> 00:35:13,667
the location. 	So here they are.
As you can see this 044 is for
optional policy, fixed media

306
00:35:17,625 --> 00:35:25,167
policy and removal media policy.
0 is for the all execute, 4 is
for deny execution. So all they

307
00:35:25,167 --> 00:35:32,042
need to do is just modify the
set up variable and change the
subset notice to zero. And we

308
00:35:32,042 --> 00:35:39,417
have execution. 	So this way the
secure boot is still enabled,
but no verification is performed

309
00:35:39,417 --> 00:35:45,417
so you can load whatever you
want. And this issue was
discovered together with the

310
00:35:49,000 --> 00:35:55,000
Miter guys -- this is a slide
from their presentation. They do
a reverse engineer and this

311
00:35:58,000 --> 00:36:04,000
shows the values for the policy
are taken from the set up
variable. This should be a demo.

312
00:36:06,292 --> 00:36:12,292
So a couple of guidelines to
bios, how to avoid these issues.
	So first of all, if you protect

313
00:36:15,750 --> 00:36:21,750
the settings, if you decide to
move them into EFI variables,
make those variables

314
00:36:26,375 --> 00:36:33,708
inaccessible and don't expose
them to a breaking system and
untrusted software. The

315
00:36:33,708 --> 00:36:41,542
variables are authenticated, so
only you can change and update
them. And to check that the user

316
00:36:41,542 --> 00:36:47,542
is physically present and
modifying those. And, of course,
the default and image

317
00:36:49,917 --> 00:36:55,917
verification policies to secure
those. Don't use always execute
or allow execute and default

318
00:37:02,125 --> 00:37:08,125
variables. And image
verification handlers should
take care not only on secure

319
00:37:13,750 --> 00:37:20,208
boot settings and policies, but
it should also check if the
executed image has a supported

320
00:37:20,208 --> 00:37:26,583
format. 	Currently the only
supportive format for this is
the Bkav image software. The

321
00:37:26,583 --> 00:37:32,583
bios firmware can verify the
signature and image only if it's
Bkav. Sometimes bios

322
00:37:42,792 --> 00:37:48,792
specifications are defined as
executable from us. Yes. The two
other formats, the first one is

323
00:37:54,083 --> 00:38:00,083
the EFI Bitcord, which actually
is the same Bkav image wrapping
around the EFI Bitcord. And

324
00:38:03,208 --> 00:38:07,583
there so-called Terse,
executable G. Which is not a
Bkav image. But the only

325
00:38:07,583 --> 00:38:13,583
difference from the Bkav image
is G hello. This is much smaller
than Bkav and this was done to

326
00:38:20,708 --> 00:38:26,708
conserve the precise space in
spy flash. 	So the G images are
usually always from spy flash.

327
00:38:35,625 --> 00:38:41,625
	Let's take a look at the actual
implementation inside EFI bios.
So the parse spy flash dumped

328
00:38:43,917 --> 00:38:51,333
this and we found that the dixit
drivers that actually implement
the image verification library.

329
00:38:51,333 --> 00:38:57,333
It's core dixit. E file. 	So
load it into IDA Pro and we
found that the function that is

330
00:39:00,542 --> 00:39:06,542
left is the image verification
heller and what it does is it
calls functions that checks that

331
00:39:10,375 --> 00:39:16,375
the executable image is a valid
Bkav image. And it returns an
error if it's not. And if

332
00:39:19,958 --> 00:39:25,958
results in an error, the image
verification hierarchy just
checks, if the error is set. If

333
00:39:31,333 --> 00:39:37,333
not, it will continue execution.
But if the error was returned it
just returns zero, which

334
00:39:39,750 --> 00:39:45,750
actually is a success. 	So no
verification is performed, it
just skipped. So secure boot is

335
00:39:49,292 --> 00:39:55,292
still enabled, but no
verification is done. So that is
simple. Just get the executable

336
00:40:01,875 --> 00:40:07,875
and bootkey go to T format by
replacing the Bkav heller and
replace a break in system orders

337
00:40:12,333 --> 00:40:18,333
on the partition and that's it.
	 	>> All right, we have 5
minutes and I want to show at

338
00:40:27,792 --> 00:40:32,667
least one demo because we have
four or five demos. You can
catch us later and we can show

339
00:40:32,667 --> 00:40:39,167
more demos. But a couple more
issues, so other problems that
we have discovered in some of

340
00:40:39,167 --> 00:40:43,333
the bios, they enable CSM which
is a compatibility support
module, which allows you to boot

341
00:40:43,333 --> 00:40:49,333
legacy OS on top of the EFI
firmware, basically enabling CSM
with secure boot. That's a bad

342
00:40:54,500 --> 00:41:00,250
idea. Secure boot should check
signatures, but legacy boot
doesn't know about the

343
00:41:00,250 --> 00:41:07,458
signatures at all. 	So the other
problems are some of the systems
allows the systems restore to

344
00:41:07,458 --> 00:41:13,458
secure boot configuration and
keys or set them to restore to
default, or clear them. So

345
00:41:16,792 --> 00:41:22,375
remember the first attack
corrupting PK? You can clear
secure boot configuration which

346
00:41:22,375 --> 00:41:28,000
will disable, which will remove
platform key. And guess what
will happen? Secure boot will

347
00:41:28,000 --> 00:41:33,708
get disabled. So some of the
bios they actually store a bit
that tells them to start this

348
00:41:33,708 --> 00:41:40,375
clearing in an unprotected
configuration available to the
ring three. 	And this is, was my

349
00:41:40,375 --> 00:41:46,417
favorite. This was not really an
exploit because we didn't need
to do anything. I mean, what we

350
00:41:46,417 --> 00:41:52,875
did is on some of the laptops,
on specific models of specific
vendors, what we figured is we

351
00:41:52,875 --> 00:41:58,167
can change the configuration
secure bit, we could disable it,
but they've implemented a

352
00:41:58,167 --> 00:42:02,417
signature hashing scheme where
they actually store the hash,
the critical configuration

353
00:42:02,417 --> 00:42:07,542
somewhere and they check if it's
changed. And they tell the user,
hey, it's changed, you know? 	So

354
00:42:07,542 --> 00:42:13,542
what they do is they do it three
times, wait for two seconds. We
didn't catch that attack

355
00:42:18,000 --> 00:42:23,458
immediately. We actually figured
this out in a week or so. Then
they continue booting with the

356
00:42:23,458 --> 00:42:29,792
changed settings. And this is
the cryptic message that you
should be able to, you know, do

357
00:42:29,792 --> 00:42:35,458
something in urgently because
somebody is trying to put a boot
kit your system, within 2

358
00:42:35,458 --> 00:42:40,583
seconds or 3 seconds. 	So there
are other problems with the
bios, specifically for settings,

359
00:42:40,583 --> 00:42:45,875
for example, Jonathan Brussard
disclosed the vulnerability some
time ago that the bios don't

360
00:42:45,875 --> 00:42:52,292
clear the keyboard bar first,
you tie a bios password, an HDD
password, so you have a

361
00:42:52,292 --> 00:42:57,542
pre-authentication system
password and then it lies around
in memory and is available to

362
00:42:57,542 --> 00:43:05,083
anyone. The bios need to clear
that. And we actually have a
test you can use to see if your

363
00:43:05,083 --> 00:43:11,500
bios system is clearing that.
	Oh, SMI handlers, we have one
minute, so I'll just say a

364
00:43:11,500 --> 00:43:16,375
couple words that we do continue
research in vulnerability
affecting bios and secure

365
00:43:16,375 --> 00:43:20,542
booting, we continue
coordination with all platform
manufacturers and bios vendors,

366
00:43:20,542 --> 00:43:26,167
specifically we are in the
middle of coordinating multiple
issues with EFI based SMI

367
00:43:26,167 --> 00:43:32,167
handlers. So in the last words,
so one may think all of these
attacks require kernel mode

368
00:43:36,833 --> 00:43:41,792
privileges. And typically yes,
you work with the hardware, you
work with the bios, you need to

369
00:43:41,792 --> 00:43:46,042
talk with the hardware
interface, IO ports, P second
fixed base, physical memory, so,

370
00:43:46,042 --> 00:43:50,792
yes, technically this is a
kernel privilege, but what we
have co-discovered with the

371
00:43:50,792 --> 00:43:58,458
Miter team is there are kernel
mode drivers that actually do
that for you. 	So you can ask to

372
00:43:58,458 --> 00:44:04,625
write to the physical memory or
boards or IO, MMIO or P-sec
config and they will do it. And

373
00:44:04,625 --> 00:44:11,375
they are assigned for old
versions of Windows that require
signatures. So, yes, that makes

374
00:44:11,375 --> 00:44:16,500
all of those attacks, even
though that initially required
kernel mode privileges as a user

375
00:44:16,500 --> 00:44:21,542
mode. You can compromise bios,
you can compromise SMM, you can
bypass secure boot, you can

376
00:44:21,542 --> 00:44:27,542
enable attack from user mode.
	There are guidelines. There's
lots of research. I do want to

377
00:44:30,208 --> 00:44:35,583
thank all of the researchers
that work in that obscure area,
because this is a baseline for

378
00:44:35,583 --> 00:44:40,917
the security of the entire
platform. You can catch us, I
don't have time even for one

379
00:44:40,917 --> 00:44:48,083
demo, but we will have videos
available of all of the demos
from this talk or you can catch

380
00:44:48,083 --> 00:44:54,083
us at hardware hacking village.
Thank you. Thanks everyone for
coming. 	 	>> [Applause]. 	 	>>

381
00:45:01,083 --> 00:45:07,500
Do I have one more minute? No?
We're done. 	 	>> Yeah. 	 	>>
Oh, so really sorry, we have one

382
00:45:07,500 --> 00:45:14,458
more minute, so I'll attempt a
live demo of bypassing secure
boot on the system we've been

383
00:45:14,458 --> 00:45:20,458
actually been presenting. You
can see why we waited until the
end of the presentation. 	So

384
00:45:23,500 --> 00:45:28,625
anyway, so secure boot is
enabled. I'm not showing that,
although I usually do. So we'll

385
00:45:28,625 --> 00:45:34,042
launch the exploit which is BT
header exploit. What we did is
we just replace the floater.

386
00:45:34,042 --> 00:45:38,458
That's it. But the bit loader
with a different boot kit has a
different pattern, that's it. 	 

