00:00:00.000 --> 00:00:06.006
im Adrian this and Zaiff is my
colleague and this is mostly his

00:00:06.006 --> 00:00:11.745
work I'm just a lucky guy or
unlucky guy three and a half

00:00:11.745 --> 00:00:17.317
thousand lines. >> What is --
seeing as you all in the room

00:00:17.317 --> 00:00:22.122
like to assume you no what
fuzzing is if you are expecting

00:00:22.122 --> 00:00:30.097
a talk about animals along those
lines sorry wrong time. Fuzzing

00:00:30.097 --> 00:00:35.168
is applying input or
manipulating input and

00:00:35.168 --> 00:00:42.409
application and seeing if you
can change application. We can

00:00:42.409 --> 00:00:49.616
simply say slow shit and seeing
what sticks. His tour of fuzzing

00:00:49.616 --> 00:00:53.954
-- we have to go back to 1999
the golden years of Miami Vice

00:00:53.954 --> 00:00:59.960
awesome suits rocking dance
moves, syntax fuzzing or using

00:01:06.233 --> 00:01:12.906
it for applications. Fuzzing is
continued since then seen big

00:01:12.906 --> 00:01:18.145
names, and another applying it
across multiple application

00:01:18.145 --> 00:01:25.218
multiple protocols and platform.
One thing that has stayed

00:01:25.218 --> 00:01:28.255
constant through the years is
the fuzzing methodology

00:01:28.255 --> 00:01:34.661
consisting of five steps step
one identify your target. Is it

00:01:34.661 --> 00:01:40.667
a browser, is it network stack
or anything like that. Once

00:01:42.803 --> 00:01:46.940
you've identified your target
you need top identify inputs to

00:01:46.940 --> 00:01:52.946
this tar G this can be done in
multiple ways. Either by using

00:01:52.946 --> 00:01:56.717
application and identifying
inputs or reviewing

00:01:56.717 --> 00:02:00.654
documentation for the
application or for you're

00:02:00.654 --> 00:02:05.892
target. Or by reversing -- the
application or finding hidden

00:02:05.892 --> 00:02:09.830
inputs that weren't identified
before. Once you identified you

00:02:09.830 --> 00:02:17.671
need to test -- can fall into
two categories either dumb

00:02:17.671 --> 00:02:22.876
fuzzing or smart. This can be
simply inserting a thousand --

00:02:22.876 --> 00:02:28.415
and seeing if application
crashes. When you are doing it

00:02:28.415 --> 00:02:34.488
you apply data to your inputs
without any prior knowledge of

00:02:34.488 --> 00:02:40.027
what application expecting or
what the data should look like.

00:02:40.027 --> 00:02:43.897
Smart fuzzing you use knowledge
about the input -- this is

00:02:43.897 --> 00:02:45.899
usually take and valid test data
and mutating in it different

00:02:45.899 --> 00:02:51.238
ways. Once you generated test
data you need to start fuzzing

00:02:51.238 --> 00:02:57.244
this is simple you feed date to
to target application and see

00:03:01.081 --> 00:03:07.087
what happens. To do this
application and in our case he

00:03:10.190 --> 00:03:16.196
monitor the application for
memory errors. So there are. >>

00:03:18.765 --> 00:03:25.605
So there are some tools that
help us with the process and

00:03:25.605 --> 00:03:30.577
memory error detector. What they
do they basically run the

00:03:30.577 --> 00:03:33.713
application, feed the test
application and monitor

00:03:33.713 --> 00:03:40.454
application for crashes. For
windows we have -- for Linux and

00:03:40.454 --> 00:03:43.890
-- OSPG memory error dee
particular force what they do

00:03:43.890 --> 00:03:49.896
early detect errors in memory
buy hooking and the -- memory

00:03:59.206 --> 00:04:05.145
applications around -- memory
any acusis to these application

00:04:07.214 --> 00:04:11.618
will result in crash to the
application. Also for windows we

00:04:11.618 --> 00:04:17.624
have, which is part of the
windows tool kit. Mic Ox -- the

00:04:24.765 --> 00:04:30.170
real reason you are here -- what
is -- all apart from the obvious

00:04:30.170 --> 00:04:36.176
meaning in -- may contain high
-- is a grammar based browser

00:04:42.916 --> 00:04:49.156
fuzzer what this means is that
we apply, we use other fine

00:04:49.156 --> 00:04:54.928
grammar to generate our test
cases and feed these into any

00:04:54.928 --> 00:04:59.299
browser that uses the same
grammar to construct its pausing

00:04:59.299 --> 00:05:01.468
methods. This approach has been
very successful and has resulted

00:05:01.468 --> 00:05:08.508
in numerous crashes high
security crashes in brow SERS.

00:05:08.508 --> 00:05:14.514
The reason we created it we
wanted to be able to identify

00:05:17.884 --> 00:05:25.258
bugs in existing and new web --
the process for this has usually

00:05:25.258 --> 00:05:32.299
been hard, a manual process you
normally focus on one BROWSER by

00:05:32.299 --> 00:05:38.104
looking at grammar are using
grammar to test cases we are

00:05:38.104 --> 00:05:42.108
able to quickly and easily
generate new test cases as new

00:05:42.108 --> 00:05:46.012
apps are brought up and
implemented in brow SERS by

00:05:46.012 --> 00:05:52.052
using the spek fiction the same
technology that you're browser

00:05:52.052 --> 00:05:59.292
or creators are using. This
allows us to test cases that are

00:05:59.292 --> 00:06:03.663
standard across browser and you
can use its same test cases for

00:06:03.663 --> 00:06:09.502
CR -- many chrome fire fox and
hopefully you get browser

00:06:09.502 --> 00:06:15.508
crashes. So -- all the way
through three, four, CSS, CSS

00:06:22.782 --> 00:06:27.988
three as well and at the moment
the web Anna mason API. But

00:06:27.988 --> 00:06:32.325
there are no limitation to which
API -- simply need to feed it

00:06:32.325 --> 00:06:36.663
the correct information and it
will generate correct test cases

00:06:36.663 --> 00:06:42.002
and it will be able to fuzz for
you. We all know what it means

00:06:42.002 --> 00:06:46.439
crashes that mean money. So no
one made it rain for us yet but

00:06:46.439 --> 00:06:54.347
we have made some money more
specifically -- yeah. The

00:06:54.347 --> 00:07:00.287
document object model provides
us standard objects to describe

00:07:02.822 --> 00:07:08.561
XML documents also provides
interfaces for interacting on

00:07:08.561 --> 00:07:15.435
these objects and manipulating
them. Web API and web API's give

00:07:15.435 --> 00:07:22.876
us Java script interfaces with
the object model. These web API

00:07:22.876 --> 00:07:28.882
can also consist of speech, web
audio, Anna mason latest one is

00:07:31.017 --> 00:07:38.458
web -- and API are being pushed
out constantly and hopefully

00:07:38.458 --> 00:07:44.531
being pushed out in all
BROWSERS. What is grammar.

00:07:44.531 --> 00:07:48.635
Grammar is something we use on
everyday basis if you apply

00:07:48.635 --> 00:07:53.673
braces two languages such as
English -- your grammar defines

00:07:53.673 --> 00:07:58.778
how a sentence should be
instructed when do you use a

00:07:58.778 --> 00:08:05.352
verb or none. In computer signs
are used to construct compilers

00:08:05.352 --> 00:08:11.992
and used for a compilers to
pause program mink language and

00:08:11.992 --> 00:08:16.796
verify syntax particular
testimony correct and how to

00:08:16.796 --> 00:08:24.070
generate . On the other hand
uses a grammar to -- much the

00:08:24.070 --> 00:08:29.376
same way as a compile her would
and generates our test cases for

00:08:29.376 --> 00:08:34.447
browser. If you want to put
grammar into one sentence

00:08:34.447 --> 00:08:39.986
specifically, knowing the
differences, your shift and you

00:08:39.986 --> 00:08:45.992
are shit -- you're shit and you
are shit. Grammar when applied

00:08:48.261 --> 00:08:54.267
to -- WL -- W three can he they
key -- this defines how browsers

00:08:58.605 --> 00:09:06.146
should implement new web API and
document model this could be

00:09:06.146 --> 00:09:10.650
described with -- so those of
you who have done computer signs

00:09:10.650 --> 00:09:15.989
no what an LO one grammar is and
how this relates to

00:09:15.989 --> 00:09:21.995
specifications. Simply put it
allows pausing of the -- and web

00:09:25.098 --> 00:09:31.004
API and standardized manner that
allows browser manufactures to

00:09:31.004 --> 00:09:34.941
all apply the same standard to
the browser technology unless

00:09:34.941 --> 00:09:37.744
Microsoft you kind of follow
your own spek fictions.

00:09:37.744 --> 00:09:40.580
Interface an interface --
defines a structure that can

00:09:40.580 --> 00:09:43.383
contain at contributes and
function that interact with the

00:09:43.383 --> 00:09:47.287
document object model. This is
the, here we see a grammar that

00:09:47.287 --> 00:09:53.293
defines this enter face object
and we can see that we have a

00:10:03.002 --> 00:10:07.640
token called interactive face
which we followed by an enter

00:10:07.640 --> 00:10:12.345
fire possible in tear tans and
in all the interface members or

00:10:12.345 --> 00:10:17.851
objects belonging to this
interface. If we create a simple

00:10:17.851 --> 00:10:24.491
and a simplified interface for
the next object we can see that

00:10:24.491 --> 00:10:30.763
we've got our identifier -- and
our inheritance -- we can also

00:10:30.763 --> 00:10:35.535
see in this case we've got four
interface members. These

00:10:35.535 --> 00:10:38.938
interface members can be
described individually as well

00:10:38.938 --> 00:10:42.142
and if we look at the grammar
for this we can see that we can

00:10:42.142 --> 00:10:47.680
have an interface member can be
ACON tan, which we are not

00:10:47.680 --> 00:10:53.686
interested in this case, what we
are interested in are the fact

00:10:57.857 --> 00:11:00.793
that it can be attributes or
options an attribute and option

00:11:00.793 --> 00:11:03.563
can either be values that
describe the interface or the

00:11:03.563 --> 00:11:06.232
functions that interactive act
with that interface. >> So if we

00:11:06.232 --> 00:11:09.802
just look at the at contribute
definition for -- at contributes

00:11:09.802 --> 00:11:14.073
we can see that we've got
possible inheritance read only

00:11:14.073 --> 00:11:19.512
flag that can be said the type
and identifier in this case one

00:11:19.512 --> 00:11:26.252
read only at contribute and one
read right at contribute and one

00:11:26.252 --> 00:11:32.225
-- and other same principal can
be applied to all functions and

00:11:32.225 --> 00:11:37.263
we can see that functions can
have a return type an identifier

00:11:37.263 --> 00:11:41.935
and possible inputs. And these
inputs can, by themselves have

00:11:41.935 --> 00:11:47.340
different input types and
values. >> When mapping IDL into

00:11:47.340 --> 00:11:54.948
grammar to grade our test cases
we map Java script object what

00:11:54.948 --> 00:12:01.821
we've done created an object for
at contribute an at contribute

00:12:01.821 --> 00:12:07.093
can have three members. The the
functions that allows us to

00:12:07.093 --> 00:12:11.497
generate data for that at
contribute type and whether the

00:12:11.497 --> 00:12:16.202
read only flag is set. When you
look at our functions the same

00:12:16.202 --> 00:12:21.140
principal has been applied, we
can create an array tank two

00:12:21.140 --> 00:12:26.112
members one with an identifier
for that function or mend. And a

00:12:26.112 --> 00:12:31.884
second array tank functions that
generate our test inputs to

00:12:31.884 --> 00:12:39.125
those functions. Here's the full
Java script object we created

00:12:39.125 --> 00:12:44.931
from our initial test from
initial text interface. We can

00:12:44.931 --> 00:12:48.368
see that we've set the name,
there's a text we've got at

00:12:48.368 --> 00:12:51.404
contribute have been defined and
we can generate expected value

00:12:51.404 --> 00:12:54.340
for those at at this time and
the same thing for mend we can

00:12:54.340 --> 00:13:00.280
create expected inputs. We --
with character data interface

00:13:09.856 --> 00:13:12.892
and the associated at contribute
and methods this is due to in

00:13:12.892 --> 00:13:15.328
her tense. >> So we have
functions that help us through

00:13:15.328 --> 00:13:18.364
the project most of it is used
during generation offer input

00:13:18.364 --> 00:13:23.770
date to either through the at
contribute which is governed by

00:13:23.770 --> 00:13:28.908
input or -- more significant of
these are the functions you've

00:13:28.908 --> 00:13:34.914
see in front of you one number
in at a grail -- supplied most

00:13:40.119 --> 00:13:42.955
importantly, we have three
function that we like to focus

00:13:42.955 --> 00:13:48.828
on the RA array and array work
which basically works through --

00:13:48.828 --> 00:13:51.330
if it's a string it will are
will just return a string if

00:13:51.330 --> 00:13:56.669
it's a function -- return value.
Last function return of the

00:13:56.669 --> 00:14:01.841
element which will refers
element through the fuzzer and

00:14:01.841 --> 00:14:07.180
will either it will reference
element directly or reference

00:14:07.180 --> 00:14:11.951
element first try, element last
try element -- or war it may be.

00:14:11.951 --> 00:14:17.957
The -- it creates test cases as
first element created --

00:14:22.462 --> 00:14:29.635
interface string -- preparation
test case. Test case is every

00:14:29.635 --> 00:14:35.641
whereas you can see. First works
on two space allow us to -- in

00:14:40.913 --> 00:14:46.919
the fuzzer BROWSER -- from the
test case. The next thing go is

00:14:51.090 --> 00:14:57.063
element creation. You can zero
that has three main functions

00:14:57.063 --> 00:15:02.568
for element creation that create
-- the create element will

00:15:02.568 --> 00:15:06.139
basically choose random
interactive face, create an

00:15:06.139 --> 00:15:09.642
element for it and save two
references one to the browser

00:15:09.642 --> 00:15:15.648
space element create random lens
text notes -- to the elements

00:15:22.789 --> 00:15:28.795
mingle the -- next we have --
basically fuzz with a certain

00:15:33.566 --> 00:15:37.937
number. This number will be used
to exact number of -- that this

00:15:37.937 --> 00:15:42.141
will execute, what this first
function does is randomly call

00:15:42.141 --> 00:15:47.046
one of the functions we have in
the fuzzer range from window

00:15:47.046 --> 00:15:53.052
document or element interfaces
or -- or using normal -- we have

00:15:57.723 --> 00:16:04.797
functions that dynamically
create -- dynamically -- create

00:16:04.797 --> 00:16:10.803
function and work through them
and as well as player at

00:16:14.607 --> 00:16:17.477
contributes or garbage
collection depending on what it

00:16:17.477 --> 00:16:23.149
is. Last thing is how we prepare
the string. First, we have a

00:16:23.149 --> 00:16:26.552
function that will generate
random function names to be used

00:16:26.552 --> 00:16:33.493
as call backs for events that
will create this simple function

00:16:33.493 --> 00:16:37.430
depend tongue on number of
statements -- that will contain

00:16:37.430 --> 00:16:43.402
this. Next Java script statement
related to element creation be

00:16:43.402 --> 00:16:50.142
that main element itself or the
observers or normally created --

00:16:50.142 --> 00:16:56.315
after that just -- create
statement at the end land

00:16:56.315 --> 00:17:03.856
randomly in Java statement that
are used to -- in these object.

00:17:03.856 --> 00:17:08.861
This is the sample object from
-- this will be between -- this

00:17:08.861 --> 00:17:12.398
is dynamically created none of
this is . We were wanted to

00:17:12.398 --> 00:17:18.404
prepare for -- a little bit
boring decided to do give you a

00:17:24.911 --> 00:17:30.917
little bit of sneak speak work
on testing the fuzzer on. As you

00:17:37.823 --> 00:17:43.829
can see it is running. We
connected the fuzzing server. As

00:17:47.767 --> 00:17:51.737
you see it doesn't take long for
spar tan to crash. This as

00:17:51.737 --> 00:17:56.676
simple -- the reference but
going in the right direction.

00:17:59.111 --> 00:18:02.815
Next we talk about our findings.
Basically you are able to find

00:18:02.815 --> 00:18:08.120
four bugs, two duplicates and
two or confirmed. The ones that

00:18:08.120 --> 00:18:14.961
are confirmed one of them is
2015 one two four three this was

00:18:14.961 --> 00:18:18.931
a -- this is the POC for it.
Three thousand for hit. The

00:18:18.931 --> 00:18:21.300
second one as you can see is
very simple, but assertion --

00:18:21.300 --> 00:18:27.306
the second one fourth one last
one also duplicate unfortunately

00:18:32.878 --> 00:18:38.884
I hit because I found 24 hours
after -- so so its fine.

00:18:52.898 --> 00:18:55.401
Basically thank you the code
will be up, hope you enjoyed our

00:18:55.401 --> 00:19:01.340
talk. These are the reference if
you need to look at them that we

00:19:05.111 --> 00:19:11.117
used doing our research. >>
[Applause]. >> If anyone has

00:19:19.558 --> 00:19:22.161
questions we would be happy to
take them. >> There as tool we

00:19:22.161 --> 00:19:28.167
have created which basically
takes -- and I will generate

00:19:50.089 --> 00:19:55.227
that Java script dynamically
explaining how this whole

00:19:55.227 --> 00:20:03.169
process has been done. Anyone
else want to ask anything? >>

00:20:03.169 --> 00:20:09.175
Question asked. >> So because we
are generate ting Java statement

00:20:15.147 --> 00:20:21.153
we are going to be -- already
created document there diagnosis

00:20:25.558 --> 00:20:31.564
an implementation thankfully
made that can be used to

00:20:34.066 --> 00:20:40.072
basically apply to an actual
document and feed it to the

00:20:44.477 --> 00:20:50.483
browser, if we are fuzzing
engine script itself I would .

00:20:54.854 --> 00:21:00.793
Yep. >> Question asked. >>
Sorry? >> Question reasked. >>

00:21:04.764 --> 00:21:10.769
Well we haven't tried yet we
have some ideas that we have

00:21:14.039 --> 00:21:16.942
tested but not fully implemented
that worked against something

00:21:16.942 --> 00:21:21.113
like Ruby for example -- R U BY
for example. Any way, guys we

00:21:21.113 --> 00:21:23.115
are going to be around if you
want to ask us anything. Hope

00:21:23.115 --> 00:21:25.718
you enjoyed it. Have a great
day.

