00:00:00.000 --> 00:00:04.638
Hopefully everybody will be
entertained. I know everyone

00:00:04.638 --> 00:00:10.644
thinks what I really want to do
at 5:00 p.m. is go to a talk

00:00:13.347 --> 00:00:18.385
that involves math. >> Whoo! >>
Excellent. Came for the math,

00:00:18.385 --> 00:00:25.626
stay for the moustache. I'm
packer and so can you. I'm going

00:00:25.626 --> 00:00:30.330
to attempt to keep this to the
45-ish minute mark so I can do

00:00:30.330 --> 00:00:37.371
some Q and A. Hopefully I'll get
good questions. Now we're on to

00:00:37.371 --> 00:00:42.609
the agenda. A little bit of an
intro, talk about the project, a

00:00:42.609 --> 00:00:47.481
little about me, because why
wouldn't I, I'm up here, give

00:00:47.481 --> 00:00:51.151
everybody a little refresher,
kind of talking a little bit

00:00:51.151 --> 00:00:54.421
about the PE format, look at the
data pull out our magnifying

00:00:54.421 --> 00:01:00.360
glass and do a little bit of
math and look at the solution

00:01:03.297 --> 00:01:08.068
and finally look at the results.
So the most important part, me.

00:01:08.068 --> 00:01:11.238
What do I do? Currently
research, those are my hobbies.

00:01:11.238 --> 00:01:17.244
Anybody else from Texas? >>
Yeah! >> There we go. If you're

00:01:20.013 --> 00:01:26.787
in Austin, I will totally buy
you a beer. If you guys are

00:01:26.787 --> 00:01:30.657
looking for various security
data, I try to keep an updated

00:01:30.657 --> 00:01:36.196
list, everything from bro logs
to snort logs to other projects,

00:01:36.196 --> 00:01:41.001
way more information than I can
possibly host. Follow me on

00:01:41.001 --> 00:01:47.007
Twitter and I'm sometimes a
contributing member -- and feel

00:01:53.647 --> 00:01:57.417
free to tweet about this and use
the hashtag secure math because

00:01:57.417 --> 00:02:02.889
we are going to be talking about
math. So what's the main problem

00:02:02.889 --> 00:02:05.926
here? I'm sure a lot of people
are familiar with the idea of

00:02:05.926 --> 00:02:12.132
detecting compilers and
encryptors. Some of the tools

00:02:12.132 --> 00:02:18.138
are really old. PID was written
in 2005. So it's 10-year-old

00:02:21.008 --> 00:02:25.445
technology. Maybe there's a more
interesting way or a better way

00:02:25.445 --> 00:02:30.450
to manage this problem. So
really the goal was to set out

00:02:30.450 --> 00:02:35.422
as can we do something new and
different. So we've got some

00:02:35.422 --> 00:02:38.625
goals. We've got some great
projects out there, like PEID

00:02:38.625 --> 00:02:42.629
and some other ones. Yeah, they
might be a little old, but

00:02:42.629 --> 00:02:45.665
there's probably still some
validity. However, for this

00:02:45.665 --> 00:02:49.136
we're going to try and adopt
kind of a zero trust towards

00:02:49.136 --> 00:02:52.773
them. In other words, if
somebody as an analyst says this

00:02:52.773 --> 00:02:57.711
PEID signature is verifiably
correct, then great, we being

00:02:57.711 --> 00:03:01.515
myself or anybody else in this
room can create a signature and

00:03:01.515 --> 00:03:04.384
kind of directly translate it
into this new language. The

00:03:04.384 --> 00:03:08.855
other one is this easy to create
signatures. So looking at PEID

00:03:08.855 --> 00:03:12.526
and some of the other associated
tools, you've got to live in X

00:03:12.526 --> 00:03:16.496
editor, you've got to open up
IDA and find the exact pattern

00:03:16.496 --> 00:03:20.934
you're looking for, it requires
a certain bar to entry. So the

00:03:20.934 --> 00:03:25.472
idea here is can this really be
distilled down to something

00:03:25.472 --> 00:03:29.042
anybody can get value out of.
Let's make it easy and we're

00:03:29.042 --> 00:03:31.545
going to talk about the
signatures as well.

00:03:31.545 --> 00:03:37.718
Cross-platform. So running PEID
on a Mac itself, that's not

00:03:37.718 --> 00:03:41.455
going to happen. There are a
couple of solutions to let you

00:03:41.455 --> 00:03:46.793
run signatures on Linux, on Mac.
They're really good, they're not

00:03:46.793 --> 00:03:50.630
as full featured as using it in
Windows so that's kind of a

00:03:50.630 --> 00:03:55.502
negative there. The other thing
once again, simple to extend and

00:03:55.502 --> 00:03:58.705
understand. So in my opinion
what I'm going to start with

00:03:58.705 --> 00:04:02.909
here is kind of this base
notion, this idea, present some

00:04:02.909 --> 00:04:06.880
data, and say look, I'm pretty
sure this mostly works, and

00:04:06.880 --> 00:04:09.649
hopefully somebody, multiple
somebodies in this room or

00:04:09.649 --> 00:04:14.287
elsewhere will go wow, that guy
wasn't really dumb. He was only

00:04:14.287 --> 00:04:19.025
mildly dumb and instead, here is
a couple of enhancements. And

00:04:19.025 --> 00:04:22.329
the other thing I wanted to get
out of this, this idea of fuzzy

00:04:22.329 --> 00:04:26.399
matching. So if you've got
something like PEID or another

00:04:26.399 --> 00:04:29.803
signature-based language,
generally it's the signature hit

00:04:29.803 --> 00:04:34.774
or it didn't. So instead I want
to introduce a notion of well,

00:04:34.774 --> 00:04:37.978
part of the signature hit, and
this is about how much of the

00:04:37.978 --> 00:04:42.249
signature hit. So in other
words, when I use this or

00:04:42.249 --> 00:04:45.685
anybody else uses this for
signature management, you can

00:04:45.685 --> 00:04:48.855
kind of figure out where your
overlapping signatures lie and

00:04:48.855 --> 00:04:51.792
you can maybe be a little bit
more effective out of the gate.

00:04:55.462 --> 00:04:58.298
So this we're going to jump in,
just an easy refresher, talk

00:04:58.298 --> 00:05:01.168
about the terms, when I say
certain words what I mean. It

00:05:01.168 --> 00:05:04.371
might be different from what
other people said so I want to

00:05:04.371 --> 00:05:08.942
go basically level setting, talk
about the PE file structure. I'm

00:05:08.942 --> 00:05:12.012
sure most of you in this room go
home and dream about the P

00:05:12.012 --> 00:05:18.718
headers. Probably not everybody
does. All right. This is a very

00:05:18.718 --> 00:05:23.890
simplified look of the PE file
structure. You've got this stub

00:05:23.890 --> 00:05:27.127
at the beginning, these other
various headers that are

00:05:27.127 --> 00:05:31.431
optional, some are which only
generated by certain compilers,

00:05:31.431 --> 00:05:35.902
this notion of sections, some
sections contain the code and

00:05:35.902 --> 00:05:38.972
some contain data and so forth
and so on. This idea of

00:05:38.972 --> 00:05:45.512
resources, so if you ever look
at a program executable icon,

00:05:45.512 --> 00:05:51.685
resource section. So there are
many different parts. This is

00:05:51.685 --> 00:05:54.588
one of my favorite graphs and I
apologize if you can't see it

00:05:54.588 --> 00:05:58.391
all that well. These are all the
header values that you can have

00:05:58.391 --> 00:06:01.228
in a PE file. Keep in mind not
all of them are required to

00:06:01.228 --> 00:06:06.099
exist. Not all of them are
required to be filled out in a

00:06:06.099 --> 00:06:09.970
entirely accurate way. But this
is what you can deal with. So

00:06:09.970 --> 00:06:15.075
there is a lot of things to mess
with. They're color coded. So as

00:06:15.075 --> 00:06:20.280
far as the PE format itself and
header structure, this is what

00:06:20.280 --> 00:06:24.951
we're going to care about today.
The three basic things that I

00:06:24.951 --> 00:06:30.023
decided, whether I'm correct or
not, that's fine. But three

00:06:30.023 --> 00:06:32.626
basic features out of the PE
header that I said these can be

00:06:32.626 --> 00:06:35.996
kind of interesting and these
should generally vary enough

00:06:35.996 --> 00:06:39.199
from compiler to compiler or
packer to packer or crypter to

00:06:39.199 --> 00:06:42.702
crypter that they should be
useful features doing this type

00:06:42.702 --> 00:06:46.606
of analysis. The other one is
number of sections. Things like

00:06:46.606 --> 00:06:52.412
UPX and a lot of other packers,
maybe they jam the executable

00:06:52.412 --> 00:06:57.217
into one section and have this
little section. So when I use

00:06:57.217 --> 00:07:01.321
the tool chain, what I'm talking
about is the set of tools used

00:07:01.321 --> 00:07:04.324
to develop software. So you can
have things like IDs and linkers

00:07:04.324 --> 00:07:06.760
and compilers. Each one of these
actually leaves somewhat of a

00:07:06.760 --> 00:07:08.762
relatively unique fingerprint
upon the binary that it creates.

00:07:13.967 --> 00:07:17.037
You can manually go in and
change these. Not a lot of

00:07:17.037 --> 00:07:21.574
people do. So for this when I
talk about tool chain, I'm going

00:07:21.574 --> 00:07:26.279
to talk about kind of the build
environment. So GCC versus

00:07:26.279 --> 00:07:29.549
visual C++. So packers, what are
they? Program within a program.

00:07:29.549 --> 00:07:32.485
When I want to pack a binary,
what I'll do is I'll take the

00:07:32.485 --> 00:07:38.491
original executable, kind of
smoosh it down and ram it

00:07:41.728 --> 00:07:46.499
somewhere inside this new
executable. So I want to do that

00:07:46.499 --> 00:07:50.804
to evade AB, maybe analyst's
lives harder, because who

00:07:50.804 --> 00:07:55.809
doesn't love stepping through
LED bug trying to figure out how

00:07:55.809 --> 00:08:00.146
do I get this unpacked version
because this is ridiculous. At

00:08:00.146 --> 00:08:04.651
least if you know, identify what
packer is similar to anything

00:08:04.651 --> 00:08:07.821
you've seen before, you know
what steps you have to go

00:08:07.821 --> 00:08:10.523
through or maybe you know what
tool to pull out of your tool

00:08:10.523 --> 00:08:14.928
box in order to do the
unpacking. So there are really

00:08:14.928 --> 00:08:18.198
two parts to a packer. You get
the packer executable that you

00:08:18.198 --> 00:08:21.067
run on the original file. This
is the thing that actually does

00:08:21.067 --> 00:08:26.272
the compression and creates the
new executable. And you've got

00:08:26.272 --> 00:08:29.809
the unpacker and the unpacker is
generally this little stub that

00:08:29.809 --> 00:08:34.314
comes out of this new program.
The stub is generally the first

00:08:34.314 --> 00:08:38.952
thing executed and it goes
through and unpacks the original

00:08:38.952 --> 00:08:44.124
binary and I'm going to run
this. When I talk about packer

00:08:44.124 --> 00:08:48.628
detection in this context, I'm
going to refer to the unpacker

00:08:48.628 --> 00:08:55.835
or the stub. So unpackers. How
do they work? So what you really

00:08:55.835 --> 00:08:59.773
want to do is take control of
the address of the entry point.

00:08:59.773 --> 00:09:04.544
So where, when a Windows or P
file is loaded, where should I

00:09:04.544 --> 00:09:07.781
go and begin executing code. So
you want that to point to your

00:09:07.781 --> 00:09:12.952
stub. And once you unpack it,
maybe you decrypt it or whatever

00:09:12.952 --> 00:09:20.060
it is, you find the packed data.
You've got to do a couple of

00:09:20.060 --> 00:09:23.730
relocation fixes because it's
not the Windows loader doing the

00:09:23.730 --> 00:09:26.933
actual loading for execution.
You have to mimic some of that

00:09:26.933 --> 00:09:31.337
and you jump into the original
program and keep going. All

00:09:31.337 --> 00:09:35.809
right. So now we're into the
popular kids. So these are the

00:09:35.809 --> 00:09:39.412
kind of the three in my opinion,
and there is probably several

00:09:39.412 --> 00:09:43.283
more tools that when people do
compiler detection, this is what

00:09:43.283 --> 00:09:46.686
they're talking about. So PEID I
mentioned that one before. The

00:09:46.686 --> 00:09:52.592
signature language is pretty
good. It's been around forever.

00:09:52.592 --> 00:09:58.465
It's my opinion it's kind of the
de facto standard. Several

00:09:58.465 --> 00:10:04.304
projects that will allow you to
take PEID rule sets so you can

00:10:04.304 --> 00:10:09.242
update your analyst tools but
you're still kind of using this

00:10:09.242 --> 00:10:13.346
limited idea of what you're
looking at, this harder way to

00:10:13.346 --> 00:10:18.651
describe data. And this last
one, I really like their slogan.

00:10:18.651 --> 00:10:25.024
All right. So now we're going to
dig into data and who doesn't

00:10:25.024 --> 00:10:27.694
love data. And honestly if
you're going to talk about math

00:10:27.694 --> 00:10:31.130
and you're going to talk about
doing any type of analysis, if

00:10:31.130 --> 00:10:35.001
you don't use data and you don't
understand your data, it's

00:10:35.001 --> 00:10:40.240
really, really hard to get good
results. A lot of times data is

00:10:40.240 --> 00:10:44.210
really ugly. Right? It's not
this beautiful end results. It's

00:10:44.210 --> 00:10:46.880
this nasty thing you have to
slog through and dissect and

00:10:46.880 --> 00:10:52.118
understand. So this is the data
that I used in my testing

00:10:52.118 --> 00:10:55.054
set-up. So I went and I found
and I Googled and I threw

00:10:55.054 --> 00:11:02.962
together 3,977 unique PEID
signatures. That's a lot of PID

00:11:02.962 --> 00:11:07.901
signatures. Right? So that alone
got me thinking maybe we can

00:11:07.901 --> 00:11:10.503
address the signature management
problem. We've got some file

00:11:10.503 --> 00:11:14.908
sets, various sizes, right?
We've got smaller ones that I

00:11:14.908 --> 00:11:17.310
understood that I could pull
apart and go o oh, okay, I get

00:11:17.310 --> 00:11:23.316
it. And this giant random sample
at the bottom. Everybody loves

00:11:25.718 --> 00:11:29.556
big data and this wouldn't be a
math talk unless I use the

00:11:29.556 --> 00:11:34.494
phrase big data. So there you
go. So that was kind of the

00:11:34.494 --> 00:11:37.664
end-all after I felt comfortable
with the technique and

00:11:37.664 --> 00:11:42.068
comfortable with the tool, what
I ran it over to verifying and

00:11:42.068 --> 00:11:46.706
spot checking with the data set.
We'll talk about that as well.

00:11:46.706 --> 00:11:49.976
Let's get into the data
analysis. So for this there's a

00:11:49.976 --> 00:11:55.648
handful of slides we'll go
through them. We'll talk about

00:11:55.648 --> 00:12:01.688
the basic exploration of the
Zeus data set. So 7,600 samples

00:12:01.688 --> 00:12:07.694
roughly are what these slides
are based off of. So first thing

00:12:11.731 --> 00:12:16.936
I did was what happens if I run
PID on these files, it turns out

00:12:16.936 --> 00:12:23.076
they don't match 4,600 of them.
Really disappointing. So we get

00:12:23.076 --> 00:12:27.480
some other ones. There's
different UPX and another UPX

00:12:27.480 --> 00:12:32.919
version and Microsoft visual
basic and armadillo packer which

00:12:32.919 --> 00:12:36.089
I'm sure just by looking at the
numbers you could probably make

00:12:36.089 --> 00:12:40.660
a relatively educated guess that
Microsoft basic and armadillo

00:12:40.660 --> 00:12:47.166
are really closely related. So
what is kind of those numbers

00:12:47.166 --> 00:12:49.669
what they look like in visual
format. It's a bar chart. You

00:12:49.669 --> 00:12:52.905
don't have to worry about the
numbers. That really tall line

00:12:52.905 --> 00:12:58.511
is the 4,600. Just another way
to visualize it, just to get

00:12:58.511 --> 00:13:02.448
into the idea that creating
signatures is hard. It's

00:13:02.448 --> 00:13:06.085
non-trivial. So having an easier
way to do that would be great

00:13:06.085 --> 00:13:09.322
because then that really big
giant, I apologize not using

00:13:09.322 --> 00:13:15.228
gray scale, blue-ish purple-ish
box, to make that smaller to get

00:13:15.228 --> 00:13:22.402
more things you can actually
label and understand. This graph

00:13:22.402 --> 00:13:26.439
in my opinion is what science
looks like. You show this to

00:13:26.439 --> 00:13:32.245
somebody, that dude up there,
totally good science. This is

00:13:32.245 --> 00:13:37.417
simply a correlation matrix. You
take all of these PEID

00:13:37.417 --> 00:13:40.620
signatures and for files that
had a flag, you want to see

00:13:40.620 --> 00:13:46.626
which signatures flagged with a
high correlation or flagged when

00:13:49.696 --> 00:13:52.932
one flagged the other one was
very, very likely to flag. So

00:13:52.932 --> 00:13:55.802
the diagonal is basically the
signature correlating with

00:13:55.802 --> 00:13:58.604
itself, right? Because every
time a signature fires it's

00:13:58.604 --> 00:14:04.477
going to be observed. So with
this you want to pull up the

00:14:04.477 --> 00:14:10.450
black dots. You can zoom in.
This is the upper left-hand

00:14:10.450 --> 00:14:12.785
corner and you can see there are
a couple of signatures that are

00:14:12.785 --> 00:14:16.689
highly correlated. So there's a
lot of signature overlap. There

00:14:16.689 --> 00:14:19.625
could be signature overlap in
your environments. There's

00:14:19.625 --> 00:14:25.264
obviously signature overlap on
the Internet. So every time one

00:14:25.264 --> 00:14:29.969
of these AS pack signatures
flagged the other one did. So

00:14:29.969 --> 00:14:34.207
with that you get a feel for
this is where I'm lacking or

00:14:34.207 --> 00:14:38.811
maybe this is where I have some
duplication. So we understand

00:14:38.811 --> 00:14:43.583
what PID looks like in a sample
data set. So now we see what we

00:14:43.583 --> 00:14:48.454
can look at in addition to
header features that allow us to

00:14:48.454 --> 00:14:53.526
say with a probability that
we're looking at a specific

00:14:53.526 --> 00:15:01.367
packer or a specific compiler. I
love it when any type of malware

00:15:01.367 --> 00:15:04.670
author or any author in general
includes a PDV string. Because

00:15:04.670 --> 00:15:10.676
sometimes they're awesome. It's
important to keep in mind these

00:15:19.986 --> 00:15:23.923
are just texts, so there's no
reason why you can't create your

00:15:23.923 --> 00:15:29.929
own you've got these major and
minor linkers, what do they look

00:15:34.300 --> 00:15:37.670
like in the sample set. So this
is just breaking down. So if you

00:15:37.670 --> 00:15:45.411
got the first one, linker 2.5,
2 --> 000 of them. So why you can

00:15:45.411 --> 00:15:49.148
group this Zeus sample set or
many other sample sets by

00:15:49.148 --> 00:15:52.618
looking at the linker versions
of the count, it still really

00:15:52.618 --> 00:15:57.456
doesn't tell you the whole
story. So we looked at the

00:15:57.456 --> 00:16:01.160
number of sections and you can
kind of see relatively similar

00:16:01.160 --> 00:16:04.030
distribution. You've got a
couple really big groups of

00:16:04.030 --> 00:16:07.700
files that might indicate a
specific campaign within the

00:16:07.700 --> 00:16:11.504
Zeus status and you can have
this longer tail. The other

00:16:11.504 --> 00:16:17.176
thing we wanted to look at.
Assembly -- these are kind of

00:16:17.176 --> 00:16:23.316
cool. The idea here is when an
executable runs, there's code.

00:16:23.316 --> 00:16:29.322
And that, those bytes can be
translated into a mnemonic. And

00:16:44.937 --> 00:16:48.341
Johnny five's live, but -- sorry
Johnny. So for this, a capstone

00:16:56.182 --> 00:16:58.317
engine was used. If you're
looking for a free and an

00:16:58.317 --> 00:17:03.556
awesome disassembler is great. I
love it. Runs on multiple

00:17:03.556 --> 00:17:08.127
architectures, bindings for
multiple languages, it's super

00:17:08.127 --> 00:17:11.831
easy to use. The reason I call
this out specifically, I'm sure

00:17:11.831 --> 00:17:16.636
a lot of you have noticed that
every single time you run a

00:17:16.636 --> 00:17:19.972
different disassembler on an
executable, you will get

00:17:19.972 --> 00:17:25.077
results. So really you only get
consistency within a

00:17:25.077 --> 00:17:31.083
disassembling engine. The point
is just to be consistent with

00:17:40.293 --> 00:17:44.597
this type of stuff. So then I
had what I thought was a really

00:17:44.597 --> 00:17:49.001
rad idea. I was going to look at
the correlation between assembly

00:17:49.001 --> 00:17:55.007
mnemonics. They describe the
program behavior and what we're

00:18:02.682 --> 00:18:08.688
looking to capture is what is
this packer doing or how does

00:18:22.335 --> 00:18:28.174
the executable get set up
because it's compiler specific

00:18:28.174 --> 00:18:31.444
or in the case of a packer
encryptor, they have to know

00:18:31.444 --> 00:18:34.513
what undo so they can run
whatever code they want. We have

00:18:34.513 --> 00:18:37.683
to capture this program
behavior. That's what we're

00:18:37.683 --> 00:18:45.424
doing with the assembly
mnemonics. So how can we look at

00:18:45.424 --> 00:18:47.827
these various assembly
mnemonics. It looked ridiculous.

00:18:47.827 --> 00:18:53.833
Imagine looking at that for
400 --> 000 samples. You're going to

00:18:56.402 --> 00:19:02.408
go blind and be sad. So there's
this kind of notion of distance

00:19:02.408 --> 00:19:05.478
or similarity, that fuzzy idea.
If I have a signature I want to

00:19:05.478 --> 00:19:09.015
know how close what I'm looking
at is how close is it to the

00:19:09.015 --> 00:19:13.753
signature. How similar. Call
talk a little about Jicard

00:19:13.753 --> 00:19:19.558
distance. It's cool however it
doesn't take order into account.

00:19:19.558 --> 00:19:25.898
Whether it executes in order, it
doesn't jump around. I mean,

00:19:25.898 --> 00:19:29.235
there's full control and that
kind of stuff. But generally,

00:19:29.235 --> 00:19:31.404
had to move -- there will be
executed in that order and not

00:19:31.404 --> 00:19:38.878
move exor at or vice versa.
While it's great and it might be

00:19:38.878 --> 00:19:43.516
useful, order I thought was
important to take into account.

00:19:43.516 --> 00:19:51.390
This is another cool metric
distance. Position is important.

00:19:51.390 --> 00:19:57.396
The left most is the one at the
entry point so this is where the

00:20:04.103 --> 00:20:08.674
executable will start and it
moves from left to right and you

00:20:08.674 --> 00:20:12.144
can see there's various ones. So
the easy way to view, take the

00:20:12.144 --> 00:20:14.814
total number of sheer elements
-- and that's your distance. So

00:20:14.814 --> 00:20:16.816
in this case it's move push
which is 2 divided by the other

00:20:16.816 --> 00:20:22.822
set, which is 8, and you get
.25. So as far as set membership

00:20:30.029 --> 00:20:35.367
is concerned, these two things
are have a distance of .25. And

00:20:35.367 --> 00:20:41.741
while, okay. It just didn't feel
right. So once again, you have

00:20:41.741 --> 00:20:44.343
this idea of order. So how many
things have to change to make

00:20:44.343 --> 00:20:48.881
one into the other? So this kind
of fit the domain a little bit

00:20:48.881 --> 00:20:54.286
better. So once again, kind of
just doing a quick compare, you

00:20:54.286 --> 00:20:57.423
know, looking at if they're
different. So right there's one

00:20:57.423 --> 00:20:59.425
difference and they're not
different and so forth and so

00:20:59.425 --> 00:21:02.928
on. So basically seven changes
are necessary to make one set

00:21:02.928 --> 00:21:09.168
into the other set. Therefore we
get a distance of 7. But code is

00:21:09.168 --> 00:21:12.638
executed in order, there may be
branches. I really didn't want

00:21:12.638 --> 00:21:16.609
to build any type of flow graph.
I wanted to keep it simple and

00:21:16.609 --> 00:21:22.081
understandable and efficient. So
in theory, the assumption was,

00:21:22.081 --> 00:21:24.683
what I worked with was the
assembly mnemonics to the left

00:21:24.683 --> 00:21:28.120
should be more than the assembly
mnemonics on the right. Because

00:21:28.120 --> 00:21:31.657
it will execute starting on the
left and finish on the right.

00:21:31.657 --> 00:21:34.493
And if there's a jump in there,
maybe you want to care about it,

00:21:34.493 --> 00:21:36.595
but maybe you don't want to care
about this stuff after as much

00:21:36.595 --> 00:21:41.500
as the fact there was a jump. So
there are a bunch of testing and

00:21:41.500 --> 00:21:44.036
metrics where I try to figure
out where the cut-off was and so

00:21:44.036 --> 00:21:50.676
forth and so on. We have to take
into account how big is the stub

00:21:50.676 --> 00:21:52.678
and if you don't know what
you're looking at and some of

00:21:52.678 --> 00:21:54.680
these questions are really hard
to answer. The ones on the left,

00:21:54.680 --> 00:21:56.682
any edit to the left will have a
higher weight than the edit to

00:21:56.682 --> 00:21:58.684
the right. Which kind of makes
sense. We care about more of the

00:21:58.684 --> 00:22:00.619
things that are executed first
in case there is something like

00:22:00.619 --> 00:22:02.621
a branch or a jump. And then we
have a language, this assembly

00:22:02.621 --> 00:22:04.623
mnemonics to kind of capture
program behavior. So we can put

00:22:04.623 --> 00:22:06.625
those two together and you
basically calculate every single

00:22:06.625 --> 00:22:08.627
position, the position of you're
looking at divided by the length

00:22:08.627 --> 00:22:10.930
of the set. So in this case
there's ten things in the set,

00:22:10.930 --> 00:22:12.932
so the first thing requires one
full edit. The second thing

00:22:12.932 --> 00:22:14.934
requires zero edits. And the
third thing requires .8 of an

00:22:14.934 --> 00:22:16.936
edit. So now you have a distance
of 3.5. So to me this was great

00:22:16.936 --> 00:22:18.938
because it said yeah, these
things are separate and

00:22:18.938 --> 00:22:20.940
different, but there might be
some similarities. The next

00:22:20.940 --> 00:22:22.942
thing you can also do is use it
as a similarity calculation. So

00:22:22.942 --> 00:22:24.944
if you want to use it as a
similarity. So it says basically

00:22:24.944 --> 00:22:26.946
those two sets are 65% similar.
This is how we get the idea of

00:22:26.946 --> 00:22:28.948
similarity mixed into the
algorithm. All right. We've made

00:22:28.948 --> 00:22:30.950
it through the great refresher,
everybody loves the files and

00:22:30.950 --> 00:22:32.952
headers and we have an idea of
the features we're going to look

00:22:32.952 --> 00:22:34.954
at. The major linker version,
the minor linker version, the

00:22:34.954 --> 00:22:36.956
various assembly mnemonics, we
have some fancy-sounding

00:22:36.956 --> 00:22:38.958
algorithms that are simple to
understand, which is great. We

00:22:38.958 --> 00:22:40.960
have a way to do fuzzy matching.
Awesome. Now what do we do?

00:22:40.960 --> 00:22:42.962
First step gather samples. You
know there are well over 411 --> 000

00:22:42.962 --> 00:22:44.964
samples. So the second thing was
let's get PEID this industry

00:22:44.964 --> 00:22:46.966
standard and see what it looks
like for everything. And then

00:22:46.966 --> 00:22:48.968
from there, for every single one
of the executables, we going to

00:22:48.968 --> 00:22:50.970
disassemble them because we need
the assembly mnemonics and in

00:22:50.970 --> 00:22:52.972
this case we wind up using the
first 30. We need the header

00:22:52.972 --> 00:22:54.974
features. We'll talk about
clustering so you can kind of

00:22:54.974 --> 00:22:56.976
understand which PE files are
similar based on these features.

00:22:56.976 --> 00:22:58.978
And when I ran this across all
the data sets my threshold was

00:22:58.978 --> 00:23:00.913
90% similar. So I felt that if
an executables signature and the

00:23:00.913 --> 00:23:02.915
signature I was matching against
were not at least 90%, that

00:23:02.915 --> 00:23:04.917
wasn't good enough to call it an
actual match. So one of the

00:23:04.917 --> 00:23:06.919
things I started off using was a
similarity comparison and

00:23:06.919 --> 00:23:08.921
optimization. I wound up doing a
lot of comparisons, but luckily

00:23:08.921 --> 00:23:10.923
not by hand. And we created
signatures so we can verify. So

00:23:10.923 --> 00:23:12.925
one of the things I kind of want
to talk about briefly is

00:23:12.925 --> 00:23:14.927
signatures, everybody we lived
in, security data science, have

00:23:14.927 --> 00:23:16.929
to do security machine learns,
if we're not using scan -- no.

00:23:16.929 --> 00:23:18.931
No. Sometimes it's overkill,
right? So one of the nice things

00:23:18.931 --> 00:23:20.933
about signatures in this case is
we can use it to capture this

00:23:20.933 --> 00:23:22.935
domain specific language. But me
or anybody else, we don't have

00:23:22.935 --> 00:23:24.937
to worry about -- they might
have great accuracy when help

00:23:24.937 --> 00:23:26.939
get new data and they go to
train it. It gets out of whack,

00:23:26.939 --> 00:23:28.941
so to speak and going to keep
going through this large

00:23:28.941 --> 00:23:30.943
process, right? This is one of
the issues with operationalizing

00:23:30.943 --> 00:23:32.945
machine learning. Also the model
will vary based on training

00:23:32.945 --> 00:23:34.947
source. It will be good at
finding things labeled APT 1 but

00:23:34.947 --> 00:23:36.949
it would be worse trying to
determine which packer or which

00:23:36.949 --> 00:23:38.951
crypter is what. And likely
everybody else will have a

00:23:38.951 --> 00:23:40.953
different edit than me and it
wasn't a good foot. And the last

00:23:40.953 --> 00:23:42.955
bullet is where I was going is
simple. You want to play, you

00:23:42.955 --> 00:23:44.957
want to do things, you want to
tinker. Sometimes machine

00:23:44.957 --> 00:23:46.959
learning is fun to tinker with.
Sometimes you really just want

00:23:46.959 --> 00:23:48.961
to get something done. So here
is what the signature language

00:23:48.961 --> 00:23:50.963
itself looks like. So really,
really simple. It's kind of

00:23:50.963 --> 00:23:52.965
highlighted to show you the
signature and I'm going to go

00:23:52.965 --> 00:23:54.967
into a demo in a second. But so
the signature for Microsoft

00:23:54.967 --> 00:23:56.969
basic, you can see there's quite
a few, the ones on the left --

00:23:56.969 --> 00:23:58.971
you get a similarity of .902. So
in my opinion, I think that

00:23:58.971 --> 00:24:00.906
accurately captured the
signature is relatively to the

00:24:00.906 --> 00:24:02.908
file and I feel pretty confident
that this file matches my

00:24:02.908 --> 00:24:04.910
signature. Now let's move into a
demo. I think I broke

00:24:04.910 --> 00:24:06.912
everything. That's phenomenal.
Seriously. It just hates full

00:24:06.912 --> 00:24:08.914
screen. Asian guy showed up.
Awesome. This went from friendly

00:24:08.914 --> 00:24:10.916
math talk to klan rally. I
scripted this all because I was

00:24:10.916 --> 00:24:12.918
kind of a chicken as well. I
didn't want to type commands. So

00:24:12.918 --> 00:24:14.920
I'll direct your attention to
the top, kind of small box and

00:24:14.920 --> 00:24:16.922
walk through the demo. Just sit
there for two minutes. Third

00:24:16.922 --> 00:24:18.924
time is a charm. When in doubt
try a different port. You know

00:24:18.924 --> 00:24:20.926
what, screw it. If anybody want
to actually see a demo, I

00:24:20.926 --> 00:24:22.928
promise I literally promise -- I
swear. Completely unreadable

00:24:22.928 --> 00:24:24.930
slides. There's two phases to
this. One the signature

00:24:24.930 --> 00:24:26.932
generation phase and that simply
says run this one script on the

00:24:26.932 --> 00:24:28.934
binary that I can't even show on
a computer, that's what I get

00:24:28.934 --> 00:24:30.936
for trying to do a demo. And
generate the signature. And on

00:24:30.936 --> 00:24:32.938
the signature is going to be, is
a simple listed assembly

00:24:32.938 --> 00:24:34.940
mnemonics and give you this
major minor linker version as

00:24:34.940 --> 00:24:36.942
well as the number of sections
and all you have to do, if

00:24:36.942 --> 00:24:38.944
you're not giving a demo, is run
this other script that if you

00:24:38.944 --> 00:24:40.946
can see it, that MMPES.pi on a
signature and you can do all

00:24:40.946 --> 00:24:42.948
sorts of things. So if your idea
for similarity is different than

00:24:42.948 --> 00:24:44.950
mine, it's 50% similar, you can
do that. You can give it this

00:24:44.950 --> 00:24:46.952
crazy verbose -- here's the
signature that I have, and

00:24:46.952 --> 00:24:48.954
here's what I'm matching
against. It also tells you when

00:24:48.954 --> 00:24:50.956
the major and minor linker
versions match or when the

00:24:50.956 --> 00:24:52.958
numbers of sections don't match.
It tells you how many edits you

00:24:52.958 --> 00:24:54.960
have and the actual similarity.
This is between two samples. And

00:24:54.960 --> 00:24:56.962
you can see the signature
generated on the two files in

00:24:56.962 --> 00:24:58.964
this directory. The first one
really didn't match all that

00:24:58.964 --> 00:25:00.899
well. This .844 required roughly
4 and a half edits, but this

00:25:00.899 --> 00:25:02.901
other file matched exactly. So
all 30 assembly mnemonics were

00:25:02.901 --> 00:25:04.903
perfectly in order. Both the
numbers matched as well as the

00:25:04.903 --> 00:25:06.905
number sections. And here's kind
of a better description of the

00:25:06.905 --> 00:25:08.907
rule you guys might be able to
see. All right. So let's look at

00:25:08.907 --> 00:25:10.909
some of the data sets. Let's
look at some of the bigger ones,

00:25:10.909 --> 00:25:12.911
because again, big data. We'll
start with the APT 1. Here, this

00:25:12.911 --> 00:25:14.913
is kind of describing the
clusters, in other words the

00:25:14.913 --> 00:25:16.915
like things grouped with other
like things and it's 2-bar

00:25:16.915 --> 00:25:18.917
charts which is why you get the
color variations. Apologies for

00:25:18.917 --> 00:25:20.919
gray scale. The far one on the
right is PID said this many

00:25:20.919 --> 00:25:22.921
things are similar and that
green bar is the assembly

00:25:22.921 --> 00:25:24.923
mnemonics comparison. The cool
thing, even with having zero

00:25:24.923 --> 00:25:26.925
trust in the labels of using
something like PEID, you get

00:25:26.925 --> 00:25:28.927
kind of this anticipated view.
You expect a lot of things to

00:25:28.927 --> 00:25:30.929
fall into a few buckets you get
this long tail that as an

00:25:30.929 --> 00:25:32.931
analyst is always a pain in the
ass to deal with. One of the

00:25:32.931 --> 00:25:34.933
ways to represent this is a neat
looking bubble graph. It's not

00:25:34.933 --> 00:25:36.935
really science unless you have
sweet graphs. So this just

00:25:36.935 --> 00:25:38.937
clustered on assembly mnemonics,
so once again kind of

00:25:38.937 --> 00:25:40.939
representing what you can see,
just one large cluster in kind

00:25:40.939 --> 00:25:42.941
of these other ones. The
signature language in this work

00:25:42.941 --> 00:25:44.943
revolved around a couple of
other features so what did they

00:25:44.943 --> 00:25:46.945
look like. So the darker blue is
the actual, so in this case it's

00:25:46.945 --> 00:25:48.947
that big orange one is the big
dark blue one and within that

00:25:48.947 --> 00:25:50.949
one cluster, based only on
assembly mnemonics similarity,

00:25:50.949 --> 00:25:52.951
you have three subclusters
number of sections. This is kind

00:25:52.951 --> 00:25:54.953
of interesting, maybe there's a
little bit of variation, maybe

00:25:54.953 --> 00:25:56.955
somebody used a slightly
different version of something,

00:25:56.955 --> 00:25:58.957
some forth and so on. Likewise
with linker versions, I thought

00:25:58.957 --> 00:26:00.893
this was kind of neat. There's
very little in the sample set,

00:26:00.893 --> 00:26:02.895
deviation for linker versions
when using subclustering. So

00:26:02.895 --> 00:26:04.897
this is kind of a
three-dimensional or

00:26:04.897 --> 00:26:06.899
two-dimensional view of a
three-dimensional set of

00:26:06.899 --> 00:26:08.901
features. So once again the dark
blue the assembly mnemonics

00:26:08.901 --> 00:26:14.773
circle and you've got these
various subcircles, kind of the

00:26:14.773 --> 00:26:20.779
one on the lower right-hand
corner you can see the cluster

00:26:20.779 --> 00:26:26.785
and you can see one cluster that
was actually based off of a

00:26:26.785 --> 00:26:31.657
number of sections and you can
kind of see two subclusters in

00:26:31.657 --> 00:26:37.663
that and everything else only
had that one cluster. So it's

00:26:40.199 --> 00:26:42.201
kind of cool. So let's look at
Zeus. Much bigger data set, much

00:26:42.201 --> 00:26:44.203
more graphs. Much more science.
This is what Zeus looked like.

00:26:44.203 --> 00:26:46.205
Once again kind of earlier a
little teaser, you get this

00:26:46.205 --> 00:26:48.207
massive, massive PID unknown
label. But the cluster actually

00:26:48.207 --> 00:26:50.209
breaks it up. This one and the
stacked one, you can see the

00:26:50.209 --> 00:26:52.211
assembly mnemonics clustering on
that, that yellow bar is a

00:26:52.211 --> 00:26:54.213
little bit more manageable and
you kind of get this slightly

00:26:54.213 --> 00:26:56.215
more gentle sloping curve. But
you get a lot of bubbles. So the

00:26:56.215 --> 00:26:58.217
end result is I shouldn't do
anything in D 3, or you

00:26:58.217 --> 00:27:00.152
shouldn't have a D 3 while
you're high. (Laughter.) The

00:27:00.152 --> 00:27:02.154
whole scenarios end badly. So
once again what does it look

00:27:02.154 --> 00:27:04.156
like if we subcluster on a
number of sections versus the

00:27:04.156 --> 00:27:06.158
cluster, the initial cluster on
assembly mnemonic. You get these

00:27:06.158 --> 00:27:08.160
crazy subspirals, things look
bizarre. For me it was kind of

00:27:08.160 --> 00:27:10.362
enjoyable because it was an
exploration of Zeus and a way to

00:27:10.362 --> 00:27:12.731
visualize this entire data set.
And you kind of want to go home

00:27:12.731 --> 00:27:14.933
and cry. It's never very good.
So I mentioned that I did

00:27:14.933 --> 00:27:16.935
something on 411 --> 000 files and
it was you awesome. Let's talk

00:27:16.935 --> 00:27:18.937
about them. This is just the
assembly mnemograph. Roughly

00:27:18.937 --> 00:27:21.907
5,400 of these files are not 90%
similar to any other file in

00:27:21.907 --> 00:27:24.076
this entire corpus. I thought
that was really cool and really

00:27:24.076 --> 00:27:26.078
surprising. This might be some
polymorphic stuff, this might be

00:27:26.078 --> 00:27:28.380
various crypters. Who knows. But
it was cool. 5,800 things is way

00:27:28.380 --> 00:27:34.386
too many for me to actually dig
through. So we'll kind of skip

00:27:37.289 --> 00:27:43.295
through some of these. Everybody
loves spirals and I wanted to

00:27:52.271 --> 00:27:58.277
leave 15 minutes for questions.
So don't D 3. I actually broke D

00:28:09.922 --> 00:28:15.928
3. This is the one that I broke.
I give up or you're doing it

00:28:30.342 --> 00:28:36.348
wrong. It might very well be
that I was doing it wrong. But

00:28:41.887 --> 00:28:47.893
it cried. So there were a couple
of really cool things that

00:28:52.931 --> 00:28:58.937
popped out of this relatively
large data set. Like Google

00:29:02.040 --> 00:29:08.046
Chrome. There are 97 Google
chrome instances and they all

00:29:11.249 --> 00:29:17.255
match this same signature. They
all have this kind of same

00:29:21.360 --> 00:29:27.799
assembly mnemonic string.
They're very consist event.

00:29:27.799 --> 00:29:33.805
They're very consistent with
what linkers they have, what

00:29:36.074 --> 00:29:42.080
linkers they use. So out of the
97, the take-home is 94 of those

00:29:48.954 --> 00:29:56.328
97 have matching linker
versions, matching number of

00:29:56.328 --> 00:30:02.334
sections, and assembly mnemonics
within 90% of this .9 distance.

00:30:05.504 --> 00:30:11.510
So it was kind of cool. And it
really wouldn't be a talk about

00:30:18.383 --> 00:30:24.690
packers if we didn't talk about
UPX. Somebody was going to ask

00:30:24.690 --> 00:30:26.758
about it. So this was kind of
cool, this was kind of telling.

00:30:26.758 --> 00:30:29.127
I dug into UPX some in the past
but this forced me to do a

00:30:29.127 --> 00:30:31.196
little bit more digging. So I
kind of cheated and I said all

00:30:31.196 --> 00:30:33.198
right, what if I do this really,
really naively and just looked

00:30:33.198 --> 00:30:35.200
for the string, UPX 0, UPX 1 and
said it's probably UPX, right?

00:30:35.200 --> 00:30:37.302
Because once again I didn't want
to test any prior solution and I

00:30:37.302 --> 00:30:43.308
wanted to see how this stuff is
backed up. So with the assembly

00:31:29.221 --> 00:31:32.324
mnemonics, I got 65 different
groups and I thought shit. Now

00:31:32.324 --> 00:31:34.326
I'm going to be laughed off
stage. However there are some

00:31:34.326 --> 00:31:36.328
pretty cool results here. You
can see this group label and

00:31:36.328 --> 00:31:38.330
this count, so that's group
label or the cluster label is

00:31:38.330 --> 00:31:40.332
the arbitrary number that I
assigned to it, this group. So

00:31:40.332 --> 00:31:42.334
you can see once again you get
this neat little slope. I was

00:31:42.334 --> 00:31:44.336
like all right. So maybe there's
some variations of UPX, maybe

00:31:44.336 --> 00:31:46.338
I'm much smarter than I thought
I was and I can do UPX version

00:31:46.338 --> 00:31:49.541
detection with this. Maybe my
head is going to explode or

00:31:49.541 --> 00:31:52.744
maybe I failed miserably. The
answer is kind of somewhere in

00:31:52.744 --> 00:31:56.214
between. So looking up against
PEID, it was neat to say either

00:31:56.214 --> 00:31:59.384
me and/or every other person
were making the same mistakes or

00:31:59.384 --> 00:32:02.220
maybe we're totally on to
something. Kind of the cool

00:32:02.220 --> 00:32:04.523
thing was, here's the numbers.
It looks like maybe I was on to

00:32:04.523 --> 00:32:08.760
something after all. There's
also -- I dubbed through that a

00:32:08.760 --> 00:32:12.764
little bit to see what was going
on. It turns out there's a bunch

00:32:12.764 --> 00:32:14.766
of packers that basically wrap
UPX. I thought that was awesome

00:32:14.766 --> 00:32:16.768
so I learned a whole bunch
there. These kind of variations.

00:32:16.768 --> 00:32:18.770
So let's go through this recap.
The idea was generate signatures

00:32:18.770 --> 00:32:20.772
I had a working demo you would
have seen me type one command

00:32:20.772 --> 00:32:22.774
and the signature would have
appeared out of no where and it

00:32:22.774 --> 00:32:28.780
would have been awesome. It
involves math, great. Who

00:32:51.369 --> 00:32:53.371
doesn't love math. It's
cross-platform, it's all written

00:32:53.371 --> 00:32:55.373
in python because python is the
new old ruby. Capstone engine,

00:32:55.373 --> 00:32:57.375
cross platform, mostly easy to
understand, it involves a little

00:32:57.375 --> 00:32:59.377
bit of math but hopefully not
too bad even for 5:00 on a

00:32:59.377 --> 00:33:01.313
Friday and probably most
important for me is it works. So

00:33:01.313 --> 00:33:03.315
even though the paper promised a
demo and it didn't work, I'm

00:33:03.315 --> 00:33:06.751
going to release it online. The
guys at work are more than happy

00:33:06.751 --> 00:33:09.654
to say you can totally release
this tool and sample signatures

00:33:09.654 --> 00:33:11.656
for people to play with and use.
It and these slides, the updated

00:33:11.656 --> 00:33:15.327
slides because the old ones are
on the CD, feel free to take a

00:33:15.327 --> 00:33:19.164
picture of it, or hit me on
Twitter, however it's not up

00:33:19.164 --> 00:33:23.301
there yet because I'm a slacker
and it will get done next week.

00:33:23.301 --> 00:33:26.071
If anybody has any questions,
I'm more than happy to answer

00:33:26.071 --> 00:33:28.139
them. >> The answer is once you
have all of this data, what's

00:33:28.139 --> 00:33:30.141
the action. And that's really a
good question. So aside from why

00:33:30.141 --> 00:33:32.143
did I do it, because I love
messing with things, it's

00:33:32.143 --> 00:33:34.145
important in my opinion for any
analysis to drive an action and

00:33:34.145 --> 00:33:36.147
the action is to understand what
you're looking at a malware

00:33:36.147 --> 00:33:38.149
versus something looking for
extra context. If I could help

00:33:38.149 --> 00:33:40.151
solve part of this signature
management program and you can

00:33:40.151 --> 00:33:42.153
get this idea of fairly accurate
signatures with very little low

00:33:42.153 --> 00:33:44.155
lift, when you're at your home
organizations and you've got

00:33:44.155 --> 00:33:46.157
man, I've got this piece of
malware that I've never seen and

00:33:46.157 --> 00:33:48.159
you can grab 3,900 signatures
off the Internet, it tells me

00:33:48.159 --> 00:33:50.161
how similar it is to some things
other people have seen. It gives

00:33:50.161 --> 00:33:52.163
you a starting point for
analysis. It would be awesome.

00:33:52.163 --> 00:33:54.165
Would you believe it? If anyone
is using it? I haven't run into

00:33:54.165 --> 00:33:56.167
it. The question was have I run
into anyone putting in the

00:33:56.167 --> 00:33:58.169
packer information into the
packed files. My answer is no.

00:33:58.169 --> 00:34:00.138
Because I didn't run into it in
any of my sample sets. However,

00:34:00.138 --> 00:34:02.307
even at 410 or 411 --> 000 binaries,
given the number of executables

00:34:02.307 --> 00:34:04.309
that everybody talks about,
that's still a relatively small

00:34:04.309 --> 00:34:07.178
sample set so it's no where near
everything. Does this apply to

00:34:07.178 --> 00:34:13.184
protectors as well. When I say
packer I mean protectors,

00:34:15.820 --> 00:34:21.826
crypters, the whole gamut. Any
more? Man. Is my math that much

00:34:29.334 --> 00:34:33.972
not everybody fell asleep and
nobody has questions on math?

00:34:33.972 --> 00:34:39.711
All right. Cool. So I'll be
around if anybody has questions.

00:34:39.711 --> 00:34:45.951
One more. >> (Inaudible). >> How
do I make this moustache happen.

00:34:45.951 --> 00:34:52.557
I think it is genetics. It is
math. This is what happens when

00:34:52.557 --> 00:34:58.563
you do too much math.
(Laughter.) I actually had a

00:35:33.298 --> 00:35:39.304
really long beard at one point
in time and my wife hated my

00:36:00.892 --> 00:36:03.228
long beard because I told her I
was going for wizard length. So

00:36:03.228 --> 00:36:09.234
I said, you know if I can't have
a long beard, I'm going to have

00:37:03.822 --> 00:37:09.828
a long moustache. Now I sleep on
the couch. (Laughter.) Too much

00:37:56.074 --> 00:38:02.013
D 3. Exactly. Any more
questions? Nobody? All right,

00:38:18.496 --> 00:38:24.502
cool. Thanks for coming. I
appreciate it. (Applause.) 

