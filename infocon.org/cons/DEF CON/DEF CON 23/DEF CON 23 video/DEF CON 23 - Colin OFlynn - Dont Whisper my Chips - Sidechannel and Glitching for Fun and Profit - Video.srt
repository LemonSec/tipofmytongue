00:00:00.167 --> 00:00:02.269
This is don't whisper my chips
and I'm going to be talking

00:00:02.269 --> 00:00:09.543
about various methods of
hardware hacking, a bit of

00:00:09.543 --> 00:00:13.347
glitching, more importantly how
you can do it. I'm from Canada.

00:00:13.347 --> 00:00:17.784
If you've had Canada jokes, I've
probably heard them. Entertain

00:00:17.784 --> 00:00:22.189
new ones. A number out there.
One of the things about this

00:00:22.189 --> 00:00:27.294
talk is everything I'm doing is
open source. Going to be a bunch

00:00:27.294 --> 00:00:30.464
of hardware, and it's all
commercially available, if you

00:00:30.464 --> 00:00:33.734
don't want to build it. All this
stuff I've been working on is

00:00:33.734 --> 00:00:35.936
open hardware. Whatever you
want. All GPL, no restrictions,

00:00:35.936 --> 00:00:41.942
oh, you have to only use it
yourself or something like that.

00:00:45.178 --> 00:00:47.848
So the main tools, and there
will be a slide with links at

00:00:47.848 --> 00:00:53.287
the end, is on the
ChipWhisperer.com, and -- I

00:00:53.287 --> 00:00:56.290
founded help some of the
commercial versions and

00:00:56.290 --> 00:00:59.993
trainings and stuff like that,
so both of those resources have

00:00:59.993 --> 00:01:05.365
all the information here. Okay.
So there's one sort of caveat I

00:01:05.365 --> 00:01:08.001
have to give at the beginning,
and that's everyone with all

00:01:08.001 --> 00:01:11.972
these attacks wants the sausage.
They want to just eat that and

00:01:11.972 --> 00:01:14.374
be done and that is they want
the attack, they want to put

00:01:14.374 --> 00:01:17.878
something on the desk, run a
side channel attack and get the

00:01:17.878 --> 00:01:21.748
magic keys out. But what I'm
taking you through is the

00:01:21.748 --> 00:01:24.818
sausage factory. So you're going
to learn how it works, whether

00:01:24.818 --> 00:01:27.487
you like it or not. Because
that's the only way these

00:01:27.487 --> 00:01:30.691
attacks are possible. They're
not a, you know -- it's not a

00:01:30.691 --> 00:01:33.961
vulnerability against some
specific implementation.

00:01:33.961 --> 00:01:38.432
Fundamental about the entire way
we implement things on digital

00:01:38.432 --> 00:01:44.471
systems. So very briefly, my
background is in embedded

00:01:44.471 --> 00:01:48.041
hardware design, not necessarily
security. I worked for a while

00:01:48.041 --> 00:01:51.645
at a company Atmel, makes the
microcontrollers, some various

00:01:51.645 --> 00:01:57.084
consulting projects, right now
I'm doing a PhD at Dalhousie

00:01:57.084 --> 00:02:02.289
University, and I have a blog
that has various projects that

00:02:02.289 --> 00:02:05.892
have been ongoing with that.
More interestingly, I did a

00:02:05.892 --> 00:02:09.363
Kickstarter recently, so this
was for a project called

00:02:09.363 --> 00:02:13.133
ChipWhisperer-Lite, basically my
objective to make the cheapest

00:02:13.133 --> 00:02:17.137
possible capture hardware that I
could. My talk will use this a

00:02:17.137 --> 00:02:21.441
bit but as I said, it is open
and you don't specifically have

00:02:21.441 --> 00:02:25.078
to use this hardware. This isn't
about my hardware. It's about

00:02:25.078 --> 00:02:29.049
how you do these attacks in
general. All right. So what is

00:02:29.049 --> 00:02:32.285
the side channel? When we say,
you know, side channel analysis,

00:02:32.285 --> 00:02:35.522
this is the most fundamental
thing you need to sort of start

00:02:35.522 --> 00:02:39.693
to realize. The easiest side
channel I can explain and

00:02:39.693 --> 00:02:42.929
apologies if you've seen some of
these talks before, I always

00:02:42.929 --> 00:02:47.734
have the same ten minute intro,
so you can zone out for ten

00:02:47.734 --> 00:02:52.072
minutes. Pin code, something
that needs to check the pin

00:02:52.072 --> 00:02:56.843
code, you might implement it
like this. So we have a

00:02:56.843 --> 00:03:00.380
PCP-Code, reads into the entire
pin, so it's not doing something

00:03:00.380 --> 00:03:06.520
dumb, checking after every digit
and checks that pin with the

00:03:06.520 --> 00:03:10.290
correct pin. But what you could
see is that as soon as the pin

00:03:10.290 --> 00:03:15.629
is wrong, so you know once it's
not equal to the entered pin,

00:03:15.629 --> 00:03:18.799
it's going to exit this loop. So
it's just going to return out.

00:03:18.799 --> 00:03:22.035
And this is pretty common how
some things really implement it.

00:03:22.035 --> 00:03:26.006
What this means is that, as soon
as the pin is run, you see some

00:03:26.006 --> 00:03:29.109
-- there's some finite time it
takes for this loop to actually

00:03:29.109 --> 00:03:33.413
execute. And we can take
something like there's some pin

00:03:33.413 --> 00:03:36.516
protected hard drive, this isn't
an encrypted hard drive. I have

00:03:36.516 --> 00:03:39.920
to point that out. It had a
simple pin code on it. Wouldn't

00:03:39.920 --> 00:03:43.924
enumerate without pin in it.
Vulnerable to this timing

00:03:43.924 --> 00:03:49.629
attack. It's a real thing you'll
see in a lot of products. In

00:03:49.629 --> 00:03:53.033
this example, to do a side
channel timing attack on this,

00:03:53.033 --> 00:03:56.970
what we do is, we have some
scope probe set up. One at the

00:03:56.970 --> 00:04:00.440
top here is just -- there's an
LED says your password was

00:04:00.440 --> 00:04:04.077
wrong, and there's another one
that's just connected to one of

00:04:04.077 --> 00:04:09.616
the buttons. Down here you can
sort of see -- red on red. But

00:04:09.616 --> 00:04:12.586
what we're trying to see, what
is the time delay when we put in

00:04:12.586 --> 00:04:16.556
the last digit of the pin and
start comparison and when that

00:04:16.556 --> 00:04:21.895
LED goes on? And if there's a
timing attack, we can use that

00:04:21.895 --> 00:04:24.798
time difference to really
quickly discover what the pin

00:04:24.798 --> 00:04:27.968
for that hard drive is. So
there's always a few

00:04:27.968 --> 00:04:34.007
complexities in real life.
Microcontroller, button press.

00:04:34.007 --> 00:04:37.310
Not just when the user presses
it. So you have to go through

00:04:37.310 --> 00:04:40.280
reverse engineer a tiny bit, how
is it actually reading the

00:04:40.280 --> 00:04:44.117
buttons, and stuff like that.
But it's all fairly reasonable.

00:04:44.117 --> 00:04:47.787
So in this case, what we see is
that the correct password by the

00:04:47.787 --> 00:04:52.626
way, is 123456, so very hard to
guess here. And so if I put in

00:04:52.626 --> 00:04:59.332
06666, what you see is this time
delay from this point here,

00:04:59.332 --> 00:05:02.502
where I press that button, to
this point over here, and this

00:05:02.502 --> 00:05:06.673
is where the -- the bad LED goes
on. And there's this, you know,

00:05:06.673 --> 00:05:09.910
whatever this time delay is, we
don't care. What we do care

00:05:09.910 --> 00:05:13.980
about is if I put in 1666, so
now the first digit is correct,

00:05:13.980 --> 00:05:18.451
we can look at that time delay
again, and you notice it's

00:05:18.451 --> 00:05:21.221
longer, so this means we now
know, the first digit is

00:05:21.221 --> 00:05:24.624
correct, so we can just guess
one digit at a time. We don't

00:05:24.624 --> 00:05:28.595
have to guess the whole pin and
if we go through and put in 123,

00:05:28.595 --> 00:05:31.865
666, you see it's an even longer
delay. So again you compare this

00:05:31.865 --> 00:05:36.937
slide with this one. So that's
sort of some of the most basics

00:05:36.937 --> 00:05:41.074
attacks you might do, and this
is using the time delay of some

00:05:41.074 --> 00:05:44.744
output based on the input. This
is a pretty obvious one. Has

00:05:44.744 --> 00:05:49.916
been known for a long time, so
people want to avoid that. The

00:05:49.916 --> 00:05:52.385
correct way to do this is
something like you don't

00:05:52.385 --> 00:05:55.889
directly compare the password,
so we're using the hash. But

00:05:55.889 --> 00:05:58.859
what you also might do is just
not give any response when it's

00:05:58.859 --> 00:06:02.095
wrong or add some random delays,
say, well, we always wait some

00:06:02.095 --> 00:06:07.000
random amount. The problem with
the second solution is you could

00:06:07.000 --> 00:06:10.036
start to look at the power
difference then. And what this

00:06:10.036 --> 00:06:13.473
is, is that this is a different
system that compares the

00:06:13.473 --> 00:06:16.977
password being sent over a
serial bus, and it gives no

00:06:16.977 --> 00:06:21.314
response for a wrong password.
It just doesn't ever respond.

00:06:21.314 --> 00:06:24.985
And so it's able to do this
because you send it a big

00:06:24.985 --> 00:06:28.388
password, there's some delay
where it processes, and then you

00:06:28.388 --> 00:06:30.790
would send a date and never
responds if password is right or

00:06:30.790 --> 00:06:35.829
wrong, starts ignoring stuff
with the wrong password. So what

00:06:35.829 --> 00:06:40.667
we can see here is that -- yeah,
here it's processing a mostly

00:06:40.667 --> 00:06:43.370
correct password and we see this
sort of -- this is the power

00:06:43.370 --> 00:06:46.873
consumption in blue and the top
is the serial data, we sort of

00:06:46.873 --> 00:06:50.510
see these chunks of data here
but the power consumption

00:06:50.510 --> 00:06:53.413
changed drastically all the
sudden here, sort of jumps up,

00:06:53.413 --> 00:06:57.183
so you can see that average
level. This is the processor

00:06:57.183 --> 00:06:59.986
spinning into infinite loop
because the wrong password was

00:06:59.986 --> 00:07:04.491
sent and you can see digit is
wrong, it receives one digit and

00:07:04.491 --> 00:07:08.361
jumps up in power consumption,
so we can do the same timing

00:07:08.361 --> 00:07:12.465
style attack, just based on the
power consumption, so if we went

00:07:12.465 --> 00:07:16.569
back here, if you -- after this
return, you had a while loop or

00:07:16.569 --> 00:07:20.507
something, waited a bit. You can
see in the microcontroller, it's

00:07:20.507 --> 00:07:23.677
sitting there doing nothing,
based on the power consumption,

00:07:23.677 --> 00:07:30.283
so that's a simple attack. To do
this, all you need is a way to

00:07:30.283 --> 00:07:34.421
measure, it's easy. Insert a
resistor in the VCC line of your

00:07:34.421 --> 00:07:39.559
device. This is micro, or
whatever we're attacking. And we

00:07:39.559 --> 00:07:43.296
-- resistor and connect the
scope across that. In real life,

00:07:43.296 --> 00:07:47.400
here is a microcontroller pin.
And we can see I've lifted the

00:07:47.400 --> 00:07:52.505
pin a bit and added a resistor
right here. And that's sort of

00:07:52.505 --> 00:07:57.344
-- not resistor, so it might
look a little weird but it's not

00:07:57.344 --> 00:07:59.479
terribly difficult with a
microscope -- [ Indiscernible ]

00:07:59.479 --> 00:08:05.852
You can also do stuff like use
magnetic field probe, so all of

00:08:05.852 --> 00:08:08.755
this is changing the current
will generate a change in

00:08:08.755 --> 00:08:11.858
magnetic field, so this means
you have a device like this and

00:08:11.858 --> 00:08:14.294
you physically put it on top of
the chip. You don't need to

00:08:14.294 --> 00:08:17.430
solder anything to it. So it's
all very practical. That's

00:08:17.430 --> 00:08:21.134
really all I'm trying to show
you, measuring the power isn't a

00:08:21.134 --> 00:08:24.571
big deal. There's a few ways to
do it and you can do it on real

00:08:24.571 --> 00:08:30.543
systems. Even more interesting,
all that stuff I showed you was

00:08:30.543 --> 00:08:33.480
simple power analysis
effectively it's called, and

00:08:33.480 --> 00:08:35.982
that's just looking at, oh, I
can see the power changed a

00:08:35.982 --> 00:08:39.285
little bit. What's sort of a
more fun attack is this

00:08:39.285 --> 00:08:43.890
differential power analysis. And
this uses a really simple, you

00:08:43.890 --> 00:08:48.962
know, idea, and this is inside
the microcontroller, we have

00:08:48.962 --> 00:08:51.865
these data lines, and these data
lines are just long wires, and

00:08:51.865 --> 00:08:55.201
it's effectively a capacitor.
And if you sort of remember

00:08:55.201 --> 00:08:58.371
vaguely from high school
physics, changing the voltage on

00:08:58.371 --> 00:09:01.841
a capacitor, it takes power to
do that, even though it seems

00:09:01.841 --> 00:09:07.313
this tiny minuscule thing it
does take power and in the

00:09:07.313 --> 00:09:11.751
microcontroller, setting a data
line from zero to one, therefore

00:09:11.751 --> 00:09:15.588
takes, you know, more power than
not setting a data line. If we

00:09:15.588 --> 00:09:19.159
set two data lines from zero to
one, it takes even more power

00:09:19.159 --> 00:09:23.196
than if just one data line was
set. So what this means is, when

00:09:23.196 --> 00:09:26.299
we look at the microcontroller
power rail, on every clock

00:09:26.299 --> 00:09:30.036
cycle, because conveniently the
digit system switches the lines

00:09:30.036 --> 00:09:33.406
on a clock cycle, how is the
power consumption? If there's a

00:09:33.406 --> 00:09:37.343
bigger spike, we know more data
lines are set than if there's a

00:09:37.343 --> 00:09:42.449
smaller spike, in which case one
data line was set. This is the

00:09:42.449 --> 00:09:46.419
real basic idea between
differential power analysis, we

00:09:46.419 --> 00:09:49.889
can actually figure out how many
ones are going across the data

00:09:49.889 --> 00:09:53.359
bus, inside the microcontroller,
and this is a real thing. So

00:09:53.359 --> 00:09:59.699
this is a -- AT mega micro, and
what I've done is measured how

00:09:59.699 --> 00:10:04.804
many ones, the weight on the
data bus for all the different

00:10:04.804 --> 00:10:10.343
data I can push across the bus,
and you can see really beautiful

00:10:10.343 --> 00:10:15.215
linear graph where it goes from
zero, ones -- lowest power

00:10:15.215 --> 00:10:20.620
consumption -- a kink in there,
I never figured out why. In

00:10:20.620 --> 00:10:26.192
between, nice linear fit. This
does work. This isn't just hand

00:10:26.192 --> 00:10:28.828
waving. You can do these
measurements and you can see

00:10:28.828 --> 00:10:33.366
it's a real thing. So all we got
so far is, we can look at the

00:10:33.366 --> 00:10:36.169
device, and we can see how many
ones are going across the data

00:10:36.169 --> 00:10:41.641
bus. What else do we need? We
need a way of using that to

00:10:41.641 --> 00:10:45.078
break the cryptographic
protocols, so let me give you --

00:10:45.078 --> 00:10:48.047
this is sort of getting towards
the end of the theory bit, don't

00:10:48.047 --> 00:10:52.752
worry. A quick example of this.
Let's say I have this system

00:10:52.752 --> 00:10:54.754
here, I have an X -- device, and
all it's doing is it's XOR'g,

00:10:54.754 --> 00:11:00.693
whatever I send to the system.
Takes, and XORs with secret key.

00:11:03.396 --> 00:11:10.336
Encryption type operation and
goes through the output and we

00:11:10.336 --> 00:11:14.307
don't know where the output
goes, magic land or something.

00:11:14.307 --> 00:11:19.345
We don't care. What we can do.
We can do this power measurement

00:11:19.345 --> 00:11:21.981
at the same time. So we have a
resistor inserted and I'm doing

00:11:21.981 --> 00:11:28.087
the power measurement of the XOR
gate. So if -- if we're the user

00:11:28.087 --> 00:11:30.089
and we're encrypting one -- I
say encrypting, we could say,

00:11:30.089 --> 00:11:37.397
okay, I sent it in hex 80, a
bunch of random data to the

00:11:37.397 --> 00:11:43.403
device. If the secret key was --
we get out six, seven. XOR'd,

00:11:47.407 --> 00:11:53.980
67, and this has a to five, five
ones, count the ones, you get

00:11:53.980 --> 00:11:58.651
the hemming weight. But
remember, we don't know the

00:11:58.651 --> 00:12:01.821
secret key. We don't know the
output. What we see is this. We

00:12:01.821 --> 00:12:05.758
see the input because we sent it
to the device. But the designer

00:12:05.758 --> 00:12:08.795
assumes that's useless because
you just know what you've sent

00:12:08.795 --> 00:12:13.132
it. Don't know what the output
was. We can observe what the

00:12:13.132 --> 00:12:19.038
hemming weight output is. How
many ones are in the output.

00:12:19.038 --> 00:12:24.477
It's not a simple system -- if
the secret key were zero, zero,

00:12:24.477 --> 00:12:28.748
we would have got an output of
eight, eight, which would have

00:12:28.748 --> 00:12:33.019
had two, ones and we do that for
all the inputs. That doesn't

00:12:33.019 --> 00:12:38.658
match. So if it was zero, one,
we'd get this and that -- and

00:12:38.658 --> 00:12:42.128
the hypothesis doesn't match
what we measured still.

00:12:42.128 --> 00:12:44.230
Eventually we get up to the
point where we say, hey, what if

00:12:44.230 --> 00:12:49.602
the secret key was, and now each
of those hypothetical outputs

00:12:49.602 --> 00:12:54.107
actually match what we observe
and so we can say, yes, it's

00:12:54.107 --> 00:12:59.178
probable that the secret key was
yeah, and why I picked XOR,

00:12:59.178 --> 00:13:04.684
that's how differential power
analysis works. How we apply it.

00:13:04.684 --> 00:13:07.420
Let's break a real algorithm.
AES128. At the input of AES128,

00:13:07.420 --> 00:13:14.761
conveniently it's 16 bits wide
but we can break it, as I'll

00:13:14.761 --> 00:13:19.132
show shortly, in just a few
seconds, really. And why is

00:13:19.132 --> 00:13:24.370
possible is because it applies
the algorithm one byte at a time

00:13:24.370 --> 00:13:28.474
so it takes one byte of the key
or sub key. It XORs it with --

00:13:28.474 --> 00:13:31.310
plain text, and passes it
through what is a -- Xbox, it

00:13:31.310 --> 00:13:38.151
goes on. It goes on for several
rounds. We just don't care about

00:13:38.151 --> 00:13:44.624
that. All we care about is -- [
Indiscernible ], because what

00:13:44.624 --> 00:13:49.595
we're able to do is do this
guess and check operation with

00:13:49.595 --> 00:13:56.536
the idea of attacking whatever
the -- Xbox is. So the one thing

00:13:56.536 --> 00:13:59.172
I really want to stress here,
remember all this guess and

00:13:59.172 --> 00:14:03.276
check is doing is it's asking
what is the secret key that the

00:14:03.276 --> 00:14:07.580
algorithm was running with? So
to use this, you have to have

00:14:07.580 --> 00:14:10.183
the crypto operation running
with the secret key you want to

00:14:10.183 --> 00:14:12.785
recover. So if you had an
encrypted hard drive sitting on

00:14:12.785 --> 00:14:17.323
the table, that's no good to
you, because if it's not running

00:14:17.323 --> 00:14:19.325
with that key, if it's not
actively encrypting or

00:14:19.325 --> 00:14:23.296
decrypting, you can't do this
side channel analysis and what

00:14:23.296 --> 00:14:26.099
I'll show you is, two examples
where you can do side channel

00:14:26.099 --> 00:14:29.068
analysis, the device does have
the key, it is able to run with

00:14:29.068 --> 00:14:33.406
it. All right. So before I show
you the types of devices it can

00:14:33.406 --> 00:14:36.342
work with, let me show you what
a side channel analysis looks

00:14:36.342 --> 00:14:40.446
like, so I have a device up
here, and it's a AVR

00:14:40.446 --> 00:14:43.416
microcontroller, it's programmed
with AES128. This works with

00:14:43.416 --> 00:14:49.689
256. It doesn't matter. And I'm
sending data to it. It's

00:14:49.689 --> 00:14:52.358
encrypting it and measuring the
power. These are what the spikes

00:14:52.358 --> 00:14:58.364
are. If I change the data,
monitor the -- output data here,

00:15:01.267 --> 00:15:03.503
so you can see it's sending
random data and gets something

00:15:03.503 --> 00:15:06.305
back. You don't really need to
see it. What's interesting is,

00:15:06.305 --> 00:15:09.876
for example, if I send it the
same input data, so it's fixed.

00:15:09.876 --> 00:15:12.478
You'll notice that the power
consumption is no longer varying

00:15:12.478 --> 00:15:15.915
as much so I'm still doing
encryptions but you see the

00:15:15.915 --> 00:15:19.352
power consumption is very
similar. If I change it back to

00:15:19.352 --> 00:15:22.288
random, you see power
consumption jumping all over.

00:15:22.288 --> 00:15:29.862
Data dependency. I would just do
this again where I send a bunch

00:15:29.862 --> 00:15:35.968
of random datas, like 50 random
packets to the device, record

00:15:35.968 --> 00:15:38.971
the power consumption, and then
do that guess and check

00:15:38.971 --> 00:15:44.977
operations. Let's just save
this. Here. And I reopened that

00:15:47.713 --> 00:15:51.017
same project. So everything I'm
showing you, this is the

00:15:51.017 --> 00:15:55.288
ChipWhisperer software, it's
written in python and open

00:15:55.288 --> 00:16:00.726
source and everything. So you
can see these are the traces I

00:16:00.726 --> 00:16:03.563
captured. And what I'm going to
do, I'm going to ask it to

00:16:03.563 --> 00:16:06.899
perform that guess and check and
tell me for every byte what it

00:16:06.899 --> 00:16:10.970
thinks the correct encryption
key is. I also told it what the

00:16:10.970 --> 00:16:16.976
correct key is, just so it can
highlight in red. You see almost

00:16:19.378 --> 00:16:25.852
immediately it recovers almost
the entire encryption key.

00:16:25.852 --> 00:16:29.288
Sending 30 packets to this
device, side channel analysis,

00:16:29.288 --> 00:16:33.125
recovers A -- open source crypto
library. It doesn't really

00:16:33.125 --> 00:16:36.295
matter which crypto library I
use. If there's no protection

00:16:36.295 --> 00:16:41.234
against this stuff, it's going
to be vulnerable. And you might

00:16:41.234 --> 00:16:44.437
also ask how did I know where
that specific operation

00:16:44.437 --> 00:16:47.607
occurred, and it actually
doesn't matter because I just

00:16:47.607 --> 00:16:51.377
said, you sent some device data
to the device, you encrypted it,

00:16:51.377 --> 00:16:56.716
a whole section of that power
consumption and I can ask, for

00:16:56.716 --> 00:17:01.621
example, where in time, these
big red spikes, was there a high

00:17:01.621 --> 00:17:06.058
correlation? Where in time did
you see that data dependency,

00:17:06.058 --> 00:17:09.328
and we can see as I turned on
each byte, so I'm asking it,

00:17:09.328 --> 00:17:13.099
byte one, byte two, byte three,
it's marching forward in time

00:17:13.099 --> 00:17:19.405
and this is because it's an
eight bit micro, doing Xbox, key

00:17:19.405 --> 00:17:25.478
application. So that's very
quickly how side channel

00:17:25.478 --> 00:17:29.282
analysis works and how you use
them against an unprotected AES

00:17:29.282 --> 00:17:34.654
implementation. So now let's
look at some real applications

00:17:34.654 --> 00:17:41.260
of it. Number one, AES-256
bootloader, so this bootloader

00:17:41.260 --> 00:17:44.030
is loosely based on a whole
bunch of app notes. If you look

00:17:44.030 --> 00:17:49.268
on app -- who else, they have
secure, if you want to make an

00:17:49.268 --> 00:17:54.073
AES-256 bootloader, here's an
example of what you can do. Very

00:17:54.073 --> 00:17:57.009
briefly, how it works, you have
the updated microfirmware file,

00:17:57.009 --> 00:18:04.517
split into a bunch of chunks
like that. You -- they add what

00:18:04.517 --> 00:18:08.654
they call a signature. Kick go
ahead me out of that. Add what

00:18:08.654 --> 00:18:12.925
they call signature operation
here. These four bytes and it's

00:18:12.925 --> 00:18:16.162
just a constant four bytes. The
idea being they encrypt that

00:18:16.162 --> 00:18:19.665
whole block with the signature.
When you decrypt, you verify you

00:18:19.665 --> 00:18:22.969
get the expected four bytes.
After the encryption -- pretty

00:18:22.969 --> 00:18:25.371
simple after the encryption.
Completely on the

00:18:25.371 --> 00:18:31.911
microcontroller side, if you
send encrypted file, it's going

00:18:31.911 --> 00:18:34.547
to try to decrypt it and that's
all we need for a side channel

00:18:34.547 --> 00:18:41.220
attack, so on the -- the
microside of it, what we'll do

00:18:41.220 --> 00:18:45.324
is, we'll look and we'll say,
okay, here's the text log zero,

00:18:45.324 --> 00:18:52.298
it came in, decrypted. CBC mode
so after the decryption, with

00:18:52.298 --> 00:18:58.404
the IV, and you get the first
byte of the plain text right

00:18:58.404 --> 00:19:00.373
here. So here's the -- which is
another thing we can discover

00:19:00.373 --> 00:19:03.509
through the side channel
analysis attack. But we don't

00:19:03.509 --> 00:19:08.914
actually need it. The important
thing to realize is we don't

00:19:08.914 --> 00:19:13.386
necessarily read it for the
attack itself, because the

00:19:13.386 --> 00:19:17.723
ciphertext is decrypted
directly. Because AES-256, two

00:19:17.723 --> 00:19:22.461
-- or two rounds we attack. Us a
32 byte key but not

00:19:22.461 --> 00:19:26.832
fundamentally any different,
really. The only complication,

00:19:26.832 --> 00:19:31.270
so we'll attack one round, first
15 bytes of the key. Attack the

00:19:31.270 --> 00:19:35.408
second round, get the next 16
bytes of the key, sorry, and

00:19:35.408 --> 00:19:39.345
then continue with the attack as
before. The only sort of tricky

00:19:39.345 --> 00:19:44.583
business is, you do get into
stuff like the attack might have

00:19:44.583 --> 00:19:47.653
a bit of a random jitter in it.
This is really easy to deal with

00:19:47.653 --> 00:19:51.257
in the software. We can see here
for example, this is the, you

00:19:51.257 --> 00:19:54.427
know, first decryption round. It
becomes unsynchronized with the

00:19:54.427 --> 00:19:56.429
second round because some time
dependent operations. Shouldn't

00:19:56.429 --> 00:19:58.431
be time dependent but they
screwed up in a few ways here.

00:19:58.431 --> 00:20:04.437
And so we just resynchronized.
Same traces as the previous one,

00:20:09.475 --> 00:20:14.513
just resynchronized it to help
with the alignment. So it's not

00:20:14.513 --> 00:20:20.519
a big deal to do this attack on
a real device. And what we see

00:20:25.424 --> 00:20:28.861
is the success rate, so the
success rate being how often was

00:20:28.861 --> 00:20:34.867
I able to get the key, and the
first round encryption, talk

00:20:37.403 --> 00:20:43.409
about 120. So we're talking
about, you know, a bootloader on

00:20:46.812 --> 00:20:49.715
a micro, and we can send this
data really quickly. This is

00:20:49.715 --> 00:20:56.122
like five minutes of data that
you had to capture to --

00:20:56.122 --> 00:20:59.024
bootloader. At this point we
have the full decryption key, if

00:20:59.024 --> 00:21:04.363
we hadn't updated firmware file
we could decrypt because maybe

00:21:04.363 --> 00:21:07.700
we were trying to hide bugs in
code, don't want us to reverse

00:21:07.700 --> 00:21:12.238
engineer, and stuff like that,
or you could actually send it a

00:21:12.238 --> 00:21:16.442
new firmware file and it's going
to decrypt it and use that file.

00:21:16.442 --> 00:21:19.812
So to do that last part, you
would also need to determine

00:21:19.812 --> 00:21:23.249
what the initialization vector
is and you can do this in a

00:21:23.249 --> 00:21:26.952
similar way through side
channel. I talk a bit about that

00:21:26.952 --> 00:21:30.789
in the paper I link here, and
there's sort of a tutorial that

00:21:30.789 --> 00:21:35.928
steps you. All these slides by
the way, if you go to -- dot

00:21:35.928 --> 00:21:38.264
com, they're posted there, you
don't have to write down a

00:21:38.264 --> 00:21:44.570
million URLs. That's the first
example. Another example is

00:21:44.570 --> 00:21:50.042
802.15.4 mode, so I -- 802.15.4,
used by a whole bunch of

00:21:50.042 --> 00:21:55.047
wireless protocols. I sort of
listed a bunch of them here,

00:21:55.047 --> 00:22:00.619
ZigBee is probably the one you
might have heard of the most.

00:22:00.619 --> 00:22:05.357
But there's, you know, nest uses
as part of the communications.

00:22:05.357 --> 00:22:12.698
Mesh -- has their own. So
there's several things using

00:22:12.698 --> 00:22:18.737
802.15.4, and what makes this
interesting is that a lot of

00:22:18.737 --> 00:22:22.608
802.15.4 are really, really
cheap. It's sort of a competitor

00:22:22.608 --> 00:22:25.811
to Bluetooth low energy-type
stuff, so this node out here

00:22:25.811 --> 00:22:28.414
might be a light switch or
outdoor light. Something the

00:22:28.414 --> 00:22:32.084
attacker can easily get access
to and a lot of the time when

00:22:32.084 --> 00:22:34.887
you have these attacks people
say, yeah, well, we don't care

00:22:34.887 --> 00:22:37.723
about that end node, if they
break, whatever. But the

00:22:37.723 --> 00:22:43.229
interesting thing is that if you
-- interesting ring tone

00:22:43.229 --> 00:22:47.933
selection here. If --
coordinator, Ethernet device as

00:22:47.933 --> 00:22:53.973
well as 802.15.4 side to it. So
if you can send messages back to

00:22:53.973 --> 00:22:58.177
the coordinator, you can start
to fuzz that coordinator's

00:22:58.177 --> 00:23:00.646
802.15.4 interface. These
messages will be appeared to be

00:23:00.646 --> 00:23:04.550
signed correctly, so the
coordinator will process them.

00:23:04.550 --> 00:23:11.891
If you did not have the
encryption key on this link, so

00:23:11.891 --> 00:23:14.293
802.15.4 -- encryption. It's
just going to throw them away

00:23:14.293 --> 00:23:17.596
right away, so what we want to
do is recover that key, so we're

00:23:17.596 --> 00:23:20.299
able to send messages to the
coordinator as if we were that

00:23:20.299 --> 00:23:24.436
node, for whatever reason,
fuzzing, something else you want

00:23:24.436 --> 00:23:30.376
to do. So what makes us able to
do this is that I guess I'll

00:23:30.376 --> 00:23:34.179
talk about this first, the
802.15.4 wireless stack, all

00:23:34.179 --> 00:23:39.451
these protocols have a lower
layer running this 802.15.4

00:23:39.451 --> 00:23:41.954
wireless stack. It defines how
you deal with messages,

00:23:41.954 --> 00:23:45.991
everything like that. If you
send a message that's -- that

00:23:45.991 --> 00:23:49.094
claims to be encrypted, it's
going to do some basic

00:23:49.094 --> 00:23:52.398
validation of the headers and
security options, and it's then

00:23:52.398 --> 00:23:54.400
going to check a few things.
It's going to check what they

00:23:54.400 --> 00:23:56.402
call the received frame counter
is greater than the last stored

00:23:56.402 --> 00:23:59.939
frame counter, to avoid replay
attacks. Looks up a secret key,

00:23:59.939 --> 00:24:05.277
says what secret key should I be
using to talk to whatever this

00:24:05.277 --> 00:24:10.816
device is. So you have to set up
out of bound. When you talk to

00:24:10.816 --> 00:24:14.620
device XY -- here's the secret
key in use. The standard doesn't

00:24:14.620 --> 00:24:17.289
specify how you do it. Code
whatever key, on that link,

00:24:17.289 --> 00:24:19.291
decrypts key load and validates
the message, authentication

00:24:19.291 --> 00:24:21.660
code. Present -- almost all the
actual standards use it and

00:24:21.660 --> 00:24:23.896
finally it stores the new frame
-- they have to do this last

00:24:23.896 --> 00:24:29.902
during the new one to prevent
you from just sending an

00:24:35.874 --> 00:24:42.948
unauthenticated message to
device -- no longer listen to

00:24:42.948 --> 00:24:48.220
any lower frame cameras, really
easy denial service attack. So

00:24:48.220 --> 00:24:51.357
what this means to us is that
remember the conditions we

00:24:51.357 --> 00:24:55.160
needed for side channel attack,
we need to run the crypto, and

00:24:55.160 --> 00:24:59.331
it needs to be running with the
key in use, so in this case, we

00:24:59.331 --> 00:25:01.800
have that. We can decrypt the
pay load, or it will try to

00:25:01.800 --> 00:25:04.603
decrypt the pay load and it's
going to try using the key of

00:25:04.603 --> 00:25:10.743
interest. So to test this, I
have a 802.15.4 development

00:25:10.743 --> 00:25:16.015
board. On this I just loaded a
commercial 802.15.4 stack. This

00:25:16.015 --> 00:25:20.586
is doing the parameasurement, a
paper with all the details, I

00:25:20.586 --> 00:25:26.425
think I have link up here, if
you want to see more details on

00:25:26.425 --> 00:25:31.764
how this was set up. It's all in
that paper. So there's a

00:25:31.764 --> 00:25:35.134
resistor inserted into one of
the power pins, differential,

00:25:35.134 --> 00:25:39.138
which reduces noise, so nothing
too crazy and this hardware in

00:25:39.138 --> 00:25:42.508
the background is the analog
capture. So this is part of

00:25:42.508 --> 00:25:46.311
ChipWhisperer project I'm
talking about, again open-source

00:25:46.311 --> 00:25:52.017
hardware but you don't need that
specifically. The only sort of

00:25:52.017 --> 00:25:55.521
caveat here, it's not
decrypting, whatever you send it

00:25:55.521 --> 00:25:59.158
it doesn't just fire into AES.
It uses a form of counter mode

00:25:59.158 --> 00:26:06.131
in AES. Sixteen byte input in
AES, source long address, which

00:26:06.131 --> 00:26:12.004
is an 8-byte field, and you have
to specify that correctly, so

00:26:12.004 --> 00:26:14.773
you can spoof it easily, but you
have to pretend you're -- this

00:26:14.773 --> 00:26:17.142
wireless -- was previously
talking to. You have the frame

00:26:17.142 --> 00:26:22.848
counter, which is something you
control. And then the security

00:26:22.848 --> 00:26:26.452
level of the AES counter -- or
you don't control, so the AES

00:26:26.452 --> 00:26:31.290
counter increments slowly. So
there's a few tricks within this

00:26:31.290 --> 00:26:35.694
to get it to work as in the
previous attacks. Basically you

00:26:35.694 --> 00:26:39.465
do math, is the short form of
it. But in reality, what we're

00:26:39.465 --> 00:26:43.735
doing, we have to push it into
more -- of the AES algorithm, so

00:26:43.735 --> 00:26:46.972
we're no longer just attacking
that one point. We have to

00:26:46.972 --> 00:26:49.641
attack multiple points and
there's details LinkedIn that

00:26:49.641 --> 00:26:56.315
paper but at the -- linked in
that paper. If I take that

00:26:56.315 --> 00:26:59.952
hardware device, and it has a
hardware AES engine inside it,

00:26:59.952 --> 00:27:02.187
not a software AES
implementation, we can see stuff

00:27:02.187 --> 00:27:05.991
like after sending it about
10 --> 000 or so packets, we can

00:27:05.991 --> 00:27:09.862
almost completely recover the
AES key, so I'm using a metric

00:27:09.862 --> 00:27:14.633
here called guessing entropy,
when it is zero, I know the key

00:27:14.633 --> 00:27:18.770
perfectly. If the entropy is
two, I needed to do two wrong

00:27:18.770 --> 00:27:23.175
byte guesses. So it's a fairly
straight forward metric and you

00:27:23.175 --> 00:27:27.012
can really see that after about
that 10 --> 000 traces, able to

00:27:27.012 --> 00:27:34.052
recover. This is a core stack,
on a real device, on a real DEV

00:27:34.052 --> 00:27:39.424
core, no tricks to make it easy
here. That's very briefly how

00:27:39.424 --> 00:27:46.131
the side channel power analysis
works. And how you can perform

00:27:46.131 --> 00:27:50.102
it against redevices. The other
thing I want to talk about is

00:27:50.102 --> 00:27:53.839
glitching, and in particular,
power glitching, so glitching is

00:27:53.839 --> 00:27:57.976
just where we make a device do
something, you know, unintended,

00:27:57.976 --> 00:28:01.146
is the generic term. Really what
we're looking at, when you look

00:28:01.146 --> 00:28:06.018
at the code, all sorts of lines
like this, so this is -- logging

00:28:06.018 --> 00:28:09.821
into Linux, at some point, it
says, hey, if your user ID is

00:28:09.821 --> 00:28:13.825
not equal to zero, check the
various authentication methods.

00:28:13.825 --> 00:28:17.896
If it is equal to zero, just
skip out. And so with glitching,

00:28:17.896 --> 00:28:20.132
what we want to do is we want to
actually screw up that

00:28:20.132 --> 00:28:24.169
comparison. We want to make the
hardware device perform the

00:28:24.169 --> 00:28:27.973
wrong operation there, and you
can do the same thing, on an

00:28:27.973 --> 00:28:31.476
Android device, on the lock
screen, there's always some

00:28:31.476 --> 00:28:34.846
point where it says, hey, did
this operation pass or not? And

00:28:34.846 --> 00:28:38.317
with glitching is, the objective
is we can cause the wrong -- to

00:28:38.317 --> 00:28:42.888
be executed. So it's a way to
skip over security in the

00:28:42.888 --> 00:28:47.926
device. So sort of make an
easier demo and by easier, I

00:28:47.926 --> 00:28:50.729
mean something you can
replicate, what I have here, I

00:28:50.729 --> 00:28:55.067
have a four loop, and there's
basically 24 loops that should

00:28:55.067 --> 00:28:57.469
increment this -- two four loops
that should increment this

00:28:57.469 --> 00:29:02.074
value. It prints the results --
how many times it ran through

00:29:02.074 --> 00:29:04.977
each loop and how many times
this value got incremented in

00:29:04.977 --> 00:29:09.147
total. If it works correctly, it
should have incremented it 25

00:29:09.147 --> 00:29:14.219
million times, and I did this on
a Raspberry Pi, so I'm looking

00:29:14.219 --> 00:29:19.391
at larger devices, not just an
eight bit microcontroller. On

00:29:19.391 --> 00:29:23.595
this Raspberry Pi, all I've
done, a wire here and where this

00:29:23.595 --> 00:29:27.566
wire connects to is one of the
capacitors, so you can see I've

00:29:27.566 --> 00:29:33.672
soldered it to positive point on
the capacitor and to this point.

00:29:33.672 --> 00:29:39.611
It's basically an electronic
switch. And it's going to short

00:29:39.611 --> 00:29:42.381
these two points together, and
have some input that says how

00:29:42.381 --> 00:29:48.520
long do I short this for? And so
that's the M. I'm using. So the

00:29:48.520 --> 00:29:51.289
newer design I have, this
ChipWhisperer-Lite has these

00:29:51.289 --> 00:29:54.359
glitching tools built in. But
again, you can just build your

00:29:54.359 --> 00:29:57.429
own like this, if you want. And
all you do, when you short that

00:29:57.429 --> 00:30:00.666
for a very specific amount of
time, when you look at the power

00:30:00.666 --> 00:30:04.136
rail, it generates massive
spikes. Huge voltage transients

00:30:04.136 --> 00:30:06.772
and cause undesired behavior. So
let's take a look at what that

00:30:06.772 --> 00:30:12.778
looks like. So this -- this demo
sort of trying to show the

00:30:21.953 --> 00:30:27.926
setup. I'm going to shift to the
interesting right. Same

00:30:27.926 --> 00:30:35.334
Raspberry Pi, same board I was
showing you before. It has --

00:30:35.334 --> 00:30:38.270
I'm pinging the board. You can
see the reply, this is to show

00:30:38.270 --> 00:30:42.441
us running at the time and I had
that wire set up that I had

00:30:42.441 --> 00:30:48.447
before. And the glitching board
is again just shorting the

00:30:48.447 --> 00:30:55.454
output. And what I'm going to do
is run the test program here.

00:30:55.454 --> 00:30:57.456
And you can see the correct
output, ran through both loops

00:30:57.456 --> 00:31:04.429
5 --> 000 times, incremented the
final value 25 million times.

00:31:04.429 --> 00:31:11.770
1.2-volt rail. Core voltage for
Raspberry Pi and when we hit

00:31:11.770 --> 00:31:14.139
trigger button, it's generating
the glitch. If you want to

00:31:14.139 --> 00:31:16.575
generate the glitch, you can
make an -- anything that can set

00:31:16.575 --> 00:31:22.581
that -- activate it for the
correct period of time, and what

00:31:26.151 --> 00:31:30.922
you might see -- I think I ran
it again here, is that that

00:31:30.922 --> 00:31:34.893
count value, when I hit trigger
becomes incorrect, so I don't

00:31:34.893 --> 00:31:38.797
know if it's too visible. But
you can see this count value

00:31:38.797 --> 00:31:42.300
here, it skipped out of that
loop at one point, so the glitch

00:31:42.300 --> 00:31:44.736
-- it didn't crash anything
else. It's still pinging the

00:31:44.736 --> 00:31:49.141
board. Everything like that. It
just caused some incorrect code

00:31:49.141 --> 00:31:52.844
path to be executed. That's the
interesting thing you can do

00:31:52.844 --> 00:31:57.482
about glyphing, causing entire
incorrect code paths to occur

00:31:57.482 --> 00:32:00.886
and you can use that for
bypassing various security

00:32:00.886 --> 00:32:05.090
measures. Another example on
Android smartphone. I've done

00:32:05.090 --> 00:32:08.860
the exact same thing. Sign of
wired a pin to one of the power

00:32:08.860 --> 00:32:12.631
pins to a system on a chip on
it. I think I have a close-up

00:32:12.631 --> 00:32:17.068
here. There you go. You can see
it's this Qualcomm chip,

00:32:17.068 --> 00:32:23.074
whatever it is. Core voltage,
takes a bit of experimentation

00:32:27.479 --> 00:32:31.383
to figure out what voltages are
but once you do that, very

00:32:31.383 --> 00:32:39.191
possible. Same sort of setup
here. I have the Mosfet. As a

00:32:39.191 --> 00:32:42.027
note, the program, all it's
doing, it's doing that

00:32:42.027 --> 00:32:44.930
calculation and displays it on
screen, so this was, like, the

00:32:44.930 --> 00:32:50.268
first Android app I ever wrote,
so it's very high quality and I

00:32:50.268 --> 00:32:53.238
left the hello world in, because
I didn't want to risk screwing

00:32:53.238 --> 00:32:56.741
it up. But what you can see, one
of those calculations was wrong

00:32:56.741 --> 00:32:58.743
and I can do it again. Does that
calculation five times in a row

00:32:58.743 --> 00:33:00.679
and then displays it. So I want
to hit start. Insert the

00:33:00.679 --> 00:33:02.681
trigger. You'll see a different
one is wrong. So I'm not

00:33:02.681 --> 00:33:08.687
triggering it reliably right
here. At this point, I'm just

00:33:13.191 --> 00:33:16.428
confirming the device is
vulnerable and experimenting

00:33:16.428 --> 00:33:19.731
with the required parameters,
and sometimes it crashes. I'm

00:33:19.731 --> 00:33:25.003
running on real device so it
might glitch the wrong code or

00:33:25.003 --> 00:33:29.708
something like that. So that's
sort of the -- the simple way to

00:33:29.708 --> 00:33:33.245
do power glitches. It's really
good. You might have heard,

00:33:33.245 --> 00:33:37.048
transients, can't on Raspberry
Pi or Android. They use an

00:33:37.048 --> 00:33:39.818
internal clock generator
effectively, so that's why this

00:33:39.818 --> 00:33:45.824
method is really fun, because
you don't have to worry about

00:33:49.427 --> 00:33:54.900
that. You're using this power
glitching, and you can also do

00:33:54.900 --> 00:33:56.935
it against the small -- I don't
have a movie of that, but

00:33:56.935 --> 00:34:03.975
there's a tutorial that runs you
through it. All right. So one of

00:34:03.975 --> 00:34:07.245
the first things people always
ask, you know, that's great, but

00:34:07.245 --> 00:34:10.515
how do you trigger it because
clearly, all of this is

00:34:10.515 --> 00:34:14.085
dependent on me knowing when
it's doing some operation. And

00:34:14.085 --> 00:34:17.422
there's a few ways that we can
do this in real life. One of

00:34:17.422 --> 00:34:20.792
them is I can actually match,
this is the analog power data, I

00:34:20.792 --> 00:34:24.629
can match patterns in the power
data. And for example, if I

00:34:24.629 --> 00:34:29.968
switch back to the capture
device, what you'll find,

00:34:29.968 --> 00:34:32.203
there's certain sections of the
code, you know, when it's

00:34:32.203 --> 00:34:37.108
jumping to the encryption
operation, that it's -- just run

00:34:37.108 --> 00:34:43.214
it again. It has some very well
defined sort of outline of

00:34:43.214 --> 00:34:46.851
paratrace and it doesn't vary a
whole lot with different data.

00:34:46.851 --> 00:34:52.724
So I'm just going to change
this. So as I hit sort of

00:34:52.724 --> 00:34:57.862
capture one, there's this
section in here, and you'll

00:34:57.862 --> 00:35:01.132
notice the data doesn't jump
around for the second half.

00:35:01.132 --> 00:35:03.134
There's a little section in
there. So you can actually

00:35:03.134 --> 00:35:06.271
trigger based on a pattern in
the analog data, so that's

00:35:06.271 --> 00:35:09.441
something that some of the
ChipWhisperer hardware variance,

00:35:09.441 --> 00:35:13.712
not the Lite, some can perform.
When I send data, here's the

00:35:13.712 --> 00:35:18.516
request to encrypt. Trigger when
I send that request. For the

00:35:18.516 --> 00:35:22.120
side channel analysis, you can
resynchronize afterwards, you

00:35:22.120 --> 00:35:26.625
don't have to have everything
perfectly synchronized, we can

00:35:26.625 --> 00:35:33.264
do that as post processing, not
a big deal. That's sort of a

00:35:33.264 --> 00:35:36.835
super quick, you know, run
through of side channel analysis

00:35:36.835 --> 00:35:40.505
and glitching. I really want to
give you that quick overview to

00:35:40.505 --> 00:35:44.776
sort of convince you it's fun,
and it's something you can do.

00:35:44.776 --> 00:35:47.979
And if you want to do it
yourself, some of the projects

00:35:47.979 --> 00:35:53.985
I've worked on, so this was the
original ChipWhisperer and FPGA

00:35:59.391 --> 00:36:02.127
based board, Spartan FPGA here,
capture board and baseboard with

00:36:02.127 --> 00:36:04.663
power and stuff. And you can set
that up. You can connect to a

00:36:04.663 --> 00:36:06.931
target device, so this is a
target and you have your

00:36:06.931 --> 00:36:09.868
computer to do the power
measurements and the attack and

00:36:09.868 --> 00:36:15.440
everything like that. You can
also use -- this was the second

00:36:15.440 --> 00:36:19.244
project I did. It basically
tried to take this and make it

00:36:19.244 --> 00:36:23.982
much smaller. So we have --
there's still an FPGA here.

00:36:23.982 --> 00:36:26.918
Still the analog capture
hardware, high speed USB

00:36:26.918 --> 00:36:32.924
interface, also a target device.
So this device is what you

00:36:35.627 --> 00:36:38.430
program if you say, I want to
play with AES. That -- whatever

00:36:38.430 --> 00:36:42.434
you want into that X mega
device. If you want to target a

00:36:42.434 --> 00:36:44.436
real target, your own thing,
break it away here and wire into

00:36:44.436 --> 00:36:50.075
your own target. What I have on
stage, I won't move it because

00:36:50.075 --> 00:36:54.412
it's all wired in. Is I have
that connected to another board

00:36:54.412 --> 00:36:56.981
called the not dwena, app --
baseboard. So what we'll do

00:36:56.981 --> 00:37:04.722
here, as an -- these -- as I
said, Kickstarter, being sold at

00:37:04.722 --> 00:37:07.792
the hardware hacking village. I
have one I'm going to throw into

00:37:07.792 --> 00:37:14.365
the crowd here. Try this way.
Okay. It's open box, so there's

00:37:14.365 --> 00:37:19.938
nothing in it. So come up here.
Oh. Because it's open box, it

00:37:19.938 --> 00:37:24.509
didn't fly very well. I'm sorry.
That's one way to get it.

00:37:24.509 --> 00:37:28.813
There's also a signed one being
auctioned off down at the

00:37:28.813 --> 00:37:32.250
hardware hacking village -- not
hardware hacking -- hackers'

00:37:32.250 --> 00:37:38.723
warehouse in the vendor area.
All right. So all of this works

00:37:38.723 --> 00:37:43.728
with this ChipWhisperer software
I was using. And it's all open

00:37:43.728 --> 00:37:47.932
source written this python, so
you can hack away at it. And

00:37:47.932 --> 00:37:50.101
there's a ton of documentation.
That's one thing people are

00:37:50.101 --> 00:37:53.605
always surprised with, for some
reason, is that -- I spent a lot

00:37:53.605 --> 00:37:56.407
of time trying to make good
documentations, so you know it

00:37:56.407 --> 00:37:59.878
goes through tutorials, how to
set up everything like that, and

00:37:59.878 --> 00:38:03.781
play with your own tools. You
really don't need -- don't think

00:38:03.781 --> 00:38:07.085
this is like, oh, this software
only works with this one variant

00:38:07.085 --> 00:38:11.456
of the hardware. You know, I
have built my own using some

00:38:11.456 --> 00:38:15.593
other FPGA boards before and
that's documented. You can build

00:38:15.593 --> 00:38:19.864
your own target device, AVR
target you can play around with

00:38:19.864 --> 00:38:22.233
sane connect it to a scope, so
there's built in drivers, you

00:38:22.233 --> 00:38:26.404
can add other scopes, any
connected device will work just

00:38:26.404 --> 00:38:31.476
fine. Yeah, so that's sort of
the overview of what side

00:38:31.476 --> 00:38:36.181
channel analysis is, how it
works, how you perform it, what

00:38:36.181 --> 00:38:39.584
glitching is and what tools can
do it. So I think I actually

00:38:39.584 --> 00:38:43.821
have a few minutes. If there's
any questions, I can take some

00:38:43.821 --> 00:38:50.595
now. Is there mics for the
question? Do you want to just

00:38:50.595 --> 00:38:56.601
shout? >> Question is, how do
you protect? The best answer is,

00:38:58.970 --> 00:39:04.442
I don't know exactly. Most of my
work has been on the attack, so

00:39:04.442 --> 00:39:09.714
very briefly, there's two major
ways. One is to use hardware

00:39:09.714 --> 00:39:13.985
that doesn't have these leaks.
And specialized checks, smart

00:39:13.985 --> 00:39:17.689
card chips, are designed not to
do this leakage, so you can do

00:39:17.689 --> 00:39:21.092
stuff simply like have
differential lines, one line

00:39:21.092 --> 00:39:24.596
goes high, another goes low, and
that reduces how much leakage

00:39:24.596 --> 00:39:30.602
you have. There's -- the other
way you can do it in software as

00:39:34.973 --> 00:39:37.742
well, there's some various --
there's a whole bunch of, you

00:39:37.742 --> 00:39:40.345
know, this is a huge field of
research. You can mask some of

00:39:40.345 --> 00:39:43.181
the data, try to remove that
data at the output of the

00:39:43.181 --> 00:39:48.586
algorithm. All of these, though,
as you say, it's a tradeoff. You

00:39:48.586 --> 00:39:52.190
may not care to some degree that
it's vulnerable, but you have to

00:39:52.190 --> 00:39:55.593
remember, this is a real threat.
When you're using an AES

00:39:55.593 --> 00:40:01.966
bootloader, don't use the same
key everywhere. AES. Invincible

00:40:01.966 --> 00:40:06.004
type thing. This whole project
is about showing people how

00:40:06.004 --> 00:40:11.276
these attacks work, and how
realistic they are. Are there

00:40:11.276 --> 00:40:16.314
other -- so the question is,
secrete TPM -- those would

00:40:16.314 --> 00:40:22.120
typically, I don't want to say
there always will be, they'll be

00:40:22.120 --> 00:40:25.023
designed to be a lot more
resistant to it, so they'll go

00:40:25.023 --> 00:40:29.227
out of their way to use the
specialized hardware and they

00:40:29.227 --> 00:40:33.531
almost always do the testing,
the standards involved you

00:40:33.531 --> 00:40:37.101
should have some side channel
resistant, so the answer should

00:40:37.101 --> 00:40:43.107
be yes. >> [ Inaudible ] >> So
the question is, if it works

00:40:48.146 --> 00:40:51.683
without a stand alone scope. The
board I made is designed just --

00:40:51.683 --> 00:40:56.220
it has everything on it. So you
don't need a scope. It has the

00:40:56.220 --> 00:40:59.857
analog capture hardware as part
of the board just to get away

00:40:59.857 --> 00:41:01.793
from needing any sort of scope.
I think there's another

00:41:01.793 --> 00:41:05.630
question. >> [ Inaudible ] >>
I'm from Canada and this means I

00:41:05.630 --> 00:41:13.404
have to cross the border when I
come here, so I try to avoid

00:41:13.404 --> 00:41:17.241
doing stuff -- I'll discover
people are mad at when I cross

00:41:17.241 --> 00:41:22.413
the border. So I don't -- I
don't really talk a lot about

00:41:22.413 --> 00:41:25.650
the -- any commercial stuff I've
done. Besides, anything public,

00:41:25.650 --> 00:41:29.620
device, the X meg, hardware
engine, published to be

00:41:29.620 --> 00:41:36.394
breakable. There's a number of
products that people have

00:41:36.394 --> 00:41:40.465
published these results on. The
key lock, so key fab for car was

00:41:40.465 --> 00:41:45.136
a popular one, side channel
analysis. Was able to break it.

00:41:45.136 --> 00:41:47.438
So there has been a number of
real products, all the smart

00:41:47.438 --> 00:41:51.109
code hacking stuff from pay TV.
Some of that was side channeled.

00:41:51.109 --> 00:41:57.115
Not that much of it actually. >>
[ Inaudible ] >> To some level,

00:41:59.951 --> 00:42:02.720
it requires physical access, so
what I've shown, you know, was

00:42:02.720 --> 00:42:05.390
using a resistive shunt. You
have to be able to solder to it.

00:42:05.390 --> 00:42:11.029
EM probe of the if you have
close access you can do it

00:42:11.029 --> 00:42:16.934
pretty easy as well, you can put
a probe within 10 millimeters.

00:42:16.934 --> 00:42:21.072
There is work on using emissions
at a distance, so some companies

00:42:21.072 --> 00:42:24.742
have demos where they have
cryptography -- where they put a

00:42:24.742 --> 00:42:28.079
cell phone on a table, they
monitor the emissions of the

00:42:28.079 --> 00:42:30.915
cell phone using a radio
receiver, you know, 20 feet

00:42:30.915 --> 00:42:37.588
away. And are able to do this
type of attack on the device. So

00:42:37.588 --> 00:42:40.291
it's easier if you have physical
access. It may or may not

00:42:40.291 --> 00:42:43.928
actually be required. I think
that's all. Thank you, everyone,

00:42:43.928 --> 00:42:49.934
for coming out and I hope you've
enjoyed it. [ Applause ]

