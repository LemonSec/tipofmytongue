00:00:00.000 --> 00:00:07.441
Good afternoon. Welcome to the
remote access talk. I welcome

00:00:07.441 --> 00:00:09.443
you all here, thanks for coming
to this talk I know you have a

00:00:09.443 --> 00:00:16.483
lot of choices. Key megsages for
this session, I wanted to let

00:00:16.483 --> 00:00:20.387
you know that your current
security architecture is flawed

00:00:20.387 --> 00:00:22.890
now. I published everything you
need to know, that's all on the

00:00:22.890 --> 00:00:26.660
website. First principles to
demonstrations, full code

00:00:26.660 --> 00:00:30.097
releases, the proof of concept
including test framework for at

00:00:30.097 --> 00:00:33.333
least the first set of
technologies. People are welcome

00:00:33.333 --> 00:00:37.437
to take photos of this and film
this if they want to. The impact

00:00:37.437 --> 00:00:41.408
is going to be significant.
There are no constraints to data

00:00:41.408 --> 00:00:44.778
theft for remote workers or
off-shore partners today. There

00:00:44.778 --> 00:00:49.950
are no easy answers but the
paper has some suggestions. For

00:00:49.950 --> 00:00:53.220
my job I've been both red team
and blue team, I'm currently on

00:00:53.220 --> 00:00:58.058
the blue team in my career. In
my spare time, this is one of my

00:00:58.058 --> 00:01:00.327
hobbies that I'm presenting
today, this has nothing to do

00:01:00.327 --> 00:01:02.696
with any of the companies that I
currently work for, have worked

00:01:02.696 --> 00:01:08.001
for. I laugh at my daughter's
Barbie car, my poor daughter has

00:01:08.001 --> 00:01:11.271
suffered at times for each of
these projects. Her Barbie car

00:01:11.271 --> 00:01:14.641
remains outstanding, we'll have
a look at this this Christmas

00:01:14.641 --> 00:01:17.244
she shouted out Barbie car in
the middle of the Kiwicon

00:01:17.244 --> 00:01:21.815
presentation, she's a cutie. I
want to give credit to

00:01:21.815 --> 00:01:23.850
researchers, there's been a
number of researchers in this

00:01:23.850 --> 00:01:27.554
field there is this whole heap
of technology that's been

00:01:27.554 --> 00:01:32.259
reinvented completely uniquely a
number of times. There's a short

00:01:32.259 --> 00:01:34.962
list here of people most
directly related to technologies

00:01:34.962 --> 00:01:38.532
that I've also reinvented again.
I discovered them afterwards.

00:01:38.532 --> 00:01:41.401
Some of what I'm going to
present is completely distinct

00:01:41.401 --> 00:01:44.404
from these. Some of these I've
with other project but I wanted

00:01:44.404 --> 00:01:47.708
to give credit to these people.
There's much bigger list on the

00:01:47.708 --> 00:01:53.380
website. Let's start with the
problem space. First principles,

00:01:53.380 --> 00:01:56.717
my assertion is that any user
control bit is a communications

00:01:56.717 --> 00:01:58.719
channel. Any user control bit is
a communications channel.

00:01:58.719 --> 00:02:00.654
Validation for this is that the
screen transmits large volumes

00:02:00.654 --> 00:02:06.660
of user controlled bits. I want
to you imagine the screen as

00:02:10.497 --> 00:02:14.301
fiber optic table that's been
cut through. Huge amounts of

00:02:14.301 --> 00:02:18.305
data is being pumped out into
the room. The question then, is

00:02:18.305 --> 00:02:21.375
the screen be transformed into
uncontrolled binary transfer

00:02:21.375 --> 00:02:27.381
interface. I've heard this. [
laughter ] [Applause] >> We have

00:02:31.318 --> 00:02:37.324
tradition at DEF CON. First time
speakers do a shot. This is a

00:02:42.095 --> 00:02:44.664
first time speaker very hard to
give acceptance give big round

00:02:44.664 --> 00:02:50.671
of applause. >> Thank you. >>
We'll all get one. Yes, we do

00:02:57.477 --> 00:03:05.252
shots in every track. >> Thank
you very much. >> This is also

00:03:05.252 --> 00:03:07.754
to all of our new attendees.
Cheers. [ Applause ] >> Thanks,

00:03:07.754 --> 00:03:13.760
appreciate it. There's a way I
didn't practice the talk. So,

00:03:22.536 --> 00:03:28.542
engineering and proof of
concept. [ laughter ] Going back

00:03:33.780 --> 00:03:37.918
in time, terminal printing back
as far as 1984, the handbook we

00:03:37.918 --> 00:03:43.123
talk about printing as a switch
in the software. Data was sent

00:03:43.123 --> 00:03:46.059
to the virtual terminals now
sent to a printer device. Not

00:03:46.059 --> 00:03:48.729
really sending data out of the
screen, same as we did with XYZ

00:03:48.729 --> 00:03:53.900
modem we switch it. Not
literally out of the screen.

00:03:53.900 --> 00:03:58.605
'92-96 VHS tape back-up solution
that I stumbled across in the

00:03:58.605 --> 00:04:01.141
spare parts bins of my
electronics store. The way this

00:04:01.141 --> 00:04:07.147
worked was data was sent out of
video port captured to VHS

00:04:13.019 --> 00:04:17.657
player, you recorded that data
as chunk of blocks that could

00:04:17.657 --> 00:04:23.530
then be played back as video out
from the VHS player back to your

00:04:23.530 --> 00:04:27.734
computer. Literally backed up as
visual signal but not downloaded

00:04:27.734 --> 00:04:31.037
through the display. Pretty
close. The first real screen

00:04:31.037 --> 00:04:35.475
data extraction that we get is
Microsoft project back in 1994

00:04:35.475 --> 00:04:39.079
some of you may have even owned
one of these the way it worked

00:04:39.079 --> 00:04:42.315
there was E-prompt inside the
watch where it exposed window

00:04:42.315 --> 00:04:47.988
and actual lines printed on the
CRT, sent signals that

00:04:47.988 --> 00:04:51.224
programmed it through the face.
It had to work on CRT there's

00:04:51.224 --> 00:04:53.226
been couple of open source
projects that I've referenced

00:04:53.226 --> 00:04:57.097
there where they had to use LED
because it didn't work for LCD

00:04:57.097 --> 00:05:02.969
display. 20 seconds to transfer
75 numbers. Here is that high

00:05:02.969 --> 00:05:08.975
quality ad, 20 years ago the
first computer watch revolution.

00:05:11.878 --> 00:05:16.783
Windows '95 had a tool. You
could manage your phone numbers

00:05:16.783 --> 00:05:22.789
actually export them to the
watch. Good old days. There he

00:05:26.526 --> 00:05:32.098
goes. Out through the CRT into
the face of the watch. Working

00:05:32.098 --> 00:05:37.037
in the machine recognition come
1994 we had QR codes, I'm not

00:05:37.037 --> 00:05:41.241
going into the complete
background of this, this is much

00:05:41.241 --> 00:05:45.445
more technical audience than
I've spoken to before. But the

00:05:45.445 --> 00:05:50.483
features that I want to take out
of this are highly distinguished

00:05:50.483 --> 00:05:54.287
codes, the fact that they're
easily recognized and machine

00:05:54.287 --> 00:05:58.491
recognizable. And 360 degree
scanning. I have to line this

00:05:58.491 --> 00:06:00.927
up. Formalized in 2000.
Capability, automatic

00:06:00.927 --> 00:06:03.463
reorientation, error correction,
native binary support.Ment

00:06:03.463 --> 00:06:07.667
features are one of that error
correction. Later supported to

00:06:07.667 --> 00:06:11.004
form them to what encodes,
really recognizable. Large

00:06:11.004 --> 00:06:16.076
capacity but see in this demo
that we don't need the larger

00:06:16.076 --> 00:06:20.747
capacities. The zen moment if we
consider the QR code as an

00:06:20.747 --> 00:06:23.883
optical packet sitting within
the either of the display

00:06:23.883 --> 00:06:27.020
device. Then what it now
represents is a data gram that

00:06:27.020 --> 00:06:31.291
is layer three. You to get
beyond packet boundary replace

00:06:31.291 --> 00:06:34.928
one code for another. I've got
multiple codes going past the

00:06:34.928 --> 00:06:38.865
viewer. The receiver then uses
video instead of a photo don't

00:06:38.865 --> 00:06:42.002
want to take one then exit. We
want to take a video and keep

00:06:42.002 --> 00:06:46.473
processing. Number of problems,
what we mean data is coming out

00:06:46.473 --> 00:06:51.645
of the screen, there's no way to
signal the sender I've got no

00:06:51.645 --> 00:06:54.414
synchronization, no flow
control. This requires over

00:06:54.414 --> 00:06:59.185
sampling it's a picture I have
table able to take pull multiple

00:06:59.185 --> 00:07:03.890
pictures like any other Wav form
to sample the screen to make

00:07:03.890 --> 00:07:07.861
sure I captured the image at
least once. But oversampling

00:07:07.861 --> 00:07:11.031
creates duplicates. May have
been intentional because that

00:07:11.031 --> 00:07:15.802
may have been part of the
protocol I may have had multiple

00:07:15.802 --> 00:07:20.173
copies. Same data because of
what I was transferring. Now at

00:07:20.173 --> 00:07:24.144
the point where we need to
transport protocol. Create the

00:07:24.144 --> 00:07:28.148
transport data flow take the
first of the packet, smallest

00:07:28.148 --> 00:07:33.286
packet we have in QR code has 14
bites of capacity. Putting a

00:07:33.286 --> 00:07:35.922
header in there take one bite
and create a header, now have

00:07:35.922 --> 00:07:39.326
the choice of framing up this
protocol as I like. I've

00:07:39.326 --> 00:07:42.429
separated it with control and
data frame. The data frame has

00:07:42.429 --> 00:07:46.433
the control which is the header.
I've got a flag tell me what

00:07:46.433 --> 00:07:53.206
type of packet then a counter so
I know where I am in the stream.

00:07:53.206 --> 00:07:58.144
At least so that I can detect
those duplicates. The payload

00:07:58.144 --> 00:08:02.015
simply the data, actual packet
size, the control frame, we've

00:08:02.015 --> 00:08:05.952
got flag to say whether or not
we control the data. And then a

00:08:05.952 --> 00:08:10.924
major type and subtype. You can
see here the types just as an

00:08:10.924 --> 00:08:14.461
example I've thrown together for
proof of concept, file name,

00:08:14.461 --> 00:08:18.465
file size. With stop code for
example that gives CRC the

00:08:18.465 --> 00:08:23.203
payload is the content that have
control message most of these

00:08:23.203 --> 00:08:25.905
messages are simply designed to
give me good user interactivity,

00:08:25.905 --> 00:08:30.410
a good user interface as you'll
see in a moment. Now this is one

00:08:30.410 --> 00:08:35.448
way transfer between two or more
peers, don't forget two devices

00:08:35.448 --> 00:08:38.184
can see the one screen. Now have
multiple receivers off one

00:08:38.184 --> 00:08:41.321
sender. The features layer four
through seven I have high

00:08:41.321 --> 00:08:45.158
latency, I have no support but
to support that because I can't

00:08:45.158 --> 00:08:49.028
tell the sender to speed up or
slow down. I support interrupted

00:08:49.028 --> 00:08:52.565
transfer because I know my
position in the file based on

00:08:52.565 --> 00:08:55.769
how many packets I've received.
And it includes error detection

00:08:55.769 --> 00:08:59.939
both within the packet but also
end to end I have a control

00:08:59.939 --> 00:09:03.710
message with a CRC I know
whether or not I've got the

00:09:03.710 --> 00:09:07.580
whole stream. I've picked there
at layer three a number of specs

00:09:07.580 --> 00:09:10.784
to make sure we have good
sampling without making it

00:09:10.784 --> 00:09:13.987
complicated. One through five or
ten frames per second. Because

00:09:13.987 --> 00:09:17.223
I'm assuming that I got
commodity camera, 30 frames per

00:09:17.223 --> 00:09:20.760
second, ten probably the most, a
range of QR code. See where I

00:09:20.760 --> 00:09:23.963
have chosen the smallest one.
Binary coding and error

00:09:23.963 --> 00:09:30.603
correction. What does this look
like? Well, most of this has no

00:09:30.603 --> 00:09:34.140
real impact on the protocol
other than the MTI that we

00:09:34.140 --> 00:09:38.278
specified. Here, because of the
ECC compression, the frame will

00:09:38.278 --> 00:09:41.614
actually spill over to a larger
size frame depending on some

00:09:41.614 --> 00:09:43.716
types of data. He pushed it up
to that frame capacity

00:09:43.716 --> 00:09:48.054
accordings to bits. What I've
done selected arbitrary reliable

00:09:48.054 --> 00:09:50.056
frame size that makes sure I
don't spill over to larger

00:09:50.056 --> 00:09:53.093
frames which interrupt the flow
of the scream, the recognition

00:09:53.093 --> 00:09:57.430
from the receiver side. For
reference the smallest reliable

00:09:57.430 --> 00:10:00.166
frame capacity there is ten
bites which means rest of the

00:10:00.166 --> 00:10:05.605
protocol has been shaped around
that. As quick example, I'm

00:10:05.605 --> 00:10:10.510
going to send hello world file
out to the room now. That is

00:10:10.510 --> 00:10:14.647
control start, hello world, fit
into ten bites that start

00:10:14.647 --> 00:10:19.219
control. There's start control
QR code saying I have 148 bytes

00:10:19.219 --> 00:10:24.257
packet. Star control FPS sending
five frames per second. Now, my

00:10:24.257 --> 00:10:31.631
client can tell how long it's
going to take for the user to

00:10:31.631 --> 00:10:35.235
receive it. There's my data with
counter of zero saying hello

00:10:35.235 --> 00:10:39.138
world. Then I'm going to send a
stop frame that says that this

00:10:39.138 --> 00:10:44.377
file is complete with this CRC
the receiver can validate it.

00:10:44.377 --> 00:10:50.550
What does that look like. This
is what you can see from the

00:10:50.550 --> 00:10:56.556
transfer. This is a PDF that's
being uploaded to the room now.

00:11:00.960 --> 00:11:03.997
To give you quick feel of data
rates, if we apply the frames

00:11:03.997 --> 00:11:07.000
her second to the packet side
you'll see that we've got

00:11:07.000 --> 00:11:11.037
minimum of 80 bits per second.
Maximum of 32 kilobytes per

00:11:11.037 --> 00:11:18.344
second. If the receiver had high
speed camera be able to proceed

00:11:18.344 --> 00:11:21.080
much higher rates of transfer.
This is exam Mel of the PDF I

00:11:21.080 --> 00:11:25.418
was throwing you before stored
in YouTube being downloaded by

00:11:25.418 --> 00:11:30.557
android phone in flight mode in
realtime. It's open letter that

00:11:30.557 --> 00:11:35.228
I sent to the office of the
Australian information

00:11:35.228 --> 00:11:38.064
commissioner advising him that
the difference that was made in

00:11:38.064 --> 00:11:42.869
2014 between use and disclosure
and the privacy act was actually

00:11:42.869 --> 00:11:47.106
not valid that if I can see it
on the screen, I can download

00:11:47.106 --> 00:11:52.111
it. You'll see that the top the
icon for icon, the status bar

00:11:52.111 --> 00:11:58.117
that realtime scoring this data.
I've almost received that file.

00:12:01.454 --> 00:12:03.489
Then there's a message to say
that it was successfully

00:12:03.489 --> 00:12:08.394
retrieved. You can pull that
down android, Apple as a proof

00:12:08.394 --> 00:12:14.968
of concept now from their
stores. Now, why did I pick that

00:12:14.968 --> 00:12:18.771
ridiculously low QR code version
one. It's native resolution

00:12:18.771 --> 00:12:25.511
pixels. We know that 80 by 25
will contain 80 by 5 will

00:12:25.511 --> 00:12:29.549
contain 20-21 pixels. What
you're looking at here is a same

00:12:29.549 --> 00:12:35.154
program that is outputting QR
code using space character with

00:12:35.154 --> 00:12:38.157
ANSI codes for white on black
and black on white. We'll see

00:12:38.157 --> 00:12:42.362
where that is important when we
get to the architecture. What do

00:12:42.362 --> 00:12:46.599
we got at this point. At this
point, transmit software on my

00:12:46.599 --> 00:12:50.370
laptop here at the podium then
I'd be able to exfiltrate any

00:12:50.370 --> 00:12:55.708
file I want out of this computer
to device you can't see. Camera

00:12:55.708 --> 00:13:00.446
in my hand. But the question is,
if -- how did I get that

00:13:00.446 --> 00:13:03.182
transmit software on to the
laptop in the first place. User

00:13:03.182 --> 00:13:08.621
control bit is a communications
channel, I've got a keyboard,

00:13:08.621 --> 00:13:12.592
what we want is a digital
programmable keyboard. Leonardo

00:13:12.592 --> 00:13:17.630
comes with USB hid support, it's
been available to us for 20, 25

00:13:17.630 --> 00:13:20.667
years that means no drivers
required in the target system

00:13:20.667 --> 00:13:23.936
for this to be recognized as a
keyboard, mouse or joystick. I'm

00:13:23.936 --> 00:13:27.373
going to use this as a keyboard.
Top is the Digi spark which is

00:13:27.373 --> 00:13:31.944
community program, the bottom
one is the Leo stick with 32

00:13:31.944 --> 00:13:39.619
kilobytes that means I have 32
kilobytes -- 25 kilobytes of

00:13:39.619 --> 00:13:43.523
space that I can use to upload a
file. The question is, what are

00:13:43.523 --> 00:13:46.626
we upload. The sensible thing
would be source code because I

00:13:46.626 --> 00:13:50.630
can type it in this text. But
that's hard because I've got to

00:13:50.630 --> 00:13:54.867
compile it in my target system.
What I'm going to do is G zip a

00:13:54.867 --> 00:13:58.371
transmit binary turn it into
Hex, allow it to type the Pex

00:13:58.371 --> 00:14:01.941
into the target system in the
strip form, wrap it around as a

00:14:01.941 --> 00:14:06.546
pearl or bashed script let it
output that binary on the target

00:14:06.546 --> 00:14:13.553
system. This is a HP thin client
with XP embedded that my wife

00:14:13.553 --> 00:14:16.289
ordered from eBay, I have no
idea what the administrative

00:14:16.289 --> 00:14:20.760
credentials are for this box.
I've used putty to log on to a

00:14:20.760 --> 00:14:27.066
Linux system. Now what you'll
see in a moment is I'm going to

00:14:27.066 --> 00:14:30.803
save the data but I'm going to
plug in the Leonardo, when the

00:14:30.803 --> 00:14:34.207
Leonardo plugs in, there it is
there, beautiful hand modeling

00:14:34.207 --> 00:14:38.845
going to pop up say, I need to
-- I need drivers for Leonardo,

00:14:38.845 --> 00:14:42.682
I don't have rights for those
I'm going to cancel that. But it

00:14:42.682 --> 00:14:49.188
also pop up with the USB hid
keyboard. Leonardo USB hid I.D.

00:14:49.188 --> 00:14:52.158
can also be programmed so this
could look exactly like HP

00:14:52.158 --> 00:14:57.130
keyboard for example. Now it's
typing the script. Which is the

00:14:57.130 --> 00:15:04.704
payload that I want to output
into the target system. It types

00:15:04.704 --> 00:15:11.644
and types and types. We'll save
that script. Change permissions

00:15:11.644 --> 00:15:16.949
on it. Now when I run that
script it will output the G zip

00:15:16.949 --> 00:15:23.623
binary. Which I'm going to
capture to a file. Unzip that

00:15:23.623 --> 00:15:29.328
file. Change the permissions on
the payload and I'm going to run

00:15:29.328 --> 00:15:33.366
that payload. That's a 64 bit
Linux payload that just got

00:15:33.366 --> 00:15:39.305
uploaded through a thin wallet.
Technology check point two. What

00:15:39.305 --> 00:15:41.440
have we done at this stage. Now
there's no barrier to get a

00:15:41.440 --> 00:15:45.978
client on to the system and
we've obviously got data off the

00:15:45.978 --> 00:15:48.648
system which means at this point
I've got to bidirectional data

00:15:48.648 --> 00:15:54.487
flow. Let's look at USB hid
interface, it's poled interface

00:15:54.487 --> 00:15:56.956
by the system, comes up once
every milliseconds, a packet

00:15:56.956 --> 00:16:00.560
full of keys. Unfortunately it's
a small packet contains only six

00:16:00.560 --> 00:16:06.032
keyboard keys by code, it's
normal binary. It's also

00:16:06.032 --> 00:16:10.903
automatically developing
interface. If you see the same

00:16:10.903 --> 00:16:17.043
key twice it will strip it out
that means at this stage the

00:16:17.043 --> 00:16:20.813
same problem as we had before. I
need transport protocol for the

00:16:20.813 --> 00:16:24.684
keyboard. This case the packet
-- I'm jumping ahead of myself.

00:16:24.684 --> 00:16:29.422
It is still Unidirectional going
inbound when I originally wrote

00:16:29.422 --> 00:16:31.791
the paper I hadn't seen
implementation where someone has

00:16:31.791 --> 00:16:35.394
done exfiltration of data
through scroll lock, cap lock

00:16:35.394 --> 00:16:40.233
and Num lock. Can't use the
status which I haven't done.

00:16:40.233 --> 00:16:44.604
Create binary payload. That
brings us down to three bytes

00:16:44.604 --> 00:16:49.876
per packet per millisecond.
Which gives me -- and we need to

00:16:49.876 --> 00:16:54.247
correct for the duplication I've
done my own compression and

00:16:54.247 --> 00:16:56.716
rehydration which is all in the
paper that you can find online.

00:16:56.716 --> 00:17:00.286
Again, the packet is tiny we
don't want to steal a bite for a

00:17:00.286 --> 00:17:03.489
header I'll book mark a stream
of these rather than putting a

00:17:03.489 --> 00:17:06.025
header in each one and we'll
ignore everything to do with

00:17:06.025 --> 00:17:09.028
file-based transfers what I want
to do get run data into the

00:17:09.028 --> 00:17:14.333
system. I don't want to be
limited to that 32K chip. At the

00:17:14.333 --> 00:17:17.403
top there I've still got
Leonardo at the bottom USB

00:17:17.403 --> 00:17:23.309
serial adapter. The attacker can
see a serial port, binary data

00:17:23.309 --> 00:17:27.380
going out of that serial port
goes into the keyboard device

00:17:27.380 --> 00:17:32.919
and gets converted to typed
keys. Combined keyboard buffer.

00:17:32.919 --> 00:17:36.355
I exposed number of internal
controls for the framework to

00:17:36.355 --> 00:17:40.059
make it faster. And now it's
binary interface for the

00:17:40.059 --> 00:17:44.730
attacker. Before we augment
TGXF, to stripped out all of the

00:17:44.730 --> 00:17:49.835
file controls for that as well
now I've got a treatment for

00:17:49.835 --> 00:17:54.206
TGFX and stream for TKFX. We'll
join them together as a single

00:17:54.206 --> 00:17:59.912
application. This is what we've
got. On the attacker's computer

00:17:59.912 --> 00:18:04.617
on the left, you'll find TCP
socket listening on that system,

00:18:04.617 --> 00:18:07.820
anything received through that
TCP socket will be sent out of

00:18:07.820 --> 00:18:11.357
the USB serial port heading for
the keyboard stuffer, whatever

00:18:11.357 --> 00:18:15.795
is typed in is received on the
organization side, decoded sent

00:18:15.795 --> 00:18:21.434
out of a packet -- out of TCP
socket on that side, inside the

00:18:21.434 --> 00:18:23.970
organization. Whatever comes out
of the organization is render

00:18:23.970 --> 00:18:28.674
the entoday encoded and rendered
to the screen. Output of the

00:18:28.674 --> 00:18:33.579
soccer on attacker's device.
This is a through console,

00:18:33.579 --> 00:18:39.752
through screen and keyboard,
native TCP socket. The reference

00:18:39.752 --> 00:18:43.723
implementation is limited to
example protocols, 12 kilobytes

00:18:43.723 --> 00:18:50.029
up on the keyboard side, 32K
down on the screen side. There

00:18:50.029 --> 00:18:52.298
are ways that I've suggested you
can improve. We have

00:18:52.298 --> 00:18:56.435
bidirectional serial connection
with native socket interface.

00:18:56.435 --> 00:19:01.540
Within same portability and
massive vulnerability. I know

00:19:01.540 --> 00:19:06.045
guys through PPP example in a
moment. The ESA context. Get

00:19:06.045 --> 00:19:09.548
back to enterprise security
architecture, they are a

00:19:09.548 --> 00:19:13.285
storage-based channel attack.
Some people referred to it as

00:19:13.285 --> 00:19:16.956
overt channel because it's so in
your face. But then where's the

00:19:16.956 --> 00:19:19.291
enterprise in all of this. So
far we've been working from a

00:19:19.291 --> 00:19:21.861
local computer, I gave you one
example that ran over a thin

00:19:21.861 --> 00:19:26.165
client and over the network. But
in the enterprise we ab tract

00:19:26.165 --> 00:19:29.301
the screen and keyboard so that
throughout the organization we

00:19:29.301 --> 00:19:32.438
stretched that screen and
keyboard to look something like

00:19:32.438 --> 00:19:38.944
this. If I'm an off-shore user
today, I'm in that managed I.T.

00:19:38.944 --> 00:19:45.651
service provider off shore, what
I see after I VPNed in, Citrix,

00:19:45.651 --> 00:19:51.257
SSH, all the way through every
single one of our gates, all the

00:19:51.257 --> 00:19:54.860
way through the deepest part of
your organization, the keyboard

00:19:54.860 --> 00:19:57.663
key strokes I type in here go
through all these tunnels to the

00:19:57.663 --> 00:20:01.567
back, the screen pixels render
back come all the way out to me

00:20:01.567 --> 00:20:06.272
off shore. A completely clear
tunnel through the organization.

00:20:06.272 --> 00:20:10.710
This is console abstraction. In
practical terms on the bottom of

00:20:10.710 --> 00:20:14.146
this picture if you can see it
is an attacker on the left and

00:20:14.146 --> 00:20:17.917
enterprise on the right. What
this means attacker device isn't

00:20:17.917 --> 00:20:21.387
the end user computer device
that you gave me off shore. This

00:20:21.387 --> 00:20:24.657
PC that you gave me off shore is
the one perhaps babe the VDI

00:20:24.657 --> 00:20:28.794
doesn't matter which is the
machine where you gave me the

00:20:28.794 --> 00:20:32.932
DAP, the AV, the anti-malware,
where you got all your controls.

00:20:32.932 --> 00:20:36.469
I'm not going to attack this
device. I'm going to plug in a

00:20:36.469 --> 00:20:39.705
keyboard and point a camera at
it, the attacker's device is in

00:20:39.705 --> 00:20:43.676
my hand not connected to the
network. Inside organization,

00:20:43.676 --> 00:20:47.046
that was on the left, on the
right in the deepest part of

00:20:47.046 --> 00:20:49.215
your organization where you have
given me access to manage your

00:20:49.215 --> 00:20:52.952
infrastructure, is the other end
of this client which is right

00:20:52.952 --> 00:20:55.955
next to my goal which is where
you don't have DLP where you

00:20:55.955 --> 00:21:02.528
don't have anti-malware
detection. Example. On the left

00:21:02.528 --> 00:21:05.831
in the red is attacker's device
with no network connectivity. In

00:21:05.831 --> 00:21:09.435
the green-yellow tags the HP
thin client my end user compute

00:21:09.435 --> 00:21:13.272
device, next to applicationer is
R server that SSHed to. I have

00:21:13.272 --> 00:21:19.044
the keyboard stuffer plugged in
a camera on a couple of Pringle

00:21:19.044 --> 00:21:24.450
cans pointing at it. At this
stage I've run PPP on that TCP

00:21:24.450 --> 00:21:30.089
Socket, we just negotiated an
I.P. address. My attacker PC

00:21:30.089 --> 00:21:34.627
with no network connection now
on the same I.P. network as the

00:21:34.627 --> 00:21:38.164
application server. I'm now
running SSH over that I.P.

00:21:38.164 --> 00:21:41.934
connection. Apologies for the
blurriness, I'm not a very good

00:21:41.934 --> 00:21:46.939
elbow model. It will come clear
in a moment. You'll see

00:21:46.939 --> 00:21:49.775
negotiation, there's the request
on the left on attacker screen

00:21:49.775 --> 00:21:55.781
saying, do I want to accept that
SSH key. Another few packets

00:21:57.783 --> 00:22:00.119
come and go. That's the request
for the password. Type the

00:22:00.119 --> 00:22:06.125
password. That's the log in. The
attacker's PC that has no

00:22:15.601 --> 00:22:19.605
network connectivity at all,
just SSH into the application

00:22:19.605 --> 00:22:25.611
server. [Applause] Solution two.
New for Christmas 2014. When you

00:22:37.823 --> 00:22:41.827
present these things people blog
about them they say, it's

00:22:41.827 --> 00:22:43.829
interesting. But I can stop QR
codes that's what I put in the

00:22:43.829 --> 00:22:49.902
paper. When I went to Kiwicon I
released something new that was

00:22:49.902 --> 00:22:56.141
an ASCII version. So, I believe
this is an unsolvable problem.

00:22:56.141 --> 00:22:58.277
This was another variation to
demonstrate that, so at this

00:22:58.277 --> 00:23:03.649
stage TGFX is transported
protocol, I've got my data gram

00:23:03.649 --> 00:23:07.353
protocol on layer three I'm
changing from QR code to ASCII

00:23:07.353 --> 00:23:12.558
character. So, text. 0s or 1s.
Now it could have been graphics,

00:23:12.558 --> 00:23:14.560
I threatened to do pixels
because that would be

00:23:14.560 --> 00:23:17.329
significantly faster it could
have been images, I'd love to

00:23:17.329 --> 00:23:20.065
see organization out there
trying to filter fortune 500

00:23:20.065 --> 00:23:23.168
logos. It could be letters,
words, phrases, whatever you

00:23:23.168 --> 00:23:26.939
choose I can adapt. In this
particular case I've chosen

00:23:26.939 --> 00:23:31.110
ASCII characters to prove it was
possible. This is client list

00:23:31.110 --> 00:23:35.281
because at this stage I no
longer need a substantial client

00:23:35.281 --> 00:23:40.052
that works up to 300 bytes, I'll
show that you. Minimal service,

00:23:40.052 --> 00:23:43.289
I indicators are compromised.
But simply some dash script or

00:23:43.289 --> 00:23:49.628
could be PHP or doesn't matter.
And demonstrates futility of QR

00:23:49.628 --> 00:23:54.266
code detection. There's the bash
code. All I need is display a

00:23:54.266 --> 00:23:59.838
counter and some data and I can
make it run. I've got particular

00:23:59.838 --> 00:24:02.942
set of font and colors because
I'm using optical character

00:24:02.942 --> 00:24:05.878
recognition. It's just for the
proof of concept you can throw

00:24:05.878 --> 00:24:10.582
that away. I've switched from a
camera to the AVA media game

00:24:10.582 --> 00:24:13.052
capture media device, anyone
that doesn't know these, so you

00:24:13.052 --> 00:24:16.755
can plug your Xbox HTMI cable,
it captures it for your replays.

00:24:16.755 --> 00:24:19.358
But it saves to a USB key that's
tiny little key at the front of

00:24:19.358 --> 00:24:27.099
that picture. This example is
designed to capture data at one

00:24:27.099 --> 00:24:33.105
kilobit per second. That will go
into speeds, I've got 19-10-80

00:24:37.876 --> 00:24:41.914
display. I'll show you example
of that shortly. My recovery

00:24:41.914 --> 00:24:45.217
runs a lot slower but it doesn't
matter what I've stolen it as is

00:24:45.217 --> 00:24:48.153
the kilobit per second. I'm
going to recover this to MP4

00:24:48.153 --> 00:24:55.361
file in Linux. Now the red room.
Last year at Black Hat, about

00:24:55.361 --> 00:24:59.064
late one night gentleman pulled
me aside I was telling him about

00:24:59.064 --> 00:25:02.501
this he said, look, seriously,
but what about the red room. My

00:25:02.501 --> 00:25:05.671
organization has a red room. We
see this thing off shore. Red

00:25:05.671 --> 00:25:08.774
room is the room that has the
secret sauce, it's got the

00:25:08.774 --> 00:25:11.477
special recipes, the place you
have to go to access certain

00:25:11.477 --> 00:25:15.781
data assets. Off shore we tend
to have rooms that classified to

00:25:15.781 --> 00:25:18.884
certain specification we put
certain physical controls around

00:25:18.884 --> 00:25:23.422
them. With variable success.
Anyway, he was focused on the

00:25:23.422 --> 00:25:26.458
red room. The rules for the red
room are device can enter the

00:25:26.458 --> 00:25:28.894
red room but has to be formatted
everything except the firmware.

00:25:28.894 --> 00:25:33.332
Which means we can get the tools
and technology in.Nd the didi

00:25:33.332 --> 00:25:37.736
advice can leave it has to be
blanked again, the question, how

00:25:37.736 --> 00:25:42.641
am I going to get that USB mass
storage out. My response to him

00:25:42.641 --> 00:25:47.446
was, well, be creative. If you
don't note the reference you'll

00:25:47.446 --> 00:25:53.685
have to watch the movie. This is
an example of that bash upload.

00:25:53.685 --> 00:25:58.557
Been given password just as
piece of content to send. I've

00:25:58.557 --> 00:26:04.696
put that bash script on the key,
just popped it in for me. What

00:26:04.696 --> 00:26:10.436
you can see on the left is
clearly a counter in binary, 0s

00:26:10.436 --> 00:26:16.642
and 1s on the right is data in
binary I'm get one bite per

00:26:16.642 --> 00:26:21.513
packet effectively. When we
decode that, you can have a look

00:26:21.513 --> 00:26:25.784
on YouTube. Now what I've got is
Linux system, I've opened the

00:26:25.784 --> 00:26:29.054
video, I'm processing it one
frame at a time now doing

00:26:29.054 --> 00:26:32.858
optical character recognition on
each frame. If you can see it, I

00:26:32.858 --> 00:26:35.194
don't know how clear it is on
those you'll see a little

00:26:35.194 --> 00:26:38.230
rainbow colored boxes floating
around the letters on the

00:26:38.230 --> 00:26:40.566
screen. That's where it's
recognized characters is

00:26:40.566 --> 00:26:44.369
attempting to process them. On
the left-hand side this is

00:26:44.369 --> 00:26:47.539
indeed bug mode every line of
password that comes out on the

00:26:47.539 --> 00:26:50.809
left you'll see another line of
it appear on the screen. That

00:26:50.809 --> 00:26:56.148
data is coming up line by line
as it's processing the video. No

00:26:56.148 --> 00:27:02.087
need for -- [ no audio ] It's so
slow. I don't care. It wasn't

00:27:16.034 --> 00:27:20.606
the point. At Christmas I got
bored I was watching "Deep space

00:27:20.606 --> 00:27:26.845
9" I think for the third time.
So I went for the pixel threat.

00:27:26.845 --> 00:27:30.649
Assumed it wouldn't be too hard,
certainly wasn't very difficult

00:27:30.649 --> 00:27:34.720
at all now what I'm doing is a
pixel at layer three, so, I'm

00:27:34.720 --> 00:27:40.659
using HGML java script. I've
left text but now if what I had

00:27:40.659 --> 00:27:46.164
that VDI in the environment or
web browser I can now encode

00:27:46.164 --> 00:27:51.637
data visually and send it back
out. It uses about 20K, that's

00:27:51.637 --> 00:27:56.942
now about 30K of java script. It
feels big to be clientless

00:27:56.942 --> 00:28:01.146
that's just a single file and
HTML you can plug in a key and

00:28:01.146 --> 00:28:03.582
upload the whole thing. Again,
demonstrates futility of

00:28:03.582 --> 00:28:11.023
targeting a specific
implementation. Now I tried the

00:28:11.023 --> 00:28:15.160
same box, this is -- 1.3
megabits per second now using

00:28:15.160 --> 00:28:18.864
two frames per second one bit
per pixel this is simply black

00:28:18.864 --> 00:28:25.304
or white. That's $120 box. The
Ava media I'm using 12 by 720 at

00:28:25.304 --> 00:28:29.641
60 frames her second. As you'll
see, we recover at the same way.

00:28:29.641 --> 00:28:33.245
Slightly different encoding.
That's me plugging in the key

00:28:33.245 --> 00:28:38.050
and typing in the client. This
is a web browser at the moment

00:28:38.050 --> 00:28:43.221
it's Firefox it works in chrome
with F11 mode it's full screen.

00:28:43.221 --> 00:28:46.058
I'm doing a local file upload to
the browser itself so the java

00:28:46.058 --> 00:28:50.996
script can process the file. And
that's what the data looks like

00:28:50.996 --> 00:28:56.969
in black and white. Looks like
just a static TV, right? I'm

00:28:56.969 --> 00:29:01.173
going to let this one run so you
can see the progress actually

00:29:01.173 --> 00:29:07.045
counts upment speed as well. The
content of this file is the 5.5

00:29:07.045 --> 00:29:12.517
megabyte I wrote last year on
TGFX. That file has been

00:29:12.517 --> 00:29:17.255
uploaded, that was 1.37 megabits
per second. Easy enough to do.

00:29:17.255 --> 00:29:21.426
Downloading is the problem. Here
I've got the same program

00:29:21.426 --> 00:29:23.762
framework only I've ditched all
the optical character

00:29:23.762 --> 00:29:27.266
recognition on the left you can
see the line by line frame

00:29:27.266 --> 00:29:31.203
marking, that is each individual
frame of this video and what

00:29:31.203 --> 00:29:34.439
I've taken away from it. This is
debug output. First thing you'll

00:29:34.439 --> 00:29:39.478
see I upload the big red box.
Allows my software to locate the

00:29:39.478 --> 00:29:43.348
region on the screen that
contains the packet. So I can

00:29:43.348 --> 00:29:49.688
find layer three. There it's
found it. Then what we'll do is

00:29:49.688 --> 00:29:52.824
every single -- control messages
going past that we can't see.

00:29:52.824 --> 00:29:57.262
We've got those now. There's
full screen of data. Now,

00:29:57.262 --> 00:30:01.933
there's a CRC in this protocol
you can see this 20 lines before

00:30:01.933 --> 00:30:04.603
successful line before
successful frame that we've

00:30:04.603 --> 00:30:08.206
miscalculated we haven't got
full data. As the over media

00:30:08.206 --> 00:30:12.577
captures you have about 50%
through this transfer you'll see

00:30:12.577 --> 00:30:16.882
that the picture starts to Res
up it's like it takes ten or 12

00:30:16.882 --> 00:30:20.218
frames to completely capture I
think there's internal bit rate

00:30:20.218 --> 00:30:23.422
in this. You'll see loads of CRC
errors before we get the one

00:30:23.422 --> 00:30:28.226
frame that works. In the bottom
corner you can see the PDF

00:30:28.226 --> 00:30:33.899
slowly being restored from this
file transfer. Now I'm getting

00:30:33.899 --> 00:30:37.202
more errors, there's loads of
errors I'm also going a full

00:30:37.202 --> 00:30:42.941
updated frame. A full updated
packet. Before I get a valid

00:30:42.941 --> 00:30:46.678
packet. If I push this one more
frame per second faster it's not

00:30:46.678 --> 00:30:52.684
successful. Ticking, ticking,
that's transferring. Very close

00:30:56.488 --> 00:31:01.393
to not successfully recovering
each individual frame. Almost

00:31:01.393 --> 00:31:07.399
complete. And the last packet
will be the CRC 32. That's

00:31:14.206 --> 00:31:18.577
successful. That's a big list of
CRC 32 validations on the file.

00:31:18.577 --> 00:31:25.283
There's the PDF. [ Applause ]
But that's not good enough for

00:31:25.283 --> 00:31:32.557
DEF CON. That's what I had when
I submitted to DEF CON I

00:31:32.557 --> 00:31:35.460
thought, this is pitiful. I'll
show you why this should be

00:31:35.460 --> 00:31:40.999
substantially higher. For $30
more you can get professional

00:31:40.999 --> 00:31:43.702
capture card, unfortunately I
didn't read the fine print this

00:31:43.702 --> 00:31:47.639
is YUV capture card even though
RGB data source is one bit per

00:31:47.639 --> 00:31:50.876
pixel without getting whole lot
of mess. However, by being a

00:31:50.876 --> 00:31:55.347
better card I can do eight
frames per second that works out

00:31:55.347 --> 00:32:01.052
to 4.7 megabits per second. Same
resolution, same packet size,

00:32:01.052 --> 00:32:05.123
100 kilobytes per frame. So the
low price of ten times that

00:32:05.123 --> 00:32:11.163
much, you can buy the 4K extreme
4G this thing designed to

00:32:11.163 --> 00:32:16.401
capture realtime, 60 frames per
second, 4K video frames. This

00:32:16.401 --> 00:32:19.004
thing will capture the next
couple of generations of what

00:32:19.004 --> 00:32:25.210
you're VPN users will use. Same
resolution. QR but in and out

00:32:25.210 --> 00:32:29.581
three bits per pixel, ten frames
per second. So I'm up to 300

00:32:29.581 --> 00:32:33.652
kilobytes per packet. And a
total of 12.1 megabits per

00:32:33.652 --> 00:32:38.623
second in the demo. Only reason
why I'm not showing you today a

00:32:38.623 --> 00:32:43.295
one gigabit transfer because I
couldn't properly pass the AVI

00:32:43.295 --> 00:32:47.999
file. FFM peg came closest to
converting the file I was able

00:32:47.999 --> 00:32:52.237
to get the three bits per pixel
reliably. I couldn't get ten

00:32:52.237 --> 00:32:55.841
bits per pixel reliably. Which
this card will capture but I

00:32:55.841 --> 00:33:00.512
couldn't convert. This is where
I've left it. That's the same

00:33:00.512 --> 00:33:06.518
file with this card capturing
it. Let's recover that file. You

00:33:11.456 --> 00:33:13.992
can see I've already captured
the frame. Resize this picture

00:33:13.992 --> 00:33:17.529
fast enough. There's the
control. You'll note that there

00:33:17.529 --> 00:33:21.099
are only two CRC only two times
I didn't correctly get the frame

00:33:21.099 --> 00:33:27.038
with this capture card. That was
12 megabits per second.

00:33:29.241 --> 00:33:31.877
Architecture, look, we need to
leave out the PP example. The

00:33:31.877 --> 00:33:35.680
PPP example is not part of the
solution. Because it requires

00:33:35.680 --> 00:33:38.984
privilege. Require privilege to
set up interface on system, to

00:33:38.984 --> 00:33:42.988
leave that aside before we had
that we already had PCP socket

00:33:42.988 --> 00:33:46.925
was working between two nodes.
Just having a bit of fun. But

00:33:46.925 --> 00:33:49.594
important thing to note the
technologies I've shown you do

00:33:49.594 --> 00:33:53.798
nothing for privilege. They can
only do exactly what your users

00:33:53.798 --> 00:33:57.769
can do today. What you can type
and read is what I can type and

00:33:57.769 --> 00:34:00.205
read. I haven't changed
privilege at all. Distinct

00:34:00.205 --> 00:34:03.074
properties of the delta seem to
be along volume, accuracy,

00:34:03.074 --> 00:34:06.444
structure and utility and the
paper goes into a few views on

00:34:06.444 --> 00:34:11.182
that in the cat and mouse games
that you can play on that. The

00:34:11.182 --> 00:34:15.120
problem we have in Australia, in
the Australia privacy act and I

00:34:15.120 --> 00:34:20.425
believe -- there's a distinction
drawn between use and

00:34:20.425 --> 00:34:26.097
disclosure. It's considered use
and safe if the user comes into

00:34:26.097 --> 00:34:28.133
your system, into your
environment and works with the

00:34:28.133 --> 00:34:31.269
data in your system. That is
considered to remain in the off

00:34:31.269 --> 00:34:34.806
shore case that data remains on
shore. It's not off shore. Even

00:34:34.806 --> 00:34:37.509
though the screen is displaying
it that's use. Haven't left your

00:34:37.509 --> 00:34:42.113
system. Disclosure however when
that data is taken from that

00:34:42.113 --> 00:34:44.616
system, taken off shore and user
can do whatever they want with

00:34:44.616 --> 00:34:47.886
it. Obviously tools that I've
presented today are designed to

00:34:47.886 --> 00:34:51.890
completely destroy that barrier.
But I haven't done anything with

00:34:51.890 --> 00:34:55.327
the privilege on that. Now in
the Australian privacy act, if

00:34:55.327 --> 00:34:58.930
the data is taken off shore,
Australian entity is actually

00:34:58.930 --> 00:35:02.167
liable for that data going off
shore if they didn't take

00:35:02.167 --> 00:35:04.736
reasonable steps and the only
one of these steps that seems to

00:35:04.736 --> 00:35:08.006
make any sense in this context
is monitoring. The questions

00:35:08.006 --> 00:35:14.679
what is reasonable monitoring.
In 1973 I wrote a note on

00:35:14.679 --> 00:35:19.884
confinement problem, brilliant.
Brilliant work. His conclusion

00:35:19.884 --> 00:35:22.187
was, at the time they were all
looking at multi-user systems

00:35:22.187 --> 00:35:25.757
and trying trying to provide
levels of difference between

00:35:25.757 --> 00:35:29.394
clearance, not being able to
leak data, his conclusion was it

00:35:29.394 --> 00:35:34.599
probably cheaper if possible at
all to just to leave it -- to

00:35:34.599 --> 00:35:40.105
accept the risk. For this type
of problem. His work was rolled

00:35:40.105 --> 00:35:46.411
up in to the TCC specification.
For B and B3 trusted systems.

00:35:46.411 --> 00:35:50.482
The conclusion that document
came to was that a hundred bit

00:35:50.482 --> 00:35:54.786
per second data leak or hundred
bits per second was considered a

00:35:54.786 --> 00:36:01.159
high leak. Because a hundred was
valid terminal. If you had valid

00:36:01.159 --> 00:36:05.397
terminal that was leaking at the
speed of a valid terminal, then

00:36:05.397 --> 00:36:08.600
they can't possibly be secure.
Now, out of all the example I've

00:36:08.600 --> 00:36:14.239
given you today, none ran under
a hundred bits per second. Not

00:36:14.239 --> 00:36:17.609
one. Including text one that
will run through SSH. HTMI at

00:36:17.609 --> 00:36:23.615
1920 by 1080. By 24 bits per
pixel faster than a gigabit. In

00:36:30.688 --> 00:36:36.261
terms of acceptability. The TCC
spec said that the maximum

00:36:36.261 --> 00:36:42.901
bandwidth accept for is one bit
per second. And any covert

00:36:42.901 --> 00:36:47.705
channel that was above one bit
in ten seconds had to be

00:36:47.705 --> 00:36:51.543
auditable. So if you are in your
environment today, the question

00:36:51.543 --> 00:36:56.114
I put to you today is, do you
have the ability to see every

00:36:56.114 --> 00:37:01.553
single key change, caps lock
light change, pixel change, any

00:37:01.553 --> 00:37:04.756
delta in your environment that
runs faster than a tenth of a

00:37:04.756 --> 00:37:10.628
bit per second. Not in any
organization I've known. The

00:37:10.628 --> 00:37:13.465
business impact. I'm going to
refer to example from April this

00:37:13.465 --> 00:37:17.402
year here in theist, the FCC
went after AT&T because if I

00:37:17.402 --> 00:37:21.740
remember correctly their off
shore centers in Mexico,

00:37:21.740 --> 00:37:25.810
Colombia and the Philippines
lost 280 --> 000 records. The

00:37:25.810 --> 00:37:30.115
lawsuit settled at 25 million.
Which was then reported as the

00:37:30.115 --> 00:37:36.187
fine. If I took one of those
users off shore, that works out

00:37:36.187 --> 00:37:40.125
to about in rough numbers, $89 a
record. Per personal record

00:37:40.125 --> 00:37:44.162
lost. If I took one of those
users working today with A4 page

00:37:44.162 --> 00:37:49.868
I'm writing down whole records,
two kilobytes per record, full

00:37:49.868 --> 00:37:55.140
bits, eight bits. That works out
to -- a thousand words a day,

00:37:55.140 --> 00:38:01.045
five kilobytes a day. The worst
damage I could do to you in four

00:38:01.045 --> 00:38:05.350
business days would be ten
records. Multiple output by ten,

00:38:05.350 --> 00:38:10.021
still talking less than $10 --> 000,
still less than 100 users stole

00:38:10.021 --> 00:38:14.325
in in four business days.
Assuming the FCC doesn't give

00:38:14.325 --> 00:38:18.830
bulk discounts then what we've
done in the last 45 minutes is

00:38:18.830 --> 00:38:25.270
take that to 12.1 megabits per
second. I'm now moving in the

00:38:25.270 --> 00:38:30.842
same grid of time, 87 million
records with a cost to the U.S.

00:38:30.842 --> 00:38:35.346
organization of almost $8
billion in fines. But I don't

00:38:35.346 --> 00:38:39.517
have to work in business days
because they're just business

00:38:39.517 --> 00:38:45.356
days. They're eight hour days, I
can now work in 24 hour days, I

00:38:45.356 --> 00:38:50.361
can start this transfer at 9:00
this morning pick up the results

00:38:50.361 --> 00:38:55.366
at 5:00 tomorrow afternoon when
I go home. In terms of 24-hour

00:38:55.366 --> 00:38:59.938
days we now talking about one
fifth of the U.S. population

00:38:59.938 --> 00:39:05.310
being able to be downloaded per
24 hour day of fine around $6

00:39:05.310 --> 00:39:10.315
billion per day. And that would
be entire U.S. pinched in one

00:39:10.315 --> 00:39:15.320
week or Australia in eight
hours. [ no audio ] Once it's

00:39:15.320 --> 00:39:19.891
been displayed it's been
uploaded to the room. So far as

00:39:19.891 --> 00:39:23.228
off shoring, right sourcing,
Bestshoring, whatever you want

00:39:23.228 --> 00:39:29.067
to call it if you -- as a name
for remote access for untrusted

00:39:29.067 --> 00:39:34.472
users to trusted data on shore,
if you want your data to be

00:39:34.472 --> 00:39:39.477
yours and yours alone then this
is not currently an unlikely to

00:39:39.477 --> 00:39:43.348
ever be safe. I'd like you all
to consider how many bits per

00:39:43.348 --> 00:39:49.354
second data loss is too many to
accept. Thank you very much.

00:39:55.293 --> 00:39:57.595
[Applause]

