00:00:00.334 --> 00:00:02.769
Welcome to the early morning
shift. Thanks everybody for

00:00:02.769 --> 00:00:06.440
showing up. For the half of you
that are not hung over I hope

00:00:06.440 --> 00:00:09.343
you enjoy the talk. For the half
of you that are hung over, we're

00:00:09.343 --> 00:00:11.578
going to try to talk really,
really softly so you don't hurt

00:00:11.578 --> 00:00:18.218
your head. This is abusing Adobe
readers JavaScript API's. We've

00:00:18.218 --> 00:00:20.687
got a lot to cover so we're
going to start getting going

00:00:20.687 --> 00:00:25.826
right away. A quick agenda of
what we're going to be doing.

00:00:25.826 --> 00:00:27.828
We're going to introduce
ourselves, talk about ourselves

00:00:27.828 --> 00:00:30.397
for about 45 minutes and we'll
go over the content the last

00:00:30.397 --> 00:00:34.568
five minutes, it will be great.
We've been doing a lot of

00:00:34.568 --> 00:00:38.038
research on Adobe reader over
the last six months and trying

00:00:38.038 --> 00:00:40.040
to under understand the attack
surface and what we're going to

00:00:40.040 --> 00:00:43.610
show you is an overview of the
attack service that most people

00:00:43.610 --> 00:00:47.548
don't know about and what you
can do with it. We're going to

00:00:47.548 --> 00:00:50.884
talk about how you can find
these vulnerabilities themselves

00:00:50.884 --> 00:00:54.021
and how you put it all together
and chain the various bugs that

00:00:54.021 --> 00:00:57.791
you need. For remote execution
on Adobe reader. First we'll

00:00:57.791 --> 00:01:05.732
introduce ourselves. My name is
Brian Gorenc. I'm the manager of

00:01:05.732 --> 00:01:08.535
vulnerability research inside of
HPC security research

00:01:08.535 --> 00:01:12.005
organization. I run a program
called the zero day initiative

00:01:12.005 --> 00:01:14.741
which is the world's largest and
one of the oldest vendor

00:01:14.741 --> 00:01:18.111
agnostic bug bounty problems.
We're entering our tenth year

00:01:18.111 --> 00:01:25.419
and we spent over $10 million on
bugs over these last years. We

00:01:25.419 --> 00:01:31.024
do -- I work with researchers
around the world to procure

00:01:31.024 --> 00:01:34.795
vulnerabilities, and send them
to vendors to get them fixed.

00:01:34.795 --> 00:01:37.197
Sometimes they fix them,
sometimes they don't and we have

00:01:37.197 --> 00:01:39.933
a long history of making sure
everybody is aware of the

00:01:39.933 --> 00:01:42.736
vulnerabilities that we
purchase. I also organize the

00:01:42.736 --> 00:01:47.274
ever-popular hacking competition
which just this last year game

00:01:47.274 --> 00:01:50.243
away almost $1 million for
exploits against the hardest

00:01:50.243 --> 00:01:55.716
attack surfaces out there in the
industry and we had one

00:01:55.716 --> 00:02:00.020
individual win $250 --> 000 for
three exploits this year. I got

00:02:00.020 --> 00:02:03.123
to work with Jasiel and Abdul
back here along with several

00:02:03.123 --> 00:02:06.293
members of my team are working
on the Adobe research project

00:02:06.293 --> 00:02:10.497
that we were doing and I'll let
them introduce themselves. >>

00:02:10.497 --> 00:02:16.269
Hello. I'm Abdul. I'm a security
researcher working for the zero

00:02:16.269 --> 00:02:20.407
day initiative program. Been
working for them for a little

00:02:20.407 --> 00:02:24.878
bit more than two years. I do a
lot of root cause analysis, bug

00:02:24.878 --> 00:02:29.516
hunting and exploit development.
And recently I have been

00:02:29.516 --> 00:02:34.154
operating reader in a regime of
high memory pressure.

00:02:34.154 --> 00:02:39.626
(Laughter.) >> I'm Jasiel and I
prefer to go by wandering

00:02:39.626 --> 00:02:42.929
glitch. I also work at ZDI,
spend a fair amount of time on

00:02:42.929 --> 00:02:46.466
root causing vulnerabilities and
using what I learn to augment my

00:02:46.466 --> 00:02:49.736
own vulnerability discovery in
exploit development and I use

00:02:49.736 --> 00:02:52.205
python assembly to prevent
people from operating high

00:02:52.205 --> 00:02:55.876
pressure memory. And if that
doesn't make any sense you

00:02:55.876 --> 00:03:01.048
should check out the ZDI
blackout talk. >> So we've done

00:03:01.048 --> 00:03:03.817
a lot of research over the past
year as well in Internet

00:03:03.817 --> 00:03:07.320
explorer so that's a good paper
to read. So we also do a lot of

00:03:07.320 --> 00:03:10.357
research and you can see it here
on the slides, some of that

00:03:10.357 --> 00:03:12.793
research that we've done. These
are all of the bugs that we've

00:03:12.793 --> 00:03:16.296
discovered in Adobe reader since
we've started this research back

00:03:16.296 --> 00:03:20.901
in December 2014. Like I said we
do a lot of internal research.

00:03:20.901 --> 00:03:24.938
We started researching it back
about six, seven months ago to

00:03:24.938 --> 00:03:28.809
get an understanding of how it
work. We've discovered it's

00:03:28.809 --> 00:03:32.646
about 91 vulnerabilities in fact
we found or at least Abdul found

00:03:32.646 --> 00:03:36.616
one on the plane. So we'll be
submitting that -- yeah, true

00:03:36.616 --> 00:03:40.053
story. It really covers the
whole spectrum of

00:03:40.053 --> 00:03:43.623
vulnerabilities that exist in
the product itself but the

00:03:43.623 --> 00:03:47.227
majority of these things that
you see on the slide are what we

00:03:47.227 --> 00:03:51.998
call JavaScript API restriction
bypasses. So we'll go into

00:03:51.998 --> 00:03:57.637
detail about what that is and
how they occur and what you can

00:03:57.637 --> 00:04:02.776
do with them. So before we get
start, we kind of want to call

00:04:02.776 --> 00:04:05.045
out some prior research that if
you are going to spent a lot of

00:04:05.045 --> 00:04:08.348
time looking at JavaScript APIs
and what you can do with them.

00:04:08.348 --> 00:04:15.755
The first is a set of research
from back in 2014 and he was the

00:04:15.755 --> 00:04:18.525
researcher to highlight the
restriction bypasses and he goes

00:04:18.525 --> 00:04:23.330
into detail about how all of it
works and he provides you a

00:04:23.330 --> 00:04:27.534
proof of concept that will allow
you to bypass the restrictions

00:04:27.534 --> 00:04:31.338
that we'll talk about and
disclose information on a box

00:04:31.338 --> 00:04:35.142
that he can read files off of a
computer and send them out to a

00:04:35.142 --> 00:04:38.011
server using this restriction
bypass. And it really is

00:04:38.011 --> 00:04:41.414
required reading, in my opinion,
to get started in this research

00:04:41.414 --> 00:04:43.817
and hopefully our paper will
also be required reading when

00:04:43.817 --> 00:04:48.822
it's done. There was also a
presentation released by MWR

00:04:48.822 --> 00:04:52.492
labs where they asked the
question why bother basically

00:04:52.492 --> 00:04:55.529
auditing popular software. And
that's a good question most of

00:04:55.529 --> 00:04:59.399
the researchers out there kind
of are scared to go after some

00:04:59.399 --> 00:05:02.536
of these bigger pieces of
software thinking that all the

00:05:02.536 --> 00:05:05.906
low-hanging fruit is gone, but
as you can see from the previous

00:05:05.906 --> 00:05:08.842
slide you can find a lot of bugs
if you start looking at the

00:05:08.842 --> 00:05:11.878
software and reading the
research that's out there and

00:05:11.878 --> 00:05:15.248
they provide a nice overview of
the attack surface and all the

00:05:15.248 --> 00:05:18.451
attack vectors that are
available in Adobe reader and

00:05:18.451 --> 00:05:21.354
highlighted and also highlighted
the JavaScript restriction

00:05:21.354 --> 00:05:27.460
bypass bugs. So this research
like I said started in December

00:05:27.460 --> 00:05:30.931
2014. And the reason we started,
because honestly we were not

00:05:30.931 --> 00:05:33.066
getting a lot of Adobe reader
bugs. We knew that they were

00:05:33.066 --> 00:05:36.503
being used so we want to get a
better understanding of what

00:05:36.503 --> 00:05:40.240
existed in this product and how
it could be leveraged. And we

00:05:40.240 --> 00:05:43.476
basically hit every type of bug
that -- probably every CWE that

00:05:43.476 --> 00:05:48.882
exists, right? We took a varied
approach when doing this

00:05:48.882 --> 00:05:51.885
auditing. First we started out
writing a bunch of fuzzers, we

00:05:51.885 --> 00:05:54.921
followed up with binary
analysis, we released a blog

00:05:54.921 --> 00:05:58.091
recently about a privilege
escalation that existed in the

00:05:58.091 --> 00:06:00.160
shared memory region. We did
some code analysis on the

00:06:00.160 --> 00:06:03.897
JavaScript APIs and we trained
each other internally trying to

00:06:03.897 --> 00:06:11.671
find as many bugs as possible
with the main goal of trying to

00:06:11.671 --> 00:06:16.977
kill off as much as possible.
Because we do purchase bugs, so

00:06:16.977 --> 00:06:19.579
the more that we kill, the
better that it is for us, money

00:06:19.579 --> 00:06:24.551
wise. Internal discoveries we
found basically every type. Use

00:06:24.551 --> 00:06:28.822
after freeze memory leaks, use
after freeze privilege

00:06:28.822 --> 00:06:32.692
escalations, logic bugs,
sandboxes you name it, we found

00:06:32.692 --> 00:06:37.030
it. So we specifically we're
looking at the JavaScript API's

00:06:37.030 --> 00:06:41.034
today which offer a rich set of
functionality for document

00:06:41.034 --> 00:06:46.306
authors. These allow you to
process forms, control

00:06:46.306 --> 00:06:49.743
multimedia events, do
communication with databases,

00:06:49.743 --> 00:06:55.749
basically all there to give end
users really a lot of options to

00:06:55.749 --> 00:06:59.185
make complex documents. But it's
also a perfect avenue for

00:06:59.185 --> 00:07:03.089
attackers if they think outside
of the box, you're able to kind

00:07:03.089 --> 00:07:06.660
of leverage these weaknesses
within these APIs to do a lot of

00:07:06.660 --> 00:07:10.297
interesting stuff. There are
mitigations that are built into

00:07:10.297 --> 00:07:14.167
the APIs and we're going to talk
about those right now. It's this

00:07:14.167 --> 00:07:18.571
idea of privileged versus
non-privileged methods. Some of

00:07:18.571 --> 00:07:23.009
the APIs that exist have
security restrictions on them

00:07:23.009 --> 00:07:25.512
and it can only be executed in
what's called a privileged

00:07:25.512 --> 00:07:30.083
context. So what exactly is a
privileged context? A privileged

00:07:30.083 --> 00:07:33.787
context is really three points
within Adobe reader. One is when

00:07:33.787 --> 00:07:39.793
you're compute -- executing at
the console. Then there's the

00:07:41.962 --> 00:07:44.931
batch processing and during
application initialization

00:07:44.931 --> 00:07:46.933
events and if you're trusting
the document certificate is when

00:07:46.933 --> 00:07:49.369
you can actually used these
privileged and security

00:07:49.369 --> 00:07:53.606
restricted APIs. For example,
non-privileged API would be

00:07:53.606 --> 00:07:57.110
things that could be processed
within the doc context. An

00:07:57.110 --> 00:08:01.114
example of a privileged APA is
what you see on the slide which

00:08:01.114 --> 00:08:06.853
is launch URL. This is not
supposed to be executed from the

00:08:06.853 --> 00:08:13.126
doc context and only be executed
when you're doing some sort of

00:08:13.126 --> 00:08:16.062
automation. If you try to
execute a security-restricted

00:08:16.062 --> 00:08:21.101
API from a doc context, you're
going to get a security warning

00:08:21.101 --> 00:08:26.272
and you'll see that in action
shortly when we try to execute

00:08:26.272 --> 00:08:30.276
one of these APIs from the doc
context. It will pop up to the

00:08:30.276 --> 00:08:33.146
user. If you're an exploiter,
you don't want that to happen.

00:08:33.146 --> 00:08:40.387
You want to kind of remove that
obstacle from your exploit.

00:08:40.387 --> 00:08:43.256
There's also the idea of trusted
functions. And this is where

00:08:43.256 --> 00:08:46.393
you're trying to execute
privileged functionality from a

00:08:46.393 --> 00:08:50.030
nonprivileged context. Why would
you want to do that? In certain

00:08:50.030 --> 00:08:54.701
cases you need those privileged
functions for your workflow. You

00:08:54.701 --> 00:08:57.170
need to launch URL for some
reason during your batch

00:08:57.170 --> 00:09:01.074
processing so you do this using
what's called a trusted function

00:09:01.074 --> 00:09:05.078
or app trusted function. You can
see that on the slide there.

00:09:05.078 --> 00:09:08.815
Hopefully you can see it in the
back. That AN verified comments

00:09:08.815 --> 00:09:13.353
is actually a trusted function.
And the -- in this function

00:09:13.353 --> 00:09:19.092
you're going to leverage the
privileged APIs. This idea of a

00:09:19.092 --> 00:09:24.631
code block, where you've got app
begin priv and app end priv and

00:09:24.631 --> 00:09:29.469
you can actually execute these
privileged APs. You can see on

00:09:29.469 --> 00:09:36.076
these slides. We're going to use
this later on when we're

00:09:36.076 --> 00:09:39.245
actually looking for a privilege
escalation. Not this exact one,

00:09:39.245 --> 00:09:43.550
but that idea. There's also the
idea of a folder level scripts.

00:09:43.550 --> 00:09:46.920
A folder level scripts are
available to end users for when

00:09:46.920 --> 00:09:51.691
they want to use -- when they
want to use them for automation

00:09:51.691 --> 00:09:53.693
purposes and they want to use
those trusted functions and

00:09:53.693 --> 00:09:58.631
leverage those privileged APIs.
So these are available in Adobe

00:09:58.631 --> 00:10:05.038
reader and you can put a set of
JavaScript in the JavaScript

00:10:05.038 --> 00:10:07.941
folder. As you can see on the
screen we kind of show it. And

00:10:07.941 --> 00:10:11.144
in that folder you're going to
put your scripts and they'll be

00:10:11.144 --> 00:10:15.014
available to you in the doc
context when Adobe reader is

00:10:15.014 --> 00:10:17.717
loaded. And in there you can
actually implement trusted

00:10:17.717 --> 00:10:22.622
functions and use those
privileged APIs. Luckily for us,

00:10:22.622 --> 00:10:28.828
Adobe provides us a set of
JavaScript APIs and you can see

00:10:28.828 --> 00:10:35.268
them on the slide. Inside of
there there's a set of APIs on

00:10:35.268 --> 00:10:40.206
that do use those trusted
functions. This will be loaded

00:10:40.206 --> 00:10:46.146
up inside root and exposed to
the doc when the document is

00:10:46.146 --> 00:10:51.718
opened. So what you see here is
an example of what that code

00:10:51.718 --> 00:10:53.853
looks like. You can actually --
that is actually compiled spider

00:10:53.853 --> 00:11:01.094
monkey XDR bite code. One of the
best parts about the research

00:11:01.094 --> 00:11:07.534
back in the day was that he
actually provided us a

00:11:07.534 --> 00:11:11.171
decompiler. So you can actually
decompile this by code and get

00:11:11.171 --> 00:11:13.273
the code off of that hub
location and that's where you

00:11:13.273 --> 00:11:17.677
want to start. You're going to
decompile that by code and

00:11:17.677 --> 00:11:21.014
you're going to find interesting
trusted functions in there. So

00:11:21.014 --> 00:11:23.216
when it's actually decompiled
it's pretty messy so you want to

00:11:23.216 --> 00:11:26.553
pass it through a beautifying
process so you can actually read

00:11:26.553 --> 00:11:32.358
the code and you can see here an
example of the color convert

00:11:32.358 --> 00:11:36.963
function. That's inside of
there, about 27 --> 000 lines of

00:11:36.963 --> 00:11:41.134
JavaScript within this bin. And
this is your place to start

00:11:41.134 --> 00:11:45.672
auditing. So if we think about
this for a second, and we are

00:11:45.672 --> 00:11:50.076
going to be auditing this code,
and how are we going to actually

00:11:50.076 --> 00:11:52.979
leverage an attack, we need to
kind of -- we want to be able to

00:11:52.979 --> 00:11:57.717
execute some sort of privileged
API from within the doc context.

00:11:57.717 --> 00:12:00.887
You want to be able to reach
these functions that Adobe

00:12:00.887 --> 00:12:04.591
considers security restricted
just from within the document.

00:12:04.591 --> 00:12:07.060
This is not something that they
normally allow, so what we're

00:12:07.060 --> 00:12:10.463
going to do now in a couple of
seconds here is we're going to

00:12:10.463 --> 00:12:14.601
show you how to go through this
code and find these

00:12:14.601 --> 00:12:17.704
vulnerabilities and chain them
together so that you can do some

00:12:17.704 --> 00:12:25.578
interesting things. So before we
look at how we managed to find

00:12:25.578 --> 00:12:27.814
these, you first have to
understand there are few places

00:12:27.814 --> 00:12:30.249
in JavaScript as part of the
language itself that will

00:12:30.249 --> 00:12:33.152
implicitly cull functions. So if
you look at this snippet of

00:12:33.152 --> 00:12:40.026
code, it takes an argument
called argument and there are

00:12:40.026 --> 00:12:43.329
three places here, we are
potentially unexpectedly calling

00:12:43.329 --> 00:12:46.866
a function. The first is in the
if conditional, and that can

00:12:46.866 --> 00:12:52.872
potentially either retrieve that
property or could execute a

00:12:54.974 --> 00:12:59.278
getter or accessor method if one
is defined. The second is within

00:12:59.278 --> 00:13:03.683
the app dot alert you're adding
arguments to a string so if the

00:13:03.683 --> 00:13:08.388
argument is not a string then to
string has to be called on it.

00:13:08.388 --> 00:13:11.824
And the last one is right after
the if and that's where we're

00:13:11.824 --> 00:13:15.528
setting a value on argument dot
attribute and in that case we

00:13:15.528 --> 00:13:19.866
would be either replacing that
property or calling the setter

00:13:19.866 --> 00:13:24.937
or mutator method. And this will
be viable in a couple of slides

00:13:24.937 --> 00:13:29.008
and the main thing to note here
is that we can use this to

00:13:29.008 --> 00:13:32.311
replace properties or just
execute code within a

00:13:32.311 --> 00:13:36.382
potentially different context.
For the next couple of slides we

00:13:36.382 --> 00:13:38.885
essentially have the set-up in
the last two lines where we have

00:13:38.885 --> 00:13:42.088
some object that has some
attributes set to a value.

00:13:42.088 --> 00:13:45.992
That's done before we ever get
any control, and that's

00:13:45.992 --> 00:13:49.128
essentially out of our hands.
What we do have control over is

00:13:49.128 --> 00:13:53.366
the empty line under it as well
as the cull function so the next

00:13:53.366 --> 00:13:57.470
two slides will basically be
replacing that empty line. So

00:13:57.470 --> 00:14:00.440
the first is define getter and
define setter with two

00:14:00.440 --> 00:14:04.110
underscores before and after
them. The way both of these work

00:14:04.110 --> 00:14:08.047
is you cull this function on any
object and give it two

00:14:08.047 --> 00:14:11.084
arguments. The first is the
property name and the second is

00:14:11.084 --> 00:14:13.953
a function that will actually
return the value. And define

00:14:13.953 --> 00:14:17.390
getter's case you can use this
to overload and essentially

00:14:17.390 --> 00:14:20.960
replace an attribute that may
already exist even if that

00:14:20.960 --> 00:14:24.997
attribute doesn't let you
override it. You can also

00:14:24.997 --> 00:14:29.202
execute other functions or do
anything at this point. After

00:14:29.202 --> 00:14:32.405
that there is defined setter and
as you can imagine the mutator

00:14:32.405 --> 00:14:36.042
method. In this case you can do
conversions on the input

00:14:36.042 --> 00:14:42.348
argument or just deny access to
ever change that value. The

00:14:42.348 --> 00:14:46.018
other way, because this is based
on spider monkey, is to use the

00:14:46.018 --> 00:14:50.356
proto attribute. Unlike browsers
which have prototype, this only

00:14:50.356 --> 00:14:54.227
has proto with two underscores
before and after. And in this

00:14:54.227 --> 00:14:57.163
case all you're doing is
creating a dictionary with

00:14:57.163 --> 00:15:01.367
updated keys and updated values.
And then setting proto to the

00:15:01.367 --> 00:15:05.505
original object such that when
anything tries to access a

00:15:05.505 --> 00:15:08.174
preexisting attribute it will
fall through and still access

00:15:08.174 --> 00:15:10.843
it. But when it tries to access
the properties you care about,

00:15:10.843 --> 00:15:17.049
it will get your special value.
So as far as getting system

00:15:17.049 --> 00:15:19.986
level execution, and by system
level I mean within the root

00:15:19.986 --> 00:15:23.723
context, which is a more
privileged context, you have to

00:15:23.723 --> 00:15:27.260
somehow execute arbitrary
JavaScript within -- outside

00:15:27.260 --> 00:15:31.097
your context. The easiest way to
do that is to grip for eval. You

00:15:31.097 --> 00:15:35.501
can see there are a bunch of
results, it's less readable than

00:15:35.501 --> 00:15:41.274
I was hoping. But essentially
you have calls to eval on

00:15:41.274 --> 00:15:44.710
potentially untrusted input. The
first one there is a call to

00:15:44.710 --> 00:15:50.716
eval. And long entry is supplied
to that function and char et is

00:15:54.220 --> 00:15:57.089
a function is as the name
implies returns a character.

00:16:00.226 --> 00:16:03.629
We'll overload that and instead
replace it with a custom

00:16:03.629 --> 00:16:08.568
function so that we can execute
arbitrary code there. Once we

00:16:08.568 --> 00:16:11.804
have done that, we have to look
for ways of escalating

00:16:11.804 --> 00:16:14.674
privileges within JavaScript and
we do that by app dot begin

00:16:14.674 --> 00:16:20.079
priv. The key thing to note here
is we can't just look for app

00:16:20.079 --> 00:16:25.284
dot begin priv for every match
we find. We have to look for

00:16:25.284 --> 00:16:29.322
we're looking for a function
that's being sent to trusted

00:16:29.322 --> 00:16:33.326
function. Because if it's not
being culled from a trusted

00:16:33.326 --> 00:16:37.763
function, the user will still
get prompted. There will be a

00:16:37.763 --> 00:16:41.767
subsequent cull, and somewhere
in between there we're going to

00:16:41.767 --> 00:16:46.505
look for some sort of method
indication that we can overload.

00:16:46.505 --> 00:16:50.376
So here is an example of where
we get the system level eval.

00:16:50.376 --> 00:16:55.314
You can see the second argument
is long entry and all the way at

00:16:55.314 --> 00:16:59.819
the bottom we can see that cull
to eval. So what we can do is

00:16:59.819 --> 00:17:04.624
just set up a custom hash with a
char app that will execute the

00:17:04.624 --> 00:17:12.498
bulk of the JavaScript payload.
Here we are going to replace a

00:17:12.498 --> 00:17:14.867
-- we have a place we can
replace a property with a

00:17:14.867 --> 00:17:18.604
privilege function. This is CB
shared review security dialogue

00:17:18.604 --> 00:17:21.741
and it's a trusted function, as
you can see. Where it is being

00:17:21.741 --> 00:17:25.278
set and at the very second to
last line you can see the call

00:17:25.278 --> 00:17:29.382
to begin priv and the last line
is a call to collab so what we

00:17:29.382 --> 00:17:33.085
can do is replace the property
with app.launch URL. Since it is

00:17:33.085 --> 00:17:39.091
an input argument, it will call
it directly and we'll be able to

00:17:42.128 --> 00:17:49.869
escalate from there. So
altogether the first thing we do

00:17:49.869 --> 00:17:54.540
is set up a system level eval
and issue the bulk of our pay

00:17:54.540 --> 00:17:59.078
load. We'll replace that call so
we can call app.launch URL or

00:17:59.078 --> 00:18:06.953
any privilege call and then
we'll trigger it. And here's

00:18:06.953 --> 00:18:12.959
what it looks like. Easiest way
is probably look at the bottom.

00:18:18.965 --> 00:18:21.367
That first argument can be
ignored. That's just to hit the

00:18:21.367 --> 00:18:24.337
vulnerable code. The interesting
thing being that we're sending

00:18:24.337 --> 00:18:28.040
the O object four times and if
you look a couple of lines

00:18:28.040 --> 00:18:31.877
earlier we are setting O to have
a char at attribute where that

00:18:31.877 --> 00:18:37.883
function will return the exploit
function and then call it. The

00:18:40.519 --> 00:18:44.523
exploit function itself is
defining a getter to replace

00:18:44.523 --> 00:18:49.795
collab within the system level
context and it's calling shared

00:18:49.795 --> 00:18:56.369
dialogue to trigger it. So here
we're going to see the normal

00:18:56.369 --> 00:18:59.405
behavior, this is what it looks
like in Adobe reader DC when

00:18:59.405 --> 00:19:02.108
it's patched. And you can see
that all we're doing within the

00:19:02.108 --> 00:19:06.946
PDF is a call -- and it's
prompting the user as it's

00:19:06.946 --> 00:19:10.983
supposed to do. Whereas when we
chain everything together, we

00:19:10.983 --> 00:19:15.354
end up launching, in this case
four browsers. The reason is

00:19:15.354 --> 00:19:17.690
because we're passing that O
argument four times to the

00:19:17.690 --> 00:19:24.730
function. And that was a
privilege execution. (Applause.)

00:19:24.730 --> 00:19:30.703
So here in the vulnerable
version, this is what the

00:19:30.703 --> 00:19:34.040
JavaScript debugger looks like.
It's a little weird to read.

00:19:34.040 --> 00:19:38.210
Basically the first line and
every other line after that is

00:19:38.210 --> 00:19:41.881
where we are executing
JavaScript. So we're executing

00:19:41.881 --> 00:19:44.884
collab and it's telling us it's
a collab object. On the third

00:19:44.884 --> 00:19:50.222
line we're replacing collab and
setting it to app. On the fifth

00:19:50.222 --> 00:19:53.726
line it's saying let's access
collab again and it's being

00:19:53.726 --> 00:19:57.496
returned to the app object and
we replacing it and that's

00:19:57.496 --> 00:20:02.568
persisting. In the Adobe reader
after the patch we're doing the

00:20:02.568 --> 00:20:05.971
same thing you only the last
line is now changed, it's no

00:20:05.971 --> 00:20:08.541
longer persisting it's staying
as collab because they've

00:20:08.541 --> 00:20:13.646
blocked our ability to replace
that object. So all in all in

00:20:13.646 --> 00:20:18.751
order to execute privileged API,
we get to execution within the

00:20:18.751 --> 00:20:23.122
system level context by finding
those evals and within the block

00:20:23.122 --> 00:20:26.459
that we're going to execute that
eval we replace the property

00:20:26.459 --> 00:20:29.595
that we can call some privileged
API. Abdul is about to go over

00:20:29.595 --> 00:20:35.601
another set that works out
better for full RC. All right.

00:20:42.908 --> 00:20:46.679
So this whole bypass stuff is
awesome. So let's go back -- can

00:20:46.679 --> 00:20:52.685
you hear me now? All right. So
going back, in the advisory,

00:20:57.256 --> 00:21:00.760
Adobe stated that this bug
basically leads to information

00:21:00.760 --> 00:21:05.731
disclosure. And that's cool. So
we knew 245 we were able to leak

00:21:05.731 --> 00:21:09.869
information out of this bug,
extract information and send it

00:21:09.869 --> 00:21:12.905
to whatever server we want but
we still needed to take this to

00:21:12.905 --> 00:21:16.542
the next level if it was
possible. So you guys can

00:21:16.542 --> 00:21:19.111
imagine if you were able to
actually get RC out of this

00:21:19.111 --> 00:21:22.214
stuff. Like it's just logical
JavaScript stuff. No memory

00:21:22.214 --> 00:21:26.318
corruption. It's just freaking
awesome. So the main challenge

00:21:26.318 --> 00:21:31.390
here was to gain RC through the
JavaScript whatever Jasiel

00:21:31.390 --> 00:21:35.694
discussed. But in order to
achieve this, we have to find

00:21:35.694 --> 00:21:42.268
the right APIs that would allow
us to actually do interesting

00:21:42.268 --> 00:21:44.904
stuff. So it was clear for us
that we needed a way to dump a

00:21:44.904 --> 00:21:49.041
file on disc and we needed to do
this thorough the JavaScript

00:21:49.041 --> 00:21:53.679
API. So I started doing like
going through the JavaScript API

00:21:53.679 --> 00:21:58.384
reference that that would be
provided and started looking for

00:21:58.384 --> 00:22:01.620
interesting APIs and that was a
big fail. It was a big fail

00:22:01.620 --> 00:22:08.761
because most of the documented
APIs were really hardened. There

00:22:08.761 --> 00:22:12.431
were a lot of restrictions on
file types, file contents and

00:22:12.431 --> 00:22:15.901
stuff like that. So eventually I
was like screw this. I'm going

00:22:15.901 --> 00:22:19.805
to get back to memory corruption
and fuzzing and that's it. So

00:22:19.805 --> 00:22:22.908
one day I decided to write a
fuzz module for the collab

00:22:22.908 --> 00:22:28.247
object. So being the lazy ass I
am I went back to the JavaScript

00:22:28.247 --> 00:22:33.886
preference API and then I had a
look at the collab object

00:22:33.886 --> 00:22:37.223
basically there. As you guys can
see the screen shot, there were

00:22:37.223 --> 00:22:42.561
three methods documented in that
API reference. So I was like,

00:22:42.561 --> 00:22:45.531
okay, this is going to be easy.
I can implement the fuzz module

00:22:45.531 --> 00:22:50.502
for this. But I was kind of more
curious about the collab object.

00:22:50.502 --> 00:22:56.141
So I went in console inside
Adobe reader and decided to dump

00:22:56.141 --> 00:23:00.579
all the actual methods that were
inside the collab. And this is

00:23:00.579 --> 00:23:06.018
what I found. So basically there
were like 128 methods. So if we

00:23:06.018 --> 00:23:12.024
do the math it's like 125
undocumented methods. So I have

00:23:12.024 --> 00:23:19.865
no idea. Seriously Adobe. >>
Thanks, Adobe. >> Yeah. So with

00:23:19.865 --> 00:23:24.103
125 undocumented functions, we
decided to have a closer look.

00:23:24.103 --> 00:23:29.708
So while I was going through the
list of functions, I noticed

00:23:29.708 --> 00:23:35.481
there are some interesting ones
which are highlighted right

00:23:35.481 --> 00:23:42.421
there. Which I would later
reference as the URI family. So

00:23:42.421 --> 00:23:44.857
I wasn't like super convinced
that these APIs were not really

00:23:46.992 --> 00:23:51.130
explored by anyone. So I ran a
search on Google and I got

00:23:51.130 --> 00:23:56.001
nothing. No information. Nothing
like no documentation

00:23:56.001 --> 00:23:59.204
whatsoever. No description,
nothing. All I got are these two

00:23:59.204 --> 00:24:04.810
hits. And basically these just
describe -- they list the

00:24:04.810 --> 00:24:09.481
functions or the methods inside
collab. And one of these hits

00:24:09.481 --> 00:24:15.487
were a report by the minister of
defense. So I'm going to go over

00:24:21.060 --> 00:24:24.930
these or the interesting APIs.
Just describe them briefly and

00:24:24.930 --> 00:24:30.803
stuff. So the first one is URI
put data. Basically it takes two

00:24:30.803 --> 00:24:38.010
arguments. So basically this
function, what it does is it

00:24:38.010 --> 00:24:41.547
takes data object and it strikes
it to the path they supply it

00:24:41.547 --> 00:24:47.519
to. The delete folder as the
name implies, it take one

00:24:47.519 --> 00:24:50.789
argument which is the path and
deletes that folder that you

00:24:50.789 --> 00:24:54.860
give it as a path. Create
folder, same thing. Takes one

00:24:54.860 --> 00:24:58.831
argument, which is the path, and
just creates a folder at that

00:24:58.831 --> 00:25:04.536
path. The URI -- it takes a path
as well and takes a listen side

00:25:04.536 --> 00:25:10.909
that path that you give it. And
finally the URI delete file as

00:25:10.909 --> 00:25:14.680
the name implies, it takes a
path and deletes the file. So

00:25:14.680 --> 00:25:20.686
you guys can see that Adobe
provided like such an awesome

00:25:22.821 --> 00:25:26.892
set of API that you guys can go
whatever they want. We talked

00:25:26.892 --> 00:25:33.065
about it as some kind of
government agency back door

00:25:33.065 --> 00:25:39.071
whatever. So just a overview of
the whole URI stuff. This API is

00:25:42.508 --> 00:25:46.845
used for collaboration.
Collaboration is a feature

00:25:46.845 --> 00:25:51.950
provided by Adobe that would do
like -- that would allow us to

00:25:51.950 --> 00:25:55.387
do some shared reviews and stuff
like that. It's worth noting

00:25:55.387 --> 00:26:01.393
that delete folder, delete file,
put data and create folder are

00:26:01.393 --> 00:26:04.062
all privileged APIs so you guys
cannot exclude them from the

00:26:04.062 --> 00:26:07.399
normal doc context so they have
to be changed by one of the by

00:26:07.399 --> 00:26:11.937
passes that Jasiel discussed.
The only one that's not

00:26:11.937 --> 00:26:15.274
privileged so you guys can run
it from the doc context. So

00:26:15.274 --> 00:26:21.280
these functions have one thing
in common, which is the first

00:26:23.482 --> 00:26:26.885
argument which is the path.
Basically the path should be a

00:26:26.885 --> 00:26:30.989
UNC path. And the UNC path
should be of a specific format.

00:26:30.989 --> 00:26:33.325
So these APIs are not perfect.
Basically they fail at

00:26:33.325 --> 00:26:39.331
sanitizing the path and the old
school trick works like a champ.

00:26:54.012 --> 00:26:59.585
URI put data has two major
fails. The first one it doesn't

00:26:59.585 --> 00:27:02.855
check the file type that it's
going to write to. It doesn't

00:27:02.855 --> 00:27:07.292
check the file name for sure.
The next big fail is that it

00:27:07.292 --> 00:27:11.897
doesn't really check the
contents of the data object. So

00:27:11.897 --> 00:27:16.468
if you guys can provide PE file
data inside the data object and

00:27:16.468 --> 00:27:20.339
then write it to an EXE file it
doesn't complain. So basically

00:27:20.339 --> 00:27:23.742
you guys have an ideal API that
would allow you to write

00:27:23.742 --> 00:27:28.080
whatever you want, whatever file
type, whatever you want. Thank

00:27:28.080 --> 00:27:36.088
you, Adobe. All right. So, what
do we have here so far? So we

00:27:36.088 --> 00:27:40.559
know that our problem of finding
an API that would allow us to

00:27:40.559 --> 00:27:45.397
dump a file on disk is solved.
But if we have a closer look at

00:27:45.397 --> 00:27:50.335
the URI put data, specifically
the second argument which is the

00:27:50.335 --> 00:27:54.072
data object, that's an
interesting piece of

00:27:54.072 --> 00:27:58.210
information. So basically being,
again, being the lazy ass I am,

00:27:58.210 --> 00:28:02.247
back to documentation to
understand how the data object

00:28:02.247 --> 00:28:05.284
looks like or how to actually
get a reference of data or

00:28:05.284 --> 00:28:10.956
anything like that and I found
nothing, as usual. But during my

00:28:10.956 --> 00:28:15.661
experiments I noticed that if
you supply a stream object

00:28:15.661 --> 00:28:18.730
instead of that data object,
than your data would not

00:28:18.730 --> 00:28:23.569
complain which is awesome
because we can create stream

00:28:23.569 --> 00:28:27.339
objects in multiple ways. You
can see I basically created a

00:28:27.339 --> 00:28:34.079
stream object out of a string
and then supplied as a second

00:28:34.079 --> 00:28:38.984
argument for URI put data. And
basically attribute it to

00:28:38.984 --> 00:28:44.990
whatever path I gave it. Which
is cool. All right. So what we

00:28:49.161 --> 00:28:53.465
know as well is that we can
attach files to PDF documents.

00:28:53.465 --> 00:28:56.501
We can attach whatever files we
want, whatever file types and

00:28:56.501 --> 00:29:00.305
stuff like that. And we also
know that we can extract the

00:29:00.305 --> 00:29:06.745
file contents and store them in
a stream object using documented

00:29:06.745 --> 00:29:12.317
APIs as well. So what we should
do is that we should chain the

00:29:12.317 --> 00:29:16.555
URI put data with one of the
bypasses of course supplying the

00:29:16.555 --> 00:29:19.891
stream object to it and we can
write whatever we want on disc.

00:29:19.891 --> 00:29:26.465
So then what? We know we can
dump files but how can we get RC

00:29:26.465 --> 00:29:31.269
out of this? So basically there
are two ways to get RCE. The

00:29:31.269 --> 00:29:36.341
first way, I call it a chelky
way. So basically we can just

00:29:36.341 --> 00:29:38.410
like write our file to a startup
folder and just wait for a

00:29:38.410 --> 00:29:44.416
logoff and login. So the second
way which is my favorite way and

00:29:49.655 --> 00:29:52.758
of course a cleaner way, which
is writing and enforcing acrobat

00:29:52.758 --> 00:30:00.232
to load it right away. That is
possible in specific scenarios

00:30:00.232 --> 00:30:04.236
where you load a PDF in a
specific way. And we call this

00:30:04.236 --> 00:30:07.172
-- one of our colleagues and
he's obsessed with clean

00:30:07.172 --> 00:30:11.610
exploits. By the way, 2015 was a
blast. All right. So this table

00:30:11.610 --> 00:30:14.980
shows the vulnerable versions of
reader and acrobat pro. So

00:30:14.980 --> 00:30:19.885
basically reader and reader DC,
there are limited stuff that we

00:30:19.885 --> 00:30:25.557
can do on windows due to the
sandbox. So it limits our

00:30:25.557 --> 00:30:30.729
ability to write files. But we
can still exploit with no

00:30:30.729 --> 00:30:35.300
problem. Acrobat pro and acrobat
pro DC is available on all

00:30:35.300 --> 00:30:38.603
versions because it doesn't have
a sandbox. So you guys might be

00:30:38.603 --> 00:30:40.605
asking questions why we didn't
enable like specific version

00:30:40.605 --> 00:30:42.607
numbers and stuff. Well, it's
because the first time we tested

00:30:42.607 --> 00:30:44.943
this it was version 11.0.10 and
then Adobe patched it and we

00:30:44.943 --> 00:30:47.112
broke the patch and Adobe
patched it again and we broke

00:30:47.112 --> 00:30:49.114
the patch again. And it's still
not patched. In process.

00:30:49.114 --> 00:30:51.116
Everything is vulnerable,
basically. So let's put this all

00:30:51.116 --> 00:30:53.685
together. Now we know that Adobe
acrobat pro doesn't have a

00:30:53.685 --> 00:30:56.722
sandbox, so it's the easiest
target to exploit. So basically

00:30:56.722 --> 00:30:59.024
our exploit, so these are the
steps with the exploit basically

00:30:59.024 --> 00:31:01.927
to attach a pay load to the PDF
and we should write a JavaScript

00:31:01.927 --> 00:31:04.029
code that basically executes
when the document opens. So this

00:31:04.029 --> 00:31:06.031
JavaScript code should be
composed of the following. A

00:31:06.031 --> 00:31:08.667
code that extracts the contents
of the payload and saves it in a

00:31:08.667 --> 00:31:11.002
stream object. Then we have to
bypass the privileges to execute

00:31:11.002 --> 00:31:13.772
URI put data and then dump and
then have acrobat basically load

00:31:13.772 --> 00:31:15.807
that URL. So I have a demo here
that demonstrates this exploit

00:31:15.807 --> 00:31:17.809
which runs on Windows 8.1. It
exploits acrobat pro 11.0.10. It

00:31:17.809 --> 00:31:19.811
basically dumps -- and have
acrobat pro. Of course. So it

00:31:19.811 --> 00:31:21.813
dumped, if you guys cannot see
it, but. There you go.

00:31:21.813 --> 00:31:23.815
(Applause.) Thank you. So it's
not over yet. So basically we

00:31:23.815 --> 00:31:25.817
paid a visit to reader on micro
sacks. This is the latest

00:31:25.817 --> 00:31:27.819
reader. As you can see, this is
the latest batch. There you go.

00:31:27.819 --> 00:31:29.821
(Applause.) And by the way, this
works on 64 bit too. (Laughter.)

00:31:29.821 --> 00:31:32.224
All right. So I'm going to hand
it to Brian so he can wrap this

00:31:32.224 --> 00:31:34.226
up. Thank you very much.
(Applause.) >> You're so much

00:31:34.226 --> 00:31:36.228
taller than I am. So in
conclusion, what we wanted to

00:31:36.228 --> 00:31:38.230
start off with is really kind of
an idea of go after an

00:31:38.230 --> 00:31:40.232
application that we hadn't been
getting a lot of submissions in

00:31:40.232 --> 00:31:42.234
and we did this and we looked at
prior research, we looked at the

00:31:42.234 --> 00:31:44.236
occasional submission that would
come in and our goal was to take

00:31:44.236 --> 00:31:46.238
that to the next level. The
existing research that existed

00:31:46.238 --> 00:31:48.240
at the time would only allow you
to disclose information on a

00:31:48.240 --> 00:31:50.242
server but we wanted to take
that to make sure we could get

00:31:50.242 --> 00:31:52.244
remote code execution so people
would treat these

00:31:52.244 --> 00:31:54.246
vulnerabilities with the
criticality that they are. So

00:31:54.246 --> 00:31:56.248
what we did, we also wanted to
challenge ourselves. We are

00:31:56.248 --> 00:31:58.250
actually mostly memory
corruption exploiters and

00:31:58.250 --> 00:32:00.185
reverse engineers looking for
memory corruption bugs. So we

00:32:00.185 --> 00:32:02.187
wanted to do this in a way where
there would be no memory

00:32:02.187 --> 00:32:04.189
corruption. We wanted to logic
issues within side of an

00:32:04.189 --> 00:32:06.191
application so that the exploits
would basically run clean. You

00:32:06.191 --> 00:32:08.193
saw in the videos that were on
the slides that there was no

00:32:08.193 --> 00:32:10.195
crashing at all. The things ran
really smoothly, really cleanly,

00:32:10.195 --> 00:32:12.197
and shows just kind of the power
of these type of exploits. So

00:32:12.197 --> 00:32:14.199
our plan of attack was to obtain
an arbitrary eval by using the

00:32:14.199 --> 00:32:16.201
JavaScript overloading and
redefinition capabilities. We

00:32:16.201 --> 00:32:18.203
wanted to chain that eval with a
privilege escalation through

00:32:18.203 --> 00:32:20.205
these app.trusted functions. And
we wanted to leverage the

00:32:20.205 --> 00:32:23.675
undocumented APIs that existed
in Adobe reader to execute our

00:32:23.675 --> 00:32:29.681
malicious code and we were able
to do all these of these things

00:32:43.128 --> 00:32:49.134
to actually produce some pretty
interesting stuff. Then we

00:32:56.608 --> 00:33:02.547
wanted to profit from that. We
decided to submit it to Def Con

00:33:15.994 --> 00:33:22.000
so that the corporation would
pay for us to come to Vegas.

00:33:25.804 --> 00:33:31.810
(Applause.) So yeah, wanted to
share with the community. We are

00:33:40.151 --> 00:33:46.157
a bug bounty program. So if you
do decide to take this research

00:33:57.035 --> 00:34:02.974
and look inside some of the
inner bits of Adobe reader and

00:34:06.878 --> 00:34:12.884
if you do find vulnerabilities,
there are quite a few in there,

00:34:15.787 --> 00:34:21.793
we do purchase these and we do
pay quite a bit of money for

00:34:50.922 --> 00:34:56.928
them. If you're interested,
zerodayinitiative.com we'll

00:36:12.604 --> 00:36:14.906
submit the programs, these
individuals on the stage and the

00:36:14.906 --> 00:36:17.075
couple over there will do all
the analysis. So send them as

00:36:17.075 --> 00:36:20.478
much bugs as possible so they
have to do a lot of work.

00:36:20.478 --> 00:36:24.115
Outside of that, we are
celebrating our ten-year

00:36:24.115 --> 00:36:28.420
anniversary as a program. So up
on the stage we have these

00:36:28.420 --> 00:36:30.422
challenge points of the they're
actually our dual use

00:36:30.422 --> 00:36:36.061
technology. They are also a
bottle opener. So get them

00:36:36.061 --> 00:36:42.067
before they take them away.
Thank you very much. I hope you

00:36:44.202 --> 00:36:46.838
enjoyed the presentation. We'll
be taking questions and coming

00:36:46.838 --> 00:36:49.541
on up. We have a bunch of these
bottle openers to give out and

00:36:49.541 --> 00:36:55.547
coins and I hope you guys have a
good Def Con. (Applause.)

