00:00:00.634 --> 00:00:03.036
 >> Hello, everyone. Thank you
for coming. My name is Fernando

00:00:03.036 --> 00:00:05.839
Arnaboldi and I work as a
security consultant for

00:00:05.839 --> 00:00:11.011
IOActive. I would like to show
you today how XML applications

00:00:11.011 --> 00:00:15.315
are vulnerable to multiple
practical attacks. And for that

00:00:15.315 --> 00:00:18.285
matter, the very first question
that I would like to have

00:00:18.285 --> 00:00:22.389
addressed if I was sitting over
there is why are we talking

00:00:22.389 --> 00:00:26.226
about XSLT? This is a
programming language that is not

00:00:26.226 --> 00:00:30.898
so common. It has been created
when XML was created and it was

00:00:30.898 --> 00:00:38.205
a way to parse XML data. So, a
couple years ago I came across--

00:00:38.205 --> 00:00:44.411
Ariel Sanchez, a coworker, found
an external entity expansion

00:00:44.411 --> 00:00:47.514
that allowed him to retrieve
some passwords. And I thought,

00:00:47.514 --> 00:00:51.852
this is pretty cool. I want to
learn more about XML, schemas,

00:00:51.852 --> 00:00:56.390
and XSLT. Those are all the
technologies related to XML. And

00:00:56.390 --> 00:01:00.994
I was doing that, I noticed that
there were no things talking

00:01:00.994 --> 00:01:04.331
about how to explore XML
implementations. When you are

00:01:04.331 --> 00:01:09.069
reviewing a language, you may
want to know that. So what we

00:01:09.069 --> 00:01:12.239
will be doing here is to analyze
what are those weaknesses and we

00:01:12.239 --> 00:01:16.076
will present five different
issues in here and how you can

00:01:16.076 --> 00:01:20.948
practically explore them. So
whether you are reviewing code,

00:01:20.948 --> 00:01:25.352
if you are a penetration tester,
or if you are developing

00:01:25.352 --> 00:01:29.656
technology related to XSLT,
these will come in handy, or

00:01:29.656 --> 00:01:31.658
just trying to abuse an
implementation, hopefully this

00:01:31.658 --> 00:01:35.629
will help. One of the things is
that even today no one of the

00:01:35.629 --> 00:01:43.337
weaknesses have been fixed, so
everything will work. And you

00:01:43.337 --> 00:01:46.540
may be able to affect the
confidentiality and the

00:01:46.540 --> 00:01:49.476
integrity of multiple
implementations. And that means

00:01:49.476 --> 00:01:55.849
that you may get even some
profit in certain areas. So, the

00:01:55.849 --> 00:02:03.090
good thing is that you are not
exploiting flaws in a way that a

00:02:03.090 --> 00:02:07.094
malicious virus or Malware
would. You will see no assembly

00:02:07.094 --> 00:02:12.399
code. You will see just XSLT and
how that can be used to get some

00:02:12.399 --> 00:02:17.838
fun things. So, we will briefly
talk today about how you can

00:02:17.838 --> 00:02:22.509
identify your target, how
numbers will let you affect the

00:02:22.509 --> 00:02:27.647
integrity, how random numbers
may be predictable sometimes.

00:02:27.647 --> 00:02:30.050
I'll show you how to bypass the
same margin policy in a web

00:02:30.050 --> 00:02:33.687
browser using XSLT and finally
some information disclosure

00:02:33.687 --> 00:02:39.259
through (Inaudible) So,
basically the idea here is to

00:02:39.259 --> 00:02:46.266
tell you what XSLT does, briefly
and how XSLT can be attacked.

00:02:46.266 --> 00:02:53.206
And finally, if you didn't
know-- >> How's it going? >>

00:02:53.206 --> 00:03:00.747
Hello. I was actually expecting
this. >> I know. That's why I'm

00:03:00.747 --> 00:03:08.188
here. So, where's the mic? This
is your first time at DEF CON,

00:03:08.188 --> 00:03:11.224
huh? >> This is my first time at
DEF CON, yes. >> How's it going?

00:03:11.224 --> 00:03:16.697
>> A little bit anxious. >> You
seem a little nervous. Do you

00:03:16.697 --> 00:03:24.004
want me to rub your shoulders?
>> I would be a little bit

00:03:24.004 --> 00:03:30.210
uncomfortable. >> We have a
medicine for that. >> It comes

00:03:30.210 --> 00:03:38.085
in a bottle, right? >> Yes, it
does. I gave him the right one,

00:03:38.085 --> 00:03:45.125
right? >> Why am I getting the
water? I don't want the water.

00:03:45.125 --> 00:03:51.131
>>Moron. >>Welcome to DEF CON.
>> Thank you very much. >> Yes.

00:03:54.968 --> 00:04:01.174
>> [Clapping]. >> That was
interesting. >> You feel much

00:04:01.174 --> 00:04:07.280
better, don't you? >> I feel
like a madman. Thank you very

00:04:07.280 --> 00:04:14.988
much. >> You want to talk
directly into the mic...very

00:04:14.988 --> 00:04:20.894
close to it. (Laughing) I'll
show you later. >> I would

00:04:20.894 --> 00:04:26.766
expect that...and as I was
saying, you can identify your

00:04:26.766 --> 00:04:32.806
target right here. Thank you. >>
So basically, XSLT is a language

00:04:32.806 --> 00:04:39.646
that's being used to modify an
XML. So what it does is receive

00:04:39.646 --> 00:04:44.985
as an input an XML document, it
creates a text document or an

00:04:44.985 --> 00:04:50.757
HTML document or a new XML
document for that matter. So,

00:04:50.757 --> 00:04:53.527
there are different versions
when it comes to XSLT. There are

00:04:53.527 --> 00:04:58.965
three, V1, V2, V3. The different
versions doesn't mean that they

00:04:58.965 --> 00:05:03.737
are improvement... well, they
are, or should be, but they have

00:05:03.737 --> 00:05:07.507
more functionality. Each version
has more functionality. And V1

00:05:07.507 --> 00:05:11.278
is the more implemented version
here because it has been

00:05:11.278 --> 00:05:14.514
supported by web browsers and
because it is supported by

00:05:14.514 --> 00:05:18.652
previous versions. So an XSLT
processor supporting V2 will be

00:05:18.652 --> 00:05:22.856
supporting V1. So, I tested two
types of software. Server side

00:05:22.856 --> 00:05:29.362
processors and client side
processors. Server side

00:05:29.362 --> 00:05:32.999
processors means those are
standalone things that you can

00:05:32.999 --> 00:05:35.969
run and come online or they
could be libraries hooked up to

00:05:35.969 --> 00:05:41.608
different languages (Inaudible)
Java, whatever. When it comes to

00:05:41.608 --> 00:05:45.111
client process servers,
basically I believe you have two

00:05:45.111 --> 00:05:48.915
types, you will have web
browsers or eventually XML or

00:05:48.915 --> 00:05:53.954
XSLT editors, and I believe that
that is a very narrow set of

00:05:53.954 --> 00:05:59.993
people that are using those. So,
the processors in the libraries

00:05:59.993 --> 00:06:03.396
are mostly three. These are the
most important ones, developed

00:06:03.396 --> 00:06:09.836
by (Inaudible) Apache. Linux is
the most widely deployed one.

00:06:09.836 --> 00:06:12.672
It's not only implemented by
server side processors, but also

00:06:12.672 --> 00:06:16.876
by client side process servers,
web browsers. And you also have

00:06:16.876 --> 00:06:22.215
(Inaudible), developed by the
Apache people which comes in two

00:06:22.215 --> 00:06:25.585
flavors, SQL plus and Java. And
the similar thing with

00:06:25.585 --> 00:06:28.021
(Inaudible) And the client
process servers, here we have

00:06:28.021 --> 00:06:30.690
browsers, all the things that I
tested was in the latest

00:06:30.690 --> 00:06:35.262
versions available of all the
servers, libraries, and the web

00:06:35.262 --> 00:06:38.765
browsers. So, we have three ways
to do this. The first one

00:06:38.765 --> 00:06:45.639
involves an XSLT processor
receiving XML and XSLT. This

00:06:45.639 --> 00:06:49.909
only happens when you are
calling a common line processor.

00:06:49.909 --> 00:06:52.912
And eventually you will get a
new document. You'll do this if

00:06:52.912 --> 00:06:56.249
you need to parse an XML. So
people will be using this if

00:06:56.249 --> 00:07:00.320
they need to parse something
server side. Another possibility

00:07:00.320 --> 00:07:03.857
which is more common from a
client perspective is when the

00:07:03.857 --> 00:07:07.527
XSLT processor is grabbing the
XSLT document. There is a small

00:07:07.527 --> 00:07:13.767
portion in the XML that says you
will find here XSLT document. Go

00:07:13.767 --> 00:07:18.371
get it for me, and create a new
document. And finally you can

00:07:18.371 --> 00:07:22.742
embed the XSLT document along
with the XML and by doing that

00:07:22.742 --> 00:07:27.747
you are just supplying one file
to the processor to get the new

00:07:27.747 --> 00:07:31.851
result. So you might want to
know if you don't know already

00:07:31.851 --> 00:07:36.022
who is your target, and which
kind of properties do the target

00:07:36.022 --> 00:07:40.460
has. By getting which type of
version and vendor they have you

00:07:40.460 --> 00:07:44.264
may know what type of
vulnerabilities you could

00:07:44.264 --> 00:07:48.568
exploit in this target. Since
clients may also support Java

00:07:48.568 --> 00:07:51.071
script, and that would be the
case for a typical web browser,

00:07:51.071 --> 00:07:54.874
you may retrieve some Java
script information. All these

00:07:54.874 --> 00:07:58.778
codes that you see here, and you
will be seeing here, it is only

00:07:58.778 --> 00:08:02.949
white paper and you can do a
copy and paste and try on your

00:08:02.949 --> 00:08:07.721
target of choice to see what
happens. At the end of each

00:08:07.721 --> 00:08:12.359
section I will show you a brief
summary of the server sites.

00:08:12.359 --> 00:08:17.931
Here we have all of them.
(Inaudible) all related to XLT

00:08:17.931 --> 00:08:25.638
in this example. Then you have
the clients, which would be the

00:08:25.638 --> 00:08:31.444
web browsers. You will see the
first column for the version,

00:08:31.444 --> 00:08:37.117
the vendor, over there, and if
support Java script or not and

00:08:37.117 --> 00:08:41.688
basically all web browsers
support Java script. And there

00:08:41.688 --> 00:08:46.726
is one final thing. Normally,
XLT is more widely deployed than

00:08:46.726 --> 00:08:51.431
other things, so you will notice
that it is sometimes when it

00:08:51.431 --> 00:08:56.636
reaches (Inaudible) it may also
effect the client one. So let's

00:08:56.636 --> 00:09:00.306
talk about the issues. So this
is something present in client

00:09:00.306 --> 00:09:03.810
side and service side. And it
doesn't matter if you are

00:09:03.810 --> 00:09:08.915
talking about floating point
numbers or integers, all numbers

00:09:08.915 --> 00:09:15.155
will introduce errors in here.
So as I was testing this, it

00:09:15.155 --> 00:09:18.558
felt a little bit weird that
sometimes that relation was not

00:09:18.558 --> 00:09:22.929
working as I would expect it to
be. Certain additions,

00:09:22.929 --> 00:09:29.068
subtractions were not doing what
I expecting. So, the very first

00:09:29.068 --> 00:09:34.707
thing that I did was define a
simple calculation. What I was

00:09:34.707 --> 00:09:39.679
trying to do is just to add a
few numbers. So for that matter,

00:09:39.679 --> 00:09:46.553
I have (Inaudible) specific
output here, says text output.

00:09:46.553 --> 00:09:52.959
In the middle, you will have
this simple thing, 0.2 + 0.1 -

00:09:52.959 --> 00:09:57.730
0.3. That should be 0, right?
Pretty simple. May not be that

00:09:57.730 --> 00:10:01.901
simple for processors. Only two
said that that was 0. That was

00:10:01.901 --> 00:10:08.341
the case for (?) and Chrome. The
rest said, well, close to that.

00:10:08.341 --> 00:10:13.947
Why is this happening? This is
weird. The weird thing is that

00:10:13.947 --> 00:10:18.651
you'll see this across all
implementations. Ok. This is

00:10:18.651 --> 00:10:22.922
cool. But it would be better if
it would do something with this.

00:10:22.922 --> 00:10:27.260
I mean this shows numbers that
were not properly rounded by the

00:10:27.260 --> 00:10:32.799
programming language. So this is
the things that is present in

00:10:32.799 --> 00:10:36.136
all programming languages. I
realize that you have these in

00:10:36.136 --> 00:10:42.041
Java script, Python, whatever.
This is a common thing. Floating

00:10:42.041 --> 00:10:46.012
point numbers will have certain
decimals that are over there

00:10:46.012 --> 00:10:50.383
hanging around that you may
take. So I created a simple Java

00:10:50.383 --> 00:10:54.154
script application simulating a
bank. This is not my real bank.

00:10:54.154 --> 00:10:56.956
I wouldn't try this on my real
bank. Hopefully my real bank

00:10:56.956 --> 00:10:59.859
would limit the amount of
transaction. I wouldn't allow a

00:10:59.859 --> 00:11:02.896
very small decimal to be
transferred from one account to

00:11:02.896 --> 00:11:05.598
another. So the very first thing
that I tried was to see-- this

00:11:05.598 --> 00:11:07.600
application I deposit a million
dollars in first account and the

00:11:07.600 --> 00:11:13.873
second account has 0 balance at
the moment. This is where I will

00:11:13.873 --> 00:11:20.180
deposit profit. So I notice that
if I remove a very small number

00:11:20.180 --> 00:11:24.183
from million dollar account, it
will not get subtracted, but it

00:11:24.183 --> 00:11:27.520
will be added to the secondary
account, because it has a lower

00:11:27.520 --> 00:11:32.559
number than a million, it has a
0, and that decimal means more

00:11:32.559 --> 00:11:37.130
for a 0 than it gets for the
million. So this program will

00:11:37.130 --> 00:11:40.400
try to do the first portion of
the problem, will try to see how

00:11:40.400 --> 00:11:44.837
big of a number it can retrieve.
It is a small number. And then

00:11:44.837 --> 00:11:47.840
it will do millions of
transactions to move it to the

00:11:47.840 --> 00:11:51.511
secondary account. So you will
see here that we will be using

00:11:51.511 --> 00:11:56.916
V8, and that is the Chrome, Java
script processor, (Inaudible)

00:11:56.916 --> 00:12:01.788
and we'll try to see what's the
best process to getting here.

00:12:01.788 --> 00:12:04.290
How much money can I steal from
a million dollars that would not

00:12:04.290 --> 00:12:08.461
be noticed? And I will try
moving that money from the

00:12:08.461 --> 00:12:12.599
account number 0 to the account
number 1. And hopefully that

00:12:12.599 --> 00:12:17.637
will gain me a daily profit of
around $1,300. It's moving

00:12:17.637 --> 00:12:23.643
right? Yeah. So, this was good.
But it would be better if it

00:12:25.845 --> 00:12:28.681
were a higher number. So let's
talk about integers. (Inaudible)

00:12:28.681 --> 00:12:33.319
This should be fairly easy to
understand even if you are not

00:12:33.319 --> 00:12:37.223
developing. You'll see that you
have five exponential numbers in

00:12:37.223 --> 00:12:40.760
here, and the same five
exponential numbers written with

00:12:40.760 --> 00:12:43.730
the number one with a bunch of
0s. The things is that

00:12:43.730 --> 00:12:47.166
programming languages do not
handle it well when you have 16

00:12:47.166 --> 00:12:52.071
digits because of precision. But
what I tried to do was print in

00:12:52.071 --> 00:12:56.776
here the same number that I was
having on the XML document and

00:12:56.776 --> 00:13:00.680
then format it with commas and
periods and such so it would be

00:13:00.680 --> 00:13:06.185
more legible. In here you will
see that Saxon is doing great.

00:13:06.185 --> 00:13:09.055
This is what you want to see.
You will see number one,

00:13:09.055 --> 00:13:11.891
followed by a bunch of zeros.
This is pretty clear. This is

00:13:11.891 --> 00:13:16.496
awesome. You will have the same
for non-exponential

00:13:16.496 --> 00:13:20.700
exploitation. Internet Explorer
and Firefox are good. They

00:13:20.700 --> 00:13:23.302
weren't able to show the
exponential notation. But that's

00:13:23.302 --> 00:13:28.608
ok. The problem comes when you
are introducing errors. Because

00:13:28.608 --> 00:13:31.644
there is nothing worse than
believing you have the right

00:13:31.644 --> 00:13:37.050
number when in fact you do not.
In fact, I was noting today that

00:13:37.050 --> 00:13:39.152
how they are finishing is
different depending on whether

00:13:39.152 --> 00:13:43.489
you using exploitation notation
or not. We will try to use this

00:13:43.489 --> 00:13:49.495
number in a couple of minutes.
Same for Java, almost there. For

00:13:51.631 --> 00:13:57.036
C, they just don't care about
what's going on over there, so

00:13:57.036 --> 00:14:03.676
anything can happen there. First
thing, this is something related

00:14:03.676 --> 00:14:08.681
to an error in this download, so
I want to read this download

00:14:08.681 --> 00:14:12.452
(Inaudible) But the problem is
not with the error. All

00:14:12.452 --> 00:14:16.689
implementations have problems.
It's what you do with floating

00:14:16.689 --> 00:14:21.160
point numbers and integers that
matters. You should be saying,

00:14:21.160 --> 00:14:23.996
Ok, a number should be between
this value, and not allowing a

00:14:23.996 --> 00:14:28.501
value to be so big if you are
not able to handle it. Either

00:14:28.501 --> 00:14:33.706
way, this shouldn't be working
like this. So I reported all of

00:14:33.706 --> 00:14:37.410
the issues, including this one,
the floating point numbers, to

00:14:37.410 --> 00:14:42.615
the vendors. And the first thing
that I heard was that I should

00:14:42.615 --> 00:14:44.684
be reading Wikipedia to
understand how floating point

00:14:44.684 --> 00:14:49.155
numbers work. That was
interesting, but probably you

00:14:49.155 --> 00:14:52.525
wouldn't find the answers there.
Then, I heard that I should be

00:14:52.525 --> 00:14:54.827
reading the (Inaudible) that
this was effecting purely V1,

00:14:54.827 --> 00:14:59.899
that was nice as well, but
clearly was not solving the

00:14:59.899 --> 00:15:05.938
problem that was in here. And
the very same person also said

00:15:05.938 --> 00:15:10.109
this is something that you'll
see in Java script as well.

00:15:10.109 --> 00:15:14.914
That's fine, I know that you can
find this in Java script, but I

00:15:14.914 --> 00:15:17.383
don't want to have this in my
programming language, or any

00:15:17.383 --> 00:15:20.353
programming language because
these numbers are everywhere.

00:15:20.353 --> 00:15:23.156
So, we stole some decimals
before, and now we are trying to

00:15:23.156 --> 00:15:26.826
do a similar thing but with
integers. The thing is that if

00:15:26.826 --> 00:15:31.631
you put a number zero, a number
one, followed by 17 zeros and

00:15:31.631 --> 00:15:34.500
subtract the number one,
programming language will not

00:15:34.500 --> 00:15:39.605
notice that the one is missing.
So perhaps, I created in here a

00:15:39.605 --> 00:15:43.109
fake cryptic currency which I
have named fake coin. That the

00:15:43.109 --> 00:15:49.215
value is very small, very, very,
small. So I bought a number one

00:15:49.215 --> 00:15:53.586
followed by 17 zeros of this
coin. So I have a lot of coins

00:15:53.586 --> 00:15:59.158
with a total net value of
$1,100 --> 000. And I will try to

00:15:59.158 --> 00:16:02.962
transfer one coin at a time to a
secondary account, which will be

00:16:02.962 --> 00:16:07.066
my profit account. And hopefully
by the end of the day I will

00:16:07.066 --> 00:16:13.072
have a better profit than moving
decimals. The profit would be

00:16:16.008 --> 00:16:19.445
better if I use more coins. I
would be able to transfer more

00:16:19.445 --> 00:16:22.181
coins at the same time. Here,
just going for the minimum

00:16:22.181 --> 00:16:25.785
amount possible just to show
you. The minimum amount here

00:16:25.785 --> 00:16:31.791
gave me a profit of $2,300. If
you add a 0 to the coins, you

00:16:35.027 --> 00:16:38.998
should add a 0 to the daily
profit as well. So that was

00:16:38.998 --> 00:16:45.905
nice. That was nice. So the very
next thing that I did was to see

00:16:45.905 --> 00:16:49.709
how random numbers work. If you
ever develop, if you have ever

00:16:49.709 --> 00:16:53.312
developed, you need random
numbers. This is something that

00:16:53.312 --> 00:16:57.116
you should normally see on
server side processors. And you

00:16:57.116 --> 00:17:00.453
should also know that of course
not any random number generator

00:17:00.453 --> 00:17:05.057
should be used (Inaudible)
Random number, you have to be

00:17:05.057 --> 00:17:10.429
careful with them. In XSLT, this
is a function that comes from

00:17:10.429 --> 00:17:18.337
the extended XSLT, which is an
extension of XSLT. It is defined

00:17:18.337 --> 00:17:22.675
as a function that returns a
value between 0 and 1, as any

00:17:22.675 --> 00:17:27.213
random function should be.
Supposedly any random number

00:17:27.213 --> 00:17:30.216
should be a number that doesn't
have any pattern. You shouldn't

00:17:30.216 --> 00:17:33.686
know what will be the number
before calling this map. That

00:17:33.686 --> 00:17:38.457
would be fairly logical from a
random point of view. So, we

00:17:40.760 --> 00:17:42.929
normally have two types of
random functions. If you have

00:17:42.929 --> 00:17:47.099
ever developed you may know that
you have functions that are less

00:17:47.099 --> 00:17:50.369
secure like random-random in
Python and you have more

00:17:50.369 --> 00:17:53.606
cryptographically secure
mechanisms like system-random in

00:17:53.606 --> 00:17:57.243
Python. You may want to use that
if you are moving cryptographic

00:17:57.243 --> 00:18:02.448
things. And some of the software
that I tested, the service line

00:18:02.448 --> 00:18:06.085
processors, the, you are able to
see the code, you are able to

00:18:06.085 --> 00:18:11.624
see how that was developed.
(Inaudible) and Saxon, you will

00:18:11.624 --> 00:18:18.564
see that in all those areas they
are using a random generator.

00:18:18.564 --> 00:18:22.668
Which is fine. The thing comes,
the problem may come on the

00:18:22.668 --> 00:18:26.539
implementation. If people are
using random numbers for any

00:18:26.539 --> 00:18:30.810
cryptograph proposer, that may
be a problem because you may

00:18:30.810 --> 00:18:33.679
know with a certain random
number generator what is going

00:18:33.679 --> 00:18:41.554
on. This was a point that we
would see in C and C++ and Java.

00:18:41.554 --> 00:18:44.790
And a good definition comes from
(Inaudible). These are chosen by

00:18:44.790 --> 00:18:47.493
a random number generator. You
have to take that into

00:18:47.493 --> 00:18:52.832
consideration and shouldn't use
them for cryptograph proposers.

00:18:52.832 --> 00:18:55.801
But there is one more thing when
it comes to random numbers that

00:18:55.801 --> 00:18:59.772
you normally pay attention to,
or you should at least, what

00:18:59.772 --> 00:19:02.675
happens if there is no
initialization vector. This is

00:19:02.675 --> 00:19:07.079
something basic for many random
number. And that's that you need

00:19:07.079 --> 00:19:10.883
to have some sort of-- something
that's changing when you getting

00:19:10.883 --> 00:19:13.853
a random number, otherwise you
may get always the very same

00:19:13.853 --> 00:19:17.356
volume. And that's not very
useful if you're expecting a

00:19:17.356 --> 00:19:21.227
random number. And that's
because you may know in advance

00:19:21.227 --> 00:19:27.600
which numbers you will be
getting. So once you have a

00:19:27.600 --> 00:19:30.503
proper IV in place, you will
have different volumes every

00:19:30.503 --> 00:19:33.739
time that you are calling the
random functions. But let's see

00:19:33.739 --> 00:19:37.943
again how the functions that we
saw before are working with the

00:19:37.943 --> 00:19:43.182
(Inaudible) association vector.
And here there is only one that

00:19:43.182 --> 00:19:47.486
doesn't have the IV. Again,
leave it XLT. This is not

00:19:47.486 --> 00:19:50.523
something new to Linux XSLT.
They knew about these things in

00:19:50.523 --> 00:19:56.529
2006, but this is how it works.
So, if you try to create an XSLT

00:19:59.331 --> 00:20:02.201
that will produce a random
function, or you see anyone who

00:20:02.201 --> 00:20:06.105
is trying to produce a random
value out of Linux XSLT, you

00:20:06.105 --> 00:20:10.643
will see something like this.
And you will see these kinds of

00:20:10.643 --> 00:20:15.314
results if you are executing
that on common line. I executed

00:20:15.314 --> 00:20:19.985
twice on the same terminal and I
got twice the same number. You

00:20:19.985 --> 00:20:24.957
can see that the 7.82, you
always get that first number

00:20:24.957 --> 00:20:29.929
every time that you are
executing the random function

00:20:29.929 --> 00:20:33.999
from Linux XSLT. So, the next
thing that I do is try to

00:20:33.999 --> 00:20:38.137
understand how this can be used
in cipher modes when they are

00:20:38.137 --> 00:20:42.041
doing blog ciphers. That is not
a way to cipher things if you

00:20:42.041 --> 00:20:47.413
are using random. So I created
two executions of the very first

00:20:47.413 --> 00:20:52.451
time to understand how these
numbers look like. So first I

00:20:52.451 --> 00:20:56.288
printed the Python version of
random-random. And you get two

00:20:56.288 --> 00:20:59.158
different numbers. Of course,
these are from the random number

00:20:59.158 --> 00:21:02.328
generator. They may not be the
best, but they are not

00:21:02.328 --> 00:21:04.930
predictable, and they are not
the same every time that I

00:21:04.930 --> 00:21:09.201
execute that function. But Linux
XSLT can recognize again the

00:21:09.201 --> 00:21:12.638
very same number that we saw on
the previous line, that 7.82

00:21:12.638 --> 00:21:16.108
thing. That is the very same
number. If you are calling

00:21:16.108 --> 00:21:20.946
Python again with a print
random-random function, we will

00:21:20.946 --> 00:21:24.583
see that we have again two
different numbers. So, so far,

00:21:24.583 --> 00:21:29.722
four for Python and one for
Linux XSLT. If we are calling

00:21:29.722 --> 00:21:33.559
Linus XSLT again, you will
notice in second position we'll

00:21:33.559 --> 00:21:39.632
always have these new values,
the 0.13 and it will be repeated

00:21:39.632 --> 00:21:44.803
every second time they are
calling this. So, without having

00:21:44.803 --> 00:21:49.208
an external (Inaudible) you may
know in advance which will be

00:21:49.208 --> 00:21:52.511
the sequence of numbers that
will be generated by Linux XSLT.

00:21:52.511 --> 00:21:56.882
Which is pretty cool, because
you may know in advance what's

00:21:56.882 --> 00:22:00.486
being encrypted if they are
using this to encrypt something,

00:22:00.486 --> 00:22:04.456
which would be pretty
ridiculous. So again, you may

00:22:04.456 --> 00:22:10.462
predict values when you see
random numbers. The same origin

00:22:13.999 --> 00:22:17.703
point is something present in
client side processors, this

00:22:17.703 --> 00:22:23.742
means web browsers. Basically
this says that if you are on a

00:22:23.742 --> 00:22:27.479
website, you shouldn't be
reading information from other

00:22:27.479 --> 00:22:33.485
websites, but again that may not
be the case for (Inaudible) So

00:22:36.288 --> 00:22:40.092
this is important, the origin is
always defined from the scheme,

00:22:40.092 --> 00:22:45.831
the host, on the port of a URL.
What would be an example of

00:22:45.831 --> 00:22:49.101
this? The http at the very
beginning or https would be the

00:22:49.101 --> 00:22:52.838
scheme. The host should be
example.com and the ports should

00:22:52.838 --> 00:22:58.744
be either port 80 or port 443 or
something like that. Generally

00:22:58.744 --> 00:23:00.846
speaking, when we are retrieving
documents from different

00:23:00.846 --> 00:23:05.017
origins, the web browsers will
not share the information. I

00:23:05.017 --> 00:23:08.587
mean when we are taking the same
origin over and over, we may

00:23:08.587 --> 00:23:12.591
have-- we'll be sending the same
cookie over and over to the same

00:23:12.591 --> 00:23:17.096
website and that would be ok.
Normally, Java script is used to

00:23:17.096 --> 00:23:20.899
try to deter this, but you don't
necessarily need to use it to

00:23:20.899 --> 00:23:27.306
effect the same origin policy.
You should not be expecting that

00:23:27.306 --> 00:23:30.809
when you are connecting to
Google.com your browser will be

00:23:30.809 --> 00:23:34.213
saving the very same cookie to
this website because it have the

00:23:34.213 --> 00:23:39.351
very same origin. If you are
connecting to Microsoft.com you

00:23:39.351 --> 00:23:42.388
should be seeing a different
cookie. This will be a very

00:23:42.388 --> 00:23:46.492
(Inaudible) You just connected
to the website and you are on

00:23:46.492 --> 00:23:50.262
the main webpage and you are
trying to access a second

00:23:50.262 --> 00:23:54.500
webpage that's being stored over
there. That will be fine. That's

00:23:54.500 --> 00:23:58.404
ok, you are allowed to see that.
In fact, you are even allowed to

00:23:58.404 --> 00:24:02.675
see other webpages on the very
same domain. But, if you are

00:24:02.675 --> 00:24:06.245
changing the scheme, if you are
changing the host name, or if

00:24:06.245 --> 00:24:09.515
you are changing the port, you
shouldn't be allowed to see any

00:24:09.515 --> 00:24:13.385
of the information that is
present on that other website. I

00:24:13.385 --> 00:24:15.621
mean you are not sharing the
private information between

00:24:15.621 --> 00:24:20.726
websites. That's what you would
expect at least. So, there is

00:24:20.726 --> 00:24:24.563
only one function that reads
documents, and that's document.

00:24:24.563 --> 00:24:30.302
Ok, so you may try to use that
to read another XML document. In

00:24:30.302 --> 00:24:34.506
fact, since we're speaking about
websites, we could also see here

00:24:34.506 --> 00:24:39.878
xhtml, which is a fairly common
way to represent a webpage by

00:24:39.878 --> 00:24:45.684
certain web servers. Once we
retrieve the html documents, we

00:24:45.684 --> 00:24:48.153
could see what's inside using
either of these two functions

00:24:48.153 --> 00:24:52.024
(Inaudible) It will show either
an XML representation or

00:24:52.024 --> 00:24:56.962
(Inaudible) representation. So,
the very first thing that you

00:24:56.962 --> 00:25:00.632
want to do if you want to use
this, you need to find a server

00:25:00.632 --> 00:25:08.107
that uses xhtml. Ok. Bing.com
uses xhtml. I'm logging in here.

00:25:08.107 --> 00:25:10.676
What can you do with this? So in
the upper right corner you will

00:25:10.676 --> 00:25:15.581
see that my name is in a red box
and that is also reflected in

00:25:15.581 --> 00:25:21.987
the code. Since it is xhtml this
is some sort of XML and my name

00:25:21.987 --> 00:25:29.194
is in an element named ID
underscore M. So you may be able

00:25:29.194 --> 00:25:35.200
to target your web browser to
retrieve that value. So let's

00:25:35.200 --> 00:25:37.936
see how using that document, how
using many of the other

00:25:37.936 --> 00:25:42.574
functions, we can retrieve that
information. In here, we can see

00:25:42.574 --> 00:25:49.415
that the document function is
accessing the URL, WWW being dot

00:25:49.415 --> 00:25:55.554
com. Then right in the middle we
are retrieving the information

00:25:55.554 --> 00:25:59.358
that we just grabbed from the
document. And finally, because

00:25:59.358 --> 00:26:05.297
I'm lazy, on Java script, I will
be subtracting the ID_ dot

00:26:07.566 --> 00:26:14.072
element, which has my name.
Let's see a demo of this. First

00:26:14.072 --> 00:26:19.511
I will open Safari and I will
show you that I'm using Bing.com

00:26:19.511 --> 00:26:23.715
as my home page. And then I will
open the document that is on the

00:26:23.715 --> 00:26:30.522
desktop that it is not sharing
the same origin because one,

00:26:30.522 --> 00:26:34.693
Bing.com is being hosted on
https, Bing.com, and the other

00:26:34.693 --> 00:26:38.964
one it is a file, it is a local
file. Let's see what happens.

00:26:42.968 --> 00:26:46.538
Notice again my number in the
upper right corner. And when I

00:26:46.538 --> 00:26:50.509
open that file, I'm reading the
document that is being stored by

00:26:50.509 --> 00:26:54.012
Bing.com and I'm able to
retrieve my name from using

00:26:54.012 --> 00:26:58.784
XSLT. Even though it is not
hosted on Bing.com, Safari

00:26:58.784 --> 00:27:04.823
doesn't care, and we'll show you
that information. So, basically

00:27:04.823 --> 00:27:09.428
Safari will all you to read
this. Internet Explorer may show

00:27:09.428 --> 00:27:14.132
you a warning message, it will
retrieve the information, but

00:27:14.132 --> 00:27:18.237
you won't be sharing anything
related to this. And other

00:27:18.237 --> 00:27:24.142
browsers didn't show anything.
Another cool thing would be that

00:27:24.142 --> 00:27:30.415
you may use some of these sites
to scan internal networks in

00:27:30.415 --> 00:27:34.553
case you wanted to. There are
multiple ways to try to scan

00:27:34.553 --> 00:27:37.689
internal networks when you are
executing something locally and

00:27:37.689 --> 00:27:45.631
this could be another way as
well. So another vulnerability

00:27:45.631 --> 00:27:49.568
that I found and I found would
be very interesting to discuss

00:27:49.568 --> 00:27:51.703
would be an information
disclosure and I'm probably

00:27:51.703 --> 00:27:58.110
reading through errors. This is
something that's present in

00:27:58.110 --> 00:28:01.613
server side and client side
processors. The focus here is of

00:28:01.613 --> 00:28:04.316
course on server side processors
because we wouldn't care what

00:28:04.316 --> 00:28:09.588
would happen on a web browser.
So the cool thing about this is

00:28:09.588 --> 00:28:13.458
that it is not possible to read
text files in XSLT1. It's only

00:28:13.458 --> 00:28:19.464
possible to read XML documents,
or as we saw, xhtml documents.

00:28:23.101 --> 00:28:28.273
And since it's not possible to
read plain text files, it

00:28:28.273 --> 00:28:30.576
doesn't matter what function you
are trying to use in here

00:28:30.576 --> 00:28:36.048
because all functions wouldn't
be capable of doing this. Let's

00:28:36.048 --> 00:28:42.087
see what happens even though
when the W3C consortium says

00:28:42.087 --> 00:28:44.656
it's not possible. We saw before
that there was one function to

00:28:44.656 --> 00:28:51.697
read XML documents and that is
the document function. This

00:28:51.697 --> 00:28:55.200
document will allow access to
other XML documents other than

00:28:55.200 --> 00:28:59.171
the main document. We have that.
We can try to use that. There

00:28:59.171 --> 00:29:03.842
are also other functions used
for accessing XML documents. And

00:29:03.842 --> 00:29:07.045
that would be the functions
"include" and "import". These

00:29:07.045 --> 00:29:13.986
functions do just retrieve and
(Inaudible) and I'll try to use

00:29:13.986 --> 00:29:17.589
it combined with other
(Inaudible) We don't care what

00:29:17.589 --> 00:29:22.361
the manual says about this
because either way we're not

00:29:22.361 --> 00:29:28.367
trying to read a stylesheet in
here. I created a text file that

00:29:32.971 --> 00:29:37.042
contains three lines, very
simple. If you see the contents

00:29:37.042 --> 00:29:40.746
on my test file you will see a
line one, line two, and a line

00:29:40.746 --> 00:29:45.884
three. Pretty simple. If you
read the documentations, you see

00:29:45.884 --> 00:29:49.855
that when you are reading a
file-- this comes from XML

00:29:49.855 --> 00:29:53.025
documentation-- if you are
reading a file, there are a

00:29:53.025 --> 00:29:57.162
couple possibilities. The first
one is that you may show that

00:29:57.162 --> 00:30:01.366
XSLT processor found an error.
And this is what some of the

00:30:01.366 --> 00:30:05.270
processor do. They say this is
not allowed in (Inaudible) Okay.

00:30:05.270 --> 00:30:10.042
That would be-- that's okay. The
other possibility would be to

00:30:10.042 --> 00:30:13.779
return an empty XML document.
That's what Ruby does. Ruby will

00:30:13.779 --> 00:30:19.584
show you that there is nothing
to see in here and this is

00:30:19.584 --> 00:30:24.089
something that is also expected
as well. But again, this doesn't

00:30:24.089 --> 00:30:27.125
solve the problem that-- we
wanted to read something that

00:30:27.125 --> 00:30:30.862
was in the test file. Linus XSLT
comes again to help us with

00:30:30.862 --> 00:30:37.035
this. So when using document,
XSLT prompt, PHP, and Pearl,

00:30:37.035 --> 00:30:40.739
will show you first line of our
test file. Remember line one of

00:30:40.739 --> 00:30:47.312
test file? That's not too much.
But it's cool. Perhaps we could

00:30:47.312 --> 00:30:53.285
do something with that. We also
try to use other functions to

00:30:53.285 --> 00:30:56.922
try to access these files later.
But having this unexpected

00:30:56.922 --> 00:31:02.561
behavior in place may allow us
to do something with it. So you

00:31:02.561 --> 00:31:05.530
may know in advance where I'm
going with this. We've saw

00:31:05.530 --> 00:31:08.133
before as it may have an
interesting first line that

00:31:08.133 --> 00:31:12.304
would be valuable for us. There
are certain specific files that

00:31:12.304 --> 00:31:14.806
store the most valuable
information of a computer on the

00:31:14.806 --> 00:31:20.512
very first line. So what if we
won't be able to read, for

00:31:20.512 --> 00:31:25.150
example, a password file. Where
could we find those passwords?

00:31:25.150 --> 00:31:27.686
The most common answer for any
Linux system would be in its

00:31:27.686 --> 00:31:32.491
inner password. The next one if
you go off a bit (Inaudible)

00:31:32.491 --> 00:31:38.396
through a shadow. The
possibilities are in your

00:31:38.396 --> 00:31:41.099
imagination in here. Depending
what you are trying to read, you

00:31:41.099 --> 00:31:43.802
may be able to retrieve certain
information that might be

00:31:43.802 --> 00:31:47.606
valuable for you or someone
else. You also have the Apache

00:31:47.606 --> 00:31:51.109
password and you may also have
database passwords. There are a

00:31:51.109 --> 00:31:55.113
number of possibilities down
there. The thing is that this is

00:31:55.113 --> 00:31:58.283
what you'll see when using, for
example, one of the processors

00:31:58.283 --> 00:32:02.821
when trying to read it into your
password. You will see an error,

00:32:02.821 --> 00:32:06.424
and also something else: the
password. Which is cool. I mean

00:32:06.424 --> 00:32:10.729
you could also now use XSLT to
retrieve this information.

00:32:10.729 --> 00:32:14.800
Another example you seen PHP
could be to try to use to read

00:32:14.800 --> 00:32:16.802
HD password of an Apache. And
again, since this is something

00:32:16.802 --> 00:32:23.708
that you store on the very first
line, you may see a bunch of

00:32:23.708 --> 00:32:28.146
errors and right in the middle,
what you were planning to see,

00:32:28.146 --> 00:32:33.051
the password for Joe, in this
case. And as I was saying

00:32:33.051 --> 00:32:36.788
before, just in case they do not
care about what they are doing,

00:32:36.788 --> 00:32:42.794
you could also have someone
using the shadow, leaving that

00:32:46.164 --> 00:32:51.102
available if they are running
this as root, and this will

00:32:51.102 --> 00:32:54.739
happen if you are using Ruby to
try to retrieve that file.

00:32:54.739 --> 00:32:58.743
Again, expect all the errors,
but also expect the password for

00:32:58.743 --> 00:33:02.681
the root over there. So, this is
pretty neat because I believe

00:33:02.681 --> 00:33:05.851
this opens the possibility for
XSLT to be as interesting

00:33:05.851 --> 00:33:10.856
perhaps as (Inaudible) expansion
as a way to retrieve some

00:33:10.856 --> 00:33:15.961
information even if a hacker is
able to compromise an XSLT

00:33:15.961 --> 00:33:18.430
because the application is
allowing-their application is

00:33:18.430 --> 00:33:22.534
allowing XSLT to be uploaded, or
XML that are relying on document

00:33:22.534 --> 00:33:29.107
importing include that may be
trying to read files. So,

00:33:29.107 --> 00:33:32.177
either, if you are able to
control an XML and you have an

00:33:32.177 --> 00:33:35.714
XLT processor in the back end
parsing this, or you are able to

00:33:35.714 --> 00:33:39.084
control the XLT, you may
compromise the security of an

00:33:39.084 --> 00:33:44.022
application. As we also saw, we
don't always need to do that in

00:33:44.022 --> 00:33:47.792
place to have the
confidentiality and integrity

00:33:47.792 --> 00:33:51.263
effected because sometimes when
using random function or

00:33:51.263 --> 00:33:55.800
integers, they may be doing that
to our profit without doing

00:33:55.800 --> 00:34:01.573
anything on our side. So, I
would recommend, as a very last

00:34:01.573 --> 00:34:04.042
thing, that you should check
your code, or someone else, in

00:34:04.042 --> 00:34:10.282
case they want to see what's
going on to use these things.

00:34:10.282 --> 00:34:13.184
So, that's what I have for
today. If anyone has any

00:34:13.184 --> 00:34:18.490
questions, I would be happy to
answer them. [Clapping] >> Thank

00:34:18.490 --> 00:34:24.496
you very much. And thank you to
all these people who helped me

00:34:28.199 --> 00:34:30.435
with the presentation.

