00:00:00.033 --> 00:00:02.202
>> I want to point out that we
have ourselves a first time

00:00:02.202 --> 00:00:05.205
speaker here. I'd like to
welcome John Seymour to the

00:00:05.205 --> 00:00:09.910
stage for his talk Quantum
Classification of Malware. Give

00:00:09.910 --> 00:00:15.916
it up! >> All right hi everybody
thanks for coming out to Defcon

00:00:18.852 --> 00:00:22.623
and I hope you'll find it
interesting my name is John

00:00:22.623 --> 00:00:25.592
Seymour and the best way to
reach me is probably through my

00:00:25.592 --> 00:00:28.595
email but I'll put my Twitter
info on the last slide if you

00:00:28.595 --> 00:00:35.702
need it on so I guess we'll just
go and get started here all the

00:00:35.702 --> 00:00:39.506
standard a little bit about
myself I'm a PhD student at the

00:00:39.506 --> 00:00:42.609
University of Maryland Baltimore
County trying to find out what

00:00:42.609 --> 00:00:46.680
it means to be a good malware
data set I've been actively

00:00:46.680 --> 00:00:49.583
studying and researching infosec
for about three years now some

00:00:49.583 --> 00:00:52.386
still bit of a new but I'm
trying to bridge the gap between

00:00:52.386 --> 00:00:57.424
academia and industry and I'm
currently a seven point

00:00:57.424 --> 00:01:00.761
international finishing up a few
summer projects involving both

00:01:00.761 --> 00:01:07.768
infosec and machine learning
talk into a few major segments

00:01:07.768 --> 00:01:10.904
first I want to talk about the
current state of the delay and

00:01:10.904 --> 00:01:13.640
delay controversy in what
working with one actually looks

00:01:13.640 --> 00:01:16.743
like and then will switch gears
and move into the machine

00:01:16.743 --> 00:01:20.013
learning background necessary to
understand how deeply class

00:01:20.013 --> 00:01:24.418
fireworks we don't have the
money right now for talking

00:01:24.418 --> 00:01:27.454
quantum classification malware
there is going to be a little

00:01:27.454 --> 00:01:33.460
bit of technical stuff around
the on so I hope that's okay not

00:01:33.460 --> 00:01:37.798
what finally this Atlanta our
design choices and

00:01:37.798 --> 00:01:40.267
implementation details of
actually getting on our

00:01:40.267 --> 00:01:45.205
classifier onto the DB2 instance
that my university has access to

00:01:45.205 --> 00:01:48.709
and we found some interesting
things as we played around to

00:01:48.709 --> 00:01:51.745
wrap this up with some
interesting observations and

00:01:51.745 --> 00:01:57.417
everything search might actually
be useful some of us are ears

00:01:57.417 --> 00:02:00.287
heard about quantum computing
and how to bring all her

00:02:00.287 --> 00:02:04.224
criticisms and all the things
like I had a dance with the you

00:02:04.224 --> 00:02:08.829
are in arrears for the complete
loss of quantum computers that

00:02:08.829 --> 00:02:13.200
allow us to no communicate
perfectly securely and no help

00:02:13.200 --> 00:02:19.339
us do all the things right
answer on my software I just

00:02:19.339 --> 00:02:22.309
want to lower everybody's
occasions the do it doesn't do

00:02:22.309 --> 00:02:25.812
any of that right all regardless
of the state of standard quantum

00:02:25.812 --> 00:02:31.518
computing viewing doesn't do
that in fact there's a lot of

00:02:31.518 --> 00:02:34.588
lowering expectations that I
needed to hear visible some

00:02:34.588 --> 00:02:37.424
misinformation about the way
when it first came out and let's

00:02:37.424 --> 00:02:41.928
go and get out of the way you
might've heard that the D-wave

00:02:41.928 --> 00:02:45.365
solved NP complete problems in
polynomial time this is

00:02:45.365 --> 00:02:47.367
definitely that he doesn't solve
and peaceably problems now you

00:02:47.367 --> 00:02:52.672
might think of solutions to
these problems but it's

00:02:52.672 --> 00:02:55.675
important to remember that often
we can do that classically to

00:02:55.675 --> 00:03:00.714
it's also hard question as to
whether the wave is better at

00:03:00.714 --> 00:03:03.784
solving any real-world problems
at this moment than classical

00:03:03.784 --> 00:03:07.387
machines there's a few papers
arguing that the delay

00:03:07.387 --> 00:03:10.791
outperforms classical machines
already but so far these been

00:03:10.791 --> 00:03:14.561
pretty spurious comparisons more
specialized classical software

00:03:14.561 --> 00:03:19.199
was able to outperform the
D-wave on the now course that's

00:03:19.199 --> 00:03:22.669
not to say that if you become
better than standard cluster

00:03:22.669 --> 00:03:28.375
computing future but it still
don't waste and because of all

00:03:28.375 --> 00:03:31.011
this misinformation it's no
surprise that there's a lot of

00:03:31.011 --> 00:03:34.881
polarized debate about what the
can do to my knowledge this is

00:03:34.881 --> 00:03:39.119
the current state of affairs
regarding the delay first facts

00:03:39.119 --> 00:03:43.590
are right all this might not
actually be interesting quantum

00:03:43.590 --> 00:03:47.661
effects have been everywhere
even in like NAND flash sample

00:03:47.661 --> 00:03:50.297
the question everyone's
interested in is whether the

00:03:50.297 --> 00:03:53.633
delay uses quantum effects for
computation and whether

00:03:53.633 --> 00:03:58.572
implementation will or might
perform all better in the future

00:04:00.774 --> 00:04:04.511
regardless The Standard Quantum
Albums That Everyone Gets

00:04:04.511 --> 00:04:08.515
Excited about And If You Do Try
to Say This Pretty Clearly in

00:04:08.515 --> 00:04:12.352
Every Presentation about Ever
Been It Looks like They've Made

00:04:12.352 --> 00:04:15.155
Some Design Choices in the
Pursuit of Solving NP Complete

00:04:15.155 --> 00:04:19.126
Problems Which Means Universal
Quantum Computation Can't Happen

00:04:19.126 --> 00:04:23.430
on the DV Machines Was Also to
Their Credit They Have Made

00:04:23.430 --> 00:04:26.833
Several Advances on Cooling and
on Power Consumption Tronic

00:04:26.833 --> 00:04:29.936
Devices And I've Also Heard That
Some of Their Techniques Might

00:04:29.936 --> 00:04:36.076
Be Useful for Scaling Even
Standard Quantum Computation So

00:04:36.076 --> 00:04:39.579
It's a Non-Technical Stuff Right
Most of You Probably Seen This

00:04:39.579 --> 00:04:43.316
Picture before All This Is like
to Do a Case It's a Big Black

00:04:43.316 --> 00:04:48.722
Box about the Size of This And
If You Opened up This Is What

00:04:48.722 --> 00:04:53.793
You See inside On This
Contraption Is Mostly for The

00:04:53.793 --> 00:04:56.997
Bottles Has A Lot Of Room for a
Technician to Stand inside for

00:04:56.997 --> 00:05:01.434
Repairs and Whatnot But the Chip
Is Finding out the Bottom Can't

00:05:01.434 --> 00:05:06.206
Even Really See from Here So
Here's a Close Right There's

00:05:06.206 --> 00:05:09.509
Actually A Lot Of Classical
Certain Circuits on This to All

00:05:09.509 --> 00:05:16.283
Only about Middle {Where I Don't
See It Is the Quantum Part And

00:05:16.283 --> 00:05:22.823
Again This Year to See Some
Initial Close-Up On the So This

00:05:22.823 --> 00:05:26.326
Is Actually Check This Is the
Washington The Thousand Chip

00:05:26.326 --> 00:05:29.629
That Just Came out This Summer
But Structure Is Pretty Similar

00:05:29.629 --> 00:05:34.134
to What We Were Just Figure You
Might Actually Be Able to See a

00:05:34.134 --> 00:05:37.504
Faint Grid on the Chart That's A
Lot Of of What Do You Think the

00:05:37.504 --> 00:05:45.345
Cubans So There Was A Lot Of
Yoga Loops Which Is Where the

00:05:45.345 --> 00:05:49.249
Possible Quantum Behavior Comes
from These Lives Are Magnetized

00:05:49.249 --> 00:05:52.419
and Then They Handle with
Intersect At Least I Think We

00:05:52.419 --> 00:05:54.955
Have Consensus That the
Containment This Intersection

00:05:54.955 --> 00:05:59.693
Points but As with Everything
Else That Still Hotly Debated

00:05:59.693 --> 00:06:03.196
The Idea Is That These Loops
Want to Be an Agreement Which

00:06:03.196 --> 00:06:05.966
Will Happen If the Minimal
Energy State of the System So

00:06:05.966 --> 00:06:11.037
Think like Norton North Repels
More In South South We Want All

00:06:11.037 --> 00:06:15.876
of These Different On
Magnetization's to Be Pointing

00:06:15.876 --> 00:06:23.316
Different Directions So the Way
This Program by Advising Many of

00:06:23.316 --> 00:06:27.354
Them Loops The Couplers Which
Govern Their Interactions This

00:06:27.354 --> 00:06:32.459
Formula Here Is How You
Represent That Mathematically

00:06:32.459 --> 00:06:35.428
Given His Views Which Are All
Real Numbers The Delay Comes the

00:06:35.428 --> 00:06:39.599
Final Assignment of Cues Such
That This Formula Is Minimized

00:06:39.599 --> 00:06:44.104
We Normally Work with You Being
Either 01 And When the Case This

00:06:44.104 --> 00:06:47.240
Is Known As a Quadratic
Unconstrained Area Optimization

00:06:47.240 --> 00:06:52.145
Problem Or Cuba for Short It
Turns out That If We Could Softy

00:06:52.145 --> 00:06:57.183
Was Pretty Easily and Actually
Used But He Doesn't Always Get

00:06:57.183 --> 00:07:00.487
the Absolute Minimum Solution So
the Company Now Call Their

00:07:00.487 --> 00:07:06.993
Machine a Heuristic for Solving
the Sorts of Problems So We You

00:07:06.993 --> 00:07:10.797
Receive Access to the Way to
Instance in Burnaby Canada Do

00:07:10.797 --> 00:07:14.134
You Has Built a Little Website.
Everything For Submitting

00:07:14.134 --> 00:07:17.871
Programs and Parameters for
Running Them to the Machine They

00:07:17.871 --> 00:07:21.374
Also Have API Access Which Is
Basically like Using Old for

00:07:21.374 --> 00:07:27.380
Those of You Can Google Apps
before And When You Want to Play

00:07:29.416 --> 00:07:32.252
with a Trip to Their Website You
Get a Visual Representation

00:07:32.252 --> 00:07:35.455
Looking like This All the Time
Your Graph This Is the System

00:07:35.455 --> 00:07:40.093
Six Processor That We Had Access
to When We First Experiments Now

00:07:40.093 --> 00:07:43.063
the First Thing You'll Notice Is
All the Spots Where Nodes Are

00:07:43.063 --> 00:07:47.467
Missing Physical Debt Units or
Qubits Which Are Defective And

00:07:47.467 --> 00:07:51.071
It Programmers Can't Interact
with Those That It's All And

00:07:51.071 --> 00:07:53.073
There Assume That They Don't
Interfere with Any of the

00:07:53.073 --> 00:07:57.110
Computations There Determined
When the Machine Boots up so We

00:07:57.110 --> 00:08:01.981
Can Fix Those That Kibitz but It
Can Also Kill All the Runs

00:08:01.981 --> 00:08:05.652
Reboots of the Viewing Don't
Happen Often All Probably like

00:08:05.652 --> 00:08:10.423
Every Two Months or so in My
Experience Out Of 512 Cubits We

00:08:10.423 --> 00:08:17.864
Had Maximum This System Six Chip
Has 496 Working But Now Compare

00:08:17.864 --> 00:08:21.368
That to the System 13 Jet Which
Is What We Have Access to Now

00:08:21.368 --> 00:08:25.438
Write There's A Lot More
Documents on This Trip The Take

00:08:25.438 --> 00:08:29.476
Away from Here Is Just Because I
Call It a 512 Cuban Machine

00:08:29.476 --> 00:08:35.181
Doesn't Mean the Machine
Actually Has All 512 Those

00:08:35.181 --> 00:08:39.386
Qubits And Finally Here's an
Example of an Optimization

00:08:39.386 --> 00:08:43.056
Problem Run on the System
Fixture The Left Is What We

00:08:43.056 --> 00:08:46.393
Input to the Machine Each
Colored Notoriety Corresponds

00:08:46.393 --> 00:08:50.930
the Bias That We Gave It On the
Right Is What Was Returned to Us

00:08:50.930 --> 00:08:54.601
by the Way And Again Each Color
Corresponds to Keep His Final

00:08:54.601 --> 00:08:57.837
State I Think Red Means That the
Qubit Measured at the End Was

00:08:57.837 --> 00:09:00.974
Positive One and Blue Means That
They Keep It at the End of the

00:09:00.974 --> 00:09:05.044
Run Was -1 But We like to Work
with Binary Variables So We

00:09:05.044 --> 00:09:07.881
Apply Simple Substitution
Function to Change the -Ones to

00:09:07.881 --> 00:09:15.588
Zeros So Far We've Been Talking
about Documents In Working

00:09:15.588 --> 00:09:19.192
Directly onto the Director Now
There Are Certain Problems like

00:09:19.192 --> 00:09:23.129
Reset Which Actually Simply
Transform into Those And As a

00:09:23.129 --> 00:09:25.698
Side Note This Is Why the
Company Is so Interested in

00:09:25.698 --> 00:09:30.503
Three Set However You Is Also
Developed Some Closer Software

00:09:30.503 --> 00:09:33.273
to Embed Arbitrary Minimization
Problems And They Call the

00:09:33.273 --> 00:09:39.045
Software Blackbox Generally the
Problem of Embedding an

00:09:39.045 --> 00:09:42.082
Arbitrary Minimization Problem
onto the Time Your Graph Is NP

00:09:42.082 --> 00:09:47.120
Complete It's Very Similar to
the Subgraph Isomorphism Problem

00:09:47.120 --> 00:09:50.390
There Might Still Be Solutions
for Particular Graphs Rather

00:09:50.390 --> 00:09:52.692
Than Actually Solving the
Problem for a Chat with Given

00:09:52.692 --> 00:09:57.130
That Qubits Do It Instead Uses a
Heuristic Called to Search For

00:09:57.130 --> 00:10:02.068
Embedding Problems onto the
Director Blackhawks Involves a

00:10:02.068 --> 00:10:06.105
Dialogue between This Classical
to Do Algorithm In the Direction

00:10:06.105 --> 00:10:09.375
And What I Mean by This Is the
to You Album on a Classical

00:10:09.375 --> 00:10:12.645
Machine Finds What He Thinks Is
a Good Embedding for Some Chunk

00:10:12.645 --> 00:10:16.182
of the Problem And Then This
Talk Is Sent over to the Wafer

00:10:16.182 --> 00:10:21.454
Salt The Solution Is Passed Back
from the Delay to This to the

00:10:21.454 --> 00:10:25.225
Search Algorithm Which Uses Data
Input for the Next Iteration

00:10:25.225 --> 00:10:28.928
Often the Problem And This
Continues until the Machine

00:10:28.928 --> 00:10:32.565
Can't Find a Better Solution Or
until Specified Timeout Is

00:10:32.565 --> 00:10:37.337
Reached So A Lot Of Our Time in
Blackbox Programs Is Actually

00:10:37.337 --> 00:10:40.940
Wasted Just Due To Network
Latency As Part of This Dialogue

00:10:44.511 --> 00:10:47.247
But Actually Coding This All on
Straightforward Right Here's an

00:10:47.247 --> 00:10:50.250
Example of Some Python Code
Which Connects the System Six

00:10:50.250 --> 00:10:54.420
Processor and Minimizes a Given
Function You Basically Just Put

00:10:54.420 --> 00:10:58.825
in the Software You Want to Use
Some Parameters and a Function

00:10:58.825 --> 00:11:03.363
Which Just Returns a Value for
How Good a Given Bit String Is

00:11:03.363 --> 00:11:06.099
And Then Blackbox Will Look for
the Best Bit String to Minimize

00:11:06.099 --> 00:11:12.138
That Function Susan: All the
Question Is What Can This

00:11:12.138 --> 00:11:16.843
Machine Do Now Do It A Lot Of
Applications like Classification

00:11:16.843 --> 00:11:20.780
Protein Folding Problems Solving
Getting Close to Optimal

00:11:20.780 --> 00:11:24.951
Solutions to NP Complete Problem
Traveling Salesman On They Do

00:11:24.951 --> 00:11:28.788
Have Way Tutorials for Most of
These on Their Website But It's

00:11:28.788 --> 00:11:33.793
Not Quite Clear to Me How Those
Toys Size Tutorials Scale to

00:11:33.793 --> 00:11:40.166
Larger Problem So Now Were to
Switch Gears a Little Bit and

00:11:40.166 --> 00:11:45.271
Talk about the Machine Learning
Background Necessary for the

00:11:45.271 --> 00:11:48.274
Delay. On My Can Obviously Get
through Everything to Do with

00:11:48.274 --> 00:11:51.711
Machine Learning the Time We
Have Available to Us Today But I

00:11:51.711 --> 00:11:55.114
Want to Try to Go through What's
Relevant to This Project When

00:11:55.114 --> 00:11:57.717
Assume You Guys Know about like
Supervising Unsupervised

00:11:57.717 --> 00:12:01.387
Classification. If You Don't
Definitely Check out Alex

00:12:01.387 --> 00:12:05.058
Mendoza Roberts Talks Their
Amazing But We're Using the

00:12:05.058 --> 00:12:08.194
Supervised Technique Here Which
Means That the Instances We Feed

00:12:08.194 --> 00:12:11.631
into the Album We Create Are
Labeled before We Train Our

00:12:11.631 --> 00:12:18.938
Classifier The Direct Classifier
We Look at Is a Boosting Out Of

00:12:18.938 --> 00:12:22.742
Them And to Explain This Concept
I'm Borrowing from Good Tutorial

00:12:22.742 --> 00:12:25.478
I Read Recently The Only Check
It out If You're Interested in

00:12:25.478 --> 00:12:29.649
Machine Learning But It's Very
Similar to Eric Correcting Codes

00:12:29.649 --> 00:12:33.553
If Any of You Work with Signal
Processing Let's Say We Have

00:12:33.553 --> 00:12:39.559
Three Programs That Classify
Malware And Further Let's

00:12:42.362 --> 00:12:44.964
Suppose Any Single One of These
Programs Is a 70% Probability of

00:12:44.964 --> 00:12:47.133
Being Correct for Any Given
Instance You Can't Simply Choose

00:12:47.133 --> 00:12:49.502
Any Single Classifier and Be
Happy with Getting 30% of Your

00:12:49.502 --> 00:12:53.906
Is Wrong Or You Could Be a Bit
Smarter Than Mine A Simple Way

00:12:53.906 --> 00:12:57.510
to Combine Them Is by Running
Each of Your Three Classifiers

00:12:57.510 --> 00:13:00.647
On Instance and Use Whichever
Classification the Majority

00:13:00.647 --> 00:13:05.184
Signs Is Your Final Guess During
This Your New Classifier Can Be

00:13:05.184 --> 00:13:09.789
Right in Our Example up to 78%
of the Time Because Now the New

00:13:09.789 --> 00:13:12.558
Classifier Will Be Correct
Whenever At Least Two The Old

00:13:12.558 --> 00:13:15.895
Classifiers Guess Correctly You
Can Actually Check This by

00:13:15.895 --> 00:13:20.099
Writing out the Probabilities
before Cases When 012 and Three

00:13:20.099 --> 00:13:26.205
Classifies Actually Correct But
Many Using Algorithms Allow You

00:13:26.205 --> 00:13:29.976
to Give Us Some Wii Classifiers
More Weight Than Others Though

00:13:29.976 --> 00:13:32.845
What We Look on the Delay
Doesn't Interestingly the Do

00:13:32.845 --> 00:13:35.581
Everything Out Of Them Does
Pretty Well Even In Spite Of

00:13:35.581 --> 00:13:41.621
Being Simpler So First Deftly
Don't Be Scared by the Equation

00:13:41.621 --> 00:13:44.023
There Is Really Not That
Important I Went to Try to Talk

00:13:44.023 --> 00:13:47.894
Is There But Let's Talk about
This Whole Process As a

00:13:47.894 --> 00:13:53.066
Minimization Function Because
the Delay Likes to Minimize the

00:13:53.066 --> 00:13:55.902
Central to the Idea of Machine
Learning Algorithms Is the Idea

00:13:55.902 --> 00:13:58.738
of Loss Function or
Quantification of How Poorly a

00:13:58.738 --> 00:14:02.442
Classifier Performs The Idea Is
That You Want to Minimize the

00:14:02.442 --> 00:14:07.413
Sauce Now Generally Losses the
Parts We Want to Minimize the

00:14:07.413 --> 00:14:10.583
The Number of Misclassification
That Are Model Creates And We

00:14:10.583 --> 00:14:14.887
Want Our Model to Be As Simple
As Possible In Our Case We Have

00:14:14.887 --> 00:14:17.590
a Set of Classifiers and Were
Trying to Find Which Subset of

00:14:17.590 --> 00:14:20.860
Classifiers Can Be Boosted Using
Majority Vote into the Best

00:14:20.860 --> 00:14:24.030
Possible Classifier In This
Scary Formula Is Just a

00:14:24.030 --> 00:14:28.167
Modification of That This Is an
Example of a Loss Function That

00:14:28.167 --> 00:14:30.903
We Actually Used for a Class
Parties As a Function Block Box

00:14:30.903 --> 00:14:34.040
That Were Trying to Minimize In
a Mostly Including This for

00:14:34.040 --> 00:14:37.443
People Looking at the Slides
Later I Will Say Though That the

00:14:37.443 --> 00:14:40.213
Sign of the W Soundly Asked Her
What Her Boosted Classifier

00:14:40.213 --> 00:14:44.016
Guesses the Executables Are And
Then This Is Compared to Whether

00:14:44.016 --> 00:14:46.986
the Executable Is Actually
Labeled to Be Malicious or Not

00:14:46.986 --> 00:14:51.057
and If They Differ And That's
Called Mass Classification And

00:14:51.057 --> 00:14:54.160
out + Is Just a Term Which
Penalizes Using A Lot Of Wii

00:14:54.160 --> 00:15:00.166
Classifiers So the Final Machine
Learning Ingredient Your

00:15:06.339 --> 00:15:10.743
Classifier Is the Features We
Use Now We Used an Grams Which

00:15:10.743 --> 00:15:14.781
Is a Standard Type Feature Used
in Document Analysis We

00:15:14.781 --> 00:15:17.717
Attendees and Dems from the Heck
Stumps of Malware and Benign

00:15:17.717 --> 00:15:22.922
Software You Can Think of an
Grams As the Sliding Window

00:15:22.922 --> 00:15:26.959
Overtaxed So If You Consider the
Has Staying Deadbeat I'll Go

00:15:26.959 --> 00:15:30.496
Ahead and Give an Example of 2
MB of Diagrams and Remember That

00:15:30.496 --> 00:15:35.168
One Bite Is Just Too Texted Its
So We Take Her First Two Bites

00:15:35.168 --> 00:15:38.137
and That's One by Graham And
Then We Take Two Bites with an

00:15:38.137 --> 00:15:42.408
Offset One and That's Another by
Graham And We Keep Going until

00:15:42.408 --> 00:15:46.245
We Reach the End of the Extra So
Here's the Final Diagram And so

00:15:46.245 --> 00:15:52.251
Their 32 MB and Debbie DAD ADB
and Be Now We Actually Use

00:15:54.754 --> 00:15:57.857
Trigrams of the Programs so
Three by Sliding Window Instead

00:15:57.857 --> 00:16:01.561
of a 2 x 1 As a Basis for a
Classifier That Doesn't Really

00:16:01.561 --> 00:16:06.232
Change Much There's A Few
Reasons Why We Chose Engrams of

00:16:06.232 --> 00:16:09.368
Her Other Features They've Been
Used before Malware with These

00:16:09.368 --> 00:16:13.339
Results First off But We Mostly
Use Them Because We Had No Idea

00:16:13.339 --> 00:16:16.676
How Many Features to Be with
Handle It's Easy to Generate a

00:16:16.676 --> 00:16:19.812
Large Number of Features with
Engrams And Then to Preprocess

00:16:19.812 --> 00:16:23.683
Them down to Any Given Number
And It's Also Trivial to Turn

00:16:23.683 --> 00:16:27.019
These Engrams and We Classify As
You Can Have Just Simply Whether

00:16:27.019 --> 00:16:29.889
or Not the Engrams Present in
the Executable As Being a We

00:16:29.889 --> 00:16:36.629
Classify Obviously since Were
Only Using 3 G What We Build

00:16:36.629 --> 00:16:38.631
Won't Be As Good As
State-Of-The-Art Malware

00:16:38.631 --> 00:16:41.634
Classifiers We Don't Need It to
Be the Best in Our Class Are in

00:16:41.634 --> 00:16:44.871
Existence Here Though Were Just
Using It to Compare Classifiers

00:16:44.871 --> 00:16:47.273
between the D-Wave Machine in
Standard Classical Machine

00:16:47.273 --> 00:16:53.512
Learning Techniques Now
Hopefully All of That Wasn't Too

00:16:53.512 --> 00:17:01.153
Painful And We Can Get into All
the Fun Stuff At First Glance

00:17:01.153 --> 00:17:03.756
the Dealer Looks like It's Going
to Be Awesome for Classifying

00:17:03.756 --> 00:17:07.193
Malicious Executables There's an
Out Of Them Already Developed

00:17:07.193 --> 00:17:11.831
Called Cubist Freezing That He
Would Classify Things Cubist

00:17:11.831 --> 00:17:15.501
Models in the Paper Had Higher
Accuracy Than At Least One

00:17:15.501 --> 00:17:20.206
Entered Classical Boosting
Algorithm Called Database What's

00:17:20.206 --> 00:17:24.277
Really Interesting Here Is That
Depending on the Lost on to Use

00:17:24.277 --> 00:17:28.948
The Classifier Can Be Robust to
Label Voice Generally If You're

00:17:28.948 --> 00:17:32.652
Wrong about A Lot Of the Samples
in a Training Set Then Many

00:17:32.652 --> 00:17:36.489
Algorithms That You Apply to It
Will Learn Incorrectly If an

00:17:36.489 --> 00:17:39.992
Album's Robust Label Noise
However Short of Catastrophic

00:17:39.992 --> 00:17:43.162
Failure Labeling Bill Still
Generally Learn Even If a

00:17:43.162 --> 00:17:47.366
Significant Number of Instances
Are Mislabeled And As You Trim

00:17:47.366 --> 00:17:50.336
Our Classifying How to Tell It
Whether Each Instance Is Benign

00:17:50.336 --> 00:17:54.607
or Malicious Obtaining
Background through This Hard In

00:17:54.607 --> 00:18:01.414
This Domain Even As We Found in
Our Lab But Finally I Found a

00:18:01.414 --> 00:18:04.784
Call with the Creator Cubist
Documents As Early Scale to

00:18:04.784 --> 00:18:08.788
What's Known As Google Size
Problems However like Box

00:18:08.788 --> 00:18:12.258
Handles Trunking of Problems and
so It Supposedly Can Scale to

00:18:12.258 --> 00:18:16.095
Larger Problems I Was There Also
Was a Tutorial for Implement and

00:18:16.095 --> 00:18:18.631
Keep His Lawyer Using the
Blackboard Software And It

00:18:18.631 --> 00:18:25.938
Looked Pretty Easy to Do So
That's What We Did Here Our Goal

00:18:25.938 --> 00:18:29.008
at the Time of This Research Was
to Classify Executables As

00:18:29.008 --> 00:18:32.645
Either Being Malicious or Benign
Of Course There's Loads of

00:18:32.645 --> 00:18:36.215
Malicious Data Sets to Choose
from We Use Via Kevin Which Is a

00:18:36.215 --> 00:18:39.852
Pretty Standard Data Set for
Training Malware Classifiers

00:18:39.852 --> 00:18:42.321
Although Now It's Starting to
Show Its Age It's like 10 Years

00:18:42.321 --> 00:18:47.026
Old by Now However There's No
Standard Nine Software Data Sets

00:18:47.026 --> 00:18:50.830
and This Is Pretty Problematic
For Benign SQLs Is the

00:18:50.830 --> 00:18:54.200
Combination of Executables Found
in Clean Windows XP and Seven

00:18:54.200 --> 00:18:57.737
Installs And the Executables
Resulting from Installation of

00:18:57.737 --> 00:19:01.040
Sick Women and Certain Source
Forge Executables Based on Some

00:19:01.040 --> 00:19:04.977
Previous Work We Did Never
Thought Don't Do This On We

00:19:04.977 --> 00:19:08.814
Don't Claim That This Is An
Acceptable Data Set for Future

00:19:08.814 --> 00:19:12.184
Malware Classification It's Not
Very Diverse Are Representative

00:19:12.184 --> 00:19:15.287
of the NYNEX Cables and General
Were Actually Trying to Solve

00:19:15.287 --> 00:19:19.925
That Problem Now But As a Final
Note on Data Sets We Do Know

00:19:19.925 --> 00:19:22.561
about the Source for the
Hardware And We Would like to

00:19:22.561 --> 00:19:25.865
Make the Disclaimer That No
Adware Was Used This Test Fire

00:19:30.636 --> 00:19:33.272
So There's Some Classical
Preprocessing That We Did before

00:19:33.272 --> 00:19:37.777
We Do This Thing onto Blackbox
First You'll Notice That We Have

00:19:37.777 --> 00:19:43.749
Tons More Malware Nine Examples
If We Created a Problem to a

00:19:43.749 --> 00:19:46.952
Program to Classify Executables
That Always Return That the

00:19:46.952 --> 00:19:50.423
Executable Was Malicious That
Program Would Do Extremely Well

00:19:50.423 --> 00:19:53.092
on Our Data Set Even Though It's
Not Actually Learning What

00:19:53.092 --> 00:19:58.497
Malware Actually Is Right Just
like a Random Number Generator

00:19:58.497 --> 00:20:03.436
That Always Returns for Isn't
Really Random To Get around This

00:20:03.436 --> 00:20:06.539
Issue We Sampled with
Replacement And There's Some

00:20:06.539 --> 00:20:10.743
Upside and Some Downsides That
On the First Leg Classifies It

00:20:10.743 --> 00:20:13.679
Back to the Train We Are
Throwing A Lot Of Information

00:20:13.679 --> 00:20:17.917
the Way by Doing so Sampling
with Replacement Also Has Some

00:20:17.917 --> 00:20:20.853
Good Statistical Properties for
the Underlying Distribution If

00:20:20.853 --> 00:20:25.691
You Care about That Sort of
Thing Now We Use 3 G Is the

00:20:25.691 --> 00:20:29.028
Basis for a Classifier Knowing
That What We Built Here Won't Be

00:20:29.028 --> 00:20:32.398
As Good As State-Of-The-Art
Systems There Were Not Turning

00:20:32.398 --> 00:20:35.501
Any Heads of the Accuracy of the
Models We Built Here The Models

00:20:35.501 --> 00:20:38.003
Will Be Complex Enough to
Compare Accuracy and Timing

00:20:38.003 --> 00:20:43.409
Information And I've Done All
This Is Simple Python Program

00:20:43.409 --> 00:20:46.612
Which Uses Blackbox along with
the System 60 with Two Instance

00:20:46.612 --> 00:20:49.648
That We Have Access to To
Minimize That Scary Loss

00:20:49.648 --> 00:20:53.786
Function from Earlier That's
Actually What, Are Our

00:20:53.786 --> 00:20:58.457
Classifier It Will Determine
Which Engrams Using Majority

00:20:58.457 --> 00:21:04.463
Vote Best Classifier Malware So
When We First Ran over

00:21:06.565 --> 00:21:10.369
Classifier It Wasn't Doing Any
Better Than Random Chance We Did

00:21:10.369 --> 00:21:13.439
Some Digging and Found the Black
Boxes Using up All the Way Time

00:21:13.439 --> 00:21:18.577
That We Actually A Lot To Solve
This Problem We Needed to

00:21:18.577 --> 00:21:21.113
Increase the Amount of Time That
We Allowed Blackbox to Search

00:21:21.113 --> 00:21:24.250
for Solutions But the Question
Is How Much Time We Actually

00:21:24.250 --> 00:21:27.686
Need to Get It To Get Reasonable
Accuracy on a Problem with the

00:21:27.686 --> 00:21:34.393
Given Number of Variables So
Previous Work Using Blackbox

00:21:34.393 --> 00:21:37.062
Mostly Deals with NP Complete
Problems so They All Use a

00:21:37.062 --> 00:21:41.333
Rather Large and Arbitrary 30
Minute Timeout In Many Classical

00:21:41.333 --> 00:21:43.903
Models on the Scale That We
Built in the past Especially

00:21:43.903 --> 00:21:47.173
after Resampling to Smaller
Numbers of Executables Trenton A

00:21:47.173 --> 00:21:52.511
Few Seconds to Minutes so This
Is an Extremely Large Time We

00:21:52.511 --> 00:21:55.481
Originally Thought That Slimming
down the Problem in This Way

00:21:55.481 --> 00:21:57.850
Would Give Us a Reasonable
Decrease in the Time Required to

00:21:57.850 --> 00:22:00.753
Solve the Problem But We Quickly
Found out That This Wasn't the

00:22:00.753 --> 00:22:05.024
Case Even for Minimize Asian
Problems With Small Numbers of

00:22:05.024 --> 00:22:08.894
Binary Variables It Took over 10
Minutes to Get a Decent

00:22:08.894 --> 00:22:14.033
Solutions But We Still Pressed
on Just in Case May Be Some

00:22:14.033 --> 00:22:17.403
Accuracy Increase Might Justify
a 10 Minute Model Creation Time

00:22:17.403 --> 00:22:23.409
Even for Very Very Simple Models
So As a Result of Our Pilot

00:22:29.715 --> 00:22:34.320
Study We Decided to Restrict Our
Classifier to 32 Features The

00:22:34.320 --> 00:22:37.056
Balance of Complexity the
Classifier with the Time It Took

00:22:37.056 --> 00:22:41.160
to Train Now 32 Features Is a
Very Very Small Number of

00:22:41.160 --> 00:22:44.296
Features for Machine Learning
Problems But We Found It Took

00:22:44.296 --> 00:22:47.733
Almost an Hour to Train a Single
Model And We Have Limited

00:22:47.733 --> 00:22:53.973
Allotment of Time on the Buick
Machine We Kinda Na√Øvely Split

00:22:53.973 --> 00:22:58.510
Those 32 Trigrams from Earlier
into 16 Each of Benign and

00:22:58.510 --> 00:23:02.314
Malware Features Then We Use the
Same Python Code from Earlier to

00:23:02.314 --> 00:23:05.584
Trends and Classifiers And We
Noted the Time to Taking the

00:23:05.584 --> 00:23:09.255
Train The Accuracy And Which
Features Were Present in the

00:23:09.255 --> 00:23:13.659
Final Booster Classifier We Did
That on the UHF and the Delay

00:23:13.659 --> 00:23:19.832
Simulator Which Is Classical
Nature Using the Same Features

00:23:19.832 --> 00:23:22.801
We Compared the Buick Classifier
to Several Models We Built Using

00:23:22.801 --> 00:23:27.306
What Which Is a Voting Machine
Learning Library Written in Java

00:23:27.306 --> 00:23:31.877
We Compared the Classified Eight
of Most J 48 Decision Trees In

00:23:31.877 --> 00:23:35.981
Rain Forests It Should Be Pretty
Obvious When Compared to Those

00:23:35.981 --> 00:23:39.084
like Ada Boosting Cubist Have
Been Compared to before And

00:23:39.084 --> 00:23:43.923
These Are Similar Techniques MJ
48 and Random Foresight Easy to

00:23:43.923 --> 00:23:47.693
Use Techniques That Work Right
Out Of the Box And Also Been

00:23:47.693 --> 00:23:52.197
Shown I Think Could Be Pretty
Good with Malware As Well But

00:23:52.197 --> 00:23:55.534
I'll Just Take a Minute to Let
You All Look at Our Results And

00:23:55.534 --> 00:23:58.170
There Are Two Major Things That
Look Super Weird about This

00:23:58.170 --> 00:24:05.477
Maybe You Guys Can Spot It So
Yeah Our First Finding Is That

00:24:05.477 --> 00:24:08.147
for Quantum Speed up the Thing
Is Extremely Slow Compared to

00:24:08.147 --> 00:24:12.351
Classical In Fact the Timing for
the Delay Stuff Is Actually

00:24:12.351 --> 00:24:16.288
Underreported We Only Included
the Total Time That the D-Wave

00:24:16.288 --> 00:24:19.391
Itself Was Running On Our
Problems so That We Don't

00:24:19.391 --> 00:24:23.562
Include Any Latent He Caused by
the Network in This Calculation

00:24:23.562 --> 00:24:27.032
Remember the Black Box Involves
a Conversation between Classical

00:24:27.032 --> 00:24:31.470
and Quantum Hardware As a Side
Effect the Classical Time for

00:24:31.470 --> 00:24:34.073
the True Other Than from
Blackbox Isn't Actually Included

00:24:34.073 --> 00:24:39.545
in the Time Taken to Build the
Delay Classifier Now We Found

00:24:39.545 --> 00:24:42.815
You to Be Middle-Of-The-Road on
Accuracy But It Takes 10 --> 000

00:24:42.815 --> 00:24:46.552
Times on the Train And Remember
the Other Out Of Them Scale But

00:24:46.552 --> 00:24:49.688
We Had to Heavily Restrict Our
Numbers of Features in Order to

00:24:49.688 --> 00:24:55.394
Train the Delete Classifier in a
Reasonable Amount of Time No We

00:24:55.394 --> 00:24:59.465
Don't Know Why It Takes so Long
but We Do Have A Few Guesses

00:24:59.465 --> 00:25:02.701
It's Possible That Blackbox Is
Finding Very Good in Beddings Or

00:25:02.701 --> 00:25:05.604
Maybe the D-Wave Isn't Actually
Getting Good Enough Solutions on

00:25:05.604 --> 00:25:07.606
the Also You Have Those
Documents from Earlier a Release

00:25:07.606 --> 00:25:09.708
from the Black Box Or It Could
Also Be That Black Box Is Trying

00:25:09.708 --> 00:25:16.215
to Solve the Next Financial
Problem We Don't Really Know

00:25:16.215 --> 00:25:21.387
Right Now But Our Second
Interesting Result Is That the

00:25:21.387 --> 00:25:25.157
Delay Simulator Which Is Again
Classical Nature Takes Less Time

00:25:25.157 --> 00:25:27.893
to Train the Natural Beauty
Check And That's Kind of

00:25:27.893 --> 00:25:31.096
Surprising to His Late Wife I Do
It When You Can Just Use the You

00:25:31.096 --> 00:25:35.634
Have Simulator on Your Laptop
Right We Think This Might Be an

00:25:35.634 --> 00:25:38.771
Artifact of Dead Qubits Because
the Simulator Assumes a Perfect

00:25:38.771 --> 00:25:42.508
View But Is Still Really Really
Weird That the Simulator for the

00:25:42.508 --> 00:25:49.481
Delay Actually Outperformed the
Actual Chip So What Does This

00:25:49.481 --> 00:25:52.985
All Mean Right We Found the Wall
As Possible to Create a Malware

00:25:52.985 --> 00:25:56.588
Classifier Using the D-Wave And
That It Has Similar Accuracies

00:25:56.588 --> 00:25:58.924
to Standard Machine Learning
Techniques It's Not Very

00:25:58.924 --> 00:26:02.261
Practical There Significant
Overhead and We Need to Restrict

00:26:02.261 --> 00:26:06.298
the Problem Substantially We
Don't Know Exactly Where This

00:26:06.298 --> 00:26:09.368
Overhead Comes from It Could Be
from DB Software to Embed

00:26:09.368 --> 00:26:13.639
Arbitrary Minimization Problems
onto the Director Or Could Come

00:26:13.639 --> 00:26:17.876
from the Direction Itself Not
Finding Enough Solutions However

00:26:17.876 --> 00:26:22.080
Were Betting the Black Box Is
the Problem Here Regardless It

00:26:22.080 --> 00:26:25.050
Seems That the Weight Isn't
Quite Ready for Even the Sort of

00:26:25.050 --> 00:26:29.254
Toy Problem Much Less the
Real-World Malware Problem That

00:26:29.254 --> 00:26:32.791
We Currently Deal with So We
Probably Really Should've Stuck

00:26:32.791 --> 00:26:39.665
with Cuba Is Here Even Those Not
Ready Now There's Still Some

00:26:39.665 --> 00:26:44.203
Areas Will Look into Before
Closing This Is There's A Few

00:26:44.203 --> 00:26:47.573
Magazines to Try to Do to Get
around This Timing Problem We

00:26:47.573 --> 00:26:51.743
Could Just Wait to Do a Trip
Size Is Supposed to Double Every

00:26:51.743 --> 00:26:56.381
Couple of Years and Defects
Should Decrease over Time On

00:26:56.381 --> 00:26:59.084
Each Cubit Should Even
Exponentially Increase the Size

00:26:59.084 --> 00:27:03.322
of the Problem The Chip Should
Be Able to Solve It's Possible

00:27:03.322 --> 00:27:06.458
That the Next Generation Check
for the Tip after That All Will

00:27:06.458 --> 00:27:08.794
Be Fast Enough for This Method
to Compare While the Standard

00:27:08.794 --> 00:27:13.165
Models But of Course Waiting for
Fun Right Instead of Salt

00:27:13.165 --> 00:27:16.668
Instead of Solving and Embedding
of the Problem Directly onto a

00:27:16.668 --> 00:27:20.639
Particular Chip Rather Than
Using Heuristics from Betting Is

00:27:20.639 --> 00:27:25.978
What I Think Probably Should Be
the Best Route We Did Also

00:27:25.978 --> 00:27:29.281
Notice That the Buick Classifier
Often Used Less for Different

00:27:29.281 --> 00:27:32.184
Features Than the Classic
Logarithms When Compared to Used

00:27:32.184 --> 00:27:34.686
So It's Possible the Accused
Might Be Useful for Some Other

00:27:34.686 --> 00:27:38.357
Purpose like Feature Selection
or Future Preprocessing But That

00:27:38.357 --> 00:27:44.029
Time Issues Still There Other
Than the Revisions We Noticed

00:27:44.029 --> 00:27:48.166
That Most Infosec Data Sets Are
Out Of Date and Relatively Small

00:27:48.166 --> 00:27:51.703
Private Researchers Regard Data
Sets and Features As Being Part

00:27:51.703 --> 00:27:55.073
of Their Secret Sauce for
Classification These Facts

00:27:55.073 --> 00:27:58.143
Combined Make It Really Really
Hard to Produce Results or

00:27:58.143 --> 00:28:01.113
Effectively Evaluate Her Own
Creations And That's a Challenge

00:28:01.113 --> 00:28:06.552
We Actually Really Really Need
to Overcome His I Feel So

00:28:06.552 --> 00:28:09.521
Actually That's the End of My
Talk on Meyer A Lot Of People

00:28:09.521 --> 00:28:12.124
Were Actually Flying out Later
Today and I Wanted to Make Sure

00:28:12.124 --> 00:28:16.361
We Had A Lot Of Time for
Questions On so That's My

00:28:16.361 --> 00:28:19.565
Experience with Programming to
Do It Due To Building Our

00:28:19.565 --> 00:28:25.571
Classifier and I Hope You
Enjoyed It On So I Can Go to

00:28:32.211 --> 00:28:37.082
Field Questions If Anyone Has
Any or I Guess I Could Step down

00:28:37.082 --> 00:28:41.019
and Meet with People One on One
I'm Honestly Kind Better at That

00:28:41.019 --> 00:28:47.025
Something Anyways Some Anyone
Right so I Had Actually Seen Any

00:29:06.778 --> 00:29:11.183
Our Studies on Scaling about
Qubits Here And I Really Really

00:29:11.183 --> 00:29:18.523
Would like to Your On Certainly
Possible to Do so And on So Yeah

00:29:18.523 --> 00:29:21.593
I Think That's a Good Nextep to
See How the New Dealerships Will

00:29:21.593 --> 00:29:27.599
Actually So to Be in the Future
Oh Yes Sorry If Anyone Has

00:29:29.968 --> 00:29:35.974
Questions Please Is Mike Yes

