00:00:00.300 --> 00:00:03.570
okay. This, this talk is going
to be a lot of fun. There's a

00:00:03.570 --> 00:00:06.573
lot of old stuff out there
that's still running. The tire

00:00:06.573 --> 00:00:09.710
shop that I go to was, they,
their database was in an AS400

00:00:09.710 --> 00:00:14.114
until, you know, about,
actually, it was about a year

00:00:14.114 --> 00:00:16.583
ago, and then they never
migrated any of the data. So

00:00:16.583 --> 00:00:19.920
they were still running that and
another system terrible,

00:00:19.920 --> 00:00:22.689
terrible. So these guys are
going to talk about old stuff

00:00:22.689 --> 00:00:26.660
and problems with old stuff.
Let's give them a big hand. [

00:00:30.264 --> 00:00:34.968
Applause ] >> Thank you. >>
Thanks for coming out. I will

00:00:34.968 --> 00:00:38.505
see in, in follow-up to that,
that is a great, that -- that is

00:00:38.505 --> 00:00:43.844
absolutely the, um, that is
absolutely what a great number

00:00:43.844 --> 00:00:47.080
of the, the number that we meet
and talk about, and talk to

00:00:47.080 --> 00:00:50.651
about this kind of stuff, ah,
have to say when we talk about

00:00:50.651 --> 00:00:55.022
these kind of things and there's
a lot of truth to that. This,

00:00:55.022 --> 00:00:57.357
this, this platform, the
mainframe platform, specifically

00:00:57.357 --> 00:01:00.661
we're talking about IBMs, system
Z, Z-series platforms have been

00:01:00.661 --> 00:01:04.364
around for a long time. So it's
absolutely what you would

00:01:04.364 --> 00:01:07.401
consider legacy. However, but,
um, it's very modern. Right?

00:01:07.401 --> 00:01:11.972
The, the, the most recent
incarnation of it is as bad ass

00:01:11.972 --> 00:01:15.175
as just about and maybe more so
than anything you can buy in

00:01:15.175 --> 00:01:18.879
terms of what it does and what
it's good at. And so what we're

00:01:18.879 --> 00:01:20.881
talking about today and the
things that Phil and I are going

00:01:20.881 --> 00:01:24.918
to talk about today are done on
the very newest systems, fully

00:01:24.918 --> 00:01:30.824
updated, fully patched, all this
kind of stuff, um -- >> So we'll

00:01:30.824 --> 00:01:36.330
go from there. So who can relate
to this scenario? Wake up in the

00:01:36.330 --> 00:01:43.337
middle of the night, deep sleep,
freaking out, cold sweat, you

00:01:43.337 --> 00:01:46.073
thinking to yourself, holy shit,
who's doing security research on

00:01:46.073 --> 00:01:50.344
mainframes? Show of hands. All
right. So both of you,

00:01:50.344 --> 00:01:53.080
excellent. Thank you for doing
that. I appreciate it. I'll pay

00:01:53.080 --> 00:01:57.084
you afterwards. So this happened
to me about 18 months ago, I

00:01:57.084 --> 00:02:01.555
have vacation in my, in my
business life, and not, I'm not

00:02:01.555 --> 00:02:04.291
here on behalf of my employer,
this is just, standard

00:02:04.291 --> 00:02:08.362
disclaimer, research I'm doing
in my free time, um, but I had

00:02:08.362 --> 00:02:11.031
occasion in my business life to
care about mainframe

00:02:11.031 --> 00:02:14.634
availability. More so I have
occasion just as a human living

00:02:14.634 --> 00:02:18.905
in a civilized world -- somewhat
civilized. In a modern world to

00:02:18.905 --> 00:02:23.877
care about mainframes. And
wanting them to be secure. So 18

00:02:23.877 --> 00:02:26.813
months ago I had this, I had
this idea, like, well, I wonder

00:02:26.813 --> 00:02:28.815
who's doing the security
research? Who's doing the stuff

00:02:28.815 --> 00:02:31.084
that you guys do for Linux,
Windows, all of this kind of

00:02:31.084 --> 00:02:33.253
stuff, who's doing it on
mainframes? So I tried Googling

00:02:33.253 --> 00:02:36.590
it and I'm looking to see what I
can find out about exploit

00:02:36.590 --> 00:02:39.292
development, mainframes,
vulnerability research, get a

00:02:39.292 --> 00:02:43.296
couple of companies, but as
individuals go, really, there

00:02:43.296 --> 00:02:48.502
were like maybe two. And one of
them's right here. And so, ah, I

00:02:48.502 --> 00:02:52.806
reached out to Phil, my
cospeaker here, at the last DEF

00:02:52.806 --> 00:02:55.475
CON and said, hey, let me buy
you are beer and I would like to

00:02:55.475 --> 00:02:58.378
talk about the work you are
doing. So he told me all about

00:02:58.378 --> 00:03:02.182
the work he was doing and I
said, this, this is fantastic

00:03:02.182 --> 00:03:05.452
stuff, but -- I had recently
been very much involved in like

00:03:05.452 --> 00:03:07.988
malware reversing, exploit
development, that kind of stuff,

00:03:07.988 --> 00:03:10.691
I said, well he's doing this
kind of stuff? Right? Who is

00:03:10.691 --> 00:03:12.959
fuzzing the binaries? Who is
testing to see if there is

00:03:12.959 --> 00:03:16.630
buffer overflows? You know, the
basic like meat and potatoes at

00:03:16.630 --> 00:03:19.933
this point of, of security
vulnerabilities and that kind of

00:03:19.933 --> 00:03:22.736
stuff. I said, I don't know. I,
I, I don't know that anybody is.

00:03:22.736 --> 00:03:26.006
He looked at me, he was like you
are. I was like, well I'm not. I

00:03:26.006 --> 00:03:28.475
mean, I'm not a mainframer.
I've, I've worked around

00:03:28.475 --> 00:03:31.545
mainframes for, for 10 years,
but, you know, it doesn't make

00:03:31.545 --> 00:03:34.815
me a mainframer more than being
in my garage make me a car. So I

00:03:34.815 --> 00:03:41.354
said, well, I'll give it a shot.
So I, ah, got a mainframe and

00:03:41.354 --> 00:03:44.624
ah, I started doing some
research on this stuff and the

00:03:44.624 --> 00:03:48.195
first thing I did was I want on
Google and I said what, what's

00:03:48.195 --> 00:03:51.465
already out there? Right? What
vulnerabilities are available?

00:03:51.465 --> 00:03:54.835
What publicly available proof of
concepts are out there for, for

00:03:54.835 --> 00:03:57.170
vulnerabilities, exploit code,
shellcode, all of this kind of

00:03:57.170 --> 00:04:01.975
stuff, and just by way of
example, I went to

00:04:01.975 --> 00:04:05.912
cvedetails.com. So Windows in
the last 10 years has had about

00:04:05.912 --> 00:04:09.916
5 --> 000 documented CVEs. No
surprise there, Mac, OS X about

00:04:09.916 --> 00:04:14.654
2200. ZUS, which is the
mainframe also known as MVS or

00:04:14.654 --> 00:04:19.559
used to be known as MVS, none.
What? That, that can't be right.

00:04:19.559 --> 00:04:22.195
I know for a fact that there
have been security

00:04:22.195 --> 00:04:24.197
vulnerabilities on the
mainframe. Why aren't their

00:04:24.197 --> 00:04:26.500
publically documented
vulnerabilities, proof concepts,

00:04:26.500 --> 00:04:30.303
shellcode, exploits, this kind
of stuff? If you ask the, ah,

00:04:30.303 --> 00:04:35.976
the, the everybody, if you ask
the people that have been

00:04:35.976 --> 00:04:37.978
working this for a while you'll
hear everything from like, well,

00:04:37.978 --> 00:04:39.980
you can't have, you can't have
exploits on the mainframe. You

00:04:39.980 --> 00:04:41.982
can't have buffer overflows, it
doesn't work. It's a secure

00:04:41.982 --> 00:04:43.984
platform. And it is a secure
platform if configured correctly

00:04:43.984 --> 00:04:48.288
and running code with no bugs in
it, which is totally possible.

00:04:48.288 --> 00:04:52.959
Right? Not, not really. So, so
why aren't there any, why isn't

00:04:52.959 --> 00:04:56.463
any of this out there? There's
two reasons in my opinion,

00:04:56.463 --> 00:04:59.599
there's two reasons of this. And
the first one and probably the

00:04:59.599 --> 00:05:03.737
biggest one is that IBM has a
special relationship with our

00:05:03.737 --> 00:05:06.640
customers and that they know all
of their customers. You can't

00:05:06.640 --> 00:05:09.176
buy this without working with
IBM. You can't get one of these

00:05:09.176 --> 00:05:14.181
systems without working with
them. Legally. And so they know

00:05:14.181 --> 00:05:17.551
all of their customers. So by
knowing all of their customers,

00:05:17.551 --> 00:05:21.688
they can release the, ah, they
can release security

00:05:21.688 --> 00:05:23.857
vulnerabilities when they find
them and give them to their

00:05:23.857 --> 00:05:28.228
customers and say, hey, we found
a security vulnerability, it's

00:05:28.228 --> 00:05:31.998
pretty bad, right? Let me rank
it for you, and here's kind of

00:05:31.998 --> 00:05:34.734
the area. It's like, maybe it's
program-based or network-based

00:05:34.734 --> 00:05:37.270
or something like that. That
give you like a -- a vector

00:05:37.270 --> 00:05:40.507
light, if you will. And so and
these are for their paying

00:05:40.507 --> 00:05:42.909
customers. They have a secure
portal where they give them this

00:05:42.909 --> 00:05:45.245
information. And can then the
customer can decide if they want

00:05:45.245 --> 00:05:47.614
to put it on or when they want
to put it on. These things on

00:05:47.614 --> 00:05:51.051
here that I've showed you,
those, those are direct copies

00:05:51.051 --> 00:05:54.421
from kind of their policy around
this vulnerability discloser on

00:05:54.421 --> 00:05:59.459
this platform. And they -- it is
-- it is a benefit, based on

00:05:59.459 --> 00:06:02.696
this ah, document, did not
providing the vulnerability

00:06:02.696 --> 00:06:06.566
details is that both external
attackers and internal personal

00:06:06.566 --> 00:06:10.070
threats don't have access to
that. Could put the --

00:06:10.070 --> 00:06:14.741
enterprise at undue risk. So you
and I know this as security by

00:06:14.741 --> 00:06:17.210
obscurity, right? That's
basically what that is, right?

00:06:17.210 --> 00:06:20.380
Lots of, a lot of vendors and
people who have tried this over

00:06:20.380 --> 00:06:24.684
the years and done this
differing degrees of success. So

00:06:24.684 --> 00:06:29.890
that's reason one. A second
reason is, um, is summed up in

00:06:29.890 --> 00:06:33.193
this slide. And so, this is a
picture of the Ferrari that DEF

00:06:33.193 --> 00:06:38.164
CON bought me for being a
speaker. Thank you. And I think

00:06:38.164 --> 00:06:41.334
that mainframes, or, ah,
businesses treat their

00:06:41.334 --> 00:06:44.070
mainframes much like this
Ferrari. This is a -- Ferrari,

00:06:44.070 --> 00:06:47.774
this is a million and a half
dollar Ferrari, the guy who owns

00:06:47.774 --> 00:06:50.110
this -- the person who owns this
Ferrari is that talking it out

00:06:50.110 --> 00:06:54.314
and pulling a trailer with it.
And they're not bringing it home

00:06:54.314 --> 00:06:56.917
and practicing their shade tree
mechanic skills on it, cutting

00:06:56.917 --> 00:06:59.152
their teeth on it, and not
taking the engine a part and

00:06:59.152 --> 00:07:02.155
saying, like, how does this
thing work. Right? Neither is

00:07:02.155 --> 00:07:04.357
the enterprise that owns the
mainframe doing this stuff,

00:07:04.357 --> 00:07:06.426
because this is their pride and
joy, right? And not only their

00:07:06.426 --> 00:07:09.396
pride and joy, but this runs
their most critical workloads.

00:07:09.396 --> 00:07:11.498
Most enterprises that run
mainframes, if you pull the

00:07:11.498 --> 00:07:14.534
mainframe out, they don't do
whatever their core

00:07:14.534 --> 00:07:22.275
functionality is much well or at
all. So who I am? And why am I

00:07:22.275 --> 00:07:28.448
here? Um, basically I'm here as
kind of the call to arms. Ah, I

00:07:28.448 --> 00:07:30.650
want to get people, I got
excited about this, because I

00:07:30.650 --> 00:07:32.886
felt a need, I felt it was a
place to make a difference, not

00:07:32.886 --> 00:07:35.488
just breaking it something, but
making it better. And I, I want

00:07:35.488 --> 00:07:38.858
to do a call to arms to the
people out there that are ah,

00:07:38.858 --> 00:07:40.994
own pen testing company or
enterprises that own mainframes

00:07:40.994 --> 00:07:44.331
and say, hey, you can afford to
have a mainframe and if you rely

00:07:44.331 --> 00:07:47.567
on it, you ought to have a group
of people that are smart enough

00:07:47.567 --> 00:07:50.503
to pen test it, really pen test
it. Not just port scan it and

00:07:50.503 --> 00:07:52.906
not just go through and make
sure everything is configured

00:07:52.906 --> 00:07:55.308
the best way possible. But the
kind of pen testing that key

00:07:55.308 --> 00:07:58.278
come to love and except for
every other platform that we

00:07:58.278 --> 00:08:01.214
have. Right? Full on fuzzing,
vulnerability discovery. This

00:08:01.214 --> 00:08:04.651
kind of stuff. And if you're a
pen testing company and you do

00:08:04.651 --> 00:08:08.488
engagements for companies that
have mainframes you ought to be,

00:08:08.488 --> 00:08:10.990
have somebody on your staff that
knows how to do this. You ought

00:08:10.990 --> 00:08:13.426
to go out and hire them. Tell
you what, there are not a lot of

00:08:13.426 --> 00:08:17.263
people that go out there and do
this. Not very many in fact, but

00:08:17.263 --> 00:08:20.266
you can train them, it is very,
very, very much a trainable

00:08:20.266 --> 00:08:23.303
skill. You got to be talking to
those engagements that you have

00:08:23.303 --> 00:08:26.139
about, hey, maybe the mainframes
out of scope, but should it

00:08:26.139 --> 00:08:28.675
really be out of scope? I mean,
here's some examples of why

00:08:28.675 --> 00:08:33.012
maybe this should be in scope.
Try to make it a little bit, a

00:08:33.012 --> 00:08:35.815
little bit better ecosystem. So
I grew up, I've been doing

00:08:35.815 --> 00:08:38.284
computers since I was old enough
to type. I like solving

00:08:38.284 --> 00:08:40.920
problems. I like not taking no
for an answer. This kind of

00:08:40.920 --> 00:08:44.457
stuff. Mostly I grew up, though,
bust by -- of my background is

00:08:44.457 --> 00:08:49.596
Linux and Windows. I started
doing mainframe, like -- maybe

00:08:49.596 --> 00:08:52.999
10 years ago, but only really in
Earnest, like maybe a year and a

00:08:52.999 --> 00:08:56.302
half, two years ago. So that's a
little bit about me, I will let

00:08:56.302 --> 00:09:01.474
Phil tell you a little bit about
himself. >> Thanks, Jeff. So my

00:09:01.474 --> 00:09:05.612
name is Phil or, you may know me
as soldier of poor trend. I run

00:09:05.612 --> 00:09:08.915
a couple of blogs about
mainframe security. I really got

00:09:08.915 --> 00:09:13.086
interested in this stuff maybe a
handful of years ago working as

00:09:13.086 --> 00:09:17.157
a company, um, it wasn't until I
got really my own mainframe that

00:09:17.157 --> 00:09:20.693
I started sort of messing around
with it. Um, I probably

00:09:20.693 --> 00:09:23.229
connected to some mainframes
when I was messing around on X25

00:09:23.229 --> 00:09:27.333
networks back in my teens, but
basically I got my own, started

00:09:27.333 --> 00:09:31.137
just doing things with it. And
saying well, what's -- maybe not

00:09:31.137 --> 00:09:33.139
as good as people have said
there, thank you, yeah. There

00:09:33.139 --> 00:09:37.110
you go. So I got my own
mainframe, did my own stuff,

00:09:37.110 --> 00:09:40.880
released a couple of tools, I
spoke at DEF CON last year, did

00:09:40.880 --> 00:09:44.617
all that kind of stuff. Now, I
want you guys to think, so, so

00:09:44.617 --> 00:09:48.188
we sort of touched on this a
little bit, but when people

00:09:48.188 --> 00:09:52.058
think mainframe, 'cause, it
happened right before our talk,

00:09:52.058 --> 00:09:56.095
this is what they think of --
all right? If you can't see

00:09:56.095 --> 00:10:00.600
that, that is a dinosaur with a
pay phone in its stomach. All

00:10:00.600 --> 00:10:04.604
right? That's like two dead
things. And that's what people

00:10:04.604 --> 00:10:08.641
think a mainframe is when we're
talking about them. Okay? But

00:10:08.641 --> 00:10:14.214
the reality is, it's about 90%
of fortune 100s are running

00:10:14.214 --> 00:10:17.183
these things. Anything that
matters to -- okay. Let me do a

00:10:17.183 --> 00:10:21.621
quick poll, who here has used a
credit card in like the last 48

00:10:21.621 --> 00:10:27.360
hours? All right. All right. Who
here has used cash in the last

00:10:27.360 --> 00:10:32.265
48 hours? Yeah. Okay. So
everybody. Right? Any time you

00:10:32.265 --> 00:10:35.301
did that transaction, a
mainframe was involved at some

00:10:35.301 --> 00:10:38.872
point. So I'm going to show you
this slide. Can't read it,

00:10:38.872 --> 00:10:42.242
somewhere on this slide is a
company you give a shit about.

00:10:42.242 --> 00:10:46.980
Okay? Also on this slide -- I
could have keep going with

00:10:46.980 --> 00:10:50.083
multiple slides -- okay? There's
banks in here, there's airlines

00:10:50.083 --> 00:10:54.654
in here, 911, states, all kinds
of things that matter to you, to

00:10:54.654 --> 00:11:00.326
everybody, are on here. They're
on this platform. So you don't

00:11:00.326 --> 00:11:03.463
think you need to care about
this -- you definitely need to

00:11:03.463 --> 00:11:05.932
care about this platform? Okay.
The whole reason I started

00:11:05.932 --> 00:11:08.701
talking about this because no
one else was. So the rest of

00:11:08.701 --> 00:11:11.070
this talk is going to be broken
down into two parts. I'm going

00:11:11.070 --> 00:11:13.606
to be talking about networking
and a little bit about the tools

00:11:13.606 --> 00:11:16.042
and pen testing tools I'm
releasing. And then Chad's going

00:11:16.042 --> 00:11:19.145
to talk about, ah, exploit
development, shellcode

00:11:19.145 --> 00:11:22.382
development, on the platform. So
on network, when you think about

00:11:22.382 --> 00:11:24.684
a mainframe, you usually think
about a screen that looks like

00:11:24.684 --> 00:11:28.388
this, this is a classic TN3270
green screen. It's horrible to

00:11:28.388 --> 00:11:33.726
write in. When you write this,
when you develop for this, it's

00:11:33.726 --> 00:11:37.463
written in assembly to make it
look like this. This took a lot

00:11:37.463 --> 00:11:39.999
of work to setup. But you can
sort of see on the screen here,

00:11:39.999 --> 00:11:42.769
if I type CICS, it will take me
to CICS. If I type TSO, it will

00:11:42.769 --> 00:11:46.472
take me to TSO. This is one of
those macros, but anyway, it is

00:11:46.472 --> 00:11:51.210
TN3270. It's based on Telenet,
yes. That Telenet. It's not

00:11:51.210 --> 00:11:53.546
really Telenet because it's not
really an interactive protocol,

00:11:53.546 --> 00:11:56.849
it's got these beautiful colors,
but what happens is you submit,

00:11:56.849 --> 00:12:00.987
you, you get a text full of
stuff, you type in whatever, you

00:12:00.987 --> 00:12:04.324
hit enter, and then it processes
what you did and then sends it

00:12:04.324 --> 00:12:08.595
back to you. So you, it's not
really happening in realtime.

00:12:08.595 --> 00:12:11.764
Now, it's a buffer. So that
whole screen you saw a couple of

00:12:11.764 --> 00:12:16.569
slides ago, it's a buffer that's
109 --> 020 bytes long and it graphs

00:12:16.569 --> 00:12:20.840
at the 80th common every single
time, right? Each byte is either

00:12:20.840 --> 00:12:23.977
going to be a character, like,
like you saw, or it could be a

00:12:23.977 --> 00:12:27.880
field identifying an attribute
that identifies that as the next

00:12:27.880 --> 00:12:31.684
character's going to be this
color or the next character's

00:12:31.684 --> 00:12:34.787
going to be locked or unlocked,
or the next thousand characters

00:12:34.787 --> 00:12:37.490
are going to be locked or
unlocked. And then it's going to

00:12:37.490 --> 00:12:42.929
say are these characters visible
or invisible? So on this screen,

00:12:42.929 --> 00:12:46.799
the only area you can actually
touch and change is that little

00:12:46.799 --> 00:12:50.136
tiny square there. Right? So
when you type in and you log-in

00:12:50.136 --> 00:12:54.307
-- that's the only place you can
type stuff on that screen. Now,

00:12:54.307 --> 00:12:57.610
when I started doing this, I
just used the free tools that

00:12:57.610 --> 00:13:03.716
were available to me personally.
And Nmap, not so great. Okay? In

00:13:03.716 --> 00:13:06.819
fact, one time I did a scan, a
couple years ago, and it

00:13:06.819 --> 00:13:11.591
identified a bunch of mainframes
a microscope ISSSL. So way off

00:13:11.591 --> 00:13:15.528
mark. So I wrote my own Nmap
script to take care of this.

00:13:15.528 --> 00:13:17.897
This is what it looks like
before. Now, the problem with

00:13:17.897 --> 00:13:21.034
this, one it tells you that the
services Telenet. Well,

00:13:21.034 --> 00:13:23.936
technically true, it's not
really. It's TN3270. The other

00:13:23.936 --> 00:13:30.376
challenge is IBM OS390 is 20
years old and was discontinued

00:13:30.376 --> 00:13:33.413
20 years ago. Like it's, it's
gone. No one uses it anymore.

00:13:33.413 --> 00:13:36.916
But for some reason that's the
version, and that's not even the

00:13:36.916 --> 00:13:38.918
version, it's not like a demon
that's running, that's not what

00:13:38.918 --> 00:13:41.921
it looks like. So what I did, I
wrote an Nmap script to help you

00:13:41.921 --> 00:13:46.192
actually tell that you've
connected to TN3270. So now, and

00:13:46.192 --> 00:13:49.062
it will actually tell you if
you're doing this excel or not.

00:13:49.062 --> 00:13:51.064
So now when you're doing a scan
of your networks and you're

00:13:51.064 --> 00:13:53.066
finding mainframes, you'll
actually know you're finding

00:13:53.066 --> 00:13:57.270
mainframes. But that wasn't
really enough, right? That just

00:13:57.270 --> 00:14:00.139
tells me it's, I want the
banners. And want more

00:14:00.139 --> 00:14:04.911
information. I wanted to see
this -- this is a real mainframe

00:14:04.911 --> 00:14:08.414
that's on the Internet. Okay?
But I don't want to have to run

00:14:08.414 --> 00:14:12.885
an emulator every time I want to
see these screens. So I wrote my

00:14:12.885 --> 00:14:18.891
own TN3270 library for Nmap in
Lua, it was rough. Really hard

00:14:21.661 --> 00:14:26.699
to do, but it's available and it
takes things like this -- this

00:14:26.699 --> 00:14:30.436
is what the banner now looks
like when you do a scan against

00:14:30.436 --> 00:14:33.740
a mainframe with these two
scripts. It will show you the,

00:14:33.740 --> 00:14:40.413
that it is a TN3270 and then it
will show you the actual screen

00:14:40.413 --> 00:14:46.152
or banner that it has. So that's
fun. But now, because I wrote a

00:14:46.152 --> 00:14:52.458
fully functional 3270 emulator
for Nmap I can do all kinds of

00:14:52.458 --> 00:14:56.229
cool stuff. This is a CICS
transaction idea numerator.

00:14:56.229 --> 00:14:59.899
Anyone know what CICS
transactions are? Okay. Good. So

00:14:59.899 --> 00:15:02.101
you know why this is cool. So
this will go through and

00:15:02.101 --> 00:15:07.039
enumerate CICS transactions on a
mainframe. Multi-threaded --

00:15:07.039 --> 00:15:10.910
this is on our test mainframe.
We actually have one. This is

00:15:10.910 --> 00:15:13.279
only allowing 22 threads at the
same time, because we only allow

00:15:13.279 --> 00:15:17.083
22 TCP connections, but that's
exactly what it looks like and

00:15:17.083 --> 00:15:20.486
it works fast. But now we can do
all kinds of cool stuff with the

00:15:20.486 --> 00:15:23.456
other things I know you can
enumerate. So V10 application

00:15:23.456 --> 00:15:28.594
IDs, which means nothing to
almost everybody here except for

00:15:28.594 --> 00:15:33.399
one person. I'm guaranteed. The
other thing, oh, great -- [

00:15:33.399 --> 00:15:36.836
Laughter ] Yeah! >> Keep going
with your stuff. >> Oh, I want

00:15:36.836 --> 00:15:41.974
to see him take a shot. >> Keep
going. >> Oh, damn. I also, I'm

00:15:41.974 --> 00:15:46.412
going to. >> Are these you? >>
Anyways. V10 macros you saw me

00:15:46.412 --> 00:15:49.482
type TSO CICS on the first
thing, well, you don't actually

00:15:49.482 --> 00:15:54.787
have to display those items. You
can just, you can just type in

00:15:54.787 --> 00:15:57.757
whatever you want and if it's a
macro it will work. So I wrote

00:15:57.757 --> 00:16:01.527
another one that does macro
enumeration. Now, you guys

00:16:01.527 --> 00:16:06.666
remember when I said it was
hidden and protected? Well that

00:16:06.666 --> 00:16:12.205
hidden and protection happens on
the client side. So what happens

00:16:12.205 --> 00:16:14.941
when you do sort of security
type stuff on the client side?

00:16:17.043 --> 00:16:19.779
You just ignore, yeah. It's not
secure, right? So take a look at

00:16:19.779 --> 00:16:23.683
this, this is what the CICS
transaction actually looks like.

00:16:23.683 --> 00:16:27.353
And when you look at it, it's
got a locked field -- >> Keep

00:16:27.353 --> 00:16:30.356
going, keep going. >> Keep
going? All right. Right here.

00:16:30.356 --> 00:16:33.693
This is 8 bytes long. [ Laughter
] Are you all right? >> Yeah.

00:16:33.693 --> 00:16:38.598
I'm all right. Keep going. >>
What happens if you ignore that?

00:16:38.598 --> 00:16:42.001
What's happening if you ignore
the 8 bytes of length? >> What

00:16:42.001 --> 00:16:45.571
happens? [ Laughter ] >> I don't
know. >> All right. >> I

00:16:45.571 --> 00:16:47.573
personally, I actually don't
know because we've never done

00:16:47.573 --> 00:16:50.476
it, but I assume all the apps
break. >> They, the screen

00:16:50.476 --> 00:16:53.346
becomes blue. >> No, probably
does. I mean, I don't know. But

00:16:53.346 --> 00:16:56.048
also, what if you have hidden
fields down here? >> All right.

00:16:56.048 --> 00:17:00.052
You guys know how this works. So
um, are these guys doing a good

00:17:00.052 --> 00:17:06.559
job? [ Applause ] >> Yeah! [
Applause ] >> All right. That's

00:17:06.559 --> 00:17:12.198
pretty good applause there. So
new speakers, hard to get here,

00:17:12.198 --> 00:17:18.571
congratulations. It is DEF CON.
[ Applause ] >> And now let's

00:17:18.571 --> 00:17:22.708
find out what happens to the
CICS field. >> Yes. Thanks.

00:17:22.708 --> 00:17:27.313
Thanks for making it sound so
exciting. [ Laughter ] But no

00:17:27.313 --> 00:17:29.348
lie, if you actually do care
about this stuff and you all

00:17:29.348 --> 00:17:36.355
should, trust me, this is some
crazy shit. So oh, that's --

00:17:36.355 --> 00:17:38.758
that's hard to do if you need to
go and identify all the hidden

00:17:38.758 --> 00:17:42.862
fields by yourself. This
emulator ignores all the rules.

00:17:42.862 --> 00:17:45.231
In the Nmap emulator just
ignores them, it doesn't care.

00:17:45.231 --> 00:17:48.301
If it is hidden it will show
you. If it is not modifiable, it

00:17:48.301 --> 00:17:51.304
doesn't care, it will just keep
putting characters in there. So

00:17:51.304 --> 00:17:54.307
you can do things like this and
automate finding hidden

00:17:54.307 --> 00:17:58.678
characters in green screen
applications on the mainframe.

00:17:58.678 --> 00:18:00.980
Also you can just do fuzzing
now. You can just use this to

00:18:00.980 --> 00:18:03.249
fuzz mainframe applications
which was not a thing you could

00:18:03.249 --> 00:18:08.854
do before. But I wrote one in
Lua, why not also do one in

00:18:08.854 --> 00:18:14.160
Python? Same as Nmap. It's the
same thing. But now I can do a

00:18:14.160 --> 00:18:18.397
script that I wrote called set
N3270 if you don't give it any

00:18:18.397 --> 00:18:21.734
arguments it just create as fake
TSO log-in screen, you trick,

00:18:21.734 --> 00:18:24.770
you know, trick users hidden it
that will put in their user

00:18:24.770 --> 00:18:27.873
credentials. It can mirror a
target mainframe so you connect

00:18:27.873 --> 00:18:32.478
it, it does a bunch of stuff,
and it will also do proxy man in

00:18:32.478 --> 00:18:35.448
the middle and it will also do
SSL. So if you have an SSL

00:18:35.448 --> 00:18:37.550
mainframe it will just, because
the clients don't really care.

00:18:37.550 --> 00:18:41.253
So this is what it looks like.
This I'm just going to show you

00:18:41.253 --> 00:18:48.661
the default mode here. So here
it's going to run. That's why I

00:18:48.661 --> 00:18:51.630
record my demos. They never work
when I do them live. I'm going

00:18:51.630 --> 00:18:59.071
to launch my 3270 emulator. [
Laughter ] Thank you. Somebody

00:18:59.071 --> 00:19:03.109
got it. Someone at least. So
this is the fake TN -- TN3270

00:19:03.109 --> 00:19:05.745
TSO log-in screen. This is what
everybody uses when they log

00:19:05.745 --> 00:19:08.280
into the mainframe for the most
part. I'm going to log-in as

00:19:08.280 --> 00:19:11.584
date, give it a password, when I
hit enter it's going to show up

00:19:11.584 --> 00:19:13.586
on the bottom and it's going to
kick the user off and say,

00:19:13.586 --> 00:19:20.693
actually we shut this mainframe
down, you can't use it anymore.

00:19:20.693 --> 00:19:22.962
Now, there's other tools out
there, so Dominick White, are

00:19:22.962 --> 00:19:26.165
you here? Put your hand up if
you're here. All righty. So he's

00:19:26.165 --> 00:19:28.467
actually given a talk at
DerbyCon, I recommends that you

00:19:28.467 --> 00:19:32.071
see it, it's a great talk. He
also has some tools. Big iron

00:19:32.071 --> 00:19:35.174
reconnaissance, opponents. Once
you see hidden fields and once

00:19:35.174 --> 00:19:37.910
you see those things and want to
manipulate it, you can use his

00:19:37.910 --> 00:19:39.912
tools to do it, there is also
mainframe brute, which is a tool

00:19:39.912 --> 00:19:42.648
he wrote based on a tool I
wrote, so I don't know who owes

00:19:42.648 --> 00:19:47.620
who what kudos, but, all right.
So, that's TN3270. You'd

00:19:47.620 --> 00:19:51.190
probably have heard of it if you
work around mainframes, right?

00:19:51.190 --> 00:19:54.960
This is something most people
have never heard of because no

00:19:54.960 --> 00:19:58.364
one talks about it, but it's
called network job entry. I

00:19:58.364 --> 00:20:02.735
heard about it, maybe, um, a
handful of years ago when I was

00:20:02.735 --> 00:20:05.704
doing a walk through of a
mainframe and someone told me

00:20:05.704 --> 00:20:08.674
there, they were working on the
DEV system got connected to any

00:20:08.674 --> 00:20:13.112
other system and they submit a
job and it created a use in the

00:20:13.112 --> 00:20:17.516
production environment. I was
like, what the hell is this? How

00:20:17.516 --> 00:20:20.586
is this possible? I mean, it's
nonchalantly, like oh, it is

00:20:20.586 --> 00:20:24.256
just NJE. I mean, I'm like, I
have never, nowhere in any

00:20:24.256 --> 00:20:27.626
security guide, in any book,
nowhere does it talk about

00:20:27.626 --> 00:20:31.297
network job entry, but that's
what this is. Basically two

00:20:31.297 --> 00:20:35.568
mainframes share, share a secret
handshake and after they had

00:20:35.568 --> 00:20:39.572
that handshake they are trusted
nodes and they can send jobs and

00:20:39.572 --> 00:20:43.843
commanding control messages
between them. And they don't

00:20:43.843 --> 00:20:46.979
send passwords. They don't send
anything. So kind of like this,

00:20:46.979 --> 00:20:49.648
this is an actual configuration
from our mainframe, and so, my,

00:20:49.648 --> 00:20:53.853
my, this is my mainframe. I'm
going to say I have two nodes.

00:20:53.853 --> 00:21:00.459
My node name is New York. Chad's
node name is Washington, D.C.

00:21:00.459 --> 00:21:02.628
And this is the IP address I
need to connect to when I'm

00:21:02.628 --> 00:21:05.998
connecting to his mainframe.
Now, he would do the exact

00:21:05.998 --> 00:21:08.067
opposite on this mainframe, he
would switch New York and

00:21:08.067 --> 00:21:12.705
Washington, D.C. and then change
the IP address. It runs on port

00:21:12.705 --> 00:21:18.978
175 or 2252. It uses host names.
So those, those nodes which they

00:21:18.978 --> 00:21:21.780
call nodes in the configuration
file, but they call host names

00:21:21.780 --> 00:21:26.785
in the documentation, I don't
know why, it runs over TCPIP. So

00:21:26.785 --> 00:21:29.655
that's good. And it was
developed in the '80s, we think?

00:21:29.655 --> 00:21:34.226
Because it's not really clear.
There's a couple of ways you can

00:21:34.226 --> 00:21:38.230
break this. But first I need to
identify that it's even running.

00:21:38.230 --> 00:21:41.133
Here's what happens when you do
Nmap against an NJE port. It has

00:21:41.133 --> 00:21:46.405
no idea what it's talking about.
So I wrote another Nmap script

00:21:46.405 --> 00:21:49.608
which will tell us that we're
connected to an NJE port on a

00:21:49.608 --> 00:21:54.280
mainframe and that it's open
accepting connections. The next

00:21:54.280 --> 00:21:57.783
thing we need is the actual host
name. So what happens when they

00:21:57.783 --> 00:22:01.420
share that secret handshake is
the mainframe says -- I'm New

00:22:01.420 --> 00:22:05.724
York, you're Washington, D.C., I
want to connect to you. And the

00:22:05.724 --> 00:22:08.961
mainframe says, that name checks
out, my name checks out, we're

00:22:08.961 --> 00:22:12.064
going to connect. And if you add
a password, which you should,

00:22:12.064 --> 00:22:14.166
because if you add a password to
this it breaks everything I'm

00:22:14.166 --> 00:22:18.971
going to talk about next, so do
that, but the default is not to

00:22:18.971 --> 00:22:24.343
have a password. Yeah. So
basically, if you say I'm New

00:22:24.343 --> 00:22:28.280
York and you're Cincinnati --
PPP -- it didn't allow you to

00:22:28.280 --> 00:22:32.418
connect. So we can use that to
brute force the node names

00:22:32.418 --> 00:22:35.454
ourselves. So I wrote another,
and I think this might be the

00:22:35.454 --> 00:22:38.791
last Nmap script. I wrote
another Nmap script to brute

00:22:38.791 --> 00:22:42.995
force that. So now we have the
node names for this system and

00:22:42.995 --> 00:22:45.598
we have the node name for the
other system. Now, there's an

00:22:45.598 --> 00:22:47.666
easier way, if you just steal
the configuration file from one

00:22:47.666 --> 00:22:49.835
of the main frames you'll have
them all anyways. Right? They

00:22:49.835 --> 00:22:53.939
all have to declare them all at
the same time. So we got the

00:22:53.939 --> 00:22:59.979
host name, we got the IP
address, what I did was write an

00:22:59.979 --> 00:23:04.717
NJE library in Python in a
program called injector. What

00:23:04.717 --> 00:23:08.787
injector does is given the IP
address and two host names and

00:23:08.787 --> 00:23:13.025
you can actually pass a password
here and a command you want to

00:23:13.025 --> 00:23:18.430
execute, it will connect to the
mainframe and execute that

00:23:18.430 --> 00:23:23.302
command as the other mainframe.
This is called -- so I'm just

00:23:23.302 --> 00:23:26.005
running a GES2 command here,
that's all about you can run.

00:23:26.005 --> 00:23:29.942
That's about what that looks
like. But I -- so -- that's

00:23:29.942 --> 00:23:34.146
amazing. That's terrifying. So
put a password on it, please.

00:23:34.146 --> 00:23:39.118
Now, that's the end of that
stuff. And one of the fun things

00:23:39.118 --> 00:23:41.887
when we, when we do this
research, we encounter a lot of

00:23:41.887 --> 00:23:45.424
old guides that we have to use.
So all that stuff for NJE, and

00:23:45.424 --> 00:23:48.527
nothing special, I just read a
couple of books that IBM has put

00:23:48.527 --> 00:23:52.831
out and wrote my tools. It's
not, it's not impossible to do.

00:23:52.831 --> 00:23:54.833
So we use a lot of books in our
research and we use a lot of

00:23:54.833 --> 00:23:58.370
stuff. So I want everyone's
hands to go up, everybody. All

00:23:58.370 --> 00:24:04.310
your hands. Everybody. Now, if
you were born, which help me

00:24:04.310 --> 00:24:08.380
out, because I will screw this
up, if this book is older than

00:24:08.380 --> 00:24:12.785
you are, I want your hand to go
down. Okay? So this first one

00:24:12.785 --> 00:24:18.791
1992. Okay. A couple of hands
went down. Okay. 1988. Okay. A

00:24:21.560 --> 00:24:25.998
couple of hands went down. 1978.
Oh, wow! [ Laughter ] Wow! Okay.

00:24:25.998 --> 00:24:30.235
Still got some hands up, still
got come hands up, good, good.

00:24:30.235 --> 00:24:35.007
1964. That's, oh, oh, a couple
of people still left. That's it.

00:24:35.007 --> 00:24:37.309
We have nothing older than that.
So you can put your hands down.

00:24:37.309 --> 00:24:41.013
[ Laughter ] [ Applause ] I'm
going to get Chad back up here,

00:24:41.013 --> 00:24:45.784
here's going to explain what
that book meant and continue

00:24:45.784 --> 00:24:49.421
from here. >> Thanks, Phil.
Yeah. I was actually looking up,

00:24:49.421 --> 00:24:54.793
ah, an -- let me, a preassembler
construct. I was Googling it and

00:24:54.793 --> 00:24:59.298
the exact specification that I
wanted came up in that PDF only

00:24:59.298 --> 00:25:02.134
so the instruction I was looking
for and the way it works was in

00:25:02.134 --> 00:25:04.336
that document, which if you read
the small print, was printed in

00:25:04.336 --> 00:25:07.473
like, on, you know, one of those
big wide like green bar printers

00:25:07.473 --> 00:25:10.042
with the tractor feed, and then
somebody took the time to scan

00:25:10.042 --> 00:25:13.212
it and put it on the Internet.
So um, I'm going to talk about

00:25:13.212 --> 00:25:17.583
exploit development. And
basically -- did that go blank?

00:25:17.583 --> 00:25:22.821
>> Wrong button. >> All right.
So I'm going to talk about

00:25:22.821 --> 00:25:25.657
exploit development for a
second. And basically what I'm

00:25:25.657 --> 00:25:28.794
going to talk about is, um, when
I talk, when I had this

00:25:28.794 --> 00:25:32.231
conversation with Phil and
wanted to know about who is

00:25:32.231 --> 00:25:34.700
doing the vulnerability
scanning, anybody write exploits

00:25:34.700 --> 00:25:38.203
up real close. He said no. Not
that he knew of. And I did a lot

00:25:38.203 --> 00:25:40.506
of Googling, couldn't find
anything. And then there is this

00:25:40.506 --> 00:25:43.308
kind of, you know, mass herd
knowledge of well, it is not

00:25:43.308 --> 00:25:46.111
even really possible. So I hear
statements like that and I'm

00:25:46.111 --> 00:25:48.113
probably like a lot of you, when
I hear something like its not

00:25:48.113 --> 00:25:52.518
possible, I'm like, fuck, yeah.
Okay. Media, right? Yeah. You

00:25:52.518 --> 00:25:55.487
know, like the rest of you. So,
so like okay. I'm going to give

00:25:55.487 --> 00:25:58.023
this a shot. But here's the
deal, I can't mainframe, I spent

00:25:58.023 --> 00:26:00.325
a lot of time on mainframes, but
I have never really gotten into

00:26:00.325 --> 00:26:04.096
this level of mainframes, right?
So I don't know, I don't know,

00:26:04.096 --> 00:26:07.399
JAS well, I don't know what PO1
is, or REX or Cobalt, and I

00:26:07.399 --> 00:26:11.270
heard about 3270 and NJE from
Phil's talk right now. So I have

00:26:11.270 --> 00:26:15.040
no idea what I'm doing
basically. But what I do know,

00:26:15.040 --> 00:26:17.042
and some of you probably fall
into this category, what I do

00:26:17.042 --> 00:26:21.680
know is that mainframe is an
amazing machine, runs all kinds

00:26:21.680 --> 00:26:24.249
of stuff and most of the stuff
it runs are probably things that

00:26:24.249 --> 00:26:27.920
you know, probably know better
than I, better than I do. So

00:26:27.920 --> 00:26:33.926
some little known technologies,
like this -- so what you're

00:26:36.995 --> 00:26:40.499
seeing here are all different
types of technologies, right?

00:26:40.499 --> 00:26:45.771
That run on a mainframe. And
there's at least one, if not

00:26:45.771 --> 00:26:48.607
more of these on here, that
probably everybody in this room

00:26:48.607 --> 00:26:51.376
is some kind of expert at. So I
said, good, well I'm not going

00:26:51.376 --> 00:26:53.612
to start with all these things I
don't really understand. I'm

00:26:53.612 --> 00:26:57.249
going to start with one of the
ones I do understand. So I start

00:26:57.249 --> 00:26:59.718
-- so -- [clearing throat]. So
first thing is first I had to

00:26:59.718 --> 00:27:03.355
learn about the architecture.
First question I get when I tell

00:27:03.355 --> 00:27:06.758
somebody we're talking about,
well, what CPU is that. It is

00:27:06.758 --> 00:27:09.595
it's on CPU. It is Z
architecture. It is proprietor

00:27:09.595 --> 00:27:12.264
CPU that doesn't exist anywhere
else, not in Telnet, not in Arm,

00:27:12.264 --> 00:27:15.834
it's its own thing. So just to
give you an example, this is a

00:27:15.834 --> 00:27:20.506
very, very, very brief, but,
illustrative points about what's

00:27:20.506 --> 00:27:24.276
different about it. So programs
can run at one and three modes.

00:27:24.276 --> 00:27:28.680
Right? 23, 31, or 64-bit modes.
Now, street sets are registers

00:27:28.680 --> 00:27:33.685
48 registers on the CPU. It's
big NVM. Three type of memory

00:27:33.685 --> 00:27:37.556
addressing. Absolute memory,
real memory, and virtual memory.

00:27:37.556 --> 00:27:41.927
It is a big architecture. Those
that you know what that means,

00:27:41.927 --> 00:27:44.663
basically that you can store
data and you can store

00:27:44.663 --> 00:27:47.432
instructions, kind of in the
same memory space on and the CPU

00:27:47.432 --> 00:27:52.070
doesn't care. It is just bytes.
It is what allows us to do

00:27:52.070 --> 00:27:55.207
pretty much like the core of
exploits, buffer overflows, that

00:27:55.207 --> 00:27:58.243
kind of stuff, it's why that
works. So it doesn't work well

00:27:58.243 --> 00:28:00.746
on like microcontrollers or
Harvard architectures, kind of a

00:28:00.746 --> 00:28:04.416
totally different beast. It is
kind of stack ways. There is

00:28:04.416 --> 00:28:08.020
kind of a concept of stack. And
it has things you don't find on

00:28:08.020 --> 00:28:10.923
other systems. So this idea of
memory key protection. So every

00:28:10.923 --> 00:28:15.127
four-K block of memory has a few
bits that are the protection key

00:28:15.127 --> 00:28:18.263
on that memory. Every
instruction that gets executed

00:28:18.263 --> 00:28:22.334
also has, ah, protection key.
When, when the -- the CPU goes

00:28:22.334 --> 00:28:24.336
out and try to fetch the memory,
tries to write the memory,

00:28:24.336 --> 00:28:28.006
compares these keys. If a
certain value is yielded on that

00:28:28.006 --> 00:28:32.044
comparison, it lets the fetch or
write, or both happen. If not,

00:28:32.044 --> 00:28:34.713
it doesn't. It says invalid
storage access, and that's it.

00:28:34.713 --> 00:28:37.683
Shuts you down right there. So
that's at the CPU level. So

00:28:37.683 --> 00:28:41.720
processes that get their address
space can't write or read

00:28:41.720 --> 00:28:44.289
outside of those address spaces
unless they have authority to do

00:28:44.289 --> 00:28:46.425
it. That's a very different
construct then what you see in a

00:28:46.425 --> 00:28:50.762
lot of stuff. So where to start?
This is a massive system and it

00:28:50.762 --> 00:28:53.732
has tremendous numbers of
differing technologies on it. So

00:28:53.732 --> 00:28:56.735
like I said earlier, I was kind
of at the time focusing on

00:28:56.735 --> 00:28:58.904
reverse engineering, buffer
overflows, shellcode, that kind

00:28:58.904 --> 00:29:03.008
of stuff, I said, hey, it runs
UNIX, UNIX is one of the main

00:29:03.008 --> 00:29:05.277
faces of the mainframe, there is
the traditional MVS and the

00:29:05.277 --> 00:29:08.480
stuff that Phil was showing. At
UNIX services, which is like

00:29:08.480 --> 00:29:11.717
just another window into the
mainframe, but it is compliant,

00:29:11.717 --> 00:29:15.854
it looks a lot like AIX. If you
know Linux, you can easily pick

00:29:15.854 --> 00:29:19.224
this up, or if you have just
done UNIX, it's -- very much

00:29:19.224 --> 00:29:24.062
UNIX. Ah, and C -- it compiles
C, it compiles C++, but you

00:29:24.062 --> 00:29:29.668
know, based on C, where all good
exploits begin, they're alive, I

00:29:29.668 --> 00:29:34.139
thought I will just start with C
and start with UNIX. It also has

00:29:34.139 --> 00:29:37.476
an assembly language that is
entirely different from, ah,

00:29:37.476 --> 00:29:39.478
from the Intel uncallable
language. Different set of

00:29:39.478 --> 00:29:42.314
pneumonics. There are thousands
of instructions. There is a

00:29:42.314 --> 00:29:46.318
CIST-based processor. The C
stands for complex. Just as an

00:29:46.318 --> 00:29:50.055
example, there are 26 different
possible instruction format for

00:29:50.055 --> 00:29:53.825
every instruction. So you can
have registered-mediate,

00:29:53.825 --> 00:29:55.827
register-register,
register-memory,

00:29:55.827 --> 00:29:57.896
memory-to-memory, that sort of
thing, in all the different bit

00:29:57.896 --> 00:30:02.467
modes. Right? 23, 31, 64-bit.
So, so as an example like an add

00:30:02.467 --> 00:30:04.636
instruction, like a basic add
instructions, there's 15

00:30:04.636 --> 00:30:07.506
different kinds of add
instructions. There's a lot,

00:30:07.506 --> 00:30:13.178
there's a lot of -- a lot of
options out there for assembly.

00:30:13.178 --> 00:30:18.383
So I'm going to, and set it
very, very, very -- narrow goal

00:30:18.383 --> 00:30:22.087
for this. That was like what I
really want to have, I want to

00:30:22.087 --> 00:30:25.190
write a vulnerable, vulnerable
program, plausible, venerable

00:30:25.190 --> 00:30:29.394
program. I want to write some
shellcode that pops a shell and

00:30:29.394 --> 00:30:32.564
I want, I want to deliver that
sort of like the hello world of,

00:30:32.564 --> 00:30:35.734
of shellcoding exploit
development, buffer overflows.

00:30:35.734 --> 00:30:38.503
And so the first thing I have to
find out is can I actually

00:30:38.503 --> 00:30:42.808
execute strings as codes? Right?
This is the basis of all good

00:30:42.808 --> 00:30:45.444
overflows. Like, so I've got to
buffer there, SC that's

00:30:45.444 --> 00:30:48.580
basically a bunch of hex bytes
that represent valid mainframe

00:30:48.580 --> 00:30:51.983
instructions. And if you do
coding or exploit development,

00:30:51.983 --> 00:30:55.821
you'll recognize this stuff. It
is very common C stuff to test

00:30:55.821 --> 00:30:59.524
shellcode, which all it does is
really create a, ah, function

00:30:59.524 --> 00:31:02.894
pointer to this string. If this
string is valid instructions and

00:31:02.894 --> 00:31:08.867
the CPU allows me to do this,
this should work. And it did. So

00:31:08.867 --> 00:31:12.304
here it runs through, but I'll
just skip to the end and show

00:31:12.304 --> 00:31:15.273
you, ah, what you've got here,
right at the top their where it

00:31:15.273 --> 00:31:17.542
says dead beef, so the two
instructions that I've created

00:31:17.542 --> 00:31:21.480
just basically take, clear out a
register, take the dead beef hex

00:31:21.480 --> 00:31:25.317
string, put it in the register.
So those bytes right there, that

00:31:25.317 --> 00:31:28.186
say like -- CE1-dead beef and
recognize below it, where it is

00:31:28.186 --> 00:31:31.990
O7 dead beef, those are the
strings that I had in my buffer.

00:31:31.990 --> 00:31:35.727
So this is the big deal. Can I
execute strings as code? Yes. I

00:31:35.727 --> 00:31:37.763
can. I called Phil up, I was
like, Phil, I can execute

00:31:37.763 --> 00:31:42.033
strings as code, I'm so excited.
This is like -- man. Oh, this

00:31:42.033 --> 00:31:45.570
year. Like this man! I was like,
this is great. This is like --

00:31:45.570 --> 00:31:49.274
partway to the thing that we're
talking about. So the next thing

00:31:49.274 --> 00:31:52.110
is like, that's great, but this
is obviously very staged. If you

00:31:52.110 --> 00:31:55.147
write a program like that, (
laughter ) and it works great.

00:31:55.147 --> 00:32:01.086
But really, you haven't done
anything. Um, so the next thing

00:32:03.088 --> 00:32:05.624
is like, well, can we overflow
this buffer and can we do it in

00:32:05.624 --> 00:32:07.793
a meaningful way? Right? So
worst case scenario is I get a

00:32:07.793 --> 00:32:09.795
denial of service. I can
overflow the buffer and maybe it

00:32:09.795 --> 00:32:11.797
crashes. Best case scenario is I
can overflow the buffer and

00:32:11.797 --> 00:32:13.799
maybe it lands something in some
special register that I can

00:32:13.799 --> 00:32:16.668
control and then all the good
stuff happens. So this is the,

00:32:16.668 --> 00:32:20.305
this is the -- this is the
sample program that I'm, that

00:32:20.305 --> 00:32:22.707
I'm going to be using for the
rest of the demonstrations. It's

00:32:22.707 --> 00:32:25.177
very symbol. It is obviously
vulnerable. It uses a GAP string

00:32:25.177 --> 00:32:29.314
without any bounce checking. Um,
but there's been a million and

00:32:29.314 --> 00:32:32.918
one different types of, ah,
exploits over the years that

00:32:32.918 --> 00:32:35.787
this very thing is at the core
of. Right? This is, this is,

00:32:35.787 --> 00:32:40.358
this is how it starts. So I take
this, I take this code, and I

00:32:40.358 --> 00:32:44.062
compile it, and I'm going to run
it in my debugger. Say a word

00:32:44.062 --> 00:32:46.398
about the debugger for just a
second. So this, I don't know if

00:32:46.398 --> 00:32:49.401
you can see it up there, this is
the DBX debugger. This is the

00:32:49.401 --> 00:32:51.503
debugger that comes with the
mainframe on UNIX system

00:32:51.503 --> 00:32:56.608
services. It's a little bit
analogous to GDB. So I tell

00:32:56.608 --> 00:32:58.977
people when they ask me about
this, I say, hey, if you love

00:32:58.977 --> 00:33:01.346
GDB and you know how to work in
GDB because those of us who do

00:33:01.346 --> 00:33:04.950
kind of like it, then you will
probably not like this or maybe

00:33:04.950 --> 00:33:09.254
hate it. [ Laughter ] It's, its
very GDB-like, but it's just

00:33:09.254 --> 00:33:11.656
like enough to kind of make you
angry about it. Like it's got,

00:33:11.656 --> 00:33:14.726
it's got instructions that you
-- oh, yeah. I can do that in

00:33:14.726 --> 00:33:18.797
GDB-- no. No. To, to, to -- just
kind of further make you angry,

00:33:18.797 --> 00:33:22.834
angry about it, um, DBX is a
debugger that Oracle ships with

00:33:22.834 --> 00:33:25.637
some of its products. Not the
same debugger, but it has some

00:33:25.637 --> 00:33:28.673
of the same instructions. So if
you're Googling this and you're

00:33:28.673 --> 00:33:32.043
looking for like, something
like, hey, how can I, ah, go in

00:33:32.043 --> 00:33:34.546
and edit memory? What do I have
to do to do that, and you find

00:33:34.546 --> 00:33:36.681
it on an Oracle site, and you
enter this switch and this

00:33:36.681 --> 00:33:40.085
command, oh, great, no. That one
is not implemented, you can't do

00:33:40.085 --> 00:33:43.255
that one. But it is enough. It
is enough. As I show here, this

00:33:43.255 --> 00:33:46.892
is all used. I -- my goal with
this was only to use tools that

00:33:46.892 --> 00:33:50.195
were actually on the mainframe.
So I didn't write anything for

00:33:50.195 --> 00:33:54.065
it. I didn't record anything to
it. I'm using the ones that come

00:33:54.065 --> 00:33:57.235
with it. This is very simple and
no magic here. I just had a

00:33:57.235 --> 00:34:00.405
buffer that said hello word, I
added to this and ran it in

00:34:00.405 --> 00:34:04.676
there. On the bottom green box
there, basically I can see where

00:34:04.676 --> 00:34:06.845
my string is stored in memory
and I can start looking at the

00:34:06.845 --> 00:34:09.614
interesting bytes that come
after it. Say, hey. Is there

00:34:09.614 --> 00:34:11.683
anything that is interesting.
And there is interesting things

00:34:11.683 --> 00:34:15.921
there. Um, and oh, by the way,
just, because I haven't

00:34:15.921 --> 00:34:19.591
mentioned it yet, so in a
different to -- in addition to,

00:34:19.591 --> 00:34:22.127
ah, ah, different compiler,
different operating system,

00:34:22.127 --> 00:34:24.896
different CPU, different
instruction set, different

00:34:24.896 --> 00:34:29.501
debugger, it also, everything is
in Ed stick. It is a different

00:34:29.501 --> 00:34:32.003
character set. It's not asking.
Right? So that the end of this

00:34:32.003 --> 00:34:35.440
we're not going to get a 41, 41,
41, 41 in the IP. Right? It's

00:34:35.440 --> 00:34:39.911
going to be a C1, C1, but yeah.
So, so if you do any, anything

00:34:39.911 --> 00:34:42.847
you take between an Intel system
and this, there has to be that

00:34:42.847 --> 00:34:48.320
ASCII to stick conversion, it is
a whole different code page. So

00:34:48.320 --> 00:34:52.123
this, taking that research
further, the next step we could

00:34:52.123 --> 00:34:54.125
do when you're building this
kind of stuff, it is like, okay.

00:34:54.125 --> 00:34:56.261
Here's a valid buffer let's
start sending it some extra

00:34:56.261 --> 00:34:59.097
characters and overflow it, see
what happens. This is usually

00:34:59.097 --> 00:35:01.967
where the magic happens. This is
the next major milestone. I was

00:35:01.967 --> 00:35:04.936
like, if this works great. If it
doesn't -- this will be like a,

00:35:04.936 --> 00:35:07.806
like a five-minute DEF CON
hallway talk. Right? Probably

00:35:07.806 --> 00:35:12.210
wouldn't get a free shot either.
So what happened? Lots of

00:35:12.210 --> 00:35:15.981
crashing. And since this
debugger is really designed for

00:35:15.981 --> 00:35:18.616
people who are building
programs, not people who are,

00:35:18.616 --> 00:35:22.587
you know, decompiling or
disassembling programs, it

00:35:22.587 --> 00:35:25.457
failed and it failed in a way
that was like really helpful.

00:35:25.457 --> 00:35:29.661
Because I got a lot of these
DDPI, DLEX, FSX, extra bad, 134

00:35:29.661 --> 00:35:34.499
messages. Which is super
helpful. What's below that,

00:35:34.499 --> 00:35:36.501
though, is storage access
failed. So if you remember when

00:35:36.501 --> 00:35:38.770
I was talking about memory key
protection, storage access

00:35:38.770 --> 00:35:41.740
failed is saying to me, that you
tried to access something from

00:35:41.740 --> 00:35:45.410
a, from a memory that, that your
process doesn't have. It might

00:35:45.410 --> 00:35:47.412
not be a valid memory address,
but it doesn't matter because

00:35:47.412 --> 00:35:49.848
you don't have access to it. I'm
not going to tell you if it is

00:35:49.848 --> 00:35:53.418
valid or not valid, I'm just
going to tell you, you can't

00:35:53.418 --> 00:35:56.454
have it. What I found out later
is that I was actually

00:35:56.454 --> 00:35:58.890
overwriting what, what would be
kind of analogous to a base

00:35:58.890 --> 00:36:01.926
pointer, but there was nothing
here when the program crashed

00:36:01.926 --> 00:36:05.597
that I could find that out. So I
did some more digging and went

00:36:05.597 --> 00:36:08.566
back to the manuals and, and,
and -- when all of you, you

00:36:08.566 --> 00:36:10.568
start to get into mainframes,
like I know all of you will,

00:36:10.568 --> 00:36:13.738
because I can tell, I can see
it, ah, any time you research

00:36:13.738 --> 00:36:17.042
something you, about five
manuals open that are about a

00:36:17.042 --> 00:36:20.178
thousand pages each. I'm not
exaggerating at all. Because you

00:36:20.178 --> 00:36:22.580
want to find out, like something
very simple -- but you have to

00:36:22.580 --> 00:36:24.582
read three different manuals. So
you go from configuration

00:36:24.582 --> 00:36:27.018
manual, you have a reference
manual, you have a user's guide,

00:36:27.018 --> 00:36:29.020
and you have maybe like a setup
manual and then maybe a red

00:36:29.020 --> 00:36:32.057
book. Right? And it took all of
them to find out something

00:36:32.057 --> 00:36:34.626
easier, because -- not because
they're of -- about, ah, us to,

00:36:34.626 --> 00:36:36.761
but because they are so
comprehensive. They are so

00:36:36.761 --> 00:36:39.564
comprehensive that if you want
to do something simple, it's

00:36:39.564 --> 00:36:43.802
never easy. So one day I'm going
to start reading about like how

00:36:43.802 --> 00:36:47.338
does the function call work? So
using the Intel world, like how,

00:36:47.338 --> 00:36:49.674
house the, ah, the frame, the
stack frame setup, right? Does

00:36:49.674 --> 00:36:53.344
the caller set it up? Does the
caller set it up? Who manages

00:36:53.344 --> 00:36:56.414
the base pointer? Who manages
the stack pointer? Right, if you

00:36:56.414 --> 00:37:00.018
do this kind of work you know
what I'm talking about it. If

00:37:00.018 --> 00:37:03.721
you don't, just nod your head.
Like who does that and where is

00:37:03.721 --> 00:37:06.624
it? Because it is a very
standard calling convention. So

00:37:06.624 --> 00:37:09.060
I did a little research on that
and then I want back to my proof

00:37:09.060 --> 00:37:12.430
of concept and I figured out
that what I needed to do was

00:37:12.430 --> 00:37:15.600
take one of these things I was
overwriting and instead of

00:37:15.600 --> 00:37:18.436
overwriting that part of it I
needed to actually send that

00:37:18.436 --> 00:37:21.706
back through and then I could
keep on writing. So it's kind

00:37:21.706 --> 00:37:24.542
of, it's not meant to be, but it
kind of works like a stack

00:37:24.542 --> 00:37:28.246
canary. Right? Like -- a stack
canary. So if you compile a

00:37:28.246 --> 00:37:31.015
program on a Linux system that
has stack canaries enabled and

00:37:31.015 --> 00:37:33.251
you do a buffer overflow and it
overwrites that canary what

00:37:33.251 --> 00:37:36.454
happens, right? The program
crashes and it says, hey, you

00:37:36.454 --> 00:37:38.456
modified your memory you can't
go on, but if you are able to

00:37:38.456 --> 00:37:41.960
put that very canary back in the
right spot, you can continue

00:37:41.960 --> 00:37:44.395
exploiting that program, just
like you would if it wasn't

00:37:44.395 --> 00:37:49.200
there. So I did. And what
happened next, besides this

00:37:49.200 --> 00:37:56.441
screen going dark, was, there we
go ah, was lo and behold, ah, I

00:37:56.441 --> 00:38:00.745
was able to not only continue
execution, I had, the program

00:38:00.745 --> 00:38:04.015
crashed, but it crashed awesome.
So if you look at this, at the

00:38:04.015 --> 00:38:08.119
top there, the C1s are As, C2s
are Bs. So on and so forth.

00:38:08.119 --> 00:38:10.622
There's my base pointer. So if I
took this buffer and I put it in

00:38:10.622 --> 00:38:14.559
that memory I got one of these.
So for those of you who do this

00:38:14.559 --> 00:38:16.761
out there, you know what this
means, right? This is my

00:38:16.761 --> 00:38:20.798
instruction pointer with a bunch
of ASCII test or absent test in

00:38:20.798 --> 00:38:24.869
it. Those are Cs. Right? So
outstanding. I put that there,

00:38:24.869 --> 00:38:27.872
right? I made the computer now
go to where it thinks the next

00:38:27.872 --> 00:38:30.708
instruction should be because of
something that I just passed it

00:38:30.708 --> 00:38:35.446
as a string. So I called Phil
up. And Phil, Phil, Phil. Like,

00:38:35.446 --> 00:38:37.448
you got to believe this, like I
got to send this out, like I'm

00:38:37.448 --> 00:38:39.450
going to tweet this and like the
six people in the world who know

00:38:39.450 --> 00:38:42.020
what this means are going to be
so excited. [ Laughter ] And

00:38:42.020 --> 00:38:44.489
Phil was really excited, he was
like that is great, that is

00:38:44.489 --> 00:38:46.858
great, now go back and finish
this. I was like, okay. So this

00:38:46.858 --> 00:38:49.060
is like the end of June. By now
we've been accepted our DEF CON

00:38:49.060 --> 00:38:51.496
talk and I would have been
content, like that's pretty good

00:38:51.496 --> 00:38:53.965
like right there. You know
that's pretty good. But I'm not

00:38:53.965 --> 00:38:57.402
happy taken that as like, you
know, the end of this. So next

00:38:57.402 --> 00:38:59.971
thing is I got to build a
working, I got to build some

00:38:59.971 --> 00:39:01.906
shellcode, right? I need
something that actually does

00:39:01.906 --> 00:39:06.544
something. So back to the
drawing board. Earn myself some

00:39:06.544 --> 00:39:09.480
assembly. Started doing it in C,
but as you know, when you

00:39:09.480 --> 00:39:12.116
compile it, the compiler does
all kinds of unholy things to

00:39:12.116 --> 00:39:14.953
your code. Moves stuff around.
And that doesn't work really

00:39:14.953 --> 00:39:17.956
well for shellcode. You want
relative addresses, relative

00:39:17.956 --> 00:39:21.059
jumps. You went maybe, you want
to control the nulls or that

00:39:21.059 --> 00:39:24.262
kind of stuff. So I, so I wrote
it all in assembly. The assembly

00:39:24.262 --> 00:39:26.998
here is very similar to when you
write assembly on an Intel

00:39:26.998 --> 00:39:30.134
platform, different pneumonics,
but the same ideas about how

00:39:30.134 --> 00:39:35.006
things work. You got your
setting up your frame. Find your

00:39:35.006 --> 00:39:38.443
exact function. That, that bit
right there, that red, that red

00:39:38.443 --> 00:39:42.814
arrow, that's important. So the
mainframe has, has something

00:39:42.814 --> 00:39:46.951
called you -- ah, assembly
callable services. So this is

00:39:46.951 --> 00:39:51.422
like in Linux where you can do a
CIS call, you can get EXEC or

00:39:51.422 --> 00:39:54.525
some of those things that are
like so ubiquitous that every

00:39:54.525 --> 00:39:56.794
process has access to them, you
just got to find them in memory,

00:39:56.794 --> 00:40:01.499
right? And Windows has it, too.
Like the WS32, like, some of

00:40:01.499 --> 00:40:03.768
these things are in, part of
every process you can find them,

00:40:03.768 --> 00:40:05.904
like you want to open a port,
you want to listen, you want to

00:40:05.904 --> 00:40:10.708
bind, that kind of stuff. It has
it, too. So I'm going to EXEC

00:40:10.708 --> 00:40:14.579
and I'm going to pass it as
string that is, you're in the

00:40:14.579 --> 00:40:19.584
constant section that has been
SH. All right? So this is no

00:40:19.584 --> 00:40:22.487
shock. I, I, once I got this
working I got it to run, you can

00:40:22.487 --> 00:40:26.391
see I created, ah, the, you
know, this, this is no magic

00:40:26.391 --> 00:40:28.826
here. This is just me being able
to actually write a program that

00:40:28.826 --> 00:40:32.530
runs. So my program at the end,
writes shell and it launches a

00:40:32.530 --> 00:40:36.000
shell. Outstanding. So and the
steps are the same as, as those

00:40:36.000 --> 00:40:38.903
steps that you would use on any
other platform, you assemble,

00:40:38.903 --> 00:40:45.610
link, execute. All right. So we
got, we got a working shell.

00:40:45.610 --> 00:40:49.414
Now, we got to convert it to
shellcode. And see if that

00:40:49.414 --> 00:40:54.319
works. So I was able to take the
debugger again and it does have

00:40:54.319 --> 00:40:56.854
a couple decent features in it,
but when you create shellcode

00:40:56.854 --> 00:40:59.957
you basically are cutting out
that portion of the binary that

00:40:59.957 --> 00:41:02.427
actually does the stuff. Right?
You're not worrying about

00:41:02.427 --> 00:41:04.429
setting things up. You're not
worrying about tearing things

00:41:04.429 --> 00:41:07.498
done. You just want that part of
the binary that does this stuff.

00:41:07.498 --> 00:41:10.234
And this stuff in this case is
like launching a shell. That's

00:41:10.234 --> 00:41:13.571
all I want. I don't care about
any of the forward, I don't care

00:41:13.571 --> 00:41:16.908
about any of the cleanup, I just
want the stuff. So back in the

00:41:16.908 --> 00:41:23.214
debugger I'm able to get the
offsets that I want. So that's

00:41:23.214 --> 00:41:26.117
my first instruction. There's my
last instruction. I'm going to

00:41:26.117 --> 00:41:29.821
get those offsets and the link
to the shellcode. Print it out.

00:41:29.821 --> 00:41:33.358
There's some idea of what it
will look like when I format it.

00:41:33.358 --> 00:41:36.127
And now I need to format it into
a string that I can use in C or

00:41:36.127 --> 00:41:41.332
into assembly. So I wrote a
little, I wrote a little Python

00:41:41.332 --> 00:41:44.669
script that you can basically
just pass you binary to, pass

00:41:44.669 --> 00:41:48.606
the beginning offset, pass the
length, and it will kick you out

00:41:48.606 --> 00:41:50.641
some super nice formatted
shellcode that you can just drop

00:41:50.641 --> 00:41:53.544
into C. It will also kick out
assembly code if you want to

00:41:53.544 --> 00:41:57.015
drop it into your assembly on
the mainframe, and it will, if

00:41:57.015 --> 00:42:01.419
you want it to, create encoded
code. So if you're going to

00:42:01.419 --> 00:42:04.455
pass, ah, shellcode as a string
it can't have any nulls, it

00:42:04.455 --> 00:42:07.525
can't have any move lines in it,
so this, this simple little

00:42:07.525 --> 00:42:10.828
Python script will go through,
find a valid character, X over

00:42:10.828 --> 00:42:14.699
everything and give you a good,
ah, give you a good string with

00:42:14.699 --> 00:42:21.739
no nulls and no new lines. So
that's great. So next thing was

00:42:21.739 --> 00:42:25.109
test this out. So I took the, I
took the shellcode, put it back

00:42:25.109 --> 00:42:29.881
in the same buffer, execute the
program, and now I know not only

00:42:29.881 --> 00:42:33.785
can I, not only can I exercise
the strings as instructions, but

00:42:33.785 --> 00:42:36.487
I can do something that actually
matters. Right? I get, I got a

00:42:36.487 --> 00:42:39.624
shell now from nothing but
shellcode. And the last thing

00:42:39.624 --> 00:42:41.626
that I had to do with it is what
I was just talking about which

00:42:41.626 --> 00:42:44.195
encode it and remove the bad
characters. So if you guys,

00:42:44.195 --> 00:42:47.065
Metasploit or whatever you use,
MS code, or MS payload, or MS

00:42:47.065 --> 00:42:50.802
venom, whatever does this for
you, this is doing it by hand. I

00:42:50.802 --> 00:42:53.838
wrote a script to do it because
none of that stuff exists. Um,

00:42:53.838 --> 00:42:56.674
by the way, the Python that I'm
talking about is Python on the

00:42:56.674 --> 00:42:59.210
mainframe. So you can run Python
on the mainframe, which is a

00:42:59.210 --> 00:43:02.280
godsend, that did help a great
deal in a lot of this,

00:43:02.280 --> 00:43:05.883
automating a lot of this stuff.
So there I just generated the

00:43:05.883 --> 00:43:08.886
same buffer but it did it in
assembly and it was the encoded

00:43:08.886 --> 00:43:10.888
version. So it doesn't have any
nulls, it doesn't have any new

00:43:10.888 --> 00:43:14.258
lines it. Put it in this program
which is a subprogram that goes

00:43:14.258 --> 00:43:16.461
through and decodes it and then
adjustments to it. This is how a

00:43:16.461 --> 00:43:19.397
lot of exploits, malware, that
kind of stuff works. Right?

00:43:19.397 --> 00:43:22.500
There's a tiny little header
that's the coder, or an encoder

00:43:22.500 --> 00:43:25.770
or an encryptor, it may be
decodes or decrypts the payload

00:43:25.770 --> 00:43:27.772
and then it jumps to it and
executes. So it's like one

00:43:27.772 --> 00:43:30.942
stage, two stage, that's exactly
what's here. And then I'm going

00:43:30.942 --> 00:43:34.312
to take that now, tested it,
compiled it, works great,

00:43:34.312 --> 00:43:38.249
convert that into shellcode, now
I got my final shellcode. Right?

00:43:38.249 --> 00:43:40.818
So this is what I'm going to
take, I'm going to package it

00:43:40.818 --> 00:43:44.489
altogether with the offsets. I'm
going to build a Python delivery

00:43:44.489 --> 00:43:46.491
vehicle that kind of
concatenates everything. I'm

00:43:46.491 --> 00:43:49.927
going to pipe it in. We're going
to see what happens. It's

00:43:49.927 --> 00:43:55.433
exciting. I don't know what's
going to happen. So this is the

00:43:55.433 --> 00:43:58.436
same vulnerable echo program
that I had before, which is a

00:43:58.436 --> 00:44:00.905
little bit bigger buffer. So I
have a little room to move. The

00:44:00.905 --> 00:44:04.742
shellcoded ended up being like
450 bytes, which isn't too bad

00:44:04.742 --> 00:44:07.378
for, for popping a shell. I
think I could have made it a

00:44:07.378 --> 00:44:11.015
little bit smaller, but 450
bytes is pretty reasonable. This

00:44:11.015 --> 00:44:13.484
is the, this is just the high
level of the Python script right

00:44:13.484 --> 00:44:16.454
here. So your return address
that I mentioned before that has

00:44:16.454 --> 00:44:19.757
to be there. And oh, by the way,
that address was the same every

00:44:19.757 --> 00:44:24.929
time. I'm going to let that sink
in for a second. Okay? Through

00:44:24.929 --> 00:44:30.234
reboots on different systems,
okay? The jump address of my

00:44:30.234 --> 00:44:33.571
buffer where, where the buffer
gets memory. A few other filler

00:44:33.571 --> 00:44:36.307
variables. There's the same
shellcode. Going to put it

00:44:36.307 --> 00:44:43.247
altogether. Pipe it out to, ah,
standard output. Let's see what

00:44:43.247 --> 00:44:47.618
happens. So this is just, the
program being executed show that

00:44:47.618 --> 00:44:53.624
it works. Right. So take a
string through standard input,

00:45:01.766 --> 00:45:06.837
take it back to you. Now, what I
did in this, what I did with

00:45:06.837 --> 00:45:11.676
this is instead of, I, I took
the echo binary and I made it a

00:45:11.676 --> 00:45:15.379
sued binary. Right? So that's
the concept of suedes. I made it

00:45:15.379 --> 00:45:17.949
a sued binary and I made it
owned by IBM user, which is like

00:45:17.949 --> 00:45:22.687
the root user. The 0ID0 user to
see if not only could I execute

00:45:22.687 --> 00:45:26.757
it, but could I inherit those
permissions -- authorities as

00:45:26.757 --> 00:45:31.696
well. So what happens here, I'll
blow it up just a little bit. So

00:45:31.696 --> 00:45:34.498
first we've got my restricted
user. My restricted employee,

00:45:34.498 --> 00:45:37.034
who doesn't have access to
anything. He can't SU. He can't

00:45:37.034 --> 00:45:39.537
cat, or super-secret file,
because it is only owned and

00:45:39.537 --> 00:45:43.941
reasonable by, by the root user.
We'll run this on the command

00:45:43.941 --> 00:45:48.512
line. And now we can SU, we can
cat that file, and we're, root.

00:45:48.512 --> 00:45:54.518
So from start to finish,
success. [ Applause ] So I

00:45:57.121 --> 00:46:03.661
think, I think that was like a
three-hour call to Phil. I'm

00:46:03.661 --> 00:46:05.696
like Phil, you're not going to
believe this, you're going to

00:46:05.696 --> 00:46:08.165
print this out and put it on
your fridge and tell your

00:46:08.165 --> 00:46:11.402
friends about it. I'm sure they
care. They, like this, this is

00:46:11.402 --> 00:46:16.407
exciting. So this opened a whole
number of doors. Um, because we

00:46:16.407 --> 00:46:18.709
know that a lot of the
traditional things that we know

00:46:18.709 --> 00:46:22.713
how to do work here. And what
we're up here doing is making

00:46:22.713 --> 00:46:25.416
it, is trying to make it so
that, that those of you who want

00:46:25.416 --> 00:46:27.418
to get involved in this, or
those of you who own company ass

00:46:27.418 --> 00:46:29.420
on a higher people to get
involved in it. Or have

00:46:29.420 --> 00:46:31.422
companies want to get people
involved it don't have to do

00:46:31.422 --> 00:46:33.424
quite the learning curve. We
don't need to maybe make you a

00:46:33.424 --> 00:46:35.793
mainframe expert to kind of do
this stuff. You don't have to

00:46:35.793 --> 00:46:39.163
spend the nine months getting up
to speed like I did on this,

00:46:39.163 --> 00:46:42.967
because I'm releasing, you know,
tools and how-tos and facts and

00:46:42.967 --> 00:46:45.970
that kind of stuff, I blogged to
get you the answers faster so

00:46:45.970 --> 00:46:48.873
you don't have to do that kind
of research. So what's next? We

00:46:48.873 --> 00:46:51.409
got a huge pool of stuff we're
just talking over lunch like we

00:46:51.409 --> 00:46:54.412
added like 30 more things to the
list of what might happen next.

00:46:54.412 --> 00:46:57.581
Right? Things like NSF
integration. What we really need

00:46:57.581 --> 00:46:59.850
is a custom
debugger/disassembler which I'm

00:46:59.850 --> 00:47:03.354
working on, if any of you have
worked with like the radar, ah,

00:47:03.354 --> 00:47:06.991
framework, that is on my
shortlist of making work on this

00:47:06.991 --> 00:47:10.461
system. Ah, more privileged
escalations. Different kinds of

00:47:10.461 --> 00:47:13.097
deployment, modules and that
sort of stuff. If we peaked your

00:47:13.097 --> 00:47:16.100
interest -- ah, we have started
a mailing list of which there

00:47:16.100 --> 00:47:18.369
are now two members. Right?
Because Phil, you signed up. >>

00:47:18.369 --> 00:47:20.671
Yep. >> So there's both of us on
there. [ Laughter ] , but

00:47:20.671 --> 00:47:22.907
honestly, like it's a public
mailing list. Anybody can sign

00:47:22.907 --> 00:47:25.209
up. I encourage you to sign-up.
You can ask questions, you can

00:47:25.209 --> 00:47:27.678
ask them anonymously. There are
mailing lists like this, but

00:47:27.678 --> 00:47:29.680
they're all associated with the
company. This one's not. So

00:47:29.680 --> 00:47:32.583
everything should sign-up for
it. We put all the code, the

00:47:32.583 --> 00:47:35.186
tools, the proofs of concept,
the exact things that ran, that

00:47:35.186 --> 00:47:38.389
made this demo are out on the
get hub right now. Both of our

00:47:38.389 --> 00:47:43.027
blogs -- soldierportrait.org and
bignamefalls.com have lots of

00:47:43.027 --> 00:47:45.296
good information. Will continue
to have lots of good information

00:47:45.296 --> 00:47:48.332
as we go down this journey. But
what we really need is you guys

00:47:48.332 --> 00:47:51.669
to add to the body of knowledge.
So with that, and just want to

00:47:51.669 --> 00:47:54.638
say thanks to DEF CON to let us
talk about this. Thanks for IBM

00:47:54.638 --> 00:47:58.109
for having this cool platform
because it really is a hoot. And

00:47:58.109 --> 00:48:00.044
we are really enjoying it.
Thanks again to Dominick, ah,

00:48:00.044 --> 00:48:02.446
for the work that you've done
and everybody else, really,

00:48:02.446 --> 00:48:05.249
who's kind of allowed this to
happen. Because it needs to

00:48:05.249 --> 00:48:08.018
happen and, and we're having a
ball with it. So there's our

00:48:08.018 --> 00:48:10.654
contact info. I appreciate it. I
know we're out of time, but

00:48:10.654 --> 00:48:12.923
we'll be around if you guys have
any questions or, you can

00:48:12.923 --> 00:48:15.893
absolutely contact us, talk
about it, because -- we'll talk

00:48:15.893 --> 00:48:19.864
about it forever. So be, be, be
warned. All right? Thank you

00:48:19.864 --> 00:48:26.704
very much. Thanks for everybody
who came and showed up. Really

00:48:26.704 --> 00:48:29.807
appreciate it. [ Applause ]

