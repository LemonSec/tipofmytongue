00:00:00.000 --> 00:00:04.838
uuum ok uuuhhhm This is not
really a new topic as far as RE

00:00:04.838 --> 00:00:07.708
Dos goes its just an old
attack The thing Im

00:00:07.708 --> 00:00:11.378
bringing to this thats sort
of new, is automation, so, um,

00:00:11.378 --> 00:00:16.216
and some benchmarking, too. But
what I mean by automation, is

00:00:16.216 --> 00:00:20.621
with NFA engines, you have to
uuhm to kill the performance,

00:00:20.621 --> 00:00:25.659
you have to craft an evil stream
and um, normally that takes a

00:00:25.659 --> 00:00:29.730
little bit of craftiness; you
have to underrated that

00:00:29.730 --> 00:00:31.732
expression a little bit and know
what would make it perform

00:00:31.732 --> 00:00:33.734
terribly. Thats the part I
automated, and I have a tool

00:00:33.734 --> 00:00:36.470
that I released, and there will
be a demo at the end for that.

00:00:36.470 --> 00:00:39.506
So thats to know what to
expect. Um, but I will go

00:00:39.506 --> 00:00:41.909
through regular expressions, how
the DOSing works and all of that

00:00:41.909 --> 00:00:46.246
first. Um, but before I start
with that, I just wanna give

00:00:46.246 --> 00:00:48.916
some shouts and some credits to
some of the places I hacked at,

00:00:48.916 --> 00:00:54.254
and did my security research at,
cuz thats where I did most of

00:00:54.254 --> 00:00:57.291
it. So, HeatSink Labs from
Phoenix, when I used to live

00:00:57.291 --> 00:01:03.297
there and then my new life in
Manhattan so aaaah NYC were just

00:01:05.565 --> 00:01:07.568
trying to start hacking
manhattan, is where I did a lot

00:01:07.568 --> 00:01:12.673
of the later stuff. So I'll
going to depth in this slide.

00:01:12.673 --> 00:01:17.044
but about me, I'm Eric, im not a
security researcher, there is my

00:01:17.044 --> 00:01:19.713
E mail address, my blog is
there, that has more details

00:01:19.713 --> 00:01:23.684
about the other stuff. not some
reg x But some like low level

00:01:23.684 --> 00:01:27.154
assembly machine code stuff i
talk about. I'm always talking

00:01:27.154 --> 00:01:31.425
about how assembly language is
too high level, and in my github

00:01:31.425 --> 00:01:33.860
and at the bottom its smaller
just to fit the screen is the

00:01:33.860 --> 00:01:37.497
specific pearl script that is
the tool that I will be talking

00:01:37.497 --> 00:01:40.400
about later in Demoing. and when
i saw im not a security

00:01:40.400 --> 00:01:43.003
researcher, its kinda funny
story, I typically don include a

00:01:43.003 --> 00:01:46.406
company name or title or
anything in my bio.so when you

00:01:46.406 --> 00:01:49.009
dont do that you can always
notice people that says

00:01:49.009 --> 00:01:51.845
security researcher after
the name But I mean I did not

00:01:51.845 --> 00:01:54.481
put that because I really don't
know what security research is

00:01:54.481 --> 00:02:00.654
so I just play hack. So this
first part come the first third

00:02:00.654 --> 00:02:03.123
of the presentation, im gonna
make this part really quick coz

00:02:03.123 --> 00:02:07.194
there a lot of hand so, ill try
to race through this but this is

00:02:07.194 --> 00:02:10.998
kind of a tldr of regular
expression there is more to it

00:02:10.998 --> 00:02:14.568
but like this is 90% like you
would ever use and for some one

00:02:14.568 --> 00:02:16.570
that never use regular
expression,like even learning

00:02:16.570 --> 00:02:20.440
half of this stuff you can get
moving really quickly and be

00:02:20.440 --> 00:02:24.978
useful. Like I said I'm really
going to race this. like i said

00:02:24.978 --> 00:02:29.349
with all the heads that went up
i didnt even expect that, and

00:02:29.349 --> 00:02:32.653
uuuhhm you know what im almost
not even gonna try to explain

00:02:32.653 --> 00:02:35.322
bout regular expressions are, I
mean is a great way to search is

00:02:35.322 --> 00:02:38.125
the way to look at it. it kind
of a programming language, its

00:02:38.125 --> 00:02:41.595
Non training complete. which
that being kinda Like a language

00:02:41.595 --> 00:02:45.999
is why you can have performing
issues but is like you know when

00:02:45.999 --> 00:02:49.136
you are doing file searches you
can do dot dot or a question

00:02:49.136 --> 00:02:52.039
mark or or one character or
whatsoever, it kinda like that

00:02:52.039 --> 00:02:55.075
kind of a syntax but its way
more powerful, so first of all

00:02:55.075 --> 00:02:59.312
well talk about pawn of fires,
say I was looking in bio or any

00:02:59.312 --> 00:03:02.482
kind of data or pact or
anything, if I wanted to 5 or

00:03:02.482 --> 00:03:10.157
anywhere between 5 to 15 exes
like the syntax of that of

00:03:10.157 --> 00:03:16.163
that search so X and the amount
from 5-15 and then we have

00:03:18.799 --> 00:03:22.669
aliases for useful arranges that
we use alot so If you wanted to

00:03:22.669 --> 00:03:28.008
say 0 to 1 of that like the
letter X. That's just a question

00:03:28.008 --> 00:03:34.214
mark after the X or a plus is
something like X plus will be 1

00:03:34.214 --> 00:03:39.453
or more Xs. Now say 1 or more I
want to say to infinity here.

00:03:39.453 --> 00:03:42.856
but thats not completely true,
there is a limit. But then the

00:03:42.856 --> 00:03:46.126
star is not like a star when you
are doing file searches. like

00:03:46.126 --> 00:03:50.630
the glob kinda format, It means
0 to infinity. So is kind of

00:03:50.630 --> 00:03:54.000
like 1 or more or also not all
is there as well. So. There is

00:03:54.000 --> 00:03:57.204
also character classes. So you
group a certain kind of

00:03:57.204 --> 00:03:59.206
character im looking of 3 5s and
9s in my stream, and I want to

00:03:59.206 --> 00:04:01.208
find 5 to 8 of those because of
that a string like that can

00:04:01.208 --> 00:04:03.210
match. Also negative space you
can select the character class.

00:04:03.210 --> 00:04:09.216
that is negated so this right
here, this little carret is a

00:04:21.294 --> 00:04:27.300
negation, this is the class that
were negating the coma, What

00:04:31.071 --> 00:04:34.774
this really this really mean is
one or more is not a comma so

00:04:34.774 --> 00:04:40.780
the string down here is red is
the one that matches one till we

00:04:43.283 --> 00:04:49.289
hit the comma. Somehow, wow. I
have no idea how that just

00:04:57.297 --> 00:05:03.303
happened. So give me a second
here man, technical issues.

00:05:14.314 --> 00:05:20.320
Whats up? Oh weird is doing that
scale mode. Does anybody know

00:05:26.960 --> 00:05:32.966
LSX good enough to get out of
the scale mode? Hey, Joe. No, no

00:05:35.468 --> 00:05:41.474
that worked. Cool. I'm back,
back in track. so my alias is

00:05:45.712 --> 00:05:51.284
for character classes you can do
wide space, numbers,

00:05:51.284 --> 00:05:55.021
alphanumeric also under score
and then if you capitalize it

00:05:55.021 --> 00:05:58.558
thats negate character class, so
not number, not wide space not

00:05:58.558 --> 00:06:01.294
alpha numeric, have you a dot
which is kind of like the

00:06:01.294 --> 00:06:04.064
questions mark in blogging so
thats any character except for

00:06:04.064 --> 00:06:10.070
new lines. Unless not because
you can modify that too. So we

00:06:15.675 --> 00:06:19.212
can also do kind of like an org
statement. so if were looking

00:06:19.212 --> 00:06:25.018
for any of these three words
from the stream Like good, bad

00:06:25.018 --> 00:06:28.488
evil. This string down here
nonevil sentence will match the

00:06:28.488 --> 00:06:34.427
part that matches the word evil,
so it had one of those in it. We

00:06:34.427 --> 00:06:38.098
can also group it as well so if
we did good, bad, evil and group

00:06:38.098 --> 00:06:42.335
it with parenthesis we can say 3
or more of that so any one of

00:06:42.335 --> 00:06:46.706
those words. we have bad good
evil bad, so anyone of those

00:06:46.706 --> 00:06:49.609
three words we had 4 of them we
had matches, we can also anchor

00:06:49.609 --> 00:06:55.882
so what that means is For the
carret not in the carret plus

00:06:55.882 --> 00:06:59.719
but the carret means we want to
find the word anchor in this

00:06:59.719 --> 00:07:03.323
case this is out regular
expression, but uuuhm the string

00:07:03.323 --> 00:07:07.694
has to start with the word
anchor. so a string that would

00:07:07.694 --> 00:07:11.665
match is anchor is an anchor,
But the thing it doesn't start

00:07:11.665 --> 00:07:15.669
with that word it starting with
the word boat is an anchor, it

00:07:15.669 --> 00:07:19.673
does have the word anchor but
the is is it doesnt start with

00:07:19.673 --> 00:07:23.677
the word anchor it starts with
word boat, and we can do the

00:07:23.677 --> 00:07:27.080
same thing with end anchor. The
dollar sign so that's the

00:07:27.080 --> 00:07:29.482
regular expression and a string
that will match as anchor

00:07:29.482 --> 00:07:35.422
because it ends anchor, this
will not match because it starts

00:07:35.422 --> 00:07:41.161
with a boat and not anchor, if
we want to search a string for a

00:07:41.161 --> 00:07:48.668
character that a regular special
character so we have to keep it

00:07:48.668 --> 00:07:52.772
with backslash so if we are
looking for 3 to 6 dollar signs

00:07:52.772 --> 00:07:59.713
we have to stay this is an
escape a dollar sign on an end

00:07:59.713 --> 00:08:04.484
anchor. And this is like the
last red x because this is like

00:08:04.484 --> 00:08:06.486
boring stuff if you already know
reg x, and Il get into the

00:08:06.486 --> 00:08:10.657
dos. there is greediness
laziness, and possessiveness. Is

00:08:10.657 --> 00:08:15.929
a useful thing to know. A source
of confusing when things are not

00:08:15.929 --> 00:08:19.699
matching the things you want.
but a good example it kind of an

00:08:19.699 --> 00:08:24.871
HTML, example here Because reg x
is the best thing to part HTML

00:08:24.871 --> 00:08:28.942
(inaudible) I don't know if you
have seen but in this case I

00:08:28.942 --> 00:08:32.278
have scrip tag not really and
end the script and then we have

00:08:32.278 --> 00:08:35.582
a text and we start another
strip and then we end that and

00:08:35.582 --> 00:08:38.585
then more text so if we have
general expression trying to

00:08:38.585 --> 00:08:44.924
find the first strip tag and
everything in between it. That

00:08:44.924 --> 00:08:48.528
will kind of work if we have
only one strip tag. but because

00:08:48.528 --> 00:08:51.731
reg x by default is greedy, it
tries to capture everything. The

00:08:51.731 --> 00:08:58.671
thing that it matches starting
from this first script. Wow this

00:08:58.671 --> 00:09:04.677
whole presentation. Starting
from the first script to the

00:09:07.480 --> 00:09:11.651
last script to the second to the
end script tag. So if we want to

00:09:11.651 --> 00:09:14.788
just the first script here. We
can use that question mark

00:09:14.788 --> 00:09:17.590
modifier after the quantifier
which is the plus in this case.

00:09:17.590 --> 00:09:21.428
And it does and tells the next
one were looking for. Not

00:09:21.428 --> 00:09:27.834
everything until the next one.
So now ReDos so now its all evil

00:09:27.834 --> 00:09:33.840
because is red. I'm going to
take a drink of my caffeine. So

00:09:39.079 --> 00:09:42.615
before we start attacking there
is more than just these two

00:09:42.615 --> 00:09:45.652
engines but these are the most
commonly type of regular express

00:09:45.652 --> 00:09:51.458
engines. Theres hybrids too.
But there is a deterministic

00:09:51.458 --> 00:09:55.428
engine and a nondeterministic
engine. they have different kind

00:09:55.428 --> 00:09:58.865
of problems when it comes to
performance usually when you

00:09:58.865 --> 00:10:03.503
read up on ReDos and uhhm NFAs
are the engines most talked

00:10:03.503 --> 00:10:06.773
about, and the way the Dos it is
thru time, deterministic engines

00:10:06.773 --> 00:10:10.210
is a little bit different
because timing wise, because

00:10:10.210 --> 00:10:12.946
timing is it doesnt really
even matter what stream its on

00:10:12.946 --> 00:10:14.948
searching it kinda
deterministically, time wise

00:10:14.948 --> 00:10:19.052
find other different matches or
not, but you dont get that

00:10:19.052 --> 00:10:22.622
for free, the downside is that
it takes up memory to build the

00:10:22.622 --> 00:10:28.661
state table, so if you gonna
wanna Dos and expression you

00:10:28.661 --> 00:10:31.231
kinda wanna know what engines it
is using coz your strategy is

00:10:31.231 --> 00:10:34.234
gonna be a little bit different,
you can actually do a recon to

00:10:34.234 --> 00:10:37.203
find that out, because they
dont actually, itd be nice

00:10:37.203 --> 00:10:39.706
if they work is actually the
same, as far as the output that

00:10:39.706 --> 00:10:43.109
you get, but it doesnt
completely, like on engine, if

00:10:43.109 --> 00:10:48.748
you a had a risk of - one of
em will pick the first one and

00:10:48.748 --> 00:10:51.651
another engine will pick the
longest one instead, and also

00:10:51.651 --> 00:10:55.054
the laziness the DFA doesnt
support, and possessiveness is

00:10:55.054 --> 00:11:00.093
handled really weirdly for one
of engines, so we can test it

00:11:00.093 --> 00:11:03.530
with like a proof of concept
perhaps i can show a different

00:11:03.530 --> 00:11:07.600
results and show what i mean
when i say that, so the longest

00:11:07.600 --> 00:11:11.271
alternation thing, the nfa,
which is the first example here

00:11:11.271 --> 00:11:17.043
and ill zoom in, the sample
stream im echoing out the stream

00:11:17.043 --> 00:11:23.349
is A B and the search that im
doing is A or AB and the match

00:11:23.349 --> 00:11:27.487
that we get is just A. So really
what's happening is we are

00:11:27.487 --> 00:11:30.690
picking the first thing that we
see that matches the string and

00:11:30.690 --> 00:11:32.859
the first thing we see is just
the A and now we're done we

00:11:32.859 --> 00:11:35.895
dont match it we dont get
anything more than that, Another

00:11:35.895 --> 00:11:41.935
hand the DFA we do AB it grabs
the largest thing. It actually

00:11:41.935 --> 00:11:45.905
match it is AB the full AB. So
there is a difference in what it

00:11:45.905 --> 00:11:50.043
matches. And laziness this
example is pretty straight

00:11:50.043 --> 00:11:56.082
forward because DFA doesn't
support it. So we have a search

00:11:56.082 --> 00:12:01.854
string of ABABA. We search for A
and any amount of character

00:12:01.854 --> 00:12:06.993
until the next A which make
sense to why we get ABA. But we

00:12:06.993 --> 00:12:11.097
use the DFA we are still trying
to say the same thing, that

00:12:11.097 --> 00:12:14.133
laziness that question mark. And
it doesnt work and thats

00:12:14.133 --> 00:12:17.937
why we get, ABABA. Because it is
with A and anything amount of

00:12:17.937 --> 00:12:21.274
anything until another A is how
is working. So it just keeps on

00:12:21.274 --> 00:12:23.343
going. B doesnt amount of
anything. A is in the amount of

00:12:23.343 --> 00:12:27.013
anything and B is now like that.
This one is really weird. With

00:12:27.013 --> 00:12:30.850
NFA when they find something
that matches as is going along.

00:12:30.850 --> 00:12:35.688
It holds onto it and it doesn't
want to give it back and it

00:12:35.688 --> 00:12:40.193
keeps going. So in this case we
have ABC as the search string

00:12:40.193 --> 00:12:44.030
for both. And out expression is
a little bit more complicated

00:12:44.030 --> 00:12:48.468
but just to break it down. We
are looking for an A and maybe a

00:12:48.468 --> 00:12:55.775
B and then we're look maybe a BC
0 or 1 BC and both of the

00:12:55.775 --> 00:13:00.179
expressions that's what we're
looking for. So for one of them

00:13:00.179 --> 00:13:06.185
we get AB and another we get
ABC. So is weird why we get

00:13:08.821 --> 00:13:14.027
that. We get AB for one and ABC
but if we follow it with NFA we

00:13:14.027 --> 00:13:21.134
get RA and the next thing is we
get our A and there is also

00:13:21.134 --> 00:13:25.805
going to be a B. As we find that
so we hold onto that and now the

00:13:25.805 --> 00:13:30.743
last part of the string. We have
a C and is not a BC so we match

00:13:30.743 --> 00:13:35.181
them with AB where as the DFA
will see the A and then the B

00:13:35.181 --> 00:13:39.085
will match with BC and longer
stream will match so it gives up

00:13:39.085 --> 00:13:41.954
the first part to match the
longer string so that's handle a

00:13:41.954 --> 00:13:46.626
little different. And as long as
recon goes thats the biggest

00:13:46.626 --> 00:13:52.331
assumption, that you to have the
ability to know what the system

00:13:52.331 --> 00:13:54.734
expressions are to be able to
know what is matching so

00:13:54.734 --> 00:13:58.938
sometimes can you not do that
recall and another thing you can

00:13:58.938 --> 00:14:03.476
do is can give it a string and
you know what the expression is

00:14:03.476 --> 00:14:07.447
you can time it and if it takes
the same amount you are dealing

00:14:07.447 --> 00:14:12.352
with the DFA if it is
inconsistent in the time if it

00:14:12.352 --> 00:14:16.723
is longer than others then is
either a DFA or hybrid. So we'll

00:14:16.723 --> 00:14:21.594
do comparison between on the
engines still on how them work

00:14:21.594 --> 00:14:26.766
on the backend. So I'll start
with the lies to simplify things

00:14:26.766 --> 00:14:34.674
and we'll go under the hood as
we go. So the first kind of

00:14:34.674 --> 00:14:37.677
simplify version on how it works
[ inaudible ] on how an engine

00:14:37.677 --> 00:14:43.216
would do path finding and this
is going to be the NFA example

00:14:43.216 --> 00:14:48.321
so kind of like go down just the
follow one side of the maze and

00:14:48.321 --> 00:14:51.724
if it hits the dead end it
backtracks and go take another

00:14:51.724 --> 00:14:57.897
path. So this is how it would
look like. Backtracks that dead

00:14:57.897 --> 00:15:01.134
end. Comes out finds another
backtracks thats how it goes.

00:15:01.134 --> 00:15:05.705
Depending on the mace looks you
dont know how long it will

00:15:05.705 --> 00:15:10.276
take through depending on how
the dead ends are. With DFA in

00:15:10.276 --> 00:15:14.847
parallel it will go through all
the options and picks the one

00:15:14.847 --> 00:15:19.418
that will work. It deterministic
how fast it goes. And then you

00:15:19.418 --> 00:15:22.421
get the longest match. The
problem is you're doing all that

00:15:22.421 --> 00:15:28.594
at once and it takes more
memory. So part 2, with say this

00:15:28.594 --> 00:15:33.199
is our example regular
expression at the top kind of in

00:15:33.199 --> 00:15:38.938
the blue and at the bottom I am
wondering yeah, contrast is not

00:15:38.938 --> 00:15:42.975
as terrible. Well at least on my
monitor here. Thats kinnda

00:15:42.975 --> 00:15:49.882
stupid. So red is the search
string. So with the NFA engine.

00:15:49.882 --> 00:15:54.020
It starts as -- it takes a look
at the expression and see how is

00:15:54.020 --> 00:15:59.926
matching with the string. 0 or
more L, no. A, it doesnt

00:15:59.926 --> 00:16:03.663
satisfy the [ inaudible ], no,
there you go, that matches. So

00:16:03.663 --> 00:16:06.632
then we go to the next part know
that that L doesn't match

00:16:06.632 --> 00:16:10.269
because we are still looking for
more L so the I, so we go to the

00:16:10.269 --> 00:16:15.875
next part of the expression, is
that T? No is that a C? No. Is

00:16:15.875 --> 00:16:21.514
that an I, Yes. We can go to
next part there and as a T, no.

00:16:21.514 --> 00:16:25.818
Is that a C, yes. Is than an A?
yes. And we can qualify and keep

00:16:25.818 --> 00:16:30.089
going is that a T? keep going
you know and then this is where

00:16:30.089 --> 00:16:34.193
a search fails. Is it a C, no.
Is it a C, no. Some I, no and

00:16:34.193 --> 00:16:37.563
then we're done that's the
match. So the difference, Ill

00:16:37.563 --> 00:16:42.869
get into how the DFA does it
later. But also you can

00:16:42.869 --> 00:16:46.239
flowchart that out into a state
diagram, is kind of messy but

00:16:46.239 --> 00:16:51.844
this is natural state diagram
will be for this specific

00:16:51.844 --> 00:16:56.215
example back here so we start at
nothing and at the bottom here

00:16:56.215 --> 00:16:58.451
we go, is this an L? But it
doesn't have to be. Then its

00:16:58.451 --> 00:17:00.453
kinda could go back. This is
were we diverge our three

00:17:00.453 --> 00:17:03.089
Different patterns and our
alternations list. what I

00:17:03.089 --> 00:17:09.095
meant by that is back, there we
go. We have our T group, or CA

00:17:11.964 --> 00:17:19.105
group and our I group. So going
back there we have like at the

00:17:19.105 --> 00:17:23.109
bottom there the T, right there
we have our CA and then we have

00:17:23.109 --> 00:17:27.947
our I and then in green is like
our we solve it state it matches

00:17:27.947 --> 00:17:32.451
state. And if you really wanted
to pop the hood there is a way

00:17:32.451 --> 00:17:35.755
you can actually get pearl to
tell you exactly how is

00:17:35.755 --> 00:17:39.058
compiling a regular expression.
so again this is our expression

00:17:39.058 --> 00:17:42.662
on the top. And this is kind of
the programming language side of

00:17:42.662 --> 00:17:48.467
it how is being compile. And I
say at the begin I said that it

00:17:48.467 --> 00:17:50.469
is not training complete because
you cannot have an infinite

00:17:50.469 --> 00:17:52.471
loop. To the best of my
knowledge, but in theory you

00:17:52.471 --> 00:17:55.207
shouldnt have an infinite
loop. You can have an itteration

00:17:55.207 --> 00:17:58.210
that can goes over over and
over. Backtracks and over but

00:17:58.210 --> 00:18:00.613
you shouldnt have an infinite
loop. So in other words it

00:18:00.613 --> 00:18:06.953
should finish. So the F in the
DFA is a finite [ inaudible ].

00:18:06.953 --> 00:18:12.858
And this is just moreover that
same expression. So DFA is

00:18:12.858 --> 00:18:16.295
little different. This is like
more of a lie of how it works.

00:18:16.295 --> 00:18:18.297
It really doesnt work this
way. Is more string base. It

00:18:18.297 --> 00:18:23.069
looks at the string and it says,
does it match the expression? It

00:18:23.069 --> 00:18:27.673
follows the string more than the
expression its itself. And this

00:18:27.673 --> 00:18:33.112
is what a DFA state would look
like. It has multiple ways to

00:18:33.112 --> 00:18:37.717
match. And it picks the longest
match. Whereas NFA would pick

00:18:37.717 --> 00:18:42.088
the first one. And it is done
when it picks the fist one. And

00:18:42.088 --> 00:18:46.225
this is a more accurate way. If
you running an engine a DFA

00:18:46.225 --> 00:18:49.228
engine in a programing language
is like you are going to be

00:18:49.228 --> 00:18:53.599
sitting up in array and its like
a state diagram you are going to

00:18:53.599 --> 00:18:57.269
go through the states is a lot
easier to comprehend on how an

00:18:57.269 --> 00:19:00.840
NFA engine should work. so this
is again, this state diagram is

00:19:00.840 --> 00:19:03.242
not arbitrate is following the
same example like the

00:19:03.242 --> 00:19:07.747
application string like reg x.
So if we start on state 0, up

00:19:07.747 --> 00:19:13.753
here. In state zero, does it
have an LTCR or A. It eventually

00:19:16.922 --> 00:19:22.294
gets you that L and when you do
that just tells you now you go

00:19:22.294 --> 00:19:25.464
to state that listed in the
diagram which is 1 so now we'll

00:19:25.464 --> 00:19:28.934
be on state 1 and we'll look for
any of those letters. And

00:19:28.934 --> 00:19:32.438
whatever letter that is. And it
instructs you which state, 2, 3,

00:19:32.438 --> 00:19:36.876
or 4 if you had a C it will
instruct you to go to state 3.

00:19:36.876 --> 00:19:40.679
And eventually you will get a
character that is no there which

00:19:40.679 --> 00:19:47.486
would completely fail or you
would match eventually. And

00:19:47.486 --> 00:19:51.791
that's important to look at DFA
in that context because that

00:19:51.791 --> 00:19:55.327
gives you an idea how you can
dust the memory. Being is a

00:19:55.327 --> 00:19:59.065
table in memory what ways can
you make that table grow. One

00:19:59.065 --> 00:20:03.769
way is you can have more of
those patterns you're looking

00:20:03.769 --> 00:20:09.775
for or you can have a lot more
states and I learn that states

00:20:12.244 --> 00:20:16.282
are the easiest way to attack
it, in practice. In theory it

00:20:16.282 --> 00:20:18.951
should work, but in practice
having more states is the way to

00:20:18.951 --> 00:20:24.023
do it. Is now talking about
abusing DFA, we'll talk about

00:20:24.023 --> 00:20:27.493
abusing NFAs after this which is
more complicated. But thinking

00:20:27.493 --> 00:20:30.429
of the labyrinth this is how I
could abuse it. You will give it

00:20:30.429 --> 00:20:34.333
multiple paths to expand that
memory out. It has to traverse

00:20:34.333 --> 00:20:38.771
all of them at the same time.
Thats what I would explain

00:20:38.771 --> 00:20:41.741
there. that's kind of an
example, thats a POC. An

00:20:41.741 --> 00:20:46.779
expression that not even getting
to the point of giving a string

00:20:46.779 --> 00:20:50.382
to search just the fact that it
has to load that expression as a

00:20:50.382 --> 00:20:54.019
state table that will consume
that memory. that expression.

00:20:54.019 --> 00:20:58.791
Because to break it down in this
first set of parentheses we are

00:20:58.791 --> 00:21:06.365
looking for to 0 to 75 A. And
the group that and were

00:21:06.365 --> 00:21:09.468
looking for 0 to 75 of that and
4 times 0 to 75 of that so it

00:21:09.468 --> 00:21:14.773
multiplies pretty badly. Now
we'll talk about abusing NFA.

00:21:14.773 --> 00:21:20.312
I'm going to check the time
here, we're good. Going pretty

00:21:20.312 --> 00:21:25.084
fast. This is another labyrinth.
One important thing there is no

00:21:25.084 --> 00:21:30.422
way to solve it. You see a start
up here. But there is no

00:21:30.422 --> 00:21:35.261
solution. It tries to go every
path it can to try to find the

00:21:35.261 --> 00:21:38.697
solution but if it doesn't it
backtracks and tries another way

00:21:38.697 --> 00:21:42.802
and it backtracks and tries
another way. So if you give it a

00:21:42.802 --> 00:21:47.506
way out once it got out it will
be done. It be match. So you

00:21:47.506 --> 00:21:51.277
just make it try every single
possible thing. At the end it

00:21:51.277 --> 00:21:55.381
doesn't even match but it but
that takes a lot of time so

00:21:55.381 --> 00:21:59.618
thats the way to abuse NFA. so
the way to kind of conclude that

00:21:59.618 --> 00:22:04.690
is to try everything until it
finds a match, dot, dot, dot. So

00:22:04.690 --> 00:22:08.894
I don't know about the contrast
here. They have a pretty easy to

00:22:08.894 --> 00:22:11.697
understand example on how that
should work. You have an

00:22:11.697 --> 00:22:16.335
expression, that It has to start
with A, one or more As and

00:22:16.335 --> 00:22:19.772
then grouping one or more of
that and end anchor it and give

00:22:19.772 --> 00:22:24.443
it different character and make
it fail and that's what they do.

00:22:24.443 --> 00:22:28.380
Their example, say you add 4 A
as and an X. That will give it

00:22:28.380 --> 00:22:32.184
16 possible paths that it would
find out that it is not

00:22:32.184 --> 00:22:35.287
matching. but if you just gave
it a little bit more As that

00:22:35.287 --> 00:22:41.193
example there, 65 thousands
different paths it has to take.

00:22:41.193 --> 00:22:46.832
Which takes so much longer. But
unfortunately that's the naive

00:22:46.832 --> 00:22:51.203
assumption that the reg x is not
going to do a any or the engine

00:22:51.203 --> 00:22:54.840
will not going to do any of a
little bit of optimizing. So

00:22:54.840 --> 00:22:57.643
like optimization without
thinking I'm going the flood the

00:22:57.643 --> 00:23:04.984
word but is getting optimize to
that right there. So kinda a

00:23:04.984 --> 00:23:08.621
metaphor for that for any hard
core C people with compilers

00:23:08.621 --> 00:23:13.292
this optimization as well. Even
if you dont know C, this is

00:23:13.292 --> 00:23:16.395
really like child's play. This
is saying the number we get if

00:23:16.395 --> 00:23:23.903
we're actually not taking it in
but if 5 is greater than 0 print

00:23:23.903 --> 00:23:28.340
true otherwise print false.
That's pretty simple. So when we

00:23:28.340 --> 00:23:32.278
actually compile it, with a
debugger. Is not actually doing

00:23:32.278 --> 00:23:39.351
a lot we're just making a call
here after we set up a stack

00:23:39.351 --> 00:23:43.322
frame. And you know we already
have this true populated and

00:23:43.322 --> 00:23:46.258
registration there and if you
are looking at the X to the

00:23:46.258 --> 00:23:48.894
program itself we have true but
we dont have false. But

00:23:48.894 --> 00:23:52.097
its true meaning is straight
going to print app. Just

00:23:52.097 --> 00:23:55.968
printing true because the
compiler knows that in this case

00:23:55.968 --> 00:23:59.805
back here there is never a
situation for this code where

00:23:59.805 --> 00:24:01.974
false is ever be true. It
already knows that. So why

00:24:01.974 --> 00:24:05.878
compile that, why even make code
for that. So we have trick the

00:24:05.878 --> 00:24:09.348
optimization and only just a
little bit, just simply. So we

00:24:09.348 --> 00:24:11.350
make a variable that's equals to
five and we test if that

00:24:11.350 --> 00:24:18.090
variable is greater than 0. So
that's all we have to do to make

00:24:18.090 --> 00:24:21.760
the compile not able to
understand what is doing. So

00:24:21.760 --> 00:24:24.029
when we do that simple
modification. If we look at that

00:24:24.029 --> 00:24:29.101
at the debugger. We see that is
moving 5 into an area and it is

00:24:29.101 --> 00:24:32.938
comparing right there with the 0
and we do have some conditional

00:24:32.938 --> 00:24:36.342
instructions. Until we actually
get into the call print out. So

00:24:36.342 --> 00:24:41.213
if you look at memory you see it
has true or false state. That's

00:24:41.213 --> 00:24:44.683
what we have to do reg x. I know
its like a tangent kind of

00:24:44.683 --> 00:24:49.121
analogy. But we kinda do that
with similar expressions. So in

00:24:49.121 --> 00:24:51.690
the OS example they are doing a
plus so whats kinda similar

00:24:51.690 --> 00:24:59.164
to a plus so we kinda use the
curly braces. The ranch thing so

00:24:59.164 --> 00:25:03.869
we can say, this is our range,
is like almost one or more,

00:25:03.869 --> 00:25:10.209
right? So to kind of format that
example in that way to replace

00:25:10.209 --> 00:25:16.215
all the pluses with one more
than nine thousand. We have that

00:25:16.215 --> 00:25:20.119
group and we have 1 to 9 more
than 1 thousand again and

00:25:20.119 --> 00:25:26.125
anchored. I would zoom out of
this but this is me benchmarking

00:25:29.828 --> 00:25:33.332
it so I did not do AX I did AB
with that expression there and I

00:25:33.332 --> 00:25:35.901
timed it use your bend time and
that first one there we have

00:25:35.901 --> 00:25:38.237
almost a second and you'll
notice I'm increasingly adding

00:25:38.237 --> 00:25:43.375
an A each time I test the time,
right? So I go back to actual

00:25:43.375 --> 00:25:47.946
timing, one second, two seconds
4 seconds. Almost 10 seconds. 15

00:25:47.946 --> 00:25:52.951
seconds. You see what's
happening here after we add one

00:25:52.951 --> 00:25:57.322
more A each time. It doubles.
And then we see these two down

00:25:57.322 --> 00:26:03.328
here. like .02 seconds. That
really was the original OAS

00:26:06.432 --> 00:26:08.434
example. So you see it really
getting optimized. It doesn't

00:26:08.434 --> 00:26:11.203
take a long time you still have
to trick it. And you might be

00:26:11.203 --> 00:26:13.572
thinking. Theres not a lot of
time to have control to the

00:26:13.572 --> 00:26:15.574
expression itself. Because this
is considering you do have

00:26:15.574 --> 00:26:17.910
control and you do get to make
bad expression, it does happen

00:26:17.910 --> 00:26:23.649
rarely. One kind of really naive
but still it happened scenario

00:26:23.649 --> 00:26:31.089
is you a server side validation
for someone trying to sign up

00:26:31.089 --> 00:26:34.059
for an account in a web site. On
the client side you just Dos

00:26:34.059 --> 00:26:38.230
yourself. But server side when
you are registering your user

00:26:38.230 --> 00:26:40.566
name and password it wants to
make sure they're not the same.

00:26:40.566 --> 00:26:44.203
You should never use regular
expressions to check that. But

00:26:44.203 --> 00:26:48.273
in case you did, For the
username poor regular used

00:26:48.273 --> 00:26:53.145
expression and for that password
you have a string that dos it.

00:26:53.145 --> 00:26:56.815
Dosing that in the server.
Its a run down to benchmark.

00:26:56.815 --> 00:27:01.386
I get more gnarly about that
later down. Now we talk about

00:27:01.386 --> 00:27:07.926
the animation the theory of what
goes into it and I'll show some

00:27:07.926 --> 00:27:11.296
cool funny examples of that and
then I'll do a demo of the

00:27:11.296 --> 00:27:14.900
script that I wrote. DFA have
not gone that much attention. As

00:27:14.900 --> 00:27:18.971
far as research. But is the
easiest to benchmark. And that

00:27:18.971 --> 00:27:23.742
is all that you can do. You can
only benchmark it. You cant

00:27:23.742 --> 00:27:27.279
really like make something worst
for the expression already. So

00:27:27.279 --> 00:27:30.382
its either its good or it is
bad. So if are you dossing you

00:27:30.382 --> 00:27:33.819
just kinda be aware of what a
bad expression is for typical

00:27:33.819 --> 00:27:37.189
like dos or D dos situation
instead of like loading a web

00:27:37.189 --> 00:27:41.827
page you just do a post to that
expression with the string

00:27:41.827 --> 00:27:44.363
that's arbitrary. It doesn't
matter. Now you are making it

00:27:44.363 --> 00:27:47.966
low that state table and consume
memory. so what I did to

00:27:47.966 --> 00:27:53.172
benchmark it I use the Re 2
module and I used perl. And I

00:27:53.172 --> 00:27:56.542
slowly starved it of its
resources. So I would load the

00:27:56.542 --> 00:28:00.178
state table used the module
again but I would tell it to use

00:28:00.178 --> 00:28:02.214
a little more memory and try
again and a little more memory.

00:28:06.585 --> 00:28:09.221
Eventually I'm going to get some
errors that it ran out of memory

00:28:09.221 --> 00:28:15.227
and I capture that and record
it. And this is yeah, so that's

00:28:19.498 --> 00:28:24.403
all for DFA I'm right into NFA
now. So for NFA it is more

00:28:24.403 --> 00:28:28.206
complicated. The string matter.
So how do you automate that, how

00:28:28.206 --> 00:28:31.076
do you say look at expressions
and know this one will not

00:28:31.076 --> 00:28:33.712
preform well when you dont
know what string is attach to

00:28:33.712 --> 00:28:36.748
it. you can't just give it an
arbitrary string and timed that.

00:28:36.748 --> 00:28:40.919
You kinda have to some way
automatically generate a string

00:28:40.919 --> 00:28:45.123
that is bad. And in my case,
generate a string thats good

00:28:45.123 --> 00:28:49.194
to. So not only I could compare
like is this string generally

00:28:49.194 --> 00:28:52.397
bad for any strings. Or somebody
it like an expression that it

00:28:52.397 --> 00:28:54.733
might be okay given the
environemnt but somebody still

00:28:54.733 --> 00:29:00.372
can abuse it and I keep track of
all that. And one way to think

00:29:00.372 --> 00:29:04.543
about crafting a really bad
string is I call it long circuit

00:29:04.543 --> 00:29:06.545
attack because when you are
thinking of programing languages

00:29:06.545 --> 00:29:11.149
in C you have a bunch of ors
conditional like if A or B or C

00:29:11.149 --> 00:29:15.320
or D and on. If are you variable
had A is not going to evaluate

00:29:15.320 --> 00:29:18.890
anything after that, if it has A
it stops. So if you long circuit

00:29:18.890 --> 00:29:25.330
it. You have a string like, it
has everything ABC and the last

00:29:25.330 --> 00:29:29.835
one is not. So it fails on that
part. Another thing is if you

00:29:29.835 --> 00:29:33.271
see a quantifier. My string will
pick up as many as possible. if

00:29:33.271 --> 00:29:38.043
is you know A plus I'm going to
put a bunch of A, if you is A 1

00:29:38.043 --> 00:29:41.713
through 15. I would pick 15
As. And for any alternation I

00:29:41.713 --> 00:29:45.083
pick the last alternative so it
has to look at all of them so it

00:29:45.083 --> 00:29:51.523
gets to that. Here's an example.
This is expression, either an AB

00:29:51.523 --> 00:29:57.329
or CD or YZ. Anywhere from 1 to
20 of them and then a G. So

00:29:57.329 --> 00:29:59.865
simple example that will match
and this is what will match the

00:29:59.865 --> 00:30:05.303
quickest. AB satisfied. And that
was one of them. And that

00:30:05.303 --> 00:30:09.141
happens to be a G we are done.
We matched. An example of what

00:30:09.141 --> 00:30:11.143
will take a lot longer.
Theres a YZ, you got to look

00:30:11.143 --> 00:30:13.145
at AB, no. CD no, YZ yes. Ok
theres a YZ. is the next one

00:30:13.145 --> 00:30:19.151
a G? No, okay, so is it AB, is
it CD, is is a YZ. So we do that

00:30:21.953 --> 00:30:27.659
20 times and then eventually A
it will pick A because is not G.

00:30:27.659 --> 00:30:29.995
So it still has to look at
everything and backtrack,

00:30:29.995 --> 00:30:32.631
everything and backtrack and
that's the longest it will take

00:30:32.631 --> 00:30:38.136
to solve that one. Is and as far
as the complication to

00:30:38.136 --> 00:30:42.307
automating this, say our
expression end up with a G.

00:30:42.307 --> 00:30:48.346
which will start 0 or more, 0 is
an option so being that I have

00:30:48.346 --> 00:30:53.051
negate that last one this YZ YZ
YZ A will still match because I

00:30:53.051 --> 00:30:58.523
do not need to have the G at
that point so I still works. I

00:30:58.523 --> 00:31:03.095
have to find a way to negate the
last [ inaudible ] that isnt

00:31:03.095 --> 00:31:08.133
optional. So anything star so
any 0 to whatever number

00:31:08.133 --> 00:31:14.139
quantifiers I cant use those
or even the question mark one.

00:31:16.775 --> 00:31:24.182
So I made a script called bench
wreckers IPL. I'll show you some

00:31:24.182 --> 00:31:28.854
example output of some arbitrary
strings and then I'll show you

00:31:28.854 --> 00:31:32.391
it working but I thought it will
be cool at some example to see

00:31:32.391 --> 00:31:37.496
what tricks it does for it. So
the expression at the top is hi.

00:31:37.496 --> 00:31:41.767
Thats the regular expression.
My script will output Ha like it

00:31:41.767 --> 00:31:44.803
match it is first part and
negates the last part. So

00:31:44.803 --> 00:31:48.974
thats how it works. So being
we got ha from here. So lets

00:31:48.974 --> 00:31:54.813
use HA as the expression and see
what it does with that. I said

00:31:54.813 --> 00:32:00.051
HA and it says H 1. Still
negates it. So I did 1 to 15 A

00:32:00.051 --> 00:32:04.222
and then an H and then a [
inaudible ]. Well you know

00:32:04.222 --> 00:32:07.325
again, the most amount of
quantifier and thats 15 As

00:32:07.325 --> 00:32:11.263
and then an H not an bang. A it
still fails. But it makes [

00:32:11.263 --> 00:32:13.598
inaudible ] possible. Again like
a big long alternation of a lot

00:32:13.598 --> 00:32:16.034
of alternatives and then a D and
a one, the last alterations it

00:32:16.034 --> 00:32:22.040
does a D but not a 1. I do any
amount of Hs like where are one

00:32:27.245 --> 00:32:33.351
or more Hs and then an I then an
Hs then an A. This one okay

00:32:33.351 --> 00:32:41.126
yes, so it has 7 X and then one
or more or one to 10 As and that

00:32:41.126 --> 00:32:44.696
1 to 10 times, but it picks up
just the one. Because you cannot

00:32:44.696 --> 00:32:49.935
have any As. This one is more
interesting is kind of the same

00:32:49.935 --> 00:32:53.171
thing but we are just adding an
end anchor to the end of that.

00:32:53.171 --> 00:32:56.908
So it starts with the X. It does
a whole bunch of A so it can end

00:32:56.908 --> 00:33:01.546
with a 1 so it has to do a lot
of backtracking to see the most

00:33:01.546 --> 00:33:08.587
time to evaluate so it know it
doesnt match. so this is the

00:33:08.587 --> 00:33:12.190
script I was talking about. What
you do is use a text file with a

00:33:12.190 --> 00:33:15.293
lot of expressions. It goes
through them all it does a

00:33:15.293 --> 00:33:19.130
memory testing. It generates the
good needle string and test to

00:33:19.130 --> 00:33:22.400
see how good it takes to run
each one. And then you can

00:33:22.400 --> 00:33:27.672
output a CSV file. So in spread
sheet software you can sort them

00:33:27.672 --> 00:33:32.477
to best to worse or whatever.
And for my research, just goes

00:33:32.477 --> 00:33:35.480
to the long list of expressions.
I thought it will be fun to look

00:33:35.480 --> 00:33:40.518
at merging threat ideas and [
inaudible ] and reg x live dot

00:33:40.518 --> 00:33:45.257
com. And that was like the best
for debugging my script because

00:33:45.257 --> 00:33:48.960
there were like really strange
and terrible expressions that

00:33:48.960 --> 00:33:51.229
broke my script and some of them
still do. I do not try to

00:33:51.229 --> 00:33:55.700
validate whether it is a real
validated expression. To be

00:33:55.700 --> 00:34:01.506
honest the script is a little
bit buggy. But it workings

00:34:01.506 --> 00:34:04.910
pretty well. I'm not going to
say like this expression

00:34:04.910 --> 00:34:08.480
universally take 1.5 second,
well it doesn't in this machine

00:34:08.480 --> 00:34:13.451
but still giving you an idea. So
examples of real stuff in the

00:34:13.451 --> 00:34:19.057
wild. This is most complete URL
validator. If you dont need

00:34:19.057 --> 00:34:22.594
the most complete URL valid
dont do that. If are you

00:34:22.594 --> 00:34:27.666
using a DFA that will take 150
Megs each shot you use that

00:34:27.666 --> 00:34:30.402
expression. This is not so bad.
Im just throwing an example in

00:34:30.402 --> 00:34:35.540
for those not bad. This supposed
to validate long Window file

00:34:35.540 --> 00:34:41.279
names. Uses a less than a meg of
a memory. This is probably the

00:34:41.279 --> 00:34:47.285
worse time dates or DFA from
regex but it supposed to match

00:34:49.354 --> 00:34:52.557
any valid human name like
peoples name like Mr.

00:34:52.557 --> 00:34:56.528
Whatever you know. This
expression takes more than 4

00:34:56.528 --> 00:35:04.069
seconds each time you use it
with an evil string. And now I

00:35:04.069 --> 00:35:11.543
get into some of the IDS rules
this one is not so bad memory

00:35:11.543 --> 00:35:19.417
wise. This one is really bad
time wise and the actual rule is

00:35:19.417 --> 00:35:22.354
merge threat [ inaudible ]
remote code execution. For the

00:35:22.354 --> 00:35:27.192
evil string that my script
generates. It takings 1.6

00:35:27.192 --> 00:35:34.899
seconds to validate. But if you
think about this. But if it

00:35:34.899 --> 00:35:41.072
takes longer to your IDS to
validate this string then it

00:35:41.072 --> 00:35:45.543
takes for me to send the packet
have you a problem. And by the

00:35:45.543 --> 00:35:49.748
way last year at defcon I did a
presentation on various things.

00:35:49.748 --> 00:35:54.786
But one of them, this script
called 8 ball that will attempt

00:35:54.786 --> 00:35:59.858
to trigger every single idea
rule in an IDS. You feed it a

00:35:59.858 --> 00:36:04.229
IDS rule set. It deconstruct all
the rules. Makes a packet for

00:36:04.229 --> 00:36:08.466
each rule and sends it to a
target. So this ideas has reg X

00:36:08.466 --> 00:36:13.004
on it. So this 8 ball script I
added a speedball option now you

00:36:13.004 --> 00:36:17.942
can tell it to do redof for all
of these packets as well. It

00:36:17.942 --> 00:36:22.647
will not trigger all the ideas
rules, it will actually take the

00:36:22.647 --> 00:36:27.752
idea as long as possible and
fail to match too so you would

00:36:27.752 --> 00:36:31.556
not see alerts in theory. And
just to show an example because

00:36:31.556 --> 00:36:33.558
I'm talking ability the
benchmark. But if you want to

00:36:33.558 --> 00:36:36.261
see what a string would look
like with this tool for a real

00:36:36.261 --> 00:36:39.397
expression thats what it
generates. Cool, thats what

00:36:39.397 --> 00:36:43.134
the main reason of automating.
The OAS page Like obviously that

00:36:43.134 --> 00:36:45.770
make sense but I don't think I
would ever really look at this

00:36:45.770 --> 00:36:48.373
expression and thinking, this is
a terrible expression, take a

00:36:48.373 --> 00:36:51.076
while to validate with some
string I havent thought of.

00:36:51.076 --> 00:36:54.079
But when you automate it I still
get something like this but it

00:36:54.079 --> 00:36:57.382
still takes a while. And then
looking at it in DFA context

00:36:57.382 --> 00:37:03.388
this is where I like give
examples the worse I can

00:37:05.457 --> 00:37:07.459
possible throw at it. 150 mg
doesnt sound that bad. I

00:37:07.459 --> 00:37:09.461
think that other one that was
really bad. I just want to see,

00:37:09.461 --> 00:37:11.463
yeah that's really -- wow,
that's funny when I try to be

00:37:11.463 --> 00:37:13.465
the worse I possibly can that's
about as good as I can can do.

00:37:13.465 --> 00:37:15.467
This is me trying to do a simple
bad expression by building a big

00:37:15.467 --> 00:37:17.469
stage table and I barely get 10
megabytes more. But this is the

00:37:17.469 --> 00:37:19.471
worst I can do. And then for
time one men forget about it. To

00:37:19.471 --> 00:37:21.473
do really bad with that one, I
start with this expression and

00:37:21.473 --> 00:37:23.475
this is the same expression I'm
going to use every time so like

00:37:23.475 --> 00:37:25.477
this string with 40 As and a B
that will take 2 days and I

00:37:25.477 --> 00:37:27.479
tested that it took me 2 days
right. and in theory

00:37:27.479 --> 00:37:29.481
it is and it really like times
2. So 54 As will take like a

00:37:29.481 --> 00:37:31.483
lifetime. And 81 As [
inaudible ] based on 13 14

00:37:31.483 --> 00:37:33.485
billiopn years. it will finish
it is infinity it will finish.

00:37:33.485 --> 00:37:35.487
But that doesnt gonna mean
much if it takes that long. And

00:37:35.487 --> 00:37:37.489
Im almost done, Im going
to show the demo really quick.

00:37:37.489 --> 00:37:39.491
But I thought this is fun.
Looking at an expression like

00:37:39.491 --> 00:37:41.493
this, right here. Im not
really immediately looking what

00:37:41.493 --> 00:37:43.495
this is for. But this is my none
dos engine and and my dos

00:37:43.495 --> 00:37:45.497
engine. this are the strings I
made for it. And I think

00:37:45.497 --> 00:37:47.499
thats kinda cool. Because I
look at that expression, yeah

00:37:47.499 --> 00:37:49.501
Viagra This is from regex lib. [
inaudible ] probably for spam.

00:37:49.501 --> 00:37:51.503
That's cool too automation is
funny. More recently I did not

00:37:51.503 --> 00:37:53.505
dig into this one. But you can
use that too. [ inaudible ] you

00:37:53.505 --> 00:37:55.507
ca use regular expressions on
that. Again I kind of so the

00:37:55.507 --> 00:37:57.509
funny thing is this NFA or DFA I
had to use any tricks to see

00:37:57.509 --> 00:38:00.512
what that was and it turns out
is definitely not an DFA.

00:38:00.512 --> 00:38:06.518
Because it is not deterministic
time wise. But it doesn't seem

00:38:09.487 --> 00:38:15.493
to be pure NFA either because is
not double ever A I had. It

00:38:20.965 --> 00:38:26.971
seems that it is a hybrid. But
it definitely has some NFA

00:38:30.775 --> 00:38:35.747
elements based on the
exponential increase in this

00:38:35.747 --> 00:38:41.753
string that I gave to it. So an
actual test that I did was a 100

00:39:30.401 --> 00:39:33.972
bite file that is checking for
malware I did. So up here is the

00:39:33.972 --> 00:39:39.777
rule that I am using. I have a
file with 99 A and a B. That

00:39:39.777 --> 00:39:43.181
took me 13 hours to see if that
was malware. Based on that

00:39:43.181 --> 00:39:50.688
definition. So that's kind of
bad. That's harder to attack

00:39:50.688 --> 00:39:54.325
because I don't know of anybody
that will be using a definition

00:39:54.325 --> 00:39:59.163
like that. That's just me trying
to do it badly and really allot

00:39:59.163 --> 00:40:01.466
of the definitions I have seen
most people don't use

00:40:01.466 --> 00:40:05.403
expressions they just use string
and hex matches and build

00:40:05.403 --> 00:40:12.477
complex logics condition section
here. And you know, pixels

00:40:12.477 --> 00:40:17.081
didn't happen this is screen
shot. So is me timing it. [

00:40:17.081 --> 00:40:23.354
inaudible ] Rule file with that
text file [ inaudible ]. This is

00:40:23.354 --> 00:40:28.026
the 13 hours 19 minutes. I'm
showing the output of an

00:40:28.026 --> 00:40:34.032
expression that's similar. And
shows A and the B and I see is a

00:40:41.072 --> 00:40:47.979
100 bites down there and demo
time. Is a good time for me to

00:40:47.979 --> 00:40:51.549
take a drink again because it is
testing the time on this. So it

00:40:51.549 --> 00:40:55.553
does have timeouts. So its not
going crazy to take like your

00:40:55.553 --> 00:40:59.857
lifetime. So by defaulting it
timeouts like 30 seconds. You

00:40:59.857 --> 00:41:03.428
can expressions that timeout you
can define the time out as

00:41:03.428 --> 00:41:06.831
longer if you want to you can
explore that. So by default it

00:41:06.831 --> 00:41:10.635
times out so you don't go crazy.
And you see I'm running tool

00:41:10.635 --> 00:41:17.975
against the text file [
inaudible ] I wanted to see CSV

00:41:17.975 --> 00:41:23.247
that text files is back here.
I'm giving it nonexpression.

00:41:23.247 --> 00:41:29.253
Some familiar is bad one, some
not, the Viagra one and the bad

00:41:32.190 --> 00:41:40.164
regex lib one and it has finish.
I'm going to open it up. Is tab

00:41:40.164 --> 00:41:42.166
limited and I know that's kind
of weird it is not comma

00:41:42.166 --> 00:41:44.769
delimited but it was easier
because a lot of expression have

00:41:44.769 --> 00:41:48.806
tab in them. So have expression
output in it as well annoying

00:41:48.806 --> 00:41:54.746
without using a really good
module for csv. So these are

00:41:54.746 --> 00:41:58.549
your expressions. you can see
how long it takings. This one is

00:41:58.549 --> 00:42:03.287
clearly the worse of those. 11
seconds. But you see the 4 and a

00:42:03.287 --> 00:42:09.193
half second one so that's the
dos time but I also timed how

00:42:09.193 --> 00:42:14.766
good expressions so I can timed
a bad expressions here. 1 to 8 1

00:42:14.766 --> 00:42:19.737
to 8 thing the anchor. Normally
it can take like a split second

00:42:19.737 --> 00:42:23.841
but it could up to 11. So that's
interesting thing is not always

00:42:23.841 --> 00:42:27.078
bad. And I giver it delta like
the difference between the good

00:42:27.078 --> 00:42:30.581
and a bad. And then I give the
memory assuming is DFA and

00:42:30.581 --> 00:42:33.951
clearly this one is the worst
down here that was the one that

00:42:33.951 --> 00:42:39.223
build state table dos. So that's
all I'm good to know. Which ones

00:42:39.223 --> 00:42:42.126
are the worse for time or
memory. But I'm still

00:42:42.126 --> 00:42:48.666
interesting to know what the
good and evil strings are as

00:42:48.666 --> 00:42:52.703
well because it didn't tell us.
So I gave an option for that

00:42:52.703 --> 00:42:57.675
dash dash strings it doesn't
measure the time so you get

00:42:57.675 --> 00:43:02.080
instantly. So if I go up here.
You should get the feedback

00:43:02.080 --> 00:43:08.853
right away. So A dot plus RGH,
is like ARGH, for the dos string

00:43:08.853 --> 00:43:12.523
and then simple string is just
ARG. Some of them arent that

00:43:12.523 --> 00:43:18.329
disable. The dot string is A
that's not going to take time as

00:43:18.329 --> 00:43:24.135
simple sting is B. Is A because
is negating the whole thing. A

00:43:24.135 --> 00:43:28.206
bad one with a DFA would be this
but the dos for the simple

00:43:28.206 --> 00:43:33.611
string is more for the NFA. and
you're Viagra there the one you

00:43:33.611 --> 00:43:37.949
saw on the deck here and then
you get this string one right

00:43:37.949 --> 00:43:43.321
here from regex lib. So that's
the demo pretty quick. And it is

00:43:43.321 --> 00:43:47.792
on my github and again if you
want that address its the guy

00:43:47.792 --> 00:43:53.798
down here and is over. [
APPLAUSE ] >> Thank you. 

