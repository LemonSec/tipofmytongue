00:00:01.201 --> 00:00:05.839
DLL hijack on operating system
ten. My name is path Wardle.

00:00:05.839 --> 00:00:09.243
It's the only U.S. government
agency that listens. The rest

00:00:09.243 --> 00:00:15.249
don't pay attention. I work as
the director of R and D at

00:00:18.252 --> 00:00:24.458
Synack they do crowd sourced
vulnerability. Anyone can sign

00:00:24.458 --> 00:00:31.365
up to find vulnerabilities on
websites, mobile devices, IOT

00:00:31.365 --> 00:00:38.505
devices. And not a secret
secret, their security is really

00:00:38.505 --> 00:00:43.343
bad. It's a blood bath. We pay a
ton of money to researchers. If

00:00:43.343 --> 00:00:49.349
you want to make money and get
paid to hack legally. Synack.

00:00:52.386 --> 00:00:58.392
Since we're in Vegas it's good
to define terms. Implants are

00:01:00.527 --> 00:01:06.533
persist tent malicious code.
Intercepting function code. A

00:01:08.669 --> 00:01:12.105
Trojan is a malicious program.
Injection is about getting code

00:01:12.105 --> 00:01:18.111
into remote process. And back
door is code that provides

00:01:20.480 --> 00:01:27.921
undetected remote control.
Today's talk is three parts. A

00:01:27.921 --> 00:01:35.529
brief overview of DLL hijacking
on Windows. We're going to look

00:01:35.529 --> 00:01:38.832
at the features and loader and
linker that allow us to realize

00:01:38.832 --> 00:01:42.636
this attack and talk about how
to find vulnerable applications

00:01:42.636 --> 00:01:46.707
to hijack. And finally walk
through some hijack examples

00:01:46.707 --> 00:01:51.378
because there are nuances to
this. We're going to end with

00:01:51.378 --> 00:01:55.749
some attacks and defenses.
First, let's talk about DLL

00:01:55.749 --> 00:01:58.719
hijacking on Windows. The reason
we talk about this first is

00:01:58.719 --> 00:02:04.691
because it's similar to --
hijacking on operating system S.

00:02:04.691 --> 00:02:07.694
There are real life examples of
DLL hijacking that illustrate

00:02:07.694 --> 00:02:12.933
the gravity of this kind of
attack. Some of you are probably

00:02:12.933 --> 00:02:16.770
familiar with DLL hijacking on
Windows. Starts with an

00:02:16.770 --> 00:02:21.975
application that starts into a
DLL instead of a qualified path.

00:02:21.975 --> 00:02:26.513
This makes it vulnerable. When
only a name is provided the

00:02:26.513 --> 00:02:29.816
Windows loader look in various
application directories before

00:02:29.816 --> 00:02:36.757
the system directory. We have an
application that says I have a

00:02:36.757 --> 00:02:40.394
dependency on (audio blipped)
the loader says, okay, you

00:02:40.394 --> 00:02:42.662
didn't give me a full path. I'm
going to look in several

00:02:42.662 --> 00:02:46.400
directories. I'm going to start
with the current one or the

00:02:46.400 --> 00:02:50.137
applications directory before
looking in the system directory.

00:02:50.137 --> 00:02:54.107
What malware can do is plant
malicious DLL in the primary

00:02:54.107 --> 00:02:58.078
search directory and the loader
can be tricked to using the

00:02:58.078 --> 00:03:01.248
malicious one. -- very useful
for malicious adversaries in

00:03:01.248 --> 00:03:04.851
malware. You can persist without
touching the registry. All you

00:03:04.851 --> 00:03:09.189
have to do is (audio blipped)
and it loads. Load time process

00:03:09.189 --> 00:03:12.793
injection. If a browser is
vulnerable to DLL hijacking you

00:03:12.793 --> 00:03:16.763
plant a malicious DLL and your
DLL gets loaded into the

00:03:16.763 --> 00:03:20.000
context. Used to bypass UAC.
There are applications on

00:03:20.000 --> 00:03:22.536
Windows that are autoUAC,
automatically elevated without

00:03:22.536 --> 00:03:26.173
putting in the password. If
these applications are

00:03:26.173 --> 00:03:33.046
vulnerable to DLL hijack, you
can plant a DLL and execute the

00:03:33.046 --> 00:03:39.052
applications and the DLL is
(audio blipped) in the process.

00:03:41.488 --> 00:03:47.494
Aspects where this can be used
for remote infection. If an

00:03:50.397 --> 00:03:53.667
attacker can -- off web dab
share, they can get the DLL

00:03:53.667 --> 00:03:57.904
loaded from that remote share as
well. Here are examples.

00:03:57.904 --> 00:04:03.844
Persistence. There is a blog
written and they talk about

00:04:17.357 --> 00:04:21.528
unrelated samples of malware
they were all named the same in

00:04:21.528 --> 00:04:25.599
Windows. If you look deeper,
explore dot EXE was subject to

00:04:25.599 --> 00:04:30.504
attack. If you plant that in
Windows, every time when

00:04:30.504 --> 00:04:34.908
explorer starts the malicious
DLL gets loaded. (audio blipped)

00:04:34.908 --> 00:04:39.813
vulnerable to DLL hijacking.
Here is malware that was abusing

00:04:39.813 --> 00:04:44.985
this. It would plant a malicious
DLL and start CYS prep

00:04:44.985 --> 00:04:47.787
[indiscernible] processing. What
does DLL hijacking stand today.

00:04:47.787 --> 00:04:49.790
Microsoft responded and they
patched the applications. They

00:04:49.790 --> 00:04:51.792
set some registry keys that help
control the loader so maybe it

00:04:51.792 --> 00:04:53.793
wouldn't be tricked as much.
When I was working on these

00:04:53.793 --> 00:04:55.796
slides two weeks ago, there was
a security advisory released by

00:04:55.796 --> 00:04:57.797
Microsoft they had to repatch an
application because it was

00:04:57.797 --> 00:04:59.799
vulnerable to this DLL hijack.
This bodes well for an attacker

00:04:59.799 --> 00:05:01.735
if they can find a similar
attack. 6 months ago I was

00:05:01.735 --> 00:05:03.737
reading stack overflow. I do
programming at work and this is

00:05:03.737 --> 00:05:05.739
how I code at work. I see what
other people are doing. And I

00:05:05.739 --> 00:05:07.741
found this quote by Mark B. I
owe him a beer. Any DLS is

00:05:07.741 --> 00:05:09.743
vulnerable to DLL hijacking. I'm
going to [indiscernible] on

00:05:09.743 --> 00:05:13.847
operating system X. Why are
attacks on Mac a big deal? This

00:05:13.847 --> 00:05:19.853
is kind of an obvious statement
but Macs are ever where. You

00:06:14.975 --> 00:06:18.245
look around a security
conference, college campuses, R

00:06:18.245 --> 00:06:23.917
and D centers, everyone uses
Mac. When a technology becomes

00:06:23.917 --> 00:06:30.156
more prevalent, attacks become
more valuable and destructive.

00:06:30.156 --> 00:06:32.859
So the previous terms I defined
were funny. These are more

00:06:32.859 --> 00:06:36.963
serious but equally important.
When I say mock -- this is the

00:06:36.963 --> 00:06:39.499
executable format that apple
uses. Windows has PE files, and

00:06:39.499 --> 00:06:42.035
Linux L files and Macs have
(inaudible). Windows has DLLs.

00:06:42.035 --> 00:06:45.071
Linux is dot SOs and Mac ...
Load commands. They are embedded

00:06:45.071 --> 00:06:47.374
in these binaries (audio
blipped) commands to the loader.

00:06:47.374 --> 00:06:50.143
They do things like specify the
memory lay out, the initial

00:06:50.143 --> 00:06:52.445
execution thread of the main
execution state. (audio blipped)

00:06:52.445 --> 00:06:54.714
loader should load. Since these
load commands play such a

00:06:54.714 --> 00:06:58.685
pivotal role I wanted to talk
more in depth. Embedded in the

00:06:58.685 --> 00:07:01.488
binary and read by the loader.
And you can view them with tools

00:07:01.488 --> 00:07:03.490
like mock OV or O tool. One of
the most important load commands

00:07:03.490 --> 00:07:05.492
for this presentation is the LC
load command. This is one for

00:07:05.492 --> 00:07:07.494
each -- application as a
dependency. This is like an

00:07:07.494 --> 00:07:09.496
entry in the IAT on Windows. I
have a dependency, load it into

00:07:09.496 --> 00:07:11.498
memory. Let's take a closer look
at the load command. Starts with

00:07:11.498 --> 00:07:13.500
a load command header, the
command number and size. Then a

00:07:13.500 --> 00:07:15.502
DILib structure. A name, a full
path and versioning information.

00:07:15.502 --> 00:07:17.504
There is another important load
command called the LCID DILib

00:07:17.504 --> 00:07:19.506
load command. This shares the
same format as the LC load

00:07:19.506 --> 00:07:21.508
command. The reason is it's
complimentary. Applications have

00:07:21.508 --> 00:07:23.510
the LV load DILib command which
says there is a dependency. The

00:07:23.510 --> 00:07:25.512
loader goes and finds the DILib
and looks for the (audio

00:07:25.512 --> 00:07:27.514
blipped) command and make sure
they have the same format and

00:07:27.514 --> 00:07:29.516
they're complementary. So back
to DILib hijacking. Let's

00:07:29.516 --> 00:07:31.518
specify exactly what we're
trying to do. We want to be able

00:07:31.518 --> 00:07:33.520
to plant or drop a malicious
DILib and have it matched to an

00:07:33.520 --> 00:07:35.522
application. Obviously you can
achieve this by patching a

00:07:35.522 --> 00:07:37.524
binary and putting in a new
dependency. This breaks the

00:07:37.524 --> 00:07:39.526
digital signature and it's easy
to detect. We're going to say no

00:07:39.526 --> 00:07:41.528
other modifications to the
operating system. No autorun key

00:07:41.528 --> 00:07:43.530
less files or anything. Just
plant the file on the file

00:07:43.530 --> 00:07:45.532
system. Again we want it
independent of the users

00:07:45.532 --> 00:07:47.534
environment. We're not going to
modify any path variables. If we

00:07:47.534 --> 00:07:49.536
can find an attack on operating
system X, dropping a DILib and

00:07:49.536 --> 00:07:51.538
getting it loaded, it would be
powerful and we would be able to

00:07:51.538 --> 00:07:53.540
abuse it similar to DLL
hijacking on Windows (audio

00:07:53.540 --> 00:07:55.542
blipped) load time process,
bypass security and open avenues

00:07:55.542 --> 00:07:57.544
to facilitate infection. Windows
and DLL injection was about all

00:07:57.544 --> 00:07:59.546
[indiscernible]. When an
application starts the loader

00:07:59.546 --> 00:08:01.481
does a few things. These are
similar to what loaders on other

00:08:01.481 --> 00:08:03.483
operating systems do. They parse
the application they're loading.

00:08:03.483 --> 00:08:05.485
Look for dependencies. Find the
dependencies on disk. Load them

00:08:05.485 --> 00:08:07.487
into memory and link so the
application can use this. This

00:08:07.487 --> 00:08:09.489
is standard loader, linker
stuff. Take a closer look you

00:08:09.489 --> 00:08:11.491
can see what DILib is doing. The
first code (audio blipped) in

00:08:11.491 --> 00:08:15.562
that newly-borne process is
DILib under score start. This

00:08:15.562 --> 00:08:20.567
calls start and then main. This
isn't the applications name,

00:08:20.567 --> 00:08:23.436
it's the loaders name. Name gets
-- link. Link calls recursive

00:08:23.436 --> 00:08:26.406
libraries and step four calls
the DILibs and starts the

00:08:26.406 --> 00:08:30.643
loading process. Step five
prerequisite parsing and other

00:08:30.643 --> 00:08:35.115
analysis and step 6, load phase
6 that loads the DILib into

00:08:35.115 --> 00:08:38.785
memory and does the linking.
That is DILib. Let's find some

00:08:38.785 --> 00:08:45.091
logic that we can abuse to
hijack. We want to look for two

00:08:45.091 --> 00:08:50.563
scenarios, the first is there
code within the loader that

00:08:50.563 --> 00:08:57.170
doesn't error out if the DILib
is not found. Is there code

00:08:57.170 --> 00:09:02.575
within the loader that looks for
DILibs in multiple applications.

00:09:02.575 --> 00:09:10.250
If in either case the answer is
yes, we may be able to hijack.

00:09:10.250 --> 00:09:15.755
The first scenario, there is
instance where the dependent is

00:09:15.755 --> 00:09:21.594
not found, we can plant a
malicious DILib and fulfill the

00:09:21.594 --> 00:09:26.433
dependency. In the second
scenario, if the loader is

00:09:26.433 --> 00:09:32.305
looking in multiple places for
the DILibs to load and the

00:09:32.305 --> 00:09:37.644
legitimate DILib is not in a
primary location it's loading,

00:09:37.644 --> 00:09:45.118
we may be able to plant or save
a malicious DILib and trick the

00:09:45.118 --> 00:09:51.524
loader into loading it. Let's
look for the first case which is

00:09:51.524 --> 00:09:58.998
there a scenario where it's okay
if a DILib is not found. In the

00:09:58.998 --> 00:10:03.803
recursive load libraries
function we see an exception is

00:10:03.803 --> 00:10:10.243
thrown if is DILib is not found.
If an application has a

00:10:10.243 --> 00:10:15.582
dependency and the dependency is
unable to be fulfilled the

00:10:15.582 --> 00:10:21.988
loader is going to crash. In the
catch statement the exception is

00:10:21.988 --> 00:10:27.861
ignored if some variable named
is required and not set. There

00:10:27.861 --> 00:10:33.733
is an apple comment that says
weak libraries are okay (audio

00:10:33.733 --> 00:10:39.072
blipped) required variable. We
see code iterating over the load

00:10:39.072 --> 00:10:46.546
bands and the LC load DILib and
a new load command. If the load

00:10:46.546 --> 00:10:52.986
command is this weak DILib the
variable is set to false. The

00:10:52.986 --> 00:10:58.858
exception is avoided. If the
DILib is not there, no harm

00:10:58.858 --> 00:11:04.397
done. By using these weak
dependencies this is the first

00:11:04.397 --> 00:11:08.835
scenario. A weak dependency, the
loader is going to try to find

00:11:08.835 --> 00:11:13.239
the DILib, the application is
like I would have used it if it

00:11:13.239 --> 00:11:17.610
was there but if it's not, no
problem. A hacker can plant a

00:11:17.610 --> 00:11:21.347
malicious DILib in that location
and the loader will find the

00:11:21.347 --> 00:11:25.084
malicious DILib and be tricked
into using it. That was the

00:11:25.084 --> 00:11:28.788
first method. Auditing the code
was a loop. Loading DILibs from

00:11:28.788 --> 00:11:32.258
multiple R path locations. An
inner loop, a vector of path and

00:11:32.258 --> 00:11:39.599
trying each path and seeing if
it can find the DILib in each

00:11:39.599 --> 00:11:46.372
path. I have no idea what this
was functionally doing but apple

00:11:46.372 --> 00:11:53.713
explains. There are two parts to
these. The first is the DILib. A

00:11:53.713 --> 00:11:59.919
run path dependent DILib which
is a library that doesn't know

00:11:59.919 --> 00:12:04.357
where it's going to end up on a
target system when installed.

00:12:04.357 --> 00:12:07.994
The second piece is applications
that link to these independent

00:12:07.994 --> 00:12:11.965
DILibs. The application has to
have some knowledge to tell the

00:12:11.965 --> 00:12:15.201
loader where to look. (audio
blipped) from an attacker's

00:12:15.201 --> 00:12:20.273
point of view we can say DILib
is going to look for DILib in

00:12:20.273 --> 00:12:24.243
multiple areas. We're going to
build a run path library and

00:12:24.243 --> 00:12:27.480
create an example application
that links against the libraries

00:12:27.480 --> 00:12:32.185
that we'll use to hijack. It's a
normal DILib except you put a

00:12:32.185 --> 00:12:35.788
special keyboard. You compile
the DILib and dump the load

00:12:35.788 --> 00:12:41.127
commands. A load command that
tells or identifies the DILib to

00:12:41.127 --> 00:12:43.463
the loader. You can see the name
which is a path starts with a

00:12:43.463 --> 00:12:49.469
special keyword. For an
application to link or make use

00:13:10.290 --> 00:13:12.291
of run path dependent DILibs
they have to do two things. You

00:13:12.291 --> 00:13:14.293
drag the local copy and read the
create the dependency and then

00:13:14.293 --> 00:13:16.296
you have to tell the loader
where this DILib may end up on

00:13:16.296 --> 00:13:18.297
the target system when the
software is deployed. You

00:13:18.297 --> 00:13:20.299
specify search paths. When you
run the application it's going

00:13:20.299 --> 00:13:22.301
to generate load commands. First
is the dependency. And now there

00:13:22.301 --> 00:13:24.303
are new load commands, the RC
load commands. These contain the

00:13:24.303 --> 00:13:26.305
list of places that tell the
loader where to look for the

00:13:26.305 --> 00:13:28.308
DILib. Let's dump each load
command and show you what I'm

00:13:28.308 --> 00:13:30.309
talking about. This is the LC
DILib load command. This

00:13:30.309 --> 00:13:32.311
specifies a dependency. I'm
dependent on a DILib, go load

00:13:32.311 --> 00:13:34.314
it. This is standard. The name
field starts with @R path. This

00:13:34.314 --> 00:13:36.315
says as an application I have
this dependency. When I was

00:13:36.315 --> 00:13:38.317
built I didn't know where this
DILib was going to end up on the

00:13:38.317 --> 00:13:40.319
file system by have embedded
search paths for you to look for

00:13:40.319 --> 00:13:42.321
to try to find it. In order to
find this DILib, the loader

00:13:42.321 --> 00:13:44.324
looks for LCR path load
commands. One for each

00:13:44.324 --> 00:13:46.325
directory. So we go back to the
loader source code and we can

00:13:46.325 --> 00:13:48.327
see where these load commands
are processed and how the loader

00:13:48.327 --> 00:13:50.329
interacts with them. (audio
blipped) get R path. What this

00:13:50.329 --> 00:13:52.331
does is extract the run path and
puts them all into the vector.

00:13:52.331 --> 00:13:54.334
Each of those search directories
and put them into an array into

00:13:54.334 --> 00:13:56.335
a vector. Now a list of where to
look. In load phase 3 which is a

00:13:56.335 --> 00:13:58.337
prerequisite loader functions it
looks for all dependencies that

00:13:58.337 --> 00:14:00.273
start with that P path keyword.
And now it's going to put in a

00:14:00.273 --> 00:14:02.275
search directory and see if it's
happy, if not it goes to the

00:14:02.275 --> 00:14:04.277
next directory to look there.
There are several pre-recs. We

00:14:04.277 --> 00:14:06.279
have an application with a
dependency on a run path

00:14:06.279 --> 00:14:08.281
dependent DILib. The loader is
going to look in the

00:14:08.281 --> 00:14:10.283
applications library directory.
That's the first LCR path. Then

00:14:10.283 --> 00:14:14.754
after it doesn't find the DILib
there it consults the second RC

00:14:14.754 --> 00:14:18.858
path manned and look for the
DILib there. What an evil

00:14:18.858 --> 00:14:22.562
adversary can do is plant or
place a malicious DILib in that

00:14:22.562 --> 00:14:26.132
primary search directory and
every time the search is

00:14:26.132 --> 00:14:29.135
started, it will find that DILib
first and load the malicious

00:14:29.135 --> 00:14:35.141
DILib. It will be tricked into
using ours. I described two ways

00:14:47.286 --> 00:14:53.292
to perform DILib hijacking on
operating system S. First a weak

00:15:00.166 --> 00:15:03.102
dependency, the dependency is
not there we can plant a

00:15:03.102 --> 00:15:05.938
malicious DILib. Or if an
application contains multiple

00:15:05.938 --> 00:15:10.109
search directories, the
legitimate one is not in the

00:15:10.109 --> 00:15:15.181
primary directory. We can plant
a malicious DILib and it will

00:15:15.181 --> 00:15:19.819
get loaded automatically. Now
it's time to perform hijack. We

00:15:19.819 --> 00:15:25.391
use the example application. It
has a dependency on the run path

00:15:25.391 --> 00:15:29.562
dependent DILibs. We confirm
it's vulnerable. The loader has

00:15:29.562 --> 00:15:33.499
variables that you can set that
tell it to do more logging. We

00:15:33.499 --> 00:15:39.505
set the DILib print R pass
environment. This prints all the

00:15:42.241 --> 00:15:48.247
information that the loader is
going to do. On (audio blipped)

00:15:51.050 --> 00:15:57.056
search directly and didn't find
the DILib there. Went and looked

00:15:59.859 --> 00:16:05.798
in the second directory and
found the DILib there so it's

00:16:08.167 --> 00:16:11.537
happy. What we're going to try
to do is build a DILib and drop

00:16:11.537 --> 00:16:14.707
it in the primary search
directory. Hopefully the loader

00:16:14.707 --> 00:16:18.911
picks it up. We put an export
constructor in the DILib. The

00:16:18.911 --> 00:16:23.282
reason is when DILibs are loaded
they're not executed right away.

00:16:23.282 --> 00:16:27.620
The application has to trigger
the excuse. If you create a

00:16:27.620 --> 00:16:31.591
custom exporter as soon as the
DILib is loaded, it's

00:16:31.591 --> 00:16:35.161
automatically executed. We plant
the malicious DILib in the

00:16:35.161 --> 00:16:38.331
primary run path search
directory and start the

00:16:38.331 --> 00:16:43.069
directory. Good news, the loader
seems to have found it and tried

00:16:43.069 --> 00:16:47.807
to load. The bad news is it
crashes. There is a verbose

00:16:47.807 --> 00:16:52.979
error message that says what is
going on. We look at the source

00:16:52.979 --> 00:16:57.316
code to see where the error
message is from. Within the

00:16:57.316 --> 00:17:01.220
recursive load libraries method
it checks that the version of

00:17:01.220 --> 00:17:06.058
the DILib that it's about to
load matches the version that

00:17:06.058 --> 00:17:09.862
the application has a dependency
on. Makes sense. If an

00:17:09.862 --> 00:17:11.898
application has a dependency on
a DILib and says I need version

00:17:11.898 --> 00:17:14.133
X. If the DILib that the loader
loads is less thanking X, it's

00:17:14.133 --> 00:17:16.135
going to crash and say I
couldn't fulfill the dependency

00:17:16.135 --> 00:17:18.137
for you. We didn't specify a
version, it's going to be set to

00:17:18.137 --> 00:17:20.573
0. We can fix this easily. We go
back to X codes and set the

00:17:20.573 --> 00:17:22.575
version information. Recompile
and dump the load commands and

00:17:22.575 --> 00:17:24.577
now the version is 1.0. We have
a compatible version number. We

00:17:24.577 --> 00:17:26.579
take this malicious DILib and
copy back to the search

00:17:26.579 --> 00:17:28.581
directory, and execute the
application and it crashes

00:17:28.581 --> 00:17:30.583
again. Different error message.
You don't have the symbols I

00:17:30.583 --> 00:17:32.585
require. This makes sense.
Applications have dependencies

00:17:32.585 --> 00:17:34.587
on DILibs because they want to
use some functionality with the

00:17:34.587 --> 00:17:36.589
DILib. The way this is linked
and glued together is symbols.

00:17:36.589 --> 00:17:38.591
The loader is like you don't
have the symbols the application

00:17:38.591 --> 00:17:40.593
need. How do we address this
issue. We can manually create

00:17:40.593 --> 00:17:42.595
the symbols nah the application
needs but this is problematic.

00:17:42.595 --> 00:17:44.597
One it's a lot of work. And I'm
lazy. The other is it's brittle.

00:17:44.597 --> 00:17:46.599
Say we're trying to hijack
application A, we have to export

00:17:46.599 --> 00:17:48.601
all the symbols for application
A. Then we want to hijack

00:17:48.601 --> 00:17:50.603
application B, we have to create
a whole new set of symbols. It's

00:17:50.603 --> 00:17:52.605
better if we can point to the
(audio blipped) that we're

00:17:52.605 --> 00:17:54.607
hijacking and say I don't have
the symbols that you need but I

00:17:54.607 --> 00:18:00.546
know someone else that does. We
can update the hijacker to point

00:18:03.549 --> 00:18:09.555
to the correct legitimate
doctor. In operating system S

00:18:19.432 --> 00:18:25.438
you can do this. There are
linker flags that you patch and

00:18:40.553 --> 00:18:46.559
this creates a new load command.
Again, this tells the linker I

00:19:01.641 --> 00:19:07.646
don't have the symbols but this
other DILib has the correct

00:19:21.027 --> 00:19:27.033
symbols. Go get them. Two
issues. Both are LD, the compile

00:19:40.379 --> 00:19:46.385
time linger. When you specify
this export dependency the

00:19:54.693 --> 00:19:58.230
compile time linker goes and
gets the names of the legitimate

00:19:58.230 --> 00:20:01.000
DILib you're exporting to. This
name is going to start with the

00:20:01.000 --> 00:20:03.002
[indiscernible] keyword. When
the run time linkers sees this

00:20:03.002 --> 00:20:05.471
load command it doesn't resolve
that at R path keyword. It tries

00:20:05.471 --> 00:20:08.374
to go to the file system and
look for a DILib that starts

00:20:08.374 --> 00:20:11.277
with at R path which is not
going to exist. LD, the compile

00:20:11.277 --> 00:20:13.979
time linker will not allow you
to link against or reexport to

00:20:13.979 --> 00:20:16.649
another DILib is that DILib is a
system DILib under an umbrella

00:20:16.649 --> 00:20:19.351
framework. We can get around
this by linking to a fake DILib.

00:20:19.351 --> 00:20:23.189
This allows us to compile and we
can patch or fix up this reload

00:20:23.189 --> 00:20:26.058
command so it points to the
correct DILib. There is an apple

00:20:26.058 --> 00:20:31.197
tool to do this. The install
name tool. You give it

00:20:31.197 --> 00:20:38.938
parameters. The existing name or
value in the load command. You

00:20:38.938 --> 00:20:46.712
give it the new value. The full
path through the legitimate

00:20:46.712 --> 00:20:52.718
DILib that we're hijacking and
then the path to our own DILib.

00:20:55.154 --> 00:21:01.093
When you run this it's going to
fully update the run LC DILib.

00:21:04.263 --> 00:21:12.004
That points to the correct DILib
that we're hijacking. We take

00:21:12.004 --> 00:21:19.078
this hijacker DILib and copy
back to the primary search

00:21:19.078 --> 00:21:24.717
directly and execute the
application and it finally

00:21:24.717 --> 00:21:32.158
works. The malicious DILib is
loaded and executed. All symbols

00:21:32.158 --> 00:21:38.164
are reexported to the legitimate
DILib so the user doesn't see

00:22:19.338 --> 00:22:25.344
anything fishy going on. This
allows us to achieve cool hacks

00:22:58.844 --> 00:23:04.783
by planting a malicious DILib.
It's unlikely to be patched out.

00:23:07.052 --> 00:23:13.826
We're using the functionality of
the operating system function

00:23:13.826 --> 00:23:21.333
loader. And unlikely to be
detected. The loader is doing

00:23:21.333 --> 00:23:28.841
the one that is loading the
malicious library. We're abusing

00:23:28.841 --> 00:23:36.749
legitimate techniques. I want to
talk about automation. In order

00:23:36.749 --> 00:23:39.685
to do this DILib hijack you have
to have a vulnerable

00:23:39.685 --> 00:23:45.391
application. You can't just
target any application. I wrote

00:23:45.391 --> 00:23:51.397
a script that scans the running
processes or all files on the

00:24:02.107 --> 00:24:07.746
file system and looks for
applications vulnerable to

00:24:07.746 --> 00:24:13.752
either of the two hijack
scenarios described. It found

00:24:28.300 --> 00:24:34.306
150 binaries on the box. We can
see apple has a whole list.

00:24:55.160 --> 00:25:03.068
Third party applications like
Microsoft have a bunch. All the

00:25:03.068 --> 00:25:09.074
office products are vulnerable
to DLL and hijacking on

00:25:12.277 --> 00:25:18.283
operating system S. And third
party like Google, Dropbox.

00:25:20.719 --> 00:25:23.956
Hijack any of these
applications. Talking more about

00:25:23.956 --> 00:25:28.994
automation. To successfully
hijack an application we draft a

00:25:28.994 --> 00:25:34.199
DILib with the correct version
number and reexported the

00:25:34.199 --> 00:25:41.707
symbols to the correct DILib. I
wrote a script that takes a

00:25:41.707 --> 00:25:45.978
generic hijacker DILib and
configures for the target. For

00:25:45.978 --> 00:25:49.648
any application you're trying to
hijack, it will be fully

00:25:49.648 --> 00:25:51.884
compatible and the hijack will
work. Persistence. This is

00:25:51.884 --> 00:25:57.890
probably one of the best uses of
attack. The goal is to maintain

00:26:00.559 --> 00:26:04.563
automatic code execution by
dropping a DILib. The benefits

00:26:04.563 --> 00:26:10.736
is no breaking of digital
signatures or autorun locations.

00:26:10.736 --> 00:26:16.742
No new processes. The malicious
DILib is loaded into the

00:26:20.679 --> 00:26:23.682
existing process. The user
doesn't see any new malicious

00:26:23.682 --> 00:26:28.821
processes running. Also it's
going to be hosted within a

00:26:28.821 --> 00:26:33.392
trusted process. This is good
because trusted processes are

00:26:33.392 --> 00:26:37.429
allowed to do more things than
untrusted processes and abuses

00:26:37.429 --> 00:26:43.102
legitimate functionality. That
mean it's going to be harder to

00:26:43.102 --> 00:26:49.174
patch and detect. In my box
there is an I cloud photostream

00:26:49.174 --> 00:26:53.412
agent. Apple daemon that is
automatically run when the

00:26:53.412 --> 00:26:58.016
operating system starts. And it
turns out it's vulnerable to a

00:26:58.016 --> 00:27:03.956
hijack attack. We configure the
malicious DILib, copy to the

00:27:06.058 --> 00:27:11.263
primary run path and any time
the box is restarted our

00:27:11.263 --> 00:27:15.000
malicious DILib will get loaded
automatically by the loader. We

00:27:15.000 --> 00:27:19.738
can use DILib hijacking to
obtain persistent -- within the

00:27:19.738 --> 00:27:25.744
process. There is a number of
ways to do process injection. An

00:27:29.381 --> 00:27:32.584
external monitoring component.
And then as soon as the browser

00:27:32.584 --> 00:27:39.024
comes up and you want to inject
code you allocate memory and

00:27:39.024 --> 00:27:44.930
copy in shell code. This works
but it's noisy and complicated

00:27:44.930 --> 00:27:49.835
and easy to detect. DILib
achieves the same thing. Code

00:27:49.835 --> 00:27:54.873
execution within a target
process without any of these

00:27:54.873 --> 00:27:57.476
downsides. So X code is an
attractive code for malware.

00:27:57.476 --> 00:28:01.647
Malware can use it to infect all
employed binaries. Ex-code is

00:28:01.647 --> 00:28:08.153
the apple IDE, what developers
use to develop applications. I

00:28:08.153 --> 00:28:13.525
thought it would be cool if
there was malware watching for a

00:28:13.525 --> 00:28:18.597
release build and as soon as the
developer builds it, the malware

00:28:18.597 --> 00:28:24.102
can - at the source code inject
malicious code so the release

00:28:24.102 --> 00:28:30.742
binary is infected and it will
go out and propagate malware. X

00:28:30.742 --> 00:28:33.178
code is vulnerable to a
[indiscernible]. We can

00:28:33.178 --> 00:28:37.950
configure a malicious DILib and
save to the file system and ever

00:28:37.950 --> 00:28:39.952
time the X code is started, our
malware is automatically loaded.

00:28:39.952 --> 00:28:41.954
Another use is to bypass
security products. The goal is

00:28:41.954 --> 00:28:43.956
we want to do something that
normally would be blocked or not

00:28:43.956 --> 00:28:45.958
allowed. There are a lot of ways
to individually attack personal

00:28:45.958 --> 00:28:47.960
security but DILib hijacking
provides a generic way to bypass

00:28:47.960 --> 00:28:49.962
all of them. Let's talk
specifically about little

00:28:49.962 --> 00:28:51.964
snitch. It's the de-facto
firewall for operating system. I

00:28:51.964 --> 00:28:53.966
run it on my box. When there is
a new outgoing connection, it

00:28:53.966 --> 00:28:55.968
pops up and asks if I want to
trust it. The approach that

00:28:55.968 --> 00:28:57.970
little snitch takes is it's
binary. Trusts known processes

00:28:57.970 --> 00:28:59.972
and allows users to create
blanket rules. On my box it's

00:28:59.972 --> 00:29:01.907
allowed to create any outgoing
connection. It is trusted. This

00:29:01.907 --> 00:29:03.909
rule makes sense. The problem is
DPT chain is vulnerable to a

00:29:03.909 --> 00:29:05.911
DILib hijack attack. We can
plant -- and every time DPT

00:29:05.911 --> 00:29:07.913
chain is started,
[indiscernible] by the user, the

00:29:07.913 --> 00:29:09.915
malicious DILib gets loaded and
executed and now be in the

00:29:09.915 --> 00:29:11.917
trusted process context of the
DPT chain. And the malicious

00:29:11.917 --> 00:29:13.919
DILib can create an outgoing
connection to any network at

00:29:13.919 --> 00:29:15.921
once. Little snitch will see
this and say this is

00:29:15.921 --> 00:29:17.923
[indiscernible] and I trust it.
I'm going to let the connection

00:29:17.923 --> 00:29:19.925
out. This is how to use DILib
hijacking bypass security. We

00:29:19.925 --> 00:29:21.927
talked about local attacks and
these are great per persistent

00:29:21.927 --> 00:29:23.929
malware. I want to infect remote
users. There is this built in

00:29:23.929 --> 00:29:25.931
security component called gate
keeper that gets in the way. We

00:29:25.931 --> 00:29:27.933
want to bypass this. How does it
work? When you download content

00:29:27.933 --> 00:29:29.935
from the internet it's tagged
with a quarantine. And when you

00:29:29.935 --> 00:29:31.937
run the application, doubleclick
on the desktop, gate keeper

00:29:31.937 --> 00:29:33.939
intercepts the request the first
time and makes sure what you're

00:29:33.939 --> 00:29:35.941
about to do conform PSFTP you
can set it to various settings.

00:29:35.941 --> 00:29:37.943
If you download code from
anywhere else gate keeper will

00:29:37.943 --> 00:29:39.945
pop up and block. It does a
decent job of blocking malicious

00:29:39.945 --> 00:29:41.947
downloads. Users are faked into
downloading a flash update or

00:29:41.947 --> 00:29:43.949
something. If there are man in
the middle attacks performed

00:29:43.949 --> 00:29:45.951
against software gate keeper can
detect this because it will have

00:29:45.951 --> 00:29:47.953
been modified. Gate keeper
verifies the downloaded

00:29:47.953 --> 00:29:49.955
application but only verifies
that. External content was not

00:29:49.955 --> 00:29:51.957
verified. That's okay except if
the application loads the

00:29:51.957 --> 00:29:53.959
external content. This is what
we do in three steps, two. First

00:29:53.959 --> 00:29:55.961
find an apple sign or Mac
approved application with an

00:29:55.961 --> 00:29:57.963
(audio blipped). Create the
necessary zip package and inject

00:29:57.963 --> 00:29:59.965
into a legitimate DILib and
build the folder structure

00:29:59.965 --> 00:30:01.967
necessary to execute. Let's talk
about these steps. First find a

00:30:01.967 --> 00:30:03.969
gate keeper approved application
with external relative presence

00:30:03.969 --> 00:30:05.971
to a hijack able DILib. It has
to be external because we can't

00:30:05.971 --> 00:30:07.973
modify the bundle. Gate keeper
will not allow it to execute. It

00:30:07.973 --> 00:30:09.975
has to be externally relative.
We want it within the same zip

00:30:09.975 --> 00:30:11.977
file. So instruments dot app, we
can see that it is verifiable,

00:30:11.977 --> 00:30:13.979
accepted by gate keeper. Apple
signed. You download from the

00:30:13.979 --> 00:30:15.981
internet and only from the Mac
app store, I will allow you to

00:30:15.981 --> 00:30:17.983
run this application. If we dump
it, it has an LCR path that is

00:30:17.983 --> 00:30:19.985
relative externally to the
application bundle.

00:30:19.985 --> 00:30:21.987
[indiscernible] installed under
X code application. At run time

00:30:21.987 --> 00:30:23.989
it goes into X code shared
framework directory and looks

00:30:23.989 --> 00:30:25.991
for directories there. DMG image
or a zip file or inject into a

00:30:25.991 --> 00:30:27.993
legitimate download. At the top
there is instruments dot app.

00:30:27.993 --> 00:30:29.995
Under the applications
directory. There's the external

00:30:29.995 --> 00:30:31.997
folders that instruments will
look for for DILibs to load. If

00:30:31.997 --> 00:30:33.999
we provide the user with this
image, they're like what is

00:30:33.999 --> 00:30:36.001
this? I'm not going to run this.
We can take steps to clean it

00:30:36.001 --> 00:30:38.003
up. We can hide the files and
folders. Set a top level alias.

00:30:38.003 --> 00:30:40.005
Change the icon or background.
We're not modifying the digital

00:30:40.005 --> 00:30:42.007
signature itself. If you're
downloading a flash installer

00:30:42.007 --> 00:30:44.009
over HTTP and this is what you
get, you're probably going to

00:30:44.009 --> 00:30:46.011
run it. This is how this
happens. We have Mac's gate

00:30:46.011 --> 00:30:48.013
keeper setting. Only allow code
from the Mac store and the

00:30:48.013 --> 00:30:50.015
malicious DILib that should not
be able to execute because it's

00:30:50.015 --> 00:30:52.017
not from the Mac app store and
instruments dot app. When the

00:30:52.017 --> 00:30:54.019
user clicks they get a pop up.
The gate keeper pop up for any

00:30:54.019 --> 00:30:56.021
content. Even if it's signed and
validated. The user is going to

00:30:56.021 --> 00:30:58.023
click okay because they
downloaded software they want to

00:30:58.023 --> 00:31:00.025
run. Even though gate keeper is
set to only allow code from the

00:31:00.025 --> 00:31:01.960
Mac store it will load our
malicious DILib. Apple patched

00:31:01.960 --> 00:31:03.962
this so we're save now. This was
problematic until they patched

00:31:03.962 --> 00:31:05.964
it. This allowed hackers to go
back to their tricks and get

00:31:05.964 --> 00:31:07.966
users to download malicious
software. The way most hackers

00:31:07.966 --> 00:31:09.968
target Mac users is getting
people to download malicious

00:31:09.968 --> 00:31:11.970
software. A website that says
there is HD codex you have to

00:31:11.970 --> 00:31:13.972
install, flash installer or
something, or a free copy of

00:31:13.972 --> 00:31:15.974
Photoshop. Hackers put malicious
code in there. Gate keeper would

00:31:15.974 --> 00:31:17.976
block this. Using this attack,
hackers can go back to their

00:31:17.976 --> 00:31:19.978
same techniques and infect Mac
users. Hopefully we're all

00:31:19.978 --> 00:31:25.984
security conscious professionals
here so we're unlikely to

00:31:25.984 --> 00:31:30.655
download shady content. We do
all download software. Since the

00:31:30.655 --> 00:31:36.661
Mac app store is so
constrictive. A lot of us get

00:31:40.165 --> 00:31:46.171
the software from the company's
website. Photoshop, you go to

00:31:52.444 --> 00:31:58.450
Adobe.COM. It's problematic if
it's distributed over HTTP. An

00:32:03.455 --> 00:32:09.461
adversary with network level
access can inject malicious code

00:32:14.499 --> 00:32:20.505
and gate keeper can no longer
detect if they're tampered with.

00:32:28.013 --> 00:32:34.019
2015, how much software is
distributed over HTTP. About

00:32:39.057 --> 00:32:45.063
two-thirds of the software that
I installed on my computer was

00:32:52.571 --> 00:32:58.577
distributed over HTTP. All
right, you are a malware

00:33:03.548 --> 00:33:09.554
analysis security guy and you're
downloading a lot of stuff. Let

00:33:17.062 --> 00:33:23.068
me look at security tools. These
guys are supposed to be the

00:33:31.810 --> 00:33:37.816
shining example of how to do it
right. When I did this research

00:33:47.759 --> 00:33:53.765
earlier this year, every single
third party thing I downloaded

00:33:59.971 --> 00:34:05.977
was downloaded over HTTP. Any
adversary could have injected

00:34:11.049 --> 00:34:18.290
malicious content. And gate
keeper would not have caught it.

00:34:18.290 --> 00:34:21.626
I wanted to put everything
together to test the third party

00:34:21.626 --> 00:34:26.231
products. I put in a piece of
code that was distributed as a

00:34:26.231 --> 00:34:29.134
malicious download. When
executed it persists as a DILib

00:34:29.134 --> 00:34:33.338
hijack and Ex-fill trait data on
I drive and download and execute

00:34:33.338 --> 00:34:41.146
commands. Not the most
sophisticated. It persists,

00:34:41.146 --> 00:34:47.152
downloads and executes. I wanted
to test this against these third

00:34:53.391 --> 00:34:59.397
party securities. The test I
thought was simple. Download the

00:35:04.469 --> 00:35:10.475
security product, update it so
it had the latest signatures and

00:35:16.715 --> 00:35:22.721
run the image to see if the
antivirus product or firewall

00:35:28.994 --> 00:35:35.000
detected the attack. I skewed
it. If they detected any

00:35:40.805 --> 00:35:43.808
component of the attack that
would win for the antivirus

00:35:43.808 --> 00:35:45.810
product and loss for the
malware. If they detected the

00:35:45.810 --> 00:35:47.812
gate keeper, the persistence,
the downloaded commands, any of

00:35:47.812 --> 00:35:49.814
those detections is a win for
the antivirus company. Not too

00:35:49.814 --> 00:35:51.816
surprising, none of them
detected any of this. This

00:35:51.816 --> 00:35:53.818
reexposed the ineptitude of an
entire industry that charges us

00:35:53.818 --> 00:35:55.820
for their products. I wanted to
talk about suggested fixes.

00:35:55.820 --> 00:35:57.822
Since DILib hijacking is
legitimate, it's unlikely to be

00:35:57.822 --> 00:35:59.824
patched. I don't know how to
protect against this. Gate

00:35:59.824 --> 00:36:01.760
keeper I reported this to apple
(audio blipped) the way apple

00:36:01.760 --> 00:36:03.762
patches things is narrow minded.
A vulnerable piece of code, they

00:36:03.762 --> 00:36:05.764
patch the code path to the code.
I'm giving a talk tomorrow about

00:36:05.764 --> 00:36:07.766
apples patch (audio blipped)
with this gate keeper patch,

00:36:07.766 --> 00:36:09.768
there are other avenues to
coerce gate keeper to run code.

00:36:09.768 --> 00:36:11.770
Hopefully I talked to apple
about this and they fix it. So

00:36:11.770 --> 00:36:13.772
it's improving slowly. If
software is downloaded over

00:36:13.772 --> 00:36:17.075
HTTP, let the company know. Why
are you distributing software to

00:36:17.075 --> 00:36:24.916
me over HTTP. I briefly want to
talk about El captain. I was

00:36:24.916 --> 00:36:30.588
hoping DILib would be addressed.
There are new security

00:36:30.588 --> 00:36:33.491
mitigations according to apple
markets, DILib hijacking is

00:36:33.491 --> 00:36:38.396
alive and well. I was able to
plant a malicious unsigned DILib

00:36:38.396 --> 00:36:42.734
and every time the operating
system was started the DILib was

00:36:42.734 --> 00:36:49.507
loaded. Apple says that code
injection into system binaries

00:36:49.507 --> 00:36:53.912
is no longer permitted. But
using DILib we can still do it.

00:36:53.912 --> 00:36:59.851
So I don't know. I don't know if
they'll fix it. It is what it

00:36:59.851 --> 00:37:04.889
is. It looks like this attack
will be around for a while.

00:37:04.889 --> 00:37:08.326
(audio blipped) DHS, DILib
hijack scanner is running

00:37:08.326 --> 00:37:13.431
processes over the entire file
system and it will tell you if

00:37:13.431 --> 00:37:16.434
there are vulnerable
applications. There is probably

00:37:16.434 --> 00:37:21.139
going to be a lot of vulnerable
applications. That doesn't mean

00:37:21.139 --> 00:37:25.877
your hacked just means if
malware were to get into your

00:37:25.877 --> 00:37:31.883
system, it can load the DILib by
the operating system. It will

00:37:35.186 --> 00:37:41.192
show you hijacked application.
They appear to be hijacked

00:37:43.728 --> 00:37:49.734
there. Are some false positives.
I have yet to see any malware

00:37:55.106 --> 00:38:02.847
abusing this technique. This
will detect all the attacks I

00:38:02.847 --> 00:38:05.450
said earlier. If someone (audio
blipped) DILib to hijack a

00:38:05.450 --> 00:38:09.587
legitimate one this tool will
detect that. This tool is

00:38:09.587 --> 00:38:13.758
available for free at objective
C.com. There is a nice

00:38:13.758 --> 00:38:18.329
collection of malware if you
want to download and play with

00:38:18.329 --> 00:38:23.735
recent samples that I find. It's
hard to get the AD companies to

00:38:23.735 --> 00:38:27.872
share malware with me. I spent
some time getting this

00:38:27.872 --> 00:38:32.443
collection together. There are
free tools that I run on my

00:38:32.443 --> 00:38:37.849
personal computer. I love my Mac
but it's easy to hack. I wanted

00:38:37.849 --> 00:38:42.854
to write some tools to protect
it and make them available for

00:38:42.854 --> 00:38:47.425
free. The first tool is knock
knock. This is autoruns for

00:38:47.425 --> 00:38:51.162
operating system X. Task
explorer, this is internal tools

00:38:51.162 --> 00:38:55.300
for Windows. Shows you all the
running tasks, if they're

00:38:55.300 --> 00:38:59.470
signed, virus total integration
and loaded DILibs. It shows any

00:38:59.470 --> 00:39:02.707
of these injected DILibs.
Network connections and open

00:39:02.707 --> 00:39:07.712
files and block block. It will
monitor the file system and if

00:39:07.712 --> 00:39:12.283
malware tries to install itself,
it will detect it. We talked

00:39:12.283 --> 00:39:16.855
about really new class of attack
that affects operating system S.

00:39:16.855 --> 00:39:20.158
Affects everyone, apple, third
party, and abuses legitimate

00:39:20.158 --> 00:39:24.729
functionally and it's stealthy.
We can do all sort of cool

00:39:24.729 --> 00:39:29.767
things. Persist, we can gain low
time process injection. Bypass

00:39:29.767 --> 00:39:33.304
security products and facilitate
remote infections. Until apple

00:39:33.304 --> 00:39:35.306
fixes this which they - I would
recommend scanning your system,

00:39:35.306 --> 00:39:37.308
make sure you're not hijacks. I
doubt you are but it can't hurt.

00:39:37.308 --> 00:39:39.310
Only download software over
(inaudible) and if it's over

00:39:39.310 --> 00:39:41.312
HTTP, send them a nasty email. I
don't think the antivirus

00:39:41.312 --> 00:39:43.314
programs are worth the money.
They don't detect anything.

00:39:43.314 --> 00:39:45.316
That's a wrap. We have two
minutes for Q and A. Slides are

00:39:45.316 --> 00:39:47.318
available for download. I wrote
a white paper about this. If you

00:39:47.318 --> 00:39:49.320
want to read about the details.
And here is a website for free

00:39:49.320 --> 00:39:51.322
security tools. That is it. Any
questions? Some of the UI ones

00:39:51.322 --> 00:39:53.324
not. There are open source
versions of knock knock and the

00:39:53.324 --> 00:39:55.326
DILib scanner. Those are on sin
knacks GitHub. You can download

00:39:55.326 --> 00:39:57.328
them and play with them as well.
Thank you. Gentleman in blue.

00:39:57.328 --> 00:39:59.330
The question is how does this
impact I operating system. I

00:39:59.330 --> 00:40:01.933
believe the code is kind of
vulnerable because they share a

00:40:01.933 --> 00:40:07.939
lot of the same loader code.
Because I operating system does

00:40:18.349 --> 00:40:24.355
not allow you to run unsaved
code, that blocks this attack.

00:40:30.261 --> 00:40:36.267
Even if an application is
vulnerable and you planted a

00:40:39.504 --> 00:40:45.510
malicious DILib the loader would
ignore it because it's not

00:40:52.483 --> 00:40:58.489
signed by apple. Any other
questions? Yes. I think one

00:41:05.396 --> 00:41:11.402
thing, the question is can you
require the DILibs to be signed

00:41:20.978 --> 00:41:26.984
or something? Apple, if I'm an
apple signed process I should

00:41:35.259 --> 00:41:41.265
only load apple signed
processes. A problem that you

00:41:46.938 --> 00:41:52.944
can prevent this is don't allow
unsigned DILibs to be loaded in.

00:42:02.453 --> 00:42:08.459
It's not that hard to get a
developer ID and get apple to

00:42:16.467 --> 00:42:22.473
sign it but it makes the bar
higher. I'm about to get kicked

00:42:38.923 --> 00:42:44.929
off the stage. Thank you again.
If you have questions, I would

00:42:53.071 --> 00:42:59.077
love to chat.

