00:00:01.034 --> 00:00:05.239
 Good afternoon DEFCON. Excited
to be here. Before we jump into

00:00:05.239 --> 00:00:09.243
the content I want to start with
a personal observation. Working

00:00:09.243 --> 00:00:14.214
as a consultant that gets to see
hundreds of thousand of

00:00:14.214 --> 00:00:19.353
compromised systems, a
remarkable shift we've seen is

00:00:19.353 --> 00:00:24.625
away from malware that is a
discreet file in the file system

00:00:24.625 --> 00:00:29.496
that is easy to find as an
analyst, to attacks that are

00:00:29.496 --> 00:00:37.137
more difficult because they
don't use malware or the payload

00:00:37.137 --> 00:00:41.975
is stored in unusual places.
Attackers that compromise the

00:00:41.975 --> 00:00:47.314
VPN and use RDP and don't
compromise the environment and

00:00:47.314 --> 00:00:53.754
steal the recipe for coke. The
storing of the whole payload in

00:00:53.754 --> 00:00:59.126
the registry. This is yet
another variant of this. Another

00:00:59.126 --> 00:01:03.363
technique to use as offense.
Pentesters getting into

00:01:03.363 --> 00:01:07.668
environments and from a defense
perspective. How do we

00:01:07.668 --> 00:01:14.708
investigate these attacks. We
are here to talk about WMI,

00:01:14.708 --> 00:01:17.511
Windows management. We're going
to talk about practical

00:01:17.511 --> 00:01:24.985
attaches. Not just the
theoretical. We have seen

00:01:24.985 --> 00:01:28.922
attackers use these techniques
and even more advanced

00:01:28.922 --> 00:01:31.692
techniques to compromise
environments and further their

00:01:31.692 --> 00:01:33.694
goals. As investigators going
around, there is not much out

00:01:33.694 --> 00:01:39.333
there in terms of doing the
investigation. It's difficult.

00:01:39.333 --> 00:01:45.739
We have gotten lucky in many
cases and looking into the

00:01:45.739 --> 00:01:50.610
future we can't expect to be
lucky. We'll be covering that

00:01:50.610 --> 00:01:56.817
today. In order to motivate this
presentation, so you understand

00:01:56.817 --> 00:01:59.820
practically what this means and
how powerful these techniques

00:01:59.820 --> 00:02:02.723
are. Matt is going to introduce
a demo that we'll use throughout

00:02:02.723 --> 00:02:05.726
the presentation to show how
these techniques work. Will you

00:02:05.726 --> 00:02:11.365
take it from there, Matt? >> I
wrote a very crude basic credit

00:02:11.365 --> 00:02:18.772
card track data scraper. What
you're going to see here is from

00:02:18.772 --> 00:02:25.045
this red attacker machine, I'm
going to persist on the blue

00:02:25.045 --> 00:02:31.685
victim machine a track data
stealing payload. Using WMI. I

00:02:31.685 --> 00:02:37.758
use WMI both to install the
payload persistently. The WMI

00:02:37.758 --> 00:02:43.497
payload itself is asynchronous
in that upon firing of a very

00:02:43.497 --> 00:02:48.702
specific event that I target,
it's going to start scraping the

00:02:48.702 --> 00:02:53.774
track data from the executable
that I'm targeting. Finally I'm

00:02:53.774 --> 00:02:59.546
going to use WMI as a pure C2
channel and exfiltrate data back

00:02:59.546 --> 00:03:03.884
to the attacker system. I'm
going to provide the credentials

00:03:03.884 --> 00:03:09.890
to the victim machine and all in
the back ground over the WMI

00:03:16.129 --> 00:03:22.135
port. It's going to install the
payload. As soon as this process

00:03:24.971 --> 00:03:28.608
on the victim machine fires up,
it's going to execute the

00:03:28.608 --> 00:03:33.847
payload. The one that will
scrape memory for valid credit

00:03:33.847 --> 00:03:37.484
card track data. This is our
fictitious payment process. I

00:03:37.484 --> 00:03:43.457
paste in some fake but valid
track data. Track one and track

00:03:43.457 --> 00:03:49.463
two data. (audio blipped). If
everything worked properly, over

00:03:52.733 --> 00:04:00.540
WMI using it as a pure C2
channel, I can pull back that

00:04:00.540 --> 00:04:04.778
fully parsed data and because I
love PowerShell so much, I love

00:04:04.778 --> 00:04:08.248
the fact that everything is an
object. I'm not dumping text. I

00:04:08.248 --> 00:04:13.320
dumped the track data in a form
of a properly parsed out

00:04:13.320 --> 00:04:19.826
PowerShell object. So the attack
that you just saw -- I'm sorry

00:04:19.826 --> 00:04:23.296
I'm not going to release the
source code for it. We're going

00:04:23.296 --> 00:04:27.667
to use this to drive a mock
investigation. We developed

00:04:27.667 --> 00:04:33.373
amazing tools to parse out the
WMI or the SIM repository,

00:04:33.373 --> 00:04:38.011
you'll hear us use these terms
interchangeably. They parse out

00:04:38.011 --> 00:04:44.317
all the forensic artifacts that
attack left behind. Prior to

00:04:44.317 --> 00:04:48.121
this week in Vegas such a
forensic capability didn't

00:04:48.121 --> 00:04:51.091
exist. But they're going to
release these tools and I think

00:04:51.091 --> 00:04:57.097
you'll be impressed? >> I'm
Willi Ballenthin. A group of 20

00:05:03.170 --> 00:05:07.274
reverse engineers working on the
mall IQ there. What I like most

00:05:07.274 --> 00:05:10.143
is I get to do a ton of
research, investigate new

00:05:10.143 --> 00:05:15.015
technologies that are coming
out. Or WMI something that has

00:05:15.015 --> 00:05:19.252
been around for 20 years and
turn it into something usable

00:05:19.252 --> 00:05:27.227
for you. I don't want ask you if
you're on the blue team. I love

00:05:27.227 --> 00:05:30.430
helping you guys out and I look
forward to developing additional

00:05:30.430 --> 00:05:36.903
techniques with you in the
future. >> I don't fear

00:05:36.903 --> 00:05:41.575
embarrassment, so who here is on
the blue team? Who might have to

00:05:41.575 --> 00:05:43.944
defend against this? Great. I'm
Matt Graeber. A reverse

00:05:43.944 --> 00:05:49.950
engineer. Been a speaker at
various conferences. BlackHat

00:05:58.325 --> 00:06:03.196
trainer. As you may or may not
know, I'm a (audio blipped) fan

00:06:03.196 --> 00:06:08.668
boy, probably to a fault. I
personally subscribe to what

00:06:08.668 --> 00:06:12.272
myself and my friend Chris
Campbell referred to as the

00:06:12.272 --> 00:06:17.410
living off the land mind set. As
an attacker you should have the

00:06:17.410 --> 00:06:19.446
minimum footprint possible. We
are advocates of using the --

00:06:19.446 --> 00:06:21.448
infections. Say you're running
PowerShell payloads purely in

00:06:21.448 --> 00:06:23.450
memory or the WMI techniques
that we'll discuss here shortly.

00:06:23.450 --> 00:06:25.452
Traditionally security products
perform all kinds of

00:06:25.452 --> 00:06:27.454
introspection on things on disk.
We really don't have to drop too

00:06:27.454 --> 00:06:33.460
many payloads to disk. It's very
powerful for defenders. There is

00:06:54.648 --> 00:06:57.317
not a single payload that AV
can't touch that can be really

00:06:57.317 --> 00:07:03.256
introspected by a traditional
security product. And I'm a new

00:07:06.826 --> 00:07:10.063
-- I don't really claim to know
what I'm talking about, but here

00:07:10.063 --> 00:07:16.069
I am. >> Hello, everybody. I'm
Claudiu Teodorescu. My middle

00:07:18.104 --> 00:07:23.610
name is a translation of my last
name in English. That is what I

00:07:23.610 --> 00:07:29.616
heard. I'm a reverse engineer
for the team. I do forensic

00:07:32.419 --> 00:07:36.623
research writing forensic
parsing for the past ten years.

00:07:36.623 --> 00:07:40.193
So my background is forensics.
I'm a crypto enthusiast.

00:07:48.435 --> 00:07:54.908
[indiscernible]. My parents had
a different idea about that. We

00:07:54.908 --> 00:07:59.446
have to cover a lot of
information in this

00:07:59.446 --> 00:08:04.417
presentation. The outline is two
page long so bear with me. First

00:08:04.417 --> 00:08:10.657
the background, motivation, and
attack examples. We go into the

00:08:10.657 --> 00:08:17.230
WMI architecture and WPL core
language. Follow up with

00:08:17.230 --> 00:08:22.969
eventing and remote WMI and a
brief history of WMI attacks

00:08:22.969 --> 00:08:28.975
from malware perspective. And
WMI providers. And then we go

00:08:32.078 --> 00:08:36.416
into forensic data, file
formatting, investigation,

00:08:36.416 --> 00:08:42.522
realtime, defense and
mitigations. And forensics on

00:08:42.522 --> 00:08:50.463
the formats of the files. The
SIM repository. And we finish

00:08:50.463 --> 00:08:56.469
with a mock investigation and
WMI attack detection. >> Let's

00:08:59.239 --> 00:09:04.244
cover the basics first. Many of
you know what WMI is. But just

00:09:04.244 --> 00:09:06.780
real quickly, WMI stands for
Windows management

00:09:06.780 --> 00:09:10.350
instrumentation. This is
Microsofts open standards that

00:09:14.888 --> 00:09:20.760
strive to automate just
management of resources and

00:09:20.760 --> 00:09:27.167
devices in an enterprise. It's
extremely powerful locally and

00:09:27.167 --> 00:09:32.038
remotely. Attackers have
realized that this WMI service

00:09:32.038 --> 00:09:36.776
has been listening on every
Window's system since Windows 98

00:09:36.776 --> 00:09:43.249
and MP4. From a Window's ten
attacker may sheen, you can

00:09:43.249 --> 00:09:47.020
easily compromise a Windows 98
system given that you have the

00:09:47.020 --> 00:09:54.060
proper credentials. WMI can be
used to do a lot of things but

00:09:54.060 --> 00:09:59.632
some highlights are, you can
enumerate files and directories.

00:09:59.632 --> 00:10:05.271
When I say you can work with the
registry, you can read from it,

00:10:05.271 --> 00:10:09.476
write to it, you can subscribe
to events. This is one of the

00:10:09.476 --> 00:10:14.280
killer features that I'll
explain in PowerShell. And you

00:10:14.280 --> 00:10:17.717
can execute commands. There is a
bunch of my classes that have

00:10:17.717 --> 00:10:21.588
these built-methods. One of
which is used heavily, the win

00:10:21.588 --> 00:10:28.361
32 which is used for (audio
blipped) and lateral movement

00:10:28.361 --> 00:10:35.101
and I'll have examples of those.
I'll probably say this often.

00:10:35.101 --> 00:10:40.073
Any technology that is useful
for administrators is useful for

00:10:40.073 --> 00:10:44.511
attackers, too. Admins have
known about WMI for a long time.

00:10:44.511 --> 00:10:50.583
If you Google various articles
on WMI event subscriptions

00:10:50.583 --> 00:10:55.722
you'll see these great articles
going back to the late 90s and

00:10:55.722 --> 00:11:00.927
early 2000s. It hasn't been
until 2010 that we saw an up

00:11:00.927 --> 00:11:06.933
tick in attackers starting to
realize just how powerful this

00:11:06.933 --> 00:11:12.138
technology is. All right. So
here is the overlying

00:11:12.138 --> 00:11:17.043
architecture of WMI. Over-on the
left side you see all these

00:11:17.043 --> 00:11:21.281
client utilities. WMI you can
think of as like a client-server

00:11:21.281 --> 00:11:25.919
model where we have all these
clients, say you want to use a

00:11:25.919 --> 00:11:30.623
client like win dot XE2 and use
processes remotely or read

00:11:30.623 --> 00:11:35.261
registry value. These fall under
the clients and there are tools

00:11:35.261 --> 00:11:38.965
to allow you to do that.
Ultimately I would call it a

00:11:38.965 --> 00:11:43.937
server process, the WMI service
itself. So win management. This

00:11:43.937 --> 00:11:47.407
is running on every one of your
Window's systems whether you

00:11:47.407 --> 00:11:53.413
realize it or not. On part 185
or part 1589 by default. These

00:11:57.784 --> 00:12:03.623
clients you can either straight
up execute methods directly,

00:12:03.623 --> 00:12:08.328
enumerate all instances of a
certain class. You can get

00:12:08.328 --> 00:12:12.732
pretty specific with what events
you want to subscribe to or

00:12:12.732 --> 00:12:15.368
objects you want to enumerate by
using the main specific language

00:12:15.368 --> 00:12:17.370
called WQL. It's SQL like syntax
that allows you to manipulate

00:12:17.370 --> 00:12:19.372
objects and whatnot. There are
two basic protocols that WMI

00:12:19.372 --> 00:12:25.378
uses. The classic is D con and
the more recent is Windows

00:12:37.824 --> 00:12:40.827
remote management. I will use
win RM and PowerShell

00:12:40.827 --> 00:12:46.833
interchangeably. Just be aware
of these two protocols where you

00:12:49.869 --> 00:12:54.941
can use WMI remotely. WMI
wouldn't be useful without a

00:12:54.941 --> 00:12:58.244
bunch of providers. Say you want
to enumerate all the running

00:12:58.244 --> 00:13:04.183
processes. (audio blipped) there
is a DLL on disk that provides

00:13:07.754 --> 00:13:13.760
the WMI service with the
information you're requesting.

00:13:17.163 --> 00:13:19.599
There is a bunch of WMI
providers and these give you the

00:13:19.599 --> 00:13:22.602
functionality and allow as the
defender or attacker to

00:13:22.602 --> 00:13:26.005
potentially extent the
functionality of WMI. And then

00:13:26.005 --> 00:13:32.445
everything in WMI is backed by
this one particular file called,

00:13:32.445 --> 00:13:36.549
the WMI or SIM repository and
Willi and Claudiu are going to

00:13:36.549 --> 00:13:42.555
get into this. There is valuable
-- in there but there is no way

00:13:44.891 --> 00:13:50.730
to parse these offline in a
forensically sound fashion. I'm

00:13:50.730 --> 00:13:56.736
going to cover a few of these,
my favorite including

00:13:59.205 --> 00:14:06.612
PowerShell. I say this because
right out of the box you have

00:14:06.612 --> 00:14:10.349
all of these commands listed.
You have a set of WMI command

00:14:10.349 --> 00:14:16.355
lets and SIM command lets. We
can enumerate class instances,

00:14:16.355 --> 00:14:22.361
WMI -- events in the local shell
power context but also do some

00:14:25.398 --> 00:14:31.304
on a permanent fashion as well.
Remove class instances as well.

00:14:31.304 --> 00:14:36.275
There is also as a PowerShell
three and above there are a

00:14:36.275 --> 00:14:40.179
bunch of SIM command lets and
they're more or less the same as

00:14:40.179 --> 00:14:43.316
the WMI command lets but they
provide more functionality. You

00:14:43.316 --> 00:14:46.486
can call get SIM class to parse
out the schema of a bunch of WMI

00:14:46.486 --> 00:14:52.492
objects (audio blipped) valuable
objects. That might be useful to

00:14:58.030 --> 00:15:02.935
an attacker or a defender. Also
these SIM command lets can talk

00:15:02.935 --> 00:15:06.873
over Dcom and win RM. That
something to think of when

00:15:06.873 --> 00:15:12.578
you're working in more modern
environments. These are the

00:15:12.578 --> 00:15:18.084
command lets that you'll get the
most value out of. There are a

00:15:18.084 --> 00:15:25.525
bunch of other utilities. Who
used WIMIC.EXE? A lot of you.

00:15:25.525 --> 00:15:31.531
It's been out forever. Since WMI
has been out, going back to

00:15:34.233 --> 00:15:41.307
Windows 98. It's powerful. It
gets the job done. I've seen

00:15:41.307 --> 00:15:44.710
this used pretty heavily for
example for lateral movement

00:15:44.710 --> 00:15:47.780
where the win 32 process is used
or lateral movement. Haven't

00:15:47.780 --> 00:15:49.782
seen it used a lot for
persistence. But I've seen it

00:15:49.782 --> 00:15:56.289
used for a lot of malware
samples where they use certain

00:15:56.289 --> 00:15:58.291
WMI object instances like the
win 32 bios class where they do

00:15:58.291 --> 00:16:00.226
something crude like VM
detection and exit out of the

00:16:00.226 --> 00:16:02.228
malware process or do something
-- like a sleep loop.

00:16:02.228 --> 00:16:04.230
[indiscernible] Another really
cool utility that you may not be

00:16:04.230 --> 00:16:06.232
aware of is WBEM test. This is
like -- it's a crappy GUI

00:16:06.232 --> 00:16:08.668
utility, the UI is terrible but
it's powerful. I have used this

00:16:08.668 --> 00:16:11.904
on assessments a long time ago
when I didn't have access to win

00:16:11.904 --> 00:16:17.910
dot EXE, I was able to use this
to get around their application.

00:16:42.802 --> 00:16:45.605
Because this utility was white
listed. If on assessments you're

00:16:45.605 --> 00:16:48.574
blocked by using some utilities
that might be available. This

00:16:48.574 --> 00:16:54.580
one isn't too well known, you
can use win RM assuming the

00:17:00.686 --> 00:17:05.725
service is listening on your
local or remote system. This can

00:17:05.725 --> 00:17:10.062
be used to enumerate class
instances. You can use it to set

00:17:10.062 --> 00:17:16.535
win RM settings. You can also
use VD script, J scripts. People

00:17:16.535 --> 00:17:22.775
have been doing this for. If you
go and Google how to install a

00:17:22.775 --> 00:17:28.114
permanent WMI subscription you
would see a lot of old-school

00:17:28.114 --> 00:17:32.785
articles where VD script is
used. Attackers and some

00:17:32.785 --> 00:17:36.656
defenders have to resort
sometimes to writing VD script.

00:17:36.656 --> 00:17:42.495
One of the built-in payloads you
can do with this thing with WMI

00:17:42.495 --> 00:17:49.035
is you can embed a VD script in
there. There are good Linux

00:17:49.035 --> 00:17:55.041
ones. WMIC, WMIS is a wrapper
for the win 32 process create

00:17:58.144 --> 00:18:03.049
method. It enables you to
promote a Linux system, do

00:18:03.049 --> 00:18:06.752
lateral movement given
credentials or in the case of

00:18:06.752 --> 00:18:12.024
the pass the hash variant, you
can provide a hash to do your

00:18:12.024 --> 00:18:15.928
lateral movement and code
execution. There is cool

00:18:15.928 --> 00:18:19.098
research utilities as well. If
you're interested in dicking

00:18:19.098 --> 00:18:24.503
around in these WMI repository
looking for objects, methods or

00:18:24.503 --> 00:18:31.744
events of interest, check out
SIM studio or WMI explorer.

00:18:31.744 --> 00:18:34.513
Finally if you're going to
incorporate some techniques into

00:18:34.513 --> 00:18:40.519
your own code, plus plus or --
use various APIs to work with.

00:18:43.255 --> 00:18:46.792
Aside from the client utilities,
if you want to be able to do

00:18:46.792 --> 00:18:51.897
some slightly more advanced
options with WMI, then it would

00:18:51.897 --> 00:18:57.903
behoove you to learn WQL. It's
very -- syntax. Allows you to do

00:18:59.972 --> 00:19:04.443
three things. There is three
classes of queries, instance

00:19:04.443 --> 00:19:10.016
queries where you're interested
in logic instance. Say like if

00:19:10.016 --> 00:19:13.252
you want to enumerated. And meta
queries are high level queries

00:19:22.528 --> 00:19:27.099
where you can use these to
determine like what classes may

00:19:27.099 --> 00:19:31.170
or may not exist in the WMI
repository. What is what an

00:19:31.170 --> 00:19:36.342
instance query might look like.
Look at the example. Select star

00:19:36.342 --> 00:19:42.648
from win 32 process. I'm
interested in having all win 32

00:19:42.648 --> 00:19:47.153
process instances returned to me
in all properties. That's a

00:19:47.153 --> 00:19:51.457
star. You can specify just a
single property name but usually

00:19:51.457 --> 00:19:53.993
you give it a star because you
may be interested in all of the

00:19:53.993 --> 00:19:58.564
properties. You can provide an
additional constraint. Instead

00:19:58.564 --> 00:20:01.934
of providing all win 32 process
objects give me the ones that

00:20:01.934 --> 00:20:08.674
just have the word "chrome" in
them. The event queries are more

00:20:08.674 --> 00:20:13.979
complex. There is a little bit
of a learning curve. I hope to

00:20:13.979 --> 00:20:16.515
prove to you eventually these
things are really, really

00:20:16.515 --> 00:20:22.388
powerful. There's two classes of
event queries. There is queries

00:20:22.388 --> 00:20:25.224
for intrinsic and extrinsic
events. But look at these

00:20:25.224 --> 00:20:31.430
examples here. The first example
at a high level, we want to

00:20:31.430 --> 00:20:38.537
target all interactive log ons.
So the way you describe that in

00:20:38.537 --> 00:20:42.975
a WMI query is you want to
target all instance creation

00:20:42.975 --> 00:20:47.213
events. So this event will fire
upon (audio blipped) WMI class

00:20:47.213 --> 00:20:52.084
instance. What we're interested
in is all instances that are of

00:20:52.084 --> 00:20:58.891
type win 32 log on session,
within 15. With these queries

00:20:58.891 --> 00:21:02.194
you have to specify a polling
interval because they trigger

00:21:02.194 --> 00:21:08.200
all the time. You have to
specify a polling interval.

00:21:12.738 --> 00:21:20.746
We're interested in any win 32
log on where time equals 2. You

00:21:20.746 --> 00:21:26.752
see that log on type 2 refers to
interactive log ons. Now the

00:21:28.988 --> 00:21:32.391
next one. Select star from win
32 volume change where event

00:21:32.391 --> 00:21:36.028
type equals 2. This is an
extrinsic event. This fires

00:21:36.028 --> 00:21:42.735
immediately upon this event
firing. What does this event do?

00:21:42.735 --> 00:21:47.206
If you look up, you see event
type 2 refers to removable

00:21:47.206 --> 00:21:50.576
(audio blipped) you have
something that triggers and can

00:21:50.576 --> 00:21:57.583
do something interesting when
someone inserts a USB stick. The

00:21:57.583 --> 00:22:01.120
last example is
self-explanatory. This trigger

00:22:01.120 --> 00:22:07.126
will fire upon the registry key,
the run key changing in HKLM.

00:22:09.662 --> 00:22:14.567
Let's dig into eventing. You saw
some examples of how the WQL

00:22:14.567 --> 00:22:17.803
event queries can be used. What
is cool about WMI if you

00:22:17.803 --> 00:22:19.805
enumerate every class
definition, on this Windows 7,

00:22:19.805 --> 00:22:26.078
the slides are being driven
from, there is just under

00:22:26.078 --> 00:22:33.319
8 --> 000WMI classes. There are
really interesting classes with

00:22:33.319 --> 00:22:41.026
valuable information to
defenders and attackers. We can

00:22:41.026 --> 00:22:47.166
craft these queries based upon
some of the examples that you

00:22:47.166 --> 00:22:53.172
saw previously. You'll see more
valuable examples coming up

00:22:55.441 --> 00:23:02.748
later. Attackers seem to enjoy
using WMI system mechanism. I

00:23:02.748 --> 00:23:06.485
would say largely because to
date, perhaps defenders just

00:23:06.485 --> 00:23:10.890
aren't that great at detecting
it. And I don't know of anyone

00:23:10.890 --> 00:23:16.095
to date who is able to recognize
WMI used as a persistence

00:23:16.095 --> 00:23:22.067
mechanism in realtime. It's easy
say like using autoruns to

00:23:22.067 --> 00:23:26.238
detect it used after the fact
but in realtime it's a

00:23:26.238 --> 00:23:31.610
challenge. So in order to use
WMI for persistence you need a

00:23:31.610 --> 00:23:37.449
filter which is a WQL query.
This describes the event you

00:23:37.449 --> 00:23:39.451
want to trigger off of. A
consumer. This is what you want

00:23:39.451 --> 00:23:46.058
to do upon firing that event.
And then a binding. This is the

00:23:46.058 --> 00:23:48.861
registration mechanism that
takes the filter and the

00:23:48.861 --> 00:23:55.301
consumer and actually like
installs them. So these can run

00:23:55.301 --> 00:24:01.740
for the lifetime of the host
process (audio blipped) or you

00:24:01.740 --> 00:24:06.445
can register permanent and these
are persistent and the evidence

00:24:06.445 --> 00:24:09.982
is only located in a single file
that AV will never touch and

00:24:09.982 --> 00:24:14.453
runs a system. So there's two
event types, intrinsic and

00:24:14.453 --> 00:24:18.924
extrinsic. Once you start
digging into WMI classes you

00:24:18.924 --> 00:24:22.861
will see there are a ton of
classes that are organized into

00:24:22.861 --> 00:24:27.866
name spaces. Not unlike any
typical object oriented

00:24:27.866 --> 00:24:32.104
language. So within each of
these name spaces you have the

00:24:32.104 --> 00:24:35.574
following system classes
defined. When I say system class

00:24:35.574 --> 00:24:40.612
I refer to any class that begins
with these two underscores here.

00:24:40.612 --> 00:24:44.249
Within each space you have all
these intrinsic eventers. There

00:24:44.249 --> 00:24:48.821
is really valuable queries that
you can subscribe to. I use the

00:24:48.821 --> 00:24:54.460
instance creation event to
trigger off of. Whenever an

00:24:54.460 --> 00:24:58.230
object is create offed the type
that I'm targeting, then I can

00:24:58.230 --> 00:25:03.168
go and do something with that
accordingly. There are some

00:25:03.168 --> 00:25:07.072
malware that -- was using that
created dynamically it's own

00:25:07.072 --> 00:25:11.276
custom WMI classes and using it
like they were stuffing data

00:25:11.276 --> 00:25:16.582
into there. You can create a
query that would trigger on the

00:25:16.582 --> 00:25:20.152
class creation event for
example. There is another tool

00:25:20.152 --> 00:25:26.091
with a WMI as a C2 channel by
identifying and changing name

00:25:26.091 --> 00:25:30.129
spaces. You have intrinsic
events that could fire off the

00:25:30.129 --> 00:25:35.834
malicious events as well.
Extrinsic are more specialized.

00:25:40.139 --> 00:25:44.176
These are highly performance
events. They fire immediately.

00:25:44.176 --> 00:25:50.883
You don't specify the polling
interval. We have the win 32

00:25:50.883 --> 00:25:56.355
process start trace event. This
fires immediately upon any

00:25:56.355 --> 00:26:01.326
process starting. So you can use
this as a defender for pretty

00:26:01.326 --> 00:26:05.964
decent processing command line
auditing. You can use it as an

00:26:05.964 --> 00:26:10.269
attacker which is exactly what I
did in the attack scenario that

00:26:10.269 --> 00:26:13.038
I showed at the beginning of the
talk. With that credit card

00:26:13.038 --> 00:26:17.643
scraper. You have module load
trace. Every single executable

00:26:17.643 --> 00:26:22.147
DLL device driver, this event
will fire. If you subscribe to

00:26:22.147 --> 00:26:25.784
that you can get interesting
information. You have the volume

00:26:25.784 --> 00:26:29.855
change event that has to do with
physical volume. Removable

00:26:29.855 --> 00:26:33.392
media. And registry key change
event and value change event.

00:26:33.392 --> 00:26:37.362
These are self-explanatory.
These are extremely powerful. As

00:26:37.362 --> 00:26:41.800
a defender and attacker think of
the creative ways you might be

00:26:41.800 --> 00:26:47.206
able to leverage these events.
So once we registered our

00:26:47.206 --> 00:26:49.808
eventer, the thing that we're
interested in triggering off of,

00:26:49.808 --> 00:26:51.810
we want to do something
interesting. Microsoft provides

00:26:51.810 --> 00:26:57.816
five standard event consumers.
These things effectively execute

00:27:00.052 --> 00:27:03.889
the payload upon triggering the
event. Log file then consumer.

00:27:08.694 --> 00:27:12.498
Active script event consumer.
Attackers enjoy this one. It

00:27:12.498 --> 00:27:18.003
allows you to embed (audio
blipped) J script that executes

00:27:18.003 --> 00:27:21.874
immediately upon the event
triggers. Anti-event log

00:27:21.874 --> 00:27:27.679
consumer. There's already a lot
[indiscernible] information

00:27:27.679 --> 00:27:31.583
within the event log and
hopefully you constantly inspect

00:27:31.583 --> 00:27:35.988
those event logs. WMI can be
used to cover all the gaps. Say

00:27:35.988 --> 00:27:37.990
there is some event that you're
interested in where there is no

00:27:37.990 --> 00:27:40.125
event log entry. You can use
this event consumer to

00:27:40.125 --> 00:27:46.131
supplement the existing antilog
entries. There is SMTM event

00:27:50.035 --> 00:27:55.240
consumers. Fire off an email.
And [indiscernible] very popular

00:27:55.240 --> 00:28:01.179
with attackers for obvious
reasons. So again, for permanent

00:28:03.649 --> 00:28:08.887
WMI events we need a filter, an
event consumer class. The

00:28:08.887 --> 00:28:14.893
consumer one of the five
standard consumers that perform

00:28:17.462 --> 00:28:20.899
the action upon triggering that
event and the binding which

00:28:20.899 --> 00:28:24.570
takes the form of this filter to
consumer binding object that

00:28:24.570 --> 00:28:28.006
performs the registration and
does the insulation of these

00:28:28.006 --> 00:28:33.445
events local or remotely. A
little about the protocols used

00:28:33.445 --> 00:28:38.584
by WMI. The one that's been
around forever is DCOM. WMI

00:28:38.584 --> 00:28:45.691
service will listen on port 135
to establish an initial

00:28:45.691 --> 00:28:49.962
connection. All subsequent
connections will be established

00:28:49.962 --> 00:28:55.968
on a separate port dictated by
this registry key. I believe by

00:28:58.403 --> 00:29:00.339
default there is like a large
range of ports here. You can use

00:29:00.339 --> 00:29:02.341
the DCOM.EXE making it more
firewall friendly in your

00:29:02.341 --> 00:29:04.343
enterprise. (audio blipped) on a
remote system using DCOM. The

00:29:04.343 --> 00:29:06.345
DCOM protocol is -- WMI command
list. Not to be mistaken with

00:29:06.345 --> 00:29:08.347
the SIM command list. So WINRM.
A soap based protocol. Soap

00:29:08.347 --> 00:29:10.349
inherently contains all this
rich type information that can

00:29:10.349 --> 00:29:12.351
transmit and receive PowerShell
objects and WMI information.

00:29:12.351 --> 00:29:14.353
It's encrypted by default. Out
of the box it is listening on

00:29:14.353 --> 00:29:16.355
port 5985. If you configure it
to use certificates it will

00:29:16.355 --> 00:29:18.357
listen on port 5986. This is
like the official remote

00:29:18.357 --> 00:29:20.359
management protocol that
Microsoft is pushing hard. If

00:29:20.359 --> 00:29:22.361
you take a server 2012 machine,
you would find the only port

00:29:22.361 --> 00:29:24.363
listening on this machine is
5985. Microsoft is pushing this

00:29:24.363 --> 00:29:26.365
hard. Here is an example of me
using the SIM commandlets

00:29:26.365 --> 00:29:28.367
rather, I'm using the win RM
protocol to do the same thing

00:29:28.367 --> 00:29:31.203
that I did with DCOM previously.
Here the SIM commandlets to

00:29:31.203 --> 00:29:36.575
enumerate processes. (audio
blipped) attacks. As far as I

00:29:36.575 --> 00:29:42.581
can tell the first WMI attack
that came to my attention was

00:29:42.581 --> 00:29:47.085
with [indiscernible]. What
stucks net did is exploited the

00:29:47.085 --> 00:29:50.088
Windows printer spooler
vulnerability. Effectively they

00:29:50.088 --> 00:29:55.127
got an arbitrary -- right
vulnerability. Imagine, if as an

00:29:55.127 --> 00:29:59.498
attacker you could write a file
anywhere on the Windows system

00:29:59.498 --> 00:30:05.637
to gain code execution, what
file would it be and where would

00:30:05.637 --> 00:30:11.777
you write it do? The developers
of stuck net are intelligent and

00:30:11.777 --> 00:30:16.882
they created a specification for
these certain objects. They had

00:30:16.882 --> 00:30:23.021
this moth file that allowed them
to gain persistence and when you

00:30:23.021 --> 00:30:28.126
do WMI persistence -- they
dropped the file into this

00:30:28.126 --> 00:30:33.231
directory. And there was a
watchdog process that looked for

00:30:33.231 --> 00:30:40.405
new moth files and consumes them
if it saw a new one. All they

00:30:40.405 --> 00:30:45.644
did was installed this anti, I
believe shortly after systems

00:30:45.644 --> 00:30:48.246
start up. It executes another
executable they dropped in the

00:30:48.246 --> 00:30:55.954
system context. (audio blipped)
then in the same year there was

00:30:55.954 --> 00:30:58.857
a ghost -- this is a commodity
sample that targeted user's

00:30:58.857 --> 00:31:01.727
documents. There was a really
useful WMI class for file based

00:31:01.727 --> 00:31:04.896
operations. SIM under score data
file. When ever there was new or

00:31:04.896 --> 00:31:08.200
modified files within the recent
folder, it would up load all of

00:31:08.200 --> 00:31:11.503
those. The payload that it used
was event consumer that just

00:31:11.503 --> 00:31:15.507
used the internet explorer comma
object to up load the new

00:31:15.507 --> 00:31:17.943
documents that it discovered.
And then moving forward in 2014,

00:31:17.943 --> 00:31:19.945
there's a Romanian researcher
who developed WMI shell. This

00:31:19.945 --> 00:31:21.947
was the first time that I had
ever seen WMI used as a pure C2

00:31:21.947 --> 00:31:23.949
channel. So what he did was he
created a modified name space

00:31:23.949 --> 00:31:25.951
and just stuffed his payload in
there. So say you created some

00:31:25.951 --> 00:31:27.953
name space and placed in it an
encoded PowerShell command. And

00:31:27.953 --> 00:31:33.125
then used the win 32 process
create method to take that name

00:31:33.125 --> 00:31:39.131
space on the victim's system,
base 64 code it and execute it.

00:31:39.131 --> 00:31:45.103
And then you can also take the
output of the PowerShell command

00:31:45.103 --> 00:31:50.609
and save it to another WMI name
space and read that remotely.

00:31:50.609 --> 00:31:56.314
That is effectively what this
tool did. And then this year we

00:31:56.314 --> 00:32:02.254
revealed ATP29. It was like a
week or two ago, released a

00:32:17.235 --> 00:32:23.241
report on the hammer toss
malware. This is python and --

00:32:27.612 --> 00:32:30.882
what that paper didn't describe
were the WMITTPs that this group

00:32:30.882 --> 00:32:34.052
was using. They were creating
and modifying WMI classes and

00:32:34.052 --> 00:32:36.588
class properties, stuffing their
payload in there, basically

00:32:36.588 --> 00:32:40.058
doing the same as WMI shell
using custom WMI classes instead

00:32:40.058 --> 00:32:44.196
of name spaces. There's a lot of
things that as an attacker you

00:32:44.196 --> 00:32:47.365
can do with WMI. From a post
exploitation perspective, really

00:32:47.365 --> 00:32:50.836
you can cover pretty much the
entire attack life cycle here

00:32:50.836 --> 00:32:53.705
whether it's reconnaissance, I
mentioned malware does VM and

00:32:53.705 --> 00:32:55.907
sandbox detection. Code
execution and lateral movement.

00:32:55.907 --> 00:32:59.077
Persistence as we know. Data
storage. Using the name spaces

00:32:59.077 --> 00:33:02.514
and custom classes to stuff the
payloads or the result of

00:33:02.514 --> 00:33:05.050
payloads in there. And C2
communication. Basically tieing

00:33:05.050 --> 00:33:08.186
together the data storage with
code execution and getting a

00:33:08.186 --> 00:33:12.624
pure C2 channel out of WMI. Now,
if you were to go about doing

00:33:12.624 --> 00:33:16.294
reconnaissance with WMI, these
are just some of the classes

00:33:16.294 --> 00:33:18.964
that you might be interested in.
This is typical of a lot of

00:33:18.964 --> 00:33:20.966
malware. The first thing is
collect host information, up

00:33:20.966 --> 00:33:22.968
load to a server, you have
convenient objects there. If you

00:33:22.968 --> 00:33:24.970
want to perform file or directly
listings, delete files, move

00:33:24.970 --> 00:33:26.972
files, you have SIM underscore
data file. The volume

00:33:26.972 --> 00:33:28.974
operations, registry operations.
You can list processes, stop

00:33:28.974 --> 00:33:30.976
processes, start processes,
create services all remotely

00:33:30.976 --> 00:33:32.978
using WMI. Now, we can also get
code -- lateral movement. I

00:33:32.978 --> 00:33:34.980
described the static create
method. Here is an example of me

00:33:34.980 --> 00:33:36.982
using PowerShell to evoke that
method and -- well in this case

00:33:36.982 --> 00:33:38.984
call it [indiscernible] from an
attack perspective replacing no

00:33:38.984 --> 00:33:40.986
paddocks EXE and you have one
liner commands that goes out to

00:33:40.986 --> 00:33:42.988
the internet and downloads the
PowerShell and executes that.

00:33:42.988 --> 00:33:44.990
This is simple to do. A reminder
for WMI persistence. We have the

00:33:44.990 --> 00:33:46.992
filter that take it is form of a
WQL event query. The consumer,

00:33:46.992 --> 00:33:48.994
the thing you want to execute
and the five standard event

00:33:48.994 --> 00:33:50.996
consumers and a binding. What's
up? Hey. >> So we have a little

00:33:50.996 --> 00:33:52.998
tradition here at DEFCON. What
it is? Shot the newb. Welcome to

00:33:52.998 --> 00:33:55.000
DEFCON. Cheers. >> That's good.
All right. So we have our three

00:33:55.000 --> 00:33:57.002
requirements. So let's get going
with persistence. I feel so much

00:33:57.002 --> 00:33:59.004
better now. Here is an example
of what C daddy was doing. C

00:33:59.004 --> 00:34:00.939
daddy was the internal name that
we were using for the public

00:34:00.939 --> 00:34:02.941
family name for this was CDUKE.
This was a python back door that

00:34:02.941 --> 00:34:04.943
used PowerShell as an WMI
persistence mechanism. I pulled

00:34:04.943 --> 00:34:06.945
that out of the python back door
and changed it a bit. So you

00:34:06.945 --> 00:34:08.947
take the event filter which is
this long query here in the

00:34:08.947 --> 00:34:10.949
query variable, effectively all
it's doing is going to trigger

00:34:10.949 --> 00:34:12.951
some event shortly after system
start up. Specifically anywhere

00:34:12.951 --> 00:34:14.953
within 232 seconds after system
start up. In fact, this attacker

00:34:14.953 --> 00:34:16.955
just ripped this query right out
of [indiscernible] kind of lame.

00:34:16.955 --> 00:34:18.957
And then we have what we want to
trigger off of and what are we

00:34:18.957 --> 00:34:20.959
going to do upon triggering
that? All we do here is there is

00:34:20.959 --> 00:34:22.961
a command line event consumer.
After system start up we execute

00:34:22.961 --> 00:34:24.963
thing in the command line. The
attacker had previously dropped

00:34:24.963 --> 00:34:26.965
their python executable and
shortly after system start up it

00:34:26.965 --> 00:34:28.967
would be executed again. Nothing
too complex here. So WMI can be

00:34:28.967 --> 00:34:30.969
used as a storage mechanism.
This is a short little snippet

00:34:30.969 --> 00:34:32.971
of what ATP29 was doing. They
were doing it remotely not

00:34:32.971 --> 00:34:34.973
locally. This is local, here I
create a custom win 32

00:34:34.973 --> 00:34:36.975
underscore evil class within the
root space and attach evil

00:34:36.975 --> 00:34:38.977
property to it and the payload
is the string. The put method

00:34:38.977 --> 00:34:40.979
installs it permanently into the
SIM repository. Just imagine

00:34:40.979 --> 00:34:42.981
this being like some base 64
encoded PowerShell command that

00:34:42.981 --> 00:34:44.983
gets executed later on.
Providers. Take it away? >> One

00:34:44.983 --> 00:34:46.985
of the things that kind of
impressed me when I started

00:34:46.985 --> 00:34:48.987
looking at WMI is that it's not
this one huge monolithic service

00:34:48.987 --> 00:34:50.989
that I expected coming from
Microsoft and existed for 20

00:34:50.989 --> 00:34:52.991
years. I expected this
complicated beast. And that's

00:34:52.991 --> 00:34:54.993
not what it is. Instead you
should be thinking of WMI as a

00:34:54.993 --> 00:34:56.995
framework for querying and
configuring a system. The core

00:34:56.995 --> 00:34:58.997
part of WMI is very small. What
gives WMI the power is those

00:34:58.997 --> 00:35:00.932
providers. And a provider is a
[indiscernible] that declares

00:35:00.932 --> 00:35:02.934
that it knows some type of data.
This is the data that I know how

00:35:02.934 --> 00:35:04.936
to process and give to people.
For instance when you use WMI to

00:35:04.936 --> 00:35:06.938
go query the list of processes
on an operating system or on a

00:35:06.938 --> 00:35:08.940
host, there is a provider on the
backend that is able to perform

00:35:08.940 --> 00:35:10.942
the operating system queries
that the system calls to get

00:35:10.942 --> 00:35:12.944
those processes and format them
in a way that the querier is

00:35:12.944 --> 00:35:14.946
able to process. It's a really
neat system. There are of course

00:35:14.946 --> 00:35:16.948
ways that as a defender you can
enumerate those things. With

00:35:16.948 --> 00:35:18.950
your attacker hat on you should
be thinking, wait a minute, this

00:35:18.950 --> 00:35:20.952
is a plug in based system that
provides ark tear data to a

00:35:20.952 --> 00:35:22.954
framework. Can we use that
maliciously? Yes. We can think

00:35:22.954 --> 00:35:24.956
easily of how to create a
malicious WMI provider that can

00:35:24.956 --> 00:35:26.958
do customized activity on the
remote systems. Matt was able to

00:35:26.958 --> 00:35:28.960
come up with some examples of
this and it's really state of

00:35:28.960 --> 00:35:30.962
the art? >> Didn't come up with
examples here, I had the

00:35:30.962 --> 00:35:32.964
requirements which I provided
out to the twit toe sphere and

00:35:32.964 --> 00:35:34.966
what resulted in that is my good
friends Casey and Jared, that

00:35:34.966 --> 00:35:36.968
very night went and implemented
their own custom or proof of

00:35:36.968 --> 00:35:38.970
concept malicious WMI provider
which is awesome. When Willi and

00:35:38.970 --> 00:35:40.972
Claudiu mentioned this, this was
just theoretical. We thought it

00:35:40.972 --> 00:35:42.974
was cool and these guys banged
it out quickly. What Casey did

00:35:42.974 --> 00:35:44.976
is created a malicious WMI
provider in the form of a shell

00:35:44.976 --> 00:35:46.978
code runner. You take his dot
net DLL and install with install

00:35:46.978 --> 00:35:48.980
U till dot EXE and do the COM
registration and locally or

00:35:48.980 --> 00:35:50.982
remotely you can execute a shell
load payload in the system

00:35:50.982 --> 00:35:52.984
context. Pretty cool. And then
Jared what he wanted to do was

00:35:52.984 --> 00:35:58.990
create a WMI provider that would
list out active network

00:36:11.636 --> 00:36:19.210
connections. Prior to Windows 8
there -- WMI object for doing

00:36:19.210 --> 00:36:22.380
that. So there was this large
gap in WMI for older systems

00:36:22.380 --> 00:36:25.016
where you wouldn't have that
information to say trigger off

00:36:25.016 --> 00:36:28.453
of if you saw a connection going
out to a known blacklisted C2

00:36:28.453 --> 00:36:30.989
address. Another thing he
slipped in there was a

00:36:30.989 --> 00:36:33.558
PowerShell runner. So once you
got this installed, then you

00:36:33.558 --> 00:36:36.294
just provide an arbitrary
PowerShell command via this

00:36:36.294 --> 00:36:42.300
argument list argument and it
executes the PowerShell payload

00:36:44.769 --> 00:36:50.875
local or remotely in the system
context. That concludes the

00:36:50.875 --> 00:36:56.948
introduction to WMI. If you
weren't familiar with WM, you

00:36:56.948 --> 00:37:03.621
now have a good basis for
understanding what you can do

00:37:03.621 --> 00:37:10.929
with it and so forth. Matt gave
a great introduction. I would

00:37:10.929 --> 00:37:17.035
like to spend a few minutes
talking about our motivation.

00:37:17.035 --> 00:37:24.342
Why we started this in the first
place. This started within our

00:37:24.342 --> 00:37:30.448
company about 6 months ago or
so. Working on large

00:37:30.448 --> 00:37:35.320
investigation. Companies with
10 --> 000, 100 --> 000 host ons the

00:37:35.320 --> 00:37:38.490
network. We saw a threat group
and use WMI to attack. We called

00:37:38.490 --> 00:37:40.492
this APT29. They used neat
techniques. And one of the most

00:37:40.492 --> 00:37:42.494
interesting to me as a defender
is they were particularly aware

00:37:42.494 --> 00:37:44.496
of how a forensic investigator
goes about their investigation

00:37:44.496 --> 00:37:46.498
and made it really difficult for
us. They did what we always talk

00:37:46.498 --> 00:37:48.500
about like using passwords.,
clearing event logs. When we did

00:37:48.500 --> 00:37:50.502
the investigation, we aren't
trying to remediate they knew we

00:37:50.502 --> 00:37:52.504
were doing an investigation.
They knew it and started upping

00:37:52.504 --> 00:37:54.506
their game and we knew they were
upping their game so we upped

00:37:54.506 --> 00:37:56.508
our game. And we got into this
little, I don't know like a war

00:37:56.508 --> 00:37:58.510
there kind of trying to do
better and better things and it

00:37:58.510 --> 00:38:00.445
was interesting. We were very
lucky because we had great

00:38:00.445 --> 00:38:02.447
network coverage and host base
coverage. We were successful in

00:38:02.447 --> 00:38:04.449
the remediation and exhausted
the attackers new technique.

00:38:04.449 --> 00:38:06.451
Along the way what we saw is
deployment of the WMI

00:38:06.451 --> 00:38:08.453
techniques. Some of the things
they did right away was this

00:38:08.453 --> 00:38:10.455
consumer to binding persistence
technique at the backdoors. As

00:38:10.455 --> 00:38:12.457
we started pushing them along,
they deployed C daddy and I

00:38:12.457 --> 00:38:14.459
started pushing all of their
payloads into the SIM

00:38:14.459 --> 00:38:16.461
repository. And why did they
want to do that? Because as

00:38:16.461 --> 00:38:18.463
investigators when we look at a
system, hopefully it's online

00:38:18.463 --> 00:38:20.465
when we get to it and maybe we
can do inspection. When we get a

00:38:20.465 --> 00:38:22.467
forensic image, there are no
dropped files on disk. Very

00:38:22.467 --> 00:38:24.469
little to look at. There is one
binary blob that sits there and

00:38:24.469 --> 00:38:26.471
houses data. At that point we
had no way to parse it. We were

00:38:26.471 --> 00:38:28.473
out of luck. Some things that we
could have done and tried is we

00:38:28.473 --> 00:38:30.475
could have used up WMI to
inspect the WMI system itself to

00:38:30.475 --> 00:38:32.477
find out what was there. We can
use those meta queries to fetch

00:38:32.477 --> 00:38:34.479
that data. That's a fair
technique and a powerful

00:38:34.479 --> 00:38:36.481
technique because WMI is
networks. We can do it remotely

00:38:36.481 --> 00:38:38.483
and say what WMI classes do you
have installed. But being

00:38:38.483 --> 00:38:40.485
familiar with sophisticated
attackers, I don't really trust

00:38:40.485 --> 00:38:42.487
asking the system to report its
own safety and health to me

00:38:42.487 --> 00:38:44.489
back. I imagine how very short
amount of time it would take to

00:38:44.489 --> 00:38:46.491
deploy a root kit that might
shim into the WMI service and

00:38:46.491 --> 00:38:52.497
decides not to return the most
interesting results. That

00:38:52.497 --> 00:38:54.499
doesn't make me feel good.
Another reason this didn't work

00:38:54.499 --> 00:39:00.438
well is occasionally, maybe the
system that had the most

00:39:02.874 --> 00:39:08.880
interesting data on it was
compromised and we had to pull

00:39:12.851 --> 00:39:18.857
the system offline as soon as
possible or got a forensic image

00:39:23.761 --> 00:39:29.767
from the client. On a dead box
environment and on dead box

00:39:34.672 --> 00:39:40.678
image we couldn't use WMI to
query that box. So we were left

00:39:46.484 --> 00:39:52.490
inspecting the file system and
registry. We found some

00:39:54.692 --> 00:40:01.599
interesting string hits and
object hits data. Have you seen

00:40:01.599 --> 00:40:05.370
that before, malware showing
(audio blipped) strings. This

00:40:05.370 --> 00:40:11.843
was a huge file. 100-megabytes
and we had no way to inspect it

00:40:11.843 --> 00:40:16.848
further. Strings on a binary
file and calling that forensics

00:40:16.848 --> 00:40:22.353
doesn't make me feel good. That
is not forensics. The final

00:40:22.353 --> 00:40:27.825
technique that we explored with
limited success was to build a

00:40:27.825 --> 00:40:33.331
Frankenstein and that's where we
have a live running system that

00:40:33.331 --> 00:40:38.836
is clean and copy out the SIM
database from a compromised

00:40:38.836 --> 00:40:43.808
system onto a live system and
hope everything works and

00:40:43.808 --> 00:40:48.813
sometimes it does. Coming from a
forensic perspective I don't

00:40:48.813 --> 00:40:54.786
know why the system works that
way. I'm wondering -- check some

00:40:54.786 --> 00:40:59.791
and cleaning up unusual data
that shouldn't be there. Is

00:40:59.791 --> 00:41:04.729
there other (audio blipped)
along the way when that live

00:41:04.729 --> 00:41:10.702
system imports the data? I don't
know that. I'm wondering if I'm

00:41:10.702 --> 00:41:16.207
losing data, stomping on time
stamps, I don't know. That makes

00:41:16.207 --> 00:41:20.678
me uncomfortable. So we got
together and spent time

00:41:20.678 --> 00:41:26.417
investigating what these files
were and if they allowed us to

00:41:26.417 --> 00:41:29.854
reconstruct the WMI data. I can
report to you with confidence

00:41:29.854 --> 00:41:34.425
that sure enough there is a lot
of really interesting stuff in

00:41:34.425 --> 00:41:40.264
there. So we're going to dig
into that. Taking a look on

00:41:40.264 --> 00:41:45.370
disk, what makes up my service
and the data that backs it. Here

00:41:45.370 --> 00:41:51.376
are some of the major files.
Objects of data is the most

00:42:05.189 --> 00:42:11.195
obvious. This is a file that we
had been inspecting for years

00:42:13.598 --> 00:42:19.604
looking for interesting entries
in there. All we were able to do

00:42:21.973 --> 00:42:29.680
is run strings and interpret the
output. That is not forensics.

00:42:29.680 --> 00:42:35.686
This index dot BTR file. This
allows us to seek the data

00:42:38.056 --> 00:42:45.062
within the object files. These
bottom files, mapping one, two,

00:42:45.062 --> 00:42:52.737
three, allows us to reconstruct
the data in a logical address

00:42:52.737 --> 00:42:59.043
space. Unfortunately one of the
findings that we identified

00:42:59.043 --> 00:43:06.651
along the way is simply grabbing
objects for data is not

00:43:06.651 --> 00:43:12.256
sufficient forensic analysis.
Over time we had basically

00:43:12.256 --> 00:43:18.262
acquired a huge -- of the data
files and we were excited to

00:43:21.332 --> 00:43:27.338
parse through them and find the
malware. That file itself is not

00:43:29.740 --> 00:43:37.415
sufficient. When you go out and
do forensics, grab the whole

00:43:37.415 --> 00:43:45.122
directory. So we dug into these
files, maybe from a single

00:43:45.122 --> 00:43:52.096
system we were looking at 50,
100-megabytes of data. Mostly

00:43:52.096 --> 00:43:58.102
within that data file that we
can use -- supporting the B tree

00:44:00.671 --> 00:44:02.940
index on the side. We're not
going to dig into this a lot.

00:44:02.940 --> 00:44:04.942
How do we go about this (audio
blipped) we didn't debug the

00:44:04.942 --> 00:44:06.944
system. Generates head stumps
and meant weeks staring at the

00:44:06.944 --> 00:44:08.946
stumps. It ends up not being as
difficult as it sounds. There is

00:44:08.946 --> 00:44:10.948
a lot of human readable strings
and it's a great place to start

00:44:10.948 --> 00:44:12.950
when reversing a file format.
Identifying known data. Those

00:44:12.950 --> 00:44:14.952
strings stand out obviously. The
long side strings, the size of

00:44:14.952 --> 00:44:16.954
the string. You identify those.
And sets within sized buffers

00:44:16.954 --> 00:44:18.956
that become obvious. A known
piece of data that is

00:44:18.956 --> 00:44:20.958
interesting, a string. And now
offsets to the string that show

00:44:20.958 --> 00:44:22.960
how the data is organized
internally. (audio blipped)

00:44:22.960 --> 00:44:24.962
reverse engineer, bit flags
along the way. The read write

00:44:24.962 --> 00:44:26.964
able flag. A bit flag. Does this
thing have a default value, a

00:44:26.964 --> 00:44:28.966
single thing flipped in each
record. Glancing at the file is

00:44:28.966 --> 00:44:30.968
difficult. Differential
analysis. One good known SIM

00:44:30.968 --> 00:44:32.970
repository and one changed one
and see what the dins was on

00:44:32.970 --> 00:44:34.972
disk. Ultimately it was tedious
but I can report now that after

00:44:34.972 --> 00:44:40.978
a few months of research, I
think we have four bytes across

00:45:14.245 --> 00:45:20.251
the entire database that we're
unsure what it means. Everything

00:45:51.983 --> 00:45:58.556
else we know what it means and
how to parse it. What that

00:45:58.556 --> 00:46:00.491
allows us to do is reimplement
WQL or any of the other query

00:46:00.491 --> 00:46:02.493
languages on a dead box system.
What is there. What did the

00:46:02.493 --> 00:46:04.495
attacker store there and what
other artifacts that aren't

00:46:04.495 --> 00:46:06.497
exposed to WMI. There are
additional artifacts. Brand new

00:46:06.497 --> 00:46:08.499
sets of time stamps that we can
pull out and figure out when

00:46:08.499 --> 00:46:10.501
this database was modified last,
when enters were inserted and

00:46:10.501 --> 00:46:12.503
things like that. Anyone
familiar with digital forensics

00:46:12.503 --> 00:46:14.505
(audio blipped) we can build up
a time line of attacker activity

00:46:14.505 --> 00:46:16.507
and identify new period of
compromise. This is really neat

00:46:16.507 --> 00:46:18.509
stuff. Claudiu now is going to
dig into the nitty-gritty

00:46:18.509 --> 00:46:20.511
detail? >> The next diagram
shows the files that the SIM

00:46:20.511 --> 00:46:22.513
repository consist of and their
relationship. The index -- a

00:46:22.513 --> 00:46:24.515
beat file, the page size is
8,192. It's a B tree on disk

00:46:24.515 --> 00:46:26.517
index. Pointers to the next
pages are represented as logical

00:46:26.517 --> 00:46:30.054
page numbers. And to get the
physical page number of a

00:46:30.054 --> 00:46:33.257
certain artifact you have to use
the currently active mapping

00:46:33.257 --> 00:46:36.827
file and find the logic to
physical page number mapping for

00:46:36.827 --> 00:46:39.730
the index [indiscernible] and
the logical number page number

00:46:39.730 --> 00:46:43.901
is used as an index in the
mapping. What the value of that

00:46:43.901 --> 00:46:47.138
index represents, the physical
page number. In this example, in

00:46:47.138 --> 00:46:50.374
the physical page ten, we have
the internal representation of

00:46:50.374 --> 00:46:53.911
evil consumer. As you can see
the first identifier prefixed by

00:46:53.911 --> 00:46:57.148
MS under score represents the
name space where the instance

00:46:57.148 --> 00:47:00.951
lives in. The second identifier
is prefixed by CI under score is

00:47:00.951 --> 00:47:05.122
the class name of the instance.
And the last one is prefixed by

00:47:05.122 --> 00:47:08.359
the [indiscernible] the instance
name. At the end of the

00:47:08.359 --> 00:47:11.262
representation there are three
integers. The first integer is

00:47:11.262 --> 00:47:14.799
of a logical page number. The
second one is a record

00:47:14.799 --> 00:47:18.669
identifier. And the last one is
the size of the record. Objects

00:47:18.669 --> 00:47:23.207
that data is also a paged file.
This is the same page size as

00:47:23.207 --> 00:47:27.078
the index -- getting from the
logical page number found in the

00:47:27.078 --> 00:47:30.281
index, we are using the
corresponding mapping in the map

00:47:30.281 --> 00:47:33.184
-- active mapping file. From
that logical offset we're

00:47:33.184 --> 00:47:36.721
getting the physical offset in
the object set data. The actual

00:47:36.721 --> 00:47:39.623
physical -- the physical page
numbers, sorry. The physical

00:47:39.623 --> 00:47:42.526
offset is computed by
multiplying the page number by

00:47:42.526 --> 00:47:44.528
the page size. And after reading
the page, we identified the

00:47:44.528 --> 00:47:47.398
record header for the instance
data using the record identifier

00:47:47.398 --> 00:47:51.202
from the search result. From the
record header we get the

00:47:51.202 --> 00:47:55.005
offsetting page of the record
and its size and then the

00:47:55.005 --> 00:47:58.476
physical offset of the record
data by doing the following

00:47:58.476 --> 00:48:01.178
computation. Physical page
number multiplied by the page

00:48:01.178 --> 00:48:06.083
size plus the end page offset.
The size is also present in the

00:48:06.083 --> 00:48:12.089
header. Also CRC32 checks them,
is present there, too. We can do

00:48:15.493 --> 00:48:21.499
a data integrity check on the
record data to validate that

00:48:24.301 --> 00:48:31.475
nothing weird happened. To do an
artifact recovery methodology,

00:48:31.475 --> 00:48:39.483
first we have to construct the
search thing, taking into

00:48:39.483 --> 00:48:47.491
consideration the artifact name
space plus a name. Stay tuned

00:48:47.491 --> 00:48:53.497
for the white paper that will
describe this in detail. And

00:48:56.267 --> 00:49:02.206
then perform a search into the
index -- doing a prefix match on

00:49:06.610 --> 00:49:12.616
the key that is returned. From
the key you get the logical page

00:49:16.987 --> 00:49:22.993
number, the artifact records ID
and the record size. Based on

00:49:25.796 --> 00:49:32.970
the logical page number, you
determine the physical number,

00:49:32.970 --> 00:49:39.376
page number using the
corresponding mapping in the

00:49:39.376 --> 00:49:43.848
mapping active mapping file.
Then in the object data page you

00:49:43.848 --> 00:49:46.250
find the record header using the
record identifier from the

00:49:46.250 --> 00:49:48.252
result search. And then we
validate the size of the record

00:49:48.252 --> 00:49:50.254
header matches the size in the
index -- search and record

00:49:50.254 --> 00:49:52.256
offsetting the header offsetting
the current page of the

00:49:52.256 --> 00:49:54.258
artifacts. And the integrity
check is performed. This is a

00:49:54.258 --> 00:49:56.260
page structure of page and
object data. It starts with a

00:49:56.260 --> 00:49:58.262
list of record headers. Each
record header consists of a

00:49:58.262 --> 00:50:00.264
record identifier. A record
offset and size and CR32. The

00:50:00.264 --> 00:50:02.266
CRC32 is only present under
Windows XP since the integrity

00:50:02.266 --> 00:50:04.268
check is done on the record
level for optimization purposes

00:50:04.268 --> 00:50:06.270
in Windows vista and up, the CRC
was moved into mapping. So the

00:50:06.270 --> 00:50:08.272
integrity check will be done at
the page level this time. Next

00:50:08.272 --> 00:50:10.274
this is the keys in route page
in the index dot ETR (ph.). They

00:50:10.274 --> 00:50:12.276
respect class definitions
instance, decorations, hierarchy

00:50:12.276 --> 00:50:14.278
representations and also
references and next it's a

00:50:14.278 --> 00:50:16.280
pretty picture. When I talk
about pretty, I'm saying pretty

00:50:16.280 --> 00:50:18.282
complicated. I won't spend any
time on this. All the details

00:50:18.282 --> 00:50:20.284
and examples are in the white
paper and they're very

00:50:20.284 --> 00:50:22.286
self-explanatory and whoever
wants to follow and read the

00:50:22.286 --> 00:50:24.288
white paper, I'm pretty sure
they'll understand? >> So we've

00:50:24.288 --> 00:50:26.290
demonstrated I hope that maybe
you don't quite fully understand

00:50:26.290 --> 00:50:28.292
the file format, we demonstrated
that we do understand it. The

00:50:28.292 --> 00:50:35.833
natural thing for us to do is
build tools that make it easy

00:50:35.833 --> 00:50:42.640
for you all to take advantage of
this knowledge. Precisely what

00:50:42.640 --> 00:50:46.410
we did. I wrote a tool developed
in python which is a nice object

00:50:46.410 --> 00:50:50.414
oriented library and it's easy
to interact with a forensic

00:50:50.414 --> 00:50:54.852
image with a SIM repository.
We're going to spend a few

00:50:54.852 --> 00:50:58.856
minutes walking through the
tools so you understand what you

00:50:58.856 --> 00:51:03.994
have at your disposal. So python
SIM is what I call it. Pure

00:51:03.994 --> 00:51:07.598
python parser for the SIM
repository. The SIM repository

00:51:07.598 --> 00:51:12.002
are files that have been
persisted to disk. Many of the

00:51:12.002 --> 00:51:15.639
instance of classes that
attackers have created as well

00:51:15.639 --> 00:51:20.844
as all the data supported by the
system that you can query and

00:51:20.844 --> 00:51:24.448
configure. It's an interesting
place to look. This tool

00:51:24.448 --> 00:51:29.253
provides access to any field
that we're able to parse out and

00:51:29.253 --> 00:51:33.657
know about. It parses everything
that we're able to describe at

00:51:33.657 --> 00:51:38.295
this point except for the last
four bytes and access to say

00:51:38.295 --> 00:51:40.764
time stamps, time lining. It's
easy to use. I did develop a GUI

00:51:40.764 --> 00:51:46.770
to demonstrate the
functionality. That's what I'll

00:51:52.543 --> 00:51:58.549
show you. I will describe that
anything you see in the GUI here

00:52:07.157 --> 00:52:11.795
is easy to use programmatically.
Build investigative scripts to

00:52:11.795 --> 00:52:17.901
triage data. This is good for
data exploration. Let me see if

00:52:17.901 --> 00:52:25.275
I can figure out this. Written
IQT works on Windows and Linux

00:52:25.275 --> 00:52:32.649
systems. You can go in and
explore the pieces of data, the

00:52:32.649 --> 00:52:38.022
forensic artifacts that we can
parse out. If you don't

00:52:38.022 --> 00:52:40.324
understand the physical
representation, you can explore

00:52:40.324 --> 00:52:42.326
the logical representation of
the repository. SIM V2 is the

00:52:42.326 --> 00:52:44.328
default space. And root
subscription is the consumer

00:52:44.328 --> 00:52:46.330
bindings that maintain
persistence. As we explore that

00:52:46.330 --> 00:52:48.332
name space we see all the
classes that are resident. These

00:52:48.332 --> 00:52:50.334
are the types of data you can
query for and an attacker may

00:52:50.334 --> 00:52:52.336
have modified. Consumer binding.
I'm sorry, everyone. It's

00:52:52.336 --> 00:52:54.338
amazing you can have a demo fail
when you're not even doing it

00:52:54.338 --> 00:52:56.340
live. So we can explore these
classes here. And this filter to

00:52:56.340 --> 00:52:58.342
consumer binding is ... Now it
looks like we're good. We're

00:52:58.342 --> 00:53:00.277
going to hit start and go for
it. Filter to consumer binding.

00:53:00.277 --> 00:53:02.279
That is for persistence using
WMI. What this report shows is

00:53:02.279 --> 00:53:05.749
all those nitty-gritty details
that we're able to parse out.

00:53:05.749 --> 00:53:11.488
The most interesting one is the
layout section here. In detail

00:53:11.488 --> 00:53:16.694
each of the properties exposed
by this particular class. A

00:53:16.694 --> 00:53:22.399
filter and consumer. Those are
the two parts of the persistence

00:53:22.399 --> 00:53:27.071
there. Additionally the default
values or other things we're

00:53:27.071 --> 00:53:33.343
able to parse out of the
artifact. One of the neat things

00:53:33.343 --> 00:53:39.583
about this tool is in addition
to parsing data for you, it

00:53:39.583 --> 00:53:46.857
gives you a way to validate the
parsing. What we see here is a

00:53:46.857 --> 00:53:51.095
standard hex editor view where
you can look at the various

00:53:51.095 --> 00:53:55.899
fields. It's more than that. In
addition to parsing out, it

00:53:55.899 --> 00:54:00.671
shows you how each individual
field is parsed out. If you're

00:54:00.671 --> 00:54:06.777
not quite sure why was that time
stamp parsed as 2009 in July? We

00:54:06.777 --> 00:54:11.615
can see where that data is and
confirm that (audio blipped)

00:54:11.615 --> 00:54:15.986
correctly. Anything that we're
able to parse out is visible

00:54:15.986 --> 00:54:21.258
here in this hex stump. That is
really neat. We parsed through

00:54:21.258 --> 00:54:24.761
the class definition that
describes what data is

00:54:24.761 --> 00:54:29.133
available. Now let's look at the
instances, the specific concrete

00:54:29.133 --> 00:54:33.637
data that is stored using the
schema. That's also displayed

00:54:33.637 --> 00:54:37.474
under this -- sub branch. We
have three instances. We can

00:54:37.474 --> 00:54:43.480
take this first one and explore
the concrete data installed on

00:54:55.759 --> 00:54:58.362
the system. There are two time
stamps there within each

00:54:58.362 --> 00:55:02.966
instance, it's probably the
creation and modification date

00:55:02.966 --> 00:55:07.337
for those instances. We're
looking at the special values,

00:55:07.337 --> 00:55:13.143
the concrete values and these
give us the names of the WMI

00:55:13.143 --> 00:55:18.949
classes that define the filter
which is a thing that will be

00:55:18.949 --> 00:55:24.755
triggering and the consumer, the
thing that will be run. We can

00:55:24.755 --> 00:55:31.061
fetch that data as well and see
who those two payloads will be.

00:55:31.061 --> 00:55:37.334
And sure enough we can go in and
validate manually what is this

00:55:37.334 --> 00:55:42.172
data. From my perspective I
think it's an interesting tool.

00:55:42.172 --> 00:55:46.043
It's intuitive from my
perspective. You can click

00:55:46.043 --> 00:55:51.381
around and explore the data. I
don't necessarily expect you to

00:55:51.381 --> 00:55:57.688
know where you want to look.
This is a great tool for getting

00:55:57.688 --> 00:56:01.491
familiar with WMI especially
from a forensic perspective.

00:56:01.491 --> 00:56:07.764
We'll leave it to Claudiu who is
able to take the knowledge that

00:56:07.764 --> 00:56:13.570
we gained along the way and
codified it into almost like a

00:56:13.570 --> 00:56:19.409
wizard to find evil. Both of
these things you'll have at your

00:56:19.409 --> 00:56:24.248
disposal for finding bad guys in
your environment. We'll give

00:56:24.248 --> 00:56:30.053
Claudiu a chance here. >> The
daemon parser, a C++ parser and

00:56:30.053 --> 00:56:34.891
works only in Windows. It's
using commands, dash, dash, name

00:56:34.891 --> 00:56:38.762
space instance, dash, dash,
consumer instance, dash, dash,

00:56:38.762 --> 00:56:43.133
class definition and so on.
Extracts persistence and pull

00:56:43.133 --> 00:56:48.438
out data and it's a guided
wizard to find evil consumers

00:56:48.438 --> 00:56:53.277
and triggers and it was built
following the IRR (ph.)

00:56:53.277 --> 00:56:58.115
workload. The source code is
available at the following

00:56:58.115 --> 00:57:02.419
[indiscernible]. And let's go
into the demo. Is it working

00:57:02.419 --> 00:57:08.725
now? We start the parser and we
saw that the persistence in WMI

00:57:08.725 --> 00:57:14.031
is using consumers. What we're
doing here is parsing all the

00:57:14.031 --> 00:57:17.901
consumers in the root
subscription event space and

00:57:17.901 --> 00:57:22.272
found a [indiscernible] called
-- consumer and execute the

00:57:22.272 --> 00:57:26.777
PowerShell using IEX. And it's
taking form the Window 32

00:57:26.777 --> 00:57:33.216
payload the class, the payload
value, the payload property

00:57:33.216 --> 00:57:39.222
value. The next one is an --
log. [indiscernible]. And

00:57:42.693 --> 00:57:48.699
another command line event
consumer called BVD consumer and

00:57:51.234 --> 00:57:57.240
executing a script which is
located in [indiscernible] The

00:57:59.776 --> 00:58:07.584
first one looks suspicious, the
second tool, find those in any

00:58:07.584 --> 00:58:11.455
system. But still you have to
check them to make sure that

00:58:11.455 --> 00:58:14.725
they're valid and not
overwritten. Next we take a

00:58:14.725 --> 00:58:18.729
closer look to the suspicious
event consumer. We see what it's

00:58:18.729 --> 00:58:22.733
doing is executing a payload
toting a custom class. And also

00:58:22.733 --> 00:58:26.336
finding the binding that binds
the triggering event to the

00:58:26.336 --> 00:58:30.340
consumer. The triggering event
in this case is the payment card

00:58:30.340 --> 00:58:34.344
processor. And let's look at the
query to find what the

00:58:34.344 --> 00:58:38.348
triggering event looks like. We
get a filter instance and select

00:58:38.348 --> 00:58:41.618
star from win 32, where process
name is [indiscernible].

00:58:41.618 --> 00:58:44.855
Whenever a process is started,
it triggers automatically. Since

00:58:44.855 --> 00:58:49.226
we know that the payload is
located in the win 32 payload

00:58:49.226 --> 00:58:53.230
class and payload property, then
we can do the class definition

00:58:53.230 --> 00:58:58.301
parsing of the win 32 payload
and we have here the name of the

00:58:58.301 --> 00:59:02.606
class and then we see the
property and as a default value

00:59:02.606 --> 00:59:06.610
there is a basic -- encoded
payload. Which is actually after

00:59:06.610 --> 00:59:09.513
decoding and done analyzing the
memory [indiscernible] for

00:59:09.513 --> 00:59:14.217
credit card information data. We
decode it and look at it and the

00:59:14.217 --> 00:59:18.588
most important thing is what are
you hiding the data that you're

00:59:18.588 --> 00:59:22.926
scraping. A class -- route event
space under track data it's a

00:59:22.926 --> 00:59:27.297
good indication. Let's go back
to the WMI parser and do a

00:59:27.297 --> 00:59:32.002
parsing on the win 32X field and
what we have here under the

00:59:32.002 --> 00:59:35.639
track data property, there is
another base 64 encoded value

00:59:35.639 --> 00:59:38.909
which after decoding it ...
(audio blipped) which contains

00:59:38.909 --> 00:59:42.913
the formation that was created.
Track type, the CDV, the name,

00:59:42.913 --> 00:59:47.250
Fred Smith. And the credit card
number. I don't know Fred Smith,

00:59:47.250 --> 00:59:52.355
but I have his credit card and
we're in Vegas, so join me? >>

00:59:52.355 --> 00:59:57.427
At this point we're in a lot
better shape now. We can go out

00:59:57.427 --> 01:00:01.898
and investigate these types of
attacks now. We don't have to

01:00:01.898 --> 01:00:04.234
hope that we have good network
coverage and host space

01:00:04.234 --> 01:00:07.103
coverage. We can do it offline
and be sure of the results. We

01:00:07.103 --> 01:00:09.773
have tools that do that now.
That python tool is really good.

01:00:09.773 --> 01:00:12.242
And Claudiu's tool we're going
to continue to update with all

01:00:12.242 --> 01:00:14.444
of the methodologies along the
way to identify WMI attacks.

01:00:14.444 --> 01:00:17.347
What are the other ways that we
can go about finding these WMI

01:00:17.347 --> 01:00:19.783
attacks. Matt said there might
be something like 7, 8 --> 000 of

01:00:19.783 --> 01:00:22.652
these on a single host. How do
you dig through the weeds to

01:00:22.652 --> 01:00:25.322
find the bad stuff. We're
working on that. I want to jump

01:00:25.322 --> 01:00:28.658
into a few things but I want to
maybe do some kind of call for

01:00:28.658 --> 01:00:31.528
action. Essentially what we're
presenting is like a file system

01:00:31.528 --> 01:00:34.297
parser, an NTFS parser that
gives you a new file system.

01:00:34.297 --> 01:00:36.299
We're not sure of the new pieces
of data stored there. Let me

01:00:36.299 --> 01:00:38.301
talk about the things that we do
know about and encourage you to

01:00:38.301 --> 01:00:40.303
dig around in those files to
find new information. The

01:00:40.303 --> 01:00:42.305
obvious one that we covered a
new times ago is

01:00:42.305 --> 01:00:44.307
[indiscernible]. This is the
most obvious and well known

01:00:44.307 --> 01:00:46.309
commonly used way to maintain
persistence in WMI. It's a way

01:00:46.309 --> 01:00:48.311
to encode and store the payloads
within SIM repository. AV may

01:00:48.311 --> 01:00:50.313
not find those on the list but
it's in the repository. We have

01:00:50.313 --> 01:00:52.315
seen attackers that go in and
install their own custom class

01:00:52.315 --> 01:00:54.317
definitions and use them
remotely to store payloads or

01:00:54.317 --> 01:00:56.319
pull data out. We're proposing
to do a complete enumerate of

01:00:56.319 --> 01:00:58.321
client environments and it's no
longer something that we can't

01:00:58.321 --> 01:01:00.257
do (audio blipped) and look for
things that shouldn't be there.

01:01:00.257 --> 01:01:02.259
In my experience seeing
attackers use the most advanced

01:01:02.259 --> 01:01:04.261
techniques, the new classes they
create do not look like

01:01:04.261 --> 01:01:06.263
legitimate classes. It's
something like recon or back

01:01:06.263 --> 01:01:08.265
door or I think there was one
that was bad or something like

01:01:08.265 --> 01:01:14.271
that. If you're scanning this
thing, it's like that is so

01:01:23.647 --> 01:01:26.583
obvious. At least for the next
two days we can say, easy to

01:01:26.583 --> 01:01:29.319
find, we need to think about in
the future, how to identify

01:01:29.319 --> 01:01:31.621
things that shouldn't be there.
Moving beyond what has been

01:01:31.621 --> 01:01:33.623
installed persistently, another
piece of interesting forensic

01:01:33.623 --> 01:01:35.959
artifact that shows up in these
object up data files is under

01:01:35.959 --> 01:01:37.961
Microsoft metering, the
processes that are executed and

01:01:37.961 --> 01:01:40.530
when last executed and how often
their used is stored for some

01:01:40.530 --> 01:01:42.599
reason via WMI. When it
persists, that data, which

01:01:42.599 --> 01:01:45.101
operating system is executing
it, it stores it in the SIM

01:01:45.101 --> 01:01:48.071
repository. We have an easy to
use parser that can extract the

01:01:48.071 --> 01:01:51.274
recently used executable and who
was running it and how many

01:01:51.274 --> 01:01:53.410
times and when was the last
time. This is juicy and

01:01:53.410 --> 01:01:55.412
interesting stuff. One of the
classes that I recommend you

01:01:55.412 --> 01:01:57.647
looking at is CCM recently used
apps. Some of the other software

01:01:57.647 --> 01:01:59.649
metering artifacts is
interesting and we can talk

01:01:59.649 --> 01:02:01.585
about that offline. I have you
successfully time lining

01:02:01.585 --> 01:02:03.587
everything that is happening in
the SIM repository to find

01:02:03.587 --> 01:02:05.589
attacker inventory. And that is
interesting. I was able to use

01:02:05.589 --> 01:02:07.591
the time lining of -- the
background I guess is I saw an

01:02:07.591 --> 01:02:10.126
attacker install the
[indiscernible]. I looked at the

01:02:10.126 --> 01:02:16.132
other events that were happening
about that same time and saw

01:03:03.380 --> 01:03:05.615
artifacts that lead to the user
account ha the attacker

01:03:05.615 --> 01:03:11.621
compromised to compromise the
system and get that persistence

01:04:02.772 --> 01:04:07.777
there. That is something we
didn't know at the point and was

01:04:07.777 --> 01:04:14.250
able to add to the report. And
finally decode this stuff with

01:04:14.250 --> 01:04:20.156
full confidence. Say two or
three months ago when we were

01:04:20.156 --> 01:04:23.026
trying to do this the first
time, we would run strings on

01:04:23.026 --> 01:04:25.729
the SIM repository and get
things that looked like base 64

01:04:25.729 --> 01:04:27.731
commands in there and think we
got everything and then we threw

01:04:27.731 --> 01:04:29.733
it into the decoder and it was
truncated and didn't work. It's

01:04:29.733 --> 01:04:31.735
due to the way the file is
paged. Because we didn't know

01:04:31.735 --> 01:04:33.737
the mapping of all those, we
couldn't reconstruct. Now we can

01:04:33.737 --> 01:04:35.739
with full confidence. I think
we're in a good situation now in

01:04:35.739 --> 01:04:37.741
regards to investigating these
attacks. Anything more we can do

01:04:37.741 --> 01:04:39.743
to prevent these attacks in the
future? Something that is

01:04:39.743 --> 01:04:41.745
effecting our client's
organization. That is what Matt

01:04:41.745 --> 01:04:43.747
is going to talk about next. >>
So I want you to consider the

01:04:43.747 --> 01:04:45.749
following. An attacker can do a
lot of things. I'm going to give

01:04:45.749 --> 01:04:47.751
a few examples of attacks and
the effects that they'll have in

01:04:47.751 --> 01:04:50.487
WMI that you might be able to
form a creative WQL query off of

01:04:50.487 --> 01:04:53.323
to potentially detect these sort
of things as they're happening

01:04:53.323 --> 01:04:55.425
in realtime. An attacker
persists an -- subscription.

01:04:55.425 --> 01:04:57.894
What ends up happening from a
WMI perspective is instance of

01:04:57.894 --> 01:05:03.533
event filters, event consumers
and filter to consumer bindings

01:05:03.533 --> 01:05:09.539
are created and a respective
event that is triggered upon

01:05:15.779 --> 01:05:21.785
creation of the class instances
is an instance creation event.

01:05:28.057 --> 01:05:34.063
An attacker uses WMI as a C2
channel. Let's take that WMI

01:05:42.772 --> 01:05:48.778
shell tool that creates and
modifies WMI name spaces and

01:05:55.051 --> 01:05:59.222
uses it to stuff payloads and
store the results of executed

01:05:59.222 --> 01:06:01.457
payloads. The name space
creation event will trigger in

01:06:01.457 --> 01:06:06.229
this case. An attacker uses WMI
as a payload storage mechanism.

01:06:06.229 --> 01:06:11.367
Similar to WMI shell but say
we're talking about APT29 --

01:06:11.367 --> 01:06:15.104
create WMI classes and
properties dynamically and stuff

01:06:15.104 --> 01:06:20.710
the payload in there as well as
execute a payload, take the

01:06:20.710 --> 01:06:25.849
result of that payload and store
it into another class property.

01:06:25.849 --> 01:06:32.355
In this case for the TTPs by 29,
you see the class creation event

01:06:32.355 --> 01:06:37.026
be fired. Going further, an
attacker persists via the start

01:06:37.026 --> 01:06:43.099
menu or the registry. There is a
valuable WMI class called win 32

01:06:43.099 --> 01:06:47.770
start up command that captures
that very action. Whether it's

01:06:47.770 --> 01:06:53.376
the all user start up, user
start up directly, HKLM or one

01:06:53.376 --> 01:06:58.514
of the KCU hives, this single
WMI object will capture that.

01:06:58.514 --> 01:07:04.053
And the way that you would
capture that event is because an

01:07:04.053 --> 01:07:09.192
instance creation event would
fire of type win 32 start up

01:07:09.192 --> 01:07:12.929
command. An attacker modifies
any additional known persistence

01:07:12.929 --> 01:07:19.035
locations. One that comes to the
top of my mind is say you have a

01:07:19.035 --> 01:07:22.772
malicious LSA plug in installed.
The registry key used where

01:07:22.772 --> 01:07:25.608
those are installed to. Well, in
a more generic sense you can use

01:07:25.608 --> 01:07:27.810
the registry key change event
(audio blipped) to trigger --

01:07:27.810 --> 01:07:29.812
modification of any key or value
that you're specifically

01:07:29.812 --> 01:07:31.814
targeting. Service creation.
This is easy. Instance creation.

01:07:31.814 --> 01:07:34.350
Is going to fire of win 32 type
service. Are you seeing a

01:07:34.350 --> 01:07:36.953
pattern here? All of these
attack effects can effectively

01:07:36.953 --> 01:07:43.826
be described in the form of a
WQL query. What's the WQL query?

01:07:43.826 --> 01:07:49.832
That event filter. Requirement
No. 1 for an instance of

01:07:56.439 --> 01:08:02.378
permanent WMI event
subscriptions. You want to do

01:08:06.482 --> 01:08:13.056
something upon triggering this
event. You have a standard event

01:08:13.056 --> 01:08:18.761
consumer and bind those together
using a filter to consumer

01:08:18.761 --> 01:08:21.965
binding. I thought this really
kind of begged for this exhibit

01:08:21.965 --> 01:08:24.867
mean here. (audio blipped) using
WMI as a persistence technique.

01:08:24.867 --> 01:08:28.104
What if we had a permanent WMI
event subscription that detected

01:08:28.104 --> 01:08:31.007
the [indiscernible] it's do
able. All right. So we could

01:08:31.007 --> 01:08:34.043
potentially detect persistence,
any WMI persistence, registry

01:08:34.043 --> 01:08:36.546
per SYS sans using the registry
key change event. Service

01:08:36.546 --> 01:08:38.948
creation. Easy. Schedule job and
task creation. You can get

01:08:38.948 --> 01:08:41.117
creative. Think of any attacker
action and the respective

01:08:41.117 --> 01:08:44.020
artifacts that it might leave
behind and there is going to be

01:08:44.020 --> 01:08:46.923
almost guaranteed there is going
to be a WQL query that can

01:08:46.923 --> 01:08:52.929
respect that attacker effect.
The only exception to that as I

01:08:55.365 --> 01:09:01.804
mentioned before, below Windows
8 you don't have WMI classes

01:09:01.804 --> 01:09:03.906
that represent network actions.
There is a known gap there. All

01:09:03.906 --> 01:09:06.609
right. So perhaps we can use WMI
as say an agent list host IBS.

01:09:06.609 --> 01:09:08.611
We register or own permanent WMI
event subscriptions that detect

01:09:08.611 --> 01:09:10.613
all kinds of attacker activity
and the benefit is it's

01:09:10.613 --> 01:09:12.615
persistent, the service is
running and there is no agent.

01:09:12.615 --> 01:09:14.617
We don't have to push our own
executable package onto a

01:09:14.617 --> 01:09:16.619
system. Microsoft gives us this
mechanism without dropping a

01:09:16.619 --> 01:09:18.688
single file. And we can install
it remotely. I wrote a proof of

01:09:18.688 --> 01:09:20.690
concept tool called WMI post
IDS. It's effectively an agent

01:09:20.690 --> 01:09:22.692
list host-based IDS. A single
PowerShell module file. All you

01:09:22.692 --> 01:09:25.962
do is call it import module and
then the name of the file and so

01:09:25.962 --> 01:09:28.931
the only system that requires
PowerShell is the one that

01:09:28.931 --> 01:09:31.968
you're installing it from. What
you're doing on the backend is

01:09:31.968 --> 01:09:33.970
just creating locally or
remotely those event

01:09:33.970 --> 01:09:36.672
subscriptions on the machine
that you want to register these

01:09:36.672 --> 01:09:38.741
alerts on. Let's see this in
action. The attacker machine.

01:09:38.741 --> 01:09:40.743
Then you import. List the module
and currently there are four

01:09:40.743 --> 01:09:42.745
functions. Trigger, register
alert with the requirements for

01:09:42.745 --> 01:09:44.747
permanent (audio blipped) WMI
persistence. Let's look at the

01:09:44.747 --> 01:09:46.749
help. What does new alert
trigger do? This is what you

01:09:46.749 --> 01:09:48.751
want to trigger off of. We can
trigger off event consumer,

01:09:48.751 --> 01:09:50.753
creation, modification or
deletion. We can trigger off the

01:09:50.753 --> 01:09:52.755
start up command object or the -
a change to a registry key.

01:09:52.755 --> 01:09:54.757
There is much to be expanded in
this but right now this is just

01:09:54.757 --> 01:09:56.759
a proof of concept to show it's
possible. New alert action. This

01:09:56.759 --> 01:09:58.761
is the payload that we want to
execute as a defender. We can

01:09:58.761 --> 01:10:00.763
either send that event
information to a URI or we can

01:10:00.763 --> 01:10:02.765
create an event log entry. We
would be supplementing the event

01:10:02.765 --> 01:10:04.767
log with whatever event it is
that we're interested in as a

01:10:04.767 --> 01:10:08.237
defender. And then we register
the respective trigger and

01:10:08.237 --> 01:10:14.377
action together using register
alert. So let's see this in

01:10:14.377 --> 01:10:20.516
action. Now, I'm interested in
detecting in realtime the attack

01:10:20.516 --> 01:10:23.119
that you saw at the beginning of
the talk. So I'm going to

01:10:23.119 --> 01:10:25.121
provide the credentials to the
remote system. Register my

01:10:25.121 --> 01:10:27.123
trigger. What do I want to fire
off of? The creation of a

01:10:27.123 --> 01:10:29.125
command line event consumer.
Which is what the attack used.

01:10:29.125 --> 01:10:31.127
So trigger type creation.
Optimally you can provide a name

01:10:31.127 --> 01:10:33.129
of this trigger when it's
registered persistently in the

01:10:33.129 --> 01:10:35.131
SIM repo. And then you just take
that, type it to new alert

01:10:35.131 --> 01:10:41.137
action, so this is what we want
to do upon the creation of say a

01:10:50.546 --> 01:10:52.548
malicious command line event
consumer. So in this case I want

01:10:52.548 --> 01:10:54.550
to create an event log.
Hopefully as a defender you

01:10:54.550 --> 01:10:56.552
would be forwarding your event
logs to some centralized logging

01:10:56.552 --> 01:10:58.554
server. And register it together
with the register alert

01:10:58.554 --> 01:11:00.490
function. And as proof we now
have our created instances of

01:11:00.490 --> 01:11:02.492
the event filter, event consumer
and filter to consumer binding

01:11:02.492 --> 01:11:04.494
on the remote system. I said
this was the attacker machine as

01:11:04.494 --> 01:11:06.496
well. We're going to execute the
track data scraper again. Before

01:11:06.496 --> 01:11:08.498
we do that as proof to show you
that this hasn't fired yet, I

01:11:08.498 --> 01:11:10.500
want to be able to pull back
remotely the event log entry

01:11:10.500 --> 01:11:12.502
that I would be looking for upon
a malicious eventer consumer

01:11:12.502 --> 01:11:14.504
being created. Just to show the
payload hasn't been executed.

01:11:14.504 --> 01:11:16.506
There is no event log at this
point. Installed remotely and

01:11:16.506 --> 01:11:18.508
persistently, the - data scraper
is going to do its thing. This

01:11:18.508 --> 01:11:20.510
is the same exact payload that
you saw installed previously.

01:11:20.510 --> 01:11:22.512
Now, I'm going to look at the
event log to see if that event

01:11:22.512 --> 01:11:24.514
was created. Which indeed it was
created. So this was realtime

01:11:24.514 --> 01:11:30.520
detection of this in action. And
so like what Claudiu did

01:12:13.663 --> 01:12:17.733
earlier, I can parse out this
payload and see that what it's

01:12:17.733 --> 01:12:20.036
doing is it's stumped the
payload in the win 32 process

01:12:20.036 --> 01:12:22.405
class I believe and then -- or
in the payload property. And I

01:12:22.405 --> 01:12:24.740
can even pull that back remotely
using the SIM command. I say get

01:12:24.740 --> 01:12:26.943
SIM class on win 32 payload
which we see here. I'm pulling

01:12:26.943 --> 01:12:29.111
this remotely and I'm interested
in dumping out the data in the

01:12:29.111 --> 01:12:31.314
payload property. And I get the
base 64 included payload. So we

01:12:31.314 --> 01:12:33.316
have two options. We have now
the capability to perform dead

01:12:33.316 --> 01:12:35.318
box forensics and the ability to
perform detection in realtime

01:12:35.318 --> 01:12:37.486
using WMI. So as a defender, I
just showed you a few instances

01:12:37.486 --> 01:12:41.057
of how you can use this to
detect activity in realtime.

01:12:41.057 --> 01:12:47.330
There are a bunch of other
things you can trigger off of.

01:12:47.330 --> 01:12:53.102
For example event log creation
or say you might want to trigger

01:12:53.102 --> 01:12:57.006
off of the clearing of an event
log and do something interesting

01:12:57.006 --> 01:12:59.275
as a defender. Do process
auditing. Monitor files or

01:12:59.275 --> 01:13:01.477
directories, and then in Windows
8 and above, check out the MSFT

01:13:01.477 --> 01:13:03.779
net classes. These you can query
and trigger off the creation and

01:13:03.779 --> 01:13:05.781
removal of new network
connections. Okay. We can use

01:13:05.781 --> 01:13:07.783
PowerShell to detect WMI
persistence after the fact. I

01:13:07.783 --> 01:13:09.785
showed you how to do it in
realtime. Say you want the sweep

01:13:09.785 --> 01:13:11.787
the whole enterprise, there are
a few lines that can accomplish

01:13:11.787 --> 01:13:13.789
that. Existing utilities out
there that can help detect WMI

01:13:13.789 --> 01:13:15.791
persistence after the fact. The
latest autorun has a WMI tab

01:13:15.791 --> 01:13:17.894
that will present out the event
filters and consumers and you

01:13:17.894 --> 01:13:19.896
can right click and delete them.
[indiscernible] pure incident

01:13:19.896 --> 01:13:21.898
response framework for
PowerShell has WMI detection.

01:13:21.898 --> 01:13:23.900
Lastly one other thing I would
like to mention is you can

01:13:23.900 --> 01:13:25.901
actually set the name space, for
each respective name space. Say

01:13:25.901 --> 01:13:27.903
you wanted to remove the ability
to execute the win 32 process

01:13:27.903 --> 01:13:30.072
create method. You can go into
the root SIM 2 name space where

01:13:30.072 --> 01:13:33.442
the process is and remove the
ability of anyone to execute

01:13:33.442 --> 01:13:35.444
those methods remotely. Shawn
Metcalf, mentioned to me, this

01:13:35.444 --> 01:13:37.446
was a great idea from an
attacker's perspective. What I'm

01:13:37.446 --> 01:13:39.448
saying here as a defender you
can set Ackles (ph). Imagine

01:13:39.448 --> 01:13:41.450
compromising a DC and
downgrading the Ackles (ph) so

01:13:41.450 --> 01:13:43.452
any authenticated user without
any privilege on the domain can

01:13:43.452 --> 01:13:45.454
go back and recompromise the
domain controller. All right. So

01:13:45.454 --> 01:13:47.456
that's it. Just want to give a
shout out to Will Schroder and

01:13:47.456 --> 01:13:49.458
Justin Warner for giving me
great ideas on the event filters

01:13:49.458 --> 01:13:51.460
that you can come up as a
defender and attacker. And Willi

01:13:51.460 --> 01:13:53.462
take it away? >> I hope through
this presentation we brought you

01:13:53.462 --> 01:13:55.464
through an emotional roller
coaster. We started about talk

01:13:55.464 --> 01:13:57.466
about how awesome WMI was and I
think it's neat how after the

01:13:57.466 --> 01:13:59.468
fact we can come in and say here
are the things you can do to

01:13:59.468 --> 01:14:01.404
defend from that using the same
techniques and forensic

01:14:01.404 --> 01:14:03.406
techniques. I think it's fair
that we acknowledge our employer

01:14:03.406 --> 01:14:05.408
for this. And share it with you.
All this code is on GitHub at

01:14:05.408 --> 01:14:07.410
this point. Just before this
talk we finalized and asked to

01:14:07.410 --> 01:14:09.412
be published a white paper that
goes into great detail. It's

01:14:09.412 --> 01:14:11.414
about 100 pages long and talks
in depth about everything here.

01:14:11.414 --> 01:14:13.416
This is information that I hope
you can take away from the talk

01:14:13.416 --> 01:14:18.287
and implement in your
environment or use on another

01:14:18.287 --> 01:14:22.391
person's environment. Couple
references here. We'll share

01:14:22.391 --> 01:14:28.230
that white paper. The flare
challenge. Great way to practice

01:14:28.230 --> 01:14:32.401
reverse engineering. Starts off
easy and gets pretty complex and

01:14:32.401 --> 01:14:38.407
we'd love to chat after this
talk. We have almost a half hour

01:14:47.817 --> 01:14:53.823
for questions or a half hour to
get over to the parse talk. The

01:15:11.173 --> 01:15:17.179
microphone is coming around. >>
As far as the trying to

01:15:21.283 --> 01:15:23.285
downgrade how many classes there
are to go through is there

01:15:23.285 --> 01:15:25.287
master hash libraries, does that
mess everything up or can you

01:15:25.287 --> 01:15:27.990
exclude those and do the rest of
the values. >> Totally feasible

01:15:27.990 --> 01:15:33.996
and not difficult to do, a hash
list of the known classes and

01:15:42.872 --> 01:15:44.874
the properties you expect to
find there across an environment

01:15:44.874 --> 01:15:46.876
and go from the gold image to
anything installed on a

01:15:46.876 --> 01:15:48.911
workstation. That would limit it
to 5, 10 classes. >> Would that

01:15:48.911 --> 01:15:50.946
be primarily location specific
or is it possible to develop one

01:15:50.946 --> 01:15:52.948
for multiple systems just
contribution based. >> I think

01:15:52.948 --> 01:15:55.184
we have a lot of flexibility
there in the way we attack it.

01:15:55.184 --> 01:15:57.420
We'll try it after. >> As a
follow up, any techniques you

01:15:57.420 --> 01:15:59.422
can share for doing this at
scale for identifying providers

01:15:59.422 --> 01:16:01.724
across an entire environment? >>
I think the most obvious one is

01:16:01.724 --> 01:16:03.726
this persistence mechanism that
we talked about to consumer

01:16:03.726 --> 01:16:06.295
bindings. This is the only one
we've seen so far. And on top of

01:16:06.295 --> 01:16:08.464
that on a default Windows
insulation, there is one or two

01:16:08.464 --> 01:16:10.666
persistent WMI consumers used by
the operating system to do its

01:16:10.666 --> 01:16:13.235
own thing. You only expect to
find one or two per system. It's

01:16:13.235 --> 01:16:16.205
easy to look at scale how many
do I have. Five, ten? That is

01:16:16.205 --> 01:16:19.175
something to look at and say
that's weird. That's a good

01:16:19.175 --> 01:16:21.777
place to start. >> Were you also
asking specifically about WMI

01:16:21.777 --> 01:16:23.779
providers? >> Not specifically.
More as the - in methodology to

01:16:23.779 --> 01:16:25.781
detect across an environment. >>
It might be worth noting when a

01:16:25.781 --> 01:16:27.783
new WMI provider is created you
can say trigger off instance

01:16:27.783 --> 01:16:30.553
creation event of type under
score under score win 32

01:16:30.553 --> 01:16:33.489
provider. You can take the
definition of that - there is a

01:16:33.489 --> 01:16:36.926
GUI that you can look up in the
registry and that shows the DLL

01:16:36.926 --> 01:16:39.628
that is for that provider. >>
Are there any situations where

01:16:39.628 --> 01:16:42.832
you might put an Acklet (ph) on
and cause something else not to

01:16:42.832 --> 01:16:45.301
work properly. >> If you're
doing things with WMI remotely

01:16:45.301 --> 01:16:48.904
you want to be mindful of that.
Say you can create like a remote

01:16:48.904 --> 01:16:52.942
WMI administrators group and
limit the Ackles (ph) to that

01:16:52.942 --> 01:16:55.244
group and block everything else
for every other group. >>

01:16:55.244 --> 01:16:57.246
Anything specific within Windows
for using that or just if you're

01:16:57.246 --> 01:16:59.248
using remote WMI for yourself?
It's like any standard Windows

01:16:59.248 --> 01:17:01.183
services that would need that in
order to function properly. >>

01:17:01.183 --> 01:17:03.185
That is a good question. I never
looked into what some of the

01:17:03.185 --> 01:17:05.187
unintended side effects would be
of just disabling that service.

01:17:05.187 --> 01:17:07.189
Windows is increasingly relying
on this service -- like desired

01:17:07.189 --> 01:17:09.191
state configuration that relies
heavily on WMI under the hood. I

01:17:09.191 --> 01:17:11.193
would be wary of that. >> First
of all, excellent presentation

01:17:11.193 --> 01:17:13.195
and thank you for that. For
opening up a new class of

01:17:13.195 --> 01:17:15.197
defense which is not available
using the existing tool chain

01:17:15.197 --> 01:17:17.199
that we have. Thank you for
that. I have a few questions.

01:17:17.199 --> 01:17:19.201
First is I write my own custom
files to do different stuff.

01:17:19.201 --> 01:17:21.203
Most of your defense analysis is
coming with a clean machine

01:17:21.203 --> 01:17:23.205
[indiscernible] you're going to
trip my more file for sure? >>

01:17:23.205 --> 01:17:25.207
So backing up. We didn't really
cover moth very much. Only

01:17:25.207 --> 01:17:27.209
because from an attackers
perspective and investigator's

01:17:27.209 --> 01:17:29.211
perspective, what we see more
and more is attackers doing

01:17:29.211 --> 01:17:31.213
everything dynamically without a
moth file. You can use a moth

01:17:31.213 --> 01:17:33.215
file to carry out the same exact
attacks that the attackers are

01:17:33.215 --> 01:17:35.217
doing. Only a moth introduces
another forensic artifact that

01:17:35.217 --> 01:17:37.219
has a defender you would be able
to detect pretty easily. From an

01:17:37.219 --> 01:17:39.221
attacker's perspective, in my
view the only thing that a moth

01:17:39.221 --> 01:17:41.223
file gets you is persistence
beyond WM, repository

01:17:41.223 --> 01:17:43.225
corruption. Not sure if you want
to ask your question again. Say

01:17:43.225 --> 01:17:45.227
how moth might play into all
this? >> The second question is

01:17:45.227 --> 01:17:47.229
for Willie with that tool. How
do you handle WMI recompile in a

01:17:47.229 --> 01:17:49.231
Citrix environment
[indiscernible]. Compilation and

01:17:49.231 --> 01:17:51.233
back up and restore the
repositories. What happens to

01:17:51.233 --> 01:17:53.235
you daytime signatures that
you're relying on and say if I

01:17:53.235 --> 01:17:55.237
drop a payload, and immediately
after that I can take the whole

01:17:55.237 --> 01:17:57.239
moth and recompile the
repository, and I mean on my

01:17:57.239 --> 01:17:59.241
time line there should be a
line. >> Sure. We're explaining

01:17:59.241 --> 01:18:01.177
how the time lines are effected
now by inserting new data into

01:18:01.177 --> 01:18:03.178
the repository and taking it
out. As you insert dynamically

01:18:03.178 --> 01:18:05.180
new classes not all the --
change. Typically they're

01:18:05.180 --> 01:18:07.182
restricted to the new objected
created or modified. I suspect

01:18:07.182 --> 01:18:09.184
they stand out like a sore thumb
when doing the time line

01:18:09.184 --> 01:18:11.186
analysis. Does that answer the
question? >> It's a good start.

01:18:11.186 --> 01:18:13.189
Another thing is [indiscernible]
how do you track that in

01:18:13.189 --> 01:18:15.191
environments which doesn't use
ACCM. >> I pointed to that

01:18:15.191 --> 01:18:17.193
forensic artifact as something
useful. In 50 percent of the

01:18:17.193 --> 01:18:19.195
environments that we investigate
they're using MS8067 SCM. This

01:18:19.195 --> 01:18:21.197
is a huge -- to look for as a
consulting company. But if

01:18:21.197 --> 01:18:23.198
you're not using that in your
organization, you may not find

01:18:23.198 --> 01:18:25.201
it useful. >> Did you try taking
objects dot update data and

01:18:25.201 --> 01:18:27.202
dumping into it a -- which can
nest it [indiscernible] >> No.

01:18:27.202 --> 01:18:29.204
>> You did a static analysis of
the whole thing which is

01:18:29.204 --> 01:18:31.206
forensically. >> Usually you
don't take only the objects --

01:18:31.206 --> 01:18:33.208
(audio blipped) you have to have
all the files. In order to get

01:18:33.208 --> 01:18:35.210
all the data and how the data is
constructed, you need the

01:18:35.210 --> 01:18:37.212
mapping file. If you have a
record that is bigger than the

01:18:37.212 --> 01:18:39.215
page size, there will be
different chance of different

01:18:39.215 --> 01:18:41.217
offset. It's not sequential.
That is one of the things. But

01:18:41.217 --> 01:18:43.219
no, we didn't go and
[indiscernible] that's correct.

01:18:43.219 --> 01:18:45.220
You can go -- the next big thing
we want to invest some time in

01:18:45.220 --> 01:18:47.223
is recovering deleted artifacts.
Because the mapping that -- the

01:18:47.223 --> 01:18:49.224
active mapping file has a list
of three pages which whenever

01:18:49.224 --> 01:18:51.227
you insert something new in the
data base, [indiscernible] they

01:18:51.227 --> 01:18:53.228
will be used. Whenever something
goes outs of the scope, the data

01:18:53.228 --> 01:18:55.231
still resides in the object set
data. You can go and parse every

01:18:55.231 --> 01:18:57.232
file in the -- every page that
is in the three page array and

01:18:57.232 --> 01:18:59.235
look for artifacts there. You
can do [indiscernible] both for

01:18:59.235 --> 01:19:01.170
BPR and object set data? >>
Imagine the attacker is trying

01:19:01.170 --> 01:19:03.172
to be stealthy. After they
install, they only want to

01:19:03.172 --> 01:19:05.174
execute the payload once. They
do what they do and as a clean

01:19:05.174 --> 01:19:07.176
up remove the event filter and
consumer and filter to consumer

01:19:07.176 --> 01:19:09.178
binding. Those artifacts are
going to persist in these three

01:19:09.178 --> 01:19:11.180
pages which we don't have the
ability to parse at the moment.

01:19:11.180 --> 01:19:13.182
But they're the tools like once
the research is done, extended

01:19:13.182 --> 01:19:15.951
to pull those artifacts out. >>
The next question, we start

01:19:15.951 --> 01:19:18.988
charging. >> Depends how much
you charge. So a lot of the

01:19:18.988 --> 01:19:21.490
forensic analysis is focused on
finding out what exactly --

01:19:21.490 --> 01:19:23.492
consumer binding. But you do not
have any trace of what events

01:19:23.492 --> 01:19:26.996
did fire. >> Wouldn't you
through -- from the filter to

01:19:26.996 --> 01:19:28.998
consumer binding you would have
the event filter property and

01:19:28.998 --> 01:19:31.000
when you look at that instance
you would see the event of

01:19:31.000 --> 01:19:33.002
interest. >> The question is
you're coming into exploited

01:19:33.002 --> 01:19:35.004
system after point X after
something has happened. Or

01:19:35.004 --> 01:19:37.006
unless you're looking at it with
your WMI and you have the moth

01:19:37.006 --> 01:19:39.008
files pre-installed, if you
don't have that there is no way

01:19:39.008 --> 01:19:41.010
to keep track of what already
fired in the system. Unless you

01:19:41.010 --> 01:19:43.012
have a consumer there is no
persistence, right. You know

01:19:43.012 --> 01:19:45.014
what I'm saying. >> I think
you're right. You're saying we

01:19:45.014 --> 01:19:47.016
see the persistence mechanism
installs but we don't know if it

01:19:47.016 --> 01:19:49.018
fired and the payload. That is
equivalent to finding a run key

01:19:49.018 --> 01:19:51.020
in the registry, you don't know
if the system rebooted and the

01:19:51.020 --> 01:19:53.022
run key executed but it's enough
to kick off the investigation

01:19:53.022 --> 01:19:55.024
and say there is malware here.
It's been installed. Typically I

01:19:55.024 --> 01:19:57.026
say this box is compromised and
assume the malware has run even

01:19:57.026 --> 01:19:59.028
though we didn't see the
specific trigger that caused the

01:19:59.028 --> 01:20:01.030
consumer to execute. >> I
understand what you're saying.

01:20:01.030 --> 01:20:03.032
We're in agreement. >> Cool. >>
More questions. >> Sure. >> The

01:20:03.032 --> 01:20:05.034
B tree file which you're
analyzing, I know that there are

01:20:05.034 --> 01:20:07.036
certain stuff which stands out.
Meaning the name, a lot of this

01:20:07.036 --> 01:20:09.038
analysis is very name based. I
would say if you're hiding, I'm

01:20:09.038 --> 01:20:11.040
trying to say how can you get
beyond detecting things based

01:20:11.040 --> 01:20:13.042
just on name or base 64 dump or
something which is stealthy? >>

01:20:13.042 --> 01:20:15.044
[indiscernible] >> My point is B
tree is where the deposit is

01:20:15.044 --> 01:20:17.046
stored is there a differential
am SYS. >> No the B tree stores

01:20:17.046 --> 01:20:19.048
different representation of
different artifacts. The keys in

01:20:19.048 --> 01:20:21.050
the B tree is concatenation of
-- for example, if you want to

01:20:21.050 --> 01:20:23.052
specify a class definition you
have to provide the

01:20:23.052 --> 01:20:25.054
interpretation of the name space
full path and the class name.

01:20:25.054 --> 01:20:27.056
That represents a key into the
index. And this is how you are

01:20:27.056 --> 01:20:29.058
able to query the objects, by
finding the location information

01:20:29.058 --> 01:20:31.060
of the data and objects. That's
the purpose of the index BTR.

01:20:31.060 --> 01:20:33.062
There is no other information.
It's just for searching quick

01:20:33.062 --> 01:20:35.064
and finding where the data
resides. >> Question for Matt.

01:20:35.064 --> 01:20:37.066
Development class without
autorecover. [indiscernible]

01:20:37.066 --> 01:20:39.068
meaning I drop it, it fires off
once. And goes away. >> Well,

01:20:39.068 --> 01:20:41.070
like if you had a moth file that
still did (audio blipped) even

01:20:41.070 --> 01:20:43.072
without autorecover. Just
autorecover will recover

01:20:43.072 --> 01:20:45.074
everything and recompile the
moth after the rebuilding of the

01:20:45.074 --> 01:20:47.076
database. We'll take any further
questions offline and we can

01:20:47.076 --> 01:20:49.078
talk about this for hours. We'll
just be right outside. Thanks

01:20:49.078 --> 01:20:51.380
again for staying so long and
missing out on the car hacking

01:20:51.380 --> 01:20:57.386
talk. We really appreciate it.

