00:00:00.000 --> 00:00:05.272
Good morning. So everybody
that's like from the middle half

00:00:05.272 --> 00:00:09.176
of the room, if you all want to
come up a little bit, there is

00:00:09.176 --> 00:00:12.212
going to be some slides here
that have some code on it. The

00:00:12.212 --> 00:00:16.850
code has really tiny text. My
eyesight isn't that good that

00:00:16.850 --> 00:00:21.121
far back. Trying to do a favor
to y'all to come forward so you

00:00:21.121 --> 00:00:27.127
can see what is going on. With
that here is Topher. >> Awesome.

00:00:33.367 --> 00:00:36.770
Thanks for having me. This is my
first time speaking at DEFCON

00:00:36.770 --> 00:00:40.474
and my first time attending and
I'm blown away at the caliber of

00:00:40.474 --> 00:00:45.746
this community. Thank you for
coming to the talk. This is

00:00:45.746 --> 00:00:48.782
hijacking arbitrary .NET
application control flow and I'm

00:00:48.782 --> 00:00:51.351
going to screw up sot .NET
applications. Who am I? I'm a

00:00:51.351 --> 00:00:53.587
security researcher at Intel.
Previously doing research in

00:00:53.587 --> 00:00:56.290
Ashland, Oregon in Southern
Oregon University. I've done a

00:00:56.290 --> 00:01:02.229
little bit of security training.
I did a talk on .NET hacking in

00:01:16.476 --> 00:01:22.149
Oslo, Norway and occasionally
blog and tweet. .NET, why the

00:01:22.149 --> 00:01:27.087
hell do any of us care? Like I
said, I was at the new

00:01:27.087 --> 00:01:31.024
developers conference in Oslo
and 80 percent of the attendees

00:01:31.024 --> 00:01:35.963
there were .NET developers.
There is constant jobs up online

00:01:35.963 --> 00:01:38.865
for this. SQL databases,
fingerprint readers, et cetera.

00:01:38.865 --> 00:01:43.904
There is a big market for .NET
but there aren't really people

00:01:43.904 --> 00:01:49.910
attacking .NET. I'm going to go
through run time attacks in the

00:01:53.513 --> 00:01:55.983
.NET. Manipulating the just in
time compilation process,

00:01:55.983 --> 00:02:00.153
manipulating things at the
machine code level. Modify

00:02:00.153 --> 00:02:08.061
control flow in .NET
applications, taking branches

00:02:08.061 --> 00:02:12.265
and changing them arbitrarily to
things that you control to do

00:02:12.265 --> 00:02:16.403
something different in the
application that is evil. And

00:02:16.403 --> 00:02:19.673
then I'm going to show you
machine code editing in .NET.

00:02:19.673 --> 00:02:24.077
This is not a common practice
now. A lot of people are doing

00:02:24.077 --> 00:02:28.281
ILD compilation and changing
bytes at the ILD level and these

00:02:28.281 --> 00:02:33.020
are on disk attacks so I'm going
to go down to machine code. And

00:02:33.020 --> 00:02:40.027
manipulate the [indiscernible]
which is the mechanism that .NET

00:02:40.027 --> 00:02:43.864
uses to store all objects. It's
unprotected. We can go through

00:02:43.864 --> 00:02:46.900
and rip off objects that are
instantiated and and use them

00:02:46.900 --> 00:02:48.902
ourselves. I'm releasing tools
for this demo. And then we're

00:02:48.902 --> 00:02:56.143
using .NET to attack. Not many
people are operating in the

00:02:56.143 --> 00:03:02.049
space which I think it's cool.
And then of course we're using

00:03:02.049 --> 00:03:05.085
objects on the manage -- which
isn't something that's been done

00:03:05.085 --> 00:03:11.091
too much before and I think
you're going to enjoy it. When I

00:03:16.663 --> 00:03:20.500
talk about CLR attacks or the
common language run time, I'm

00:03:20.500 --> 00:03:24.838
talking actual run time. You
have a process running on a

00:03:24.838 --> 00:03:31.011
machine, a C application, that's
the process. In .NET there is a

00:03:31.011 --> 00:03:36.083
level underneath that called the
CLR and it's a container for the

00:03:36.083 --> 00:03:40.687
.NET instance. A process inside
a process. Two versions of the

00:03:40.687 --> 00:03:46.693
CLR, version 2 and 4. And when
you're building attack pay lows

00:03:49.596 --> 00:03:52.899
for C sharp you have to worry
about the target application but

00:03:52.899 --> 00:03:56.203
we don't have to worry about
that anymore because I took care

00:03:56.203 --> 00:03:59.973
of the work and now we can use
any payload and not care the

00:03:59.973 --> 00:04:06.279
version. With a CLR that is
where the sheep is living. It's

00:04:06.279 --> 00:04:11.551
a run time concept where objects
are being stored. That's

00:04:11.551 --> 00:04:17.057
essentially a part of attacking
the CLR. If we dive down into a

00:04:17.057 --> 00:04:22.229
.NET process, we have at
domains, giant containers for

00:04:22.229 --> 00:04:25.766
running code and they contain
the actual executable that we're

00:04:25.766 --> 00:04:29.302
running and all of the DLLs that
we're running. Those are called

00:04:29.302 --> 00:04:33.673
assembles. Within an app domain,
there can be more than one but

00:04:33.673 --> 00:04:37.377
it's no common. And utilizing
that commonality, because of

00:04:37.377 --> 00:04:43.383
this we can control all loaded
code. If we have access to the

00:04:46.586 --> 00:04:53.660
CLR itself we can just in time
the compilation process.

00:04:53.660 --> 00:04:59.799
Assembly or ASM, assembly is a
module like a DLL or executable,

00:04:59.799 --> 00:05:05.205
we can manipulate the resources
of it. Go through and edit the

00:05:05.205 --> 00:05:11.678
method tables. Call in machine
code at .NET to go through

00:05:11.678 --> 00:05:15.382
structures and enumerators. And
then of course attacking methods

00:05:15.382 --> 00:05:21.388
purely at the machine code
level. So here is a kind of

00:05:24.991 --> 00:05:29.262
layout of the run time. You have
the processor, the CLR and app

00:05:29.262 --> 00:05:31.398
domains and assemblies and like
any other language. Objects with

00:05:31.398 --> 00:05:33.400
properties, fields and instance
methods and classes that contain

00:05:33.400 --> 00:05:36.069
static methods and the core
logic of the application. Now

00:05:36.069 --> 00:05:40.006
that we have an idea of what a
.NET process looks like and what

00:05:40.006 --> 00:05:46.012
these tools are going to be
doing, I'm going to jump into

00:05:48.481 --> 00:05:55.989
them instead of boring you with
the details of .NET. Gray frost

00:05:55.989 --> 00:05:59.459
and gray storm are two tools but
acting in tandem for this. Gray

00:05:59.459 --> 00:06:06.533
frost is a DLL that you inject
and it's a boot strapping

00:06:06.533 --> 00:06:10.570
process to bind the payload into
the .NETCLR. And gray storm is

00:06:10.570 --> 00:06:16.977
the payload that I'm delivering
are gray frost. Gray storm is

00:06:16.977 --> 00:06:19.879
written in C sharp that attacks
.NET. Gray frost in detail. Gray

00:06:19.879 --> 00:06:25.886
frost is the payload delivery
system. A C++ DLL that acts as a

00:06:32.459 --> 00:06:36.730
DLR boot strapper. It's going
through and figuring out what

00:06:36.730 --> 00:06:43.103
methods to call within MS query
which is the main CLR, DLL. It

00:06:43.103 --> 00:06:49.009
calls a bunch of methods that
create or inject into the CLR

00:06:49.009 --> 00:06:54.915
run time. I mentioned there were
two versions of the CLR, version

00:06:54.915 --> 00:07:00.854
2 and version 4, this payload
delivery system has the

00:07:11.464 --> 00:07:14.200
capability to pivot into the 2.0
run time if needed. This gives

00:07:14.200 --> 00:07:16.436
us the mechanism to not care
about the target application

00:07:16.436 --> 00:07:18.471
running is, and insert an
arbitrary payload like gray

00:07:18.471 --> 00:07:20.507
storm. Gray frost contains the
ray payload [indiscernible] once

00:07:20.507 --> 00:07:22.776
through the boot strapping
process and it's in the proper

00:07:22.776 --> 00:07:25.478
version of CLR it fires the
payloads void main. It does this

00:07:25.478 --> 00:07:30.684
in two rounds. The first round
is gray frost CPP. This is the

00:07:30.684 --> 00:07:36.856
DLL bots process. And after that
process finishes it's going to

00:07:36.856 --> 00:07:39.793
fire the C sharp payload. So
graphically this is going to

00:07:39.793 --> 00:07:45.231
look like this for round one
which is gray frost CPP. The

00:07:45.231 --> 00:07:51.438
.NET process is running. This
can be on a box that we have

00:07:51.438 --> 00:07:55.742
physical access to, remote, it
doesn't matter. All we need to

00:07:55.742 --> 00:07:59.312
do is do DLL injection. You can
utilize a tool called gray

00:07:59.312 --> 00:08:01.981
dragon. Doesn't matter. Inject
the DLL however you want. Once

00:08:01.981 --> 00:08:07.987
it's spinning it pivots and
calls the needed methods and

00:08:13.059 --> 00:08:19.899
instantiates the CLR. And C
sharp, at this point we're in

00:08:19.899 --> 00:08:26.473
the proper version of CLR, 4.0.
So we have our .NET process with

00:08:26.473 --> 00:08:29.876
gray frost C sharp running, the
right version of the CLR and now

00:08:29.876 --> 00:08:32.278
the payload is running in
tandem. If we have to pivot with

00:08:32.278 --> 00:08:37.417
the run times -- you might think
it's not common because 4.0 is

00:08:37.417 --> 00:08:43.423
the newest and greatest but
developers are lazy so a lot of

00:08:45.725 --> 00:08:51.731
things are 2.0 unfortunately.
It's not more of a step. I did

00:08:54.033 --> 00:09:00.874
the work for you. After
injection and after it ..(audio

00:09:00.874 --> 00:09:06.312
blipped).. gray frost C sharp.
Gray frost C sharp realizes that

00:09:06.312 --> 00:09:10.984
the app domain name is default.
If it's labeled as default that

00:09:10.984 --> 00:09:14.554
means the target application
isn't running an app domain

00:09:14.554 --> 00:09:18.158
because ..(audio blipped).. name
associated with it and I'm

00:09:18.158 --> 00:09:23.463
making default when I inject.
Gray frost C sharp comes into

00:09:23.463 --> 00:09:29.569
C++ we pivot to MS query and do
clean up and fire in the proper

00:09:29.569 --> 00:09:33.106
version of the CLR. So that's
gray frost in a nutshell. It's

00:09:33.106 --> 00:09:41.047
being open-sourced so you can
read the code of how all that is

00:09:41.047 --> 00:09:44.884
made possible. Let's get into
gray storm. Gray storm our

00:09:44.884 --> 00:09:52.392
reconnaissance and in-memory
attack payload. Several features

00:09:52.392 --> 00:09:57.931
that attack .NET at the assembly
level and run time level. We're

00:09:57.931 --> 00:10:00.633
going to be able to do things
like attack the .NET just in

00:10:00.633 --> 00:10:03.503
time compiler. If you're not
familiar with that, when you hit

00:10:03.503 --> 00:10:06.840
compile button, you're not
generating run able machine

00:10:06.840 --> 00:10:12.846
code. You're doing an
intermediate level language and

00:10:16.583 --> 00:10:19.319
at run time the IL code is just
in time compiled down into the

00:10:19.319 --> 00:10:25.758
actual machine code that is ran
by the CP for that particular

00:10:25.758 --> 00:10:31.064
method. We're going to be able
to with gray storm attack .NET

00:10:31.064 --> 00:10:37.070
at the ASM level. Rip pointers
off of messages ..(audio

00:10:39.138 --> 00:10:45.145
blipped).. In demonstrate -- own
assembly payloads and utilize --

00:10:49.382 --> 00:10:52.352
payloads. There are subtle
differences between the two.

00:10:52.352 --> 00:10:58.358
Then utilize objects on the
managed heap. Usage of gray

00:11:00.493 --> 00:11:06.499
storm. Controlling the just in
time compiler. When you have

00:11:09.602 --> 00:11:11.704
just in time compilation of the
debt net framework when method A

00:11:11.704 --> 00:11:15.341
is calling to method B, method B
contains a table that I'm

00:11:15.341 --> 00:11:20.513
calling the just in time
compilation stub. That contains

00:11:20.513 --> 00:11:24.350
an address to where the IL code
and machine code is going to be

00:11:24.350 --> 00:11:29.088
generated. Because we know this,
and because Microsoft chose to

00:11:29.088 --> 00:11:34.027
leave in the framework all this
stuff unprotected, we can go

00:11:34.027 --> 00:11:38.031
through and grab the tables,
overwrite with anything we want

00:11:38.031 --> 00:11:45.204
and control the just in time
compiler. ..(audio blipped)..

00:11:45.204 --> 00:11:48.007
this is not possible and you're
going to need to do something at

00:11:48.007 --> 00:11:51.311
the machine code level or wait
for something to get garbage

00:11:51.311 --> 00:11:53.846
collected. At that point
something is going to be just in

00:11:53.846 --> 00:11:56.816
time compiled again because the
.NET framework made room for

00:11:56.816 --> 00:12:03.723
something else. Graphically this
look likes this in the demo.

00:12:03.723 --> 00:12:10.096
Method A calls method B. What we
can do is take a hacker method

00:12:10.096 --> 00:12:16.102
with a git stub. Redirect method
B and now method A is going to

00:12:18.471 --> 00:12:23.309
call hacker method instead. I'm
going to open up a target

00:12:23.309 --> 00:12:28.548
application now. This is a
pretty cool mark down editor for

00:12:28.548 --> 00:12:34.520
Windows. I'm not running Linux
right now. Here is gray dragon,

00:12:34.520 --> 00:12:39.559
a remote DLL injector. It has
cute cross hairs to drag to the

00:12:39.559 --> 00:12:44.230
target application. I've done
some editing where it ..(audio

00:12:44.230 --> 00:12:48.668
blipped).. version of gray frost
I need to inject. Because this

00:12:48.668 --> 00:12:51.704
payload delivery system is going
to account for the differences

00:12:51.704 --> 00:12:57.910
in 32 and 64 bit targets. Once I
inject it's going to inject gray

00:12:57.910 --> 00:13:02.482
frost, and it's going to go
through the entire boot

00:13:02.482 --> 00:13:08.154
strapping process and spin up
gray storm. I injected it. It

00:13:08.154 --> 00:13:13.660
did the boot strapping process
and it's running in the 4.40

00:13:13.660 --> 00:13:20.633
version of the CLR. I'm going to
do a quick run through of this

00:13:20.633 --> 00:13:24.337
application. You can see on the
left side, this is inside of the

00:13:24.337 --> 00:13:27.173
main app domain and you're
seeing the assemblies within the

00:13:27.173 --> 00:13:33.079
domain, the main executable mark
down and the DLLs it needs: You

00:13:33.079 --> 00:13:37.283
can keep going down further and
further into each of these. Go

00:13:37.283 --> 00:13:42.922
until something like
[indiscernible] look at the

00:13:42.922 --> 00:13:46.859
methods it contains. Dump the
assembly so I can see the raw

00:13:46.859 --> 00:13:50.997
machine code for the method
after it's compiled. Look at the

00:13:50.997 --> 00:13:54.400
IL code for the thing. Shows
where the address of the machine

00:13:54.400 --> 00:14:00.173
code is. Attach this application
in windows D bag. I breakpoint

00:14:00.173 --> 00:14:05.144
on methods which is a little
easier than having to track them

00:14:05.144 --> 00:14:10.683
down. Let's go through and
attack this just in time

00:14:10.683 --> 00:14:13.553
compilation process. There's a
licensed feature in mark down

00:14:13.553 --> 00:14:17.590
pad two that allows you to
export to a PDF and currently I

00:14:17.590 --> 00:14:22.395
have a license for it. I'm able
to do this easily. I want to

00:14:22.395 --> 00:14:25.965
change that feature and I want
to insert my own method there. I

00:14:25.965 --> 00:14:29.302
don't want to wait for the just
in time compiler, I'm going to

00:14:29.302 --> 00:14:31.838
close out of that. Reopen the
target application. I'm going to

00:14:31.838 --> 00:14:37.844
drag the cross hairs back over
it, inject back in and then I'm

00:14:42.215 --> 00:14:45.251
going to come here to the
dynamic C sharp Window. This is

00:14:45.251 --> 00:14:47.887
going to allows us to compile
new codon the fly which I

00:14:47.887 --> 00:14:53.826
prepared. I'm going to pop up a
message box that said owned and

00:14:53.826 --> 00:14:57.997
returned false because I don't
want a license for this

00:14:57.997 --> 00:15:02.101
application anymore. I'm going
to paste that here and ..(audio

00:15:02.101 --> 00:15:04.871
blipped).. now it's over here in
the methods list and I can fire

00:15:04.871 --> 00:15:07.740
it to make sure it works. It
says owned. Awesome. If I come

00:15:07.740 --> 00:15:13.446
back over here and trace down
[indiscernible] here called

00:15:13.446 --> 00:15:16.983
licensing helper. And then a
Boolean value late license. I'm

00:15:16.983 --> 00:15:21.154
going to say replace method with
custom C sharp and it says

00:15:21.154 --> 00:15:27.160
[indiscernible]. Come here to
file export, export PDF and now

00:15:29.996 --> 00:15:36.002
I'm owned and I don't have a
license anymore. So that's

00:15:38.604 --> 00:15:42.241
attacking something before it's
been just in time compiled. If

00:15:42.241 --> 00:15:44.944
you want to attack something and
don't want to restart the

00:15:44.944 --> 00:15:48.414
application or wait, you can do
things at the machine cold

00:15:48.414 --> 00:15:53.419
level. In .NET there is far and
relative calls. You can take

00:15:53.419 --> 00:15:56.222
because I showed you how easy it
is to dump the may sheen code or

00:15:56.222 --> 00:16:01.127
overwrite it. Figure out what
call instructions is going to

00:16:01.127 --> 00:16:07.400
the method it's calling and
replace them and change them.

00:16:07.400 --> 00:16:11.270
This is a way to attack
something when you don't want to

00:16:11.270 --> 00:16:17.443
wait because you're lazy or want
to do it now. If we read the

00:16:17.443 --> 00:16:21.280
Intel manual that calculating a
relative call address at run

00:16:21.280 --> 00:16:24.517
time is little bit difficult.
But there is source code where

00:16:24.517 --> 00:16:28.821
you can read this and how I made
it easy with a simple method

00:16:28.821 --> 00:16:35.394
call. Now we get into actual
machine code payload. Utilizing

00:16:35.394 --> 00:16:38.564
reflection which name space
[indiscernible] allows you to

00:16:38.564 --> 00:16:43.069
see things like the assemblies,
the app domains and meta data

00:16:43.069 --> 00:16:46.339
about specific methods. One of
the things this lets us see is

00:16:46.339 --> 00:16:48.841
where the machine code is
..(audio blipped).. and

00:16:48.841 --> 00:16:56.415
unprotected in memory. We can
take it and change it. So we can

00:16:56.415 --> 00:17:00.186
create payloads to do things
like steal stack programmers. A

00:17:00.186 --> 00:17:04.223
method of interest that is
taking in a password. Steal the

00:17:04.223 --> 00:17:07.360
password and send it to email
server and return the password

00:17:07.360 --> 00:17:12.164
back to the application and you
stole stuff. A mouse click isn't

00:17:12.164 --> 00:17:20.072
a mouse click, it does other
things behind the Seans and then

00:17:20.072 --> 00:17:22.074
a mouse click. It's up to your
imagination. The most quick

00:17:22.074 --> 00:17:24.777
approaches is changing ..(audio
blipped).. and false to trues.

00:17:24.777 --> 00:17:30.716
Because developers are awesome
in they modulate code really,

00:17:30.716 --> 00:17:34.287
really well. So there is always
this low hanging branch of a

00:17:34.287 --> 00:17:37.957
return tree with a password or
license check. Password

00:17:37.957 --> 00:17:43.362
validation can be bypassed
easily. So can key and licensing

00:17:43.362 --> 00:17:45.364
validation. SQL sanitization can
be bypassed if it's returning

00:17:45.364 --> 00:17:47.633
down. Has this been sanitized
yet, yes or no. It has been,

00:17:47.633 --> 00:17:50.670
I'll pass it along to the
server. There can .NET security

00:17:50.670 --> 00:17:56.676
mechanisms that I won't name.
But you can rip them apart and

00:18:02.348 --> 00:18:05.985
destroy them and grab things off
the happy like agent, objects,

00:18:05.985 --> 00:18:11.457
et cetera, steal stack
parameters, do whatever and rip

00:18:11.457 --> 00:18:16.295
apart security at the assembly
level. And really we're

00:18:16.295 --> 00:18:19.498
overwriting logic and we're
hackers to update mechanisms are

00:18:19.498 --> 00:18:24.437
always juicy. Graphically this
looks like this. Assume you have

00:18:24.437 --> 00:18:28.574
this Boolean verified license
that takes parameters and checks

00:18:28.574 --> 00:18:34.013
for a valid license. After
produces assembly code that you

00:18:34.013 --> 00:18:36.682
don't want to disassemble,
return one and now the developer

00:18:36.682 --> 00:18:42.688
wrote return true. Let's demo.
I'm going to open gray dragon

00:18:49.228 --> 00:18:54.667
and Windows PowerShell ISC. It's
a scripting environment. You can

00:18:54.667 --> 00:18:59.739
ping level three which is not
going to work because I'm not

00:18:59.739 --> 00:19:04.510
connected to the DEFCON
wireless, because screw that. So

00:19:04.510 --> 00:19:09.548
I'll drag my cross hairs back
into that. It's a 32 bit

00:19:09.548 --> 00:19:14.253
application so I'll injects.
Here is gray storm, it's in the

00:19:14.253 --> 00:19:19.692
version 2.0 of the CLR. This is
running an older .NET version.

00:19:19.692 --> 00:19:22.762
Gray frost accounted for that.
Within this application there is

00:19:22.762 --> 00:19:25.664
a run script button. So I'm
going to find it. So I know that

00:19:25.664 --> 00:19:28.167
it's in this Microsoft
PowerShell GP PowerShell

00:19:28.167 --> 00:19:34.173
assembly. If I pivot down there
is this thing in PowerShell tab

00:19:38.010 --> 00:19:45.251
and it's void execute script. So
this method right here, if I

00:19:45.251 --> 00:19:49.221
dump the assembly is doing all
that manipulation to run

00:19:49.221 --> 00:19:52.692
whatever is in that text box, I
can look at the IL code, I can

00:19:52.692 --> 00:19:56.929
disassemble it if I want to. I
would have to inject B engine

00:19:56.929 --> 00:20:01.267
DLL which is an open-source
disassembly. I'm not going to go

00:20:01.267 --> 00:20:07.573
through this. You can do that.
I'm going to come here to show

00:20:07.573 --> 00:20:13.746
you how easy it is to roll a
meta exploit payload. I'm going

00:20:13.746 --> 00:20:17.416
to show you an alias called
DEFCON. It pops a calculator. I

00:20:17.416 --> 00:20:23.956
will run that and this takes
time because I'm encoding it and

00:20:23.956 --> 00:20:29.095
whatnot. Once it finishes I have
a payload that pops a

00:20:29.095 --> 00:20:35.968
calculator. I'll come over here
and drag over and copy it. I

00:20:35.968 --> 00:20:39.939
will come back over here to gray
storm. Go to the shell code tab

00:20:39.939 --> 00:20:42.675
which has a couple of payloads
that I'm including ..(audio

00:20:42.675 --> 00:20:46.045
blipped).. return false and
Miranda warnings SS calculator

00:20:46.045 --> 00:20:51.417
payload. I'm not going to use
that one. I come to the editor

00:20:51.417 --> 00:20:56.388
and paste the payload. I'm going
to name it DEFCON. And I create

00:20:56.388 --> 00:21:02.561
the shell code. DEFCON meta
exploit payload. I can say fire

00:21:02.561 --> 00:21:09.401
it. If I come here and I have
this execute script method

00:21:09.401 --> 00:21:15.074
selected and I say dump
assembly. That changed to the

00:21:15.074 --> 00:21:19.879
meta exploit payload. If I come
to Windows PowerShell and run

00:21:19.879 --> 00:21:22.915
script, I popped a calculator.
So that's utilizing machine code

00:21:22.915 --> 00:21:28.921
payloads. You can rule your own.
The most important thing to know

00:21:37.363 --> 00:21:40.399
if you want to use a meta
exploit payload or run your own

00:21:40.399 --> 00:21:46.739
there is a change that causes
headache. In the portable

00:21:46.739 --> 00:21:50.176
environment block. You need to
find out the base address of

00:21:50.176 --> 00:21:56.182
kernel 32 to get address and
load library. That is commonly

00:22:00.119 --> 00:22:04.924
the third entry in the memory
order module listing. However in

00:22:04.924 --> 00:22:08.961
.NET applications it's the
fourth. So you have to change

00:22:08.961 --> 00:22:12.398
your one line of code in the
payload to account for that

00:22:12.398 --> 00:22:16.569
dins. If you're using a meta
exploit payload make sure

00:22:16.569 --> 00:22:19.071
they're doing this otherwise
you're going to crash the target

00:22:19.071 --> 00:22:22.841
application and if you're doing
this on an enterprise level

00:22:22.841 --> 00:22:24.977
thing, you're going to have a
bad time and somebody is going

00:22:24.977 --> 00:22:32.852
to catch you. Object hunting and
memory. Now we attacked the just

00:22:32.852 --> 00:22:37.223
in time compiler. What about at
run time. What about getting

00:22:37.223 --> 00:22:41.827
things off the managed heap.
It's the storage point for all

00:22:41.827 --> 00:22:47.666
.NET run time objects such as
things that are instantiated by

00:22:47.666 --> 00:22:53.005
the application application and
the things that the user is

00:22:53.005 --> 00:22:58.077
doing. And occasionally remove
dead objects and make room. We

00:22:58.077 --> 00:23:00.846
don't care how it works, we're
going to manipulate the crap out

00:23:00.846 --> 00:23:05.217
of it. When we do object hunting
in memory, what we need to

00:23:05.217 --> 00:23:11.223
realize is that there's a lot of
pointers in .NET. And objects

00:23:13.993 --> 00:23:17.730
are actually pointers, an
instance of the object on the

00:23:17.730 --> 00:23:21.100
managed heap. This object
instance contains meta data

00:23:21.100 --> 00:23:25.004
about the object. What fields
and properties are currently set

00:23:25.004 --> 00:23:30.910
on it. A method table. This
method table tells the object

00:23:30.910 --> 00:23:34.213
instance what method
instantiated this thing and all

00:23:34.213 --> 00:23:37.082
objects of the same type share
the same method table. We'll

00:23:37.082 --> 00:23:39.118
utilize that in a signature.
We're going to utilize an object

00:23:39.118 --> 00:23:45.124
hunting signature that I created
and then we're going to win. In

00:23:53.866 --> 00:23:56.869
order to do this there is a
6-step methodology that you need

00:23:56.869 --> 00:24:00.139
to take as an attacker trying to
rip objects off the managed

00:24:00.139 --> 00:24:08.013
heap. It's inspired by the way
the volatility guys do pool

00:24:08.013 --> 00:24:11.984
scanning. Essentially ..(audio
blipped).. construct an object

00:24:11.984 --> 00:24:16.288
and find the location of the
managed heap. Reflection gives

00:24:16.288 --> 00:24:20.059
us the ability to look at what
address is machine code running

00:24:20.059 --> 00:24:23.162
at for a particular method. This
isn't the case with the managed

00:24:23.162 --> 00:24:26.665
heap and we need to do trickery
so tell us where it is at run

00:24:26.665 --> 00:24:33.939
time and construct a reference
object to figure out what the

00:24:33.939 --> 00:24:38.143
method table is for all of these
objects. Step two is we're going

00:24:38.143 --> 00:24:41.513
to signature that instantiated
type. Use a little bit of

00:24:41.513 --> 00:24:44.416
machine code to pars that
structure that the object

00:24:44.416 --> 00:24:48.287
instance is and rip off some
particular things that we

00:24:48.287 --> 00:24:53.492
..(audio blipped).. and step 3
is do a brute force approach to

00:24:53.492 --> 00:24:56.295
scan the managed heap for other
object pointers that are the

00:24:56.295 --> 00:24:59.965
same as this object we're
interested in. Step four is

00:24:59.965 --> 00:25:05.404
convert those objects into raw
objects. When you do this

00:25:05.404 --> 00:25:10.376
something cool happens. And
profit. So step one, construct

00:25:10.376 --> 00:25:14.246
an object. Essentially utilizing
reflection we're able to go

00:25:14.246 --> 00:25:16.949
through and pars through all of
the app domains and all of the

00:25:16.949 --> 00:25:21.553
constructors for a particular
class. We can ..(audio

00:25:21.553 --> 00:25:25.457
blipped).. out knowing anything
about it and instantiate

00:25:25.457 --> 00:25:28.427
anything. There is some objects
that will -- complex object

00:25:28.427 --> 00:25:35.067
types as arguments but we don't
really need to scare about that,

00:25:35.067 --> 00:25:37.169
we don't want to utilize this
object. ..(audio blipped).. have

00:25:37.169 --> 00:25:42.908
one to reference. So we can just
nullify all arguments in a

00:25:42.908 --> 00:25:50.382
constructor and we'll will able
to use it how we need to. So

00:25:50.382 --> 00:25:53.552
then what we're going do is once
we have an instantiated object

00:25:53.552 --> 00:25:57.122
we're going to build a stack
frame. You can see at the top of

00:25:57.122 --> 00:26:00.559
the diagram here that I have the
raw object that I just

00:26:00.559 --> 00:26:04.630
instantiated and it has a
pointer associated with it. This

00:26:04.630 --> 00:26:07.533
pointer is hidden behind the
Seans in the object type. So

00:26:07.533 --> 00:26:11.503
with a little bit of stack
manipulation. You can read the

00:26:11.503 --> 00:26:16.341
gist for this. We know that this
object points to the location of

00:26:16.341 --> 00:26:20.546
the managed heap which could be
anywhere. At the top, the

00:26:20.546 --> 00:26:25.517
bottom, in the middle which is
why we need to do a brute

00:26:25.517 --> 00:26:28.353
forcing approach in memory.
We're going to move that object

00:26:28.353 --> 00:26:31.890
down into the in pointer
location and we have the pointer

00:26:31.890 --> 00:26:36.929
to that object and the pointer
of the managed heap. Have an

00:26:36.929 --> 00:26:40.432
actual object created with an
address of the managed heap, we

00:26:40.432 --> 00:26:45.370
signature that instantiated
type. So object instances like I

00:26:45.370 --> 00:26:48.574
said contain a method table
pointer back to the type that

00:26:48.574 --> 00:26:53.846
instantiated them. In 32 bit
this is byte 033. So we grab

00:26:53.846 --> 00:26:59.084
that and also the instant size
of this objected. This allows us

00:26:59.084 --> 00:27:01.954
when going down the managed
heap, we don't need to do brute

00:27:01.954 --> 00:27:08.060
force by jumping 4 or 8 bits, we
can jump the size of each object

00:27:08.060 --> 00:27:13.565
to get to the bottom to save
time. A subtle different in 64

00:27:13.565 --> 00:27:17.302
bit. Primarily just the size of
the pointer. That is all taken

00:27:17.302 --> 00:27:22.141
care of as well. Now that we
have an object and signature it,

00:27:22.141 --> 00:27:27.546
we scan the managed heap. This
is somewhat of an approach to

00:27:27.546 --> 00:27:32.518
how the volatility guys do pull
tech scanning. They brute force

00:27:32.518 --> 00:27:37.055
through memory with a specific
structure and innumerate on the

00:27:37.055 --> 00:27:41.560
structure to make sure what
they're looking for matches the

00:27:41.560 --> 00:27:45.831
memory they found. I do this by
-- down the managed heap by the

00:27:45.831 --> 00:27:49.368
size of the object that I rip
off of each object's method

00:27:49.368 --> 00:27:54.840
table. Grab the instance size
off all of them and skin down.

00:27:54.840 --> 00:27:58.577
When I find one that matches, I
grab that pointer. I have a

00:27:58.577 --> 00:28:03.749
listing of all pointers of
objects that I care about. If I

00:28:03.749 --> 00:28:11.223
want to go up the managed heap,
I have to scan up it by 4 or 8

00:28:11.223 --> 00:28:15.093
increments and a little bit of
access violation errors. It's a

00:28:15.093 --> 00:28:19.965
decent signature now. If
somebody has a better approach,

00:28:19.965 --> 00:28:26.438
submit me a request and let's
make it better. Now other object

00:28:26.438 --> 00:28:31.310
pointers. Convert the object
pointers back to objects. Here

00:28:31.310 --> 00:28:37.015
is code to show this. There is
unsafe code that allows you to

00:28:37.015 --> 00:28:41.853
do pointer manipulation in .NET.
What a lot of people say is this

00:28:41.853 --> 00:28:46.391
is a compile check. If you're
compiling .NET and trying to do

00:28:46.391 --> 00:28:51.196
safe code, it's like that's not
cool. Are you sure. You have to

00:28:51.196 --> 00:28:56.435
allow it. In memory where this
didn't allow the compile time,

00:28:56.435 --> 00:29:01.540
it doesn't matter because it's
not a run time check so who

00:29:01.540 --> 00:29:06.244
cares. We're building a stack
again, the reference object that

00:29:06.244 --> 00:29:08.981
we're putting pointers back to.
And then we have an address that

00:29:08.981 --> 00:29:13.619
we grabbed off of the managed
heap to another object. All

00:29:13.619 --> 00:29:19.858
we're going to do is move the
pointer lower on the stack and

00:29:19.858 --> 00:29:24.663
put it over that reference. And
then what's magic about .NET is

00:29:24.663 --> 00:29:28.500
when you give an object, a
pointer to another object, it

00:29:28.500 --> 00:29:32.104
will reference the instantiated
object for you and now you have

00:29:32.104 --> 00:29:35.540
a new reference to something
that was on the managed heap.

00:29:35.540 --> 00:29:38.910
This is how we can go through
and instantiate an object and

00:29:38.910 --> 00:29:42.848
scan for all other objects of
that type and utilize them. Now

00:29:42.848 --> 00:29:49.121
we will learn all the things
about the application. So what

00:29:49.121 --> 00:29:51.990
I'm going to do is open up a
fingerprint reader software that

00:29:51.990 --> 00:29:56.194
is sent on all laptops of a
specific manufacturer that won't

00:29:56.194 --> 00:30:02.200
be named. Inject gray frost. And
open up gray storm. So now what

00:30:04.770 --> 00:30:08.240
I'm doing is I'm going to open
up the GUI more. I'm not a GUI

00:30:08.240 --> 00:30:12.310
developer. I'm a hacker. The GUI
is not too great. But

00:30:16.815 --> 00:30:19.851
essentially this method editor
functionality, it shows all

00:30:19.851 --> 00:30:24.523
objects and instance methods and
fields and properties and on the

00:30:24.523 --> 00:30:27.492
left the QLCLR user class and
constructor. The constructor is

00:30:27.492 --> 00:30:29.494
taking two complex object types,
a passport and -- object. Like I

00:30:29.494 --> 00:30:31.496
said you can nullify those. I
added two nulls and called that

00:30:31.496 --> 00:30:33.498
constructor. And you can see
this thing has a lot of instance

00:30:33.498 --> 00:30:39.504
methods. One of the instance
methods is get the Window's

00:30:47.713 --> 00:30:54.653
password in plain text text. I
hit get all objects. I didn't

00:30:54.653 --> 00:30:58.724
get an object. That's because I
haven't validated that I am who

00:30:58.724 --> 00:31:03.628
I say I am. I swiped my finger
and logged in. I'm calling that

00:31:03.628 --> 00:31:07.999
constructor. I get all objects
off the managed heap. I'll open

00:31:07.999 --> 00:31:14.840
QLCLR user and go to the
properties field and you can see

00:31:14.840 --> 00:31:18.176
that I have a plain text system
plain text passwords and Hunger

00:31:18.176 --> 00:31:21.713
Games rocks. Now we have all of
the superpowers and things.

00:31:21.713 --> 00:31:28.153
Never before have we been able
to go through the managed heap

00:31:28.153 --> 00:31:34.092
and grab objects that we're
interested in. We can go through

00:31:34.092 --> 00:31:39.464
and essentially construct any
object we want and grab any

00:31:39.464 --> 00:31:45.170
object we want of that type.
It's common that crypto objects

00:31:45.170 --> 00:31:50.375
have in a field or a property,
the key that is being used. The

00:31:50.375 --> 00:31:54.079
salt that's being used. Go
through and find those things

00:31:54.079 --> 00:31:57.883
and then change them to keys
that you have so everything in

00:31:57.883 --> 00:32:03.221
the database is encrypted and
they can never access ..(audio

00:32:03.221 --> 00:32:07.292
blipped).. And of course those
instance ..(audio blipped).. you

00:32:07.292 --> 00:32:10.495
can go through and call them.
You can call them with arguments

00:32:10.495 --> 00:32:13.865
if you want to. Say in the
instance of that constructor it

00:32:13.865 --> 00:32:17.803
took two object types, you can
build a chain and build an

00:32:17.803 --> 00:32:21.807
object type and build an
argument path. The possibilities

00:32:21.807 --> 00:32:27.813
are endless and up to you. This
is a GUI. We're hackers, GUIs

00:32:30.248 --> 00:32:38.223
suck. All of these payloads can
be automated. So gray frost is

00:32:38.223 --> 00:32:40.992
just the injector platform, a
DLL. It doesn't map the payload.

00:32:40.992 --> 00:32:48.567
You can use a python script like
autofrost. Give it a C sharp

00:32:48.567 --> 00:32:51.937
payload with automation of
something behind the scans, and

00:32:51.937 --> 00:32:57.943
inject into a target application
and have it run. So automations

00:33:02.547 --> 00:33:06.184
is loved so I'm going to attack
that fingerprint reader and show

00:33:06.184 --> 00:33:11.156
you that I'm not crapping you
and you can automate stuff. I'm

00:33:11.156 --> 00:33:14.392
going to swipe my finger and
authenticate with this

00:33:14.392 --> 00:33:20.298
application. Grab gray dragon,
inject gray frost which is an

00:33:20.298 --> 00:33:24.803
automated version of the payload
and Hunger Games still rocks.

00:33:24.803 --> 00:33:30.809
When it comes down to
constructing attack chains, it's

00:33:35.180 --> 00:33:39.684
relatively easy to attack .NET
applications due to the nature

00:33:39.684 --> 00:33:45.724
of this just in time compilation
process. If you did .NET work or

00:33:45.724 --> 00:33:49.895
played with challenges such as
the FireEye challenge ..(audio

00:33:49.895 --> 00:33:53.465
blipped).. to recover keys, you
can just throw something into an

00:33:53.465 --> 00:34:01.072
ILD compiler and look at a
higher level C sharp source code

00:34:01.072 --> 00:34:05.010
experience because of how easy
it is to generate C sharp back

00:34:05.010 --> 00:34:09.481
from IL. You can utilize the
functionality to locate

00:34:09.481 --> 00:34:11.483
meaningful objects that you
might want to steal. And

00:34:11.483 --> 00:34:14.019
properties of interest that you
can attack at the machine code

00:34:14.019 --> 00:34:19.424
level or the just in time level.
There is debugging functionally

00:34:19.424 --> 00:34:25.430
in here. I'm giving you the
address of constructors and the

00:34:27.999 --> 00:34:34.272
address of methods that you're
interested in. You can take

00:34:34.272 --> 00:34:37.842
those and throw them in a
debuger and breakpoint them. In

00:34:37.842 --> 00:34:40.912
the case of the fingerprint
reader, I have no idea what

00:34:40.912 --> 00:34:46.651
triggered that object to appear
on the managed heap. So I --

00:34:46.651 --> 00:34:50.221
until something happened. If I
didn't do that, I would have

00:34:50.221 --> 00:34:54.592
never figured it out. This is
useful if you have time and you

00:34:54.592 --> 00:35:00.932
want to say this application, I
won't to upon it. This is a DLL,

00:35:00.932 --> 00:35:04.636
you can utilize something like
DLL hijacking and put this gray

00:35:04.636 --> 00:35:08.239
frost DLL on disk and every time
that application spins up

00:35:08.239 --> 00:35:12.744
..(audio blipped).. you don't
have to worry about things like

00:35:12.744 --> 00:35:16.348
attacking the just in time
compiler because it does it the

00:35:16.348 --> 00:35:23.655
second is loaded. Every time a
SQL object appears on the heap I

00:35:23.655 --> 00:35:28.593
want to grab it. You can do this
by placing a [indiscernible] and

00:35:28.593 --> 00:35:36.134
every single object on the
managed heap is yours. Opens up

00:35:36.134 --> 00:35:40.472
a whole new avenue of
hybridization. A lot of what I

00:35:40.472 --> 00:35:47.178
did when I manipulate the
managed heap is calling into raw

00:35:47.178 --> 00:35:52.784
machine code to pars all of
those structures. So you can now

00:35:52.784 --> 00:35:57.489
utilize this technique to do
even more complicated things

00:35:57.489 --> 00:36:00.959
that haven't been possible
before. You can also do things

00:36:00.959 --> 00:36:05.530
because we're at a higher level
coding space, then say C or

00:36:05.530 --> 00:36:09.234
machine code in that it's
incredibly easy to use crypto

00:36:09.234 --> 00:36:15.507
libraries. Encrypt the -- within
gray frost or the payload. Call

00:36:15.507 --> 00:36:18.643
off the web server and make
something superhard -- how easy

00:36:18.643 --> 00:36:22.247
it is to reverse .NET. Give them
hell. You can do this at the

00:36:22.247 --> 00:36:28.253
machine code level. Encrypt it,
do some sophisticated hackery

00:36:33.758 --> 00:36:37.495
techniques to make it hard to
find you and fire the payload.

00:36:39.831 --> 00:36:44.202
And then the payload system, why
use it. For starters C sharp is

00:36:44.202 --> 00:36:49.441
an incredibly easy language to
learn. None of these guys really

00:36:49.441 --> 00:36:54.145
understood the power of
reflection or there were

00:36:54.145 --> 00:36:59.884
pointers in the .NET framework.
It has easy to use C sharp and

00:36:59.884 --> 00:37:04.155
easy to build payloads and
malware in C sharp. Because of

00:37:04.155 --> 00:37:07.625
these techniques and the gray
frost platform you can run this

00:37:07.625 --> 00:37:12.564
in any application you want.
Because the gray frost DLL

00:37:12.564 --> 00:37:17.569
creates or injects the 4.0CLR
you can inject this thing into a

00:37:17.569 --> 00:37:23.641
python application and spin up
the .NET framework inside that.

00:37:23.641 --> 00:37:26.444
You may want to do that but the
really purpose is attacking .NET

00:37:26.444 --> 00:37:31.649
but that is cool and would blow
somebody's mind. The low and

00:37:31.649 --> 00:37:37.122
high level gap is relatively
easy. ..(audio blipped).. people

00:37:37.122 --> 00:37:42.494
that code in C sharp and in
assembly can drink beer together

00:37:42.494 --> 00:37:47.398
and be friends instead of hate
each other. Which I think is

00:37:47.398 --> 00:37:54.873
cool. You should get involved
with this .NET hacking space and

00:37:54.873 --> 00:38:02.647
read the code and contribute to
it. It's really small now. In

00:38:02.647 --> 00:38:06.251
the research I did, there were
hardly any tools that were

00:38:06.251 --> 00:38:10.054
reference able. Nobody was
attacking the managed heap. And

00:38:10.054 --> 00:38:14.425
most -- attacking world of
warcraft which on some of these

00:38:14.425 --> 00:38:18.997
forms people with getting owned
and pissed off and rage quitting

00:38:18.997 --> 00:38:22.367
because they invest in security.
And there are lots of PowerShell

00:38:22.367 --> 00:38:28.873
which is a subset of .NET. It's
cool and powerful but I think

00:38:28.873 --> 00:38:33.144
this has good practicality if
you want to get into this. A lot

00:38:33.144 --> 00:38:39.150
of this was inspired by previous
DEFCON talks. Especially 18 and

00:38:43.188 --> 00:38:46.457
19. I have shown you that
arbitrary .NET applications can

00:38:46.457 --> 00:38:51.629
be injected and changed at run
time and open up another avenue

00:38:51.629 --> 00:38:55.500
for .NET possibilities. These
tools support automation and

00:38:55.500 --> 00:38:58.937
they're on GitHub, ask me
questions. If you do have

00:38:58.937 --> 00:39:03.842
questions you can come up here
afterwards. I am around until

00:39:03.842 --> 00:39:09.847
tomorrow. I am dumb and got bad
flights. You can check in on

00:39:14.118 --> 00:39:18.089
Twitter. Thank you for
listening.

