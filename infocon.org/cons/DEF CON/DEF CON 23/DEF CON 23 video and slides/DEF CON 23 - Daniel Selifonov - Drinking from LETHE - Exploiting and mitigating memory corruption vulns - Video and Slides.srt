00:00:00.000 --> 00:00:06.273
All right. Good evening. Thank
you for joining me. I realize

00:00:06.273 --> 00:00:13.113
there are fun parties here at
Defcon at the start of evening.

00:00:13.113 --> 00:00:17.684
I'm going to be talking about
memory corruption

00:00:17.684 --> 00:00:23.390
vulnerabilities sort of history.
Strategy you can take from code

00:00:23.390 --> 00:00:27.961
execution exploits. And
basically extending the line of

00:00:27.961 --> 00:00:35.369
research has been done over the
last 20 years and where to go

00:00:35.369 --> 00:00:39.940
forward to make defense
straightforward and robust. Who

00:00:39.940 --> 00:00:48.515
am I? Day job I walk at the San
Francisco area. By night -- and

00:00:48.515 --> 00:00:54.788
usually disclaimer. These are
the opinion of the talk or my

00:00:54.788 --> 00:01:01.628
own they are not represented of
my employer. Show of hands. How

00:01:01.628 --> 00:01:07.901
many of you have written
programs c++? How many of you

00:01:07.901 --> 00:01:12.472
have written stash maxing
exploits. It's about two-thirds

00:01:12.472 --> 00:01:18.178
or so. Return to programming?
About a third. Advanced return

00:01:18.178 --> 00:01:23.884
to information disclosure.
Someone has his hand on and --

00:01:23.884 --> 00:01:29.022
well, done. So some
modifications. One of the things

00:01:29.022 --> 00:01:34.728
that sort of bothers me today is
vulnerability corruption. And

00:01:34.728 --> 00:01:40.434
vulnerabilities used for remote
exploits. Vvn doesn't seem to be

00:01:40.434 --> 00:01:46.139
changing that. Approximate
second thing there are a lot of

00:01:46.139 --> 00:01:52.412
better increasing tools. I think
there was a talk now about

00:01:52.412 --> 00:01:56.984
constraint searches over program
to find vulnerabilities. But

00:01:56.984 --> 00:02:01.555
also industrial bug hunting
running American fuzzy lob

00:02:01.555 --> 00:02:06.126
against your program. And
centralized exploit process goes

00:02:06.126 --> 00:02:11.832
from vulnerabilities to analyst
look at crash log and weaponize

00:02:11.832 --> 00:02:15.836
and work around anti
exploitation in software

00:02:15.836 --> 00:02:20.407
program. And there's not
economic insensitive to let

00:02:20.407 --> 00:02:25.545
vendors know that you found
vulnerabilities because you can

00:02:25.545 --> 00:02:31.818
sell exploits for of money. And
to my third part modification.

00:02:31.818 --> 00:02:38.091
Bug bounty is not effective.
There are people who will pay

00:02:38.091 --> 00:02:42.662
for weaponize exploits than
vendors. State agencies have

00:02:42.662 --> 00:02:50.671
limited budgets for these. And I
don't think we want to be in the

00:02:50.671 --> 00:02:55.242
reactive business finding
exploit and blacklisting it. I

00:02:55.242 --> 00:03:00.947
don't think it's worked out for
antivirus and for exploit

00:03:00.947 --> 00:03:06.653
markets as well. We should be
targeting supply rather than

00:03:06.653 --> 00:03:13.493
demands for exploits. So what's
the path that we should take for

00:03:13.493 --> 00:03:20.901
that. There have been plenty of
research for that in how to try

00:03:20.901 --> 00:03:27.174
to prevent memory corruption --
cpu overhead proven to be market

00:03:27.174 --> 00:03:32.879
acceptable. But maybe look at
other strategies for an attacker

00:03:32.879 --> 00:03:38.018
to achieve execution maybe in
the context of vulnerabilities.

00:03:38.018 --> 00:03:43.723
Why do we keep hitting these
types of vulnerabilities these

00:03:43.723 --> 00:03:49.429
class of attacks against our
program systems? Is there a

00:03:49.429 --> 00:03:54.568
fundamental blind spots that
encourage these types of issues?

00:03:54.568 --> 00:04:01.408
Defenses -- so we understand
where we came from and where to

00:04:01.408 --> 00:04:09.416
go forward. I'm going to take us
a bit of 20 year journey on

00:04:09.416 --> 00:04:13.987
major points of attack from
injection exploitation, class

00:04:13.987 --> 00:04:19.126
stack smashing defenses against
those such as none executable

00:04:19.126 --> 00:04:24.264
stacks. Code renew exploits.
Ccdm or return programming. The

00:04:24.264 --> 00:04:29.402
weaker mitigation we have
against that. Like standard --

00:04:29.402 --> 00:04:35.108
randomization on systems today
and then we will look over

00:04:35.108 --> 00:04:41.381
research last five years on
defense and attack. And i'll be

00:04:41.381 --> 00:04:48.221
showing out key enumeration, I
think we will make it a little

00:04:48.221 --> 00:04:53.360
bit more interesting from
defense standard point. So I

00:04:53.360 --> 00:05:00.767
think the main name of the game
fundamentally is we have a lack

00:05:00.767 --> 00:05:08.175
of memory safety. And when I say
memory safety I mean that we

00:05:08.175 --> 00:05:12.746
have program languages that
provide abstraction as software

00:05:12.746 --> 00:05:19.586
developer that -- problem we try
to solve as oppose to the

00:05:19.586 --> 00:05:22.989
underline system of
implementation of certain

00:05:22.989 --> 00:05:29.262
things. So we have notion of
variable that are separate from

00:05:29.262 --> 00:05:33.833
each other. Conceptually
separate from a programmer and

00:05:33.833 --> 00:05:40.106
thus we don't really think about
interaction between the two. We

00:05:40.106 --> 00:05:45.812
have assumption that the system
will not interact with the

00:05:45.812 --> 00:05:52.652
other. But the idealized case as
we know if we basically step

00:05:52.652 --> 00:05:58.358
through this code and look at
simplified version of stack

00:05:58.358 --> 00:06:04.631
looks like as we step through
the program we have return

00:06:04.631 --> 00:06:10.904
addresses to call functions. We
keep track of where we are

00:06:10.904 --> 00:06:16.042
executing, subroutines, we
allocate on the stacks we feed

00:06:16.042 --> 00:06:23.450
data in, call data in and we
follow this process where we run

00:06:23.450 --> 00:06:28.588
these functions stack as
manipulated in this way. And

00:06:28.588 --> 00:06:33.727
eventually we hit return,
everything is happy assuming no

00:06:33.727 --> 00:06:40.567
one writes more than 23 bits in
this program. Let's talk about

00:06:40.567 --> 00:06:45.705
code injection attacks in
general. For those who knows

00:06:45.705 --> 00:06:52.545
smash stacking this is old hat.
Execution unbound read in to. If

00:06:52.545 --> 00:06:59.386
we write zero to 22 character
plus terminator to three, we are

00:06:59.386 --> 00:07:03.957
fine. Nothing bad happens.
Design expectation of the

00:07:03.957 --> 00:07:10.797
program. If we write a little
bit more than that say 24

00:07:10.797 --> 00:07:19.372
through 28 bytes we are kind of
okay. Part of the a we have not

00:07:19.372 --> 00:07:26.780
broken the program. But if we as
an attacker choose to write more

00:07:26.780 --> 00:07:32.485
than that, we can eventually
overwrite the return address and

00:07:32.485 --> 00:07:38.191
at this point we have seized
control of the instruction

00:07:38.191 --> 00:07:43.330
pointer. Something we can do
classical smashing attack '96.

00:07:43.330 --> 00:07:48.468
We can actually load an
arbitrary called payload onto

00:07:48.468 --> 00:07:54.174
the stack and manipulate the
return address that we've placed

00:07:54.174 --> 00:08:01.581
here in this location, to point
to that shelf code. And we seize

00:08:01.581 --> 00:08:07.287
control program and running code
attack code has supplied. Game

00:08:07.287 --> 00:08:13.560
over. Bad news. Before that, I
will briefly divulge into work

00:08:13.560 --> 00:08:19.833
with this type of defense
standard point. If it would be

00:08:19.833 --> 00:08:26.673
nice to execute code on stack.
But let's look at what our

00:08:26.673 --> 00:08:32.379
capability are so far. Virtual
address, every program has its

00:08:32.379 --> 00:08:38.651
own what it believes to be
exclusive view of the address

00:08:38.651 --> 00:08:44.357
space of the computer. These are
virtualized by the operating

00:08:44.357 --> 00:08:50.630
system so when you dereference
an address in the process it

00:08:50.630 --> 00:08:54.634
goes through an address
translation address controlled

00:08:54.634 --> 00:09:02.041
by the operating system. If we
look at the binary for this and

00:09:02.041 --> 00:09:07.747
decompose it. It's decomposing
this way. And a 12-bit fragment.

00:09:07.747 --> 00:09:15.155
Intel the base pointer of this
is control -- and we use the

00:09:15.155 --> 00:09:21.995
first component as an offset
into this table to look up the

00:09:21.995 --> 00:09:27.133
page directory. And this page
directory entry container this

00:09:27.133 --> 00:09:33.973
address of a page table. We now
use the second decompose of

00:09:33.973 --> 00:09:40.246
virtual address to look at
offset for this table. And this

00:09:40.246 --> 00:09:46.519
page table entry points to the
base of the actual page,

00:09:46.519 --> 00:09:53.927
physical page in memory that we
care about and then we use this

00:09:53.927 --> 00:09:59.065
offset whatever the program is
interested. Transfer into the

00:09:59.065 --> 00:10:04.204
architecture assuming it's set
up appropriately. So the first

00:10:04.204 --> 00:10:10.477
20 bits here are virtual frame
number for convenience. And this

00:10:10.477 --> 00:10:17.317
is useful for other things. And
page table entries as I said

00:10:17.317 --> 00:10:23.022
basically since things are page
align the bottom 12 bits

00:10:23.022 --> 00:10:29.295
architecture will be zero. So
you don't need to store that.

00:10:29.295 --> 00:10:34.434
These lower bits are used for
alternative capabilities like

00:10:34.434 --> 00:10:39.572
setting permission bits or
tracking or if swapping an

00:10:39.572 --> 00:10:45.845
enable determine whether page is
in memory or out through memory

00:10:45.845 --> 00:10:52.685
press on the system. And the
thing is you don't actually do

00:10:52.685 --> 00:10:57.257
this virtual to physical
translation process every time

00:10:57.257 --> 00:11:03.530
you want to do a memory access
because there's three memory

00:11:03.530 --> 00:11:08.668
access for every one your
virtual address space represents

00:11:08.668 --> 00:11:14.941
which can be a lot of overhead
so this translation cache

00:11:14.941 --> 00:11:20.647
translation buffer -- processing
unit and it takes the virtual

00:11:20.647 --> 00:11:26.352
number. It does the translation
process where the page is

00:11:26.352 --> 00:11:30.924
located in memory. And then
determines the effective

00:11:30.924 --> 00:11:37.196
permission. Is it a writable
which are the two permission bit

00:11:37.196 --> 00:11:42.902
in the previous slides and store
those three things together,

00:11:42.902 --> 00:11:48.041
virtual, physical and algorithm
permissions. And so there's a

00:11:48.041 --> 00:11:52.612
really awesome team, students
anonymous team called pack

00:11:52.612 --> 00:11:58.885
looked at this and say hey, on
the intel architecture there's

00:11:58.885 --> 00:12:04.023
translation buffer for both
instructions and data. And it

00:12:04.023 --> 00:12:11.431
turns out these are only filled
based on the type of access you

00:12:11.431 --> 00:12:19.439
have as a program. So if you are
doing data access, the data will

00:12:19.439 --> 00:12:25.144
be filled but instruction might
not have mapping. So they

00:12:25.144 --> 00:12:32.552
realize if they are clever about
it and able to default in a

00:12:32.552 --> 00:12:38.825
control way as the operating
system, they would be able to

00:12:38.825 --> 00:12:43.396
emulate of executable pages not
previously available to

00:12:43.396 --> 00:12:49.669
architecture. They would set the
supervisor bit on the page table

00:12:49.669 --> 00:12:54.807
entry. So the operating system,
process memory management unit

00:12:54.807 --> 00:13:02.215
will try to access the page will
fail. I'm running on user mode

00:13:02.215 --> 00:13:08.488
and not allowed to do that.
Interrupt the handler will take

00:13:08.488 --> 00:13:15.328
a look and see what's going on.
For example we have some

00:13:15.328 --> 00:13:21.034
instruction pointer and try to
access this yellow, orange page.

00:13:21.034 --> 00:13:27.874
This is basically a data access
and we have a pseudo code

00:13:27.874 --> 00:13:33.579
strategy if it's a supervisor
page and endpointer on the

00:13:33.579 --> 00:13:39.852
faulty page, otherwise what they
end up doing was they actually

00:13:39.852 --> 00:13:46.693
flip the blue bit to zero. To
user page. They allow one

00:13:46.693 --> 00:13:52.398
instruction to proceed in the
user program. Which would create

00:13:52.398 --> 00:13:57.537
this entry say this orange
virtual address correspond to

00:13:57.537 --> 00:14:03.810
some user address. And then they
would immediately trap again and

00:14:03.810 --> 00:14:11.818
reset that blue bit back to one
the page table versus tlb -- the

00:14:11.818 --> 00:14:17.523
process only cares about tlb on
substance sequence access, we

00:14:17.523 --> 00:14:24.363
have access on orange and I'm
not doing the expensive look up 

00:14:24.363 --> 00:14:30.636
for the page table hierarchy. If
later on orange pointer trying

00:14:30.636 --> 00:14:36.342
to access an orange page,
there's no itlb entry. The

00:14:36.342 --> 00:14:43.750
processor again, not allowed to
do that. And go to -- now it's

00:14:43.750 --> 00:14:50.022
an instruction page and [
inaudible ] so it will terminate

00:14:50.022 --> 00:14:55.728
the process. Memory access
violation and we don't want to

00:14:55.728 --> 00:15:02.568
allow that. Basically the whole
point is we want to make sure

00:15:02.568 --> 00:15:07.707
instruction tlb entry created
for that virtual address that

00:15:07.707 --> 00:15:13.412
permits access. So this is
implemented as a linux module

00:15:13.412 --> 00:15:18.551
and then shortly thereafter 2003
and 04, processor manufacturer

00:15:18.551 --> 00:15:25.391
extended the memory model to
support x bits. So amd calls x

00:15:25.391 --> 00:15:31.097
bits intel x bits it's
implemented the exact same way.

00:15:31.097 --> 00:15:37.937
This is in hardware now. It's
been in hardware since the last

00:15:37.937 --> 00:15:43.643
ten years. Your system supports
it probably. So we basically

00:15:43.643 --> 00:15:50.483
move from the situation where we
had user pages. We had the

00:15:50.483 --> 00:15:56.189
ability read and execute pages
or read, write, execute pages

00:15:56.189 --> 00:16:01.327
basically wide open. By adding
supervisor based emulating of

00:16:01.327 --> 00:16:06.465
none executable -- we actually
gain this additional dimension

00:16:06.465 --> 00:16:11.604
of control page permission and
more expressive power. Almost

00:16:11.604 --> 00:16:19.011
data and we don't want to treat
as code. But obviously the story

00:16:19.011 --> 00:16:25.852
doesn't end there. We doesn't
end that with packs or x bits.

00:16:25.852 --> 00:16:31.557
So attacker evolved to using
code strategy. Returned to c.

00:16:31.557 --> 00:16:38.965
This is a model another view of
stack smash. You can't do this

00:16:38.965 --> 00:16:43.536
anymore. When the processor
actually instructor pointer goes

00:16:43.536 --> 00:16:50.943
into stack it's no longer permit
to do that by the memory access

00:16:50.943 --> 00:16:57.216
unit. We can't do this as
attacker. We can still corrupt

00:16:57.216 --> 00:17:01.787
attack overflow, and put
arbitrary value into protocol

00:17:01.787 --> 00:17:08.628
system paths. So instead of
putting an address to a piece of

00:17:08.628 --> 00:17:16.035
code that we've injected instead
we can do put the address to say

00:17:16.035 --> 00:17:21.173
mc system call. Which takes a
single command-line, single

00:17:21.173 --> 00:17:26.879
parameter serves as command-line
parameter. In this case we are

00:17:26.879 --> 00:17:34.287
asking the system to run a bash.
This view is difficult to via

00:17:34.287 --> 00:17:39.992
it's basically a damaged memory
space. But look from a

00:17:39.992 --> 00:17:45.131
perspective of what system to
use, it's used reasonable

00:17:45.131 --> 00:17:51.404
function called it has some say
return address that we don't

00:17:51.404 --> 00:17:57.677
care about while we are
executing system and we have a

00:17:57.677 --> 00:18:03.950
parameter before the return
address which is a pointer to a

00:18:03.950 --> 00:18:10.222
string which has been bashed and
variable that needs to be

00:18:10.222 --> 00:18:15.361
allocated from the presser. It
doesn't matter from attacker

00:18:15.361 --> 00:18:21.067
standpoint. You can't function
more than one function but it

00:18:21.067 --> 00:18:28.474
gives you idea this is how to do
this attacks. The technique was

00:18:28.474 --> 00:18:34.180
generalized ten years later with
a notion of return programming

00:18:34.180 --> 00:18:41.587
and the idea is instead of
having a full lip c function you

00:18:41.587 --> 00:18:46.726
are calling, you are looking for
machine fragments that's

00:18:46.726 --> 00:18:52.431
succeeded with return function.
And you can compose them however

00:18:52.431 --> 00:18:58.137
you want to achieve whatever
stack manipulation. If you look

00:18:58.137 --> 00:19:04.410
at the bottom here, we can
rebalance the stack with extra

00:19:04.410 --> 00:19:09.548
arguments. And actually invoke
more than one gadget which

00:19:09.548 --> 00:19:16.389
resembles looking stack. So in
2003 sort of in the realm of

00:19:16.389 --> 00:19:23.229
find a deal of return c even
though it's not generalized at

00:19:23.229 --> 00:19:28.934
the time. The pack team looked
at different approaches for

00:19:28.934 --> 00:19:34.073
preventing these return use code
attacks. We had developed

00:19:34.073 --> 00:19:38.644
position independent code
library and executables so we

00:19:38.644 --> 00:19:45.484
don't need to load them in fixed
address, we can load them

00:19:45.484 --> 00:19:51.190
arbitrarily. If where he shift
the stack and allocation a

00:19:51.190 --> 00:19:59.198
little bit shift the location of
our key a little bit and we load

00:19:59.198 --> 00:20:05.471
the program codes in arbitrary
offset and order then we can

00:20:05.471 --> 00:20:12.311
limit the ability of attacker to
know ahead of time where the

00:20:12.311 --> 00:20:18.017
interesting addresses are for
them. So this was sort of,

00:20:18.017 --> 00:20:24.857
caveat to this version we don't
think it's fully capable -- so

00:20:24.857 --> 00:20:32.865
let's look at couple of ways to
work around this. So one of the

00:20:32.865 --> 00:20:39.138
things is if you have ability to
disclose memory of particular

00:20:39.138 --> 00:20:45.411
library that you are interested
in then you can actually recover

00:20:45.411 --> 00:20:51.684
the offset of everything that
you might be interesting as an

00:20:51.684 --> 00:20:57.957
attacker. So for example if
system live at offset 23 within

00:20:57.957 --> 00:21:05.364
the linery and print f live at
library beginning of lip c and

00:21:05.364 --> 00:21:12.771
you discovered print f is [
inaudible ] this then you as an

00:21:12.771 --> 00:21:19.612
attacker know the lay out of c
knows the system function volt.

00:21:19.612 --> 00:21:25.885
You can use this again accept
your gadget chain, deliver same

00:21:25.885 --> 00:21:30.456
type of exploit strategy.
Therefore couple of research

00:21:30.456 --> 00:21:36.162
paper came out which looked at
couple of more sophisticated

00:21:36.162 --> 00:21:43.002
means of permitting the address
state. So one of them is saying

00:21:43.002 --> 00:21:50.409
a little bit randomness is good
and let's add more. Let's do at

00:21:50.409 --> 00:21:56.115
the function level or basic
block level. More recent paper

00:21:56.115 --> 00:22:01.821
just does address -- effectively
complete. You are doing alpha

00:22:01.821 --> 00:22:06.959
equivalent. This is absolutely
equivalent code map them to

00:22:06.959 --> 00:22:10.963
internal address Nebraska
anyway. There's another paper.

00:22:10.963 --> 00:22:16.669
Observe the -- techniques are
not significant value. Okay. The

00:22:16.669 --> 00:22:23.509
whole point is you want to
reduce the value of a single

00:22:23.509 --> 00:22:28.647
pointer from the attacker
perspective. Because if they get

00:22:28.647 --> 00:22:34.353
one pointer then they know
everything in your library but

00:22:34.353 --> 00:22:41.760
the whole point for this is you
may learn one address but it

00:22:41.760 --> 00:22:47.466
doesn't mean it will teach you
multiple addresses in your

00:22:47.466 --> 00:22:54.306
library or program space. So
what they did is let's say they

00:22:54.306 --> 00:22:58.877
find address they observe
interesting fact. The first

00:22:58.877 --> 00:23:06.885
thing is if they chop off the or
zero off the bottom bit they

00:23:06.885 --> 00:23:12.591
know they have 4-kilobyte of
code address space. What they

00:23:12.591 --> 00:23:18.864
then did at runtime they would
disassemble this page and look

00:23:18.864 --> 00:23:25.137
for assembly page absolutely
call offset. In this case [ on

00:23:25.137 --> 00:23:30.843
screen ] they would find some
handful of absolute addresses.

00:23:30.843 --> 00:23:36.548
So they can repeat this process.
They would find another

00:23:36.548 --> 00:23:42.821
4-kilobyte line page and they
can repeat this page over and

00:23:42.821 --> 00:23:47.960
over again until they've
exhaust. They would find 2-300

00:23:47.960 --> 00:23:52.531
through this process.
1-3-megabyte of machine code and

00:23:52.531 --> 00:23:58.237
they do a gadget research in
realtime and compile payload

00:23:58.237 --> 00:24:03.375
objective to gadgets they
discovered in realtime. So it

00:24:03.375 --> 00:24:09.648
was game over. I've implemented
a version of this. Has the

00:24:09.648 --> 00:24:14.787
ability to basically wipe out
any randomization you are

00:24:14.787 --> 00:24:21.627
interested in doing. So the
value of one pointer is still a

00:24:21.627 --> 00:24:28.467
lot, one pointer -- and fine
grain doesn't seem to help this

00:24:28.467 --> 00:24:34.740
problem at all. But it's kind of
interesting still because when

00:24:34.740 --> 00:24:38.744
you introduce fine grain
randomization you actually

00:24:38.744 --> 00:24:45.017
change the attacker posture a
little bit. They can't do their

00:24:45.017 --> 00:24:51.857
work ahead of time, gadget work
ahead of time find exploits and

00:24:51.857 --> 00:24:58.130
chain the gadgets. Because there
are not going to be predictable

00:24:58.130 --> 00:25:03.268
location or value. So that's
important. Because that will

00:25:03.268 --> 00:25:09.541
give us as a defender an
interesting advantage. If we can

00:25:09.541 --> 00:25:13.545
maintain that information
asymmetry the attacker doesn't

00:25:13.545 --> 00:25:18.684
know enough information they
can't readjust gadget chain or

00:25:18.684 --> 00:25:23.255
achieve arbitrary code
execution. So I will do

00:25:23.255 --> 00:25:27.826
digression of c++. Apparently
class. Animals has virtual

00:25:27.826 --> 00:25:34.099
function called feeding a sound.
And let's also imagine that we

00:25:34.099 --> 00:25:39.238
have two subclass, a dog and cat
slightly different

00:25:39.238 --> 00:25:43.242
implementation like making a
sound. Fundamentally every

00:25:43.242 --> 00:25:48.380
single one of these virtual
functions are single pointers

00:25:48.380 --> 00:25:54.086
that are sufficient to execute
just in time return rate

00:25:54.086 --> 00:26:00.359
programming exploitation phase.
So we want to be able to avoid

00:26:00.359 --> 00:26:07.199
that. And here's an interesting
idea I came up with. I don't

00:26:07.199 --> 00:26:12.337
know how practical but worth
considering. Rather than having

00:26:12.337 --> 00:26:18.043
a fix virtual function table for
animal, for instance animals

00:26:18.043 --> 00:26:24.883
that we actually expand the size
of the table by parameter and

00:26:24.883 --> 00:26:31.156
sort of raise the uncertainty
for an attacker. We may have

00:26:31.156 --> 00:26:36.862
real function at particular
offset. Table just index look up

00:26:36.862 --> 00:26:43.702
for it. Ten times bigger or more
it doesn't matter. But awesome

00:26:43.702 --> 00:26:49.975
of these things can be unmap
memory. You cannot read, write

00:26:49.975 --> 00:26:55.681
them any result for that will
result in-system crash. So

00:26:55.681 --> 00:26:59.685
probablistic approach
programming. I didn't take this

00:26:59.685 --> 00:27:05.390
approach very far because I
think there are other issues

00:27:05.390 --> 00:27:11.096
with it but it's something to
think about. Another alternative

00:27:11.096 --> 00:27:18.504
is to actually make the pointer
more opaque not as useful to the

00:27:18.504 --> 00:27:25.344
attacker. So for example if the
attacker know this page maybe we

00:27:25.344 --> 00:27:31.617
can stop them at this stage
disassemble it. They need to

00:27:31.617 --> 00:27:36.755
access that page as data,
different operation than access

00:27:36.755 --> 00:27:43.595
the page code for instruction
fetches and this is quite a few

00:27:43.595 --> 00:27:50.435
what pack did but sort of
sideways. So can we do a

00:27:50.435 --> 00:27:56.141
splitting like pack did to do
something like this? Maybe.

00:27:56.141 --> 00:28:01.280
There's rootkit before. Which
used this very, very symmetric

00:28:01.280 --> 00:28:06.985
to hide the contents of the
rootkits code pages from

00:28:06.985 --> 00:28:10.389
operating system memory
scanning. Unfortunately you

00:28:10.389 --> 00:28:14.960
can't actually do splitting.
Intel process produced last

00:28:14.960 --> 00:28:19.531
seven years they made
fundamental changes. There's a

00:28:19.531 --> 00:28:25.804
second level which is not
agnostic to data. So you can't

00:28:25.804 --> 00:28:32.644
do the same trick that pack's
did. What one hands take intel

00:28:32.644 --> 00:28:39.484
another give it back, and we
have an option of extending the

00:28:39.484 --> 00:28:44.623
page table and these are
designed to hypervisor so

00:28:44.623 --> 00:28:49.761
accelerate to physical address
in translation. Almost the same

00:28:49.761 --> 00:28:54.900
process for operating system for
physical translation it's just

00:28:54.900 --> 00:29:01.740
another layer for it. It turns
out for some bazaar reason, they

00:29:01.740 --> 00:29:06.311
added explicit control of
reading writing and executing

00:29:06.311 --> 00:29:13.719
code on table. And there's a
talk by Jacob said that you can

00:29:13.719 --> 00:29:19.424
use atp basically same with
shadow walker. It's really cool.

00:29:19.424 --> 00:29:25.130
And let me circle back the
necessary versus the sufficient

00:29:25.130 --> 00:29:33.138
thing. We know that if we have
no slr the attacker will know to

00:29:33.138 --> 00:29:37.709
achieve exploitation. No need to
runtime discovery. Adversary

00:29:37.709 --> 00:29:43.982
needs to know the runtime of
offset. And they actually need

00:29:43.982 --> 00:29:51.990
to do a lot of work. And if we
can kill that runtime making

00:29:51.990 --> 00:29:56.561
beiges not readable but
executable or otherwise offense

00:29:56.561 --> 00:30:01.700
indicate the point, we can
actually prevent attacker from

00:30:01.700 --> 00:30:07.406
gaining the information they
need to achieve a dynamic the

00:30:07.406 --> 00:30:11.977
exploits. The ultimately two
reasons fine grain randomization

00:30:11.977 --> 00:30:17.683
hasn't been widely deployed. If
you read the academic paper,

00:30:17.683 --> 00:30:23.955
it's interesting. The thing that
they are not saying is every

00:30:23.955 --> 00:30:29.094
time you do fine grain
randomization you share code

00:30:29.094 --> 00:30:35.367
pages. You lose the advantages
of shared library which is is

00:30:35.367 --> 00:30:42.207
big deal. Lip c let's say 2
megabytes of code across 200

00:30:42.207 --> 00:30:49.047
processes if you are able to
save that there's [ inaudible ]

00:30:49.047 --> 00:30:55.887
savings and that's just one more
library saving. When you give up

00:30:55.887 --> 00:31:01.026
at wholesale, running the
typical system grows. This is

00:31:01.026 --> 00:31:06.732
the main reason beyond just the
difficulty of what security

00:31:06.732 --> 00:31:13.004
advantages give us why we have
not deplore that. Another, they

00:31:13.004 --> 00:31:19.277
took that we were able to share
the library executable object

00:31:19.277 --> 00:31:26.118
level because we have the notion
of independent code. And we do

00:31:26.118 --> 00:31:30.122
that through layers of
interaction, procedure leakage

00:31:30.122 --> 00:31:36.394
table and global offset table.
We can probably do the exact

00:31:36.394 --> 00:31:43.235
same thing. So they said okay.
Page 86 kilobytes. So break that

00:31:43.235 --> 00:31:48.940
into that chunk. Position them
relative in each other. The

00:31:48.940 --> 00:31:54.646
trick they use is reusing the
remanence of segmentation still

00:31:54.646 --> 00:32:00.352
available 64 intel architecture
to segment register. So you can

00:32:00.352 --> 00:32:07.759
have this piece of assembly code
that I have on the left which

00:32:07.759 --> 00:32:15.167
has a call to some offset ss
segment. And this fs segment can

00:32:15.167 --> 00:32:20.872
be located and specified random
location and address space and

00:32:20.872 --> 00:32:27.145
within that you have the real
addresses that you are jumping

00:32:27.145 --> 00:32:33.418
to. So the right, called rattle
is process specific but quite

00:32:33.418 --> 00:32:40.258
small. Might be a couple pages.
But the 4 kilobytes the library

00:32:40.258 --> 00:32:45.964
code in total random virtual
space but shared across physical

00:32:45.964 --> 00:32:51.670
address spaces. And so finally
circling around the work I've

00:32:51.670 --> 00:32:57.943
been doing the last year. Since
extended page tables provide us

00:32:57.943 --> 00:33:03.081
method to extend the memory
capabilities of the intel

00:33:03.081 --> 00:33:08.787
architecture model I grabbed an
off the shelf hypervisor xen

00:33:08.787 --> 00:33:13.925
4.4. Which is commonly used.
They introduced para virtualized

00:33:13.925 --> 00:33:20.198
hardware plus memory access. So
prior to this is pv mode

00:33:20.198 --> 00:33:25.337
emulated the physical frame the
operating system sought, machine

00:33:25.337 --> 00:33:31.610
frame translation. Ept the whole
point for this task. Since ept

00:33:31.610 --> 00:33:36.748
expose directly we can modify
version of xen, hypervisor,

00:33:36.748 --> 00:33:43.021
extend tables for me when we
receive and protect call and

00:33:43.021 --> 00:33:48.727
system calling lin induction
when those are requested. And in

00:33:48.727 --> 00:33:54.432
its current handler and reinject
as handler in linux operating

00:33:54.432 --> 00:34:00.705
system. So this basically from
that point onward it looks like

00:34:00.705 --> 00:34:07.545
a violation to platform and be
like this program has done some

00:34:07.545 --> 00:34:12.684
weird process and funky,
whatever it happens to be

00:34:12.684 --> 00:34:17.255
operating system doesn't care
it's actually software and

00:34:17.255 --> 00:34:22.394
terminate the program like it's
any other page related

00:34:22.394 --> 00:34:28.667
violation. There's couple of
caveats used for this which I go

00:34:28.667 --> 00:34:36.074
in a lot more details in my
white paper over here. The other

00:34:36.074 --> 00:34:43.481
component is very simple fine
grain that I added to lvm is a

00:34:43.481 --> 00:34:48.620
fairly long standing process
modular for c++, subjective c

00:34:48.620 --> 00:34:53.758
whatever language you might be
interested in. In intermediate

00:34:53.758 --> 00:34:59.464
form and is then compiled to
machine architecture you might

00:34:59.464 --> 00:35:06.871
be interested in. So all these
of these zone, the front ten any

00:35:06.871 --> 00:35:13.144
of the automatization you can
plug in whatever you want. I

00:35:13.144 --> 00:35:19.985
added a simple code to 64 bits,
32 and 64 realistically intel

00:35:19.985 --> 00:35:25.123
architecture. Beginning of every
function and every basic call

00:35:25.123 --> 00:35:31.963
received if you leak through v
table or examine the stack in

00:35:31.963 --> 00:35:38.236
detail you are still not going
to know the exact subdivisions

00:35:38.236 --> 00:35:46.244
and I chose 2 bits of entry you
can actually get away of entropy

00:35:46.244 --> 00:35:54.252
here but why not two. So I'm
going to try to demo that and

00:35:54.252 --> 00:36:00.525
not blow up my system. First
showing off pages and the

00:36:00.525 --> 00:36:07.932
second. Let's see if I can do
that. Let's see the fine grain.

00:36:07.932 --> 00:36:15.340
That's less likely to blow up.
So I have a very simple c

00:36:15.340 --> 00:36:21.046
program here which is compute
factorial. It's on a single

00:36:21.046 --> 00:36:26.184
giant ant. But very, very
straightforward, very simple. I

00:36:26.184 --> 00:36:33.591
run the process on it and I have
it spit out the disassembled

00:36:33.591 --> 00:36:41.599
version of this machine. And if
we look at it this is just a

00:36:41.599 --> 00:36:46.738
factorial and other things I
stripped output. There's added.

00:36:46.738 --> 00:36:53.011
This function is very simple. It
doesn't have return edges. This

00:36:53.011 --> 00:36:59.284
is only place with inversion is
possible. It lets you minimize

00:36:59.284 --> 00:37:03.855
the overhead introduced around
hot loop these particular

00:37:03.855 --> 00:37:10.695
addresses are not going to leak
where attacker might be able to

00:37:10.695 --> 00:37:15.834
examine them. Main looks
complicated because it has bunch

00:37:15.834 --> 00:37:21.539
of call key function call
instruction. So beginning it has

00:37:21.539 --> 00:37:28.379
two knobs. It has the one after
factorial. Two noob after this

00:37:28.379 --> 00:37:35.220
one and it's got three noobs
after this one. If you have

00:37:35.220 --> 00:37:40.358
execute only page it is
sufficient level of complexity

00:37:40.358 --> 00:37:46.631
to be randomization to be
effective. You don't need to go

00:37:46.631 --> 00:37:53.471
super crazy. You can do simple
route men tri strategy for this.

00:37:53.471 --> 00:37:59.744
I can run it in slightly
different outputs. And now it

00:37:59.744 --> 00:38:06.584
has two at the beginning of
this. The other one is slight

00:38:06.584 --> 00:38:12.290
risk of crashing the system. So
again straightforward. You have

00:38:12.290 --> 00:38:19.130
a program to print out. I have
stupid food function. It does

00:38:19.130 --> 00:38:25.403
something so it does get
optimize out. And in the main

00:38:25.403 --> 00:38:31.676
function I'm calling fo, and I'm
retrieving the address of that

00:38:31.676 --> 00:38:39.083
function and dumps out and I
mark the page again 12 bits all

00:38:39.083 --> 00:38:46.491
knocked out and I do page size
of exact, only permission. I try

00:38:46.491 --> 00:38:53.331
executing foo again to make sure
it's still work and hex again

00:38:53.331 --> 00:39:00.171
and it should fail and not reach
the print statement. Nice. So

00:39:00.171 --> 00:39:06.444
again we can see we have a
couple of statements, machine

00:39:06.444 --> 00:39:12.150
code coming out return
instruction at the very end. We

00:39:12.150 --> 00:39:19.557
mark it executable. We can still
run it. But we attempt to read

00:39:19.557 --> 00:39:25.263
it and we get fault.
Segmentation volt. So that's the

00:39:25.263 --> 00:39:32.103
demo. It didn't blow up. [
applause ] the demo gods are

00:39:32.103 --> 00:39:37.809
pleased. Couple of closing
thoughts before we finish up. I

00:39:37.809 --> 00:39:45.216
have couple of take aways. The
main one we should be able to

00:39:45.216 --> 00:39:50.355
take full advantage of the
memory permission model. We

00:39:50.355 --> 00:39:54.926
shouldn't arbitrary restrict
ourselves to intel provided as

00:39:54.926 --> 00:40:00.064
the default architecture. We
should begin where we have

00:40:00.064 --> 00:40:05.770
constant data just readable.
Which we have already. We should

00:40:05.770 --> 00:40:12.043
maintain our region read and
write data and not as executable

00:40:12.043 --> 00:40:18.316
code. And shift from having our
library program code being read

00:40:18.316 --> 00:40:24.022
executable to just executable
and there are some issues doing

00:40:24.022 --> 00:40:28.593
this especially around switches
and couple other construct.

00:40:28.593 --> 00:40:34.866
Pressure to do none readable
pages. We should not be using

00:40:34.866 --> 00:40:41.139
read write execute model. I
don't know what the other three

00:40:41.139 --> 00:40:49.147
might be useful for but what we
have [ inaudible ] -- and the

00:40:49.147 --> 00:40:57.155
other thing is I think we might
want to change a little bit how

00:40:57.155 --> 00:41:02.860
we do software packaging and
distributions because if we can

00:41:02.860 --> 00:41:07.999
say transmit our operating
system distribution as bit code

00:41:07.999 --> 00:41:14.839
as final machine code, it gives
us an opportunity to say boot

00:41:14.839 --> 00:41:19.978
time service which imposes a
high quality randomization. We

00:41:19.978 --> 00:41:26.818
can generate that -- at boot
time. And we can further take

00:41:26.818 --> 00:41:33.658
advantage of a trick like oxy
moron to break them apart and

00:41:33.658 --> 00:41:37.061
impose still valuable
randomization without imposing

00:41:37.061 --> 00:41:42.200
memory cost. We ultimately have
three different objective for

00:41:42.200 --> 00:41:46.771
these representation. We want
repeatable designs across [

00:41:46.771 --> 00:41:52.477
inaudible ] operating system
distribution so we can look at

00:41:52.477 --> 00:41:58.750
binary, they haven't been
subverted and we want to be this

00:41:58.750 --> 00:42:05.022
to be repeatable. We want high
quality, unpredictable and do it

00:42:05.022 --> 00:42:11.295
so it's producible. You want
some sense from the user you

00:42:11.295 --> 00:42:17.001
want a process that you can
repeat. You want randomization

00:42:17.001 --> 00:42:23.274
service isn't backdoor. And if
we can add more entropy and

00:42:23.274 --> 00:42:30.114
randomness at low cost, we
should do it. And that's all I

00:42:30.114 --> 00:42:38.122
got. Are we putting code -- I'll
be putting out code in 2 weeks.

00:42:38.122 --> 00:42:44.962
But my white paper should be
online now. You can e-mail me

00:42:44.962 --> 00:00:00.000
here. That's all I got
[applause].

