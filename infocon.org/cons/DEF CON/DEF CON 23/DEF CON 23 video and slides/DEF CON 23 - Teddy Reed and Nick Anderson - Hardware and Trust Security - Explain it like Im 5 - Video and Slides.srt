00:00:00.033 --> 00:00:03.937
>> All right. Let's jump into
it. The reason we started this

00:00:03.937 --> 00:00:10.444
kind of talk, the reason we
submitted this talk like explain

00:00:10.444 --> 00:00:18.252
it like I'm five is because,
we're kind of into hardware

00:00:18.252 --> 00:00:24.258
security for protective
purposes. Are we up? Yay, no? We

00:00:26.326 --> 00:00:31.698
-- anything you want me to do?
Test this. Were in. I can put

00:00:31.698 --> 00:00:37.704
the seal back up, too. It's on.
It's off. It's on. It's off. All

00:00:41.041 --> 00:00:47.047
right. We saw a couple of talks
that are really deep. There's

00:00:50.484 --> 00:00:56.490
like four really -- not today
four this weekend that are

00:00:59.126 --> 00:01:04.564
really deep into hardware
security. Mostly around

00:01:04.564 --> 00:01:10.571
attacking this is DEF CON that
was Black Hat we're about

00:01:13.173 --> 00:01:16.443
attacking we like securing
things, so we wanted to give

00:01:16.443 --> 00:01:20.213
like introduction talk that
motivates everyone in the

00:01:20.213 --> 00:01:24.651
audience to learn about hardware
security and use that to build

00:01:24.651 --> 00:01:28.155
and secure mobile devices, the
general purpose machines that

00:01:28.155 --> 00:01:30.657
they have, all this IoT swag.
The main objective was kind of

00:01:33.160 --> 00:01:39.166
to simplify like this overly
somewhat complex explanations of

00:02:11.832 --> 00:02:16.203
hardware security by defining it
in the form of like building

00:02:16.203 --> 00:02:19.373
blocks. We'll talk about like
security primitives, hardware

00:02:19.373 --> 00:02:23.877
security primitives how each one
of those are used to build

00:02:23.877 --> 00:02:27.848
things like secure boot. >>
Nice. >> Want to start with our

00:02:27.848 --> 00:02:30.117
objectives for this
presentation. Then we'll start

00:02:30.117 --> 00:02:32.319
going into those building
blocks. Our objective was to

00:02:32.319 --> 00:02:34.755
kind of map hardware security
and the uses of hardware

00:02:34.755 --> 00:02:36.957
security to something everyone
is familiar with. Like defending

00:02:36.957 --> 00:02:40.127
a network service. Most of the
time we know how to defend this.

00:02:40.127 --> 00:02:42.129
We have authentication,
confidentiality like trust

00:02:42.129 --> 00:02:44.297
relationships. Those are the
things that we use to kind of

00:02:44.297 --> 00:02:46.967
protect the services and when we
try to build protections around

00:02:46.967 --> 00:02:49.169
those services our goals around
like isolating the application

00:02:49.169 --> 00:02:51.872
that is running the service,
reducing the attacker is fas of

00:02:51.872 --> 00:02:54.307
the machine, reducing the number
of services. And audited them.

00:02:54.307 --> 00:02:56.309
Finding whatever logs they
produce, pulling them back,

00:02:56.309 --> 00:02:59.212
aggregate can them finding way
to search them. Cool >> I need

00:02:59.212 --> 00:03:02.549
visualization for to but I can
try to wing it when we think of

00:03:02.549 --> 00:03:04.551
an operating system and
privilege there's really only

00:03:04.551 --> 00:03:08.088
two privileges you get today.
Ring three and ring zero. So

00:03:08.088 --> 00:03:11.825
that you have a concept much
users, you have access controls,

00:03:11.825 --> 00:03:15.729
you have permissions, bits on
files, that's not really making

00:03:15.729 --> 00:03:18.198
-- anything to do with hardware
security. Hardware security

00:03:18.198 --> 00:03:22.969
comes in when you make context
switch from user land

00:03:22.969 --> 00:03:27.541
application, the web user, so
on. Into ring zero. That's

00:03:27.541 --> 00:03:30.711
implemented kind of at the
silicon level. Kind of actually,

00:03:30.711 --> 00:03:34.948
really at the silicon level.
X86, Intel producing -- allow

00:03:34.948 --> 00:03:40.153
implement both of these modes.
Then you pick your favorite

00:03:40.153 --> 00:03:45.358
operating system. Slackware, and
you run a kernel that is

00:03:45.358 --> 00:03:49.529
implementing this ISA to switch
between privilege and

00:03:49.529 --> 00:03:55.235
unprivileged mode. We get one
little ring. We want to put all

00:03:55.235 --> 00:03:58.705
of our security aware stuff
inside of the privileged mode,

00:03:58.705 --> 00:04:02.008
the security unaware stuff on
the outside. That comes down to

00:04:02.008 --> 00:04:05.645
implementing all of those access
controls, the permissions bits

00:04:05.645 --> 00:04:09.683
inside the privilege mode. Any
time you need to make -- every

00:04:09.683 --> 00:04:13.253
time you have a question that
you want to check a permissions

00:04:13.253 --> 00:04:16.690
bit hopefully enforcement of
that is inside that privilege

00:04:16.690 --> 00:04:24.131
domain. Now X86 there are couple
other privilege levels, too.

00:04:24.131 --> 00:04:29.302
Kind of call these negative one.
System management mode. It works

00:04:29.302 --> 00:04:34.641
in kind of the same way. In the
ISA there is some definition of

00:04:34.641 --> 00:04:38.979
how you can set up this other
privilege mode, load some code

00:04:38.979 --> 00:04:42.916
into it and then use it as kind
of an Oracle. Use it as an

00:04:42.916 --> 00:04:47.687
Oracle in way that you define an
API between the SMM then load

00:04:47.687 --> 00:04:51.158
your security context aware code
inside there and any time you

00:04:51.158 --> 00:04:54.094
need to check the permission,
I'm talking in vagueness right

00:04:54.094 --> 00:04:57.998
now, you'll access the SMM
otherwise, the kernel cannot

00:04:57.998 --> 00:05:01.902
modify anything that's happening
in there. Take a step back,

00:05:01.902 --> 00:05:05.505
there are definitely attacks
against that. Right there is not

00:05:05.505 --> 00:05:10.877
true when these APIs fall apart
but that is the general gist of

00:05:10.877 --> 00:05:15.849
it. That is how we define a
privilege service. We come up

00:05:15.849 --> 00:05:20.821
with two domains. Now think of
this in the networking mode, you

00:05:20.821 --> 00:05:27.027
kind of have a LAN then you have
a service on that LAN running on

00:05:27.027 --> 00:05:31.998
a machine. The privilege domain
is like the TCP port that you

00:05:31.998 --> 00:05:36.136
have open. If you want to
communicate with that service

00:05:36.136 --> 00:05:40.674
you have to communicate over the
protocol that it defined. I

00:05:40.674 --> 00:05:44.811
mean, we tested it couple of
minutes before, I doubt

00:05:44.811 --> 00:05:48.548
something with my machine.
Definitely. It's probably the --

00:05:48.548 --> 00:05:53.920
I can definitely reboot if you
like. >> I'm just going to jump

00:05:53.920 --> 00:05:58.892
in here. What Ted is talking
about we're trying to think how

00:05:58.892 --> 00:06:02.729
can we take something like
operating system level or a

00:06:02.729 --> 00:06:05.398
software application layer to
sort of make a good analogy for

00:06:05.398 --> 00:06:09.436
what we're trying to talk about
for the separation trusted

00:06:09.436 --> 00:06:12.706
execution states or like context
switching, right, of this idea

00:06:12.706 --> 00:06:16.309
of escalating your privilege.
And one of the ways that you can

00:06:16.309 --> 00:06:20.180
kind of think about that is sort
of how an API exposes internal

00:06:20.180 --> 00:06:23.183
like infrastructure for a big
application to somebody on the

00:06:23.183 --> 00:06:26.786
outside that wants to leverage
it and make use it of, right?

00:06:26.786 --> 00:06:30.657
You can think if you have this
like barrier, this bubble inside

00:06:30.657 --> 00:06:33.293
of this bubble is a lot of
abstracts and complex systems,

00:06:33.293 --> 00:06:37.063
not necessarily going to need to
understand or touch. This is

00:06:37.063 --> 00:06:41.534
kind of like merging into where
we got APIs type of thing we're

00:06:41.534 --> 00:06:46.139
just going to expose a couple of
pieces to you say, hey, here is

00:06:46.139 --> 00:06:49.209
this functionality that will --
awesome stuff you take it and

00:06:49.209 --> 00:06:51.912
kind of run and just go wild and
do whatever you think you need

00:06:51.912 --> 00:06:55.815
to do with it. Well, the way
this is working at the hardware

00:06:55.815 --> 00:06:59.552
layer is almost -- very, very
similar way. There's a lot of

00:06:59.552 --> 00:07:03.957
these -- these little pieces
that developers of things like

00:07:03.957 --> 00:07:07.327
the trusted computing group
they're requiring a standard for

00:07:07.327 --> 00:07:10.997
having these pieces and we're
going to expose the

00:07:10.997 --> 00:07:13.667
functionality of these pieces to
the people that are writing the

00:07:13.667 --> 00:07:16.903
firmware for you. It's an
analogy that you can use to sort

00:07:16.903 --> 00:07:20.206
of make it make sense if you're
coming at this from a software

00:07:20.206 --> 00:07:25.312
world. >> Right. Let's talk a
little bit about those building

00:07:25.312 --> 00:07:30.116
blocks, too. The buildings
blocks are that ISA, it's that

00:07:30.116 --> 00:07:35.355
API or it's like the HTTP 11
specification. That's how you

00:07:35.355 --> 00:07:39.592
use it. Only instead of HTTP11
this specification these

00:07:39.592 --> 00:07:42.228
building blocks are around
protecting information. You'll

00:07:42.228 --> 00:07:46.366
see a lot of like implemented
here that you can use, you'll

00:07:46.366 --> 00:07:51.171
see some protected storage that
you will have access to and then

00:07:51.171 --> 00:07:57.177
you'll have like protected IO,
so network service will have to

00:08:00.080 --> 00:08:06.086
put the mode into -- put the
machine into just a mode before

00:08:12.025 --> 00:08:18.031
any AIO can be detected --
difficult context to explain.

00:08:21.234 --> 00:08:27.240
Let's start with, can I project
now? If we had visualizations it

00:08:32.245 --> 00:08:38.251
would be so much better. How
about now? Oh, the Woas of being

00:08:41.287 --> 00:08:47.293
the first speakers. I'm
definitely picking up your color

00:08:55.535 --> 00:09:00.807
LCD. All right. Yeah, right.
We'll do this. Building blocks

00:09:00.807 --> 00:09:07.247
that you -- we looked at all the
kind of hardware security APIs,

00:09:07.247 --> 00:09:13.686
the trust zones, Intel ISA as
the AMDs we try to boil that

00:09:13.686 --> 00:09:18.158
down, that includes the
Qualcomms, the -- >> Everything

00:09:18.158 --> 00:09:22.629
mobile and like, you know,
enterprise level desktop like

00:09:22.629 --> 00:09:28.067
all of these different platforms
are going to have some variant

00:09:28.067 --> 00:09:34.507
of these blocks that we're --
Ted is going to talk about. It

00:09:34.507 --> 00:09:40.480
really kind of reduces down to
having one -- getting lost. We

00:09:40.480 --> 00:09:46.419
need to have some type of
dedicated storage so you need to

00:09:46.419 --> 00:09:52.392
have some form of a chip that
you can burn things into from

00:09:52.392 --> 00:09:54.394
that you're going to get the
concept of this storage also

00:09:54.394 --> 00:09:58.431
needs to have some capability
for being isolated. Right? You

00:09:58.431 --> 00:10:03.470
want to have the capacity or the
capability of burning a Cert or

00:10:03.470 --> 00:10:06.306
key or something sensitive to a
chip with some level of

00:10:06.306 --> 00:10:08.708
assurance that nobody is going
to be able to tamper that,

00:10:08.708 --> 00:10:14.714
right? >> Yeah. So, from like
this dedicated storage,

00:10:19.385 --> 00:10:22.622
something that you can burn in
one time, blow any fuse then

00:10:22.622 --> 00:10:27.327
never be modified plus some
crypto algorithm this resilience

00:10:27.327 --> 00:10:34.133
we can get this concept of
extendible trust. With a private

00:10:34.133 --> 00:10:38.905
key with a algorithm implemented
chip and some reasonable

00:10:38.905 --> 00:10:45.178
guarantee that you need about
$100 --> 000 -- >> Fighting the good

00:10:45.178 --> 00:10:51.184
fight. >> We can use those kind
of primitives -- with those we

00:10:55.255 --> 00:11:01.494
can have this concept of
extendible trust. So, with that,

00:11:01.494 --> 00:11:04.531
then with that extendible trust
we can start taking affirmatives

00:11:04.531 --> 00:11:10.870
up a level. Add couple more, the
directed IO that we mentioned.

00:11:10.870 --> 00:11:16.209
And that might include some --
something on the hardware that

00:11:16.209 --> 00:11:20.380
allows to you interact with this
outside the regular band. So

00:11:20.380 --> 00:11:24.417
that could be another Ethernet
port on the device another PS2

00:11:24.417 --> 00:11:30.723
on the device. And that you can
direct input and output to. With

00:11:30.723 --> 00:11:34.260
that we can take that up a level
start defining concepts like

00:11:34.260 --> 00:11:39.432
trust zone. >> I'll just try to
do the best I can. We had some

00:11:39.432 --> 00:11:43.036
pretty awesome images that
helped make these things darks

00:11:43.036 --> 00:11:46.005
darks concepts a little clearer,
there this was whole thing with

00:11:46.005 --> 00:11:50.510
pokeymon and Legos -- >> You're
missing out it was great. We'll

00:11:50.510 --> 00:11:57.884
do the best we can. What pokemon
in general looks like. Or like

00:11:57.884 --> 00:12:03.456
Legos, right? The concept that
we use to construct these really

00:12:03.456 --> 00:12:06.893
complicated technologies like
security trust zone which we'll

00:12:06.893 --> 00:12:10.930
dive into lot further is, again,
using the API analogy we've been

00:12:10.930 --> 00:12:14.500
given all of these hardware
building blocks and start to

00:12:14.500 --> 00:12:18.404
string these pieces together to
a point where we have technology

00:12:18.404 --> 00:12:22.342
platform that enables us to
provide that trust. So, you

00:12:22.342 --> 00:12:28.748
start with these building blocks
you build up the capability with

00:12:28.748 --> 00:12:31.751
the firmware, that's the next
piece that we need. We're

00:12:31.751 --> 00:12:35.188
shooting for secure boot or
trust zone. But we can't quite

00:12:35.188 --> 00:12:37.857
get there yet. Before you get to
there you have to have a couple

00:12:37.857 --> 00:12:41.961
of other pieces like the secure
boot and also the concept of

00:12:41.961 --> 00:12:44.964
these building blocks that we
had before TPM or some sort of

00:12:44.964 --> 00:12:48.434
isolated storage device.
Constructing all of these pieces

00:12:48.434 --> 00:12:52.205
together gives you the framework
with which to implement your

00:12:52.205 --> 00:12:55.708
specs of secure boot. And the
reason that there is so many of

00:12:55.708 --> 00:12:59.045
these varying technologies
because secure boot is more of

00:12:59.045 --> 00:13:01.948
just a protocol, it's really
just there for to you say, all

00:13:01.948 --> 00:13:04.183
right, we have all of these
different pieces and what you

00:13:04.183 --> 00:13:07.487
should do is try to take the
Legos that you specifically need

00:13:07.487 --> 00:13:12.558
-- [Applause] Now all this makes
sense. You guys are good? We

00:13:12.558 --> 00:13:18.631
don't even need to -- [
inaudible ] Start again. Let's

00:13:18.631 --> 00:13:25.838
get some Scotch. Are we just
going to -- >> We'll just have

00:13:25.838 --> 00:13:29.676
to tell them to advance. We have
the slides down there. >>

00:13:29.676 --> 00:13:35.081
Advance. >> Oh, man. Yeah, so
this is our goal. This is where

00:13:35.081 --> 00:13:42.188
we're trying to get to. >> There
we go. >> Even know the order of

00:13:42.188 --> 00:13:45.258
these. Is that -- that's one
ahead we'll build secure boot.

00:13:45.258 --> 00:13:48.761
We'll start there start fresh.
Being a little bit redundant

00:13:48.761 --> 00:13:52.298
we're going to take these
concepts of extendible trust,

00:13:52.298 --> 00:13:56.269
dedicated storage, monitoring,
algorithm, state, we're going to

00:13:56.269 --> 00:14:00.306
with it start constructing the
firmware. This is block number

00:14:00.306 --> 00:14:05.678
one that we need to reach our
goal. And the Uwifi firmware is

00:14:05.678 --> 00:14:09.782
this protocol that's been
defined that is I think trusted

00:14:09.782 --> 00:14:14.087
computing one of the biggest
proponents making this clear and

00:14:14.087 --> 00:14:17.924
concise and have a good design
to, right? So that is what we

00:14:17.924 --> 00:14:22.395
want to focus on today is the
design of these things. As

00:14:22.395 --> 00:14:25.031
opposed to implementations.
We'll talk about the

00:14:25.031 --> 00:14:27.600
implementations later but --
first ones we've got Uwifi 2

00:14:27.600 --> 00:14:35.041
plus. Now the paramount please
of doing hardware security is

00:14:35.041 --> 00:14:38.911
our trusted certificate stores.
The large majority of how secure

00:14:38.911 --> 00:14:42.615
boot works or trust zone works
through cryptographic protocols.

00:14:42.615 --> 00:14:46.753
Digital signatures. We have to
have way verifying that the

00:14:46.753 --> 00:14:51.290
signature that you have that
that you got from Microsoft that

00:14:51.290 --> 00:14:55.528
has been verified from them can
be stored on your computer not

00:14:55.528 --> 00:14:59.465
tampered with or hijacked at any
point in time, right? This also

00:14:59.465 --> 00:15:01.801
brings up a lot of scary
thoughts about well Microsoft

00:15:01.801 --> 00:15:04.270
just going to take over the
world, we'll talk about. That

00:15:04.270 --> 00:15:06.706
don't get too excited yet. I'm
excited, don't get too excited

00:15:06.706 --> 00:15:11.477
yet. Once we have those, the
last thing, last piece that we

00:15:11.477 --> 00:15:13.913
need again this comes from
Microsoft but again we'll talk

00:15:13.913 --> 00:15:19.819
about that controversy is signed
letter which -- executes the

00:15:19.819 --> 00:15:22.755
different components at the
firmware layer gets you into

00:15:22.755 --> 00:15:26.058
your operating system. >> That
signed boot loader just an

00:15:26.058 --> 00:15:29.495
example of the extendible trust
that we talked about. It could

00:15:29.495 --> 00:15:32.765
be assigned to anything. But
with that dash those couple of

00:15:32.765 --> 00:15:35.868
building blocks plus the
certificate store you can now

00:15:35.868 --> 00:15:39.372
extend that trust. >> You've got
all of the components that you

00:15:39.372 --> 00:15:43.042
need, you as individuals are
like a company or corporation,

00:15:43.042 --> 00:15:46.479
to design your own hardware
security platform that you can

00:15:46.479 --> 00:15:49.248
deploy on your varying devices.
>> Don't recommend doing that,

00:15:49.248 --> 00:15:52.051
though. >> We don't, please.
Please use already developed

00:15:52.051 --> 00:15:55.988
things. Let's talk about these
individual components and kind

00:15:55.988 --> 00:16:00.726
of explore a little bit more of
like what entails constructing

00:16:00.726 --> 00:16:06.699
them. After I drink some water.
For the -- secure boot to

00:16:06.699 --> 00:16:10.536
function we have to be able to
verify that firmware that we're

00:16:10.536 --> 00:16:13.172
executing was actually given to
you from the manufacturer. How

00:16:13.172 --> 00:16:17.143
do we do that? Well, we have to
do digital signatures. Digital

00:16:17.143 --> 00:16:19.712
signatures work by taking the
private -- public key that

00:16:19.712 --> 00:16:22.315
scored on disk or somewhere on a
chip, somewhere immutable,

00:16:22.315 --> 00:16:29.422
assigned hash that was computed
by taking the currently

00:16:29.422 --> 00:16:32.358
executing. To do this you have
to have that public key, which

00:16:32.358 --> 00:16:36.395
is stored inside of your
platform key, key store, the PK

00:16:36.395 --> 00:16:40.666
you might see that acronym
thrown around. Then also we have

00:16:40.666 --> 00:16:43.636
another key store called the
KEK. Key enrollment key

00:16:43.636 --> 00:16:48.140
database. I screw that up. The
KEK is where you can store any

00:16:48.140 --> 00:16:51.344
third party drivers or
components that you also have

00:16:51.344 --> 00:16:54.647
signed you take the certificate,
is that ever signed by Microsoft

00:16:54.647 --> 00:16:58.150
and also came from the developer
of those drivers, and you put

00:16:58.150 --> 00:17:00.987
them in your Kek this is just
where those things live so as

00:17:00.987 --> 00:17:03.456
you're going through your
execution process of your

00:17:03.456 --> 00:17:06.692
firmware you can load these
digital signatures of your third

00:17:06.692 --> 00:17:10.930
party drivers up, verify they
haven't been tampered with then,

00:17:10.930 --> 00:17:17.937
yep, I'm good. Then also need
signature database, I don't

00:17:17.937 --> 00:17:23.342
remember how that one comes in.
You might have to help me on

00:17:23.342 --> 00:17:29.015
that one. Two biggest are the PX
and KEK. Let's keep moving. Go

00:17:29.015 --> 00:17:34.387
back one slide. Go back two
slides. We'll start here. So, we

00:17:34.387 --> 00:17:38.925
want that when we go Pokeyman
battle we're fighting big fierce

00:17:38.925 --> 00:17:42.728
opponent we'll throw out those
capabilities, right. This is

00:17:42.728 --> 00:17:47.767
sort of a hint to what secure
has capability of offering you.

00:17:47.767 --> 00:17:51.571
Go to the next slide. So, when
you don't have secure boot

00:17:51.571 --> 00:17:55.641
enables, you're rolling with
running around naked, you throw

00:17:55.641 --> 00:18:01.347
out your woke ball might end up
with a magikarp that's a huge

00:18:01.347 --> 00:18:05.351
bummer. Might find yourself
surprised or confused or care

00:18:05.351 --> 00:18:10.256
filed. Why did that come out?
That's a huge bummer. This is

00:18:10.256 --> 00:18:13.392
the kind of illustrate without
secure boot enables you're

00:18:13.392 --> 00:18:15.995
missing out on a lot of
functional -- missing out on lot

00:18:15.995 --> 00:18:19.231
of security and verification for
what this technology has to

00:18:19.231 --> 00:18:23.970
offer you. Go to the next slide.
When do you have secure boot

00:18:23.970 --> 00:18:27.707
it's pretty awesome, right? When
design of secure boot is

00:18:27.707 --> 00:18:30.509
implemented correctly and we
have some assurances that

00:18:30.509 --> 00:18:33.346
everything we're doing has been
signed there's all of the crypto

00:18:33.346 --> 00:18:37.049
we need. You have a lot of power
in what you're doing like you

00:18:37.049 --> 00:18:40.086
now have much more capability at
the firmware layer. You can do

00:18:40.086 --> 00:18:42.488
remote updates, you can do all
of these different things.

00:18:42.488 --> 00:18:44.890
Because you have crypto kind of
backing you up and giving you

00:18:44.890 --> 00:18:50.296
that validation that you need.
>> That analogy is pretty cool

00:18:50.296 --> 00:18:55.034
only because Pokeman is fucking
awesome. But it's very hard to

00:18:55.034 --> 00:19:01.007
get a magikarp into a -- only
thing it knows is Flo. If you

00:19:01.007 --> 00:19:05.778
are running an enterprise you
need to run weird drivers or

00:19:05.778 --> 00:19:10.082
weird firmware or boot an
operating system that has boot

00:19:10.082 --> 00:19:14.387
loader that isn't signed and
provided and do you understand

00:19:14.387 --> 00:19:18.557
load binary grub. You need to do
a little bit of work. That

00:19:18.557 --> 00:19:22.461
little work involves loading up
that Kek with your own

00:19:22.461 --> 00:19:26.298
certificate, not entering that
CA, whatever sign that

00:19:26.298 --> 00:19:29.301
certificate then distributing it
to all the machines that you

00:19:29.301 --> 00:19:32.338
want to run this firmware,
modified firmware on. That is a

00:19:32.338 --> 00:19:36.108
lot of work. It's almost
impossible for small

00:19:36.108 --> 00:19:39.211
organization. Smaller, medium
organization. But fortunately

00:19:39.211 --> 00:19:42.715
they're not doing that. You're
not usually pushing to a mode or

00:19:42.715 --> 00:19:47.953
train magikarp up to a Garados.
>> So um, just to kind of

00:19:47.953 --> 00:19:50.790
elaborate on that note, if you
think about it this is still a

00:19:50.790 --> 00:19:54.393
really new technology. The
capabilities of making this wide

00:19:54.393 --> 00:19:56.929
scale where you can roll out
your own custom firmware that's

00:19:56.929 --> 00:19:59.632
been signed appropriately that
honors that there is not a lot

00:19:59.632 --> 00:20:03.135
-- this is baby technology it's
still coming around. So that's

00:20:03.135 --> 00:20:08.407
like just keep that in mind when
you're like seeing this, turn it

00:20:08.407 --> 00:20:13.646
off, it's so bad. Bear that in
mind. Next slide. We're going to

00:20:13.646 --> 00:20:17.683
talk a little bit more about
other technologies I've been

00:20:17.683 --> 00:20:22.621
droning on about secure boot a
lot but this is a quick overview

00:20:22.621 --> 00:20:25.891
of the different types of -- I'm
going to say measured in a

00:20:25.891 --> 00:20:29.628
general sense but also something
called measured boot. We just

00:20:29.628 --> 00:20:32.431
got done talking about secure
boot which is verifying that

00:20:32.431 --> 00:20:35.367
everything has actually been
digitally signed before you

00:20:35.367 --> 00:20:39.839
start actually executing it,
also -- sorry also something

00:20:39.839 --> 00:20:42.541
called trusted boot. Which is
much more often talked about in

00:20:42.541 --> 00:20:45.845
the Windows world, actually a
trifecta of three different

00:20:45.845 --> 00:20:49.248
types of boot, secured boot,
measured boot also verified

00:20:49.248 --> 00:20:54.587
boot. That's right. Thank you.
Trusted boot is neat in the

00:20:54.587 --> 00:20:58.057
tense that if you're just
rolling vanilla Windows, that's

00:20:58.057 --> 00:21:00.259
what you do in life you're not
looking to customize which I

00:21:00.259 --> 00:21:02.528
know everybody in this room
that's how you roll, I know

00:21:02.528 --> 00:21:07.500
that. That's a good joke, I
thought it was good. This is

00:21:07.500 --> 00:21:09.502
going to give you the
opportunity to verify every

00:21:09.502 --> 00:21:12.538
single operating system driver
before it loads, before you get

00:21:12.538 --> 00:21:14.740
into the operating system kind
of thing. It's also going to

00:21:14.740 --> 00:21:18.778
give you something called early
launch anti-malware. Is trying

00:21:18.778 --> 00:21:23.282
to find root kits, things that
are hiding out in kernel land

00:21:23.282 --> 00:21:26.719
trying to subvert your operating
system. Again, try to take away

00:21:26.719 --> 00:21:29.622
from this the idea of the
technology. It's really awesome

00:21:29.622 --> 00:21:32.491
idea, we should start seeing
more of these types of things

00:21:32.491 --> 00:21:35.661
deployed. Then lastly, measured
boot. This is more along the

00:21:35.661 --> 00:21:38.030
lines if you're like, you know
what, that's cool that you're

00:21:38.030 --> 00:21:41.167
trying to protect me and all,
but I just want to run naked how

00:21:41.167 --> 00:21:43.836
about you let know know when I'm
naked or when something bad

00:21:43.836 --> 00:21:48.607
happened to me. Then still going
to walk through a lot of these

00:21:48.607 --> 00:21:53.145
features but just going to do an
alerting, like, hey, you're

00:21:53.145 --> 00:21:57.249
about to load malware, you can
continue execution. Next slide.

00:21:57.249 --> 00:22:01.320
Cool. >> The words secured boot,
measured boot, verified boot

00:22:01.320 --> 00:22:05.424
most of the time they're used
interchangeably. I know in

00:22:05.424 --> 00:22:10.362
couple of of the sentences we
had we used them a little

00:22:10.362 --> 00:22:13.666
incorrectly. But the big
differentiation is the measured

00:22:13.666 --> 00:22:18.504
boot from kind of all the rest.
But in every single scenario,

00:22:18.504 --> 00:22:22.241
you have the opportunity to make
a decision. And you can be a

00:22:22.241 --> 00:22:25.311
piece of software that's running
or could be remote service

00:22:25.311 --> 00:22:28.714
that's making a yes or no
decision, right? That's what --

00:22:28.714 --> 00:22:32.751
like the big take away. I used
it incorrect leave, man, I'm so

00:22:32.751 --> 00:22:37.056
sorry. >> Like, dude, what did I
say wrong? >> Not yet. The way

00:22:37.056 --> 00:22:39.858
that's implemented with those
building blocks that we talked

00:22:39.858 --> 00:22:43.262
about is this little psych
they'll you see here. So, we're

00:22:43.262 --> 00:22:47.600
going to fetch load code. Going
to measure in a way like a hash

00:22:47.600 --> 00:22:49.735
that's always being added,
right? We call that like

00:22:49.735 --> 00:22:53.606
extending a hash, so you take
the hash from before and the

00:22:53.606 --> 00:22:57.776
hash of the code that you're
going to do now you get this

00:22:57.776 --> 00:23:00.412
amalgamation and you load it.
The point there being that you

00:23:00.412 --> 00:23:05.484
can't load code that erases the
hash. Then you're going to apply

00:23:05.484 --> 00:23:09.955
like an optional signature check
in the case where you're not

00:23:09.955 --> 00:23:13.025
worrying about these, there's a
little bit of variance in the

00:23:13.025 --> 00:23:15.127
hashes are always coming out to
something that you can't keep

00:23:15.127 --> 00:23:19.365
like, this big map of. We can
attach a little signature to the

00:23:19.365 --> 00:23:22.601
code that we're about to load
assuming that the code before it

00:23:22.601 --> 00:23:25.871
knew how to verify that
signature and also had some

00:23:25.871 --> 00:23:31.443
trust extended. So that it can
check that signature. Finally we

00:23:31.443 --> 00:23:34.113
have this ability to kind of
push those hashes and those

00:23:34.113 --> 00:23:37.650
signature checks to some remote
service that can possibly make a

00:23:37.650 --> 00:23:41.253
decision, right? Then finally
we'll make that decision. With

00:23:41.253 --> 00:23:44.657
the go forward with with no
still go forward or could abort

00:23:44.657 --> 00:23:48.928
the whole entire operation. We
can also set a couple of bits

00:23:48.928 --> 00:23:52.398
that identify that the operation
would have been aborted so that

00:23:52.398 --> 00:23:55.768
you can still run just in a
different mode. Really good

00:23:55.768 --> 00:23:59.705
economical use not decrypting a
certain storage device

00:23:59.705 --> 00:24:05.511
afterwards so that the decision
that you make is not to stop

00:24:05.511 --> 00:24:10.582
booting, it's just to not reveal
sensitive content going forward.

00:24:10.582 --> 00:24:13.852
So, when you think of this kind
of like trust chain, like

00:24:13.852 --> 00:24:16.989
whatever code is coming before
the code that you're loading

00:24:16.989 --> 00:24:21.727
right now, has to be aware. The
instant that there isn't this

00:24:21.727 --> 00:24:24.530
awareness of checking or
measuring, the whole entire

00:24:24.530 --> 00:24:28.500
chain is broken. That's what we
call like a root of trust

00:24:28.500 --> 00:24:32.938
measurement or dynamic root of
trust measurement. That root is

00:24:32.938 --> 00:24:36.308
like this establishment of like
your foot bone attached to your

00:24:36.308 --> 00:24:40.312
like ankle, attached to your
leg, so on, so forth up the

00:24:40.312 --> 00:24:43.215
body. As soon as you're missing
one of those bones the whole

00:24:43.215 --> 00:24:46.251
kind of thing starts to fall
apart. More so you can't trust

00:24:46.251 --> 00:24:52.257
the stuff that goes past it,
right? Sorry that interlude. I

00:24:59.431 --> 00:25:05.204
like to put underwear on slides,
too, it's my thing. No, sorry.

00:25:05.204 --> 00:25:10.275
Can we go? I think we have trust
zone coming up, I can't really

00:25:10.275 --> 00:25:13.746
see the next slide. >> This is
me. That was reminder of like

00:25:13.746 --> 00:25:17.182
where we are in the thing but we
didn't start with slides, right,

00:25:17.182 --> 00:25:20.552
it doesn't super matter a lot.
Nobody really knows where we're

00:25:20.552 --> 00:25:25.958
at. We did a big talk about
secure boot and thats great. But

00:25:25.958 --> 00:25:30.963
Nick I hear you say, what about
my phone? Well, you common

00:25:30.963 --> 00:25:37.102
pleebs there is an answer to
one's phone. >> In 2003. Right.

00:25:37.102 --> 00:25:44.710
It's been around for a long
time. So I'm talking about baby

00:25:44.710 --> 00:25:48.947
technologies and that's not
accurate with this fall. But

00:25:48.947 --> 00:25:51.884
where trust zone comes in is
again we want to use a similar

00:25:51.884 --> 00:25:54.620
analogy. We have all of these --
using Pokeman this time instead

00:25:54.620 --> 00:25:56.855
of Legos I know you were
concerned. Were using Pokemon

00:25:56.855 --> 00:25:58.857
this time instead of Legos. We
have a lot of different poke

00:25:58.857 --> 00:26:02.361
balls and different kinds of
Pokemon what you want to assure

00:26:02.361 --> 00:26:06.131
designing your trust zone, when
you go to the certain region in

00:26:06.131 --> 00:26:09.935
the Pokemon world you want to
make sure you bring the right

00:26:09.935 --> 00:26:14.039
poke balls to catch the right
Pokemon but also bring your all

00:26:14.039 --> 00:26:17.843
-- going to do very well against
those type of Pokemon. So, it's

00:26:17.843 --> 00:26:20.946
a similar concept with trust
zone that you were given a large

00:26:20.946 --> 00:26:24.583
amount of hardware pieces on the
board that you can take

00:26:24.583 --> 00:26:27.586
advantage of and leverage. But
also given a lot of like,

00:26:27.586 --> 00:26:30.856
software protocol specifications
that you can also make use of,

00:26:30.856 --> 00:26:34.460
right? So, trust zone varies
from secure boot in the sense

00:26:34.460 --> 00:26:38.831
that oftentimes this is less
stuck to you as like a constant

00:26:38.831 --> 00:26:41.500
standard. And companies usually
just take the spec, the

00:26:41.500 --> 00:26:46.338
guideline, make our own
proprietary version of this and

00:26:46.338 --> 00:26:52.444
things like Samsung knox and
Qualcomm has QSE. There was talk

00:26:52.444 --> 00:26:57.783
at Black Hat about Samsung knox
or QSE one of them, it was silly

00:26:57.783 --> 00:27:01.787
you should check that talk out,
pretty cool. >> Not the talk.

00:27:01.787 --> 00:27:05.491
The implementation. >> Yeah.
That's what I meant to say. >>

00:27:05.491 --> 00:27:10.262
What did I say? Anyway. >> With
trust zone 2, arm kind of is

00:27:10.262 --> 00:27:13.632
built this API like the
protection domain that we were

00:27:13.632 --> 00:27:17.102
talking about before and the
ISA. Here is the manual how to

00:27:17.102 --> 00:27:20.539
create a protection domain,
please write me some software

00:27:20.539 --> 00:27:23.742
that implements this protection
domain, such that I can load

00:27:23.742 --> 00:27:27.479
code and kind of secure mode,
also like unprivileged mode

00:27:27.479 --> 00:27:32.584
which would be normal operating
system. Then Qualcomm and

00:27:32.584 --> 00:27:37.689
Samsung knox will license that
spec from arm theyll

00:27:37.689 --> 00:27:43.896
implement this trust zone APIs,
right? >> Next slide. I can

00:27:43.896 --> 00:27:49.568
continue on this. If we're
talking trust zone, this is

00:27:49.568 --> 00:27:53.539
called like execution
environment. It is that

00:27:53.539 --> 00:27:58.944
privilege domain. Anything
loading inside the trust zone T,

00:27:58.944 --> 00:28:03.515
right, the trust zone secure
world, is the equivalent of that

00:28:03.515 --> 00:28:06.785
like -- not the actual
equivalent but equivalent in the

00:28:06.785 --> 00:28:11.957
metaphor of privilege domain in
your operating system and

00:28:11.957 --> 00:28:17.362
unprivileged domain in the user
mode. Same metaphor applies to

00:28:17.362 --> 00:28:22.267
priviledge service, versus the
network, the LAN itself. You can

00:28:22.267 --> 00:28:26.505
leverage this to build something
like secure boot. Right? You

00:28:26.505 --> 00:28:30.642
build secure boot and trusted
boot and trust zone. >> Me? >>

00:28:30.642 --> 00:28:36.248
You did? >> No. Right, the way
you get -- the way you get

00:28:36.248 --> 00:28:40.586
secure boot with this kind of
capability is, you load a small

00:28:40.586 --> 00:28:43.922
little operating system, like
your boot operating system. It

00:28:43.922 --> 00:28:47.593
knows how to load code in to
this secure world, right? The

00:28:47.593 --> 00:28:52.097
room on your mobile device, your
arm, platform is measuring that

00:28:52.097 --> 00:28:56.401
boot rating system once it sets
up the secure world it can now

00:28:56.401 --> 00:28:59.471
make API calls to that,
hopefully there's some storage

00:28:59.471 --> 00:29:03.241
in that secure world with some
certificate stores now that boot

00:29:03.241 --> 00:29:07.145
can load a normal operating
system while the secure mode is

00:29:07.145 --> 00:29:11.249
auditing it. Measuring. Checking
additional drivers, additional

00:29:11.249 --> 00:29:15.187
firmware that it might load.
This is done, right? There is a

00:29:15.187 --> 00:29:18.857
secure boot for arm devices for
android devices, and it's

00:29:18.857 --> 00:29:23.161
implemented with all these APIs.
>> I think that's coming later.

00:29:23.161 --> 00:29:27.332
I don't want to give away
spoilers but we'll -- >> Right.

00:29:27.332 --> 00:29:33.805
We kind of skipped like what a
TPM is, missing few of the

00:29:33.805 --> 00:29:39.878
slides but the same things that
you would use to build a TPM you

00:29:39.878 --> 00:29:45.384
can use with these APIs, too,
they call it secure core. Both a

00:29:45.384 --> 00:29:50.055
TPM in what incantation it is
like new Intel platforms the

00:29:50.055 --> 00:29:55.260
TPM2.0 in the silicon or add to
your motherboard. Or secure core

00:29:55.260 --> 00:29:57.362
they're all using these
primitives that we talked about

00:29:57.362 --> 00:30:03.435
and implementing them. >> Okay.
So this was kind of what we were

00:30:03.435 --> 00:30:06.371
trying to build up to. Ted
already talked about what this

00:30:06.371 --> 00:30:09.908
slide is kind of illustrating,
but it's really just the trust

00:30:09.908 --> 00:30:13.578
zone giving you this capability.
Right? You can in some sense

00:30:13.578 --> 00:30:17.449
have these two different
environments of operation

00:30:17.449 --> 00:30:19.985
sitting right along side of each
other like on your mobile device

00:30:19.985 --> 00:30:24.056
so you can switch into a mode of
compute, performing sensitive

00:30:24.056 --> 00:30:28.827
operations -- data and then you
can jump out of that context go

00:30:28.827 --> 00:30:31.530
back into the normal user mode
where you can check Facebook get

00:30:31.530 --> 00:30:34.032
upon Twitter do the things that
you need to do. Kind of like how

00:30:34.032 --> 00:30:40.839
goes back and forth from being
crazy and upset and angry to

00:30:40.839 --> 00:30:46.912
super happy. Next slide. But,
yeah, implementation of these

00:30:46.912 --> 00:30:50.449
things gets really complicated
really, really quickly. The spec

00:30:50.449 --> 00:30:56.755
that you can use they're huge
these massive documents of just

00:30:56.755 --> 00:31:00.726
constant changes and revisions
to the spec. So this is really

00:31:00.726 --> 00:31:05.097
just illustrate -- trying to
make this at really higher level

00:31:05.097 --> 00:31:08.700
of design functionality but you
can see how -- this gets like

00:31:08.700 --> 00:31:13.238
muddled and very noisy. >> One
way our analogy between the

00:31:13.238 --> 00:31:17.008
network service and the
operating -- service running on

00:31:17.008 --> 00:31:21.179
the operating system falls apart
sick install a python module

00:31:21.179 --> 00:31:25.984
implement like a API give me a
web server if I wanted to

00:31:25.984 --> 00:31:31.890
implement UAFI, read over 2,3500
pages of the spec and then go

00:31:31.890 --> 00:31:35.894
consult even -- over a million
lines of code of reference

00:31:35.894 --> 00:31:39.297
specification. The same would
exist for trust zone, too.

00:31:39.297 --> 00:31:42.768
There's lots of applications
here, lots for rooms of error

00:31:42.768 --> 00:31:45.303
that's why you see these great
talks about breaking these

00:31:45.303 --> 00:31:50.809
things because those
implementations were misused or

00:31:50.809 --> 00:31:55.080
the building blocks weren't used
correctly. >> This kind of feeds

00:31:55.080 --> 00:31:59.985
into the old, don't write your
own crypto. Very complicated,

00:31:59.985 --> 00:32:03.955
very quickly, one small mess up
leaves you have completely open

00:32:03.955 --> 00:32:07.425
and totally vulnerable, right?
Hopefully this illustrates that

00:32:07.425 --> 00:32:13.698
complexity factor. Next slide.
Again, just trying to keep where

00:32:13.698 --> 00:32:19.704
you we're at. Next slide. Cool.
>> Do hardware security tour. So

00:32:21.807 --> 00:32:26.311
we're going to cruise around the
region and talk a bit about

00:32:26.311 --> 00:32:32.617
these implementations. Go to the
next slide. TPMs, if you want to

00:32:32.617 --> 00:32:36.421
buy a TPM, actually I have
couple of discrete TPMs up here

00:32:36.421 --> 00:32:39.724
if anyone looking to like play
around with one. And they have

00:32:39.724 --> 00:32:42.694
little embedded boards that
speak I2C. I can give you a

00:32:42.694 --> 00:32:47.399
couple. Otherwise if you look
for purchasing motherboards that

00:32:47.399 --> 00:32:53.338
have Intel small business you'll
get a TPM or get some

00:32:53.338 --> 00:32:58.910
implementation might be in the
silicon TPM. These are really

00:32:58.910 --> 00:33:02.981
cool. They implement almost all
of those building blocks except

00:33:02.981 --> 00:33:07.052
for kind of the directed IO and
execution isolation. So I can't

00:33:07.052 --> 00:33:10.755
hand off code to the TPM say,
create me a privilege domain and

00:33:10.755 --> 00:33:14.993
run this code in it then I'm
going to make API calls. You

00:33:14.993 --> 00:33:18.797
can't really do that. Are kind
of like your poke ball, there

00:33:18.797 --> 00:33:22.734
was a reason why I had a bunch
of these emoticons but I'm not

00:33:22.734 --> 00:33:28.006
going to explain it now. But
like your Keks or UBHSM they do

00:33:28.006 --> 00:33:34.012
various parts of those building
blocks. You're going to have a

00:33:36.581 --> 00:33:38.783
certificate store on there,
you're going to have a push

00:33:38.783 --> 00:33:42.153
certificates in there hopefully
below E-fuse so the certificates

00:33:42.153 --> 00:33:46.558
cannot never change. But on
almost every case you will --

00:33:46.558 --> 00:33:51.329
read the private key from those
-- some other directed IO. You

00:33:51.329 --> 00:33:56.101
put your HTM into your machine
that needs to access the public

00:33:56.101 --> 00:34:00.438
keys for these certs and only
the software running on that

00:34:00.438 --> 00:34:04.809
machine or software on that
machine will only be able to

00:34:04.809 --> 00:34:09.281
access the public keys. Go to
the next slide. Trust zone and

00:34:09.281 --> 00:34:13.551
secure core. Implementing this
privilege domain and Qualcomm

00:34:13.551 --> 00:34:17.289
Secure MSM, right? And like we
said before they license the

00:34:17.289 --> 00:34:22.360
trust zone spec they can build
towards it and call are the are

00:34:22.360 --> 00:34:28.466
their own. Knox at the bottom is
just this trust zone spec. TXT

00:34:28.466 --> 00:34:33.204
and IOMMU are a little bit
different. We haven't really

00:34:33.204 --> 00:34:39.311
jumped into this domain. But the
IOMMU is going to be an API

00:34:39.311 --> 00:34:44.015
around isolating devices and
memory reads. So when we think

00:34:44.015 --> 00:34:48.887
back to the primitives that we
talk about and the reason we're

00:34:48.887 --> 00:34:51.990
bringing these things up is if
you're interested in these, in

00:34:51.990 --> 00:34:58.029
IOMMU or building things for TXT
please do. That is going to give

00:34:58.029 --> 00:35:01.866
you that kind of directed IO
plus the isolated execution. Now

00:35:01.866 --> 00:35:05.570
I can take that isolated
execution and extend it to

00:35:05.570 --> 00:35:09.274
potentially untrusted driver for
like a network card that I'm

00:35:09.274 --> 00:35:12.711
testing out, furthermore I can
create that kind of concept of a

00:35:12.711 --> 00:35:16.414
secure world that trust zone
gives me on an Intel platform. I

00:35:16.414 --> 00:35:19.150
can take a bit of code, I can
push it into a privileged

00:35:19.150 --> 00:35:23.088
domain, I can define the APIs
for it and make calls it to. If

00:35:23.088 --> 00:35:26.191
I wanted to bootstrap some
protected key material in there

00:35:26.191 --> 00:35:30.261
then launch a web service that
is going to negotiate session

00:35:30.261 --> 00:35:33.398
keys, it can do that to that
little isolated environment,

00:35:33.398 --> 00:35:37.902
right? And it uses TXT for that.
That will push the code on to a

00:35:37.902 --> 00:35:42.073
single CPU, set up the IOMMU for
you, you're going to have to do

00:35:42.073 --> 00:35:46.211
a little bit of yourself, but at
the end of the day you're going

00:35:46.211 --> 00:35:49.447
to get this dedicated storage,
dedicated part of D RAM and

00:35:49.447 --> 00:35:52.183
dedicated execution on single
core and also going to get a

00:35:52.183 --> 00:35:55.487
measurement afterwards. Then you
can use other measurements that

00:35:55.487 --> 00:35:59.224
might already exist to kind of
come up with a decision of

00:35:59.224 --> 00:36:02.360
whether you are running in a
trusted environment on trusted

00:36:02.360 --> 00:36:07.966
machine or in trusted state then
you can extend that decision

00:36:07.966 --> 00:36:13.071
further. To maybe like remote
service. We'll keep going? SGX

00:36:13.071 --> 00:36:17.676
is this awesome sauce that's
coming out. But it will take

00:36:17.676 --> 00:36:23.048
that TXT, IOMMU concept push it
into your user land apps. They

00:36:23.048 --> 00:36:28.753
can do the same thing. They can
set up their own Bastion of

00:36:28.753 --> 00:36:34.059
isolated then allow other
services to make calls to that.

00:36:34.059 --> 00:36:37.028
We take that privilege domain we
pull it out of of the ring zero

00:36:37.028 --> 00:36:41.633
and push it into like whatever
ring we define. It's very

00:36:41.633 --> 00:36:48.640
complicated, like concept. But I
hope that we can really start

00:36:48.640 --> 00:36:51.943
taking things like large attack
surfaces that we have against

00:36:51.943 --> 00:36:56.014
both applications running on the
host used to escalate privileges

00:36:56.014 --> 00:36:59.951
but also applications running as
network services and kind of

00:36:59.951 --> 00:37:03.621
define these APIS between
accessing protected material and

00:37:03.621 --> 00:37:09.627
then serving up that content on
a TCP board. So, we'll make one

00:37:12.964 --> 00:37:18.970
aside here. If you wanted to log
every execution of a process on

00:37:21.372 --> 00:37:26.611
OSX, right? You could go into
the kernel, write kernel

00:37:26.611 --> 00:37:32.917
extension, hook SYS, you use OSX
the Mac policies or APIs. Every

00:37:32.917 --> 00:37:39.724
time one of those are called you
create a log right? Start up

00:37:39.724 --> 00:37:45.764
some ring buffer, push the ring
buffer that becomes your log.

00:37:45.764 --> 00:37:49.768
Start doing this about 5 --> 000
times an hour for every process

00:37:49.768 --> 00:37:52.203
-- 5 --> 000 times an hour that will
be the processes he's that run

00:37:52.203 --> 00:37:55.940
per hour if you're using your
machine hard core. where do you

00:37:55.940 --> 00:37:59.978
put that data? So, from the
privilege domain you audited

00:37:59.978 --> 00:38:03.581
that requiring attacker to get
into the kernel so bypass that,

00:38:03.581 --> 00:38:07.819
what do you do with that data?
Can you from kernel land start

00:38:07.819 --> 00:38:13.124
pushing out to network service?
What kind of like arrows do you

00:38:13.124 --> 00:38:18.563
need to define. In almost every
example you have to go back out

00:38:18.563 --> 00:38:22.367
of that privilege domain to
write that data. That makes a

00:38:22.367 --> 00:38:25.870
lot of sense, too. If we're
defining reliable services, I

00:38:25.870 --> 00:38:31.743
can't for every Exec TCP call or
throw  EDP call throw this

00:38:31.743 --> 00:38:36.281
off to the network. I could
buffer it there, so now I'm

00:38:36.281 --> 00:38:38.850
taking memory away from the
system, so if I wanted to

00:38:38.850 --> 00:38:41.352
compress that I'm implementing
all these compression APIs

00:38:41.352 --> 00:38:46.491
inside the kernel, too, just --
it's not really a lot of fun.

00:38:46.491 --> 00:38:51.196
What we end up with something
called like -- we start auditing

00:38:51.196 --> 00:38:55.934
to a file in the unprivileged
world then we put like root

00:38:55.934 --> 00:39:00.171
access on there. We're adding
these permissions bits that are

00:39:00.171 --> 00:39:04.142
enforced in the unprivileged
world an attacker only needs to

00:39:04.142 --> 00:39:06.945
go up to root. Well if they went
up to root they just take kernel

00:39:06.945 --> 00:39:10.615
extension away or module away to
begin with. What we really need

00:39:10.615 --> 00:39:15.587
and we'll go to the next slide
is this concept of SGX where

00:39:15.587 --> 00:39:20.592
that blue circle I will is now
become purple that is my little

00:39:20.592 --> 00:39:23.661
privileged mode existing outside
of the traditional operating

00:39:23.661 --> 00:39:26.931
systems privilege land I can
write directly from the

00:39:26.931 --> 00:39:34.572
privileged log of the payoff,
this that can implement my

00:39:34.572 --> 00:39:38.977
compression and choose schedule
which it pushes data off. Now I

00:39:38.977 --> 00:39:42.714
get all the advantages of not
crashing the kernel if I somehow

00:39:42.714 --> 00:39:46.751
implemented my compression or my
scheduling wrong. I still can

00:39:46.751 --> 00:39:50.221
log this from the privilege
domain which is the operating

00:39:50.221 --> 00:39:56.494
system. The little deep but just
isolates -- or how you would use

00:39:56.494 --> 00:40:01.532
something like this isolated
execution, right? >> Yeah. >>

00:40:01.532 --> 00:40:07.171
We're almost finished here.
Another thing we didn't get much

00:40:07.171 --> 00:40:13.911
time to talk about is this out
of band systems which implement

00:40:13.911 --> 00:40:18.182
these isolated executions. IPMI
is kind of the equivalent of the

00:40:18.182 --> 00:40:22.420
trust zone, it's the
specification to which ILO and

00:40:22.420 --> 00:40:28.026
Draq or AMT or Intel's
management engine or secure

00:40:28.026 --> 00:40:32.730
engine, right? That is another
mode outside that has special

00:40:32.730 --> 00:40:38.269
APIs to run into this privilege
LAN. They are in the form of

00:40:38.269 --> 00:40:43.308
accessing or making Dram calls
or having access to some of the

00:40:43.308 --> 00:40:48.313
memory buses that are otherwise
protected by the ISA. We go one

00:40:48.313 --> 00:40:52.917
more. We'll go past this.
Failures and use cases. Hit the

00:40:52.917 --> 00:40:57.955
play button there. >> It's worth
it. You'll dig it. >> Great.

00:40:57.955 --> 00:41:02.160
Most of the failures in the
hardware security come in the

00:41:02.160 --> 00:41:06.931
form of like a cat trying to
walk a dog. Where the API wasn't

00:41:06.931 --> 00:41:10.068
implemented correctly now you
have some unprivileged mode

00:41:10.068 --> 00:41:13.104
commanding what you thought was
the privileged mode. Dogs are

00:41:13.104 --> 00:41:15.740
the privileged, that's your
kernel, they herd all the cats,

00:41:15.740 --> 00:41:21.746
right? They're the unprivileged
people. They're us. One more. So

00:41:24.749 --> 00:41:27.518
the kind of uses of these, the
things that we wanted to impress

00:41:27.518 --> 00:41:31.489
on everyone is, one, please do
not turn off secure boot, right?

00:41:31.489 --> 00:41:34.025
If you want to boot your
operating system, if you want to

00:41:34.025 --> 00:41:36.995
boot a different operating
system, figure out a way, there

00:41:36.995 --> 00:41:40.531
is a way, read a little bit more
we'll keep secure boot on we'll

00:41:40.531 --> 00:41:43.968
get you -- >> Something that we
didn't mention I'm going to jump

00:41:43.968 --> 00:41:47.672
in real quick there's a lot of
talk about like, well, if I have

00:41:47.672 --> 00:41:51.109
secure boot on with my laptop I
can only ever use Windows. At

00:41:51.109 --> 00:41:54.312
the moment there is currently a
lot of support for things like

00:41:54.312 --> 00:41:57.382
Ubuntu, Fidora that will keep
secure boot on and actually

00:41:57.382 --> 00:42:00.585
continue to boot with secure
boot enabled. It's performing

00:42:00.585 --> 00:42:03.755
all of these integrity checks
that you want to have. They have

00:42:03.755 --> 00:42:08.059
a little boot shin that still
signed by Microsoft, still going

00:42:08.059 --> 00:42:11.329
through all the Microsoft Certs
hijacking that process with

00:42:11.329 --> 00:42:17.135
their own boot strapping
process. Said that weird. That's

00:42:17.135 --> 00:42:24.108
kind of more -- secure boot on
is the functionality is there

00:42:24.108 --> 00:42:30.014
we're building it. Help be part
of the solution not the problem.

00:42:30.014 --> 00:42:32.316
>> Another really cool thing to
look forward to which exists

00:42:32.316 --> 00:42:37.188
right now in Windows almost
there in -- we got four minutes.

00:42:37.188 --> 00:42:42.693
Right? We have until -- >> We're
going to cut it off for

00:42:42.693 --> 00:42:47.265
questions. >> Like four minutes.
>> Until:45D 45. >> Yeah.

00:42:47.265 --> 00:42:49.267
Testing these like mobile app
containers right now isolation

00:42:49.267 --> 00:42:53.938
happens on mobile devices like
it's awesome, right? There is

00:42:53.938 --> 00:42:58.242
mobile platform that isn't
implementing some form much

00:42:58.242 --> 00:43:03.548
isolation. Now going to start
seeing APIs for letting remote

00:43:03.548 --> 00:43:09.253
service make a decision for the
user, right? It's scary at first

00:43:09.253 --> 00:43:15.760
when that decision becomes
remote service saying, hey, we

00:43:15.760 --> 00:43:17.762
think you're phone booted a
different firmware, different

00:43:17.762 --> 00:43:19.764
operating system would you like
to continue, yes or no. That

00:43:19.764 --> 00:43:21.766
kind of friction will end up for
people who are running egg

00:43:21.766 --> 00:43:27.305
things like Cyaongen or booting
different operating system. They

00:43:27.305 --> 00:43:31.209
already understand that there is
going to be couple of hiccups it

00:43:31.209 --> 00:43:34.745
should be the onerous of them to
load like the certificate for

00:43:34.745 --> 00:43:38.549
that engine model. >> Relates
back to rooting your phone or

00:43:38.549 --> 00:43:42.720
jail breaking your iPhone to run
things as root, and remove the

00:43:42.720 --> 00:43:46.157
security protections that have
been place there in the first

00:43:46.157 --> 00:43:49.026
place. Not that there is
anything wrong that you've made

00:43:49.026 --> 00:43:52.029
that conscious decision. So
having a server end kind of like

00:43:52.029 --> 00:43:54.532
give you the heads up say, wait
a minute, something's different.

00:43:54.532 --> 00:43:58.169
That would be a sweet feature
even still just kind of skip

00:43:58.169 --> 00:44:01.539
right past it and do it at your
discretion. >> We're using these

00:44:01.539 --> 00:44:05.243
like, how we all can start using
these hardware security

00:44:05.243 --> 00:44:08.946
primitives to push it into
something like a consumer can

00:44:08.946 --> 00:44:13.150
use. That decision, hey, your
phone booted in a different way,

00:44:13.150 --> 00:44:17.421
continue, yes or no. Then like
more info. Then we can deduce

00:44:17.421 --> 00:44:21.192
that down into a better decision
for them, probably don't know

00:44:21.192 --> 00:44:23.995
whether to hit yes or no. So we
can have a setting somewhere

00:44:23.995 --> 00:44:28.166
that says if my phone boots in a
mode that isn't trusted, here is

00:44:28.166 --> 00:44:31.502
the default option, right? Then
we can set that to please don't

00:44:31.502 --> 00:44:34.338
continue. >> It's really similar
to like the SSL validation,

00:44:34.338 --> 00:44:36.874
right, you go to a website in
chrome or somebody stops you

00:44:36.874 --> 00:44:41.412
says, wait a minute, this Cert
is wrong we skip right past

00:44:41.412 --> 00:44:44.715
that, similar concept, right?
Hopefully get to a point where

00:44:44.715 --> 00:44:48.185
there's enough to say, wait a
minute, this is bad or you

00:44:48.185 --> 00:44:53.124
really sure that you want to go.
Kind of has hints that have to

00:44:53.124 --> 00:44:57.528
it. >> Cool. I think next slide
will kill it. >> Done, great. >>

00:44:57.528 --> 00:44:59.664
If you're interested in this
stuff, if this was a little bit

00:44:59.664 --> 00:45:03.367
too high level or too basic of
an explanation for you, right?

00:45:03.367 --> 00:45:06.204
There's a lot more to look
forward to. If this definitely

00:45:06.204 --> 00:45:10.241
got your interest, go look at
these talks. Or please hit us up

00:45:10.241 --> 00:45:16.247
afterwards, definitely love to
talk to you. >> Thank you. >>

00:45:18.716 --> 00:45:22.053
Cool. Questions? [Applause]

