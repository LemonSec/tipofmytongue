00:00:00.000 --> 00:00:04.304
So we're going to start the
topic, Lance from 801. With

00:00:04.304 --> 00:00:09.209
that, he's going to talking
about his SQL injection. Nemus:

00:00:09.209 --> 00:00:13.881
thank you, my name is Lance, I
also go by the handle Nemus,

00:00:13.881 --> 00:00:18.785
part of myself, I'm from the
local Def Con group from Salt

00:00:18.785 --> 00:00:23.190
Lake City Utah, from DC801. If
you want to chat with us during

00:00:23.190 --> 00:00:26.193
the day, I help the hacker
space, in downtown assault lake,

00:00:26.193 --> 00:00:32.199
I plan events, things like that,
my hobbies, during the day, I

00:00:37.437 --> 00:00:42.042
write software for payment
solutions, my code in php and

00:00:42.042 --> 00:00:45.846
thigh upon, mostly, I also do
c., and basically, just the

00:00:45.846 --> 00:00:51.418
whole gamut of programming,
languages, also, if you are

00:00:51.418 --> 00:00:55.088
interested in listening to me
more, I'm part of the web

00:00:55.088 --> 00:01:00.127
security podcast, it's a new
podcast we're putting together

00:01:00.127 --> 00:01:02.129
for people who are interested in
security. It's mostly focused

00:01:02.129 --> 00:01:04.131
toward web developers and
focuses on introduction

00:01:04.131 --> 00:01:07.200
security-related topics. All
right. Quick disclaimer: I'm not

00:01:07.200 --> 00:01:13.206
responsible for anything you do
with what I teach you.

00:01:19.780 --> 00:01:24.017
[laughter] That's you. I am not
a lawyer, I can not tell you

00:01:24.017 --> 00:01:27.688
what is legal and what is not
legal. That's what lawyers are

00:01:27.688 --> 00:01:34.328
for. All right. Prereqs, this is
a 101 talk, so it's geared

00:01:34.328 --> 00:01:38.999
towards beginners, but you do
need to understand basic Linux

00:01:38.999 --> 00:01:43.637
operating systems, basic php
coding techniques, basically,

00:01:43.637 --> 00:01:46.974
you need to understand how to
set up a lamp server, and get

00:01:46.974 --> 00:01:50.644
php working on it, and write php
code, not a lot, just a little

00:01:50.644 --> 00:01:54.881
bit. I wrote this talk, it's
geared towards, beginning php

00:01:54.881 --> 00:02:01.388
developers, so they can learn
the basics, of php SQL injection

00:02:01.388 --> 00:02:07.594
security. If you are looking to
get into coding or just want to

00:02:07.594 --> 00:02:12.332
learn more about SQL injection
you can study up a little bit

00:02:12.332 --> 00:02:16.603
and come back to this talk. So
you don't have the prereqs,

00:02:16.603 --> 00:02:22.709
well, you will have a lot of fun
coming back to it later. So why

00:02:22.709 --> 00:02:28.582
do we study atax, right? You
hear the best defense is a good

00:02:28.582 --> 00:02:32.819
offense, right? But we can't
attack other systems, we can't

00:02:32.819 --> 00:02:35.622
go out and defend against the
world, it's basic lie, the world

00:02:35.622 --> 00:02:40.694
against us, we want to have our
code visible and available to

00:02:40.694 --> 00:02:44.064
our users, and our clients, and
basically the world, that's the

00:02:44.064 --> 00:02:48.468
way, the apps work, you set up
an app application, and want as

00:02:48.468 --> 00:02:53.840
many customers as you can find,
but the only way to secure it is

00:02:53.840 --> 00:02:58.412
understand how it's attacked,
you will be able to understand

00:02:58.412 --> 00:03:00.647
your weaknesses, and find good
solutions to mitigate those

00:03:00.647 --> 00:03:03.750
issues. So, basics of SQL
injection what causes SQL

00:03:03.750 --> 00:03:07.954
injection? Any time you have one
programming language, or you

00:03:07.954 --> 00:03:11.792
have one language writing code,
or writing executable

00:03:11.792 --> 00:03:13.860
instructions for another
language, are you going to have

00:03:13.860 --> 00:03:16.930
an injection flaw, it's inherit,
it's the nature of the beast, in

00:03:16.930 --> 00:03:20.300
this case, we're going to focus
on writing php writing SQL

00:03:20.300 --> 00:03:24.704
injection queries, if you have
two, php writing php, which I

00:03:24.704 --> 00:03:29.609
will talk about going over web
shells, are you going to have an

00:03:29.609 --> 00:03:32.679
injection problem, with that,
you have to validate user input

00:03:32.679 --> 00:03:35.949
and you have to make sure that
you are programming queries

00:03:35.949 --> 00:03:41.955
correctly, otherwise, the user
will be able to manipulate the

00:03:45.792 --> 00:03:51.798
string generated by the metal
wear and execute the code on the

00:03:58.839 --> 00:04:03.643
second layer. In this scenario,
I'm going to walk you through

00:04:03.643 --> 00:04:06.580
some php code, I posted it on
the slide, very simple, broke it

00:04:06.580 --> 00:04:13.987
down, I tried to make it very
concise so you can see, here's

00:04:13.987 --> 00:04:17.791
where the vulnerability and use
it to debug why your php is not

00:04:17.791 --> 00:04:23.797
working -- then once we're
finished with that, we're going

00:04:33.707 --> 00:04:36.676
to explore ways of uploading
code and taking advantage of the

00:04:36.676 --> 00:04:41.448
server. So this is a basic lab
set up, will you go over this

00:04:41.448 --> 00:04:47.787
real quick, you can back to this
later, design my talks as a lab,

00:04:47.787 --> 00:04:50.690
so later if you want to come
through and learn something and

00:04:50.690 --> 00:04:55.362
work through it. 	So we're going
to use curl. Curl is going to do

00:04:55.362 --> 00:04:59.199
our php requests, it's going to
format -- I like command line,

00:04:59.199 --> 00:05:02.702
there is also zed, and burp
suite, I don't have time to go

00:05:02.702 --> 00:05:06.039
over these steps, but they do
basically the same thing, we

00:05:06.039 --> 00:05:09.176
need something to help us craft
the php request so we're not

00:05:09.176 --> 00:05:15.182
hand coding it each time. 	So
this is my simple curl test

00:05:18.685 --> 00:05:23.056
script, we're taking parameters,
from the command line and

00:05:23.056 --> 00:05:29.062
feeding it to the variable, id,
to the get script. The command

00:05:31.298 --> 00:05:37.304
there is git curl, one php
request url, we will have it do

00:05:39.506 --> 00:05:44.511
data url encoding, which is how
we wanted input formatted, so

00:05:44.511 --> 00:05:46.813
all of your tax, will be
formatted correctly, and won't

00:05:46.813 --> 00:05:50.217
have issues of spacing, and
special characters. So when

00:05:50.217 --> 00:05:57.657
we're attacking lamp, we have to
think about the architecture,

00:05:57.657 --> 00:06:01.728
most basic lamp applications,
are going to start off on a

00:06:01.728 --> 00:06:08.068
single system, then the
application is running on a

00:06:08.068 --> 00:06:13.373
single server, then the data
running on another, in most

00:06:13.373 --> 00:06:16.343
cases, it will be running on the
same server, this makes it

00:06:16.343 --> 00:06:19.946
easier for attacking, once we
know we have found a

00:06:19.946 --> 00:06:25.719
vulnerability we can leverage
the database or one server, and

00:06:25.719 --> 00:06:29.756
working with one system. It's
more complicated when you get to

00:06:29.756 --> 00:06:33.893
an enterprise solution, so this,
we see we have low bouncer,

00:06:33.893 --> 00:06:37.731
database clusters, if I run a
data base, injection attack, I

00:06:37.731 --> 00:06:44.004
might run against the first,
second, or third server, and I

00:06:44.004 --> 00:06:50.844
won't know where my code is
executed, keep this in mind, you

00:06:50.844 --> 00:06:54.648
might have a vulnerability, or
doing something with the

00:06:54.648 --> 00:06:57.917
operating system, if you are
attacking the php code, you have

00:06:57.917 --> 00:07:01.988
to figure out which server is in
the loop -- so if you have a SQL

00:07:01.988 --> 00:07:07.661
injection query and writing
uploading shells, kit be pushing

00:07:07.661 --> 00:07:13.667
the shells to each one of the
databases, and you have to

00:07:18.071 --> 00:07:22.475
figure out how to execute that
code or the web shells on the

00:07:22.475 --> 00:07:28.748
different web servers, here's a
test database, it's a simple

00:07:28.748 --> 00:07:32.018
orders database, with columns,
we will create another database,

00:07:32.018 --> 00:07:39.326
with users, and put some users
in there. Using md5 hashes,

00:07:39.326 --> 00:07:43.763
here's our vulnerable simple
code, at the top, I show the

00:07:43.763 --> 00:07:51.638
request as the server sees it, I
have designed this to be what I

00:07:51.638 --> 00:07:55.475
would interpret would be out
there when people first start

00:07:55.475 --> 00:08:00.847
writing php code, the easiest
thing, they connect to my SQL

00:08:00.847 --> 00:08:05.719
injection database loop, just to
get it running, we have code to

00:08:05.719 --> 00:08:08.955
check to see if the connection
fails, then we run the query

00:08:08.955 --> 00:08:12.459
then we have the vulnerability,
is that we're concatenating, the

00:08:12.459 --> 00:08:18.064
string, because we're taking two
strings, and concatenating them,

00:08:18.064 --> 00:08:25.972
and not filtering the user input
we have created a SQL injection

00:08:25.972 --> 00:08:30.977
problem, that will allow a user
to take advantage of our

00:08:30.977 --> 00:08:36.383
database, which we did not
attend. So how does the

00:08:36.383 --> 00:08:39.753
attacker, attest for the SQL
injection? First we do anything,

00:08:39.753 --> 00:08:45.225
we want to verify that the
injection exists, in this

00:08:45.225 --> 00:08:48.495
presentation, I will focus on
blind SQL, I think for the most

00:08:48.495 --> 00:08:55.735
part, they have been turning off
error reporting, which is a good

00:08:55.735 --> 00:09:00.774
thing, but makes SQL for
difficult. Non blind are printed

00:09:00.774 --> 00:09:04.911
to the screen, you can use those
for what you need to do to build

00:09:04.911 --> 00:09:10.650
your query. So there is three
different types of SQL injection

00:09:10.650 --> 00:09:17.857
attacks, what you are going to
be doing is manipulating the

00:09:17.857 --> 00:09:23.129
strings, the numeric values, or
doing evaluation, the classic

00:09:23.129 --> 00:09:26.399
example is where you take
advantage of the login -- we

00:09:26.399 --> 00:09:30.470
know that the user is a valid
user on the web application. So

00:09:30.470 --> 00:09:36.476
like I said, we will be doing
numeric injection, here's the

00:09:43.316 --> 00:09:46.186
first test to the git curl
script that will pass the id

00:09:46.186 --> 00:09:52.926
forward, then we're going to do
select orders, for order numbers

00:09:52.926 --> 00:10:00.800
1 and 1, and we get the first
results, we do it again, and we

00:10:00.800 --> 00:10:05.171
get 1 and 0, we get no results,
what the and is doing is a

00:10:05.171 --> 00:10:10.643
binary saying, if it's 1 and 1,
it's true, so one, so return the

00:10:10.643 --> 00:10:14.814
first results, if it's 1 and 0,
that 0 so look for the 0

00:10:14.814 --> 00:10:18.818
results, there is no data there.
So with this, we can say, seems

00:10:18.818 --> 00:10:24.757
like there could be a possible
SQL injection vulnerability to

00:10:24.757 --> 00:10:30.063
do further testing, we do one
and true. True will be evaluated

00:10:30.063 --> 00:10:35.301
as one, and with one comes back
at one, we get the first record,

00:10:35.301 --> 00:10:40.773
one and false, false is 0, and
it come back with the record, do

00:10:40.773 --> 00:10:45.145
the same with minus, if it's
minus one, minus true, we see

00:10:45.145 --> 00:10:49.916
the results, we don't, 0 record,
then the dead give away, is if

00:10:49.916 --> 00:10:53.186
we can use multiplication,
against the data SQL database,

00:10:53.186 --> 00:10:58.658
we know we have an injection
flaw. We do one times, three,

00:10:58.658 --> 00:11:04.597
and on the third vulnerability,
we know it exists, I don't have

00:11:08.535 --> 00:11:11.237
the third record displayed
there, you don't see it f we got

00:11:11.237 --> 00:11:18.344
the first results back, we know,
okay this probably is not a SQL

00:11:18.344 --> 00:11:22.782
injection within this code, now
that we verified the injection

00:11:22.782 --> 00:11:25.051
exists, we need to verify, it's
running lamp stack, we need to

00:11:25.051 --> 00:11:31.057
figure what the web application
is running so we can attack it,

00:11:34.928 --> 00:11:38.164
so we're going to fingerprint
the server by looking at web

00:11:38.164 --> 00:11:42.802
requests and figure out our
architecture, so we can craft

00:11:42.802 --> 00:11:48.808
our queries. The easiest thing
you can do is curl-v, and look

00:11:52.045 --> 00:11:57.617
at the headers, that will tell
you a lot about the application

00:11:57.617 --> 00:12:02.355
and the metal ware, and the
apache -- or web application

00:12:02.355 --> 00:12:05.792
sorry the web server, I will
tell you the web server, and the

00:12:05.792 --> 00:12:10.997
possible metal code that is
running, these are the ones you

00:12:10.997 --> 00:12:15.735
can turn off, so it makes it
harder to guess what is going on

00:12:15.735 --> 00:12:18.972
in the architecture, here we're
blindly telling people, I'm

00:12:18.972 --> 00:12:22.008
running apache c.p. OS, and the
operating system, and the

00:12:22.008 --> 00:12:24.510
server, m-map is identified as
the apache, and s. OS, we do the

00:12:24.510 --> 00:12:26.613
OS fingerprinting, apache, sent
OS. Another thing we can do is

00:12:26.613 --> 00:12:28.715
use signatures, to identify web
servers, here we run the command

00:12:28.715 --> 00:12:30.817
against server on port 80s, it
tells us, probability score, 76

00:12:30.817 --> 00:12:33.586
confidence this is an apache web
server, we can say with

00:12:33.586 --> 00:12:37.824
confidence that the web server
is running apache, and we know

00:12:37.824 --> 00:12:40.593
what we're going up against.
Next, we need to identify

00:12:40.593 --> 00:12:43.062
database. So we have identified
we're running the Linux

00:12:43.062 --> 00:12:45.565
operating system, and we're
running apache, as the web

00:12:45.565 --> 00:12:48.701
server, next we're going to do
is identify what the database

00:12:48.701 --> 00:12:52.372
version is or you know determine
if it's my SQL, postgre SQL or

00:12:52.372 --> 00:12:54.841
other stuff out there. You can
guess with a probability,

00:12:54.841 --> 00:12:56.843
they're running my SQL on the
back end, to do this, we're

00:12:56.843 --> 00:12:58.845
going to use a union select
poisoning query, we will take

00:12:58.845 --> 00:13:00.780
the original query that the
developer wrote, mirror it with

00:13:00.780 --> 00:13:02.782
our own code, and match those
up, so the result set is

00:13:02.782 --> 00:13:04.784
returned together, so what you
do is write a select id, do

00:13:04.784 --> 00:13:06.786
union, select, then you got to
figure out how many columns are

00:13:06.786 --> 00:13:08.788
in that query so that the union
will match the original query.

00:13:08.788 --> 00:13:10.790
So you start with one, and you
numerate, 2, 3, 4, 5, once you

00:13:10.790 --> 00:13:12.792
get a valid result back, you can
then know how many parameters

00:13:12.792 --> 00:13:14.794
that need to be in that union
select, so it matches the

00:13:14.794 --> 00:13:16.796
original queries column count.
So here, we have our union

00:13:16.796 --> 00:13:18.798
select, I used nulls, you can
use 1's, you basically want to

00:13:18.798 --> 00:13:20.800
avoid things, that use special
characters, so it can get passed

00:13:20.800 --> 00:13:22.802
filters and other things. That's
a more complicated suggest, by

00:13:22.802 --> 00:13:24.804
passing, web filters, just to
keep in mind, don't use ticks,

00:13:24.804 --> 00:13:26.806
use pretty safe SQL queries,
here, we're using the user

00:13:26.806 --> 00:13:28.808
select with the original query,
and match it up, so the last

00:13:28.808 --> 00:13:30.810
column, we're going to have the
database version which is 5.540.

00:13:30.810 --> 00:13:32.812
So next, what we're going to do
is use the con cat function in

00:13:32.812 --> 00:13:36.716
SQL which is different between
all of the different databases,

00:13:36.716 --> 00:13:42.722
so my SQL and oracle are
similar, so we need to identify

00:13:57.437 --> 00:14:03.376
that it is a my SQL database,
not oracle, database, here, we

00:14:18.091 --> 00:14:24.097
do dot one dot one dot one
ticks, and when we get back here

00:14:42.248 --> 00:14:48.254
the line where the merge merges
the query, the a.b. we know it

00:14:57.563 --> 00:15:00.666
worked. We don't get results, it
returned 0, so we're fairly

00:15:00.666 --> 00:15:04.837
certain we have a my SQL
database on the back end. At

00:15:04.837 --> 00:15:10.143
this point, we have the version
number and all that version

00:15:10.143 --> 00:15:15.948
seems to correlate to my SQL. We
have a good understanding of

00:15:15.948 --> 00:15:21.721
what we're up against. Now we
can start pulling data from the

00:15:21.721 --> 00:15:26.659
architecture. So at this point,
you have the select statement,

00:15:26.659 --> 00:15:31.430
we're going to try and get as
much data as we possibly can out

00:15:31.430 --> 00:15:35.735
of database. Your attacker, may
select items, user names and

00:15:35.735 --> 00:15:41.607
passwords at this point, I will
show you how your data will be

00:15:41.607 --> 00:15:47.013
stolen out of your database just
from this one flaw. So first

00:15:47.013 --> 00:15:52.418
thing we're going to do is
enumerate the user, of the my

00:15:52.418 --> 00:15:56.489
SQL database, not the my
application, or the program.

00:15:56.489 --> 00:16:00.493
This is the database that
maintains, access to the

00:16:00.493 --> 00:16:05.431
connections to the database. So
we're going to use a union

00:16:05.431 --> 00:16:09.969
select we're going to select
host, user, password, then null

00:16:09.969 --> 00:16:13.940
out the rest from my SQL dot
user, so if the credentials, set

00:16:13.940 --> 00:16:16.909
up on the php are root, we will
have access to this database. If

00:16:16.909 --> 00:16:19.011
they secured their credentials,
we don't have access to table,

00:16:19.011 --> 00:16:21.981
you can see here, I was able to
determine the local host has a

00:16:21.981 --> 00:16:24.116
connection, use, then a patch
word, hash, from the database,

00:16:24.116 --> 00:16:27.086
here we get the post name, from
the user select, if you need to

00:16:27.086 --> 00:16:29.422
have more data in your union
select then the column count

00:16:29.422 --> 00:16:31.757
has, you can use concat, to get
more columns from different

00:16:31.757 --> 00:16:34.060
tables into one column, and get
that returned with the union.

00:16:34.060 --> 00:16:36.195
Another interesting thing, you
can use the u.u. id, function,

00:16:36.195 --> 00:16:39.165
to get the mac address, I did
verify this, I didn't know if it

00:16:39.165 --> 00:16:41.767
works on all architectures, the
first or last part, is the u.u.

00:16:41.767 --> 00:16:45.238
id, s., that is useful for
attacking -- the database is

00:16:45.238 --> 00:16:49.308
connected to. Then with this
command here, you can see it

00:16:49.308 --> 00:16:54.447
gets complicated, this dumps all
of the tables and columns from

00:16:54.447 --> 00:16:59.585
the my SQL database that has
access to, there is more

00:16:59.585 --> 00:17:04.690
information there. Then see we
have our output, we have the

00:17:04.690 --> 00:17:09.829
order details, order number,
tells us the column names, so we

00:17:09.829 --> 00:17:14.967
can go through this and see
where the interesting points of

00:17:14.967 --> 00:17:21.974
data might be. Next what we will
do is pull all of the users from

00:17:21.974 --> 00:17:27.246
the web application this is
usually a table called logins or

00:17:27.246 --> 00:17:30.483
users, something like that in
the web application itself is

00:17:30.483 --> 00:17:32.485
going to contain a clear text
password, or assaulted hash

00:17:32.485 --> 00:17:34.487
password, we will pull that data
and get users, to log into the

00:17:34.487 --> 00:17:36.489
web application. So we do that
by just doing union select and

00:17:36.489 --> 00:17:38.491
pulling that information from
this login table we had earlier.

00:17:38.491 --> 00:17:40.493
Now that we have hashes, and
user names, with you thing we

00:17:40.493 --> 00:17:42.495
can do to attack this one by one
application is crack these

00:17:42.495 --> 00:17:44.497
hashes, before you can do that,
you need to identify what these

00:17:44.497 --> 00:17:46.499
hashes are. And one cool you can
use to do that is hash id, hash

00:17:46.499 --> 00:17:49.468
id is running in python three,
so you will need to set up a

00:17:49.468 --> 00:17:51.504
python three environment to
identify the hashes, just a

00:17:51.504 --> 00:17:53.739
quick thing on password hashing,
don't use m.d. five, right?

00:17:53.739 --> 00:17:55.808
Easy, reversible, it's been
around forever, the guy who

00:17:55.808 --> 00:17:58.744
wrote it, stop using it, to this
day, I still find m.d. five

00:17:58.744 --> 00:18:02.682
hashes. If you can, use password
hash, it's a php function and

00:18:02.682 --> 00:18:08.154
the newer versions of php, it
will be included in default, if

00:18:08.154 --> 00:18:13.192
you are running an older
version, you can use php pass,

00:18:13.192 --> 00:18:19.165
with crypt, and use the salt
word pass for you, and takes the

00:18:19.165 --> 00:18:24.203
difficulty out of it, we used
the same password twice, and

00:18:24.203 --> 00:18:29.241
generated a new password each
time, if you are interested in

00:18:29.241 --> 00:18:33.379
passing hash or cracking, you
can reference this information,

00:18:33.379 --> 00:18:39.018
hash cat is pretty good, john
ripper is great. SQL map which I

00:18:39.018 --> 00:18:42.722
will talk about a little bit
later, it has a password crack

00:18:42.722 --> 00:18:47.093
in itself just a touch on
rainbow tables, they liar

00:18:47.093 --> 00:18:51.464
password crackers, but they're
stored in the database so you

00:18:51.464 --> 00:18:56.736
are not generating a new hash
each time to compare it against,

00:18:56.736 --> 00:19:01.374
you want to use a combination of
both password cracking and

00:19:01.374 --> 00:19:07.380
rainbow tables, testing the
security of your hashes. Quick

00:19:33.806 --> 00:19:36.976
example; I ran md5s, through
hash cat, with gpu's reminder,

00:19:36.976 --> 00:19:41.113
with the four gpu's, I was able
to get the passwords, rock you

00:19:41.113 --> 00:19:44.950
list within 2 or 3 minutes. All
right, now for more interesting

00:19:44.950 --> 00:19:48.788
stuff, we attacked the database,
now what we're going to do is

00:19:48.788 --> 00:19:52.591
attack the operating system of
the database, we are going to do

00:19:52.591 --> 00:19:56.729
that by looking at files on that
system. So going back to our

00:19:56.729 --> 00:19:59.932
architecture, if the database,
and serve are sitting on the

00:19:59.932 --> 00:20:04.403
same system, you might be able
to look at the code files on the

00:20:04.403 --> 00:20:07.907
system, using your SQL injection
technique. By doing this, I load

00:20:07.907 --> 00:20:11.577
the file, then use union select,
to push that file out, and I can

00:20:11.577 --> 00:20:17.583
view, hey, here's the user name
and password for database, and I

00:20:32.731 --> 00:20:35.868
just gotten credentials that
way. So this goes back to your

00:20:35.868 --> 00:20:39.305
web server set up -- your web
server set up. Nothing is

00:20:39.305 --> 00:20:41.941
working, right? You odd 777,
right? [laughter] Get it to

00:20:41.941 --> 00:20:47.947
work. This is why you don't want
to do that, if that 777 in my

00:21:05.564 --> 00:21:11.570
SQL user can touch that and if
there is a SQL injection

00:21:34.527 --> 00:21:36.529
vulnerability, I can overwrite
that, which I will show later,

00:21:36.529 --> 00:21:38.531
this comes down to, if you have
a my SQL database, and web

00:21:38.531 --> 00:21:40.533
application running on the same
server, you want to make sure

00:21:40.533 --> 00:21:42.535
that the one by one application
is not running with the same

00:21:42.535 --> 00:21:44.537
privileges of the database, you
want them in completely

00:21:44.537 --> 00:21:46.539
separated, isolated
environments, the default, set

00:21:46.539 --> 00:21:48.541
-- appear to have that
separation, but a lot of times,

00:21:48.541 --> 00:21:50.543
administrators, will push
everything as root users, then

00:21:50.543 --> 00:21:52.545
everything can touch, and cross
contaminate, and you can modify

00:21:52.545 --> 00:21:54.547
files. So here, by default, so
this is my attack against the

00:21:54.547 --> 00:21:56.549
operating system and by default,
I was able to pull epsy,

00:21:56.549 --> 00:21:58.551
password, as the my SQL
database, I got a list of users,

00:21:58.551 --> 00:22:00.486
from the epsy, password file,
luckily, I was not able to read

00:22:00.486 --> 00:22:02.488
the epsy, shadow files, from the
database passwords, that is at

00:22:02.488 --> 00:22:04.490
least secure and blind from me
on a default configuration, now

00:22:04.490 --> 00:22:06.492
I have user names, I can use for
brute force or attack against

00:22:06.492 --> 00:22:08.494
other servers, here's
interesting, readable files, you

00:22:08.494 --> 00:22:10.496
can get resolve.com message of
the day sshd config other

00:22:10.496 --> 00:22:12.498
places, or the patch, you can
figure out how the server is

00:22:12.498 --> 00:22:14.500
configured, at this point, you
will be thinking, I got this

00:22:14.500 --> 00:22:16.502
select vulnerability so I want
to modify the database, so it

00:22:16.502 --> 00:22:18.504
can be much easier to rewrite
the hash on the login table and

00:22:18.504 --> 00:22:20.506
then login with a password that
I already know, if you have a

00:22:20.506 --> 00:22:22.508
SQL injection, and you are using
union select, I was not able to

00:22:22.508 --> 00:22:24.510
find a way to do insert, update,
for a sub and nesting query.

00:22:24.510 --> 00:22:26.512
That's when you have a query
inside of a query, with the

00:22:26.512 --> 00:22:28.514
"where", statement, is the
selecting item, is the query

00:22:28.514 --> 00:22:30.516
result returned from future
query. So just a little bit more

00:22:30.516 --> 00:22:32.518
about subqueries. Like I said, I
wasn't able to figure out, if

00:22:32.518 --> 00:22:34.520
someone can do that, I would be
really interested in seeing your

00:22:34.520 --> 00:22:36.522
results. So bobby drop tables,
right? We cannot have a talk

00:22:36.522 --> 00:22:38.524
about SQL injection without
bobby-drop tables, it's not just

00:22:38.524 --> 00:22:40.526
not possible. So you are like,
oh, I can modify the database,

00:22:40.526 --> 00:22:42.528
just using a semicolon and then
[inaudible] the query, and

00:22:42.528 --> 00:22:44.530
running another query, if the up
to date version of my SQL query,

00:22:44.530 --> 00:22:46.532
of php, it was not able to use
query stacking, excuse me. So no

00:22:46.532 --> 00:22:48.534
bobby drop tables,
unfortunately, there is a my SQL

00:22:48.534 --> 00:22:50.536
multiquery that gives you this
functionality. Why would you use

00:22:50.536 --> 00:22:52.538
it? I don't know. The problems
with php, it lets you do all

00:22:52.538 --> 00:22:54.540
kinds of things, you probably
shouldn't. Okay, some fun stuff,

00:22:54.540 --> 00:22:56.542
we will go going to go onto
remote code execution, at this

00:22:56.542 --> 00:22:58.544
point, we got user names and
pass ward words, and look at how

00:22:58.544 --> 00:23:00.479
we can attack this architecture.
Web shells are great. What we're

00:23:00.479 --> 00:23:02.481
going to do with web shells is
demonstrate how you can use php

00:23:02.481 --> 00:23:04.483
code to put a simple backdoor,
that will be executed by the web

00:23:04.483 --> 00:23:06.485
server, and possibly, by the web
server, operating system, user

00:23:06.485 --> 00:23:08.487
web shell functions, that php
has. This is a good idea to

00:23:08.487 --> 00:23:10.489
disable these, if you don't need
them, I can guarantee that you

00:23:10.489 --> 00:23:12.491
don't need them. So we don't
need execute, shell execute. If

00:23:12.491 --> 00:23:14.493
you are running shell execute,
the only real example is if you

00:23:14.493 --> 00:23:16.495
are writing code for net gear or
something like that, or one of

00:23:16.495 --> 00:23:18.497
those small home office,
networking appliances, with

00:23:18.497 --> 00:23:20.499
operating system code, to do
that, you need to make sure you

00:23:20.499 --> 00:23:22.501
are properly, escaping, or have
injection problems, as an

00:23:22.501 --> 00:23:24.503
attacker, we can take advantage
of this function to run code on

00:23:24.503 --> 00:23:26.505
this operating system. Eval. I
hate eval. Don't use it php

00:23:26.505 --> 00:23:28.507
coder, please don't use eval. I
can't think of a reason to do

00:23:28.507 --> 00:23:30.509
it, what eval does is takes a
string of code and executes it,

00:23:30.509 --> 00:23:32.511
so you can write php code, that
exkites php code. I have seen

00:23:32.511 --> 00:23:34.513
weird stuff, I have seen
developers, put php code, from

00:23:34.513 --> 00:23:36.515
strings in the database, and
execute it, don't use eval. I

00:23:36.515 --> 00:23:38.517
can't stress this enough,
disable it, get rid of it, one

00:23:38.517 --> 00:23:40.519
of the more hidden one is
assert, it does the same thing,

00:23:40.519 --> 00:23:42.521
but it's used by developers, to
test code, to make sure

00:23:42.521 --> 00:23:44.523
operations are running
correctly, and their conditions

00:23:44.523 --> 00:23:46.525
are what they example them to
do, so you got to make sure, if

00:23:46.525 --> 00:23:48.527
you are using assert, are you
doing it directly, and you are

00:23:48.527 --> 00:23:50.529
not providing user input into
the assert, that isn't sanitized

00:23:50.529 --> 00:23:52.531
or clean, we have the create
function. It's great, takes a

00:23:52.531 --> 00:23:54.533
string of code and turns it into
a function you can call later,

00:23:54.533 --> 00:23:56.535
then using dynamic variables, in
php, we can call any function in

00:23:56.535 --> 00:23:58.537
the code, another couple of
dangerous functions is acollude.

00:23:58.537 --> 00:24:00.472
By default, you can start php
code on a remote server, if you

00:24:00.472 --> 00:24:02.474
have access, to the function by
dynamic variable code, remotely,

00:24:02.474 --> 00:24:04.476
so it's a good idea to disable
that function. 	We're going to

00:24:04.476 --> 00:24:06.478
call the system, pass in a git
parameter, called the command,

00:24:06.478 --> 00:24:08.480
we call the url, by a curl, or
the web browser, pass the

00:24:08.480 --> 00:24:10.482
command ls, or get the output,
and see these files, shell.php

00:24:10.482 --> 00:24:12.484
is on the server, we can use a
php eval to run php commands and

00:24:12.484 --> 00:24:14.486
do a little bit more discrete
backdoor by running preg

00:24:14.486 --> 00:24:16.488
replace. It looks pretty benign.
You are looking for the code,

00:24:16.488 --> 00:24:18.490
preg-replace, you can sneak that
in there, passed your review, to

00:24:18.490 --> 00:24:20.492
get passed your code, I don't
have time to go into super

00:24:20.492 --> 00:24:22.494
details, about shells, but iron
geek, has web shells for pretty

00:24:22.494 --> 00:24:24.496
much any architecture, you can
think of. So remote code

00:24:24.496 --> 00:24:26.498
execution, there exists a
multiple avenues of attack, we

00:24:26.498 --> 00:24:28.500
can attempt, first we will
upload the php script, by the my

00:24:28.500 --> 00:24:30.502
SQL write function, if it has
chmodo -- files, I can over rite

00:24:30.502 --> 00:24:32.504
by the file and web server on
the system, I can upload code,

00:24:32.504 --> 00:24:34.506
using a feature, if the web
application has a file of a

00:24:34.506 --> 00:24:36.508
picture upload, I can take a
picture of that, and see if I

00:24:36.508 --> 00:24:38.510
can get it to pass to the file,
and later execute it through the

00:24:38.510 --> 00:24:40.512
url, third is a last-ditch
effort, a social engineering

00:24:40.512 --> 00:24:42.514
attack. I will talk about
wildcard poisoning. This is a

00:24:42.514 --> 00:24:44.516
vulnerability feature, it's been
in Linux for a very long time,

00:24:44.516 --> 00:24:46.518
it's been on the full disclosure
list, which is where I found it,

00:24:46.518 --> 00:24:48.520
basically, it takes advantage of
the Linux star commands, to run

00:24:48.520 --> 00:24:50.522
commands, it's kind of an
injection attack itself. So

00:24:50.522 --> 00:24:52.524
writing files. Here we're going
to use the into/out file, which

00:24:52.524 --> 00:24:54.526
is going to take our php code
and push it to slash ten. I know

00:24:54.526 --> 00:24:56.528
by default, most applications,
can write to slash ten, so I

00:24:56.528 --> 00:24:58.530
look at the query runs, see it.
There, it is. If I'm looking for

00:24:58.530 --> 00:25:02.501
right points, I can look at
temp, cap, images, files and

00:25:02.501 --> 00:25:05.037
basically enumerate the web
applications for weak

00:25:05.037 --> 00:25:08.707
permissions, writable files, by
my SQL. This is the default.

00:25:08.707 --> 00:25:13.112
These are the only ones of
interest I could find. So

00:25:13.112 --> 00:25:18.684
default install. It's kind of
secure in the fact that my SQL

00:25:18.684 --> 00:25:24.690
user is a different user, that
doesn't have permissions on the

00:25:27.993 --> 00:25:33.999
web server, like I said, again,
if the web server, and database

00:25:38.103 --> 00:25:44.109
are running on the same system,
and they have the same

00:25:47.379 --> 00:25:53.385
permissions, at this point, I
can change those files. 	Like I

00:25:56.688 --> 00:26:02.628
said, this is what I talked
about earlier, here's more

00:26:05.063 --> 00:26:12.671
detail, about black cat
presentation done a couple of

00:26:12.671 --> 00:26:18.677
years ago, it's got more detail,
on remote code -- excuse me, and

00:26:20.779 --> 00:26:23.982
remote code filing, so
application feature. What we're

00:26:23.982 --> 00:26:26.552
going to do if filtered, we will
upload a php file. If not, we

00:26:26.552 --> 00:26:30.856
will try to manipulate a php
file I so it can be uploaded.

00:26:30.856 --> 00:26:33.759
Here's example of vulnerable
code. All it does is take files

00:26:33.759 --> 00:26:36.628
turn them to user and upload
them. So that's one-way. 	There

00:26:36.628 --> 00:26:39.531
is another examples you can look
on there, and dig deeper,

00:26:39.531 --> 00:26:42.601
getting passed filters, stuff
like that, that is a little bit

00:26:42.601 --> 00:26:45.070
more advanced. If you can't
write files on the web server,

00:26:45.070 --> 00:26:48.040
and you can't upload files, one
thing you could try is doing a

00:26:48.040 --> 00:26:50.742
wildcard poisoning attack on the
system. So if my SQL user can

00:26:50.742 --> 00:26:53.479
write files, it can write to
var-log SQL, so one thing you

00:26:53.479 --> 00:26:56.682
can do to attack the system, is
fill up the disk with my SQL

00:26:56.682 --> 00:26:58.951
general log. (no audio) Off the
system, so using wildcard

00:26:58.951 --> 00:27:01.153
poisoning, we have the ls
command, the ls-l and ls-star.

00:27:01.153 --> 00:27:03.889
If I have a file on the
operating system, that is-l, and

00:27:03.889 --> 00:27:06.859
I do an ls-star, that dash l is
interpreted, as being passed to

00:27:06.859 --> 00:27:09.361
the ls command, we can take
advantage of that, the purpose

00:27:09.361 --> 00:27:12.064
concept here is on the defensive
code, I have provided the link,

00:27:12.064 --> 00:27:14.800
what this does is in this
example is it takes advantage of

00:27:14.800 --> 00:27:17.536
s-copy, no, this takes advantage
of tar, the other one is s-copy.

00:27:17.536 --> 00:27:20.506
The might tar up the file, tar
has a parameter that will pass

00:27:20.506 --> 00:27:23.442
it, so you can execute code, you
can upload file names, set them

00:27:23.442 --> 00:27:25.944
up correctly this is something
you want to test because the

00:27:25.944 --> 00:27:28.881
order is important, you want to
make sure the file is in the

00:27:28.881 --> 00:27:31.583
correct order, then the
administrator comes in, to

00:27:31.583 --> 00:27:33.919
s-copy or tar up this file,
they're going to run this

00:27:33.919 --> 00:27:35.921
vulnerable code and possibly get
a shell or get access to the

00:27:35.921 --> 00:27:37.923
system, here's the s-copy
example, that uses the dash 0

00:27:37.923 --> 00:27:39.925
command to run a script. So a
little bit about reverse shells,

00:27:39.925 --> 00:27:41.927
last year, I did a Def Con talk
about intro to backdoors, we

00:27:41.927 --> 00:27:43.929
talked about shells, and netcat,
stuff like that, if you are

00:27:43.929 --> 00:27:45.931
interested, this is a basic php
reverse shell taken from

00:27:45.931 --> 00:27:47.933
pentestmonkey.net, you can do a
php-r., and get remote code on

00:27:47.933 --> 00:27:49.935
the system, you can set up
remote cat on the listener, bam,

00:27:49.935 --> 00:27:51.937
you got commands you can run.
All right, so what we have seen

00:27:51.937 --> 00:27:53.939
from this is through just a
simple vulnerability, somebody

00:27:53.939 --> 00:27:55.941
barely learning php code has
completely left their system

00:27:55.941 --> 00:27:57.943
unsecured, we're able to steal a
lot of data, we're able to take

00:27:57.943 --> 00:27:59.945
advantage of the system, and
possibly gain control of the

00:27:59.945 --> 00:28:01.880
system, just a little bit of
recap, the epsy passwords -- you

00:28:01.880 --> 00:28:03.882
have a good understand of
injection, a lot of this is

00:28:03.882 --> 00:28:05.884
built into the SQL map tool,
with this you can run the

00:28:05.884 --> 00:28:07.886
queries, and run the tool
better, I encourage you to get

00:28:07.886 --> 00:28:09.888
in there, run the SQL map and
learn how it works, here's

00:28:09.888 --> 00:28:11.890
injection resources too, if you
are interested. Other thing you

00:28:11.890 --> 00:28:13.892
might want to research too is
privilege escalation, by

00:28:13.892 --> 00:28:16.161
default, these systems, the
apache service and the my SQL

00:28:16.161 --> 00:28:18.864
service is not running with root
privileges, if you want to get

00:28:18.864 --> 00:28:21.366
full access to the system, you
will need to do privilege

00:28:21.366 --> 00:28:23.368
escalation. Here's examples of
php secure code, if you want to

00:28:23.368 --> 00:28:26.238
write php secure code, filter
input, php has a great filter

00:28:26.238 --> 00:28:30.442
input library. Just set your
variable length, when you are

00:28:30.442 --> 00:28:36.448
talking it in, one thing you can
to limit the damage, if you have

00:28:43.021 --> 00:28:49.027
a string that is not supposed to
be more than characters, cut it

00:28:54.733 --> 00:29:00.672
off. My SQL has user define
functions this is pretty cool.

00:29:04.543 --> 00:29:11.049
If you want to get into advanced
stuff to take advantage of the

00:29:11.049 --> 00:29:15.487
my SQL system. Here's some
security guides on how to harden

00:29:15.487 --> 00:29:19.858
your lamp stack. Then for some
code review and analysis, here's

00:29:19.858 --> 00:29:25.864
free tools, the rip scanner is
kind of old, but kind of gives

00:30:01.066 --> 00:30:04.569
you an insight where you might
have vulnerabilities, in your

00:30:04.569 --> 00:30:10.575
php code. Here's my credits,
from icon archive, and the

00:32:01.520 --> 00:32:04.856
background is from pand the
background is from ppt

00:32:04.856 --> 00:32:10.862
backgrounds. Thank you.
[applause] 

