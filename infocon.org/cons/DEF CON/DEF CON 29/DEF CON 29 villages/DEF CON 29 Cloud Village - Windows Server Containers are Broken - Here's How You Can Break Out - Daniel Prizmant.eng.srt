1
00:00:00,560 --> 00:00:03,840
uh so uh hello everyone uh welcome and

2
00:00:03,840 --> 00:00:05,839
thank you for joining me

3
00:00:05,839 --> 00:00:08,720
you're about to hear a story about uh

4
00:00:08,720 --> 00:00:11,120
how a single mission condition in uh if

5
00:00:11,120 --> 00:00:12,240
statement

6
00:00:12,240 --> 00:00:14,480
enabled one of the easiest container

7
00:00:14,480 --> 00:00:16,560
escape of recent years

8
00:00:16,560 --> 00:00:18,960
so let's just get started

9
00:00:18,960 --> 00:00:22,320
okay so who am i

10
00:00:22,320 --> 00:00:24,160
my name is daniel prismant and i'm a

11
00:00:24,160 --> 00:00:26,480
senior security researcher at the palo

12
00:00:26,480 --> 00:00:27,760
alto networks

13
00:00:27,760 --> 00:00:29,679
i usually do reverse engineering in

14
00:00:29,679 --> 00:00:32,479
windows platform for years i joined the

15
00:00:32,479 --> 00:00:34,880
containers focus team that mostly did

16
00:00:34,880 --> 00:00:36,960
like open source vulnerability research

17
00:00:36,960 --> 00:00:38,480
on cloud products

18
00:00:38,480 --> 00:00:41,520
our team are full of security research

19
00:00:41,520 --> 00:00:44,160
focused on finding vulnerabilities on

20
00:00:44,160 --> 00:00:46,800
the cloud and i was the only windows guy

21
00:00:46,800 --> 00:00:49,280
in the team so i decided to focus on

22
00:00:49,280 --> 00:00:52,239
windows containers

23
00:00:53,039 --> 00:00:54,879
okay so i'll go over the agenda real

24
00:00:54,879 --> 00:00:56,879
quick we will start things off with the

25
00:00:56,879 --> 00:00:59,680
demo to show you guys the impact of this

26
00:00:59,680 --> 00:01:00,719
issue

27
00:01:00,719 --> 00:01:03,199
i will then cover containers in general

28
00:01:03,199 --> 00:01:05,600
and windows containers in particular i

29
00:01:05,600 --> 00:01:07,119
will also go over some of the

30
00:01:07,119 --> 00:01:09,840
fundamentals that one needs to know in

31
00:01:09,840 --> 00:01:11,760
order to fully understand the issue i'll

32
00:01:11,760 --> 00:01:13,360
be covered

33
00:01:13,360 --> 00:01:15,520
i will cover the issue itself what made

34
00:01:15,520 --> 00:01:18,320
it possible and after that we will cover

35
00:01:18,320 --> 00:01:21,040
how cloud providers are affected by this

36
00:01:21,040 --> 00:01:22,080
issue

37
00:01:22,080 --> 00:01:24,159
and lastly we'll briefly talk about

38
00:01:24,159 --> 00:01:25,920
malware that took advantage of this

39
00:01:25,920 --> 00:01:27,520
issue to gain some

40
00:01:27,520 --> 00:01:29,200
free processing power

41
00:01:29,200 --> 00:01:30,799
and when we're finished i will try

42
00:01:30,799 --> 00:01:32,000
answering some of the questions you

43
00:01:32,000 --> 00:01:34,240
might have

44
00:01:34,240 --> 00:01:35,520
okay

45
00:01:35,520 --> 00:01:36,720
uh

46
00:01:36,720 --> 00:01:38,799
okay let's let's get started with uh

47
00:01:38,799 --> 00:01:40,400
with the demo

48
00:01:40,400 --> 00:01:44,399
i will try to explain it while it runs

49
00:01:46,079 --> 00:01:48,880
okay so first of all i'm deploying a

50
00:01:48,880 --> 00:01:52,640
kubernetes yaml i took this yaml from

51
00:01:52,640 --> 00:01:55,040
the kubernetes official website i didn't

52
00:01:55,040 --> 00:01:56,880
change anything the only thing i'm doing

53
00:01:56,880 --> 00:01:59,040
here is applying a deployment

54
00:01:59,040 --> 00:02:01,680
when stating that the node i'm choosing

55
00:02:01,680 --> 00:02:04,799
is windows and not linux

56
00:02:04,799 --> 00:02:06,880
so we created the it created two

57
00:02:06,880 --> 00:02:09,679
deployments for me

58
00:02:09,679 --> 00:02:11,680
and i'm checking that they are actually

59
00:02:11,680 --> 00:02:14,400
running and at this point i'm executing

60
00:02:14,400 --> 00:02:16,959
into the container i will explain more

61
00:02:16,959 --> 00:02:17,920
uh

62
00:02:17,920 --> 00:02:20,080
in the next in the next slide

63
00:02:20,080 --> 00:02:22,000
for now i'm mimicking an attacker

64
00:02:22,000 --> 00:02:24,319
actually gaining

65
00:02:24,319 --> 00:02:28,079
execution inside the container

66
00:02:28,800 --> 00:02:30,560
so as you can see i'm inside the windows

67
00:02:30,560 --> 00:02:33,840
container i move to c and i'm making a

68
00:02:33,840 --> 00:02:36,480
directory for all my files for the

69
00:02:36,480 --> 00:02:37,440
breakup

70
00:02:37,440 --> 00:02:39,120
i prepared them beforehand i will

71
00:02:39,120 --> 00:02:40,800
explain more in

72
00:02:40,800 --> 00:02:43,360
the rest of the talk downloading all the

73
00:02:43,360 --> 00:02:46,400
tools i created to to make breakout

74
00:02:46,400 --> 00:02:48,480
basically it's a dll which carries the

75
00:02:48,480 --> 00:02:50,959
logic itself and injector which inject

76
00:02:50,959 --> 00:02:52,879
the dll into one of the

77
00:02:52,879 --> 00:02:55,040
containers processes

78
00:02:55,040 --> 00:02:57,280
as you can see i use the injector it

79
00:02:57,280 --> 00:03:00,640
injected itself into the main container

80
00:03:00,640 --> 00:03:01,840
process

81
00:03:01,840 --> 00:03:04,879
and i also made a log file

82
00:03:04,879 --> 00:03:06,319
which will log

83
00:03:06,319 --> 00:03:09,599
what happened from inside that process i

84
00:03:09,599 --> 00:03:11,680
created a symbolic link

85
00:03:11,680 --> 00:03:13,280
to the host

86
00:03:13,280 --> 00:03:14,879
how it may how it trustable i will

87
00:03:14,879 --> 00:03:16,080
explain later

88
00:03:16,080 --> 00:03:19,120
and for now i'm only doing a simple copy

89
00:03:19,120 --> 00:03:21,920
file from the host using the symbolic

90
00:03:21,920 --> 00:03:23,760
link i created

91
00:03:23,760 --> 00:03:25,840
and i'm copying a file from the host to

92
00:03:25,840 --> 00:03:27,440
the container so i will have access to

93
00:03:27,440 --> 00:03:31,959
it from inside our container

94
00:03:32,000 --> 00:03:34,799
the file i'm copying is the config file

95
00:03:34,799 --> 00:03:36,720
of the node it's the config file that

96
00:03:36,720 --> 00:03:38,319
the node

97
00:03:38,319 --> 00:03:41,519
uses in order to to talk with the api

98
00:03:41,519 --> 00:03:44,480
master server of kubernetes

99
00:03:44,480 --> 00:03:47,280
as you can see it okay it contains all

100
00:03:47,280 --> 00:03:49,920
all the certificates and keys

101
00:03:49,920 --> 00:03:52,959
uh that the nodes that the nodes have

102
00:03:52,959 --> 00:03:56,720
and i'm going to use

103
00:03:56,959 --> 00:03:59,680
this configure to impersonate the node

104
00:03:59,680 --> 00:04:02,319
in front of the kubernetes master api

105
00:04:02,319 --> 00:04:04,560
server as you can see i'm pointing that

106
00:04:04,560 --> 00:04:06,400
i want to use a cube config and not the

107
00:04:06,400 --> 00:04:08,239
default config

108
00:04:08,239 --> 00:04:10,560
and then i can actually query the api

109
00:04:10,560 --> 00:04:12,560
master server and get information for

110
00:04:12,560 --> 00:04:14,640
example i see all the running pods as i

111
00:04:14,640 --> 00:04:18,478
did from outside the container

112
00:04:19,279 --> 00:04:23,600
and i have i have a yaml here so a linux

113
00:04:23,600 --> 00:04:27,199
container which opens a reverse shell

114
00:04:27,199 --> 00:04:29,840
also this container is privileged and my

115
00:04:29,840 --> 00:04:31,440
my goal here is to create a new

116
00:04:31,440 --> 00:04:34,320
container privileged one a linux one so

117
00:04:34,320 --> 00:04:36,240
we so kubernetes will create this

118
00:04:36,240 --> 00:04:37,280
container

119
00:04:37,280 --> 00:04:39,600
inside a linux machine and not windows

120
00:04:39,600 --> 00:04:41,360
because i already have access to the

121
00:04:41,360 --> 00:04:42,960
windows machine i want access to a linux

122
00:04:42,960 --> 00:04:45,840
machine too so i'm creating a deployment

123
00:04:45,840 --> 00:04:47,120
using the

124
00:04:47,120 --> 00:04:48,080
the

125
00:04:48,080 --> 00:04:50,880
the config file i stole from the node

126
00:04:50,880 --> 00:04:52,720
and i created a new

127
00:04:52,720 --> 00:04:54,639
privileged container escape

128
00:04:54,639 --> 00:04:57,520
that container contains a reverse shell

129
00:04:57,520 --> 00:04:59,360
so i'm gonna i'm going to connect to

130
00:04:59,360 --> 00:05:02,720
that shell for my windows machine

131
00:05:02,720 --> 00:05:05,440
using netcat

132
00:05:08,320 --> 00:05:10,400
as you can see i'm inside the linux the

133
00:05:10,400 --> 00:05:12,800
privileged linux container and i have

134
00:05:12,800 --> 00:05:15,600
full access to the node 2 to the to the

135
00:05:15,600 --> 00:05:17,600
linux node because the container is

136
00:05:17,600 --> 00:05:19,840
privileged and at this point in this

137
00:05:19,840 --> 00:05:22,320
cluster i had only two two nodes i had a

138
00:05:22,320 --> 00:05:25,440
linux node in had a windows zone i used

139
00:05:25,440 --> 00:05:28,160
the windows i used the windows note to

140
00:05:28,160 --> 00:05:30,160
to break out and create

141
00:05:30,160 --> 00:05:33,039
a privileged container so i had access

142
00:05:33,039 --> 00:05:35,199
to both the windows using the

143
00:05:35,199 --> 00:05:38,720
vulnerability and linux using using the

144
00:05:38,720 --> 00:05:41,199
config file

145
00:05:41,199 --> 00:05:43,360
okay

146
00:05:43,360 --> 00:05:46,240
okay but let's explain let's explain the

147
00:05:46,240 --> 00:05:48,240
demo a bit more

148
00:05:48,240 --> 00:05:50,479
what does it all mean okay so i will go

149
00:05:50,479 --> 00:05:52,560
over the demo step by step because i

150
00:05:52,560 --> 00:05:54,720
didn't explain the issue yet but

151
00:05:54,720 --> 00:05:56,240
nevertheless let's go over their main

152
00:05:56,240 --> 00:05:58,560
idea here so i created a new deployment

153
00:05:58,560 --> 00:06:00,800
and note i specifically stated in the

154
00:06:00,800 --> 00:06:03,360
ammo that i want a windows node i use

155
00:06:03,360 --> 00:06:05,840
the example yaml from kubernetes website

156
00:06:05,840 --> 00:06:07,440
with default configuration of the

157
00:06:07,440 --> 00:06:10,240
cluster if you google how to create a

158
00:06:10,240 --> 00:06:12,720
windows windows container in kubernetes

159
00:06:12,720 --> 00:06:15,039
that what that what will find

160
00:06:15,039 --> 00:06:16,880
and i didn't change anything remember

161
00:06:16,880 --> 00:06:20,639
that because it is important for later

162
00:06:20,639 --> 00:06:22,560
so i created the i created the

163
00:06:22,560 --> 00:06:24,800
deployment and issued an exit command

164
00:06:24,800 --> 00:06:25,840
into it

165
00:06:25,840 --> 00:06:27,840
this part might confuse you i use the

166
00:06:27,840 --> 00:06:29,600
exit command to mimic an attacker

167
00:06:29,600 --> 00:06:32,400
gaining execution into the cluster

168
00:06:32,400 --> 00:06:34,479
so for example if your cluster

169
00:06:34,479 --> 00:06:36,400
hosts a web server with vulnerability

170
00:06:36,400 --> 00:06:38,639
and then attacker managed to use this

171
00:06:38,639 --> 00:06:40,400
vulnerability to gain access to your

172
00:06:40,400 --> 00:06:43,199
cluster we will end up in the same step

173
00:06:43,199 --> 00:06:45,520
here because the attacker will gain

174
00:06:45,520 --> 00:06:48,479
execution and i just use exactly i skip

175
00:06:48,479 --> 00:06:50,880
the part when we're an attacker find a

176
00:06:50,880 --> 00:06:52,800
vulnerability in your container and get

177
00:06:52,800 --> 00:06:56,000
execution to the container

178
00:06:56,240 --> 00:06:58,720
after that i use some symbolic link

179
00:06:58,720 --> 00:07:00,880
tricks to gain access to the host file

180
00:07:00,880 --> 00:07:04,400
system and in this case the host is the

181
00:07:04,400 --> 00:07:07,359
kubernetes node

182
00:07:09,360 --> 00:07:11,280
okay once i gain access to the nodes

183
00:07:11,280 --> 00:07:13,919
file system i use the node kubernetes

184
00:07:13,919 --> 00:07:16,800
config file to impersonate the node to

185
00:07:16,800 --> 00:07:19,919
the master api server in order to in

186
00:07:19,919 --> 00:07:21,919
order to create

187
00:07:21,919 --> 00:07:26,080
a privileged linux container

188
00:07:27,120 --> 00:07:29,120
because i created the linux container

189
00:07:29,120 --> 00:07:31,599
the api server created this container on

190
00:07:31,599 --> 00:07:33,360
a linux node

191
00:07:33,360 --> 00:07:35,840
and my container packed a reverse shell

192
00:07:35,840 --> 00:07:38,400
and once it was up i simply connected to

193
00:07:38,400 --> 00:07:40,240
the shell gaining access to the linux

194
00:07:40,240 --> 00:07:42,560
mode as well

195
00:07:42,560 --> 00:07:44,400
and at this point

196
00:07:44,400 --> 00:07:48,000
i had full access to both the linux and

197
00:07:48,000 --> 00:07:50,319
the windows pallet of the cluster and i

198
00:07:50,319 --> 00:07:52,319
could do with the cluster

199
00:07:52,319 --> 00:07:54,560
anything i wanted i could create new

200
00:07:54,560 --> 00:07:57,360
deployments to mine my cryptocurrency or

201
00:07:57,360 --> 00:07:59,520
i could steal all the data in the data

202
00:07:59,520 --> 00:08:01,680
cluster or anything else and the

203
00:08:01,680 --> 00:08:05,199
possibilities from hero and

204
00:08:06,319 --> 00:08:09,039
okay so what are containers and i know

205
00:08:09,039 --> 00:08:10,800
this is the cloud event and most people

206
00:08:10,800 --> 00:08:12,960
here probably know what the container is

207
00:08:12,960 --> 00:08:15,199
but i will go over it quickly just in

208
00:08:15,199 --> 00:08:16,400
case

209
00:08:16,400 --> 00:08:18,240
a container is basically an operating

210
00:08:18,240 --> 00:08:20,879
system based virtual machine meaning it

211
00:08:20,879 --> 00:08:23,360
runs inside operating system with the

212
00:08:23,360 --> 00:08:26,240
same kernel as the operating system it

213
00:08:26,240 --> 00:08:28,319
uses operating system features to

214
00:08:28,319 --> 00:08:30,479
isolate the virtual machine from the

215
00:08:30,479 --> 00:08:32,000
rest of the system

216
00:08:32,000 --> 00:08:34,240
unlike actual virtual machines which use

217
00:08:34,240 --> 00:08:36,559
a completely separated operations

218
00:08:36,559 --> 00:08:38,640
operating system and

219
00:08:38,640 --> 00:08:41,440
based on hardware they they base their

220
00:08:41,440 --> 00:08:43,440
virtualization hardware instead of

221
00:08:43,440 --> 00:08:44,399
software

222
00:08:44,399 --> 00:08:46,720
and containers can run anything but the

223
00:08:46,720 --> 00:08:49,040
desired container must match the

224
00:08:49,040 --> 00:08:51,680
operating system version so for example

225
00:08:51,680 --> 00:08:53,200
you won't be able to run windows

226
00:08:53,200 --> 00:08:55,519
containers on the linux machine

227
00:08:55,519 --> 00:08:57,920
as you saw in the in the demo i had to

228
00:08:57,920 --> 00:09:00,160
create a windows node in order to run

229
00:09:00,160 --> 00:09:01,920
windows containers

230
00:09:01,920 --> 00:09:03,839
and one of the most important features

231
00:09:03,839 --> 00:09:05,760
of container is that they pack all the

232
00:09:05,760 --> 00:09:08,160
necessary files to run the application

233
00:09:08,160 --> 00:09:10,720
so for instance if you have a special

234
00:09:10,720 --> 00:09:12,240
application with

235
00:09:12,240 --> 00:09:15,120
special dependencies you can pack it all

236
00:09:15,120 --> 00:09:17,360
in a lightweight container and send it

237
00:09:17,360 --> 00:09:20,160
to the end user

238
00:09:21,839 --> 00:09:24,640
okay so let's go over uh the differences

239
00:09:24,640 --> 00:09:25,920
what is the difference between a

240
00:09:25,920 --> 00:09:27,839
container and virtual machines real

241
00:09:27,839 --> 00:09:29,600
quick the main difference is that

242
00:09:29,600 --> 00:09:31,360
containers rely on operating system to

243
00:09:31,360 --> 00:09:33,600
make it it's isolation while virtual

244
00:09:33,600 --> 00:09:35,519
machines rely on hardware

245
00:09:35,519 --> 00:09:37,839
so virtual machines virtualize

246
00:09:37,839 --> 00:09:40,160
everything including the kernel while

247
00:09:40,160 --> 00:09:42,000
containers run on the same kernel as

248
00:09:42,000 --> 00:09:43,120
their host

249
00:09:43,120 --> 00:09:45,040
and because of that containers are much

250
00:09:45,040 --> 00:09:46,800
more portable and efficient

251
00:09:46,800 --> 00:09:49,600
a container image can be as small as few

252
00:09:49,600 --> 00:09:52,160
kilobytes while virtual machine images

253
00:09:52,160 --> 00:09:54,560
will usually be at least few gigabytes

254
00:09:54,560 --> 00:09:56,560
in size because they have to pack the

255
00:09:56,560 --> 00:09:58,640
kernel too

256
00:09:58,640 --> 00:10:00,720
all of that comes with a price of course

257
00:10:00,720 --> 00:10:03,040
containers are much less secure than a

258
00:10:03,040 --> 00:10:05,040
virtual machine if you look if you look

259
00:10:05,040 --> 00:10:07,440
in google for container escape you will

260
00:10:07,440 --> 00:10:10,240
probably find much more results than the

261
00:10:10,240 --> 00:10:13,440
virtual machine escapes

262
00:10:15,440 --> 00:10:18,000
okay so uh on the left side you can see

263
00:10:18,000 --> 00:10:20,079
a virtual machine infrastructure with

264
00:10:20,079 --> 00:10:23,120
the hypervisor managing all the machines

265
00:10:23,120 --> 00:10:25,120
each machine has a separate operating

266
00:10:25,120 --> 00:10:26,079
system

267
00:10:26,079 --> 00:10:28,720
and on the right is an infrastructure of

268
00:10:28,720 --> 00:10:30,320
a docking machine hosting a few

269
00:10:30,320 --> 00:10:32,959
different applications in containers

270
00:10:32,959 --> 00:10:35,440
each application is inside a separate

271
00:10:35,440 --> 00:10:37,839
container but they are all running on

272
00:10:37,839 --> 00:10:40,000
the same host operating system with the

273
00:10:40,000 --> 00:10:42,720
same camera

274
00:10:43,519 --> 00:10:44,800
okay so

275
00:10:44,800 --> 00:10:47,760
what needs to be contained let's dive

276
00:10:47,760 --> 00:10:50,880
a bit deeper into the internals

277
00:10:50,880 --> 00:10:53,200
uh and note we are only talking about

278
00:10:53,200 --> 00:10:54,959
linux for now and we'll talk about

279
00:10:54,959 --> 00:10:56,959
linters yet later

280
00:10:56,959 --> 00:10:58,959
well obviously you would want to limit

281
00:10:58,959 --> 00:11:01,360
the containers access to a resource such

282
00:11:01,360 --> 00:11:03,839
as cpu ram network bandwidth list

283
00:11:03,839 --> 00:11:05,519
bandwidth and such

284
00:11:05,519 --> 00:11:07,360
this is done using a feature called see

285
00:11:07,360 --> 00:11:08,320
groups

286
00:11:08,320 --> 00:11:11,040
and these features allow us to

287
00:11:11,040 --> 00:11:12,800
limit resource

288
00:11:12,800 --> 00:11:14,880
usage for a group of processors

289
00:11:14,880 --> 00:11:17,279
obviously what you wouldn't want your

290
00:11:17,279 --> 00:11:18,880
container to

291
00:11:18,880 --> 00:11:21,680
to get all the cpu all the disk

292
00:11:21,680 --> 00:11:24,399
from your host so you can limit that but

293
00:11:24,399 --> 00:11:25,839
you would also want to limit the

294
00:11:25,839 --> 00:11:28,640
visibility the containers have if we

295
00:11:28,640 --> 00:11:30,480
would only limit resources nothing would

296
00:11:30,480 --> 00:11:32,880
stop a malicious container from just

297
00:11:32,880 --> 00:11:35,440
changing its own resource limitation

298
00:11:35,440 --> 00:11:37,839
and for that we would also want to limit

299
00:11:37,839 --> 00:11:39,839
the container's visibility

300
00:11:39,839 --> 00:11:42,480
and to some of the host objects such as

301
00:11:42,480 --> 00:11:45,600
processes network interfaces users

302
00:11:45,600 --> 00:11:47,040
mounts such

303
00:11:47,040 --> 00:11:49,279
things like that and this is done using

304
00:11:49,279 --> 00:11:51,839
a feature called namespace

305
00:11:51,839 --> 00:11:55,120
all of that is in linux

306
00:11:55,839 --> 00:11:57,839
okay but this is talk about windows

307
00:11:57,839 --> 00:11:59,519
containers so let's move forward to

308
00:11:59,519 --> 00:12:00,480
windows

309
00:12:00,480 --> 00:12:02,560
in order to get a good solution for

310
00:12:02,560 --> 00:12:04,560
containers and windows uh the same

311
00:12:04,560 --> 00:12:06,480
requirements i talked about in the last

312
00:12:06,480 --> 00:12:08,720
slide need to be implemented here

313
00:12:08,720 --> 00:12:10,800
and luckily windows had a solution for

314
00:12:10,800 --> 00:12:12,800
that resource limitation for years it's

315
00:12:12,800 --> 00:12:14,720
called job objects and they do pretty

316
00:12:14,720 --> 00:12:17,279
much the same thing as c groups in linux

317
00:12:17,279 --> 00:12:19,200
and so there's nothing too interesting

318
00:12:19,200 --> 00:12:21,360
about them but it's it is important to

319
00:12:21,360 --> 00:12:23,760
know that the feature existed for years

320
00:12:23,760 --> 00:12:26,240
it's not new and it's not it it's like

321
00:12:26,240 --> 00:12:29,200
the windows version of c groups

322
00:12:29,200 --> 00:12:31,920
okay but what about visibility isolation

323
00:12:31,920 --> 00:12:34,560
and until recently windows didn't

324
00:12:34,560 --> 00:12:36,240
actually have a solution for this and

325
00:12:36,240 --> 00:12:38,720
that's why windows containers

326
00:12:38,720 --> 00:12:43,200
didn't exist until like a few years ago

327
00:12:43,440 --> 00:12:46,320
uh but luckily a few years ago microsoft

328
00:12:46,320 --> 00:12:48,240
came up with a feature called server

329
00:12:48,240 --> 00:12:51,279
silo which directly provides the missing

330
00:12:51,279 --> 00:12:54,000
features that were necessary in order to

331
00:12:54,000 --> 00:12:57,519
create a container solution

332
00:12:57,519 --> 00:13:00,160
server silos provide everything that

333
00:13:00,160 --> 00:13:02,959
namespaces provide in linux

334
00:13:02,959 --> 00:13:05,040
they isolate the object manager the

335
00:13:05,040 --> 00:13:07,600
registry networking devices and

336
00:13:07,600 --> 00:13:10,240
basically any named object that process

337
00:13:10,240 --> 00:13:11,360
can access

338
00:13:11,360 --> 00:13:13,920
and remember the name name the object

339
00:13:13,920 --> 00:13:17,360
part that's the important thing

340
00:13:17,760 --> 00:13:19,360
but also here the other type of windows

341
00:13:19,360 --> 00:13:21,600
containers the hyper-v containers and

342
00:13:21,600 --> 00:13:23,519
servo silo

343
00:13:23,519 --> 00:13:25,279
on the right you can see

344
00:13:25,279 --> 00:13:27,360
how a hyper recontainer architecture

345
00:13:27,360 --> 00:13:28,160
looks

346
00:13:28,160 --> 00:13:29,680
not much different than a regular

347
00:13:29,680 --> 00:13:32,000
virtual machine actually each container

348
00:13:32,000 --> 00:13:34,480
has its own lightweight kernel

349
00:13:34,480 --> 00:13:36,880
basically it's the microsoft version of

350
00:13:36,880 --> 00:13:38,720
vm it's not what we are here to talk

351
00:13:38,720 --> 00:13:41,680
about today because it's a vm and on the

352
00:13:41,680 --> 00:13:43,120
left side you can see the more

353
00:13:43,120 --> 00:13:45,600
traditional meaning of containers one

354
00:13:45,600 --> 00:13:47,440
kernel with few containers for different

355
00:13:47,440 --> 00:13:49,839
applications

356
00:13:50,480 --> 00:13:52,800
note the system processes are also

357
00:13:52,800 --> 00:13:54,800
shared with the containers

358
00:13:54,800 --> 00:13:58,560
and this is done using cell silos

359
00:13:58,560 --> 00:14:00,000
as you can see all the containers are

360
00:14:00,000 --> 00:14:02,480
using the same the same kernel system

361
00:14:02,480 --> 00:14:05,600
same system processes

362
00:14:07,040 --> 00:14:09,680
okay there is one more thing that need

363
00:14:09,680 --> 00:14:12,880
to uh to know before understanding like

364
00:14:12,880 --> 00:14:14,740
how it all works

365
00:14:14,740 --> 00:14:16,079
[Music]

366
00:14:16,079 --> 00:14:18,959
called root directory object

367
00:14:18,959 --> 00:14:20,880
which is a key feature in windows

368
00:14:20,880 --> 00:14:23,279
operating system without anything to do

369
00:14:23,279 --> 00:14:24,560
with containers

370
00:14:24,560 --> 00:14:25,600
uh

371
00:14:25,600 --> 00:14:27,680
without getting too deep about this

372
00:14:27,680 --> 00:14:29,839
mechanism it's suffice to say that all

373
00:14:29,839 --> 00:14:32,720
application visible named objects such

374
00:14:32,720 --> 00:14:36,160
as file registration events mutex rpcs

375
00:14:36,160 --> 00:14:38,160
stuff like that anything that is named

376
00:14:38,160 --> 00:14:40,720
are hosted in a root namespace which

377
00:14:40,720 --> 00:14:43,360
allows applications to create locate

378
00:14:43,360 --> 00:14:47,519
share these objects among themselves

379
00:14:49,120 --> 00:14:51,120
take a look at this screenshot from the

380
00:14:51,120 --> 00:14:53,680
win object application by sysinternals

381
00:14:53,680 --> 00:14:56,079
it shows the root directory object

382
00:14:56,079 --> 00:14:58,800
perfectly as you can see on the left

383
00:14:58,800 --> 00:15:00,639
there are many directories under the

384
00:15:00,639 --> 00:15:03,680
wood the root object and under global

385
00:15:03,680 --> 00:15:05,360
question what question mark

386
00:15:05,360 --> 00:15:07,680
there are tons of symbolic links

387
00:15:07,680 --> 00:15:10,240
including the sea letter symbolic link

388
00:15:10,240 --> 00:15:12,320
so yeah when you are accessing the c

389
00:15:12,320 --> 00:15:15,279
drive in your windows machine it is in

390
00:15:15,279 --> 00:15:17,440
fact a symbolic link to the actual

391
00:15:17,440 --> 00:15:18,480
device

392
00:15:18,480 --> 00:15:20,399
there are many more symbolic links over

393
00:15:20,399 --> 00:15:21,600
there but the

394
00:15:21,600 --> 00:15:23,839
the one most important to us is indeed

395
00:15:23,839 --> 00:15:24,880
ceiling

396
00:15:24,880 --> 00:15:27,920
and which points to the actual file

397
00:15:27,920 --> 00:15:30,320
system device which in this case is how

398
00:15:30,320 --> 00:15:32,560
is volume 3.

399
00:15:32,560 --> 00:15:35,519
in this case what you can see

400
00:15:35,519 --> 00:15:37,040
that would direct to the object of a

401
00:15:37,040 --> 00:15:39,360
host it's not with a actual object of a

402
00:15:39,360 --> 00:15:41,759
container or several style

403
00:15:41,759 --> 00:15:43,839
it the wood directory object of the host

404
00:15:43,839 --> 00:15:46,000
now note it can also be a virtual

405
00:15:46,000 --> 00:15:49,040
machine but it's uh it's it has its own

406
00:15:49,040 --> 00:15:51,600
camera so this screenshot is from a

407
00:15:51,600 --> 00:15:53,279
machine with its own account and not a

408
00:15:53,279 --> 00:15:55,519
container

409
00:15:55,519 --> 00:15:56,639
okay

410
00:15:56,639 --> 00:15:58,720
and this screenshot however you can see

411
00:15:58,720 --> 00:16:00,800
what the containers look like in the

412
00:16:00,800 --> 00:16:02,880
wood directory logic notice on the left

413
00:16:02,880 --> 00:16:05,279
there is a stylus directory

414
00:16:05,279 --> 00:16:07,680
every server silo container will have

415
00:16:07,680 --> 00:16:09,600
its own subdirectory under this

416
00:16:09,600 --> 00:16:10,800
directory

417
00:16:10,800 --> 00:16:14,800
with the name being the server silo id

418
00:16:14,800 --> 00:16:16,560
so in this particular case i had a

419
00:16:16,560 --> 00:16:18,560
single container with a cell a silo id

420
00:16:18,560 --> 00:16:20,240
of 804

421
00:16:20,240 --> 00:16:22,079
and as you can see the silent directory

422
00:16:22,079 --> 00:16:23,759
is almost identical to the host

423
00:16:23,759 --> 00:16:24,959
directory

424
00:16:24,959 --> 00:16:27,199
this is because windows tries to

425
00:16:27,199 --> 00:16:29,839
virtualize a mini operating system as

426
00:16:29,839 --> 00:16:31,600
accurately as possible

427
00:16:31,600 --> 00:16:33,680
and so most of the symbolic links that

428
00:16:33,680 --> 00:16:36,480
the host have the container have too

429
00:16:36,480 --> 00:16:38,480
with different destinations of course

430
00:16:38,480 --> 00:16:39,920
because we don't want the container to

431
00:16:39,920 --> 00:16:43,920
point to the same devices as the host

432
00:16:44,240 --> 00:16:45,920
we will discuss the server side of the

433
00:16:45,920 --> 00:16:50,120
directory object further later

434
00:16:51,120 --> 00:16:54,000
so let's move over to an actual example

435
00:16:54,000 --> 00:16:56,320
of how a root directory object is used

436
00:16:56,320 --> 00:16:58,880
in a simple create file code

437
00:16:58,880 --> 00:17:01,360
the create file api receives the files

438
00:17:01,360 --> 00:17:04,079
path and returns a handle to that file

439
00:17:04,079 --> 00:17:06,720
the process can read write or do

440
00:17:06,720 --> 00:17:08,559
basically any action with the handle

441
00:17:08,559 --> 00:17:10,959
depending on the permissions the process

442
00:17:10,959 --> 00:17:12,559
asked when calling the create file

443
00:17:12,559 --> 00:17:13,679
function

444
00:17:13,679 --> 00:17:15,599
and in this example we're going to

445
00:17:15,599 --> 00:17:17,839
create file on a file in the c drive

446
00:17:17,839 --> 00:17:21,280
named secret dot text

447
00:17:22,160 --> 00:17:25,199
as i said earlier note that the c part

448
00:17:25,199 --> 00:17:28,160
is just a symbol in clink as you can see

449
00:17:28,160 --> 00:17:30,400
in the screen scheduled below you can

450
00:17:30,400 --> 00:17:32,960
see the c it pointing to device hardest

451
00:17:32,960 --> 00:17:34,799
country

452
00:17:34,799 --> 00:17:35,919
um

453
00:17:35,919 --> 00:17:37,440
okay

454
00:17:37,440 --> 00:17:41,360
so uh c is first converted to something

455
00:17:41,360 --> 00:17:43,919
that kernel can actually

456
00:17:43,919 --> 00:17:45,840
query it is converted to the wood

457
00:17:45,840 --> 00:17:47,679
directory object

458
00:17:47,679 --> 00:17:49,360
form of this path

459
00:17:49,360 --> 00:17:51,840
this is done in user mode before the

460
00:17:51,840 --> 00:17:54,320
call arrives to the kernel

461
00:17:54,320 --> 00:17:57,120
and after that in the kernel the kernel

462
00:17:57,120 --> 00:17:59,440
query the global c path in the wood

463
00:17:59,440 --> 00:18:01,120
directory object and receive the

464
00:18:01,120 --> 00:18:05,039
destination of that symbolic link

465
00:18:06,000 --> 00:18:08,799
we then queried that that destination

466
00:18:08,799 --> 00:18:10,960
received from the symbolic link still

467
00:18:10,960 --> 00:18:13,360
under the directory object

468
00:18:13,360 --> 00:18:16,799
but this time the pulsing ends with

469
00:18:16,799 --> 00:18:20,080
with an actual device

470
00:18:21,520 --> 00:18:22,560
okay

471
00:18:22,560 --> 00:18:25,200
[Music]

472
00:18:25,200 --> 00:18:27,840
so at this point having an actual device

473
00:18:27,840 --> 00:18:29,760
the kernel follows the request to the

474
00:18:29,760 --> 00:18:32,880
device driver which in this case is the

475
00:18:32,880 --> 00:18:35,120
file system driver and from here the

476
00:18:35,120 --> 00:18:38,000
file system drivers take the

477
00:18:38,000 --> 00:18:39,760
execution and that part is less

478
00:18:39,760 --> 00:18:41,200
important for us because we're not here

479
00:18:41,200 --> 00:18:42,400
to talk about

480
00:18:42,400 --> 00:18:44,720
the file system driver and remember that

481
00:18:44,720 --> 00:18:46,880
part where the kernel received the

482
00:18:46,880 --> 00:18:49,919
symbolic link target and queried that

483
00:18:49,919 --> 00:18:51,760
under the root directory object too

484
00:18:51,760 --> 00:18:54,160
until it found an actual device it will

485
00:18:54,160 --> 00:18:57,039
be important for us later

486
00:18:57,039 --> 00:18:59,760
uh also remember that uh this query was

487
00:18:59,760 --> 00:19:02,559
an example of a query from the host and

488
00:19:02,559 --> 00:19:04,799
not from inside the container it is

489
00:19:04,799 --> 00:19:07,039
slightly different when the calls come

490
00:19:07,039 --> 00:19:08,480
from inside the container we'll cover

491
00:19:08,480 --> 00:19:11,760
this in a minute

492
00:19:11,760 --> 00:19:13,520
okay so before giving an example of a

493
00:19:13,520 --> 00:19:15,280
file access form inside a container

494
00:19:15,280 --> 00:19:16,640
let's discuss

495
00:19:16,640 --> 00:19:19,200
how the system decides that the call

496
00:19:19,200 --> 00:19:22,960
comes from inside the container actually

497
00:19:22,960 --> 00:19:24,400
as you can see on the left

498
00:19:24,400 --> 00:19:26,720
the it's a schedule for mida where i

499
00:19:26,720 --> 00:19:29,600
search for the keyword silo server

500
00:19:29,600 --> 00:19:32,000
there are plenty of functions that can

501
00:19:32,000 --> 00:19:34,480
decide if a code comes from a server

502
00:19:34,480 --> 00:19:35,919
side or not

503
00:19:35,919 --> 00:19:38,240
and the kernel uses different functions

504
00:19:38,240 --> 00:19:40,080
in different scenarios uh

505
00:19:40,080 --> 00:19:41,600
this screenshot is from the enter

506
00:19:41,600 --> 00:19:44,960
scanner binary so it's like the binary

507
00:19:44,960 --> 00:19:47,919
that represent the kind of windows

508
00:19:47,919 --> 00:19:49,280
um

509
00:19:49,280 --> 00:19:51,760
in our specific case the kernel decides

510
00:19:51,760 --> 00:19:54,400
a call comes from a container if it if

511
00:19:54,400 --> 00:19:57,120
it decided it queries that the path we

512
00:19:57,120 --> 00:19:59,840
saw before the global c path

513
00:19:59,840 --> 00:20:03,360
relative to uh to the server side of

514
00:20:03,360 --> 00:20:05,840
subdirectory inside a wood directory

515
00:20:05,840 --> 00:20:07,840
object

516
00:20:07,840 --> 00:20:08,880
and

517
00:20:08,880 --> 00:20:11,520
this will happen to every axis of a

518
00:20:11,520 --> 00:20:14,480
named object such as files so every

519
00:20:14,480 --> 00:20:16,320
every access of a named object from

520
00:20:16,320 --> 00:20:17,520
inside

521
00:20:17,520 --> 00:20:20,559
server side meaning inside the container

522
00:20:20,559 --> 00:20:23,919
will be queried relative to the silos

523
00:20:23,919 --> 00:20:26,799
directory and then the silos id in this

524
00:20:26,799 --> 00:20:30,559
case 804.

525
00:20:31,120 --> 00:20:33,200
in this screenshot formida you can see

526
00:20:33,200 --> 00:20:35,520
the branch in the kernel where it is

527
00:20:35,520 --> 00:20:39,120
decided if path will be created to the

528
00:20:39,120 --> 00:20:41,360
actual wood directory object

529
00:20:41,360 --> 00:20:43,679
and not to the server style subdirectory

530
00:20:43,679 --> 00:20:45,919
in the root directory object and as you

531
00:20:45,919 --> 00:20:49,200
can see this is done using a ps get

532
00:20:49,200 --> 00:20:51,520
terminal and silocontext

533
00:20:51,520 --> 00:20:53,679
candle function which just returns the

534
00:20:53,679 --> 00:20:56,799
context of the silo

535
00:20:57,360 --> 00:20:59,600
okay

536
00:21:00,240 --> 00:21:02,480
okay let's go over an example of

537
00:21:02,480 --> 00:21:05,840
accessing a file from a container

538
00:21:05,840 --> 00:21:08,320
as before we are accessing a file named

539
00:21:08,320 --> 00:21:10,480
secret text under the cd drive so

540
00:21:10,480 --> 00:21:12,960
exactly as before but this time from

541
00:21:12,960 --> 00:21:15,760
inside a container

542
00:21:15,760 --> 00:21:18,080
skipping the user mode part or the api

543
00:21:18,080 --> 00:21:20,960
where the api adds the global part uh

544
00:21:20,960 --> 00:21:22,880
before the c letter and jumping straight

545
00:21:22,880 --> 00:21:24,240
to the camera part because we already

546
00:21:24,240 --> 00:21:25,280
covered that

547
00:21:25,280 --> 00:21:26,159
um

548
00:21:26,159 --> 00:21:29,039
so the kernel calls

549
00:21:29,039 --> 00:21:31,840
ps get permanent style context as you

550
00:21:31,840 --> 00:21:32,720
saw

551
00:21:32,720 --> 00:21:34,320
and you retrieve the style of context

552
00:21:34,320 --> 00:21:36,000
and not null if you try to if the

553
00:21:36,000 --> 00:21:37,760
knowledge you find the last picture it

554
00:21:37,760 --> 00:21:39,280
will be queried

555
00:21:39,280 --> 00:21:40,080
uh

556
00:21:40,080 --> 00:21:41,679
towards the

557
00:21:41,679 --> 00:21:43,440
the root director of the real one of the

558
00:21:43,440 --> 00:21:45,679
host and not the style so it takes the

559
00:21:45,679 --> 00:21:48,320
branch of the server silo in the kernel

560
00:21:48,320 --> 00:21:49,840
code

561
00:21:49,840 --> 00:21:52,320
and it created the relevant directory

562
00:21:52,320 --> 00:21:55,679
under the subdirectory of the silo in

563
00:21:55,679 --> 00:21:58,400
the wood directory object until it finds

564
00:21:58,400 --> 00:22:00,799
the system voluntary

565
00:22:00,799 --> 00:22:02,799
and

566
00:22:02,799 --> 00:22:03,840
okay

567
00:22:03,840 --> 00:22:05,039
but

568
00:22:05,039 --> 00:22:06,720
this time

569
00:22:06,720 --> 00:22:09,360
the system bowling gleam points to a

570
00:22:09,360 --> 00:22:11,360
virtual hard disk device

571
00:22:11,360 --> 00:22:13,280
under the side of subdirectory in the

572
00:22:13,280 --> 00:22:16,240
directory object note the vhd before

573
00:22:16,240 --> 00:22:17,280
before

574
00:22:17,280 --> 00:22:19,200
in the name under the device before it

575
00:22:19,200 --> 00:22:21,760
was just how this volume 3 in this in

576
00:22:21,760 --> 00:22:23,760
this case is the vhd which represents

577
00:22:23,760 --> 00:22:27,320
the virtual hovers

578
00:22:27,600 --> 00:22:30,240
okay but take a look at the screenshot

579
00:22:30,240 --> 00:22:32,880
and this is the interesting part

580
00:22:32,880 --> 00:22:35,280
that virtual hard disk device isn't a

581
00:22:35,280 --> 00:22:38,320
device at all it is a symbolic link too

582
00:22:38,320 --> 00:22:41,760
which points to itself a symbolic link

583
00:22:41,760 --> 00:22:43,840
and we end up in an infinite loop

584
00:22:43,840 --> 00:22:45,760
because we have a symbolic link that

585
00:22:45,760 --> 00:22:48,240
points to itself in the same name which

586
00:22:48,240 --> 00:22:50,240
is to a symbolic link

587
00:22:50,240 --> 00:22:51,840
uh

588
00:22:51,840 --> 00:22:54,080
and this was the point at my research

589
00:22:54,080 --> 00:22:56,240
when i realized there is something i'm

590
00:22:56,240 --> 00:22:59,360
missing because the request to the file

591
00:22:59,360 --> 00:23:01,679
was successful and i was able to read

592
00:23:01,679 --> 00:23:04,559
and write to the file in my container so

593
00:23:04,559 --> 00:23:06,480
it was obviously working but on the

594
00:23:06,480 --> 00:23:08,640
other hand it looks like we should have

595
00:23:08,640 --> 00:23:10,720
it stuck in an infinite loop

596
00:23:10,720 --> 00:23:13,840
so what's going on here

597
00:23:14,400 --> 00:23:15,520
uh

598
00:23:15,520 --> 00:23:17,360
let's go over what the requirement is in

599
00:23:17,360 --> 00:23:20,400
this case every container and it of

600
00:23:20,400 --> 00:23:22,640
course is relevant to what i just said

601
00:23:22,640 --> 00:23:24,960
about the infinite symbol

602
00:23:24,960 --> 00:23:27,200
every container either in linux or in

603
00:23:27,200 --> 00:23:29,440
windows needs to be able to communicate

604
00:23:29,440 --> 00:23:32,000
with some of the host's devices it can

605
00:23:32,000 --> 00:23:34,240
be a screen to show output or a network

606
00:23:34,240 --> 00:23:37,039
device or the file system

607
00:23:37,039 --> 00:23:39,840
so in the way windows works some of the

608
00:23:39,840 --> 00:23:42,320
symbolic links under the server style

609
00:23:42,320 --> 00:23:43,520
subdirectory

610
00:23:43,520 --> 00:23:46,400
must point to a device in the host or

611
00:23:46,400 --> 00:23:48,880
directory object otherwise the container

612
00:23:48,880 --> 00:23:50,640
won't have any access to anything for

613
00:23:50,640 --> 00:23:52,880
example the virtual file system is

614
00:23:52,880 --> 00:23:55,200
eventually just a path in the host file

615
00:23:55,200 --> 00:23:56,159
system

616
00:23:56,159 --> 00:23:57,840
and the container must have access to

617
00:23:57,840 --> 00:24:00,159
that path at least so it must have

618
00:24:00,159 --> 00:24:05,159
access to the host file system device

619
00:24:05,279 --> 00:24:06,320
and

620
00:24:06,320 --> 00:24:07,840
we're getting closer to the actual

621
00:24:07,840 --> 00:24:09,679
escape i promise

622
00:24:09,679 --> 00:24:12,240
the way it is done in windows is that

623
00:24:12,240 --> 00:24:14,720
processors with the right permissions

624
00:24:14,720 --> 00:24:18,000
can set a symbol in clink as a global a

625
00:24:18,000 --> 00:24:20,480
global symbolic well symbolic thing will

626
00:24:20,480 --> 00:24:22,320
always be looked at relative to the

627
00:24:22,320 --> 00:24:25,200
hosts or directory object regardless of

628
00:24:25,200 --> 00:24:27,679
the process that is trying to pulse it

629
00:24:27,679 --> 00:24:30,000
is inside a container

630
00:24:30,000 --> 00:24:32,880
so when a container is created docker

631
00:24:32,880 --> 00:24:34,799
sets some of the containers symbolic

632
00:24:34,799 --> 00:24:37,279
links as global and that's why the

633
00:24:37,279 --> 00:24:39,360
container can maintain some sort of

634
00:24:39,360 --> 00:24:41,360
communication with the host

635
00:24:41,360 --> 00:24:42,159
it

636
00:24:42,159 --> 00:24:45,200
it pulses global symbolic links

637
00:24:45,200 --> 00:24:48,960
and the result is devices on the host

638
00:24:48,960 --> 00:24:51,279
and note that non-global symbolic

639
00:24:51,279 --> 00:24:53,200
headaches like regular symbolics are

640
00:24:53,200 --> 00:24:54,720
passed straight into the silos or

641
00:24:54,720 --> 00:24:58,640
directory object as we discussed earlier

642
00:24:58,640 --> 00:25:00,559
okay so in this screenshot again for

643
00:25:00,559 --> 00:25:03,520
nida you can clearly see the condition

644
00:25:03,520 --> 00:25:06,720
uh eax hold one of the symbolic links

645
00:25:06,720 --> 00:25:09,360
parameters the one that holds the

646
00:25:09,360 --> 00:25:12,559
symbolic link if it is global or not

647
00:25:12,559 --> 00:25:15,600
and if it is the execution will take the

648
00:25:15,600 --> 00:25:17,360
right branch and will retrieve the root

649
00:25:17,360 --> 00:25:19,679
directory object from a global variable

650
00:25:19,679 --> 00:25:22,559
in the kernel and if not

651
00:25:22,559 --> 00:25:24,559
it will take the left branch and then we

652
00:25:24,559 --> 00:25:26,000
will have to get

653
00:25:26,000 --> 00:25:28,320
the style of context first as you can

654
00:25:28,320 --> 00:25:30,799
see the left branch calls psg permanent

655
00:25:30,799 --> 00:25:34,158
style of context so it makes sense

656
00:25:35,120 --> 00:25:37,840
so if the symbolic link is global

657
00:25:37,840 --> 00:25:40,640
the link will be passed from here

658
00:25:40,640 --> 00:25:43,840
instead of from here

659
00:25:44,240 --> 00:25:48,960
just just a visualization of that

660
00:25:49,760 --> 00:25:52,880
okay let's move let's move to the house

661
00:25:52,880 --> 00:25:55,360
how can we exploit the global symbolic

662
00:25:55,360 --> 00:25:56,880
link feature to break out of the

663
00:25:56,880 --> 00:25:57,919
container

664
00:25:57,919 --> 00:26:00,159
so the function that is in charge of

665
00:26:00,159 --> 00:26:02,320
making symbolic links global is the

666
00:26:02,320 --> 00:26:04,559
undocumented empty set information

667
00:26:04,559 --> 00:26:06,640
symbolic function

668
00:26:06,640 --> 00:26:08,720
and after reversing it in order to

669
00:26:08,720 --> 00:26:11,440
understand what parameter that function

670
00:26:11,440 --> 00:26:14,400
expects i discovered that it requires

671
00:26:14,400 --> 00:26:17,360
setcp privilege permissions in order to

672
00:26:17,360 --> 00:26:19,279
make the link global

673
00:26:19,279 --> 00:26:21,840
and sadly the regular container user

674
00:26:21,840 --> 00:26:24,240
doesn't have those permissions so if you

675
00:26:24,240 --> 00:26:26,720
are for example hosting uh

676
00:26:26,720 --> 00:26:28,240
you're hosting a

677
00:26:28,240 --> 00:26:31,440
web server and someone managed to to

678
00:26:31,440 --> 00:26:33,360
abuse their vulnerability in it and

679
00:26:33,360 --> 00:26:34,320
getting

680
00:26:34,320 --> 00:26:35,600
container

681
00:26:35,600 --> 00:26:38,559
and gain execution inside your container

682
00:26:38,559 --> 00:26:40,799
that's process that web server process

683
00:26:40,799 --> 00:26:43,440
in the context the attacker running in

684
00:26:43,440 --> 00:26:46,400
we won't have that tcp privilege to

685
00:26:46,400 --> 00:26:49,120
create a global symbol click

686
00:26:49,120 --> 00:26:51,200
okay but lucky for us there is another

687
00:26:51,200 --> 00:26:53,919
process in the container scope

688
00:26:53,919 --> 00:26:55,840
meaning it is visible to the containers

689
00:26:55,840 --> 00:26:59,360
user even without tcp tcp privileges

690
00:26:59,360 --> 00:27:01,919
called cxxservice.exe

691
00:27:01,919 --> 00:27:03,919
and it is the main process of the

692
00:27:03,919 --> 00:27:06,400
container it's the process that spawns

693
00:27:06,400 --> 00:27:08,480
all the other processes

694
00:27:08,480 --> 00:27:11,679
and this process has in fact sapcb

695
00:27:11,679 --> 00:27:12,720
coverage

696
00:27:12,720 --> 00:27:15,200
and lucky for us again by default the

697
00:27:15,200 --> 00:27:19,360
normal container user is administrator

698
00:27:19,360 --> 00:27:22,159
so if you are running a web server i'm

699
00:27:22,159 --> 00:27:24,000
coming back to the web server example if

700
00:27:24,000 --> 00:27:26,799
you're running a web server the website

701
00:27:26,799 --> 00:27:31,039
is running as administrator by default

702
00:27:31,039 --> 00:27:33,600
take a look at this schedule from

703
00:27:33,600 --> 00:27:36,559
and as you can see there is a check for

704
00:27:36,559 --> 00:27:39,679
sctcb privilege before moving forward

705
00:27:39,679 --> 00:27:42,240
with the execution in making a symbolic

706
00:27:42,240 --> 00:27:45,120
and global and that screenshot is from

707
00:27:45,120 --> 00:27:47,840
the anti-set information symbolic link

708
00:27:47,840 --> 00:27:51,678
function that i mentioned earlier

709
00:27:56,080 --> 00:27:59,120
so let's go over the escape plan

710
00:27:59,120 --> 00:28:01,679
first we impersonate cxx service to gain

711
00:28:01,679 --> 00:28:02,720
its

712
00:28:02,720 --> 00:28:04,559
tcp privileges

713
00:28:04,559 --> 00:28:06,960
there are numerous ways to do that

714
00:28:06,960 --> 00:28:09,600
such as thread impersonation or dll

715
00:28:09,600 --> 00:28:12,240
injection there are probably many other

716
00:28:12,240 --> 00:28:14,000
ways that we didn't mention or didn't

717
00:28:14,000 --> 00:28:15,520
research

718
00:28:15,520 --> 00:28:18,240
but in the demo i use dll injector and

719
00:28:18,240 --> 00:28:21,039
it did injection from there in the last

720
00:28:21,039 --> 00:28:23,360
year when i researched it further i

721
00:28:23,360 --> 00:28:26,000
moved to a thread impersonation

722
00:28:26,000 --> 00:28:29,120
and there are probably many other ways

723
00:28:29,120 --> 00:28:31,120
so after that we create a regular

724
00:28:31,120 --> 00:28:34,000
symbolic link which at this point is not

725
00:28:34,000 --> 00:28:36,000
global and points to our local

726
00:28:36,000 --> 00:28:38,880
containerized cell right

727
00:28:38,880 --> 00:28:41,440
then we call ntc information symbol in

728
00:28:41,440 --> 00:28:43,279
qiling with our newly created and

729
00:28:43,279 --> 00:28:45,039
symbolic links to make it global and

730
00:28:45,039 --> 00:28:46,720
remember that we do that after we

731
00:28:46,720 --> 00:28:51,039
already impersonate the cxx service

732
00:28:51,039 --> 00:28:53,279
so at this point we have full access to

733
00:28:53,279 --> 00:28:55,039
the host c drive

734
00:28:55,039 --> 00:28:57,679
by using our local x drive because we

735
00:28:57,679 --> 00:28:59,840
created the symbolic link x to c and

736
00:28:59,840 --> 00:29:02,559
make it global so now it points to the

737
00:29:02,559 --> 00:29:04,879
host

738
00:29:04,960 --> 00:29:06,000
and

739
00:29:06,000 --> 00:29:07,840
we are done here and the possibilities

740
00:29:07,840 --> 00:29:09,679
are endless at this point we have full

741
00:29:09,679 --> 00:29:11,600
access to the post

742
00:29:11,600 --> 00:29:13,760
file system as you saw in the demo i was

743
00:29:13,760 --> 00:29:15,279
able to copy

744
00:29:15,279 --> 00:29:17,840
the config file of the node which is not

745
00:29:17,840 --> 00:29:19,600
inside a container it's inside it's

746
00:29:19,600 --> 00:29:20,799
inside the node

747
00:29:20,799 --> 00:29:23,679
and i'm only talking here about the file

748
00:29:23,679 --> 00:29:25,600
system but this can be used for the

749
00:29:25,600 --> 00:29:28,399
registry itself and basically any named

750
00:29:28,399 --> 00:29:29,600
object

751
00:29:29,600 --> 00:29:32,399
the file system was just the easiest to

752
00:29:32,399 --> 00:29:35,840
to export and demonstrate

753
00:29:37,360 --> 00:29:38,880
uh okay

754
00:29:38,880 --> 00:29:40,880
but how cloud providers are affected by

755
00:29:40,880 --> 00:29:42,320
this

756
00:29:42,320 --> 00:29:45,360
uh well the trivial thing is any

757
00:29:45,360 --> 00:29:48,159
kubernetes cluster with a windows node

758
00:29:48,159 --> 00:29:50,320
and attacker that gains access to the

759
00:29:50,320 --> 00:29:52,480
container can just break out of the host

760
00:29:52,480 --> 00:29:54,880
and possibly spread from there exactly

761
00:29:54,880 --> 00:29:56,480
as i did in the demo

762
00:29:56,480 --> 00:29:58,480
so it's depend on the

763
00:29:58,480 --> 00:30:01,520
cluster how the cluster is configured

764
00:30:01,520 --> 00:30:04,399
uh but said attacker will at least be

765
00:30:04,399 --> 00:30:06,240
able to control to control every

766
00:30:06,240 --> 00:30:09,039
container that the specific node is

767
00:30:09,039 --> 00:30:11,200
compromised

768
00:30:11,200 --> 00:30:14,399
that the com the specific node hosts so

769
00:30:14,399 --> 00:30:16,480
even if the kubernetes cluster is

770
00:30:16,480 --> 00:30:18,480
configured well and

771
00:30:18,480 --> 00:30:20,880
unlike in my demo

772
00:30:20,880 --> 00:30:23,600
one node can't access other nodes

773
00:30:23,600 --> 00:30:25,520
the attacker will at least have access

774
00:30:25,520 --> 00:30:28,000
to that node with all the containers

775
00:30:28,000 --> 00:30:30,880
this snow host

776
00:30:31,200 --> 00:30:33,039
okay so as i demonstrated in my demo an

777
00:30:33,039 --> 00:30:34,880
attacker could possibly spread in the

778
00:30:34,880 --> 00:30:36,720
rest of the cluster as well so not just

779
00:30:36,720 --> 00:30:39,760
his node but other node as well

780
00:30:39,760 --> 00:30:42,080
and another possibility in the whole

781
00:30:42,080 --> 00:30:44,159
container as a service

782
00:30:44,159 --> 00:30:46,880
service that's going on lately imagine a

783
00:30:46,880 --> 00:30:48,960
cloud provider offering windows

784
00:30:48,960 --> 00:30:51,520
containers as a service and not part of

785
00:30:51,520 --> 00:30:52,960
an entire cluster

786
00:30:52,960 --> 00:30:54,880
an attacker can host a malicious

787
00:30:54,880 --> 00:30:57,360
container and break out of his own

788
00:30:57,360 --> 00:30:59,600
container and gain access to other

789
00:30:59,600 --> 00:31:01,120
customers private containers because

790
00:31:01,120 --> 00:31:02,880
they are running on the same host

791
00:31:02,880 --> 00:31:04,880
because the cloud provider won't create

792
00:31:04,880 --> 00:31:07,840
a new host with a new camera for each

793
00:31:07,840 --> 00:31:09,039
customer

794
00:31:09,039 --> 00:31:11,120
so that's a possibility i didn't i

795
00:31:11,120 --> 00:31:13,039
didn't check it yet i didn't exploit it

796
00:31:13,039 --> 00:31:13,840
but

797
00:31:13,840 --> 00:31:16,559
this can happen

798
00:31:17,120 --> 00:31:20,559
uh okay let's move to an actual example

799
00:31:20,559 --> 00:31:22,720
of how this vulnerability

800
00:31:22,720 --> 00:31:25,919
could be used in the wild by attackers

801
00:31:25,919 --> 00:31:26,720
uh

802
00:31:26,720 --> 00:31:28,640
so a few months ago i discovered

803
00:31:28,640 --> 00:31:31,120
cytoscape which is a malware that was

804
00:31:31,120 --> 00:31:33,200
using the this vulnerability to gain

805
00:31:33,200 --> 00:31:35,760
access to your kubernetes cluster

806
00:31:35,760 --> 00:31:37,919
uh a target windows containers

807
00:31:37,919 --> 00:31:39,279
specifically

808
00:31:39,279 --> 00:31:41,679
in the in its case execution if it

809
00:31:41,679 --> 00:31:44,480
detected that the container or the host

810
00:31:44,480 --> 00:31:47,039
isn't a windows container it just

811
00:31:47,039 --> 00:31:48,559
exited

812
00:31:48,559 --> 00:31:52,159
and he used this exactly global symbolic

813
00:31:52,159 --> 00:31:54,720
symbolic link issue to spread in the

814
00:31:54,720 --> 00:31:56,880
rest of the kubernetes cluster it

815
00:31:56,880 --> 00:31:58,559
basically opened the bag though to its

816
00:31:58,559 --> 00:32:02,240
cnc and just waited for command

817
00:32:02,240 --> 00:32:03,840
and as part of my research i actually

818
00:32:03,840 --> 00:32:06,480
discovered it had active victims each

819
00:32:06,480 --> 00:32:08,480
one being a kubernetes cluster with the

820
00:32:08,480 --> 00:32:10,559
possibility of a huge amount of

821
00:32:10,559 --> 00:32:12,960
processing power i didn't have any way

822
00:32:12,960 --> 00:32:15,600
to actually check all right daniel uh

823
00:32:15,600 --> 00:32:17,279
just just jumping in here you have five

824
00:32:17,279 --> 00:32:19,279
minutes left and i actually have a

825
00:32:19,279 --> 00:32:21,279
question for you if you'd like to answer

826
00:32:21,279 --> 00:32:22,080
it

827
00:32:22,080 --> 00:32:24,480
um about i'm about to finish just a

828
00:32:24,480 --> 00:32:28,679
moment okay okay no problem

829
00:32:28,799 --> 00:32:32,399
uh okay so as as i was saying the the

830
00:32:32,399 --> 00:32:35,200
amount of processing power that the this

831
00:32:35,200 --> 00:32:38,640
kubernetes clusters had is unknown it

832
00:32:38,640 --> 00:32:41,919
could be huge clusters with huge amount

833
00:32:41,919 --> 00:32:44,480
of processors

834
00:32:44,480 --> 00:32:46,080
uh

835
00:32:46,080 --> 00:32:47,360
okay but

836
00:32:47,360 --> 00:32:49,519
but what can you do about it well there

837
00:32:49,519 --> 00:32:51,440
are a few things first of all in order

838
00:32:51,440 --> 00:32:54,399
for an attacker to even be in a position

839
00:32:54,399 --> 00:32:57,120
to use this issue if else needs to gain

840
00:32:57,120 --> 00:32:59,440
access to the to your container and most

841
00:32:59,440 --> 00:33:01,600
of the time this happens to an outdated

842
00:33:01,600 --> 00:33:03,360
application in your containers or a

843
00:33:03,360 --> 00:33:05,760
misconfigured container manager

844
00:33:05,760 --> 00:33:08,000
so keep your applications up to date

845
00:33:08,000 --> 00:33:10,799
even if they are inside a container

846
00:33:10,799 --> 00:33:12,320
this is relevant to both linux and

847
00:33:12,320 --> 00:33:13,679
windows actually

848
00:33:13,679 --> 00:33:15,600
and next this is the this is only

849
00:33:15,600 --> 00:33:18,080
relevant to windows i advise you to run

850
00:33:18,080 --> 00:33:20,000
your container as a container user

851
00:33:20,000 --> 00:33:22,159
instead of administrator it will be much

852
00:33:22,159 --> 00:33:23,679
harder to pull off something like that

853
00:33:23,679 --> 00:33:24,880
without

854
00:33:24,880 --> 00:33:27,360
administrator permissions and kubernetes

855
00:33:27,360 --> 00:33:29,279
supports that as well there is a special

856
00:33:29,279 --> 00:33:31,360
variable you can set in your yaml to run

857
00:33:31,360 --> 00:33:33,760
your applications user even in

858
00:33:33,760 --> 00:33:36,559
kubernetes and third update your windows

859
00:33:36,559 --> 00:33:38,559
host this is mostly relevant if you are

860
00:33:38,559 --> 00:33:40,320
running your cloud environment on your

861
00:33:40,320 --> 00:33:41,120
own

862
00:33:41,120 --> 00:33:42,559
and if you are using one of the cloud

863
00:33:42,559 --> 00:33:44,960
providers they usually keep the host

864
00:33:44,960 --> 00:33:46,080
updated

865
00:33:46,080 --> 00:33:48,320
and last but not least configure

866
00:33:48,320 --> 00:33:50,799
kubernetes properly for example there is

867
00:33:50,799 --> 00:33:53,200
no reason the nodes user will be a

868
00:33:53,200 --> 00:33:56,559
cluster administrator like in my demo

869
00:33:56,559 --> 00:33:58,559
nodes shouldn't be able to create

870
00:33:58,559 --> 00:34:00,720
deployments on other nodes

871
00:34:00,720 --> 00:34:02,960
uh and real quick because we are running

872
00:34:02,960 --> 00:34:05,279
off time a few weeks ago microsoft

873
00:34:05,279 --> 00:34:06,480
actually patched

874
00:34:06,480 --> 00:34:08,239
this anti-symbolic anti-semitic

875
00:34:08,239 --> 00:34:10,079
information metabolic link function

876
00:34:10,079 --> 00:34:12,079
and the patch is extremely easy to

877
00:34:12,079 --> 00:34:14,399
understand and spread forward as you can

878
00:34:14,399 --> 00:34:15,520
see

879
00:34:15,520 --> 00:34:17,359
any call to anticipate information's

880
00:34:17,359 --> 00:34:19,599
evolving from a thread inside a

881
00:34:19,599 --> 00:34:21,520
container will be blocked with status

882
00:34:21,520 --> 00:34:23,839
builder is not held at all

883
00:34:23,839 --> 00:34:26,159
and this is done using the ps's current

884
00:34:26,159 --> 00:34:28,399
red server silo function

885
00:34:28,399 --> 00:34:30,480
which as its name suggests checks

886
00:34:30,480 --> 00:34:32,320
whether the current thread is associated

887
00:34:32,320 --> 00:34:35,440
with the process inside the server silo

888
00:34:35,440 --> 00:34:36,560
on the right you can see how the

889
00:34:36,560 --> 00:34:38,639
function looks after the patch there is

890
00:34:38,639 --> 00:34:40,879
simply a call and there is a branch

891
00:34:40,879 --> 00:34:42,399
there which checks if the calls come

892
00:34:42,399 --> 00:34:44,560
from the cell asylum

893
00:34:44,560 --> 00:34:45,599
um

894
00:34:45,599 --> 00:34:47,679
so what's next i will probably start

895
00:34:47,679 --> 00:34:49,520
with checking microsoft's patch maybe

896
00:34:49,520 --> 00:34:51,440
the function the use

897
00:34:51,440 --> 00:34:53,520
maybe ps get going threads in server

898
00:34:53,520 --> 00:34:54,879
side is broken

899
00:34:54,879 --> 00:34:56,960
and i can still break out i will

900
00:34:56,960 --> 00:34:58,480
probably also look for other ways to

901
00:34:58,480 --> 00:35:00,839
abuse symbolic links to break out of the

902
00:35:00,839 --> 00:35:03,359
container and we'll also search for

903
00:35:03,359 --> 00:35:05,359
other access points to the host that are

904
00:35:05,359 --> 00:35:07,599
not specifically related to symbolic

905
00:35:07,599 --> 00:35:09,520
links

906
00:35:09,520 --> 00:35:14,280
and okay let's go over to questions

