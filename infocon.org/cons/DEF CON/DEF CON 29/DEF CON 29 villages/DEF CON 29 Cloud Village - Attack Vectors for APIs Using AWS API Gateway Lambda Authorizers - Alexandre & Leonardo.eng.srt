1
00:00:00,080 --> 00:00:02,000
thank you to all the cloud village team

2
00:00:02,000 --> 00:00:04,160
for accepting our cfp

3
00:00:04,160 --> 00:00:06,080
uh and allow us allowing us to speak

4
00:00:06,080 --> 00:00:07,040
today

5
00:00:07,040 --> 00:00:09,760
so let us introduce ourselves uh i'm

6
00:00:09,760 --> 00:00:11,679
alex sierra i'm co-founder and cto of

7
00:00:11,679 --> 00:00:13,200
tenchi security

8
00:00:13,200 --> 00:00:16,239
uh i'm also accompanied here by uh leo

9
00:00:16,239 --> 00:00:17,920
donald vaders

10
00:00:17,920 --> 00:00:20,320
i have presented before as

11
00:00:20,320 --> 00:00:21,840
uh jeff said in a few conferences

12
00:00:21,840 --> 00:00:25,039
including last year on uh cloud village

13
00:00:25,039 --> 00:00:26,800
on the topic on a presentation called

14
00:00:26,800 --> 00:00:29,359
sas apocalypse called talking about

15
00:00:29,359 --> 00:00:31,599
supply chain attacks in the cloud not

16
00:00:31,599 --> 00:00:34,000
that supply chains have become a hot

17
00:00:34,000 --> 00:00:34,800
thing

18
00:00:34,800 --> 00:00:37,520
in infosec you know this year

19
00:00:37,520 --> 00:00:39,280
but uh we haven't seen enough on the

20
00:00:39,280 --> 00:00:40,559
cloud yet

21
00:00:40,559 --> 00:00:41,440
um

22
00:00:41,440 --> 00:00:43,680
leo do you wanna say hi for a little bit

23
00:00:43,680 --> 00:00:45,600
hey hello everyone this is my very first

24
00:00:45,600 --> 00:00:46,480
time

25
00:00:46,480 --> 00:00:47,840
at defcon

26
00:00:47,840 --> 00:00:49,280
and

27
00:00:49,280 --> 00:00:51,920
this is actually six months ago i didn't

28
00:00:51,920 --> 00:00:53,600
knew about this

29
00:00:53,600 --> 00:00:56,480
i joined alexandre companies he told me

30
00:00:56,480 --> 00:00:58,800
about the amazing word of cyber security

31
00:00:58,800 --> 00:01:01,039
and here we are presenting

32
00:01:01,039 --> 00:01:03,680
how about that uh this time last year he

33
00:01:03,680 --> 00:01:05,360
didn't even know what defcon was now

34
00:01:05,360 --> 00:01:07,439
he's presenting in cloud village

35
00:01:07,439 --> 00:01:10,000
but let's talk about the subject at hand

36
00:01:10,000 --> 00:01:12,320
why should you care this this talk uh

37
00:01:12,320 --> 00:01:13,600
will cover

38
00:01:13,600 --> 00:01:17,119
a little bit a specific uh issue

39
00:01:17,119 --> 00:01:19,840
around doing serverless application

40
00:01:19,840 --> 00:01:23,360
security in aws right and serverless is

41
00:01:23,360 --> 00:01:25,040
a nice thing right serverless is all the

42
00:01:25,040 --> 00:01:26,960
rage right now you see

43
00:01:26,960 --> 00:01:28,880
getting a lot of good press

44
00:01:28,880 --> 00:01:31,040
it's been widely adopted as far as as we

45
00:01:31,040 --> 00:01:32,000
can see

46
00:01:32,000 --> 00:01:34,000
and it's good right i believe it's

47
00:01:34,000 --> 00:01:36,479
another step in the evolution of how we

48
00:01:36,479 --> 00:01:39,040
build applications that we're always

49
00:01:39,040 --> 00:01:40,799
looking for that next level the

50
00:01:40,799 --> 00:01:42,159
abstraction

51
00:01:42,159 --> 00:01:44,399
that already bundles many of the

52
00:01:44,399 --> 00:01:46,079
concerns and abstracts away some of the

53
00:01:46,079 --> 00:01:48,159
complexity of what's underneath

54
00:01:48,159 --> 00:01:50,320
and you know if we didn't progress in

55
00:01:50,320 --> 00:01:51,680
that sense toward higher level

56
00:01:51,680 --> 00:01:53,439
abstractions i mean we would all be

57
00:01:53,439 --> 00:01:56,159
writing distributed systems in assembly

58
00:01:56,159 --> 00:01:58,479
right which i don't think would be fun

59
00:01:58,479 --> 00:01:59,360
and so

60
00:01:59,360 --> 00:02:01,520
the end goal here of course is to always

61
00:02:01,520 --> 00:02:02,479
have

62
00:02:02,479 --> 00:02:04,719
the developers work as much of their

63
00:02:04,719 --> 00:02:06,799
time as possible writing business logic

64
00:02:06,799 --> 00:02:08,878
and delivering value to their business

65
00:02:08,878 --> 00:02:10,639
whatever that business is

66
00:02:10,639 --> 00:02:13,120
uh and as little time as possible

67
00:02:13,120 --> 00:02:15,760
focused on the nitty-gritty on you know

68
00:02:15,760 --> 00:02:17,680
the operating systems the applications

69
00:02:17,680 --> 00:02:19,200
the components and networks where their

70
00:02:19,200 --> 00:02:21,440
applications are running right because

71
00:02:21,440 --> 00:02:23,680
the business part is what's actually

72
00:02:23,680 --> 00:02:26,800
paying for everyone's salary right

73
00:02:26,800 --> 00:02:27,920
um

74
00:02:27,920 --> 00:02:31,680
and so but the thing is uh in serverless

75
00:02:31,680 --> 00:02:33,040
as any

76
00:02:33,040 --> 00:02:35,360
as well as on any of the previous layers

77
00:02:35,360 --> 00:02:36,879
of abstraction we used to do on

78
00:02:36,879 --> 00:02:38,400
development

79
00:02:38,400 --> 00:02:40,239
you always need to look at the

80
00:02:40,239 --> 00:02:42,400
foundations of the infrastructure your

81
00:02:42,400 --> 00:02:44,000
application is running on

82
00:02:44,000 --> 00:02:45,760
and if before serverless you were

83
00:02:45,760 --> 00:02:47,680
looking at servers and how they ran how

84
00:02:47,680 --> 00:02:49,519
they're configured how they scaled how

85
00:02:49,519 --> 00:02:51,519
would their availability look like

86
00:02:51,519 --> 00:02:53,280
now you have to be concerned about the

87
00:02:53,280 --> 00:02:55,519
serverless components and frameworks

88
00:02:55,519 --> 00:02:57,360
that your application's been built on

89
00:02:57,360 --> 00:03:00,239
top of and again worry about reliability

90
00:03:00,239 --> 00:03:03,519
scalability performance and security

91
00:03:03,519 --> 00:03:06,720
so if you're doing serverless in aws

92
00:03:06,720 --> 00:03:08,959
you will be hard pressed to avoid

93
00:03:08,959 --> 00:03:12,400
using amazon api gateway right or as aws

94
00:03:12,400 --> 00:03:14,560
employees would say api gateway i think

95
00:03:14,560 --> 00:03:16,959
right because they say army anyway

96
00:03:16,959 --> 00:03:20,319
uh what api gateway does and you gonna

97
00:03:20,319 --> 00:03:23,200
see it being used by pretty much any um

98
00:03:23,200 --> 00:03:25,440
serverless framework that works on aws

99
00:03:25,440 --> 00:03:28,560
like the serverless framework sim

100
00:03:28,560 --> 00:03:29,840
chalice

101
00:03:29,840 --> 00:03:31,040
you name it

102
00:03:31,040 --> 00:03:34,159
uh it's a serverless scalable reverse

103
00:03:34,159 --> 00:03:35,680
proxy service

104
00:03:35,680 --> 00:03:38,799
uh it it's gonna receive http https

105
00:03:38,799 --> 00:03:40,959
requests and it's gonna

106
00:03:40,959 --> 00:03:44,480
route them to a specified backend most

107
00:03:44,480 --> 00:03:45,680
typically when we're talking about

108
00:03:45,680 --> 00:03:48,159
surface applications those back ends

109
00:03:48,159 --> 00:03:49,840
will be lambda functions right you're

110
00:03:49,840 --> 00:03:52,400
going to have a rest api say and you're

111
00:03:52,400 --> 00:03:55,200
going to map each api endpoint to one or

112
00:03:55,200 --> 00:03:56,560
more or or

113
00:03:56,560 --> 00:03:58,159
actually you can map many endpoints to

114
00:03:58,159 --> 00:03:59,680
one lambda but you're mapping endpoints

115
00:03:59,680 --> 00:04:00,959
to lambdas

116
00:04:00,959 --> 00:04:03,200
that implement the logic behind that

117
00:04:03,200 --> 00:04:05,439
endpoint a client doesn't have to know

118
00:04:05,439 --> 00:04:07,840
what your back end is and if you're

119
00:04:07,840 --> 00:04:10,239
using lambdas again you're serverless

120
00:04:10,239 --> 00:04:11,760
all the way through that that's what we

121
00:04:11,760 --> 00:04:13,840
see being used the most often

122
00:04:13,840 --> 00:04:15,680
and since you have this one point for

123
00:04:15,680 --> 00:04:18,079
all this routing besides the actual

124
00:04:18,079 --> 00:04:20,560
routing uh api gateway is a nice

125
00:04:20,560 --> 00:04:22,079
integration point for a lot of

126
00:04:22,079 --> 00:04:24,160
additional features like scanning and

127
00:04:24,160 --> 00:04:25,360
caching

128
00:04:25,360 --> 00:04:27,199
the server the service itself api

129
00:04:27,199 --> 00:04:29,120
gateway as well as lend the scales on

130
00:04:29,120 --> 00:04:30,720
its own based on demand

131
00:04:30,720 --> 00:04:31,840
um

132
00:04:31,840 --> 00:04:34,880
but you can also do caching this both

133
00:04:34,880 --> 00:04:36,720
api gateway does its own caching but you

134
00:04:36,720 --> 00:04:38,240
can also integrate it with cloudfront to

135
00:04:38,240 --> 00:04:40,240
cache static content you can do

136
00:04:40,240 --> 00:04:42,639
versioning of your apis really easily

137
00:04:42,639 --> 00:04:43,840
you can do monitoring and of

138
00:04:43,840 --> 00:04:46,080
observability so api gateway generates

139
00:04:46,080 --> 00:04:47,360
their own logs but you can also

140
00:04:47,360 --> 00:04:49,360
integrate that with services like x-ray

141
00:04:49,360 --> 00:04:51,520
or cloud watch cloud watch logs things

142
00:04:51,520 --> 00:04:52,800
like that

143
00:04:52,800 --> 00:04:55,120
and as far as security goes api gateway

144
00:04:55,120 --> 00:04:57,360
can implement input validation if you

145
00:04:57,360 --> 00:04:59,520
specify you know the get parameters the

146
00:04:59,520 --> 00:05:02,080
path parameters you can specify uh some

147
00:05:02,080 --> 00:05:03,680
basic input validation is going to be

148
00:05:03,680 --> 00:05:06,080
performed uh even before your lambdas

149
00:05:06,080 --> 00:05:08,479
are called you can also use api gateways

150
00:05:08,479 --> 00:05:10,639
integration point for aws web

151
00:05:10,639 --> 00:05:12,800
application file or wafts

152
00:05:12,800 --> 00:05:15,360
an api gateway most importantly for our

153
00:05:15,360 --> 00:05:16,400
research

154
00:05:16,400 --> 00:05:18,560
also allows you to do authentication and

155
00:05:18,560 --> 00:05:20,560
authorization and abstract that away

156
00:05:20,560 --> 00:05:22,000
from your code

157
00:05:22,000 --> 00:05:25,440
a few key uh concepts around how api

158
00:05:25,440 --> 00:05:26,720
gateway works

159
00:05:26,720 --> 00:05:29,039
each api is an object that's not

160
00:05:29,039 --> 00:05:31,199
identified by my id that's generated

161
00:05:31,199 --> 00:05:33,520
automatically a bunch of

162
00:05:33,520 --> 00:05:35,360
like an account id but it has letters as

163
00:05:35,360 --> 00:05:37,360
well just not just numbers

164
00:05:37,360 --> 00:05:40,639
you can define as an api gate to a user

165
00:05:40,639 --> 00:05:43,199
stages for your api the way this is

166
00:05:43,199 --> 00:05:44,960
typically used is if you're going to

167
00:05:44,960 --> 00:05:46,960
have versioning it's going to be a stage

168
00:05:46,960 --> 00:05:49,360
called v1 and then a stage called v2 and

169
00:05:49,360 --> 00:05:51,840
v3 or you can have stages like

170
00:05:51,840 --> 00:05:53,520
development or production or things like

171
00:05:53,520 --> 00:05:54,960
that right

172
00:05:54,960 --> 00:05:57,520
um and so

173
00:05:57,520 --> 00:05:59,039
as far as authentication goes there are

174
00:05:59,039 --> 00:06:02,880
a few ways to implement it uh you have a

175
00:06:02,880 --> 00:06:06,080
ciam solution native to aws called

176
00:06:06,080 --> 00:06:09,120
amazon cognito it's a customer identity

177
00:06:09,120 --> 00:06:11,600
and access measurement solution

178
00:06:11,600 --> 00:06:12,960
we're going to talk about it on the next

179
00:06:12,960 --> 00:06:15,840
slide you have native capabilities on

180
00:06:15,840 --> 00:06:17,919
api gateway to do open id connect or

181
00:06:17,919 --> 00:06:19,759
oauth 2.0

182
00:06:19,759 --> 00:06:20,960
you can also

183
00:06:20,960 --> 00:06:22,160
god forbid

184
00:06:22,160 --> 00:06:25,039
use iam policies and privileges to allow

185
00:06:25,039 --> 00:06:27,840
uh entities or principles in your aws

186
00:06:27,840 --> 00:06:30,880
accounts to call api endpoints on an api

187
00:06:30,880 --> 00:06:32,880
gateway api

188
00:06:32,880 --> 00:06:33,759
and

189
00:06:33,759 --> 00:06:36,000
when you want to do something else

190
00:06:36,000 --> 00:06:38,319
when you want to do something bespoke or

191
00:06:38,319 --> 00:06:39,280
custom

192
00:06:39,280 --> 00:06:41,600
uh you go to something that is called

193
00:06:41,600 --> 00:06:43,520
lambda authorizers this is what you will

194
00:06:43,520 --> 00:06:45,759
use when you are integrating let's say

195
00:06:45,759 --> 00:06:48,160
with a third-party tool like off zero

196
00:06:48,160 --> 00:06:51,120
jump cloud or things like that

197
00:06:51,120 --> 00:06:53,919
so this is pretty frequent

198
00:06:53,919 --> 00:06:55,759
before we go into lambda authorizes

199
00:06:55,759 --> 00:06:57,440
which is the star of the the research

200
00:06:57,440 --> 00:06:58,560
here let's

201
00:06:58,560 --> 00:07:01,039
briefly credit my good friend andres

202
00:07:01,039 --> 00:07:04,400
riancho from argentina now working as a

203
00:07:04,400 --> 00:07:06,960
cso at wildlife studios uh he did a

204
00:07:06,960 --> 00:07:09,840
research in 2019 specifically on cognito

205
00:07:09,840 --> 00:07:12,319
security we won't delve deeply into that

206
00:07:12,319 --> 00:07:14,400
here but just to give you an idea

207
00:07:14,400 --> 00:07:18,000
so it's a cm solution uh from uh from

208
00:07:18,000 --> 00:07:19,199
aws

209
00:07:19,199 --> 00:07:22,240
uh but the way that a lot of the aws

210
00:07:22,240 --> 00:07:24,400
documentation describes

211
00:07:24,400 --> 00:07:26,800
uh developers should use it

212
00:07:26,800 --> 00:07:28,880
is was not a really good architecture

213
00:07:28,880 --> 00:07:30,960
the basically the idea was

214
00:07:30,960 --> 00:07:33,360
you create users you assign them to

215
00:07:33,360 --> 00:07:34,880
identity pools

216
00:07:34,880 --> 00:07:37,680
they can authenticate using either login

217
00:07:37,680 --> 00:07:40,000
password or social logins and once

218
00:07:40,000 --> 00:07:41,840
they're validated against an identity

219
00:07:41,840 --> 00:07:44,160
polls they can get a set of temporary

220
00:07:44,160 --> 00:07:46,800
aws credentials that hopefully have been

221
00:07:46,800 --> 00:07:49,360
scoped and have least privilege to just

222
00:07:49,360 --> 00:07:51,440
access the things on aws they need to

223
00:07:51,440 --> 00:07:53,840
access like calling lambdas or accessing

224
00:07:53,840 --> 00:07:56,160
files on s3 buckets or things like that

225
00:07:56,160 --> 00:07:57,120
right

226
00:07:57,120 --> 00:07:59,840
um the problem is that the the premise

227
00:07:59,840 --> 00:08:02,319
on the aws documentation was

228
00:08:02,319 --> 00:08:04,479
that client-side components of your

229
00:08:04,479 --> 00:08:06,160
application so your mobile app your

230
00:08:06,160 --> 00:08:07,840
single page application

231
00:08:07,840 --> 00:08:10,000
uh would do that

232
00:08:10,000 --> 00:08:12,720
the the credentials would go back from

233
00:08:12,720 --> 00:08:14,160
your api

234
00:08:14,160 --> 00:08:15,199
into

235
00:08:15,199 --> 00:08:17,680
the the the client and the client would

236
00:08:17,680 --> 00:08:21,440
then call aws apis directly which is a

237
00:08:21,440 --> 00:08:23,520
horrible idea it's like exposing your

238
00:08:23,520 --> 00:08:25,759
database to the internet and every time

239
00:08:25,759 --> 00:08:28,080
someone logs into your web application

240
00:08:28,080 --> 00:08:29,919
you provide i don't know the single page

241
00:08:29,919 --> 00:08:31,840
application of database credentials but

242
00:08:31,840 --> 00:08:33,440
to just give them access to the right

243
00:08:33,440 --> 00:08:35,200
tables and columns

244
00:08:35,200 --> 00:08:38,399
it's just not the right level of

245
00:08:38,399 --> 00:08:40,240
it there's an impedance mismatch right

246
00:08:40,240 --> 00:08:42,320
there you want to abstract that away

247
00:08:42,320 --> 00:08:44,399
through your api and have your api on

248
00:08:44,399 --> 00:08:46,000
api gateway have the necessary

249
00:08:46,000 --> 00:08:48,480
privileges to access any other aws

250
00:08:48,480 --> 00:08:49,680
resources

251
00:08:49,680 --> 00:08:52,160
and so what andres did when he found out

252
00:08:52,160 --> 00:08:54,560
that was what people were doing

253
00:08:54,560 --> 00:08:56,240
was he did a major search on the

254
00:08:56,240 --> 00:08:57,839
internet including common crawl and

255
00:08:57,839 --> 00:08:58,800
other

256
00:08:58,800 --> 00:09:01,600
large data sets and he found a lot of

257
00:09:01,600 --> 00:09:03,519
web applications and then some mobile

258
00:09:03,519 --> 00:09:06,959
applications that had identity pools uh

259
00:09:06,959 --> 00:09:09,279
ids hard coded into the apps to do

260
00:09:09,279 --> 00:09:11,040
precisely that

261
00:09:11,040 --> 00:09:13,200
moreover he found out that you don't

262
00:09:13,200 --> 00:09:15,519
even need to be authenticated to get

263
00:09:15,519 --> 00:09:17,519
some aws credentials when you create

264
00:09:17,519 --> 00:09:19,680
you're using cod needle you can set

265
00:09:19,680 --> 00:09:21,279
a level of

266
00:09:21,279 --> 00:09:23,519
access even for anonymous users for

267
00:09:23,519 --> 00:09:25,760
unauthenticated users so just using

268
00:09:25,760 --> 00:09:26,640
those

269
00:09:26,640 --> 00:09:28,640
he was able to gain access to over 13

270
00:09:28,640 --> 00:09:31,120
000 s3 bucks that were not public

271
00:09:31,120 --> 00:09:34,399
1200 dynamodb tables and 1500 lambda

272
00:09:34,399 --> 00:09:35,360
functions

273
00:09:35,360 --> 00:09:37,600
pretty amazing research check out this

274
00:09:37,600 --> 00:09:38,560
link

275
00:09:38,560 --> 00:09:40,720
check out his paper

276
00:09:40,720 --> 00:09:43,600
it's really scary

277
00:09:43,680 --> 00:09:46,560
now back to api gateway

278
00:09:46,560 --> 00:09:48,240
let's talk a little bit about how lambda

279
00:09:48,240 --> 00:09:50,480
authorizers work right so as we were

280
00:09:50,480 --> 00:09:51,920
describing before

281
00:09:51,920 --> 00:09:54,080
if you have an api on api gateway you

282
00:09:54,080 --> 00:09:55,120
have a client that's going to do a

283
00:09:55,120 --> 00:09:57,600
request and then api gateway has to make

284
00:09:57,600 --> 00:09:59,760
a decision on whether this request is

285
00:09:59,760 --> 00:10:02,240
authorized or not to route that to let's

286
00:10:02,240 --> 00:10:04,320
say a lambda implementation then that

287
00:10:04,320 --> 00:10:06,399
implements that api endpoint when you

288
00:10:06,399 --> 00:10:08,160
use lambda authorizers the way this

289
00:10:08,160 --> 00:10:09,839
happens is

290
00:10:09,839 --> 00:10:11,519
before they call the lambda that

291
00:10:11,519 --> 00:10:13,600
actually implements the api operation

292
00:10:13,600 --> 00:10:15,839
they call a special lambda called the

293
00:10:15,839 --> 00:10:17,920
lambda authorizer right that's also part

294
00:10:17,920 --> 00:10:19,760
of your application it's a lambda

295
00:10:19,760 --> 00:10:22,399
function that will get as a parameter

296
00:10:22,399 --> 00:10:24,640
the authentication tokens that were

297
00:10:24,640 --> 00:10:27,440
presented on that http request typically

298
00:10:27,440 --> 00:10:30,240
the authorization http header right you

299
00:10:30,240 --> 00:10:31,920
can configure it to be anything else you

300
00:10:31,920 --> 00:10:34,160
want like a get parameter or another

301
00:10:34,160 --> 00:10:35,360
header right

302
00:10:35,360 --> 00:10:37,519
but typically that's that that's what's

303
00:10:37,519 --> 00:10:39,279
used by default and that's what makes

304
00:10:39,279 --> 00:10:41,360
the most sense for most people

305
00:10:41,360 --> 00:10:43,519
and so what that lambda does is it gets

306
00:10:43,519 --> 00:10:46,880
that information besides a lot of other

307
00:10:46,880 --> 00:10:48,320
information about

308
00:10:48,320 --> 00:10:51,360
other things on on that http request

309
00:10:51,360 --> 00:10:53,920
it evaluates you know let's say that

310
00:10:53,920 --> 00:10:56,000
authorization headers has a json web

311
00:10:56,000 --> 00:10:57,760
token or has

312
00:10:57,760 --> 00:11:00,320
some other form an api key you're going

313
00:11:00,320 --> 00:11:02,959
to evaluate that using whatever logic

314
00:11:02,959 --> 00:11:04,560
and code you want to write and you're

315
00:11:04,560 --> 00:11:06,320
going to return

316
00:11:06,320 --> 00:11:07,200
uh

317
00:11:07,200 --> 00:11:09,760
information to api gateway that tells it

318
00:11:09,760 --> 00:11:11,279
who this user is

319
00:11:11,279 --> 00:11:13,279
any metadata that you want to have

320
00:11:13,279 --> 00:11:16,000
passed to the back end of the api let's

321
00:11:16,000 --> 00:11:17,600
say that the lambdas that implement the

322
00:11:17,600 --> 00:11:19,440
api operations

323
00:11:19,440 --> 00:11:22,640
and you're going to give that

324
00:11:22,640 --> 00:11:24,880
api gateway what's called a policy

325
00:11:24,880 --> 00:11:26,320
document

326
00:11:26,320 --> 00:11:28,800
let's look that tells api gateway which

327
00:11:28,800 --> 00:11:30,720
operations that person can and cannot

328
00:11:30,720 --> 00:11:32,800
invoke so let's look at what that that

329
00:11:32,800 --> 00:11:34,480
looks like this is straight from the aws

330
00:11:34,480 --> 00:11:36,800
documentation basically

331
00:11:36,800 --> 00:11:39,040
the lambda authorizer typically will

332
00:11:39,040 --> 00:11:41,360
return a json object

333
00:11:41,360 --> 00:11:44,240
that will identify the user right which

334
00:11:44,240 --> 00:11:46,320
which principle it is

335
00:11:46,320 --> 00:11:47,920
it's going to give a context with

336
00:11:47,920 --> 00:11:49,600
metadata let's say which groups they

337
00:11:49,600 --> 00:11:51,440
belong to which privileges they have in

338
00:11:51,440 --> 00:11:53,760
your application or things like that

339
00:11:53,760 --> 00:11:55,760
those things will be passed along as

340
00:11:55,760 --> 00:11:58,000
additional parameters to the lambdas

341
00:11:58,000 --> 00:11:59,920
that implement api operations on your

342
00:11:59,920 --> 00:12:00,959
api

343
00:12:00,959 --> 00:12:03,200
but also importantly there's this one

344
00:12:03,200 --> 00:12:05,760
field called policy documents

345
00:12:05,760 --> 00:12:08,399
that this is the part that api gateway

346
00:12:08,399 --> 00:12:11,360
itself will process fully use that's

347
00:12:11,360 --> 00:12:14,480
what it will use to decide which api

348
00:12:14,480 --> 00:12:16,720
endpoints this user can call

349
00:12:16,720 --> 00:12:17,519
and

350
00:12:17,519 --> 00:12:18,959
shockingly

351
00:12:18,959 --> 00:12:21,440
this is not in the form that anyone that

352
00:12:21,440 --> 00:12:23,519
has ever used a reverse proxy a web

353
00:12:23,519 --> 00:12:25,760
application viral would expect what you

354
00:12:25,760 --> 00:12:27,600
would expect would be something like a

355
00:12:27,600 --> 00:12:29,519
list of reg x's

356
00:12:29,519 --> 00:12:31,519
of urls they can access or things like

357
00:12:31,519 --> 00:12:32,399
that

358
00:12:32,399 --> 00:12:33,920
instead

359
00:12:33,920 --> 00:12:36,880
what the api gateway team decided to do

360
00:12:36,880 --> 00:12:41,920
was to implement this in an iam aws iam

361
00:12:41,920 --> 00:12:43,519
policy format

362
00:12:43,519 --> 00:12:45,440
so basically they created an action

363
00:12:45,440 --> 00:12:48,880
called execute api code invoke right and

364
00:12:48,880 --> 00:12:51,839
then you have the traditional format of

365
00:12:51,839 --> 00:12:53,920
allow deny and you have to specify a

366
00:12:53,920 --> 00:12:55,120
resource

367
00:12:55,120 --> 00:12:57,040
and if you look at how they encode that

368
00:12:57,040 --> 00:13:00,240
resource here right it's an ran an

369
00:13:00,240 --> 00:13:02,800
amazon resource notation as usual

370
00:13:02,800 --> 00:13:05,760
uh with an execute api service right and

371
00:13:05,760 --> 00:13:08,079
then you have the region as usual

372
00:13:08,079 --> 00:13:09,760
because api gateway is a regional

373
00:13:09,760 --> 00:13:12,000
service you have the account id and then

374
00:13:12,000 --> 00:13:14,480
on the last on segment where the

375
00:13:14,480 --> 00:13:17,360
resource would come in right they have

376
00:13:17,360 --> 00:13:21,440
encoded separated by slashes the api id

377
00:13:21,440 --> 00:13:23,200
the stage name that we talked about

378
00:13:23,200 --> 00:13:26,320
before like v1 v2 or broad dev

379
00:13:26,320 --> 00:13:31,760
the http verb so get put post delete etc

380
00:13:31,760 --> 00:13:33,760
and the path the resource right so the

381
00:13:33,760 --> 00:13:36,160
actual url path

382
00:13:36,160 --> 00:13:38,959
of the api endpoint that was called

383
00:13:38,959 --> 00:13:41,760
so basically what api gateway will do is

384
00:13:41,760 --> 00:13:44,000
they will store that policy

385
00:13:44,000 --> 00:13:46,000
and every time

386
00:13:46,000 --> 00:13:48,240
they're gonna cache it you that's that's

387
00:13:48,240 --> 00:13:50,480
the way again this is most often used

388
00:13:50,480 --> 00:13:52,480
it's optional but it wouldn't make sense

389
00:13:52,480 --> 00:13:54,079
to not use it

390
00:13:54,079 --> 00:13:56,399
api gateway will cache that policy for

391
00:13:56,399 --> 00:13:58,160
amount of time and every time someone

392
00:13:58,160 --> 00:14:00,240
comes in with that same authorization

393
00:14:00,240 --> 00:14:03,519
header it's gonna evaluate is the ap not

394
00:14:03,519 --> 00:14:05,279
gonna call the lambda authorizer again

395
00:14:05,279 --> 00:14:07,600
just gonna use the cached response to

396
00:14:07,600 --> 00:14:08,399
say

397
00:14:08,399 --> 00:14:10,959
is the end pointer calling match an

398
00:14:10,959 --> 00:14:13,120
allow statement on this policy document

399
00:14:13,120 --> 00:14:14,800
they're gonna build on iron based on the

400
00:14:14,800 --> 00:14:16,399
request that's being made they're going

401
00:14:16,399 --> 00:14:17,920
to compare that

402
00:14:17,920 --> 00:14:20,639
with the policy that was returned by the

403
00:14:20,639 --> 00:14:23,600
lambda authorizer right

404
00:14:23,600 --> 00:14:24,639
so

405
00:14:24,639 --> 00:14:26,160
this is

406
00:14:26,160 --> 00:14:28,399
a controversial decision

407
00:14:28,399 --> 00:14:31,360
i can't understand a little bit why they

408
00:14:31,360 --> 00:14:33,920
did this right if you are developing a

409
00:14:33,920 --> 00:14:36,079
new service at aws and you want to

410
00:14:36,079 --> 00:14:38,800
achieve mvp status as much as possible

411
00:14:38,800 --> 00:14:41,680
the iam policy engine it's just sitting

412
00:14:41,680 --> 00:14:43,120
there right it's

413
00:14:43,120 --> 00:14:45,680
tried it's trusted it's scalable it's

414
00:14:45,680 --> 00:14:48,000
free for for users but it's not charged

415
00:14:48,000 --> 00:14:49,279
music

416
00:14:49,279 --> 00:14:51,040
that probably also has implications on

417
00:14:51,040 --> 00:14:53,920
the price they had to to to charge for

418
00:14:53,920 --> 00:14:55,600
api gateway right

419
00:14:55,600 --> 00:14:58,720
uh but here's the thing first of all

420
00:14:58,720 --> 00:15:01,199
this is a format that's not at all

421
00:15:01,199 --> 00:15:03,519
familiar and intuitive to developers

422
00:15:03,519 --> 00:15:06,560
it's much more so to ops into security

423
00:15:06,560 --> 00:15:07,360
folk

424
00:15:07,360 --> 00:15:09,760
than to developers right that people

425
00:15:09,760 --> 00:15:11,839
that deal with iam

426
00:15:11,839 --> 00:15:14,000
on a daily basis

427
00:15:14,000 --> 00:15:17,600
uh and also it's not nearly granular

428
00:15:17,600 --> 00:15:19,839
enough for the things you need to

429
00:15:19,839 --> 00:15:21,120
represent

430
00:15:21,120 --> 00:15:23,760
uh when you're trying to to to control

431
00:15:23,760 --> 00:15:26,480
access to api endpoints right

432
00:15:26,480 --> 00:15:28,560
so it's it's case sensitive that that's

433
00:15:28,560 --> 00:15:29,920
not a problem

434
00:15:29,920 --> 00:15:30,720
but

435
00:15:30,720 --> 00:15:32,560
it doesn't have regular expression

436
00:15:32,560 --> 00:15:33,920
matching

437
00:15:33,920 --> 00:15:36,000
right so think about it think if you

438
00:15:36,000 --> 00:15:37,279
have an

439
00:15:37,279 --> 00:15:39,839
api path parameter that's part of your

440
00:15:39,839 --> 00:15:43,440
path part of the url you're encoding ids

441
00:15:43,440 --> 00:15:45,440
that are essentially external parameters

442
00:15:45,440 --> 00:15:47,279
that instead of being provided to the

443
00:15:47,279 --> 00:15:48,880
api in the form of

444
00:15:48,880 --> 00:15:49,839
a get

445
00:15:49,839 --> 00:15:52,480
parameter like after the question mark

446
00:15:52,480 --> 00:15:55,680
it's being passed as part of the path as

447
00:15:55,680 --> 00:15:59,600
as usual you know with rest apis

448
00:15:59,600 --> 00:16:01,519
there's no good way

449
00:16:01,519 --> 00:16:06,320
in aws iam policy to specify this url

450
00:16:06,320 --> 00:16:08,639
and to be clear that you're just

451
00:16:08,639 --> 00:16:11,199
allowing this type of value a specific

452
00:16:11,199 --> 00:16:14,160
type of ad say a uuid or a number

453
00:16:14,160 --> 00:16:16,639
on that middle of the url

454
00:16:16,639 --> 00:16:19,279
because when you look at iam policy

455
00:16:19,279 --> 00:16:20,720
syntax

456
00:16:20,720 --> 00:16:23,519
it's very literal and all you have are

457
00:16:23,519 --> 00:16:25,839
two wild cards you have a question mark

458
00:16:25,839 --> 00:16:28,800
to signify just one character like the

459
00:16:28,800 --> 00:16:31,120
dot on regular expressions

460
00:16:31,120 --> 00:16:32,959
and you have the star

461
00:16:32,959 --> 00:16:36,639
which greedily expands to anything on

462
00:16:36,639 --> 00:16:39,120
that one iron segment

463
00:16:39,120 --> 00:16:41,920
right if we recall how irons work they

464
00:16:41,920 --> 00:16:43,839
have several segments separated by

465
00:16:43,839 --> 00:16:45,279
colons right

466
00:16:45,279 --> 00:16:47,440
and so if you have a

467
00:16:47,440 --> 00:16:50,480
an asterisk anywhere inside this entire

468
00:16:50,480 --> 00:16:51,839
last part

469
00:16:51,839 --> 00:16:54,639
with api id stage http verb resource et

470
00:16:54,639 --> 00:16:57,519
cetera you can expand to occupy the

471
00:16:57,519 --> 00:17:00,639
entire thing it will not stop at slashes

472
00:17:00,639 --> 00:17:03,199
it would not stop at anything except the

473
00:17:03,199 --> 00:17:05,599
end of the string and this first colon

474
00:17:05,599 --> 00:17:07,280
here right

475
00:17:07,280 --> 00:17:08,640
so

476
00:17:08,640 --> 00:17:11,359
this is a huge problem because it makes

477
00:17:11,359 --> 00:17:13,919
it so that it's really hard

478
00:17:13,919 --> 00:17:16,959
to avoid making mistakes and to apply

479
00:17:16,959 --> 00:17:18,480
least privilege here

480
00:17:18,480 --> 00:17:20,240
i'm going to let leo tell you a little

481
00:17:20,240 --> 00:17:23,599
bit about a few examples that he built

482
00:17:23,599 --> 00:17:25,439
that showcases this

483
00:17:25,439 --> 00:17:27,679
leo

484
00:17:27,679 --> 00:17:30,160
yeah so suppose those are the end points

485
00:17:30,160 --> 00:17:33,919
for regular users of our application not

486
00:17:33,919 --> 00:17:36,400
admins or staff users just regular users

487
00:17:36,400 --> 00:17:38,160
that can create an account in your

488
00:17:38,160 --> 00:17:40,000
website

489
00:17:40,000 --> 00:17:42,000
as we can see we have

490
00:17:42,000 --> 00:17:45,120
post get put and delete methods and all

491
00:17:45,120 --> 00:17:47,679
of the routes has a prefix of dashboard

492
00:17:47,679 --> 00:17:48,720
on it

493
00:17:48,720 --> 00:17:50,559
so we do make total sense for a

494
00:17:50,559 --> 00:17:52,559
developer that wants to be economical on

495
00:17:52,559 --> 00:17:54,160
the way they write

496
00:17:54,160 --> 00:17:56,960
api gateway allow policies to write

497
00:17:56,960 --> 00:17:58,160
something like

498
00:17:58,160 --> 00:18:01,840
we have there so our api id slash prod

499
00:18:01,840 --> 00:18:03,760
for our stage name of production for

500
00:18:03,760 --> 00:18:04,960
example

501
00:18:04,960 --> 00:18:07,280
slash star to match all of the methods

502
00:18:07,280 --> 00:18:09,120
suppose you get put and delete slash

503
00:18:09,120 --> 00:18:10,799
dashboard for everything related to

504
00:18:10,799 --> 00:18:13,039
dashboard that is what uh this

505
00:18:13,039 --> 00:18:15,760
underprivileged users can do

506
00:18:15,760 --> 00:18:16,960
slash

507
00:18:16,960 --> 00:18:19,440
stars again to match for example

508
00:18:19,440 --> 00:18:20,640
user

509
00:18:20,640 --> 00:18:24,160
user with username user login and stuff

510
00:18:24,160 --> 00:18:25,600
like that

511
00:18:25,600 --> 00:18:28,080
so it's something for a developer to

512
00:18:28,080 --> 00:18:30,160
write a policy like that it's very

513
00:18:30,160 --> 00:18:31,919
simple and security and simplicity

514
00:18:31,919 --> 00:18:34,160
security and simplicity goes together

515
00:18:34,160 --> 00:18:36,400
right

516
00:18:36,559 --> 00:18:37,679
wrong

517
00:18:37,679 --> 00:18:39,280
actually when you write something like

518
00:18:39,280 --> 00:18:40,080
that

519
00:18:40,080 --> 00:18:41,200
please next

520
00:18:41,200 --> 00:18:43,200
slide

521
00:18:43,200 --> 00:18:46,240
uh we will out sorry would you allow

522
00:18:46,240 --> 00:18:48,240
other routes as well so suppose we have

523
00:18:48,240 --> 00:18:50,160
these other two rounds that are reserved

524
00:18:50,160 --> 00:18:53,120
for admin users with elevated privileges

525
00:18:53,120 --> 00:18:55,280
the first one for example admin store

526
00:18:55,280 --> 00:18:57,120
order credit card dashboard that's going

527
00:18:57,120 --> 00:18:58,960
to charge users in their credit card and

528
00:18:58,960 --> 00:19:01,120
the next one admin dashboard create

529
00:19:01,120 --> 00:19:03,360
admin users that's going to let you

530
00:19:03,360 --> 00:19:06,400
create another admin users the first

531
00:19:06,400 --> 00:19:10,480
star will expand not just in this post

532
00:19:10,480 --> 00:19:12,720
method but also

533
00:19:12,720 --> 00:19:15,840
in admin store order and credit card

534
00:19:15,840 --> 00:19:18,240
so the user regular user that has this

535
00:19:18,240 --> 00:19:20,320
policy will also be able to call this

536
00:19:20,320 --> 00:19:21,520
method

537
00:19:21,520 --> 00:19:25,120
and now so please next and also the last

538
00:19:25,120 --> 00:19:28,559
star will also expand the two

539
00:19:28,559 --> 00:19:31,120
after post method admin slash dashboard

540
00:19:31,120 --> 00:19:34,640
and create admin user so as stars can be

541
00:19:34,640 --> 00:19:37,360
anything there can also be nothing so

542
00:19:37,360 --> 00:19:39,039
independent if you have

543
00:19:39,039 --> 00:19:40,960
dashboard in your route in the beginning

544
00:19:40,960 --> 00:19:43,200
the middle of the or the end of your

545
00:19:43,200 --> 00:19:45,280
endpoint definition

546
00:19:45,280 --> 00:19:47,840
a user with this kind of policy will be

547
00:19:47,840 --> 00:19:51,760
able to call these endpoints

548
00:19:51,760 --> 00:19:54,080
please

549
00:19:54,080 --> 00:19:55,600
now we're going to take a look in a

550
00:19:55,600 --> 00:19:58,080
video of a deployed stack with these

551
00:19:58,080 --> 00:19:59,760
exactly same

552
00:19:59,760 --> 00:20:00,640
uh

553
00:20:00,640 --> 00:20:03,280
methods we have some user methods and

554
00:20:03,280 --> 00:20:05,200
some admin methods we're going to see if

555
00:20:05,200 --> 00:20:08,559
it really works or if it's historical

556
00:20:08,559 --> 00:20:11,840
please can you play the video

557
00:20:12,400 --> 00:20:14,159
first thing we're going to show you the

558
00:20:14,159 --> 00:20:15,679
end points but it's pretty much the same

559
00:20:15,679 --> 00:20:18,799
thing you just saw two admin routes and

560
00:20:18,799 --> 00:20:22,240
six other user routes

561
00:20:22,240 --> 00:20:23,600
and then we're going to take a look at

562
00:20:23,600 --> 00:20:26,959
our authorization function

563
00:20:27,760 --> 00:20:29,679
it's pretty standard authorization

564
00:20:29,679 --> 00:20:31,520
function every serverless developer

565
00:20:31,520 --> 00:20:33,679
should be very familiar with it first

566
00:20:33,679 --> 00:20:36,240
things first we we verify we receive an

567
00:20:36,240 --> 00:20:39,120
authorization token if we did so we use

568
00:20:39,120 --> 00:20:42,559
a dwt generator token to verify that we

569
00:20:42,559 --> 00:20:44,000
could use a third-party authentication

570
00:20:44,000 --> 00:20:45,600
provider but for the sake of simplicity

571
00:20:45,600 --> 00:20:48,240
we just do a verify and after we found

572
00:20:48,240 --> 00:20:50,880
that the user is has the role of user we

573
00:20:50,880 --> 00:20:53,840
generate this policy with star slash

574
00:20:53,840 --> 00:20:55,919
dashboard slash star just like we

575
00:20:55,919 --> 00:20:58,400
mentioned before and this first star is

576
00:20:58,400 --> 00:21:01,840
where we have our fault

577
00:21:01,840 --> 00:21:04,159
now we're going to start fetching uh or

578
00:21:04,159 --> 00:21:06,640
having requests against these routes so

579
00:21:06,640 --> 00:21:08,320
first thing we're going to get a

580
00:21:08,320 --> 00:21:10,480
dashboard user with the username let's

581
00:21:10,480 --> 00:21:13,200
see if that succeeds yeah it's a 6 200

582
00:21:13,200 --> 00:21:15,600
okay as expected

583
00:21:15,600 --> 00:21:17,600
then the other without the username in

584
00:21:17,600 --> 00:21:19,840
the end slash dashboard slash user of

585
00:21:19,840 --> 00:21:21,440
course it succeeds

586
00:21:21,440 --> 00:21:24,480
and then the boot method after that

587
00:21:24,480 --> 00:21:26,480
and it succeeds as well we're not going

588
00:21:26,480 --> 00:21:28,000
to test every one of them because we

589
00:21:28,000 --> 00:21:29,919
have very little time but you got the

590
00:21:29,919 --> 00:21:32,559
idea all the user methods are going to

591
00:21:32,559 --> 00:21:34,159
succeed

592
00:21:34,159 --> 00:21:36,400
just as expected but what about admin

593
00:21:36,400 --> 00:21:37,360
routes

594
00:21:37,360 --> 00:21:40,720
the credit card and create admin stuff

595
00:21:40,720 --> 00:21:43,280
we've made a post on admin store order

596
00:21:43,280 --> 00:21:45,679
credit card slash dashboard

597
00:21:45,679 --> 00:21:47,679
we will answer this need with the same

598
00:21:47,679 --> 00:21:50,000
token with the same rule of the regular

599
00:21:50,000 --> 00:21:51,600
user not admin

600
00:21:51,600 --> 00:21:54,000
and the same thing about admin dashboard

601
00:21:54,000 --> 00:21:55,440
create admin user proving that

602
00:21:55,440 --> 00:21:57,600
independent if it's in the beginning the

603
00:21:57,600 --> 00:22:00,320
middle or the end if you have star slash

604
00:22:00,320 --> 00:22:02,000
dashboards like star

605
00:22:02,000 --> 00:22:04,720
it will match

606
00:22:04,720 --> 00:22:06,080
see thank you

607
00:22:06,080 --> 00:22:08,080
thank you leo uh and so it's important

608
00:22:08,080 --> 00:22:10,559
to note that if you had a path parameter

609
00:22:10,559 --> 00:22:12,080
and you were able to choose as an

610
00:22:12,080 --> 00:22:13,679
attacker to have the word dashboard

611
00:22:13,679 --> 00:22:15,120
there let's say there were entities you

612
00:22:15,120 --> 00:22:16,320
could create that would be later

613
00:22:16,320 --> 00:22:19,200
represented in some other url the simple

614
00:22:19,200 --> 00:22:21,360
fact that it had dashboard there

615
00:22:21,360 --> 00:22:23,360
that one

616
00:22:23,360 --> 00:22:25,280
arn would allow you to call that

617
00:22:25,280 --> 00:22:27,360
endpoint so you can see how it's pretty

618
00:22:27,360 --> 00:22:31,360
easy to mess it up uh using stars right

619
00:22:31,360 --> 00:22:33,280
uh and

620
00:22:33,280 --> 00:22:34,880
more importantly

621
00:22:34,880 --> 00:22:38,240
uh it seems like even the team working

622
00:22:38,240 --> 00:22:40,880
at api gateway aws or at least a team

623
00:22:40,880 --> 00:22:42,240
documenting

624
00:22:42,240 --> 00:22:44,400
and doing other tasks for the api

625
00:22:44,400 --> 00:22:45,840
gateway

626
00:22:45,840 --> 00:22:48,080
seemed to have an incorrect

627
00:22:48,080 --> 00:22:50,559
understanding of how the stars expanded

628
00:22:50,559 --> 00:22:52,720
on iam policies right it seemed like

629
00:22:52,720 --> 00:22:54,640
they themselves

630
00:22:54,640 --> 00:22:57,280
were not fully sure how this worked uh

631
00:22:57,280 --> 00:22:59,440
which is a shame because developers that

632
00:22:59,440 --> 00:23:01,120
were diligent that read the

633
00:23:01,120 --> 00:23:03,039
documentation for api gateway they would

634
00:23:03,039 --> 00:23:05,039
have been misled by this documentation

635
00:23:05,039 --> 00:23:07,039
so this is one example from the old

636
00:23:07,039 --> 00:23:08,720
version of that documentation has since

637
00:23:08,720 --> 00:23:10,000
been fixed we're going to talk about

638
00:23:10,000 --> 00:23:12,240
this in a little bit but it says what

639
00:23:12,240 --> 00:23:14,799
about you want to create a policy that

640
00:23:14,799 --> 00:23:17,520
allows you to access any method in the

641
00:23:17,520 --> 00:23:19,200
htcp method

642
00:23:19,200 --> 00:23:22,159
any resource on any api but on the test

643
00:23:22,159 --> 00:23:23,440
stage

644
00:23:23,440 --> 00:23:25,679
right now with the way that the

645
00:23:25,679 --> 00:23:29,360
granulatory that the policy document has

646
00:23:29,360 --> 00:23:32,400
it's impossible to create a policy that

647
00:23:32,400 --> 00:23:34,000
does that

648
00:23:34,000 --> 00:23:36,159
but the api gateway team said you can

649
00:23:36,159 --> 00:23:39,360
just say star slash test slash star on

650
00:23:39,360 --> 00:23:41,760
that last arn segment and you're going

651
00:23:41,760 --> 00:23:43,120
to achieve that

652
00:23:43,120 --> 00:23:45,520
that's incorrect you aren't allowing

653
00:23:45,520 --> 00:23:47,279
anything on the test stage but you're

654
00:23:47,279 --> 00:23:48,960
also allowing much more if you look at

655
00:23:48,960 --> 00:23:50,799
those four numbered examples here on the

656
00:23:50,799 --> 00:23:52,159
bottom right

657
00:23:52,159 --> 00:23:54,640
so what you intended was number one but

658
00:23:54,640 --> 00:23:56,720
you were also allowing numbers two three

659
00:23:56,720 --> 00:23:58,080
and four

660
00:23:58,080 --> 00:24:00,320
right so it seems and you're going to be

661
00:24:00,320 --> 00:24:01,760
seeing that

662
00:24:01,760 --> 00:24:04,880
more and more uh on the official aws

663
00:24:04,880 --> 00:24:07,440
content that the team writing this

664
00:24:07,440 --> 00:24:10,320
seemed to think that stars stopped

665
00:24:10,320 --> 00:24:12,320
expanding at slashes

666
00:24:12,320 --> 00:24:15,279
which is not this is not how they work

667
00:24:15,279 --> 00:24:16,240
right

668
00:24:16,240 --> 00:24:18,400
you can see this is explicitly said on

669
00:24:18,400 --> 00:24:20,640
that's later on that same documentation

670
00:24:20,640 --> 00:24:23,760
page uh the api id can be replaced by an

671
00:24:23,760 --> 00:24:28,000
asterisk for all apis that's not

672
00:24:28,000 --> 00:24:29,760
what it does at all it's gonna

673
00:24:29,760 --> 00:24:31,520
be able to be replaced by everything

674
00:24:31,520 --> 00:24:33,600
else and also include the stage name

675
00:24:33,600 --> 00:24:35,679
http verbs etc so you can see they do

676
00:24:35,679 --> 00:24:37,600
that with every single field

677
00:24:37,600 --> 00:24:40,080
whereas as if you could use asterisk to

678
00:24:40,080 --> 00:24:42,720
replace just that one field

679
00:24:42,720 --> 00:24:45,520
right again as we just saw that that's

680
00:24:45,520 --> 00:24:47,120
not how this works

681
00:24:47,120 --> 00:24:49,440
right

682
00:24:49,440 --> 00:24:52,000
also aws provided

683
00:24:52,000 --> 00:24:53,919
what they call lambda authorizer

684
00:24:53,919 --> 00:24:55,919
blueprints they have which is pretty a

685
00:24:55,919 --> 00:24:57,520
pretty awesome idea by the way kudos to

686
00:24:57,520 --> 00:25:00,400
aws for doing this they have on the aws

687
00:25:00,400 --> 00:25:03,279
labs github account they wrote like a

688
00:25:03,279 --> 00:25:04,559
skeleton

689
00:25:04,559 --> 00:25:06,720
a blueprint of how an and lambda

690
00:25:06,720 --> 00:25:08,400
authorizer should work on a variety of

691
00:25:08,400 --> 00:25:11,279
languages so you know

692
00:25:11,279 --> 00:25:13,600
javascript with node

693
00:25:13,600 --> 00:25:14,559
python

694
00:25:14,559 --> 00:25:16,960
go rust et cetera

695
00:25:16,960 --> 00:25:19,039
and then developers can take a shortcut

696
00:25:19,039 --> 00:25:20,480
instead of copying and pasting from

697
00:25:20,480 --> 00:25:22,320
stack overflow they can copy and paste

698
00:25:22,320 --> 00:25:25,600
from aws's own github repo

699
00:25:25,600 --> 00:25:29,279
the problem is the repo had that same

700
00:25:29,279 --> 00:25:30,960
incorrect assumption

701
00:25:30,960 --> 00:25:33,200
you can see they had comments saying you

702
00:25:33,200 --> 00:25:35,600
could replace any one of those things by

703
00:25:35,600 --> 00:25:37,760
an asterisk and and that wouldn't affect

704
00:25:37,760 --> 00:25:38,960
anything else

705
00:25:38,960 --> 00:25:41,919
you had default values for api ids or

706
00:25:41,919 --> 00:25:44,640
stages or methods being asterisk on some

707
00:25:44,640 --> 00:25:46,799
of the language versions

708
00:25:46,799 --> 00:25:49,200
right and again that's leading your

709
00:25:49,200 --> 00:25:52,480
developers towards making a mistake

710
00:25:52,480 --> 00:25:55,600
and even the aws console reinforces that

711
00:25:55,600 --> 00:25:57,440
incorrect assumption

712
00:25:57,440 --> 00:26:00,240
for example this is the console for api

713
00:26:00,240 --> 00:26:02,720
gateway so if you look at a particular

714
00:26:02,720 --> 00:26:04,000
method or a

715
00:26:04,000 --> 00:26:05,520
better request

716
00:26:05,520 --> 00:26:08,840
you can see that it's creating that same

717
00:26:08,840 --> 00:26:12,799
arn format it's giving you the api id

718
00:26:12,799 --> 00:26:16,880
and then as an asterisk for the stage

719
00:26:16,880 --> 00:26:19,760
and then get and then a path right it's

720
00:26:19,760 --> 00:26:21,679
using just

721
00:26:21,679 --> 00:26:24,159
replacing just the stage by an asterisk

722
00:26:24,159 --> 00:26:26,640
when it's showing you

723
00:26:26,640 --> 00:26:27,840
what this

724
00:26:27,840 --> 00:26:30,320
arn for this particular operation would

725
00:26:30,320 --> 00:26:31,600
look like

726
00:26:31,600 --> 00:26:32,640
um

727
00:26:32,640 --> 00:26:35,679
and the same in the lambda console if

728
00:26:35,679 --> 00:26:38,000
you go to a lambda that's being used as

729
00:26:38,000 --> 00:26:40,240
the implementation of an api endpoint

730
00:26:40,240 --> 00:26:42,159
it's going to tell you there's a trigger

731
00:26:42,159 --> 00:26:44,720
from api gateway and it's going to give

732
00:26:44,720 --> 00:26:46,880
you again something that looks like that

733
00:26:46,880 --> 00:26:49,840
invoke api arn format

734
00:26:49,840 --> 00:26:51,360
and it's going to be

735
00:26:51,360 --> 00:26:54,080
api id and then the method

736
00:26:54,080 --> 00:26:56,799
and the stage are going to be asterisks

737
00:26:56,799 --> 00:26:57,600
so

738
00:26:57,600 --> 00:27:01,600
all around ews the epi gateway team the

739
00:27:01,600 --> 00:27:05,279
ws console team the team that wrote the

740
00:27:05,279 --> 00:27:06,720
blueprints

741
00:27:06,720 --> 00:27:08,640
seem to be working under this incorrect

742
00:27:08,640 --> 00:27:09,840
assumption

743
00:27:09,840 --> 00:27:10,880
that

744
00:27:10,880 --> 00:27:12,960
stars expanded differently

745
00:27:12,960 --> 00:27:15,120
than what they actually do and that has

746
00:27:15,120 --> 00:27:17,760
to mislead developers right so let's

747
00:27:17,760 --> 00:27:20,480
look at at a little uh

748
00:27:20,480 --> 00:27:24,080
at actual examples of places where this

749
00:27:24,080 --> 00:27:25,360
came to pass

750
00:27:25,360 --> 00:27:26,720
leo

751
00:27:26,720 --> 00:27:29,360
yeah now looking at real world scenarios

752
00:27:29,360 --> 00:27:31,360
it's not so easy to find too many

753
00:27:31,360 --> 00:27:33,039
serverless applications that are open

754
00:27:33,039 --> 00:27:35,600
source but we find one that is pretty

755
00:27:35,600 --> 00:27:37,600
interesting in this case

756
00:27:37,600 --> 00:27:39,520
it is an application that makes

757
00:27:39,520 --> 00:27:41,679
difference between guests and admin

758
00:27:41,679 --> 00:27:44,480
users and because there are no such way

759
00:27:44,480 --> 00:27:46,640
to represent using regular expression

760
00:27:46,640 --> 00:27:49,360
for example the parameter paths of the

761
00:27:49,360 --> 00:27:51,520
api these developers just wrote

762
00:27:51,520 --> 00:27:54,159
something like get slash problems slash

763
00:27:54,159 --> 00:27:56,799
stars let's submissions and for example

764
00:27:56,799 --> 00:27:59,120
pose slash problems slash star slash

765
00:27:59,120 --> 00:28:00,480
submit

766
00:28:00,480 --> 00:28:02,480
thinking that it will allow for example

767
00:28:02,480 --> 00:28:05,440
just using the ideas of uh these

768
00:28:05,440 --> 00:28:06,720
problems that are

769
00:28:06,720 --> 00:28:08,640
getting the submissions posting and get

770
00:28:08,640 --> 00:28:11,039
the submissions but in reality he is

771
00:28:11,039 --> 00:28:14,080
allowed much more rounds for example if

772
00:28:14,080 --> 00:28:16,480
he has an admin route that has something

773
00:28:16,480 --> 00:28:20,799
related with uh submit in the end or in

774
00:28:20,799 --> 00:28:22,159
any part of it

775
00:28:22,159 --> 00:28:24,640
like we have using this example get

776
00:28:24,640 --> 00:28:27,200
problems full bar submissions or post

777
00:28:27,200 --> 00:28:29,440
problems full bar submit

778
00:28:29,440 --> 00:28:31,760
uh this the guest user with this policy

779
00:28:31,760 --> 00:28:34,799
will also be able to call uh this device

780
00:28:34,799 --> 00:28:36,880
so this is one of the examples we found

781
00:28:36,880 --> 00:28:39,279
no there are not so many uh open source

782
00:28:39,279 --> 00:28:40,720
service projects but

783
00:28:40,720 --> 00:28:44,480
this is one a very interesting one

784
00:28:44,480 --> 00:28:48,159
and also as a developer we everyone in

785
00:28:48,159 --> 00:28:49,440
their life say

786
00:28:49,440 --> 00:28:51,279
well it works on my machine

787
00:28:51,279 --> 00:28:54,000
and this is exactly the case with when

788
00:28:54,000 --> 00:28:56,399
we are developing serverless apis using

789
00:28:56,399 --> 00:28:59,120
serverless framework

790
00:28:59,120 --> 00:29:01,919
as npm says this service offline plugin

791
00:29:01,919 --> 00:29:06,240
has around 130 134 000 downloads per

792
00:29:06,240 --> 00:29:08,960
week so it's not something not used it's

793
00:29:08,960 --> 00:29:11,600
very useful and it's what i use it all

794
00:29:11,600 --> 00:29:14,640
my life to developing uh serverless apis

795
00:29:14,640 --> 00:29:16,480
and it has a difference between the way

796
00:29:16,480 --> 00:29:19,760
it be it comports between your machine

797
00:29:19,760 --> 00:29:22,559
and when it's deployed to aws in this

798
00:29:22,559 --> 00:29:25,279
example we are fetching a post we are

799
00:29:25,279 --> 00:29:26,880
doing a post on

800
00:29:26,880 --> 00:29:29,120
a route that is dashboard

801
00:29:29,120 --> 00:29:31,600
our stage dev and slash dashboard and

802
00:29:31,600 --> 00:29:33,039
that's it

803
00:29:33,039 --> 00:29:35,120
in the server it's offline plugin that

804
00:29:35,120 --> 00:29:37,440
we're going to test in your machine

805
00:29:37,440 --> 00:29:40,000
it uh says it's forbidden for 103

806
00:29:40,000 --> 00:29:42,159
forbidden you can't do this but when we

807
00:29:42,159 --> 00:29:44,080
deploy the same stack the same code to

808
00:29:44,080 --> 00:29:45,200
aws

809
00:29:45,200 --> 00:29:48,320
it allows us to call this method

810
00:29:48,320 --> 00:29:51,039
and it's very bad because

811
00:29:51,039 --> 00:29:53,279
probably this serverless offline plugins

812
00:29:53,279 --> 00:29:55,679
is being used in ci city validations and

813
00:29:55,679 --> 00:29:58,080
manual validations and there are leading

814
00:29:58,080 --> 00:30:00,240
to developers believe they are safe

815
00:30:00,240 --> 00:30:02,720
in reality when they are not safe at all

816
00:30:02,720 --> 00:30:04,880
this is a consequence of im policies

817
00:30:04,880 --> 00:30:07,120
being very complex and much more

818
00:30:07,120 --> 00:30:09,360
familiar for security and knobs guys

819
00:30:09,360 --> 00:30:11,360
than developers and as developers right

820
00:30:11,360 --> 00:30:12,960
tools for developers we end up in a

821
00:30:12,960 --> 00:30:15,039
situation like that

822
00:30:15,039 --> 00:30:16,640
we can't reproduce the very same

823
00:30:16,640 --> 00:30:19,279
situation we have when deployed in our

824
00:30:19,279 --> 00:30:21,919
local machine

825
00:30:22,480 --> 00:30:24,399
yeah so it's sad even developers that

826
00:30:24,399 --> 00:30:26,640
try to be do the right thing and test

827
00:30:26,640 --> 00:30:28,159
their application thoroughly to make

828
00:30:28,159 --> 00:30:29,679
sure things that should be blocked are

829
00:30:29,679 --> 00:30:31,520
being blocked if they're using really

830
00:30:31,520 --> 00:30:33,760
well known and good and awesome reliable

831
00:30:33,760 --> 00:30:35,760
tools like serverless offline they're

832
00:30:35,760 --> 00:30:37,440
being heard by this we submitted this as

833
00:30:37,440 --> 00:30:39,760
an issue as you can see uh we're not

834
00:30:39,760 --> 00:30:42,559
sure if they have fixed the the problem

835
00:30:42,559 --> 00:30:43,360
yet

836
00:30:43,360 --> 00:30:45,279
uh but we hope they do soon and if we

837
00:30:45,279 --> 00:30:46,559
have the time we'll even try to write a

838
00:30:46,559 --> 00:30:50,559
pull request uh to to assist in this uh

839
00:30:50,559 --> 00:30:53,279
so once we found this this was on april

840
00:30:53,279 --> 00:30:56,240
uh of this year uh we started so what we

841
00:30:56,240 --> 00:30:57,840
did was responsible disclosure we

842
00:30:57,840 --> 00:31:00,159
reached out to aws we reported the

843
00:31:00,159 --> 00:31:02,080
issues we found in the documentation on

844
00:31:02,080 --> 00:31:04,480
the console on the um

845
00:31:04,480 --> 00:31:06,399
the aws console

846
00:31:06,399 --> 00:31:08,159
we had a variety of conversations with

847
00:31:08,159 --> 00:31:10,080
them going back and forth

848
00:31:10,080 --> 00:31:11,120
they were

849
00:31:11,120 --> 00:31:13,039
very responsive they were really

850
00:31:13,039 --> 00:31:14,960
professional they were really concerned

851
00:31:14,960 --> 00:31:17,360
on doing the right thing i have nothing

852
00:31:17,360 --> 00:31:19,440
but good words to say to them and

853
00:31:19,440 --> 00:31:20,640
especially

854
00:31:20,640 --> 00:31:22,480
i'd like to thank mark ryland for the

855
00:31:22,480 --> 00:31:23,919
the role he played

856
00:31:23,919 --> 00:31:26,640
in intermediating helping mediate this

857
00:31:26,640 --> 00:31:28,720
conversation right

858
00:31:28,720 --> 00:31:31,200
the only thing i would say was

859
00:31:31,200 --> 00:31:33,760
a little bit less than stellar is the

860
00:31:33,760 --> 00:31:35,760
fact that they made a decision not to

861
00:31:35,760 --> 00:31:38,240
update the aws console they continue to

862
00:31:38,240 --> 00:31:42,399
use stars as a placeholder for any api

863
00:31:42,399 --> 00:31:44,720
stage or any api id

864
00:31:44,720 --> 00:31:46,480
on the lambda console and the api

865
00:31:46,480 --> 00:31:48,960
gateway console which i i i wish they

866
00:31:48,960 --> 00:31:50,880
hadn't i wish they fixed it

867
00:31:50,880 --> 00:31:53,760
but uh they didn't in any case

868
00:31:53,760 --> 00:31:55,519
the documentation for api gateway for

869
00:31:55,519 --> 00:31:57,840
iem and the lambda authorizer blueprints

870
00:31:57,840 --> 00:32:00,320
was was fixed and leo even helped them

871
00:32:00,320 --> 00:32:02,559
on the lambda blueprint stuff by

872
00:32:02,559 --> 00:32:04,960
submitting a pull request

873
00:32:04,960 --> 00:32:06,640
and so this was very collaborative and

874
00:32:06,640 --> 00:32:08,320
we thank them for

875
00:32:08,320 --> 00:32:11,120
for being so nice about us

876
00:32:11,120 --> 00:32:12,799
and

877
00:32:12,799 --> 00:32:14,720
the other thing we tried to do was

878
00:32:14,720 --> 00:32:16,799
thinking look we have something here

879
00:32:16,799 --> 00:32:19,279
that is getting external input

880
00:32:19,279 --> 00:32:22,960
and based on this input it's generating

881
00:32:22,960 --> 00:32:25,120
a policy that's going to be executed by

882
00:32:25,120 --> 00:32:26,799
api gateway

883
00:32:26,799 --> 00:32:29,279
so if we replace those words with a sql

884
00:32:29,279 --> 00:32:30,880
command that's going to be run by a

885
00:32:30,880 --> 00:32:32,559
database

886
00:32:32,559 --> 00:32:35,200
we started thinking hmm maybe we can do

887
00:32:35,200 --> 00:32:37,919
an iem policy injection attack can i

888
00:32:37,919 --> 00:32:40,399
send some form when there's a lender

889
00:32:40,399 --> 00:32:42,880
authorizer that uses part of the

890
00:32:42,880 --> 00:32:44,640
request even if it's just the

891
00:32:44,640 --> 00:32:46,399
authorization header or maybe a field

892
00:32:46,399 --> 00:32:50,000
inside a json web token to build

893
00:32:50,000 --> 00:32:52,320
uh the document the policy document

894
00:32:52,320 --> 00:32:53,200
right

895
00:32:53,200 --> 00:32:54,399
can we

896
00:32:54,399 --> 00:32:57,120
escape the quote you know

897
00:32:57,120 --> 00:32:59,760
and insert an entire new statement on

898
00:32:59,760 --> 00:33:02,640
that policy that allows for asterisk

899
00:33:02,640 --> 00:33:04,880
that allows for everything

900
00:33:04,880 --> 00:33:07,919
and it turns out we can't we cannot uh

901
00:33:07,919 --> 00:33:09,840
aws made a choice that lambda

902
00:33:09,840 --> 00:33:12,080
authorizers cannot return strings it

903
00:33:12,080 --> 00:33:14,159
fails if you try to return a string with

904
00:33:14,159 --> 00:33:16,399
that response format it has to be a

905
00:33:16,399 --> 00:33:18,399
native language object like an object in

906
00:33:18,399 --> 00:33:20,799
javascript or a dict in python

907
00:33:20,799 --> 00:33:22,559
and so there's very little opportunity

908
00:33:22,559 --> 00:33:24,640
to escape the string and try to change

909
00:33:24,640 --> 00:33:27,039
the structure of the document so that

910
00:33:27,039 --> 00:33:29,200
kind of injection attack

911
00:33:29,200 --> 00:33:32,399
uh was pretty thoroughly foiled

912
00:33:32,399 --> 00:33:33,760
we don't know if it was just a happy

913
00:33:33,760 --> 00:33:35,600
coincidence on how lamb does work and

914
00:33:35,600 --> 00:33:37,760
their wrappers do the hard work of

915
00:33:37,760 --> 00:33:40,799
converting things to json uh in any case

916
00:33:40,799 --> 00:33:43,360
it it did the trick

917
00:33:43,360 --> 00:33:45,519
but what about inside that resource

918
00:33:45,519 --> 00:33:47,279
string not escaping it

919
00:33:47,279 --> 00:33:50,240
what about we have a resource that's in

920
00:33:50,240 --> 00:33:51,679
a part of the policy that's going to use

921
00:33:51,679 --> 00:33:54,080
external data let's say we get a

922
00:33:54,080 --> 00:33:56,080
user id inside a

923
00:33:56,080 --> 00:33:58,960
json web token and we are able to change

924
00:33:58,960 --> 00:34:01,760
it to an asterisk okay that might work

925
00:34:01,760 --> 00:34:03,600
that might actually work

926
00:34:03,600 --> 00:34:06,399
but no one's going to do that right

927
00:34:06,399 --> 00:34:07,440
oops

928
00:34:07,440 --> 00:34:10,399
uh it turns out the very

929
00:34:10,399 --> 00:34:13,839
aws blog entry where they announced

930
00:34:13,839 --> 00:34:16,560
the introduction of

931
00:34:16,560 --> 00:34:19,199
lambda authorizers had exactly that

932
00:34:19,199 --> 00:34:21,199
problem they were

933
00:34:21,199 --> 00:34:24,159
deciding how to build that arn

934
00:34:24,159 --> 00:34:25,679
by adding

935
00:34:25,679 --> 00:34:28,800
slash users slash the content of a field

936
00:34:28,800 --> 00:34:31,679
on a jwt on a json web token and of

937
00:34:31,679 --> 00:34:32,800
course

938
00:34:32,800 --> 00:34:34,960
json web tokens are signed if you can

939
00:34:34,960 --> 00:34:37,119
tamper with json web tokens you're

940
00:34:37,119 --> 00:34:39,520
already you know on the second or third

941
00:34:39,520 --> 00:34:41,440
stage of an attack chain

942
00:34:41,440 --> 00:34:43,839
but still uh you know

943
00:34:43,839 --> 00:34:47,040
saying uh algorithm equals none on jwts

944
00:34:47,040 --> 00:34:48,560
is not exactly no

945
00:34:48,560 --> 00:34:50,399
uh and there might be other ways in

946
00:34:50,399 --> 00:34:53,199
which you can subvert or create uh jwt

947
00:34:53,199 --> 00:34:56,320
is under your control if you can

948
00:34:56,320 --> 00:34:58,480
or if you can find other ways to inject

949
00:34:58,480 --> 00:35:00,720
data that you think are going to end up

950
00:35:00,720 --> 00:35:02,480
into a policy document

951
00:35:02,480 --> 00:35:04,240
try changing them to an asterisk or

952
00:35:04,240 --> 00:35:06,800
appending an asterisk after them and see

953
00:35:06,800 --> 00:35:08,320
how that changes the authorization

954
00:35:08,320 --> 00:35:09,920
decisions of their api

955
00:35:09,920 --> 00:35:12,400
this might actually work

956
00:35:12,400 --> 00:35:13,359
right

957
00:35:13,359 --> 00:35:15,280
so we're going to close up

958
00:35:15,280 --> 00:35:17,760
with a few recommendations right on on

959
00:35:17,760 --> 00:35:20,720
things that aws can do and that everyone

960
00:35:20,720 --> 00:35:21,839
else can do

961
00:35:21,839 --> 00:35:23,760
starting with aws

962
00:35:23,760 --> 00:35:25,839
the first thing they could do that's i

963
00:35:25,839 --> 00:35:27,599
mean they're pretty tied down with their

964
00:35:27,599 --> 00:35:29,839
decision to use the iam policy format

965
00:35:29,839 --> 00:35:31,760
right it would be a big change for them

966
00:35:31,760 --> 00:35:34,560
to add an additional format based on reg

967
00:35:34,560 --> 00:35:37,200
access or even harder i think to add rig

968
00:35:37,200 --> 00:35:39,359
access to iam

969
00:35:39,359 --> 00:35:40,480
right

970
00:35:40,480 --> 00:35:43,040
but one quick thing they could do is add

971
00:35:43,040 --> 00:35:46,640
conditions uh currently that

972
00:35:46,640 --> 00:35:49,839
execute api invoke action does not allow

973
00:35:49,839 --> 00:35:51,440
for any conditions it's just standard

974
00:35:51,440 --> 00:35:53,760
part of how iam policies are

975
00:35:53,760 --> 00:35:56,800
evaluated if you had conditions for the

976
00:35:56,800 --> 00:36:00,240
api id the stage the method and the

977
00:36:00,240 --> 00:36:02,400
resource separately

978
00:36:02,400 --> 00:36:05,200
you could do that thing where i want to

979
00:36:05,200 --> 00:36:09,119
allow just the test stage for any api on

980
00:36:09,119 --> 00:36:11,440
any method or any resource it would look

981
00:36:11,440 --> 00:36:13,920
like the right side of the slide

982
00:36:13,920 --> 00:36:17,119
it is currently impossible to do this or

983
00:36:17,119 --> 00:36:18,720
anything without conditions that

984
00:36:18,720 --> 00:36:20,880
replicates exactly that

985
00:36:20,880 --> 00:36:22,560
right

986
00:36:22,560 --> 00:36:24,800
but if they added conditions

987
00:36:24,800 --> 00:36:27,359
this would already make it so much more

988
00:36:27,359 --> 00:36:30,320
granular like you wouldn't believe right

989
00:36:30,320 --> 00:36:32,960
uh please please reconsider the decision

990
00:36:32,960 --> 00:36:34,960
not to update the aws console change

991
00:36:34,960 --> 00:36:36,480
those placeholders you know curly

992
00:36:36,480 --> 00:36:38,640
brackets api id curly brackets or

993
00:36:38,640 --> 00:36:41,280
anything other than asterisks you don't

994
00:36:41,280 --> 00:36:43,280
want do not want to

995
00:36:43,280 --> 00:36:45,599
lead developers into using asterisks

996
00:36:45,599 --> 00:36:48,640
when they do write the arns themselves

997
00:36:48,640 --> 00:36:51,520
so don't do that

998
00:36:51,520 --> 00:36:52,960
and

999
00:36:52,960 --> 00:36:54,880
just the conditions and just exchange

1000
00:36:54,880 --> 00:36:57,520
here still doesn't fix the problem of

1001
00:36:57,520 --> 00:36:59,839
how to deal with path parameters

1002
00:36:59,839 --> 00:37:03,440
so that can only work if they extend

1003
00:37:03,440 --> 00:37:06,079
and add more functionality to iam as it

1004
00:37:06,079 --> 00:37:08,160
exists today and my understanding again

1005
00:37:08,160 --> 00:37:10,880
either more functions that match regular

1006
00:37:10,880 --> 00:37:13,520
expressions on conditions or if they add

1007
00:37:13,520 --> 00:37:15,839
a new wildcard that doesn't expand

1008
00:37:15,839 --> 00:37:18,160
beyond slashes right that's not the

1009
00:37:18,160 --> 00:37:20,320
question mark and the star right one of

1010
00:37:20,320 --> 00:37:22,560
those two things has to happen right

1011
00:37:22,560 --> 00:37:25,200
and finally it's pretty it seems to me i

1012
00:37:25,200 --> 00:37:27,280
know nothing about how aws works

1013
00:37:27,280 --> 00:37:29,200
internally but it seems to me like they

1014
00:37:29,200 --> 00:37:31,599
they need to have more senior security

1015
00:37:31,599 --> 00:37:34,560
people on those famous two pizza teams

1016
00:37:34,560 --> 00:37:36,480
when they're designing how products work

1017
00:37:36,480 --> 00:37:37,760
because this is the sort of thing that a

1018
00:37:37,760 --> 00:37:39,440
security person probably would have got

1019
00:37:39,440 --> 00:37:40,880
early on when they were designing the

1020
00:37:40,880 --> 00:37:42,079
service

1021
00:37:42,079 --> 00:37:44,640
right for aws customers if you're using

1022
00:37:44,640 --> 00:37:48,000
stars on those uh invoke api arn's

1023
00:37:48,000 --> 00:37:50,640
only use it at the very end as a slash

1024
00:37:50,640 --> 00:37:54,000
star at the very end to allow a prefix

1025
00:37:54,000 --> 00:37:56,000
for your path

1026
00:37:56,000 --> 00:37:58,079
anything other than this and you're

1027
00:37:58,079 --> 00:38:00,480
treading on on dangerous ground right

1028
00:38:00,480 --> 00:38:02,160
you're in quicksand

1029
00:38:02,160 --> 00:38:05,040
you got one minute okay you might be

1030
00:38:05,040 --> 00:38:06,960
able to use deny statements to limit the

1031
00:38:06,960 --> 00:38:09,119
impact of some of those expansions so

1032
00:38:09,119 --> 00:38:10,560
look into that

1033
00:38:10,560 --> 00:38:13,359
uh do not use lambda authorizers as the

1034
00:38:13,359 --> 00:38:16,000
only way to decide authorization since

1035
00:38:16,000 --> 00:38:17,440
specifically you cannot handle path

1036
00:38:17,440 --> 00:38:19,359
parameters well you might need to

1037
00:38:19,359 --> 00:38:21,440
recheck at the lambdas that actually

1038
00:38:21,440 --> 00:38:23,680
implement the api endpoints if the user

1039
00:38:23,680 --> 00:38:25,839
is authorized or not right

1040
00:38:25,839 --> 00:38:27,839
if you used any lambda authorizer

1041
00:38:27,839 --> 00:38:30,079
blueprint code update it based on the

1042
00:38:30,079 --> 00:38:31,680
new version

1043
00:38:31,680 --> 00:38:33,920
and

1044
00:38:33,920 --> 00:38:34,960
that's it

1045
00:38:34,960 --> 00:38:37,359
those are the things we're recommending

1046
00:38:37,359 --> 00:38:38,880
let's see if you guys have any questions

1047
00:38:38,880 --> 00:38:40,320
that we might be able to answer hope you

1048
00:38:40,320 --> 00:38:43,200
enjoyed it

