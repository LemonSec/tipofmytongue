1
00:00:00,080 --> 00:00:02,240
hello and welcome to encryption for

2
00:00:02,240 --> 00:00:04,000
developers or everything that you want

3
00:00:04,000 --> 00:00:05,759
to know about crypto but we're afraid to

4
00:00:05,759 --> 00:00:07,040
ask

5
00:00:07,040 --> 00:00:10,080
my name is james mckee i do developer

6
00:00:10,080 --> 00:00:11,920
security at trimble

7
00:00:11,920 --> 00:00:14,880
um i have some certs in the development

8
00:00:14,880 --> 00:00:16,880
space i have some certs in the

9
00:00:16,880 --> 00:00:19,199
security space which puts me as a pretty

10
00:00:19,199 --> 00:00:21,199
interesting uh place

11
00:00:21,199 --> 00:00:22,560
uh if you want to find me on the

12
00:00:22,560 --> 00:00:24,960
internet you can do so at punk coder

13
00:00:24,960 --> 00:00:26,920
and you can also reach me at punkcoder

14
00:00:26,920 --> 00:00:28,960
protonmail.com

15
00:00:28,960 --> 00:00:30,800
i'm also one of the people behind

16
00:00:30,800 --> 00:00:32,399
besides boulder so you should probably

17
00:00:32,399 --> 00:00:35,120
check that out too if you like this

18
00:00:35,120 --> 00:00:37,440
uh what i do um so for years i was a

19
00:00:37,440 --> 00:00:38,239
developer

20
00:00:38,239 --> 00:00:40,640
and it was kind of over the time of

21
00:00:40,640 --> 00:00:42,840
doing my development work that i ended

22
00:00:42,840 --> 00:00:44,000
transitioning

23
00:00:44,000 --> 00:00:47,600
into uh cyber security

24
00:00:47,600 --> 00:00:49,760
and now i act as a an intermediary

25
00:00:49,760 --> 00:00:51,680
really between the cyber security staff

26
00:00:51,680 --> 00:00:52,960
and development staff

27
00:00:52,960 --> 00:00:55,199
that puts me clearly in the orange team

28
00:00:55,199 --> 00:00:56,239
space

29
00:00:56,239 --> 00:00:58,399
i do things like code reviews and i

30
00:00:58,399 --> 00:00:59,760
teach developers

31
00:00:59,760 --> 00:01:01,520
how to do the things that our

32
00:01:01,520 --> 00:01:03,680
adversaries will do to our software

33
00:01:03,680 --> 00:01:05,438
so that they can learn not to do those

34
00:01:05,438 --> 00:01:07,680
things uh it's a fantastic job i love

35
00:01:07,680 --> 00:01:08,560
what i do

36
00:01:08,560 --> 00:01:10,880
um but much of this talk kind of comes

37
00:01:10,880 --> 00:01:12,880
through that lens

38
00:01:12,880 --> 00:01:14,720
and hopefully that information should be

39
00:01:14,720 --> 00:01:16,240
helpful to you uh

40
00:01:16,240 --> 00:01:18,080
regardless of whether you're following

41
00:01:18,080 --> 00:01:19,840
this from kind of a corporate standpoint

42
00:01:19,840 --> 00:01:21,680
or an individual developer and talking

43
00:01:21,680 --> 00:01:23,119
about encryption

44
00:01:23,119 --> 00:01:26,000
um if by some chance i say crypto i

45
00:01:26,000 --> 00:01:28,000
actually mean cryptography

46
00:01:28,000 --> 00:01:30,320
not cryptocurrency i have a tendency to

47
00:01:30,320 --> 00:01:32,000
to say that

48
00:01:32,000 --> 00:01:34,000
um so let's start with story time once

49
00:01:34,000 --> 00:01:36,000
upon a time i was working in this role

50
00:01:36,000 --> 00:01:38,799
and i was invited to a code review

51
00:01:38,799 --> 00:01:41,119
and the developer was giving me the

52
00:01:41,119 --> 00:01:42,159
opportunity to

53
00:01:42,159 --> 00:01:44,720
take a look at some source code and they

54
00:01:44,720 --> 00:01:45,680
wanted me to

55
00:01:45,680 --> 00:01:47,680
kind of review the the piece that they'd

56
00:01:47,680 --> 00:01:49,759
done but this was done by a junior

57
00:01:49,759 --> 00:01:51,680
developer and basically it was

58
00:01:51,680 --> 00:01:53,600
writing another login page nobody wants

59
00:01:53,600 --> 00:01:55,439
to write another login page so they give

60
00:01:55,439 --> 00:01:56,240
it to the

61
00:01:56,240 --> 00:01:58,159
to the new guy and so he goes through

62
00:01:58,159 --> 00:01:59,439
and builds this

63
00:01:59,439 --> 00:02:02,240
and he was given the device the guidance

64
00:02:02,240 --> 00:02:03,920
that developers should salt and hash

65
00:02:03,920 --> 00:02:05,040
their passwords

66
00:02:05,040 --> 00:02:07,920
okay so what we ended up with was this

67
00:02:07,920 --> 00:02:09,280
code

68
00:02:09,280 --> 00:02:11,840
in which they actually took some pretty

69
00:02:11,840 --> 00:02:12,879
solid

70
00:02:12,879 --> 00:02:15,440
randomly generated cryptographic salt

71
00:02:15,440 --> 00:02:18,080
hard-coded it into the code

72
00:02:18,080 --> 00:02:20,640
and then took that appended the that to

73
00:02:20,640 --> 00:02:21,599
the password

74
00:02:21,599 --> 00:02:24,080
ran it through a single round of sha-1

75
00:02:24,080 --> 00:02:26,400
and then save that off to the database

76
00:02:26,400 --> 00:02:28,160
now luckily we caught this before it

77
00:02:28,160 --> 00:02:30,400
ever went to a production environment

78
00:02:30,400 --> 00:02:32,560
but it kind of speaks to a disconnect

79
00:02:32,560 --> 00:02:33,840
here right

80
00:02:33,840 --> 00:02:35,680
the developer in the space did exactly

81
00:02:35,680 --> 00:02:37,040
what they were told

82
00:02:37,040 --> 00:02:40,560
they just didn't understand the why

83
00:02:40,560 --> 00:02:42,560
but let's stop and step back for a

84
00:02:42,560 --> 00:02:46,000
second ask how did we get here

85
00:02:46,000 --> 00:02:48,800
um you know developers should care about

86
00:02:48,800 --> 00:02:50,720
cryptography this is one of those things

87
00:02:50,720 --> 00:02:51,280
that

88
00:02:51,280 --> 00:02:53,120
you know if we go into the realm of

89
00:02:53,120 --> 00:02:54,879
things that can make applications safe

90
00:02:54,879 --> 00:02:56,720
and make them secure cryptography is one

91
00:02:56,720 --> 00:02:58,000
of those pieces

92
00:02:58,000 --> 00:03:00,000
and many of the failures in cyber

93
00:03:00,000 --> 00:03:01,280
security uh

94
00:03:01,280 --> 00:03:03,599
really come from ignorance about

95
00:03:03,599 --> 00:03:05,360
cryptography and the correct ways to use

96
00:03:05,360 --> 00:03:07,280
it in the correct applications

97
00:03:07,280 --> 00:03:09,519
improperly using cryptography can leave

98
00:03:09,519 --> 00:03:10,800
you in a spot that's

99
00:03:10,800 --> 00:03:13,360
as bad or maybe worse than no crypto at

100
00:03:13,360 --> 00:03:14,400
all

101
00:03:14,400 --> 00:03:16,400
the information that gets to developers

102
00:03:16,400 --> 00:03:18,560
about cryptography and generally about

103
00:03:18,560 --> 00:03:21,280
cyber security issues can sometimes be

104
00:03:21,280 --> 00:03:22,879
translated through four or five

105
00:03:22,879 --> 00:03:24,480
different people before it actually gets

106
00:03:24,480 --> 00:03:25,680
to them

107
00:03:25,680 --> 00:03:27,760
and so you have instances where people

108
00:03:27,760 --> 00:03:29,360
are living off of kind of tribal

109
00:03:29,360 --> 00:03:30,879
knowledge

110
00:03:30,879 --> 00:03:33,040
if they don't know how to handle a

111
00:03:33,040 --> 00:03:33,920
certain piece

112
00:03:33,920 --> 00:03:36,080
almost certainly one of the first stops

113
00:03:36,080 --> 00:03:37,760
is to go and copy and paste something

114
00:03:37,760 --> 00:03:39,519
from stack overflow

115
00:03:39,519 --> 00:03:41,599
stack overflow as it turns out is pretty

116
00:03:41,599 --> 00:03:43,280
bad at giving security advice

117
00:03:43,280 --> 00:03:46,640
especially around cryptography um

118
00:03:46,640 --> 00:03:48,560
but even if they do manage to find that

119
00:03:48,560 --> 00:03:50,239
right place say they don't end up on

120
00:03:50,239 --> 00:03:51,760
stack overflow they end up on

121
00:03:51,760 --> 00:03:54,959
crypto.stack exchange

122
00:03:54,959 --> 00:03:57,200
the internet is filled with information

123
00:03:57,200 --> 00:03:58,319
that can quickly

124
00:03:58,319 --> 00:04:00,959
devolve into really complicated math and

125
00:04:00,959 --> 00:04:02,720
very complicated subjects

126
00:04:02,720 --> 00:04:05,599
that are not directly applicable and

127
00:04:05,599 --> 00:04:07,599
frankly may just be overwhelming to

128
00:04:07,599 --> 00:04:08,799
people that they're trying to get

129
00:04:08,799 --> 00:04:11,200
information across to

130
00:04:11,200 --> 00:04:13,200
add to this development teams have it

131
00:04:13,200 --> 00:04:16,238
rough any developers are not classically

132
00:04:16,238 --> 00:04:17,918
trained in computers what i mean by that

133
00:04:17,918 --> 00:04:19,440
is these are people who went

134
00:04:19,440 --> 00:04:22,079
and if they had any uh post-secondary

135
00:04:22,079 --> 00:04:23,919
education they're studying

136
00:04:23,919 --> 00:04:27,199
you know english or teaching or

137
00:04:27,199 --> 00:04:29,680
nursing or some of these and they end up

138
00:04:29,680 --> 00:04:30,880
in the

139
00:04:30,880 --> 00:04:32,560
software development field through boot

140
00:04:32,560 --> 00:04:34,320
camps and things like that

141
00:04:34,320 --> 00:04:37,919
um management kind of expects developers

142
00:04:37,919 --> 00:04:39,520
to know all this stuff right out of the

143
00:04:39,520 --> 00:04:41,360
gate without training because

144
00:04:41,360 --> 00:04:43,600
um if we take time to go train our

145
00:04:43,600 --> 00:04:44,639
developers

146
00:04:44,639 --> 00:04:46,720
then there's features that aren't

147
00:04:46,720 --> 00:04:48,880
getting shipped

148
00:04:48,880 --> 00:04:51,280
ultimately in some of the worst cases we

149
00:04:51,280 --> 00:04:53,440
have groups that are constant questions

150
00:04:53,440 --> 00:04:55,440
constantly questioned about every step

151
00:04:55,440 --> 00:04:57,280
that they make this seems to happen a

152
00:04:57,280 --> 00:04:58,320
lot more in

153
00:04:58,320 --> 00:04:59,919
organizations where there isn't a

154
00:04:59,919 --> 00:05:01,360
technical mind

155
00:05:01,360 --> 00:05:03,680
at the heart of the development process

156
00:05:03,680 --> 00:05:04,400
kind of the

157
00:05:04,400 --> 00:05:06,000
the project manager doesn't have a

158
00:05:06,000 --> 00:05:07,600
technical background

159
00:05:07,600 --> 00:05:09,919
and what ends up happening is you end up

160
00:05:09,919 --> 00:05:11,440
forcing people into this

161
00:05:11,440 --> 00:05:13,520
uh mentality where they if they have to

162
00:05:13,520 --> 00:05:16,080
justify everything all the time

163
00:05:16,080 --> 00:05:17,840
um that doesn't leave any room for

164
00:05:17,840 --> 00:05:19,680
saying you know what i don't know that

165
00:05:19,680 --> 00:05:21,199
and so it leads to this mentality of

166
00:05:21,199 --> 00:05:24,080
being confidently incorrect

167
00:05:24,080 --> 00:05:25,840
and the second part of this is is

168
00:05:25,840 --> 00:05:27,759
because we don't all kind of come from

169
00:05:27,759 --> 00:05:29,440
the same background because we don't all

170
00:05:29,440 --> 00:05:30,160
come

171
00:05:30,160 --> 00:05:32,560
from the same training space the

172
00:05:32,560 --> 00:05:34,320
language that we speak isn't a common

173
00:05:34,320 --> 00:05:35,199
language

174
00:05:35,199 --> 00:05:36,479
and that's kind of one of the themes

175
00:05:36,479 --> 00:05:38,479
that comes through this talk is the fact

176
00:05:38,479 --> 00:05:39,039
that

177
00:05:39,039 --> 00:05:40,880
in a lot of these cases as we're going

178
00:05:40,880 --> 00:05:42,800
through and talking about it

179
00:05:42,800 --> 00:05:44,320
the language that we use isn't

180
00:05:44,320 --> 00:05:46,320
necessarily the same one

181
00:05:46,320 --> 00:05:47,919
that's used by the development teams

182
00:05:47,919 --> 00:05:51,440
that's used by the people in security

183
00:05:51,440 --> 00:05:54,560
okay so what is cryptography let's start

184
00:05:54,560 --> 00:05:56,160
from the very basics

185
00:05:56,160 --> 00:05:59,520
uh and my the best definition that i

186
00:05:59,520 --> 00:06:00,000
like is

187
00:06:00,000 --> 00:06:01,680
the art of using mathematics to keep

188
00:06:01,680 --> 00:06:03,199
secrets secret

189
00:06:03,199 --> 00:06:05,440
um and really that that kind of plays at

190
00:06:05,440 --> 00:06:07,039
the space we are without going too

191
00:06:07,039 --> 00:06:09,199
deeply into it right

192
00:06:09,199 --> 00:06:10,720
but every once while you get a

193
00:06:10,720 --> 00:06:12,800
development team that says we're fine

194
00:06:12,800 --> 00:06:16,080
our secrets are encrypted

195
00:06:16,160 --> 00:06:18,240
we have to understand the why here and

196
00:06:18,240 --> 00:06:20,000
this goes back to speaking about

197
00:06:20,000 --> 00:06:23,600
the the kind of subtext here right um

198
00:06:23,600 --> 00:06:25,440
if the group that you're talking to

199
00:06:25,440 --> 00:06:26,720
doesn't understand what

200
00:06:26,720 --> 00:06:29,120
encrypted means to them it may mean that

201
00:06:29,120 --> 00:06:31,280
it's just unreadable

202
00:06:31,280 --> 00:06:34,479
then you'd have to go into the

203
00:06:34,479 --> 00:06:36,160
deeper parts to help them understand

204
00:06:36,160 --> 00:06:38,160
that and as part of that we're going to

205
00:06:38,160 --> 00:06:39,440
understand the why behind it we're going

206
00:06:39,440 --> 00:06:41,280
to understand when we use a coding

207
00:06:41,280 --> 00:06:42,880
when we use hashing and when we use

208
00:06:42,880 --> 00:06:44,960
encryption okay

209
00:06:44,960 --> 00:06:46,560
so encoding is this space where we're

210
00:06:46,560 --> 00:06:48,160
really going through and

211
00:06:48,160 --> 00:06:50,319
talking about representing one set of

212
00:06:50,319 --> 00:06:52,639
data as another set of data

213
00:06:52,639 --> 00:06:55,280
and so you know in most cases we'll use

214
00:06:55,280 --> 00:06:56,639
things like base64

215
00:06:56,639 --> 00:06:59,120
encoding where if we pass special

216
00:06:59,120 --> 00:07:00,000
characters

217
00:07:00,000 --> 00:07:01,919
it may cause something to blow up as

218
00:07:01,919 --> 00:07:03,599
part of the process it only can handle

219
00:07:03,599 --> 00:07:04,800
certain characters

220
00:07:04,800 --> 00:07:06,319
and so because of that we have to move

221
00:07:06,319 --> 00:07:08,240
it to a format where it can be passed

222
00:07:08,240 --> 00:07:08,639
through

223
00:07:08,639 --> 00:07:12,000
safely and then d pull decoded on the

224
00:07:12,000 --> 00:07:13,520
other side right

225
00:07:13,520 --> 00:07:15,520
so that's when we use encoding the key

226
00:07:15,520 --> 00:07:16,720
piece that we want to know here is

227
00:07:16,720 --> 00:07:18,400
there's no secret here

228
00:07:18,400 --> 00:07:20,160
we're just transferring data from one

229
00:07:20,160 --> 00:07:22,319
type to another

230
00:07:22,319 --> 00:07:25,680
okay hashing functions now hashing

231
00:07:25,680 --> 00:07:27,520
functions are really interesting space

232
00:07:27,520 --> 00:07:29,039
whenever we talk about

233
00:07:29,039 --> 00:07:32,080
cryptography the key here is that we're

234
00:07:32,080 --> 00:07:34,160
taking an arbitrary amount of data and

235
00:07:34,160 --> 00:07:36,240
we're producing a fixed amount of data

236
00:07:36,240 --> 00:07:38,639
based off of that and ideally it should

237
00:07:38,639 --> 00:07:40,479
be done in such a way that we ensure

238
00:07:40,479 --> 00:07:41,759
that there's always a

239
00:07:41,759 --> 00:07:43,520
consistent value that comes out the

240
00:07:43,520 --> 00:07:45,039
other side

241
00:07:45,039 --> 00:07:48,240
and that we can't determine what uh

242
00:07:48,240 --> 00:07:50,000
what data started with the process in

243
00:07:50,000 --> 00:07:51,440
order for us to go back to that

244
00:07:51,440 --> 00:07:53,360
so if we take a look at the hashing

245
00:07:53,360 --> 00:07:55,120
examples here we've got the lorem ipsum

246
00:07:55,120 --> 00:07:56,160
text

247
00:07:56,160 --> 00:07:58,479
and whenever we run that through we get

248
00:07:58,479 --> 00:08:00,080
a hash down here and we can see that

249
00:08:00,080 --> 00:08:01,360
down here at the bottom of the first

250
00:08:01,360 --> 00:08:03,280
column we've got a set value

251
00:08:03,280 --> 00:08:05,520
now if we were to just slightly tweak

252
00:08:05,520 --> 00:08:07,120
that and change that

253
00:08:07,120 --> 00:08:10,319
uppercase l to a lowercase l we get a

254
00:08:10,319 --> 00:08:12,240
completely different hash that comes out

255
00:08:12,240 --> 00:08:14,560
the other side of that hashing function

256
00:08:14,560 --> 00:08:16,639
and that's one of the real values that

257
00:08:16,639 --> 00:08:17,840
we have in this

258
00:08:17,840 --> 00:08:20,479
is that it quickly lets us tell if we

259
00:08:20,479 --> 00:08:20,960
have

260
00:08:20,960 --> 00:08:23,039
information that's the same on one side

261
00:08:23,039 --> 00:08:24,800
as it is on the other ensuring that we

262
00:08:24,800 --> 00:08:27,919
have that integrity across our data

263
00:08:27,919 --> 00:08:29,759
but there's an additional piece to this

264
00:08:29,759 --> 00:08:32,080
whenever we talk about hashes if we just

265
00:08:32,080 --> 00:08:33,760
have the hash

266
00:08:33,760 --> 00:08:35,599
generally speaking we don't know what

267
00:08:35,599 --> 00:08:37,440
created that hash there's no way for us

268
00:08:37,440 --> 00:08:39,200
to reverse it and so because of that we

269
00:08:39,200 --> 00:08:42,000
refer to this as a one-way function

270
00:08:42,000 --> 00:08:44,480
we can only get data out of it one way

271
00:08:44,480 --> 00:08:45,760
now if we don't take

272
00:08:45,760 --> 00:08:47,920
proper precautions you may be able to go

273
00:08:47,920 --> 00:08:48,800
and take that hash

274
00:08:48,800 --> 00:08:50,560
copy it over to google and figure out

275
00:08:50,560 --> 00:08:53,359
what produced it

276
00:08:53,519 --> 00:08:55,519
but encryption is a different beast

277
00:08:55,519 --> 00:08:57,360
altogether and that's really the piece

278
00:08:57,360 --> 00:08:59,600
that we want to talk about this

279
00:08:59,600 --> 00:09:02,800
encryption fundamentally is taking some

280
00:09:02,800 --> 00:09:03,680
form of

281
00:09:03,680 --> 00:09:06,880
clear text running it through a function

282
00:09:06,880 --> 00:09:08,000
with a key that

283
00:09:08,000 --> 00:09:11,200
is held secret from the process and out

284
00:09:11,200 --> 00:09:13,920
what is produced on the other side is

285
00:09:13,920 --> 00:09:14,800
encrypted

286
00:09:14,800 --> 00:09:17,279
in is you know changed in such a way

287
00:09:17,279 --> 00:09:19,200
that it can't be read

288
00:09:19,200 --> 00:09:20,640
so there's no way for us to get that

289
00:09:20,640 --> 00:09:22,160
information back and it's beyond the

290
00:09:22,160 --> 00:09:23,120
encoding

291
00:09:23,120 --> 00:09:24,959
because if you don't have that key if

292
00:09:24,959 --> 00:09:27,519
you don't have that fried chicken resa

293
00:09:27,519 --> 00:09:29,040
um you're never going to get that

294
00:09:29,040 --> 00:09:30,640
message back it's always going to be

295
00:09:30,640 --> 00:09:31,360
junk

296
00:09:31,360 --> 00:09:35,680
okay so password storage

297
00:09:35,680 --> 00:09:37,600
you know is one of those topics that we

298
00:09:37,600 --> 00:09:39,519
have to to talk about this

299
00:09:39,519 --> 00:09:41,680
because it's the first real place that

300
00:09:41,680 --> 00:09:43,360
most people encounter

301
00:09:43,360 --> 00:09:46,000
encryption and encryption as part of the

302
00:09:46,000 --> 00:09:47,120
process

303
00:09:47,120 --> 00:09:50,480
um and i love this question so whenever

304
00:09:50,480 --> 00:09:52,000
i tell a group that you know we go

305
00:09:52,000 --> 00:09:53,680
through this process and they say okay

306
00:09:53,680 --> 00:09:55,040
how are we supposed to encrypt our

307
00:09:55,040 --> 00:09:56,160
passwords

308
00:09:56,160 --> 00:09:58,720
well the answer is you don't uh we use

309
00:09:58,720 --> 00:10:00,160
key derivation functions

310
00:10:00,160 --> 00:10:03,440
this isn't fully cryptography but it's

311
00:10:03,440 --> 00:10:04,000
one of those

312
00:10:04,000 --> 00:10:05,920
pieces that if we don't talk about it up

313
00:10:05,920 --> 00:10:08,079
front you can easily lose

314
00:10:08,079 --> 00:10:10,720
everything uh before we actually get

315
00:10:10,720 --> 00:10:13,040
into worrying about cryptography

316
00:10:13,040 --> 00:10:16,079
yeah the goal of this is to

317
00:10:16,079 --> 00:10:19,440
slow down or stop the leak of passwords

318
00:10:19,440 --> 00:10:20,959
in the event of an incident

319
00:10:20,959 --> 00:10:22,160
so if somebody gets our password

320
00:10:22,160 --> 00:10:24,320
database we want to make sure that it

321
00:10:24,320 --> 00:10:26,480
takes them the maximum amount of time to

322
00:10:26,480 --> 00:10:27,200
try and guess

323
00:10:27,200 --> 00:10:29,120
all those passwords so they can come

324
00:10:29,120 --> 00:10:30,399
back and use them

325
00:10:30,399 --> 00:10:32,800
in other places maybe people's banks or

326
00:10:32,800 --> 00:10:34,560
various pieces like that

327
00:10:34,560 --> 00:10:37,360
so to do this we use safe key derivation

328
00:10:37,360 --> 00:10:38,800
functions

329
00:10:38,800 --> 00:10:41,040
um for these pieces you'll notice that i

330
00:10:41,040 --> 00:10:42,560
have some benchmarks to get

331
00:10:42,560 --> 00:10:44,079
kind of give you an idea of what it

332
00:10:44,079 --> 00:10:46,560
looks like as we're going through and

333
00:10:46,560 --> 00:10:49,600
generating the initial hashes uh so that

334
00:10:49,600 --> 00:10:50,880
you understand the values

335
00:10:50,880 --> 00:10:52,800
this isn't done on some like super

336
00:10:52,800 --> 00:10:54,800
powerful machine this is done on a mid

337
00:10:54,800 --> 00:10:55,680
core

338
00:10:55,680 --> 00:10:59,839
consumer grade i7 with a nvidia geforce

339
00:10:59,839 --> 00:11:00,560
uh

340
00:11:00,560 --> 00:11:03,360
1060 nothing big here nothing surprising

341
00:11:03,360 --> 00:11:04,880
maybe a little bit extra ram

342
00:11:04,880 --> 00:11:06,800
okay so the first one we're going to

343
00:11:06,800 --> 00:11:08,560
talk about is the password-based key

344
00:11:08,560 --> 00:11:10,240
derivation function too

345
00:11:10,240 --> 00:11:12,720
and really what this thing does is it we

346
00:11:12,720 --> 00:11:13,279
take

347
00:11:13,279 --> 00:11:16,079
a password and some salt and we give it

348
00:11:16,079 --> 00:11:16,399
a

349
00:11:16,399 --> 00:11:18,640
complexity number and this complexity

350
00:11:18,640 --> 00:11:20,800
number allows us to go up and down

351
00:11:20,800 --> 00:11:24,000
and kind of view uh how

352
00:11:24,000 --> 00:11:26,160
many iterations that we want this to go

353
00:11:26,160 --> 00:11:29,200
through to help secure that process

354
00:11:29,200 --> 00:11:30,800
because the goal is if we're only doing

355
00:11:30,800 --> 00:11:32,800
this and we know the right password for

356
00:11:32,800 --> 00:11:34,240
testing

357
00:11:34,240 --> 00:11:36,240
this process should go really quickly

358
00:11:36,240 --> 00:11:37,519
but for each

359
00:11:37,519 --> 00:11:40,240
guess that an attacker has to make it's

360
00:11:40,240 --> 00:11:42,160
going to slow their process down

361
00:11:42,160 --> 00:11:44,000
and so that's really the goal of these

362
00:11:44,000 --> 00:11:46,480
functions um and so for this one we've

363
00:11:46,480 --> 00:11:48,240
got password-based key derivation

364
00:11:48,240 --> 00:11:49,920
function it's definitely starting to

365
00:11:49,920 --> 00:11:51,200
show its age

366
00:11:51,200 --> 00:11:54,480
um but it still can still be very very

367
00:11:54,480 --> 00:11:56,320
uh well set and secured assuming that

368
00:11:56,320 --> 00:11:56,800
you know

369
00:11:56,800 --> 00:11:59,519
use enough iterations as we go across

370
00:11:59,519 --> 00:12:01,600
this we can see even on kind of this

371
00:12:01,600 --> 00:12:02,880
mid-range

372
00:12:02,880 --> 00:12:05,839
uh machine we're still talking you know

373
00:12:05,839 --> 00:12:07,600
milliseconds

374
00:12:07,600 --> 00:12:09,680
of performance to produce these hashes

375
00:12:09,680 --> 00:12:10,880
and check them

376
00:12:10,880 --> 00:12:13,120
yeah so the next one we'll take a look

377
00:12:13,120 --> 00:12:15,519
is bcrypt and bcrypt is really based off

378
00:12:15,519 --> 00:12:17,680
of blowfish uh blowfish is an encryption

379
00:12:17,680 --> 00:12:18,160
we'll

380
00:12:18,160 --> 00:12:20,079
talk about whenever we get into the uh

381
00:12:20,079 --> 00:12:22,160
symmetra key section of this

382
00:12:22,160 --> 00:12:24,639
um but really this has a very similar

383
00:12:24,639 --> 00:12:26,399
process to what we saw with

384
00:12:26,399 --> 00:12:28,160
password-based key derivation function

385
00:12:28,160 --> 00:12:30,240
two um in the fact that it

386
00:12:30,240 --> 00:12:33,360
takes salt a password and we get to

387
00:12:33,360 --> 00:12:34,720
supply the cost

388
00:12:34,720 --> 00:12:37,120
and the cost in this case is measured as

389
00:12:37,120 --> 00:12:39,040
an exponent of two to the

390
00:12:39,040 --> 00:12:42,079
x where x is the cost um generally

391
00:12:42,079 --> 00:12:42,800
speaking

392
00:12:42,800 --> 00:12:47,279
12 is about uh 4096 iterations

393
00:12:47,279 --> 00:12:49,440
um that's kind of the good space we want

394
00:12:49,440 --> 00:12:50,800
to go we if we go

395
00:12:50,800 --> 00:12:53,279
under too for many iterations it'll

396
00:12:53,279 --> 00:12:55,120
start to explode and gets really

397
00:12:55,120 --> 00:12:58,560
kind of um easy to break

398
00:12:58,560 --> 00:13:00,240
so the next one we're going to talk

399
00:13:00,240 --> 00:13:01,600
about is s-crypt

400
00:13:01,600 --> 00:13:03,839
s-crypt is a password derivation

401
00:13:03,839 --> 00:13:06,560
function based on cpu and memory load

402
00:13:06,560 --> 00:13:08,480
and where we see the real transition

403
00:13:08,480 --> 00:13:09,680
here is instead of

404
00:13:09,680 --> 00:13:11,680
kind of forcing a processor to do it

405
00:13:11,680 --> 00:13:12,959
over and over again

406
00:13:12,959 --> 00:13:14,880
we're now scaling out to the resources

407
00:13:14,880 --> 00:13:17,120
of the device that will be calculating

408
00:13:17,120 --> 00:13:19,680
this hash and locking it into that place

409
00:13:19,680 --> 00:13:20,399
um so

410
00:13:20,399 --> 00:13:21,920
you know if this is done on a server

411
00:13:21,920 --> 00:13:23,600
with several thousand cores and lots and

412
00:13:23,600 --> 00:13:24,720
lots of memory

413
00:13:24,720 --> 00:13:27,200
um that's not as much of a problem as if

414
00:13:27,200 --> 00:13:28,639
it's somebody trying to crack these

415
00:13:28,639 --> 00:13:32,000
passwords on a graphics card for example

416
00:13:32,000 --> 00:13:34,399
where the cost of graphics ram is

417
00:13:34,399 --> 00:13:35,920
significantly higher

418
00:13:35,920 --> 00:13:37,920
um and so we have this key derivation

419
00:13:37,920 --> 00:13:39,040
function we pass it

420
00:13:39,040 --> 00:13:42,160
salt and our password uh generally

421
00:13:42,160 --> 00:13:43,920
speaking the block size is always going

422
00:13:43,920 --> 00:13:44,399
to be

423
00:13:44,399 --> 00:13:46,880
fairly standard so generally speaking we

424
00:13:46,880 --> 00:13:47,519
use uh

425
00:13:47,519 --> 00:13:50,079
eight here to produce a decent sized

426
00:13:50,079 --> 00:13:50,720
block

427
00:13:50,720 --> 00:13:52,800
uh the parallelization factor is usually

428
00:13:52,800 --> 00:13:54,240
set up in such a way that it's

429
00:13:54,240 --> 00:13:55,920
the number of cores that you want to

430
00:13:55,920 --> 00:13:58,079
dedicate towards

431
00:13:58,079 --> 00:14:01,519
actually doing the hashing times two

432
00:14:01,519 --> 00:14:03,600
the output key length is another one of

433
00:14:03,600 --> 00:14:05,120
those control pieces that we can put

434
00:14:05,120 --> 00:14:06,800
into place here but we again have this

435
00:14:06,800 --> 00:14:07,600
parameter for

436
00:14:07,600 --> 00:14:10,079
cost and this is going to allow us to

437
00:14:10,079 --> 00:14:12,320
section off a certain portion of ram

438
00:14:12,320 --> 00:14:14,000
now the interesting thing about s crypt

439
00:14:14,000 --> 00:14:16,079
if you look at this the actual

440
00:14:16,079 --> 00:14:18,160
processing time associated with

441
00:14:18,160 --> 00:14:20,639
generating script is very low

442
00:14:20,639 --> 00:14:22,480
okay we have some outliers in here but

443
00:14:22,480 --> 00:14:24,160
for the most part it's it's a very low

444
00:14:24,160 --> 00:14:25,279
process

445
00:14:25,279 --> 00:14:28,720
um so much so because

446
00:14:28,720 --> 00:14:30,800
of the fact that we're locking this to

447
00:14:30,800 --> 00:14:32,639
resources it doesn't have to do

448
00:14:32,639 --> 00:14:33,920
something over and over again

449
00:14:33,920 --> 00:14:35,519
it has the ability to rely on the

450
00:14:35,519 --> 00:14:37,519
resources to keep it safe

451
00:14:37,519 --> 00:14:40,639
but we now move into kind of the the

452
00:14:40,639 --> 00:14:44,079
top level of this and really argon 2 id

453
00:14:44,079 --> 00:14:45,920
if you're designing a new system this is

454
00:14:45,920 --> 00:14:48,079
the direction you should be going in

455
00:14:48,079 --> 00:14:50,399
um it locks the key derivation process

456
00:14:50,399 --> 00:14:52,240
to memory execution time

457
00:14:52,240 --> 00:14:55,360
and parallelization okay so we specify

458
00:14:55,360 --> 00:14:56,880
all of those pieces in there we've got

459
00:14:56,880 --> 00:14:58,399
our parallelism number threads

460
00:14:58,399 --> 00:15:01,519
uh hashing cpus times two

461
00:15:01,519 --> 00:15:03,199
our tag length which is what we want to

462
00:15:03,199 --> 00:15:04,880
come out the memory cost that's

463
00:15:04,880 --> 00:15:06,160
associated with it

464
00:15:06,160 --> 00:15:08,079
the number of iterations and this can

465
00:15:08,079 --> 00:15:09,760
have a significant

466
00:15:09,760 --> 00:15:12,240
impact on the amount of time that it

467
00:15:12,240 --> 00:15:14,800
takes them to calculate as we'll see now

468
00:15:14,800 --> 00:15:16,320
to take a look at these from a breaking

469
00:15:16,320 --> 00:15:18,480
standpoint remember the key is to

470
00:15:18,480 --> 00:15:20,160
you know slow down the process of trying

471
00:15:20,160 --> 00:15:22,160
to break these passwords as quick

472
00:15:22,160 --> 00:15:25,440
as much as possible so if we run sha-1

473
00:15:25,440 --> 00:15:26,880
with salt which is what we saw in our

474
00:15:26,880 --> 00:15:28,399
developers example

475
00:15:28,399 --> 00:15:31,759
we're pulling out 3 800

476
00:15:31,759 --> 00:15:34,880
milli mega hashes per second and that is

477
00:15:34,880 --> 00:15:36,639
a mind-boggling just

478
00:15:36,639 --> 00:15:38,720
pass you can very quickly iterate

479
00:15:38,720 --> 00:15:40,320
through an entire word list

480
00:15:40,320 --> 00:15:43,680
to find collisions in there very quickly

481
00:15:43,680 --> 00:15:45,440
even if we were to just upgrade that

482
00:15:45,440 --> 00:15:48,320
from sha-1 to shot 256

483
00:15:48,320 --> 00:15:50,079
not what i would recommend at all but

484
00:15:50,079 --> 00:15:51,360
it's one of the first things that

485
00:15:51,360 --> 00:15:52,720
developers especially

486
00:15:52,720 --> 00:15:54,079
ones that don't realize what we're

487
00:15:54,079 --> 00:15:55,440
talking about we'll pick out of that

488
00:15:55,440 --> 00:15:57,680
sample

489
00:15:57,680 --> 00:16:00,720
you still reduce it down by a third or

490
00:16:00,720 --> 00:16:02,240
down to a third

491
00:16:02,240 --> 00:16:04,399
now if we move this over to something

492
00:16:04,399 --> 00:16:06,320
like the scheme that's used with mac os

493
00:16:06,320 --> 00:16:08,160
where it's password-based key derivation

494
00:16:08,160 --> 00:16:08,959
function

495
00:16:08,959 --> 00:16:12,000
at you know 1023 iterations

496
00:16:12,000 --> 00:16:15,759
we drop from mega hashes to kila hashes

497
00:16:15,759 --> 00:16:18,079
if we switch that over to blowfish with

498
00:16:18,079 --> 00:16:20,079
something as little as 32

499
00:16:20,079 --> 00:16:23,680
we're now in the thousands of hashes

500
00:16:23,680 --> 00:16:25,920
if we move that over to s crypt with

501
00:16:25,920 --> 00:16:27,279
some decent settings

502
00:16:27,279 --> 00:16:30,560
we get down to the hundreds of hashes

503
00:16:30,560 --> 00:16:33,440
and finally if we pull in and use argon

504
00:16:33,440 --> 00:16:34,639
to id

505
00:16:34,639 --> 00:16:36,959
currently there is no uh no code for

506
00:16:36,959 --> 00:16:37,920
actually doing

507
00:16:37,920 --> 00:16:40,160
a graphics card based acceleration of

508
00:16:40,160 --> 00:16:43,120
this and so you are cpu locked in trying

509
00:16:43,120 --> 00:16:45,680
to crack argon 2 id passwords

510
00:16:45,680 --> 00:16:47,759
and so beca password hashes and because

511
00:16:47,759 --> 00:16:48,959
of that we're down to

512
00:16:48,959 --> 00:16:52,480
on my hardware uh effectively 100 and

513
00:16:52,480 --> 00:16:55,199
maybe 20 hashes per second

514
00:16:55,199 --> 00:16:58,320
okay so now that we have a deep

515
00:16:58,320 --> 00:17:00,320
understanding of how to protect the

516
00:17:00,320 --> 00:17:02,160
first entry into our application we can

517
00:17:02,160 --> 00:17:03,519
move on so

518
00:17:03,519 --> 00:17:06,720
how do we enforce integrity um well

519
00:17:06,720 --> 00:17:08,640
you know all of our stuff already uses

520
00:17:08,640 --> 00:17:11,039
md5 that's secure right why would we

521
00:17:11,039 --> 00:17:12,880
want to change anything we've got years

522
00:17:12,880 --> 00:17:14,880
of of hashes built up

523
00:17:14,880 --> 00:17:16,480
so that we know that things are safe

524
00:17:16,480 --> 00:17:18,079
right well

525
00:17:18,079 --> 00:17:20,720
why do we do hashing the the first goal

526
00:17:20,720 --> 00:17:21,359
is to

527
00:17:21,359 --> 00:17:23,520
to make sure that something is unique to

528
00:17:23,520 --> 00:17:25,359
again go back to that example of the

529
00:17:25,359 --> 00:17:26,559
lorem ipsum

530
00:17:26,559 --> 00:17:28,079
right we're going to pull something out

531
00:17:28,079 --> 00:17:29,840
so that we make sure that the value

532
00:17:29,840 --> 00:17:31,520
is the same whenever we transfer from

533
00:17:31,520 --> 00:17:33,760
one place to another

534
00:17:33,760 --> 00:17:36,880
using that check is really to make sure

535
00:17:36,880 --> 00:17:38,720
that data was not manipulated during

536
00:17:38,720 --> 00:17:40,000
that process

537
00:17:40,000 --> 00:17:42,080
and if somebody can manipulate that data

538
00:17:42,080 --> 00:17:44,000
we've got problems

539
00:17:44,000 --> 00:17:45,440
additionally we want to ensure that it

540
00:17:45,440 --> 00:17:47,360
can only go one way we can't determine

541
00:17:47,360 --> 00:17:49,200
what the original content from the hash

542
00:17:49,200 --> 00:17:50,080
was

543
00:17:50,080 --> 00:17:52,400
and so we get into talking about these

544
00:17:52,400 --> 00:17:53,919
and i'm not going to drain this slide

545
00:17:53,919 --> 00:17:55,200
but the key one that you

546
00:17:55,200 --> 00:17:58,320
really have to call out here is md5 is

547
00:17:58,320 --> 00:18:00,080
really at this point fully broken

548
00:18:00,080 --> 00:18:02,000
there's been some uh stuff where people

549
00:18:02,000 --> 00:18:04,080
could actually manufacture collisions in

550
00:18:04,080 --> 00:18:04,880
that

551
00:18:04,880 --> 00:18:07,280
um and so that's that's genuinely a bad

552
00:18:07,280 --> 00:18:08,160
thing uh

553
00:18:08,160 --> 00:18:10,799
sha-1 has been weak for many many years

554
00:18:10,799 --> 00:18:12,559
we've seen collisions in it and so

555
00:18:12,559 --> 00:18:14,080
because of that it's good idea to

556
00:18:14,080 --> 00:18:14,880
abandon it

557
00:18:14,880 --> 00:18:16,400
but any of the other ones that are on

558
00:18:16,400 --> 00:18:18,880
this list are solid you can use them and

559
00:18:18,880 --> 00:18:20,720
they work for what they need them to

560
00:18:20,720 --> 00:18:21,919
okay

561
00:18:21,919 --> 00:18:24,559
so now that we understand how we enforce

562
00:18:24,559 --> 00:18:26,160
integrity through hashing

563
00:18:26,160 --> 00:18:28,720
let's move over to symmetric encryption

564
00:18:28,720 --> 00:18:30,960
now the interesting thing about

565
00:18:30,960 --> 00:18:33,919
about symmetric encryption is we have a

566
00:18:33,919 --> 00:18:35,840
pre-shared key

567
00:18:35,840 --> 00:18:37,919
and that is the consistent piece across

568
00:18:37,919 --> 00:18:39,679
all symmetric encryption is that there

569
00:18:39,679 --> 00:18:40,080
is a

570
00:18:40,080 --> 00:18:42,960
pre-shared key and so that goes back to

571
00:18:42,960 --> 00:18:43,520
our

572
00:18:43,520 --> 00:18:45,120
our piece where we're saying hey you

573
00:18:45,120 --> 00:18:47,280
know we have secrets right if i have

574
00:18:47,280 --> 00:18:49,360
you know i'm sharing information between

575
00:18:49,360 --> 00:18:50,400
servers

576
00:18:50,400 --> 00:18:52,000
and i have to have that password on

577
00:18:52,000 --> 00:18:54,480
every server then any of those servers

578
00:18:54,480 --> 00:18:55,360
that get

579
00:18:55,360 --> 00:18:58,080
attacked and have that key stolen are

580
00:18:58,080 --> 00:18:58,400
now

581
00:18:58,400 --> 00:19:00,320
able to leak all the other information

582
00:19:00,320 --> 00:19:02,559
on all the other servers

583
00:19:02,559 --> 00:19:05,360
this can be bad so whenever we talk

584
00:19:05,360 --> 00:19:07,039
about using symmetric encryption you

585
00:19:07,039 --> 00:19:08,559
want to make sure that you're only using

586
00:19:08,559 --> 00:19:10,480
it in a situation where you don't have

587
00:19:10,480 --> 00:19:12,000
to share that key

588
00:19:12,000 --> 00:19:14,080
okay or that you're sharing it in a way

589
00:19:14,080 --> 00:19:16,160
that we can handle responsibly

590
00:19:16,160 --> 00:19:18,480
talk about that here in a little bit the

591
00:19:18,480 --> 00:19:20,400
key to this is whenever we do that

592
00:19:20,400 --> 00:19:22,640
encryption process we have text

593
00:19:22,640 --> 00:19:25,760
key produces ciphertext decryption

594
00:19:25,760 --> 00:19:29,120
produces takes ciphertext key

595
00:19:29,120 --> 00:19:32,720
and produces the original text back

596
00:19:32,720 --> 00:19:35,280
now all of this kind of relies on the

597
00:19:35,280 --> 00:19:36,960
ability to use something known as an

598
00:19:36,960 --> 00:19:38,640
initialization vector

599
00:19:38,640 --> 00:19:41,360
and we use an initialization vector to

600
00:19:41,360 --> 00:19:41,760
i'm

601
00:19:41,760 --> 00:19:44,080
sure that any time that we push data

602
00:19:44,080 --> 00:19:45,760
through the encryption

603
00:19:45,760 --> 00:19:47,840
we always get out data that looks

604
00:19:47,840 --> 00:19:49,280
slightly different

605
00:19:49,280 --> 00:19:51,280
because for example if we were to go

606
00:19:51,280 --> 00:19:53,039
through the process and encrypt the same

607
00:19:53,039 --> 00:19:55,200
information over and over again

608
00:19:55,200 --> 00:19:58,559
and say you know okay okay okay

609
00:19:58,559 --> 00:20:00,480
and somebody were to come and see all of

610
00:20:00,480 --> 00:20:02,080
those messages they would be able to at

611
00:20:02,080 --> 00:20:03,120
least determine

612
00:20:03,120 --> 00:20:05,760
that those are all the same and so we're

613
00:20:05,760 --> 00:20:07,360
giving away some piece of knowledge as

614
00:20:07,360 --> 00:20:08,400
part of that

615
00:20:08,400 --> 00:20:10,720
um and the goal of encryption is to not

616
00:20:10,720 --> 00:20:12,559
give away any knowledge it's to keep

617
00:20:12,559 --> 00:20:13,600
secrets

618
00:20:13,600 --> 00:20:16,080
so to do this we have pieces that are

619
00:20:16,080 --> 00:20:17,520
built in so that it gives us some

620
00:20:17,520 --> 00:20:18,400
variation

621
00:20:18,400 --> 00:20:20,720
in how the information is generated from

622
00:20:20,720 --> 00:20:21,600
the beginning

623
00:20:21,600 --> 00:20:23,440
to generate that random information we

624
00:20:23,440 --> 00:20:25,520
use an initialization vector

625
00:20:25,520 --> 00:20:28,000
now for debugging purposes most of the

626
00:20:28,000 --> 00:20:29,039
application

627
00:20:29,039 --> 00:20:31,760
frameworks have an initialization vector

628
00:20:31,760 --> 00:20:34,080
that includes initialization none which

629
00:20:34,080 --> 00:20:35,919
means that initialization vector

630
00:20:35,919 --> 00:20:36,400
includes

631
00:20:36,400 --> 00:20:39,440
all zeros under no circumstances should

632
00:20:39,440 --> 00:20:41,679
you ever use that in a production

633
00:20:41,679 --> 00:20:43,760
instance in fact i would suggest that

634
00:20:43,760 --> 00:20:45,760
you don't even use it in a development

635
00:20:45,760 --> 00:20:46,840
instance

636
00:20:46,840 --> 00:20:49,760
um the goal here is to really make sure

637
00:20:49,760 --> 00:20:51,280
that we go through this process

638
00:20:51,280 --> 00:20:52,880
and make sure that we get out random

639
00:20:52,880 --> 00:20:55,120
data every single time

640
00:20:55,120 --> 00:20:58,000
okay so that brings us to the next piece

641
00:20:58,000 --> 00:20:59,600
which is our symmetric modes

642
00:20:59,600 --> 00:21:01,440
and effectively whenever we talk about

643
00:21:01,440 --> 00:21:02,799
symmetric encryption

644
00:21:02,799 --> 00:21:04,559
most of the cases that we're talking

645
00:21:04,559 --> 00:21:06,320
about are

646
00:21:06,320 --> 00:21:08,799
block ciphers at least most of the

647
00:21:08,799 --> 00:21:10,640
modern ones are

648
00:21:10,640 --> 00:21:12,559
and this means that it takes a certain

649
00:21:12,559 --> 00:21:14,559
amount of data it encrypts it and then

650
00:21:14,559 --> 00:21:15,280
moves on to

651
00:21:15,280 --> 00:21:17,039
another block of that certain amount of

652
00:21:17,039 --> 00:21:19,440
data so it could be 8

653
00:21:19,440 --> 00:21:22,000
bytes might be 16 bytes whatever it is

654
00:21:22,000 --> 00:21:23,600
we have to take that data we encrypt it

655
00:21:23,600 --> 00:21:25,280
and then we move on

656
00:21:25,280 --> 00:21:27,039
but it's this kind of iterative process

657
00:21:27,039 --> 00:21:29,280
as we go through it so the question is

658
00:21:29,280 --> 00:21:31,120
is how do we move from one block to the

659
00:21:31,120 --> 00:21:33,520
next and make sure that we're keeping

660
00:21:33,520 --> 00:21:34,720
things secure

661
00:21:34,720 --> 00:21:36,080
and there are a couple of different ways

662
00:21:36,080 --> 00:21:38,000
that we can do this depending on

663
00:21:38,000 --> 00:21:41,039
the goal that you're trying to achieve

664
00:21:41,039 --> 00:21:42,640
so the first way that we do is we just

665
00:21:42,640 --> 00:21:44,720
do the same block over and over again

666
00:21:44,720 --> 00:21:47,120
okay we don't really have any variations

667
00:21:47,120 --> 00:21:47,919
this is called

668
00:21:47,919 --> 00:21:51,600
electro electronic code book mode or ecb

669
00:21:51,600 --> 00:21:53,520
the takeaway from this is that each

670
00:21:53,520 --> 00:21:54,799
block is the exact

671
00:21:54,799 --> 00:21:58,159
same it's encrypted the exact same way

672
00:21:58,159 --> 00:22:01,039
okay and we should avoid this at all

673
00:22:01,039 --> 00:22:04,240
costs for all but the extremely small

674
00:22:04,240 --> 00:22:04,880
messages

675
00:22:04,880 --> 00:22:07,600
and here's why whenever you use

676
00:22:07,600 --> 00:22:09,280
electronic code book mode it's doing

677
00:22:09,280 --> 00:22:10,080
those blocks and

678
00:22:10,080 --> 00:22:11,679
you can actually see in the section that

679
00:22:11,679 --> 00:22:13,760
we have here that it's going through

680
00:22:13,760 --> 00:22:16,480
and it's talking about we have three

681
00:22:16,480 --> 00:22:17,120
blocks

682
00:22:17,120 --> 00:22:18,799
set off with two passwords using the

683
00:22:18,799 --> 00:22:20,159
same key

684
00:22:20,159 --> 00:22:22,720
we have one small change of an s towards

685
00:22:22,720 --> 00:22:24,559
the middle of the password we can see

686
00:22:24,559 --> 00:22:27,919
that only the center section changes

687
00:22:27,919 --> 00:22:30,960
now if you know this the attacker could

688
00:22:30,960 --> 00:22:33,280
use this to change out certain portions

689
00:22:33,280 --> 00:22:34,559
of it if they knew that a certain

690
00:22:34,559 --> 00:22:36,320
portion of the message was valid or

691
00:22:36,320 --> 00:22:38,559
invalid and they could use this for an

692
00:22:38,559 --> 00:22:39,440
attack

693
00:22:39,440 --> 00:22:41,679
so generally speaking we should never

694
00:22:41,679 --> 00:22:44,640
use electronic code book mode

695
00:22:44,640 --> 00:22:46,480
so the next one that comes up is cipher

696
00:22:46,480 --> 00:22:48,240
block chaining or cbc and what we're

697
00:22:48,240 --> 00:22:50,400
doing is we're taking the output of one

698
00:22:50,400 --> 00:22:53,120
process and using that as the input for

699
00:22:53,120 --> 00:22:54,960
the plain text on the other side on the

700
00:22:54,960 --> 00:22:56,240
next process

701
00:22:56,240 --> 00:22:57,840
now what this means is that whenever we

702
00:22:57,840 --> 00:22:59,679
go through we can encrypt

703
00:22:59,679 --> 00:23:02,480
using a single thread but whenever we go

704
00:23:02,480 --> 00:23:04,960
to decrypt we can do it in parallel

705
00:23:04,960 --> 00:23:06,640
so it allows us to go through and find

706
00:23:06,640 --> 00:23:08,000
those pieces and carry them

707
00:23:08,000 --> 00:23:10,240
over as part of the next process it

708
00:23:10,240 --> 00:23:12,400
allows us for

709
00:23:12,400 --> 00:23:14,240
for us whenever we have a full series of

710
00:23:14,240 --> 00:23:15,760
blocks encrypted

711
00:23:15,760 --> 00:23:18,960
to do random seeking in that space

712
00:23:18,960 --> 00:23:21,919
so the next one is cipher feedback and

713
00:23:21,919 --> 00:23:23,120
cipher feedback

714
00:23:23,120 --> 00:23:25,120
is another one that goes through and it

715
00:23:25,120 --> 00:23:26,640
takes the information out

716
00:23:26,640 --> 00:23:29,600
and it supplies it going into the blocks

717
00:23:29,600 --> 00:23:29,919
now

718
00:23:29,919 --> 00:23:32,080
encryption can't be paralyzed in this

719
00:23:32,080 --> 00:23:33,760
case but decryption

720
00:23:33,760 --> 00:23:36,880
can be um and this again allows for

721
00:23:36,880 --> 00:23:38,640
random seeking through the data that's

722
00:23:38,640 --> 00:23:40,400
been encrypted

723
00:23:40,400 --> 00:23:43,039
the next one is output feedback mode and

724
00:23:43,039 --> 00:23:44,720
effectively this sets it up in such a

725
00:23:44,720 --> 00:23:46,880
way that the output from one is included

726
00:23:46,880 --> 00:23:47,840
as part of the

727
00:23:47,840 --> 00:23:50,080
entry point for the next one now what

728
00:23:50,080 --> 00:23:50,880
this means

729
00:23:50,880 --> 00:23:53,360
is that we have a stream that goes

730
00:23:53,360 --> 00:23:55,360
across and this effectively creates that

731
00:23:55,360 --> 00:23:56,720
streaming process

732
00:23:56,720 --> 00:23:58,559
data has to come in one side go out the

733
00:23:58,559 --> 00:24:00,159
other side we can't paralyze the

734
00:24:00,159 --> 00:24:02,159
encryption or decryption

735
00:24:02,159 --> 00:24:04,240
um and it doesn't allow for random

736
00:24:04,240 --> 00:24:06,159
reading but the key feature of this is

737
00:24:06,159 --> 00:24:06,720
that

738
00:24:06,720 --> 00:24:08,240
if somebody starts listening in the

739
00:24:08,240 --> 00:24:10,080
middle of the conversation

740
00:24:10,080 --> 00:24:12,480
even if they have the initial key they

741
00:24:12,480 --> 00:24:14,159
probably aren't going to be able to

742
00:24:14,159 --> 00:24:15,679
start listening back in on that

743
00:24:15,679 --> 00:24:18,720
conversation okay the last one is

744
00:24:18,720 --> 00:24:22,000
counter mode encounter mode uses a nonce

745
00:24:22,000 --> 00:24:23,520
as a counter to increment the

746
00:24:23,520 --> 00:24:25,039
initialization vector

747
00:24:25,039 --> 00:24:27,279
now the value to this of course is that

748
00:24:27,279 --> 00:24:28,640
the encryption can be

749
00:24:28,640 --> 00:24:30,640
done in parallel the decryption can be

750
00:24:30,640 --> 00:24:32,720
done in parallel and it allows for

751
00:24:32,720 --> 00:24:37,840
random reading as part of the process um

752
00:24:37,840 --> 00:24:39,440
you know as we talk about legacy

753
00:24:39,440 --> 00:24:41,120
products and the the kind of pieces that

754
00:24:41,120 --> 00:24:42,000
are in there

755
00:24:42,000 --> 00:24:44,960
there's some very dangerous pieces of

756
00:24:44,960 --> 00:24:46,559
our algorithms that are out there that

757
00:24:46,559 --> 00:24:47,919
have been around for years and are used

758
00:24:47,919 --> 00:24:48,799
in products

759
00:24:48,799 --> 00:24:51,200
um that we need to pull out and so i'm

760
00:24:51,200 --> 00:24:52,640
again i'm not going to drain this slide

761
00:24:52,640 --> 00:24:53,440
for you but

762
00:24:53,440 --> 00:24:55,919
here's kind of an idea of what we're

763
00:24:55,919 --> 00:24:57,520
looking at and when it should have been

764
00:24:57,520 --> 00:24:58,960
removed from your product

765
00:24:58,960 --> 00:25:00,720
if you see any of these in your product

766
00:25:00,720 --> 00:25:02,960
just go through and replace them with

767
00:25:02,960 --> 00:25:06,320
some of these okay and there's some good

768
00:25:06,320 --> 00:25:08,159
advice out there for which are the

769
00:25:08,159 --> 00:25:10,400
algorithms to use and how to use them

770
00:25:10,400 --> 00:25:13,120
um but generally speaking aes is going

771
00:25:13,120 --> 00:25:15,200
to get you most of the cases if it

772
00:25:15,200 --> 00:25:15,760
doesn't

773
00:25:15,760 --> 00:25:17,760
um there are some other options

774
00:25:17,760 --> 00:25:18,960
available to you

775
00:25:18,960 --> 00:25:21,679
so this brings us to asymmetric

776
00:25:21,679 --> 00:25:23,039
encryption

777
00:25:23,039 --> 00:25:25,200
asymmetric encryption is really our

778
00:25:25,200 --> 00:25:26,840
traditional alice and bob

779
00:25:26,840 --> 00:25:29,760
story we've got two people who want to

780
00:25:29,760 --> 00:25:30,080
share

781
00:25:30,080 --> 00:25:32,159
information between each other and they

782
00:25:32,159 --> 00:25:33,840
want to do it in such a way that they

783
00:25:33,840 --> 00:25:34,559
don't

784
00:25:34,559 --> 00:25:36,960
risk losing information as part of the

785
00:25:36,960 --> 00:25:38,000
process

786
00:25:38,000 --> 00:25:40,559
and to do this we have two pieces we

787
00:25:40,559 --> 00:25:42,000
have this idea of a public

788
00:25:42,000 --> 00:25:44,720
key and a private key and the public key

789
00:25:44,720 --> 00:25:45,760
can be shared with

790
00:25:45,760 --> 00:25:48,080
anybody this is completely open public

791
00:25:48,080 --> 00:25:48,880
knowledge

792
00:25:48,880 --> 00:25:52,080
anybody can have it and the idea is that

793
00:25:52,080 --> 00:25:52,320
if

794
00:25:52,320 --> 00:25:55,440
i want to send this send a message to

795
00:25:55,440 --> 00:25:56,320
somebody

796
00:25:56,320 --> 00:25:59,039
who is using that public key all i have

797
00:25:59,039 --> 00:26:01,520
to do is get a copy of that public key

798
00:26:01,520 --> 00:26:04,159
take my message encrypt it using their

799
00:26:04,159 --> 00:26:06,080
public key and their cipher text on the

800
00:26:06,080 --> 00:26:07,360
other side

801
00:26:07,360 --> 00:26:09,200
now the interesting part about this is

802
00:26:09,200 --> 00:26:11,279
that is that i can't

803
00:26:11,279 --> 00:26:13,600
you know i can pass this text around and

804
00:26:13,600 --> 00:26:15,520
if they only have the public key they

805
00:26:15,520 --> 00:26:17,039
should not be able to get

806
00:26:17,039 --> 00:26:19,520
the information out of the message that

807
00:26:19,520 --> 00:26:20,640
went into it

808
00:26:20,640 --> 00:26:23,840
so it should be safe for everybody to

809
00:26:23,840 --> 00:26:24,880
have a copy of it

810
00:26:24,880 --> 00:26:29,039
save for bob and then when bob gets it

811
00:26:29,039 --> 00:26:31,840
bob actually has the tool he has that

812
00:26:31,840 --> 00:26:33,039
private key

813
00:26:33,039 --> 00:26:35,039
to take and decrypt the message using

814
00:26:35,039 --> 00:26:36,240
the cipher text

815
00:26:36,240 --> 00:26:38,720
and usually a password protecting bob's

816
00:26:38,720 --> 00:26:39,840
private key

817
00:26:39,840 --> 00:26:41,919
so you have two layers of protection one

818
00:26:41,919 --> 00:26:43,840
they have to have physical access to the

819
00:26:43,840 --> 00:26:44,400
key

820
00:26:44,400 --> 00:26:46,080
but two they also have to have the

821
00:26:46,080 --> 00:26:47,919
password to unlock it so it's something

822
00:26:47,919 --> 00:26:49,919
they haven't something they know

823
00:26:49,919 --> 00:26:52,559
and that ends up producing this text

824
00:26:52,559 --> 00:26:53,840
back again

825
00:26:53,840 --> 00:26:56,640
so why do we use asymmetric data

826
00:26:56,640 --> 00:26:57,520
encryption

827
00:26:57,520 --> 00:26:59,919
uh really it serves two really good

828
00:26:59,919 --> 00:27:01,200
purposes for us

829
00:27:01,200 --> 00:27:03,039
the first one is it ensures that data

830
00:27:03,039 --> 00:27:04,799
can always be decrypted by the right

831
00:27:04,799 --> 00:27:05,600
people

832
00:27:05,600 --> 00:27:08,159
and assuming that it has decrypted on

833
00:27:08,159 --> 00:27:09,120
access

834
00:27:09,120 --> 00:27:11,200
um so assuming that they're using a

835
00:27:11,200 --> 00:27:13,840
password for this to unlock that private

836
00:27:13,840 --> 00:27:14,559
key

837
00:27:14,559 --> 00:27:17,200
we can actually go and say at a high

838
00:27:17,200 --> 00:27:18,000
level that we

839
00:27:18,000 --> 00:27:20,720
feel more secure that this person is the

840
00:27:20,720 --> 00:27:22,799
person who should be reading it

841
00:27:22,799 --> 00:27:25,760
um because you theoretically in this

842
00:27:25,760 --> 00:27:27,600
space if you have an encrypted message

843
00:27:27,600 --> 00:27:30,000
and they steal the private key if they

844
00:27:30,000 --> 00:27:32,240
don't have that password to unlock it

845
00:27:32,240 --> 00:27:34,240
that should be only in the person's mind

846
00:27:34,240 --> 00:27:35,679
and they should be the only person who

847
00:27:35,679 --> 00:27:36,480
has it

848
00:27:36,480 --> 00:27:39,279
um in that instance only then should

849
00:27:39,279 --> 00:27:41,279
they be able to open it up and decrypt

850
00:27:41,279 --> 00:27:41,679
it

851
00:27:41,679 --> 00:27:44,480
okay and additionally we have this kind

852
00:27:44,480 --> 00:27:45,600
of element of

853
00:27:45,600 --> 00:27:48,720
integrity which means i can say that if

854
00:27:48,720 --> 00:27:51,279
i know that i'm keeping my private key

855
00:27:51,279 --> 00:27:53,360
safely and i want to prove

856
00:27:53,360 --> 00:27:55,840
that i generated something i should be

857
00:27:55,840 --> 00:27:56,480
able to

858
00:27:56,480 --> 00:27:59,600
sign a copy of something using my public

859
00:27:59,600 --> 00:28:01,039
key in this case or

860
00:28:01,039 --> 00:28:04,399
using a signing key pair i should say

861
00:28:04,399 --> 00:28:06,640
to prove that i was the one who

862
00:28:06,640 --> 00:28:08,320
generated this message

863
00:28:08,320 --> 00:28:10,640
i can send it out so that everybody can

864
00:28:10,640 --> 00:28:11,679
decrypt it

865
00:28:11,679 --> 00:28:13,520
but since i was the only one who was

866
00:28:13,520 --> 00:28:15,039
able to encrypt it

867
00:28:15,039 --> 00:28:16,720
we know that the message came from me

868
00:28:16,720 --> 00:28:18,640
and we can use that to validate that the

869
00:28:18,640 --> 00:28:20,320
source of the data was exactly what we

870
00:28:20,320 --> 00:28:21,360
thought it was

871
00:28:21,360 --> 00:28:23,679
okay so signing really works in this

872
00:28:23,679 --> 00:28:24,480
function

873
00:28:24,480 --> 00:28:28,640
and it uses uh is used for you know

874
00:28:28,640 --> 00:28:30,480
for us being able to validate things and

875
00:28:30,480 --> 00:28:32,080
we see this in a lot of cases

876
00:28:32,080 --> 00:28:36,000
um you know tools like generating uh

877
00:28:36,000 --> 00:28:38,399
jwts and things like that will allow us

878
00:28:38,399 --> 00:28:39,279
to use

879
00:28:39,279 --> 00:28:41,679
encryption to verify that the source of

880
00:28:41,679 --> 00:28:43,200
the data was original

881
00:28:43,200 --> 00:28:46,399
okay so we take some data we take a hash

882
00:28:46,399 --> 00:28:48,240
and then we go through and we sign that

883
00:28:48,240 --> 00:28:50,880
hash and now we have the ability to say

884
00:28:50,880 --> 00:28:53,679
if i ship the data that original portion

885
00:28:53,679 --> 00:28:54,240
of

886
00:28:54,240 --> 00:28:57,360
corporate ipsum with that hash and that

887
00:28:57,360 --> 00:28:58,080
message

888
00:28:58,080 --> 00:29:01,039
i can now say that this data that i sent

889
00:29:01,039 --> 00:29:02,240
you is correct

890
00:29:02,240 --> 00:29:04,240
by value of the fact that i ran this

891
00:29:04,240 --> 00:29:05,279
hash through it

892
00:29:05,279 --> 00:29:07,360
got a value that was cryptographically

893
00:29:07,360 --> 00:29:08,399
sound

894
00:29:08,399 --> 00:29:10,799
and then signed that and sent that to

895
00:29:10,799 --> 00:29:12,960
you now you have verification that not

896
00:29:12,960 --> 00:29:14,799
only the data that was sent as part of

897
00:29:14,799 --> 00:29:16,080
the package was correct

898
00:29:16,080 --> 00:29:18,080
but also that i was the one who said it

899
00:29:18,080 --> 00:29:19,279
was correct

900
00:29:19,279 --> 00:29:22,640
okay um which brings us to the point

901
00:29:22,640 --> 00:29:24,320
where we start actually talking about

902
00:29:24,320 --> 00:29:26,080
algorithms and there are two main

903
00:29:26,080 --> 00:29:27,760
algorithms in this space that we can

904
00:29:27,760 --> 00:29:30,080
talk about um the first one is

905
00:29:30,080 --> 00:29:33,200
rsa and rsa was originally designed in

906
00:29:33,200 --> 00:29:35,440
the 1970s

907
00:29:35,440 --> 00:29:38,159
and the math behind it basically relies

908
00:29:38,159 --> 00:29:39,279
on the fact

909
00:29:39,279 --> 00:29:42,480
that factoring really really large

910
00:29:42,480 --> 00:29:43,200
primes

911
00:29:43,200 --> 00:29:45,679
is very difficult and time consuming to

912
00:29:45,679 --> 00:29:46,480
do

913
00:29:46,480 --> 00:29:48,799
now the key to this is that it really

914
00:29:48,799 --> 00:29:50,480
gives us a space where

915
00:29:50,480 --> 00:29:52,960
as we scale up on this it gets more and

916
00:29:52,960 --> 00:29:54,000
more difficult to try

917
00:29:54,000 --> 00:29:57,360
and guess those keys and so at low

918
00:29:57,360 --> 00:30:00,480
bit rate for the keys we run into

919
00:30:00,480 --> 00:30:01,039
problems

920
00:30:01,039 --> 00:30:04,480
so for example 256 keys can be broken in

921
00:30:04,480 --> 00:30:06,240
about 35 minutes

922
00:30:06,240 --> 00:30:08,720
10 24 is really kind of that minimum

923
00:30:08,720 --> 00:30:09,919
considered to be secure

924
00:30:09,919 --> 00:30:13,039
you really want to be at 2048. but once

925
00:30:13,039 --> 00:30:13,919
we get up to

926
00:30:13,919 --> 00:30:16,720
4096 we've got something that's fairly

927
00:30:16,720 --> 00:30:18,640
resilient going forward

928
00:30:18,640 --> 00:30:20,320
but runs into the problem that

929
00:30:20,320 --> 00:30:22,320
generating keys of that size is a

930
00:30:22,320 --> 00:30:25,600
very very time consuming process

931
00:30:25,600 --> 00:30:28,080
and the further we go up that the

932
00:30:28,080 --> 00:30:30,240
processing time necessary to generate

933
00:30:30,240 --> 00:30:31,360
larger keys gets

934
00:30:31,360 --> 00:30:33,600
exponentially larger as we go up through

935
00:30:33,600 --> 00:30:34,559
this

936
00:30:34,559 --> 00:30:37,840
um and so it's both a blessing and a

937
00:30:37,840 --> 00:30:40,080
curse in that way that we have something

938
00:30:40,080 --> 00:30:41,919
that you know gets more difficult to

939
00:30:41,919 --> 00:30:43,440
process that way but becomes more

940
00:30:43,440 --> 00:30:45,200
difficult for us to generate

941
00:30:45,200 --> 00:30:46,960
um generally speaking when you hear

942
00:30:46,960 --> 00:30:49,039
about uh quantum

943
00:30:49,039 --> 00:30:51,919
quantum affecting cryptography this is

944
00:30:51,919 --> 00:30:53,679
usually what they're talking about

945
00:30:53,679 --> 00:30:55,600
because the properties of quantum

946
00:30:55,600 --> 00:30:58,159
computers are such that they will allow

947
00:30:58,159 --> 00:30:58,799
for the

948
00:30:58,799 --> 00:31:01,600
quick factorization of prime numbers

949
00:31:01,600 --> 00:31:02,000
which

950
00:31:02,000 --> 00:31:05,919
could put rsa at risk

951
00:31:05,919 --> 00:31:08,960
so so what do we do to shift away from

952
00:31:08,960 --> 00:31:09,440
that

953
00:31:09,440 --> 00:31:11,279
we have what's called elliptic curve

954
00:31:11,279 --> 00:31:12,559
cryptography

955
00:31:12,559 --> 00:31:16,159
and really it addresses a lot of these

956
00:31:16,159 --> 00:31:19,679
underlying pieces and really ecc

957
00:31:19,679 --> 00:31:22,080
is very fast it's structured so that it

958
00:31:22,080 --> 00:31:23,519
can be run on very low

959
00:31:23,519 --> 00:31:26,559
performing hardware and it's generally

960
00:31:26,559 --> 00:31:28,320
considered to be

961
00:31:28,320 --> 00:31:31,519
pretty strong against future

962
00:31:31,519 --> 00:31:34,080
incidences of you know quantum

963
00:31:34,080 --> 00:31:36,159
cryptography problems right

964
00:31:36,159 --> 00:31:38,159
um so generally speaking whenever we're

965
00:31:38,159 --> 00:31:40,000
looking at doing public key private key

966
00:31:40,000 --> 00:31:41,440
now we really want to go in

967
00:31:41,440 --> 00:31:43,919
and we want to be doing elliptic curve

968
00:31:43,919 --> 00:31:44,720
okay

969
00:31:44,720 --> 00:31:46,159
but there are some things that you have

970
00:31:46,159 --> 00:31:48,000
to know about elliptic curve and it can

971
00:31:48,000 --> 00:31:48,399
get

972
00:31:48,399 --> 00:31:50,399
really kind of challenging to go through

973
00:31:50,399 --> 00:31:51,440
this process

974
00:31:51,440 --> 00:31:53,039
uh there's a website that will give you

975
00:31:53,039 --> 00:31:55,200
a list of safe curves to use

976
00:31:55,200 --> 00:31:56,799
and they go through and they list all of

977
00:31:56,799 --> 00:31:59,039
these um the final note on this is

978
00:31:59,039 --> 00:32:00,240
probably

979
00:32:00,240 --> 00:32:02,880
you know i i personally can't tell you

980
00:32:02,880 --> 00:32:04,399
whether you should be using them or

981
00:32:04,399 --> 00:32:05,200
shouldn't be using

982
00:32:05,200 --> 00:32:06,559
them whether they're safe or whether

983
00:32:06,559 --> 00:32:08,399
they're not safe there's a lot of

984
00:32:08,399 --> 00:32:09,919
question in that space

985
00:32:09,919 --> 00:32:14,240
as to what constitutes safe or unsafe um

986
00:32:14,240 --> 00:32:16,240
but if you want to avoid that

987
00:32:16,240 --> 00:32:18,080
conversation altogether

988
00:32:18,080 --> 00:32:21,039
uh just don't use those um there are two

989
00:32:21,039 --> 00:32:22,799
really good curves out there

990
00:32:22,799 --> 00:32:25,600
um the first is curve two five five one

991
00:32:25,600 --> 00:32:26,480
nine

992
00:32:26,480 --> 00:32:29,200
um which is generally considered a

993
00:32:29,200 --> 00:32:30,919
really good one or

994
00:32:30,919 --> 00:32:33,840
p256 and both of these uh depending on

995
00:32:33,840 --> 00:32:35,279
the hardware that you're looking at may

996
00:32:35,279 --> 00:32:36,080
actually have

997
00:32:36,080 --> 00:32:38,640
hardware acceleration that really pushes

998
00:32:38,640 --> 00:32:40,240
that to the next level

999
00:32:40,240 --> 00:32:41,919
um generally speaking those are going to

1000
00:32:41,919 --> 00:32:43,039
be the two that you're going to want to

1001
00:32:43,039 --> 00:32:45,120
use if you need something that's got a

1002
00:32:45,120 --> 00:32:47,120
kind of a higher level of security

1003
00:32:47,120 --> 00:32:49,360
um and you're willing to burn off a

1004
00:32:49,360 --> 00:32:52,000
couple extra cpu cycles to make it work

1005
00:32:52,000 --> 00:32:56,399
uh ed448 goldilocks is a good choice

1006
00:32:56,399 --> 00:33:00,399
okay but say you know we've got

1007
00:33:00,399 --> 00:33:02,320
symmetric key encryption which is really

1008
00:33:02,320 --> 00:33:04,320
good for transferring information

1009
00:33:04,320 --> 00:33:05,679
quickly

1010
00:33:05,679 --> 00:33:07,760
and encrypting large amounts of data

1011
00:33:07,760 --> 00:33:09,120
using private key

1012
00:33:09,120 --> 00:33:12,080
private public key is really slow how do

1013
00:33:12,080 --> 00:33:12,480
we

1014
00:33:12,480 --> 00:33:14,159
kind of bridge that gap and generally

1015
00:33:14,159 --> 00:33:15,600
when we do that we talk about hybrid

1016
00:33:15,600 --> 00:33:16,720
encryption

1017
00:33:16,720 --> 00:33:18,720
and what we have is we have two groups

1018
00:33:18,720 --> 00:33:20,480
that have their public keys and private

1019
00:33:20,480 --> 00:33:21,039
keys

1020
00:33:21,039 --> 00:33:22,799
and we go through a key negotiation

1021
00:33:22,799 --> 00:33:24,320
process where we generate

1022
00:33:24,320 --> 00:33:27,200
a random key and then we encrypt the

1023
00:33:27,200 --> 00:33:29,919
bulk of the data that we want to

1024
00:33:29,919 --> 00:33:32,240
you know pass back and forth between us

1025
00:33:32,240 --> 00:33:34,159
with that key

1026
00:33:34,159 --> 00:33:36,799
and then we wrap it up in the public key

1027
00:33:36,799 --> 00:33:38,480
private key exchange

1028
00:33:38,480 --> 00:33:40,240
and so what we'll do is we'll take and

1029
00:33:40,240 --> 00:33:42,080
we'll transfer the data

1030
00:33:42,080 --> 00:33:44,240
and when we're done with that we'll take

1031
00:33:44,240 --> 00:33:45,760
and we'll transfer the key

1032
00:33:45,760 --> 00:33:47,600
to that data using public and private

1033
00:33:47,600 --> 00:33:49,039
key cryptography

1034
00:33:49,039 --> 00:33:50,960
that way we effectively have a balance

1035
00:33:50,960 --> 00:33:52,799
of data that's transferred to one

1036
00:33:52,799 --> 00:33:55,120
place to another safely and then is

1037
00:33:55,120 --> 00:33:56,399
decrypted once

1038
00:33:56,399 --> 00:33:58,880
the party that we know is going to be

1039
00:33:58,880 --> 00:34:00,000
receiving it

1040
00:34:00,000 --> 00:34:01,760
decrypts that random key for the

1041
00:34:01,760 --> 00:34:04,159
symmetric portion and then can decrypt

1042
00:34:04,159 --> 00:34:08,079
the main part the of the payload um

1043
00:34:08,079 --> 00:34:09,359
and that's really what we talk about

1044
00:34:09,359 --> 00:34:12,480
whenever we talk about hybrid encryption

1045
00:34:12,480 --> 00:34:14,960
okay so this kind of brings us to the

1046
00:34:14,960 --> 00:34:17,119
last piece right we've talked some about

1047
00:34:17,119 --> 00:34:18,639
encryption we've talked some about

1048
00:34:18,639 --> 00:34:20,560
hashing we've talked some about

1049
00:34:20,560 --> 00:34:22,960
passwords and all of this but you know

1050
00:34:22,960 --> 00:34:24,879
anytime we talk about encryption

1051
00:34:24,879 --> 00:34:27,839
you know the problem comes of the key

1052
00:34:27,839 --> 00:34:28,719
right

1053
00:34:28,719 --> 00:34:31,440
somebody inherently has to know the key

1054
00:34:31,440 --> 00:34:32,079
and some

1055
00:34:32,079 --> 00:34:34,560
where somebody has to be able to hold it

1056
00:34:34,560 --> 00:34:36,719
otherwise we can't use it right

1057
00:34:36,719 --> 00:34:38,800
so where do we put them um generally

1058
00:34:38,800 --> 00:34:40,560
speaking your encryption's only as good

1059
00:34:40,560 --> 00:34:42,079
as your storage key

1060
00:34:42,079 --> 00:34:44,159
and what you're doing with that can make

1061
00:34:44,159 --> 00:34:45,679
it either stronger

1062
00:34:45,679 --> 00:34:47,440
as far as the protection or really

1063
00:34:47,440 --> 00:34:49,040
weaken it and so

1064
00:34:49,040 --> 00:34:50,800
when we talk about this some really bad

1065
00:34:50,800 --> 00:34:52,560
places to store encryption keys are

1066
00:34:52,560 --> 00:34:53,440
things like

1067
00:34:53,440 --> 00:34:56,399
in docker secrets um so first of all it

1068
00:34:56,399 --> 00:34:58,000
should be known that docker whenever you

1069
00:34:58,000 --> 00:35:00,000
do a docker secret is only base64

1070
00:35:00,000 --> 00:35:01,040
encoded

1071
00:35:01,040 --> 00:35:03,440
so that's not really encryption at all

1072
00:35:03,440 --> 00:35:04,400
um but if

1073
00:35:04,400 --> 00:35:05,920
assuming that you go through and encrypt

1074
00:35:05,920 --> 00:35:07,920
your data in the secret and then you put

1075
00:35:07,920 --> 00:35:08,960
that secret in

1076
00:35:08,960 --> 00:35:10,960
a base64 encoding and then store it in

1077
00:35:10,960 --> 00:35:12,720
there it's still not safe you don't want

1078
00:35:12,720 --> 00:35:13,280
to stick

1079
00:35:13,280 --> 00:35:16,320
your encryption keys in docker or

1080
00:35:16,320 --> 00:35:19,359
kubernetes at all web configs or other

1081
00:35:19,359 --> 00:35:20,880
similar config files

1082
00:35:20,880 --> 00:35:24,000
is generally also a bad idea don't and

1083
00:35:24,000 --> 00:35:27,040
put these keys in source code if you've

1084
00:35:27,040 --> 00:35:27,359
got

1085
00:35:27,359 --> 00:35:28,960
questions about how easy it is to

1086
00:35:28,960 --> 00:35:30,400
disassemble something

1087
00:35:30,400 --> 00:35:33,200
um it's painfully easy to get a hold of

1088
00:35:33,200 --> 00:35:33,920
your code

1089
00:35:33,920 --> 00:35:36,960
and disassemble it um don't stick it in

1090
00:35:36,960 --> 00:35:39,599
environment variables um because

1091
00:35:39,599 --> 00:35:40,640
attackers have

1092
00:35:40,640 --> 00:35:42,560
if they get access to the environment

1093
00:35:42,560 --> 00:35:46,079
they also have access to those variables

1094
00:35:46,079 --> 00:35:48,640
um generally speaking don't stick them

1095
00:35:48,640 --> 00:35:50,480
in databases one of my favorite stories

1096
00:35:50,480 --> 00:35:53,040
is i had a group that came to me and

1097
00:35:53,040 --> 00:35:54,640
showed me their database structure and

1098
00:35:54,640 --> 00:35:56,560
they said okay all of our data is safe

1099
00:35:56,560 --> 00:35:57,520
now everything's

1100
00:35:57,520 --> 00:36:00,079
safe and secure and i said well yeah it

1101
00:36:00,079 --> 00:36:01,440
kind of is except for

1102
00:36:01,440 --> 00:36:03,839
you know you could get in to your system

1103
00:36:03,839 --> 00:36:05,599
by a sql injection

1104
00:36:05,599 --> 00:36:08,240
and on each row it has a row encryption

1105
00:36:08,240 --> 00:36:08,960
key

1106
00:36:08,960 --> 00:36:11,280
as one of the columns so they don't

1107
00:36:11,280 --> 00:36:12,560
store it in the database

1108
00:36:12,560 --> 00:36:14,240
they can get access that's where it's

1109
00:36:14,240 --> 00:36:15,760
going to be um

1110
00:36:15,760 --> 00:36:18,240
don't stick keys in open memory this is

1111
00:36:18,240 --> 00:36:20,000
kind of a tough one for a lot of groups

1112
00:36:20,000 --> 00:36:21,440
to kind of really wrap their minds

1113
00:36:21,440 --> 00:36:23,040
around

1114
00:36:23,040 --> 00:36:24,800
effectively what happens is even when

1115
00:36:24,800 --> 00:36:26,240
you're pulling these things into memory

1116
00:36:26,240 --> 00:36:28,079
somebody can dump the memory of your

1117
00:36:28,079 --> 00:36:29,599
application get those debug

1118
00:36:29,599 --> 00:36:31,599
pieces and dump your application and

1119
00:36:31,599 --> 00:36:32,880
pull that out

1120
00:36:32,880 --> 00:36:34,480
and so we want to make sure that

1121
00:36:34,480 --> 00:36:36,400
whenever we handle that we don't want to

1122
00:36:36,400 --> 00:36:38,079
have our encryption key sitting out

1123
00:36:38,079 --> 00:36:39,440
there because that's effectively giving

1124
00:36:39,440 --> 00:36:40,640
away the data

1125
00:36:40,640 --> 00:36:43,040
under no circumstances ever stick

1126
00:36:43,040 --> 00:36:44,960
secrets into source control

1127
00:36:44,960 --> 00:36:47,680
this is a horrible idea um encryption

1128
00:36:47,680 --> 00:36:49,839
keys those type of things have no place

1129
00:36:49,839 --> 00:36:51,839
in belonging anywhere in your data

1130
00:36:51,839 --> 00:36:53,200
whatsoever

1131
00:36:53,200 --> 00:36:55,359
build servers the number of teams that

1132
00:36:55,359 --> 00:36:57,520
i've seen sticking

1133
00:36:57,520 --> 00:36:59,599
you know encryption keys and secrets in

1134
00:36:59,599 --> 00:37:01,520
build servers is an awful idea

1135
00:37:01,520 --> 00:37:04,160
don't do that um good places to stick

1136
00:37:04,160 --> 00:37:06,640
encryption keys if you're on a device

1137
00:37:06,640 --> 00:37:09,760
having the tpm generate a key or

1138
00:37:09,760 --> 00:37:11,760
generating a sub key from a key that's

1139
00:37:11,760 --> 00:37:14,240
stored in tpm is a fantastic way

1140
00:37:14,240 --> 00:37:17,119
to ensure that that key is held securely

1141
00:37:17,119 --> 00:37:17,520
um

1142
00:37:17,520 --> 00:37:19,599
inside operating systems they're usually

1143
00:37:19,599 --> 00:37:21,520
credential management systems

1144
00:37:21,520 --> 00:37:23,359
you know it's better than storing them

1145
00:37:23,359 --> 00:37:25,040
directly on the hard drive but

1146
00:37:25,040 --> 00:37:28,240
still not quite the same level um

1147
00:37:28,240 --> 00:37:29,520
if you're in cloud environments or

1148
00:37:29,520 --> 00:37:31,599
you're gonna on prem a key vault can be

1149
00:37:31,599 --> 00:37:32,640
a fantastic

1150
00:37:32,640 --> 00:37:34,960
option and so what that does is it

1151
00:37:34,960 --> 00:37:36,240
allows you to

1152
00:37:36,240 --> 00:37:38,880
segregate your encryption keys away from

1153
00:37:38,880 --> 00:37:40,400
the rest of your applications

1154
00:37:40,400 --> 00:37:43,440
so that it's only available on request

1155
00:37:43,440 --> 00:37:44,960
and then whenever you make that request

1156
00:37:44,960 --> 00:37:46,640
and whenever you pull it local

1157
00:37:46,640 --> 00:37:48,480
use secure strings most of those are

1158
00:37:48,480 --> 00:37:50,480
built into application to

1159
00:37:50,480 --> 00:37:53,680
application frameworks to allow the safe

1160
00:37:53,680 --> 00:37:55,359
containment of secrets

1161
00:37:55,359 --> 00:37:57,280
it's not great but it adds an extra

1162
00:37:57,280 --> 00:38:01,200
level of difficulty into extracting them

1163
00:38:01,200 --> 00:38:02,960
so if you want additional reading in

1164
00:38:02,960 --> 00:38:04,720
this space i would strongly recommend

1165
00:38:04,720 --> 00:38:06,160
picking up a copy of applied

1166
00:38:06,160 --> 00:38:09,520
cryptography it is a fantastic book

1167
00:38:09,520 --> 00:38:11,359
despite its age hopefully we will get a

1168
00:38:11,359 --> 00:38:13,280
third edition at some point

1169
00:38:13,280 --> 00:38:15,520
um additionally we have practical

1170
00:38:15,520 --> 00:38:16,960
cryptography developers

1171
00:38:16,960 --> 00:38:19,760
currently the entire book is as much of

1172
00:38:19,760 --> 00:38:20,160
it

1173
00:38:20,160 --> 00:38:22,320
as written is currently available on the

1174
00:38:22,320 --> 00:38:25,200
web and definitely thank you for that

1175
00:38:25,200 --> 00:38:27,359
um with that said i would like to thank

1176
00:38:27,359 --> 00:38:29,200
you and i will be around to take

1177
00:38:29,200 --> 00:38:33,279
questions uh thank you very much

