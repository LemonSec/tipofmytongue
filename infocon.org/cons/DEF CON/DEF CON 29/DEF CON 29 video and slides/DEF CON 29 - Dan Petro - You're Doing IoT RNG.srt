1
00:00:01,460 --> 00:00:02,730
- Hi, I'm Allan Cecil.

2
00:00:02,730 --> 00:00:04,870
And with me today, I have-

3
00:00:04,870 --> 00:00:05,790
- Dan Petro.

4
00:00:05,790 --> 00:00:08,152
- We are presenting
"You're Doing IoT RNG".

5
00:00:08,152 --> 00:00:09,440
We're talking about vulnerabilities

6
00:00:09,440 --> 00:00:13,170
that exist in virtually
every device out there

7
00:00:13,170 --> 00:00:14,800
in the IoT world.

8
00:00:14,800 --> 00:00:17,360
That's a critical issue that
we need to talk to you about

9
00:00:17,360 --> 00:00:19,510
because random numbers
are used everywhere.

10
00:00:20,750 --> 00:00:21,980
- Before we get too far though,

11
00:00:21,980 --> 00:00:24,250
let's talk a little bit
about random numbers

12
00:00:24,250 --> 00:00:26,660
and why they're so important to security.

13
00:00:26,660 --> 00:00:29,040
Numbers of course are kind
of how computers work.

14
00:00:29,040 --> 00:00:30,910
So a random number can be a stand in

15
00:00:30,910 --> 00:00:32,100
for all sorts of things

16
00:00:32,100 --> 00:00:34,510
that we don't normally
think of as numerical.

17
00:00:34,510 --> 00:00:37,380
So encryption keys, authentication tokens,

18
00:00:37,380 --> 00:00:40,160
and our lovely friend, business logic.

19
00:00:40,160 --> 00:00:41,810
But one of the things
you're going to notice

20
00:00:41,810 --> 00:00:43,240
throughout this presentation

21
00:00:43,240 --> 00:00:44,380
is that the vulnerabilities

22
00:00:44,380 --> 00:00:45,580
that we're going to describe here

23
00:00:45,580 --> 00:00:47,630
have a lot to do with these specific logic

24
00:00:47,630 --> 00:00:50,030
of a particular application

25
00:00:50,030 --> 00:00:52,780
in a way that is hard to replicate on map.

26
00:00:52,780 --> 00:00:55,580
So a lot of the vulnerabilities
that we'll discuss here

27
00:00:55,580 --> 00:00:58,110
are kind of specific to
particular applications

28
00:00:58,110 --> 00:01:01,020
or frameworks and are necessarily
the kind of canned exploit

29
00:01:01,020 --> 00:01:04,720
that you might expect
from a widespread CVE.

30
00:01:04,720 --> 00:01:05,553
- One of the problems though

31
00:01:05,553 --> 00:01:08,230
is that computers are notoriously bad

32
00:01:08,230 --> 00:01:10,520
at making truly random numbers.

33
00:01:10,520 --> 00:01:12,530
And that's because computers
need to be deterministic.

34
00:01:12,530 --> 00:01:15,360
If you did math and every
time you got a different value

35
00:01:15,360 --> 00:01:18,580
out of pi or you had a penny two processor

36
00:01:18,580 --> 00:01:20,430
that just kept messing up
floating point numbers,

37
00:01:20,430 --> 00:01:21,410
you'd have problems.

38
00:01:21,410 --> 00:01:22,650
And we have seen this in the past.

39
00:01:22,650 --> 00:01:26,410
So we make computers to
be very deterministic.

40
00:01:26,410 --> 00:01:29,470
However, sometimes you need
stuff that isn't deterministic.

41
00:01:29,470 --> 00:01:31,190
You need some entropy.

42
00:01:31,190 --> 00:01:32,750
And that's where our
hardware RNG comes in.

43
00:01:32,750 --> 00:01:35,580
That's its job, is to make entropy,

44
00:01:35,580 --> 00:01:37,290
to make a source of randomness,

45
00:01:37,290 --> 00:01:41,160
to be a seed for some way
of getting random numbers.

46
00:01:41,160 --> 00:01:43,263
So that solves the problem, right?

47
00:01:44,470 --> 00:01:45,413
- Now is actually a good time to bring up

48
00:01:45,413 --> 00:01:48,440
that there's two major kinds
of random number generators

49
00:01:48,440 --> 00:01:50,860
that you'll find, a pseudo
random number generator

50
00:01:50,860 --> 00:01:53,520
and a true random number generator.

51
00:01:53,520 --> 00:01:55,370
You might think from the names of them

52
00:01:55,370 --> 00:01:58,470
that you want the true new
random number generator

53
00:01:58,470 --> 00:02:00,450
or the TRNG, that that's the good one

54
00:02:00,450 --> 00:02:03,980
and pseudo ones are the bad
ones, but it's not that simple.

55
00:02:03,980 --> 00:02:06,840
Really the distinction is only
that one is made in software

56
00:02:06,840 --> 00:02:08,740
and one is made in hardware.

57
00:02:08,740 --> 00:02:11,790
And the names really lead you astray here.

58
00:02:11,790 --> 00:02:15,040
I particularly hate the name,
true random number generator

59
00:02:15,040 --> 00:02:16,410
for the hardware ones.

60
00:02:16,410 --> 00:02:19,260
It sort of implies a kind
of quality behind them

61
00:02:19,260 --> 00:02:21,160
that isn't necessarily present.

62
00:02:21,160 --> 00:02:24,040
I suspect this naming comes from big RNG

63
00:02:24,040 --> 00:02:25,580
as a propaganda term.

64
00:02:25,580 --> 00:02:27,800
But in any case, the pseudo
random number generators

65
00:02:27,800 --> 00:02:29,870
also come in two major forms,

66
00:02:29,870 --> 00:02:32,770
the cryptographically secure
random number generators

67
00:02:32,770 --> 00:02:36,650
or CSPRNG for short and regular ones.

68
00:02:36,650 --> 00:02:38,340
So the regular ones are things you'll find

69
00:02:38,340 --> 00:02:40,810
in like libc random or
the Mersenne Twister

70
00:02:40,810 --> 00:02:42,070
that are meant to be fast.

71
00:02:42,070 --> 00:02:43,410
They're really efficient.

72
00:02:43,410 --> 00:02:44,940
They're just pieces of software.

73
00:02:44,940 --> 00:02:47,780
In both cases, they work
basically the same though.

74
00:02:47,780 --> 00:02:51,910
You take an initial seed
number that could be any length

75
00:02:51,910 --> 00:02:56,770
somewhere between 32 bits
all the way up to 128 bits.

76
00:02:56,770 --> 00:02:59,070
And then you stretch that entropy out

77
00:02:59,070 --> 00:03:00,270
indefinitely into the future.

78
00:03:00,270 --> 00:03:05,020
You could produce the stream
of seemingly random numbers

79
00:03:05,020 --> 00:03:06,600
from that seed, right?

80
00:03:06,600 --> 00:03:08,940
So it's an entirely
predictable set of numbers

81
00:03:08,940 --> 00:03:10,510
given that initial seed.

82
00:03:10,510 --> 00:03:11,730
And so the distinction

83
00:03:11,730 --> 00:03:14,680
between a cryptographically
secure random number generator

84
00:03:14,680 --> 00:03:16,830
and a not secure one

85
00:03:16,830 --> 00:03:19,750
is basically that the regular
ones like the Mersenne Twister

86
00:03:19,750 --> 00:03:20,930
or libc random

87
00:03:20,930 --> 00:03:23,860
or any number of other
common implementations

88
00:03:23,860 --> 00:03:26,670
will leak information
about the internal state

89
00:03:26,670 --> 00:03:29,290
and, therefore, the seed as you go along.

90
00:03:29,290 --> 00:03:31,970
So there's really no
secure way to use those.

91
00:03:31,970 --> 00:03:35,230
They're never safe to use for security,

92
00:03:35,230 --> 00:03:37,350
critical pieces of information.

93
00:03:37,350 --> 00:03:40,760
Anytime you actually
need secure information,

94
00:03:40,760 --> 00:03:42,390
like a crypto key or something like that,

95
00:03:42,390 --> 00:03:45,180
you should definitely be using a CSPRNG.

96
00:03:45,180 --> 00:03:48,010
And then the security of the hardware RNG

97
00:03:48,010 --> 00:03:51,750
is something that we
investigated in this research.

98
00:03:51,750 --> 00:03:53,880
One unfortunate part about the design

99
00:03:53,880 --> 00:03:55,630
of these hardware random number generators

100
00:03:55,630 --> 00:03:57,310
is that there's not a
lot of information known

101
00:03:57,310 --> 00:03:59,870
about the details of
how they actually work

102
00:03:59,870 --> 00:04:01,380
or they're basically black boxes.

103
00:04:01,380 --> 00:04:02,930
So if you wanted to find out

104
00:04:02,930 --> 00:04:05,850
about how your favorite IoT device,

105
00:04:05,850 --> 00:04:08,970
the hardware random number
generator actually works,

106
00:04:08,970 --> 00:04:10,360
you're kind of out of luck.

107
00:04:10,360 --> 00:04:12,570
One notable exception is the STM32.

108
00:04:12,570 --> 00:04:16,700
Wanna give them a shout out
from STMicroelectronics.

109
00:04:16,700 --> 00:04:18,010
They actually have
really great information

110
00:04:18,010 --> 00:04:20,800
about the details of the
inner workings of their RNG

111
00:04:20,800 --> 00:04:22,220
as well as proof of correctness,

112
00:04:22,220 --> 00:04:25,160
a kind of proof of the
good quality random numbers

113
00:04:25,160 --> 00:04:26,710
that came out of it.

114
00:04:26,710 --> 00:04:29,860
But there's two kind of
basic digital designs

115
00:04:29,860 --> 00:04:33,130
that you'll find for how
to produce random numbers

116
00:04:33,130 --> 00:04:35,120
in hardware, at least in a low cost way

117
00:04:35,120 --> 00:04:37,230
that you'll find in IoT devices.

118
00:04:37,230 --> 00:04:39,600
Analog circuits and clock timings.

119
00:04:39,600 --> 00:04:41,510
The first one is an analog circuit.

120
00:04:41,510 --> 00:04:43,610
So you're probably more
familiar with digital circuits,

121
00:04:43,610 --> 00:04:46,730
that is circuits that are
gated by a clocking function.

122
00:04:46,730 --> 00:04:48,260
Analog circuits are kind of the opposite.

123
00:04:48,260 --> 00:04:51,070
There's no central gate by a clock.

124
00:04:51,070 --> 00:04:53,640
So what you can do is
set up a analog circuit

125
00:04:53,640 --> 00:04:55,470
that sort of looks like
the diagram we have here

126
00:04:55,470 --> 00:04:56,670
on the top right.

127
00:04:56,670 --> 00:04:59,750
And there's a bit that
flows back and forth

128
00:04:59,750 --> 00:05:00,870
between these (indistinct) functions.

129
00:05:00,870 --> 00:05:02,250
So it's either a zero or a one

130
00:05:02,250 --> 00:05:04,417
and a zero and a one kind
of back and forth again,

131
00:05:04,417 --> 00:05:06,560
and sort of spins in this infinite loop,

132
00:05:06,560 --> 00:05:08,370
going back and forth between zero and one

133
00:05:08,370 --> 00:05:12,640
at a function at a rate rather
that is not exactly random,

134
00:05:12,640 --> 00:05:13,970
but sort of arbitrary.

135
00:05:13,970 --> 00:05:15,560
So if you were to pull that,

136
00:05:15,560 --> 00:05:17,890
if you say, ask the analog circuit

137
00:05:17,890 --> 00:05:22,380
at any given point in time
to find out what the bid is,

138
00:05:22,380 --> 00:05:24,570
the value will be pretty random.

139
00:05:24,570 --> 00:05:25,840
And that's a pretty good way

140
00:05:25,840 --> 00:05:28,900
of designing a hardware
random number generator.

141
00:05:28,900 --> 00:05:32,140
- There's also a method where
you're using multiple clocks

142
00:05:32,140 --> 00:05:35,110
at the same time to get a difference

143
00:05:35,110 --> 00:05:38,160
between a delta, between
the measured differences

144
00:05:38,160 --> 00:05:38,993
between those clocks.

145
00:05:38,993 --> 00:05:41,360
If you had two clocks that were derived

146
00:05:41,360 --> 00:05:42,700
from the same source,

147
00:05:42,700 --> 00:05:44,900
the result should, in
theory, be identical.

148
00:05:44,900 --> 00:05:47,990
So you would always get a one or a zero

149
00:05:47,990 --> 00:05:49,700
depending on when you sampled it.

150
00:05:49,700 --> 00:05:52,140
But if you allow them to run freely

151
00:05:52,140 --> 00:05:53,910
and measure the delta between the two,

152
00:05:53,910 --> 00:05:55,860
you can get a pretty normal
distribution of differences

153
00:05:55,860 --> 00:05:56,980
between the two.

154
00:05:56,980 --> 00:06:01,250
Sometimes this happens on situations

155
00:06:01,250 --> 00:06:02,230
that you wouldn't expect

156
00:06:02,230 --> 00:06:04,440
where the designers didn't
deliberately do that.

157
00:06:04,440 --> 00:06:07,370
One of them happens to be
the original Super Nintendo.

158
00:06:07,370 --> 00:06:09,360
They had a 21 megahertz clock

159
00:06:09,360 --> 00:06:13,400
for the central processing
unit and a 24.576 clock

160
00:06:13,400 --> 00:06:16,530
for the APU, the audio processing unit.

161
00:06:16,530 --> 00:06:19,620
The result is that speed
runners playing Super Metroid,

162
00:06:19,620 --> 00:06:22,270
they have to deal with random timings

163
00:06:22,270 --> 00:06:24,610
due to moving data across the bus

164
00:06:24,610 --> 00:06:26,440
when going through door transitions.

165
00:06:26,440 --> 00:06:28,560
Sometimes these random situations

166
00:06:28,560 --> 00:06:30,730
happen on unrelated devices

167
00:06:30,730 --> 00:06:32,830
and in a HAL harbor
random number generator,

168
00:06:32,830 --> 00:06:34,250
you're taking advantage

169
00:06:34,250 --> 00:06:36,870
of what just sometimes
happens accidentally

170
00:06:36,870 --> 00:06:40,440
and using that deliberately to
get random numbers out of it.

171
00:06:40,440 --> 00:06:42,070
There are some issues that come up

172
00:06:42,070 --> 00:06:45,750
if you're calling too often,
if you're running too fast,

173
00:06:45,750 --> 00:06:47,300
you're calling too frequently,

174
00:06:47,300 --> 00:06:49,650
for instance that output call

175
00:06:49,650 --> 00:06:51,510
from that analog circuit method.

176
00:06:51,510 --> 00:06:52,610
If you're calling it too often,

177
00:06:52,610 --> 00:06:54,900
you're gonna get the same
number twice in a row

178
00:06:54,900 --> 00:06:57,090
because you didn't give it
enough time to transition.

179
00:06:57,090 --> 00:07:00,550
And the same thing could
happen with the clock method.

180
00:07:00,550 --> 00:07:01,480
If you're calling it too frequently,

181
00:07:01,480 --> 00:07:03,180
you could also end up
with accidental sinking.

182
00:07:03,180 --> 00:07:06,370
It could just be that both of
your clocks happen to align.

183
00:07:06,370 --> 00:07:10,370
So they're both operating
in exactly the same offset.

184
00:07:10,370 --> 00:07:12,940
There's no guarantee that
you're going to be perfect,

185
00:07:12,940 --> 00:07:16,260
but it's usually good
enough that it's fine

186
00:07:16,260 --> 00:07:19,223
as long as you're not
calling it constantly.

187
00:07:20,230 --> 00:07:22,990
How IoT does RNG is interesting.

188
00:07:22,990 --> 00:07:27,080
Most new IoT system on a chips
have a hardware RNG device

189
00:07:27,080 --> 00:07:28,910
built into them as of 2021.

190
00:07:28,910 --> 00:07:31,430
That hardware RNG is an entire peripheral

191
00:07:31,430 --> 00:07:34,470
devoted to just RNG.

192
00:07:34,470 --> 00:07:35,933
So it must be secure, right?

193
00:07:37,490 --> 00:07:41,740
- The thing about IoT and
programming on IoT devices

194
00:07:41,740 --> 00:07:43,900
is that there's not really
any operating systems

195
00:07:43,900 --> 00:07:46,860
to kind of smooth over the
errors that you might make.

196
00:07:46,860 --> 00:07:50,350
Typically you just run
C/C++ on bare metal.

197
00:07:50,350 --> 00:07:52,150
So if you needed a random number

198
00:07:52,150 --> 00:07:55,870
for the security critical
piece of information,

199
00:07:55,870 --> 00:07:57,190
like a crypto key,

200
00:07:57,190 --> 00:08:00,150
you just call the hardware
RNG peripheral directly,

201
00:08:00,150 --> 00:08:02,030
usually through a HAL functional hardware

202
00:08:02,030 --> 00:08:03,610
abstraction layer function

203
00:08:03,610 --> 00:08:06,110
and something that looks
basically like this.

204
00:08:06,110 --> 00:08:07,440
This of course is pseudo code,

205
00:08:07,440 --> 00:08:09,120
but it looks basically the same

206
00:08:09,120 --> 00:08:12,250
across basically every
SDK and operating system.

207
00:08:12,250 --> 00:08:15,100
So there's the
HAL_get_random_number of function

208
00:08:15,100 --> 00:08:16,190
and there's kind of two parts

209
00:08:16,190 --> 00:08:17,730
that we really care about here.

210
00:08:17,730 --> 00:08:20,880
For one, there's an output
variable, the outnumber,

211
00:08:20,880 --> 00:08:23,540
that's the actual random
number that we care about.

212
00:08:23,540 --> 00:08:25,660
If you're familiar with C,
it's an output variable,

213
00:08:25,660 --> 00:08:28,650
basically you send it
a pointer to the number

214
00:08:28,650 --> 00:08:31,570
and then the function
will overwrite the value

215
00:08:31,570 --> 00:08:32,540
at that pointer.

216
00:08:32,540 --> 00:08:35,580
And then the actual return code,
which has an error message.

217
00:08:35,580 --> 00:08:36,820
The error message that'll tell you

218
00:08:36,820 --> 00:08:39,710
in case something went
wrong along the way.

219
00:08:39,710 --> 00:08:41,260
There's lots of things that can go wrong

220
00:08:41,260 --> 00:08:43,770
when you are talking to a
piece of hardware, right?

221
00:08:43,770 --> 00:08:45,900
The peripheral might be
broken or something went wrong

222
00:08:45,900 --> 00:08:46,860
over the bus.

223
00:08:46,860 --> 00:08:49,390
Maybe there are a random
number generator peripheral

224
00:08:49,390 --> 00:08:50,930
just wasn't ready yet.

225
00:08:50,930 --> 00:08:52,920
Maybe the relative positions
of Jupiter and Saturn

226
00:08:52,920 --> 00:08:55,320
for all we know are not aligned.

227
00:08:55,320 --> 00:08:57,720
In any case, an error can occur

228
00:08:57,720 --> 00:09:00,800
in the calling of this random
number generator function

229
00:09:00,800 --> 00:09:03,460
and it'll let you know about
that in the return code.

230
00:09:03,460 --> 00:09:06,110
So we wanna ask the natural question,

231
00:09:06,110 --> 00:09:07,530
how many people out there in the world

232
00:09:07,530 --> 00:09:09,733
actually check this error code?

233
00:09:10,630 --> 00:09:11,463
So as it happens,

234
00:09:11,463 --> 00:09:14,030
almost nobody actually
checks the return codes

235
00:09:14,030 --> 00:09:15,870
of these HAL RNG functions.

236
00:09:15,870 --> 00:09:18,620
Basically everybody out there
just sort of makes a call

237
00:09:18,620 --> 00:09:20,630
to the random number generator peripheral

238
00:09:20,630 --> 00:09:23,820
and just uses whatever result
that happens to give you.

239
00:09:23,820 --> 00:09:26,290
You can see two results
here from a free RTUs,

240
00:09:26,290 --> 00:09:28,770
which is a popular IoT operating system.

241
00:09:28,770 --> 00:09:32,770
And the MediaTek 7697.

242
00:09:32,770 --> 00:09:34,210
You could see both of these calls here

243
00:09:34,210 --> 00:09:35,770
are basically what we looked at earlier.

244
00:09:35,770 --> 00:09:37,580
There's a return code
that you're not seeing

245
00:09:37,580 --> 00:09:40,110
that it's checked and
then the output variable

246
00:09:40,110 --> 00:09:41,810
that's put into it.

247
00:09:41,810 --> 00:09:43,540
So maybe you're wondering,

248
00:09:43,540 --> 00:09:46,000
all right, so you didn't
check the return code

249
00:09:46,000 --> 00:09:48,230
of the HAL RNG function.

250
00:09:48,230 --> 00:09:50,070
What's the worst that could happen?

251
00:09:50,070 --> 00:09:52,380
- Undefined behavior.

252
00:09:52,380 --> 00:09:54,360
We don't know what will happen.

253
00:09:54,360 --> 00:09:58,740
And that is a pen
tester's favorite phrase.

254
00:09:58,740 --> 00:09:59,840
The worst that can happen

255
00:09:59,840 --> 00:10:02,110
might sound like it's the number zero.

256
00:10:02,110 --> 00:10:04,650
And in fact, we have
seen examples of this.

257
00:10:04,650 --> 00:10:07,380
The XKCD joke that you
always have to reference

258
00:10:07,380 --> 00:10:08,850
when you're talking about random numbers

259
00:10:08,850 --> 00:10:10,950
is that you ask for a random number

260
00:10:10,950 --> 00:10:13,980
and it always returns a
static value, a constant.

261
00:10:13,980 --> 00:10:17,520
That isn't quite what usually
happens, but it's not far off.

262
00:10:17,520 --> 00:10:21,710
We've seen large swaths of
zeros in a one gigabyte file

263
00:10:21,710 --> 00:10:23,810
of supposedly random numbers.

264
00:10:23,810 --> 00:10:26,100
And even in our own implementations,

265
00:10:26,100 --> 00:10:27,640
when we were trying to do it properly,

266
00:10:27,640 --> 00:10:28,650
we ended up with results

267
00:10:28,650 --> 00:10:31,350
that had large quantities
of zeros in them.

268
00:10:31,350 --> 00:10:33,820
But that's not the most insidious one.

269
00:10:33,820 --> 00:10:36,750
The worst is where you
have partial entropy.

270
00:10:36,750 --> 00:10:38,780
It looks like it's random,

271
00:10:38,780 --> 00:10:41,270
but it isn't as random
as you thought it was.

272
00:10:41,270 --> 00:10:43,370
A good example is you make a call,

273
00:10:43,370 --> 00:10:46,470
you get a 32-bit unsigned energy back.

274
00:10:46,470 --> 00:10:48,700
It has four bytes of random numbers.

275
00:10:48,700 --> 00:10:50,640
And the first call looks fine.

276
00:10:50,640 --> 00:10:53,500
You call again, it still looks okay.

277
00:10:53,500 --> 00:10:55,250
Then you call a third
time and you get zeros

278
00:10:55,250 --> 00:10:57,710
and you call a fourth time
and you still get zeros.

279
00:10:57,710 --> 00:10:59,960
But if you're not
looking carefully enough,

280
00:10:59,960 --> 00:11:02,690
you might not notice that you
got a whole bunch of zeros

281
00:11:02,690 --> 00:11:03,830
in your calls.

282
00:11:03,830 --> 00:11:06,150
This partial entropy can be really tricky

283
00:11:06,150 --> 00:11:10,130
because it substantially
reduces the actual randomness

284
00:11:10,130 --> 00:11:12,570
that you're working for, the
strength of the random number

285
00:11:12,570 --> 00:11:13,700
that you're getting.

286
00:11:13,700 --> 00:11:17,370
And it might seem like
this is not an issue,

287
00:11:17,370 --> 00:11:21,050
but this seems to happen pretty often.

288
00:11:21,050 --> 00:11:23,280
- So this is actually how
this entire research project

289
00:11:23,280 --> 00:11:24,300
got started.

290
00:11:24,300 --> 00:11:27,200
We do a lot of IoT
engagements at Bishop Fox

291
00:11:27,200 --> 00:11:29,580
under what we'd usually call
a product security review.

292
00:11:29,580 --> 00:11:32,020
We like to say that if it
breaks when you drop it,

293
00:11:32,020 --> 00:11:33,980
it's a product security review.

294
00:11:33,980 --> 00:11:35,560
And so one time we had a client

295
00:11:35,560 --> 00:11:37,920
that was developing an IoT device

296
00:11:37,920 --> 00:11:39,848
that does a lot of cryptography in it

297
00:11:39,848 --> 00:11:41,720
that was kind of a security device.

298
00:11:41,720 --> 00:11:46,140
And I was reviewing the
code and looked at the code,

299
00:11:46,140 --> 00:11:47,970
but he used a lot of a
random number generation

300
00:11:47,970 --> 00:11:50,420
in the process of doing a
lot of this cryptography

301
00:11:50,420 --> 00:11:54,000
and was curious about how it
did random number generation

302
00:11:54,000 --> 00:11:56,860
on such a tiny, low power device.

303
00:11:56,860 --> 00:11:57,693
And it turns out

304
00:11:57,693 --> 00:11:59,920
that there was a hardware
random number generator

305
00:11:59,920 --> 00:12:02,830
on the sock that our client was using.

306
00:12:02,830 --> 00:12:06,957
And on a Lark, I sort
of asked to see like,

307
00:12:06,957 --> 00:12:09,357
"Hey, what is the quality
of the random numbers

308
00:12:09,357 --> 00:12:10,280
"coming out of this thing?"

309
00:12:10,280 --> 00:12:11,680
I was sort of curious,

310
00:12:11,680 --> 00:12:16,350
I hadn't actually seen the
output of one of these hardware

311
00:12:16,350 --> 00:12:18,240
random number generators previously.

312
00:12:18,240 --> 00:12:20,543
And I didn't really expect it to be bad.

313
00:12:20,543 --> 00:12:21,376
I was thinking

314
00:12:21,376 --> 00:12:23,790
that the hardware random number generator

315
00:12:23,790 --> 00:12:27,060
surely is the gold
standard for RNG, right?

316
00:12:27,060 --> 00:12:29,550
And so when we got the results back,

317
00:12:29,550 --> 00:12:32,220
we ran it through some
statistical randomness tests

318
00:12:32,220 --> 00:12:34,033
and it failed basically all of them.

319
00:12:34,880 --> 00:12:36,500
And then upon further inspection,

320
00:12:36,500 --> 00:12:39,380
looking at the actual binary files

321
00:12:39,380 --> 00:12:42,800
and a couple of gigabytes
of output from the RNG,

322
00:12:42,800 --> 00:12:45,023
the large swaths of it were just zero.

323
00:12:46,020 --> 00:12:48,560
Surely I thought that this was a mistake,

324
00:12:48,560 --> 00:12:50,270
that this can't have been right.

325
00:12:50,270 --> 00:12:53,760
So we then embarked on
this sort of longer journey

326
00:12:53,760 --> 00:12:56,800
to investigate to see, was
it just a single buggy chip

327
00:12:56,800 --> 00:12:58,760
or was it some crazy buggy code?

328
00:12:58,760 --> 00:13:01,373
And this entire thing kind
of blew up from there.

329
00:13:02,210 --> 00:13:04,470
So you might think that
encryption keys of zero

330
00:13:04,470 --> 00:13:06,530
are about as bad as it can get, right?

331
00:13:06,530 --> 00:13:08,160
Surely it can't get worse than that.

332
00:13:08,160 --> 00:13:11,000
Well, I'd like to introduce
you to Petro's law.

333
00:13:11,000 --> 00:13:13,100
If I could have one eponymous law,

334
00:13:13,100 --> 00:13:16,000
one law named after myself,
help me out here, DEFCON,

335
00:13:16,000 --> 00:13:18,820
it would be this, "It
can always be worse."

336
00:13:18,820 --> 00:13:23,410
No matter how bad you think
it is, it can always be worse.

337
00:13:23,410 --> 00:13:26,087
So what could be worse than
encryption keys of zero?

338
00:13:26,087 --> 00:13:28,070
Uninitialized memory, that's what.

339
00:13:28,070 --> 00:13:32,080
So take these three lines
of pseudo code, for example.

340
00:13:32,080 --> 00:13:33,630
These are pseudo code of course,

341
00:13:33,630 --> 00:13:36,170
but if you just hop on to
GitHub and look around,

342
00:13:36,170 --> 00:13:38,770
you'll find lots of examples
of this in the real world.

343
00:13:38,770 --> 00:13:41,870
So you declare, but not
instantiate a number

344
00:13:41,870 --> 00:13:43,800
that you're going to
be using as your holder

345
00:13:43,800 --> 00:13:45,000
for a random number.

346
00:13:45,000 --> 00:13:46,960
This is declared on the stack.

347
00:13:46,960 --> 00:13:50,020
You then pass this to the
HAL random number function.

348
00:13:50,020 --> 00:13:52,500
However, if the HAL
function works in such a way

349
00:13:52,500 --> 00:13:57,500
that it doesn't perturb
the random number variable

350
00:13:57,670 --> 00:13:59,050
when there's an error condition,

351
00:13:59,050 --> 00:14:01,140
like it doesn't set it to zero say,

352
00:14:01,140 --> 00:14:03,910
then what will happen is when
you go to use it later on,

353
00:14:03,910 --> 00:14:06,620
the value will just be
whatever happened to be present

354
00:14:06,620 --> 00:14:09,170
in RAM prior to the call.

355
00:14:09,170 --> 00:14:11,950
So this can actually
happen quite regularly

356
00:14:11,950 --> 00:14:13,450
in the real world too.

357
00:14:13,450 --> 00:14:15,140
For instance, if you're
doing some cryptography

358
00:14:15,140 --> 00:14:17,000
with a Diffie-Hellman key exchange,

359
00:14:17,000 --> 00:14:19,080
this will involve
generating a random number

360
00:14:19,080 --> 00:14:20,660
and then sending it over the network

361
00:14:20,660 --> 00:14:22,290
to a potential adversary.

362
00:14:22,290 --> 00:14:25,770
So this is something that's
quite realistic at practice.

363
00:14:25,770 --> 00:14:28,210
- So let's talk about
some real world instances.

364
00:14:28,210 --> 00:14:31,680
In 2019, a study against over 75 million

365
00:14:31,680 --> 00:14:33,140
publicly available certificates

366
00:14:33,140 --> 00:14:37,300
found that over 435,000 of
them were vulnerable to attack.

367
00:14:37,300 --> 00:14:39,080
In the study, they specifically called out

368
00:14:39,080 --> 00:14:40,500
lightweight IoT devices

369
00:14:40,500 --> 00:14:43,260
are particularly prone to
being in low entropy states.

370
00:14:43,260 --> 00:14:45,710
And I'm not saying that our research here

371
00:14:45,710 --> 00:14:48,210
directly points to what they found,

372
00:14:48,210 --> 00:14:50,790
but it's a pretty clear link

373
00:14:50,790 --> 00:14:53,360
that when you have these many devices

374
00:14:53,360 --> 00:14:55,980
that are producing such
low entropy results,

375
00:14:55,980 --> 00:14:59,160
it seems pretty likely that
this was what they found.

376
00:14:59,160 --> 00:14:59,993
- So you might've thought

377
00:14:59,993 --> 00:15:01,380
this was gonna be a very simple case

378
00:15:01,380 --> 00:15:04,150
of just simply blame the users, right?

379
00:15:04,150 --> 00:15:08,230
Those pesky users aren't
checking the return codes

380
00:15:08,230 --> 00:15:10,530
and we just need to make sure

381
00:15:10,530 --> 00:15:12,720
that they're calling
the functions correctly.

382
00:15:12,720 --> 00:15:15,520
Well, it's actually not quite so simple.

383
00:15:15,520 --> 00:15:16,950
So take this for instance,

384
00:15:16,950 --> 00:15:19,370
this is some pseudo code at the top here.

385
00:15:19,370 --> 00:15:24,220
This is from the MediaTek
7697 documentation.

386
00:15:24,220 --> 00:15:27,650
You call the random number,
you check if the status code

387
00:15:27,650 --> 00:15:28,830
is not equal to okay

388
00:15:28,830 --> 00:15:31,290
and then you're sort of handle the error.

389
00:15:31,290 --> 00:15:34,220
Well, the handling of the
error comment right there

390
00:15:34,220 --> 00:15:35,490
is doing a lot of heavy lifting

391
00:15:35,490 --> 00:15:37,840
because when you need a random number

392
00:15:37,840 --> 00:15:41,010
for some security critical code,

393
00:15:41,010 --> 00:15:43,120
you can't just simply move forward

394
00:15:43,120 --> 00:15:44,543
without that random number.

395
00:15:44,543 --> 00:15:46,420
It's sort of important to the core thing

396
00:15:46,420 --> 00:15:48,190
that you're trying to accomplish there.

397
00:15:48,190 --> 00:15:51,220
So generally speaking, you're
kind of given two options.

398
00:15:51,220 --> 00:15:52,750
One is to spin loops.

399
00:15:52,750 --> 00:15:55,270
So you can just kind of wild loop call

400
00:15:55,270 --> 00:15:57,360
the random number generator function again

401
00:15:57,360 --> 00:16:00,610
over and over and over again
until you get an OK status.

402
00:16:00,610 --> 00:16:03,720
Basically, you're going to
use 100% CPU indefinitely,

403
00:16:03,720 --> 00:16:07,010
maybe forever if the RNG
to referral was broken,

404
00:16:07,010 --> 00:16:08,620
waiting for a result.

405
00:16:08,620 --> 00:16:09,910
That's not very good.

406
00:16:09,910 --> 00:16:12,800
But the second option is
just to quit out entirely,

407
00:16:12,800 --> 00:16:14,010
kill the entire process

408
00:16:14,010 --> 00:16:15,860
or if you're in the networking stack,

409
00:16:15,860 --> 00:16:20,830
if you're trying to make a
TLS key for TCP connection

410
00:16:20,830 --> 00:16:22,500
that you're in, then it's going to involve

411
00:16:22,500 --> 00:16:25,020
killing the entire TCP connection.

412
00:16:25,020 --> 00:16:27,130
That's not a very good option either.

413
00:16:27,130 --> 00:16:31,500
- Both are so unacceptable that
it really leaves developers

414
00:16:31,500 --> 00:16:34,580
with only option three, which is YOLO.

415
00:16:34,580 --> 00:16:36,610
You can't just spend loop

416
00:16:36,610 --> 00:16:40,360
because it'll lead to broken,
buggy, useless devices,

417
00:16:40,360 --> 00:16:43,160
same thing with quitting and
killing the entire process

418
00:16:43,160 --> 00:16:44,410
and starting over.

419
00:16:44,410 --> 00:16:46,920
This is gonna make a device
no one would want to buy.

420
00:16:46,920 --> 00:16:51,920
So we force users into
this unwinnable situation.

421
00:16:52,300 --> 00:16:55,570
RNG and IoT is fundamentally broken

422
00:16:55,570 --> 00:16:57,533
and it's not the fault of the user.

423
00:16:58,440 --> 00:17:00,810
So let's talk about the right way to RNG.

424
00:17:00,810 --> 00:17:02,620
And the right way to do this

425
00:17:02,620 --> 00:17:04,830
is to use a cryptographically secure

426
00:17:04,830 --> 00:17:06,680
pseudo random number generator.

427
00:17:06,680 --> 00:17:11,240
It's a mouthful, but a CSPRNG
has some distinct advantages.

428
00:17:11,240 --> 00:17:13,310
It never blocks execution.

429
00:17:13,310 --> 00:17:16,120
It has API calls that don't fail.

430
00:17:16,120 --> 00:17:18,140
It pulls from multiple entropy sources,

431
00:17:18,140 --> 00:17:19,240
more on that in a second,

432
00:17:19,240 --> 00:17:21,540
it always returns crypto-quality results

433
00:17:21,540 --> 00:17:23,310
due to stretching out
the amount of randomness

434
00:17:23,310 --> 00:17:24,150
that you have.

435
00:17:24,150 --> 00:17:27,760
In short, it's a much stronger system

436
00:17:27,760 --> 00:17:30,713
than just relying on a
single source of entropy.

437
00:17:32,330 --> 00:17:35,160
- The way that the CSPRNG subsystem works

438
00:17:35,160 --> 00:17:37,530
is you start with a
number of entropy sources.

439
00:17:37,530 --> 00:17:40,240
So these can include the
hardware random number generator,

440
00:17:40,240 --> 00:17:42,490
but also lots of other things
that an operating system

441
00:17:42,490 --> 00:17:44,920
might have access to
such as interrupt timing

442
00:17:44,920 --> 00:17:49,710
from various devices,
networking receive times,

443
00:17:49,710 --> 00:17:52,490
like tiny nanosecond receive times

444
00:17:52,490 --> 00:17:54,900
has a quite a bit of
entropy to the network.

445
00:17:54,900 --> 00:17:58,240
You XR them all together
into this big entropy pool.

446
00:17:58,240 --> 00:17:59,620
So it's important to know about this,

447
00:17:59,620 --> 00:18:01,940
is all of them are XR together

448
00:18:01,940 --> 00:18:03,570
so that it's not sufficient

449
00:18:03,570 --> 00:18:06,470
to break just a single one
of these entropy sources

450
00:18:06,470 --> 00:18:08,160
in order to predict the output

451
00:18:08,160 --> 00:18:09,440
of the random number generator,

452
00:18:09,440 --> 00:18:11,680
an attacker would need
to simultaneously predict

453
00:18:11,680 --> 00:18:12,630
all of them.

454
00:18:12,630 --> 00:18:13,940
So that's very strong.

455
00:18:13,940 --> 00:18:16,130
Additionally, what you can do is then read

456
00:18:16,130 --> 00:18:17,220
from the entropy pool

457
00:18:17,220 --> 00:18:20,010
by a cryptographically secure
random number generator.

458
00:18:20,010 --> 00:18:22,660
These are typically
just a hashing function,

459
00:18:22,660 --> 00:18:26,110
like a Linux kernel, just
MD5 the entropy pool.

460
00:18:26,110 --> 00:18:29,020
And then in order to produce
a more numbers afterward,

461
00:18:29,020 --> 00:18:32,320
MD5 the last output with
the entry pool itself,

462
00:18:32,320 --> 00:18:34,930
so you can kind of chain
basically key stretching

463
00:18:34,930 --> 00:18:37,920
your way out to produce
the functionally infinite

464
00:18:37,920 --> 00:18:41,860
amount of entropy from a static amount.

465
00:18:41,860 --> 00:18:46,860
Also because we can study these
hashing functions offline,

466
00:18:47,030 --> 00:18:49,840
we're very sure about the
strength of the results.

467
00:18:49,840 --> 00:18:52,240
So this also makes
remediation tricky here,

468
00:18:52,240 --> 00:18:53,530
that you see it's not as simple case

469
00:18:53,530 --> 00:18:55,620
of use zigged view should have zagged

470
00:18:55,620 --> 00:18:58,430
where there's a bug and a
piece of software somewhere

471
00:18:58,430 --> 00:19:01,770
and whoever made the software
can just kind of fix that bug,

472
00:19:01,770 --> 00:19:04,310
we patch it and move on with our lives.

473
00:19:04,310 --> 00:19:06,310
This is a case of a missing feature

474
00:19:06,310 --> 00:19:10,110
and one across the very
heterogeneous landscape of devices

475
00:19:10,110 --> 00:19:11,820
and pieces of software.

476
00:19:11,820 --> 00:19:13,920
The most likely place that
you'd implement a feature

477
00:19:13,920 --> 00:19:18,490
like this, CSPRNG subsystem,
is one of the emerging,

478
00:19:18,490 --> 00:19:21,836
the IoT operating system,
something like FreeRTOS,

479
00:19:21,836 --> 00:19:24,760
Contiki-NG, (indistinct)
or point of many others.

480
00:19:24,760 --> 00:19:26,660
And we'd highly recommend
using one of those

481
00:19:26,660 --> 00:19:30,520
if you're making a new
IoT device from scratch

482
00:19:30,520 --> 00:19:32,220
because the individual device, SDK

483
00:19:32,220 --> 00:19:34,270
is seeming like they're unlikely

484
00:19:34,270 --> 00:19:35,950
to get this kind of a feature.

485
00:19:35,950 --> 00:19:39,340
Those SDKs are usually very
thin filled with example code

486
00:19:39,340 --> 00:19:41,730
that's mostly around hardware enablement

487
00:19:41,730 --> 00:19:46,060
and not so much around making
a full device end to end.

488
00:19:46,060 --> 00:19:49,920
So yeah, this is gonna be a
tricky remediation process.

489
00:19:49,920 --> 00:19:52,900
Now this vulnerability might
be with us for some time.

490
00:19:52,900 --> 00:19:56,120
- This is how RNG and IoT
devices should work too.

491
00:19:56,120 --> 00:19:58,123
But right now it doesn't.

492
00:19:59,240 --> 00:20:02,860
And the rest of this talk
is all about convincing you

493
00:20:02,860 --> 00:20:06,230
why you really do need a CSPRNG subsystem.

494
00:20:06,230 --> 00:20:09,180
It's absolutely critical to have this.

495
00:20:09,180 --> 00:20:12,470
Now, let's talk a little bit
more about using hardware RNG

496
00:20:12,470 --> 00:20:15,420
to seed an insecure PRNG
because this'll matter a lot

497
00:20:15,420 --> 00:20:18,100
when we start moving into
the rest of this talk.

498
00:20:18,100 --> 00:20:20,390
Nobody codes from scratch.

499
00:20:20,390 --> 00:20:22,000
We were talking earlier
about blaming the users

500
00:20:22,000 --> 00:20:22,833
for doing it wrong.

501
00:20:22,833 --> 00:20:25,210
Well, if you're a user and
you're grabbing reference

502
00:20:25,210 --> 00:20:28,150
or example code and that reference library

503
00:20:28,150 --> 00:20:31,140
or that code that you're working
with has vulnerabilities,

504
00:20:31,140 --> 00:20:33,950
it propagates those vulnerabilities out.

505
00:20:33,950 --> 00:20:35,610
And one of the places this shows up

506
00:20:35,610 --> 00:20:39,610
is some IoT devices and operating
systems use the hardware,

507
00:20:39,610 --> 00:20:40,980
but only to seed

508
00:20:40,980 --> 00:20:44,680
an insecure libc pseudo-random
number generator.

509
00:20:44,680 --> 00:20:46,840
What that looks like is
you're getting a nice,

510
00:20:46,840 --> 00:20:48,240
potentially random number

511
00:20:48,240 --> 00:20:50,340
from the hardware random number generator,

512
00:20:50,340 --> 00:20:52,400
you're using that to seed libc,

513
00:20:52,400 --> 00:20:53,970
but everything after that

514
00:20:53,970 --> 00:20:57,560
is not necessarily
cryptographically secure.

515
00:20:57,560 --> 00:20:58,990
You're not really using the hardware

516
00:20:58,990 --> 00:21:00,450
even though you might think you are.

517
00:21:00,450 --> 00:21:04,130
This shows up in the MediaTek link 7697

518
00:21:04,130 --> 00:21:06,660
and specifically in the Contiki-NG.

519
00:21:06,660 --> 00:21:08,410
I'm gonna let Dan describe this

520
00:21:08,410 --> 00:21:10,410
in a demo we have for you.

521
00:21:10,410 --> 00:21:13,690
- So for this demo, we built
an IoT security camera device.

522
00:21:13,690 --> 00:21:15,350
It takes pictures every few minutes,

523
00:21:15,350 --> 00:21:16,860
just like a real security camera

524
00:21:16,860 --> 00:21:19,800
and post them to a publicly
accessible website.

525
00:21:19,800 --> 00:21:21,270
So the only thing keeping an attacker

526
00:21:21,270 --> 00:21:23,180
from being able to view your photos

527
00:21:23,180 --> 00:21:26,330
is that each file is named
in this long random file name

528
00:21:26,330 --> 00:21:28,140
here chosen by the camera.

529
00:21:28,140 --> 00:21:29,360
Now before you go thinking

530
00:21:29,360 --> 00:21:31,620
that this is unrealistically vulnerable,

531
00:21:31,620 --> 00:21:32,860
this is how discord works

532
00:21:32,860 --> 00:21:34,930
and lots of other applications like it.

533
00:21:34,930 --> 00:21:36,470
Anytime you take a photo

534
00:21:36,470 --> 00:21:38,450
and send it to a friend over discord,

535
00:21:38,450 --> 00:21:40,030
it's publicly accessible.

536
00:21:40,030 --> 00:21:41,460
The long random file name

537
00:21:41,460 --> 00:21:43,000
is the only thing that's keeping people

538
00:21:43,000 --> 00:21:44,570
from seeing your photos.

539
00:21:44,570 --> 00:21:47,790
Our device, however, is
built using Contiki-NG,

540
00:21:47,790 --> 00:21:49,970
a popular IoT operating system.

541
00:21:49,970 --> 00:21:52,660
When you call the operating
system to get a random number,

542
00:21:52,660 --> 00:21:55,150
it will use the hardware RNG on board,

543
00:21:55,150 --> 00:21:59,060
but only to seed the
insecure libc rand function.

544
00:21:59,060 --> 00:22:01,000
So we don't know what the seed is,

545
00:22:01,000 --> 00:22:03,860
but we don't have to
because we can derive it.

546
00:22:03,860 --> 00:22:06,530
So suppose one day you take
a photo with your camera

547
00:22:06,530 --> 00:22:08,180
and post it on social media.

548
00:22:08,180 --> 00:22:11,300
Wow, what a cool camera
you bought, how fun?

549
00:22:11,300 --> 00:22:12,230
But what you didn't know

550
00:22:12,230 --> 00:22:13,960
is that an attacker can use this file name

551
00:22:13,960 --> 00:22:17,100
to derive what the original
seed was that generated it.

552
00:22:17,100 --> 00:22:20,390
That's because that's how
the libc rand function works.

553
00:22:20,390 --> 00:22:23,520
Our attacker here uses ANN
Twister to find the seed.

554
00:22:23,520 --> 00:22:25,940
Once they have, they can use that seed

555
00:22:25,940 --> 00:22:29,550
to determine every past and
future value from the RNG.

556
00:22:29,550 --> 00:22:32,230
So our attacker can just
plug in some of those numbers

557
00:22:32,230 --> 00:22:34,920
back into the camera
website and view every photo

558
00:22:34,920 --> 00:22:37,000
that the camera has ever taken,

559
00:22:37,000 --> 00:22:39,050
even if they've never been shared before.

560
00:22:42,550 --> 00:22:44,410
All right, so let's have a
word about exploitability.

561
00:22:44,410 --> 00:22:46,650
This comes up a lot
anytime you give a talk

562
00:22:46,650 --> 00:22:49,560
about random number
generation or crypto stuff,

563
00:22:49,560 --> 00:22:51,570
is how exploitable is this really?

564
00:22:51,570 --> 00:22:54,400
And the answer here is very exploitable,

565
00:22:54,400 --> 00:22:56,730
but it's not going to be a canned exploit.

566
00:22:56,730 --> 00:23:00,270
You're not going to see
you're doing it wrong.pi,

567
00:23:00,270 --> 00:23:03,100
that just sort of exploits
things in the wild.

568
00:23:03,100 --> 00:23:06,250
It's gonna have to do with
the particular business logic

569
00:23:06,250 --> 00:23:08,780
of the device that you're speaking to.

570
00:23:08,780 --> 00:23:10,140
It's going to be very particular

571
00:23:10,140 --> 00:23:13,600
to individual Internet of things, devices.

572
00:23:13,600 --> 00:23:15,470
So there's not gonna be
just like a simple CVE

573
00:23:15,470 --> 00:23:18,510
that you can kind of apply
universally across the board

574
00:23:18,510 --> 00:23:20,300
to every device.

575
00:23:20,300 --> 00:23:23,930
That comes with a one asterix,
one possible exception here,

576
00:23:23,930 --> 00:23:26,290
and that's with asymmetric keys.

577
00:23:26,290 --> 00:23:27,460
You see one of the things

578
00:23:27,460 --> 00:23:31,610
that often causes the
hardware RNG functions to fail

579
00:23:31,610 --> 00:23:34,080
is calling them very
rapidly in succession.

580
00:23:34,080 --> 00:23:37,830
So you call them too quickly
and then it runs out of entropy

581
00:23:37,830 --> 00:23:39,880
and just starts giving you zeros.

582
00:23:39,880 --> 00:23:42,600
So one really common
way to make that happen

583
00:23:42,600 --> 00:23:45,500
in the real world is to make a 2048

584
00:23:45,500 --> 00:23:48,270
or 4096-bit RSA Key, right?

585
00:23:48,270 --> 00:23:50,780
In order to get that many
bits from the hardware RNG,

586
00:23:50,780 --> 00:23:53,090
you're going to need to
kind of call it in a loop

587
00:23:53,090 --> 00:23:54,920
in succession very quickly.

588
00:23:54,920 --> 00:23:58,570
And those sorts of keys are
very sensitive to low entropy.

589
00:23:58,570 --> 00:24:02,470
It's not like an AES key where
if you're missing 32-bits

590
00:24:02,470 --> 00:24:06,840
off of 128-bit key, you're
still probably fine,

591
00:24:06,840 --> 00:24:09,630
whereas with RSA keys,
that's not the case.

592
00:24:09,630 --> 00:24:11,970
In fact, there's a different
talk at this DEFCON

593
00:24:11,970 --> 00:24:12,830
going on right now

594
00:24:12,830 --> 00:24:16,800
called the Mechanics of
Compromising Low Entropy RSA Keys.

595
00:24:16,800 --> 00:24:18,260
We did not plan for this.

596
00:24:18,260 --> 00:24:20,110
That was just a thing
that sort of happened.

597
00:24:20,110 --> 00:24:21,380
So this is actually a thing

598
00:24:21,380 --> 00:24:23,390
that you can check for empirically.

599
00:24:23,390 --> 00:24:27,610
You can look at the RSA keys
coming out of IoT devices

600
00:24:27,610 --> 00:24:31,230
and see if they are of
poor quality or not.

601
00:24:31,230 --> 00:24:33,610
And that's the sort of thing you can do

602
00:24:33,610 --> 00:24:36,310
from the outside of black box as well.

603
00:24:36,310 --> 00:24:38,920
So if you're a pen tester and
you have an IoT engagement

604
00:24:38,920 --> 00:24:41,710
coming up, how you're going
to actually exploit this

605
00:24:41,710 --> 00:24:42,680
is going to depend greatly

606
00:24:42,680 --> 00:24:44,350
on whether it's a black box approach

607
00:24:44,350 --> 00:24:45,780
or whether you have the source code

608
00:24:45,780 --> 00:24:48,580
to the application of the device itself.

609
00:24:48,580 --> 00:24:51,390
As a black box approach,
it's gonna be much trickier.

610
00:24:51,390 --> 00:24:53,670
You're gonna want to look
at the output of the RNG

611
00:24:53,670 --> 00:24:56,690
from however the application is using it.

612
00:24:56,690 --> 00:24:58,080
The easiest way as we mentioned

613
00:24:58,080 --> 00:25:00,287
is using the asymmetric keys,

614
00:25:00,287 --> 00:25:02,640
the device produces an RSA key

615
00:25:02,640 --> 00:25:04,530
or a certificate of some form,

616
00:25:04,530 --> 00:25:06,640
then you can look at
those cryptographically

617
00:25:06,640 --> 00:25:09,290
to see if any known
attacks work against it.

618
00:25:09,290 --> 00:25:11,350
That's probably gonna be your best bet.

619
00:25:11,350 --> 00:25:15,260
Second though, look for any
opportunities to tax the RNG,

620
00:25:15,260 --> 00:25:17,600
so any opportunity for the attacker

621
00:25:17,600 --> 00:25:20,750
to influence how often
the RNG is being called.

622
00:25:20,750 --> 00:25:24,350
So for instance, if the device
is producing some ID value,

623
00:25:24,350 --> 00:25:27,540
and that is done at the request of a user,

624
00:25:27,540 --> 00:25:30,020
then try requesting
that very, very quickly

625
00:25:30,020 --> 00:25:32,550
and see if the numbers start becoming zero

626
00:25:32,550 --> 00:25:35,020
or if they're lower entropy.

627
00:25:35,020 --> 00:25:37,110
Other than that, trying
to actually measure

628
00:25:37,110 --> 00:25:40,980
the entropy of values that
come out of an application

629
00:25:40,980 --> 00:25:41,830
can be very hard

630
00:25:41,830 --> 00:25:44,880
because very often it's gonna
be permuted in some way,

631
00:25:44,880 --> 00:25:46,730
you're not going to get the raw hex values

632
00:25:46,730 --> 00:25:48,620
that come out of the RNG.

633
00:25:48,620 --> 00:25:51,310
Typically it's gonna be
produced as a six-digit pin

634
00:25:51,310 --> 00:25:52,143
or something like that,

635
00:25:52,143 --> 00:25:54,600
and an urge to perform
statistical analysis

636
00:25:54,600 --> 00:25:57,730
on the kinds of output of the RNG,

637
00:25:57,730 --> 00:26:00,190
you're going to need a
very large sample size,

638
00:26:00,190 --> 00:26:01,590
like a gigabyte or so.

639
00:26:01,590 --> 00:26:04,810
And in order to get a
gigabyte of six-digit pins,

640
00:26:04,810 --> 00:26:07,050
you're gonna have to make a lot of calls.

641
00:26:07,050 --> 00:26:09,500
So that might actually be
very difficult in practice.

642
00:26:09,500 --> 00:26:12,550
With source code, however,
things become a lot more visible.

643
00:26:12,550 --> 00:26:15,680
You can look into to see how
the hardware RNG is called

644
00:26:15,680 --> 00:26:18,430
and see if the return
code is being ignored.

645
00:26:18,430 --> 00:26:20,320
I hesitate to recommend

646
00:26:20,320 --> 00:26:24,530
actually implementing a
CSPRNG subsystem on your own

647
00:26:24,530 --> 00:26:27,250
at this state, since there's
a lot that can go wrong there.

648
00:26:27,250 --> 00:26:29,670
There's a lot of moving
pieces that go on there.

649
00:26:29,670 --> 00:26:31,970
There's certainly a lot
that you can mess up,

650
00:26:31,970 --> 00:26:34,593
but at least consider it
if it's critical enough.

651
00:26:35,960 --> 00:26:38,380
- Okay, you've done everything right.

652
00:26:38,380 --> 00:26:39,700
You're spin looping,

653
00:26:39,700 --> 00:26:42,700
you're blocking until the
hardware random number generator

654
00:26:42,700 --> 00:26:45,340
gives you valid non-zero results

655
00:26:45,340 --> 00:26:49,580
or validated that you've
used every library correctly.

656
00:26:49,580 --> 00:26:51,720
And that your libraries
aren't written in a bad way

657
00:26:51,720 --> 00:26:53,900
that are perhaps just seeding libc.

658
00:26:53,900 --> 00:26:56,960
You validated all of
the code you're using,

659
00:26:56,960 --> 00:26:59,700
surely you've got it right, now right?

660
00:26:59,700 --> 00:27:01,170
Nope, there's still some usage quirks.

661
00:27:01,170 --> 00:27:03,030
You're still likely going to do it wrong.

662
00:27:03,030 --> 00:27:05,110
In fact, you will do it wrong.

663
00:27:05,110 --> 00:27:06,910
This is the same level of difficulty

664
00:27:06,910 --> 00:27:08,210
as trying to write crypto code.

665
00:27:08,210 --> 00:27:09,610
And for the most part,

666
00:27:09,610 --> 00:27:11,560
we know not to try to
write our own crypto code.

667
00:27:11,560 --> 00:27:14,310
It's kind of a well-known law.

668
00:27:14,310 --> 00:27:15,840
Well, this is my law.

669
00:27:15,840 --> 00:27:19,000
My law is, don't write your own RNG code.

670
00:27:19,000 --> 00:27:20,140
You will do it wrong.

671
00:27:20,140 --> 00:27:24,510
Now, you might potentially
have some documentation.

672
00:27:24,510 --> 00:27:26,230
Maybe, if you can find it.

673
00:27:26,230 --> 00:27:28,470
On some usage quirks
you're gonna run into,

674
00:27:28,470 --> 00:27:32,593
for instance, the LPC54628
has a warning on page 1,106

675
00:27:33,770 --> 00:27:37,737
out of 1,152 that says,
"When you're calling it,

676
00:27:37,737 --> 00:27:41,387
"you have to throw out
32 results, use one,

677
00:27:41,387 --> 00:27:43,217
"and then throw out the next 32 results

678
00:27:43,217 --> 00:27:44,570
"and repeat the process."

679
00:27:44,570 --> 00:27:46,200
It is the only way to guarantee

680
00:27:46,200 --> 00:27:49,053
that you're getting proper
random numbers out of it.

681
00:27:49,930 --> 00:27:50,763
But how would you know

682
00:27:50,763 --> 00:27:53,810
if you didn't sort through
a 1,000-page document?

683
00:27:53,810 --> 00:27:57,320
And if you saw this code written down

684
00:27:57,320 --> 00:27:58,680
and you went through the comments,

685
00:27:58,680 --> 00:28:00,960
unless they specifically called
out why they were doing it,

686
00:28:00,960 --> 00:28:03,260
you would think that this was buggy code.

687
00:28:03,260 --> 00:28:04,793
This doesn't seem sane.

688
00:28:05,670 --> 00:28:09,460
You can't try writing
RNG code on your own.

689
00:28:09,460 --> 00:28:11,710
It's as bad as trying to write crypto code

690
00:28:11,710 --> 00:28:13,060
and even worse at ...

691
00:28:13,060 --> 00:28:14,760
This is absolutely a situation

692
00:28:14,760 --> 00:28:17,210
that emphasizes you can't
blame the user for this.

693
00:28:17,210 --> 00:28:19,810
There's no one that's
gonna get this right.

694
00:28:19,810 --> 00:28:21,690
One of the things we've
touched on in this talk,

695
00:28:21,690 --> 00:28:25,998
our hardware dev kits that
SoC, silicon-on-a-chip vendor

696
00:28:25,998 --> 00:28:28,840
is released to allow developers to debug

697
00:28:28,840 --> 00:28:30,620
and flash their devices.

698
00:28:30,620 --> 00:28:33,810
An IoT developer is going
to build their advice

699
00:28:33,810 --> 00:28:35,360
around an SoC.

700
00:28:35,360 --> 00:28:38,930
And they'll be writing their code in C/C++

701
00:28:38,930 --> 00:28:42,060
or something similar on a PC
and then flashing the device

702
00:28:42,060 --> 00:28:43,070
and testing it.

703
00:28:43,070 --> 00:28:45,780
The dev kits provide a
variety of different features

704
00:28:45,780 --> 00:28:47,400
for testing things

705
00:28:47,400 --> 00:28:49,520
and each vendor does it a
completely different way.

706
00:28:49,520 --> 00:28:52,230
For instance, this is a spark fund board

707
00:28:52,230 --> 00:28:55,026
that is using an NRF based SoC

708
00:28:55,026 --> 00:28:59,150
and it has a USB port for
debugging and flashing

709
00:28:59,150 --> 00:29:01,470
as well as an SD card.

710
00:29:01,470 --> 00:29:03,820
Each vendor implements it
completely differently.

711
00:29:03,820 --> 00:29:08,820
And for instance, this is an
older version of an STM32.

712
00:29:09,590 --> 00:29:12,760
This particular design
has a debugger at the top

713
00:29:12,760 --> 00:29:14,440
that can flash the device.

714
00:29:14,440 --> 00:29:18,050
The actual device you'd be
flashing is this SoC down here.

715
00:29:18,050 --> 00:29:20,420
This portion of the
board is still a dev kit.

716
00:29:20,420 --> 00:29:24,130
It has all of the
functionality in that chip

717
00:29:24,130 --> 00:29:26,970
exposed on the pens on the sides.

718
00:29:26,970 --> 00:29:28,900
But you can do some interesting things.

719
00:29:28,900 --> 00:29:33,170
You could flash this chip and
debug it with this portion.

720
00:29:33,170 --> 00:29:34,500
And when you're satisfied with the device,

721
00:29:34,500 --> 00:29:38,120
you can actually snap off
this entire upper portion.

722
00:29:38,120 --> 00:29:40,650
Sometimes you'll do this because
you'll develop your device

723
00:29:40,650 --> 00:29:43,160
and then use the dev kit itself.

724
00:29:43,160 --> 00:29:46,100
One of these designs
that we did on the side

725
00:29:46,100 --> 00:29:47,350
on my task bot project

726
00:29:47,350 --> 00:29:51,010
was with this Cyprus PSoC 5 based board.

727
00:29:51,010 --> 00:29:54,610
To flash this device, you
plug this in into a computer

728
00:29:54,610 --> 00:29:55,730
and to actually use it,

729
00:29:55,730 --> 00:29:57,640
you're using a completely
separate USB port

730
00:29:57,640 --> 00:29:58,640
on the other side.

731
00:29:58,640 --> 00:30:01,410
In our case, we connected
the actual dev kit

732
00:30:01,410 --> 00:30:02,820
to a board we manufactured.

733
00:30:02,820 --> 00:30:06,270
This was made by total in
the task bot community.

734
00:30:06,270 --> 00:30:09,600
This allows us to connect
to a video game console

735
00:30:09,600 --> 00:30:12,160
and pretend to be a
controller as in for instance.

736
00:30:12,160 --> 00:30:14,330
You can also just make your own hardware

737
00:30:14,330 --> 00:30:15,860
that doesn't have any of this

738
00:30:15,860 --> 00:30:17,810
extra debugging functionality at all.

739
00:30:17,810 --> 00:30:20,000
And that's what we did
with this task team 32 bot

740
00:30:20,000 --> 00:30:21,250
made by own source.

741
00:30:21,250 --> 00:30:23,320
Same concept, this allows
us to connect directly

742
00:30:23,320 --> 00:30:26,160
to a video game console and
pretend to be a controller.

743
00:30:26,160 --> 00:30:27,750
We just have cables that go from ethernet

744
00:30:27,750 --> 00:30:29,890
to say an Nintendo or Super Nintendo.

745
00:30:29,890 --> 00:30:32,700
But in this case, we've
taken the SoC right here

746
00:30:32,700 --> 00:30:35,010
and incorporated it into
a board of our own design.

747
00:30:35,010 --> 00:30:38,520
And that's generally what
a IoT device developer

748
00:30:38,520 --> 00:30:39,890
is going to do.

749
00:30:39,890 --> 00:30:43,140
Now, there are a variety
of different advantages

750
00:30:43,140 --> 00:30:43,973
of doing that.

751
00:30:43,973 --> 00:30:46,520
One of the boards we worked
with was this newer version

752
00:30:46,520 --> 00:30:49,100
of an STM32 that incorporated everything

753
00:30:49,100 --> 00:30:51,640
over just a single USB port.

754
00:30:51,640 --> 00:30:54,120
Rather than splitting it
out like the PSoC 5 did,

755
00:30:54,120 --> 00:30:56,390
this has a USB serial interface,

756
00:30:56,390 --> 00:30:58,850
it has debugging functionality,

757
00:30:58,850 --> 00:31:00,180
there's various different
ways that you can talk

758
00:31:00,180 --> 00:31:01,600
just over USB.

759
00:31:01,600 --> 00:31:04,710
This was really interesting to work with.

760
00:31:04,710 --> 00:31:07,830
And ultimately the bulk
of our research time

761
00:31:07,830 --> 00:31:10,000
was working with devices like these

762
00:31:10,000 --> 00:31:14,147
to try to access the hardware
RNG that was on the SoC.

763
00:31:15,610 --> 00:31:18,410
This particular device had
really good documentation.

764
00:31:18,410 --> 00:31:20,860
So a lot of credit to STMicro for that.

765
00:31:20,860 --> 00:31:21,850
They even went so far

766
00:31:21,850 --> 00:31:26,380
as to provide a proof of their randomness.

767
00:31:26,380 --> 00:31:29,250
And when we started trying
to reproduce the results,

768
00:31:29,250 --> 00:31:31,570
we actually ran into several problems.

769
00:31:31,570 --> 00:31:33,020
One of the issues we ran into

770
00:31:33,020 --> 00:31:35,200
was that even with a
reference librarian code

771
00:31:35,200 --> 00:31:38,140
and documentation, we
still ran into problems

772
00:31:38,140 --> 00:31:40,210
with not properly spend locking

773
00:31:40,210 --> 00:31:42,480
and blocking execution of the program.

774
00:31:42,480 --> 00:31:44,670
For instance, in our early tests,

775
00:31:44,670 --> 00:31:47,620
we were using something
called byte circle,

776
00:31:47,620 --> 00:31:51,250
just an analysis tool that
allowed us to throw the data

777
00:31:51,250 --> 00:31:52,700
at this program.

778
00:31:52,700 --> 00:31:55,320
And it would show the byte
distribution in a nice circle.

779
00:31:55,320 --> 00:31:59,690
So out of 255 possible
different combinations,

780
00:31:59,690 --> 00:32:03,320
what we found is that all of
the values we were getting

781
00:32:03,320 --> 00:32:05,660
were very low numbers for some reason.

782
00:32:05,660 --> 00:32:07,230
When you looked at the data in a file,

783
00:32:07,230 --> 00:32:09,290
it looked like it was properly random.

784
00:32:09,290 --> 00:32:10,700
But what we found

785
00:32:10,700 --> 00:32:14,620
was that we were actually
calling it too frequently.

786
00:32:14,620 --> 00:32:16,780
We weren't blocking properly

787
00:32:16,780 --> 00:32:19,780
and as a result, we were
calling the hardware RNG

788
00:32:19,780 --> 00:32:23,180
too frequently and starving
it, getting bad results

789
00:32:24,100 --> 00:32:25,473
out of it as a result.

790
00:32:26,700 --> 00:32:28,770
One of the other challenges we ran into

791
00:32:28,770 --> 00:32:31,570
was some of the devices
made it very difficult

792
00:32:31,570 --> 00:32:33,240
to even get the data off of.

793
00:32:33,240 --> 00:32:36,160
MediaTek could be flashed over USB,

794
00:32:36,160 --> 00:32:38,690
but to actually exfiltrate the data,

795
00:32:38,690 --> 00:32:41,240
we had to use this crazy
method over wireless

796
00:32:41,240 --> 00:32:43,260
and do various Git calls.

797
00:32:43,260 --> 00:32:45,320
It was pretty complicated,

798
00:32:45,320 --> 00:32:48,390
and really the bulk of our
research was just spending time

799
00:32:48,390 --> 00:32:51,493
trying to get accurate
numbers out of these devices.

800
00:32:52,540 --> 00:32:53,760
I bring up all this complexity

801
00:32:53,760 --> 00:32:57,093
because I wanna highlight
dwangoAC's rule as it were,

802
00:32:58,150 --> 00:33:02,010
don't try to make your
own hardware RNG code.

803
00:33:02,010 --> 00:33:03,610
It's as bad as writing crypto code.

804
00:33:03,610 --> 00:33:04,840
I've said it before,

805
00:33:04,840 --> 00:33:07,700
but I can't emphasize this point enough.

806
00:33:07,700 --> 00:33:11,070
We spent a long time trying to do this

807
00:33:11,070 --> 00:33:13,100
and still managed to
mess it up several times

808
00:33:13,100 --> 00:33:14,590
in the process.

809
00:33:14,590 --> 00:33:16,960
IoT vendors really have it rough

810
00:33:16,960 --> 00:33:19,330
because if they do release a device

811
00:33:19,330 --> 00:33:22,160
that is standalone like
this, how do you flash it

812
00:33:22,160 --> 00:33:22,993
in the field?

813
00:33:22,993 --> 00:33:24,810
Once you've released this,
you've broken off the debugger,

814
00:33:24,810 --> 00:33:27,270
there's possibly no debugger on it at all.

815
00:33:27,270 --> 00:33:28,840
There's a lot of hardware out there

816
00:33:28,840 --> 00:33:32,320
that possibly has badly
implemented hardware RNG

817
00:33:32,320 --> 00:33:34,190
that vendors simply can't fix.

818
00:33:34,190 --> 00:33:37,340
So to pen testers, this is
gonna be a perennial finding

819
00:33:37,340 --> 00:33:39,330
that will pop up for years to come

820
00:33:39,330 --> 00:33:41,070
because there's already hardware out there

821
00:33:41,070 --> 00:33:44,450
that's potentially using
insecure RNG methods

822
00:33:44,450 --> 00:33:45,883
and it's not easy to fix.

823
00:33:46,800 --> 00:33:48,050
- Okay, so let's take a look

824
00:33:48,050 --> 00:33:50,710
at what the quality of
the entropy looks like

825
00:33:50,710 --> 00:33:52,810
coming out of these hardware
random number generators

826
00:33:52,810 --> 00:33:54,870
is raw, no more bugs,

827
00:33:54,870 --> 00:33:58,010
no more silly usage quirks
and library shenanigans.

828
00:33:58,010 --> 00:33:59,240
Let's look at the actual numbers

829
00:33:59,240 --> 00:34:01,950
coming from the hardware RNGs themselves.

830
00:34:01,950 --> 00:34:03,550
Are they good, are they bad?

831
00:34:03,550 --> 00:34:06,590
So we ran a bunch of the RNGs

832
00:34:06,590 --> 00:34:07,930
through some statistical analysis

833
00:34:07,930 --> 00:34:09,693
and we've got some cool
results to show you.

834
00:34:09,693 --> 00:34:12,520
What you're looking at here is a histogram

835
00:34:12,520 --> 00:34:14,800
for the MediaTek 7697.

836
00:34:14,800 --> 00:34:17,180
That is a diagram of all bytes

837
00:34:17,180 --> 00:34:20,900
and how often they occur zero
to 255 from left to right.

838
00:34:20,900 --> 00:34:23,890
So what we should see is
basically a flat graph.

839
00:34:23,890 --> 00:34:27,500
Every byte should occur just
as often as every other byte,

840
00:34:27,500 --> 00:34:29,860
maybe with a little bit
of fuzziness at the top.

841
00:34:29,860 --> 00:34:30,900
But that's not what we see.

842
00:34:30,900 --> 00:34:33,840
What we see is this obvious
sawtooth sort of pattern

843
00:34:33,840 --> 00:34:35,490
that occurs down the line.

844
00:34:35,490 --> 00:34:38,190
And if there's two things that
don't go along well together,

845
00:34:38,190 --> 00:34:41,310
it's obvious repeating
patterns and crypto keys.

846
00:34:41,310 --> 00:34:45,080
Do you feel comfortable using
this for your encryption key?

847
00:34:45,080 --> 00:34:46,133
I for sure don't.

848
00:34:47,350 --> 00:34:52,230
Next up is the Nordic nRF528040 for this,

849
00:34:52,230 --> 00:34:54,920
there's this obvious
repeating 12-byte pattern

850
00:34:54,920 --> 00:34:57,370
of just zeros, there's a 0, 0, 0.

851
00:34:57,370 --> 00:34:59,010
It's a little bit hard to
see in the picture there.

852
00:34:59,010 --> 00:35:01,590
The highlighting doesn't
capture the third zero.

853
00:35:01,590 --> 00:35:06,500
But this happens in hacks 50
bytes and that's super bad.

854
00:35:06,500 --> 00:35:09,150
Obviously repeating
patterns of any kind is bad,

855
00:35:09,150 --> 00:35:13,080
but especially fully zeroed bytes

856
00:35:13,080 --> 00:35:15,010
coming from the Nordic board

857
00:35:15,010 --> 00:35:16,930
was something that we saw
that kind of stood out

858
00:35:16,930 --> 00:35:17,763
and made it fail

859
00:35:17,763 --> 00:35:20,943
all of these statistical
randomness tests there forward.

860
00:35:22,000 --> 00:35:25,110
This example was so
egregious and so peculiar

861
00:35:25,110 --> 00:35:27,200
that we thought for sure
for a really long time

862
00:35:27,200 --> 00:35:29,200
that it was just our
instrumentation that was at fault,

863
00:35:29,200 --> 00:35:31,550
but we don't think it
is for three reasons.

864
00:35:31,550 --> 00:35:35,330
One, we spent a really long
time investigating our code,

865
00:35:35,330 --> 00:35:37,540
trying to figure out how this
could possibly be happening

866
00:35:37,540 --> 00:35:39,740
from it and never figured out how.

867
00:35:39,740 --> 00:35:42,410
But two, it's a 12-bit pattern,

868
00:35:42,410 --> 00:35:45,960
which is very weird if it was
exactly one byte or no byte,

869
00:35:45,960 --> 00:35:47,480
then perhaps you'd think

870
00:35:47,480 --> 00:35:49,940
that was just a Knoll terminated string

871
00:35:49,940 --> 00:35:52,130
was kind of getting copied
around incorrectly somewhere.

872
00:35:52,130 --> 00:35:55,130
But exactly 12-bits is really curious.

873
00:35:55,130 --> 00:35:59,200
And also the amount
that jumps by 50 bytes.

874
00:35:59,200 --> 00:36:00,470
Sometimes it'll actually jump

875
00:36:00,470 --> 00:36:02,540
by a little bit more than 50 bytes

876
00:36:02,540 --> 00:36:04,410
which kind of offsets things a little bit.

877
00:36:04,410 --> 00:36:06,050
So there'll be maybe 80 bytes

878
00:36:06,050 --> 00:36:07,230
or something like that in hex.

879
00:36:07,230 --> 00:36:10,640
And then it'll kind of continue
on the pattern from there,

880
00:36:10,640 --> 00:36:13,000
which also wouldn't really make sense

881
00:36:14,010 --> 00:36:18,300
as an inconsistency in
our instrumentation.

882
00:36:18,300 --> 00:36:22,200
- So aside from just a
distribution of values

883
00:36:22,200 --> 00:36:24,480
and aside from just
taking all of the bytes

884
00:36:24,480 --> 00:36:25,690
and putting them on a graph

885
00:36:25,690 --> 00:36:27,080
and seeing how frequently they are,

886
00:36:27,080 --> 00:36:29,300
you can do a lot more
statistical analysis.

887
00:36:29,300 --> 00:36:31,550
There's a lot of tools out
there including dieharder

888
00:36:31,550 --> 00:36:34,010
that you can use on large datasets

889
00:36:34,010 --> 00:36:35,880
to see if there are repeating patterns.

890
00:36:35,880 --> 00:36:37,360
And we relied on this a lot

891
00:36:37,360 --> 00:36:40,930
when we were doing our own
implementation on the STM32.

892
00:36:40,930 --> 00:36:43,430
When we first started, we
were failing all of the tests

893
00:36:43,430 --> 00:36:46,660
and it took us a while
to get the code right.

894
00:36:46,660 --> 00:36:49,610
We thought we were spent
looping properly, we weren't.

895
00:36:49,610 --> 00:36:51,960
It turns out it's very
difficult to do this properly

896
00:36:51,960 --> 00:36:54,290
even when you think you
know what you're doing.

897
00:36:54,290 --> 00:36:56,810
Once we got through
all of the other tests,

898
00:36:56,810 --> 00:36:59,070
we still had one of the dieharder tests

899
00:36:59,070 --> 00:37:00,070
that continued to fail,

900
00:37:00,070 --> 00:37:02,173
which was the RGB minimum distance test.

901
00:37:03,060 --> 00:37:04,220
- So the minimum distance test,

902
00:37:04,220 --> 00:37:06,850
what it's doing is it takes
a bunch of random numbers,

903
00:37:06,850 --> 00:37:08,420
interprets them as integers,

904
00:37:08,420 --> 00:37:10,800
and plots them in end dimensional space,

905
00:37:10,800 --> 00:37:13,360
and then calculates
using a simple algorithm

906
00:37:13,360 --> 00:37:14,610
what the minimum distance

907
00:37:14,610 --> 00:37:16,980
between any two of those points are.

908
00:37:16,980 --> 00:37:19,430
And it should fall within
expected parameters.

909
00:37:19,430 --> 00:37:22,670
What this is doing really
is it's checking for repeats

910
00:37:22,670 --> 00:37:24,710
or nearly repeated values

911
00:37:24,710 --> 00:37:28,530
since any repeats would
cause the minimum distance

912
00:37:28,530 --> 00:37:31,700
to become smaller than
it normally should be.

913
00:37:31,700 --> 00:37:33,620
So what you're seeing
here in terms of a failure

914
00:37:33,620 --> 00:37:35,680
is a P value of exactly zero,

915
00:37:35,680 --> 00:37:37,210
which means that it's very confident

916
00:37:37,210 --> 00:37:39,850
that this should not
have occurred randomly

917
00:37:39,850 --> 00:37:42,080
or the chances of it
having occurred naturally

918
00:37:42,080 --> 00:37:44,000
is very small.

919
00:37:44,000 --> 00:37:45,370
At the same time, you're watching this,

920
00:37:45,370 --> 00:37:47,470
we'll be releasing our code that gathered

921
00:37:47,470 --> 00:37:50,390
and analyzed the hardware
RNG entropy itself.

922
00:37:50,390 --> 00:37:51,670
It's nothing terribly special,

923
00:37:51,670 --> 00:37:53,240
but it took a long time to get right

924
00:37:53,240 --> 00:37:56,220
and working across a
bunch of IoT dev ports.

925
00:37:56,220 --> 00:37:58,270
And while we don't think
that there's any errors

926
00:37:58,270 --> 00:38:00,420
that would have impacted the results,

927
00:38:00,420 --> 00:38:02,690
consider that even if it
turns out that there's a bug

928
00:38:02,690 --> 00:38:04,240
in our code, what does it say

929
00:38:04,240 --> 00:38:06,800
that two computer security
experts spent months

930
00:38:06,800 --> 00:38:08,760
studying and analyzing our RNGs

931
00:38:08,760 --> 00:38:11,480
and still couldn't get
them to work properly?

932
00:38:11,480 --> 00:38:12,510
And what does that say

933
00:38:12,510 --> 00:38:15,173
about the state of IoT
security more broadly?

934
00:38:16,260 --> 00:38:18,560
- Okay, so what are the
conclusions we've come to

935
00:38:18,560 --> 00:38:20,950
after talking through all of this?

936
00:38:20,950 --> 00:38:24,170
The first is that this affects
the entire IoT industry.

937
00:38:24,170 --> 00:38:26,530
It's not a single vendor,
it's not a single device.

938
00:38:26,530 --> 00:38:31,530
It's not a single particular
quirk, this is widespread.

939
00:38:32,000 --> 00:38:35,720
And if you take nothing
else out of this talk,

940
00:38:35,720 --> 00:38:37,240
the point we really wanna make

941
00:38:37,240 --> 00:38:41,400
is that the IoT world
needs a CSPRNG subsystem.

942
00:38:41,400 --> 00:38:43,700
This can't be fixed by
just changing documentation

943
00:38:43,700 --> 00:38:45,210
and blaming users.

944
00:38:45,210 --> 00:38:49,100
You really need RNG
code that is well-vetted

945
00:38:49,100 --> 00:38:51,010
and you should consider it dangerous

946
00:38:51,010 --> 00:38:53,510
to write it on your own,
it's just like crypto code.

947
00:38:53,510 --> 00:38:55,010
And also you should never use entropy

948
00:38:55,010 --> 00:38:56,060
directly from the hardware.

949
00:38:56,060 --> 00:38:57,770
You don't know how strong
or weak it might be

950
00:38:57,770 --> 00:38:58,870
as we just showed you.

951
00:39:00,140 --> 00:39:02,280
- Okay, so what can you
actually do about this?

952
00:39:02,280 --> 00:39:04,660
Well, it depends on what camp you're in.

953
00:39:04,660 --> 00:39:07,000
If you're a device owner,
keep an eye out for updates,

954
00:39:07,000 --> 00:39:08,820
IoT devices aren't the best in general

955
00:39:08,820 --> 00:39:10,450
with software updates.

956
00:39:10,450 --> 00:39:12,640
And you're gonna wanna make
sure that yours is ready

957
00:39:12,640 --> 00:39:14,400
to take them when they're available.

958
00:39:14,400 --> 00:39:17,400
IoT device developers,
we highly recommend using

959
00:39:17,400 --> 00:39:19,720
one of the emerging IoT operating systems.

960
00:39:19,720 --> 00:39:22,360
We don't have a strong preference
for one versus the other

961
00:39:22,360 --> 00:39:23,193
at this point.

962
00:39:23,193 --> 00:39:25,280
But if you're baking a
new device from scratch

963
00:39:25,280 --> 00:39:27,110
or maybe even just updating a current one,

964
00:39:27,110 --> 00:39:30,320
we highly recommend using
those rather than writing raw C

965
00:39:30,320 --> 00:39:31,670
on the bare metal yourself.

966
00:39:32,700 --> 00:39:34,410
If you're an IoT device manufacturer

967
00:39:34,410 --> 00:39:36,530
or an iOS developer themselves,

968
00:39:36,530 --> 00:39:39,460
implement one of these CSPRNG subsystems,

969
00:39:39,460 --> 00:39:40,950
that's the only secure way to do it,

970
00:39:40,950 --> 00:39:43,133
there isn't a way to get around it.

971
00:39:43,133 --> 00:39:44,480
You might even consider deprecating

972
00:39:44,480 --> 00:39:46,350
or straight up disallowing users

973
00:39:46,350 --> 00:39:49,420
from using the hardware RNG raw itself.

974
00:39:49,420 --> 00:39:50,600
And if you're a pen tester,

975
00:39:50,600 --> 00:39:51,630
keep an eye out for this

976
00:39:51,630 --> 00:39:54,630
because it's gonna be a perennial
finding for years to come.

977
00:39:56,250 --> 00:39:59,410
- I am Allan Cecil(dwangoAC.)

978
00:39:59,410 --> 00:40:01,923
- I'm Dan Petro and thanks a lot.

