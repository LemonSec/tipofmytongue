1
00:00:00,740 --> 00:00:02,690
- Hi and welcome to
Instrument and Find Out

2
00:00:02,690 --> 00:00:06,430
Writing Parasitic tracers
for High Level Languages.

3
00:00:06,430 --> 00:00:08,350
I'm Jeff and I'm at NCC group

4
00:00:08,350 --> 00:00:09,230
I like to do,

5
00:00:09,230 --> 00:00:11,050
hack on stuff and do various things

6
00:00:11,050 --> 00:00:12,540
for the purpose of this talk.

7
00:00:12,540 --> 00:00:16,550
That means programs, languages,
runtimes, memory, and bytes.

8
00:00:16,550 --> 00:00:17,550
But first up, a notice.

9
00:00:17,550 --> 00:00:19,340
By viewing this presentation,
you agree to indemnify

10
00:00:19,340 --> 00:00:20,700
and hold harmless the
presenter in the event

11
00:00:20,700 --> 00:00:22,210
you decide to take any of his advice

12
00:00:22,210 --> 00:00:24,270
and find yourself unable to
sleep at four in the morning

13
00:00:24,270 --> 00:00:26,427
due to "language demons".

14
00:00:27,690 --> 00:00:30,610
So just as an outline of
the structure of this talk,

15
00:00:30,610 --> 00:00:32,430
I'm gonna talk about
kind of the background

16
00:00:32,430 --> 00:00:33,704
of what lead me to this work,

17
00:00:33,704 --> 00:00:36,840
what parasitic tracers are,

18
00:00:36,840 --> 00:00:38,210
how to kind of design them

19
00:00:38,210 --> 00:00:41,563
for tracing high level language runtimes,

20
00:00:42,510 --> 00:00:45,570
looking at Ruby as some
sort of case study,

21
00:00:45,570 --> 00:00:48,490
and then some concluding thoughts.

22
00:00:48,490 --> 00:00:50,140
So first about me,

23
00:00:50,140 --> 00:00:51,380
I've done a fair amount of work with

24
00:00:51,380 --> 00:00:53,840
the dynamic instrumentation and tracing

25
00:00:53,840 --> 00:00:56,300
from a Java Bytecode,
various stuff in Android,

26
00:00:56,300 --> 00:01:00,633
Linux, both user land and
in the kernel with eBPF.

27
00:01:02,470 --> 00:01:05,560
Generally I do a lot of this
stuff mostly for reversing

28
00:01:05,560 --> 00:01:07,920
and learning stuff and also to kind of

29
00:01:07,920 --> 00:01:12,110
script up existing things
to do other things.

30
00:01:12,110 --> 00:01:14,530
So for dynamic instrumentation,

31
00:01:14,530 --> 00:01:16,230
just as a quick refresher,

32
00:01:16,230 --> 00:01:17,300
this generally means

33
00:01:17,300 --> 00:01:21,010
function hooking or
instruction instrumentation.

34
00:01:21,010 --> 00:01:22,270
The latter of which mostly means

35
00:01:22,270 --> 00:01:25,830
that you kind of modify
bytecode or assembly

36
00:01:25,830 --> 00:01:27,220
to do

37
00:01:27,220 --> 00:01:30,530
be different by coder assembly
to do something different.

38
00:01:30,530 --> 00:01:32,330
Whereas function hooking generally

39
00:01:32,330 --> 00:01:35,060
you are doing something that hijacks

40
00:01:35,060 --> 00:01:38,000
control flow directly
to go somewhere else.

41
00:01:38,000 --> 00:01:40,290
Dynamic tracing can refer to

42
00:01:40,290 --> 00:01:41,900
dynamically enabling or disabling

43
00:01:41,900 --> 00:01:43,320
existing logging functionality,

44
00:01:43,320 --> 00:01:45,360
but for our purposes this mostly means

45
00:01:45,360 --> 00:01:47,150
adding enhanced logging functionality

46
00:01:47,150 --> 00:01:49,050
that wasn't there before.

47
00:01:49,050 --> 00:01:54,050
I've also been recently doing
tracing with Frida for Ruby

48
00:01:54,080 --> 00:01:56,390
which is what this talk is about.

49
00:01:56,390 --> 00:01:59,800
So some background on Ruby and myself.

50
00:01:59,800 --> 00:02:02,640
Little while back, I had to do some

51
00:02:02,640 --> 00:02:04,670
Ruby bytecode transformation stuff

52
00:02:04,670 --> 00:02:08,380
and convert more modern
bytecode to an older one,

53
00:02:08,380 --> 00:02:11,730
an older format so
translate newer op codes

54
00:02:11,730 --> 00:02:14,300
into equivalent older ones.

55
00:02:14,300 --> 00:02:17,290
So that a decompiler that
only knew the older format

56
00:02:17,290 --> 00:02:18,170
would work.

57
00:02:18,170 --> 00:02:20,820
And that worked quite
nicely for me at the time.

58
00:02:20,820 --> 00:02:24,050
More recently a colleague
and I were looking

59
00:02:24,050 --> 00:02:26,760
at Ruby'sdRuby protocol.

60
00:02:26,760 --> 00:02:29,420
We were writing a scanner for it in Ruby

61
00:02:29,420 --> 00:02:30,263
of all things.

62
00:02:31,320 --> 00:02:34,013
We gave a talk in this in
North Sec earlier this year.

63
00:02:35,710 --> 00:02:37,620
There were some weird issues that came up

64
00:02:37,620 --> 00:02:40,720
and I spent a lot of time debugging this

65
00:02:40,720 --> 00:02:42,630
and going through the
Ruby internal source code

66
00:02:42,630 --> 00:02:46,340
and see to find out you
don't want to call IO#read

67
00:02:46,340 --> 00:02:47,300
on a Socket object.

68
00:02:47,300 --> 00:02:49,200
Instead you just want to call receive.

69
00:02:50,260 --> 00:02:53,500
This lead me to start writing
this parasitic low level

70
00:02:53,500 --> 00:02:54,780
Ruby tracer.

71
00:02:54,780 --> 00:02:57,700
So what are parasitic tracers?

72
00:02:57,700 --> 00:02:58,940
Well what are tracers?

73
00:02:58,940 --> 00:03:01,210
So a tracer is an enhanced logger that

74
00:03:01,210 --> 00:03:03,360
basically dumps everything you might want

75
00:03:03,360 --> 00:03:06,330
about program state
running code et cetera.

76
00:03:06,330 --> 00:03:08,000
And a parasite is a highly-specialized

77
00:03:08,000 --> 00:03:10,685
unwanted organism that symbiotically lives

78
00:03:10,685 --> 00:03:14,890
on or off of inside of another organism

79
00:03:14,890 --> 00:03:16,400
that is completely adapted to.

80
00:03:16,400 --> 00:03:19,080
So a parasitic tracer is a
combination of these two.

81
00:03:19,080 --> 00:03:21,630
It's basically a tracer
that's specially adapted

82
00:03:21,630 --> 00:03:24,330
to he target process,
that it kind of hooks onto

83
00:03:24,330 --> 00:03:25,500
and injects itself into.

84
00:03:25,500 --> 00:03:27,570
And makes use of internal functionality

85
00:03:27,570 --> 00:03:30,940
that wasn't really intended
to be you know, accessible.

86
00:03:30,940 --> 00:03:33,910
So the tracing of this part
is just kind of a goal.

87
00:03:33,910 --> 00:03:36,750
I want to write a tracer for
Ruby to better understand it,

88
00:03:36,750 --> 00:03:40,000
but the parasitic part is more
of an implementation detail.

89
00:03:40,000 --> 00:03:41,330
Chances are, you've done this if

90
00:03:41,330 --> 00:03:44,483
you've ever used LD_PRELOAD
to inject code into something.

91
00:03:45,340 --> 00:03:46,680
So why would you write these things?

92
00:03:46,680 --> 00:03:49,100
Well to get a better understanding of

93
00:03:49,100 --> 00:03:50,620
where the higher level extractions

94
00:03:50,620 --> 00:03:52,310
meet the lower level implementations

95
00:03:52,310 --> 00:03:54,270
in say runtimes and things.

96
00:03:54,270 --> 00:03:56,520
So for reversing, or debugging,

97
00:03:56,520 --> 00:03:58,335
or just plain performance analysis.

98
00:03:58,335 --> 00:04:01,120
You could also be writing
one of these things

99
00:04:01,120 --> 00:04:03,700
mostly to avoid having to maintain

100
00:04:03,700 --> 00:04:05,020
a fork of the actual code base

101
00:04:05,020 --> 00:04:08,040
if you kind of want to maintain
the tracer out of tree.

102
00:04:08,040 --> 00:04:09,990
Because you can just do
it on the process itself

103
00:04:09,990 --> 00:04:14,600
and not have to recompile it
against the whole code base.

104
00:04:14,600 --> 00:04:17,510
So some examples of these
parasitic tracers would be

105
00:04:17,510 --> 00:04:19,560
Frida's Java Bridge API

106
00:04:19,560 --> 00:04:21,440
which is actually really two of them.

107
00:04:21,440 --> 00:04:24,420
One for Android and
one for the JVM itself.

108
00:04:24,420 --> 00:04:26,500
They provide basically an API

109
00:04:26,500 --> 00:04:30,640
for hooking into higher
level Java operations,

110
00:04:30,640 --> 00:04:32,840
but in ways that weren't really intended

111
00:04:32,840 --> 00:04:34,070
to be allowed by the platform.

112
00:04:34,070 --> 00:04:36,837
So in Android it's totally
hooking the runtime

113
00:04:36,837 --> 00:04:41,237
and for the JVM it's using some of the

114
00:04:41,237 --> 00:04:43,060
JVM instrumentation APIs,

115
00:04:43,060 --> 00:04:45,820
but it's definitely doing stuff
that doesn't involve those

116
00:04:45,820 --> 00:04:46,653
in weird ways.

117
00:04:46,653 --> 00:04:50,260
And so whereas a normal vanilla Java agent

118
00:04:50,260 --> 00:04:52,783
that uses those things
wouldn't really qualify

119
00:04:52,783 --> 00:04:55,640
as a parasitic tracer because it's

120
00:04:55,640 --> 00:04:58,510
using kind of public APIs
specifically for this purpose.

121
00:04:58,510 --> 00:05:01,253
The way the Frida does it is
a little bit more invasive.

122
00:05:02,090 --> 00:05:03,740
But let's just say that
if you're crawling around

123
00:05:03,740 --> 00:05:05,970
the memory of a process or
intercepting its syscalls,

124
00:05:05,970 --> 00:05:07,680
chances are you just have a tracer.

125
00:05:07,680 --> 00:05:09,910
But, you know like S trace.

126
00:05:09,910 --> 00:05:12,360
But if you are hooking around in functions

127
00:05:12,360 --> 00:05:13,580
inside the process itself

128
00:05:13,580 --> 00:05:16,350
or really calling functions
from inside the process

129
00:05:16,350 --> 00:05:18,280
then you're doing some parasitic stuff.

130
00:05:18,280 --> 00:05:19,730
So let's talk about designing these things

131
00:05:19,730 --> 00:05:21,450
for high-level language runtimes.

132
00:05:21,450 --> 00:05:22,994
So first some prereqs,

133
00:05:22,994 --> 00:05:25,410
you're gonna need some means to actually

134
00:05:25,410 --> 00:05:26,869
hook the code or instrument it.

135
00:05:26,869 --> 00:05:29,750
Generally, ideally, one that allows you to

136
00:05:29,750 --> 00:05:32,152
kind of remove those hooks
or re-add them at runtime.

137
00:05:32,152 --> 00:05:34,320
You could do this with a
debugger and breakpoints

138
00:05:34,320 --> 00:05:35,800
especially a scripted debugger.

139
00:05:35,800 --> 00:05:37,610
You could do this with and
instrumentation toolkit

140
00:05:37,610 --> 00:05:40,160
like Frida which is what
I generally do these days.

141
00:05:41,540 --> 00:05:44,477
You also need a way to
invoke existing functionality

142
00:05:44,477 --> 00:05:46,740
that's in that code, in that process.

143
00:05:46,740 --> 00:05:48,780
So generally speaking you do that

144
00:05:48,780 --> 00:05:50,670
with a debugger or with Frida.

145
00:05:50,670 --> 00:05:53,610
The debugger would be something
like the expression syntax

146
00:05:53,610 --> 00:05:55,763
for calling functions.

147
00:05:57,600 --> 00:06:00,370
But the thing is , you need
to know what you're gonna call

148
00:06:00,370 --> 00:06:04,500
So the hierarchy of how you
wanna be preferring things

149
00:06:04,500 --> 00:06:07,640
is ideally public APIs
that aren't going to change

150
00:06:07,640 --> 00:06:08,950
all that often.

151
00:06:08,950 --> 00:06:11,620
Then internal APIs with symbols.

152
00:06:11,620 --> 00:06:13,440
Then internal APIs that don't have symbols

153
00:06:13,440 --> 00:06:16,100
but that you can get
handles on fairly easily.

154
00:06:16,100 --> 00:06:19,380
Say if the pointers to them
are passed into other functions

155
00:06:19,380 --> 00:06:21,070
you can just catch them there.

156
00:06:21,070 --> 00:06:22,560
Then after that, you're
probably just gonna want to

157
00:06:22,560 --> 00:06:25,340
opt for re-implementing
stuff locally yourself.

158
00:06:25,340 --> 00:06:27,500
And then finally all the
way at the end, you know,

159
00:06:27,500 --> 00:06:30,320
if you need to reuse
existing code that's inside

160
00:06:30,320 --> 00:06:33,600
the process that you can't
get a find a good way to find.

161
00:06:33,600 --> 00:06:36,240
You might need to search
for bytecode sequences

162
00:06:36,240 --> 00:06:37,140
and match on them.

163
00:06:38,170 --> 00:06:41,780
But moving on, the first
step to owning a target

164
00:06:41,780 --> 00:06:44,310
is recon and that is the first step to

165
00:06:44,310 --> 00:06:45,967
designing a parasitic tracer.

166
00:06:45,967 --> 00:06:47,220
And you're going to need to be

167
00:06:47,220 --> 00:06:49,330
doing some reverse engineering.

168
00:06:49,330 --> 00:06:51,146
Really to understand the
internals of what is you're

169
00:06:51,146 --> 00:06:53,070
gonna be mucking around with.

170
00:06:53,070 --> 00:06:55,113
And as you do so, you'll learn more.

171
00:06:56,520 --> 00:06:58,410
But you may actually have sources

172
00:06:58,410 --> 00:07:01,950
like I was looking into Ruby, C Ruby.

173
00:07:01,950 --> 00:07:03,770
But you still need to know
what's actually going on

174
00:07:03,770 --> 00:07:05,700
in native level especially with the way

175
00:07:05,700 --> 00:07:07,960
that your instrumentation itself works

176
00:07:07,960 --> 00:07:10,840
because at that point C
doesn't really matter anymore.

177
00:07:10,840 --> 00:07:13,440
And optimizations can elide out functions

178
00:07:13,440 --> 00:07:16,840
or can lead to weird situations where

179
00:07:16,840 --> 00:07:19,440
garbage values are sent to functions

180
00:07:19,440 --> 00:07:21,090
that don't process on them anyway

181
00:07:21,090 --> 00:07:24,640
and we need to be careful
when handling those inputs

182
00:07:24,640 --> 00:07:25,720
stuff like that.

183
00:07:25,720 --> 00:07:28,770
And then additionally just
all these kind of runtimes

184
00:07:28,770 --> 00:07:31,270
heavily rely on like super implementation

185
00:07:31,270 --> 00:07:32,500
defined behavior.

186
00:07:32,500 --> 00:07:33,690
And so you need to be really careful

187
00:07:33,690 --> 00:07:35,810
about how you're
interacting with their code

188
00:07:35,810 --> 00:07:37,340
from your code.

189
00:07:37,340 --> 00:07:39,720
After that you're gonna wanna identify

190
00:07:39,720 --> 00:07:41,380
all of the things you're
gonna wanna hook on

191
00:07:41,380 --> 00:07:44,490
or call into to build up all of your,

192
00:07:44,490 --> 00:07:46,540
whatever it is you're going to get out of

193
00:07:46,540 --> 00:07:49,117
the runtime or the language.

194
00:07:49,117 --> 00:07:52,430
And then next is actually
doing all of the hooking

195
00:07:52,430 --> 00:07:54,120
and calling of those things.

196
00:07:54,120 --> 00:07:55,060
You're gonna hook all the functionality.

197
00:07:55,060 --> 00:07:56,550
You're gonna extract all of the relevance

198
00:07:56,550 --> 00:07:58,020
data that you can get.

199
00:07:58,020 --> 00:07:59,590
You're gonna start invoking you know,

200
00:07:59,590 --> 00:08:01,950
function calls that are in the thing

201
00:08:01,950 --> 00:08:05,090
to get other pieces of
data out of it, et cetera.

202
00:08:05,090 --> 00:08:07,440
And then after that you're gonna kind of

203
00:08:07,440 --> 00:08:09,840
bring it all together
and orchestrate all that

204
00:08:09,840 --> 00:08:12,270
in what I like to call puppeteering

205
00:08:12,270 --> 00:08:14,330
to bring together all your hooks,

206
00:08:14,330 --> 00:08:16,410
have them coordinate with one another.

207
00:08:16,410 --> 00:08:19,040
Possibly be managed by some
sort of injected thread

208
00:08:19,040 --> 00:08:20,093
or whatnot.

209
00:08:21,100 --> 00:08:24,240
But at this point, you're
mostly building up from there

210
00:08:24,240 --> 00:08:27,250
to have better interop
between your own hooks

211
00:08:27,250 --> 00:08:30,810
and better interop between
the actual platform

212
00:08:30,810 --> 00:08:32,490
you are messing around with.

213
00:08:32,490 --> 00:08:34,320
So in this case for me it was Frida

214
00:08:34,320 --> 00:08:35,220
which is Javascript .

215
00:08:35,220 --> 00:08:39,470
So basically a Javascript to
Ruby bridged more or less.

216
00:08:39,470 --> 00:08:42,345
So ideally you start small and build big.

217
00:08:42,345 --> 00:08:46,090
You compose together a larger set of hooks

218
00:08:46,090 --> 00:08:48,260
from a smaller set of modular pieces.

219
00:08:48,260 --> 00:08:50,430
You're in a good position to do this

220
00:08:50,430 --> 00:08:52,600
because you're hooking
on to a full program

221
00:08:52,600 --> 00:08:54,620
that already exists and runs on its own.

222
00:08:54,620 --> 00:08:56,470
So mostly you just need to make sure

223
00:08:56,470 --> 00:08:58,200
that you don't break it
with what you're doing

224
00:08:58,200 --> 00:08:59,480
and injecting into it.

225
00:08:59,480 --> 00:09:00,940
But other than that,
the thing will continue

226
00:09:00,940 --> 00:09:02,473
to run on it's own just fine.

227
00:09:03,687 --> 00:09:07,138
So the next thing about
this layering stuff

228
00:09:07,138 --> 00:09:10,490
is that you can take advantage of

229
00:09:10,490 --> 00:09:14,430
you know, layering on abstract calls

230
00:09:14,430 --> 00:09:17,250
that are implemented with
versions specific behaviors.

231
00:09:17,250 --> 00:09:20,240
So for example, if you have a pointer

232
00:09:20,240 --> 00:09:23,918
to obstruct between two
different versions of the binary

233
00:09:23,918 --> 00:09:26,280
the field you want that's
inside of that strucks

234
00:09:26,280 --> 00:09:27,610
is at different offsets

235
00:09:27,610 --> 00:09:29,120
you need to have some functionality

236
00:09:29,120 --> 00:09:29,980
to be able to handle that.

237
00:09:29,980 --> 00:09:32,780
But the pointer to the start
of it is still the same.

238
00:09:32,780 --> 00:09:35,350
So you can do that from
per-version implementations

239
00:09:35,350 --> 00:09:36,740
or version-based switches

240
00:09:36,740 --> 00:09:39,560
kind of like ifdefs or both.

241
00:09:39,560 --> 00:09:40,700
But let's talk about Ruby.

242
00:09:40,700 --> 00:09:44,840
So Ruby is a scripting
language, that's right.

243
00:09:44,840 --> 00:09:46,247
The most interesting thing about Ruby

244
00:09:46,247 --> 00:09:47,768
is that it's super object oriented

245
00:09:47,768 --> 00:09:49,950
and every time you try to access something

246
00:09:49,950 --> 00:09:52,590
on an object that's actually a method call

247
00:09:52,590 --> 00:09:55,140
and all the method calls are basically

248
00:09:55,140 --> 00:09:58,123
handled via sending messages.

249
00:09:59,850 --> 00:10:01,283
Ruby is super feature full,

250
00:10:02,200 --> 00:10:05,110
but it doesn't have
really and good low level

251
00:10:05,110 --> 00:10:06,920
introspection tracing capabilities.

252
00:10:06,920 --> 00:10:09,133
It does have this thing called TracePoint

253
00:10:09,133 --> 00:10:11,830
which is an API for
various events that go on

254
00:10:11,830 --> 00:10:13,080
as Ruby executes.

255
00:10:13,080 --> 00:10:15,380
But it can't really
intercept method arguments

256
00:10:15,380 --> 00:10:17,510
or native function parameters.

257
00:10:17,510 --> 00:10:20,660
It can't really provide
information on bytecode execution.

258
00:10:20,660 --> 00:10:23,420
And it doesn't really
provide all that useful

259
00:10:23,420 --> 00:10:25,420
information from any time
you're switching back and forth

260
00:10:25,420 --> 00:10:26,983
between Ruby and native code.

261
00:10:27,870 --> 00:10:30,080
This is mostly an artifact,

262
00:10:30,080 --> 00:10:31,500
with the fact that Ruby is a language

263
00:10:31,500 --> 00:10:33,920
and CRuby is an implementation and so

264
00:10:33,920 --> 00:10:35,918
this bytecode stuff,
this lower level stuff

265
00:10:35,918 --> 00:10:38,350
are kind of implementation details.

266
00:10:38,350 --> 00:10:41,170
And this API needs to
theoretically work across

267
00:10:41,170 --> 00:10:43,530
multiple different Ruby implementations.

268
00:10:43,530 --> 00:10:46,240
But really the CRuby implementation

269
00:10:46,240 --> 00:10:49,190
should have better tracing stuff

270
00:10:49,190 --> 00:10:51,720
given that it basically
functions similarly to Java..

271
00:10:51,720 --> 00:10:54,190
And Java has a very well defined

272
00:10:54,190 --> 00:10:57,390
and extensive API for instrumentation.

273
00:10:57,390 --> 00:10:59,610
So I wrote this thing called ruby-trace

274
00:10:59,610 --> 00:11:02,980
which is a Frida-based CLI
tool for instrumenting Ruby

275
00:11:02,980 --> 00:11:05,370
and kind of dumping
everything that goes on

276
00:11:05,370 --> 00:11:07,150
as it executes.

277
00:11:07,150 --> 00:11:09,636
So it hooks all the opcodes.

278
00:11:09,636 --> 00:11:12,450
The interesting thing about
that is the implementation

279
00:11:12,450 --> 00:11:15,130
of the opcode handlers are kind of all

280
00:11:15,130 --> 00:11:17,320
a bunch of labeled go-to spots

281
00:11:17,320 --> 00:11:18,350
and a giant state machine.

282
00:11:18,350 --> 00:11:19,410
They're not really their own function

283
00:11:19,410 --> 00:11:21,300
so they don't have your standard

284
00:11:21,300 --> 00:11:23,643
calling convention preludes.

285
00:11:25,594 --> 00:11:27,260
And then separately Ruby has a bunch of

286
00:11:27,260 --> 00:11:30,420
C functions to call Ruby methods

287
00:11:30,420 --> 00:11:33,360
And do a bunch of stuff
about handling the methods.

288
00:11:33,360 --> 00:11:34,930
And tying them to objects,

289
00:11:34,930 --> 00:11:36,277
both native code to Ruby

290
00:11:36,277 --> 00:11:38,570
and Ruby back to native code calls.

291
00:11:38,570 --> 00:11:40,190
So I hook all that stuff

292
00:11:40,190 --> 00:11:43,990
and I hook all the transition
between Ruby and native code.

293
00:11:43,990 --> 00:11:47,360
And then hook those native
functions and et cetera.

294
00:11:47,360 --> 00:11:50,650
And then separately it supports

295
00:11:50,650 --> 00:11:52,870
kind of hooking into Ruby's internal

296
00:11:52,870 --> 00:11:55,250
exception handling mechanisms.

297
00:11:55,250 --> 00:11:57,510
What is pulls out of that is basically

298
00:11:57,510 --> 00:11:59,280
all the arguments of all kinds

299
00:11:59,280 --> 00:12:02,033
even the special internal
ones for the opcodes.

300
00:12:03,150 --> 00:12:05,930
And then it basically,
Ruby inspects everything

301
00:12:05,930 --> 00:12:07,860
which is a stringification.

302
00:12:07,860 --> 00:12:09,453
Kind of like repr and python.

303
00:12:10,450 --> 00:12:12,680
The one problem with that is many times

304
00:12:12,680 --> 00:12:14,490
values aren't fully initialized

305
00:12:14,490 --> 00:12:17,960
or with the Ruby VM itself
isn't fully initialized.

306
00:12:17,960 --> 00:12:21,030
You need to be very careful
about how to try to call things

307
00:12:21,030 --> 00:12:22,440
on things that aren't fully initialized.

308
00:12:22,440 --> 00:12:24,240
So it handles a lot of that.

309
00:12:24,240 --> 00:12:26,400
Trying to be very careful
about when it's safe

310
00:12:26,400 --> 00:12:29,490
to actually send the inspect method over

311
00:12:29,490 --> 00:12:31,870
and doing alternative fallback approaches

312
00:12:31,870 --> 00:12:33,430
when it can't.

313
00:12:33,430 --> 00:12:35,244
It dumps out the bytecode whenever

314
00:12:35,244 --> 00:12:37,790
it sees something like a method or

315
00:12:37,790 --> 00:12:39,163
a block being defined.

316
00:12:40,370 --> 00:12:42,117
It dumps all the return values for opcodes

317
00:12:42,117 --> 00:12:43,860
in the native functions it hooks.

318
00:12:43,860 --> 00:12:45,750
It gets all sorts of other metadata

319
00:12:45,750 --> 00:12:49,630
and takes all sorts of things
to make it human-readable.

320
00:12:49,630 --> 00:12:52,880
It supports Ruby 2.6-3.0 and I assume

321
00:12:52,880 --> 00:12:55,560
once 3.1 comes out it
won't be too much effort

322
00:12:55,560 --> 00:12:57,763
to get it working on 3.1.

323
00:12:59,210 --> 00:13:01,430
I have a sort of generic implementation

324
00:13:01,430 --> 00:13:03,970
with a couple of versions
specific behaviors

325
00:13:03,970 --> 00:13:06,580
and switches and then
for separate lower level,

326
00:13:06,580 --> 00:13:10,560
anytime I need to deal
with Ruby structs from C

327
00:13:10,560 --> 00:13:13,420
I just have a version and
specific set of structs

328
00:13:13,420 --> 00:13:15,240
to pull fields from essentially

329
00:13:15,240 --> 00:13:18,330
using Frida's C module API.

330
00:13:18,330 --> 00:13:19,660
So other cool things that it does

331
00:13:19,660 --> 00:13:21,500
is it actually makes use
of the TracePoint API

332
00:13:21,500 --> 00:13:23,360
but not in the way you would expect.

333
00:13:23,360 --> 00:13:26,550
It's just the TracePoint
API has a very good way

334
00:13:26,550 --> 00:13:29,790
of controlling whether or not it's enabled

335
00:13:29,790 --> 00:13:31,440
based on various aspects.

336
00:13:31,440 --> 00:13:35,810
And so whenever the
TracePoint API is enabled

337
00:13:35,810 --> 00:13:36,790
that turns it on.

338
00:13:36,790 --> 00:13:39,410
And whenever it's turned
off, it turns it off.

339
00:13:39,410 --> 00:13:41,310
It gives you fine-grained control to

340
00:13:41,310 --> 00:13:44,193
very minutely trace certain
pieces of execution.

341
00:13:45,320 --> 00:13:48,640
I have a bunch of test cases
for various bytecode sequences

342
00:13:48,640 --> 00:13:51,660
that seem to cover a
greater span of more detail

343
00:13:51,660 --> 00:13:53,740
of hedge cases than Ruby's own

344
00:13:53,740 --> 00:13:56,600
internal opcode test suite.

345
00:13:56,600 --> 00:13:59,000
Although not necessarily
some of the other ones.

346
00:14:00,020 --> 00:14:02,800
I also implement support
for dead Ruby opcodes

347
00:14:02,800 --> 00:14:06,362
that shouldn't even exist
anymore for some reason.

348
00:14:06,362 --> 00:14:09,790
But basically RubyTrace
is kind of like its own

349
00:14:09,790 --> 00:14:12,830
CRuby bytecode interpreter
because of how it works.

350
00:14:12,830 --> 00:14:17,463
So as a demo, let's just
switch to this view.

351
00:14:18,400 --> 00:14:21,310
So I have some Ruby code here

352
00:14:21,310 --> 00:14:24,000
that defines TracePoint, tracer

353
00:14:24,000 --> 00:14:25,560
and then in the middle of this big block

354
00:14:25,560 --> 00:14:29,020
is actually a stringified
block of this Ruby code

355
00:14:29,020 --> 00:14:32,400
With this Foo method and
then some calls into it.

356
00:14:32,400 --> 00:14:36,210
And then it redefines
symbol to redefine its

357
00:14:36,210 --> 00:14:38,140
triple equal operator, then calls a lot of

358
00:14:38,140 --> 00:14:39,760
those same things over again.

359
00:14:39,760 --> 00:14:43,990
And then it compiles
that code from the string

360
00:14:43,990 --> 00:14:47,423
and the evaluates it under the tracing.

361
00:14:49,000 --> 00:14:52,160
So in this case the
tracer that's being used

362
00:14:52,160 --> 00:14:52,993
doesn't really do anything.

363
00:14:52,993 --> 00:14:55,300
So when we run this code it
just kind of spits things out.

364
00:14:55,300 --> 00:14:58,420
The more interesting thing
is that the not found:wat

365
00:14:58,420 --> 00:15:01,580
on the left side gets
replaced with a symbol

366
00:15:01,580 --> 00:15:03,240
on the right side
because that triple equal

367
00:15:03,240 --> 00:15:05,740
when it hits the
comparison for the symbol.

368
00:15:05,740 --> 00:15:09,840
It instantly matches
stuff so the wat string

369
00:15:09,840 --> 00:15:11,860
will on the last case
will hit the symbol check

370
00:15:11,860 --> 00:15:13,860
against foo, symbol foo

371
00:15:13,860 --> 00:15:15,310
and that will just pass.

372
00:15:15,310 --> 00:15:20,250
So now let's run this under

373
00:15:23,648 --> 00:15:24,481
RubyTrace.

374
00:15:30,870 --> 00:15:34,410
And basically RubyTrace dumps
out a whole bunch of stuff.

375
00:15:34,410 --> 00:15:36,940
One of the first things you can see is

376
00:15:36,940 --> 00:15:41,080
that the instruction sequence
part from that compilation.

377
00:15:41,080 --> 00:15:42,450
You see it there and then you see

378
00:15:42,450 --> 00:15:44,350
the call to the eval on it.

379
00:15:44,350 --> 00:15:45,840
And then where inside of that,

380
00:15:45,840 --> 00:15:47,790
the first thing that
happens is the foo method

381
00:15:47,790 --> 00:15:48,623
is defined.

382
00:15:48,623 --> 00:15:51,864
And so it dumps out all of the bytecode

383
00:15:51,864 --> 00:15:54,230
of that foo method.

384
00:15:54,230 --> 00:15:56,153
We can see a bunch of values from it.

385
00:15:57,130 --> 00:16:01,563
Next it adds that to the class it's in.

386
00:16:02,530 --> 00:16:06,120
Then we see the first call into foo

387
00:16:06,120 --> 00:16:07,373
from the hello string.

388
00:16:08,800 --> 00:16:11,930
And then we run through
that check operation.

389
00:16:11,930 --> 00:16:14,160
So the first thing that happens we see

390
00:16:14,160 --> 00:16:17,160
is a call into this opt case dispatch

391
00:16:17,160 --> 00:16:20,670
which is a special case bytecode generated

392
00:16:20,670 --> 00:16:24,150
for switches that don't
have special types in them,

393
00:16:24,150 --> 00:16:25,420
only simple types.

394
00:16:25,420 --> 00:16:28,290
And basically it optimizes
so that all of the cases

395
00:16:28,290 --> 00:16:32,300
get added into a single Ruby hash

396
00:16:32,300 --> 00:16:35,500
and then it checks if the
value is a member of the hash.

397
00:16:35,500 --> 00:16:37,180
But it first checks a bunch of things

398
00:16:37,180 --> 00:16:39,210
about the object coming in to
make sure it's a simple type

399
00:16:39,210 --> 00:16:41,980
that the comparison would
work in the first place.

400
00:16:41,980 --> 00:16:45,660
So in this case hello
is the simple string.

401
00:16:45,660 --> 00:16:47,879
It's in there. It takes the hello path.

402
00:16:47,879 --> 00:16:49,800
We move on.

403
00:16:49,800 --> 00:16:51,300
The next thing is we have one.

404
00:16:51,300 --> 00:16:55,630
It takes the one path and so forth.

405
00:16:55,630 --> 00:17:00,630
But then we eventually see
this big decimal 3.0 value

406
00:17:01,070 --> 00:17:03,440
which you'll see represented variously

407
00:17:03,440 --> 00:17:06,050
as 0.3E1.

408
00:17:06,050 --> 00:17:11,050
And that thing will get passed into foo.

409
00:17:11,440 --> 00:17:13,600
And the problem is, is that because it is

410
00:17:13,600 --> 00:17:17,560
not a simple type. It will fall through.

411
00:17:17,560 --> 00:17:19,970
And the way that this works
is that the optimization

412
00:17:19,970 --> 00:17:21,430
is just a quick check first.

413
00:17:21,430 --> 00:17:24,640
And it is kind of a guard on top of what

414
00:17:24,640 --> 00:17:26,800
the rest of the switch
implementation will be,

415
00:17:26,800 --> 00:17:28,880
which is the series of
subsequent if else checks.

416
00:17:28,880 --> 00:17:30,400
That's just how Ruby does it.

417
00:17:30,400 --> 00:17:32,000
And so it falls through

418
00:17:32,000 --> 00:17:34,650
and then starts doing
all of the if else's.

419
00:17:34,650 --> 00:17:36,050
It doesn't match like a string,

420
00:17:36,050 --> 00:17:37,850
it doesn't match a whole bunch of stuff.

421
00:17:37,850 --> 00:17:41,690
And then eventually we see a bunch of

422
00:17:41,690 --> 00:17:44,080
operations where it's
trying to compare against

423
00:17:44,080 --> 00:17:46,430
the float value and the big int has to

424
00:17:46,430 --> 00:17:50,010
do a bunch of math conversions
to get the stuff out

425
00:17:50,010 --> 00:17:51,300
for the comparison.

426
00:17:51,300 --> 00:17:54,070
And so then it eventually
does the comparison

427
00:17:54,070 --> 00:17:56,480
and sees that, you know, it

428
00:17:56,480 --> 00:17:59,490
0.3E1 is equal to 3.0 float.

429
00:17:59,490 --> 00:18:01,900
And so then it check match passes.

430
00:18:01,900 --> 00:18:03,780
That's the comparison for the branch.

431
00:18:03,780 --> 00:18:05,330
And then I jumps to the code that is

432
00:18:05,330 --> 00:18:07,220
part of a segment of the branch.

433
00:18:07,220 --> 00:18:11,020
We continue doing all this
for the rest of the values.

434
00:18:11,020 --> 00:18:12,830
We see in this case the string wat

435
00:18:13,680 --> 00:18:16,690
doesn't match anything so
it ends up in the else path.

436
00:18:16,690 --> 00:18:18,190
But it was a simple type so

437
00:18:18,190 --> 00:18:20,573
it actually goes to
the else path directly.

438
00:18:21,940 --> 00:18:25,910
And then we see the code
that redefines symbols,

439
00:18:25,910 --> 00:18:27,570
triple equal method.

440
00:18:27,570 --> 00:18:28,720
And from this point on,

441
00:18:28,720 --> 00:18:30,270
things are gonna get a little bit weird.

442
00:18:30,270 --> 00:18:33,676
So we start seeing that all
of these opt case dispatches

443
00:18:33,676 --> 00:18:36,900
end up falling through
because triple equals

444
00:18:36,900 --> 00:18:37,990
been redefined.

445
00:18:37,990 --> 00:18:39,880
And so basically there's a short circuit

446
00:18:39,880 --> 00:18:41,797
in the implementation where Ruby says,

447
00:18:41,797 --> 00:18:45,300
"well if any of these core
equals things has been redefined

448
00:18:45,300 --> 00:18:48,120
on any of the core types, such as symbol,

449
00:18:48,120 --> 00:18:50,370
it just can't bother to
do any comparisons anymore

450
00:18:50,370 --> 00:18:51,720
one way or the other."

451
00:18:51,720 --> 00:18:53,750
And it's faster to just give up

452
00:18:53,750 --> 00:18:55,680
and have them go through all of the checks

453
00:18:55,680 --> 00:18:56,810
one at a time.

454
00:18:56,810 --> 00:18:59,440
And so we run through this
all one after another.

455
00:18:59,440 --> 00:19:02,143
And then we get to the
end with all the values.

456
00:19:02,980 --> 00:19:06,230
And they get percolated up from

457
00:19:07,162 --> 00:19:09,083
all the functionality.

458
00:19:09,960 --> 00:19:11,990
So Future Work.

459
00:19:11,990 --> 00:19:13,970
I have to implement support for Ractors,

460
00:19:13,970 --> 00:19:18,113
Ruby's new multi VM in
process concurrency model.

461
00:19:19,010 --> 00:19:21,180
Right now I'm just
relying on the one global

462
00:19:21,180 --> 00:19:23,293
Ruby VM internal of the process.

463
00:19:24,400 --> 00:19:25,680
And then just generally
keeping up with the

464
00:19:25,680 --> 00:19:26,740
Ruby versions.

465
00:19:26,740 --> 00:19:30,490
The code will be available
here at our github repo

466
00:19:30,490 --> 00:19:32,420
shortly after this presentation airs.

467
00:19:32,420 --> 00:19:35,810
But in conclusion, it's been
really fun working on this.

468
00:19:35,810 --> 00:19:37,730
Although it's been pretty tiring

469
00:19:37,730 --> 00:19:39,870
because of all the tiring
that goes on with Ruby

470
00:19:39,870 --> 00:19:41,840
and various other things that can fail

471
00:19:41,840 --> 00:19:43,980
when you're messing
around in it's insides.

472
00:19:43,980 --> 00:19:45,450
But I think that all of these techniques

473
00:19:45,450 --> 00:19:47,380
pretty much apply to other

474
00:19:47,380 --> 00:19:49,860
high-level languages and runtimes.

475
00:19:49,860 --> 00:19:53,950
Some good examples are Python,
Node, Golang, and Haskell.

476
00:19:53,950 --> 00:19:56,140
And I really think people
should be trying to

477
00:19:56,140 --> 00:19:57,430
build some of these things.

478
00:19:57,430 --> 00:20:00,373
So to paraphrase Arlo Guthrie,

479
00:20:04,597 --> 00:20:06,580
"You know, if one person,

480
00:20:06,580 --> 00:20:08,470
just one person does it,

481
00:20:08,470 --> 00:20:10,760
they may think he's really sick.

482
00:20:10,760 --> 00:20:12,060
And three people do it, three,

483
00:20:12,060 --> 00:20:15,400
can you imagine three people
writing parasitic tracers?

484
00:20:15,400 --> 00:20:17,770
They may think it's an organization.

485
00:20:17,770 --> 00:20:19,960
And can you, can you imagine 50 people,

486
00:20:19,960 --> 00:20:22,510
I said 50 people, writing these tracers?

487
00:20:22,510 --> 00:20:25,130
Friends, they may think it's a movement."

488
00:20:25,130 --> 00:20:26,313
And that's what it is.

489
00:20:27,350 --> 00:20:29,410
I'd like to thank Addison,
my partner in crime

490
00:20:29,410 --> 00:20:31,490
on the DRuby stuff

491
00:20:31,490 --> 00:20:32,980
that lead us down this rabbit hole

492
00:20:32,980 --> 00:20:34,410
for me doing this work.

493
00:20:34,410 --> 00:20:36,060
And a wise man once said,

494
00:20:36,060 --> 00:20:38,870
you can't hide secrets
from the future using math.

495
00:20:38,870 --> 00:20:40,400
I believe that is true, but I also believe

496
00:20:40,400 --> 00:20:43,900
it is true that you simply
can't hide from the future.

497
00:20:43,900 --> 00:20:47,100
I would take questions,
but this is a recording

498
00:20:47,100 --> 00:20:50,370
so there are no questions to be had.

499
00:20:50,370 --> 00:20:55,290
So instead I will answer a question about

500
00:20:55,290 --> 00:20:59,940
why on my intro page
I used an image from a

501
00:20:59,940 --> 00:21:02,840
Pokemon crystal and not Pokemon Ruby.

502
00:21:02,840 --> 00:21:04,713
Well to answer that question.

503
00:21:05,610 --> 00:21:07,370
I do not like Ruby lang.

504
00:21:07,370 --> 00:21:09,560
I do not like its yuppy gang.

505
00:21:09,560 --> 00:21:11,630
I do not like its simple keys.

506
00:21:11,630 --> 00:21:14,170
I do not like its optional parentheses.

507
00:21:14,170 --> 00:21:16,160
I do not like its method send.

508
00:21:16,160 --> 00:21:18,170
I do not like its begin and end.

509
00:21:18,170 --> 00:21:20,200
I do not like its magic verbs.

510
00:21:20,200 --> 00:21:22,630
I do not like its methodic key words.

511
00:21:22,630 --> 00:21:24,950
I do not like its IO dot read.

512
00:21:24,950 --> 00:21:27,300
I do not like its lackluster speed.

513
00:21:27,300 --> 00:21:29,620
I do not like its deal open jit.

514
00:21:29,620 --> 00:21:32,350
I do not like strong params permit.

515
00:21:32,350 --> 00:21:34,450
I do not like its if unless.

516
00:21:34,450 --> 00:21:36,920
I do not like its dependency mess.

517
00:21:36,920 --> 00:21:38,940
I do not like its case in when.

518
00:21:38,940 --> 00:21:41,510
I do not like its require middle men.

519
00:21:41,510 --> 00:21:44,030
I do not like its polymorphism.

520
00:21:44,030 --> 00:21:46,540
I do not like its object fanaticism.

521
00:21:46,540 --> 00:21:50,029
Its object nil gives me pain.

522
00:21:50,029 --> 00:21:53,330
That Ruby lang is profane.

523
00:21:53,330 --> 00:21:54,163
Thank you.

