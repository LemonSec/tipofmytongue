1
00:00:07,120 --> 00:00:08,020
- [Presenter] Hello everyone.

2
00:00:08,020 --> 00:00:10,950
Another year to see you
in this special mode.

3
00:00:10,950 --> 00:00:12,940
Welcome to our talk, "Caught You:

4
00:00:12,940 --> 00:00:16,457
Reveal and Exploit IPC
Logic Bugs Inside Apple."

5
00:00:17,770 --> 00:00:20,630
First, a self-introduction.

6
00:00:20,630 --> 00:00:23,510
Zhipeng Huo is a senior
security researcher.

7
00:00:23,510 --> 00:00:26,993
He's a member of EcoSec Team
at Tencent Security Xuanwu Lab.

8
00:00:27,940 --> 00:00:30,750
His research focuses on macOS, iOS,

9
00:00:30,750 --> 00:00:33,190
and Windows platform security.

10
00:00:33,190 --> 00:00:35,320
He has found and reported
many vulnerability

11
00:00:35,320 --> 00:00:37,560
to Apple and Microsoft.

12
00:00:37,560 --> 00:00:40,170
He's a speaker of Black Hat Europe 2018,

13
00:00:40,170 --> 00:00:41,313
and DEF CON 28.

14
00:00:43,490 --> 00:00:46,410
Yuebin Sun is a co-author
of this presentation.

15
00:00:46,410 --> 00:00:49,750
He's a senior security
researcher of EcoSec Team.

16
00:00:49,750 --> 00:00:53,533
His focus is on macOS and
iOS platform security.

17
00:00:55,450 --> 00:00:58,740
Chuanda Ding is also a
co-author of this presentation.

18
00:00:58,740 --> 00:01:00,000
He leads the EcoSec Team

19
00:01:00,000 --> 00:01:02,940
and is a speaker of Black Hat Europe 2018,

20
00:01:02,940 --> 00:01:05,563
DEF CON China 2018, and DEF CON 28.

21
00:01:07,860 --> 00:01:09,890
This is the agenda of our talk.

22
00:01:09,890 --> 00:01:13,453
First, an introduction to
IPC and logic vulnerability.

23
00:01:14,950 --> 00:01:19,030
Then we talk about the IPC
mechanisms on Apple platforms.

24
00:01:19,030 --> 00:01:20,820
After that, we will share some interesting

25
00:01:20,820 --> 00:01:23,820
logic vulnerabilities we found
in Preferences and App Store.

26
00:01:24,810 --> 00:01:26,510
And finally, we'll give a conclusion

27
00:01:26,510 --> 00:01:29,333
on IPC logic vulnerabilities
on Apple platform.

28
00:01:31,080 --> 00:01:33,950
Let's talk about some
background knowledge.

29
00:01:33,950 --> 00:01:35,120
What is IPC?

30
00:01:35,120 --> 00:01:38,210
IPC means Inter-Process Communication.

31
00:01:38,210 --> 00:01:41,750
It's a set of techniques
provided by the operating system.

32
00:01:41,750 --> 00:01:43,620
It allows stand-alone processes

33
00:01:43,620 --> 00:01:45,480
to communicate with each other.

34
00:01:45,480 --> 00:01:48,930
The communication could be
about process notifying,

35
00:01:48,930 --> 00:01:50,460
and then the process about some event

36
00:01:50,460 --> 00:01:53,833
or transferring of data
from one process to another.

37
00:01:54,750 --> 00:01:58,650
The processes involved in
IPC could have two roles,

38
00:01:58,650 --> 00:02:00,440
client and server.

39
00:02:00,440 --> 00:02:02,010
The client request the server,

40
00:02:02,010 --> 00:02:05,060
and server may respond
to the client if needed.

41
00:02:05,060 --> 00:02:07,750
The OS kernel provides the IPC channel

42
00:02:07,750 --> 00:02:10,130
to allow the client and server processes

43
00:02:10,130 --> 00:02:12,693
to send or reply to messages.

44
00:02:13,940 --> 00:02:17,800
There are three advantages
that IPC provides.

45
00:02:17,800 --> 00:02:20,033
First, modularity.

46
00:02:21,070 --> 00:02:23,740
Modern software is more and more complex.

47
00:02:23,740 --> 00:02:25,800
With the help of IPC,

48
00:02:25,800 --> 00:02:28,320
developers could divide the complex system

49
00:02:28,320 --> 00:02:30,620
into separated modules

50
00:02:30,620 --> 00:02:32,950
and reduce the complexity of software

51
00:02:32,950 --> 00:02:34,933
and avoids re-inventing the wheel.

52
00:02:36,420 --> 00:02:39,200
Second, stability.

53
00:02:39,200 --> 00:02:42,200
If all data and code
are inside one process,

54
00:02:42,200 --> 00:02:45,440
a little error would probably
crash the entire system.

55
00:02:45,440 --> 00:02:49,010
By dividing a complex system
into separated modules,

56
00:02:49,010 --> 00:02:51,780
a module crash would not
crash the entire system,

57
00:02:51,780 --> 00:02:53,543
which makes the system more stable.

58
00:02:54,430 --> 00:02:57,636
And third, privilege separation.

59
00:02:57,636 --> 00:03:01,830
With IPC, developers not
just separate functionality,

60
00:03:01,830 --> 00:03:04,190
but also separate the privilege,

61
00:03:04,190 --> 00:03:08,970
isolating sensitive operations
into separated processes,

62
00:03:08,970 --> 00:03:11,470
giving the processes the least privilege.

63
00:03:11,470 --> 00:03:14,030
Then if part of the system is hacked,

64
00:03:14,030 --> 00:03:16,850
it will not compromise the entire system,

65
00:03:16,850 --> 00:03:19,563
and increase the security
and protection from attacks.

66
00:03:21,230 --> 00:03:24,243
Let's see an example of IPC usage.

67
00:03:25,190 --> 00:03:26,110
The web browser.

68
00:03:26,110 --> 00:03:28,950
It's nearly impossible to
build a rendering engine

69
00:03:28,950 --> 00:03:31,390
that never crashes, and hence,

70
00:03:31,390 --> 00:03:34,190
it's also nearly impossible
to build a rendering engine

71
00:03:34,190 --> 00:03:36,410
that's perfectly secure.

72
00:03:36,410 --> 00:03:38,940
To solve this issue, modern browser

73
00:03:38,940 --> 00:03:42,220
mostly use a multi-process architecture.

74
00:03:42,220 --> 00:03:44,990
For example, it may divide the components

75
00:03:44,990 --> 00:03:48,223
into rendering process
and networking process.

76
00:03:49,100 --> 00:03:51,770
So different processes of browser

77
00:03:51,770 --> 00:03:54,550
would communicate with
each other through IPC.

78
00:03:54,550 --> 00:03:56,370
And all of them also needs to request

79
00:03:56,370 --> 00:03:58,943
the operating system's system service.

80
00:04:00,050 --> 00:04:03,183
You may not feel it,
but IPC is everywhere.

81
00:04:05,680 --> 00:04:08,980
The using of IPC divides the entire system

82
00:04:08,980 --> 00:04:11,410
into separated processes.

83
00:04:11,410 --> 00:04:14,950
Different processes have
different privileges.

84
00:04:14,950 --> 00:04:18,757
Process may have low
privilege or high privilege.

85
00:04:18,757 --> 00:04:22,033
A process may be sandboxed
or non-sandboxed.

86
00:04:23,150 --> 00:04:25,080
There is a security boundary between them

87
00:04:25,080 --> 00:04:26,743
and IPC may break it.

88
00:04:28,060 --> 00:04:31,610
IPC is a bridge between
different processes.

89
00:04:31,610 --> 00:04:34,613
So it is also a window
between different privileges.

90
00:04:35,510 --> 00:04:38,300
IPC vulnerability is a
key to high privilege.

91
00:04:38,300 --> 00:04:41,000
So it is one of the most valuable targets

92
00:04:41,000 --> 00:04:42,613
for privilege escalation.

93
00:04:44,300 --> 00:04:46,680
Logic vulnerability is different

94
00:04:46,680 --> 00:04:49,250
from memory corruption vulnerability.

95
00:04:49,250 --> 00:04:51,130
We do not want to play
with memory corruption

96
00:04:51,130 --> 00:04:53,220
since they are boring to us.

97
00:04:53,220 --> 00:04:55,023
We like to find logic flaws.

98
00:04:56,630 --> 00:04:58,920
There are two kinds of logic flaws.

99
00:04:58,920 --> 00:05:01,650
One that is introduced
during design phase,

100
00:05:01,650 --> 00:05:05,290
and one is introduced
during implementation phase.

101
00:05:05,290 --> 00:05:06,970
In fact, most of the time,

102
00:05:06,970 --> 00:05:08,880
abusing existing features

103
00:05:08,880 --> 00:05:11,563
are enough for us to
compromise the entire system.

104
00:05:14,481 --> 00:05:17,210
Apple's new MacBook and iPad Pro

105
00:05:17,210 --> 00:05:21,080
have been combined with
the new Apple M1 chip.

106
00:05:21,080 --> 00:05:24,420
The new chip brings many
additional security features

107
00:05:24,420 --> 00:05:27,080
such as system integrity, data protection,

108
00:05:27,080 --> 00:05:30,390
and Pointer Authentication Code.

109
00:05:30,390 --> 00:05:32,713
The Pointer Authentication Code or PAC

110
00:05:33,900 --> 00:05:36,070
is a hardware-level security mechanism

111
00:05:36,070 --> 00:05:37,600
against the memory bug,

112
00:05:37,600 --> 00:05:40,443
which makes memory games much harder.

113
00:05:42,880 --> 00:05:45,970
Logic vulnerability is not
playing with memory corruption

114
00:05:45,970 --> 00:05:47,453
and may not be affected.

115
00:05:48,730 --> 00:05:52,993
So is the Spring of logic
vulnerability finally coming?

116
00:05:56,160 --> 00:05:58,820
Before introducing the
IPC logic vulnerabilities,

117
00:05:58,820 --> 00:06:00,940
let's start with some
fundamental knowledge

118
00:06:00,940 --> 00:06:03,780
of IPC on Apple platforms.

119
00:06:03,780 --> 00:06:08,780
Apple IPC has different
specific implementation methods.

120
00:06:08,800 --> 00:06:12,520
This includes shared files,
shared memory, and sockets,

121
00:06:12,520 --> 00:06:15,023
which other systems supports as well.

122
00:06:16,400 --> 00:06:19,450
There are also some that
are unique to Apple,

123
00:06:19,450 --> 00:06:22,670
such as Mach messages, Apple events,

124
00:06:22,670 --> 00:06:24,973
distributed notifications, and so on.

125
00:06:26,060 --> 00:06:29,390
However, the latest and the most advanced

126
00:06:29,390 --> 00:06:31,280
IPC methods on Apple platform

127
00:06:31,280 --> 00:06:34,743
currently are XPC and NSXPC.

128
00:06:36,900 --> 00:06:39,733
Apple implements them
on top of Mach message.

129
00:06:41,130 --> 00:06:43,460
Next, we will walk you
through the principle

130
00:06:43,460 --> 00:06:44,923
and usages of them.

131
00:06:46,320 --> 00:06:48,600
Mach port is an endpoint

132
00:06:48,600 --> 00:06:51,550
of unidirectional communication channel,

133
00:06:51,550 --> 00:06:53,900
which is one of the fundamental parameters

134
00:06:53,900 --> 00:06:55,983
of XNU kernel for messaging.

135
00:06:57,090 --> 00:06:59,993
Messages can be sent or received from it.

136
00:07:00,910 --> 00:07:05,310
Users of Mach port never
actually sees the port itself,

137
00:07:05,310 --> 00:07:08,260
but access it through
a type of indirection

138
00:07:08,260 --> 00:07:09,900
called Port Rights.

139
00:07:09,900 --> 00:07:13,700
The sender of the message can
send the message to Mach port

140
00:07:13,700 --> 00:07:15,460
through the SEND right.

141
00:07:15,460 --> 00:07:19,220
The receiver of the message
can get the received message

142
00:07:19,220 --> 00:07:21,370
the Mach port or through
the RECEIVE right.

143
00:07:25,240 --> 00:07:28,020
The message transmitted
through the Mach port

144
00:07:28,020 --> 00:07:29,383
is called Mach message.

145
00:07:30,840 --> 00:07:32,540
The system trap level API,

146
00:07:32,540 --> 00:07:35,020
mach_msg and mach_msg_overwrite,

147
00:07:35,020 --> 00:07:39,030
can be used to send or
receive Mach messages.

148
00:07:39,030 --> 00:07:41,240
The structure contains a header,

149
00:07:41,240 --> 00:07:43,360
optional complex data,

150
00:07:43,360 --> 00:07:44,473
and message buffer.

151
00:07:45,670 --> 00:07:50,070
The header contains the sender
and receiver of the message.

152
00:07:50,070 --> 00:07:53,900
The optional complex data
part can transfer complex data

153
00:07:53,900 --> 00:07:57,423
such as a file handle,
shared memory, and Mach port.

154
00:07:58,640 --> 00:08:01,403
Message buffer is used
to send binary data.

155
00:08:02,490 --> 00:08:05,670
Mach message is low level and powerful,

156
00:08:05,670 --> 00:08:08,623
but it is also ancient
and poorly documented.

157
00:08:10,000 --> 00:08:11,520
Developers needs to construct

158
00:08:11,520 --> 00:08:14,470
entire structure to transmit data

159
00:08:14,470 --> 00:08:17,830
and handle different
data type by themselves.

160
00:08:17,830 --> 00:08:19,500
It is difficult to use,

161
00:08:19,500 --> 00:08:21,670
and Apple also does not recommend

162
00:08:21,670 --> 00:08:24,090
developers to use it directly.

163
00:08:24,090 --> 00:08:27,900
Instead, Apple provides
high-level IPC mechanisms

164
00:08:27,900 --> 00:08:29,313
that are easier to use.

165
00:08:31,750 --> 00:08:33,630
On top of Mach messages,

166
00:08:33,630 --> 00:08:37,143
Apple built another communication
mechanism called XPC.

167
00:08:38,440 --> 00:08:41,343
XPC is managed by launchd process.

168
00:08:42,459 --> 00:08:44,773
Launchd is a naming server.

169
00:08:46,010 --> 00:08:49,130
The XPC server register with launchd

170
00:08:49,130 --> 00:08:51,060
and declares that it will handle message

171
00:08:51,060 --> 00:08:52,483
sent to its endpoint.

172
00:08:54,300 --> 00:08:57,400
The client looks up an
endpoint name via launchd

173
00:08:57,400 --> 00:08:59,323
and sends a message request.

174
00:09:00,190 --> 00:09:03,000
The server will receive the request,

175
00:09:03,000 --> 00:09:06,113
handle it, and reply to
the client if needed.

176
00:09:07,720 --> 00:09:11,460
Behind the scene, launchd
starts and terminates

177
00:09:11,460 --> 00:09:13,773
the target server process on demand.

178
00:09:15,080 --> 00:09:19,610
The message sent through
XPC is called XPC message,

179
00:09:19,610 --> 00:09:22,503
which is a more structured
dictionary format.

180
00:09:24,210 --> 00:09:27,810
XPC users do not need to
pay attention to the details

181
00:09:27,810 --> 00:09:30,203
of the underlying Mach message processing.

182
00:09:33,550 --> 00:09:36,227
Through the xpc_dictionary_set APIs,

183
00:09:37,420 --> 00:09:40,773
we can easily construct
an XPC dictionary message.

184
00:09:42,620 --> 00:09:45,870
Besides supporting the
transmission of basic types of data

185
00:09:45,870 --> 00:09:49,630
such as typical string
integer and Boolean,

186
00:09:49,630 --> 00:09:53,200
XPC message also supports
complex data types

187
00:09:53,200 --> 00:09:55,873
such as file descriptor and shared memory.

188
00:09:56,910 --> 00:10:00,660
XPC message is serialized
into Mach message

189
00:10:00,660 --> 00:10:03,490
and transmitted to the
other end of the IPC

190
00:10:03,490 --> 00:10:05,053
via the XNU kernel.

191
00:10:06,490 --> 00:10:11,160
The received Mach messages is
unserialized to XPC message

192
00:10:11,160 --> 00:10:16,003
and then can be used through
the xpc_dictionary_get APIs.

193
00:10:19,640 --> 00:10:22,540
At the API level, the XPC server

194
00:10:22,540 --> 00:10:26,160
calls
xpc_connection_create_mach_service API

195
00:10:26,160 --> 00:10:29,940
with the
xpc_connection_mach_service_listener
flag set

196
00:10:29,940 --> 00:10:34,290
to register itself to
launchd as an XPC service.

197
00:10:34,290 --> 00:10:37,310
And then the client can
connect to the XPC service

198
00:10:37,310 --> 00:10:38,733
through the same API.

199
00:10:40,570 --> 00:10:42,420
The message sending is completed

200
00:10:42,420 --> 00:10:44,170
by the xpc_connection_send_message.

201
00:10:47,233 --> 00:10:50,597
After the process
received the XPC message,

202
00:10:51,800 --> 00:10:54,120
the registered message handler

203
00:10:54,120 --> 00:10:55,920
via xpc_connection_set_event_handler

204
00:10:57,650 --> 00:11:00,503
will be called to process the message.

205
00:11:03,260 --> 00:11:06,230
The mainstream languages
for app developers

206
00:11:06,230 --> 00:11:11,230
are the object-oriented
Objective-C and Swift.

207
00:11:11,270 --> 00:11:14,530
So Apple has encapsulated a layer

208
00:11:14,530 --> 00:11:17,360
of object-oriented implementation

209
00:11:17,360 --> 00:11:20,033
on top of XPC called NSXPC.

210
00:11:22,400 --> 00:11:25,300
NSXPC provides a set of remote procedure

211
00:11:25,300 --> 00:11:27,880
call interface implementations

212
00:11:27,880 --> 00:11:31,333
instead of caring about the
underlying message like XPC.

213
00:11:33,450 --> 00:11:35,470
After establishing the connection,

214
00:11:35,470 --> 00:11:38,440
the client can directly
call the open interface

215
00:11:38,440 --> 00:11:41,990
of the NSXPC server across processes,

216
00:11:41,990 --> 00:11:44,153
just like calling local methods.

217
00:11:45,850 --> 00:11:49,973
Apple provides many NSXPC
classes for developers.

218
00:11:51,300 --> 00:11:54,380
The server registers
the service with launchd

219
00:11:54,380 --> 00:11:56,940
through the NSXPCListener,

220
00:11:56,940 --> 00:11:59,580
and specifies a NSXPCListenerDelegate

221
00:12:00,860 --> 00:12:02,693
to handle the connection request.

222
00:12:04,080 --> 00:12:06,160
The connection between a client and server

223
00:12:06,160 --> 00:12:08,767
is managed by NSXPCConnection.

224
00:12:12,050 --> 00:12:14,523
What method can a client call in a server?

225
00:12:15,740 --> 00:12:19,210
The NSXPC server defines this

226
00:12:19,210 --> 00:12:21,750
through the Objective-C protocol,

227
00:12:21,750 --> 00:12:24,830
which defines programmatic interface

228
00:12:24,830 --> 00:12:27,193
between the calling
application and service.

229
00:12:28,960 --> 00:12:31,370
In interfaces definitions,

230
00:12:31,370 --> 00:12:34,450
common arithmetic types and basic types

231
00:12:34,450 --> 00:12:36,310
such as strings and arrays

232
00:12:36,310 --> 00:12:38,523
are directly supported as parameters.

233
00:12:40,500 --> 00:12:44,750
The interface also supports
custom defined class objects

234
00:12:44,750 --> 00:12:47,090
to be parsed as parameters.

235
00:12:47,090 --> 00:12:49,260
The custom object needs to implement

236
00:12:49,260 --> 00:12:51,463
the NSSecureCoding protocol.

237
00:12:52,570 --> 00:12:54,243
Here is an example.

238
00:12:58,920 --> 00:13:02,590
Here is an architectural
diagram for an app.

239
00:13:02,590 --> 00:13:04,730
The server registered the service

240
00:13:04,730 --> 00:13:06,313
through an NSXPCListener.

241
00:13:07,640 --> 00:13:11,670
The app establishes a
connection with the service

242
00:13:11,670 --> 00:13:13,070
through the NSXPCConnection.

243
00:13:16,300 --> 00:13:17,500
In this process,

244
00:13:17,500 --> 00:13:20,310
both parties can directly
call remote methods

245
00:13:20,310 --> 00:13:22,810
across process boundary
without caring about

246
00:13:22,810 --> 00:13:25,083
the underlying implementation details.

247
00:13:28,530 --> 00:13:31,020
We will now share some
interesting logic vulnerabilities

248
00:13:31,020 --> 00:13:33,613
we found and exploited on Apple platforms.

249
00:13:36,120 --> 00:13:38,470
We found and reported three logic bugs

250
00:13:38,470 --> 00:13:40,483
in Preferences components.

251
00:13:43,030 --> 00:13:44,530
With these vulnerabilities,

252
00:13:44,530 --> 00:13:46,700
a local user may be able to modify

253
00:13:46,700 --> 00:13:48,913
protected parts of the file system.

254
00:13:50,730 --> 00:13:52,630
What are Preferences?

255
00:13:52,630 --> 00:13:55,083
Preferences are user-defined settings.

256
00:13:55,930 --> 00:13:59,740
They are persistent data
stored in Preferences file.

257
00:13:59,740 --> 00:14:02,913
Its format is property
list also called plist.

258
00:14:03,850 --> 00:14:06,070
The service, cfprefsd,

259
00:14:06,070 --> 00:14:09,560
has the responsibility
to manage Preferences.

260
00:14:09,560 --> 00:14:12,280
It would read from or
write to Preferences file

261
00:14:12,280 --> 00:14:13,993
according to client requests.

262
00:14:15,160 --> 00:14:18,393
Apple provides two kinds of
high level Preferences API.

263
00:14:19,660 --> 00:14:22,060
Using the Foundation APIs,

264
00:14:22,060 --> 00:14:25,140
apps could use the NSUserDefaults class

265
00:14:25,140 --> 00:14:26,963
to access its Preferences.

266
00:14:27,930 --> 00:14:31,690
Each app has a single
instance of this class

267
00:14:31,690 --> 00:14:35,183
accessible from the
standardUserDefaults class method.

268
00:14:36,410 --> 00:14:39,120
Through the shared user defaults object,

269
00:14:39,120 --> 00:14:42,963
apps could get and set
individual Preferences values.

270
00:14:44,170 --> 00:14:46,990
Apps can also use many of the underlying

271
00:14:46,990 --> 00:14:48,593
core Foundation APIs.

272
00:14:49,550 --> 00:14:51,400
For example, CFPreferencesSetAppValue

273
00:14:52,872 --> 00:14:55,370
and CFPreferencesCopyAppValue

274
00:14:55,370 --> 00:14:58,853
could be used to get or
set the Preferences data.

275
00:15:04,230 --> 00:15:07,320
After reverse engineering cfprefsd,

276
00:15:07,320 --> 00:15:10,720
we found it create the XPC service

277
00:15:10,720 --> 00:15:15,280
named com.apple.cfprefsd.daemon,

278
00:15:15,280 --> 00:15:18,623
which runs with root
privilege and without sandbox.

279
00:15:19,550 --> 00:15:21,780
When the client requests cfprefsd,

280
00:15:21,780 --> 00:15:25,543
the event handler will be
scheduled to handle the request.

281
00:15:27,180 --> 00:15:29,560
As a foundational service,

282
00:15:29,560 --> 00:15:32,980
Preferences could be accessed
from almost everywhere.

283
00:15:32,980 --> 00:15:35,180
Even the most restricted process

284
00:15:35,180 --> 00:15:37,193
needs to access Preferences.

285
00:15:39,370 --> 00:15:42,643
Here is a sandbox profile
for Safari web browsers.

286
00:15:43,870 --> 00:15:46,150
It allows the sandbox process

287
00:15:46,150 --> 00:15:49,463
to access com.apple.cfprefsd.daemon.

288
00:15:52,200 --> 00:15:56,140
Because cfprefsd is an XPC service,

289
00:15:56,140 --> 00:16:01,140
we could also request it by
sending XPC message directly.

290
00:16:01,300 --> 00:16:04,510
It is a low level method
that could control

291
00:16:04,510 --> 00:16:07,240
the operation more precisely.

292
00:16:07,240 --> 00:16:08,963
Here is a sample request.

293
00:16:11,040 --> 00:16:13,240
First, we use the
xpc_connection_create_mach_service

294
00:16:14,600 --> 00:16:16,573
to create a service connection.

295
00:16:18,150 --> 00:16:22,100
Then we create the XPC
dictionary and set the key value

296
00:16:22,100 --> 00:16:24,453
that is used to control the operation.

297
00:16:25,700 --> 00:16:27,750
Finally, we send the XPC message

298
00:16:27,750 --> 00:16:29,513
through the
xpc_connection_send_message API.

299
00:16:33,300 --> 00:16:37,403
Where does cfprefsd save
the Preferences data?

300
00:16:40,250 --> 00:16:41,820
The Preferences file path

301
00:16:41,820 --> 00:16:44,580
is constructed from multiple components.

302
00:16:44,580 --> 00:16:49,010
Part of it is a fixed value in cfprefsd.

303
00:16:49,010 --> 00:16:52,373
Parts of it come from the
client through XPC message.

304
00:16:53,810 --> 00:16:56,250
First, let's see the Preferences Directory

305
00:16:56,250 --> 00:16:59,290
where the Preferences file is stored in.

306
00:16:59,290 --> 00:17:02,613
There are some predefined
locations to store the file.

307
00:17:04,260 --> 00:17:06,480
PreferencesDomain is a value

308
00:17:06,480 --> 00:17:10,250
that is parsed through the
CFPreferencesDomain key.

309
00:17:10,250 --> 00:17:12,930
By default, the file path is composed

310
00:17:12,930 --> 00:17:16,150
of PreferencesDirectory,
PreferencesDomain,

311
00:17:16,150 --> 00:17:18,523
and the surface string .plist.

312
00:17:19,950 --> 00:17:22,193
How is the file path constructed?

313
00:17:23,150 --> 00:17:25,970
There are two main components.

314
00:17:25,970 --> 00:17:30,340
First, format the file path
with CFStringCreateWithFormat

315
00:17:32,627 --> 00:17:37,610
which concatenate the
PreferencesDomain with .plist,

316
00:17:37,610 --> 00:17:39,830
then
using
CFURLCreateWithFileSystemPathRelativeToBase

317
00:17:42,430 --> 00:17:44,940
to generate the full path.

318
00:17:44,940 --> 00:17:47,880
The baseURL is the PreferencesDirectory,

319
00:17:47,880 --> 00:17:50,623
and the filePath is the
path returned above.

320
00:17:52,780 --> 00:17:57,230
Logic vulnerabilities always
combine some features.

321
00:17:57,230 --> 00:17:58,128
And we found that

322
00:17:58,128 --> 00:18:02,070
CFURLCreateWithFileSystemPathRelativeToBase

323
00:18:02,070 --> 00:18:04,683
have two features that may be abused.

324
00:18:05,940 --> 00:18:10,100
First, this function has
path traversal feature.

325
00:18:10,100 --> 00:18:12,820
If filePath contains ../,

326
00:18:12,820 --> 00:18:16,423
the returned filePath could
traverse to any path we want.

327
00:18:17,630 --> 00:18:19,520
The second feature is that

328
00:18:19,520 --> 00:18:22,640
if the filePath is an absolute path,

329
00:18:22,640 --> 00:18:24,230
it will return the filePath

330
00:18:24,230 --> 00:18:26,433
no matter what the baseURL is.

331
00:18:27,930 --> 00:18:30,210
We could use the path traversal feature

332
00:18:30,210 --> 00:18:34,130
or absolute path feature to
control the Preferences filePath

333
00:18:34,130 --> 00:18:36,203
and return any filePath we want.

334
00:18:37,590 --> 00:18:40,240
What if the controllable filePath

335
00:18:40,240 --> 00:18:42,273
does not exist on the file system?

336
00:18:43,420 --> 00:18:47,540
The function name,
cacheActualPathCreatingIfNecessary,

337
00:18:47,540 --> 00:18:49,290
is very interesting.

338
00:18:49,290 --> 00:18:52,803
Seems it will create the file
path if it does not exist.

339
00:18:53,750 --> 00:18:56,250
Firstly, it will try try to open a file.

340
00:18:56,250 --> 00:18:59,960
If the file path exists,
it will return path.

341
00:18:59,960 --> 00:19:02,490
But if the file path does not exist,

342
00:19:02,490 --> 00:19:05,147
it will get the directory
part of the file path,

343
00:19:05,147 --> 00:19:07,840
and it will create the directory.

344
00:19:07,840 --> 00:19:09,870
After it created the directory,

345
00:19:09,870 --> 00:19:11,980
it tries to open the file path again,

346
00:19:11,980 --> 00:19:13,480
and then return the file path.

347
00:19:15,259 --> 00:19:19,120
The CFPrefsCreatePreferenceDirectory
is the function

348
00:19:19,120 --> 00:19:22,713
used to create the now
existing directories.

349
00:19:23,760 --> 00:19:27,100
It first split the path into
multiple sub items by slice

350
00:19:28,056 --> 00:19:32,023
and then creates them
recursively with mkdirat.

351
00:19:34,240 --> 00:19:36,490
After the directory is created,

352
00:19:36,490 --> 00:19:40,290
its ownership will be modified
through a file change owner.

353
00:19:40,290 --> 00:19:44,663
But where does the user
ID and group ID came from?

354
00:19:46,450 --> 00:19:49,410
The owner of the newly created directories

355
00:19:49,410 --> 00:19:52,400
is determined by several factors.

356
00:19:52,400 --> 00:19:57,100
By default, the owner is the
identity of the XPC client

357
00:19:57,100 --> 00:20:01,050
and cfprefsd get the
identity of the client user

358
00:20:01,050 --> 00:20:02,450
through xpc_connection_get_euid

359
00:20:04,495 --> 00:20:06,828
and xpc_connection_get_egid.

360
00:20:08,770 --> 00:20:13,770
However, the XPC client can
also specify the expected user.

361
00:20:14,350 --> 00:20:17,410
Therefore, the ownership of
the newly created directory

362
00:20:17,410 --> 00:20:19,450
is also under our control.

363
00:20:19,450 --> 00:20:22,310
We can let cfprefsd help us create

364
00:20:22,310 --> 00:20:24,110
any directory with controlled owner.

365
00:20:26,910 --> 00:20:30,440
There are many ways to convert
arbitrary directory creation

366
00:20:30,440 --> 00:20:32,923
to code execution with root privilege.

367
00:20:33,830 --> 00:20:36,680
Here we share a method
mentioned by Csaba Fitzl

368
00:20:36,680 --> 00:20:38,143
through periodic script.

369
00:20:39,960 --> 00:20:44,490
Periodic script is a mechanism
to schedule script execution.

370
00:20:44,490 --> 00:20:48,080
The daily directory does
not exist by default

371
00:20:48,080 --> 00:20:50,000
but the operating system will periodically

372
00:20:50,000 --> 00:20:52,003
scan and execute the files in it.

373
00:20:53,290 --> 00:20:55,600
By exploiting the vulnerability,

374
00:20:55,600 --> 00:20:57,430
we can create the daily directory

375
00:20:57,430 --> 00:21:00,180
and set the owner of the
directory to the current user.

376
00:21:01,210 --> 00:21:04,183
And then we can write any
script to the daily directory.

377
00:21:05,120 --> 00:21:09,253
Wait a day, and the script will
execute with root privilege.

378
00:21:11,690 --> 00:21:13,290
The patch for the vulnerability

379
00:21:13,290 --> 00:21:14,903
is simple and straightforward.

380
00:21:15,850 --> 00:21:18,773
It can be explained even by
looking at the function name.

381
00:21:19,750 --> 00:21:23,440
The cacheActualPathCreatingIfNecessary
function

382
00:21:23,440 --> 00:21:25,790
has been replaced with
cacheFileInfoForWriting.

383
00:21:27,410 --> 00:21:29,173
There is no creating anymore.

384
00:21:30,240 --> 00:21:33,710
In fact, cfprefsd will
no longer help the user

385
00:21:33,710 --> 00:21:37,253
create the non-existing
Preferences Directory.

386
00:21:38,250 --> 00:21:41,820
If client parse in a directory
which does not exist,

387
00:21:41,820 --> 00:21:44,963
cfprefsd will ask the client to create it.

388
00:21:47,380 --> 00:21:52,283
How does cfprefsd read
the Preferences data?

389
00:21:54,160 --> 00:21:56,277
When the client wants to get the data,

390
00:21:56,277 --> 00:22:00,400
the client needs to request cfprefsd.

391
00:22:00,400 --> 00:22:02,410
By default, it will read the data

392
00:22:02,410 --> 00:22:05,400
and then return them
in the reply directly.

393
00:22:05,400 --> 00:22:07,300
But if it decides that
the file is too large

394
00:22:07,300 --> 00:22:10,080
to fit in a XPC message,

395
00:22:10,080 --> 00:22:12,743
it will just return the file descriptor.

396
00:22:13,830 --> 00:22:16,130
To avoid subsequent changes to the file,

397
00:22:16,130 --> 00:22:19,733
it will clone a copy before
return the file descriptor.

398
00:22:22,030 --> 00:22:25,830
This function is the
implementation of cfprefsd

399
00:22:25,830 --> 00:22:28,760
to process large Preferences file.

400
00:22:28,760 --> 00:22:31,580
First, it gets the file path,

401
00:22:31,580 --> 00:22:34,340
then it determines whether the file size

402
00:22:34,340 --> 00:22:37,130
exceeds one megabyte.

403
00:22:37,130 --> 00:22:40,080
Then it generates a
random temporary file path

404
00:22:40,080 --> 00:22:41,120
according to the rules,

405
00:22:41,120 --> 00:22:43,903
and then clone the original
file to a temporary file.

406
00:22:45,050 --> 00:22:46,940
Finally, open a temporary file,

407
00:22:46,940 --> 00:22:49,060
and return its file descriptor.

408
00:22:51,160 --> 00:22:54,310
It calls clonefile to clone
the file to a temporary file

409
00:22:54,310 --> 00:22:56,173
with a random name.

410
00:22:59,100 --> 00:23:01,260
The temporary file and the original file

411
00:23:01,260 --> 00:23:02,893
are in the same directory.

412
00:23:04,970 --> 00:23:06,970
The path of the temporary file

413
00:23:08,220 --> 00:23:12,033
is generated by mktemp
according to a rule.

414
00:23:12,930 --> 00:23:16,150
The rule is that the file path is spliced

415
00:23:16,150 --> 00:23:20,140
with .cfp and seven random characters.

416
00:23:20,140 --> 00:23:22,833
So the final temporary
file name is random.

417
00:23:23,870 --> 00:23:26,323
But can it guarantee it to be random?

418
00:23:29,670 --> 00:23:34,670
The mktemp will replace the
seven X at the end of the row

419
00:23:34,911 --> 00:23:37,090
with random characters.

420
00:23:37,090 --> 00:23:41,383
The space for random
characters is very large.

421
00:23:42,800 --> 00:23:45,830
Is there any other way to make mktemp

422
00:23:45,830 --> 00:23:48,053
generate a fake file name?

423
00:23:49,720 --> 00:23:51,860
One key point is that snprintf

424
00:23:52,857 --> 00:23:54,303
specifies a maximum length as
0x400 for generating rules.

425
00:23:58,680 --> 00:24:01,380
If plist path is very long,

426
00:24:01,380 --> 00:24:05,273
what happens if the
splicing row exceeds 0x400?

427
00:24:08,217 --> 00:24:10,260
Snprintf will overflow

428
00:24:10,260 --> 00:24:13,000
and the characters exceeding 0x400

429
00:24:13,970 --> 00:24:17,290
will not be written
into the written buffer.

430
00:24:17,290 --> 00:24:18,860
To be more precise,

431
00:24:18,860 --> 00:24:21,380
if the length of the filePath pass

432
00:24:21,380 --> 00:24:26,320
the cfp string is exactly 0x400-1,

433
00:24:26,320 --> 00:24:28,233
the rule generated by snprintf

434
00:24:28,233 --> 00:24:30,750
will not contain X at the end.

435
00:24:30,750 --> 00:24:34,653
And mktemp will generate a
fixed temporary file path.

436
00:24:36,143 --> 00:24:38,370
Before clonefile is called,

437
00:24:38,370 --> 00:24:40,290
there's a file check.

438
00:24:40,290 --> 00:24:41,660
In exploit code,

439
00:24:41,660 --> 00:24:44,830
we can first parse in a normal file path.

440
00:24:44,830 --> 00:24:46,900
This will ensure that cfprefsd

441
00:24:46,900 --> 00:24:49,160
can successfully pass this check

442
00:24:49,160 --> 00:24:52,253
and enter the subsequent
clonefile process.

443
00:24:53,560 --> 00:24:56,660
After the file check and
before the clonefile,

444
00:24:56,660 --> 00:24:59,090
there is a window for race condition.

445
00:24:59,090 --> 00:25:01,130
Before we replace a controllable file

446
00:25:01,130 --> 00:25:04,200
with a symbolic link during this time,

447
00:25:04,200 --> 00:25:07,340
cfprefsd will call clonefile to help us

448
00:25:07,340 --> 00:25:10,823
copy arbitrary file to a
temporary file path we control.

449
00:25:12,310 --> 00:25:15,020
We've got a fixed temporary file name,

450
00:25:15,020 --> 00:25:17,480
but can we link it to another place

451
00:25:17,480 --> 00:25:19,950
ahead of mktemp function?

452
00:25:19,950 --> 00:25:24,350
No, this file name is
guaranteed not to exist

453
00:25:24,350 --> 00:25:26,253
at the time of function and location.

454
00:25:27,380 --> 00:25:30,550
But after the mktemp return successfully

455
00:25:30,550 --> 00:25:32,750
and before the clonefile,

456
00:25:32,750 --> 00:25:35,653
this is also a window for race condition.

457
00:25:38,200 --> 00:25:42,150
We could replace the temporary
file with a symbolic link.

458
00:25:42,150 --> 00:25:44,863
In this way, we can achieve
arbitrary file write.

459
00:25:46,490 --> 00:25:50,090
In the patch, Apple added
an overflow checking

460
00:25:50,090 --> 00:25:52,690
and the subsequent clone
file will not be executed

461
00:25:52,690 --> 00:25:54,623
if overflow occurs.

462
00:25:55,510 --> 00:25:58,130
The previous method of
forcing fixed file name

463
00:25:58,130 --> 00:25:59,283
no longer works.

464
00:26:01,760 --> 00:26:04,843
How does cfprefsd write Preferences data?

465
00:26:07,210 --> 00:26:10,653
When cfprefsd saves Preferences
data for the client,

466
00:26:11,590 --> 00:26:16,100
first it extract key and
value from the XPC message,

467
00:26:16,100 --> 00:26:19,053
then it reads the original
data from the target file,

468
00:26:20,360 --> 00:26:22,520
and it generates new data based on

469
00:26:22,520 --> 00:26:24,603
the incoming key and value data,

470
00:26:25,790 --> 00:26:29,460
and writes to the new
data to a temporary file.

471
00:26:29,460 --> 00:26:31,210
And then it renamed the temporary file

472
00:26:31,210 --> 00:26:32,633
back to the target file.

473
00:26:33,630 --> 00:26:37,050
When saving data, cfprefsd verifies

474
00:26:37,050 --> 00:26:40,113
the client has write
permission to target file.

475
00:26:40,990 --> 00:26:43,760
The client needs to parse
in a file descriptor

476
00:26:43,760 --> 00:26:45,053
with write permission.

477
00:26:46,420 --> 00:26:47,870
After the previous check,

478
00:26:47,870 --> 00:26:50,420
cfprefsd would generate a temporary file

479
00:26:50,420 --> 00:26:51,683
and write data to it.

480
00:26:52,600 --> 00:26:54,980
Then it will rename this temporary file

481
00:26:54,980 --> 00:26:56,453
back to the target file.

482
00:26:57,830 --> 00:27:00,030
Can normal user replace the source file

483
00:27:00,030 --> 00:27:02,173
if the rename was a symbolic link?

484
00:27:03,270 --> 00:27:07,570
No, this temporary file is
in root-owned directory.

485
00:27:07,570 --> 00:27:09,830
A normal user does not have permission

486
00:27:09,830 --> 00:27:11,223
to write to this directory.

487
00:27:13,700 --> 00:27:16,010
Can a normal user
replace the rename target

488
00:27:16,010 --> 00:27:17,093
as a symbolic link?

489
00:27:18,030 --> 00:27:21,300
Normal user has write
permission for the target,

490
00:27:21,300 --> 00:27:23,750
but the target file will be deleted first

491
00:27:23,750 --> 00:27:25,170
when the rename is called.

492
00:27:25,170 --> 00:27:29,070
So even if it can be replaced
with a symbolic link,

493
00:27:29,070 --> 00:27:30,920
it will not work.

494
00:27:30,920 --> 00:27:32,710
Regarding this feature,

495
00:27:32,710 --> 00:27:34,960
the rename API documentation says,

496
00:27:34,960 --> 00:27:38,350
if the final component of the
target is a symbolic link,

497
00:27:38,350 --> 00:27:40,560
the symbolic link is renamed,

498
00:27:40,560 --> 00:27:43,513
not the file or directory
to which it points.

499
00:27:47,750 --> 00:27:50,260
But wait, the document says that

500
00:27:50,260 --> 00:27:54,540
if the final component of the
target is a symbolic link,

501
00:27:54,540 --> 00:27:57,100
rename will delete it first.

502
00:27:57,100 --> 00:28:01,210
What if it's not the final component?

503
00:28:01,210 --> 00:28:03,540
What if the middle component of plist_path

504
00:28:03,540 --> 00:28:05,890
is a symbolic link?

505
00:28:05,890 --> 00:28:10,890
Suppose the path of Preferences
is /tmp/test/hello.plist?

506
00:28:13,260 --> 00:28:16,523
If we replaced the directory
with a symbolic link,

507
00:28:17,440 --> 00:28:20,560
pointing to the LaunchDaemons directory,

508
00:28:20,560 --> 00:28:25,560
then the hello.plist is used
as the target path of rename,

509
00:28:26,350 --> 00:28:27,323
what will happen?

510
00:28:29,120 --> 00:28:31,820
The symbolic link will be followed

511
00:28:31,820 --> 00:28:34,350
and the temporary file will be moved

512
00:28:34,350 --> 00:28:36,413
to the LaunchDaemons directory.

513
00:28:39,600 --> 00:28:42,150
Before renaming the temporary file,

514
00:28:42,150 --> 00:28:44,843
it verifies the caller
has write permission.

515
00:28:45,900 --> 00:28:48,120
However, after the file check

516
00:28:48,120 --> 00:28:50,290
and before the rename function,

517
00:28:50,290 --> 00:28:53,270
there is a time window to
replace the middle component

518
00:28:53,270 --> 00:28:55,433
of file path with symbolic link.

519
00:28:57,540 --> 00:29:00,860
In renaming files, it will
move the temporary file

520
00:29:00,860 --> 00:29:03,363
with controllable content
to arbitrary path.

521
00:29:05,130 --> 00:29:09,490
The patch for the rename
vulnerability is very simple.

522
00:29:09,490 --> 00:29:11,873
Rename is replaced with renameat.

523
00:29:12,953 --> 00:29:15,780
Renameat locates the target file

524
00:29:15,780 --> 00:29:18,190
according to the directory descriptor,

525
00:29:18,190 --> 00:29:20,940
to ensure that the final move target

526
00:29:20,940 --> 00:29:23,590
must be in a certain directory.

527
00:29:23,590 --> 00:29:27,090
So even if we replace the
directory with a symbolic link,

528
00:29:27,090 --> 00:29:28,673
it will not work anymore.

529
00:29:36,480 --> 00:29:37,720
Here is a demo.

530
00:29:37,720 --> 00:29:39,670
We used the vulnerabilities to achieve

531
00:29:39,670 --> 00:29:41,570
arbitrary file read and write,

532
00:29:41,570 --> 00:29:44,428
and then we put get
root privileges on macOS

533
00:29:44,428 --> 00:29:48,801
and read privacy data on iOS.

534
00:29:48,801 --> 00:29:51,217
First,

535
00:29:51,217 --> 00:29:53,149
we used Preferences vulnerabilities

536
00:29:53,149 --> 00:29:55,316
to achieve root privilege.

537
00:29:56,542 --> 00:30:00,671
We could see the system
integrity protection is enabled.

538
00:30:00,671 --> 00:30:04,338
The current user is a
normal user, not root.

539
00:30:05,409 --> 00:30:10,409
We could get the root
privileges very quickly.

540
00:31:09,061 --> 00:31:11,989
Next, we use Preferences vulnerabilities

541
00:31:11,989 --> 00:31:13,913
to read privacy data on iOS.

542
00:31:13,913 --> 00:31:16,810
You can see our demo
application is not allowed

543
00:31:16,810 --> 00:31:19,150
to access photos and contacts.

544
00:31:19,150 --> 00:31:21,450
However, when we take a photo,

545
00:31:21,450 --> 00:31:23,710
then the open the demo application.

546
00:31:23,710 --> 00:31:25,670
Our demo application can steal the photo

547
00:31:25,670 --> 00:31:27,223
and send it to our server.

548
00:32:22,740 --> 00:32:25,540
Last year, we found and
reported an interesting

549
00:32:25,540 --> 00:32:29,113
logic vulnerabilities in
macOS App Store component.

550
00:32:30,170 --> 00:32:33,623
An application could abuse it
to gain elevated privilege.

551
00:32:36,050 --> 00:32:39,430
The vulnerability exists in NSXPC server,

552
00:32:39,430 --> 00:32:41,013
com.apple.storedownloadd.daemon.

553
00:32:43,799 --> 00:32:47,530
The server is implemented in
storedownloadd application,

554
00:32:47,530 --> 00:32:49,383
which runs with root privilege.

555
00:32:50,630 --> 00:32:54,163
Fortunately, this process
is run in the sandbox.

556
00:32:55,590 --> 00:32:58,940
But unfortunately, as
an app download service,

557
00:32:58,940 --> 00:33:00,570
it must have the ability to write

558
00:33:00,570 --> 00:33:02,640
to some sensitive locations.

559
00:33:02,640 --> 00:33:05,400
For example, it is allowed
to write to applications

560
00:33:05,400 --> 00:33:06,883
and keychains directory.

561
00:33:08,050 --> 00:33:12,900
As an NXSPC server, it provides
many interfaces for client.

562
00:33:12,900 --> 00:33:15,343
Here we listed the setStoreClient

563
00:33:15,343 --> 00:33:18,000
and performDownload interface.

564
00:33:18,000 --> 00:33:21,190
The performDownload interface
is very interesting.

565
00:33:21,190 --> 00:33:24,430
This interface performs
downloading jobs for the client,

566
00:33:24,430 --> 00:33:25,860
but what can it download,

567
00:33:25,860 --> 00:33:28,153
and what is the SSDownload parameter?

568
00:33:29,970 --> 00:33:34,160
For NSXPC, the Objective-C
object and implements

569
00:33:34,160 --> 00:33:37,973
NSSecureCoding protocol
could be used as parameters.

570
00:33:39,654 --> 00:33:42,200
SSDownload is such an object.

571
00:33:42,200 --> 00:33:45,750
This object only have
one property, assets.

572
00:33:45,750 --> 00:33:47,083
And it is an array.

573
00:33:47,990 --> 00:33:52,493
The element in the assets array
is SSDownloadAsset object.

574
00:33:53,660 --> 00:33:56,530
It is also an Objective-C object,

575
00:33:56,530 --> 00:33:58,930
and it has three properties.

576
00:33:58,930 --> 00:34:01,763
The URL, download paths, and hashes.

577
00:34:04,010 --> 00:34:08,013
The SSDownloadAsset object is
passed from client to server.

578
00:34:09,090 --> 00:34:11,450
The properties of SSDownloadAsset

579
00:34:11,450 --> 00:34:13,217
will be serialized in client.

580
00:34:13,217 --> 00:34:15,407
The function, encodeWithCoder,
will be called

581
00:34:15,407 --> 00:34:19,810
to serialize the specified
properties to XPC message.

582
00:34:19,810 --> 00:34:21,210
At the server side,

583
00:34:21,210 --> 00:34:25,173
the XPC message would be
unserialized with initWithCoder,

584
00:34:27,560 --> 00:34:30,030
and construct the SSDownloadAsset object

585
00:34:30,030 --> 00:34:31,573
with specified properties.

586
00:34:32,960 --> 00:34:36,193
The properties of the object
would be fully controllable.

587
00:34:40,580 --> 00:34:44,063
How does storedownloadd
perform downloading tasks?

588
00:34:46,359 --> 00:34:49,007
It will perform download
task according to the URL,

589
00:34:50,270 --> 00:34:54,253
then it verifies the response
contents based on the hashes.

590
00:34:55,170 --> 00:34:57,320
And finally, it writes the contents

591
00:34:57,320 --> 00:34:59,103
to the specified download path.

592
00:35:00,360 --> 00:35:04,090
There is a hash verification
in the download logic.

593
00:35:04,090 --> 00:35:05,530
This function will calculate

594
00:35:05,530 --> 00:35:08,100
the hash of the response content,

595
00:35:08,100 --> 00:35:12,330
and then compare it with the
hashes the client specified.

596
00:35:12,330 --> 00:35:14,310
But it's not a security check,

597
00:35:14,310 --> 00:35:16,823
just a data integrity verification.

598
00:35:18,890 --> 00:35:21,090
Because we can control the download URL,

599
00:35:21,090 --> 00:35:23,460
the content hash and download path,

600
00:35:23,460 --> 00:35:26,010
we could write arbitrary file path

601
00:35:26,010 --> 00:35:28,783
with the storedownloadd's privilege.

602
00:35:30,270 --> 00:35:33,920
Attackers could say,
"Hi, it's storedownloadd.

603
00:35:33,920 --> 00:35:37,280
Please help me download
the file from this URL.

604
00:35:37,280 --> 00:35:38,780
Its hash is this...

605
00:35:38,780 --> 00:35:41,860
and then write the contents
to this download path.

606
00:35:41,860 --> 00:35:43,480
Thanks!"

607
00:35:43,480 --> 00:35:45,790
Then the storedownloadd would do

608
00:35:45,790 --> 00:35:47,683
all the jobs well for the attacker.

609
00:35:50,920 --> 00:35:53,673
How did Apple fix this vulnerability?

610
00:35:54,887 --> 00:35:56,430
"The issue was addressed

611
00:35:57,550 --> 00:36:00,710
by removing the vulnerable
code," they said.

612
00:36:00,710 --> 00:36:02,120
To be more precise,

613
00:36:02,120 --> 00:36:04,970
they completely removed the service.

614
00:36:04,970 --> 00:36:08,823
There is no
com.apple.storedownloadd.daemon anymore.

615
00:36:11,770 --> 00:36:15,143
Here is the demo of App
Store vulnerability.

616
00:36:16,350 --> 00:36:20,630
We just downloaded the
test.keychain in tmp directory,

617
00:36:20,630 --> 00:36:22,253
to keychains directory,

618
00:36:22,253 --> 00:36:24,783
with the help of storedownloadd.

619
00:36:47,534 --> 00:36:50,140
There are other interesting
logic vulnerabilities

620
00:36:50,140 --> 00:36:52,273
we found and detailed in our blog;

621
00:36:53,470 --> 00:36:56,690
an XPC service implementation flaw,

622
00:36:56,690 --> 00:36:59,360
which is a logic bug inside launchd,

623
00:36:59,360 --> 00:37:01,393
for managing the XPC service;

624
00:37:02,910 --> 00:37:07,910
and NSXPC vulnerability in
Adobe Acrobat Reader for macOS.

625
00:37:10,270 --> 00:37:13,960
There are many security
mechanisms on Apple platform

626
00:37:13,960 --> 00:37:17,660
that tries to make
vulnerabilities harder to exploit

627
00:37:17,660 --> 00:37:21,313
like DEP, ASLR, PAC and so on.

628
00:37:22,350 --> 00:37:25,250
But you probably noticed that logic bugs

629
00:37:25,250 --> 00:37:28,450
are not affected by
these security features.

630
00:37:28,450 --> 00:37:29,803
That's just awesome.

631
00:37:32,510 --> 00:37:36,410
Logic vulnerabilities has many advantages.

632
00:37:36,410 --> 00:37:40,370
Though it is hard to find,
it is easy to exploit.

633
00:37:40,370 --> 00:37:42,423
The exploitation is always stable.

634
00:37:43,390 --> 00:37:47,170
The logic vulnerabilities
exist across platforms often,

635
00:37:47,170 --> 00:37:49,513
so one exploit could rule them all.

636
00:37:53,480 --> 00:37:57,790
Logic bugs in core
frameworks like Preferences,

637
00:37:57,790 --> 00:37:59,960
let us rule whole Apple platforms,

638
00:37:59,960 --> 00:38:02,470
Intel and Apple Silicon alike,

639
00:38:02,470 --> 00:38:04,993
without changing one line of our exploit.

640
00:38:06,940 --> 00:38:09,840
Apple is also working
hard to try to reduce

641
00:38:09,840 --> 00:38:12,600
the IPC attack surfaces.

642
00:38:12,600 --> 00:38:16,620
For example, by adding more
restrictive sandbox rules,

643
00:38:16,620 --> 00:38:21,580
it reduced the IPC services
accessible to applications.

644
00:38:21,580 --> 00:38:25,630
They keep deleting the unnecessary
high privilege services,

645
00:38:25,630 --> 00:38:29,000
and they are adding more and
more private entitlements

646
00:38:29,000 --> 00:38:31,130
to make many high privilege services

647
00:38:31,130 --> 00:38:33,483
only accessible to Apple applications.

648
00:38:34,840 --> 00:38:38,470
It hard to make sure
everything is perfectly secure,

649
00:38:38,470 --> 00:38:41,033
so Apple is also trying
to limit the damage.

650
00:38:42,160 --> 00:38:47,010
For example, they are putting
IPC services in sandboxes

651
00:38:47,010 --> 00:38:49,620
and give them the least privilege.

652
00:38:49,620 --> 00:38:52,603
They are also using Rootless
to limit the root privilege.

653
00:38:55,220 --> 00:38:56,730
In this presentation,

654
00:38:56,730 --> 00:38:59,410
we talked about the latest IPC mechanism

655
00:38:59,410 --> 00:39:02,963
on Apple platforms, XPC and NSXPC.

656
00:39:03,970 --> 00:39:06,880
Then we walked you through
some of the interesting

657
00:39:06,880 --> 00:39:08,860
IPC logic vulnerabilities;

658
00:39:08,860 --> 00:39:11,710
three logic vulnerabilities
in Preferences,

659
00:39:11,710 --> 00:39:13,710
and one in App Store.

660
00:39:13,710 --> 00:39:15,470
We detailed the design logic

661
00:39:15,470 --> 00:39:18,160
and the implementation
of these components,

662
00:39:18,160 --> 00:39:20,080
the flaws inside them

663
00:39:20,080 --> 00:39:23,570
and how we exploit them
to elevate privilege.

664
00:39:23,570 --> 00:39:25,910
And we also talked about the advantage

665
00:39:25,910 --> 00:39:28,260
of IPC logic vulnerability,

666
00:39:28,260 --> 00:39:31,563
and the state of Apple IPC security.

667
00:39:34,300 --> 00:39:36,990
Logic bugs are always fun to hunt for.

668
00:39:36,990 --> 00:39:39,123
We think you will love it just as we do.

669
00:39:42,430 --> 00:39:46,490
We would like to thank Csaba
Fitzl, Ian Beer, and Zhi Zhou

670
00:39:46,490 --> 00:39:48,240
for their previous work and shares.

