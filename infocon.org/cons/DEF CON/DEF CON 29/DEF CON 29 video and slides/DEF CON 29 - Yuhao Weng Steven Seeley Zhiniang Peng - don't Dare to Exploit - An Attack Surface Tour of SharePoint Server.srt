1
00:00:17,030 --> 00:00:18,430
- [Yuhao Weng] Hello, everyone.

2
00:00:18,430 --> 00:00:21,860
It is a great honor to present at DefCon.

3
00:00:21,860 --> 00:00:23,565
Welcome to our presentation.

4
00:00:23,565 --> 00:00:25,013
Don't Dare to Exploit

5
00:00:25,013 --> 00:00:27,997
An Attack Surface Tour
of SharePoint Server.

6
00:00:27,997 --> 00:00:32,030
It is presented by myself,
Yuhao Weng of Sangfor,

7
00:00:32,030 --> 00:00:36,533
Steven Seeley of Qihoo 360,
and Zhiniang Peng of Sangfor.

8
00:00:36,533 --> 00:00:39,590
Let me introduce ourselves at first.

9
00:00:39,590 --> 00:00:43,410
Yuhao Weng who is a web
security researcher of Sangfor

10
00:00:43,410 --> 00:00:46,890
and also a CTF player of Team Kap0k.

11
00:00:46,890 --> 00:00:51,830
Steven Seeley is a Security
Researcher of Qihoo 360,

12
00:00:51,830 --> 00:00:54,200
and he is a very good trainer.

13
00:00:54,200 --> 00:00:57,140
Zhiniang Peng is the
Principle Security Researcher

14
00:00:57,140 --> 00:01:00,430
of Sangfor. Let's begin.

15
00:01:00,430 --> 00:01:03,969
The agenda we will be
talk about is introduction

16
00:01:03,969 --> 00:01:06,913
to SharePoint Server,
Exploiting Server-side,

17
00:01:06,913 --> 00:01:10,226
Exploiting Client-side and examples,

18
00:01:10,226 --> 00:01:11,963
and a conclusion.

19
00:01:12,940 --> 00:01:16,840
SharePoint Server really
doesn't need an introduction.

20
00:01:16,840 --> 00:01:20,480
It's a part Of Office 365 products.

21
00:01:20,480 --> 00:01:23,260
It is one of the most popular, trusted

22
00:01:23,260 --> 00:01:26,880
Content Management Systems
that we have today.

23
00:01:26,880 --> 00:01:30,530
It has online version
hosted by Microsoft Azure

24
00:01:30,530 --> 00:01:34,960
and open version which
we can deploy ourselves.

25
00:01:34,960 --> 00:01:37,730
It doesn't need too much
professional knowledge

26
00:01:37,730 --> 00:01:41,480
and skill to deploy but
actually, in my opinion,

27
00:01:41,480 --> 00:01:43,910
it should have a more
higher learning curve

28
00:01:43,910 --> 00:01:45,900
than other Content Management Systems.

29
00:01:46,810 --> 00:01:50,710
You always need to spend some
time to get similar with it

30
00:01:50,710 --> 00:01:54,770
but many schools and
institutions like it, in fact.

31
00:01:54,770 --> 00:01:57,460
This is a example of
what SharePoint server

32
00:01:57,460 --> 00:01:59,700
will look like in 2019.

33
00:01:59,700 --> 00:02:02,550
This is a default communication site.

34
00:02:02,550 --> 00:02:06,320
It look very up-to-date
and very professional.

35
00:02:06,320 --> 00:02:07,920
But hiding behind all of that

36
00:02:07,920 --> 00:02:10,530
is a lot of issues that
don't necessarily have

37
00:02:10,530 --> 00:02:12,653
buttons or earlier tools.

38
00:02:13,530 --> 00:02:17,673
We're going to exploit a lot
of that in this present day.

39
00:02:18,860 --> 00:02:21,630
With a introduction to SharePoint Server,

40
00:02:21,630 --> 00:02:24,060
we can talk about the structure,

41
00:02:24,060 --> 00:02:26,310
the key difference, design weakness

42
00:02:26,310 --> 00:02:29,723
and AddAndCustomizePages default danger.

43
00:02:31,420 --> 00:02:35,120
With the SharePoint
structures is site admin

44
00:02:35,120 --> 00:02:36,950
who can manage the different sites

45
00:02:36,950 --> 00:02:39,600
and they can access the admin panel,

46
00:02:39,600 --> 00:02:42,270
which has global communities settings

47
00:02:42,270 --> 00:02:44,150
that can impart multiple sites.

48
00:02:44,150 --> 00:02:48,054
Or you can deploy a new web
parts those of features.

49
00:02:48,054 --> 00:02:51,470
So is really a powerful position.

50
00:02:51,470 --> 00:02:52,350
To be honest,

51
00:02:52,350 --> 00:02:56,120
we have not fully explore the admin panel,

52
00:02:56,120 --> 00:02:57,140
but I do believe,

53
00:02:57,140 --> 00:03:01,100
there is the ability
to upload regular files

54
00:03:01,100 --> 00:03:04,160
on the server and secure the code, anyway.

55
00:03:04,160 --> 00:03:07,550
Then this is known as the site owner,

56
00:03:07,550 --> 00:03:09,720
and this is the regular permissions

57
00:03:09,720 --> 00:03:12,410
that given by most users.

58
00:03:12,410 --> 00:03:15,270
So if a new user is created

59
00:03:15,270 --> 00:03:17,900
they have site owner permissions

60
00:03:17,900 --> 00:03:20,160
because they can create their own site.

61
00:03:20,160 --> 00:03:22,470
If they are just site viewer,

62
00:03:22,470 --> 00:03:23,800
they cannot do anything

63
00:03:23,800 --> 00:03:26,010
other than just viewing the page.

64
00:03:26,010 --> 00:03:28,130
They can change any settings

65
00:03:28,130 --> 00:03:29,420
and waste my site

66
00:03:29,420 --> 00:03:33,240
so seen as we lack of
my space or something.

67
00:03:33,240 --> 00:03:35,220
They can create their own page

68
00:03:35,220 --> 00:03:37,810
and they can look on there
and do what they like

69
00:03:37,810 --> 00:03:41,750
but they cannot use their
site to set other sites.

70
00:03:41,750 --> 00:03:44,519
There are other securities involved.

71
00:03:44,519 --> 00:03:46,180
The key difference of SharePoint

72
00:03:46,180 --> 00:03:48,550
and some popular open source competitor

73
00:03:48,550 --> 00:03:49,750
would be this.

74
00:03:49,750 --> 00:03:51,420
As I said it before,

75
00:03:51,420 --> 00:03:53,550
this ability to create a site.

76
00:03:53,550 --> 00:03:56,393
In the SharePoint eyes
site is a new structure.

77
00:03:57,450 --> 00:03:59,930
It has a new physical
folder on the file system.

78
00:03:59,930 --> 00:04:03,290
Then are new virtual directory is created

79
00:04:03,290 --> 00:04:05,950
and point to that folder on file system.

80
00:04:05,950 --> 00:04:10,430
Is logged on different path
is different application

81
00:04:10,430 --> 00:04:12,880
messed up site will
not create a new folder

82
00:04:12,880 --> 00:04:14,390
just a virtual one

83
00:04:14,390 --> 00:04:16,213
and they can upload page in their site

84
00:04:16,213 --> 00:04:18,650
as well as our security file.

85
00:04:18,650 --> 00:04:22,510
Those other script cannot
access other site content,

86
00:04:22,510 --> 00:04:25,310
which is why Microsoft demo is safe

87
00:04:25,310 --> 00:04:27,760
to be able to upload server script code,

88
00:04:27,760 --> 00:04:30,540
on your site, because it
means that our script,

89
00:04:30,540 --> 00:04:33,350
we cannot access content on another site

90
00:04:33,350 --> 00:04:34,860
of other admin site.

91
00:04:34,860 --> 00:04:38,000
where lots of other
dangerous things can be done.

92
00:04:38,000 --> 00:04:42,160
Users can upload a custom
page like a conversation,

93
00:04:42,160 --> 00:04:45,810
and there are several different
authentication measures

94
00:04:45,810 --> 00:04:49,400
like NTLM, Form Based
Authentication, and so on.

95
00:04:49,400 --> 00:04:52,810
It design weakness of
SharePoint is the ability

96
00:04:52,810 --> 00:04:56,220
to use an arbitrary
file with vulnerability

97
00:04:56,220 --> 00:05:00,517
that can be leveraged to
achieved remote code execution,

98
00:05:00,517 --> 00:05:05,070
because it's possible to
load the web.config file,

99
00:05:05,070 --> 00:05:07,760
which can contain the validation key

100
00:05:07,760 --> 00:05:10,610
or ViewState deserialization,

101
00:05:10,610 --> 00:05:14,229
which can be used to generate
a particular ViewState,

102
00:05:14,229 --> 00:05:18,530
executes and eventually
command again the application.

103
00:05:18,530 --> 00:05:20,350
I know some other researcher

104
00:05:20,350 --> 00:05:22,430
have talked about this before,

105
00:05:22,430 --> 00:05:24,660
and this is something that I told them

106
00:05:24,660 --> 00:05:27,377
as a default site of SharePoint.

107
00:05:27,377 --> 00:05:30,710
I'm not exactly sure why they
have decide that is generate

108
00:05:30,710 --> 00:05:35,710
use a randomized config
key in the webconfig file.

109
00:05:35,800 --> 00:05:38,750
Because it's possible
to generate config key

110
00:05:38,750 --> 00:05:40,750
without using phase one.

111
00:05:40,750 --> 00:05:44,850
Like the past of CVE-2020-0688.

112
00:05:44,850 --> 00:05:46,550
But I'm not sure exactly

113
00:05:46,550 --> 00:05:49,680
why SharePoint doesn't use
that particular feature.

114
00:05:49,680 --> 00:05:54,160
I believe that there are some
shared code in SharePoint

115
00:05:54,160 --> 00:05:57,090
that require the validation
key to be started

116
00:05:57,090 --> 00:06:00,550
in the webconfig file. I not very sure.

117
00:06:00,550 --> 00:06:04,350
But regardless if a file
disclosure vulnerability

118
00:06:04,350 --> 00:06:05,523
is file in SharePoint,

119
00:06:05,523 --> 00:06:10,523
it means that you have an
arbitrary command execution.

120
00:06:10,690 --> 00:06:13,670
The AddAndCustomizePages default danger.

121
00:06:13,670 --> 00:06:17,320
Other permission rather is
allowing user with this privilege

122
00:06:17,320 --> 00:06:22,050
of site owner rather to
upload page on that site.

123
00:06:22,050 --> 00:06:24,607
So this also work on
server online (indistinct),

124
00:06:26,568 --> 00:06:28,880
but it should be enabled by other admin

125
00:06:28,880 --> 00:06:30,583
in SharePoint Online.

126
00:06:31,810 --> 00:06:36,810
It gets dangerous because
users can upload also aspx page

127
00:06:37,040 --> 00:06:39,830
which can contain client-side script

128
00:06:39,830 --> 00:06:43,120
along with a server-side asp.net controls.

129
00:06:43,120 --> 00:06:45,924
Those are known as site pages.

130
00:06:45,924 --> 00:06:48,720
The control are filtered by an allow lists

131
00:06:48,720 --> 00:06:51,540
that is a defined in the web.config.

132
00:06:51,540 --> 00:06:55,260
So you can just upload what
type of control you want.

133
00:06:55,260 --> 00:06:59,450
And those controls will be
the deserialized using xaml.

134
00:07:00,583 --> 00:07:03,520
That several evil
payloads used in the past

135
00:07:03,520 --> 00:07:06,110
with XamlReader.Load.

136
00:07:06,110 --> 00:07:08,270
But those payloads don't work here.

137
00:07:08,270 --> 00:07:12,240
We can adjust deserialized
what type of payload we want

138
00:07:12,240 --> 00:07:14,683
and get the code execution in that way.

139
00:07:15,700 --> 00:07:20,010
Users can also not upload
inline asp.net script.

140
00:07:20,010 --> 00:07:23,850
It will not work because
compilation is never,

141
00:07:23,850 --> 00:07:26,930
you cannot run a compiler
code on the server.

142
00:07:26,930 --> 00:07:30,660
Additionally, the asp.net
server-side include

143
00:07:30,660 --> 00:07:31,833
are also blocked.

144
00:07:32,810 --> 00:07:37,080
However, a combination of the
allowed server-side controls

145
00:07:37,080 --> 00:07:40,900
in Java script can be quite problematic.

146
00:07:40,900 --> 00:07:44,240
And we will talk about
several vulnerabilities

147
00:07:44,240 --> 00:07:46,173
that are raised by this.

148
00:07:47,010 --> 00:07:49,240
Looking at the table site page,

149
00:07:49,240 --> 00:07:51,709
which are created by users.

150
00:07:51,709 --> 00:07:55,400
The content of those pages
are stored in a database.

151
00:07:55,400 --> 00:07:58,600
They are not compiled
and they are untrusted.

152
00:07:58,600 --> 00:08:02,550
And so application page is opposite.

153
00:08:02,550 --> 00:08:06,230
They are created by
system or installation.

154
00:08:06,230 --> 00:08:08,520
They are only file systems.

155
00:08:08,520 --> 00:08:11,000
They are compiled and they are trusted.

156
00:08:11,000 --> 00:08:14,523
Those files will get compiled
and secured when accessed.

157
00:08:15,530 --> 00:08:17,493
Now for the server side.

158
00:08:18,490 --> 00:08:22,700
We're going to briefly
discuss the attack service.

159
00:08:22,700 --> 00:08:27,470
So using things like a Bypass
SPPageParseFilter Check,

160
00:08:27,470 --> 00:08:30,350
Server Side Request Forgery,

161
00:08:30,350 --> 00:08:35,157
XML Parsing will give you
some exploitation examples.

162
00:08:37,430 --> 00:08:41,039
Bypass SPPageParseFilter Check.

163
00:08:41,039 --> 00:08:45,585
SPPageParseFilter overrided
the page parse filter.

164
00:08:45,585 --> 00:08:47,767
It doesn't check files in file system

165
00:08:47,767 --> 00:08:50,090
enter directory directly,

166
00:08:50,090 --> 00:08:52,030
but check files in database

167
00:08:52,030 --> 00:08:54,650
if they then only save controls

168
00:08:54,650 --> 00:08:56,460
and without server side included,

169
00:08:56,460 --> 00:09:01,460
In addition, this page is
copied from Look for Escape.

170
00:09:02,820 --> 00:09:06,930
We want to know what a safe
control is actually make out of.

171
00:09:06,930 --> 00:09:11,580
The load class is
System.Web.UI.Control class.

172
00:09:11,580 --> 00:09:15,473
And so every ASP.net
control is taken from it.

173
00:09:16,320 --> 00:09:18,450
And to work out what classes

174
00:09:18,450 --> 00:09:22,700
can be used for XAML deserialization

175
00:09:22,700 --> 00:09:27,120
the controls that are marked
as safe in web.config file.

176
00:09:27,120 --> 00:09:29,030
So here is an example,

177
00:09:29,030 --> 00:09:30,903
that's two different the controls.

178
00:09:30,903 --> 00:09:33,916
The first one is actually a namespace,

179
00:09:33,916 --> 00:09:35,916
System.Web.UI namespace.

180
00:09:37,590 --> 00:09:40,670
And all type under that
namespace are safe.

181
00:09:40,670 --> 00:09:42,460
Then you have another

182
00:09:42,460 --> 00:09:47,350
that has the
System.Web.UI.WebControls namespace.

183
00:09:47,350 --> 00:09:50,200
A particular type, SQLDataSource,

184
00:09:50,200 --> 00:09:54,177
that is marked as false, it is safe.

185
00:09:54,177 --> 00:09:55,160
By the way,

186
00:09:55,160 --> 00:09:58,320
if it is inside safe control tag

187
00:09:58,320 --> 00:10:01,653
and don't special save, it is safe.

188
00:10:03,070 --> 00:10:07,860
Let's think if a control
extends from unsafe control.

189
00:10:07,860 --> 00:10:09,470
Is it safe?

190
00:10:09,470 --> 00:10:10,593
Yes, actually.

191
00:10:11,560 --> 00:10:12,990
Examples.

192
00:10:12,990 --> 00:10:16,250
If we look into the web.config file

193
00:10:16,250 --> 00:10:18,057
and we see the SqlDataSource

194
00:10:18,057 --> 00:10:21,740
it is defined as an unsafe control.

195
00:10:21,740 --> 00:10:23,690
But as it turned out,

196
00:10:23,690 --> 00:10:27,915
that is a particular class
called SPSqlDataSource

197
00:10:27,915 --> 00:10:29,565
that is taken from SqlDataSource.

198
00:10:31,271 --> 00:10:36,070
This particular control is
not found from web.config

199
00:10:36,070 --> 00:10:38,523
It was possible to reach
a SqlConnection.Open sink.

200
00:10:41,180 --> 00:10:44,840
Attacker can control the
connection string properties,

201
00:10:44,840 --> 00:10:48,470
and it can be used to
attack the client drivers

202
00:10:48,470 --> 00:10:50,243
on the server itself.

203
00:10:51,480 --> 00:10:55,820
We saw this earlier research
is interesting because

204
00:10:55,820 --> 00:10:59,270
not many people sat it down
and look at into attacking

205
00:10:59,270 --> 00:11:02,677
Sql drivers on client's side.

206
00:11:03,575 --> 00:11:06,051
But overall mySQL driver is intuitive.

207
00:11:06,051 --> 00:11:10,350
If you can connect to a
malicious, mySQL server,

208
00:11:10,350 --> 00:11:14,190
then the local server
can send back a request

209
00:11:14,190 --> 00:11:15,810
for a local file.

210
00:11:15,810 --> 00:11:19,713
This has been public knowledge
that since April 2nd, 2018.

211
00:11:21,700 --> 00:11:25,890
I do know that this is by
design the features of mySQL.

212
00:11:25,890 --> 00:11:29,462
If you control the connection
stream in most application,

213
00:11:29,462 --> 00:11:33,010
the connection string is not controlled.

214
00:11:33,010 --> 00:11:33,960
But not SharePoint.

215
00:11:34,940 --> 00:11:37,800
Here is an example of a payload.

216
00:11:37,800 --> 00:11:41,230
You can see here that the
connection string driver

217
00:11:41,230 --> 00:11:46,230
equals mySQL, then the server
to the attack servers, port,

218
00:11:47,010 --> 00:11:49,983
and database, name, username and password.

219
00:11:51,020 --> 00:11:52,910
But when you, basically here,

220
00:11:52,910 --> 00:11:57,160
you can see a SelectCommand
select * from users.

221
00:11:57,160 --> 00:11:58,620
We need a SelectCommand

222
00:11:58,620 --> 00:12:01,390
to be able to trigger the communication,

223
00:12:01,390 --> 00:12:04,440
or it can communicate with the server.

224
00:12:04,440 --> 00:12:06,060
And then on the server side,

225
00:12:06,060 --> 00:12:10,973
we will ask for the particular
file, you know, web.config.

226
00:12:12,330 --> 00:12:15,890
We have a proof of concern video here.

227
00:12:15,890 --> 00:12:20,890
Note that it need a mySQL driver
in the time keeper servers.

228
00:12:21,155 --> 00:12:23,322
(silence)

229
00:13:26,092 --> 00:13:29,482
And the SPSqlDataSource
file disclosure bug

230
00:13:29,482 --> 00:13:31,840
had a patch bypass.

231
00:13:31,840 --> 00:13:34,870
It was interesting because
this particular bypass

232
00:13:34,870 --> 00:13:36,994
was a time of check time of use

233
00:13:36,994 --> 00:13:41,930
in the way that they check
the connection string.

234
00:13:41,930 --> 00:13:43,100
To be honest,

235
00:13:43,100 --> 00:13:45,700
we never tested this patch bypass

236
00:13:45,700 --> 00:13:47,822
we just reviewed the patch quickly

237
00:13:47,822 --> 00:13:50,690
and seeing it was vulnerable.

238
00:13:50,690 --> 00:13:53,850
They added a check of
the connection string.

239
00:13:53,850 --> 00:13:58,224
And this was the method
called CheckConnectionString.

240
00:13:58,224 --> 00:13:59,944
It will get the ConnectionString

241
00:13:59,944 --> 00:14:02,361
and call IsAllowedOdbcDriver.

242
00:14:03,774 --> 00:14:04,953
Let's check it.

243
00:14:04,953 --> 00:14:06,650
The first string it look out

244
00:14:06,650 --> 00:14:09,183
is a dsn in the ConnectionStrings.

245
00:14:10,370 --> 00:14:12,390
Then you will look out the dsn

246
00:14:12,390 --> 00:14:14,660
and find the particular driver,

247
00:14:14,660 --> 00:14:16,357
out of the dsn.

248
00:14:16,357 --> 00:14:20,350
And if that equal to SQL server driver,

249
00:14:20,350 --> 00:14:24,350
that's the trustee SQL server
then it will be allowed.

250
00:14:24,350 --> 00:14:26,410
But if you look at the implementation

251
00:14:27,560 --> 00:14:30,500
of the SqlConnection.Open

252
00:14:30,500 --> 00:14:34,910
it look for either,
dsn or driver property,

253
00:14:34,910 --> 00:14:37,860
whichever is set first it used.

254
00:14:37,860 --> 00:14:40,090
We can exploit this for TOCTOU used

255
00:14:41,560 --> 00:14:45,870
by providing a dsn
property after the driver.

256
00:14:45,870 --> 00:14:48,263
The Impact, again, is RCE.

257
00:14:49,220 --> 00:14:51,290
But we need to know the other

258
00:14:51,290 --> 00:14:53,500
existing dsn only target systems

259
00:14:53,500 --> 00:14:56,050
that use SQL servers.

260
00:14:56,050 --> 00:14:58,770
At the time we didn't spend too much time

261
00:14:58,770 --> 00:15:01,070
on these particular vulnerabilities.

262
00:15:01,070 --> 00:15:04,583
But we're saying there is
a way to leave the dsn.

263
00:15:04,583 --> 00:15:07,250
Here is our port.

264
00:15:07,250 --> 00:15:10,760
You can see that way using
PowerShell command line.

265
00:15:10,760 --> 00:15:15,690
Add-OdbcDsn which will
create dsl on the systems

266
00:15:15,690 --> 00:15:17,620
using SQL servers.

267
00:15:17,620 --> 00:15:21,873
When the Add-OdbcDsn
here contain equal POC

268
00:15:23,150 --> 00:15:26,820
as long as the dsl is in here,

269
00:15:26,820 --> 00:15:29,100
then it will be traded as trustee.

270
00:15:29,100 --> 00:15:32,390
But then when the SQL connection is made

271
00:15:32,390 --> 00:15:35,803
is set, the driver property
first and then set it,

272
00:15:35,803 --> 00:15:40,200
You see mySQL? Use mySQL driver.

273
00:15:40,200 --> 00:15:42,190
Then what other properties?

274
00:15:42,190 --> 00:15:44,560
And then it ignored the dsl

275
00:15:44,560 --> 00:15:48,280
because there is no a particular property

276
00:15:48,280 --> 00:15:52,670
for that particular
drivers is a SQL server.

277
00:15:52,670 --> 00:15:55,690
And the driver, server, port, database

278
00:15:55,690 --> 00:15:58,960
and then trigger it again.

279
00:15:58,960 --> 00:16:02,750
So we can continue to
reveal the web.config file

280
00:16:02,750 --> 00:16:05,443
and get remote code executions.

281
00:16:06,367 --> 00:16:11,010
Then look at the next
example, CVE-2021-28450.

282
00:16:12,370 --> 00:16:14,264
It is an RE DOS file

283
00:16:14,264 --> 00:16:18,230
and count for another unsafe control.

284
00:16:18,230 --> 00:16:22,660
We find this control and then
RegularExpressionValidator.

285
00:16:22,660 --> 00:16:26,020
It look like a link tool as validation.

286
00:16:26,020 --> 00:16:30,700
That is unsigned class
InputFormRegularExpressionValidator

287
00:16:33,007 --> 00:16:35,200
is taken from it, which is safe.

288
00:16:35,200 --> 00:16:37,470
Okay, let's check this normal example.

289
00:16:37,470 --> 00:16:41,569
As we see, we can control
the validation expression

290
00:16:41,569 --> 00:16:43,236
and validationvalue.

291
00:16:45,188 --> 00:16:46,880
Anything else?

292
00:16:46,880 --> 00:16:49,340
When we look at the code
and we found out that we can

293
00:16:49,340 --> 00:16:50,851
control the time out too.

294
00:16:50,851 --> 00:16:53,060
So in this case,

295
00:16:53,060 --> 00:16:56,840
we can specify the
expressions and the input,

296
00:16:56,840 --> 00:16:59,930
as well as the match time out

297
00:16:59,930 --> 00:17:03,383
for the expressions to be calculate.

298
00:17:04,360 --> 00:17:08,420
What will happen if we insert
a malicious expressions?

299
00:17:08,420 --> 00:17:13,420
Think about this expression
and our input is 128*a+!.

300
00:17:18,400 --> 00:17:20,430
It will run very, very slowed

301
00:17:20,430 --> 00:17:23,400
because the first part of this expression

302
00:17:23,400 --> 00:17:25,630
will be executed repeatedly.

303
00:17:25,630 --> 00:17:27,810
It will keep measuring,

304
00:17:27,810 --> 00:17:32,660
it will keep measuring
until run out of time.

305
00:17:32,660 --> 00:17:36,570
Here is the chart about how
many steps will be executed.

306
00:17:36,570 --> 00:17:39,400
When the number of a is ingest,

307
00:17:39,400 --> 00:17:42,393
we can see that when we input 20a,

308
00:17:43,650 --> 00:17:47,882
it will learn more than
100,000 steps to try to match.

309
00:17:47,882 --> 00:17:51,833
And we will attack it with 128a.

310
00:17:53,763 --> 00:17:57,040
And we will, we can set a
large count timeout value

311
00:17:57,040 --> 00:18:01,000
so the script don't get close quickly.

312
00:18:01,000 --> 00:18:05,830
So we tested against SharePoint
online and make it died

313
00:18:05,830 --> 00:18:08,615
after sending 50 requests.

314
00:18:08,615 --> 00:18:11,300
You don't need to send
requests at the same time.

315
00:18:11,300 --> 00:18:14,870
So I send it slowly and
see whether it dies out.

316
00:18:14,870 --> 00:18:17,357
And you will restart after some minutes,

317
00:18:18,400 --> 00:18:21,393
maybe 20 minutes more or less.

318
00:18:23,760 --> 00:18:27,100
Then go to the next example
that we will talk about.

319
00:18:27,100 --> 00:18:32,100
We found the two types that
were blocked in web.config file.

320
00:18:32,510 --> 00:18:37,237
This was about creating users
where they changed password.

321
00:18:37,237 --> 00:18:39,740
And in this time we cannot find

322
00:18:39,740 --> 00:18:43,010
any class is taken from them.

323
00:18:43,010 --> 00:18:45,410
Let us find it ourselves.

324
00:18:45,410 --> 00:18:48,240
Why are those controls blocked?

325
00:18:48,240 --> 00:18:51,030
Why those particular controls?

326
00:18:51,030 --> 00:18:55,280
After doing a bit of
research and investigation,

327
00:18:55,280 --> 00:18:57,340
we found that those people controls

328
00:18:57,340 --> 00:19:00,210
categories of a file methods

329
00:19:00,210 --> 00:19:02,430
in the lower controlled class.

330
00:19:02,430 --> 00:19:06,073
They changed password and
create and create user wizard.

331
00:19:06,073 --> 00:19:08,310
It taken from web controls,

332
00:19:08,310 --> 00:19:11,610
which has open file methods,

333
00:19:11,610 --> 00:19:12,443
Of course,

334
00:19:12,443 --> 00:19:16,690
there was an additional
control the password recovery,

335
00:19:16,690 --> 00:19:19,923
which was not block any web.config.

336
00:19:20,966 --> 00:19:25,710
We could use password recovery
control to email ourselves,

337
00:19:25,710 --> 00:19:30,200
our own password, coupled
with a file of our choice.

338
00:19:30,200 --> 00:19:34,650
We're seeing is designed to
see that email template file.

339
00:19:34,650 --> 00:19:36,970
So email address were
assigned to the account

340
00:19:36,970 --> 00:19:41,200
using the phone based authentication,

341
00:19:41,200 --> 00:19:44,963
which was the default authentication
for SharePoint online.

342
00:19:46,240 --> 00:19:49,144
They will allow yours to email ourself

343
00:19:49,144 --> 00:19:53,390
with the web.config file
and get us here again.

344
00:19:53,390 --> 00:19:57,560
But the attacker also need to
link the membership provider

345
00:19:57,560 --> 00:20:00,200
and we can follow it by the session cookie

346
00:20:01,833 --> 00:20:06,833
and outgoing SMTP server
needed to be configured

347
00:20:06,910 --> 00:20:09,110
on the target system as well,

348
00:20:09,110 --> 00:20:13,523
so that we can receive
email of web.config file.

349
00:20:14,600 --> 00:20:17,570
This is what the payload look like.

350
00:20:17,570 --> 00:20:21,110
All we have to do is
specify the body file name,

351
00:20:21,110 --> 00:20:25,003
and that equals a particular
part to web.config.

352
00:20:26,680 --> 00:20:31,680
We load a proof of consent
for that one and put here.

353
00:20:32,260 --> 00:20:33,780
Email results here.

354
00:20:33,780 --> 00:20:37,950
We can receive machine key in our mailbox.

355
00:20:37,950 --> 00:20:40,533
Here we use both to capture it.

356
00:20:41,840 --> 00:20:43,530
Then let's (indistinct) control,

357
00:20:43,530 --> 00:20:47,520
and we will talk a little bit
about server-side include.

358
00:20:47,520 --> 00:20:52,520
Server-side include are
directives that place in html page

359
00:20:53,150 --> 00:20:55,950
and evaluated on these server

360
00:20:55,950 --> 00:20:58,980
while the page are being served.

361
00:20:58,980 --> 00:21:03,570
Asp.net is convenient
to include web.config

362
00:21:03,570 --> 00:21:06,020
to steal your machine key.

363
00:21:06,020 --> 00:21:10,410
But it is blocked by default
on most case, at least.

364
00:21:10,410 --> 00:21:14,670
When you were to make
asp as page only server,

365
00:21:14,670 --> 00:21:18,760
it will try to do it
included for web.config.

366
00:21:18,760 --> 00:21:22,210
It is not allowed because asp page filter,

367
00:21:22,210 --> 00:21:26,751
is enabled by default
and you block the encoder

368
00:21:26,751 --> 00:21:29,870
SSI site page and doesn't allow it.

369
00:21:29,870 --> 00:21:31,310
But as it turned out,

370
00:21:31,310 --> 00:21:34,467
there was a way to bypass that over this.

371
00:21:34,467 --> 00:21:36,300
Let's see this example.

372
00:21:36,300 --> 00:21:40,700
Here is a famous method parser control,

373
00:21:40,700 --> 00:21:44,330
which was introduced in Look
For Escape presentation,

374
00:21:44,330 --> 00:21:48,590
and it was in many environments
where the SharePoint.

375
00:21:48,590 --> 00:21:52,110
It will parse strings
to control the class.

376
00:21:52,110 --> 00:21:57,110
And it has the ability to
bypass the SPPageParserFilter.

377
00:21:57,640 --> 00:22:02,060
If for the second parameter
to the past control is true,

378
00:22:02,060 --> 00:22:05,460
to SPPageParserFilter will be ignored.

379
00:22:05,460 --> 00:22:09,590
In that way we could get an inquiry going.

380
00:22:09,590 --> 00:22:14,130
So we want to find a method
in which we'll call the parser

381
00:22:14,130 --> 00:22:16,760
control with a generic value.

382
00:22:16,760 --> 00:22:19,740
The data form will be part of controlling.

383
00:22:19,740 --> 00:22:22,663
It has a particular measure
called CreateChildControls.

384
00:22:23,559 --> 00:22:27,690
It is called when the other
control exists on that

385
00:22:27,690 --> 00:22:28,810
particular control.

386
00:22:28,810 --> 00:22:30,520
And inside this function,

387
00:22:30,520 --> 00:22:31,984
you call ParseControl.

388
00:22:31,984 --> 00:22:36,537
It is a good target if
we can met the flag too,

389
00:22:36,537 --> 00:22:39,850
and the flag generated from,

390
00:22:39,850 --> 00:22:42,450
verify SPD control markup.

391
00:22:42,450 --> 00:22:45,690
We have to satisfy to some validation

392
00:22:45,690 --> 00:22:48,116
to lose this call in a dangerous way.

393
00:22:48,116 --> 00:22:50,273
It has to be valid.

394
00:22:51,550 --> 00:22:56,208
Okay, first of all, it need
to be valid xml so we can,

395
00:22:56,208 --> 00:22:59,700
so we cannot register with this

396
00:22:59,700 --> 00:23:03,540
because it is not a valuable xml format.

397
00:23:03,540 --> 00:23:06,810
We also need to have runat=server,

398
00:23:06,810 --> 00:23:09,550
or it will be seen as client script

399
00:23:09,550 --> 00:23:13,130
and want to pass the verify control.

400
00:23:13,130 --> 00:23:15,720
It also need to be a safe controlled.

401
00:23:15,720 --> 00:23:19,760
It can contain things like
objected the shows controlled,

402
00:23:19,760 --> 00:23:21,653
which is a famous gathered.

403
00:23:23,040 --> 00:23:24,900
We create a panel that with

404
00:23:24,900 --> 00:23:27,000
use server-side inquiry instead,

405
00:23:27,000 --> 00:23:28,800
as you can see.

406
00:23:28,800 --> 00:23:32,339
It use (indistinct)

407
00:23:32,339 --> 00:23:34,670
Don't need to use any unsafe control

408
00:23:34,670 --> 00:23:36,810
or objectdatasource.

409
00:23:36,810 --> 00:23:39,674
And then we equaled the web.config file

410
00:23:39,674 --> 00:23:42,270
of that particular site.

411
00:23:42,270 --> 00:23:44,800
And that it will leak the validation key

412
00:23:44,800 --> 00:23:47,603
and give us remote code execution back.

413
00:23:50,320 --> 00:23:53,407
We've got a video demonstration here.

414
00:23:55,082 --> 00:23:57,249
(silence)

415
00:24:49,106 --> 00:24:51,218
Let's continue this presentation.

416
00:24:51,218 --> 00:24:55,020
Next, we will discuss
another type of attack.

417
00:24:55,020 --> 00:24:56,913
Server-side request forgery.

418
00:24:57,810 --> 00:25:01,170
Let's look at the vulnerable code example.

419
00:25:01,170 --> 00:25:04,988
This server will retrieve
the url we control.

420
00:25:04,988 --> 00:25:09,910
And park the url into a request object.

421
00:25:09,910 --> 00:25:13,830
Send the request and return the response.

422
00:25:13,830 --> 00:25:16,480
We can set the url to arbitrary address

423
00:25:16,480 --> 00:25:20,967
like web evaluator,
localhost, fileserver or other

424
00:25:20,967 --> 00:25:23,950
interesting http servers.

425
00:25:23,950 --> 00:25:27,160
We found many SSI vulnerabilities

426
00:25:27,160 --> 00:25:31,123
in SharePoint and will be discussed later.

427
00:25:32,960 --> 00:25:36,083
We found a very simple function CallOLS.

428
00:25:38,380 --> 00:25:43,190
If passed the parameter URL
of the mentioned SafeCreate

429
00:25:43,190 --> 00:25:45,420
to get a request option.

430
00:25:45,420 --> 00:25:49,050
And return the result of the request.

431
00:25:49,050 --> 00:25:52,190
It look very similar to
the vulnerability example

432
00:25:52,190 --> 00:25:54,020
mentioned earlier.

433
00:25:54,020 --> 00:25:56,120
Here, it can be considered

434
00:25:56,120 --> 00:25:59,133
as a wrapper of WebRequest.Create.

435
00:26:00,490 --> 00:26:02,700
If we can control this parameters

436
00:26:03,630 --> 00:26:06,453
here is a classical SSI vulnerability.

437
00:26:07,440 --> 00:26:09,150
At first we need to try

438
00:26:09,150 --> 00:26:11,553
whether we can access this method.

439
00:26:13,181 --> 00:26:16,543
Through the research of
official documentation online

440
00:26:18,120 --> 00:26:20,970
we found out that when method is marked

441
00:26:20,970 --> 00:26:23,797
as ClientCallableMethod it means that

442
00:26:23,797 --> 00:26:26,950
we can call you with an ftp request.

443
00:26:26,950 --> 00:26:28,580
The general format is

444
00:26:28,580 --> 00:26:32,353
/SP/NameSpace.ClientCallableType.ClientCallableMethod.

445
00:26:37,140 --> 00:26:39,470
So the path here should be

446
00:26:39,470 --> 00:26:44,470
/SP.HashtagStoreManager.CallOLS.

447
00:26:48,357 --> 00:26:51,780
Note that here is SP not SharePoint.

448
00:26:51,780 --> 00:26:54,390
As mentioned in there.

449
00:26:54,390 --> 00:26:57,270
And we can control all the parameters

450
00:26:57,270 --> 00:27:01,240
of the ClientCallableMethod function.

451
00:27:01,240 --> 00:27:05,960
So it's very simple to
write a proof of concern.

452
00:27:05,960 --> 00:27:09,640
Just add the url pattern for it.

453
00:27:09,640 --> 00:27:12,610
Then when it follows the
server to our address

454
00:27:12,610 --> 00:27:16,110
and return the result of url request.

455
00:27:16,110 --> 00:27:17,890
Actually, there are more things

456
00:27:17,890 --> 00:27:21,430
about the server-side request forgery.

457
00:27:21,430 --> 00:27:25,630
But for some reason we
cannot talk in this time.

458
00:27:25,630 --> 00:27:30,047
So the next thing we
will talk is XML Parsing.

459
00:27:30,047 --> 00:27:34,190
Xml is a very popular markup language.

460
00:27:34,190 --> 00:27:39,190
First vendor in the late 1990s

461
00:27:39,250 --> 00:27:44,030
and adopted by countless
software projects.

462
00:27:44,030 --> 00:27:48,671
It is used for configuration
files, document format,

463
00:27:48,671 --> 00:27:53,287
image format, and the network protocol.

464
00:27:53,287 --> 00:27:56,920
And it is so popular
that any problem about it

465
00:27:56,920 --> 00:28:00,243
will bring catastrophic result.

466
00:28:01,860 --> 00:28:05,930
In the process of parsing external entity

467
00:28:05,930 --> 00:28:10,930
the xml parser can query
various network protocols,

468
00:28:11,340 --> 00:28:16,340
and survive like a dos,
ftp, http, smb, and so on.

469
00:28:17,720 --> 00:28:20,710
According to this protocol

470
00:28:20,710 --> 00:28:23,230
specified in the EUIO

471
00:28:23,230 --> 00:28:25,880
external entities are very useful for

472
00:28:25,880 --> 00:28:29,840
creating generic levelers
in documentations.

473
00:28:29,840 --> 00:28:33,870
So that any change admitted
to the levelers results

474
00:28:33,870 --> 00:28:37,580
are automatically update in the document.

475
00:28:37,580 --> 00:28:40,010
According to official documents

476
00:28:40,010 --> 00:28:45,010
for lower versions of the .NET network.

477
00:28:45,110 --> 00:28:48,830
When reading xml test
container external entities

478
00:28:51,720 --> 00:28:53,693
will be automatically parsed.

479
00:28:54,780 --> 00:28:58,370
However, when dealing
with the external entities

480
00:28:58,370 --> 00:29:02,640
many attack can be launched
against the application.

481
00:29:02,640 --> 00:29:06,975
Those attacks include the
disclosure of local system files.

482
00:29:06,975 --> 00:29:11,004
Which may contain sensitive
data such as password,

483
00:29:11,004 --> 00:29:14,676
and private user data

484
00:29:14,676 --> 00:29:17,150
or the use of network SSL certificates

485
00:29:17,150 --> 00:29:22,150
various programs to manipulate
internet applications

486
00:29:23,642 --> 00:29:28,642
by combining those attacks
with other malicious code.

487
00:29:29,190 --> 00:29:32,400
The scope of this attack can be extended

488
00:29:32,400 --> 00:29:37,065
to server interruption and
even eventually code execution,

489
00:29:37,065 --> 00:29:40,928
depending on the content of those attacks.

490
00:29:40,928 --> 00:29:45,928
We call these attack types
xml external entity attack.

491
00:29:48,680 --> 00:29:52,660
We also share a simple
vulnerability code example.

492
00:29:52,660 --> 00:29:55,326
The code snippet show the classical

493
00:29:55,326 --> 00:29:59,630
xmldocument.load xml method.

494
00:30:00,798 --> 00:30:04,620
It will receive an xml container

495
00:30:04,620 --> 00:30:07,410
parsing to xml document object

496
00:30:08,860 --> 00:30:12,573
The dtt definition will
be executed when parsing.

497
00:30:14,389 --> 00:30:17,359
There are also many ways to pase xml.

498
00:30:17,359 --> 00:30:19,393
Like XPathDocument,
DataSet.LoadXML, and so on.

499
00:30:25,192 --> 00:30:28,940
In order to decode the
problem caused by SSE.

500
00:30:29,907 --> 00:30:34,907
Microsoft recommends that
users use XML evaluator

501
00:30:34,920 --> 00:30:38,030
to evaluate xml test before loading.

502
00:30:38,030 --> 00:30:43,030
And prohibit the parsing
of external entity.

503
00:30:43,199 --> 00:30:46,480
Or upgrade to higher
version of .NET framework

504
00:30:47,730 --> 00:30:50,623
which will not parse
external entity by default.

505
00:30:53,560 --> 00:30:56,310
But we will check
SharePoint will follow that.

506
00:30:57,670 --> 00:31:01,460
The .NET version of SharePoint that is 4.0

507
00:31:02,330 --> 00:31:05,180
in SharePoint 2019.

508
00:31:05,180 --> 00:31:08,100
Which means that we were likely to find

509
00:31:08,100 --> 00:31:09,913
SSE vulnerability in it.

510
00:31:10,890 --> 00:31:13,237
Here is our finding of SSE.

511
00:31:15,768 --> 00:31:19,190
This regional vulnerability
patterns can often

512
00:31:19,190 --> 00:31:23,241
bring destabalized. We found unmentioned

513
00:31:23,241 --> 00:31:27,658
GetPluginContent which will
call xmlDocument.Loadxml.

514
00:31:30,463 --> 00:31:33,947
Like our examples it
will read the container

515
00:31:33,947 --> 00:31:38,280
in the public in file and
parse it as xml container.

516
00:31:40,080 --> 00:31:44,520
Okay, let's take a quick
look at the call state,

517
00:31:44,520 --> 00:31:46,303
which appears to be accessible.

518
00:31:47,260 --> 00:31:48,983
We need to analyze the method.

519
00:31:51,080 --> 00:31:53,800
First, it will traverse all files in

520
00:31:53,800 --> 00:31:57,713
/_catalogs/wp directory.

521
00:31:58,747 --> 00:32:00,280
We need to create a file.

522
00:32:00,280 --> 00:32:03,710
The files here includes
all files in database

523
00:32:03,710 --> 00:32:07,340
and file system because it is SPFile

524
00:32:07,340 --> 00:32:10,883
which is another of the
file object by SharedPoint.

525
00:32:11,930 --> 00:32:15,387
Then looking for the file
that the send filename

526
00:32:15,387 --> 00:32:17,568
as the parameter we set.

527
00:32:17,568 --> 00:32:20,627
Then its content is passed into Loadxml.

528
00:32:22,420 --> 00:32:27,320
Including the visual file in
the database is good news.

529
00:32:27,320 --> 00:32:30,190
Users now have permissions to upload

530
00:32:30,190 --> 00:32:33,060
such files on their website.

531
00:32:33,060 --> 00:32:35,770
If it can only load the
files in the file systems

532
00:32:35,770 --> 00:32:38,763
we will not be able to do anything.

533
00:32:40,290 --> 00:32:45,290
So therefore the first step in
exploiting the vulnerability

534
00:32:45,750 --> 00:32:50,079
is to upload a xxe file. We are sure it is

535
00:32:50,079 --> 00:32:54,712
xxe.webpart which contain xxe payload.

536
00:32:54,712 --> 00:32:58,650
Note that the file need
to end with a .webpart.

537
00:33:00,534 --> 00:33:03,540
But how to make the server load this file?

538
00:33:03,540 --> 00:33:07,390
Let's go back to the call
state and take a closer look

539
00:33:07,390 --> 00:33:10,033
at the function in the live post.

540
00:33:10,880 --> 00:33:15,880
We notice that he has a special
attribute ClientCallable.

541
00:33:16,394 --> 00:33:18,670
What does it contain here?

542
00:33:18,670 --> 00:33:22,010
It is similar to ClientCallableMethod

543
00:33:22,010 --> 00:33:25,580
that we mentioned earlier
but it is not the same.

544
00:33:25,580 --> 00:33:29,600
It means that we can
call it using client-side

545
00:33:29,600 --> 00:33:31,433
SharePoint Object Model API.

546
00:33:33,040 --> 00:33:37,330
CSOM stand for SharePoint
client object model

547
00:33:37,330 --> 00:33:41,430
and is used to insert, update, delete,

548
00:33:41,430 --> 00:33:43,173
and retrieve data in SharePoint.

549
00:33:44,020 --> 00:33:48,700
Microsoft provided various
client object model like

550
00:33:48,700 --> 00:33:52,807
Javascript models, SharePoint
REST API, SharePoint

551
00:33:52,807 --> 00:33:55,623
.NET client object model.

552
00:33:56,797 --> 00:34:00,710
Then we will not use the
last one, SharePoint .NET

553
00:34:00,710 --> 00:34:02,830
client object model.

554
00:34:02,830 --> 00:34:05,448
When we use debug tools to debug it

555
00:34:05,448 --> 00:34:09,010
we found that every
ClientCallable function

556
00:34:09,010 --> 00:34:11,270
has a paired remote function.

557
00:34:11,270 --> 00:34:15,890
The calling process starts
from the client code passes

558
00:34:15,890 --> 00:34:19,061
so that the remote
method of the same name.

559
00:34:19,061 --> 00:34:23,243
And then send the data to
the server so xml format.

560
00:34:23,243 --> 00:34:28,240
The server parser the xml
and find the policy method

561
00:34:28,240 --> 00:34:33,240
of the corresponding
method invoke state method.

562
00:34:34,690 --> 00:34:38,010
And finally fall to the
ClientCallable method

563
00:34:38,010 --> 00:34:40,053
to complete the method called.

564
00:34:41,180 --> 00:34:45,911
Now, we can start writing the
second part of the exploiting.

565
00:34:45,911 --> 00:34:48,540
(indistinct) relayed there of CSOM.

566
00:34:50,050 --> 00:34:52,500
And we need to pass this server url

567
00:34:52,500 --> 00:34:57,130
and the user's credential
to gain a client contents.

568
00:34:57,130 --> 00:35:00,230
Then use the contents
to load the plugin file

569
00:35:00,230 --> 00:35:01,880
that we created before.

570
00:35:01,880 --> 00:35:04,420
And here, we set it to xxe.

571
00:35:04,420 --> 00:35:07,450
Finally, we should call ExecuteQuery

572
00:35:07,450 --> 00:35:11,170
to package all the data
and send the request.

573
00:35:11,170 --> 00:35:14,743
Which can trigger GetPlugin
method as we want it.

574
00:35:15,990 --> 00:35:17,730
After testing this vulnerability

575
00:35:17,730 --> 00:35:20,520
that can also work on SharePoint Online.

576
00:35:20,520 --> 00:35:25,520
An example of loading
window in SharePoint Online

577
00:35:26,180 --> 00:35:29,574
and our demo of proof of concern is here.

578
00:35:29,574 --> 00:35:31,741
(silence)

579
00:36:33,491 --> 00:36:36,170
But if you notice that we called it as xxe

580
00:36:36,170 --> 00:36:39,170
instead of remote call execution.

581
00:36:39,170 --> 00:36:44,170
Because it is only 01%&
remote call execution.

582
00:36:45,078 --> 00:36:50,078
We found that that &
character in the web.cofig.

583
00:36:50,440 --> 00:36:55,440
According to the same task
of the external entity.

584
00:36:55,680 --> 00:36:58,969
It will be considered
as an entity definition

585
00:36:58,969 --> 00:37:02,610
but there is no specific
name defined later.

586
00:37:02,610 --> 00:37:06,182
This will cause parsing
error and able to load

587
00:37:06,182 --> 00:37:09,450
content of web.config normally.

588
00:37:09,450 --> 00:37:12,240
If someone can bypass this shortcoming for

589
00:37:12,240 --> 00:37:16,850
invalid remote code
execution exploitation,

590
00:37:16,850 --> 00:37:19,280
please share your tips with us.

591
00:37:19,280 --> 00:37:23,210
Anyway, it is a real interesting

592
00:37:23,210 --> 00:37:26,493
because it appeared in
SharePoint client code.

593
00:37:28,110 --> 00:37:31,630
Then we have discussed the security issue

594
00:37:31,630 --> 00:37:33,870
of the server side.

595
00:37:33,870 --> 00:37:35,410
They are often very powerful

596
00:37:35,410 --> 00:37:38,430
and don't need any user intervention.

597
00:37:38,430 --> 00:37:42,064
Next, we will assure that
we have a user intervention.

598
00:37:42,064 --> 00:37:47,064
A victim will open the url
he send in his java server.

599
00:37:47,493 --> 00:37:51,850
How to achieve an account takeover attack?

600
00:37:51,850 --> 00:37:56,630
Server has a variety of
user authentication methods,

601
00:37:56,630 --> 00:38:01,630
including NTLM, fba, Oauth and so on.

602
00:38:02,920 --> 00:38:04,770
So, let's check the fba.

603
00:38:05,673 --> 00:38:08,640
Form-based authentication.

604
00:38:08,640 --> 00:38:12,576
Here is the login form and fba is a

605
00:38:12,576 --> 00:38:15,170
form-based identity authentication.

606
00:38:15,170 --> 00:38:19,690
Httd authentication is
passed to SharePoint server

607
00:38:19,690 --> 00:38:24,690
will set a cookie for
users, rtFa & FedAuth.

608
00:38:24,690 --> 00:38:27,810
If we obtain the cookie of other users

609
00:38:27,810 --> 00:38:30,530
we can forge user identities.

610
00:38:30,530 --> 00:38:33,830
But the cookies have activity only specs

611
00:38:33,830 --> 00:38:38,830
so we can't use java script to
call it to steal it directly.

612
00:38:39,130 --> 00:38:43,175
And users with the same
cookies can access both

613
00:38:43,175 --> 00:38:46,340
admin panel and site collection

614
00:38:46,340 --> 00:38:48,990
if they have enough privilege.

615
00:38:48,990 --> 00:38:51,670
However, as we talked before

616
00:38:51,670 --> 00:38:54,260
we don't just own the javascript.

617
00:38:54,260 --> 00:38:56,920
We will introduce a vulnerability

618
00:38:56,920 --> 00:39:01,040
that steal cookies
stored parameter validly.

619
00:39:01,040 --> 00:39:05,670
For this vulnerability we need
to show the problem first.

620
00:39:05,670 --> 00:39:07,423
The addition to the request header.

621
00:39:08,700 --> 00:39:12,618
Where does that cookie
exist? Can we get it?

622
00:39:12,618 --> 00:39:17,618
In Microsoft documentation
a special value is recorded.

623
00:39:17,777 --> 00:39:22,610
IIS server variables provide
information about the server,

624
00:39:24,710 --> 00:39:27,277
the connection with the client,

625
00:39:27,277 --> 00:39:29,916
and the current request on the connection.

626
00:39:29,916 --> 00:39:32,671
IIS server variables are not the same

627
00:39:32,671 --> 00:39:36,010
as environment variables.

628
00:39:36,010 --> 00:39:39,017
Here is the value that
we need, http cookie.

629
00:39:39,017 --> 00:39:44,017
With any cookie string that
was encoded with the request.

630
00:39:44,990 --> 00:39:48,580
Okay, we find another page to get cookie

631
00:39:48,580 --> 00:39:51,390
but it is a server values.

632
00:39:51,390 --> 00:39:53,640
We need to put it embed with the page.

633
00:39:53,640 --> 00:39:55,583
When reading some sever-side codes

634
00:39:55,583 --> 00:39:59,260
we noticed that there is a special syntax

635
00:39:59,260 --> 00:40:00,523
called ParameterBinding,

636
00:40:01,999 --> 00:40:04,487
a resource can be bound to parameter

637
00:40:04,487 --> 00:40:09,487
value in the current
vendor xsl style sheet.

638
00:40:10,900 --> 00:40:13,950
The ParameterBinding element encoded are

639
00:40:13,950 --> 00:40:18,950
location attribute that
specify resource time.

640
00:40:19,230 --> 00:40:22,310
The same task for this element is similar

641
00:40:22,310 --> 00:40:27,050
to the SPResourceBinding
expression syntax.

642
00:40:27,050 --> 00:40:30,680
The location value is
expressed as a function.

643
00:40:30,680 --> 00:40:35,680
We can use the location attribute
to specify the values for

644
00:40:36,150 --> 00:40:40,273
server-side query strings, server values,

645
00:40:40,273 --> 00:40:44,890
webpart properties, control ids and so on.

646
00:40:44,890 --> 00:40:47,963
So, we can look at this process.

647
00:40:48,890 --> 00:40:52,980
When we send a request to the poc page

648
00:40:52,980 --> 00:40:56,680
the server will stop our
cookie in http_cookie

649
00:40:58,556 --> 00:41:01,850
slow ParameterBinding and bind it

650
00:41:02,730 --> 00:41:05,760
into DataFormWebPart value.

651
00:41:05,760 --> 00:41:08,343
And finally display it in page.

652
00:41:09,190 --> 00:41:12,910
So here is the proof of consent.

653
00:41:12,910 --> 00:41:16,313
We render the cookie
back to the xsl value.

654
00:41:17,310 --> 00:41:21,250
Therefore, we have the
ability to bring the cookies

655
00:41:21,250 --> 00:41:23,680
to the client-side page.

656
00:41:23,680 --> 00:41:26,630
Then we can we can read the page script

657
00:41:26,630 --> 00:41:28,253
without restrictions.

658
00:41:29,090 --> 00:41:34,040
Use XMLHttpRequest to
fetch the value of cookie

659
00:41:34,040 --> 00:41:35,863
and send it to our servers.

660
00:41:37,260 --> 00:41:40,150
And then check the servers request.

661
00:41:40,150 --> 00:41:43,300
You can see that all the
cookies are sent contains

662
00:41:43,300 --> 00:41:47,480
rtFA and FedAuth that
you can use to access

663
00:41:47,480 --> 00:41:49,313
the site of victims.

664
00:41:51,260 --> 00:41:55,687
So here is our conclusion
of today's presentation.

665
00:41:55,687 --> 00:42:00,687
The about all the vulnerabilities
disclosure in our sharing.

666
00:42:01,180 --> 00:42:04,870
From the server to the
client we have studied many

667
00:42:04,870 --> 00:42:08,167
interesting traits of
SharePoint and most of the

668
00:42:08,167 --> 00:42:11,467
vulnerabilities are based
on the permission we have

669
00:42:11,467 --> 00:42:13,590
to upload page.

670
00:42:13,590 --> 00:42:17,340
We've been able to find many
vulnerabilities in SharePoint

671
00:42:17,340 --> 00:42:19,990
because of these virtual (indistinct)

672
00:42:19,990 --> 00:42:23,030
When you give users more permission,

673
00:42:23,030 --> 00:42:25,411
your system is more dangerous.

674
00:42:25,411 --> 00:42:29,073
User created content that
can interact with server-side

675
00:42:29,073 --> 00:42:33,973
controls has the potential to
cause some trusted violence.

676
00:42:35,400 --> 00:42:38,530
It is hard to build a strong enough filter

677
00:42:38,530 --> 00:42:41,150
to protect this instance.

678
00:42:41,150 --> 00:42:46,150
And multiple API give users
different access methods

679
00:42:46,820 --> 00:42:50,960
and give an attacker
a large attack surface

680
00:42:50,960 --> 00:42:52,840
for discovery tool.

681
00:42:52,840 --> 00:42:56,920
So, this is the end of our presentation.

682
00:42:56,920 --> 00:42:58,540
Thank you for listening.

683
00:42:58,540 --> 00:43:00,583
Feel free to ask any questions.

