1
00:00:01,570 --> 00:00:02,403
- Hello.

2
00:00:02,403 --> 00:00:03,280
I am Mathy Vanhoef

3
00:00:03,280 --> 00:00:05,130
and together with Tom Van Goethem,

4
00:00:05,130 --> 00:00:08,263
we will be presenting
Timeless Timing Attacks.

5
00:00:09,205 --> 00:00:10,710
Tom Van Goethem is a researcher

6
00:00:10,710 --> 00:00:14,378
at the DistriNet group
in KU Leuven in Belgium.

7
00:00:14,378 --> 00:00:18,050
He is a fanatic web and
network security enthusiast,

8
00:00:18,050 --> 00:00:19,600
and he likes to exploit

9
00:00:19,600 --> 00:00:21,770
side channel leaks in browsers,

10
00:00:21,770 --> 00:00:25,640
and more general in
Web platforms, as well.

11
00:00:25,640 --> 00:00:26,510
I am Mathy Vanhoef.

12
00:00:26,510 --> 00:00:29,770
I'm a postdoc at NYU, Abu Dhabi,

13
00:00:29,770 --> 00:00:31,340
and I'll, later this year,

14
00:00:31,340 --> 00:00:34,740
be starting as a professor
at KU Leuven in Belgium.

15
00:00:34,740 --> 00:00:37,370
I'm interested in wireless
on network security

16
00:00:37,370 --> 00:00:38,790
and software security,

17
00:00:38,790 --> 00:00:41,880
and also a bit in applied crypto.

18
00:00:41,880 --> 00:00:42,713
Previously,

19
00:00:42,713 --> 00:00:45,360
I discovered a KRACK attack against WPA2,

20
00:00:45,360 --> 00:00:48,087
and the RC4 NOMORE attack.

21
00:00:49,614 --> 00:00:50,570
And in this presentation

22
00:00:50,570 --> 00:00:54,440
we'll be talking about timing
attacks and timing leaks.

23
00:00:54,440 --> 00:00:58,943
Let me start with some
examples of timing leaks.

24
00:00:59,885 --> 00:01:00,980
In the top left corner

25
00:01:00,980 --> 00:01:03,150
we can see a straightforward timing leak

26
00:01:03,150 --> 00:01:06,740
where depending on some secret condition,

27
00:01:06,740 --> 00:01:08,833
extra computation is performed.

28
00:01:10,120 --> 00:01:12,590
And here, the execution time,

29
00:01:12,590 --> 00:01:15,150
so also the response
time of, for instance,

30
00:01:15,150 --> 00:01:17,020
the web application will leak

31
00:01:17,020 --> 00:01:19,653
whether the condition was true or false.

32
00:01:20,820 --> 00:01:21,653
The top right,

33
00:01:21,653 --> 00:01:24,110
we have a for-loop that iterates

34
00:01:24,110 --> 00:01:26,850
through all the elements in an array

35
00:01:26,850 --> 00:01:28,790
and the for-loop is terminated

36
00:01:28,790 --> 00:01:32,793
once an element is found with
a certain secret condition.

37
00:01:34,300 --> 00:01:35,133
In other words,

38
00:01:35,133 --> 00:01:38,470
the number of iterations
that are being executed,

39
00:01:38,470 --> 00:01:41,840
depend on some kind of secret information,

40
00:01:41,840 --> 00:01:43,010
and this, again,

41
00:01:43,010 --> 00:01:47,570
also means that the execution
time of this for-loop

42
00:01:47,570 --> 00:01:51,023
leaks sensitive information
to an adversary.

43
00:01:52,570 --> 00:01:54,370
Finally, at the bottom,

44
00:01:54,370 --> 00:01:56,720
we have an if test that checks

45
00:01:56,720 --> 00:01:58,670
whether an array is empty or not

46
00:01:58,670 --> 00:02:00,550
and if it is not empty,

47
00:02:00,550 --> 00:02:03,200
extra computation is performed.

48
00:02:03,200 --> 00:02:05,810
And here, you can imagine a web app

49
00:02:05,810 --> 00:02:07,490
where you can search

50
00:02:07,490 --> 00:02:10,500
through secret documents using a key word

51
00:02:10,500 --> 00:02:12,150
And then this code would leak

52
00:02:12,150 --> 00:02:14,510
whether this keyword is present

53
00:02:14,510 --> 00:02:16,993
in a secret document or not.

54
00:02:19,350 --> 00:02:23,390
How are these timing leaks
exploited in practice?

55
00:02:23,390 --> 00:02:25,700
Well, the attacker would
first need to connect

56
00:02:25,700 --> 00:02:28,170
to the target server.

57
00:02:28,170 --> 00:02:29,510
The attacker then sends

58
00:02:29,510 --> 00:02:33,750
a possibly large amount
of requests to the server.

59
00:02:33,750 --> 00:02:35,340
And for each request,

60
00:02:35,340 --> 00:02:37,100
the server will measure

61
00:02:37,100 --> 00:02:40,203
how long it takes to receive a response.

62
00:02:41,250 --> 00:02:43,030
And then the attacker will compare

63
00:02:43,030 --> 00:02:44,590
two sets of

64
00:02:45,670 --> 00:02:46,680
timing measurements,

65
00:02:46,680 --> 00:02:50,040
namely the baseline on the target.

66
00:02:50,040 --> 00:02:52,440
And what do I mean with baseline here?

67
00:02:52,440 --> 00:02:54,430
Well, with baseline,

68
00:02:54,430 --> 00:02:55,300
I, for instance,

69
00:02:55,300 --> 00:02:57,860
mean the first example here,

70
00:02:57,860 --> 00:03:01,010
where then the secret condition

71
00:03:01,010 --> 00:03:02,287
evaluates to false,

72
00:03:02,287 --> 00:03:03,790
and the adversary knows

73
00:03:03,790 --> 00:03:07,009
that the secret condition
evaluates to false.

74
00:03:07,009 --> 00:03:10,430
And the adversary will
use that as a baseline

75
00:03:11,280 --> 00:03:14,110
and the target request is then a request

76
00:03:14,110 --> 00:03:16,360
where the adversary doesn't know

77
00:03:16,360 --> 00:03:19,033
what the secret condition evaluates to,

78
00:03:19,920 --> 00:03:22,370
but based on the response time,

79
00:03:22,370 --> 00:03:24,130
the adversary can then derive

80
00:03:24,130 --> 00:03:27,540
whether the secret condition
and the target request

81
00:03:27,540 --> 00:03:29,050
is also false,

82
00:03:29,050 --> 00:03:32,203
or whether it is in fact true.

83
00:03:33,436 --> 00:03:36,860
And to check whether there is a difference

84
00:03:36,860 --> 00:03:40,130
between the baseline of the target request

85
00:03:40,130 --> 00:03:43,040
we will be using statistical tests

86
00:03:43,040 --> 00:03:44,500
to determine whether there really is

87
00:03:44,500 --> 00:03:46,653
a significant difference or not.

88
00:03:49,120 --> 00:03:50,410
There are several factors

89
00:03:50,410 --> 00:03:54,540
that influence the success
rate of a timing attack.

90
00:03:54,540 --> 00:03:56,870
The first one is the network connection

91
00:03:56,870 --> 00:04:00,948
between the attacker
and the victim server.

92
00:04:00,948 --> 00:04:01,970
And in particular,

93
00:04:01,970 --> 00:04:04,900
the higher the jitter of this connection,

94
00:04:04,900 --> 00:04:08,374
the worse the performance
of the timing attack.

95
00:04:08,374 --> 00:04:10,080
Now, the attacker can mitigate this

96
00:04:10,080 --> 00:04:11,360
to some extent by,

97
00:04:11,360 --> 00:04:14,013
for instance, moving closer to the target.

98
00:04:14,950 --> 00:04:19,490
So in practice that
could be renting a server

99
00:04:19,490 --> 00:04:21,370
in the same cloud provider

100
00:04:21,370 --> 00:04:23,163
where the victim is also located.

101
00:04:25,170 --> 00:04:27,480
And I also want to remark here

102
00:04:27,480 --> 00:04:31,040
that the jitter is present
both on the upstream path,

103
00:04:31,040 --> 00:04:32,187
so in the requests,

104
00:04:32,187 --> 00:04:33,950
and in the downstream path,

105
00:04:33,950 --> 00:04:35,393
so in the responses.

106
00:04:36,690 --> 00:04:40,840
Another important factor is
the size of the timing leak.

107
00:04:40,840 --> 00:04:44,320
So it's much easier to
exploit a large timing leak,

108
00:04:44,320 --> 00:04:46,420
say, of 50 milliseconds

109
00:04:46,420 --> 00:04:49,130
than it is to exploit
a small timing leak of,

110
00:04:49,130 --> 00:04:51,463
say, five microseconds.

111
00:04:52,370 --> 00:04:53,203
And finally,

112
00:04:53,203 --> 00:04:54,530
the last important factor

113
00:04:54,530 --> 00:04:58,410
is the number of measurements
that on adversary can make.

114
00:04:58,410 --> 00:04:59,243
In particular,

115
00:04:59,243 --> 00:05:02,570
the more timing measurements
that an adversary can make,

116
00:05:02,570 --> 00:05:05,803
the better the performance
of the timing attack will be.

117
00:05:06,837 --> 00:05:07,882
And Tom will now show

118
00:05:07,882 --> 00:05:11,902
a graphical illustration
of a timing attack.

119
00:05:11,902 --> 00:05:14,690
- Thank you for that introduction, Mathy.

120
00:05:14,690 --> 00:05:15,690
So now let's see how

121
00:05:15,690 --> 00:05:19,160
such a remote timing attack works

122
00:05:19,160 --> 00:05:21,730
with a visual representation.

123
00:05:21,730 --> 00:05:23,950
So we have our attacker on the left side,

124
00:05:23,950 --> 00:05:26,363
sending the request to the server.

125
00:05:27,597 --> 00:05:29,360
And this request goes over the Internet,

126
00:05:29,360 --> 00:05:31,170
then is processed by the server,

127
00:05:31,170 --> 00:05:33,220
a responses is generated,

128
00:05:33,220 --> 00:05:34,963
and sent back to the attacker

129
00:05:34,963 --> 00:05:38,310
and the attacker will then
measure how long it took

130
00:05:39,650 --> 00:05:43,370
between sending the request
and receiving the response.

131
00:05:43,370 --> 00:05:44,470
And in this case,

132
00:05:44,470 --> 00:05:46,653
this was a bit over three seconds.

133
00:05:48,010 --> 00:05:52,610
Then the attacker stores
this timing value,

134
00:05:52,610 --> 00:05:57,190
and then he will probably need
to make multiple requests.

135
00:05:57,190 --> 00:06:00,640
So he starts sending the next request.

136
00:06:00,640 --> 00:06:02,600
But here on the third hop,

137
00:06:02,600 --> 00:06:05,030
there was a small delay,

138
00:06:05,030 --> 00:06:09,453
also causing a delay in the
arrival of the response.

139
00:06:10,490 --> 00:06:13,900
So this means that because of this jitter

140
00:06:14,790 --> 00:06:18,310
the attacker will need to
make multiple measurements

141
00:06:18,310 --> 00:06:19,143
and then

142
00:06:21,040 --> 00:06:24,180
apply some statistical analysis

143
00:06:24,180 --> 00:06:25,340
in order to reveal

144
00:06:25,340 --> 00:06:28,583
the true processing time of the server.

145
00:06:31,900 --> 00:06:33,570
We did some measurements

146
00:06:33,570 --> 00:06:34,720
to see how many requests

147
00:06:34,720 --> 00:06:36,793
the attacker would actually require.

148
00:06:38,350 --> 00:06:39,940
We varied

149
00:06:39,940 --> 00:06:41,550
the number,

150
00:06:41,550 --> 00:06:44,720
or the difference in timing

151
00:06:44,720 --> 00:06:46,290
of the processing time

152
00:06:47,340 --> 00:06:51,010
between five microseconds
and 50 microseconds.

153
00:06:51,010 --> 00:06:53,180
And then we determined how many requests

154
00:06:53,180 --> 00:06:57,263
an attacker would need to
achieve a 95% accuracy.

155
00:06:58,890 --> 00:07:01,670
Our attacker was located

156
00:07:01,670 --> 00:07:04,100
in our university network

157
00:07:04,100 --> 00:07:05,547
located in Belgium,

158
00:07:05,547 --> 00:07:08,693
and then we set up
servers across the world.

159
00:07:10,566 --> 00:07:12,210
And then we performed the attack

160
00:07:12,210 --> 00:07:15,623
to see how many requests were required.

161
00:07:17,300 --> 00:07:21,030
To detect a timing
difference of 50 microseconds

162
00:07:22,440 --> 00:07:24,230
with a server in the EU,

163
00:07:24,230 --> 00:07:27,163
with the attacker also located in the EU,

164
00:07:28,478 --> 00:07:32,540
a total of 333 requests were required.

165
00:07:32,540 --> 00:07:36,060
Now when the server was further away,

166
00:07:36,060 --> 00:07:36,930
so for instance,

167
00:07:36,930 --> 00:07:39,810
when it was located in the U.S.

168
00:07:39,810 --> 00:07:41,303
more requests were required.

169
00:07:42,212 --> 00:07:44,733
In this case, for 50 microseconds,

170
00:07:45,980 --> 00:07:49,750
well over 4,000 requests were required

171
00:07:49,750 --> 00:07:51,433
to detect this difference.

172
00:07:54,586 --> 00:07:55,419
You can also see

173
00:07:55,419 --> 00:07:59,060
that as the timing
difference became smaller.

174
00:07:59,060 --> 00:08:02,633
also the attacker required
more measurements.

175
00:08:05,750 --> 00:08:07,220
For 20 microseconds,

176
00:08:07,220 --> 00:08:11,540
it was close to 3,000
requests that where needed

177
00:08:11,540 --> 00:08:13,620
for the server in EU,

178
00:08:13,620 --> 00:08:14,480
growing to

179
00:08:16,137 --> 00:08:18,720
23,000 for 10 microseconds.

180
00:08:18,720 --> 00:08:22,180
And for a timing difference
of five microseconds,

181
00:08:22,180 --> 00:08:25,800
we found that it was
not possible to do this

182
00:08:26,845 --> 00:08:30,283
with the maximum set to 100,000 requests.

183
00:08:35,680 --> 00:08:38,320
We were thinking how can we

184
00:08:38,320 --> 00:08:41,180
improve these remote timing attacks?

185
00:08:41,180 --> 00:08:44,573
And that's how we came to
timeless timing attacks.

186
00:08:46,590 --> 00:08:50,650
We know that if we rely on

187
00:08:50,650 --> 00:08:52,590
absolute response timing,

188
00:08:52,590 --> 00:08:55,620
this will not be very reliable

189
00:08:55,620 --> 00:08:59,150
because there will be always

190
00:08:59,150 --> 00:09:02,490
this jitter that's
included in every request

191
00:09:05,012 --> 00:09:06,120
because the request

192
00:09:06,120 --> 00:09:09,000
needs to traverse over the Internet,

193
00:09:09,000 --> 00:09:11,460
and so does the response.

194
00:09:11,460 --> 00:09:12,640
Then we thought, okay,

195
00:09:12,640 --> 00:09:15,853
then maybe let's get rid
of the notion of time.

196
00:09:16,920 --> 00:09:19,343
That's why we call these attack timeless.

197
00:09:20,250 --> 00:09:22,080
So instead of relying on

198
00:09:22,080 --> 00:09:25,120
the sequential timing measurements,

199
00:09:25,120 --> 00:09:27,740
we can try to explore to concurrency

200
00:09:27,740 --> 00:09:32,270
and only consider the
order of the responses.

201
00:09:32,270 --> 00:09:33,800
We don't use any

202
00:09:33,800 --> 00:09:36,380
absolute timing measurements anymore

203
00:09:36,380 --> 00:09:38,080
in these timing and measurements.

204
00:09:38,080 --> 00:09:40,293
We just look at the response order.

205
00:09:41,690 --> 00:09:42,810
And this means,

206
00:09:42,810 --> 00:09:45,760
as a very important side effect

207
00:09:45,760 --> 00:09:47,520
is that these timeless timing attacks

208
00:09:47,520 --> 00:09:49,963
are completely unaffected
by network jitter.

209
00:09:52,240 --> 00:09:55,133
So let's see how this works in practice.

210
00:09:56,568 --> 00:09:59,171
Again, we have our attacker on the server.

211
00:09:59,171 --> 00:10:02,280
But now the attacker is not
just sending one request,

212
00:10:02,280 --> 00:10:04,440
but he will be sending two requests

213
00:10:04,440 --> 00:10:06,343
that are contained in the same packet.

214
00:10:08,200 --> 00:10:09,210
These two requests

215
00:10:09,210 --> 00:10:12,090
arrive simultaneously at the server

216
00:10:12,090 --> 00:10:14,313
and are processed concurrently,

217
00:10:15,510 --> 00:10:19,040
and because the light pink requests

218
00:10:19,040 --> 00:10:21,890
took less time to process

219
00:10:21,890 --> 00:10:25,630
the light blue response
will be generated first

220
00:10:25,630 --> 00:10:27,423
and sent first to the attacker,

221
00:10:28,660 --> 00:10:31,127
allowing the attacker to detect that

222
00:10:34,199 --> 00:10:37,503
these requests required
less processing time.

223
00:10:39,470 --> 00:10:40,960
If in this case,

224
00:10:40,960 --> 00:10:43,640
we have some jitter on
the way to the server

225
00:10:44,560 --> 00:10:45,780
it will not affect

226
00:10:49,470 --> 00:10:50,303
anything

227
00:10:50,303 --> 00:10:54,120
because both requests will still arrive

228
00:10:54,120 --> 00:10:56,080
exactly at the same time at the server,

229
00:10:56,080 --> 00:10:59,293
because they're contained
in a single packet.

230
00:11:00,160 --> 00:11:03,763
And then they can be
processed simultaneously

231
00:11:05,719 --> 00:11:07,309
at the server site.

232
00:11:07,309 --> 00:11:10,142
And again, we see the same result.

233
00:11:11,810 --> 00:11:12,860
- Thank you, Tom.

234
00:11:12,860 --> 00:11:15,840
So what are the requirements
of a timeless timing attack?

235
00:11:15,840 --> 00:11:17,710
Well, first of all,

236
00:11:17,710 --> 00:11:19,170
the requests need to arrive

237
00:11:19,170 --> 00:11:22,150
at the same time at the server.

238
00:11:22,150 --> 00:11:25,550
The server needs to process
these requests in parallel,

239
00:11:25,550 --> 00:11:27,520
so, concurrently.

240
00:11:27,520 --> 00:11:29,390
And the order of the responses

241
00:11:29,390 --> 00:11:31,290
needs to reflect the difference

242
00:11:31,290 --> 00:11:33,823
in the execution time on the server.

243
00:11:35,270 --> 00:11:39,833
Now let's explore these three
requirements in more detail.

244
00:11:41,202 --> 00:11:42,270
The first requirement

245
00:11:43,620 --> 00:11:47,780
that both requests arrive
simultaneously at the server

246
00:11:47,780 --> 00:11:50,690
can be fulfilled in two manners.

247
00:11:50,690 --> 00:11:51,523
Namely,

248
00:11:51,523 --> 00:11:54,610
we can either rely on multiplexing

249
00:11:54,610 --> 00:11:57,410
or on encapsulation.

250
00:11:57,410 --> 00:11:58,910
And with multiplexing,

251
00:11:58,910 --> 00:12:02,423
our example is the HTTP/2 protocol,

252
00:12:03,463 --> 00:12:06,170
and this is because with
the HTTP/2 protocol,

253
00:12:06,170 --> 00:12:10,090
two requests can be sent simultaneously

254
00:12:10,090 --> 00:12:12,700
over the same connection.

255
00:12:12,700 --> 00:12:13,533
In fact,

256
00:12:13,533 --> 00:12:18,530
a single TCP packet can carry
multiple HTTP/2 requests

257
00:12:18,530 --> 00:12:20,480
that will be processed concurrently

258
00:12:20,480 --> 00:12:22,513
once they arrive at the server.

259
00:12:24,380 --> 00:12:25,510
For encapsulation,

260
00:12:25,510 --> 00:12:29,100
there our example is the HTTP/1 protocol

261
00:12:29,100 --> 00:12:32,160
because the HTTP/1 protocol on its own

262
00:12:32,160 --> 00:12:36,300
does not allow you to send
two requests in parallel.

263
00:12:36,300 --> 00:12:37,133
However,

264
00:12:37,133 --> 00:12:40,500
when we exploit HTTP/1 over Tor,

265
00:12:40,500 --> 00:12:42,100
or over VPN,

266
00:12:42,100 --> 00:12:45,300
then we can send two HTTP requests

267
00:12:45,300 --> 00:12:47,280
at the same time over Tor

268
00:12:47,280 --> 00:12:49,073
or over the VPN network.

269
00:12:50,270 --> 00:12:53,073
Let me illustrate these
two cases graphically.

270
00:12:53,978 --> 00:12:54,811
For multiplexing,

271
00:12:54,811 --> 00:12:57,020
we have the HTTP/2 example

272
00:12:57,020 --> 00:12:58,720
where, here on top,

273
00:12:58,720 --> 00:13:03,330
you can see the two
HTTP/2 requests in gray,

274
00:13:03,330 --> 00:13:05,190
and the adversary will assure

275
00:13:05,190 --> 00:13:07,910
that these two HTTP/2 requests

276
00:13:07,910 --> 00:13:11,070
are sent in a single TCP packet.

277
00:13:11,070 --> 00:13:13,410
This assures that these two requests

278
00:13:13,410 --> 00:13:16,403
will arrive simultaneously at the server.

279
00:13:18,010 --> 00:13:19,590
For the encapsulation case,

280
00:13:19,590 --> 00:13:22,630
we have the HTTP/1 example where,

281
00:13:22,630 --> 00:13:23,850
here again at the bottom,

282
00:13:23,850 --> 00:13:28,123
we have two HTTP/1 requests shown in gray.

283
00:13:28,960 --> 00:13:31,440
These two HTTP/1 requests are sent

284
00:13:31,440 --> 00:13:33,750
in different TCP connections,

285
00:13:33,750 --> 00:13:35,750
meaning they're also encapsulated

286
00:13:35,750 --> 00:13:39,217
in two different TCP
packets shown in red here.

287
00:13:39,217 --> 00:13:42,040
And each TCP packet is then encapsulated

288
00:13:42,040 --> 00:13:43,763
in a different Tor cell.

289
00:13:45,010 --> 00:13:47,080
Now what the adversary now does

290
00:13:47,080 --> 00:13:49,950
is the adversary assures

291
00:13:49,950 --> 00:13:51,930
that these two Tor cells

292
00:13:51,930 --> 00:13:55,700
will be aggregated into
a single TCP packet

293
00:13:55,700 --> 00:13:58,510
and once this TCP packet arrives

294
00:13:58,510 --> 00:14:02,800
at the Tor union servers
that we are targeting,

295
00:14:02,800 --> 00:14:06,700
then the union servers will
process these two requests

296
00:14:06,700 --> 00:14:08,573
effectively, in parallel.

297
00:14:11,860 --> 00:14:13,600
For the second requirement,

298
00:14:13,600 --> 00:14:16,350
the second requirement is
that these two requests

299
00:14:16,350 --> 00:14:20,360
then have to be handled
in parallel by the server

300
00:14:20,360 --> 00:14:24,450
and whether this is the case
is application dependent.

301
00:14:24,450 --> 00:14:26,440
We have found that in most cases,

302
00:14:26,440 --> 00:14:30,300
applications can handle
requests in parallel.

303
00:14:30,300 --> 00:14:31,510
One possible exception

304
00:14:31,510 --> 00:14:34,170
is when you target
cryptographic operations,

305
00:14:34,170 --> 00:14:37,030
because those often have to be handled

306
00:14:37,030 --> 00:14:39,333
in a certain sequential order.

307
00:14:41,300 --> 00:14:42,720
The third requirement then,

308
00:14:42,720 --> 00:14:47,720
is that the order of the
responses will reflect

309
00:14:47,870 --> 00:14:51,693
which requests finished processing first.

310
00:14:52,700 --> 00:14:53,890
And, in practice,

311
00:14:53,890 --> 00:14:55,240
that means that the server

312
00:14:55,240 --> 00:14:57,990
must immediately send a response

313
00:14:57,990 --> 00:15:01,193
after it finished processing a request.

314
00:15:03,550 --> 00:15:04,800
Additionally,

315
00:15:04,800 --> 00:15:08,010
the adversary must be
able to reliably recover

316
00:15:08,010 --> 00:15:10,050
the response order.

317
00:15:10,050 --> 00:15:10,883
In other words,

318
00:15:10,883 --> 00:15:12,870
when the responses are sent back

319
00:15:12,870 --> 00:15:14,530
from the victim server,

320
00:15:14,530 --> 00:15:15,970
to the adversary,

321
00:15:15,970 --> 00:15:20,490
the network should not be
reordering these responses.

322
00:15:20,490 --> 00:15:22,950
Now, in our experience,

323
00:15:22,950 --> 00:15:24,330
in our experiments,

324
00:15:24,330 --> 00:15:26,860
we noticed that these two responses

325
00:15:26,860 --> 00:15:29,230
generally follow the same network paths,

326
00:15:29,230 --> 00:15:31,380
meaning the order is maintained.

327
00:15:31,380 --> 00:15:32,810
But even if for some reason,

328
00:15:32,810 --> 00:15:35,360
the order of the responses is switched

329
00:15:36,375 --> 00:15:39,000
along the network path,

330
00:15:39,000 --> 00:15:41,970
then the adversary can
still rely on TCP shields,

331
00:15:41,970 --> 00:15:44,110
such as the TCP sequence numbers,

332
00:15:44,110 --> 00:15:46,350
or the TCP timestamps

333
00:15:46,350 --> 00:15:49,120
to recover the order in which the server

334
00:15:49,120 --> 00:15:51,393
sent both responses.

335
00:15:53,520 --> 00:15:55,100
What is now the performance

336
00:15:55,100 --> 00:15:57,490
of a timeless timing attack?

337
00:15:57,490 --> 00:15:58,330
Well,

338
00:15:58,330 --> 00:15:59,390
let's first, and for all,

339
00:15:59,390 --> 00:16:02,720
recall the performance of a
traditional timing attack,

340
00:16:02,720 --> 00:16:06,490
where Tom explained the first
part of this table here.

341
00:16:06,490 --> 00:16:08,240
On this slide we also added

342
00:16:08,240 --> 00:16:10,640
the performance of a
traditional timing attack

343
00:16:10,640 --> 00:16:12,733
over the LAN and the local host.

344
00:16:13,570 --> 00:16:14,403
For instance,

345
00:16:14,403 --> 00:16:16,683
we can see that if we want to exploit

346
00:16:16,683 --> 00:16:19,200
a timing leak of five microseconds

347
00:16:19,200 --> 00:16:20,900
over the local host,

348
00:16:20,900 --> 00:16:24,470
this would require a bit
more than 40 requests

349
00:16:25,430 --> 00:16:27,063
in a traditional timing attack.

350
00:16:28,700 --> 00:16:30,300
In contrast,

351
00:16:30,300 --> 00:16:33,770
if you look at our new
timeless timing attacks,

352
00:16:33,770 --> 00:16:35,870
we can, for example,

353
00:16:35,870 --> 00:16:40,680
exploit a timing leak of five microseconds

354
00:16:40,680 --> 00:16:44,120
using roughly 50 requests pairs.

355
00:16:44,120 --> 00:16:45,100
And important here,

356
00:16:45,100 --> 00:16:48,010
is that the timing leak
can then be exploited

357
00:16:48,010 --> 00:16:52,063
no matter where the adversary
is located on the internet.

358
00:16:54,224 --> 00:16:58,110
And this is in contrast to
traditional timing attacks

359
00:16:58,110 --> 00:17:00,810
because with traditional timing attacks,

360
00:17:00,810 --> 00:17:02,613
we were not able to exploit

361
00:17:02,613 --> 00:17:04,580
a timing leak of five microseconds

362
00:17:04,580 --> 00:17:05,820
over the internet,

363
00:17:05,820 --> 00:17:08,673
while for our timeless
timing attacks we can.

364
00:17:09,880 --> 00:17:10,713
On top of that,

365
00:17:10,713 --> 00:17:11,550
I want to highlight

366
00:17:11,550 --> 00:17:13,840
that with the timeless timing attacks,

367
00:17:13,840 --> 00:17:15,123
we were able to exploit

368
00:17:15,123 --> 00:17:19,330
a timing leak of just 100 nanoseconds

369
00:17:19,330 --> 00:17:22,200
while with the traditional timing attacks,

370
00:17:22,200 --> 00:17:23,630
the best we could exploit

371
00:17:23,630 --> 00:17:27,100
was a timing leak of 150 nanoseconds

372
00:17:27,100 --> 00:17:28,060
when the adversary

373
00:17:28,060 --> 00:17:30,233
was in the same LAN or local host.

374
00:17:31,200 --> 00:17:32,050
And, in fact,

375
00:17:32,050 --> 00:17:35,330
over the internet a
traditional timing attack,

376
00:17:35,330 --> 00:17:39,303
at best could exploit a timing
leak of 50 microseconds.

377
00:17:40,190 --> 00:17:42,690
And this really shows that
timeless timing attacks

378
00:17:42,690 --> 00:17:46,580
are an order of magnitude more powerful

379
00:17:46,580 --> 00:17:48,793
than traditional timing attacks.

380
00:17:50,880 --> 00:17:54,050
That covers how direct
timing attacks work.

381
00:17:54,050 --> 00:17:56,160
It's also possible to perform

382
00:17:56,160 --> 00:17:59,420
timeless timing attacks
in a cross-site setting

383
00:17:59,420 --> 00:18:01,650
and to perform timeless timing attacks

384
00:18:01,650 --> 00:18:03,323
against Wi-Fi authentication.

385
00:18:04,723 --> 00:18:06,080
And Tom will now elaborate

386
00:18:06,080 --> 00:18:08,943
on the cross-site timing attack scenario.

387
00:18:10,320 --> 00:18:13,170
- So these cross-site timing attacks,

388
00:18:13,170 --> 00:18:15,250
they're a bit different from
the direct timing attacks

389
00:18:15,250 --> 00:18:18,380
that we were talking about before,

390
00:18:18,380 --> 00:18:20,320
because in this case

391
00:18:20,320 --> 00:18:21,890
it will not be the attacker

392
00:18:21,890 --> 00:18:25,670
who's directly connecting
to the targeted server,

393
00:18:25,670 --> 00:18:29,040
but it will be the
victim sending requests,

394
00:18:29,040 --> 00:18:30,470
but still these requests

395
00:18:30,470 --> 00:18:32,600
are triggered by the attacker

396
00:18:32,600 --> 00:18:35,403
by launching some
malicious JavaScript code.

397
00:18:36,260 --> 00:18:37,920
This could happen

398
00:18:37,920 --> 00:18:41,300
when the victim lands
on a malicious website,

399
00:18:41,300 --> 00:18:42,133
for instance,

400
00:18:42,133 --> 00:18:43,363
by clicking on a link,

401
00:18:44,990 --> 00:18:48,920
or if there's a malicious
advertisement being shown,

402
00:18:48,920 --> 00:18:52,240
or if this victim has a really urgent need

403
00:18:52,240 --> 00:18:54,410
to look at some cute animal videos,

404
00:18:54,410 --> 00:18:58,033
and then ends up on the
website of the attacker.

405
00:18:59,920 --> 00:19:01,270
So these requests

406
00:19:01,270 --> 00:19:02,320
that are triggered by the attacker

407
00:19:02,320 --> 00:19:04,100
with the JavaScripts,

408
00:19:04,100 --> 00:19:07,020
they will include the cookies.

409
00:19:07,020 --> 00:19:10,600
This means that the server
will process the requests

410
00:19:10,600 --> 00:19:12,733
using the victim's authentication.

411
00:19:15,550 --> 00:19:19,170
Once that request has been processed,

412
00:19:19,170 --> 00:19:21,130
the attacker can still observe

413
00:19:21,130 --> 00:19:23,300
the order of the response.

414
00:19:23,300 --> 00:19:24,280
For instance,

415
00:19:24,280 --> 00:19:26,113
when he's using the Fetch API,

416
00:19:27,130 --> 00:19:30,960
he can look at which
promised results first,

417
00:19:30,960 --> 00:19:33,090
and this will leak,

418
00:19:33,090 --> 00:19:37,100
or this might leak sensitive information

419
00:19:37,100 --> 00:19:39,673
that the victim has
shared with the website.

420
00:19:41,120 --> 00:19:44,450
We actually applied this timing attack,

421
00:19:44,450 --> 00:19:47,470
this cross-site timing attack

422
00:19:47,470 --> 00:19:51,273
to the search functionality in HackerOne,

423
00:19:51,273 --> 00:19:53,630
where we were able to leak information

424
00:19:53,630 --> 00:19:56,713
about private and disclosed reports.

425
00:20:00,990 --> 00:20:02,750
One of the key differences

426
00:20:02,750 --> 00:20:05,810
is that with direct timing attacks,

427
00:20:05,810 --> 00:20:06,800
is that here,

428
00:20:06,800 --> 00:20:09,310
the attacker does not have direct control

429
00:20:09,310 --> 00:20:11,200
over the network.

430
00:20:11,200 --> 00:20:13,330
Just because the browser

431
00:20:13,330 --> 00:20:16,760
can choose how to send
requests to the kernel

432
00:20:16,760 --> 00:20:20,150
and the kernel will then
send it to the server.

433
00:20:20,150 --> 00:20:22,870
So we will need another technique

434
00:20:22,870 --> 00:20:25,040
to make sure that the two requests

435
00:20:25,040 --> 00:20:27,770
are joined into a single packet

436
00:20:28,930 --> 00:20:31,100
and in order to do so,

437
00:20:31,100 --> 00:20:33,773
we can leverage TCP congestion control.

438
00:20:34,920 --> 00:20:37,577
This mechanism will prevent

439
00:20:37,577 --> 00:20:40,030
the client from sending

440
00:20:40,030 --> 00:20:42,880
very large number of packets at once

441
00:20:44,450 --> 00:20:47,050
and it sets that attacker won't have,

442
00:20:47,050 --> 00:20:47,883
sorry,

443
00:20:47,883 --> 00:20:51,410
the client will need to
wait for an acknowledgement

444
00:20:51,410 --> 00:20:55,123
from the server before
more packets can be sent.

445
00:20:58,030 --> 00:21:01,630
As soon as the client is waiting for

446
00:21:03,836 --> 00:21:05,653
acknowledgement from the server,

447
00:21:07,690 --> 00:21:09,613
any other requests that are made,

448
00:21:10,800 --> 00:21:13,880
all their data will be stored in the queue

449
00:21:15,500 --> 00:21:19,833
and they will be merged
together into a single packet.

450
00:21:21,550 --> 00:21:25,143
So the attack looks fairly simple.

451
00:21:26,290 --> 00:21:27,350
First we make

452
00:21:28,750 --> 00:21:32,173
post requests with a
sufficiently long body,

453
00:21:33,310 --> 00:21:35,850
and then immediately after

454
00:21:35,850 --> 00:21:37,900
we make the two target requests.

455
00:21:37,900 --> 00:21:39,890
So the one will be for the baseline

456
00:21:41,380 --> 00:21:43,340
and then the other one is

457
00:21:44,585 --> 00:21:47,300
the target URL for which we want to see

458
00:21:47,300 --> 00:21:51,960
if it matches the same
timing as the baseline

459
00:21:51,960 --> 00:21:54,623
or whether it takes longer or shorter.

460
00:21:57,290 --> 00:21:58,123
Okay.

461
00:21:58,123 --> 00:22:00,340
Let's see how this works in practice then.

462
00:22:01,490 --> 00:22:05,023
Here we show the victim's packet queue.

463
00:22:06,940 --> 00:22:10,400
The TCP packets sent that are being queued

464
00:22:10,400 --> 00:22:11,803
to be sent to the server.

465
00:22:13,860 --> 00:22:17,230
First the attacker makes this post request

466
00:22:17,230 --> 00:22:20,793
which already sends off
a number of TCP packets,

467
00:22:21,680 --> 00:22:23,550
but there will be also some packets

468
00:22:23,550 --> 00:22:25,293
that cannot be sent yet,

469
00:22:26,280 --> 00:22:27,570
because we need to wait

470
00:22:27,570 --> 00:22:29,850
for the acknowledgement from the server

471
00:22:29,850 --> 00:22:31,550
and they'll be added to the queue.

472
00:22:33,230 --> 00:22:35,770
Here every square

473
00:22:36,890 --> 00:22:39,033
represents a single TCP packet.

474
00:22:42,330 --> 00:22:44,800
Then the second line of codes

475
00:22:44,800 --> 00:22:47,380
is where the attacker will

476
00:22:47,380 --> 00:22:49,973
make a request for the baseline URL.

477
00:22:51,630 --> 00:22:53,040
And as you can see here,

478
00:22:53,040 --> 00:22:56,690
it's represented with this pink,

479
00:22:56,690 --> 00:22:57,613
light pink.

480
00:22:59,990 --> 00:23:01,530
And then,

481
00:23:01,530 --> 00:23:02,363
second,

482
00:23:02,363 --> 00:23:04,230
the third line of code will be

483
00:23:04,230 --> 00:23:06,490
the attacker sending the request

484
00:23:06,490 --> 00:23:08,940
for the target URL,

485
00:23:08,940 --> 00:23:11,203
represented as the darker pink.

486
00:23:12,700 --> 00:23:13,723
As you can see,

487
00:23:14,800 --> 00:23:18,743
both requests will be added
to the same TCP packet.

488
00:23:20,520 --> 00:23:22,330
And then later on,

489
00:23:22,330 --> 00:23:23,163
when

490
00:23:24,120 --> 00:23:27,030
the client has received enough,

491
00:23:27,030 --> 00:23:30,223
or sufficient acknowledgements
from the server,

492
00:23:31,630 --> 00:23:35,040
it's possible to send
all the remaining packets

493
00:23:35,040 --> 00:23:36,840
that are in the queue.

494
00:23:36,840 --> 00:23:39,060
And as you can see,

495
00:23:39,060 --> 00:23:41,160
the light and dark pink

496
00:23:42,760 --> 00:23:44,180
requests

497
00:23:44,180 --> 00:23:47,260
will be both in a single TCP packet,

498
00:23:47,260 --> 00:23:49,330
which is exactly what we need

499
00:23:49,330 --> 00:23:51,493
to perform our timeless timing attacks.

500
00:23:54,390 --> 00:23:55,370
In this presentation,

501
00:23:55,370 --> 00:23:58,750
we already discussed the
direct timing attacks,

502
00:23:58,750 --> 00:24:02,460
where the attacker connects
directly to the server.

503
00:24:02,460 --> 00:24:04,760
Then what I was just talking about

504
00:24:04,760 --> 00:24:06,990
are the cross-site timing attacks.

505
00:24:06,990 --> 00:24:08,550
And then now,

506
00:24:08,550 --> 00:24:13,380
Mathy will be talking about
a third attack scenario

507
00:24:13,380 --> 00:24:16,360
where we use a timeless timing attacks

508
00:24:16,360 --> 00:24:19,303
to break a Wi-Fi authentication.

509
00:24:20,440 --> 00:24:22,480
- So it is also possible to perform

510
00:24:22,480 --> 00:24:25,980
timeless timing attacks against Wi-Fi,

511
00:24:25,980 --> 00:24:26,813
and in particular,

512
00:24:26,813 --> 00:24:30,020
we're going to exploit
the EAP-pwd protocol

513
00:24:30,020 --> 00:24:31,900
that can be used in WPA2

514
00:24:31,900 --> 00:24:35,353
or even WPA3 enterprise networks.

515
00:24:36,550 --> 00:24:38,100
Most enterprise networks,

516
00:24:38,100 --> 00:24:41,630
they use certificates to
authenticate the server

517
00:24:41,630 --> 00:24:44,840
and sometimes also to
authenticate the user.

518
00:24:44,840 --> 00:24:45,673
However,

519
00:24:45,673 --> 00:24:48,090
this can be quite annoying to configure.

520
00:24:48,090 --> 00:24:48,950
So in practice,

521
00:24:48,950 --> 00:24:51,930
a small but significant amount of networks

522
00:24:51,930 --> 00:24:54,770
rely on the EAP-pwd protocol and stats

523
00:24:54,770 --> 00:24:56,530
to authenticate a user

524
00:24:56,530 --> 00:24:58,983
using a username and password.

525
00:25:00,340 --> 00:25:01,220
And when using these

526
00:25:01,220 --> 00:25:03,600
enterprise authentication protocols,

527
00:25:03,600 --> 00:25:05,833
the authentication happens
between the clients

528
00:25:05,833 --> 00:25:07,820
and the authentication server.

529
00:25:07,820 --> 00:25:10,070
There the authentication server

530
00:25:10,070 --> 00:25:13,245
is commonly a free radius server,

531
00:25:13,245 --> 00:25:15,860
and the access point will
simply forward messages

532
00:25:15,860 --> 00:25:18,933
between the client and
the authentication server.

533
00:25:19,937 --> 00:25:22,000
And because of the authentication server

534
00:25:22,000 --> 00:25:24,970
can be located anywhere on the internet,

535
00:25:24,970 --> 00:25:27,287
the communication between the access point

536
00:25:27,287 --> 00:25:29,220
and the authentication server

537
00:25:29,220 --> 00:25:32,070
is typically protected using a TLS tunnel.

538
00:25:32,070 --> 00:25:35,473
on the TLS tunnel is
called a RadSec connection.

539
00:25:36,980 --> 00:25:38,650
Now the EAP-pwd protocol

540
00:25:38,650 --> 00:25:42,190
that we will be targeting
uses the so-called

541
00:25:42,190 --> 00:25:46,870
hash-to-curve algorithm
to verify a password.

542
00:25:46,870 --> 00:25:47,980
Unfortunately,

543
00:25:47,980 --> 00:25:50,823
a timing leak was discovered
in this algorithm.

544
00:25:51,730 --> 00:25:54,253
This was called a Dragonblood attack.

545
00:25:55,470 --> 00:25:56,350
However,

546
00:25:56,350 --> 00:26:01,350
against EAP-pwd this timing
leak was fairly small.

547
00:26:01,400 --> 00:26:03,570
And it did not appear possible

548
00:26:03,570 --> 00:26:07,860
to combine multiple timing measurements

549
00:26:07,860 --> 00:26:09,970
in a more powerful attack.

550
00:26:09,970 --> 00:26:11,200
So in other words,

551
00:26:11,200 --> 00:26:12,930
it seemed almost impossible

552
00:26:12,930 --> 00:26:15,020
to exploit this timing leak

553
00:26:15,020 --> 00:26:17,713
at least against EAP-pwd.

554
00:26:19,930 --> 00:26:20,840
However,

555
00:26:20,840 --> 00:26:22,950
by using the timeless timing attack,

556
00:26:22,950 --> 00:26:26,940
we are able to attack
the EAP-pwd protocol.

557
00:26:26,940 --> 00:26:29,090
And how does this work?

558
00:26:29,090 --> 00:26:29,923
Well,

559
00:26:29,923 --> 00:26:32,720
the adversary will spoof three clients

560
00:26:32,720 --> 00:26:34,690
shown here on the right.

561
00:26:34,690 --> 00:26:35,523
And

562
00:26:35,523 --> 00:26:36,990
first, the first two clients

563
00:26:36,990 --> 00:26:39,780
will associate to the access point.

564
00:26:39,780 --> 00:26:43,650
The access point will request
the identity of the client.

565
00:26:43,650 --> 00:26:46,270
The client will reply with their identity

566
00:26:46,270 --> 00:26:49,413
and send the identity through
the FreeRADIUS server,

567
00:26:50,740 --> 00:26:52,150
and then the FreeRADIUS server

568
00:26:52,150 --> 00:26:53,800
will tell these clients,

569
00:26:53,800 --> 00:26:54,760
okay,

570
00:26:54,760 --> 00:26:55,800
I recognize you,

571
00:26:55,800 --> 00:26:58,290
and both of you now have to perform

572
00:26:58,290 --> 00:27:02,373
the EAP-pwd authentication algorithm.

573
00:27:03,810 --> 00:27:05,070
Now up to this point,

574
00:27:05,070 --> 00:27:07,163
nothing special happened.

575
00:27:08,000 --> 00:27:09,400
Instead,

576
00:27:09,400 --> 00:27:11,990
the attack only starts now.

577
00:27:11,990 --> 00:27:14,880
And in the first part of the attack,

578
00:27:14,880 --> 00:27:16,040
the third client

579
00:27:16,040 --> 00:27:19,180
will send a special authentication frame

580
00:27:19,180 --> 00:27:20,343
to the access point.

581
00:27:21,569 --> 00:27:22,480
And the access point

582
00:27:22,480 --> 00:27:25,170
will forward this authentication frame

583
00:27:25,170 --> 00:27:26,530
over the TLS tunnel.

584
00:27:26,530 --> 00:27:28,470
So over the RadSec connection

585
00:27:29,670 --> 00:27:31,360
to the FreeRADIUS server

586
00:27:32,315 --> 00:27:35,070
and this will cause the
buffer of the access point

587
00:27:35,070 --> 00:27:39,550
to slowly fill up with RadSec frames,

588
00:27:39,550 --> 00:27:41,000
and as a result,

589
00:27:41,000 --> 00:27:42,380
when Client 1 and 2

590
00:27:42,380 --> 00:27:47,380
now sends their EAP-pwd
authentication response,

591
00:27:49,540 --> 00:27:51,720
then because the access point

592
00:27:51,720 --> 00:27:54,493
already has some frames in its buffer,

593
00:27:55,660 --> 00:27:58,803
these two frames will be
combined into one TLS record.

594
00:27:59,700 --> 00:28:02,200
Before I explain that in more detail,

595
00:28:02,200 --> 00:28:04,510
I want to highlight that

596
00:28:04,510 --> 00:28:06,530
the server here will send both

597
00:28:06,530 --> 00:28:10,730
these EAP-pwd authentication responses

598
00:28:10,730 --> 00:28:13,572
in a single physical Wi-Fi frame,

599
00:28:13,572 --> 00:28:15,340
and this single physical Wi-Fi frame

600
00:28:15,340 --> 00:28:17,603
is called an A-MPDU frame.

601
00:28:19,070 --> 00:28:22,350
This means that these two
authentication responses

602
00:28:22,350 --> 00:28:25,000
will arrive at exactly the same time

603
00:28:25,000 --> 00:28:26,830
at the access point,

604
00:28:26,830 --> 00:28:28,730
and because the buffer at the access point

605
00:28:28,730 --> 00:28:31,540
is slowly starting to get full,

606
00:28:31,540 --> 00:28:33,250
the access point will combine

607
00:28:33,250 --> 00:28:37,450
both authentication requests
in a single TLS record

608
00:28:37,450 --> 00:28:40,773
that is sent to the FreeRADIUS server.

609
00:28:42,230 --> 00:28:44,470
The FreeRADIUS server will then process

610
00:28:44,470 --> 00:28:45,810
both authentication

611
00:28:47,060 --> 00:28:49,150
requests simultaneously

612
00:28:49,150 --> 00:28:50,570
and parallel,

613
00:28:50,570 --> 00:28:51,700
and it will reply

614
00:28:51,700 --> 00:28:55,207
using whichever requests finished first,

615
00:28:55,207 --> 00:28:56,610
and then it will reply

616
00:28:56,610 --> 00:29:00,423
using the other request that
finished processing second.

617
00:29:02,300 --> 00:29:03,133
So here,

618
00:29:03,133 --> 00:29:05,060
the request of the first client

619
00:29:05,060 --> 00:29:06,600
finished first at the server.

620
00:29:06,600 --> 00:29:09,830
So the server also sends it's reply first,

621
00:29:09,830 --> 00:29:13,413
and then the reply of the
second client is sent.

622
00:29:14,533 --> 00:29:15,950
And we can see that this order

623
00:29:15,950 --> 00:29:17,220
is also reflected

624
00:29:18,170 --> 00:29:20,070
at the adversary site.

625
00:29:20,070 --> 00:29:20,903
Namely,

626
00:29:20,903 --> 00:29:23,500
the adversary will first receive

627
00:29:23,500 --> 00:29:24,920
the reply of the Client 1,

628
00:29:24,920 --> 00:29:27,540
and then it was received the reply

629
00:29:27,540 --> 00:29:29,103
for Client 2.

630
00:29:31,020 --> 00:29:35,040
And the order of these replies

631
00:29:35,040 --> 00:29:37,420
allows an adversary to bruteforce

632
00:29:37,420 --> 00:29:39,663
the password of the victim.

633
00:29:42,223 --> 00:29:43,453
And in this case,

634
00:29:44,380 --> 00:29:46,100
the probability of them

635
00:29:46,100 --> 00:29:51,040
successfully bruteforcing
the password of the client

636
00:29:51,040 --> 00:29:54,763
is higher than 99%,

637
00:29:55,620 --> 00:29:57,223
or to put it differently,

638
00:29:59,170 --> 00:30:02,280
the response order correctly reflects

639
00:30:02,280 --> 00:30:06,220
the execution time at
the FreeRADIUS servers

640
00:30:06,220 --> 00:30:08,750
in 99% of the time.

641
00:30:08,750 --> 00:30:11,860
So only in less than 1% of the cases

642
00:30:11,860 --> 00:30:13,550
does the response order

643
00:30:13,550 --> 00:30:17,233
incorrectly reflect the
execution time at the server.

644
00:30:19,670 --> 00:30:21,230
And we can use this information

645
00:30:21,230 --> 00:30:25,020
to then perform a
off-line dictionary attack

646
00:30:25,020 --> 00:30:26,570
against the password.

647
00:30:26,570 --> 00:30:27,590
So for instances,

648
00:30:27,590 --> 00:30:29,890
if we take the RockYou password dump,

649
00:30:29,890 --> 00:30:33,950
which contains about
140 million passwords,

650
00:30:33,950 --> 00:30:36,770
then we need to perform 40 measurements,

651
00:30:36,770 --> 00:30:38,800
and with those 40 measurements

652
00:30:38,800 --> 00:30:43,000
we have an 86% success probability

653
00:30:43,000 --> 00:30:45,350
of correctly recovering the password.

654
00:30:45,350 --> 00:30:46,530
At least if the password

655
00:30:46,530 --> 00:30:50,230
is inside this password dump.

656
00:30:50,230 --> 00:30:55,140
And this bruteforce
search costs about $1 on,

657
00:30:55,140 --> 00:30:55,973
for instance,

658
00:30:55,973 --> 00:30:57,993
an Amazon cloud server.

659
00:31:00,850 --> 00:31:02,130
So as a quick recap,

660
00:31:02,130 --> 00:31:05,060
we now explained direct timing attacks.

661
00:31:05,060 --> 00:31:07,690
We explained cross-site timing attacks,

662
00:31:07,690 --> 00:31:10,570
and we explained timeless timing attacks

663
00:31:10,570 --> 00:31:12,253
over Wi-Fi authentication.

664
00:31:13,720 --> 00:31:14,553
And with that,

665
00:31:14,553 --> 00:31:16,693
I hand the word back over to Tom.

666
00:31:17,950 --> 00:31:18,900
- All right.

667
00:31:18,900 --> 00:31:21,563
And that brings us to the demonstration.

668
00:31:22,630 --> 00:31:24,590
So for this demonstration,

669
00:31:24,590 --> 00:31:26,120
I created

670
00:31:26,120 --> 00:31:29,480
an application called The Vault,

671
00:31:29,480 --> 00:31:31,350
which is basically a place

672
00:31:31,350 --> 00:31:33,220
where people can securely share

673
00:31:33,220 --> 00:31:36,693
their text documents with
military grade protection.

674
00:31:37,540 --> 00:31:41,310
So users can enter the
title of the document

675
00:31:41,310 --> 00:31:42,940
and then select

676
00:31:42,940 --> 00:31:46,013
the required security
level of the other users.

677
00:31:47,920 --> 00:31:50,470
It's required to access the document.

678
00:31:50,470 --> 00:31:52,470
So it ranges from one,

679
00:31:52,470 --> 00:31:54,380
which is for public documents,

680
00:31:54,380 --> 00:31:55,900
up until five,

681
00:31:55,900 --> 00:31:58,690
which is for really top secret documents

682
00:31:59,570 --> 00:32:01,980
then the user can enter their content

683
00:32:01,980 --> 00:32:04,743
and finally post the document.

684
00:32:07,920 --> 00:32:10,410
Another functionality
provided by The Vault

685
00:32:10,410 --> 00:32:13,090
is the search functionality

686
00:32:13,090 --> 00:32:15,747
where we can search for strings like "hi",

687
00:32:17,200 --> 00:32:20,393
and then get a bunch of results.

688
00:32:22,340 --> 00:32:24,780
We can also look for other strings,

689
00:32:24,780 --> 00:32:25,613
like for instance,

690
00:32:25,613 --> 00:32:26,820
"Vegas".

691
00:32:26,820 --> 00:32:27,707
And then we can see

692
00:32:27,707 --> 00:32:30,253
that there's this one single result,

693
00:32:31,150 --> 00:32:34,040
or we can try some more secretive

694
00:32:35,460 --> 00:32:37,497
things like the string "DEFCON",

695
00:32:38,670 --> 00:32:40,390
but unfortunately,

696
00:32:40,390 --> 00:32:41,950
we don't find any documents

697
00:32:41,950 --> 00:32:43,100
containing that string.

698
00:32:44,590 --> 00:32:45,423
Well,

699
00:32:45,423 --> 00:32:46,390
I did create

700
00:32:47,380 --> 00:32:49,400
this application.

701
00:32:49,400 --> 00:32:52,320
So I know that there's
at least one document

702
00:32:52,320 --> 00:32:54,007
with the string "DEFCON",

703
00:32:55,970 --> 00:32:57,930
but the reason why we're not shown

704
00:32:57,930 --> 00:32:59,370
this document is because

705
00:32:59,370 --> 00:33:02,253
we don't have the right security level.

706
00:33:05,720 --> 00:33:06,820
In this demonstration,

707
00:33:06,820 --> 00:33:09,090
what we will try to do is leak

708
00:33:09,935 --> 00:33:10,768
the password,

709
00:33:12,640 --> 00:33:15,570
that is in the same document

710
00:33:15,570 --> 00:33:17,060
as the one that contains

711
00:33:17,060 --> 00:33:18,060
the string "DEFCON".

712
00:33:18,920 --> 00:33:21,250
And in order to do so,

713
00:33:21,250 --> 00:33:24,883
we will be using these
timeless timing attacks.

714
00:33:26,290 --> 00:33:29,240
But before I go into the details there

715
00:33:30,210 --> 00:33:31,400
of how the attack works,

716
00:33:31,400 --> 00:33:33,410
I'll first explain

717
00:33:33,410 --> 00:33:35,273
how the search functionality works.

718
00:33:37,490 --> 00:33:38,323
Basically,

719
00:33:38,323 --> 00:33:40,770
what we do is we do a textual search

720
00:33:40,770 --> 00:33:44,130
on the contents of all the documents

721
00:33:44,130 --> 00:33:47,620
using the query provided by the user.

722
00:33:47,620 --> 00:33:50,680
And then if there's at least one document,

723
00:33:50,680 --> 00:33:53,280
we need to be able to tell

724
00:33:53,280 --> 00:33:54,923
whether the current user,

725
00:33:56,440 --> 00:33:58,500
their security level is

726
00:33:59,920 --> 00:34:02,090
high enough to view

727
00:34:02,090 --> 00:34:03,313
one of the documents.

728
00:34:04,500 --> 00:34:06,690
So getting the security level

729
00:34:06,690 --> 00:34:08,470
is done by launching

730
00:34:08,470 --> 00:34:10,980
a simple SQL query

731
00:34:12,190 --> 00:34:14,170
on the database that's located

732
00:34:14,170 --> 00:34:16,803
on the same server as the web server.

733
00:34:17,650 --> 00:34:19,590
So that the timing

734
00:34:20,580 --> 00:34:23,480
or the latency there is very minimal,

735
00:34:23,480 --> 00:34:24,313
but still,

736
00:34:24,313 --> 00:34:25,920
this is where the timing leak is

737
00:34:26,860 --> 00:34:29,400
because if there are no documents,

738
00:34:29,400 --> 00:34:32,693
which means that there's
no match for the text,

739
00:34:35,100 --> 00:34:38,343
we don't have to launch this SQL query.

740
00:34:39,550 --> 00:34:40,580
So this means that

741
00:34:42,560 --> 00:34:44,650
if there's at least one document,

742
00:34:44,650 --> 00:34:47,470
the timing will take slightly

743
00:34:48,620 --> 00:34:50,213
a few microseconds longer.

744
00:34:54,030 --> 00:34:57,680
This is what we leverage in our attack.

745
00:34:57,680 --> 00:35:00,430
So we use PYTHON here,

746
00:35:00,430 --> 00:35:02,970
and we are using the H2

747
00:35:03,970 --> 00:35:06,420
H2 time library,

748
00:35:06,420 --> 00:35:07,253
which is the one

749
00:35:07,253 --> 00:35:09,883
that we also use in our research.

750
00:35:12,640 --> 00:35:13,900
It's made public

751
00:35:13,900 --> 00:35:16,130
and I'll be sharing the link

752
00:35:16,130 --> 00:35:17,683
later on in the presentation.

753
00:35:19,930 --> 00:35:20,944
So what we do is

754
00:35:20,944 --> 00:35:23,210
we define the URL prefix,

755
00:35:23,210 --> 00:35:26,960
so we know that the actual password

756
00:35:26,960 --> 00:35:30,513
is prefixed by DEFCON_PASSWORD=.

757
00:35:33,620 --> 00:35:35,210
And then we guess

758
00:35:35,210 --> 00:35:37,543
the current character one by one.

759
00:35:40,300 --> 00:35:42,860
If the guess is incorrect,

760
00:35:42,860 --> 00:35:45,200
we don't get shown any,

761
00:35:45,200 --> 00:35:47,020
there will be no documents

762
00:35:47,020 --> 00:35:49,920
matching the text search.

763
00:35:49,920 --> 00:35:52,783
So this SQL query will not be executed.

764
00:35:54,780 --> 00:35:57,170
And then we compare this to

765
00:35:57,170 --> 00:35:59,600
the baseline request

766
00:35:59,600 --> 00:36:00,960
where we use a character

767
00:36:00,960 --> 00:36:03,060
that's not part of the character set.

768
00:36:03,060 --> 00:36:03,910
So we know that

769
00:36:03,910 --> 00:36:06,983
it will never have any matching documents.

770
00:36:08,960 --> 00:36:11,000
And then we run

771
00:36:11,000 --> 00:36:15,220
this with the H2 time library and we get

772
00:36:15,220 --> 00:36:17,100
the response order

773
00:36:17,100 --> 00:36:19,373
for 15 request pairs.

774
00:36:21,770 --> 00:36:22,603
Basically,

775
00:36:22,603 --> 00:36:24,610
we determine how many

776
00:36:24,610 --> 00:36:26,223
negative results there are.

777
00:36:27,190 --> 00:36:29,880
Negative means that the order

778
00:36:29,880 --> 00:36:33,703
in which the response
arrived was reversed.

779
00:36:36,270 --> 00:36:37,910
So if we get

780
00:36:37,910 --> 00:36:39,320
for

781
00:36:39,320 --> 00:36:40,680
the response of r2

782
00:36:41,550 --> 00:36:43,103
before the response of r1,

783
00:36:45,828 --> 00:36:47,840
the order is reversed,

784
00:36:47,840 --> 00:36:51,380
because r1 is sent before r2

785
00:36:51,380 --> 00:36:52,800
typically,

786
00:36:52,800 --> 00:36:55,450
or the request is sent before,

787
00:36:55,450 --> 00:36:56,810
but then the response

788
00:36:56,810 --> 00:36:58,963
is received in a different order.

789
00:37:01,410 --> 00:37:02,243
And then

790
00:37:03,240 --> 00:37:05,200
we determine the percentage of

791
00:37:09,190 --> 00:37:13,450
how many responses were
received in reverse order.

792
00:37:13,450 --> 00:37:15,950
And then see if this

793
00:37:15,950 --> 00:37:19,790
is above or below a certain threshold.

794
00:37:19,790 --> 00:37:22,140
And in this case,

795
00:37:22,140 --> 00:37:26,353
the threshold was set to 80%.

796
00:37:27,740 --> 00:37:29,170
Okay?

797
00:37:29,170 --> 00:37:31,260
So I think now

798
00:37:31,260 --> 00:37:34,150
we are ready to actually run the attack,

799
00:37:34,150 --> 00:37:36,563
which is done using just PYTHON.

800
00:37:38,312 --> 00:37:39,660
(suspenseful techno music)

801
00:37:39,660 --> 00:37:42,170
And we will be guessing the

802
00:37:43,030 --> 00:37:45,003
passwords character by character.

803
00:37:46,350 --> 00:37:48,873
So on the top most line,

804
00:37:50,050 --> 00:37:50,883
we can see

805
00:37:52,114 --> 00:37:55,023
all the characters that
have been found so far.

806
00:37:55,960 --> 00:37:58,143
So we are at T and 1.

807
00:38:00,660 --> 00:38:03,690
Now we're also guessing,

808
00:38:03,690 --> 00:38:08,690
or correctly guessed the letter m.

809
00:38:08,770 --> 00:38:12,763
Everything here is being
shown in real time,

810
00:38:14,750 --> 00:38:15,583
of course,

811
00:38:15,583 --> 00:38:18,995
to make the demo a bit shorter,

812
00:38:18,995 --> 00:38:21,400
not the entire character set is used,

813
00:38:21,400 --> 00:38:22,550
but we just use some

814
00:38:23,970 --> 00:38:24,933
random guesses,

815
00:38:26,820 --> 00:38:28,370
but as you can see,

816
00:38:28,370 --> 00:38:29,203
so far,

817
00:38:29,203 --> 00:38:30,373
it's going pretty well.

818
00:38:33,695 --> 00:38:36,400
On the bottom line

819
00:38:36,400 --> 00:38:37,233
we show

820
00:38:38,080 --> 00:38:41,150
for each character that's being guessed,

821
00:38:41,150 --> 00:38:43,080
the percentage of the responses

822
00:38:43,080 --> 00:38:45,480
that arrived in the reverse order

823
00:38:46,390 --> 00:38:47,460
and

824
00:38:47,460 --> 00:38:51,140
for the characters that
were guessed incorrectly

825
00:38:53,340 --> 00:38:55,320
the percentage is

826
00:38:55,320 --> 00:38:57,740
somewhat close to 50%

827
00:38:57,740 --> 00:39:02,340
because there's a 50/50% chance

828
00:39:02,340 --> 00:39:04,380
for every request that's being sent

829
00:39:05,920 --> 00:39:06,753
that it will

830
00:39:08,080 --> 00:39:09,913
arrive before or after

831
00:39:09,913 --> 00:39:12,496
(techno music)

832
00:39:14,160 --> 00:39:15,440
the other request.

833
00:39:15,440 --> 00:39:19,210
So whether the response order
is the same or different,

834
00:39:19,210 --> 00:39:22,820
the chance is around 50%.

835
00:39:22,820 --> 00:39:23,653
Of course,

836
00:39:23,653 --> 00:39:24,740
there's still a bit of randomness.

837
00:39:24,740 --> 00:39:27,460
So that's why it's not always 50,

838
00:39:27,460 --> 00:39:30,553
but it's sometimes 40 sometimes 60.

839
00:39:33,280 --> 00:39:34,820
And

840
00:39:34,820 --> 00:39:36,700
I believe that we're

841
00:39:36,700 --> 00:39:39,650
already getting quite close to

842
00:39:39,650 --> 00:39:42,170
extracting the passwords.

843
00:39:42,170 --> 00:39:43,853
And yeah, there it is.

844
00:39:45,060 --> 00:39:46,460
So we've managed to

845
00:39:47,730 --> 00:39:51,400
in just under two minutes,

846
00:39:51,400 --> 00:39:54,253
find that the password is TimeLessTiming.

847
00:39:58,960 --> 00:39:59,793
Of course,

848
00:40:00,930 --> 00:40:03,460
in a real world scenario,

849
00:40:03,460 --> 00:40:04,830
it would take a bit longer

850
00:40:04,830 --> 00:40:06,530
because we would have to

851
00:40:06,530 --> 00:40:08,673
guess all the characters one by one,

852
00:40:09,920 --> 00:40:10,753
but still,

853
00:40:11,770 --> 00:40:14,313
I think it shows that the tech works very,

854
00:40:15,960 --> 00:40:16,793
very well.

855
00:40:18,250 --> 00:40:19,130
All right.

856
00:40:19,130 --> 00:40:22,083
And that brings us to the conclusion.

857
00:40:22,940 --> 00:40:25,720
So we find that these
timeless timing attacks

858
00:40:25,720 --> 00:40:29,040
are not affected by network jitter at all,

859
00:40:29,040 --> 00:40:31,810
neither on the upstream,

860
00:40:31,810 --> 00:40:33,343
nor the downstream.

861
00:40:36,350 --> 00:40:39,340
This allows the attacker to perform

862
00:40:39,340 --> 00:40:42,520
these remote timing attacks

863
00:40:42,520 --> 00:40:44,490
with an accuracy that is similar to

864
00:40:44,490 --> 00:40:45,700
as if the attack

865
00:40:45,700 --> 00:40:48,380
was launched against a local system.

866
00:40:48,380 --> 00:40:50,260
And in order to do so,

867
00:40:50,260 --> 00:40:53,233
we need to ensure that both requests are,

868
00:40:54,560 --> 00:40:57,133
they arrive at the same
time at the server,

869
00:40:58,890 --> 00:41:00,727
in order do so,

870
00:41:00,727 --> 00:41:04,343
the attacker can leverage multiplexing,

871
00:41:05,570 --> 00:41:08,640
or if that's not available,

872
00:41:08,640 --> 00:41:10,420
it might still be available

873
00:41:10,420 --> 00:41:11,950
to leverage

874
00:41:13,280 --> 00:41:14,950
a transport protocol

875
00:41:14,950 --> 00:41:18,463
that enables encapsulation
of the requests.

876
00:41:22,010 --> 00:41:24,200
We also find that all the protocols

877
00:41:24,200 --> 00:41:26,170
that meet these criteria

878
00:41:27,080 --> 00:41:31,230
may be susceptible to
timeless timing attacks.

879
00:41:31,230 --> 00:41:32,350
And we already,

880
00:41:32,350 --> 00:41:35,030
in our research we
created practical attacks

881
00:41:35,030 --> 00:41:36,780
against HTTP/2

882
00:41:36,780 --> 00:41:38,390
and EAP-pwd

883
00:41:40,920 --> 00:41:43,223
for Wi-Fi authentication.

884
00:41:44,800 --> 00:41:45,633
Okay.

885
00:41:45,633 --> 00:41:46,466
So with that,

886
00:41:46,466 --> 00:41:47,300
I would like to thank you

887
00:41:47,300 --> 00:41:49,683
for listening to the presentation.

888
00:41:51,030 --> 00:41:53,680
If you have any additional questions,

889
00:41:53,680 --> 00:41:56,220
or remarks, or ideas,

890
00:41:56,220 --> 00:41:59,620
don't hesitate to reach
out to us on Twitter.

891
00:41:59,620 --> 00:42:01,520
And then finally,

892
00:42:01,520 --> 00:42:03,140
you can find this,

893
00:42:03,140 --> 00:42:05,000
H2 time

894
00:42:05,000 --> 00:42:09,210
library that we used in our research,

895
00:42:09,210 --> 00:42:10,350
but also in the demo,

896
00:42:10,350 --> 00:42:12,690
in the following link.

897
00:42:12,690 --> 00:42:14,513
And then on the right-hand side,

898
00:42:15,450 --> 00:42:18,400
you can find the sources,

899
00:42:18,400 --> 00:42:21,600
or the source code of the demonstration,

900
00:42:21,600 --> 00:42:24,270
so you can play around with it as well.

901
00:42:24,270 --> 00:42:25,103
Okay.

902
00:42:25,103 --> 00:42:25,936
Thank you.

