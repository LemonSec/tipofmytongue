1
00:00:02,960 --> 00:00:03,793
- [Sick Codes] Hey, everyone.

2
00:00:03,793 --> 00:00:06,600
Welcome to rotten code, aging standards,

3
00:00:06,600 --> 00:00:08,750
and pwning IPv4 parsing across

4
00:00:08,750 --> 00:00:11,293
nearly every mainstream
programming language.

5
00:00:12,870 --> 00:00:13,873
Let's get started.

6
00:00:14,820 --> 00:00:17,330
Sort of starting off with
a meme here I got from JF

7
00:00:17,330 --> 00:00:19,360
or Joe Slowik's Twitter account.

8
00:00:19,360 --> 00:00:20,470
Everyone, please stay calm.

9
00:00:20,470 --> 00:00:22,780
We're releasing PoCs for the
unpatched vulnerabilities

10
00:00:22,780 --> 00:00:25,450
so you can better
evaluate security posture.

11
00:00:25,450 --> 00:00:27,710
I thought this was fantastic

12
00:00:27,710 --> 00:00:28,543
and I asked Joe if it was cool

13
00:00:28,543 --> 00:00:30,783
if I could put it in the presentation.

14
00:00:32,030 --> 00:00:32,950
Just as a quick disclaimer.

15
00:00:32,950 --> 00:00:34,920
None of the research today was paid for.

16
00:00:34,920 --> 00:00:35,970
It's all in good faith.

17
00:00:35,970 --> 00:00:38,150
Nothing today represents our employers,

18
00:00:38,150 --> 00:00:39,370
future, past or present.

19
00:00:39,370 --> 00:00:40,580
None of us are under any gag orders

20
00:00:40,580 --> 00:00:42,960
apart from vulnerabilities
that are still pending,

21
00:00:42,960 --> 00:00:44,100
which you'll see on the next slide.

22
00:00:44,100 --> 00:00:47,470
All of the content in the
slides is creative commons zero,

23
00:00:47,470 --> 00:00:50,310
and all the trademarks
logos, blah, blah, blah,

24
00:00:50,310 --> 00:00:52,150
are property of the respective owners.

25
00:00:52,150 --> 00:00:53,480
So what will we be discussing today?

26
00:00:53,480 --> 00:00:56,950
So we'll be discussing
today a litany of CVEs.

27
00:00:56,950 --> 00:00:58,990
These are CVEs that we accumulated

28
00:00:58,990 --> 00:01:00,610
over the course of about the last,

29
00:01:00,610 --> 00:01:02,130
I'd say nine months,

30
00:01:02,130 --> 00:01:04,370
with some of them still pending
because they're quite large

31
00:01:04,370 --> 00:01:06,790
and they take a bit of
time to fix, obviously.

32
00:01:06,790 --> 00:01:08,810
So, two of them we'll be releasing today,

33
00:01:08,810 --> 00:01:11,090
but they've never been seen before.

34
00:01:11,090 --> 00:01:12,240
And we confirm with all the vendors

35
00:01:12,240 --> 00:01:13,073
and everything like that,

36
00:01:13,073 --> 00:01:14,190
that it's cool to talk about them,

37
00:01:14,190 --> 00:01:17,250
including the Oracle one
we've mentioned below.

38
00:01:17,250 --> 00:01:19,596
We'll get into that a bit soon.

39
00:01:19,596 --> 00:01:21,700
So the format of today's talk is

40
00:01:21,700 --> 00:01:24,130
how did we find this
type of vulnerability?

41
00:01:24,130 --> 00:01:25,590
How you as a researcher

42
00:01:25,590 --> 00:01:28,660
or a hacker can horizontally
scale your vulnerabilities,

43
00:01:28,660 --> 00:01:30,483
whether that be for good or for bad.

44
00:01:31,520 --> 00:01:33,760
Some proof of concepts for
some of the vulnerabilities.

45
00:01:33,760 --> 00:01:35,350
The exploitability of a vulnerability

46
00:01:35,350 --> 00:01:37,210
of this caliber or type

47
00:01:37,210 --> 00:01:39,460
and further vectors or attacks

48
00:01:39,460 --> 00:01:42,650
or research that can
be conducted by anyone

49
00:01:42,650 --> 00:01:44,873
who is willing to get involved.

50
00:01:46,300 --> 00:01:48,380
Some takeaways we want
you to take out of this

51
00:01:48,380 --> 00:01:50,140
is that every day is patch Tuesday.

52
00:01:50,140 --> 00:01:51,700
Patch Tuesday is a meme.

53
00:01:51,700 --> 00:01:52,910
No longer exists,

54
00:01:52,910 --> 00:01:55,020
except for maybe at Microsoft and Oracle.

55
00:01:55,020 --> 00:01:56,660
And how do you patch an entire class

56
00:01:56,660 --> 00:01:58,070
of vulnerabilities this size?

57
00:01:58,070 --> 00:02:00,150
And just a quick apologies to anyone

58
00:02:00,150 --> 00:02:01,590
who has to leave the conference early,

59
00:02:01,590 --> 00:02:02,910
because some of these vulnerabilities

60
00:02:02,910 --> 00:02:05,720
might affect some of your code bases.

61
00:02:05,720 --> 00:02:07,120
And lastly, we just wanna show you

62
00:02:07,120 --> 00:02:10,520
how to exponentially magnify
some of your research,

63
00:02:10,520 --> 00:02:13,980
threat models or thought models
to magnify those attacks,

64
00:02:13,980 --> 00:02:16,770
and once again, horizontally
scaling your research,

65
00:02:16,770 --> 00:02:20,020
so applying it across all
different types of languages.

66
00:02:20,020 --> 00:02:23,090
And also, the ability to pick
up existing vulnerabilities

67
00:02:23,090 --> 00:02:26,450
and apply that across existing code bases,

68
00:02:26,450 --> 00:02:29,660
whether that be finding a
vulnerability in one language

69
00:02:29,660 --> 00:02:31,500
and then applying it in the next language

70
00:02:31,500 --> 00:02:33,550
and so on and so forth.

71
00:02:33,550 --> 00:02:35,220
So I just wanna start with a quick picture

72
00:02:35,220 --> 00:02:40,220
of a typical NIST CVE
scorecard, basically 9.8.

73
00:02:42,760 --> 00:02:45,420
That's the maximum you can
get for a vulnerability,

74
00:02:45,420 --> 00:02:48,020
excluding scoping changed or unchanged.

75
00:02:48,020 --> 00:02:50,030
And this is or what you can expect

76
00:02:50,030 --> 00:02:52,200
from a pretty high caliber vulnerability

77
00:02:52,200 --> 00:02:54,220
where you can get remote code execution

78
00:02:54,220 --> 00:02:57,600
or server side request
forgery or things like that.

79
00:02:57,600 --> 00:02:58,980
And just quickly as an intro,

80
00:02:58,980 --> 00:03:00,970
you're listening currently to Sick Codes

81
00:03:00,970 --> 00:03:03,513
and you'll be hearing
from Kelly Kaoudis soon.

82
00:03:04,870 --> 00:03:07,420
We'll be presenting work
based on some of the work

83
00:03:07,420 --> 00:03:10,620
that we did with
Johnjhacking, Nick Sahler,

84
00:03:10,620 --> 00:03:12,340
Victor Viale, Cheng Xu,

85
00:03:12,340 --> 00:03:14,760
and Harold Hunt.

86
00:03:14,760 --> 00:03:17,570
So I just wanna start with
the octal numbering system.

87
00:03:17,570 --> 00:03:19,670
Most people will understand
this numbering system,

88
00:03:19,670 --> 00:03:22,020
but basically there's no eight or nine.

89
00:03:22,020 --> 00:03:24,190
You can kinda visualize
this numbering system

90
00:03:24,190 --> 00:03:25,300
as in counting to 10,

91
00:03:25,300 --> 00:03:26,700
except you're counting with closed fists

92
00:03:26,700 --> 00:03:28,130
and you're counting from zero

93
00:03:28,130 --> 00:03:29,470
and you've only got eight fingers,

94
00:03:29,470 --> 00:03:32,460
therefore you're counting
for the maximum of seven,

95
00:03:32,460 --> 00:03:35,200
and then you just start
from the next number up.

96
00:03:35,200 --> 00:03:37,750
So that would be 10, which
would be one and zero.

97
00:03:37,750 --> 00:03:40,190
And how do you get to
these numbering system

98
00:03:40,190 --> 00:03:42,200
from what we know as decimal?

99
00:03:42,200 --> 00:03:43,227
Well, the easiest way to do it is

100
00:03:43,227 --> 00:03:45,060
you just go from left to right

101
00:03:45,060 --> 00:03:47,310
on a number that's being prefixed

102
00:03:47,310 --> 00:03:50,690
with the appropriate octal formatting.

103
00:03:50,690 --> 00:03:52,110
You basically start from left to right,

104
00:03:52,110 --> 00:03:53,680
and then do eight times the power.

105
00:03:53,680 --> 00:03:55,760
So this number here has three digits,

106
00:03:55,760 --> 00:03:57,830
therefore we go two, one, and zero.

107
00:03:57,830 --> 00:04:00,350
So eight times two, eight
times one, eight times zero,

108
00:04:00,350 --> 00:04:03,390
and then we multiply that
by each digit in each box.

109
00:04:03,390 --> 00:04:05,760
So one times eight to the power of two,

110
00:04:05,760 --> 00:04:07,590
zero times eight to the power of one,

111
00:04:07,590 --> 00:04:10,070
and then zero times eight
to the power of zero.

112
00:04:10,070 --> 00:04:10,920
And this one's really easy

113
00:04:10,920 --> 00:04:13,300
because one times eight
to the power of two.

114
00:04:13,300 --> 00:04:14,930
Eight to the power of two is 64,

115
00:04:14,930 --> 00:04:15,807
so one times 64.

116
00:04:15,807 --> 00:04:18,640
And the other two multiply
by zero or nothing.

117
00:04:18,640 --> 00:04:20,390
Therefore the answer is
just adding it all up.

118
00:04:20,390 --> 00:04:21,393
You get 64.

119
00:04:23,120 --> 00:04:25,220
Now let's go to a more interesting case.

120
00:04:25,220 --> 00:04:27,740
We got the one at the front
again. So we've got 64.

121
00:04:27,740 --> 00:04:29,560
Second one there, eight times two is 16.

122
00:04:29,560 --> 00:04:31,590
And then the last one there,

123
00:04:31,590 --> 00:04:33,180
anything to the power of zero is one,

124
00:04:33,180 --> 00:04:35,127
therefore seven times one is seven.

125
00:04:35,127 --> 00:04:36,993
Add it all up, you got 87.

126
00:04:37,830 --> 00:04:41,090
And then this is what we
traditionally know as decimal

127
00:04:41,090 --> 00:04:42,100
or base 10.

128
00:04:42,100 --> 00:04:44,070
This is what we've got 10 fingers for.

129
00:04:44,070 --> 00:04:45,780
One times, this is exactly what you do

130
00:04:45,780 --> 00:04:47,340
when you're normally counting numbers

131
00:04:47,340 --> 00:04:49,870
as you got your hundreds,
your tens, and your ones.

132
00:04:49,870 --> 00:04:51,730
So ten to the power of two is 100,

133
00:04:51,730 --> 00:04:53,390
to the power of one is 10,

134
00:04:53,390 --> 00:04:54,800
10 to the power of zero is zero.

135
00:04:54,800 --> 00:04:56,320
Pardon me, it's one.

136
00:04:56,320 --> 00:04:59,020
And then you got one
times a hundred is 100,

137
00:04:59,020 --> 00:05:00,771
and then you got your two times 20,

138
00:05:00,771 --> 00:05:02,187
two times 10 is 20,

139
00:05:02,187 --> 00:05:03,272
and seven times one is seven.

140
00:05:03,272 --> 00:05:04,140
So you get 127.

141
00:05:04,140 --> 00:05:05,460
That's your typical base 10

142
00:05:05,460 --> 00:05:09,560
or your real life numbering
system that you currently know

143
00:05:09,560 --> 00:05:11,773
as decimal or regular numbers.

144
00:05:12,950 --> 00:05:16,290
To go backwards from
octal between decimal,

145
00:05:16,290 --> 00:05:18,410
to get from decimal to octal,

146
00:05:18,410 --> 00:05:19,760
we do remainders.

147
00:05:19,760 --> 00:05:22,450
So 127 divided by eight
is 15 remainder one.

148
00:05:22,450 --> 00:05:24,820
Keep the remainder on the right-hand side.

149
00:05:24,820 --> 00:05:27,580
15 over eight is one remainder seven,

150
00:05:27,580 --> 00:05:31,100
and then one remainder eight
is zero reminder seven,

151
00:05:31,100 --> 00:05:36,100
and then you get the octal
number is the right-hand digits

152
00:05:37,060 --> 00:05:39,293
basically you lined up
next to each other, 177.

153
00:05:41,670 --> 00:05:43,140
So notably from that example,

154
00:05:43,140 --> 00:05:45,380
you would've obviously
been looking at the 127,

155
00:05:45,380 --> 00:05:47,150
a really recognizable number.

156
00:05:47,150 --> 00:05:48,000
This is check host.

157
00:05:48,000 --> 00:05:49,690
If anyone doesn't know,
it's an awesome website,

158
00:05:49,690 --> 00:05:51,350
Russian website, I believe.

159
00:05:51,350 --> 00:05:52,920
There's no capture or anything like.

160
00:05:52,920 --> 00:05:54,310
You just plug in the IP address.

161
00:05:54,310 --> 00:05:55,143
You can ping it.

162
00:05:55,143 --> 00:05:57,320
You can mainly, one of
the things I get out of it

163
00:05:57,320 --> 00:06:00,190
is you can discern between DBIP, MaxMind,

164
00:06:00,190 --> 00:06:02,680
and I think it's IP2address
or something like that.

165
00:06:02,680 --> 00:06:06,520
You can maximize your (indistinct)
by comparing the three

166
00:06:06,520 --> 00:06:08,550
and calculating where a database

167
00:06:08,550 --> 00:06:13,550
is getting its geolocation
from in some cases.

168
00:06:13,570 --> 00:06:16,080
So 0177, if you put that
in your address bar,

169
00:06:16,080 --> 00:06:18,940
you'll actually go through
to your home address.

170
00:06:18,940 --> 00:06:21,460
But if you put that without
the zero in the front,

171
00:06:21,460 --> 00:06:22,900
which we'll allude to later,

172
00:06:22,900 --> 00:06:24,097
you actually get to a Brazilian IP.

173
00:06:24,097 --> 00:06:26,330
And I'm not gonna blur this IP address out

174
00:06:26,330 --> 00:06:27,570
'cause it's pretty well known,

175
00:06:27,570 --> 00:06:32,300
but 177.0.0.1 is somewhere
in the middle of Brazil.

176
00:06:32,300 --> 00:06:35,870
And then the reverse of this
is the resolution of 0127,

177
00:06:35,870 --> 00:06:38,503
which goes to 87.0.0.1,

178
00:06:39,540 --> 00:06:41,480
and that's some random one in Italy.

179
00:06:41,480 --> 00:06:43,080
I think before we were looking at this,

180
00:06:43,080 --> 00:06:44,740
that was owned by Level
Three Communications,

181
00:06:44,740 --> 00:06:46,800
but it looks like
someone else has actually

182
00:06:46,800 --> 00:06:48,780
taken up the roster on
that IP address there,

183
00:06:48,780 --> 00:06:50,350
which is quite interesting.

184
00:06:50,350 --> 00:06:52,130
So this actually, this vulnerability,

185
00:06:52,130 --> 00:06:53,550
as you can see where it's kind of heading,

186
00:06:53,550 --> 00:06:56,940
is based on the fact that
some parsing libraries,

187
00:06:56,940 --> 00:06:58,300
I'd say all of them, pretty much,

188
00:06:58,300 --> 00:07:00,420
have some sort of nuances in the way

189
00:07:00,420 --> 00:07:01,800
that they parse IP addresses,

190
00:07:01,800 --> 00:07:03,700
and that Daniel Stenberg,

191
00:07:03,700 --> 00:07:04,990
who runs the curl project,

192
00:07:04,990 --> 00:07:09,200
he fixed this in 2018
on the Linux or GNU side

193
00:07:09,200 --> 00:07:12,270
where 177 with a zero in the front,

194
00:07:12,270 --> 00:07:13,550
which means octal,

195
00:07:13,550 --> 00:07:15,680
would actually resolve
to the funny address

196
00:07:15,680 --> 00:07:17,630
that's located there in Brazil.

197
00:07:17,630 --> 00:07:18,860
And he called it a funny host,

198
00:07:18,860 --> 00:07:20,660
which I thought was quite hilarious.

199
00:07:21,630 --> 00:07:24,290
And the part of this
presentation we're alluding to

200
00:07:24,290 --> 00:07:26,700
in the terms of rotten code
is that a lot of people

201
00:07:26,700 --> 00:07:29,810
have different ideas of how code works

202
00:07:29,810 --> 00:07:33,760
and implementations and
standards and changing schema,

203
00:07:33,760 --> 00:07:34,713
things like that.

204
00:07:35,670 --> 00:07:37,080
It's not a blame game,

205
00:07:37,080 --> 00:07:41,290
but a lot of languages have
turned bugs into features

206
00:07:41,290 --> 00:07:43,920
or things that they've added along the way

207
00:07:43,920 --> 00:07:46,150
have actually been the
incorrect way to add them

208
00:07:46,150 --> 00:07:48,160
or there's typos or there's manipulation

209
00:07:48,160 --> 00:07:52,040
or even there might be
code that's being inserted

210
00:07:52,040 --> 00:07:55,130
maliciously through, I
guess, rogue commits.

211
00:07:55,130 --> 00:07:58,660
But another part we wanna
allude to is how well tested

212
00:07:58,660 --> 00:08:00,310
is some of the libraries you've been using

213
00:08:00,310 --> 00:08:02,680
and how well do you trust those libraries?

214
00:08:02,680 --> 00:08:04,740
This is interesting excerpt
we got from Wikipedia

215
00:08:04,740 --> 00:08:06,516
in the term of octal.

216
00:08:06,516 --> 00:08:08,010
There's a lot of different
ways you can prefix numbers

217
00:08:08,010 --> 00:08:10,060
to represent octal numbers.

218
00:08:10,060 --> 00:08:13,840
A lot of people might
remember the backslash 73

219
00:08:13,840 --> 00:08:17,380
as being the most common
way of referring to octal,

220
00:08:17,380 --> 00:08:21,920
where by 0o is actually typical of octal

221
00:08:21,920 --> 00:08:24,660
and then 0x is typical of hexadecimal,

222
00:08:24,660 --> 00:08:25,860
and that's true in C.

223
00:08:25,860 --> 00:08:27,190
And then furthermore,

224
00:08:27,190 --> 00:08:30,060
that was actually taken
up by Python, OCaml,

225
00:08:30,060 --> 00:08:33,480
Haskell, Raku, Ruby, TCL, PHP,

226
00:08:33,480 --> 00:08:35,350
and then we've got ECMAScript,

227
00:08:35,350 --> 00:08:37,510
which is actually a JavaScript space

228
00:08:37,510 --> 00:08:39,138
rule structure or standards.

229
00:08:39,138 --> 00:08:41,550
And we'll get into that a bit later on,

230
00:08:41,550 --> 00:08:43,170
but there's actually some confusion there

231
00:08:43,170 --> 00:08:44,150
based around the standards

232
00:08:44,150 --> 00:08:49,030
so that ECMA 6 and ECMA 3
and ECMA 5 are all different

233
00:08:49,030 --> 00:08:53,883
in the way that they should or
shouldn't pass octal values.

234
00:08:55,090 --> 00:08:58,930
And this has been "discouraged,"
in quotation marks.

235
00:08:58,930 --> 00:09:01,900
That does not mean that
it's been employed,

236
00:09:01,900 --> 00:09:03,850
but I'll just quickly say for the record,

237
00:09:03,850 --> 00:09:07,620
you can use use strict to
avoid this kind of instance.

238
00:09:07,620 --> 00:09:09,340
So a lot of IoT devices,

239
00:09:09,340 --> 00:09:10,880
they don't have the sort of capability

240
00:09:10,880 --> 00:09:13,010
or even memory allowed

241
00:09:13,010 --> 00:09:14,570
or memory allocated to the device

242
00:09:14,570 --> 00:09:16,810
where it can actually realistically

243
00:09:16,810 --> 00:09:20,020
or reliably parse an IP address.

244
00:09:20,020 --> 00:09:21,570
Parsing IP addresses should actually be

245
00:09:21,570 --> 00:09:24,313
the same sort of meme as passing HTML.

246
00:09:25,290 --> 00:09:27,400
IP addresses are a bit complicated

247
00:09:27,400 --> 00:09:28,810
in that if you do a Wireshark,

248
00:09:28,810 --> 00:09:30,380
you'll see the MAC address pop up,

249
00:09:30,380 --> 00:09:32,780
you'll see the IP address
pop up in hexadecimal,

250
00:09:32,780 --> 00:09:34,430
but what you want to see is octal, okay?

251
00:09:34,430 --> 00:09:36,570
So that's a little thing that
a lot of people are missing

252
00:09:36,570 --> 00:09:38,760
is the octal usage of numbers.

253
00:09:38,760 --> 00:09:41,080
Everything boils back down to libc.

254
00:09:41,080 --> 00:09:43,410
So depending which
operating system you're on,

255
00:09:43,410 --> 00:09:46,910
Windows can, we'll keep
Windows aside for the moment,

256
00:09:46,910 --> 00:09:49,410
but all of it's based on translating

257
00:09:49,410 --> 00:09:52,720
network addresses from hexadecimal
into something readable,

258
00:09:52,720 --> 00:09:54,920
into all that 16-bit
network representation,

259
00:09:54,920 --> 00:09:56,610
32-bit, et cetera, et cetera,

260
00:09:56,610 --> 00:09:58,840
or even into the octal format.

261
00:09:58,840 --> 00:10:00,760
The reason is for using the,

262
00:10:00,760 --> 00:10:02,430
the reason we do that is to obviously

263
00:10:02,430 --> 00:10:04,150
use it in other programs.

264
00:10:04,150 --> 00:10:06,683
So programs to program communication.

265
00:10:08,730 --> 00:10:09,659
So this is really funny.

266
00:10:09,659 --> 00:10:12,720
Me yelling at my computer
because my code isn't doing

267
00:10:12,720 --> 00:10:14,070
what I want it to do,

268
00:10:14,070 --> 00:10:15,750
and then on the other side,

269
00:10:15,750 --> 00:10:18,150
my code is doing exactly
what it was told to do.

270
00:10:19,610 --> 00:10:21,710
In this picture here, we've got a...

271
00:10:22,960 --> 00:10:26,650
This is just a Wireshark dump
just to sort of emphasize

272
00:10:26,650 --> 00:10:28,620
the packet itself

273
00:10:28,620 --> 00:10:30,620
and what you can actually
find out of the packet.

274
00:10:30,620 --> 00:10:32,310
It lets you click on the
different parts of the packet

275
00:10:32,310 --> 00:10:33,300
and identify what's there.

276
00:10:33,300 --> 00:10:35,110
Obviously if you're a bit more savvy

277
00:10:35,110 --> 00:10:36,380
with the network address translation,

278
00:10:36,380 --> 00:10:39,480
you can just see the bytes in themselves,

279
00:10:39,480 --> 00:10:40,890
or the other way to do it is just to click

280
00:10:40,890 --> 00:10:41,723
on the source address.

281
00:10:41,723 --> 00:10:45,120
For example, 10.8.160.235.

282
00:10:45,120 --> 00:10:46,900
I believe I'm behind a VPN.

283
00:10:46,900 --> 00:10:49,120
And then you can see each
individual byte there.

284
00:10:49,120 --> 00:10:50,640
The four bytes are represented

285
00:10:51,499 --> 00:10:55,830
as the actual integer
values, 10, 8, 160, 235,

286
00:10:55,830 --> 00:10:57,370
and that's the full IP address.

287
00:10:57,370 --> 00:10:59,110
But where did the dots come in from?

288
00:10:59,110 --> 00:11:01,650
Well, the dots come in from translating.

289
00:11:01,650 --> 00:11:04,400
So they're not actually
part of the packet.

290
00:11:04,400 --> 00:11:06,610
That's where kind of the issue lies

291
00:11:06,610 --> 00:11:08,980
is that most of the translational errors

292
00:11:08,980 --> 00:11:11,410
come from people not understanding that

293
00:11:11,410 --> 00:11:13,913
or skipping parts or just human error.

294
00:11:14,770 --> 00:11:16,820
But the only real reason
that people use octal

295
00:11:16,820 --> 00:11:19,563
is kind of like just basically
for testing out SSRF.

296
00:11:21,007 --> 00:11:23,930
And that brings us to our
first entry to the story here,

297
00:11:23,930 --> 00:11:25,940
which is the nodejs project private-ip,

298
00:11:25,940 --> 00:11:29,170
which has got something like
12,000 weekly downloads.

299
00:11:29,170 --> 00:11:34,170
We came across this about nine
months ago when John Jackson

300
00:11:34,790 --> 00:11:37,360
and Harold came across this vulnerability

301
00:11:37,360 --> 00:11:38,800
when they were working.

302
00:11:38,800 --> 00:11:41,310
And one of the vulnerability
reports they received

303
00:11:41,310 --> 00:11:43,400
was in relation to SSRF.

304
00:11:43,400 --> 00:11:46,180
So someone was able to
request server files

305
00:11:46,180 --> 00:11:48,830
belonged to the server
when in the real world,

306
00:11:48,830 --> 00:11:51,160
they weren't actually supposed
to receive those files.

307
00:11:51,160 --> 00:11:54,100
And the way they used that
was using SSRF techniques

308
00:11:54,100 --> 00:11:57,530
involving submitting octal
numbers to the module

309
00:11:57,530 --> 00:12:00,280
and getting to a public facing module

310
00:12:00,280 --> 00:12:03,433
and getting back private files
that belong to the server.

311
00:12:05,010 --> 00:12:05,843
And just for reiteration here,

312
00:12:05,843 --> 00:12:09,240
this has 12,000 weekly
downloads to this project.

313
00:12:09,240 --> 00:12:12,793
The project hadn't made
updates for about three years,

314
00:12:13,840 --> 00:12:15,220
and what it previously had

315
00:12:15,220 --> 00:12:17,200
was a bunch of regular expressions

316
00:12:17,200 --> 00:12:20,530
in a form that I would
probably say is unmaintainable.

317
00:12:20,530 --> 00:12:21,830
Some people would beg to differ,

318
00:12:21,830 --> 00:12:25,340
but the maintainability
of regex in this format

319
00:12:25,340 --> 00:12:27,620
is quite hard for someone to
just come along as a newbie,

320
00:12:27,620 --> 00:12:29,560
particularly if they don't know regex

321
00:12:29,560 --> 00:12:31,858
or if they're not that
strong or familiar with it.

322
00:12:31,858 --> 00:12:33,560
But there's better ways to do this.

323
00:12:33,560 --> 00:12:34,860
What we thought at the time,

324
00:12:34,860 --> 00:12:38,310
a better way to do it was
using big set of ranges.

325
00:12:38,310 --> 00:12:41,450
So you can see here, we
got let private ranges,

326
00:12:41,450 --> 00:12:44,763
we've got a bunch of private
ranges here that we allocated.

327
00:12:46,860 --> 00:12:48,810
And just here just
quickly just showing you

328
00:12:48,810 --> 00:12:49,780
the private internets.

329
00:12:49,780 --> 00:12:52,490
This is just a really
classic document from 1996

330
00:12:53,630 --> 00:12:56,405
where they put the reserve
ranges as specified.

331
00:12:56,405 --> 00:13:00,240
These were the three
basic ones at the start.

332
00:13:00,240 --> 00:13:01,810
As you clearly see, point number six,

333
00:13:01,810 --> 00:13:03,710
security's not addressed in this memo.

334
00:13:04,920 --> 00:13:09,920
Some examples of where
public IP addresses may

335
00:13:10,050 --> 00:13:12,840
or may not be used is like arrival

336
00:13:12,840 --> 00:13:15,400
and departure terminal
displays at airports,

337
00:13:15,400 --> 00:13:18,763
which we now know clearly need TCP/IP,

338
00:13:19,890 --> 00:13:22,210
and then cash registers.

339
00:13:22,210 --> 00:13:25,793
Obviously they use TCP/IP
connected to the web now.

340
00:13:26,800 --> 00:13:28,070
Money machines, all that sort of stuff.

341
00:13:28,070 --> 00:13:29,823
So they got some of this wrong.

342
00:13:30,920 --> 00:13:32,567
Banks weren't supposed to
be connected to the net,

343
00:13:32,567 --> 00:13:35,100
and now everyone's literally
banking on the net.

344
00:13:35,100 --> 00:13:37,950
So, and then yeah,

345
00:13:37,950 --> 00:13:40,457
two of the addresses
that we had in the tests

346
00:13:40,457 --> 00:13:43,260
were actually false.

347
00:13:43,260 --> 00:13:44,093
They're actually incorrect

348
00:13:44,093 --> 00:13:45,330
'cause they're actually private IPs,

349
00:13:45,330 --> 00:13:46,163
so they shouldn't have been

350
00:13:46,163 --> 00:13:49,740
in the public IP address test case.

351
00:13:49,740 --> 00:13:53,400
For the original package private IP,

352
00:13:53,400 --> 00:13:55,480
we removed those, obviously,

353
00:13:55,480 --> 00:13:57,880
and then we added a bunch
more test cases there.

354
00:13:59,600 --> 00:14:03,420
This is the new IPv6 rejects that Vasco,

355
00:14:03,420 --> 00:14:08,420
another maintainer from
the lib-ptp, I think,

356
00:14:08,760 --> 00:14:11,300
they added IPv6.

357
00:14:11,300 --> 00:14:12,850
As you can see, regex is regex.

358
00:14:14,690 --> 00:14:15,790
You either love it or hate it.

359
00:14:15,790 --> 00:14:16,720
I love it.

360
00:14:16,720 --> 00:14:18,210
However, in this kind of context,

361
00:14:18,210 --> 00:14:21,930
it's not really maintainable
to a level that we'd expect

362
00:14:21,930 --> 00:14:24,600
for application that's used by X amount

363
00:14:24,600 --> 00:14:26,933
of thousand dependencies,

364
00:14:28,100 --> 00:14:30,110
and that's probably the reason
why the original package

365
00:14:30,110 --> 00:14:32,583
was not updated for three years.

366
00:14:34,700 --> 00:14:35,603
And regex.

367
00:14:37,970 --> 00:14:40,640
So here we're looking at the second module

368
00:14:41,500 --> 00:14:42,333
that we found was netmask.

369
00:14:42,333 --> 00:14:44,070
It's the one we added.

370
00:14:44,070 --> 00:14:45,780
You're looking at 3
million weekly downloads.

371
00:14:45,780 --> 00:14:48,350
This is a big one. This is a
lot bigger than that other one.

372
00:14:48,350 --> 00:14:51,753
I'd say in magnitude, an
order of magnitude larger.

373
00:14:54,170 --> 00:14:58,823
9.8 critical for this one
with Harold and John Jackson.

374
00:15:00,020 --> 00:15:01,670
So here's the first CVE.

375
00:15:01,670 --> 00:15:04,360
We had insufficient
regex in private IP 1.0.5

376
00:15:07,390 --> 00:15:11,380
was insufficiently filtering ranges

377
00:15:11,380 --> 00:15:13,870
that were actually supposed
to be private ranges.

378
00:15:13,870 --> 00:15:15,820
And that's why people
could actually submit URLs

379
00:15:15,820 --> 00:15:17,810
to applications using this package

380
00:15:17,810 --> 00:15:21,540
and actually get files
that belong to the server,

381
00:15:21,540 --> 00:15:23,503
which is obviously disastrous.

382
00:15:24,390 --> 00:15:25,470
And then after that,

383
00:15:25,470 --> 00:15:29,393
because we'd actually entered
the netmask project in there,

384
00:15:30,240 --> 00:15:32,420
someone actually came and
found another vulnerability,

385
00:15:32,420 --> 00:15:35,017
and then one thing led to another,

386
00:15:35,017 --> 00:15:35,933
and we actually found out

387
00:15:35,933 --> 00:15:37,690
that netmask itself was vulnerable,

388
00:15:37,690 --> 00:15:39,340
which was hilarious.

389
00:15:39,340 --> 00:15:42,270
And you can see here that it's pretty much

390
00:15:42,270 --> 00:15:43,700
exactly the same vulnerability.

391
00:15:43,700 --> 00:15:47,080
And then another guy named
Ryatack came in midway

392
00:15:47,080 --> 00:15:49,520
or another researcher named Ryatack,

393
00:15:49,520 --> 00:15:53,397
he came in halfway and
actually found another CVE,

394
00:15:54,360 --> 00:15:57,330
because the complete fix
wasn't actually correct.

395
00:15:57,330 --> 00:15:58,820
And this was only scored a 5.3,

396
00:15:58,820 --> 00:16:01,663
'cause I think it was only
out for, like, two days,

397
00:16:02,630 --> 00:16:05,520
although it is the same
impact as the first one.

398
00:16:05,520 --> 00:16:07,560
- [Kelly] So we're in tmux in a container.

399
00:16:07,560 --> 00:16:10,610
I just wanted to run
through the netmask CVE.

400
00:16:10,610 --> 00:16:12,520
So this is the last vulnerable version

401
00:16:12,520 --> 00:16:15,040
before we started making
changes with the maintainer.

402
00:16:15,040 --> 00:16:19,873
And we're just picking an
arbitrary CIDR block, 31.0.0.0/8.

403
00:16:20,890 --> 00:16:24,460
First address in this block is 31.0.0.1.

404
00:16:24,460 --> 00:16:25,693
Last address.

405
00:16:26,640 --> 00:16:31,190
And so then this block
should contain 31.5.5.5.

406
00:16:31,190 --> 00:16:35,190
However, this block should
not contain 031.5.5.5

407
00:16:35,190 --> 00:16:39,260
because 031 is 25 in decimal,

408
00:16:39,260 --> 00:16:40,703
if we convert it properly.

409
00:16:41,860 --> 00:16:43,810
Now we'll see the same thing in coffee.

410
00:16:46,080 --> 00:16:48,650
I wanted to show coffee
because netmask itself

411
00:16:48,650 --> 00:16:49,850
was originally written in coffee

412
00:16:49,850 --> 00:16:52,013
and it's transpiled to node.

413
00:16:53,590 --> 00:16:54,973
Okay, that's the same.

414
00:16:56,120 --> 00:16:58,420
And unfortunately that is also the same.

415
00:16:58,420 --> 00:17:00,960
Now, why does this happen?

416
00:17:00,960 --> 00:17:04,220
Underneath in the netmask library,

417
00:17:04,220 --> 00:17:06,030
this function parseInt is being called.

418
00:17:06,030 --> 00:17:07,120
And so parseInt,

419
00:17:07,120 --> 00:17:09,700
if it's not passed a base
as the second argument,

420
00:17:09,700 --> 00:17:11,930
will just chop that leading zero right off

421
00:17:11,930 --> 00:17:14,360
and pretend it got a decimal.

422
00:17:14,360 --> 00:17:16,600
When 031 should be 25,

423
00:17:16,600 --> 00:17:18,173
it'll just come out as 31.

424
00:17:19,050 --> 00:17:21,300
And we're gonna see the same
thing in coffee, unfortunately,

425
00:17:21,300 --> 00:17:23,330
even though coffee has the advantage

426
00:17:23,330 --> 00:17:26,950
of not accepting leading zero
notation otherwise, right?

427
00:17:26,950 --> 00:17:31,950
So we should be using 0o0 if
we really want octal in coffee.

428
00:17:33,780 --> 00:17:35,730
All right, so what?

429
00:17:35,730 --> 00:17:38,030
So back in 2018 again,

430
00:17:38,030 --> 00:17:43,030
Nicolas Gregoire responds to
curl guy tweeting about octal.

431
00:17:43,410 --> 00:17:46,350
He says, yeah, bad octal
conversions are a legit way

432
00:17:46,350 --> 00:17:49,990
that we can use to get
around anti-SSRF filters.

433
00:17:49,990 --> 00:17:51,190
If you haven't heard of Nicolas,

434
00:17:51,190 --> 00:17:52,720
he's associated with PortSwigger

435
00:17:52,720 --> 00:17:54,550
as an official Burp Suite trainer.

436
00:17:54,550 --> 00:17:57,640
He teaches people how to
use one of the most popular

437
00:17:57,640 --> 00:17:59,570
web app hacking tools in the world.

438
00:17:59,570 --> 00:18:02,470
And he references his
talk from AppSec Euro 2015

439
00:18:02,470 --> 00:18:04,330
and says, yeah, if you're interested,

440
00:18:04,330 --> 00:18:07,540
checkout pages 24 to 28 of my slides.

441
00:18:07,540 --> 00:18:09,670
So it's pretty clear that
this is an accepted way

442
00:18:09,670 --> 00:18:13,090
to get to a place where
we can achieve SSRF.

443
00:18:13,090 --> 00:18:15,240
Once we can bypass input validation,

444
00:18:15,240 --> 00:18:18,130
we can potentially execute local code.

445
00:18:18,130 --> 00:18:21,870
Around the time we were
doing this research in March,

446
00:18:21,870 --> 00:18:24,050
the node netmask package had about

447
00:18:24,050 --> 00:18:26,470
238 million lifetime downloads.

448
00:18:26,470 --> 00:18:29,060
So it's a bit more
popular than private IP.

449
00:18:29,060 --> 00:18:32,480
It had around 2.8 million
people downloading it

450
00:18:32,480 --> 00:18:33,780
directly every week.

451
00:18:33,780 --> 00:18:38,547
About 170 packages public in
npm declare it as a dependency.

452
00:18:38,547 --> 00:18:43,547
289,515 packages on GitHub
declared it as a dependent

453
00:18:43,630 --> 00:18:45,870
last we checked the
dependency graph, as well.

454
00:18:45,870 --> 00:18:48,723
So it's pretty popular for
a node package, I'd say.

455
00:18:49,950 --> 00:18:53,100
In Ax's original write-up
on bleeping computer,

456
00:18:53,100 --> 00:18:55,610
he mentioned, perhaps rightfully,

457
00:18:55,610 --> 00:18:57,220
the Perl component Net::Netmask,

458
00:18:57,220 --> 00:18:59,318
which inspired node netmask.

459
00:18:59,318 --> 00:19:01,650
Net::Netmask had the identical flaw,

460
00:19:01,650 --> 00:19:05,420
and its maintainer Joelle
was very quick to file a CVE

461
00:19:05,420 --> 00:19:07,218
and push out a fix pretty much

462
00:19:07,218 --> 00:19:09,900
as soon as the article came
out or slightly before,

463
00:19:09,900 --> 00:19:11,863
which is very commendable.

464
00:19:13,420 --> 00:19:16,000
And it also kind of lit a fire under us.

465
00:19:16,000 --> 00:19:17,790
We were having a good
time looking at things,

466
00:19:17,790 --> 00:19:20,150
or at least Sick, John, and I were.

467
00:19:20,150 --> 00:19:23,300
So then we started looking
at other CIDR parsers

468
00:19:23,300 --> 00:19:24,900
and trying to see, well, okay,

469
00:19:24,900 --> 00:19:26,790
what else could there be
out there in the world

470
00:19:26,790 --> 00:19:29,410
that does this exact same thing

471
00:19:29,410 --> 00:19:32,160
and doesn't quite work the
way the maintainer intended?

472
00:19:34,130 --> 00:19:37,330
So the last time this
package was updated was 2016,

473
00:19:37,330 --> 00:19:38,670
which is fairly reasonable.

474
00:19:38,670 --> 00:19:41,500
CIDR parsers don't exactly
change a whole lot.

475
00:19:41,500 --> 00:19:42,600
This is another package,

476
00:19:42,600 --> 00:19:44,160
a bit like Net::Netmask,

477
00:19:44,160 --> 00:19:47,420
which inspired node netmask
within the Perl ecosystem.

478
00:19:47,420 --> 00:19:49,260
So we've installed the vulnerable version.

479
00:19:49,260 --> 00:19:51,920
We've got our proof of
concept on the right.

480
00:19:51,920 --> 00:19:53,350
And the deal with this package is

481
00:19:53,350 --> 00:19:55,847
you're supposed to use
a guard function is_ipv4

482
00:19:57,560 --> 00:20:00,560
before you call isprivate_ipv4

483
00:20:00,560 --> 00:20:02,860
or ispublic_ipv4.

484
00:20:02,860 --> 00:20:05,180
And we didn't do that
because it wasn't documented

485
00:20:05,180 --> 00:20:07,480
that you needed to do that before the fix.

486
00:20:07,480 --> 00:20:10,240
The documentation was
changed as part of the fix.

487
00:20:10,240 --> 00:20:11,190
So we're just gonna run it

488
00:20:11,190 --> 00:20:13,490
and show you the output here real quick.

489
00:20:13,490 --> 00:20:16,830
And so like with netmask
and everything else,

490
00:20:16,830 --> 00:20:20,990
the idea here is an attacker
could submit input data

491
00:20:20,990 --> 00:20:23,870
which is an octal which should be private

492
00:20:23,870 --> 00:20:25,960
and ends up pointing to something

493
00:20:25,960 --> 00:20:27,130
that is a false negative,

494
00:20:27,130 --> 00:20:29,290
which results in SSRF bypass.

495
00:20:29,290 --> 00:20:30,620
And the same thing with things

496
00:20:30,620 --> 00:20:32,990
that should be public and are not.

497
00:20:32,990 --> 00:20:36,130
So there's a couple of
things that do work here,

498
00:20:36,130 --> 00:20:38,160
a couple of things that don't work here.

499
00:20:38,160 --> 00:20:39,480
If you wanted to exploit this,

500
00:20:39,480 --> 00:20:41,042
you would just sort of have to experiment

501
00:20:41,042 --> 00:20:43,200
to see what was going on.

502
00:20:43,200 --> 00:20:44,800
But the trick is guard function.

503
00:20:46,680 --> 00:20:47,640
- [Sick Codes] If you're
a little bit confused,

504
00:20:47,640 --> 00:20:49,950
you can actually go to sick.codes,

505
00:20:49,950 --> 00:20:51,180
and in the releases section,

506
00:20:51,180 --> 00:20:52,140
you'll find a big writeup

507
00:20:52,140 --> 00:20:54,140
about the original netmask vulnerability

508
00:20:55,320 --> 00:20:56,260
and how it affects you.

509
00:20:56,260 --> 00:20:58,070
It's actually quite a large writeup.

510
00:20:58,070 --> 00:21:00,670
We go into all the details
about that vulnerability.

511
00:21:01,650 --> 00:21:03,450
And here's sort of a table

512
00:21:03,450 --> 00:21:06,580
where you can compare netmask to decimal

513
00:21:06,580 --> 00:21:07,995
and then the reverse of that

514
00:21:07,995 --> 00:21:10,030
and what you should expect.

515
00:21:10,030 --> 00:21:12,860
But what I'd like to point
out is the comments section

516
00:21:17,400 --> 00:21:18,233
So in the comments section,

517
00:21:18,233 --> 00:21:20,040
"Is there a reason for the double check?"

518
00:21:20,040 --> 00:21:22,668
So that was actually a small zero day

519
00:21:22,668 --> 00:21:26,023
that came through in the comments section.

520
00:21:26,950 --> 00:21:29,000
Another one in the comments section was

521
00:21:29,000 --> 00:21:31,043
padding for an anonymous user.

522
00:21:31,900 --> 00:21:33,410
So IP address, I mean,

523
00:21:33,410 --> 00:21:34,800
these are just zero days getting dropped

524
00:21:34,800 --> 00:21:35,800
into the comments section,

525
00:21:35,800 --> 00:21:38,890
which we, I didn't approve them at start,

526
00:21:38,890 --> 00:21:40,290
but I did actually end up approving them

527
00:21:40,290 --> 00:21:42,330
'cause it's been enough time.

528
00:21:42,330 --> 00:21:45,063
So you can zero pad your octals.

529
00:21:45,063 --> 00:21:47,210
You can do all sorts of crazy stuff.

530
00:21:47,210 --> 00:21:48,907
And then Lorens,

531
00:21:48,907 --> 00:21:53,690
"The only reasonable thing is
to consider the IP invalid.

532
00:21:53,690 --> 00:21:54,960
Trying to convince some people

533
00:21:54,960 --> 00:21:57,700
that it should be considered is futile."

534
00:21:57,700 --> 00:21:59,280
And I tend to agree with Lorens

535
00:21:59,280 --> 00:22:04,177
because only IP addresses without eights

536
00:22:04,177 --> 00:22:07,780
are in the octal range alphabet,

537
00:22:07,780 --> 00:22:10,800
so you literally are missing 20%

538
00:22:10,800 --> 00:22:14,140
of your entire address space.

539
00:22:14,140 --> 00:22:14,973
So, yeah.

540
00:22:16,500 --> 00:22:19,670
And one comment from Tony Chung.

541
00:22:19,670 --> 00:22:22,067
I tried to get in contact with Tony.

542
00:22:22,067 --> 00:22:25,070
He was one of the guys that
mentioned to us early on

543
00:22:25,070 --> 00:22:27,380
that Java is probably worth looking at,

544
00:22:27,380 --> 00:22:28,810
and we did actually
end up looking at that,

545
00:22:28,810 --> 00:22:29,680
and emailed Tony.

546
00:22:29,680 --> 00:22:31,546
And Tony, I hope you hear this,

547
00:22:31,546 --> 00:22:35,110
but yeah, appreciate the heads up.

548
00:22:35,110 --> 00:22:36,361
I couldn't approve your
comment at the time

549
00:22:36,361 --> 00:22:38,820
because it was technically a zero day,

550
00:22:38,820 --> 00:22:40,160
but we've been in touch with him.

551
00:22:40,160 --> 00:22:43,230
Hopefully ping back.

552
00:22:43,230 --> 00:22:44,370
- [Kelly] When you're initially learning

553
00:22:44,370 --> 00:22:46,210
about a type of vulnerability,

554
00:22:46,210 --> 00:22:49,010
it may make sense to try and
find it everywhere you can.

555
00:22:49,010 --> 00:22:50,760
Like if you're trying to figure out

556
00:22:50,760 --> 00:22:52,890
how reflected XSS works,

557
00:22:52,890 --> 00:22:54,550
it can be interesting to try that

558
00:22:54,550 --> 00:22:56,670
on basically everything you come across.

559
00:22:56,670 --> 00:22:59,200
And so we applied that to octal a bit.

560
00:22:59,200 --> 00:23:01,820
We knew we had some leads to go on

561
00:23:01,820 --> 00:23:04,270
from some of the things
people were saying,

562
00:23:04,270 --> 00:23:06,710
and there are just so many
vulnerable CIDR parsers

563
00:23:06,710 --> 00:23:08,510
that even when we were
putting this talk together,

564
00:23:08,510 --> 00:23:10,290
we were still finding more.

565
00:23:10,290 --> 00:23:15,290
So not only is it possible
that there are more out there

566
00:23:15,770 --> 00:23:17,440
that are vulnerable like this,

567
00:23:17,440 --> 00:23:19,060
it is quite likely.

568
00:23:19,060 --> 00:23:19,970
- [Sick Codes] So if you didn't really get

569
00:23:19,970 --> 00:23:22,220
what's going on at the moment,

570
00:23:22,220 --> 00:23:25,970
basically we're just applying the same CVE

571
00:23:25,970 --> 00:23:27,760
to a whole bunch of different languages,

572
00:23:27,760 --> 00:23:30,440
a Python, Perl, Golang,

573
00:23:30,440 --> 00:23:33,300
Java, JavaScript in the form of nodejs,

574
00:23:33,300 --> 00:23:34,930
and another Perl one.

575
00:23:34,930 --> 00:23:36,893
And here's the one by Dave.

576
00:23:38,070 --> 00:23:40,480
So we opened a issue at Chromium project

577
00:23:40,480 --> 00:23:43,760
stating that the V8 engine is wrong

578
00:23:43,760 --> 00:23:47,100
because eight doesn't actually
exist in the octal alphabet.

579
00:23:47,100 --> 00:23:48,803
After the number seven is 10,

580
00:23:49,817 --> 00:23:52,493
and that's relating to decimal only.

581
00:23:53,900 --> 00:23:56,670
So it's apparently working as intended.

582
00:23:56,670 --> 00:23:58,820
And we opened up an issue on ECMA,

583
00:23:58,820 --> 00:24:01,750
and they've said they
don't wanna fix the issue

584
00:24:01,750 --> 00:24:03,203
because it's too old.

585
00:24:04,635 --> 00:24:06,573
It's not even a bug, apparently.

586
00:24:09,130 --> 00:24:12,623
But yeah, so you have to be,
just have to deal with it.

587
00:24:14,780 --> 00:24:16,850
- [Kelly] Going over to the
Mozilla developer reference

588
00:24:16,850 --> 00:24:19,290
for a second to check out what
it says about these errors

589
00:24:19,290 --> 00:24:21,550
that we were discussing
with the Chromium team,

590
00:24:21,550 --> 00:24:23,740
we see a couple of things here.

591
00:24:23,740 --> 00:24:26,249
So firstly, as mentioned
by the Chromium team,

592
00:24:26,249 --> 00:24:28,720
octal literals, the leading
zero format literals

593
00:24:28,720 --> 00:24:30,170
which represent octal integers,

594
00:24:30,170 --> 00:24:31,633
will throw an error in strict mode,

595
00:24:31,633 --> 00:24:32,780
which is nice.

596
00:24:32,780 --> 00:24:35,140
But this doesn't exactly
help us with either netmask

597
00:24:35,140 --> 00:24:37,130
or with the behavior of parseInt,

598
00:24:37,130 --> 00:24:40,600
which still allows zero prefix
literals input as strings

599
00:24:40,600 --> 00:24:42,560
or integers even in strict mode.

600
00:24:42,560 --> 00:24:47,560
So the second thing is JavaScript
mixes zero prefix literals

601
00:24:47,580 --> 00:24:49,140
that get interpreted as decimal

602
00:24:49,140 --> 00:24:52,260
with zero prefix literals
that get interpreted as octal.

603
00:24:52,260 --> 00:24:54,660
And we find this one of
the weirdest footguns

604
00:24:54,660 --> 00:24:56,360
we've encountered so far with JavaScript

605
00:24:56,360 --> 00:24:58,380
aside from parseInt's behavior.

606
00:24:58,380 --> 00:24:59,910
To explain this a little bit,

607
00:24:59,910 --> 00:25:02,600
since the only digits in base
eight are zero through seven,

608
00:25:02,600 --> 00:25:04,890
this means there are
some extra zero prefixed

609
00:25:04,890 --> 00:25:07,060
integer literals allowed by the ECMA spec,

610
00:25:07,060 --> 00:25:09,600
and they get interpreted as decimal.

611
00:25:09,600 --> 00:25:10,720
- [Sick Codes] After the chromium project,

612
00:25:10,720 --> 00:25:12,990
we opened one at nodejs itself

613
00:25:12,990 --> 00:25:15,630
to see if they could
do something about it.

614
00:25:15,630 --> 00:25:17,700
Mozilla apparently doesn't treat it

615
00:25:17,700 --> 00:25:19,640
as illegal octal constant.

616
00:25:19,640 --> 00:25:21,180
That's because it isn't.

617
00:25:21,180 --> 00:25:23,230
There's like, there's only seven numbers.

618
00:25:24,340 --> 00:25:27,540
And so V8's rejected it,

619
00:25:27,540 --> 00:25:28,623
nodejs rejected it,

620
00:25:29,845 --> 00:25:34,845
and pretty much then the
last opportunity we had

621
00:25:35,170 --> 00:25:38,160
to raise the issue is with ECMA itself.

622
00:25:38,160 --> 00:25:40,260
And I said that these numbers don't exist.

623
00:25:41,660 --> 00:25:43,403
They said websites will break.

624
00:25:45,400 --> 00:25:48,950
And the end of the discussion
is no one has claimed

625
00:25:48,950 --> 00:25:50,473
this doesn't make sense,

626
00:25:51,350 --> 00:25:52,620
just that we can't change it

627
00:25:52,620 --> 00:25:54,930
because it will break a bunch of websites.

628
00:25:54,930 --> 00:25:59,930
So the bug has moved into feature status.

629
00:26:02,810 --> 00:26:06,230
So here we'll present
a Rust CVE, Golang CVE,

630
00:26:06,230 --> 00:26:08,793
a Python one, and some Oracle stuff.

631
00:26:10,030 --> 00:26:12,410
- [Kelly] So Cheng sort
of decided for Rust

632
00:26:12,410 --> 00:26:16,450
that they would just reject
zero prefixed octets,

633
00:26:16,450 --> 00:26:18,200
which is likely the right decision.

634
00:26:19,980 --> 00:26:24,239
So leading zero on IP string
interpreted as octal literals.

635
00:26:24,239 --> 00:26:25,320
A simple demo here.

636
00:26:25,320 --> 00:26:29,893
We see that 0127 becomes
127 when it shouldn't be.

637
00:26:31,800 --> 00:26:33,610
Yeah, this may cause
security vulnerabilities

638
00:26:33,610 --> 00:26:34,753
in certain cases.

639
00:26:38,330 --> 00:26:42,220
The specification also allows
hex formats in IP strings.

640
00:26:42,220 --> 00:26:46,030
Yeah, so the end result of this is

641
00:26:46,030 --> 00:26:48,490
only decimal is allowed in Rust,

642
00:26:48,490 --> 00:26:51,320
which is better for user input.

643
00:26:51,320 --> 00:26:52,440
Yeah, it's not at all obvious

644
00:26:52,440 --> 00:26:54,420
that we should parse octal IP addresses.

645
00:26:54,420 --> 00:26:56,470
It seems exceedingly unlikely to come up

646
00:26:56,470 --> 00:26:58,170
outside of security advisories.

647
00:26:58,170 --> 00:27:00,890
Yeah.
(laughs)

648
00:27:00,890 --> 00:27:03,610
So this made it into 1.5 3.0,

649
00:27:03,610 --> 00:27:04,560
which is super cool.

650
00:27:04,560 --> 00:27:06,160
Congrats, Cheng.

651
00:27:06,160 --> 00:27:07,780
Fixing the comments,

652
00:27:07,780 --> 00:27:10,430
fixing the code and
referencing the same RFC draft

653
00:27:10,430 --> 00:27:12,633
as the Python thread did, interestingly.

654
00:27:13,500 --> 00:27:17,050
So, which says that octal is a rare format

655
00:27:17,050 --> 00:27:18,740
for user input for IP addresses

656
00:27:18,740 --> 00:27:20,320
and we shouldn't parse it.

657
00:27:20,320 --> 00:27:24,740
Yeah, if number starting
with zero is not none,

658
00:27:24,740 --> 00:27:25,810
then we don't, you know,

659
00:27:25,810 --> 00:27:27,820
we don't wanna mess with that octet.

660
00:27:27,820 --> 00:27:32,180
So tests to make sure that
octal things are error,

661
00:27:32,180 --> 00:27:33,450
hex things are error,

662
00:27:33,450 --> 00:27:36,700
and let's just run the little
proof of concept from our CVE.

663
00:27:36,700 --> 00:27:39,580
So this is the version of Rust from before

664
00:27:39,580 --> 00:27:41,193
the one with Cheng's fix in it.

665
00:27:42,210 --> 00:27:43,810
I'm gonna compile it real quick.

666
00:27:44,980 --> 00:27:48,100
And then you'll notice that we're changing

667
00:27:48,100 --> 00:27:49,500
individual octets at a time.

668
00:27:49,500 --> 00:27:52,800
So second octet, third
octet, fourth octet,

669
00:27:52,800 --> 00:27:54,390
and then the first octet.

670
00:27:54,390 --> 00:27:57,250
So we've got 026, 026, 093,

671
00:27:57,250 --> 00:27:59,630
and then 099 at the very bottom,

672
00:27:59,630 --> 00:28:01,940
and none of these are
translated correctly.

673
00:28:01,940 --> 00:28:05,660
You know, same parsing logic
applying to all the octets.

674
00:28:05,660 --> 00:28:07,820
With Golang, folks have
been talking about limiting

675
00:28:07,820 --> 00:28:11,060
the size of allowed octets for a while.

676
00:28:11,060 --> 00:28:14,480
So Golang would allow you to
just throw a crap ton of zeros

677
00:28:14,480 --> 00:28:15,313
in front of something

678
00:28:15,313 --> 00:28:17,570
and allow it to still
be treated as decimal.

679
00:28:17,570 --> 00:28:22,190
So, like, 00000192 would still be 192.

680
00:28:22,190 --> 00:28:26,020
But really all you need is
three digits to get to 255,

681
00:28:26,020 --> 00:28:28,200
which is the max size
in decimal for an octet.

682
00:28:28,200 --> 00:28:29,767
So when our writeup came out,

683
00:28:29,767 --> 00:28:33,310
people started talking
about it in the same thread,

684
00:28:33,310 --> 00:28:38,310
and Golang eventually decided
to mimic what Rust did

685
00:28:39,170 --> 00:28:42,210
and return an error on zero prefix input,

686
00:28:42,210 --> 00:28:45,200
which is good because
it avoids the ambiguity

687
00:28:45,200 --> 00:28:49,560
of allowing both octal and decimal,

688
00:28:49,560 --> 00:28:52,667
especially when zero prefixed
octets are probably just

689
00:28:52,667 --> 00:28:56,520
a footgun that most would rather not have.

690
00:28:56,520 --> 00:28:57,540
So here's the change.

691
00:28:57,540 --> 00:29:00,160
It made it into 1.17.

692
00:29:00,160 --> 00:29:01,133
Thanks, Roland.

693
00:29:07,880 --> 00:29:09,063
Docs change.

694
00:29:10,120 --> 00:29:12,070
We now reject IPv4 addresses

695
00:29:12,070 --> 00:29:14,300
which contain decimal components,

696
00:29:14,300 --> 00:29:15,773
octets with leading zeros.

697
00:29:18,440 --> 00:29:20,103
And then this is just a little check

698
00:29:20,103 --> 00:29:22,840
on that first digit, I guess.

699
00:29:22,840 --> 00:29:25,300
Rejection on zero components
with leading zeros.

700
00:29:25,300 --> 00:29:26,133
Boom.

701
00:29:27,690 --> 00:29:30,020
Here's our proof of concept from the CVE.

702
00:29:30,020 --> 00:29:33,070
And we're looking at
octets one at a time again.

703
00:29:33,070 --> 00:29:35,820
The last two little sections here

704
00:29:35,820 --> 00:29:37,900
are just trying hexadecimal.

705
00:29:37,900 --> 00:29:39,360
We're trying some of the things

706
00:29:39,360 --> 00:29:41,200
that we knew worked with netmask

707
00:29:41,200 --> 00:29:43,070
and kind of shouldn't have.

708
00:29:43,070 --> 00:29:44,590
So we're trying, you know,

709
00:29:44,590 --> 00:29:49,170
some CIDR pursers will
also parse IP addresses

710
00:29:49,170 --> 00:29:50,540
that are just a single integer,

711
00:29:50,540 --> 00:29:52,230
and so that's what the last one is.

712
00:29:52,230 --> 00:29:54,970
Second to last is just throwing
a random hexadecimal octet

713
00:29:54,970 --> 00:29:56,263
in there for grins.

714
00:29:57,380 --> 00:29:58,290
So we've got it built.

715
00:29:58,290 --> 00:29:59,510
We're running it.

716
00:29:59,510 --> 00:30:01,250
Yeah, so the hexadecimal ones don't work,

717
00:30:01,250 --> 00:30:03,110
which is encouraging,

718
00:30:03,110 --> 00:30:04,610
but the octal ones do.

719
00:30:04,610 --> 00:30:08,680
That zero on, that leading
zero on those octets there

720
00:30:08,680 --> 00:30:11,330
in octal format just gets stripped off,

721
00:30:11,330 --> 00:30:13,270
and so just the same as decimal

722
00:30:13,270 --> 00:30:15,430
is how they end up being treated,

723
00:30:15,430 --> 00:30:16,680
which is not what we want

724
00:30:19,560 --> 00:30:20,930
of all the languages we looked at

725
00:30:20,930 --> 00:30:22,210
that we found to be vulnerable,

726
00:30:22,210 --> 00:30:24,010
I think Java was my favorite.

727
00:30:24,010 --> 00:30:25,510
So we're running 11,

728
00:30:25,510 --> 00:30:27,490
which is the LTS version.

729
00:30:27,490 --> 00:30:29,143
So compiling it real quick.

730
00:30:33,860 --> 00:30:35,840
Yeah. So we're looking at
one octet at a time again,

731
00:30:35,840 --> 00:30:39,430
and up to 255,

732
00:30:39,430 --> 00:30:43,350
we are interpreting as decimal.

733
00:30:43,350 --> 00:30:45,170
We're just stripping that
leading zero right off.

734
00:30:45,170 --> 00:30:49,260
And then 0256 becomes 174.

735
00:30:49,260 --> 00:30:50,630
Hexadecimal, on the other hand,

736
00:30:50,630 --> 00:30:52,190
seems to be fine.

737
00:30:52,190 --> 00:30:53,310
Fewer dotted quads,

738
00:30:53,310 --> 00:30:55,330
which is a format I noticed
in the documentation,

739
00:30:55,330 --> 00:30:56,773
seems to work out fine.

740
00:30:58,180 --> 00:30:59,550
What else? Get by address.

741
00:30:59,550 --> 00:31:01,900
Inet address get by
address seems to work fine.

742
00:31:01,900 --> 00:31:03,760
Java net URI seems to be fine.

743
00:31:03,760 --> 00:31:05,880
Java net URL seems to be fine.

744
00:31:05,880 --> 00:31:08,340
It's just inet address get by name.

745
00:31:08,340 --> 00:31:12,140
And funny thing about
stopping interpreting

746
00:31:12,140 --> 00:31:13,872
as decimal at 255.

747
00:31:13,872 --> 00:31:16,010
Probably somewhere there's
something that's looking

748
00:31:16,010 --> 00:31:18,520
at three digits out of an octet

749
00:31:18,520 --> 00:31:20,310
and trying to figure out what it is.

750
00:31:20,310 --> 00:31:21,970
So after some back and forth

751
00:31:21,970 --> 00:31:24,040
with the Oracle security bug triage team,

752
00:31:24,040 --> 00:31:25,980
where we were like, well, it's broken,

753
00:31:25,980 --> 00:31:27,590
and they were like, well,
we're not really sure why,

754
00:31:27,590 --> 00:31:31,520
and also it performs differently
in different environments.

755
00:31:31,520 --> 00:31:34,210
We simply weren't sure whether
for ourselves the issue

756
00:31:34,210 --> 00:31:37,190
resides with the underlying C
libraries per operating system

757
00:31:37,190 --> 00:31:40,080
or with the JVM or with the Java compiler.

758
00:31:40,080 --> 00:31:42,410
- [Sick Codes] And obviously
the question comes in there

759
00:31:42,410 --> 00:31:43,960
where Java actually is supposed to run

760
00:31:43,960 --> 00:31:47,150
in a virtual machine, AKA JVM.

761
00:31:47,150 --> 00:31:50,390
The difference is basically
that if you run Java code

762
00:31:50,390 --> 00:31:53,160
just on any operating
system without a JVM,

763
00:31:53,160 --> 00:31:54,940
obviously you'll get different results,

764
00:31:54,940 --> 00:31:57,490
and the benefit of that
is that you can see

765
00:31:57,490 --> 00:32:00,780
the vulnerability being played
out between applications.

766
00:32:00,780 --> 00:32:02,830
However, it won't actually
play out in the real world

767
00:32:02,830 --> 00:32:05,360
unless you're using
Java outside of the JVM.

768
00:32:05,360 --> 00:32:07,910
- [Kelly] So we tested it against
a couple of different JVMs

769
00:32:07,910 --> 00:32:09,560
just to see what would happen

770
00:32:09,560 --> 00:32:12,030
and as well across
different operating systems.

771
00:32:12,030 --> 00:32:17,030
So JVM wise, we tested using
HotSpot and also against Grel,

772
00:32:17,070 --> 00:32:20,260
and we saw our proof of concept
code performed consistently.

773
00:32:20,260 --> 00:32:22,740
However, we did see different results

774
00:32:22,740 --> 00:32:24,820
across different operating systems.

775
00:32:24,820 --> 00:32:26,440
- [Sick Codes] That's where
obviously the security team

776
00:32:26,440 --> 00:32:28,570
from Oracle decided to just say,

777
00:32:28,570 --> 00:32:29,490
it's not really a bug,

778
00:32:29,490 --> 00:32:31,610
and it's the responsibility.

779
00:32:31,610 --> 00:32:36,050
the responsibility is actually
downstream related to libc

780
00:32:36,050 --> 00:32:38,460
and does not affect Oracle's product.

781
00:32:38,460 --> 00:32:40,780
And we asked them if it was
cool to actually discuss that,

782
00:32:40,780 --> 00:32:41,940
and they said yes,

783
00:32:41,940 --> 00:32:43,430
so that's where we are.

784
00:32:43,430 --> 00:32:47,160
- [Kelly] So these are just
some examples of CIDR parsers

785
00:32:47,160 --> 00:32:49,280
where we took the time to investigate

786
00:32:49,280 --> 00:32:52,790
and discovered unique
ways for handling octal.

787
00:32:52,790 --> 00:32:55,400
The point we're trying
to make in this talk is

788
00:32:55,400 --> 00:32:57,220
very few people actually handle

789
00:32:57,220 --> 00:32:59,940
the octal IP address format correctly.

790
00:32:59,940 --> 00:33:03,350
Some of the other languages
which we didn't look at,

791
00:33:03,350 --> 00:33:04,560
but could have,

792
00:33:04,560 --> 00:33:05,750
include LeWitt and Ruby,

793
00:33:05,750 --> 00:33:07,870
and maybe someone else with interest

794
00:33:07,870 --> 00:33:09,100
can come along behind us

795
00:33:09,100 --> 00:33:12,100
and take a peek at some of
the other things out there.

796
00:33:12,100 --> 00:33:13,160
During this work,

797
00:33:13,160 --> 00:33:16,810
we came across a wide variety
of articles and blog posts

798
00:33:16,810 --> 00:33:19,440
and just opinions about how IPv4 parsing

799
00:33:19,440 --> 00:33:21,120
should actually happen,

800
00:33:21,120 --> 00:33:24,290
but not so much in the way of
a single formal definition,

801
00:33:24,290 --> 00:33:26,557
from a discussion around
a reference IPv4 parser

802
00:33:26,557 --> 00:33:29,990
and a blog post that Dave
Anderson wrote back in December,

803
00:33:29,990 --> 00:33:31,350
for such a simple seeming idea,

804
00:33:31,350 --> 00:33:33,790
it is hard in general for people to agree

805
00:33:33,790 --> 00:33:37,480
on what an IPv4 address
actually should be.

806
00:33:37,480 --> 00:33:38,470
Well, I've read the spec,

807
00:33:38,470 --> 00:33:39,610
but most of it is cursed,

808
00:33:39,610 --> 00:33:41,150
so I'll just implement this subset

809
00:33:41,150 --> 00:33:43,100
which fits my definition of acceptable.

810
00:33:43,940 --> 00:33:45,950
The textual representation of IPv4

811
00:33:45,950 --> 00:33:48,060
still doesn't have a single standard.

812
00:33:48,060 --> 00:33:51,930
Grammars or other specifications
for the IPv4 address format

813
00:33:51,930 --> 00:33:55,400
do come up occasionally in RFCs like 1918,

814
00:33:55,400 --> 00:33:56,900
which is the private internet one

815
00:33:56,900 --> 00:33:58,170
that we talked about earlier,

816
00:33:58,170 --> 00:34:01,370
and a variety of drafts that
were simply never ratified

817
00:34:01,370 --> 00:34:02,890
for one reason or another,

818
00:34:02,890 --> 00:34:06,530
and incidentally also in
the definition for IPv6.

819
00:34:06,530 --> 00:34:08,670
The representation has evolved over time,

820
00:34:08,670 --> 00:34:11,030
and this in addition to
people simply not knowing

821
00:34:11,030 --> 00:34:13,050
where to turn has led to a bunch

822
00:34:13,050 --> 00:34:14,600
of slightly different definitions

823
00:34:14,600 --> 00:34:16,200
that mostly interoperate,

824
00:34:16,200 --> 00:34:19,420
but sometimes just clash in fabulous ways.

825
00:34:19,420 --> 00:34:21,900
A handful of the reference
definitions out there simply say

826
00:34:21,900 --> 00:34:24,170
something like dotted decimal form

827
00:34:24,170 --> 00:34:27,360
and just leave the rest as
an exercise to the reader.

828
00:34:27,360 --> 00:34:30,950
If you want to truly parse IPv4 addresses,

829
00:34:30,950 --> 00:34:33,290
this is the bullshit
you have to put up with.

830
00:34:33,290 --> 00:34:34,220
And we do.

831
00:34:34,220 --> 00:34:36,490
IPv4 is still the most widely adopted

832
00:34:36,490 --> 00:34:38,253
IP address format currently.

833
00:34:39,140 --> 00:34:41,410
IPv6 has, according to
the Internet Society,

834
00:34:41,410 --> 00:34:44,770
been operationally deployed
somewhere since at least 2002

835
00:34:44,770 --> 00:34:47,816
and became standardized just in 2017.

836
00:34:47,816 --> 00:34:50,960
Currently only around 35% of the internet

837
00:34:50,960 --> 00:34:52,310
even supports IPv6,

838
00:34:52,310 --> 00:34:54,070
according to Google stats.

839
00:34:54,070 --> 00:34:56,580
So until IPv6 achieves wider adoption,

840
00:34:56,580 --> 00:34:59,530
we'll just have to keep
on with IPv4, as well.

841
00:34:59,530 --> 00:35:02,080
Pretty much anything we
use to purse IP addresses,

842
00:35:02,080 --> 00:35:03,690
whether it was originally intended

843
00:35:03,690 --> 00:35:05,250
to parse IP addresses or not,

844
00:35:05,250 --> 00:35:06,910
is just gonna have some interesting

845
00:35:06,910 --> 00:35:08,720
ifs, ands, and gotchas.

846
00:35:08,720 --> 00:35:11,270
So back in Cheng's Rust pull request,

847
00:35:11,270 --> 00:35:13,920
he mentioned RFC draft 6943,

848
00:35:13,920 --> 00:35:17,370
which is from all the way back in 2013.

849
00:35:17,370 --> 00:35:19,470
If the parties involved
in a security decision

850
00:35:19,470 --> 00:35:22,180
use different algorithms
to compare identifiers,

851
00:35:22,180 --> 00:35:25,130
then failure scenarios
ranging from denial of service

852
00:35:25,130 --> 00:35:27,670
to elevation of privilege can result.

853
00:35:27,670 --> 00:35:29,960
The authors do a decent
job of walking through

854
00:35:29,960 --> 00:35:32,000
exactly what we've shown in this talk.

855
00:35:32,000 --> 00:35:33,870
And so here's a little table.

856
00:35:33,870 --> 00:35:36,370
They're using a couple of different terms,

857
00:35:36,370 --> 00:35:38,300
false positive and false negative.

858
00:35:38,300 --> 00:35:40,910
A false positive means two
identifiers were equal,

859
00:35:40,910 --> 00:35:43,620
but should refer to two different things,

860
00:35:43,620 --> 00:35:45,380
like the octal literals
parsing as decimal literals

861
00:35:45,380 --> 00:35:47,340
in netmask and other places.

862
00:35:47,340 --> 00:35:51,470
For example, 0177 equaling 177.

863
00:35:51,470 --> 00:35:52,530
So on the other hand,

864
00:35:52,530 --> 00:35:55,040
a false negative would
happen when two things

865
00:35:55,040 --> 00:35:56,540
should have been equal, but were not,

866
00:35:56,540 --> 00:36:00,260
like 0177 not equaling 127 when compared.

867
00:36:00,260 --> 00:36:02,790
This draft has existed since
before a lot of the code

868
00:36:02,790 --> 00:36:04,510
that we demoed today.

869
00:36:04,510 --> 00:36:08,390
Not everyone reads spec before
trying to implement something

870
00:36:08,390 --> 00:36:10,290
or even knows it would be useful.

871
00:36:10,290 --> 00:36:12,350
But it does come in handy as a researcher

872
00:36:12,350 --> 00:36:13,410
when you're trying to understand

873
00:36:13,410 --> 00:36:15,410
how something would behave ideally.

874
00:36:15,410 --> 00:36:20,130
Back in 2019, Python decided
they wanted to remove any

875
00:36:20,130 --> 00:36:22,440
and all checks for octal.

876
00:36:22,440 --> 00:36:24,450
Just, you know, it's a rare IP format.

877
00:36:24,450 --> 00:36:25,470
Who really needs that?

878
00:36:25,470 --> 00:36:26,410
Gosh.

879
00:36:26,410 --> 00:36:28,660
So here's the pull
request where it happened.

880
00:36:30,720 --> 00:36:33,640
So here's changing the tests.

881
00:36:33,640 --> 00:36:35,968
No more error message.

882
00:36:35,968 --> 00:36:38,993
No more ambiguous rejection.

883
00:36:42,340 --> 00:36:43,810
Leading zeros are ignored

884
00:36:43,810 --> 00:36:46,430
and are no longer assumed
to specify octal octets.

885
00:36:46,430 --> 00:36:48,150
Yeah, that's the good part.

886
00:36:48,150 --> 00:36:50,850
And so we're gonna look at the issue

887
00:36:50,850 --> 00:36:52,720
where this pull request is discussed

888
00:36:52,720 --> 00:36:55,800
and which was reopened following
our Net::Netmask report

889
00:36:55,800 --> 00:36:57,010
here again in a second.

890
00:36:57,010 --> 00:36:58,900
And so they're actually referencing an RFC

891
00:36:58,900 --> 00:37:01,080
which rightly says octal is a rare format.

892
00:37:01,080 --> 00:37:02,300
You shouldn't handle it.

893
00:37:02,300 --> 00:37:05,170
Unfortunately, that
leads to inconsistencies

894
00:37:05,170 --> 00:37:07,440
with other programming languages,

895
00:37:07,440 --> 00:37:09,550
utilities written in other
programming languages,

896
00:37:09,550 --> 00:37:11,220
the underlying operating system.

897
00:37:11,220 --> 00:37:14,090
So you can't really ignore it,

898
00:37:14,090 --> 00:37:16,010
even though you'd rather once,

899
00:37:16,010 --> 00:37:18,343
now that we've got octal,
we've sort of all got octal.

900
00:37:18,343 --> 00:37:21,350
So in this case,

901
00:37:21,350 --> 00:37:26,350
having octal off by default
would be a better outcome,

902
00:37:26,630 --> 00:37:28,530
but that wasn't what they did.

903
00:37:28,530 --> 00:37:30,950
So we're gonna look at Python 3.8.0,

904
00:37:30,950 --> 00:37:32,450
which is a vulnerable version,

905
00:37:33,290 --> 00:37:35,800
and we're gonna run this
little proof of concept

906
00:37:35,800 --> 00:37:37,660
which Victor and Sick wrote here.

907
00:37:37,660 --> 00:37:38,620
We're gonna run it with sudo

908
00:37:38,620 --> 00:37:42,860
so that the network calls ping work.

909
00:37:42,860 --> 00:37:46,690
So you'll notice that Linux
is handling 010 correctly,

910
00:37:46,690 --> 00:37:47,870
but Python is not,

911
00:37:47,870 --> 00:37:49,720
just like we saw in the pull request.

912
00:37:50,960 --> 00:37:52,193
Yeah.

913
00:37:54,900 --> 00:37:56,470
We've got our suspect IP, right?

914
00:37:56,470 --> 00:37:59,170
And we've translated it
using the IP address call

915
00:37:59,170 --> 00:38:02,750
and then we've fed it into ping twice,

916
00:38:02,750 --> 00:38:04,300
once as itself

917
00:38:04,300 --> 00:38:08,027
and once as translated into the bad IP.

918
00:38:08,027 --> 00:38:10,000
Bad IP stays bad.

919
00:38:10,000 --> 00:38:13,070
Suspect gets translated correctly.

920
00:38:13,070 --> 00:38:15,250
We got this far because
we worked as a team

921
00:38:15,250 --> 00:38:18,420
and we were able to pick
up across time zones.

922
00:38:18,420 --> 00:38:19,950
None of us got paid to do this.

923
00:38:19,950 --> 00:38:22,010
We've all been collaborating
in our off hours,

924
00:38:22,010 --> 00:38:23,830
whenever those happened to be.

925
00:38:23,830 --> 00:38:25,830
We'd love it if people
were a bit more skeptical

926
00:38:25,830 --> 00:38:27,990
of the battle hardiness
of their dependencies

927
00:38:27,990 --> 00:38:29,210
in the future.

928
00:38:29,210 --> 00:38:31,120
We'd love it if there
were a formal definition

929
00:38:31,120 --> 00:38:33,120
for the IPv4 address format,

930
00:38:33,120 --> 00:38:34,940
or at the very least for how to handle

931
00:38:34,940 --> 00:38:37,610
IP address octets in base eight.

932
00:38:37,610 --> 00:38:40,260
We'd love it if ECMA
rejected zero prefix literals

933
00:38:40,260 --> 00:38:42,120
containing decimal digits.

934
00:38:42,120 --> 00:38:44,440
But even if those spec changes happened,

935
00:38:44,440 --> 00:38:45,640
there would still be code out there

936
00:38:45,640 --> 00:38:47,850
where something's just slightly wrong.

937
00:38:47,850 --> 00:38:50,640
Spec can guide future
researchers or programmers

938
00:38:50,640 --> 00:38:53,370
in understanding the differences
between the ideal world

939
00:38:53,370 --> 00:38:55,050
and whatever issues have become features,

940
00:38:55,050 --> 00:38:58,720
but it's not gonna magically
make things perfect.

941
00:38:58,720 --> 00:39:01,500
If it's critical for code
to behave a certain way,

942
00:39:01,500 --> 00:39:03,740
it may be useful to ensure the behavior

943
00:39:03,740 --> 00:39:06,670
of your underlying dependencies
matches your expectations

944
00:39:06,670 --> 00:39:08,400
before you rely on them.

945
00:39:08,400 --> 00:39:10,720
One thing we did find really
useful was the ability

946
00:39:10,720 --> 00:39:12,790
to report these issues
to the security teams

947
00:39:12,790 --> 00:39:14,693
at all the various organizations

948
00:39:14,693 --> 00:39:16,210
and at least discuss

949
00:39:16,210 --> 00:39:18,920
and get pointed in a different
direction if necessary.

950
00:39:18,920 --> 00:39:21,260
If we hadn't been able to
get in contact with the folks

951
00:39:21,260 --> 00:39:24,150
at Rust and Golang and Oracle and so on,

952
00:39:24,150 --> 00:39:26,920
these vulnerabilities
would continue to be live

953
00:39:26,920 --> 00:39:28,190
in the most current versions

954
00:39:28,190 --> 00:39:29,920
of these languages and libraries.

955
00:39:29,920 --> 00:39:31,510
So thank you so much to everyone

956
00:39:31,510 --> 00:39:34,570
who is receptive to working
with us to fix these issues,

957
00:39:34,570 --> 00:39:36,573
and thank you for watching our talk.

