1
00:00:00,190 --> 00:00:02,070
- [Mickey] Hello, friends
and welcome to our talk

2
00:00:02,070 --> 00:00:03,461
High-Stakes Updates,

3
00:00:03,461 --> 00:00:08,113
or as we like to call it
BIOS, RCE OMG WTF BBQ.

4
00:00:09,540 --> 00:00:11,120
We are Jesse and Mickey.

5
00:00:11,120 --> 00:00:13,470
I am Mickey.
- [Jesse] I'm Jessie.

6
00:00:13,470 --> 00:00:14,960
- [Mickey] Here are our pictures.

7
00:00:14,960 --> 00:00:18,320
So you can someday find us
and harass us face to face.

8
00:00:18,320 --> 00:00:20,590
We both work at a startup named Eclypsium,

9
00:00:20,590 --> 00:00:23,360
who has generously funded this research.

10
00:00:23,360 --> 00:00:26,490
And down below are our Twitter handles

11
00:00:26,490 --> 00:00:29,833
where you can heckle us and
ask us questions at any time.

12
00:00:31,390 --> 00:00:33,330
And this talk will give
you some background

13
00:00:33,330 --> 00:00:35,210
as to how it all started.

14
00:00:35,210 --> 00:00:37,000
What we call the background story.

15
00:00:37,000 --> 00:00:39,843
Before we talk about what we
found and how we found it.

16
00:00:41,060 --> 00:00:42,760
Once we are all on the same page,

17
00:00:42,760 --> 00:00:44,100
we'll dig in a little deeper

18
00:00:44,100 --> 00:00:46,050
into the exploitation of these issues

19
00:00:46,050 --> 00:00:47,910
and finish up with discussing

20
00:00:47,910 --> 00:00:50,720
the practicality of
large scale exploitation

21
00:00:50,720 --> 00:00:51,583
of these issues.

22
00:00:56,790 --> 00:00:57,920
In the last five years,

23
00:00:57,920 --> 00:00:59,640
we've seen almost an explosion

24
00:00:59,640 --> 00:01:02,500
in the amount of firmware
related vulnerabilities.

25
00:01:02,500 --> 00:01:04,370
We've seen more and more publications

26
00:01:04,370 --> 00:01:06,855
about silicon side channel attacks

27
00:01:06,855 --> 00:01:10,340
and more attention is put
on lower level components

28
00:01:10,340 --> 00:01:15,340
from the Intel IME to
AMD PSP, to PCI bridges,

29
00:01:15,383 --> 00:01:16,216
(indistinct) controllers,

30
00:01:16,216 --> 00:01:18,433
and even more components
in the server world.

31
00:01:19,920 --> 00:01:23,040
Since the term firmware
is very broad these days,

32
00:01:23,040 --> 00:01:25,070
in this context, we'll use it to describe

33
00:01:25,070 --> 00:01:27,730
BIOS or UEFI firmware.

34
00:01:27,730 --> 00:01:29,220
Now in my eyes,

35
00:01:29,220 --> 00:01:32,130
threats and vulnerabilities
are not the same.

36
00:01:32,130 --> 00:01:35,100
Threats are manifested
using vulnerabilities.

37
00:01:35,100 --> 00:01:36,880
For example, there is no threat

38
00:01:36,880 --> 00:01:38,540
without a vulnerability of some kind.

39
00:01:38,540 --> 00:01:43,420
So in response to this growing
problem of increased threats,

40
00:01:43,420 --> 00:01:45,520
more and more solutions are popping up.

41
00:01:45,520 --> 00:01:48,320
The easiest and most known
solution to talk about

42
00:01:48,320 --> 00:01:51,080
is Microsoft Secured Core PC.

43
00:01:51,080 --> 00:01:52,790
The marketing material for this solution

44
00:01:52,790 --> 00:01:54,160
has been putting emphasis

45
00:01:54,160 --> 00:01:56,900
on how large scale the firmware problem is

46
00:01:56,900 --> 00:01:59,560
and how we're all oblivious to it.

47
00:01:59,560 --> 00:02:01,360
The way this is done is by utilizing

48
00:02:01,360 --> 00:02:04,010
a range of hardware and
firmware security features

49
00:02:04,010 --> 00:02:06,380
to work in unison and provide

50
00:02:06,380 --> 00:02:09,153
a sort of umbrella
coverage to protect us all.

51
00:02:10,021 --> 00:02:12,410
But not everyone can get a new computer

52
00:02:12,410 --> 00:02:14,810
with all the top security
bells and whistles

53
00:02:14,810 --> 00:02:17,840
and not all computers are
going to have them either.

54
00:02:17,840 --> 00:02:20,900
So for normal users, the problem remains,

55
00:02:20,900 --> 00:02:22,500
and it's simple to explain.

56
00:02:22,500 --> 00:02:25,000
There are more issues to patch in firmware

57
00:02:25,000 --> 00:02:26,620
and patching or updating firmware

58
00:02:26,620 --> 00:02:29,660
has never been a very
user friendly process.

59
00:02:29,660 --> 00:02:32,310
In fact, many knowledgeable
users still fear it

60
00:02:32,310 --> 00:02:34,140
because of a mishap

61
00:02:34,140 --> 00:02:36,340
they might've had in the past themselves,

62
00:02:36,340 --> 00:02:38,883
or have heard of a friend
breaking their computer

63
00:02:38,883 --> 00:02:40,363
during a firmware update.

64
00:02:41,370 --> 00:02:44,640
There are some ways the user
experience, or UX, problem

65
00:02:44,640 --> 00:02:45,990
is being attempted to be solved

66
00:02:45,990 --> 00:02:47,540
with minimal user interaction

67
00:02:47,540 --> 00:02:51,670
or by using classic OEM
tools or update packages,

68
00:02:51,670 --> 00:02:54,350
or by manually going into the BIOS menu

69
00:02:54,350 --> 00:02:56,150
and flashing through their.

70
00:02:56,150 --> 00:02:57,600
LVFS for example,

71
00:02:57,600 --> 00:02:59,630
is the RedHat open source way

72
00:03:00,624 --> 00:03:01,457
of providing firmware updates

73
00:03:01,457 --> 00:03:04,080
in an automated way for Linux users.

74
00:03:04,080 --> 00:03:07,210
Windows update is another
process of doing this

75
00:03:07,210 --> 00:03:08,910
on supportive machines.

76
00:03:08,910 --> 00:03:12,440
The easiest example is
Microsoft's Surface lineup.

77
00:03:12,440 --> 00:03:14,160
Since they control the whole vertical

78
00:03:14,160 --> 00:03:17,720
from firmware to software and
manufacturing of the computer,

79
00:03:17,720 --> 00:03:20,660
they can have the OS do
the update process for them

80
00:03:20,660 --> 00:03:23,150
without worrying about any third party

81
00:03:23,150 --> 00:03:26,453
not doing proper validation
and breaking their system.

82
00:03:27,290 --> 00:03:29,010
By the way, this does
not mean that bricking

83
00:03:29,010 --> 00:03:30,350
is not a real possibility.

84
00:03:30,350 --> 00:03:34,120
For example, there are always
these unfortunate souls

85
00:03:34,120 --> 00:03:37,360
who's experienced that
one bizarre power outage,

86
00:03:37,360 --> 00:03:40,290
right smack in the
middle of a BIOS update.

87
00:03:40,290 --> 00:03:45,040
HTTPS Boot, which is also
used to recover an OS

88
00:03:45,040 --> 00:03:47,090
But we listed here because it's a part

89
00:03:47,090 --> 00:03:49,880
of the recovery "umbrella",

90
00:03:49,880 --> 00:03:51,060
which can also apply updates

91
00:03:51,060 --> 00:03:53,980
as a new version of OS
installed over an older one

92
00:03:53,980 --> 00:03:55,550
that's not working anymore.

93
00:03:55,550 --> 00:03:58,880
All these methods of updates and recovery

94
00:03:58,880 --> 00:04:01,243
need to be done in a secure and safe way.

95
00:04:01,243 --> 00:04:03,810
Especially if they involve

96
00:04:03,810 --> 00:04:06,860
using a network connection at any point.

97
00:04:06,860 --> 00:04:08,100
We've had some experience

98
00:04:08,100 --> 00:04:10,370
dealing with remote code
execution in the past.

99
00:04:10,370 --> 00:04:15,285
Back in 2018, we've
discovered vulnerabilities

100
00:04:15,285 --> 00:04:19,980
in Asrock and ASUS update
process through BIOS.

101
00:04:19,980 --> 00:04:22,460
You can watch our Black
Hat and DefCon talks

102
00:04:22,460 --> 00:04:25,300
from that year if you want to learn more.

103
00:04:25,300 --> 00:04:26,630
Looking at some of the big names

104
00:04:26,630 --> 00:04:28,460
in the enterprise computer hardware world,

105
00:04:28,460 --> 00:04:31,040
we did some attack surface scoping.

106
00:04:31,040 --> 00:04:32,310
We started with HP and looked

107
00:04:32,310 --> 00:04:35,570
at their PXE Boot and HTTPS Boot features

108
00:04:35,570 --> 00:04:38,280
and we couldn't find anything
that stuck out there.

109
00:04:38,280 --> 00:04:41,000
We also took a look at
Lenovo's capabilities.

110
00:04:41,000 --> 00:04:42,960
They're very similar to HPs,

111
00:04:42,960 --> 00:04:46,750
but with less fancy user interface.

112
00:04:46,750 --> 00:04:48,423
Nothing stuck up there either.

113
00:04:49,430 --> 00:04:52,240
We then moved to Dell and then we noticed

114
00:04:52,240 --> 00:04:55,123
that they had more
options and more fancy UI.

115
00:04:57,330 --> 00:05:00,100
We noticed two new options
coming in from Dell.

116
00:05:00,100 --> 00:05:03,963
One is to make it easier to
update the BIOS without an OS.

117
00:05:04,981 --> 00:05:06,965
And the other is to recover the OS

118
00:05:06,965 --> 00:05:09,500
from an unrecoverable state.

119
00:05:09,500 --> 00:05:10,740
Now don't get me wrong.

120
00:05:10,740 --> 00:05:12,270
Both are very useful features

121
00:05:12,270 --> 00:05:14,464
that I wish I had these many times

122
00:05:14,464 --> 00:05:16,680
during my career using computers.

123
00:05:16,680 --> 00:05:19,220
So please don't take this
talk as a discouragement

124
00:05:19,220 --> 00:05:21,283
against using these in general.

125
00:05:22,670 --> 00:05:24,710
Both of these new features
appear to be a part

126
00:05:24,710 --> 00:05:27,480
of what's called Dell Support Assist.

127
00:05:27,480 --> 00:05:29,340
Which is an umbrella definition.

128
00:05:29,340 --> 00:05:32,040
I'd say umbrella because the same term

129
00:05:32,040 --> 00:05:34,688
covers software utilities in the OS level,

130
00:05:34,688 --> 00:05:38,170
as well as the firmware features.

131
00:05:38,170 --> 00:05:40,190
Some of you might call it bloatware.

132
00:05:40,190 --> 00:05:42,760
That's the stuff where it
comes installed by default

133
00:05:42,760 --> 00:05:44,540
on most Dell systems.

134
00:05:44,540 --> 00:05:48,760
There's some ways that the
Windows side of Support Assist

135
00:05:48,760 --> 00:05:50,720
can interact with the firmware side.

136
00:05:50,720 --> 00:05:51,900
Those are well documented.

137
00:05:51,900 --> 00:05:53,920
We're not going to go into them right now.

138
00:05:53,920 --> 00:05:56,970
If you want to go explore these,

139
00:05:56,970 --> 00:05:59,420
you can Google them and you will find

140
00:05:59,420 --> 00:06:01,830
plenty of documentation covering this.

141
00:06:01,830 --> 00:06:03,550
But for the contents of this talk,

142
00:06:03,550 --> 00:06:05,180
anything referring to Support Assistant

143
00:06:05,180 --> 00:06:07,253
will be in the context of firmware.

144
00:06:08,370 --> 00:06:10,928
Let's say a regular user gets
into the boot options menu.

145
00:06:10,928 --> 00:06:14,550
After either something bad
happened to their system,

146
00:06:14,550 --> 00:06:16,440
or they need to do a BIOS update.

147
00:06:16,440 --> 00:06:18,610
This is the screen that they would see.

148
00:06:18,610 --> 00:06:20,546
This is the boot option menu

149
00:06:20,546 --> 00:06:23,547
or something similar
in any other platform.

150
00:06:23,547 --> 00:06:26,560
This is the example of what we're seeing

151
00:06:26,560 --> 00:06:29,023
on our Dell Latitude 5320.

152
00:06:30,270 --> 00:06:32,240
If their system will not boot to an OS

153
00:06:33,685 --> 00:06:34,910
and it needs to go through recovery,

154
00:06:34,910 --> 00:06:37,263
then they will have the recovery option.

155
00:06:39,630 --> 00:06:44,139
If they need to do a BIOS
update, but not use Windows,

156
00:06:44,139 --> 00:06:47,653
they can use the BIOS
firmware update remote option.

157
00:06:49,180 --> 00:06:54,070
The BIOS setup, the
diagnostics, the BIOS update,

158
00:06:54,070 --> 00:06:58,080
and the device configuration
are usually out of reach

159
00:06:58,080 --> 00:07:02,590
for normal usage scenarios
for common users.

160
00:07:02,590 --> 00:07:04,150
For more technical users

161
00:07:04,150 --> 00:07:07,883
it is something that most of
us are probably familiar with.

162
00:07:10,260 --> 00:07:12,620
In case some of you missed that.

163
00:07:12,620 --> 00:07:16,827
That was a BIOS flash update over the air.

164
00:07:16,827 --> 00:07:19,184
Not just the BIOS update,

165
00:07:19,184 --> 00:07:22,130
the OS recovery is done over the internet.

166
00:07:22,130 --> 00:07:24,223
What could possibly go wrong?

167
00:07:25,290 --> 00:07:29,120
So let's take a look at
how these features work.

168
00:07:29,120 --> 00:07:33,170
We need to set up a machine
in the middle environment.

169
00:07:33,170 --> 00:07:36,700
We start with using the
community edition of pfsense

170
00:07:36,700 --> 00:07:39,220
running on an old desktop
we had lying around.

171
00:07:39,220 --> 00:07:41,160
And once we had all of that working,

172
00:07:41,160 --> 00:07:44,113
we set up a sniffer and
sniffed the traffic.

173
00:07:47,590 --> 00:07:49,760
Looking at the initial packet capture,

174
00:07:49,760 --> 00:07:53,930
we can immediately see a
ping going out to 8.8.8.8,

175
00:07:53,930 --> 00:07:57,120
which is Google's DNS server IP address,

176
00:07:57,120 --> 00:08:01,510
and a DNS query asking for
the IP of downloads.dell.com.

177
00:08:01,510 --> 00:08:03,870
After that we see the handshake process

178
00:08:03,870 --> 00:08:05,683
starting and then failing.

179
00:08:06,520 --> 00:08:08,040
Looks like we need a cert.

180
00:08:08,040 --> 00:08:09,700
Well, what kind of cert do we need?

181
00:08:09,700 --> 00:08:11,370
We need a valid SSL cert.

182
00:08:11,370 --> 00:08:13,050
So we can use with our malicious server

183
00:08:13,050 --> 00:08:15,740
to do a proper handshake
and sniff the traffic.

184
00:08:15,740 --> 00:08:18,263
So let's look at the firmware image.

185
00:08:20,384 --> 00:08:21,930
We pop it open and we get this string.

186
00:08:21,930 --> 00:08:24,640
Now, if you look at it closely,
you might recognize it.

187
00:08:24,640 --> 00:08:27,330
This is the text header

188
00:08:27,330 --> 00:08:29,960
of the Mozilla CA root certificate bundle.

189
00:08:29,960 --> 00:08:32,430
Now, this is just the first few lines.

190
00:08:32,430 --> 00:08:33,840
This file is very, very long.

191
00:08:33,840 --> 00:08:38,840
It contains the common
CAs used by Mozilla.

192
00:08:39,150 --> 00:08:40,930
So let's get a cert.

193
00:08:40,930 --> 00:08:45,380
First, we tried to get one from ZeroSSL.

194
00:08:45,380 --> 00:08:47,510
That's a free service that gives you

195
00:08:47,510 --> 00:08:51,330
three months free cert
for a domain that you own.

196
00:08:51,330 --> 00:08:54,830
You can play with it and
try whatever you want.

197
00:08:54,830 --> 00:08:58,950
We got the SSL cert, we
loaded it up in the server.

198
00:08:58,950 --> 00:09:02,250
Everything looked fine when
we tested it independently.

199
00:09:02,250 --> 00:09:03,380
But when we went ahead

200
00:09:03,380 --> 00:09:05,470
and did the machine in the middle attack,

201
00:09:05,470 --> 00:09:06,570
it didn't work.

202
00:09:06,570 --> 00:09:09,813
Turns out the CA that ZeroSSL is using.

203
00:09:09,813 --> 00:09:11,340
It's not one of the ones

204
00:09:11,340 --> 00:09:14,220
that is listed in the Mozilla list.

205
00:09:14,220 --> 00:09:15,950
So we moved on.

206
00:09:15,950 --> 00:09:17,210
We tried, Let's Encrypt.

207
00:09:17,210 --> 00:09:19,490
Took about three minutes
before we realized

208
00:09:19,490 --> 00:09:21,150
that that's going to be a hassle.

209
00:09:21,150 --> 00:09:22,700
It's not going to be a point and click way

210
00:09:22,700 --> 00:09:24,645
to go to their website, like ZeroSSL,

211
00:09:24,645 --> 00:09:27,140
click a few buttons and get a certificate.

212
00:09:27,140 --> 00:09:28,640
So moving on.

213
00:09:28,640 --> 00:09:30,520
It turns out that you can buy

214
00:09:30,520 --> 00:09:33,760
a wildcard SSL certificate for about €70.

215
00:09:33,760 --> 00:09:35,960
Which is about $95 to $100.

216
00:09:35,960 --> 00:09:39,880
So after a few minutes
Googling on the internet,

217
00:09:39,880 --> 00:09:41,780
finding the cheapest solution,

218
00:09:41,780 --> 00:09:45,010
we ended up buying a
certificate from Certum,

219
00:09:45,010 --> 00:09:46,460
I hope that's pronounced like that,

220
00:09:46,460 --> 00:09:47,993
and we're set.

221
00:09:49,045 --> 00:09:50,295
And holy crap, it worked.

222
00:09:52,840 --> 00:09:57,820
We got a full capture of all the traffic

223
00:09:57,820 --> 00:10:02,820
decrypted between our laptop
and our malicious server.

224
00:10:02,880 --> 00:10:04,380
Let's take a closer look

225
00:10:04,380 --> 00:10:06,760
at those green lines in the capture.

226
00:10:06,760 --> 00:10:11,757
We see that the laptop is
reaching out to downloads.dell.com

227
00:10:11,757 --> 00:10:15,960
and is trying to, first make
sure that there's a connection,

228
00:10:15,960 --> 00:10:20,070
and then retrieves a CatalogBc.XML file.

229
00:10:20,070 --> 00:10:21,140
Let's take a step back

230
00:10:21,140 --> 00:10:23,630
and look at how this works in high level.

231
00:10:23,630 --> 00:10:27,120
We have our laptop reaching
out to Dell servers over SSL

232
00:10:27,120 --> 00:10:29,930
and getting a catalog
file with an XML format.

233
00:10:29,930 --> 00:10:33,520
In this catalog, according to
what we chose in the laptop,

234
00:10:33,520 --> 00:10:36,870
with what option we selected,
either firmware update,

235
00:10:36,870 --> 00:10:40,270
which we will reference
as F-O-T-A or FOTA,

236
00:10:40,270 --> 00:10:43,603
or OS recovery that we will
mention as C-S-O-S or CSOS.

237
00:10:44,500 --> 00:10:45,500
According to that selection,

238
00:10:45,500 --> 00:10:48,480
these will point the communications

239
00:10:48,480 --> 00:10:50,780
to the corresponding EFI file

240
00:10:50,780 --> 00:10:52,920
that will be downloaded from the server.

241
00:10:52,920 --> 00:10:55,510
Normally, modifying these
would be out of reach

242
00:10:55,510 --> 00:10:59,460
because the traffic would
be covered over the SSL.

243
00:10:59,460 --> 00:11:02,280
But since we bypass that barrier,

244
00:11:02,280 --> 00:11:03,610
we are able to play around

245
00:11:03,610 --> 00:11:05,590
and mess with the files and the process

246
00:11:05,590 --> 00:11:08,630
and see what we can mess with and fuzz.

247
00:11:08,630 --> 00:11:12,330
As a result of all this,
we have found four CVEs.

248
00:11:12,330 --> 00:11:14,790
The first one was the TLS issue.

249
00:11:14,790 --> 00:11:17,940
Where the verification of the certificate

250
00:11:17,940 --> 00:11:19,590
was not done properly.

251
00:11:19,590 --> 00:11:23,440
In which the URL was not
compared to the certificate.

252
00:11:23,440 --> 00:11:25,320
So as long as you would provide

253
00:11:25,320 --> 00:11:28,298
a valid certificate from a trusted CA

254
00:11:28,298 --> 00:11:30,603
you could impersonate Dell servers.

255
00:11:32,240 --> 00:11:34,380
The second, third, and
fourth vulnerabilities

256
00:11:34,380 --> 00:11:37,683
are the ones we're going to
discuss deeper in this talk.

257
00:11:39,880 --> 00:11:41,370
- [Jesse] Okay. So now
let's take a closer look

258
00:11:41,370 --> 00:11:44,120
at some of the vulnerabilities themselves,

259
00:11:44,120 --> 00:11:47,440
and what's actually happening here.

260
00:11:47,440 --> 00:11:52,440
This is some of the contents
of that CatalogBc.xml file.

261
00:11:52,810 --> 00:11:55,410
It includes things like
the baseLocation tag

262
00:11:55,410 --> 00:11:58,210
with downloads.dell.com.

263
00:11:58,210 --> 00:12:02,116
There's a lot of model specific
information in this file.

264
00:12:02,116 --> 00:12:06,450
But there's also some of
these software component tags

265
00:12:06,450 --> 00:12:11,243
that include things like the
path to DellFOTALauncher.efi.

266
00:12:12,370 --> 00:12:17,370
There's another one for
DellCSOSLauncher.efi

267
00:12:18,110 --> 00:12:22,610
and both the firmware over the air update

268
00:12:22,610 --> 00:12:25,460
and the support assist OS recovery,

269
00:12:25,460 --> 00:12:27,690
depending on which path you choose,

270
00:12:27,690 --> 00:12:29,640
will pick a different software component

271
00:12:29,640 --> 00:12:34,640
to download and run
from downloads.dell.com.

272
00:12:35,120 --> 00:12:36,670
If security is turned off,

273
00:12:36,670 --> 00:12:39,930
that's an easy way to get
arbitrary code execution

274
00:12:39,930 --> 00:12:42,210
during the pre-boot process.

275
00:12:42,210 --> 00:12:43,900
If secure boot is turned on,

276
00:12:43,900 --> 00:12:47,330
you do need to have a executable
that's signed by a key

277
00:12:47,330 --> 00:12:50,680
that's allowed by EUFI Secure Boot,

278
00:12:50,680 --> 00:12:54,543
which would mean that
it's in the BBD database.

279
00:12:55,790 --> 00:12:58,160
In our investigation, we discovered that

280
00:12:58,160 --> 00:13:01,990
this base location tag
has a buffer overflow.

281
00:13:01,990 --> 00:13:04,710
And this is a heat based buffer overflow

282
00:13:04,710 --> 00:13:08,010
that is in the UEFI firmware itself.

283
00:13:08,010 --> 00:13:10,840
So just the code that's running

284
00:13:12,340 --> 00:13:15,090
before it even downloads and
runs this DellFOTALauncher

285
00:13:16,121 --> 00:13:18,110
for when it's parsing this XML file

286
00:13:18,110 --> 00:13:22,550
in a component that's in the
SPI, in your UEFI firmware,

287
00:13:22,550 --> 00:13:24,410
that's flashed to the motherboard.

288
00:13:24,410 --> 00:13:27,300
That's where this component,
where this vulnerability lives.

289
00:13:27,300 --> 00:13:29,760
So there is this overflow
in the baseLocation tag,

290
00:13:29,760 --> 00:13:31,370
and that was kind of fun.

291
00:13:31,370 --> 00:13:35,040
But there's some more vulnerabilities
we'll look at as well.

292
00:13:35,040 --> 00:13:39,860
Starting the support assist
OS recovery path or CSOS.

293
00:13:39,860 --> 00:13:41,480
One of the things that this does

294
00:13:41,480 --> 00:13:46,480
is it downloads a JSON file
from from Dell as well.

295
00:13:47,240 --> 00:13:50,200
This is part of that JSON file.

296
00:13:50,200 --> 00:13:55,170
There are multiple sections
that have a URL, size,

297
00:13:55,170 --> 00:13:56,930
and then a sha256.

298
00:13:56,930 --> 00:14:00,090
It turns out that this URL field

299
00:14:00,090 --> 00:14:02,270
has a stack buffer overflow.

300
00:14:02,270 --> 00:14:07,270
And also the sha256 field also
has a stack buffer overflow.

301
00:14:07,770 --> 00:14:12,770
Let's take a closer look
at the sha256 overflow.

302
00:14:13,000 --> 00:14:16,560
The verification function to check and see

303
00:14:16,560 --> 00:14:20,378
if the file that was
downloaded from the server

304
00:14:20,378 --> 00:14:23,900
actually matches that
sha256 that was provided,

305
00:14:23,900 --> 00:14:25,600
has some bugs in it.

306
00:14:25,600 --> 00:14:30,600
So this is a simplified
decompilation of that function,

307
00:14:30,800 --> 00:14:35,350
where it is taking the ASCII hex string,

308
00:14:35,350 --> 00:14:37,650
converting that to binary,

309
00:14:37,650 --> 00:14:41,500
and then comparing that against the hash

310
00:14:41,500 --> 00:14:45,920
that was calculated from the
file that was downloaded.

311
00:14:45,920 --> 00:14:49,320
But this hex conversion that it's doing,

312
00:14:49,320 --> 00:14:53,170
they are writing the converted values

313
00:14:53,170 --> 00:14:54,870
into a buffer on the stack

314
00:14:54,870 --> 00:14:58,800
without properly verifying
that it's only the length

315
00:14:58,800 --> 00:15:01,310
of a sha256 hash that they're converting.

316
00:15:01,310 --> 00:15:02,860
If you take a look here,

317
00:15:02,860 --> 00:15:07,860
they will read up to 20,000
bytes from the hex string,

318
00:15:08,630 --> 00:15:12,060
but they can only write 344 bytes

319
00:15:12,060 --> 00:15:15,200
before they run into the same
return address on the stack.

320
00:15:15,200 --> 00:15:18,510
This is a great thing for attackers

321
00:15:18,510 --> 00:15:23,090
because it's a stack buffer
overflow at a fixed address,

322
00:15:23,090 --> 00:15:25,070
and you don't have to
worry about embedded nulls,

323
00:15:25,070 --> 00:15:26,610
other bad characters,

324
00:15:26,610 --> 00:15:28,710
because you can just give it a hex string

325
00:15:28,710 --> 00:15:30,347
with whatever you want in it

326
00:15:30,347 --> 00:15:32,297
and that will get written to the stack.

327
00:15:33,400 --> 00:15:34,233
- [Mickey] So in the past,

328
00:15:34,233 --> 00:15:36,390
when we had to work on
explaining bugs like this,

329
00:15:36,390 --> 00:15:39,070
it was basically set the easy mode

330
00:15:39,070 --> 00:15:41,530
because we could set the
hardware to be in debug

331
00:15:41,530 --> 00:15:42,990
and using Intel tools

332
00:15:42,990 --> 00:15:45,960
we could just single step
through instructions in real time

333
00:15:45,960 --> 00:15:48,890
and see how the bug is being triggered

334
00:15:48,890 --> 00:15:50,130
and how to exploit it.

335
00:15:50,130 --> 00:15:52,870
But that's not common anymore.

336
00:15:52,870 --> 00:15:54,760
Modern computers and modern platforms

337
00:15:54,760 --> 00:15:57,490
no longer have that
option easily available.

338
00:15:57,490 --> 00:15:59,590
So you have to be creative.

339
00:15:59,590 --> 00:16:02,950
Now it is however possible to do this.

340
00:16:02,950 --> 00:16:04,250
It's just harder,

341
00:16:04,250 --> 00:16:07,290
but that will be in a different talk.

342
00:16:07,290 --> 00:16:10,210
Instead of using that debug mechanism,

343
00:16:10,210 --> 00:16:13,240
we are using the PCI Leech.

344
00:16:13,240 --> 00:16:16,323
We love PCI Leech (indistinct) is great.

345
00:16:17,599 --> 00:16:19,680
- [Jesse] The PCI Leech was a great way

346
00:16:19,680 --> 00:16:22,900
to dump all the memory in the system.

347
00:16:22,900 --> 00:16:26,920
So we didn't have direct debug access.

348
00:16:26,920 --> 00:16:27,870
We couldn't single step.

349
00:16:27,870 --> 00:16:30,460
We couldn't do live debugging,

350
00:16:30,460 --> 00:16:34,190
but we had the ability to
dump the entire address space,

351
00:16:34,190 --> 00:16:36,220
or most of the address space.

352
00:16:36,220 --> 00:16:39,140
So we ended up with a three gigabyte dumps

353
00:16:39,140 --> 00:16:41,510
and a lot of those.

354
00:16:41,510 --> 00:16:44,060
Since we had kind of an interesting year,

355
00:16:44,060 --> 00:16:46,790
we've been doing socially
distant debugging.

356
00:16:46,790 --> 00:16:50,720
And Mickey initially found this bug

357
00:16:50,720 --> 00:16:54,800
and was able to dump the
system using PCI Leech.

358
00:16:54,800 --> 00:16:58,110
And then he would upload
this three gig memory dump.

359
00:16:58,110 --> 00:17:00,880
I would download it loaded into IDA,

360
00:17:00,880 --> 00:17:03,030
which has some issues of its own,

361
00:17:03,030 --> 00:17:07,780
and do some analysis and send
a payload back, try something.

362
00:17:07,780 --> 00:17:09,540
And we had kind of this workflow,

363
00:17:09,540 --> 00:17:12,370
which was not ideal

364
00:17:12,370 --> 00:17:15,500
because Mickey has much faster
internet access than I do.

365
00:17:15,500 --> 00:17:17,530
And at one point we discovered

366
00:17:17,530 --> 00:17:20,420
that because the system is booting up

367
00:17:20,420 --> 00:17:21,759
there isn't really a lot,

368
00:17:21,759 --> 00:17:24,480
there isn't a lot of live memory yet.

369
00:17:24,480 --> 00:17:26,630
So it's mostly just a little bit larger

370
00:17:26,630 --> 00:17:28,060
than the BIOS region.

371
00:17:28,060 --> 00:17:31,178
So it turns out that these
three gig memory dumps

372
00:17:31,178 --> 00:17:33,760
compressed down to around 17 megs

373
00:17:33,760 --> 00:17:35,680
if you throw it in a 7ZIP.

374
00:17:35,680 --> 00:17:37,830
So that sped things up a lot

375
00:17:39,314 --> 00:17:41,100
and helped quite a bit.

376
00:17:41,100 --> 00:17:45,470
For actually debugging
these vulnerabilities

377
00:17:45,470 --> 00:17:49,460
one thing that's really
nice about exploiting UEFI

378
00:17:49,460 --> 00:17:53,720
is that there's a one-to-one
virtual to physical mapping.

379
00:17:53,720 --> 00:17:55,670
So all of the physical map,

380
00:17:55,670 --> 00:17:58,610
all of the pointers that you
would see in the memory space

381
00:17:58,610 --> 00:18:01,550
are actually at those physical
offsets into the file.

382
00:18:01,550 --> 00:18:05,530
So it was pretty easy to do that mapping

383
00:18:05,530 --> 00:18:08,060
and figure out what was going on.

384
00:18:08,060 --> 00:18:09,580
Where to find where things were,

385
00:18:09,580 --> 00:18:12,295
because I didn't need to
do any kind of translation

386
00:18:12,295 --> 00:18:13,520
or mapping between those.

387
00:18:13,520 --> 00:18:15,450
So it ended up where we were able

388
00:18:15,450 --> 00:18:18,600
to basically pass these dumps

389
00:18:18,600 --> 00:18:20,890
and payload attempts back and forth.

390
00:18:20,890 --> 00:18:24,040
Where we were able to
test the payload remotely

391
00:18:24,040 --> 00:18:26,720
and confirm arbitrary code execution

392
00:18:26,720 --> 00:18:29,490
when I never even saw what the
physical device looked like.

393
00:18:29,490 --> 00:18:31,740
So there are some things to be aware of

394
00:18:31,740 --> 00:18:34,070
when you're doing this type of analysis.

395
00:18:34,070 --> 00:18:36,455
Especially with really large images,

396
00:18:36,455 --> 00:18:38,070
loading those into IDA.

397
00:18:38,070 --> 00:18:40,360
Make sure you turn off analysis

398
00:18:40,360 --> 00:18:42,190
before you load the image into IDA.

399
00:18:42,190 --> 00:18:44,800
These were three gig memory images.

400
00:18:44,800 --> 00:18:48,790
Even just loading that into
IDA with 64 gigs of RAM

401
00:18:48,790 --> 00:18:51,080
it would go down unresponsive for awhile.

402
00:18:51,080 --> 00:18:53,380
I'd sit there for awhile,
wait for it to load.

403
00:18:53,380 --> 00:18:57,600
And if you forget and
leave analysis turned on,

404
00:18:57,600 --> 00:18:59,670
it's really easy to run out of memory.

405
00:18:59,670 --> 00:19:01,400
And there are some cases

406
00:19:01,400 --> 00:19:05,700
where you might need to turn
on analysis momentarily.

407
00:19:05,700 --> 00:19:06,990
Like if you're using Hex Rays

408
00:19:06,990 --> 00:19:09,350
and something isn't decompiled properly.

409
00:19:09,350 --> 00:19:10,830
You might want to turn on,

410
00:19:10,830 --> 00:19:12,800
just click to turn on analysis.

411
00:19:12,800 --> 00:19:14,830
Click again, to disable it

412
00:19:14,830 --> 00:19:16,760
and eventually it'll
start responding again

413
00:19:16,760 --> 00:19:19,070
and disable analysis.

414
00:19:19,070 --> 00:19:21,520
But if you forget,
you'll run out of memory.

415
00:19:21,520 --> 00:19:23,620
And even with analysis turned off,

416
00:19:23,620 --> 00:19:25,520
loading these three gig dumps into IDA

417
00:19:25,520 --> 00:19:29,540
was creating about 12 gig IDBs.

418
00:19:29,540 --> 00:19:32,010
I totally ran out of
memory, out of disc space,

419
00:19:32,010 --> 00:19:34,282
multiple times while doing this

420
00:19:34,282 --> 00:19:35,663
and had to shuffle things around.

421
00:19:35,663 --> 00:19:37,485
Doing some preprocessing ahead of time

422
00:19:37,485 --> 00:19:40,230
to strip out the regions
that only want it to do.

423
00:19:40,230 --> 00:19:42,019
That would have been a good idea.

424
00:19:42,019 --> 00:19:44,160
Some other things we ran into

425
00:19:44,160 --> 00:19:46,870
was once we were able to come

426
00:19:46,870 --> 00:19:49,202
and start working in the office again

427
00:19:49,202 --> 00:19:51,780
we put our test equipment in the office.

428
00:19:51,780 --> 00:19:55,340
We were able to do some tests that way,

429
00:19:55,340 --> 00:19:57,570
but then we didn't really have the ability

430
00:19:57,570 --> 00:20:00,680
to test remotely in some scenarios.

431
00:20:00,680 --> 00:20:04,310
So I did some experiments
of loading three gig dumps

432
00:20:04,310 --> 00:20:07,565
into Unicorn Engine and debugging

433
00:20:07,565 --> 00:20:10,620
first stage shell code payloads that way.

434
00:20:10,620 --> 00:20:12,020
And that actually worked really well.

435
00:20:12,020 --> 00:20:16,510
And I have a 128 gig
(indistinct) system at home,

436
00:20:16,510 --> 00:20:21,470
and it would take about five
minutes to test a payload

437
00:20:21,470 --> 00:20:22,303
and it would run through

438
00:20:22,303 --> 00:20:25,800
until it was jumping to the next stage.

439
00:20:25,800 --> 00:20:28,883
So that's another thing
that was really useful.

440
00:20:31,040 --> 00:20:35,460
So there's some interesting complications

441
00:20:35,460 --> 00:20:37,490
to modern exploitation.

442
00:20:37,490 --> 00:20:40,810
There's a lot of exploit
mitigation techniques

443
00:20:40,810 --> 00:20:45,103
like the stack and heap
used to be fully executable.

444
00:20:47,189 --> 00:20:49,290
All these mitigations were put in place.

445
00:20:49,290 --> 00:20:51,063
Address randomization, sandboxes.

446
00:20:52,010 --> 00:20:53,703
But in UEFI environment,

447
00:20:55,007 --> 00:20:56,506
it's kind of like going back to the 90s

448
00:20:56,506 --> 00:20:59,610
because that's still
lagging significantly behind

449
00:20:59,610 --> 00:21:02,340
all these mitigations that were
in the OS application space.

450
00:21:02,340 --> 00:21:06,240
So in most cases you have an
executable stack and heap.

451
00:21:06,240 --> 00:21:07,240
You don't have any canaries,

452
00:21:07,240 --> 00:21:09,560
you don't have address randomization

453
00:21:09,560 --> 00:21:11,310
and you're running and ring zero,

454
00:21:11,310 --> 00:21:13,480
essentially running in kernel mode.

455
00:21:13,480 --> 00:21:17,230
So (indistinct) core has started providing

456
00:21:17,230 --> 00:21:19,310
initial implementations
of some of these things.

457
00:21:19,310 --> 00:21:21,490
Like non executable stack,

458
00:21:21,490 --> 00:21:24,502
but those need to be enabled by the OEMs.

459
00:21:24,502 --> 00:21:26,370
And we haven't seen any real systems

460
00:21:26,370 --> 00:21:28,610
that have these turned on yet.

461
00:21:28,610 --> 00:21:31,830
Essentially anything that
slows down the boot process,

462
00:21:31,830 --> 00:21:34,433
OEMs are hesitant to turn on.

463
00:21:35,930 --> 00:21:38,780
So, one of the things that
we looked at for our payload

464
00:21:38,780 --> 00:21:42,530
is although there is no
address randomization

465
00:21:42,530 --> 00:21:45,180
things can still load
at different addresses

466
00:21:45,180 --> 00:21:48,125
just because of you might have

467
00:21:48,125 --> 00:21:50,160
a different system, different controller.

468
00:21:50,160 --> 00:21:52,525
Things might load at different addresses.

469
00:21:52,525 --> 00:21:55,140
So we took a look at places

470
00:21:55,140 --> 00:21:58,200
where we could find gadgets
at known fixed locations.

471
00:21:58,200 --> 00:22:00,840
So, one thing that's really useful

472
00:22:00,840 --> 00:22:04,440
is that the BIOS region in SPI

473
00:22:04,440 --> 00:22:08,860
is mapped at physically known
locations in physical memory.

474
00:22:08,860 --> 00:22:11,520
starting at FF0 through the reset vector

475
00:22:11,520 --> 00:22:15,650
at 16 bytes below four gig.

476
00:22:15,650 --> 00:22:18,590
So we know where the UEFI firmware

477
00:22:18,590 --> 00:22:21,550
is going to be mapped
at a physical location.

478
00:22:21,550 --> 00:22:26,490
So we can go look for ROP
gadgets in the BIOS region

479
00:22:26,490 --> 00:22:28,620
that's mapped from the SPI chip.

480
00:22:28,620 --> 00:22:31,030
There's a couple of ways that
you can get the contents.

481
00:22:31,030 --> 00:22:33,300
You can either dump the BIOS region

482
00:22:33,300 --> 00:22:35,150
using tools like ChIPSEC.

483
00:22:35,150 --> 00:22:37,730
You can use physical access (indistinct)

484
00:22:37,730 --> 00:22:38,920
SPI reader,

485
00:22:38,920 --> 00:22:41,050
or you can also just download BIOS updates

486
00:22:41,050 --> 00:22:42,870
and you can extract them

487
00:22:42,870 --> 00:22:46,383
using this great Dell PFS BIOS extractor.

488
00:22:47,470 --> 00:22:50,380
And it turns out there's
actually a lot of useful gadgets

489
00:22:50,380 --> 00:22:52,690
at fixed addresses in the BIOS region.

490
00:22:52,690 --> 00:22:54,650
Here's an example of using ROPer

491
00:22:54,650 --> 00:22:59,650
to search for jmp rso
equivalent instructions.

492
00:22:59,720 --> 00:23:04,607
In this particular BIOS image,
we found 441 in this image.

493
00:23:04,607 --> 00:23:09,550
So the firmware across model
families and different models

494
00:23:09,550 --> 00:23:10,980
tends to be different.

495
00:23:10,980 --> 00:23:13,500
But within a specific model,

496
00:23:13,500 --> 00:23:14,970
the different firmware versions

497
00:23:14,970 --> 00:23:16,840
tend to be similar enough

498
00:23:16,840 --> 00:23:19,960
that you could find
common gadget addresses

499
00:23:19,960 --> 00:23:22,330
across all of the
available firmware images.

500
00:23:22,330 --> 00:23:25,640
Here's an example from the Latitude 5320.

501
00:23:25,640 --> 00:23:28,710
All of these versions have this
gadget at the same address.

502
00:23:28,710 --> 00:23:30,113
It's totally useful for us.

503
00:23:31,490 --> 00:23:35,390
So let's take a look at what
our exploit payload contains.

504
00:23:35,390 --> 00:23:39,990
So our first stage includes
a JMP RSP at a known address

505
00:23:39,990 --> 00:23:41,493
that's mapped from SPI.

506
00:23:42,390 --> 00:23:45,000
So we can reliably get remote (indistinct)

507
00:23:45,000 --> 00:23:47,010
without caring where we loaded.

508
00:23:47,010 --> 00:23:48,550
At this point, we can do whatever we want,

509
00:23:48,550 --> 00:23:52,085
but we want to use UEFI
functions to do things for us.

510
00:23:52,085 --> 00:23:54,758
So to do that, we need a pointer

511
00:23:54,758 --> 00:23:55,670
to the boot services table.

512
00:23:55,670 --> 00:23:58,565
We can scan for the boot serve signature,

513
00:23:58,565 --> 00:24:00,820
take a look, find it that way,

514
00:24:00,820 --> 00:24:03,100
but we also need to point or to EFI handle

515
00:24:03,100 --> 00:24:04,930
for the current executable to do things

516
00:24:04,930 --> 00:24:07,600
like load image and start image.

517
00:24:07,600 --> 00:24:10,500
It turns out that that executable

518
00:24:10,500 --> 00:24:12,100
that they just downloaded from us.

519
00:24:12,100 --> 00:24:16,500
Dell SISA SOS launcher contains
pointers to both of these.

520
00:24:16,500 --> 00:24:18,380
So we can just scan memory,

521
00:24:18,380 --> 00:24:22,120
find that executable that we just ran.

522
00:24:22,120 --> 00:24:24,320
We know exactly what version they have.

523
00:24:24,320 --> 00:24:27,760
And then we know offsets
to the services pointer.

524
00:24:27,760 --> 00:24:29,970
We know the offset for the image handle

525
00:24:29,970 --> 00:24:32,330
for the currently running executable.

526
00:24:32,330 --> 00:24:33,810
There are going to be multiple copies

527
00:24:33,810 --> 00:24:36,070
of these files in memory.

528
00:24:36,070 --> 00:24:38,160
You do need to determine
what is the correct one.

529
00:24:38,160 --> 00:24:43,160
As an example, when Dell
CSOS launcher is loaded,

530
00:24:43,660 --> 00:24:46,440
there will be one copy that is

531
00:24:46,440 --> 00:24:48,760
before it has actually been executed.

532
00:24:48,760 --> 00:24:50,960
So those pointers will be null.

533
00:24:50,960 --> 00:24:54,630
In the live version that
boot services pointer

534
00:24:54,630 --> 00:24:58,010
and EFI handle variables will not be null.

535
00:24:58,010 --> 00:25:01,360
So, again, search for a
pattern, check the pointers.

536
00:25:01,360 --> 00:25:04,800
If they're non null we
found the correct one.

537
00:25:04,800 --> 00:25:06,370
But what about Secure Boot?

538
00:25:06,370 --> 00:25:10,000
We talked about calling a
load image and start image,

539
00:25:10,000 --> 00:25:13,417
but there's still Secure
Boot to contend with

540
00:25:13,417 --> 00:25:15,573
and the cryptographic image verification.

541
00:25:16,430 --> 00:25:19,700
So the UEFI framework is
designed in a modular way,

542
00:25:19,700 --> 00:25:22,631
and it uses this UEFI security2 protocol

543
00:25:22,631 --> 00:25:24,970
to abstract some of
these security functions,

544
00:25:24,970 --> 00:25:28,600
including TCG measured
boot, UEFI secure boot.

545
00:25:28,600 --> 00:25:30,530
Essentially there are a callback handlers

546
00:25:30,530 --> 00:25:32,470
to get registered in this protocol.

547
00:25:32,470 --> 00:25:33,840
In order to actually do that

548
00:25:33,840 --> 00:25:35,850
cryptographic signature verification

549
00:25:35,850 --> 00:25:39,290
and the measurement
into the TPM registers.

550
00:25:39,290 --> 00:25:42,170
So when Dxe core is loading an image.

551
00:25:42,170 --> 00:25:47,010
CoreLoadImageCommon calls,
Security2StubAuthenticate,

552
00:25:47,010 --> 00:25:48,860
which calls ExecuteSecurity2Handlers,

553
00:25:50,092 --> 00:25:52,650
and that function before it actually calls

554
00:25:52,650 --> 00:25:53,650
any of the handlers

555
00:25:53,650 --> 00:25:55,720
checks to see if any are registered

556
00:25:55,720 --> 00:25:59,250
and returns success if there
are no handlers registered.

557
00:25:59,250 --> 00:26:02,410
So it turns out there's a
really easy thing we can do.

558
00:26:02,410 --> 00:26:04,550
In order to turn off image verification.

559
00:26:04,550 --> 00:26:06,490
We just scan memory to find

560
00:26:06,490 --> 00:26:08,860
that SecurityStubDxe executable,

561
00:26:08,860 --> 00:26:11,490
and write a zero to that global variable.

562
00:26:11,490 --> 00:26:13,750
And now we can load whatever we want.

563
00:26:13,750 --> 00:26:16,730
This also stops updating
the TPM measurements

564
00:26:16,730 --> 00:26:18,320
and the rest of the UEFI firmware

565
00:26:18,320 --> 00:26:21,283
still thinks that secure boot
is on and being enforced.

566
00:26:22,135 --> 00:26:25,820
So another thing that we have to deal with

567
00:26:25,820 --> 00:26:29,410
is we have somewhat of a
limited amount of space

568
00:26:29,410 --> 00:26:31,290
in our payload, in the stack.

569
00:26:31,290 --> 00:26:33,800
Where do we want to load our
next EFI executable from?

570
00:26:33,800 --> 00:26:37,280
The easiest thing to do
is have a very small EFI.

571
00:26:37,280 --> 00:26:39,310
That's just appended to the first stage.

572
00:26:39,310 --> 00:26:42,610
You can also call UEFI network functions

573
00:26:42,610 --> 00:26:46,970
to do connections to your
own network infrastructure.

574
00:26:46,970 --> 00:26:49,610
Download new executable is run that way.

575
00:26:49,610 --> 00:26:50,710
So it turns out there's actually

576
00:26:50,710 --> 00:26:52,650
something a lot easier that we can do.

577
00:26:52,650 --> 00:26:55,600
Dell has their own EFI
RamDisk implementation.

578
00:26:55,600 --> 00:26:59,650
And Dell CSOS launcher
will actually download

579
00:26:59,650 --> 00:27:03,100
all those URLs that we
saw in the JSON file

580
00:27:03,100 --> 00:27:05,460
into RamDisk file systems.

581
00:27:05,460 --> 00:27:06,610
It'll verify them,

582
00:27:06,610 --> 00:27:09,020
it'll even extract zip files for you.

583
00:27:09,020 --> 00:27:10,900
And all of these files can be accessed

584
00:27:10,900 --> 00:27:12,660
using standard UEFI functions.

585
00:27:12,660 --> 00:27:16,091
Like EFI simple file system protocol.

586
00:27:16,091 --> 00:27:18,470
And our payload actually
ended up using both of these.

587
00:27:18,470 --> 00:27:21,700
Where we appended a very small executable

588
00:27:21,700 --> 00:27:24,610
to keep our shell code simple.

589
00:27:24,610 --> 00:27:27,760
And then the appended EFI executable

590
00:27:27,760 --> 00:27:30,700
iterated over the file
systems in order to find

591
00:27:30,700 --> 00:27:32,463
the next stage and run that.

592
00:27:33,580 --> 00:27:34,500
For our first demo

593
00:27:34,500 --> 00:27:37,710
we'll just show the classic
example of popping calc,

594
00:27:37,710 --> 00:27:40,353
except in BIOS when
security was turned off.

595
00:27:42,314 --> 00:27:44,897
(jaunty music)

596
00:27:57,370 --> 00:27:58,680
So for our second demo,

597
00:27:58,680 --> 00:28:01,130
we'll increase the
difficulty level a little bit

598
00:28:01,130 --> 00:28:03,220
by using a Secure Core PC

599
00:28:03,220 --> 00:28:06,020
where Secure Boot and all the
other features are turned on

600
00:28:06,020 --> 00:28:07,283
and we'll pop shell.

601
00:28:09,332 --> 00:28:11,915
(jaunty music)

602
00:28:39,833 --> 00:28:43,250
(jaunty music continues)

603
00:29:15,270 --> 00:29:17,940
So for our third demo, or the boss level,

604
00:29:17,940 --> 00:29:20,340
we'll increase the difficulty even further

605
00:29:20,340 --> 00:29:22,470
by still using the Secure Core PC

606
00:29:22,470 --> 00:29:24,650
with all the security features enabled,

607
00:29:24,650 --> 00:29:27,000
but we'll drop a malicious executable

608
00:29:27,000 --> 00:29:29,290
into the Windows startup
folder and run that.

609
00:29:31,229 --> 00:29:33,812
(jaunty music)

610
00:30:01,147 --> 00:30:04,564
(jaunty music continues)

611
00:30:30,137 --> 00:30:33,554
(jaunty music continues)

612
00:31:00,464 --> 00:31:03,881
(jaunty music continues)

613
00:31:33,715 --> 00:31:37,132
(jaunty music continues)

614
00:31:59,978 --> 00:32:03,395
(jaunty music continues)

615
00:32:30,319 --> 00:32:33,736
(jaunty music continues)

616
00:33:00,904 --> 00:33:02,530
- [Mickey] But BitLocker.

617
00:33:02,530 --> 00:33:03,767
Some of you might say,

618
00:33:03,767 --> 00:33:05,840
"Hey, BitLocker is enabled.

619
00:33:05,840 --> 00:33:08,250
Why do you have to suspend it?"

620
00:33:08,250 --> 00:33:10,687
We get to that age old question of,

621
00:33:10,687 --> 00:33:12,480
"What came first, chicken or the egg."

622
00:33:12,480 --> 00:33:15,560
What is this the right thing to do

623
00:33:15,560 --> 00:33:18,260
once you have an update
process you need to follow

624
00:33:18,260 --> 00:33:21,150
when the BitLocker measurements
measure the firmware,

625
00:33:21,150 --> 00:33:22,950
but you need to update the firmware?

626
00:33:24,260 --> 00:33:25,560
So, according to Dell,

627
00:33:25,560 --> 00:33:28,810
the easiest solution
is to suspend BitLocker

628
00:33:28,810 --> 00:33:30,160
before you update the BIOS.

629
00:33:31,400 --> 00:33:35,730
Unsurprisingly, HP has a
very similar recommendation.

630
00:33:35,730 --> 00:33:37,550
and last but not least,

631
00:33:37,550 --> 00:33:41,423
Microsoft also recommends
this for third party updates.

632
00:33:42,390 --> 00:33:45,290
So you can't update firmware
without suspending BitLocker.

633
00:33:46,270 --> 00:33:49,750
Now we do have modern
mitigations in place.

634
00:33:49,750 --> 00:33:53,540
So there are some challenges
If you want to persist.

635
00:33:53,540 --> 00:33:56,560
For example, Boot Guard and BIOS Guard

636
00:33:56,560 --> 00:33:59,500
are there to prevent you
from modifying the firmware

637
00:33:59,500 --> 00:34:03,000
and persisting inside the firmware image.

638
00:34:03,000 --> 00:34:04,789
There are ways around this.

639
00:34:04,789 --> 00:34:08,180
If you see recent
vulnerabilities published,

640
00:34:08,180 --> 00:34:11,560
you might spot some Boot Guard bypasses.

641
00:34:11,560 --> 00:34:13,540
HP Sure Start is another mechanism

642
00:34:13,540 --> 00:34:16,600
to verify the integrity of firmware.

643
00:34:16,600 --> 00:34:19,900
So if you do happen to be an
attacker and modify flash,

644
00:34:19,900 --> 00:34:21,970
you will get caught by HP Sure Start.

645
00:34:21,970 --> 00:34:24,340
Kernel DMA protections are there as well.

646
00:34:24,340 --> 00:34:26,050
VBS and HVCI.

647
00:34:26,050 --> 00:34:27,420
There are protections in place

648
00:34:27,420 --> 00:34:31,610
that prevent you from
abusing low-level mechanisms.

649
00:34:31,610 --> 00:34:35,980
So how would you exploit
this at a large scale?

650
00:34:35,980 --> 00:34:39,211
Well, we know these vulnerabilities

651
00:34:39,211 --> 00:34:43,520
impact a large number of laptops.

652
00:34:43,520 --> 00:34:46,070
We also know that home routers

653
00:34:46,070 --> 00:34:49,570
are being attacked actively right now.

654
00:34:49,570 --> 00:34:52,140
And enterprise device vulnerabilities.

655
00:34:52,140 --> 00:34:55,467
For example, we've seen a lot of effort

656
00:34:55,467 --> 00:34:57,620
done by attackers against VPN servers.

657
00:34:57,620 --> 00:34:59,220
Once they gain that foothold

658
00:34:59,220 --> 00:35:03,400
they are potentially able to modify

659
00:35:03,400 --> 00:35:05,160
internal network appliances,

660
00:35:05,160 --> 00:35:08,830
to redirect DNS traffic inside
an enterprise environment

661
00:35:08,830 --> 00:35:10,550
and so on and so forth.

662
00:35:10,550 --> 00:35:13,330
We can't forget all the
ASN hijacking stuff.

663
00:35:13,330 --> 00:35:16,320
Let's say someone managed
to social engineer

664
00:35:16,320 --> 00:35:20,140
their way to redirect or
the ownership of a DNS

665
00:35:20,140 --> 00:35:22,990
through a registrar or modify records.

666
00:35:22,990 --> 00:35:25,820
There's also BGP hijacking.

667
00:35:25,820 --> 00:35:28,120
And we should never forget

668
00:35:28,120 --> 00:35:31,330
what the ISPs are capable of doing.

669
00:35:31,330 --> 00:35:33,790
No one really knows what ISP's are doing.

670
00:35:33,790 --> 00:35:35,570
So we are at their mercy.

671
00:35:35,570 --> 00:35:38,540
These attacks are actually in the wild

672
00:35:38,540 --> 00:35:39,910
and although not common,

673
00:35:39,910 --> 00:35:41,800
they have happened repeatedly

674
00:35:41,800 --> 00:35:44,850
and are most likely to happen again.

675
00:35:44,850 --> 00:35:48,520
We can't have a talk without
mentioning supply chain.

676
00:35:48,520 --> 00:35:52,550
Now let's say we want
to attack this mechanism

677
00:35:52,550 --> 00:35:54,210
of remote firmware updates.

678
00:35:54,210 --> 00:35:57,300
The simple way to do this,
by supply chain attack,

679
00:35:57,300 --> 00:36:02,300
is by compromising the web
server hosting the XML files.

680
00:36:02,847 --> 00:36:05,830
Let's assume we didn't
have the TLS vulnerability.

681
00:36:05,830 --> 00:36:07,220
We still wanted to gain access

682
00:36:07,220 --> 00:36:09,770
to all the machines that are doing updates

683
00:36:09,770 --> 00:36:12,370
and exploit the other buffer overflows

684
00:36:12,370 --> 00:36:14,350
without the SSL issue.

685
00:36:14,350 --> 00:36:17,910
So a web vulnerability
and a web server expert

686
00:36:17,910 --> 00:36:19,562
would come in handy.

687
00:36:19,562 --> 00:36:22,010
You just replace the files
in downloads.dell.com

688
00:36:22,010 --> 00:36:23,390
and you're done.

689
00:36:23,390 --> 00:36:24,990
The more complex scenario

690
00:36:24,990 --> 00:36:28,210
is when you have an insider
threat inside the chain.

691
00:36:28,210 --> 00:36:31,791
Let's say an employee
manages to modify files

692
00:36:31,791 --> 00:36:35,960
in some of the servers
that hosts these files,

693
00:36:35,960 --> 00:36:38,400
or an insider who is involved

694
00:36:38,400 --> 00:36:42,350
in adding code to the sign binaries

695
00:36:42,350 --> 00:36:44,649
that adds vulnerabilities to them.

696
00:36:44,649 --> 00:36:45,647
It's less likely,

697
00:36:45,647 --> 00:36:47,970
but it's still a scenario
that we should talk about.

698
00:36:47,970 --> 00:36:49,689
In conclusion, a couple of words

699
00:36:49,689 --> 00:36:52,640
about the disclosure process.

700
00:36:52,640 --> 00:36:56,000
It was not easy at first to gain a measure

701
00:36:56,000 --> 00:36:58,610
of how many models were
actually affected by this issue.

702
00:36:58,610 --> 00:37:01,360
But we ended up agreeing

703
00:37:01,360 --> 00:37:04,210
that there were 129 models affected.

704
00:37:04,210 --> 00:37:07,610
The initial disclosure, went
out to Dell on March 3rd.

705
00:37:07,610 --> 00:37:09,240
And by the time we published

706
00:37:09,240 --> 00:37:13,420
our initial high level
blog post on June 24th,

707
00:37:13,420 --> 00:37:16,630
all updates for this issue
have been released publicly.

708
00:37:16,630 --> 00:37:20,220
Note that this has been
90 days plus two weeks

709
00:37:20,220 --> 00:37:24,260
from disclosure to patch of 129 models,

710
00:37:24,260 --> 00:37:26,420
a vulnerability in BIOS.

711
00:37:26,420 --> 00:37:28,720
This, I hope will be an example

712
00:37:28,720 --> 00:37:31,210
for every other vendor
and every other OEM.

713
00:37:31,210 --> 00:37:32,880
Once you find a vulnerability in BIOS,

714
00:37:32,880 --> 00:37:37,880
you can achieve a 90 day timeline
without arguing for more.

715
00:37:39,629 --> 00:37:42,620
If you are affected by this issue,

716
00:37:42,620 --> 00:37:45,650
and you would like to
securely update your system,

717
00:37:45,650 --> 00:37:48,520
we recommend you do not
use these features from,

718
00:37:48,520 --> 00:37:50,130
For obvious reasons,

719
00:37:50,130 --> 00:37:54,800
and download the manual
OEM updates set up files

720
00:37:54,800 --> 00:37:55,890
from the Dell website

721
00:37:55,890 --> 00:37:58,873
and use those to update your BIOS locally.

722
00:37:59,900 --> 00:38:03,170
If you are afraid of rollback

723
00:38:03,170 --> 00:38:05,550
and downgrade attacks on your system,

724
00:38:05,550 --> 00:38:08,850
you can go into BIOS
and uncheck the checkbox

725
00:38:08,850 --> 00:38:11,980
that says allow for downgraded BIOS.

726
00:38:11,980 --> 00:38:13,860
And only check it if you manually

727
00:38:13,860 --> 00:38:15,180
need to roll back your BIOS

728
00:38:15,180 --> 00:38:16,680
for some reason in the future.

729
00:38:17,830 --> 00:38:22,830
All our tools, exploits, data, information

730
00:38:23,247 --> 00:38:25,610
is going to be available on GitHub

731
00:38:25,610 --> 00:38:27,230
in the following address.

732
00:38:27,230 --> 00:38:28,560
Feel free to submit issues.

733
00:38:28,560 --> 00:38:32,330
If you want to ask us questions,
you can DM us on Twitter.

734
00:38:32,330 --> 00:38:34,400
And we would like to say, thank you.

735
00:38:34,400 --> 00:38:37,840
A final thank you to Dell,
CERT for working with us

736
00:38:37,840 --> 00:38:40,530
and resolving this issue in around 90 days

737
00:38:40,530 --> 00:38:43,163
and US CERT for helping us as well.

738
00:38:44,320 --> 00:38:46,180
But that's it.
Thank you for your time.

739
00:38:46,180 --> 00:38:48,210
And we appreciate you listening,

740
00:38:48,210 --> 00:38:49,860
and we hope you enjoyed our talk.

