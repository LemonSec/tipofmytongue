1
00:00:00,980 --> 00:00:03,530
- Welcome to our talk, 2021,

2
00:00:03,530 --> 00:00:07,170
our journey back to the future
of Windows vulnerabilities

3
00:00:07,170 --> 00:00:10,260
and the 0-days we brought back with us.

4
00:00:10,260 --> 00:00:12,310
My name is Tomer Bar.

5
00:00:12,310 --> 00:00:16,558
I've been in the cybersecurity
field for more than 15 years,

6
00:00:16,558 --> 00:00:18,694
currently leading SafeBreach Labs

7
00:00:18,694 --> 00:00:21,427
as director of security research.

8
00:00:21,427 --> 00:00:24,323
My main focus is on vulnerability research

9
00:00:24,323 --> 00:00:26,680
and nation state APT research.

10
00:00:26,680 --> 00:00:28,510
My name is Eran Segal.

11
00:00:28,510 --> 00:00:30,710
I've been in the cyber security field

12
00:00:30,710 --> 00:00:32,410
for more than seven years.

13
00:00:32,410 --> 00:00:35,570
Currently, I'm working
as a security researcher

14
00:00:35,570 --> 00:00:39,080
in SafeBreach Labs for the last two years.

15
00:00:39,080 --> 00:00:41,820
My experience involves research on windows

16
00:00:41,820 --> 00:00:43,133
and the better devices.

17
00:00:46,160 --> 00:00:48,580
In memory of my dad, David,

18
00:00:48,580 --> 00:00:51,280
who bought me my first personal computer

19
00:00:51,280 --> 00:00:53,513
and he's the reason I'm standing here.

20
00:00:54,600 --> 00:00:57,810
In 2020, security researchers reported

21
00:00:57,810 --> 00:01:01,660
a record number of 1000
Windows vulnerabilities.

22
00:01:01,660 --> 00:01:05,010
We were curious, what
superpowers will we get

23
00:01:05,010 --> 00:01:08,310
from researching this huge
number of vulnerabilities?

24
00:01:08,310 --> 00:01:11,650
Can we leverage our
findings to discover 0-days?

25
00:01:11,650 --> 00:01:15,100
We decided to go back in time to 2016,

26
00:01:15,100 --> 00:01:18,060
to search for patterns
and automatically classify

27
00:01:18,060 --> 00:01:21,140
all the public vulnerabilities since then.

28
00:01:21,140 --> 00:01:23,740
We believe that only
by connecting the dots

29
00:01:23,740 --> 00:01:25,030
to a bigger picture,

30
00:01:25,030 --> 00:01:27,910
we will be able to come back to 2021

31
00:01:27,910 --> 00:01:29,963
with the success of achieving our goal.

32
00:01:32,520 --> 00:01:35,140
We will start with describing
the research goals,

33
00:01:35,140 --> 00:01:38,520
assumptions, motivations and approach,

34
00:01:38,520 --> 00:01:41,230
then we will explain the challenge

35
00:01:41,230 --> 00:01:45,140
and our chosen solution,
process and infrastructure.

36
00:01:45,140 --> 00:01:47,970
We will detail the process step-by-step,

37
00:01:47,970 --> 00:01:50,440
provide a detailed end to end example

38
00:01:50,440 --> 00:01:52,920
from 0 to 0-day.

39
00:01:52,920 --> 00:01:55,520
We will present the six vulnerabilities

40
00:01:55,520 --> 00:01:58,333
and past exportation
techniques we discovered.

41
00:01:59,210 --> 00:02:02,560
We'll end our talk with
a new proposed idea

42
00:02:02,560 --> 00:02:05,210
for discovering vulnerable
Windows machines

43
00:02:05,210 --> 00:02:07,003
and open a Q&A session.

44
00:02:07,900 --> 00:02:09,920
We define three main goals.

45
00:02:09,920 --> 00:02:13,940
First, dive in and
understand the root cause

46
00:02:13,940 --> 00:02:18,910
of each vulnerability and how
Microsoft chose to address it.

47
00:02:18,910 --> 00:02:22,080
Second, automate and provide tools

48
00:02:22,080 --> 00:02:24,483
to ease the process
from root cause to POC.

49
00:02:26,110 --> 00:02:29,730
Last but most important,
discover new 0-days

50
00:02:29,730 --> 00:02:32,083
based on a semi-automated process.

51
00:02:33,150 --> 00:02:36,290
Every research start with assumptions.

52
00:02:36,290 --> 00:02:37,900
Let's describe them.

53
00:02:37,900 --> 00:02:40,810
The first assumption is
that although Microsoft

54
00:02:40,810 --> 00:02:45,690
is a huge enterprise with
thousands of developers,

55
00:02:45,690 --> 00:02:50,130
we believe that similar
vulnerabilities will be mitigated

56
00:02:50,130 --> 00:02:52,600
by similar patching techniques.

57
00:02:52,600 --> 00:02:55,810
The second assumption is
that Microsoft will try

58
00:02:55,810 --> 00:02:59,790
to fix each vulnerability
with as minority change

59
00:02:59,790 --> 00:03:04,790
as possible in order to avoid
backward compatibility issues.

60
00:03:04,800 --> 00:03:08,323
This approach might be
prone to patch bypasses.

61
00:03:09,370 --> 00:03:13,320
Last, it will be a good
idea to search for 0-days

62
00:03:13,320 --> 00:03:17,283
near a code that's already
been known as vulnerable.

63
00:03:18,440 --> 00:03:21,240
Probably the first thing you will do

64
00:03:21,240 --> 00:03:24,533
is to start checking if your
assumptions are correct.

65
00:03:25,840 --> 00:03:28,490
We encountered a recent public research

66
00:03:28,490 --> 00:03:31,300
on just one ento scalar function,

67
00:03:31,300 --> 00:03:33,970
which included five
different vulnerabilities

68
00:03:33,970 --> 00:03:37,890
from various categories,
in a short block of code.

69
00:03:37,890 --> 00:03:40,570
We won't dive into the specific details

70
00:03:40,570 --> 00:03:42,390
of each vulnerability,

71
00:03:42,390 --> 00:03:43,950
but you can get the impression

72
00:03:43,950 --> 00:03:46,820
that our assumptions were fulfilled.

73
00:03:46,820 --> 00:03:49,330
Vulnerable code is a good place to search

74
00:03:49,330 --> 00:03:50,930
for new vulnerabilities.

75
00:03:50,930 --> 00:03:53,780
The vulnerabilities have
different categories,

76
00:03:53,780 --> 00:03:56,460
but all are due to wrong bound checks

77
00:03:56,460 --> 00:03:59,483
or wrong entering of memory allocations.

78
00:04:01,670 --> 00:04:05,890
Now that we are more confident
in the research idea,

79
00:04:05,890 --> 00:04:09,133
it was time to think about
our research approach.

80
00:04:10,330 --> 00:04:13,610
Until now, patch diffing was done manually

81
00:04:13,610 --> 00:04:15,280
by comparing the differences

82
00:04:15,280 --> 00:04:18,470
of a vulnerable executable
to its new code version

83
00:04:18,470 --> 00:04:19,820
after the fix.

84
00:04:19,820 --> 00:04:23,530
Furthermore, the main goal of this process

85
00:04:23,530 --> 00:04:26,210
was focused on
understanding the root cause

86
00:04:26,210 --> 00:04:29,960
of a single vulnerability
and building 1-day

87
00:04:29,960 --> 00:04:30,983
to exploit it.

88
00:04:32,030 --> 00:04:33,530
We aimed higher,

89
00:04:33,530 --> 00:04:36,670
we wanted to find 0-days in the end.

90
00:04:36,670 --> 00:04:40,553
But is it possible to jump
from root cost to 0-days?

91
00:04:41,540 --> 00:04:44,620
We understood that in order to achieve it,

92
00:04:44,620 --> 00:04:47,330
we will need to build an automated process

93
00:04:47,330 --> 00:04:48,750
that will gather the insights

94
00:04:48,750 --> 00:04:53,470
from all the patches in
a single searchable DB.

95
00:04:53,470 --> 00:04:58,040
Let's dive into our
infrastructure implementation,

96
00:04:58,040 --> 00:04:59,513
moving over to Eran.

97
00:05:01,330 --> 00:05:03,670
- We were required to take four steps

98
00:05:03,670 --> 00:05:06,320
in order to achieve our goal.

99
00:05:06,320 --> 00:05:09,880
The first step is to understand
each one of the patches

100
00:05:09,880 --> 00:05:14,240
Microsoft released and infer
the vulnerability root cause.

101
00:05:14,240 --> 00:05:16,965
Then we want to integrate the context

102
00:05:16,965 --> 00:05:19,830
of each vulnerability by correlating

103
00:05:19,830 --> 00:05:23,520
publicly available information
about the vulnerability

104
00:05:23,520 --> 00:05:25,400
with each patch.

105
00:05:25,400 --> 00:05:27,760
The second step is to find a way

106
00:05:27,760 --> 00:05:29,530
to trigger the vulnerability.

107
00:05:29,530 --> 00:05:33,853
In other words, which actions
lead to the vulnerable code.

108
00:05:35,210 --> 00:05:38,940
Finally, after gaining
this valuable knowledge,

109
00:05:38,940 --> 00:05:42,840
we had to find ways to
harness this knowledge

110
00:05:42,840 --> 00:05:44,433
for hunting 0-days.

111
00:05:45,630 --> 00:05:47,453
Let's begin with step one.

112
00:05:48,600 --> 00:05:52,310
The automated process
includes five sub-steps.

113
00:05:52,310 --> 00:05:54,780
First, downloading all Windows 8

114
00:05:54,780 --> 00:05:58,683
security only updates since 2016.

115
00:05:59,540 --> 00:06:02,840
the reason we chose to
download security updates

116
00:06:02,840 --> 00:06:05,530
of Windows 8 and not Windows 10,

117
00:06:05,530 --> 00:06:09,790
is because Windows 8 is
a security only updates

118
00:06:09,790 --> 00:06:11,643
while Windows 10 doesn't.

119
00:06:14,851 --> 00:06:16,490
It is possible to discover
all the vulnerabilities

120
00:06:18,270 --> 00:06:23,160
Microsoft ever fixed in
Windows 8 since 2016,

121
00:06:23,160 --> 00:06:25,363
using the security updates.

122
00:06:26,360 --> 00:06:30,520
After we downloaded all Windows
8 security only updates,

123
00:06:30,520 --> 00:06:33,790
the automated process, extract the KBs

124
00:06:33,790 --> 00:06:36,730
and compare the extracted files

125
00:06:36,730 --> 00:06:40,140
versus the older version of the same files

126
00:06:40,140 --> 00:06:41,323
using BinDiff tool.

127
00:06:42,660 --> 00:06:44,593
Now the fun part begins.

128
00:06:45,490 --> 00:06:48,550
The changes are classified into groups

129
00:06:48,550 --> 00:06:51,590
and inserted into a database

130
00:06:51,590 --> 00:06:53,953
so we will be able to search for patterns.

131
00:06:54,910 --> 00:06:58,060
Each group represent a
specific type of change

132
00:06:58,060 --> 00:07:02,230
and we will talk about these
features in the next slides.

133
00:07:02,230 --> 00:07:06,110
To get some perspective on the
scale we are talking about,

134
00:07:06,110 --> 00:07:08,160
here are a few numbers.

135
00:07:08,160 --> 00:07:12,533
You can see, we have more
than 100,000 unique functions,

136
00:07:13,650 --> 00:07:16,820
each one of them may be a part of a patch

137
00:07:16,820 --> 00:07:18,610
so it is clear that we need to understand

138
00:07:18,610 --> 00:07:22,363
which changes are
interesting and which aren't.

139
00:07:24,530 --> 00:07:27,350
Inside the KB, some of
the files are interesting

140
00:07:27,350 --> 00:07:32,350
while others aren't because
APE can get indirectly updated

141
00:07:32,600 --> 00:07:35,830
such as a change in one of its libraries.

142
00:07:35,830 --> 00:07:37,690
It have huge effect.

143
00:07:37,690 --> 00:07:41,230
For example, GDI 32 is
one of the most vulnerable

144
00:07:41,230 --> 00:07:42,863
PEs in Windows.

145
00:07:43,710 --> 00:07:48,210
It has more than 26
statically linked libraries.

146
00:07:48,210 --> 00:07:51,230
Some of these libraries
are statically linked

147
00:07:51,230 --> 00:07:53,003
to another libraries and so on.

148
00:07:54,400 --> 00:07:58,570
In addition, every PE in
Windows 8 is part of a package

149
00:07:58,570 --> 00:08:01,680
and every time one of the PEs is affected,

150
00:08:01,680 --> 00:08:03,330
has to be updated.

151
00:08:03,330 --> 00:08:06,400
The entire package is
really compiled together

152
00:08:06,400 --> 00:08:09,313
and all the files are included in the KB.

153
00:08:10,560 --> 00:08:13,530
In order to detect which
changes are interesting

154
00:08:13,530 --> 00:08:16,510
and which aren't, first,
we need to understand

155
00:08:16,510 --> 00:08:19,223
which changes the compiler can do.

156
00:08:21,460 --> 00:08:24,250
It is not simple to distinguish
between changes made

157
00:08:24,250 --> 00:08:27,220
by the developer and the
changes made by the compiler

158
00:08:27,220 --> 00:08:29,730
because of free compilations.

159
00:08:29,730 --> 00:08:32,210
If you compile the same code twice,

160
00:08:32,210 --> 00:08:36,740
the compiler sometimes is compiled

161
00:08:36,740 --> 00:08:41,030
with different alignments of the code.

162
00:08:41,030 --> 00:08:42,830
We all do some instructions

163
00:08:42,830 --> 00:08:46,103
and all other optimizations.

164
00:08:47,850 --> 00:08:51,200
We had to find ways to
reduce the compiler noise.

165
00:08:51,200 --> 00:08:54,503
We chose to reduce the
compiler noise using features.

166
00:08:56,050 --> 00:08:59,150
The features group
similar changes together

167
00:08:59,150 --> 00:09:02,940
and allow us to look for
vulnerability patterns.

168
00:09:02,940 --> 00:09:05,410
We developed 33 features,

169
00:09:05,410 --> 00:09:08,090
most of them are in the function level,

170
00:09:08,090 --> 00:09:11,760
but other are in the executable level.

171
00:09:11,760 --> 00:09:14,280
Each feature is optimized differently.

172
00:09:14,280 --> 00:09:16,910
Some are optimized to
have the lowest amount

173
00:09:16,910 --> 00:09:18,770
of false positives,

174
00:09:18,770 --> 00:09:22,923
while others give us the
overview insights on the patch.

175
00:09:24,900 --> 00:09:26,830
There are two types of features,

176
00:09:26,830 --> 00:09:30,470
patch-related features and
vulnerability-related features.

177
00:09:30,470 --> 00:09:33,170
Patch-related features group patches

178
00:09:33,170 --> 00:09:36,600
by the type of the
change made by Microsoft,

179
00:09:36,600 --> 00:09:39,423
such as add a new function call,

180
00:09:40,600 --> 00:09:43,590
while vulnerability-related
features group patches

181
00:09:43,590 --> 00:09:46,780
by vulnerability category
such as off by one,

182
00:09:46,780 --> 00:09:48,673
use after free and so on.

183
00:09:49,680 --> 00:09:52,700
The beauty of the features
lie in their simplicity,

184
00:09:52,700 --> 00:09:55,453
we'll provide some examples
in the next slides.

185
00:09:57,200 --> 00:09:59,183
2019, here we come.

186
00:10:00,370 --> 00:10:03,410
The first example of
patch-related features

187
00:10:03,410 --> 00:10:05,440
is the number of Xrefs.

188
00:10:05,440 --> 00:10:07,230
It is not directly linked

189
00:10:07,230 --> 00:10:10,410
to a specific vulnerability category.

190
00:10:10,410 --> 00:10:13,410
This feature compares the
number of function calls

191
00:10:13,410 --> 00:10:18,190
between each patched function
versus the unpatched version.

192
00:10:18,190 --> 00:10:22,520
In this example,
ReadPROPVARIANT added one Xref

193
00:10:22,520 --> 00:10:23,353
to IStream_Read.

194
00:10:24,240 --> 00:10:29,240
Let's look into the overview
of ReadPROP variant function.

195
00:10:31,440 --> 00:10:34,140
It is very easy to spot the change block.

196
00:10:34,140 --> 00:10:36,433
Let's zoom in to
understand the root cause.

197
00:10:38,160 --> 00:10:43,160
As we can see, one call and
slim move operations were added.

198
00:10:43,340 --> 00:10:46,890
The root cause of this
vulnerability is type confusion

199
00:10:46,890 --> 00:10:49,520
due to the fact that ReadPROP variant,

200
00:10:49,520 --> 00:10:51,582
reads a decimal from the file

201
00:10:51,582 --> 00:10:54,415
without resetting VT to VT_DECIMAL

202
00:10:55,472 --> 00:10:58,164
This means that we can control

203
00:10:58,164 --> 00:11:01,463
the type of ReadPROP variant object.

204
00:11:01,463 --> 00:11:04,823
The patch added a call to item read

205
00:11:04,823 --> 00:11:08,906
and set VT to VT_DECIMAL
to avoid type confusion.

206
00:11:11,250 --> 00:11:14,173
Let's jump back to 2018.

207
00:11:15,780 --> 00:11:19,980
An additional patch-related
feature is number of conditions.

208
00:11:19,980 --> 00:11:23,100
It compares the patched
and unpatched version

209
00:11:23,100 --> 00:11:28,100
of the file and looks for
different amounts of conditions

210
00:11:28,260 --> 00:11:30,250
in those functions.

211
00:11:30,250 --> 00:11:35,250
In this example, the patch
added five new conditions

212
00:11:35,780 --> 00:11:39,823
to the function NTFS
find files owned by SID,

213
00:11:41,190 --> 00:11:45,063
changing the number of
conditions between 27 and 32.

214
00:11:49,200 --> 00:11:54,200
We automatically correlation
between finding in our DB

215
00:11:55,470 --> 00:11:57,003
and public exploits.

216
00:11:58,850 --> 00:12:02,650
Going into the patch, we can
see the five added code blocks

217
00:12:02,650 --> 00:12:06,960
in the patched files on the right.

218
00:12:06,960 --> 00:12:10,800
Their goal is to verify that
the user has admin permissions

219
00:12:10,800 --> 00:12:15,800
by calling SE token is admin
and allowing the listing,

220
00:12:17,420 --> 00:12:21,160
only if the user have listing permissions.

221
00:12:21,160 --> 00:12:25,003
Let's move to vulnerability-specific
features, Tomer.

222
00:12:25,870 --> 00:12:27,200
- Thank you, Eran.

223
00:12:27,200 --> 00:12:31,200
Until this point, we introduced
patch-related features.

224
00:12:31,200 --> 00:12:34,810
Now we will represent how
these patch-related features

225
00:12:34,810 --> 00:12:38,740
can be used to understand
the vulnerability root cause.

226
00:12:38,740 --> 00:12:40,943
We will go over a few examples.

227
00:12:42,650 --> 00:12:46,130
The professor told us not to,

228
00:12:46,130 --> 00:12:48,493
but we are bound to break rules.

229
00:12:50,420 --> 00:12:53,910
Following our guidelines
of learning from the past,

230
00:12:53,910 --> 00:12:57,290
we look at high-profile
integer overflow vulnerability,

231
00:12:57,290 --> 00:13:02,030
the SMB GHOST, the patch
usage function RtlULong

232
00:13:03,410 --> 00:13:06,490
in order to verify that our location size

233
00:13:06,490 --> 00:13:09,933
will not overflow before
calling the allocation function.

234
00:13:11,160 --> 00:13:12,890
Is this a unique fix

235
00:13:12,890 --> 00:13:17,240
or should we expect Microsoft
to use this fixed method

236
00:13:17,240 --> 00:13:19,643
in other integer overflow vulnerabilities?

237
00:13:20,660 --> 00:13:23,070
Let's go back in time
to the earliest patches

238
00:13:23,070 --> 00:13:25,383
we identified two binary defic.

239
00:13:27,350 --> 00:13:32,350
We went back in time to
2016, Las Vegas DEFCON 25.

240
00:13:34,560 --> 00:13:37,760
It seems that there is
a searchable pattern

241
00:13:37,760 --> 00:13:40,630
for the integer overflow
vulnerability category.

242
00:13:40,630 --> 00:13:45,630
The fix added Xref to the
several ulong arithmetic function

243
00:13:45,820 --> 00:13:48,540
before calling the vulnerable function.

244
00:13:48,540 --> 00:13:52,750
In this example, it calls
the ulong multiply function

245
00:13:52,750 --> 00:13:57,180
in order to verify that
allocation size will not overflow

246
00:13:57,180 --> 00:13:59,480
before calling the allocation function.

247
00:13:59,480 --> 00:14:01,690
We constructed a list of ulong functions

248
00:14:01,690 --> 00:14:03,793
and added in-safe feature.

249
00:14:05,440 --> 00:14:07,320
Our integer overflow feature,

250
00:14:07,320 --> 00:14:10,250
we tell with more than 200 results.

251
00:14:10,250 --> 00:14:11,980
We selected the vulnerability,

252
00:14:11,980 --> 00:14:16,200
but as far as we know, has
not been publicly analyzed yet

253
00:14:16,200 --> 00:14:18,500
and see if the feature provide us

254
00:14:18,500 --> 00:14:20,823
with automated root cause analysis.

255
00:14:22,610 --> 00:14:25,953
We chose the NTDLL pitch from April, 2020.

256
00:14:27,380 --> 00:14:29,940
The only function that was really changed

257
00:14:29,940 --> 00:14:33,270
was LDRP search resource section

258
00:14:33,270 --> 00:14:37,530
and the change included
adding both RtlULong multiply

259
00:14:37,530 --> 00:14:38,853
and add functions.

260
00:14:41,330 --> 00:14:43,110
Indeed, the patch was implemented

261
00:14:43,110 --> 00:14:47,680
by verifying that allocated
mapping size will not overflow.

262
00:14:47,680 --> 00:14:51,070
This was done using
the same ulong function

263
00:14:51,070 --> 00:14:53,963
as the vulnerability we saw
in the previous example.

264
00:14:54,960 --> 00:14:59,880
As far as we know, this patch
pattern used since 2016,

265
00:15:00,780 --> 00:15:03,953
so now we have a working
integer overflow feature.

266
00:15:05,830 --> 00:15:09,580
Sometimes features are very simple,

267
00:15:09,580 --> 00:15:11,410
but are still very effective,

268
00:15:11,410 --> 00:15:13,730
searching for all added functions

269
00:15:13,730 --> 00:15:17,200
that include integrity
level, expand the category

270
00:15:17,200 --> 00:15:19,973
and provide several
additional vulnerabilities.

271
00:15:21,060 --> 00:15:23,660
There are additional features
that we have researched

272
00:15:23,660 --> 00:15:25,450
and found interesting.

273
00:15:25,450 --> 00:15:28,620
One feature is vice-conditioned
vulnerabilities,

274
00:15:28,620 --> 00:15:32,710
which are usually fixed
by adding log functions.

275
00:15:32,710 --> 00:15:35,210
Another feature is direct traversal,

276
00:15:35,210 --> 00:15:39,160
which are mitigated by
detecting the ./ in strings,

277
00:15:39,160 --> 00:15:41,210
we'll speak about it later.

278
00:15:41,210 --> 00:15:43,830
And finally, symbolic
link vulnerabilities,

279
00:15:43,830 --> 00:15:46,680
which are very common
and are usually mitigated

280
00:15:46,680 --> 00:15:48,943
by adding a check for the final path.

281
00:15:51,210 --> 00:15:53,303
Let's describe the second step.

282
00:15:54,640 --> 00:15:58,810
Patch Tuesday occurs on the
second Tuesday of each month

283
00:15:58,810 --> 00:16:02,770
and includes a report for
each patch vulnerability.

284
00:16:02,770 --> 00:16:05,260
The report includes important data,

285
00:16:05,260 --> 00:16:09,040
such as name, CVE number the affected OS,

286
00:16:09,040 --> 00:16:11,832
vulnerability category and et cetera.

287
00:16:11,832 --> 00:16:15,770
The cue is to have a
description until mid 2020.

288
00:16:15,770 --> 00:16:19,900
The information can help us
focus on the relevant features

289
00:16:19,900 --> 00:16:22,023
and the related executables.

290
00:16:23,290 --> 00:16:26,910
We have created an automated
process that uses the API

291
00:16:26,910 --> 00:16:31,720
for downloading of all published
CVE data since mid 2016.

292
00:16:33,210 --> 00:16:36,590
Please note that Microsoft
recently changed the API

293
00:16:36,590 --> 00:16:37,840
and released the new one.

294
00:16:39,700 --> 00:16:43,210
The coalition process
consists of four steps.

295
00:16:43,210 --> 00:16:47,200
First, take the previously
extracted patches files,

296
00:16:47,200 --> 00:16:51,810
then query all CVE data
using Microsoft's API.

297
00:16:51,810 --> 00:16:54,820
Then, extract the
vulnerable component name,

298
00:16:54,820 --> 00:16:57,070
we will refer it as VCN

299
00:16:57,070 --> 00:17:00,820
from vulnerability CVE
name or description.

300
00:17:00,820 --> 00:17:04,430
And finally, call it the
CVEs to the patch files

301
00:17:04,430 --> 00:17:07,603
based on four different coalition methods.

302
00:17:09,010 --> 00:17:14,010
First, we check if the VCN
extracted for Microsoft's API

303
00:17:14,040 --> 00:17:15,670
is a Windows service.

304
00:17:15,670 --> 00:17:18,070
The list of Windows
service names is available

305
00:17:18,070 --> 00:17:19,710
in the registry.

306
00:17:19,710 --> 00:17:22,550
As we can see, connected user experiences

307
00:17:22,550 --> 00:17:26,223
and telemetry is the name
of diagtrack service.

308
00:17:27,900 --> 00:17:30,430
If the VCN is not a service name,

309
00:17:30,430 --> 00:17:34,230
we will check if the VCN is
included in the file description

310
00:17:34,230 --> 00:17:37,110
of any of the system files.

311
00:17:37,110 --> 00:17:40,250
As we can see, compatibility appraiser,

312
00:17:40,250 --> 00:17:43,743
VCN, is the description of
the appraiser executable.

313
00:17:45,980 --> 00:17:49,580
The third method of
correlation was built manually.

314
00:17:49,580 --> 00:17:51,520
We classify those VCN

315
00:17:51,520 --> 00:17:54,363
based on our Windows internal knowledge.

316
00:17:56,390 --> 00:17:59,990
The last correlation is
based on get all statistics.

317
00:17:59,990 --> 00:18:03,130
Past association help in
understanding the correlation

318
00:18:03,130 --> 00:18:06,770
between VCNs and the
vulnerable executable.

319
00:18:06,770 --> 00:18:10,400
In this example, arrow
reporting was the VCN,

320
00:18:10,400 --> 00:18:14,543
which was found in three
Patch Tuesday during 2020.

321
00:18:15,490 --> 00:18:17,690
If we search for files which were patched

322
00:18:17,690 --> 00:18:20,400
during these months and were not patched

323
00:18:20,400 --> 00:18:22,190
in other 22 months,

324
00:18:22,190 --> 00:18:25,710
we've found eight possible patched files.

325
00:18:25,710 --> 00:18:29,370
Print spooler was the VCN
in four monthly the patches

326
00:18:29,370 --> 00:18:33,140
and was associated with
12 possible patch files.

327
00:18:33,140 --> 00:18:35,540
Next time, we will see this VCN

328
00:18:35,540 --> 00:18:38,650
as part of a future vulnerability report.

329
00:18:38,650 --> 00:18:42,143
We will be able to correlate
them to those files.

330
00:18:43,590 --> 00:18:46,540
The four methods automatically
produced correlation

331
00:18:46,540 --> 00:18:48,783
of 90% of the CVEs.

332
00:18:49,720 --> 00:18:53,480
Now that we know more about
the context of each patch,

333
00:18:53,480 --> 00:18:56,660
we can prioritize which
changes are more interesting

334
00:18:56,660 --> 00:18:58,450
and which are less.

335
00:18:58,450 --> 00:19:00,033
Moving over to Eran.

336
00:19:01,010 --> 00:19:05,490
- So we found the patch linked
to the corresponding CVE

337
00:19:05,490 --> 00:19:08,610
and found which type of
vulnerability it was.

338
00:19:08,610 --> 00:19:13,210
Now, how do you find which
PE can trigger that code?

339
00:19:13,210 --> 00:19:15,380
Who is calling that PE?

340
00:19:15,380 --> 00:19:18,633
And which functions are called?

341
00:19:20,290 --> 00:19:23,840
Our goal in step three is finding out

342
00:19:23,840 --> 00:19:26,090
how to trigger the vulnerable function

343
00:19:26,090 --> 00:19:29,197
and generate the code that will take it.

344
00:19:30,530 --> 00:19:33,490
There are two sub steps for this step.

345
00:19:33,490 --> 00:19:36,610
First, find which executables

346
00:19:36,610 --> 00:19:40,380
can trigger the vulnerable
code and the second,

347
00:19:40,380 --> 00:19:43,790
generate the code with the correct input

348
00:19:43,790 --> 00:19:46,260
to trigger the vulnerability.

349
00:19:47,560 --> 00:19:50,730
We added new features that will extract

350
00:19:50,730 --> 00:19:54,830
all the function calls
from all the PEs in Windows

351
00:19:54,830 --> 00:19:59,500
and for all the versions in
order to generate a call graph

352
00:19:59,500 --> 00:20:03,800
from or to any function in Windows.

353
00:20:03,800 --> 00:20:06,860
We are talking about a very large scale,

354
00:20:06,860 --> 00:20:11,860
we are talking about more than
26 million function calls.

355
00:20:13,030 --> 00:20:16,150
Our graph is just like the graphs in IDA

356
00:20:16,150 --> 00:20:18,773
but across binaries and huge.

357
00:20:20,420 --> 00:20:24,400
With the data we collected,
now we can create a call graph

358
00:20:24,400 --> 00:20:26,563
across the entire Windows system.

359
00:20:27,920 --> 00:20:31,250
In the picture you can see
a visual representation

360
00:20:31,250 --> 00:20:34,830
of the call graph we
created in order to find

361
00:20:34,830 --> 00:20:39,830
which functions are called
to unwrap XML invitation.

362
00:20:40,350 --> 00:20:42,410
Later on, we will demonstrate

363
00:20:42,410 --> 00:20:45,040
how we are going to use this function

364
00:20:45,040 --> 00:20:46,923
in past exploitation scenario.

365
00:20:49,140 --> 00:20:52,297
We support multiple ways
to detect a function call

366
00:20:52,297 --> 00:20:54,770
from a function to another.

367
00:20:54,770 --> 00:20:57,240
Load-time linking is
the common way to call

368
00:20:57,240 --> 00:20:59,370
for an external function.

369
00:20:59,370 --> 00:21:01,800
Runtime linking such as gettalkaddress

370
00:21:02,700 --> 00:21:05,033
and COM servers and clients.

371
00:21:05,960 --> 00:21:09,040
We generate this class for Windows 8

372
00:21:09,040 --> 00:21:11,340
and Windows 10 because after all,

373
00:21:11,340 --> 00:21:13,633
we want to find 0-days in Windows 10.

374
00:21:14,530 --> 00:21:17,200
In addition to creating the graph,

375
00:21:17,200 --> 00:21:21,260
we collected information we need to choose

376
00:21:21,260 --> 00:21:24,650
which function are the most interesting.

377
00:21:24,650 --> 00:21:27,050
We do that by looking for function,

378
00:21:27,050 --> 00:21:29,720
which are close in terms of distance

379
00:21:29,720 --> 00:21:31,770
to the vulnerable function,

380
00:21:31,770 --> 00:21:35,360
verifying whether or not
the function is exported

381
00:21:35,360 --> 00:21:38,377
and events scraping the internet.

382
00:21:39,890 --> 00:21:42,830
We collected information and call examples

383
00:21:42,830 --> 00:21:45,900
about each function for multiple sources,

384
00:21:45,900 --> 00:21:50,633
such as MSDN documentation and
scraping project in GitHub.

385
00:21:51,660 --> 00:21:54,780
User existing examples from the internet

386
00:21:54,780 --> 00:21:58,000
is much quicker than
writing them ourselves,

387
00:21:58,000 --> 00:21:59,440
especially when we are talking

388
00:21:59,440 --> 00:22:01,663
about non-documented functions.

389
00:22:02,920 --> 00:22:06,550
But we found that even that wasn't enough.

390
00:22:06,550 --> 00:22:09,000
We were still missing lots of functions

391
00:22:09,000 --> 00:22:13,433
so we had to find additional
ways to generate PLCs.

392
00:22:15,430 --> 00:22:18,960
So we want to have the option to trigger

393
00:22:18,960 --> 00:22:21,063
all RPC servers quickly.

394
00:22:21,940 --> 00:22:25,070
RPC is a common
interprocess communication.

395
00:22:25,070 --> 00:22:28,040
It can be over network or locally.

396
00:22:28,040 --> 00:22:32,130
RPC calls use IDL, interface
definition language,

397
00:22:32,130 --> 00:22:33,710
to set up the communication

398
00:22:33,710 --> 00:22:36,370
between the client and the servers.

399
00:22:36,370 --> 00:22:40,040
In order to communicate
with an RPC server,

400
00:22:40,040 --> 00:22:42,793
we have to include the
corresponding IDL file.

401
00:22:44,370 --> 00:22:47,420
Therefore, we would like
to extract from Windows

402
00:22:47,420 --> 00:22:49,523
as many ideas as possible.

403
00:22:50,410 --> 00:22:52,780
Since the original version of RPC view

404
00:22:52,780 --> 00:22:56,900
support only extraction
of a single interface IDL,

405
00:22:56,900 --> 00:23:01,900
we use a modified RPC view
tool to extract all IDLs

406
00:23:01,930 --> 00:23:03,693
with all the interfaces.

407
00:23:04,960 --> 00:23:06,630
The extracted IDL file

408
00:23:06,630 --> 00:23:09,010
include dozens of sparks and unions.

409
00:23:09,010 --> 00:23:11,780
Most of them raise compilation and all

410
00:23:11,780 --> 00:23:13,700
due to order of definition

411
00:23:13,700 --> 00:23:15,313
so we fixed that as well.

412
00:23:16,300 --> 00:23:20,480
RPC view works on the running RPC servers,

413
00:23:20,480 --> 00:23:23,020
so we had to start all of them.

414
00:23:23,020 --> 00:23:24,130
After running a script

415
00:23:24,130 --> 00:23:26,540
to automatically start Windows services,

416
00:23:26,540 --> 00:23:29,563
we got 150 running services.

417
00:23:31,760 --> 00:23:35,360
After we extracted the IDL
from the opposite view,

418
00:23:35,360 --> 00:23:37,820
we used the automated process.

419
00:23:37,820 --> 00:23:42,550
For each interface, the
automation created a new project,

420
00:23:42,550 --> 00:23:45,940
setting the relevant
parameters for the code

421
00:23:45,940 --> 00:23:49,210
and compile it using MSBuild.

422
00:23:49,210 --> 00:23:52,789
In the end, we successfully
automatically generated

423
00:23:52,789 --> 00:23:55,773
127 working projects.

424
00:23:57,150 --> 00:24:00,500
We'll provide a specific
example of how easy it is

425
00:24:00,500 --> 00:24:04,600
to exploit the task
scheduler ALPC vulnerability,

426
00:24:04,600 --> 00:24:07,000
using our semi-automated process,

427
00:24:07,000 --> 00:24:09,230
calling some of the functions

428
00:24:09,230 --> 00:24:11,263
that the IDL exposes.

429
00:24:13,800 --> 00:24:17,290
We generate and compile
the template project.

430
00:24:17,290 --> 00:24:19,690
The project includes two fives,

431
00:24:19,690 --> 00:24:23,290
the IDL and the short
generic template for settings

432
00:24:23,290 --> 00:24:27,103
that needed opposite parameters
for composed RPC binding.

433
00:24:30,010 --> 00:24:34,090
In this example, the
provider DUID, the protocol,

434
00:24:34,090 --> 00:24:36,070
the RPC endpoint name,

435
00:24:36,070 --> 00:24:39,283
are relevant to the
task scheduler opposite.

436
00:24:40,430 --> 00:24:44,220
This template allows us
to call each RPC function

437
00:24:44,220 --> 00:24:46,230
that we would like to take trigger.

438
00:24:48,229 --> 00:24:50,773
After the automation created our project

439
00:24:50,773 --> 00:24:53,970
with all the dependencies,
comes the manual part,

440
00:24:53,970 --> 00:24:56,270
writing the exploit itself.

441
00:24:56,270 --> 00:24:59,430
All we need to do is call
the correct functions

442
00:24:59,430 --> 00:25:03,670
with the correct input and
we'll get a working project,

443
00:25:03,670 --> 00:25:05,653
we will get privilege escalation.

444
00:25:06,650 --> 00:25:09,280
In order to exploit this vulnerability,

445
00:25:09,280 --> 00:25:14,280
we created and had a link
and did two RPC calls.

446
00:25:15,200 --> 00:25:18,260
The first RPC call creates a folder

447
00:25:18,260 --> 00:25:20,920
in the task scheduler for them

448
00:25:20,920 --> 00:25:24,150
and the second RPC call
sets the permissions.

449
00:25:24,150 --> 00:25:26,570
This would trigger the task scheduler

450
00:25:26,570 --> 00:25:29,540
to set the permissions of our executable,

451
00:25:29,540 --> 00:25:33,560
resulting previous
escalation to anti-system.

452
00:25:33,560 --> 00:25:35,657
Moving on to Tomer.

453
00:25:35,657 --> 00:25:38,230
- Until this point, we
covered how we can understand

454
00:25:38,230 --> 00:25:42,060
the root cause and
trigger a 1-day in scale.

455
00:25:42,060 --> 00:25:44,520
But how do we find 0-days?

456
00:25:44,520 --> 00:25:49,050
We will use the XXE vulnerability
as an end to end example,

457
00:25:49,050 --> 00:25:53,143
to demonstrate the four-step
process from 0 to 0-day.

458
00:25:54,980 --> 00:25:57,950
We enrich our DB with the
vulnerability category,

459
00:25:57,950 --> 00:26:01,440
name CWE, for each vulnerability.

460
00:26:01,440 --> 00:26:03,870
Then when we queried our DB

461
00:26:03,870 --> 00:26:06,220
for the different CWE categories,

462
00:26:06,220 --> 00:26:09,960
we noticed the 611 category
improper restriction

463
00:26:09,960 --> 00:26:12,240
of XML entity resonance

464
00:26:12,240 --> 00:26:14,640
with six relevant vulnerabilities.

465
00:26:14,640 --> 00:26:17,393
Let's query to see more
details about them.

466
00:26:19,440 --> 00:26:22,460
We eventually found eight
patched vulnerabilities,

467
00:26:22,460 --> 00:26:25,970
six of them with full details in our DB.

468
00:26:25,970 --> 00:26:30,533
So we were curious, what is
this vulnerability category?

469
00:26:31,980 --> 00:26:36,980
As described by CWE, using
XML with an external entity,

470
00:26:37,770 --> 00:26:39,870
allows remote file read.

471
00:26:39,870 --> 00:26:43,130
Hmm, sounds very interesting.

472
00:26:43,130 --> 00:26:47,523
Let's dig deeper in order to
understand how XXE happens.

473
00:26:50,407 --> 00:26:54,120
XXE vulnerabilities occur in XML parsers.

474
00:26:54,120 --> 00:26:58,520
When the XML contains a
reference to an external entity,

475
00:26:58,520 --> 00:27:01,720
such an HTTP server, this external entity

476
00:27:01,720 --> 00:27:04,790
can get the content of local files.

477
00:27:04,790 --> 00:27:08,010
XXE vulnerabilities
contain multiple parts.

478
00:27:08,010 --> 00:27:11,773
The upper entity is the
input to the XML parser.

479
00:27:12,620 --> 00:27:17,230
The XML parser reads the
content of the file system, INI

480
00:27:17,230 --> 00:27:20,990
and then sends a request
to the attacker server

481
00:27:20,990 --> 00:27:22,427
to get the rest of the XML.

482
00:27:23,710 --> 00:27:26,220
The second entity, the lower one,

483
00:27:26,220 --> 00:27:28,600
is the response of the server.

484
00:27:28,600 --> 00:27:32,420
When the XML parser parses this response,

485
00:27:32,420 --> 00:27:35,830
it generates an additional
HTTP GET request

486
00:27:35,830 --> 00:27:38,383
with the content of the file system INI.

487
00:27:39,310 --> 00:27:42,340
This is according to the standard of XML.

488
00:27:42,340 --> 00:27:46,624
And in order to prevent this
feature in the XML parser,

489
00:27:46,624 --> 00:27:50,430
the DTD, which stands for
document type definition,

490
00:27:50,430 --> 00:27:52,390
must be disabled.

491
00:27:52,390 --> 00:27:55,590
Let's analyze the patches
and understand the root cause

492
00:27:55,590 --> 00:27:58,123
of these XXE vulnerabilities.

493
00:27:59,540 --> 00:28:04,540
The patch for CVE-2018-0878,
added four conditions

494
00:28:05,830 --> 00:28:10,830
to a function called LoadRATicket
in the MSRA executable.

495
00:28:11,690 --> 00:28:15,490
We know that the MSRA
executable is used for Windows

496
00:28:15,490 --> 00:28:18,590
or remote systems where a basic user

497
00:28:18,590 --> 00:28:22,080
can send an invitation
ticket to advanced user

498
00:28:22,080 --> 00:28:25,850
to log into his agent
and remotely assist him.

499
00:28:25,850 --> 00:28:28,853
This function probably
loads the invitation ticket.

500
00:28:31,320 --> 00:28:35,820
The LoadRATicket creates the
XML DOM document COM object

501
00:28:35,820 --> 00:28:39,593
and uses it to load and pass
the XML invitation file.

502
00:28:41,240 --> 00:28:43,770
In the patch version of this function,

503
00:28:43,770 --> 00:28:47,560
in order to disable the support
for external XML entities,

504
00:28:47,560 --> 00:28:49,430
four properties were added,

505
00:28:49,430 --> 00:28:54,430
first thing document, XS script,
externals and prohibitDTD.

506
00:28:54,450 --> 00:28:56,520
The rest, stay the same,

507
00:28:56,520 --> 00:28:59,800
calling put a sync and load functions.

508
00:28:59,800 --> 00:29:03,950
We also followed the Xref
to the user COM CLSIDs.

509
00:29:03,950 --> 00:29:05,733
We will get to it later.

510
00:29:07,720 --> 00:29:11,573
We wonder, either a
pattern for XXE patching,

511
00:29:12,600 --> 00:29:15,930
so we develop a feature
to search for all added

512
00:29:15,930 --> 00:29:19,413
prohibitDTD patches and
found 20 past patches.

513
00:29:20,270 --> 00:29:24,420
Let's verify the first
patch in the UPNP host.

514
00:29:24,420 --> 00:29:27,660
We can see that HR load documents

515
00:29:27,660 --> 00:29:31,400
now cause the restrict DOM documents.

516
00:29:31,400 --> 00:29:34,383
Let's see who also calls
this patch function.

517
00:29:35,930 --> 00:29:39,160
The ISAPI extension executable was patched

518
00:29:39,160 --> 00:29:44,160
by calling restrict DOM document
before a call to load XML.

519
00:29:44,210 --> 00:29:47,400
This is a different function
than the load function

520
00:29:47,400 --> 00:29:48,713
used by remote assistance.

521
00:29:49,670 --> 00:29:53,620
So there are probably
other vulnerable function

522
00:29:53,620 --> 00:29:56,520
used by the same COM object.

523
00:29:56,520 --> 00:29:59,670
Digging deeper, we found a
third vulnerable function,

524
00:29:59,670 --> 00:30:00,803
set XML.

525
00:30:02,790 --> 00:30:06,070
At this point, we
understood the root cause

526
00:30:06,070 --> 00:30:07,670
and define the conditions

527
00:30:07,670 --> 00:30:10,130
for exploiting the vulnerable code.

528
00:30:10,130 --> 00:30:12,163
Let's dig into the first condition.

529
00:30:14,180 --> 00:30:16,703
We develop a code to trigger COM object.

530
00:30:17,580 --> 00:30:20,160
First, we queried all CLSIDs

531
00:30:20,160 --> 00:30:22,580
from all the files in Windows 10.

532
00:30:22,580 --> 00:30:24,100
Then for each CLSID,

533
00:30:24,100 --> 00:30:27,510
we enumerated all functions and interfaces

534
00:30:27,510 --> 00:30:29,220
then we generated source code,

535
00:30:29,220 --> 00:30:32,060
which created each one of the COM objects.

536
00:30:32,060 --> 00:30:35,370
And finally, we called all these function

537
00:30:35,370 --> 00:30:38,173
with an XXE XML file as input.

538
00:30:40,660 --> 00:30:44,210
We automatically discovered
the vulnerable COM objects

539
00:30:44,210 --> 00:30:49,210
to the filtration data by adding
the vulnerable CLSID to it.

540
00:30:49,580 --> 00:30:52,580
As we can see, we found
four common interfaces

541
00:30:52,580 --> 00:30:54,263
and 16 vulnerable CLSIDs.

542
00:30:56,870 --> 00:31:00,790
We developed a new feature
to detect all the locations

543
00:31:00,790 --> 00:31:03,490
that seems to be vulnerable to XXE.

544
00:31:03,490 --> 00:31:06,590
This feature is different
from other feature,

545
00:31:06,590 --> 00:31:10,170
it does not compare between
unpatched and patched version.

546
00:31:10,170 --> 00:31:14,090
Instead, it searches for XXE condition

547
00:31:14,090 --> 00:31:16,113
in all Windows 10 executables.

548
00:31:17,750 --> 00:31:21,070
Eventually, we found 52 candidates,

549
00:31:21,070 --> 00:31:24,193
25 of them are marked
as possibly vulnerable.

550
00:31:25,050 --> 00:31:28,890
They will be vulnerable if
one last condition is met,

551
00:31:28,890 --> 00:31:33,010
if we are able to control
the input of the past XML.

552
00:31:33,010 --> 00:31:35,030
For example, we can see

553
00:31:35,030 --> 00:31:39,840
the MSRA patch function
LoadRATicket which is patched,

554
00:31:39,840 --> 00:31:41,440
while at the same time,

555
00:31:41,440 --> 00:31:44,600
the LoadandSOTARAInvitationsHistory
function

556
00:31:44,600 --> 00:31:46,640
might still be vulnerable.

557
00:31:46,640 --> 00:31:49,417
Let's see if we can control the input XML.

558
00:31:51,651 --> 00:31:55,410
At the bottom, we can see
the patched XML DOM object

559
00:31:55,410 --> 00:31:58,460
that was used in the
original vulnerability

560
00:31:58,460 --> 00:32:00,633
and was called from LoadRATicket.

561
00:32:02,170 --> 00:32:05,100
To our surprise, there
is a second instance

562
00:32:05,100 --> 00:32:09,330
of the exact same
vulnerability XML DOM object,

563
00:32:09,330 --> 00:32:14,330
just a few commands above
used by several functions,

564
00:32:14,390 --> 00:32:17,319
including our possibly vulnerable function

565
00:32:17,319 --> 00:32:19,986
LoadandSOTARAInvitationsHistory.

566
00:32:22,361 --> 00:32:25,160
LoadandSOTARAInvitationsHistory, indeed,

567
00:32:25,160 --> 00:32:27,780
uses the vulnerable load function.

568
00:32:27,780 --> 00:32:30,000
We can see that the file to be loaded

569
00:32:30,000 --> 00:32:31,523
is the parameter A2.

570
00:32:34,371 --> 00:32:37,110
The GetInvitationManagerLoaded function

571
00:32:37,110 --> 00:32:41,060
calls our vulnerable
function with the XML file

572
00:32:41,060 --> 00:32:43,600
RA contact history from UB data.

573
00:32:43,600 --> 00:32:45,820
This file is controlled by the user

574
00:32:45,820 --> 00:32:48,143
with no need for admin privileges.

575
00:32:50,890 --> 00:32:52,970
This is the history data read

576
00:32:52,970 --> 00:32:56,600
from a legitimate RA
contact history XML file

577
00:32:56,600 --> 00:33:00,560
that we changed to
contain the address, 1111

578
00:33:00,560 --> 00:33:04,450
as the previous IP
requested remote assistance.

579
00:33:04,450 --> 00:33:07,253
Now we know how to
trigger the vulnerability.

580
00:33:09,210 --> 00:33:11,490
So let's begin with the fun stuff.

581
00:33:11,490 --> 00:33:14,460
On the bottom left, we see the MSRA

582
00:33:14,460 --> 00:33:17,763
that was run with offer RA as a parameter.

583
00:33:18,730 --> 00:33:21,440
It can be reached also
with double-click on MSRA.

584
00:33:22,310 --> 00:33:27,310
In Pokemon, you can see the
reduction of the RA export

585
00:33:28,020 --> 00:33:31,780
is the refile and it's also it's content,

586
00:33:31,780 --> 00:33:33,573
which includes the exploit code.

587
00:33:34,810 --> 00:33:38,500
On the right, we can say
the first DTD GetRequest

588
00:33:38,500 --> 00:33:42,260
for XXE XML, which reads remote file

589
00:33:42,260 --> 00:33:44,110
from the Windows 10 machine

590
00:33:44,110 --> 00:33:46,960
and ex filtrate it to the C2 server

591
00:33:46,960 --> 00:33:49,170
using a second GetRequest.

592
00:33:52,310 --> 00:33:56,140
Microsoft fixes this MSRA
vulnerability we found

593
00:33:56,140 --> 00:34:00,143
and assign it the ID, CVE-2021-34507.

594
00:34:02,020 --> 00:34:05,330
In total, we discovered
six vulnerabilities.

595
00:34:05,330 --> 00:34:07,840
All were reported to Microsoft.

596
00:34:07,840 --> 00:34:10,293
We will go over them one by one.

597
00:34:12,300 --> 00:34:15,330
The most critical vulnerability we found

598
00:34:15,330 --> 00:34:17,940
was the vulnerability in the Windows Help.

599
00:34:17,940 --> 00:34:21,550
We sent a spear phishing mail
with a compressed attachment

600
00:34:21,550 --> 00:34:23,290
of an HTML file.

601
00:34:23,290 --> 00:34:27,950
We named the HTML file
to include .chn twice.

602
00:34:27,950 --> 00:34:32,920
This forced the vulnerable
process HH executable to pass it,

603
00:34:32,920 --> 00:34:36,093
although it's plain
HTML and not a CHM file.

604
00:34:36,940 --> 00:34:40,610
We can choose almost any
extension to this file

605
00:34:40,610 --> 00:34:42,653
and it will still be passed.

606
00:34:43,860 --> 00:34:46,160
We tested the attack on default

607
00:34:46,160 --> 00:34:48,460
fully-patched Windows 10 machine

608
00:34:48,460 --> 00:34:51,900
and got blocked by the
mark of the web mechanism.

609
00:34:51,900 --> 00:34:54,000
But when we compress the attachment,

610
00:34:54,000 --> 00:34:55,560
even without encryption,

611
00:34:55,560 --> 00:34:58,823
it bypassed the sandbox and
ex filtration was successful.

612
00:35:00,890 --> 00:35:03,800
The third liability we found in MMC,

613
00:35:03,800 --> 00:35:06,540
include several snappings.

614
00:35:06,540 --> 00:35:11,020
The link to a web address
snapping, expects an HTML file,

615
00:35:11,020 --> 00:35:15,940
but if we will provide an
XXE XML exploit instead,

616
00:35:15,940 --> 00:35:18,853
it will be passed by MSHTML. DLL.

617
00:35:19,690 --> 00:35:22,180
We can see on the top right

618
00:35:22,180 --> 00:35:24,490
that it will read the remote file

619
00:35:24,490 --> 00:35:26,733
and actually fight it to the C2 server.

620
00:35:27,890 --> 00:35:29,880
It will provide an error message

621
00:35:29,880 --> 00:35:33,163
which includes the content
of the ex filtrated file.

622
00:35:35,480 --> 00:35:37,780
To trigger the Windows
Media Player remote file

623
00:35:37,780 --> 00:35:41,230
read vulnerability, you
will only need to open

624
00:35:41,230 --> 00:35:44,220
the option screen and
select the network top.

625
00:35:44,220 --> 00:35:48,140
This will trigger vulnerable
parsing of the XML file,

626
00:35:48,140 --> 00:35:49,453
which we can control.

627
00:35:50,290 --> 00:35:53,300
On the right, you can see the structures.

628
00:35:53,300 --> 00:35:55,180
Please pay attention to the calling

629
00:35:55,180 --> 00:35:59,840
of the vulnerable load
function from MSXML3 DLL.

630
00:35:59,840 --> 00:36:01,053
Moving over to Eran.

631
00:36:02,320 --> 00:36:07,170
- In addition to finding
vulnerabilities in native code,

632
00:36:07,170 --> 00:36:10,780
we want them to discover
0-days in managed code.

633
00:36:10,780 --> 00:36:13,400
So we added a feature that compiles

634
00:36:13,400 --> 00:36:17,353
all .Net executables in
windows 10 using ILSpy.

635
00:36:19,100 --> 00:36:22,250
ILSpy de-compiles each executable

636
00:36:22,250 --> 00:36:25,880
to a visual studio
solution with Cshop files.

637
00:36:25,880 --> 00:36:29,600
The files look very
similar to the XL code,

638
00:36:29,600 --> 00:36:32,743
even the parameter names
and function names are kept.

639
00:36:34,360 --> 00:36:37,210
We sell inside all the .Net files

640
00:36:37,210 --> 00:36:39,350
for non-classes and functions

641
00:36:39,350 --> 00:36:44,070
that are vulnerable or
configured to use DTD.

642
00:36:44,070 --> 00:36:48,247
All the XML parses with
DTD processing enabled,

643
00:36:48,247 --> 00:36:51,743
are vulnerable to XXE,
such as XMLTextReader.

644
00:36:54,510 --> 00:36:56,970
We found two XXE vulnerabilities

645
00:36:56,970 --> 00:36:58,773
in official Windows SDK executables.

646
00:37:00,020 --> 00:37:03,030
We found vulnerabilities in XXD,

647
00:37:03,030 --> 00:37:05,540
the utility to generate disclaimer

648
00:37:05,540 --> 00:37:09,390
or a class from a given source

649
00:37:09,390 --> 00:37:13,900
and another in XSLTC.

650
00:37:13,900 --> 00:37:17,490
In order to exploit a
vulnerability in XXD,

651
00:37:17,490 --> 00:37:22,280
it is required to execute
it with a path to XML file,

652
00:37:22,280 --> 00:37:23,763
which contains the XXE.

653
00:37:25,190 --> 00:37:30,190
Unlike XSD, XSLTC requires
multiple parameter

654
00:37:30,370 --> 00:37:33,713
so it is a little bit
more complex to trigger.

655
00:37:35,420 --> 00:37:37,710
In addition to the
vulnerabilities we found,

656
00:37:37,710 --> 00:37:41,303
we found two XXE past
exploitation techniques.

657
00:37:42,450 --> 00:37:46,870
We can use them to ex
filtrate text files using DLL

658
00:37:46,870 --> 00:37:49,280
signed by Microsoft instead of using

659
00:37:49,280 --> 00:37:51,233
suspicious network APIs.

660
00:37:52,740 --> 00:37:56,733
This increases the odds for
bypassing security controls.

661
00:37:58,160 --> 00:38:00,960
The first one is P2P,
PeerGroupParseInvitation.

662
00:38:02,550 --> 00:38:06,050
It is documented function found in MSDN

663
00:38:06,050 --> 00:38:08,200
and the root cause of the XXE

664
00:38:08,200 --> 00:38:12,303
found in internal function
named unwrap XML invitation.

665
00:38:13,690 --> 00:38:16,240
We traced back to find which function

666
00:38:16,240 --> 00:38:20,410
it is called from, using our call graph.

667
00:38:20,410 --> 00:38:22,920
We found multiple options,

668
00:38:22,920 --> 00:38:26,170
but we could not find any attack vector

669
00:38:26,170 --> 00:38:28,060
that can trigger these functions

670
00:38:28,060 --> 00:38:30,593
without calling one of them ourself.

671
00:38:31,650 --> 00:38:34,100
The second past exploitation technique

672
00:38:34,100 --> 00:38:38,303
is found in set XML in PLA DLL.

673
00:38:39,210 --> 00:38:41,210
In order to trigger that function,

674
00:38:41,210 --> 00:38:45,240
we used one of the
examples provided by MSDN,

675
00:38:45,240 --> 00:38:48,113
so we had to change only
a few lines of code.

676
00:38:50,500 --> 00:38:55,500
In June, 2020, Microsoft
released a fix to CVE-2020-1300.

677
00:38:58,660 --> 00:39:01,123
It is a directory of XL vulnerability.

678
00:39:01,990 --> 00:39:05,300
You can see that they declared to fix it

679
00:39:05,300 --> 00:39:08,903
on Windows 8 among other Windows versions.

680
00:39:10,140 --> 00:39:12,460
Based on our correlation capability

681
00:39:12,460 --> 00:39:15,893
between the CVE report and
the relevant patch files,

682
00:39:16,860 --> 00:39:20,630
we understood that the patch
provided partial coverage

683
00:39:20,630 --> 00:39:21,803
so we dug deeper.

684
00:39:23,470 --> 00:39:26,210
Using our directorate of our XL feature,

685
00:39:26,210 --> 00:39:29,510
we searched for any
function with ../ or ..\

686
00:39:30,860 --> 00:39:32,450
as an argument.

687
00:39:32,450 --> 00:39:34,840
We found that on June, 2020,

688
00:39:34,840 --> 00:39:37,750
Microsoft indeed patched two files,

689
00:39:37,750 --> 00:39:41,270
localspl and win32spl

690
00:39:41,270 --> 00:39:44,680
but the patch to the PrintBRM engine

691
00:39:44,680 --> 00:39:47,410
was done only in August.

692
00:39:47,410 --> 00:39:50,550
We compared the pitch to
the paths of Windows 10

693
00:39:51,550 --> 00:39:54,180
and found that on Windows 10,

694
00:39:54,180 --> 00:39:57,810
all three files were patched in June.

695
00:39:57,810 --> 00:40:00,610
Does it means that
Windows 8 was vulnerable

696
00:40:00,610 --> 00:40:02,913
to a 1-day for two months?

697
00:40:04,720 --> 00:40:09,720
The PrintBRM engine executable
was patched only in August

698
00:40:09,850 --> 00:40:14,220
and with the same patch logic
used in Windows 10 in June

699
00:40:14,220 --> 00:40:19,220
and in two WCSDR function
for mitigating ../ attacks.

700
00:40:20,840 --> 00:40:24,643
The PrintBRM engine was
not patched in June, 2020.

701
00:40:26,840 --> 00:40:30,720
We verified that in Windows 8, in June,

702
00:40:30,720 --> 00:40:35,720
it was vulnerable to 1-day
attack of CVE-2020-1300.

703
00:40:36,480 --> 00:40:40,830
The PrintBRM engine allows
importing of a CAB file.

704
00:40:40,830 --> 00:40:43,730
If the CAB file contains a file name

705
00:40:43,730 --> 00:40:46,150
that contains ../charles,

706
00:40:46,150 --> 00:40:51,150
it will extract the file to an
attacker-controlled location,

707
00:40:51,310 --> 00:40:53,700
such as System32 wbem,

708
00:40:53,700 --> 00:40:55,853
which is prone to DLL hijacking.

709
00:40:59,010 --> 00:41:02,550
We proved that it was possible to have RCE

710
00:41:02,550 --> 00:41:04,580
on fully patched Windows 8

711
00:41:04,580 --> 00:41:08,713
between June and August, 2020 with 1-day.

712
00:41:09,670 --> 00:41:14,670
We also found an additional
unpatched issue in 2020.

713
00:41:14,750 --> 00:41:17,240
This time the vulnerability provided

714
00:41:17,240 --> 00:41:19,480
arbiter delete capabilities.

715
00:41:19,480 --> 00:41:22,360
Normal search is needed
in order to determine

716
00:41:22,360 --> 00:41:24,850
whether this is a new opportunity

717
00:41:24,850 --> 00:41:27,170
for finding low-hanging force

718
00:41:27,170 --> 00:41:28,713
or just a coincidence.

719
00:41:30,380 --> 00:41:32,320
Microsoft response.

720
00:41:32,320 --> 00:41:34,630
Regarding the MSI vulnerability,

721
00:41:34,630 --> 00:41:39,360
the bug was fixed as part
of July Patch Tuesday.

722
00:41:39,360 --> 00:41:41,500
Regarding the other vulnerabilities,

723
00:41:41,500 --> 00:41:43,350
no fix is currently planned

724
00:41:43,350 --> 00:41:46,123
since they don't meet
Microsoft service bottom.

725
00:41:47,690 --> 00:41:51,300
We are encouraging you all
to use and expand our tools

726
00:41:51,300 --> 00:41:53,280
that will be published today.

727
00:41:53,280 --> 00:41:55,920
We think that the vulnerabilities we found

728
00:41:55,920 --> 00:41:57,893
are just the tip of the iceberg.

729
00:41:59,200 --> 00:42:02,320
We would like to credit
multiple researchers.

730
00:42:02,320 --> 00:42:06,810
We based our research on top
of their previous results.

731
00:42:06,810 --> 00:42:10,563
Thanks for joining, moving
on to the Q&A session.

