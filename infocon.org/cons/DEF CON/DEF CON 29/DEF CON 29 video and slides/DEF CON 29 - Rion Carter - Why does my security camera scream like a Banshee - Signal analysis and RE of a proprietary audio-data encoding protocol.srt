1
00:00:03,610 --> 00:00:05,610
- Hi, my name's Rion Carter,

2
00:00:05,610 --> 00:00:06,780
and today I'll be presenting

3
00:00:06,780 --> 00:00:10,240
on why my security camera
screams like a banshee.

4
00:00:10,240 --> 00:00:13,530
The talking on signal analysis
and reverse engineering

5
00:00:13,530 --> 00:00:15,130
of an audio and coding protocol.

6
00:00:16,150 --> 00:00:17,160
A little bit about myself,

7
00:00:17,160 --> 00:00:19,970
I'm a software developer,
a security engineer.

8
00:00:19,970 --> 00:00:24,023
I love to code, love to
automate, love to solve problems.

9
00:00:24,023 --> 00:00:26,320
I like to employ the hacker mindset.

10
00:00:26,320 --> 00:00:30,250
Like to break things in
cool and unexpected ways

11
00:00:30,250 --> 00:00:31,440
to learn more about the system

12
00:00:31,440 --> 00:00:33,360
and hopefully drive an improvement

13
00:00:33,360 --> 00:00:35,430
that makes it better for everybody.

14
00:00:35,430 --> 00:00:36,725
I love food.

15
00:00:36,725 --> 00:00:39,220
Love cooking, love baking.

16
00:00:39,220 --> 00:00:40,970
Recipe hacking is a passion of mine,

17
00:00:40,970 --> 00:00:43,050
and when I can get a delicious result,

18
00:00:43,050 --> 00:00:45,530
that really makes my day.

19
00:00:45,530 --> 00:00:48,150
And then of course the standard
disclaimer applies here.

20
00:00:48,150 --> 00:00:49,760
All opinions are my own.

21
00:00:49,760 --> 00:00:53,354
Don't reflect positions or
thoughts of anybody else

22
00:00:53,354 --> 00:00:55,890
or any current or previous employers.

23
00:00:55,890 --> 00:00:57,883
So, let's get to it.

24
00:00:58,880 --> 00:01:02,010
Got a few different sections to cover.

25
00:01:02,010 --> 00:01:03,570
We're going to touch on what it is

26
00:01:03,570 --> 00:01:05,660
that we're actually doing here.

27
00:01:05,660 --> 00:01:08,660
The signal analysis piece,
application analysis,

28
00:01:08,660 --> 00:01:11,690
hacking the signal, and, if all goes well,

29
00:01:11,690 --> 00:01:13,203
we'll get to a demo.

30
00:01:14,170 --> 00:01:16,590
So, what are we doing here?

31
00:01:16,590 --> 00:01:20,483
And why are we talking about
wireless security cameras?

32
00:01:21,420 --> 00:01:25,490
So, my original goal,
before I even had the idea

33
00:01:25,490 --> 00:01:28,710
to submit a Defcon talk was to use

34
00:01:28,710 --> 00:01:32,042
an inexpensive wireless
camera to monitor my garden.

35
00:01:32,042 --> 00:01:35,633
And this is the inexpensive
camera I selected.

36
00:01:36,500 --> 00:01:39,611
It's got an antenna
suitable for outdoor use.

37
00:01:39,611 --> 00:01:42,570
This one's kind of interesting
in that it has a microphone

38
00:01:42,570 --> 00:01:45,860
and a speaker, so you could
have two-way communication

39
00:01:45,860 --> 00:01:47,900
if you wanted it.

40
00:01:47,900 --> 00:01:50,240
The nice thing about this
is that it was cheap.

41
00:01:50,240 --> 00:01:52,913
So, and it seemed like
it would do the job.

42
00:01:53,830 --> 00:01:56,290
This sounds fairly easy
and straight forward,

43
00:01:56,290 --> 00:01:58,820
so what's the catch here?

44
00:01:58,820 --> 00:02:01,460
I discovered after purchasing the camera,

45
00:02:01,460 --> 00:02:04,653
unboxing it and examining
it, that it requires

46
00:02:04,653 --> 00:02:09,653
a cloud application in order
to enable and pair the camera.

47
00:02:11,402 --> 00:02:14,960
There's no way to self set up the camera.

48
00:02:14,960 --> 00:02:17,970
There's no ad hoc wireless network.

49
00:02:17,970 --> 00:02:21,020
It doesn't show up with
a Bluetooth connection.

50
00:02:21,020 --> 00:02:22,931
There's, when you plug in the USB cable,

51
00:02:22,931 --> 00:02:25,407
there's no signals there whatsoever.

52
00:02:25,407 --> 00:02:28,715
Also, there's no documentation
online about this camera

53
00:02:28,715 --> 00:02:31,280
to any real technical depth.

54
00:02:31,280 --> 00:02:34,270
Not that I was expecting
much from a $30 camera.

55
00:02:34,270 --> 00:02:38,170
And then of course, what
brings us here today

56
00:02:38,170 --> 00:02:41,302
is the bespoke protocol that it uses to,

57
00:02:41,302 --> 00:02:44,780
well that the vendor
application uses to communicate

58
00:02:44,780 --> 00:02:47,623
and configure the wireless camera.

59
00:02:48,630 --> 00:02:51,830
So take a listen to this.

60
00:02:51,830 --> 00:02:55,480
This is what really peaked
my interest and sent me down

61
00:02:55,480 --> 00:02:58,543
the path of trying to do
a Defcon presentation.

62
00:03:00,072 --> 00:03:02,989
(electronic noise)

63
00:03:10,990 --> 00:03:15,990
So that's the sound that
this vendor application makes

64
00:03:16,203 --> 00:03:19,580
to interface with the camera and configure

65
00:03:19,580 --> 00:03:22,923
it to connect to a wireless network.

66
00:03:24,490 --> 00:03:26,500
I have to say I was not expecting that.

67
00:03:26,500 --> 00:03:30,779
That's not usually how
you configure things

68
00:03:30,779 --> 00:03:32,890
like security cameras.

69
00:03:32,890 --> 00:03:37,700
So, my new goal after
finding out that it uses

70
00:03:37,700 --> 00:03:41,290
a sound wave signal to
configure the camera,

71
00:03:41,290 --> 00:03:44,480
was to find out what was
going on in the camera set up,

72
00:03:44,480 --> 00:03:47,280
and see if I can't hack
on it and replicate it,

73
00:03:47,280 --> 00:03:50,490
and if possible, cast off the shackles

74
00:03:50,490 --> 00:03:53,790
of the proprietary cloud enabled app

75
00:03:55,290 --> 00:03:57,220
that the vendor supplies.

76
00:03:57,220 --> 00:03:59,570
So, let's investigate.

77
00:03:59,570 --> 00:04:02,000
First thing you want to
investigate is the hardware.

78
00:04:02,000 --> 00:04:06,830
And as I mentioned before,
it does have a USB cable.

79
00:04:06,830 --> 00:04:09,550
This connector though only supplies power.

80
00:04:09,550 --> 00:04:10,680
When I trace the leads,

81
00:04:10,680 --> 00:04:13,343
there's no activity on the data pins.

82
00:04:14,295 --> 00:04:18,410
Other investigative angles, of
course, check for Bluetooth,

83
00:04:18,410 --> 00:04:20,403
check for ad hoc wifi.

84
00:04:21,400 --> 00:04:26,390
And unfortunately, after many
hours of trying all sorts

85
00:04:26,390 --> 00:04:29,020
of different permutations of things,

86
00:04:29,020 --> 00:04:32,110
pressing the reset button,
holding the reset button,

87
00:04:32,110 --> 00:04:34,610
scanning with wireless
scanners, et cetera.

88
00:04:34,610 --> 00:04:36,900
Nothing was advertising.

89
00:04:36,900 --> 00:04:41,800
So that left me to
investigate the software

90
00:04:41,800 --> 00:04:44,060
in a little bit more detail.

91
00:04:44,060 --> 00:04:47,830
This is the vendor application
that comes with the camera.

92
00:04:47,830 --> 00:04:49,493
It's called JAWA.

93
00:04:50,720 --> 00:04:53,013
And it's used to configure
the cloud camera.

94
00:04:54,320 --> 00:04:58,030
However, like I mentioned
before, I wasn't really a fan

95
00:04:58,030 --> 00:05:01,940
of having to use this proprietary
cloud locked application.

96
00:05:01,940 --> 00:05:04,530
JAWA requires an internet connection.

97
00:05:04,530 --> 00:05:07,860
It also requires a username
and password to be configured

98
00:05:07,860 --> 00:05:11,800
with this cloud set up.

99
00:05:11,800 --> 00:05:14,212
So that made me a little frustrated,

100
00:05:14,212 --> 00:05:17,783
and incentivized me to
poke around some more.

101
00:05:18,970 --> 00:05:22,410
Now, in order to analyze
the vendor application,

102
00:05:22,410 --> 00:05:25,080
I needed a test device.

103
00:05:25,080 --> 00:05:27,359
I didn't want to run
this on my primary phone

104
00:05:27,359 --> 00:05:30,970
just being a security
paranoid person that I am.

105
00:05:30,970 --> 00:05:35,380
I don't really have a trust
for applications that come

106
00:05:35,380 --> 00:05:37,560
from from dubious sources,
like the manufacturer

107
00:05:37,560 --> 00:05:40,093
of a $30 cloud enabled camera.

108
00:05:41,760 --> 00:05:45,810
And as I searched online
for information either

109
00:05:45,810 --> 00:05:48,371
about the camera or the application,

110
00:05:48,371 --> 00:05:50,530
probably not too surprised to hear

111
00:05:50,530 --> 00:05:55,240
that there wasn't very many,
if any results that were found.

112
00:05:55,240 --> 00:05:57,820
I did uncover a few other
camera models that seemed

113
00:05:57,820 --> 00:06:01,730
to use the sound audio
wave signal approach

114
00:06:01,730 --> 00:06:04,850
to configure the camera for Wi-Fi network.

115
00:06:04,850 --> 00:06:06,430
I don't have any of those though,

116
00:06:06,430 --> 00:06:11,430
and I just more list them
here as an interesting aside.

117
00:06:11,700 --> 00:06:14,390
There are some cheap cameras
though which leverage,

118
00:06:14,390 --> 00:06:18,420
in my opinion, a far
superior approach to pairing

119
00:06:18,420 --> 00:06:19,467
the camera to a wireless network.

120
00:06:19,467 --> 00:06:23,008
And that's having the app show a QR code

121
00:06:23,008 --> 00:06:26,910
that you then scan with the camera.

122
00:06:26,910 --> 00:06:28,939
I mean the camera has, well a camera,

123
00:06:28,939 --> 00:06:32,650
and scanning a QR code is a
fairly straightforward thing

124
00:06:34,839 --> 00:06:36,170
to do in 2021.

125
00:06:36,170 --> 00:06:40,804
So I doubt, or I should say,
I wonder if there'll be many,

126
00:06:40,804 --> 00:06:42,990
if any, more cameras out there,

127
00:06:42,990 --> 00:06:46,973
which leverage this audio coded approach.

128
00:06:47,810 --> 00:06:50,900
So, now that we've taken a
quick pass at the hardware

129
00:06:50,900 --> 00:06:54,170
and the software, let's
think about this signal

130
00:06:54,170 --> 00:06:55,250
a little bit more.

131
00:06:55,250 --> 00:06:59,363
See what we can identify and figure out.

132
00:07:01,930 --> 00:07:05,530
And along the way, let's think
about what are some things

133
00:07:05,530 --> 00:07:07,290
that we can think about

134
00:07:07,290 --> 00:07:10,700
or look for as we analyze the signal.

135
00:07:10,700 --> 00:07:12,410
Of course, the first thing is we'll want

136
00:07:12,410 --> 00:07:14,890
to capture and visualize the signal.

137
00:07:14,890 --> 00:07:17,510
We'll be looking for
things like repetition,

138
00:07:17,510 --> 00:07:20,130
the variation in replay.

139
00:07:20,130 --> 00:07:23,740
And if possible, we'll
try to fuzz and simulate

140
00:07:23,740 --> 00:07:27,140
the signal in a way
that can hopefully track

141
00:07:27,140 --> 00:07:29,513
with a valid coding.

142
00:07:31,210 --> 00:07:36,210
This is the raw view of the
signal as captured by Audacity,

143
00:07:38,390 --> 00:07:42,573
and visualized in the spectrographic view.

144
00:07:42,573 --> 00:07:44,230
Just taking a quick look at this.

145
00:07:44,230 --> 00:07:48,253
It's pretty clear that
there are distinct tones,

146
00:07:48,253 --> 00:07:51,300
and there appears to be steps.

147
00:07:51,300 --> 00:07:55,160
This isn't a continuous wave
form that gets transmitted.

148
00:07:55,160 --> 00:07:59,090
There's individual tones,
which are given certain slices

149
00:07:59,090 --> 00:08:01,737
of time, that are transmitted
for a certain amount of time,

150
00:08:01,737 --> 00:08:04,930
and then other tones
are played after that.

151
00:08:04,930 --> 00:08:07,820
Taking a look, it seems
like a lot of the signals

152
00:08:07,820 --> 00:08:10,601
are centering at least
here around 3,500 Hertz

153
00:08:10,601 --> 00:08:15,601
with a few outliers on the low
end of the frequency range,

154
00:08:15,610 --> 00:08:18,220
and the high end as well.

155
00:08:18,220 --> 00:08:21,088
So that is something worth noting

156
00:08:21,088 --> 00:08:23,703
as we go about analyzing the signal.

157
00:08:25,190 --> 00:08:27,533
Now, let's see.

158
00:08:29,040 --> 00:08:34,040
One thing that I thought as I
was looking at the signal is,

159
00:08:34,250 --> 00:08:37,830
is this similar to a modem signal?

160
00:08:37,830 --> 00:08:42,155
It's been an awful long time
since I've heard a modem,

161
00:08:42,155 --> 00:08:47,155
and obviously modems encode their,

162
00:08:47,268 --> 00:08:50,030
transmit information
using an audio signal.

163
00:08:50,030 --> 00:08:54,950
So I did a quick comparison
against a recording

164
00:08:54,950 --> 00:08:59,950
of 56K dial-up modem
establishing a connection.

165
00:09:00,490 --> 00:09:03,950
And just by looking at these wave forms,

166
00:09:03,950 --> 00:09:08,950
it's pretty apparent that
it's not a 56K modem.

167
00:09:09,710 --> 00:09:12,870
The spectrographs are
substantially different.

168
00:09:12,870 --> 00:09:16,470
And this protocol, this audio
protocol that they're using

169
00:09:16,470 --> 00:09:20,630
to configure the camera
it's bespoke in the sense

170
00:09:20,630 --> 00:09:23,800
that you can't find
information about it easily,

171
00:09:23,800 --> 00:09:27,350
and it doesn't track with
other common audio protocols

172
00:09:27,350 --> 00:09:29,593
that you might think of like modem or fax.

173
00:09:30,800 --> 00:09:34,663
So, looking a little closer
at this with our eyes.

174
00:09:36,845 --> 00:09:39,750
I marked out a few sections
that appeared interesting,

175
00:09:39,750 --> 00:09:43,201
just really highlighting
the signals that appear

176
00:09:43,201 --> 00:09:47,140
that are extraneous, or
that don't really track

177
00:09:47,140 --> 00:09:50,120
with what the rest of the signal offers.

178
00:09:50,120 --> 00:09:53,714
And on the left of this slide here,

179
00:09:53,714 --> 00:09:56,340
I put together, I guess what I'm calling

180
00:09:56,340 --> 00:09:58,970
a collapsed spectrograph view,

181
00:09:58,970 --> 00:10:01,090
where I basically took all of the tones

182
00:10:01,090 --> 00:10:05,140
and I slid them all over to my left,

183
00:10:05,140 --> 00:10:07,880
and just lined them up to see which tones

184
00:10:07,880 --> 00:10:10,180
and frequencies were represented.

185
00:10:10,180 --> 00:10:14,340
And you can see that it does
center around 3,500 Hertz.

186
00:10:14,340 --> 00:10:18,070
There's a small gap above 4,000 Hertz.

187
00:10:18,070 --> 00:10:20,659
And then there appeared to be
some things at the higher end,

188
00:10:20,659 --> 00:10:23,253
at the higher register range.

189
00:10:24,300 --> 00:10:29,180
Now, a picture is nice,
and it helps us understand

190
00:10:29,180 --> 00:10:31,894
maybe how the signal is structured.

191
00:10:31,894 --> 00:10:34,410
But a picture can only take us so far.

192
00:10:34,410 --> 00:10:36,932
We'd like to get more
precise and better understand

193
00:10:36,932 --> 00:10:40,243
what is actually encoded in this signal,

194
00:10:43,544 --> 00:10:46,900
and kind of what the protocol
is for actually encoding data

195
00:10:46,900 --> 00:10:47,793
into the signal.

196
00:10:49,440 --> 00:10:53,030
With a manual approach,
we can keep using a tool

197
00:10:53,030 --> 00:10:56,340
such as Audacity or
other audio editing tools

198
00:10:56,340 --> 00:10:57,670
that are out there.

199
00:10:57,670 --> 00:10:59,970
With Audacity, though, you can use

200
00:10:59,970 --> 00:11:02,840
this functionality called labeling.

201
00:11:02,840 --> 00:11:05,310
You position the cursor over each one

202
00:11:05,310 --> 00:11:10,310
of those sections where there
appears to be a distinct tone.

203
00:11:10,660 --> 00:11:13,606
You press Control + B and
it will cause Audacity

204
00:11:13,606 --> 00:11:17,848
to label that time slice,
and mark the frequency

205
00:11:17,848 --> 00:11:21,830
that's detected at that point in time.

206
00:11:21,830 --> 00:11:24,980
And so you can see just in the
signal in this picture here,

207
00:11:24,980 --> 00:11:26,740
it might be a little smaller.

208
00:11:26,740 --> 00:11:29,150
A little hard to see, but
I've got a bunch of labels

209
00:11:29,150 --> 00:11:30,883
on each one of these tones.

210
00:11:31,857 --> 00:11:36,199
This next view here is the
Audacity view where you can view

211
00:11:36,199 --> 00:11:40,370
the labels that you've taken.

212
00:11:40,370 --> 00:11:42,830
You can go to edit labels, edit labels,

213
00:11:42,830 --> 00:11:46,670
and you can export them to a text file,

214
00:11:46,670 --> 00:11:48,290
which you could run
through some other type

215
00:11:48,290 --> 00:11:51,610
of automated analysis, or
plug it into a spreadsheet,

216
00:11:51,610 --> 00:11:53,660
or what have you.

217
00:11:53,660 --> 00:11:55,660
Let's take a little closer look at this.

218
00:11:58,370 --> 00:12:02,460
And you can see that
Audacity is mapping a low

219
00:12:02,460 --> 00:12:06,820
and a high frequency that it
detects at that time slice.

220
00:12:06,820 --> 00:12:09,770
These frequencies are a little variable.

221
00:12:09,770 --> 00:12:13,458
So to me it looks like this
puts us in the ballpark

222
00:12:13,458 --> 00:12:17,310
for what each of the target tones are.

223
00:12:17,310 --> 00:12:20,470
I don't imagine the vendor application

224
00:12:20,470 --> 00:12:23,870
is really putting out 5,101.89 Hertz.

225
00:12:23,870 --> 00:12:27,238
It's probably something a bit more round.

226
00:12:27,238 --> 00:12:30,200
We'll figure out more
about that as we go along

227
00:12:30,200 --> 00:12:31,283
in this process.

228
00:12:33,081 --> 00:12:37,960
What do we know now from doing
our quick manual analysis?

229
00:12:37,960 --> 00:12:42,960
We can see that there
is encoding going on.

230
00:12:43,194 --> 00:12:45,990
There's a digitized signal.

231
00:12:45,990 --> 00:12:47,670
But the signal isn't binary,

232
00:12:47,670 --> 00:12:50,920
it's not like it's just
two tones, one and zero.

233
00:12:50,920 --> 00:12:54,660
There's a range of
frequencies represented here.

234
00:12:54,660 --> 00:12:57,363
So there's some type of
digital encoding going on.

235
00:12:58,310 --> 00:13:00,420
The frequencies seem to
be centered in the three

236
00:13:00,420 --> 00:13:02,680
to five kilohertz range.

237
00:13:02,680 --> 00:13:05,520
And my suspicion is that the signals

238
00:13:05,520 --> 00:13:07,830
that are outliers at the top of bottom

239
00:13:07,830 --> 00:13:10,766
are control signals, and that
they warrant a closer look

240
00:13:10,766 --> 00:13:15,400
for investigating how the
signal is put together.

241
00:13:15,400 --> 00:13:17,140
And we see that there's repetition.

242
00:13:17,140 --> 00:13:20,614
I noticed that in my analysis
of the vendor application

243
00:13:20,614 --> 00:13:24,230
and the pairing tones that it produces.

244
00:13:24,230 --> 00:13:28,100
The complete sequence repeats
itself multiple times,

245
00:13:28,100 --> 00:13:29,890
at least three times.

246
00:13:29,890 --> 00:13:30,920
So, and then finally,

247
00:13:30,920 --> 00:13:35,490
we can see that this is not
a 56K modem or fax signal.

248
00:13:35,490 --> 00:13:37,963
The spectral analysis just do not match.

249
00:13:39,870 --> 00:13:43,860
So at this point, we
have to ask ourselves,

250
00:13:43,860 --> 00:13:47,563
is there really much further
that we can go in manual mode?

251
00:13:49,130 --> 00:13:52,940
And the answer there is yes,
but with a set of caveats.

252
00:13:52,940 --> 00:13:56,660
There's variability whenever
you play back the audio signal.

253
00:13:56,660 --> 00:13:58,860
I found that each time I played back,

254
00:13:58,860 --> 00:14:01,960
even the same signal from
the vendor application,

255
00:14:01,960 --> 00:14:05,755
that Audacity would slightly vary,

256
00:14:05,755 --> 00:14:08,270
that the Audacity analysis
would slightly vary in terms

257
00:14:08,270 --> 00:14:09,880
of which frequencies

258
00:14:09,880 --> 00:14:12,790
it shows when you do the labeling process.

259
00:14:12,790 --> 00:14:14,950
And of course, manually
going through the process

260
00:14:14,950 --> 00:14:17,600
of playing a signal from an application,

261
00:14:17,600 --> 00:14:20,360
recording it into an audio editor,

262
00:14:20,360 --> 00:14:22,350
and doing that over and over again.

263
00:14:22,350 --> 00:14:23,650
It's very time consuming.

264
00:14:23,650 --> 00:14:27,790
Since again, the app repeats
the same signal multiple times.

265
00:14:27,790 --> 00:14:30,450
So even after you get a
complete signal captured,

266
00:14:30,450 --> 00:14:32,950
you have to wait for the
app to finish its full cycle

267
00:14:32,950 --> 00:14:36,960
before you can kick off
another test permutation.

268
00:14:36,960 --> 00:14:38,360
And, just to be clear,

269
00:14:38,360 --> 00:14:39,750
the only options we have to configure

270
00:14:39,750 --> 00:14:44,620
in this vendor application are
the SSID and the passphrase

271
00:14:44,620 --> 00:14:46,160
for the wireless network.

272
00:14:46,160 --> 00:14:47,910
So there's not a whole lot of things

273
00:14:47,910 --> 00:14:50,163
that you can vary for the input.

274
00:14:51,100 --> 00:14:52,860
Then, one thing I noticed

275
00:14:52,860 --> 00:14:54,922
is that there's no readily apparent API

276
00:14:54,922 --> 00:14:59,922
to leverage the frequency
detection portion of Audacity.

277
00:15:01,000 --> 00:15:02,280
There's no CLI option.

278
00:15:02,280 --> 00:15:04,620
There's no readily available API option.

279
00:15:04,620 --> 00:15:05,900
And while I could have dug deeper

280
00:15:05,900 --> 00:15:09,130
into the Audacity code
base to better understand

281
00:15:09,130 --> 00:15:10,887
how that's put together and hook into it,

282
00:15:10,887 --> 00:15:14,113
that really wasn't what
I was trying to go for.

283
00:15:15,681 --> 00:15:18,230
That would be more of an
aside as opposed to helping me

284
00:15:18,230 --> 00:15:20,680
on my main journey to reverse engineer

285
00:15:20,680 --> 00:15:22,680
and better understand this audio signal.

286
00:15:24,290 --> 00:15:26,080
So with manual mode,

287
00:15:26,080 --> 00:15:28,140
we can do black box signal reversing.

288
00:15:28,140 --> 00:15:31,250
We can try to brute force
reproduce the tones.

289
00:15:31,250 --> 00:15:32,810
We can attempt to match generated tones

290
00:15:32,810 --> 00:15:34,840
with spectrographic views.

291
00:15:34,840 --> 00:15:38,420
And then of course, just
fuzzing generating permutations

292
00:15:38,420 --> 00:15:40,300
until we find a match.

293
00:15:40,300 --> 00:15:43,650
This is a very tedious and a
time consuming process though.

294
00:15:43,650 --> 00:15:47,580
So I was looking for a better
way to leverage what I have

295
00:15:47,580 --> 00:15:51,453
and what I know in order
to improve this process.

296
00:15:53,060 --> 00:15:57,950
So really the next step
here is to do an analysis

297
00:15:57,950 --> 00:16:00,056
of the Android application,

298
00:16:00,056 --> 00:16:03,210
since the Android
application is what generates

299
00:16:03,210 --> 00:16:04,363
the audio signals.

300
00:16:06,167 --> 00:16:11,010
And, let's take a closer look
at this vendor application.

301
00:16:11,010 --> 00:16:11,843
So.

302
00:16:13,500 --> 00:16:18,500
How do we go about analysis
of a software artifact?

303
00:16:19,780 --> 00:16:23,204
We could do things like executing
it and logging the results

304
00:16:23,204 --> 00:16:26,100
in a sandbox or a test environment.

305
00:16:26,100 --> 00:16:29,361
We can decompile the package.

306
00:16:29,361 --> 00:16:31,072
We can look for strings,

307
00:16:31,072 --> 00:16:34,246
anything that might relate
to the audio or sound

308
00:16:34,246 --> 00:16:39,246
or SSIDs and passwords,
things of that nature.

309
00:16:40,080 --> 00:16:44,150
We can do a key method
search since Android uses

310
00:16:44,150 --> 00:16:46,810
a higher level language, or
at least I should say this,

311
00:16:46,810 --> 00:16:51,720
this APK is written to
a higher level language.

312
00:16:51,720 --> 00:16:54,632
And even though vendors
can obfuscate their code,

313
00:16:54,632 --> 00:16:56,454
it's a lot harder to obfuscate

314
00:16:56,454 --> 00:17:00,640
the underlying library functions
that you use as a vendor.

315
00:17:00,640 --> 00:17:04,890
So you could do a search
for Android system calls

316
00:17:04,890 --> 00:17:06,587
or Android libraries that provide methods

317
00:17:06,587 --> 00:17:09,420
that you might need
when dealing with audio

318
00:17:09,420 --> 00:17:10,633
and audio and coding.

319
00:17:11,920 --> 00:17:13,640
Once we figured out these code paths,

320
00:17:13,640 --> 00:17:15,530
we can attempt to do high speed fuzzing.

321
00:17:15,530 --> 00:17:17,870
And then of course, if
we identify something

322
00:17:17,870 --> 00:17:19,420
that has been obfuscated,

323
00:17:19,420 --> 00:17:22,473
we can try to go and deobfuscate it

324
00:17:22,473 --> 00:17:26,131
and attribute the classes,
the methods, the properties,

325
00:17:26,131 --> 00:17:29,480
some other identifiers, which
makes more sense to humans.

326
00:17:29,480 --> 00:17:31,908
And it helps us better
reason about the code

327
00:17:31,908 --> 00:17:35,360
to really figure out how this all works.

328
00:17:35,360 --> 00:17:38,004
Now, let's talk a little
bit about preparation.

329
00:17:38,004 --> 00:17:42,080
You'll need to prepare your
computer to pull the APK off

330
00:17:42,080 --> 00:17:44,235
of your test device.

331
00:17:44,235 --> 00:17:46,790
If you've done any of this,

332
00:17:46,790 --> 00:17:48,520
if you've worked with Android before,

333
00:17:48,520 --> 00:17:50,350
you're probably already
familiar with this.

334
00:17:50,350 --> 00:17:52,560
And you need to make sure your
developer mode is enabled,

335
00:17:52,560 --> 00:17:55,360
that you've allowed USB debugging.

336
00:17:55,360 --> 00:17:57,720
Make sure that you have
Android Studio installed,

337
00:17:57,720 --> 00:18:02,720
and that version of ADB is
correctly placed in your path.

338
00:18:03,250 --> 00:18:07,073
So that way you can leverage
it for the purposes of this.

339
00:18:08,690 --> 00:18:12,740
You'll want to extract
the Android package.

340
00:18:12,740 --> 00:18:15,130
And here I show a few
commands that you can use

341
00:18:15,130 --> 00:18:19,330
if you want to follow along
afterwards and try this.

342
00:18:19,330 --> 00:18:21,230
You'll want to make sure
that you take the output

343
00:18:21,230 --> 00:18:24,090
of each step and feed
it into the next step.

344
00:18:24,090 --> 00:18:26,760
Since what I have here
is really only applicable

345
00:18:26,760 --> 00:18:31,760
to a Blackberry priv, 'cause
this is the test device

346
00:18:32,810 --> 00:18:34,940
that I had lying around
after all these years

347
00:18:34,940 --> 00:18:36,673
to do this analysis on.

348
00:18:38,570 --> 00:18:41,863
Once you have the APK, you can
use a tool to decompile it.

349
00:18:42,770 --> 00:18:46,070
I leveraged jadx, you can
go to the GitHub page,

350
00:18:46,070 --> 00:18:49,786
pull the latest release,
and then it's very simple

351
00:18:49,786 --> 00:18:50,619
to decompile the code.

352
00:18:50,619 --> 00:18:52,053
Just a quick one liner.

353
00:18:55,350 --> 00:18:59,500
You will probably note that
it'll show finished with errors.

354
00:18:59,500 --> 00:19:02,660
I found that the errors
did not negatively impact

355
00:19:02,660 --> 00:19:04,860
my analysis of the package.

356
00:19:04,860 --> 00:19:07,423
And I was not impeded in my journey.

357
00:19:08,770 --> 00:19:11,670
Once you have the decompiled sources,

358
00:19:11,670 --> 00:19:14,827
you'll want to open up a
new Android Studio project.

359
00:19:14,827 --> 00:19:19,690
Open the decompiled sources from jadx,

360
00:19:19,690 --> 00:19:21,180
and then click a little button

361
00:19:21,180 --> 00:19:24,640
in the lower right-hand
corner that says configure

362
00:19:24,640 --> 00:19:26,400
the Android framework.

363
00:19:26,400 --> 00:19:28,410
By configuring the Android framework,

364
00:19:28,410 --> 00:19:32,480
it enables you to do
things like find usages

365
00:19:32,480 --> 00:19:34,780
and go to definition.

366
00:19:34,780 --> 00:19:36,800
Just all the goodness that you'd expect

367
00:19:36,800 --> 00:19:37,700
from a modern IDE.

368
00:19:40,240 --> 00:19:44,781
Once it's loaded, you'll see a
bunch of classes on the side.

369
00:19:44,781 --> 00:19:48,390
The one that I have
highlighted there is a U.ALI,

370
00:19:48,390 --> 00:19:51,110
which is clearly obfuscated.

371
00:19:51,110 --> 00:19:52,250
As you drill into there,

372
00:19:52,250 --> 00:19:54,923
there's a bunch of obfuscated
classes and methods.

373
00:19:56,560 --> 00:19:59,620
Now, quick note on obfuscated code.

374
00:19:59,620 --> 00:20:01,040
What is obfuscation?

375
00:20:01,040 --> 00:20:02,090
Sometimes software makers

376
00:20:02,090 --> 00:20:05,920
want to hide their implementations.

377
00:20:05,920 --> 00:20:10,400
They want to impede you from
figuring out how they work,

378
00:20:10,400 --> 00:20:12,971
and from reverse engineering
it to better understand

379
00:20:12,971 --> 00:20:17,763
what the underlying mechanisms
of its operation are.

380
00:20:18,920 --> 00:20:19,990
With higher level languages,

381
00:20:19,990 --> 00:20:23,240
you get a terse randomly
generated identifiers.

382
00:20:23,240 --> 00:20:26,550
You might have a class named lowercase A.

383
00:20:26,550 --> 00:20:29,650
You might have a method named F999,

384
00:20:29,650 --> 00:20:32,210
or just whatever the case may be.

385
00:20:32,210 --> 00:20:35,470
It's harder to obfuscate
the use of system libraries

386
00:20:35,470 --> 00:20:37,110
in a higher level language.

387
00:20:37,110 --> 00:20:42,110
Since those decompile cleanly
back to base libraries, so.

388
00:20:44,810 --> 00:20:46,040
Why do we use Android Studio?

389
00:20:46,040 --> 00:20:47,900
Or I should say, what's the advantage

390
00:20:47,900 --> 00:20:49,230
of using Android Studio

391
00:20:49,230 --> 00:20:52,283
is in your manual deobfuscation process.

392
00:20:53,190 --> 00:20:57,080
It's a very slick IDE, it's
free, it's readily available.

393
00:20:57,080 --> 00:21:00,489
It receives a lot of support,
a lot of people use it.

394
00:21:00,489 --> 00:21:01,530
And then of course you get

395
00:21:01,530 --> 00:21:04,310
all the classic IDE
functionality like find usages,

396
00:21:04,310 --> 00:21:07,240
go to declarations, things like that.

397
00:21:07,240 --> 00:21:08,920
With Android in particular,

398
00:21:08,920 --> 00:21:12,620
you get a LogCats
instance or LogCat window,

399
00:21:12,620 --> 00:21:14,350
which lets you search.

400
00:21:14,350 --> 00:21:17,700
You can also target specific
applications that are running

401
00:21:17,700 --> 00:21:21,425
on a phone to reduce the
verbosity of the messages

402
00:21:21,425 --> 00:21:25,871
that you see, and better help
you tailor your analysis.

403
00:21:25,871 --> 00:21:30,871
Let's take a look at what we
can do with this application.

404
00:21:31,055 --> 00:21:33,633
So live log analysis.

405
00:21:34,549 --> 00:21:37,288
This is one of the first things I try

406
00:21:37,288 --> 00:21:39,440
because being a developer myself,

407
00:21:39,440 --> 00:21:42,540
I know that oftentimes the
debug logs will contain

408
00:21:42,540 --> 00:21:44,630
a wealth of information.

409
00:21:44,630 --> 00:21:48,070
And as a regular user of
the phone or the service

410
00:21:48,070 --> 00:21:51,120
of the application, I regularly
user's not going to see

411
00:21:51,120 --> 00:21:52,400
the debug output.

412
00:21:52,400 --> 00:21:55,410
So if you're rushing a
release out the door,

413
00:21:55,410 --> 00:21:58,062
and you don't disable your debug output,

414
00:21:58,062 --> 00:22:00,280
somebody like me is gonna come along

415
00:22:00,280 --> 00:22:05,059
and hook up the Android phone to LogCat

416
00:22:05,059 --> 00:22:07,520
and investigate for
messages if we're curious

417
00:22:07,520 --> 00:22:08,620
about what's going on.

418
00:22:09,484 --> 00:22:14,228
Now, let's take a look at what logs we get

419
00:22:14,228 --> 00:22:16,990
as we start this application.

420
00:22:16,990 --> 00:22:19,344
Here's the login screen.

421
00:22:19,344 --> 00:22:23,350
Here's a little capture from LogCat.

422
00:22:23,350 --> 00:22:25,458
And we can see that there's
some interesting information

423
00:22:25,458 --> 00:22:28,390
in there, there appears to be some kind

424
00:22:28,390 --> 00:22:30,240
of an encoded payload.

425
00:22:30,240 --> 00:22:33,140
There's some interesting strings in there.

426
00:22:33,140 --> 00:22:35,544
And we appear to be
getting both informational

427
00:22:35,544 --> 00:22:36,773
and debug output.

428
00:22:37,970 --> 00:22:42,970
So, there's a URL that ap.jawalife.net.

429
00:22:43,320 --> 00:22:44,153
Go JAWAs!

430
00:22:45,280 --> 00:22:48,270
And then as we kind of continue scrolling

431
00:22:48,270 --> 00:22:49,103
through the screen

432
00:22:49,103 --> 00:22:51,193
that there's a lot more
messages like this.

433
00:22:52,030 --> 00:22:54,743
When you try the camera pairing process,

434
00:22:56,279 --> 00:22:59,373
you have to enter in the
SSID and the password.

435
00:23:00,462 --> 00:23:05,462
And at this stage, we see
that there's log output

436
00:23:05,680 --> 00:23:08,610
which logs the SSID, the password,

437
00:23:08,610 --> 00:23:10,210
and then what appears to be some kind

438
00:23:10,210 --> 00:23:12,400
of a randomly generated token.

439
00:23:12,400 --> 00:23:15,860
And in this log output, I know
it's really hard to see here,

440
00:23:15,860 --> 00:23:19,510
but there's a class that we
can start to investigate.

441
00:23:19,510 --> 00:23:22,530
And then there's what appears
to be an HTTP helper class,

442
00:23:22,530 --> 00:23:25,910
which is what helps us send
and receive messages back

443
00:23:25,910 --> 00:23:27,833
from the cloud server.

444
00:23:29,640 --> 00:23:33,700
Let's try to pair to a
camera and see what we get.

445
00:23:33,700 --> 00:23:38,160
So there's a button that says
click to send the sound wave.

446
00:23:38,160 --> 00:23:41,310
Just to love it, it makes
me smile when I see that.

447
00:23:41,310 --> 00:23:44,220
And when we send the sound wave,

448
00:23:44,220 --> 00:23:45,680
we get some additional information.

449
00:23:45,680 --> 00:23:48,180
And it may not look like much,

450
00:23:48,180 --> 00:23:51,323
but there are a few
strings here which can help

451
00:23:51,323 --> 00:23:53,363
in the analysis.

452
00:23:54,970 --> 00:23:59,200
We found, just to recap
what we've found so far.

453
00:23:59,200 --> 00:24:00,840
We found a distinctive characters.

454
00:24:00,840 --> 00:24:02,090
We found URLs.

455
00:24:02,090 --> 00:24:03,580
We found a class to investigate

456
00:24:03,580 --> 00:24:06,440
this bind device new activity.

457
00:24:06,440 --> 00:24:08,000
That sounds particularly fitting given

458
00:24:08,000 --> 00:24:10,650
that we are trying to enable

459
00:24:10,650 --> 00:24:14,270
and configure a new camera device.

460
00:24:14,270 --> 00:24:16,223
So, what does this lead us?

461
00:24:17,400 --> 00:24:19,690
We can continue our search
by taking those strings

462
00:24:19,690 --> 00:24:21,620
that we found in the log outputs,

463
00:24:21,620 --> 00:24:24,630
and searching for them
within Android Studio.

464
00:24:24,630 --> 00:24:29,630
And as I searched through
the decompile output,

465
00:24:29,862 --> 00:24:31,340
I found a few things.

466
00:24:31,340 --> 00:24:36,340
It looks like the number one
is used to delimit fields.

467
00:24:36,579 --> 00:24:39,780
They call the random generated code,

468
00:24:39,780 --> 00:24:41,740
they call it a SmartCode.

469
00:24:41,740 --> 00:24:46,740
Then, there's a string one
that's appended at the end

470
00:24:48,200 --> 00:24:50,470
of this little message block.

471
00:24:50,470 --> 00:24:53,210
And even though Android Studio is calling

472
00:24:53,210 --> 00:24:55,850
this message DB notify reached,

473
00:24:55,850 --> 00:24:59,090
I kind of wonder if this
isn't a decompilation artifact

474
00:24:59,090 --> 00:25:01,503
of some kind, because it
really is just the string

475
00:25:01,503 --> 00:25:04,093
of the character one.

476
00:25:05,530 --> 00:25:07,790
So, what is the SmartCode thing?

477
00:25:07,790 --> 00:25:11,430
I noticed that each time I
tried to pair via the camera

478
00:25:11,430 --> 00:25:15,220
to the cloud app, this
SmartCode would change.

479
00:25:15,220 --> 00:25:16,893
It would be different every time.

480
00:25:19,020 --> 00:25:22,850
And I could see by looking
at this boot up code,

481
00:25:22,850 --> 00:25:26,300
that yes, every time that you
attempt to pair the camera,

482
00:25:26,300 --> 00:25:29,940
you get characters and
numbers for six characters,

483
00:25:29,940 --> 00:25:32,357
and that constitutes the SmartCode.

484
00:25:33,910 --> 00:25:37,540
But the question still remains,
like, what is this thing?

485
00:25:37,540 --> 00:25:39,590
And just after having gone

486
00:25:39,590 --> 00:25:41,720
through this entire analysis process,

487
00:25:41,720 --> 00:25:45,510
and seen it change with every single time

488
00:25:45,510 --> 00:25:46,910
that I attempt to pair,

489
00:25:46,910 --> 00:25:50,200
and noticing that whenever
I paired the camera,

490
00:25:50,200 --> 00:25:53,530
a message was sent from the application

491
00:25:53,530 --> 00:25:56,490
up to the cloud server that
included the random code.

492
00:25:56,490 --> 00:26:00,790
I can only presume that the
backend cloud service uses

493
00:26:00,790 --> 00:26:03,814
this random code to tie this camera

494
00:26:03,814 --> 00:26:08,180
to my user account in the cloud.

495
00:26:08,180 --> 00:26:13,180
Since, how else is the
camera going to identify

496
00:26:13,460 --> 00:26:16,640
that it belongs to my account?

497
00:26:16,640 --> 00:26:18,180
So that's the best case that I have

498
00:26:18,180 --> 00:26:20,773
for what this code is used for.

499
00:26:21,815 --> 00:26:25,790
As we continue looking
through the strings,

500
00:26:25,790 --> 00:26:29,560
we can see other strings
which guide us to processes,

501
00:26:29,560 --> 00:26:30,800
sorry, to functions,

502
00:26:30,800 --> 00:26:34,630
methods that warrant further
investigation like run

503
00:26:34,630 --> 00:26:35,900
and play voice.

504
00:26:35,900 --> 00:26:40,160
Both of those sound, they sound good.

505
00:26:40,160 --> 00:26:45,160
Let's take a closer look and
do an extractive analysis.

506
00:26:45,880 --> 00:26:50,267
At this point, we've
uncovered a lot of functions,

507
00:26:51,790 --> 00:26:56,790
a lot of methods, static
constants in the code base.

508
00:26:58,020 --> 00:27:02,110
And we want to take the key sections

509
00:27:02,110 --> 00:27:05,440
out of the vendor application,
put them in a clean project

510
00:27:05,440 --> 00:27:08,800
so that way we can perform an analysis.

511
00:27:08,800 --> 00:27:13,800
Just a couple of notes on
setting up the clean application.

512
00:27:15,096 --> 00:27:18,000
If you're looking at another application,

513
00:27:18,000 --> 00:27:20,300
which like this application here,

514
00:27:20,300 --> 00:27:22,240
leverages native libraries,

515
00:27:22,240 --> 00:27:25,460
you'll need to manually
create a jniLibs folder,

516
00:27:25,460 --> 00:27:30,340
put all those compiled libraries
in the jniLibs directory,

517
00:27:30,340 --> 00:27:35,340
and then you'll need to make
the JAWA class that matches,

518
00:27:36,999 --> 00:27:38,870
the package structure has to be the same.

519
00:27:38,870 --> 00:27:43,310
So this thing is called
like calm.ithink.voice

520
00:27:43,310 --> 00:27:44,790
in the vendor application.

521
00:27:44,790 --> 00:27:48,570
I can't call it calm.test.reverseengineer,

522
00:27:48,570 --> 00:27:51,400
I have to name the package
structure the same.

523
00:27:51,400 --> 00:27:53,922
Because the way that JNI works,

524
00:27:53,922 --> 00:27:57,670
it requires those two things to match up.

525
00:27:57,670 --> 00:28:01,170
And once you have your
sample test project set up,

526
00:28:01,170 --> 00:28:04,150
you're able to perform black box analysis

527
00:28:04,150 --> 00:28:08,720
of the code that's used
to generate the signal.

528
00:28:08,720 --> 00:28:12,870
And along this way, one of
the questions that I had was,

529
00:28:12,870 --> 00:28:15,343
well, what are the exact
tones that are being generated

530
00:28:15,343 --> 00:28:20,343
by the application to pair
and bind with the camera?

531
00:28:20,835 --> 00:28:23,813
Well, there's a class called VCodeTable.

532
00:28:24,666 --> 00:28:28,610
And as I ran it in this extracted project,

533
00:28:28,610 --> 00:28:32,560
it produced a mapping of all of the tones.

534
00:28:32,560 --> 00:28:37,560
All the tones along with the
characters that they map to.

535
00:28:38,020 --> 00:28:40,380
So this is what the characters map to.

536
00:28:40,380 --> 00:28:44,860
We have from zero to 4875 Hertz.

537
00:28:44,860 --> 00:28:49,860
And there are 16 states, so
this is a hexadecimal style

538
00:28:51,867 --> 00:28:53,133
and coding here.

539
00:28:54,022 --> 00:28:58,010
Now, looking at what else we found here,

540
00:28:58,010 --> 00:28:58,910
there's a lot of findings.

541
00:28:58,910 --> 00:29:01,450
We know that Android uses AudioTrack,

542
00:29:01,450 --> 00:29:03,423
we know that the
application uses AudioTrack

543
00:29:03,423 --> 00:29:04,660
to play a signal.

544
00:29:04,660 --> 00:29:07,980
We've identified how
it creates the payload,

545
00:29:07,980 --> 00:29:11,760
as far as the SSID, the
password, the random code,

546
00:29:11,760 --> 00:29:14,160
and then the delimiters
between those fields.

547
00:29:14,160 --> 00:29:16,000
We've identified control tones,

548
00:29:16,000 --> 00:29:17,960
like a frequency begin and frequency ends

549
00:29:17,960 --> 00:29:19,860
that are just static constants.

550
00:29:19,860 --> 00:29:22,824
There's also a space
tone, which is used for

551
00:29:22,824 --> 00:29:26,800
when two tones play back
to back the same tone.

552
00:29:26,800 --> 00:29:29,373
There's a little space tone that pops in,

553
00:29:29,373 --> 00:29:33,810
and that'll be better
visualized in a later slide.

554
00:29:33,810 --> 00:29:35,640
There's methods which play the characters,

555
00:29:35,640 --> 00:29:39,170
there's the use of a CRC
values to help the camera

556
00:29:39,170 --> 00:29:42,110
know if it's received a
complete signal or not.

557
00:29:42,110 --> 00:29:44,150
So, there's a been a wealth of information

558
00:29:44,150 --> 00:29:47,020
that we've uncovered through this process.

559
00:29:47,020 --> 00:29:49,590
So, what do we know now?

560
00:29:49,590 --> 00:29:53,100
We can reconstruct all of
section one and section two

561
00:29:53,100 --> 00:29:54,500
of the signal.

562
00:29:54,500 --> 00:29:58,660
'Cause each signal
consists of three sections.

563
00:29:58,660 --> 00:30:03,038
And now that we can reconstruct
section one and section two,

564
00:30:03,038 --> 00:30:06,530
really that just leaves section three.

565
00:30:06,530 --> 00:30:09,850
And I've highlighted in this
image the part of the code

566
00:30:09,850 --> 00:30:11,510
which is, sorry, the part of the signal

567
00:30:11,510 --> 00:30:16,120
which is elusive at this
stage in the analysis.

568
00:30:16,120 --> 00:30:20,030
This tone appears to be some
type of error correction code.

569
00:30:20,030 --> 00:30:22,557
It doesn't exactly track
what the CRC process

570
00:30:22,557 --> 00:30:25,440
that the rest of the
code base uses though,

571
00:30:25,440 --> 00:30:27,920
which left me wondering.

572
00:30:27,920 --> 00:30:31,090
And since this is generated by code

573
00:30:31,090 --> 00:30:33,180
that's in a native library,

574
00:30:33,180 --> 00:30:35,360
it means that I need binary analysis

575
00:30:35,360 --> 00:30:39,503
to dig deeper and try to figure
out what's going on here.

576
00:30:40,410 --> 00:30:42,653
My tool of choice is Ghidra.

577
00:30:42,653 --> 00:30:44,980
I don't know how to pronounce that.

578
00:30:44,980 --> 00:30:46,620
It's a free tool.

579
00:30:46,620 --> 00:30:47,850
It's very capable.

580
00:30:47,850 --> 00:30:49,870
And it does the job here.

581
00:30:49,870 --> 00:30:51,540
So to get set up with Ghidra,

582
00:30:51,540 --> 00:30:54,250
you'll want to visit their GitHub page.

583
00:30:54,250 --> 00:30:56,340
Pull the latest release for your platform,

584
00:30:56,340 --> 00:30:59,710
and then follow the installation guide.

585
00:30:59,710 --> 00:31:03,218
Once you have Ghidra installed,
create a new project,

586
00:31:03,218 --> 00:31:05,970
fill out all the wizard boxes.

587
00:31:05,970 --> 00:31:08,320
I just took basically all the defaults

588
00:31:08,320 --> 00:31:09,930
and gave it a project name.

589
00:31:09,930 --> 00:31:11,999
Click the dragon icon.

590
00:31:11,999 --> 00:31:15,650
Import the native library
that you want to analyze.

591
00:31:15,650 --> 00:31:19,500
In my case, I just went
with the x8664 library

592
00:31:19,500 --> 00:31:22,430
since I am a little bit
more comfortable with x86

593
00:31:22,430 --> 00:31:26,150
than I am with arm library at the moment.

594
00:31:26,150 --> 00:31:28,220
When you click the yes button,

595
00:31:28,220 --> 00:31:30,060
it'll go through and it'll do an analysis

596
00:31:30,060 --> 00:31:31,890
of this compiled library,

597
00:31:31,890 --> 00:31:34,143
which you can then navigate in the UI.

598
00:31:35,270 --> 00:31:38,377
So, reverse engineering with Ghidra.

599
00:31:38,377 --> 00:31:40,940
We need to know what
we're looking at here.

600
00:31:40,940 --> 00:31:44,090
So, you want to go to your
Android Studio project,

601
00:31:44,090 --> 00:31:47,300
make sure that you
identify which functions,

602
00:31:47,300 --> 00:31:52,300
which methods in the higher
level language map to functions

603
00:31:53,440 --> 00:31:54,913
in the compiled library.

604
00:31:56,334 --> 00:32:00,355
Once you know that, you can
look in the symbol tree,

605
00:32:00,355 --> 00:32:03,170
and you can see here that there's a number

606
00:32:03,170 --> 00:32:06,130
of a JAWA com interrupts.

607
00:32:06,130 --> 00:32:09,033
So JNI interfaces here
in this native library.

608
00:32:09,897 --> 00:32:11,530
The methods that we're looking

609
00:32:11,530 --> 00:32:14,580
for are the get voise structures
that are listed towards

610
00:32:14,580 --> 00:32:16,363
the bottom of the screen.

611
00:32:17,420 --> 00:32:20,670
And here's a closer view on
what you would see in Ghidra

612
00:32:20,670 --> 00:32:22,333
as you do this analysis.

613
00:32:23,433 --> 00:32:26,360
So, now we just need to
pick one of the functions

614
00:32:26,360 --> 00:32:27,243
and dig in.

615
00:32:28,290 --> 00:32:30,750
I focused on this
intuitively named function

616
00:32:30,750 --> 00:32:33,440
called "getVoiseStructGoke2."

617
00:32:33,440 --> 00:32:35,580
So I love the spelling of voice,

618
00:32:35,580 --> 00:32:38,800
and I don't know what Goke2 means.

619
00:32:38,800 --> 00:32:41,910
This is the function though
that generates the section two

620
00:32:41,910 --> 00:32:45,900
and section three output
for the audio signal.

621
00:32:45,900 --> 00:32:48,447
One thing that I noticed as
I was doing this analysis

622
00:32:48,447 --> 00:32:53,370
is that on the JAWA side,
you pass in eight parameters

623
00:32:53,370 --> 00:32:54,723
to this native function.

624
00:32:56,270 --> 00:32:59,410
Yet on the compiled side,

625
00:32:59,410 --> 00:33:02,710
when we look at the function
signature in Ghidra,

626
00:33:02,710 --> 00:33:04,820
there were 10 parameters here.

627
00:33:04,820 --> 00:33:08,255
So, it seems a little odd,

628
00:33:08,255 --> 00:33:11,070
but then doing a little
bit of reading I found

629
00:33:11,070 --> 00:33:15,630
that JNI call in conventions
add two parameters.

630
00:33:15,630 --> 00:33:20,610
There is a, yeah, let's
talk about the note on JNI.

631
00:33:20,610 --> 00:33:22,230
There's a JNI environment pointer,

632
00:33:22,230 --> 00:33:24,900
and then there's an object pointer.

633
00:33:24,900 --> 00:33:26,820
And these two parameters are front loaded

634
00:33:26,820 --> 00:33:28,290
to the function signature.

635
00:33:28,290 --> 00:33:33,080
So those first two are just
the environment and the object.

636
00:33:33,080 --> 00:33:38,080
So this top picture is
the raw decompiled view.

637
00:33:38,820 --> 00:33:41,980
Just with all the generated identifiers

638
00:33:41,980 --> 00:33:43,760
that don't really make a lot of sense.

639
00:33:43,760 --> 00:33:48,360
The bottom picture shows
it refactored in Ghidra,

640
00:33:48,360 --> 00:33:52,953
to indicate that the first two
parameters are JNI related.

641
00:33:54,170 --> 00:33:55,883
Now let's continue the analysis.

642
00:33:56,910 --> 00:33:59,000
Okay, so inside of Ghidra,

643
00:33:59,000 --> 00:34:01,740
there's a function decompiler window.

644
00:34:01,740 --> 00:34:06,380
And the nice thing about Ghidra,
it's like most other IDEs

645
00:34:06,380 --> 00:34:07,340
that I've worked with.

646
00:34:07,340 --> 00:34:10,850
You can right click on an
identifier, you can rename it,

647
00:34:10,850 --> 00:34:12,212
you can highlight it.

648
00:34:12,212 --> 00:34:14,950
You can do things that'll help you analyze

649
00:34:14,950 --> 00:34:17,620
the flow of how a particular parameter

650
00:34:17,620 --> 00:34:19,223
is used and manipulated.

651
00:34:20,360 --> 00:34:25,310
So, this function, this
getVoiseStructGoke2.

652
00:34:27,620 --> 00:34:31,720
It calls another function
that leverages the inputs

653
00:34:31,720 --> 00:34:34,900
that are passed into this function.

654
00:34:34,900 --> 00:34:37,090
What I do when I do this type of analysis

655
00:34:37,090 --> 00:34:39,800
is for each screen that I'm on,

656
00:34:39,800 --> 00:34:44,800
I try to rename and refactor
the parameters and the methods,

657
00:34:44,970 --> 00:34:47,300
the functions, to names that actually

658
00:34:47,300 --> 00:34:49,810
make some degree of human sense.

659
00:34:49,810 --> 00:34:52,070
So that's what I'll be doing here.

660
00:34:52,070 --> 00:34:54,240
This is the cleaned up view.

661
00:34:54,240 --> 00:34:57,490
And I know it's small,
but the picture shows

662
00:34:57,490 --> 00:35:00,992
that each of those parameters
are named to reflect

663
00:35:00,992 --> 00:35:05,940
what value they represent
from the Android side.

664
00:35:05,940 --> 00:35:09,470
And then, I go from
there, I check the usages.

665
00:35:09,470 --> 00:35:12,762
Since this is decompiled,
there can be a lot of,

666
00:35:12,762 --> 00:35:17,020
sometimes it doesn't
exactly make the most sense.

667
00:35:17,020 --> 00:35:19,770
Like I noticed that input parameters

668
00:35:19,770 --> 00:35:22,550
are copied to local variables,

669
00:35:22,550 --> 00:35:25,190
and then those local variables
are then used elsewhere.

670
00:35:25,190 --> 00:35:27,180
So, in the analysis,

671
00:35:27,180 --> 00:35:29,890
just keep in mind what you're looking at,

672
00:35:29,890 --> 00:35:33,908
track the flow through any
type of intermediate steps

673
00:35:33,908 --> 00:35:35,410
that it goes through,

674
00:35:35,410 --> 00:35:37,753
to see where it winds
up being manipulated.

675
00:35:38,717 --> 00:35:43,717
Now, this is the raw view
of that nested function.

676
00:35:45,770 --> 00:35:48,210
Fortunately for me,
and almost conveniently

677
00:35:48,210 --> 00:35:51,030
so for this demo, this
is a very small function.

678
00:35:51,030 --> 00:35:53,503
There's only about 58.

679
00:35:54,510 --> 00:35:57,180
Yeah, actually about 56 lines long.

680
00:35:57,180 --> 00:36:00,613
So it makes it pretty easy to analyze.

681
00:36:00,613 --> 00:36:03,800
Again, since the identifiers are all terse

682
00:36:03,800 --> 00:36:06,740
and auto-generated, I need to
refactor those into something

683
00:36:06,740 --> 00:36:08,600
that I can use.

684
00:36:08,600 --> 00:36:12,137
So, start with what you know,
find a good starting point.

685
00:36:12,137 --> 00:36:14,270
Even if you can't get all the names

686
00:36:14,270 --> 00:36:17,224
to something human readable,
just to do what you know,

687
00:36:17,224 --> 00:36:19,334
and as you reason through the code,

688
00:36:19,334 --> 00:36:23,920
you'll find that the rest of the pieces

689
00:36:23,920 --> 00:36:27,040
can fall into place sometimes
if you enter what you know.

690
00:36:27,040 --> 00:36:29,780
As I went through this and
did all of the renaming,

691
00:36:29,780 --> 00:36:32,449
I found that the critical section,

692
00:36:32,449 --> 00:36:34,430
the critical operation
that I needed to apply

693
00:36:34,430 --> 00:36:39,430
in my reverse engineering
project to replicate

694
00:36:39,814 --> 00:36:44,210
the signal three, it just
came down to a shift.

695
00:36:44,210 --> 00:36:46,930
So, this is the line.

696
00:36:46,930 --> 00:36:51,930
It takes the CRC SSID, and
then it shifts it to the right.

697
00:36:53,960 --> 00:36:57,240
So, that's a very simple
operation for me to perform

698
00:36:57,240 --> 00:37:00,540
in my replicated Android project.

699
00:37:00,540 --> 00:37:02,750
It is not something that
I was able to figure out

700
00:37:02,750 --> 00:37:04,960
just by reasoning through the JAWA,

701
00:37:04,960 --> 00:37:08,530
or by passing in inputs
to the library function

702
00:37:08,530 --> 00:37:10,210
and fuzzing the output.

703
00:37:10,210 --> 00:37:11,890
I think probably with enough time,

704
00:37:11,890 --> 00:37:13,394
I probably would have figured it out,

705
00:37:13,394 --> 00:37:17,170
but I get a little impatient,

706
00:37:17,170 --> 00:37:19,390
and when I can go explore a little deeper

707
00:37:19,390 --> 00:37:21,630
and a more fully understand
how something works,

708
00:37:21,630 --> 00:37:23,080
I'll take that opportunity.

709
00:37:23,080 --> 00:37:25,540
So, a shift, that's all I got to do

710
00:37:25,540 --> 00:37:26,903
to replicate section three.

711
00:37:27,900 --> 00:37:30,540
Now, let's think about hacking the signal.

712
00:37:30,540 --> 00:37:33,550
How can we recreate this and manipulate

713
00:37:33,550 --> 00:37:36,250
it to serve our purposes?

714
00:37:36,250 --> 00:37:37,960
So, let's look again at what we know.

715
00:37:37,960 --> 00:37:39,945
This is the spectrographic wave form

716
00:37:39,945 --> 00:37:43,113
of a complete pairing cycle.

717
00:37:45,390 --> 00:37:47,552
The wave form is comprised
of three sections

718
00:37:47,552 --> 00:37:50,300
of hexified data.

719
00:37:50,300 --> 00:37:53,660
Each section is prefixed and
suffixed by control codes

720
00:37:53,660 --> 00:37:55,800
and section identifiers.

721
00:37:55,800 --> 00:37:59,830
We know that when two
sequential tones are used,

722
00:37:59,830 --> 00:38:02,730
there's a space tone that
shows up in between it to help

723
00:38:02,730 --> 00:38:04,260
the camera better differentiate

724
00:38:04,260 --> 00:38:08,020
and identify distinct signals.

725
00:38:08,020 --> 00:38:09,830
The duration of each tone that I found

726
00:38:09,830 --> 00:38:12,360
is about 50 to 60 milliseconds.

727
00:38:12,360 --> 00:38:15,603
And we know the structure
of each wave form section.

728
00:38:16,510 --> 00:38:17,430
Let's look at section one.

729
00:38:17,430 --> 00:38:19,640
This one's a long one.

730
00:38:19,640 --> 00:38:21,230
It's got frequency begin.

731
00:38:21,230 --> 00:38:26,230
It's got delimited, SSID,
passphrase and random code digits.

732
00:38:28,880 --> 00:38:32,950
It has a CRCs of a bunch
of data put together.

733
00:38:32,950 --> 00:38:34,970
And then it's got end tones.

734
00:38:34,970 --> 00:38:38,800
Section two is incredibly
simple by comparison.

735
00:38:38,800 --> 00:38:42,097
All it's about is the SmartCode,

736
00:38:42,097 --> 00:38:44,260
and just making sure that there's

737
00:38:44,260 --> 00:38:48,500
a proper error correction on
that randomly generated code.

738
00:38:48,500 --> 00:38:50,700
So that's very terse, very short,

739
00:38:50,700 --> 00:38:52,470
very easy to reason through.

740
00:38:52,470 --> 00:38:53,470
Section three.

741
00:38:53,470 --> 00:38:55,730
Yeah, this one's a little
bit longer as well.

742
00:38:55,730 --> 00:38:58,830
We have some CRC codes in there.

743
00:38:58,830 --> 00:39:03,050
We have another kind of
like mutilated version

744
00:39:03,050 --> 00:39:04,680
of the SmartCode.

745
00:39:04,680 --> 00:39:07,187
There's a passphrase
by itself, another CRC,

746
00:39:07,187 --> 00:39:09,930
and then this thing wraps up.

747
00:39:09,930 --> 00:39:12,520
So, we can reproduce the signal now.

748
00:39:12,520 --> 00:39:17,280
We know every aspect of
every part of the signal,

749
00:39:17,280 --> 00:39:20,770
and we are able to
recreate it as a result.

750
00:39:20,770 --> 00:39:24,380
So, that's where the demo
comes into play here.

751
00:39:24,380 --> 00:39:29,380
I created an application
which can be used to pair

752
00:39:29,613 --> 00:39:33,840
this wireless camera to a wireless network

753
00:39:33,840 --> 00:39:37,340
without having to use
the cloud application.

754
00:39:37,340 --> 00:39:40,110
This enables the camera
to be further analyzed

755
00:39:40,110 --> 00:39:41,474
using more traditional

756
00:39:41,474 --> 00:39:46,474
but network style of
investigation techniques.

757
00:39:46,930 --> 00:39:49,630
So with that, let's go ahead

758
00:39:49,630 --> 00:39:54,630
and let's take a look at the demo.

759
00:40:03,315 --> 00:40:08,315
In this demo, we'll be
pairing the wireless camera

760
00:40:08,776 --> 00:40:12,090
with a wireless network

761
00:40:12,090 --> 00:40:16,570
that's hosted on this
laptop running host APD,

762
00:40:16,570 --> 00:40:20,210
advertising a Defcon 29 SSID.

763
00:40:21,540 --> 00:40:23,790
To do the pairing, we will leverage

764
00:40:23,790 --> 00:40:28,790
the reverse engineered
application that I created

765
00:40:28,930 --> 00:40:32,573
as part of this kind of
reverse engineering process.

766
00:40:35,380 --> 00:40:39,513
Where I've configured
the SSID and passphrase.

767
00:40:40,590 --> 00:40:44,560
Now, to get this camera to pair,

768
00:40:44,560 --> 00:40:48,051
we need to wait for it
to get into setup mode.

769
00:40:48,051 --> 00:40:49,700
After I plug it in,

770
00:40:49,700 --> 00:40:52,143
we'll want to wait for the flashing light.

771
00:40:53,030 --> 00:40:54,020
And at that point,

772
00:40:54,020 --> 00:40:59,020
the camera should be
susceptible to our suggestion

773
00:40:59,666 --> 00:41:01,880
that it paired to a specific network.

774
00:41:01,880 --> 00:41:06,093
So, I'll plug the camera
into the power bank,

775
00:41:06,980 --> 00:41:09,423
and start it up.

776
00:41:11,890 --> 00:41:15,695
On boot the camera shows
a solid green light

777
00:41:15,695 --> 00:41:19,385
to indicate that it has power.

778
00:41:19,385 --> 00:41:22,850
After it goes through its set up sequence,

779
00:41:22,850 --> 00:41:23,840
whatever that entails,

780
00:41:23,840 --> 00:41:26,340
I haven't been able to really probe that.

781
00:41:26,340 --> 00:41:28,760
It'll go into a flashing light mode

782
00:41:28,760 --> 00:41:32,430
where we can pass it along our message.

783
00:41:32,430 --> 00:41:34,743
So, let's give this a try.

784
00:41:35,891 --> 00:41:38,808
(electronic noise)

785
00:41:45,049 --> 00:41:46,630
All right.

786
00:41:46,630 --> 00:41:49,650
With that tone, it should indicate

787
00:41:49,650 --> 00:41:53,877
that the camera has received
our pairing message.

788
00:41:57,580 --> 00:42:01,713
And in the Wireshark capture,

789
00:42:03,140 --> 00:42:08,140
you will see that the
camera is communicating

790
00:42:08,850 --> 00:42:13,850
with the network, and that it's paired.

791
00:42:14,420 --> 00:42:18,853
So that is looking good.

792
00:42:22,103 --> 00:42:25,770
Let's take another look at the pairing,

793
00:42:25,770 --> 00:42:28,134
this time from the screen recording

794
00:42:28,134 --> 00:42:33,134
that shows the Wireshark
output of our packet capture.

795
00:42:34,330 --> 00:42:37,960
As the camera goes through
its visualization sequence,

796
00:42:37,960 --> 00:42:40,020
receives our pairing code,

797
00:42:40,020 --> 00:42:44,380
it should show up requesting an address.

798
00:42:44,380 --> 00:42:45,360
Which in this case,

799
00:42:45,360 --> 00:42:50,360
I've targeted to be a
specific one in advance.

800
00:42:50,410 --> 00:42:54,820
You can see here that it
receives an IP address

801
00:42:54,820 --> 00:42:58,823
on the local demo network,

802
00:42:59,860 --> 00:43:04,330
and it proceeds to query back home

803
00:43:04,330 --> 00:43:09,330
and attempt to call home and
do the cloud configuration bit.

804
00:43:17,160 --> 00:43:22,160
We're going to try connecting
to the camera's video now.

805
00:43:22,250 --> 00:43:24,490
One thing I do want to
note about this camera

806
00:43:24,490 --> 00:43:29,490
is that the video connection
can be a little bit iffy.

807
00:43:29,570 --> 00:43:32,371
It doesn't always work

808
00:43:32,371 --> 00:43:37,190
and can require three,
four, sometimes upwards

809
00:43:37,190 --> 00:43:41,280
of five different attempts to
get the video signal to work.

810
00:43:41,280 --> 00:43:44,410
Here I'm showing an attempt to connect

811
00:43:44,410 --> 00:43:49,410
to the camera using VLC,
and surprise surprise.

812
00:43:49,460 --> 00:43:50,980
It fires right up.

813
00:43:50,980 --> 00:43:52,993
So, go figure.

814
00:44:00,009 --> 00:44:04,510
Let's go ahead and wrap this up now.

815
00:44:04,510 --> 00:44:07,640
There are a few limitations
that are worth noting.

816
00:44:07,640 --> 00:44:08,830
It's not easy to discover

817
00:44:08,830 --> 00:44:10,890
the device's administrative password.

818
00:44:10,890 --> 00:44:14,950
It is six hexadecimal characters.

819
00:44:14,950 --> 00:44:18,050
And the password changes each
time the camera is reset.

820
00:44:18,050 --> 00:44:20,970
It doesn't seem to be tied
to macro serial number.

821
00:44:20,970 --> 00:44:23,560
So just kind of brute forcing your way

822
00:44:23,560 --> 00:44:27,800
through it might be one decent option.

823
00:44:27,800 --> 00:44:30,080
The easiest option is
just to have it pair once

824
00:44:30,080 --> 00:44:35,080
to the cloud and pull
the password off of that.

825
00:44:35,810 --> 00:44:39,510
That is not the approach
that I would prefer

826
00:44:39,510 --> 00:44:41,570
if at all possible though.

827
00:44:41,570 --> 00:44:46,570
So, it's not possible or not
really very easy I should say

828
00:44:46,850 --> 00:44:49,948
to decipher the camera
to cloud communication,

829
00:44:49,948 --> 00:44:52,700
based off of some of
the code that I've seen

830
00:44:52,700 --> 00:44:55,204
in the application and
what I've intercepted

831
00:44:55,204 --> 00:44:59,095
between the camera and the cloud servers.

832
00:44:59,095 --> 00:45:03,546
The camera has a local RSA
key pair that changes on reset

833
00:45:03,546 --> 00:45:06,380
or potentially between each request.

834
00:45:06,380 --> 00:45:11,380
The payloads are encrypted
and sent over to the server.

835
00:45:11,690 --> 00:45:15,600
So even though you can view
the payloads by setting

836
00:45:15,600 --> 00:45:18,610
up a self-signed demand
in the middle server,

837
00:45:18,610 --> 00:45:22,840
you can't really make sense of
what the payloads are saying.

838
00:45:22,840 --> 00:45:26,453
So, could be worth some
additional investigation.

839
00:45:27,320 --> 00:45:29,220
You also get what you pay for,

840
00:45:29,220 --> 00:45:31,863
even if you know the password,
it doesn't always connect.

841
00:45:31,863 --> 00:45:35,890
VLC will sometimes connect
and sometimes it will not.

842
00:45:35,890 --> 00:45:38,480
So, just keep that in mind

843
00:45:38,480 --> 00:45:40,530
if you want to economize and save a buck

844
00:45:40,530 --> 00:45:43,063
or two on a cheap wireless camera.

845
00:45:43,063 --> 00:45:47,150
So, thank you very much for
attending my Defcon talk.

846
00:45:47,150 --> 00:45:50,980
It's been a real pleasure to
spend this time with you today.

847
00:45:50,980 --> 00:45:52,613
So thanks.

