1
00:00:02,950 --> 00:00:04,950
- Hi, and welcome to our talk.

2
00:00:04,950 --> 00:00:06,230
My name is Guillaume Fournier,

3
00:00:06,230 --> 00:00:08,250
I'm a security engineer at Datadog.

4
00:00:08,250 --> 00:00:11,390
And today Sylvain and I are
going to present the rootkits

5
00:00:11,390 --> 00:00:14,000
that we implemented using eBPF.

6
00:00:14,000 --> 00:00:16,140
If you don't know what
eBPF is, don't worry,

7
00:00:16,140 --> 00:00:18,260
we are going to present this technology

8
00:00:18,260 --> 00:00:19,810
and tell you everything you need to know

9
00:00:19,810 --> 00:00:21,410
in order to understand the talk.

10
00:00:22,950 --> 00:00:25,800
So let's start with a few words about us.

11
00:00:25,800 --> 00:00:27,900
We are the cloud workload security team.

12
00:00:27,900 --> 00:00:29,640
We usually use eBPF for good.

13
00:00:29,640 --> 00:00:32,110
And our goal is to detect
threats at runtime.

14
00:00:32,110 --> 00:00:34,580
Everything we do is added
to the Datadog engine,

15
00:00:34,580 --> 00:00:36,190
which is an open source project.

16
00:00:36,190 --> 00:00:39,410
So feel free to check it
out if you are interested.

17
00:00:39,410 --> 00:00:40,830
That being said, for DEFCON,

18
00:00:40,830 --> 00:00:43,330
we decided to use everything
we knew about eBPF

19
00:00:43,330 --> 00:00:46,080
to build the ultimate rootkits.

20
00:00:46,080 --> 00:00:48,720
So, as I said before, we
are going to start the talk

21
00:00:48,720 --> 00:00:50,930
with a brief introduction to eBPF.

22
00:00:50,930 --> 00:00:52,490
Then Sylvain will take it over

23
00:00:52,490 --> 00:00:54,820
to talk about how we
implemented obfuscation

24
00:00:54,820 --> 00:00:57,620
and persistent access in our rootkits.

25
00:00:57,620 --> 00:00:58,790
After that I will come back

26
00:00:58,790 --> 00:01:00,900
to present the command-and-control feature

27
00:01:00,900 --> 00:01:04,340
along with some data
exfiltration examples,

28
00:01:04,340 --> 00:01:06,140
and then I will talk about
the network discovery,

29
00:01:06,140 --> 00:01:08,350
and RASP bypass features of the rootkits.

30
00:01:08,350 --> 00:01:11,300
And finally Sylvain will
present a few detection

31
00:01:11,300 --> 00:01:13,200
and mitigation strategies
that you can follow

32
00:01:13,200 --> 00:01:15,633
to detect rootkits such as ours.

33
00:01:17,630 --> 00:01:19,643
All right, so let's start with eBPF.

34
00:01:20,500 --> 00:01:24,090
EBPF stands for extended
Berkeley Packet Filter.

35
00:01:24,090 --> 00:01:27,150
It is a set of technologies
that can run sandbox programs

36
00:01:27,150 --> 00:01:30,150
in the Linux kernel without
changing the kernel source code

37
00:01:30,150 --> 00:01:32,360
or having to load kernel modules.

38
00:01:32,360 --> 00:01:35,300
It was initially designed
for nitro packet processing,

39
00:01:35,300 --> 00:01:38,060
but many new use cases
were progressively added.

40
00:01:38,060 --> 00:01:40,220
So for example, we can now use eBPF

41
00:01:40,220 --> 00:01:42,180
to do kernel performance tracing

42
00:01:42,180 --> 00:01:46,700
along with network security and
runtime security in general.

43
00:01:46,700 --> 00:01:48,640
So how does it work?

44
00:01:48,640 --> 00:01:51,170
So eBPF is simply a two-step process.

45
00:01:51,170 --> 00:01:53,500
First, you have to load your eBPF programs

46
00:01:53,500 --> 00:01:56,270
in the Linux kernel and then
you need to tell the kernel

47
00:01:56,270 --> 00:01:58,660
how to trigger your programs.

48
00:01:58,660 --> 00:02:01,300
So let's have a look at the first step.

49
00:02:01,300 --> 00:02:03,440
EBPF programs are written in C.

50
00:02:03,440 --> 00:02:06,100
So it's not exactly C, it's
more like a subset of C

51
00:02:06,100 --> 00:02:09,180
because of many restrictions
that eBPF has to follow.

52
00:02:09,180 --> 00:02:11,150
But I'm gonna talk about this later.

53
00:02:11,150 --> 00:02:14,110
So once you have your C program,

54
00:02:14,110 --> 00:02:16,643
you can use LLVM to
generate eBPF bytecode,

55
00:02:17,500 --> 00:02:19,760
which you can then load into the kernel

56
00:02:19,760 --> 00:02:22,007
using the BPF syscall.

57
00:02:22,007 --> 00:02:25,210
EBPF programs are really
made of two different things,

58
00:02:25,210 --> 00:02:28,310
eBPF maps and the actual program.

59
00:02:28,310 --> 00:02:31,470
So there are a lot of
different types of eBPF maps,

60
00:02:31,470 --> 00:02:32,790
but all you need to know

61
00:02:32,790 --> 00:02:36,250
is that they are the
only way to persist data

62
00:02:36,250 --> 00:02:39,270
generated by your eBPF programs.

63
00:02:39,270 --> 00:02:42,070
Similarly there are a lot
of different program types

64
00:02:42,070 --> 00:02:44,383
and each program type
has its own use case.

65
00:02:45,280 --> 00:02:47,150
However, regardless of the program type,

66
00:02:47,150 --> 00:02:49,790
each program has to go through the same

67
00:02:49,790 --> 00:02:51,310
following two phases.

68
00:02:51,310 --> 00:02:53,830
So the first one is the verifier step.

69
00:02:53,830 --> 00:02:56,320
So I will talk about
this later, but for now,

70
00:02:56,320 --> 00:03:00,340
just know that this ensures
that your program is valid.

71
00:03:00,340 --> 00:03:04,880
And second, your eBPF bytecode

72
00:03:04,880 --> 00:03:06,700
will be converted into machine code

73
00:03:06,700 --> 00:03:08,980
by a just-in-time compiler.

74
00:03:08,980 --> 00:03:10,740
And when those two phases succeed,

75
00:03:10,740 --> 00:03:13,093
your program is ready to be executed.

76
00:03:15,940 --> 00:03:18,580
Step two is attaching eBPF programs.

77
00:03:18,580 --> 00:03:21,700
So in other words, this is
when you tell the kernel

78
00:03:21,700 --> 00:03:24,160
how to trigger your program.

79
00:03:24,160 --> 00:03:26,270
So there are many different program types

80
00:03:26,270 --> 00:03:27,510
and I can't present them all,

81
00:03:27,510 --> 00:03:30,000
but I'm just going to
talk about four of them.

82
00:03:30,000 --> 00:03:33,270
So for example, you can use kprobe

83
00:03:33,270 --> 00:03:34,760
to trigger any BPF program

84
00:03:34,760 --> 00:03:38,450
whenever a specific symbol
in the kernel is called.

85
00:03:38,450 --> 00:03:40,500
Tracepoints are similar to kprobes,

86
00:03:40,500 --> 00:03:43,270
but the hook points on
which they can be attached

87
00:03:43,270 --> 00:03:46,970
have to be declared manually
by the kernel developers.

88
00:03:46,970 --> 00:03:50,100
Those two programs
require an older syscall

89
00:03:50,100 --> 00:03:52,210
in order to be attached.

90
00:03:52,210 --> 00:03:55,790
And this is called as the
perf_ event_ open syscall.

91
00:03:55,790 --> 00:03:58,030
So the other two program
types I wanted to talk about

92
00:03:58,030 --> 00:04:02,660
are TC classifiers, so it's
sched_cls and XDP programs.

93
00:04:02,660 --> 00:04:07,230
So those program types can be
used to do packet processing.

94
00:04:07,230 --> 00:04:10,090
So whenever some network
traffic is detected

95
00:04:10,090 --> 00:04:13,810
at the host level or at a
specific network interface level,

96
00:04:13,810 --> 00:04:17,860
those two require the
netlink to be attached.

97
00:04:17,860 --> 00:04:19,260
And the only thing to remember here

98
00:04:19,260 --> 00:04:21,740
is that each program
type has its own set up

99
00:04:21,740 --> 00:04:24,343
and does not require a
different level of access.

100
00:04:25,760 --> 00:04:28,050
Another very important fact about eBPF

101
00:04:28,050 --> 00:04:30,310
is that the BPF maps can be shared

102
00:04:30,310 --> 00:04:31,740
between different programs

103
00:04:31,740 --> 00:04:33,753
regardless of their program types.

104
00:04:37,180 --> 00:04:39,900
All right, so the eBPF verifier.

105
00:04:39,900 --> 00:04:44,190
So the verifier is used to
ensure that eBPF programs

106
00:04:44,190 --> 00:04:46,890
will finish and won't crash.

107
00:04:46,890 --> 00:04:50,010
To do so it's really just a list of rules

108
00:04:50,010 --> 00:04:51,720
that the verifier checks

109
00:04:51,720 --> 00:04:55,050
and your program has to
comply with those rules.

110
00:04:55,050 --> 00:04:57,760
So for example, your
program has to finish,

111
00:04:57,760 --> 00:04:59,700
it cannot be like an infinite loop.

112
00:04:59,700 --> 00:05:04,130
So your program has to be
a directed acyclic graph.

113
00:05:04,130 --> 00:05:05,520
You can't have unreachable code,

114
00:05:05,520 --> 00:05:07,770
you can't have unchecked dereferences.

115
00:05:07,770 --> 00:05:11,440
Your stack size is limited
and your overall program size

116
00:05:11,440 --> 00:05:12,490
is also limited.

117
00:05:12,490 --> 00:05:14,750
And finally, one of the
most infamous features

118
00:05:14,750 --> 00:05:18,590
of the verifier is it's
very cryptic outputs.

119
00:05:18,590 --> 00:05:21,247
So basically if your program
doesn't pass the verifier step,

120
00:05:21,247 --> 00:05:24,500
you will have a huge log of everything

121
00:05:24,500 --> 00:05:26,330
that the verifier looked into

122
00:05:26,330 --> 00:05:31,330
and eventually some kind of
error telling you what happens.

123
00:05:31,790 --> 00:05:33,770
But yeah, basically you are in

124
00:05:33,770 --> 00:05:35,723
for a very painful beginning session.

125
00:05:37,440 --> 00:05:41,070
Last but not least, eBPF
comes with a list of helpers

126
00:05:41,070 --> 00:05:42,980
that will help you access data

127
00:05:42,980 --> 00:05:44,420
or executive operations

128
00:05:44,420 --> 00:05:47,359
that you wouldn't be
able to write natively.

129
00:05:47,359 --> 00:05:51,290
For example, you have context
helpers, you have map helpers,

130
00:05:51,290 --> 00:05:53,700
a lot of things that you
wouldn't be able to write in C

131
00:05:53,700 --> 00:05:57,890
and that you would need
external instrumentation to do.

132
00:05:57,890 --> 00:06:00,790
In short, you have about 160 helpers.

133
00:06:00,790 --> 00:06:03,610
And most of the heavy
lifting of your eBPF programs

134
00:06:03,610 --> 00:06:06,073
will be based on those helpers.

135
00:06:09,340 --> 00:06:11,710
So that concludes this
introduction to eBPF.

136
00:06:11,710 --> 00:06:13,520
And I will hand it over to you, Sylvain,

137
00:06:13,520 --> 00:06:16,420
so that you can kick off the
presentation of the rootkits.

138
00:06:17,520 --> 00:06:19,090
- Thank you, Guillaume.

139
00:06:19,090 --> 00:06:20,530
Before we get into the details,

140
00:06:20,530 --> 00:06:23,370
let's see why eBPF is an
interesting technology

141
00:06:23,370 --> 00:06:24,423
to write a rootkit.

142
00:06:26,360 --> 00:06:27,860
First, the safety guarantee.

143
00:06:27,860 --> 00:06:30,610
Broad eBPF mean that a bird in our rootkit

144
00:06:30,610 --> 00:06:32,723
cannot crush the host.

145
00:06:32,723 --> 00:06:36,530
(indistinct) will not cause
any low message to be emitted.

146
00:06:36,530 --> 00:06:38,370
The user therefore has no way to know

147
00:06:38,370 --> 00:06:40,130
that something actually went wrong

148
00:06:40,130 --> 00:06:42,513
and notice the presence of the rootkit.

149
00:06:44,170 --> 00:06:46,270
As we saw earlier, the eBPF bytecode

150
00:06:46,270 --> 00:06:47,980
is converted to native code.

151
00:06:47,980 --> 00:06:50,450
And the number of instruction is limited,

152
00:06:50,450 --> 00:06:53,290
which limits by extension,
the performance impact

153
00:06:53,290 --> 00:06:55,740
that our rootkit can have on the machine

154
00:06:55,740 --> 00:06:58,113
that could otherwise be
detected by the user.

155
00:06:59,190 --> 00:07:00,660
On the commercial side,

156
00:07:00,660 --> 00:07:03,640
the eBPF is used by an
increasing number of vendors

157
00:07:03,640 --> 00:07:04,770
in various use cases,

158
00:07:04,770 --> 00:07:07,820
network monitoring security, for instance.

159
00:07:07,820 --> 00:07:09,700
With eBPF becoming widespread,

160
00:07:09,700 --> 00:07:11,990
returns of one product being abused,

161
00:07:11,990 --> 00:07:14,563
too many issues programs also increases.

162
00:07:15,410 --> 00:07:17,490
The safety guarantee
we just told you about

163
00:07:17,490 --> 00:07:19,640
should not give the
security and (indistinct)

164
00:07:19,640 --> 00:07:21,183
before filling of security.

165
00:07:24,940 --> 00:07:26,910
There's a lot of activity around eBPF

166
00:07:26,910 --> 00:07:29,330
and each new version of the Linux kernel

167
00:07:29,330 --> 00:07:31,730
comes with a new set of eBPF helpers,

168
00:07:31,730 --> 00:07:33,960
bringing new capabilities.

169
00:07:33,960 --> 00:07:35,560
As we wanted our rootkit to run

170
00:07:35,560 --> 00:07:38,550
on a widely used distribution on Linux

171
00:07:38,550 --> 00:07:42,380
such as RHEL/CentOS Linux,
or the latest Ubuntu LTS,

172
00:07:42,380 --> 00:07:47,040
we used a limited number of
helpers using RHEL/CentOS

173
00:07:47,040 --> 00:07:49,830
or a feature like KRSI
will have probably made

174
00:07:49,830 --> 00:07:51,730
the development of the rootkit easier.

175
00:07:55,040 --> 00:07:57,240
One of the primary tasks of a rootkit

176
00:07:57,240 --> 00:08:00,980
is to ask itself, what
does it mean in our case?

177
00:08:00,980 --> 00:08:04,010
EBPF programs are bound
to a running process.

178
00:08:04,010 --> 00:08:05,880
If this process gets killed,

179
00:08:05,880 --> 00:08:09,100
all the attached eBPF
programs will be unloaded.

180
00:08:09,100 --> 00:08:09,940
For that reason,

181
00:08:09,940 --> 00:08:12,590
it is essential that we
boast either our program

182
00:08:12,590 --> 00:08:14,453
and protect it from being killed.

183
00:08:16,370 --> 00:08:19,360
The eBPF programs and
maps used by the rootkit

184
00:08:19,360 --> 00:08:22,470
should also be hidden and we
should forbid other programs

185
00:08:22,470 --> 00:08:25,170
to gain access to them, so
there are five descriptors.

186
00:08:27,130 --> 00:08:29,153
So let's see a rootkit in action.

187
00:08:32,110 --> 00:08:34,693
So let's start with kit,
would give us its PID.

188
00:08:36,460 --> 00:08:38,800
Then we can try your PS kernel

189
00:08:38,800 --> 00:08:42,410
in order to see if we can
detect it from the output.

190
00:08:42,410 --> 00:08:47,210
We can try using its
preface entry and nothing.

191
00:08:47,210 --> 00:08:49,780
We can even try using your such file

192
00:08:51,250 --> 00:08:53,563
or even a relative pass.

193
00:08:55,830 --> 00:08:58,873
And we still have the same
issue, no such file or directory.

194
00:09:00,020 --> 00:09:02,080
And finally, we can try to send a signal

195
00:09:02,940 --> 00:09:07,940
to see what happened, and we
get no such process error.

196
00:09:12,010 --> 00:09:14,740
Your prescription
capabilities of our rootkit

197
00:09:14,740 --> 00:09:17,950
mainly rely on the use of two BPF helpers.

198
00:09:17,950 --> 00:09:21,660
So BPF provides user helper
arose our BPF program

199
00:09:21,660 --> 00:09:23,500
to ride into machinery of the process

200
00:09:23,500 --> 00:09:25,247
that issues the syscall.

201
00:09:25,247 --> 00:09:27,580
This can be used for instance
to alter the other data

202
00:09:27,580 --> 00:09:29,403
that is returned by your syscall.

203
00:09:30,490 --> 00:09:33,670
It's also possible to alter
the syscall arguments.

204
00:09:33,670 --> 00:09:35,500
So it's one caveat with this helper,

205
00:09:35,500 --> 00:09:37,140
the memory to be modified

206
00:09:37,140 --> 00:09:40,080
has to be mapped into the kernel space.

207
00:09:40,080 --> 00:09:43,430
Otherwise a minor or major
pitfall will be triggered

208
00:09:43,430 --> 00:09:45,763
causing the BPF provider
user call to fail.

209
00:09:48,240 --> 00:09:52,710
User BPF helper is to ease
the BPF override return.

210
00:09:52,710 --> 00:09:54,420
This one allows you to change the return

211
00:09:54,420 --> 00:09:57,690
that you have a syscall and
as an interesting property.

212
00:09:57,690 --> 00:10:00,540
If this helper is used
at the syscall exit,

213
00:10:00,540 --> 00:10:01,990
it will simply change the return

214
00:10:01,990 --> 00:10:03,710
that you will do at the syscall.

215
00:10:03,710 --> 00:10:05,370
But if we use it at the
entry of the syscall,

216
00:10:05,370 --> 00:10:08,313
the execution of the syscall
will be completely skipped.

217
00:10:09,170 --> 00:10:11,090
It is important to note that this helper

218
00:10:11,090 --> 00:10:14,373
can only be used at the entry
of the syscall or at the exit.

219
00:10:18,240 --> 00:10:21,970
So let's see how obfuscation
of a file actually works.

220
00:10:21,970 --> 00:10:24,670
At startup, the rootkit
will populate the map

221
00:10:24,670 --> 00:10:26,537
with the pass of it's PID folder.

222
00:10:27,800 --> 00:10:32,800
Now the user space issues a
file with syscall such as stat.

223
00:10:32,934 --> 00:10:35,103
The syscall usually come in two forms,

224
00:10:35,980 --> 00:10:39,430
one that accept the pass
to the file as a string,

225
00:10:39,430 --> 00:10:42,480
another one that accepts
the VFS for the file,

226
00:10:42,480 --> 00:10:44,980
but the user space program
must have previous (indistinct)

227
00:10:44,980 --> 00:10:46,080
using an open syscall.

228
00:10:47,780 --> 00:10:49,690
So let's consider the former.

229
00:10:49,690 --> 00:10:51,560
To properly identify the targeted file,

230
00:10:51,560 --> 00:10:54,510
the rootkit needs to do an
accurate resolution of the pass

231
00:10:54,510 --> 00:10:57,400
as the pass specified
could be a relative pass.

232
00:10:57,400 --> 00:10:58,323
At the entry of the syscall,

233
00:10:58,323 --> 00:11:01,350
that is not in context to the resolution.

234
00:11:01,350 --> 00:11:04,120
So we need to go deeper
in the kernel in our case,

235
00:11:04,120 --> 00:11:05,940
in DBFS code.

236
00:11:05,940 --> 00:11:06,900
So we are at the region,

237
00:11:06,900 --> 00:11:09,890
but at this point we
cannot block the syscall

238
00:11:09,890 --> 00:11:12,350
as we are outside of
the override of points

239
00:11:12,350 --> 00:11:14,980
for the eBPF override return helper.

240
00:11:14,980 --> 00:11:16,830
So the only thing that we can do

241
00:11:16,830 --> 00:11:18,440
is to change the return value

242
00:11:18,440 --> 00:11:21,690
so that the user space believes
that the syscall failed.

243
00:11:21,690 --> 00:11:23,730
We also need to scrub the
content of the switcher

244
00:11:23,730 --> 00:11:26,830
that could have been filled by the kernel.

245
00:11:30,140 --> 00:11:31,780
Now let's consider the latter,

246
00:11:31,780 --> 00:11:34,190
the ratio that accept the file as return.

247
00:11:34,190 --> 00:11:35,830
We do the same passage version as before,

248
00:11:35,830 --> 00:11:37,560
but instead of just pretending
it was the descriptor file

249
00:11:37,560 --> 00:11:40,313
that the syscall failed, we
still have the file descriptor

250
00:11:40,313 --> 00:11:43,830
that we can edit located into an eBPF map.

251
00:11:43,830 --> 00:11:45,660
If the same processes issue the syscall

252
00:11:45,660 --> 00:11:47,050
with the same file descriptor,

253
00:11:47,050 --> 00:11:49,840
we can add the syscall
entry return an error

254
00:11:49,840 --> 00:11:51,500
and block the syscall.

255
00:11:51,500 --> 00:11:53,940
In this situation, the
user has no way to know

256
00:11:53,940 --> 00:11:55,820
that the file descriptor exist.

257
00:11:55,820 --> 00:11:58,290
And as we control the read syscall,

258
00:11:58,290 --> 00:12:00,310
we can also hide all the references

259
00:12:00,310 --> 00:12:02,343
to the file descriptor in proxy phase.

260
00:12:06,020 --> 00:12:08,890
Blocking the syscall that
accept the PID as an argument

261
00:12:08,890 --> 00:12:11,130
is trivial if you're
using BPF override return,

262
00:12:11,130 --> 00:12:12,823
same for in kernel modules.

263
00:12:17,060 --> 00:12:18,393
Now let's see your demo.

264
00:12:19,410 --> 00:12:23,023
Let's demo the obfuscation
of our BPF programs and maps.

265
00:12:25,630 --> 00:12:27,960
So we still have the rootkit started

266
00:12:27,960 --> 00:12:30,890
and we've released the
maps and the programs,

267
00:12:30,890 --> 00:12:32,710
thanks to the eBPF tool kernel online.

268
00:12:32,710 --> 00:12:35,630
We can't see anything
related to the rootkit.

269
00:12:35,630 --> 00:12:38,450
Now if we (indistinct) kprobes and maps,

270
00:12:38,450 --> 00:12:40,320
and we list, again, the programs,

271
00:12:40,320 --> 00:12:42,690
we can see the program
related to the binary,

272
00:12:42,690 --> 00:12:44,740
but still nothing related to the rootkit.

273
00:12:46,720 --> 00:12:49,680
Then we can even try checking the kprobes

274
00:12:49,680 --> 00:12:51,730
and still nothing related to the rootkit.

275
00:12:55,510 --> 00:12:59,680
The ID is to hook into
the eBPF syscall itself,

276
00:12:59,680 --> 00:13:01,720
two things are required here.

277
00:13:01,720 --> 00:13:03,000
We want to avoid the real space

278
00:13:03,000 --> 00:13:05,830
to utilize the two IDs of our own duties

279
00:13:05,830 --> 00:13:08,550
using the BPF_prog_get_next_id command.

280
00:13:08,550 --> 00:13:10,510
And we need to prevent the user space

281
00:13:10,510 --> 00:13:13,710
from getting a file descriptor
to the program or map

282
00:13:13,710 --> 00:13:15,730
from the ID using BPF_prog_get_fd_by_id

283
00:13:17,440 --> 00:13:20,440
basically to prevent ID guessing.

284
00:13:20,440 --> 00:13:22,970
When these operations are
handled by the rootkit,

285
00:13:22,970 --> 00:13:24,720
the user space is not able to view

286
00:13:24,720 --> 00:13:26,923
or modify our programs and match.

287
00:13:29,170 --> 00:13:32,660
BPF provider user is a
crucial part of our rootkit

288
00:13:33,540 --> 00:13:35,200
but it comes with a pitfall.

289
00:13:35,200 --> 00:13:38,480
While an eBPF program that
makes use of it is loaded,

290
00:13:38,480 --> 00:13:41,670
the journal printer pretty
scary, but legitimate message

291
00:13:41,670 --> 00:13:43,487
in the kernel ring buffer.

292
00:13:45,930 --> 00:13:48,823
So let's see how the rootkit handle this.

293
00:13:51,180 --> 00:13:53,500
First, let's check what
is the current statues

294
00:13:53,500 --> 00:13:56,683
of the kernel ring buffer
using the kernel dnesg.

295
00:13:58,930 --> 00:14:00,433
So nothing special here.

296
00:14:01,840 --> 00:14:04,160
And we can even start
a cache on the device

297
00:14:04,160 --> 00:14:05,763
used by the ring buffer.

298
00:14:07,320 --> 00:14:08,623
Then we start the rootkit.

299
00:14:10,500 --> 00:14:13,110
So we can see that the cache terminated

300
00:14:13,110 --> 00:14:15,683
with a pretty legit looking message.

301
00:14:17,380 --> 00:14:21,190
We can recheck the kernel ringer buffer,

302
00:14:21,190 --> 00:14:23,490
thanks to the message kernel online,

303
00:14:23,490 --> 00:14:26,643
and we can only see
legit-looking messages,

304
00:14:29,410 --> 00:14:30,363
but I need more.

305
00:14:31,370 --> 00:14:35,100
And then we can stop the
rootkit and we can run again,

306
00:14:35,100 --> 00:14:36,660
the message kernel online

307
00:14:36,660 --> 00:14:41,313
in order to see what was
overridden by the rootkit.

308
00:14:42,880 --> 00:14:45,043
So let's see how it works.

309
00:14:46,120 --> 00:14:49,010
In this diagram, Ronald is
waiting for a new message

310
00:14:49,010 --> 00:14:51,332
and is blocked on a red syscall.

311
00:14:51,332 --> 00:14:54,911
Two BPF programs are loaded
secondly by the rootkit.

312
00:14:54,911 --> 00:14:58,170
The first one, which doesn't
choose eBPF provide user

313
00:14:58,170 --> 00:15:01,150
work on our red syscall
and we make it written zero

314
00:15:01,150 --> 00:15:03,370
and we'll write legit-looking message.

315
00:15:03,370 --> 00:15:05,450
This will guarantee
that the warning message

316
00:15:05,450 --> 00:15:08,683
is related to the BPF
ProLite user won't be read.

317
00:15:09,990 --> 00:15:13,940
Then the second program using
BPF ProLite user is loaded.

318
00:15:13,940 --> 00:15:16,700
At this point, the red
syscall can be unblocked

319
00:15:16,700 --> 00:15:19,360
and we can override the
content of the warning messages

320
00:15:19,360 --> 00:15:20,893
with legit-looking messages.

321
00:15:23,980 --> 00:15:25,740
Another important task for the rootkit

322
00:15:25,740 --> 00:15:27,270
is to set up a persistent access

323
00:15:27,270 --> 00:15:29,180
across reboots, for instance.

324
00:15:29,180 --> 00:15:32,100
The rootkit can copy
itself to a dedicated place

325
00:15:32,100 --> 00:15:34,840
in either it's binary file
with the same mechanism

326
00:15:34,840 --> 00:15:35,840
that we already saw.

327
00:15:37,290 --> 00:15:39,020
For the persistent access to the system,

328
00:15:39,020 --> 00:15:41,600
we can use a generic method
close to what we described

329
00:15:41,600 --> 00:15:42,840
in the obfuscation path.

330
00:15:42,840 --> 00:15:45,860
We can replace the content
of some critical files

331
00:15:45,860 --> 00:15:50,513
read by the root demands,
such as crotab or even sshd.

332
00:15:51,350 --> 00:15:53,270
Let's see an example targeting sshd

333
00:15:53,270 --> 00:15:55,593
and using the reader override approach.

334
00:15:57,690 --> 00:16:01,050
So the approach here is to open an sshd

335
00:16:01,050 --> 00:16:03,680
to the authorized key files.

336
00:16:03,680 --> 00:16:05,670
Only sshd should be impacted,

337
00:16:05,670 --> 00:16:07,640
meaning the file will remain the same

338
00:16:07,640 --> 00:16:09,670
for the user point of view.

339
00:16:09,670 --> 00:16:12,670
And we want to have it available
to the command-and-control.

340
00:16:13,810 --> 00:16:15,323
So let's see this in action.

341
00:16:18,140 --> 00:16:21,963
So let's take the authorized
keys content first.

342
00:16:24,790 --> 00:16:27,950
So we can see that only
one key is present.

343
00:16:27,950 --> 00:16:29,780
So let's start the connection

344
00:16:29,780 --> 00:16:33,720
and it's in that password is required.

345
00:16:33,720 --> 00:16:37,050
So now we're going to start the rootkit

346
00:16:38,148 --> 00:16:39,670
and we are going to specify

347
00:16:39,670 --> 00:16:44,000
that we want to inject an SSH
key to the authorized keys

348
00:16:44,000 --> 00:16:45,237
but only for SSH.

349
00:16:49,587 --> 00:16:52,363
So we can try your connection again,

350
00:16:54,740 --> 00:16:56,943
and it seems to be successful.

351
00:16:58,030 --> 00:16:59,790
And now we can check what is the content

352
00:16:59,790 --> 00:17:02,120
of the authorized key from
the user point of view

353
00:17:02,120 --> 00:17:04,263
and nothing changed apparently.

354
00:17:07,940 --> 00:17:10,070
Persistent access to
an application database

355
00:17:10,070 --> 00:17:13,630
can also be set up using
another type of eBPF program.

356
00:17:13,630 --> 00:17:17,600
Uprobes eBPF programs attached
to user space function.

357
00:17:17,600 --> 00:17:21,760
In addition to being safer
and easier to use than ptrace,

358
00:17:21,760 --> 00:17:24,010
they offer a valuable advantage.

359
00:17:24,010 --> 00:17:27,170
The kernel will automatically
set up for us the hooks

360
00:17:27,170 --> 00:17:29,710
on every instance of the program.

361
00:17:29,710 --> 00:17:33,600
Let's see a uprobe
demonstration using (indistinct)

362
00:17:35,070 --> 00:17:37,420
So first, let's try to
connect to (indistinct)

363
00:17:37,420 --> 00:17:39,803
using the word bonsoir as password.

364
00:17:45,530 --> 00:17:49,300
This one seems to be the
good one, then trying hello,

365
00:17:49,300 --> 00:17:51,150
and this one is rejected.

366
00:17:51,150 --> 00:17:52,370
Now we start the rootkit

367
00:17:54,870 --> 00:17:57,360
and we'll get the opposite treasured.

368
00:17:57,360 --> 00:17:59,743
Now the value password is hello.

369
00:18:01,460 --> 00:18:03,590
So the idea here is to hook

370
00:18:03,590 --> 00:18:06,370
on the md5_cript_verify function

371
00:18:06,370 --> 00:18:07,570
of a progressive creator

372
00:18:07,570 --> 00:18:10,630
that check whether the
user provided the right MD5

373
00:18:10,630 --> 00:18:13,240
for its role, passwords, and the challenge

374
00:18:13,240 --> 00:18:15,140
sent by the server.

375
00:18:15,140 --> 00:18:19,300
Overwriting the expected
hash contained in shadow_pass

376
00:18:19,300 --> 00:18:22,060
with a known value makes
the comparison succeeded

377
00:18:22,060 --> 00:18:26,120
and give persistent access to
the database to the attacher.

378
00:18:26,120 --> 00:18:28,950
Now I will hand over to
Guillaume that will show you

379
00:18:28,950 --> 00:18:31,550
the command-and-control
capabilities of the rootkit.

380
00:18:33,410 --> 00:18:34,460
- Thank you, Sylvain.

381
00:18:34,460 --> 00:18:36,410
Let's talk about the
command-and-control feature

382
00:18:36,410 --> 00:18:37,260
of the rootkits.

383
00:18:37,260 --> 00:18:39,420
So what exactly do we want to do?

384
00:18:39,420 --> 00:18:41,690
We want to be able to send
commands to the rootkits

385
00:18:41,690 --> 00:18:43,930
to exfiltrate data and
to get remote access

386
00:18:43,930 --> 00:18:45,530
to the infected hosts.

387
00:18:45,530 --> 00:18:48,690
Unfortunately, there are a
few eBPF-related challenges

388
00:18:48,690 --> 00:18:52,230
that we need to face in order
to implement those features.

389
00:18:52,230 --> 00:18:55,430
First, you can't initiate
a connection with eBPF.

390
00:18:55,430 --> 00:18:57,920
Second, you can't open a port.

391
00:18:57,920 --> 00:19:02,040
However, eBPF can hijack
an existing connection.

392
00:19:02,040 --> 00:19:03,800
So in order to show up this feature,

393
00:19:03,800 --> 00:19:06,647
we have set up a very simple
infrastructure on AWS.

394
00:19:07,720 --> 00:19:10,300
A web app was installed on any C2 instance

395
00:19:10,300 --> 00:19:12,830
and we used a Classic Load Balancer

396
00:19:12,830 --> 00:19:16,900
to redirect HTTPS traffic
to our instance over HTTP.

397
00:19:16,900 --> 00:19:18,760
In other words, the TLS termination

398
00:19:18,760 --> 00:19:21,260
is done at the Load Balancer level

399
00:19:21,260 --> 00:19:23,480
and its eBPF requests are sent

400
00:19:23,480 --> 00:19:26,210
to our instance and encrypted.

401
00:19:26,210 --> 00:19:29,240
So our goal is to implement CNC

402
00:19:29,240 --> 00:19:32,320
by hijacking the network
traffic to our web app.

403
00:19:32,320 --> 00:19:35,010
First, we need to figure
out which eBPF program types

404
00:19:35,010 --> 00:19:37,710
we're going to use in order
to implement this feature.

405
00:19:38,820 --> 00:19:42,670
Although eBPF provides a lot
of options to choose from,

406
00:19:42,670 --> 00:19:45,720
we decided to go with
two eBPF program types,

407
00:19:45,720 --> 00:19:49,090
XDP programs and TC classifier programs.

408
00:19:49,090 --> 00:19:51,660
So both of those programs

409
00:19:51,660 --> 00:19:54,863
are usually used to do deep
packet inspection use cases.

410
00:19:55,710 --> 00:19:58,670
And while XDP only works for ingress,

411
00:19:58,670 --> 00:20:02,740
TC works on both ingress
and egress traffic.

412
00:20:02,740 --> 00:20:04,980
Another difference between
the two program types

413
00:20:04,980 --> 00:20:07,380
is that XDP programs can be offered

414
00:20:07,380 --> 00:20:09,260
to the network interface controller,

415
00:20:09,260 --> 00:20:13,130
which essentially means that
your program will be run

416
00:20:13,130 --> 00:20:15,500
before the packet enters any subsystem

417
00:20:15,500 --> 00:20:16,923
into the network stack.

418
00:20:18,150 --> 00:20:20,880
On the other hand, TC
programs have to be attached

419
00:20:23,373 --> 00:20:27,190
to a network interface, but
much later in the network stack,

420
00:20:27,190 --> 00:20:30,963
which means that they are
triggered later in the kernel.

421
00:20:32,630 --> 00:20:34,640
With both programs, you can drop, allow,

422
00:20:34,640 --> 00:20:35,860
and modify your packets.

423
00:20:35,860 --> 00:20:37,500
And with an XDP programming,

424
00:20:37,500 --> 00:20:39,960
you can also retransmit a packet.

425
00:20:39,960 --> 00:20:42,960
This option is actually
super interesting for us

426
00:20:42,960 --> 00:20:47,733
because it means that you can
essentially receive and answer

427
00:20:47,733 --> 00:20:51,010
to a packet even before it
reaches the network stack,

428
00:20:51,010 --> 00:20:54,410
which in other words
means that you can do this

429
00:20:54,410 --> 00:20:57,370
even before it reaches any
kind of network firewall

430
00:20:57,370 --> 00:20:58,913
or monitoring on the hosts.

431
00:21:00,490 --> 00:21:03,610
Skipping the network side
also explains why XDP programs

432
00:21:03,610 --> 00:21:06,310
are mainly used for DDoS mitigation

433
00:21:06,310 --> 00:21:09,870
and TC programs are
usually used to monitor

434
00:21:09,870 --> 00:21:14,870
and secure network access at
the pod or container level.

435
00:21:15,060 --> 00:21:18,340
So what you need to remember
about this slide is that first,

436
00:21:18,340 --> 00:21:21,540
XDP programs can be used
to hide natural traffic

437
00:21:21,540 --> 00:21:23,220
from the kernel entirely

438
00:21:23,220 --> 00:21:26,930
and TC programs can be
used to exfiltrate data

439
00:21:26,930 --> 00:21:27,763
on its way out.

440
00:21:31,510 --> 00:21:34,160
First, let's see how we used XDP programs

441
00:21:34,160 --> 00:21:37,670
to receive commands with the rootkits.

442
00:21:37,670 --> 00:21:39,830
So we implemented a client for the rootkit

443
00:21:39,830 --> 00:21:41,980
and this client communicates
with the rootkit

444
00:21:41,980 --> 00:21:44,950
by sending simple https requests

445
00:21:44,950 --> 00:21:48,653
with custom routes and custom user agent.

446
00:21:49,660 --> 00:21:52,650
So after going through the Load Balancer,

447
00:21:52,650 --> 00:21:54,970
the request eventually reaches the host

448
00:21:54,970 --> 00:21:57,860
and triggers our XDP programs.

449
00:21:57,860 --> 00:22:01,900
Then our program pass the
requests, the http routes

450
00:22:01,900 --> 00:22:03,490
and understand that this request

451
00:22:03,490 --> 00:22:06,970
is not meant for the web
app, but it's meant for us.

452
00:22:06,970 --> 00:22:08,720
So after sending the other,

453
00:22:08,720 --> 00:22:11,130
sorry, after reading the user agents,

454
00:22:11,130 --> 00:22:13,080
the rootkit executes the
requests that come in

455
00:22:13,080 --> 00:22:14,960
and moves on to the final step.

456
00:22:14,960 --> 00:22:18,570
So this final step is probably
the most important one.

457
00:22:18,570 --> 00:22:20,380
It overrides the entire request

458
00:22:20,380 --> 00:22:23,620
with a simple health check request,

459
00:22:23,620 --> 00:22:26,750
and we do this for two different reasons.

460
00:22:26,750 --> 00:22:28,530
First, we don't want the manager's request

461
00:22:28,530 --> 00:22:29,530
to reach the web app

462
00:22:30,610 --> 00:22:32,880
or any kind of user space monitoring tool

463
00:22:32,880 --> 00:22:34,890
that might be bringing

464
00:22:34,890 --> 00:22:37,980
and that might detect the unusual traffic.

465
00:22:37,980 --> 00:22:40,460
And second, we want the
client to receive an answer

466
00:22:40,460 --> 00:22:43,263
in order to know if the
request was successful.

467
00:22:44,170 --> 00:22:45,540
So, as I said before,

468
00:22:45,540 --> 00:22:48,250
we could also have drop
the packet entirely,

469
00:22:48,250 --> 00:22:50,130
but since we're using TCP,

470
00:22:50,130 --> 00:22:52,770
the Load Balancer would have
retransmitted the packet

471
00:22:52,770 --> 00:22:55,810
over and over again until
the request times out.

472
00:22:55,810 --> 00:22:57,400
And this would have generated noise

473
00:22:57,400 --> 00:23:00,360
and increase our chances
of getting discovered.

474
00:23:00,360 --> 00:23:05,340
That said, if you were
working with a UDP server,

475
00:23:05,340 --> 00:23:08,223
this would be a totally valid strategy.

476
00:23:09,170 --> 00:23:10,003
So let's have a look

477
00:23:10,003 --> 00:23:12,953
at how we can send
Postgres kernels remotely.

478
00:23:15,660 --> 00:23:17,150
All right, so on the left of the screen,

479
00:23:17,150 --> 00:23:18,460
you can see two different shells.

480
00:23:18,460 --> 00:23:22,260
Those shells are connected
to the remote infected hosts

481
00:23:22,260 --> 00:23:25,110
on AWS and on the right,
this is my local shell

482
00:23:25,110 --> 00:23:27,123
and this is the attacker machine.

483
00:23:28,600 --> 00:23:29,440
Okay, so let's start

484
00:23:29,440 --> 00:23:33,390
with trying to log into
the Postgres database

485
00:23:33,390 --> 00:23:34,470
using the normal password.

486
00:23:34,470 --> 00:23:36,560
And again, the rootkit is not running yet.

487
00:23:36,560 --> 00:23:39,560
So as you can see, the
bonsoir passwords works fine.

488
00:23:39,560 --> 00:23:43,590
And then they start the rootkit
and restart to log in again

489
00:23:43,590 --> 00:23:46,270
and as expected and as you've seen before

490
00:23:46,270 --> 00:23:49,050
during Sylvain demo, it doesn't work.

491
00:23:49,050 --> 00:23:50,860
So you have to change into, hello,

492
00:23:50,860 --> 00:23:52,078
and this time it will work

493
00:23:52,078 --> 00:23:52,911
there you go.

494
00:23:52,911 --> 00:23:54,170
Okay, so we're gonna try
to do the same thing,

495
00:23:54,170 --> 00:23:57,320
but instead of hard
coding the new password

496
00:23:57,320 --> 00:24:01,350
with the rootkit, we're gonna
define remotely through C&C

497
00:24:01,350 --> 00:24:03,170
what the new password should be.

498
00:24:03,170 --> 00:24:06,520
So, as you can see, we
have a custom client

499
00:24:06,520 --> 00:24:08,933
that will make a request to its CPS,

500
00:24:10,139 --> 00:24:12,620
it needs to be a CPS
request to defcon.demo.dog

501
00:24:12,620 --> 00:24:15,090
and then we will provide both the role

502
00:24:15,090 --> 00:24:19,350
and the secret to override
the normal secret with.

503
00:24:19,350 --> 00:24:23,040
So the request that will go
through is a very simple one

504
00:24:23,040 --> 00:24:24,340
with the custom routes

505
00:24:24,340 --> 00:24:26,750
and the user agent will
contain the new password

506
00:24:26,750 --> 00:24:28,973
that will be used at runtime.

507
00:24:30,190 --> 00:24:34,170
So as expected, we get the 200
okay from the health check,

508
00:24:34,170 --> 00:24:36,570
which essentially means that we know

509
00:24:36,570 --> 00:24:41,200
that the new password now is
defcon and not hello anymore.

510
00:24:41,200 --> 00:24:42,820
So as you can see,
hello that doesn't work,

511
00:24:42,820 --> 00:24:46,177
but if I'm change it
to defcon, here you go.

512
00:24:48,450 --> 00:24:49,917
This time it does work.

513
00:24:51,520 --> 00:24:55,150
Okay, so this is how we send
the command to the rootkits.

514
00:24:55,150 --> 00:24:57,933
Now let's see how we can exfiltrate data.

515
00:24:59,460 --> 00:25:00,770
So to exfiltrate data,

516
00:25:00,770 --> 00:25:03,940
the client has to send an initial request

517
00:25:03,940 --> 00:25:06,560
to specify what kind of data
and what kind of resource

518
00:25:06,560 --> 00:25:08,030
we want to exfiltrate.

519
00:25:08,030 --> 00:25:10,710
So the XDP part of this process

520
00:25:10,710 --> 00:25:12,280
is basically the same as before,

521
00:25:12,280 --> 00:25:15,940
but this time the XDP programs
stores the network flow

522
00:25:15,940 --> 00:25:20,850
that made the request along
with the requested resource,

523
00:25:20,850 --> 00:25:23,130
sorry, in an eBPF map.

524
00:25:23,130 --> 00:25:25,070
And the reason why we do so

525
00:25:25,070 --> 00:25:29,200
is because when the web app
answers the health check,

526
00:25:29,200 --> 00:25:31,490
we want to be able to detect the packets

527
00:25:31,490 --> 00:25:34,460
that are meant to be
sent back to the clients.

528
00:25:34,460 --> 00:25:39,460
So when the XDP answer reaches
the TC egress classifier,

529
00:25:39,960 --> 00:25:43,040
our eBPF program looks at the network flow

530
00:25:43,040 --> 00:25:46,760
and overrides the answer
with the requested data.

531
00:25:46,760 --> 00:25:48,370
Now, the question is,

532
00:25:48,370 --> 00:25:51,070
what kind of data can you
exfiltrate with the rootkit?

533
00:25:53,650 --> 00:25:56,510
And the answer is, well,
pretty much anything

534
00:25:56,510 --> 00:25:58,350
that is accessible to eBPF.

535
00:25:58,350 --> 00:26:01,310
And the reason for that
is, as I said before,

536
00:26:01,310 --> 00:26:05,230
multiple program types can
share data through eBPF maps,

537
00:26:05,230 --> 00:26:08,750
regardless of what those
programs are supposed to do.

538
00:26:08,750 --> 00:26:12,590
So basically you can exfiltrate
things like file content,

539
00:26:12,590 --> 00:26:15,880
environment variables,
database dumps, in-memory data

540
00:26:15,880 --> 00:26:18,470
if you start looking at
the stacks of the programs.

541
00:26:18,470 --> 00:26:21,320
Anyway, you can pretty much
exfiltrate whatever you want.

542
00:26:22,610 --> 00:26:25,510
So let's have a look at a simple demo

543
00:26:25,510 --> 00:26:28,970
that we can exfiltrate
Postgres credentials

544
00:26:28,970 --> 00:26:32,183
along with the file
content of etcpasswrd demo.

545
00:26:35,890 --> 00:26:38,700
All right, so again, the
two shells on the left

546
00:26:38,700 --> 00:26:42,853
are the ones connected to
the infected hosts on AWS

547
00:26:43,750 --> 00:26:45,890
and on the right, this is my local shell.

548
00:26:45,890 --> 00:26:47,700
So the first request that I make here

549
00:26:47,700 --> 00:26:49,883
is to do Progres list,

550
00:26:51,940 --> 00:26:55,130
which basically means please
list all the credentials

551
00:26:55,130 --> 00:26:58,523
that you have detected so far
since the rootkit has started.

552
00:26:59,520 --> 00:27:00,690
And as you can see,

553
00:27:00,690 --> 00:27:03,010
the answer was, sort of
the health check answer

554
00:27:03,010 --> 00:27:05,600
was overridden with the content of a map

555
00:27:05,600 --> 00:27:07,850
that we used to store the passwords

556
00:27:07,850 --> 00:27:10,100
that we've collected at runtime.

557
00:27:10,100 --> 00:27:12,310
And again, remember that with Postgres,

558
00:27:12,310 --> 00:27:14,410
you don't need the
clear password to login.

559
00:27:14,410 --> 00:27:15,760
You just need the hash password

560
00:27:15,760 --> 00:27:17,493
that is stored in the database.

561
00:27:19,060 --> 00:27:19,893
Here you go.

562
00:27:19,893 --> 00:27:21,510
So now we're gonna try
to do the same thing

563
00:27:21,510 --> 00:27:24,273
to dump the contents of etc password.

564
00:27:25,580 --> 00:27:28,390
So to do so, this is a two-step process.

565
00:27:28,390 --> 00:27:30,850
The first thing you want
to do is tell the rootkits

566
00:27:30,850 --> 00:27:34,360
to start looking for this specific file.

567
00:27:34,360 --> 00:27:37,820
And as soon as a user space
process tries to open the file

568
00:27:37,820 --> 00:27:40,080
and read the content of the file,

569
00:27:40,080 --> 00:27:42,680
our rootkit will actually copy the data

570
00:27:42,680 --> 00:27:46,090
as it is sent to the
user space application

571
00:27:46,090 --> 00:27:49,940
and say that into an eBPF map

572
00:27:49,940 --> 00:27:52,140
so that it can be retrieved later.

573
00:27:52,140 --> 00:27:55,680
So this first request
will tell the rootkits

574
00:27:55,680 --> 00:27:58,580
to start looking for etc password.

575
00:27:58,580 --> 00:28:00,770
And now let's go back to the host

576
00:28:00,770 --> 00:28:04,380
and trigger some kind of pseudo operation

577
00:28:05,969 --> 00:28:08,793
so that our user space process
tries to open the file.

578
00:28:09,770 --> 00:28:10,677
Here you go.

579
00:28:11,670 --> 00:28:15,060
And then this time,
instead of saying, add,

580
00:28:15,060 --> 00:28:16,710
we're gonna say, get,

581
00:28:16,710 --> 00:28:21,290
and this will dump the content
of the etc password file.

582
00:28:21,290 --> 00:28:22,123
Here you go.

583
00:28:24,380 --> 00:28:26,410
All right, so the cool
thing about this technique

584
00:28:26,410 --> 00:28:30,060
is that it applies to any
un-encrypted network protocol.

585
00:28:30,060 --> 00:28:33,540
So for example, we also
implemented it for DNS,

586
00:28:33,540 --> 00:28:36,780
which means that you can actually
use it to do DNS spoofing.

587
00:28:36,780 --> 00:28:39,590
So the only difference between
the normal way of doing this

588
00:28:39,590 --> 00:28:44,260
and the DNS spoofing is that
instead of using a TC program

589
00:28:44,260 --> 00:28:47,640
to override the answer of the request,

590
00:28:47,640 --> 00:28:50,110
you will actually switch
to see an XDP program

591
00:28:50,110 --> 00:28:53,300
because DNS requests
are made from the host

592
00:28:53,300 --> 00:28:55,973
instead of received by the host.

593
00:28:57,880 --> 00:28:59,470
All right, so let's move on

594
00:28:59,470 --> 00:29:02,650
to our network discovery feature.

595
00:29:02,650 --> 00:29:04,410
So I know everybody knows what it is,

596
00:29:04,410 --> 00:29:05,760
but I have to say it anyway,

597
00:29:05,760 --> 00:29:08,530
network discovery is the
ability to discover machines

598
00:29:08,530 --> 00:29:09,890
and services on the network

599
00:29:09,890 --> 00:29:13,300
so that you know where you want to go next

600
00:29:13,300 --> 00:29:14,840
in the infrastructure.

601
00:29:14,840 --> 00:29:18,600
And also discovering services
is a super important step

602
00:29:18,600 --> 00:29:21,500
when you are trying to
pivot between hosts,

603
00:29:21,500 --> 00:29:23,080
because it will tell
you what kind of attacks

604
00:29:23,080 --> 00:29:24,770
you might want to try.

605
00:29:24,770 --> 00:29:25,603
So the rootkit

606
00:29:25,603 --> 00:29:28,340
has two different networks
discovery features.

607
00:29:28,340 --> 00:29:30,720
One of them is passive,
the other one is active.

608
00:29:30,720 --> 00:29:32,500
And you can control both of them

609
00:29:32,500 --> 00:29:34,283
through command-and-control.

610
00:29:35,520 --> 00:29:37,540
So I'm gonna get into more details later,

611
00:29:37,540 --> 00:29:39,740
but basically the only
difference between the two

612
00:29:39,740 --> 00:29:42,760
is the kind of networks
scanning you're looking for

613
00:29:42,760 --> 00:29:44,710
and also the level of traffic

614
00:29:44,710 --> 00:29:47,183
that you are willing to
generate on the network.

615
00:29:48,640 --> 00:29:52,290
So first, let's have a
look at the passive option.

616
00:29:52,290 --> 00:29:53,230
So the passive option

617
00:29:53,230 --> 00:29:56,240
is simply a basic network monitoring tool.

618
00:29:56,240 --> 00:29:58,220
So it will do pretty much the same thing

619
00:29:58,220 --> 00:30:01,750
as any other eBPF-based
network monitoring tool,

620
00:30:01,750 --> 00:30:03,040
which means that it will listen

621
00:30:03,040 --> 00:30:05,620
for any ingress or egress traffic

622
00:30:05,620 --> 00:30:07,100
and then generate a graph

623
00:30:07,100 --> 00:30:09,670
from all the collected network flows.

624
00:30:09,670 --> 00:30:12,000
It will also show you the amount of data

625
00:30:12,000 --> 00:30:15,230
that was sent per network flow.

626
00:30:15,230 --> 00:30:17,340
And to implement this feature,

627
00:30:17,340 --> 00:30:20,060
we used our TC and XDP programs.

628
00:30:20,060 --> 00:30:22,130
So the TC programs were used

629
00:30:22,130 --> 00:30:24,980
to monitor the egress
traffic and the XDP programs

630
00:30:24,980 --> 00:30:27,233
were used to monitor the ingress traffic.

631
00:30:29,050 --> 00:30:31,130
So for this version of the rootkits,

632
00:30:31,130 --> 00:30:35,150
we are limited to IPv4
and TCP UDP packets,

633
00:30:35,150 --> 00:30:38,230
that said support for
IPv6 and all the protocols

634
00:30:38,230 --> 00:30:40,233
could have been headed easily.

635
00:30:41,410 --> 00:30:43,770
So the reason why the
passive option is pretty cool

636
00:30:43,770 --> 00:30:48,010
is that it will not generate
any traffic on the network.

637
00:30:48,010 --> 00:30:49,970
In other words, it is basically impossible

638
00:30:49,970 --> 00:30:53,270
to detect that someone is
tapping into your network

639
00:30:53,270 --> 00:30:55,070
and more specifically at the network

640
00:30:57,747 --> 00:31:00,590
that creatures this
specific infected host.

641
00:31:00,590 --> 00:31:02,550
However, this doesn't work

642
00:31:02,550 --> 00:31:05,110
for services that do not communicate

643
00:31:05,110 --> 00:31:06,770
with the infected host.

644
00:31:06,770 --> 00:31:08,080
And so in other words,

645
00:31:08,080 --> 00:31:10,160
the graph will definitely not be complete.

646
00:31:10,160 --> 00:31:14,343
And that's also why we
implemented the active method.

647
00:31:17,120 --> 00:31:21,000
So the active method
is a simple ARP scanner

648
00:31:21,000 --> 00:31:22,780
along with a SYN scanner.

649
00:31:22,780 --> 00:31:26,260
So we implement it using
only our XDP programs,

650
00:31:26,260 --> 00:31:30,240
which means that the entire process

651
00:31:30,240 --> 00:31:34,740
is done without involving
the kernel stack.

652
00:31:34,740 --> 00:31:37,830
And although this will
be a slower process,

653
00:31:37,830 --> 00:31:41,730
you can use this method to
discover hosts and services

654
00:31:41,730 --> 00:31:44,080
that are reachable by the infected host,

655
00:31:44,080 --> 00:31:46,230
but that are not communicating usually

656
00:31:46,230 --> 00:31:48,650
with the infected host.

657
00:31:48,650 --> 00:31:50,000
And again, the rootkit client

658
00:31:50,000 --> 00:31:53,540
will generate a nice network graph for you

659
00:31:53,540 --> 00:31:56,020
once the scan is complete.

660
00:31:56,020 --> 00:31:58,590
So on a technical level,
this feature of the rootkit

661
00:31:58,590 --> 00:32:02,220
is actually quite interesting
because, as I said before,

662
00:32:02,220 --> 00:32:04,820
eBPF cannot create a
connection from scratch.

663
00:32:04,820 --> 00:32:07,200
So in other words, we
had to figure out a way

664
00:32:07,200 --> 00:32:10,130
to generate hundreds of SYN requests

665
00:32:10,130 --> 00:32:13,200
while dealing with this
limitation of eBPF.

666
00:32:13,200 --> 00:32:15,893
So let's see how we solve this problem.

667
00:32:19,210 --> 00:32:21,130
So in order to send a SYN request,

668
00:32:21,130 --> 00:32:24,200
you first need to know
the MAC address of the IP

669
00:32:24,200 --> 00:32:26,090
that you want to scan.

670
00:32:26,090 --> 00:32:28,540
To do so, we use the same trick

671
00:32:28,540 --> 00:32:30,070
that we've been using so far,

672
00:32:30,070 --> 00:32:33,390
which is to override the requests
from the rootkit clients.

673
00:32:33,390 --> 00:32:38,360
So when our XDP program
receives a scan request

674
00:32:38,360 --> 00:32:41,150
for a specific IP and
a specific port range,

675
00:32:41,150 --> 00:32:45,780
it will override the entire
request with an ARP request

676
00:32:45,780 --> 00:32:47,870
for the target IP.

677
00:32:47,870 --> 00:32:50,750
And then instead of returning XDP pass,

678
00:32:50,750 --> 00:32:53,090
which is what we've done so far,

679
00:32:53,090 --> 00:32:56,210
and also which would send the
packets to the network stack,

680
00:32:56,210 --> 00:32:58,663
our eBPF program returns XDPTX.

681
00:32:59,640 --> 00:33:02,940
So what XDPTX does is send the packet out

682
00:33:02,940 --> 00:33:05,703
to the network interface
controller it can inform.

683
00:33:06,720 --> 00:33:09,250
In other words, our HTTP packet

684
00:33:09,250 --> 00:33:11,420
was transformed into an ARP request

685
00:33:15,570 --> 00:33:20,470
and broadcasted back to
the entire local network.

686
00:33:20,470 --> 00:33:25,470
So eventually the target IP
will answer the ARP request

687
00:33:25,530 --> 00:33:28,070
and will be able to store the MAC address

688
00:33:28,070 --> 00:33:31,343
of this specific IP in an eBPF map.

689
00:33:32,780 --> 00:33:35,640
However, during this entire process,

690
00:33:35,640 --> 00:33:39,330
the TCP packet that was used
to send the HTTP request

691
00:33:39,330 --> 00:33:41,760
was never acknowledged by the kernel.

692
00:33:41,760 --> 00:33:45,350
And that is simply because
it never made it's way

693
00:33:45,350 --> 00:33:47,530
to the kernel in the first place,

694
00:33:47,530 --> 00:33:51,080
which means that the Load
Balancer or the client itself

695
00:33:51,080 --> 00:33:53,900
will eventually try to
retransmit the packet.

696
00:33:53,900 --> 00:33:56,200
And when this packet is retransmitted

697
00:33:58,330 --> 00:34:01,390
and when it eventually
reaches our XDP program,

698
00:34:01,390 --> 00:34:03,217
we will do the exact same thing.

699
00:34:03,217 --> 00:34:07,480
But this time, instead of,
because we know the MAC address,

700
00:34:07,480 --> 00:34:11,070
instead of overriding the
request with an ARP request,

701
00:34:11,070 --> 00:34:13,890
we're gonna override the
request with a SYN request.

702
00:34:13,890 --> 00:34:15,950
And more specifically a SYN request

703
00:34:15,950 --> 00:34:19,470
with the first port of
the provided port range,

704
00:34:19,470 --> 00:34:23,930
the target IP and the MAC
address of the target IP.

705
00:34:23,930 --> 00:34:26,890
And assuming that the
remote IP or the remote host

706
00:34:26,890 --> 00:34:30,083
doesn't have any kind of
prediction against SYN request,

707
00:34:31,330 --> 00:34:34,810
sorry, SYN scanning, it
will answer either resets

708
00:34:34,810 --> 00:34:38,430
or SYN plus acc to this first request.

709
00:34:38,430 --> 00:34:41,280
So reset would mean that the
port is open and SYN PLUS acc

710
00:34:41,280 --> 00:34:44,400
would indicate that there
might be a set of sprinting

711
00:34:44,400 --> 00:34:45,573
running on the host.

712
00:34:47,170 --> 00:34:51,030
And this is where basically
the network loop happens

713
00:34:51,030 --> 00:34:51,950
and the reason why

714
00:34:51,950 --> 00:34:55,930
we were able to generate
hundreds of packets

715
00:34:57,615 --> 00:35:00,700
while dealing with the limitation of eBPF,

716
00:35:00,700 --> 00:35:05,290
that is the inability to create packets.

717
00:35:05,290 --> 00:35:08,500
So whenever we get an
answer from a SYN request,

718
00:35:08,500 --> 00:35:12,010
we override the received
packet with another SYN request

719
00:35:12,010 --> 00:35:13,450
on the next port.

720
00:35:13,450 --> 00:35:16,860
And we also switch the IPs,
switch to the MAC addresses,

721
00:35:16,860 --> 00:35:18,950
and send it back again to the target IP.

722
00:35:18,950 --> 00:35:20,200
And we do so in a loop

723
00:35:20,200 --> 00:35:24,110
until we go through the entire port range.

724
00:35:24,110 --> 00:35:27,750
So eventually the clients
will try one last time

725
00:35:27,750 --> 00:35:31,910
to retransmit the initial HTTP requests.

726
00:35:31,910 --> 00:35:34,540
Because once again,
during the network loop,

727
00:35:34,540 --> 00:35:38,303
we never answered the second retransmit.

728
00:35:38,303 --> 00:35:41,636
So eventually when this third retransmit

729
00:35:43,623 --> 00:35:47,170
reaches our XDP program, we
will override the request

730
00:35:47,170 --> 00:35:50,450
with the usual health check requests

731
00:35:50,450 --> 00:35:54,540
so that the 200 okay
answer will make its way

732
00:35:54,540 --> 00:35:57,660
back to the client after
the request was handled

733
00:35:57,660 --> 00:35:59,423
by web app and user space.

734
00:36:00,780 --> 00:36:02,653
All right, so let's see it in action.

735
00:36:05,950 --> 00:36:07,510
So on the right of the screen,

736
00:36:07,510 --> 00:36:11,130
this is a shell to the
infected host on AWS

737
00:36:11,130 --> 00:36:14,440
and at the bottom here, it's another one.

738
00:36:14,440 --> 00:36:19,343
And at the top, this is my
local shell on my machine.

739
00:36:20,210 --> 00:36:24,410
So the first thing you want
to do is to start the rootkit.

740
00:36:24,410 --> 00:36:28,200
Then second is to start dumping
the logs of the rootkit.

741
00:36:28,200 --> 00:36:32,570
So an eBPF can actually generate
logs using a trace pipe.

742
00:36:32,570 --> 00:36:35,930
Obviously you would not want
to do this in a real use case

743
00:36:35,930 --> 00:36:38,320
for a rootkit, but this is a great way

744
00:36:38,320 --> 00:36:43,290
of visualizing the scan
as it goes through.

745
00:36:43,290 --> 00:36:44,560
Yeah, so that's why I'm doing this

746
00:36:44,560 --> 00:36:46,520
and that's why you will
see what the rootkit does

747
00:36:46,520 --> 00:36:48,110
at runtime.

748
00:36:48,110 --> 00:36:52,130
And then let's make the scan request.

749
00:36:52,130 --> 00:36:57,130
So what I'm saying here is
please scan the IP 10.0.2.3

750
00:36:58,410 --> 00:37:03,193
from port 7990 and for the
next 20 ports after this one.

751
00:37:04,610 --> 00:37:05,900
So the first thing you can see

752
00:37:05,900 --> 00:37:10,760
is the request is immediately
changed into an ARP request

753
00:37:10,760 --> 00:37:13,820
and we already got the
answer for this ARP request.

754
00:37:13,820 --> 00:37:16,020
So next step, when we get a retransmit,

755
00:37:16,020 --> 00:37:18,543
we will change this into a SYN request.

756
00:37:19,520 --> 00:37:20,353
Here you go.

757
00:37:20,353 --> 00:37:21,960
So the SYN request went through

758
00:37:21,960 --> 00:37:24,110
and then you can see
the loop that happens.

759
00:37:24,110 --> 00:37:27,420
And we increased port one by one

760
00:37:27,420 --> 00:37:30,470
until we reached the final port

761
00:37:30,470 --> 00:37:32,713
requested by the port branch.

762
00:37:33,660 --> 00:37:36,470
And then now we are waiting
for the third retransmit

763
00:37:36,470 --> 00:37:38,300
and this retransmit will be the one

764
00:37:38,300 --> 00:37:41,440
that we override with
the health check request,

765
00:37:41,440 --> 00:37:43,260
which means that we will
eventually get here,

766
00:37:43,260 --> 00:37:47,230
go the 200 okay, in other words,

767
00:37:47,230 --> 00:37:49,203
the answer from the user space web app.

768
00:37:50,270 --> 00:37:51,930
All right, so now what you want to do

769
00:37:51,930 --> 00:37:54,700
is retrieve the output of the scan

770
00:37:54,700 --> 00:37:57,060
and exfiltrate all the network flows

771
00:37:57,060 --> 00:38:00,520
that were detected at
runtime, and here you go.

772
00:38:00,520 --> 00:38:04,090
So you would say network_discovery_get
and eventually ...

773
00:38:04,090 --> 00:38:06,760
So it actually requires a
lot of different requests

774
00:38:06,760 --> 00:38:08,910
because there's a lot
of data to exfiltrate,

775
00:38:08,910 --> 00:38:12,600
but eventually you will get the
entire list of network flows

776
00:38:12,600 --> 00:38:16,880
that were captured by the rootkit.

777
00:38:16,880 --> 00:38:17,713
Here we go.

778
00:38:17,713 --> 00:38:20,360
So you have all the
different individual flows

779
00:38:22,060 --> 00:38:23,840
and then more importantly,

780
00:38:23,840 --> 00:38:26,603
you will have a graph generated for you.

781
00:38:27,730 --> 00:38:31,890
So this one is the passive,
sorry, active graph.

782
00:38:31,890 --> 00:38:35,940
So as you can see, range there,
you can see the ARP requests

783
00:38:35,940 --> 00:38:39,300
and replies between those different hosts.

784
00:38:39,300 --> 00:38:42,490
And then in gray, those
are the SYN requests

785
00:38:42,490 --> 00:38:44,440
and the reset answers.

786
00:38:44,440 --> 00:38:47,250
And in red is the only SYN plus acc,

787
00:38:47,250 --> 00:38:49,483
and so from the remote host.

788
00:38:50,910 --> 00:38:54,970
All right, and then you
have also the passive graph,

789
00:38:54,970 --> 00:38:56,770
which is the one that we saw before.

790
00:39:03,210 --> 00:39:06,510
Okay, so now let's move
on to our RASP bypass.

791
00:39:06,510 --> 00:39:11,510
So RASP stands for runtime
application self-protection.

792
00:39:11,520 --> 00:39:12,353
So in a few words,

793
00:39:12,353 --> 00:39:15,100
a RASP is a new generation
of security tools

794
00:39:15,100 --> 00:39:17,720
that uses runtime instrumentation

795
00:39:17,720 --> 00:39:20,340
to detect and block
application level attacks.

796
00:39:20,340 --> 00:39:24,120
And more importantly,
it leverages its insight

797
00:39:24,120 --> 00:39:25,200
into the application

798
00:39:25,200 --> 00:39:28,420
in order to make more
intelligent decisions.

799
00:39:28,420 --> 00:39:32,190
So simply put, it is some kind of advanced

800
00:39:32,190 --> 00:39:36,350
input monitoring tool that can
detect malicious parameters

801
00:39:36,350 --> 00:39:38,960
and can understand if a malicious input

802
00:39:38,960 --> 00:39:43,810
will successfully exploit a
weakness from one of your apps.

803
00:39:43,810 --> 00:39:45,570
So the textbook example of a RASP

804
00:39:45,570 --> 00:39:47,850
is usually a SQL injection.

805
00:39:47,850 --> 00:39:51,200
So the RASP route implement
multiple functions,

806
00:39:51,200 --> 00:39:53,580
instruments, sorry, multiple functions

807
00:39:53,580 --> 00:39:55,700
in the libraries that you use

808
00:39:55,700 --> 00:39:58,270
such as for example,
the HTTP server library

809
00:39:58,270 --> 00:40:00,010
or the SQL library.

810
00:40:00,010 --> 00:40:01,670
And it will check at runtime

811
00:40:01,670 --> 00:40:04,640
that the user control
parameters in your queries

812
00:40:04,640 --> 00:40:06,193
are properly sanitized.

813
00:40:07,090 --> 00:40:09,100
If not, the RASP will stop the query

814
00:40:09,100 --> 00:40:12,500
before it reaches the database
and redirect the client

815
00:40:12,500 --> 00:40:16,930
to an error page or some
kind of error message.

816
00:40:16,930 --> 00:40:20,250
In other words, a RASP
relies on the assumption

817
00:40:20,250 --> 00:40:23,630
that the application runtime
has not been compromised,

818
00:40:23,630 --> 00:40:26,990
which is exactly what we can do with eBPF.

819
00:40:26,990 --> 00:40:31,170
So just a little disclaimer
before I move forward.

820
00:40:31,170 --> 00:40:33,790
I want to stress the
fact that we are playing

821
00:40:33,790 --> 00:40:35,280
outside of the boundaries

822
00:40:35,280 --> 00:40:38,260
of what a RASP can protect you from.

823
00:40:38,260 --> 00:40:39,960
And more importantly,

824
00:40:39,960 --> 00:40:43,120
this bypass does not apply
to one specific RASP,

825
00:40:43,120 --> 00:40:44,350
but to all of them

826
00:40:44,350 --> 00:40:47,110
because this is one of the core principles

827
00:40:47,110 --> 00:40:50,620
of how a RASP works.

828
00:40:50,620 --> 00:40:51,453
So let's have a look

829
00:40:51,453 --> 00:40:56,063
at how RASP products a good
web app from a SQL injection.

830
00:40:58,180 --> 00:41:00,320
So let's say that you have a web app

831
00:41:00,320 --> 00:41:02,700
with a simple products page

832
00:41:02,700 --> 00:41:07,700
and get parameter to specify
the category of the products

833
00:41:07,750 --> 00:41:09,410
that you want to see.

834
00:41:09,410 --> 00:41:10,980
Chances are your web app

835
00:41:10,980 --> 00:41:15,020
uses the default go
database SQL interface.

836
00:41:15,020 --> 00:41:17,230
So this is a generic
interface that you can use

837
00:41:17,230 --> 00:41:19,450
to query your database
without having to worry

838
00:41:19,450 --> 00:41:21,240
about the underlying driver

839
00:41:21,240 --> 00:41:24,570
and the database type that you're using.

840
00:41:24,570 --> 00:41:26,410
More importantly for us,

841
00:41:26,410 --> 00:41:29,580
since it is such a generic interface,

842
00:41:29,580 --> 00:41:34,000
this is usually where the RASP
tools instrument your code

843
00:41:34,950 --> 00:41:38,150
because simply it's much
easier to hook at this layer

844
00:41:38,150 --> 00:41:42,150
rather than having to hook onto
all the underlying drivers.

845
00:41:42,150 --> 00:41:46,360
So when your request is
handled by the web server,

846
00:41:46,360 --> 00:41:48,542
the query will be formatted

847
00:41:48,542 --> 00:41:50,740
with the provided category parameter

848
00:41:50,740 --> 00:41:51,880
and eventually the web app

849
00:41:51,880 --> 00:41:56,643
will call the query context
function of this SQL interface.

850
00:41:57,660 --> 00:42:00,810
This is when the RASP checks the query

851
00:42:00,810 --> 00:42:03,400
and makes sure that everything is normal.

852
00:42:03,400 --> 00:42:07,030
And if it is, the execution
will resume its normal flow

853
00:42:07,030 --> 00:42:10,820
and the underlying driver will be called.

854
00:42:10,820 --> 00:42:13,460
So in our example, we use SQLite,

855
00:42:13,460 --> 00:42:16,330
so the SQLite driver is called.

856
00:42:16,330 --> 00:42:18,760
Eventually the query makes
its way to the database

857
00:42:18,760 --> 00:42:21,340
and the answer is sent back to the client.

858
00:42:21,340 --> 00:42:25,450
However, if the RASP detects
that something is wrong

859
00:42:25,450 --> 00:42:27,710
or detects some kind of SQL injection,

860
00:42:27,710 --> 00:42:30,060
it will block the query
and redirect the client

861
00:42:30,060 --> 00:42:33,210
to an error page.

862
00:42:33,210 --> 00:42:35,370
All right, so now let's see what we did

863
00:42:35,370 --> 00:42:36,833
to bypass this protection.

864
00:42:37,670 --> 00:42:39,820
Well, the answer is
actually pretty simple.

865
00:42:39,820 --> 00:42:44,320
We added a uprobe on both
the database SQL interface

866
00:42:44,320 --> 00:42:47,630
and the SQLite driver interface.

867
00:42:47,630 --> 00:42:51,720
What this allows us to do is
call one of our eBPF programs

868
00:42:51,720 --> 00:42:55,440
right before the RASP checks the SQL query

869
00:42:55,440 --> 00:42:57,330
and trigger another one

870
00:42:57,330 --> 00:43:01,830
right before the SQL query is executed

871
00:43:01,830 --> 00:43:04,300
by the database itself.

872
00:43:04,300 --> 00:43:08,640
And thanks to the BPF ProLite user helper,

873
00:43:08,640 --> 00:43:11,660
we can override the input
parameters of the hooked functions

874
00:43:11,660 --> 00:43:15,420
so that the RASP sees a benign query

875
00:43:15,420 --> 00:43:19,833
and the database executes
our SQL injection.

876
00:43:20,770 --> 00:43:21,780
And the cool thing about this

877
00:43:21,780 --> 00:43:24,690
is that we can even do it conditionally,

878
00:43:24,690 --> 00:43:28,300
which means that we can bypass the RASP

879
00:43:28,300 --> 00:43:31,590
only if one specific secret password

880
00:43:31,590 --> 00:43:34,563
was added to the beginning of the query.

881
00:43:36,350 --> 00:43:39,113
Perfect, so let's move on to the demo.

882
00:43:39,113 --> 00:43:42,370
So as you can see, we have
a very simple web app.

883
00:43:42,370 --> 00:43:44,300
So it's a shoes retailer.

884
00:43:44,300 --> 00:43:46,560
So you have a lot of different products

885
00:43:46,560 --> 00:43:49,840
and you can filter by category.

886
00:43:49,840 --> 00:43:52,590
So let's try to do a SQL injection

887
00:43:53,960 --> 00:43:55,400
using the get parameter.

888
00:43:55,400 --> 00:43:58,700
So the injection was simply be select star

889
00:43:58,700 --> 00:44:03,130
from user and because the
RASP is not running right now,

890
00:44:03,130 --> 00:44:04,680
the SQL injection should work.

891
00:44:04,680 --> 00:44:05,970
Here you go.

892
00:44:05,970 --> 00:44:07,840
And if you scroll down this time,

893
00:44:07,840 --> 00:44:12,680
you will see the users along
with the passwords, perfect.

894
00:44:12,680 --> 00:44:15,550
So now let's restart the
web app with the RASP,

895
00:44:15,550 --> 00:44:19,373
which is what I've just
done and try this again.

896
00:44:20,340 --> 00:44:21,890
So let's go to the shop

897
00:44:22,830 --> 00:44:27,830
and then override the
category parameter, perfect.

898
00:44:30,250 --> 00:44:32,500
And this time the RASP blocked the request

899
00:44:32,500 --> 00:44:34,620
because it detected

900
00:44:34,620 --> 00:44:37,590
that someone tried to do a SQL injection

901
00:44:37,590 --> 00:44:40,433
and the SQL injection would
actually have succeeded.

902
00:44:42,080 --> 00:44:44,120
Great, so now let's start the rootkits

903
00:44:46,070 --> 00:44:48,690
by providing the path to the web app

904
00:44:48,690 --> 00:44:51,040
and then try to refresh the page.

905
00:44:51,040 --> 00:44:55,660
So again, this should also
be blocked by the RASP

906
00:44:55,660 --> 00:44:58,270
because we haven't provided
the secret password

907
00:44:58,270 --> 00:44:59,780
for the bypass to work.

908
00:44:59,780 --> 00:45:02,820
And the secret password
is of course, defcon.

909
00:45:02,820 --> 00:45:04,430
And when we say defcon,

910
00:45:04,430 --> 00:45:07,000
the entire process that I described before

911
00:45:07,000 --> 00:45:08,010
will be triggered.

912
00:45:08,010 --> 00:45:10,360
And as you can see, the
RASP did not detect it.

913
00:45:11,500 --> 00:45:13,880
So that's all for our RASP bypass.

914
00:45:13,880 --> 00:45:15,680
I hope you had fun.

915
00:45:15,680 --> 00:45:17,590
Just before I hand it over to Sylvain

916
00:45:17,590 --> 00:45:20,000
for the detection and
mitigation strategies,

917
00:45:20,000 --> 00:45:22,420
I wanted to say that,
unfortunately, we won't have time

918
00:45:22,420 --> 00:45:24,520
to talk about the container breakouts

919
00:45:24,520 --> 00:45:26,790
that are (indistinct) into the rootkit.

920
00:45:26,790 --> 00:45:28,620
However, they have been presented

921
00:45:28,620 --> 00:45:30,850
during our Black Hat call this year.

922
00:45:30,850 --> 00:45:33,540
So if you are interested,
feel free to check it out.

923
00:45:33,540 --> 00:45:35,673
That being said, Sylvain, take it away.

924
00:45:37,820 --> 00:45:40,453
- So let's talk about
detection and mitigation.

925
00:45:41,620 --> 00:45:43,480
How could we detect and protect ourselves

926
00:45:43,480 --> 00:45:45,330
from this type of rootkit?

927
00:45:45,330 --> 00:45:47,620
We could do this at different level.

928
00:45:47,620 --> 00:45:50,220
First, if a vendor
provided you eBPF programs,

929
00:45:50,220 --> 00:45:52,870
you should go through an
audit and an assessment phase

930
00:45:52,870 --> 00:45:54,330
of their programs.

931
00:45:54,330 --> 00:45:57,100
Some changes that the code has to be GPL.

932
00:45:57,100 --> 00:45:59,440
It probably uses some
internal candid symbols,

933
00:45:59,440 --> 00:46:00,623
so you can ask for it.

934
00:46:01,610 --> 00:46:03,167
What should we be looking for?

935
00:46:03,167 --> 00:46:04,870
The program types that are used,

936
00:46:04,870 --> 00:46:07,290
but also the eBPF helpers used.

937
00:46:07,290 --> 00:46:08,130
So communication.

938
00:46:08,130 --> 00:46:11,640
So maps between programs may
indicate the control risk

939
00:46:11,640 --> 00:46:14,340
in the case of that the
vendor program is compromised.

940
00:46:15,200 --> 00:46:18,110
We developed a tool to
assist in this auditing phase

941
00:46:18,110 --> 00:46:20,980
by inspecting the health files
containing eBPF programs,

942
00:46:20,980 --> 00:46:24,430
it is able to list the use
entities, programs, and maps,

943
00:46:24,430 --> 00:46:27,130
and compare to graph of the
interactions between them.

944
00:46:29,248 --> 00:46:32,990
The tool was run on our rootkit
with the following result.

945
00:46:32,990 --> 00:46:37,440
We can identify on the
graph that the XDP program

946
00:46:37,440 --> 00:46:39,260
has stored information into maps

947
00:46:39,260 --> 00:46:41,700
that are also used by some kprobes,

948
00:46:41,700 --> 00:46:43,980
which correspond to the
command-and-control capabilities

949
00:46:43,980 --> 00:46:45,233
of the rootkits.

950
00:46:47,600 --> 00:46:50,350
It is also possible to mitigate at runtime

951
00:46:50,350 --> 00:46:53,210
the loading of such
programs by monitoring calls

952
00:46:53,210 --> 00:46:57,925
to the eBPF syscall and
logging (indistinct)

953
00:46:57,925 --> 00:47:01,110
It would even be possible to
protect the eBPF syscall itself

954
00:47:01,110 --> 00:47:03,690
by either (indistinct) syscall to it

955
00:47:03,690 --> 00:47:05,610
to need some trusted processes.

956
00:47:05,610 --> 00:47:08,390
As the programs inspected
before then and rejected

957
00:47:08,390 --> 00:47:10,320
if they contain suspicious patterns

958
00:47:10,320 --> 00:47:12,373
or make use of some dangerous helpers.

959
00:47:13,740 --> 00:47:15,230
We could also compute and validate

960
00:47:15,230 --> 00:47:18,990
the signature of the
programs before (indistinct)

961
00:47:18,990 --> 00:47:21,903
exist to the kernel itself.

962
00:47:24,040 --> 00:47:26,480
Using TLS everywhere for network traffic

963
00:47:26,480 --> 00:47:29,560
also helps mitigating the
risk of a rogue eBPF program

964
00:47:29,560 --> 00:47:31,133
that intercept network data.

965
00:47:33,840 --> 00:47:35,940
Now if we are not able to block

966
00:47:35,940 --> 00:47:37,720
the loading of such a rootkit,

967
00:47:37,720 --> 00:47:40,850
how difficult would it be
to detect its presence?

968
00:47:40,850 --> 00:47:43,360
Even if it's possible,
though very challenging

969
00:47:43,360 --> 00:47:45,730
to write anonymous perfect rootkit,

970
00:47:45,730 --> 00:47:48,240
we should concentrate on the
action the rootkit will have

971
00:47:48,240 --> 00:47:51,660
to block and lie about the
result of such actions.

972
00:47:51,660 --> 00:47:54,039
For instance, our rootkit (indistinct)

973
00:47:54,039 --> 00:47:55,370
we are loading kernel modules

974
00:47:55,370 --> 00:47:57,550
because such a module
would have the ability

975
00:47:57,550 --> 00:48:00,163
to lead the eBPF programs
and the active kprobes.

976
00:48:01,140 --> 00:48:03,380
Now let's imagine that we insert a module

977
00:48:03,380 --> 00:48:07,170
that executes a specific
action only known to us.

978
00:48:07,170 --> 00:48:09,370
The blocking of the module by the rootkit

979
00:48:09,370 --> 00:48:10,823
will then be easy to detect.

980
00:48:12,340 --> 00:48:16,430
Monitoring the network traffic
at the infrastructure level

981
00:48:16,430 --> 00:48:18,290
could that detecting hijacked connection

982
00:48:18,290 --> 00:48:20,950
or strange back into our transmission.

983
00:48:20,950 --> 00:48:25,030
Our rootkit being far from
complete and far from perfect,

984
00:48:25,030 --> 00:48:27,380
it should be relatively easy to detect it.

985
00:48:27,380 --> 00:48:30,810
That being said, we hope
it will bring to light

986
00:48:30,810 --> 00:48:34,710
the potential and the risk
of such an eBFP base rootkit

987
00:48:34,710 --> 00:48:36,910
while presenting some
interesting technique.

988
00:48:39,230 --> 00:48:42,290
The code of both the
rootkit and the monitor

989
00:48:42,290 --> 00:48:45,650
is available at the
servers, please have a look.

990
00:48:45,650 --> 00:48:48,350
Thanks for your attention
and have a great conference.

