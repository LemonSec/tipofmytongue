1
00:00:00,220 --> 00:00:02,440
- Hello everyone, my
name is Adam Zabrocki,

2
00:00:02,440 --> 00:00:04,100
and together with Alex Matrosov,

3
00:00:04,100 --> 00:00:05,170
we would like to give you a talk

4
00:00:05,170 --> 00:00:06,210
about Glitching RISC-V Chips:

5
00:00:06,210 --> 00:00:09,180
MTVEC Corruption For Hardening ISA.

6
00:00:09,180 --> 00:00:12,490
However, this is the end
goal, what we end up doing.

7
00:00:12,490 --> 00:00:14,800
And before we ended up doing that,

8
00:00:14,800 --> 00:00:18,500
we also needed to go through
various different researches

9
00:00:18,500 --> 00:00:22,050
we would like to cover
in this topic today.

10
00:00:22,050 --> 00:00:23,600
To sentence about ourself,

11
00:00:23,600 --> 00:00:25,400
we don't wanna focus too much here.

12
00:00:25,400 --> 00:00:29,000
Both of us did this research
during our work at Nvidia,

13
00:00:29,000 --> 00:00:31,590
and here you can find some
private contact information

14
00:00:31,590 --> 00:00:34,150
to me and Alex, and we
just want to mention

15
00:00:34,150 --> 00:00:36,590
that we did some security research

16
00:00:36,590 --> 00:00:38,770
for a couple of years already.

17
00:00:38,770 --> 00:00:41,130
So what is this talk about exactly?

18
00:00:41,130 --> 00:00:43,450
So let's speak first about
execution environment.

19
00:00:43,450 --> 00:00:46,770
So to be able to speak
about execution environment,

20
00:00:46,770 --> 00:00:48,650
we need to have some kind of hardware.

21
00:00:48,650 --> 00:00:50,120
And when we speak about the hardware,

22
00:00:50,120 --> 00:00:53,540
we especially also mean
about the CPU architecture.

23
00:00:53,540 --> 00:00:55,540
There might be various
different CPU architecture

24
00:00:55,540 --> 00:01:00,440
like RISC-V, like x86,
like ARM, et cetera.

25
00:01:00,440 --> 00:01:02,310
And when we write a software,

26
00:01:02,310 --> 00:01:05,160
software especially targets
the CPU architecture.

27
00:01:05,160 --> 00:01:07,530
So any software which we write in the end

28
00:01:07,530 --> 00:01:10,640
are kind of designed
to run on specific CPU

29
00:01:10,640 --> 00:01:11,860
architecture hardware,

30
00:01:11,860 --> 00:01:13,950
even if you're writing
the high level language,

31
00:01:13,950 --> 00:01:16,520
in the end still the interpreter runs on

32
00:01:16,520 --> 00:01:19,720
and targeting specific CPU architecture.

33
00:01:19,720 --> 00:01:23,240
And in this kind of scenario,
if you would like to break

34
00:01:23,240 --> 00:01:25,260
such kind of execution environment,

35
00:01:25,260 --> 00:01:27,450
we can focus on the
various type of the attack.

36
00:01:27,450 --> 00:01:29,410
We can focus on the pure software attacks

37
00:01:29,410 --> 00:01:30,790
or pure hardware attacks.

38
00:01:30,790 --> 00:01:32,280
Example of the pure software attack

39
00:01:32,280 --> 00:01:33,800
could be any kind of the Memory Safety,

40
00:01:33,800 --> 00:01:36,180
like Overflow, Use After Free, et cetera.

41
00:01:36,180 --> 00:01:37,720
Injection, which is very popular

42
00:01:37,720 --> 00:01:40,400
in the higher level languages
like command injection,

43
00:01:40,400 --> 00:01:43,380
SQL injection, cross-site
scripting or logical issues

44
00:01:43,380 --> 00:01:47,330
where you essentially try to
target a specific software,

45
00:01:47,330 --> 00:01:49,150
which is very badly designed

46
00:01:49,150 --> 00:01:51,590
and which might have security implication.

47
00:01:51,590 --> 00:01:53,650
There is also much more other attacks.

48
00:01:53,650 --> 00:01:55,420
While the pure hardware attacks,

49
00:01:55,420 --> 00:01:58,240
we usually think about the
glitching type of the attacks

50
00:01:58,240 --> 00:02:00,130
or any kind of the side channel attack

51
00:02:00,130 --> 00:02:01,740
or physical probing of the hardware,

52
00:02:01,740 --> 00:02:03,120
also there is many more.

53
00:02:03,120 --> 00:02:04,680
So from the high-level perspective,

54
00:02:04,680 --> 00:02:06,410
if you think about the
pure software attack,

55
00:02:06,410 --> 00:02:09,090
they are targeting
specific implementation,

56
00:02:09,090 --> 00:02:11,910
example could be specific
programming language,

57
00:02:11,910 --> 00:02:15,380
which allows you to have some
kind of undefined behavior,

58
00:02:15,380 --> 00:02:16,700
which we try to hunt,

59
00:02:16,700 --> 00:02:18,890
or you can also target specific compilers,

60
00:02:18,890 --> 00:02:21,520
specific software or
like firmware, et cetera.

61
00:02:21,520 --> 00:02:23,890
And there is no different
than pure hardware attacks.

62
00:02:23,890 --> 00:02:25,200
In the pure hardware attacks,

63
00:02:25,200 --> 00:02:28,780
you also focus on targeting
specific implementation.

64
00:02:28,780 --> 00:02:31,000
Example could be specific CPU family,

65
00:02:31,000 --> 00:02:33,050
or specific implementation
of the architecture,

66
00:02:33,050 --> 00:02:34,480
ISAM, et cetera.

67
00:02:34,480 --> 00:02:38,920
And there is also recently
very nice research about,

68
00:02:38,920 --> 00:02:41,060
what about mixing these
two types of attack,

69
00:02:41,060 --> 00:02:42,940
pure hardware and pure software.

70
00:02:42,940 --> 00:02:45,260
And example of such kind
of mix attack could be,

71
00:02:45,260 --> 00:02:48,380
for example, meltdown or spectre attacks.

72
00:02:48,380 --> 00:02:50,820
They essentially means
hardware and software.

73
00:02:50,820 --> 00:02:52,990
However, if you think
about that a bit more,

74
00:02:52,990 --> 00:02:56,330
what about if you found the
bug in the reference code

75
00:02:56,330 --> 00:02:57,920
of the hardware ISA itself?

76
00:02:57,920 --> 00:02:59,730
Not in the implementation of the ISA,

77
00:02:59,730 --> 00:03:01,870
but like in the kind of ISA itself,

78
00:03:01,870 --> 00:03:03,850
like a reference code for the ISA.

79
00:03:03,850 --> 00:03:07,340
This is pretty interesting
implication from that,

80
00:03:07,340 --> 00:03:09,060
because then the problem will affect

81
00:03:09,060 --> 00:03:11,360
all of the implementation of the silicon,

82
00:03:11,360 --> 00:03:14,330
not just the specific
implementation or specific family,

83
00:03:14,330 --> 00:03:17,430
because everything which is
realized from the reference code

84
00:03:17,430 --> 00:03:19,170
like ISA will be affected.

85
00:03:19,170 --> 00:03:21,480
And this is also interesting
because in such case

86
00:03:21,480 --> 00:03:24,860
software cannot trust
hardware at all when they do.

87
00:03:24,860 --> 00:03:28,170
So this is exactly what we'll
try to speak about today.

88
00:03:28,170 --> 00:03:29,320
This type of the problem

89
00:03:29,320 --> 00:03:31,590
which we discovered during our research.

90
00:03:31,590 --> 00:03:34,430
So at first, how did we find it

91
00:03:34,430 --> 00:03:37,230
and how did we even focus
on such kind of problem?

92
00:03:37,230 --> 00:03:41,320
So essentially we wanted to
analyze a specific boot software

93
00:03:41,320 --> 00:03:44,060
like Boot ROM or a
specific microcode runs.

94
00:03:44,060 --> 00:03:46,290
However, the problem
is that it was running

95
00:03:46,290 --> 00:03:48,010
on the specific RISC-V chip,

96
00:03:48,010 --> 00:03:49,930
which we essentially had zero experience

97
00:03:49,930 --> 00:03:52,700
with architecture of
RISC-V, and more over,

98
00:03:52,700 --> 00:03:56,890
it was not just a simple
RISC-V chip implementing base.

99
00:03:56,890 --> 00:03:59,607
ISA however, they carry custom extension

100
00:03:59,607 --> 00:04:03,460
and custom functionalities
on this specific environment,

101
00:04:03,460 --> 00:04:04,470
which we wanna analyze.

102
00:04:04,470 --> 00:04:06,560
And even more, the boot software

103
00:04:06,560 --> 00:04:09,770
was written in the AdaCore/SPARK language

104
00:04:09,770 --> 00:04:12,170
which we additionally also
had zero experience with

105
00:04:12,170 --> 00:04:14,050
at that time during the research.

106
00:04:14,050 --> 00:04:17,380
And we starting to focus
on that a bit more quickly,

107
00:04:17,380 --> 00:04:19,720
is there any kind of
public offensive research

108
00:04:20,640 --> 00:04:22,770
publication about that language.

109
00:04:22,770 --> 00:04:24,800
Did anyone even hear about
that language before?

110
00:04:24,800 --> 00:04:25,870
Because we did not.

111
00:04:25,870 --> 00:04:29,210
So at that time we also needed to be able

112
00:04:29,210 --> 00:04:32,720
to analyze the binary,
especially the binary compiled

113
00:04:32,720 --> 00:04:35,740
from SPARK language targeting
this customized V-chip,

114
00:04:35,740 --> 00:04:39,627
and there was no even any
tools who natively support

115
00:04:39,627 --> 00:04:43,380
and even simple RISC-V,
including IDA Pro and Ghidra.

116
00:04:43,380 --> 00:04:45,660
This was around 2019,
and none of these tool

117
00:04:45,660 --> 00:04:48,040
natively supported RISC-V.

118
00:04:48,040 --> 00:04:51,080
And this is exactly what we
try to speak about today.

119
00:04:51,080 --> 00:04:54,140
So during this talk, we will
try to describe our journey

120
00:04:54,140 --> 00:04:56,450
through all of the problems which we met

121
00:04:56,450 --> 00:04:58,960
during this research,
which resulted in the end,

122
00:04:58,960 --> 00:05:02,760
in the discovering ambiguity
of the RISC-V specification,

123
00:05:02,760 --> 00:05:05,070
and also one additional problem.

124
00:05:05,070 --> 00:05:06,570
However, first thing first

125
00:05:06,570 --> 00:05:09,030
let's speak about RISC-V in a nutshell.

126
00:05:09,030 --> 00:05:11,550
So RISC-V is essentially an open standard

127
00:05:11,550 --> 00:05:13,880
instruction set architecture known as ISA,

128
00:05:13,880 --> 00:05:16,040
based on the RISC principles.

129
00:05:16,040 --> 00:05:19,690
And unlike any other, most of the ISAs,

130
00:05:19,690 --> 00:05:22,810
RISC-V essential is
provided under open source

131
00:05:22,810 --> 00:05:24,740
that do not require any fee,

132
00:05:24,740 --> 00:05:27,370
it's open source and free essentially.

133
00:05:27,370 --> 00:05:29,070
But there is some kind
of side effect of that

134
00:05:29,070 --> 00:05:31,240
because it's open source and it's free,

135
00:05:31,240 --> 00:05:33,320
essentially the same
RISC-V chip might have tons

136
00:05:33,320 --> 00:05:36,160
of the different implementation,
even ISA is the same.

137
00:05:36,160 --> 00:05:37,800
So you think you have
exactly the same chip

138
00:05:37,800 --> 00:05:39,840
but implementation could
be completely different

139
00:05:39,840 --> 00:05:43,890
and variant, and also RISC-V
has a small standard base ISA,

140
00:05:43,890 --> 00:05:46,840
which essentially have
multiple standard extension.

141
00:05:46,840 --> 00:05:49,680
However, this gives you a
potential huge fragmentation

142
00:05:49,680 --> 00:05:51,870
of the silicon, because one with ISA,

143
00:05:51,870 --> 00:05:53,110
with the custom extension,

144
00:05:53,110 --> 00:05:55,390
another base ISA with
a different extension,

145
00:05:55,390 --> 00:05:57,390
and all of them still are RISC-V.

146
00:05:57,390 --> 00:06:00,390
And everybody can easily
add their own extension,

147
00:06:00,390 --> 00:06:02,120
which is very cool
because it's open source,

148
00:06:02,120 --> 00:06:03,580
so nothing stops you to do that.

149
00:06:03,580 --> 00:06:05,690
So just take the ISA out
of your own extension

150
00:06:05,690 --> 00:06:08,780
and the built on silicon, which
essentially as a side effect

151
00:06:08,780 --> 00:06:10,820
gives you even much bigger fragmentation

152
00:06:10,820 --> 00:06:14,160
because it's not only RISC-V
base with a different extension

153
00:06:14,160 --> 00:06:17,530
but also they could be custom
extension on the top of that.

154
00:06:17,530 --> 00:06:19,800
And what is worth to mention that,

155
00:06:19,800 --> 00:06:22,530
today there is more than 500 plus members

156
00:06:22,530 --> 00:06:23,660
of the RISC-V foundation

157
00:06:23,660 --> 00:06:26,640
who support this initiative of RISC-V,

158
00:06:26,640 --> 00:06:29,713
including the big players
like Nvidia or Google.

159
00:06:31,030 --> 00:06:33,787
So most people now are
familiar with the x86,

160
00:06:33,787 --> 00:06:38,490
and this is just prepared as
very short and simple table,

161
00:06:38,490 --> 00:06:40,000
who compares this two architecture.

162
00:06:40,000 --> 00:06:42,630
So main difference is exactly license

163
00:06:42,630 --> 00:06:45,950
because x86 charged fee for
ISA and microarchitecture

164
00:06:45,950 --> 00:06:49,050
while RISC-V it's free,
so there's no fee for ISA,

165
00:06:49,050 --> 00:06:50,810
neither for microarchitecture.

166
00:06:50,810 --> 00:06:54,900
RISC-V it's an instruction set
based on the RISC, obviously.

167
00:06:54,900 --> 00:06:57,990
And X86 originally was a CISC,

168
00:06:57,990 --> 00:07:00,630
but it's not really true anymore
because since Pentium pro,

169
00:07:00,630 --> 00:07:02,030
x86 instruction essentially

170
00:07:02,030 --> 00:07:04,100
are turned into something
called micro-ops,

171
00:07:04,100 --> 00:07:06,330
which is kind of like RISC nowadays.

172
00:07:06,330 --> 00:07:08,490
And x86 is very old architectural,

173
00:07:08,490 --> 00:07:11,730
so essentially we have
various variants of ISA.

174
00:07:11,730 --> 00:07:14,820
They have 16 and 32 and 64 bits of ISA.

175
00:07:14,820 --> 00:07:16,960
However, RISC-V is much more modern,

176
00:07:16,960 --> 00:07:20,410
so we have 32, 64 and
there's even 128 bits

177
00:07:20,410 --> 00:07:22,580
of variance of ISA,
which is not locked yes,

178
00:07:22,580 --> 00:07:24,190
but essentially there is one.

179
00:07:24,190 --> 00:07:26,780
And RISC-V operates on the memory model

180
00:07:26,780 --> 00:07:28,670
called load-store architecture.

181
00:07:28,670 --> 00:07:31,240
While x86 is a
register-memory architecture.

182
00:07:31,240 --> 00:07:34,817
And RISC-V has 32 general
purpose registers.

183
00:07:36,070 --> 00:07:38,640
But there is one special
registers called zero register,

184
00:07:38,640 --> 00:07:40,340
which always keeps zero.

185
00:07:40,340 --> 00:07:43,160
And what is interesting
from security perspective,

186
00:07:43,160 --> 00:07:46,600
RISC-V natively support execute
only memory, known as XOM.

187
00:07:46,600 --> 00:07:47,810
It can set up this as,

188
00:07:47,810 --> 00:07:49,820
this is supported in
the page table entries.

189
00:07:49,820 --> 00:07:52,560
However, x86 normally doesn't support XOM,

190
00:07:52,560 --> 00:07:54,740
unless you have hypervisor extension,

191
00:07:54,740 --> 00:07:57,440
then you can define XOM-like
attributes in the slot table,

192
00:07:57,440 --> 00:07:59,840
which is second level
(indistinct) translation.

193
00:07:59,840 --> 00:08:03,040
And another big difference
is software ecosystem,

194
00:08:03,040 --> 00:08:04,990
which supports specific architecture.

195
00:08:04,990 --> 00:08:06,840
So x86 essentially runs everywhere.

196
00:08:06,840 --> 00:08:09,120
It's very old and very well designed

197
00:08:09,120 --> 00:08:11,000
and very well researched architecture.

198
00:08:11,000 --> 00:08:12,980
So you have Linux ecosystem,
Windows, Macintosh,

199
00:08:12,980 --> 00:08:13,870
and many more.

200
00:08:13,870 --> 00:08:16,360
While RISC-V from the
practicality perspective,

201
00:08:16,360 --> 00:08:18,150
you essentially have only one ecosystem,

202
00:08:18,150 --> 00:08:19,733
which is Linux essentially.

203
00:08:20,800 --> 00:08:22,650
But again, from the security perspective,

204
00:08:22,650 --> 00:08:24,920
you would like to focus
more on the privilege modes

205
00:08:24,920 --> 00:08:27,110
and levels which architectural carries.

206
00:08:27,110 --> 00:08:29,430
So this is very nice picture
taken from the blockbuster

207
00:08:29,430 --> 00:08:31,460
you get here on the below of the slides,

208
00:08:31,460 --> 00:08:35,190
which essentially gives
you the traditional rings,

209
00:08:35,190 --> 00:08:36,730
which x86 carries.

210
00:08:36,730 --> 00:08:39,030
So originally x86 only had four rings,

211
00:08:39,030 --> 00:08:41,250
which is ring zero, one, two and three,

212
00:08:41,250 --> 00:08:43,640
while ring one and two
was not really used.

213
00:08:43,640 --> 00:08:46,230
However, when the virtualization,

214
00:08:46,230 --> 00:08:48,150
hardware virtualization of architecture,

215
00:08:48,150 --> 00:08:50,450
x86 not fully designed yet,

216
00:08:50,450 --> 00:08:53,620
people trying to implement
part of virtualization of x86

217
00:08:53,620 --> 00:08:55,903
using ring one, but it's not,

218
00:08:56,933 --> 00:08:58,400
it doesn't need to be done anymore

219
00:08:58,400 --> 00:09:01,970
because now we have full
hardware virtualization of x86.

220
00:09:01,970 --> 00:09:03,821
So traditionally in the ring three,

221
00:09:03,821 --> 00:09:05,720
there is a least privilege code running,

222
00:09:05,720 --> 00:09:06,960
which is like user application,

223
00:09:06,960 --> 00:09:09,820
and in the ring zero, you have
kernel code most of the time.

224
00:09:09,820 --> 00:09:12,810
However, over the time people
demand more privilege levels.

225
00:09:12,810 --> 00:09:14,740
So that's why we have something which we,

226
00:09:14,740 --> 00:09:16,560
and officially called ring minus one,

227
00:09:16,560 --> 00:09:20,010
where the hypervisor works software.

228
00:09:20,010 --> 00:09:23,680
In the ring minus two, there
is something which we call SMM,

229
00:09:23,680 --> 00:09:26,530
which is more privileged
than ring minus one,

230
00:09:26,530 --> 00:09:29,400
and the results are something
not many people know,

231
00:09:29,400 --> 00:09:31,860
management engine on the x86,

232
00:09:31,860 --> 00:09:34,460
which we can call this as
kind of ring minus three,

233
00:09:34,460 --> 00:09:36,400
because it's the most privileged mode.

234
00:09:36,400 --> 00:09:40,570
If you compare that to the
RISC-V, we have only three mode,

235
00:09:40,570 --> 00:09:42,220
which is M, S, and U.

236
00:09:42,220 --> 00:09:46,690
So traditionally it's an
open source architecture.

237
00:09:46,690 --> 00:09:49,060
So you have also various
combination of this mode.

238
00:09:49,060 --> 00:09:51,410
So you can have M mode
without another mode.

239
00:09:51,410 --> 00:09:54,030
So you can have M and
U mode without S mode,

240
00:09:54,030 --> 00:09:57,020
or M, S, and U mode, which
all of the mode essentially.

241
00:09:57,020 --> 00:09:58,170
So what are these modes?

242
00:09:58,170 --> 00:10:00,460
So U mode extends from user mode.

243
00:10:00,460 --> 00:10:03,290
It's kind of equivalent to
the ring three on the x86.

244
00:10:03,290 --> 00:10:04,470
This is where the application runs,

245
00:10:04,470 --> 00:10:06,620
user application runs
least privileged mode.

246
00:10:06,620 --> 00:10:08,500
In the supervisor mode, which is a S mode,

247
00:10:08,500 --> 00:10:11,640
essentially this is what
is equivalent to ring zero.

248
00:10:11,640 --> 00:10:13,060
This is where the kernel runs.

249
00:10:13,060 --> 00:10:15,070
And M mode is kind of interesting,

250
00:10:15,070 --> 00:10:18,540
because M mode is called machine mode.

251
00:10:18,540 --> 00:10:21,150
What the ISA defines,
this is the software,

252
00:10:21,150 --> 00:10:23,680
which is the closest to the hardware runs,

253
00:10:23,680 --> 00:10:25,110
kind of like a firmware.

254
00:10:25,110 --> 00:10:28,560
However, if you wanna
compare this mode to the x86,

255
00:10:28,560 --> 00:10:31,020
it should be something
around the ring minus two

256
00:10:31,020 --> 00:10:32,040
and ring minus three.

257
00:10:32,040 --> 00:10:34,270
This is what you should
think about as an M mode,

258
00:10:34,270 --> 00:10:35,800
is the most privileged mode essentially,

259
00:10:35,800 --> 00:10:37,710
it's most powerful mode.

260
00:10:37,710 --> 00:10:41,000
However, RISC-V also works
on the hypervisor extension,

261
00:10:41,000 --> 00:10:42,540
so we have a few extra modes.

262
00:10:42,540 --> 00:10:45,160
So S mode became HS mode,

263
00:10:45,160 --> 00:10:48,220
this is where the hypervisor
extended supervisor works.

264
00:10:48,220 --> 00:10:51,270
And we have two new modes,
which is VS mode and VU mode,

265
00:10:51,270 --> 00:10:53,830
which is virtualized supervisor
and virtualized user.

266
00:10:53,830 --> 00:10:55,640
This is where the VM will run,

267
00:10:55,640 --> 00:10:57,747
but also it doesn't cancel
U mode, normal U mode,

268
00:10:57,747 --> 00:11:00,280
so you have also all of
these modes together.

269
00:11:00,280 --> 00:11:02,070
And again, because it's open source

270
00:11:02,070 --> 00:11:05,920
with one additional combination
of supported RISC-V chips,

271
00:11:05,920 --> 00:11:09,240
which is also MVS and VU mode.

272
00:11:09,240 --> 00:11:11,860
And again, you don't need to
implement all of the modes.

273
00:11:11,860 --> 00:11:14,540
You can choose which mode
to support your hardware.

274
00:11:14,540 --> 00:11:17,020
And we, as an attacker,
we are very interested

275
00:11:17,020 --> 00:11:19,230
and we would like to focus on that mode,

276
00:11:19,230 --> 00:11:22,630
which is M mode, which you can
kind of call it "God" mode,

277
00:11:22,630 --> 00:11:23,877
because this is the most privileged

278
00:11:23,877 --> 00:11:25,520
and most powerful mode runs.

279
00:11:25,520 --> 00:11:29,200
So if you are there, is
the most ideal situation.

280
00:11:29,200 --> 00:11:30,560
So how to be there.

281
00:11:30,560 --> 00:11:34,100
So essentially we know more
or less what is RISC-V.

282
00:11:34,100 --> 00:11:36,440
We learn about RISC-V a bit very quickly,

283
00:11:36,440 --> 00:11:38,310
but we at least know what
we are talking about.

284
00:11:38,310 --> 00:11:40,130
And then we know that the software

285
00:11:40,130 --> 00:11:42,540
which was targeting this
specific hardware RISC-V

286
00:11:42,540 --> 00:11:45,640
which customize V essentially,
was written in SPARK.

287
00:11:45,640 --> 00:11:47,690
And then we started to think about like,

288
00:11:47,690 --> 00:11:49,290
what the hell is SPARK?

289
00:11:49,290 --> 00:11:50,710
We never heard about that language.

290
00:11:50,710 --> 00:11:53,290
Like, did anyone even
hear this language before?

291
00:11:53,290 --> 00:11:56,030
So what is AdaCore/SPARK.

292
00:11:56,030 --> 00:11:58,570
AdaCore/SPARK is essentially
a programming language

293
00:11:58,570 --> 00:12:00,700
together with a set of analyzing tools.

294
00:12:00,700 --> 00:12:05,150
So SPARK in fact is a type
of like other language,

295
00:12:05,150 --> 00:12:07,520
ADA language, but it's
subset of ADA language.

296
00:12:07,520 --> 00:12:11,700
It's much more restricted and
doesn't have full ADA features

297
00:12:11,700 --> 00:12:14,330
because SPARK essentially

298
00:12:14,330 --> 00:12:16,470
wants to be formally verified language.

299
00:12:16,470 --> 00:12:18,550
And the form of verification
has been carried

300
00:12:18,550 --> 00:12:20,400
by the exact set of analyzing tools,

301
00:12:20,400 --> 00:12:22,610
and this is where the
strength of the language is.

302
00:12:22,610 --> 00:12:24,555
So exactly analyzing tools.

303
00:12:24,555 --> 00:12:27,890
These tools include GNATProve, GNATStack,

304
00:12:27,890 --> 00:12:30,300
GNATTest and GNATEmulator.

305
00:12:30,300 --> 00:12:32,280
Essentially what this tool gives you

306
00:12:32,280 --> 00:12:34,740
as a attributes for the
SPARK language itself,

307
00:12:34,740 --> 00:12:37,630
it can statically prove
various different things.

308
00:12:37,630 --> 00:12:40,870
It can prove that these
dynamic checks can never fail

309
00:12:40,870 --> 00:12:43,610
for example, or they also can warranty you

310
00:12:43,610 --> 00:12:45,620
there is absence of runtime errors,

311
00:12:45,620 --> 00:12:48,410
essentially everything is in
the known and correct states,

312
00:12:48,410 --> 00:12:50,470
because of that, you don't have errors,

313
00:12:50,470 --> 00:12:52,260
or runtime errors at least.

314
00:12:52,260 --> 00:12:55,740
And also all of that
it's formally verified,

315
00:12:55,740 --> 00:12:57,650
which is very interesting and cool,

316
00:12:57,650 --> 00:13:00,030
because that gives you a
form of verified proofs

317
00:13:00,030 --> 00:13:03,300
that all of these
attributes are being intact.

318
00:13:03,300 --> 00:13:05,500
So what you should think about that

319
00:13:05,500 --> 00:13:07,060
from the attacker's perspective,

320
00:13:07,060 --> 00:13:09,220
it's essentially a memory safe language.

321
00:13:09,220 --> 00:13:12,030
It's a memory safe language,
which is formally proved.

322
00:13:12,030 --> 00:13:14,300
So it's a kind of like a RUST.

323
00:13:14,300 --> 00:13:17,170
RUST is not formally proved,
but it's a memory safe language

324
00:13:17,170 --> 00:13:21,330
and it's much stronger
typing system than RUST,

325
00:13:21,330 --> 00:13:23,210
because it has very strong typing system,

326
00:13:23,210 --> 00:13:25,000
and because it's much stronger than RUST,

327
00:13:25,000 --> 00:13:27,890
also there's lack of problems
like arithmetic overflows,

328
00:13:27,890 --> 00:13:30,000
integer overflows, underflows, et cetera,

329
00:13:30,000 --> 00:13:31,180
which is very interesting.

330
00:13:31,180 --> 00:13:33,620
And because of that, it's
a very secure language.

331
00:13:33,620 --> 00:13:34,840
It's traditionally have been,

332
00:13:34,840 --> 00:13:37,610
it was used traditionally
in the industries,

333
00:13:37,610 --> 00:13:39,940
which are critical,
like avionics, railways

334
00:13:39,940 --> 00:13:41,880
or defense system.

335
00:13:41,880 --> 00:13:44,570
So we should think about any language

336
00:13:44,570 --> 00:13:45,890
from the developer's perspective

337
00:13:45,890 --> 00:13:48,880
that you would like to model a
correct states of the machine

338
00:13:48,880 --> 00:13:50,770
of the software and the hardware

339
00:13:50,770 --> 00:13:53,290
and language allows you to do it more easy

340
00:13:53,290 --> 00:13:56,000
or more hard to do that,
like in the C language,

341
00:13:56,000 --> 00:13:58,080
there is a lot of undefined behaviors,

342
00:13:58,080 --> 00:14:01,860
so modeling along the machine
states, it's very difficult

343
00:14:01,860 --> 00:14:05,250
and that's why you have
various undefined states.

344
00:14:05,250 --> 00:14:08,690
Other language it's slightly
more accurate in that case

345
00:14:08,690 --> 00:14:11,349
and allows you to give you
a more accurate modeling

346
00:14:11,349 --> 00:14:15,740
of the states, and that's why
there is less unambiguously

347
00:14:15,740 --> 00:14:17,590
and less unknown states there.

348
00:14:17,590 --> 00:14:18,860
However, because SPARK,

349
00:14:18,860 --> 00:14:21,310
it's a much more strict
than other essentially,

350
00:14:21,310 --> 00:14:22,660
it's the most closest way

351
00:14:22,660 --> 00:14:24,630
how we can get to the correct state.

352
00:14:24,630 --> 00:14:28,670
However, because the strength
is in the analyzing tools,

353
00:14:28,670 --> 00:14:32,180
essentially this is what
the tools can give you

354
00:14:32,180 --> 00:14:33,040
as an attribute.

355
00:14:33,040 --> 00:14:34,680
However, there is some kind of values

356
00:14:34,680 --> 00:14:35,720
in the SPARK language.

357
00:14:35,720 --> 00:14:37,900
Imagine you wanna call the libraries,

358
00:14:37,900 --> 00:14:39,810
which is implemented in
the different language,

359
00:14:39,810 --> 00:14:42,720
like in the C, essentially SPARK analyzer

360
00:14:42,720 --> 00:14:46,140
will not be able to prove
that the code written in C,

361
00:14:46,140 --> 00:14:50,560
which you cause from SPARK is
also correct in unknown state,

362
00:14:50,560 --> 00:14:52,320
so that's why they survive from that.

363
00:14:52,320 --> 00:14:53,880
And how does it look in the practice?

364
00:14:53,880 --> 00:14:56,340
So if you write a program
and you make a mistakes,

365
00:14:56,340 --> 00:14:59,970
the prover will not only
tell you where the bug is

366
00:14:59,970 --> 00:15:01,700
in the which line, and which file,

367
00:15:01,700 --> 00:15:03,980
but also they gives you
proof of concept essentially.

368
00:15:03,980 --> 00:15:05,900
So what are the values necessary

369
00:15:05,900 --> 00:15:08,410
to generate the bug or error?

370
00:15:08,410 --> 00:15:10,480
This example on the top,
you can see that the prover

371
00:15:10,480 --> 00:15:13,280
tells you that there is
a problem divide by zero,

372
00:15:13,280 --> 00:15:16,960
which may fail when the
variable B has value 42.

373
00:15:16,960 --> 00:15:18,970
So it not only gives you the problem

374
00:15:18,970 --> 00:15:20,580
and does not only tells you the problem,

375
00:15:20,580 --> 00:15:22,460
but also gives you the
necessary condition,

376
00:15:22,460 --> 00:15:24,770
how to execute the problem,
which is very interesting.

377
00:15:24,770 --> 00:15:26,450
Another example could be medium

378
00:15:26,450 --> 00:15:31,450
array index track might fail
when the MyIndex have value 36.

379
00:15:31,610 --> 00:15:32,680
So it's very interesting.

380
00:15:32,680 --> 00:15:35,250
And then we're starting to
think about that a bit more.

381
00:15:35,250 --> 00:15:38,050
And so we wanted to analyze,
like what are the problems

382
00:15:38,050 --> 00:15:41,780
which specific tools can
catch or cannot catch?

383
00:15:41,780 --> 00:15:43,780
And we found one of the
interesting scenario

384
00:15:43,780 --> 00:15:46,820
where I was able still
to generate a program,

385
00:15:46,820 --> 00:15:49,890
which prover says this
doesn't have any problems,

386
00:15:49,890 --> 00:15:51,370
which is you see on the top,

387
00:15:51,370 --> 00:15:53,150
on the slide, mark on the green,

388
00:15:53,150 --> 00:15:55,320
the prover said there
is no problems there.

389
00:15:55,320 --> 00:15:56,760
However, when we run that

390
00:15:56,760 --> 00:15:59,705
we were able to execute stack
(indistinct) vulnerability,

391
00:15:59,705 --> 00:16:03,790
and generally the exception,
because lack of the memory.

392
00:16:03,790 --> 00:16:05,740
However, as we said before,

393
00:16:05,740 --> 00:16:07,230
the SPARKS supposed to give you warranty

394
00:16:07,230 --> 00:16:09,560
there is absence of
errors, runtime errors.

395
00:16:09,560 --> 00:16:11,040
So how is it even possible?

396
00:16:11,040 --> 00:16:13,890
And then we started to run
other tools, like GNATStack

397
00:16:13,890 --> 00:16:16,950
and we realized that even
GNATProve didn't find a bug,

398
00:16:16,950 --> 00:16:20,100
this problem, GNATStack did,
and on the bottom, on the red,

399
00:16:20,100 --> 00:16:22,870
you can see that they
said that the GNATStack

400
00:16:22,870 --> 00:16:24,240
analyzed all of the different phases

401
00:16:24,240 --> 00:16:28,890
and the analyzer could be a
problem with stack (indistinct).

402
00:16:28,890 --> 00:16:31,360
So what did we learn from
that kind of approach?

403
00:16:31,360 --> 00:16:33,830
Essentially, we learned
that you can compile

404
00:16:33,830 --> 00:16:35,580
still a buggy code,

405
00:16:35,580 --> 00:16:37,510
but the problems are detected by the tools

406
00:16:37,510 --> 00:16:40,260
and the developers might
not run them at all.

407
00:16:40,260 --> 00:16:42,480
So it's very interesting attribute

408
00:16:42,480 --> 00:16:44,960
because it depends on
the developing scenarios

409
00:16:44,960 --> 00:16:47,890
and the process of developing
the software on the company.

410
00:16:47,890 --> 00:16:50,060
And also tools are
orthogonal to themselves

411
00:16:50,060 --> 00:16:51,860
because they detect
completely different classes

412
00:16:51,860 --> 00:16:53,930
of the problem, and to be fully protected,

413
00:16:53,930 --> 00:16:56,540
you must run all of the provided tools.

414
00:16:56,540 --> 00:16:57,920
And again it depends

415
00:16:57,920 --> 00:17:00,230
what the process of
software development is

416
00:17:00,230 --> 00:17:03,010
to be able to find out if
all of these tools are run.

417
00:17:03,010 --> 00:17:06,020
And another problem is
there is no clear definition

418
00:17:06,020 --> 00:17:07,570
of what are the classes of the problems,

419
00:17:07,570 --> 00:17:09,460
which can or cannot be detected.

420
00:17:09,460 --> 00:17:11,690
It's very limited public information,

421
00:17:11,690 --> 00:17:13,370
what can be detected, what is not.

422
00:17:13,370 --> 00:17:15,110
And again, we didn't find anything

423
00:17:15,110 --> 00:17:16,990
from the security researchers perspective.

424
00:17:16,990 --> 00:17:18,030
So what did we do?

425
00:17:18,030 --> 00:17:21,280
We end up trying to do
more research and find out,

426
00:17:21,280 --> 00:17:22,870
because if nobody did it before us,

427
00:17:22,870 --> 00:17:25,110
we must do it by ourself.

428
00:17:25,110 --> 00:17:27,100
So this is what we end up doing.

429
00:17:27,100 --> 00:17:29,780
We starting to evaluate,
it's kind of strong word,

430
00:17:29,780 --> 00:17:32,440
but let's say analyzing
the AdaCore/SPARK language

431
00:17:32,440 --> 00:17:34,780
from the offensive security perspective.

432
00:17:34,780 --> 00:17:38,910
And we divided the language,

433
00:17:38,910 --> 00:17:41,850
we divided to the, all
of the security problems,

434
00:17:41,850 --> 00:17:45,300
software problems, so the
general buckets of the problem

435
00:17:45,300 --> 00:17:46,730
and one of the most popular one

436
00:17:46,730 --> 00:17:48,850
is exactly general memory corruption bug,

437
00:17:48,850 --> 00:17:50,700
and compare with the other languages.

438
00:17:50,700 --> 00:17:52,740
And so essentially SPARK as we mentioned,

439
00:17:52,740 --> 00:17:53,940
is a memory safe language.

440
00:17:53,940 --> 00:17:55,880
So none of these kinds of problem exist.

441
00:17:55,880 --> 00:17:58,840
There is some kind of caveats
which I don't wanna focus now.

442
00:17:58,840 --> 00:18:00,407
However you can think about that,

443
00:18:00,407 --> 00:18:02,330
it's a memory safe language,

444
00:18:02,330 --> 00:18:05,150
so memory corruption doesn't exist there.

445
00:18:05,150 --> 00:18:08,130
And then we moved to the
general pointer security.

446
00:18:08,130 --> 00:18:09,540
And it's interesting because SPARK

447
00:18:09,540 --> 00:18:11,600
doesn't have pointers at all.

448
00:18:11,600 --> 00:18:13,060
So if it doesn't have pointers,

449
00:18:13,060 --> 00:18:15,200
the pointer security doesn't apply there.

450
00:18:15,200 --> 00:18:17,000
However, there is still
kind of corner case,

451
00:18:17,000 --> 00:18:20,440
like imagine we are able to
generate the stack (indistinct).

452
00:18:20,440 --> 00:18:22,270
So that's why uncontrolled
memory allocation

453
00:18:22,270 --> 00:18:25,500
kind of semi exist, if you
don't run the GNATStack.

454
00:18:25,500 --> 00:18:27,260
But it can be of course
catch by the tool set

455
00:18:27,260 --> 00:18:28,330
if you run them correctly.

456
00:18:28,330 --> 00:18:31,110
And also they could be some
kind of double (indistinct).

457
00:18:31,110 --> 00:18:34,460
Imagine your DMA twice
the same as the memory,

458
00:18:34,460 --> 00:18:36,890
it's kind of possible to have like that.

459
00:18:36,890 --> 00:18:38,910
And then we move to the
arithmetic security,

460
00:18:38,910 --> 00:18:41,270
and as I mentioned, the
SPARK gives you ability

461
00:18:41,270 --> 00:18:45,160
to have very precise type language.

462
00:18:45,160 --> 00:18:48,580
Essentially you can define
own type in the language

463
00:18:48,580 --> 00:18:50,560
and also define own boundaries.

464
00:18:50,560 --> 00:18:52,090
And then the prover will tell you

465
00:18:52,090 --> 00:18:54,730
if anyone crossed these
boundaries, which we defined.

466
00:18:54,730 --> 00:18:56,710
So essentially because of that,

467
00:18:56,710 --> 00:18:59,390
you don't even need to use the
general types like integers.

468
00:18:59,390 --> 00:19:01,260
You just defined only one every time,

469
00:19:01,260 --> 00:19:04,200
or a new model in your
program, your hardware.

470
00:19:04,200 --> 00:19:07,290
Essentially, that's why
none of this problem exists,

471
00:19:07,290 --> 00:19:09,230
like integer overflow, and underflow

472
00:19:09,230 --> 00:19:12,510
or arithmetic overflow
doesn't exist in the SPARK.

473
00:19:12,510 --> 00:19:14,730
And then we also have
other types of the problem

474
00:19:14,730 --> 00:19:16,920
like missing default
case in switch stipend

475
00:19:16,920 --> 00:19:18,810
or assigning instead of comparing,

476
00:19:18,810 --> 00:19:20,820
and these problems doesn't exist in SPARK

477
00:19:20,820 --> 00:19:22,630
because tools easily catch it up.

478
00:19:22,630 --> 00:19:24,260
And then we're starting to find out

479
00:19:24,260 --> 00:19:26,760
something more interesting,
like a parallel execution.

480
00:19:26,760 --> 00:19:28,385
Essentially, what about the problems

481
00:19:28,385 --> 00:19:30,290
like race condition or deadlocks?

482
00:19:30,290 --> 00:19:33,070
Essentially, it's possible to have them,

483
00:19:33,070 --> 00:19:37,180
but AdaCore working on the
extension to SPARK, (indistinct),

484
00:19:37,180 --> 00:19:40,080
which supposed to close that
gap, but from our perspective,

485
00:19:40,080 --> 00:19:42,830
it was not very interesting
because the boot software

486
00:19:42,830 --> 00:19:45,480
was not running essentially parallel.

487
00:19:45,480 --> 00:19:46,550
It was single execution,

488
00:19:46,550 --> 00:19:48,137
so it was not very interesting for us,

489
00:19:48,137 --> 00:19:49,640
but it's worth to mention.

490
00:19:49,640 --> 00:19:52,240
And then in the entry
move to the logical box.

491
00:19:52,240 --> 00:19:54,040
So essentially in the logical box,

492
00:19:54,040 --> 00:19:58,100
the prover and neither GNATStack,

493
00:19:58,100 --> 00:19:59,680
none of the tools were,

494
00:19:59,680 --> 00:20:01,930
can catch if you badly
design the software,

495
00:20:01,930 --> 00:20:04,000
because you try to model the hardware

496
00:20:04,000 --> 00:20:08,720
and to try to generate
any kind of software,

497
00:20:08,720 --> 00:20:11,560
we transformed that specific
states, which we model.

498
00:20:11,560 --> 00:20:13,360
And then in the end,
if you barely do that,

499
00:20:13,360 --> 00:20:15,120
of course SPARK won't be able
to catch the (indistinct),

500
00:20:15,120 --> 00:20:17,410
badly designed or badly modeled,

501
00:20:17,410 --> 00:20:20,120
because this is intention
of your software.

502
00:20:20,120 --> 00:20:21,630
So this kind of problem still exists

503
00:20:21,630 --> 00:20:23,830
if you're accurately
modeling the hardware,

504
00:20:23,830 --> 00:20:26,170
or if you accurately handing the DMA

505
00:20:26,170 --> 00:20:27,300
or barely designed the software.

506
00:20:27,300 --> 00:20:28,950
So this is exactly the path

507
00:20:28,950 --> 00:20:31,640
which SPARK can not help you much.

508
00:20:31,640 --> 00:20:33,800
So what did we learn from this evaluation?

509
00:20:33,800 --> 00:20:35,097
So, essentially, as we mentioned before,

510
00:20:35,097 --> 00:20:37,280
you can still compile the buggy code

511
00:20:37,280 --> 00:20:39,990
and because the problem
are detected by the tools

512
00:20:39,990 --> 00:20:42,040
and developers just might not run them.

513
00:20:42,040 --> 00:20:44,130
And again, the tools are orthogonal,

514
00:20:44,130 --> 00:20:46,420
so they detect different
classes of the problem.

515
00:20:46,420 --> 00:20:48,160
So again, to be fully protected,

516
00:20:48,160 --> 00:20:51,200
you must run all of the
tools, not just one of them.

517
00:20:51,200 --> 00:20:54,460
And from analysis of
the implementation box,

518
00:20:54,460 --> 00:20:57,490
we realized that there still
might be security issue

519
00:20:57,490 --> 00:20:59,690
when you, in the design problems,

520
00:20:59,690 --> 00:21:01,580
or also some kinds of logical errors,

521
00:21:01,580 --> 00:21:04,210
but there is no kind of
memory safety, for example.

522
00:21:04,210 --> 00:21:06,200
So it's not worth to focus on that.

523
00:21:06,200 --> 00:21:08,610
And again, there is an
additional cost of the problem

524
00:21:08,610 --> 00:21:10,270
that could be introduced by the compiler

525
00:21:10,270 --> 00:21:13,300
because bugs can be introduced
by the compiler itself,

526
00:21:13,300 --> 00:21:14,700
even if it's not in the software

527
00:21:14,700 --> 00:21:16,200
or maybe they're in the hardware.

528
00:21:16,200 --> 00:21:17,700
However, to be able to catch

529
00:21:17,700 --> 00:21:19,550
these three types of the problems,

530
00:21:19,550 --> 00:21:21,910
we need to analyze the binary, yes.

531
00:21:21,910 --> 00:21:23,900
So because we need to analyze the binary,

532
00:21:23,900 --> 00:21:26,210
we need to have tools
who can target the RISC-V

533
00:21:26,210 --> 00:21:29,150
and that was the problem
that during this research,

534
00:21:29,150 --> 00:21:32,860
neither either Pro nor Ghidra
natively supported RISC-V.

535
00:21:32,860 --> 00:21:34,320
There was some kind of progress,

536
00:21:34,320 --> 00:21:37,970
but there were no essentially
native support of RISC-V.

537
00:21:37,970 --> 00:21:40,580
So we decided to focus on the Ghidra

538
00:21:40,580 --> 00:21:44,770
and add on a custom plugin to Ghidra,

539
00:21:44,770 --> 00:21:48,100
to be able to analyze the
binary which was running there,

540
00:21:48,100 --> 00:21:50,250
but was generated from SPARK language.

541
00:21:50,250 --> 00:21:52,670
And this is what we end up
doing, and how did we do it?

542
00:21:52,670 --> 00:21:55,530
So Ghidra 9.0, that time
is what was the newest one,

543
00:21:55,530 --> 00:21:57,360
didn't support natively RISC-V.

544
00:21:57,360 --> 00:22:00,500
More over, we were dealing
with the customized V chips

545
00:22:00,500 --> 00:22:01,970
not the standard RISC-V chip.

546
00:22:01,970 --> 00:22:05,150
So even if you hate them,
it will not work for us.

547
00:22:05,150 --> 00:22:08,950
So again, RISC-V is
huge and implementation

548
00:22:08,950 --> 00:22:12,020
of entire RISC-V base
would take us tons of time.

549
00:22:12,020 --> 00:22:16,280
And traditionally we needed to
add the custom feature there,

550
00:22:16,280 --> 00:22:19,180
a custom extension, not
just the RISC-V base.

551
00:22:19,180 --> 00:22:23,360
So what we end up doing,
we found on the GitHub,

552
00:22:23,360 --> 00:22:25,930
a few RISC-V base plugins for Ghidra,

553
00:22:25,930 --> 00:22:28,827
which had different
implementation of RISC-V.

554
00:22:28,827 --> 00:22:31,590
And we decided to integrate
one of the plugin,

555
00:22:31,590 --> 00:22:33,120
which we thought it's a good one

556
00:22:33,120 --> 00:22:35,580
on the top of three of Ghidra itself.

557
00:22:35,580 --> 00:22:38,070
And a few months after which
is what is interesting,

558
00:22:38,070 --> 00:22:40,910
Ghidra 9.2 brought the
natively RISC-V support,

559
00:22:40,910 --> 00:22:42,200
where they use exactly the same plugin

560
00:22:42,200 --> 00:22:44,940
which we use in our research.

561
00:22:44,940 --> 00:22:47,560
And where to start, so essentially

562
00:22:47,560 --> 00:22:49,830
we successfully integrate
RISC-V plugin first,

563
00:22:49,830 --> 00:22:51,560
but of course we need to modify it

564
00:22:51,560 --> 00:22:53,270
because we have custom extensions.

565
00:22:53,270 --> 00:22:55,767
So Ghidra is using SLEIGH
language to describe the CPU

566
00:22:55,767 --> 00:22:57,200
and what is SLEIGH language?

567
00:22:57,200 --> 00:23:00,300
And SLEIGH language is a
processor specification language

568
00:23:00,300 --> 00:23:04,220
developed just for Ghidra and
it heritage from the SLED.

569
00:23:04,220 --> 00:23:07,530
And what is not cool that
there was at that time at least

570
00:23:07,530 --> 00:23:09,450
very little documentation about that.

571
00:23:09,450 --> 00:23:12,600
So if you wanna implement
some kind of a simple CPU,

572
00:23:12,600 --> 00:23:14,750
you can use as a source of knowledge

573
00:23:14,750 --> 00:23:17,030
already implemented
CPUs in the source code.

574
00:23:17,030 --> 00:23:19,510
And based on that, you
can just implement on one.

575
00:23:19,510 --> 00:23:21,853
but if you wanna do
something more complex,

576
00:23:22,720 --> 00:23:24,060
this could be a very painful,

577
00:23:24,060 --> 00:23:26,410
and it was very painful at least for me.

578
00:23:26,410 --> 00:23:28,290
So additionally we found,

579
00:23:28,290 --> 00:23:30,850
in fact only one interesting
source of knowledge.

580
00:23:30,850 --> 00:23:34,260
It was a presentation
made by Giulaume Valadon,

581
00:23:34,260 --> 00:23:36,100
which we link here on the slide.

582
00:23:36,100 --> 00:23:38,680
So what do you need to do to
implement CPU in the Ghidra?

583
00:23:38,680 --> 00:23:40,470
Essentially to create a couple of files,

584
00:23:40,470 --> 00:23:42,010
which are listed here.

585
00:23:42,010 --> 00:23:44,300
And so then we also defined
the model manifests,

586
00:23:44,300 --> 00:23:46,320
how to tie them together and compile.

587
00:23:46,320 --> 00:23:47,910
However, we already had this file

588
00:23:47,910 --> 00:23:50,660
because we have from the
plugin, USB base plugin,

589
00:23:50,660 --> 00:23:52,800
but we needed to modify them,

590
00:23:52,800 --> 00:23:56,120
especially SLASPEC to be
able to add custom extension.

591
00:23:56,120 --> 00:23:57,420
And this is exactly the file

592
00:23:57,420 --> 00:24:00,277
where you define the register
definition, the tokens,

593
00:24:00,277 --> 00:24:02,460
the aliases, the instruction, et cetera.

594
00:24:02,460 --> 00:24:04,427
And Ghidra, what is interesting,

595
00:24:04,427 --> 00:24:05,950
and it's worth to keep in mind,

596
00:24:05,950 --> 00:24:10,690
allows you to compile
the bad model SLASPEC,

597
00:24:10,690 --> 00:24:12,610
as soon as the syntax is correct,

598
00:24:12,610 --> 00:24:14,070
as long as the syntax is correct,

599
00:24:14,070 --> 00:24:16,340
which essentially you will not even know

600
00:24:16,340 --> 00:24:18,480
if you make a mistake,
then you run the Ghidra,

601
00:24:18,480 --> 00:24:20,820
you think everything works,
then you meet the instruction,

602
00:24:20,820 --> 00:24:22,430
which you barely implement on the runtime.

603
00:24:22,430 --> 00:24:23,910
And then you see tons of Java exception,

604
00:24:23,910 --> 00:24:26,020
and maybe the program will crash.

605
00:24:26,020 --> 00:24:28,580
So we use essentially "check
and try" and "calm down"

606
00:24:28,580 --> 00:24:31,000
techniques to be able to
achieve what we wanted.

607
00:24:31,000 --> 00:24:33,190
However, let's briefly talk about

608
00:24:33,190 --> 00:24:35,910
how to do these kinds of
custom extension or tokens.

609
00:24:35,910 --> 00:24:37,590
So Ghidra plugin CPU implementation.

610
00:24:37,590 --> 00:24:39,750
So essentially at first
you define the token,

611
00:24:39,750 --> 00:24:41,430
and the token of the instruction here,

612
00:24:41,430 --> 00:24:43,280
defines common the bit
instruction narrative,

613
00:24:43,280 --> 00:24:45,560
and you can define them
in the range of the bits

614
00:24:45,560 --> 00:24:46,890
which you're focus with,

615
00:24:46,890 --> 00:24:48,920
from the values or the axis of the name.

616
00:24:48,920 --> 00:24:52,460
Here on the bottom you have,
for example, the name CSR zero,

617
00:24:52,460 --> 00:24:54,230
which will be representing the bits

618
00:24:54,230 --> 00:24:57,300
from 20 to 27 as a token.

619
00:24:57,300 --> 00:24:59,270
And then you also can define the register.

620
00:24:59,270 --> 00:25:01,620
And RISC-V, for example,
have status registers,

621
00:25:01,620 --> 00:25:04,160
like U status, from the user mode status,

622
00:25:04,160 --> 00:25:06,690
which we defined the
registered offs and the size

623
00:25:06,690 --> 00:25:08,810
and the name, and then you
can grow them together.

624
00:25:08,810 --> 00:25:11,440
So you can attach the
variables to the CSR zero.

625
00:25:11,440 --> 00:25:13,200
You can attach the names of the register,

626
00:25:13,200 --> 00:25:16,720
which we define before, and
this is exactly what you do.

627
00:25:16,720 --> 00:25:19,140
We just, exactly also what we did.

628
00:25:19,140 --> 00:25:22,660
We just define the custom
extension, the custom tokens,

629
00:25:22,660 --> 00:25:25,140
the custom register, the custom variables,

630
00:25:25,140 --> 00:25:27,660
and then we starting to
define the custom instruction

631
00:25:27,660 --> 00:25:29,380
and how to define the instruction.

632
00:25:29,380 --> 00:25:32,290
So this is example of the
compressed ADA instruction.

633
00:25:32,290 --> 00:25:35,050
You essentially define
what are the operands,

634
00:25:35,050 --> 00:25:38,400
there's two operands,
you have D and CRS-2.

635
00:25:38,400 --> 00:25:40,710
And then you define what are
the values of the tokens,

636
00:25:40,710 --> 00:25:44,820
which we define as previously
as (indistinct) mapping.

637
00:25:44,820 --> 00:25:47,750
And then you define what they
must be necessarily values

638
00:25:47,750 --> 00:25:50,170
for them to be able to decode
these specific instruction.

639
00:25:50,170 --> 00:25:54,100
So example the cop-001
token with the value two,

640
00:25:54,100 --> 00:25:56,960
and the bits between 13 to 15

641
00:25:56,960 --> 00:25:59,479
interpreted as a token
cop (indistinct) 15,

642
00:25:59,479 --> 00:26:01,510
(indistinct) value four,
et cetera, et cetera,

643
00:26:01,510 --> 00:26:03,400
the final of the bits and
then the Ghidra will know

644
00:26:03,400 --> 00:26:04,990
that this is exactly the instruction

645
00:26:04,990 --> 00:26:06,060
which you're looking for.

646
00:26:06,060 --> 00:26:07,580
And then you define the (indistinct),

647
00:26:07,580 --> 00:26:10,170
if it matches you go to
(indistinct) in the compressed,

648
00:26:10,170 --> 00:26:13,430
then add the instruction, we
essentially add two operands,

649
00:26:13,430 --> 00:26:15,210
so that's what we did.

650
00:26:15,210 --> 00:26:16,700
And then there's some other examples

651
00:26:16,700 --> 00:26:20,120
of the compress branch equal zero.

652
00:26:20,120 --> 00:26:22,150
It's exactly the same,
you define the tokens,

653
00:26:22,150 --> 00:26:23,640
you define the values of the tokens,

654
00:26:23,640 --> 00:26:26,250
which are necessary to,
and call the instruction.

655
00:26:26,250 --> 00:26:29,410
You define operands and
then (indistinct) will check

656
00:26:29,410 --> 00:26:34,120
if the operands is zero, then
you just jump and that's all.

657
00:26:34,120 --> 00:26:36,020
And in the end, when we
starting to add that,

658
00:26:36,020 --> 00:26:37,930
and we add the custom extension,

659
00:26:37,930 --> 00:26:42,510
the top of the RISC-V base ISA
on this plugin which we had,

660
00:26:42,510 --> 00:26:45,130
we end up having this, which is very cool.

661
00:26:45,130 --> 00:26:47,850
So essentially what, this is
a screenshot from the Ghidra,

662
00:26:47,850 --> 00:26:50,110
that shows you that essentially

663
00:26:50,110 --> 00:26:52,520
it correctly decompile the program,

664
00:26:52,520 --> 00:26:55,740
and you have forfeited the compiler

665
00:26:55,740 --> 00:26:57,140
on the right side if you see.

666
00:26:57,140 --> 00:26:58,895
On the left side, you have the assembly.

667
00:26:58,895 --> 00:27:02,626
And then the right side we
starting to have for free

668
00:27:02,626 --> 00:27:05,220
the compiler, and as you
can see this is a binary

669
00:27:05,220 --> 00:27:07,020
which was generated from the SPARK.

670
00:27:07,020 --> 00:27:08,420
This is a simple language they found

671
00:27:08,420 --> 00:27:10,720
like Ada, RV from RISC-V, et cetera.

672
00:27:10,720 --> 00:27:14,100
However, that's the idea
that we also got for free,

673
00:27:14,100 --> 00:27:17,140
not only that this assembly,
but also on the analyzer.

674
00:27:17,140 --> 00:27:22,140
We also had the custom extension
was automatically reflected

675
00:27:22,360 --> 00:27:23,920
in the decompiler,

676
00:27:23,920 --> 00:27:27,640
which of course obviously
make our life much easier.

677
00:27:27,640 --> 00:27:30,090
So, I've linked everything together.

678
00:27:30,090 --> 00:27:31,540
We already know what to look for

679
00:27:31,540 --> 00:27:32,827
because we analyze the SPARK

680
00:27:32,827 --> 00:27:34,910
and we know what the
limits for the language

681
00:27:34,910 --> 00:27:37,560
and to what we can hunt for
from the offensive perspective,

682
00:27:37,560 --> 00:27:39,400
obviously not memory safety issues.

683
00:27:39,400 --> 00:27:42,980
However, we also know that we
were learning on the RISC-V

684
00:27:42,980 --> 00:27:45,920
and it was not normal RISC-V,
but the custom RISC-V chip.

685
00:27:45,920 --> 00:27:50,220
So we focus on the design on
how hardware is more focused.

686
00:27:50,220 --> 00:27:54,730
So we focus on what is
the design of the SPARK,

687
00:27:54,730 --> 00:27:56,660
software SPARK, how is it designed

688
00:27:56,660 --> 00:28:00,240
and how to implement the custom
hardware, how is it modeled

689
00:28:00,240 --> 00:28:02,950
because this we know what is
there and it's not standard.

690
00:28:02,950 --> 00:28:07,880
So what we saw, we saw
during analyzing the binary,

691
00:28:07,880 --> 00:28:10,030
because that's why we needed
to have this Ghidra plugin,

692
00:28:10,030 --> 00:28:12,490
that very first, very,
very first instruction

693
00:28:13,370 --> 00:28:16,020
of this boot software was
configuring the hardware,

694
00:28:16,020 --> 00:28:18,750
also custom hardware, and not only,

695
00:28:18,750 --> 00:28:20,620
but additionally also custom hardware.

696
00:28:20,620 --> 00:28:22,720
As soon as the first instruction run

697
00:28:22,720 --> 00:28:24,730
is starting to configure the hardware.

698
00:28:24,730 --> 00:28:28,290
And later we see that instructions

699
00:28:28,290 --> 00:28:30,780
of setting up the MTVEC value.

700
00:28:30,780 --> 00:28:33,080
And then we starting
(indistinct) what is MTVEC value?

701
00:28:33,080 --> 00:28:34,710
And officially RISC-V convention

702
00:28:34,710 --> 00:28:37,920
says that MTVEC is defined
as a register read only and,

703
00:28:37,920 --> 00:28:40,010
or read/write, which holds the base

704
00:28:40,010 --> 00:28:41,850
of the rest of the trap handler.

705
00:28:41,850 --> 00:28:44,720
And by default RISC-V always
handles all of the traps

706
00:28:44,720 --> 00:28:46,993
in the most privileged
mode, which is M mode,

707
00:28:46,993 --> 00:28:50,080
so that it can delegate this
trap to the least privileged,

708
00:28:50,080 --> 00:28:53,480
the other modes if it's needed to.

709
00:28:53,480 --> 00:28:55,127
And when the essentially trap happens,

710
00:28:55,127 --> 00:28:57,430
the RISC-V switches to the machine mode

711
00:28:57,430 --> 00:29:00,240
and set the instruction pointer counter

712
00:29:01,210 --> 00:29:04,650
to the value defined
in the register MTVEC.

713
00:29:04,650 --> 00:29:06,920
And MTVEC can be defined in the two modes.

714
00:29:06,920 --> 00:29:10,250
There is a mode which essentially
keeps the direct pointer,

715
00:29:10,250 --> 00:29:11,760
which is just jumped there

716
00:29:11,760 --> 00:29:14,680
and is defined by the
two significant bits.

717
00:29:14,680 --> 00:29:17,800
So bit zero and one, if it's
zero then we have direct mode.

718
00:29:17,800 --> 00:29:19,510
You just jumped to the pointer.

719
00:29:19,510 --> 00:29:22,410
Or if it's non zero,
then it's being treated,

720
00:29:22,410 --> 00:29:24,690
the value there as a vectorized

721
00:29:24,690 --> 00:29:27,430
like IDT table x86, for example.

722
00:29:27,430 --> 00:29:28,583
So then we started to think

723
00:29:28,583 --> 00:29:31,300
that MTVEC is essentially configured

724
00:29:31,300 --> 00:29:33,290
after we configure the hardware.

725
00:29:33,290 --> 00:29:35,990
So what will happen if any interrupt arise

726
00:29:35,990 --> 00:29:38,530
before the MTVEC is initialized,

727
00:29:38,530 --> 00:29:41,260
because it can happen during
initialization of the hardware.

728
00:29:41,260 --> 00:29:42,880
And this is exactly what we discovered

729
00:29:42,880 --> 00:29:44,920
that essentially there is a problem

730
00:29:44,920 --> 00:29:47,680
because RISC-V MTVEC
registers specification

731
00:29:47,680 --> 00:29:52,140
does not define the initial
value of MTVEC at all,

732
00:29:52,140 --> 00:29:53,620
so it's undefined.

733
00:29:53,620 --> 00:29:55,020
However, when we're starting

734
00:29:55,020 --> 00:29:59,060
to analyze a few different
implementation of RISC-V,

735
00:29:59,060 --> 00:30:01,450
we found out that most of
the tests and implementation

736
00:30:01,450 --> 00:30:03,270
set it to zero anyway,

737
00:30:03,270 --> 00:30:06,250
but in many implementations,
zero is not a valid address,

738
00:30:06,250 --> 00:30:08,200
or if it's valid, it's not mapped.

739
00:30:08,200 --> 00:30:11,330
And then the reference
to it, to MTVEC pointer

740
00:30:11,330 --> 00:30:13,580
which is known will generate an exception.

741
00:30:13,580 --> 00:30:15,530
And this is kind of interesting

742
00:30:15,530 --> 00:30:17,870
because if there's any exception generated

743
00:30:17,870 --> 00:30:21,280
before initialize MTVEC
register, RISC-V ends up

744
00:30:21,280 --> 00:30:23,320
in a very stable
infinitive exception loop,

745
00:30:23,320 --> 00:30:25,450
because it's starting for
the reference an old pointer,

746
00:30:25,450 --> 00:30:27,680
which is not valid and
generate another exception,

747
00:30:27,680 --> 00:30:30,390
which generate another
exception and so on, so on.

748
00:30:30,390 --> 00:30:33,560
And what was interesting
that during this experiment

749
00:30:33,560 --> 00:30:36,380
RISC-V did not halt, it was not halted,

750
00:30:36,380 --> 00:30:39,860
it continues spinning in the
infinitive exception loop,

751
00:30:39,860 --> 00:30:43,990
and such state is in fact ideal situation

752
00:30:43,990 --> 00:30:46,570
for the fault injection
attack, like glitching attack,

753
00:30:46,570 --> 00:30:48,320
because RISC-V at first is running

754
00:30:48,320 --> 00:30:50,770
in the highest privilege
mode, which is M mode,

755
00:30:50,770 --> 00:30:54,380
and constantly dereferencing
the glitchable register.

756
00:30:54,380 --> 00:30:57,070
And so this is the
first the bug essential,

757
00:30:57,070 --> 00:31:00,500
which we found that ISA does
not define the initial value

758
00:31:00,500 --> 00:31:04,000
of MTVEC register, and
the second bug is that,

759
00:31:04,000 --> 00:31:07,590
ISA allows you to have
infinitive exception loop

760
00:31:07,590 --> 00:31:09,420
without halting the core.

761
00:31:09,420 --> 00:31:13,440
There is lack of double
or triple fault exception,

762
00:31:13,440 --> 00:31:15,830
which is kind of interesting.

763
00:31:15,830 --> 00:31:18,660
And however, how to exploit
these kind of issues

764
00:31:18,660 --> 00:31:21,100
which we found, and this is
where I would like to hand over

765
00:31:21,100 --> 00:31:24,530
to Alex Matrosov, which
physically glitch the RISC-V

766
00:31:24,530 --> 00:31:27,273
and he can take you
over from there, thanks.

767
00:31:28,840 --> 00:31:30,040
- Thanks Adam.

768
00:31:30,040 --> 00:31:32,010
Hello DEFCON, my name is Alex Matrosov,

769
00:31:32,010 --> 00:31:35,340
and I will be walking you over
our exploitation technique

770
00:31:35,340 --> 00:31:39,220
for MTVEC, and it's actually
two important points,

771
00:31:39,220 --> 00:31:41,710
just Adam mentioned it
on the previous slide,

772
00:31:41,710 --> 00:31:44,537
we have MTVEC undefined behavior,

773
00:31:44,537 --> 00:31:49,130
and the core of RISC-V
also doesn't halted,

774
00:31:49,130 --> 00:31:53,393
and it is actually looped after,

775
00:31:54,260 --> 00:31:58,440
search of an exception happening
with undefined behavior

776
00:31:58,440 --> 00:32:00,410
of MTVEC instruction.

777
00:32:00,410 --> 00:32:02,957
But let's talk about the attack scenario

778
00:32:02,957 --> 00:32:06,130
and it is important points,
which you need to know

779
00:32:06,130 --> 00:32:08,540
before we basically
get an actual scenario.

780
00:32:08,540 --> 00:32:12,677
We need to prefill D/I MEM of RISC-V core.

781
00:32:12,677 --> 00:32:15,130
And we can use like external

782
00:32:15,130 --> 00:32:17,350
recover USB boot flow functionality

783
00:32:17,350 --> 00:32:18,537
or access (indistinct).

784
00:32:20,151 --> 00:32:22,830
And second thing we need an ability

785
00:32:22,830 --> 00:32:25,870
to generate an early exception
during core execution.

786
00:32:25,870 --> 00:32:29,543
Basically it is a physical
hardware damage can cause that.

787
00:32:30,570 --> 00:32:32,190
And let's go to this scenario,

788
00:32:32,190 --> 00:32:36,100
let's say we prefilled
IMEM with R as a shellcode,

789
00:32:36,100 --> 00:32:40,097
but it is some interesting
techniques we used to make it

790
00:32:40,097 --> 00:32:43,220
the attack more stable because when,

791
00:32:43,220 --> 00:32:48,220
after successful MTVEC exception,
when we jumping into IMEM,

792
00:32:50,580 --> 00:32:52,730
it can be some random address, right?

793
00:32:52,730 --> 00:32:56,333
And we need to make sure
our code will be executed,

794
00:32:58,060 --> 00:33:00,260
with actual payload.

795
00:33:00,260 --> 00:33:05,160
So we need to pre-fill IMEM
with the NOPs and NOP SLED

796
00:33:05,160 --> 00:33:09,660
will be basically creating
some sort of insurance will be,

797
00:33:09,660 --> 00:33:12,880
get into the random
place, but it will be led

798
00:33:12,880 --> 00:33:17,880
our shell code execution,
and on top of our NOP SLED,

799
00:33:17,950 --> 00:33:20,890
we put actual shellcode with a payload,

800
00:33:20,890 --> 00:33:24,820
and it will be basically the
realistic attack scenario

801
00:33:24,820 --> 00:33:25,883
in our case.

802
00:33:26,760 --> 00:33:29,110
So attack your boot RISC-V core

803
00:33:29,110 --> 00:33:31,590
and then enforce the necessary condition

804
00:33:31,590 --> 00:33:35,250
to generate an early exception
during the software boot

805
00:33:35,250 --> 00:33:40,250
and execute before actually
MTVEC get initialized, right?

806
00:33:42,140 --> 00:33:47,030
So a RISC-V core, you'll be
jumped into the null page

807
00:33:47,030 --> 00:33:50,790
and enters to the state of
the infinite loop exception,

808
00:33:50,790 --> 00:33:53,620
very stable and predictable
state, by the way.

809
00:33:53,620 --> 00:33:56,870
And it's actually one of the
conditions of our success

810
00:33:56,870 --> 00:33:59,610
in this attack scenario.

811
00:33:59,610 --> 00:34:03,833
Attack here glitches
the MTVEC register CSR

812
00:34:05,010 --> 00:34:08,840
and after the value get glitched

813
00:34:10,970 --> 00:34:15,970
because it just a boolean
value, even one big change,

814
00:34:17,080 --> 00:34:20,140
will be changed the condition
of this register, right?

815
00:34:20,140 --> 00:34:25,130
And the looped core, you'll
be point somewhere into IMEM

816
00:34:25,130 --> 00:34:28,780
and the special payload
which we discussed before

817
00:34:28,780 --> 00:34:31,647
will be executed, this R shellcode.

818
00:34:32,550 --> 00:34:36,630
So it's very interesting
and stable attack scenario.

819
00:34:36,630 --> 00:34:39,310
The test that went in different ways,

820
00:34:39,310 --> 00:34:43,160
and I will be explaining
how we actually created

821
00:34:43,160 --> 00:34:45,410
the fault injection
attack in the next slide.

822
00:34:45,410 --> 00:34:50,410
But before we move there one
thing you need to remember,

823
00:34:50,900 --> 00:34:53,900
because MTVEC register has a new page,

824
00:34:53,900 --> 00:34:57,720
it's very likely that the
change of one bit will end up

825
00:34:57,720 --> 00:34:59,230
and generate an address point

826
00:34:59,230 --> 00:35:01,480
in the middle of the NOPs and IMEM.

827
00:35:01,480 --> 00:35:05,220
And it's exactly why we need
the fault injection attack.

828
00:35:05,220 --> 00:35:07,220
And we experimented with a different type

829
00:35:07,220 --> 00:35:10,083
of fault injection
attacks, clock glitching,

830
00:35:12,099 --> 00:35:16,220
voltage glitching, and
actually we try to chip shooter

831
00:35:16,220 --> 00:35:19,440
and with a NOP SLED,
it's actually possible,

832
00:35:19,440 --> 00:35:23,780
but most stable and in our
case because we experiment

833
00:35:23,780 --> 00:35:27,120
with U4 boards and ChipWhisperer.

834
00:35:27,120 --> 00:35:31,030
And it is U4 board with
RISC-V Silicon CPU on it.

835
00:35:31,030 --> 00:35:33,390
So we are actually able

836
00:35:35,900 --> 00:35:39,500
to reach very stable point with
the clock glitching attack.

837
00:35:39,500 --> 00:35:44,500
So on this oscilloscope
diagram you exactly see

838
00:35:44,860 --> 00:35:47,483
the glitch happens with
the clock technique.

839
00:35:48,390 --> 00:35:53,390
But also because we measure this values,

840
00:35:55,137 --> 00:35:58,150
with clock glitching,
even with this small guy,

841
00:35:58,150 --> 00:36:01,530
ChipWhisperer Nano, we
can manage after we await

842
00:36:01,530 --> 00:36:03,890
all the parameters and we have the offsets

843
00:36:03,890 --> 00:36:08,140
of the timeframes, we can
create successful attack

844
00:36:08,140 --> 00:36:11,960
and actually with much cheaper hardware.

845
00:36:11,960 --> 00:36:16,160
So of course, we tried
this complex scenario

846
00:36:16,160 --> 00:36:18,510
in many different environments.

847
00:36:18,510 --> 00:36:22,430
And first of all, thanks
for Nvidia hardware team,

848
00:36:22,430 --> 00:36:25,230
which has actually help us a lot

849
00:36:25,230 --> 00:36:27,970
to play with a simulation environment

850
00:36:27,970 --> 00:36:31,854
with internal hardware,
and actually, first of all,

851
00:36:31,854 --> 00:36:35,490
we realize about this attack
when we've been playing

852
00:36:35,490 --> 00:36:37,153
with some internal tools.

853
00:36:38,540 --> 00:36:43,450
On this slide, you can see
the simulation environment

854
00:36:43,450 --> 00:36:46,560
where we have full event scenario.

855
00:36:46,560 --> 00:36:49,710
On step first, we pull the trigger

856
00:36:49,710 --> 00:36:54,710
to corrupt MTVEC registers,
CSR, the value of CSR,

857
00:36:54,950 --> 00:36:59,790
and looping the core,
and on the wave diagram,

858
00:36:59,790 --> 00:37:02,470
it's very feasible once that happens,

859
00:37:02,470 --> 00:37:06,970
and the step two actually
leading the value change

860
00:37:06,970 --> 00:37:10,630
and then equal triggers
an exception handler

861
00:37:10,630 --> 00:37:13,640
with the corrupted MTVEC register value.

862
00:37:13,640 --> 00:37:18,200
And that's led exactly pointing to IMEM,

863
00:37:20,710 --> 00:37:23,720
and executing our NOPs SLED

864
00:37:23,720 --> 00:37:25,823
and lead the shellcode execution.

865
00:37:28,040 --> 00:37:33,040
But let's talk also about
how we report this bug,

866
00:37:33,960 --> 00:37:38,870
and how we fix this bug
with an industry effort

867
00:37:38,870 --> 00:37:41,780
from the RISC-V foundation community.

868
00:37:41,780 --> 00:37:45,150
Actually, it was very tough scenario

869
00:37:45,150 --> 00:37:47,870
because think about you find the bug,

870
00:37:47,870 --> 00:37:51,770
not an actual implementation,
not in a single board,

871
00:37:51,770 --> 00:37:55,610
you find the buganizer
that's in most of the boards,

872
00:37:55,610 --> 00:37:58,150
which is currently
available in the markets,

873
00:37:58,150 --> 00:38:03,150
it's affected by this issue,
and how to fix it, right?

874
00:38:05,550 --> 00:38:09,790
So, first of all like of
course when we just realize

875
00:38:09,790 --> 00:38:13,780
this is big issue, we contacted
the RISC-V Foundation,

876
00:38:13,780 --> 00:38:16,080
and until the time it was no official

877
00:38:16,080 --> 00:38:20,223
security response group,
and it's been actually,

878
00:38:21,520 --> 00:38:25,310
we've worked with RISC-V
foundation over our PSIRT.

879
00:38:25,310 --> 00:38:29,280
And also now it is official
security response group exists,

880
00:38:29,280 --> 00:38:30,300
which is good, right?

881
00:38:30,300 --> 00:38:33,680
And I think they can address security bugs

882
00:38:33,680 --> 00:38:35,310
and issues with ISA,

883
00:38:35,310 --> 00:38:38,930
and not only is the ISA tied
to the RISC-V foundation

884
00:38:38,930 --> 00:38:41,330
as an industry call much more efficient.

885
00:38:41,330 --> 00:38:45,000
Also we contact SiFive
and working with them

886
00:38:45,000 --> 00:38:48,020
on analyzing this issue,

887
00:38:48,020 --> 00:38:51,780
and actually we allocated
the CV number 2021-11-04.

888
00:38:54,138 --> 00:38:59,138
And Nvidia PSIRT and Nvidia
RISC-V hardware team,

889
00:38:59,180 --> 00:39:02,450
confirmed this issue and
fixed this issue internally,

890
00:39:02,450 --> 00:39:04,510
and sync with all involved parties

891
00:39:04,510 --> 00:39:06,280
for responsible disclosure.

892
00:39:06,280 --> 00:39:10,970
It's been kind of tough and
timeline been also very limited

893
00:39:10,970 --> 00:39:15,210
because we want to deliver
this talk on DEFCON Conference,

894
00:39:15,210 --> 00:39:18,453
but all the parties need to
be secure first of all, right.

895
00:39:18,453 --> 00:39:23,453
And how actually we can propose the fix

896
00:39:24,540 --> 00:39:27,110
for this problems right, so first of all,

897
00:39:27,110 --> 00:39:30,023
what we need to do is initialize at MTVEC.

898
00:39:31,280 --> 00:39:35,220
All tested chips have MTVEC programmable

899
00:39:35,220 --> 00:39:40,070
and the most common mode
vulnerable to describe a problem.

900
00:39:40,070 --> 00:39:44,590
And actually we also realize
some of the newer chip

901
00:39:44,590 --> 00:39:48,540
being released recently this spring

902
00:39:48,540 --> 00:39:51,120
also actually affected by this problem

903
00:39:51,120 --> 00:39:54,507
because of course nobody
thinks before you bought MTVEC

904
00:39:54,507 --> 00:39:56,490
and define that behavior.

905
00:39:56,490 --> 00:40:01,000
But of course without a looped core

906
00:40:01,000 --> 00:40:02,760
on the exception handler,

907
00:40:02,760 --> 00:40:04,920
this attack will be not exploitable.

908
00:40:04,920 --> 00:40:09,920
And if MTVEC value will be not described,

909
00:40:09,930 --> 00:40:12,680
but then still on define
that behavior exists,

910
00:40:12,680 --> 00:40:15,850
but let's say it will be at
some double or triple fault,

911
00:40:15,850 --> 00:40:19,170
like exception or like just in the help,

912
00:40:19,170 --> 00:40:22,080
this will be prevent the code execution,

913
00:40:22,080 --> 00:40:24,130
which we described on the previous slide.

914
00:40:28,240 --> 00:40:30,780
So how we can fix this issue

915
00:40:30,780 --> 00:40:34,050
and what kind of mitigations it can be.

916
00:40:34,050 --> 00:40:37,860
First of all, it can be a combination

917
00:40:37,860 --> 00:40:42,380
of hardware mitigations
and software mitigations.

918
00:40:42,380 --> 00:40:47,380
But let's talk about
DCLS, and DCLS, and TCLs,

919
00:40:48,630 --> 00:40:50,500
it's actually very interesting techniques

920
00:40:50,500 --> 00:40:55,500
when we taken the shadow
core DCLS with a double core

921
00:40:56,590 --> 00:41:01,060
or TCLS with a triple
core in consideration

922
00:41:01,060 --> 00:41:05,390
of additional execution,

923
00:41:05,390 --> 00:41:07,630
following the instruction flow, right?

924
00:41:07,630 --> 00:41:12,630
So the shadow core adjust,
having the same flow,

925
00:41:13,280 --> 00:41:17,460
the same instruction and in
sync with the original core

926
00:41:17,460 --> 00:41:20,010
and if instruction flow is not equal,

927
00:41:20,010 --> 00:41:22,420
it will be panic or
halted or whatever happens

928
00:41:22,420 --> 00:41:24,620
as defined at the silicon, right?

929
00:41:24,620 --> 00:41:27,250
Same thing happening with TCLS.

930
00:41:29,050 --> 00:41:32,870
And TCLS just introduced two cores

931
00:41:32,870 --> 00:41:37,870
and it will be a more difficult to glitch.

932
00:41:37,900 --> 00:41:40,770
And in case of the two cores,

933
00:41:40,770 --> 00:41:43,870
the possibility of the glitch
still possible potentially,

934
00:41:43,870 --> 00:41:46,800
but of course it's raising
and increasing the bar.

935
00:41:46,800 --> 00:41:51,800
TCLS created much harder
the attack scenario.

936
00:41:53,050 --> 00:41:56,720
And I would say, realistically,
it need first of all

937
00:41:56,720 --> 00:42:01,130
to be involved in multiple
glitch attacks simultaneously.

938
00:42:01,130 --> 00:42:04,340
So you need to glitch
simultaneously multiple cores

939
00:42:04,340 --> 00:42:06,650
and with the corruption
of the instruction,

940
00:42:06,650 --> 00:42:09,300
let's say you need to corrupt the value,

941
00:42:09,300 --> 00:42:11,370
and if this values are different,

942
00:42:11,370 --> 00:42:14,880
so it can be, cause some
additional exceptions,

943
00:42:14,880 --> 00:42:16,930
which you can't predict, right?

944
00:42:16,930 --> 00:42:19,670
So I would say it's raising the bar,

945
00:42:19,670 --> 00:42:21,330
of course the attack still possible,

946
00:42:21,330 --> 00:42:23,860
but much more complicated.

947
00:42:23,860 --> 00:42:26,390
But let's talk about the
software mitigations.

948
00:42:26,390 --> 00:42:29,430
And Jeremy Boone from NCC Group

949
00:42:29,430 --> 00:42:32,240
recently created a blog series

950
00:42:32,240 --> 00:42:34,960
about the software mitigations,
and thank you for that.

951
00:42:34,960 --> 00:42:38,950
It was a great series of explanation

952
00:42:38,950 --> 00:42:42,070
from the industry standards
about software mitigations.

953
00:42:42,070 --> 00:42:45,117
But of course, all this
mitigation is known for a while,

954
00:42:45,117 --> 00:42:48,620
and also it's broadly used.

955
00:42:48,620 --> 00:42:53,240
Software mitigations doesn't
prevent such of the attacks,

956
00:42:53,240 --> 00:42:54,550
but it's raising the bar,

957
00:42:54,550 --> 00:42:58,640
in many cases it make much more difficult

958
00:42:58,640 --> 00:43:03,590
as the attack scenario or like
for unexperienced attacker,

959
00:43:03,590 --> 00:43:05,563
it make it even impossible.

960
00:43:06,580 --> 00:43:10,230
But all this, hamming
distance, clear memory,

961
00:43:10,230 --> 00:43:12,850
random delays and redundant checks,

962
00:43:12,850 --> 00:43:15,930
it's actually can be introduced
on the compiler level

963
00:43:15,930 --> 00:43:19,610
and created automatically
because first of all,

964
00:43:19,610 --> 00:43:24,090
the developer can forget
to install this mitigations

965
00:43:24,090 --> 00:43:27,350
or like copy paste something incorrectly,

966
00:43:27,350 --> 00:43:32,150
or forget to change before
coping this sort of mitigations

967
00:43:32,150 --> 00:43:37,150
in different places, also some
of them just can be utilized

968
00:43:37,830 --> 00:43:40,260
by compiler during the compilation flows,

969
00:43:40,260 --> 00:43:42,230
because redundant checks as example

970
00:43:42,230 --> 00:43:46,480
without special definitions
or compiler extensions,

971
00:43:46,480 --> 00:43:50,630
it will be optimized during
the compilation phases,

972
00:43:50,630 --> 00:43:53,543
and you clearly can see
this in this assembly flow.

973
00:43:56,780 --> 00:43:59,703
Also, we proposed some decisions,

974
00:44:01,110 --> 00:44:02,610
we propose some design decisions

975
00:44:02,610 --> 00:44:04,840
to address for MTVEC weaknesses.

976
00:44:04,840 --> 00:44:09,840
And basically, as we said
before, start CPU need to signal

977
00:44:12,080 --> 00:44:13,800
when the signal will be arrives,

978
00:44:13,800 --> 00:44:17,340
pre-initialize MTVEC to point
to the halt instruction.

979
00:44:17,340 --> 00:44:19,380
Basically, if something happens,

980
00:44:19,380 --> 00:44:24,380
it will initiate the help
and change the ISA needed

981
00:44:25,770 --> 00:44:28,310
because we need to warn
about the potential

982
00:44:28,310 --> 00:44:31,430
undefined behavior if the MTVEC will be,

983
00:44:31,430 --> 00:44:33,100
not initialized, right?

984
00:44:33,100 --> 00:44:36,500
And we need to basically
introduce this kind of comment

985
00:44:36,500 --> 00:44:38,493
into the ISA documentation.

986
00:44:39,490 --> 00:44:44,423
Also introduction of double,
triple fault like exception

987
00:44:44,423 --> 00:44:48,020
will be complimentary
to the halt of the core,

988
00:44:48,020 --> 00:44:50,500
and actually instead of infinite loop,

989
00:44:50,500 --> 00:44:55,360
it will be make this attack
vector unexploitable.

990
00:44:55,360 --> 00:44:57,610
It will be cause the denial of service,

991
00:44:57,610 --> 00:45:00,910
but the not code execution
we described previously.

992
00:45:02,480 --> 00:45:07,430
And of course, like it's
much more can be explained

993
00:45:07,430 --> 00:45:09,850
in terms of RISC-V hardening

994
00:45:09,850 --> 00:45:14,240
and I think the mitigations
against software attacks

995
00:45:14,240 --> 00:45:16,700
can be explained in different ways,

996
00:45:16,700 --> 00:45:21,170
but also it is brilliant
research been done

997
00:45:21,170 --> 00:45:24,260
of introducing pointer masking.

998
00:45:24,260 --> 00:45:27,813
And Adam will be take
over from that place.

999
00:45:30,770 --> 00:45:31,890
- Thanks Alex.

1000
00:45:31,890 --> 00:45:35,010
Let's briefly talk about the
pointer masking extension

1001
00:45:35,010 --> 00:45:37,700
for RISC-V, which can
significantly increase

1002
00:45:37,700 --> 00:45:40,520
the security state of
entire RISC-V ecosystem

1003
00:45:40,520 --> 00:45:42,570
in the software,
especially in the software,

1004
00:45:42,570 --> 00:45:43,850
but also in the hardware.

1005
00:45:43,850 --> 00:45:47,810
It can also reduce the impact
or at least increase the bar

1006
00:45:47,810 --> 00:45:49,920
of exploitability of this MTVEC issue,

1007
00:45:49,920 --> 00:45:52,210
which we're speaking about here today.

1008
00:45:52,210 --> 00:45:55,230
So this extension is
driven as a collaboration

1009
00:45:55,230 --> 00:45:58,500
between Nvidia, Google,
RISC-V TEE Extension

1010
00:45:58,500 --> 00:46:00,170
and the J Extension Task Group.

1011
00:46:00,170 --> 00:46:02,150
So this is a huge collaboration.

1012
00:46:02,150 --> 00:46:04,883
And from the security perspective
it allows to implement

1013
00:46:04,883 --> 00:46:07,940
various technologies,
including Hardware ASAN,

1014
00:46:07,940 --> 00:46:10,960
including Pointer Authentication
Code known as PAC,

1015
00:46:10,960 --> 00:46:14,480
Hardware Memory Sandboxing,
and it also can serve

1016
00:46:14,480 --> 00:46:16,780
as a foundation for other extension,

1017
00:46:16,780 --> 00:46:18,810
including Hardware Memory Tagging,

1018
00:46:18,810 --> 00:46:20,200
which cannot exist in the RISC-V

1019
00:46:20,200 --> 00:46:21,730
without the pointer masking.

1020
00:46:21,730 --> 00:46:26,120
And also it can significantly
improve the security

1021
00:46:26,120 --> 00:46:29,520
of the other extension,
which is protected.

1022
00:46:29,520 --> 00:46:32,820
It can protect the Control
Flow Integrity Attributes,

1023
00:46:32,820 --> 00:46:35,320
and Shadow Stack, which is an extension

1024
00:46:35,320 --> 00:46:39,010
driven by the TEE Task Group
and the work is in progress.

1025
00:46:39,010 --> 00:46:42,220
However, this kind of
technologies are mostly known,

1026
00:46:42,220 --> 00:46:45,130
excluding the one, which is
Hardware Memory Sandboxing.

1027
00:46:45,130 --> 00:46:46,440
This is kind of innovative

1028
00:46:46,440 --> 00:46:49,790
and we haven't seen in
other architectures.

1029
00:46:49,790 --> 00:46:52,280
So what is Hardware Memory Sandboxing?

1030
00:46:52,280 --> 00:46:54,500
Essentially it allows you to lock down

1031
00:46:54,500 --> 00:46:56,570
the specific execution context

1032
00:46:56,570 --> 00:46:58,350
on the sub-region of the memory.

1033
00:46:58,350 --> 00:47:02,540
So even you can make an extra
boundary between the threats,

1034
00:47:02,540 --> 00:47:05,570
even if they run on the
same protest context.

1035
00:47:05,570 --> 00:47:08,170
So the threat execution, executing threat,

1036
00:47:08,170 --> 00:47:10,880
might not even be able physically to see

1037
00:47:10,880 --> 00:47:14,410
or reference any memory outside
of the pre-configured one.

1038
00:47:14,410 --> 00:47:18,230
And this is being confers
in the hardware level.

1039
00:47:18,230 --> 00:47:20,520
But this is more than
that because essentially

1040
00:47:20,520 --> 00:47:21,870
what you can think about that,

1041
00:47:21,870 --> 00:47:24,140
that essentially you can lock down

1042
00:47:24,140 --> 00:47:26,680
what is specific ranges of the memory,

1043
00:47:26,680 --> 00:47:30,270
which are visible for each
specific execution context.

1044
00:47:30,270 --> 00:47:32,580
So even if you have the vulnerability

1045
00:47:32,580 --> 00:47:34,395
in such kind of software

1046
00:47:34,395 --> 00:47:37,730
which runs on specific execution context,

1047
00:47:37,730 --> 00:47:39,840
such vulnerability will not allow you

1048
00:47:39,840 --> 00:47:42,860
to jump over the predefined memory region.

1049
00:47:42,860 --> 00:47:45,782
So even if some kind of secrets

1050
00:47:45,782 --> 00:47:48,360
is leaving in the other pages,

1051
00:47:48,360 --> 00:47:50,840
which normally this specific software

1052
00:47:50,840 --> 00:47:52,940
doesn't need to have access to,

1053
00:47:52,940 --> 00:47:54,710
the vulnerability in the classic way,

1054
00:47:54,710 --> 00:47:56,450
will allows you to steal these secrets

1055
00:47:56,450 --> 00:47:57,490
or override these secrets.

1056
00:47:57,490 --> 00:47:59,760
But because pointer masking can lockdown,

1057
00:47:59,760 --> 00:48:02,306
what do you physically
see, which physical pages

1058
00:48:02,306 --> 00:48:04,290
(indistinct) pages,

1059
00:48:04,290 --> 00:48:08,240
then you can protect that
such kind of vulnerability

1060
00:48:08,240 --> 00:48:11,240
will not be able to allow attacker

1061
00:48:11,240 --> 00:48:14,200
using the current execution
context to reference

1062
00:48:14,200 --> 00:48:16,440
or corrupt any kind of the secrets

1063
00:48:16,440 --> 00:48:18,950
outside of their
predefined memory regions.

1064
00:48:18,950 --> 00:48:22,270
And this is exactly what the
Hardware Memory Sandboxing

1065
00:48:22,270 --> 00:48:25,030
is doing, and it's provided by the pointer

1066
00:48:25,030 --> 00:48:26,710
and masking isolation feature.

1067
00:48:26,710 --> 00:48:28,880
Essentially it's slightly
even more than that

1068
00:48:28,880 --> 00:48:32,530
because you can have multiple
different execution contexts,

1069
00:48:32,530 --> 00:48:35,770
which are locked down
and they never be able

1070
00:48:37,290 --> 00:48:39,600
to reference memory, which does not belong

1071
00:48:39,600 --> 00:48:42,680
or are not configured for them to be seen.

1072
00:48:42,680 --> 00:48:46,860
And this also allows you
to implement features like,

1073
00:48:46,860 --> 00:48:51,650
not only sandboxing, but
also for the low cost devices

1074
00:48:51,650 --> 00:48:54,970
which do not need to do
full context switching,

1075
00:48:54,970 --> 00:48:57,680
because essentially the execution contexts

1076
00:48:57,680 --> 00:49:00,510
cannot corrupt (indistinct)
data between themselves

1077
00:49:00,510 --> 00:49:02,050
because they kind of lockdown.

1078
00:49:02,050 --> 00:49:04,490
You might not do a full context switch,

1079
00:49:04,490 --> 00:49:06,940
which you can save you performance.

1080
00:49:06,940 --> 00:49:08,680
So this is what essentially does it do,

1081
00:49:08,680 --> 00:49:12,530
and from the MTVEC perspective,
how the pointer masking

1082
00:49:12,530 --> 00:49:17,530
can help essentially can
predefine specific boot software,

1083
00:49:17,810 --> 00:49:20,090
can only be able to reference the memory

1084
00:49:20,090 --> 00:49:22,830
for a very small specific
sub-region of the memory.

1085
00:49:22,830 --> 00:49:26,110
So then if you wanna glitch
the MTVEC register, random,

1086
00:49:26,110 --> 00:49:29,140
corruption of the random
bit will most likely

1087
00:49:29,140 --> 00:49:32,340
do not allows you to execute
your custom code or shell code

1088
00:49:32,340 --> 00:49:34,030
because you will not even see that.

1089
00:49:34,030 --> 00:49:36,340
It will be lockdown
specific execution context,

1090
00:49:36,340 --> 00:49:38,120
which would be very hard to predict

1091
00:49:38,120 --> 00:49:41,410
what type of bit you
need to precisely glitch

1092
00:49:41,410 --> 00:49:45,220
to be able to end up in the
predefined memory sandbox.

1093
00:49:45,220 --> 00:49:49,710
So that's what it is, and I
would like to hand over to Alex.

1094
00:49:49,710 --> 00:49:53,460
- Thanks, Adam, and I will
be finish our representation.

1095
00:49:53,460 --> 00:49:57,990
And actually, first of
all I want to address

1096
00:49:57,990 --> 00:50:00,430
some acknowledgement for Nvidia team.

1097
00:50:00,430 --> 00:50:02,780
And it's been a lot of people involved

1098
00:50:02,780 --> 00:50:07,670
from GPU system software and
our RISC-V hardware team.

1099
00:50:07,670 --> 00:50:08,790
I want to thank you all.

1100
00:50:08,790 --> 00:50:13,120
So product security and
especially our PSIRT team,

1101
00:50:13,120 --> 00:50:17,240
where they being hardly
working on this issue,

1102
00:50:17,240 --> 00:50:19,730
because in the beginning
it's been not obvious

1103
00:50:19,730 --> 00:50:21,870
where this issue need to be reported.

1104
00:50:21,870 --> 00:50:25,600
And actually which parties we
need to discuss this issue.

1105
00:50:25,600 --> 00:50:29,133
We need also to thank you
SiFive and RISC-V foundation,

1106
00:50:30,030 --> 00:50:34,460
because RISC-V foundation take
our concerns very serious,

1107
00:50:34,460 --> 00:50:38,020
and address this issue to whole ecosystem.

1108
00:50:38,020 --> 00:50:40,920
And also Security Team got created.

1109
00:50:40,920 --> 00:50:45,920
Also SiFive been very present
during the disclosure process

1110
00:50:46,740 --> 00:50:50,780
and help us to understand this issue

1111
00:50:50,780 --> 00:50:52,323
and side effects more deeply.

1112
00:50:54,130 --> 00:50:58,220
In the summary, I want to
actually summarize our research.

1113
00:50:58,220 --> 00:51:01,700
And first part, we also cover
some type safety languages

1114
00:51:01,700 --> 00:51:06,700
and formal verification
with AdaCore and SPARK.

1115
00:51:07,120 --> 00:51:09,520
Of course it is minimize
some attack surfaces,

1116
00:51:09,520 --> 00:51:11,160
with the memory corruption issues,

1117
00:51:11,160 --> 00:51:13,030
but it is not a silver bullet

1118
00:51:13,030 --> 00:51:15,880
and some issues can be still exist,

1119
00:51:15,880 --> 00:51:17,970
and especially it's hard to mitigate

1120
00:51:17,970 --> 00:51:22,970
some undefined behavior
or race condition attacks.

1121
00:51:23,870 --> 00:51:26,910
And of course in the end,

1122
00:51:26,910 --> 00:51:30,130
the code compiles to
the native code, right?

1123
00:51:30,130 --> 00:51:32,750
And to machine code by the compiler

1124
00:51:32,750 --> 00:51:35,870
and formal verification
happens on early stage

1125
00:51:35,870 --> 00:51:37,600
before this transition

1126
00:51:37,600 --> 00:51:39,690
to intermediate representation happens,

1127
00:51:39,690 --> 00:51:42,370
and all the compiler optimization applies.

1128
00:51:42,370 --> 00:51:46,310
It's still some room
for undefined behavior,

1129
00:51:46,310 --> 00:51:49,147
and a lot of other
interesting things can happen.

1130
00:51:50,366 --> 00:51:53,160
There are CPU ISA bugs exist, right?

1131
00:51:53,160 --> 00:51:56,770
So when we found two
interesting side effects

1132
00:51:56,770 --> 00:52:01,770
in RISC-V ISA, and this actually
real world attack scenarios

1133
00:52:03,810 --> 00:52:06,880
can combine with the physical attack

1134
00:52:06,880 --> 00:52:08,590
such of the fault injection,

1135
00:52:08,590 --> 00:52:12,560
and in combination with software
exploitation techniques,

1136
00:52:12,560 --> 00:52:15,700
this can lead to very realistic

1137
00:52:15,700 --> 00:52:18,030
and impactful attack scenarios.

1138
00:52:18,030 --> 00:52:21,330
And of course disclosing
the ISA bugs is tough.

1139
00:52:21,330 --> 00:52:26,330
And we need to basically pay
more attention on our open ISA

1140
00:52:28,010 --> 00:52:31,120
and basically how these
bugs can be addressed.

1141
00:52:31,120 --> 00:52:35,050
And what kind of way
and path to reporting in

1142
00:52:35,050 --> 00:52:37,580
will be exist for the researcher, right?

1143
00:52:37,580 --> 00:52:39,830
Thank you very much for your attention,

1144
00:52:39,830 --> 00:52:43,023
and we'll be happy to
answer those questions.

