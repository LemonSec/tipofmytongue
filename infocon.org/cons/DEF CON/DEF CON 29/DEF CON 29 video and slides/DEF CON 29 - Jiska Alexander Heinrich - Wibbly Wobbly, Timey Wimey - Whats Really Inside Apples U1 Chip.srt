1
00:00:03,140 --> 00:00:05,550
- In this talk Alexander and
me will show you internals

2
00:00:05,550 --> 00:00:08,460
about Apple's new ultra
wide band technology.

3
00:00:08,460 --> 00:00:10,690
Apple built a new chip
officially called U1

4
00:00:10,690 --> 00:00:12,700
and internally called Rose.

5
00:00:12,700 --> 00:00:14,810
The chip has been
introduced for the iPhone 11

6
00:00:14,810 --> 00:00:16,440
for spatial awareness.

7
00:00:16,440 --> 00:00:17,910
And since IS 14,

8
00:00:17,910 --> 00:00:20,420
some functionality of
the U1 chip is exposed

9
00:00:20,420 --> 00:00:22,670
through the the nearby
interaction framework.

10
00:00:23,980 --> 00:00:26,190
Even though it's been there for a while,

11
00:00:26,190 --> 00:00:29,743
nobody really knows what
ultra wide band is or does.

12
00:00:30,860 --> 00:00:32,550
Ultra wide band is only available

13
00:00:32,550 --> 00:00:34,570
on the latest generation of devices.

14
00:00:34,570 --> 00:00:36,540
So on Apple devices,

15
00:00:36,540 --> 00:00:39,800
Tech med-supported iPhones
do not have the U1 chip.

16
00:00:39,800 --> 00:00:42,230
However, the Air-Techs have a U1 chip,

17
00:00:42,230 --> 00:00:44,470
and at $30 they are cheaper

18
00:00:44,470 --> 00:00:46,763
than some ultra wide
band development boards.

19
00:00:48,020 --> 00:00:49,550
Another barrier for hackers is

20
00:00:49,550 --> 00:00:52,400
the typical software-define
radio setups do not allow it

21
00:00:52,400 --> 00:00:54,490
to intercept ultra wide band signals.

22
00:00:54,490 --> 00:00:56,560
So the bandwidth is way too wide

23
00:00:56,560 --> 00:01:00,740
and the frequency is too
high for a typical SDR setup.

24
00:01:00,740 --> 00:01:02,224
So overall,

25
00:01:02,224 --> 00:01:05,103
I guess ultra wide band
seems to be hiccup-proof.

26
00:01:08,520 --> 00:01:09,830
Apple's platform security guide

27
00:01:09,830 --> 00:01:11,830
is usually very, very detailed,

28
00:01:11,830 --> 00:01:14,330
but when it comes to
ultra wide band security,

29
00:01:14,330 --> 00:01:16,580
there is almost no documentation.

30
00:01:16,580 --> 00:01:18,340
It only states that address

31
00:01:18,340 --> 00:01:20,560
and frame sequences are randomized,

32
00:01:20,560 --> 00:01:23,450
which is fundamental to
privacy in wireless systems.

33
00:01:23,450 --> 00:01:26,750
However, this does not tell
anything about security features

34
00:01:26,750 --> 00:01:29,833
of ultra wide band on a chip
or operating system level.

35
00:01:32,560 --> 00:01:35,820
Ultra wide band is so secure
they even put it into vehicles.

36
00:01:35,820 --> 00:01:37,310
And one application is to use it

37
00:01:37,310 --> 00:01:39,130
as a second factor for keys.

38
00:01:39,130 --> 00:01:41,490
Signals are limited by speed of light,

39
00:01:41,490 --> 00:01:43,320
meaning that they travel a constant time

40
00:01:43,320 --> 00:01:46,090
and being sent over the
air or through a cable.

41
00:01:46,090 --> 00:01:48,950
This means that an attacker
cannot simply replay

42
00:01:48,950 --> 00:01:52,133
or relay a signal from a
key to shorten the distance.

43
00:01:53,060 --> 00:01:56,330
Such an attack would
introduce a measurable delay.

44
00:01:56,330 --> 00:01:59,140
Using this property as a second factor

45
00:01:59,140 --> 00:02:01,063
is also called distance bonding.

46
00:02:03,980 --> 00:02:06,820
In practice, the direct line of sight path

47
00:02:06,820 --> 00:02:08,460
might not be as strong

48
00:02:08,460 --> 00:02:10,520
because objects are in between.

49
00:02:10,520 --> 00:02:13,090
So in such a case, a
non-line of sight path

50
00:02:13,090 --> 00:02:17,430
from a reflection like a wall
or the ground can be stronger.

51
00:02:17,430 --> 00:02:18,263
However,

52
00:02:18,263 --> 00:02:21,223
you still want to use your
key and open your vehicle.

53
00:02:24,020 --> 00:02:27,970
So Apple does not provide any
non-line of sight accuracy

54
00:02:27,970 --> 00:02:29,530
for their ultra wide band chip.

55
00:02:29,530 --> 00:02:32,920
And XP advertises their chip
with plus-minus 10 centimeters

56
00:02:32,920 --> 00:02:34,910
non-line of sight accuracy.

57
00:02:34,910 --> 00:02:36,740
And when correlating paths,

58
00:02:36,740 --> 00:02:39,030
the signal strength of the shortest path

59
00:02:39,030 --> 00:02:41,270
might be lower than the indirect reflected

60
00:02:41,270 --> 00:02:42,680
non-line of sight path.

61
00:02:42,680 --> 00:02:45,180
The shortest path is earlier but weaker.

62
00:02:45,180 --> 00:02:46,830
And to compensate for this,

63
00:02:46,830 --> 00:02:49,110
there needs to be a back search window

64
00:02:49,110 --> 00:02:52,880
in that the ultra wide
band chip looks for peaks.

65
00:02:52,880 --> 00:02:55,130
Any peak about the noise floor

66
00:02:55,130 --> 00:02:57,540
will be accepted as freeze path.

67
00:02:57,540 --> 00:02:59,250
An attacker can trick this algorithm

68
00:02:59,250 --> 00:03:01,020
by injecting short peaks

69
00:03:01,020 --> 00:03:04,140
that slightly distort a signal in way

70
00:03:04,140 --> 00:03:06,820
that makes four sort of paths appear

71
00:03:06,820 --> 00:03:08,660
within the back search time window.

72
00:03:08,660 --> 00:03:09,500
And as of now,

73
00:03:09,500 --> 00:03:11,560
this attack has only been simulated

74
00:03:11,560 --> 00:03:13,770
because there is no affordable setup

75
00:03:13,770 --> 00:03:16,200
that would allow such
an attack in practice.

76
00:03:16,200 --> 00:03:19,180
But considering that ultra
wide band's secure ranging

77
00:03:19,180 --> 00:03:22,160
is now being built into the
newest generation of devices,

78
00:03:22,160 --> 00:03:23,603
this is still concerning.

79
00:03:24,850 --> 00:03:27,200
And we have this I'm
handing over to Alexander

80
00:03:27,200 --> 00:03:29,580
who is now going to show you a bit more

81
00:03:29,580 --> 00:03:34,050
about how ultra wide
band is being used on iOS

82
00:03:34,050 --> 00:03:35,220
from a user perspective

83
00:03:35,220 --> 00:03:37,120
but also from a framework perspective.

84
00:03:41,730 --> 00:03:43,540
- Thank you, Jiska, for the introduction.

85
00:03:43,540 --> 00:03:47,420
I will now continue to present
the ultra wide band features

86
00:03:47,420 --> 00:03:48,930
that are currently present in iOS

87
00:03:48,930 --> 00:03:51,000
and continue to dive a bit deeper

88
00:03:51,000 --> 00:03:53,803
into the internals of the
implementation of iOS.

89
00:03:56,430 --> 00:03:58,090
The first feature that was made available

90
00:03:58,090 --> 00:04:01,390
using ultra wide band is
an extension to AirDrop.

91
00:04:01,390 --> 00:04:04,080
This extension mainly
changed the user interface

92
00:04:04,080 --> 00:04:07,210
in a way that the device at
which the user is pointing

93
00:04:07,210 --> 00:04:09,620
is shown in a circle in the middle.

94
00:04:09,620 --> 00:04:11,850
This helps users to identify
the person they want

95
00:04:11,850 --> 00:04:12,750
to send a file to

96
00:04:12,750 --> 00:04:15,070
and could be another hint
against malicious actors

97
00:04:15,070 --> 00:04:16,403
trying to steal files.

98
00:04:18,180 --> 00:04:19,850
With iOS 14,

99
00:04:19,850 --> 00:04:22,660
Apple has opened up their
ultra wide band interface

100
00:04:22,660 --> 00:04:24,250
to app developers.

101
00:04:24,250 --> 00:04:25,950
Developers are now able to use

102
00:04:25,950 --> 00:04:29,640
the nearby interaction framework
to measure the distance

103
00:04:29,640 --> 00:04:31,480
and angle between two iPhones

104
00:04:31,480 --> 00:04:32,893
and to play games with this.

105
00:04:33,900 --> 00:04:35,580
Usage is quite limited

106
00:04:35,580 --> 00:04:40,220
because we cannot access
more details than this.

107
00:04:40,220 --> 00:04:43,110
And actually, it requires
a quite complicated setup

108
00:04:43,110 --> 00:04:44,610
in which we will detail later.

109
00:04:47,470 --> 00:04:49,547
Also, with the introduction of the AirTag

110
00:04:49,547 --> 00:04:53,040
the Find My app gained
support for ultra wide band.

111
00:04:53,040 --> 00:04:56,180
This is used to discover lost devices

112
00:04:56,180 --> 00:04:58,370
and it shows you the distance

113
00:04:58,370 --> 00:05:02,630
and the direction in which
your device is placed.

114
00:05:02,630 --> 00:05:06,350
So this is an option to
find devices in your place

115
00:05:06,350 --> 00:05:08,780
but it's not feasible for longer distances

116
00:05:08,780 --> 00:05:13,163
as the system has a maximum
distance of around 10 meters.

117
00:05:15,840 --> 00:05:17,280
With iOS 15,

118
00:05:17,280 --> 00:05:20,480
Apple is opening up ultra
wide band even more.

119
00:05:20,480 --> 00:05:22,910
Now ultra wide band can
be added to anything

120
00:05:22,910 --> 00:05:25,600
if the manufacturer is certified by Apple,

121
00:05:25,600 --> 00:05:29,560
and now you can integrate
ultra wide band hardware

122
00:05:29,560 --> 00:05:31,070
into your house.

123
00:05:31,070 --> 00:05:31,903
For example,

124
00:05:31,903 --> 00:05:36,430
to unlock it or to have
certain smart home features.

125
00:05:36,430 --> 00:05:38,430
You can unlock your car
with ultra wide band

126
00:05:38,430 --> 00:05:41,120
using the digital car key,

127
00:05:41,120 --> 00:05:45,810
and also ultra wide band can now be used

128
00:05:45,810 --> 00:05:47,413
for the key to your Tardis.

129
00:05:50,750 --> 00:05:52,460
And now I will dive deeper into

130
00:05:52,460 --> 00:05:55,760
the AirDrop and newer interaction
parts of ultra wide band.

131
00:05:55,760 --> 00:05:56,593
In this part,

132
00:05:56,593 --> 00:05:59,470
I will the two protocols in use.

133
00:05:59,470 --> 00:06:02,713
And now we start with AirDrop.

134
00:06:04,260 --> 00:06:07,220
So the first ultra wide band use case

135
00:06:07,220 --> 00:06:09,600
that we're going to look at is AirDrop.

136
00:06:09,600 --> 00:06:10,970
When users open AirDrop,

137
00:06:10,970 --> 00:06:13,260
a lot of things start
happening in the background.

138
00:06:13,260 --> 00:06:16,170
The devices will start sending
out ultra wide band beacons

139
00:06:17,050 --> 00:06:19,050
and it would also start sharing

140
00:06:19,050 --> 00:06:20,670
Bluetooth low-energy advertisements

141
00:06:20,670 --> 00:06:25,393
to inform user uses nearby
about the just-started AirDrop.

142
00:06:28,340 --> 00:06:30,670
The first Bluetooth
low-energy advertisement

143
00:06:30,670 --> 00:06:32,370
is the main AirDrop advertisement.

144
00:06:33,210 --> 00:06:35,900
This part is largely known
by previous research,

145
00:06:35,900 --> 00:06:39,020
and when an iPhone tries to
send something over at drop,

146
00:06:39,020 --> 00:06:41,890
it will send these BLE advertisements.

147
00:06:41,890 --> 00:06:44,640
Those advertisements use a
non-resolvable MAC address,

148
00:06:44,640 --> 00:06:47,890
so it cannot be identified even by devices

149
00:06:47,890 --> 00:06:50,520
that have been paired to this iPhone.

150
00:06:50,520 --> 00:06:54,530
The first part here identifies
this as an AirDrop message.

151
00:06:54,530 --> 00:06:58,030
Then it just states the length
of the whole advertisement

152
00:06:58,030 --> 00:07:00,403
and then we have zero padding here.

153
00:07:01,800 --> 00:07:04,050
Then we get a version number

154
00:07:04,050 --> 00:07:07,220
and this is followed up
by four truncated hashes

155
00:07:07,220 --> 00:07:09,580
from email addresses like the Apple ID

156
00:07:09,580 --> 00:07:11,550
and from phone numbers
that are also linked

157
00:07:11,550 --> 00:07:13,450
to this Apple account.

158
00:07:13,450 --> 00:07:15,250
Now all devices in the surrounding know

159
00:07:15,250 --> 00:07:17,180
if their potential contact is trying

160
00:07:17,180 --> 00:07:18,570
to send something over AirDrop

161
00:07:18,570 --> 00:07:20,740
as they can compare the hashes here.

162
00:07:20,740 --> 00:07:23,440
They will start with the
normal AirDrop protocol

163
00:07:23,440 --> 00:07:24,520
in the background.

164
00:07:24,520 --> 00:07:26,560
And now this ultra wide
band part of AirDrop

165
00:07:26,560 --> 00:07:29,260
is clearly separated from
the normal AirDrop protocol.

166
00:07:31,670 --> 00:07:34,270
So for the ultra wide band part,

167
00:07:34,270 --> 00:07:36,030
it's also sending a different kind

168
00:07:36,030 --> 00:07:38,850
of second BLE advertisement.

169
00:07:38,850 --> 00:07:42,370
And this one uses, actually,
a resolvable MAC address,

170
00:07:42,370 --> 00:07:45,003
and it's often this nearby action type.

171
00:07:46,070 --> 00:07:48,640
This new action type is
used for multiple features.

172
00:07:48,640 --> 00:07:51,453
For example, the Wi-Fi
password sharing and Air Play.

173
00:07:52,810 --> 00:07:55,363
Then we have nearby action flags.

174
00:07:56,940 --> 00:07:58,950
And then we have a special type.

175
00:07:58,950 --> 00:08:02,600
In this case, it's the action
type called point to share.

176
00:08:02,600 --> 00:08:04,720
This is directly linked to ultra wide band

177
00:08:04,720 --> 00:08:08,520
and it's sent every time the
device has started AirDrop.

178
00:08:08,520 --> 00:08:12,180
This informs nearby devices
that this AirDrop device

179
00:08:12,180 --> 00:08:14,400
has started ultra wide band beaconing

180
00:08:14,400 --> 00:08:19,400
and is awaiting responses by
potential other AirDrop users.

181
00:08:20,190 --> 00:08:22,160
Also, only by action messages

182
00:08:22,160 --> 00:08:24,273
contain an authentication tag end yet.

183
00:08:27,440 --> 00:08:29,270
So on the receiver side,

184
00:08:29,270 --> 00:08:30,980
to receive BLE advertisements,

185
00:08:30,980 --> 00:08:32,253
parse to the sharing key.

186
00:08:34,900 --> 00:08:37,990
Then the sharingd is now able to identify

187
00:08:37,990 --> 00:08:40,040
that there's a nearby device

188
00:08:40,040 --> 00:08:42,053
and what this device wants to do.

189
00:08:43,500 --> 00:08:46,010
But also, the sharingd needs to validate

190
00:08:46,010 --> 00:08:48,060
this authentication tag.

191
00:08:48,060 --> 00:08:52,470
This is possible because all
previously connected devices

192
00:08:52,470 --> 00:08:55,680
share an identity-resolving key.

193
00:08:55,680 --> 00:08:59,360
So all iOS devices are sharing these keys

194
00:08:59,360 --> 00:09:01,370
and they are stored locally on device.

195
00:09:01,370 --> 00:09:03,250
So for every received message,

196
00:09:03,250 --> 00:09:04,750
their performance up hash algorithm

197
00:09:04,750 --> 00:09:06,613
using the MAC address

198
00:09:06,613 --> 00:09:08,200
and one of those identity-resolving keys.

199
00:09:08,200 --> 00:09:11,670
And then they check if the
authentication tag matches.

200
00:09:11,670 --> 00:09:13,340
And if this is the case,

201
00:09:13,340 --> 00:09:16,370
this device has been seen before.

202
00:09:16,370 --> 00:09:19,893
So they know if this is
actually a friend device.

203
00:09:20,840 --> 00:09:22,890
According to the brutal specification

204
00:09:22,890 --> 00:09:24,690
in identity-resolving keys, or IRKs,

205
00:09:25,680 --> 00:09:27,930
are used to resolve the
actual Bluetooth address

206
00:09:27,930 --> 00:09:29,610
from the randomized address.

207
00:09:29,610 --> 00:09:32,410
Apple repurposes them here

208
00:09:32,410 --> 00:09:34,653
to generate those authentication tags.

209
00:09:40,270 --> 00:09:41,990
Now, the iPhone can be rather sure

210
00:09:41,990 --> 00:09:44,360
that the sending device
is a friend's device.

211
00:09:44,360 --> 00:09:46,440
Therefore, it starts
forwarding this information

212
00:09:46,440 --> 00:09:49,450
to the nearbyd through the rapportd.

213
00:09:49,450 --> 00:09:52,640
Here, iOS uses a trick to find friendly

214
00:09:52,640 --> 00:09:54,570
devices in ultra wide band.

215
00:09:54,570 --> 00:09:56,810
They use the same randomized MAC address

216
00:09:56,810 --> 00:09:59,280
for ultra wide band as for Bluetooth.

217
00:09:59,280 --> 00:10:01,460
So the nearbyd initializes the U1 chip

218
00:10:01,460 --> 00:10:04,933
and watches the ultra
wide band MAC addresses.

219
00:10:08,050 --> 00:10:11,790
Now the device can respond to
the ultra wide band beacons

220
00:10:11,790 --> 00:10:14,270
initiated by the AirDrop device

221
00:10:14,270 --> 00:10:16,310
to send out its information
about the distance

222
00:10:16,310 --> 00:10:18,210
and angle of nearby iPhones.

223
00:10:20,370 --> 00:10:23,730
This information is used to show the user,

224
00:10:23,730 --> 00:10:26,110
the person they are
pointing the device at.

225
00:10:26,110 --> 00:10:29,130
So this is how AirDrop's implementation of

226
00:10:29,130 --> 00:10:33,130
ultra wide band ranging
angle of arrival works.

227
00:10:33,130 --> 00:10:34,730
Now we come to the second part.

228
00:10:34,730 --> 00:10:36,303
Nearby interaction framework.

229
00:10:37,910 --> 00:10:39,930
As shown is the nearby
interaction framework.

230
00:10:39,930 --> 00:10:42,980
It is possible to range
with nearby iPhones

231
00:10:42,980 --> 00:10:45,793
and measure the distance and
angle between your devices.

232
00:10:46,740 --> 00:10:48,190
Furthermore, with iOS 15,

233
00:10:48,190 --> 00:10:49,860
Apple allows ranging re-certified

234
00:10:49,860 --> 00:10:52,540
third-party ultra wide band devices.

235
00:10:52,540 --> 00:10:55,430
To perform the ranging
with nearby iPhones using

236
00:10:55,430 --> 00:10:57,150
the nearby interaction framework,

237
00:10:57,150 --> 00:11:01,220
both devices need to
exchange NI Discovery Tokens.

238
00:11:01,220 --> 00:11:03,120
These tokens have to be exchanged

239
00:11:03,120 --> 00:11:05,010
using an out-of-band channel.

240
00:11:05,010 --> 00:11:06,440
This is left to the developers

241
00:11:06,440 --> 00:11:08,190
to implement it in a secure manner.

242
00:11:09,520 --> 00:11:12,240
The tokens are generated at random

243
00:11:12,240 --> 00:11:15,140
and the device which has a greater token

244
00:11:15,140 --> 00:11:16,330
will act as an initiator

245
00:11:16,330 --> 00:11:18,173
and the other device as a responder.

246
00:11:19,650 --> 00:11:21,680
And after the tokens have been exchanged,

247
00:11:21,680 --> 00:11:24,763
the user has to be confirm
the usage of ultra wide band.

248
00:11:27,800 --> 00:11:29,420
Similarly to AirDrop,

249
00:11:29,420 --> 00:11:33,360
both devices will start
sending out BLE advertisements.

250
00:11:33,360 --> 00:11:35,090
Those advertisements are different

251
00:11:35,090 --> 00:11:37,150
to the ones sent in AirDrop.

252
00:11:37,150 --> 00:11:38,400
So the advertisements

253
00:11:38,400 --> 00:11:41,030
are solely ultra wide band advertisements

254
00:11:41,030 --> 00:11:42,674
and they contain

255
00:11:42,674 --> 00:11:44,460
as the other ones before,

256
00:11:44,460 --> 00:11:46,300
links and flags,

257
00:11:46,300 --> 00:11:48,230
but also an authentication tag

258
00:11:49,380 --> 00:11:50,863
and ultra wide band conflict.

259
00:11:52,840 --> 00:11:55,730
So only the initiator sending the config

260
00:11:55,730 --> 00:11:57,380
and the responder device

261
00:11:57,380 --> 00:11:59,523
is only sending its authentication tag.

262
00:12:02,740 --> 00:12:05,540
But how are the devices
now identifying each other?

263
00:12:05,540 --> 00:12:07,410
Both devices have shared token.

264
00:12:07,410 --> 00:12:11,770
This token is used to find
the other devices using BLE.

265
00:12:11,770 --> 00:12:13,730
Those BLE advertisements.

266
00:12:13,730 --> 00:12:15,990
Every token contains a 16 bytes,

267
00:12:15,990 --> 00:12:19,040
randomly-generated
identity-resolving key again,

268
00:12:19,040 --> 00:12:20,240
and similarly to AirDrop,

269
00:12:20,240 --> 00:12:22,950
these keys used to generate
the authentication tag

270
00:12:22,950 --> 00:12:25,320
from the device's user's MAC address.

271
00:12:25,320 --> 00:12:27,570
They reused the same Bluetooth MAC address

272
00:12:27,570 --> 00:12:29,230
for a ultra wide band again

273
00:12:29,230 --> 00:12:32,300
and this allows them to
discover the correct device

274
00:12:32,300 --> 00:12:33,403
when perform ranging.

275
00:12:34,340 --> 00:12:36,450
After the devices have
discovered their peer

276
00:12:36,450 --> 00:12:37,853
over Bluetooth low energy,

277
00:12:39,176 --> 00:12:41,250
they can now perform ranging over

278
00:12:41,250 --> 00:12:44,903
ultra wide band and continue.

279
00:12:45,800 --> 00:12:47,300
To secure this ranging,

280
00:12:47,300 --> 00:12:51,593
they use the so-called
scramble timestamp sequences.

281
00:12:52,690 --> 00:12:54,567
Scramble timestamp sequences

282
00:12:54,567 --> 00:12:56,650
are used to generate multiple timestamps

283
00:12:56,650 --> 00:12:58,400
from receiving a message.

284
00:12:58,400 --> 00:13:01,360
Those timestamps can then be used

285
00:13:01,360 --> 00:13:04,280
to detect potential attacks on a protocol

286
00:13:04,280 --> 00:13:07,310
and additionally, both devices
can authenticate each other

287
00:13:07,310 --> 00:13:09,913
as they share the same STS values.

288
00:13:12,360 --> 00:13:16,120
So to get an extra distance at both sides,

289
00:13:16,120 --> 00:13:19,020
they should perform double-sided ranging.

290
00:13:19,020 --> 00:13:21,810
With this, the initiator
sends the first message

291
00:13:22,830 --> 00:13:25,460
and then the responder replies to it,

292
00:13:25,460 --> 00:13:30,070
the responder replies with
the time when he replied

293
00:13:30,070 --> 00:13:32,340
and the initiator has
the time when this reply

294
00:13:32,340 --> 00:13:33,830
has been received.

295
00:13:33,830 --> 00:13:36,100
And therefore, the initiator can calculate

296
00:13:36,100 --> 00:13:38,530
the time of flight by using the timestamp

297
00:13:38,530 --> 00:13:39,790
when the message has arrived

298
00:13:39,790 --> 00:13:42,760
and the time when the device replied.

299
00:13:42,760 --> 00:13:46,270
And also, they can deduct
the processing times needed.

300
00:13:46,270 --> 00:13:49,030
The same procedure is
handled on the other side

301
00:13:49,030 --> 00:13:52,200
and both devices have distances and angle

302
00:13:52,200 --> 00:13:53,950
of arrival measurements in the end.

303
00:13:58,210 --> 00:13:59,960
So since the beginning of our research

304
00:13:59,960 --> 00:14:02,640
we wanted to receive
actual frames from iOS.

305
00:14:02,640 --> 00:14:03,473
Until now,

306
00:14:03,473 --> 00:14:05,350
the whole system is really closed down.

307
00:14:05,350 --> 00:14:07,410
We do not get any packet logs from iOS

308
00:14:07,410 --> 00:14:10,340
and we only get high-level reports

309
00:14:10,340 --> 00:14:12,020
of their measurements

310
00:14:12,020 --> 00:14:13,560
to nearby demon.

311
00:14:13,560 --> 00:14:17,240
So to receive ultra wide band signals

312
00:14:17,240 --> 00:14:19,520
we first need to know what our hardware

313
00:14:19,520 --> 00:14:20,860
should be capable of.

314
00:14:20,860 --> 00:14:22,670
In the system logs on a jailbroken device

315
00:14:22,670 --> 00:14:24,970
we can unveil a few things.

316
00:14:24,970 --> 00:14:29,440
So from the nearby interaction packet

317
00:14:29,440 --> 00:14:31,740
we see the preambles that I used

318
00:14:31,740 --> 00:14:33,160
and the channels that are supported

319
00:14:33,160 --> 00:14:35,683
and that they are using
a hot pattern mask here.

320
00:14:36,550 --> 00:14:38,420
And also, we can see the usage

321
00:14:38,420 --> 00:14:41,370
of the scrambled timestamp sequences.

322
00:14:41,370 --> 00:14:44,500
Many of those integers presented
here are just an index in

323
00:14:44,500 --> 00:14:47,380
the list of the supported configurations.

324
00:14:47,380 --> 00:14:50,290
So when we check out those configurations,

325
00:14:50,290 --> 00:14:55,290
we see that ultra wide band
here is using 64 megahertz

326
00:14:55,840 --> 00:14:57,730
post-repetition frequency

327
00:14:57,730 --> 00:15:01,130
and iOS ultra wide band
users post and transmit data,

328
00:15:01,130 --> 00:15:03,223
it can operate in different frequences.

329
00:15:04,200 --> 00:15:06,990
And if they use the STS radios,

330
00:15:06,990 --> 00:15:08,670
they need to use 64 megahertz,

331
00:15:08,670 --> 00:15:10,520
according to the standard.

332
00:15:10,520 --> 00:15:14,260
So for 64 megahertz we
have four preamble codes

333
00:15:14,260 --> 00:15:17,940
and the NDCs is our resulting two, three,

334
00:15:17,940 --> 00:15:18,850
so which is here,

335
00:15:18,850 --> 00:15:20,453
the preamble code number 12.

336
00:15:21,310 --> 00:15:22,940
The channels are also using NDCs,

337
00:15:22,940 --> 00:15:27,480
so the one chip supports
channel five and nine,

338
00:15:27,480 --> 00:15:31,460
and here we see that the
start channel is channel nine

339
00:15:31,460 --> 00:15:33,663
and channel five is the
alternative channel.

340
00:15:36,100 --> 00:15:38,533
So next we need the right hardware.

341
00:15:38,533 --> 00:15:43,533
And we know that the
development kits we wanted,

342
00:15:43,733 --> 00:15:45,950
so we were looking for development kits

343
00:15:45,950 --> 00:15:47,893
that support the most recent standard.

344
00:15:48,790 --> 00:15:50,940
And we found the one from Quavo

345
00:15:50,940 --> 00:15:53,823
which also uses the same
channels as the U1 chip.

346
00:15:55,120 --> 00:15:57,850
Then Apple actually announced

347
00:15:57,850 --> 00:16:01,060
that they are supporting
third-party devices,

348
00:16:01,060 --> 00:16:02,130
and they are also saying

349
00:16:02,130 --> 00:16:04,330
that the Quavo device we actually bought

350
00:16:04,330 --> 00:16:06,540
is one of the third-party development kits

351
00:16:06,540 --> 00:16:07,780
they are supporting,

352
00:16:07,780 --> 00:16:10,310
so we bought the right hardware here.

353
00:16:10,310 --> 00:16:11,560
But to receive frames,

354
00:16:11,560 --> 00:16:13,860
we also need to have
the right configuration.

355
00:16:13,860 --> 00:16:16,610
So this needs a set of parameters

356
00:16:16,610 --> 00:16:18,490
and most of them need to match,

357
00:16:18,490 --> 00:16:21,230
otherwise the reception errors would occur

358
00:16:21,230 --> 00:16:23,180
and the frames would not be readable.

359
00:16:23,180 --> 00:16:25,020
Some parameters are clear from the logs,

360
00:16:25,020 --> 00:16:26,820
like the channel and preamble code.

361
00:16:26,820 --> 00:16:28,350
Ours are not known

362
00:16:28,350 --> 00:16:30,370
and they are likely hot-coded and chipped,

363
00:16:30,370 --> 00:16:33,380
so they are basically the
same for all transmissions.

364
00:16:33,380 --> 00:16:36,360
So those which are not known
here are the STS format

365
00:16:36,360 --> 00:16:37,353
and the STS length.

366
00:16:39,150 --> 00:16:40,870
So why is this important?

367
00:16:40,870 --> 00:16:43,570
Let's take a look at the
ultra wide band frame format.

368
00:16:44,410 --> 00:16:47,160
Here we see all frames
start with a preamble.

369
00:16:47,160 --> 00:16:49,620
The preamble contains the
specific preamble code

370
00:16:49,620 --> 00:16:51,260
and it can be repeated,

371
00:16:51,260 --> 00:16:54,510
so this is why the preamble
can have variable lengths.

372
00:16:54,510 --> 00:16:57,390
But with the wrong preamble code

373
00:16:57,390 --> 00:16:59,090
we would never receive any frame.

374
00:16:59,090 --> 00:17:03,080
So the preamble would
just not be detected.

375
00:17:03,080 --> 00:17:04,950
Then the preamble is followed

376
00:17:04,950 --> 00:17:07,853
by the start of frame delimiter or SFD.

377
00:17:09,519 --> 00:17:12,671
This start of frame
delimiter is used to identify

378
00:17:12,671 --> 00:17:14,895
when the preamble ends,

379
00:17:14,895 --> 00:17:19,895
so it's not really important
if you know how long it is.

380
00:17:20,430 --> 00:17:22,903
You just need to check for the SFD.

381
00:17:23,770 --> 00:17:26,492
Then the STS values start.

382
00:17:26,492 --> 00:17:31,492
The STS is used for the secure ranging

383
00:17:37,070 --> 00:17:39,780
and it can also have a
better variable length,

384
00:17:39,780 --> 00:17:44,010
so it's quite difficult
to identify when STS ends

385
00:17:44,010 --> 00:17:45,750
and when the flight header would start

386
00:17:45,750 --> 00:17:49,220
because it's not followed
by something like an SFD.

387
00:17:49,220 --> 00:17:51,370
So we need to know what
the actual length is,

388
00:17:51,370 --> 00:17:53,663
otherwise we would not receive any frames.

389
00:17:55,720 --> 00:17:57,600
Then to make this even more complicated,

390
00:17:57,600 --> 00:17:59,750
there is a second mode for the STS

391
00:17:59,750 --> 00:18:02,410
so it can even be after the flight header,

392
00:18:02,410 --> 00:18:04,793
and also here it can
have variable lengths.

393
00:18:05,900 --> 00:18:07,823
And then there's a third mode

394
00:18:07,823 --> 00:18:11,370
where the STS is after the SFD again

395
00:18:11,370 --> 00:18:13,083
but no data is shared.

396
00:18:15,180 --> 00:18:20,120
So in this demo I want to show you

397
00:18:20,120 --> 00:18:24,620
how we have started
sniffing against an actual

398
00:18:24,620 --> 00:18:26,440
iOS device with a U1 chip,

399
00:18:26,440 --> 00:18:31,090
and for this we start
this demo app from Apple

400
00:18:31,970 --> 00:18:34,370
which is using the nearby
interaction framework.

401
00:18:35,650 --> 00:18:38,350
And then the two devices
start discovering each other

402
00:18:38,350 --> 00:18:41,100
and the user needs to confirm
that ultra wide band use

403
00:18:41,100 --> 00:18:42,150
and then they start ranging.

404
00:18:42,150 --> 00:18:44,830
We can see that they are
ranging a distance here

405
00:18:44,830 --> 00:18:47,310
and we get a lot of logs on the left side

406
00:18:47,310 --> 00:18:49,930
from the iPhone and
basically for every distance

407
00:18:49,930 --> 00:18:51,150
that is measured

408
00:18:51,150 --> 00:18:55,730
we get this one huge log
with the angle of arrival

409
00:18:55,730 --> 00:18:58,070
and the distance that's actually measured.

410
00:18:58,070 --> 00:19:00,850
On the right side we have seen the frames

411
00:19:00,850 --> 00:19:03,222
that are received by (speaking softly),

412
00:19:03,222 --> 00:19:07,580
so our sniffer has been
attached to (speaking softly)

413
00:19:07,580 --> 00:19:10,663
and we were able to
receive some frames here.

414
00:19:12,950 --> 00:19:16,720
But even though it does look
very nice on the first slide,

415
00:19:16,720 --> 00:19:20,570
from a closer look we see that
it has the couple of issues.

416
00:19:20,570 --> 00:19:23,150
So there are malformed packets everywhere

417
00:19:23,150 --> 00:19:25,270
received in (speaking softly),

418
00:19:25,270 --> 00:19:29,129
and even those packets that
look like they're not malformed

419
00:19:29,129 --> 00:19:32,830
have parts of those
packet which are malformed

420
00:19:32,830 --> 00:19:36,850
or incorrect and also the data,

421
00:19:36,850 --> 00:19:37,960
which is part of the packets,

422
00:19:37,960 --> 00:19:39,380
looks very scrambled.

423
00:19:39,380 --> 00:19:40,213
So of course,

424
00:19:40,213 --> 00:19:42,490
the scrambled data could be encrypted

425
00:19:42,490 --> 00:19:44,950
but those issues are most likely caused

426
00:19:44,950 --> 00:19:47,230
by a misaligned STS value.

427
00:19:47,230 --> 00:19:50,420
So we tried every combination
of length and mode

428
00:19:50,420 --> 00:19:54,410
but no one matched the
Apple transmission modes,

429
00:19:54,410 --> 00:19:57,150
so Apple could have employed
some custom STS length

430
00:19:57,150 --> 00:19:59,245
which is not supported by our device,

431
00:19:59,245 --> 00:20:03,410
or they could have
additional data after the STS

432
00:20:03,410 --> 00:20:07,820
which is not part of the official
standardized frame format.

433
00:20:07,820 --> 00:20:10,971
So they could have used a custom
frame format, for example,

434
00:20:10,971 --> 00:20:13,690
and I hope we will get
more insights on this

435
00:20:13,690 --> 00:20:17,450
when the better software
from Quavo gets available

436
00:20:17,450 --> 00:20:19,260
so we can actually

437
00:20:19,260 --> 00:20:23,903
range with iPhones as
supported with iOS 15 beta.

438
00:20:25,850 --> 00:20:28,710
So now we covered the
two modes of interaction,

439
00:20:28,710 --> 00:20:31,010
AirDrop and nearby interaction

440
00:20:31,010 --> 00:20:33,980
and AirDrop's ultra
wide band communication

441
00:20:33,980 --> 00:20:35,610
has been the first that was iOS.

442
00:20:35,610 --> 00:20:39,500
In AirDrop, one device
sends ranging beacons

443
00:20:39,500 --> 00:20:41,760
and multiple devices can respond to it.

444
00:20:41,760 --> 00:20:43,940
Only the initiator or AirDrop sender

445
00:20:43,940 --> 00:20:46,470
is able to get the distance information.

446
00:20:46,470 --> 00:20:47,660
For nearby interaction,

447
00:20:47,660 --> 00:20:50,220
the ranging is performed
in a peer-to-peer manner.

448
00:20:50,220 --> 00:20:52,890
Every device ranges with another.

449
00:20:52,890 --> 00:20:54,930
And both receive the distance information

450
00:20:54,930 --> 00:20:57,130
as they are performing
double-sided ranging.

451
00:20:59,030 --> 00:21:01,450
The devices participating in AirDrop

452
00:21:01,450 --> 00:21:03,030
do not exchange any secrets

453
00:21:03,030 --> 00:21:05,550
and do not secure the actual ranging.

454
00:21:05,550 --> 00:21:07,260
While the nearby interaction and initial

455
00:21:07,260 --> 00:21:09,650
off-band key exchange is necessary.

456
00:21:09,650 --> 00:21:12,170
Even though AirDrop ranging is not secured

457
00:21:12,170 --> 00:21:13,660
by an STS value,

458
00:21:13,660 --> 00:21:16,507
it should not be particularly
dangerous to use AirDrop.

459
00:21:16,507 --> 00:21:18,003
The ultra wide band part,

460
00:21:19,249 --> 00:21:22,510
they're just changes to
order of how nearby people

461
00:21:22,510 --> 00:21:24,333
are shown in the user interface.

462
00:21:25,200 --> 00:21:28,150
And now I will hand over to Jiska again.

463
00:21:28,150 --> 00:21:28,983
Thank you.

464
00:21:32,440 --> 00:21:34,970
- The nearby demon is the
one to start the distance

465
00:21:34,970 --> 00:21:36,330
and angle measurement.

466
00:21:36,330 --> 00:21:38,530
No matter if this has
been initiated by AirDrop

467
00:21:38,530 --> 00:21:41,080
or the nearby interactions framework.

468
00:21:41,080 --> 00:21:41,913
For this,

469
00:21:41,913 --> 00:21:43,300
it's using the RoseControllerLib

470
00:21:43,300 --> 00:21:45,180
which then cause functions in our IO kit

471
00:21:45,180 --> 00:21:47,370
to communicate with the U1 chip.

472
00:21:47,370 --> 00:21:49,840
And the chip initialization
for the measurement

473
00:21:49,840 --> 00:21:51,530
is only done once,

474
00:21:51,530 --> 00:21:53,800
then later on, in return,

475
00:21:53,800 --> 00:21:55,770
measurement tickets
are sent multiple times

476
00:21:55,770 --> 00:21:58,250
containing the measurement data.

477
00:21:58,250 --> 00:22:01,330
The ticket data is not sent
directly to other daemons.

478
00:22:01,330 --> 00:22:03,800
Instead, the nearby daemon combines data

479
00:22:03,800 --> 00:22:06,340
with the so-called Rose
neural engine sensor fusion

480
00:22:06,340 --> 00:22:08,990
and only forwards combined
plausible measurements

481
00:22:08,990 --> 00:22:09,993
to other daemons.

482
00:22:13,610 --> 00:22:15,850
This still looks a bit like magic

483
00:22:15,850 --> 00:22:18,314
and so in the following I
will explain how iOS interacts

484
00:22:18,314 --> 00:22:20,343
with the underlying hardware.

485
00:22:23,568 --> 00:22:26,470
The U1 chip actually
consists of two main chips.

486
00:22:26,470 --> 00:22:27,583
Both of them are iron.

487
00:22:28,500 --> 00:22:31,240
The application process will
implement most functionality

488
00:22:31,240 --> 00:22:32,890
and it's only 32-bit,

489
00:22:32,890 --> 00:22:35,340
and then the signal processor runs on

490
00:22:35,340 --> 00:22:37,850
64-bit iron with ASLI.

491
00:22:37,850 --> 00:22:40,750
It does this more time-critical tasks

492
00:22:40,750 --> 00:22:43,570
as well as the initial packet parsing.

493
00:22:43,570 --> 00:22:44,403
So for example,

494
00:22:44,403 --> 00:22:48,220
the application processor
generates the next STS

495
00:22:48,220 --> 00:22:50,810
and forwards it to the
digital signal processor,

496
00:22:50,810 --> 00:22:52,750
which needs it for the actual distance

497
00:22:52,750 --> 00:22:55,150
measurement and verification.

498
00:22:55,150 --> 00:22:58,320
The U1 chip has three receive antennas.

499
00:22:58,320 --> 00:23:00,820
This is required to
get angular information

500
00:23:00,820 --> 00:23:02,960
and not only distance information.

501
00:23:02,960 --> 00:23:05,540
The three antennas are only
required in the sensing,

502
00:23:05,540 --> 00:23:07,350
AKA receiving, direction,

503
00:23:07,350 --> 00:23:11,210
so angles can still be displayed on iPhone

504
00:23:11,210 --> 00:23:13,940
which communicates with an AirTag U1 chip

505
00:23:13,940 --> 00:23:17,113
even though the AirTag only
has one receive antenna.

506
00:23:18,590 --> 00:23:21,660
All communication is routed
through the always-on processor.

507
00:23:21,660 --> 00:23:23,840
It keeps some basic state of the U1 chip

508
00:23:23,840 --> 00:23:27,363
and only makes up the
iOS kernel when needed.

509
00:23:29,450 --> 00:23:31,090
The iOS kernel, in turn,

510
00:23:31,090 --> 00:23:34,100
can set the ultra wide
band communications route

511
00:23:34,100 --> 00:23:36,120
to either the applications processor

512
00:23:36,120 --> 00:23:37,963
or the always-on processor.

513
00:23:39,650 --> 00:23:41,790
While the U1 chip in the
iPhone's HomePod mini

514
00:23:41,790 --> 00:23:43,360
and watch is very similar,

515
00:23:43,360 --> 00:23:46,110
the U1 chip in the AirTag
is a bit different.

516
00:23:46,110 --> 00:23:48,150
It is the only U1 chip that is not powered

517
00:23:48,150 --> 00:23:49,940
by an iOS rewritive

518
00:23:49,940 --> 00:23:51,730
and an always-on processor.

519
00:23:51,730 --> 00:23:52,563
Because of this,

520
00:23:52,563 --> 00:23:54,190
the AirTag U1 application processor

521
00:23:54,190 --> 00:23:56,260
has a few additional features.

522
00:23:56,260 --> 00:23:58,560
More over, since it
does not have a display,

523
00:23:58,560 --> 00:24:00,110
it cannot show angular information

524
00:24:00,110 --> 00:24:03,603
and so has one receiver antennae only.

525
00:24:04,460 --> 00:24:06,030
More details about the AirTags

526
00:24:06,030 --> 00:24:07,460
and how to glitch the NRF chip

527
00:24:07,460 --> 00:24:10,290
that can then run custom firmware on them

528
00:24:10,290 --> 00:24:13,190
will be part of Thomas' talk,
"Hacking the Apple AirTags."

529
00:24:15,257 --> 00:24:18,230
All the chips I have shown
previously run RTKitOS,

530
00:24:18,230 --> 00:24:21,060
which is a real-time operating system.

531
00:24:21,060 --> 00:24:23,300
Even if you have never heard of it,

532
00:24:23,300 --> 00:24:26,640
it runs on almost every
embedded device by Apple.

533
00:24:26,640 --> 00:24:28,130
There are some exceptions.

534
00:24:28,130 --> 00:24:30,580
So for example, the
NRF chip on the AirTags

535
00:24:30,580 --> 00:24:32,030
does not run RTKitOS.

536
00:24:33,434 --> 00:24:35,080
RTKitOS is very light-weight

537
00:24:35,080 --> 00:24:38,670
and maybe around 100
functions or a bit more.

538
00:24:38,670 --> 00:24:41,610
It is so small that even logging
is implemented differently

539
00:24:41,610 --> 00:24:44,280
in every RTKitOS firmware.

540
00:24:44,280 --> 00:24:47,340
Note that there are RTKitOS debug builds

541
00:24:47,340 --> 00:24:48,840
with additional features.

542
00:24:48,840 --> 00:24:53,380
So for the U1 chip there exists
debug builds in the wild,

543
00:24:53,380 --> 00:24:54,450
and for example,

544
00:24:54,450 --> 00:24:57,160
the iOS 13.3 on the iPhone 11

545
00:24:57,160 --> 00:24:58,990
as well as the initial AirTag firmware

546
00:24:58,990 --> 00:25:00,913
both are U1 chip debug builds.

547
00:25:03,330 --> 00:25:07,612
You can find RTKitOS in almost
every embedded Apple device.

548
00:25:07,612 --> 00:25:09,360
The AirPods two and pro,

549
00:25:09,360 --> 00:25:12,600
the pencil, the Siri and
remote second generation,

550
00:25:12,600 --> 00:25:14,920
the magic keyboard variant for the iPens,

551
00:25:14,920 --> 00:25:17,490
the always-on processor and more.

552
00:25:17,490 --> 00:25:19,540
A few more details about RTKitOS

553
00:25:19,540 --> 00:25:22,720
with a focus on AirPods and
Apple's own Bluetooth chip

554
00:25:22,720 --> 00:25:24,470
are documented in the next teasers.

555
00:25:26,000 --> 00:25:28,630
The iOS kernel has two
drivers for the U1 chip,

556
00:25:28,630 --> 00:25:29,860
the AppleSPURoseDriverUserClient

557
00:25:31,394 --> 00:25:33,644
and the AppleSPUUserClient.

558
00:25:35,080 --> 00:25:36,300
These drivers can be accessed

559
00:25:36,300 --> 00:25:38,000
from user space by IOKit

560
00:25:38,000 --> 00:25:40,040
and IOKit is a driver framework

561
00:25:40,040 --> 00:25:42,780
that takes care of
exposing selected methods

562
00:25:42,780 --> 00:25:45,100
from the kernel to user space.

563
00:25:45,100 --> 00:25:49,120
IOKit also validates the
parameters that are passed

564
00:25:49,120 --> 00:25:50,370
to through these methods.

565
00:25:52,150 --> 00:25:54,420
The always-on processor has equivalence

566
00:25:54,420 --> 00:25:55,840
to these two drivers,

567
00:25:55,840 --> 00:25:56,992
which are called Rose,

568
00:25:56,992 --> 00:25:58,390
and Rose and Rose-Supervisor.

569
00:25:58,390 --> 00:26:00,310
So when the kernel goes to sleep

570
00:26:00,310 --> 00:26:02,500
and the always-on processor takes over,

571
00:26:02,500 --> 00:26:03,743
they are responsible.

572
00:26:04,620 --> 00:26:06,930
This principle is not
unique to ultra wide band,

573
00:26:06,930 --> 00:26:08,280
so you can also find it

574
00:26:08,280 --> 00:26:10,340
for various other chips and features,

575
00:26:10,340 --> 00:26:11,440
such as Siri.

576
00:26:11,440 --> 00:26:12,970
Even Apple's own Bluetooth chip,

577
00:26:12,970 --> 00:26:15,470
which is available in audioOS
for your HomePod mini,

578
00:26:15,470 --> 00:26:17,663
is managed by the always-on processor.

579
00:26:18,830 --> 00:26:19,940
In the opposite direction,

580
00:26:19,940 --> 00:26:22,520
our ticket-based chips
communicate with an RTBuddy

581
00:26:22,520 --> 00:26:23,930
in the kernel.

582
00:26:23,930 --> 00:26:25,900
This is mainly used for logging.

583
00:26:25,900 --> 00:26:30,823
Note that the RTBuddy is not
directly exposed to IOKit.

584
00:26:34,260 --> 00:26:37,800
You can use the IRA command
to check the driver hierarchy.

585
00:26:37,800 --> 00:26:40,720
This is very interesting
since it does not only show

586
00:26:40,720 --> 00:26:42,440
the IOKit user-client

587
00:26:42,440 --> 00:26:44,870
but also the corresponding interface name

588
00:26:44,870 --> 00:26:46,350
in the always-on processor

589
00:26:46,350 --> 00:26:49,260
and the RTBuddy dependency.

590
00:26:49,260 --> 00:26:52,950
This is very useful to see
which chips on an Apple device

591
00:26:52,950 --> 00:26:54,430
actually run RTKitOS.

592
00:26:57,330 --> 00:26:59,690
The nearby daemon can
directly send robot commands

593
00:26:59,690 --> 00:27:01,050
to the U1 chip.

594
00:27:01,050 --> 00:27:04,610
It still needs to use the IOKit framework.

595
00:27:04,610 --> 00:27:05,443
To do this,

596
00:27:05,443 --> 00:27:07,700
it caused the function
IOConnectCallMethod,

597
00:27:07,700 --> 00:27:09,730
and by setting the proper MAC port,

598
00:27:09,730 --> 00:27:13,470
it selects the
AppleSPURoseDriver user-client.

599
00:27:13,470 --> 00:27:15,200
The second argument is five,

600
00:27:15,200 --> 00:27:17,490
which means that the function X Rose takes

601
00:27:17,490 --> 00:27:18,843
is called in the kernel.

602
00:27:20,380 --> 00:27:23,430
Note that there are a lot, a
lot, a lot of other functions

603
00:27:23,430 --> 00:27:24,263
in this framework.

604
00:27:24,263 --> 00:27:25,096
So for example,

605
00:27:25,096 --> 00:27:27,400
the properties are being used during

606
00:27:27,400 --> 00:27:30,303
the Rose (speaking softly)
to get its unique identifier.

607
00:27:32,780 --> 00:27:34,710
And sending a raw command to the kernel,

608
00:27:34,710 --> 00:27:36,240
it stills passes a few reverse

609
00:27:36,240 --> 00:27:37,970
before eventually being forwarded

610
00:27:37,970 --> 00:27:40,123
to the always-on processor.

611
00:27:41,460 --> 00:27:42,700
In this specific example,

612
00:27:42,700 --> 00:27:45,130
the always-on processor
does not handle anything

613
00:27:45,130 --> 00:27:48,400
but forwards the command to the U1 chip.

614
00:27:48,400 --> 00:27:50,440
The application processor in the U1 chip

615
00:27:50,440 --> 00:27:53,033
then finally parses the command.

616
00:27:54,550 --> 00:27:55,640
However, in some situations,

617
00:27:55,640 --> 00:27:58,860
the always-on processor
also needs to keep a state

618
00:27:58,860 --> 00:28:00,990
about what is happening in the U1 chip.

619
00:28:00,990 --> 00:28:01,823
In this case,

620
00:28:01,823 --> 00:28:04,343
another driver is called
the AppleSPUUserClient.

621
00:28:05,480 --> 00:28:06,313
In this example,

622
00:28:06,313 --> 00:28:08,830
a property is set that affects
the always-on processor

623
00:28:08,830 --> 00:28:13,410
state as well as the U1
application processor state.

624
00:28:13,410 --> 00:28:16,230
The AppleSPUUserClient
exports fear methods

625
00:28:16,230 --> 00:28:17,810
and they are primarily meant

626
00:28:17,810 --> 00:28:19,930
to get and set such properties

627
00:28:19,930 --> 00:28:22,803
that also affect the always-on processor.

628
00:28:23,640 --> 00:28:25,270
In this example,

629
00:28:25,270 --> 00:28:28,120
the MAC address of the U1 chip is set.

630
00:28:28,120 --> 00:28:30,630
Note that this is simply two serial bytes

631
00:28:30,630 --> 00:28:33,380
concatenated with the Bluetooth address.

632
00:28:33,380 --> 00:28:35,970
So we have the same MAC
address for immunization

633
00:28:35,970 --> 00:28:36,973
as for Bluetooth.

634
00:28:38,630 --> 00:28:42,010
The 211 in this example is the MAC address

635
00:28:42,010 --> 00:28:44,150
but there are also various
other settings available

636
00:28:44,150 --> 00:28:45,750
for this framework.

637
00:28:45,750 --> 00:28:47,660
Note that you should not switch

638
00:28:47,660 --> 00:28:49,677
the ultra wide band communications route

639
00:28:49,677 --> 00:28:50,890
out of context,

640
00:28:50,890 --> 00:28:53,210
since communication with the
U1 chip will no longer work

641
00:28:53,210 --> 00:28:55,010
until we start in the nearby daemon.

642
00:28:57,560 --> 00:29:00,080
The always-on processor also
applies these properties

643
00:29:00,080 --> 00:29:02,340
and then also calls a handler

644
00:29:02,340 --> 00:29:04,050
in the U1 application processor

645
00:29:04,050 --> 00:29:05,533
to get these properties set.

646
00:29:07,680 --> 00:29:09,280
You might have noticed that both

647
00:29:09,280 --> 00:29:12,510
the AppleSPURoseDriverUserClient
and the AppleSPUUserClient

648
00:29:13,910 --> 00:29:16,440
have a perform command method.

649
00:29:16,440 --> 00:29:20,620
However, in this case of
the AppleSPUUserClient,

650
00:29:20,620 --> 00:29:22,220
these commands are not raw.

651
00:29:22,220 --> 00:29:24,733
There are only a few predefined commands.

652
00:29:25,920 --> 00:29:26,753
In our case,

653
00:29:26,753 --> 00:29:29,930
this exclamation mark just
means new service request,

654
00:29:29,930 --> 00:29:33,500
and most of these commands
also have a few parameters.

655
00:29:33,500 --> 00:29:36,870
The always-on processor then
has a handle for these commands

656
00:29:36,870 --> 00:29:38,590
and it will place the settings

657
00:29:38,590 --> 00:29:39,560
and, if needed,

658
00:29:39,560 --> 00:29:43,023
also execute the command in
the U1 application processor.

659
00:29:44,160 --> 00:29:46,700
The easiest option to start
interaction with the U1 chip

660
00:29:46,700 --> 00:29:47,970
is using AirDrop.

661
00:29:47,970 --> 00:29:49,790
However, as you can see,

662
00:29:49,790 --> 00:29:52,380
as long as the other device
is not in the contact list,

663
00:29:52,380 --> 00:29:55,800
spatial information is not
displayed in the user interface.

664
00:29:55,800 --> 00:29:56,970
Note that, nonetheless,

665
00:29:56,970 --> 00:29:58,950
some U1 interaction is triggered

666
00:29:58,950 --> 00:30:01,920
but this is not that
helpful for debugging.

667
00:30:01,920 --> 00:30:03,090
Instead, you can download

668
00:30:03,090 --> 00:30:06,063
the Peekaboo example
application from Apple.

669
00:30:06,900 --> 00:30:08,160
This is much more helpful

670
00:30:08,160 --> 00:30:11,380
and shows distance as
well as angle information.

671
00:30:11,380 --> 00:30:12,860
In contrast to AirDrop,

672
00:30:12,860 --> 00:30:15,060
it exchanges a peer token

673
00:30:15,060 --> 00:30:18,493
that is then also used
for STS in the U1 chip.

674
00:30:19,970 --> 00:30:23,410
What you can see here is the
output of the nearby daemon

675
00:30:23,410 --> 00:30:25,380
while the Peekaboo app is running.

676
00:30:25,380 --> 00:30:27,550
So what you can see here is

677
00:30:27,550 --> 00:30:31,480
that we get regular
measurements from the Rose chip

678
00:30:31,480 --> 00:30:36,060
and everything is also
sent to this sensor fusion

679
00:30:36,060 --> 00:30:39,543
to get a solution of the actual values.

680
00:30:40,840 --> 00:30:42,580
While the chip is idle,

681
00:30:42,580 --> 00:30:45,903
the host sends a regular AP check-in.

682
00:30:47,430 --> 00:30:50,300
Once we start the Peekaboo app,

683
00:30:50,300 --> 00:30:51,920
it will take a moment

684
00:30:51,920 --> 00:30:55,830
and then the iPhones discover each other,

685
00:30:55,830 --> 00:30:59,750
and what you can see next
is the ServiceRequest

686
00:30:59,750 --> 00:31:02,460
and the RangingStart.

687
00:31:02,460 --> 00:31:06,500
However, the measurements
are not sent via IOKit

688
00:31:06,500 --> 00:31:08,853
and this is why we do not see them.

689
00:31:11,300 --> 00:31:13,240
If you want to see more IOKit output,

690
00:31:13,240 --> 00:31:15,780
you can change my script
and reconfigure it

691
00:31:15,780 --> 00:31:16,893
to debug IOKit.

692
00:31:21,080 --> 00:31:24,163
And with this you will
see way more information.

693
00:31:30,830 --> 00:31:33,410
So this was the chip initialization

694
00:31:33,410 --> 00:31:36,367
and now we are starting the Peekaboo app.

695
00:31:46,350 --> 00:31:48,057
And as you can see here,

696
00:31:48,057 --> 00:31:49,913
I will just quit this now.

697
00:31:52,350 --> 00:31:54,560
We got the ServiceRequest

698
00:31:54,560 --> 00:31:56,203
with a lot of information.

699
00:32:00,410 --> 00:32:02,560
On the left-hand side you
can see the most relevant

700
00:32:02,560 --> 00:32:04,100
log out-put from the nearby daemon

701
00:32:04,100 --> 00:32:07,180
when using the nearby
interactions framework.

702
00:32:07,180 --> 00:32:09,140
A new ServiceRequest is scheduled,

703
00:32:09,140 --> 00:32:12,060
and for this a general
ranging packet is built

704
00:32:12,060 --> 00:32:14,763
that defines all transmission parameters.

705
00:32:15,930 --> 00:32:17,970
On the right-hand side
you can see the output

706
00:32:17,970 --> 00:32:19,510
of my Frida script.

707
00:32:19,510 --> 00:32:22,710
You can see the new
ServiceRequest in detail.

708
00:32:22,710 --> 00:32:25,960
Note that the STS block output
format in the original log

709
00:32:25,960 --> 00:32:27,350
is not very helpful.

710
00:32:27,350 --> 00:32:31,380
Apparently, some developer
decided to print each byte

711
00:32:31,380 --> 00:32:35,120
in variable length decimal
without specifying a separator.

712
00:32:35,120 --> 00:32:37,110
When looking at the syntax hexadecimal,

713
00:32:37,110 --> 00:32:41,130
it becomes clear that the
STS is composed of contents

714
00:32:41,130 --> 00:32:43,683
of the nearby interaction peer tokens.

715
00:32:46,150 --> 00:32:48,290
To understand a bit
more about the firmware,

716
00:32:48,290 --> 00:32:49,690
we need to understand the format

717
00:32:49,690 --> 00:32:51,927
and load it into a disassembler.

718
00:32:54,003 --> 00:32:58,460
The U1 chip firmware is contained
in every IPSW, OTA image,

719
00:32:58,460 --> 00:33:00,330
or peripheral image.

720
00:33:00,330 --> 00:33:04,237
You can simply extract it from
the folder /firmware/Rose.

721
00:33:04,237 --> 00:33:07,170
The ftab format is rather
simple and well-known,

722
00:33:07,170 --> 00:33:10,603
so there are existing scripts
to extract its contents.

723
00:33:11,540 --> 00:33:12,373
As of now,

724
00:33:12,373 --> 00:33:14,730
I have encountered five
different hardware variants,

725
00:33:14,730 --> 00:33:17,940
the iPhone 11 versus
12, the Apple Watch 6,

726
00:33:17,940 --> 00:33:19,997
the Homepod mini and the AirTag.

727
00:33:23,650 --> 00:33:26,420
The ftab that you can
download from Apple servers

728
00:33:26,420 --> 00:33:28,010
contains an application processor

729
00:33:28,010 --> 00:33:30,520
and digital signal processor image.

730
00:33:30,520 --> 00:33:32,900
Both of them can be statically analyzed

731
00:33:32,900 --> 00:33:35,363
with any reversal rearing
tool of your choice.

732
00:33:36,810 --> 00:33:39,260
However, the ftab files
stored on an iPhone

733
00:33:39,260 --> 00:33:42,810
after an update differs
from the initial ftab file.

734
00:33:42,810 --> 00:33:46,360
It gets appended by a so-called IP ticket.

735
00:33:46,360 --> 00:33:49,210
This is a signature by
Apple from the combination

736
00:33:49,210 --> 00:33:52,050
of this firmware and U1 chip.

737
00:33:52,050 --> 00:33:54,870
Each U1 chip has a unique ECID,

738
00:33:54,870 --> 00:33:58,420
so you cannot simply boot
a different firmware.

739
00:33:58,420 --> 00:34:00,780
I have not tried if it
is possible time-crate

740
00:34:00,780 --> 00:34:02,820
the firmware of the U1 chip yet,

741
00:34:02,820 --> 00:34:04,440
but if it is possible,

742
00:34:04,440 --> 00:34:07,610
then only if you have copied
the according ftab file

743
00:34:07,610 --> 00:34:08,910
from a jailbroken iPhone

744
00:34:08,910 --> 00:34:10,823
that is always signed by Apple.

745
00:34:12,550 --> 00:34:15,290
Next I'm going to override
the firmware that I have,

746
00:34:15,290 --> 00:34:18,070
moving all the firmware
from a different iPhone

747
00:34:18,070 --> 00:34:19,710
with a different iOS version,

748
00:34:19,710 --> 00:34:21,773
but also with a different ECID.

749
00:34:23,390 --> 00:34:24,340
So first of all,

750
00:34:24,340 --> 00:34:26,580
to get the chip into a clean state

751
00:34:26,580 --> 00:34:28,330
I'm resetting it

752
00:34:28,330 --> 00:34:32,183
and now I'm going to inject
my firmware by pressing enter.

753
00:34:34,610 --> 00:34:38,860
And now you should see that
the chip is no longer starting.

754
00:34:38,860 --> 00:34:41,890
And this is the case
multiple times in a row

755
00:34:41,890 --> 00:34:44,170
until I am stopping my script.

756
00:34:44,170 --> 00:34:46,090
So I will now stop my script here

757
00:34:47,390 --> 00:34:50,800
and you can now see that
the chip is booting again.

758
00:34:50,800 --> 00:34:53,193
So let's take a close look into this.

759
00:34:55,660 --> 00:34:59,743
So actually, we got some arrows here.

760
00:35:04,060 --> 00:35:05,260
And as you can see,

761
00:35:05,260 --> 00:35:10,260
we see that the Rose boot failed
and we did not successfully

762
00:35:12,270 --> 00:35:13,560
boot the secure ROM.

763
00:35:13,560 --> 00:35:14,800
You can also see

764
00:35:14,800 --> 00:35:17,333
that we got some crash logs over here.

765
00:35:19,530 --> 00:35:22,310
A successful chip boot
looks quite differently.

766
00:35:22,310 --> 00:35:26,560
So you can see here that
we are booting the chip

767
00:35:26,560 --> 00:35:31,370
and it has started including
some parameters like this ECID.

768
00:35:31,370 --> 00:35:33,770
So this is not written, this is just read,

769
00:35:33,770 --> 00:35:35,370
so you cannot write this property.

770
00:35:35,370 --> 00:35:36,840
I tried this.

771
00:35:36,840 --> 00:35:40,650
But this is all included
in the boot process

772
00:35:40,650 --> 00:35:44,193
and also in the signature
that is very fined.

773
00:35:47,000 --> 00:35:48,230
The first thing I mannered

774
00:35:48,230 --> 00:35:50,470
before understanding all
the U1 chip internals

775
00:35:50,470 --> 00:35:52,303
was obtaining logs from the chip.

776
00:35:55,410 --> 00:35:57,730
I simply did some static
reverse engineering

777
00:35:57,730 --> 00:35:58,590
of nearby daemon,

778
00:35:58,590 --> 00:36:01,320
wondering how I could
interact with the firmware.

779
00:36:01,320 --> 00:36:04,710
I found a handler that always allows

780
00:36:04,710 --> 00:36:06,460
to trigger some FatalErrorHandling.

781
00:36:09,730 --> 00:36:12,210
The same handler also
contains another command

782
00:36:12,210 --> 00:36:13,560
to switch off the chip.

783
00:36:13,560 --> 00:36:15,980
This can be triggered through
the iOS user interface

784
00:36:15,980 --> 00:36:17,620
by enabling flight mode.

785
00:36:17,620 --> 00:36:19,600
So I simply switched the implementation

786
00:36:19,600 --> 00:36:23,960
of switching off the chip
and triggering a fatal error.

787
00:36:23,960 --> 00:36:25,170
As a result,

788
00:36:25,170 --> 00:36:26,520
I got full crash logs,

789
00:36:26,520 --> 00:36:29,120
and since this was an iOS 13.3

790
00:36:29,120 --> 00:36:31,430
with a U1 RTKitOS debug build,

791
00:36:31,430 --> 00:36:33,093
I also got packet logs.

792
00:36:33,093 --> 00:36:35,900
Note that in addition to
triggering a fatal error,

793
00:36:35,900 --> 00:36:38,210
it is also required to
set a few more variables

794
00:36:38,210 --> 00:36:40,780
that make the nearby
daemon believe it would be

795
00:36:40,780 --> 00:36:41,733
an internal build.

796
00:36:45,910 --> 00:36:48,660
Once I understood a bit more
about the drive structure,

797
00:36:48,660 --> 00:36:51,400
I found a better way
to call such functions.

798
00:36:51,400 --> 00:36:54,143
The RoseControllerLib
provides lot of abstract

799
00:36:54,143 --> 00:36:56,543
(speaking softly) to you
for the mailer daemon.

800
00:36:57,600 --> 00:36:59,110
Since it is a shared library,

801
00:36:59,110 --> 00:37:00,850
it even exports symbols,

802
00:37:00,850 --> 00:37:02,470
and the libRoseBooter,

803
00:37:02,470 --> 00:37:04,350
which is used during the chip start-up,

804
00:37:04,350 --> 00:37:06,270
also uses the RoseControllerLib

805
00:37:06,270 --> 00:37:09,250
and also exports some of those.

806
00:37:09,250 --> 00:37:10,143
It is possible to directly call

807
00:37:10,143 --> 00:37:14,650
\the function trigger crash
log in the RoseControllerLib.

808
00:37:14,650 --> 00:37:17,693
And the second argument is
the crash type as an integer.

809
00:37:21,840 --> 00:37:23,940
All right, let's actually
trigger a crash log.

810
00:37:23,940 --> 00:37:26,080
So for this, let's first of all,

811
00:37:26,080 --> 00:37:29,200
watch that we are getting a new crash log.

812
00:37:29,200 --> 00:37:32,490
So just check this on the right-hand side.

813
00:37:32,490 --> 00:37:34,070
And since we are running in Frida,

814
00:37:34,070 --> 00:37:39,070
we can also just directly enter
a command in this interface.

815
00:37:41,540 --> 00:37:43,550
So here I'm triggering the crash log

816
00:37:44,410 --> 00:37:47,370
and now you can already see
the firmware is rebooting.

817
00:37:47,370 --> 00:37:49,120
And on the right-hand side,

818
00:37:49,120 --> 00:37:51,253
we even got a new crash log.

819
00:37:52,190 --> 00:37:53,983
So let's check this out.

820
00:37:59,120 --> 00:38:02,050
So the first thing you will
notice is that the firmware

821
00:38:02,050 --> 00:38:05,180
logs with the packets are zero bytes

822
00:38:05,180 --> 00:38:07,870
because this is not a debug build,

823
00:38:07,870 --> 00:38:11,330
and depending on the actual crash,

824
00:38:11,330 --> 00:38:15,090
we only get an AP log or also the SP log.

825
00:38:15,090 --> 00:38:17,840
And we can see the crash
reason in the summaries,

826
00:38:17,840 --> 00:38:20,283
so this is human readable.

827
00:38:22,950 --> 00:38:24,320
So as you can see here,

828
00:38:24,320 --> 00:38:27,493
this was a coredump trigger
that we caused on our own.

829
00:38:28,890 --> 00:38:32,530
And actually, it thinks that
the firmware logs are enabled,

830
00:38:32,530 --> 00:38:37,240
so I changed everything
correctly with an iOS

831
00:38:37,240 --> 00:38:39,953
but the chip just does
not support this feature.

832
00:38:43,718 --> 00:38:46,177
With this, I'm concluding
the talk about Apple's new

833
00:38:46,177 --> 00:38:47,227
ultra wide band chip.

834
00:38:48,880 --> 00:38:51,150
First of all, Bluetooth
and ultra wide band

835
00:38:51,150 --> 00:38:52,750
are dependent on each other.

836
00:38:52,750 --> 00:38:54,670
They use the same MAC address

837
00:38:54,670 --> 00:38:55,900
and, as of now,

838
00:38:55,900 --> 00:38:59,253
ultra wide band only works after
initializing via Bluetooth.

839
00:39:00,650 --> 00:39:02,670
Apple's own RTKit-based wireless chips

840
00:39:02,670 --> 00:39:04,370
are super, super interesting,

841
00:39:04,370 --> 00:39:06,610
and also have a lot of security features.

842
00:39:06,610 --> 00:39:10,023
The always-on processor routing
is great for saving energy.

843
00:39:11,090 --> 00:39:14,690
And even though we cannot modify
the U1 firmware as of now,

844
00:39:14,690 --> 00:39:15,523
many features in the
chip can be instrumented

845
00:39:15,523 --> 00:39:18,833
from user space on a jailbroken device.

846
00:39:20,350 --> 00:39:22,040
Some scripts that enable you to interact

847
00:39:22,040 --> 00:39:22,880
with the U1 chip

848
00:39:22,880 --> 00:39:25,890
will be available on
GitHub on our group's page.

849
00:39:25,890 --> 00:39:28,980
Note that Defcon will not have
a Q and A session this year,

850
00:39:28,980 --> 00:39:30,460
so if you have further questions,

851
00:39:30,460 --> 00:39:33,270
you can drop us a direct
message or write an email.

852
00:39:33,270 --> 00:39:34,270
Thanks for watching.

