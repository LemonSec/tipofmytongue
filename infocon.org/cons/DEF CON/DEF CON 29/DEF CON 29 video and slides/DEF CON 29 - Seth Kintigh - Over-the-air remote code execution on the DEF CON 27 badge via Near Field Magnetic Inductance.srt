1
00:00:01,270 --> 00:00:02,730
- Hello, and welcome to my talk

2
00:00:02,730 --> 00:00:05,073
on hacking the DEFCON 27 Badge.

3
00:00:06,610 --> 00:00:07,740
My name is Seth Kintigh.

4
00:00:07,740 --> 00:00:10,450
My background is hardware
and computer security.

5
00:00:10,450 --> 00:00:12,763
So this project was a lot of fun for me.

6
00:00:14,580 --> 00:00:15,950
I just wanted to give a little background

7
00:00:15,950 --> 00:00:17,650
on some of the terminology we'll be using

8
00:00:17,650 --> 00:00:19,640
in this presentation.

9
00:00:19,640 --> 00:00:22,900
NFMI, near field magnetic inductions.

10
00:00:22,900 --> 00:00:25,380
It's basically using magnetic waves

11
00:00:25,380 --> 00:00:29,700
and fields to communicate
instead of radio.

12
00:00:29,700 --> 00:00:32,990
And magnetic fields decay much faster rate

13
00:00:32,990 --> 00:00:35,190
than a radio does,

14
00:00:35,190 --> 00:00:37,490
passes us through body tissues better.

15
00:00:37,490 --> 00:00:40,860
So it's better for short distances,

16
00:00:40,860 --> 00:00:43,470
for body area networks.

17
00:00:43,470 --> 00:00:46,470
The short distance supposedly
it makes it more secure.

18
00:00:46,470 --> 00:00:51,470
It's more efficient and
hasn't been used too much.

19
00:00:52,320 --> 00:00:54,730
Basically it uses two coils to
communicate with each other,

20
00:00:54,730 --> 00:00:58,030
sort of like electromagnets

21
00:00:58,030 --> 00:01:00,430
or half of the transformer
talking to each other

22
00:01:00,430 --> 00:01:02,270
instead of using antennas.

23
00:01:02,270 --> 00:01:04,010
And it's used in proximity cars

24
00:01:04,010 --> 00:01:06,000
as part of the NFC protocol.

25
00:01:06,000 --> 00:01:09,420
And it's using some hearing
aids and I think some earbuds,

26
00:01:09,420 --> 00:01:11,773
but not too many other locations.

27
00:01:14,001 --> 00:01:18,480
And maybe they had dreams of
putting it in Apple earbuds

28
00:01:18,480 --> 00:01:21,030
because I read that somewhere in a blog,

29
00:01:21,030 --> 00:01:24,190
but the company was extremely cagey

30
00:01:24,190 --> 00:01:27,170
about any sort of
information on these chips.

31
00:01:27,170 --> 00:01:30,880
There was no data sheet
at all, which is bizarre.

32
00:01:30,880 --> 00:01:34,520
No info on the protocol,
no dev kits, no samples.

33
00:01:34,520 --> 00:01:35,870
If you wanted to order anything

34
00:01:35,870 --> 00:01:38,740
you had to order tens
or hundreds of thousands

35
00:01:38,740 --> 00:01:40,290
and sign an NDA

36
00:01:40,290 --> 00:01:45,103
Just couldn't find any real
official info on these chips.

37
00:01:47,500 --> 00:01:49,240
Software defined radio,

38
00:01:49,240 --> 00:01:51,005
basically taking all the hardware guts

39
00:01:51,005 --> 00:01:55,090
and making them virtual and
putting them into software

40
00:01:55,090 --> 00:01:56,940
that makes designing new radios

41
00:01:56,940 --> 00:01:59,290
and mixing and matching parts much easier

42
00:01:59,290 --> 00:02:00,143
and more fun.

43
00:02:02,350 --> 00:02:06,472
I used a new radio to do that
sort of thing and modulate

44
00:02:06,472 --> 00:02:08,270
demodulate signals.

45
00:02:08,270 --> 00:02:10,260
Some other tools with that too.

46
00:02:10,260 --> 00:02:13,760
I used HackRF to receive
and transmit my signals

47
00:02:13,760 --> 00:02:14,593
and tune them.

48
00:02:15,670 --> 00:02:16,530
There's no antennas,

49
00:02:16,530 --> 00:02:18,911
but I made a bunch of coils just wrapping

50
00:02:18,911 --> 00:02:22,223
electromagnet electromagnet wire.

51
00:02:23,280 --> 00:02:25,890
And I should probably have
some pictures of those

52
00:02:25,890 --> 00:02:27,660
online at some point.

53
00:02:27,660 --> 00:02:29,733
And used Python for everything else.

54
00:02:31,994 --> 00:02:33,070
A few other terms you should know,

55
00:02:33,070 --> 00:02:33,993
buffer overflow, TAG,

56
00:02:33,993 --> 00:02:35,170
just how that works.

57
00:02:35,170 --> 00:02:37,070
I'm sure most of you familiar with that.

58
00:02:37,070 --> 00:02:39,190
Basically just blow
everything on the stack

59
00:02:39,190 --> 00:02:40,700
and keep on writing until you overwrite

60
00:02:40,700 --> 00:02:43,150
the return address and
take control of a program.

61
00:02:44,140 --> 00:02:46,260
SWD or J-TAG,

62
00:02:46,260 --> 00:02:49,990
those are different low level hardware,

63
00:02:49,990 --> 00:02:53,424
debug interfaces, or like
GDB, but super low level,

64
00:02:53,424 --> 00:02:56,250
control the clock one cycle a time.

65
00:02:56,250 --> 00:02:57,083
Fun stuff.

66
00:02:58,125 --> 00:02:59,390
And then a convolution code,

67
00:02:59,390 --> 00:03:00,970
basically error correction code

68
00:03:00,970 --> 00:03:04,930
spreads out bits over multiple symbols

69
00:03:04,930 --> 00:03:07,783
to make them more resistant to noise.

70
00:03:11,600 --> 00:03:14,423
So the badge was part of a game.

71
00:03:15,274 --> 00:03:16,900
They communicated the badges,

72
00:03:16,900 --> 00:03:17,860
communicate with each other

73
00:03:17,860 --> 00:03:20,150
and they'd make little beeping noises

74
00:03:20,150 --> 00:03:23,980
and blink lights when they
paired with each other.

75
00:03:23,980 --> 00:03:26,320
And then if you paired with a magic badge,

76
00:03:26,320 --> 00:03:29,940
it would advance the stage
of the game you were in

77
00:03:29,940 --> 00:03:31,010
and there were six stages.

78
00:03:31,010 --> 00:03:32,810
And you advanced once for each of these

79
00:03:32,810 --> 00:03:37,610
different magic versions
of these flavors of badge.

80
00:03:37,610 --> 00:03:38,710
And then once you got all of them,

81
00:03:38,710 --> 00:03:41,583
you won by getting a
piezoelectric rick-roll.

82
00:03:42,540 --> 00:03:45,280
The badges are actually
cut from pieces of stone.

83
00:03:45,280 --> 00:03:46,690
And there was a great
presentation on that,

84
00:03:46,690 --> 00:03:47,540
should check out.

85
00:03:50,420 --> 00:03:55,300
The badge hardware has an MCU
that does most of the work,

86
00:03:55,300 --> 00:03:58,120
controls the lights and
speakers and whatnot,

87
00:03:58,120 --> 00:04:00,960
and talks to the NFMI chip over UART.

88
00:04:02,194 --> 00:04:04,830
When the MCU boots up,

89
00:04:04,830 --> 00:04:05,900
it loads firmware.

90
00:04:05,900 --> 00:04:06,733
And in that firmware,

91
00:04:06,733 --> 00:04:11,040
there's a little patch of
firmware for the NFMI chip,

92
00:04:11,040 --> 00:04:12,370
and it sends that over UART

93
00:04:12,370 --> 00:04:14,863
and patches that on boot up.

94
00:04:17,590 --> 00:04:20,830
The debug hardware, debug interfaces,

95
00:04:20,830 --> 00:04:23,130
are labeled on this picture.

96
00:04:23,130 --> 00:04:27,010
You can connect by serial
and talk to a console

97
00:04:27,010 --> 00:04:28,970
that's running on the MCU,

98
00:04:28,970 --> 00:04:31,460
or you can connect to a SWD

99
00:04:31,460 --> 00:04:34,260
and do some really low level debugging.

100
00:04:34,260 --> 00:04:35,652
There's no connectors on there.

101
00:04:35,652 --> 00:04:37,000
In that picture,

102
00:04:37,000 --> 00:04:40,150
there's a connector soldered
onto the serial port,

103
00:04:40,150 --> 00:04:43,807
but they're unpopulated
connectors for now.

104
00:04:43,807 --> 00:04:45,910
And you can either solder on a connector

105
00:04:45,910 --> 00:04:47,490
or solder wires on directly,

106
00:04:47,490 --> 00:04:48,853
or use a pressure fitting.

107
00:04:56,730 --> 00:05:01,683
The badges communicate
in a sort of bizarre way.

108
00:05:03,750 --> 00:05:06,600
When the badge MCU wants
to transmit eight bytes,

109
00:05:06,600 --> 00:05:08,580
first, it adds a 'D' to the beginning,

110
00:05:08,580 --> 00:05:11,790
then pads every single
four bits, every nibble,

111
00:05:11,790 --> 00:05:16,530
with a 'D' and then ends
it with an ASCII 'E',

112
00:05:16,530 --> 00:05:17,970
sends out over UART,

113
00:05:17,970 --> 00:05:20,200
the NFMI chip receives that,

114
00:05:20,200 --> 00:05:23,526
immediately strips all of that
padding off and transmits it.

115
00:05:23,526 --> 00:05:25,520
And the receiving badge receives that,

116
00:05:25,520 --> 00:05:27,060
puts all that padding back on again,

117
00:05:27,060 --> 00:05:27,980
sends it over UART,

118
00:05:27,980 --> 00:05:30,153
And then the badge
strips it all off again.

119
00:05:32,896 --> 00:05:35,020
Early on in the game,

120
00:05:35,020 --> 00:05:36,890
I decided to reverse engineer the code

121
00:05:36,890 --> 00:05:39,380
that someone had pulled
the firmware off the badge.

122
00:05:39,380 --> 00:05:41,240
So I reverse engineered
it and looking through,

123
00:05:41,240 --> 00:05:44,396
and after a few hours of that, someone,

124
00:05:44,396 --> 00:05:46,670
I think it was Joe Grant, actually,

125
00:05:46,670 --> 00:05:47,730
released the source code.

126
00:05:47,730 --> 00:05:50,040
So there was sort of wasted time.

127
00:05:50,040 --> 00:05:50,873
But on the other hand,

128
00:05:50,873 --> 00:05:53,140
I'd never actually seen
all the correct answers

129
00:05:53,140 --> 00:05:55,590
when reverse engineering code before,

130
00:05:55,590 --> 00:05:59,770
but it was a new experience.

131
00:05:59,770 --> 00:06:01,160
I tried plugging into Ghidra.

132
00:06:01,160 --> 00:06:02,710
It didn't work very well back then.

133
00:06:02,710 --> 00:06:03,980
I don't know if it still does.

134
00:06:03,980 --> 00:06:06,900
I ended up using an old version of IDA Pro

135
00:06:06,900 --> 00:06:08,730
and it worked a lot better.

136
00:06:08,730 --> 00:06:09,960
While poking through with IDA

137
00:06:09,960 --> 00:06:12,590
I found a buffer overflow
and it seemed so obvious.

138
00:06:12,590 --> 00:06:15,143
I sure was sure it had
to be part of the game.

139
00:06:16,550 --> 00:06:18,286
As you can possibly tell from the code,

140
00:06:18,286 --> 00:06:21,880
it's basically reading bytes into a buffer

141
00:06:21,880 --> 00:06:24,290
until it finds a letter 'E',

142
00:06:24,290 --> 00:06:28,830
and it will read that
buffer is 18 bytes total,

143
00:06:28,830 --> 00:06:30,480
but there's no limit at all.

144
00:06:30,480 --> 00:06:32,980
Just read and read and
read and read and read

145
00:06:32,980 --> 00:06:34,180
until it finds that 'E'.

146
00:06:36,470 --> 00:06:38,690
I made a proof of concept early on.

147
00:06:38,690 --> 00:06:41,430
I wanted to make sure this buffer overflow

148
00:06:41,430 --> 00:06:43,040
was actually exploitable.

149
00:06:43,040 --> 00:06:45,660
So in note pad, I wrote up some arm code

150
00:06:45,660 --> 00:06:47,790
and just used an online assembler

151
00:06:47,790 --> 00:06:50,060
to convert that into machine code.

152
00:06:50,060 --> 00:06:52,580
And I wrote this little script here

153
00:06:52,580 --> 00:06:57,450
to use a J-Link over SWD, not J-TAG.

154
00:06:57,450 --> 00:06:59,680
I connected to the badge,

155
00:06:59,680 --> 00:07:02,390
loaded my payload into the ring buffer.

156
00:07:02,390 --> 00:07:07,390
I set the transmit index and
the receive index values,

157
00:07:07,560 --> 00:07:09,740
and this told the batch to run.

158
00:07:09,740 --> 00:07:11,410
It thought it had a giant packet,

159
00:07:11,410 --> 00:07:13,023
and we'll see what happens.

160
00:07:14,630 --> 00:07:17,290
This is the serial console for the badge.

161
00:07:17,290 --> 00:07:19,460
I'm telling it to receive a packet.

162
00:07:19,460 --> 00:07:20,660
Now I'm going to send it one,

163
00:07:20,660 --> 00:07:23,140
a regular valid packet.

164
00:07:23,140 --> 00:07:24,563
And that's what it displays.

165
00:07:25,450 --> 00:07:29,430
Now I run my hack through J-Link.

166
00:07:29,430 --> 00:07:32,100
So now there is a oversized packet

167
00:07:32,100 --> 00:07:33,820
sitting in the ring buffer.

168
00:07:33,820 --> 00:07:35,980
Next time I tell the batch to receive it,

169
00:07:35,980 --> 00:07:37,170
my code takes over,

170
00:07:37,170 --> 00:07:39,120
prints "hack the planet" on the screen.

171
00:07:40,990 --> 00:07:41,823
Well, that worked.

172
00:07:41,823 --> 00:07:43,490
So now I just need to
figure out how to send

173
00:07:43,490 --> 00:07:46,453
a gigantic custom crafted packet.

174
00:07:48,270 --> 00:07:52,050
So I dug around online
for specs on this chip

175
00:07:52,050 --> 00:07:54,653
used on this badge, the FNMI chip.

176
00:07:55,650 --> 00:07:57,210
Found a few details,

177
00:07:57,210 --> 00:08:00,660
some good guesses on
frequencies and bandwidths.

178
00:08:00,660 --> 00:08:02,580
A pretty good guess on the modulation

179
00:08:03,610 --> 00:08:06,283
from a lot of random sources.

180
00:08:08,100 --> 00:08:12,340
Started looking at the signal in analog.

181
00:08:12,340 --> 00:08:17,020
First, on the top row you see 16 bursts

182
00:08:17,020 --> 00:08:19,440
over about 10 seconds.

183
00:08:19,440 --> 00:08:21,450
Middle row, I magnified
one of those bursts,

184
00:08:21,450 --> 00:08:23,940
so you can kind of see where
the different sections are.

185
00:08:23,940 --> 00:08:25,200
In the bottom row,

186
00:08:25,200 --> 00:08:29,123
lets you see the four distinct
sections of each burst.

187
00:08:30,960 --> 00:08:34,150
Section one seems to be timing pulses,

188
00:08:34,150 --> 00:08:36,670
sends the carrier frequency,

189
00:08:36,670 --> 00:08:38,960
and then one that's 150 megahertz higher

190
00:08:38,960 --> 00:08:41,510
and then one 150 megahertz lower.

191
00:08:41,510 --> 00:08:43,890
It doesn't seem to be
transmitting any data,

192
00:08:43,890 --> 00:08:47,300
but it may be doing this just to establish

193
00:08:47,300 --> 00:08:50,240
a range of frequency and
amplitude of the signal,

194
00:08:50,240 --> 00:08:51,193
as well as timing.

195
00:08:53,450 --> 00:08:54,860
Quick note on down conversion,

196
00:08:54,860 --> 00:08:56,997
if you're familiar with the subject.

197
00:08:56,997 --> 00:08:59,210
You're not demodulating the signal,

198
00:08:59,210 --> 00:09:00,220
you're not changing at all,

199
00:09:00,220 --> 00:09:02,700
other than lowering the frequency

200
00:09:02,700 --> 00:09:04,660
by multiplying it with another signal.

201
00:09:04,660 --> 00:09:07,690
Had to think of it like a
beat frequency in music.

202
00:09:07,690 --> 00:09:10,760
So you're just shifting
the signal down from,

203
00:09:10,760 --> 00:09:13,160
say, 10.569 megahertz.

204
00:09:13,160 --> 00:09:15,570
You're shifting that
down to zero megahertz.

205
00:09:15,570 --> 00:09:19,820
So now all the energy
is circling around that

206
00:09:19,820 --> 00:09:23,890
plus or minus 200,000 kilohertz.

207
00:09:23,890 --> 00:09:28,890
And you can see how the signals that were

208
00:09:29,066 --> 00:09:32,240
at the carrier frequency are now basically

209
00:09:32,240 --> 00:09:34,120
flat lines because they're at zero

210
00:09:34,120 --> 00:09:35,960
or almost zero.

211
00:09:35,960 --> 00:09:37,860
And what whole bunch of squiggles

212
00:09:37,860 --> 00:09:40,430
that want to look much
different from each other

213
00:09:40,430 --> 00:09:43,790
are now much more clearly data.

214
00:09:43,790 --> 00:09:46,563
You can see those
repeating patterns in them.

215
00:09:49,300 --> 00:09:52,290
So section two has these patterns

216
00:09:54,120 --> 00:09:57,040
that plays them twice,

217
00:09:57,040 --> 00:09:58,670
sometimes exact copies.

218
00:09:58,670 --> 00:10:00,200
Sometimes they're inverted.

219
00:10:00,200 --> 00:10:03,700
Sometimes they swap places between I/Q

220
00:10:03,700 --> 00:10:06,120
and there's only, I think,

221
00:10:06,120 --> 00:10:08,610
eight different patterns it shows.

222
00:10:08,610 --> 00:10:10,130
I ended up calling these preambles

223
00:10:10,130 --> 00:10:13,043
based on them showing up
later in the other packet.

224
00:10:16,340 --> 00:10:19,030
Section three just
seems to be more timing.

225
00:10:19,030 --> 00:10:21,890
Tried my best to get it exactly zero hertz

226
00:10:21,890 --> 00:10:22,800
and never quite could.

227
00:10:22,800 --> 00:10:24,290
And then the frequency would drift,

228
00:10:24,290 --> 00:10:27,233
I think with temperature,
I don't really know.

229
00:10:29,500 --> 00:10:31,590
And then section four was data.

230
00:10:31,590 --> 00:10:34,903
271 copies of the same data packet.

231
00:10:36,050 --> 00:10:37,510
Each one starts with eight variations.

232
00:10:37,510 --> 00:10:39,720
Of those preamble you saw in section two

233
00:10:39,720 --> 00:10:41,590
are almost exactly that preamble.

234
00:10:41,590 --> 00:10:42,790
it's slightly different

235
00:10:44,110 --> 00:10:46,640
and then followed by data and then

236
00:10:46,640 --> 00:10:50,240
a brief null or pause.

237
00:10:50,240 --> 00:10:52,490
And sometimes they are
exact copies of each other

238
00:10:52,490 --> 00:10:54,080
and sometimes they're inverted.

239
00:10:54,080 --> 00:10:56,450
Sometimes the I/Q swap just
like with the preambles

240
00:10:56,450 --> 00:10:57,313
in section two.

241
00:10:59,030 --> 00:11:01,890
The modulation used is D8PSK.

242
00:11:01,890 --> 00:11:04,070
PSK is phase shift keying.

243
00:11:04,070 --> 00:11:06,540
It's basically modulating a signal.

244
00:11:06,540 --> 00:11:07,930
So when you plot it,

245
00:11:07,930 --> 00:11:11,040
it shows up as, the bursts show up as,

246
00:11:11,040 --> 00:11:14,050
one of those eight dots
on that constellation.

247
00:11:14,050 --> 00:11:16,280
It will actually form that on a plot,

248
00:11:16,280 --> 00:11:17,883
as long as your timing is right.

249
00:11:20,560 --> 00:11:21,800
The eight refers to there being

250
00:11:21,800 --> 00:11:23,330
eight points in that constellation

251
00:11:23,330 --> 00:11:25,380
and then 'D' means differential.

252
00:11:25,380 --> 00:11:28,380
So it's the difference between each point,

253
00:11:28,380 --> 00:11:31,570
is where your actual data is transmitted.

254
00:11:31,570 --> 00:11:34,513
And each of those points
is called a symbol.

255
00:11:37,810 --> 00:11:40,583
The center frequency seems
to move a little bit.

256
00:11:41,960 --> 00:11:44,040
In the beginning I had one frequency

257
00:11:44,040 --> 00:11:46,300
that I just narrowed down

258
00:11:46,300 --> 00:11:48,140
to a very precise frequency.

259
00:11:48,140 --> 00:11:52,050
It was working very well
until I broke the badge

260
00:11:52,050 --> 00:11:53,510
and then it switched to 1.4

261
00:11:53,510 --> 00:11:54,823
and then later on I fixed another badge

262
00:11:54,823 --> 00:11:59,600
that had broken earlier and
it was using 1.569 megahertz.

263
00:11:59,600 --> 00:12:02,270
So I don't under quite
understand why the frequency

264
00:12:02,270 --> 00:12:03,683
bounces around so much.

265
00:12:04,680 --> 00:12:06,230
It was initially using a sample rate of

266
00:12:06,230 --> 00:12:09,120
2 million samples per second,

267
00:12:09,120 --> 00:12:10,677
but the timing didn't work out and I said,

268
00:12:10,677 --> 00:12:14,670
"Oh, well obviously if it's
596 kilohertz bandwidth,

269
00:12:14,670 --> 00:12:18,870
then I need to use a multiple
of that for the sample rates."

270
00:12:18,870 --> 00:12:22,250
So I use the 1.192, but
that didn't work out either.

271
00:12:22,250 --> 00:12:24,150
And I ended up using this 1.19055,

272
00:12:26,560 --> 00:12:30,760
and that worked out perfectly
for 440 samples per packet,

273
00:12:30,760 --> 00:12:33,493
or four samples per symbol.

274
00:12:34,490 --> 00:12:36,443
Why that number, I don't know.

275
00:12:38,870 --> 00:12:41,260
Using HackRF to receive the signal,

276
00:12:41,260 --> 00:12:44,360
it does the down
conversion and resampling.

277
00:12:44,360 --> 00:12:47,190
So I can use an easier to use frequency.

278
00:12:47,190 --> 00:12:49,630
And it was just a much lower sampling rate

279
00:12:49,630 --> 00:12:51,640
because your sampling
rate must be at least

280
00:12:51,640 --> 00:12:54,830
twice your highest
frequency than your signal.

281
00:12:54,830 --> 00:12:57,483
And then I use GNURadio
to write my demodulator.

282
00:12:58,390 --> 00:13:00,930
Now, there were some examples
online of some lower order,

283
00:13:00,930 --> 00:13:03,233
like some 4PSK demodulators
and modulators.

284
00:13:04,782 --> 00:13:06,782
And I figured it would be easy enough to

285
00:13:07,710 --> 00:13:10,350
modify one of those into 8PSK,

286
00:13:10,350 --> 00:13:11,920
but it ended up being a nightmare.

287
00:13:11,920 --> 00:13:15,840
And the examples used
components that don't exist,

288
00:13:15,840 --> 00:13:18,340
or never worked or were
broken for other reasons,

289
00:13:18,340 --> 00:13:21,100
and not documented and no one could help,

290
00:13:21,100 --> 00:13:22,280
and the docs were a mess.

291
00:13:22,280 --> 00:13:24,180
And it was kind of a nightmare.

292
00:13:24,180 --> 00:13:26,720
So I made a bunch of working examples

293
00:13:26,720 --> 00:13:31,500
of different flavors of my PSK
modulators and demodulators,

294
00:13:31,500 --> 00:13:34,853
and I put them all on GitHub
to help other people out.

295
00:13:37,280 --> 00:13:40,799
Now I had to deal with noise and nulls.

296
00:13:40,799 --> 00:13:44,900
There's 271 copies of the same packet,

297
00:13:44,900 --> 00:13:46,650
but they varied a bunch.

298
00:13:46,650 --> 00:13:49,072
But only some of that was the noise.

299
00:13:49,072 --> 00:13:51,450
It turns out that because
of those null symbols

300
00:13:51,450 --> 00:13:52,363
at the beginning,

301
00:13:53,320 --> 00:13:57,260
normal D8PSK demodulator
doesn't understand

302
00:13:57,260 --> 00:13:59,070
what those are and tries to put them

303
00:13:59,070 --> 00:14:00,960
into one of those eight quadrants.

304
00:14:00,960 --> 00:14:03,170
So it kind of interprets them as eight

305
00:14:03,170 --> 00:14:05,540
for three random symbols.

306
00:14:05,540 --> 00:14:06,710
And then after those nulls,

307
00:14:06,710 --> 00:14:09,050
there seemed to be an
actual random symbol,

308
00:14:09,050 --> 00:14:11,370
which is why there was
eight different variations

309
00:14:11,370 --> 00:14:13,413
of both the preamble and of the packet.

310
00:14:15,174 --> 00:14:16,860
The nulls were new to me all together,

311
00:14:16,860 --> 00:14:18,032
and you could maybe even call it

312
00:14:18,032 --> 00:14:21,350
sort of a ninth symbol
in that constellation.

313
00:14:21,350 --> 00:14:24,380
I Googled around trying to
find out other examples of it

314
00:14:24,380 --> 00:14:26,890
and NXP, the maker of this NFMI chip,

315
00:14:26,890 --> 00:14:30,490
they also make this
Coolflux BSP audio chip,

316
00:14:30,490 --> 00:14:35,490
and it also uses a similar
modulation scheme with nulls.

317
00:14:36,550 --> 00:14:39,933
And those nulls are used for
finding the timing of a signal.

318
00:14:42,550 --> 00:14:47,130
So my demodulator spits
out a stream of symbols,

319
00:14:47,130 --> 00:14:49,110
which I then I've manually parsed here

320
00:14:49,110 --> 00:14:50,600
just to make them more readable.

321
00:14:50,600 --> 00:14:53,422
So you can see section one is 21 copies

322
00:14:53,422 --> 00:14:57,840
of just blast of that signal,

323
00:14:57,840 --> 00:14:59,823
basically junk in those symbols.

324
00:15:01,110 --> 00:15:04,440
Section two, we see that
preamble copied twice,

325
00:15:04,440 --> 00:15:06,350
followed by a little bit of noise,

326
00:15:06,350 --> 00:15:07,813
and I think mostly nulls.

327
00:15:09,380 --> 00:15:12,273
Section three is just more timing blasts.

328
00:15:13,170 --> 00:15:17,043
And then section four is
where our actual data lives.

329
00:15:17,980 --> 00:15:21,643
These are the symbols for our packets,

330
00:15:22,670 --> 00:15:25,010
271 copies of them.

331
00:15:25,010 --> 00:15:26,020
They should be identical.

332
00:15:26,020 --> 00:15:27,883
They're not because of some noise.

333
00:15:30,210 --> 00:15:32,280
So I had to write a Python program

334
00:15:32,280 --> 00:15:37,280
to basically ignore the first
few bytes or few symbols,

335
00:15:37,420 --> 00:15:40,893
then count up all the different
patterns of packet set.

336
00:15:41,830 --> 00:15:43,410
Each flavor of packet are in there.

337
00:15:43,410 --> 00:15:45,410
And then whichever one has the most copies

338
00:15:45,410 --> 00:15:48,860
is judged to be the correct copy.

339
00:15:48,860 --> 00:15:51,253
And the one copy of that one is output.

340
00:15:53,050 --> 00:15:56,650
The preambles consists
of 20 fixed symbols,

341
00:15:56,650 --> 00:16:01,110
and then 12 that can be
in one of three patterns.

342
00:16:01,110 --> 00:16:04,430
The section two seems to flip randomly

343
00:16:04,430 --> 00:16:05,950
between two different sequences

344
00:16:05,950 --> 00:16:10,950
of those 12 preamble symbols.

345
00:16:12,050 --> 00:16:13,260
I don't know what they meant.

346
00:16:13,260 --> 00:16:15,760
I assumed that the one with mostly zeros

347
00:16:15,760 --> 00:16:19,030
could be like the mask for all zeros,

348
00:16:19,030 --> 00:16:21,083
but it doesn't quite seem to be right.

349
00:16:21,940 --> 00:16:23,610
It could be, I don't know,

350
00:16:23,610 --> 00:16:24,710
never really figured that out.

351
00:16:24,710 --> 00:16:26,030
And then section four,

352
00:16:26,030 --> 00:16:29,950
every single packet always
starts with the same preamble,

353
00:16:29,950 --> 00:16:31,850
which is different than the other two.

354
00:16:34,410 --> 00:16:37,300
And here we see the structure
of the entire packet.

355
00:16:37,300 --> 00:16:39,627
We've got the header that has those nulls

356
00:16:39,627 --> 00:16:42,570
and that little random
byte or random symbol

357
00:16:42,570 --> 00:16:44,820
I'm referring to as the primer.

358
00:16:44,820 --> 00:16:46,490
And then the preamble.

359
00:16:46,490 --> 00:16:49,940
Then we have the packet data,

360
00:16:49,940 --> 00:16:54,940
which is 64 symbols
corresponding to 16 bytes.

361
00:16:56,310 --> 00:17:00,110
The first four bytes
appear to be a counter.

362
00:17:00,110 --> 00:17:02,087
Then there's one byte that is used as

363
00:17:02,087 --> 00:17:05,220
the length field for the user data.

364
00:17:05,220 --> 00:17:09,440
And then there's 11 bytes
available for user data.

365
00:17:09,440 --> 00:17:11,310
But the badge only uses the first eight,

366
00:17:11,310 --> 00:17:15,110
the last three are just left unused.

367
00:17:15,110 --> 00:17:19,680
And then the footer
has what all 10 symbols

368
00:17:19,680 --> 00:17:21,420
that change with every single packet

369
00:17:21,420 --> 00:17:24,320
as the counter increments.

370
00:17:24,320 --> 00:17:27,823
So I assumed it was a
checksum or CRC of some sort.

371
00:17:30,490 --> 00:17:33,140
Now I need to find the mask,

372
00:17:33,140 --> 00:17:38,140
the zero mask for all of the data,

373
00:17:38,156 --> 00:17:43,156
because if you fill a packet
with zeros in the data fields,

374
00:17:43,450 --> 00:17:46,810
you don't get a packet
full of zero symbols.

375
00:17:46,810 --> 00:17:50,090
You get a random looking
pattern of symbols.

376
00:17:50,090 --> 00:17:53,560
This is the mask that
they've used to either

377
00:17:53,560 --> 00:17:56,480
obfuscate what's being transmitted,

378
00:17:56,480 --> 00:17:59,250
or maybe it's used for spread spectrum

379
00:17:59,250 --> 00:18:01,400
or noise or resistance or something,

380
00:18:01,400 --> 00:18:02,390
not entirely sure.

381
00:18:02,390 --> 00:18:04,810
But basically when you
send an empty packet,

382
00:18:04,810 --> 00:18:08,280
you don't send all zeros,
you send a pattern.

383
00:18:08,280 --> 00:18:10,880
So I was able to able to easily change

384
00:18:10,880 --> 00:18:12,210
the first eight bytes to zeros

385
00:18:12,210 --> 00:18:14,673
and confirmed that
there's this crazy mask.

386
00:18:15,590 --> 00:18:17,320
Later on I modified the firmware

387
00:18:17,320 --> 00:18:20,506
to allow the MCU badge firmware

388
00:18:20,506 --> 00:18:23,670
to allow me to send 11 bytes in a packet.

389
00:18:23,670 --> 00:18:24,880
So all those to zeros,

390
00:18:24,880 --> 00:18:26,468
and that's what the pattern you see

391
00:18:26,468 --> 00:18:28,950
on the bottom of the screen.

392
00:18:28,950 --> 00:18:31,010
Though I don't actually
see any sort of pattern

393
00:18:31,010 --> 00:18:31,843
in this pattern.

394
00:18:33,980 --> 00:18:36,300
Finding the mass for the other data bytes

395
00:18:36,300 --> 00:18:38,283
was a little more difficult.

396
00:18:40,947 --> 00:18:41,820
I was basically able to confirm

397
00:18:41,820 --> 00:18:43,160
that the counter was counting.

398
00:18:43,160 --> 00:18:45,040
It was counting by binary values,

399
00:18:45,040 --> 00:18:48,830
except it was counting by twos.

400
00:18:48,830 --> 00:18:52,320
And I didn't know if it was
starting off odd or even,

401
00:18:52,320 --> 00:18:54,470
I basically had to guess.

402
00:18:54,470 --> 00:18:56,350
And because of the tail that it has

403
00:18:56,350 --> 00:18:57,714
in a chain of symbols

404
00:18:57,714 --> 00:19:00,780
that was covering up some
of the other symbols.

405
00:19:00,780 --> 00:19:03,793
So I needed a way to figure out something.

406
00:19:05,260 --> 00:19:09,260
I observed the counter
incrementing in that binary fashion

407
00:19:09,260 --> 00:19:12,289
decided, well, I'll just
record it for a week.

408
00:19:12,289 --> 00:19:16,630
Eventually it found
that after about a week,

409
00:19:16,630 --> 00:19:18,940
it finally flipped the 10th symbol.

410
00:19:18,940 --> 00:19:23,940
So I was able to get
10 of the mask symbols,

411
00:19:23,980 --> 00:19:27,270
and then the tail change afterwards.

412
00:19:27,270 --> 00:19:29,390
I have no idea what those bits are.

413
00:19:29,390 --> 00:19:31,537
So I don't know if there ones are zeroes.

414
00:19:31,537 --> 00:19:34,210
So only the green is what I'm positive

415
00:19:34,210 --> 00:19:36,140
or so I thought were zeros

416
00:19:36,140 --> 00:19:39,090
based on my guess of what was
odd or even at the beginning.

417
00:19:41,020 --> 00:19:44,860
And I realized that it took
19.1 hours to get the ninth,

418
00:19:44,860 --> 00:19:47,920
almost a week to get the 10th symbol.

419
00:19:47,920 --> 00:19:52,580
It was going to take
decades to get 16 symbols

420
00:19:52,580 --> 00:19:55,310
and over 9,000 years to get all 20.

421
00:19:55,310 --> 00:19:57,270
And I tried to brute force them,

422
00:19:57,270 --> 00:19:58,900
but I just didn't know
enough about the math

423
00:19:58,900 --> 00:20:00,920
of what was going on with
these symbols and the values.

424
00:20:00,920 --> 00:20:02,900
So I couldn't brute force them

425
00:20:02,900 --> 00:20:04,423
and I needed a smarter way.

426
00:20:07,000 --> 00:20:09,870
Then I got lucky by becoming unlucky.

427
00:20:09,870 --> 00:20:11,633
I murdered a badge.

428
00:20:12,510 --> 00:20:13,790
It got really angry.

429
00:20:13,790 --> 00:20:16,220
It started transmitting a weird pattern.

430
00:20:16,220 --> 00:20:18,940
Instead of 110 symbol packets,

431
00:20:18,940 --> 00:20:21,833
it was doing 108 symbols and 108 nulls.

432
00:20:25,070 --> 00:20:26,620
Transmitted a different frequency

433
00:20:26,620 --> 00:20:28,150
and even weirder,

434
00:20:28,150 --> 00:20:31,490
the counter slid over by four bytes.

435
00:20:31,490 --> 00:20:35,210
So now instead of counting
at byte zero through three,

436
00:20:35,210 --> 00:20:37,663
it was counting at four through seven.

437
00:20:38,780 --> 00:20:42,730
And I assumed initially that it set those

438
00:20:42,730 --> 00:20:45,758
first four bytes to all zero,

439
00:20:45,758 --> 00:20:50,280
but by watching it count the upper bytes

440
00:20:50,280 --> 00:20:53,360
that let me figure out, well,

441
00:20:53,360 --> 00:20:58,360
let me confirm the mask
for the length byte

442
00:21:00,261 --> 00:21:03,870
and helped me to do some
other bytes as well.

443
00:21:03,870 --> 00:21:08,870
So I finally got the mask
of the first five bytes.

444
00:21:09,550 --> 00:21:14,410
Though, at least assuming
my 0/1 guess was correct,

445
00:21:14,410 --> 00:21:16,840
it was odd or even that
it was starting with.

446
00:21:16,840 --> 00:21:19,240
So sometimes it's better
to be lucky than smart.

447
00:21:22,530 --> 00:21:25,190
So I finished this up.

448
00:21:25,190 --> 00:21:27,890
We'll kind of fast forward
to the future a little bit.

449
00:21:28,857 --> 00:21:31,970
But I later on discovered
that whenever you update

450
00:21:31,970 --> 00:21:34,500
the transmission badge or the packet

451
00:21:34,500 --> 00:21:37,803
that the badge transmits to other badges,

452
00:21:39,120 --> 00:21:42,520
it makes the counter count
whatever it's counting

453
00:21:42,520 --> 00:21:46,750
count super fast, almost 250,000.

454
00:21:46,750 --> 00:21:49,340
So I wrote a script to count
over and over and over,

455
00:21:49,340 --> 00:21:52,850
and that advanced all
the bytes of the counter,

456
00:21:52,850 --> 00:21:57,713
which let me confirm more mask bits.

457
00:21:58,730 --> 00:22:03,320
It also let me confirm that
my initial guess was zero.

458
00:22:03,320 --> 00:22:06,480
Well that, and the some
erratic counting later on

459
00:22:06,480 --> 00:22:10,660
in the future when I was
decoding the sequential count.

460
00:22:10,660 --> 00:22:11,850
What should be sequential,

461
00:22:11,850 --> 00:22:12,950
wasn't always sequential.

462
00:22:12,950 --> 00:22:17,570
It was bouncing around by
eight or 32 and here and there.

463
00:22:17,570 --> 00:22:20,193
And I realized cause my
initial guess was wrong.

464
00:22:21,625 --> 00:22:23,940
So what I found above as a mask

465
00:22:23,940 --> 00:22:26,393
was actually the mask
for the value of one.

466
00:22:27,948 --> 00:22:29,940
It was really a mask of zero,

467
00:22:29,940 --> 00:22:31,970
but that also means that
when I broke that badge,

468
00:22:31,970 --> 00:22:33,490
instead of all the bytes being zero,

469
00:22:33,490 --> 00:22:36,830
it was also started at
one, which is weird.

470
00:22:36,830 --> 00:22:38,773
I don't know what that means.

471
00:22:41,010 --> 00:22:43,100
Next I need to find the checksum mask,

472
00:22:43,100 --> 00:22:46,920
but really there's no way I
could figure that out right now.

473
00:22:46,920 --> 00:22:51,030
All I can do is, at least until
I figure out the algorithm,

474
00:22:51,030 --> 00:22:52,350
and then figure out the data

475
00:22:52,350 --> 00:22:55,720
and then figure out
which part of the packet

476
00:22:55,720 --> 00:22:57,230
that the algorithm actually protects.

477
00:22:57,230 --> 00:22:58,730
Like, does it predict the preamble or not?

478
00:22:58,730 --> 00:23:01,040
You know, so basically I just guessed

479
00:23:01,040 --> 00:23:05,130
by picking symbols that are
already seen in the packet

480
00:23:05,130 --> 00:23:09,883
called that zero, or just
whatever, and moved on.

481
00:23:12,500 --> 00:23:14,380
So one thing that the counter indicated

482
00:23:14,380 --> 00:23:17,613
was a convolution code is being used.

483
00:23:18,530 --> 00:23:22,410
So for every odd bit that's changed,

484
00:23:22,410 --> 00:23:24,657
whereas we're defining an odd bit as

485
00:23:24,657 --> 00:23:28,220
a bit one with LSB being bit zero.

486
00:23:28,220 --> 00:23:29,850
So if that one, that three, that five,

487
00:23:29,850 --> 00:23:31,070
if any of those change

488
00:23:31,940 --> 00:23:36,023
only a single symbol is changed.

489
00:23:36,920 --> 00:23:38,490
But if an even bit has changed,

490
00:23:38,490 --> 00:23:40,940
then six of the next
seven bits are changed

491
00:23:40,940 --> 00:23:43,440
or symbols are changed.

492
00:23:43,440 --> 00:23:46,910
Now that pattern looked suspiciously like

493
00:23:46,910 --> 00:23:50,460
the one used by the Voyager space probe.

494
00:23:50,460 --> 00:23:51,930
I don't know if that's coincidence

495
00:23:51,930 --> 00:23:55,770
or if that's somehow they've
been adapted to use this

496
00:23:55,770 --> 00:23:59,070
into the the badge transmission.

497
00:23:59,070 --> 00:24:01,070
I haven't figured that part out yet.

498
00:24:01,070 --> 00:24:04,050
It's also that only half of
the bits are being protected

499
00:24:04,050 --> 00:24:05,140
because normally you'd want to

500
00:24:05,140 --> 00:24:06,810
protect all the bits from noise

501
00:24:06,810 --> 00:24:08,910
only having half doesn't do you much good.

502
00:24:11,070 --> 00:24:12,730
So to reverse engineer this,

503
00:24:12,730 --> 00:24:15,630
I started by changing
just one bit at a time.

504
00:24:15,630 --> 00:24:17,657
Whenever you change one odd bit,

505
00:24:17,657 --> 00:24:19,470
that would just change one symbol.

506
00:24:19,470 --> 00:24:22,310
And it always adds four to the symbol.

507
00:24:22,310 --> 00:24:23,750
If you change one even bit,

508
00:24:23,750 --> 00:24:26,010
then six of the next seven symbols change,

509
00:24:26,010 --> 00:24:30,097
and in a pattern that
depended on how far away

510
00:24:30,097 --> 00:24:33,350
that symbol was from the
bit that was changed,

511
00:24:33,350 --> 00:24:36,850
and based on the zero mask

512
00:24:36,850 --> 00:24:39,313
that was used at that location.

513
00:24:41,050 --> 00:24:42,857
So I figured out the pattern

514
00:24:42,857 --> 00:24:47,190
through just a lot of making examples

515
00:24:47,190 --> 00:24:48,690
and taking lots of notes

516
00:24:48,690 --> 00:24:50,393
and making crazy Excel sheets,

517
00:24:51,700 --> 00:24:53,490
and finally figured out the math

518
00:24:53,490 --> 00:24:57,620
of how a mask changes
each bit at each position.

519
00:24:57,620 --> 00:25:00,780
I've listed it by the symbol positions

520
00:25:00,780 --> 00:25:04,390
and then also listed it twice in two ways.

521
00:25:04,390 --> 00:25:06,250
One, is the code,

522
00:25:06,250 --> 00:25:09,080
basically Python code
of where the mask is,

523
00:25:09,080 --> 00:25:10,440
like what values the mask is.

524
00:25:10,440 --> 00:25:14,770
And then if that mask
exists in that position,

525
00:25:14,770 --> 00:25:18,940
like say mask is in
one, two, five, or six.

526
00:25:18,940 --> 00:25:22,003
So if it isn't, that's a
one times four plus two.

527
00:25:23,410 --> 00:25:26,330
And as a more lower-level
electrical engineer

528
00:25:26,330 --> 00:25:27,450
sort of way to think about it,

529
00:25:27,450 --> 00:25:30,830
I also put it as an array of bits.

530
00:25:30,830 --> 00:25:33,020
So you can look at the bitmap

531
00:25:33,020 --> 00:25:34,750
and possibly that could be related

532
00:25:34,750 --> 00:25:35,770
to the Voyager probe,

533
00:25:35,770 --> 00:25:37,693
but we'll worry about that later.

534
00:25:40,970 --> 00:25:43,570
So that figured out for a single bit,

535
00:25:43,570 --> 00:25:47,090
but once you start using two bits

536
00:25:47,090 --> 00:25:49,320
or changing two bits at a time,

537
00:25:49,320 --> 00:25:52,690
then the math gets really ugly again.

538
00:25:52,690 --> 00:25:53,940
And it just goes crazy.

539
00:25:53,940 --> 00:25:57,160
I tried coming up with
really complicated algorithms

540
00:25:57,160 --> 00:25:58,720
to figure it all out,

541
00:25:58,720 --> 00:26:00,270
but I eventually realized, well,

542
00:26:00,270 --> 00:26:01,670
why instead of doing that,

543
00:26:01,670 --> 00:26:05,900
let me just treat
everything as just a mask.

544
00:26:05,900 --> 00:26:10,210
Every sum of every step is
the mask of the next step.

545
00:26:10,210 --> 00:26:12,420
And made seven different steps like that,

546
00:26:12,420 --> 00:26:13,520
and it all worked out.

547
00:26:15,490 --> 00:26:17,653
So here it is stepping through that.

548
00:26:20,380 --> 00:26:21,750
You start off with the mask

549
00:26:21,750 --> 00:26:26,750
and then you follow those rules
from an earlier to change.

550
00:26:27,500 --> 00:26:30,573
If a bit changes, then you add, say, six.

551
00:26:32,230 --> 00:26:33,063
Compute the sum.

552
00:26:33,063 --> 00:26:36,320
That sum becomes the mask
for the next little row

553
00:26:36,320 --> 00:26:38,010
or the next, the next, the next.

554
00:26:38,010 --> 00:26:40,620
So that rule of course
doesn't make any difference

555
00:26:40,620 --> 00:26:41,700
if you're only changing one bit,

556
00:26:41,700 --> 00:26:43,890
but when you're changing two bits,

557
00:26:43,890 --> 00:26:46,770
say, the mask is three, position zero,

558
00:26:46,770 --> 00:26:47,880
you add three plus two,

559
00:26:47,880 --> 00:26:48,900
you get the sum of five.

560
00:26:48,900 --> 00:26:50,470
Now you use five as the mask

561
00:26:50,470 --> 00:26:53,610
for the next bit down, on and on.

562
00:26:53,610 --> 00:26:55,403
And it actually worked.

563
00:26:57,940 --> 00:27:01,940
Except when I started
decoding the counter,

564
00:27:01,940 --> 00:27:04,340
it didn't always count sequentially.

565
00:27:04,340 --> 00:27:05,360
It did most of the time,

566
00:27:05,360 --> 00:27:06,670
but every now and then it would freak out

567
00:27:06,670 --> 00:27:08,370
and then go back to working again.

568
00:27:09,600 --> 00:27:13,304
And I realized that sometimes
odd bits are involved

569
00:27:13,304 --> 00:27:17,023
when it's multiple odd bits
that have been flipped,

570
00:27:19,050 --> 00:27:20,687
but there wasn't much
rhyme or reason to it.

571
00:27:20,687 --> 00:27:22,630
I just started looking for patterns.

572
00:27:22,630 --> 00:27:25,260
And any time I found a pattern that worked

573
00:27:25,260 --> 00:27:27,490
for a lot of the problems,

574
00:27:27,490 --> 00:27:29,623
I would code that pattern up.

575
00:27:30,550 --> 00:27:31,610
That would solve most of them.

576
00:27:31,610 --> 00:27:33,470
But then a few more would slip through.

577
00:27:33,470 --> 00:27:34,610
Just did that a few times

578
00:27:34,610 --> 00:27:36,360
and ended up with these four rules.

579
00:27:37,290 --> 00:27:38,520
All of the rules are interesting

580
00:27:38,520 --> 00:27:41,080
in that they don't care
what the current bit is.

581
00:27:41,080 --> 00:27:43,083
They only look at previous bits.

582
00:27:44,804 --> 00:27:48,370
Two of the rules care if
previous bits were zero,

583
00:27:48,370 --> 00:27:51,650
instead of one, all those
X's are the "don't cares",

584
00:27:51,650 --> 00:27:54,700
and you can see the rules
are mostly "don't cares",

585
00:27:54,700 --> 00:27:57,240
but now we know the answer that

586
00:27:57,240 --> 00:27:58,910
all the bits have some sort of

587
00:27:58,910 --> 00:28:00,710
convolution code of protecting them.

588
00:28:03,260 --> 00:28:06,830
The first convolution
code that we saw earlier,

589
00:28:06,830 --> 00:28:08,630
it could be that Voyager code,

590
00:28:08,630 --> 00:28:10,150
could be a trials code modulation.

591
00:28:10,150 --> 00:28:12,580
I don't know if that's actually possible,

592
00:28:12,580 --> 00:28:14,073
but I won't go into that.

593
00:28:15,090 --> 00:28:19,160
And then the other compilation
code is I have no idea.

594
00:28:19,160 --> 00:28:22,420
I made that little circuit
diagram for how I think it works,

595
00:28:22,420 --> 00:28:24,920
but other than that, I didn't recognize it

596
00:28:24,920 --> 00:28:26,470
in anything I looked up online.

597
00:28:29,720 --> 00:28:32,023
So now I need to reverse engineer the CRC.

598
00:28:34,780 --> 00:28:37,993
And early on, I noticed that each packet,

599
00:28:39,108 --> 00:28:42,160
or the CRC has a possibility to contain

600
00:28:42,160 --> 00:28:46,800
basically 20 bits of
data in those 10 symbols.

601
00:28:46,800 --> 00:28:50,560
But when I count it up,

602
00:28:50,560 --> 00:28:52,660
the number of patterns
that actually showed up,

603
00:28:52,660 --> 00:28:55,980
it was only two of the
12 or 4096 patterns.

604
00:28:55,980 --> 00:29:00,560
So that was telling me it was
storing 12 bits in 20 bits,

605
00:29:00,560 --> 00:29:02,430
which was strange.

606
00:29:02,430 --> 00:29:03,570
And then there was also the issue

607
00:29:03,570 --> 00:29:06,640
that when you change a bit,

608
00:29:06,640 --> 00:29:09,920
you can have a tail of up
to six changes behind it.

609
00:29:09,920 --> 00:29:13,400
And won't that tail of changes overwrite

610
00:29:13,400 --> 00:29:15,800
the nulls and primers
completely destroy the packets?

611
00:29:15,800 --> 00:29:18,663
So something, something
odd was going on here.

612
00:29:20,110 --> 00:29:24,640
I also confirmed that all of
those symbols had to be used

613
00:29:24,640 --> 00:29:26,970
because if you try changing any of them,

614
00:29:26,970 --> 00:29:28,340
then the packet was rejected.

615
00:29:28,340 --> 00:29:31,320
So clearly all those
symbols were being checked.

616
00:29:31,320 --> 00:29:34,313
So they all were important
in one way or the other.

617
00:29:36,160 --> 00:29:39,470
And so I need to reverse engineer the CRC

618
00:29:39,470 --> 00:29:42,340
if I ever wanted to send
my own custom packets.

619
00:29:42,340 --> 00:29:45,100
I tried this tool called CRC Reveng,

620
00:29:45,100 --> 00:29:47,590
and it just didn't seem to work at all

621
00:29:47,590 --> 00:29:49,510
on the values I was pulling out.

622
00:29:49,510 --> 00:29:50,940
So I said, fine, screw it.

623
00:29:50,940 --> 00:29:52,350
I'll just write a Python program

624
00:29:52,350 --> 00:29:55,600
and brute force every
possible CRC algorithm.

625
00:29:55,600 --> 00:29:57,390
And that didn't work either.

626
00:29:57,390 --> 00:29:59,623
So something really odd was going on.

627
00:30:02,660 --> 00:30:05,860
While looking through the CRC values

628
00:30:05,860 --> 00:30:08,660
of a bunch of packets in sequential order,

629
00:30:08,660 --> 00:30:12,210
I noticed that the check sum was changing

630
00:30:12,210 --> 00:30:13,730
by a predictable amount.

631
00:30:13,730 --> 00:30:17,210
Like every time, just
the lowest bit changed,

632
00:30:17,210 --> 00:30:22,210
it was XORing the checksum
value by the same amount.

633
00:30:22,520 --> 00:30:25,950
Which told me that the checksum

634
00:30:27,900 --> 00:30:30,880
was being built up by XOR
probably from a table,

635
00:30:30,880 --> 00:30:33,110
just like a CRC.

636
00:30:33,110 --> 00:30:35,430
And I poked through that some more,

637
00:30:35,430 --> 00:30:37,080
eventually found a pattern to it.

638
00:30:38,580 --> 00:30:39,830
But in the beginning,

639
00:30:39,830 --> 00:30:44,050
what I did was I used
all the counter values

640
00:30:44,050 --> 00:30:46,592
to find where it just a single bit

641
00:30:46,592 --> 00:30:48,340
changed between two packets,

642
00:30:48,340 --> 00:30:50,748
XORed those packets,

643
00:30:50,748 --> 00:30:53,667
or XORed the CRCs from those.

644
00:30:53,667 --> 00:30:55,550
And that gave me the XOR value

645
00:30:55,550 --> 00:30:57,540
for that single bit change.

646
00:30:57,540 --> 00:31:00,020
Did that for all the counter bits.

647
00:31:00,020 --> 00:31:02,800
Did that for a few of the length a byte.

648
00:31:07,930 --> 00:31:09,220
Couldn't really do it for all the counter

649
00:31:09,220 --> 00:31:11,460
because even the high counter values

650
00:31:11,460 --> 00:31:14,330
would take months to flip through.

651
00:31:14,330 --> 00:31:16,560
But since I had realized that
when you update a packet,

652
00:31:16,560 --> 00:31:20,420
it fast forwards it by
some 350,000 clicks.

653
00:31:20,420 --> 00:31:22,230
So I wrote a program to speed it through

654
00:31:22,230 --> 00:31:24,120
a whole lot of those bits.

655
00:31:24,120 --> 00:31:26,650
And then I wrote another
program to do a bit walk,

656
00:31:26,650 --> 00:31:30,380
basically change one
bit in every data byte

657
00:31:30,380 --> 00:31:34,730
and walk that back and forth
through all the data bytes.

658
00:31:34,730 --> 00:31:36,950
And then I wrote a cute little program

659
00:31:36,950 --> 00:31:40,963
to adjust all of those and
build up the CRC table.

660
00:31:44,830 --> 00:31:49,830
Now that I had most of the
CRC table values for each bit,

661
00:31:50,019 --> 00:31:52,650
I was looking through the changes in them

662
00:31:52,650 --> 00:31:55,100
and noticed a couple of patterns.

663
00:31:55,100 --> 00:31:58,930
And the first was a pattern
in how the actual data bits

664
00:31:58,930 --> 00:32:01,363
are stored into those symbols.

665
00:32:02,330 --> 00:32:06,450
And it's kind of ingenious
the way they're spread out.

666
00:32:06,450 --> 00:32:10,690
So the first four symbols holds,

667
00:32:10,690 --> 00:32:14,090
or first two symbols holds four bits.

668
00:32:14,090 --> 00:32:18,523
And the next symbol after
that holds two bits.

669
00:32:19,650 --> 00:32:24,466
So basically the way
that it spread them out,

670
00:32:24,466 --> 00:32:26,010
where the even bits are used

671
00:32:26,010 --> 00:32:29,240
in only the first three symbols,

672
00:32:29,240 --> 00:32:31,498
those even bits, since they have a tail

673
00:32:31,498 --> 00:32:33,640
that can be six long,

674
00:32:33,640 --> 00:32:38,640
that tail doesn't extend
the past the end of the CRC.

675
00:32:39,030 --> 00:32:41,890
So it doesn't overwrite the nulls

676
00:32:41,890 --> 00:32:43,460
or anything like that.

677
00:32:43,460 --> 00:32:47,770
So basically it used mostly the odd bits

678
00:32:47,770 --> 00:32:51,540
to store bits from the CRC

679
00:32:51,540 --> 00:32:53,600
and just a few of those even bits.

680
00:32:53,600 --> 00:32:55,623
And it all fit.

681
00:32:57,960 --> 00:33:02,200
And then for just extra fun I guess,

682
00:33:02,200 --> 00:33:05,990
they shuffled the order
of those bits all around.

683
00:33:05,990 --> 00:33:10,990
And that shuffling is what
made the CRC Reveng fail,

684
00:33:11,720 --> 00:33:14,430
what made my brute force tools fail.

685
00:33:14,430 --> 00:33:18,120
Once I removed the dead bits

686
00:33:18,120 --> 00:33:20,430
and rearranged the bits that actually had

687
00:33:20,430 --> 00:33:22,170
useful info in them,

688
00:33:22,170 --> 00:33:25,923
then suddenly CRC Reveng worked perfectly.

689
00:33:28,500 --> 00:33:33,290
So now I can compute the
CRC table for all 16 bytes.

690
00:33:33,290 --> 00:33:36,620
I also noticed a pattern
between the values

691
00:33:36,620 --> 00:33:38,680
for every single bit in my table,

692
00:33:38,680 --> 00:33:39,910
and used that pattern to fill up

693
00:33:39,910 --> 00:33:43,070
the rest of the symbols.

694
00:33:43,070 --> 00:33:48,070
But CRC Reveng also
showed me the exact name

695
00:33:48,140 --> 00:33:50,770
and algorithm used for the CRC.

696
00:33:50,770 --> 00:33:51,723
So that was nice.

697
00:33:53,930 --> 00:33:57,013
So now my original guess for the mask,

698
00:33:58,190 --> 00:33:59,550
I knew it was wrong in the beginning

699
00:33:59,550 --> 00:34:01,513
for the CRC zero mask,

700
00:34:02,440 --> 00:34:03,330
but it worked anyway.

701
00:34:03,330 --> 00:34:05,990
Cause basically since a
CRC is built up by XORs

702
00:34:05,990 --> 00:34:10,990
and it was basically XORing my bad mask,

703
00:34:11,070 --> 00:34:13,800
which had my bad base value,

704
00:34:13,800 --> 00:34:16,070
and all those XORs were canceling out.

705
00:34:16,070 --> 00:34:17,460
And it worked most of the time,

706
00:34:17,460 --> 00:34:18,850
but it was flaky.

707
00:34:18,850 --> 00:34:20,570
Probably because of those three bits

708
00:34:20,570 --> 00:34:22,737
that had tails that weren't quite XORs,

709
00:34:22,737 --> 00:34:25,090
the way the tails change.

710
00:34:25,090 --> 00:34:27,560
So once I figured out the new mask,

711
00:34:27,560 --> 00:34:29,380
everything worked like rock solid.

712
00:34:29,380 --> 00:34:30,353
It was beautiful.

713
00:34:32,510 --> 00:34:34,910
I think the CRC doesn't
protect the preamble.

714
00:34:34,910 --> 00:34:37,590
I think it's only covering the data.

715
00:34:37,590 --> 00:34:40,450
I tried coming up with counterexamples.

716
00:34:40,450 --> 00:34:42,970
I tried making a ton of different packets

717
00:34:43,900 --> 00:34:45,300
with using different preambles

718
00:34:45,300 --> 00:34:47,720
and testing all possible CRC values,

719
00:34:47,720 --> 00:34:50,150
and couldn't make any
other preambles work.

720
00:34:50,150 --> 00:34:52,293
So that's just an unknown.

721
00:34:53,450 --> 00:34:55,630
Also, I basically went with the assumption

722
00:34:55,630 --> 00:34:58,110
that the CRC of those 16 bytes,

723
00:34:58,110 --> 00:34:59,630
if they were all zero,

724
00:34:59,630 --> 00:35:02,200
that the end result would be zero.

725
00:35:02,200 --> 00:35:04,380
Cause that's how CRCs work,

726
00:35:04,380 --> 00:35:07,060
and based my mask off that,

727
00:35:07,060 --> 00:35:07,993
and it worked.

728
00:35:10,330 --> 00:35:13,973
So with that, I can finally
craft my own packets.

729
00:35:14,925 --> 00:35:16,750
So those will be released on GitHub

730
00:35:16,750 --> 00:35:18,200
If they haven't been already.

731
00:35:20,570 --> 00:35:24,660
I can now basically make any
16-byte packet that I want,

732
00:35:24,660 --> 00:35:27,050
except I need a 36-byte packet

733
00:35:27,050 --> 00:35:29,090
in order to overflow the badge

734
00:35:29,090 --> 00:35:31,913
and possibly even more
to do any cool attack.

735
00:35:33,248 --> 00:35:34,081
I knew this from the start.

736
00:35:34,081 --> 00:35:37,328
I just assumed that would
fall into place along the way,

737
00:35:37,328 --> 00:35:38,960
but it didn't happen.

738
00:35:38,960 --> 00:35:40,420
Never found a field in the packet

739
00:35:40,420 --> 00:35:43,033
that actually let me set
a longer packet length.

740
00:35:44,200 --> 00:35:46,510
Skirting around the preamble didn't work.

741
00:35:46,510 --> 00:35:49,120
So it was time to try
and reverse engineering

742
00:35:49,120 --> 00:35:50,853
the NFMI firmware.

743
00:35:52,710 --> 00:35:55,500
To extract the NFMI firmware,

744
00:35:55,500 --> 00:35:57,380
I needed to run SWD,

745
00:35:57,380 --> 00:35:58,880
and to do that,

746
00:35:58,880 --> 00:36:00,980
I needed to be able to
access the reset line,

747
00:36:00,980 --> 00:36:04,010
which unfortunately was
buried in the middle layer

748
00:36:04,010 --> 00:36:04,963
of the board.

749
00:36:05,960 --> 00:36:07,590
The ball on the ball grid array

750
00:36:07,590 --> 00:36:08,470
on the bottom of the chip

751
00:36:08,470 --> 00:36:10,500
also was not accessible.

752
00:36:10,500 --> 00:36:13,428
So I had to pick through slides

753
00:36:13,428 --> 00:36:16,310
and other info from the presentation.

754
00:36:16,310 --> 00:36:19,203
I figured out which
ball on the grid it was,

755
00:36:20,210 --> 00:36:25,090
and then zoomed in really
close on some of the slides

756
00:36:25,090 --> 00:36:27,960
that didn't have the,

757
00:36:27,960 --> 00:36:30,797
so that middle image it's from the slide.

758
00:36:30,797 --> 00:36:32,470
That's the circuit board

759
00:36:32,470 --> 00:36:33,980
before it has the white paint on it.

760
00:36:33,980 --> 00:36:36,870
So you can kind of see
the middle traces faintly

761
00:36:36,870 --> 00:36:38,820
in the middle of the board.

762
00:36:38,820 --> 00:36:41,220
Also with one of my badges,

763
00:36:41,220 --> 00:36:42,610
I scraped all the white paint off

764
00:36:42,610 --> 00:36:47,540
and I cut through the
bottom layer of the badge

765
00:36:47,540 --> 00:36:51,020
to remove the metal ground plane

766
00:36:51,020 --> 00:36:53,830
and was able to shine light through it.

767
00:36:53,830 --> 00:36:56,030
And then eventually Joe Grant
actually was nice enough

768
00:36:56,030 --> 00:36:59,330
to send me some schematics
that showed exactly

769
00:36:59,330 --> 00:37:02,330
where the resets lines
were just to confirm,

770
00:37:02,330 --> 00:37:05,730
but that helped me find the reset line.

771
00:37:05,730 --> 00:37:07,670
Now I need to connect to it.

772
00:37:07,670 --> 00:37:09,240
So as you can see the top,

773
00:37:09,240 --> 00:37:13,020
I had to scrape the paint off
and the top layer of the board

774
00:37:13,020 --> 00:37:15,820
to get down to that
middle layer of the board.

775
00:37:15,820 --> 00:37:19,090
Kind of made like a
little C of flux on it,

776
00:37:19,090 --> 00:37:22,470
based on a video I watched
of repairing iPhones.

777
00:37:22,470 --> 00:37:24,140
So we'll see a flux

778
00:37:24,140 --> 00:37:26,600
and it was after a few tries

779
00:37:26,600 --> 00:37:29,820
I was able to solder
a wire onto this trace

780
00:37:29,820 --> 00:37:32,760
that was smaller than a human hair.

781
00:37:32,760 --> 00:37:34,480
I think this didn't actually work though.

782
00:37:34,480 --> 00:37:37,800
I think I had to go back
and actually cut the trace

783
00:37:37,800 --> 00:37:40,440
and then do it again because the MCU

784
00:37:40,440 --> 00:37:42,510
was still connected to the reset

785
00:37:42,510 --> 00:37:44,140
and was like changing the reset

786
00:37:44,140 --> 00:37:45,090
while I was trying to change it

787
00:37:45,090 --> 00:37:47,160
with the SWD commands.

788
00:37:47,160 --> 00:37:49,860
So I think, I don't know.

789
00:37:49,860 --> 00:37:51,450
I think that second uglier image

790
00:37:51,450 --> 00:37:53,320
onto the right of the soldering

791
00:37:53,320 --> 00:37:54,893
is the second time I did it.

792
00:37:56,280 --> 00:37:58,530
And so I was able to connect to it,

793
00:37:58,530 --> 00:38:01,970
but when I hooked the J-Link up to it,

794
00:38:01,970 --> 00:38:05,970
the SWD could not communicate with it.

795
00:38:05,970 --> 00:38:07,490
Cause I didn't know what
kind of chip it was.

796
00:38:07,490 --> 00:38:11,670
I was guessing different cortex
chips and nothing worked.

797
00:38:11,670 --> 00:38:13,220
I thought, well, maybe you need pull ups,

798
00:38:13,220 --> 00:38:16,210
maybe you need pull downs,
maybe there's noise.

799
00:38:16,210 --> 00:38:17,590
Maybe I need to go slower.

800
00:38:17,590 --> 00:38:18,810
I tried everything.

801
00:38:18,810 --> 00:38:21,490
I tried going at like one kilohertz

802
00:38:21,490 --> 00:38:22,710
and nothing was working.

803
00:38:22,710 --> 00:38:25,390
So finally out of desperation

804
00:38:25,390 --> 00:38:30,390
I just started randomly
trying the default settings

805
00:38:30,760 --> 00:38:32,380
for a whole bunch of different chips

806
00:38:32,380 --> 00:38:35,540
that were related or
even kind of unrelated.

807
00:38:35,540 --> 00:38:37,980
And then one of them just worked.

808
00:38:37,980 --> 00:38:39,780
So I quickly downloaded

809
00:38:39,780 --> 00:38:41,260
the entire memory space I could,

810
00:38:41,260 --> 00:38:43,873
which was a zero to 18000.

811
00:38:46,420 --> 00:38:51,420
and realized at that
point, because I guess,

812
00:38:53,070 --> 00:38:53,903
I don't know,

813
00:38:53,903 --> 00:38:55,070
either screwing around earlier

814
00:38:55,070 --> 00:38:57,040
with the reset line being
connected to two things

815
00:38:57,040 --> 00:38:58,173
or maybe cutting it,

816
00:38:59,090 --> 00:39:01,330
or maybe just based on
the way it boots up,

817
00:39:01,330 --> 00:39:05,360
but whatever little snippet
that the MCU firmware

818
00:39:05,360 --> 00:39:08,890
sends over to the NFMI chip, wasn't there.

819
00:39:08,890 --> 00:39:12,000
So the protocol was missing,

820
00:39:12,000 --> 00:39:15,880
but at least I got all of
the other hidden stuff.

821
00:39:15,880 --> 00:39:19,820
Because the protocol only
makes up like a few hundred,

822
00:39:19,820 --> 00:39:21,380
maybe thousand bytes.

823
00:39:21,380 --> 00:39:22,470
And I got a whole lot more than that

824
00:39:22,470 --> 00:39:24,520
in all those hidden functions and stuff.

825
00:39:24,520 --> 00:39:25,770
So that was very helpful.

826
00:39:28,360 --> 00:39:33,360
So I pulled the NFMI protocol
bit out of the MC firmware,

827
00:39:35,548 --> 00:39:37,330
figured out the base address

828
00:39:37,330 --> 00:39:38,600
of the different pieces of it,

829
00:39:38,600 --> 00:39:41,640
and plopped that into the
binary I just pulled out,

830
00:39:41,640 --> 00:39:45,450
that 18,000 binary.

831
00:39:45,450 --> 00:39:47,493
And stuck that into IDA Pro.

832
00:39:48,660 --> 00:39:50,800
Once again, I couldn't
find anything indicating

833
00:39:50,800 --> 00:39:53,590
a packet length field
or anything like that.

834
00:39:53,590 --> 00:39:56,180
And I also confirmed there's
code that actually checks

835
00:39:56,180 --> 00:39:57,790
to make sure you're not claiming

836
00:39:57,790 --> 00:40:00,020
to send more than 11 bytes.

837
00:40:00,020 --> 00:40:01,850
And fast forward to the future,

838
00:40:01,850 --> 00:40:03,640
I was able to remove that at one point,

839
00:40:03,640 --> 00:40:05,950
but it doesn't do me any good

840
00:40:05,950 --> 00:40:08,310
cause I can't send more
than actually 11 bytes.

841
00:40:08,310 --> 00:40:09,962
So if I fake it,

842
00:40:09,962 --> 00:40:11,540
it'll try outputting it.

843
00:40:11,540 --> 00:40:13,037
But it's outputting like zeroes

844
00:40:13,037 --> 00:40:14,160
and uninitialized garbage

845
00:40:14,160 --> 00:40:15,723
and it wasn't helpful.

846
00:40:17,290 --> 00:40:21,980
But I had seen oversize
packets happen before.

847
00:40:21,980 --> 00:40:23,650
I'd even logged them,

848
00:40:23,650 --> 00:40:25,250
as you can see in that log down there.

849
00:40:25,250 --> 00:40:28,160
I'd hacked a badge firmware to spit out

850
00:40:28,160 --> 00:40:31,560
every byte it received and the length.

851
00:40:31,560 --> 00:40:34,210
And after a bazillion length 22s,

852
00:40:34,210 --> 00:40:36,380
I got a length 52 and then it crashed.

853
00:40:36,380 --> 00:40:38,890
It said "Welcome to DefCon" again.

854
00:40:38,890 --> 00:40:43,870
So obviously it's happened
spontaneously in the wild.

855
00:40:43,870 --> 00:40:47,607
Why, how, how, why, how
do I make that happen?

856
00:40:50,850 --> 00:40:54,633
Well, I was saved by some more
bugs in the badge firmware.

857
00:40:56,630 --> 00:41:01,100
So when the NFMI chip sends a packet

858
00:41:01,100 --> 00:41:03,720
over the UART and it's all padded out,

859
00:41:03,720 --> 00:41:05,200
the badge receives it.

860
00:41:05,200 --> 00:41:10,100
But instead of trying to copy
the entire packet off of UART,

861
00:41:10,100 --> 00:41:12,740
it just copies one at a time.

862
00:41:12,740 --> 00:41:17,100
So that alone allows a
partial packet to be copied

863
00:41:17,100 --> 00:41:19,260
if it runs out of space.

864
00:41:19,260 --> 00:41:21,580
And then there was also
this off by one error

865
00:41:21,580 --> 00:41:25,200
where it seemed to make
sure there was always

866
00:41:25,200 --> 00:41:27,630
one more spot free.

867
00:41:27,630 --> 00:41:29,540
So basically it's checking
for two bytes free

868
00:41:29,540 --> 00:41:30,913
before copying one byte.

869
00:41:31,890 --> 00:41:36,890
And that allowed an odd
number or odd-sized packet,

870
00:41:37,140 --> 00:41:38,830
which was nice because
it would just chop off

871
00:41:38,830 --> 00:41:42,730
just the 'E' at the end and leave my 'B'

872
00:41:42,730 --> 00:41:46,090
followed by however many
bytes of data I had on there.

873
00:41:46,090 --> 00:41:48,290
So then later on,

874
00:41:48,290 --> 00:41:52,370
when the badge actually tries
to use that packet data,

875
00:41:52,370 --> 00:41:53,940
it starts with the reading at the 'B',

876
00:41:53,940 --> 00:41:56,660
and it keeps on reading
until finds an 'E'.

877
00:41:56,660 --> 00:41:58,650
So with these errors,

878
00:41:58,650 --> 00:42:00,650
I was able to send a 'B'

879
00:42:00,650 --> 00:42:03,280
and then 16 bytes of padded data

880
00:42:03,280 --> 00:42:04,817
and then no 'E'.

881
00:42:06,440 --> 00:42:09,690
I can completely fill up the ring buffer

882
00:42:09,690 --> 00:42:12,100
by just sending a whole bunch of these.

883
00:42:12,100 --> 00:42:14,127
And then I tell the batch to read.

884
00:42:14,127 --> 00:42:16,040
And the moment it reads the first one,

885
00:42:16,040 --> 00:42:19,820
now it's freed up 18 more bytes.

886
00:42:19,820 --> 00:42:23,610
So as long as I'm still
blasting these packets,

887
00:42:23,610 --> 00:42:26,060
it will now write a second
packet into that hole.

888
00:42:27,522 --> 00:42:30,020
And then the badge will
keep on reading everything.

889
00:42:30,020 --> 00:42:32,580
And when it gets to that
last packet, it sees a 'B',

890
00:42:32,580 --> 00:42:35,053
and then 16 bytes of these like,

891
00:42:35,053 --> 00:42:37,500
16 of these padded nibbles,

892
00:42:37,500 --> 00:42:40,830
and then another 'B', and then
another 16, and then an 'E'.

893
00:42:40,830 --> 00:42:45,563
So as far as it's concerned,
it just saw a 33 byte packet.

894
00:42:48,900 --> 00:42:50,260
But wait, there's more.

895
00:42:50,260 --> 00:42:54,600
So if you keep hammering that even more,

896
00:42:54,600 --> 00:42:58,620
it's possible to say on even
like the max size 11 bytes,

897
00:42:58,620 --> 00:43:01,430
which ends up being 22
of these padded nibbles.

898
00:43:01,430 --> 00:43:03,120
So I can sound like a B22,

899
00:43:03,120 --> 00:43:05,330
and then it's that off by one error

900
00:43:05,330 --> 00:43:06,990
and chops off the 'E'.

901
00:43:06,990 --> 00:43:09,510
And then when a packet gets read,

902
00:43:09,510 --> 00:43:12,370
frees up enough space that if
I'm still writing fast enough

903
00:43:12,370 --> 00:43:16,340
or transmitting fast enough,
it can stick another B22

904
00:43:16,340 --> 00:43:18,430
in there was no room for the 'E'.

905
00:43:18,430 --> 00:43:20,970
And then since the badge is reading faster

906
00:43:20,970 --> 00:43:22,750
than I can actually transmit,

907
00:43:22,750 --> 00:43:24,760
by the time I send a third one,

908
00:43:24,760 --> 00:43:27,187
it'll be more than
enough space for that 'E'

909
00:43:27,187 --> 00:43:28,280
to fit in there too.

910
00:43:28,280 --> 00:43:31,423
But basically I have now
made up a 68-byte packet.

911
00:43:32,930 --> 00:43:34,550
And then I haven't
actually played with this,

912
00:43:34,550 --> 00:43:36,760
but I could probably even
fill the buffer first

913
00:43:36,760 --> 00:43:38,150
with like super tiny packets,

914
00:43:38,150 --> 00:43:39,760
like two byte packets,

915
00:43:39,760 --> 00:43:41,250
to make reading take much longer.

916
00:43:41,250 --> 00:43:44,510
And maybe you can stack
even more than three

917
00:43:44,510 --> 00:43:47,417
of these B22s, B22Es.

918
00:43:51,230 --> 00:43:53,770
So now I can crash a badge at will,

919
00:43:53,770 --> 00:43:55,143
a stock badge.

920
00:43:56,410 --> 00:43:59,380
This takes a long while
with a 2048-byte buffer,

921
00:43:59,380 --> 00:44:02,180
and it makes like a pretty boring demo.

922
00:44:02,180 --> 00:44:05,363
So I cheated and I made a badge

923
00:44:05,363 --> 00:44:07,883
that just has a 72-byte buffer.

924
00:44:09,419 --> 00:44:12,180
What I do is I basically
fill up the buffer

925
00:44:12,180 --> 00:44:14,750
and then I drain the buffer.

926
00:44:14,750 --> 00:44:16,500
So now that I'm like at a known state,

927
00:44:16,500 --> 00:44:18,629
then I fill the buffer again

928
00:44:18,629 --> 00:44:23,180
and keep on transmitting
while that read happens.

929
00:44:23,180 --> 00:44:25,423
And it should crash the badge.

930
00:44:27,250 --> 00:44:29,100
Here, the buffer is full.

931
00:44:29,100 --> 00:44:30,980
I'm gonna empty the buffer.

932
00:44:30,980 --> 00:44:32,910
I switched over to GNURadio

933
00:44:32,910 --> 00:44:34,490
and start playing the packets

934
00:44:34,490 --> 00:44:37,040
as fast as I possibly can.

935
00:44:37,040 --> 00:44:38,770
A little faster than
display can keep up with,

936
00:44:38,770 --> 00:44:40,320
and completely fill the buffer.

937
00:44:42,200 --> 00:44:44,900
And the video glitches up
for no apparent reason.

938
00:44:44,900 --> 00:44:47,293
And then we go over here,

939
00:44:49,830 --> 00:44:51,880
see the packets,

940
00:44:51,880 --> 00:44:52,993
and it crashes.

941
00:44:58,670 --> 00:44:59,503
The crash is neat,

942
00:44:59,503 --> 00:45:02,040
but could we do something
more interesting than that?

943
00:45:02,040 --> 00:45:04,020
Well, unfortunately
that padding gets added

944
00:45:04,020 --> 00:45:05,090
to every single packet

945
00:45:05,090 --> 00:45:06,870
and it's going to ruin any sort of attack

946
00:45:06,870 --> 00:45:09,870
that we try to send to
something more interesting

947
00:45:09,870 --> 00:45:10,773
than just crash.

948
00:45:11,790 --> 00:45:13,320
So we need to cheat.

949
00:45:13,320 --> 00:45:18,320
I found or deducted the
firmware for the NFMI chip

950
00:45:18,360 --> 00:45:20,040
and found where it pads data,

951
00:45:20,040 --> 00:45:21,490
and removed that.

952
00:45:21,490 --> 00:45:23,870
And found that 'B' and 'E' stuff also,

953
00:45:23,870 --> 00:45:24,997
and removed that.

954
00:45:24,997 --> 00:45:27,020
And we can still fake
that if we want the badges

955
00:45:27,020 --> 00:45:28,340
to talk to each other like normal,

956
00:45:28,340 --> 00:45:30,340
but now it's optional.

957
00:45:30,340 --> 00:45:33,313
I just found all that code
and replaced it with no ops.

958
00:45:35,250 --> 00:45:37,620
But to install that code into the chip,

959
00:45:37,620 --> 00:45:40,480
I had to figure out
their crazy format first,

960
00:45:40,480 --> 00:45:42,042
which was just proprietary

961
00:45:42,042 --> 00:45:45,290
and weird and slowed me down for a while.

962
00:45:45,290 --> 00:45:47,500
But once I finally got that in there,

963
00:45:47,500 --> 00:45:49,663
I was able to do a lot more fun attacks.

964
00:45:51,640 --> 00:45:54,060
Here's a freshly reboot badge.

965
00:45:54,060 --> 00:45:57,320
I switched over to GNURadio
and I play my attack.

966
00:45:57,320 --> 00:45:59,140
It takes up four packets to fit

967
00:45:59,140 --> 00:46:01,023
the entire buffer overflow attack.

968
00:46:03,920 --> 00:46:05,520
Let's get loaded into the buffer,

969
00:46:05,520 --> 00:46:06,720
switchback to the badge.

970
00:46:06,720 --> 00:46:08,740
I tell the batch to read the packets

971
00:46:09,830 --> 00:46:11,030
and it executes my code.

972
00:46:13,970 --> 00:46:16,913
I'll end with a few oddities
and mysteries that remain.

973
00:46:17,820 --> 00:46:20,960
Never quite understood
what that initial packet

974
00:46:20,960 --> 00:46:24,590
that it sends out with that 0403E045.

975
00:46:24,590 --> 00:46:27,300
At one point I convinced
myself it was a buffer address.

976
00:46:27,300 --> 00:46:29,050
I don't quite remember why anymore.

977
00:46:29,920 --> 00:46:31,880
Sometimes when it's in error,
it sends a different code.

978
00:46:31,880 --> 00:46:34,013
I don't know what those mean.

979
00:46:34,013 --> 00:46:37,620
There's also a rev strain
and another value next to it.

980
00:46:37,620 --> 00:46:39,330
And I was wondering,

981
00:46:39,330 --> 00:46:42,503
is that supposed to be a
frequency or something else?

982
00:46:45,939 --> 00:46:47,730
I was never quite sure about

983
00:46:47,730 --> 00:46:49,780
if it was truly a differential signal

984
00:46:49,780 --> 00:46:51,350
or a double differential signal,

985
00:46:51,350 --> 00:46:54,283
because the preamble
suggested it might be double.

986
00:46:55,120 --> 00:46:58,331
Never quite figured out what
the rest of the preamble meant.

987
00:46:58,331 --> 00:46:59,863
Not sure if the CRC protects it.

988
00:47:01,240 --> 00:47:03,053
Tried poking out a lot, didn't help.

989
00:47:04,620 --> 00:47:06,530
And where the heck does
that mask come from?

990
00:47:06,530 --> 00:47:08,820
I spent a lot of while working on that,

991
00:47:08,820 --> 00:47:10,210
trying to figure out its source,

992
00:47:10,210 --> 00:47:11,460
couldn't figure that out.

993
00:47:13,410 --> 00:47:15,953
And there's gotta be an easy way to stream

994
00:47:15,953 --> 00:47:17,770
or send longer packets.

995
00:47:17,770 --> 00:47:19,370
That would be fun to play with

996
00:47:19,370 --> 00:47:20,380
if I could figure that out

997
00:47:20,380 --> 00:47:22,060
or someone else could.

998
00:47:22,060 --> 00:47:24,123
And what is up with that convolution?

999
00:47:25,300 --> 00:47:26,460
Anyway, that's all.

1000
00:47:26,460 --> 00:47:28,813
Thank you very much for
watching my presentation.

