1
00:00:00,540 --> 00:00:02,750
- Hello and welcome to "HTTP two,

2
00:00:02,750 --> 00:00:04,807
The Sequel is Always Worse".

3
00:00:05,950 --> 00:00:08,700
Have you ever seen something
that was so complex,

4
00:00:08,700 --> 00:00:10,700
it just had to be hackable,

5
00:00:10,700 --> 00:00:13,103
if only you had time to understand it.

6
00:00:14,360 --> 00:00:16,820
HTTP/2 is a beautiful beast,

7
00:00:16,820 --> 00:00:19,730
but it is complex and
where there's complexity

8
00:00:19,730 --> 00:00:23,220
people take shortcuts and things go wrong.

9
00:00:23,220 --> 00:00:24,320
In this session,

10
00:00:24,320 --> 00:00:26,890
I will show you how you can
use new features in H two

11
00:00:26,890 --> 00:00:29,130
for a range of high-impact attacks.

12
00:00:29,130 --> 00:00:32,343
And also how those shed light
on a type of request modeling

13
00:00:32,343 --> 00:00:35,483
that has always existed,
but never been noticed.

14
00:00:36,670 --> 00:00:40,040
Complexity causes trouble for me too.

15
00:00:40,040 --> 00:00:42,860
I first looked at the
H two spec back in 2019

16
00:00:42,860 --> 00:00:46,630
when I was doing research for HPD syntax,

17
00:00:46,630 --> 00:00:48,050
I loaded up the spec,

18
00:00:48,050 --> 00:00:50,645
looked at the size of
the browser scroll bar

19
00:00:50,645 --> 00:00:53,810
and then proceeded to
skim read it so fast that

20
00:00:53,810 --> 00:00:57,033
I didn't even bother reading
the security considerations.

21
00:00:58,070 --> 00:01:01,410
My second encounter with H two

22
00:01:01,410 --> 00:01:02,860
was after I presented

23
00:01:02,860 --> 00:01:06,600
this research at Blackout USA,
an audience member asked me,

24
00:01:06,600 --> 00:01:10,600
did those Desync attacks
work against H two?

25
00:01:10,600 --> 00:01:13,920
And my answer was nope,
it's completely secure.

26
00:01:13,920 --> 00:01:16,390
My third encounter was the same day.

27
00:01:16,390 --> 00:01:19,040
I was at a party after a few drinks

28
00:01:19,040 --> 00:01:21,530
and someone else asked
me the same question

29
00:01:21,530 --> 00:01:23,130
and I gave them the same answer.

30
00:01:24,360 --> 00:01:28,180
And then, they proceeded
to explain to me exactly

31
00:01:28,180 --> 00:01:32,173
how you can use request
modeling to exploit HTTP two.

32
00:01:33,840 --> 00:01:36,430
And it is tricky to explain this next bit

33
00:01:36,430 --> 00:01:40,280
without coming off slightly
badly but at this point in time,

34
00:01:40,280 --> 00:01:44,720
I just spent nine months
exploiting request smuggling.

35
00:01:44,720 --> 00:01:47,960
So the prospect of immediately
diving into more request

36
00:01:47,960 --> 00:01:50,950
smuggling work didn't
exactly fill me with joy.

37
00:01:50,950 --> 00:01:54,330
And instead I just put that
idea on the shelf and went off

38
00:01:54,330 --> 00:01:57,423
and spent a year researching
web cache poisoning instead.

39
00:01:58,660 --> 00:02:00,150
One year later,

40
00:02:00,150 --> 00:02:02,870
I came back, tried the idea
out and it really worked.

41
00:02:02,870 --> 00:02:05,870
I could hack loads of
interesting servers with it.

42
00:02:05,870 --> 00:02:08,530
There was only one fly in the ointment

43
00:02:08,530 --> 00:02:11,450
and that was Bitbucket.

44
00:02:11,450 --> 00:02:14,510
Every holistic I used said that Bitbucket

45
00:02:14,510 --> 00:02:16,010
should be vulnerable,

46
00:02:16,010 --> 00:02:20,083
but every exploit that
I tried reliably failed.

47
00:02:21,070 --> 00:02:23,540
And, normally when I encounter something

48
00:02:23,540 --> 00:02:25,390
like this during research,

49
00:02:25,390 --> 00:02:28,260
I spend a bit of time on it
and then I just abandon it

50
00:02:28,260 --> 00:02:30,740
and move on, or I get stuck forever,

51
00:02:30,740 --> 00:02:33,640
but I had previously seen
this type of behavior

52
00:02:33,640 --> 00:02:36,400
when I was doing the original
desync attack research.

53
00:02:36,400 --> 00:02:41,400
And I was determined not to
let it escape me a second time.

54
00:02:42,270 --> 00:02:44,190
So, month after month,

55
00:02:44,190 --> 00:02:46,550
in between exploiting
other systems successfully,

56
00:02:46,550 --> 00:02:48,587
I kept coming back to Bitbucket

57
00:02:48,587 --> 00:02:51,010
and eventually,

58
00:02:51,010 --> 00:02:51,940
I had a breakthrough

59
00:02:51,940 --> 00:02:54,370
thanks to something that
was a complete fluke.

60
00:02:54,370 --> 00:02:56,830
I found proper evidence

61
00:02:56,830 --> 00:02:59,023
that there was definitely a vulnerability.

62
00:03:00,210 --> 00:03:02,220
However, what this didn't do

63
00:03:02,220 --> 00:03:04,720
was actually give me
something exploitable.

64
00:03:04,720 --> 00:03:08,393
So once again, I had to put
it on the shelf and move on.

65
00:03:09,310 --> 00:03:11,880
But other than that,
things went really well

66
00:03:11,880 --> 00:03:14,120
until about March.

67
00:03:14,120 --> 00:03:16,360
When Emil published the research that

68
00:03:16,360 --> 00:03:21,326
he had been doing on the same
topic as me at the same time.

69
00:03:21,326 --> 00:03:24,920
This left me in a bit of
a tricky situation because

70
00:03:24,920 --> 00:03:26,270
when I present some research,

71
00:03:26,270 --> 00:03:28,560
it has to contain some novel content,

72
00:03:28,560 --> 00:03:31,370
but all the novel content that
I was planning on presenting

73
00:03:31,370 --> 00:03:35,370
had just been presented
publicly by Emil instead.

74
00:03:35,370 --> 00:03:38,330
So I really needed something new.

75
00:03:38,330 --> 00:03:41,970
And therefore, naturally I
went back to Bitbucket again.

76
00:03:41,970 --> 00:03:45,750
And this time I finally cracked it.

77
00:03:45,750 --> 00:03:49,810
And this led to a cascade of
findings, including a new,

78
00:03:49,810 --> 00:03:53,653
more powerful type of
desynchronization core type.

79
00:03:54,620 --> 00:03:57,220
An entire class of issue
that was previously useless,

80
00:03:57,220 --> 00:04:00,140
becoming practically exploitable.

81
00:04:00,140 --> 00:04:04,670
Atlassian having to log
everybody out of Jira worldwide

82
00:04:04,670 --> 00:04:07,570
and contacting the computer
emergency response team,

83
00:04:07,570 --> 00:04:09,250
leading to further findings.

84
00:04:09,250 --> 00:04:12,453
And that last scene awarding
triple their maximum bounty.

85
00:04:14,930 --> 00:04:15,860
Out of that mess,

86
00:04:15,860 --> 00:04:17,960
I've managed to extract some information

87
00:04:17,960 --> 00:04:20,620
that I hope you'll find
really quite useful,

88
00:04:20,620 --> 00:04:23,390
regardless of whether you've
seen Emil's presentation

89
00:04:23,390 --> 00:04:25,360
already or not.

90
00:04:25,360 --> 00:04:27,580
I am not going to be
approaching these topics

91
00:04:27,580 --> 00:04:29,890
in chronological order
because looking back at it,

92
00:04:29,890 --> 00:04:32,850
it doesn't make sense even to me.

93
00:04:32,850 --> 00:04:34,390
Instead, first of all,

94
00:04:34,390 --> 00:04:36,730
I am going to show you how to use HP two

95
00:04:36,730 --> 00:04:38,600
for the quest modeling.

96
00:04:38,600 --> 00:04:42,030
Just like what I was told
in the party in Vegas.

97
00:04:42,030 --> 00:04:42,863
After that,

98
00:04:42,863 --> 00:04:44,410
I'll focus on the quest tunneling

99
00:04:44,410 --> 00:04:46,890
and show you how to confirm and exploit

100
00:04:46,890 --> 00:04:50,280
this largely overlooked
type of vulnerability.

101
00:04:50,280 --> 00:04:54,960
Then I will share four or five
new HP to exploit primitives.

102
00:04:54,960 --> 00:04:58,120
And finally, I'll cover some
practical considerations,

103
00:04:58,120 --> 00:05:01,600
such as common pitfalls
and share some tooling

104
00:05:01,600 --> 00:05:04,350
and talk about how to
prevent these attacks.

105
00:05:04,350 --> 00:05:06,680
If you're watching this live at Def Con,

106
00:05:06,680 --> 00:05:10,150
then feel free to hit me up
with questions on Discord

107
00:05:10,150 --> 00:05:12,003
or on Twitter, as you prefer.

108
00:05:13,550 --> 00:05:15,400
Although H two is complex,

109
00:05:15,400 --> 00:05:17,330
there's only actually four key things

110
00:05:17,330 --> 00:05:20,110
that you need to understand
in order to wield it,

111
00:05:20,110 --> 00:05:21,690
as a weapon.

112
00:05:21,690 --> 00:05:24,280
Here, we can see an identical request

113
00:05:24,280 --> 00:05:27,640
represented in H one and H two.

114
00:05:27,640 --> 00:05:30,470
The first key difference
is the request line.

115
00:05:30,470 --> 00:05:32,010
H one has the request line

116
00:05:32,010 --> 00:05:33,910
containing the method in the path.

117
00:05:33,910 --> 00:05:36,700
Whereas, H two has removed this concept

118
00:05:36,700 --> 00:05:39,080
and replaced it with pseudo headers,

119
00:05:39,080 --> 00:05:41,160
which look just like normal headers

120
00:05:41,160 --> 00:05:43,040
but they begin with a colon.

121
00:05:43,040 --> 00:05:45,000
And these are used to
transmit more or less

122
00:05:45,000 --> 00:05:47,913
the information that you would
expect in the request line.

123
00:05:49,280 --> 00:05:50,560
The second difference,

124
00:05:50,560 --> 00:05:53,700
is that H one is a plain text protocol.

125
00:05:53,700 --> 00:05:56,440
So when a server pauses a request,

126
00:05:56,440 --> 00:05:57,890
it has to do things like

127
00:05:57,890 --> 00:06:00,300
look for a new line in order to know

128
00:06:00,300 --> 00:06:01,640
when one header ends

129
00:06:01,640 --> 00:06:04,333
and the next header or the body starts.

130
00:06:05,200 --> 00:06:08,060
H two, meanwhile is a binary protocol

131
00:06:08,060 --> 00:06:11,070
and the head are represented
using key value pairs.

132
00:06:11,070 --> 00:06:16,070
So what that means is when
I show you a H two request

133
00:06:16,120 --> 00:06:17,830
in this presentation, on a slide,

134
00:06:17,830 --> 00:06:20,070
what you're seeing is an abstraction.

135
00:06:20,070 --> 00:06:22,750
It's not the actual bytes
being sent on the wire

136
00:06:22,750 --> 00:06:25,910
because they're binary and not readable.

137
00:06:25,910 --> 00:06:26,940
For example,

138
00:06:26,940 --> 00:06:30,710
if a pseudo headers are
not actually represented

139
00:06:30,710 --> 00:06:31,610
as header names,

140
00:06:31,610 --> 00:06:33,310
starting with a colon on the wire,

141
00:06:34,780 --> 00:06:37,110
they are just mapped to fix bytes,

142
00:06:37,110 --> 00:06:39,453
which are predefined in the RFC.

143
00:06:40,870 --> 00:06:43,710
The third key difference
is that with H one,

144
00:06:43,710 --> 00:06:46,070
the length of the message
has to be communicated

145
00:06:46,070 --> 00:06:48,160
via either the content length header

146
00:06:48,160 --> 00:06:50,750
or the transferring coding chunked header.

147
00:06:50,750 --> 00:06:55,750
H two, meanwhile has requests
being composed out of frames,

148
00:06:56,200 --> 00:07:00,820
and every frame has its own
built in length measurement.

149
00:07:00,820 --> 00:07:03,043
It can be thought of sort of like TCP.

150
00:07:03,900 --> 00:07:06,730
And what that means is that in H two,

151
00:07:06,730 --> 00:07:09,330
you don't need to specify
the length of the message

152
00:07:09,330 --> 00:07:10,163
in a header.

153
00:07:10,163 --> 00:07:13,770
And there's also no real
potential for ambiguity

154
00:07:13,770 --> 00:07:16,990
about the length of a H two message.

155
00:07:16,990 --> 00:07:20,220
And that's why I thought the
request smuggling against H two

156
00:07:20,220 --> 00:07:21,123
was impossible.

157
00:07:22,120 --> 00:07:24,083
The final key difference
is to do with the way

158
00:07:24,083 --> 00:07:27,440
that the postcodes handles
sending multiple requests

159
00:07:27,440 --> 00:07:30,010
over a single connection.

160
00:07:30,010 --> 00:07:32,440
HP two does support this,

161
00:07:32,440 --> 00:07:35,010
but it's not very well understood.

162
00:07:35,010 --> 00:07:36,880
All you do is you open your socket,

163
00:07:36,880 --> 00:07:38,810
you send your requests down it,

164
00:07:38,810 --> 00:07:40,860
you read the response back down the socket

165
00:07:40,860 --> 00:07:43,500
and you send the next request
straight down the same socket

166
00:07:43,500 --> 00:07:45,250
just concatenate it on the end

167
00:07:45,250 --> 00:07:48,070
and read the response back like so.

168
00:07:48,070 --> 00:07:51,290
So you're relying on the
responses coming back

169
00:07:51,290 --> 00:07:53,913
in the order that you
sent the requests in.

170
00:07:55,450 --> 00:07:58,043
H two, meanwhile decides
they don't like this

171
00:07:58,043 --> 00:08:00,090
because it is pretty sketchy.

172
00:08:00,090 --> 00:08:04,280
And instead they introduce
this concept of streams,

173
00:08:04,280 --> 00:08:05,550
every frame, therefore,

174
00:08:05,550 --> 00:08:08,720
every request and response has a label,

175
00:08:08,720 --> 00:08:11,560
which tells you it's stream ID.

176
00:08:11,560 --> 00:08:15,930
A stream is simply a
request response pair.

177
00:08:15,930 --> 00:08:18,430
So that means that the
server can send the responses

178
00:08:18,430 --> 00:08:19,350
back out of order.

179
00:08:19,350 --> 00:08:21,480
But thanks to the stream ID,

180
00:08:21,480 --> 00:08:24,420
the client can associate the responses

181
00:08:24,420 --> 00:08:26,453
with the appropriate requests.

182
00:08:28,260 --> 00:08:29,093
Like so.

183
00:08:30,480 --> 00:08:32,430
Now that we understand HTP two,

184
00:08:32,430 --> 00:08:35,020
let's see what damage we can do.

185
00:08:35,020 --> 00:08:37,280
As usual, all the case studies,

186
00:08:37,280 --> 00:08:40,500
presented in this section
are based on real targets

187
00:08:40,500 --> 00:08:42,840
that have bug bounty programs.

188
00:08:42,840 --> 00:08:44,590
All these vulnerabilities were found using

189
00:08:44,590 --> 00:08:45,550
an open source tool

190
00:08:45,550 --> 00:08:48,620
that I am releasing as
part of this presentation.

191
00:08:48,620 --> 00:08:50,350
And of any bounties earned,

192
00:08:50,350 --> 00:08:53,260
over half have been
donated to local charities

193
00:08:53,260 --> 00:08:55,560
and the other half will be spent on beer,

194
00:08:55,560 --> 00:08:57,683
when that is, once again, permitted.

195
00:08:59,120 --> 00:09:01,260
This section we will be
traveling quite fast.

196
00:09:01,260 --> 00:09:04,620
So if you're not already
familiar with request smuggling

197
00:09:04,620 --> 00:09:06,170
and you struggle to keep track,

198
00:09:06,170 --> 00:09:09,080
I suggest pausing it and checking
out my prior presentation,

199
00:09:09,080 --> 00:09:11,263
HTP Desync attacks.

200
00:09:12,810 --> 00:09:13,643
So,

201
00:09:13,643 --> 00:09:16,110
why is the quest mugging possible

202
00:09:16,110 --> 00:09:18,187
against servers running HP two?

203
00:09:19,285 --> 00:09:24,090
It is because the vast majority
of servers that speak H two

204
00:09:24,090 --> 00:09:26,610
actually only speak H two with the client.

205
00:09:26,610 --> 00:09:30,300
And then they rewrite
their requests as HTP one

206
00:09:30,300 --> 00:09:33,230
in order to talk to the backend server.

207
00:09:33,230 --> 00:09:34,080
This behavior,

208
00:09:34,080 --> 00:09:38,110
which I have dubbed HTP two downgrading

209
00:09:38,110 --> 00:09:39,610
is ridiculously common.

210
00:09:39,610 --> 00:09:42,150
For example, Amazon's
application load balance.

211
00:09:42,150 --> 00:09:44,970
It does it by default and
you cannot disable it.

212
00:09:44,970 --> 00:09:48,003
You cannot tell it to talk H two into it.

213
00:09:49,088 --> 00:09:50,370
What this approach does

214
00:09:50,370 --> 00:09:54,030
is it basically dodges
all the security benefits

215
00:09:54,030 --> 00:09:57,490
that should be brought by using H two.

216
00:09:57,490 --> 00:10:00,810
In fact, it arguably makes things worse.

217
00:10:00,810 --> 00:10:03,510
When you get a classic request
smuggling vulnerability,

218
00:10:03,510 --> 00:10:06,570
it is typically because the
front end and the back end

219
00:10:06,570 --> 00:10:08,280
disagree about whether they should use

220
00:10:08,280 --> 00:10:11,223
the content length or the
transfer and coding header.

221
00:10:12,180 --> 00:10:15,920
However, if the front end
server is speaking H two,

222
00:10:15,920 --> 00:10:18,950
then there's basically no
possibility for the front end

223
00:10:18,950 --> 00:10:21,780
and the backend to directly
agree because the front end

224
00:10:21,780 --> 00:10:25,020
is going to use the HP two message length,

225
00:10:25,020 --> 00:10:27,080
and then the back end does
not have access to that data.

226
00:10:27,080 --> 00:10:29,780
So it has to use the content length

227
00:10:29,780 --> 00:10:32,300
or the transfer encoding header.

228
00:10:32,300 --> 00:10:34,760
If that sounds like a
mess that's because it is,

229
00:10:34,760 --> 00:10:37,580
if you take a server
that supports HTP one,

230
00:10:37,580 --> 00:10:39,640
and you turn on HTP two support,

231
00:10:39,640 --> 00:10:41,430
you've just doubled the number of ways

232
00:10:41,430 --> 00:10:43,873
that it may be vulnerable
to request smuggling.

233
00:10:45,790 --> 00:10:49,733
We're going to start with an
extremely simple case study.

234
00:10:50,730 --> 00:10:53,260
The RFC for H2 says that

235
00:10:53,260 --> 00:10:56,390
even though the content length
headache is not required,

236
00:10:56,390 --> 00:11:00,630
you are still allowed to send
it provided that it's correct.

237
00:11:00,630 --> 00:11:02,930
What could possibly go wrong with that?

238
00:11:02,930 --> 00:11:03,830
Well,

239
00:11:03,830 --> 00:11:07,520
the front end used by
Netflix on their main website

240
00:11:07,520 --> 00:11:09,520
where you watch videos and stuff

241
00:11:09,520 --> 00:11:13,420
forgot to verify that the
content length was correct.

242
00:11:13,420 --> 00:11:16,810
So if I sent the HP two
request, you can see here,

243
00:11:16,810 --> 00:11:19,420
then it would get
translated and downgraded

244
00:11:19,420 --> 00:11:22,440
into an H one request that
you can see on the right.

245
00:11:22,440 --> 00:11:25,000
And that thanks to the
incorrect content length,

246
00:11:25,000 --> 00:11:28,430
will get treated as 1.5
requests on the backend

247
00:11:28,430 --> 00:11:31,280
and the malicious prefixed shown in orange

248
00:11:31,280 --> 00:11:35,840
would get stuck on the start
of the next users request.

249
00:11:35,840 --> 00:11:37,010
I crafted that prefix,

250
00:11:37,010 --> 00:11:39,100
so it would redirect them to my server.

251
00:11:39,100 --> 00:11:40,780
And by running that in a loop,

252
00:11:40,780 --> 00:11:43,830
I could hijack other
people's JavaScript imports

253
00:11:43,830 --> 00:11:46,710
in real time, compromise their account,

254
00:11:46,710 --> 00:11:49,040
steal plain text passwords
and credit card details

255
00:11:49,040 --> 00:11:50,520
and so on.

256
00:11:50,520 --> 00:11:53,370
That was traced back to the Netty library

257
00:11:53,370 --> 00:11:57,013
and Netflix awarded me
a $20,000 bounty for it.

258
00:11:59,220 --> 00:12:00,660
After that motivating start,

259
00:12:00,660 --> 00:12:04,220
let's move on to something
slightly more complex.

260
00:12:04,220 --> 00:12:07,470
The H two OFC also says any message

261
00:12:07,470 --> 00:12:10,020
containing connection
specific header fields

262
00:12:10,020 --> 00:12:12,810
must be treated as malformed.

263
00:12:12,810 --> 00:12:15,330
But, it's a bit vague about what happens

264
00:12:15,330 --> 00:12:17,380
if you fail to obey this line.

265
00:12:17,380 --> 00:12:19,920
So I'm going to fill in the blanks.

266
00:12:19,920 --> 00:12:22,189
One server that failed to obey this was

267
00:12:22,189 --> 00:12:24,614
Amazon's application load balancer,

268
00:12:24,614 --> 00:12:26,290
and it meant I could exploit

269
00:12:26,290 --> 00:12:28,300
pretty much every single website

270
00:12:28,300 --> 00:12:31,090
using application load balancer.

271
00:12:31,090 --> 00:12:32,490
For our first case study,

272
00:12:32,490 --> 00:12:33,680
we will take a look at

273
00:12:33,680 --> 00:12:37,350
Verizon's law enforcement portal thing.

274
00:12:37,350 --> 00:12:41,220
So here, I'm sending a HP two request

275
00:12:41,220 --> 00:12:45,080
containing the connection
specific header field transfer

276
00:12:45,080 --> 00:12:46,890
in coding chucked.

277
00:12:46,890 --> 00:12:50,520
And because the server
has failed to eject this,

278
00:12:50,520 --> 00:12:52,700
it's been forwarded onto the backend

279
00:12:52,700 --> 00:12:54,353
and the backend has
prioritized the transfer

280
00:12:54,353 --> 00:12:56,690
and coding header over the content length,

281
00:12:56,690 --> 00:12:58,220
which is the one that's actually correct.

282
00:12:58,220 --> 00:12:59,230
And once again,

283
00:12:59,230 --> 00:13:03,650
I can cause a desynchronization
and append arbitrary content

284
00:13:03,650 --> 00:13:05,400
to other people's requests.

285
00:13:05,400 --> 00:13:09,730
And once again, I'm using
this to trigger a redirect.

286
00:13:09,730 --> 00:13:12,380
When I reported this, the
triage has said, well,

287
00:13:12,380 --> 00:13:14,890
you haven't really proven
that this is dangerous.

288
00:13:14,890 --> 00:13:18,600
So I decided to try and
redirect some live users

289
00:13:18,600 --> 00:13:20,790
and I've found very, very quickly.

290
00:13:20,790 --> 00:13:22,310
I ended up redirecting people

291
00:13:22,310 --> 00:13:24,990
who were in the middle
of an OAuth login float,

292
00:13:24,990 --> 00:13:26,200
and thereby, they ended up

293
00:13:26,200 --> 00:13:28,620
leaking their Oauth secret codes to me

294
00:13:28,620 --> 00:13:29,823
via the referer header.

295
00:13:30,880 --> 00:13:33,400
That worked on application load balance,

296
00:13:33,400 --> 00:13:34,233
as I mentioned,

297
00:13:34,233 --> 00:13:36,460
and also on everything using

298
00:13:36,460 --> 00:13:38,650
encapsulates web application firewall,

299
00:13:38,650 --> 00:13:41,403
which is supposed to make
your website more secure.

300
00:13:42,310 --> 00:13:46,440
That led to a $7,000 bounty from Verizon.

301
00:13:46,440 --> 00:13:49,740
Notably This didn't get
me any bounty from Amazon

302
00:13:49,740 --> 00:13:51,050
or from Incapsula.

303
00:13:51,050 --> 00:13:53,110
There's a bit of a disconnect between

304
00:13:53,110 --> 00:13:55,810
the vendors that write
the vulnerable software

305
00:13:55,810 --> 00:13:58,833
and the end users that
end up paying for it.

306
00:14:00,420 --> 00:14:05,010
On another server with the
same vulnerability, I found

307
00:14:05,010 --> 00:14:07,040
I could, once again, we'd
have an arbitrary users.

308
00:14:07,040 --> 00:14:08,190
And I was, once again told,

309
00:14:08,190 --> 00:14:11,470
you need to prove that
this is really dangerous.

310
00:14:11,470 --> 00:14:15,030
So I, once again, started
redirecting real users.

311
00:14:15,030 --> 00:14:18,010
However, this time something
really quite cool happened.

312
00:14:18,010 --> 00:14:21,160
I started getting requests
that landed on my server

313
00:14:21,160 --> 00:14:23,770
that said something along
the lines of, Hey there,

314
00:14:23,770 --> 00:14:27,563
I'd like to have permission
to send you my credentials.

315
00:14:28,470 --> 00:14:32,000
So I hastily made some tweets
to my server to make it say,

316
00:14:32,000 --> 00:14:33,760
yeah, absolutely, go ahead.

317
00:14:33,760 --> 00:14:37,630
Send me your password.
And sure enough, they did.

318
00:14:37,630 --> 00:14:41,310
I've got a brilliant video
taken with TCP dump showing

319
00:14:41,310 --> 00:14:44,770
a stream of creds landing
on my server in real time

320
00:14:44,770 --> 00:14:46,210
from their live traffic.

321
00:14:46,210 --> 00:14:49,310
But unfortunately it was
near impossible to redact.

322
00:14:49,310 --> 00:14:51,810
So I can't share it.

323
00:14:51,810 --> 00:14:55,193
This led to a $10,000 bounty from Verizon.

324
00:14:57,360 --> 00:14:59,350
Right, that was the basic stuff.

325
00:14:59,350 --> 00:15:02,003
Now things are going to
get a bit more interesting.

326
00:15:02,850 --> 00:15:06,940
One cool thing about H two is
that being a binary protocol,

327
00:15:06,940 --> 00:15:09,770
It lets you put, arbitary
characters wherever you'd like,

328
00:15:09,770 --> 00:15:13,150
and then it relies on an extra
layer of server logic to say,

329
00:15:13,150 --> 00:15:13,983
actually, no,

330
00:15:13,983 --> 00:15:17,403
you should not be putting that
character in that position.

331
00:15:18,540 --> 00:15:20,350
Firefox's start page,

332
00:15:20,350 --> 00:15:24,910
at start dot Mozilla dot org
was powered by the Netlify CDN.

333
00:15:24,910 --> 00:15:26,520
And they forget to say,

334
00:15:26,520 --> 00:15:31,020
you shouldn't put new
lines in header values.

335
00:15:31,020 --> 00:15:34,020
This led to the request header injection,

336
00:15:34,020 --> 00:15:35,600
for mobility that I'm using here

337
00:15:35,600 --> 00:15:39,100
to smuggle the transfer
in coding, chunked header,

338
00:15:39,100 --> 00:15:41,810
and cause a desynchronization.

339
00:15:41,810 --> 00:15:45,460
Here, I've crafted the
malicious prefix to fetch data

340
00:15:45,460 --> 00:15:48,590
from my own site on Netlify

341
00:15:48,590 --> 00:15:50,256
and thanks Netlify's cache,

342
00:15:50,256 --> 00:15:52,860
that harmful data would then get saved.

343
00:15:52,860 --> 00:15:56,070
And basically, persistently
gives me full control

344
00:15:56,070 --> 00:15:59,440
over every page, on
every site using Netlify.

345
00:16:00,330 --> 00:16:03,240
I reported that to Mozilla and Netlify

346
00:16:03,240 --> 00:16:05,260
and got two K off each,

347
00:16:05,260 --> 00:16:07,933
taking the total earned so far to 41 K.

348
00:16:09,600 --> 00:16:12,890
When I tried the same
technique on Atlassian Jira,

349
00:16:12,890 --> 00:16:15,550
something quite unexpected happened.

350
00:16:15,550 --> 00:16:18,420
I expected to see two
responses coming back to me,

351
00:16:18,420 --> 00:16:21,540
the normal response and
the poison response.

352
00:16:21,540 --> 00:16:24,320
But what I actually saw
and you can see here is

353
00:16:24,320 --> 00:16:27,710
a huge range of different
responses clearly coming

354
00:16:27,710 --> 00:16:30,130
from different Jira deployments,

355
00:16:30,130 --> 00:16:31,870
intended for different people

356
00:16:31,870 --> 00:16:36,333
and containing a huge amount
of sensitive information.

357
00:16:38,140 --> 00:16:41,220
How did this happen? Well,
I wasn't sure initially,

358
00:16:41,220 --> 00:16:44,040
but I think I eventually figured it out.

359
00:16:44,040 --> 00:16:46,510
The problem was I had realized that

360
00:16:46,510 --> 00:16:48,900
by putting new lines in headers,

361
00:16:48,900 --> 00:16:52,780
I could actually place my
entire malicious prefix

362
00:16:52,780 --> 00:16:55,220
inside a header instead
of putting it in the body,

363
00:16:55,220 --> 00:16:57,740
which meant I didn't need to use a body

364
00:16:57,740 --> 00:17:00,520
and therefore didn't need
to use the post method.

365
00:17:00,520 --> 00:17:03,510
And so it might work on more targets.

366
00:17:03,510 --> 00:17:05,160
That was fantastic reasoning on my part,

367
00:17:05,160 --> 00:17:09,071
but the thing I forgot to figure out is

368
00:17:09,071 --> 00:17:13,320
I didn't account for the
front end needing to terminate

369
00:17:13,320 --> 00:17:16,210
my request by adding on
a couple of new lines.

370
00:17:16,210 --> 00:17:18,090
So my smuggled requests looked like this,

371
00:17:18,090 --> 00:17:20,360
and I thought I was sending 1.5 requests.

372
00:17:20,360 --> 00:17:23,400
But when he got downgraded,
thanks to the front end,

373
00:17:23,400 --> 00:17:25,630
sticking the new lines on the end,

374
00:17:25,630 --> 00:17:30,180
I was actually sending
exactly two requests.

375
00:17:30,180 --> 00:17:31,670
So, what happened then?

376
00:17:31,670 --> 00:17:34,690
Well, the first response
went to me as usual

377
00:17:34,690 --> 00:17:38,160
and the second response
went to the next user,

378
00:17:38,160 --> 00:17:41,310
but because it was exactly two requests,

379
00:17:41,310 --> 00:17:44,780
their response then went
to the next user and so on.

380
00:17:44,780 --> 00:17:46,890
And basically the front
end completely lost track

381
00:17:46,890 --> 00:17:49,070
of which responses should be going to who.

382
00:17:49,070 --> 00:17:51,820
So random responses to everybody.

383
00:17:51,820 --> 00:17:52,790
And thanks to the set,

384
00:17:52,790 --> 00:17:56,150
cookie header ended up
persistently logging random users

385
00:17:56,150 --> 00:17:58,200
into random accounts,

386
00:17:58,200 --> 00:18:01,330
leading to Atlassian having
to expire all sessions

387
00:18:01,330 --> 00:18:03,323
and log everybody out.

388
00:18:04,210 --> 00:18:07,900
So, if you find a request
smuggling, vulnerability,

389
00:18:07,900 --> 00:18:10,750
and someone demands to
see the impact of it,

390
00:18:10,750 --> 00:18:12,670
smuggling exactly two requests

391
00:18:12,670 --> 00:18:15,653
should get them the evidence
that they're looking for.

392
00:18:17,020 --> 00:18:19,350
The root cause of this was Atlassian

393
00:18:19,350 --> 00:18:24,010
was using the post secure virtual
traffic manager front end,

394
00:18:24,010 --> 00:18:25,040
which shouldn't be

395
00:18:25,040 --> 00:18:27,343
confused with post secure's notorious VPN.

396
00:18:28,420 --> 00:18:31,440
We also saw that this worked
on Netlify and as usual

397
00:18:31,440 --> 00:18:33,490
with most of my techniques, it also worked

398
00:18:33,490 --> 00:18:36,143
on the Imperva cloud WAF thing.

399
00:18:38,820 --> 00:18:41,750
Thanks to the work of the
computer emergency response team.

400
00:18:41,750 --> 00:18:44,850
There are more advisories
from other vendors vulnerable

401
00:18:44,850 --> 00:18:46,870
to the same technique on their way.

402
00:18:46,870 --> 00:18:49,510
If you check out the
white paper on our blog,

403
00:18:49,510 --> 00:18:51,340
you should find that they
are referenced there,

404
00:18:51,340 --> 00:18:53,040
by the time you are watching this.

405
00:18:54,340 --> 00:18:56,950
While Atlassian was
waiting for post secure

406
00:18:56,950 --> 00:18:59,780
to release a proper patch
to fix this vulnerability,

407
00:18:59,780 --> 00:19:02,190
they tried deploying a
few hotfixes themselves

408
00:19:02,190 --> 00:19:03,040
and these issues,

409
00:19:03,040 --> 00:19:07,340
some of the other potential
bypasses that you might find.

410
00:19:07,340 --> 00:19:09,840
The first issue was they
were filtering header values

411
00:19:09,840 --> 00:19:12,350
but they weren't filtering header names.

412
00:19:12,350 --> 00:19:15,180
Exploiting that directly is not super easy

413
00:19:15,180 --> 00:19:17,590
because it results in an invalid request,

414
00:19:17,590 --> 00:19:20,210
hitting the backend and the
requests being rejected.

415
00:19:20,210 --> 00:19:22,718
But HP two, on some servers,

416
00:19:22,718 --> 00:19:25,430
lets you put colons in header names,

417
00:19:25,430 --> 00:19:28,463
making exploitation actually
quite straightforward.

418
00:19:29,870 --> 00:19:33,250
Another issue was that
even after they patch that,

419
00:19:33,250 --> 00:19:35,070
they forgot to filter pseudo headers.

420
00:19:35,070 --> 00:19:39,710
So we could get injection
inside the request line.

421
00:19:39,710 --> 00:19:42,580
And exploiting pseudo
headers is pretty much

422
00:19:42,580 --> 00:19:44,960
just the same as exploiting other headers,

423
00:19:44,960 --> 00:19:46,830
but you just need to think about

424
00:19:46,830 --> 00:19:49,510
what the resulting downgraded
request will look like

425
00:19:49,510 --> 00:19:52,540
and make sure that it
has a valid request line

426
00:19:52,540 --> 00:19:55,113
so that your request doesn't get rejected.

427
00:19:55,980 --> 00:19:59,670
The final issue was that in
the path, pseudo header only,

428
00:19:59,670 --> 00:20:02,720
they were only rejecting the
slash R slash end sequence.

429
00:20:02,720 --> 00:20:05,270
So if you could send slash end by itself,

430
00:20:05,270 --> 00:20:07,163
you could once again, exploit.

431
00:20:08,300 --> 00:20:10,480
In summary, we've seen a
range of techniques that

432
00:20:10,480 --> 00:20:12,680
you can use to exploit H two downgrades

433
00:20:12,680 --> 00:20:14,193
and achieve request smuggling.

434
00:20:15,700 --> 00:20:18,790
Now, I'm going to take a look
at something less flashy,

435
00:20:18,790 --> 00:20:22,783
less obvious, but still
really quite dangerous.

436
00:20:24,170 --> 00:20:26,870
When you find a request
smuggling vulnerability,

437
00:20:26,870 --> 00:20:30,220
the possible attacks are heavily affected

438
00:20:30,220 --> 00:20:33,640
by the approach that
the front end server use

439
00:20:33,640 --> 00:20:36,080
to decide whether to reuse

440
00:20:36,080 --> 00:20:38,670
an existing connection to the backend

441
00:20:38,670 --> 00:20:40,113
or to create a new one.

442
00:20:41,270 --> 00:20:43,640
Normally, you can exploit everybody fine

443
00:20:43,640 --> 00:20:46,030
because there's no particular
restrictions on this,

444
00:20:46,030 --> 00:20:48,010
but sometimes you'll that when

445
00:20:48,010 --> 00:20:49,590
you're trying to exploit other people,

446
00:20:49,590 --> 00:20:51,560
you can only poison the response

447
00:20:51,560 --> 00:20:54,780
to requests coming from your own IP.

448
00:20:54,780 --> 00:20:56,130
And the reason that that happens

449
00:20:56,130 --> 00:20:58,800
is because the front end
has decided it is going

450
00:20:58,800 --> 00:21:03,160
to establish one connection
to the backend per client IP.

451
00:21:03,160 --> 00:21:05,800
However, this is still
exploitable via cash poisoning

452
00:21:05,800 --> 00:21:08,070
and you can still use the
regular old techniques

453
00:21:08,070 --> 00:21:09,650
to leak internal headers

454
00:21:09,650 --> 00:21:11,690
and thereby use that
for request tunneling.

455
00:21:11,690 --> 00:21:13,347
So it's not that bad.

456
00:21:14,260 --> 00:21:17,640
The most extreme scenario is
what I'm going to focus on.

457
00:21:17,640 --> 00:21:20,300
This happens when the front end refuses

458
00:21:20,300 --> 00:21:24,090
to ever reuse a connection
to the backend server.

459
00:21:24,090 --> 00:21:26,530
Some servers are just set up like this.

460
00:21:26,530 --> 00:21:30,370
And also Amazon's
application load balancer

461
00:21:30,370 --> 00:21:32,877
has a feature called HP desync (guardian).

462
00:21:33,780 --> 00:21:35,660
It doesn't work against HP two,

463
00:21:35,660 --> 00:21:38,840
so it didn't prevent any of
the attacks shown earlier.

464
00:21:38,840 --> 00:21:42,540
But against H one, if they
see a suspicious request,

465
00:21:42,540 --> 00:21:45,230
they will try to mitigate
the damage it might do

466
00:21:45,230 --> 00:21:47,843
by putting that on its own connection.

467
00:21:49,050 --> 00:21:51,110
So I'm going to show you how to

468
00:21:51,110 --> 00:21:53,750
establish that this
vulnerability really exists,

469
00:21:53,750 --> 00:21:55,320
how to confirm that you found it.

470
00:21:55,320 --> 00:21:58,840
And also some new exploit
paths that will let you

471
00:21:58,840 --> 00:21:59,830
turn it into something

472
00:21:59,830 --> 00:22:02,863
really quite high severity
in the right conditions.

473
00:22:04,690 --> 00:22:07,140
Let's visualize what's happening here.

474
00:22:07,140 --> 00:22:11,550
Here, we've successfully
smuggled 1.5 requests

475
00:22:11,550 --> 00:22:15,000
to the backend and then
sent a follow up request.

476
00:22:15,000 --> 00:22:16,260
But because the front end

477
00:22:16,260 --> 00:22:19,020
is only sending one
request down each socket,

478
00:22:19,020 --> 00:22:22,440
the follow-up is being sent
down a different socket

479
00:22:22,440 --> 00:22:25,810
and the poisoned socket is
effectively being discarded.

480
00:22:25,810 --> 00:22:29,793
So the victim, the follow-up
is completely unaffected.

481
00:22:31,430 --> 00:22:33,720
This. As I mentioned,

482
00:22:33,720 --> 00:22:37,630
is going to cause us
numerous practical problems.

483
00:22:37,630 --> 00:22:40,620
The first key problem is
that although the server

484
00:22:40,620 --> 00:22:43,110
will flag up up as being vulnerable,

485
00:22:43,110 --> 00:22:45,350
using the regular, timeout-based,

486
00:22:45,350 --> 00:22:47,370
request smuggling detection technique

487
00:22:48,810 --> 00:22:51,540
The usual confirmation technique
of sending followups will,

488
00:22:51,540 --> 00:22:54,670
as we have just seen, fail spectacularly.

489
00:22:54,670 --> 00:22:58,053
So it's easy to mistake
this for a false positive.

490
00:22:59,520 --> 00:23:02,970
We need a different way of confirming it.

491
00:23:02,970 --> 00:23:05,840
Now you might think it's
quite easy just to smuggle

492
00:23:05,840 --> 00:23:09,530
exactly two requests and see
if you get two responses.

493
00:23:09,530 --> 00:23:11,410
Or maybe smuggled 2.1 requests,

494
00:23:11,410 --> 00:23:15,050
if you don't want to cause a
disaster that we saw on Jira.

495
00:23:16,060 --> 00:23:18,920
But unfortunately, this response

496
00:23:18,920 --> 00:23:21,930
that you can see here
containing two responses,

497
00:23:21,930 --> 00:23:25,200
doesn't actually show us that
this target is vulnerable

498
00:23:25,200 --> 00:23:29,053
because this is just how HTB 1.1 works.

499
00:23:30,150 --> 00:23:31,870
When you're looking at this response,

500
00:23:31,870 --> 00:23:34,030
you can't answer the question.

501
00:23:34,030 --> 00:23:36,760
Does the front end think it
is sending us one response

502
00:23:36,760 --> 00:23:40,053
or two and thereby, you don't
know if it's vulnerable.

503
00:23:41,240 --> 00:23:45,850
HP two fixes this problem for
us with absolutely no effort,

504
00:23:45,850 --> 00:23:46,683
on our part.

505
00:23:46,683 --> 00:23:49,740
If you see HP 1.1 headers showing up

506
00:23:49,740 --> 00:23:53,010
in the body of HP two
response, and I promise you,

507
00:23:53,010 --> 00:23:54,900
if you try these techniques out, you will,

508
00:23:54,900 --> 00:23:57,430
then you know that this server

509
00:23:57,430 --> 00:23:59,903
is really vulnerable to request tunneling.

510
00:24:01,800 --> 00:24:03,530
The second problem,

511
00:24:03,530 --> 00:24:05,770
is that request tunneling is often blind

512
00:24:05,770 --> 00:24:08,640
because the front end looks
the content of the header,

513
00:24:08,640 --> 00:24:12,180
coming from the backend in
order to know how many bytes

514
00:24:12,180 --> 00:24:15,990
it should read off the socket
and pass on to the user.

515
00:24:15,990 --> 00:24:20,210
So we can smuggle two or
three requests to the backend

516
00:24:20,210 --> 00:24:21,940
and the backend will generate responses

517
00:24:21,940 --> 00:24:24,010
and it will try and send them to us.

518
00:24:24,010 --> 00:24:27,120
But the front end will
only show us the first one,

519
00:24:27,120 --> 00:24:29,840
which is the one that we
don't have much control over

520
00:24:29,840 --> 00:24:31,590
and isn't particularly interesting.

521
00:24:32,900 --> 00:24:35,070
This makes life extremely difficult.

522
00:24:35,070 --> 00:24:38,613
And this is the behavior
that was present on Bitbucket

523
00:24:38,613 --> 00:24:40,483
that drove me completely insane.

524
00:24:42,320 --> 00:24:43,193
Eventually,

525
00:24:44,210 --> 00:24:47,390
as I was testing this
end point on Bitbucket,

526
00:24:47,390 --> 00:24:50,070
I started to get frustrated
for another reason,

527
00:24:50,070 --> 00:24:53,600
which was that the file
being returned was so large.

528
00:24:53,600 --> 00:24:58,420
It was making the whole UI
lag inside Burp Repeater.

529
00:24:58,420 --> 00:25:00,160
And I thought, you know what?

530
00:25:00,160 --> 00:25:03,010
I actually don't particularly
care about the response body.

531
00:25:03,010 --> 00:25:04,670
I'm only looking at the headers.

532
00:25:04,670 --> 00:25:07,260
So to stop the repeater from lagging,

533
00:25:07,260 --> 00:25:10,950
why don't I just change the
request method from post to head

534
00:25:10,950 --> 00:25:14,603
thereby only asking the server
for the response headers.

535
00:25:15,620 --> 00:25:16,640
And that worked,

536
00:25:16,640 --> 00:25:18,610
the server only served
up the response headers,

537
00:25:18,610 --> 00:25:20,820
but it included the content length header,

538
00:25:20,820 --> 00:25:23,350
even though there was actually no content.

539
00:25:23,350 --> 00:25:25,540
And that meant that the front end read

540
00:25:26,510 --> 00:25:29,510
into the next response
coming from the backend.

541
00:25:29,510 --> 00:25:32,380
And it proved that this
target was really vulnerable

542
00:25:32,380 --> 00:25:34,260
to request smuggling.

543
00:25:34,260 --> 00:25:36,980
So if you find blind request smuggling,

544
00:25:36,980 --> 00:25:39,100
you may be able to use the head method

545
00:25:39,100 --> 00:25:42,663
or potentially the options
method to make it non blind.

546
00:25:43,960 --> 00:25:47,210
I think that's a brilliant
lesson on how sometimes

547
00:25:47,210 --> 00:25:50,500
you might not have any
particular spark or insight,

548
00:25:50,500 --> 00:25:53,000
but actually if you just spend long enough

549
00:25:53,000 --> 00:25:54,440
trying to hack something,

550
00:25:54,440 --> 00:25:56,170
you're basically find the answer

551
00:25:56,170 --> 00:25:58,833
if it exists just through brute force.

552
00:25:59,720 --> 00:26:01,160
So, let's say,

553
00:26:01,160 --> 00:26:03,590
you've just confirmed you're
tunneling vulnerability

554
00:26:03,590 --> 00:26:05,490
and hopefully made it non blind.

555
00:26:05,490 --> 00:26:07,190
How can you exploit it?

556
00:26:07,190 --> 00:26:10,260
Well, as we've seen you
can't attack other users,

557
00:26:10,260 --> 00:26:14,810
but what you can do is you
can tunnel internal headers.

558
00:26:14,810 --> 00:26:18,960
Front ends often append secret
headers to incoming requests

559
00:26:18,960 --> 00:26:22,320
that are trusted by the
backend for critical functions,

560
00:26:22,320 --> 00:26:25,230
such as knowing who you are logged in as.

561
00:26:25,230 --> 00:26:26,640
But to exploit these,

562
00:26:26,640 --> 00:26:27,987
you need to know what they're called

563
00:26:27,987 --> 00:26:30,290
and the normal header leaking
techniques that you can do

564
00:26:30,290 --> 00:26:32,843
with regular request smuggling don't work.

565
00:26:34,040 --> 00:26:36,870
However, if you can inject
new lines and headers,

566
00:26:36,870 --> 00:26:40,620
you can actually cause a different
type of desynchronization

567
00:26:40,620 --> 00:26:43,103
that lets you disclose these headers.

568
00:26:44,220 --> 00:26:46,380
Take a look at what I've done here.

569
00:26:46,380 --> 00:26:48,630
I've crafted the HP two requests,

570
00:26:48,630 --> 00:26:51,610
such that both, the
front end and the backend

571
00:26:51,610 --> 00:26:54,563
think I'm sending one request.

572
00:26:55,490 --> 00:26:56,660
So that means even if this

573
00:26:56,660 --> 00:26:59,030
is a blind request
smuggling vulnerability,

574
00:26:59,030 --> 00:27:01,663
I am still going to see
the response coming back.

575
00:27:02,520 --> 00:27:05,810
Where the two systems are desynchronized,

576
00:27:05,810 --> 00:27:08,360
is they're not desynchronized about

577
00:27:08,360 --> 00:27:09,980
the length of the body,

578
00:27:09,980 --> 00:27:12,630
which is the normal thing
they get confused about.

579
00:27:12,630 --> 00:27:16,450
Instead they're desynchronized
about where the headers end

580
00:27:16,450 --> 00:27:18,610
and the body starts.

581
00:27:18,610 --> 00:27:19,443
So that is meant that

582
00:27:19,443 --> 00:27:22,140
when the front end appended
its internal headers,

583
00:27:22,140 --> 00:27:24,430
it actually, from the
backends perspective,

584
00:27:24,430 --> 00:27:26,590
appended them into this S parameter,

585
00:27:26,590 --> 00:27:29,030
which is part of the body
being used to do a search

586
00:27:29,030 --> 00:27:32,340
on the word quest backend on BitBucket,

587
00:27:32,340 --> 00:27:33,490
thereby leading to it

588
00:27:33,490 --> 00:27:36,743
reflecting a whole bunch of
internal headers back to me.

589
00:27:38,120 --> 00:27:40,210
I also found that by
hitting different parts,

590
00:27:40,210 --> 00:27:42,310
I could get the request
routed to different backends

591
00:27:42,310 --> 00:27:44,120
with different internal headers,

592
00:27:44,120 --> 00:27:46,633
including certain secret keys.

593
00:27:49,720 --> 00:27:52,030
Finally, if the stars have aligned,

594
00:27:52,030 --> 00:27:55,870
you might be able to use
tunneling for cash poisoning.

595
00:27:55,870 --> 00:27:58,440
Cash poisoning is one of
the highest severity attacks

596
00:27:58,440 --> 00:28:00,180
that you can do with request smuggling

597
00:28:00,180 --> 00:28:02,070
and the head technique,

598
00:28:02,070 --> 00:28:04,980
when combined with the ability
to put new lines in headers,

599
00:28:04,980 --> 00:28:07,780
enables a unique and extra
powerful variety of it,

600
00:28:07,780 --> 00:28:11,800
whereby you can mix and match
response, headers and bodies.

601
00:28:11,800 --> 00:28:16,290
So here I have chosen a set
of response headers that

602
00:28:16,290 --> 00:28:18,860
just have content type, text, HTML.

603
00:28:18,860 --> 00:28:22,510
And then I have chosen a
different response that reflects

604
00:28:22,510 --> 00:28:26,100
my user input without encoding
it in the location header.

605
00:28:26,100 --> 00:28:27,630
By itself, that's completely safe.

606
00:28:27,630 --> 00:28:29,280
You don't need to encode user input

607
00:28:29,280 --> 00:28:30,560
that is going in the location header.

608
00:28:30,560 --> 00:28:32,990
But by combining these two things,

609
00:28:32,990 --> 00:28:35,440
I can poison the cash and get full control

610
00:28:35,440 --> 00:28:37,910
over every page on Bitbucket

611
00:28:37,910 --> 00:28:40,490
and triple their maximum bounty

612
00:28:40,490 --> 00:28:42,750
for this plus the issue mentioned earlier,

613
00:28:42,750 --> 00:28:45,913
taking the total earned
in this research to 56 K.

614
00:28:48,320 --> 00:28:50,150
Now, I'm going to take you on a tour

615
00:28:50,150 --> 00:28:53,130
of some HP two exploit primitives.

616
00:28:53,130 --> 00:28:55,220
Each of these use a H two feature to

617
00:28:55,220 --> 00:28:57,740
give you some kind of hold on the target.

618
00:28:57,740 --> 00:29:00,010
And although, it's a bit
light on full case studies

619
00:29:00,010 --> 00:29:01,080
and bounties,

620
00:29:01,080 --> 00:29:03,100
these are all based on real behaviors

621
00:29:03,100 --> 00:29:06,023
that I've seen on real life systems.

622
00:29:07,400 --> 00:29:10,880
In H one, duplicate headers
cause all kinds of problems.

623
00:29:10,880 --> 00:29:13,460
But due to the way the
request line is designed,

624
00:29:13,460 --> 00:29:17,480
you cannot send a request
with a duplicate path.

625
00:29:17,480 --> 00:29:21,320
However, because H two
supports pseudo headers,

626
00:29:21,320 --> 00:29:24,540
you can now send a request
that has two parts.

627
00:29:24,540 --> 00:29:26,150
Admittedly, the server should reject it,

628
00:29:26,150 --> 00:29:27,670
but plenty of them don't

629
00:29:27,670 --> 00:29:29,180
and plenty of them differ

630
00:29:29,180 --> 00:29:31,930
about which path they give priority to,

631
00:29:31,930 --> 00:29:34,620
which is sure to lead to
some unpleasant exploits

632
00:29:34,620 --> 00:29:35,463
in the future.

633
00:29:36,860 --> 00:29:41,020
Even better, H two introduces
this authority pseudo header,

634
00:29:41,020 --> 00:29:43,290
which basically replaces the host,

635
00:29:43,290 --> 00:29:45,800
but it actually says the
host is allowed as well.

636
00:29:45,800 --> 00:29:48,080
And then it says that
they're both optional.

637
00:29:48,080 --> 00:29:50,210
This means you'll find plenty of servers

638
00:29:50,210 --> 00:29:52,000
that do support both.

639
00:29:52,000 --> 00:29:53,780
And if they treat them inconsistently,

640
00:29:53,780 --> 00:29:56,453
it may let you perform
host header attacks.

641
00:29:58,150 --> 00:30:00,680
Another cool thing about
H two is the scheme.

642
00:30:00,680 --> 00:30:01,990
I haven't really mentioned this so far,

643
00:30:01,990 --> 00:30:03,990
but it's basically just meant to be HTTP

644
00:30:05,390 --> 00:30:08,203
or HTPS, just that ASCII strict.

645
00:30:09,270 --> 00:30:12,210
But, the cool thing is
because this is H two,

646
00:30:12,210 --> 00:30:14,210
we can put arbitrary binary data in there

647
00:30:14,210 --> 00:30:18,540
and it doesn't have a
direct equivalent in H one.

648
00:30:18,540 --> 00:30:20,470
So that means it's new attack surface

649
00:30:20,470 --> 00:30:24,130
and people thereby forget to sanitize it.

650
00:30:24,130 --> 00:30:25,620
I found that on Netlify,

651
00:30:25,620 --> 00:30:29,410
we could put an entire
URL inside the scheme

652
00:30:29,410 --> 00:30:33,090
and that was used to
construct a URL on the backend

653
00:30:33,090 --> 00:30:35,750
and thereby led to them
getting extremely confused.

654
00:30:35,750 --> 00:30:39,370
Although there was no clear
security impact with this.

655
00:30:39,370 --> 00:30:43,150
It's potentially going to be
more usable than other systems.

656
00:30:43,150 --> 00:30:44,660
And on another target,

657
00:30:44,660 --> 00:30:47,350
they once again use the
scheme to build a URL,

658
00:30:47,350 --> 00:30:49,910
but they then try to route
the request to that URL.

659
00:30:49,910 --> 00:30:52,610
So I got a server-side request forgery

660
00:30:52,610 --> 00:30:56,053
using the scheme pseudo header.

661
00:30:58,390 --> 00:31:01,660
Some H two servers do
not let you put new lines

662
00:31:01,660 --> 00:31:03,430
in H two header names.

663
00:31:03,430 --> 00:31:06,083
But they do let you put colons in there.

664
00:31:06,980 --> 00:31:10,000
So on some servers you can use this

665
00:31:10,000 --> 00:31:12,230
to get full requests smuggling

666
00:31:12,230 --> 00:31:13,063
on the backend,

667
00:31:13,063 --> 00:31:16,170
provided that the backend
tolerates this irritating colon,

668
00:31:16,170 --> 00:31:19,673
which ends up getting stuck on
the end of the header value.

669
00:31:20,870 --> 00:31:23,170
However often the backend will be fussy

670
00:31:23,170 --> 00:31:24,190
and they will not like that.

671
00:31:24,190 --> 00:31:27,840
So a better option if you find
the front end has this gadget

672
00:31:27,840 --> 00:31:30,520
is to smuggle the host header,

673
00:31:30,520 --> 00:31:33,640
because the host header is
expected to contain a colon

674
00:31:33,640 --> 00:31:37,340
and often servers just ignore
everything that occurs,

675
00:31:37,340 --> 00:31:38,173
after the colon.

676
00:31:39,710 --> 00:31:42,300
I did find one server that was vulnerable

677
00:31:42,300 --> 00:31:45,270
to request smuggling using this technique.

678
00:31:45,270 --> 00:31:49,690
And I got halfway through
exploitation, had to take a break,

679
00:31:49,690 --> 00:31:52,180
got distracted for a couple of weeks.

680
00:31:52,180 --> 00:31:55,150
And then, I found when I came back

681
00:31:55,150 --> 00:31:57,160
that the vulnerability had disappeared

682
00:31:57,160 --> 00:31:58,760
and looking at my logs,

683
00:31:58,760 --> 00:32:00,800
the server banner was reporting that

684
00:32:00,800 --> 00:32:03,743
they had patched their Apache front-end.

685
00:32:04,960 --> 00:32:06,290
So I went looking to see if

686
00:32:06,290 --> 00:32:09,440
Apache had any security
advisories related to this issue.

687
00:32:09,440 --> 00:32:10,740
And I could not find one.

688
00:32:10,740 --> 00:32:12,060
So I thought, you know what?

689
00:32:12,060 --> 00:32:14,990
I will install a vulnerable
version of Apache locally

690
00:32:14,990 --> 00:32:16,393
and use it for my demo.

691
00:32:17,530 --> 00:32:21,120
I installed Apache in the
correct vulnerable version

692
00:32:21,120 --> 00:32:23,460
and I couldn't replicate
the vulnerability.

693
00:32:23,460 --> 00:32:26,770
So maybe it's there. Maybe it isn't.

694
00:32:26,770 --> 00:32:29,730
But what I did find was something else.

695
00:32:29,730 --> 00:32:33,130
I found that Apache is a mod proxy.

696
00:32:33,130 --> 00:32:35,360
When it's doing HTP two downgrading,

697
00:32:35,360 --> 00:32:38,960
lets you put spaces in
the method, pseudo header,

698
00:32:38,960 --> 00:32:43,410
leading to a request line
injection vulnerability.

699
00:32:43,410 --> 00:32:46,530
When a vulnerable version of Apache

700
00:32:46,530 --> 00:32:49,050
and this works on the
latest version of Apache.

701
00:32:49,050 --> 00:32:51,230
It's a zero day at the time of presenting.

702
00:32:51,230 --> 00:32:52,063
Hopefully,

703
00:32:52,063 --> 00:32:54,650
it's been patched by the
time you're watching this.

704
00:32:54,650 --> 00:32:56,610
When this is paired with a backend server

705
00:32:56,610 --> 00:32:58,900
that ignores trailing
junk in the request line,

706
00:32:58,900 --> 00:33:02,560
you can use this to bypass
block walls implemented

707
00:33:02,560 --> 00:33:05,800
on the front end and also
to escape any folders that

708
00:33:05,800 --> 00:33:07,663
they might try to trap you in.

709
00:33:10,710 --> 00:33:14,210
Finally, a few practicalities.

710
00:33:14,210 --> 00:33:19,210
Firstly, because HTTP one
and two share the same port.

711
00:33:19,990 --> 00:33:21,870
When they're spoken over TLS,

712
00:33:21,870 --> 00:33:24,990
then the client is relying on the server

713
00:33:24,990 --> 00:33:27,510
advertising HP two support

714
00:33:27,510 --> 00:33:30,630
via the ALPN field in TLS handshake,

715
00:33:30,630 --> 00:33:33,280
in order to know that it's
allowed to speak H two,

716
00:33:33,280 --> 00:33:35,593
otherwise it will just default to H one.

717
00:33:36,610 --> 00:33:38,840
And there's a whole bunch
of servers out there

718
00:33:38,840 --> 00:33:41,060
that actually support HP two,

719
00:33:41,060 --> 00:33:44,090
but they forget to advertise
this fact in the handshake.

720
00:33:44,090 --> 00:33:46,600
So if you use a regular route,

721
00:33:46,600 --> 00:33:51,420
a client like a browsable curl
it won't speak HP two to them

722
00:33:51,420 --> 00:33:52,730
and you'll think they don't support it.

723
00:33:52,730 --> 00:33:56,200
And you'll miss out on loads
of awesome attack surface.

724
00:33:56,200 --> 00:34:00,100
Fortunately, this behavior
is extremely easy to detect.

725
00:34:00,100 --> 00:34:02,840
So HB request smuggler,

726
00:34:02,840 --> 00:34:05,910
the open source extension
I'm releasing a major update

727
00:34:05,910 --> 00:34:09,120
to for this research will
detect and report this.

728
00:34:09,120 --> 00:34:11,800
Burp Scanner will also
detect and report it

729
00:34:11,800 --> 00:34:12,910
and you can test for it,

730
00:34:12,910 --> 00:34:17,320
simply using curl with the
following command line flags.

731
00:34:17,320 --> 00:34:19,810
I found a real server that was vulnerable

732
00:34:19,810 --> 00:34:22,430
to HP two powered requests smuggling

733
00:34:22,430 --> 00:34:27,070
and had this hidden HP two configuration.

734
00:34:27,070 --> 00:34:28,400
The only catch there was that

735
00:34:28,400 --> 00:34:32,370
I could only exploit other
users that were using HP two,

736
00:34:32,370 --> 00:34:35,370
which was nobody because
they weren't advertising.

737
00:34:35,370 --> 00:34:37,520
Hopefully you'll have
more success than me.

738
00:34:39,120 --> 00:34:40,720
On other sites,

739
00:34:40,720 --> 00:34:42,770
you'll find that although HP two

740
00:34:42,770 --> 00:34:47,770
promises amazing encapsulation
between your requests.

741
00:34:48,120 --> 00:34:51,810
Sometimes, you'll find
that one request sent down,

742
00:34:51,810 --> 00:34:53,570
a connection will break.

743
00:34:53,570 --> 00:34:56,100
All subsequent requests
sent down that connection,

744
00:34:56,100 --> 00:34:58,760
even though it doesn't
actually lead to the server

745
00:34:58,760 --> 00:35:00,650
telling you that it's got corrupted

746
00:35:00,650 --> 00:35:02,360
or closing the connection.

747
00:35:02,360 --> 00:35:04,160
So that's something to watch out for.

748
00:35:04,160 --> 00:35:07,500
And another thing to be
wary of is some servers

749
00:35:07,500 --> 00:35:12,160
treat first request out any
given connection differently.

750
00:35:12,160 --> 00:35:16,650
You can manage these two
bits of annoying behavior

751
00:35:16,650 --> 00:35:20,610
using the requests per
connection configuration setting

752
00:35:20,610 --> 00:35:21,990
in Turbo Intruder,

753
00:35:21,990 --> 00:35:25,610
which I've updated with a
full open source HP two stack

754
00:35:25,610 --> 00:35:26,713
that I coded myself.

755
00:35:27,594 --> 00:35:29,620
And you can also deal
with it in a Repeater

756
00:35:29,620 --> 00:35:32,520
and I'm going to be doing
more research on this

757
00:35:32,520 --> 00:35:33,820
because I think

758
00:35:33,820 --> 00:35:36,890
there's some cool stuff even
behind the scenes there.

759
00:35:36,890 --> 00:35:38,710
The tooling situation in H two

760
00:35:38,710 --> 00:35:43,640
is a bit of a mess because
H two is a binary protocol.

761
00:35:43,640 --> 00:35:47,780
You can't simply use something
like Netcat or open SSL

762
00:35:47,780 --> 00:35:51,040
to speak. You need to
code your own client.

763
00:35:51,040 --> 00:35:53,660
But coding your own client
is a huge amount of work

764
00:35:53,660 --> 00:35:54,640
because it's so complex.

765
00:35:54,640 --> 00:35:56,590
So really, you need to use a library,

766
00:35:56,590 --> 00:35:59,040
but actually libraries will refuse to send

767
00:35:59,040 --> 00:36:00,520
the kinds of malformed requests

768
00:36:00,520 --> 00:36:02,130
that we need to send in order

769
00:36:02,130 --> 00:36:04,293
to trigger these vulnerabilities.

770
00:36:05,390 --> 00:36:07,830
To get started with this research myself,

771
00:36:07,830 --> 00:36:10,760
I coded an open-source
HP two stack from scratch

772
00:36:10,760 --> 00:36:13,140
and integrated that into Turbo Intruder.

773
00:36:13,140 --> 00:36:14,973
So you can use that library.

774
00:36:16,250 --> 00:36:19,810
Also, there is HP two stack
built into Burp Suite,

775
00:36:19,810 --> 00:36:21,510
which is more battle tested

776
00:36:21,510 --> 00:36:24,310
and can also be accessed
via the extended API

777
00:36:24,310 --> 00:36:26,810
and via turbo intruder.

778
00:36:26,810 --> 00:36:29,800
And it may be worth
checking out HP two smuggle,

779
00:36:29,800 --> 00:36:33,020
which was released by Emil
as part of his research.

780
00:36:33,020 --> 00:36:36,623
And I believe works by
patching Golang HP two stack.

781
00:36:38,020 --> 00:36:40,810
As far as detection and exploitation goes.

782
00:36:40,810 --> 00:36:41,643
As of today,

783
00:36:41,643 --> 00:36:42,970
I am releasing a massive update

784
00:36:42,970 --> 00:36:47,970
to the HTTP request smuggler
open source, both extension.

785
00:36:48,970 --> 00:36:51,250
Which you can use to detect

786
00:36:51,250 --> 00:36:55,040
and also aid exploitation
of these vulnerabilities.

787
00:36:55,040 --> 00:36:59,750
In addition to supporting the
normal timeout based technique

788
00:36:59,750 --> 00:37:02,720
that we have used in H one and H two,

789
00:37:02,720 --> 00:37:05,413
it also supports using the HEAD method

790
00:37:05,413 --> 00:37:06,810
that I showed you earlier

791
00:37:06,810 --> 00:37:08,860
in order to find request tunneling

792
00:37:08,860 --> 00:37:10,130
in a reliable manner

793
00:37:10,130 --> 00:37:13,210
that basically doesn't
have false positives,

794
00:37:13,210 --> 00:37:14,730
which is pretty cool.

795
00:37:14,730 --> 00:37:17,400
I highly recommend HP Request Smuggler.

796
00:37:17,400 --> 00:37:18,720
That's what provided

797
00:37:18,720 --> 00:37:21,083
all of the case studies
in this presentation.

798
00:37:22,850 --> 00:37:25,110
Defence. Well, it is tricky.

799
00:37:25,110 --> 00:37:28,770
If you are a network architect,
then please, if possible,

800
00:37:28,770 --> 00:37:30,960
just use speak HP two end to end,

801
00:37:30,960 --> 00:37:33,700
don't do HP downgrading.

802
00:37:33,700 --> 00:37:37,080
Rewriting something from one
protocol to another protocol

803
00:37:37,080 --> 00:37:38,500
is not a good idea.

804
00:37:38,500 --> 00:37:40,490
And I am sure plenty of
other things go wrong

805
00:37:40,490 --> 00:37:43,360
that I did not spot and
put in this presentation.

806
00:37:43,360 --> 00:37:45,900
So don't think just because
you have defended against

807
00:37:45,900 --> 00:37:47,853
this stuff means it's safe.

808
00:37:49,090 --> 00:37:50,310
If you are a server vendor,

809
00:37:50,310 --> 00:37:54,500
please respect the RFC
and enforce the HP 1.1

810
00:37:54,500 --> 00:37:56,660
limitations about what characters

811
00:37:56,660 --> 00:37:58,940
you can put in what positions.

812
00:37:58,940 --> 00:38:01,790
And as a developer,

813
00:38:01,790 --> 00:38:04,990
I think probably you just
need to drop assumptions

814
00:38:04,990 --> 00:38:07,870
that used to be safe to make in HP 1.1,

815
00:38:07,870 --> 00:38:08,870
like don't assume

816
00:38:08,870 --> 00:38:11,400
that the request method
doesn't have spaces in it.

817
00:38:11,400 --> 00:38:15,120
Do not assume that the
scheme is at all trustworthy.

818
00:38:15,120 --> 00:38:16,810
Why don't you just look
at the actual scheme

819
00:38:16,810 --> 00:38:18,130
the request is using,

820
00:38:18,130 --> 00:38:21,223
if possible or use a white list, if not.

821
00:38:23,040 --> 00:38:25,720
There's loads of further
reading available,

822
00:38:25,720 --> 00:38:28,610
I recommend checking out the
white paper I've published,

823
00:38:28,610 --> 00:38:30,007
which accompanies this research

824
00:38:30,007 --> 00:38:32,450
and will contain slightly
more up to date information

825
00:38:32,450 --> 00:38:34,350
on certain topics.

826
00:38:34,350 --> 00:38:37,730
Also, we're releasing a bunch
of online interactive labs.

827
00:38:37,730 --> 00:38:40,580
So as part of our web security academy,

828
00:38:40,580 --> 00:38:41,740
which is completely free,

829
00:38:41,740 --> 00:38:45,360
you can try applying these
techniques to real systems

830
00:38:45,360 --> 00:38:47,840
that we spit up for you on demand,

831
00:38:47,840 --> 00:38:49,590
just so that you can hack them

832
00:38:49,590 --> 00:38:51,670
and gain some practical experience

833
00:38:51,670 --> 00:38:53,853
before targeting real world systems.

834
00:38:54,920 --> 00:38:56,040
Also,

835
00:38:56,040 --> 00:38:58,350
it's probably worth
checking out Emi Lerner's

836
00:38:58,350 --> 00:38:59,810
presentation on HP two

837
00:38:59,810 --> 00:39:03,370
for a different perspective
on the same topic.

838
00:39:03,370 --> 00:39:05,750
And I highly recommend also watching

839
00:39:05,750 --> 00:39:09,050
Response Smuggling:
Pwning HP 1.1 connections,

840
00:39:09,050 --> 00:39:11,680
which is another Def Con presentation.

841
00:39:11,680 --> 00:39:12,660
And it introduces

842
00:39:12,660 --> 00:39:15,520
some new request smuggling
exploitation techniques,

843
00:39:15,520 --> 00:39:20,000
which should be completely
compatible with HP two downgrade

844
00:39:21,367 --> 00:39:23,143
based desynchronization.

845
00:39:24,580 --> 00:39:26,040
As far as primary sources go,

846
00:39:26,040 --> 00:39:30,300
this is mostly based on my
prior work, HP Desync attacks,

847
00:39:30,300 --> 00:39:33,250
but if you want a significantly
better explanation

848
00:39:33,250 --> 00:39:35,010
of response queue poisoning,

849
00:39:35,010 --> 00:39:37,733
check out Defparam's
presentation on YouTube.

850
00:39:38,670 --> 00:39:40,770
The three key things to take away

851
00:39:40,770 --> 00:39:42,760
are that HP two breaks

852
00:39:42,760 --> 00:39:45,950
critical assumptions at
multiple layers of the stack.

853
00:39:45,950 --> 00:39:48,440
HP two downgrades are extremely hazardous

854
00:39:48,440 --> 00:39:49,850
and should be avoided

855
00:39:49,850 --> 00:39:53,410
and request tunneling is a real threat.

856
00:39:53,410 --> 00:39:57,380
If you have any questions, hit
me up on discord or Twitter,

857
00:39:57,380 --> 00:40:00,840
or chuck me an email. Don't
forget to follow me on Twitter.

858
00:40:00,840 --> 00:40:02,040
Thank you for listening.

