1
00:00:01,270 --> 00:00:02,193
- Hello, everyone.

2
00:00:03,270 --> 00:00:05,310
Today we're going to talk
about Phantom Attack,

3
00:00:05,310 --> 00:00:07,470
evading the system call monitoring.

4
00:00:07,470 --> 00:00:09,503
My name is Rex.
- My name's Junyuan.

5
00:00:19,450 --> 00:00:23,573
- Imagine an attacker compromise
your Linux infrastructure.

6
00:00:24,460 --> 00:00:28,201
So the attacker first compromise a web app

7
00:00:28,201 --> 00:00:31,200
through a web app remote call execution,

8
00:00:31,200 --> 00:00:33,100
and then he launches as reverse shell.

9
00:00:35,930 --> 00:00:39,400
Then they discovered a
vulnerability on the system,

10
00:00:39,400 --> 00:00:42,150
he can activate privileges

11
00:00:42,150 --> 00:00:45,080
using the sudo
vulnerability CVE-2021-3156.

12
00:00:50,690 --> 00:00:54,440
Then he's looking for
secrets on the system.

13
00:00:54,440 --> 00:00:56,333
So he read the /etc/shadow file.

14
00:00:58,270 --> 00:01:00,290
And then he discover additional

15
00:01:02,450 --> 00:01:04,030
lateral movement opportunities

16
00:01:04,030 --> 00:01:06,913
by reading the SSH process
environment variable.

17
00:01:09,210 --> 00:01:11,830
Then he lateral move to the second machine

18
00:01:11,830 --> 00:01:12,983
using SSH hijacking.

19
00:01:15,710 --> 00:01:18,400
As he is celebrating this moment,

20
00:01:18,400 --> 00:01:22,480
he discovered that his reverse
shell connection is gone,

21
00:01:22,480 --> 00:01:24,880
and it doesn't take him
too long to discover

22
00:01:24,880 --> 00:01:28,273
that his IP is completely blocked.

23
00:01:30,630 --> 00:01:33,420
Now let's take a look at
the other side of the story.

24
00:01:33,420 --> 00:01:35,100
While all this is happening,

25
00:01:35,100 --> 00:01:39,100
our security engineer has received

26
00:01:39,100 --> 00:01:43,560
a bunch of Slack messages
for the alerts generated

27
00:01:43,560 --> 00:01:48,253
by his latest cloud workload
protection software.

28
00:01:49,810 --> 00:01:53,250
And the reason that the
software can discover

29
00:01:53,250 --> 00:01:55,770
all of these activities precisely

30
00:01:55,770 --> 00:01:59,290
is because it monitors the system calls

31
00:01:59,290 --> 00:02:00,893
and other process-related data.

32
00:02:02,700 --> 00:02:03,933
So for example,

33
00:02:05,550 --> 00:02:08,580
when the attacker launches
the reverse shell,

34
00:02:08,580 --> 00:02:11,330
there will be a connect system call.

35
00:02:11,330 --> 00:02:13,130
And there may be additional system calls.

36
00:02:13,130 --> 00:02:16,383
Depends on the reverse shell that he uses.

37
00:02:17,800 --> 00:02:20,473
This is similar for the other activities.

38
00:02:21,640 --> 00:02:26,240
And through this talk we're going to use

39
00:02:26,240 --> 00:02:28,643
openat system call as an example.

40
00:02:29,890 --> 00:02:33,530
So let's take a look at how
one can use system calls

41
00:02:33,530 --> 00:02:34,980
and other process information

42
00:02:34,980 --> 00:02:39,980
to detect a attacker reads /etc/shadow.

43
00:02:43,290 --> 00:02:44,733
So here's an example rule.

44
00:02:46,260 --> 00:02:50,600
The rule is trying to
detect untrusted programs

45
00:02:50,600 --> 00:02:53,293
reads the /etc/shadow.

46
00:02:54,850 --> 00:02:57,250
Let me explain what the rule means.

47
00:02:57,250 --> 00:03:01,990
It detect that there is a
openat or open system call.

48
00:03:01,990 --> 00:03:03,423
What is the read permission,

49
00:03:04,430 --> 00:03:07,453
and the file name is equal to /etc/shadow.

50
00:03:08,650 --> 00:03:12,730
And also the program is
not in the allow list

51
00:03:14,620 --> 00:03:16,670
that allows to read the /etc/shadow file.

52
00:03:18,245 --> 00:03:19,770
So from this rule,

53
00:03:19,770 --> 00:03:24,770
it should be very obvious that the ability

54
00:03:24,780 --> 00:03:27,200
to precisely monitor system calls

55
00:03:27,200 --> 00:03:30,270
and other system correlated data

56
00:03:30,270 --> 00:03:34,707
is critical for the
detection for this attack.

57
00:03:38,240 --> 00:03:40,800
The agenda of this talk is we will talk

58
00:03:40,800 --> 00:03:44,350
about system call
monitoring in more detail.

59
00:03:44,350 --> 00:03:47,290
And then we'll talk
about the two open source

60
00:03:47,290 --> 00:03:49,640
system call monitoring
project that we analyze.

61
00:03:50,637 --> 00:03:52,300
And then we'll talk about
the first vulnerability,

62
00:03:52,300 --> 00:03:57,300
the TOCTOU issue, which we use
Phantom v1 attack to exploit.

63
00:03:58,210 --> 00:04:01,290
And then we'll talk about
the second vulnerability

64
00:04:01,290 --> 00:04:03,550
of semantic confusion issue,

65
00:04:03,550 --> 00:04:06,753
which we use Phantom v2 attack to exploit.

66
00:04:07,690 --> 00:04:11,093
And finally, we'll conclude
the talk with takeaways.

67
00:04:11,940 --> 00:04:14,870
With that, I will hand over to Junyuan

68
00:04:14,870 --> 00:04:16,770
to talk about the system call monitor.

69
00:04:20,970 --> 00:04:23,400
- Yeah, so as Rex mentioned,

70
00:04:23,400 --> 00:04:25,840
system called monitoring is very important

71
00:04:25,840 --> 00:04:28,610
to detect threats.

72
00:04:28,610 --> 00:04:30,760
So what is system call monitoring?

73
00:04:30,760 --> 00:04:35,270
We can define a technique to verify

74
00:04:35,270 --> 00:04:39,910
whether the application
system call coming forward

75
00:04:39,910 --> 00:04:44,610
to the rule that specify the
program behaviors at runtime.

76
00:04:44,610 --> 00:04:49,330
Here is the graph showing how
system call monitoring works.

77
00:04:49,330 --> 00:04:51,753
When application system call is invoked,

78
00:04:52,870 --> 00:04:55,390
system call code path is executed.

79
00:04:55,390 --> 00:04:58,160
If there are any hooks in a code path,

80
00:04:58,160 --> 00:05:00,500
the attach program will be called

81
00:05:00,500 --> 00:05:02,750
to collect subsequent data.

82
00:05:02,750 --> 00:05:05,360
For example, this is called arguments.

83
00:05:05,360 --> 00:05:08,850
The data are sent to user
space monitoring agent.

84
00:05:08,850 --> 00:05:12,970
The morning agent will check
if application system calls

85
00:05:12,970 --> 00:05:15,720
conform to the user-defined rules.

86
00:05:15,720 --> 00:05:18,083
If not the case, it may generate errors.

87
00:05:20,340 --> 00:05:23,340
So typically at least two
steps should be include

88
00:05:23,340 --> 00:05:25,317
for system call monitoring.

89
00:05:25,317 --> 00:05:28,130
On step is called syscall Interception,

90
00:05:28,130 --> 00:05:30,560
which is to get notified

91
00:05:30,560 --> 00:05:33,530
if target's doesn't call are invoked.

92
00:05:33,530 --> 00:05:35,690
In order to intercept system call,

93
00:05:35,690 --> 00:05:39,013
you can use tracepoint or raw_tracepoint.

94
00:05:39,013 --> 00:05:43,610
Both of them are static hook
placed in a kernel code.

95
00:05:43,610 --> 00:05:48,610
Raw tracepoints are eBPF
alternatives to standard tracepoint

96
00:05:49,770 --> 00:05:52,700
It's faster because it provides low access

97
00:05:52,700 --> 00:05:55,160
to the arguments without processing.

98
00:05:55,160 --> 00:05:57,150
For this call interception,

99
00:05:57,150 --> 00:05:59,787
the kernel provides two raw tracepoints,

100
00:05:59,787 --> 00:06:01,093
sys_enter and sys_exit.

101
00:06:02,432 --> 00:06:05,080
These raw tracepoint can
be called with functions,

102
00:06:05,080 --> 00:06:09,460
trace_sys_enter and
trace_sys_exit, respectively.

103
00:06:09,460 --> 00:06:12,190
The first arguments of this fashion

104
00:06:12,190 --> 00:06:14,480
are pt_register structure,

105
00:06:14,480 --> 00:06:19,360
saving user registers in
user kernel mode switching,

106
00:06:19,360 --> 00:06:22,400
and it includes system call arguments.

107
00:06:22,400 --> 00:06:25,263
The second parameters is syscall number.

108
00:06:26,240 --> 00:06:29,890
If any progress attached
to this raw tracepoint,

109
00:06:31,274 --> 00:06:34,323
it will be executed with the
same arguments as functions.

110
00:06:35,540 --> 00:06:37,287
Tracepoint has low overhead,

111
00:06:37,287 --> 00:06:39,853
but it only provides
a static interception.

112
00:06:42,070 --> 00:06:43,873
Different from tracepoint,

113
00:06:45,057 --> 00:06:49,440
kprobe or kretprobe provides
dynamic hook in the kernel.

114
00:06:49,440 --> 00:06:52,460
Using these, we can register the progress

115
00:06:52,460 --> 00:06:53,780
on kernel instructions.

116
00:06:53,780 --> 00:06:57,200
For example, on system call code path.

117
00:06:57,200 --> 00:06:59,670
When the instruction are executed,

118
00:06:59,670 --> 00:07:01,943
it will trigger register progress.

119
00:07:02,870 --> 00:07:05,650
Kprobe can be insert on almost

120
00:07:05,650 --> 00:07:07,640
any instructions in the kernel.

121
00:07:07,640 --> 00:07:11,400
However, kretprobe can only be insert

122
00:07:11,400 --> 00:07:13,823
in function entry and exit.

123
00:07:14,750 --> 00:07:16,680
Kprobe provides dynamic hook,

124
00:07:16,680 --> 00:07:19,550
but it's low compared to tracepoint.

125
00:07:19,550 --> 00:07:22,010
And you need to know exactly

126
00:07:22,010 --> 00:07:25,660
how data is placed on a stack or registers

127
00:07:25,660 --> 00:07:27,560
in order to read the system call data.

128
00:07:29,030 --> 00:07:31,510
You can also use the LD_PRELOAD trick

129
00:07:31,510 --> 00:07:35,660
to intercept system call, but
it's not working in all cases.

130
00:07:35,660 --> 00:07:40,546
For example, application
is statically compiled.

131
00:07:40,546 --> 00:07:42,540
Ptrace system call provides another way

132
00:07:42,540 --> 00:07:46,343
to intercept system call,
however the overhead is high.

133
00:07:48,630 --> 00:07:50,970
The second step of system call monitoring

134
00:07:50,970 --> 00:07:54,270
is called syscall data collection,

135
00:07:54,270 --> 00:07:56,433
which is to collect system call data.

136
00:07:58,306 --> 00:08:00,050
For example, system call arguments.

137
00:08:00,050 --> 00:08:03,380
After we are notified by simple events,

138
00:08:03,380 --> 00:08:05,730
the program used to
collect system call data

139
00:08:05,730 --> 00:08:07,323
is called tracing program.

140
00:08:08,310 --> 00:08:10,990
For example, you can
use the tracing program

141
00:08:10,990 --> 00:08:13,690
to collect system call arguments.

142
00:08:13,690 --> 00:08:15,170
As we mentioned before,

143
00:08:15,170 --> 00:08:17,860
tracing programs can
attach to different hooks,

144
00:08:17,860 --> 00:08:22,173
like tracepoint, raw_tracepoint,
kprobe, or kretprobe.

145
00:08:23,130 --> 00:08:24,570
When the hooks fire,

146
00:08:24,570 --> 00:08:27,423
tracing programs are
called to collect data.

147
00:08:29,030 --> 00:08:31,340
There are different ways to
implement tracing programs

148
00:08:31,340 --> 00:08:33,670
to collect system call data.

149
00:08:33,670 --> 00:08:36,330
You can use Linux-native mechanisms,

150
00:08:36,330 --> 00:08:39,490
like ftrace or perf_events.

151
00:08:39,490 --> 00:08:42,480
You can also implement the trace programs

152
00:08:42,480 --> 00:08:46,470
in kernel module or eBPF programs,

153
00:08:46,470 --> 00:08:49,853
which allow the execution
of a user code in a kernel.

154
00:08:52,620 --> 00:08:54,980
The open source projects,
Falco and Tracee,

155
00:08:54,980 --> 00:08:59,160
both used similar techniques
to monitor syscalls.

156
00:08:59,160 --> 00:09:02,400
Falco is originally created by Sysdig.

157
00:09:02,400 --> 00:09:06,210
It's one of the two security
and compliance projects

158
00:09:06,210 --> 00:09:09,520
and the only endpoint
security monitoring project

159
00:09:09,520 --> 00:09:13,140
in CNCF incubating projects.

160
00:09:13,140 --> 00:09:17,083
It has 3.9Ks GitHub stars.

161
00:09:18,000 --> 00:09:20,560
It actually consumes kernel events

162
00:09:20,560 --> 00:09:24,310
and enrich them with information
from cloud native stack,

163
00:09:24,310 --> 00:09:27,520
like Linux containers and so on.

164
00:09:27,520 --> 00:09:32,520
Falco supports both eBPF and
kernel module implementation

165
00:09:32,910 --> 00:09:34,110
for the tracing program.

166
00:09:35,132 --> 00:09:36,540
Tracee, on the other hand,

167
00:09:36,540 --> 00:09:40,280
is originally created by Aqua Security.

168
00:09:40,280 --> 00:09:43,393
It has 1.1K GitHub stars.

169
00:09:44,410 --> 00:09:46,440
It's basically a runtime security

170
00:09:46,440 --> 00:09:48,923
and forensics tool based on eBPF.

171
00:09:51,110 --> 00:09:53,510
So unfortunately, the open source projects

172
00:09:53,510 --> 00:09:56,510
or other projects using
similar techniques,

173
00:09:56,510 --> 00:10:00,700
are vulnerable to be attack
during syscall monitoring.

174
00:10:00,700 --> 00:10:04,540
The first vulnerability is
time-of-check, time-of-use.

175
00:10:04,540 --> 00:10:08,603
During time-of-check, tracing
programs collect syscall data.

176
00:10:09,590 --> 00:10:13,490
During time-of-use, syscall
data used by its kernel

177
00:10:13,490 --> 00:10:16,953
is different from what
tracing program check.

178
00:10:17,930 --> 00:10:20,630
Let's take openat system call for example.

179
00:10:20,630 --> 00:10:23,510
The second parameter is called finding,

180
00:10:23,510 --> 00:10:27,660
which is the pointer
pointing to user space buffer

181
00:10:27,660 --> 00:10:30,800
between time-of-check and time-of-use.

182
00:10:30,800 --> 00:10:34,823
This pointer is vulnerable to
be modified from user space.

183
00:10:36,460 --> 00:10:39,230
So we do introduce Phantom v1 attack,

184
00:10:39,230 --> 00:10:43,143
that can exploit the TOCTOU issue.

185
00:10:44,120 --> 00:10:47,290
The second vulnerability
is semantic confusion.

186
00:10:47,290 --> 00:10:51,010
It means kernel interprets
data differently

187
00:10:51,010 --> 00:10:52,940
from tracing programs.

188
00:10:52,940 --> 00:10:57,560
For example, symbolic link
is interpreted differently

189
00:10:57,560 --> 00:10:59,903
by the kernel and tracing programs.

190
00:11:01,230 --> 00:11:04,230
You can also introduce Phantom v2 attack

191
00:11:04,230 --> 00:11:07,663
that can exploit semantic confusion.

192
00:11:09,362 --> 00:11:12,460
We will also demonstrate
Falco is vulnerable

193
00:11:12,460 --> 00:11:15,650
to both Phantom v1 and v2 attack,

194
00:11:15,650 --> 00:11:18,763
while Tracee is only
vulnerable to Phantom v1.

195
00:11:21,290 --> 00:11:23,610
In order to understand TOCTOU,

196
00:11:23,610 --> 00:11:25,913
we used openat system call for example.

197
00:11:26,770 --> 00:11:30,150
We used kernel version 5.4.0,

198
00:11:30,150 --> 00:11:32,860
but regardless of the kernel version,

199
00:11:32,860 --> 00:11:37,830
if the monitoring software
use tracepoint in this way,

200
00:11:37,830 --> 00:11:39,933
the TOCTOU vulnerability will exist.

201
00:11:41,207 --> 00:11:43,940
To simplify, we only show the code

202
00:11:43,940 --> 00:11:46,193
that is related to that tech.

203
00:11:47,380 --> 00:11:50,987
When openat system call is
invoked in applications,

204
00:11:50,987 --> 00:11:55,987
syscall handler execute
trace_sys_enter function

205
00:11:56,170 --> 00:11:59,110
with two arguments, as
we mentioned before.

206
00:11:59,110 --> 00:12:02,300
If any tracing program attached
to this sys_enter tracepoint

207
00:12:04,240 --> 00:12:06,820
the program will be executed.

208
00:12:06,820 --> 00:12:11,320
After that, syscall handler
look up syscall table

209
00:12:11,320 --> 00:12:15,100
and jump to openat system
call to open the file.

210
00:12:15,100 --> 00:12:17,610
Before return them to applications,

211
00:12:17,610 --> 00:12:20,160
the handler will call trace_sys_exit

212
00:12:20,160 --> 00:12:24,127
with exactly the same
arguments as trace_sys_enter.

213
00:12:25,010 --> 00:12:27,980
So similarly, if there
are any tracing programs

214
00:12:27,980 --> 00:12:29,730
attached to sys_exit at tracepoint,

215
00:12:32,100 --> 00:12:34,093
the program will be executed.

216
00:12:36,110 --> 00:12:37,210
As we mentioned before,

217
00:12:37,210 --> 00:12:39,580
the second argument of openat system call

218
00:12:39,580 --> 00:12:44,290
is filename pointer pointing
to the user space memory.

219
00:12:44,290 --> 00:12:47,460
The filename is passed
through do_filp_open function

220
00:12:47,460 --> 00:12:51,300
and the kernel copy it
to kernel buffer temp

221
00:12:51,300 --> 00:12:52,733
using getname function.

222
00:12:53,670 --> 00:12:56,890
After that, kernel use the kernel buffer

223
00:12:56,890 --> 00:13:01,890
to call internal function,
do_file_open, to open the file.

224
00:13:02,590 --> 00:13:06,293
This is time-of-use for system
call arguments by the kernel.

225
00:13:08,830 --> 00:13:11,820
If we divide the openat
system call code path

226
00:13:11,820 --> 00:13:15,660
into two parts based on
the getname function,

227
00:13:15,660 --> 00:13:20,030
you get two step copass, CP1, copass one,

228
00:13:20,030 --> 00:13:22,550
and CP2, copass two.

229
00:13:22,550 --> 00:13:24,850
In CP1, the filename pointer

230
00:13:24,850 --> 00:13:28,310
hasn't been copied to the kernel buffer.

231
00:13:28,310 --> 00:13:32,123
In this case, no matter where
we place the hooks in CP1,

232
00:13:33,370 --> 00:13:34,920
the attached tracing program

233
00:13:34,920 --> 00:13:37,240
will have to read user space buffer

234
00:13:37,240 --> 00:13:39,451
in order to get the filename.

235
00:13:39,451 --> 00:13:42,853
This is vulnerable to be
changed in user space attacker.

236
00:13:44,410 --> 00:13:48,160
For example, if we attach tracing program

237
00:13:48,160 --> 00:13:51,597
to sys_enter tracepoint or
to do_sys_open using kprobe,

238
00:13:54,560 --> 00:13:57,020
during time-of-check the tracing program

239
00:13:57,020 --> 00:14:00,423
will have to read the user space
buffer to get the filename.

240
00:14:01,711 --> 00:14:05,840
In CB2, user space memory has been copied

241
00:14:05,840 --> 00:14:07,290
to the kernel buffer,

242
00:14:07,290 --> 00:14:11,113
making it not vulnerable to
be changed from user space.

243
00:14:12,890 --> 00:14:15,990
For example, if we attach tracing program

244
00:14:15,990 --> 00:14:19,713
to the entry of do_file_open
function using kprobe,

245
00:14:20,920 --> 00:14:23,780
the tracing program can
read a kernel buffer tab

246
00:14:23,780 --> 00:14:25,530
to get the filename.

247
00:14:25,530 --> 00:14:27,390
That's kernel buffer is not vulnerable

248
00:14:27,390 --> 00:14:29,483
to be changed for a TOCTOU attack.

249
00:14:31,640 --> 00:14:35,260
However, if the hook are
placed improperly in CB2,

250
00:14:35,260 --> 00:14:38,023
TOCTOU is still possible.

251
00:14:38,970 --> 00:14:41,400
For example, if tracing programs

252
00:14:41,400 --> 00:14:43,033
attached to a sys_exit tracepoint,

253
00:14:44,047 --> 00:14:47,423
it will read the user space
buffer to get filename.

254
00:14:48,270 --> 00:14:52,803
If, as we mentioned before,
we use kernel version 5.4.0,

255
00:14:54,440 --> 00:14:56,820
but regardless of the kernel version,

256
00:14:56,820 --> 00:15:01,060
if the monitoring software use
the tracepoint in this way,

257
00:15:01,060 --> 00:15:02,930
this vulnerability will exist.

258
00:15:05,660 --> 00:15:08,323
Falco is the vulnerable to TOCTOU,

259
00:15:09,329 --> 00:15:13,240
and the vulnerability is
tracked by CVE-2021-33505,

260
00:15:16,973 --> 00:15:18,640
with a score of 7.3.

261
00:15:19,744 --> 00:15:24,480
In particular, the
vulnerability exist for Falco

262
00:15:24,480 --> 00:15:29,480
is a version older than
0.29.0, or open source sysdig.

263
00:15:31,780 --> 00:15:34,710
It also affects our
commercial versions space

264
00:15:34,710 --> 00:15:37,670
on the open source agent.

265
00:15:37,670 --> 00:15:40,070
This was confirmed by an
open source maintainer.

266
00:15:41,790 --> 00:15:44,683
Please contact the vendor for divergence.

267
00:15:47,050 --> 00:15:50,800
The reason why Falco is
vulnerable to TOCTOU vulnerability

268
00:15:50,800 --> 00:15:54,740
is that it use sys_enter
and sys_ext access point

269
00:15:54,740 --> 00:15:56,863
to intercept system calls.

270
00:15:58,130 --> 00:16:02,560
In that case, user space
pointers are read directory

271
00:16:02,560 --> 00:16:06,620
by Falco trace program
in both kernel module

272
00:16:06,620 --> 00:16:09,133
and eBPF progress implementations.

273
00:16:12,390 --> 00:16:15,930
In order to demonstrate
the generality of TOCTOU,

274
00:16:15,930 --> 00:16:19,420
we evaluate the syscalls
in front of rules.

275
00:16:19,420 --> 00:16:22,330
Just know that we only
can see the system calls,

276
00:16:22,330 --> 00:16:24,940
that includes use of
pointers as arguments,

277
00:16:24,940 --> 00:16:26,313
like openat system call.

278
00:16:28,150 --> 00:16:30,867
And we found that Falco is vulnerable

279
00:16:30,867 --> 00:16:34,580
to most of these calls that we evaluate,

280
00:16:34,580 --> 00:16:37,600
except execve system call.

281
00:16:37,600 --> 00:16:40,620
Because Falco doesn't read user pointer

282
00:16:40,620 --> 00:16:44,290
for execve system call arguments directly.

283
00:16:44,290 --> 00:16:48,493
Instead it read the data
from kernel in a structure.

284
00:16:51,360 --> 00:16:55,240
So we evaluate the Tracee 0.4.0.

285
00:16:55,240 --> 00:16:57,270
And we found that it's vulnerable

286
00:16:57,270 --> 00:17:02,270
to many system calls,
like connect system call.

287
00:17:03,054 --> 00:17:04,350
One of the thing I need to mention

288
00:17:04,350 --> 00:17:09,350
is there's no CBE given because
the Tracee ask us mentioned

289
00:17:11,470 --> 00:17:15,750
that TOCTOU attacks on
syscall wrappers or tracer

290
00:17:15,750 --> 00:17:20,750
is a well-known issue, and
Tracee is no exception.

291
00:17:21,570 --> 00:17:23,768
And also agrees on the fact

292
00:17:23,768 --> 00:17:26,580
that there's no CVE or novel findings,

293
00:17:26,580 --> 00:17:29,623
and therefore you could
talk about it publicly.

294
00:17:30,490 --> 00:17:32,523
I will let the audience to interpret.

295
00:17:33,620 --> 00:17:36,140
So I will hand over to Rex to explain

296
00:17:36,140 --> 00:17:38,603
and demo Phantom v1 attack.

297
00:17:42,540 --> 00:17:47,540
- All right, so the high-level idea

298
00:17:48,840 --> 00:17:53,223
to exploit the TOCTOU
issue is fairly simple.

299
00:17:54,250 --> 00:17:56,020
So first of all, we want to trigger

300
00:17:56,020 --> 00:17:59,193
the target system call
with malicious arguments.

301
00:18:00,220 --> 00:18:04,500
And we'll let the kernel to
read the malicious argument

302
00:18:04,500 --> 00:18:07,463
and perform the intended
malicious action for us.

303
00:18:08,900 --> 00:18:10,930
After the kernel reads it,

304
00:18:10,930 --> 00:18:12,930
we will override the data structure

305
00:18:12,930 --> 00:18:16,563
pointed by the user space
argument pointer with benign data.

306
00:18:17,590 --> 00:18:22,590
And at sys_exit the tracing
program reads a data structure

307
00:18:22,880 --> 00:18:24,540
pointed by the user space pointer

308
00:18:25,610 --> 00:18:28,190
and checks the benign
data against the rule,

309
00:18:28,190 --> 00:18:29,743
and therefore it will not fire.

310
00:18:32,310 --> 00:18:35,070
Although the high level
plan sounds simple,

311
00:18:35,070 --> 00:18:37,430
there is a few technical challenges

312
00:18:37,430 --> 00:18:38,680
that we need to overcome.

313
00:18:39,710 --> 00:18:43,363
First one is when does
the kernel thread read it,

314
00:18:44,450 --> 00:18:47,570
and how can we synchronize the override

315
00:18:47,570 --> 00:18:48,933
with the kernels that read?

316
00:18:50,610 --> 00:18:53,470
Are the racing windows big enough

317
00:18:53,470 --> 00:18:55,970
for these system calls
that we're going to attack?

318
00:18:56,920 --> 00:18:59,870
And how do we ensure the tracing program

319
00:18:59,870 --> 00:19:02,573
gets the overwritten copy on time?

320
00:19:07,750 --> 00:19:11,853
So before I dive into the
step-by-step exploitation,

321
00:19:13,160 --> 00:19:15,720
there are a few primitives
that we use in the exploit

322
00:19:15,720 --> 00:19:17,153
which I want to talk about.

323
00:19:18,370 --> 00:19:20,733
First one is Userfaultfd system call.

324
00:19:21,850 --> 00:19:24,140
The system call is designed in a way

325
00:19:24,140 --> 00:19:29,073
that a user thread can handle page fault.

326
00:19:30,240 --> 00:19:32,940
But page fault is traditionally
handled by the kernel.

327
00:19:34,170 --> 00:19:38,423
So what's the initial
design intentions of this?

328
00:19:39,470 --> 00:19:42,163
This was designed for
memory externalization.

329
00:19:43,589 --> 00:19:47,563
In the case where you're
running a distributed program,

330
00:19:48,520 --> 00:19:51,513
you can run compute
nodes and memory nodes.

331
00:19:52,600 --> 00:19:56,460
When the compute node
needs a particular memory

332
00:19:56,460 --> 00:19:59,170
that doesn't exist in the compute node,

333
00:19:59,170 --> 00:20:01,560
the kernel triggers the page fault

334
00:20:01,560 --> 00:20:05,040
and the user space fault handler.

335
00:20:05,040 --> 00:20:07,290
It's going to reach out to the memory node

336
00:20:07,290 --> 00:20:08,923
to get the desirable memory.

337
00:20:09,940 --> 00:20:13,780
On the other hand, if the
compute node has memory pressure,

338
00:20:13,780 --> 00:20:16,330
it will send those memory
pages back to the memory.

339
00:20:17,770 --> 00:20:20,650
One very important fact about Userfaultfd

340
00:20:20,650 --> 00:20:25,650
is that once the kernel thread
triggers the page fault,

341
00:20:25,920 --> 00:20:28,470
the kernel thread is completely paused

342
00:20:28,470 --> 00:20:31,733
and wait for the user
space program to respond.

343
00:20:33,050 --> 00:20:38,050
As some of you may already be aware of,

344
00:20:38,300 --> 00:20:41,540
this has been used quite a bit

345
00:20:41,540 --> 00:20:43,963
in exploiting kernel race condition bugs.

346
00:20:47,660 --> 00:20:49,810
The other tool primitive
I want to talk about,

347
00:20:49,810 --> 00:20:54,450
one is interrupts and the
other one is scheduling.

348
00:20:54,450 --> 00:20:57,810
So an interrupt notifies
the processor with an event

349
00:20:57,810 --> 00:20:59,510
that requires immediate attention.

350
00:21:00,630 --> 00:21:02,760
It will diverge the program control flow

351
00:21:02,760 --> 00:21:04,223
to an interrupt handler.

352
00:21:05,630 --> 00:21:10,030
Let's look at the picture
on the right side.

353
00:21:10,030 --> 00:21:13,770
So we have two cores and we have two tasks

354
00:21:13,770 --> 00:21:16,553
running on each core corresponding.

355
00:21:17,410 --> 00:21:20,867
On Core 0, Task_A issues a Syscall_A,

356
00:21:21,980 --> 00:21:24,850
and then the control flow
transfer to the kernel thread

357
00:21:24,850 --> 00:21:27,093
to handle the system call.

358
00:21:28,080 --> 00:21:33,080
While it is running, the
user thread on the Core 1

359
00:21:34,080 --> 00:21:38,616
triggers an interrupt and the
way it triggers the interrupt

360
00:21:38,616 --> 00:21:42,483
is indirect interrupt using system call.

361
00:21:43,640 --> 00:21:45,890
Once the interrupt is triggered,

362
00:21:45,890 --> 00:21:50,890
its Core 0 will execute
the interrupt handler.

363
00:21:51,040 --> 00:21:53,710
And after the interrupt is handled,

364
00:21:53,710 --> 00:21:57,150
it will return back to
the system call routine

365
00:21:57,150 --> 00:21:58,913
which handles the system call.

366
00:22:01,610 --> 00:22:03,320
So there are different ways

367
00:22:03,320 --> 00:22:05,570
to indirectly trigger a system call,

368
00:22:05,570 --> 00:22:08,503
indirectly trigger
interrupt using system call.

369
00:22:10,400 --> 00:22:13,200
One way to do it is to
trigger a hardware interrupt.

370
00:22:13,200 --> 00:22:16,970
So this can happen when a program issues

371
00:22:16,970 --> 00:22:18,400
a connect system call.

372
00:22:18,400 --> 00:22:21,980
The CPU that is dedicated
to handle network interrupt

373
00:22:21,980 --> 00:22:23,770
will get interrupted.

374
00:22:23,770 --> 00:22:25,510
Another way to trigger this interrupt

375
00:22:25,510 --> 00:22:28,060
is called inter-processor interrupt.

376
00:22:28,060 --> 00:22:30,763
This can be done by issuing
end protect system call.

377
00:22:31,660 --> 00:22:36,660
So once the end protect is issue,

378
00:22:37,920 --> 00:22:42,660
the memory page permission has changed,

379
00:22:42,660 --> 00:22:45,800
and therefore all the
CPUs that are caching

380
00:22:45,800 --> 00:22:49,313
those memory permissions
need to be updated

381
00:22:49,313 --> 00:22:50,973
with the right memory permission.

382
00:22:53,930 --> 00:22:58,930
The scheduling primitive that
we use, one is a scheduler.

383
00:22:59,000 --> 00:23:01,140
This will change the scheduling priority

384
00:23:02,090 --> 00:23:04,663
of a particular task.

385
00:23:06,170 --> 00:23:08,070
This is optional in the exploit

386
00:23:09,670 --> 00:23:13,040
because for system calls
with a longer TOCTOU window,

387
00:23:13,040 --> 00:23:15,090
such as networking system calls,

388
00:23:15,090 --> 00:23:18,160
we find that it's not needed

389
00:23:18,160 --> 00:23:21,490
to reliably exploit the TOCTOU issue.

390
00:23:21,490 --> 00:23:26,130
But with system calls related to files,

391
00:23:26,130 --> 00:23:28,740
the TOCTOU window is typically smaller.

392
00:23:28,740 --> 00:23:30,810
And with the capability,

393
00:23:30,810 --> 00:23:35,687
we can a hundred percent reliably
exploit the TOCTOU issue.

394
00:23:37,810 --> 00:23:41,060
And then the second primitive
we use is set affinity,

395
00:23:41,060 --> 00:23:44,350
which will pin a task to a particular CPU.

396
00:23:49,410 --> 00:23:51,290
Okay, so let me talk about

397
00:23:51,290 --> 00:23:54,563
the step-by-step exploitation in detail.

398
00:23:57,070 --> 00:23:59,260
Initially, we need to do some setup.

399
00:23:59,260 --> 00:24:01,763
So we set up three threads, a main thread,

400
00:24:02,780 --> 00:24:04,853
a userfaultfd thread,

401
00:24:05,710 --> 00:24:10,710
the userfaultfd thread can run on any CPU,

402
00:24:11,580 --> 00:24:13,783
and also an override thread.

403
00:24:15,100 --> 00:24:17,180
So the main thread will pin to CPU 3.

404
00:24:18,530 --> 00:24:23,440
The choice of three here is
because we run our experiment,

405
00:24:23,440 --> 00:24:26,540
one of our experiments
on a four core system,

406
00:24:26,540 --> 00:24:31,540
and CPU 3 is used to handle
the networking interrupt.

407
00:24:31,830 --> 00:24:36,247
But if you're using IPI
interrupt, it can be any CPU.

408
00:24:39,810 --> 00:24:44,640
And then the main thread
will map a memory page A.

409
00:24:44,640 --> 00:24:48,913
The page is not allocated
and it will register

410
00:24:48,913 --> 00:24:51,500
a userfaultfd thread to
handle the page fault

411
00:24:51,500 --> 00:24:52,860
generated for this page.

412
00:24:56,446 --> 00:25:01,446
On the override thread side
we pin it to a different CPU

413
00:25:01,730 --> 00:25:03,780
because we want to reduce the interference

414
00:25:03,780 --> 00:25:07,823
between the override
thread and the main thread.

415
00:25:10,800 --> 00:25:12,890
And then the override
thread will just block

416
00:25:12,890 --> 00:25:15,563
on condition mutex once it start.

417
00:25:17,680 --> 00:25:22,680
After the setup, the main thread
will trigger a system call,

418
00:25:22,900 --> 00:25:24,900
in this case openat,

419
00:25:24,900 --> 00:25:27,720
and it will specify the filename argument

420
00:25:27,720 --> 00:25:29,463
to point to page A.

421
00:25:30,590 --> 00:25:33,160
Now keep in mind that
page A, at this point,

422
00:25:33,160 --> 00:25:35,030
is not allocated.

423
00:25:35,030 --> 00:25:39,503
And so the kernel thread
would trigger a page fault.

424
00:25:42,649 --> 00:25:44,630
Once the the page fault is triggered,

425
00:25:44,630 --> 00:25:49,380
the userfaultfd thread will write page A

426
00:25:49,380 --> 00:25:51,130
with the malicious filename

427
00:25:52,680 --> 00:25:54,930
and then it will release
the condition mutex.

428
00:25:57,370 --> 00:25:59,930
And then it will issue out a system call

429
00:25:59,930 --> 00:26:02,133
to return execution back to the kernel.

430
00:26:04,210 --> 00:26:07,470
Now, once the conditional
mutex is released,

431
00:26:07,470 --> 00:26:10,090
the override thread must start running.

432
00:26:10,090 --> 00:26:14,963
And it will first write
a benign file name.

433
00:26:20,770 --> 00:26:22,483
In the last stage of the attack,

434
00:26:23,661 --> 00:26:28,566
once execution returned
back to the kernel,

435
00:26:28,566 --> 00:26:31,210
the kernel will use copy_from_user

436
00:26:31,210 --> 00:26:34,013
and you will get the malicious pathname.

437
00:26:35,000 --> 00:26:36,333
This is a time-of-check.

438
00:26:38,390 --> 00:26:43,390
And it keeps executing until a sys_exit.

439
00:26:46,220 --> 00:26:48,470
The trace program will read the register

440
00:26:48,470 --> 00:26:52,520
and reference the file name value again.

441
00:26:52,520 --> 00:26:53,820
This is the time-of-check.

442
00:26:54,920 --> 00:26:59,150
So this is the TOCTOU window we have.

443
00:26:59,150 --> 00:27:03,440
And let's see how we can
use the override thread

444
00:27:03,440 --> 00:27:05,683
to make this override successful.

445
00:27:09,662 --> 00:27:11,530
After it writes a benign name,

446
00:27:11,530 --> 00:27:16,530
we issue a memory consistency
update using CPU instructions.

447
00:27:16,990 --> 00:27:21,990
And as the memory consistency
update takes place,

448
00:27:24,410 --> 00:27:27,300
we want to increase the TOCTOU window

449
00:27:27,300 --> 00:27:29,750
such that we have enough
time to update the value

450
00:27:30,660 --> 00:27:31,693
for all the CPUs.

451
00:27:32,670 --> 00:27:35,690
So what we do is that he will issue

452
00:27:35,690 --> 00:27:39,963
a interrupt using system calls.

453
00:27:41,950 --> 00:27:45,083
And this will increase
the TOCTOU window size.

454
00:27:46,660 --> 00:27:50,313
And then the memory
consistency update applies.

455
00:27:52,000 --> 00:27:56,640
So the filename now points
will be a benign filename.

456
00:27:56,640 --> 00:27:58,137
And then the tracing program will read out

457
00:27:58,137 --> 00:28:01,050
the benign filename and
check it against the rule,

458
00:28:01,050 --> 00:28:02,093
which will not fire.

459
00:28:05,330 --> 00:28:07,230
And now let's take a look at the demo.

460
00:28:20,460 --> 00:28:24,953
Okay, so in our first demo,
we're going to attack Sysdig

461
00:28:27,750 --> 00:28:30,443
using connect system call, as an example.

462
00:28:31,720 --> 00:28:34,897
So what we'll do is we will run Sysdig,

463
00:28:36,200 --> 00:28:38,700
and ask it to monitor connect system call,

464
00:28:38,700 --> 00:28:41,603
and just filter the data
on our attack program.

465
00:28:42,840 --> 00:28:45,650
And then on another window
we will use TCP dump

466
00:28:45,650 --> 00:28:48,323
to monitor all traffic going to port 80.

467
00:28:50,210 --> 00:28:52,060
And now we'll run our attack program.

468
00:28:53,410 --> 00:28:58,270
The attack program, it
will connect 1.1.1.1,

469
00:29:00,050 --> 00:29:03,360
then you will override this IP address

470
00:29:03,360 --> 00:29:06,267
with a IP address from LinkedIn.com.

471
00:29:08,260 --> 00:29:10,590
Okay, so we can see that the TCP dump

472
00:29:10,590 --> 00:29:13,253
report traffic actually go into 1.1.1.1.

473
00:29:14,990 --> 00:29:16,653
This is what happens on the wire.

474
00:29:19,990 --> 00:29:21,110
Let's just stay where we port at.

475
00:29:21,110 --> 00:29:23,577
Okay, this program, attack_connect,

476
00:29:24,560 --> 00:29:28,680
is actually connecting to 13.107.42.14,

477
00:29:28,680 --> 00:29:31,703
which is the IP address
on my LinkedIn.com.

478
00:29:33,150 --> 00:29:36,810
And therefore we showed
that we can write this

479
00:29:37,645 --> 00:29:38,963
with arbitrary value.

480
00:29:51,320 --> 00:29:54,760
Okay, so now we'll show a second demo.

481
00:29:54,760 --> 00:29:57,400
In this demo, we'll
show an attack on Sysdig

482
00:29:57,400 --> 00:29:58,943
on the openat system call.

483
00:30:00,010 --> 00:30:03,950
Now our demo set up is slightly different.

484
00:30:03,950 --> 00:30:08,460
So for openat, the TOCTOU window is small.

485
00:30:08,460 --> 00:30:13,350
So if we don't use a Capsis nice,

486
00:30:13,350 --> 00:30:15,683
sometimes the attack will fail.

487
00:30:17,470 --> 00:30:20,790
But if we are assigned Capsis nice,

488
00:30:20,790 --> 00:30:24,713
we can achieve 100% reliable exploitation.

489
00:30:26,680 --> 00:30:30,510
Keep in mind that because
the override thread

490
00:30:30,510 --> 00:30:32,570
has the highest scheduling priority.

491
00:30:32,570 --> 00:30:36,973
So sometimes you can
write the filename faster

492
00:30:39,230 --> 00:30:42,160
than the kernel reads it.

493
00:30:42,160 --> 00:30:45,520
So when that happens the system call

494
00:30:45,520 --> 00:30:47,003
will get the benign filename,

495
00:30:47,910 --> 00:30:51,110
and the Sysdig will also
get the benign filename,

496
00:30:51,110 --> 00:30:53,350
so there's no harm being done,

497
00:30:53,350 --> 00:30:55,203
and no alert being fired as well.

498
00:30:58,710 --> 00:31:00,860
And therefore we've run the experiment

499
00:31:00,860 --> 00:31:03,133
15 times using our script.

500
00:31:03,970 --> 00:31:07,957
And each time we check
what is the syscall rate

501
00:31:09,038 --> 00:31:10,933
and what does Sysdig read.

502
00:31:11,980 --> 00:31:14,570
And then we'll compute the results

503
00:31:14,570 --> 00:31:17,053
based on each observation.

504
00:31:19,480 --> 00:31:21,820
So what we'll do is we'll print out

505
00:31:22,980 --> 00:31:26,240
the number of success attack,

506
00:31:26,240 --> 00:31:30,240
the number of attack that has no harm,

507
00:31:30,240 --> 00:31:31,790
and also the success rate.

508
00:31:43,480 --> 00:31:45,493
Okay, so as you can see here,

509
00:31:46,530 --> 00:31:51,360
in the 15 experiment we succeed
three times, no failure,

510
00:31:51,360 --> 00:31:53,433
and 12 times there's no harm.

511
00:31:55,480 --> 00:31:59,293
And therefore, the success rate is 100%.

512
00:32:17,100 --> 00:32:21,970
Okay, so lastly, we'll show
a demo on Tracee as well.

513
00:32:21,970 --> 00:32:25,700
And here we'll attack a
connect call in Tracee.

514
00:32:25,700 --> 00:32:27,480
The attack set up is very similar

515
00:32:27,480 --> 00:32:30,070
to what we have for the Sysdig.

516
00:32:30,070 --> 00:32:33,620
Again, Tracee will monitor
the connect system call

517
00:32:33,620 --> 00:32:36,990
and will just filter the
data on our attack program,

518
00:32:36,990 --> 00:32:38,580
reported by Tracee.

519
00:32:38,580 --> 00:32:41,310
And then have TCP dump
monitoring on port 80.

520
00:32:41,310 --> 00:32:43,080
And then we run the attack.

521
00:32:43,080 --> 00:32:46,150
As you can see, the actual traffic

522
00:32:46,150 --> 00:32:48,890
going on the wire is going to 1.1.1.1.

523
00:32:52,344 --> 00:32:55,027
But Tracee reported that the traffic

524
00:32:56,109 --> 00:33:01,109
is going to 13.107.42.14,
which was overwritten by us.

525
00:33:14,760 --> 00:33:18,810
I just want to reiterate that
the CAP_SYS_NICE is optional.

526
00:33:18,810 --> 00:33:22,750
It depends on the system
call that you are attacking.

527
00:33:22,750 --> 00:33:26,590
And for networking system calls

528
00:33:26,590 --> 00:33:28,020
typically this is not needed.

529
00:33:28,020 --> 00:33:31,200
And for file base,
typically this is needed

530
00:33:31,200 --> 00:33:33,713
to achieve a 100% reliable exploitation.

531
00:33:37,685 --> 00:33:39,670
And then I'll talk
about the second attack,

532
00:33:39,670 --> 00:33:41,023
the semantic confusion.

533
00:33:41,900 --> 00:33:44,203
The idea of the attack is fairly simple.

534
00:33:46,240 --> 00:33:48,390
The kernel and the tracing program

535
00:33:48,390 --> 00:33:50,023
can interpret data differently.

536
00:33:51,110 --> 00:33:55,900
So we use file link as an example.

537
00:33:55,900 --> 00:33:59,760
When the kernel reads a link,

538
00:33:59,760 --> 00:34:03,593
it will try to resolve the
link and read the actual file.

539
00:34:04,670 --> 00:34:07,450
But when the tracing
program read the link,

540
00:34:07,450 --> 00:34:10,760
it will just take the link as the argument

541
00:34:10,760 --> 00:34:13,280
and use that to track in the...

542
00:34:13,280 --> 00:34:16,540
So Falco is vulnerable to
this semantic confusion attack

543
00:34:18,060 --> 00:34:23,060
because it didn't resolve
the link in the system call.

544
00:34:25,080 --> 00:34:27,950
There's no CVE given
because they mentioned

545
00:34:27,950 --> 00:34:31,840
that symlink and
symlinkat, link and linkat

546
00:34:31,840 --> 00:34:34,590
are all monitored by Falco.

547
00:34:34,590 --> 00:34:38,390
But practically, detection
team need to track

548
00:34:38,390 --> 00:34:43,350
all these links at or link, linkat

549
00:34:43,350 --> 00:34:44,750
to all these file-based rules

550
00:34:44,750 --> 00:34:46,300
if the attacker is using those.

551
00:34:47,440 --> 00:34:49,410
And Tracee is not
vulnerable to this attack,

552
00:34:49,410 --> 00:34:53,730
because it uses a mitigation in RSM hook,

553
00:34:53,730 --> 00:34:56,313
which are Junyuan will
talk more in a later slide.

554
00:34:58,840 --> 00:35:00,660
So I just want to quickly show the example

555
00:35:00,660 --> 00:35:04,440
of Phantom v2 attack in Sysdig.

556
00:35:04,440 --> 00:35:07,940
Remember this rule that we talk
about at the very beginning.

557
00:35:07,940 --> 00:35:12,200
And see that the filename, actually,

558
00:35:12,200 --> 00:35:16,590
we checked whether the
filename is /etc/shadow, okay?

559
00:35:16,590 --> 00:35:18,437
So in order to exploit this,

560
00:35:18,437 --> 00:35:20,870
we can create a file link, /tmp/shadow,

561
00:35:20,870 --> 00:35:23,030
pointing to /etc/shadow.

562
00:35:23,030 --> 00:35:24,690
And then the tracing program will read

563
00:35:24,690 --> 00:35:26,223
the same link, /etc/shadow.

564
00:35:27,830 --> 00:35:31,890
And then the system call
openat sees the /tmp/shadow

565
00:35:31,890 --> 00:35:33,720
and track against the rule.

566
00:35:33,720 --> 00:35:35,000
It doesn't match /etc/shadow,

567
00:35:35,000 --> 00:35:38,000
and therefore the rule is bypass, okay?

568
00:35:38,000 --> 00:35:39,840
So with that, I will
hand over back to Junyuan

569
00:35:39,840 --> 00:35:41,773
to talk about mitigations.

570
00:35:45,190 --> 00:35:47,554
- Yeah, so for mitigations,

571
00:35:47,554 --> 00:35:52,490
there are basically two approach
for the Phantom attacks.

572
00:35:52,490 --> 00:35:56,930
So one is to detect the
potential exploit is happening.

573
00:35:56,930 --> 00:36:01,930
This was proposed and partially
implemented by Falco team.

574
00:36:02,050 --> 00:36:06,880
It has include in Falco's
release in version 0.29.0.

575
00:36:08,640 --> 00:36:10,510
Basically it's trying to detect

576
00:36:10,510 --> 00:36:14,490
the variant behaviors used by the exploit.

577
00:36:14,490 --> 00:36:18,910
For example, it detects the privileges use

578
00:36:18,910 --> 00:36:21,770
of userfaultfd system call.

579
00:36:21,770 --> 00:36:25,410
This was implemented and detect

580
00:36:25,410 --> 00:36:28,430
a user register's memory address range,

581
00:36:28,430 --> 00:36:33,430
and also detect a user copying
a continuous memory chunk

582
00:36:33,480 --> 00:36:37,390
into a use of the
register range, and so on.

583
00:36:37,390 --> 00:36:39,710
The second way to mitigate Phantom attacks

584
00:36:39,710 --> 00:36:42,340
is to read the data actually used

585
00:36:42,340 --> 00:36:45,200
by system call or the kernel.

586
00:36:45,200 --> 00:36:48,210
In order to do that, you
can hook LSM functions

587
00:36:48,210 --> 00:36:52,577
to get the doses and call
data that is actually used.

588
00:36:52,577 --> 00:36:56,190
The LSM hooks function
is a list of checkpoints

589
00:36:56,190 --> 00:36:57,500
that are placed in a kernel

590
00:36:57,500 --> 00:37:00,753
before operations happens on the objects.

591
00:37:01,600 --> 00:37:05,590
So here is the table showing
a list of the LSM hooks

592
00:37:05,590 --> 00:37:08,720
used by Tracee version four.

593
00:37:08,720 --> 00:37:11,420
And the second column
shows the system call

594
00:37:11,420 --> 00:37:16,420
that is protected by the LSM
hook from Phantom attacks.

595
00:37:18,240 --> 00:37:20,090
You can also read those data

596
00:37:20,090 --> 00:37:23,580
that's used by the kernel
from kernel data structure.

597
00:37:23,580 --> 00:37:27,410
For example, in order to
read the arguments of execve,

598
00:37:27,410 --> 00:37:29,200
tracing programs can read it

599
00:37:29,200 --> 00:37:32,400
from the mm structure from the kernel.

600
00:37:32,400 --> 00:37:35,543
I will hand over back to Rex to conclude.

601
00:37:40,240 --> 00:37:44,710
- Okay, so basically in this talk,

602
00:37:44,710 --> 00:37:47,560
we showed that Phantom attack is generic

603
00:37:47,560 --> 00:37:51,600
and it exploit the fact that
kernel and tracing program

604
00:37:51,600 --> 00:37:53,970
can read data at different times.

605
00:37:53,970 --> 00:37:55,570
This is exploited by Phantom v1.

606
00:37:56,510 --> 00:37:58,610
And we also showed that the Phantom attack

607
00:37:58,610 --> 00:38:02,170
can exploit the fact that
kernel and tracing program

608
00:38:02,170 --> 00:38:05,120
can interpret data differently,
is exploited by Phantom v2.

609
00:38:07,290 --> 00:38:09,950
We demonstrated that kernel
raw tracepoint on system call

610
00:38:09,950 --> 00:38:11,753
are not ideal for secure tracing.

611
00:38:13,060 --> 00:38:18,060
And for other tracing
implementations, such as kprobe,

612
00:38:18,550 --> 00:38:19,770
because it'll be vulnerable

613
00:38:19,770 --> 00:38:22,013
if it is not implemented properly.

614
00:38:23,430 --> 00:38:26,920
For mitigation, one can use detection

615
00:38:26,920 --> 00:38:30,340
for abnormal usages on userfaultfd,

616
00:38:30,340 --> 00:38:33,860
or to ensure that the kernel
and the secure tracing program

617
00:38:33,860 --> 00:38:38,763
reads the data and interpret
the data in the same way.

618
00:38:40,560 --> 00:38:42,740
- If you're interested in discuss further,

619
00:38:42,740 --> 00:38:45,600
feel free to contact me on Twitter

620
00:38:45,600 --> 00:38:50,600
and we'll share the GitHub
link at Twitter as well.

621
00:38:51,000 --> 00:38:55,190
So before we conclude,

622
00:38:55,190 --> 00:39:00,190
we also want to thank all these
people during our research.

623
00:39:01,380 --> 00:39:03,430
Chris and Joel, for the discussion

624
00:39:03,430 --> 00:39:06,600
on the eBPF and kernel tracing on TOCTOU.

625
00:39:06,600 --> 00:39:08,510
Also Yu on TOCTOU.

626
00:39:08,510 --> 00:39:13,510
And lastly, we really appreciate
the Falco open source team.

627
00:39:13,930 --> 00:39:16,160
They are very professional
handling the issue.

628
00:39:16,160 --> 00:39:20,023
We had really good discussions on there.

629
00:39:21,870 --> 00:39:23,360
Thank you, everyone.

