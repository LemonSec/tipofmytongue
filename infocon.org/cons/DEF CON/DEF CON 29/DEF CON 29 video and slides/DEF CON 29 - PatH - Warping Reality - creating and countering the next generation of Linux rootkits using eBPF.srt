1
00:00:02,360 --> 00:00:03,890
- Good everyone, my name is Pat,

2
00:00:03,890 --> 00:00:07,370
I'm PathToFile on
Twitter, Github, Discord,

3
00:00:07,370 --> 00:00:09,010
and most other places.

4
00:00:09,010 --> 00:00:11,520
And this talk is about
Creating and Countering

5
00:00:11,520 --> 00:00:14,473
the Next Generation of
Linux rootkits using eBPF.

6
00:00:15,620 --> 00:00:17,550
So today we're gonna
start with an overview

7
00:00:17,550 --> 00:00:19,900
on what Linux Kernel rootkits are,

8
00:00:19,900 --> 00:00:21,450
and we're gonna cover why rootkits

9
00:00:21,450 --> 00:00:23,560
are such a powerful tool for attackers,

10
00:00:23,560 --> 00:00:26,330
but why they're so dangerous to use.

11
00:00:26,330 --> 00:00:28,460
Next, we're gonna introduce eBPF,

12
00:00:28,460 --> 00:00:31,120
and we're gonna discuss
on how it can enable

13
00:00:31,120 --> 00:00:34,300
an attacker to have all the
best odds of a kernel rootkit

14
00:00:34,300 --> 00:00:36,370
without any of the risks.

15
00:00:36,370 --> 00:00:38,940
Then finally, we're
gonna cover how to detect

16
00:00:38,940 --> 00:00:41,200
and prevent eBPF based rootkits

17
00:00:41,200 --> 00:00:42,860
before they take over as the preferred

18
00:00:42,860 --> 00:00:44,363
rootkit type for attackers.

19
00:00:45,560 --> 00:00:48,410
So firstly, what are kernel rootkits?

20
00:00:48,410 --> 00:00:51,580
Well, once an attacker
compromises a machine,

21
00:00:51,580 --> 00:00:54,250
they're going to want
to maintain that access.

22
00:00:54,250 --> 00:00:56,310
So perhaps they exploited a vulnerability

23
00:00:56,310 --> 00:00:59,530
in a web application or use
some stolen credentials.

24
00:00:59,530 --> 00:01:01,360
These holes can be closed.

25
00:01:01,360 --> 00:01:02,510
And when they are,

26
00:01:02,510 --> 00:01:05,060
the attacker is gonna want
a way to regain access

27
00:01:05,060 --> 00:01:06,040
to that machine,

28
00:01:06,040 --> 00:01:08,530
preferably with root
privileges and preferably

29
00:01:08,530 --> 00:01:11,530
in a way that is undetectable
to security systems

30
00:01:11,530 --> 00:01:12,943
or systems administrators.

31
00:01:13,780 --> 00:01:15,580
This is the role of a root kit.

32
00:01:15,580 --> 00:01:16,820
And in terms of access,

33
00:01:16,820 --> 00:01:18,670
there's no better places
to put a root kit,

34
00:01:18,670 --> 00:01:20,340
than in the kernel.

35
00:01:20,340 --> 00:01:22,780
When a program wants to list the files

36
00:01:22,780 --> 00:01:26,200
in a directory, it'll use
a syscall to ask the kernel

37
00:01:26,200 --> 00:01:29,530
to read the data from the
hard drive on its behalf.

38
00:01:29,530 --> 00:01:31,800
If a rootkit can hook
or intercept this call

39
00:01:31,800 --> 00:01:35,130
then it can simply
remove any sensitive file

40
00:01:35,130 --> 00:01:37,100
from the directory listing before passing

41
00:01:37,100 --> 00:01:38,590
it back to the kernel.

42
00:01:38,590 --> 00:01:41,380
This same technique can
be used to hide files,

43
00:01:41,380 --> 00:01:45,070
processes, network connections
really cannot do anything

44
00:01:45,070 --> 00:01:46,823
to hide from user space programs.

45
00:01:48,200 --> 00:01:50,810
Now by living in the kernel the
rootkit also has the ability

46
00:01:50,810 --> 00:01:54,670
to tap into old network
traffic before any firewall

47
00:01:54,670 --> 00:01:57,670
and has the ability to launch
processes with root privileges

48
00:01:57,670 --> 00:02:00,670
or alter the privileges
of existing processes.

49
00:02:00,670 --> 00:02:03,220
So this all sounds incredibly
useful for an attacker,

50
00:02:03,220 --> 00:02:04,870
so what's the problem?

51
00:02:04,870 --> 00:02:07,000
Well, by running code in the kernel

52
00:02:07,000 --> 00:02:09,470
it's very easy to turn a small mistake

53
00:02:09,470 --> 00:02:10,963
into a very big problem.

54
00:02:12,430 --> 00:02:15,980
There isn't any guard rails
or safety lines in the kernel.

55
00:02:15,980 --> 00:02:17,960
Once code is running there,

56
00:02:17,960 --> 00:02:21,700
it has the ability to read
and write to almost anything.

57
00:02:21,700 --> 00:02:24,080
This means if there's a bug in your code

58
00:02:24,080 --> 00:02:26,290
and you write to the wrong part of memory,

59
00:02:26,290 --> 00:02:28,500
you're likely to crash the kernel

60
00:02:28,500 --> 00:02:31,910
and you crash the kernel
you crash the entire system.

61
00:02:31,910 --> 00:02:33,390
And it could be even worse,

62
00:02:33,390 --> 00:02:36,010
if the kernel happened to
be riding to a hard drive,

63
00:02:36,010 --> 00:02:37,410
when you broke things,

64
00:02:37,410 --> 00:02:40,120
you could end up corrupting
that disc effectively breaking

65
00:02:40,120 --> 00:02:41,363
the entire system.

66
00:02:42,410 --> 00:02:45,150
Doing this will almost certainly
bring in administrators

67
00:02:45,150 --> 00:02:47,520
and incident responders to
determine what happened.

68
00:02:47,520 --> 00:02:50,453
So this is far from an ideal
outcome for an attacker.

69
00:02:51,370 --> 00:02:54,620
Now, even if the rootkit
developer was very careful,

70
00:02:54,620 --> 00:02:57,557
a kernel update has the ability to alter

71
00:02:57,557 --> 00:03:00,440
what hooked function looks like

72
00:03:00,440 --> 00:03:03,400
or what new kernel object looks like.

73
00:03:03,400 --> 00:03:05,950
And all of this just
increases the likelihood

74
00:03:05,950 --> 00:03:07,400
of a disaster from occurring.

75
00:03:08,290 --> 00:03:09,770
This means that a rootkit developer

76
00:03:09,770 --> 00:03:11,990
often has to test the rootkit against

77
00:03:11,990 --> 00:03:13,960
every single kernel version that it plans

78
00:03:13,960 --> 00:03:14,983
to be deployed upon.

79
00:03:16,130 --> 00:03:18,700
So the good parts of kernel root kits

80
00:03:18,700 --> 00:03:20,650
sound really good for an attacker,

81
00:03:20,650 --> 00:03:24,050
but the risks are often
too high to make it viable.

82
00:03:24,050 --> 00:03:25,910
If only there was a way to keep the only

83
00:03:25,910 --> 00:03:27,730
advantages of a kernel rootkit,

84
00:03:27,730 --> 00:03:30,390
but have the safety and portability

85
00:03:30,390 --> 00:03:32,143
of a user space program.

86
00:03:34,060 --> 00:03:37,810
So, how about we add JavaScript-like

87
00:03:37,810 --> 00:03:40,170
capabilities to the Linux Kernel?

88
00:03:40,170 --> 00:03:42,580
Now to some people, this
quote might sound like

89
00:03:42,580 --> 00:03:45,090
the most wildest thing
they I've ever heard.

90
00:03:45,090 --> 00:03:47,180
But when Thomas Graff
from Isovalent made it,

91
00:03:47,180 --> 00:03:49,900
he wasn't talking literally
about putting JavaScript

92
00:03:49,900 --> 00:03:51,170
in the Kernel.

93
00:03:51,170 --> 00:03:53,600
What he was talking about
was introducing a way

94
00:03:53,600 --> 00:03:57,270
to run a certain type of
code that has the visibility

95
00:03:57,270 --> 00:04:00,100
of the Kernel, but with the ease safety

96
00:04:00,100 --> 00:04:03,130
and portability of such
user space systems,

97
00:04:03,130 --> 00:04:05,480
such as JavaScript programs.

98
00:04:05,480 --> 00:04:09,083
And really what he was
talking about was eBPF.

99
00:04:10,630 --> 00:04:13,220
So what is eBPF?

100
00:04:13,220 --> 00:04:17,960
So eBPF stands for, Extended
Berkeley Packet Filtering,

101
00:04:17,960 --> 00:04:21,470
but it has grown so much
from the original BPF,

102
00:04:21,470 --> 00:04:23,590
particularly in the last two years,

103
00:04:23,590 --> 00:04:25,740
that any comparison to
this classic version

104
00:04:25,740 --> 00:04:28,290
isn't really relevant today.

105
00:04:28,290 --> 00:04:31,990
So what it is, it's a system
within the Linux Kernel

106
00:04:31,990 --> 00:04:35,210
that allows you to create
programmable trace points

107
00:04:35,210 --> 00:04:37,460
known as eBPF programs.

108
00:04:37,460 --> 00:04:40,600
These programs can be
attached to network interfaces

109
00:04:40,600 --> 00:04:44,610
to observe network traffic
or the entry or exit points

110
00:04:44,610 --> 00:04:47,410
of Kernel functions, including syscalls

111
00:04:47,410 --> 00:04:48,580
and can even actually attach

112
00:04:48,580 --> 00:04:51,120
to user space programs and functions.

113
00:04:51,120 --> 00:04:53,560
If this sounds like the same places

114
00:04:53,560 --> 00:04:56,070
as our kernel rootkit, you'd be correct.

115
00:04:56,070 --> 00:05:00,720
But unlike the Kernel rootkit
eBPF programs are guaranteed

116
00:05:00,720 --> 00:05:02,840
to be safe from crashing the system.

117
00:05:02,840 --> 00:05:05,240
And they're even portable
across Kernel versions

118
00:05:05,240 --> 00:05:08,060
and even system architectures.

119
00:05:08,060 --> 00:05:10,920
So to explain how eBPF can achieve this,

120
00:05:10,920 --> 00:05:13,600
let's have a look at how eBPF programs

121
00:05:13,600 --> 00:05:14,943
get written and loaded.

122
00:05:16,410 --> 00:05:20,270
So we'll start with
writing the eBPF program.

123
00:05:20,270 --> 00:05:23,250
So these are typically
written in a restricted

124
00:05:23,250 --> 00:05:24,750
version of C or Rust,

125
00:05:24,750 --> 00:05:27,710
and there's an example of
one in the bottom left.

126
00:05:27,710 --> 00:05:31,010
So the programs have variables,
loops, IF statements,

127
00:05:31,010 --> 00:05:32,900
all the standard parts of the language,

128
00:05:32,900 --> 00:05:34,270
but they're heavily restricted

129
00:05:34,270 --> 00:05:36,550
in what external functions they can call.

130
00:05:36,550 --> 00:05:41,340
And it's limited to only a
number of BPF helper functions.

131
00:05:41,340 --> 00:05:44,690
Now, instead of compiling this
code into native assembly,

132
00:05:44,690 --> 00:05:47,160
eBPF programs actually get compiled

133
00:05:47,160 --> 00:05:49,500
into what's called BPF bytecode.

134
00:05:49,500 --> 00:05:53,650
Which is fairly simple, but
straightforward instruction set,

135
00:05:53,650 --> 00:05:55,760
but the most important thing about this

136
00:05:55,760 --> 00:05:58,080
is that the BPF bytecode is independent

137
00:05:58,080 --> 00:06:01,093
of the architecture or kernel
version that was compiled on.

138
00:06:02,150 --> 00:06:05,310
Now, once this bytecode has been compiled,

139
00:06:05,310 --> 00:06:08,530
it is now ready to be sent to the Kernel.

140
00:06:08,530 --> 00:06:10,910
So this code is sent to the Kernel

141
00:06:10,910 --> 00:06:13,320
using a user space
program called a loader,

142
00:06:13,320 --> 00:06:16,110
which makes use of the BPF syscall

143
00:06:16,110 --> 00:06:18,340
to send it up into the Kernel.

144
00:06:18,340 --> 00:06:20,890
Now, technically non root users

145
00:06:20,890 --> 00:06:25,650
can load some eBPF programs
on some kernel configurations,

146
00:06:25,650 --> 00:06:27,380
but these programs are extremely limited

147
00:06:27,380 --> 00:06:28,930
in what they can do,

148
00:06:28,930 --> 00:06:31,370
so they're out of scope
for this sort of talk.

149
00:06:31,370 --> 00:06:33,090
So for the purpose of this talk,

150
00:06:33,090 --> 00:06:36,910
this loading has to occur
from either the root user

151
00:06:36,910 --> 00:06:38,763
or systems administrator.

152
00:06:39,970 --> 00:06:43,930
Now the Kernel just doesn't
blindly trust this bytecode,

153
00:06:43,930 --> 00:06:48,240
so if the kernel runs what's
called the BPF verifier,

154
00:06:48,240 --> 00:06:51,630
which checks every branch
and every possible value

155
00:06:51,630 --> 00:06:54,670
of every possible variable in this code

156
00:06:54,670 --> 00:06:56,790
to make sure that it is not doing things

157
00:06:56,790 --> 00:06:59,670
such as trying to read in ballad memory

158
00:06:59,670 --> 00:07:01,320
or slow the system down,

159
00:07:01,320 --> 00:07:05,350
or by being too big or complex,
or do really anything else,

160
00:07:05,350 --> 00:07:07,700
that might cause the kernel to crash.

161
00:07:07,700 --> 00:07:11,240
So this is where eBPF
gets a safety guarantee

162
00:07:11,240 --> 00:07:13,080
because only code that passes

163
00:07:13,080 --> 00:07:15,320
all of the verifies extensive checks

164
00:07:15,320 --> 00:07:17,653
is allowed to actually be loaded and run.

165
00:07:18,860 --> 00:07:21,360
Now, once code has passed the verifier,

166
00:07:21,360 --> 00:07:23,610
the coder will then actually run a compile

167
00:07:23,610 --> 00:07:27,470
to convert the bytecode
into the native instructions

168
00:07:27,470 --> 00:07:30,470
that match that machine's
architecture in kernel version.

169
00:07:30,470 --> 00:07:33,470
So if it's an X86 machine
or compiler it to 2X86

170
00:07:33,470 --> 00:07:36,560
or if it's (indistinct) for example.

171
00:07:36,560 --> 00:07:38,980
Now, by running this native instructions,

172
00:07:38,980 --> 00:07:42,250
eBPF code can run as fast as efficient

173
00:07:42,250 --> 00:07:45,360
as regular kernel code for that machine.

174
00:07:45,360 --> 00:07:49,029
But this is not only this,
what this compiler does,

175
00:07:49,029 --> 00:07:54,029
it actually also dynamically
looks up the addresses

176
00:07:55,110 --> 00:07:57,400
of the BPF helper functions

177
00:07:57,400 --> 00:08:00,200
or the any Kernel objects
that the code is using,

178
00:08:00,200 --> 00:08:02,480
and it will actually
patch the instructions

179
00:08:02,480 --> 00:08:05,130
to match that specific kernel version.

180
00:08:05,130 --> 00:08:08,030
And so this is where
the code can be portable

181
00:08:08,030 --> 00:08:11,640
because this compilation
step knows exactly

182
00:08:11,640 --> 00:08:13,890
what the format of that helper function

183
00:08:13,890 --> 00:08:16,420
and what that object looks
like for that specific kernel.

184
00:08:16,420 --> 00:08:18,220
And so by patching the instructions

185
00:08:18,220 --> 00:08:19,920
as it goes to compile it,

186
00:08:19,920 --> 00:08:21,840
it means that that code
will be specifically

187
00:08:21,840 --> 00:08:23,963
designed to run on that system.

188
00:08:25,701 --> 00:08:28,040
Now once these programs are compiled,

189
00:08:28,040 --> 00:08:31,400
they are attached to either
the network interface

190
00:08:31,400 --> 00:08:32,830
or the kernel function that they need

191
00:08:32,830 --> 00:08:34,660
to be attached to where they

192
00:08:34,660 --> 00:08:38,640
will run once for every
packet or function code.

193
00:08:38,640 --> 00:08:41,900
Now programs can't retain
state from one run to the next,

194
00:08:41,900 --> 00:08:44,590
but they can make use of
a global key value store

195
00:08:44,590 --> 00:08:46,190
called an eBPF map.

196
00:08:46,190 --> 00:08:48,160
And so programs can
actually store their state

197
00:08:48,160 --> 00:08:49,700
in that between runs,

198
00:08:49,700 --> 00:08:50,850
and then the next time it runs,

199
00:08:50,850 --> 00:08:54,050
it can read that state and
then pick up where it left off.

200
00:08:54,050 --> 00:08:59,050
Now that is an extremely quick
overview on what eBPF is,

201
00:08:59,530 --> 00:09:00,590
I'll have links to much more,

202
00:09:00,590 --> 00:09:03,090
in-depth documentation at the end of this.

203
00:09:03,090 --> 00:09:05,350
But for now I wanna go
into what are the attacker

204
00:09:05,350 --> 00:09:06,820
with the privileges to load

205
00:09:06,820 --> 00:09:09,690
and run eBPF programs can do?

206
00:09:09,690 --> 00:09:12,210
And how can they use it to
achieve the same rootkit

207
00:09:12,210 --> 00:09:15,113
functionality as a regular kernel rootkit?

208
00:09:16,890 --> 00:09:19,710
So, the first thing we're
gonna cover is using

209
00:09:19,710 --> 00:09:22,623
eBPF to warp the network reality.

210
00:09:23,880 --> 00:09:27,270
So this is a diagram of a
fairly standard web service

211
00:09:27,270 --> 00:09:30,430
set up, it has two network interfaces.

212
00:09:30,430 --> 00:09:32,350
So on the left,

213
00:09:32,350 --> 00:09:35,280
we have the internet
facing network interface.

214
00:09:35,280 --> 00:09:37,480
Where a firewall only allows traffic

215
00:09:37,480 --> 00:09:42,240
to and from a website that's
listening on, say port 443.

216
00:09:42,240 --> 00:09:44,970
Now on the right, we have
the administrators access.

217
00:09:44,970 --> 00:09:47,460
So this is via a separate
network interface

218
00:09:47,460 --> 00:09:50,780
that is attached to an
internal VPN network.

219
00:09:50,780 --> 00:09:54,290
And there's an SSH server
listing on this internal section.

220
00:09:54,290 --> 00:09:55,700
And that's how the administrators,

221
00:09:55,700 --> 00:09:56,603
when they wanna access the machine

222
00:09:56,603 --> 00:09:59,050
they will go through the internal network

223
00:09:59,050 --> 00:10:00,890
and SSH onto this machine.

224
00:10:00,890 --> 00:10:02,450
But to make things interesting,

225
00:10:02,450 --> 00:10:04,650
let's say this SSH connection requires

226
00:10:04,650 --> 00:10:06,233
multi-factor authentication.

227
00:10:07,240 --> 00:10:10,710
Now an attacker who's gained
access to this machine

228
00:10:10,710 --> 00:10:12,730
will probably want the ability to connect

229
00:10:12,730 --> 00:10:14,290
in from the internet,

230
00:10:14,290 --> 00:10:15,760
but they still wanna be able to gain

231
00:10:15,760 --> 00:10:18,090
the same privilege access from the host,

232
00:10:18,090 --> 00:10:21,333
that seems to be limited only
to the internal VPN side.

233
00:10:23,240 --> 00:10:26,840
So eBPF programs have the
ability to read and write

234
00:10:26,840 --> 00:10:29,470
all network packets across all interfaces.

235
00:10:29,470 --> 00:10:31,260
And before the firewall has the ability

236
00:10:31,260 --> 00:10:32,920
to block the connection.

237
00:10:32,920 --> 00:10:35,450
What this means is if
there was a connection

238
00:10:35,450 --> 00:10:37,820
to come in from an attacker's IP address,

239
00:10:37,820 --> 00:10:40,170
even to a closed port,

240
00:10:40,170 --> 00:10:41,790
it was coming from the internet.

241
00:10:41,790 --> 00:10:44,870
Then eBPF can actually
alter both the destination

242
00:10:44,870 --> 00:10:47,150
and source IP addresses and ports

243
00:10:47,150 --> 00:10:48,970
to make it look like this traffic is

244
00:10:48,970 --> 00:10:51,770
actually coming from a fake IP address

245
00:10:51,770 --> 00:10:54,680
that matches the internal VPN side.

246
00:10:54,680 --> 00:10:57,810
It can then route the traffic
into the internal interface,

247
00:10:57,810 --> 00:10:59,800
into the SSH service.

248
00:10:59,800 --> 00:11:02,210
And so for the prospective of SSH

249
00:11:02,210 --> 00:11:04,940
this looks like just a regular connection

250
00:11:04,940 --> 00:11:06,593
from the internal systems.

251
00:11:07,700 --> 00:11:12,700
Then not only will SSH see
this traffic is regular,

252
00:11:12,750 --> 00:11:14,580
if an administrator is using tools such

253
00:11:14,580 --> 00:11:17,850
as Wireshark or Netstat or TCP Dome,

254
00:11:17,850 --> 00:11:20,470
then from the perspective of these tools,

255
00:11:20,470 --> 00:11:22,920
the network connection also only appears

256
00:11:22,920 --> 00:11:25,030
to be coming from the fake IP address

257
00:11:25,030 --> 00:11:26,480
on the internal network.

258
00:11:26,480 --> 00:11:28,660
And they will have no
idea that the connection

259
00:11:28,660 --> 00:11:31,393
is actually being routed
from the internet.

260
00:11:33,740 --> 00:11:36,340
Now this isn't the only
tactic eBPF can employ

261
00:11:37,210 --> 00:11:38,986
because it has the ability to read

262
00:11:38,986 --> 00:11:41,120
and write network packets.

263
00:11:41,120 --> 00:11:43,050
It has ability to see any network packets

264
00:11:43,050 --> 00:11:44,710
before any other system.

265
00:11:44,710 --> 00:11:47,490
So it has the ability to
receive command and control

266
00:11:47,490 --> 00:11:51,830
information from even a port
that nothing is listening on,

267
00:11:51,830 --> 00:11:53,880
and then it can just
silently drop those pockets,

268
00:11:53,880 --> 00:11:55,900
so no security system will know that

269
00:11:55,900 --> 00:11:58,260
that come out of control data has actually

270
00:11:58,260 --> 00:12:00,000
reached the system.

271
00:12:00,000 --> 00:12:04,110
Then while eBPF can not
create its own connections,

272
00:12:04,110 --> 00:12:07,100
it has the ability to
clone existing packets.

273
00:12:07,100 --> 00:12:10,370
So it could close some existing
traffic that some existing,

274
00:12:10,370 --> 00:12:13,500
legitimate traffic, that
say going to the website,

275
00:12:13,500 --> 00:12:16,400
then alter the destination IP addresses

276
00:12:16,400 --> 00:12:19,010
to be the attacker's IP address,

277
00:12:19,010 --> 00:12:22,707
and then alter the actual
data within the packet

278
00:12:22,707 --> 00:12:24,140
to be whatever it wants,

279
00:12:24,140 --> 00:12:26,310
and then it can send
it off to the attacker.

280
00:12:26,310 --> 00:12:29,870
So this technique could be used
to exfiltrate arbitrary data

281
00:12:29,870 --> 00:12:30,773
from the machine.

282
00:12:31,840 --> 00:12:35,470
Then finally, eBPF
programs can be attached

283
00:12:35,470 --> 00:12:37,330
to the user space programs.

284
00:12:37,330 --> 00:12:40,950
So for example, it could
be attached to the website

285
00:12:40,950 --> 00:12:44,070
and hook into the functions
that do the TLS encryption

286
00:12:44,070 --> 00:12:46,120
and decryption for the website.

287
00:12:46,120 --> 00:12:48,980
Now we'll explain in more
detail how that function hooking

288
00:12:48,980 --> 00:12:50,560
works in the next section,

289
00:12:50,560 --> 00:12:54,950
but what this does enable,
is it actually enables eBPF

290
00:12:54,950 --> 00:12:57,850
to change out the data underneath

291
00:12:57,850 --> 00:12:59,750
the encrypted TLS connection.

292
00:12:59,750 --> 00:13:03,520
So that even from an
external network monitor,

293
00:13:03,520 --> 00:13:04,680
it would only see

294
00:13:06,938 --> 00:13:10,300
legitimate TLS traffic going
to it from the website.

295
00:13:10,300 --> 00:13:12,090
And it doesn't actually know that eBPF

296
00:13:12,090 --> 00:13:14,690
might be reaching underneath VTLS

297
00:13:14,690 --> 00:13:17,170
and swapping out the website's data to be

298
00:13:17,170 --> 00:13:19,193
some exfiltrated data from the system.

299
00:13:22,150 --> 00:13:26,220
So altering data across the
network is only one type

300
00:13:26,220 --> 00:13:28,700
of malicious behavior eBPF can do.

301
00:13:28,700 --> 00:13:32,020
The real strength
actually lies in its codal

302
00:13:32,020 --> 00:13:35,180
hooking functions and
even syscall deception.

303
00:13:35,180 --> 00:13:37,650
Because it's the disability
that allows it to walk reality

304
00:13:37,650 --> 00:13:40,913
around files, processes, and even uses.

305
00:13:42,270 --> 00:13:44,400
So going back to my SSH example,

306
00:13:44,400 --> 00:13:48,030
it's not enough to just be
able to connect to the service.

307
00:13:48,030 --> 00:13:51,800
If logging on requires a
valid password and multifactor

308
00:13:51,800 --> 00:13:54,380
authentication, then it's
unlikely the attacker

309
00:13:54,380 --> 00:13:56,530
we'll be able to easily log on.

310
00:13:56,530 --> 00:13:59,470
But what if there was a
way to make SSH ignore this

311
00:13:59,470 --> 00:14:03,420
multi-factor requirement or
even the username and password

312
00:14:03,420 --> 00:14:07,533
requirement, and just allow
anybody to log onto the system?

313
00:14:08,445 --> 00:14:12,880
SSH knows that there's extra requirements

314
00:14:12,880 --> 00:14:16,350
such as multi-factor due
to configuration files

315
00:14:16,350 --> 00:14:19,620
that are in the Etsy pam D folder.

316
00:14:19,620 --> 00:14:22,970
And when a user is going to
authenticate a user's name

317
00:14:22,970 --> 00:14:25,870
and password, it'll look
inside the Etsy password

318
00:14:25,870 --> 00:14:28,220
and Etsy shadow files to make sure

319
00:14:28,220 --> 00:14:31,300
that the supplied username
and passwords are correct.

320
00:14:31,300 --> 00:14:35,460
So is there a way that eBPF
can lie about the contents

321
00:14:35,460 --> 00:14:37,460
of all of these files?

322
00:14:37,460 --> 00:14:38,400
So, yes.

323
00:14:38,400 --> 00:14:40,740
And to explore how eBPF can do this,

324
00:14:40,740 --> 00:14:44,165
let's first quickly revisit
how you user space programs

325
00:14:44,165 --> 00:14:46,773
actually read files using the syscalls.

326
00:14:47,760 --> 00:14:50,950
So when a person wants to
read a file, it actually

327
00:14:50,950 --> 00:14:53,280
make true syscalls to the Kernel.

328
00:14:53,280 --> 00:14:56,460
So the first is to open or open at,

329
00:14:56,460 --> 00:14:59,770
and this will check that
the file that the program

330
00:14:59,770 --> 00:15:01,870
wants to open, actually exists

331
00:15:01,870 --> 00:15:03,770
and the user that's
wanting to read the file,

332
00:15:03,770 --> 00:15:05,900
is actually allowed to do so.

333
00:15:05,900 --> 00:15:08,460
Now, if they are, the Kernel will return,

334
00:15:08,460 --> 00:15:11,250
what's called a file
descriptor number or FD number,

335
00:15:11,250 --> 00:15:14,633
which is simply a reference
to that file for that process.

336
00:15:15,470 --> 00:15:18,110
Then the process will
make a second syscall

337
00:15:18,110 --> 00:15:20,140
this time to read where

338
00:15:20,140 --> 00:15:23,180
asking the kernel to read the file

339
00:15:23,180 --> 00:15:25,280
that matches the supplied FD number

340
00:15:25,280 --> 00:15:27,030
it got from the open call.

341
00:15:27,030 --> 00:15:30,590
And it'll actually give a
memory buffer to the kernel

342
00:15:30,590 --> 00:15:33,130
to fill in with the files, content.

343
00:15:33,130 --> 00:15:35,440
The kernel then look up that FD number,

344
00:15:35,440 --> 00:15:37,160
make sure it's a valid number,

345
00:15:37,160 --> 00:15:39,477
then grab the file and I'll copy the file

346
00:15:39,477 --> 00:15:42,050
of the data into that process as a buffer,

347
00:15:42,050 --> 00:15:44,763
before returning to
the user space process.

348
00:15:45,950 --> 00:15:49,900
What this means is, if we have
four different eBPF programs,

349
00:15:49,900 --> 00:15:52,150
we can observe what's going on

350
00:15:52,150 --> 00:15:55,987
and we can actually watch,

351
00:15:55,987 --> 00:15:59,590
what is both being sent to and from

352
00:15:59,590 --> 00:16:01,890
these two different sets of syscalls.

353
00:16:01,890 --> 00:16:03,760
What this means is we're able to track

354
00:16:03,760 --> 00:16:07,550
what FD number corresponds
to what file name.

355
00:16:07,550 --> 00:16:11,010
And we can even actually read
what the data is contained

356
00:16:11,010 --> 00:16:14,010
within the file before
the youth space program,

357
00:16:14,010 --> 00:16:16,530
by reading the contents of the buffer

358
00:16:16,530 --> 00:16:18,590
after the Etsy call has as exited,

359
00:16:18,590 --> 00:16:20,940
which would be that eBPF
program at the bottom.

360
00:16:21,910 --> 00:16:25,220
But reading buffers, isn't
the only thing eBPF can do,

361
00:16:25,220 --> 00:16:27,363
it can also write to them.

362
00:16:28,490 --> 00:16:31,860
So let's have a look
at this basic example.

363
00:16:31,860 --> 00:16:35,560
On the left is a very
simple user space program,

364
00:16:35,560 --> 00:16:38,750
it is looking to open
the file called read me,

365
00:16:38,750 --> 00:16:42,530
and then it's asking the
Kernel using the read syscall

366
00:16:42,530 --> 00:16:46,450
to read the data from that file
into a buffer called buffer.

367
00:16:46,450 --> 00:16:49,420
Now on the right is the eBPF program

368
00:16:49,420 --> 00:16:51,870
that is attached to the
exit of the read syscall.

369
00:16:53,550 --> 00:16:56,040
So after the file has been opened,

370
00:16:56,040 --> 00:16:58,380
and after the user space
program, asked the Kernel

371
00:16:58,380 --> 00:17:00,110
to read the file,

372
00:17:00,110 --> 00:17:03,210
the kernel will read
the file into the buffer

373
00:17:03,210 --> 00:17:06,510
but before the user space
programs gets control again,

374
00:17:06,510 --> 00:17:08,870
our eBPF program is going run.

375
00:17:08,870 --> 00:17:11,320
So you can see at the
start of this program

376
00:17:11,320 --> 00:17:14,740
that it's using the BPF
probe read user function

377
00:17:14,740 --> 00:17:16,830
to read the contents of that buffer,

378
00:17:16,830 --> 00:17:19,763
which at this stage we'll
include the file data.

379
00:17:20,840 --> 00:17:25,610
But, there was also a BPF
program write user function.

380
00:17:25,610 --> 00:17:29,090
Now this program, this actually allows us

381
00:17:29,090 --> 00:17:31,660
to alter the data within that buffer,

382
00:17:31,660 --> 00:17:34,360
and then write it back
into user space memory

383
00:17:34,360 --> 00:17:36,220
before the user space program sees it.

384
00:17:36,220 --> 00:17:39,930
What this means is once
a eBDF program exits

385
00:17:39,930 --> 00:17:43,000
and controllers returned
to the user space program,

386
00:17:43,000 --> 00:17:44,910
the program will think
that the contents of buffer

387
00:17:44,910 --> 00:17:46,490
contains the file data,

388
00:17:46,490 --> 00:17:48,210
when in actuality it contains

389
00:17:48,210 --> 00:17:51,123
the fetched data been put there by eBPF.

390
00:17:52,720 --> 00:17:56,610
This BPF right user code
can be used to override

391
00:17:56,610 --> 00:17:59,910
any user of space,
buffer pointer, or string

392
00:17:59,910 --> 00:18:01,834
that gets passed into or out of the

393
00:18:01,834 --> 00:18:03,403
syscalls kernel functions.

394
00:18:04,400 --> 00:18:06,770
So things like changing what
program getting launched

395
00:18:06,770 --> 00:18:09,150
by execve or reading an altering

396
00:18:09,150 --> 00:18:11,420
net like data heaps of different stuff

397
00:18:11,420 --> 00:18:13,760
can be possible with this call.

398
00:18:13,760 --> 00:18:16,470
So another thing eBPF can do is bypass

399
00:18:16,470 --> 00:18:18,500
the syscall altogether.

400
00:18:18,500 --> 00:18:21,840
And instead, just pretend
that the function ran

401
00:18:21,840 --> 00:18:26,530
and return an arbitrary
error code or return value.

402
00:18:26,530 --> 00:18:30,730
This can be done using the F
mode read type of EPF program.

403
00:18:30,730 --> 00:18:33,930
Which while these can be
attached to every function,

404
00:18:33,930 --> 00:18:35,870
they can be attached to every syscalls

405
00:18:35,870 --> 00:18:37,860
at least on newer kernels.

406
00:18:37,860 --> 00:18:41,210
So for example, the
example in the top, right,

407
00:18:41,210 --> 00:18:45,240
this program simply
pretends to write to a file

408
00:18:45,240 --> 00:18:48,520
and it returns the expected success code

409
00:18:48,520 --> 00:18:51,160
to indicate that the file
was actually written,

410
00:18:51,160 --> 00:18:53,280
but the file is never actually written

411
00:18:53,280 --> 00:18:56,520
then the right syscall
was never actually called.

412
00:18:56,520 --> 00:18:59,850
Now, if the goal is to prevent
a process from discovering

413
00:18:59,850 --> 00:19:01,190
or stopping the rootkit,

414
00:19:01,190 --> 00:19:05,310
a more drastic option can be
to simply kill the process.

415
00:19:05,310 --> 00:19:09,120
So by using the eBPF sends
signal helper function,

416
00:19:09,120 --> 00:19:12,890
the program can send an
unstoppable SIGKILL signal,

417
00:19:12,890 --> 00:19:14,490
which will immediately instruct the code

418
00:19:14,490 --> 00:19:16,080
on to start tearing down that process,

419
00:19:16,080 --> 00:19:19,160
regardless of whether
it wants to what or not.

420
00:19:19,160 --> 00:19:20,950
Now, this is a pretty drastic action

421
00:19:20,950 --> 00:19:23,440
that could probably be noticed,

422
00:19:23,440 --> 00:19:25,950
but it's certainly a
possible way to prevent

423
00:19:25,950 --> 00:19:27,223
an action from occurring.

424
00:19:29,470 --> 00:19:33,110
Now, killing every process
that attempts to open any file

425
00:19:33,110 --> 00:19:36,130
is gonna be a quick way to
having a really bad time.

426
00:19:36,130 --> 00:19:39,270
So thankfully, eBPF
programs have lots of ways

427
00:19:39,270 --> 00:19:43,290
to tailor an action based on
who or what is performing.

428
00:19:43,290 --> 00:19:45,550
So eBPF programs can do different things

429
00:19:45,550 --> 00:19:48,910
based upon the process name, the user ID,

430
00:19:48,910 --> 00:19:50,960
the value of arguments being passed

431
00:19:50,960 --> 00:19:52,920
or returned from that function.

432
00:19:52,920 --> 00:19:56,300
And it can even take cues
from other eBPF programs.

433
00:19:56,300 --> 00:19:58,932
So for example, it could only start

434
00:19:58,932 --> 00:20:03,370
tampering with the read calls from a file

435
00:20:03,370 --> 00:20:05,860
only after connection

436
00:20:05,860 --> 00:20:07,883
from a specific IP address has occurred.

437
00:20:10,130 --> 00:20:13,020
So looking back to our SSH example,

438
00:20:13,020 --> 00:20:16,970
to bypass multifactor
eBPF can simply overwrite

439
00:20:16,970 --> 00:20:20,100
the data being read from
the Pam configuration files

440
00:20:20,100 --> 00:20:22,760
to remove any mention of multifactor.

441
00:20:22,760 --> 00:20:25,200
It could then even overwrite the data

442
00:20:25,200 --> 00:20:27,290
in Etsy password and Etsy shadow,

443
00:20:27,290 --> 00:20:30,860
to insert a fake user
account and password,

444
00:20:30,860 --> 00:20:33,040
which would enable
logging in to the machine

445
00:20:33,040 --> 00:20:35,393
with a completely fake set of accounts.

446
00:20:36,310 --> 00:20:40,150
By having eBPF only
target the SSH process,

447
00:20:40,150 --> 00:20:42,850
it means to an administrator using tools

448
00:20:42,850 --> 00:20:45,790
like cat or vim or a security tool,

449
00:20:45,790 --> 00:20:47,540
or even to file forensics looking

450
00:20:47,540 --> 00:20:49,230
at the actual file on disk.

451
00:20:49,230 --> 00:20:53,050
All of these will only show
the normal unedited file.

452
00:20:53,050 --> 00:20:55,330
Only SSH will be presented with the warped

453
00:20:55,330 --> 00:20:57,363
reality version of this data.

454
00:21:00,420 --> 00:21:03,623
Okay, so now it's time for some demo.

455
00:21:06,560 --> 00:21:08,520
The first demonstration
that we're gonna go through

456
00:21:08,520 --> 00:21:12,610
is the ability to replace text
within the arbitrary files.

457
00:21:12,610 --> 00:21:14,900
So we can see in the
shell on the top, right,

458
00:21:14,900 --> 00:21:18,240
that there is a folder
with a file called file.

459
00:21:18,240 --> 00:21:19,950
And when we look inside this file,

460
00:21:19,950 --> 00:21:21,913
we see the text, this is real data.

461
00:21:23,130 --> 00:21:25,420
So now we're gonna go
ahead and load up the first

462
00:21:25,420 --> 00:21:29,060
of our eBPF rootkits into
this shell on the left.

463
00:21:29,060 --> 00:21:31,830
So this rootkit is going to
look for any type of process,

464
00:21:31,830 --> 00:21:33,870
that means the word file,

465
00:21:33,870 --> 00:21:36,540
and it's gonna replace
any data that contains

466
00:21:36,540 --> 00:21:39,540
the text real with the word fake.

467
00:21:39,540 --> 00:21:42,940
But specifically it's not
going to affect every process,

468
00:21:42,940 --> 00:21:44,950
it's only going to affect children

469
00:21:44,950 --> 00:21:47,210
of this specific person's ID.

470
00:21:47,210 --> 00:21:50,943
Which we can see, that matches
with our shell on the right.

471
00:21:51,790 --> 00:21:53,480
So, we're gonna go ahead,

472
00:21:53,480 --> 00:21:55,270
our rootkit is now started,

473
00:21:55,270 --> 00:21:59,440
and now back to our shell,
when we go to read this file,

474
00:21:59,440 --> 00:22:02,120
we can see that the data has been changed

475
00:22:02,120 --> 00:22:04,720
and it says, this is fake data.

476
00:22:04,720 --> 00:22:07,370
And in fact, the log from
the root kit actually

477
00:22:07,370 --> 00:22:10,750
says that it did detect
that this process started,

478
00:22:10,750 --> 00:22:13,740
which was cut, and it
replaced the text that

479
00:22:13,740 --> 00:22:16,010
that process read.

480
00:22:16,010 --> 00:22:18,060
But what is interesting
if we go to this shell now

481
00:22:18,060 --> 00:22:19,730
on the bottom, right,

482
00:22:19,730 --> 00:22:21,420
because this is a different shell

483
00:22:21,420 --> 00:22:23,250
with a different process ID,

484
00:22:23,250 --> 00:22:26,490
even though we're in the same folder,

485
00:22:26,490 --> 00:22:29,650
and we you look at the same file,

486
00:22:29,650 --> 00:22:33,510
it sees the unaltered data.

487
00:22:33,510 --> 00:22:37,810
So this is a technique
that has many, many uses.

488
00:22:37,810 --> 00:22:40,000
The example that we've
used in the presentation

489
00:22:40,000 --> 00:22:43,660
is this is a way that you can add a user

490
00:22:43,660 --> 00:22:45,970
into the Etsy password file,

491
00:22:45,970 --> 00:22:49,060
but only do that for an SSH process

492
00:22:49,060 --> 00:22:52,930
and not for any auditing
software or system administrator,

493
00:22:52,930 --> 00:22:54,380
having you look at that file.

494
00:23:02,360 --> 00:23:05,580
So the next demonstration
we're gonna go through

495
00:23:05,580 --> 00:23:10,580
is the ability to stealthily enable

496
00:23:10,730 --> 00:23:12,480
a user to use Sudo to (indistinct).

497
00:23:14,067 --> 00:23:16,030
So typically on this machine,

498
00:23:16,030 --> 00:23:18,750
if we have a look at this
shell in the bottom right,

499
00:23:18,750 --> 00:23:22,280
this is running as the
user called Lonpriv.

500
00:23:22,280 --> 00:23:26,943
And if word priv wanted
to become root using Sudo,

501
00:23:28,272 --> 00:23:29,105
what we can see...

502
00:23:29,105 --> 00:23:33,080
Oh Lonprtiv is not allowed
in the sudoers file.

503
00:23:33,080 --> 00:23:38,080
And in fact, if we use the
root shell on the top right,

504
00:23:38,170 --> 00:23:40,467
we can double and triple
confirmed that lonpriv

505
00:23:40,467 --> 00:23:42,460
is not in this list.

506
00:23:42,460 --> 00:23:45,520
So first off we can use
the sudo dash L command

507
00:23:45,520 --> 00:23:48,930
to say, hey, what privileges

508
00:23:48,930 --> 00:23:51,480
does Sudo believe this user to have?

509
00:23:51,480 --> 00:23:52,420
And when we run it,

510
00:23:52,420 --> 00:23:55,117
we see user Lonpriv is not allowed to run

511
00:23:55,117 --> 00:23:58,150
and in fact, we can even
add this most basic level,

512
00:23:58,150 --> 00:24:01,500
just go and read

513
00:24:01,500 --> 00:24:04,230
the Etsy Sudo's file

514
00:24:04,230 --> 00:24:05,680
and look for the user Lonpriv

515
00:24:07,000 --> 00:24:09,160
and sure enough, that
user is not in there.

516
00:24:09,160 --> 00:24:12,550
So this user Lonpriv is definitely

517
00:24:12,550 --> 00:24:15,393
not able to become root user in Sudo.

518
00:24:16,840 --> 00:24:19,660
That is until we run the second

519
00:24:19,660 --> 00:24:23,163
of our eBPF rootkits on the left.

520
00:24:24,730 --> 00:24:28,700
So this one is going to look for any time,

521
00:24:28,700 --> 00:24:31,500
anything that is opening,
specifically Sudo,

522
00:24:31,500 --> 00:24:34,770
is going to try to open
the Etsy Sudo file.

523
00:24:34,770 --> 00:24:37,630
And it's just going to
alter the text in that file

524
00:24:37,630 --> 00:24:40,490
to say, hey, Lonpriv is actually in there

525
00:24:40,490 --> 00:24:42,750
and they do actually
have those privileges.

526
00:24:42,750 --> 00:24:45,340
But it's only going to do this,

527
00:24:45,340 --> 00:24:47,930
not only when just Sudo is running,

528
00:24:47,930 --> 00:24:51,010
but only when sudo is
being run specifically

529
00:24:51,010 --> 00:24:52,640
from Lonpriv.

530
00:24:52,640 --> 00:24:54,710
So now this root could have started

531
00:24:55,970 --> 00:25:00,050
if Lonpriv were to use Sudo
again and say, who am I?

532
00:25:00,050 --> 00:25:03,210
Well, look at this, it can become root.

533
00:25:03,210 --> 00:25:06,050
In fact, it didn't even
need to enter its password.

534
00:25:06,050 --> 00:25:08,730
So how does that work?

535
00:25:08,730 --> 00:25:12,250
Well, so if as Lonpriv,

536
00:25:12,250 --> 00:25:16,210
we now ask Sudo to tell
us, hey what privileges

537
00:25:16,210 --> 00:25:17,743
do you think I have?

538
00:25:18,670 --> 00:25:21,440
Well, we can see that from when Sudo

539
00:25:21,440 --> 00:25:24,600
is running as Lonpriv it says,

540
00:25:24,600 --> 00:25:28,620
hey lonpriv has the ability
to do anything it wants

541
00:25:28,620 --> 00:25:30,953
without even needing
to add in any password.

542
00:25:32,090 --> 00:25:34,163
But even with this rootkit running,

543
00:25:35,110 --> 00:25:38,330
if we were to check these
permissions as a different user,

544
00:25:38,330 --> 00:25:41,560
it still says, hey
Lonpriv is no longer here,

545
00:25:41,560 --> 00:25:44,770
and if we check that file, it still says

546
00:25:44,770 --> 00:25:46,440
that Lonpriv is not in there.

547
00:25:46,440 --> 00:25:48,380
So this file is only altered,

548
00:25:48,380 --> 00:25:51,790
not only when it's just
a Sudo process running,

549
00:25:51,790 --> 00:25:55,030
but only when it is a
Sudo process being run

550
00:25:55,030 --> 00:25:57,157
by that Lonpriv user.

551
00:26:03,060 --> 00:26:06,420
The last example that
we're gonna go through

552
00:26:06,420 --> 00:26:09,130
is the ability

553
00:26:09,130 --> 00:26:11,780
to kill arbitrary processes

554
00:26:11,780 --> 00:26:15,070
as a sort of self protection idea.

555
00:26:15,070 --> 00:26:20,070
So, typically an
administrator can use a tool

556
00:26:21,700 --> 00:26:23,550
called BPF tool,

557
00:26:23,550 --> 00:26:27,290
and this lists, the running eBPF programs

558
00:26:27,290 --> 00:26:29,460
that are running on that system.

559
00:26:29,460 --> 00:26:32,090
And it's got the ability to
see what programs are running.

560
00:26:32,090 --> 00:26:35,830
So for example, we can
see a lot of eBPF programs

561
00:26:35,830 --> 00:26:37,420
that actually relate to that system deed

562
00:26:37,420 --> 00:26:39,490
currently running on this system.

563
00:26:39,490 --> 00:26:42,880
And BPF tool has the ability to list

564
00:26:42,880 --> 00:26:44,300
the running processes,

565
00:26:44,300 --> 00:26:46,700
to dump out the instructions

566
00:26:46,700 --> 00:26:49,340
and even seeing what process IDs

567
00:26:49,340 --> 00:26:53,280
are actually related to that eBPF program.

568
00:26:53,280 --> 00:26:55,610
So, this is a good way for administrator

569
00:26:55,610 --> 00:26:59,020
to see what eBPF programs are running

570
00:26:59,020 --> 00:27:01,420
to potentially discover something like

571
00:27:01,420 --> 00:27:02,673
an eBPF rootkit.

572
00:27:03,566 --> 00:27:07,929
So we're gonna load up a
rootkit that is running

573
00:27:07,929 --> 00:27:09,450
on the left.

574
00:27:09,450 --> 00:27:13,290
And now, if we attempt to use BPF tool

575
00:27:13,290 --> 00:27:14,860
to list the processes,

576
00:27:14,860 --> 00:27:17,360
oh, the process just gets killed before

577
00:27:17,360 --> 00:27:18,950
that information happens.

578
00:27:18,950 --> 00:27:20,633
So this is pretty extreme,

579
00:27:22,060 --> 00:27:26,430
but this demonstrates
that eBPF has the ability

580
00:27:26,430 --> 00:27:29,480
to sort of protect itself by just killing

581
00:27:29,480 --> 00:27:30,730
any process that it's attempting

582
00:27:30,730 --> 00:27:33,993
to do any sort of investigation.

583
00:27:43,090 --> 00:27:45,917
So now we're gonna cover
some other features of eBPF

584
00:27:45,917 --> 00:27:48,870
and then get into some limitations of it.

585
00:27:48,870 --> 00:27:51,350
So three features that
we haven't yet covered,

586
00:27:51,350 --> 00:27:53,800
but I think are definitely
worth mentioning.

587
00:27:53,800 --> 00:27:56,260
Firstly, on some network cards,

588
00:27:56,260 --> 00:27:57,229
you can actually run the eBPF programs

589
00:27:57,229 --> 00:28:01,460
on the the network kernel hardware itself,

590
00:28:01,460 --> 00:28:03,060
instead of in the kernel.

591
00:28:03,060 --> 00:28:04,620
So for regular developers,

592
00:28:04,620 --> 00:28:07,100
this is great because this
can drastically increase

593
00:28:07,100 --> 00:28:09,170
the packet processing speeds.

594
00:28:09,170 --> 00:28:10,900
But from a rootkit perspective,

595
00:28:10,900 --> 00:28:13,480
this is interesting to know
because what this means

596
00:28:13,480 --> 00:28:17,560
is that any packet alterations
made by an eBPF program,

597
00:28:17,560 --> 00:28:20,540
that if this program is
running on network card,

598
00:28:20,540 --> 00:28:23,620
this will occur after the Linux kernel

599
00:28:23,620 --> 00:28:27,110
has tentatively scanned that
packet for anything malicious.

600
00:28:27,110 --> 00:28:30,610
So if you were to send a packet
to add malicious IP address,

601
00:28:30,610 --> 00:28:34,370
but send it to a benign IP address,

602
00:28:34,370 --> 00:28:37,930
then only once it's left the
kernel and then inside the

603
00:28:37,930 --> 00:28:41,110
network card do you alter
it to the dodgy IP address,

604
00:28:41,110 --> 00:28:43,200
well, any security system
that's running in the kernel

605
00:28:43,200 --> 00:28:44,803
won't see that alteration.

606
00:28:45,920 --> 00:28:50,610
So, secondly, up until
recently eBPF programs

607
00:28:50,610 --> 00:28:53,510
that are attached to Kernel
functions or syscalls

608
00:28:53,510 --> 00:28:55,540
require their user space loader

609
00:28:55,540 --> 00:28:58,850
to continue to run once the
program is up and running.

610
00:28:58,850 --> 00:29:01,630
And in fact, if that you user
space loader where to exit,

611
00:29:01,630 --> 00:29:03,950
then the kernel would just
assume that you also want

612
00:29:03,950 --> 00:29:06,913
to stop running eBPF
programs and shut them down.

613
00:29:07,750 --> 00:29:10,300
Now, if newer kernels
there's been the introduction

614
00:29:10,300 --> 00:29:14,600
of these F entry and F
exit type of BPF programs.

615
00:29:14,600 --> 00:29:18,000
Now these actually have
the ability to be pinned

616
00:29:18,000 --> 00:29:21,070
to add this SIS SBPF folder,

617
00:29:21,070 --> 00:29:24,150
which what this means is a
special file gets created

618
00:29:24,150 --> 00:29:27,080
under this folder one
for each BPF program,

619
00:29:27,080 --> 00:29:29,830
and then for as long as
this file remains there,

620
00:29:29,830 --> 00:29:32,520
the loader is free to exit, delete itself,

621
00:29:32,520 --> 00:29:35,230
be completely removed and eBPF of programs

622
00:29:35,230 --> 00:29:36,630
will continue to run.

623
00:29:36,630 --> 00:29:37,870
Then when you want to stop them,

624
00:29:37,870 --> 00:29:39,423
you just delete the files.

625
00:29:41,020 --> 00:29:44,300
So finally, the thing worth mentioning is

626
00:29:44,300 --> 00:29:46,720
as we said before, the BPF verifier

627
00:29:46,720 --> 00:29:49,300
put strict limits in how complex

628
00:29:49,300 --> 00:29:52,990
an individual eBPF program can be,

629
00:29:52,990 --> 00:29:55,800
but they exist in mechanism
to chain multiple programs

630
00:29:55,800 --> 00:29:57,910
together using the BPF,

631
00:29:57,910 --> 00:30:01,060
using this helper function
called a BPF tail code.

632
00:30:01,060 --> 00:30:03,900
Now this requires some
preparation and making use

633
00:30:03,900 --> 00:30:05,930
of those eBPF maps we mentioned,

634
00:30:05,930 --> 00:30:09,270
but the end result is
the system as a whole

635
00:30:09,270 --> 00:30:13,350
can be much more complex than
what a single eBPF program

636
00:30:13,350 --> 00:30:14,950
is allowed to be.

637
00:30:14,950 --> 00:30:16,200
So for example the right,

638
00:30:16,200 --> 00:30:19,420
this is full code graphs
that are from four different

639
00:30:19,420 --> 00:30:23,220
eBPF programs that actually
just make up one half

640
00:30:23,220 --> 00:30:26,690
of that text, replacing rootkit
that we just demonstrated.

641
00:30:26,690 --> 00:30:30,880
Now each individual program
is pushing the limit

642
00:30:30,880 --> 00:30:33,690
on what a single eBPF
program is allowed to do,

643
00:30:33,690 --> 00:30:36,580
but all combined the
system as a whole can be

644
00:30:36,580 --> 00:30:38,493
much, much more complex.

645
00:30:40,670 --> 00:30:43,130
Now there's a number of
limitations to writing

646
00:30:43,130 --> 00:30:45,150
a rootkit using eBPF.

647
00:30:45,150 --> 00:30:50,150
So the first one is when using
the BPF right user function

648
00:30:50,400 --> 00:30:51,770
to overwrite the buffer,

649
00:30:51,770 --> 00:30:54,100
there is a small window of time between

650
00:30:54,100 --> 00:30:57,240
when the syscall fills the
data inside the buffer,

651
00:30:57,240 --> 00:31:00,210
and when eBPF overwrites it.

652
00:31:00,210 --> 00:31:02,080
Now this time, I know it doesn't matter

653
00:31:02,080 --> 00:31:04,710
in single-threaded programs because

654
00:31:04,710 --> 00:31:07,370
the current execution is not gonna return

655
00:31:07,370 --> 00:31:10,200
to the user space program until after eBPF

656
00:31:10,200 --> 00:31:11,350
has done its thing,

657
00:31:11,350 --> 00:31:13,650
but in a multi-threaded program,

658
00:31:13,650 --> 00:31:16,170
a second thread could
be constantly reading

659
00:31:16,170 --> 00:31:19,010
the contents of that buffer
and actually get read

660
00:31:19,010 --> 00:31:21,360
what is the true data from the syscall

661
00:31:21,360 --> 00:31:23,833
before eBPF has a chance
to tamper with it.

662
00:31:25,010 --> 00:31:28,730
Now, the first major
issue do you using eBPF

663
00:31:28,730 --> 00:31:33,730
as a rootkit, is program's
don't persist across the reboot.

664
00:31:33,750 --> 00:31:36,510
So what this means is
when a machine restarts

665
00:31:36,510 --> 00:31:40,000
the user space loader
is needed to run again

666
00:31:40,000 --> 00:31:42,560
to load and attach all those eBPF programs

667
00:31:42,560 --> 00:31:44,023
back into the kernel.

668
00:31:45,240 --> 00:31:49,080
Now, the second major
thing is that eBPF programs

669
00:31:49,080 --> 00:31:50,960
caught right to kernel memory,

670
00:31:50,960 --> 00:31:52,990
because this would almost certainly break

671
00:31:52,990 --> 00:31:55,660
those safety guarantees of eBPF.

672
00:31:55,660 --> 00:31:58,470
What is means if a security
tool is running in the kernel

673
00:31:58,470 --> 00:32:01,770
such as audit D or a
Linux security module,

674
00:32:01,770 --> 00:32:04,683
these are gonna be
unaffected by eBPF tampering.

675
00:32:05,940 --> 00:32:08,270
But one thing to note about these is that

676
00:32:08,270 --> 00:32:11,180
wireless security product
might be running in the kernel

677
00:32:11,180 --> 00:32:14,430
they usually administrated
by user space tools.

678
00:32:14,430 --> 00:32:19,380
So if a rootkit were to
disable the security tool

679
00:32:19,380 --> 00:32:23,000
in the kernel, but then lie
to the user space controller

680
00:32:23,000 --> 00:32:26,040
about the current running
status of the system,

681
00:32:26,040 --> 00:32:28,150
that might be enough to fool the system

682
00:32:28,150 --> 00:32:30,950
into thinking that it's more
secure than it actually is.

683
00:32:33,010 --> 00:32:36,400
Okay, let's talk about the
defensive side of things.

684
00:32:36,400 --> 00:32:38,390
So we're gonna start with file forensics.

685
00:32:38,390 --> 00:32:40,960
So if you're looking to detect files

686
00:32:40,960 --> 00:32:42,610
that contain eBPF code,

687
00:32:42,610 --> 00:32:44,580
there's a couple of things to think about.

688
00:32:44,580 --> 00:32:48,220
So for starters, the
file that gets generated

689
00:32:48,220 --> 00:32:51,850
by the compiler, when compiling
a program to BPF bytecode

690
00:32:51,850 --> 00:32:53,660
is actually an ELF file.

691
00:32:53,660 --> 00:32:57,750
Where the byte code is
inside a named section

692
00:32:57,750 --> 00:32:59,250
within that ELF.

693
00:32:59,250 --> 00:33:02,870
So what this means is that
tools such as read ELF

694
00:33:02,870 --> 00:33:06,270
or object jump can actually
used to pass these files

695
00:33:06,270 --> 00:33:08,450
and extract the BPF bytecode.

696
00:33:08,450 --> 00:33:11,910
So for example, the eBPF
program on the top right,

697
00:33:11,910 --> 00:33:15,470
is being attached to
the execve trace point

698
00:33:15,470 --> 00:33:18,183
that TP syscall exactly in top.

699
00:33:19,200 --> 00:33:21,640
What happens is when this gets compiled,

700
00:33:21,640 --> 00:33:24,010
that TP syscall execve is actually

701
00:33:24,010 --> 00:33:26,720
becomes the name of the
section inside the ELF

702
00:33:26,720 --> 00:33:28,520
that contains the raw bytes.

703
00:33:28,520 --> 00:33:31,110
So you can use a tool
then to read that section

704
00:33:31,110 --> 00:33:33,263
and extract the eBPF bytecode.

705
00:33:34,350 --> 00:33:35,720
Now it's important to note,

706
00:33:35,720 --> 00:33:38,480
that's just the object from the compiler,

707
00:33:38,480 --> 00:33:40,440
that's not the user space loader.

708
00:33:40,440 --> 00:33:45,440
Because what gets sent to the
kernel is just the BPF bites.

709
00:33:45,490 --> 00:33:47,840
Now it's important to note that

710
00:33:49,330 --> 00:33:51,470
a lot of loaders are gonna be written

711
00:33:51,470 --> 00:33:53,970
using this LIBBPF library.

712
00:33:53,970 --> 00:33:56,250
Because this is a library that is actually

713
00:33:56,250 --> 00:33:58,240
part of the Linux source tree

714
00:33:58,240 --> 00:34:01,170
and makes it a lot
easier to read, and write

715
00:34:01,170 --> 00:34:03,350
and manage eBPF programs.

716
00:34:03,350 --> 00:34:06,670
Now, if a loader is using LIBBBPF,

717
00:34:06,670 --> 00:34:08,510
what this library will actually do,

718
00:34:08,510 --> 00:34:11,600
it'll actually embed the entire ELF object

719
00:34:11,600 --> 00:34:14,730
from the compiler inside
the users space loader.

720
00:34:14,730 --> 00:34:17,600
So you end up with an
ELF inside of an ELF.

721
00:34:17,600 --> 00:34:20,520
And so therefore if you're
wishing to extract the byte code,

722
00:34:20,520 --> 00:34:22,950
you would first need to
look at the read only data

723
00:34:22,950 --> 00:34:25,540
inside the load up,
extract the ELF from there,

724
00:34:25,540 --> 00:34:27,620
and then possibly extract that data

725
00:34:27,620 --> 00:34:30,433
to find the correct section,
to get the BPF bytecode.

726
00:34:31,810 --> 00:34:34,140
Now, once you do extract the byte code,

727
00:34:34,140 --> 00:34:36,910
the biggest thing to look
for would be evidence

728
00:34:36,910 --> 00:34:40,190
of that BPF probe right user function.

729
00:34:40,190 --> 00:34:43,730
It might be more difficult
to automatically tell

730
00:34:43,730 --> 00:34:48,170
if network packet altering
program is malicious or not,

731
00:34:48,170 --> 00:34:50,920
but I can't imagine too
many legitimate use cases

732
00:34:50,920 --> 00:34:53,830
of this BPF pro right user function.

733
00:34:53,830 --> 00:34:57,920
Now I haven't touched at
all on what BPF byte code

734
00:34:57,920 --> 00:34:59,773
instructions actually look like,

735
00:35:00,710 --> 00:35:02,632
but the instruction code

736
00:35:02,632 --> 00:35:06,240
that comes out of the first compiler

737
00:35:06,240 --> 00:35:08,030
is that example on disk.

738
00:35:08,030 --> 00:35:10,940
So the 85, and then the 24 batches

739
00:35:10,940 --> 00:35:13,410
with the BPF probe write user function.

740
00:35:13,410 --> 00:35:16,450
But if you remember, the
byte code is architectural

741
00:35:16,450 --> 00:35:18,440
and kernel version agnostic.

742
00:35:18,440 --> 00:35:20,130
And so what happens is when this bytecode

743
00:35:20,130 --> 00:35:22,450
gets sent into the kernel as we explained,

744
00:35:22,450 --> 00:35:25,110
the kernel will actually patch that 24

745
00:35:25,110 --> 00:35:27,340
to match up with what
is the correct address

746
00:35:27,340 --> 00:35:28,560
for that kernel.

747
00:35:28,560 --> 00:35:31,720
So if you're looking at the byte code

748
00:35:31,720 --> 00:35:33,600
that's being stored inside the kernel

749
00:35:33,600 --> 00:35:35,780
you would actually then
to not need to dynamically

750
00:35:35,780 --> 00:35:37,340
look up that memory address

751
00:35:37,340 --> 00:35:40,370
to determine that is the
appropriate user function.

752
00:35:40,370 --> 00:35:43,700
And then if you're
looking at the native card

753
00:35:43,700 --> 00:35:46,070
after the JIT compiler inside the kernel

754
00:35:46,070 --> 00:35:46,903
then this is definitely

755
00:35:46,903 --> 00:35:48,970
just gonna look like a
regular kernel instruction.

756
00:35:48,970 --> 00:35:51,720
So you would need to look up that

757
00:35:51,720 --> 00:35:54,040
again, dynamically look
up that memory address

758
00:35:54,040 --> 00:35:57,633
to determine that is the
probe write user function.

759
00:35:59,680 --> 00:36:01,710
So to protect a running system,

760
00:36:01,710 --> 00:36:03,230
I think one of the strongest defenses

761
00:36:03,230 --> 00:36:06,500
would be to monitor that BPF, syscall

762
00:36:06,500 --> 00:36:10,530
which, you could use eBPF to monitor eBPF.

763
00:36:10,530 --> 00:36:13,580
So monitoring for what
programs are loading

764
00:36:13,580 --> 00:36:17,580
and running eBPF programs, is
gonna be a really good tactic.

765
00:36:17,580 --> 00:36:19,890
Because realistically,
this should only be a small

766
00:36:19,890 --> 00:36:21,980
number of known programs

767
00:36:21,980 --> 00:36:24,093
that are actually interacting with eBPF.

768
00:36:25,320 --> 00:36:28,210
Now, if a program
actually sounds suspicious

769
00:36:28,210 --> 00:36:31,320
because eBPF has intercepted the syscall,

770
00:36:31,320 --> 00:36:33,990
you could actually extract
the program's bytecode,

771
00:36:33,990 --> 00:36:36,040
and then send it to
somewhere else to be analyzed

772
00:36:36,040 --> 00:36:37,720
where you could detect (indistinct)

773
00:36:37,720 --> 00:36:39,320
suspicious behavior in the code.

774
00:36:41,860 --> 00:36:44,870
So a lot of the things
I've covered so far,

775
00:36:44,870 --> 00:36:48,270
assume that and eBPF
rootkit is not already

776
00:36:48,270 --> 00:36:50,560
an installed and
tampering with the system.

777
00:36:50,560 --> 00:36:52,230
Because if it is already running,

778
00:36:52,230 --> 00:36:54,510
it actually would have the
ability to either block

779
00:36:54,510 --> 00:36:58,300
or hide a bunch of these user
memory process scanning file,

780
00:36:58,300 --> 00:37:00,330
that a standing files or attempting

781
00:37:00,330 --> 00:37:02,083
to load an eBPF program.

782
00:37:03,270 --> 00:37:06,070
But even kernel rootkits have a hard time

783
00:37:06,070 --> 00:37:07,840
hiding from memory forensics.

784
00:37:07,840 --> 00:37:10,370
Which particularly if the
machine is virtualized,

785
00:37:10,370 --> 00:37:12,900
the memory forensics can
be acquired from underneath

786
00:37:12,900 --> 00:37:15,300
the kernel hardware, a hypervisor,

787
00:37:15,300 --> 00:37:16,803
or even the physical level.

788
00:37:18,010 --> 00:37:20,250
Volatility is the name of an excellent

789
00:37:20,250 --> 00:37:21,630
memory forensics tool.

790
00:37:21,630 --> 00:37:23,520
And in fact, at this years is black card,

791
00:37:23,520 --> 00:37:25,840
the team is releasing some
new plugins specifically

792
00:37:25,840 --> 00:37:30,260
around acquiring and analyzing
Linux tracing forensics.

793
00:37:30,260 --> 00:37:32,400
Now, as I'm prerecording this talk,

794
00:37:32,400 --> 00:37:34,980
I don't know exactly
what they're gonna cover,

795
00:37:34,980 --> 00:37:37,820
but I did speak briefly with
a number of the team members

796
00:37:37,820 --> 00:37:39,030
before I recorded this,

797
00:37:39,030 --> 00:37:41,990
and I'm really excited
to actually get ahead

798
00:37:41,990 --> 00:37:44,020
a lot and play with the plugins

799
00:37:44,020 --> 00:37:45,210
that they're producing, because

800
00:37:45,210 --> 00:37:46,910
they sound incredibly interesting.

801
00:37:48,830 --> 00:37:53,830
So one final prevention could
be to just straight up disable

802
00:37:53,850 --> 00:37:55,753
any use of eBPF within the code.

803
00:37:56,740 --> 00:37:59,660
Now this requires you
to recompile the kernel

804
00:37:59,660 --> 00:38:03,330
with the relevant flags
disabled and by doing so,

805
00:38:03,330 --> 00:38:05,720
you'd lose all the
advantages of using eBPF

806
00:38:05,720 --> 00:38:07,470
for your own reasons,

807
00:38:07,470 --> 00:38:09,570
but this is definitely an option for some.

808
00:38:10,720 --> 00:38:13,410
So a different additionally at the moment,

809
00:38:13,410 --> 00:38:16,170
there is some discussions
going on within the community

810
00:38:16,170 --> 00:38:19,170
about how to cryptographically
signed eBPF programs

811
00:38:19,170 --> 00:38:22,550
in the same way that you
can sign kernel modules.

812
00:38:22,550 --> 00:38:24,820
Doing so would allow a system to load

813
00:38:24,820 --> 00:38:27,280
only trusted eBPF programs,

814
00:38:27,280 --> 00:38:29,940
but prevent unknown or untrusted programs

815
00:38:29,940 --> 00:38:31,323
from being loaded and used.

816
00:38:32,520 --> 00:38:35,410
Now, implementing this
is definitely nontrivial,

817
00:38:35,410 --> 00:38:38,390
particularly due to that compilation step,

818
00:38:38,390 --> 00:38:40,750
but some smart people are
really looking at this.

819
00:38:40,750 --> 00:38:43,090
And so in the future,
this may end up being

820
00:38:43,090 --> 00:38:47,063
the best defense against
eBPF base rootkits.

821
00:38:48,725 --> 00:38:52,660
Before we finish quickly,
what else can eBPF do?

822
00:38:52,660 --> 00:38:56,040
So, firstly, eBPF now runs on Windows.

823
00:38:56,040 --> 00:38:59,210
So in May Microsoft released
the start of a project

824
00:38:59,210 --> 00:39:02,090
on GitHub called eBPF for Windows.

825
00:39:02,090 --> 00:39:04,050
It's in the early stages at the moment,

826
00:39:04,050 --> 00:39:07,310
it's only got the network
observability side of things

827
00:39:07,310 --> 00:39:10,100
and not the function
hook or syscall hooking.

828
00:39:10,100 --> 00:39:12,330
But a lot of people including myself,

829
00:39:12,330 --> 00:39:15,740
are really interested in seeing
how this project evolves.

830
00:39:15,740 --> 00:39:17,670
So if you're interested in Windows at all,

831
00:39:17,670 --> 00:39:20,333
I would highly recommend
checking out this project.

832
00:39:22,520 --> 00:39:24,240
Now, another thing I wanted to mention

833
00:39:24,240 --> 00:39:27,930
is that warping reality,
isn't just for attackers.

834
00:39:27,930 --> 00:39:31,350
So these same ideas around altering file

835
00:39:31,350 --> 00:39:33,840
or network data is also incredibly useful

836
00:39:33,840 --> 00:39:35,280
to reverse engineers.

837
00:39:35,280 --> 00:39:38,230
Either doing malware
analysis or even bug hunting.

838
00:39:38,230 --> 00:39:40,910
So for example, it's
not uncommon for malware

839
00:39:40,910 --> 00:39:42,560
to perform a series of checks

840
00:39:42,560 --> 00:39:46,000
to determine if it's actually
running on a victim machine,

841
00:39:46,000 --> 00:39:49,483
or if it's running in an
analysis Sandbox, such as Cuckoo.

842
00:39:50,360 --> 00:39:51,920
Now, the malware will check things

843
00:39:51,920 --> 00:39:55,660
such as the number of CPU
calls, the machine uptime,

844
00:39:55,660 --> 00:39:58,520
the number of files within
the template folder.

845
00:39:58,520 --> 00:40:00,250
It might even actually
look at the manufacturers,

846
00:40:00,250 --> 00:40:01,410
of the network cards to determined

847
00:40:01,410 --> 00:40:04,200
is that a real card or a virtual machine.

848
00:40:04,200 --> 00:40:06,940
So thanks to eBPF we
can fake the responses

849
00:40:06,940 --> 00:40:08,600
to all of these questions.

850
00:40:08,600 --> 00:40:11,190
And in fact, we can fake
them only for the malware,

851
00:40:11,190 --> 00:40:13,110
so we don't accidentally
break some critical

852
00:40:13,110 --> 00:40:15,710
piece of software that's
running inside the Sandbox.

853
00:40:19,880 --> 00:40:21,520
So now at the end of this talk,

854
00:40:21,520 --> 00:40:25,520
I'm gonna release a
collection of eBPF programs

855
00:40:25,520 --> 00:40:27,813
and loaders that I've called bad BPF.

856
00:40:28,710 --> 00:40:31,310
So these programs demonstrate
a number of the techniques

857
00:40:31,310 --> 00:40:33,340
we've discussed and demonstrated today,

858
00:40:33,340 --> 00:40:36,000
and they should have enough documentation

859
00:40:36,000 --> 00:40:39,960
and comments to help you
understand exactly how they work.

860
00:40:39,960 --> 00:40:43,530
They cover a range of actions
from hijacking execve calls

861
00:40:43,530 --> 00:40:45,290
to load arbitrary programs,

862
00:40:45,290 --> 00:40:47,380
allowing the user to become Sudo

863
00:40:47,380 --> 00:40:49,420
all the program that
replaces the arbitrary text

864
00:40:49,420 --> 00:40:50,930
in arbitrary programs.

865
00:40:50,930 --> 00:40:54,230
Which because basically
everything in Linux is a file,

866
00:40:54,230 --> 00:40:57,250
this can be used to hide kernel modules,

867
00:40:57,250 --> 00:40:59,380
adding fake users to Etsy password,

868
00:40:59,380 --> 00:41:01,780
or faking the Mac address
from the network card.

869
00:41:04,460 --> 00:41:06,590
So we've covered a lot today and honestly,

870
00:41:06,590 --> 00:41:10,020
the internals of EBF I'm
using eBPF defensively

871
00:41:10,020 --> 00:41:12,300
could be entire talks on their own.

872
00:41:12,300 --> 00:41:14,940
But, I hope you've at
least learn things about

873
00:41:14,940 --> 00:41:16,950
how kernel rootkits are great,

874
00:41:16,950 --> 00:41:19,070
but they're also incredibly risky.

875
00:41:19,070 --> 00:41:21,930
And I hope you've learnt how
eBPF can remove that risk

876
00:41:21,930 --> 00:41:23,900
while keeping the same ability

877
00:41:23,900 --> 00:41:26,020
to hide data from administrators

878
00:41:26,020 --> 00:41:28,820
and provide backdoor access to a machine.

879
00:41:28,820 --> 00:41:30,820
And I really hope you've
come away with some ideas

880
00:41:30,820 --> 00:41:33,360
on how to detect and prevent eBPF rootkit

881
00:41:33,360 --> 00:41:34,520
from being deployed.

882
00:41:34,520 --> 00:41:37,100
Because I think the safety and portability

883
00:41:37,100 --> 00:41:38,660
is gonna mean that we're definitely

884
00:41:38,660 --> 00:41:41,100
gonna start seeing actual eBPF rootkit

885
00:41:41,100 --> 00:41:43,390
appear in world before too long.

886
00:41:43,390 --> 00:41:45,380
Now there's a lot of links on this page,

887
00:41:45,380 --> 00:41:46,950
I think if you're interested in eBPF,

888
00:41:46,950 --> 00:41:48,790
I would absolutely recommend checking out

889
00:41:48,790 --> 00:41:50,630
the community website in Slack,

890
00:41:50,630 --> 00:41:52,060
there's a bunch of really
cool people sitting

891
00:41:52,060 --> 00:41:55,420
on that Slack who are really
great at helping people learn

892
00:41:55,420 --> 00:41:56,740
more about the system and answering

893
00:41:56,740 --> 00:41:58,290
any questions that people have.

894
00:41:59,230 --> 00:42:02,350
Now, there's also been some
other offensive eBPF talks

895
00:42:02,350 --> 00:42:05,530
in the past, if you're
interested in the offensive side.

896
00:42:05,530 --> 00:42:08,400
So including (indistinct)
just the other day

897
00:42:08,400 --> 00:42:09,990
from the Data Dog people.

898
00:42:09,990 --> 00:42:12,540
So I would definitely recommend
checking those talks out,

899
00:42:12,540 --> 00:42:14,113
if you're interested in this.

900
00:42:15,100 --> 00:42:16,800
Finally, I've got some thanks.

901
00:42:16,800 --> 00:42:19,870
Thank you very much to Cory
for being incredibly supportive

902
00:42:19,870 --> 00:42:22,340
as I've delved into the quarters of eBPF.

903
00:42:22,340 --> 00:42:24,350
And definitely thanks
for Maybe for helping me

904
00:42:24,350 --> 00:42:27,420
workshops are more than
ridiculous ideas that I had,

905
00:42:27,420 --> 00:42:29,260
when I was designing this talk

906
00:42:29,260 --> 00:42:31,473
and then definitely
thank you to my family.

907
00:42:32,320 --> 00:42:34,160
This recording was done during the middle

908
00:42:34,160 --> 00:42:35,830
of a pretty hectic time,

909
00:42:35,830 --> 00:42:39,460
involving the pandemic and
(indistinct) lots of fun.

910
00:42:39,460 --> 00:42:41,710
I've been very lucky to have a partner

911
00:42:41,710 --> 00:42:44,260
that supporting me as
I ramble into a camera

912
00:42:44,260 --> 00:42:47,863
that is many, many, many
miles away from DEFCON.

913
00:42:49,780 --> 00:42:52,000
So with that, I will end this talk

914
00:42:52,000 --> 00:42:54,930
with a picture of my
dog, thanks for watching.

915
00:42:54,930 --> 00:42:56,170
I'll be around on the Discord,

916
00:42:56,170 --> 00:42:57,590
if you have any other questions,

917
00:42:57,590 --> 00:43:00,090
otherwise, feel free to
reach out to me on Twitter,

918
00:43:00,090 --> 00:43:02,520
email, GitHub et cetera.

919
00:43:02,520 --> 00:43:04,053
And thank you for watching.

