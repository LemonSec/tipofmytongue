00:00:00.100,00:00:05.105
>>I present you your speakers.
Daniel Romero and Mario Rivas.
[applause] >>Can you hear me?

00:00:10.844,00:00:15.849
Yeah, Ok. Well, uh, hi everyone
and thanks for coming to our
talk “Why You Should Fear Your

00:00:21.088,00:00:26.293
Mundane Office Equipment”, where
we are going to present
enterprise printer research. Ok.

00:00:26.293,00:00:31.765
Thanks also to Def Con for
giving us this great
opportunity. Ok first of all,

00:00:31.765,00:00:37.137
there’s there’s a reason to care
about who we are. This is Mario
Rivas and I’m Daniel Romero. Um,

00:00:37.137,00:00:42.109
both work at a Security
Consultant and Researchers at nc
group in the Madrid office. Ok.

00:00:42.109,00:00:48.148
Here you have our contact info
and emails but you want to know
us better, we are always up for

00:00:48.148,00:00:53.887
a beer, so just ping us. Ok,
this is the agenda, this uh
really classical agenda, first

00:00:53.887,00:00:58.358
introduction about uh about our
research and the attack phase
that we have covered. Uh the

00:00:58.358,00:01:03.163
test methodology. Mario will
present the test methodology and
some fuzz we have developed and

00:01:03.163,00:01:08.302
have a way to crush the
different vulnerabilities that
we have found. And after that we

00:01:08.302,00:01:14.341
will show you some exploit we
have developed. And just finally
a brief conclusions. Let’s go

00:01:14.341,00:01:16.877
with introduction. Ok. Um, the
main goal of the research was
testing enterprise devices. Ok.

00:01:16.877,00:01:23.150
Um, figure out the current state
of security of them. For this
reason we thought that printer

00:01:23.150,00:01:28.155
would be a good target. Ok. Um
we selected 6 di- 6 different
medium size enterprise printers

00:01:34.528,00:01:39.833
and we decided to focus these
research in a red teaming
approach. Ok. We will show with

00:01:39.833,00:01:46.406
it vulnerability research, it’s
protection, plus exploitation.
Keep in mind it was not an

00:01:46.406,00:01:50.444
assessment, so we only need one
vulnerability to provide us
remote code execution. We don’t

00:01:50.444,00:01:55.649
need to find all the
vulnerabilities that the printer
have. Ok. And why printers.

00:01:55.649,00:02:02.255
These are really good questions.
Printers has been real eh- well
extended sa- many years ago

00:02:02.255,00:02:08.962
around the the companies. And
they are usually connected to eh
different networks, different

00:02:08.962,00:02:13.633
VLANs so we can use them in
order to eh, pivot and solve the
different department the company

00:02:13.633,00:02:19.006
could have k? And obviously the
information that could be
managed by um a company is

00:02:19.006,00:02:23.977
really sensitive. We have
corporate information, personal,
financial, customers. And don’t

00:02:23.977,00:02:29.816
forget information which was
inc- or is include within the uh
configuration. We can have uh

00:02:29.816,00:02:36.556
domain accounts, creation,
password and eccetera. Ok. And
well usually uh printers are

00:02:36.556,00:02:42.496
considered lower static so
probably they are not included
within the patch cycle. And uh

00:02:42.496,00:02:49.036
they probably are not configured
cyclically or properly. Ok. And
then we have uncontrolled

00:02:49.036,00:02:53.640
devices. Managing really
sensitive information and
connected to the most of the

00:02:53.640,00:02:58.645
company’s networks. These are
example of this quick, where
Microsoft catches Russian state

00:03:00.647,00:03:06.586
hackers using printers in order
to attack companies for example.
I’m going out. Some vendor-,

00:03:06.586,00:03:11.591
some vendors decided to make a
statements like this one, so it
is a challenge for us. The most

00:03:14.461,00:03:20.567
important probably. Ha ha. Ok,
let’s go with attack surface. Uh
first of all this command that

00:03:20.567,00:03:26.773
we identify two different eh uh
operation system within our
printers um. The real time

00:03:26.773,00:03:32.846
operation system, RTOS and
Linux. And obviously we identify
many different attack surfaces.

00:03:32.846,00:03:38.218
Like web applications and web
servers, web servers sorry.
Mobile applications, file

00:03:38.218,00:03:43.223
parsers, updated firmware
analysis. Printed language and
services, external services like

00:03:46.059,00:03:51.064
the Google CloudPrint or
AirPrint. Management services,
telnet, SMP and others. Um

00:03:53.433,00:03:58.271
proxi- proximity attacks like
wifi, USB, NFC and et cetera.
And we also decided to include

00:03:58.271,00:04:04.411
other two tasks, post
exploitation and hardware
analysis. Ok. But obviously we

00:04:04.411,00:04:09.483
have enough time to go over all
these attack surfaces. And we
finally decided to include the

00:04:09.483,00:04:14.888
following ones, those ones are
gray because we didn’t include
them in all the print testing.

00:04:14.888,00:04:21.094
Ok. Uh these are mortitalic
picture about our attack surface
where you can see the difference

00:04:21.094,00:04:26.500
element we called in these in
these research, uh for example,
for the printed languages and

00:04:26.500,00:04:31.505
file format we decided to
include the PJL, PJL, PCL and PS
language format. Ok. Let’s go

00:04:35.142,00:04:40.147
with the testing methodology.
>>So this the methodology that
we mainly uh use during the

00:04:42.415,00:04:48.321
research. Uh we started with the
state of the art on uh setting
up our printers and then we

00:04:48.321,00:04:53.894
chose uh the scope of our attack
surface as we just told and then
in a second process uh we

00:04:53.894,00:04:58.365
started searching
vulnerabilities uh passing
different protocols and finding

00:04:58.365,00:05:02.869
some crashes. Then analyzing
them um then trying to exploit
them in order to gain more

00:05:02.869,00:05:07.807
knowledge of the device. Uh all
these while also analyzing the
few were in the cases we were

00:05:07.807,00:05:14.548
able to obtain it and also eh,
using the hardware to get some
more useful information. Talking

00:05:14.548,00:05:20.353
about fuzzing. Um, we started
with dumb fuzzer first. Uh which
are very quick to launch, but

00:05:20.353,00:05:25.358
also uh, well, and we continue
dev- developing uh smarter ones
uh, which require more time, but

00:05:27.994,00:05:32.999
ge- give better results. But
Linux gave us great results, but
we also find that we were

00:05:36.136,00:05:42.676
spending more time that eh we
should. Uh, so we decided to
create our own fuzzer. While

00:05:42.676,00:05:48.014
looking at the state of the art,
uh we found two amazing tools.
Uh Sulley and BooFuzz. By the

00:05:48.014,00:05:50.016
way, um, Joshua Pereyda, uh the
maintainer of BooFuzz and car
vision were here yesterday. Um,

00:05:50.016,00:05:56.823
these two tools have great uh
model use and great uh
functionalities. Uh, but we were

00:05:56.823,00:06:01.761
taking a lot of the code, so we
decided to to fork, BooFuzz and
after Sulley and Boo eh the next

00:06:10.203,00:06:15.208
one was Wazowski so we called
this Fuzzowski, uh we wrote it
in Python3 and we changed eh,

00:06:17.477,00:06:24.451
improved some of the models like
the strings fuzzing libraries
and um, we also made fuzzer

00:06:24.451,00:06:27.087
modules to keep all your
protocol fuzzers under uh single
program with a similar behavior.

00:06:27.087,00:06:29.089
And between the rest of the
changes uh we wanted to solve
some difficulties that we were

00:06:29.089,00:06:31.091
having. Different
implementations of the same
protocol behave uh different in

00:06:31.091,00:06:33.093
different targets and when a
device crashes it can load to
tear it down or maybe the the

00:06:33.093,00:06:35.095
service may a stop answering or
maybe it just print us stacked
arrays in some bug interface.

00:06:35.095,00:06:42.002
For this, um, we made a main
program with a lot of arguments
to uh, avoid touching the code.

00:06:42.002,00:06:47.007
Um, for different targets and we
made monitor modules to
constantly check the target. And

00:07:10.664,00:07:16.603
then when the device crashes um,
a lot of times we boo- need to
reboot it manually. So we made

00:07:16.603,00:07:23.176
restarter modules um, to for
example, turn off a known an a
smart black another to any

00:07:23.176,00:07:28.181
necessity we were having. And
then, uh to give usability to
the to the fuzzer we made a a

00:07:30.784,00:07:36.222
nice console where we can post
and control the fuzzing session
and do things like re-test uh

00:07:36.222,00:07:42.762
suspect packet uh suspect escape
detection of a device. And do
other things like printing human

00:07:42.762,00:07:49.102
readable formats the packets we
are sending. And uh we can also
save standalone scripts uh that

00:07:49.102,00:07:54.107
we can for example uh send to a
manufacturer. So let’s with uh
very quick demo. Before that, uh

00:07:57.877,00:08:02.816
you can see here um, a typical
BooFuzz uh, test case. Uh,
printing and below um, the our

00:08:05.752,00:08:07.754
console with the test case, the
number of test cases, our target
and some more information of the

00:08:07.754,00:08:12.759
actual test case. Let’s go for
the demo. That’s it. Ok. Um, so
we can see a below a ping to the

00:08:22.068,00:08:27.073
uh to the target and we can see
above um, the help with a lot of
the commands and the options

00:08:34.914,00:08:40.387
that we have. Uh the different
modules, the fuzzer modules that
we have, uh developed. The

00:08:40.387,00:08:45.392
restarted modules, the monitor
modules and all the options. We
are going now to launch uh the

00:08:47.627,00:08:52.632
fuzzer tool target. The printer
1 and the port 631. Using the
internet printing protocol uh

00:08:56.202,00:09:02.142
fuzzer. Uh and the get printer
attributes command of the IPP
protocol. And we are also using

00:09:02.142,00:09:08.848
restarter module that turns off
a known and a smartplug. When
the device goes down. We can see

00:09:08.848,00:09:15.288
here cool logo and the console.
Where with a lot of the commands
that we implemented. We are

00:09:15.288,00:09:21.060
going now just test the
connection sending a known fast
packet to a printer. And after

00:09:21.060,00:09:25.932
checking that the connection is
ok, uh we are going to go to a
different test case and we are

00:09:25.932,00:09:30.937
going to continue the execution
from from there. We can see here
uh the different test cases that

00:09:37.310,00:09:42.315
we are sending, uh, like in very
similar tool fuzz. And after
sending two of them we will see

00:09:45.218,00:09:51.391
below uh that we will stop
receiving icmp messages and that
printer has gone down and now we

00:09:51.391,00:09:56.429
cannot connect to the target and
we are going to use the
restarter module to restart the

00:09:56.429,00:10:01.434
target. After that it will wait
for it to recover and um, it
will continue the execution

00:10:05.405,00:10:10.543
automatically. But we don’t want
to do that, we can control C, go
to the console uh and we can for

00:10:10.543,00:10:15.548
example bring the suspects where
you can see the 5 phoning one.
And we can also print these, uh

00:10:18.485,00:10:25.425
test case in a human readable
format. Uh, you can see all the
the code packet and the longest

00:10:25.425,00:10:30.430
line, uh, is you can see we are
sending 10,000 Cs and so there
are full value which was in. Uh

00:10:32.899,00:10:38.805
we can also say uh see a proof
of concept. Uh we can copy and
paste into a script and for

00:10:38.805,00:10:43.810
example send it to a manufacture
or use it in a in a split. Then
um, after this uh recallers, we

00:10:48.715,00:10:55.255
will retest it to see if it was
this test case which was uh
causing the crash or it was any

00:10:55.255,00:11:00.193
other reason. For that we can
use the fuzz command and uh we
are going to launch the fuzz

00:11:03.029,00:11:09.235
command for the 501 we will just
test the test case and after
that we stop passing icmps

00:11:09.235,00:11:14.240
again. Uh we have fall back uh
in this case it was uh pbuffer
flow. And we can also save the

00:11:16.843,00:11:21.848
[indiscernible] script into a
file with a crash command. And
um, disable this element to not

00:11:23.917,00:11:28.054
test it anymore because we
already know it’s vulnerable and
we don’t want to spend more time

00:11:28.054,00:11:33.059
with this. So. That was the the
main demo. Uh we you can find
all the code after the talk in

00:11:40.433,00:11:45.438
our external github. And let’s
go for just a bit of hardware.
We took a very good look at the

00:11:49.175,00:11:53.980
hardware, mainly searching for
things that will help us with
the exploitation with things.

00:11:53.980,00:11:58.985
Like debug interfaces, like uh
serial ports, UR attack data and
other uh information that will

00:12:00.920,00:12:06.893
allow us to damn the uh firmware
or other useful information from
their memory. And while doing

00:12:06.893,00:12:12.298
that um, we also were having too
much fun uh playing with the
hardware. Um, we did something

00:12:12.298,00:12:17.303
that we shouldn’t and uh one of
the printers will never print
again because of that. Um, we

00:12:19.872,00:12:24.877
will say maybe kill printer safe
at three. I don’t know. Um, so
one of the first things that we

00:12:27.513,00:12:32.518
did was uh looking for exposed
memories. Like in this case
where we use at uh buspirate

00:12:35.388,00:12:40.627
which was connected to one of
the tips. And through spi
protocol we downloaded the

00:12:40.627,00:12:45.632
firmware through that. From the,
from that memory. We also found
uh serial ports in three of the

00:12:48.768,00:12:53.773
six printer uh tested. Which uh
also we found uh founds some
data ports that seemed to be

00:12:56.109,00:12:58.111
disabled and uh serial ports
were extremely useful as they
give us a lot of information. Uh

00:12:58.111,00:13:00.580
debug information, uh errors and
uh stack traces. And this was of
course useful to us for some of

00:13:00.580,00:13:05.585
the vulnerabilities that we
found. Uh also one of them had a
interrupted shell that allowed

00:13:14.661,00:13:19.666
to write and read to memory. And
also to give from arbitrary
positions so we decided to make

00:13:21.901,00:13:27.874
a hardware backdoor with this
and which could be implanted
with by someone with physical

00:13:27.874,00:13:34.213
access to the printer in 2 or 3
minutes. For this we use a
Raspberry Pi, uh, as you can see

00:13:34.213,00:13:40.687
in the picture, which was
connected to the to the serial
port and was also power byte, so

00:13:40.687,00:13:46.492
whenever the printer is on, our
Raspberry Pi will be on. And
then this Raspberry Pi an ac- an

00:13:46.492,00:13:52.965
access point and from there we
could just uh access to this
console and have this this

00:13:52.965,00:13:59.205
capabilities. That was a very
quick look at the hardware and
let’s go for some of the most

00:13:59.205,00:14:05.445
common flaws found in most of
the printers. Um, we are
starting with the web

00:14:05.445,00:14:10.950
applications and we found really
weak default configurations,
exposing almost services have

00:14:10.950,00:14:17.557
hilo in the printers, um more
than 20 in some cases. And we
also found that it was giving

00:14:17.557,00:14:22.795
access to the management panel
with default or without
credentials. Uh we got the

00:14:22.795,00:14:29.402
feeling that it was like the
product security of 20 years
ago. Um, and of course we found

00:14:29.402,00:14:35.007
a lot of the typical issues in
our web like uh cross-site
request forgery, lack of access

00:14:35.007,00:14:40.012
control in some functionalities
like um, ah, one that a load
test stood a lot of full back of

00:14:43.583,00:14:50.022
the configuration including uh
passwords in clear text of
course. And uh all that inf-

00:14:50.022,00:14:55.595
things like cross-site scripting
issues, like 1, 2, 3 and 4. And
a bit more interesting path

00:14:55.595,00:15:00.533
reversal uh which allowed us to
to load some files, but
unfortunately we were only able

00:15:02.769,00:15:09.375
to download some specific
extensions and we are not able
to further exploit this to get

00:15:09.375,00:15:14.380
closer to our objective which
was uh to get remote execution.
So these issues are not bad, but

00:15:16.783,00:15:21.921
we are looking for something
that may allow us to get uh full
control of the device, so

00:15:21.921,00:15:27.960
looking at the frameworks, we
found a few lengthy, more
interesting functionalities.

00:15:27.960,00:15:34.267
Like this one, you can see there
are a lot of information, uh, a
lot of debug information like

00:15:34.267,00:15:40.439
authorization and security
locks. Including sysdebug uh
cookies. And also more

00:15:40.439,00:15:45.244
information like activity
authority logs, kerberos logs,
the full list of processors

00:15:45.244,00:15:49.916
running in the machine and more
information about the underlying
operating system, uh Linux in

00:15:49.916,00:15:54.921
this case. In this second case,
was very similar to the first
one, um, with different

00:15:57.790,00:16:03.763
functionalities and their
different URLs. And this was uh
very useful to exploit one of

00:16:03.763,00:16:09.602
the vulnerabilities that we will
see later. And this third one
was even better because it

00:16:09.602,00:16:14.407
directly allowed us to download
the full memory of the device
containing any secret, eh,

00:16:14.407,00:16:21.247
passwords, uh anything in that
at that moment. We also used
this as a memory leak issue to

00:16:21.247,00:16:27.854
defeat ASLR uh one, when
exploiting one of the issues. We
will see also that later. And of

00:16:27.854,00:16:34.227
course, all this was uh
accessible without any
implications because it’s not

00:16:34.227,00:16:40.967
even in the menus or anything.
So. So going for the memory
corruption issues, we found a

00:16:40.967,00:16:46.305
lot of them in a lot of
services, not only in the web,
but also in um, in other

00:16:46.305,00:16:51.310
services like printer protocols,
IPP or LPD or SNMP the Google
Cloud implementations. Basically

00:16:54.013,00:16:59.018
a lot uh more than we can
handle, or investigate so we
really stopped searching for

00:17:02.021,00:17:08.027
more um, we we had basically
vulnerabilities everywhere.
Which leaded to crashes

00:17:08.027,00:17:14.367
everywhere and also some useful
traces in the debug interfaces
that we found, like this one.

00:17:14.367,00:17:19.372
Where you can see that the PC is
overwritten and this is from a
exploit that we won’t uh show

00:17:28.347,00:17:33.352
you today, but don’t worry,
Daniel is now going to to
explain two others that are

00:17:35.821,00:17:38.724
nice. >>Ok let’s go with the
couple of uh expolita- example,
de- eh- sorry. A couple exploit

00:17:38.724,00:17:43.696
examples that we we fo- we
developed for this research.
This uh first one this the easy

00:17:43.696,00:17:48.701
case and was found by one uh web
application file scan. As you
can see in the image in the uh

00:17:51.370,00:17:58.010
HTTP request, and we uh with a
long cookie value we were able
to uh crash the print. So

00:17:58.010,00:18:02.682
probably this is a parsing a
stack buffer overflow. Ok. But
looking to the framework we

00:18:02.682,00:18:06.852
identify that the developers
forgot to include vulnerability
checks in the whole code. So

00:18:06.852,00:18:11.857
probably this is strug- this is
string copy here, eh, which is
copying the cookie value into

00:18:14.393,00:18:20.333
stacker, right could lead to us
attack buffer flow. Ok. And uh,
important another important

00:18:20.333,00:18:23.936
point here is the count
variable, the count variable is
the is the cookie size,

00:18:23.936,00:18:30.609
including the cooke name, the
equal symbol and the eh cookie
value. Ok. And it for ex-, it is

00:18:30.609,00:18:35.615
for example used in some paths
within the within the string
copy ey- function like, within

00:18:37.883,00:18:42.888
the, the size argument. Where,
where eh, 15 byte were extracted
from these for these variable

00:18:45.524,00:18:52.264
ok. Question here, will be, do
you really think there is only
one bug here? Answer obvious is

00:18:52.264,00:18:59.271
no. Imagine that we replace the
equal symbol by a semi colon
symbol ok? The count value will

00:18:59.271,00:19:04.210
assume 14. 14 minus 13 is a
negative number. So the 15 copy
function will copy a really huge

00:19:06.512,00:19:10.649
and special number into the
local array. So we have two
different vulnerabilities in the

00:19:10.649,00:19:16.689
same line. Here you have to
separate concepts. The first one
just sending a really long

00:19:16.689,00:19:22.161
cookie value and the second one
just replacing the equal symbol
by eh by a semi colon symbol.

00:19:22.161,00:19:27.166
Ok? And thinking about
exploitation uh so looks looks
like we are going back to the

00:19:41.013,00:19:46.018
90s code which scares and let’s
go to take the different
difficulties that we came

00:19:48.654,00:19:50.656
across. The first one is us we
identify ASLR within the stack
and heap within a half um

00:19:50.656,00:19:52.658
software debug and we hope to
exploit a real time operation
system. We so we need to reverse

00:19:52.658,00:19:54.660
engineer the firmware in order
to identify some potential
functionalities for example and

00:19:54.660,00:19:58.998
use the that functionality or
shell code. Because we don’t
have a shell here. Ok. Helpers

00:19:58.998,00:20:05.204
only we have a direct PC
overwritten, potential rewrite,
NX serial table and the whole

00:20:05.204,00:20:11.644
space of memory and we we have
the stack table. Ok. Finally, as
Mario mentioned before, the same

00:20:11.644,00:20:17.950
printer we identify memory leak
vulnerability, that provide,
that allow us to get the full

00:20:17.950,00:20:24.423
memory. So what what code wha-
what we’re going to do here is
try to use this memory leak in

00:20:24.423,00:20:30.563
order to bypass the ASLR. Ok. So
the exploitation chain should
be, we’re going to send a

00:20:30.563,00:20:35.568
shellcode to a printer between
patterns ok. We’re going to use
the memory leak vulnerability in

00:20:35.568,00:20:41.741
order to dump the the memory.
We’re going to try to identify
in dump memory our shellcode and

00:20:41.741,00:20:46.745
where and try to look into into
where our shellcode was located.
We’re going to try to uh trigger

00:20:49.915,00:20:54.920
the buffer flow and after that
jump into our shellcode. Ok? Ok
eh uh, but for our regiment

00:20:58.657,00:21:04.897
tools we want something more.
And, but so what is the most one
of the most important data

00:21:04.897,00:21:10.970
managed by a printer? Obviously
the documents. And so when don’t
create a shellcode that they

00:21:10.970,00:21:16.275
steal all documents into the
printer and send it through
reverse shell. Which sounds like

00:21:16.275,00:21:20.613
a good plan. Ok, let’s go with
the demo. For this demo we are
going to have two different

00:21:20.613,00:21:25.484
machines. The first one is the
attacker machine, which is going
to execute exploit. And the

00:21:25.484,00:21:30.356
exploit hardware that we will
take the the data from the
printer. Ok. and the second

00:21:30.356,00:21:35.928
machine is, eh, victim machine
that we’re going to send th- the
document to the printer. Ok. Let

00:21:35.928,00:21:40.933
me check the that is the. Sorry.
[mumbling] I can take well. And.
[mic noise] Uh. ok. Here you

00:21:44.136,00:21:49.141
have. De- demo, sorry for this.
Ok. Uh. This the the demo uh,
here you have the uh, the

00:22:12.398,00:22:17.503
attacker machine. Which uh which
uh, IP address and below you can
see the exploit. Is pointed to

00:22:17.503,00:22:22.208
different arguments for what is
target IP. The target port and
the reverse IP, well you to

00:22:22.208,00:22:26.345
include here the ta- the um, the
target machine IP others. So we
are going to attack the printer

00:22:26.345,00:22:31.016
one and the port 80 and after
that the we’re going to include
the printer machine. Before

00:22:31.016,00:22:36.622
execute this exploit we are
going to execute or exploit
handler that will receive or uh

00:22:36.622,00:22:41.627
all data sent from the printer.
And listening the port 1337. Ok.
And after the execute this

00:22:44.430,00:22:49.034
exploit you can see in the, uh
third line, we are ex-, we are
using the memory vulnerability

00:22:49.034,00:22:55.841
in order to find eh, operating
memory. Ok? So we have now
receive uh connection from the

00:22:55.841,00:23:00.379
printer. Got the sentence, hack
the planet friend. Because it
was included within the

00:23:00.379,00:23:06.252
shellcode. Ok. this is now the
um, the attacker machine, that
saw the victim machine uh with a

00:23:06.252,00:23:11.323
different IP address, whe- whe,
what we are going to do now is
send in these document to the

00:23:11.323,00:23:16.328
printer. Ok. we are going to
send document to the printer 1.
It is second one and after send

00:23:18.864,00:23:25.104
the document, you can see here,
for example, how the exploit,
how they receive some data. Data

00:23:25.104,00:23:30.109
from the printer. Ok so I’m now
converting this data a pdf. And
so after 2 seconds, you can see

00:23:33.145,00:23:38.817
here how we were able to a steal
all data, all documents sent
sent to the printer. Ok. And the

00:23:38.817,00:23:44.723
printer continues to print them
normally and all exploit
handler, auto forward, all data

00:23:44.723,00:23:49.762
sent to another printer
controlled by the target. So we
were able to steal all data, all

00:23:49.762,00:23:54.767
documents to a printer.
[applause] Thank you. Ok. Let’s
go with the second exploit. This

00:24:02.141,00:24:08.647
was the case, this going to be
the tricky case. Um as we didn’t
have stolen hardware debug and

00:24:08.647,00:24:13.652
other protections and
difficulties was implement this
uh this printer. So this isn’t

00:24:17.089,00:24:22.594
going to be easy to explain, uh
but we will try ok. So be
patient please, because it’s a

00:24:22.594,00:24:28.267
bit tricky. Ok. we found a
similar in the same place, but
for this printer, but in this

00:24:28.267,00:24:33.372
case we have two different parts
in the cookie value. Ok. The
first part is the the first part

00:24:33.372,00:24:39.778
is on the like a hash and the
second part seperated by a a
comma. It’s something like uh

00:24:39.778,00:24:45.984
base 64 is string. Ok. After
reverse engineering the printer
fr- the printer frameworks, we

00:24:45.984,00:24:49.588
identify some potential
vulnerabilities the code
contained this vulnerability.

00:24:49.588,00:24:52.825
Ok, but the most important
function was the function that
the code the base 64, the code

00:24:52.825,00:24:54.827
value. Ok? Uh, after analyzing
these function, we identify how
extract was based as argument to

00:24:54.827,00:24:58.030
these to the function to the
base 64 to code function and
this has different elements

00:24:58.030,00:25:04.603
included within this truck. The
first uh, elements, the source
pointer, which is the base 64

00:25:04.603,00:25:06.605
string, the second is the
destination pointer which is the
result of the base 64 string and

00:25:06.605,00:25:08.607
that will-, this will will be
filled within this this
function. This source len and

00:25:08.607,00:25:13.612
the destination len. Ok? But
this function, the base 64
function was called by the code

00:25:18.717,00:25:23.722
in the highlighted area. As you
can see here, when calling the
base 64 the code function and we

00:25:41.907,00:25:48.013
are passing a struct as
argument, ok? And the buffer
flow course because the

00:25:48.013,00:25:54.620
destination point there which is
here, was as you see into a
local array. So we send a really

00:25:54.620,00:25:59.625
long cookie value base 64 end
code, we are oper-, we are eh
um, the the base 64 function

00:26:01.593,00:26:06.598
will overflow this stack. Ok?
So, this was analyzed locally,
so we need to corroborate this

00:26:10.269,00:26:16.675
dynamically ok. So we use the
the unicorn framework in order
to emulate so some framework

00:26:16.675,00:26:22.047
that you know the unicorn eh uh
this framework allows you to
emulate different special code

00:26:22.047,00:26:27.286
as in the the resin- for
example, the resistance. And we
decide to create in the script

00:26:27.286,00:26:32.458
that they um emulate the the get
and check the second part, the
cookie, the string len, the base

00:26:32.458,00:26:37.463
64 decode and other functions.
Ok. and after the good is uh um
the script we’re we place 100 eh

00:26:41.667,00:26:48.307
100 ace as uh base 64 as
argument wi- we are able to
identify that the PC resistor

00:26:48.307,00:26:52.611
the brown code resistor was
[inaudible]. Ok. We can also see
how the uh stack pointer on-

00:26:52.611,00:26:57.616
only included with stack pointer
we can control all this data.
And uh the r4 the r4 or r5

00:27:02.654,00:27:07.659
resistor we’re also operating by
by ace. Ok? This is because the
instruction instruction execute

00:27:10.028,00:27:16.268
before before taking over this
uh pop instruction, we’re just
popping the r4, r4, r5 and the

00:27:16.268,00:27:21.273
po- register. Ok. So we have now
all the information that we need
in order to our shell code. But

00:27:23.442,00:27:28.447
everything become insane here.
We identify that the stack
wasn’t executable. We also

00:27:31.517,00:27:36.722
identify that we try to to use
many firmware addresses in order
to create our shell code to our

00:27:36.722,00:27:39.858
rope change. But that doesn’t
work properly. Ok. Uh we also
identified the this uh the the

00:27:39.858,00:27:41.860
printer was using uh a modified
t kernel RTOS, but the most
important point here is that

00:27:41.860,00:27:43.862
these uh non mono- monolithic
system and different tasks
executed the same time. So

00:27:43.862,00:27:48.867
probably which the coordination
here is take uh a code from the
framework and execute this code

00:28:00.979,00:28:06.919
in memory in a different
address. Ok. So this iteration
because we were not able to use

00:28:06.919,00:28:11.924
eh, thing others to create all
all the shellcode. Or the
change. So therefore, we didn’t

00:28:14.660,00:28:20.799
know where and how our shellcode
can be execute. We have
something like ASLR or or NX. We

00:28:20.799,00:28:25.804
have uh NX and we didn’t we- eh-
we could not able to identify
valid addresses to create a ROP

00:28:28.574,00:28:32.477
chains. But we need we need to
identify by the re- other
registers in order to do that.

00:28:32.477,00:28:37.482
Ok. So thinking about rate going
thought about different approach
that we’re going to use for

00:28:39.785,00:28:44.756
example. Reverse engineer the
t-kernel structure, but
obviously we didn’t have enough

00:28:44.756,00:28:50.429
time to do it because it could
takes weeks. Uh, reverse
engineer the bootloader in order

00:28:50.429,00:28:55.233
to identify potential static
addresses, identify static
memory, but we did not want

00:28:55.233,00:28:59.204
pemi- like configuration for
example, but we did not want
permission code we assisted to

00:28:59.204,00:29:04.876
that piece of code or memory.
Sorry. Brute-force random
addresses, like we’ll see now

00:29:04.876,00:29:09.881
are looking for helpers. Ok.
Helpers like this one, this the
infinite loop that we found

00:29:12.417,00:29:19.257
within the the bootlogger, so uh
without the equally good option,
use this infinite loop in order

00:29:19.257,00:29:25.197
to create a blind exploitation,
ok? Imagine that we have a code
that we don’t know if it

00:29:25.197,00:29:32.070
executed or not properly. What
we can do now is just after that
code, we’re going to try to jump

00:29:32.070,00:29:37.209
to our infinite loop ok. If the
printer reminds up, that means
the code was executed properly.

00:29:37.209,00:29:42.280
If the printer crashes, that
means the code was not executed
properly. So it’s something like

00:29:42.280,00:29:47.285
a blasted injection, but with
memory corruptions, ok? Um, Ok.
Uh, we decided to mix the the

00:29:49.554,00:29:54.559
infinite code helper with the uh
the following approach of brute
force in the PC register with

00:29:57.462,00:30:02.367
potential firmware addresses and
figure out what instructions
were executed. Let me explain,

00:30:02.367,00:30:04.803
ok? Uh, the main goal here is
uh, we’re going to helping us
with the code called the

00:30:04.803,00:30:06.805
infinite loop uh co-helper, we
are going to try to brute force
in the PC register ok? And we’re

00:30:06.805,00:30:08.807
going to to to try to guess or
identify what instruction was
executed or in memory blindly

00:30:08.807,00:30:10.809
ok. So remember that we can call
to the PC register on all that’s
included within this tag point

00:30:10.809,00:30:15.814
there. Ok. Imagine that we we
brute force in the PC register
we finally jump into the pop

00:30:35.000,00:30:41.239
instruction, but we don’t know
this is pop instruction, ok? And
we’re going to include some data

00:30:41.239,00:30:45.911
within our step pop in like
three set of arrays and after
that the infinite loop others.

00:30:45.911,00:30:52.551
It works good this code, the PC
re- the R0 register will be
operated by the first set of

00:30:52.551,00:30:57.556
arrays ok. Be- eh and the second
a um, the the PC register wi-
will be operating by the second

00:31:00.358,00:31:05.363
first of fi- se- second set of
face. Sorry. And so the printer
we be all the printer crashes

00:31:07.966,00:31:12.404
ok. But in order to solve this
and try to guess what
instruction was executed in

00:31:12.404,00:31:17.609
moment, we can change
information includes in included
within the stack pointer. This

00:31:17.609,00:31:24.449
is an a another example. Uh, but
for this case, we’re going to
just include one set of face

00:31:24.449,00:31:29.287
within the stack point and not
in the infinite loop others. It
works a good the same code, the

00:31:29.287,00:31:35.694
same address after the execute
this address, the r0 register
will be re-written by the first

00:31:35.694,00:31:41.066
set of face and the pc register
will be overwritten by the
second, I’m sorry, by the second

00:31:41.066,00:31:47.205
address which is an infinite
loop so the printer will remind
up. So using this methodology we

00:31:47.205,00:31:52.577
are able to identify that in
memory eh we are execute in
memory our pop register, ok.

00:31:52.577,00:31:57.582
Which is pop in our one register
and after that the in the pop
encounters. So using this

00:31:59.918,00:32:05.390
methodology uh our approach we
were able to identify three
instructions in memory. The

00:32:05.390,00:32:12.330
first was is address 12, which
was an added section. The second
is uh an add 2 uh a 14 string uh

00:32:12.330,00:32:18.737
which was uh a pop instruction
and in a research of 500 bytes
we were able to identify another

00:32:18.737,00:32:25.076
pop instruction. Ok. so our main
goal here is to identify the
same pattern that we have found

00:32:25.076,00:32:31.983
in memory in our framework. Ok.
and we finally were able to
identify this pattern, but in

00:32:31.983,00:32:37.422
another address. That means that
the kernel is execute in this
code, the kernel is applying an

00:32:37.422,00:32:44.362
upset to this to this code. And
we now know that address that
that exact address that the

00:32:44.362,00:32:50.702
kernel is using. Ok. This
provide us useful ROP gadgets in
order to create our sh- our

00:32:50.702,00:32:56.908
shell code. Um, but it provides
helpers to continue with the
task execution. Sorry for that

00:32:56.908,00:33:01.680
but this is the way that we
found in order to create our
exploit. Ok, but it was not

00:33:01.680,00:33:08.119
enough. We need more gadgets in
order to create our exploit. And
that th- this moment we remember

00:33:08.119,00:33:13.291
that as Mario mentioned before
we remember that another
function identified

00:33:13.291,00:33:19.497
vulnerability which allow us
would provide us some some
useful information was found in

00:33:19.497,00:33:24.502
the same printer. This um,
memory leak or or or information
leak vulnerability provides when

00:33:27.138,00:33:32.410
exactly uh images and gif were
uh located in mobile. Okay. So
we can use this information in

00:33:32.410,00:33:38.350
order to bypass the ASLR
protection for example. And why
not.we can also use this

00:33:38.350,00:33:42.921
information in order to create a
ROP change. Ok. Or we’re going
to do something that

00:33:42.921,00:33:49.027
exploitation with images. Ok. So
we are going to download all the
images and gif to our laptop and

00:33:49.027,00:33:53.965
we are going to use the ROP
gadget script in order to find
some interesting ROP gadgets.

00:33:53.965,00:34:00.171
Ok. Already these not coher-
code coherent code because they
are images, but we were able to

00:34:00.171,00:34:05.176
identify some useful useful ROP
gadgets to create all for
exploit. Ok. But we came of

00:34:08.980,00:34:14.286
course with another problem.
This was the last problem. I
promise you. Haha. Eh um, we

00:34:14.286,00:34:20.959
identify, uh, we came across
with caches ok, so we need to
flush the caches, then some

00:34:20.959,00:34:25.964
options here, like call ARM
instructions or different uh,
functions, like sleep, mprotect

00:34:29.100,00:34:34.639
and others. Or continue with
execution flow, which is
probably the most harder, but

00:34:34.639,00:34:40.712
the most proficient option and
we choose this option. Just
quickly, eh um, in order to

00:34:40.712,00:34:45.717
continue with execution flow, we
need that shell code implement
three different eh um, paths.

00:34:48.119,00:34:52.791
The first one is our exploit for
example, we can use, um we can
create something like for the

00:34:52.791,00:34:57.929
previous uh, exploit, where we
are going to code the print
function ID and steal all data

00:34:57.929,00:35:04.069
for reverse connection. The
second part, uh, should change
the address that we were able uh

00:35:04.069,00:35:09.607
were able to report with the
vulnerability in order to jump
in the value function. Then we

00:35:09.607,00:35:15.447
want to continue with execution,
so we need the value function
that we can get it here, ok. And

00:35:15.447,00:35:21.820
the third, uh the third part,
the umm, we should align the
step pointer again to a previous

00:35:21.820,00:35:26.558
pointer. Because we have for
example, execute or payload or
change some addresses, so we

00:35:26.558,00:35:31.296
need to align this task stack
pointer to our previous estate,
ok? And after that just trigger

00:35:31.296,00:35:36.201
the vulnerability as many times
as you want. Ok. As you work
with the demo uh for the

00:35:36.201,00:35:38.870
previous um exploit we try to
attack the document drop of our
printer, but for this demo we’re

00:35:38.870,00:35:40.872
going to attack, to try to
attack all the information
included with the within a

00:35:40.872,00:35:45.877
printer. Data. Uh let me check
demo. Ok. For for this demo we
implemented three different

00:35:49.414,00:35:54.419
function items within the within
our exploit. The first one is a
write so we can write byte into

00:36:08.500,00:36:14.239
the into the printer memory and
after that jump into that to the
memory. For example we can right

00:36:14.239,00:36:20.378
uh a set uh a set code and after
that jump into our shell code.
The second is similar to the

00:36:20.378,00:36:25.183
first one but we can write a
file that we have in our
computer, for example, into a a

00:36:25.183,00:36:30.688
piece of code. And the last one
is the grid functionality. This
allow to us to read some data

00:36:30.688,00:36:35.460
from the printer memory. But we
need to wait in order to locate
the memory or copy the memory.

00:36:35.460,00:36:40.465
Ok. So what we did here is we’re
going to try to copy the memory
that we want to read in a known

00:36:43.134,00:36:48.373
place. We know where exactly
images and gif were affected so
we’re going to use this piece of

00:36:48.373,00:36:53.311
memory in order to read the
information. Ok. Oh uh what
[inaudible] and after that they

00:36:53.311,00:36:58.316
um this size um here you have
the uh the image that we are
going to use in order to to

00:37:01.586,00:37:07.792
exploit this this function uh
here you have see- you can see
how it is a normal png header

00:37:07.792,00:37:12.464
ok. So we are going to, we are
going to use the read code to
read this address. Uh read in

00:37:12.464,00:37:17.569
500 bytes as you can see here
for example how we are reading
the information the others that

00:37:17.569,00:37:22.507
we have set and writing this
information in other in one of
the others which is the image.

00:37:22.507,00:37:29.047
Ok. And after that we are going
to download again the the image,
as you can see here the

00:37:29.047,00:37:34.385
information in the included
within the image changes and it
is now uh eh certificate

00:37:34.385,00:37:39.891
included within our printer
memory. Ok. So with this
function, we were able to read

00:37:39.891,00:37:46.231
credentials to my account uh uh
and other uh sensitive
information ok. So let’s go with

00:37:46.231,00:37:52.070
the second uh the first function
writing which is the write we
can write the circle for example

00:37:52.070,00:37:57.609
but for this demo we are going
to just write a a sentence. The
Hi Everyone sentence. We are not

00:37:57.609,00:38:03.281
to jump to this this code
because it is uh it’s uh it’s a
sentence and after write this

00:38:03.281,00:38:08.686
information uh wll load again
the image we can see for example
how the Hi Everyone sentence uh

00:38:08.686,00:38:13.691
was write in the first um, in
the first line of the image. Ok.
And let’s go with the the uh

00:38:18.530,00:38:22.534
this this other example. Which
is the write file. Which is what
we’re going to do here is we’re

00:38:22.534,00:38:27.539
going to try to overwrite an
existing web portal image ok. Uh
so we are going to select the uh

00:38:30.074,00:38:36.781
ad- uh global kit we have in
memory uh going we are going to
try to overwrite an existing

00:38:36.781,00:38:43.421
image in the in the memory. It
takes a bit so we are straight
in hello hello and we are

00:38:43.421,00:38:48.393
writing the the information
with- within the load and uh
known others. Let’s go to mode

00:38:48.393,00:38:53.398
uh firmware because it takes a
bit and after two seconds we are
going open the the uh the web

00:38:57.969,00:39:03.441
portal image which is this one,
that we are going to, we are
going to rewrite and if we

00:39:03.441,00:39:09.347
refresh again this image, we can
see how the nc group logo
overwrite the image that we have

00:39:09.347,00:39:13.851
in memory. So we can so we can
control all the information that
we have in the printer memory.

00:39:13.851,00:39:18.857
In order to read this or or to
write this eh eh into into our
printer, ok. Let’s go with the

00:39:21.459,00:39:26.464
last part, the conclusions.
>>Ok. I hope you’re all still
alive after Daniel trying to

00:39:31.502,00:39:36.507
explain this. Last exploit um,
let’s go with the responsible
vulnerability disclosure. Uh, we

00:39:38.810,00:39:45.450
started this process in February
and we got a very mixed response
from the vendors. Some of them

00:39:45.450,00:39:51.222
had a very mature procedure for
this and were really quick
fixing the issues and producing

00:39:51.222,00:39:57.228
patches. Special mention to
LexSmart which response was
great. And on the other hand

00:39:57.228,00:40:02.500
some others we could just say
that uh it was easier to find
the vulnerabilities than their

00:40:02.500,00:40:07.505
security department. So uh there
is some work to do in that area.
Um. we already published all the

00:40:10.475,00:40:15.480
security advisories. Um, most of
them two days ago. And as a
quick overview as you just saw

00:40:19.817,00:40:26.324
uh we found a lot of issues in a
lot of places, which uh lead uh
in most cases to remote conne-

00:40:26.324,00:40:31.329
code execution issues. And let’s
go for the CVE party. Um, we
found uh fi- uh well we got

00:40:38.569,00:40:43.574
fifty uh CVEs. Um, most of them
high critical risk ones and just
don’t take the number per

00:40:46.010,00:40:52.483
manufacture as an indicative of
their state of security bec-
because some of them grouped

00:40:52.483,00:40:57.488
different vulnerabilities and
are the same entries. Um. Just
for a reference, the full list,

00:41:01.526,00:41:08.166
I’m going for the main
conclusions, um, these research
aim to show how the state of

00:41:08.166,00:41:14.472
security of common office
devices uh such as printers
which are presenting most if not

00:41:14.472,00:41:21.446
total organizations is a still
very much mature and largely
not. We found a large number of

00:41:21.446,00:41:24.682
critical and high risk issues in
all the printers tested. Uh we
got uh proof of concept for four

00:41:24.682,00:41:26.684
of them. We show here, uh we
showed here two of them. One for
documents and one for other data

00:41:26.684,00:41:31.689
within the printer. And we run
out of time to um, to show a to
develop the exploits for the two

00:41:44.068,00:41:49.073
others. So but anyway, there
were issues that correlate
easily to that. Uh, a lot of

00:41:52.110,00:41:58.750
CVEs and we stopped searching
for vulnerabilities so it was
important to is a lot more of

00:41:58.750,00:42:04.689
issues eh waiting in there. And
we only attacked a few services
uh there is a lot uh more things

00:42:04.689,00:42:09.694
to research here. And by what we
saw, uh, the first one looking
at this will probably find gold

00:42:12.430,00:42:19.370
in there. And only attack
printers, but we do not expect
the same manufacture having

00:42:19.370,00:42:25.143
implementations for some of the
protocol sites such as IPP or
different web applications, et

00:42:25.143,00:42:30.148
cetera. So probably the number
num- uh devices affected by this
issues is huge. Um, mo- much

00:42:33.651,00:42:38.656
bigger than the number gave by
some of the manufacturers. We go
so say, to some vendors that

00:42:43.661,00:42:48.666
list marketing and more security
um, and the main recommendations
for for manufacturers will be to

00:42:52.236,00:42:57.241
simply invest in securities
necessary in all the development
uh faces of our product. Uh for

00:43:00.211,00:43:06.083
organizations, they should list
out consider the threats they
are um they have a lot of

00:43:06.083,00:43:12.557
sensitive information, um, not
only documents but also eh
important eh, information, the

00:43:12.557,00:43:17.361
configuration, like passwords,
the main credentials, et cetera.
And they are connected to their

00:43:17.361,00:43:24.202
corporate networks. So they are
really high risk and normal
risk, uh devices. And finally,

00:43:24.202,00:43:30.141
for hackers, uh this is a very
much your field. If you spend
some time with a devices and

00:43:30.141,00:43:36.447
start from the, with the very
basics that you will probably a
lot of issues uh you will learn

00:43:36.447,00:43:41.452
a lot. And there is a lot of fun
in here. So usually with a try.
And about internet, as expected

00:43:43.554,00:43:48.559
a quick server search revealed
lot of these devices connected
to internet. And we then saw

00:43:52.530,00:43:56.133
that um, some different vendors
uh seem to be using the same
code for some things like this

00:43:56.133,00:44:02.106
web application two different
ones. Which as you can see is
quite similar so maybe we tested

00:44:02.106,00:44:04.108
more vendors that than we
thought. And finally
acknowledgements, uh, thanks uh

00:44:04.108,00:44:06.110
to the Madrid Office to Matt
Lewis and Phillip Moss for all
their help. And support. Also,

00:44:06.110,00:44:08.112
thanks to Mario and Chris who
suffered us the most. And last
but not least thank you to

00:44:08.112,00:44:13.117
Alvaro Felipe eh, who as part of
the research in the first days
and also helped us with great

00:44:21.792,00:44:26.797
ideas uh during the this
exploitation phases. So it was
very difficult to put this talk

00:44:39.677,00:44:44.682
in this months of research in
just 45 minutes, but uh thank
you for suffering us. That’s it.

00:44:50.488,00:44:53.324
[applause]

