00:00:00.033,00:00:03.871
>>Good afternoon everyone. Thank
you very much for coming. Uh my
name is uh Christopher Wade I’m

00:00:03.871,00:00:08.942
a pentester with a company
called Pen Test Partners. Um you
should see my slides in a second

00:00:08.942,00:00:14.948
I think. Um and today I’m gonna
talk about um attacks like-
attacks against NFC. Now what

00:00:14.948,00:00:18.418
really I’m going to talk about
is how you can take very
rudimentary components, like

00:00:18.418,00:00:22.489
those that are not generally
used for creating NFC based
technologies and use them in

00:00:22.489,00:00:27.628
order to create attack tools
that can be used to um basically
attack NFC readers rather than

00:00:27.628,00:00:32.599
do things like um attack NFC
tags themselves in order to uh
get their contents. Now um this

00:00:37.271,00:00:42.276
is- I th- I think my slides
aren’t coming up here. Um.
[applause and cheers] And that’s

00:00:50.350,00:00:56.757
my talk about PowerPoint thank
you very much. [audience laughs]
So yeah we’ll talk about um

00:00:56.757,00:01:00.160
tag-side attacks against NFC. So
basically we’re gonna talk about
how you can take some very very

00:01:00.160,00:01:05.666
basic components in order to
make um NFC analysis and attack
tools. So firstly, what is NFC?

00:01:05.666,00:01:09.503
Well we all know what it is.
It’s contactless communication
between usually a card and some

00:01:09.503,00:01:13.874
kind of reader that um
illuminates the card in order to
power and communicate with it in

00:01:13.874,00:01:18.278
order to do things like pay for
things, open doors, or other
applications that are quite

00:01:18.278,00:01:23.317
useful. So um I don’t know why
I’ve got a picture of some gates
there, but it’s pretty much the

00:01:23.317,00:01:27.854
main purpose of this. Um we’re
gonna show some techniques for
attacking things, mainly to do

00:01:27.854,00:01:32.960
with door control access
systems. So first we’re gonna
talk about uh some ISO numbers

00:01:32.960,00:01:38.098
so we’re gonna talk about
ISO-1443 um which focuses on 13
point 5 6 megahertz NFC

00:01:38.098,00:01:42.235
communication. It defines the
characteristics of the
communication basically how it

00:01:42.235,00:01:47.240
works, how the protocol works
and it’s split out into 2
sections, A and B which are used

00:01:47.240,00:01:51.545
for different purposes and have
different protocols on both a
higher and lower level. Um the

00:01:51.545,00:01:56.783
most common of these is
ISO-14443A uh which is uh mainly
used for Mifare classic, Mifare

00:01:56.783,00:02:02.456
Ultralight, and other Mifare
systems. Um so low level
communication basically works on

00:02:02.456,00:02:09.162
ISO-1443A which I’m gonna try
and stop saying, um by powering
the uh tags with electromagnetic

00:02:09.162,00:02:12.933
induction. Literally powering
the device with the same
mechanism it’s using to

00:02:12.933,00:02:16.803
communicate with it. So
communication is performed by
essent- basically cutting power

00:02:16.803,00:02:20.741
to the tag every so often, in a
fast enough manner that it
doesn’t turn off the tag but

00:02:20.741,00:02:25.212
allows it to receive data back.
Now the responses are performed
by the tag by modulating the

00:02:25.212,00:02:29.650
amount of power being drawn from
the reader to the tag.
Essentially uh modulating on

00:02:29.650,00:02:33.754
that in order to send responses.
It’s sort of a 1 way
communication by uh receiving

00:02:33.754,00:02:37.891
more power from it. Uh they use
2 different coding schemes;
Modified Miller coding which is

00:02:37.891,00:02:42.929
designed specifically in order
to um uh produce the amount of
power um loss that’s gonna

00:02:42.929,00:02:48.335
happen, and Manchester Coding
cause it’s good because of uh
timing issues that may occur. So

00:02:48.335,00:02:53.707
Modified Miller coding basically
yeah it minimizes the power
loss. Um it has a very strange

00:02:53.707,00:02:59.179
um like um protocol basically. 0
after 0 bit means that it’s low
for the first quarter of the

00:02:59.179,00:03:03.817
transmission and then high
again. 0 after 1 bit high for
the ent- entire transmission.

00:03:03.817,00:03:08.155
And 1 uh 1 bit is high for the
first half of the transmission
followed by low for 1 quarter of

00:03:08.155,00:03:12.392
the transmission and high again.
Basically this is done in order
to no matter what the

00:03:12.392,00:03:17.064
communication is, not have a
small space between the off um
sections of the communication

00:03:17.064,00:03:21.034
nor to prevent there to being
glitches or problems with the
power as it goes along as this

00:03:21.034,00:03:26.006
can cause problems for the
readout protection. Manchester
coding is uh done in order to

00:03:26.006,00:03:30.243
prevent timing issues. Basically
this is used among all other
kinds of radio technologies

00:03:30.243,00:03:35.282
including AVSB which you may
know if you like UART or SDR
technologies. Um and basically

00:03:35.282,00:03:39.920
uh how they use it is to
modulate the amount of power
being received in order to um

00:03:39.920,00:03:46.593
communicate either a 1 or a 0 by
basically uh modifying the uh
phase of the signals. So basic

00:03:46.593,00:03:50.163
ene- enumeration of the uh NFC
we’re gonna look at today is
basically a requi- it starts

00:03:50.163,00:03:53.900
with a request or a wake-up
command. Which basically
requests any tags that haven’t

00:03:53.900,00:03:58.171
spoken or are ready to speak.
And ATQA which responds the
initial part of what the tag

00:03:58.171,00:04:03.944
does. A select which requests
the unique identifier from the
tag. And a further select in

00:04:03.944,00:04:07.380
order to select that specific
tag depending if there’s more
than 1 on the reader. And then a

00:04:07.380,00:04:11.852
final sak um value which
basically says the final
information about what this tag

00:04:11.852,00:04:16.690
does. And then contin- continued
enumeration and communication
based on what’s happened there.

00:04:16.690,00:04:21.995
Now this could be extended
unique identifiers or more
cryptography. A big thing that I

00:04:21.995,00:04:26.133
found when it came to this was
uh, a feature called called anti
collision which basically exists

00:04:26.133,00:04:33.006
when there are 2 tags within a
reader that haven’t spoken yet
causing issues which um uh could

00:04:33.006,00:04:37.544
uh stop the reader from being
able to uh decide which tags are
on the thing. So for instance if

00:04:37.544,00:04:41.848
we look at the request that we
made, the first thing that
happens is the tag sends an ATQA

00:04:41.848,00:04:45.652
response. Now because both tags
don’t know they’ve spoken yet,
both will send a tag- er

00:04:45.652,00:04:51.758
response at the same time.
Basically causing uh corrupting
communication from both. Now how

00:04:51.758,00:04:57.464
it’s- this is resolved is by the
reader specifically um
requesting specific bits from

00:04:57.464,00:05:01.168
the tag in order to find ones
that don’t match, as these
identifiers are meant to be

00:05:01.168,00:05:05.705
unique. So there’s a couple of
different ways of um encrypting
autheti- and authenticating

00:05:05.705,00:05:09.142
depending on what the tags are.
So there’s Mifare Ultralight
which is extremely simple. You

00:05:09.142,00:05:12.913
send a password to the tag and
it says either yes or no. Now
this uh can often increase the

00:05:12.913,00:05:17.083
counter which basically locks
the chip and stops it from being
used again. This is a common

00:05:17.083,00:05:22.088
technology in things like
amiibos that you fi- find on uh
Nintendo products. Um, there are

00:05:22.088,00:05:25.192
other ways of doing it. There’s
having no communication
whatsoever, just reading and

00:05:25.192,00:05:30.463
writing in data. Or newer
versions like Mifare Ultralight
C allow you to um use um more

00:05:30.463,00:05:34.701
stringent encryption and
authentication methods. Uh
Mifare Classic which we’re gonna

00:05:34.701,00:05:37.938
focus on quite a lot today
because it’s an older technology
but a technology that’s used

00:05:37.938,00:05:42.409
everywhere. Um uses the uh
Crypto- 1 algorithm that’s often
called the Crapto-1 algorithm

00:05:42.409,00:05:48.215
for the fact that it’s got very
very very weak encryption, weak
keying. Um basically the reader

00:05:48.215,00:05:52.219
requests authentication, the tag
responds with a 4 byte nonce.
The reader responds with a

00:05:52.219,00:05:55.722
random value, followed by an
encrypted number that’s
generated from that original

00:05:55.722,00:05:59.960
nonce. And then the tag responds
with another encrypted number
from that data. Basically it’s a

00:05:59.960,00:06:03.530
mutual authentication scheme
where both the tag and the
reader know that they both have

00:06:03.530,00:06:06.700
the same key they’re working
with. All the further
communication after this is

00:06:06.700,00:06:10.403
encrypted in order to prevent an
attacker from basically being
able to read or write attack

00:06:10.403,00:06:15.008
even when they’re not allowed
to. There’s Mifare DESFire which
is probably 1 of the later

00:06:15.008,00:06:18.445
technologies and 1 that’s used
all- in all sorts of things. I
live in London so it uses, it’s

00:06:18.445,00:06:23.450
being used in Oyster cards in
order to um work with the
transit systems. And that’s it’s

00:06:23.450,00:06:28.888
got much stronger encryption
authentication. If you use DES,
triple Des or AES and can do it

00:06:28.888,00:06:33.593
all based on very specific
sectors of the data. Um multiple
keys can be used on each section

00:06:33.593,00:06:39.399
and it- some- it’s authenticated
similarly to Mifare Classic. Now
crypto-1 has a lot of issues

00:06:39.399,00:06:42.636
with known plaintext attacks due
to the fact that streams like
them but when you’re using

00:06:42.636,00:06:47.607
things like DES, Triple DES and
AES, uh plain- known plain text
becomes not very useful and it’s

00:06:47.607,00:06:53.146
not really been broken in any
meaningful manner via crypto
analytic techniques. So we’re

00:06:53.146,00:06:56.249
gonna talk about creating the
analysis tools that I worked
with for this project. So

00:06:56.249,00:07:00.220
obviously there’s a few we know
about there’s the Proxmark 3 and
the Chameleon Mini which are

00:07:00.220,00:07:04.557
probably the most well known of
these uh uh NFC attack tools
that people see. There’s

00:07:04.557,00:07:09.329
HydraNFC which is something more
of a hobbyist’s product, but is
very very useful. I use some of

00:07:09.329,00:07:13.533
this in the technology we’ll be
using today. SimpleNFC which has
some similar hardware to what

00:07:13.533,00:07:17.904
I’m working with and is a very
interesting product in and of
itself. And Emutag which also

00:07:17.904,00:07:24.077
has some uh benefits to it. So
let’s start with the absolute
basics. If you take an LED and a

00:07:24.077,00:07:28.081
coil of wire and solder them
together you can detect an NFC
field. That’s all you need to

00:07:28.081,00:07:32.052
see that NFC is working. It will
literally light that LED as soon
as you put it within the field’s

00:07:32.052,00:07:37.190
reach and show that it’s
working. But if you want to go
higher level and get more

00:07:37.190,00:07:40.760
details about the communication,
you can create a passive
sniffer. Now I did this with an

00:07:40.760,00:07:46.866
RTL-SDR which we all know is a
very very basic very cheap SDR
tool that’s definitely not meant

00:07:46.866,00:07:51.971
to be an SDR tool. Uh this is a
device that is basically reverse
engineered from uh uh TV tuners

00:07:51.971,00:07:56.643
that people use via USB um but
it has some very great libraries
that basically allow you to work

00:07:56.643,00:08:00.680
with it as an SDR tool. There
are some problems with it, that
it can’t tune down to the exact

00:08:00.680,00:08:04.784
frequency that’s being worked
with for NFC. It can’t r- cannot
run at the low sample rate

00:08:04.784,00:08:08.855
required for NFC. And It’s
bundled with a really weak
antenna so it's not really

00:08:08.855,00:08:13.626
useful for many purposes. It’s
also not built for purpose for
being an SDR in the first place,

00:08:13.626,00:08:17.330
it’s built as a TV tuner,
meaning anything we do to it is
gonna be very uh difficult to

00:08:17.330,00:08:22.635
work with. So what I ended up
doing is because I couldn’t tune
down to 13 point 56 megahertz

00:08:22.635,00:08:27.474
because the range was 25
megahertz to 1700 megahertz, I
tuned to 27 dot 12 megahertz

00:08:27.474,00:08:33.113
which is a harmonic value of 13
point 5 6. Um as long as I had a
coil within the uh vicinity of

00:08:33.113,00:08:35.682
the reader or a tag within the
vicinity of the reader, the
power throughput was enough that

00:08:35.682,00:08:41.988
I could analyze the uh
communication from the reader
using this uh methodology. And

00:08:41.988,00:08:45.959
by setting the sample rate to uh
double what it should be I could
still get the correct sampling

00:08:45.959,00:08:49.496
for what I was trying to
communicate with. I didn’t
require any antenna modifi-

00:08:49.496,00:08:53.533
modifications because of this I
used a traditional antenna and a
coil of wire wrapped around it.

00:08:53.533,00:08:59.305
Nothing else. Um the problem was
I couldn’t actually re- get any
responses from tags to the

00:08:59.305,00:09:04.244
readers because the harmonic
values and the nature of the um
the uh antennas we- I was using

00:09:04.244,00:09:10.517
just weren’t capable of it. So
here’s some uh basic output of
how this came. So this is fr- uh

00:09:10.517,00:09:16.055
output from the tool I made out
of the RTL last year. Showing um
a request uh message a select

00:09:16.055,00:09:20.427
message, a uh halt message, and
then there’s the request
message. Now this is done in

00:09:20.427,00:09:24.964
order to um find any tags within
the field that haven’t spoken
yet without waking up the ones

00:09:24.964,00:09:28.935
that already have, basically to
prevent the anti collision from
happening. There is then the

00:09:28.935,00:09:32.071
wake up command which wakes up
every tag in the field so that
it can communicate with them

00:09:32.071,00:09:37.877
again. So I made some analysis
tools I wanted to make a tag
myself out of components that

00:09:37.877,00:09:42.315
you wouldn’t traditionally use.
Now some people use things like
PN 532 boards and other NFC

00:09:42.315,00:09:45.385
boards which are great but
you’re not getting down to the
raw level, you’re basically

00:09:45.385,00:09:50.523
communicating with something
that’s meant to be a tag. Um so
I wanted to use no NFC chipsets,

00:09:50.523,00:09:54.094
but obviously I’d need to use a
micro controller, but I wanted
to build it with as minimal

00:09:54.094,00:09:58.164
components as possible. If I
could do it with like a w- piece
of wire, and a microcontroller I

00:09:58.164,00:10:02.569
would have. Unforfunately wh-
that wasn’t possible. Um I had
to implement the full Crypto 1

00:10:02.569,00:10:06.339
authentication um which would
add quite a lot of complexity to
the project and mean that I’d

00:10:06.339,00:10:10.310
need a micro controller with
sufficient power to do it. Um by
imp- fully implementing this I

00:10:10.310,00:10:14.214
hope to find some weaknesses
that other people haven’t found
or introduce ones that people

00:10:14.214,00:10:18.985
have found but haven’t fully
implemented yet. So there’s a
few things that happen when you

00:10:18.985,00:10:24.624
need to uh work with the NFC
field versus inductive coupling.
Now this is for um producing

00:10:24.624,00:10:29.062
power and fortune switching the
communicate- communications back
and forth. So it’d need to be d-

00:10:29.062,00:10:34.267
demodulated by the amplitude
because uh basically power and
powering- off the uh field in

00:10:34.267,00:10:37.137
order to communicate with it is
essentially the same as on off
keying used in traditional

00:10:37.137,00:10:43.943
radios. Because of this I would
need to um use uh some amplitude
um detection technologies. Uh

00:10:43.943,00:10:48.081
I’d need to have a decently fast
micro controller with enough
power to do um uh encryption

00:10:48.081,00:10:52.218
calculations and enough storage
in order to do encryption
calculations. And I would need

00:10:52.218,00:10:56.656
enough sufficient memory on the
device to store any attacks that
I’ve made. So we’re gonna go

00:10:56.656,00:11:00.660
from the basics of how this
circuit would work. So the first
thing we would need is an LC

00:11:00.660,00:11:05.965
circuit. Now this is for
inductive coupling with uh, uh a
NFC reader. It’s made of an

00:11:05.965,00:11:10.703
inductor and a capacitor so
that’s what LC circuit L for
inductor and C for capacitor.

00:11:10.703,00:11:17.277
And basically the q- uh con-
inductor was a coil of wire and
then we just used a 10 peaker

00:11:17.277,00:11:21.281
for a capacitor in order to uh
attune with that. The resonance
we checked with a logic analyzer

00:11:21.281,00:11:26.986
rather than a um uh a scope
which you would usually use even
though it’s digital information

00:11:26.986,00:11:31.524
you can at least check that the
frequency was correct, 13 point
5 6 megahertz. Alright we then

00:11:31.524,00:11:35.228
need to demodulate this so I
basically took and made an
envelope detector. Now these are

00:11:35.228,00:11:39.966
traditionally used in um AM
radios and that kind of
technology. Um can be made from

00:11:39.966,00:11:44.404
a diode, a resistor, and a
capacitor. This will rectify the
signal and then um basically

00:11:44.404,00:11:47.941
smooth it in order to get the
actual signal that’s trying to
be transmitted. Basically

00:11:47.941,00:11:53.179
instead of having the uh AM wave
as it wa- as it was. I via trial
and error found out that I

00:11:53.179,00:11:58.184
wanted to use a 1 k resistor and
a 220 pico-Farad capacitor and
that seemed to work very well.

00:11:58.184,00:12:01.621
Again I just took the circuit
and plugged it into a logic
analyser and I got exactly what

00:12:01.621,00:12:06.225
I wanted. Now that communication
there is a wake up command uh
basically modulated via the

00:12:06.225,00:12:11.497
Modified Miller protocol and
encoding schemes. So that’s the
full circuit that you'd need to

00:12:11.497,00:12:15.602
use in order to connect a
microcontroller on to the NFC
technologies that are being

00:12:15.602,00:12:21.240
used. Now I don’t often draw
circuits so it's not perfect but
it does seem to work. I would

00:12:21.240,00:12:28.047
then tie 1 pin to a GPIO input,
um and then that same pin to
GPIO output in order to um uh

00:12:28.047,00:12:34.520
modulate on the power uh being
received, and then just to the
ground on the other 1. I’ve-

00:12:34.520,00:12:38.057
while I said that I wanted to
use a- a microcontroller with
sufficient power, I actually

00:12:38.057,00:12:44.030
went for the ATTiny84 which is a
very very very small very weak
chip. It’s got an 8 kilobyte

00:12:44.030,00:12:49.836
program space and 512 bytes of
RAM, which is nothing, that’s 1
and a half tweets. So not much

00:12:49.836,00:12:54.140
to work with. It can be
programmed with an Arduino or a
ISP programmer although this

00:12:54.140,00:12:58.478
makes it very difficult to debug
with. And it can use external
crystals basically in order to

00:12:58.478,00:13:02.448
get it to tune it to the
frequency you want. It’s also in
DIP package so I could build

00:13:02.448,00:13:06.252
this on a breadboard, test it,
and then solder something
together as I need it. I could

00:13:06.252,00:13:09.789
literally just attach the
circuit I made before to the
GPIO pins and receive the data.

00:13:09.789,00:13:14.027
The interruption and timings on
it were very good, but the
debugging capabilities were

00:13:14.027,00:13:19.332
quite lackluster. Um because it
was um an 8 bit architecture
being used, uh encryption

00:13:19.332,00:13:26.305
calculations were very very uh
unuseable on it. So I took a 13
point 5 6 mega- megahertz

00:13:26.305,00:13:30.076
crystal and their matching
capacitors required in order to
um work with it on this

00:13:30.076,00:13:34.814
microcontroller and soldered
them up. Now I could set all the
um fuses in order to make sure

00:13:34.814,00:13:39.485
the ATTiny was performing at the
exact frequency we wanted. I
then took the receiving circuit

00:13:39.485,00:13:44.390
and connected it to an input and
an output pin in the ground. And
due to the lack of UART I

00:13:44.390,00:13:50.229
searched in GPIOs to basically
make a software based ace- SPI
master in order to uh print out

00:13:50.229,00:13:54.967
any debug strings that I
required. Which was very slow
but was good in the early stages

00:13:54.967,00:13:59.038
of this in order to see how the
communication was working. I
then added an LED just so I knew

00:13:59.038,00:14:03.376
when the thing was working and
not crashing. Uh the state
machine that uh was used for

00:14:03.376,00:14:07.447
enumeration, the authentication,
and everything else, was
implemented and allowed the

00:14:07.447,00:14:12.652
device to behave as a tag as
needed. 1 of the big problems I
had was the uh the timing

00:14:12.652,00:14:17.590
issues. A 13 point 5 6 meg-
megahertz crystal um with an
ATTiny is gonna have a lot of

00:14:17.590,00:14:21.828
clock drift, just because it’s a
very non standard frequency and
it’s not 1 traditionally used.

00:14:21.828,00:14:25.865
Um basically what I was trying
to do was at predefined
intervals 847 and a half

00:14:25.865,00:14:31.003
kilohertz which is the uh data
rate of the communication, I’d
read the value of the GPIO. Now

00:14:31.003,00:14:33.940
this worked about 50 percent of
the time to get an accurate read
of the communication that was

00:14:33.940,00:14:39.212
going on. But eventually it just
got out of synch and it just
wouldn’t work anymore. So what I

00:14:39.212,00:14:45.985
did was I um took all the times
the power was uh taken down and
um checked the timings between

00:14:45.985,00:14:49.288
each 1. And this basically
helped me build up
communications just for time as

00:14:49.288,00:14:53.426
it interrupts and made it
possible to be very vague about
the uh timings between these

00:14:53.426,00:14:57.930
things. And it basically by
doing this I got 99 percent
accuracy which was enough to

00:14:57.930,00:15:04.237
keep the tag and the reader
happy and communicating fully.
So um Crypto-1 eh was meant to

00:15:04.237,00:15:08.141
be a proprietary library and
people have reverse engineered
it and created the Crapto-1

00:15:08.141,00:15:12.278
library which is an excellent
name for any GitHub project. Um
there are lots of papers

00:15:12.278,00:15:17.216
involved with this that made it
very easy to understand what was
going on. And it’s really not a

00:15:17.216,00:15:21.554
good encryption algorithm even
from the get go. It uses a 48
bit key scheme but separating

00:15:21.554,00:15:26.959
these 24 bit keys into 24 bit
keys that are cycled between as
authentication goes on. Uhm

00:15:26.959,00:15:32.098
which also made um the ATTiny
have to do some very strange uh
calculations in order to work

00:15:32.098,00:15:38.304
with it. Um the big problem was
that um when you have a micro
controller like the 32 bit 1

00:15:38.304,00:15:41.407
when you’re working with things
like 16, 24, and 32 bit
calculations, things can be done

00:15:41.407,00:15:46.145
very quickly. There are some
problems that mean that an 8 bit
uh calculation will take like at

00:15:46.145,00:15:51.851
least 3 to 4 times in order to
perform the same calculations.
Um especially this happened with

00:15:51.851,00:15:55.822
the bit shifts that happen. Most
things that are microcontrollers
can do multiple bit shifts in 1

00:15:55.822,00:16:00.927
operation whereas the AVR uh
microcontroller set can only do
1 bit shift at a time which is

00:16:00.927,00:16:06.599
very slow. The problem with this
is that um most readers want a
response within 17 microseconds

00:16:06.599,00:16:11.838
when you uh- send a request. And
so I had to make sure I did this
very quickly. I identified that

00:16:11.838,00:16:15.975
the big problem was in the
filter function of Crypto-1.
Which has a lot of um multi byte

00:16:15.975,00:16:20.980
shifts and calculations going
on. So I identified all the
parts of this where the-

00:16:20.980,00:16:25.418
everything was going too slow
and all the communication
wouldn’t work and I calculated

00:16:25.418,00:16:30.790
these and took them in order to
uh work out how I could improve
the speed using assembly rather

00:16:30.790,00:16:36.729
than C. So all the Crypto- 1
code was converted to C- from C
to assembly by hand in order to

00:16:36.729,00:16:40.700
make sure that I could uh speed
up anything I needed to. Now we
all know that if you write uh-

00:16:40.700,00:16:44.437
assembly by hand rather then
letting the compiler do it,
things become a lot more

00:16:44.437,00:16:49.642
efficient. I used the SimAVR um
emulator which basically allows
you to um pretend you’ve got an

00:16:49.642,00:16:54.013
AVR microcontroller apart from
the important hardware parts to
print out data as it was going

00:16:54.013,00:16:58.818
along so I can test and do unit
testing against keys from the C
version and the assembly

00:16:58.818,00:17:03.022
version. I took all the
calculations that woulda been
treated as 32 bit when they

00:17:03.022,00:17:07.460
could have been 24 or 16 bit and
converted them to 24 bit
operations. Basically this meant

00:17:07.460,00:17:12.899
I could use 1 register or 2
registers whereas usually they
would be using 4. Um all bit

00:17:12.899,00:17:17.370
shifts were converted as needed
so a 16 bit shift can just be
used by 2 move instructions, 8

00:17:17.370,00:17:22.642
bit shifts 1 move instruction, 4
bit shifts the AVR uh micro
controller has the SWAP command

00:17:22.642,00:17:27.480
which SWAPs the upper nibble and
lower nibble of the byte. Um the
2 bit shifts could just be done

00:17:27.480,00:17:32.785
with traditional shift- um bit
shift operations. And 1 bit
shifts, just a shift operation.

00:17:32.785,00:17:37.490
Uh basically I’m actually making
the thing 10 times faster by
doing this. Here is some of the

00:17:37.490,00:17:43.696
assembly kit that was used. It’s
uh not pretty but it is very
effective as- as needed. Um here

00:17:43.696,00:17:48.334
are the uh prototype boards I
made. Now the top 1 um has the
program header and a button to

00:17:48.334,00:17:52.538
switch between tag versions and
tag data, and the bottom has
everything you need to emulate a

00:17:52.538,00:17:56.475
Mifare classic attack using the
platform. You don’t need
anything more than those 5 or 6

00:17:56.475,00:18:00.279
components that are on the
board. Um these worked very
effectively and allowed me to

00:18:00.279,00:18:05.384
basically emulate anything I
needed to. So I could take an
NFC reader now this is the NFC

00:18:05.384,00:18:08.721
reader that I took to DEFCON
China recently and discovered
that it is the same 1 they use

00:18:08.721,00:18:15.361
in Beijing airport which was
very fun to get through customs,
believe me. Um [laughter] they

00:18:15.361,00:18:21.634
did question it but they let me
through anyway. Um I basically
could make it print out your IDs

00:18:21.634,00:18:27.106
by um sel- uh putting an NE- NFC
tag on top of it, and I took my
device and laid it over it and

00:18:27.106,00:18:32.111
got responses. And I want to do
a quick f- uh demonstration
video of this for everyone. Um.

00:18:37.817,00:18:42.822
Hopefully. Nope. Oh. 1 second,
sorry.So literally I could wave
the thing on top and the NFC

00:18:54.200,00:18:58.437
reader would print that out and
that allowed me to know that it
was communicating effectively

00:18:58.437,00:19:03.376
and that the reader was working.
Uhm. So there were ha- some
hardware limitations with this.

00:19:06.779,00:19:10.383
Ultimately I made something that
could emulate a tag fully but I
couldn’t now make an attack tool

00:19:10.383,00:19:15.154
out of it. Basically it was too
slow and didn't have enough
memory to do it. I used 400

00:19:15.154,00:19:21.260
bytes of the RAM and 7000 bytes
of the Flash which seems like a
lot but I would only have about

00:19:21.260,00:19:26.265
100 bytes of RAM left and 1 k of
Flash left to work with, which
wouldn't be enough to make any

00:19:26.265,00:19:30.469
real attacks from this. Also the
EEPROM on the device just didn’t
have enough to store an entire

00:19:30.469,00:19:35.474
NFC tag. So a Mifare classic tag
um uses 1k of uh data uh except
in very specific um uh instances

00:19:38.377,00:19:41.681
and because of this I wouldn’t
be able to store a whole tag but
I could perform some attacks on

00:19:41.681,00:19:45.785
it. So I was in a sort of catch
22 with this thing. Complex
functionality on an AVR

00:19:45.785,00:19:50.423
microcontroller, especially
debugging, it’s just not
possible. Um unless you’ve got a

00:19:50.423,00:19:54.060
much more expensive set up than
I did. I was using the most
basic and cheap tools I could

00:19:54.060,00:19:58.330
find. And the number of pins on
the thing which was a total of
14 just wasn’t enough to add any

00:19:58.330,00:20:04.270
extra functionality I’d want to.
Uh the slow responses from the
uh the tag were just making it

00:20:04.270,00:20:08.474
very difficult to work with very
specific readers which meant I
couldn’t make it work in all

00:20:08.474,00:20:14.046
instances. So I decided to build
a better device with something a
lot more powerful. I used the

00:20:14.046,00:20:20.820
STM32L496ZG which is a
development board um and uh uh
and a microcontroller which has

00:20:20.820,00:20:25.491
a huge amount of power and a
huge amount of capabilities for
a very small price. Um it’s

00:20:25.491,00:20:30.396
about 18 pounds on Amazon and
nowadays that means it’s about
18 dollars as well. Um it has 1

00:20:30.396,00:20:36.469
megabyte of flash and 320
kilobytes of RAM, that’s 640
times more than the ATTiny,

00:20:36.469,00:20:39.905
which is really crazy when you
really think about it. The clock
speed can go all the way up to

00:20:39.905,00:20:43.576
80 megahertz which would allow
me to uh basically not have to
use an external clock if I was

00:20:43.576,00:20:48.280
clever about it. And the 32 bit
architecture meant that I could
implement all the encryption

00:20:48.280,00:20:52.618
authentication without having to
do anything too clever like
write assembly. Um it has USB

00:20:52.618,00:20:55.788
and UART capabilities meaning I
could make it a proper attack
tool with commands being

00:20:55.788,00:21:00.526
received and sent. And it’s got
proper printf debugging so if
you plug in to the ST link at

00:21:00.526,00:21:07.066
the top, you can debug this
thing fully extremely easily.
The Ping configurations on it

00:21:07.066,00:21:12.505
can be set using the STM32Cube
software suite which basically
allows you to click on the chip,

00:21:12.505,00:21:16.609
decide which 1 you are gonna to
work with, and set what each pin
does, like if you want to be a

00:21:16.609,00:21:21.080
timer, an external GPIO and set
the clock rate. Uh now the clock
rate is very important because

00:21:21.080,00:21:26.185
this thing wouldn’t be able to
synchronize with a strange SP
like 13 point 5 6 megahertz. So

00:21:26.185,00:21:30.055
because of this I decided to
find a- the clockspeed that it
would support that was closest

00:21:30.055,00:21:35.060
to what I wanted. Um when this
occurred I basically um decided
I didn’t want to use an external

00:21:37.830,00:21:42.601
crystal, the thing already had 1
and it would have incor-
involved some SNB soldering and

00:21:42.601,00:21:46.438
it could have broken the device.
Because of this I wanted to uh
look at all the range of

00:21:46.438,00:21:50.376
frequencies that um it could run
out, which is this huge amount,
and find the 1 that had the most

00:21:50.376,00:21:55.147
suitable candidate. Now this was
important because um Myfair
classic and all other NFC in

00:21:55.147,00:22:00.052
this area uses uh Manchester
coding for the responses which
means it’s inherently got this

00:22:00.052,00:22:04.557
ability to uh keep track of the
timing and the frequency that’s
going on, so that if you get out

00:22:04.557,00:22:08.227
of synch with it, eventually it
can pick it back up again. So I
looked through all the possible

00:22:08.227,00:22:13.532
values it can be and found that
72 megahertz was the fastest and
the least uh problematic um

00:22:13.532,00:22:18.537
value I could use. So it was
only um gonna be about um what
50 percent of RAM speed. So this

00:22:20.906,00:22:25.611
the DUART side again extremely
simple big coil of wire, a
capacitor, a diode, resistor and

00:22:25.611,00:22:29.949
another capacitor. And that’s
all I need to conf- needed to
convert this device into an NFC

00:22:29.949,00:22:34.186
tag that would be used to
perform attacks in this
platform. It’s extremely simple

00:22:34.186,00:22:37.590
but effective and I really
didn’t want to do anything far
too complex because it just

00:22:37.590,00:22:41.927
wouldn’t be necessary. I wanted
to have a lot of different
features with this, especially

00:22:41.927,00:22:45.097
ones that weren’t present in
ama- existing commercial devices
like the ProxMark and the

00:22:45.097,00:22:49.001
Chameleon. Not because these
devices aren’t excellent but
because if I’m just covering

00:22:49.001,00:22:52.972
their work, it’s just not fun
anymore. So I made it so that it
can emulate more than 1 tag at

00:22:52.972,00:22:56.742
once, now this is a very useless
uh ability but it would mean
that I could m- put it on a

00:22:56.742,00:23:00.079
reader and the reader would
think that there was 2 uh tags.
This could have caused

00:23:00.079,00:23:03.382
authentication issues,
communication issues, uh make
the thing just get very

00:23:03.382,00:23:07.620
confused. So this can be handled
by just taking the same state
machine that was being created,

00:23:07.620,00:23:11.991
and making sure that the
responses uh matched what would
happen if there were 2 tags in

00:23:11.991,00:23:16.195
the field. So this would by
either forcing anticollision by
sending randomized data when

00:23:16.195,00:23:20.532
selections were made, or by
cascading requests, so 1 tag was
selected the way it could be

00:23:20.532,00:23:24.670
selected and then bring up the
other 1 in it. Th- there was not
a huge amount of weaknesses I

00:23:24.670,00:23:29.875
could find on this but I thought
it was quite interesting. Dynam-
dynamic Crypto-1 key generation

00:23:29.875,00:23:34.813
was another 1. Now this would
allow me to uh make a number of
different UIDs and basically

00:23:34.813,00:23:38.150
cycle through them while also
changing the encryption keys
being used. This would allow me

00:23:38.150,00:23:42.554
to quickly work out how the uh
authentication was working and
help me more easily generate

00:23:42.554,00:23:47.026
tags based on what I wanted to
from random data, but also
changing the keys to match. This

00:23:47.026,00:23:51.797
is because a large number of
these devices um authenticate
using keys generated from their

00:23:51.797,00:23:57.102
unique identifiers. So that it’s
not the same for every single uh
tag that’s being put in the

00:23:57.102,00:24:02.141
field. Now this is very useful
but um it can cause some
problems with authentication in

00:24:02.141,00:24:08.314
general. I wanted to implement
DESFire which has been
implemented on a few um uh uh

00:24:08.314,00:24:12.584
forked versions of ProxMark and
Chameleon Mini but not in the
main land versions as far as I

00:24:12.584,00:24:17.022
know. Now you can make the thing
pretend to be 1 of these just by
modifying the SAK and ATQA

00:24:17.022,00:24:21.994
values that the tag would
present and make sure the
response values matched as

00:24:21.994,00:24:26.832
needed. Um I basically uh wanted
to replay any legitimate
responses I could get from a

00:24:26.832,00:24:31.403
reader, so I took a DESFire tag,
put it against my phone and see
how- saw how it read and sort of

00:24:31.403,00:24:35.908
replicated that as I went along.
As it um basically just went
through each part- section of

00:24:35.908,00:24:40.512
this. Um the authentication
functionality is well documented
and as their source code about

00:24:40.512,00:24:44.450
an hour to work with this, it
makes things a lot easier to
work with. I took the Mifare

00:24:44.450,00:24:48.921
DESFire- DESFire tool which uh
is um an Android application you
get in Google Play, and

00:24:48.921,00:24:54.026
basically taped my phone to the
S1032 device, and basically ran
it every so often to see how I

00:24:54.026,00:24:57.196
could me- mess with the
responses in order to get the
thing to work. Literally taking

00:24:57.196,00:25:01.734
my phone and sticking it on top
of the device. Now let’s talk
about security weaknesses a bit

00:25:01.734,00:25:04.703
so we’ve gone through how we
built these tech tools, let’s
talk about some interesting

00:25:04.703,00:25:10.609
security weaknesses on this
platform. Uum so Crypto-1 which
is still used everywhere in

00:25:10.609,00:25:15.848
Mifare classic tags has been
well known to be absolutely
useless. It has little to no f-

00:25:15.848,00:25:20.552
uh security in the same way that
WAP keys no longer do. And it’s
important that people still know

00:25:20.552,00:25:24.890
why they’re weak, for the same
reason that we should still know
why WAP is weak. So it utilizes

00:25:24.890,00:25:29.595
a 48 bit keys split into 2 24
bit keys that cycle between as
authentication encryption is

00:25:29.595,00:25:35.067
happening making things a lot uh
stranger than you’d see in a
traditional keying scheme. Um

00:25:35.067,00:25:38.103
it’s vulnerable to replay
attacks, if the same requests
are made from the reader, you

00:25:38.103,00:25:42.107
can respond to them in the same
way. But there are weaknesses in
the nonces authentication

00:25:42.107,00:25:45.811
mechanisms that allows you to
recover 32 bits of they key
stream then use that key stream

00:25:45.811,00:25:50.816
to generate the keys eventually.
So key recovery for a sector can
be achieved basically by

00:25:52.918,00:25:56.522
allowing the authentication to
get to the point where the
reader has sent its response to

00:25:56.522,00:26:01.693
the nonce during the
authentication. Uh you then take
this value, um and generate

00:26:01.693,00:26:05.397
that’s encrypted value yourself
because you know what the nonce
is and you know the amount of

00:26:05.397,00:26:10.769
cycles you need to go through
the PRNG XOR it with the um
values being sent by the reader,

00:26:10.769,00:26:14.907
and this allows you to have this
key string you can work with.
You then take the 2 24 bit keys

00:26:14.907,00:26:18.944
or the all the 24 bit keys you
can think of, this is only 16
million which isn’t a huge

00:26:18.944,00:26:24.316
amount, and for each alternating
section, that’s 16 bits out of
the 32. Um you try and find all

00:26:24.316,00:26:28.187
those keys that would
potentially match that auth-
that string. Now this’ll create

00:26:28.187,00:26:33.759
about 200,000 if you do it 1 way
and about 33 er- 30,000 the
other way. And this um basically

00:26:33.759,00:26:39.531
can be used to get you enough of
the 24 bit keys to reduce from a
48 bit key even trying to sift

00:26:39.531,00:26:43.769
through just something like a
48- 40 million keys to search
through, which is a lot quicker.

00:26:43.769,00:26:49.341
Um then you can rollback through
the initial authentication cause
you know how that works, and get

00:26:49.341,00:26:53.078
to the point of the state of the
key stream where the keys are
what they would be when the

00:26:53.078,00:26:59.818
thing started and that makes it
gives you the keys. So
authentication is requested, a

00:26:59.818,00:27:04.756
simple nonce is sent back, um
the randomized data as the um
encrypted nonce is uh sent by

00:27:07.025,00:27:12.264
the reader, and that’s all you
need in order to get onto this
and start attacking the keys.

00:27:12.264,00:27:17.269
[applause] Oh ok. Huh. I’ve not
got to the good part yet, you
know? [laughter] Believe me. Um

00:27:21.073,00:27:25.210
so this can be used for offline
cracking. So rather than having
to stand next to an NFC reader

00:27:25.210,00:27:29.948
you can go up, wave a device in
front of the reader, get this
authentication, go away, not for

00:27:29.948,00:27:34.953
very long even about 10 minutes,
and get the keys back. Um it’s a
bit more complex than that but

00:27:34.953,00:27:38.690
that’s the long and short of it,
really. Um this is more
efficient than reader based

00:27:38.690,00:27:43.395
attacks which often have very uh
weird scientific and statis-
statistical approaches and is

00:27:43.395,00:27:47.432
more like traditionally cra-
cracking in the same way again
as you would crack a WAP key,

00:27:47.432,00:27:51.436
just attacking the screen site
that’s being used. Um this
functionality is already

00:27:51.436,00:27:55.641
available and well known but
it’s never used because it’s
really really not very efficient

00:27:55.641,00:28:00.379
to work with. I decided to
implement this with a bit of a
demo with um a few toys I had

00:28:00.379,00:28:05.784
around my flat from my uh recent
visit to Japan. So I had a uh
Mifa- Mifare Classic reader from

00:28:05.784,00:28:10.389
a Japanese video game uh based
on the Kamen Rider series which
I’d never heard of before. Uh

00:28:10.389,00:28:14.459
this was basically a USB device
you would plug into your
Playstation, and it would um

00:28:14.459,00:28:18.130
communicate by you putting tags
on top of it which were shaped
like toys, giving you access to

00:28:18.130,00:28:22.034
those characters in the game.
The readers identified to use
the USB and allowed me to uh use

00:28:22.034,00:28:24.036
man in the middle attacks using
my Beaglebone Black and the UZ-
USB Proxy tool chain which

00:28:24.036,00:28:26.471
allows you to basically p- um
man in the middle USB
communications between a uh hoax

00:28:26.471,00:28:31.476
device, usually a black box hoax
device, and the uh USB device
itself. Analyze the entire

00:28:38.250,00:28:42.387
protocol, allowing you to
reverse engineer it and make
your own uh lib- USB based tool

00:28:42.387,00:28:48.293
to attack this. Um I did that
and took my um STM32 and just
laid it on top of the board so

00:28:48.293,00:28:52.598
that I could then send
authentication requests to it by
using the reverse engineered USB

00:28:52.598,00:28:57.603
protocol. Um so I made it print
out section numbers, information
basically from the STM32 based

00:29:00.639,00:29:05.611
on what’s been requested by that
USB reader from what I’ve told
it to. This allowed me to um

00:29:05.611,00:29:09.948
reverse engineer more about how
the key generation worked, but
also very quickly brute force a

00:29:09.948,00:29:14.519
huge number of keys based on a
huge number of UIDs which I
could use to basically emulate

00:29:14.519,00:29:19.291
anything I wanted to. Purely for
the purposes of showing that
these uh uh encryption keys are

00:29:19.291,00:29:23.829
just weak, like to a terrible
extent, and yet if you go to
most places in England which

00:29:23.829,00:29:27.799
have door access controls,
you’ll still- still see this
technology being used. It’s very

00:29:27.799,00:29:34.172
surprising. See, um so here’s uh
how it works. It got the
authentication uh round through

00:29:34.172,00:29:39.478
all the uh um authentication
encryption data and got a test
key out in under 10 minutes

00:29:39.478,00:29:44.483
which is incredibly fast. And
that was on a 1 core I 5 laptop.
Um improvements that could have

00:29:46.585,00:29:50.455
been made to this uh algorithm
include increasing the uh key
size significantly even bringing

00:29:50.455,00:29:55.293
it to 64 bits which wouldn’t be
hugely stringent, would have
made this a lot harder to do.

00:29:55.293,00:29:59.898
Which would make things more
secure and make some of these
attacks just not possible. Using

00:29:59.898,00:30:03.735
a single large key rather than 2
keys that played off against
each other would mean I’d have

00:30:03.735,00:30:08.874
to brute force every single 1 of
the keys in that bit uh bit
range rather than 2 24 bit keys

00:30:08.874,00:30:14.312
which is just 16 million values
and very quick to do. And an
improved PRN- PRNG would have

00:30:14.312,00:30:19.051
prevented the replay attacks
that could occur from occurring.
Removing any known plaintext

00:30:19.051,00:30:22.487
from authentication remove the
opportunity for exploitation as
well. Now this is important

00:30:22.487,00:30:26.191
especially when you look at
things that are newer like
DESFire which have somewhat

00:30:26.191,00:30:31.463
similar uh known plaintext
issues basically based on how
the tag works but because AES,

00:30:31.463,00:30:36.034
triple DES, and DES really
aren’t vulnerable to known uh
plaintext attacks in the same

00:30:36.034,00:30:42.240
way, there’s no real problem
there. So let’s talk about some
raw protocol weaknesses. Now the

00:30:42.240,00:30:47.546
raw protocol weaknesses are
important because even with like
traditional NFC chipsets that

00:30:47.546,00:30:52.818
are dedicated for that purpose
you can attack things like NDEF
and other more high level issues

00:30:52.818,00:30:56.655
but you can’t attack the
enumeration level cause if they
haven’t implemented that then

00:30:56.655,00:31:01.059
there wouldn’t be very much
point in having an NFC cha-
chipset in the first place. Um

00:31:01.059,00:31:04.529
the big thing is that initial
enumeration that’s sending
requests to identify unique

00:31:04.529,00:31:09.568
identifiers uh is performed by
all tag types of this range.
Meaning that if I found an

00:31:09.568,00:31:14.339
attack there that was viable on
the readers, that would be very
useful in a lot of places. Um a

00:31:14.339,00:31:18.710
big thing as well that I noticed
was I could send a lot of uh
data basically fuzzing responses

00:31:18.710,00:31:22.748
for requests in order to see if
the uh device would crash or get
confused. This sometimes

00:31:22.748,00:31:26.718
happened but it wasn’t really a
viable attack. I found that the
greatest weaknesses lie in the

00:31:26.718,00:31:31.089
anti collision procedures
myself. Now I like this bit of
the documentation of Texas

00:31:31.089,00:31:36.728
Instrument’s uh pseudo code for
tag detection. Umh the note is
extremely important. Due to the

00:31:36.728,00:31:42.134
highly recursive nature of the
anti-collision algorithm, there
is a risk of stack overflow. It

00:31:42.134,00:31:45.504
is highly recommended that the
user implement the
stack-overflow check. Which is

00:31:45.504,00:31:49.841
not very good cause they never
bloody do. What they often do is
just ignore this technology

00:31:49.841,00:31:53.678
entirely and don’t use
anti-collision. But when they do
they’ve never done it properly

00:31:53.678,00:31:59.818
and it’s always got problems. So
what I ended up doing was making
my tool respond over and over

00:31:59.818,00:32:03.188
and over again to any
authentication that happened
pretending that there was an

00:32:03.188,00:32:07.526
infinite number of tags on the
reader at that time. By
basically every time it add- uh

00:32:07.526,00:32:12.697
tried to use anti collision on
it forcing it to just send
garbage data. By doing this over

00:32:12.697,00:32:15.667
and over and over again
eventually the reader would just
keep asking for more and more

00:32:15.667,00:32:20.739
data past the maximum size for
unique identifiers, eventually
allowing the device to crash and

00:32:20.739,00:32:24.609
I’m fairly sure if I tried
harder I could have got some
really cool buffering weaknesses

00:32:24.609,00:32:30.982
from this. Um as I said before
there’s high level weaknesses
that are basically um usable on

00:32:30.982,00:32:36.021
traditional chipsets, um even
some Android phones, including
NDEF data which has some uh

00:32:36.021,00:32:40.292
issues with memory corruption
and authentication mechanisms
which can be worked with on all

00:32:40.292,00:32:46.531
sides. Um the big problem that I
found was that most tags just
haven't got enough power in them

00:32:46.531,00:32:53.271
to do proper authentication or
anything like that in them even
if they were dedicated for that

00:32:53.271,00:32:58.743
purpose. So, I made this, it’s a
sonic screwdriver, a toy 1,
which is now full with all the

00:32:58.743,00:33:03.682
tools that I’ve just talked
about. And I’ve got it with me.
It’s got 4 modes so far. It’s

00:33:06.151,00:33:12.224
got traditional NFC tag,
fuzzing, transmission of uh ASK
uh data basically it’s got an

00:33:12.224,00:33:16.061
ASK transmitter in the handle
which transmits any
authentication being sent from a

00:33:16.061,00:33:20.999
reader to the device, allowing
someone with a laptop and an SDR
like far away from me to get the

00:33:20.999,00:33:27.439
authentication keys back. And um
done with the data. Now I
decided to use a much smaller

00:33:27.439,00:33:33.245
but still quite powerful chip
for this, an M- STM32F070 which
is a very small t cell chip but

00:33:33.245,00:33:39.651
has way more power than even the
ATTiny, which was a lot larger.
So 32 K of flash and 6 K of ram.

00:33:39.651,00:33:45.624
Um had a recommended clock speed
of uh 48 megahertz but it could
be pushed a lot further, like 72

00:33:45.624,00:33:49.394
megahertz, so I could basically
copy and paste a lot of the code
I’ve done tradition- before and

00:33:49.394,00:33:53.498
make it still work. And by dry
soldering onto a breakout board
I could literally load it into

00:33:53.498,00:33:59.804
the sonic screwdriver and get it
working. Um I decided to um
basically uh make it

00:33:59.804,00:34:03.475
programmable from the top so I
could add extra features as I go
along. I’ve added more features

00:34:03.475,00:34:07.779
since these slides were made, so
it- so up there it says 3 now it
has 4. But because it’s got 3

00:34:07.779,00:34:13.084
LEDs on it, I could get up to 7
if I really wanted to. Um I
managed to use the internal

00:34:13.084,00:34:17.289
clock on the device rather than
having to use an external 1,
keeping the amount of um- uh

00:34:17.289,00:34:22.127
hardware inside it very low
which was necessary because
there wasn't a lot of room in

00:34:22.127,00:34:26.097
the case. It’s using a uh
lithium ion battery in order to
power it, in order to keep the

00:34:26.097,00:34:29.668
power high, and what’s
interesting about it at the
moment is it’s using the battery

00:34:29.668,00:34:36.341
from my Nintendo DS because at
the last minute, the battery I
had in it exploded. Um, I want

00:34:36.341,00:34:39.844
to talk about some future work.
I’m gonna release all the source
code for this, hopefully uh

00:34:39.844,00:34:43.715
soon. And I’m gonna design some
boards to go along with it to
make it a lot easier for people

00:34:43.715,00:34:48.720
to work with, um because if I
can make a simple DIP package
board that people can solder

00:34:48.720,00:34:52.257
themselves it’d be a lot more
fun for people to work with. I’m
going to work with DESFire more

00:34:52.257,00:34:55.927
and try to implement it fully
and try and find attacks on it
and see if we can find any tag

00:34:55.927,00:35:00.865
types that I haven’t yet worked
with. Um I’ll take some
questions now but um I’m also

00:35:02.934,00:35:06.204
gonna be in the Hardware Hacking
village at 5 oclock to answer
any questions and do a follow up

00:35:06.204,00:35:10.809
talk where I go to the really
really really low date- um low
level details of what I did to

00:35:10.809,00:35:15.814
develop this project. Um thank
you very much. [applause] Any
questions? Oh.

00:35:23.922,00:35:28.927
>>[indistinguishable offmic
voice] >>Umm I haven’t, no. Now
LibNFC is a great tool that’s

00:35:35.166,00:35:38.703
used by most people for their um
that makes their NFC
communication, I just haven't

00:35:38.703,00:35:43.708
had a chance to look at it yet.
Unfortunately. Anyone else?
Fine. Thank you very much.

00:35:51.049,00:35:51.983
[applause]

