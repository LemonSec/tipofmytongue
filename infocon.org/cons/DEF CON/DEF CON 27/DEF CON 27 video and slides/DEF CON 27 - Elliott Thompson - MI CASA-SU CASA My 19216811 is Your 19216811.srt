00:00:00.067,00:00:04.271
>>Uhh so, welcome to the Mi
Casa, Su Casa talk. Umm now,
I’ve never been good at

00:00:04.271,00:00:09.510
introducing myself, But I do
what any hack does when
presented with a problem for the

00:00:09.510,00:00:14.514
first time. I uhh, I looked on
Google [audience laughs]. So uhh
I searched for presentation ice

00:00:16.817,00:00:21.788
breakers, and one of the top
results was, Enchant your
audience with statistics. Now,

00:00:21.788,00:00:27.394
I’m not going to subject you lot
to a presentation that starts
with statistics, so instead,

00:00:27.394,00:00:33.634
I’ll start with a confession.
The last time I was on stage was
20 years ago, I was dressed as a

00:00:33.634,00:00:38.438
donkey for my elementary school
Christmas party. Umm, and
unfortunately for you guys, I

00:00:38.438,00:00:43.443
don’t have a picture of the
event, fortunately for me. Umm
I’ll try and bring the same

00:00:48.615,00:00:54.655
nervous energy to this [audience
laughs and claps]. Now hopefully
the ice is broken, umm my name

00:00:54.655,00:00:59.459
is Elliott Thompson, and I’m a
UK based principal security
consultant over at SureCloud and

00:00:59.459,00:01:04.398
I believe I’ve spelt it wrong on
this slide, c’mon. Nope, that’s
the donkey. That’s me. So uhh,

00:01:07.267,00:01:12.272
yeah, so uhh that’s my alphabet
soup there- OSCP - CTL over in
the UK umm as well as uhh 2CVU

00:01:15.709,00:01:21.348
privilege escalation in uhh
beyond trusts bond application
and a uhh browser based remote

00:01:21.348,00:01:26.353
execution and the v-tech android
tablet. Now I’ll jump on to the
meat of the presentation. So,

00:01:28.488,00:01:33.493
the core assumption that mi casa
relies upon is: if you’re
connected to your own network

00:01:33.493,00:01:36.229
and browse to 192.168.1.1 then
connect to my network and browse
to the same IP address, as far

00:01:36.229,00:01:41.234
as your browser’s concerned,
they’re exactly the same thing.
Umm now this alone certainly

00:01:44.838,00:01:49.042
isn’t a new discovery but we can
stack a few of behaviors things
together and make something

00:01:49.042,00:01:54.047
exploitable. So digging deeper
into the internal IP’s thing, so
I said that browsers treat them

00:01:56.383,00:02:00.554
the same no matter what network
your on, but what do I actually
mean by that? So I'll go through

00:02:00.554,00:02:07.394
three examples. So the first is
caching, then cookies, then
JavaScript. So this is a just a

00:02:07.394,00:02:12.532
rough example of a sticky
captive portal that I’ve built,
so normally any page is served

00:02:12.532,00:02:17.104
by a captive portal, a
regressively not cached. The
last thing stopped upon is for

00:02:17.104,00:02:21.908
you to keep seeing the captive
portal page after you’ve signed
in. Umm, and when connected to

00:02:21.908,00:02:26.513
my Starbucks network, I serve a
page with the cache control
header set to a max age of one

00:02:26.513,00:02:32.319
year, so uhh when you go home
back to your corporate network,
umm you will keep seeing that

00:02:32.319,00:02:37.524
same, uhh that same captive
portal. So that that kind of
quickly demonstrates the caching

00:02:37.524,00:02:43.463
side of things. Now onto
cookies- so the next I kind of
want to go over is the behavior

00:02:43.463,00:02:48.668
of cookies in this kind of same
situation. So cookies that are
set by a login interface on one

00:02:48.668,00:02:52.372
network, are automatically
attached to requests for
anything accessed through the

00:02:52.372,00:02:57.744
same URL on a different network,
at least until the cookie
expires. Umm and then to many of

00:02:57.744,00:03:01.381
you, especially on the website,
that this is like super obvious
expected behavior, but stick

00:03:01.381,00:03:06.386
with it the fun stuff is coming.
So, here we have PF sense
running on my HOME-AB12 wireless

00:03:08.755,00:03:13.760
network and the page is hosted
on 10 10 10 1 umm and when we
login, we see the php session ID

00:03:15.996,00:03:21.334
is expected- is kind of stored
as expected against the kind of
domain 10 dot 10 dot 10 dot 1,

00:03:21.334,00:03:26.773
so far, so standard. Umm but if
I then rush out for some junk
food, and connect to this fake

00:03:26.773,00:03:33.046
McDonald’s wifi network umm, in
this case the fake captive
portal happens to be on the same

00:03:33.046,00:03:39.586
IP address as the uhh the PF
sense machine. So it means the
browser sends our PF sense php

00:03:39.586,00:03:45.692
session ID to this totally
unrelated captive portal. But so
what? Right? so, sure Mcdonald’s

00:03:45.692,00:03:50.497
now has a session token to my PF
sense on my internal network to
actually use that session,

00:03:50.497,00:03:55.335
they’d need to get inside my
network. And there’s another
problem as well, so, we have to

00:03:55.335,00:03:59.773
contend with how long these
cookies are going to last. So,
cookies can be set to expire in

00:03:59.773,00:04:04.878
like a specific set amount of
time or at the end of a session.
And the definition of kind of

00:04:04.878,00:04:09.883
“session” varies between
browsers, it gets a bit fuzzy.
So Chrome- Chrome umm, when you

00:04:13.453,00:04:18.625
close the browser and all kind
of profiles that you’ve got
open, that’s when the session

00:04:18.625,00:04:23.797
kind of ends. Umm for IE it’s
the same kind of without the
profile thing, you have to close

00:04:23.797,00:04:28.802
all the windows down, and then
the kind of sessions- sessions
are cleared. For Firefox it

00:04:28.802,00:04:33.874
removes the cookie as soon as
the tab is closed, umm and when
I tested it on Android the flag

00:04:33.874,00:04:39.012
was just completely ignored, it
was just kept for as long as it
was needed. Umm so the window of

00:04:39.012,00:04:44.284
a cookie being available umm is
either going to be the date
specified in the expires flag,

00:04:44.284,00:04:49.356
or kind of when the session ends
or when the browser closes. And
on the subject of browsers being

00:04:49.356,00:04:54.361
closed, so these days it’s
fairly common to leave browsers
open for a long period of time,

00:04:57.197,00:05:03.603
especially if you’ve got like a
laptop. Umm and in fact if any
of you have seen these arrows in

00:05:03.603,00:05:10.177
Chrome, like feel shame, like
the green one is- Chrome has
like needed an update for two

00:05:10.177,00:05:16.249
days and you just left it, and
not uhh not uhh not updating it,
not closing Chrome. Uhh and red

00:05:16.249,00:05:19.786
is like a week, you’ve left
Chrome needing an update for a
week without restarting it. So

00:05:19.786,00:05:21.788
it’s safe to say, like I’m sure
some of you have probably seen
at least one of these arrows umm

00:05:21.788,00:05:27.060
but it’s safe to say that, uhh
browser that require the entire
process to be stopped, we can

00:05:27.060,00:05:32.065
rely on users not closing their
browsers meaning the kind
expired session cookies, are

00:05:35.569,00:05:39.873
kind of fair game. Umm as well
as any cookies with a new
expiration or some expiration

00:05:39.873,00:05:44.477
kind of far in the future. Umm
but of course we’re still
limited by anything expiring

00:05:44.477,00:05:49.482
service side as well. Now onto
the uhh last of the three
browser behaviors, here we go,

00:05:52.152,00:05:57.791
umm in the previous cookie
example, we first started on my
safe home network umm and then

00:05:57.791,00:06:03.330
logged into PF, uhh so we first
started on the safe home
network, logged into PF sense,

00:06:03.330,00:06:08.335
and then run to McDonald’s and
joined the unsafe network. But
what if we reverse the order? So

00:06:10.470,00:06:14.975
if instead the victim starts
somewhere unsafe, and then
connects back their own secure

00:06:14.975,00:06:21.114
network, could something be left
behind? And the answer is yes, I
wouldn’t be standing here if the

00:06:21.114,00:06:26.119
answer was no [audience laughs].
Umm so instead of just serving
the McDonald’s captive portal on

00:06:28.688,00:06:32.993
ten dot ten dot ten dot one
let’s hide some JavaScript on
the page. Now I totally accept

00:06:32.993,00:06:37.163
this is some hideous JavaScript,
I just tried to collect as many
deprecated functions as I could,

00:06:37.163,00:06:42.168
umm, and line 2- I go through- I
go through the important lines-
so line 2 umm just gets the CS

00:06:44.304,00:06:51.111
ref token from PF sense on the
new VPN client page. line 5
pulls the token out, again it’s

00:06:51.111,00:06:54.915
horrific, I’m sorry I’ve done it
this way, I apologize to any of
you that deal with JavaScript.

00:06:54.915,00:07:01.521
Ummm and lines 8 and 10 just
build a malicious post request
and submits it to PF sense along

00:07:01.521,00:07:07.027
with the CS ref token. Umm and
all that the post request does
something really simple, it just

00:07:07.027,00:07:12.032
creates an additional open VPN
user. So here we are , so now
we’re connected to the

00:07:14.200,00:07:18.838
McDonald’s free Wifi connection,
uhh McDonald’s free Wifi network
and in the background our page

00:07:18.838,00:07:23.176
has loaded that malicious uhh
JavaScript and it’s cached for a
year. Umm, and that JavaScript

00:07:23.176,00:07:28.315
will be continuously running uhh
while they’re on this captive
portal network and that PF sense

00:07:28.315,00:07:32.118
request that kind of gets the
open VPN stuff to grab the CS
ref token, that will be

00:07:32.118,00:07:37.123
continuously failing until they
go back home again. So then when
they try and login into their PF

00:07:39.192,00:07:44.331
sense web interface, they’ll
instead see the McDonald’s
captive portal page and probably

00:07:44.331,00:07:49.769
think, huh that’s weird, hit
refresh, and they’re kind of
back into their standard

00:07:49.769,00:07:55.308
dashboard. Umm but by this point
it’s already too late. That
malicious strict has executed

00:07:55.308,00:07:59.713
and we have a new VPN user right
into it. So as the attacker we
can go straight in their

00:07:59.713,00:08:04.517
internal network without ever
having connected with-without
ever having to of connected in

00:08:04.517,00:08:10.557
the first place. Umm but, and of
course, if we actually check the
VPN configuration, we can see

00:08:10.557,00:08:14.361
all the malicious changes. So
uhh, I just want to stress it’s
not a vulnerability in PF sense,

00:08:14.361,00:08:19.432
this was just an example I
chose. Umm, we’re just using the
standard interface through

00:08:19.432,00:08:24.637
JavaScript. Umm the attack will
work against just about any
interface. Anything you access

00:08:24.637,00:08:29.642
over IP address at least. So
that goes over the three browser
behaviors that we’re going to

00:08:32.278,00:08:37.617
look at: caching, cookies and
Javascript. Umm they’re all
shared between devices accessed

00:08:37.617,00:08:42.622
through internal umm RFC 1918 IP
addresses, umm and the reason
behind it is pretty simple.

00:08:45.892,00:08:50.263
Browsers aren’t really aware
that the network you run has
changed. So, and it totally

00:08:50.263,00:08:55.368
makes sense for origins like
Google dot com or VK dot com or
whatever, they only really exist

00:08:55.368,00:09:01.041
once. Umm so browsers that use
those differentiate- they use
the kind of the domain and to

00:09:01.041,00:09:04.978
differentiate between uhh things
like caching, cookies and like
just resources in general,

00:09:04.978,00:09:09.115
that’s what they use to
differentiate them. Umm there
are a couple of exceptions like

00:09:09.115,00:09:14.454
cookies being scoped exclusively
to uhh certain pages or paths,
or specifically to HTTPS

00:09:14.454,00:09:19.492
connections, like with a secure
flag. But anyway, onto the
second major component. So,

00:09:19.492,00:09:26.499
karma. So when writing this
presentation, umm I remembered
the karma attack, I remember it

00:09:26.499,00:09:32.272
being the most recent thing
without explanation or
introduction. Umm but after

00:09:32.272,00:09:38.878
checking, my definition of
recent made me feel so old. So
15 years ago, uhh Dino Dai Zovi

00:09:38.878,00:09:43.750
and Shaun Macaulay [presenter
laughs] found that you can
effectively coerce wifi devices

00:09:43.750,00:09:50.089
to connect to networks that you
control without user
interaction. So how does the

00:09:50.089,00:09:54.427
karma attack actually work? So
umm when you connect to a
network umm and allow automatic

00:09:54.427,00:09:58.832
reconnection to it umm wherever
your device is not connected to
that network, it’ll send out

00:09:58.832,00:10:02.735
probe requests asking if any
other networks are nearby. Umm
if one of those networks is

00:10:02.735,00:10:07.574
nearby, the access plant will
send a response saying that’s me
and start initiating the

00:10:07.574,00:10:10.944
connection. And do you know,
when Shaun found that you could
boot someone off of there, you

00:10:10.944,00:10:16.082
can truly boot someone off their
own wireless network uhh with a
deauthentication frame, umm and

00:10:16.082,00:10:20.753
then respond to the probe
requests asking for a kind of
network access, as umm, yeah

00:10:20.753,00:10:25.925
sure I’m Starbucks underscore
wifi that sounds about right,
connect to me. Umm it’s worth

00:10:25.925,00:10:31.464
noting it only works on open
networks, so encrypted ones
require the pre check key to be

00:10:31.464,00:10:37.137
known by both sides. So I’ll
quickly do the uhh a quick go
through- So this is what the

00:10:37.137,00:10:41.541
karma attacks let’s us do: It
let’s us pull someone off their
network, and temporarily bring

00:10:41.541,00:10:46.212
them to our dangerous network.
So in this illustration we have
uhh two seperate networks with

00:10:46.212,00:10:51.384
all clients connected happily.
We send the deauthentication
frame, umm a spoof

00:10:51.384,00:10:55.455
deauthentication frame
effectively telling
them-effectively telling it hey

00:10:55.455,00:11:02.061
router says right now you need
to disconnect. And then the
client dutifully just does

00:11:02.061,00:11:07.066
itself and disconnects. Once the
client’s disconnected, umm it’s
not searching for networks

00:11:09.469,00:11:15.241
anything that it remembers. Umm
but that searching involves
shouting the names of all the

00:11:15.241,00:11:21.381
networks it’s previously
connected to uhh hoping that one
of them will respond. So we

00:11:21.381,00:11:25.585
respond to all of them. So if
you’re looking for Starbucks 1
underscore wifi, yeah sure

00:11:25.585,00:11:31.190
that’s me! Umm you mean Hilton,
yes yeah me too. Umm as long as
those remembered wireless

00:11:31.190,00:11:37.330
networks didn’t require a PSK or
a certificate or whatever. Umm
but now the target’s- now the

00:11:37.330,00:11:43.036
target’s on our network,
thinking it’s on Starbucks wifi
or whatever. Umm but how does

00:11:43.036,00:11:47.273
that look to the end user? So it
isn’t super obvious- isn’t it
super obvious that we

00:11:47.273,00:11:51.210
disconnected then reconnected
and most places you’ll have a
couple of seconds of like the

00:11:51.210,00:11:55.548
connecting animation followed by
the connected sign again. Umm
and if someone clicked on a

00:11:55.548,00:11:58.918
wireless icon, yeah sure they’d
see that they’re now on
Starbucks underscore wifi

00:11:58.918,00:12:00.853
despite being in their corporate
office, but uhh most of the time
there’s nothing that’s going to

00:12:00.853,00:12:02.855
be plainly obvious for them to
see. Here we go, umm one sec,
okay, but now that the target is

00:12:02.855,00:12:04.857
connected to our network umm we
can poison the cache and display
whatever pages we want. Umm but

00:12:04.857,00:12:09.862
that’s not particularly useful
to us while their connected to
our network. Umm anything I drop

00:12:29.449,00:12:33.820
down can only be used to attack
me, and I don’t want them
attacking me. I can do that

00:12:33.820,00:12:38.358
already. Umm but before moving
on, I just want to stress that
obviously I had no part of

00:12:38.358,00:12:43.429
discovering karma, that was Dino
and Shawn, I was probably a
teenager at the time, umm but on

00:12:43.429,00:12:48.434
to the next bit. So at the start
umm I demonstrated that we can
add JavaScript onto internal IP

00:12:51.304,00:12:56.309
pages, umm that users use- umm
enter on to internal IP pages,
if users connect to our network

00:12:58.711,00:13:03.850
and we demonstrated we can use
karma to pull- pull victims onto
our network or pull targets onto

00:13:03.850,00:13:07.720
our network. They’re only
victims once they connect. Umm
while they’re connected to the

00:13:07.720,00:13:11.758
network, we can poison anything
we want, but none of that
matters until they’re back on

00:13:11.758,00:13:17.630
their original network again. So
like a rescue animal, we want to
release them back into their

00:13:17.630,00:13:22.669
home. Although, unlike a rescued
animal, we’d be sending them
back with more parasites. Umm

00:13:22.669,00:13:26.606
and this is by far the kind of
simplest part of the
exploitation chain, but though

00:13:26.606,00:13:31.944
it is still absolutely critical.
All we need to do is boot them
off our malicious network umm

00:13:31.944,00:13:36.949
and hopefully they’ll
automatically find their way
home. So booting them off our

00:13:39.318,00:13:43.690
initial fake network umm is
super easy, we can just
disconnect ourselves, umm and

00:13:43.690,00:13:49.529
the device-the poor device will
get confused, it’ll start
looking for it’s known networks

00:13:49.529,00:13:56.035
and this time we shut the h**l
up, and the targets’ back home
again, along with our JavaScript

00:13:56.035,00:14:00.973
payload running umm and we can
attack their router our whatever
it is we’ve poisoned earlier.

00:14:03.076,00:14:06.913
And to the target this looks
exactly the same as it did
before, a slight kind of brief

00:14:06.913,00:14:11.017
moment of kind of connecting,
umm and no internet access
followed by connected back to

00:14:11.017,00:14:16.022
the home network again. So, in
summary so far, we can use the
karma attack or just wait and

00:14:20.293,00:14:26.766
pull someone onto a fake captive
portal, poison a particular IP
address domain or IFC 1918

00:14:26.766,00:14:31.871
domain with JavaScript, then
have the target go back to their
own network allowing the

00:14:31.871,00:14:36.008
JavaScript to execute in the
context of whatever internal
network device that we just

00:14:36.008,00:14:41.013
poisoned, but when we’re not
done just yet. [drinks water] So
now we reach the final, and kind

00:14:45.651,00:14:52.091
of most complex component, which
is the automation side of
things, now this component uhh

00:14:52.091,00:14:57.096
exists purely to solve two
specific problems with the chain
of exploits so far. So, the

00:15:00.433,00:15:05.371
first problem is we need to know
the IP address of the system
that we’re targeting. Um, and

00:15:05.371,00:15:10.343
the second problem is we need to
know the HTML slash DOM
structure of whatever it is

00:15:10.343,00:15:15.348
we’re targeting. But we can
overcome both of these. So
starting with the IP addresses

00:15:17.817,00:15:23.022
issue. We can switch from our
kind of one shot sniper method
and go thermonuclear. So

00:15:23.022,00:15:25.024
obviously 1918 defines all
internal IP addresses. In total
there are roughly 17 million

00:15:25.024,00:15:27.426
across these three ranges. Cool,
so let’s hit them all. So let’s
try imposing 17 million IP

00:15:27.426,00:15:32.431
addresses as quick as we can. No
surprises that does not go well.
[speaker laughs] I tried to uh,

00:15:36.502,00:15:41.507
but yeah every single browser
you try to submit 17million
requests for immediately and

00:15:43.776,00:15:48.781
just doesn’t go well. But that's
a surprise to non one.
Realistically, we don’t really

00:15:51.851,00:15:58.224
need to poison every single one
of the 17 million addresses. So
Textbot dot com and a few other

00:15:58.224,00:16:03.162
sites listed a ton of common
default routers, and firewall
and switch IP addresses, so

00:16:15.174,00:16:20.179
let’s start with those guys. So
the IPs have been helpfully
separated by vendor, but we

00:16:22.782,00:16:28.888
don’t really care. So, instead
we just want the unique IPs. I
started with a list of about 500

00:16:28.888,00:16:35.628
default IPs across various
different sources and various
different websites of which 54

00:16:35.628,00:16:40.633
were unique and 53 had the right
number of octets, which sounds
like a more reasonable starting

00:16:43.502,00:16:48.507
point. So, these were the most
common 53 default device IP
addresses which was a good

00:16:51.844,00:16:58.384
starting point. Now, if you guys
look closely, can someone spot
something which doesn’t belong

00:16:58.384,00:17:04.390
here and just shout it out?
[audience clamor] Yeah there we
go, so there’s one in here in at

00:17:04.390,00:17:09.395
the bottom right which starts
with 200. So 200 dot 200 dot 200
dot 5. So when I first saw this,

00:17:13.966,00:17:18.971
I immediately thought ‘ah it’s
just a typo. It’s clearly just a
typo. No one would really do

00:17:18.971,00:17:23.976
that right?’ But then before
just deleting it from the list,
um i thought maybe I should

00:17:26.279,00:17:31.284
check. It turns, yeah, TrendNet
released a device a good few
years ago, the TEW432BRP which

00:17:34.654,00:17:40.493
used those dot 200 ip addresses
in its management interface, and
i checked the IP address myself

00:17:40.493,00:17:45.531
to see if it was like a range
that was defined for like
documentation or something kind

00:17:45.531,00:17:51.170
of something unusual that I
hadn’t seen before. But no, it
was a Brazilian ISP. So this,

00:17:51.170,00:17:56.609
the TrendNet had just handed out
public IPs for this Brazilian
ISP to their internal network

00:17:56.609,00:18:02.481
devices. It gets better too. So
It's not just that one
management interface. There’s

00:18:02.481,00:18:08.654
like 200 DHCP addresses or 100
DHCP addresses that are owned by
this Brazilian ISP that have

00:18:08.654,00:18:13.225
just been handed out to internal
TrendNet devices. Um, my
favorite part about it as well

00:18:13.225,00:18:18.297
is, so I mentioned that it’s
like a v3 of the TrendNet
device. The V4 had it as well,

00:18:18.297,00:18:24.670
this was a mistake they made
twice. [audience laughs] But
show down shows that were

00:18:24.670,00:18:29.675
multiple devices that were
happily listing on the address
as an alternative interface.

00:18:33.713,00:18:37.917
Although I didn’t get any
responses from the real IP
address, unfortunately. But

00:18:37.917,00:18:42.922
moving on. So now we have a list
of 53 or 52 RFC 1918 IP
addresses. And it was

00:18:47.360,00:18:54.233
interesting to see there weren't
any common default in the 172
dot 16 range. But just to make

00:18:54.233,00:18:58.304
sure they all get loaded into
the browser crash, the first
task was to create some sort of

00:18:58.304,00:19:04.010
page, kind of orchestration
layer which submits a request to
all of our 52 targets. A few

00:19:04.010,00:19:09.015
lines of terrible JavaScript and
we’re ready to go. So all this
does is, it runs through like a

00:19:11.851,00:19:16.856
fixed list, and send each TTP
requests and it's not pretty but
it was quick. Um, and it can

00:19:19.091,00:19:24.463
also, we can just add additional
stuff to the list, at hardly at
any point. So we can add kind of

00:19:24.463,00:19:30.836
all of 192 and 168, and like the
slash 24 dot one, like the slash
24 dot zero, whatever is the

00:19:30.836,00:19:36.809
most common particular
engagement. But cool. Now we are
submitting requests to all of

00:19:36.809,00:19:41.947
these IP addresses. But we still
need a way to provide http
responses for them all. Now if

00:19:41.947,00:19:45.918
we were just doing dns
hijacking, um that would be
super easy. All we’d need to do

00:19:45.918,00:19:51.390
would be to provide a dns
server, through dhcp and then
like submit, like send anything

00:19:51.390,00:19:55.027
through to a particular ip
address that we controlled.
There are modules and there are

00:19:55.027,00:20:01.867
things that exist to do that.
But we can’t do that with RFC
1918 IP addresses since we

00:20:01.867,00:20:07.540
expect them to not require DNS.
But the simplest option, rather
than sending specific routes

00:20:07.540,00:20:14.480
through dhcp was just to use IP
tables. So just to quickly break
down how this works, so I've got

00:20:14.480,00:20:20.820
a server running on 172 dot 16
dot 214 dot 1, that’s the first
time I’ve said that right first

00:20:20.820,00:20:26.525
time. And any client that gets
pulled onto my network gets
assigned a dhcp address in that

00:20:26.525,00:20:30.329
same slash 24 range. And the
only reason that was chosen it
was because it seemed as far

00:20:30.329,00:20:36.435
from one of the defaults as
possible. So this ip table is
real effectively says anyone

00:20:36.435,00:20:43.175
using this gateway, so anyone
who's joined my network that
attempts to connect to 192 168

00:20:43.175,00:20:48.714
slash 16 or 10 slash 8,
translate that to servers
gateway ip address, where we’ve

00:20:48.714,00:20:55.387
got an apache server or a non
generic server listening. So
anything we host on that 172 ip,

00:20:55.387,00:21:01.327
kind of our server ip address,
or our gateway IP address, is
going to be kind of responding

00:21:01.327,00:21:08.067
directly to any request to those
RFC 1918 IP or default ip
adresses. Now that we’ve got our

00:21:08.067,00:21:13.372
orchestrated payload done, that
submits, so we've now got our
orchestrated payload which

00:21:13.372,00:21:18.778
submits all the requests to the
internal IPs, and we have now an
ability to respond to them all.

00:21:18.778,00:21:23.782
But at the moment, we’re just
providing the apache, it works
50 times. So, that’s no fun. Um,

00:21:26.785,00:21:32.191
but before I get onto the actual
payload, I’ll quickly mention a
fun optimization technique, that

00:21:32.191,00:21:35.694
like almost all of you probably
already know about but I find it
really interesting at the time,

00:21:35.694,00:21:41.433
which was, if you go to say
google dot com and there page
imports a piece of java script

00:21:41.433,00:21:46.438
from say their Cloud Flask-CDN,
then you got to a totally
different website like Linkedin,

00:21:49.108,00:21:53.946
if Linkedin imports the same
script from the same CDN, your
browser doesn't need to make a

00:21:53.946,00:21:59.318
request for it, it will just
load it locally from its own
cache. So instead of us having

00:21:59.318,00:22:06.225
10,000 lines of JavaScript sent
50 times, we can send it once,
cache it, and then have all the

00:22:06.225,00:22:11.163
other pages look at that
particular cache. So the number
of requests that we're sending

00:22:11.163,00:22:15.601
won't change, or the number of
responses that we’re sending
won’t change, but the data goes

00:22:15.601,00:22:20.806
from megabytes to kilobytes,
which is what we need to kind of
help get increased from 50 to

00:22:20.806,00:22:27.713
anything more than that. So,
anyway, that’s the optimization,
on to the actual payload. So at

00:22:27.713,00:22:31.951
the current stage with what
we've been through so far, i
need to create a payload for

00:22:31.951,00:22:36.889
every different device that I
want to target. And I’m
targeting projects like PFSense,

00:22:36.889,00:22:42.828
that’s fairly easy since we can
just download a copy and build
our own payloads. Similarly

00:22:42.828,00:22:47.866
router interfaces, they’re
pretty easy too, if we can just
buy one of the routers off ebay.

00:22:47.866,00:22:53.772
But there are plenty of devices
that we’re not going to be able
to have this level of access to.

00:22:53.772,00:22:58.410
So instead of building a million
different payloads for a million
different payloads, I needed a

00:22:58.410,00:23:02.348
way of writing a single piece of
javascript that was used for no
matter what context it was

00:23:02.348,00:23:07.519
running under, something that
could be used to attack any
device in any state. So the

00:23:07.519,00:23:13.292
first step was relatively easy.
Um, if the route page looked
like a login interface, the next

00:23:13.292,00:23:19.164
step is pretty easy, like try
and log in. And detecting login
pages thankfully isn’t hugely

00:23:19.164,00:23:24.770
difficult. So there are
definitely plenty of options
when it comes to detecting login

00:23:24.770,00:23:29.208
interfaces, but most of them
aren’t going to be super
reliable. So lets kind of rule

00:23:29.208,00:23:33.913
them out one by one. So firstly,
the obvious stuff. The contents
of things like titles,

00:23:33.913,00:23:39.351
paragraphs, and divs, they’re
expected to change based on the
device itself. So we can rule

00:23:39.351,00:23:44.890
those out. But that’s the first
step. The next is the form
action. So credentials could be

00:23:44.890,00:23:49.762
getting sent to any URL, or it
might not be in standard
location, or it might not be a

00:23:49.762,00:23:56.001
form action at all. And same
with the various names of the
inputs. They could be something

00:23:56.001,00:24:02.474
specific to the device, or it
might be in just, in a different
language. But now we are

00:24:02.474,00:24:08.547
narrowing it down. So, with the
input elements themselves, the
type value is part of the html

00:24:08.547,00:24:14.053
spec, and is unlikely to be
custom. But we don’t know
whether the interface is going

00:24:14.053,00:24:20.125
to be asking for a username, or
whether the submit button is
handled elsewhere, or you just

00:24:20.125,00:24:25.898
hit enter or whatever, or like I
say, it could be missing
entirely. But we can expect in

00:24:25.898,00:24:32.204
99% of cases for there to be an
input somewhere of the type
password if it’s a login

00:24:32.204,00:24:37.209
interface. So now we have our
first check, which effectively
fits in our ‘if statement’. So,

00:24:39.578,00:24:44.583
if it's a login page, what do we
want to do? We want to login.
And we don’t necessarily have

00:24:47.219,00:24:50.222
credentials, or we might not
necessarily know credentials but
we can just throw it like a

00:24:50.222,00:24:53.926
brute force, it’s on the inside
of someone's network. We might
be able to just login with brute

00:24:53.926,00:24:59.832
force. Or it might be already
authenticated if there’s already
a session that’s active. But

00:24:59.832,00:25:03.869
what do we do if the target
device either doesn’t require
authentication, it’s already

00:25:03.869,00:25:08.540
logged in, or if the brute force
attempt somehow succeeds. Now
this is where it gets a bit

00:25:08.540,00:25:14.446
tricky. So if we see a router,
we might want to add, like we
did before, add a VPN

00:25:14.446,00:25:20.719
connection, or extract or change
the PSK. If we see a Firewall,
we might want to punch a

00:25:20.719,00:25:26.258
specific rule through. Or if we
see a CCTV camera, we might want
to just turn it off entirely.

00:25:26.258,00:25:31.263
But the answer: we can send the
logged in interfaces to an off
site mural network trained to

00:25:34.867,00:25:40.172
identify the most strategically
relevant next steps when
confronted by any device

00:25:40.172,00:25:45.177
interface. And by that I mean
send it to you, the human. And
that will stall them from xkcd.

00:25:47.913,00:25:53.619
So welcome to the most bizarre
stock image I have ever paid
real money for [audience

00:25:53.619,00:25:58.957
laughs]. Now, grabbing the
authenticator device pages isn’t
trivial, but thanks to the BeEF

00:25:58.957,00:26:04.963
JS project, all the hard work
has already been done. So it was
surprisingly easy, if you ignore

00:26:04.963,00:26:11.437
the ridiculously hard work that
has been put into the BeEF JS
project. So to quickly explain

00:26:11.437,00:26:17.476
that particular project, it was
designed as an XSL cross site
scription exploitation framework

00:26:17.476,00:26:23.148
by Wade Alcorn. So the idea
being, if you found like a
stored cross site scription

00:26:23.148,00:26:28.087
vulnerability on a page, you can
build a payload which includes
the BeEF java script hook, then

00:26:28.087,00:26:33.158
anyone connecting to that page
with the hook loaded effectively
gets this script running in

00:26:33.158,00:26:38.897
their user contacts on their
machine, with their session
hooked as well. Along with

00:26:38.897,00:26:43.001
features like Mantis block
module integration and
integrated browser exploitation,

00:26:43.001,00:26:48.841
that kind of stuff. It’s
fantastic piece of code. But the
killer feature we want to use is

00:26:48.841,00:26:53.879
the ability to tunnel our
requests through java script
running on the target’s browser.

00:26:53.879,00:26:59.351
So within the context of
whatever interesting device we
are targeting, when they are

00:26:59.351,00:27:05.958
connected back to their own
network. And this means that
when one of our poisoned pages

00:27:05.958,00:27:12.130
is active, we get a call back
that we can tunnel straight to
the device through the HTTP

00:27:12.130,00:27:19.004
proxy through BeEF JS. So to
clarify the java script tunnel
itself runs over the internet,

00:27:19.004,00:27:25.711
and so we as an attacker, we
don’t necessarily need to be on
the inside of their network to

00:27:25.711,00:27:30.716
do this. But enough diagrams.
Um, I”m going to try and see if
you can, so get a video result

00:27:32.718,00:27:37.956
of me frantically get this
working like an hour before the
deadline to send to Nikita. So I

00:27:37.956,00:27:42.961
will try and get this onscreen.
I taped my notes over the
touchpad on the laptop. So this

00:27:53.171,00:27:58.176
is the most awkward thing.
[video presentation begins,
speaker annotates] Here we go.

00:28:01.847,00:28:07.119
Can I fullscreen this? Yeah,
cool. So here we see the victim
device on the right, and then

00:28:07.119,00:28:12.958
two laptops performing the
attack on the left. So the one
on the far left is performing

00:28:12.958,00:28:16.828
the meat of the kind of the
authentication and the
poisoning, and the one in the

00:28:16.828,00:28:22.301
middle is just the, like it’s
easier to show two screens at
once, and that’s the BeEF hook

00:28:22.301,00:28:28.473
effectively. So here they are,
browsing a stole http msn dot
com. And then we do the

00:28:28.473,00:28:33.478
authentication, so then we boot
them off the home network while
they’re browsing game of

00:28:39.918,00:28:45.991
thrones. Think i spent too long
scrolling through this, but
we’re on the journey now, you're

00:28:45.991,00:28:52.531
all on it with me. So after a
couple of seconds, they should
be getting disconnected from

00:28:52.531,00:28:58.303
their home network, and then
this is the Karma stuff, this is
just the default Karma, getting

00:28:58.303,00:29:02.040
pulled onto my network, so there
they are getting disconnected
from their home network, and

00:29:02.040,00:29:07.079
then it should already be
connected to the fake McDonald’s
wifi stuff that’s getting

00:29:07.079,00:29:12.084
ultimately responded too. Again,
it’s just Karma. So far it’s
just Karma. As they’re loading

00:29:15.187,00:29:20.192
pages, so now the, i think after
a page refresh, the BeEF JS hook
should be in, so it’s not the

00:29:22.661,00:29:25.364
BeEF JS hook itself that I'm
loading in, it's, that’s
orchestration java script, which

00:29:25.364,00:29:27.366
is loading 52 separate BeEF
hooks on those various different
router ip addresses. So if there

00:29:27.366,00:29:30.569
are session cookies, its hooked
onto that. But as far as the
user is concerned, they are just

00:29:30.569,00:29:35.807
seeing whatever, any unencrypted
page that they are already on.
There we go, so we’ve got the

00:29:35.807,00:29:40.812
BeEF hook there against the
particular router IP address. So
this is the Fritz box log in,

00:29:49.621,00:29:54.626
the Fritz box router interface.
So in BeEF, you just like right
click and start like kind of use

00:29:56.928,00:30:01.933
as proxy. This is like three in
the morning, so forgive me for
this not being the most kind of

00:30:05.270,00:30:11.209
nicely put together thing. So as
they’re browsing through,
hopefully a long article, to

00:30:11.209,00:30:15.147
give you as long as possible to
interact with their stuff,
they’ve been sent back to their

00:30:15.147,00:30:19.618
home network again. So now
they’re back home with that java
script running on that page, or

00:30:19.618,00:30:26.091
any pages that were unencrypted
that were opened. And now if we
go to, so this laptop again is

00:30:26.091,00:30:29.828
completely, not on their network
at all, but it’s proxied through
that java script running on the

00:30:29.828,00:30:34.833
dss page. I hope it works, I
think it worked at the time.
There we go, so that’s their

00:30:39.004,00:30:45.844
internal router login interface,
over the internet, through
javascript. I mean it’s all

00:30:45.844,00:30:52.050
thanks to BeEf. But it’s, we can
now kind of change the PSK, we
can do whatever we want on their

00:30:52.050,00:30:58.323
internal interface. [video
presentation ends, audience
applause] So there are things it

00:30:58.323,00:31:03.261
won’t work on, like if there is
a password or whatever on the
device. But I tried it on an

00:31:09.468,00:31:14.473
engagement fairly recently and
managed to access the data
center fire suppression and HVAC

00:31:16.908,00:31:23.448
system. It wasn’t quite fully
authenticated, but the guest
account did have right access to

00:31:23.448,00:31:28.453
everything. [speaker working
computer] Get back into the
presentation, full screen, there

00:31:42.701,00:31:47.706
we are. [speaker addresses
audience again] So that was the
video. Now, so this is the

00:31:51.109,00:31:56.748
project itself. So at the
moment, by the end of DEFCON it
will be open public. At the

00:31:56.748,00:32:02.888
moment, it’s a combination of
bash scripts and apologies.
[audience laughs] So uh, I’m

00:32:02.888,00:32:06.491
hoping in the next week or two,
it should be kind of a nice,
relatively seamless piece of

00:32:06.491,00:32:11.496
Python, but at the moment, yeah
bash scripts, apologies, I’m
sorry, one more sorry to add to

00:32:11.496,00:32:17.469
the pile that were already
there. Just on another separate
quick note, something that was

00:32:17.469,00:32:22.641
kind of funny. During this, i
found that, so each of the
different browsers, if you’ve

00:32:22.641,00:32:27.612
got, say for example you’ve got
a router login interface, one
into one bit whatever you’ve got

00:32:27.612,00:32:32.617
your username and password
stored, like remembered in
chrome or IE or firefox, in

00:32:36.922,00:32:42.194
firefox and IE, when I tested
it, to use the stored
credentials, you needed to click

00:32:42.194,00:32:46.198
from the dropdown and select
your username and then it would
populate the fields, and then it

00:32:46.198,00:32:51.369
would be available in javascript
and DOM. With chrome and
chromium, it was automatically

00:32:51.369,00:32:56.441
populated, but you needed to
interact with the page in some
way. So if you like kind of left

00:32:56.441,00:33:00.879
clicked anywhere on the page,
then the credentials would be
available in DOM. So you could,

00:33:00.879,00:33:02.881
like there was a demonstration
where you could have like a
captive portal that stored the

00:33:02.881,00:33:04.883
credentials ,the inputs didn’t
need to be visible, they could
be kind of hidden away in css or

00:33:04.883,00:33:06.885
whatever so you couldn’t see
them. In firefox you needed to
click on it. If they weren’t

00:33:06.885,00:33:08.887
there, you couldn’t click on it,
so you couldn't use it. But um,
on chrome, you could. You could,

00:33:08.887,00:33:11.156
um just as long as they clicked
somewhere on the page, then
you’d have them, have the

00:33:11.156,00:33:16.161
credentials that you could
replay back again . so I
submitted it to the chromium

00:33:21.933,00:33:26.938
project. And we got, kind of, it
was a back and forth, but kind
of the overall consensus was

00:33:33.278,00:33:38.917
yeah, it was a usability, the
kind of, the idea was it’s meant
to kind of make it easier for

00:33:38.917,00:33:41.653
people to kind of login to
stuff, rather than clicking and
clicking and drop downs. And I

00:33:41.653,00:33:46.391
completely agree with them, like
love the guys over there. But
then they fixed it, [speaker

00:33:49.194,00:33:52.864
laughs] so uh, but i guess it
was just like a numerator thing.
So it was fixed months and

00:33:52.864,00:33:57.869
months later. But anyways, onto
fixing it generally. So we’ve
seen that it can be

00:34:01.406,00:34:07.479
realistically exploited, but how
can we defend against it. So the
method that works best in

00:34:07.479,00:34:12.317
enterprise environments is
accessing devices through dns
names, configuring trusted

00:34:12.317,00:34:17.122
certificates, the standard stuff
that we do in enterprise anyway.
But most importantly, disabling

00:34:17.122,00:34:22.627
the http interfaces, especially
if those interfaces work over
like direct IP address. Like if

00:34:22.627,00:34:27.332
you can connect over IP address
directly, then it's worth
disabling them. Especially for

00:34:27.332,00:34:32.904
the weird and wonderful, like,
kind of like Skylet, I say
Skylet, especially like the

00:34:32.904,00:34:39.377
weird and wonderful random stuff
that’s on the network. And for
home users and residential

00:34:39.377,00:34:44.382
vendors, simply disabling the
http interface entirely and
having only https listing, it

00:34:46.518,00:34:49.521
should be enough to stop the
attack working on a mass scale,
since no one is clicking

00:34:49.521,00:34:51.523
through, or i hope no one is
clicking through 50 separate
certificate warnings on the same

00:34:51.523,00:34:54.826
page, but it seems it would be
possible to target a specific
device. But it defangs the

00:34:54.826,00:34:59.831
attack significantly Another
potential is the wider option of
IPP 6. SINCE there are so many

00:35:09.207,00:35:13.778
more options in IPP 6. local
address don’t necessarily need
to be shared between networks,

00:35:13.778,00:35:20.418
and that doesn't really exist in
it. So uh, but if vendors still
use like a common set of

00:35:20.418,00:35:24.389
defaults instead of using kind
of unique ones, then the attack
could potentially still be

00:35:24.389,00:35:27.325
viable. Um, the final one is
WPAv3. So based on the spec, I’m
one of kind of a few other

00:35:27.325,00:35:29.327
people who have been through, so
far the common attacks still
look to be technically possible.

00:35:29.327,00:35:31.329
So protected management frames
are enabled by defaults so you
can’t trivially boot someone off

00:35:31.329,00:35:36.334
their own network, but there’s
still the potential, as far as I
can see, for kind of the good

00:35:42.941,00:35:47.946
old fashioned signal-to-noise
ratio jamming. And as far as we
understand the spec, open

00:35:53.752,00:35:57.956
networks are still a thing. So,
key is, uh generated negotiated
,so there’s no kind of

00:35:57.956,00:36:03.795
unencrypted communications. But
there’s no trust-on-first-use
mechanism. So it might still be

00:36:03.795,00:36:08.967
possible to uh, if, for example,
you connect to mcdonalds
underscore wifi and connect to a

00:36:08.967,00:36:12.737
different mcdonalds underscore
wifi, there's nothing there
saying this isn’t the same

00:36:12.737,00:36:17.308
network that you’ve seen before.
But this is largely conjecture
anyway. Like I don’t have any

00:36:17.308,00:36:22.313
yWPA3 devices, this is based off
like other people going through
blog posts, other people going

00:36:24.582,00:36:31.289
through the spec and me reading
their blog posts. So, roughly
makes sense. And that brings us

00:36:31.289,00:36:36.528
towards the end of the
adventure. I think we have a few
minutes left on the clock. So if

00:36:36.528,00:36:41.533
there are any questions?
[audience applauds]

