00:00:00.133,00:00:05.138
>>Alright, I'm really excited to
introduce Alexandre again. He
spoke in my track last year and

00:00:07.307,00:00:11.812
did a bang up job. Last year was
his first time speaking at any
kind of big conference at all.

00:00:11.812,00:00:15.616
Since then, he's gone on quite
the world tour. He went to
China, he-he- he went to

00:00:15.616,00:00:20.320
Hack-In-The Box, he spoke in
Europe and now he's back here to
speak again. Let's give

00:00:20.320,00:00:25.325
Alexandre a big round of
applause [applause] Have a good
time my friend. >>Thank you so

00:00:28.795,00:00:33.800
much. >>Yeah. >>Hello guys, good
afternoon. Let's talk about dot
net malware reversing, it's uh

00:00:37.738,00:00:42.743
pretty decent talk, I think so.
Uh, I'm a security research. Uh,
here is our agenda about my

00:00:51.852,00:00:56.857
presentation. Here uh you have
my last presentation on
Confidence Defcon China,

00:00:59.860,00:01:06.099
Hack-In-The Box Amsterdam, and
Defcon last year; I recommend
you should take some time to

00:01:06.099,00:01:11.104
read it. In the last line you'll
see my two, my tool, my personal
create tool, uh Maloverview

00:01:14.007,00:01:19.012
Tool. Uh if you have some free
time uh you -you can text me.
And let's start. Uh, there are

00:01:25.152,00:01:30.157
lots of people here. Honestly,
once again I was expecting 10 or
12 people, huh. Uh because most

00:01:34.561,00:01:39.566
malware analyst don't like uh
dot net malware. H, basically
malware analyst, while uh

00:01:43.637,00:01:48.642
analyzing dot net malwares are
concerned to unpack uh a binary
from memory or uh find the –the

00:01:53.347,00:01:58.352
encryption routine in a dot net
malware or even show a – the
decryption resources embedded in

00:02:00.754,00:02:05.759
–in this type of malware. But
according to my experience, dot
net uh -dot net malwares uh can

00:02:11.698,00:02:16.703
be so challenging because uh
sometimes a defense uh offers
advances in mal -malware authors

00:02:20.841,00:02:25.846
try to modify uh the dot net
malware, the application
directly in the intermediate

00:02:29.349,00:02:34.354
language. And uh, I've been uh
-I've been -been checking in
analyzing some malwares in dot

00:02:37.157,00:02:40.293
net uh which try to attack the
dot net runtime so it's
recommended to learn a bit more

00:02:40.293,00:02:45.298
uh umm on intermediate language
and uh some information about
metadata and dot net runtime. Uh

00:02:59.112,00:03:04.051
most of the time uh, we find uh
dot net malwares uh around the
world and we have basic-,

00:03:10.824,00:03:15.829
usually uh net codes, uh sorry
dot net uh uh manage codes load
uh uh native code on the memory.

00:03:25.105,00:03:30.110
Thi- this is the common scenario
but sometimes things can be
worse, uh sometimes things can

00:03:35.282,00:03:40.287
be a bit more complicated. You
see, this is a real case that I
uh faced uh some month ago. The

00:03:46.359,00:03:51.364
suspect uh receive an email,
click on the link, drop uh -uh a
first dropper. This dropper uh

00:03:57.137,00:04:02.075
fed a first payload on the
internet. This payload is
composed by two pieces. One

00:04:07.481,00:04:12.486
pieces is a native code, the
other pieces is an encrypt
manage code. This uh first piece

00:04:18.391,00:04:23.396
in native language, in native
code is inject in -into another
process, in a remote process.

00:04:27.734,00:04:32.739
Once this code is injected, uh
this code loads the first manage
code, decrypt and load. This

00:04:37.811,00:04:42.816
manage codes fetch a second
stage from the internet. The
second stage is the real payload

00:04:48.021,00:04:53.026
and the infection is start. So
things uh, things can be harder
than -than uh, than usual case

00:04:58.231,00:05:03.170
and I tried to show it in
pictures here. Uh, I don't
needed to show you again how to

00:05:08.942,00:05:13.947
make injection. Injection is so
easy. I tried to show here in
this slide. This slide is a kind

00:05:16.216,00:05:21.221
of refresh about injections. Uh,
I won't explain it because it's
pretty easy. But as I mentioned,

00:05:28.061,00:05:33.066
things can be different. For
example, I told you that usually
I have uh uh manage code, load

00:05:37.604,00:05:42.609
uh native code eh on rh into
their memory uh but somethings,
-sometimes things are the

00:05:45.145,00:05:50.150
inverse. I have a native code
the loading a manage code into
the memory. In this case for

00:05:54.621,00:05:59.626
example, I have -I use the
CLRCreationInstance to get a
interface name and ICLRMetaHost

00:06:04.764,00:06:09.769
. From this interface I use the
Getruntime to get another
interface named ICLRRuntimeinfo.

00:06:11.838,00:06:16.843
From this interface, I used a
new method named Getinterface to
load the runtime. Afterward,

00:06:23.383,00:06:28.388
afterwards, I use the Execute
application to activate the
domain. I start the runtime

00:06:33.360,00:06:38.365
using the start method and
finally I use the Executing the
full application domain to start

00:06:44.771,00:06:49.776
the real application, the real
infection the real payload. As
you know, a dot net framework is

00:06:54.014,00:06:59.019
composed by a runtime, CLR and
some Libraries. Uh, malware
authors uh can write uh networks

00:07:03.089,00:07:08.094
using different languages such
as uh C sharp and F sharp, uh VB
dot net and so on. Basically uh

00:07:13.466,00:07:18.471
these source codes are compiled
into a common language infra
-infrastructure and finally run

00:07:20.774,00:07:25.779
by the CLR. Uh, we -we have
several excellent tools to
analyze dot net um, networks. I

00:07:29.082,00:07:31.084
tried to list several of them
here. I use them uh daily in my
daily job. Personally, I also

00:07:31.084,00:07:33.086
use some uh additional tools
that I tried to show you here in
red. Uh these are great tools to

00:07:33.086,00:07:35.355
analyze dot net malwares and
you've heard some of that. Uh of
course uh, you must know that

00:08:01.014,00:08:06.019
most dot net, -most dot net
malwares uh use some kind of
packers or quiters so we -we –

00:08:09.055,00:08:14.060
I, -I tried to show you some of
them here. Uh pay attention that
the last one, VM Protect 3 dot 4

00:08:18.998,00:08:24.003
uh was released, I believe one
or two weeks ago and now uh it
includes uh dot net obfuscation.

00:08:33.346,00:08:38.351
When our uh working uh with dot
net malwares, uh you should, or
you must try to remember that

00:08:42.255,00:08:47.260
most them uh are using
obfuscators and obfuscators can,
- obfuscators, uh obfuscating

00:08:49.896,00:08:54.901
the Control flow. These
obfuscator try to rename
methods, attributes, classes and

00:08:58.538,00:09:03.476
so on. Some of them uh, encode
all of the strings of course.
Uh, try to encode and obfuscate

00:09:07.747,00:09:12.752
the cross reference you know.
It's so complicated to analyze
this kind of uh code, uh while

00:09:15.321,00:09:20.326
you use uh any kind of
obfuscators so it's very
important that you know about

00:09:25.532,00:09:30.537
that. When uh, when I'm
analyzing a dot net malware,
usual -usually I see the same

00:09:33.373,00:09:38.378
functions load the payload and
in this case, I tried to show it
in green here. Uh, Assembly dot

00:09:43.783,00:09:48.788
Load, Assembly dot LoadFile and
MethodInfo dot invoke is almost,
almost, almost the same thing.

00:09:51.724,00:09:56.729
Uh, uh, most times uh we see a
kind of uh reflection approach.
And uh, when you see a

00:10:02.702,00:10:07.707
reflection approach, you will
see a sequence similar to that.
Uh I'm using Load R, Load File

00:10:13.680,00:10:18.685
followed by GetType, GetMethod
and Invoke the method. So
reflections is uh so used to uh

00:10:21.521,00:10:26.526
during uh dot not -dot net
malwares so umm it's a very
common approach. Another

00:10:30.563,00:10:35.568
approach, another possibly
-possible approach is using
GetAssemblyName plus GetType,

00:10:37.937,00:10:42.942
GetMethod, Invoke again. As most
malwares uh have been using
resources or, uh just dot net

00:10:48.948,00:10:53.953
malware tries to hide uh some
denial of or their payload into
resources. You see uh sequences

00:10:58.825,00:11:03.763
like this one in pink, uh
FindResource, SizeOfResources
and so on. Sometimes uh you see

00:11:08.368,00:11:13.373
uh other sequences like this
-this one in orange. When uh
malicious dot net assembly uh uh

00:11:23.850,00:11:28.855
is trying to load some external
dll. All -all of these approach
are based on uh trying to load

00:11:31.891,00:11:36.896
something in runtime to evade
your static analysis. Here I
-I’m show you uh a first very

00:11:44.737,00:11:49.742
basic malware. I opened in
dnSpy. We have the entry point
uh there in green. I click now

00:11:59.018,00:12:03.957
the entry point. I find a class
named the
PinnableBufferCacheEventSource.

00:12:07.994,00:12:12.999
Inside this class I see the main
function and at the bottom I see
our potential malicious function

00:12:21.741,00:12:26.746
named TargetInvocationException.
Following this function I see
this -this very special function

00:12:31.484,00:12:36.489
is trying to load uh an
assembly. And eh this function
are using a URL to load this

00:12:41.294,00:12:48.101
assembly but in this case the
weblink comes from several
attributes. For example, I took

00:12:48.101,00:12:53.106
one, the first one uh and I
checked that this attribute is
being set by garing uh, new

00:13:01.948,00:13:06.953
assembly is using
GetExecutingAssembly here at
bottom. This function is trying

00:13:10.323,00:13:15.328
to read a resource. This
resource is encrypted and when
you decrypt the resource, you

00:13:18.965,00:13:23.970
see uh P -p Executable. So uh
each uh each of these uh
variables are -are related to

00:13:33.212,00:13:38.217
our resource that represent uh
possible or potential malicious
native code. Here uh I’m showing

00:13:46.225,00:13:51.230
the same code but uh using
intermediate language as it’s
similar, you’ll see. The main

00:13:57.370,00:14:02.308
function, the entry point, you
see at right our function, our
malicious function. We have a

00:14:07.747,00:14:12.752
token, a token is that number 0
6 and to stop uh works uh a kind
of index inside a metadata table

00:14:22.995,00:14:28.000
named member reference table
there. And when I, when I tried
to follow it, I find a are

00:14:32.305,00:14:37.310
functional here at bottom and
more details are explained. As
you see, implementation flex are

00:14:43.282,00:14:48.287
IL, intermediate language and
manage becauseI’m handling our
manage code. This is a -this is

00:14:52.024,00:14:57.029
a manifest. A manifest in this
case is a file that wr -wrap up
everything. In this case, you

00:15:00.767,00:15:05.772
can see the assembly name, you
can see several manage resource
related to uh mresource at

00:15:12.078,00:15:17.083
bottom. You can see further
information about this malware.
As I mentioned before this

00:15:20.186,00:15:25.191
point, uh this malware is using
reflection to load malicious
content at runtime so you can

00:15:30.196,00:15:35.201
see here several calls to
Getexecuteassembly method in
several points in this

00:15:40.139,00:15:45.144
intermediate language code.
Sometimes you -you are facing uh
a bit harder uh dot net malware.

00:15:51.717,00:15:56.722
Uh in this malware uh brings
some uh encrypt resource so you
can’t use dnSpy or other tool,

00:16:02.428,00:16:07.433
drop this resource, decrypt and
using Reflexil. Reflexil is a
kind of loading you can add the

00:16:17.243,00:16:22.248
original code and load the
resource, the decrypt resource
to analyze the malware. In this

00:16:27.086,00:16:32.091
case, you must true -he move, he
must -he move the old references
because the old reference are

00:16:34.627,00:16:39.632
half reference. Uh decrypt re
-resource so in this case you
drop the resource decrypt just

00:16:43.836,00:16:48.841
the original dot net malware,
load again and that’s it. You
can analyze your dot net malware

00:16:51.777,00:16:56.782
uh using this -this technique.
Of course it is always
recommended to know more uh

00:16:59.318,00:17:04.257
intermediate language and of
course metadata. I -I think that
about 90 percent of case dot net

00:17:16.269,00:17:21.274
malwares or dot net malware
authors trying to insert some
malicious code in our

00:17:32.685,00:17:37.690
initializers, our finalizers. In
this case for example, usually I
try to check uh every uh class

00:17:47.400,00:17:52.405
constructor to find our uh
unpacker or decryptor or any
kind of uh hacking code. It’s

00:17:59.045,00:18:05.885
very usually for example in -in
the last few weeks I’ve been
seeing uh several dot net

00:18:05.885,00:18:10.890
malwares trying to compromise
the JIT. Uh in this case, this
uh -this special malwares -these

00:18:13.526,00:18:18.531
special advances malwares trying
to uh hook JIT function
complier, uh sorry, compile

00:18:22.001,00:18:27.006
methods and to compromise the
JIT. In this case, when the JIT
uh generate the native code, uh

00:18:30.977,00:18:35.982
this -this special malware can
hide or uh encrypt user code in
runtime. For -for example in

00:18:39.518,00:18:41.520
this case, I try to see the
class constructor. There usually
I found – I find some um some

00:18:41.520,00:18:46.525
hacking code. This hacking code
try to compromise the compile
method. And by uh using this

00:18:59.872,00:19:04.810
trick, uh the malware can or
hide or encrypt the user code.
It’s a very clever technique.

00:19:07.213,00:19:12.218
There are other uh dot net uh
details here. Most dot net
malwares bring some very

00:19:20.659,00:19:25.664
important uh metadata. So,
metadata basically are
information about classes,

00:19:28.868,00:19:33.873
attributes, members. Usually uh
usually if -if you uh get very
valuable information from

00:19:36.809,00:19:41.814
metadata. Uh dot net application
as you see is composed by
managed executable and a managed

00:19:43.849,00:19:48.854
code. It’s not so hard to
analyze this kind code but you
need to uh have some uh uh some

00:19:52.992,00:19:57.997
guidelines to do that. For
example a manage code is
composed by a PE Header of

00:20:01.901,00:20:06.906
course, CLR header, metadata and
intermediate language. In this
case, I have the compiler here,

00:20:10.710,00:20:15.714
uh I have the manage – models, I
have the resource files that uh
are compiled to a final version,

00:20:20.786,00:20:25.791
uh composed by a manifest, a
managed models, and a resource
file and uh our resource file.

00:20:31.731,00:20:36.735
In, using pictures, you see that
uh uh dot net header is composed
by PE Header, CLR Header, CLR

00:20:44.143,00:20:49.148
Data, and Native Code. And at
the right side you can see the
same picture but in a detailed

00:20:51.484,00:20:56.489
view. Metadata is very important
because there uh I can find very
uh available things and

00:21:01.660,00:21:06.665
information. Metadata in this
case is composed by Definition
tables, Reference tables, and a

00:21:09.401,00:21:14.406
Manifest table. Uh there are
several tables inside of these
uh classes. And you should

00:21:17.643,00:21:22.648
remember that all the dot net uh
malware infection try to use one
of these tricks. Our code

00:21:28.554,00:21:33.559
manipulation inside the class
constructer or fffuh analyzer uh
try to load some unmanaged

00:21:37.530,00:21:42.535
functions, F function or use a
companies so the tricks are the
same, always the same. Here is a

00:21:44.970,00:21:46.972
second case, a bit more
complicated case. This uh real
dot net malware. I’m -I’m

00:21:46.972,00:21:51.977
showing here the intermediate
language and the metadata
information. As you see, you see

00:22:02.922,00:22:07.927
the name, TypeDef reference
table. You see the method name,
in this case, Main and the

00:22:15.000,00:22:20.005
Flags. In this case I -I’m using
the ILDasm to show this screen.
As you see, the real manage code

00:22:27.146,00:22:32.151
is so small, less than 5
percent. Metadata is so
important because as I told you,

00:22:41.427,00:22:47.433
describes some information about
members attributes, properties,
classes, and so on and this

00:22:47.433,00:22:52.438
metadata uh is organized uh by
using a kind of relational
database and it’s so tiresome

00:22:56.942,00:23:01.880
because you see I have a table.
Uh 1, 2, 3, 3, 4 slots, each
slot is dedicated to a class. Uh

00:23:11.657,00:23:16.662
each slot comes with methods
belong to this class at right.
Uh, this metadata are organized

00:23:23.869,00:23:25.871
in main streams and classified
in metadata -in metadata heaps
and metadata tables. Meta – uh

00:23:25.871,00:23:27.873
metadata heaps is so easy
because that or uh or our only
concern is about strings so a

00:23:27.873,00:23:29.875
string heap is more important
for us. Uh inside these uh six
named streams, we have uh hash

00:23:29.875,00:23:34.880
US, uh utilized to user strings
and hash dash is uh kind of
uncompressed metadata strings so

00:24:01.240,00:24:06.245
uh I -I believe that uh this two
ones are the most important.
When I talk about uh metadata

00:24:12.818,00:24:18.257
table, uh we have several
tables. This -it's almost
impossible to remember every

00:24:18.257,00:24:23.262
one, every table. You see, I
list all the tables here and uh
things here works using a token.

00:24:31.470,00:24:36.475
A token is a kind of structure
composed by four bytes. The
first byte determines the table.

00:24:40.212,00:24:45.217
The remaining three bytes tell
us the rule inside this table.
Here I show you uh some

00:24:50.689,00:24:55.694
statistic information about
metadata. At bottom, I show some
user strings that I commented

00:25:00.065,00:25:05.070
about the name strings.
Intermediate language in dot net
is a kind of uh assembly

00:25:14.413,00:25:19.418
language based on stack. So you
see several instructions uh load
something onto stack or pop some

00:25:24.056,00:25:29.061
things from stack –from stack.
You see uh,-uh very usual
application or two uh named

00:25:33.132,00:25:38.137
Ngen. Ngen is a executable to
compile -to compile uh
intermediate language into a

00:25:41.407,00:25:46.412
native code. It's so easy to do
that but in the last three
years, I've seen several

00:25:52.484,00:25:57.489
malwares trying to attack the
dot –the dot net framework. In
this case, uh this kind of

00:26:00.058,00:26:05.063
infection are a bit more
complicated. We have several uh
we -we have several uh kinds of

00:26:09.034,00:26:15.741
the dot net malwares but
assemblies are classified in
private assemblies and shared

00:26:15.741,00:26:20.746
assemblies of course. Uh you
should remember that most
malware samples uh try to hide

00:26:25.951,00:26:30.956
some malicious content in
resource, hide by encrypting or
obfuscate something. Uh some dot

00:26:36.795,00:26:41.800
net malwares try to download uh
an external assembly from
somewhere. In order uh dot net

00:26:47.406,00:26:52.945
malwares are based on multi-file
assemblies. In these cases, it's
a bit more complicated because

00:26:52.945,00:26:57.950
these authors try to compose the
dot net assembly and uh and is
split over multiple files uh to

00:27:03.455,00:27:08.460
evade the defenses. It's so easy
to generate a multi-file dot net
malware. For example I show you

00:27:12.898,00:27:17.903
here, a step-by-step, this case
is so easy. Uh -uh I compile for
example a hooking dot cs model.

00:27:20.672,00:27:25.677
I compile an injection dot cs
and using a uh a main program
named defcon dot cs, I generate

00:27:30.349,00:27:35.354
a library named uh malware lib
here. It's so easy to do that.
Of course this operation took

00:27:37.923,00:27:42.928
several metadata tables but it
-it's normal. Here uh we have
uh, real manifest about our

00:27:49.201,00:27:54.673
second malware. You see, some
native models being loaded at
bottom, some external reference

00:27:54.673,00:27:59.678
to assemblies. And at this case
-in sorry, in this case, our uh
our assembly is uh string

00:28:08.854,00:28:13.859
assembly because uh it uh it is
uh it's signing by a private uh
key from somewhere. The second

00:28:25.037,00:28:30.042
screen here you see the driver,
uh the assembly name, you see
several custom attributes. You

00:28:33.779,00:28:38.784
see that uh the signature is
SAG, SAJ one algorithm. You see
several manage resource being

00:28:49.728,00:28:54.733
used and uh at bottom you see
that the uh the real name of
this malware is Microtik Realtek

00:29:00.939,00:29:05.944
Driver dot exe. I show you here,
how to compact a file executable
in C sharp; it's pretty easy. If

00:29:21.093,00:29:26.098
you have a key pair, you can
sign uh this assembly by using
this procedure here at bottom.

00:29:30.569,00:29:35.574
After signing this dot net
assembly, you can see the public
key there in red. During some

00:29:45.717,00:29:50.722
infections uh I’ve seen uh
native – native uh uh codes
trying to copy uh dot net

00:29:57.362,00:30:02.367
assembly to GAC. GAC is global,
means global assembly cache. In
this case, the author uh was

00:30:06.104,00:30:11.109
trying to execute native code,
copy the manage code to GAC
because other pieces of this

00:30:15.580,00:30:20.585
malware uh would use uh would
use uh the -this shared assembly
in the GAC to continue the

00:30:27.259,00:30:32.264
infection. It's a kind of second
stage. It's pretty easy to copy
to that because you can use GAC

00:30:35.867,00:30:40.872
Util there in orange or you can
use the MSI Install package to
do that. Of course uh to copy

00:30:48.280,00:30:53.285
anything to GAC, you need to
have a keeper to sign your dot
net assembly. If you don’t have

00:30:56.722,00:31:01.660
one, you can use the –only the
public key and try uh delay
signing. In this -in this case,

00:31:03.695,00:31:08.700
you will uh sign the dot net
assembly only use the public
key. Uh to do that you can

00:31:13.705,00:31:18.710
follow this procedure. You can
add some resources by using
slash resource, you can add some

00:31:20.979,00:31:25.984
references by using slash
references; it's pretty easy. Of
course, uh I don't have enough

00:31:29.020,00:31:34.025
time here to show you uh how to
uh –to explain everything we
instruction in intermediate

00:31:37.262,00:31:42.267
language so I left some –some
slides here showing each
important instruction in

00:31:44.936,00:31:49.941
intermediate –in intermediate
language. Uh I don't have enough
time to do that unfortunately.

00:31:52.410,00:31:57.415
And here I show you a real, real
malware. Uh it's the same
malware so I tried to comment

00:32:03.155,00:32:08.160
several lines. Of course, you
must know about C sharp to
understand these -these codes.

00:32:10.962,00:32:15.967
Uh here we don't have anything
different from a C sharp but the
names and the keywords are a bit

00:32:21.139,00:32:26.144
different. You have uh public
class, you have private class,
you have your sealed class, you

00:32:28.547,00:32:33.552
have your constructor here uh
ctor, you have some private
fields, we have uh some stack

00:32:36.454,00:32:41.459
reservation there, max stack,
you have several operations
loads, things to stack on top of

00:32:46.364,00:32:51.369
things from stack. You have a
custom – a custom instance here
at bottom, You have private

00:32:56.675,00:33:01.613
class, you have uh –uh
invocation of a native code in
-in the middle here, you see

00:33:04.616,00:33:09.621
invoke implementation here
trying to call a -a manage code.
You have here at bottom uh, on a

00:33:20.031,00:33:25.036
uh look variable being
initialized with zeros. We have
a try, uh try catch structure,

00:33:29.207,00:33:34.212
so it's so similar to uh C sharp
code. I tried to comment several
lines here uh to help you later.

00:33:41.353,00:33:46.358
You have for example here heh,
our -our dot net malware are
interest in get our uh

00:33:48.927,00:33:53.932
keystrokes. You see uh, uh in
this case malware is trying to
hook uh some uh keyboard

00:33:59.304,00:34:04.242
operations. As -as -as you can
see, uh the dot net malware is
trying to hook the KeyDownEvent

00:34:08.346,00:34:13.351
and KeyUpEvent so uh it’s a kind
of keylogger. At bottom here, we
have uh some event declaration.

00:34:20.725,00:34:25.730
Uh in -in this case, our dot net
malware is trying to subscribe
some functions uh on -on this

00:34:33.138,00:34:38.143
event. Uh at bottom, key down,
at up uh key uh key up. And
finally uh our dot net malware

00:34:49.421,00:34:54.426
using aggregate uh uh to invoke
this event. So easy to do that.
Several uh constructor’s been

00:35:00.365,00:35:05.370
called here. Oh finally, I found
the decryption function. This
function is re -responsible for

00:35:16.181,00:35:21.186
decrypting several strings from
this malware. As you see, I try
to comment line-by-line or the

00:35:23.655,00:35:28.660
most important line here. Uh,
you can -you can try to monitor
all DLL’s load from the GAC by

00:35:38.036,00:35:43.041
using Fuslog or even Process
Monitor. But uh as I told you,
uh some advanced malwares try to

00:35:46.444,00:35:51.449
compromise the dot -the dot net
framework, uh try to insert some
hookings, uh even trying to

00:35:54.152,00:35:59.157
compromise the JIT. So, it’s uh
uh just kind of more -more
dangerous. Here at -at bottom I

00:36:04.996,00:36:10.001
show you the complete procedure.
For example I can call a DLL
from GAC, modify, uh recompile

00:36:13.004,00:36:18.009
uh to the native code and copy
it back again to the GAC. It’s
so -it’s so easy, pretty easy to

00:36:23.548,00:36:28.553
do that. Of course, uh nothing
is so simple to do that. I
needed to I -I needed to uh have

00:36:35.894,00:36:40.899
a sign assembly and as I don’t
have the private key from the
Microsoft is so complicated, it

00:36:44.035,00:36:50.675
should do that. Uh other
approach, it would be to uh
resign all the dot net

00:36:50.675,00:36:55.680
framework; It’s so hard to do
that. I can try to uh copy the
-the modified DLL uh to GAC but

00:37:00.719,00:37:05.723
if uh some applications are
services, uh are using this uh
DLL, it’s not possible. I can

00:37:10.295,00:37:15.300
try to force a reboot to make
this spot and even that I get to
the GAC, I need to force uh my

00:37:22.307,00:37:27.312
[incoherent] applications using
this modified DLL. So in this
case I needed to uninstall and

00:37:30.248,00:37:35.253
remove, the native uh uh code
from the native directory. Casey
Smith uh show a very uh

00:37:40.391,00:37:45.396
interesting way uh to do that.
Casey Smith uh uh uh show a very
nice trick by -by copying, by

00:37:49.300,00:37:54.305
dropping assembly to the path
tasks dot dll to force
applications using my modified

00:37:57.775,00:38:02.714
DLL. I can try to, for example,
I have uh I have uh register uh
composed by two entries. One

00:38:08.653,00:38:14.926
entry uh is going to show the
assembly code, the other entry
is point to the native code. In

00:38:14.926,00:38:19.931
this case I tried to change the
second entry to uh point to my
modified dll is another approach

00:38:24.402,00:38:29.407
here. Some uh some dot net
malwares try to compromises
services, try to uh introduce

00:38:31.843,00:38:36.848
some hooking in JIT. Some dll
-some dot net dll try to load
external assemblies so there are

00:38:40.485,00:38:45.490
several tricks. Of course I’ve
been using Windbg to analyze uh
this kind of dot net malwares

00:38:48.226,00:38:53.231
using uh an extension on Sosex.
And uh here I show you a
computer code. For example here

00:38:59.137,00:39:04.075
-here, I load the -the extension
SO -SOS dot dll, I found the
native entry point -the -the

00:39:10.014,00:39:15.019
-the uh -the manage entry -entry
point. I, this assembly the
entry point I found the PE entry

00:39:20.825,00:39:25.830
point there by using dumpbin .
Uh I tried to display the
pointer and finally I find uh

00:39:29.234,00:39:34.239
the CorExeMan uh function by the
same. I can dump the domain. In
this case uh I see the system

00:39:39.744,00:39:44.749
domain, I see the shared domain,
I see our domain that uh from
our malware. I see several calls

00:39:49.821,00:39:54.826
to external assemblies Visual
basic, System dlls, forms and so
on. I list uh several managed

00:40:01.432,00:40:06.437
exceptions. I can try to switch
uh the tracks for the sample. In
this case, I switches to Thread

00:40:10.942,00:40:15.947
0, I checked the managed stack
trace here. I found our dot net
-mm uh malware at bottom. I list

00:40:23.321,00:40:28.326
some manage tracks by using, uh
by tracks here as you see, you
can see that thre -threads uh

00:40:34.599,00:40:39.604
threads. Threads zero, two,
fine, ten and fourth thing, our
managed threads. All of them are

00:40:41.973,00:40:46.978
managed by Garbage Collector. I
risk the native, the native at
stack at bottom using KeyIn. I

00:40:54.552,00:40:59.557
pickup a -an entry there. I
check that if this address
belongs to the JIT code, yes in

00:41:05.830,00:41:10.835
this case belongs, I pickup the
Method Descriptor reference. I
assembled it, so we have the

00:41:14.739,00:41:19.744
assembly uh uh function here. I
check the managed stack again. I
pick up a object’s address. I

00:41:24.882,00:41:29.887
check it against uh uh if this
address belongs to the JIT. Yes
again I dumped the meta

00:41:34.492,00:41:39.497
descriptor information here. I
pickup the class reference at
top. I dumped the EEClass

00:41:47.572,00:41:52.577
structure information. I found
the, i found that this is
specific class has 6 methods, 8

00:42:05.390,00:42:10.395
instance fields and 5 static
fields. I can check one of these
fields for example in this case,

00:42:14.465,00:42:19.470
I validate fields by using
dumpvc. I found a hashtable
class composed by several, uh

00:42:24.308,00:42:29.313
several fields here at right. I
dumped the method table
information, I dumped the method

00:42:35.787,00:42:40.792
table information again but uh,
the payout didn’t output. As you
see, several uh methods some of

00:42:43.728,00:42:48.733
them PreJIT and precompiled. I
dumped information about uh -an
specific model. I found the

00:42:53.337,00:42:58.342
assembly reference, I dumped the
assembly uh information. I found
the parent domain information. I

00:43:03.014,00:43:08.019
dumped the domian information at
bottom. It’s pretty easy to do
that, of course here. Here is a

00:43:10.721,00:43:15.726
bit more complicated. Uh,
finally I start again, I -I
found the metadata structure and

00:43:19.597,00:43:24.602
uh the structure here. I found
some interesting uh classes, uh
possible malicious classes,

00:43:29.574,00:43:34.579
possible malicious classes. I -I
take one testprint dot client. I
dumped some information from

00:43:39.517,00:43:44.522
this class. As you can see,
there are several methods there.
I pick up one. I dumped the

00:43:50.728,00:43:55.733
class, it’s -it and it’s very
interesting because there I -I
found some uh some fields in

00:44:01.105,00:44:06.110
English, Portugese and German
language. I - I took the German
one to check the information. As

00:44:12.517,00:44:17.522
you see uh, this part uh was not
executed by JIT because at
bottom it’s easy to know. So I

00:44:22.226,00:44:27.231
try to put a break point to a
future execution. I dump it
again all -all of the stack

00:44:31.669,00:44:36.674
objects. I saw uh uh a function
using uh an array, I dumped this
array. This array is composed by

00:44:43.214,00:44:48.219
one element that in this case is
a structure, as you see at
bottom. I dumped, okay that’s

00:44:52.957,00:44:57.962
-that’s the seems light. I check
the heap information. I check
any kind of reference by should

00:45:01.966,00:45:06.971
this object by using Gcroot.
References from uh, references
from the stack uh from the

00:45:10.775,00:45:15.780
handle tables. I checked the
finalized queue to find
something interesting. I check

00:45:19.417,00:45:24.422
the pinned handles because some
malwares uh cause strong heap
frag -fragmentation. I track

00:45:28.626,00:45:33.631
again, I keep again uh some pro
same problems with locks and
that locks, locks, uh the

00:45:36.400,00:45:41.405
deadlocks. I tried to find a
string inside the heap, the
managed heap. Uh at bottom I

00:45:45.910,00:45:50.915
bump the -the malware from
memory. And finally, finally, I
check the current event lock. I

00:45:56.921,00:46:01.859
dumped some strings from there,
I found some nice strings at
bottom. Uh I dumped all of the

00:46:05.863,00:46:10.868
heap, I found -I found uh some,
I -I found some uh classes. I
took one keyboard hook and so

00:46:21.879,00:46:26.884
nice. I now map the front JIT
class that are several methods.
I took the last one. Try to

00:46:33.858,00:46:38.863
assemble it in intermediate, -in
intermediate language. Try to
dump all the strings from the

00:46:43.801,00:46:48.806
memory related to this uh
method, and it’s nice, I found.
Several URL’s related to banks,

00:46:56.280,00:47:01.218
so this is a kind of trojan
banker. Uh, I -I’m leaving some
breakpoints for, for you here.

00:47:07.992,00:47:12.997
These uh are very nice break
points to test, to gather some
additional information. And at

00:47:17.368,00:47:22.373
last, the -the URL uh in a virus
total by using malwareview I can
see that it’s a malicious site

00:47:27.578,00:47:32.583
and I test the domain and I
found several related things,
several malicious things uh

00:47:37.455,00:47:44.261
associated to this sub-domain.
It was a very long presentation,
you know about that. If you

00:47:44.261,00:47:49.266
want, I can uh I can explain uh
details for you. Uh, thank
-thank you so much to the Defcon

00:47:54.004,00:47:59.009
staff as usual for you who, who
reserved some time and have a
nice day, thank you. [applause]

00:48:06.584,00:48:08.619
>>Wonderful job

