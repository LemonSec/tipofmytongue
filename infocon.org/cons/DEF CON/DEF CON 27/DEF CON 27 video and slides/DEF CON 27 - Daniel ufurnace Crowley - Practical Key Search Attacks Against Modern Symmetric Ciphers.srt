00:00:00.167,00:00:05.239
>>Let's give Daniel and Daniel a
big round of applause! And hear
about some, uh, crypto stuff.

00:00:05.239,00:00:10.244
[applause] Have a great time,
boys. >>Thank you. >>Have fun.
[applause] Good luck. >>Thanks

00:00:12.412,00:00:16.650
everybody. Darren was nice
enough to give me a shot too,
even though I've spoken before,

00:00:16.650,00:00:21.321
so... Although I didn't, I
didn't expect it to be room
temperature Jack Daniels, uh,

00:00:21.321,00:00:27.027
body temperature, sorry, body
temperature Jack Daniels, so...
[laughter] Uhm, so, uh, so, I'm

00:00:27.027,00:00:32.633
Daniel Crowley, uhm, I run
research at X-Force Red, uhm,
I'm a cryptography nerd, if

00:00:32.633,00:00:37.671
you've ever heard of the tool
FeatherDuster, that's my work.
Uh, also, I am Sealandic

00:00:37.671,00:00:44.311
nobility, uhm, and I'd like to
clarify that crypto does not
mean that either crypto currency

00:00:44.311,00:00:49.316
or cryptography - crypto means
cryptozoology. So, please get
that right. >>Yea, so it's my

00:00:53.487,00:00:59.393
first time speaking here, and,
uh, I thought I'd start out
strong with a, uh, quality meme,

00:00:59.393,00:01:04.331
uhm... [laughter] So, the, you
know, just for you guys, uhm,
but, uh, I just graduated from

00:01:04.331,00:01:09.336
Georgia Tech, uhm, I'm also
Sealandic nobility, whereas he's
a baron, I am the lord. Uhm, and

00:01:11.939,00:01:16.944
yea, so I'm, I'm working with
him doing our crypto stuff,
yea.. >>So, I'd also like to

00:01:22.649,00:01:28.555
point out that team Saeland here
is dangerously close to
completing the DefCon infinity

00:01:28.555,00:01:34.861
gauntlet, uh, we have the
speaker stone, the contest
stone, and the goons stone and

00:01:34.861,00:01:41.835
the human stone as well, so...
[laughter] For the sake of
DefCon Spiderman, please, uh,

00:01:41.835,00:01:46.840
don't get a press badge near us.
Uhm... [laughter] Anyway, sorry,
the, there is, uhm, there is a

00:01:52.212,00:01:58.352
problem that we're trying to
solve here, uhm, and as, as any
good, uh, solution should have a

00:01:58.352,00:02:04.891
problem it's trying to solve.
Uhm, so, there's this whole big
thing made about Hash Cracking.

00:02:04.891,00:02:09.363
Hash cracking is a huge thing in
the hacker community, uhm and in
the information security in

00:02:09.363,00:02:15.936
general. And this is for good
reason, uhm, there's lots of
practical applications, uh, for

00:02:15.936,00:02:20.841
hash cracking. Uhm, uh, in, in
penetration testing and things
like that in strength, in

00:02:20.841,00:02:25.979
testing password strength.
There's a long history of it ,
uhm but it's even a sport and a

00:02:25.979,00:02:30.717
business, you know. There's that
contest here at DefCon, called
"Crack me if you can". Which is

00:02:30.717,00:02:35.722
all based around password hash
cracking. Uhm, now, something
that is not quite as big, by a

00:02:40.193,00:02:44.798
long shot, is cracking
encryption keys, uhm there's are
examples of this that are, that

00:02:44.798,00:02:49.803
are being done. Uhm, sort of,
uh, on regular basis, so WPA2
cracking, uhm, is cracking

00:02:51.972,00:02:57.778
symmetric encryption keys. Uhm,
but then you also have a lot of,
uh, stuff that's being done in

00:02:57.778,00:03:02.716
terms of side channel analysis.
So, analysis of power or timing
or heat or something like that,

00:03:05.519,00:03:11.558
in order to recover encryption
keys without, uh, any sort of,
uh, key search attack, any sort

00:03:11.558,00:03:15.462
of brute force. So, it's not
really brute force, it's not
really cracking, it's more of

00:03:15.462,00:03:21.234
key recovery. And if you can
recover a partial key, then you
can brute force the rest. Uhm,

00:03:21.234,00:03:25.105
and then we see algorithm
specific attacks. So, for
instance, uh, there's been a lot

00:03:25.105,00:03:30.110
of work in cracking DES keys
because DES has a pitifully
short key length. Uh, and so

00:03:32.612,00:03:38.485
that makes it practical to do an
exhaustive key search without
any sort of optimisation and it

00:03:38.485,00:03:45.125
works. Uhm, the EFF have built a
DSS, uh, uh, the most recent DES
cracker that I'm aware of and

00:03:45.125,00:03:51.465
it's just, DES is, DES is dead.
Uh, single DES is dead. Uhm, but
this is sort of, uhm, what we

00:03:51.465,00:03:56.470
see in the community on
encryption key cracking so far.
Uhm, but as far as general, uh,

00:04:00.107,00:04:06.012
cracking of encryption keys
there's not a whole lot going
on. Uhm, nobody has really

00:04:06.012,00:04:11.017
talked about how in general you
take encrypted data and try to
guess the key in a meaningful

00:04:13.086,00:04:16.590
way, in a practical way. And
this is really what we're going
to be discussing here today.

00:04:16.590,00:04:23.396
Uhm, but first, let's talk about
why the traditional wisdom is
that symmetric key-cracking

00:04:23.396,00:04:28.401
should fail in theory. Uhm,
when, you know, we've seen with
like WPA2 key cracking that it

00:04:30.403,00:04:36.443
really does work in practice at
least with some applications.
So, the first big thing is key

00:04:36.443,00:04:42.916
validation, when you take the
wrong key and try to use it to
decrypt some encrypted data,

00:04:42.916,00:04:47.654
decryption can't fail. It's,
it's, it's basically an equation
- you're, you're just running

00:04:47.654,00:04:54.427
through a, a series of steps,
uhm, and it, it can't, it can't
fail really, uh, it just

00:04:54.427,00:04:59.432
produces a different output.
Uhm, because you're really just
permuting data from one, from

00:05:01.968,00:05:08.608
one thing to another. Uhm, so
you just get a different
pseudo-randomised output instead

00:05:08.608,00:05:13.613
of the correct output. Now, in
theory, academically speaking,
uh, the, the common wisdom is

00:05:17.784,00:05:23.356
that it should be impossible to
guess encryption keys because
you can't tell when you've got

00:05:23.356,00:05:27.561
the correct key because you
don't know anything about the
message. Now, we'll talk about

00:05:27.561,00:05:32.465
why this is a bad, uh,
assumption why the theory
doesn't match the practice. Why

00:05:32.465,00:05:37.838
the real world is different.
Uhm, but then you also have the
problem with key space. Now,

00:05:37.838,00:05:43.743
uhm, the, when you don't, when
you're not, like, talking about
and export strength ciph, cipher

00:05:43.743,00:05:48.615
which is specifically weekend to
have a key length that can be
exhaustively searched where we

00:05:48.615,00:05:54.888
can guess every key with modern
hardware. Uhm, you, you know,
when you're talking about like

00:05:54.888,00:06:00.360
AES 128, for instance, you're
talking about 16 bytes of key
material - a 128 bits of key

00:06:00.360,00:06:06.800
material - and to guess every
single key with all of the
computing resources on planet

00:06:06.800,00:06:12.405
earth, right now, it should take
longer than we will take to
reach the heat depth of the

00:06:12.405,00:06:19.312
universe. So, that is another
reason, in theory, what we're
doing, practically should fail.

00:06:19.312,00:06:24.317
Uhm, so let's talk about the
solution to validating our
guesses. Uhm, so, in the real

00:06:29.022,00:06:35.895
world, there is an easy
distinction that we can make in
most cases between the pseudo

00:06:35.895,00:06:40.900
random output that we get from
using the wrong key, to the
structured, meaningful data that

00:06:43.136,00:06:49.909
we get from decrypting data
using the correct key. In the
real world, we can, we, we do

00:06:49.909,00:06:54.915
have some information about what
the message is supposed to be.
And we'll dive deeper into that.

00:06:54.915,00:07:01.354
But, like, you know, if, if
you're seeing English words in a
decrypted, uh, uh, in decrypted

00:07:01.354,00:07:06.593
data, if you're seeing
meaningful-looking data, if
you're seeing, uh, formats like

00:07:06.593,00:07:13.566
XML or JSON, that, that, that's,
you know, statistically it's
possible that you can come out

00:07:13.566,00:07:18.571
with that but it's unlikely. And
we'll talk about just how
unlikely, uh, later on. Uh, but

00:07:20.907,00:07:26.479
knowing or guessing part of the
plain text is often very easy.
We can make a lot good general

00:07:26.479,00:07:30.150
assumptions about what data
we're going to get. And we'll
talk a little bit more about

00:07:30.150,00:07:34.554
that later. Uhm, but if we can
validate that data we can
validate that the key is

00:07:34.554,00:07:39.559
correct. Uhm, so, uh, with
Electronic Code Book mode, uhm,
as an example, uhm, there are

00:07:44.364,00:07:51.137
certain con, there are certain
considerations that we need to
make. So, AES by itself is just

00:07:51.137,00:07:56.142
a black box that takes 16 bytes
and a key and turns those 16
bytes into some other 16 bytes

00:07:58.778,00:08:03.717
and back. Uhm, and so it's sort
of like a, uhm, it's, it's a
pseudo-random permutation,

00:08:06.953,00:08:11.958
right? Uhm, now, in order to
process data with AES, it needs
to be exactly 16 bytes in

00:08:16.796,00:08:22.402
length, in Electronic Code Book
mode is the most naive
construction and is the simplest

00:08:22.402,00:08:26.606
construction and this is just
for demonstration purposes - we
won't get into, all the problems

00:08:26.606,00:08:31.611
with ECB. Uhm, but, the, the
thing is that if we have data
that is longer than 16 bytes, we

00:08:33.613,00:08:37.851
need to split up into chunks and
do something with those chunks -
process them individually with

00:08:37.851,00:08:44.190
AES or whatever block cipher
we're using. Uhm, now, the thing
is, if we don't have enough

00:08:44.190,00:08:48.828
data, we need to add what is
called "padding". So, we add at
the very end, we add a little

00:08:48.828,00:08:53.833
bit of padding or "jump data" to
the end that is recognisable,
uh, in our crypto-system as

00:08:56.302,00:09:03.009
jumped data so that it can be
removed. So that we can take
data that's 15 bytes or 30

00:09:03.009,00:09:08.014
bytes, or something that doesn't
evenly fits into 16 byte chunks,
and process it with AES which is

00:09:10.183,00:09:15.188
a function that processes 16
bytes and no more and no less.
And what this means, for us,

00:09:18.124,00:09:24.764
because padding is required to
use AES in a useful way, it
means that we have data that can

00:09:24.764,00:09:31.471
validate. So, we need padding,
we need to apply padding to
messages and when we decrypt it,

00:09:31.471,00:09:37.110
we can see that padding and in
fact, many common encryption
libraries, when decrypting, will

00:09:37.110,00:09:43.016
check the padding and if it does
not, uh, uh, look correct, it
will actually fail. So, while

00:09:43.016,00:09:47.620
encryption, you know, while the
decryption cannot really fail
with the wrong key, if you were

00:09:47.620,00:09:53.259
to use the wrong key in
decryption, your library would
probably fail. So, this is a way

00:09:53.259,00:09:58.264
we can easily validate. Now, it
is possible for padding to be on
a random output just by chance.

00:10:05.004,00:10:11.277
Just by random chance. But,
let's talk about how feasible it
is, let, let's talk about how

00:10:11.277,00:10:17.117
much of a problem that is. So,
let's talk about one of the most
common padding schemes in the

00:10:17.117,00:10:21.120
world, it's called PKCS5 or
PKCS7 padding - and the trivia
there is that this was

00:10:21.120,00:10:26.125
originally released in Stanridge
document, uh, called "PKCS
number 5" and then they, they

00:10:29.662,00:10:35.768
defined it for 8 byte block
cipher, 64-bit block ciphers.
And then, later on they said

00:10:35.768,00:10:41.040
"Well, actually, the scheme
works for any block size, so it
works for any block size, so it

00:10:41.040,00:10:46.045
works for any block size so just
use it like that." And it's
fine. And that was in PKCS

00:10:46.045,00:10:51.050
number 7, so, uhm, if a
cryptographer, uh, which, uh, we
cryptographers are notoriously

00:10:53.319,00:11:00.093
pedantic, uhm, everyone is like
"Eh, that's actually PKCS7" -
now you know why. Uhm, so, uh,

00:11:00.093,00:11:05.098
but if, if you, the way it works
is basically like this - however
many bytes you need to get to

00:11:08.134,00:11:15.008
the next block boundary, uh, you
just take the, that number and,
and make that the, the byte

00:11:15.008,00:11:20.246
value of every byte that you
add. So, you have 5 open bytes
to get to the next block

00:11:20.246,00:11:25.251
boundary? You add five 5s or you
add two 2s. And the beauty of
this scheme, if you have, for

00:11:27.754,00:11:34.527
instance, four spots empty, 4
bytes that you need to pad and
you have an ASCII value 4 byte

00:11:34.527,00:11:39.532
at the end of your plain text,
uhm, a well-written PKCS7
padding, uh, removal routine

00:11:41.768,00:11:47.106
will just take a look at the
last byte and say "Okay, is the
number 4? Are there four 4s at

00:11:47.106,00:11:51.210
the end? There are. Great, I'll
remove them." So, this is
totally unambiguous, uhm, this

00:11:51.210,00:11:56.683
is one of the, this is a very
simple padding and it's very
commonly used, very well, uh,

00:11:56.683,00:12:01.621
supported. Uhm, but we can
validate this, right? So, uhm,
any message that ends in a, uh,

00:12:06.259,00:12:11.264
uh, a byte with a value of 1, is
padded correctly under PKCS5
slash 7. Uhm, which means that

00:12:15.201,00:12:20.206
we have a 1 in 256 chance, uh,
of, getting a message that is
padded correctly under PKCS5

00:12:23.109,00:12:28.114
slash 7 padding. So, padding
alone produces too many false
positives. But, we also have

00:12:31.484,00:12:37.323
the, uh, the assumption that we
can make that our data will be
printable. So, we can say, you

00:12:37.323,00:12:43.329
know, if we decrypt some piece
of data with a, with a key that
we're guessing, we dunno if this

00:12:43.329,00:12:48.301
is the correct key or not, we
can validate the padding and can
most of the time make the

00:12:48.301,00:12:52.272
assumption that the data that
we're, that's coming out is
printable. Now, there are a

00:12:52.272,00:12:58.978
hundred printable characters in
the ASCII character set - out of
256. So, our chances of getting

00:12:58.978,00:13:05.585
7 characters, assuming, like an
8-byte block, uhm, is 1 in a
hundred seven twenty, uh, sorry

00:13:05.585,00:13:10.590
1 in, 1 in 720. Uhm, so if we
have longer blocks, more
characters, we have an even

00:13:12.959,00:13:18.698
lower chance of a false
positive. So, this, in this 8
byte scenario, we have

00:13:18.698,00:13:25.338
approximately 1 in 250-thousand
false positive chance. Now,
that's not great when we're

00:13:25.338,00:13:30.977
guessing a large volume of keys,
but it's also not bad and we'll
talk about how we can improve

00:13:30.977,00:13:36.916
that further. Uhm, one of the
things to remember here is that
it's way more likely for the

00:13:36.916,00:13:41.921
last byte to be one particular
value out 256 possible values
than, uh, two bytes being one

00:13:44.957,00:13:51.030
particular value, out of 256
possible values. Or three bytes,
or four bytes. So, when we have

00:13:51.030,00:13:56.035
a false positive on the padding,
it's overwhelmingly likely to be
just one byte value 1, uh, at

00:13:59.238,00:14:05.578
the end. Uhm, so, keep that in
mind. In our worst case
scenario, we have a single block

00:14:05.578,00:14:11.751
of ciphertext. Uhm, and this,
this is, you know, this, this
checking for printable

00:14:11.751,00:14:18.057
characters is something we can
apply across multiple blocks.
Uhm, if we have only a single

00:14:18.057,00:14:24.197
block of 64-bit block, uh, of
64-bit, uh, block cipher
ciphertext. And we don't know

00:14:24.197,00:14:29.836
anything about the plaintext we
are only checking on padding and
printable characters. We get

00:14:29.836,00:14:34.841
about 4-thousand false positives
every billion guessed keys. Now,
that's not that bad, and we can

00:14:38.010,00:14:43.015
actually use character analysis
frequency analysis, uhm, as is
used in a lot of cracking of

00:14:45.551,00:14:51.290
classical ciphers in order to
narrow down what the best
candidate keys are. So, if we

00:14:51.290,00:14:57.997
have 1 key that, uh, comes out,
allows us to decrypt to
printable characters but it's a

00:14:57.997,00:15:02.935
complete jumble, and then we
have another key that looks,
that prints out, uh, and English

00:15:06.172,00:15:11.177
word - a word in English
followed by multiple bytes of
PKCS7 padding, that's a much

00:15:14.347,00:15:21.053
better result. That is much more
like to be the correct key. And
using these factors we can score

00:15:21.053,00:15:26.459
the output, so yes, maybe e have
4-thousand false positives for a
billion keys in the worst case

00:15:26.459,00:15:32.398
scenario but we can score them
and like google results - the
first page is gonna be a lot

00:15:32.398,00:15:39.071
more useful than the 7th. If we
have more samples, and this,
again, it's we're talking about

00:15:39.071,00:15:45.311
the worst case scenario, 8 bytes
of ciphertext, uh, per
ciphertext, and multiple samples

00:15:45.311,00:15:50.316
if we have 2, suddenly, our
false positive rate drops
dramatically. We have 1 in 62

00:15:52.919,00:15:57.924
point 5 billion false positives.
So, every 62 point 5 billion
keys we guess, we get 1 false

00:16:01.460,00:16:07.667
positive. And, with 3 worst case
ciphertexts, it's an obscene
number, I think quadrillion,

00:16:07.667,00:16:12.972
it's in the quadrillions. So,
this is because a terribly
practical attack, if you have

00:16:12.972,00:16:17.977
even 2 worst case ciphertexts.
>> Alright, I, uh, I talk, you
know, I'm not gonna be silent

00:16:23.883,00:16:28.955
the whole, whole presentation,
don't worry, uhm, so, the next
part of the solution is the, the

00:16:28.955,00:16:33.960
key space. So, basically, there
is a way that developers should
be doing this and then there's

00:16:37.797,00:16:42.969
what actually happens. So, how
they should be choosing their
keys, at least, is through

00:16:42.969,00:16:47.974
actual random number generators.
Uhm, true random number
generators or, uhm, also,

00:16:50.042,00:16:55.047
slightly worse but still, uh,
valid is to, kind of, take a
password and you want to run it

00:16:58.384,00:17:03.456
through a computationally
expensive function, uh, like
those shown, and uh, basically

00:17:03.456,00:17:08.461
that, that is a decent way of
generating a key whereas you
don't want you key to be, say,

00:17:10.863,00:17:15.868
looking like these. Uhm, so,
these are some keys we have
actually seen in the wild. Uh,

00:17:19.338,00:17:24.343
in some, like, real production
code, so, yeah, I mean you can
obviously see how, how easy that

00:17:27.780,00:17:30.716
would be to guess. Uhm, and, uh
sometimes developers try to do,
uh, like homebrew crypto and

00:17:30.716,00:17:33.953
that's never good, good thing to
try, so... Uh, very common is to
just choose your password and

00:17:33.953,00:17:35.955
then just pad nulls, no bytes
until you hit 16 bytes. Uhm, or
just repeat your chosen password

00:17:35.955,00:17:40.960
over and over until you hit that
16 bytes. And then, also, uhm, I
talked about, like,

00:17:55.675,00:18:02.014
"computationally expensive"
password derivation functions.
Uhm, running it through MD5 is

00:18:02.014,00:18:06.953
really, really, really
computationally cheap. So, uh,
that's basically nothing if I

00:18:06.953,00:18:12.658
know that you're doing MD5 to
generate your keys then I can
run all of my password lists on

00:18:12.658,00:18:17.663
MD5 and that's nothing. That
would be very easy to do. Uhm,
so yeah, and, it's kind of weird

00:18:21.267,00:18:26.872
but if you look at the first
result of Google, as a java
developer, for how to do AES

00:18:26.872,00:18:33.546
encryption, they actually tell
you the incorrect way of
generating your key. Uhm,

00:18:33.546,00:18:38.551
either, you know, running it
through MD5, or SHA-1 or even
just part-coding the bytes into

00:18:40.686,00:18:45.691
your code, which is, terrible.
Uhm, so yea, uhm, this is just a
basic usage of SHA-1 to generate

00:18:49.195,00:18:54.200
the key. >>Uhm, uh, this is
actually the exact code they
give you in the first result in

00:18:56.969,00:19:01.907
Google. >>Yeah, yeah, this is
from their example, uhm, so this
is, this is bad obviously. Uhm,

00:19:04.343,00:19:10.683
and, uh, so sometimes, you know,
developers think "oh, I can just
add a little bit more onto it

00:19:10.683,00:19:15.688
and it would be a little bit
more secure. Ugh, XOR, just take
the SHA-1 and run it through a

00:19:18.524,00:19:23.529
couple of XORs which are easily
reversible. Uhm, this is no
problem for, for, uh, us to

00:19:27.166,00:19:32.972
attack, uhm, because, and this
is, this is an open source code,
right? Like this is real code

00:19:32.972,00:19:37.977
that, uh, exists, unfortunately.
Uhm, so, then, if you're going
to not, you know, just hard code

00:19:41.981,00:19:47.620
it, or use a hash function, uhm,
some people like to, you know,
use a random number generator

00:19:47.620,00:19:52.625
and there are inherent issues
with this depending on both how
you seed it and how the actual

00:19:54.627,00:19:59.632
number generator that you
choose. Uhm, so, two common ones
are "libc rand", probably all of

00:20:01.667,00:20:07.640
us have used that, and also
"Java util random", uhm. So,
yea, uh, the DES cracker that

00:20:07.640,00:20:14.046
EFF released has, uh, 56 DES,
DES has 56-bits of security and
that, right, you can run that

00:20:14.046,00:20:19.051
off of a laptop and crack DES
keys, right? So, these reduce
your key space to 32-bit seeds,

00:20:21.721,00:20:27.893
uh, seed space, uhm, or 48 and
that's almost child's play.
Like, I, I could crack this

00:20:27.893,00:20:32.898
stuff on a raspberry pi, right?
Like this is a joke almost. Uhm,
and so that's a poor random

00:20:35.401,00:20:40.406
number generator choice assuming
that you have truly, like you
know, perfect seeding of your

00:20:40.406,00:20:46.545
random number generator. Uhm,
but what if you used, uh, uh,
you know, secure random number

00:20:46.545,00:20:52.685
generator but then your, you go
to seed and, uh, yea, we've seen
developers use timestamps in

00:20:52.685,00:20:59.158
their seeds - easily guessable,
uhm, and then that allows as to,
you know, can just guess the

00:20:59.158,00:21:04.096
time they created or generated
the key and then you're, you can
start guessing keys. Uhm, so

00:21:07.366,00:21:12.371
both of those things are not
very ideal, uhm, so, yea we've
seen all of these different

00:21:14.907,00:21:19.912
problems and how we've, uh, have
these techniques to bypass what
developers are doing with, with,

00:21:22.448,00:21:27.453
uh, their encryption. Uhm, so
there's ways that we optimize a,
uh, basically key-cracker for

00:21:29.922,00:21:36.796
this and we can abuse, uh, a lot
of different techniques to make
this insanely fast. Uhm, so, one

00:21:36.796,00:21:43.636
thing we can do is use
parallelization, uhm, obviously,
you know, if you wanna write up

00:21:43.636,00:21:49.175
any form of brute forcing,
you're gonna have to parallelize
your workload. Uhm, but we can

00:21:49.175,00:21:55.047
actually parallelize in multiple
ways here, uhm, so we're trying,
right, a bunch of keys, you can,

00:21:55.047,00:22:01.687
you know, do all of those in
parallel against your ciphertext
but you can also, uh, uhm, AES

00:22:01.687,00:22:08.394
itself in certain modes, uhm,
block modes, are, is
parallelizable within the actual

00:22:08.394,00:22:13.399
operation that you're doing,
uhm, so, we saw that ECB had all
those, like no, uh, it wasn't

00:22:13.399,00:22:18.404
like streamed together and that
means that we can even
parallelize there. Uhm, so that

00:22:21.106,00:22:26.111
leads to massive speed up, uhm,
and also, for, uh, block, these
block modes, you can also

00:22:30.549,00:22:35.554
introduce this techniques where,
right, we're, we're looking for
checking things we know to be

00:22:35.554,00:22:40.559
there to validate whether our
key guess is correct and for
something like PKCS padding,

00:22:43.462,00:22:48.667
uhm, that padding is only on the
last block. So, if we had like a
40 block message, I can throw

00:22:48.667,00:22:54.173
away 39 of those blocks and just
decrypt the last block in these
certain modes and I can check

00:22:54.173,00:22:59.044
the padding. Uhm, and then if it
ends up being, you know, an
interesting result, then you can

00:22:59.044,00:23:05.384
go back and decrypt it fully,
uhm. But for the purpose of just
finding our, our, keys that are

00:23:05.384,00:23:10.723
probable real keys that the
developer used, uh, you can use
that, uh. And we can see that

00:23:10.723,00:23:12.725
here - CBC itself is actually,
you're able to do this, uhm,
last block decryption cause you

00:23:12.725,00:23:14.727
just need, uh, right, the last
block of the ciphertext, your
guess key and then you can see

00:23:14.727,00:23:16.729
at the end we're XORing the
second to last ciphertext, uh,
block, into that decrypted

00:23:16.729,00:23:18.731
result. Uhm, so that cuts out
the whole rest of the chain
before, uhm, and ECB mode, yeah,

00:23:18.731,00:23:20.733
it's, there's no. Nothing
complicated about just doing the
last block there. Uhm, another

00:23:20.733,00:23:22.735
optimisation we can do for our
tool is "early exit". So, these
are just the block modes for a

00:23:22.735,00:23:24.737
stream, or for a symmetric
cipher. But there can be, uh,
basic streaming modes, uh,

00:23:24.737,00:23:26.739
basically that don't allow us to
do that last block decryption.
Uhm, but with this we can do an

00:23:26.739,00:23:33.145
early exit, right? So, uh, if we
know we're looking for ASCII,
we're know, we know we're

00:23:33.145,00:23:38.150
looking for, uh, say, JSON, uh,
we can exit early once we don't
satisfy any of our parameters.

00:23:40.653,00:23:45.658
So, we're basically doing block
by block until something is
invalid - just throw it away and

00:24:21.093,00:24:26.098
continue on cracking with the
next, uh, key. And, uhm, yea,
another thing we can do that's,

00:24:29.201,00:24:35.441
uh, that's pretty interesting is
AES uses, uh, it has internally
the block cipher has many

00:24:35.441,00:24:40.980
different rounds and it has the
sub-keys that it derives from
your guessed key. So, if you

00:24:40.980,00:24:47.152
were to pre-compute all of these
sub-keys, uhm, it's possible,
you know like that you can save

00:24:47.152,00:24:52.157
on space, performance etcetera
by pre-computing. Uhm, and so,
for optimization, right, we're

00:24:54.660,00:25:01.467
running this basically to run as
fast as possible. Uhm, so,
there's a lot of different

00:25:01.467,00:25:06.472
choices of hardware. Uh,
basically - CPU, GPU, FPGA,
ASICs; where do we start really?

00:25:09.441,00:25:14.446
So, with CPUs, uhm, they're,
they're good, uhm, they support
SIMD instructions, uh, which

00:25:17.583,00:25:22.588
basically allows your to handle
more data than you normally
would, but, uhm, for AES it's

00:25:25.391,00:25:30.195
unfortunate SIMD instructions
don't actually apply, uh, cause
AES is a little bit longer than

00:25:30.195,00:25:34.433
those instructions that the data
internally is a little bit
longer than those instructions.

00:25:34.433,00:25:39.438
Uhm, so, CPUs can definitely do
it, uhm, but, yeah, we'll, I'll
get back to CPUs later. Uhm, and

00:25:42.908,00:25:47.146
then, so, graphics cards!
Everybody know's graphics cards
for pass, for password cracking,

00:25:47.146,00:25:52.985
hash cracking, all of this stuff
- yes, they are really fast for
that and highly parallelizable.

00:25:52.985,00:25:57.990
And, uhm, and they have that
great advantage but, uhm, that's
kind of then back and forth

00:26:00.058,00:26:05.063
which is better CPU or GPU? So,
I will settle that debate, after
I explain FGPAs and ASICs, uhm,

00:26:07.466,00:26:12.471
so, FPGAs, we looked into it,
uhm, and basically, uh, you can
program your FPGA to basically

00:26:15.240,00:26:22.181
to like, at the gate level
you're programming it, uh, like,
uh, yea. You're programming

00:26:22.181,00:26:26.952
gates and then you can create
specialized hardware, where
whereas, you know, CPUs you're

00:26:26.952,00:26:31.690
running actual instructions.
Where here we could have
specialized logic that is at the

00:26:31.690,00:26:37.129
gate level. And then, obviously,
ASICs, I mean, it's the fastest
you can get, you can manufacture

00:26:37.129,00:26:44.002
a chip that is dedicated just to
doing this, uh, decryption, uhm,
but, we don't have that kind of

00:26:44.002,00:26:49.007
money or time yet. Uhm, so, it
was kind of interesting to
choose but there's a twist,

00:26:51.510,00:26:56.515
right? I, I was holding off on
the CPU versus GPU debate
because actually in 2008, Intel

00:26:58.550,00:27:05.123
introduced dedicated AES
instructions, hm, and so,
basically, right, where SIMD

00:27:05.123,00:27:10.128
wasn't quite enough to, to
support AES very quickly at
hardware level, uhm, AES-NI, uh,

00:27:12.464,00:27:18.837
basically is specialized
hardware in probably most of
your CPUs that does this very

00:27:18.837,00:27:23.842
common encryption incredibly
fast. Uhm, and, it's great for
parallelizable workloads and

00:27:27.779,00:27:33.552
that's exactly what we have.
Uhm, and so, we can basically
just flood our AES-NI

00:27:33.552,00:27:38.557
instructions and just, just go
all out into this and crack
insanely fast, uhm, and GPUs are

00:27:42.628,00:27:47.900
still valid, uhm, if you have a
password cracking rig or know
someone who does, they're still

00:27:47.900,00:27:52.905
valid for this. But in this case
AES-NI is such a wide-spread
thing, uhm, that it's, it's

00:27:56.241,00:28:01.847
perfect for this application.
Uhm, so, we can see some
benchmarks here, basically we

00:28:01.847,00:28:08.287
can see with the 8 cores, uhm,
it's, uhm, beating out the GPU
at higher ends. Somehow, so,

00:28:08.287,00:28:15.260
like, somehow, an 8-core CPU is
destroying this GPU, uhm, and
so, in this test, uh, this was

00:28:15.260,00:28:20.299
not done by us, but in this
test, uhm, basically, there's
also the consideration of price

00:28:20.299,00:28:25.304
when you're building these. And
the GPU is before the sale and
after the sale, uhm, more

00:28:28.507,00:28:33.512
expensive than the CPU that they
used. Uhm, so, CPUs, are way
more cost effective for this and

00:28:37.583,00:28:41.453
actually, there's... [indistinct
talking] Yea, and the GPUs
actually refurbished too, so,

00:28:41.453,00:28:48.026
and the CPU was new, in this
case. Uhm, so, CPUs are
definitely the best in terms of

00:28:48.026,00:28:53.031
cost effectiveness and, uh, and
so then there's this - the
Atomic Pi - which has a CPU with

00:28:55.901,00:29:01.673
AES-NI and it's 50 bucks. So,
theoretically you could just rig
like as many of these as you

00:29:01.673,00:29:07.646
want together, create a
computing cluster and just
deploy, uh, like basically run

00:29:07.646,00:29:12.651
all of those AES-NI instructions
across all of those relatively
cheap devices. Uhm, so yea,

00:29:15.387,00:29:20.392
AES-NI provides good speedup,
uh, but, uh, we need to utilize
it effectively and we can do

00:29:27.032,00:29:32.037
that with our tool. Yea.. >>I
know the slide says
"Limitations", uhm, and as I was

00:29:36.742,00:29:42.514
writing it, it really should
have been "limitation". Uhm,
but, the great news is that as I

00:29:42.514,00:29:46.585
was writing this and having
conversations with people about
this and doing dry runs with,

00:29:46.585,00:29:52.057
uh, friends and colleagues and
and and what not, uhm, what I
came to realize is that this

00:29:52.057,00:29:56.595
wasn't actually that big a
limitation. So, this is, this
slide is a bit of a misnomer,

00:29:56.595,00:30:03.468
uh, from the get go. So, this is
a limitation, uhm, one thing
that, uh, because we are talking

00:30:03.468,00:30:07.673
about the real world. We do need
to take real-world, uh, uh,
design choices into

00:30:07.673,00:30:11.543
consideration. Something that
developers who don't really
understand cryptography, which

00:30:11.543,00:30:16.548
is most of them, let's be f...
let's be honest. Uhm, what they
will do is take the IV and say

00:30:19.317,00:30:23.588
"I don't know what to do with
this". Uh, they'll look at the
documentation and say, uh, it

00:30:23.588,00:30:28.593
needs to be, they say "This
needs to be a random, uh, value
of 16 bytes", or whatever it is.

00:30:31.930,00:30:38.336
So, they will choose a random
value and then hardcode it and
use it for every single

00:30:38.336,00:30:43.341
operation. Uhm, which is not how
an IV is supposed to used, uh,
to be used. It's supposed to be

00:30:43.341,00:30:49.281
different per operation but
what's really common is the
developer doesn't understand

00:30:49.281,00:30:54.820
what an IV is for, they just
know it's of some value and so
they will pick a random value

00:30:54.820,00:30:59.524
and keep it secret because
normally, your, you know, if you
don't understand cryptography

00:30:59.524,00:31:03.729
you're thinking "Well, I have to
keep the key secret, I probably
have to keep this secret too."

00:31:03.729,00:31:08.734
So, they just have these two
different hard-coded values and
so if you have a single block of

00:31:11.236,00:31:16.241
ciphertext in CBC mode and you
have your IV kept secret, the
best that you can get without

00:31:18.643,00:31:23.648
the IV, you know, even guessing
keys, is a value that is the
real plain text of the message

00:31:27.319,00:31:33.959
XOR-ed with the initialization
vector. Uhm, and this basically
boils down to the one-time pad

00:31:33.959,00:31:38.830
problem. As long as you've
chosen your IV correctly,
there's really no information

00:31:38.830,00:31:45.670
you can get with this. There's
nowhere you can go from here,
but because developers generally

00:31:45.670,00:31:50.675
choose a single fixed IV and
keep it secret, if we can get
more than one message, uh, we

00:31:53.411,00:31:58.416
can do something with this. This
is, you know, uh, CBC
decryption. Uh, enhance! Uhm,

00:32:01.119,00:32:06.525
and so, when we look at the
first block, the decryption
starts out with a block cipher

00:32:06.525,00:32:13.498
operation in decrypt mode. And
continues on with an XOR
unmasking step. So, we take

00:32:13.498,00:32:18.503
this, sort of, halfway decrypted
lock and we XOR it, uhm, and we
get to about here. So, ue have,

00:32:21.473,00:32:26.478
you know, we have the IV XOR
with the plaintext. Now, if we
have two or more ciphertexts

00:32:30.715,00:32:35.720
that are using the same IV and
they're single block messages
and they had this limitation,

00:32:37.756,00:32:42.527
uhm, we can actually do
something here. So, all
printable ASCII characters start

00:32:42.527,00:32:47.532
with the bit 0, so, we know that
the first byte of a message is
always data. Uh, anything after

00:32:50.902,00:32:56.875
that could be data, could be
padding, up to the last byte.
So, we can look at the first bit

00:32:56.875,00:33:01.813
of the, uh, the first byte and
it shouldn't change between
messages because the IV is

00:33:05.083,00:33:09.254
always going to be the same so
the first bit of the IV is
always going to be the same and

00:33:09.254,00:33:15.994
so we have something that is 0
XORed with the first bit of the
IV. In the case that we're

00:33:15.994,00:33:21.533
dealing with printable data
which is a, a generally strong
assumption to make. Uhm, so, we

00:33:21.533,00:33:23.535
know that if that first bit
changes between encrypted
messages, uh, between, sort of,

00:33:23.535,00:33:25.537
"half-decrypted messages" we'll
call them, with any given key,
we know that is not the correct

00:33:25.537,00:33:27.539
key. Because we can make the
strong assumption that that
first bit is always going to be

00:33:27.539,00:33:30.609
a 0. And whether that's flipped
or not because, because of the
first bit of the IV, it's always

00:33:30.609,00:33:34.546
going to be the same. So, the
other thing that we know is that
the last byte of the message can

00:33:34.546,00:33:37.215
only, can only be, be between
certain values. And, uh, if
we're dealing with an 8-byte

00:33:37.215,00:33:40.385
block cipher, the largest value
that we can have is 8. If we're
dealing with a 16 byte block

00:33:40.385,00:33:43.555
cipher, uh, the largest value
that we can have is 16. So, for,
uh, for any given message we

00:33:43.555,00:33:48.560
know that the last byte is
always going to be padding and
therefore will always be at

00:33:53.031,00:33:58.036
maximum 16, or 8, depending on
what we're dealing with. So, for
a 16-byte block cipher, an 8, a

00:34:05.310,00:34:12.017
128-bit block cipher like AES,
we know that the first three
bits are always going to be

00:34:12.017,00:34:17.022
zeros. So, we can check the
last, the first three bits of
the last byte of any given

00:34:32.504,00:34:37.509
message and be, uh, and throw
out any key that doesn't produce
the same first three bits in the

00:34:40.312,00:34:45.317
last byte. Uhm, so, that's
pretty rad. Uhm, we can also,
because we're assuming ASCII

00:34:49.821,00:34:54.826
printable data, and, either no
byte or PKCS7-style padding, we
can assume that every single

00:34:57.996,00:35:02.934
byte is going to start with 0 -
whether it's a padding byte, or
a data byte. Now, for a 64-bit

00:35:05.403,00:35:10.408
block ciphers, this means we get
7 bits of data at the, one at
the start of each byte that

00:35:13.144,00:35:18.650
isn't the last, that we can
reliably say, should be the same
across all messages. And for the

00:35:18.650,00:35:24.723
last byte, we can say, we get,
uh, four bits, because the
maximum value is 8. So, it

00:35:24.723,00:35:30.228
should start with "0, 0, 0, 0" -
regardless of the value of the
padding byte at the end. That

00:35:30.228,00:35:36.968
gives us 11 bits. And what this
means is, we have 2, 2 to the 11
times "n", uh, uh,

00:35:36.968,00:35:40.305
possibilities. Uhm, and only one
of those possibilities is a
false positive. So, for two

00:35:40.305,00:35:45.310
samples that's a false positive
chance of 1 in about 4-million,
uh, and in, with three samples

00:35:48.079,00:35:53.084
that's about 8 point 5 billion,
uhm, and this is, if we have
secret, fixed IV, single block

00:36:00.025,00:36:04.763
CBC ciphertext, which is, you
know, not always the situation
we're going to end up in anyway.

00:36:04.763,00:36:10.568
But we can deal with this and
it, as it turns out, if we just
have two samples, we already

00:36:10.568,00:36:15.573
have an incredibly practical
attack, still. And for 16, for
128-bit block ciphers it gets

00:36:18.143,00:36:23.148
even better. At 2 samples we
have a 68 point 7, uh, uh, 1 in
68 point 7 billion false

00:36:27.652,00:36:32.657
positive chance which is
insanely practical. Uhm, and so,
once we get to 3 samples, I'm

00:36:34.726,00:36:38.563
not even gonna bother trying to
like read that number aloud,
cause that's you know,

00:36:38.563,00:36:43.568
phenomenally good chance. So,
let's talk about the tool. [mic
noise] >>Alright, so, basically,

00:36:48.106,00:36:54.412
we wanted to actually make this
practical, uhm, so we had to
show, build a tool to show it's

00:36:54.412,00:36:59.417
legit. Uhm, so we came up with
"AESBurst", uhm, yeah. So,
basically, right now, it just

00:37:01.352,00:37:07.759
sports ECB, CBC and CTR modes,
uhm, and it has a couple of
those optimizations that I was

00:37:07.759,00:37:12.764
talking about. Uhm, it does use
AES-NI currently. And it's fully
multi-threaded and so, basically

00:37:18.203,00:37:23.575
what you can do with the tool,
is you, you find, uh, some sort
of encryption scheme that's

00:37:23.575,00:37:30.014
vulnerable to what we've talked
about and you can use your own
wordlist, whatever you want,

00:37:30.014,00:37:36.254
uhm, and we provide a conversion
tool. The wordlist will use
different approaches to convert

00:37:36.254,00:37:41.259
that, uh, wordlist into, uh,
possible keys, uhm, and then,
uh, you can run it. And we get

00:37:45.830,00:37:50.835
some very good, uh, performance
out of this, uhm, the blue here
is, uhm, is, uh, our first

00:37:55.573,00:38:01.846
implementation which was in
Python, uhm and, it, you know,
it was a single thread,

00:38:01.846,00:38:06.851
performed well and we're getting
like 125, uh, uh, thousand uh,
keys per second. So, pretty

00:38:11.055,00:38:16.060
decent. And the multi-threaded
one that I produced, uhm, was,
uh, basically double the speed,

00:38:18.530,00:38:23.535
so, we're getting amazing, uh,
performance optimization here
and the thing about this is,

00:38:26.905,00:38:33.545
it's all running off of just a
laptop. Uhm, so I'm getting,
about like 250-thousand keys per

00:38:33.545,00:38:40.018
second off a single laptop, you
know. Uhm, and you can imagine
how this will be in a computing

00:38:40.018,00:38:45.023
cluster made up of all of those
Atomic-Pis, I was showing you
earlier. Uhm, so and, and yea,

00:38:47.458,00:38:53.398
that was for ECB mode. CBC mode
- very similar results, uhm,
because of the optimizations

00:38:53.398,00:38:58.503
like last block decryption and
all of that, we get very
similar, similar results to EBC

00:38:58.503,00:39:03.441
from more complex thing like
CBC. Uhm, yea, so,
unfortunately, no demo today.

00:39:06.444,00:39:11.449
I'm sorry, uh, but yea. Future
work. >>So, uhm, the,
unfortunately we had, uh, some

00:39:19.057,00:39:24.062
AV issues that prevent us from
showing it to, but the code is
available, uhm, we probably,

00:39:26.231,00:39:32.070
uh... What, can you, can you
give everybody the URL where you
can get the tool? >>Uhm, so it

00:39:32.070,00:39:38.643
will be on my GitHub - ghostpep
- uhm, and the tool is AESBurst.
So, you should be able to find

00:39:38.643,00:39:43.648
it, just by typing AESBurst into
GitHub and, yea. >>So, we talked
a lot about, uh, about, uhm,

00:39:49.120,00:39:54.125
various techniques that we, we,
uh, can use to do practical
key-cracking attacks. Uhm, but

00:39:56.694,00:40:01.699
not every one of them is built
into AESBurst, uhm, so the
plaintext scoring, the, uh,

00:40:04.168,00:40:09.941
that, that could be used to sort
the result - and it isn't
currently. Uhm, we can add more

00:40:09.941,00:40:16.781
key derivation methods, uhm,
currently we only support only a
few of them. Uhm, we can, uh,

00:40:16.781,00:40:21.419
you know, as I, as I mentioned
tin hat limitation section -
late on was when I realized this

00:40:21.419,00:40:27.892
technique could work. So, uh,
that's not in there. Uhm, we
could add distributive computing

00:40:27.892,00:40:31.729
support possibly, via
Kubernetes. Uh, so we can just
tie a bunch of existing

00:40:31.729,00:40:36.734
computers, uh, uh, together.
Uhm, we could, you know, throw a
bunch of Atomic Pis together and

00:40:39.270,00:40:45.076
create the cracking cluster that
we, we talked about. Uhm, I
think that, that the final word

00:40:45.076,00:40:50.081
is not necessarily out on GPUs
versus CPUs because at some
point there might be a workload

00:40:53.284,00:40:58.289
large enough - and so, uh, so to
be massively parallel, uh,
parallelizable, uh, such that we

00:41:00.558,00:41:05.563
might be able to get slightly
more, uh, performance out of GPU
vs CPU. But we get so much great

00:41:08.499,00:41:13.805
performance out the average CPU.
And this is across Intel, uh,
CPUs, AME CPUs, you know, like,

00:41:13.805,00:41:18.042
if it's, if it's in your laptop
and you've got your laptop with
you right now - I would bet, uh,

00:41:18.042,00:41:23.047
that your laptop probably
supports the AES-NI instruction
set. Uhm, right now, we only

00:41:27.852,00:41:32.857
support AES-128. Uh, AES-NI
instructions support AES-128 and
256, uhm, but we can also, like,

00:41:37.795,00:41:42.333
this, this technique is not
specific to AES, it, it, our
techniques that we presented

00:41:42.333,00:41:47.472
today should work with any block
ciph, cipher or stream cipher.
Uh, it is a, a

00:41:47.472,00:41:51.943
algorithm-independent set of
techniques. Uhm, we'd love to
work with established pass,

00:41:51.943,00:41:53.945
password cracking groups like,
uh, KoreLogic, or HashCat, or
who, who ever really wants to

00:41:53.945,00:41:58.950
works with us to honest. Uhm,
because, you know, it's one
thing to produce a tool that

00:42:07.325,00:42:12.330
implements this, and it's
another to produce work for some
group that already has wide

00:42:14.365,00:42:19.003
adoption - where they can just
roll out an update and suddenly
your favourite password cracking

00:42:19.003,00:42:25.843
tool can do AES-key cracking or
whatever else as well. Uhm, and
if something that they're not

00:42:25.843,00:42:31.983
currently doing today. Uhm, we
can also add support for AEAD
cipher modes - so, this is

00:42:31.983,00:42:37.054
something when you get the
correct key, you know it because
you already have, uhm, sort of

00:42:37.054,00:42:43.828
an, an authentication, uh, built
into your cipher mode. So, that
is another way we didn't even

00:42:43.828,00:42:49.934
discuss that you can validate
your key guesses. So, but we're
not doing that currently. So,

00:42:49.934,00:42:54.539
there's a lot of room for future
work here, and this is sort of,
uh, where we wanna call

00:42:54.539,00:43:00.378
everybody to action. Like, this
is obviously, we've shown, we've
done the calculations, it's an

00:43:00.378,00:43:07.218
incredibly practical attack.
We've built a practical tool
that implements this on a basic

00:43:07.218,00:43:12.223
level and it still works. We've,
you know, uh, uhm, this, this,
this is a practical technique.

00:43:14.592,00:43:19.597
And now what we would love to
see is for you to take this and
run with it. To go as far as,

00:43:23.401,00:43:29.240
you know, the hash cracking
community has gone with password
hash, uh, cracking, and do the

00:43:29.240,00:43:34.412
same with encryption keys. And
that's, that's really what I,
personally, hope to see. And I

00:43:34.412,00:43:41.052
think I speak for the, the other
Daniel as well. [indistinct
talking] Yea, so, confirmation,

00:43:41.052,00:43:47.325
we have confirmation. And, uh,
I'm, I'm sorry but I haven't
been able to see if we are, uh,

00:43:47.325,00:43:52.597
good on 5 minutes? Okay, thank
you, I can finally see you.
[chuckle] The lights are

00:43:52.597,00:43:56.801
fantastic, but, you know, a
little blinding. So, at this
point we would like to open it

00:43:56.801,00:44:01.739
up to questions. Uhm, does
anybody have? Does anybody have
questions? I see, I see somebody

00:44:05.576,00:44:10.581
raising their hand back there.
Uh, do we have microphones for
questions or? We? Okay. Uhm, can

00:44:14.151,00:44:19.156
you just shout your question
really loud and then I'll repeat
it into the mic for the

00:44:35.039,00:44:41.312
recording? [off-mic question]
So, uhm, the question is, uhm,
one of the, the, the big things

00:44:41.312,00:44:47.885
that we've done here is, uh,
validate the padding on block
ciphers to check whether or not

00:44:47.885,00:44:52.890
we've got the correct key. Uh,
and do we, uh, is there a
padding method that has been

00:44:56.260,00:45:02.266
standardized that, uh,
randomizes the padding? So,
there is. There is a padding

00:45:02.266,00:45:09.006
scheme which is referred to as
like a ciphertext stealing
padding scheme which, so, for

00:45:09.006,00:45:15.179
instance in CBC mode, uhm, you
take whatever the ciphertext is
of the second to last block and

00:45:15.179,00:45:20.184
you use bytes from that, uh,
after a fixed byte, to say, you
know, "Here's the, you know,

00:45:22.420,00:45:27.425
here's the, uhm, here's the, uh,
here's the bytes". Now, while
this does prevent against

00:45:30.561,00:45:36.968
certain attacks like padding
oracle attacks. This does not
actually make a meaningful

00:45:36.968,00:45:42.873
difference for our attack,
because any padding scheme that
you can validate which really

00:45:42.873,00:45:49.013
should be all of them, based on
what padding is used for, uhm,
we can validate it. So, you

00:45:49.013,00:45:53.818
know, even if you're, uhm, even
if you're stealing ciphertext
from the second to last block,

00:45:53.818,00:45:58.656
uhm, it needs to be something
that you can validate during
decryption. So, we will by

00:45:58.656,00:46:03.027
design always be able to use
this, regardless of the padding
scheme, unless it's a really

00:46:03.027,00:46:08.032
s**t padding scheme. So, great
question, thank you. Are, are
there other questions? Go ahead.

00:46:10.868,00:46:15.873
[off-mic question] So, our, our
results in benchmarking, uh, was
actually, I'll, I'll give this

00:46:20.611,00:46:25.616
to Daniel since he was the one
who did the coding in the
benchmarking. >>Oh, uh. >>Repeat

00:46:33.357,00:46:38.362
the question. >>Yea, uhm, so,
the question is basically, uh,
for hard limits on like the

00:46:42.800,00:46:47.805
multi-threaded, uh, version, and
basically saw that it was
linear, uhm, so in this case

00:46:50.141,00:46:55.913
linear is, as far as, as far as
complexity - time complexity of
the, of what we're doing - it,

00:46:55.913,00:47:00.751
linear is the best case, right?
Anything other than that would
just be wasteful, uhm, and you

00:47:00.751,00:47:06.057
can't go below linear if you're
doing, you know, "n" keys
against one ciphertext, that's

00:47:06.057,00:47:12.063
you know, a little venn. Uhm,
so, we want linnear it's just
can we, can we get it faster

00:47:12.063,00:47:18.869
and, you know, changing it from
"Oh, you can decrypt this,
single-threaded in, in a week,

00:47:18.869,00:47:23.874
versus can you do it in, in a
weekend?". Right, uhm. [off-mic
question] Yes. [off-mic

00:47:32.683,00:47:39.256
question] Yes, so that was on 4,
a 4-core and in that case, so,
AES-NI is actually, uh, on its

00:47:39.256,00:47:44.261
own dial on your CPU. So, then
your limited by what you're CPU
technically has. Uhm, in this

00:47:46.530,00:47:53.304
case, on the test machine it
was, uh, four, I was able to run
four at a, at a time. Uhm, so

00:47:53.304,00:47:57.108
you're limited not by
necessarily your cores. You're
actually limited by the AES

00:47:57.108,00:48:03.714
hardware that you have. Uhm,
which is why the, uh, Atomic Pis
are so interesting is because

00:48:03.714,00:48:09.453
yeah, the CPU itself, right, at
from a traditional standpoint -
pretty c**p. But, it's, it's

00:48:09.453,00:48:14.458
fifty dollars, right? But it has
the exact same AES-NI
instruction and for, for us

00:48:16.494,00:48:22.366
that's already our, our
bottleneck. So, that's why those
are so attractive really.

00:48:22.366,00:48:27.371
Because it's mega cheap for a
specific part of that CPU that's
we're targeting. >>Right, okay.

00:48:33.244,00:48:39.483
It looks like we're out of time.
So, uh, if you have additional
questions, uh, do we have, uh,

00:48:39.483,00:48:44.655
sorry do we have like a, an
after room? We do not have an
after room. Okay, uh, find our

00:48:44.655,00:48:49.794
attractive, beautiful faces that
are unmistakable and ask us any
questions that you might have

00:48:49.794,00:48:55.266
that you are not able to, later
on. Uhm, we will be around the
conference. So, uh, thank you

00:48:55.266,00:49:00.204
for coming. Uh... [cheering]
[applause] Have a good DefCon!

