00:00:00.133,00:00:05.138
>>Alright. Thank you guys, for
coming and spending this fine
Sunday afternoon with me. I'm

00:00:08.609,00:00:14.815
going to guide you on an
experience of 50 slides, three
videos and one tool. Today,

00:00:14.815,00:00:18.819
we're talking about something
called Firmware Slap. It's
something that I've spent the

00:00:18.819,00:00:25.058
last year and a half working on.
Its a combination of concolic
analysis, and semi supervised

00:00:25.058,00:00:30.063
firmware function clustering,
yugh, uh, that in the end
produces a series of explor uh,

00:00:33.133,00:00:38.138
of vulnerabilities that we know
are exploitable. So my name is
Christopher Roberts. I'm a

00:00:43.377,00:00:50.317
researcher and engineer at Red
Lattice. I am a CTF player, in
George Mason's Competitive Cyber

00:00:50.317,00:00:56.857
Club. And in general, I'm pretty
interested in finding bugs. I
like learning about program

00:00:56.857,00:01:03.297
analysis frameworks. And I like
trying to stitch the two
together whenever I get the

00:01:03.297,00:01:08.235
chance. And so for this talk,
we're going to talk a little bit
about exploitable bugs. Just,

00:01:08.235,00:01:14.608
just or real quick background on
what they are, and a little bit
of the uh more recent history,

00:01:14.608,00:01:19.413
to kind of set the framework for
what we're going to be talking
about today. A couple years ago,

00:01:19.413,00:01:24.418
here, there was something called
the DARPA Cyber Grand Challenge.
It’s a combination of these

00:01:27.554,00:01:32.559
automated cyber reasoning
systems, that were designed and
tasked with finding exploitable

00:01:34.761,00:01:39.766
bugs in binaries, writing
exploits and throwing those
exploits, and on top of that,

00:01:41.902,00:01:46.573
once it found those
vulnerabilities, they were also
tasked with patching them.

00:01:46.573,00:01:53.480
That’s a tall order. And,
unfortunately, they, those
systems were not quite at a

00:01:53.480,00:01:59.453
point where they could analyse
real world systems. Made a
couple things competing against

00:01:59.453,00:02:04.391
them today. They have a series
of mitigations and protections
that you as developers employ

00:02:08.362,00:02:13.934
everyday. You have source code
level protections through things
like static analyzers, using

00:02:13.934,00:02:18.405
like uh, Clang and LLVM. You
have your compile time
protections that's offered by

00:02:18.405,00:02:23.243
your compiler. You have your
non-executable stack, your stack
canaries, making your uh,

00:02:23.243,00:02:28.849
relocation offsets read only.
You have a, a whole nother
option that doesn't even let you

00:02:28.849,00:02:33.854
use a number of uh, very,
vulnerable uh, functions. And
finally, if all this fails, you

00:02:35.956,00:02:41.595
have your operating system to
lean on just a little bit with
something called a SLR. And so,

00:02:41.595,00:02:45.832
fortunately, we have all of
these protections and so none of
these automated reasoning

00:02:45.832,00:02:50.837
systems can exploit us at all.
Oh, except in the embedded case.
We've got a couple things that

00:02:54.041,00:03:00.714
we're uh, we're missing. We've
uh, you can use static
analyzers, sometimes you might

00:03:00.714,00:03:05.719
have a non-executable stack, but
all in all, you're really
missing all of those big things

00:03:07.921,00:03:13.794
that make it hard to exploit
vulnerabilities, um, and I'm
coming to you with backed up

00:03:13.794,00:03:19.199
information, I went on Amazon,
this is right during Prime Day,
and I typed in router. These are

00:03:19.199,00:03:25.172
the top five, most sold routers.
And, if we know that they have
none of these exploit

00:03:25.172,00:03:30.243
mitigations, obviously, this is
just a show of confidence.
They're telling us, that these

00:03:30.243,00:03:36.817
things are coded to perfection.
That there is no possible way to
exploit them. And so you don't

00:03:36.817,00:03:41.822
need a way to mitigate exploits,
right? It's really bad. There's
almost no exploit mitigations on

00:03:46.426,00:03:51.431
these top five routers. So, our
very first demo, we're going to
talk about something called The

00:03:53.834,00:03:59.473
Almond 3. It's this smart home
device that can hook up into
your network. They can act as a

00:03:59.473,00:04:04.878
gateway. Connect as a router. It
can hook up into your home
security system, set off alarms.

00:04:04.878,00:04:09.282
It can tell you what the weather
is. It can do everything and
it's got a touch screen. And so

00:04:09.282,00:04:14.287
this first video is going to be
uh, finding a couple bugs in it.
[Laughter and applause] Alright,

00:04:21.328,00:04:26.333
where’s the full screen button?
Ah, right here. Alright, so
here, we have got this device on

00:04:40.780,00:04:46.286
the network and browse to it and
on our left, we can see that we
can see all of our status

00:04:46.286,00:04:51.224
information. We can see where
the HTTP is, on what our
hostname is. We can see what our

00:04:51.224,00:04:55.629
IP address is. This thing's
living on my network. And I've
gone ahead and I've downloaded

00:04:55.629,00:04:59.866
the firmware online. You just
Google Almond 3 Securify
Firmware download, and you get

00:04:59.866,00:05:05.172
it right there. And I'm going to
use this little script I made
called Pone Firmware CGI against

00:05:05.172,00:05:09.776
this thing. And what this is
going to do for me, is it's
going to go in, it's going to

00:05:09.776,00:05:15.282
extract out the file system,
it's going to extract out all of
our shared objects, and it's

00:05:15.282,00:05:21.354
going to go in and iterate over
every single binary in this
firmware. It's going to recover

00:05:21.354,00:05:27.527
a series of function prototypes,
it’s going to recover hundreds
of these. It's going to build a

00:05:27.527,00:05:34.067
set of analysis tasks that we
can run in parallel, that's
using a system called Angr, and

00:05:34.067,00:05:39.372
we're analysing those individual
tasks as individual functions
for vulnerabilities. We're

00:05:39.372,00:05:44.377
looking for memory corruption.
We're looking for command
injections and finally, this

00:05:46.379,00:05:51.384
tool, is going to take that
information and it's going to
set it into a templated Python

00:05:54.287,00:05:58.825
script that I have, that just
sends data to a web server. So
we're using information

00:05:58.825,00:06:05.632
recovered from that function
prototype, we're grabbing uh,
information that takes us to

00:06:05.632,00:06:10.637
that exact URL on this firmware,
and we're generating the
exploit. And so here, we've got

00:06:15.508,00:06:20.680
a whole bunch of fun colours
that just tell us that it's
found an exploit and it's

00:06:20.680,00:06:25.685
writing those to these files.
And so, here in a second, we're
going to see that I have 2

00:06:29.189,00:06:34.194
Python files that were generated
automatically from Firmware
Slap. And, so, the very first

00:06:36.463,00:06:41.301
thing that I like to do is I, I
like to see if Telnet’s open.
I'm gonna see if uh Telnet’s

00:06:41.301,00:06:46.940
opened my very favourite port 1,
2, 3, 4, 5, um, and, ah man,
unfortunately, Telnet is not

00:06:46.940,00:06:50.443
open. I don't just get my free
backdoor. So we're going to go
in and we're going to open it up

00:06:50.443,00:06:55.682
ourselves, using these
automatically generated
exploits. I'm going to go in,

00:06:55.682,00:07:00.854
I'm going to launch my Telnet
Damon. I'm going to tell it to
listen on port 1, 2, 3, 4, 5,

00:07:00.854,00:07:06.059
without credentials. I'm going
to run this exploit across the
network. I still have to provide

00:07:06.059,00:07:11.064
the IP address. And then
finally, we're going to connect
in. [Applause] And it runs

00:07:14.100,00:07:19.105
everything as route [applause].
That video had some segments
sped up at two times speed. We

00:07:28.581,00:07:33.586
took the uh, demo time from five
minutes to three minutes.
Alright, so, concolic analysis

00:07:46.232,00:07:51.471
has been a talk, it's been
talked about a whole bunch. I'm
going to give you the 5000 mile

00:07:51.471,00:07:57.344
high view on what it is. In
essence, a combined something
called Symbolic analysis with

00:07:57.344,00:08:02.982
Concrete analysis. And a kind of
way to visualise this in your
head is, it's representing a

00:08:02.982,00:08:07.987
program as a set of equations.
Each path, each possible program
state is represented as a unique

00:08:10.623,00:08:16.796
set of equations. And we can ask
really specific questions for
these uh, programs states. And

00:08:16.796,00:08:23.269
so I'm using Angr for this tool,
which is a concolic analysis
tool that was used in the third

00:08:23.269,00:08:28.975
place team in the DARPA Cyber
Grand Challenge. It's perfect
for concolic analysis, it's got

00:08:28.975,00:08:33.980
some reverse engineering
applications, and in essence, we
can tell it to do this, we have

00:08:36.683,00:08:42.655
some code over here on the left,
and we can tell it to treat a
variable as symbolic. It can be

00:08:42.655,00:08:48.828
anything ranging from what ever.
And so, as it's going through
and looking at all these

00:08:48.828,00:08:54.901
individual pieces of the
program, it's generating
constraints. It's finding each

00:08:54.901,00:09:01.641
of these program pads that print
out you did it wrong or the
other wrong. And it's created a

00:09:01.641,00:09:08.281
different set of program
constraints. And so, we're not
limited to just doing this for

00:09:08.281,00:09:14.854
some variable, where it's get
user input or make this thing
symbolic. We can represent a

00:09:14.854,00:09:20.827
whole lot more of the programs
state. We can represent
registers as symbolic. We can

00:09:20.827,00:09:25.698
represent our stacks as
symbolic. We can represent our
files, our network reads, our

00:09:25.698,00:09:30.703
environment variable reads, all
of that as symbolic. And instead
of asking, can you reach this

00:09:33.006,00:09:38.278
point of the program? You can
query for a lot more interesting
conditions. You can ask if one

00:09:38.278,00:09:43.817
of those network reads, or one
of those file reads, corrupts
the program counter? A buffer

00:09:43.817,00:09:48.822
overflow. You can ask if some of
that input taints a system
command. A command injection.

00:09:52.492,00:09:57.730
And you can also ask it, if we
can track all of our reads and
writes required to trigger that

00:09:57.730,00:10:03.937
vulnerability. Holy cow, this
thing's awesome, why isn't it
used more? Well, if you load up

00:10:03.937,00:10:08.208
a little web server, and you run
these three commands, it takes
about five minutes before you

00:10:08.208,00:10:13.213
run out of RAM [laughs]. So it
tends to fail on really big code
bases. And this web server that

00:10:16.015,00:10:21.020
I'm looking at is 200 kilobytes.
That's absolutely miniscule, for
what I just showed you at the

00:10:21.020,00:10:26.192
very beginning when we're
looking at an entire firmware
that's megabytes worth of size.

00:10:26.192,00:10:31.197
And so, we need something that
can digest this large amount of
information, more quickly and

00:10:35.168,00:10:40.173
more efficiently. And so we have
a couple of challenges before
us. We need to model more

00:10:42.275,00:10:47.614
complicated binaries. We need to
model more complicated
environments. We need to model

00:10:47.614,00:10:51.184
when there's a hardware
peripheral in a firmware that we
can't understand, or when

00:10:51.184,00:10:58.024
there's an NVRAM value we can
understand. And just for kicks,
let's also try and find binaries

00:10:58.024,00:11:04.264
and functions that are similar
to one another. So in general,
when you have these large system

00:11:04.264,00:11:09.269
services, they tend to follow a
pretty similar uh, control flow.
You start them up, they parse

00:11:12.572,00:11:16.676
some massive config file, maybe
they read some environment
variables, maybe they accept

00:11:16.676,00:11:21.681
some command line arguments um,
maybe they set up some sockets,
maybe they parse some user

00:11:21.681,00:11:27.287
input, anyways, it's a whole lot
of information. It's going to
consume all of your resources.

00:11:27.287,00:11:30.790
All of your memory. It's going
to take forever to analyse if
you're just trying to do this in

00:11:30.790,00:11:37.363
Angr. And s, I'm only interested
in that very bottom piece, where
that vulnerable code is. And

00:11:37.363,00:11:42.001
then I want to work my way back
up. So there's a really cool
technique, it's been talked

00:11:42.001,00:11:46.639
about just a couple times,
called Under Constrained
concolic analysis. I'm trying to

00:11:46.639,00:11:51.511
throw as many complicated words
at you as possible, but all it
means is we’re starting from the

00:11:51.511,00:11:56.516
bottom, and we're working our
way back up. We can tell our
analysis tasks that we don't

00:11:58.618,00:12:03.590
know what those horrible
peripherals are giving us,
information wise, we can tell

00:12:03.590,00:12:09.529
it, we don't know what NVRAM
values are being given to us. We
can also skip past a lot of that

00:12:09.529,00:12:15.435
initialization that comes from
parsing config files, from
reading environment variables,

00:12:15.435,00:12:20.907
from reading our command line
arguments, and we can jump past
that and just look at the

00:12:20.907,00:12:25.912
interesting code. We can start
down here. And when you start at
that low of a level, you can

00:12:29.215,00:12:35.922
break up each of those actions
into separate analysis tasks.
And so not only are you

00:12:35.922,00:12:41.728
analysing substantially less
code, it's going to be faster.
You can split it up and run it

00:12:41.728,00:12:47.233
in parallel. So using less
resources, and you can run it
faster if you just add more

00:12:47.233,00:12:52.238
cores, more tasks, it’s
horizontally scalable. The
challenge comes in trying to

00:12:54.340,00:13:00.546
understand and model what each
of those actions the very bottom
are. And so, our friends at NSA

00:13:00.546,00:13:06.419
released a tool recently called
Ghidra. Ghidra has the ability
to go into a given binary or a

00:13:06.419,00:13:13.326
given firmware and it can
recover a function prototype. So
this is information that we can

00:13:13.326,00:13:18.331
use, to understand what
arguments, what values, what
registers, go into a given

00:13:21.367,00:13:26.873
function, into that very bottom
piece that we want to understand
if it's vulnerable. And so we

00:13:26.873,00:13:33.246
can combine the two, we can use
Ghidra and we can use Angr
together to build these analysis

00:13:33.246,00:13:39.352
tasks, with this information we
recovered from Ghidra. Part of
what I'm releasing later is a

00:13:39.352,00:13:45.925
Ghidra plugin that goes through
a given binary and it will
iterate over every function. It

00:13:45.925,00:13:51.564
will run a D compiler on each of
those functions. And it will
dump the given function

00:13:51.564,00:13:56.569
prototype telling us what it
returns, what arguments it uses.
And so we're interested in

00:13:59.672,00:14:04.410
finding bugs and all of these
binaries. We can use Angr to
build these programs states. We

00:14:04.410,00:14:09.415
can run each analysis job in
parallel. So let's find some
more bugs. This video has

00:14:23.563,00:14:28.568
sections that are sped up at
about two times speed. So here,
I'm using, something a little

00:14:37.977,00:14:43.282
bit different. It's another
Python script I cobbled together
called Discover and Dump. I've

00:14:43.282,00:14:48.821
got a binary here that is a CGI
binary for that very same,
online security device. And it's

00:14:48.821,00:14:52.558
going to be a lot faster now
because we're looking at just a
single binary instead of the

00:14:52.558,00:14:59.198
whole firmware. We provided that
binary, to this script and
behind the scenes, it's handing

00:14:59.198,00:15:04.303
it out to Ghidra. Ghidra’s going
through, iterating over every
function, recovering this

00:15:04.303,00:15:09.642
function prototypes, it's
building, there's a program
analysis states for us, passing

00:15:09.642,00:15:15.548
those back to Angr and then
we're running our Angr analysis
tasks all in parallel. And

00:15:15.548,00:15:20.086
before I can even finish that
sentence, it's found a
vulnerability for us. So let's

00:15:20.086,00:15:25.091
dissect a little bit about what
that vulnerability is. Up here
at the top, we have a couple

00:15:32.665,00:15:37.670
arguments. We have A 0, A 1, A
2. These are the argument
registers that are provided for

00:15:40.506,00:15:47.413
this function. Our tool has gone
in and it has told us that we
have three pointers here. Three

00:15:47.413,00:15:52.418
strings, and, we have a string
at the top. We have a string in
the middle with another value

00:15:57.223,00:16:02.161
required for this and we can see
that this very first one,
correlates to that first

00:16:04.330,00:16:10.469
argument being passed into our
function. We also have a series
of tainted memory values. So

00:16:10.469,00:16:17.343
these are all the instructions
in the program, that took that
information, that user provided

00:16:17.343,00:16:22.348
input, and touched it in memory,
concatanated it together or did
some sort of operation that

00:16:25.852,00:16:32.325
eventually made its way down
into a system call. This
information, this user provided

00:16:32.325,00:16:37.330
information, went down the path
and was finally a command
injection. And because I like to

00:16:40.499,00:16:45.504
live dangerously, I made this
tool always make my command
injections, reboot the system.

00:16:49.475,00:16:54.480
It's a very visual way to see
that yes, we won. So we talked,
a moment ago, about function

00:16:59.218,00:17:05.458
similarities, function
differences and wanting to
compare one function to another.

00:17:05.458,00:17:10.463
Um, these techniques for binary
and function diffing have been
used time and time again, to

00:17:13.432,00:17:19.772
identify where patched
vulnerabilities are. When
Microsoft releases a patch, you

00:17:19.772,00:17:24.777
can go in and compare a
Microsoft patched uh, or a
Microsoft patch versus a older

00:17:26.879,00:17:33.286
version and you can find out
where that code that was patched
was. And you can go back and

00:17:33.286,00:17:39.358
reverse engineer this to find
out where a vulnerability or a
CVE was introduced. And the

00:17:39.358,00:17:44.864
state of the art tools to do
this are generally bindiff and
diaphora. They're very visual,

00:17:44.864,00:17:51.170
they're very good at looking at
one thing compared against the
other and they use a set of

00:17:51.170,00:17:57.710
basic block counts, basic block
edges and kind of, a couple
heuristics um, all kind of

00:17:57.710,00:18:02.448
tethered together. And
unfortunately, they’re pretty
slow if you're trying to do

00:18:02.448,00:18:08.688
these at scale. They're really,
really good for one off
comparisons. For when you have

00:18:08.688,00:18:12.558
that patch and you're trying to
find out where that
vulnerability that was publicly

00:18:12.558,00:18:17.563
discose, disclosed, was. And so,
I wanted to take this
information that I had found,

00:18:20.933,00:18:26.505
from this concolic analysis
pass, and I wanted to see if
there are other places in code

00:18:26.505,00:18:32.845
that couldn't be analysed, that
might also be vulnerable. And
so, I decided to take a data

00:18:32.845,00:18:37.850
mining approach. I decided to go
for clustering. So, for you and
me, we can see that there's

00:18:42.121,00:18:48.527
obviously two clusters there,
but we need to convince our
computer that there are two

00:18:48.527,00:18:55.134
clusters there. It doesn't have
eyeballs the way you and I do.
And so, a classic way of doing

00:18:55.134,00:19:01.440
this in data mining is
extracting features. So, on, on
a grid up here, we would call

00:19:01.440,00:19:07.913
them X and Y components. And we
could find the distance between
all of these and all the other

00:19:07.913,00:19:12.918
points. And a very popular form
of clustering, is something
called K Means Clustering. And

00:19:15.154,00:19:20.126
so, you extract these features,
you have these X and Y
components and you pick two

00:19:20.126,00:19:26.866
random points, any two, and you
categorise all the points based
off of that. You, you ask which

00:19:26.866,00:19:33.205
points are closest to which
point that I just picked? And
you get this two, very distinct

00:19:33.205,00:19:38.210
clusters, these groupings. And
what you do is, you take another
set of two points, two points

00:19:40.446,00:19:46.118
that were in the very middle, of
those groups. And you repeat
this process a couple times. And

00:19:46.118,00:19:51.757
it works very similar to the way
that you are I might look at one
of these graphs and be able to

00:19:51.757,00:19:56.295
say here in the top right, we've
got read here in the top left,
we've got blue, and it works

00:19:56.295,00:20:01.300
really well, for visual
information like this.
Fortunately, you don't need to

00:20:03.469,00:20:10.443
use X and Y components and break
out your algebra one knowledge.
You can use the existence of

00:20:10.443,00:20:16.482
information. You can use string
references, Data References,
function arguments, basic block

00:20:16.482,00:20:21.987
counts. All sorts of information
that you can pull out of reverse
engineering tools. You can

00:20:21.987,00:20:28.761
convert this into information
that can be used for clustering,
and you can develop a method of,

00:20:28.761,00:20:33.766
really quickly finding
similarities between functions
and binaries. There's one hang

00:20:35.868,00:20:41.774
up. With K Means Clustering, if
you don't guess the right number
of clusters, you get a really

00:20:41.774,00:20:48.180
bad result. Obviously there's
four here, but if we told it,
there was two, we got a whole

00:20:48.180,00:20:52.585
lot of blue on one side and a
whole lot of red on the other
side. So one of the ways we can

00:20:52.585,00:20:58.858
fix this is, called cheating, I
mean, Supervised Clustering.
[Laughter] Supervised Clustering

00:20:58.858,00:21:04.997
is where you go in ahead of time
and you say I already know what
everything is. I can tell you

00:21:04.997,00:21:10.002
that there are 4 clusters right
here, right now. And you,
computer, go find me 4 clusters.

00:21:12.138,00:21:17.143
Ah, unfortunately, all of these
firmware writers, they don't
just tell us which functions are

00:21:19.311,00:21:25.217
vulnerable. Ha, they don't tell
us which functions aren't
vulnerable. And so, we can't

00:21:25.217,00:21:31.457
really do supervised clustering.
So I made up a word just for you
guys today called Semi

00:21:31.457,00:21:36.462
Supervised Clustering. So, the
idea is use some known values to
cluster data. So if, if you had

00:21:39.231,00:21:45.371
some sort of concolic analysis
past that found vulnerabilities
for you, or maybe if you had CVE

00:21:45.371,00:21:50.709
information, you could start
with some known good set of
data. You could say I know these

00:21:50.709,00:21:55.714
are vulnerable. I want to find
functions that are really
similar to these bad patterns.

00:21:57.950,00:22:04.156
And so we can set our closer
accounts, to the number of known
vulnerable functions and we can

00:22:04.156,00:22:09.161
pull a whole lot of information
back out of these functions.
Ghidra has a lot that you can

00:22:13.299,00:22:19.705
pull out of a function. It has a
lot of information that lets you
convert it to the existence of

00:22:19.705,00:22:26.645
data. You can turn a data string
call reference into a zero and
one. You can normalise the

00:22:26.645,00:22:32.284
information, to make it so that
one feature, one set of that
data is not more important than

00:22:32.284,00:22:37.289
the other. Or maybe it should
be. But, being it offset 8
million, and memory shouldn't be

00:22:39.792,00:22:44.964
more important than having two
function arguments. And so,
there's a really cool way of

00:22:44.964,00:22:49.735
doing that, called the Chi^2
Squared test and if I had a
whole lot more time, we could

00:22:49.735,00:22:55.174
talk about it, but, what you can
do is you can import from SK
learn, use Chi^2 Squared tests,

00:22:55.174,00:23:01.680
and it works. Oh man, was the
easiest two lines in this entire
program. And so what it does at

00:23:01.680,00:23:06.619
a super high level, is it takes
all of these features, all of
these zeros and ones, all of

00:23:06.619,00:23:11.624
these, this normalised
information and it tells us
what's good and what's bad.

00:23:14.326,00:23:19.732
Having the same file name, as
another function, might not tell
you whether they're especially

00:23:19.732,00:23:24.536
similar or not, or everything
being the exact same
architecture might not be useful

00:23:24.536,00:23:29.408
information. So let's just take
this information out of these
binaries and just throw them

00:23:29.408,00:23:34.513
away for all of our clustering.
But we can make it even more
complicated. We can take it a

00:23:34.513,00:23:40.319
step further. We can use this
thing, called the Silhouette
Score. And and I'm not kidding

00:23:40.319,00:23:46.892
you. The way Silhouette Score is
defined, is it's how good is a
cluster? Like you Google and you

00:23:46.892,00:23:51.897
get how good is a cluster again.
And, what it's designed to do,
is, it tells you how similar

00:23:55.200,00:24:00.139
every function in a cluster is
and I noticed as I was
increasing my cluster counts, on

00:24:05.577,00:24:10.582
this entire firmware, that I was
starting to get really eerily
similar groupings of functions.

00:24:13.252,00:24:18.557
I was finding functions that did
a lot of string operations where
they were concatenating, or they

00:24:18.557,00:24:23.262
were SN perneffing or they were
just doing something with
strings that ’cause they had a

00:24:23.262,00:24:27.700
lot of string references., I
found c++, D structures and
constructors, where all these

00:24:27.700,00:24:34.640
objects are getting created and
destroyed. I found file
manipulations. I found lots of

00:24:34.640,00:24:39.645
web request handling. And so
that was really cool. And so if
we go back to our horrible

00:24:42.381,00:24:48.187
mismatch from before where we
just guessed, 2 clusters, we can
apply our Silhouette Score. And

00:24:48.187,00:24:55.094
we can think about it as big
circles. We want the smallest
circles possible, because we

00:24:55.094,00:25:01.433
want everything that's been
clustered to be really, really
similar. And so if we have a

00:25:01.433,00:25:07.773
really large number, we know
that our clusters, our clusters
of functions, are not really

00:25:07.773,00:25:13.245
similar. And we should increase
our cluster count. And we can do
this over and over and over

00:25:13.245,00:25:18.951
again, until we get a really
good number, where we have a
very small distance, between all

00:25:18.951,00:25:23.956
the functions. And so for my
third demo, we're going to do
just that. This video, is

00:25:39.304,00:25:44.309
running in real time, it is
taking in over 100 binaries
across this firmware. It will

00:25:46.378,00:25:53.252
cluster all of them and produce
a result of how similar every
function in every binary is, in

00:25:53.252,00:25:58.257
about a minute. And so, we're
providing a function that we're
interested in, I know that this

00:26:01.593,00:26:07.266
function is a command injection,
and I want to find functions
that are really similar to this.

00:26:07.266,00:26:13.739
And so I'm providing, a path, to
my extracted firmware, I'm
telling it to go through and

00:26:13.739,00:26:19.178
iterate over every function
inside of this firmware. It's
recovering that set of

00:26:19.178,00:26:25.751
information out of Ghidra and
now we're clustering. So over
here we have a set of numbers

00:26:25.751,00:26:30.522
and those are the number of
clusters that we are testing
against. And those other

00:26:30.522,00:26:36.862
numbers, are the Silhouette
Score, we want the smallest
Silhouette Score possible. And

00:26:36.862,00:26:41.867
so right now we are mapping
those cluster counts to their
corresponding Silhouette Score.

00:26:43.936,00:26:50.008
And so we're gonna just test out
50 clusters, and we're going to
see that there was a spike,

00:26:50.008,00:26:55.013
right around 13 of the lowest
Silhouette Score. And that is
the best grouping of those

00:27:00.352,00:27:05.824
functions. And how, how close
they were together. And so in
less than a minute, we ran

00:27:05.824,00:27:10.829
across an entire firmware, and
compared to every function to
every function. And so I did

00:27:16.268,00:27:21.940
this a lot, I did this for just
way more than just this
firmware. And I had a lot of

00:27:21.940,00:27:26.945
really interesting results. Uh,
up near the top, we have an
impeccably small number, zero.

00:27:29.548,00:27:34.152
Means we did a good job. It
means, the first function that
we're comparing against is the

00:27:34.152,00:27:38.323
exact same as the first
function, was a really good
test, let me know that I was

00:27:38.323,00:27:42.561
doing the right thing. But right
below that I have a really,
really, really small number

00:27:42.561,00:27:48.967
again. And what this showed me
is that there were code clones
in this firmware I was looking

00:27:48.967,00:27:53.972
at, someone went in, copied and
pasted code from one binary into
another. And because I did this

00:27:57.209,00:28:03.115
clustering, I was able to
identify it automatically. And
then just below that again, I

00:28:03.115,00:28:08.120
had another function that was
really, really, really similar
to that very first one. And as I

00:28:10.923,00:28:17.696
dived farther and farther into
the data, I started finding ah,
similarities across calling

00:28:17.696,00:28:24.469
patterns, where data might be
loaded in from an argument, SM
printer F’d, and then using a

00:28:24.469,00:28:29.374
system call, I'd find similar
function calls, similar data
references, similar file

00:28:29.374,00:28:36.014
accesses, similar ways of
interacting with sockets and
networks. And so looking at that

00:28:36.014,00:28:42.487
very first function, the
original function we provided,
in that third function, that was

00:28:42.487,00:28:47.292
really, really close, it's
actually really hard to tell
that they're different at all

00:28:47.292,00:28:54.266
You could have just had one
function in there, outside of
maybe the function name, and the

00:28:54.266,00:29:00.539
string it referenced, so many
patterns were identified
automatically using this

00:29:00.539,00:29:05.544
clustering and feature
extraction technique. So I
showed you a really complicated

00:29:08.914,00:29:13.919
graph earlier. We were
interested in that value. The
trick for finding our cluster

00:29:15.954,00:29:22.828
count, was finding the biggest
drop, the smallest value
returned, out of our Silhouette

00:29:22.828,00:29:29.534
Score. So I've just thrown a
whole lot of information at you
in about 30 minutes, I hope you

00:29:29.534,00:29:36.408
were taking notes. I'm just
kidding. Um, I don't expect you
to go out and implement this on

00:29:36.408,00:29:42.648
your own, I don't expect you to
try and use the first script or
the second script, or, or try to

00:29:42.648,00:29:48.286
hobble through my poorly
documented Python. I've built a
tool. This tool is called

00:29:48.286,00:29:53.492
Firmware Slap. The tool that
we're talking about today, it
automates every single one of

00:29:53.492,00:29:58.497
these steps. You provide a
firmware, it'll locate the
system route, it will locate all

00:30:01.366,00:30:07.906
the shared objects. It'll
iterate over every function in
every binary, recover this

00:30:07.906,00:30:12.911
function prototypes, build and
run those analysis jobs. It'll
identify those vulnerabilities

00:30:15.380,00:30:20.385
for you. It'll extract out the
features, using SK learn.
Iterating over all those

00:30:22.721,00:30:29.127
features to see if they're good.
It'll cluster those features and
we'll dump it into JSON. And

00:30:29.127,00:30:34.132
because I know not everyone is a
big fan of black backgrounds
with green text, it exports it

00:30:36.435,00:30:41.440
to Elasticsearch and Kibana.
[Laughter and applause]. You're
not limited to just

00:30:50.849,00:30:57.389
Elasticsearch and Kibana, it's
JSON, loaded into whatever you
like. Um, I, I've included a

00:30:57.389,00:31:02.327
series of scripts to load that
information into Elasticsearch
and Kibana if you want. But,

00:31:04.730,00:31:11.169
this tool is designed to talk
about something a little bit
bigger. You have protections in

00:31:11.169,00:31:16.174
your code. If you are writing
firmware, use that extra flag on
GCC. You have these protections

00:31:18.310,00:31:23.315
that can be so easily used to
prevent a tool like this, from
automatically building exploits.

00:31:25.517,00:31:30.622
Enable your ASLR. That’ll make
it so much harder for any of
these exploits to land. And if

00:31:30.622,00:31:35.627
you're a consumer, buy a better
router. [Laughter]. It's time to
bring a lot more automation into

00:31:39.931,00:31:44.936
our embedded systems. You have
IoT fridges, and washers and
dryers and routers, and smart

00:31:48.440,00:31:54.980
home systems. And, not all these
systems are getting vetted. Not
all of these systems are going

00:31:54.980,00:32:00.385
through the proper QA. They're
trying to produce the cheapest
and fastest product that they

00:32:00.385,00:32:05.390
can and get it to market. And
that is creating a series of
very, very vulnerable devices.

00:32:08.460,00:32:13.131
Don't blindly trust and run
these third party systems. I'm
giving you the tools to find

00:32:13.131,00:32:18.136
these bugs yourself. Today this
morning, I released Firmware
Slap. You can find it on GitHub.

00:32:21.907,00:32:26.912
I'm releasing the Ghidra
function dumping plugin. And I'm
also releasing all the Pox

00:32:29.047,00:32:34.052
associated with this
presentation. And that's where
you can find it. Thank you.

