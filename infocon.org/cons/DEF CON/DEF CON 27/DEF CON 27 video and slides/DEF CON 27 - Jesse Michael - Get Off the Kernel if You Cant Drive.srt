00:00:00.601,00:00:05.606
>>So, I am Mickey, that's Jesse.
Uhm.. That's our twitter
handles, if you wanna ask us

00:00:08.742,00:00:13.080
questions, uh, about anything we
give at this talk, please free
to, please feel free to reach

00:00:13.080,00:00:20.020
out and ask us. Even next week
or whatever, we're happy to
help. About the agenda of this

00:00:20.020,00:00:23.957
talk, well, we're going to start
with a little bit of a
high-level introduction into

00:00:23.957,00:00:29.263
what is a driver in Windows.
We're gonna keep it high-level
and then we're gonna get more

00:00:29.263,00:00:33.433
and more technical as we go
along. One of the things we're
going to discuss is what the

00:00:33.433,00:00:38.438
problem is, uh, I'll give you
some funny examples of it. The
tools you need to exploit for

00:00:40.741,00:00:45.746
yourselves and, uh, a couple of
funny stories about disclosures.
This topic is not new, so, bad

00:00:52.819,00:00:57.824
drivers have been known to be
found in, uhm, the past decade.
They pop up - 1 here, 1 there, 3

00:01:01.862,00:01:06.867
here and you get a little log
post and descriptions and...
Excuse me. How to use them and

00:01:09.803,00:01:15.409
it just goes away after a while
- the vendor patches it or fixes
it or not and it stays there and

00:01:15.409,00:01:20.414
then continues on. So, here are
some of the examples, we use
them in our talk and based our,

00:01:20.414,00:01:25.452
uh, our, uh some of our code on.
So, I thought it was best to
give credit. Uh, more

00:01:25.452,00:01:30.223
information can be found in
these links, we'll have the
slides available on GitHub, uh,

00:01:30.223,00:01:37.130
soon after the talk or next, uh,
early next week, and we'll
explain that later. Let's start

00:01:37.130,00:01:42.069
with the biggest, the, the, the
smallest, uh, uhg, simplest
explanation - I'm sorry, English

00:01:42.069,00:01:47.975
is not my first language. Uhm,
why are we talking about Windows
and Linux drivers or, uh, or

00:01:47.975,00:01:53.347
Apple? Uh, Linux drivers are
basically - so, except for
specific examples that are

00:01:53.347,00:01:59.820
proprietary code, most of the
Linus drivers are available in
GitHub and you can find them and

00:01:59.820,00:02:05.826
look at them. Apple is a closed
garden - so, whatever Apple
does, Apple knows and Apple sees

00:02:05.826,00:02:10.297
but we don't really care. There
is a caveat, uh, Apple does
have, uh, Windows drivers for

00:02:10.297,00:02:12.299
their hardware. We did skim
those but we didn't find
substantial there. What is a

00:02:12.299,00:02:17.304
driver and how it's used? So,
basically, in, in, in the
computer operating system you

00:02:20.040,00:02:25.045
have a user space, you have
kernel space and then you have
the hardware. For application

00:02:30.150,00:02:35.022
and user space to communicate
with hardware, you're gonna need
some sort of way to do this

00:02:35.022,00:02:39.326
securely - otherwise you violate
every known concept of a
security boundary, ever. And you

00:02:39.326,00:02:44.331
don;t want a ring through your
user space application to be
through to be able to read and

00:02:44.331,00:02:49.336
write flash. It's just wrong,
so, we this concept called
drivers. These drivers are

00:02:52.339,00:02:57.344
running within kernel space;
they communicate with the
kernel; the kernel gets requests

00:03:00.147,00:03:05.952
from the application - passes it
on to the driver, the driver
does it's magic and communicates

00:03:05.952,00:03:10.957
with the hardware and goes back
and forth. It's pretty straight
forward. These drivers in

00:03:13.326,00:03:18.331
Windows are signed. Now, uhm,
for a driver to run and execute,
be executing kernel space these

00:03:23.437,00:03:28.442
days. It needs to be signed and
it needs to be certified by
Microsoft. We're not going to go

00:03:31.978,00:03:36.983
into the entire process of how
drivers are certified by Windows
- it's not, it's not easy to

00:03:42.189,00:03:48.295
explain. There's a back and
forth. Some, some of your are
smirking right now, yeah, cause

00:03:48.295,00:03:54.768
you probably tried to assign
drivers with Windows. There is a
reason for that process - uhm,

00:03:54.768,00:04:01.374
but it's, it's not quite
straightforward to get out from
reading blog posts on the

00:04:01.374,00:04:07.881
internet. Uhm, the point, the
key point in this slide is
"Windows 10 sign-in process",

00:04:07.881,00:04:13.353
right? So, uh, uh, Microsoft
introduced this new process
called EV - EV stands for

00:04:13.353,00:04:18.091
"Extended Validation". Uhm, if
you want to EV sign a
certificate, uh, so, uh, driver,

00:04:18.091,00:04:23.096
you need to have this EV
certificate which, uhm, allows
basically, Microsoft to co-sign

00:04:26.299,00:04:31.037
the driver with you and give
that with gold certification
side-by-side, so you have a

00:04:31.037,00:04:38.011
driver certified by Microsoft
and operates and everything's
great. Uhm, EV, these are slides

00:04:38.011,00:04:43.150
we found for our Microsoft
presentation, given in Shanghai
2015, uh, when they introduced

00:04:43.150,00:04:45.285
this. Uh, funny st, uh, funny
thing about this is that, the
bad guys, the bad guys reference

00:04:45.285,00:04:47.287
here and that EV certificates
are better because it means less
malware - but not for legacy!

00:04:47.287,00:04:51.291
So, if you have an old driver
that's already signed - do
whatever you want with it.

00:04:51.291,00:04:53.293
However, if Microsoft is a good
guy, they will let you load the
driver even if, even if the

00:04:53.293,00:04:55.295
certificate's expired. Uhm, we
do have one of these drivers
that, for some reason, loaded

00:04:55.295,00:04:57.297
and we kept double-checking the
properties and it just expired,
the certificate. What the h***'s

00:04:57.297,00:04:59.299
going on? So we ran sign tool -
sign tool said it's not, uh,
it's not within the required

00:04:59.299,00:05:01.234
period of verifying. No idea why
it loaded - it still loaded - I
don't complain. So, at this

00:05:01.234,00:05:03.236
point we were like maybe we'll
get our own EV certificate!
We'll try to make our own

00:05:03.236,00:05:05.238
example driver and, you know,
have some fun with it. We saw
this list of things to do - of

00:05:05.238,00:05:07.240
getting it, and, you know, you
have to have the legal
agreements signed on behalf the

00:05:07.240,00:05:09.242
organisation - I don't think so.
It's just too much of a hassle,
we work for a company, that

00:05:09.242,00:05:11.311
company has their own driver
they developed - they, they
signed it with Microsoft. I

00:05:11.311,00:05:18.084
don't want to risk anything
potentially with Microsoft, so.
[fart noise] Highest of notes

00:05:18.084,00:05:23.089
So, uh, let's take a look at
some of the, uh, the issues that
we've seen in the past with some

00:05:41.641,00:05:47.614
drivers - and, uh, one example
that we, uh, that a lot of
people know about is "Read Write

00:05:47.614,00:05:51.618
Everything", and uh, there is
also, uh, "LoJax" is also one of
the, uh, uh, malware that we saw

00:05:51.618,00:05:56.623
that was using signed drivers.
"Slingshot" was another APT that
was using, uh, this class of

00:06:43.803,00:06:48.808
driver specifically to bypass
Windows protections. Uh, we've
also seen this type of driver

00:06:54.648,00:07:00.754
being used by a game-cheating
engines, or uh, anti-cheat
software. Uh, there was an

00:07:00.754,00:07:05.759
interesting case, CapCon driver
where, uh, where this driver was
signed by CapCom for a video

00:07:07.994,00:07:12.999
game that it would turn off, uh,
SMEP protection, execute code
you bashed in from userspace and

00:07:15.168,00:07:21.107
then... [coughing] Uh, continue
on and that was found pretty
quickly and people were able to,

00:07:21.107,00:07:26.112
uh, know to block that, but
these, these issues keep popping
up individually so we wanted to

00:07:28.481,00:07:33.086
try, to look at, across the
spectrum a lot more. There's
some, uh, nice examples right

00:07:33.086,00:07:38.091
up. So, there's a vulnerability
in an MSI driver and how to use
it escalate from, uh, user space

00:07:40.193,00:07:46.733
not elevated to, uh,
anti-authority system. By using
one of these signed drivers. So,

00:07:46.733,00:07:51.971
to take a, a little bit of a
closer look - read write
everything was, uh, essentially

00:07:51.971,00:07:57.010
designed to give you the ability
to look at these hardware
interfaces in your system.

00:07:57.010,00:08:02.215
Basically, explore the system,
see what the state of the
machine is, and it basically has

00:08:02.215,00:08:08.755
a, a user space app and then an
signed driver which is intended
for this purpose. But, uh, the

00:08:08.755,00:08:15.395
problem is that it, it allows
access to components that have
really important security

00:08:15.395,00:08:20.533
properties and they need
confidentiality and some of
these, uh, resources and, uh,

00:08:20.533,00:08:25.538
integrity in other resources.
So, you're basically given free
reign to arbitrarily read,

00:08:27.707,00:08:32.712
write, modify, some of the
devices, some of the interfaces
that Windows depends on, Windows

00:08:35.048,00:08:40.353
security depends on these not
being tampered with. So, this,
this was an interesting app.

00:08:40.353,00:08:45.358
Uhm, but then, uh, LoJax was a,
uh, malware that was found in
the wild - it was an APT that

00:08:48.862,00:08:55.502
they actually brought a copy of
that along with them as part of
their infection. Uh, their

00:08:55.502,00:09:00.440
implant tool use Read Write
everything to gain direct access
to the spy controller and then

00:09:03.743,00:09:08.848
they were able to use that in
order to write their own
malicious module into the, into

00:09:08.848,00:09:15.488
the system flash and, uh,
persist in that UFI firmware
that would, uh, survive,

00:09:15.488,00:09:21.027
reboots,, operating system
reinstalls. Because they have
the ability to directly talk to

00:09:21.027,00:09:27.200
the hardware through this
mechanism. And, even if you're
system did not have this Read

00:09:27.200,00:09:31.471
Write everything driver on it,
they just brought it with them.
They were able to load it and

00:09:31.471,00:09:36.476
use that capability in a really
interesting attack. Uh, there
was another APT, uh, campaign

00:09:39.179,00:09:44.184
that also, basically, also
brought their own driver. Their
driver was not signed but they

00:09:48.221,00:09:53.226
exploited, uh, 4 different
drivers that had, uh, read write
MSR capability in order to get

00:09:55.728,00:10:00.500
arbitrary code execution in the
kernel and bypass driver signing
enforcement - so they could

00:10:00.500,00:10:06.806
install their own, uh, kernel
rootkit. So, this, this is out
there, actually being used, in

00:10:06.806,00:10:11.811
the wild, by real attackers. So,
there's a few different reasons
why you might want to use 1 of

00:10:14.481,00:10:19.486
these drivers. Basic one is just
privilege escalation from user
space. Get either`, uh, escalate

00:10:22.455,00:10:27.460
a user from a normal unelevated
user to admin user. There's also
just getting code execution

00:10:29.796,00:10:36.769
running within, uh, within the
kernel itself. Uh, another, uh,
possibility is you can use some

00:10:36.769,00:10:41.774
of these, uh, drivers to
disable, bypass, uh, Windows
security mechanisms, and

00:10:44.210,00:10:49.649
sometimes that could be used in
order to, uh, escalate privilege
within the kernel or just get

00:10:49.649,00:10:54.754
access to resources you
shouldn't get access to. Uh,
there's another write, uh,

00:10:54.754,00:11:01.494
motivation where, essentially,
getting access to the hardware
itself is, is really useful. You

00:11:01.494,00:11:05.999
could modify system firmware,
you could modify device
firmware. There are a lot of

00:11:05.999,00:11:12.338
devices that still have unsigned
firmware and you can go -
basically, write your malicious

00:11:12.338,00:11:17.477
modification either to the
system firmware, get code
execution before the operating

00:11:17.477,00:11:22.482
system loads. Or, modify a
device and, uh, have a, uh,
persistent implant in a

00:11:25.018,00:11:29.289
particular device. And there's
some other things you can do
with direct hardware access but

00:11:29.289,00:11:34.227
those are some key ones that
we'll want to specifically call
out. So there's, there's a few

00:11:34.227,00:11:39.232
different, uh, attack scenarios,
uh, if the driver is already on
the system and loaded, the

00:11:41.634,00:11:46.639
driver itself controls the
policy for who can talk to this
device. So, many drivers, you

00:11:49.075,00:11:55.815
don't have to be admin - you can
be a normal, non-elevated user
to talk to this particular

00:11:55.815,00:12:02.388
device. There's another scenario
where the, the driver is on the
system but it's not loaded yet.

00:12:02.388,00:12:09.162
And, in that case, you do need
admin privileges to load the
driver, uh, we have found signed

00:12:09.162,00:12:14.934
applications that you could use
to load drivers. Uh, that are
signed by well-known, trusted

00:12:14.934,00:12:19.806
vendors that you could
potentially use one of these
applications - there will be a

00:12:19.806,00:12:26.613
little UAC pop-up that says
"Would you like some trusted
vendor to modify your computer"

00:12:26.613,00:12:31.618
and that might be means to uh,
load the driver if you do not
have admin privileges but, you

00:12:34.520,00:12:40.893
can also just wait, so... If
you, if it's already loaded, you
don't need to be admin. If it's

00:12:40.893,00:12:46.799
not, not yet loaded, you do need
admin, essentially. And there's
also the scenario where the

00:12:46.799,00:12:51.804
driver isn't on the system; all
of your drivers are, are fully
up to date. Uh, malware can

00:12:55.108,00:13:01.981
bring a driver with it and load
that. In this case they do, you
do need escalated to, uh, an

00:13:01.981,00:13:06.986
admin in order to load the
driver. But, there have been a
lot of privilege escalations.

00:13:10.790,00:13:17.597
So, uh, even if the newest
version has been fixed, in many
cases the old vulnerable driver

00:13:17.597,00:13:22.669
will still be loaded into
Windows, or loadable into
Windows. And you could just

00:13:22.669,00:13:27.674
bring the old version and load
that. And, use this kind of
capability. And LoJax did this

00:13:30.276,00:13:35.481
in the wild for their PDP
campaign where they brought an
older driver. They were able to

00:13:35.481,00:13:40.486
load it and get, get direct
access to the hardware and
implant the UEFI firmware. So,

00:13:44.624,00:13:50.396
we've, we've seen this pop-up
every now and then, just one at
a time, there's not really an

00:13:50.396,00:13:54.367
industry wide fix for this
problem, or uh, industry-wide
effort to go fix this. So, we

00:13:54.367,00:13:59.372
wanted to, uh, take a look and
see, see how hard it is to find
these drivers how widespread it

00:14:04.911,00:14:11.784
is. So, uh, we, uh, focussed on,
because we're interested in
signed drivers so we're loaded

00:14:11.784,00:14:16.956
into WIndows, we, we threw out
any that we found that weren't
signed. Because we're looking

00:14:16.956,00:14:23.563
for drivers that talk to
hardware interfaces or how that
kind of capability we look for

00:14:23.563,00:14:28.000
drivers specifically from, uh,
firmware and hardware vendors.
And then, just to make it a

00:14:28.000,00:14:33.072
little easier, we, uh, just went
with the smaller drivers that
will probably be more simple.

00:14:33.072,00:14:38.077
So, also, looking for things
like read-write, MS, opcode,
move to control register,

00:14:40.213,00:14:45.218
in-and-out opcodes. Those are
specific x86 instructions that
are, uh, talking to drivers, or,

00:14:48.121,00:14:53.092
uh, talking to devices in a way
that we're interested in. Uh,
one other thing to keep in mind

00:14:53.092,00:14:59.699
is that, uh, there's two
different, uh, drivers, there's
two different mechanisms or

00:14:59.699,00:15:06.072
frameworks that you could write
your driver, the, uh, older
windows driver model and, uh,

00:15:06.072,00:15:13.012
the, the newer Windows driver
framework, uh, with the, uh, the
older version - you basically,

00:15:13.012,00:15:18.017
your driver would just call IO
create device and then write an
address of the handler for, uh,

00:15:20.686,00:15:25.558
all of the requests that, uh,
that user space is going to make
to your driver to a specific

00:15:25.558,00:15:30.563
address within a, a structure
that passes to this IO create
device, uh, function. Uh, the

00:15:32.899,00:15:38.404
Windows driver framework has
changed a little bit but it's a
similar type of concept where

00:15:38.404,00:15:43.409
you, uh, you have a couple of
functions that are set up and
eventually you do have a, a main

00:15:46.779,00:15:53.052
dispatch, or, a opcode handling
function that will handle all of
the requests for user space. Uh,

00:15:53.052,00:15:58.057
uh, and I, I dunno if we
mentioned it but IOCTL is
basically iO control. So,

00:16:00.059,00:16:05.064
there's, there's a specific
number I want IOCTL 1, 2, 3, 4,
and, uh, the, uh, the dispatch

00:16:09.735,00:16:14.740
will call your, your kernel
handler and say "Here is your iO
request packet with requests 1,

00:16:17.176,00:16:22.181
2, 3, 4 and the data was passed
between each user space." Uhm,
so, there is a little bit of a

00:16:24.650,00:16:29.655
difference where an iO create
device vs, uh, this creates
device secure function. If you,

00:16:33.259,00:16:38.998
if the driver is calling, uh,
create device, secure, it can
actually specify a, uh, a

00:16:38.998,00:16:44.003
security descriptor. Which is, a
policy which can talk to this
driver and what type of access

00:16:46.305,00:16:51.310
they have. Uh, this is, this is
an example of one of these SDDL
strings, in this case it's a

00:16:54.046,00:17:00.119
"discretionary access control
list" that, uh, allows, generic
all to local system and generic

00:17:00.119,00:17:05.791
all to built-n administrators.
Most of the drivers that we've
looked at don't bother to send

00:17:05.791,00:17:10.796
any kind of policies. So, a
normal, non-elevated user can
talk to these drivers. So, we

00:17:12.999,00:17:18.004
ess, essentially spent two weeks
looking for drivers. We, uh,
skimmed through hundreds of

00:17:20.873,00:17:27.680
driver files, just doing, uh,
manual disassembly analysis -
looking for this type of, uh,

00:17:27.680,00:17:32.685
behaviour. Uh, we found 42, uh,
different vulnerable signed
drivers. Uh, we found 42

00:17:34.987,00:17:39.992
vulnerable signed x86-64
drivers. Uh, we did find a lot
that had a, a 32-bit version.

00:17:42.395,00:17:47.300
So, uh, it was around
80-something total files. We
did, we did find 1 I, Itanium

00:17:47.300,00:17:53.339
driver that, I dunno if anyone
still has a machine out there,
but uh, we've, we've also found

00:17:53.339,00:17:58.344
more drivers since. But, there
were, uh, 42 drivers, 42 x86-64
drivers that we were looking at.

00:18:01.414,00:18:06.419
But, uh, the types of things
that we follow. Basically, you
could ask from userspace for the

00:18:10.189,00:18:16.162
kernel to go read and write
virtual memory in the kernel. Or
do read and write to the

00:18:16.162,00:18:22.568
physical memory addresses. Uh,
you could go talk to MIO
devices, uh, model specific

00:18:22.568,00:18:28.407
register, read, write, control
register access, talking to psi
devices. Just basic, uh, in and

00:18:28.407,00:18:30.409
out. So, uh, here's an example
of, uh, mem copy that we found
in the kernel where they

00:18:30.409,00:18:32.411
literally are taking the, the
source destinations and size for
this copy operation from user

00:18:32.411,00:18:37.416
space. There's no checks of any,
on any point. Yea, pointers - no
pointer checks, no one writes

00:18:50.896,00:18:55.901
checks, you can just ask the
driver to copy by bringing it
around.. Uh, this can, this can

00:18:59.071,00:19:05.678
be used to modify, uh, kernel
code and data structures, uhm,
patch guard will detect some

00:19:05.678,00:19:11.050
modifications - it doesn't
detect them all though, so...
It's, if you have, a primitive

00:19:11.050,00:19:17.189
that's flexible, you could do a
lot of interesting things with
it. How you can copy form users

00:19:17.189,00:19:23.295
base into kernel memory, other
way around. It's, it's really
useful. Uh, another thing we

00:19:23.295,00:19:29.168
found is just basic, arbitrary
physical memory write. Uh, read
and write. Uh, in, in this it's

00:19:29.168,00:19:35.274
intended so that you can use it
to go talk to device drivers and
do MMIO access, uh, in this

00:19:35.274,00:19:40.279
case, there's also no sanity
checks, you can basically have
any, any address, any size, and

00:19:44.250,00:19:49.255
go try to call this function and
m, map iOS space. Uhm, there has
been a change in how Windows

00:19:51.457,00:19:58.097
deals with this function as of,
uh, uh, 18-03 where they've
tried to limit the scope of what

00:19:58.097,00:20:04.170
you can do with this physical
memory write only to those, uh,
MMIO addresses. So, uh, older

00:20:04.170,00:20:09.275
systems before 18-03, you could,
you could just map, map any
kernel address and you read and

00:20:09.275,00:20:14.280
write there also. Uhm, but even
after 18-03 you can still go,
uh, get direct access to the

00:20:16.382,00:20:22.354
hardware and do some pretty
interesting things there. Uh,
uh, there's also drivers that

00:20:22.354,00:20:29.228
just expose the, the physical to
virtual mapping so you can look
up addresses in virtual space

00:20:29.228,00:20:34.567
and find their corresponding
page and, uh, the physical
address layout which is, it,

00:20:34.567,00:20:39.972
it's useful for, for dealing
with IOCTLs that give that kind
of, uh, physical address but

00:20:39.972,00:20:44.577
it's also useful for, uh, things
like rogue hammer where knowing
where things are mapped

00:20:44.577,00:20:48.414
physically into, into the
address space, this type of
functionality could be really

00:20:48.414,00:20:53.419
useful. So, another thing that
we, uh, looked at was arbitrary
model-specific register. Uh,

00:20:56.455,00:21:01.360
read and write, uh, here's an
example where they're taking the
address of the model specific

00:21:01.360,00:21:07.767
register to read - no filtering,
directly give you the data back.
So, if you're not familiar with

00:21:07.767,00:21:12.037
model specific registers, uh,
these are, uh, internal
registers within the CPU,

00:21:12.037,00:21:16.542
that's.. You have your general
purpose registers for normal
executing code but these special

00:21:16.542,00:21:21.547
purpose model specific registers
are, uh, in addition to that and
they were originally used for

00:21:27.153,00:21:32.591
experimental features that they
have wanted to try out and some
of those, uh, experimental

00:21:32.591,00:21:37.129
features, they decided "These
are really useful, so we're
going to turn them into

00:21:37.129,00:21:43.536
architecture, uh, model-specific
registers, or "MSRs" such that
from a certain point going

00:21:43.536,00:21:49.775
forward they're, they're
committing to support this
particular usage model for the,

00:21:49.775,00:21:55.581
the value that you, you put into
the MSR will be used in an
architecturally defined way.

00:21:55.581,00:22:02.087
And, uh, they do have a special
OP code - specialized x86
OPcodes, uh, read MSR and write

00:22:02.087,00:22:08.360
MSR in order to, uh, access
these, uh, registers. Uh, 1
interesting point is that you

00:22:08.360,00:22:13.365
can only access them from ring 0
- so, ring 3, if you try to read
a, uh, an MSR, uh, you'll get a,

00:22:15.601,00:22:22.575
uh, false. And, it, it won't
allow you to, uh, get that data.
But, we, we have a primitive

00:22:22.575,00:22:27.680
here where you can read MSRs and
there's some pretty useful
things you can get just by

00:22:27.680,00:22:33.519
reading the MSR. Uh, we also
found, uh, the model specific
write primitives and there's

00:22:33.519,00:22:38.524
some really, really critical
model-specific, uh, registers
that, uh, are,are especially

00:22:41.927,00:22:46.932
interesting like, uh, star,
CSTAR, LSTAR, and CSTAR where,
in order to even transition from

00:22:51.804,00:22:56.809
user space into kernel space -
or ring 3 into ring 0, when you
call a, when you execute a

00:22:59.745,00:23:04.683
syscall instruction, it will, as
part of that transition, going
from use, going frm ring 3 into

00:23:07.486,00:23:14.093
ring 0, it will take the address
that's stored in this LSTAR
register and use that as the

00:23:14.093,00:23:20.299
address that it starts, uh,
executing in ring 0. If, if you
have the ability to write to

00:23:20.299,00:23:25.304
this register, from user space,
that's pretty dangerous. So, uh,
there's also a control registers

00:23:28.741,00:23:33.746
and there's a lot less control
registers but they store some
key, uh, control bits for the

00:23:35.914,00:23:40.919
processor. Uhm, CR3 is the base
of the virtual memory uh paging
tables so, knowing where that

00:23:44.123,00:23:49.128
is, could potentially be useful.
Uh, CR4 has, uh, uh, some other
security controls. CR0 has some

00:23:51.797,00:23:57.169
security controls. So, in this
case we have an arbitrary
ability to read any of these

00:23:57.169,00:24:02.074
control registers, uh, including
the base of the page table
structure in kernel space - not

00:24:02.074,00:24:07.079
the user space copy of the page
tables. And there's also, uh, a
control register write, uh,

00:24:09.782,00:24:16.121
functions where you can take an
arbitrary value, an arbitrary
control register, that's taken

00:24:16.121,00:24:22.294
directly from your user space,
uh, as a buffer, and write the
value to the control register.

00:24:22.294,00:24:27.299
and some pretty key ones that,
that some of the security, uh,
controls in Windows, depend on

00:24:29.868,00:24:36.608
is supervised execution
protection - that basically is,
uh, one of the features that

00:24:36.608,00:24:40.913
helps protects against a number
of different attacks that have
been very successful against

00:24:40.913,00:24:45.918
Windows in the past. Uh, there's
also this write protect bit in
CR0 where if, if the write

00:24:49.855,00:24:54.860
protect bit is not set in CR0,
and, uh, the, the kernel or
ring-0 code tries to write to

00:24:58.464,00:25:03.669
page that is marked "read only"
they will completely ignore the
permissions in the page table

00:25:03.669,00:25:09.842
and let you do the write anyway.
So, it's a, it's an interesting
control, so, it's kind of

00:25:09.842,00:25:14.480
security hardening but it's
useful to know about it, if we
can write to that, that can help

00:25:14.480,00:25:20.619
us. Other things are just
arbitrary, uh, IO-port write.
You can write arbitrary values;

00:25:20.619,00:25:26.792
arbitrary iO ports. Its, uh,
what you can do with that is
platform-dependent, you can use

00:25:26.792,00:25:32.798
that to modify system and device
firmware. Uh, we, we saw a
really cool, uh, vulnerability

00:25:32.798,00:25:38.537
last year involving ASPEED BMC
configuration where there were
debug features that were

00:25:38.537,00:25:44.576
accessible through the host,
through IO-reads and -writes,
arbitrarily read and write into

00:25:44.576,00:25:50.082
the BMC address space. Uh,
laptops have likely an embedded
control you can talk to over IO

00:25:50.082,00:25:55.087
access. And there's also legacy
PCI access over iO-port CF8,
CFC, there's also just functions

00:25:58.424,00:26:03.362
to literally do that like legacy
PCI write. So, there have been
issues with, uh, security at PSI

00:26:06.665,00:26:11.670
devices and that comes up a lot.
So, kind of look at the MSR-case
a little bit more. Essentially

00:26:15.974,00:26:22.281
LS, LSTAR MSR is pointing to an
address in the kernel memory
where we don't know exactly

00:26:22.281,00:26:29.054
where the kernel has been
loaded. There's address
randomizations happening, so,

00:26:29.054,00:26:35.327
when, when this transition
happens, when you go from user
space to kernel space, it starts

00:26:35.327,00:26:42.100
executing at the, at the address
that LSTAR points to. So, if you
could write to LSTAR, we can

00:26:42.100,00:26:47.406
basically allocate a buffer in
user memory and then when that
transition happens, the next

00:26:47.406,00:26:52.411
syscall that happens, it'll
start executing from your
pointer instead but there's some

00:26:54.980,00:26:59.651
complications to that. So, one
of the features that I've
mentioned, uh, supervisor mode

00:26:59.651,00:27:05.557
execution prevention is intended
to, uh, stop this feature. There
have been a lot of bugs where

00:27:05.557,00:27:10.562
they would get the kernel to
jump to your, your pointer and
they added this feature to the

00:27:12.998,00:27:18.837
CPU, I think in, uh, Sandy
Bridge where, maybe IV bridge,
but it's essentially a feature

00:27:18.837,00:27:23.842
where if the CPU is executing
and, uh, and, uh, ring-0 kind of
does a code fetch to a page

00:27:26.445,00:27:31.450
that's in user mapping, it'll
cause a false. And this is
controlled by a bit in the CR4

00:27:33.886,00:27:38.891
register, so, if we have a
read-write primitive for, uh,
control registers, we can just

00:27:40.893,00:27:47.399
read this bit, uh, or we can
read the CR4 value, clear the
bit and write it back to CR4 and

00:27:47.399,00:27:52.070
in order to get around
supervisor mode execution
prevention. Uhm, there's

00:27:52.070,00:27:57.075
another, uh, complication that,
uh, uh, there needs to be a
little bit of state change when

00:27:59.945,00:28:05.651
you're transitioning into the
kernel space, so, although it
starts executing in ring-0, it

00:28:05.651,00:28:10.055
hasn't fully switched into
kernel space, so, you need to do
a little bit of extra work

00:28:10.055,00:28:15.060
entering and exiting your, your
payload there. And then there's
also a, a kernel page isolation.

00:28:18.030,00:28:23.035
So, as part of the meltdown
mitigation for, uh, for one of
the Intel CPU issues, uh, they

00:28:25.904,00:28:30.642
basically isolated the kernel
pages - so they have two
different sets of pages - one

00:28:30.642,00:28:37.482
for user space and one for
kernel space. So, uh, we do need
to know the address for those

00:28:37.482,00:28:42.921
kernel page tables in order to
fully be able to switch the
kernel space. Uh, but, if we

00:28:42.921,00:28:49.695
have an IOCTL that we can
arbitrarily CR3 then, then we
can get the address of that

00:28:49.695,00:28:55.500
kernel, uh, page table base so
that when we build that payload
we can swap in the kernel page

00:28:55.500,00:29:00.439
table pointer and do what we
want to do. So, we have a couple
little demos of, uh, switching

00:29:04.810,00:29:09.815
of, uh, some of these features.
>> Uh, a quick note...all these
demos are in Powershell.

00:29:17.489,00:29:22.494
[laughter] >> So we, we have a
basic, uh, uh... [indistinct
talking] This one is not

00:29:24.663,00:29:29.668
Powershell but this, this is
just a simple... [indistinct
talking] Yea, so, in order, in

00:29:34.006,00:29:39.011
order to, to do our research we
basically made a, a simple tool
to, uh, load any arbitrary

00:29:44.016,00:29:50.722
driver for us. So, in, instead
of needing to, needing to, uh,
write a helper to load it and

00:29:50.722,00:29:56.995
deal with it, it's just a simple
tool to load a driver and create
the service, start the service

00:29:56.995,00:30:02.000
for us so we can try things out.
So, in order to do this, we were
running it's administrator. Uhm,

00:30:04.436,00:30:09.441
the other demo that I'm about to
show, uh, is not running its
administrator. [indistinct

00:30:14.046,00:30:19.051
talking] Yea... So, in this case
we basically are reading some,
uh, state from basically a, the

00:30:26.658,00:30:32.497
kernel's being loaded at random
address - so, from user space
not elevated at all we can, uh,

00:30:32.497,00:30:37.502
read, read the address of that,
uh, entry point into the kernel.
And, uh, understand where the

00:30:40.072,00:30:46.011
kernel is loaded with a, with
further attacks that depend on
where, where the kernel loaded

00:30:46.011,00:30:51.349
into, uh, into the address
space. We also know that the
base of the, the page tables is

00:30:51.349,00:30:56.822
this, uh, second value, so,
while we're building a payload
we can, we can use this value

00:30:56.822,00:31:01.760
to, uh, make that easier. Yeah,
so, there's also, uh, the SMEP
bit and, uh, NCR 4 where we can

00:31:08.567,00:31:13.572
also, like, in this case we, we
read CR4 we saw that it was
enabled, we cleared the value,

00:31:16.108,00:31:21.613
we wrote it back, we see that
it's still. It's, it's disabled
now, uh, and, and there is a,

00:31:21.613,00:31:23.615
uh, a feature in Windows called,
uh, patchguard that will go and
look for, uh, configuration of

00:31:23.615,00:31:25.617
the system, look for dangerous
things and, uh, we found a
write-up that meant, that said

00:31:25.617,00:31:30.622
that they were able to measure
that they're reading these MSRs
every 30 minutes, so, that's a

00:31:44.569,00:31:51.409
lot of time to, uh, get your
malicious code to, uh, run. And,
and we were testing, it didn't

00:31:51.409,00:31:57.816
crash, even after like 45
seconds. We did see some cases
where it would crash after the

00:31:57.816,00:32:04.356
MSR but it's, uh, it seems like
plenty of time in order to, uh,
to get your payload working if

00:32:04.356,00:32:09.361
you wanna use this for...
[indistinct talking] What's
that? [indistinct talking] And,

00:32:12.097,00:32:18.436
and this was in a 19-03 system,
so it's latest, has the latest
version of, uh, of, uh,

00:32:18.436,00:32:23.441
patchguard. So, some, some of
the problems - we, we took all
of these drivers. We uploaded

00:32:30.148,00:32:35.620
them to Virustotal none of the
drivers came back as malicious,
they came back via Windows, but

00:32:35.620,00:32:41.626
AV, AV isn't really helping us
with this issue because, because
you can use a lot of these

00:32:41.626,00:32:47.833
drivers to attack AV and bypass
some of those. Some of the, some
of those protections. So, we

00:32:47.833,00:32:53.238
are, we are hoping that we could
actually fix this so, Microsoft
does have a, a

00:32:53.238,00:32:58.243
virtualisation-based security
and hypervisor enforced code
integrity. Uhm, those are only

00:33:02.113,00:33:08.286
present from 7th generation CPU
and newer, also, there are
compatibility issues that

00:33:08.286,00:33:15.126
prevent you from turning this on
and each VCI will help against
some of these issues but, uh,

00:33:15.126,00:33:17.128
not all. And, I have a, Kaby
Lake laptop that is pretty new
and soul support it but I have

00:33:17.128,00:33:22.133
compatibility issues and I
haven't been able to actually
turn on this feature, uh,

00:33:27.239,00:33:32.244
enterprise device guard policy
that you could configure to
block known drivers once they're

00:33:35.380,00:33:40.919
known to be vulnerable but there
hasn't been any really
industry-wide fix for this yet.

00:33:40.919,00:33:45.924
So, so we're hoping to, uh, fix
that. So, all of these are, all
of these drivers that we found

00:33:48.260,00:33:52.530
originally were just through
manual analysis. So, we were
looking how could we actually

00:33:52.530,00:33:57.369
automate this? And started
looking at the angr, angr
framework for, uh, symbolic

00:33:57.369,00:34:02.741
execution. And, uh, if you're
not familiar with anger or
symbolic execution, uh, it

00:34:02.741,00:34:09.648
essentially allows you to allow
you to dynamically execute the
parts of a program and every

00:34:09.648,00:34:15.787
time you get to a conditional
branch it will try to execute
both paths and see what happens,

00:34:15.787,00:34:20.792
so it's really useful but it's
easy to, uh, run into issues,
but, so, I got an initial script

00:34:23.495,00:34:29.834
just to try out the idea of
working in about a day and it
works really well in some cases.

00:34:29.834,00:34:36.308
In other cases, the code is
complex enough that you run out
of memory and you have a, a

00:34:36.308,00:34:41.947
state explosion because there
are so many conditional branches
that it had issues. For, for

00:34:41.947,00:34:47.652
what that actually looked like
for trying, trying it out, we,
we had a specific driver that we

00:34:47.652,00:34:49.654
know is vulnerable and we know
the, the address of the handler
that, does that mean IOCTL

00:34:49.654,00:34:52.190
dispatch, is it a particular
address? And we know the address
of the right MSR opcode that we

00:34:52.190,00:34:57.195
want to, uh, search for and see
if this is actually taking data
that's passed from, from user

00:35:05.270,00:35:10.275
space, so essentially you just
need to load the driver and in
this case we don't care about,

00:35:12.577,00:35:17.582
uh, libraries, so. We'll not
load libraries and then create
a, uh, an angry execution state

00:35:22.087,00:35:28.927
object that, uh, starts
execution at the IOCTL handler,
the dispatch function. And, we

00:35:28.927,00:35:33.932
can take that, uh, IO request
packet, that structure and, uh,
basically create symbolic

00:35:36.868,00:35:42.874
regions for those parts and set
pointers so that when we're
starting execution for, uh, the

00:35:42.874,00:35:47.879
IOCTL handler, it will have
these, uh, these, uh, symbolic
regions regions as, as the input

00:35:50.882,00:35:55.887
data that we're passing into
this function. Then you can, uh,
create sim, simulation manager

00:35:58.289,00:36:03.228
and just let it start executing
code from the, uh, from the
IOCTL entry point, give it a

00:36:05.964,00:36:11.302
target address of the, uh, write
MSR address. So, we're trying to
reach that address. If it's

00:36:11.302,00:36:16.307
found, we just print that we,
we've print that a path was
found and whether the uh, input

00:36:19.511,00:36:26.351
data to this write MSR is taken
from the input buffer if, if
it's symbolic data. And, it, it

00:36:26.351,00:36:33.024
worked, it completed in less
than 5 seconds and we proved
that when we reach this, uh,

00:36:33.024,00:36:38.029
MSR, write MSR opcode, uh, that
the address and, uh, data will
be written to the CPU register,

00:36:43.501,00:36:48.606
is, uh, included in the input
buffer. It even tells you the
specific D-word offset into the

00:36:48.606,00:36:53.611
input buffer for where you need
to structure your, your data to,
to talk to this driver. And it,

00:36:56.014,00:37:02.187
it completed in, uh, 5 seconds -
literally, the last 3 slides
that I showed you - that's the

00:37:02.187,00:37:07.625
entire script to, uh, to do this
and prove that, that this is
actually taking input from the

00:37:07.625,00:37:14.599
user. Uh, another issue is that
we want to automatically find
that IOCTL handler ourselves.

00:37:14.599,00:37:20.638
So, we don't have to manually
open every driver; do some
disassembly, find that prime,

00:37:20.638,00:37:25.643
that initial dispatch function,
so... WDM, uh, Windows Driver
Model, uh, drivers, it's a lot

00:37:29.080,00:37:34.519
easier, we can easily just set
a, a, uh, memory write
breakpoint on that struction,

00:37:34.519,00:37:40.892
uh, structure element in the
driver object. And, uh, this,
this script right here, that's

00:37:40.892,00:37:47.532
all you need to find the IOCTL
handler for these, uh, WDM
drivers. We can also, uh,

00:37:47.532,00:37:51.302
automatically find the IOCTL
number, so, you have a driver,
you have a write MSR - it'll

00:37:51.302,00:37:58.276
tell you that there's a write
contr, control register or an
MSR. It'll tell you the number

00:37:58.276,00:38:03.214
you need to pass for the IOCTL,
it can tell you what values you
also need to put into, into the

00:38:05.250,00:38:11.022
input buffer. So, in this case,
uh, this list of constraints
down at the bottom, were

00:38:11.022,00:38:17.962
automatically detected and, uh,
angry can actually simplify
those for you. So, these 3

00:38:17.962,00:38:24.402
constraints at the bottom
basically are simplified to the
value of the first D-word in,

00:38:24.402,00:38:30.909
uh, the input buffer, needs to
before. And then the second, uh,
there, the third and fourth

00:38:30.909,00:38:36.080
keywords are the value that's
written to this, uh, CR4
register. So, we can actually

00:38:36.080,00:38:42.787
find a lot of information
automatically. Uh, there are
some problems with this. Uh,

00:38:42.787,00:38:48.593
angr is based on VEX which was
part of Velgrined, so, it was
all user space applications.

00:38:48.593,00:38:53.097
And, as far as we could tell, it
was never used to analyse
privilege code. So, it really

00:38:53.097,00:38:55.099
has decode errors for when it
runs into some of these
privilege opcodes. So, the

00:38:55.099,00:38:57.101
decompiler and the instruction
lifter, it lifts into, into an
intermediate representation and

00:38:57.101,00:38:59.103
that part of the code it runs
into a decode error and doesn't
know what to do. So, there is

00:38:59.103,00:39:04.042
some functionality that was
added in the Python framework on
top of that where you can write

00:39:16.454,00:39:21.459
a Python module to kind of
emulate or implement what this
opcode should have done. So, we,

00:39:23.761,00:39:28.199
we were able to take advantage
of that and make it work more
reliably on, on more, uh,

00:39:28.199,00:39:34.639
drivers. So, one other problem
is that it currently only
supports, at least the tool that

00:39:34.639,00:39:39.644
we wrote, only supports, uh,
WDDM drivers, we do detective
WDDM driver and have some ideas

00:39:41.946,00:39:47.185
on how to make it work with WDF
drivers also - it's just a
little bit more indirection than

00:39:47.185,00:39:54.058
hooking but it should be fairly
straightforward. Uhm, and then
there's the issue that some

00:39:54.058,00:39:58.229
drivers are a little bit more
complex and cause it to run out
of memory. I've had it run out

00:39:58.229,00:40:03.234
of 64 gigs or RAM, so, we, uh,
we, we need to fix a few things.
I'll, uh, I'll let Mickey go

00:40:08.673,00:40:13.678
here. So, uhm, now for a little
bit of naming, shaming and
faming. Uh, we talked about 20

00:40:19.417,00:40:24.422
total vendors, these are the
ones we can, uh... Disclose
right now. Some are not, uhm,

00:40:26.624,00:40:33.298
ready to release updates, some
did not respond, some said
"acknowledged" but we haven't

00:40:33.298,00:40:39.570
heard back from. Uhm, and some
are really working on a fix but
because they're in regulated

00:40:39.570,00:40:44.008
environments they require more
time to go through
certifications. So, we're not

00:40:44.008,00:40:48.913
gonna disclose them. We're gonna
go through, uhm, everything
we've been through - talking to

00:40:48.913,00:40:53.918
these people, to these guys and,
and these companies, since, uh,
late April, early May. Uh, we're

00:40:56.020,00:41:00.958
gonna go start from the best
example from the worst. Uhm, the
best example we had is with

00:41:04.629,00:41:09.634
Phoenix, Phoenix is one of the
big 3 IPVs. I have never heard
or experienced a better response

00:41:13.504,00:41:18.509
than Phoenix - we, we started
with the first disclosure batch
to send out to vendors, uhm, I

00:41:20.745,00:41:25.583
think Monday that week, and we
said yea "We'll finish it up,
we'll send it on Tuesday".

00:41:25.583,00:41:32.423
Obviously it ended up Friday 5pm
and we're sending out the emails
and we went home. Saturday

00:41:32.423,00:41:37.995
morning, we got an email back
saying "We acknowledge the
issue. We're walking on a fix".

00:41:37.995,00:41:43.000
Within 6 weeks they already had
a fix ready to deploy to
customers. This is textbook -

00:41:45.903,00:41:52.777
like I've never ever experienced
anything like this - especially
with a driver. Uh, we also sent

00:41:52.777,00:41:57.782
an email to, uh, Cert and CertCC
- we, for some reason, it got
lost in communication with US

00:42:00.785,00:42:06.324
Cert. Uh, ended up calling them
a couple of days ago and they
did receive it, so, I dunno

00:42:06.324,00:42:11.162
what's going on from that
perspective - we did get a
receipt, but, uhm, no actions

00:42:11.162,00:42:16.167
were, uh, were described to us
from, uh, from certs. Microsoft,
uh, now that's a story - so,

00:42:21.839,00:42:26.844
Microsoft's model of, of the
operating system is basically
"Give 3rd parties the option to

00:42:29.313,00:42:35.520
write their driver", right? It's
like "I have a company, I have a
product - here- write code to

00:42:35.520,00:42:40.525
interface with my product.".
Uhm, the problem with this class
of issues is, a lot of drivers

00:42:43.895,00:42:50.568
fall into that caveat where
some, someone might write bad
code. So, what can Microsoft do

00:42:50.568,00:42:57.041
about it? They can just say,
"Hey, people, write some code
but don't make it bad". It's a

00:42:57.041,00:43:02.914
bit problematic, so, we had a,
am initial discussion with them
and, and sent them a note saying

00:43:02.914,00:43:09.087
"Hey, what's your, what's your
view about this?" and we got a
response from MSR CTR1 that said

00:43:09.087,00:43:15.393
"Not a problem, uh, talk to you
later". We sent another email
later on, it, asking if they're

00:43:15.393,00:43:20.665
really sure - it was a back and
forth. And the end of the day,
after, uh, quite a few rants on

00:43:20.665,00:43:27.338
Twitter, we ended up getting to
communicate and, and ended up
doing a couple of face-to-faces

00:43:27.338,00:43:33.111
here in Vegas. Uh, it changes
the, changes the entire
conversation. Uh, I'd like to

00:43:33.111,00:43:39.851
say thank you to Chris Anderson
and Nate Warfield for being very
good at communicating and

00:43:39.851,00:43:46.691
forthcoming an trying to help.
Also to Kimberly, Merissa, Mary,
Eustice and Gouraf, I hope I'm

00:43:46.691,00:43:51.696
not bothering that name for
helping from MSRC side for
helping clean everything up and,

00:43:53.965,00:43:58.970
uhm, help sort things out. Now,
the worst driver award goes to
ASRock, uhm, because this is 1

00:44:06.744,00:44:11.749
of 4, I think. 1 of 4 signed
drivers that does all of this,
so, it's quite impressive. The,

00:44:19.123,00:44:24.128
ugh, the "You Tried!" award goes
to Nvidia, for telling us the
driver that we found is

00:44:26.664,00:44:31.669
internal, so it doesn't narrate
a CVE because it, it requires a
security "hardening", uh,

00:44:34.171,00:44:39.176
effort, internally. Although it
is distributed by MSI on their
website as a tool for updates

00:44:41.846,00:44:48.152
for their graphics cards. So,
it's internal tool but it's
distributed by an OEM on the

00:44:48.152,00:44:53.157
internet. Okay. The worst ones
are these 4 that did not
respond. So, our of these 4,

00:44:58.729,00:45:04.902
there is 1, uhm, that completely
doesn't respond. So, at least
some of them sometimes respond -

00:45:04.902,00:45:11.309
but Realtech, I have had, uhm,
researchers during this time in
Vegas, we talked to each other

00:45:11.309,00:45:16.280
and we'd are notes and we
discuss, you know, experiences
like "Oh, this vendor sucks,

00:45:16.280,00:45:21.285
this vendor's great". And, no
one in Realtech is answering any
emails, so, if anyone from

00:45:23.454,00:45:29.293
Realteach sees this, please
check your inbox, inbox and
reply with something. [laughter]

00:45:29.293,00:45:34.298
Uhm, a few deliveries are coming
out, so, Phoenix did June 21st
within amazingly quickly. Uh,

00:45:37.735,00:45:44.241
already sent to Williams, so the
fixes that Phoenix, Insyde and
AMI will release - the 3 big

00:45:44.241,00:45:51.215
BIOS vendors are gonna get
distributed to OEMs. And, uhm,
OEMs will then distribute it to

00:45:51.215,00:45:56.220
customers. Uh, Intel had a fix
on July 9th, Huawei in July
10th, uh, it's the Insyde is

00:46:00.591,00:46:05.096
today, that's the next slide.
And a couple more are coming out
next week, we can't talk about

00:46:05.096,00:46:10.101
it. And, ugh, a few more during
the, until the end of the year.
Uhm, Insyde was kind enough to

00:46:14.405,00:46:19.410
send us this, uh, statement -
I'm not gonna go through it but
the gist is they're fixing it.

00:46:21.846,00:46:25.950
Microsoft send us this
statement, I'm not gonna go
through this because we've been

00:46:25.950,00:46:30.955
through enough. Uh, and now
we're onto the conclusions. So,
basically, bad drivers are bad,

00:46:34.325,00:46:39.330
uhm, people that write ring-0
code and write it badly are a
danger to society. [laughter]

00:46:45.036,00:46:50.608
Uhm, these, some of these
drivers. Like the easiest way to
fix this is "Okay, I'm a vendor,

00:46:50.608,00:46:56.080
I wrote a driver, I own up to
it, I revoke the certificate."
Done! Can't load it anymore in

00:46:56.080,00:47:01.852
Windows 10, at least. Uhm, so
getting vendors to, to, to
revoke the certificates is, is

00:47:01.852,00:47:07.925
not as easy as sometimes. Like,
what we had with Phoenix, but,
uhm, it will be a great help to

00:47:07.925,00:47:12.930
do this, like, the biggest
majority of the, the majority of
drivers that we've seen are old

00:47:15.833,00:47:20.838
- they're not brand new 2018,
2019, 2017 - some of these go
back to 20, 2008. So, just

00:47:24.842,00:47:31.549
revoke the certificates. This is
like a big problem, it's not
just specifically, it's just a

00:47:31.549,00:47:37.888
class, again, uhm, multiple
researchers have disclosed these
drivers separately at a time but

00:47:37.888,00:47:43.260
the problem is systemic and we
wanna, we wanna hope that, we're
hoping that at some point it can

00:47:43.260,00:47:47.798
be fixed on a larger scale.
Windows 10 is, is moving towards
this, there's mitigations in

00:47:47.798,00:47:54.038
place, there's HVCI, uhm,
Virtual Based Security, but, you
know, you have to have 7th gen

00:47:54.038,00:47:59.043
CPU or above for HVCI to work,
and even then not always does it
work. We are gonna release all,

00:48:02.113,00:48:07.118
all our code. C-sharp, C++ and
Powershell examples on GitHub
with the latest slides and the

00:48:10.054,00:48:15.059
videos and our tracking for all
the drivers and where you can
find them. Please check this

00:48:18.129,00:48:23.134
GitHub on August 13th, uh, we
did have this internal debate of
whether to release it today or

00:48:25.936,00:48:32.276
in 3 days. But, because it was
so close, we just decided to
sort everything out, get through

00:48:32.276,00:48:37.281
Vegas and upload it on the 13th.
And I think we're done.
[applause]

