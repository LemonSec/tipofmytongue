00:00:00.100,00:00:05.105
>>Omer is now gonna present
Exploiting Windows Exploit
Mitigation for ROP Exploits. I

00:00:07.207,00:00:12.546
knew exactly what I was doing
there. Alright, go ahead Omer.
Have a good time, dude. >>K.

00:00:12.546,00:00:17.551
Hello everyone. Thank you for
coming. Let me get sorted and we
can start. Okay, for first

00:00:20.687,00:00:25.692
things first. Uh, and work.
Okay. So, I better your parents
taught you well and taught you,

00:00:29.696,00:00:34.134
told you don’t listen to
strangers so I will, I will
introduce myself. I am Omer

00:00:34.134,00:00:40.274
Yair. I manage the endpoint team
at Javelin Networks. We are a
small start-up that uh, decided

00:00:40.274,00:00:45.045
to protect your endpoint on the
enterprise front, to protect
your active directory from the

00:00:45.045,00:00:50.050
endpoint and Symantec uh,
believed in us, and acquired us
a few like, 9 months ago. Uh,

00:00:52.319,00:00:58.959
and though I’m still not sure
how I am supposed to pronounce
the new title. I am also a

00:00:58.959,00:01:05.432
photographer and you can follow
me on twitter. So, I want to
start with the guise of this

00:01:05.432,00:01:10.737
talk. It’s uh, quote by Gilles
Deleuze, a French philosopher
and he said the concept is a

00:01:10.737,00:01:14.908
brick. It can be used to build a
courthouse of reason or it can
be thrown through the window.

00:01:14.908,00:01:20.180
And throughout this talk, we, we
will identify all those bricks
that make up ROP exploits,

00:01:20.180,00:01:25.185
Windows mitigations, Windows
exploit mitigation and we will
see how we can use those to

00:01:25.185,00:01:30.190
break windows. So, what’s on the
agenda? We’ll start talking
about ROP uh, 101, I will dumb

00:01:32.626,00:01:37.631
down the things as much as
possible, make it simple so
everyone can understand, then we

00:01:37.631,00:01:42.169
will talk about Windows exploit
mitigations and we see how we
can abuse them. Next, about ROP

00:01:42.169,00:01:46.773
mitigations and we’ll see how we
can bypass them, and lastly,
there will be a demo where you

00:01:46.773,00:01:52.012
will clap hands and if you will,
we will all behave yourself
there will be a little surprise

00:01:52.012,00:01:58.118
too. So, let’s start. We can’t
start talking about ROP exploit
without mentioning the, the

00:01:58.118,00:02:02.389
smashing the stack for fun and
profit. And, is there anyone in
the audience that ever heard the

00:02:02.389,00:02:08.195
term for fun and profit, and
profit? Please raise your hand.
Yeah, it’s quite common and I

00:02:08.195,00:02:12.766
hope you all know what the
source of this uh, term came
from and it’s an article by

00:02:12.766,00:02:18.839
Aleph One that we wrote in 96
about the mechanics of uh, stack
overflow and we can’t talk about

00:02:18.839,00:02:24.277
stack overflow without expanding
how stack semantics works. So,
if you call uh, a function in a

00:02:24.277,00:02:30.517
32 bit processor, uh, you first
need to push the parameters on
the stack and the stack on my

00:02:30.517,00:02:34.955
slides will go upwards and then
with the call out code is
issued, the return address is

00:02:34.955,00:02:40.260
pushed in the stack and the
extraction point jumps to the
function that you called. Now

00:02:40.260,00:02:44.598
that function will allocate
space for itself on the stack,
do its stuff, and eventually it

00:02:44.598,00:02:51.204
will de-allocate the space and
the read opcode will pop the
return address from the stack.

00:02:51.204,00:02:55.642
So, how stack overflow works?
Well let’s take hypothetical
example. Completely hypothet,

00:02:55.642,00:03:01.181
hypothetical. Let’s say you have
a program that uh, gets an input
and looks for part, for details

00:03:01.181,00:03:07.054
about the user. So, it first
allocates its, its, uh, space
for the stack, then it uses get

00:03:07.054,00:03:12.492
ask to steal a buffer from the
user. Now, a normal user will
just fill up the few bytes of

00:03:12.492,00:03:17.831
the buffer, but a hacker will
start overwriting the buffer
until eventually the hacker

00:03:17.831,00:03:24.738
overrides the return address. So
now, if you are an elite hacker,
you won’t just write random

00:03:24.738,00:03:29.709
bytes, you will write your shell
code instead and on the place
that you write the return

00:03:29.709,00:03:33.747
address, let’s say a
hypothetical again, you know the
address of the stack, you can

00:03:33.747,00:03:38.552
just write the address of the
stack where your shell code
starts. So now, when a return

00:03:38.552,00:03:42.756
code will be issued, the
instruction pointer will jump to
the shell code on your stack and

00:03:42.756,00:03:48.528
now you can run a shell. Now,
this is not a hypothetical at
all. That was the exact source

00:03:48.528,00:03:53.200
code and the exact buffer
overflow, exact shell code that
was used on the Morris Worm and

00:03:53.200,00:03:58.872
that was 1988. Almost a decade
before Aleph One published his
article on uh, stack overflow.

00:03:58.872,00:04:04.077
So, the security eye industry
actually knew about stack
overflow and the potential

00:04:04.077,00:04:09.983
hazardous disasters that it can
make, but still didn’t do
anything and was so bad that it

00:04:09.983,00:04:14.387
prompted the formation of the
Shell Code CERT Coordination
Center. So, again, you would

00:04:14.387,00:04:18.291
think that after Aleph One
published his article, the
security industry will wake up

00:04:18.291,00:04:24.464
and start protecting everyone,
but no, on 2003, all you had to
do to exploit a buffer overflow

00:04:24.464,00:04:29.836
was to write this simple html
page and that’s a CVE by Matt
Miller, and what happened behind

00:04:29.836,00:04:33.707
the scene is that internet
explorer had just replaced every
slash character with an

00:04:33.707,00:04:38.678
underline slash underline, which
caused it to miscalculate the
amount of bytes that it needed

00:04:38.678,00:04:43.683
to write and then caused it to
write like, the first buffer to
the stack and you had the

00:04:43.683,00:04:47.921
ability to override the return
address and then you could write
the shell code. But now this is

00:04:47.921,00:04:54.394
not the uh, uh, an OS where we
can guess the address of the,
the stack. This is Windows. It’s

00:04:54.394,00:05:00.000
a modern OS. Well, then Matt
Miller used a different trick.
He knew that the system dll’s

00:05:00.000,00:05:05.172
was always loaded to the same
address. So, he looked on those
dll’s and found an opcode which

00:05:05.172,00:05:10.076
is jump esp, which is, was
always on the same address. So
instead of writing the address

00:05:10.076,00:05:14.915
of the stack, he wrote the
address of that command. So now
when the returning, the return

00:05:14.915,00:05:20.086
opcode is issued, the
instruction pointer jumps to the
jmp esp, and after it uh,

00:05:20.086,00:05:24.858
executes jmp esp, now the
instruction pointer points to
the stack and you can pop calc,

00:05:24.858,00:05:30.197
if you want. Now you might ask
yourselves, well, how is it even
possible to run code from the

00:05:30.197,00:05:36.169
stack? Shouldn’t it just be read
write memory? Well, that was,
uh, possible a long, long time

00:05:36.169,00:05:42.209
ago. Until DEP came in, came in
on Windows XP Service Pack 2.
And DEP, Data Execution

00:05:42.209,00:05:47.614
Prevention, actually enforces
the read write or more precisely
the non-execute code, uh,

00:05:47.614,00:05:53.019
memory. Because Windows
throughout time, always marked
that memory is only read write,

00:05:53.019,00:05:58.024
but the CPU ignored that, eh,
the CPU ignored that, and eh,
Windows had to write another bit

00:06:00.160,00:06:06.099
which is called Annex Bit, which
forces the CPU to actually not
execute code in that, uh, area.

00:06:06.099,00:06:11.738
And DEP was actually the
cornerstone for ROP. It actually
made ROP what it is today. And

00:06:11.738,00:06:17.510
the reason why is now that, now
is because now we need a bridge
between actually uh, exploiting

00:06:17.510,00:06:23.316
a software and writing out shell
code to that uh, memory, and
running it. So, ROP fills the

00:06:23.316,00:06:28.888
bridge between those, uh, two
things. Now another thing you
might ask yourself, what do you

00:06:28.888,00:06:33.860
mean that all dlls are loaded to
the same address? Well, again,
that was the reality back then.

00:06:33.860,00:06:39.566
Until ASLR, auto space layout
randomization came. And, with
ASLR, every time you boot your

00:06:39.566,00:06:43.903
machine, Windows randomized the
base address feature of each dll
so now you can’t guess the

00:06:43.903,00:06:48.975
address, you need to find it.
Now, it is effective mostly on
remote, uh, exploits because if

00:06:48.975,00:06:53.146
you can run code on your, on the
same machine, let’s say you’re
trying to exploit the privilege

00:06:53.146,00:06:58.418
escalation uh, bug, well, you
can just run a benign a program
that loads, loads those dll, and

00:06:58.418,00:07:05.025
you know the address of those
dll’s. So, I want to take a
little sep, step back to help

00:07:05.025,00:07:09.996
people that want to write
exploits today to see some
spets, steps that we overlooked

00:07:09.996,00:07:14.401
when we saw the, the stack
overflow. Because stack overflow
looks very simple, you just

00:07:14.401,00:07:18.471
write byte and you control the
machine. So, let’s see what
those are if you want write

00:07:18.471,00:07:22.575
exploits today. First, you need
to have vulnerable software. You
need to have access to that

00:07:22.575,00:07:27.113
software so you can run your
code again, and again, and again
until you perfect your exploit

00:07:27.113,00:07:32.919
to make it running well. Next,
we had a way to uh, to get that
information so on th Morris

00:07:32.919,00:07:38.491
case, we knew the address of the
stack, on the Matt Miller CV, we
knew the system function

00:07:38.491,00:07:42.929
analysis. Today, you will need
an arbitrary read vulnerability
that will allow you to leak

00:07:42.929,00:07:48.535
those addresses when you, on
your exploit. Next, you need a
way to manipulate memory. So,

00:07:48.535,00:07:53.473
stack overflow, obviously you
write the stack so you have an
way to uh, to write into the

00:07:53.473,00:07:59.012
memory. Ah, you have other ways
to write into memory, like heap
overflow or use after free,

00:07:59.012,00:08:04.250
which sometimes allows you to do
that. And if you want to write
exploit today, this kind of

00:08:04.250,00:08:08.321
vulnerability is called
arbitrary right. So, if you
arbitrary read and arbitrary

00:08:08.321,00:08:13.159
write, you’ve probably have a
way to exploit the software. And
the last step, with, which I

00:08:13.159,00:08:17.997
think is the most important to
understand, is that you don’t
actually write code to the

00:08:17.997,00:08:22.569
target, uh, process you are
trying to exploit. When you
hijack the code execution, it’s

00:08:22.569,00:08:27.173
actually uh, a by-product of
both writing memory into that
process and the normal

00:08:27.173,00:08:32.278
execution. So, if you think
about thread ROP code simply
jumps into the shell code from

00:08:32.278,00:08:37.450
the Morris Worm is the normal
flow of execution of the program
and we abuse that normal flow of

00:08:37.450,00:08:43.256
execution to run our shell code.
So, now, we’re ready to play.
So, let’s talk about

00:08:43.256,00:08:48.128
Return-Orient, Oriented
Programming or ROP and the term
was coined by Hovav Shacham in

00:08:48.128,00:08:52.165
his article The Geometry of
Innocent Flesh of, on the Bone,
which I think it’s one, one of

00:08:52.165,00:08:57.237
the most amazing titles someone
can give, and the main idea
behind it is to reuse existing

00:08:57.237,00:08:59.239
code in memory ah, by leveraging
the stacks semantics. So, let’s
understand how it works. In

00:08:59.239,00:09:01.174
normal flow of execution, when
your program runs, you, the
instruction pointer and ending

00:09:01.174,00:09:04.944
instructions control the, the
flow of the [stuttering], the
flow of execution. So anytime

00:09:04.944,00:09:08.782
instruction is issued, the
instruction pointer
automatically advances to the

00:09:08.782,00:09:13.119
next instruction. So, now you
have the instruct, instructions
running one after the other. In

00:09:13.119,00:09:15.121
ROP, this, the register that
controls the execution is the
stack pointer, or the stack. So,

00:09:15.121,00:09:17.123
you are looking for a set of
instructions that end with a
ret. So, now, the instructions

00:09:17.123,00:09:19.125
running, are running and when
the ret opcode is issued, the
next set of instructions will be

00:09:19.125,00:09:21.127
fetched from the stack, cause
that’s the return address that,
over there. So, now, you are

00:09:21.127,00:09:26.132
running another set of
instructions that are followed
by that, which fetches the next

00:09:35.208,00:09:40.213
set of instructions. So now the
stack pointer is controlling the
execution, or the stack, and

00:09:48.555,00:09:53.393
luckily for us, the stack is
read-write uh, memory, which we
can control if we have the point

00:09:53.393,00:09:58.398
of uh, vulnerability. Okay, so
one of the most important terms
on, on the ROP is gadgets. And a

00:10:01.768,00:10:05.338
gadget is a sequence of
instruction that usually ends
with a ret that allows you to

00:10:05.338,00:10:09.609
perform logic, logical
operations. Let’s say, you can
copy a value into memory, you

00:10:09.609,00:10:15.582
can change the memory permission
of uh, memory area into
executable, oh, load uh, val,

00:10:15.582,00:10:21.020
uh, values in specific registers
and many more. Let’s see an
example. If you want to write

00:10:21.020,00:10:26.125
an, an assembly code that uh,
write value into memory, you
will probably read write this

00:10:26.125,00:10:31.531
uh, this code. You will load a
value into eax, load a
destination into ecx and then

00:10:31.531,00:10:37.003
use the move opcode to move the
data from eax into the
destination of ecx. So, we are

00:10:37.003,00:10:41.141
working with a stack, so we can
replace the first two moves with
pops. Let’s see how it will work

00:10:41.141,00:10:46.246
in, in a ROP. So, you have the
stack on the middle and the
memory and code on the right and

00:10:46.246,00:10:51.518
the registers on the left. So,
we’ll start with the first set
of instructions which is pop

00:10:51.518,00:10:57.590
eax. Now you pop that beef into
eax and the ret opcode will take
us to the nest, next uh, set of

00:10:57.590,00:11:02.762
instructions which is pop ecx.
So, now we pop the others we
want to write to, the six, one,

00:11:02.762,00:11:07.400
two, three, zero, and now the
ret opcode will take you to the
next, uh, set of instructions

00:11:07.400,00:11:12.405
which is the move eax into ecx.
So, now we are writing the dead
beef into the address we wanted.

00:11:15.675,00:11:21.581
Ok, so, most of the talks on ROP
only mention 32 bits, but we are
in 2019 and it’s about time we

00:11:21.581,00:11:27.787
start talking about 64 bit
ROP’s. So, the main difference
between 32 and 64 bits ROP’s is

00:11:27.787,00:11:30.990
that when you pass the
parameters for a function, you
need to load the first four

00:11:30.990,00:11:37.063
parameters on rcx, rdx, r8 or
r9. Next you alloc, you need to
allocate 32 bits uh, in the

00:11:37.063,00:11:42.101
stack, you don’t need to fill it
with anything, and lastly, all
the other parameters are passed

00:11:42.101,00:11:48.875
uh, similarly to 32 bits. How
would we, how does it look like?
Well, if you want to call a 64

00:11:48.875,00:11:52.645
bit function that will receive
five parameters, again, to
execute the code, you first push

00:11:52.645,00:11:56.616
the first parameter to the
stack. Now we load the first
parameter into rcx, the second

00:11:56.616,00:12:02.155
into rdx, the third into r8, and
the fourth into r9. Next you
need to allocate the 32 byte,

00:12:02.155,00:12:08.561
uh, bit, bytes, and the call
instruction works similar to uh,
32 bit, and pushes the return

00:12:08.561,00:12:14.367
address on the stack. So, very
similar to 32 bit. And the
example, the example which we

00:12:14.367,00:12:19.939
will see today will be 64 bit.
So, what do we do with a ROP?
Usually you would want, you want

00:12:19.939,00:12:24.477
to call either virtual protector
or virtual alloc. Virtual
protect allows you to change

00:12:24.477,00:12:29.048
the, uh, protection of a memory
address to into executables so
if you have the shell code

00:12:29.048,00:12:34.053
already in memory, you just need
to change it in the executable
and jump to that address. Or we

00:12:34.053,00:12:39.792
can also allocate using virtual
allocate, virtual alloc in
executable memory and copy all,

00:12:39.792,00:12:46.132
uh shell code into that address
and run it. Now because those
two functions are the main, uh,

00:12:46.132,00:12:50.937
targets of ROP, the endpoint
protection will actually monitor
those functions and we will see

00:12:50.937,00:12:57.810
later how they do it. So, a lot
of the time when you write ROP,
most of the time will be wasted

00:12:57.810,00:13:03.516
looking for gadgets. And I want
to suggest you, just look at
ntdll and there are a few

00:13:03.516,00:13:08.821
reasons to do that. First, ntdll
is loaded into every process on
the systems. So, you don’t need

00:13:08.821,00:13:14.827
to uh, hope that the dll you,
you exploited before will be on
that, uh, process, because ntdll

00:13:14.827,00:13:20.900
is always there. So, if you find
the gadgets on ntdll, you might
be able to uh, use those gadgets

00:13:20.900,00:13:25.071
on every other exploit you will
use, and another thing that
contributes to that is because

00:13:25.071,00:13:30.610
ntdll is so close to the kernel,
then a lot of the code on ntdll
is handled at written assembly

00:13:30.610,00:13:33.913
and if you ever wrote assembly,
you know that you write it once
and you don’t touch it. It just

00:13:33.913,00:13:39.419
works. So, now, if you find a
gadgets that its handled an
assembly, most of the chances

00:13:39.419,00:13:43.122
that it works from the very
early version of Windows,
sometimes even Windows Vista and

00:13:43.122,00:13:46.125
uh, gadgets I will show you
works from at least Windows 7,
and that’s a lot, uh, that’s a

00:13:46.125,00:13:52.632
lot of power if you can write
your ROP once and use it on
every other exploit you will

00:13:52.632,00:13:57.770
ever need. So, let’s see some
gadgets on the ntdll. So, the
first is the function

00:13:57.770,00:14:04.110
RtlCopyLuid and that function
even look if you are copying
luid, it just copies 64 bytes

00:14:04.110,00:14:09.215
from a destination you give
into, from the source into the
destination and how it looks

00:14:09.215,00:14:14.987
like in, uh, assembly, well, it
simply loads the value from the
source, which is in rdx, it’s

00:14:14.987,00:14:20.226
the second parameter in rax and
copies that value into rcx,
which is the destination that it

00:14:20.226,00:14:26.132
gave you. But, because we are
writing uh, the stack we don’t
need to write, to write a return

00:14:26.132,00:14:30.002
address to the beginning of that
function. We can skip three
bytes directing to the second

00:14:30.002,00:14:35.942
opcode and now we can, we have
the gadget that can move rax
into the destination rcx. Now

00:14:35.942,00:14:41.748
there is a similar that exists
throughout all versions of
Windows, the move rcx into the

00:14:41.748,00:14:47.920
address in rax. It’s in the
function
rtlSetExtendedFeaturesMask and

00:14:47.920,00:14:53.793
you can use it everywhere, but
now you’ll need uh, a way to
load values into rax and rcx.

00:14:53.793,00:14:59.999
So, how you do it? Well, modern
compilers are aware of ROP and
will not emit pop rax or pop rcx

00:14:59.999,00:15:04.937
in the code. But what they do
emit is like add rsp 58 hex
bytes, which is just deallocate

00:15:07.006,00:15:13.079
in the stack for 58 hex bytes,
but apparently the byte 58 is
pop rax, so if you skip three

00:15:13.079,00:15:18.851
bytes into the middle of the ROP
code, you get pop rax thread and
that ROP code exists in a lot of

00:15:18.851,00:15:23.823
time in ntdll. And very
similarly, if you are looking
for pop rcx, you have the

00:15:23.823,00:15:30.797
multiplier xmm0 with xmm3, which
allows you to skip two bytes and
now you have pop rcx thread, so

00:15:30.797,00:15:37.470
now we have a way to copy, uh,
any value we want in memory.
Next, I want to show you another

00:15:37.470,00:15:43.509
cool gadget uh, which is on
ntdll chkstk. Again, handle it
in assembly, and I will soon

00:15:43.509,00:15:48.748
explain to you why, because it
first load the top of the stack
into r, uh 10, then the next

00:15:48.748,00:15:54.353
value into r11, then it simply
deallocates the step that stack
and returns. And it’s simply

00:15:54.353,00:15:59.425
like writing pop r10, pop r11,
ret. And how do I know that this
is handled at assembly, because

00:15:59.425,00:16:03.529
only if you read the internal
manual back then when Windows
wrote the code, you know that

00:16:03.529,00:16:09.368
this was a more efficient way to
write it. So, I didn’t want to
show you pop r10, but if you

00:16:09.368,00:16:15.675
skip just one byte, you have pop
r, uh, edx, so now you can load
both rcx and edx, so you have

00:16:15.675,00:16:21.848
two parameters you can test two
function, so that’s a thing we
can start working with. Another

00:16:21.848,00:16:26.953
very important gadget, well
obviously not pop r12, it’s the
pop rsp, and this gadget is

00:16:26.953,00:16:31.891
called the stack pointer – the
stack pivot. Because sometimes
when you have exploits, you can

00:16:31.891,00:16:37.463
only write uh, a limited amount
of bytes into the stack when you
hijack the stack. And this

00:16:37.463,00:16:42.268
gadget allows you to write the
whole ROP into the heap or a
place we can, we can, where you

00:16:42.268,00:16:47.673
can write a lot of code and
simply pivot the stack into that
address, so now you just need to

00:16:47.673,00:16:52.011
write a return address into the
uh, the stack pivot and you can
have ROP as long as you want.

00:16:54.046,00:16:58.184
Now one of the most powerful
gadgets on ntd, on ntdll is
actually a function. It’s called

00:16:58.184,00:17:01.988
NtContinue, which gets two
parameters, and I can tell you
that you can completely ignore

00:17:01.988,00:17:07.093
the second parameter as it
doesn’t do anything, and context
is a, uh, contains the processor

00:17:07.093,00:17:11.964
specifically used for data,
which means you can actually
replace all the values in all

00:17:11.964,00:17:17.503
the registers of the currently
running thread, so now you can
control not only rcx, rdx, r8 or

00:17:17.503,00:17:22.975
r10, - r9, you can also control
the stack pointer and the
instruction pointer. So, that’s

00:17:22.975,00:17:27.647
very powerful gadget that you
can use. Now, the last gadget
that I want to show is

00:17:27.647,00:17:34.086
RtlMoveMemory, when you want to
copy a large amount of data
between memory. Now, I like to

00:17:34.086,00:17:39.792
make analogies because it better
explains things and I want to
compare gadgets to the art

00:17:39.792,00:17:45.798
technique called Readymade.
Okay, so the Readymade Technique
was invented by a French artist

00:17:45.798,00:17:50.836
called Marcel Duchamp, and if
you think the French people only
contributed to the world by, uh,

00:17:50.836,00:17:55.708
inventing, uh, I don’t know,
like croissant, baguette,
democracy, and Mimikatz, then

00:17:55.708,00:18:00.646
they do, they did some other
stuff as well. So, this is a,
this art piece called Fountain

00:18:03.916,00:18:09.889
which is just urinal turned on
its side and signed with his
pseudo name of R. Mutt, which

00:18:09.889,00:18:15.728
Marcel Duchamp did, and what he
write about it explains exactly
I think what gadgets are all

00:18:15.728,00:18:20.333
about. Whether Mr. Mutt with his
own hands made this, the
fountain or not has no

00:18:20.333,00:18:25.972
importance. He chose it. He took
an ordinary article of life, and
placed it so that its useful

00:18:25.972,00:18:31.110
significance disappeared under,
under the new title and point of
view – created a new thought for

00:18:31.110,00:18:35.581
that object. And if you think
about it, that’s exactly what we
are doing with gadgets. And if

00:18:35.581,00:18:40.386
you follow this train of
thought, well, like the Fountain
is an art piece, our little

00:18:40.386,00:18:46.926
gadgets are little pieces of
virtual art. So, oui. So, if you
follow this train of thought,

00:18:46.926,00:18:51.931
and our gadgets are little
pieces of art, it actually makes
ntdll the public bathroom of

00:18:55.735,00:18:59.071
Windows. [audience laughing]
Okay, so with that thought in
mind, let’s move on to Windows

00:18:59.071,00:19:04.844
Exploit Mitigations. We’ll stack
with, we’ll start with stack
canaries and stack canaries

00:19:04.844,00:19:10.249
protect you against buffer
overflow. It works by first
generating a random base canary

00:19:10.249,00:19:14.587
value whenever a process is
started and then writes a cookie
into the stack using a

00:19:14.587,00:19:20.059
calculation and that base value.
Now, when the return opcode is
issued before the return opcode

00:19:20.059,00:19:25.297
is actually executed, it
performs the reverse, uh,
calculation and checks that the

00:19:25.297,00:19:31.570
value you got is the base canary
value. So, now we can actually
see if someone actually

00:19:31.570,00:19:36.575
override, overridden the, the
stack. And let’s see the code,
how it works. Uh, so it first

00:19:38.744,00:19:45.284
loads the base canary value into
ecx then it sorts the value with
a stack pointer so now it’s not

00:19:45.284,00:19:50.489
only uh, as an attacker, you
don’t only need to guess the
base canary value, you should

00:19:50.489,00:19:54.727
also guess the current stack
pointer, which is very hard, and
then you push the value into the

00:19:54.727,00:19:59.799
stack. Now before the return
opcode, uh, let’s say an
attacker actually managed to

00:19:59.799,00:20:03.736
override the stack, the, uh,
opcode will pop the, the canary
stack, the canary value from the

00:20:03.736,00:20:05.738
stack, will sort it again, and
will call a function that
verifies if the value was

00:20:05.738,00:20:07.740
changed, and because it did, it
will actually crash that
process. Next uh, mitigation I

00:20:07.740,00:20:09.742
want talk about is the Windows 8
ROP Mitigation which is a very
big name, but it actually just

00:20:09.742,00:20:11.744
detects, uh, stack pivot. So,
whenever are calling, uh, memory
functions on Windows, starting

00:20:11.744,00:20:13.746
from Windows 8, it will actually
check that the stack pointer
points to a valid location on

00:20:13.746,00:20:18.584
the stack. So, if you used uh,
stack pivot on your ROP, well
Windows will detect it and will

00:20:18.584,00:20:23.589
crash the software. And now,
it’s very easy to guess how we
can bypass it. You simply need

00:20:30.863,00:20:34.366
to make sure that the stack
pointer points to a valid
location on the stack when you

00:20:34.366,00:20:36.368
are calling, uh, Windows 32 API.
So, how can you, uh, fetch the
stack pointer value? Well, you

00:20:36.368,00:20:38.370
can abuse canary stack canaries.
So, for the first, I think
technical I show you, I call it

00:20:38.370,00:20:40.372
“A Little Bird Told Me” and we
will see how we can abuse by
using your ROP uh, stack canary

00:20:40.372,00:20:42.374
to fetch the value of RSP. And
uh, the main steps we will take
is we will first prepare the

00:20:42.374,00:20:44.376
registers, then we will call a
benign function that uses stack
canary, we will fetch the value,

00:20:44.376,00:20:48.614
that cookie from the stack. You
can treat it like a use or read
after free vulnerability, and

00:20:48.614,00:20:53.252
then we Xor that value with a
base canary value, and if you
remember before, I told you that

00:20:53.252,00:20:57.056
need to have a memory read
vulnerability, and if you have
that memory read vulnerability,

00:20:57.056,00:21:00.926
you can actually fetch that base
value from the dll you are
calling. So, we will assume that

00:21:00.926,00:21:04.430
value on the ROP already. So,
you have the code on the left.
On the top right, you have the

00:21:04.430,00:21:07.867
registers and, on the bottom
right, you have the stack. So,
the stack is also split between

00:21:07.867,00:21:10.703
the address on the left and the
values on the right. So, we will
start with a pop gadget which

00:21:10.703,00:21:12.838
will pop the values that we
want. We want to prepare the
registers, the important

00:21:12.838,00:21:15.374
registers we’re preparing now
are r6 and r9. R6 is a parameter
for the function we are calling,

00:21:15.374,00:21:19.211
and r9 you will see later what
it is used for. And now direct
will take us to the next, uh,

00:21:19.211,00:21:22.615
function, which is
RtIsValidProcessTrustLabelSid.
What it does I don’t even care.

00:21:22.615,00:21:27.987
The only thing I care about is
that it uses stack canaries and
it doesn’t mess up with uh, the

00:21:27.987,00:21:32.291
registers or the stack, or the
stack itself. So, first this
function allocates place on the

00:21:32.291,00:21:36.762
stack, next it fetches the base
canary value into rax, you can
see it over there, now, it will

00:21:36.762,00:21:40.099
store the value with a stack
pointer, so this is the uh, the
stack uh, cookie we’re using and

00:21:40.099,00:21:43.602
later it saves that value into
the stack, so you can see the
same value on rax, we can find

00:21:43.602,00:21:46.605
it now on the stack. Now,
because we passed the parameter
to the function, we passed the

00:21:46.605,00:21:50.509
bad parameter and the function
will start, uh, start going to
the exit, uh, into the exit uh,

00:21:50.509,00:21:55.514
sequence. So, now right before
the ret opcode, it fetches the
value of the stack uh, cookie

00:21:58.984,00:22:03.923
from the stack into rcx, now it
will store it with the, the
stack pointer, so now we have

00:22:09.795,00:22:14.800
the base canary value and it
called the functions that checks
the cookie, and because we are

00:22:20.906,00:22:24.243
innocent, we didn’t do anything
wrong here, we’re just calling a
function, well that function

00:22:24.243,00:22:26.245
will pass correctly, and now
before I execute this, I need to
remind you the canary cookie is

00:22:26.245,00:22:28.247
still on the stack, so we are
deallocating the stack, but
actually the stack memory is

00:22:28.247,00:22:30.249
like a memory in any other place
on the computer, so if anyone,
if no one written or overwritten

00:22:30.249,00:22:35.254
that value, that value is still
there. So, now we will jump to a
special uh, gadget that will

00:22:38.724,00:22:42.861
allow us to fetch that value,
and that gadget is in
RtlpExecuteHandlerForException.

00:22:42.861,00:22:48.267
Again, all the gadgets you are
seeing here are from ntdll and
this is handled in assembly and

00:22:48.267,00:22:52.471
you can guess it’s used for
exception handling, but this
gadget actually allocates place

00:22:52.471,00:22:59.144
on the stack and now it calls,
you can see that now we have the
cookie on the stack, uh, on our

00:22:59.144,00:23:03.682
stack value, and now it will
call a pointer that is
controlled by r9. So, if you

00:23:03.682,00:23:05.684
remember the first gadget we
used, we popped r9 to control
the value. So, can you guess

00:23:05.684,00:23:07.686
where we are going with this uh,
now? What gadget we will use?
Well, we’re going to the same

00:23:07.686,00:23:09.688
uh, pop gadget that we used
before. So, now we are not only
popping values from the stack

00:23:09.688,00:23:14.693
and the important thing is that
now r9 will receive the canary
uh, cookie. So, now we have the

00:23:18.330,00:23:23.335
cookie on r9, all we need to do
is to fetch the base canary
value and solve it. So, now the

00:23:34.480,00:23:39.485
ret opcode, you can see we take
to the next gadget, the pop rax,
you know that one. This will

00:23:44.490,00:23:49.495
fetch the base canary value into
rax and the ret opcode will take
us to the last uh, gadget, which

00:23:54.233,00:24:01.173
is solve r9 with rax and this is
part of our RtlpSytemCode
pointer, another function on

00:24:01.173,00:24:06.178
ntdll, and now we have the stack
pointer and we can pivot from
here and continue our ROP. Okay,

00:24:09.481,00:24:14.486
so now for the next mitigation,
we will talk about a control,
controlled flow guard (or CFG)

00:24:16.922,00:24:23.462
and the idea behind it is to
mitigate uh, controlled flow
hijacking of indirect calls.

00:24:23.462,00:24:28.467
What are indirect calls? Let’s
say you are writing CPP code and
the compiler needs to fetch the

00:25:19.118,00:25:23.222
address of the function from the
virtual table. So, it will
write, will emit code which

00:25:23.222,00:25:29.094
looks like this. It fetches the
address uh, of the func, of the
function into rax, then loads

00:25:29.094,00:25:35.000
the parameter rcx, rdx, and r9,
uh 8 for like, three parameters
for this function, and will

00:25:35.000,00:25:41.106
recall rax. So CFG actually
replaces rax. Wait, I’ll take a
step back. If you are an

00:25:41.106,00:25:45.511
attacker, you can actually
hijack the value that will be
saving to rax, and then you can

00:25:45.511,00:25:51.617
call any function you want or
any place in memory you want.
So, control flow guard actually

00:25:51.617,00:25:56.622
replaces the control rax with a
call to guard dispatc, icall
fptr. Uh, sometimes, it’s just a

00:25:59.324,00:26:05.998
check and there is another call
rax later. It depends on its
limitation, but actually this

00:26:05.998,00:26:11.503
function will check that rax is
valid. Function and no one
overridden it. How it does it?

00:26:11.503,00:26:17.376
It uses a huge, uh, bit field,
where every bit marks, uh, if a
function starts at the specific

00:26:17.376,00:26:22.648
address in memory. So, it’s
coarse grain. It uh, doesn’t
know if those are the functions

00:26:22.648,00:26:27.219
you actually wanted to call, but
uh, if there is a function
starting there and it doesn’t

00:26:27.219,00:26:32.724
matter what, what the dll it is,
it will say that it’s valid.
What it gives us is that uh, you

00:26:32.724,00:26:37.696
won’t be able to call in the
middle of function and then uh,
mess with the stack uh, the

00:26:37.696,00:26:42.701
stack itself. So, now comes the
questions, how can we abuse CFG?
Well, well I did. You remember

00:26:46.071,00:26:52.744
uh, I told you that the uh, cfg
replaces the call with a call
guard dispatch icall fptr? Well,

00:26:52.744,00:26:59.117
actually that function
translates into ntdll functions
called Ld, Lt,

00:26:59.117,00:27:03.655
LdrpValidateUserCallTarget and
that function checks the bit
field, you can see it and uh,

00:27:03.655,00:27:08.026
down below, you can see that if
it finds that there is no
function overwrote, it jumps

00:27:08.026,00:27:12.831
into
LdrpHandleInvalidUserCallTarget.
And if this name sounds

00:27:12.831,00:27:18.237
familiar, because that’s the pop
gadget we just used. So, thank
you Microsoft for introducing

00:27:18.237,00:27:23.475
one of the best gadgets for
ROP’s out there and making it
available in every, in every god

00:27:23.475,00:27:29.481
damn process on the system. Now,
I need to ask, sorry for all the
people exploiting this because

00:27:29.481,00:27:33.919
if Microsoft is watching this,
they probably take it away from
us. [audience laughing]. But

00:27:33.919,00:27:39.758
wait, [laughing] there is more.
If you will look at then, at the
nsdn, you will see there is a

00:27:39.758,00:27:41.760
uh, a function called
SetProcessValidCallTargets and
this function actually allows

00:27:41.760,00:27:46.765
you to tell CFG what addresses
are valid. So, let’s say if you
can potentially exploit uh, a

00:27:50.502,00:27:57.142
CF, uh an indirect uh, call
twice, you can first call
SetProcessValidCallTarget, set

00:27:57.142,00:28:00.979
the target you want as a valid
target, and then call it again.
So, what do you think? Do you

00:28:00.979,00:28:07.853
think Microsoft actually protect
the valid uh, uh function that
is published on nsdn? Well,

00:28:07.853,00:28:13.759
apparently, they do. So, nice
one Microsoft, but not that
nice, because if you look at

00:28:13.759,00:28:19.998
SetProcessValidCallTargets, it’s
actually a wrapper around an
ntdll function called

00:28:19.998,00:28:24.069
NtSetInformationVirtualMemory,
and do you not what?
NtSetInformationVirtualMemory is

00:28:24.069,00:28:29.141
actually valid code indirect
call target so we can call this
function, tell Windows that it’s

00:28:29.141,00:28:34.980
a valid target and then abuse
the same exploit again to run
whatever function you want or

00:28:34.980,00:28:38.584
whatever address you want. It’s
actually like telling Windows
those are not the exploits

00:28:38.584,00:28:43.889
you’re looking for [audience
laughing] and you know the force
is powerful on the weak minded.

00:28:43.889,00:28:48.894
Okay, so let’s talk about ROP
mitigations. And we will talk
about first about ROPGuard which

00:28:53.198,00:28:58.070
is the mitigation that is
implemented by most endpoint
security today, or at least a

00:28:58.070,00:29:02.774
variation of it. And it uses
strategic hooks on um, memory
functions. Like I told you

00:29:02.774,00:29:07.846
before, in the virtualprotect,
virtualalloc, all the matching
ntdll functions, and all the

00:29:07.846,00:29:12.618
functions that allow you to
create processes. And what it
does, it fetches the return

00:29:12.618,00:29:17.889
address from the stack and look
at the opcode preceding it to
see if there is a call uh, to

00:29:17.889,00:29:22.794
that uh, function and if there
is no call opcode before the
return address, then how did

00:29:22.794,00:29:26.765
this return address go through
the stack? Now, it doesn’t only
check that there is a call, it

00:29:26.765,00:29:32.938
also checks that the call opcode
actually uh, calls the function
that we’re hooking, so that’s

00:29:32.938,00:29:39.811
the ROPGuard in general. It does
have, uh, some more tricks, uh,
to do, but most of them simply

00:29:39.811,00:29:44.816
checks that there is a call
opcode. Now kBouncer is like a
ROPGuard on steroids, if you

00:29:47.085,00:29:53.025
would like. It actually utilizes
a feature on CPU called Last
Branch Records, which saves the

00:29:53.025,00:29:58.730
last indirect uh, jumps or calls
you had. So, you have uh, the
source and the target address

00:29:58.730,00:30:03.201
and you can actually perform
singular checks to ROPGuard on
those address too. So, if you

00:30:03.201,00:30:07.839
can think about it, ROPGuard
actually checks that the return
address, which is the future of

00:30:07.839,00:30:13.679
execution. kBouncer also checks
the past of execution that was,
that already happened. Now I

00:30:13.679,00:30:18.917
know that there are a few, very
few, uh, vendors that
implemented kBouncer, but most

00:30:18.917,00:30:24.589
of them only implemented
ROPGuard. Now, another
mitigation is ROPecker, which I

00:30:24.589,00:30:29.394
haven’t seen implemented
anywhere and the idea behind it
is to use the same mechan,

00:30:29.394,00:30:34.966
mechanism as uh, DEP, the dot
execution prevente, prevention,
to mark all the memory as

00:30:34.966,00:30:40.338
non-executable except, except
for the current uh, executing
page and the next one. So, now

00:30:40.338,00:30:46.011
whenever the execution jumps
outside of that, uh, area, there
will be uh, exception found, and

00:30:46.011,00:30:50.949
ROPecker will catch this
exception, and will perform
similar checks to uh, kBouncer,

00:30:50.949,00:30:55.954
but uh, because it happens a
lot, the heuristic that it use
are a lot weaker than uh,

00:30:59.324,00:31:03.895
kBouncer. Now, the last
mitigation I want to mention is
Shadow Stack, which is uh, a

00:31:03.895,00:31:09.468
collaboration between Microsoft
and Intel. It was first proposed
on 2016, but it was never

00:31:09.468,00:31:13.805
implemented. Uh, they suggest to
use two different stacks, one
the regular stack that you have

00:31:13.805,00:31:18.009
and we all know about, and
another matching kernel stack
that only saves the return

00:31:18.009,00:31:22.581
address so whenever there is a
call opcode, the return address
is pushed both to the user mode

00:31:22.581,00:31:27.152
stack and the kernel stack and
when there is a ret, it will pop
both addresses. And if the

00:31:27.152,00:31:33.492
addresses are uh, incorrect,
well, then you know that uh,
someone overwritten the stack.

00:31:33.492,00:31:38.497
Uh, but as I said before, it was
proposed in 2016, there is no
implementation of it, anywhere

00:31:41.399,00:31:46.805
that I know of, and let’s see
how we can bypass it. So, before
I tell you my effort, I want to

00:31:46.805,00:31:51.810
suggest you a paper to read or a
BlackHat talk to, to watch,
which is called The Beast Is In

00:31:51.810,00:31:57.549
Your Memory, by Daniel Lehmann
and Ahmad-Reza Sadeghi. And they
explain how you can bypass uh,

00:31:57.549,00:32:03.722
ROPecker and kBouncer uh, by
abusing their heuristics. And,
if you think about it, when they

00:32:03.722,00:32:08.360
say they are abusing their
heuristic, they are actually uh,
have an intention of being

00:32:08.360,00:32:13.698
caught. And I don’t like being
caught, so this is why I
invented uh, a new technique

00:32:13.698,00:32:18.603
called Rite of Passage, which
allows you to bypass uh, the ROP
mitigations without even being

00:32:18.603,00:32:25.076
caught or without going through
of the endpoint securities uh,
hooks. So, we collected a lot of

00:32:25.076,00:32:30.415
bricks so far and there is still
one more brick we need to
collect to understand how we can

00:32:30.415,00:32:36.555
completely break windows and
this one is the system call. So,
syscall is the way uh, you

00:32:36.555,00:32:42.060
transition from user mode to
kernel mode and whenever you
call uh, virtualprotect, or

00:32:42.060,00:32:48.033
virtualalloc, or any other Win32
function, it’s usually translate
into a system call function

00:32:48.033,00:32:53.471
inside ntdll. Again, handle it
in assembly. So, all of those
functions will look very similar

00:32:53.471,00:32:58.476
to NtAllocateVirtualMemory. It
first moves the first parameter
from rcx and saves it into r10.

00:33:01.379,00:33:05.717
Next, it loads the system code
parameter into eax and on the
case of NtAllocateVirtualMemory,

00:33:05.717,00:33:09.621
I think it’s Windows 10, the
value will be 18 hex. Let’s say
for NTVirtual,

00:33:09.621,00:33:14.626
NtProtectVirtualMemory, that
will be 50 hex. So, every
function has a different uh,

00:33:19.798,00:33:25.670
number. Next, it issues the
syscall uh, command, and the
syscall actually, is actually

00:33:25.670,00:33:31.910
the opcode that transitions into
kernel mode, but it always go to
the same function in kernel. So,

00:33:31.910,00:33:36.581
how does this function know
which function you want to run?
Well, it looks at eax. So now it

00:33:36.581,00:33:42.621
knows that because eax is loaded
with 18, 18 hex, you want to run
NtAllocateVirtualMemory. Now

00:33:42.621,00:33:47.325
when the function finishes in
the kernel, it will return to
user mode and the function will

00:33:47.325,00:33:52.764
continue. So, as I said before,
all the endpoint protection
usually hook those functions.

00:33:52.764,00:33:58.136
So, now you have a hook on that
function and if your ROP goes
through that uh, function, it

00:33:58.136,00:34:03.775
will go through the endpoint
hook. Some vendors did even go
as far as override the whole

00:34:03.775,00:34:07.212
function so you will not even
know that it’s there. Don’t why
they should do it, but you know

00:34:07.212,00:34:09.214
what? The jump hook end
function, let’s say
NtYieldExecution, which is

00:34:09.214,00:34:11.216
actually a function uh, that
does nothing, it’s like the
insecure function of a program,

00:34:11.216,00:34:13.218
if you want. It just tells
Windows, well I don’t know if I
have anything important to do

00:34:13.218,00:34:15.520
right now, maybe you decide if I
need to continue execution or if
someone else do the execution.

00:34:15.520,00:34:17.522
It’s a function that is no, has
no interest to anyone. Maybe for
us. But, uh, another thing that

00:34:17.522,00:34:19.524
you can see. How do I know that
this is handled it in assembly
or a marker that just copies the

00:34:19.524,00:34:24.529
same values everywhere? It’s
because NtYieldExecution doesn’t
get any parameter. So, why do

00:34:47.552,00:34:53.825
you need to pass r6 and r10 if
r6 holds no valuable data? Well,
that’s handwritten in assembly.

00:34:53.825,00:34:59.164
But we can actually abuse
NtYieldExecution of any other
function on ntdll which is not

00:34:59.164,00:35:04.102
hooked for our cause. And how do
we do it? Well, we will start
with a pop rax uh, ret gadget

00:35:07.739,00:35:13.812
that loads the system call into
rax. Next, we’ll use another
gadget that you’ve seen before

00:35:13.812,00:35:19.784
that allows us to load r10. So,
now we can also prepare the
first step parameter. And next,

00:35:19.784,00:35:23.655
we will not call
NtYieldExecution, we will jump
18 bytes directly into the

00:35:23.655,00:35:29.194
system call. And now, if you
look at it, we actually have a
way to issue any system call we

00:35:29.194,00:35:35.133
want using a ROP and because we
don’t pass through any of the
endpoint protection hooks, no

00:35:35.133,00:35:41.473
one will even know that our ROP
was there and no one will ever
catch us. So, I wrote a little

00:35:41.473,00:35:48.213
tool, which I will publish on my
GIT later. Uh, it’s called
ROPInjector, injector, which uh,

00:35:48.213,00:35:53.118
first allocates read write
memory into the target process,
uh, it writes the shell code

00:35:53.118,00:35:58.256
into that process. Then it will
create a new thread on that
process and injects the ROP into

00:35:58.256,00:36:03.161
that process using uh, uh, get
process, uh, get process context
and separate get thread context

00:36:03.161,00:36:05.263
and set thread context and
lastly, the ROP will modify that
exec, uh, area into read write

00:36:05.263,00:36:07.265
execute using either, either a
regular call to virtual protect
or a rite of passage call to

00:36:07.265,00:36:12.270
NtProtectVirtualMemory and
lastly, it will run the
shellcode. So, let’s see how it

00:36:27.919,00:36:32.924
works. Uh, okay [typing]. Okay,
so, so I want to change things a
bit, so I will not pop uh,

00:36:58.917,00:37:03.855
calculator with my demo. I will
actually inject a ROP into calc
with my, in my demo. So, you

00:37:07.092,00:37:12.197
need to pass the process id to
the ROPInjector so now we will
pass the process id of the

00:37:12.197,00:37:18.269
calculator and we’re injecting a
regular way of ROP and you can
see that our shellcode injected

00:37:18.269,00:37:24.676
uh, the created a new text
called PAWN3D, so obviously, it
worked. Now, I will tell you a

00:37:24.676,00:37:29.147
little secret. Endpoint
protection won’t protect all
process on your system. They

00:37:29.147,00:37:33.485
usually protect only the
vulnerable like FireFox. So now
when you try to inject, you can

00:37:33.485,00:37:38.990
see that the endpoint protection
caught the ROP. So, now we’ll
try to run FireFox again and we

00:37:38.990,00:37:43.995
will use the Rite of Passage ROP
uh, instead of the regular ROP.
Okay, and, then, then endpoint

00:38:06.985,00:38:09.921
protection didn’t even see it
coming or see that it even
happened. Okay. So. Okay, so

00:38:09.921,00:38:14.926
thank you. You all behaved very
[audience applause], you behaved
very nicely so I have a little

00:38:31.442,00:38:36.447
surprise for you. I have a
mini-talk. Okay, so welcome to
the mini-talk, Exploiting a

00:38:50.395,00:38:56.534
Windows Exploit for Mitigating
Rite of Passage Exploits.
[audience laughing] [ speaker

00:38:56.534,00:39:00.338
laughing] So, at the beginning I
thought maybe I will show you
the bloop reel and how to write

00:39:00.338,00:39:05.577
a hypervisor to protect against,
uh, Rite of Passage, but last
month, there was research by

00:39:05.577,00:39:10.248
Nick Peterson, he called it
InfinityHook, which exploits,
uh, the Windows Event Tracing

00:39:10.248,00:39:15.753
mechanism to hook system calls
on the kernel. So, what Nick
found out is that there is a

00:39:15.753,00:39:21.960
struct in the kernel that uh,
every uh, event log on saves,
which has a function pointer

00:39:21.960,00:39:28.933
that needs to save the timing of
the event that occurred, and he
found out that you can actually

00:39:28.933,00:39:33.972
replace that function pointer
with your function pointer uh,
to your function and now you

00:39:33.972,00:39:39.577
have way to get notification
every time a system call was
issued. So now we can hijack

00:39:39.577,00:39:45.116
system calls. So, obviously
Microsoft responded that this is
not a security boundary so I

00:39:45.116,00:39:51.823
thought why not make it a
security boundary. Yeah. So, now
every time there is a system

00:39:51.823,00:39:56.628
call, we can actually check what
is the return address and check
that the system call matches the

00:39:56.628,00:40:01.432
same function that this, uh,
function came from and if it
doesn’t match that, well, then

00:40:01.432,00:40:05.603
we actually caught to Rite of
Passage uh, bypass and it
actually catches a lot of more

00:40:05.603,00:40:10.608
kind of uh, exploitations, not
only that. So, we can find, uh,
Nick’s work on github. And,

00:40:17.115,00:40:23.388
okay, so takeaways. First, have
fun. I mean, even though
Microsoft tries to make our life

00:40:23.388,00:40:28.793
harder, we can still enjoy it
and do fun stuff with it. And we
need to remember that ROP

00:40:28.793,00:40:35.300
remains a viable threat, even 30
years after its first, uh, its
first incarnation. And, as a

00:40:35.300,00:40:39.737
security industry, we need to
respond faster to those uh,
threats and I want to suggest we

00:40:39.737,00:40:44.976
can utilize the brains in
academy uh, to do that. A lot of
the research on ROP came from

00:40:44.976,00:40:49.947
the academy and also the
research about how, how to
bypass the ROP mitigations and

00:40:49.947,00:40:55.953
there are a lot of great minds
there that we can use, so let’s
do that. And lastly, break it to

00:40:55.953,00:41:00.892
make it better. Okay, thank you
very much. [Audience applause]
So, I think we have about 10

00:41:09.734,00:41:14.739
minutes for uh, Q an A. Five
minutes. Okay, I can’t see
anyone. Yes. >>Uh, how much of

00:41:19.544,00:41:25.116
the mitigations are transferable
to [inaudible] >>Okay, so the
question was how much of the

00:41:25.116,00:41:29.921
mitigation are transferrable to
the Linux wall? So, first I
would say I am not a Linux guy,

00:41:29.921,00:41:34.926
I’m a Windows guy, uh, but I
think ROPGuard uh, is
transferable. kBouncer is also

00:41:37.495,00:41:44.302
transferable. ROPecker, I don’t
how Linux manages the memory of
the processors, but I think it’s

00:41:44.302,00:41:49.540
also will be pronounced
transferable, and I think also
Shadow Stack can be, uh,

00:41:49.540,00:41:54.545
transferable too, so maybe all
of them. It might need a little
tweaks from the uh, Linux side.

00:41:57.415,00:42:02.353
Okay, any more questions? I
can’t see. Okay. So, thank you
very much. [audience applause]

