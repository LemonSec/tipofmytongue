00:00:00.000,00:00:05.005
>>Alright, welcome um you’re
currently in Meticulously Modern
Mobile Manipulations and if

00:00:07.140,00:00:12.145
that’s a bit of a mouthful you
can just say Mmmmm. [Audience
laughing] Alright, um today I

00:00:15.015,00:00:21.488
want to cover some uh cases for
a little bit more advanced
mobile application hacking, um

00:00:21.488,00:00:27.094
we’ll look at some use cases
from Frida, and uh see if we can
figure out how we would go about

00:00:27.094,00:00:31.832
improving our current tooling
and improve it in a way that
would make it relevant for us

00:00:31.832,00:00:36.837
going for from today going
forward and um yeah, let’s see
how that goes. First of all, my

00:00:39.473,00:00:44.845
name is Leon Jacobs, I’m a
security researcher at a company
called SensePost back in South

00:00:44.845,00:00:50.918
Africa. Um, it does not get as
hot as this but uh we’ll leave
that aside for now and I’ve been

00:00:50.918,00:00:56.556
hacking stuff for roughly around
uh 10 years now. I have been
fortunate enough to play around

00:00:56.556,00:01:02.229
on large networks at ISP’s and
maybe a little bit more
complicated ones at banks. Now

00:01:02.229,00:01:06.934
part of my day job at the
moment, sometimes requires me to
perform mobile application

00:01:06.934,00:01:13.640
assessments and to be pretty
honest, I’ve hated that pretty
much a lot.So I’ve set out to

00:01:13.640,00:01:19.279
see what can I do to improve the
state of mobile application
hacking and really just make it

00:01:19.279,00:01:25.185
a way that it sucks a lot less
for me. Now how we’re going to
go about that today, we’re going

00:01:25.185,00:01:32.092
to try and see with these three
phones that are clearly iOS 13
ready um, haha. On a more

00:01:32.092,00:01:38.165
serious note, uh we we’re going
to cover a bunch of techniques
but they’re primarily targeted

00:01:38.165,00:01:44.338
at three uh disciplines from a
mobile hacking perspective. The
first scenario or discipline

00:01:44.338,00:01:49.042
would be that of a mobile
application hacker that wants to
poke around and maybe understand

00:01:49.042,00:01:55.015
how such an application works.
The second discipline would be
one that uh speaks to a mal- a

00:01:55.015,00:02:00.053
malware reverser that maybe
needs to understand quickly how
a mobile application functions

00:02:00.053,00:02:06.326
or what it’s doing uh right now.
The third scenario is sort of
targeted more towards those that

00:02:06.326,00:02:11.398
are responsible for some
development pipeline and might
be involved in the CICD pipeline

00:02:11.398,00:02:17.571
and to deliver some form of
testing. Now these uh techniques
that you’ll see here is probably

00:02:17.571,00:02:24.211
about two years of work that
I’ve been doing um on and off
and uh ultimately the results of

00:02:24.211,00:02:29.016
it should be shown now. That
being said, before we can
actually get to that stuff, we

00:02:29.016,00:02:33.387
probably need to have a bit of a
sit down and understand where
we’re at right now as if a

00:02:33.387,00:02:38.392
parent is going to give us a
stern warning. The reality of uh
mobile app hacking today is I

00:02:40.394,00:02:44.498
think we’re sort of bearing the
fruits of the research of many
of those that might’ve done in

00:02:44.498,00:02:50.604
this room where mobile
ecosystems are so tightly
controlled, they’re relatively

00:02:50.604,00:02:56.676
complex um beasts in themselves,
that’s it's quite hard to do a
mobile app end test right now.

00:02:56.676,00:03:00.680
In fact, there are so many
moving parts of this thing that
I’m pretty sure you’ll groan

00:03:00.680,00:03:07.187
very loudly when you realize you
need to do a mobile app end
test. That being said um, things

00:03:07.187,00:03:11.391
get even a little bit more
complicated if we consider the
state of jailbreaks. While you

00:03:11.391,00:03:16.263
may be fortunate enough to have
access to commercial products
that could give you um root

00:03:16.263,00:03:20.901
access to the latest operating
systems or maybe you have a
private jailbreak that you don’t

00:03:20.901,00:03:26.306
want to share, which is fine.
For the general populous with
iOS 13 available in beta today

00:03:26.306,00:03:31.511
where we don’t have a public
jailbreak, chances are good that
when that becomes the latest and

00:03:31.511,00:03:37.350
greatest OS and an application
is written that makes use of NFC
API’s what are we as mobile app

00:03:37.350,00:03:42.122
end testers going to do about um
when a client asks us well,
you’re now need to go and look

00:03:42.122,00:03:48.562
at what that application is
doing. Secondly, um the result
of this testing or the five

00:03:48.562,00:03:53.333
ecosystems also means that we
can’t really understand what’s
really happening with that. If

00:03:53.333,00:03:58.772
we had to consider scenarios
maybe where big data is watching
us, and uh we not certain that

00:03:58.772,00:04:04.111
if we’re downloading a
flashlight application, which I
might ask why I want to do that

00:04:04.111,00:04:08.849
today, um, is it actually just a
flashlight application or is
there different alternative

00:04:08.849,00:04:13.553
motives to why we have this app
in the first place. In fact, how
do we get to a point where we

00:04:13.553,00:04:18.625
can understand how this data
that might be used in an
application is used against us

00:04:18.625,00:04:23.630
for monetary purposes or other
reasons? This sort of I believe
forces us to try and reshape how

00:04:25.899,00:04:31.538
we think about uh mobile app
hacking and look at alternative
methods to approach this. One

00:04:31.538,00:04:36.543
such method could be using a uh
framework or a toolkit called
Frida. The reality of Frida is I

00:04:39.346,00:04:45.085
sometimes find it hard to truly
explain what it really does um
other than saying it’s a toolkit

00:04:45.085,00:04:49.289
written by Ole André and
honestly I sometimes can’t
believe why this is actually

00:04:49.289,00:04:54.728
free. The capabilities of Frida
spans far beyond what you might
see today uh but we’ll just

00:04:54.728,00:04:59.900
focus on the mobile application
aspect of this. But maybe before
we can understand how this is

00:04:59.900,00:05:05.438
actually gonna to help us app
end testers, let’s look at a
very quick analogy. In this case

00:05:05.438,00:05:10.610
we have a castle or a fortress
and imagine that this castle is
the mobile application app that

00:05:10.610,00:05:15.282
you need to test or you want to
look at how this thing
functions. With root access to

00:05:15.282,00:05:20.787
your device, you can move around
in this castle, you can see
what’s happening inside, you can

00:05:20.787,00:05:27.093
open any doors, and you’re truly
free to inspect any of or any
aspect of this uh fortress.

00:05:27.093,00:05:31.631
However when you don’t have a
jailbreak, well now you’re
sitting on the outside and it’s

00:05:31.631,00:05:35.802
pretty dark on the inside and
you have no idea what’s really
going on over there. You’re not

00:05:35.802,00:05:40.006
allowed in, you’re not allowed
to move to a castle next door
and they’re restrictions

00:05:40.006,00:05:45.412
applicable to us are uh quite
severe. However if we had to
take and combine that with

00:05:45.412,00:05:50.450
Frida, we can sort of see it as
if this gives us opportunity to
have this light to move inside

00:05:50.450,00:05:56.223
of that castle and uh again be
in a place where we can see
what’s going on around us. Now

00:05:56.223,00:06:01.261
this man here doesn’t have much
other than a torch but uh the
reality is it’s a starting point

00:06:01.261,00:06:06.166
for you to be able to explore
and investigate a runtime of
what might be happening um

00:06:06.166,00:06:11.304
around you. Now to actually
understand the limitation of
this and to leave the metaphor

00:06:11.304,00:06:16.309
aside, um we need to get Frida
going on a device. Now there are
two primary operating modes um

00:06:18.445,00:06:23.316
that may be of interest. One
would be a server mode and
that’s really targeted at if you

00:06:23.316,00:06:28.922
really have roots on your device
then you can run Frida without
much restriction. I’m sorry,

00:06:28.922,00:06:33.593
everything you would see today
is applicable in server mode but
we’re gonna focus specifically

00:06:33.593,00:06:37.931
on the gadget mode. Now I must
be really honest, this gadget
mode excites me a lot,

00:06:37.931,00:06:41.401
especially the first time when I
realized what this is possible
to do and we’re gonna look at a

00:06:41.401,00:06:47.007
little bit of that again today.
Now, an important part of how
would I get gadget mode going,

00:06:47.007,00:06:52.078
while you’re going to have to
modify a target application,
there are some small nuances uh

00:06:52.078,00:06:57.851
applicable when considering iOS
but the idea is still the same.
For Android, you might take a

00:06:57.851,00:07:02.522
small little bit of small E and
you would patch an application
to load the shared library which

00:07:02.522,00:07:06.793
is the form that a gadget mode
would take and when an
application starts up, that

00:07:06.793,00:07:12.766
gadget is started as well. A
similar scenario applies for uh
iOS in which case we’ll modify

00:07:12.766,00:07:17.203
an application to load the dylib
and again get us the
instrumentation capabilities

00:07:17.203,00:07:21.941
that we might need. Now if we
had to move on and consider well
what might Frida be used for

00:07:21.941,00:07:26.680
today, and we take the
scientific results from two
Google poems we could see that

00:07:26.680,00:07:31.851
uh if you started typing Frida
iOS, the results could give us
an idea of what folks might be

00:07:31.851,00:07:37.657
searching for. SSI opening
bypasses, root bypasses, really
are pretty common usages for

00:07:37.657,00:07:43.163
Frida. Make no mistake, this is
a super powerful tool for doing
that and um leveraging this

00:07:43.163,00:07:48.335
techniques I think is something
that we can take a lot further.
Maybe if we can try and

00:07:48.335,00:07:52.539
understand the underlying
technique of how these things
work, we can maybe move along

00:07:52.539,00:07:58.912
and see what else we can do. Now
image you had a pinning class
with a chekpin method. Using

00:07:58.912,00:08:03.650
Frida we actually have access to
the implementation of that
method. So what does that really

00:08:03.650,00:08:08.988
mean? Well, when it’s time for
checkpin to run, we now have
access to the entry point to

00:08:08.988,00:08:14.661
that function, we have access to
the logic of what that function
is actually doing, and finally

00:08:14.661,00:08:19.866
and probably more applicable to
an SSI opening bypass, we have
access to the return value that

00:08:19.866,00:08:25.905
that function gives us back. So
you now understand how an SSI
opening bypass works considering

00:08:25.905,00:08:30.176
that maybe the implementation
simply returns a true or a
false. We could use the

00:08:30.176,00:08:36.216
implementation to modify exactly
that. But there is really useful
thing to do and like I’ve

00:08:36.216,00:08:41.054
mentioned um, something that
will probably not go away for a
very long time and it we have in

00:08:41.054,00:08:46.893
our arsenal right now. But we
can absolutely do a lot more. In
fact, I think we had one

00:08:46.893,00:08:52.932
scenario where uh we had to do
an assessment the app does not
run on a device that we have a

00:08:52.932,00:08:58.238
jailbreak for but part of this
assessment meant that we needed
to get access to a file inside

00:08:58.238,00:09:03.676
of that application’s container
but without a jailbreak. Now a
little bit of thinking and

00:09:03.676,00:09:09.249
considering a little bit later,
I realized that while when we
were doing hooking, we can

00:09:09.249,00:09:14.387
manipulate existing logic that
is within our application. We
can actually also go and

00:09:14.387,00:09:19.225
introduce new logic. And when
I’m saying new logic, I’m
actually just saying that there

00:09:19.225,00:09:24.164
is a class available for us to
use in the runtime and we can
instantiate a fresh instance of

00:09:24.164,00:09:30.070
that class. Now Frida makes this
super eas- easy for us to do by
simply running some of or using

00:09:30.070,00:09:35.375
some of the API’s that Frida
exposes.The first of all would
be the Java use case in which

00:09:35.375,00:09:41.080
case we’re just instantiate a
new instance of java io dot file
here. For Objective-C

00:09:41.080,00:09:45.518
environments, there might be a
class called SI files and in
this case, we’re simply

00:09:45.518,00:09:51.291
instantiating uh sorry,
allocating and initializing that
class. Now when we’re just

00:09:51.291,00:09:55.929
initializing these classes we’re
not actually have a variable
that we can call the methods

00:09:55.929,00:10:01.668
applicable to that class um
ourselves. In fact if we start
combining these things, we’re in

00:10:01.668,00:10:06.306
a scenario where we can actually
start building some extra tools
which might result in us uh

00:10:06.306,00:10:11.945
extending functionality that’s
not necessarily part of that
original application that we are

00:10:11.945,00:10:17.784
testing. Now in our case,
remember the part where we
needed to get access to a file

00:10:17.784,00:10:22.722
inside of a container. It’s
exactly this thing that
happened. In fact, I started

00:10:22.722,00:10:28.328
writing a bunch of scripts which
resulted in a toolkit that I
wrote called Objection which um

00:10:28.328,00:10:32.866
in its infant stages was
actually just a file manager
using exactly the same building

00:10:32.866,00:10:38.204
blocks that a developer would’ve
used if they wanted to build a
file manager and uh add some

00:10:38.204,00:10:43.142
capability to list files within
their containers directory and
ultimately download those out

00:10:43.142,00:10:48.147
again. Now file manager is a
interesting scenario so let’s
have a quick look at what that

00:10:51.117,00:10:56.122
might look like. In uh, this
video’s case, I hope it’s this
one, there we go um, you should

00:10:59.359,00:11:04.964
see an existing session for
Objection running already and
there was some uh file

00:11:04.964,00:11:08.535
interactions that happened. You
know you can see these through
to the directories within the

00:11:08.535,00:11:14.007
container and uh inspect what
the contents of the file system
might be. Now applicable to this

00:11:14.007,00:11:19.612
demo, one quick little bit of um
information that you might need
to understand is if you’re using

00:11:19.612,00:11:23.716
an iOS app and you had to
background the app, iOS will
take a screenshot of that

00:11:23.716,00:11:27.587
application’s current state, and
this is to make it nice of
you’re using the app switcher to

00:11:27.587,00:11:32.325
know what the last state of that
app might have been. Using the
file manager that was built, we

00:11:32.325,00:11:38.264
can uh go to that directory and
uh see what the -those files are
and quite possibly download them

00:11:38.264,00:11:43.436
as well. So in this case over
here, using a relatively
familiar interface uh, we go to

00:11:43.436,00:11:48.174
the snapshots directory which
contains these files, and uh if
we had to hit the the LS here

00:11:48.174,00:11:53.346
we’ll see the files themselves.
Now like I’ve mentioned we could
do something like just

00:11:53.346,00:11:58.084
downloading this file and
inspecting what it might be. But
what if we start thinking about

00:11:58.084,00:12:02.722
what else we can in uh uh
-extend our app with. In this
case, we’re actually gonna

00:12:02.722,00:12:06.826
consider adding an http server
to the target application, which
I should have mentioned as

00:12:06.826,00:12:12.065
Youtube over here, and this
would actually start the http
server on my iPad allowing me to

00:12:12.065,00:12:17.937
browse to the iPad’s IP address
and view that same directory
listing from a web browser. More

00:12:17.937,00:12:23.009
importantly this is not
functionality that exists in
this application out of the box.

00:12:23.009,00:12:28.014
We’ve used instrumentation to
augment what uh we wanted to add
to it and build out tooling on

00:12:30.850,00:12:35.855
from there. Alright, now as you
may have seen, this really
really opened a lot of uh

00:12:35.855,00:12:41.027
possibilities for us. In fact,
furiously we’re at a stage where
we’re building new tools,

00:12:41.027,00:12:47.467
porting older ones for example
image old keychain dumper which
many of us are familiar with.

00:12:47.467,00:12:52.071
From an outside rooted
jailbroken perspective that
keychain dumper really just

00:12:52.071,00:12:57.477
interfaces with the SQLite
database and iOS. But within an
application container, if we

00:12:57.477,00:13:01.714
wanted to build a keychain
dumper, we can actually just
port that same logic and have it

00:13:01.714,00:13:05.852
contained within the container
and still be able to understand
what’s being stored when I’m

00:13:05.852,00:13:11.024
instrument or when I’m using
this application at runtime. Now
one thing that might be

00:13:11.024,00:13:15.662
interesting or that could help
understand how all of this fits
together, as the super explore

00:13:15.662,00:13:20.800
uh explanatory picture that
would link, and you should see
the little line over there, um

00:13:20.800,00:13:26.305
all of these components
together. First of all you would
have the JavaScript for runtime,

00:13:26.305,00:13:31.644
um that Frida exposes for us
that we could use um to write
some scripts. But that won't be

00:13:31.644,00:13:36.482
the starting point if you wanted
to write a new tool. In fact,
you would probably target the

00:13:36.482,00:13:41.788
Objective-C runtime if you
wanted to write your keychain
dumper. But to make use of this

00:13:41.788,00:13:46.759
from a Frida perspective, once
we have some valid uh
Objective-C running, we can now

00:13:46.759,00:13:51.531
port that over to the Javascript
runtime, and that’s what the
little link should show, um and

00:13:51.531,00:13:57.103
run it from there. The exact
same process applieswhen we’re
speaking of Java runtime or even

00:13:57.103,00:14:02.942
if you wanted to run some native
code. Stringing all of these um
runtimes together is ultimately

00:14:02.942,00:14:09.115
what gives us that ability to um
work with these runtimes and
build fresh new tooling. But

00:14:09.115,00:14:14.654
okay, let’s shift gears a little
bit and consider application
heaps. When we are speaking of

00:14:14.654,00:14:21.060
application heap over here,
really what I’m saying is uh, we
have a class, we’ve instantiated

00:14:21.060,00:14:26.699
an instance of that class and
that would live on a heap for a
certain amount of time. That

00:14:26.699,00:14:31.537
instance itself has methods that
gets called from it and whatever
the reason is or why we have

00:14:31.537,00:14:36.242
this, it might affect some state
of the application. Now a lot of
the research that you’ll see

00:14:36.242,00:14:41.514
over here, hinges off a
ex-colleagues work that was
done, Chris Le Roy that um

00:14:41.514,00:14:47.019
explored the idea of using java
objects that live on the heap to
possibly identify some forms of

00:14:47.019,00:14:52.925
malware and try and understand
how that works. But for us, and
what I’ve hoped to try to take

00:14:52.925,00:14:57.130
this further, is to see well
what else can we do with this
stuff. If we’re considering

00:14:57.130,00:15:00.933
application heaps, maybe the
first thing that we need to
understand is what type of

00:15:00.933,00:15:07.573
classes that are on the heap
could be interesting. A list, as
you might see there, could be

00:15:07.573,00:15:11.944
things that handle cryptography
in some way that might make
socket connections out on the

00:15:11.944,00:15:16.916
internet. Um, maybe handle some
states for the target
application. There might be some

00:15:16.916,00:15:21.888
configurations saved for your
app or if in an Android world,
there might be a class loader

00:15:21.888,00:15:27.593
that loads some classes from the
outside. If we understand maybe,
what classes might be

00:15:27.593,00:15:32.532
interesting, maybe if we zone in
very quickly at what we might
want to do with such a class it

00:15:32.532,00:15:37.336
could look something like this.
Methods could exist on that
class that could get in said

00:15:37.336,00:15:43.109
properties. A class itself less
properties which has some values
and understanding what those

00:15:43.109,00:15:47.780
values are could actually tell
us what the state of that class
is right now. But more

00:15:47.780,00:15:53.519
importantly if we are calling
methods on that class, we might
actually be changing the state

00:15:53.519,00:15:59.325
of that class that is as it is
right now as the application is
running. Now a lot of this stuff

00:15:59.325,00:16:04.363
might seem a little complicated
but uh from a Frida perspective,
we really have two API’s that

00:16:04.363,00:16:10.069
start exposing this stuff to us.
We could simply use the java,
the choose runtime, umm, I’m

00:16:10.069,00:16:14.207
sorry the java dot choose API
and that would actually just
enumerate us instances of a

00:16:14.207,00:16:19.512
target class that we might want
to interact with. Similarly an
Objective-C world again the

00:16:19.512,00:16:25.117
choose API would do the same
thing. But that’s not a lot of
talk, let’s consider what a uh,

00:16:25.117,00:16:31.724
this might look like and a way
we could use this. What you
should see over here is um, once

00:16:31.724,00:16:38.464
the video loads, is um there’s a
terminal on the left hand side
where we’re going to interact

00:16:38.464,00:16:44.270
using Objection and on the right
hand side there’s a video that’s
looping from uh uh the Tik Tok

00:16:44.270,00:16:49.876
application. Now this
application itself, um explains
a little bit of time reversing

00:16:49.876,00:16:55.248
it just to understand what it
looks like and I’ve identified
one class of interest that uh

00:16:55.248,00:17:00.586
seems to be controlling the
current video that’s playing
right now. Now using that choose

00:17:00.586,00:17:05.324
API, wrapped over here from an
Objections perspective, we can
actually enumerate live

00:17:05.324,00:17:10.963
instances of that class like
I’ve mentioned that uh we might
want to interact with right now.

00:17:10.963,00:17:15.668
The output of the command I just
ran gives us three instances
that we might work, want to work

00:17:15.668,00:17:20.973
with. We could copy one of those
which has a uh which is a
pointer to that class and I’ll

00:17:20.973,00:17:25.945
start interrogating it to
understand more about it. One
way we might want to do that is

00:17:25.945,00:17:30.249
to actually tell it show me the
instance variables that we have
for this specific class that

00:17:30.249,00:17:35.388
lives at that pointer. The
answer that we get back is
actually a bunch of information

00:17:35.388,00:17:39.725
which includes all of the
properties for that class
including some values that it

00:17:39.725,00:17:44.463
could easily read. You’ll see
many of these are actually
handles to more com- more uh

00:17:44.463,00:17:50.002
classes so what we can try and
do now is to try to cause those
to UTF8 strings which should

00:17:50.002,00:17:54.874
result in much more uh
information about what this
class is doing, what it’s

00:17:54.874,00:17:59.578
current state might be, and in
other words, actually what the
current video might be that is

00:17:59.578,00:18:05.484
playing. Now understanding
what’s inside of the class, we
might choose uh a different

00:18:05.484,00:18:10.256
route and maybe see which
methods do we have exposed to us
by purely interrogating that

00:18:10.256,00:18:16.562
actual class itself. By doing a
heap print methods um command,
we should get a list of methods

00:18:16.562,00:18:21.033
that we can run on this class
instance that’s on the heap
right now and maybe see that

00:18:21.033,00:18:25.438
there’s a play command and a
pause command and these are the
type of things that we might use

00:18:25.438,00:18:30.977
to interact with uh the video
that’s currently playing at the
back. Now like I’ve mentioned,

00:18:30.977,00:18:34.981
we might want to change the
state of this thing so to do
such a thing, we could actually

00:18:34.981,00:18:40.219
just go and execute that method
that we have found for this
instance and uh if we hit the

00:18:40.219,00:18:44.657
pause method over here, we
should see the video pause um
using the interaction that we’ve

00:18:44.657,00:18:49.462
just done. Naturally to
continue, you could just go and
call the play method once again.

00:18:49.462,00:18:55.201
Now in this case, we’ve had two
method calls that didn’t accept
any arguments, they’re really

00:18:55.201,00:19:00.272
simple calls, they don’t do a
lot really interesting so let’s
consider other methods that

00:19:00.272,00:19:04.877
might be a little bit more
complicated. One such method
that you would find on that list

00:19:04.877,00:19:11.484
would be setcontentURLstring and
you would see it except one
argument. Now uh from a Frida

00:19:11.484,00:19:15.888
perspective, you can write a
separate script or from
Objection perspective, you could

00:19:15.888,00:19:20.993
get a new command that will show
in a second that will actually
show you a javascript variable

00:19:20.993,00:19:26.065
to the address that that pointer
points to. So if we do the
evaluate method here, it will

00:19:26.065,00:19:31.570
tell you that uh PTR variable is
actually just the variable that
binds to that um address on the

00:19:31.570,00:19:36.542
heap and uh we can now work with
it. Now in this case, I actually
want to change this video to

00:19:36.542,00:19:42.948
little bit more educational one
so I have found a URL for such a
video on Youtube and uh I now

00:19:42.948,00:19:48.387
want to change Tik Tok without
interacting with it to play that
video uh as we have it. So we’ve

00:19:48.387,00:19:53.993
identified setcontentURLstring
so we’re going to call that
method on that PTR variable

00:19:53.993,00:19:59.865
again which is just a pointer to
the object and give it the URL
argument that we um wanted -to

00:19:59.865,00:20:05.237
to load. The next thing that you
would find if you were to
reverse this app a bit there

00:20:05.237,00:20:09.041
would be a prepare to play
method and all this really does
is just downloads it in the

00:20:09.041,00:20:14.780
background and gets it ready to
display um in the foreground.
Now ne -next thing we might want

00:20:14.780,00:20:20.152
to do with this little script is
to actually set uh or give us
ourselves a bit of a visual

00:20:20.152,00:20:23.422
indicator that that was
successful right. So if anything
we’ll do then is just log that

00:20:23.422,00:20:29.061
we’re done and uh wrapping all
of that up, run the script
itself. When the script runs,

00:20:29.061,00:20:34.233
you see in the background that
uh the app itself has now just
gone dark. So the next thing you

00:20:34.233,00:20:38.738
might want to do is ask it to
actually play that. So like
we’ve already been doing we’ll

00:20:38.738,00:20:44.276
just call that play method on
top of it and we’ll enjoy some
recreational content that may

00:20:44.276,00:20:49.281
um, inspire you to do this
yourself, haha, awesome. Okay,
but I think the point to take

00:20:55.821,00:21:00.926
from here is, using simply one
address, I’m also sure this is
the most most of us have seen of

00:21:00.926,00:21:06.632
the video before you just close
it. Um, but an important take
away from this is you’ve

00:21:06.632,00:21:12.338
enumerated an instance of an
object uh we’ve manipulated it
by pausing it playing and we’ve

00:21:12.338,00:21:18.277
actually changed its state by
setting a variable and uh making
sure that that loads up givin

00:21:18.277,00:21:23.349
-going us a nice visual
indicator that something has
changed. Now all of that was iOS

00:21:23.349,00:21:29.121
specific stuff so let’s uh
consider um Android. Well,
exactly like you’ve seen over

00:21:29.121,00:21:32.958
here is actually applicable to
Android as well and from an
Objection perspective, the

00:21:32.958,00:21:38.030
interaction is pretty much the
same. Again, in the un-
underneath it uses the same

00:21:38.030,00:21:43.602
API’s that we’ve been using for
iOS so it’s really not a lot
different over here. However, if

00:21:43.602,00:21:48.240
we had to look at one example
for Android very quickly, um we
could take the Youtube app and

00:21:48.240,00:21:53.345
ask it show me the instances of
the next class loader that are
alive right now. What’s quite

00:21:53.345,00:21:57.650
nice about the javaruntime, it
has a two string method on many
classes so we can actually see

00:21:57.650,00:22:03.022
very quickly see what that um uh
methods properties might be or
at least some of the properties

00:22:03.022,00:22:08.794
that mi- uh class might have.
Okay now we’ve noticed that
there’s a the dot apk. I promise

00:22:08.794,00:22:14.400
I didn’t name it that and uh now
that we know where it might
live, we have a path. We could

00:22:14.400,00:22:18.704
probably just go about and use
the file manger that we already
have and download that for

00:22:18.704,00:22:23.475
further analysis later. Again,
this is -this doesn’t require
you to have root, you just

00:22:23.475,00:22:28.581
needed to modify the app to get
the gadget going and you could
quickly get to um some content

00:22:28.581,00:22:33.586
that you might not have known
initially from static analysis.
Now while on that topic, what

00:22:33.586,00:22:37.923
about applications that we’re
unsure of what they’re actually
doing or one’s that you’re

00:22:37.923,00:22:42.761
relatively certain is probably
malware? Well, obviously you
could perform some static

00:22:42.761,00:22:48.033
analysis, reverse the app, see
what is going on underneath the
hood um and get a good idea of

00:22:48.033,00:22:52.271
what it might be hav- wha- what
it might be doing. However at
the same time, that could be a

00:22:52.271,00:22:58.077
pretty tedious task and
depending on um how the app is
built, it might not be a very

00:22:58.077,00:23:03.616
easy thing to do. In fact, it’s
not really a secret to know that
apps might actually try and hide

00:23:03.616,00:23:08.754
their true intent, well malware
apps for that. Interesting
techniques like using a backer

00:23:08.754,00:23:13.125
or some really heavy obfuscation
might make it difficult for you
to understand from a static

00:23:13.125,00:23:18.497
analysis perspective what an
application is truly up to. Um,
if you don’t have a lot of time

00:23:18.497,00:23:23.335
and you may be want to collect
some IOC’s very quickly, again
your static analysis approach

00:23:23.335,00:23:28.440
might be a little bit tricky.
One method a lot of apps might
use to uh try and make this a

00:23:28.440,00:23:33.312
little bit difficult is to
actually use reflection. By
using reflection, they could

00:23:33.312,00:23:38.417
programatically make calls to
methods and uh ya know depending
on what the source of that logic

00:23:38.417,00:23:44.456
might be, the method calls
themselves are not immediately
um known. However, from a

00:23:44.456,00:23:50.229
runtime perspective, we could
actually have this uh exact same
method hooked, and as they’re

00:23:50.229,00:23:55.034
using reflection to uh invoke
calls, we could use that to
understand what the calls

00:23:55.034,00:24:01.407
themselves are. Now one such um
piece of malware, assuming that
we had a look at, that uh would

00:24:01.407,00:24:07.579
load a jar file actually out of
a bitmap and uh once the jar
file is loaded, use reflection

00:24:07.579,00:24:13.052
to call methods that’s on top of
that. We have a sample hook here
that I want to show you very

00:24:13.052,00:24:17.956
quickly that uh does exactly
that, hooking the reflection
methods to understand what the

00:24:17.956,00:24:22.728
app is doing. Now one thing I
would need to do is apologize
for the speed of this. I’ve

00:24:22.728,00:24:28.033
actually slowed it down quite a
bit but um we’re running a
malware application here in a

00:24:28.033,00:24:32.204
Android emulator, they’re no way
I’m installing that stuff on an
actual phone. Some of those are

00:24:32.204,00:24:37.810
really really dodgy but um, by
hooking the invoke method for
reflection, we can actually see

00:24:37.810,00:24:44.283
all of the calls and possibly
some of the arguments that are
being used to um make these uh

00:24:44.283,00:24:48.687
interactions that the malware is
supposed to be doing. Now like
I’ve said, this is slowed down

00:24:48.687,00:24:52.891
quite a bit. You don’t have to
worry about actually following
on all of that but toward the

00:24:52.891,00:24:57.429
end, we should start seeing some
socket classes making lettered
connections out to the internet.

00:24:57.429,00:25:01.834
So we can quickly deduce at this
point, that there’s something
strange going on here or at the

00:25:01.834,00:25:06.105
very least, there’s some network
activity that we might want to
have a look at. Now once you’ve

00:25:06.105,00:25:10.642
inspected maybe some of the
network activity, maybe we want
to try and understand how this

00:25:10.642,00:25:16.014
application actually came to uh
make this logic happen in the
first place. Well, once I’ve

00:25:16.014,00:25:21.286
seen, like I’ve mentioned, the
next class loader could be used
to load arbitrary um code from

00:25:21.286,00:25:25.758
outside of what you may have
expected it to come from or we
can see over here that using

00:25:25.758,00:25:30.462
reflection, the class loader was
loaded and it actually tried to
load that jar file that you can

00:25:30.462,00:25:35.801
see on the path over there. More
interestingly though, once that
jar was loaded, it actually

00:25:35.801,00:25:39.872
deletes it off disk using a
delete collator you know and
making it a little bit harder

00:25:39.872,00:25:44.042
for you possibly to catch that
and actually uncovering what
this malware might be up to in

00:25:44.042,00:25:49.048
the first place. Alright, so I
hope that sort of gives you an
idea of how that might work. But

00:25:52.251,00:25:57.623
what about existing tools? What
about tooling the developers are
using to make their development

00:25:57.623,00:26:02.628
experience or uh making their
lives a lot easier. I truly
believe as security

00:26:02.628,00:26:07.065
professionals we probably are
missing out by not leveraging
the exact same tooling that they

00:26:07.065,00:26:12.237
might be using as well. In fact,
some of that stuff I’ve seen I
can’t believe that is free and

00:26:12.237,00:26:17.309
you could actually use it
yourself as well. Anyways, one
way if we are to use a

00:26:17.309,00:26:22.781
instrumentation is we can
actually side load this existing
tooling into an application that

00:26:22.781,00:26:28.487
um doesn’t have it and make use
of exactly the same features a
developer would do. We can

00:26:28.487,00:26:33.659
leverage an API from Frida if it
came in the form of a shade
library using simply module dot

00:26:33.659,00:26:39.231
load and pointing it to a path
on disk within the application’s
container to a shared library

00:26:39.231,00:26:44.603
that might have the debug
tooling that you’re interested
um and use that. Now shade

00:26:44.603,00:26:49.074
library’s not the only form in
which this thing can come, in
fact, you could also have a java

00:26:49.074,00:26:53.912
tool, obviously for Android, uh
and you can side load that much
like malware probably would do

00:26:53.912,00:26:59.685
it but uh allowing you to
leverage the same features that
they might have. I want to look

00:26:59.685,00:27:04.923
at two examples relatively
quickly today. Of which one
would be uh Flex from Flipboard

00:27:04.923,00:27:10.896
which targets iOS and another
would be the Stetho project from
Facebook. Both of these tools

00:27:10.896,00:27:16.168
are uh tools that developers can
use that absolutely augments
their uh development experience

00:27:16.168,00:27:20.672
and probably more so the
debugging experience that they
might um or scenarios that they

00:27:20.672,00:27:25.677
might need to debug. The first
would be Flex and I’ll load
this. Um and you’ll should see

00:27:29.882,00:27:35.087
over here, just pause that, that
on left hand side we have the
terminal with some interactions

00:27:35.087,00:27:39.691
from objection and on the right
hand side, I have the Youtube
app that’s just connected with

00:27:39.691,00:27:44.196
Quicktime to the Mac. There is a
plugins flag that you’ll
probably seeing for the first

00:27:44.196,00:27:49.768
time now. That was a community
contributed feature that uh
allowed us to just flow side

00:27:49.768,00:27:54.506
load Frida’s scripts quickly
with an objection. However the
most important thing really to

00:27:54.506,00:27:58.610
understand from that is -is just
Frida script at the bottom and
there’s nothing really different

00:27:58.610,00:28:04.550
about it. Anyways, if we decided
that we wanted to load this Flex
plugin, we can run a command

00:28:04.550,00:28:09.454
like plugin flexiload and all
this will do is using that file
manager, that objection

00:28:09.454,00:28:15.327
originally had to upload the
shared library into a directory
finally called module dot load

00:28:15.327,00:28:20.165
which will result in this little
debug bar popping up in the
Youtube application. Now I can

00:28:20.165,00:28:24.536
tell you that Youtube app
doesn’t have Flex by default but
we’ve now just sideloaded Flex

00:28:24.536,00:28:28.674
and made it possible for us to
use it just like a developer
would do to understand what this

00:28:28.674,00:28:35.047
application might be up to and
to make use of any features Flex
has uh ya know for us. One

00:28:35.047,00:28:39.651
thing, it has a really cool name
to it uh um inspector so I would
highly encourage you to have a

00:28:39.651,00:28:46.291
look at that as well. Alright,
now uh from a Android
perspective, like I’ve

00:28:46.291,00:28:52.197
mentioned, we have Stetho as an
example and in this case um for
Stetho specifically, sorry I

00:28:52.197,00:28:58.937
just need to get this proper
demo. Um, let’s take a little
bit of a longer route around

00:28:58.937,00:29:03.408
this and understand what’s
happening. We have a show on the
left hand side, an Android App

00:29:03.408,00:29:08.647
that’s streaming to my ph- uh to
my laptop and a Chrome inspector
at the bottom. I’ve launched the

00:29:08.647,00:29:13.585
Reddit app and uh I’m just
quickly going to interact with
it as if I am normally using

00:29:13.585,00:29:18.457
this application. I’ll go to my
favorite subreddit um read a
little bit of news and probably

00:29:18.457,00:29:23.729
get bored of that pretty
quickly. With an objection
though, at this point, I might

00:29:23.729,00:29:27.933
be interested in which
activities are available within
the runtime right now. Now at

00:29:27.933,00:29:31.503
runtime, you can query
Androids’s packet manager and
that can give us a list of

00:29:31.503,00:29:36.942
activities that is um targetable
right now. If I had to go
through the list of activities

00:29:36.942,00:29:41.413
that I’ve enumerated one such
activity might catch your eye
called the data logging

00:29:41.413,00:29:46.585
activity. Well, data logging
seems interesting so let’s go
and build a fresh intent um

00:29:46.585,00:29:52.624
again using java to run via
javascript to launch the actual
intent but wrapped up in an easy

00:29:52.624,00:29:56.862
command like you’d see here
which should result in that
activity actually launching on

00:29:56.862,00:30:01.633
the Android app and letting us
use it. In this case over here
though, you should see quite a

00:30:01.633,00:30:07.539
lot of um tracking related logs
and if you go into the detail of
some of this stuff um, it’s a

00:30:07.539,00:30:11.543
little bit hair raising really
to see why they need to know
what the current theme is as

00:30:11.543,00:30:17.549
part of your um browsing
experience. But okay, we can
keep that in mind on the side.

00:30:17.549,00:30:22.254
Now I might decide that at this
stage, maybe I want to use
Stetho’s features to browse data

00:30:22.254,00:30:28.093
on the device itself. Much like
the Flex scenario, we can just
load Stetho up using a plugin

00:30:28.093,00:30:33.532
and that should result in uh a
class loader being used to
actually instantiate the classes

00:30:33.532,00:30:39.471
in a jar and finally call the
intial- initialization method
that it had. Once that’s done,

00:30:39.471,00:30:44.910
the way Stetho works, is it has
a um inspector that you can use
at the bottom and if you inspect

00:30:44.910,00:30:50.015
that, it’s just a normal Chrome
inspector that actually gives
you access to the files within

00:30:50.015,00:30:55.554
that container so preferences,
files, in this case or SQLite
databases that you might have

00:30:55.554,00:31:01.293
access to as well. Over here, we
might notice that pureedb and in
that case, see events relatively

00:31:01.293,00:31:06.298
similar to those that we saw in
the data logging activity
itself. Now, what’s possible

00:31:06.298,00:31:11.870
here is you can run raw SQL
queries on that data and what
you should keep in mind is if

00:31:11.870,00:31:16.675
you have an application that
actually has some states stored
within a SQLite database,

00:31:16.675,00:31:20.779
changing the data in that
database might actually affect
the state of the application

00:31:20.779,00:31:24.950
that you’re targeting. Maybe
there’s a key in there that you
could update to something else

00:31:24.950,00:31:29.955
or ya know let your imagination
go pretty wild. Alright, now
what about integration? Um, if

00:31:33.859,00:31:39.030
we had, uh when I had thi this
-this thought about ya know how
could I make it that we could

00:31:39.030,00:31:43.935
integrate the things, uh it
seems like a very difficult
thing but when I had a bit of a

00:31:43.935,00:31:47.806
thought about it, I realized I
could load the building blocks
on how to do this, actually

00:31:47.806,00:31:52.878
already existed. Now when I do
speak of integration ya know
from my perspective, it’s really

00:31:52.878,00:31:58.183
just http requests into
something that would give me
some results back. If we had to

00:31:58.183,00:32:03.088
consider an architecture of what
that might of looked like, we
already have the Frida um

00:32:03.088,00:32:07.492
gadgets involved somewhere in an
application, we already have a
bunch of files and tooling

00:32:07.492,00:32:12.731
written around it so really the
only thing that was necessary
was to expose an https server

00:32:12.731,00:32:16.968
from which an http client would
be able to connect to
serializing messaging using

00:32:16.968,00:32:22.574
JSON. In fact, this resulted in
really just three lines of code,
you can check me on that um to

00:32:22.574,00:32:29.047
get it to work. So that was like
quite surprising and easy to get
going. However, the result of

00:32:29.047,00:32:34.653
that would mean we could now
make a call request and using
runtime instrumentation, go and

00:32:34.653,00:32:39.925
figure out for example the
binary protections that an iOS
app has. This is just one of the

00:32:39.925,00:32:43.862
many scripts that exist in
Objection and make some
decisions based on that if we

00:32:43.862,00:32:48.500
required them to be enabled or
not or many even question their
existence in the first place.

00:32:48.500,00:32:55.073
Now just being able to use code
commands might be um interesting
but we could probably actually

00:32:55.073,00:33:00.078
add this to a Jenkins pipeline.
So if we had to look at what
that might look like, I have a

00:33:00.078,00:33:06.618
project over here that um is
configured here using Jenkins.
There’s a uh, the configuration

00:33:06.618,00:33:10.889
of the project is actually quite
simple. The first step would be
to just build the app that I

00:33:10.889,00:33:15.927
have and this app has the gadget
embedded. The next step is just
some simulator commands to

00:33:15.927,00:33:21.099
actually get an iOS simulator
running, installing the app that
just got built. Once that’s

00:33:21.099,00:33:25.437
done, we would start up
Objection which will give us the
opportunity to interact with the

00:33:25.437,00:33:31.443
Frida gadget using http messages
and finally the actual checks
that we want to make to make

00:33:31.443,00:33:37.249
sure that certain protections
are enabled and uh that we fail
if they don’t. Finally just some

00:33:37.249,00:33:43.088
cleanup scripts to save space on
my limited hard drive. Alright,
now we’ll probably go into the

00:33:43.088,00:33:47.225
build phase and uh although this
is a little bit small to see,
the details are not too

00:33:47.225,00:33:52.163
important. This will now just go
through that entire phase of
actually building a project,

00:33:52.163,00:33:56.801
modifying the simulator uh, and
getting to a point with a
Objection API is actually

00:33:56.801,00:34:01.973
listening and that’s what you
should see over here in a sec.
Once that’s up and going, the

00:34:01.973,00:34:06.978
again this is now an app that’s
actually running in the
simulator and runtime we are

00:34:06.978,00:34:12.317
queiring to see what are the
binary protections of the final
artifact that we’ve had um on

00:34:12.317,00:34:17.222
the uh device. This is that
binary that’s probably gonna be
the one that gonna get shipped

00:34:17.222,00:34:22.093
to your aim client. Because my
project is configured in such a
way that has all of these

00:34:22.093,00:34:27.332
protections enabled, um my build
completes and I’m now at a state
where I can continue with

00:34:27.332,00:34:32.971
whatever the next step might be.
So I’m hoping that gives you an
idea of probably many of the use

00:34:32.971,00:34:38.710
cases where uh if you’re
concerned of what the last final
stage of your app is, you could

00:34:38.710,00:34:44.249
use instrumentation in an
automated fashion to uh query
that runtime and assert certain

00:34:44.249,00:34:50.622
features that you may need.
Alright, so let’s really quickly
recap about what we’ve just

00:34:50.622,00:34:55.627
said. We’re saying that um apps
are ya know at a runtime for
many disciplines might be, it

00:34:58.463,00:35:03.068
might be interesting for us to
query that. Uh this is
applicable for hackers, this is

00:35:03.068,00:35:08.773
applicable for malware reversers
and even those folks who might
be responsible for a CICD

00:35:08.773,00:35:13.311
pipeline. Some of these
techniques that you’ve seen
today absolutely overlap for

00:35:13.311,00:35:18.183
some of these disciplines but uh
the general idea is is that it
would enable us to improve the

00:35:18.183,00:35:22.420
actual testing that we’re doing
and we’re not relying on old
tooling that might not be

00:35:22.420,00:35:27.425
working on a non-jailbroken
device. So to summarize all of
that, I would love for us to

00:35:29.828,00:35:35.000
realize that ya know runtime
analysis is more than just
hooking, it’s much more that

00:35:35.000,00:35:40.605
just SSI opening bypasses
although absolutely powerful, we
have the ability to build many

00:35:40.605,00:35:46.311
more tools and extend our
arsenal that we have. We don’t
always need roots to run these

00:35:46.311,00:35:51.850
types of things which means that
if iOS 13 for example had to
drop today, we still can test

00:35:51.850,00:35:56.488
and we still can do a proper
analysis of how these
applications might work.

00:35:56.488,00:36:02.761
Finally, irrespective of what
your discipline is um, anyone
can use this. It’s uh applicable

00:36:02.761,00:36:09.167
to many folks involved in some
form of mobile application
pipeline and uh as a final sake,

00:36:09.167,00:36:13.972
we can use this for the greater
good to actually understand what
our apps are doing if our data’s

00:36:13.972,00:36:18.243
being shipped off somewhere we
can catch that. I think it’s
everyone's responsibility here

00:36:18.243,00:36:23.248
to actually do that and I hope
this encourages you to do that.
Thank you. [Applause] Uh, one

00:36:32.791,00:36:36.828
final thing that I’d like to
mention, the stuff that you’ve
seen here should be available in

00:36:36.828,00:36:41.199
the release that I would make in
Objection as soon as I can get
to a computer after this. And

00:36:41.199,00:36:42.067
yeah, awesome.

