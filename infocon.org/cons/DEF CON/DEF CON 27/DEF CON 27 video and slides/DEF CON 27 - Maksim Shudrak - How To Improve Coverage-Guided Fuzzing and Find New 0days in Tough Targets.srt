00:00:00.100,00:00:05.939
>>Ladies and gentlemen can you
put your hands together for
Maksim Shudrak. [applause]

00:00:05.939,00:00:10.944
>>Hello DefCon how are you
doing? [audience cheers] Nice, I
just uh I had a party near my

00:00:18.452,00:00:25.025
room all the night so I slept
like forty five minutes so I,
I’m sorry if my brain will

00:00:25.025,00:00:31.698
switch off at some point at this
presentation but hope we’ll
manage today. So uh we’re gonna

00:00:31.698,00:00:36.703
talk about um, zero bugs found,
hold my beer AFL and how to
coverage-guided fuzzing and find

00:00:39.206,00:00:46.179
new zero days in tough targets.
So, glad to see all of you here
um, first of all let me thank

00:00:46.179,00:00:52.853
DefCon goons for having me here
I’m really excited to speak uh
at this stage today. Uh before I

00:00:52.853,00:00:58.692
will actually start uh let me
introduce myself. So my name is
Maks I have spoken various uh

00:00:58.692,00:01:04.464
security conferences around the
planet, mostly about dynamic
analysis of machine code, and

00:01:04.464,00:01:08.835
last year I presented at DefCon
a talk about Malware fuzzing so
check it out if you’re

00:01:08.835,00:01:15.375
interested in this topic. I
first experience working on open
source fuzzers such as FNL, RFL,

00:01:15.375,00:01:21.782
uh contributed to opensource
framework DynamoRIO, uh working
on implem-implementing extremely

00:01:21.782,00:01:26.787
obstruct operating system uh for
windows malware analysis IBM
research in Israel. So currently

00:01:30.857,00:01:36.296
I’m working at Salesforce Red
Team, it’s an offensive security
research. Researching for zero

00:01:36.296,00:01:42.903
day bugs, uh writing exploits
and doing engagements. In my
case uh I need to identify

00:01:42.903,00:01:49.209
vulnerability and write exploit
uh in a very very short uh
period of time. And that’s

00:01:49.209,00:01:55.983
actually why, where our store
about efficient coverage-guided
fuzzing begins. So we’re going

00:01:55.983,00:02:02.089
to talk about fuzzing today,
right. And what kind of problems
we-we face uh when we use AFL.

00:02:02.089,00:02:08.895
Um I will describe what
coverage-guided fuzzing is and
explain how AFL actually work.

00:02:08.895,00:02:14.301
Then we gonna talk about down
size of AFL and how each of them
can ruin your entire fuzzing

00:02:14.301,00:02:20.240
campaign. And in the second part
of my talk uh I’ll present a new
coverage-guided fuzzer uh

00:02:20.240,00:02:26.079
implemented in pure python. That
uh is supposed to address all of
this problems and of course

00:02:26.079,00:02:30.851
we’ll compare it with AFL and
I’ll show you a couple of uh
vulnerable I managed to find

00:02:30.851,00:02:35.856
with this fuzzer. And so what is
fuzzing? And more importantly
what is coverage-guided fuzzing.

00:02:38.225,00:02:42.896
So the general idea uh of
fuzzing is actually a dream of
finding a professional

00:02:42.896,00:02:49.336
procrastinator, right. So you’re
on a special tool, uh this tool
mutated in both provides an

00:02:49.336,00:02:54.474
input into your target and you
just sit, wait for a crash,
that’s basically all. Let’s see

00:02:54.474,00:03:00.647
it on example. Uh let’s say we
have a very trivial problem that
crash an input eh pile on it. Uh

00:03:00.647,00:03:06.420
we start string uh five As uh
we, we cover this couple of
lines, program exists, we do it

00:03:06.420,00:03:12.092
again, and again, until we find
something that can uh cause a
crash in the target. Uh in this

00:03:12.092,00:03:17.097
example our fuzzer need to
mutate uh the string from 5 A to
PWNIT, and this is very unlikely

00:03:20.867,00:03:25.872
and can take hours or even days
uh to finally find this uh no
pointer reference so to be able

00:03:28.508,00:03:34.147
to address this problem people
invented uh coverage-guided
fuzzing. Uh people calls, also

00:03:34.147,00:03:41.021
call it uh feedback driven or
smart fuzzing. In this case we
continue mutating, uh our input

00:03:41.021,00:03:47.427
but at the same time we estimate
coverage uh triggered in our
target so if you see that our

00:03:47.427,00:03:52.966
input led to some new path in
the target we save this input
and then perform our sub secret

00:03:52.966,00:03:57.971
mutation on top of this input,
we do it again and again, we
apply the same algorithm for the

00:03:57.971,00:04:03.276
next finding, we save it, we
m-mutate the next byte, search
for potential new paths opened

00:04:03.276,00:04:09.683
by this mutation, then save it
again, and mutate the next byte
uh and you will finally find, uh

00:04:09.683,00:04:14.688
an input that can trigger a
crash in our target. So this way
we can cover the program in

00:04:17.090,00:04:21.828
steps and actually it
dramatically increase uh
efficiency of your fuzzing

00:04:21.828,00:04:26.833
campaign. So instead of spending
uh hours or even days uh doing
blind fuzzing uh you’d be able

00:04:29.636,00:04:33.840
to find this no pointer
reference just in couple of
seconds. So you see the

00:04:33.840,00:04:40.180
difference. And this algorithm
with the basic of the most known
uh today coverage-guided fuzzer

00:04:40.180,00:04:45.185
called American Fuzzy Lop or
AFL. So, AFL was created by
Michal Zalewski five years ago

00:04:48.455,00:04:54.060
and today it’s the standard de
facto coverage-guided fuzzer uh
for bugs hunting. Uh it’s

00:04:54.060,00:04:57.931
attracting people with it’s
efficiency and successful
stories of critical

00:04:57.931,00:05:02.502
vulnerabilities found with it,
and it’s very powerful uh
solution for vulnerability

00:05:02.502,00:05:07.507
research. Uh especially if you
have uh source code of your
target. So I have prepared a

00:05:09.609,00:05:15.749
short a visualization of how AFL
actually works. H- so here on
the screen we have four windows

00:05:15.749,00:05:20.887
uh in the left upper window we
can see AFL start to screen, it
just regular AFL start to

00:05:20.887,00:05:27.260
screen. In the right screen we
see number of uh files already
exist in our queue so as soon w-

00:05:27.260,00:05:33.800
as we continue mutating uh we
are increasing our files uh
number of how our files in, in

00:05:33.800,00:05:38.805
the queue. And so in the left um
middle uh window we can see uh
content of file of actual file

00:05:42.275,00:05:47.914
that we are going to provide in
our publication. And it’s in
hex, and I am in- I am

00:05:47.914,00:05:52.919
indicating with red the actual
change that AFL uh performing on
our input. Uh so you can see it

00:05:55.055,00:06:00.760
perform a lot of uh random
mutations in our file and as
soon as we continue mutating uh

00:06:00.760,00:06:07.300
this input uh the number of path
is growing, you can see it on
the plot on the top uh, on the

00:06:07.300,00:06:13.874
bottom left uh plot. This white
background so you can see it’s
growing and, and in this example

00:06:13.874,00:06:18.879
uh we uh we do fuzzing against
seventy it’s just um, let’s stop
this figure and move forward. So

00:06:22.215,00:06:27.787
for the past five years AFL
prove itself to be a very
efficient fuzzer to find memory

00:06:27.787,00:06:32.792
corruption box in many different
uh projects on many different
plot forms both uh in user land

00:06:34.995,00:06:40.000
and in the kernel of all widely
spread platforms uh there’s even
kernel version of AFL called KFL

00:06:43.303,00:06:48.308
uh I managed to find a couple of
boxes this uh tool but this is
different story. People even

00:06:50.677,00:06:55.915
search for bugs in a very
specific places like SCADA
system switchers, wireless

00:06:55.915,00:07:02.522
hardware, medical devices. Where
any problem is software quality.
And security can cause serious

00:07:02.522,00:07:07.527
consequences of human life. So
while mine, many of you might
think like okay Maks uh my only

00:07:10.330,00:07:16.636
corruption bugs are cool but
they’re in the cloud, uh right,
while this is true uh C and C

00:07:16.636,00:07:22.175
plus plus remains to be on the
top of the most used programming
languages so our world is

00:07:22.175,00:07:28.815
running on top of C or C plus,
plus fortunately or unfortunate.
Uh we can also look into

00:07:28.815,00:07:34.587
statistics on number of research
publications on fuzzing year by
year and we can definitely see

00:07:34.587,00:07:40.627
the trend. So it’s growing and
last year it exceeded fifteen
hundred publications. Eh it’s a

00:07:40.627,00:07:45.699
very hot research topic today, a
lot of people play uh with
fuzzing and a lot of companies

00:07:45.699,00:07:52.138
invest in this technology. Uh
Google even has an RSS fuzz
project where they integrated uh

00:07:52.138,00:07:57.744
fuzzing within uh
self-development life cycle of
one hundred seventy sixty open

00:07:57.744,00:08:03.750
source projects. Uh they use a
lot of fuzz CPU power and they
already identified uh thousand

00:08:03.750,00:08:08.755
memory corruption issues uh, um
by January half trillion test
cases per week. So this high

00:08:11.191,00:08:16.496
popularity of fuzzing across
security community means uh it
is becoming harder and harder to

00:08:16.496,00:08:22.569
find new bugs in products and
libraries already covered by
security researchers uh projects

00:08:22.569,00:08:29.075
like RSS path right? So we have
to search for some new strategy
and be able to perform fuzzing

00:08:29.075,00:08:34.547
more efficiently than other uh
tools and be able to perform
fuzzing more efficiently uh we

00:08:34.547,00:08:39.819
have to understand what kind of
issues already exist in modern
fuzzers and be able to address

00:08:39.819,00:08:46.359
them. So let’s start with the
first one and it’s uh volatile
paths. What does volatile paths?

00:08:46.359,00:08:53.066
Uh let’s say we have input, uh
eight As that cover this three
branches in our target it

00:08:53.066,00:08:59.406
indicated by green. Uh we will
take one B and now it covers uh
three previous branches and two

00:08:59.406,00:09:04.344
more shown in yellow. Let, so if
we uh, one second, okay, so if
we scan the input again in the

00:09:13.119,00:09:18.825
target uh it again cover only
the first three paths. So we, we
send absolutely the same uh

00:09:18.825,00:09:24.431
input in our target but uh now
it doesn’t cover a path
indicated by yellow and those

00:09:24.431,00:09:30.036
paths uh considered to be
volatile. They, they do not
depend on input but

00:09:30.036,00:09:36.209
parasitically executed in our
program due to some randomness.
And it happens pretty often,

00:09:36.209,00:09:42.549
especially if we work with,
we’ll just try the top-location.
And our father actually has a

00:09:42.549,00:09:48.154
dilemma, what to do with this
input, uh from one point of view
uh it can just try multiple

00:09:48.154,00:09:54.694
times, run, write and then
reject it uh if it sees some
path uh appears and disappears

00:09:54.694,00:10:01.201
uh after each run but what if we
actually discover something new
with this test case. Uh, this

00:10:01.201,00:10:07.540
situation we would reject a new
finding, uh okay we can keep
this case and raise the warning

00:10:07.540,00:10:14.347
for our users uh that’s what we
actually have in Israel but in
this case uh if our target is

00:10:14.347,00:10:19.486
very volatile we can end up with
a very large of corpus that uh
actually do not cover anything

00:10:19.486,00:10:25.692
new at all so we would just
waste an hour of our fuzzer
time. Second problem is

00:10:25.692,00:10:31.965
parallelization uh let's say you
have a really slow target and
you don’t know how or don’t know

00:10:31.965,00:10:35.835
how uh and don’t want to
actually spend time on
increasing performance uh of

00:10:35.835,00:10:41.207
your target right? So you are
not uh, performance engineer,
you’re security engineer. So uh

00:10:41.207,00:10:46.212
AFL uh wasn’t designed to be
parallel from the beginning. Uh
of course it’s functionality

00:10:48.248,00:10:54.621
that allow you to create master
and slave instances but uh let’s
discuss how it actually work.

00:10:54.621,00:10:59.626
Let’s say we have uh one master
instance and two slaves. Along
with three files in our corpus.

00:11:01.761,00:11:07.100
Uh AFL can perform the
deterministic mutation on master
instance and random tweaks on

00:11:07.100,00:11:12.105
slaves. So the corpus will be
corpus into each instance and
all the instances will perform

00:11:14.574,00:11:21.281
mutations uh in each file one by
one. If one slave finds
something new this file will be

00:11:21.281,00:11:27.387
distributed to other instances
and they will continue mutating
this uh, this same finding so

00:11:27.387,00:11:33.760
that’s all actually what we have
for chance of parallelization
and effort. Uh it will w-work

00:11:33.760,00:11:40.466
fine for fast targets and when
you have small corpus but it
will much p-perform much poorly

00:11:40.466,00:11:45.471
on slower targets uh especially
if we have uh real large corpus.
So there’s no easy way to

00:11:48.007,00:11:54.113
distribute this corpus between
instances and ask AFL to share
uh code coverage in a smart way

00:11:54.113,00:11:59.919
between them. And I believe we
can paralyze uh better here and
I'll show how a little bit

00:11:59.919,00:12:04.857
later. Uh another problem is a
lack of network fuzzing mode in
AFL at all. So we actually don’t

00:12:07.026,00:12:12.999
have much f-fuzzers that can
perform a network uh fuzzing
coverage-guided network fuzzing

00:12:12.999,00:12:19.906
uh at all especially on mark. On
networks we can try some uh
effort forks or honggfuzz uh on

00:12:19.906,00:12:25.211
windows there is network fuzzing
modes uh implemented by me last
year and we can try hongg

00:12:25.211,00:12:30.717
fuzzing mark. That’s actually
all. Unusually when you want to
fuzz network application the

00:12:30.717,00:12:37.624
general advice is to somehow
make your application to receive
input uh over file instead of

00:12:37.624,00:12:43.863
actually doing the fuzzing uh,
by sending network traffic
right. But it's significantly

00:12:43.863,00:12:48.501
reduced number of potential
applications where we can use
this approach. Uh especially if

00:12:48.501,00:12:53.506
we deal with black box binaries
when we don’t have source code
and we can’t just magnify uh our

00:12:55.808,00:13:01.481
target. Speaking about other
platforms such as windows, uh we
are significantly limited in

00:13:01.481,00:13:07.086
number of uh potential tools we
can use. Uh basically if you
don’t have source code uh

00:13:07.086,00:13:13.593
there’s winAFL and if it have
source code and our target can
become compiled with clang uh we

00:13:13.593,00:13:20.266
can apply lop fuzzer which is
basically designed to perform
fuzzing of uh library APA calls.

00:13:20.266,00:13:25.271
And that’s all. Uh, all of this
tools have their own limitations
of course. Uh on OS X we have

00:13:27.407,00:13:32.879
even less tools uh, eh, that we
can use to fuzz user ran
application. Uh basically we can

00:13:32.879,00:13:39.619
try to compile our target with
clunk and use lop fuzzer uh if
you have source code, uh if not

00:13:39.619,00:13:44.090
there’s actually nothing that
can perform coverage-guided
fuzzing for you, well at least I

00:13:44.090,00:13:49.462
don’t know about it. And of
course I’m not the first one who
wants to address this problem,

00:13:49.462,00:13:55.535
the a lot of researchers who
tried to address this issues and
improve AFL in some way such as

00:13:55.535,00:14:00.473
AFLFast, AFLSmart, winAFL,
libfuzzer, QSYM and many, many
other tools. Uh there a lot of

00:14:03.209,00:14:08.981
effort to leverage uh
coverage-guided fuzzing on
kernel. Uh such as these callers

00:14:08.981,00:14:15.188
demonstrate incredible results.
Uh along with KFL three fourths
and others. Uh I just listed

00:14:15.188,00:14:21.461
some projects here um, and
papers published in the last
year so we can dedicate entire

00:14:21.461,00:14:26.365
day describing different fuzzing
solutions and techniques and uh
there’s a nice paper where you

00:14:26.365,00:14:31.537
can find uh system wide research
on all the existing f-fuzzers if
you go, if you want to go deeper

00:14:31.537,00:14:36.342
in this topic. And I apologize
if I forget to include some
research or tool here, it’s not

00:14:36.342,00:14:41.214
because this tool is not great
it’s just be-because we have
limited amount of space here and

00:14:41.214,00:14:46.219
of course time. Uh however if we
summarize all of our
re-requirements and problems

00:14:48.821,00:14:53.826
that I described earlier we can
see there’s a huge uh demand uh
for a new fuzzer here. Uh this

00:14:56.496,00:15:01.734
fuzzer should be really flexible
in ter- in terms of scalability,
parallelization and platform

00:15:01.734,00:15:08.174
dependencies and the same time
it should be able to address uh
volatile path problem and be

00:15:08.174,00:15:14.614
able to support uh data mutation
with uh multiple fuzzing
strategies, uh eh, eh, in on

00:15:14.614,00:15:19.719
fuzzing campaign. Of course this
fuzzer should also support
functionality that already

00:15:19.719,00:15:24.590
exists in modern fuzzers that
allow a user to provide custom
mutation output to be able to

00:15:24.590,00:15:29.629
implement specific fuzzing
strategies or even enable a
structure where fuzzing, which

00:15:29.629,00:15:35.067
is very, very promising
technique uh today. So ladies
and gentlemen, let me

00:15:35.067,00:15:41.040
introduction Manul a new
coverage-guided fuzzer
implemented in pure python, let,

00:15:41.040,00:15:47.613
uh tries to address of the
issues I presented uh on the
previous part of my talk. Uh

00:15:47.613,00:15:53.085
Manul was born to be parallel,
uh from the beginning. It can
obtain coverage from AFL

00:15:53.085,00:15:58.090
instrumented binary or from DBI
uh frameworks like Intel Pin or
DynamoRIO. I’m trying to support

00:16:00.459,00:16:07.266
a Linux, windows and there’s a
better version uh better version
support of uh, for Mac. Uh I

00:16:07.266,00:16:13.673
decided to call it Manul after
the most fattest cat on the
planet. Uh basically in English

00:16:13.673,00:16:18.678
it’s called pallas cat but in
Latin it’s called uh otocolobus
manul. So Manul is very

00:16:21.714,00:16:28.054
adaptable cat, capable to live
when hot, uh in very severe
weather conditions of Central

00:16:28.054,00:16:33.826
Asia and I just like this cat
this is actually second DefCon
where I present exactly the same

00:16:33.826,00:16:40.533
slide and this template was
actually made out of this
picture so I process this from

00:16:40.533,00:16:47.373
their network and then just
applied black collar. Okay
moving forward. Let’s talk about

00:16:47.373,00:16:51.210
architecture. Of course Manul
employed modern based design, uh
you have network modern

00:16:51.210,00:16:57.283
instrumentation and modern s- uh
core, UI, uh mutators
implemented as plugins, this way

00:16:57.283,00:17:03.689
y-user can ask Manul to enable
and disable different putators
or will provide uh his or her

00:17:03.689,00:17:08.694
own and ask Manul to use them.
Uh, if we uh want to understand
how Manul address volatile path

00:17:10.830,00:17:17.069
problem uh it’s pretty straight
forward. Let's say we have uh
two volatile paths indicated by

00:17:17.069,00:17:23.843
yellow uh when Manul see our
input cover something new in the
target uh we will run this uh

00:17:23.843,00:17:29.282
input uh couple of times uh it’s
called calibration in
coverage-guided fuzzing and then

00:17:29.282,00:17:34.787
just uh if we see some uh
randomness in our coverage, some
random path, uh it will

00:17:34.787,00:17:41.661
temporarily blacklist uh this
path uh and ignores them uh in
the next runs. So first time I

00:17:41.661,00:17:48.267
found this out it in KFL uh
kernel fuzzer and I just decided
to integrate it with Manul

00:17:48.267,00:17:54.373
probably it was introduced s- in
some other fuzzer but I first
found it in KFL. Okay and moving

00:17:54.373,00:18:01.047
forward, parallel fuzzing is
default feather in Manul. Uh you
just need to specify uh how many

00:18:01.047,00:18:06.919
fuzzing instances you want to
spin up using the command line
argument. So Manul will

00:18:06.919,00:18:13.492
automatically start uh all of
them and split the corpus
equally uh to each instance. So

00:18:13.492,00:18:19.198
in this case uh each instance
will ha- will have on a smart
part, uh small part of the

00:18:19.198,00:18:24.670
corpus, so we will have one w-
w- this was we can smart
distribute our corpus uh across

00:18:24.670,00:18:31.444
instances and we can even spin
up remote instance on some other
machine, uh, uh available over

00:18:31.444,00:18:36.782
network. So Manul will be able
to share corpus and coverage
with this remote instance uh

00:18:36.782,00:18:42.221
like it’s running on the same
machine, this way you can link
uh, eh, have your own like

00:18:42.221,00:18:48.294
fuzzer squasher on top of Manul.
And basically each instance is
an independent byte and process

00:18:48.294,00:18:54.467
that virtualize it’s own uh
shared memory. Uh at the same
time uh Manul main process uh

00:18:54.467,00:19:01.240
will be able to synchronized uh
coverage and share it across uh
other instances to always double

00:19:01.240,00:19:07.713
work for them. So if one
instance uh found some new path,
uh in the target all other

00:19:07.713,00:19:13.519
instances will at some point uh
know about that and will c-
focus on something else so in

00:19:13.519,00:19:19.025
this way we can smartly
distribute our fuzzing campaign
across all available corpus. Uh

00:19:19.025,00:19:25.398
user can easily provider this
third party mutator with
plugins, uh so it’s only

00:19:25.398,00:19:31.103
required to place uh your plug
in a second folder where Manul
main binary can locate it. And

00:19:31.103,00:19:37.443
plugins can be implemented in
python and should contain init
and mutate functions. Um so far

00:19:37.443,00:19:41.447
I have implemented two fuzzing
strategies by default so you
already have it in Manul. Uh the

00:19:41.447,00:19:46.452
first one is AFL strategy uh
ported from C two python and the
second one is Radamsa uh

00:19:49.221,00:19:54.226
distributed as uh native
library. Network fuzzing is an
experimental feature. So you can

00:19:56.562,00:20:01.567
try to fuzz TCP or UDP server,
it works and you can ask Manul
to act as a TCP or UDP uh server

00:20:03.803,00:20:10.409
to, to fuzz some network client.
But this feature in very better
stage so expect problems. And

00:20:10.409,00:20:15.414
blackbox binary uh fuzzing is a
very important part of Manul so
by default uh Manual is supplied

00:20:17.450,00:20:24.423
with two DBI clients for intel
pin and DynamRio. Uh Manul will
start a binary using one of this

00:20:24.423,00:20:31.063
uh frameworks so y-you can
choose what you want to DynamRio
or Intel Pin then DynamRio or

00:20:31.063,00:20:35.701
Pin launcher with start uh your
target, inject instrumentation
library, instrumentation library

00:20:35.701,00:20:41.407
will pen shared memory and it
will share c-coverage uh back to
Manul. So pretty straight

00:20:41.407,00:20:47.346
forward way and I recommend to
use DynamoRio because Pin is
only supported on Linux and uh

00:20:47.346,00:20:53.085
it’s slow. So this is how it
looks when you’re on it on
Windows. Uh Manul will launch a

00:20:53.085,00:20:59.258
lot of python uh processes, each
of them run DynamoRio, DynamoRio
launcher will run the target and

00:20:59.258,00:21:03.362
uh is injected instrumentation
library and then instrumentation
library will provide coverage

00:21:03.362,00:21:09.568
back to uh python process,
pretty straight forward. Uh this
is interface, we have

00:21:09.568,00:21:15.508
information about volatile
bytes, coverage, number of
iterations, crash, uh exceptions

00:21:15.508,00:21:20.379
and many other useful things. Uh
and it, it also has its own
logging implement as [inaudible]

00:21:20.379,00:21:26.585
so just, just to have log, each
tool should have logger. So
Manul supports seven most used

00:21:26.585,00:21:32.625
options where command line and
dozens of fuzzers should be
provided uh in their

00:21:32.625,00:21:37.630
configuration uh and this way
you can uh adjust Manual for
your own purposes. And let’s see

00:21:39.899,00:21:44.904
it in action. SO this is Manul
main folder with a lot of files
uh for different platforms, we

00:21:47.606,00:21:52.611
have the main script here, uh
network model, uh utils, uh AFL
mutat-, uh for printing model,

00:21:56.248,00:22:02.421
AFL mutator poses from C to
python, that’s the binary for
Linux configuration file uh we

00:22:02.421,00:22:08.794
can look the uh code is just uh
straight forward python code,
nothing fancy here. I try to

00:22:08.794,00:22:13.799
make it as clean as possible to
be able uh people to contribute.
So we have uh also uh AFL

00:22:16.268,00:22:21.273
imported from uh C to python we
see a lot of different uh
strategies uh from AFL and w- we

00:22:24.376,00:22:29.815
have couple of folders. In
windows folder we have uh
folders for DBI, and

00:22:29.815,00:22:35.554
instrumentation libraries for
sixty-four and thirty-two bits
and same for linux. So you can

00:22:35.554,00:22:40.559
just, uh, uh launch them and run
against black box binaries. And
if you look to the command line

00:22:42.795,00:22:48.100
options it’s again like uh any
other fuzzer, you have to
provide a path with your files

00:22:48.100,00:22:53.906
that you want to submit at your
target output, number of
parallel fuzzers, uh switch

00:22:53.906,00:22:59.478
between dump or smart mode, uh
you can provide path to
configuration file there’s more

00:22:59.478,00:23:04.450
options and you can restore
previous session. So if you’re
looking to configuration file we

00:23:04.450,00:23:09.655
can find much more options so
they should be provided in this
file format so just option

00:23:09.655,00:23:16.595
there, splice that equal values.
Uh we can enable dictionary for
uh AFL uh strategy so AFL will

00:23:16.595,00:23:21.600
inject targets and we also can
um assign w-weights for AFL so
in or radamsa for example we can

00:23:24.737,00:23:30.709
say uh radamsa should mutate
twenty percent of our test cases
and AFL eighty percent. Or we

00:23:30.709,00:23:36.315
can enable our own uh fuzzing
strategy uh just by specifying
it’s name for example we can

00:23:36.315,00:23:40.986
say, example mutator should
mutate twenty percent of our
test cases. We can run this

00:23:40.986,00:23:47.026
deterministic seed, uh we can
run uh print uh more
information, we can disable this

00:23:47.026,00:23:52.731
volatile paths uh suppression
algorithm uh that I showed uh
previously. And to be able to

00:23:52.731,00:23:57.936
start uh black box binary
fuzzing you have to specify
which DBI framework you want to

00:23:57.936,00:24:02.574
use. So it’s DyanmoRio or
IntelPin uh if its’ DynamoRio
you have to provide DBI route

00:24:02.574,00:24:09.148
where it’s located, uh the
launcher uh then client, uh
supply it with Manul and you can

00:24:09.148,00:24:15.554
also specify for Manul what kind
of libraries you want to uh
instrument uh along with uh your

00:24:15.554,00:24:21.460
target binary so this way you
can include them in your cot
cov- coverage. This timeout uh

00:24:21.460,00:24:26.465
also this options net config
master netconfig slave can be
used to uh spread Manual over

00:24:29.068,00:24:34.073
network you just need to specify
port and IP address uh you can
run it uh in debug mode if you,

00:24:36.108,00:24:42.548
if you need more information.
Synchronization between uh, uh
different uh fuzzing instances

00:24:42.548,00:24:47.553
and we have command line fuzzing
uh as an experimental feature
just uh in this case Manul will

00:24:50.756,00:24:55.527
send it over uh command line.
And to be able to enable network
fuzzing you just need to specify

00:24:55.527,00:25:01.200
the end port, uh for example and
protocol so for example instead
of TCP or IDP we want to fuzz it

00:25:01.200,00:25:07.673
over TCP. And we can also ignore
signals, for example single
port, which is quite annoying,

00:25:07.673,00:25:12.678
uh if uh it, it, it will
consider it as false positive.
Okay we can actually start it,

00:25:15.180,00:25:20.185
so we just need to say where is
my binary uh input folder, then
provide uh output folder in this

00:25:23.789,00:25:29.695
case we will we are doing
fuzzing against [inaudible] uh
then number of um parallel

00:25:29.695,00:25:36.368
threats, like twenty for example
then pass to our main binary
line an AFL and then uh command

00:25:36.368,00:25:41.373
line, like options and that’s
all. Then, then just enter, uh
it will spin up a lot of

00:25:43.542,00:25:48.814
instances uh each instance will
perform its own mutations then
you can see the dry run is

00:25:48.814,00:25:53.819
finished uh so it’s running we
already identify uh c-, identify
a couple of crashes and the lot

00:25:56.622,00:26:02.561
of other useful information like
coverage statics, performance,
executions per second uh files I

00:26:02.561,00:26:09.201
queue uh timing, uh what kind of
mode we are running and
strategy. Okay so I guess we can

00:26:09.201,00:26:15.574
stop it and move forward. Now
let’s discuss uh vulnerabilities
that I managed to find with this

00:26:15.574,00:26:20.579
tool. So Poppler i- is an open
source library for internet PDF
documents mostly used on Linux.

00:26:23.115,00:26:28.654
Free software products like
Evince, LibreOffice, Inkscape,
is by millions of users across

00:26:28.654,00:26:33.425
the world integrated this
library for PDF documents
handling. And Poppler

00:26:33.425,00:26:39.565
participate in Google uh, uh
fuzz program which make it,
makes it much harder to identify

00:26:39.565,00:26:45.604
new vulnerabilities uh and this
target is an AFL and lop fuzzer
because Google already generated

00:26:45.604,00:26:52.010
three months of test cases so
you uh, we just don’t have
enough uh ICP power. Okay, so I

00:26:52.010,00:26:57.082
decided to try the same setup
code with corpus four hundred
and ninety-one PDF files uh used

00:26:57.082,00:27:02.788
by OSS-Fuzz uh and run the
latest version of AFL and Manul
for twenty-four hours uh with

00:27:02.788,00:27:09.094
seventy eight uh parallel jobs.
As you can see on ours, AFL was
approximately twenty-five

00:27:09.094,00:27:16.034
prevent faster compared to Manul
but execution speed is not uh
the key factor here. If you

00:27:16.034,00:27:22.508
compare paths uh found by Manul
and the AFL we can clearly see
that after nine hours of running

00:27:22.508,00:27:27.513
uh Manul managed to outperform
AFL and continue discover uh new
paths in the targets uh fuzzers

00:27:30.282,00:27:35.988
in AFL. And this was possible
because of their improvements uh
that I introduced in the second

00:27:35.988,00:27:42.461
part of my talk so our corpus
parallelization plus volatile
path suppression plus

00:27:42.461,00:27:48.333
combination of two mutators uh
give us much better results
despite of uh lower execution

00:27:48.333,00:27:53.338
speed. And more importantly uh
Manul managed to discover three
uh zero-day vulnerabilities and

00:27:55.407,00:28:00.212
five non-security related bugs
in Poppler uh previously of
course are known for developers.

00:28:00.212,00:28:06.285
So uh next assigned the
following CVEs for this
vulnerabilities from medium to

00:28:06.285,00:28:11.290
critical server reacher rate and
let’s actually discuss couple of
them. Okay so the first bug uh

00:28:19.731,00:28:25.437
the first bug uh is a heap
overflow that exist in down
sample row box filter which is

00:28:25.437,00:28:31.043
called by down scale image in
lib cairo library and this
version is actually used to

00:28:31.043,00:28:36.949
downscale JPG images that may
exist in PDF objects, uh I don’t
want to go deep into technical

00:28:36.949,00:28:41.954
details here uh it’s not
important uh all we need to know
is we can use um, uh w-we can

00:28:44.122,00:28:50.629
trigger heap overrun by
controlling basic coverage
variable uh I marked as red and

00:28:50.629,00:28:55.634
force this version to read out
of heap junk to variables A, R,
G and B. And at line forty we

00:28:59.838,00:29:03.976
can write these values to the
destination buffer, to the best
of my knowledge uh I don’t’ see

00:29:03.976,00:29:10.916
straight forward way to exploit
it but most likely we can use
this uh,uh approach this

00:29:10.916,00:29:15.954
vulnerability uh to get some
point or link out of this
vulnerability which might be

00:29:15.954,00:29:20.959
very useful if you want to
bypass SLR. Uh okay the second
bug is located in GPX three

00:29:23.362,00:29:29.334
million, uh this version doesn’t
have a check for negative values
so I highlighted in red where

00:29:29.334,00:29:35.173
Poppler read uh bufsize which we
can control and call to unsign
the chars version without

00:29:35.173,00:29:40.178
actually checking size of
bufsize. So in this fashion to
unsign the chars an initial size

00:29:42.314,00:29:48.487
can be very large uh so it makes
possible to allocate uh really
large heap chunk of arbitrary

00:29:48.487,00:29:54.793
size. Uh we can use this block
as a second stage eh in house of
force for heap metadata

00:29:54.793,00:29:59.798
exploitation uh where we need to
allocate a large chunk uh to be
able to force malloc return an

00:30:02.601,00:30:08.407
arbitrary point uh, uh pointer
to arbitrary place in our, in
our target binary. Okay the last

00:30:08.407,00:30:13.412
bug is more dangerous. Uh here
we control variable I that can
be negative which might cause an

00:30:16.648,00:30:23.221
integer sinus error and keep and
out of bounds read un controlled
by an attacker. So if I can

00:30:23.221,00:30:29.628
satisfy the first condition and
avoid this really really huge
statement uh basically what we

00:30:29.628,00:30:34.633
can do we can return another st-
an arbitrary object uh in memory
which is uh already pretty

00:30:36.935,00:30:41.940
scary. So the caller function
will check uh if this object is
not zero and then uh call one of

00:30:44.443,00:30:50.382
it’s methods which is pretty
straightforward way to get
control over RIP so I indicated

00:30:50.382,00:30:57.122
uh in red, w- this is our
function get entry and then we
just call entry to get flag, and

00:30:57.122,00:31:03.729
instead of get flag we can place
a pointer to any place uh th- t-
to any fashion that we want. Uh

00:31:03.729,00:31:10.001
the other problem here is to
prepare this object in the right
way and allocate it in the right

00:31:10.001,00:31:16.641
place but I believe it's really
possible uh so very straight
forward to explore this

00:31:16.641,00:31:21.646
vulnerability. Okay uh moving
forward. Zeek, uh formerly known
as Bro Ideas. Uh it’s evolved uh

00:31:25.617,00:31:31.923
most powerful open source
framework um used by thousands
of companies and institutions uh

00:31:31.923,00:31:37.863
across the planet. Uh there are
lot of very powerful plugins for
Zeek such as J three design and

00:31:37.863,00:31:42.000
to fingerprint uh SSL
communications uh which is a
very powerful technique to

00:31:42.000,00:31:44.136
detect suspicious uh and
encrypted connections usually
performed by malware to

00:31:44.136,00:31:47.272
communicate with C two or write
human plant communicate with C
two depending what we’re talking

00:31:47.272,00:31:51.910
about. So this project even has
its own conference called Bro
Con uh which takes place in

00:31:51.910,00:31:56.915
Ireland on every October. So
afters of Zeek is very aware of
memory corruption issues and

00:32:05.423,00:32:10.328
fuzzing technique in general uh
because even as simple deny of
service is completely

00:32:10.328,00:32:16.134
unacceptable for such type of
security products. So the
qualities pretty high, I would

00:32:16.134,00:32:22.240
say v-very high and they have
done multiple fuzzing companies
in the past so it was actually

00:32:22.240,00:32:28.280
seriously challenge for Manul.
Unfortunately, Zeek has very
complex initialization routine

00:32:28.280,00:32:33.418
that usually takes up to ten
seconds to initialize and start
uh traffic monitoring and it was

00:32:33.418,00:32:38.423
very really early stage of Manul
that it was like just couple of
python scripts. So in this case

00:32:40.892,00:32:46.331
uh if you t- if your target
takes ten seconds to initialize
it’s completely unacceptable for

00:32:46.331,00:32:52.204
fuzzers to wait for ten seconds.
Uh fortunately they have done a
couple of fuzzing campaigns in

00:32:52.204,00:32:58.944
the past with lop fuzzer uh so I
managed to find an example of
this with its long utilization

00:32:58.944,00:33:04.282
routine. So all we need is to
implement a special router for
each protocol we want to fuzz

00:33:04.282,00:33:09.287
and an example of such fuzzer
for SSH protocol um uh shown on
this slide along with other ten

00:33:12.257,00:33:18.196
uh protocols. So I run both
fuzzers for twenty-four hours
with uh seventy-eight parallel

00:33:18.196,00:33:24.302
instances for each protocol and
managed to find three previously
unknown vulnerabilities and AFL

00:33:24.302,00:33:29.841
found zero bugs. Uh this is a
list of vulnerabilities they
found uh two of them allocated

00:33:29.841,00:33:34.846
in Kerberos and the last one in
IRC protocol implementation. So
while fuzzer most application

00:33:37.349,00:33:42.587
memory leak is not a big deal uh
for Zeek might cause a serious
issue if memory is not free uh

00:33:42.587,00:33:49.094
in a p- packet process and
function so memory leak in this
case is a memory allocated on

00:33:49.094,00:33:54.099
the heap but never freed. In our
case we have memory leak in the
function uh shown on the slide

00:33:56.468,00:34:02.707
at number one, uh so, so each
Kaberos packet will cause Zeek
to allocate around one hundred

00:34:02.707,00:34:08.713
thirty kilobytes of memory which
will never be free later in the
code and we need to send a lot

00:34:08.713,00:34:15.153
of packets to force Zeek uh
allocate this a lot of memory on
the machine. And finally cause

00:34:15.153,00:34:20.759
in our service I was able to
write a simple exploit which
usually takes about seven, eight

00:34:20.759,00:34:27.699
hours to force Zeek uh allocate
fifteen uh gigabytes of memory
leading to crash. But sending a

00:34:27.699,00:34:33.738
lot of packets is a bit boring
right? Uh what about one packet
that can cause a deny service

00:34:33.738,00:34:40.712
and stop network traffic
analysis remember IRC protocol a
decade ago it was a very popular

00:34:40.712,00:34:45.717
way to communicate with people
in IRC chats using ICQ so the
protocol is text based and

00:34:47.886,00:34:54.826
pretty simple uh you have a
numerical code uh command space
and then user string. For

00:34:54.826,00:35:01.266
example using command three five
three uh which is numerical code
for Nick then space the name, uh

00:35:01.266,00:35:08.073
will assign a nickname in IRC
chat for you. Uh but if I send
this command without actual

00:35:08.073,00:35:14.512
nickname, uh so the function
party begins uh part begin uh
will return zero uh then parts

00:35:14.512,00:35:18.883
erase will be called with this
zero which will finally
obviously lead to no pointer to

00:35:18.883,00:35:23.888
reference and segmentation
fault. However IRC protocol is
not enabled by default and we

00:35:26.691,00:35:33.565
actually need something else. Uh
it’s usually uh up to uh blue
team to enable or disable uh

00:35:33.565,00:35:40.505
monitor of IFC. But the last bug
in Kerberos protocol was a bit
more complex so I don’t want to

00:35:40.505,00:35:47.245
go deep into technical details.
So this problem I actually uh
don’t’ uh quite understand it

00:35:47.245,00:35:54.119
at, at this point, hah, anyway.
But it seems like there’s an
integer type mismatch and big

00:35:54.119,00:36:00.458
pack generated parser code and
Zeek uh analyzer itself uh that
potentially can cause an

00:36:00.458,00:36:05.830
unintentional paths in some
situations to be executed
leading to no pointer to

00:36:05.830,00:36:11.302
reference uh in the Kaberos
protocol parser and usually it
happens like ninety percent uh

00:36:11.302,00:36:17.976
of the time. So we just need to
send our packets three times
instead of one. And let’s see it

00:36:17.976,00:36:23.882
in action. So we’re on the linux
machine we have two files, uh
the first file is the python

00:36:23.882,00:36:28.887
script that will connect to
Kerberos server and it receive
an AP port and path to the file

00:36:30.889,00:36:37.796
with malformed Kerberos packets.
Uh the second file contains
actual data so actual malware

00:36:37.796,00:36:43.601
Kaberos packets and we have a
virtual machine with uh Zeek and
just to make it simple our

00:36:43.601,00:36:48.807
Kerberos server script is also
placed uh, on, on this virtual
machine. So, in this script we

00:36:48.807,00:36:55.180
have uh to specify AP and
default Kaberos port which is
eighty-eight and file that we

00:36:55.180,00:37:00.118
want to use for response. So
let’s actually start it. And uh
I would just uh n-need to

00:37:04.589,00:37:09.594
specify where the scripts uh
file that we want to answer,
then we can run uh Zeek itself

00:37:12.697,00:37:19.270
it’s just uh w-we have to
specify a name u interface that
we want to listen on and this

00:37:19.270,00:37:25.443
our IP address, basically it’s
just like local IP address of
our virtual machine. But again

00:37:25.443,00:37:32.083
this Kaberos server can be
placed anywhere in the network.
And now we can just uh run uh

00:37:32.083,00:37:37.088
this client we just need to
specify API address, uh port and
our uh packets. So it already

00:37:39.591,00:37:44.596
assigned and we can see
segmentation fault and uh like
stop of network analysis. So

00:37:46.731,00:37:51.736
this is a pretty straightforward
way. So there is really
pre-pretty straightforward way

00:37:58.910,00:38:03.848
to disable traffic monitoring in
the network and uh then
communicate with uh malware uh

00:38:06.951,00:38:13.858
with C two uh or do some great
human engagement on top of this
finding. And I managed to catch

00:38:13.858,00:38:20.265
more bugs with Manul in other
applications such as an open
source uh tool 7-Zip it’s Linux

00:38:20.265,00:38:26.538
version p7Zip and unarchiver for
Mac. But unfortunately, this bug
is still waiting uh to be

00:38:26.538,00:38:32.277
punched by maintainer, for
example for P7-zip last time he
was online was two thousand

00:38:32.277,00:38:37.282
seventeen, I hope he is fine, so
again this bugs are waiting to
be punched. Uh I’m not going to

00:38:41.252,00:38:47.125
disclose them today but I’ll
definitely publish a post about
this in future when uh the

00:38:47.125,00:38:53.298
maintainers will fix it. Uh two
of them allow remote c- like
code exec arbitrary code

00:38:53.298,00:38:59.304
execution. Of course Manul is
now in better stage right?
There’s a lot of functionality

00:38:59.304,00:39:03.408
that wasn’t tested deeply enough
such as anything related to
network uh any help

00:39:03.408,00:39:09.514
contributions more than welcome
here. Uh what is strongly
required for now is AFL

00:39:09.514,00:39:15.787
forkserver to be able to speed
up Manual and perform network
fuzzing more efficiently uh I

00:39:15.787,00:39:22.760
also want to add Intel PTrace on
Linux and Windows uh I believe
Manul can be even stronger with

00:39:22.760,00:39:27.765
uh structure-aware fussing. So
more mutation algorithms again
is strongly required. And uh

00:39:30.501,00:39:35.506
basically on MacOS we have a lot
of stuff to do. This point of a
lot of future work uh Manul

00:39:38.276,00:39:44.148
already demonstrated that it’s a
very efficient coverage-guided
uh fuzzer that can catch bugs in

00:39:44.148,00:39:49.153
really tough targets already
tested by uh top security
researchers and I’m going to I

00:39:51.723,00:39:57.161
already released uh like fifteen
minutes ago uh it's already
public uh its released under a

00:39:57.161,00:40:02.166
punch two point zero license so
you can already pull it from my
GitHub account and find your own

00:40:05.436,00:40:11.809
zero days with this still. So
you can subscribe to my twitter
account, email me on linkedin if

00:40:11.809,00:40:16.814
you have and c- any questions
you can catch me later at DefCon
uh this after this talk or PM me

00:40:19.250,00:40:20.985
on Twitter, so thank you for
your attention.

