00:00:00.267,00:00:05.105
>>Alright hi everyone and thanks
for coming to our talk relaying
credentials has never been

00:00:05.105,00:00:10.110
easier: How to easily bypass the
latest NTLM relay mitigations.
I’m Marina Simakov >>I’m Yaron

00:00:12.446,00:00:18.318
Zinar >>Eh we’re both security
researchers from Preempt and
today we want to talk to you

00:00:18.318,00:00:23.757
about some of the
vulnerabilities that we are able
to discover this year. So we

00:00:23.757,00:00:27.661
have a lot of ground to cover
lets see the agenda for the talk
we will begin with the short

00:00:27.661,00:00:33.433
introduction to active directory
will see some common attacks and
we’ll focus a lot on the NTLM

00:00:33.433,00:00:39.406
protocol we’ll see design
weaknesses the NTLM relay attack
and some of the, bless you, and

00:00:39.406,00:00:45.145
some of the offered mitigations
that we have against NTLM relay
attack, then we will move onto

00:00:45.145,00:00:48.949
talk about some of the
vulnerabilities we will see some
known vulnerabilities against

00:00:48.949,00:00:54.321
this eh attack and then we will
see the new vulnerabilities that
we discovered this year,

00:00:54.321,00:01:00.694
allowing us to bypass all the
mitigations against NTLM relay.
We’ll also show you how NTLM can

00:01:00.694,00:01:05.999
be used in order to attack ADFS
servers and we will present
something new that we like to

00:01:05.999,00:01:11.004
call reverse kerberoasting and
finish with some takeaways. I
guess most of you are familiar

00:01:13.140,00:01:18.245
with active directory but I’ll
give just a brief overview just
incase, active directory is the

00:01:18.245,00:01:23.617
main secret storage of the
domain it stores the password
hashes of all the accounts and

00:01:23.617,00:01:29.289
it’s in charge it’s in charge of
authenticating accounts against
domain resources. This can be

00:01:29.289,00:01:36.063
done using three different
protocols LDAP NTLM or Kerberos
and today we will focus on NTLM,

00:01:36.063,00:01:41.068
the NTLM protocol, and the NTLM
relay attack. So you might be
scratching your heads thinking

00:01:43.870,00:01:48.875
is NTLM even still relevant and
even though we’ve had Kerberos
for quite a while now we haven’t

00:01:50.944,00:01:57.050
been able to see a single
environment which doesn’t, which
disables NTLM entirely so if

00:01:57.050,00:02:01.788
attackers can use it, they can
attacker using it and will tell
you err will show you the

00:02:01.788,00:02:07.627
vulnerability that we were able
to find. So it’s quite relevant.
Now let’s see the flow of this

00:02:07.627,00:02:12.866
protocol. Let’s say we have some
user that wants to authenticate
against some domain server.

00:02:12.866,00:02:18.105
Let’s see how the authentication
processor’s work. The client
would send an NTLM negotiate

00:02:18.105,00:02:23.043
message to the server, the
server would respond with the
challenge and now the client

00:02:23.043,00:02:28.715
would need to encrypt the
challenge using the password
hash of the user’s account and

00:02:28.715,00:02:34.321
send it back to the server in
the NTLM authenticate message.
Now since this server does not

00:02:34.321,00:02:39.659
store the password hashes of the
user’s it cannot validate th the
challenge was encrypted using

00:02:39.659,00:02:44.798
the correct password hash. So
that’s where the domain
controller comes in. The server

00:02:44.798,00:02:50.237
would send a NETLOGON request to
the domain controller with the
challenge and the response and

00:02:50.237,00:02:54.441
the domain controller would
validate whether it was
encrypted using the expected

00:02:54.441,00:02:59.446
password harsh and respond with
an approve or reject response
accordingly. One of the problems

00:03:01.481,00:03:07.654
with this protocol is that the
NTLM protocol is not bound to
the target servers. So if this

00:03:07.654,00:03:13.326
server in the middle gets
compromised it can relay the
NTLM authentication in order to

00:03:13.326,00:03:18.865
establish a connection against
another server. This is exactly
what happens in the NTLM relay

00:03:18.865,00:03:23.870
attack. Lets see the flow of
this attack. We’ll have a client
connect to a compromised server

00:03:23.870,00:03:30.177
using an NTLM negotiate message.
So this can be done by attackers
compromising server which users

00:03:30.177,00:03:35.849
constantly connect to or by
sending eh phishing email to the
user when the user collects from

00:03:35.849,00:03:42.722
the link and NTLM authentication
is initiated. Now attackers will
choose a target in the domain

00:03:42.722,00:03:47.494
which they want to relay the
credentials to and relay the
NTLM negotiate to the target.

00:03:47.494,00:03:52.766
Receive a challenge relay it
back to the eh client machine
the client would now encrypt the

00:03:52.766,00:03:58.438
challenge using the required
password hash send it back to
the compromised server and now

00:03:58.438,00:04:03.143
all the attackers need to do is
simply relay that last message
back to the attack target and

00:04:03.143,00:04:07.447
since the challenge wasn’t
encrypted using the correct
password hash the domain

00:04:07.447,00:04:12.385
controller would approve the
request and now attackers have
an authenticated session against

00:04:12.385,00:04:18.892
their attack target So notice
that at any stage the attackers
did not have knowledge of the

00:04:18.892,00:04:24.464
password hash of the user all
they did was relay messages back
and forth between the client and

00:04:24.464,00:04:29.503
the server and if that
authenticated user is the local
admin on the target machine

00:04:29.503,00:04:34.341
attackers can now remotely
execute code on that machine
down files or entirely

00:04:34.341,00:04:40.714
compromise that computer. This
is a pretty serious attack
vector. Lets see some of the

00:04:40.714,00:04:47.354
mitigations that we have against
this attack. So the two most
critical mitigations that we

00:04:47.354,00:04:54.194
have are session signing we have
SMB and LDAP signing and also we
have EPA and Channel Binding

00:04:54.194,00:04:58.965
which we will be focusing on
today and we will show you how
we are able to bypass both those

00:04:58.965,00:05:05.305
mitigations. OK lets give you a
brief overview of what each
mitigation means. The session

00:05:05.305,00:05:10.844
signing means that after the
autho until authentication is
completed all the communication

00:05:10.844,00:05:15.615
between the client and the
server would need to be signed.
Now the signing key would be

00:05:15.615,00:05:21.288
derived from the authenticating
user’s password hash. So since
the client has this password

00:05:21.288,00:05:27.060
hash it would simply calculated
by itself and the server does
not have the password hash so it

00:05:27.060,00:05:32.399
will be getting the signing key
from the domain controller in
the net log on response now if

00:05:32.399,00:05:37.737
we have a relay in the middle it
will simply have no way to
retrieve the signing key it

00:05:37.737,00:05:42.409
would not be able to send any
signed packets through the
attacked targets and the attack

00:05:42.409,00:05:48.281
would fail. This is a very
important mitigation, however,
unfortunately not enough servers

00:05:48.281,00:05:54.788
in for sessions signing by
default today. OK so lets see
the flow of this mitigation

00:05:54.788,00:05:59.960
we’ll have a client connecting
to a compromised server,
attackers would really the NTLM

00:05:59.960,00:06:04.464
negotiation challenge and
response and then the attack
target would send the NETLOGON

00:06:04.464,00:06:09.669
message to the domain controller
it would also receive the
session signing key and also the

00:06:09.669,00:06:14.407
client would calculate the
signing key by itself so both
the client and the attack target

00:06:14.407,00:06:19.846
have the signing key however the
compromised server in the middle
has no way to retrieve that key

00:06:19.846,00:06:24.851
it cannot send any signed
packets to the target and the
attack fails. Alright second

00:06:27.187,00:06:31.391
mitigation that we want to
discuss with you today is EPA
enhanced protection for

00:06:31.391,00:06:37.397
authentication and here the goal
is to protect NTLM
authentications from being

00:06:37.397,00:06:43.770
relayed over a TLS session. So
the goal is to bind the NTLM
authentication to the TLS

00:06:43.770,00:06:49.175
session over which the
authentication occurs and the
infilmentation is done by adding

00:06:49.175,00:06:54.180
an additional field to the last
NTLM authenticate message called
Channel Binding, This field is

00:06:56.716,00:07:02.656
based on the hash of the targets
servers certificate so if you
have a relayer in the middle it

00:07:02.656,00:07:07.394
would be using a different
certificate then the attack
target and the value provided by

00:07:07.394,00:07:12.299
the client in the chan in the
channel binding field would be
based on the certificate of the

00:07:12.299,00:07:17.537
compromised server so if an
attackers trie attackers tries
to relay that message to another

00:07:17.537,00:07:22.709
target the attack would simply
fail because of an incorrect
channel binding field. Ok let’s

00:07:22.709,00:07:28.014
clarify this with an example,
again we will have a client
connecting using a TLS

00:07:28.014,00:07:33.486
compromised server and
initiating an NTLM
authentication. Now attackers

00:07:33.486,00:07:40.460
would target a server which
enforces EPA and establish a TLS
session relay that NTLM

00:07:40.460,00:07:44.831
negotiate message get a
challenge relayed back to the
client and here is the

00:07:44.831,00:07:50.537
difference. Now when a client
response with an NTLM
authenticated message the messha

00:07:50.537,00:07:55.875
message would also include this
channel binding field which
would be based on the target's

00:07:55.875,00:08:02.082
certificate of the compromised
server. So if attackers now try
to relay this message back to

00:08:02.082,00:08:06.953
the attack target the attack
target is using a different
certificate and the channel

00:08:06.953,00:08:11.991
binding field would not be
valid. So the attack would fail
and the attack target would not

00:08:11.991,00:08:18.498
need to verify the credentials
against the domain controller.
OK so we’ve seen some of the

00:08:18.498,00:08:23.570
mitigations let’s now discuss
some of the vulnerabilities
we’ll show you some all the

00:08:23.570,00:08:28.108
vulnerabilities which were
previous discovered and then we
will show you how you bypass all

00:08:28.108,00:08:33.113
the mitigations that I have just
presented. >> Thanks Marina for
that great introduction. Often

00:08:35.448,00:08:40.620
these many vulnerabilities were
found that allowed the attackers
to launch successful NTLM relay

00:08:40.620,00:08:45.625
attacks. And now we view a few
of them. So the first
vulnerability I want to talk

00:08:48.027,00:08:53.032
about is LDAP S relay that
vulnerability was discovered by
our team 2017, so as Marina

00:08:55.402,00:09:00.340
mentioned, NTLM is not protected
by the fault from NTLM relay to
protect a specific application

00:09:02.375,00:09:07.313
you will need to either enable
server signing of EPA. For at
the servers on the domain

00:09:07.313,00:09:12.318
controllers there is a GPO for
enabling editors server signing.
When that GPO is enabled the

00:09:14.754,00:09:20.527
LDAP server would req would
accept LDAP requests that are
signed but also it would accept

00:09:20.527,00:09:26.866
any LDAP request over TLS this
is sometimes referred to as
LDAPS. This means that LDAP

00:09:26.866,00:09:32.839
servers were completely
vulnerable to NTLM relay over
LDAPS. We have disclosed this

00:09:32.839,00:09:39.546
vulnurability to Microsoft two
years ago and they fixed it by
enabling EPA on LDAPS sessions.

00:09:39.546,00:09:45.084
It is important to note that
LDAP is still vulnerable by
default since the GPO is not

00:09:45.084,00:09:50.089
enabled by default and EPA is
not enabled by default on LDAP S
sessions. The next vulnerability

00:09:52.826,00:09:59.666
I want to discuss was disclosed
in 2017 by Core Security by
Alberto Solino. This is a um

00:09:59.666,00:10:04.671
generic virus of NTLM server
signing. So the attack begins
like a normal NTLM relay attack,

00:10:08.374,00:10:14.614
the attack target generates an
NETLOGON message and receives a
session key in the response

00:10:14.614,00:10:21.087
censored censored eh and forces
SNB signing we cannot eh launch
an attack without having the

00:10:21.087,00:10:26.359
session key but as it turned out
any machine in the network that
knew the challenge and the

00:10:26.359,00:10:33.166
challenge response could spi
simply spoof a NETLOGON message
and receive the same session key

00:10:33.166,00:10:39.539
once that attacker has a session
key can simply send any SNB
packet that he’d like. So

00:10:39.539,00:10:44.477
Microsoft fixed that
vulnerability and the fix is a
bit more complex so I’m going to

00:10:44.477,00:10:50.850
dive deep into NTLM to explain
all the details. The first part
I want to explain is the NTLM

00:10:50.850,00:10:56.723
challenge message. In the NTLM
challenge message there is a
target in for field, this field

00:10:56.723,00:11:02.629
contains constructs named
av-pairs that identifies the
target. One of these fields is

00:11:02.629,00:11:08.501
the net bios computer name
identifying the net bios of the
target NTLM machine. In the

00:11:08.501,00:11:13.506
example you see you see the name
Test-01. When this message is
received by the NTLM client, the

00:11:16.709,00:11:22.315
NTLM client will echo all the
av-pair fields that it received
and you can see it echoed the

00:11:22.315,00:11:27.320
name Test-01 but the important
part is that when he signs the
message the empty spoof STR

00:11:29.789,00:11:36.229
signs all the av-pair this means
the attacker cannot modify or
tamper with any of the av-pairs

00:11:36.229,00:11:42.101
and needs to relay them
directly. So what was the fix
that Microsoft applied.

00:11:42.101,00:11:48.041
Microsoft simply microsoft
simply com compared the net bios
computer name to the NETLOGON

00:11:48.041,00:11:54.514
originator. Since it’s a bit
complex let’s give you flow. So
again we have a normal NTLM

00:11:54.514,00:11:59.986
relay attack, the attack target
which is the legitimate target
of the NTLM session sends a

00:11:59.986,00:12:05.558
NETLOGON message and receives a
session key, now the session
with also send a spoof NETLOGON

00:12:05.558,00:12:10.563
message the DC will compare the
NETLOGON originator which is
that the compromise server and

00:12:12.899,00:12:17.904
the av-pair th that identifies
the er attack target as the
original target see the

00:12:20.807,00:12:26.879
discrepancy and simply reject
the request. Since no session
key was er presented the

00:12:26.879,00:12:31.884
attacker cannot use the SNB
session that he just
established. OK that it for for

00:12:34.621,00:12:38.091
the old vulnerabilities now eh
let’s move onto the new
vulnerabilities we have

00:12:38.091,00:12:43.096
discovered. Over all I plan to
present we plan to present 3 new
vulnerabilities. The first, your

00:12:45.098,00:12:50.103
session key is my session key is
another generic bypass for SNB
and en all NTLM server signing

00:12:52.472,00:12:59.178
requirements. The second, drop
the MIC is another er is a
vulnerability bypassing another

00:12:59.178,00:13:05.218
NTLM mechanism the messaging
integrity code or MIC which we
will explain later and the third

00:13:05.218,00:13:10.223
bypassing EPA. That’s correct,
during our research we have
bypassed all NTLM mitigations.

00:13:13.693,00:13:20.366
Let’s deep dive into the first
vulnerability. So, if you recall
the fix I just explained for

00:13:20.366,00:13:25.371
2015 vulnerability was for the
DC to verify that the net bios
name oh in the NETLOGON message

00:13:29.175,00:13:34.313
is the same as the NETLOGON
originator. We have asked
ourselves what if we simply

00:13:34.313,00:13:39.318
remove the net bios name from
avpairs so in the NTLM challenge
message there was is an av-pair

00:13:41.387,00:13:46.926
for the net bios computer name
and with the relayer we have
full control over that packet so

00:13:46.926,00:13:53.066
we will simply remove that
field. OK what happens if we
remove this field, now there is

00:13:53.066,00:13:58.071
a series of surprising things,
first the NTLM client receives
the NTLM challenge message,

00:14:00.106,00:14:06.446
respects it, even though it’s
malformed and generates an NTLM
authenticate message. This NTLM

00:14:06.446,00:14:11.384
authenticate message would have
know that bios computer name
since we haven’t given no net

00:14:11.384,00:14:17.323
bios computer name. The second
surprising thing is that the
NTLM server would accept this

00:14:17.323,00:14:23.096
malformed eh n NTLM
authenticated message and would
generate a NETLOGON message and

00:14:23.096,00:14:28.501
now for the third surprising
thing. The DC would also respect
this rouge NETLOGON session and

00:14:28.501,00:14:33.473
would give a session key. Now
one once it it gives a session
key anyone can send this

00:14:33.473,00:14:38.478
NETLOGON message since it can’t
be authenticated what so ever.
So there is one less obstacle we

00:14:41.247,00:14:46.619
need to overcome and that’s the
MIC. The MIC is a message
integrity code that sign all

00:14:46.619,00:14:51.924
free NTLM messages, the
negotiate, challenge and the
authenticate. The MIC is there

00:14:51.924,00:14:58.464
to protect from any tampering
that is done to any of the NTLM
messages, but wait, we did

00:14:58.464,00:15:04.904
tamper with the NTLM messages
specifically with the eh NTLM
challenge but if you’ll see the

00:15:04.904,00:15:10.276
session key for the MIC is the
same session key for the SMB
signing. So what are we going to

00:15:10.276,00:15:16.749
do, we’ll simply going to
recalculate the MIC and send the
eh NTL the new NTLM authenticate

00:15:16.749,00:15:22.588
message to the server. Lets
review the flow, so once the
attacker receives an NTLM

00:15:22.588,00:15:28.828
challenge message it would
tamper with that this message
sending a new NTLM metha message

00:15:28.828,00:15:35.201
with no net bios computer name.
The client machine would respect
this message sending an NTLM

00:15:35.201,00:15:41.941
authenticate message also with
no net bios computer name. Now
will spoof a NETLOGON message

00:15:41.941,00:15:47.780
the DC cannot verify that this
is the correct origin and would
send back a session key. Now

00:15:47.780,00:15:54.253
that we have a session key we
can recalculate the MIC for the
new tampered NTLM authenticate

00:15:54.253,00:15:59.258
message. The attack target would
send a similar NETLOGON message
and would receive a session key,

00:16:02.261,00:16:07.767
now both sides have the same
session key and SMB session is
established and the attack can

00:16:07.767,00:16:14.407
walk. So I just want to
emphasize one last thing, SMB
signing is the only mitigation

00:16:14.407,00:16:16.409
for domain controllers. This
means if we are in possession of
a privileged account NTLM

00:16:16.409,00:16:18.411
session we can relay that
session to a domain controller
and establish SMB over RP

00:16:18.411,00:16:20.413
sessions this means we can dump
any credential in the domain or
execute code remotely on the DC,

00:16:20.413,00:16:25.418
this is a pretty serious attack.
Now let’s see them move the
attack. In the demo we have two

00:16:41.701,00:16:46.706
machines one of the machines is
a browser eh running a privilege
account session and the second

00:16:50.309,00:16:55.314
is the compromised server. Ok
that’s strange, let’ try, eh. OK
so first we, first we run the

00:17:10.096,00:17:15.101
attack ahh >>that’s why we made
the video >>yeah, yeah [audience
laughs] >>no one says that heck

00:17:28.814,00:17:33.819
hacking is easy. Okay >>make it
bigger [audience laughs] >>So
the first the first time we run

00:17:37.323,00:17:43.029
the attack without our exploit
and the attack fails. If we look
at the packet we see that the

00:17:43.029,00:17:48.734
NTLM authenticate message
contains a net bios computer
name so we can spoof the

00:17:48.734,00:17:54.574
NETLOGON message and the session
is not signed, you can see that
the signature field is zeroed

00:17:54.574,00:18:01.047
this is why the server rejected,
the main controller rejects our
SMB packets. Now let’s try

00:18:01.047,00:18:06.052
running the same attack with our
exploit. OK so you can see two
two new fields, one is the

00:18:14.026,00:18:19.532
computers account hash we need
this to spoof the NETLOGON
message and the second field is

00:18:19.532,00:18:26.505
the remove target removing the
net bios computer name from the
NTLM challenge message. So you

00:18:26.505,00:18:32.378
can see now that the attack
walked, we were able to retrieve
a session signing key and we

00:18:32.378,00:18:37.817
were able to dump hashes from
the remote machine. Let’s look
at the network traffic to see

00:18:37.817,00:18:42.822
what just happened. So OK the
first NTLM challenge message as
a net bios computer name when we

00:18:49.328,00:18:56.068
relayed it to HTTP session there
was no eh net bios computer
name. The NTLM al also doesn’t

00:18:56.068,00:19:01.907
have a net bios computer name,
the NETLOGON message is not
present because it’s encrypted

00:19:01.907,00:19:06.912
but you can see we’ve retrieve
the session signing key and that
the session is signed. OK now I

00:19:10.349,00:19:15.354
need to ah open the slide deck
again. >>audience clapping at
picture of Oprah Winfrey >> Yeh

00:19:22.495,00:19:27.500
OK so just to summarize with our
exploit any machine in the
network can get an NTLM session

00:19:33.039,00:19:38.044
key and sign SMB sessions to
remote machine. OK we have
disclosed this issue to

00:19:40.079,00:19:46.485
Microsoft and they’ve issued a
patch back in June the patch
works by giving NTLM servers the

00:19:46.485,00:19:52.458
option to validate if the eh the
net the NTLM authenticate
message. If the NTLM

00:19:52.458,00:19:58.664
authenticate message contains no
netbios computer name the server
would simply reject the NTLM

00:19:58.664,00:20:03.669
authenticate message. This works
in general but there are some
few caveats we want to mention.

00:20:05.671,00:20:12.178
The first is that NTLM V1 does
not have av-pairs this means
that the attack we’ve just

00:20:12.178,00:20:17.183
presented will always walk in
NTLM V1 and it is unmitigated.
The second is that since patch

00:20:19.518,00:20:26.358
is not applied directly on the
domain controllers but on target
servers all the Windows versions

00:20:26.358,00:20:31.363
and non Windows OS are still
vulnerable and the third maybe a
little tidbit is that since

00:20:33.999,00:20:40.339
again it’s not applied directly
on the DC any machine that even
if it’s patch was not restarted

00:20:40.339,00:20:45.010
is still vulnerable and in a
domain with thousands of
computers surely some are not

00:20:45.010,00:20:51.383
restarted and are still
vulnerable. With that I’m going
to pass the stage back to Marina

00:20:51.383,00:20:57.022
to present the two additional
vulnerabilities. >>Yeh it’s
actually we will be presenting

00:20:57.022,00:21:03.863
three more so bear with us. The
second one is drop the MIC the
message integrity code so as

00:21:03.863,00:21:10.102
Yaron mentioned the message
integrity code is calculated by
applying an H mark MD 5 using

00:21:10.102,00:21:15.975
the session signing key on the
three NTLM messages and the goal
is to make sure that attackers

00:21:15.975,00:21:21.447
didn’t tamper with any of the
NTLM messages. Now let’s see an
example of why we might need

00:21:21.447,00:21:26.752
this MIC field in the message.
Let’s say we have a client
sending an NTLM negotiate

00:21:26.752,00:21:32.091
message to the compromise to
some compromised server ending
in violent. And let’s assume

00:21:32.091,00:21:37.396
that this client supports
signing and it’s it sets the
negotiate sign flag in the last

00:21:37.396,00:21:43.335
NTLM neg in the first sorry NTLM
negotiate message as you can see
in in this packet. Now if

00:21:43.335,00:21:48.941
attackers try to relay this
message to a target server that
supports signing all they will

00:21:48.941,00:21:55.214
get is ahh a signed session with
no way to retrieve the session
key, let’s assume that all the

00:21:55.214,00:22:00.052
servers are patched and
attackers cannot retrieve the
session key. So it’s not

00:22:00.052,00:22:05.658
possible, well attackers however
might try to do is simply to
remove the signing flag from the

00:22:05.658,00:22:11.363
message. In order to establish
an unsigned session against
their target. However, this

00:22:11.363,00:22:17.236
would not be possible because if
attackers remove even a single
bit from one of the three NTLM

00:22:17.236,00:22:22.241
messages the MIC would nn be no
longer be valid and the attack
would fail. We have SNB clients

00:22:24.476,00:22:30.883
that turn on this negotiate flag
this negotiate signing flag by
default and also use the MIC and

00:22:30.883,00:22:37.723
this is why it was considered
very hard or even impossible to
perform NTLM relay from SNB or

00:22:37.723,00:22:43.395
other protocol’s simply because
the session would need to be
signed. However other protocol’s

00:22:43.395,00:22:50.102
don’t save the signing flag such
as http so smuch much easier to
relay NTLM from http to another

00:22:50.102,00:22:55.107
protocol. Let’s say we're
persistent and we want to remove
this signing negotiation flag

00:22:58.010,00:23:03.883
from an SNB authentication. How
can we do this? We’ve seen a way
that we can modify the message

00:23:03.883,00:23:07.953
integrity code but in order to
modify it we need to have
possession of the session

00:23:07.953,00:23:14.493
signing key. Let’s assume we
don’t have a way to do this.
Well turns out we can simply

00:23:14.493,00:23:20.332
remove the MIC from the message.
We’ve actually talked to the few
people yesterday that tried doi

00:23:20.332,00:23:24.970
tried doing that but it’s not
enough to just remove the MIC
from the message we also needed

00:23:24.970,00:23:31.176
to remove the version field and
change some of the negotiation
fields. But at the end it was as

00:23:31.176,00:23:36.715
easy as removing the MIC
entirely in order to bypass it’s
protection and the way we

00:23:36.715,00:23:40.853
discovered it was quite funny
because we were working on a
completely unrelated

00:23:40.853,00:23:46.725
vulnerability and the MIC was
interfering from uh from what we
were trying to achieve, so then

00:23:46.725,00:23:52.064
we removed the MIC from the
message and continued to working
on that other vulnerability, and

00:23:52.064,00:23:57.503
then at the end we had look back
and to think wait do we need to
disclose this one as well did we

00:23:57.503,00:24:03.208
just find another problem and
turn out that we have. So by
removing the MIC attackers can

00:24:03.208,00:24:08.213
tamper with any of the NTLM
messages. Here you can see an
example we have an original NTLM

00:24:10.582,00:24:16.255
authenticate message which has
the MIC field and version and
our tampered eh authenticate

00:24:16.255,00:24:21.260
message without those fields. OK
so let’s see the flow of this
attack. We have a client sending

00:24:23.762,00:24:29.868
a NTLM negotiate packet to a
compromised server stating that
it supports signing. Now

00:24:29.868,00:24:34.506
relayers cannot relay this
message as is to an attack
target because they would not

00:24:34.506,00:24:39.478
have a way to retrieve the
signing key, so what they can do
is simply remove the signing

00:24:39.478,00:24:44.950
flag from the message and relay
it back to the attack target.
They would then receive a

00:24:44.950,00:24:50.289
challenge and if the attack
target does not enforce signing
it would return a challenge and

00:24:50.289,00:24:56.695
state that no signing was
negotiated for the session. Now
attackers can relay this back to

00:24:56.695,00:25:02.801
the client and usually clients
don’t enforce session signing so
they would accept it and send an

00:25:02.801,00:25:08.273
NTLM authenticate message
signing the required challenge
and also adding a message

00:25:08.273,00:25:14.079
integrity code to the message.
However, the message integrity
code signs the messages between

00:25:14.079,00:25:19.618
the client and the server and
the NTLM negotiate message that
was signed was the one that

00:25:19.618,00:25:25.157
states that it supports signing
but attackers tampered with this
message so they cannot relay

00:25:25.157,00:25:31.163
this MIC to the attack target.
So they simply remove it in
order to bypass it’s protection.

00:25:31.163,00:25:36.301
Now the domain controller
verifies the credentials sends
eh an approved response and the

00:25:36.301,00:25:41.306
attackers have eh established an
unsigned session against the
attack target. Let’s see why

00:25:44.343,00:25:51.216
this is even possible. Turns out
there this is an AV-pair called
flags inside the last NTLM

00:25:51.216,00:25:57.689
authenticate message and if the
second beat of this attribute
this flags attribute is set it

00:25:57.689,00:26:03.228
means that the client is
providing a MIC in the
authenticate message. However it

00:26:03.228,00:26:08.434
doesn’t matter what this flag
states because th the attack
target upon receiving such a

00:26:08.434,00:26:14.907
message doesn’t validate that a
MIC is present even if this flag
is set and this is exactly what

00:26:14.907,00:26:20.212
allowed us to bypass this
mitigations. So no one actually
does the verification that if a

00:26:20.212,00:26:26.819
client states that it provides a
MIC that it indeed provided a
MIC. So we just dropped it from

00:26:26.819,00:26:31.824
the message. [laughter] >>OK
let’s discuss the fix. Now that
we know what the flags attribute

00:26:34.526,00:26:40.766
does we know how to easily fix
the issue all Microsoft needed
to do is for servers to verify

00:26:40.766,00:26:47.372
that if they receive a flags
value which indicates that a MIC
is present, just verify that a

00:26:47.372,00:26:52.377
MIC is present. Some issues with
this because some clients don’t
add a MIC by default and also ah

00:26:54.480,00:27:00.519
sorry don’t add a MIC such as
Firefox on Linux machine or
MacOS machines so those clients

00:27:00.519,00:27:06.358
would still be vulnerable to
NTLM tampering. So attackers can
still remove the negotia signing

00:27:06.358,00:27:12.865
negotiation for such a client.
But the more serious issue is
they were able to bypass this um

00:27:12.865,00:27:19.171
mitigation and we have ah
vulnerability that we like to
call drop the MIC to, however

00:27:19.171,00:27:24.676
Microsoft hasn’t patched this
this issue yet so we’ll have a
blog coming about this in a

00:27:24.676,00:27:29.681
couple of days. Alright the next
bypass that we want to talk to
you about is the EPA bypass. For

00:27:34.419,00:27:39.825
the goal of the EPA is to bind
the authentication the NTLM
authentication to the TLS

00:27:39.825,00:27:44.463
session over which it is
established and some of the
serves that can be protected by

00:27:44.463,00:27:49.468
EPA include AD-FS servers, OWA
servers LDAPS on domain
controllers or other HTTP

00:27:51.503,00:27:58.043
servers which support Windows
integrator authentication.
Unfortunately by default none of

00:27:58.043,00:28:04.116
those servers enforce EPA so all
of those would be vulnerable to
the simplest NTLM relay attack,

00:28:04.116,00:28:10.188
so attackers wouldn't even need
to bypass the protection of the
EPA. However let’s assume we

00:28:10.188,00:28:15.994
have a very safe environment and
EPA was enforced on all those
servers. How can we bypass this

00:28:15.994,00:28:22.301
feature as well? For the
implementation of EPA is by
adding an additional field to

00:28:22.301,00:28:28.240
the last NTLM authenticate
message which is called Channel
Bindings and this field as I’ve

00:28:28.240,00:28:34.079
mentioned is based on the target
servers certificate and since
the attackers would be using a

00:28:34.079,00:28:38.650
different certificate they would
not be able to relay this
message to another target which

00:28:38.650,00:28:44.957
enforces EPA. What they might
try to do is may be modify this
field, however that would not be

00:28:44.957,00:28:50.495
possible because this field is
also signed using the users pass
password hash so attackers have

00:28:50.495,00:28:56.101
no no knowledge of that hash and
they would not be able to modify
this field so we cannot tamper

00:28:56.101,00:29:02.207
with the NTLM authenticate
message. Let’s see what we can
do. Let’s look at the NTLM

00:29:02.207,00:29:07.512
challenge message. We know that
when a client receives an NTLM
challenge it echo’s the fields

00:29:07.512,00:29:12.517
in that message and puts them
inside the NTLM authenticate. So
what happens if we compute the

00:29:14.786,00:29:20.292
Channel Binding required in
order to bypass EPA in advance,
it is just based on public

00:29:20.292,00:29:25.797
values of the certificate and
inject it into the NTLM
challenge. What would the client

00:29:25.797,00:29:30.802
do? OK so what the client would
do is inj is put our rogue
Channel Binging field into the

00:29:40.646,00:29:47.586
NTLM authenticate message. So we
have a rogue Channel Binding
inside the message signed using

00:29:47.586,00:29:52.691
the user’s password hash. In
addition the client would add an
additional Channel Binding which

00:29:52.691,00:29:59.598
would be set to all zeros. The
only question left is what will
the server do when receiving a

00:29:59.598,00:30:05.771
message that has two different
Channel Binding fields? Well it
turns out it will only take the

00:30:05.771,00:30:11.610
first one and the first one is
the one that we calculated in
advance in order to fit what the

00:30:11.610,00:30:18.283
server expects. So we are able
to bypass EPA because the server
simply takes the value that we

00:30:18.283,00:30:24.656
computed in advance. So the last
obstacle that we might have here
is the messaging integrity code.

00:30:24.656,00:30:29.961
So what happens is that we just
modify the channel message and
the message integrity code is no

00:30:29.961,00:30:35.067
longer valid. However, we
already know what to do with the
MIC we simply remove it from the

00:30:35.067,00:30:40.072
message. Let’s see the entire
attack though as it was quite
complicated. So we have a client

00:30:42.441,00:30:48.714
sending an NTLM negotiate
message to a compromised server
and attackers now eh establish

00:30:48.714,00:30:54.753
TLS session against an attack
target which enforces EPA and
relay that NTLM negotiate

00:30:54.753,00:31:01.460
message to the attack target.
‘The target would send us an
NTLM challenge message, we’ll

00:31:01.460,00:31:07.399
compute the required Channel
Binding field that is needed in
order to bypass EPA on that on

00:31:07.399,00:31:12.404
that err server and inject it
inside the NTLM challenge
message. The client would

00:31:14.473,00:31:19.244
respond with an NTLM
authenticate message with the
injected Channel Binding and an

00:31:19.244,00:31:25.684
additional one which the server
would ignore and also add a MIC.
We cannot relay this MIC as we

00:31:25.684,00:31:31.323
modified the challenge so we
just remove it from the message
and we have our injected channel

00:31:31.323,00:31:36.995
binding, the attack target
checks the field, sees that it
is eh compatible what it is

00:31:36.995,00:31:43.335
expecting and we are able to
bypass the EPA feature. OK so
now attackers can compromise

00:31:43.335,00:31:48.340
that server which can be an
AD-FS OWA or even a domain
controller using LDAPS. OK so

00:31:52.444,00:31:57.449
let’s see a demo of this attack.
Where is it? >>[inaudible off
mic whisper] >> Sorry guys for

00:32:23.241,00:32:28.246
some reason the video is not
working from inside the eh
presentation. Here it is here it

00:32:36.321,00:32:41.326
is here OK OK so what we’ll show
now is that we’ll have our HTTP
relay server and when a client

00:32:45.530,00:32:49.367
would connect to this relay
server we would relay the
authentication to a domain

00:32:49.367,00:32:54.639
controller which enforces LDAPS
channel binding we’ll show you
the first attack which would

00:32:54.639,00:33:00.378
fail without our vulnerability
and in the second one we’lll be
adding our rogue channel binding

00:33:00.378,00:33:05.817
and removing the MIC and we’ll
show you how we are able the
escalate the privileges of user

00:33:05.817,00:33:11.790
to an enterprise admin by
relaying the credentials of
privileged account. OK so first

00:33:11.790,00:33:16.795
of all we run the eh HTTP server
without our vulnerability and
the let let’s connect to our

00:33:19.164,00:33:25.203
rogue HTTP server and we can see
in the console that the attack
failed. We are trying to

00:33:25.203,00:33:30.675
reconnect back to the eh to the
target all the time and we fail.
You can see that in the

00:33:30.675,00:33:36.481
challenge we don’t have any
channel binding field. However
in the authentication the client

00:33:36.481,00:33:41.486
sets this field to zeros and
this is the one that relay back
to the domain controller. So we

00:33:43.555,00:33:49.527
can see the channel binding is
set to zero and this is now the
domain controller is expecting

00:33:49.527,00:33:56.134
for the LDAPS channel binding so
the attack simply fails. Right
so we’ll try it try it again

00:33:56.134,00:34:02.040
with two additional fields.
First we will be removing the
message integrity code and

00:34:02.040,00:34:07.545
second is we’ll be adding a
rogue channel binding to the
message. Let’s see what happens

00:34:07.545,00:34:12.550
when we run our vulnerability
now. OK so we’re connecting
using our HTTP client to our

00:34:15.754,00:34:21.226
rogue server and you can see in
the console that first of all
the authentication was

00:34:21.226,00:34:27.999
successful, and then that we are
also able to escalate the
privileges of test user to an

00:34:27.999,00:34:33.538
enterprise admins group. Let’s
see what’s happened in the
network traffic. We can see that

00:34:33.538,00:34:39.344
the original challenge didn’t
have any channel binding field
inside, but the one that we sent

00:34:39.344,00:34:45.650
to the HTTP client does have one
and it’s the one we calculated
in advance. Now when the client

00:34:45.650,00:34:50.655
responds to our message we see
our rogue channel binding and an
additional one set to all zeros.

00:34:53.591,00:34:57.262
So right now we need to relay
this back to the domain
controller you can see this is

00:34:57.262,00:35:02.667
the one we injected and this is
the all zeros one and also there
is no MIC in the message,

00:35:02.667,00:35:09.007
however the original message did
contain a MIC. And now the
domain controller simply accepts

00:35:09.007,00:35:15.480
our authentication we are able
to escalate the privileges of
that test user to an enterprise

00:35:15.480,00:35:21.886
admins simply by relaying the
credentials and bypassing EPA by
injecting our rogue channel

00:35:21.886,00:35:26.891
binding and then removing the
message integrity code.
[audience applause] >>Thank you

00:35:43.875,00:35:48.880
[off mic] >>Oh now it’s working
[audience laughs] >>great OK so
that was the channel binding eh

00:35:50.915,00:35:55.920
bypass. Let’s discuss the fix.
So the fix is pretty simply and
it is based on ah it’s based on

00:36:00.191,00:36:05.597
detecting a signature of this
attack. So if a server receives
an NTLM authenticate message

00:36:05.597,00:36:11.669
with two channel binding fields
it would simply deny the
request. Still have some issues

00:36:11.669,00:36:17.242
with this as well because some
clients don’t support EPA and
also don’t add a MIC. So those

00:36:17.242,00:36:21.279
are the same ones that I have
discussed in the previous
vulnerability, those would still

00:36:21.279,00:36:27.018
beab would still be vulnerable
to the EPA bypass. So attackers
would still be able to inject a

00:36:27.018,00:36:32.190
malicious channel binding, the
client doesn’t support EPA so it
would not add an additional

00:36:32.190,00:36:37.195
field and attackers can relay
that to any target which
enforces EPA. OK so our last

00:36:39.898,00:36:44.903
vulnerability for today would be
how we can use NTLM in order to
attack AD-FS servers as well.

00:36:48.273,00:36:54.512
>>Thanks Marina [clears throat]
so we have discussed a couple of
NTLM relay eh vulnerabilities

00:36:54.512,00:36:59.517
but NTLM has other issues except
NTLM. First, if an attacker has
possession of an NTLM session it

00:37:02.921,00:37:07.926
can use that session to do
offline cracking of the users
password. Apart from that using

00:37:10.028,00:37:16.234
NTLM attackers can brute force
eh or do per perform credentials
spraying and using brute force

00:37:16.234,00:37:23.108
attacks. We will now discuss how
we can leverage the this ehhh
features to attack the ADFS

00:37:23.108,00:37:29.748
server. First let’s understand
what the ADFS server is. ADFS is
a server that allows users to

00:37:29.748,00:37:36.087
perform claim based web web
authentication using the domain
credentials. The server allows

00:37:36.087,00:37:42.393
users to use Windows integrated
authentication as well as simple
eh form based authentication.

00:37:42.393,00:37:47.398
ADFS supports both semen and WFS
federation protocol. So in many
cases you want to to allow users

00:37:51.202,00:37:57.609
to authenticate from external
networks like the internet. Two
common examples are OWA which is

00:37:57.609,00:38:04.115
a popular Microsoft mail server
and Office 365. A lot of
networks don’t want to sink

00:38:04.115,00:38:09.120
their passwords to the to the
cloud so they are using ADFS to
authenticate Office 365. It so

00:38:12.957,00:38:19.397
since ADFS is a very critical
server usually it is not open to
external networks an ehr

00:38:19.397,00:38:25.737
typically you deploy an ADFS
proxy that ADFS proxy receives
the authentication requests and

00:38:25.737,00:38:30.742
forwards them to the ADFS. Now I
want to talk about our NTLM
password er brute force walk and

00:38:33.144,00:38:38.149
then we will return to ADSF. So
this time the rogue machine is
the client machine, and not the

00:38:40.919,00:38:45.924
server machine, and if we want
to brute force eh some eh user
account we’ll generate an NTLM

00:38:48.459,00:38:54.532
authenticate message, this
message could be over any
protocol that supports NTLM. If

00:38:54.532,00:39:00.138
we are dealing with insider
threats this would probably be
SNB since SNB is open on all

00:39:00.138,00:39:04.542
machines in the network, but if
it’s an external attacker
walking from the internet for

00:39:04.542,00:39:10.815
example, SNB usually doesn’t
pass the firewall so it would be
another protocol, for ADFS it

00:39:10.815,00:39:17.288
would be HTTP. So if the packet
is received by the server, it
would send an NTLM challenge

00:39:17.288,00:39:23.761
message. This message will use
our guest eh password and
encrypt an NTLM authenticate

00:39:23.761,00:39:30.568
message the server would send an
a NETLOGON to the DC and if the
password is rejected we know it

00:39:30.568,00:39:35.440
was it’s the wrong password and
if it’s accepted we’ve eh lucked
out and we’ve been able to crack

00:39:35.440,00:39:41.679
an account. The really cool
thing is that in NTLM you can
spoof the origin name, so if we

00:39:41.679,00:39:47.952
look at if from the DC
perspective thh the DC logs
don’t contain any IP of the

00:39:47.952,00:39:53.691
attacker or the correct machine
name. So if we analyse this log
we’ll we’ll logs we’ll have a

00:39:53.691,00:39:58.696
hard time figuring out the
attack origin. If we go back to
ADFS and we’ve and we’ve said

00:40:01.266,00:40:07.138
ADFS is open to the internet an
attacker that has no physical
access to our network can

00:40:07.138,00:40:13.911
connect to ADFS and perform
brute force attempts either with
NTLM or with eh form base

00:40:13.911,00:40:20.251
authentication. So this is a
pretty serious attacks attack
and it can have two

00:40:20.251,00:40:25.356
consequences. If our network has
eh account lockout policy eh if
our attacker- network doesn’t

00:40:25.356,00:40:27.358
have lockout policy at some
point the attack would succeed
some password would be guest

00:40:27.358,00:40:29.360
accounts would be compromised
and eventually data would be
leaked. If our network does have

00:40:29.360,00:40:34.365
account lockout policy it
doesn’t get that much better
since now the attacker can D-Dos

00:40:45.376,00:40:50.381
with no physical access and lock
all the user accounts. Microsoft
is aware of this issue and they

00:40:53.217,00:40:59.657
have an extra net lockout
policy. When the extra net
lockout policy is enabled the

00:40:59.657,00:41:05.396
ADFS eh after a few
authentication failures stop
respecting authentication

00:41:05.396,00:41:12.103
attempts that originated from
external networks. So now let’s
move on to the vulnerabilities

00:41:12.103,00:41:18.509
we have discovered. So as it
turned out you could do windows
integrated authentication from

00:41:18.509,00:41:23.514
external networks to ADFS. This
is a bit surprising but that’s
not it. We’ve found that if you

00:41:25.917,00:41:32.090
use eh Windows integrated
authentication and specifically
NTLM the extra net lockout

00:41:32.090,00:41:37.995
policy is simply ignored. This
means that we were eh able to
bypass the extra net policy

00:41:37.995,00:41:43.000
entirely. We have disclosed this
issue to Microsoft and they’ve
issued a fix back eh in eh July.

00:41:45.670,00:41:51.476
Now I want to eh before I’ll
explain the fix I’ll I want to
add one last note, and this is

00:41:51.476,00:41:58.249
about Kerberos. Sorry not all
the live talk is about NTLM. So
with S the reason that the

00:41:58.249,00:42:04.489
vulnerability walked is because
the ADFS accepts Windows
integrated authentication from

00:42:04.489,00:42:10.561
external networks and we’ve
asked ourself can we also
exploit this issue with Kerberos

00:42:10.561,00:42:16.300
and the answer was yes. So since
our time is short I will be
brief and I mentioned that with

00:42:16.300,00:42:21.973
Kerberso we can brute force only
the ADFS service account. This
is done by forging service

00:42:21.973,00:42:26.978
tickets using guest password
hashes, we call this technique
reverse Kerberoasting. This is

00:42:29.414,00:42:36.154
ah small attack surface, but it
has a huge impact, if we will be
able to crack the ADFS service

00:42:36.154,00:42:41.692
account we can perform we can eh
create any silver ticket and
authenticate this any user to

00:42:41.692,00:42:48.199
the ADFS completely compromising
the ADFS infrastructure. Eh it
took us a while, but we’ve

00:42:48.199,00:42:52.837
convinced Microsoft that the
correct fix was to simply block
Windows integrated

00:42:52.837,00:42:57.842
authentication from external
networks and that’s what they
did. So what are the take ways

00:43:00.011,00:43:05.850
we think you should take from
this ehh lecture. First,
obviously patch all your

00:43:05.850,00:43:10.855
machines. Second, we recommend
that you do not use NTLM at all
since it’s very risky, but if

00:43:12.957,00:43:17.962
you use NTLM make sure all your
servers are en are enforcing
silver signing and EPA. Third,

00:43:20.098,00:43:25.102
if you are using NTLM V1, please
stop. It was already published
[laughing] It was already

00:43:27.405,00:43:33.511
published that any NTLM V1
session can be correct since
it’s using weak des encryption.

00:43:33.511,00:43:39.584
We have now shown that any NTLM
V1 session on fully patched
machines can be relayed.

00:43:39.584,00:43:44.589
Seriously just stop using NTLM
V1. Some credits are in due are
due. Eyal Karni and Sagi

00:43:46.924,00:43:52.763
Sheinfeld have also contributed
to this research, and Alberto
Solino help us integrate our

00:43:52.763,00:43:57.768
code into IM packet. IM packet
is an awesome tool that we use
all the time and all the demo’s

00:43:59.971,00:44:04.909
eh you’ve seen today were using
IM packet. OK so we recommend
you stop using NTLM but it you

00:44:08.980,00:44:13.985
do use it, you can’t resist, we
hope after this talk you won’t
get relayed . Thanks [applause]

