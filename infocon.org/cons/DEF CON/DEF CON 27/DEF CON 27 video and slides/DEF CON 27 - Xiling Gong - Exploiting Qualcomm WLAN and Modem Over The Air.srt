00:00:00.167,00:00:05.172
>>Thanks, thanks for attending
our talk uh today we’re share
about how we exploit Qualcomm

00:00:07.574,00:00:12.579
WLAN and the modem o the over
the air, and finally compromise
the linux kernel. Uh about us uh

00:00:14.848,00:00:19.853
we are the security researchers
from Tencent Blade Team. Uh,
Tencent Blade Team uh is founded

00:00:22.422,00:00:27.427
by Tencent Security Platform
department in 2017. Uh, we focus
on uh security research in the

00:00:29.897,00:00:34.902
areas of AIoT, mobile devices,
cloud visualization, Blockchain
and uh etc. [clears throat] uh,

00:00:37.804,00:00:42.809
this is the Agenda. Uh, firstly
we are introduce some uh related
works, uh we know that WLAN

00:00:45.579,00:00:50.584
security is a hot topic uh
recently to norm exploit uh
Broadcom wifi chip is uh 2017

00:00:53.687,00:00:59.760
and uh this year on malware.
Today our talk is about
Qualcomm. How do we know? Uh

00:00:59.760,00:01:04.665
there is no public exploit on
Qualcomm wifi chip so how secure
are the qualco- uh Qualcomm

00:01:06.934,00:01:12.606
wifi? There’s a simple uh
illustration about uh
architecture of qualco- Qualcomm

00:01:12.606,00:01:17.611
wifi. There are two important
things, the first one uh is such
uh start from Snapdragon 835 the

00:01:21.348,00:01:27.187
double line for more is
integrated into the base ban the
substation. So, the double line

00:01:27.187,00:01:33.760
and the modem are wrong in the
same processor now. The second
thing that you’re going to see

00:01:33.760,00:01:39.232
uh in Qualcomm’s uh
implementation most of the
function there is implemented in

00:01:39.232,00:01:44.237
the linux kernel driver named uh
QCACLD uh there are plenty of
vulnerabilities uh in this

00:01:47.274,00:01:52.279
driver. That is well known WLAN
host vulnerabilities. Our talk
is not about the WLAN host

00:01:55.716,00:02:02.389
issues it is about the WLAN
firmware itself. Uh, we know
that, uh there is no public talk

00:02:02.389,00:02:08.595
on the Qualcomm WLAN firmware
previously so, how about the
security status? Uh, we will

00:02:08.595,00:02:13.600
answer this question. Before we
go into the details of WLAN fir-
and modem firmware we need to

00:02:16.636,00:02:23.477
reduce the debugger we use it to
debug the firmware, this is a
key step for us to analyze the

00:02:23.477,00:02:28.482
modem and the WLAN. Uh then, uh
modem boot authenticator and the
modem images infrasystem you can

00:02:33.620,00:02:38.625
see mba dot mbn is the mba
image, modem dot mdt and the
modem dot bxx um modem images

00:02:44.765,00:02:49.770
this images have a specific
format according to Qualcomm’s
official documents. Like uh

00:02:51.938,00:02:56.943
application process, modem
process also has a secure boot
flow. The flow is like this. Uh

00:02:59.579,00:03:04.518
firstly, linux kernel we load
MBA and um modem images from to
physical memory. The second, uh

00:03:08.522,00:03:14.928
linux kernel we are sent the
start physical address of MBA
and uh reset the modem

00:03:14.928,00:03:19.933
processor. Modem PBL in ROM
where it verifies the MBA image,
if success, it will jump to the

00:03:24.204,00:03:29.209
MBA code. Finally, MBA will read
and verify modem images if-if
success it will jump to the

00:03:32.512,00:03:37.517
modem main code. Uh the pil_bot
function, in linux kernel
describes the boot flow of

00:03:40.120,00:03:45.125
modem. Uh you know we load uh m-
MBA and the modem images to
physical memory and then check

00:03:47.894,00:03:54.434
MBA and the modem images to be
verified and security with the
modem processor. Linux kernel

00:03:54.434,00:04:00.540
can restart the modem processor
at anytime and it will hit
pil_bot function anytime you

00:04:00.540,00:04:05.545
want to restart. Um, so
vulnerability we use to bypass
uh the modem secure boot use

00:04:08.682,00:04:13.687
time of check, time of use path.
When MBA verifying modem images
it doesn’t lock the physical

00:04:16.089,00:04:21.094
mem-memory reaching means that
linux kernels there can modify
the modem images. So, after MBA

00:04:25.165,00:04:31.838
verify the one image, linux
kernel can still modify which
means that we have bypassed the

00:04:31.838,00:04:36.843
secure boot check. Uh, the POC
for the vulnerability is quite
simple. There is the uh dif- dif

00:04:40.580,00:04:45.585
file of pil_bot function. We
just, let a pure recram mem
function after we modified modem

00:04:48.121,00:04:53.126
images. Uh, after we have
ability to modify the modem im-
images so we can inject debug

00:04:56.630,00:05:01.568
server to modem side uh we
injected demon thread to read 4
commands from linux side the

00:05:03.737,00:05:10.477
commands and the re- results we
are being uh extrangulated using
shared physical memory uh we now

00:05:10.477,00:05:15.482
can issue debug command to debug
WLAN in the modem firmware. Uh,
now we have the uh uh debugger,

00:05:19.953,00:05:26.359
we can analyze the modem and
WLAN firmware matter either and
uh Xiling will introduce the

00:05:26.359,00:05:31.364
following details. >>oh, okay,
I’m going to introduce the
reverse engineering and the

00:05:37.204,00:05:43.510
vulnerability and the
exploitation of WLAN and then
finally we’re going into the

00:05:43.510,00:05:48.515
linux kernel. Ok, let’s reverse
the architecture of Qualcomm
WLAN. Uh, the WLAN is not the

00:05:51.451,00:05:57.857
baseband subsystem and the
hexagon architecture and not
other architecture hexagon

00:05:57.857,00:06:02.796
architecture, so, you can
analyze firmware and if we
controlled the WLAN, you have

00:06:05.165,00:06:10.170
actually controlled the baseband
sub- sub system. Okay, oh here
your simple figure for the WLAN

00:06:13.640,00:06:18.645
architecture. From the fig you
can see that a Qualcomm WLAN
you’re not a full MAC layer

00:06:20.880,00:06:27.787
firmware. Most of the function
of W-WLAN uh implemented in the
next to driver you can see here

00:06:27.787,00:06:32.792
in the QCAC driver okay. Now see
into our smaller attack surface
than the other windows, the work

00:06:38.598,00:06:44.638
to be done here you know the
firmware you’ll call the
offloader that you see the

00:06:44.638,00:06:49.643
offload MAC layer. The middle
attack surface here you know
offload handler. The offload

00:06:52.145,00:06:58.118
handler is actually uh a table,
a functioning table. And there
are user vectors out here

00:06:58.118,00:07:00.587
packager and if we are
interested in we are parser
[inaudible]. So, the attack hook

00:07:00.587,00:07:05.592
for the handle here, uh when the
offload handler handle the
packager. So, you can analyze

00:07:09.596,00:07:14.601
okay give an example for how the
WIFI consist point is played on
the WIFI list see, if you turn

00:07:24.844,00:07:29.849
on the WIFI in the settings and
you open the WIFI you’ll see a
list of the WiF- accessible

00:07:32.352,00:07:38.625
internet okay? Actually, when
you turn turn on WIFI the
android firmware can issue

00:07:38.625,00:07:45.131
command to the driver and the
driver the command the firmware
to scan the nearby WIFI hotspot.

00:07:45.131,00:07:50.136
Finally, the firmware we are
move from the 200’s into the
handler table. When the other

00:07:52.906,00:07:57.911
hotspot or access point that’s
in the packet the CPU have a um
accessible to send out beacons,

00:08:00.246,00:08:02.248
and the other path user so our
handler received- recieved the
data and the path user. If uh

00:08:02.248,00:08:04.250
into the management of beacon,
we are transferring in to the
driver and finally, we will

00:08:04.250,00:08:09.255
notify the user space
application so that you can see
the SSID and the uh all the

00:08:20.033,00:08:25.038
informations okay. Okay, so now
we have some basic sense about
the Qualcomm WLAN uh lets start

00:08:33.046,00:08:38.051
at the reverse engineering. Uh,
this is the firmware loaded by
modem, uh this is a WLAN

00:08:40.186,00:08:45.191
firmware, it was loaded by modem
to this position and this is the
disassembler, and this is the

00:08:47.627,00:08:52.632
wonderful SDK provided by
Qualcomm, and instruction
reference for the hexagon

00:08:55.769,00:09:00.707
architecture. Okay, okay so the
WLAN firmware have more than 8
solid functions, it’s a

00:09:06.346,00:09:12.919
difficult task to reverse these
functions without any knowledge.
Uh, luckily qualcomm have go

00:09:12.919,00:09:18.558
from hint. You can see that most
of the users we’re seeing use
the string table uh we can find

00:09:18.558,00:09:25.365
a lot of function names. And uh
the other thing is the import
function because the WLAN from

00:09:25.365,00:09:31.171
where you load load the by the
modem at the shield library so
the WLAN u-use a lot of

00:09:31.171,00:09:35.975
functions from the modem and
leave the function names in the
important function table.

00:09:35.975,00:09:42.048
They’re quite useful, the string
table and the important
functions. Okay, the target e’re

00:09:42.048,00:09:48.888
going to reverse engineer in is
uh Offload handler. Uh, the
middle attack surfaces use the

00:09:48.888,00:09:54.727
offload handler, so, the
question is how to find the
handler table? The answer is

00:09:54.727,00:09:59.732
that you can first find the
string from the string table, uh
that is this string uh non data

00:10:02.802,00:10:09.576
offloader and then check the
reference of this string to find
the function name and uh find uh

00:10:09.576,00:10:15.748
the fu-function name the long
data handler uh you can see this
uh this is a big function,

00:10:15.748,00:10:22.322
actually it’s a-a big loop. And
the fix the accuracy in the
handler table, and uh then call

00:10:22.322,00:10:27.327
the functions to-to the job. Ok,
so this is uh material attack
surface you can find the table

00:10:31.431,00:10:37.837
here and the find the functions.
Uh, this is a sample function,
one of the functions looks like

00:10:37.837,00:10:44.511
this so mostly importance is to
find the data pointer. If you
send the data, uh if you want to

00:10:44.511,00:10:50.917
attack the WLAN you first send
the data, the hard to find the
data dat- data flow, this is the

00:10:50.917,00:10:55.922
entry the one of the handler,
you can see here this is the
data pointer uh ox 5B, 5A, 5 9,

00:11:01.394,00:11:06.633
5 8 this is the data pointer so
you find this function and find
the data pointer and analyze the

00:11:06.633,00:11:11.638
uh function and the process -ess
of the uh um data pointer then
you know how what is the

00:11:15.875,00:11:21.948
function doing and handler
vulnerabilities. Okay I think
this is uh mostly important set

00:11:21.948,00:11:28.888
in this talk uh you can find the
function and find the data on
the handle when vulnerability

00:11:28.888,00:11:33.893
you want. Okay, ready, so let’s
start with rotation. Uh, this is
a roadmap uh we are here, we can

00:11:39.098,00:11:44.103
send out a some signal using the
WIFI signal or something er else
we are here we can send out the

00:11:46.306,00:11:51.311
signals, WIFI signals and we are
going to combine with WLAN and
uh then we are discovery into

00:11:54.047,00:11:59.052
modem. Finally, we are into the
linux kernel. Okay to combine
with for the linux kernel. So,

00:12:04.824,00:12:09.829
before we go, let's check the uh
mitigation status of WLAN to
setup an exploitation strategy.

00:12:16.836,00:12:22.875
From the mitigation table, we
can see that there are lots of
mitigations uh for example the

00:12:22.875,00:12:29.449
heap, heap will have ASLR the
address of the heap is not a
fixed one. And the heap will

00:12:29.449,00:12:34.454
have protection heap cookie so
uh the overflow on the heap will
be difficult to exploit and also

00:12:38.091,00:12:43.096
there are dp uh you are unable
to uh, uh jump into the data
segment. Uh, also you are unable

00:12:47.500,00:12:52.505
to write to the code segment
directly if you want to do so,
how to change the memory

00:12:54.741,00:12:59.746
retribution uh k. Also, there
are frame limiter, frame limiter
to particular SP the frame key

00:13:03.282,00:13:08.287
to protect take the return
address uh so if you want to use
some technical like a ROP, ROP

00:13:14.694,00:13:19.699
is time to wake because the
protection here mhm but a we are
very lucky, the code ASLR is

00:13:23.069,00:13:28.074
letting enable this so the code
AGS is fixed and the CFI is not
enabled so, if we although we

00:13:33.713,00:13:38.718
can not use IOP we can use
something called the FOP
function oriented programming

00:13:41.354,00:13:46.359
that you uh in the calculator of
the IOP or the calculator uses
the function core, not a return

00:13:49.629,00:13:54.834
core uh return it’s a function
core, function oriented
programming okay? We also, we

00:13:54.834,00:13:59.839
are lucky the issue you find in
the global data area and uh here
there is also no ASLR. So, the

00:14:04.310,00:14:09.315
address of the data is also
fixed, okay we know the address
of the data the wat- around the

00:14:11.451,00:14:16.456
data address okay let’s see the
details of the vulnerability uh
CVE-2019-10540 ok this issue has

00:14:22.829,00:14:28.534
already been announced in the
android and the Qualcomm
security breaching and they have

00:14:28.534,00:14:33.339
been patched. So, if you are
interested about the detail
information for the

00:14:33.339,00:14:38.344
vulnerability for it’s here the
security beacon on the 29th,
this issue has been fixed

00:14:42.048,00:14:47.053
already. Uh, uh this issue even
more of the offloader handler,
uh y-y remember this table, the

00:14:51.290,00:14:56.362
offloader table there are lots
of functions uh called the
offloader handler, well the

00:14:56.362,00:15:03.169
handler have the problem and uh
it’s pre auths frame handler
[clears throat] uh handle the

00:15:03.169,00:15:09.041
OT, uh OTA pre auths uh pre
auths means you don’t have to
connect the too space finder

00:15:09.041,00:15:15.148
access pointer, you don’t have
to connect to connect to h-house
port. You just have to turn on

00:15:15.148,00:15:20.153
the WIFI then the uh formula 1
label okay. It’s pre auth
vulnerability. Okay, this is uh

00:15:23.790,00:15:28.795
vulnerability code, I will
transfer it, translate it into
the C code uh this is

00:15:31.464,00:15:36.469
[inaudible] you can see this
Global and uh this lump checker
very latent and we are coding

00:15:41.741,00:15:46.746
much of the data into the uh
destination uh a copy of so uh
and this is global if you have

00:15:50.283,00:15:55.288
enough data. This is the
vulnerability, ok hmm hmm okay
so, let’s check the data around

00:16:01.761,00:16:06.399
the overflow address. You can
see the overflow from here,
Global Buffer. In the, if you

00:16:06.399,00:16:10.303
want to do a copy, Ox44 data
into each item. From here, the
Global Buffer into here you can

00:16:10.303,00:16:15.308
see 44 bytes of data, 44, 44,
it’s like it’s a loop, okay. You
know, this is a Global Buffer,

00:16:19.612,00:16:24.617
in the Global static area, so,
the address we al-already know
because there is no SAR. The

00:16:38.264,00:16:43.269
mutation in the table you’ll
remember there’s no SR so, we
know the gist of the-the

00:16:47.673,00:16:52.678
overflow data. So, it’s very
convenient and fast to exploit.
Okay, we can analyze the data

00:16:57.049,00:17:01.988
around the overflow address we
can analyze the data here and
quickly you become find out uh

00:17:05.057,00:17:10.062
after set C is a very useful
data, it’s very useful func- uh
data point, pointer to uh

00:17:14.700,00:17:19.705
something we can uh mimic into
a-a useful job. We call it the
smart pointer, using the

00:17:22.942,00:17:28.381
vulnerability we can override
this smart pointer,
oride-override the content of

00:17:28.381,00:17:33.386
this pointer. Okay, see how we
use the smart pointer. We can
send out the packaging and uh

00:17:36.923,00:17:41.928
goes into this uh this uh code
flow to use the override on the
data. You can see, this is a

00:17:44.864,00:17:51.537
smart pointer, we override so we
can, we can change it to our
destination we are interested in

00:17:51.537,00:17:56.542
and uh before we call into this
code flow. Finally, we uh
override these 2 bytes, uh

00:18:01.948,00:18:06.953
actually sorry there’s 3 bytes,
C, D and 14, f- we override this
3 bytes okay. Let’s see the

00:18:12.625,00:18:15.861
detail, we override the smart
pointer using the vulnerability
and then we uh have two tests,

00:18:15.861,00:18:20.866
the first test you test the
destination equal to 1 and the
second test is to test the-the

00:18:29.275,00:18:35.881
smart pointer plus 6 equal to
the MacAddress of the sender,
and uh finally, if the two tests

00:18:35.881,00:18:40.886
pass we are right to the uh 3
bytes using the data from the
OTA packet uh this is the data

00:18:47.360,00:18:53.199
we controlled and uh send. And
the MacAddress is also we
controlling the sender. So, the

00:18:53.199,00:18:58.204
only constraint is that if we
pass, bypass this-this-this
check we can write a code to the

00:19:00.673,00:19:05.845
destination we are interested
in. So, we can overwrite
something like a function point,

00:19:05.845,00:19:12.018
data point or other things we
are interested in to do the job,
okay. So, we have a-a Global

00:19:12.018,00:19:17.023
write- write perimeter so we can
write it to anywhere we want if
we can bypass this check. Okay,

00:19:22.728,00:19:27.733
Just a quick example, uh we
override the smart pointer to
this address xxx and uh the know

00:19:30.202,00:19:35.207
the byte is 1, so we can bypass
the check here uh we can, we can
bypass the check here, okay?

00:19:40.846,00:19:45.851
Then we can write it to the
offset of C uh uh 56, 78 we can
see here, we can write the C and

00:19:49.288,00:19:54.293
the D and we use the 6 uh
5,6,7,8 we can write it to here,
we can use we call it the

00:19:58.297,00:20:03.302
perimeter Global Write with
Constraint okay. We can write it
to anywhere useful if you know

00:20:05.538,00:20:10.543
it’s the bit 1 stood up. So, a
meaningful address or data you
start with 4 bytes, so how to

00:20:15.514,00:20:22.188
write 4 bytes, the answer is
quite simple. We just, using the
right address, the first time on

00:20:22.188,00:20:27.193
the lower 2 bytes you know
there’s 5, 6, 7, 8 and uh the
second time we move the smart

00:20:30.463,00:20:35.468
pointer uh forward up by 2 and
uh this one, this byte use the 0
or 1 become the 1,2,3,4 then the

00:20:42.141,00:20:47.146
1,2,3,4,5,6,7,8 uh 8 [clears
throat] uh that takes the 4
bytes and that is still not a

00:20:49.682,00:20:54.687
problem you see, you want to
write to here mmm 5, 6 and uh
the problem is this bit is not

00:20:58.758,00:21:05.397
equal to 1, so it’s hard to
solve this problem you can sit
first app and you foresee this 1

00:21:05.397,00:21:10.402
you can use the Global Write to
modify this, this bit okay? You
can fill the that, fill that bit

00:21:13.806,00:21:18.811
to 1, then you can write to the
target, this is basically we
use. So, for this complex fig-

00:21:22.882,00:21:27.887
actually, we want to control the
PC and R0. Uh, R0 we have a- uh
8 bytes, the first 4 bytes is

00:21:33.559,00:21:38.564
the PC and the second 4 is R0.
Uh [clears throat], we search
from the memory and find this

00:21:42.334,00:21:47.339
place we can write table and the
reach here our remote package
okay? Then, you see there are a

00:21:50.409,00:21:57.082
lot of 1 and the 1 we can move,
move the smart pointer forward,
move on, move on, move on and

00:21:57.082,00:22:02.021
then we can override the target
PC and the R0 okay. So, we have
control of the PC and R0 uh we

00:22:05.858,00:22:10.863
can hmm, we can then run some
FOP to do some complex job such
as to write into the uh FOP and

00:22:18.604,00:22:23.609
the mapping the RWX page this is
to map some page to uh modify
the code physical DRAM. And

00:22:27.112,00:22:32.117
remember, this is a code
segment, b00 and uh and
originally come from 9,3,6 uh

00:22:35.354,00:22:40.359
you want it to want to write the
code segment so we using the FOP
to uh map this uh 4,2,4,2 uh

00:22:46.298,00:22:51.303
using this FOP. So, now we can
write to the code segment, and
uh we can write to we have a

00:22:56.342,00:23:03.249
arbitrary write. So, we can
copy, copy our shellcode into
the, into the code space and the

00:23:03.249,00:23:08.254
trigger, you can see we copy the
shellcode. The shellcode usa-
usually in the data packet, so

00:23:10.522,00:23:15.527
we copy the data packet of data
into the destination the 4,2,4,4
and then we tr-trigger this

00:23:18.964,00:23:23.969
function okay? So, now we have
running our Arbitrary code in
the WLAN. Actually, we have now

00:23:33.045,00:23:38.050
in the WLAN okay we are going to
the modem. Uh, the WLAN in the
different uh process in the

00:23:45.357,00:23:50.362
baseband of the modem we can see
the kernel the QURT OS and the
WLAN and the modem in the

00:23:53.032,00:23:59.104
process and they’re running the
user space. So, how to get into
the WLAN or uh into the modem

00:23:59.104,00:24:06.011
from the WLAN. There are
numerous actions such as modify
the code segment and uh write

00:24:06.011,00:24:11.016
the modem data for complex
functions but uh there all
illegal. If you call uh if you

00:24:15.254,00:24:21.660
do this dangerous actions, the
baseband stops this and you are
crushed, okay. But, you’ll

00:24:21.660,00:24:26.665
remember you can map memory, so
how about we map the modem
memory. directly into the WLAN

00:24:29.335,00:24:34.340
okay. Just like this, we map the
modem um memory from on the WLAN
okay it’s a memory map just map

00:24:42.514,00:24:49.121
the physical memory into the
WLAN virtual address and then we
can modify the memory content

00:24:49.121,00:24:54.126
okay. So, we can modify the code
of the modem so we control the
modem. Okay, so the last step is

00:25:01.367,00:25:06.372
to escape from the modem into
the linux kernel. This leaves
the other map we are going to do

00:25:08.640,00:25:15.080
okay there are a lot of attack
surfaces, so if you are
interested you can read about it

00:25:15.080,00:25:20.085
later for detailed information.
Okay. Uh, this is the issue uh
the CVE uh 20, 19 1-0-5-3-8

00:25:30.929,00:25:35.934
which has already been fixed in
the August android security
breach uh you can see that you

00:25:39.204,00:25:44.209
check from the data pac-packet
coming from the modem okay. Uh,
what’s this doing? Uh, actually

00:25:46.912,00:25:51.917
it’s about the memory management
of Qualcomm multi-processor. Uh,
so very big topic in fact about

00:25:55.788,00:26:01.360
uh memory management so it’s uh
simplified with tree figure. Uh,
there are two things you need to

00:26:01.360,00:26:03.796
know, first thing is that linux
maps the model that means the
whole system, uh the memory of

00:26:03.796,00:26:06.432
the whole system is management
by the linux kernel. Uh, the-
the peripheral such as Venus,

00:26:06.432,00:26:11.437
modem, WLAN or a bluetooth
oth-other peripheral subsystem
the mem-memory is all management

00:26:26.885,00:26:31.890
by, by the linux kernel and the
linux kernel we are are use the
SMMU to protect the memory. For

00:26:36.628,00:26:41.633
example, if the modem owns, owns
this, this memory, uh everytime
and the other, other peripheral

00:26:47.372,00:26:52.377
check this DRAM and the SMMU you
check uh the permission and find
out that the venus doesn’t have

00:26:59.151,00:27:04.089
this permission and then this
whole system is down. So, this
is the two things you’re

00:27:06.658,00:27:11.663
remember linux uh linux uh
master motor and SMMU protect
the uh memory. So the problem

00:27:16.802,00:27:21.807
you’re here in fact this is uh
mystery lo- logic, generally
linux we are decide the address

00:27:26.979,00:27:32.784
and decide to ans uh uh assign
to other profiles of the
subsystem. Over here you can see

00:27:32.784,00:27:37.789
the address and the size uh
determined by the modem uh um we
don’t know why but it is for the

00:27:40.893,00:27:45.898
modem send out the address to
linux, then linux will use this
address directly and use the

00:27:49.101,00:27:54.106
size directly. So, uh, if we uh
send the address to the code
address on the linux so the

00:27:58.076,00:28:04.816
address we are be uh so the
address we are be a map to into
modem and then modem can modify

00:28:04.816,00:28:09.821
the code level of the linux
kernel, that is the issue okay.
So, now we are actually in the

00:28:14.693,00:28:19.698
linux kernel so, we’re gonna
talk about how to send out the
payload. Uh, actually, before we

00:28:22.601,00:28:27.606
are using this copy and WIFI
tengo but it’s not-not very
stable. Finally, we are u-using

00:28:29.808,00:28:34.813
a Pixel 2 to send out the
pay-payload and using the Pixel
2 to attack the Pixel 2XL. So,

00:28:37.883,00:28:42.888
you can see the Pixel 2 send out
WIFI payload and then Pixel 2XL
we uh receive the payload and

00:28:46.158,00:28:51.163
then uh confirm it ok. This is a
whole roadmap we are using Pixel
2 send out this and finally eh

00:28:54.900,00:28:59.905
from modem into the linux kernel
ok. Into WLAN, into modem, into
linux kernel ok. Let’s uh use

00:29:07.079,00:29:12.084
some [clicking and typing] ah
the demo is here uh can I see?
Okay uh [mouse clicking] uh this

00:29:26.498,00:29:31.503
is on left is the Pixel- Pixel
2. Uh it is sending sending out
uh package send out the- the

00:29:43.882,00:29:49.588
payload to attack the left is
the Pixel 2 XL. Okay, you can
see the information on the

00:29:49.588,00:29:51.590
system okay, so the whole
process near[inaudible] can see
uh now we are we are in the

00:29:51.590,00:29:53.592
shell and the the [clears
throat] linux kern uh linux is
enforcing. So, we have no

00:29:53.592,00:29:58.597
permission and to- to the
dangerous so this, they are
sending out the payload-payload

00:30:21.286,00:30:26.291
and uh that’s-that’s speed up,
speed up, speed up so the linux
they are enforcing you know

00:30:34.299,00:30:39.304
enforcing, so the Pixel 2 they
are sending out the payload it’s
uh about the streaming is okay-

00:30:55.487,00:31:00.425
okay exploit done. Okay, okay
see wait for one minute [mouse
clicking] and you can see

00:31:07.632,00:31:12.637
finally we are getting into the
linux kernel and uh disable the
s id linux flow. Uh, now, okay

00:31:25.217,00:31:31.089
we can use the d method actually
we are running arbitrary code in
the linux kernel from the mo-

00:31:31.089,00:31:36.094
remote WLAN ok. Um [applause] uh
thank you. Uh, so time is up and
uh, uh we note this issues al-

00:31:46.905,00:31:52.878
already been fixed uh in the
August briefing and the patch
and you can see the detailed

00:31:52.878,00:31:57.883
information here. And today we
talked about how to remotely
into-into the kernel and the OTA

00:32:04.289,00:32:09.995
package into WLAN and the modem
the for- full chain and the
vulnerability and the

00:32:09.995,00:32:15.000
exploitations and the baseband
substation, so thanks very much
for your time, thanks very much.

00:32:18.003,00:32:22.374
[applause]

