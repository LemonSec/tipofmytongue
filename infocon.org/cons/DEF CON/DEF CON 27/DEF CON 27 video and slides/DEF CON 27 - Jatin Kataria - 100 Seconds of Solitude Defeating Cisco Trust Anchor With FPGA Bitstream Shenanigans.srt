00:00:00.133,00:00:05.239
>>Alright I’ll hand it over to
these wonderful people. Give
them a big round of applause.

00:00:05.239,00:00:10.244
[applause] >>Alright ah ok so
you guys are all here, I’m sure
you- you know what this talk is.

00:00:13.313,00:00:16.917
You should pat yourself on the
back because this is the right
choice for the talk to attend

00:00:16.917,00:00:21.788
right now. It is the best talk,
you made the right decision.
You’re life is already done,

00:00:21.788,00:00:26.627
you’re good! You’re good for
life because uh we’re talking
about Cisco routers and secure

00:00:26.627,00:00:31.632
boot uh and the title of this
talk is 100 Seconds of Solitude.
Uh my name is Ang Cui. >>I’m

00:00:34.301,00:00:40.474
Jatin Kataria. >>Is that on?
>>No. >>Is this thing on? >>Uhh.
>>Hey uh my name is Jatin

00:00:40.474,00:00:45.479
Kataria. >>Very good ok. And
what is primary main objective?
[laughter] Primary main

00:00:47.915,00:00:52.920
objective is not Chinpokomon
Camp [laughter] it is Cisco
trust anchor. Uh and you know so

00:00:54.955,00:00:59.059
this talk is about the work that
we’ve done over the last 3
years, uh around reverse

00:00:59.059,00:01:04.398
engineering not just the Cisco
router uh in front of you but uh
a fundamental piece of hardware

00:01:04.398,00:01:10.671
that underpins a lot of the- the
secure boot process of uh dozens
of types of Cisco devices

00:01:10.671,00:01:15.275
ranging from you know small
switches all the way up to the
very large enterprise level you

00:01:15.275,00:01:19.780
know core routers. So uh the
trust anchor is something that
we had no idea it existed when

00:01:19.780,00:01:24.384
we started this project. And
we’ll take you through all of
that story but um ultimately

00:01:24.384,00:01:28.355
what this revolved around was
the work that we developed,
techniques that we developed, uh

00:01:28.355,00:01:34.428
to manipulate FPGA bit streams
in order for it to do something
useful. Uh so uh you know even

00:01:34.428,00:01:40.367
though we’re gonna talk about
the security implications of uh
our techniques on this router,

00:01:40.367,00:01:47.074
uh we’re really here to talk
well ok so the deeper primary
main objective is uh FPGA

00:01:47.074,00:01:51.979
bitstream manipulation. And the
reason why this is is because
you know yes uh Cisco routers

00:01:51.979,00:01:57.117
and switches you know all use or
a lot of them use this type of
uh you know Spartan’s Xilinx’s

00:01:57.117,00:02:02.789
FPGA but so do a whole lot of
other things in the world. Like
you know uh advanced driver

00:02:02.789,00:02:08.028
assistance cars, uh I’m sure
legacy weapons systems,
missiles, and all sorts of

00:02:08.028,00:02:11.865
things and the uh you know the
techniques that we’re going to
talk about here are going to

00:02:11.865,00:02:16.636
affect those devices too, so
even though this might seem like
a fairly large impactful

00:02:16.636,00:02:20.907
vulnerability disclosure, uh the
real impact of using these
techniques uh in devices we

00:02:20.907,00:02:26.079
haven’t even started to look at
uh I think is much larger. So uh
you know like I said we did this

00:02:26.079,00:02:31.284
for 3 years uh and there is a
long story which I’m gonna take
you through over the next 235

00:02:31.284,00:02:36.556
slides. And yes I have exactly
those uh and but before we start
you know this is kind of an epic

00:02:36.556,00:02:41.561
story you know there’s love and
loss and betrayal, more love,
and friendship and defeat and

00:02:43.730,00:02:49.369
you know redemption and and more
friendship uh so we’re gonna go
through the cast. Uh Jatin, over

00:02:49.369,00:02:56.109
here, right. That’s him. Uh Rick
is actually in the front row,
that’s Rick. Joey is sadly not

00:02:56.109,00:03:01.915
here, I think he’s at a wedding.
Uh this is me, I’m wearing
sandals, just like the photo

00:03:01.915,00:03:07.454
shows. James uh right there ok.
And um well over the last 3
years uh at Red Balloon

00:03:07.454,00:03:12.426
Security, we’ve invested a ton
of our resources in creating
this massively complicated

00:03:12.426,00:03:17.731
highly intelligent automated
testing framework uh abbreviated
to BRIAN. You know it’s so

00:03:17.731,00:03:22.135
complicated that some might even
say that he is borderline
sentient. Which I think is

00:03:22.135,00:03:27.340
ridiculous but you know, we’ll-
we’ll get to that. Alright so as
with uh all great epic tales, uh

00:03:27.340,00:03:33.013
we start in mid story! Ok so you
know we started this work in
2016 uh in 2015 Jat and I worked

00:03:33.013,00:03:35.015
on this little thing where we
got code execution inside the
onscreen display controllers of

00:03:35.015,00:03:37.017
all sorts of you know probably
over a billion monitors. Uh and
then in 2017 you know Rick and I

00:03:37.017,00:03:42.856
worked on this thing where we
built a EMP uh electromagnetic
pulse generator, in order to

00:03:42.856,00:03:48.662
defeat secure boot in trust zone
on a Cisco phone. So you know
those projects were pretty

00:03:48.662,00:03:53.667
simple, straightforward, you
know there’s really no thinking
involved, I mean very easy to

00:04:00.440,00:04:06.780
do. Uh so in the middle of all
of that you know I say hey guys
like our lives are so easy you

00:04:06.780,00:04:12.319
know like it’s going too well,
uh let’s punish ourselves for
like no reason. And then Jatin

00:04:12.319,00:04:18.525
says- >>What the F man? Why?
>>Grr Grr Grr [laughter] Say
what? Right so ultimately you

00:04:18.525,00:04:24.764
know fast forward to 2019 here
we are talking about all of that
work. Uh and you know it

00:04:24.764,00:04:28.935
resulted in this thing called
Thrangrycat. Right? And
technically you can’t pronounce

00:04:28.935,00:04:33.607
it like Thrangrycat because it
is the first vulnerability named
after three unpronounceable

00:04:33.607,00:04:39.045
emojis so you can only come
close to pronouncing it but not
really, you can’t really say it

00:04:39.045,00:04:45.852
out loud. Uh thrangry fact 1: uh
the domain name for this
vulnerability is emojis ok and

00:04:45.852,00:04:52.659
for uncool kids you can type it
out as thrangrycat it’s fine. Uh
thrangry fact 2, we you know

00:04:52.659,00:04:56.129
have all sorts of information
about the nature of the
vulnerability, you know how we

00:04:56.129,00:05:02.202
did it. And actually I will
tempt fate and try to tap out of
this thing to show you our

00:05:02.202,00:05:08.542
website. So if you go to our
website uh just a few hours ago
you know we put the slides up

00:05:08.542,00:05:12.679
finally and then we also have
all of the libraries that we’ll
be talking about and the tools

00:05:12.679,00:05:16.716
that we’ve built um it’s all on
GitHub it’s right there on our
website. So if you like any of

00:05:16.716,00:05:20.954
this stuff and you’re
interested, check it out, the
tools are actually super cool.

00:05:20.954,00:05:25.959
Ok so we wrote about you know we
had this like 4 uh reach
rational- uh 4 serial- a set of

00:05:28.195,00:05:33.900
4 reasons why we decided to name
uh our vulnerability after
emojis uh and I’ll just give you

00:05:33.900,00:05:40.440
1. Rule- uh reason number 2 is
that emojis are indexical to the
digital age. Right and uh that’s

00:05:40.440,00:05:45.111
just 1 of 4 reasons and thrangry
fact 2 point 1 and this made my
heart sing when I read it,

00:05:45.111,00:05:49.015
right. I found it interesting
that the section that explains
the name of this vulnerability

00:05:49.015,00:05:53.186
is way more thought-out and
verbose than any other sections.
It’s almost they had like a

00:05:53.186,00:05:58.325
linguist on the team and the
emoji name was his prideful
contribution. True fact. True

00:05:58.325,00:06:04.698
fact. Uh thank you if you’re out
there, you’re good. Um alright
so just the immediate impact of

00:06:04.698,00:06:10.604
uh this vulnerability uh it
affected like I said probably s-
I think something like 180 uh

00:06:10.604,00:06:16.376
types of- >>133. >>133 Cisco
devices and here’s a list of
some of them. You know it goes

00:06:16.376,00:06:22.649
to like this page and more on
this page and this page and this
page and this page and this page

00:06:22.649,00:06:27.654
and this page I think there’s 1
more. Nope, 2 more. 1 more.
Alright? Alright cool. So it

00:06:29.723,00:06:34.427
affects a whole lot of Cisco
routers. Alright let’s talk
about how we did it. Uh you know

00:06:34.427,00:06:39.432
so. >>It all started when we
wanted to uh hack ASR 1001. But
it was end of life and uh Cisco

00:06:41.601,00:06:46.606
started uh you know sending 100X
in 2013. >>Yeah so right Jatin’s
like let’s look at the 1001. And

00:06:49.109,00:06:53.013
I was like aw, we can’t really
buy this thing anymore so
whatever I see this thing called

00:06:53.013,00:06:59.219
the 1001X, uh whatever let’s
it’s probably the same you know.
>>Yeah but uh what uh doesn’t

00:06:59.219,00:07:03.189
matter we don’t care but
documentation, who cares about
the X, you know? X is for

00:07:03.189,00:07:07.894
chumps. >>It’s probably fine
right? So we looked at it, we
you know signed ourselves up to

00:07:07.894,00:07:12.899
do this work and you know to be
fair, look the left is the 1001,
the right is the 1001X, looks

00:07:14.901,00:07:21.741
exactly the same. Uh you know
the 1001X uh it was kind of
expensive it’s like 11,000

00:07:21.741,00:07:27.881
dollars per router but we bought
it anyway to d- help everyone
visualize what exactly that is-

00:07:27.881,00:07:31.484
>>It’s on sale, no? >>Huh? >>The
sev- it was on sale. >>Oh that’s
right. It’s on sale so you can

00:07:31.484,00:07:38.024
get it for a little bit cheaper.
Uh anyway so what is that? Let’s
talk about what that means so 1

00:07:38.024,00:07:44.898
dollar is uh 6 point 1 4 inches
by 2 point 6 1 inches. It’s
approximately 1 gram so the cost

00:07:44.898,00:07:49.903
of that 1001X is approximately 3
and 3 point 5 8 feet or 22
pounds which uh to put in a unit

00:07:52.872,00:07:57.777
that you guys can understand,
it’s basically 2 healthy 3 month
old babies stacked on top of

00:07:57.777,00:08:00.880
each other. Like that’s the
right height and weight, that’s
exactly what it is. Ok. So the

00:08:00.880,00:08:02.882
uh 1001X the X uh has this thing
called trust anchor in secure
boot which again at the time we

00:08:02.882,00:08:07.887
had no idea what it is, uh so we
thought hey maybe this is just
like a new boot loader, whatever

00:08:12.992,00:08:17.897
let’s, we can do it. Alright so
goal is uh what do we want to
do? >>The goal is to modify the

00:08:17.897,00:08:22.902
ROMMon like we just wanted to
run our own firmware, our own
stack on the ASR 1001. It was-

00:08:25.271,00:08:29.376
that’s what we wanted so uh we
have done in our previously work
and we thought you know like it

00:08:29.376,00:08:32.746
will be easy, it was just like
change the root key, change the
firmware, doesn’t matter let’s

00:08:32.746,00:08:38.685
just do that. >>Alright so and
uh this is kind of like iron
chef. The secret ingredient is

00:08:38.685,00:08:45.658
we- we actually have 1 of these
things in front of you and if I
don’t knock it over the table,

00:08:45.658,00:08:52.632
we’ll see what’s inside. Alright
if we don’t keep the lid on uh
it’ll the thermals are horrible

00:08:52.632,00:08:58.004
so it’s not great. But anyways
so when you open this box uh you
see this thing over here. Uh it

00:08:58.004,00:09:02.509
might look a little weird but a
lot of this is basically a
standard you know Intel based

00:09:02.509,00:09:07.046
computer. Alright so the things
that we care about is um you
know obviously there’s the Intel

00:09:07.046,00:09:13.353
Xeon processor so probably a lot
of that code runs there. Uh and
uh there is a Xilinx FPGA so who

00:09:13.353,00:09:16.856
knows maybe that’s doing
something interesting. And this
thing has a number of different

00:09:16.856,00:09:22.328
little FP uh SPI flash chips
that uh we thought might
actually be you know useful to

00:09:22.328,00:09:26.866
look at. Uh and the rest of it
is a whole lot of complicated
hardware that actually makes you

00:09:26.866,00:09:30.703
know the routing and switching
stuff work. But you know we
opened this box and we said ok

00:09:30.703,00:09:34.974
you know we probably understand
something about this uh piece of
hardware, and you know this is

00:09:34.974,00:09:39.446
somewhat like a normal pro-
computer but it certainly has a
whole lot of weird stuff that we

00:09:39.446,00:09:45.318
haven’t seen before. >>Ok so
let’s look at the software now.
Let’s just. Um so eh uh if you

00:09:45.318,00:09:49.122
guys ever worked with Cisco they
used to have uh this uh
proprietary boot console called

00:09:49.122,00:09:54.227
ROMman so which allows you to
boot through TFTP, you know
change images. Uh so what they

00:09:54.227,00:09:59.532
did was they changed to UEFI in
2013 and uh but they still
wanted to work with their

00:09:59.532,00:10:04.904
ROMman, so they implemented a
PRE-ROMman as a Pre UEFI module.
What it does is that it manages

00:10:04.904,00:10:11.377
ROMman. It also with those 2 SPI
flashes as you saw, as you can
see. It also handles the updates

00:10:11.377,00:10:15.315
so in the Linux kernel if they
want to apply a patch to the
bootloader the Linux kernel uh

00:10:15.315,00:10:19.385
kernel will update one of the
SPI flashes and then the
PRE-ROMman will validate uh that

00:10:19.385,00:10:25.391
whether it is right or not and
if it is not, then copy the code
in copy again. Uh pretty common

00:10:25.391,00:10:30.730
stuff. Uh then they had Rom- uh
then they had ROMman and uh
basically this is implemented as

00:10:30.730,00:10:36.169
a DXE module uh again it does
exactly the same thing it can
allow you to boot uh d- Cisco

00:10:36.169,00:10:41.541
images um through DFTP it also
allows it also validates the
next uh operating system it’s

00:10:41.541,00:10:47.046
gonna boot. And the boot loaders
um they are OS stage. And uh it
also has a reverse module which

00:10:47.046,00:10:52.051
allows you to uh in- introspect
what is happening in the DXE.
>>Oh by the way so ROM doesn’t

00:10:54.320,00:10:58.858
stand uh for what you think it
does. It’s not actually Read
Only Memory, it stands for

00:10:58.858,00:11:04.531
Romantic Monitor. [laughter]
True fact.True fact. >>So uh
then comes the Linux kernel, uh

00:11:04.531,00:11:10.336
so they booted uh they started
using uh you know uh- uh off the
shelf Linux kernel on which they

00:11:10.336,00:11:15.341
booted their own Cisco stack
running uh as a privileged
process. They also wrote a

00:11:15.341,00:11:20.446
process manager which uh manages
this process. So anything any
kind of crash happens in the IOS

00:11:20.446,00:11:25.451
it reboots the whole, uh system.
And once you combine this, this
becomes your IOS XE stack and if

00:11:27.520,00:11:32.458
you go to their website this is
the most secure stack. Uh so we
while doing this analysis

00:11:32.458,00:11:37.697
looking at everything we s- s-
saw no hashes on the UEFI no
certs on the UEFI so it should

00:11:37.697,00:11:44.070
be like really easy mod because
our goal is just to run our own
stack. And uh we also disabled

00:11:44.070,00:11:49.576
uh some of the checks which were
in the Pre-ROMMon and we mar- uh
booted the modified firmware and

00:11:49.576,00:11:55.615
everything worked. And it was,
this is pretty simple. Uh so but
wait, then router reset. Then we

00:11:55.615,00:12:00.553
saw like wow it reset after
every 100 seconds which doesn't’
make sense. And uh we spent a

00:12:02.922,00:12:07.193
lot of time. And then I- >>Well
so first it was uh you know it-
it you know it resets- well he

00:12:07.193,00:12:12.432
was able to get code execution
on the Xeon processor and it
allowed us to do it, and then

00:12:12.432,00:12:17.503
you would eventually kind of
reboot and then uh at first you
know he was like “Well, it reset

00:12:17.503,00:12:20.139
once in a while, maybe a
minute.” Right? >>Yeah. >>And
then he was like “Eh it’s kind

00:12:20.139,00:12:24.811
of like 100 seconds.” And I said
well, how many seconds? Like
exactly 100 seconds? Because

00:12:24.811,00:12:28.281
computers don’t like to count in
decimal you know, it’s not like
they have 10 fingers and 10

00:12:28.281,00:12:33.820
toes. So 100 exact seconds-
>>Yeah. >>Was kind of a hint to
us that there’s something else

00:12:33.820,00:12:38.992
uh that’s kind of like a you
know a piece of code that some
engineer wrote that enforces

00:12:38.992,00:12:43.830
that 100 second thing. >>So this
is signified by a loud fan
noise. These fans as you can see

00:12:43.830,00:12:48.568
4 fans, make a very loud noise
and this was crucial in doing
all of the reverse engineering.

00:12:48.568,00:12:53.306
This is probably the key, the
fan noise. So we came up with
the hypothesis of like what is

00:12:53.306,00:12:57.377
this 100 second reset causing?
You know there are multiple X86-
because the route processor is

00:12:57.377,00:13:02.348
in X86 code so maybe there are
multiple mitigations like the 1
is the you know maybe it is

00:13:02.348,00:13:06.319
doing some kind of virtual
machine introspection. Uh but we
analyzed the code it was already

00:13:06.319,00:13:11.291
disabled. Uh X86 has dozens of
watchdog timers. So we disabled
all of them because we had 100

00:13:11.291,00:13:17.730
seconds to run whatever code we
want. And uh that also did not
help uh then we went to SMI_EN

00:13:17.730,00:13:23.803
and we saw like SMI_EN was
enabled so we disabled that. Uh
but it was still rebooting. So

00:13:23.803,00:13:29.142
it was like um, I don’t know
man. >>Yeah so we we
hypothesized like is there like

00:13:29.142,00:13:33.980
a magical deity in this
processor that somehow despite
the fact that we control every

00:13:33.980,00:13:38.584
instruction that executes on the
processor, still it’s watching
us and tempting us right. It

00:13:38.584,00:13:43.322
allows us to execute, like our
hopes are coming true, right?
And it waits for 100 seconds

00:13:43.322,00:13:49.729
before it takes our dream away,
right? Like what kind of thing
is this? Rrgghh. Alright so you

00:13:49.729,00:13:53.399
know normally eh every time we
asked this question like how do
we mind read the computer? We

00:13:53.399,00:13:57.570
don't understand! Uh we
typically elect to default back
to electromagnetic emanation.

00:13:57.570,00:14:02.208
And if you look at some of the
past research we’ve- we’ve done
this is a really useful tool. Uh

00:14:02.208,00:14:06.212
and a way to kind of figure out
you know what the computer is
kind of doing without really

00:14:06.212,00:14:10.516
understanding a lot. So you know
basic stuff like when you push
an electron through a wire,

00:14:10.516,00:14:14.087
right, it’ll like sit and do
some magnetic field, then an
electric field, so it kind of

00:14:14.087,00:14:19.559
emanates right EN so when you
take nearfield probe to the
thing right you should be able

00:14:19.559,00:14:24.497
to measure out the uh- you know
activity around certain parts of
the- the machine in order to

00:14:24.497,00:14:29.969
kind of come out with a timeline
of what is probably executing.
So you know we have the CNC

00:14:29.969,00:14:33.906
machine that we like to hook up
to the nearfield probe right to
do this type of you know

00:14:33.906,00:14:38.878
analysis automatically. Uh I
think the zip tie broke so we’re
just holding it by hand but

00:14:38.878,00:14:45.184
usually it’s automated. Uh we -
we swear right. So uh after
gathering some data here is what

00:14:45.184,00:14:51.491
we have. Ok. So uh on this 1- on
the- all on the- way on the
right we have uh the emanation

00:14:51.491,00:14:57.764
coming out of the- the CPU power
supply. Ok so there is a tiny
little dot uh where is my mouse

00:14:57.764,00:15:03.803
up here right so this is uh you
know time right uh so you know
as we go downwards that’s later

00:15:03.803,00:15:08.074
in time so little dots come up
right and a whole lot of uh
noise coming out of the power

00:15:08.074,00:15:12.378
supply you know in like a
quarter second or something like
that. Now uh there’s nothing

00:15:12.378,00:15:18.618
coming out of uh the CPU the
Xeon processor until basically
the bottom of- of- of this

00:15:18.618,00:15:25.391
graph, so the processor is
sitting idle doing nothing but
the FPGA the Xeon Spartan 6 FPGA

00:15:25.391,00:15:31.164
has this uh emanation profile so
you know a neat- slightly after
the initial power turn on right

00:15:31.164,00:15:35.968
you see 2 little blips and then
it waits there for a while,
thinks about its life, and then

00:15:35.968,00:15:42.408
uh later it starts doing a bunch
of stuff. Right and then the SPI
chip 1 of the SPI chips which is

00:15:42.408,00:15:47.747
actually connected to the FPGA
right has similar uh
electromagnetic emanation

00:15:47.747,00:15:52.552
profile uh in the beginning and
then you know it well it gets
red and then basically nothing

00:15:52.552,00:15:56.422
happens so you know if you put
like this is like Blue’s Clues
right? You put all of these

00:15:56.422,00:16:02.628
clues together I wonder what’s
happening? So power turns on,
right. The FPGA reads from the

00:16:02.628,00:16:08.734
SPI uh flash uh its bit stream
right, it actually reads 2 bit
streams, and then it loads the

00:16:08.734,00:16:14.140
configuration into the FPGA and
then the FPGA does some magical
thing right and then basically

00:16:14.140,00:16:20.179
at the very bottom of this, this
is where the uh the- the Xeon
processor starts to do stuff. So

00:16:20.179,00:16:22.181
uh you know we start
hypothesizing that this is
basically the mean little deity

00:16:22.181,00:16:24.183
that’s hiding in the machine
that’s taking our dreams away
after 100 seconds. >>You took my

00:16:24.183,00:16:26.185
joke. [laughter] >>Alright.
>>The deity 1. >>Aww.
>>[Chuckles] But uh there is a

00:16:26.185,00:16:28.187
slide. [chuckles] So uh there
were a number it’s coming out of
this SPI uh and uh we saw you

00:16:28.187,00:16:33.192
know like it was not available
in the boot loader and turned
out uh we had 100 seconds so we

00:16:40.499,00:16:45.504
can dump this code. Uh and uh
these were interrupt handlers uh
for the real mode. Uh basically

00:16:50.977,00:16:56.582
the BIOS/ROM/vBIOS which is
present in that range. Uh then
we also you know alaysed we saw

00:16:56.582,00:17:02.388
some uh address ranges which was
like uh 0XFED4 as you can see.
This is usually used for

00:17:02.388,00:17:07.393
external devices uh which are
map um, uh you know mme remapped
as uh IO devices uh for SQ’sI

00:17:10.129,00:17:15.835
you know bus which is basically
a serial core interface. And uh
once you once this also gives us

00:17:15.835,00:17:21.908
like kind of an idea like some
other IO device is mapped in and
X86 is uh- uh reading it’s

00:17:21.908,00:17:27.513
state. So just to validate we
also hijacked the first X86
instruction, wrote the whole

00:17:27.513,00:17:32.051
serial driver. Literally
validated and there was an
external entity which was doing

00:17:32.051,00:17:36.889
it, and that was the joke, but-
>>Well wait wait hang on. So
this is where you know he put in

00:17:36.889,00:17:41.127
this side and I said well you
know let’s not be culturally
insensitive so I added- we do

00:17:41.127,00:17:45.231
have a cat vibe and then the
rest of this presentation so cat
buddha, cat buddha, cat buddha.

00:17:45.231,00:17:50.236
[laughter] So there is a deity,
it is a vengeful 1. >>So uh we
wanted to uh you know we knew

00:17:52.338,00:17:58.010
that FPGA is doing the reset uh
so this was our assumption at
this point. Like FPGA is

00:17:58.010,00:18:04.283
booting, uh it’s validating the
UEFI so any bad change in the
UEFI uh s- address space uh you

00:18:04.283,00:18:09.221
know causes the whole thing to
uh reset. And also Pre-ROMmon
checks ROMmon, ROMmon checks the

00:18:09.221,00:18:14.727
LINUX OS um it’s kind of uh you
know secure boot flow. So then
we wanted to find the reset pin

00:18:14.727,00:18:20.232
and uh uh it was the first
10,000 dollar device which we
did because it was a PGA chip

00:18:20.232,00:18:25.705
and- >>Well, so, and this is a
large part of the difficulty of
doing this work, because I mean

00:18:25.705,00:18:30.309
seriously who can afford to just
blow away 10,000 dollars by like
touching a pin wrong you know.

00:18:30.309,00:18:35.581
Th- that was for all of us uh
and we’ve destroyed many more
than just 1 of these. Uh so this

00:18:35.581,00:18:40.353
was uh for all of us probably
the most expensive soldering
mistake we’ve made in life until

00:18:40.353,00:18:45.758
this point so in in honor of
those mistakes we’ve built the
fail fort! Right? So the fort

00:18:45.758,00:18:50.496
grows every time and there’s a
whole history mythology about
the rise and fall of fail fort

00:18:50.496,00:18:55.101
but anyway fail fort version 1,
10,000 dollars, uh humble
beginnings. >>This is the start

00:18:55.101,00:19:00.039
of the civilization. Um then uh
we wanted to test this theory
right uh and RTL reconstruction

00:19:00.039,00:19:05.978
is really hard, and we’ll come
back to RTL- uh RTL. What is
RTL? And then uh but we still

00:19:05.978,00:19:10.850
wanted it and uh uh I want just
like to pull the pre-reset pin
high and I’m a systems guy so I

00:19:10.850,00:19:17.456
go to either Ang or to Rick for
my hardware problems and uh Rick
said you know this GI Joe guy

00:19:17.456,00:19:21.427
over there like “I’m gonna take
a 10k ROM resistor and I’m gonna
just you know keep it high

00:19:21.427,00:19:27.333
always.” And then it again
costed, it basically costed 1
dollar per 1 ohm. And it was

00:19:27.333,00:19:31.637
total cost was 20 thousand
dollars. >>Alright so now the
router sitting there doing like

00:19:31.637,00:19:37.076
completely unfazed except you
know the ones that have died, uh
and us we’re negative 20,000

00:19:37.076,00:19:43.416
dollars uh, in a- in a whole. So
version 2 you know we started
racing recklessly toward fail

00:19:43.416,00:19:49.121
sky. >>This is- this is where we
uh you know took over the temple
that John built. Uh [laughs].

00:19:49.121,00:19:53.793
>>Alright so you know at this
time ano- another 1 of our
colleagues, you know uh Joey was

00:19:53.793,00:19:58.097
sitting and saying “Well, man.
Why are you guys like breaking
all of this equipment? You guys

00:19:58.097,00:20:02.201
suck. Like why don’t you try to
Google this, you know?” And he
said like “I’m a level 9 Googler

00:20:02.201,00:20:08.874
so look I type into the computer
thing and I found this patent.”
So here is a patent uh awarded

00:20:08.874,00:20:14.246
to Cisco in 2012 that talked
about a lot of the things that
we were kind of seeing. Right so

00:20:14.246,00:20:19.819
it is a patent on secure boot
through an external device and
it ex- specifically said you

00:20:19.819,00:20:24.023
know you can implement this
using FPGA and it actually has a
very similar diagram to the

00:20:24.023,00:20:28.861
thing that we came up with. So
anyway this document, super
useful. And 1 key thing that the

00:20:28.861,00:20:32.932
document said is you must
implement the trust anchor which
is uh I think what they called

00:20:32.932,00:20:38.504
it in this patent with an
immutable uh thing right because
if the attacker can m- like

00:20:38.504,00:20:43.576
change it then the whole the
premise of it goes away. Uh and
they also said that you can

00:20:43.576,00:20:47.012
implement it with an FPGA. But
you know we’ll get back to that.
>>Uh so wait- so this is

00:20:47.012,00:20:51.016
honestly if you see it
disconnected through LPC bar, so
the way it is actually doing it

00:20:51.016,00:20:55.821
is like it turns off these
upgrades so uh we had the code
hash to just reset. >>Alright so

00:20:55.821,00:21:00.659
at this point you know we can
we’re kind of getting somewhere
but you know for- for us and I

00:21:00.659,00:21:04.864
think for a whole lot of other
folks out there, you know we’re
firmware people you know maybe

00:21:04.864,00:21:10.236
software people, maybe some
hardware people but all of us
found FPGAs to be scary. You

00:21:10.236,00:21:14.907
know it is a mystery thing that
is really hard. Lot of smart
people working on it and uh you

00:21:14.907,00:21:20.546
know they haven’t done the thing
that we needed so you know we
kinda you know said “uh this is

00:21:20.546,00:21:25.017
so hard!” then we said “well you
know what, like why don’t we
stop? Let’s give up and say we

00:21:25.017,00:21:30.489
didn’t.” And then like a year
goes by, right because uh you
know we have actual work and you

00:21:30.489,00:21:36.061
know we already defeated twice
like 20,000 dollars in the hole
um and then you know 1 night

00:21:36.061,00:21:40.833
Jatin was like- >>Yeah yeah I
basically went to Ang and I said
like give me 20,000 dollar more.

00:21:40.833,00:21:46.639
>>[laughs] Let’s do it! So- >>I
can- I can hack FPGA. >>Yeah and
I said fine let’s go do it. So

00:21:46.639,00:21:51.744
uh he read a ton of docs and
he’s gonna talk about it.
>>Yeah. So uh again as I said

00:21:51.744,00:21:56.182
like I’m a systems guy so you
know how do you understand
FPGAs. And uh- >>Wait actually,

00:21:56.182,00:22:00.986
we we never defined what is an
FPGA? What is that for? >>Yeah.
So what is an FPGA? Right like

00:22:00.986,00:22:05.791
it looks like a lot of blocks,
lot of registers, lot of flip
flops, I have no idea. >>Field

00:22:05.791,00:22:11.530
programmable gate array. >>Oh I
see. >>Yeah. >>I still don’t
know that. Ok. [laughter] So uh

00:22:11.530,00:22:15.901
how does the FPGA design flow
works, right? Like uh the coder
basically provides the hardware

00:22:15.901,00:22:19.772
circuit, and then the SGA
hardware description language uh
the render dual chain

00:22:19.772,00:22:24.710
synthesizes it, places it, maps
it, all this information about
the turntables about what is the

00:22:24.710,00:22:31.650
memory initialization, routing,
and so forth. Uh gets encoded
into a bitstream which gets

00:22:31.650,00:22:36.689
encoded into a binary which we
call it a configuration
bitstream. So any time FPGA gets

00:22:36.689,00:22:42.661
configured how the uh you know
because it is an ICU which has
be- benefits of both hardware

00:22:42.661,00:22:47.266
and software, uh so it has
hardware logic block to
implement to do competitions and

00:22:47.266,00:22:51.904
s- um it can be reconfigured as
software. And there are
different types of FPGAs there’s

00:22:51.904,00:22:56.141
SRAM based FPGA which is
basically boots uh it’s
configuration bitstream from an

00:22:56.141,00:23:01.513
external static memory. Uh so
any time it reboots it has to
reload itself and that’s what

00:23:01.513,00:23:06.085
we’re talking about here uh for
Cisco ASR. And then the other 1
is the flash based in which the

00:23:06.085,00:23:10.990
flash is automatic uh is already
present on the die it’s less
power consumption, it uh boots

00:23:10.990,00:23:15.027
really quickly. And then the
other 1 is the antifuse which
is- doesn’t allow you to

00:23:15.027,00:23:20.332
configure again, so it’s not
kind of FPGA. So but still what
is FPGA? >>And now we learn-

00:23:20.332,00:23:25.037
>>Yeah >>About the advance of
FPGA because that’s how smart we
are. >>Yeah and beginning FPGA

00:23:25.037,00:23:29.508
and I just learned Field
Programmable Gate Array. Ok.
>>And actually you still didn’t

00:23:29.508,00:23:33.612
know what FPGA stands for. So
good. >>[laughing] So FPGA can
be thought of think of as like a

00:23:33.612,00:23:38.083
combination of blocks you know.
Each block does something and
they basically correlate with

00:23:38.083,00:23:43.389
each other. But again, what is
FPGA for systems people? Why is
it called to effects? So this is

00:23:43.389,00:23:49.628
very important because what
matters is like if we can
control the Y and the X with

00:23:49.628,00:23:55.968
irrespective of the logic F,
then we win. Doesn’t matter how
complex it is. So let’s go

00:23:55.968,00:24:01.473
inside like what are the basic
blocks of the FPGA? IOB is a
group of basic elements which

00:24:01.473,00:24:07.346
drives uh the output and the
input functions of the FPGA and
the value could be 0, 1, or Z.

00:24:07.346,00:24:12.251
But really what is it? It is
just a thing which is connected
to IO pin and it gives 0 or 1.

00:24:12.251,00:24:17.222
That’s all you care about. The
second thing is IO Interface.
This is how the pin gets the

00:24:17.222,00:24:22.661
val- uh uh the value from the
rest of the logic and provides
value to the uh to the other

00:24:22.661,00:24:27.866
part of the logic. And the third
is BRAM which is just memory. It
can be of different data bit uh

00:24:27.866,00:24:33.305
you know it could be 1 bit, uh 1
width or 2 or 32 or it could be
uh for Spartan 6 it’s like 18

00:24:33.305,00:24:38.110
kilobyte 9 kilobyte blocks. You
can configure it you can make it
uh singular to a port. The other

00:24:38.110,00:24:41.981
uh which does uh so complex
logic block is something which
implements the boolean function

00:24:41.981,00:24:47.252
of the FPGA. There’s 2 slices, a
switch map matrix. Switch matrix
allows it to com- uh you know

00:24:47.252,00:24:51.590
like- communicate with the rest-
uh rest of the FPGA or also
allows it to communicate it to

00:24:51.590,00:24:57.229
other parts of the IO. Uh and uh
it- the slice contains flip
flops and LUT again, it doesn’t

00:24:57.229,00:25:02.167
matter for a systems guy. Uh and
then there is you know slices
can be of multiple types, Slice

00:25:02.167,00:25:08.273
X boolean function, Slice L with
the carry logic boolean function
and Slice M also allows- gives

00:25:08.273,00:25:13.645
you some memory. Uh but this is
the complexity of the FPGA.
>>It’s so complicated. I’m I’m

00:25:13.645,00:25:17.349
bored just- >>I know!
>>listening to this. Right?
Because there’s so many you know

00:25:17.349,00:25:22.454
like little nuances of piece of
ar-like all of the stuff and all
of the innards of this is uh all

00:25:22.454,00:25:27.626
almost always in commercial
FPGAs kept as a secret. This is
a proprietary thing you know

00:25:27.626,00:25:31.897
they allow you to they give you
the tool chain that generates
you know from the- the hardware

00:25:31.897,00:25:35.968
description language, that
bitstream that configures their
specific vendor specific you

00:25:35.968,00:25:41.807
know FPGA and it will work but
they don’t actually they will
generally never tell you the-

00:25:41.807,00:25:47.546
any of the internals of how that
bitstream is read and what it-
what that bit actually does. But

00:25:47.546,00:25:51.984
you know you have to know all of
this stuff about the components
and you kind of match up just

00:25:51.984,00:25:55.354
depend on the fact that the
magical tool chain will give you
the bitstream that will

00:25:55.354,00:26:00.092
magically configure this
hardware thing to do what you
kind of told it to do through

00:26:00.092,00:26:04.863
you know a VHTL or a verilog.
>>So uh other resources, doesn’t
really matter. So what is

00:26:04.863,00:26:06.865
developer domain, right? The
developer domain is like you
specify the source code and the

00:26:06.865,00:26:10.302
attacker domain is the
bitstream. So how do you reverse
a bitstream? >>Well like before

00:26:10.302,00:26:17.109
that let’s go back. Right so as
an attacker you know you don’t
have access to any of the

00:26:17.109,00:26:21.680
information about the hardware
description language, you don’t
actually even know the- how the-

00:26:21.680,00:26:26.385
the various blocks are routed.
All you have is this you know
end the result bitstream like

00:26:26.385,00:26:32.224
literally a stream of bits that
is fed through the FPGA uh and
magically like I said you know

00:26:32.224,00:26:37.830
that bitstream makes the FPGA do
what you think it should do. Uh
but as uh an attacker uh all you

00:26:37.830,00:26:42.468
have is the bitstream so you
have to reverse engineer the
bitstream you know like you

00:26:42.468,00:26:46.905
would reverse engineer a piece
of binary with the machine
instructions and then figure out

00:26:46.905,00:26:50.943
you know what the logical
constructs is in that massive
bitstream. Without any

00:26:50.943,00:26:55.080
documentation from the vendor.
And again you know each vendor
will have a different format.

00:26:55.080,00:26:59.418
Right each type of uh class of
uh FPGA from the same form uh
vendor will have a different

00:26:59.418,00:27:04.122
format so the rules are
literally changing on you uh
underneath your feet uh and

00:27:04.122,00:27:09.127
that’s what we have. >>K. So um
so we wanted to reverse the FPGA
right and uh there is some

00:27:11.330,00:27:15.601
people who have tried it. JBITS
was 1 thing which uh Xilinx
released in 1999 it allowed you

00:27:15.601,00:27:21.073
to like change logic. Uh but
then this start uh stopped uh-
uh supporting it. Then Bil,

00:27:21.073,00:27:26.178
which it requires a netlist, it
was released in 2012 and the guy
did say that it’s very, it’s

00:27:26.178,00:27:31.483
like impossible to reverse
engineer. And then 2017 BITMAN
it also allows you to like move

00:27:31.483,00:27:37.122
logic, relocate logic. Uh. >>So
by reversing you know we mean
you take the bitstream and then

00:27:37.122,00:27:43.128
the goal for the most part is to
be able to re- recover the uh
hardware description language

00:27:43.128,00:27:48.333
and underlying logic that went
into generating that bitstream.
And once you have that, and if

00:27:48.333,00:27:52.471
you did that 100 percent
correctly, uh you might be able
to modify that logic to have it

00:27:52.471,00:27:56.675
do something different than its
original design. And then you
have to run the whole synthesis

00:27:56.675,00:28:01.613
tool right and regenerate the
bitstream, well, you know re-do
the optimization routing and

00:28:01.613,00:28:05.717
then regenerate a bitstream and
if you did that 100 percent
correctly, again without knowing

00:28:05.717,00:28:10.689
any of the rules about how those
bits are actually used uh for
that FPGA uh then you might have

00:28:10.689,00:28:14.927
a hope of you know taking
something like the bitstream
that we found in the FPGA that

00:28:14.927,00:28:18.530
we think is implementing the
trust anchor, and then
alternating its behavior in a

00:28:18.530,00:28:23.769
way that it might allow us to
bypass you know the trust anchor
capability. But the chances you

00:28:23.769,00:28:30.475
know people of doing this on
anything but a very simple FPGA
uh is very low. In fact I- I’m

00:28:30.475,00:28:35.581
not actually aware of anyone who
has successfully done that in
higher path on something like a

00:28:35.581,00:28:40.886
commercial uh you know like a c-
you know a real world commercial
uh application of an FPGA. Uh

00:28:40.886,00:28:43.021
you- on some commercial you know
bitstream. So- >>So let’s talk-
>>Chances of that working, very

00:28:43.021,00:28:45.023
low. >>Yeah let’s talk about the
p- I/O Pin. >>Alright so like
Jatin mentioned you know on the

00:28:45.023,00:28:48.760
FPGA you have uh complex logic
blocks alright so this is where
you know your hardware uh l-

00:28:48.760,00:28:53.765
description language with the
logic gets uh configured. Then
you have pins. Right pins are

00:28:59.438,00:29:03.108
literally those little metal
things that stick out from the
chip right that you wire to

00:29:03.108,00:29:07.846
other metal things on other
chips. So you know we’re humans
we like to design things on you

00:29:07.846,00:29:14.252
know uh few layers of PCB right
so the number of pins uh we want
to keep reasonable and the

00:29:14.252,00:29:19.257
largest uh you know uh so-
Spartan 6 uh FPGA has something
like 560- 76 pins. Right? So you

00:29:22.861,00:29:27.899
know that’s a lot but that’s a
very small finite number
compared to the logic blocks. Uh

00:29:27.899,00:29:32.604
which go up to about 200,000 and
in in each block you have a
whole lot of uh you know like

00:29:32.604,00:29:38.543
small- smaller logic blocks so
you know we have about no more
than 600 pins and we have

00:29:38.543,00:29:43.548
200,000 CLBs and you know
standard sort of uh approach to
FPGA reversing was to you know

00:29:46.451,00:29:50.622
recover all of the logic from
all the CLBs and we looked at
that and we said well, you know,

00:29:50.622,00:29:55.927
we’re not FPGA people. Like
we’re, you know, this is too
complicated! Right like this

00:29:55.927,00:30:00.899
probably won’t work, a lot of
smart people have tried and
haven’t really gotten far, but

00:30:00.899,00:30:04.336
why would, why don’t we look at
this? You know there are not
that many pins. So if we can

00:30:04.336,00:30:10.575
figure out a way to s- uh- p-
deterministically and reliably
uh manipulate the pin, who cares

00:30:10.575,00:30:14.413
about what the logic is doing?
You know if we can disconnect a
pin, right, and hook it up to

00:30:14.413,00:30:18.684
something else that we supply,
then it’s 1 of those things that
like if the FPGA falls in the

00:30:18.684,00:30:22.721
forest, like did it really
happen if no one hears it? No!
Right? Because uh you know if we

00:30:22.721,00:30:26.725
take a pin, disconnect it from
its logic uh and that pin is
still connected to the rest of

00:30:26.725,00:30:32.964
the circuit board, and then we
bypass that logic. Right so uh
and this is an actual plot of

00:30:32.964,00:30:37.969
the Spartan 6 Family, the
largest m- no- most dense chip
uh has yeah 576 pins and 150,000

00:30:41.006,00:30:45.477
logic blocks. Right so if you
put that you know actually in
scale, the graph actually looks

00:30:45.477,00:30:49.347
like something like this right?
So and this is not even to
scale. That curve grows really

00:30:49.347,00:30:55.153
fast so 1 of our intuitions at
the beginning is, forget about
reconstructing- reconstructing

00:30:55.153,00:31:00.926
the logic, uh, it's too hard.
Let’s look at you know uh a way
for us to reliably manipulate

00:31:00.926,00:31:06.832
the pin itself and see if we can
do that. >>So uh so uh you know
bitstream does come um

00:31:06.832,00:31:10.902
optimizations and there are no
optimizations in the IOB. This
is uh 1 of the logic uh

00:31:10.902,00:31:16.041
complexity we are looking at so
this is a shot of the 56 we
wrote and uh this is a very

00:31:16.041,00:31:21.246
small part of that logic. It has
like thousands of CLEs and- but
what is interesting is this

00:31:21.246,00:31:25.417
thing. Right like it this is the
binary presentation of the
bitstream. The top part

00:31:25.417,00:31:31.189
represents the complex logic
block which is implementing the
boolean functions and the 7 er-

00:31:31.189,00:31:36.928
yeah 6 of those are basically
the IOB blocks. Each IOB blocks
is 8 bytes in Spartan 6. And if

00:31:36.928,00:31:42.234
you uh can- can control if you
change a little bit in this, you
know like a byte here, you can

00:31:42.234,00:31:47.472
change the value of the logic,
uh of the IOB from 0 to 1 or 1
to 0. And you can ch- uh you can

00:31:47.472,00:31:52.244
also change these 8 bytes
represents the characteristics
of this IOB. So you can convert

00:31:52.244,00:31:57.249
it from uh uh you know like
input to output. By just
changing 1 parameter. The number

00:31:59.684,00:32:04.389
of rounds in the shadow 56, look
at the logic changing but the
IOB remains the same. And this

00:32:04.389,00:32:09.628
is the test. So the only diff
was actually in the complex
logic block, it was not there in

00:32:09.628,00:32:13.865
the IOB. And this is very
important. So as I said- >>Well
actually let- let’s back. So the

00:32:13.865,00:32:18.236
thing that you’re looking at is
an actual graphical rendering of
the actual bitstream generated

00:32:18.236,00:32:23.275
from this little mock example
that we created. Uh and if you
can go back 1 more slide, right

00:32:23.275,00:32:28.246
yeah. So the IOB doesn’t change
at all. It’s in very predictable
places. We know where the pins

00:32:28.246,00:32:33.118
are because they’re numbered you
know like 1 after another right
they are uh designed on the PC

00:32:33.118,00:32:37.923
board and they don’t get to
change because the PC board is
uh you know in hardware and if

00:32:37.923,00:32:44.229
we figured out like which 8 byte
construct um describes which
pin, then we should be able to

00:32:44.229,00:32:50.569
very predictably and reliably uh
you know change the behavior of
that pin uh and we have a much

00:32:50.569,00:32:57.475
more hope of doing that then
trying to do RTL reconstruction
on the logic block. >>K so as we

00:32:57.475,00:33:02.781
said like uh we can change the
output from uh to uh you know we
can assign the value 0 without

00:33:02.781,00:33:08.086
depending on the f- uh the
function F. Uh then similarly
output to 1 change output to

00:33:08.086,00:33:13.091
input, uh and the same thing
goes with the input. So uh what
we want to say here is that like

00:33:15.293,00:33:20.365
you know the vendor is not
vendor should not be dependent
on the obscurity of the FPGA

00:33:20.365,00:33:25.370
because as we saw RTL
reconstruction is hard but not
changing IO. So how do you

00:33:25.370,00:33:30.408
reverse a bitstream, right? We
see biststream as firmware and
it can go with unpack analyze

00:33:30.408,00:33:35.513
modify repack. And y- y- it has
you can talk about like it has
encryption but you can probably

00:33:35.513,00:33:40.452
do s- uh you know like uh side
channel analysis to figure out
the ES keys. You know you can do

00:33:40.452,00:33:44.522
fault injection to change to
basically skip this check. And
then you can also do photon

00:33:44.522,00:33:51.162
emission analysis. Uh so our f-
development board which we chose
to do all this research was

00:33:51.162,00:33:56.635
Spartan 6 uh LX45D. Uh uh it’s
the model of the spun. And how
do you do on the unpack if you

00:33:56.635,00:34:00.739
read the documentation you can
do the unpack. Uh which is
basically like find the sync

00:34:00.739,00:34:06.678
word, figure out which uh kind,
what kind of um uh spartan it
is, uh download it’s uh register

00:34:06.678,00:34:12.617
description language, parse it,
and uh find the registered FDRI
which specifies the hardware

00:34:12.617,00:34:17.789
circuit for boolean functions.
So uh then we move to analyze.
There are multiple types of

00:34:17.789,00:34:24.062
logic. Uh uh type 0 pa- uh
frames. The first 1 is the uh
complex logic block, frame which

00:34:24.062,00:34:30.669
and also it contains IOI uh umm
you know like how to configure a
BRAM and all that. Type 1 is

00:34:30.669,00:34:35.807
BRAM, the actual memory, what it
contains. Uh and the type 2 is
the IOB itself. And all of

00:34:35.807,00:34:40.779
these, which is really
important, is all of these are
serially laid out. So if you

00:34:40.779,00:34:46.985
figure out the range of- uh of
each of those then you can do
analysis and reversing to figure

00:34:46.985,00:34:53.792
out which uh pin is represented
by which bits. And you know um
the main important thing here is

00:34:53.792,00:34:58.830
like if you figure out the
device layout you can exactly
pinpoint which CLB is used which

00:34:58.830,00:35:03.301
BRAM is used and which IOB is
used. And each you know these
are details which you can find

00:35:03.301,00:35:08.306
on our uh GitHub. Uh and uh
major represents so it is uh 2
uh SRAM is basically a 2D uh RA.

00:35:11.676,00:35:17.082
And uh each row has multiple
columns, each column represent 1
resource. So you know like a CLB

00:35:17.082,00:35:22.354
a memory s- uh memory slice MCLB
will be 1 column, slice LCLB
will second column, BRAM will be

00:35:22.354,00:35:28.994
third column and like that. And
similarly each, each column has
its own area of rows uh- which

00:35:28.994,00:35:35.834
defines which flip flop is used
uh uh which mux was actually uh
encoded. So uh we- we actually

00:35:35.834,00:35:40.238
analyzed the bitstream and
created this really cool uh
visualization. My team has

00:35:40.238,00:35:45.210
really worked hard on this uh
tool. Uh as you can see it
specifies the resource

00:35:45.210,00:35:50.582
utilization uh which column is
used you can see this is for uh
the Mojo board uh which uses

00:35:50.582,00:35:56.821
Alex 9 it’s a really cool dev
board. And this represents the
ASR bitstream. So you- you can

00:35:56.821,00:36:01.926
see like which uh uh block which
resource represents the PCIE,
which resource represents the

00:36:01.926,00:36:07.232
LCLB, and so forth and so on.
>>So this tool, can you go back?
Is- is on GitHub right now. It’s

00:36:07.232,00:36:12.003
amazingly cool. You should go
totally check it out because uh
you know you can all that stuff

00:36:12.003,00:36:15.740
that Jatin said you can read
maybe 2,000 pages of Xilinx
documentation and try to figure

00:36:15.740,00:36:20.845
it out, great. Or you can use
this tool which has already done
that. And not only that, it will

00:36:20.845,00:36:25.483
show you like every- you can pin
point to any piece of the binary
and it will show you what that

00:36:25.483,00:36:30.522
binary- what what that chunk of
binary represents. Is it an IO
pin? If so, which pin is it?

00:36:30.522,00:36:36.594
Right? Is it uh like a CLB if so
like what is the raw data in
that CLB? Uh and for us you know

00:36:36.594,00:36:41.933
we after reading the- the patent
knew that ok the trust anchor
does a whole lot of magical

00:36:41.933,00:36:47.105
deity stuff right and then if it
doesn’t like what’s happening
after 100 seconds it will

00:36:47.105,00:36:51.509
literally assert the reset pin
on the Xeon processor and
physically reset the processor.

00:36:51.509,00:36:57.415
So that is how the mechanism we
think works so if we can find
out exactly which pin uh the

00:36:57.415,00:37:03.421
FPGA is using uh for that we can
do our thing and disable that
pin and make sure the trust

00:37:03.421,00:37:09.060
anchor literally cannot reset
that reset pin and then we win.
And uh the next thing is ok so

00:37:09.060,00:37:14.799
because the pins are set in- in
serially, in serial order uh we
know exactly what part of that

00:37:14.799,00:37:20.638
binary it ought to be so the
only thing that we need to know
now is which pin uh actually is

00:37:20.638,00:37:26.644
used on the FPGA which basically
involves tracing you know the-
the PCB on this router from the

00:37:26.644,00:37:33.618
CPU reset pin to the FPGA. Which
is very simple. >>Um we have
only 5 minutes left so I guess

00:37:33.618,00:37:37.255
we’re gonna go to the demo but
uh this is how the encoding
works. If you know the range,

00:37:37.255,00:37:41.459
figure out how- which pin
represent- which bits represent
which pin and um you know all

00:37:41.459,00:37:45.029
this code you can easily read.
Uh. >>Yeah we have a paper
coming out and we- we have a lot

00:37:45.029,00:37:49.067
of documentation on GitHub. All
the details are there. Check it
out. >>And uh 1 thing I would

00:37:49.067,00:37:53.805
want to say is that modification
is really easy uh they have like
implemented this 22 bit CRC for

00:37:53.805,00:37:59.577
single event upset. You know uh
and uh that is also reverse
engineered you guys can just

00:37:59.577,00:38:04.649
check out the GitHub but we have
to go. But uh you can also
disable the CRC. I haven’t tried

00:38:04.649,00:38:09.954
that but uh you can just disable
using this register, uh and then
I wanna sh- uh the demo

00:38:09.954,00:38:14.893
basically contains uh we have a
bitstream which enables those 4
pins and we gonna just turn this

00:38:14.893,00:38:21.599
pin off uh using the tool which
is kind of a present again. And
uh as Ang said, we basically

00:38:21.599,00:38:25.170
figured out which is the reset-
which pin is controlling the
reset pin and you disable that.

00:38:25.170,00:38:30.208
And really cool thing part about
this is, like er uh there is no
patch available. Once it is

00:38:30.208,00:38:34.612
allowed, we disabeld the
emulation of the FPGA so that
the Linux core actually can not

00:38:34.612,00:38:41.352
update the FPGA anymore. So
that’s pretty awesome. Uh and uh
ba- but- I also want to talk

00:38:41.352,00:38:46.191
about uh Rick uh found really
cool way as Ang was saying like
there are 600 pins in this case

00:38:46.191,00:38:52.597
there were 296 and you know our
uh automated extraction
bitstream tool who is not here

00:38:52.597,00:38:58.002
right now uh so he re- he came
up with the cool idea of JTAG
SCANCHAIN uh as soon as the fan

00:38:58.002,00:39:04.509
comes up uh he checks the state
of all of those 296 pins using
JTAG and we found 10 pins. And 1

00:39:04.509,00:39:10.448
of them was the 1. And you want
to- >>Sure okay so this is where
BRIAN comes in. You know we

00:39:10.448,00:39:15.587
after years of investing in this
uh we just couldn’t make it work
so we got an intern. His name is

00:39:15.587,00:39:20.258
Brian and I said Brian you touch
all the pins, you find out where
this thing connects. And he did

00:39:20.258,00:39:24.596
it! He’s great! Thank you Brian!
I mean without him this work
would have not been possible

00:39:24.596,00:39:28.600
because you know we need to
trace through like the 6 uh
layers with a PCB in order to

00:39:28.600,00:39:34.105
find you know which pin goes
from the reset pin to the FPGA.
Uh and then well you know he

00:39:34.105,00:39:39.777
touched the wrong pins so fail
fort [laughter] grows alright
[applause] eh which is fine. I

00:39:39.777,00:39:45.283
mean it was a very hard job so
uh but then you know we were
able to make some progress uh

00:39:45.283,00:39:50.922
and we were able to find that
pin right? Uh and the last
question is well, this is cool

00:39:50.922,00:39:53.791
but how are we gonna do this
remotely? You know if it’s not
remote, it’s not really

00:39:53.791,00:39:58.930
interesting, uh it- because if
somebody already has root uh on
the router then ok you can

00:39:58.930,00:40:04.235
change all sorts of stuff. So we
said well you know it’s 2019
finding a remote you know code

00:40:04.235,00:40:08.273
execution vuln and then
privileged esc- escalation has
got to be really hard. I mean

00:40:08.273,00:40:13.978
people have been looking at
Cisco routers for quite a long
time uh so man like do we- can

00:40:13.978,00:40:18.850
we even do it? Uh- >>Yeah so
they have a driver basically
that’s how they use it. And uh

00:40:18.850,00:40:25.189
we also did a lot of fuzzing on
all these protocols. Uh while
this was going on James come in-

00:40:25.189,00:40:28.159
>>Uh well you know so we’re like
man this is gonna be really
hard. Who knows if we’re ever

00:40:28.159,00:40:33.464
going to get this to work. And
then James who is sitting over
there said ok guys, I got root.

00:40:33.464,00:40:38.236
[chuckles] It was great and
then- >>LUA is easy. You know
like he found a command

00:40:38.236,00:40:42.540
injection vulnerability CSRF
vulnerability on the Cisco
routers uh which are patched

00:40:42.540,00:40:46.644
now. >>So let’s just point that
out. You know he found this kit
that’s remotely exploitable uh

00:40:46.644,00:40:53.384
you know command injection in
2019 oh a on Cisco IOS. So you
know for those who say command

00:40:53.384,00:40:57.722
injections are gone it’s like
you know it’s not true. Uh and
this was a very simple uh

00:40:57.722,00:41:02.694
vulnerability to exploit so man
uh this was great. So if you
couple any kind of code

00:41:02.694,00:41:07.932
injection on any part of the
attack surface of any Cisco IOS
uh you know platform or device

00:41:07.932,00:41:11.903
that’s affected by this, you can
immediately use that escalated
privilege and then update the

00:41:11.903,00:41:17.575
firmware uh and well update the-
the bitstream and then disable
the- the FPGA right the trust

00:41:17.575,00:41:22.847
anchor. So you can take a remote
exploit, couple it with this and
make permanent modification of

00:41:22.847,00:41:29.654
the hardware that is impossible
to undo uh using software,
again. So with that, let’s um-

00:41:29.654,00:41:34.659
and we broke some more, uh and
then final cost: 50,000 dollars.
Uh the fort is very large uh but

00:41:36.861,00:41:42.066
as a result we figured- finally
figured this out. So I’m gonna
let Jatin show the uh the 2

00:41:42.066,00:41:47.271
demos uh we’re gonna exploit the
Cisco router and then show how
this is done and then um we’re

00:41:47.271,00:41:52.276
gonna also show the- the Mojo
board demo. >>Uh ok so um yeah.
K. So this is what I want to

00:42:06.024,00:42:09.961
show right now this is booted it
takes like 10 minutes to boot so
I had to boot it. >>So this is

00:42:09.961,00:42:12.363
the output of this ASR 1001X
right here right it’s running
the latest firmware, well 1

00:42:12.363,00:42:14.365
minus the latest firmware,
because Cisco did patch this.
>>So what I want to talk about

00:42:14.365,00:42:16.367
here is that uh look at this
message. As soon as it boot, it
says initializing hardwa-

00:42:16.367,00:42:18.369
hardware. And uh that says
system integrity status, this
status is coming from the FPGA.

00:42:18.369,00:42:20.371
And the PRE-ROMmon which we
talked about earlier is reading
this status and printing it out.

00:42:20.371,00:42:22.373
So now we’re gonna go ahead and
exploit it. F*ck. [chuckles]
[laughter] >>Did we connect the

00:42:22.373,00:42:24.375
wire? >>We did. >>Yeah we did.
>>We connected to the wrong
port. Uh 1 second. >>No really?

00:42:24.375,00:42:26.377
>>Yeah. I have- nevermind. Uh
d*mnit. Sorry guys. >>We meant
to do this. This is part of the

00:42:26.377,00:42:28.379
demo. >>Okay well. >>Yay! >>Okay
it’s still going on. So what it
is doing right now is that it is

00:42:28.379,00:42:30.381
doing James’ hack uh getting the
root and then we t- uh took a
driver which was cracked RKO, I

00:42:30.381,00:42:32.383
don’t know why they wanted to
crack it but uh so we took- we
hijacked the driver, we

00:42:32.383,00:42:34.385
understood the- reverse
engineered the CPLE driver,
understood how to emulate uh how

00:42:34.385,00:42:36.387
the FPGA emulates the SPI uh
flash for the uh Linux uh OS and
then uh basically apply a

00:42:36.387,00:42:41.392
depatch. You only require around
15 bytes of patch to disable the
complete uh update and also

00:43:39.050,00:43:44.055
disable the reset. This is gonna
take some time, I wanna go ahead
and like do the module demo.

00:43:57.301,00:44:01.839
>>So just so you- we’re- what
we’re watching is a full remote
exploit of Cisco IOS uh followed

00:44:01.839,00:44:07.278
by a full modification of
bitstream bypassing trust anchor
and then permanently disabling

00:44:07.278,00:44:12.984
any future updates to trust
anchor via the FPGA with this
bitstream uh you know

00:44:12.984,00:44:16.554
modification. So that being said
right look at all- think about
all of the devices that’s

00:44:16.554,00:44:22.326
affected, this thing has been in
deployment since 2013 uh this
vulnerability is in all those

00:44:22.326,00:44:27.331
devices so if anyone finds any
code eh uh any kind of code
execution on any part of that-

00:44:27.331,00:44:32.470
that attack surface, uh there’s
a chance that this is not only
has affected your router but is

00:44:32.470,00:44:36.707
persistent uh to the point where
in order for you to get rid of
it you, you probably will

00:44:36.707,00:44:42.513
literally have to desolder a
chip right from your router or
your switch in order to test

00:44:42.513,00:44:47.618
even to see if you’ve been
exploited or not. Umm. >>Ok so
uh as you can see this is a Mojo

00:44:47.618,00:44:53.858
board um and yeah can you put a
light on? >>Yeah. >>So this is a
Mojo board. You will, in a

00:44:53.858,00:44:58.329
minute. And uh what matters is
like those 4 lights, right? And
uh those 4 lights are

00:44:58.329,00:45:03.834
representing 1 on those pins and
we’re gonna go ahead, run our
tool, which I’m gonna run again.

00:45:03.834,00:45:07.705
>>Well so right now you know the
lights indicate you know the
pieces of logic that we’ve put

00:45:07.705,00:45:12.276
in. Very simple to understand.
You know like 1, 1 thing says ok
uh you know pull, like connect

00:45:12.276,00:45:17.315
this to logic that always uh
makes the pin 0 or the LED 0
high. Right? >>So uh what it’s

00:45:17.315,00:45:22.053
doing right now here is that we
uh took the tool, we disabled
the pin, and I’m uploading it

00:45:22.053,00:45:28.259
right now, the rebug binary
which our tool did, uh the
GitHub link. And uh it’s gonna

00:45:28.259,00:45:33.264
go ahead and we’re gonna go can
you reboot the router? >>Yeah.
Alright. >>So let’s look at what

00:45:38.903,00:45:44.008
was the integrity status? Again,
this is on PRE-ROMmon, we have
full access now, FPGA cannot do

00:45:44.008,00:45:50.514
anything and here it is. We have
updated the FPGA, it still
booted. You cannot apply any

00:45:50.514,00:45:55.286
more patch. I have 20 SPI
flashes right now on my so I
have to like literally take it

00:45:55.286,00:45:58.389
out, update it. >>Ta-da! Look
this is where you clap! >>Come
on guys- >>Like, it’s very good!

00:45:58.389,00:46:00.791
>>This is really cool though.
>>Right so [applause] now we’ve
left the output right of this

00:46:00.791,00:46:03.961
thing saying that something is
wrong, right? In ROMmon so we
can demonstrate proof that okay

00:46:03.961,00:46:08.966
so the FPGA is doing its job, it
just physically can’t reset that
processor and now we can

00:46:12.937,00:46:17.575
actually patch ROMmon and
PRE-ROMmon to make this little
message go away. Right so but

00:46:17.575,00:46:21.045
for the purposes of the demo you
know we’re showing that this
thing is trying to cry out for

00:46:21.045,00:46:25.182
help, but no one is coming. We
win. >>And we’re gonna wait 100
seconds also while I show the

00:46:25.182,00:46:31.555
other demo. Uh so as you can see
uh there were 4 lights before
and we have disabled the 1 light

00:46:31.555,00:46:37.795
which was on the- uh at the end.
So again, try it out, play with
it, and uh what we want to-

00:46:37.795,00:46:41.065
>>Yeah and the reason why we
used the Mojo is that you know
this is a very inexpensive uh

00:46:41.065,00:46:46.237
piece of hardware that has you
know the- the Spartan FPGA
inside so uh if you look- take a

00:46:46.237,00:46:50.374
look at our tool, right, you
should be able to you know
modify this yourself and play

00:46:50.374,00:46:54.312
with all of the different
options of taking you know pin
high, pin low, input to output

00:46:54.312,00:46:58.949
and all of that good stuff. So
you know I think we’re uh about
out of time. >>Yeah this is the

00:46:58.949,00:47:04.822
impact. >>Well right. Cisco
routers are used a lot in a lot
of places. Um but so we do make

00:47:04.822,00:47:09.727
a lot of recommendations uh and
a lot more detail on the
technical side of all of this

00:47:09.727,00:47:14.899
and the implications of other
things that’s not just a Cisco
router, right. In our- in our

00:47:14.899,00:47:20.971
paper which is coming out in- in
a day I think or 2 days, uh at
usenix woot so you know we don’t

00:47:20.971,00:47:26.477
have time to talk about all of
the recommendations that we have
for uh you know improving FPGA

00:47:26.477,00:47:30.281
security right? Making it as- as
good as it can because
fundamentally this is something

00:47:30.281,00:47:33.718
that is stuck in hardware. And I
don’t believe that this is
something that can actually be

00:47:33.718,00:47:38.989
fixed via a software patch. So
please check out our website, uh
our code on GitHub, read our

00:47:38.989,00:47:44.428
paper, read the f*cking paper
right! And um thank you. >>There
are 20 more slides. You guys can

00:47:44.428,00:47:47.298
look at it later on. >>Yeah? I
don’t know I think we’re- we’re
getting kicked out. Oh! In order

00:47:47.298,00:47:52.236
to reward you guys for- for
coming to the right talk- I’m
gonna throw some T-shirts! I

00:47:52.236,00:47:56.140
mean who- who else is doing that
right? [crowd cheers] There you
go. You guys made the right

00:47:56.140,00:48:01.078
decision in life and you get
awarded for it. >>Yay! >> So
[chuckles] alright well anyway

00:48:01.078,00:48:06.083
thank you very much uh that’s
our talk. [applause]

