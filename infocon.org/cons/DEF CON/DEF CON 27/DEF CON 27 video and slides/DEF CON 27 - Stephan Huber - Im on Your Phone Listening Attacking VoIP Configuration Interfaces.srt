00:00:00.200,00:00:04.538
>>So umm, without further adieu
uh we have uh Stephan Huber and
uh Philipp Ris Ros uh Roskosch

00:00:09.676,00:00:16.350
[speaker laughs] [off mic
comment] yeah yeah and umm
please give him a warm welcome

00:00:16.350,00:00:21.355
[audience applause] >>Okay, so
hello to our talk about umm VoIP
configuration interface

00:00:23.690,00:00:29.663
security. My name is umm Stephan
I am a security researcher at
the Fraunhofer Institute of

00:00:29.663,00:00:35.736
secure information technology
and I am working umm there as a
researcher for study dynamic

00:00:35.736,00:00:40.741
code analysis and umm and during
my spare time I am working on
IOT stuff and with this talk we

00:00:42.910,00:00:49.149
want to share our new knowledge
or experiences. I am also one of
the founders of a hacking team

00:00:49.149,00:00:55.756
called teamSIK and it's a small
hacking group uh from
Fraunhofer. So, Philipp. >>Thank

00:00:55.756,00:01:00.894
you Stephan, hello my name is
Philipp. I am also working at
the Fraunhofer SIT in the secure

00:01:00.894,00:01:06.733
software engineering department
and my main foc, my main, my
reach, my focus research is

00:01:06.733,00:01:11.738
static code analysis and IOT
vulnerability de- detection and
I'm also a member of teamSIK.

00:01:15.976,00:01:20.647
First of all some
acknowledgements to Alexander
Trout and Michal Troeger and

00:01:20.647,00:01:26.153
Andreas Wittmann who supported
us within this project. Umm,
short announcement we we brought

00:01:26.153,00:01:31.358
some beer as we are from Germany
and it's not the first time for
us. And we always brought beer

00:01:31.358,00:01:35.228
if you have any questions or
want to talk to us, you are
welcome to join us after the

00:01:35.228,00:01:40.233
talk. So in recent years we have
several projects which we also
presented here at Defcon yo you

00:01:45.305,00:01:50.310
might check it out on our web
page and after the last year,
years Defcon we, we wondered how

00:01:52.446,00:01:57.451
do we get here this again and we
were thinking about a topic or
a, a research subject with a

00:02:00.487,00:02:06.793
wide distribution a complex
software which is a read readily
accessible because you find bugs

00:02:06.793,00:02:12.199
and nobody can exploit it,
nobody cares about it. And we
came up with voice over IP

00:02:12.199,00:02:19.006
phones, so the distribution I
mean it's in every office on
every desk in every business so

00:02:19.006,00:02:24.578
the distribution is covered. On
all of these phones runs a web
server for management and

00:02:24.578,00:02:29.583
configuration purposes, which is
complex enough to build in bugs,
and, so this point is also

00:02:32.586,00:02:37.591
covered, and the last point is
the accessibility. I think in,
in your business the network is

00:02:39.993,00:02:44.898
configured well and the works
phones are in a separate network
and not accessible by any, any

00:02:44.898,00:02:50.170
other of the participants of the
network and of course it's not
accessible over the internet.

00:02:50.170,00:02:55.175
But if, you are familiar with,
with how some companies handle
their, their network you you

00:02:59.046,00:03:05.752
might know this state, where
the, everything is put into 1
network and the guests, the, the

00:03:05.752,00:03:11.858
regular users and sometimes also
the people from the internet can
access all of the devices. So

00:03:11.858,00:03:18.331
the 3rd point is also covered,
these phones are accessible
from, from a lot of people and

00:03:18.331,00:03:23.336
also from a lot of attackers. So
this, talk, uh is structured as
follows, I'm going to give a

00:03:26.139,00:03:32.512
short background about these
phones, then give a IOT hacking
1 on 1 to, to show you how we,

00:03:32.512,00:03:38.552
find our bugs and then I will
present all the, all, some er
findings and then I will

00:03:38.552,00:03:43.557
conclude the talk. Starting with
a background. Each of those
phones runs a or has a ARMS or

00:03:48.795,00:03:53.800
MIPS CPU inside and on top of it
runs a Linux. There you have
some of in it the basic process

00:03:56.069,00:04:01.575
on watch dog the sub daemons
for, for actual voice
communication, and then finally

00:04:01.575,00:04:06.580
the web server, which is used to
configure all of this. And this
web server is not today over

00:04:08.849,00:04:13.854
target. The methodology. We went
figuring out these bugs, we we
first set up the web phone as

00:04:20.894,00:04:27.334
regular user or admin would do
so, the web server running
afterwards we attach a HTTP

00:04:27.334,00:04:33.406
Proxy and just clicking around
and see if we find some bugs in
the, by just, by uh just

00:04:33.406,00:04:39.780
observing the traffic. If you
don't find any more there, we
just extract the firmware, to

00:04:39.780,00:04:46.386
err, to form some static
analysis, for, for instance some
secrets or, or some, some

00:04:46.386,00:04:53.126
scripts which we can easily
exploit. In the end for, for
developing real exploits and

00:04:53.126,00:04:58.832
emulation comes in handy and
other dynamic analysis tools,
which, which are good for

00:04:58.832,00:05:03.770
finding the real, the real
interesting vulnerabilities.
There's 1 exception when, when

00:05:05.872,00:05:11.444
you luckily you find a, a way of
injectecting dynamic analysis
tools directly on the phone you,

00:05:11.444,00:05:16.449
so you save the step of
emulation. Here are, here's an
overview about the tools we'ved

00:05:19.686,00:05:24.724
used, you can check it out later
in the, when, when the slides
are available online. Umm I

00:05:24.724,00:05:29.729
won't go through them detail
here. So the first step what you
want to do after you, you did

00:05:32.632,00:05:37.737
the, the web pen testing you
want to grab the firmware and
this firmware access is not

00:05:37.737,00:05:42.742
always this easy. Umm, first of
all it's out of scope for us to
desolder chips and and use

00:05:46.379,00:05:51.384
complex and expensive hardware
setups because we are software
people. We, if we need to do

00:05:51.384,00:05:56.389
this we, we skip, to another
phone. So what did we do. First
we check the website from the

00:05:58.925,00:06:03.330
vendor or manufacturer, to see
whether we can download the
complete firmware image from

00:06:03.330,00:06:09.869
their, so when you lucky you
done there, sometimes you only
get diff or some patches to the

00:06:09.869,00:06:14.541
page image already running on
the phone or it's encrypted and
you cannot do something with the

00:06:14.541,00:06:19.946
update package from the website.
Then another way is to, to
trigger the update from the

00:06:19.946,00:06:25.418
phone, if this function is
available and if you have kept
the traffic you might be, might

00:06:25.418,00:06:30.423
be happy or luckily and you can,
can get the, the firmware from
there. But what we did mos-most

00:06:32.559,00:06:36.796
of the times was getting the
firmware directly from the
device because it's located

00:06:36.796,00:06:41.801
there,and, so you can, can grab
it from there. We used some,
some cheap hardware adapters

00:06:44.704,00:06:49.709
like the JTAGulator or the bus
pirate to connect directly to
the the chips. And this for

00:06:52.946,00:06:59.920
instance can be done as , as I
show you hear, if you find a
chip on the device you may,

00:06:59.920,00:07:06.092
check the data sheet of this
chip and see which parts are
opens up are provided and if you

00:07:06.092,00:07:11.097
find for instance the SPI
interface you can connect the
bus pirate to it, which looks

00:07:11.097,00:07:16.102
like this on the Akuvox and then
you can directly read from the
chip over the interface by using

00:07:19.005,00:07:25.545
several tools. Here's an example
of the flashrom tool, which we
used to dump the firmware, after

00:07:25.545,00:07:30.550
the dumping the firmware, you
can, can analyze as you wish.
For instance as with binwalk you

00:07:30.550,00:07:37.524
can extract all the data. As you
see from the button this, it's
not the most stable connection

00:07:37.524,00:07:44.264
as every output produces,err,
every dump produces a different
output, but in the end it did

00:07:44.264,00:07:49.269
the job pretty well for us.
Another way is the UART
interface, if you find the UART

00:07:51.905,00:07:57.177
connection on the, on the phone,
you may connect the JTAGulator
as you can see here in the

00:07:57.177,00:08:02.115
picture. And then you can see
what happens. Sometimes you get
connec er get access to the

00:08:04.784,00:08:10.457
bootloader which has a minimum
command set available and if you
get lucky you can dump the flash

00:08:10.457,00:08:15.295
memory from there with the dump
command. This command is not
always available, but when when

00:08:15.295,00:08:21.167
you lucky, you get your firmware
from there. But if you more
lucky, you get directly into the

00:08:21.167,00:08:26.172
root shell and have access to
all the data on the chip with
this shell. The 3rd way is a

00:08:30.377,00:08:36.416
vulnerability inside the, the
web interface. For instance if
you find a command injection you

00:08:36.416,00:08:42.355
may start, tell a daemon to
find, which allows to a
connection to the, to the phone

00:08:42.355,00:08:48.528
over uh over telnet and as it's
not intended to run sometimes
there is no authentication and

00:08:48.528,00:08:53.533
you get a root, root shell
directly. And then you can dump
the, the data. As the software

00:08:57.270,00:09:02.742
inside the work phones are
limited and not made for uh
dumping all the stuff. You need

00:09:02.742,00:09:07.747
sometimes uh some tricks to get
data on the phone for instance
additional tools or you need

00:09:09.883,00:09:16.055
some tricks to get data off the
phone after you, you've found
whats, whats, useful what you

00:09:16.055,00:09:21.060
want to investigate further.
Here's and overview about some
commands we used, you can check

00:09:21.060,00:09:26.065
it out, in the slides later, we
won't go into detail here. The
last step of the hacking 101 is

00:09:28.968,00:09:33.973
the emulation. Once you got the
firmware you, you want to run it
in a emulator to find the real

00:09:36.075,00:09:42.982
interesting vulnerabilities and
for doing this, there are
multiple ways. We focus on

00:09:42.982,00:09:47.987
system mode emulation, which
looks like this, we getting a, a
QEMU emulator with a ARM or MIPS

00:09:50.890,00:09:57.530
architecture and putting the
raspbian on top of it. Inside
the raspbian we put a CHroot

00:09:57.530,00:10:03.169
environment with all the uh data
from the firmware we need to, we
need to run up the web server.

00:10:03.169,00:10:08.174
And afterwards we attach our
dynamic analysis tool, for
instance a gdb server or gdb

00:10:10.977,00:10:15.982
directly or S trace umm in order
to analyze the web server, umm
almost all the time you need to

00:10:19.352,00:10:25.558
patch the binderies you execute
as, they looking for some
specific umm hardware interfaces

00:10:25.558,00:10:30.463
which are only available on the,
on the phone, but not on the
emulator. You can do this in

00:10:30.463,00:10:35.468
multiple ways like hooking or,
or patching with gdb you need to
a little bit, umm, err, umm, ya,

00:10:40.807,00:10:45.812
uh, there are multiple way of
doing it. Umm, now the fun part
I will go through some findings,

00:10:49.516,00:10:54.521
and starting with denial of
service. Eh if you mention these
phones are located in critical

00:10:57.423,00:11:03.263
infrastructures or hospitals and
a denial of service, ca, can
cause, umm pretty heavy damage

00:11:03.263,00:11:08.268
or can, can cost lives so denial
of service is a, a, uh is an
attack you want to avoid. So the

00:11:12.605,00:11:19.245
first thing we, we've found is
by, by nmap scanning the meter
phone you, you could cause a

00:11:19.245,00:11:25.251
denial of service for around
half an hour. So the, the
hardware is so, cheap and so

00:11:25.251,00:11:30.924
limited that the nmaps can for a
few seconds can is enough to
cause a denial of service. So

00:11:30.924,00:11:37.263
you maybe want to spend a little
more money on your, your
hardware inside your phone. Then

00:11:37.263,00:11:43.002
the more interesting is the, is
this request at the Cisco phone
can anybody guess what's the

00:11:43.002,00:11:48.007
problem here? Right, it's the
double code in the debt request
which leads to assertion fail

00:11:50.810,00:11:55.815
and causes the phone to reboot,
this, this denies the service
for around 5 minutes, but then

00:11:57.984,00:12:02.956
you can resend the, the request
again and the phone is down
forever. Whether this is good or

00:12:02.956,00:12:07.961
bad handling everybody can
decide on its own, s, uh I you
avoid harder damage like remote

00:12:10.063,00:12:15.068
excursions but ya its a denial
of service attack. Afterwards we
looked at known vulnerabilities,

00:12:18.037,00:12:24.410
like a CVE from 2017 which
caused out of bound reads in the
open in the SSLl library which

00:12:24.410,00:12:30.183
is used for the HBS connection
for the web interface and we
found 4 phones which we were

00:12:30.183,00:12:35.755
vulnerable to this, and and in
some cases the phone reboots and
in other cases just the web

00:12:35.755,00:12:40.660
server crashes, but in any case
you should update your, your
libraries or your third party

00:12:40.660,00:12:45.665
libraries to save you trouble in
this, in this area. So another
nice category is the bad crypto

00:12:49.902,00:12:56.676
stuff it's always present I
think in every talk of us.
Starting with the Akuvox. Awae

00:12:56.676,00:13:02.548
with this phone yu you can, can
export all your, your
configuration settings including

00:13:02.548,00:13:08.655
the sib credentials and the
credentials for the, for the
umm, web interface. And they

00:13:08.655,00:13:14.360
claim its encrypted as you can
see here it’s not plain text,
but is it really encrypted?

00:13:14.360,00:13:20.433
First thing we did is like
checking whether if its base 64
encoded which it isn't. So maybe

00:13:20.433,00:13:25.905
it's really encrypted. So we
investigated further and
extracted the Firmware and found

00:13:25.905,00:13:30.910
the implementation for, for the
decryption of these, these
credentials and we were, we

00:13:33.379,00:13:38.751
found a phone aes decrypt
method, and we were thinking of
all the ecrypt lectures and were

00:13:38.751,00:13:45.491
able or we were curious about
auditing the Aes encryption from
them. But it turns out it’s a

00:13:45.491,00:13:50.496
safe int encrypto it's a simpler
substitution and it’s no AES at
all. And so maybe we can break

00:13:53.566,00:13:59.138
this, this crypto, but it turns
out you don't need to break the
crypto, you get the key for

00:13:59.138,00:14:04.077
free. Because it is provided in
the firmware image, and so it’s
not a secret. So coming to the

00:14:09.215,00:14:14.220
classic web attacks. The classic
XSS, I mean by adding my
favorite contact name, into the

00:14:17.290,00:14:22.295
audio codes. I get this, just
for completeness I mean we found
it on several phones. Umm,ya

00:14:24.831,00:14:29.836
input generalization is a thing.
Keep doing it. Far more
interesting is the Gigaset

00:14:33.239,00:14:39.078
Maxwell Basic, where, we've
found 2 interesting
vulnerabilities, first of all

00:14:39.078,00:14:44.083
information leakage, by looking
at the, the traffic. When, when
asking this end point, it, it

00:14:49.021,00:14:55.795
returns to different messages
and what does it actually means.
The attacker can ask the phone

00:14:55.795,00:15:01.901
whether the admin is currently
logged in or not. I mean that's
not nice, but it's not that bad

00:15:01.901,00:15:08.040
right? Umm, I mean, you just
know that the admin is logged in
but it's not, not state of the

00:15:08.040,00:15:12.612
art. We digged a little bit
deeper and found the imple
implementation for, for this,

00:15:12.612,00:15:17.617
inside the [inaudible 15:15]
umm, I will explain it in detail
here. Normally the admin logs in

00:15:19.685,00:15:24.857
a session token generated
storaged for the, in the
database. To check the further

00:15:24.857,00:15:31.430
requests from the admin, whether
he knows the session token. Even
if, even if the attacker asks

00:15:31.430,00:15:36.469
the phone something, he doesn't
know the session token, so he
sends an invalid token and what

00:15:36.469,00:15:42.175
the phones does, right here is,
is checks whether the currently
logged in user is able to use an

00:15:42.175,00:15:47.180
admin and w-with the token, uh
just provide us, is equal to the
token storaged in the database.

00:15:49.215,00:15:53.886
And then it tells you that the
admin is logged in. Which is
somehow weird because why would

00:15:53.886,00:15:59.392
you tell somebody with an
invalid token that the admin is
logged in. So we digged a little

00:15:59.392,00:16:05.097
bit deeper, we extracted the
firmware as you might have
guessed already. It's a Ph php

00:16:05.097,00:16:12.038
implementation, so you can read
through the implementation
pretty well. And we find, found

00:16:12.038,00:16:18.978
how the session or the
authorization process is
handled. For every request you

00:16:18.978,00:16:25.351
provide a, a session token and
then it it checks whether a user
E is behind this session token

00:16:25.351,00:16:31.157
and if the session token is
credited a 0 you are allowed to
do whatever you want to do. This

00:16:31.157,00:16:36.162
is not nice but it’s somehow ok.
So we digged a little bit, more
deeper and found the following

00:16:40.032,00:16:45.037
the Post parameters functions is
umm used for, for setting, all
the, uh several settings, and

00:16:48.507,00:16:53.512
one of the settings are the
admin password. So better,
secure this method. It, it

00:16:56.182,00:17:02.488
starts as the last method, umm,
it checks with the A user ID is
behind the session token you

00:17:02.488,00:17:07.493
sent. And it provides 0 if the
session token is invalid. And
then it sets the, the para or

00:17:11.564,00:17:17.536
the settings you want to give,
so changing the password is
possible for nearly everybody.

00:17:17.536,00:17:22.541
Except the, the admin needs to
be logged in as these post
parameters function is all only,

00:17:24.710,00:17:29.715
only executed when a user is
logged in. And this I will show
you, in a demo. So on the left

00:17:40.059,00:17:45.831
top you will see the victim, and
at the bottom you will see the,
the script,from the attacker

00:17:45.831,00:17:52.071
just checks whether the admin is
logged in, the first
vulnerability and then, if it's

00:17:52.071,00:17:57.076
logged in, it sends the, the rig
request for changing the, the
password. Now the script is

00:17:59.345,00:18:04.283
running and it sees that admin
is not logged in. Now admin logs
in with this a 3 digit password.

00:18:06.319,00:18:11.324
And the script realises that
somebody logged in. And he
directly changes the password.

00:18:15.194,00:18:20.199
On top you will see, that the
admin is the real admin, by, you
will see it right now, [speaker

00:18:30.476,00:18:34.714
laughs] interesting is also,
when changing the password, you
don't need to know the old

00:18:34.714,00:18:39.719
password, and now the admin logs
out and the newly set password
is 1 2 3 4 5 6 and the attacker

00:18:41.854,00:18:46.859
can, can log in and you see
that, and the change enter
password enter phase is the

00:18:49.528,00:18:54.533
admin.[audience applause] So
that was it from my side.
Stephan will continue with the

00:19:03.209,00:19:08.214
rest of the findings. >>Ok,
thank you Philip. So at first a
short introduction about path

00:19:10.383,00:19:15.788
reversal who is not aware about
this umm attack from this,umm
imagine you have the web server,

00:19:15.788,00:19:22.194
web server can provide with web
application, can provide some
files or can write files by

00:19:22.194,00:19:28.601
uploading and for this file
handling can request this file
name is uh send it to the

00:19:28.601,00:19:33.773
applications, now imagine you as
an attacker uh change the file
name and for instance umm,

00:19:33.773,00:19:39.178
preplan some relative path
information if the web
application does not verify this

00:19:39.178,00:19:44.683
information escaping or
sanitizing it will be able for
an attacker to escape from the

00:19:44.683,00:19:51.424
default umm,umm web server
folder and can get access to, to
different folder uhm on the

00:19:51.424,00:19:57.530
system. Such type of
vulnerability we found on the
Yealink device so can see here

00:19:57.530,00:20:03.869
when we provide a few uhm
relative path information and
the ETC shadow file to the file

00:20:03.869,00:20:08.874
parameter. The device responds
with the hash of the, umm the
route user. This is possible

00:20:11.811,00:20:17.683
because of 2 reasons. The first
1 umm, the input value is not
verified and the second reason

00:20:17.683,00:20:23.789
is that the web server is
running as, as root, as we saw
most, we’ll see the most web

00:20:23.789,00:20:30.229
services are running on root on
our phones. But this is not
enough, we currently we can just

00:20:30.229,00:20:36.702
read 41 to reach is now somehow
to get uhmm remote code
execution, so we have to, to

00:20:36.702,00:20:41.707
upload files. Uhmm 1 feature on
the device is for uploading
files is the ringtone upload so

00:20:43.809,00:20:50.716
our idea was now to, to use or
override some umm some script
which is umm, to, oh you don’t

00:20:50.716,00:20:57.690
see the full text, sorry, don’t
know why, uhmm eff, the idea was
now to, to override some, some

00:20:57.690,00:21:03.362
scripting file which will start
the reboot, and the scripting
file contents then our code we

00:21:03.362,00:21:08.367
want to execute. But the problem
was, uhmm, the the upload
feature umm the upload, the

00:21:10.903,00:21:17.476
overriding of the script file
failed. Because the uh the
application verifies the file

00:21:17.476,00:21:22.081
content says ok this is not a
script file, you have to upload
some audio file, and that’s why

00:21:22.081,00:21:27.086
overriding of the start script
failed. But umm, when we
analyzed the software we saw

00:21:29.355,00:21:35.294
that the, uhmm applications just
verifies a few byte of the file
header. What we did is, that we

00:21:35.294,00:21:41.400
take a few bytes of the file
header, prepended to our script
file and then we were able to

00:21:41.400,00:21:47.339
upload our file. Uhmm then the
file is executed or the script
is executed of course the first

00:21:47.339,00:21:52.344
3 lines are umm recognized as a
error but eh operating systems
do still continue and our script

00:21:54.847,00:22:01.320
umm, will be executed. And so
with this way, we get umm files
access and code execute

00:22:01.320,00:22:06.325
arbitrary codes again as root on
the device. Then we were
scanning or looking for some

00:22:09.028,00:22:15.501
kind of back doors on the
phones. We scanned the Akuvox
box device and saw ok there is a

00:22:15.501,00:22:21.540
telnet port open so umm the
first question was that was it
running by default, can we turn

00:22:21.540,00:22:26.178
if off, or , or why is it
running, umm, we don’t know why
it’s running but you can not

00:22:26.178,00:22:31.250
turn it off, there’s no
configuration on the web
interface, nothing, so this

00:22:31.250,00:22:38.190
thing is running by default. The
other thing now is to get
somehow access, we need, uhmm

00:22:38.190,00:22:43.195
the password. Umm, the firmware
image for this device is not
public available we we looked in

00:22:46.298,00:22:52.471
different forums or on the, the
website, it’s Linox image but it
is not, umm public available.

00:22:52.471,00:22:57.476
But as Philip uh already
explained we get some image dump
by SPA, and then we extracted

00:22:59.545,00:23:05.251
the file system, here you can
see how the password hashes and
when you a bit aware of password

00:23:05.251,00:23:11.390
hashes, you will realize this is
a DS cru protection and the
problem with DS cru is that the

00:23:11.390,00:23:16.395
maximum password length is 8. I
have an old GPU on my uhmm,
office computer round 4 or 5

00:23:18.998,00:23:24.870
years, and took me 30 days to
crack it. So you can imagine if
you have a newer or modern

00:23:24.870,00:23:29.875
device you can crack this in a
few days. And then you know the
root password or the admin

00:23:29.875,00:23:34.880
password, you can log in to this
device, by design. Command
injections, another type of

00:23:38.617,00:23:45.090
vulnerability, we found that
this type of vulnerability on 7
or 8 different phones. Uhmm, at

00:23:45.090,00:23:52.031
first a short explanation on how
it’s working. Uhmm few, few of
the or the most phones providing

00:23:52.031,00:23:58.404
the web interface some, some
diagnostic tools interface for
instance, umm ping or enter an

00:23:58.404,00:24:03.208
IP address and then they phone
the ping, the IP address in the
network, this should verify that

00:24:03.208,00:24:08.380
the, the device is, is connected
and working. So you enter the IP
address, the IP address is

00:24:08.380,00:24:14.820
forwarded to the web application
and the web application con
constructs a command and this

00:24:14.820,00:24:21.393
command is then forwarded to
LIPC system function and
function is executing our

00:24:21.393,00:24:28.167
command. So here you see our
ping, so what will now happen
for instance if you append

00:24:28.167,00:24:34.807
additional comments with a semi-
colon and there is no
sanitization, you can see, uhmm,

00:24:34.807,00:24:39.812
the input is forwarded again to
our application. Combined to 1
comment and executed, so here

00:24:42.247,00:24:48.754
you will see at first we will do
zero pings because the minus c
zero says zero pings then with

00:24:48.754,00:24:53.759
the semi colon the command is
finished the we execute ALS and
the rest is commented out uhmm

00:24:55.861,00:25:01.333
is not executed anymore. So this
is the study of command
injection we found a lot of this

00:25:01.333,00:25:06.338
type of vulnerability on the
devices, we will just explain 1
here of our findings. So we had

00:25:08.540,00:25:14.880
audio coded devices and there,
umm we can execute the telnet
daemon again via command

00:25:14.880,00:25:21.687
injection and then try to get
some access via telnet. The
problem here is you can see you

00:25:21.687,00:25:27.192
need a basic authentication so
when you don’t know as the
attack of credentials can be a

00:25:27.192,00:25:32.898
problem, later we will umm show
a few information from our study
from the most devices you can

00:25:32.898,00:25:39.738
try decode from the admin and it
works. But this is not umm, the
intention of the attack. We also

00:25:39.738,00:25:44.743
tried somehow to, to bypass the
authorization but we uhmm we
failed. So we s-searched another

00:25:47.446,00:25:53.786
way to get somehow access to the
device. And what we saw was
umm,there is also a change

00:25:53.786,00:25:58.757
password, a change password
feature on the phone, here you
see the, the request and what

00:25:58.757,00:26:04.062
you see, is umm, ya you see
nothing. The first thing here is
there is no authorization header

00:26:04.062,00:26:09.835
here, so this means everybody
can trigger this request to
change the password, but then

00:26:09.835,00:26:16.208
you can argue ok, the attacker
still has to know the old
password. But same story you see

00:26:16.208,00:26:22.181
we have a parameter and uh
admin, admin this is our user
then we have a new password then

00:26:22.181,00:26:27.453
we have to verify the new
password, this means eh you
don’t have to know the old

00:26:27.453,00:26:33.492
password. So now as an attacker
you can change the password of
every user and we also have a

00:26:33.492,00:26:38.464
command injection where will
have to know the password so
when we combine this, we can say

00:26:38.464,00:26:44.503
everybody can change a password
and you can trigger remote code.
We will show this in a short

00:26:44.503,00:26:49.508
demo. So here you will now see
now the original admin, hes
logging in. to verify his, the

00:26:54.913,00:27:00.953
original admin password you see
here it’s from the umm,
authorization request, it’s base

00:27:00.953,00:27:05.958
64 encoded you see the original
admin password is superpass, and
now we log out. As you can see

00:27:10.562,00:27:15.567
our attacker script. The
attacker script will eff at
first change the password

00:27:18.070,00:27:23.075
superpass to pass and then the
second step, it will execute our
command injection with the new

00:27:26.011,00:27:31.016
set password. It will show that
the new password pass looks base
64 encoded in this way and you

00:27:33.418,00:27:39.758
see this is matching our
request.[audience claps] ya
[speaker laughs] It’s not

00:27:39.758,00:27:44.763
finished yet, give me a second,
so now we try to trigger our
exploit,umm.eh,umm, on the

00:27:47.399,00:27:52.404
device by umm at first we have
to veri to verify you see there
is no telnet running so there’s

00:27:55.007,00:27:59.945
no telnet service, so then we
execute the exploit. So password
changing, the ping, the login

00:28:06.952,00:28:12.624
admin password is pass, and
again we get a root shell
because the service is running

00:28:12.624,00:28:17.629
again as root.[audience
applause] Ok, thank you.
[audience applause] Sometimes

00:28:20.866,00:28:27.506
sh*t happens and yeah sh*t
happens brings us to stack based
buffer overflows, we found on

00:28:27.506,00:28:33.579
different devices, buff
overflows, umm in our abstract,
we announced some arm based, but

00:28:33.579,00:28:40.052
we also have some MIPS devices
and MIPS is a, a bit more rare,
so we decided to explain, the

00:28:40.052,00:28:46.124
MIPS attack. Here you see one of
the buff overflows, I have to
mention this is not err, prehalt

00:28:46.124,00:28:51.363
overflow you have to know, you
have to be at least a user, but
then you can use the buff

00:28:51.363,00:28:56.368
overflow to umm, escalate your
privileges to get root. Uhmm
either way this bug or s

00:28:59.237,00:29:04.476
vulnerability is not fixed. Uhmm
here you see again to change
again the password, there is a

00:29:04.476,00:29:10.616
set security password command
and the internal code you see on
1 side we have a target buffer,

00:29:10.616,00:29:15.621
with 32 bytes, and our input is
forwarded as a parameter and
used in a copy to comment string

00:29:18.023,00:29:23.462
function. You can imagine this
sounds like already like some
string copying and when we look

00:29:23.462,00:29:29.201
into the implementation of the
comment string function you see
this is a simple wire loop, just

00:29:29.201,00:29:34.206
writing each criteria into our
buffer, and the loop only stops
a bracket or on a , a null

00:29:36.575,00:29:41.913
value. So it’s, it’s a buff
overflow you find it in each
,uhmm, don’t know college

00:29:41.913,00:29:48.654
textbook. And umm here you see
an expert of the gdb or
debugging you see, we can

00:29:48.654,00:29:54.960
control 2 registers, the most
important is the return address.
So we can control their program

00:29:54.960,00:29:59.965
counter jump to our code, and I
will explain a bit more now how
we get our final exploit. So 1

00:30:03.268,00:30:09.708
challenge when you try to
exploit such a devices, how do
you bypass mitigations like NX,

00:30:09.708,00:30:16.682
ASLR and so on, it was very
easy, there is no mittication.
Then we were a bit lazy and at

00:30:16.682,00:30:22.220
first decided ok, we don’t want
to write a MIPS shellcode by
hand, because I’m not a MIPS sky

00:30:22.220,00:30:29.194
and it would be too hard, so we
audioed generate shellcode. The
next step is, we have to find

00:30:29.194,00:30:34.933
the uhh, the, the stack address
on,on ARIM exploration you
simply make the, or use the

00:30:34.933,00:30:41.039
branch to stack point the gadget
or on E 86 you make a jump to
ESP, best of my knowledge there

00:30:41.039,00:30:46.044
is, is not such a, a gadget, in,
in err, MIPS, so, so, we have to
build it simulate by other

00:30:49.247,00:30:55.020
gadgets, and we found 2 useful
gadgets, the first 1 simpular
user app operation to write the

00:30:55.020,00:31:00.592
stack pointer, to to address an
addui, then we jump to our
second gadget this moves the

00:31:00.592,00:31:05.597
addiu to T9 and then we can jump
to T9 where our address of our
stack pointer plus 32 byte of

00:31:09.101,00:31:14.106
set, so, so with this two
gadgets we simply find our stack
where our shell code will be. We

00:31:17.209,00:31:22.280
also have some how to handle the
bad characters. This means, umm,
when our shell code contains

00:31:22.280,00:31:26.818
this kind of cari characters
this will not be written
completely to the stack. So we

00:31:26.818,00:31:33.592
have to somehow encode or
oviscate them. So for this we
use simply umm EX encryption or

00:31:33.592,00:31:40.132
encoding umm we took this idea
from a good paper, it’s from Yun
Young from vintage point, he

00:31:40.132,00:31:45.070
wrote write a very good write
paper about MIPS exploration so
if you are working in this field

00:31:45.070,00:31:51.610
it’s worth to read it. And with
all this, we can now decide our
final exploit, you see the

00:31:51.610,00:31:56.615
payload structure we have a few
bodies pending, our 2 gadgets th
the decoder and the shellcode.

00:32:00.118,00:32:06.591
But there is another challenge,
especially on MIPS and sometimes
on ARM. So here you can see this

00:32:06.591,00:32:11.897
would be our stack lay out, you
see the decoder and our
instructions, here you see to,

00:32:11.897,00:32:17.402
to add operations, which would
be just an example for our
shellcode. So now our decoder

00:32:17.402,00:32:23.909
will modify the, the code and
memory, but on the most MIPS CPU
you have different types of, of

00:32:23.909,00:32:28.847
cache, the 1 side you have the
data cache and you have the
instruction cache, and when you

00:32:28.847,00:32:34.019
modify the umm the code in the
memory the data cache is
modified but the instruction

00:32:34.019,00:32:39.224
cache not and when you try to
execute the code, the
instruction cache executed but

00:32:39.224,00:32:46.097
not the data cache so our
modification is not triggered
and our shell code, failed. So

00:32:46.097,00:32:51.436
we get back and try to, to fix
the problem, there are 2
recommendations, on the 1 side

00:32:51.436,00:32:56.875
there is a trigger cache
function, but we did not find
any gadgets in on our device.

00:32:56.875,00:33:02.180
Another option is to umm use,
the sleep function to, to
trigger cache flush.we also

00:33:02.180,00:33:07.185
tried this, but after a few days
we still failed. I don’t, don’t
know the reason, but then we

00:33:07.185,00:33:14.125
decided ok, back umm, to roots
and we decided simply to write
our shellcode by hand and try

00:33:14.125,00:33:19.130
to, umm avoid null bytes or
other bad characters. I want to
give a few hints or umm what you

00:33:21.166,00:33:28.006
can do to avoid this, here for
instance you see uh uh
instruction uh load immediate

00:33:28.006,00:33:34.012
instruction to write a constant
value to your register and some
MIPS instruction have by design

00:33:34.012,00:33:40.285
a null byte included, so you can
simply split it up use some
negative value, inverting and so

00:33:40.285,00:33:46.625
on. and play around, and then
you will also get your final
result and this null byte free.

00:33:46.625,00:33:53.131
For setting zero values classic
tricks some eek, some eeksaw
function, eeksaw registers and

00:33:53.131,00:33:59.971
target register you get your
null and this instruction is
also null byte free. It’s

00:33:59.971,00:34:04.376
sometimes, eeh especially when
you need strings or other
characters it can get a bit

00:34:04.376,00:34:10.282
complicated then we also use the
our eeks arering this means we
took our string value umm

00:34:10.282,00:34:15.287
eekoaring already with a exorate
constant value put this as our,
our baseline and then we can

00:34:18.523,00:34:25.430
exorate again during run time
and then during the run time we
have again our string and so we

00:34:25.430,00:34:30.435
can bypass the decoding thing.
And Err, umm the shadow cache
problem. After that we put

00:34:32.971,00:34:38.276
everything in a assembler in
this case it was a good online
assembler we got our big Endan

00:34:38.276,00:34:45.016
in this assembly and can out
this in our exploit script. Here
we will show you a short demo so

00:34:45.016,00:34:50.021
in the lower window you will see
our reversal listening. The
upper window will execute our

00:34:53.058,00:34:58.063
attack script you see ok, our
target device online. Here you
see the script it is written in

00:35:00.332,00:35:05.337
cache. Her, here you can see in
the upper side our padding, our
2 gadgets and then umm our

00:35:07.605,00:35:14.145
handcrafted reversal shell. We
will put this code also online.
So I think in the video it’s

00:35:14.145,00:35:19.618
hard to see, but also have
written some advisairy
containing the code. You see

00:35:19.618,00:35:24.623
again our exploit is executed,
we’re on the device, you see in
the lower window. We have access

00:35:27.359,00:35:33.298
to the password and so on. We
are again root because we
already know all web servers are

00:35:33.298,00:35:38.303
running as root. ok, [audience
applause] here you see a small
overview of all the devices we

00:35:41.506,00:35:48.213
analyzed, uhmm we had a lot of
findings the most critical
findings we most announced are

00:35:48.213,00:35:55.086
CBCs for the minor findings err,
we did not, so so this is just
for completeness, below you will

00:35:55.086,00:36:00.425
find a link where all we
uploaded all advisory we sent to
the manufacturer they also

00:36:00.425,00:36:06.331
contain our exploits, scripts
and everything, so if your
interested you can read it. Here

00:36:06.331,00:36:11.836
is again an overview of the
vulnerability and the devices as
you can see we found a lot of

00:36:11.836,00:36:17.976
command injections path
reversals,a few buff overflows
sometimes also a few classic umm

00:36:17.976,00:36:23.681
web base attacks. When you looks
at short session ID we had 1 web
server which was generating a

00:36:23.681,00:36:30.522
session ID with a length of 3
characters so we can say this
session is very short. We were

00:36:30.522,00:36:35.527
also curious uhmm how, how much
devices or phones are out there,
but you will not get any, any

00:36:37.962,00:36:43.468
numbers from the manufacturer.
And, as as Philip already
explained, normally this devices

00:36:43.468,00:36:48.873
should not be reachable from the
outside It’s more a problem
from,from an attacker from the

00:36:48.873,00:36:53.878
inside but we still made a shor
shorter scam and here you will
see the top 4 erm, devices and

00:36:55.914,00:37:01.686
you see nearly over the 10000
devices were still reachable or
the web interface reachable,

00:37:01.686,00:37:07.759
also made a few sample tests if
they used default credentials
and we found also the devices

00:37:07.759,00:37:12.430
with the default credentials so
aah, you should take care about
this kind of problem, because

00:37:12.430,00:37:18.670
this can be an entry point to
your company network when
somebody abusers or or,attacks

00:37:18.670,00:37:25.643
the published or leaked device.
At the end you, should give a
few recommendations, I think the

00:37:25.643,00:37:32.383
most is aware of this, you,
don’t use default credentials,
keep the firmware update, you

00:37:32.383,00:37:38.189
don’t need a telnet server or a
or a, VoIP phone even if you
have a web server, mmh , try to

00:37:38.189,00:37:43.628
isolate it umm there are a few
phones where you can disable it,
when you don’t need it, disable

00:37:43.628,00:37:48.700
it. And also as we already
mentioned it network protection.
Try to isolate your, your web

00:37:48.700,00:37:53.705
network. Also for developers,
there are features called ASLR
and NX activate the compile up

00:37:56.040,00:38:02.580
press, uhmm, no hard coded keys
and also when you implement
updates what we saw was there's

00:38:02.580,00:38:07.585
just a manual update mechanism,
so implement some uh outdoor
updated. It will be helpful. So

00:38:10.088,00:38:16.561
this is now the end of the
technical part, so at the end
more more summary eerm and I

00:38:16.561,00:38:21.566
think the most are already
asking uh or wonder why we have
such a lot back to the future

00:38:21.566,00:38:26.571
images in it, the last part of
the documentation we will make a
short umm, time travel to a few

00:38:29.040,00:38:34.045
umm historical light year
moments you will see why here.
So when we go back to 1992 or 91

00:38:36.347,00:38:41.819
everybody knew that Linux was uh
released and from the concept we
have a multi user system, we

00:38:41.819,00:38:48.259
have a process isolation so it
was a good idea and good
baseline. So 96 then someone

00:38:48.259,00:38:54.365
realized that ok emm there are
some bad see functions we have a
problem, we must do something.

00:38:54.365,00:39:00.138
So different mitegations were
introduced and NX protections
ASLR and now we also have

00:39:00.138,00:39:06.978
control flow integrity relog and
so on. So you can see from this
time we have a good umm desktop

00:39:06.978,00:39:13.351
PC. I of course think it’s not
bulletproof you can still
exploit it, but it, it was

00:39:13.351,00:39:18.356
harder to attack. Back Then, now
we will go the year 2007, we get
new umm generation of devices

00:39:20.358,00:39:25.396
everybody knows there are smart
phones now and what we see now
is devices that were released

00:39:25.396,00:39:31.669
again everything was running in
root with one user. Ok, we
realized this is not such a good

00:39:31.669,00:39:38.610
idea what have we done. 2010 we
introduced again mitigation
techniques. So we missed our

00:39:38.610,00:39:45.116
chance to to produce uh new
designs or protection
magnabilities. Now we arrived

00:39:45.116,00:39:51.589
today or the last 2 or 3 years,
we now in the time of IOTS and
the focus. And when you listen

00:39:51.589,00:39:56.594
or saw our vulnerabilities or
read in the news,where are we
the state of 1992. So in our

00:39:59.797,00:40:05.270
opinion, something went wrong
and so you have to think when
you use your web phone on the

00:40:05.270,00:40:11.909
desk in some cases you using
technology which is in the
security state from 28 years

00:40:11.909,00:40:16.915
before now. Of cause we made
responsible disclosure, informed
all vendors about our findings,

00:40:20.551,00:40:26.357
we gave them 90 days or more to
fix the bug. But sometimes also
responsible disclosure can be

00:40:26.357,00:40:33.331
hard term sure nee. Here you see
a few reactions, I have to
mention of cause most corporated

00:40:33.331,00:40:38.369
and also tried to fix the
problem, but the first reaction
sometimes were why are you

00:40:38.369,00:40:42.774
investigating our poor phones?
What should we say? Yea because
we can. Eer sometimes they just

00:40:42.774,00:40:44.776
argue,ya, eer, the device is not
supported anymore, this is not
our problem. Eer I would say yes

00:40:44.776,00:40:46.778
this is your problem because
your customers still, still use
it. And sometimes you just have

00:40:46.778,00:40:51.783
to, to argue for instance umm
explain that you will publish
all your findings on Defcon and

00:41:00.425,00:41:07.365
1000 of people will listen and
suddenly everything goes a
little faster. Umm I already

00:41:07.365,00:41:13.271
mentioned that the buff overflow
were not fixed. We had 2 vendors
which did not react to our

00:41:13.271,00:41:20.144
announcement, 1 was umm Htech
and the other was aukobox uh we
tried to contact them via, email

00:41:20.144,00:41:25.149
via, support, via, twitter, via
facebook, via Linkin, umm the
only thing we did not was going

00:41:27.685,00:41:32.957
to China [speaker giggles] mmm
but if someone is here from the
company they can, can contact us

00:41:32.957,00:41:37.962
we will give him more details.
Umm at the end we had different,
we had 33 different type of

00:41:41.332,00:41:46.704
phones, all in all we found 40
vulnerabilities, the most
critical we reduced to CVES so

00:41:46.704,00:41:52.210
you can, can look it up. We
realized during the proto uh
during the project there is a

00:41:52.210,00:41:56.914
lot of old technology out there,
but on the other side umm
especially when you look at

00:41:56.914,00:42:03.087
newer models and the premium
flagship piper or whatever
superphones, you see there is a

00:42:03.087,00:42:07.992
change, there the newer phones
are running for instance with
android, which can be good,

00:42:07.992,00:42:14.866
because you have process
antalation sandbox inulooks umm
by design, which makes it more

00:42:14.866,00:42:19.670
secure, but now on the other
side you have now the feature to
install Apps so when you,

00:42:19.670,00:42:26.577
install on your,your desk phone
some Apps you can err, how can I
say, you can bring in new attack

00:42:26.577,00:42:33.518
or vulnerabilities umm in the
umm start up App. And the
question is now do we really

00:42:33.518,00:42:40.258
need a web browser or umm
WhatsApp on your wipe phone. So
I think this is end of our

00:42:40.258,00:42:45.563
journey so umm as Phillpe
already announced if you have
some questions or want to talk

00:42:45.563,00:42:51.035
to us, come to the front grab
some beer, if you have no
question, just thirsty, also

00:42:51.035,00:42:57.041
grab a beer, we we brought them
from from uh Germany, it’s good
Munnik beer. So I can only say

00:42:57.041,00:43:01.979
thank you for your attention,
here you see our contact
details. [audience applause]

