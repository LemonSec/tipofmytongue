00:00:00.167,00:00:06.840
>>Good Afternoon and welcome to
HTTP Desync attacks smashing
into the cell next door. Have

00:00:06.840,00:00:13.814
you ever seen a system that was
so complex that it just had to
be vulnerable. These days we

00:00:13.814,00:00:18.385
rely on layer upon layer of
abstraction to have the faintest
understanding of what’s really

00:00:18.385,00:00:23.390
going on with the website and we
tell people things like HTTP is
stateless and you send one

00:00:25.492,00:00:32.399
request, you get one response.
But what if both of those were
just kind of wrong. In this

00:00:32.399,00:00:37.738
session, I will share with you
new tools and techniques to
desynchronize complex systems,

00:00:37.738,00:00:43.243
smash through the barriers
around HTTP requests and make
websites rain exploits on their

00:00:43.243,00:00:48.248
visitors. During some research
last year I came up with a
theory, which was if you're

00:00:50.484,00:00:55.555
trying to select a topic to
research then the best topic is
the one that makes you the most

00:00:55.555,00:01:00.494
nervous. So, I asked myself what
topic am I personally really
scared of and the answer was

00:01:03.864,00:01:09.269
HTTP request smuggling. I saw a
presentation on this at DefCon a
few years ago, called Hiding

00:01:09.269,00:01:15.542
Your Keys In HTTP. And it was a
thrilling presentation but it
also left me far too nervous to

00:01:15.542,00:01:21.882
want to tackle this topic
myself. One reason is that this
technique was documented way

00:01:21.882,00:01:26.887
back in 2005 and yet I had never
seen it successfully applied to
a real website. Another is the -

00:01:29.523,00:01:33.593
my technical understanding just
wasn’t there so some of the
diagrams made absolutely zero

00:01:33.593,00:01:39.466
sense to me no matter how much I
stared at them and also some of
the statements on the slides

00:01:39.466,00:01:44.471
were quite concerning. They said
things like you will not earn
bounties using this technique

00:01:47.240,00:01:52.846
and even worse you’ll certainly
not be considered like a white
hat if you try and test any live

00:01:52.846,00:01:58.685
website to see if it’s
vulnerable to this technique.
So, at the time I just

00:01:58.685,00:02:04.791
sta-stayed away from this topic
but this year I thought I’d
tackle it and see what happened.

00:02:04.791,00:02:11.164
And quite a few things happened,
I mi-I did manage to earn some
bounties and no one’s called me

00:02:11.164,00:02:15.702
a black hat for it so far.
Although yesterday on Twitter
one guy, guy did call me a

00:02:15.702,00:02:20.707
terrorist.
[Pause][Laughter][Applause] But
I did get quite a few

00:02:26.313,00:02:30.917
interesting reactions from the
people that I reported these
vulnerabilities to. Ah, quite a

00:02:30.917,00:02:37.157
few people were surprised. One
guy was so surprised he appeared
to think I was faking the entire

00:02:37.157,00:02:42.562
thing, that I was doing some
kind of digital sleight of hand
in order to trick him into

00:02:42.562,00:02:49.002
paying me a bounty. Another guy,
at the opposite end of the
spectrum, liked the unique

00:02:49.002,00:02:53.440
technique that I used on his
websites so much he thought he
would take this technique and

00:02:53.440,00:02:59.813
use it himself on some other Bug
Bounty targets to make himself
some money behind my back.And at

00:02:59.813,00:03:04.651
the time, obviously, I had no
idea he was doing this, he
didn’t tell me. Ah, but then he

00:03:04.651,00:03:10.190
ran into some technical issues
with the technique and decided
the best way to solve them was

00:03:10.190,00:03:14.361
to pretend that he’d
independently found this
technique and then emailed me

00:03:14.361,00:03:19.666
and asked for help. [Audience
comment] which ah, didn’t work
out very well for him. But out

00:03:19.666,00:03:24.838
of all of this chaos I've been
able to bring you safe detection
methods to let you find this

00:03:24.838,00:03:30.544
with zero risk of being called a
Black Hat. All new methods to
trigger desynchronisation and

00:03:30.544,00:03:35.849
exploit the results and fresh
methodology in trawling to bring
clarity to a topic that’s been

00:03:35.849,00:03:40.854
ignored for far too long. So,
first I’m going to talk about
what makes this attack possible,

00:03:42.956,00:03:48.995
ah, how to assess if a target is
vulnerable and what to do next.
Then I will take a look at how

00:03:48.995,00:03:53.767
to exploit it, using case
studies, all based on real
websites. Starting out with some

00:03:53.767,00:03:58.672
really easy stuff and then
building in complexity and
ending, ah, with a video of

00:03:58.672,00:04:04.111
exploitation of a local system
in which I’ll also show how to
use the open-source Burp Suite

00:04:04.111,00:04:09.049
Extension that I’m releasing as
part of this research. After
that, I’ll talk about how to

00:04:09.049,00:04:14.054
prevent these attacks and then
wrap up and take questions if
there’s any time left. [Pause]

00:04:16.089,00:04:21.795
If you picture a website, as an
end-user, it probably looks
something like this because as

00:04:21.795,00:04:27.701
an end-user that’s all that we
can directly see. But behind the
scenes, most modern websites are

00:04:27.701,00:04:33.740
routing requests through a chain
of web servers speaking to each
other using HTTP over a

00:04:33.740,00:04:40.514
stream-based transport layer
protocol like TCP or TLS. And
for the sake of performance,

00:04:40.514,00:04:47.287
these streams are heavily reused
following the HTTP 1.1 Keepalive
protocol, which means that HTTP

00:04:47.287,00:04:53.393
requests are placed back to back
on these streams with no
delimiters in-between them and

00:04:53.393,00:04:58.665
each server in the chain is
required to parse the HTTP
headers of each request to work

00:04:58.665,00:05:05.138
out where that request stops and
the next one starts. So, with
this setup, we’ve got requests

00:05:05.138,00:05:10.577
from users all around the world
being funnelled over a small
pool of TCP or TLS streams to

00:05:10.577,00:05:15.615
the backend server that then has
to pass these requests to kind
of split them back up into

00:05:15.615,00:05:21.922
individual requests. Having said
all of that, it’s pretty obvious
what’s going to go wrong here,

00:05:21.922,00:05:28.094
right? What happens if an
attacker sends an ambiguous
message, one that gets parsed

00:05:28.094,00:05:33.333
differently by the front end and
the back end system. So, here
the front end thinks this is one

00:05:33.333,00:05:38.305
request, so its forwarding the
whole thing onto the back-end.
But the back-end, for some

00:05:38.305,00:05:42.876
reason, it thinks this message
ends with a final blue square,
so it thinks that the orange

00:05:42.876,00:05:48.915
square is the start of the next
request. And it’s just gonna
wait for this phantom request to

00:05:48.915,00:05:55.889
be completed until the front-end
routes another request onto the
back-end over the same socket.

00:05:55.889,00:06:01.294
And then, we end up with these
two requests being merged
together. So, that’s it, like

00:06:01.294,00:06:05.699
the essence of request
smuggling, is that you can, you
can set up a prefix on the

00:06:05.699,00:06:11.171
back-end that will be applied to
the next request that hits the
back-end. Whether that request

00:06:11.171,00:06:16.176
is sent by us or by somebody
else. [Pause] Because we can’t
directly see what’s happening

00:06:18.178,00:06:22.449
behind the front-end, we have to
infer everything and it’s really
easy to get kind of tangled and

00:06:22.449,00:06:26.786
bogged down in the technical
details. I certainly did myself
when doing this research, but

00:06:26.786,00:06:33.059
ultimately it’s really that
simple. Now, let’s zoom in and
see what the data looks like on

00:06:33.059,00:06:39.332
the wire. This message is
ambiguous because we’re using a
absolutely classic

00:06:39.332,00:06:43.937
desynchronisation technique,
we’ve just specified the
content-length header twice. And

00:06:43.937,00:06:48.041
the front-end is looking at the
first content-length header, so
it’s forwarding everything onto

00:06:48.041,00:06:52.512
the back-end including the
Orange G. And the back-end is
looking at the second

00:06:52.512,00:06:56.816
content-length header, so it’s
reading in the blue data and it
thinks the G is the start of the

00:06:56.816,00:07:02.289
next request. So, when the next
real request actually arrives,
there’s this G at the start of

00:07:02.289,00:07:06.626
it and whoever that user is,
they're gonna get a response
saying something like Unknown

00:07:06.626,00:07:13.266
Method G Post. And, that’s it,
we’ve successfully done a
request smuggling attack. The

00:07:13.266,00:07:18.338
only catch is, this technique is
so classic it doesn’t really
work on anything that’s actually

00:07:18.338,00:07:24.778
worth hacking these days. What
does work on plenty of
interesting systems is using

00:07:24.778,00:07:30.884
chunked encoding? Ah, ch-chunked
encoding is an alternative way
of specifying the length of the

00:07:30.884,00:07:35.889
message, whereby instead of
specifying the length upfront
using the content-length header,

00:07:35.889,00:07:40.193
you send this transferring code
in chunked header and that
triggers the server to pass the

00:07:40.193,00:07:47.067
body of the message until it
reaches a zero followed by a
blank line. So, in this example,

00:07:47.067,00:07:51.204
once again the front-end server
has looked at the content length
and forwarded everything up to

00:07:51.204,00:07:55.775
and including the Orange G and
the back-end system has seen the
chunked header and

00:07:55.775,00:08:00.513
they’ve-they’ve stopped passing
the first request after the zero
and once again they think that

00:08:00.513,00:08:04.984
the G is the start of the next
request and we get a G Post
response. This is basically

00:08:04.984,00:08:07.654
exactly the same as what I
showed you in the previous
slide, except that this

00:08:07.654,00:08:14.327
technique actually works on
plenty of real systems. Now,
what if the desynchronisation

00:08:14.327,00:08:17.897
happens the other way around,
what if it’s the front-end
server that looks at the

00:08:17.897,00:08:24.204
transferring coding header and
the back-end that looks at the
content length? Well, we can

00:08:24.204,00:08:28.675
still exploit that, ah, we-we
just need to reformat the-the
attack slightly and we’ve got

00:08:28.675,00:08:34.447
this minor limitation in the
our-our malicious prefix that
gets applied to the next request

00:08:34.447,00:08:41.187
shown in Orange, has to more or
less end with a zero followed by
a new line. But in general,

00:08:41.187,00:08:45.992
that’s not gonna to cause any
problems. Now, if you're looking
at the content length on this

00:08:45.992,00:08:49.596
slide, ah, you might be
wondering why that’s three,
that’s because every line

00:08:49.596,00:08:54.000
actually ends with slash r slash
n more or less, so that’s just
not shown on the slides to keep

00:08:54.000,00:09:00.640
them nice and clean. So, why
does that chunked technique work
on so many systems? Well, I

00:09:00.640,00:09:06.913
think we’ve gotta give some
credit to the original
specification RFC 2616. Because

00:09:06.913,00:09:11.551
that says if as a server you
receive a message that has
transferring coding chunked and

00:09:11.551,00:09:16.556
the content length, you should
prioritise the chunked encoding.
And that kind of implicitly says

00:09:18.758,00:09:24.264
that these messages are
acceptable, that you shouldn’t
be outright rejecting them. And,

00:09:24.264,00:09:29.702
thereby, all you need to exploit
a website is for one of the
servers in the chain to not

00:09:29.702,00:09:34.207
support chunked encoding and
they’ll fall back to using the
content length and you can

00:09:34.207,00:09:39.579
desynchronize them. And this
technique, when I found it,
worked on pretty much every

00:09:39.579,00:09:45.518
single website, ah, using the
content delivery network,
Akamai. Ah, they emailed me this

00:09:45.518,00:09:49.522
morning to say that they've
patched this, ah, but I expect
it still works on a decent

00:09:49.522,00:09:56.196
number of systems out there.
Now, so that’s enough by itself
to exploit quite a few systems,

00:09:56.196,00:10:02.402
but what do you do if you want
to exploit a server where every
server in the chain does support

00:10:02.402,00:10:07.540
chunked encoding? Well, that’s
often still possible, all you
need is a way to hide the

00:10:07.540,00:10:12.545
transfer code chunked header
from one server in the chain.
[Pause] One way of doing that is

00:10:16.015,00:10:22.288
by using some-some WhiteSpace.
So, some servers normalize
WhiteSpace, ah, after-after the

00:10:22.288,00:10:28.127
header name. So, some servers
will think this is transferring
coding chunked, whereas others

00:10:28.127,00:10:31.664
won’t see that, they’ll think
the space is actually part of
the header name, won’t see the

00:10:31.664,00:10:36.603
header and they’ll fall back to
using the content length and you
can desynchronized them. Other

00:10:36.603,00:10:41.541
servers, like to grip the
transfering coding header for
the word chunked. So, they will

00:10:41.541,00:10:46.546
think that this, this request is
chunked, whereas others tokenize
the headers so they won’t think

00:10:46.546,00:10:51.317
this is chunked and you can
desynchronize them. And there’s
loads of techniques that you can

00:10:51.317,00:10:57.657
use to desynchronize systems
like this. Ah, this is just a
tiny sampling of them but every

00:10:57.657,00:11:03.062
technique on this slide is one
that I've successfully used
myself to exploit a real system

00:11:03.062,00:11:07.934
during this research. Ah, the
ones that are highlighted in
orange, are techniques that I

00:11:07.934,00:11:12.939
came up with myself that I don’t
think I documented anywhere
else. So, at this point, we

00:11:16.309,00:11:20.480
understand the fundamentals of
how to desynchronize servers.
So, we’ve got a really powerful

00:11:20.480,00:11:25.351
building block, but if we just
try and whack a server with this
building block, we’re just gonna

00:11:25.351,00:11:30.623
run into hazards and
complications and waste time. To
avoid that, I've developed this

00:11:30.623,00:11:35.628
methodology to guide us in a
step by step manner towards a
successful exploit. First off,

00:11:38.598,00:11:44.470
we need to detect when
desynchronization is possible.
Now, the obvious way of doing

00:11:44.470,00:11:50.710
this is to send a pair of
requests where the first one is
am-ambiguous, so it’s designed

00:11:50.710,00:11:55.048
to poison the back-end with a
prefix and then the second
request, is designed to kind of

00:11:55.048,00:11:59.986
trigger this poisoned response.
But that technique is massively
unreliable because if anyone

00:12:02.121,00:12:06.859
else’s request hits the back-end
in-between our two requests,
they’ll get the poisoned

00:12:06.859,00:12:13.499
response. They’ll potentially
have a bad day and we won’t find
the vulnerability. So, we need a

00:12:13.499,00:12:20.373
better way of doing it. And
after a lot of effort, I think
I've got one here. So, how this

00:12:20.373,00:12:25.812
server gets handled, how this
request gets handled depends on
how the servers process these

00:12:25.812,00:12:30.683
headers. If both systems look at
the content length, ah, we get
the response pretty much

00:12:30.683,00:12:36.956
immediately and everything's
fine. If the front-end server
thinks this message is chunked,

00:12:36.956,00:12:41.361
then it will read in the first
chunked size of three, read in
the ABC and then it will read in

00:12:41.361,00:12:45.898
the next chunked size, which is
Q, which is not a valid chunked
size because that’s going to be

00:12:45.898,00:12:51.638
hexadecimal and thereby it will
just reject this-this request
outright and it will never even

00:12:51.638,00:12:56.776
hit the back-end system. But if
the front-end looks at the
fr-content header and forwards

00:12:56.776,00:13:02.348
all the blue data but not the
orange Q onto the back-end, and
the back-end thinks this message

00:13:02.348,00:13:08.354
is chunked, then the back-end
will basically just time out
while waiting for the next

00:13:08.354,00:13:13.726
chunked size to arrive. So, if
we send that request and we get
a time out, that’s a strong

00:13:13.726,00:13:20.199
indication that that server is
vulnerable to request smuggling
using that technique. And we can

00:13:20.199,00:13:23.369
detect when the
desynchronization happens the
other way around, ah, using a

00:13:23.369,00:13:28.975
fairly similar payload. The only
significant difference here is
that if the server is

00:13:28.975,00:13:33.312
vulnerable, the first way around
then we end up accidentally
poisoning the back-end socket

00:13:33.312,00:13:40.219
with the orange, with orange x,
ah, which is not an ideal
outcome. So, you should make

00:13:40.219,00:13:45.625
sure you always try the
technique on the left first.
Now, this technique should be

00:13:45.625,00:13:51.397
tried on every single endpoint
on the target website because
they may route requests to

00:13:51.397,00:13:55.902
different endpoints to different
back-end servers and you should
try this with every

00:13:55.902,00:14:01.874
desynchronization technique that
you know. Ah, and this strategy
is now used by Burp Suite

00:14:01.874,00:14:06.879
Scanner and also by the free
open-source talk that I’m
releasing as part of this

00:14:06.879,00:14:11.884
research, to find its
vulnerability. Now, because this
technique is based on influence

00:14:14.053,00:14:18.958
it will get some false
positives. But it doesn’t get
very many and its real strength

00:14:18.958,00:14:24.597
is, you will get vastly less
false negatives and there’s no
risk to real users. For example,

00:14:24.597,00:14:30.136
on one target that I found, ah,
this technique detected the
vulnerability every single time.

00:14:30.136,00:14:35.508
Whereas, using the classic
approach of sending a pair of
requests, I had to make eight

00:14:35.508,00:14:40.146
hundred attempts before one was
successful. And that’s
potentially eight hundred real

00:14:40.146,00:14:45.151
users that got a broken
response. Now, in an ideal world
but most people will want you to

00:14:47.920,00:14:52.859
prove that the vulnerability
really definitely exists. So, to
do that we’re gonna use this

00:14:52.859,00:14:57.563
technique where you send a pair
of requests and it’s kind of
unreliable but we don’t have

00:14:57.563,00:15:03.970
much choice. So, here the first
request is gonna smuggle with
this prefix shown in orange and

00:15:03.970,00:15:08.875
then we’re gonna send a second
separate request, shown in
green. And based on the response

00:15:08.875,00:15:14.647
that we get to that request, we
can tell whether the server is
vulnerable. Now, it’s crucial

00:15:14.647,00:15:19.652
that these two requests are not
sent over the same connection to
the front-end server, cause if

00:15:21.687,00:15:26.225
you do that you would just get a
false positives. And also, the
endpoint that you send these

00:15:26.225,00:15:31.731
requests to is really important
because often if, if the
back-end doesn’t like the

00:15:31.731,00:15:37.804
request that it receives, it
will reject it with like a 400
or 500 message and it will close

00:15:37.804,00:15:42.108
the connection to the front-end
server, which will mean that
the-the orange poisonous that

00:15:42.108,00:15:47.180
will be thrown out and the
attack will fail. So you want to
try and select and endpoint that

00:15:47.180,00:15:52.351
expects to receive a post
request and also try and
preserve any parametres

00:15:52.351,00:15:57.323
that-that it needs, ah, for
example, in these examples here
I’ve preserved the Q equals

00:15:57.323,00:16:03.763
smuggling parameter. [Pause] The
other thing is, please remember
that even if you do all of that,

00:16:03.763,00:16:09.635
these techniques, this technique
is non-deterministic if anyone
else’s request lands in-between

00:16:09.635,00:16:16.475
your two requests it will fail
and also even if the target has
no other users browsing it, many

00:16:16.475,00:16:21.314
websites use a pool of
connections to the back-end and
so it may still require multiple

00:16:21.314,00:16:27.687
attempts.But as soon as one
works, you know its vulnerable.
[Pause] Right now we’re done

00:16:27.687,00:16:33.526
with the theory, we can finally
take a look at what damage we
can do using this technique.

00:16:33.526,00:16:37.363
Every case study here is a real
system I exploited during this
research, ah, I have

00:16:37.363,00:16:42.802
unfortunately been forced to
redact rather a large number of
company names. But, I’d like to

00:16:42.802,00:16:46.839
give a shout out to every
company that actually let me
name them, ah, please remember

00:16:46.839,00:16:51.944
these are the guys that are now
actually secure. Also, during
this section, I’m gonna to keep

00:16:51.944,00:16:58.317
a running total of the bounties
earned via this research. Ah, as
usual of this-of these bounties

00:16:58.317,00:17:02.421
we’ve spent fifty percentage on
bare and donated the other fifty
percent to local charities.

00:17:11.764,00:17:15.968
[Applause] Now, probably the
easiest attack you can do with
request smuggling is bypassing

00:17:15.968,00:17:20.406
security roles that have been
implemented on the frontend
system. On one well-known

00:17:20.406,00:17:25.578
software vendor, I found that
their front-end was blocking
access to slash admin. So by

00:17:25.578,00:17:27.880
using, ah-ah request smuggling
their frontend would first think
I was accessing the route of the

00:17:27.880,00:17:30.616
website So by using, ah request
smuggling, their front-end would
first think I was accessing the

00:17:30.616,00:17:34.754
route of the website and then
when I sent the follow up
requesting Green, it would once

00:17:34.754,00:17:39.191
again think I was accessing the
route of the website. But the
back-end would think I was

00:17:39.191,00:17:44.196
trying to hit the admin page and
serve it up. So far, so simple.
[Pause] Now, lots of front-ends

00:17:46.365,00:17:51.070
like to rewrite requests by
adding headers to them and one
header practically every system

00:17:51.070,00:17:56.909
uses some variation of, is X
Forwarded For, which just
specifies the remote users IP.

00:17:56.909,00:18:02.748
Now, if you spe-specify this
header yourself directly, in a
normal request any

00:18:02.748,00:18:08.120
well-configured front-end will
rewrite that header or remove it
entirely and so it won’t work.

00:18:08.120,00:18:13.025
But when you smuggle a request
you effectively bypass all the
rewrite rules used on the

00:18:13.025,00:18:17.363
front-end and thereby you can
spoof your IP and make it look
like your request is coming from

00:18:17.363,00:18:22.902
anywhere. Using this technique,
ah I exploited a particular
security vendor, ah and got an

00:18:22.902,00:18:28.708
incredible three-hundred-dollar
bounty, woo. Ah,so, I’m not
suggesting you gonna get rich

00:18:28.708,00:18:33.646
quick using this particular
technique but it’s worth knowing
because it does work on

00:18:33.646,00:18:40.419
practically every target. And
also, there is a slightly less
obvious use for this technique.

00:18:40.419,00:18:45.925
Imagine you’ve found a website
where the time out based
detection technique works, so

00:18:45.925,00:18:50.262
you're fairly sure it’s
vulnerable. But their traffic
volume is so high that you’ve

00:18:50.262,00:18:56.802
effectively got zero chance of
ever getting a poisoned response
yourself. What you’ve

00:18:56.802,00:19:01.407
effectively got there is a blind
request smuggling vulnerability.
How can you prove that that

00:19:01.407,00:19:06.846
system is really vulnerable?
Well, one thing you can try is
send a request that looks

00:19:06.846,00:19:12.151
something like that but stick a
unique hostname in the X
Forwarded For Header. If you get

00:19:12.151,00:19:18.424
a DNS lookup for that hostname,
that proves that the-the Orange
data has been interpreted as a

00:19:18.424,00:19:22.995
second request by the back-end
system and thereby proves that
it is vulnerable to request

00:19:22.995,00:19:28.000
smuggling. [Pause] Now, IP
spoofing is okay, ah, but the
really interesting behavior is

00:19:30.036,00:19:34.740
gonna to come from custom
application specific headers.
But to exploit those we need to

00:19:34.740,00:19:41.480
know what they are. Now, on New
Relic, ah I was able to submit a
login, [Stutter] a-a login

00:19:41.480,00:19:47.987
request and I just shuffled the
parameters so that the email
address parameter was last. So

00:19:47.987,00:19:53.793
then when I sent my follow up
request, it effectively got
concatenated into the email

00:19:53.793,00:19:58.364
address that I was trying to
login with. So, the response
that I got from the server

00:19:58.364,00:20:03.836
contained the entirety of my
second request, including all of
the headers that the front-end

00:20:03.836,00:20:10.076
had stuck onto that request. And
some of those are going to come
in really useful on the next

00:20:10.076,00:20:16.816
slide. [Pause] So, on New Relic,
it became evident that the
back-end system wasn’t the

00:20:16.816,00:20:22.688
actual most back-end back-end,
ah, it was a reverse proxy. So,
by changing the host header, I

00:20:22.688,00:20:28.227
could access different internal
systems. I basically had SSOF
using request smuggling.

00:20:28.227,00:20:33.132
However, pretty much all of
these systems responded with
this redirect to HTTPS because

00:20:33.132,00:20:37.870
they thought my request was
being sent over HTTP, but by
looking at the previous slide,

00:20:37.870,00:20:41.774
ah getting the X Forwarded Proto
Header and sticking that on
there I could tell them, yeah

00:20:41.774,00:20:48.647
I’m using HTTPS you can trust me
and actually gain access to
those systems. So, I went

00:20:48.647,00:20:55.554
exploring and I found a page
that gave me a incredibly
taunting error message. It said,

00:20:55.554,00:21:00.359
not authorized with Header and
then it had a colon, but it
didn’t tell me what the name of

00:21:00.359,00:21:06.465
the Header that I wasn’t
authorized with actually was.
[Pause] And, so I-I went

00:21:06.465,00:21:10.503
exploring, ah looked through the
Headers I’d already discovered
the names of, and I tried the

00:21:10.503,00:21:16.909
XXNR external servers Header and
that actually just made the
problem worse. And, at this

00:21:16.909,00:21:22.448
point, I could’ve tried that
request reflection technique on
loads of different endpoints on

00:21:22.448,00:21:28.120
different New Relic systems
until I discovered this Header.
But I was feeling kind of lazy

00:21:28.120,00:21:32.992
at this point, so I decided
instead I was gonna cheat and
consult my notes from last time

00:21:32.992,00:21:38.397
I compromised New
Relic.[Laughter] And that
revealed the service gateway

00:21:38.397,00:21:45.171
account ID and service gateway
is new admin headers. So, using
those I was able to gain full

00:21:45.171,00:21:51.143
access to their core internal
API and impersonate [Stutter]
any user on the entire system as

00:21:51.143,00:21:56.315
an admin and gain pretty much
full control over everything.
Ah, and I got a reasonable

00:21:56.315,00:22:01.787
bounty for that. And they
patched that pretty quickly with
a hotfix, but they said that the

00:22:01.787,00:22:06.425
root cause was their F5 load
balancer and I don’t think
that’s been patched yet, so

00:22:06.425,00:22:13.365
that’s a zero-day more or less.
Now, what we’ve see here is,
with request smuggling, if

00:22:13.365,00:22:17.937
you’re willing to put the time
in you can often break directly
into internal systems and have a

00:22:17.937,00:22:24.276
good time. But there’s also much
easier and more reliable
techniques focused on attacking

00:22:24.276,00:22:29.281
other users. So, that’s what
we’re gonna take a look at next.
[Pause] Firstly, if the

00:22:32.151,00:22:37.389
application has any way of
persistently storing text data,
then exploitation is really

00:22:37.389,00:22:42.394
easy. On, on Trello, which is a
popular note-taking application,
I smuggled a request to update

00:22:44.830,00:22:50.002
my profile and I made sure that
the borrow parameter was last
and then I didn’t send a follow

00:22:50.002,00:22:56.108
up myself. So, some random other
Trello users request got
concatenated onto the end and

00:22:56.108,00:23:01.680
then I could just browse to my
bio and retrieve them entire
request including all their

00:23:01.680,00:23:07.186
session cookies even though they
both secure and HTTP only
[Audience Laughter] Ah, so using

00:23:07.186,00:23:11.991
this technique with zero user
interaction you can just every
time you send this you get

00:23:11.991,00:23:18.464
control over a random person who
is currently browsing the
website. On a different target,

00:23:18.464,00:23:23.636
ah they didn’t have any obvious
way of persistently storing
data, but I was able to file a

00:23:23.636,00:23:29.675
support ticket and get the users
request concatenated into that
ticket. So, that eventually I

00:23:29.675,00:23:36.515
would, ah get an email
containing their request and
could once again hijack their

00:23:36.515,00:23:40.786
account. [Pause] Now, what if
you can’t store data, well
there’s a whole other branch of

00:23:40.786,00:23:46.959
attack based on causing harmful
responses to get served directly
to people browsing the site. Ah,

00:23:46.959,00:23:52.564
the simplest one [Stutters]
conceptually is one I found on a
well-known SAS vendor that

00:23:52.564,00:23:57.336
hasn’t patched it that’s why I
can’t name them. Ah, they had
some reflected XSS right and by

00:23:57.336,00:24:01.573
itself that’s, you know, that’s
okay but it’s not that great
because it requires user

00:24:01.573,00:24:07.613
interaction to exploit people,
so it’s not ideal for mass
exploitation. But by smuggling

00:24:07.613,00:24:12.418
the request that [Stutters] that
triggers the XSS, I could get
the harmful response served to

00:24:12.418,00:24:18.090
random other people browsing the
website. Ah, so we’ve taken this
issue and we can just exploit

00:24:18.090,00:24:23.729
random people with no user
interaction, we can also grab
HTTP only-only cookies once

00:24:23.729,00:24:29.768
again using this technique and
this can also be used with
traditionally unexploitable XSS

00:24:29.768,00:24:34.773
like XSS in the user agent
header or XSS where there’s a
csrf token, ah, on the request.

00:24:37.242,00:24:42.915
[Pause] Now, while testing one
target, I happened to load the
home page in a web browser where

00:24:42.915,00:24:48.921
the developer tool was open and
this error message popped up,
and normally, you know, so what.

00:24:48.921,00:24:53.192
But I kind of recognized the IP
address in this error message,
which made me a little bit

00:24:53.192,00:24:57.830
worried. And what was more
worrying is that I got that
error message regardless of what

00:24:57.830,00:25:02.768
device I loaded the homepage on
and what network I connected
from. And it turned out, yep,

00:25:04.837,00:25:10.642
this was my fault, ah I’d sent a
request trying to trigger a
redirect from their system and

00:25:10.642,00:25:16.815
someone else’s request, an
attempt to fetch-fetch an image,
had been concatenated onto it.

00:25:16.815,00:25:21.453
So, they got this redirect
response, which is, you know,
okay that’s not ideal but it’s

00:25:21.453,00:25:28.093
only one user right who cares
about them? But a cache had seen
this happen. So, it’d seen them

00:25:28.093,00:25:33.198
try to fetch this image from the
homepage and it’d seen this
redirect to my server come back

00:25:33.198,00:25:37.536
and then it saved this, so for
the following forty-eight hours
everyone that went to the

00:25:37.536,00:25:42.541
targets homepage ended up trying
to fetch this image from my
website. [Audience laughter]

00:25:44.676,00:25:49.815
Now, on the one hand this is a
brilliant demonstration of how
easy it is to do cache poisoning

00:25:49.815,00:25:54.353
with request smuggling, right?
It’s so easy, I did it by
accident. But on the other hand,

00:25:54.353,00:25:59.925
ah, this is not something that
you really want to happen
unintentionally. Ah, so there’s

00:25:59.925,00:26:05.097
some things you can do to try
and reduce the chance of this.
Ah, one is to, one is to try and

00:26:05.097,00:26:10.836
specify a prefix that triggers a
response that will have
anti-caching headers. And, ah,

00:26:10.836,00:26:17.075
another is to send your victim
follow up requests as fast as
possible. And another is, if

00:26:17.075,00:26:21.380
you’ve got a choice of front
ends then just try and target
one in a geographic region

00:26:21.380,00:26:26.585
that’s like asleep at the time
and then you’ll be racing
against less genuine users

00:26:26.585,00:26:32.758
traffic. Now, that wasn’t
ideal,ah, but naturally that
left me wondering what happens

00:26:32.758,00:26:37.763
if we embrace this possibility.
So, here I’ve smuggled a request
saying I’d like to fetch my API

00:26:39.832,00:26:45.237
key please. And if someone
else’s request gets concatenated
onto that it’s completed with

00:26:45.237,00:26:51.043
their cookie, in their session
and it fetches their API key.
And then fetching their own API

00:26:51.043,00:26:57.015
key is harmless but if a cache
sees that happening and saves
it, then we can just browse to

00:26:57.015,00:27:02.488
whatever static resource that
user was trying to fetch and
retrieve their key. If this

00:27:02.488,00:27:07.192
attack sounds kind of familiar,
ah yep that’s because this is
basically just a variation of

00:27:07.192,00:27:13.131
web cache deception. Ah, the key
difference is that this
technique, once again, doesn’t

00:27:13.131,00:27:17.369
require any interaction on the
part of the user. You’re just
exploiting a random person

00:27:17.369,00:27:24.109
browsing the website every time
you do it. Ah, there’s also a
minor catch with this technique,

00:27:24.109,00:27:29.581
which is that as an attacker,
you’ve got no control over where
the users API key lands on the

00:27:29.581,00:27:33.986
website. It’s just gonna to
appear on a random static
resource on that site. So,

00:27:33.986,00:27:39.024
you’re going to have to like
reload all the static resources
to try and find that key. Now,

00:27:39.024,00:27:43.795
because my pipeline, ah that I
used to get examples for these
presentations, doesn’t bother

00:27:43.795,00:27:48.767
logging in to websites, I don’t
have a real example of a
vulnerable target. But I’m

00:27:48.767,00:27:53.238
pretty sure this vulnerability
does exist out there, ah and in
general you’re going to find it

00:27:53.238,00:27:58.243
in places that have those
properties. [Pause] Now, on New
Relic, the back-end was an

00:28:02.281,00:28:07.286
internal proxy, ah and on some
other systems the back-end was
actually a CDM, which doesn’t

00:28:09.655,00:28:15.894
make much sense to me. Ah, I
found one server that chained
Akamai onto Cloudflare. Ah, why,

00:28:15.894,00:28:21.366
ah but on a different system
they chained Akamai onto Akamai,
but the two Akamai’s were

00:28:21.366,00:28:26.338
configured differently, so I
could desynchronize them and
thereby, by-by changing the host

00:28:26.338,00:28:32.611
header I could serve up content
from any website on the Akamai
platform on these guys website.

00:28:32.611,00:28:37.182
And the front-end Akamai would
then cache that, so I could
override their homepage with any

00:28:37.182,00:28:44.156
content from any site on the
Akamai platform. [Pause] This
technique, ah also works pretty

00:28:44.156,00:28:49.194
well on SAS providers where you
can just, where you can simply
just change the hostname to a

00:28:49.194,00:28:55.567
different client of the SAS
provider. Now, Red Hat’s website
was itself directly vulnerable

00:28:55.567,00:29:01.473
to desynchronization. And while
looking for a vulnerability to
chain with request smuggling on

00:29:01.473,00:29:07.479
there, I found this DOM based
open redirect and that raised an
interesting challenge, because

00:29:07.479,00:29:13.452
with request smuggling, we
control the URL so the back-end
server thinks the user is on,

00:29:13.452,00:29:19.891
but we don’t control the URL in
the victim’s browser. So, when
this get query Param function is

00:29:19.891,00:29:26.231
executed, that’s executed in the
victim's browser, so we can’t
directly exploit this

00:29:26.231,00:29:32.771
vulnerability. But by finding a
local redirect on the target, I
could effectively chain that

00:29:32.771,00:29:38.977
with a DOM based redirect and
gain control of the URL in the
users browser and exploit the

00:29:38.977,00:29:44.049
session. And that’s a generic
technique that will work, that
will let you combine any DOM

00:29:44.049,00:29:48.954
based issue that looks at the
URL with request smuggling to
exploit people without user

00:29:48.954,00:29:53.959
interaction. Now, quite a few
local redirects actually turn
into open redirects in the

00:29:56.328,00:30:02.034
presence of-of request smuggling
because we can change the
smuggled host header. In

00:30:02.034,00:30:07.706
particular, there’s a default
behavior on Apache and most
versions of IIS, whereby if you

00:30:07.706,00:30:12.277
try and access a folder, and you
don’t specify the chaining
slash, they give you a redirect

00:30:12.277,00:30:18.750
to put the slash on and they
populate the host name in that
redirect using the host header.

00:30:18.750,00:30:23.388
Because this technique works on
loads of systems, and you can
use that, ah to redirect

00:30:23.388,00:30:28.393
Javascript loads on the target
websites and thereby gain
full-full control over whatever

00:30:31.029,00:30:34.800
page the Javascript load comes
from and use it for cache
poisoning and just gain like

00:30:34.800,00:30:40.439
full control of the website more
or less permanently. This became
my default technique to exploit

00:30:40.439,00:30:46.712
this vulnerability and I got
quite a few different bounties
using it. Ah, a couple of extra

00:30:46.712,00:30:51.717
points worth mentioning, if you
get a 307-open redirect, that is
absolute gold dust. Because,

00:30:54.319,00:31:00.692
imagine a web browser is doing a
post request to log someone in,
right? If it receives a 307

00:31:00.692,00:31:06.465
redirect it will repost those
credentials to the new website.
So, you can just make people

00:31:06.465,00:31:12.237
send you their username and
password in plain text with no
user interaction. Also, worth

00:31:12.237,00:31:17.709
mentioning, ah is that some
thick [Stutters] some thick
clients, like a non browser

00:31:17.709,00:31:24.216
based HTTP libraries, have that
data, ah reposting behavior on
all redirects rather that just

00:31:24.216,00:31:31.189
307 ones. So, for example, on
New Relic I was able to-to steal
the API tokens off one of their

00:31:31.189,00:31:36.194
clients, even though they were
only using a 301 redirect. Now,
one of the targets that this

00:31:38.597,00:31:43.902
redirect, ah cache poisoning
Javascript hijacking strategy
worked on, was PayPal. If you

00:31:43.902,00:31:49.908
tried to access web static, they
gave you AV direct using the
host header to populate it.

00:31:49.908,00:31:54.479
There was a couple of, ah
problems though. One is that the
two host headers were getting

00:31:54.479,00:32:00.085
concatenated and we only control
the first one. So, this was
breaking the redirect, but that

00:32:00.085,00:32:06.124
was easily fixed by sticking a
question mark at the end of the
host header. Ah, the other issue

00:32:06.124,00:32:12.397
is the protocol on this
redirect, it’s HTTP and because
of-of browsers and mixed

00:32:12.397,00:32:17.536
content, p-protections, ah that
meant that this is only gonna be
exploitable in Safari and Edge

00:32:17.536,00:32:22.674
and AI for the details of how
you can exploit those, you’ll
need to check out my cache

00:32:22.674,00:32:26.845
poisoning presentation from last
year because I don’t have time
to cover it right now. But the

00:32:26.845,00:32:31.883
important thing is, this job of
script file I could persistently
turn into a redirect to my own

00:32:31.883,00:32:38.023
malicious Javascript file was
used on PayPal’s login page.
Unfortunately, their login page

00:32:38.023,00:32:43.028
used CSP, which blocked the
redirect. But, the, their login
page also loaded a different

00:32:45.831,00:32:52.571
page in an IFrame and this
subpage didn’t use CSP and also
imported my poisoned Javascript

00:32:52.571,00:32:59.311
file, so I could hijack the
IFrame. But, thanks to the same
origin policy, I couldn’t read

00:32:59.311,00:33:04.249
the users password off the
parent page because I was stuck
on c dot PayPal dot com. But, my

00:33:06.685,00:33:12.190
colleague, Gareth Hayes, found
an endpoint PayPal dot com slash
us slash gifts, and this is a

00:33:12.190,00:33:17.195
static page. It doesn’t have
CSP, well it didn’t at the time,
ah, and it once again imports my

00:33:20.632,00:33:26.338
malicious Javascript file. So,
by first compromising the
Iframe, because it loads c dot

00:33:26.338,00:33:31.309
PayPal dot com and then
redirecting the Iframe to PayPal
dot com slash us slash gifts and

00:33:31.309,00:33:36.214
then re-compromising it, using
my Javascript file, I could then
read the users PayPal password

00:33:36.214,00:33:40.819
off the payment page and send it
off to my website. [Audience
laughter] So, the end impact is,

00:33:40.819,00:33:45.657
if you went to PayPal’s website,
ah in one of those browsers, I
just more or less got your

00:33:45.657,00:33:50.662
password. Ah, and they paid a
healthy 19000 dollar bounty for
that. [Audience Applauses] Now,

00:33:59.771,00:34:05.510
PayPal fixed this issue by
reconfiguring the frontend,
which was Akamai, ah to block

00:34:05.510,00:34:10.282
any requests that had the word
chunked in the transferring
coding header. And they, and

00:34:10.282,00:34:14.686
they asked me like I’ll be no
act, do you think this is a
solid fix? And I kinda poked at

00:34:14.686,00:34:21.293
it for a little bit and I was
like, yep, looks solid to me.
And then a few weeks later

00:34:21.293,00:34:25.530
[Laughs], I decided to-to try
out a new desynchronization
technique where I simply used a

00:34:25.530,00:34:31.937
line wrapped header. And this
strategy, ah is pretty much RFC
compliant and I didn’t really

00:34:31.937,00:34:38.109
think it was gonna to work, work
on anything and it didn’t
directly work on any systems.

00:34:38.109,00:34:43.782
But it turns out there was a
little bug in Akamai, whereby if
you use line wrapping, they

00:34:43.782,00:34:49.120
don’t see any of the data after
the line wrap. So that meant
they didn’t see this header,

00:34:49.120,00:34:53.725
they let it through, I could
once again desynchronize
PayPal’s login page, take

00:34:53.725,00:34:58.730
control of it and I got another
twenty-thousand-dollar bounty.
[Audience Applause] I thought

00:35:03.868,00:35:07.939
that was really generous of
PayPal, especially given that it
was basically my fault in the

00:35:07.939,00:35:14.079
first place. [Laughter] So, now
we’ve seen a whole range of
different attack techniques that

00:35:14.079,00:35:19.084
you can do with request
smuggling, it’s time for the
demo. [Pause] So, this is

00:35:25.023,00:35:29.627
Bugzilla, this is an exact
replica of the target system,
holds lots of duty Firefox zero

00:35:29.627,00:35:35.533
days at any given time. Ah, I’m
gonna to take the request to the
homepage and I’m gonna right

00:35:35.533,00:35:39.304
click on it and click launch
smuggle probe, which is an
option there because I’ve

00:35:39.304,00:35:44.009
installed this free open source,
Burp extension. And I’ve
disabled all the

00:35:44.009,00:35:47.946
desynchronization techniques
except for the one that’s
actually gonna work. Now we’re

00:35:47.946,00:35:52.083
gonna look at Flow, which is a
separate extension that just
shows you the requests and you

00:35:52.083,00:35:57.055
can see that here I’m using the
time out technique to detect the
vulnerability and it seems to be

00:35:57.055,00:36:02.193
working. Now, if you look at the
headers, you can see, it’s
probably too small to see, ah

00:36:02.193,00:36:07.365
but, you can see that the
previous header, the one before
transfer coding ends with Oa,

00:36:07.365,00:36:13.171
when all the other headers end
with Od Oa. That’s what’s
causing the-the

00:36:13.171,00:36:18.877
desynchronization here, so the
front-end thinks that, thinks
that Foos transfer coding is one

00:36:18.877,00:36:24.849
header, whereas the back-end,
which is Nginx sees them as two
different header and thereby we

00:36:24.849,00:36:29.354
can desynchronize them. You can
see it’s found the vulnerability
here, so I’m gonna to right

00:36:29.354,00:36:34.893
click on the request and click
smuggle attack. This pops open a
turbo intruder window, you don’t

00:36:34.893,00:36:38.897
need to change anything here
apart from the prefix variable,
which is just the malicious

00:36:38.897,00:36:44.536
prefix that gets applied to the
next request. So, when I launch
attack it’s gonna send the

00:36:44.536,00:36:49.741
attack and then load the victims
request, which are all identical
and you can see the first one,

00:36:49.741,00:36:56.014
ah even though it’s identical to
the third, to the second, gets a
404 status code back and that’s

00:36:56.014,00:37:01.119
because of the prefix that we’ve
specified here to try and make
it trigger a 404. So, that kinda

00:37:01.119,00:37:06.224
proves this system is vulnerable
and I’m just gonna replay that
to show it’s completely

00:37:06.224,00:37:11.796
consistent. Ah, and you can show
if you change the prefix then
the behavior that you get on the

00:37:11.796,00:37:17.569
second request will change. So,
we know this system is
vulnerable to request smuggling,

00:37:17.569,00:37:23.174
we just need to exploit it. On
Bugzilla, anyone can register an
account, file a bug and put an

00:37:23.174,00:37:28.480
attachment on the bug that
contains HTML. But this gets
rendered on a different domain,

00:37:28.480,00:37:34.819
see we’re on bmo sandbox vm. So,
by itself, you can’t do any
damage with this feature, this

00:37:34.819,00:37:41.392
is not a vulnerability on its
own. Thanks to the same origin
policy, ah but we’re gonna see

00:37:41.392,00:37:45.096
if we can chain that behavior
with request smuggling to
actually achieve something

00:37:45.096,00:37:50.835
useful. So, here I’m gonna take
the request to fetch the
attachment, which is sent to bmo

00:37:50.835,00:37:55.840
sandbox, ah but is actually on
the same IP as bmo web on-on
real Bugzilla systems and I’m

00:37:57.909,00:38:03.214
gonna stick that in the
malicious prefix. I’m just gonna
leave this x ignore header on

00:38:03.214,00:38:09.287
the end because the-the victims
request gets concatenated
directly onto that. So, here you

00:38:09.287,00:38:14.459
can see the-the victim request
has been sent to bmo web dot vm,
but it’s retrieved this

00:38:14.459,00:38:20.198
malicious HTML. So, all that
remains now is just to prove
this vulnerability really works

00:38:20.198,00:38:25.870
inside a browser. So, I’m gonna
comment out the victim requests,
I’m gonna send this and

00:38:25.870,00:38:30.375
basically leave the back-end
poisoned with this malicious
half of a request and now any

00:38:30.375,00:38:35.113
user, no matter what they click,
they’re gonna get the response
back, it’s gonna steal their

00:38:35.113,00:38:40.118
password, great. [Pause]
[Applause] That got a 4500
dollar bounty, ah taking the

00:38:50.361,00:38:55.233
total amount earned during this
research to 70k, ah that’s the
total so far, but there should

00:38:55.233,00:39:01.139
be some more bounties on the
way, hopefully. Now, as far as
preventing these attacks g-goes,

00:39:01.139,00:39:05.843
ah they’re best off
pre-prevented on the front-end
system, ah because the back-end

00:39:05.843,00:39:11.749
can’t normalize, can’t normalize
requests it just has to reject
them outright. But firstly, you

00:39:11.749,00:39:17.088
can’t fix this unless you can
find it properly, so make sure
that whatever tool you’re using

00:39:17.088,00:39:22.794
supports sending invalid content
length headers and doesn’t
automatically normalize

00:39:22.794,00:39:27.065
requests. In particular, that
means if you’re trying to
replicate this vulnerability

00:39:27.065,00:39:32.570
using Co, depending on which
desynchronization technique
you’re using, it may not work.

00:39:32.570,00:39:38.676
Also, some companies like to
proxy pen testers and if you do
that, you’ll fail to find

00:39:38.676,00:39:43.448
genuine vulnerabilities that
exit and you’ll also find, kind
of, phantom vulnerabilities that

00:39:43.448,00:39:49.254
only let you exploit other pen
testers. So, it’s not a very
good idea. As far as patching

00:39:49.254,00:39:55.226
this goes, ah the ideal, is just
to make the front-end
exclusively use HTTP2 to talk to

00:39:55.226,00:40:00.798
the back-end. But if that’s not
plausible, then the front-end
needs to normalize any ambiguous

00:40:00.798,00:40:05.803
requests before routing them
downstream. That strategy is
backed up by RFC [stutter] 7230,

00:40:08.706,00:40:13.511
ah so that’s probably what you
want to do. If you’re stuck on
the back-end, yeah you just have

00:40:13.511,00:40:18.283
to reject the request outright
and drop the connection. It’s
not ideal, which is why this is

00:40:18.283,00:40:24.222
better off been patched on the
front-end. There’s loads of
resources online for this, ah

00:40:24.222,00:40:28.993
there’s the Whitepaper, check
that out. We’ve also, for the
first time, released a-a whole

00:40:28.993,00:40:34.732
bunch of free online labs, so
you can practice [stutter]
exploiting this vulnerability on

00:40:34.732,00:40:40.405
replica real systems and just
get familiar with-with that
without the carnage that you get

00:40:40.405,00:40:46.110
when you try and exploit this on
a real site. Ah, also the source
code for the tool is online,

00:40:46.110,00:40:49.714
that works in the free version
of Burp as well as the pro
version and both of the

00:40:49.714,00:40:56.354
references are both well worth
checking out. The three key
things to take away are that

00:40:56.354,00:41:00.558
HTTP requests smuggling is real
vulnerability, it doesn’t matter
if it's scary, you can still get

00:41:00.558,00:41:06.297
hacked with it. HTTP one point
one parsing, is a security
critical function and it should

00:41:06.297,00:41:12.170
always be audited in web servers
before even think about using
them. And detection of request

00:41:12.170,00:41:17.375
smuggling doesn’t have t be
dangerous. I’m gonna take two
minutes of questions now, ah if

00:41:17.375,00:41:21.079
have any more after that feel
free to c-come and speak to me
at the back or chuck me an

00:41:21.079,00:41:26.084
email. Don’t forget to follow me
on twitter, thank you for
listening. [Applause]

