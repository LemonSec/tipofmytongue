00:00:00.033,00:00:04.605
>>Alright so the first
announcement we have to make is
uh that we are running CTF

00:00:04.605,00:00:10.644
challenges and those challenges
actually started yesterday
because we ‘re doing a workshop

00:00:10.644,00:00:15.649
uh for some reason nobody really
wanted to do anything
interactive in the workshop and

00:00:17.718,00:00:23.724
that means the challenges are
all three still unsolved. And
those are smart contracts on

00:00:23.724,00:00:28.729
Ethereum main-net so if you look
at those and then this is
actually a little bit funny

00:00:31.365,00:00:37.638
because somebody tried to solve
the challenge but in the process
of doing so he failed and he

00:00:37.638,00:00:42.943
added even more ether to the
complex so now you can add you
can win a little bit more. And,

00:00:42.943,00:00:47.948
and this was his second attempt
which also failed. So if you’re
quick enough you can win a total

00:00:51.518,00:00:56.523
of one point five ether which
would be around three hundred
dollars worth. Uh and you find

00:01:01.461,00:01:08.302
this here, uh on this data
repository. Sure hope you can
read it, it’s uh smashing smart

00:01:08.302,00:01:13.307
contracts workshop or just
google for it. Alright um, start
this. [inaudible other voice] So

00:01:29.122,00:01:35.429
we are going to talk about
automated exploitations of smart
contracts on the Ethereum

00:01:35.429,00:01:40.434
doctrine. Um we are both from
ConsenSys um I’m chief hacking
officer, whatever that means, at

00:01:43.971,00:01:48.976
MythX. Daniel is an Auditor and
Researcher at ConsenSys
Diligence who do uh security

00:01:51.478,00:01:56.483
audits for smart contracts. Um,
so uh normally we uh, have
developed a tool to create more

00:01:59.486,00:02:05.726
secure smart contracts we also
do some offense research because
we want to stay on top of our

00:02:05.726,00:02:12.532
game. Uh there’s a lot of other
people who contributed in some
way to this talk. Uh and the

00:02:12.532,00:02:19.406
code we are going to show, so we
are going to show four tools
today, three of which are, um

00:02:19.406,00:02:25.379
introduced for the first time.
Uh and there were a lot of
contributors involved so all of

00:02:25.379,00:02:30.384
this is open source uh the MythX
Core Team, the ConsenSys
Diligence guys, um Sam Sun who

00:02:34.621,00:02:40.193
is a very famous researcher who
contributed some of this uh bot
research and the Ethereum

00:02:40.193,00:02:45.198
security community general which
is small but really awesome. So
uh what we’re going to cover is

00:02:49.369,00:02:54.374
uh first of all symbolic
execution of automatically
detecting bugs in EVM bytecode.

00:02:56.543,00:03:01.481
And we’re going to focus on
instances of bugs where uh the
attackers steals ETH, ETH is the

00:03:04.284,00:03:10.524
native currency of the Ethereum
block chain from other
contracts. So the goal is always

00:03:10.524,00:03:16.430
to increase your own balance in
some way. Uh we are then going
to show how to automate this

00:03:16.430,00:03:23.403
exploit and uh, basically write
a script kitty tool that you run
against the contract and we load

00:03:23.403,00:03:28.408
everything out of the box and
then we’re going to show how to
exploit people who are using

00:03:30.877,00:03:36.149
these tools by tricking them
into sending your ether because
they don’t know what they’re

00:03:36.149,00:03:41.154
doing. And then on the next
level we’re going to show you
how to exploit people who

00:03:43.156,00:03:48.161
exploit people who use these
tools. So it’s kind of um a
layered approach. A very brief

00:03:52.532,00:03:59.239
intro into Ethereum. Ethereum uh
is a block chain network and
it’s a distributed state machine

00:03:59.239,00:04:04.177
so you have to uh so-called war
state and there’s a huge network
of nodes and they all agree on

00:04:06.713,00:04:11.718
the same state. Which includes
uh, account balances so uh there
are, there’s includes an account

00:04:15.822,00:04:20.827
and every account has a balance
and each time a transaction gets
accepted into the block change

00:04:24.397,00:04:29.236
this changes the state in some
way so it might decrease one
accounts balance and increase

00:04:29.236,00:04:35.775
another accounts balance. And
the network is commissionless,
anybody can send transactions

00:04:35.775,00:04:40.780
but they have to follow the
consensus rules of the block
chain. So what um makes Ethereum

00:04:45.385,00:04:52.092
different from bitcoin is that
uh you have a lot more
flexibility of how uh

00:04:52.092,00:04:57.430
transactions can change the
block chains so you can deploy
small immutable programs called

00:04:57.430,00:05:02.369
smart contracts which are
basically um chunks of byte code
in a, uh written in a simple

00:05:05.172,00:05:11.878
stack based language. What’s
special about them first of all
is they are immutable so once a

00:05:11.878,00:05:17.217
smart contract is deployed to
the chain and you have consensus
that the smart contract exists

00:05:17.217,00:05:23.056
it can never ever be changed. So
it’s much more like uh real
world contracts where you have a

00:05:23.056,00:05:28.061
set of rules that everybody
agree to uh adhere to then like
an app that you can update

00:05:30.630,00:05:35.635
anytime data. From the view of
symbolic execution, a couple of
things that’s interesting. First

00:05:38.405,00:05:43.410
of all executing an instruction
uh on the Ethereum publishing
costs gas which is maid in

00:05:45.712,00:05:50.717
ether’s Ethereum’s native
current Ether uh and that’s a
spam protection because uh

00:05:53.320,00:05:58.325
computation is expensive because
every node in the system needs
to run the same code, right. And

00:06:01.461,00:06:07.133
that means that in a single
transaction you can only do a
limited amount of uh computation

00:06:07.133,00:06:12.639
which is good for symbolic
analysis because it mitigates
the space explosions so there’s

00:06:12.639,00:06:18.578
only limited amount of states
you have to look up. But on the
other hand the bold state can be

00:06:18.578,00:06:24.217
mutated over subsequent
transactions so you can
basically split up your

00:06:24.217,00:06:29.222
computation into little chunks
and uh that makes symbolic
execution challenging again

00:06:31.558,00:06:36.563
because you run into the
traditional problems of state
space explosion and so on. So

00:06:39.132,00:06:44.137
brief primer on symbolic
execution uh here you will see a
very simple smart contract

00:06:48.942,00:06:54.948
that’s written in solidity which
is the most popular language at
the moment. And the smart

00:06:54.948,00:06:59.953
contract represents at cat, in
this one function. And this
function either extends the cats

00:07:02.522,00:07:07.894
live or it kills the cat. And
there’s a very interesting
instruction in solidity calls

00:07:07.894,00:07:12.899
self destruct. What this, uh
instruction does is um, so it
was originally called suicide,

00:07:17.270,00:07:23.576
essentially the contract is
going to kill itself, it’s going
to delete it’s own code, uh and

00:07:23.576,00:07:28.581
free it’s storage and um, send
it’s remaining balance to an
arbitrary address that you

00:07:30.583,00:07:35.588
specify here. In this case, uh
this zero address. So if you
look at this program there are

00:07:38.491,00:07:43.496
two outcomes that can happen
right if this put in variable is
true then grant survival is

00:07:47.901,00:07:52.906
false, uh sorry is true. And the
cat will not be killed, will
reach no more stop state but on

00:07:58.511,00:08:03.950
the other hand if it is false we
will reach a self-destruct
instructions so these are the

00:08:03.950,00:08:10.457
two possibilities that can
happen. So what we do in
symbolic execution now is that

00:08:10.457,00:08:15.462
we uh every time we reach a
condition of jump we follow them
both paths and we annotate each

00:08:20.266,00:08:25.271
test um so if-if you look at
this as um, control flow graph
we annotate each path with the

00:08:28.241,00:08:33.246
path constraints imposed by the
jump condition. Right so we can
say that uh, if the first

00:08:35.849,00:08:40.854
function argument is true and
this is actually looks a bit
complicated because that’s why

00:08:43.490,00:08:49.996
uh solidity compiler produces
but it ends up meaning, if it’s
true then the cat survives, if

00:08:49.996,00:08:56.202
it’s false the cat dies. And so
y-you could think about the cat
being in both states

00:08:56.202,00:09:01.141
simultaneously and what that
allows us to do now is uh we can
ask if we want to reach the

00:09:06.446,00:09:12.786
state where the cat dies what
are the input variables we have
to supply to the program and we

00:09:12.786,00:09:17.791
can do that by passing this uh
path formula or this proposition
to uh SNT server, uh we use set

00:09:21.461,00:09:27.100
three in this for example and
this will give us the correct
input values that we need to

00:09:27.100,00:09:33.840
send. Uh and this uh proposition
can be arbitrarily complex right
so we can look at very complex

00:09:33.840,00:09:38.845
programs that have many input
variables but we will always get
the correct result. So I’m not

00:09:41.581,00:09:46.586
going to into much more detail
um because we actually practiced
this talk a couple of days ago

00:09:49.022,00:09:55.862
and it turned out to uh take
about three hours to do
everything so uh we have to cut

00:09:55.862,00:10:01.968
things down a bit. But if you’re
interested, there's a good
execution uh um a good summary

00:10:01.968,00:10:07.907
by my colleague Joran talking
about symbolic execution and
then there’s a paper I wrote

00:10:07.907,00:10:12.912
last year called Smashing Smart
Contracts, it goes into a lot of
detail. I can also recommend uh

00:10:14.981,00:10:21.921
this paper, Gnawing at Ethereum
and there’s a lot of other stuff
you can just find on google, we

00:10:21.921,00:10:26.926
have a few more references at
the end of the talk. Right so
our symbolic execution tool is

00:10:30.396,00:10:35.401
called Mythril and it’s designed
with simplicity in mind. So if
you want to use it you can

00:10:38.605,00:10:43.610
install it python three and you
can either analyze solidity code
for us or contract addresses at

00:10:48.982,00:10:53.987
either the main net or a test
net or um whatever you’d like.
And I’m gonna show you a very

00:10:58.157,00:11:03.096
brief game of what it looks like
so, this is a killable smart
contract and it has a kill

00:11:07.500,00:11:12.505
function that uh calls self
destruct and this one
prerequisite that we have to

00:11:17.744,00:11:22.749
fulfill so you need to be in the
mapped of allowed addressed that
are allowed to kill the contract

00:11:25.084,00:11:30.490
right so you have to call a
sequence of transactions, the
first one is set allow to set

00:11:30.490,00:11:35.495
this mapping to true and then
you need to set kill. And so
this might look like a very

00:11:38.331,00:11:44.270
simple demo but it’s actually
something that happened in
practice so I, in two thousand

00:11:44.270,00:11:49.275
sept- seventeen uh there was a
heck of the parody wallet
library that in principle was

00:11:53.012,00:11:59.152
very simple so there was an in-
initialization function that was
exposed and by calling that

00:11:59.152,00:12:04.090
function you could kill that
contract and that lead to I
think uh one hundred fifty

00:12:06.259,00:12:11.831
million dollars being vaporized
basically so the owner is stuck
in this contract forever and

00:12:11.831,00:12:16.836
nobody can ever access those
ether again. So just gonna show
you a small video of how

00:12:22.308,00:12:27.313
Mythril, so you run uh myth
analyze against the source code
and the output will be a

00:12:36.289,00:12:41.294
sequence of transactions that
leads you to uh the kill
instruction, but it will also

00:12:52.705,00:12:58.878
compute the instructions in a
way that the remaining ether
gets sent to your account. But

00:12:58.878,00:13:03.816
so if you call set allowed and
in this case dead beef, dead
beef, dead beef represents the

00:13:06.653,00:13:11.457
attackers address you would
replace that with your own
address uh in the second

00:13:11.457,00:13:16.462
transaction you call kill to
kill the contract and then you
can see that this first argument

00:13:19.465,00:13:26.239
specifies where the remaining
ether should be sent. And that’s
also the attacker, that dead

00:13:26.239,00:13:32.111
beef, dead beef. So if you just
replace this with your own
address you will get the ether

00:13:32.111,00:13:37.116
out of that contract. So that
was a very simple example but um
Mythril can also solve more

00:13:41.521,00:13:46.526
complex stuff, that, that goes
deeper into, into the contracts
and so if you get started in

00:13:49.095,00:13:54.100
Ethereum security uh a very good
idea is to check out um CTFs and
challenges and some of the best

00:13:54.100,00:13:56.102
ethernaut uh open zeppelin,
capture the ether by Steve Marks
and the block chain ctf, dot

00:13:56.102,00:14:01.040
security innovation and I just
put a couple of examples to show
how our tool can uh solve this

00:14:13.519,00:14:18.524
challenges out of the box. So if
you look at this code here. Uh
you can see that this little bit

00:14:25.031,00:14:31.537
more evolved, so we have a
withdraw function that withdraws
the contract balance to the

00:14:31.537,00:14:37.477
ether and we have a contribute
function where somebody can
contribute a little bit of ether

00:14:37.477,00:14:42.482
and then uh some mappings will
be set and you will be added to
uh um this mapping here. And

00:14:48.688,00:14:52.859
then there’s a fall back
function fall back function
means a function with no name

00:14:52.859,00:14:57.864
that gets called when none of
the function signatures matches
and this may override the owner

00:15:00.700,00:15:06.405
with your address. And there’s
several ways of how you could
exploit this but there’s one was

00:15:06.405,00:15:11.410
that’s more profitable right,
send the least amount of ether
for the most output and Mythril

00:15:14.580,00:15:20.720
can compute it for you so, so I
will not show the video now I
will just tell you what you have

00:15:20.720,00:15:25.725
to consider when running Mythril
here. So the first thing is that
these um, vulnerability is three

00:15:29.562,00:15:34.567
transaction deep and by default
Mythril only symbolically
executes 2 transactions and so

00:15:39.605,00:15:44.510
the thing is with symbolic
execution the state of space
that you need to investigate

00:15:44.510,00:15:49.515
grows exponentially so the more
you set here the longer the
analysis will take and for like

00:15:51.684,00:15:56.689
more real life complex contracts
it can be quite a while, up to
many hours or even days. Um, so

00:15:58.825,00:16:05.131
the default is two, and if you
run it with a with a default you
will not discover anything here.

00:16:05.131,00:16:12.104
So here you would have to set
three transactions and execution
time out if you want that will

00:16:12.104,00:16:18.544
abort the execution uh if it
goes over the time lot because
you might not be willing to wait

00:16:18.544,00:16:23.549
a couple of days for a result.
So what you get here again is
the correct transaction sequence

00:16:27.753,00:16:32.758
to maximi- maximize your profit
and what you do is, you
contribute exactly one way which

00:16:35.561,00:16:40.566
is the very smallest uh
denomination of ether, basically
like a billionth ether so and

00:16:44.604,00:16:49.609
then you call code back with one
way and then you call withdraw
and this will give you the whole

00:16:54.046,00:17:00.820
contract balance. Alright. So I
briefly mentioned the state
space explosion problem so look

00:17:00.820,00:17:07.527
at this contract there, there’s
a lot of functions with
dependencies on each other and

00:17:07.527,00:17:12.531
what Mythril does is it uh
executes smart contract code in
iterations and once you find out

00:17:15.501,00:17:20.973
where the stop state is it will
use for a starting state for the
next transaction so you can see

00:17:20.973,00:17:27.747
that the space of states to
explore grows uh very fast. And
for something like this that you

00:17:27.747,00:17:32.752
need six or seven transactions
it can be quite a while. And a
couple of ways that we used to

00:17:35.254,00:17:40.259
um address this problem uh the
main way is pruning algorithms.
So what we’re trying to do is

00:17:42.295,00:17:47.300
figure out which path is
actually relevant to explore,
that means for instance, uh if

00:17:51.170,00:17:57.743
you exec-execute a transaction
and the machines state at the
beginning is complete identical

00:17:57.743,00:18:03.849
to at the end, like if you
execute a pure function of U
then you can safely discard its

00:18:03.849,00:18:08.854
state because running another
round of simply execution will
not get you any new results. You

00:18:11.490,00:18:16.996
can also do reachability checks
so at each basic block we can
check whether the constraints

00:18:16.996,00:18:23.402
can actually fulfill or not,
this also gives us a nice speed
up. And the probably most

00:18:23.402,00:18:28.407
advanced thing we do is uh to
look at dependencies in between
transactions. So once we execute

00:18:31.243,00:18:36.248
the first transactions we build
a map of state reads and writes
and as soon as we come to the

00:18:38.384,00:18:45.358
second transactions uh we have
some rules uh that allow us to
discard a lot of the path that

00:18:45.358,00:18:51.764
we encounter. Uh for instance if
there was a state where was
modified in the previous

00:18:51.764,00:18:56.769
transactions that was accessed
some will allow that path, uh we
know we need to execute the path

00:18:58.904,00:19:04.910
because we might be discerning
new pieces of code or new
behavior but i-if none of these

00:19:04.910,00:19:09.915
things are fulfilled we will
just not execute the path. Just
to show you um, how this looks

00:19:20.926,00:19:27.400
like, so this is a state space
graph of a typical three
transaction execution and you

00:19:27.400,00:19:32.405
can see execution here started
at push zero uh and as we get
further down we will reach

00:19:37.476,00:19:42.481
several stops and one of these
for example is here. Sorry for
that. So a, uh, if you look at

00:20:11.243,00:20:18.084
th-this basic block here you
will see that um execution
starts from a program counter at

00:20:18.084,00:20:23.089
zero again and, and then you get
this tree of exponentially
growing states. And that’s not a

00:20:25.291,00:20:30.296
good thing because it makes uh
execution really slow. Alright
[laughter] so with pruning

00:21:02.461,00:21:07.466
enabled you can see we can
reduce the number of states
quite considerably uh an example

00:21:07.466,00:21:12.471
I showed you before it’s down by
sixty two percent and this gives
us a nice speed up and we run

00:21:14.473,00:21:19.478
some benchmarks on uh the SWC,
smart contract weakness registry
and you got speed ups that

00:21:22.915,00:21:27.920
compound over time with number
of transactions as you reach
less stop states its uh it gets

00:21:31.056,00:21:37.229
quite fast but that doesn’t mean
that it doesn’t still grow
exponentially so you’re still

00:21:37.229,00:21:44.036
look a lot of other things you
can do. Including um,
parallelization, so obviously we

00:21:44.036,00:21:49.041
could use uh modern one core to
run analysis. Sate merging which
is one of the techniques used by

00:21:53.379,00:22:00.219
Manticore and function summaries
means uh instead of executing
functions over and over again,

00:22:00.219,00:22:05.224
uh you create summaries by uh by
looking at the constraints
exposed on memory and storage by

00:22:10.262,00:22:15.267
each functions and just um
reusing those instead of um
re-executing the code and uh

00:22:18.971,00:22:25.211
yeah this creates more complex
server queries but also speeds
up execution and reduced amount

00:22:25.211,00:22:30.216
of states you have to look at.
Sorry, we already um a little
bit over time so we very quickly

00:22:32.751,00:22:37.756
show you a demo of Scrooge
McEtherFace which is the next
two. So what this do is, uh it

00:22:54.740,00:22:59.745
creates the exploit transactions
uh creates from Mythril and it
just sends them to the block

00:22:59.745,00:23:05.551
chain and it gives you uh
interactive CLI, you can tamper
around with the transactions a

00:23:05.551,00:23:12.191
bit. So this is gnash which is a
local test node, you can see
here you have several test

00:23:12.191,00:23:17.196
accounts and the attackers
account is the second one here,
it starts with a hundred eth, so

00:23:22.635,00:23:27.640
I’m not gonna deploy to this
test block chain uh version of
wallet library which is actually

00:23:30.509,00:23:35.514
the library I mentioned it was
exploited in real life before.
And I’m gonna give you a little

00:23:38.450,00:23:43.455
bit of balance, five ether. So
you can see it was created and
that balance was deducted from

00:23:50.195,00:23:55.200
the creator account now I’m
gonna set up scrooge with the
config he needs to connect to my

00:24:00.839,00:24:07.680
local node. And so now it, it’s,
this is really really script key
friendly so the only raw data it

00:24:07.680,00:24:12.685
takes is the Ethereum address,
it will automatically detect the
exploit. So in this case you can

00:24:14.753,00:24:19.758
see the contract can be killed
by anyone and what gave the two
is uh sent this exact sequence

00:24:21.860,00:24:26.865
of transactions. And you now get
uh class interface that you can
interact with. Uh you got a list

00:24:33.172,00:24:38.177
of raids and each raid is
represents an attack and this
raids have stops that you can uh

00:24:40.446,00:24:45.451
either first manipulate or
execute one by one. And uh yeah,
so call function one with this

00:24:48.520,00:24:53.525
argument, call function two with
another argument. And then you
simply call execute. So

00:25:01.633,00:25:07.706
transactions have been sent and
actually also checks if your
attack was successful and if

00:25:07.706,00:25:12.711
your balance has increased and
in that case it gives you a
Boolean true back. So you can

00:25:17.383,00:25:22.388
see the attacker now has gained
five ETH. Which is um a thousand
dollars I think at the moment.

00:25:24.390,00:25:29.395
But, so that’s our tool. Full
screen. Demo. So, n-now that you
have this tool you could imagine

00:25:44.109,00:25:49.081
it would be very easy to use it
and steal stuff but
unfortunately the Ethereum

00:25:49.081,00:25:54.086
main-net is a very tough
environment and it’s not all
that easy. So i-if you may use

00:25:56.321,00:26:01.260
these tools there will be uh, a
lot of people uh out to exploit
you. One of them is uh,

00:26:03.762,00:26:10.602
Frontrunning Bot. So it will
actually monitor the main net
for exploits being executed and

00:26:10.602,00:26:15.441
uh Daniel’s going to talk about
that a bit and it will try to
preempt you and steal your

00:26:15.441,00:26:22.347
exploit and execute it faster
than you and actually make your
exploit fail. And then there’s

00:26:22.347,00:26:27.886
also fake exploitable contracts
called honey pots that for
example might know that all

00:26:27.886,00:26:34.092
truths have some false positives
and they might make it look like
they’re vulnerable but if you

00:26:34.092,00:26:40.132
actually execute the attack they
wont and they’ll just re-fire to
send a bit of ether and then

00:26:40.132,00:26:42.267
make your attack fail. It’s
super dangerous. So I’m going to
hand it over to. >>Okay so uh

00:26:42.267,00:26:44.269
once again I’m Daniel Luca you
can find me online at clean
unicorn. Uh kind of felt like I

00:26:44.269,00:26:46.271
have to be a white hat with
clean unicorn, dirty unicorn was
taken. But anyway, okay so I

00:26:46.271,00:26:51.276
have two tools I’m going to show
you. Um t he first one is Karl,
it’s purpose is to um mass scan

00:27:13.098,00:27:18.604
Etheruem network and find
vulnerable contracts. It will
generate like uh local reports

00:27:18.604,00:27:24.943
that you can reuse then and the
second one is a Theo. It’s more
specific because after you find

00:27:24.943,00:27:30.949
the vulnerable contract you will
actually um find a way to, it
will actually enable you to

00:27:30.949,00:27:35.954
exploit that contract. So um,
Karl. It, it does mass
continuous recon, so that means

00:27:38.590,00:27:44.496
it watches the block chain all
the time so you can, you can um
start it, it will scan all

00:27:44.496,00:27:49.535
blocks, it will scan all
transactions and see if any of
the transactions generate new

00:27:49.535,00:27:55.941
contract on the block chain and
if they do that it uh pulls up
the, the code uh it pulls up

00:27:55.941,00:28:01.313
the, the state and finds and
tries to find if it’s um tries
to find out if it’s vulnerable.

00:28:01.313,00:28:06.285
It uses Mythril for that,
b-because it’s written in um
python. You can use the Mythril

00:28:06.285,00:28:12.357
libraries directly. It does
exploit generation and it also
does uh exploit validation

00:28:12.357,00:28:17.362
because sometimes there are
vulnerable um, false positives
but it has a way to reduce that

00:28:19.531,00:28:24.536
number of false positives. So um
this how like the, the main the
core of uh Karl. It uses as I

00:28:29.374,00:28:33.445
said it uses the Mythril
libraries so we can, you can
build this yourself if you know

00:28:33.445,00:28:40.118
a bit of python you can uh
import libraries uh start up the
Mythril disassembler, you uh

00:28:40.118,00:28:46.592
point it to uh Ethereum node and
then you tell it to um load from
the address, the contract

00:28:46.592,00:28:52.998
address so that means it knows
who to scan. And then you start
the Mythril analyzer, it has

00:28:52.998,00:28:58.537
some parameters that you can
play with. Um for example uh the
timeout, the number of

00:28:58.537,00:29:03.475
transactions um what, um what
modules to test so for example
the uh default module that I’m

00:29:07.879,00:29:14.653
using is stealing ether and self
destructing contract, you can,
you can create others and

00:29:14.653,00:29:21.493
they’re already others available
in Mythril. And it generates or
reports something like this. So

00:29:21.493,00:29:27.265
for example with this report uh
we have unprotected ether
withdraw so there’s the smart

00:29:27.265,00:29:32.270
contract , um ID, problem IDs
like one oh five, I always for
this um, this um thing so the

00:29:38.343,00:29:43.982
severity is high because you can
extract ether and then it tells
you some other uh information

00:29:43.982,00:29:47.719
like what’s the contract address
but you kind of already know
that because you were uh

00:29:47.719,00:29:53.692
scanning for it, the uh
estimated guest usage and it
takes description just so you

00:29:53.692,00:29:58.397
have an idea of what you can do
with it. At the end of that you
can see the transaction sequence

00:29:58.397,00:30:04.503
so what transactions do you need
to send in order to get ether
out of that contract so it makes

00:30:04.503,00:30:09.508
it really easy for you. The
problems sometimes is that you
find the transaction sequence

00:30:12.010,00:30:18.016
but it’s kind of hard to make
sure that that indeed works. As
I said sometimes there are um

00:30:18.016,00:30:23.021
false positives. Um its, it
helps if you know assembler, if
the source code is available, if

00:30:28.960,00:30:35.867
um if you have a-all of that
available but even then it’s
still kind of hard. So there,

00:30:35.867,00:30:42.474
Karl always has implemented the
technique to help you validate
the exploit. So it uses uh it

00:30:42.474,00:30:47.479
still uses gnash, so just to gn-
a small intro, uh gnash is uh
local Ethereum development node.

00:30:50.816,00:30:56.555
Um, and it just generates a
local network for you. Nobody
else can connect to it, but it

00:30:56.555,00:31:01.693
behaves exactly the same as the
Ethereum network. So that means
you can simulate all of the

00:31:01.693,00:31:06.698
transactions and see if that
works. So how it actually does
is that it forks the main block

00:31:11.069,00:31:16.074
chain and uh it sends a
transactions to that, but when
people usually hear forks, it’s

00:31:19.311,00:31:23.515
something like there is
contentious forks, like people
are fighting, there are two

00:31:23.515,00:31:29.287
communities and they want to
develop the um the network in uh
two different directions.

00:31:29.287,00:31:34.526
Something that one feature would
be the best, others think that
another incompatible feature

00:31:34.526,00:31:39.765
will be the best. So what
usually happens with forks is
that the community splits into

00:31:39.765,00:31:45.971
two and then you have two
different uh networks. Uh if you
know for example bitcoin and

00:31:45.971,00:31:50.976
bitcoin cash or Ethereum and
Ethereum classic these are two
very popular examples. But what

00:31:53.278,00:31:59.117
I actually use is like the
technical part of forking the
block chain. So in this example

00:31:59.117,00:32:05.157
on the top part, you, you see
the real block chain and let’s
sat that Karl identified that in

00:32:05.157,00:32:11.863
block one hundred there was a
contract that was deployed and
then I need to make sure that

00:32:11.863,00:32:18.637
this actually works. So what I,
what Karl does is that it starts
gnash and then it creates

00:32:18.637,00:32:23.642
different future for that block
chain. So for example, block one
oh one is local, it’s only on my

00:32:26.111,00:32:32.784
machine, the, the top one is a
real and the bottom one is
local. So then in block one oh

00:32:32.784,00:32:39.324
one I can add my own
transactions and see in the next
block if indeed I exploited that

00:32:39.324,00:32:44.329
contract. So this is uh pretty
safe because you’re not sending
the transactions to the main net

00:32:46.665,00:32:53.004
you can actually see if you did
a good job and exploited the
contract and nobody else can see

00:32:53.004,00:32:58.009
the transactions, nobody could
front run you, nobody could do
anything to you. Um so I have a

00:33:00.679,00:33:05.684
demo for Karl. So um, in this
example I start Karl, I point it
to Inferion main net, which is

00:33:15.560,00:33:21.666
uh public Ethereum node if you
want you can use, and also ask
it to start from a specific

00:33:21.666,00:33:27.239
block. Um, I do that because I
already deployed a block, um
contract there and I know it’s

00:33:27.239,00:33:34.045
vulnerable. Otherwise most of
the time you wouldn’t see
anything. I enable sandboxing

00:33:34.045,00:33:40.585
which is the forking technique
um which um, uh creates the
local block chain and tests uh

00:33:40.585,00:33:45.590
th-the exploit generated and I
also e-enable uh the output to
the folder. Just so in the

00:33:47.926,00:33:54.566
figure I can have a list of
files with the exploits
available. So it’s scanning this

00:33:54.566,00:33:59.571
block, it found a contract, it
finds one issue but it's also
firing the sandbox tester. So

00:34:02.073,00:34:06.177
it, in this case it’s quite
fast, you can see that you have
an initial balance of one

00:34:06.177,00:34:12.584
hundred and you have a final
balance of one oh one point one.
So that means uh that the

00:34:12.584,00:34:14.586
exploit is uh, is valid and you
could use this and um, exploit
the contract. This contract, I

00:34:14.586,00:34:16.588
think it still exists on the
main net and nobody, a-actually
exploiting it so I’m, I’m super

00:34:16.588,00:34:18.590
sad about that. So what Karl
does next is that, it takes the
next block it checks uh the

00:34:18.590,00:34:20.592
contract and scans everything.
So it goes through all of the
blocks. And you could just leave

00:34:20.592,00:34:22.594
this over night and come back in
the morning and see if you found
some, some vulnerable contracts.

00:34:22.594,00:34:24.596
So the next tool is Theo. Theo
picks up where Karl left off, so
Karly just generates a list of

00:34:24.596,00:34:29.601
contracts but Theo can actually
exploit them. So um, it is kind
of on exploitation framework

00:34:43.081,00:34:48.086
because it helps you do some
kind of recon. Uh you can check
somethings on the main net, um

00:35:09.708,00:35:14.713
you can run the exploit and we
also have some uh features that
are front running, back running

00:35:20.385,00:35:25.390
or sandwiching transactions and
I’m going to go into detail
about that. But first you need

00:35:29.995,00:35:35.000
to understand what the Mempool
is. So um miners exist on the
main net and they have a list of

00:35:38.903,00:35:44.609
local transactions that were not
added to the block yet. That
means that these transactions,

00:35:44.609,00:35:48.913
if they will be added to the
block they will actually start
to exist, it will actually

00:35:48.913,00:35:53.918
happen. Before that, they’re not
real. They are pending
transactions. So this miner has

00:35:56.654,00:36:00.859
the list of um, a few
transactions and then they
receive from the network a new

00:36:00.859,00:36:06.965
transaction so that means that
they will add it to their
mempool list, what actually

00:36:06.965,00:36:11.436
happens in the network is that
you have all of these miners uh
people who want to send

00:36:11.436,00:36:16.207
transactions through the
network, send to one random or
less random node and then

00:36:16.207,00:36:21.279
everybody sends the transactions
among each other. In the end
they k-all kind of have the same

00:36:21.279,00:36:28.253
mempool but not exactly. The
idea is for everybody to have
uh, as many transactions as

00:36:28.253,00:36:33.992
possible just to have them
mined. The cool thing is that
you don’t need any permission to

00:36:33.992,00:36:38.897
be part of the network. So if
you look in, in the bottom part
you can see a hacker who can

00:36:38.897,00:36:45.103
listen to the mempool and see
what transactions will happen on
the network but were not mined

00:36:45.103,00:36:50.108
yet. Another important part is
transaction ordering. So the
miners every time they find a

00:36:54.712,00:36:59.717
block they get reward they get
some ether, but they also get
some fee, each transaction has a

00:37:01.820,00:37:08.526
fee attached to it. And uh when
they add the transaction to the
block, they also get that fee.

00:37:08.526,00:37:14.365
So there incentivized to add as
many transactions as possible
and to the transactions as

00:37:14.365,00:37:19.370
profitable as possible for them.
So the transaction fees get
created by gas and gas price. Um

00:37:21.573,00:37:26.578
the gas part is for each
instruction there is a number of
gas added so you need to pay for

00:37:29.280,00:37:34.752
uh complicated computation for
example if you do some
cryptography, if you do some um

00:37:34.752,00:37:40.492
square um operations, you will
pay more than compared to uh a
simple addition or a simple

00:37:40.492,00:37:45.497
subtraction. So you have gas
time gas price. And the gas
price is set by the sender. If

00:37:48.766,00:37:54.772
they want to their transaction
to happen faster they will have
a bigger gas price otherwise

00:37:54.772,00:37:59.777
they will have a lower gas
price. So w-when the miner um,
creates the list to add the

00:38:01.779,00:38:07.385
transactions in the block they
will usually sort the
transactions descending by gas

00:38:07.385,00:38:14.058
price. And they will add as many
as possible until they fill up
the block. So in this case we

00:38:14.058,00:38:18.396
can see that the first
transaction added um has gas
price five thousand, The second

00:38:18.396,00:38:23.401
one is two, two thousand and
one, the third one is two
thousand, s-and so on and so on.

00:38:26.171,00:38:32.310
So frontrunning happens, like
the idea of frontrunning is that
you have an information about

00:38:32.310,00:38:37.315
what somebody’s going to do in
this case you see what the
mempool is going, is, uh, has uh

00:38:39.918,00:38:44.923
in there but didn’t happen yet
and you raise them and you do
that action first. So in this

00:38:47.091,00:38:52.397
case the hacker can see the
transaction, they see that um,
a, a specific contract uh is

00:38:52.397,00:38:54.399
called the gas price of that
transaction is five thousand, a
specific method is called and

00:38:54.399,00:38:56.401
once they do that once they see
that they can add their own
transaction. So we know with

00:38:56.401,00:38:58.403
frontrun the easiest way is just
to take the transaction add one
to the gas price so that means

00:38:58.403,00:39:00.338
that the miners by sorting,
sorting descendingly the
transactions by uh gas price

00:39:00.338,00:39:02.340
yours will be ahead of theirs.
So I have um an example but
first I need to go with you for

00:39:02.340,00:39:04.342
um through the contract. So we
have a contract with two methods
they are uh the two important

00:39:04.342,00:39:09.347
methods in this example You can
claim ownership but the
important part of claiming

00:39:40.511,00:39:45.884
ownership sh- uh you h- uh this
transaction does two things. It
accepts zero point one ether and

00:39:45.884,00:39:52.857
you need to send that and if the
contract was not claimed by
anyone it will make you um the

00:39:52.857,00:39:59.731
player of the contract. The
second transaction um, checks if
you aren’t the player of the, of

00:39:59.731,00:40:04.736
the contract and if indeed you
are they send you all of the
ether available in the contract.

00:40:06.904,00:40:12.210
The cool thing is that if you’re
the first to do this you will
become the player but if you are

00:40:12.210,00:40:17.215
the second, you just add more
ether to the contract. So I can
show you a demo and h- um you

00:40:21.786,00:40:26.791
can um what we did is that we
made uh honey pot off this. And
um, this is how it works. So in

00:40:38.236,00:40:42.240
this screen I have uh local
guest node which his the
official Ethereum

00:40:42.240,00:40:48.813
impl-implementation so it’s just
mining, it’s just creating
blocks at the moment. And in

00:40:48.813,00:40:54.385
this screen I have um a local
ID, to web ID that people can do
to deploy contracts and test

00:40:54.385,00:41:01.225
contracts. So I already have
this, um contract deployed, it
has uh, I think ten ether

00:41:01.225,00:41:06.664
attached to it. And it needs
zero point one ether from the
attacker to claim all of those

00:41:06.664,00:41:11.669
ten ether. Okay so now I tart
Theo, I provide Theo uh the
accounts private key because

00:41:18.910,00:41:23.715
Theo needs to have an account in
order to send transactions so he
needs to be able to sign

00:41:23.715,00:41:28.720
transactions and send them to
the network. And then I also
need to provide the contract.

00:41:31.723,00:41:37.128
Um, what it does now is it uses
the mythril libraries it scans
the contract and it finds uh the

00:41:37.128,00:41:42.133
exploit back. You can also, uh
add your own transactions so it
found a vulnerable path, uh it’s

00:41:46.070,00:41:51.743
very similar to what uh Karl
does, to what scrooge does. So
let’s say for example um scrooge

00:41:51.743,00:41:57.215
is trying to exploit this
contract. So what I do now is
that I just extract the first

00:41:57.215,00:42:02.153
exploit. And I start
frontrunning so what does now
its just scanning the mempool

00:42:04.989,00:42:11.696
for new transactions. So it just
looks at the mempool, it queries
the Ethereum node every second

00:42:11.696,00:42:17.835
or so and it sees, it, it checks
if any interesting specific
transactions is added to the

00:42:17.835,00:42:22.840
mempool that will be added in
the next block. If that happens,
we will see what, what it does.

00:42:25.710,00:42:30.715
So Um, now I’m simulating th-
attacker or scrooge so I’m
changing to uh zero XSC, this is

00:42:34.752,00:42:40.024
the attacker or the script keyed
in. he needs to add zero point
one ether, he needs to call

00:42:40.024,00:42:45.596
claim ownership so he’s trying
to uh extract that ether, he’s
trying to become the owner or

00:42:45.596,00:42:50.601
the player of the contract. And
what immediately happens is that
Theo sees that transaction and

00:42:53.337,00:42:59.510
it adds uh, it’s own
transaction, it increase the gas
price just make sure that uh

00:42:59.510,00:43:04.449
Theo’s transaction will happen
before the script kitty’s. The
script kitty will also try to

00:43:06.684,00:43:13.324
retrieve the ether out of the
contract Theo also identifies
that and it’s uh sending its own

00:43:13.324,00:43:18.329
transaction and um hopefully at
the end we will have, we will
see more ether in our um, in our

00:43:23.267,00:43:29.340
account. So Theo’s account is
zero x one the F the one that we
see now, it’s um a hundred and

00:43:29.340,00:43:34.345
ten ether so it successfully
exploited that um, that script
kitty. So um this was all done

00:43:44.489,00:43:49.494
locally and then we thought what
if it actually works in the
wild? And we had to test it and

00:43:53.631,00:44:00.538
um, what we see here is that we
deployed a very similar honeypot
and this is the victim’s

00:44:00.538,00:44:05.243
transaction about an hour later
somebody tried to exploit the
honey pot. We also added this

00:44:05.243,00:44:09.714
contract source code to make it
easier for them to exploit. They
didn’t know that something was

00:44:09.714,00:44:16.687
up and they added they send the
transaction with um, a h- very
high gas price, I think they

00:44:16.687,00:44:21.592
were trying to make sure that
their transaction will get
picked up really quickly and so

00:44:21.592,00:44:25.062
in this case you have two
hundred sixty one point twelve
gwei. And the nonce and the uh

00:44:25.062,00:44:27.064
the position in the block is
one. And Theo’s transaction was
um, two hundred and sixty one

00:44:27.064,00:44:29.066
point thirteen gwei which is
like the minimum necessary to uh
frontrun the transaction and the

00:44:29.066,00:44:34.071
nonce was zeros and because
we’re, I, everything starts zero
it was just before the attackers

00:44:50.655,00:44:57.128
uh transaction. So that means
that uh they became the owner
and they also got the attackers

00:44:57.128,00:45:03.968
ether. So there are cases when,
when this actually works. You
have to deploy your own

00:45:03.968,00:45:09.106
honeypots and you have to design
them in a specific way to make
them vulnerable for front

00:45:09.106,00:45:15.713
running. In your case it also
helps if we share the source
code. And a very interesting

00:45:15.713,00:45:22.420
example that might um have a
bigger impact is with
decentralized exchanges. So

00:45:22.420,00:45:26.457
decentralized exchange is
something like uh normal
exchange but it, it exists on

00:45:26.457,00:45:31.295
the block chain so what you can
do is that you can sandwich the
other peoples transactions. So

00:45:31.295,00:45:35.900
for example you see that they
will buy something, you buy just
before they do and you sell

00:45:35.900,00:45:40.905
immediately after they bought so
you just, you earn some money by
doing almost nothing. And there

00:45:43.174,00:45:48.179
are some cases where it fails.
Um, it’s kind of hard to see
what a transaction does if they

00:45:51.048,00:45:56.854
use a proxy contract so they use
an app in between them and the
contract that they’re going to

00:45:56.854,00:46:01.792
exploit. It’s impossible to
frontrun if the miner uh is the
attacker and they add their own

00:46:04.428,00:46:08.899
transactions, so that means that
they don’t need to add the
transaction to the mempool

00:46:08.899,00:46:13.904
first. Um, sometimes the
Ethereum client decides to be
unresponsive but there are ways

00:46:16.440,00:46:21.445
to defend against Theo. So you
can create a contract yourself
and make sure that at the end of

00:46:24.715,00:46:31.689
the contract you have more ether
than what you initially started
with. And if you know that you

00:46:31.689,00:46:36.694
can also create the honey pot in
order to not be uh to to beat
this too. So there’s, there’s a

00:46:38.963,00:46:45.036
lot of where, i- it you, you can
fight a lot on the Ethereum
network and this is just like,

00:46:45.036,00:46:51.909
there, there are a lot of
layers. So um what I really want
is that I think we need more

00:46:51.909,00:46:56.347
hackers. I think there are not
enough people that are hacking
on the Ethereum network. I, I

00:46:56.347,00:47:01.585
might regret this but at the
moment I feel like we need more
of you guys to um, exploit the

00:47:01.585,00:47:06.590
network and find more problems
and just have fun. Um so we have
links, some links here so, these

00:47:13.564,00:47:19.570
are all the tools they are all
open source. Maybe one important
thing to say is all of the ether

00:47:19.570,00:47:24.575
that we stole from the people,
we gave it back. Um and uh, I
think that’s it. We’re um open

00:47:29.914,00:47:34.618
for questions I know there are
microphones but we can, we’re,
we’re available immediately

00:47:34.618,00:47:35.152
after this.

