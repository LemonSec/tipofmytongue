00:00:00.300,00:00:06.273
>> All right, so, once again.
Thank you all for coming out.
Um, let’s give Anish a big round

00:00:06.273,00:00:11.278
of applause and welcome him to
the stage. [Applause] Have a
great time, my friend. >>

00:00:14.047,00:00:19.887
Thanks. Thanks for the
introduction, Jurist. Uh, today
I am going to talk to you about

00:00:19.887,00:00:24.491
how we can build more secure
systems by applying the age-old
wisdom of turning it off and on

00:00:24.491,00:00:30.464
again, and how we apply this to
the design of a hardware
cryptocurrency wallet. A quick

00:00:30.464,00:00:35.435
show of hands, uh, how many of
you own one of these security
devices, these security dongles,

00:00:35.435,00:00:40.908
things like UB Keys or hardware
cryptocurrency wallets? Ah, a
good number of you. Uh, look to

00:00:40.908,00:00:44.177
your left, look to your right,
those who didn’t raise their
hands are probably going to get

00:00:44.177,00:00:49.182
hacked. [laughing] Uh, so we
believe in the value of these
uh, external devices to augment

00:00:51.518,00:00:57.291
our PC in order to increase
security and it’s not like all
these devices are created equal,

00:00:57.291,00:01:02.963
they’re actually getting better
over time. Some are maybe not
the best idea, like SMS based 2

00:01:02.963,00:01:07.100
factor auth is kinda a mess and
uh, I don’t know about you, but
at least for me it doesn’t

00:01:07.100,00:01:12.806
really work at DEFCON because my
phone’s been on airplane mode
since Thursday. Uh, but uh other

00:01:12.806,00:01:18.879
devices do a pretty good job of
preventing certain kinds of
attacks. For example, U2F Tokens

00:01:18.879,00:01:23.951
have more or less solved
phishing, and that’s pretty
cool. Um, but here, this is not

00:01:23.951,00:01:29.089
just devices becoming kind of
better and better, decreasing
the size of the TCB in a

00:01:29.089,00:01:32.626
straightforward way. It’s not
just a continuous improvement of
2 factor authenticate devices.

00:01:32.626,00:01:36.396
There is something a little bit
more interesting going on here.
I think there has been a

00:01:36.396,00:01:41.735
paradigm shift. On one hand we
have 2 factor auth devices which
are all about doing more secure

00:01:41.735,00:01:46.840
log in on your PC. This does
things like protect from stolen
passwords or against phishing

00:01:46.840,00:01:52.012
attacks. But on the other hand,
we have this new type of device,
uh, a hardware cryptocurrency

00:01:52.012,00:01:56.416
wallet, or the higher level or
uh more general sense, an
external transaction approval

00:01:56.416,00:02:01.888
device. And this device removes
the PC from the tusted, trusted
computing device entirely. There

00:02:01.888,00:02:06.126
are scenarios where a 2 factor
auth won’t save you, but
transaction authorization will.

00:02:06.126,00:02:11.198
Namely, if your PC is
compromised. And, uh, these may
seem like they’re solving

00:02:11.198,00:02:14.901
different problems, because 2
factor auth is traditionally
associated with websites,

00:02:14.901,00:02:19.339
whereas hardware wallets are
obviously associated with
cryptocurrencies, but this idea

00:02:19.339,00:02:24.344
of factoring out the most
sensitive approval decision onto
a separate secure device, well

00:02:24.344,00:02:29.449
this idea is universal and it
could be used by websites too.
And so, this is a way to improve

00:02:29.449,00:02:35.222
the security of a large class of
applications. Now you might ask,
can we just make the PC secure

00:02:35.222,00:02:40.227
instead. Well, eh, the PC is
kind of a disaster. Everything
is terrible. It’s, it’s just

00:02:42.362,00:02:47.934
this tower of complex
technologies where everyone of
them has major security flaws

00:02:47.934,00:02:52.539
and while we have mitigations
and work arounds for a lot of
these, uh, it’s, it’s just this

00:02:52.539,00:02:57.644
cat and mouse game. New attacks
come out, then developers patch
those exploits, and then the

00:02:57.644,00:03:02.215
cycle repeats. And, we have no
strong security in any
principled sense. We have

00:03:02.215,00:03:07.320
applications that are millions
of lines of java script code,
uh, using who knows what

00:03:07.320,00:03:11.892
dependencies from NPM, probably
running instead an electron
container and this is running on

00:03:11.892,00:03:15.328
top of a complex operating
system that’s at least 10’s of
millions of lines of code,

00:03:15.328,00:03:20.901
probably filled with bugs. Uh,
and this operating system is
running on a CPU that’s a leaky

00:03:20.901,00:03:25.372
abstraction for the abstract
machine its implementing. And
so, our CPU’s are susceptible to

00:03:25.372,00:03:28.742
all sorts of things, including
these micro-architectural bugs
that have been getting a lot of

00:03:28.742,00:03:34.314
attention recently. Things like
Spectre and Meltdown and
Foreshadow and Zombieloid. And

00:03:34.314,00:03:37.818
on top of that we have hardware
that it is also a leaky
abstraction cause physics is

00:03:37.818,00:03:41.621
kind of weird. And so, we have
attacks like Rowhammer and
RAMBleed, where it can do things

00:03:41.621,00:03:46.426
like repeatedly write to a row
in DRAM and cause bit flips in
adjacent regions and this breaks

00:03:46.426,00:03:51.665
isolation. And so, everything is
a disaster. It’s too hard to
build secure applications on the

00:03:51.665,00:03:57.904
modern PC. But if we can’t make
the PC secure, maybe that’s
okay. Maybe we can use this

00:03:57.904,00:04:02.209
transaction approval paradigm
instead, where critical a-a-
approval decisions and

00:04:02.209,00:04:06.680
applications are factored out
and go through a separate
secured device and we can use

00:04:06.680,00:04:12.185
this as a way to bootstrap
security. And these hardware
devices, as opposed to our PC’s

00:04:12.185,00:04:15.989
just might be simple enough that
we can get them right and have
strong confidence that we’ve

00:04:15.989,00:04:20.994
gotten them right. Maybe with
these devices its possible to
move beyond the just it hasn’t

00:04:20.994,00:04:25.132
been hacked yet and towards
having a more principled reason
for believing that such a device

00:04:25.132,00:04:30.971
is secure. And so, for those of
you, those of you who are not
super familiar with these, well

00:04:30.971,00:04:35.509
how do these devices remove the
PC from the trusted computing
base? Well, its really natural

00:04:35.509,00:04:39.713
for applications like
cryptocurrencies because they’re
already structured to require

00:04:39.713,00:04:44.618
private key signature in order
to do the sensitive operation.
And so, when using a hardware

00:04:44.618,00:04:49.122
cryptocurrency wallet, the
private key never leaves the
hardware device and so the way

00:04:49.122,00:04:53.693
it works is you can pair it with
an untrusted PC and if you want
to do anything, like send a

00:04:53.693,00:04:58.899
transaction, what you can do is
craft that transaction on the
PC, uh, you can say like oh I

00:04:58.899,00:05:03.570
want to send 0 point 1 bitcoin
to address XYZ but you can’t
actually sign and broadcast the

00:05:03.570,00:05:08.275
transaction because the PC does
not have the private key.
Instead, all you can do is send

00:05:08.275,00:05:12.179
the transaction from the
computer to this hardware
device, which can then parse the

00:05:12.179,00:05:16.583
transaction, display it to the
human in a human-readable way,
like again 0 point 1 bitcoin to

00:05:16.583,00:05:20.821
address XYZ, and then only if
the human confirms the
transaction on the device by

00:05:20.821,00:05:24.591
pushing the button does this
device sign it with the private
key and send it back to the

00:05:24.591,00:05:29.663
computer so it can be broadcast.
And so, if something goes wrong
here. Like if the PC is

00:05:29.663,00:05:34.067
compromised, it might do
something evil. Right? It might
do something like swap out the

00:05:34.067,00:05:38.338
recipient address with that of
the attacker, or it might change
the amount that is being sent.

00:05:38.338,00:05:41.908
And if there is malware running
on the PC, it could do all sorts
of wacky stuff, like it could

00:05:41.908,00:05:45.612
even fabricate the contents of
the screens so it could display
on the screen like, oh you are

00:05:45.612,00:05:49.316
sending a bitcoin to your
friend, when in fact, what the
computer is actually doing is

00:05:49.316,00:05:54.221
sending all of your money to the
attacker. But even if the PC is
compromised, the hardware wallet

00:05:54.221,00:05:59.192
user is safe. Because even if
the PC screen lies to the user,
the device will show the actual

00:05:59.192,00:06:04.364
recipient address and so we can
think of uh, these devices as
providing a secure IO path to

00:06:04.364,00:06:10.370
the user where the PC was
previously failing us. And its
good to remove the PC from the

00:06:10.370,00:06:15.108
trusted computing base because
things indeed go wrong. Like
there are tons of attacks I

00:06:15.108,00:06:19.045
could talk about where people
stole cryptocurrency. Here is
this one that I think is kind of

00:06:19.045,00:06:23.583
clever. Uh, in December 2018,
there was a phishing attack on
users of the Electrum bitcoin

00:06:23.583,00:06:29.155
wallet, um, and so the way the
Electrum bitcoin wallet works is
that it’s an SPV wallet, and

00:06:29.155,00:06:33.793
that’s like most other bitcoin
wallets people use today, uh,
these wallets don’t download the

00:06:33.793,00:06:36.630
full block chain onto your
computer cause that’d be kind of
impractical, like having to

00:06:36.630,00:06:41.067
download hundreds of gigabytes.
Instead, what these wallets do
is that they rely on untrusted

00:06:41.067,00:06:45.505
servers in order to do payment
verification. So, if you rely on
this untrusted server and it can

00:06:45.505,00:06:50.277
prove to you that a particular
payment is on the bitcoin block
chain, uh, without you having to

00:06:50.277,00:06:53.613
download the block chain and
also without you having to trust
the server. And this is pretty

00:06:53.613,00:06:58.685
cool. Um, in Electrum’s
implementation, these untrusted
servers could return error

00:06:58.685,00:07:02.889
messages to clients, and that’s
also fine, but in Electrum
versions before 3 point 3 point

00:07:02.889,00:07:06.826
three, these server error
messages could be arbitrary
text, and not just arbitrary

00:07:06.826,00:07:11.431
text actually, but HTML and so
this screenshot here shows what
happens if you take an old

00:07:11.431,00:07:14.567
version of Electrum and connect
to one of these comprised
servers, which anybody could set

00:07:14.567,00:07:19.039
up. So, its like, hey it
requires security update version
4 point 0 point 0, go download

00:07:19.039,00:07:24.477
this software here, nothing bad
will happen, I promise. Uh, and
by getting people to run bad

00:07:24.477,00:07:27.981
software on their PC, attackers
made off with hundreds of
bitcoin, and this is just one

00:07:27.981,00:07:31.785
example, there’s tons of
examples of this kind of thing
out there. If you have bad

00:07:31.785,00:07:36.022
software running on your PC, it
can steal your private key. Even
if your private key is encrypted

00:07:36.022,00:07:39.626
on your device, the malware can
just wait until you decrypt it
when you are about to send a

00:07:39.626,00:07:44.564
legitimate transaction, and it
once it has a private key, can
do whatever it wants. And, in

00:07:44.564,00:07:49.602
this scenario, and most of the
others, a hardware wallet
could’ve saved you. So, why

00:07:49.602,00:07:53.640
shouldn’t every application
behave like cryptocurrencies in
the sense that these sensitive

00:07:53.640,00:07:58.511
approval decisions are factored
out and go through a separate
secure device. Well, right now

00:07:58.511,00:08:02.849
for sensitive websites I use 2
factor auth and if my computer
is hacked, I’m in trouble. 2

00:08:02.849,00:08:08.521
factor auth doesn’t guarantee
anything if your computer is
compromised. Um, and now these

00:08:08.521,00:08:13.159
websites already have
confirmation prompts for doing
sensitive operations. Like, if I

00:08:13.159,00:08:18.264
look at my, uh, open stack, if I
try to delete a VM, its like, oh
confirm terminate instance. Are

00:08:18.264,00:08:22.736
you sure you want to do this? Or
if I’m using my, uh, I’m doing
something with my domain name

00:08:22.736,00:08:25.905
and trying to delete a DNS
record, it’s like oh are you
sure you actually want to remove

00:08:25.905,00:08:31.144
this DNS record? And these are
not for security, uh, these
screenshots you see on the left,

00:08:31.144,00:08:33.880
those are just like confirmation
prompts to make sure you don’t
click on the wrong thing and

00:08:33.880,00:08:38.051
accidently do something you
didn’t mean to do. But, in
theory, this approval decision

00:08:38.051,00:08:42.255
could be easily factored out.
Uh, at sign up time, a user
gives a website their public

00:08:42.255,00:08:46.960
key, and then for sensitive
operations, the user must sign a
human-readable description of

00:08:46.960,00:08:51.131
the operation with their private
key, and the signing could
happen on an external device. On

00:08:51.131,00:08:55.402
a hardware cryptocurrency
wallet, just like you do with
cryptocurrencies. And this could

00:08:55.402,00:09:00.340
be really useful for things like
bank transfers and stock market
trades and manipulating VM’s and

00:09:00.340,00:09:04.844
infrastructure and manipulating
DNS records and deleting
back-ups. Like basically, any

00:09:04.844,00:09:10.283
sort of sensitive thing could go
through such a device. Um, there
is actually some work on

00:09:10.283,00:09:14.054
standardizing this kind of
behavior. So, uh, web
authentication is this web

00:09:14.054,00:09:19.025
standard that’s kinda like a
successor to U2F and as it says
on the box, it’s a API for

00:09:19.025,00:09:23.163
accessing public key
credentials. And a large part of
the standard focuses on doing

00:09:23.163,00:09:27.000
better login, like basically
doing better U2F, but a small
part talks about doing

00:09:27.000,00:09:32.205
transaction authorization on an
authentication device. Um, so I
think that’s pretty cool, um.

00:09:32.205,00:09:36.476
But this, this is pretty recent
stuff, and uh, even though some
people have started supporting

00:09:36.476,00:09:41.448
web authentication as a second
factor for login, as far as I
know nobody’s really using this

00:09:41.448,00:09:48.188
transaction authorization stuff,
but I hope it takes off in the
future. Uh, so, now that we’re

00:09:48.188,00:09:52.425
convinced that transaction
approval is a great idea. Like,
this transaction approval of

00:09:52.425,00:09:56.563
sensitive transactions happening
on a separate secure device,
well of course, we’d want to use

00:09:56.563,00:10:01.501
it everywhere. Uh, with all our
cryptocurrencies like bitcoin,
and Ethereum and Monero and uh,

00:10:01.501,00:10:05.705
all the sketchy outcoins I
didn’t bother to list here, uh,
and even websites where we do

00:10:05.705,00:10:11.411
sensitive stuff, like where we
manage our virtual machines and
our DNS. And for practicality,

00:10:11.411,00:10:16.115
we want this to all happen with
a single hardware device, but if
we do that, we lose some of the

00:10:16.115,00:10:21.754
simplicity of other security
tokens, things like the UB key
or U2F keys, where those were

00:10:21.754,00:10:26.226
basically a fixed function.
Here, uh, web authentication
support maybe could be built

00:10:26.226,00:10:30.396
into the device, but supporting
arbitrary cryptocurrencies
would, uh, for sure require

00:10:30.396,00:10:34.567
different applications because
these different cryptocurrencies
all use different transaction

00:10:34.567,00:10:38.905
formats and different crypto
systems, and so on. And so, now
this device that we’re imaging

00:10:38.905,00:10:43.409
needs to run arbitrary
third-party code, while sandbox,
boxing all of the applications

00:10:43.409,00:10:47.480
from each other. Like, I really
want to be able to install a
sketchy outcoin wallet without

00:10:47.480,00:10:52.585
having my bitcoin stolen. Is
that too much to ask for? Uh,
and so this device must provide

00:10:52.585,00:10:57.624
strong isolation between these
mutually untrusting
applications. And now our device

00:10:57.624,00:11:02.929
is starting to look complicated.
Uh, earlier, I was saying oh the
PC is this complex beast and its

00:11:02.929,00:11:08.701
going to be impossible to get it
right. And the hardware wallet,
well, that, that can be simple

00:11:08.701,00:11:12.205
and therefore maybe secure. But
now, now the hardware wallet is
starting to sound kinda

00:11:12.205,00:11:17.710
complicated too. Uh, it now, now
it needs an operating system. It
needs to multiplex shared

00:11:17.710,00:11:22.782
resources like the CPU and RAM
and USB and storage and display
and buttons between

00:11:22.782,00:11:28.555
applications, and uh, sharing
leads to complexity and
complexity leads to bugs and

00:11:28.555,00:11:34.761
vulnerabilities. Uh, and
hardware wallets have indeed had
bugs in the past related to

00:11:34.761,00:11:39.599
their operating system. Uh, for
example, the Ledger Wallet, one
of the most popular

00:11:39.599,00:11:43.803
cryptocurrency wallets had a
series of bugs related to bad
argument validations and system

00:11:43.803,00:11:48.308
calls. So, one example there is
that there was a SHA 256 system
call, and you could pass a

00:11:48.308,00:11:51.344
pointer to it and it should do
some amount of validation on
that pointer so you don’t in

00:11:51.344,00:11:54.781
read memory you’re not supposed
to. Uh, but turns out you could
pass the null pointer and it

00:11:54.781,00:11:59.619
would gladly compute a SHA over
that, so you could call SHA 256
with a null pointer, and varying

00:11:59.619,00:12:04.791
length arguments, and get hashes
of prefixes of memory so you can
dump contents of flash, so you

00:12:04.791,00:12:10.930
could call SHA 256 end times and
then compare that with
independently computing 256 x n

00:12:10.930,00:12:15.001
hashes and you could use this to
dump the first n bytes of
memory, and in practice, this

00:12:15.001,00:12:20.106
could be used to dump the first
8K of flash. Isolation bug. And
there are other bugs of this

00:12:20.106,00:12:23.243
style in the Ledger Wallet. Uh,
there is some interesting
security research done by

00:12:23.243,00:12:28.615
Riscure and presented at Black
Hat in 2018 that talks more
about this. Um, and both Ledger

00:12:28.615,00:12:32.919
and Trezor, two of the most
popular cryptocurrency wallets
have had bugs where the R memory

00:12:32.919,00:12:37.156
protection unit in the device
was misconfigured by the
operating system. So, in

00:12:37.156,00:12:40.893
Ledger’s case, it allows read
accesses to memory regions which
applications were not supposed

00:12:40.893,00:12:47.567
to read, and in Trezor’s case it
logged write accesses. And so,
at a high level, uh, these bugs

00:12:47.567,00:12:51.337
are because of sharing. Cause,
if you think about it, if you
had no sharing, you wouldn’t

00:12:51.337,00:12:55.642
need a sophisticated operating
system with a complicated memory
protection policy. You wouldn’t

00:12:55.642,00:13:01.447
need the memory protection unit,
and so on. Okay, now maybe I’m
sending you mixed messages. Uh,

00:13:01.447,00:13:05.918
I seem to be hinting at security
through physical separation.
Like, this is an easy solution

00:13:05.918,00:13:11.758
in some sense. Uh, one device
per app. In this picture,
mutually untrusting applications

00:13:11.758,00:13:15.228
are just air-gapped from each
other. And physical separation
gets you a lot of nice

00:13:15.228,00:13:21.434
properties. So, why don’t we do
this? Well, it’s impractical,
especially to support a lot of

00:13:21.434,00:13:25.505
applications and practicality is
super important for adoption.
And so, there are these

00:13:25.505,00:13:30.610
competing tensions here. It’s
like sharing versus security.
And the question is can we have

00:13:30.610,00:13:36.983
the best of both worlds. Well,
here is an idea. Uh, what
happens if we try to simulate

00:13:36.983,00:13:40.353
physical separation and I’m
going to give you a very
high-level overview of it and

00:13:40.353,00:13:43.222
then we’ll talk about it in more
detail. But what if we could
have this device where we run an

00:13:43.222,00:13:47.360
application and whenever we want
to switch applications, we just
blow away all the state on the

00:13:47.360,00:13:51.998
device, and in a sense logically
have like a fresh factory new
device, in order to run the next

00:13:51.998,00:13:58.871
application on. Well, for
whatever vague description of
fresh device uh, you might have

00:13:58.871,00:14:02.642
in mind, like if this is done
correctly, maybe appl, every
application that runs could be

00:14:02.642,00:14:06.412
isolated from all the others.
Cause if you kinda clear
everything on the device away,

00:14:06.412,00:14:10.516
before running the next
application, well whatever ran
before can’t accidently leak

00:14:10.516,00:14:14.987
secrets to whatever ran
afterward. And so, maybe this
sounds reasonable to high level.

00:14:14.987,00:14:18.691
Oh, like let’s simulate physical
separation through reset, but
huh, obviously there’s some

00:14:18.691,00:14:22.128
details that need to be worked
out here. It’s like, what, what
would the hardware architecture

00:14:22.128,00:14:25.765
look like for something that’s
built around this idea? And
then, also, what does it mean to

00:14:25.765,00:14:31.804
reset hardware? Well, here’s a
proposed design. What if we run
third-party code kinda on its

00:14:31.804,00:14:36.509
own computer? A stateless
computer, and we reset it
between task switching. So,

00:14:36.509,00:14:41.314
like, on the left, uh, yeah, on
the left we have this thing we
call the application core, its

00:14:41.314,00:14:46.285
basically a computer and its
stateless. We kind of load an
application just as we are going

00:14:46.285,00:14:51.124
to run it, an we run it uh, to
completion, and then before we
run the next application, we

00:14:51.124,00:14:56.462
somehow magically clear all the
state from this application
core. And in this picture, we

00:14:56.462,00:15:01.701
have, uh, another computer
basically for managing the
computer on the left, uh, and

00:15:01.701,00:15:06.372
the computer on the left is
stateless but runs third-party
code, and the computer on the

00:15:06.372,00:15:13.312
right is stateful, it can write
stuff to flash memory, but it
never runs third-party code. And

00:15:13.312,00:15:16.682
so, this has some other nice
properties. Uh, you actually
don’t need an operating system

00:15:16.682,00:15:20.119
with a structure like this,
basically, or maybe you can
think of it as splitting, uh,

00:15:20.119,00:15:26.492
kernel and a user up in this
way. Like kernel user, uh, space
rather than being like harbor

00:15:26.492,00:15:30.763
protection on a single CPU is
just two separate computers
talking to each other. But in

00:15:30.763,00:15:34.066
this picture, whatever code runs
on this like application
computer we have on the left,

00:15:34.066,00:15:37.837
well, it doesn’t need an
operating system. We can just
give it access to bare hardware

00:15:37.837,00:15:42.008
cause operating systems are all
about kinda mediating access to
shared hardware but in our

00:15:42.008,00:15:46.012
picture, we have this idea of
resetting all the state before
letting the next guy run and so

00:15:46.012,00:15:49.749
we don’t need to really worry
about what kinds of wacky things
some malicious third-party code

00:15:49.749,00:15:54.587
might do as long as we can get
reset correct. This would need
no operating system or hardware

00:15:54.587,00:15:58.291
protection mechanisms and so
that gives us a lot of
simplicity, and so its easier to

00:15:58.291,00:16:02.361
reason about the correctness
about such a system. And then in
this picture we also really

00:16:02.361,00:16:07.900
don’t need things like system
calls. Like, basically, we need
no communication back from may –

00:16:07.900,00:16:10.436
potentially sketchy third-party
application code back to
whatever management code is

00:16:10.436,00:16:14.240
managing this device. This
communication can happen over a
really simple interface, like a

00:16:14.240,00:16:19.145
single wired UART and maybe like
the only system call you need is
for the application to be able

00:16:19.145,00:16:24.150
to terminate itself and maybe
save some state for the next
time it runs. And maybe this

00:16:24.150,00:16:27.887
seems like a really wacky design
and this wouldn’t work for
things like your desktop, where

00:16:27.887,00:16:31.357
you want to run multiple
applications simultaneously or
you want to run sophisticated

00:16:31.357,00:16:38.030
applications. But for the class
of applications we’re targeting,
this restricted model does work.

00:16:38.030,00:16:42.001
And so, this is what the
architecture looks like. Now
what do I mean by reset. We

00:16:42.001,00:16:47.640
still need to talk about reset
in more detail. So, what state
is there in this application

00:16:47.640,00:16:52.445
core? Well there is state in
many places. Obviously, the CPU
and RAM are stateful devices,

00:16:52.445,00:16:58.651
but also even things like the
USB peripheral or the display
can maintain state. And in order

00:16:58.651,00:17:02.188
to have strong isolation, we
really need to clear all the
state that might be present in

00:17:02.188,00:17:07.260
such a device. Like basically,
everything is stateful except
for things like the buttons,

00:17:07.260,00:17:11.297
which are just switches. Uh, and
to have strong isolation, these
need to be reset in some

00:17:11.297,00:17:15.334
meaningful way, clearing away
whatever was there before so
that any application that runs

00:17:15.334,00:17:18.971
is not influenced by whatever
was running on the device
before. And so, again, what do

00:17:18.971,00:17:22.875
we mean by reset? Well, we will
actually formulize this later,
but for now you can just think

00:17:22.875,00:17:26.612
of it as like factory new or
untouched or untainted. Like,
get everything back into an

00:17:26.612,00:17:32.218
untainted state. Any two
pre-reset states should be
indistinguishable post-reset.

00:17:32.218,00:17:36.789
Also, how do we implement this?
For this talk, we’ll focus on
the CPU because it’s the most

00:17:36.789,00:17:42.461
interesting and challenging
component and all the other
things are kinda analogous. So,

00:17:42.461,00:17:47.033
first attempt, turn it off and
on again. What happens if we
just take the CPU and cut the

00:17:47.033,00:17:51.671
power to it and then plug it
back in? Is this sufficient for
clearing all internal state? It

00:17:51.671,00:17:55.374
might seem like a good idea.
Well it turns out that removing
power from these chips doesn’t

00:17:55.374,00:17:59.378
actually clear all the internal
state. Uh, chip state, such as
esterum can actually persistent

00:17:59.378,00:18:03.349
for tens of minutes in these
devices, and so power cycling
isn’t really going to achieve

00:18:03.349,00:18:07.987
anything, at least not on a
reasonable time horizon. And in
a sense, we can think of power

00:18:07.987,00:18:12.525
cycling as roughly equivalent to
just asserting a reset line.
Speaking of which, these

00:18:12.525,00:18:16.862
processors have a reset line.
Like, there’s a pin on the CPU
labeled reset. Does this do the

00:18:16.862,00:18:21.400
right thing? Well, to answer
that question, to understand
what this reset line really

00:18:21.400,00:18:26.839
means, well the first place we
might look is the ISA manual.
And so here I have a screen shot

00:18:26.839,00:18:31.377
from the RISC-V instruction set
manual. Other instruction sets
say things like are and were

00:18:31.377,00:18:35.281
kind of similar. RISC-V had a
really clean description of this
so that’s why I chose this one.

00:18:35.281,00:18:41.387
And looking at this, we can set
that the reset specification of
RISC-V is really weak. All that

00:18:41.387,00:18:45.091
the manual really tells us is
that after reset the program
counter is set to an

00:18:45.091,00:18:50.963
implementation defined reset
vector, and all other state is
undefined. And this is kinda

00:18:50.963,00:18:55.167
like undefined behavior in C or
something like that where
something specific does happen,

00:18:55.167,00:18:59.505
it’s just that the standard
doesn’t guarantee that any
particular thing will happen.

00:18:59.505,00:19:03.876
So, what happens in practice?
Well all state isn’t reset like,
for example, registers may

00:19:03.876,00:19:08.647
retain their pre-reset value and
so just asserting the reset line
of a CPU isn’t really enough to

00:19:08.647,00:19:12.818
achieve the kinda stronger
notion of reset, maybe I’ll call
that deterministic reset, that

00:19:12.818,00:19:18.324
we were thinking about. So,
okay, here’s another attempt.
What happens if we run code post

00:19:18.324,00:19:23.062
reset? We might be inspired by
the part of the, uh, manual that
said the program counter is set

00:19:23.062,00:19:26.966
to an implementation defined
reset value. That means that
once we reset a CPU, we can

00:19:26.966,00:19:30.970
return control to a known
location and maybe there we can
have a read-only region of

00:19:30.970,00:19:36.075
memory where we have some code
that cleans up the rest of the
state in the CPU. That reset

00:19:36.075,00:19:39.678
guarantees that the program
counter will go there and we can
run the special code that does

00:19:39.678,00:19:44.016
things like clearing the
registers of the CPU. So, what
needs to be cleared? Well, maybe

00:19:44.016,00:19:48.788
we can read carefully through
the ISA manual and identify all
the registers and stuff internal

00:19:48.788,00:19:52.591
to the CPU. Things like the
flags registers and all that.
And if we think about it really

00:19:52.591,00:19:57.363
carefully, maybe we can write
code that clears it. Well it
turns out that that still isn’t

00:19:57.363,00:20:02.368
enough. There is actually more
state inside a CPU beyond what
is even named in the ISA manual.

00:20:04.470,00:20:08.374
Because at the abstract machine
level, there’s no notion of a
lot of the details of what’s

00:20:08.374,00:20:13.079
inside a CPU, like in the ISA,
there’s no notion of a branch
predictor. There’s no notion of

00:20:13.079,00:20:16.916
caches and things like that.
These are all implementation
details designed to make a

00:20:16.916,00:20:22.688
processor go faster, but often
times, these details end up
causing problems. As we’ve seen

00:20:22.688,00:20:27.359
in micro-architectural side
channel attacks in things like
Spectre and Meltdown and so on

00:20:27.359,00:20:31.564
because this micro-architectural
state, which can’t be named at
the architectural level, you

00:20:31.564,00:20:35.434
can’t write code that directly
talks about it, well, this
micro-architectural state can

00:20:35.434,00:20:38.337
end up leaking into
architectural state, which is
exactly what’s going on in

00:20:38.337,00:20:43.175
attacks like Spectre and
Meltdown. Uh, for example,
through timing and this is

00:20:43.175,00:20:48.180
problematic. So, are we stuck
because code can only talk about
architectural state and so

00:20:50.783,00:20:54.954
instructions can’t even name
things like the branch target
buffer or things like that,

00:20:54.954,00:20:59.592
those just don’t exist at the
architectural level. And also,
every CPU’s micro-architectural

00:20:59.592,00:21:02.628
details are going to be
different so it seems like it
would be hard to support many

00:21:02.628,00:21:08.367
CPU’s. Well, I think one step we
could take is just minimize
complexity. Like in our

00:21:08.367,00:21:11.704
relentless pursuit of
simplicity, we should just use a
processor that doesn’t have all

00:21:11.704,00:21:15.107
these fancy features. We’re not
trying to do anything super
complex, like we’re not running

00:21:15.107,00:21:21.614
Fortnite on this thing, we’re
just assigning uh, like, small
blobs of data and displaying

00:21:21.614,00:21:25.284
some small text on a screen. And
so, we don’t need a fancy
processor. We can just use

00:21:25.284,00:21:29.121
something that doesn’t speculate
and has no branch predictor and
stuff like that to minimize

00:21:29.121,00:21:33.759
micro-architectural state. Like,
if there is no branch predictor,
we don’t have to worry about

00:21:33.759,00:21:38.631
clearing it, right? Um, but even
the simplest of CPU’s is going
to have some micro-architectural

00:21:38.631,00:21:43.135
state. Some implementation
details that are not named at
the ISA level, but there are

00:21:43.135,00:21:47.239
still state inside the CPU, and
it’s really hard to reason about
whether or not this could be

00:21:47.239,00:21:52.978
problematic so we better figure
out how to clear it. And so,
here’s our final idea. It

00:21:52.978,00:21:57.449
actually turns out that it’s
possible to write code that
resets a CPU like using this

00:21:57.449,00:22:01.020
idea of asserting the reset line
to return control to a
particular point we control and

00:22:01.020,00:22:05.958
then letting the CPU run for
several cycles to run some code
that we wrote. Now let’s say,

00:22:05.958,00:22:11.797
hey wait a minute, I thought you
said that code can’t talk about
micro-architectural state? And,

00:22:11.797,00:22:17.536
yeah, that’s true. But running
code on a CPU affects
micro-architectural state. Uh,

00:22:17.536,00:22:22.308
it’s not described in the ISA
manual how it does so, because
it is specific to a CPU, but for

00:22:22.308,00:22:27.146
any given CPU, any particular
CPU, the implementation is
deterministic. It like does some

00:22:27.146,00:22:32.451
particular thing, even if it’s
not defined by the ISA manual.
And so, what if we wrote code to

00:22:32.451,00:22:38.357
very carefully have the desired
effect on a specific CPU? Like,
for example, you might imagine

00:22:38.357,00:22:40.359
if a CPU is a pipeline CPU and
you just execute a bunch of
instructions, they’ll end of

00:22:40.359,00:22:42.361
kinda clearing away a lot of the
state that was in the pipeline.
And some CPU’s are open source,

00:22:42.361,00:22:47.366
so you can actually consult the
gate level implementation of the
CPU and understand the effects

00:22:50.970,00:22:57.042
of code at the
micro-architectural level. Now,
what if we got it wrong? Well,

00:22:57.042,00:23:00.379
then we just have no more
isolation. Like, this is our
kinda tool we’re using to

00:23:00.379,00:23:04.717
achieve isolation. And so, it’s
really important that we get it
right. But this process seems

00:23:04.717,00:23:09.088
very challenging and error
prone. Like, this code itself
seems hard to write. Right, like

00:23:09.088,00:23:13.092
how do, do you write code that
has the right effect to the
micro-architectural level? Then

00:23:13.092,00:23:17.563
also, reasoning about the
correctness of such, of such
code also seems complicated.

00:23:17.563,00:23:21.433
Like, how do you know that this
code does the right thing no
matter what state the CPU is in?

00:23:21.433,00:23:25.070
Like, a CPU can be in so many
different states. How do you
know that the code always does

00:23:25.070,00:23:30.909
the right thing? Well, so how do
we know that reset is correct?
Well, what is reset trying to

00:23:30.909,00:23:36.148
do? Reset is a single operation
asserting the reset line and
then letting the CPU run code

00:23:36.148,00:23:41.420
for a little bit, that’s applied
to an arbitrary state and, and
it should turn the CPU from this

00:23:41.420,00:23:45.658
arbitrary state into a purged
state. Like, basically no matter
what state you started in

00:23:45.658,00:23:50.629
before, you should end up in the
same state after this purge
operation. And maybe another way

00:23:50.629,00:23:55.167
looking at it is like, we have
these two worlds – one where a
secret bit is zero and another

00:23:55.167,00:23:58.737
where a secret bit is one. Like
whatever software was running
before is operating on some

00:23:58.737,00:24:03.809
secret data. Um, if these worlds
are indistinguishable
post-reset, then code that was

00:24:03.809,00:24:08.213
running beforehand on that
secret data can’t accidently
leak the secret to whatever ran

00:24:08.213,00:24:12.751
on the CPU after this reset
process. And so, this is a
slightly more formal definition

00:24:12.751,00:24:18.724
of our reset property. But, how
do we apply it? It seems really
hard to just like, sit down and

00:24:18.724,00:24:23.696
think really hard about whether
this property holds for a
particular CPU and particular

00:24:23.696,00:24:30.169
sequence of code. Like, we can’t
just sit down and like think
about all of this, uh. So, what

00:24:30.169,00:24:35.007
do, what do we do? Well, we can
use tools to do this reasoning
for us. So, a little bit of

00:24:35.007,00:24:39.712
background. There is this really
neat tool called an SMT solver.
SMT stands for Satisfiability

00:24:39.712,00:24:44.416
Modulo Theories and it’s this
very powerful tool that has many
uses, uh, including security.

00:24:44.416,00:24:48.454
Like, these tools are used for
things like crack-me’s and bug
finding and static analysis and

00:24:48.454,00:24:51.423
things like that. I highly
recommend you look into these
after the talk, it’s like a

00:24:51.423,00:24:57.029
super neat tool. Um, and SMT
solvers are based on this more
primitive thing called a SAT

00:24:57.029,00:25:01.500
solver. So, what is SAT solver?
It’s, uh, it’s a tool that can
solve Boolean formulas. Like,

00:25:01.500,00:25:06.004
for example, on the top left,
you might have the formula x and
y or not z. And it turns out

00:25:06.004,00:25:09.408
that this formula is
satisfiable. So, if you give
this to the tool, it’ll say, oh,

00:25:09.408,00:25:13.846
this formula is SAT and the
satisfying assignment is x
equals false y equals false z

00:25:13.846,00:25:17.082
equals false. So, if you plug
those things in on the left and
evaluate it, you’ll see that

00:25:17.082,00:25:21.320
that expression values to true.
And similarly, you might have a
different expression, which is

00:25:21.320,00:25:27.993
not satisfiable, in which the
tool will return UNSAT. So, then
what are SMT solvers? SMT is SAT

00:25:27.993,00:25:31.797
on steroids. Basically, it
supports more data types than
just Boolean’s and more

00:25:31.797,00:25:35.634
operations that just Boolean
operations, so you might have
support for things like integers

00:25:35.634,00:25:39.872
or addition or inner qualities
or bit vectors or things like
that. And different tools have

00:25:39.872,00:25:43.442
support for different sets of
things, like you might have a
theory of strings or a theory of

00:25:43.442,00:25:47.579
arrays or things like that. But
basically, it’s SAT on steroids.
It’s like a fancy equation

00:25:47.579,00:25:52.785
solver. But it’s not just an
equation solver, because one SAT
solvers find a solution, uh,

00:25:52.785,00:25:57.289
well, that’s like an equation
solver, but when they return
UNSAT, it actually, it means

00:25:57.289,00:26:01.260
something. It’s not just, like,
the tool is failing to find a
solution. The tool has

00:26:01.260,00:26:05.297
determined that there is no
solution. You can think of it
like it’s doing a smart

00:26:05.297,00:26:11.470
exhaustive search and proving
that whatever formula was input
into it has no solution. And so,

00:26:11.470,00:26:14.706
it turns out that we can use
this fancy equation solver to
automatically approve theorems.

00:26:14.706,00:26:20.879
So, consider this abstract of
stating a theorem for all x p of
x. Well, we can mechanically

00:26:20.879,00:26:24.716
translate this to an SMT
formula, and the way we do that
is we just strip the for all’s

00:26:24.716,00:26:28.887
from the left-hand side and
negate the proposition. So, for
all x p of x turns into not p of

00:26:28.887,00:26:34.626
x. And then we can consider what
happens when we feed this to the
SAT solver. If this theorem is

00:26:34.626,00:26:41.400
satisfiable, that means that the
theorem is false. Because if not
p of x has a solution, well then

00:26:41.400,00:26:44.937
that means that there is an x
where not p of x is true and so
it can’t be the case that for

00:26:44.937,00:26:50.309
all x p of x. Like, that’s a
counter example. On the other
hand, the SAT solver might say

00:26:50.309,00:26:54.980
UNSAT, and that means that our
theorem is proven. It’s a proof
that our theorem holds because

00:26:54.980,00:27:00.118
if not p of x is not
satisfiable, there is no x that
makes not p of x true. And so,

00:27:00.118,00:27:06.391
it must be the case that p of x
holds for all x. So, in more
concrete terms, like how do we

00:27:06.391,00:27:10.462
actually apply this to a real
theorem? Well, here’s a simple
theorem. This theorem says that

00:27:10.462,00:27:14.533
the average of two real numbers
is between their min and their
max. And so, the way we

00:27:14.533,00:27:20.072
translate this to SMT, remember,
if we just strip the for all’s
and negate the proposition. And,

00:27:20.072,00:27:24.209
even though, like, actual code
for checking this theorem is
actually pretty straightforward.

00:27:24.209,00:27:28.514
So, this is Python code using
the Z3 Theorem Prover. And
basically, it’s like, oh x is a

00:27:28.514,00:27:32.217
real number, y is a real number,
let me define min and max
because those are not built-in’s

00:27:32.217,00:27:36.889
and then put in the theorem
statement, uh, assert that not
of a theorem statement holds and

00:27:36.889,00:27:40.526
check if that’s satisfiable. And
then of course, like, we know
the theorem is true and indeed

00:27:40.526,00:27:46.999
the tool returns UNSAT here,
proving the theorem. Okay, so
going back to reset property,

00:27:46.999,00:27:51.003
like the whole thing we were
talking about earlier. Uh,
here’s the, the picture I had on

00:27:51.003,00:27:56.375
the slide before that phrase is
text. What does reset mean? It
means that if you are in any two

00:27:56.375,00:28:00.245
different CPU states, if you
apply this operation to those
states, they must converge to

00:28:00.245,00:28:05.317
the same state and here purge is
like this process of asserting
the reset line of the CPU and

00:28:05.317,00:28:08.554
then just letting it execute for
some number of cycles so it
executes whatever instructions

00:28:08.554,00:28:13.592
we put in the right place. Okay,
so as long as we can express
this in the language of SMT,

00:28:13.592,00:28:16.728
then we’re good. We can just
throw this in our SMT solver and
hopefully it can prove it

00:28:16.728,00:28:22.568
correct. So, so far, I’ve only
talked about Boolean formulas
and, like, numerical equations

00:28:22.568,00:28:27.239
and stuff. How does that
translate to CPU’s? Well, let’s
start with simple circuits.

00:28:27.239,00:28:30.576
Let’s start with combinatorial
circuits. So, these are
stateless circuits that compute

00:28:30.576,00:28:35.714
Boolean functions. And here is a
full adder circuit. So, this
takes two inputs and a carry in

00:28:35.714,00:28:39.618
and produces an output and a
carry out. Pretty simple
component. Something like this

00:28:39.618,00:28:43.755
might make up a very small part
of a CPU. Like, this might be
chained together with other full

00:28:43.755,00:28:48.360
adders to make a wide adder,
like a 32-bit adder, and that
might be a small part of an ALU,

00:28:48.360,00:28:52.364
and that might be a small part
of a CPU. But we can see how
this might be representative of

00:28:52.364,00:28:58.270
a small part of a complex
circuit. So, the circuit could
be represented in Verilog code

00:28:58.270,00:29:01.173
like this. Just like a pretty
straightforward translation of
exactly what you see in the

00:29:01.173,00:29:06.578
picture, and its turns out that
the Python Z3 Code for this is
actually pretty straightforward.

00:29:06.578,00:29:10.315
Like, this tool supports doing
Boolean operations, so we can
just translate this code into

00:29:10.315,00:29:15.520
Python and use that library. So,
this is all you need in order to
represent that circuit. So,

00:29:15.520,00:29:19.057
let’s try to prove some property
about this simple circuit. We
all know that addition is

00:29:19.057,00:29:23.729
commutative. A plus B equals B
plus A. Um, and since this is a
full adder and takes a carry in,

00:29:23.729,00:29:27.132
then let’s just say that the
carry in has to be the same.
Well, what does this look like

00:29:27.132,00:29:31.603
when we try to use the tool to
formally prove this property.
Uh, this is all the code you

00:29:31.603,00:29:36.274
need. Basically, you put in the
preconditions, we have two
possible inputs. We have, like,

00:29:36.274,00:29:39.945
the A plus B input to the adder
and the B plus A input to the
adder, and we say that okay,

00:29:39.945,00:29:45.183
like, the A and B are swapped in
the two cases, but the carry in
stays the same. And then we put

00:29:45.183,00:29:48.053
in our negative theorem
statement. Like, remember from
earlier we stripped the for

00:29:48.053,00:29:52.758
all’s and negate the
proposition. So, here we say to
the solver, like, I am asserting

00:29:52.758,00:29:57.529
that the result of the full
adder ap ply to the two possible
inputs, the one where the inputs

00:29:57.529,00:30:03.702
are normal and swapped, uh,
while the result is different.
If you try to check that

00:30:03.702,00:30:08.440
property with a solver, it will
say that this, uh, this equation
is unsatisfiable, which is a

00:30:08.440,00:30:14.446
proof that our theorem is true.
That addition is indeed
commutative, as we all knew. Um,

00:30:14.446,00:30:18.450
I think the last piece of the
puzzle here is how do we deal
with state? Cause, CPU’s are

00:30:18.450,00:30:22.821
stateful things. Uh, well,
let’s, let’s not go all the way
to the level of CPU yet cause

00:30:22.821,00:30:26.925
that’s kinda complicated. Let’s
start with this 8-bit counter.
So, here’s Verilog code

00:30:26.925,00:30:31.630
implanting an 8-bit counter.
It’s pretty straightforward. It
has an 8-bit register inside and

00:30:31.630,00:30:35.634
then what it does is at every
clock edge, if the reset line is
asserted, it’ll set its internal

00:30:35.634,00:30:39.805
state to zero; otherwise if the
enabled line is asserted, it’ll
increment the count by one,

00:30:39.805,00:30:44.910
otherwise it will do nothing.
This is, like, a simple example
of some stateful circuit. Uh,

00:30:44.910,00:30:50.048
Verilog code on the top left.
Graphical representation on the
bottom right. Oh, here’s a

00:30:50.048,00:30:55.454
translation of that circuit to
SMT. It’s a little bit different
than before cause I’m using

00:30:55.454,00:31:00.392
slightly more fancy features of
a Z3 here, I’m using data types
to represent kinda the different

00:31:00.392,00:31:05.530
parts of the counter, um, but
it’s still pretty
straightforward code. And, uh,

00:31:05.530,00:31:08.834
the thing of most interest here
is the thing on the bottom left,
what I’ve labeled the transition

00:31:08.834,00:31:13.371
relation, and this describes the
behavior of the counter. And
what this is staying, saying is

00:31:13.371,00:31:18.777
that if we have two states S1
and S2, if we assert that
counter T of S1 and S2 holds,

00:31:18.777,00:31:25.684
that means that state S1 stops
the state S2 after one cycle of
execution. And this is a pretty

00:31:25.684,00:31:30.455
straightforward translation of
the Verilog code. Like, we
could’ve done this mechanically.

00:31:30.455,00:31:32.457
Just in this example, I did it
by hand so it would be cleaner
to look at. So, let’s try to

00:31:32.457,00:31:36.928
prove something about this.
Here’s another proof. Uh, we
might want a property like, oh,

00:31:36.928,00:31:42.768
the counter’s count doesn’t
decrease over its execution. Um,
and we might have a precondition

00:31:42.768,00:31:47.773
to that theorem, like, as long
as it’s not reset, the counter
doesn’t decrease. Well, here’s a

00:31:47.773,00:31:51.910
load of code, let’s instantiate
two states, S1 and S2, and then
say okay, here’s our

00:31:51.910,00:31:56.681
precondition, like, asserting
this counter T thing says that
S1 represents the state of the

00:31:56.681,00:32:01.119
counter at cycle 1 and S2
represents the state of the
counter at cycle 2, and then we

00:32:01.119,00:32:05.590
have this other, uh,
precondition that the counters
not reset, and then here is when

00:32:05.590,00:32:08.627
you get a theorem statement. So,
we are trying to see if there is
a case where the count

00:32:08.627,00:32:12.464
decreases. So, if the count at
the second cycle can be less
than the count at the first

00:32:12.464,00:32:16.902
cycle, and as you might be able
to figure out just by thinking
about the implementation of the

00:32:16.902,00:32:20.939
counter, it turns out that this
theorem we were trying to prove
is false. The counter returns

00:32:20.939,00:32:25.710
SAT, or the, the SAT solver
returns satisfiable, which means
that there’s a, there’s a

00:32:25.710,00:32:30.148
counter example to our theorem.
And, here looking at the counter
example, we can actually get

00:32:30.148,00:32:33.518
some more information beyond
just, like, the theorem we were
trying to prove is false. Uh,

00:32:33.518,00:32:39.624
looking at this a little more
closely, we can see that here,
at S1, the, at cycle 1, the

00:32:39.624,00:32:45.096
counter had its reset line low,
its enabled line high and the
count was at 127. And then

00:32:45.096,00:32:48.166
thinking about this, we can
realize, like, oh, the count’s
wrapping around and that’s why

00:32:48.166,00:32:54.673
our theorem isn’t true. Okay, so
how do we apply this to CPU’s?
Well, the CPU is basically like

00:32:54.673,00:32:58.877
our example of the counter. It’s
just a little bit bigger. Like,
it’s a big circuit that has some

00:32:58.877,00:33:03.915
state, has some inputs, has some
outputs and we can think about
it kinda in the same way. Like,

00:33:03.915,00:33:07.385
just like we had this counter S
to represent the state of the
counter and the counter T to

00:33:07.385,00:33:12.224
represent the behavior of the
counter, we can just have a CPU
S and a CPU T. And this

00:33:12.224,00:33:15.460
translation can be done entirely
mechanically. So, on the
left-hand side I have Verilog

00:33:15.460,00:33:19.865
implementation for the gate
level implementation of a CPU
and on the right, is the

00:33:19.865,00:33:26.338
extracted Z3 code that describes
one cycle of executing the CPU.
And, uh, just like you can

00:33:26.338,00:33:30.141
simulate a CPU that has some
concrete state, like, with
standard Verilog simulation

00:33:30.141,00:33:35.347
tools, uh, using these
technologies, you can simulate a
CPU over symbolic state. So, you

00:33:35.347,00:33:39.050
can be, like, the CPU is in some
unknown state, let me reason
about what happens after some

00:33:39.050,00:33:43.488
number of cycles of execution.
You can even do reasoning over,
like, partially symbolic state.

00:33:43.488,00:33:46.992
Like, you might say if the
program counter is zero but all
other state is unknown, let me

00:33:46.992,00:33:51.997
reason about what happens over
several cycles of execution. And
so, now again visually, this is

00:33:54.366,00:33:59.037
what our reset theorem looks
like. So we are considering two
worlds where they can be in any

00:33:59.037,00:34:04.042
possible initial states and what
we do is we apply the reset
operation to, like, in one cycle

00:34:04.042,00:34:08.680
of execution, like, recert the
reset line and simulate the CPU
for one cycle, and then after

00:34:08.680,00:34:13.485
that, we, uh, let go of the
reset line and just let the CPU
execute a whole bunch of cycles,

00:34:13.485,00:34:19.991
and over symbolic states. And if
these converge to the same final
state, uh, no matter what the

00:34:19.991,00:34:25.463
initial possible states were,
then our reset operation, our
purge operation is correct. And

00:34:25.463,00:34:29.134
note that this is not like a
test. This is not doing, like,
test cases and checking for a

00:34:29.134,00:34:34.339
bunch of different things. It’s
a proof. This must hold for any
two possible starting states.

00:34:34.339,00:34:40.011
And if the SAT solver can prove
this correct, well it will
always work. And with these

00:34:40.011,00:34:43.081
tools, we get a really nice
workflow for developing this
reset code. So, remember, I was

00:34:43.081,00:34:46.785
talking about how it might be
complicated to write code that
has exactly the right effect at

00:34:46.785,00:34:50.822
the micro-architectural level.
Well, what’s kinda cool is that
with these tools, we can write

00:34:50.822,00:34:54.893
some code and just throw it at
the verifier and if the verifier
says UNSAT, then we’re done,

00:34:54.893,00:34:59.631
like, that means that the CPU is
always reset correctly. But if
the verifier says SAT, not only

00:34:59.631,00:35:03.134
do we know that our reset code
doesn’t quite do the right
thing, we find out that there is

00:35:03.134,00:35:07.505
a concrete counter example and
the tool can actually tell us,
oh, this particular piece of

00:35:07.505,00:35:12.477
micro-architectural state was
not property cleared, or not
provably cleared. And, then, as

00:35:12.477,00:35:16.681
the human in the loop, we can
think about this, consult the
implementation of the CPU and

00:35:16.681,00:35:19.884
tweak our code in order to have
the desired effect on that piece
of state, and just keep

00:35:19.884,00:35:25.290
repeating this process until
we’ve developed code that always
does the right thing. So, what

00:35:25.290,00:35:30.095
does this actually look like in
practice? Well, here’s a demo of
using our tool to verify a CPU.

00:35:30.095,00:35:35.533
And so, in this demo we’re going
to be using developing reset
code for the PICO RV 32

00:35:35.533,00:35:40.739
processor, which is a simple
RISC-V processor. And here I’ve
already converted to SMT, fully

00:35:40.739,00:35:43.241
automatically, and we’re just
going to develop the reset code
and also see the output from the

00:35:43.241,00:35:47.312
tool as it tells us, like,
either we’ve done it correctly
or we haven’t done it correctly

00:35:47.312,00:35:52.317
and what pieces of state we
haven’t cleared. Okay, so we go
ahead and run it and uh, to

00:35:54.919,00:35:58.623
start with let’s just run it for
one cycle of execution. So,
let’s see what happens when we

00:35:58.623,00:36:03.161
just assert the reset line of
the processor and let it go for
one cycle. Well, as we might

00:36:03.161,00:36:07.432
have expected, uh, it’s not
correctly reset. There’s a bunch
of internal state that’s not

00:36:07.432,00:36:11.669
reset. And this tool tells us
one particular piece of state
that it complains about and it

00:36:11.669,00:36:15.740
also gives us a concrete counter
example where it gives us an
entire CPU state where if you

00:36:15.740,00:36:19.678
take these two CPU states that
are different from each other,
and then, uh, try to apply the

00:36:19.678,00:36:23.581
reset procedure, they still
haven’t converged. And then the
tool also hopefully tries to

00:36:23.581,00:36:27.685
point out a bunch of other
differences between the states,
um, so this is like pointing out

00:36:27.685,00:36:32.657
a whole bunch of internal
micro-architectural state which
is not cleared. Um, and so as a

00:36:32.657,00:36:36.227
programmer, we can look at this,
like, think about what’s going
on, and in this particular

00:36:36.227,00:36:40.398
example, the one piece of state
that the tool complained about
way at the top was part of the

00:36:40.398,00:36:44.736
instruction decoder. And so,
thinking about this, this we can
be, like, oh, maybe we can just

00:36:44.736,00:36:48.907
write some code. Like, if we let
the CPU execute for more cycles,
maybe whatever is going on in

00:36:48.907,00:36:52.977
the instruction decoder, well it
might be, like, cleared up by
this. And so, what happens if we

00:36:52.977,00:36:57.716
just put a bunch of NOPS at the
start of region in which the CPU
executes from when it’s reset?

00:36:57.716,00:37:03.521
Um, Okay, the tool still failed
where I only ran it for one
cycle. To actually execute the

00:37:03.521,00:37:08.693
NOPS, I should probably simulate
the CPU for more cycles than
zero cycles. So, okay, here I am

00:37:08.693,00:37:12.063
running the tool again. It’s
complaining about something in
the instruction decoder, and

00:37:12.063,00:37:14.933
I’ll see that after a while it
starts complaining about
something else. So now it’s

00:37:14.933,00:37:19.871
complaining about the sub part
of the state called cpuregs,
that’s not always reset

00:37:19.871,00:37:25.376
correctly. And so, now again, as
the programmer, like, we can
think about this, and consult

00:37:25.376,00:37:29.481
the CPU implementation and if we
did that, we’d see that cpuregs
is something that is

00:37:29.481,00:37:34.385
corresponding to the
architectural general purpose
registers inside the CPU. And

00:37:34.385,00:37:38.923
so, now we can clear, uh, we can
figure out how to clear that
state, so we could just write

00:37:38.923,00:37:43.728
some code that goes and clears
all the 31 general purpose
registers. Okay, so let’s do

00:37:43.728,00:37:48.733
that and try running the tool
again. So here we’re running it
again, uh both symbolically

00:37:53.905,00:37:59.110
simulate from kinda unknown
initial states and see what the
tool can figure out. Okay, if a

00:37:59.110,00:38:02.213
couple cycles in, it’s
complaining about whatever is in
the instruction decoder, now

00:38:02.213,00:38:08.553
it’s complaining about CPU
registers, but we just wrote
code to clear them, and uh, oh,

00:38:08.553,00:38:13.558
the tool failed. Okay, so
scrolling up, we can see that,
uh, well in this case it just

00:38:15.727,00:38:19.531
said failed to prove, reached
maxed depth 10. Well, with this
tool, you have to tell it how

00:38:19.531,00:38:23.868
many cycles to simulate for. Uh,
you need to give it some upward
bound, otherwise it might go on

00:38:23.868,00:38:29.174
forever, and so I just didn’t
run it for long enough, so let
me go and re-run it, and I’m

00:38:29.174,00:38:32.644
going to speed up this video
cause you probably don’t want to
sit through like two minutes of

00:38:32.644,00:38:38.516
number crunching going on. Okay,
so the tool’s simulating for
many cycles now, and still

00:38:38.516,00:38:42.787
complaining about the cpuregs
thing, so whatever’s
corresponding to the

00:38:42.787,00:38:47.625
architectural general purpose
registers, and we’ll see that
eventually it stops complaining

00:38:47.625,00:38:50.762
about this cause it has actually
gone through enough of the reset
code that all that stuff is

00:38:50.762,00:38:54.332
reset, but now it’s complaining
about something else. Now there
is this thing called mem-wdata

00:38:54.332,00:38:58.570
that is not provably reset. And
so again, we can go back to CPU
implementation, figure out what

00:38:58.570,00:39:03.174
this corresponds to and this is
something related to the memory
write machinery. So, now we can

00:39:03.174,00:39:07.879
go and write a little bit of
code that deals with that. In
this situation, we can just

00:39:07.879,00:39:11.549
issue, like, a dummy write to
read only memory region, and
that end up having the desired

00:39:11.549,00:39:17.522
micro-architectural effect. And
finally, when we do this, we’ll
see that the tool, well once it

00:39:17.522,00:39:22.060
gets through enough cycles of
simulation, it finishes and it’s
like, oh, your CPU, your reset

00:39:22.060,00:39:27.131
sequence is actually proven to
be correct. And again, this is
not like a test. We didn’t try

00:39:27.131,00:39:31.202
this for a couple different
initial states. The tools
actually proven that this works,

00:39:31.202,00:39:35.673
no matter what state the CPU was
in before. That no matter what
state you start off in, after

00:39:35.673,00:39:42.146
applying this procedure, you
always end up in the same result
in state. So, that’s the tool.

00:39:42.146,00:39:46.651
And of course, we also wanted to
make sure that this idea of,
like, building a hardware in

00:39:46.651,00:39:50.888
this wacky way, where we have
third-party code that runs on
its own CPU and like, management

00:39:50.888,00:39:54.926
code that runs on another CPU
and stuff like that kinda makes
sense, and so we built a

00:39:54.926,00:39:59.130
hardware prototype. Like, here’s
a V1 prototype, which is a bunch
of development boards strung

00:39:59.130,00:40:03.067
together, and there’s a little
bit more going on here than that
was, uh, just in the talk. But,

00:40:03.067,00:40:07.739
as we can see, like, to the end
user, this behaves more or less
like any other cryptocurrency

00:40:07.739,00:40:14.012
hardware wallet. You can do
things like install applications
on it and uh, use it to assign

00:40:14.012,00:40:18.182
bitcoin transactions and things
like that. And, really the only
difference the user will notice

00:40:18.182,00:40:24.022
is that since it’s built around
this idea of like only one piece
of third-party code runs at a

00:40:24.022,00:40:28.493
time and between applications
switches you reset the
processor, like every once in a

00:40:28.493,00:40:32.530
while the device will ask you,
like, there’s nothing more to do
now, like, you need to reset the

00:40:32.530,00:40:36.401
device before you can continue.
Like, here for example, you’ve
installed a program, but in

00:40:36.401,00:40:40.938
order to launch the next
program, you have to clear all
the state, which the device will

00:40:40.938,00:40:46.611
do for you by, well asking you
to preset the reset button. And
then the rest of the

00:40:46.611,00:40:50.448
functionality, like here we’re
just uh, running a bitcoin
application. It works like any

00:40:50.448,00:40:54.485
other bitcoin hardware wallet.
So, I can get the private key,
uh the public key from the

00:40:54.485,00:40:57.855
device and then go on my
computer and set up a watch only
wallet, like, go here, open up

00:40:57.855,00:40:59.991
Electrum and put in a public
key. Uh, type in my very secure
password that’s I think defcon,

00:40:59.991,00:41:04.929
d e f c o n, it’s a weak
password. And it basically does
the thing. We first magically

00:41:22.313,00:41:27.618
received bitcoin so we can
actually send a transaction, and
uh, you can see like, of course,

00:41:27.618,00:41:31.656
we can’t actually send the
transaction from the PC cause
the PC doesn’t have the private

00:41:31.656,00:41:35.993
key. The whole point is to have
these transactions go through
the separate hardware device,

00:41:35.993,00:41:39.597
which is the only thing that
knows the private key. We can
use the PC to construct this

00:41:39.597,00:41:43.434
transaction, send it over to the
device, which will parse it,
display it on the screen in a

00:41:43.434,00:41:48.339
human-readable way, and only if
it’s confirmed, does the device
sing the transaction and send it

00:41:48.339,00:41:53.344
back to the PC, at which point
it can be broadcast on the
internet. And so, this is a

00:41:58.583,00:42:01.552
reasonable design for a hardware
wallet. Like, we could make it
run the same kinds of

00:42:01.552,00:42:05.723
applications that other hardware
wallets could. But we got this
really strong isolation of

00:42:05.723,00:42:10.094
mutually untrusting applications
by applying this idea of
deterministic reset and reset

00:42:10.094,00:42:16.601
based task switching. And we’ve
also, uh, made it work with
websites and stuff like that.

00:42:16.601,00:42:20.738
Um, I’m not going to go through
this now though but it’s
basically what you expect. Like,

00:42:20.738,00:42:25.543
you, you, uh, try doing
something on a website, if any
sensitive operations are

00:42:25.543,00:42:29.914
required to go through this
external device, it will display
a human-readable summary, um,

00:42:29.914,00:42:34.352
and only if you approve the
transaction on this external
device will the website uh, let

00:42:34.352,00:42:38.423
you proceed with the transaction
because it requires a signature
from a private key that’s on the

00:42:38.423,00:42:43.728
device that’s not accessible to
the PC. Um, so if someone tries
to do something malicious like,

00:42:43.728,00:42:47.231
delete your domain name, your
PC’s compromised and it’s trying
to do weird stuff on the

00:42:47.231,00:42:51.736
website, well you could just
cancel it on your device and uh,
the website wouldn’t let you

00:42:51.736,00:42:57.308
complete that operation. And so,
in conclusion, we’ve, we’ve
talked about how we can apply

00:42:57.308,00:43:01.813
the idea of turning it off and
on again as a building block for
better isolation, but how there

00:43:01.813,00:43:05.416
is also a little more detail
there, like, there’s a lot of
details to getting the

00:43:05.416,00:43:11.089
deterministic reset right and
there’s this neat idea of using
formal verification as a

00:43:11.089,00:43:14.959
technique for both developing
this reset code and also
reasoning about its correctness

00:43:14.959,00:43:19.197
in order to gain confidence that
this primitive that we’re using
for isolation uh, actually does

00:43:19.197,00:43:25.536
the right thing – the thing that
we expect it to do. Um, all, all
the code that was uh, shown in

00:43:25.536,00:43:28.806
the demos is available online at
this link if you want to check
it out and play around some

00:43:28.806,00:43:34.512
formal methods tools. Um, and
uh, I hope that the impact of
this presentation is that we, as

00:43:34.512,00:43:39.350
users, uh, more of us start
using and demanding uh, for, uh,
for demanding these transaction

00:43:39.350,00:43:42.920
authorization devices and
demanding that websites have
support for this sort of thing,

00:43:42.920,00:43:46.424
so I think you can really
increase our security and uh, I
also hope that we, as

00:43:46.424,00:43:50.995
developers, well we start
supporting factoring out
approval decisions, and also I

00:43:50.995,00:43:55.166
think it would be really cool to
see more people use formal
verification as a tool to

00:43:55.166,00:43:59.537
improve security. Like, maybe in
the long term, maybe eventually
we can move beyond the just it

00:43:59.537,00:44:03.207
hasn’t been broken yet, and
towards having a principled
reason for believing that a

00:44:03.207,00:44:09.113
system is secure. Um, and I
think I don’t have any time for
questions, but I’ll be outside

00:44:09.113,00:44:14.118
if anybody wants to talk to me.
[applause]

