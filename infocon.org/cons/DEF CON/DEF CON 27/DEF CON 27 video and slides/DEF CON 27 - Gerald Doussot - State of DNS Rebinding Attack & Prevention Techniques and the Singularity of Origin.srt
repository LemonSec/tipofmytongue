00:00:00.100,00:00:05.105
>>Let’s get started, uh please
give Gerald and Roger a very
DefCon welcome. [applause]

00:00:08.709,00:00:13.714
>>Hello DefCon, um, hello
everybody. Um, today we going to
um discuss the current state of

00:00:21.321,00:00:25.959
uh DNS rebinding including
attack recent attack and
prevention technique. And we

00:00:25.959,00:00:32.399
also discuss um all uh tool uh
singularity of origin its a DNS
rebinding attack framework. And

00:00:32.399,00:00:37.404
how its incorporates this new
um, technique and how you can
use them today. So our

00:00:39.740,00:00:46.280
contribution in a domain of DNS
rebinding um, are twofold. Uh,
the new tool singularity uh it

00:00:46.280,00:00:53.020
has everything y- you need to
perform DNS rebinding. It is
reliable, it is performant. It

00:00:53.020,00:00:58.558
has built in payload for um
command services. It can perform
uh automatic service detection

00:00:58.558,00:01:03.497
and exploitation. Um, the second
area of contribution uh is uh in
the research of uh, technique to

00:01:08.201,00:01:13.206
improve the speed of rebinding
and how to bypass command DNS
rebinding protection. So um,

00:01:16.009,00:01:22.716
I’ll are talk will be
articulated around um, uh, the
new tool and the the techniques

00:01:22.716,00:01:27.721
uh it incorporates and the we
will a- include a customary um
uh, refresher on the basic of uh

00:01:30.424,00:01:35.262
uh DNS rebinding. We will also
discuss um uh, an architecture
we have implemented in

00:01:35.262,00:01:41.335
singularity. Which allow you to
indirectly interactively browse
uh, um, a hooked browser

00:01:41.335,00:01:47.741
internal network. So who are we?
We are Gerald Doussot and Roger
Meyer. We are security

00:01:47.741,00:01:51.178
consultant at NCC Group. Uh we
are attached the San Francisco
office. And uh we are the

00:01:51.178,00:01:56.183
authors of a Singularity of
Origin. So why should you care
about DNS rebinding? Most

00:02:04.591,00:02:10.430
developers understand the when
they bind their application to
all interfaces, that they expose

00:02:10.430,00:02:15.435
themselves to remote access and
this is not a good idea. So what
do they do to fix this? They

00:02:17.604,00:02:23.777
bind the application to a local
host. They think only trusted
users can access its a trusted

00:02:23.777,00:02:29.850
environment, they don’t need
authentication, right? And then
all these DNS rebinding issues

00:02:29.850,00:02:35.722
happen. The eos cryptocurrency
wall that is vulnerable, Google
home, Roku, Sonos speakers are

00:02:35.722,00:02:41.795
vulnerable. The get ethereum
client is vulnerable. Redis,
Memcached, the Elasticsearch,

00:02:41.795,00:02:47.934
the Kubernetes dashboard on
Minikube is vulnerable to DNS
rebinding allowing RCE and VM

00:02:47.934,00:02:52.939
Escape. The Raids Webconsole was
vulnerable. We see more more
applications exposing uh ah web

00:02:56.076,00:03:01.615
ah http server on the localhost.
Especially through the
popularity of framework such as

00:03:01.615,00:03:07.854
Electron. The rise of IoT
devices exposing sensitive
interfaces on internal networks

00:03:07.854,00:03:13.860
without authentication will make
this even worse. We would also
like to clear up certain

00:03:13.860,00:03:19.733
misconceptions such that DNS
rebinding is slow and can be
solved by out of the box DNS

00:03:19.733,00:03:24.738
filtering products or services,
which is not the case. We would
like to start with a quick

00:03:27.240,00:03:32.245
refresher on how DNS rebinding
works. The origin is consists of
the scheme, host and port. To

00:03:38.185,00:03:43.190
documents share a same origin if
they have the identical scheme,
host and port components. The

00:03:45.959,00:03:51.064
same origin policy is an
important security concept
implemented in browsers, static

00:03:51.064,00:03:56.436
dates hold two different sites
with different origins can
interact with each other.

00:03:56.436,00:04:02.909
Certain interactions are always
allowed between all origins such
as forms submissions, links,

00:04:02.909,00:04:07.914
redirects, content embedding.
The cross origin reads are
typically not a lot. This is

00:04:10.984,00:04:16.490
important for example if you’re
logged in to gmail dot com and
browse to an attacked controlled

00:04:16.490,00:04:21.495
website, you don’t want the
attacker control code to be able
to read your gmail messages. DNS

00:04:24.097,00:04:29.102
rebinding permits us to bypass
the same origin policy. We like
to show you a visual walkthrough

00:04:33.140,00:04:39.813
to make it easier to understand
the concept. So on the left
side, we have the victim, which

00:04:39.813,00:04:44.818
is the browser. We have a target
service, which can be a service
on the victim’s local host or on

00:04:46.920,00:04:51.925
the eternal network. We have an
attacker which consists of a DNS
server and the web server on

00:04:53.994,00:05:00.367
this public IP. So on the right
side is the internet, on the
left side we have the intranet.

00:05:00.367,00:05:06.406
The victic can access the target
service without authentication
and the attacker cannot directly

00:05:06.406,00:05:13.180
reach the target service,
otherwise we wouldn’t need DNS
rebinding. So step one, the

00:05:13.180,00:05:18.185
victim browses to the attacker’s
website hosted on rebinds dot IT
that domain in. We respond with

00:05:21.021,00:05:27.294
a DNS A record of the public IP
address and load some Javascript
which keeps running in the

00:05:27.294,00:05:32.299
victim’s browser and waits until
the DNS record expires. Once it
expired, we make another request

00:05:35.969,00:05:41.841
in the same origin. This time we
respond with a different IP
address. The IP address of our

00:05:41.841,00:05:46.846
target service 127 0 0 1. Notice
that the origin rebind the IT
did not change. We did not

00:05:51.017,00:05:57.424
violate the same origin policy.
The browser will make this
request and when will allow the

00:05:57.424,00:06:04.197
Javascript to read the response
and where we can exfiltrate it
back to the attacker. All of

00:06:04.197,00:06:10.003
this is possible because we did
not violate the same origin
policy. It’s still pointing

00:06:10.003,00:06:16.843
through rebind on IT only change
the IP address. This was a high
level overview, which omitted a

00:06:16.843,00:06:22.716
lot of details. There uh a lot
of previous good research, which
you can look at if you want to

00:06:22.716,00:06:27.721
know uh how a more about the
details. We would like to show
you first demo on iOS using

00:06:30.123,00:06:36.229
Safari where we can achieve DNS
rebinding in just 5 seconds.
Using the cache flooding

00:06:36.229,00:06:41.234
technique. In this case we will
be exploiting a home router on
router dot asus dot com, um and

00:06:45.105,00:06:50.844
we will be just reading the
index page and displaying the
results in a Javascript alert

00:06:50.844,00:06:55.849
box for demo purposes. So this
is Safari we’re going to router
that asus account to target we

00:07:00.820,00:07:06.593
are trying to exploit. So now
we’re setting up the attack.
We’re going to the single RT

00:07:06.593,00:07:12.832
manager web interface. We are
setting the target host to
router dot asos dot com. We’re

00:07:12.832,00:07:19.572
leaving the target port at port
80, we’re setting attack payload
to a simple fetch get. We’re

00:07:19.572,00:07:25.178
using the first then second
strategy. And interval of 1
second and we’re enabling the

00:07:25.178,00:07:30.183
cache flooding technique. We’re
starting the attack. This only
takes uh about 5 seconds and we

00:07:33.787,00:07:40.293
display the results. Uh what we
see here is the return of the
index page, which is just a

00:07:40.293,00:07:46.433
redirect to the main login that
ASP uh webpage, but it shows
that we were able to read the

00:07:46.433,00:07:51.438
response from an internal system
to home route. [applause] Thank
you Roger. Now that we have a

00:08:00.947,00:08:07.220
grasp on the basics of uh DNS
rebinding, uh, we are going to
explore how we made an a DNS

00:08:07.220,00:08:12.225
rebinding um more reliable
within singularity. So lets say
you have to you are fond of uh

00:08:14.427,00:08:19.833
horse riding and uh you are
trying to pl- plan your ne- next
vacation and you found a website

00:08:19.833,00:08:24.537
that just tell you how to do
that, um, there’s nothing with
this website, um displayed

00:08:24.537,00:08:30.310
permanently, uh, is a Trojan
Horse picture in fact, uh the
website was compromised and is

00:08:30.310,00:08:37.050
running um, a hidden high frame
with singularity. So you connect
to the website and you um don’t

00:08:37.050,00:08:42.422
know it the malicious JavaScript
from Singularity and uh uh the
code it makes its first DNS

00:08:42.422,00:08:48.795
query. So what is in a query?
Um, as you can see, the the the
query is made of several

00:08:48.795,00:08:54.467
components. These uh components
and codes, uh everything
Singularity needs to perform an

00:08:54.467,00:09:00.673
attack. So first you have a
start tag um, then you have to
attacker host IP address where

00:09:00.673,00:09:06.913
we run Singularity. Then you
have to target IP address or it
can be a name as well followed

00:09:06.913,00:09:13.820
by a session ID, uh session
allow for the uh use of
concurrent uh users and and uh,

00:09:13.820,00:09:18.825
targets. Then uh you have the
DNS rebinding strategy
Singularity uh incorporates uh a

00:09:21.227,00:09:27.667
number of uh de- uh different
DNS rebinding strategy here you
can see uh uh fs uh first and

00:09:27.667,00:09:34.174
second also known as a time
varying attack. Uh this is the
simplest uh and most reliable uh

00:09:34.174,00:09:39.479
DNS rebinding strategy you can
implement. Then you have the n
attack, then you have the

00:09:39.479,00:09:44.484
attacker domain. The one which
I’ve ever purchased or uh uh
compromised. So um, to improve

00:09:48.922,00:09:54.561
reliability, you want to remove
uh any uh http performance
enhancing technique that may

00:09:54.561,00:09:59.566
impede DNS rebinding or stop it
completely in its track. So um,
we try to do the http caching uh

00:10:04.037,00:10:08.741
in uh all browsers
implementation and uh
intermediate cache to ensure

00:10:08.741,00:10:15.582
that the browser uh get a fresh
copies of folder resources. Uh
we also instruct singularity to

00:10:15.582,00:10:20.587
drop uh idle connection from
browsers. So when it is time to
uh rebind against uh target IP

00:10:22.689,00:10:27.694
address, then uh browser doesn’t
maintain a connection to a
singularity. What about TTL

00:10:30.063,00:10:35.068
Value, um, mostly try to and
other tools, uh, use uh a value
of uh one second uh we tried

00:10:38.805,00:10:45.745
zero in the hope that um, it
sill break stuff, it didn’t. Uh,
zero second is a valid TTL value

00:10:45.745,00:10:52.585
so we just stick with that. So
how do we know that we have uh
successfully rebinded against

00:10:52.585,00:10:57.590
the target service? Um, its
directly uh singularity use an
index token in the html body. Um

00:11:00.460,00:11:06.733
so is this index token present?
Um, then the Javascript code
knows uh its still pointing

00:11:06.733,00:11:12.505
against Singularity. Is this
token is uh just appears on the
nex- next fetch? Uh, then it

00:11:12.505,00:11:18.378
means that you have successfully
rebinded. We recently moved to a
custom http header. Uh however

00:11:18.378,00:11:24.217
the index token is still useful
in a a one specific DNS
rebinding strategy. Uh, where we

00:11:24.217,00:11:29.722
uh advertly uh terminate the
connection uh from singularity
to the browser. And the browser

00:11:29.722,00:11:35.728
get confused, we will uh going
to moditize uh on this later.
Something you need to consider

00:11:35.728,00:11:40.833
as well is that uh you may uh
encounter an environment uh
where there is an IPS ni- uh IDS

00:11:40.833,00:11:45.838
um, and uh this IPD/IDS may
admit their own uh various uh
DNS queries, when the C uh

00:11:49.509,00:11:54.514
request from the uh the the
target browser. So it it means
that you may receive uh, uh, uh,

00:11:56.749,00:12:01.688
IP address uh out of sequence
when you make your DNS query. Um
um, which um, um means that um,

00:12:04.657,00:12:08.995
the target browser will never
see the IP address of
singularity. Only the targets.

00:12:08.995,00:12:15.034
So we’ll never be able to know
the code and uh perform DNS
rebinding. So to address that we

00:12:15.034,00:12:20.039
um have an implemented a random
DNS. Ran- um rebinding strategy.
Where um, um, uh, we respond

00:12:22.542,00:12:29.082
over with the attacker IP
address or the service um, IP
address uh which is a much

00:12:29.082,00:12:34.087
slower technique in general, but
you could get lucky. So um,
we’re now going to explore we um

00:12:37.123,00:12:42.128
improve the speed um, um, of DNS
rebinding and uh Singularity. So
the first to know is that

00:12:44.330,00:12:50.536
implementation details matter.
Um, the DNS uh rebinding speed
will vary uh depending on the

00:12:50.536,00:12:56.109
host implementation. Whether you
use uh a Windows or Linux link
environment uh Operating System

00:12:56.109,00:13:01.047
such as um, Linux or macOS, the
browser vendor, uh IE/Edge uh
Firefox, uh Chrome and all uh

00:13:03.149,00:13:08.154
it’s spinoff. Uh and Safari. The
target specification matters um
whether you use uh uh service,

00:13:11.357,00:13:16.896
you you targeting a service
that’s bound to the loop back
interface or um, a on the

00:13:16.896,00:13:21.901
private network or a remote
public IP address. Obviously we
just uh solve at a um external

00:13:23.970,00:13:28.541
factor main practice piece such
as the presence of an IPS and
IDS. so just you’re straight,

00:13:28.541,00:13:33.546
DNS binding may take 40 plus
minutes uh when uh a using Edge.
Uh and down to three seconds

00:13:36.015,00:13:41.788
depending of what strategy you
use. Uh Singularity can
automatically uh fingerprint to

00:13:41.788,00:13:46.793
optimize for speed um in some
conditions. We’ll discuss this
later. So the time-varying

00:13:49.395,00:13:56.235
attack uh uh Singularity’s first
then second is approximately 60
seconds on all browsers except

00:13:56.235,00:14:01.941
uh IE and Edge. Um, we um,
there’s another technique called
multiple answers that we didn’t

00:14:01.941,00:14:07.814
believe would work uh, however,
uh one of our colleague, Michael
Roberts, from NC Group, uh,

00:14:07.814,00:14:13.386
created a a small proof of
concept. Uh demonstrating that
it was working on Windows when

00:14:13.386,00:14:20.059
specifying an IP address 127 dot
0 dot 0 dot 1 and that we were
achieving rebinding time of uh

00:14:20.059,00:14:25.765
uh 3 second once we implemented
that. However it didn’t work
with um the same technique

00:14:25.765,00:14:30.770
didn’t work with Unix like
machine uh such as Linux or um
macOS. However, after a big of

00:14:33.506,00:14:39.245
digging, when we spec- specify
if um uh target same as IP
address of 0 dot 0 dot 0, uh we

00:14:39.245,00:14:45.251
achieve uh approximately 3
second um rebinding time. So now
we have a solid and fast uh DNS

00:14:45.251,00:14:51.958
rebinding against all loop back
band uh services. Just
illustrate that the high level

00:14:51.958,00:14:57.764
of the multiple answer rebinding
strategy work, so the target
browser will emulate its DNS

00:14:57.764,00:15:02.702
query to rebind dot it, uh were
we ran Singularity as usual. Um,
instead of responding um, with

00:15:04.837,00:15:09.842
the IP address of the attacker
then, uh the IP address of the
service uh, as we do for the

00:15:12.645,00:15:18.451
time varying attack. We respond
with both recorders and time. So
then target browser is going to

00:15:18.451,00:15:23.456
keep um pulling uh the service
um and um but determine wherever
its pointing against Singularity

00:15:26.626,00:15:32.398
or the targets. Uh, ve-
Singularity is going to then
implement a sub-stage a uh

00:15:32.398,00:15:39.305
firewall uh uh firewall rule
that will uh advertently block
the traffic. This will force the

00:15:39.305,00:15:44.310
browser uh to um, a connect uh
to the target service using the
second IP address we provided

00:15:46.813,00:15:51.818
earlier. So the multiple answer
technique um strategy work very
well for loop back bands type of

00:15:56.189,00:16:01.060
uh services so it just service
uh uh for instance, for
instances listening on the 127

00:16:01.060,00:16:06.799
dot 0 dot 0 dot 1. But we were
getting inconsistent results for
other target specification. For

00:16:06.799,00:16:11.804
instance on the uh private
network. Uh where a one attempts
out of 5 would uh succeed. Uh we

00:16:15.041,00:16:20.746
implemented another technique
called DNS cache flooding. Uh
this worked very well in uh

00:16:20.746,00:16:25.751
Google Chrome and uh, Safari and
iOS platform uh, basically,
basically uh floods the cache of

00:16:28.454,00:16:35.428
the browser with dozens of
queries um and uh, a you can
reduce DNS rebinding time from 5

00:16:35.428,00:16:42.001
to 40 seconds. Which is a great
progress over the average of 60
seconds. Uh our other demo was

00:16:42.001,00:16:47.540
using this technique. Uh when
we’re using iOS and we got a
rebinding time of 5 seconds. Um,

00:16:47.540,00:16:54.013
flooding the cache is performed
in a separate web worker. So
here you have a Chrome uh uh

00:16:54.013,00:16:56.015
console and in blue uh you have
your regular uh attempts to
fetch uh uh resources to

00:16:56.015,00:16:58.017
determine whether um, um, we
were printing against target
service or not. And uh, uh in

00:16:58.017,00:17:02.955
between though this uh request
you have thousand of query but
still the cache of the browser

00:17:12.632,00:17:19.372
DNS cache. Uh in attempt to a
fix the IP address to the
Singularity server. Forcing then

00:17:19.372,00:17:24.377
the browser to point to the
service for instance 127 dot 00
dot 1. So we have a illustrated

00:17:27.013,00:17:33.753
in this table some configuration
and uh what can you expect. Uh
uh from a a DNS rebinding time

00:17:33.753,00:17:38.758
perspective. Roger. >>Let’s talk
about DNS rebinding protection
bypasses. Using Singularity we

00:17:45.031,00:17:51.337
can bypass all known DNS
rebinding protections such as
those implemented in open source

00:17:51.337,00:17:56.342
DNS servers, unbound or DNS
mask. We would like to emphasize
that common recommendations and

00:17:58.811,00:18:03.749
default configurations do not
provide complete protection. How
do common DNS protections look

00:18:06.752,00:18:11.757
like? Most solutions block
certain DNS responses at the
parameters. So when they enter

00:18:14.060,00:18:19.065
your internal network. Some
tools block of RFC 1918 private
IP addresses, such as 10 slash 0

00:18:21.767,00:18:26.772
192 dot 68 slash slash 0. Some
tools block local host IPs. 127
slash 8. Some tools can be

00:18:30.876,00:18:36.449
configured with which I- ch- IP
addresses you’re using
internally. Such if you’re using

00:18:36.449,00:18:41.387
public IPs in your internal
network you can get those
blocked. Some tools block the 0

00:18:41.387,00:18:46.392
slash 8 range. DNSmasq and
Unbound are two widely open
source DNS servers. They are

00:18:49.295,00:18:54.300
used in tools such as pfSense,
OpenWRT, and certain home
routers. There are also free

00:18:57.203,00:19:02.141
public DNS services such as
Ciscos open DNS which advertised
that they have uh rebinding DNS

00:19:05.845,00:19:12.618
rebinding protection implemented
for open DNS. It’s called block
internal IP addresses and that

00:19:12.618,00:19:17.623
just blocks private IPs. DNSmasq
has a setting called stop DNS
rebind, which blocks private

00:19:23.229,00:19:28.234
IPs. The 0 slash 8 range and the
127 slash 8 range. This does not
block local host. We will talk

00:19:31.804,00:19:38.677
about what we mean by a local
host in a minute. The unbound
DNS server has a configuration

00:19:38.677,00:19:41.981
setting called private address
where you can configure internal
IP address range and this will

00:19:41.981,00:19:45.751
then be blocked. This is not
blocked at 0 0 0 IP. The 127 0 0
1 or the local host. Our first

00:19:45.751,00:19:48.854
protection bypass is using this
0 dot 0 dot 0 dot 0 IP address.
This is a non routable or

00:19:48.854,00:19:50.856
invalid IP address, but it works
very well on Linux and macOS
using Firefox and Chrome to

00:19:50.856,00:19:52.858
access the local host. This
bypasses protections that block
DNS responses containing the IP

00:19:52.858,00:19:54.860
address of 127 0 0 0 1 or the
whole 127 slash 8 range. When we
query Singularity. We can

00:19:54.860,00:19:57.530
specify the target here, so we
can use the 0 dot 0 dot 0 target
and then the DNS response will

00:19:57.530,00:20:02.535
be an A record pointing to 0 0 0
0. What if the DNS protection
solution blocks all internal IP

00:20:11.844,00:20:17.316
address? Then we can use C
names. Canonical Name records
are DNS records which map one

00:20:17.316,00:20:23.422
domain name to another domain
name. We can return a DNS C
record instead of an internal IP

00:20:23.422,00:20:27.993
address. So just wiki dot NC
Group dot come or jenkins dot
internal dot corp dot com.

00:20:27.993,00:20:32.998
Whatever the target is. This
bypasses protections that block
DNS responses con- on of private

00:20:35.734,00:20:40.740
IP addresses. The local internal
DNS server will then resolve the
CNAME for us. And you don’t want

00:20:42.942,00:20:49.782
to block internal DNS resolution
if you want to use internal host
names. When we query Singularity

00:20:49.782,00:20:56.388
we specify the target here. So
instead of an IP address, we
specify wiki dot nccgroup dot

00:20:56.388,00:20:59.458
com. And then the DNS response
will be a CNAME pointing to wiki
dot nccgroup dot come. Our third

00:20:59.458,00:21:01.927
bypass is a variation of the
previous technique. We can use
the CNAME of local host. This

00:21:01.927,00:21:06.932
bypasses protections that block
DNS responses containing 127 0 0
1. This works well in Linux and

00:21:11.437,00:21:13.439
um, macOS. We query Singularity,
we specify local host here and
then in the response we just

00:21:13.439,00:21:18.444
return a C name pointing to
local host. >>Ok. Now we going
to uh discuss uh technique to

00:21:22.948,00:21:29.321
implemented in um uh Singularity
uh to uh browse the um, a victim
internal network after a DNS

00:21:29.321,00:21:34.693
rebinding. So tools such as BeEF
the Browser Exploitation
Framework and FireDrill a DNS

00:21:34.693,00:21:39.698
attack tool uh can use a hook
browser to uh uh access uh
targets uh which are not

00:22:36.989,00:22:42.695
typically available directly
from an attacker. Such as your
home appliance or a corporate

00:22:42.695,00:22:49.568
environments assets over via uh
cross set scripting or DNS
rebinding. So we know that uh

00:22:49.568,00:22:54.573
BeEF uh required to the attacker
to configure uh its uh browser
or operating system to use the

00:22:57.109,00:23:02.047
BeEF application server, uh, to
uh uh to uh available
functionality. Uh we don’t know

00:23:04.083,00:23:09.755
how FireDrill uh does it since
the code uh and the binaries are
not available uh. We imple-

00:23:09.755,00:23:15.461
implemented the services in
Singularity without requiring
the attacker to uh uh setting up

00:23:15.461,00:23:22.134
its browser to use an http
proxy. But instead just to uh
point to Singularity via uh

00:23:22.134,00:23:27.139
using no more http requests. So
the hi- to high level, once your
um, browser uh has been hooked,

00:23:29.174,00:23:35.814
um, or the victim browser’s been
hooked, uh the browser will make
a websocket connection uh to the

00:23:35.814,00:23:41.820
Singularity um, application
server and await for
instruction. The uh attacker we

00:23:41.820,00:23:48.627
use is a browser to connect to
Singularity and uh uh display
the list of a um a victim that’s

00:23:48.627,00:23:53.632
been hooked and select 1 to
browse. So uh lets say you want
to connect to the home directory

00:23:56.468,00:24:01.407
of a server bound to 127 dot 0
dot 0 dot 1 uh the attacker
browser will emit a normal http

00:24:03.876,00:24:08.213
request to obtain this
directory. The Singularity
application server will

00:24:08.213,00:24:13.218
translate this into a websocket
operation uh to fetch the
resource. Um, then the target

00:24:16.121,00:24:21.393
browser using the Singularity
Javascript code will translate
its websocket fetch operation

00:24:21.393,00:24:26.398
into a normal uh fetch API call.
To uh the home directory. Then
that will be sent back all the

00:24:29.368,00:24:34.373
way. Uh, back to the attacker
browser sorry. At the load value
we just customize the Golang

00:24:36.608,00:24:42.915
RoundTripper interface and we
use uh websocket plain text
protocol to package uh each

00:24:42.915,00:24:47.920
fetch request and response, um,
since we use a base 64 encoding
uh the size of the message is

00:24:50.689,00:24:55.794
increased by 4/3 of the original
length of the message. Please
note that you don’t have to use

00:24:55.794,00:25:02.067
a a browser, you can use any uh
user agent. You can use CURL,
http uh inspecting proxy such as

00:25:02.067,00:25:07.072
um Burp PortSwigger, OWASP ZAP
or SQLMap and and so on. So when
we implemented the sock injector

00:25:11.510,00:25:16.949
and Singularity we uh we
encountered a number of change,
but the first assumption we made

00:25:16.949,00:25:23.188
was that we did not care about
the cookies exchange between the
victim browser and the victim

00:25:23.188,00:25:28.193
service, the target service. Uh
however our first uh, test case
was Duplicati, a backup solution

00:25:30.229,00:25:37.136
uh that was vulnerable to uh DNS
rebinding. And uh as you can see
the code snippet here, uh,

00:25:37.136,00:25:44.076
Duplicati is extracting xsrf
token from the cookie. Uh to
generate length value to browse

00:25:44.076,00:25:49.181
the Duplicati application and
perform a number of action
including running a backup. So

00:25:49.181,00:25:52.785
Singularity didn’t work uh with
that. So um, we had to uh uh
consume this cookie, so we um,

00:25:52.785,00:25:57.790
we read them from the target
browser and we transit, transmit
them to Singularity server over

00:26:04.062,00:26:09.768
websocket and then the
Singularity application server
set them uh on the attacker uh

00:26:09.768,00:26:15.474
browser for the target domain uh
that uh Singularity uh has
constructed. Um, for httpOnly

00:26:15.474,00:26:20.479
cookie uh we don’t really care
about them. Um they cannot be
read by Javascript. Uh so they

00:26:22.648,00:26:28.320
cannot be used by Javascript on
the attacker um, browser. So we
let the target the target

00:26:28.320,00:26:33.325
browser handle them um for us.
Another challenge uh is that to
be able to read uh cookies uh

00:26:36.562,00:26:41.667
when you perform a fetch
request, a fetch API, you have
to pass the credentials.

00:26:41.667,00:26:47.206
Includes option to the fetch
requests and if your application
require um, um http

00:26:47.206,00:26:52.211
authentication this is not going
to work. And a why is that? This
is illustration this slide um so

00:26:54.847,00:27:00.018
let’s say you have a service
that require http authentication
and you issue the commands uh

00:27:00.018,00:27:07.025
fetch uh http 127 dot 0 dot 0
dot 1 with the credentials
includes, then authentication

00:27:07.025,00:27:12.030
dialog box appears. Uh that will
uh warn the user that something
is amiss. So we don’t want that.

00:27:14.433,00:27:19.471
Um, however, if you type the
same command but we you pass a
different argument credentials

00:27:19.471,00:27:25.878
omit, then there’s no, there’s
no uh authentication dialog box,
so the victim is non the wiser.

00:27:25.878,00:27:32.384
So uh when uh we have cookie and
http authentication uh required
then we forget about we actually

00:27:32.384,00:27:37.389
don’t transmit the the cookie to
uh uh the attacker. >>Ok now
that Gerald introduced this, to

00:27:43.695,00:27:49.434
this hook and control feature,
we would like to show you how
this works in a demo. For this

00:27:49.434,00:27:54.973
demo we will have two browsers.
One is the victim, the other one
is the attacker. In this case

00:27:54.973,00:27:59.912
they will be both on the same
machine, but in the real world
attack, this does not have to be

00:27:59.912,00:28:06.151
the attacker can be anywhere. So
the victim will have a Jenkins
instance installed on the local

00:28:06.151,00:28:11.156
host and the attacker will try
to access this. So this is the
victim, Chromium browser uh

00:28:14.326,00:28:20.032
which has this Jenkins instance
running listening on the local
host. Now we’re switching to the

00:28:20.032,00:28:25.504
attacker. This is the hooked uh
victim client , which will show
up here, so you reload the page

00:28:25.504,00:28:30.642
and showed its currently empty,
there’s nothing there. Switching
back to the attacker, sorry to

00:28:30.642,00:28:35.213
the victim browser. We’re going
to the Singularity manager
interface. We’re setting the

00:28:35.213,00:28:41.653
target to 0 0 0 for local host.
Target port is 80 80. We’re
using the hook and control

00:28:41.653,00:28:46.658
attack pay load. We’re using the
multiple answers attack
strategy, we’re using 1 second

00:28:48.727,00:28:53.732
interval. We’re starting the
attack. It only takes 3 seconds.
The attack was successful. We’re

00:28:55.934,00:29:01.373
now we’re switching back to the
attacker, we are reloading the
page and we can see this new

00:29:01.373,00:29:08.246
victim session. So we click on
it and we can now browse the
victims’s Jenkins instance over

00:29:08.246,00:29:13.251
the internet. [applause] So the
attacker browse this cr-
credentials endpoint. We’re

00:29:21.827,00:29:28.266
going back to the uh victim to
show the requests. The first
request is this slash

00:29:28.266,00:29:33.839
credentials which the attacker
is browsing to to show you how
this looks like. And we can see

00:29:33.839,00:29:40.278
slash credentials, the remote
address is 0 0 0 for local host.
And the request URL is the

00:29:40.278,00:29:46.918
origin still points the
attacker. We like show you how
we exfiltrate our data back to

00:29:46.918,00:29:48.920
the attacker. So this soows
endpoint is how we send and
exfiltrate the data back to

00:29:48.920,00:29:51.189
Singularity. Uh using websocket
messages and that’s how we can
how the attacker can then browse

00:29:51.189,00:29:55.560
to a Jenkins instance. >>Ok, now
we’re going to discuss how to uh
scan for vulnerable hosts and

00:29:55.560,00:29:59.898
and services. So in the past
theirs been uh many very smart
attempts to replicate uh and map

00:29:59.898,00:30:02.701
uh behavior in the context of uh
the browser. But we’ve had the
power of raw sockets, so many of

00:30:02.701,00:30:04.703
the solution uh we have looked
at uh are are very not
completely reliable or do to

00:30:04.703,00:30:09.708
much for our purpose for
instance we don’t care where
ever SSH port is open or not uh.

00:30:38.603,00:30:43.608
DNS rebinding is concerned uh
with uh exploiting uh issue with
http uh resources so far. Uh so

00:30:46.645,00:30:51.717
the only thing we care about is
uh does it speak http? So we
implemented a very uh simple

00:30:51.717,00:30:56.722
solution about leverage uh
modern API and um and uh so its
uh uh including sorry, fetch,

00:30:59.958,00:31:04.896
abort, uh for uh a implementing
a time out. So um, we distribute
the the listed target we want to

00:31:09.434,00:31:14.439
scan uh, it- uh includes IP
address and uh a ports a across
uh 4 web workers. We only fetch

00:31:17.075,00:31:23.982
uh the resource setter uh we
don’t bother with the the
responsibility and we have a

00:31:23.982,00:31:28.854
hardcode limit of 300
millisecond uh before we move on
onto a next target if you don’t

00:31:28.854,00:31:33.859
get se- uh sufficient results.
Um, so the time out we obviously
drives how fast a scan a host or

00:31:36.928,00:31:41.933
network. It is fast for http
open port obviously and fast as
well for closed ports because if

00:31:44.002,00:31:49.007
you if, you immediately send a
packet to a a close port the
TCP/IP attack of the targets

00:31:49.007,00:31:54.446
will respond with a reset packet
if nothing is listening on this
port. Uh it is slower for

00:31:54.446,00:32:00.018
firewall ports but because here
typically a firewall will drop
any response, so you don’t know

00:32:00.018,00:32:06.291
what’s going on. Uh so the scan
will uh wait to the millisecond
and then move onto another

00:32:06.291,00:32:11.596
target. Uh and so as well
possibly for slower http service
and uh over protocol that are

00:32:11.596,00:32:18.136
not handled by fetch. Um so uh
we want to use a lower timeout
when you’re scanning a LAN or

00:32:18.136,00:32:23.141
fast HTTP service or you can use
ht- uh higher timeouts when you
scan uh over network uh and um I

00:32:26.778,00:32:33.752
can do one but I have uh higher
densities such as VPN. Other
interesting bits and pieces, uh

00:32:33.752,00:32:40.525
we use the classic webRTC IP
address leak to obtain uh the IP
address uh the private IP

00:32:40.525,00:32:45.530
address of the uh victim when
available it works on Chrome and
uh Firefox. And when we use this

00:32:47.699,00:32:52.704
IP address to derive a subnet uh
we can use to uh scan. We
obviously pass the credentials

00:32:54.873,00:32:59.878
omit to fetch, so uh the victim
uh is no- not made aware that uh
a scan ongo- ongoing. And uh we

00:33:05.483,00:33:11.790
currently considering performing
a second pass scan uh to
identify uh slower http service

00:33:11.790,00:33:16.795
that we may have missed. So we
have learned how uh we um, made
Singularity more reliable uh

00:33:22.434,00:33:27.439
faster, how we can uh, uh, find
uh vulnerable uh targets. Uh and
services. Um now we going to uh

00:33:32.811,00:33:39.117
show you how uh you can
implement all the above,
orchestrate all the above and uh

00:33:39.117,00:33:44.122
uh perform service detection and
auto exploitation as a bonus. So
Singularity provides a sample

00:33:47.425,00:33:53.164
autoattack dot html file.
Automation file. It is fully
customizable and uh permits uh

00:33:53.164,00:33:59.137
to leverage all the features we
have discussed uh so far.
Including, but not limited to

00:33:59.137,00:34:05.043
uh, you can specify uh specific
uh exploitation payload. For
instance, targeting a service

00:34:05.043,00:34:09.781
like Jenkins or you can ask
Singularity to auto select the
the payload based on the service

00:34:09.781,00:34:16.288
it detected. You can hard code
your targets uh and ask y-
Singularity to optional detects

00:34:16.288,00:34:22.761
more target on the network. Uh
same thing for ports. You can
specify a DNS, a default DNS

00:34:22.761,00:34:27.832
rebinding strategy and ask
Singularity optionally to auto
optimize and find the best

00:34:27.832,00:34:33.905
strategy for you. And uh
obviously you have all your
options such as flooding the DNS

00:34:33.905,00:34:40.011
cache uh visibly hiding activity
and so on. Uh in the future we
intend to uh implement more auto

00:34:40.011,00:34:46.051
optimization. So you don’t have
to read the extensive wiki. So
when you’re designing your

00:34:46.051,00:34:51.222
attack, you want to mix and
match uh different specification
of the same target. Uh for

00:34:51.222,00:34:56.227
instance, uh for local uh uh,
hosts bounds uh service. Uh
specify 0 dot 0 dot 0 dot 0,

00:34:59.731,00:35:06.037
local hose as the CNAME uh 127
dot 0 dot 0 dot 1. This will
improve reliability uh the uh

00:35:06.037,00:35:11.042
permit you to bypass um security
controls and a full speed. Uh
you can instruct Singularity to

00:35:13.745,00:35:18.750
find and use the external IP
address to exploit the internal
interface um, of wifi uh access

00:35:21.186,00:35:26.191
point um and routers um uh for
uh device that choose the weak
and system model can only

00:35:28.393,00:35:34.933
encourage you to refer back to
the DefCon presentation. DefCon
18 in that regard, to see how it

00:35:34.933,00:35:41.706
works. And uh you want to do
some homework using uh uh our
print source intelligence try to

00:35:41.706,00:35:48.046
figure um, uh what does the
naming convention for asset in a
corporate network or even use a

00:35:48.046,00:35:54.019
dictionary of service name and
specify specify them as CNAME uh
in your target. Uh list for

00:35:54.019,00:35:58.189
instance jenkins dot internal
dot corp dot com. This is likely
going to pay off because they

00:35:58.189,00:36:04.596
are a tough uh uh service or a
still are not authenticated in a
corporate environment. So we

00:36:04.596,00:36:10.769
mention that Singularity can do
uh service detection as well. So
um, Singularity comes with a

00:36:10.769,00:36:17.042
number of attack payloads um uh
with target services such as
Ruby on Rails, the admin console

00:36:17.042,00:36:22.047
uh Amazon uh AWS instance
metadata and so on. And uh we
recently added uh uh service

00:36:24.115,00:36:30.789
detection routine uh that allow
you to detect what service is
running uh behind and uh uh try

00:36:30.789,00:36:36.227
to deliver an appropriate
payload, so for instance if uh
you find that a service responds

00:36:36.227,00:36:42.734
with a http header contains the
value x Jenkins then Singularity
uh will figure out that’s more

00:36:42.734,00:36:49.541
well, automatically is using uh
uh uh is facing Jenkins
application instance. So when

00:36:49.541,00:36:54.279
you select a automatic uh uh
attack payloads, Singularity
will try to detect the service

00:36:54.279,00:36:59.284
and uh deliver the appropriate
payload it has. So um, with that
tool, we were trying to blur the

00:37:03.655,00:37:09.127
line uh between origin and uh uh
I think we have achieved that.
Hence the name Singularity of

00:37:09.127,00:37:14.132
origin. So how do you protect
from um a DNS rebinding attack?
Uh you often hear uh commands on

00:37:18.470,00:37:24.976
blogs or um recommendation to
use DNS black lists or to you
use tentatively to use DNSSec

00:37:24.976,00:37:30.281
maybe. Or to use this DNS
service provider or one of your
colleague or friend uh bought

00:37:30.281,00:37:37.155
this uh appliance that uh uh or
or router but a a state but it
perf- it provides DNS binding

00:37:37.155,00:37:42.160
protection. Well, as we learned,
common wisdom is not enough.Um,
it is hard to understand all the

00:37:44.429,00:37:49.834
subtleties of DNS rebinding. And
no DNSSec won’t help you there.
So Roger how do we protect from

00:37:49.834,00:37:54.839
DNS rebinding? >>There are three
proper ways to protect your
service, one is to use TLS on

00:37:58.176,00:38:03.581
your application, including the
service listening on local
hosts. You can require

00:38:03.581,00:38:10.088
authentication if the attacker
doesn’t know the credentials,
they can’t make a valid request.

00:38:10.088,00:38:16.694
Or you could validate the host
header for all incoming
requests. Using a white list of

00:38:16.694,00:38:21.699
trusted domain names such as
local host or 127 0 0 1.
Remember when we showed the

00:38:24.469,00:38:29.474
origin in our last demo, it was
still pointing to the attacker,
which won’t be white listed.

00:38:31.776,00:38:36.781
There is also a proposal called
course RFC 1918 which would re
require a pre-flight course

00:38:40.518,00:38:45.523
request for websites host in a
public IP address. When they
make a request to a private IP

00:38:47.792,00:38:54.632
address. This is currently a
draft and not shipped in any
browser. But it, this may

00:38:54.632,00:38:59.637
prevent DNS rebinding, in the
browser. We have one last demo.
Where we show you how to

00:39:02.073,00:39:07.645
automate this whole process. So
previously the victims browsing
through the Singularity browser

00:39:07.645,00:39:12.917
interface, where they had to
configure everything, which is
uh not very realistic. So in

00:39:12.917,00:39:19.691
this demo we’ll show that the
victim only has to browse to
Singularity. We start with a

00:39:19.691,00:39:26.197
port scan to detect services
listening on the local host. You
rebind to these discovered

00:39:26.197,00:39:32.704
services in three seconds
already detects the service
listening for the payloads we

00:39:32.704,00:39:39.544
have and launch the exploit
right away. For this demo we
have a Rails console listening

00:39:39.544,00:39:44.549
on the local host, port 3000.
And a Jenkins instance listening
on port 80 80. So this shows the

00:39:50.088,00:39:55.093
manage web interface which we
are not going to use. What we’re
going to use is this um, auto

00:39:57.428,00:40:02.433
attack demo as page. So browsing
to the page we see that we
detect the port 8080 and 3000.

00:40:05.169,00:40:11.709
And we launching DNS rebinding
right away. The rebinding was
successful. It eh t- detects

00:40:11.709,00:40:16.714
already detects the services. We
uh um, that’s not showing. Uh,
lets go back one more time. And

00:40:25.723,00:40:30.728
I didn’t update quite well. It
detected Jenkins right away. Um,
and it should detect alright.

00:40:35.700,00:40:40.705
Launch. And detected Jenkins and
here it’s still rebinding. Auto
detecting, but it doesn’t seem

00:40:45.376,00:40:51.482
to update quite well. So for
Rails we have our remote code
execution which launches the

00:40:51.482,00:40:57.755
calculator error for Jenkins, we
just dumped the plain text
password stored in cred- stored

00:40:57.755,00:41:02.694
in credentials to the console.
We like you show how the how the
script looks like. The

00:41:05.663,00:41:11.936
configuration script. It’s very
simple, the auto attack script.
So we can cr- define, the

00:41:11.936,00:41:18.443
rebinding strategy as here we
use multiple answers. We use the
attack payload automatic. Which

00:41:18.443,00:41:23.448
automatically tries to detect
the service. We specify the
ports, port 80 80 and 3000 this

00:41:25.450,00:41:30.455
case only. And we can specify
which address to use. There are
a few more settings, but uh

00:41:33.024,00:41:38.029
which we we don’t need for you.
You can get the slides including
our notes on this URL. You can

00:41:42.133,00:41:47.138
get Singularity or tool on our
github page which these all uh
features and let us know if have

00:41:49.974,00:41:54.979
any questions. Thank you.
[applause]

