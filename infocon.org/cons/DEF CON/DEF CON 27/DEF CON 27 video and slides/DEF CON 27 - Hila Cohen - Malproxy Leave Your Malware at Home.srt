00:00:00.100,00:00:05.105
>>Alright so yeah this is uh
Malproxy leave your malware at
home so here we go. >>Thank you.

00:00:09.476,00:00:15.249
Hi everyone. We really
appreciate your time coming here
today. Uh so my name is Amit and

00:00:15.249,00:00:21.154
with me is my colleague is Hila.
Both come from Israel so you
understand this our first time

00:00:21.154,00:00:26.159
in Defcon, speaking in Defcon
and we both come from a startup
company called XM cyber and

00:00:28.662,00:00:34.735
really do offensive cyber so we
can’t talk much about our
background that’s why we decided

00:00:34.735,00:00:41.341
to put some cool trivia stuff
about us. But let’s move on to
the actual topic. So today we

00:00:41.341,00:00:46.847
are going to show you a new and
cool technique to execute
malicious code, bypassing an

00:00:46.847,00:00:52.786
existing endpoint security
solutions. Because as attackers
we continuously try to find new

00:00:52.786,00:00:58.725
ways to execute malicious code
under the presence of those
solutions. I know there are many

00:00:58.725,00:01:05.065
existing techniques like false
viruses of executable packers
but most of those techniques

00:01:05.065,00:01:11.171
require modifications on the
malicious code side so it is
harder for the attackers to

00:01:11.171,00:01:16.777
implement them over and over
again to every piece of
malicious code. So here we

00:01:16.777,00:01:23.283
present a generic technique that
simply proxies system API calls
over the network so the

00:01:23.283,00:01:28.188
malicious code is never present
on the target machine. On the
victim. And because it’s never

00:01:28.188,00:01:33.460
there most of the defenses and
security mechanisms implemented
inside the endpoint security

00:01:33.460,00:01:39.433
solutions will simply not detect
the code. And because the code
is unaware of the proxy

00:01:39.433,00:01:45.339
incorporation uhb no
modifications are required in it
at all. So in this talk today we

00:01:45.339,00:01:51.345
will cover some basic protection
mechanisms that exist in most of
the endpoint security solutions

00:01:51.345,00:01:56.984
in the market today. Just to
keep everyone on the same page.
Then we will describe our

00:01:56.984,00:02:01.355
malproxy solutions in detail
including a demo. We will end,
of course, with some

00:02:01.355,00:02:07.527
mitigations. So why do we
actually speak specifically
about endpoint security

00:02:07.527,00:02:13.500
solutions. Mainly because they
are a major part of every
organization’s security stack.

00:02:13.500,00:02:18.572
Those solutions evolved overtime
alongside the attackers because
sometimes the attackers

00:02:18.572,00:02:23.577
successfully penetrated the
defenses so the security
community had to keep up the

00:02:23.577,00:02:29.483
pace and put in other defenses.
More advanced defenses to keep
up with the attacks. But it is

00:02:29.483,00:02:33.487
like a cat and mouse game where
the cat keeps chasing the mouse
and the mouse keeps getting

00:02:33.487,00:02:39.526
away. But it is an unfair game
because the mouse has to find a
single way to escape the cat

00:02:39.526,00:02:45.298
while the cat has to predict all
the possible ways of escape of
the mouse uh to block it from

00:02:45.298,00:02:51.638
escaping before it happens. So
what do we actually know about
the current status of endpoint

00:02:51.638,00:02:57.844
security solutions? FOr many of
us, it just a black box. With a
lot of fairy dust, Some cool UI

00:02:57.844,00:02:59.846
and of course some machine
learning insided (shouting from
audience) and that woo and that

00:02:59.846,00:03:01.782
consumes most of our CPU on the
endpoints. But most of us don’t
actually know what happens

00:03:01.782,00:03:06.787
inside. But in the bottom line
we know that there are cyber
attacks in the world and there

00:03:14.461,00:03:19.332
are successful penetrations of
most of the defenses so we can
actually sum up the current

00:03:19.332,00:03:26.106
status of endpoint security
solutions in one short sentence.
Not great, not terrible. Let’s

00:03:26.106,00:03:32.712
understand why. So thanks to the
cat and mouse game over the
years the endpoint security

00:03:32.712,00:03:37.717
solutions evolved significantly
and developed more and more
advanced protection mechanisms

00:03:39.886,00:03:44.791
so historically we can start
with the first protection
mechanism that was implemented

00:03:44.791,00:03:50.864
which is the static signatures.
Those look on what we called
IOCs Indications of Compromise.

00:03:50.864,00:03:57.037
Those can be binary sequences in
a file or in a memory dump or
simply strings. Readable strings

00:03:57.037,00:04:03.477
from a file. The next mechanisms
that came to close some gaps in
the static signature mechanisms

00:04:03.477,00:04:09.549
is the heuristic rules. Those
don’t look on the actual uh data
inside a file but look at the

00:04:09.549,00:04:14.254
different properties from a
higher perspective. It can be
where the file is located. What

00:04:14.254,00:04:19.259
APIs it uses. Or whether it is
encrypted or not and so on.
Those rules basically calculate

00:04:21.761,00:04:27.367
some sort of heuristic score.
And in many endpoint security
solutions a negative scores

00:04:27.367,00:04:33.240
means malicious and positive
score means innocent. So that’s
the whole purpose. To give some

00:04:33.240,00:04:39.479
score and decide whether a file
is malicious based on this
score. The last mechanism is the

00:04:39.479,00:04:46.319
behavioral signatures and those
come to actually look on the
impact that a piece of code eh

00:04:46.319,00:04:51.725
does on a system and not on the
actual implementation. So every
piece of code that runs on a

00:04:51.725,00:04:57.430
system interacts with the
operating system in some way
through API codes. So when we

00:04:57.430,00:05:02.369
wanted all those API codes and
look for some malicious patterns
in that activity log we may get

00:05:04.671,00:05:09.676
uh we may verdict some of those
uh pieces of code without
actually knowing them in advance

00:05:12.179,00:05:17.851
so it uh it deals with the
unknown malware. So the solution
that we present here actually

00:05:17.851,00:05:22.889
handles the first two mechanisms
successfully and it gives very
hard time for the behavioral

00:05:22.889,00:05:28.795
signatures to catch us. So let’s
dive into the first category,
static signatures. To understand

00:05:28.795,00:05:33.633
them better, let’s take this
piece of code as an example of
malicious code. I know it’s not

00:05:33.633,00:05:39.472
but let’s think it is. Say we
find some string and calls
printf. And now I would like to

00:05:39.472,00:05:45.745
create a static signatures that
verdicts that piece of code. But
not other pieces of code so I

00:05:45.745,00:05:51.885
can use a technology called
YARA. Create some rules and test
those rules on various binary

00:05:51.885,00:05:56.990
files. I didn’t actually write
this YARA rule I took it from
some website online but you can

00:05:56.990,00:06:03.196
see it finds some strings and a
binary sequence which is an ELF
header this is a unique space to

00:06:03.196,00:06:08.635
executable. And the condition is
that the ELF header exists in
the first four bytes of the

00:06:08.635,00:06:13.640
file. And there is either the
ADM string or CORPS string. So
if we compile the code that we

00:06:15.675,00:06:20.247
saw before and apply the YARA
rule on it we can see that YARA
verdicts the file because we

00:06:20.247,00:06:26.386
have the ELF header and we have
the ADM string inside some
offset in the file. So that’s a

00:06:26.386,00:06:31.391
very basic static signature. But
now let’s uh let’s create
another uh static signature that

00:06:33.693,00:06:39.833
captures Mimikatz. We love
Mimikatz and we used it as
demonstration across this talk.

00:06:39.833,00:06:44.838
So those six strings I extracted
from uh Mimikatz binary. So the
question is can we create a YARA

00:06:47.307,00:06:52.312
rule based on those six strings
only that verdicts all the files
that contains those six strings.

00:06:54.881,00:07:00.120
So the answer is not because
even this presentation file.
This pdf file. Actually contains

00:07:00.120,00:07:06.860
those strings and as far as I
know it is not Mimikatz. So we
co-cannot simply verdict the

00:07:06.860,00:07:12.065
file based on some stupid
strings. We have to be very
gentle and very careful when we

00:07:12.065,00:07:18.004
create static signatures because
otherwise we might get false
positives. And false positives

00:07:18.004,00:07:24.110
are one of the worst nightmares
of the security researchers that
create the static signatures.

00:07:24.110,00:07:29.416
Let’s move on to the second
category. The heuristic rules.
And as I said, those look on uh

00:07:29.416,00:07:36.189
different properties or features
in a file. In the file system or
in the memory, and they try to

00:07:36.189,00:07:41.561
classify for each property
whether it is malicious or
innocent. And that’s the whole

00:07:41.561,00:07:46.433
purpose of those heuristic
rules. To distinguish between
malicious properties and

00:07:46.433,00:07:51.371
innocent properties. Some
heuristic rules can be generated
by a human being by a security

00:07:51.371,00:07:57.811
researcher or the other can be
generated by some fancy new AI
algorithm. It doesn’t matter.

00:07:57.811,00:08:02.716
The whole purpose is to create
some sort of holistic heuristic
score based on a combination of

00:08:02.716,00:08:08.955
different properties. So on the
screen you can see an example of
an analysis of a PE file

00:08:08.955,00:08:13.360
Portable executable file in
windows. And you can see we have
the dot text section which is

00:08:13.360,00:08:18.832
the code. The dot data which is
the data of course and another
custom section called UPX2 and

00:08:18.832,00:08:25.171
we know the UPX is a famous
executable attacker. So as you
can see there are some red flags

00:08:25.171,00:08:30.744
in this analysis. We can look at
the text section and you can see
that the rough size is different

00:08:30.744,00:08:36.783
than the virtual size. Most of
the time it does but the the
values are more close together.

00:08:36.783,00:08:42.622
In our case the rough size is
zero bytes long so it sounds
suspicious. Another red flag is

00:08:42.622,00:08:48.161
that the text section is
actually writable and actually
there is no reason that the text

00:08:48.161,00:08:55.135
section should be writable it
just contains code. Another red
flag is the existence of the UPX

00:08:55.135,00:09:01.041
section uh because we know that
UPX actually takes some blob of
binary data from the data

00:09:01.041,00:09:06.046
section that creates the data
and executes it as a shell code
or some sort of binary code. So

00:09:08.515,00:09:15.155
we know that uh this application
this code actually hides its
true nature from us. So if we

00:09:15.155,00:09:20.160
are a security end end an
endpoint security solution and
we want to inspect what this uh

00:09:22.228,00:09:28.301
what this file actually does we
know that these true, the true
nature of this file is hidden

00:09:28.301,00:09:34.974
from us. On the other hand if we
have a digitally signed file on
the file system that imports

00:09:34.974,00:09:41.481
some API functions that interact
with the user we may assume that
this file is innocent because it

00:09:41.481,00:09:46.486
has a very many innocent
features inside it. So uh over
the years we know that uh

00:09:49.289,00:09:54.761
malicious files, malicious
pieces of code actually
penetrated the static signatures

00:09:54.761,00:10:00.200
and the heuristic rules. And
that’s what the behavioral
signatures came to solve. They

00:10:00.200,00:10:05.038
look on the actual um activity
that the piece of code does on
the system in [inaudible]

00:10:05.038,00:10:10.844
inventory on the sandbox it
doesn’t matter and analyzes that
activity log of a single thread

00:10:10.844,00:10:15.849
or an entire process in order to
look for malicious patterns
inside. So, similarly to the

00:10:18.518,00:10:23.523
static signature case, finding
data mining whether a pattern is
malicious or not is rather uh

00:10:25.558,00:10:30.697
delicate because we might get
false positives also here. On
the screen you can see an

00:10:30.697,00:10:35.702
example of Mimikatz a login
passwords command execution so
you see we call antiquary system

00:10:38.037,00:10:43.109
information to got a to get a
process list then we open a
handle to Elsas and later we

00:10:43.109,00:10:48.681
will read its memory using greet
post’s memory so can we take
this activity log and assume it

00:10:48.681,00:10:53.152
is malicious wherever we find
it? So the answer is no.
Similarly to the static

00:10:53.152,00:10:58.258
signatures because otherwise we
might get false positives.
Microsoft had spotted this those

00:10:58.258,00:11:02.629
APIs for a reason. It is
legitimate to open a handle to
another process and release

00:11:02.629,00:11:07.634
memory. Otherwise those APIs
will not be exposed to the user.
A very good example of uh the

00:11:10.603,00:11:15.542
long way that the behavioral
signatures have to go before
they become more trustworthy can

00:11:15.542,00:11:20.580
be seen in the B- one of
Benjamin Delpy’s latest posts a
few weeks ago. He discovered

00:11:20.580,00:11:26.986
that if you take calc dot exe
and add some command arguments
that are related to Mimikatz

00:11:26.986,00:11:31.991
Windows defender actually blocks
calc dot execution and verdicts
it as Mimikatz. So um and as we

00:11:35.295,00:11:41.367
know calc dot exe is one of the
most innocent executables we
know. So uh there is a long way

00:11:41.367,00:11:47.674
for the antiviruses to go before
we can trust the behavioral
signature mechanism. Now Hila

00:11:47.674,00:11:54.347
will show you how we can bypass
those behavioral security
mechanisms that I talked about.

00:11:54.347,00:12:01.020
>>Thank you Amit. So for every
protection mechanism there are
ways to go around it. And

00:12:01.020,00:12:06.960
endpoint protection solutions
are no exception. We can change
the properties IOCs and behavior

00:12:06.960,00:12:12.865
of every malicious file thus
making it unprotected by
security solutions. But those

00:12:12.865,00:12:18.605
changes require a lot of manual
work and expertise from that
hacker. It has to be done for

00:12:18.605,00:12:23.376
every malicious file
seapararelyt so its not feasible
or scalable to do it over and

00:12:23.376,00:12:28.881
over again. We can also other
techniques that uh Amit
mentioned to bypass security

00:12:28.881,00:12:33.886
solutions but they may require
to do some modifications in the
malware code. It would present

00:12:36.055,00:12:41.694
our technique to bypass security
solutions. We call this
technique malproxy and you you

00:12:41.694,00:12:46.699
will understand why shortly. So,
now we know that endpoint
protection solutions try to find

00:12:49.002,00:12:54.807
our code and its properties,
analyze and verdict it. So lets
make it impossible for those

00:12:54.807,00:13:00.013
solutions to even look at our
code. We can simply avoid
deploying the malicious code on

00:13:00.013,00:13:05.018
the direct machine by separating
the code from its interaction
with operating system. Let's

00:13:07.286,00:13:12.025
assume we have a machine with
operating system that executes a
process with malicious code

00:13:12.025,00:13:17.163
inside it. The code interacts
with operating system using API
calls as you can see in the

00:13:17.163,00:13:22.769
sketch. The malicious code is
present on the target machine so
it can be captured by any

00:13:22.769,00:13:27.874
security solution. Can we
migrate the malicious code
somewhere it won’t be detected

00:13:27.874,00:13:32.879
by those solutions? Of course we
can. Our solution allows
generate load and execute

00:13:35.048,00:13:40.420
malicious uh malicious code and
send the API code it executes to
the target side over the

00:13:40.420,00:13:46.392
network. For the malicious code
it seems like it is executed on
the target system as it cannot

00:13:46.392,00:13:52.999
tell otherwise. It interacts
with operating system using API
calls uh simulating them makes

00:13:52.999,00:13:59.639
it looks like it is executed on
the target system. Our solution
consists of two major

00:13:59.639,00:14:04.777
components. The attacker site
stub and the target site stub.
The attacker site loads and

00:14:04.777,00:14:10.283
executes the malicious the
malicious code. It controls its
API calls and redirects them

00:14:10.283,00:14:16.022
over a network tunnel to the
target site. The target code
looks innocent and doesn’t

00:14:16.022,00:14:22.028
contain any malicious activity
precoded in it. It receives the
API calls and arguments.

00:14:22.028,00:14:27.800
Executes those calls and returns
the results back to the attacker
site. Then The attacker site

00:14:27.800,00:14:32.572
return the results back to the
malicious code the same way they
would be returned if the

00:14:32.572,00:14:38.478
malicious code had called those
requests locally. It's important
to emphasize that the malicious

00:14:38.478,00:14:44.183
code is totally unaware to the
long journey the response went
through until it reach its final

00:14:44.183,00:14:49.188
destination. Let's take great
file function for example. Our
malicious code calls it and

00:14:52.058,00:14:57.764
malproxy captures that call and
create a detailed message for
data for the target site which

00:14:57.764,00:15:04.003
contains the create file
function name and the path of
blah dot txt. Then malproxy

00:15:04.003,00:15:09.542
sends this message to the target
site which parses it and
executes createfile function as

00:15:09.542,00:15:14.547
instructed. After the call the
operating system returns the
handle to that file and now

00:15:16.816,00:15:21.821
malproxy has to send this handle
back to the attacker site. Then
malproxy returns the handle back

00:15:23.923,00:15:28.928
to the malicious code and as far
as it is concerned, we now have
a valid handle to blah dot txt.

00:15:31.430,00:15:36.402
To describe our solution in
depth, let's look at some
fundamental key terms. We all

00:15:36.402,00:15:41.808
know what a system system call
is and there is a schematic
sketch of outwave the icall is

00:15:41.808,00:15:48.648
executed. The top function is
called by the users code and it
can call other functions from

00:15:48.648,00:15:53.653
other libraries if needed.
Sometimes those calls reach the
native API layer which makes the

00:15:55.655,00:16:01.594
transition between the user mode
and kernel mode. After reaching
the kernel the operating system

00:16:01.594,00:16:06.599
executes the needed operations
to fulfill a task and return the
results back to the user. To

00:16:09.302,00:16:14.307
proxy a system call without
making any adjustment to the
malicious code we can implement

00:16:14.307,00:16:19.912
our malproxy in any layer of
this attack. We can get inside
the transition between the user

00:16:19.912,00:16:25.918
mode and kernel mode and proxy
any system call it we want.
However it was proved quite

00:16:25.918,00:16:30.923
difficult. After experimenting
with this proxy logic we found
out it's much easier and

00:16:33.192,00:16:39.332
convenient to intervene and
implement our malproxy in the
top layers of the API call and

00:16:39.332,00:16:46.172
not necessary in the native API
layer. Every API call that
doesn't trigger a system call is

00:16:46.172,00:16:51.377
irrelevant to our solution
because it executes the same
flow on both the attacker site

00:16:51.377,00:16:57.283
and the target site. So lets let
those functions execute on the
attacker site. Why waste very

00:16:57.283,00:17:02.221
good bites on the wire for any
un- any unnecessary operation.
So how do we proxy a system

00:17:04.824,00:17:10.763
call? Or any API function call
in that matter. We use a
technique called hooking which

00:17:10.763,00:17:17.136
redirects the system call to our
code instead of the real
operating system implementation.

00:17:17.136,00:17:22.808
A full control over any API
function allows us to inspect
all arguments change them if

00:17:22.808,00:17:28.648
needed and construct a message
that will be sent to the target
site over the network. Moreover,

00:17:28.648,00:17:33.886
we can change the value that is
returned from the function.
There are many techniques to

00:17:33.886,00:17:39.492
perform hooking and this talk is
too short to describe them all.
We use a technique called import

00:17:39.492,00:17:44.764
address table hooking technique
which is very common and easy to
implement. Thanks to the fact

00:17:44.764,00:17:50.670
that we have full control over
malicious code load and
execution. The import address

00:17:50.670,00:17:56.375
table describes all the
functions that are used be the
windows executable while loading

00:17:56.375,00:18:01.414
the windows load our results the
address of every important API
function and places those

00:18:01.414,00:18:07.687
addresses in the import address
table structure. USing this
technique of uh changing the

00:18:07.687,00:18:13.259
addresses of API functions
allows us to separate between
the malicious code’s logic and

00:18:13.259,00:18:18.197
its interaction with the
operating system. The loading
and hooking of the malicious

00:18:18.197,00:18:23.202
code is done with the attacker
site so its not monitored by any
security solution. Now let's

00:18:26.005,00:18:32.278
in-inspect uh the structure of
API function call. Every API
function consists of three main

00:18:32.278,00:18:38.484
properties. The return type, the
calling convention and the
function arguments. The return

00:18:38.484,00:18:42.788
value type is the type of the
value that will be returned from
the function and it can be

00:18:42.788,00:18:48.928
either primitive and well known
structure or appointed to some
address. The calling convention

00:18:48.928,00:18:54.367
defines how the arguments are
passed from the caller to the
callee and every argument can be

00:18:54.367,00:18:59.372
also either a primitive and well
known structure or appointed and
can be treated as an input and

00:19:01.807,00:19:07.413
output or combination of both.
To proxy a system call we need
to handle each of those

00:19:07.413,00:19:12.518
properties by serializing and
deserializing them on both the
attacker site and the target

00:19:12.518,00:19:17.523
site. Now Amit will explain you
how we use those concepts to
proxy API function call. >>Thank

00:19:22.662,00:19:29.201
you Hila. So, now we understand
that our top priority is to
proxy Win API functions and to

00:19:29.201,00:19:34.040
do that we have to pay close
attention to all the elements
that Hila mentioned in the

00:19:34.040,00:19:38.944
function prototype. The return
value, the calling convention,
but most importantly the

00:19:38.944,00:19:44.216
arguments because the argument,
the arguments may be very hard
to handle. We might have many

00:19:44.216,00:19:49.188
types of arguments. Some may be
input, some may be output. Or a
combination. Some may be

00:19:49.188,00:19:53.959
structures or point us to some
structures that contains other
pointers to structures. THe

00:19:53.959,00:19:59.598
memory might not be, might not
even be continuous individual
address space. So, our

00:19:59.598,00:20:03.903
serialization and
deserialization logic on both
the attacker site and the target

00:20:03.903,00:20:08.974
site have to take all the
different aspects into account
in order to handle all possible

00:20:08.974,00:20:15.548
argument types. Uh so once we
implement all the different
argument types uh we can uh

00:20:15.548,00:20:20.419
simply add more and more API
calls and it is quite trivial
because once we cover all the

00:20:20.419,00:20:27.359
different argument types its
very easy to add more API calls.
Uh as there are many argument

00:20:27.359,00:20:32.364
types to handle and our time
here is short I chose to focus
on what I think is one of the

00:20:32.364,00:20:37.369
interesting cases and is
handling buff- uh memory buffers
in APi calls. We can actually uh

00:20:39.739,00:20:44.743
divide uh the API Windows APIs
into two main groups. Those who
handle user allocated memory

00:20:46.846,00:20:52.251
buffers where the user pre
allocates the buffer before
calling the API function and

00:20:52.251,00:20:57.223
system allocated use- memory
buffers where the system call
itself is responsible for the

00:20:57.223,00:21:02.661
memory allocation. And
afterwards when the user is done
using the buffer uh is

00:21:02.661,00:21:08.834
responsible to call another API
function for leasing that
memory. So when we do the

00:21:08.834,00:21:14.273
proxying between the target site
and the attacker site of those
memory buffers we might keep it

00:21:14.273,00:21:18.844
we must keep a translation
between the virtual address
space on the attacker site and

00:21:18.844,00:21:23.516
the virtual address space on the
target site because we cannot
promise that the same addresses

00:21:23.516,00:21:29.855
will be allocated for both
sites. So when we get some
address from the target site

00:21:29.855,00:21:35.895
that was allocated by some
system call and we use that
address on the attacker site of

00:21:35.895,00:21:41.567
course a translated address. The
malicious code will later call
the released function of that

00:21:41.567,00:21:47.206
buffer. But the address the
malicious code will use will be
the address of the attacker site

00:21:47.206,00:21:53.546
so we have to translate it again
for the target site to actually
release the resources. Otherwise

00:21:53.546,00:22:00.019
we’ll leak those resources. So,
uh, in order to understand it
better we’ll look at some

00:22:00.019,00:22:05.691
example. This uh we chose to
show you NtQuery Information
Process. First because it is

00:22:05.691,00:22:10.162
used by Mimikatz as it will show
uh as we will see later and
second you can see the third

00:22:10.162,00:22:15.601
argument it uses an OPAC buffer
we do not know its structure in
advance and this structure is

00:22:15.601,00:22:20.272
set by the value of the second
argument. The process
information class. You can see

00:22:20.272,00:22:26.312
we have three input arguments
and two output arguments and
actually those output arguments

00:22:26.312,00:22:32.318
are not input as well so they
are output only and the system
will override whatever data’s

00:22:32.318,00:22:38.190
stored inside. So as far as
we’re concerned in the request
site we can treat those uh

00:22:38.190,00:22:43.329
buffers as complete garbage. We
don’t have to serialize it to
serialize the data into the

00:22:43.329,00:22:49.468
request message. Now let’s see
how we handle each one of those
arguments. So the first argument

00:22:49.468,00:22:56.342
is the process handle. A handle
is simply an index in the object
table of some process. An once

00:22:56.342,00:23:02.781
we proxy uh this call to the
target site the handle must have
meaning on the target site. So

00:23:02.781,00:23:07.987
we probably got it from some
previously proxied API call for
example to open process or

00:23:07.987,00:23:12.992
create process or whatever API
that returns us a handle to the
process. This handle is a

00:23:15.127,00:23:20.766
numeric value so its very easy
to uh serialize it into the
request message and as I said it

00:23:20.766,00:23:26.305
doesn’t have any meaning on the
attacker site. It has meaning
only on the target site. So, we

00:23:26.305,00:23:31.610
serialize it into the request
message. Now we serialize also
the process information class.

00:23:31.610,00:23:36.915
It's also numeric value so we
serialize it easily into the
request message. But we have to

00:23:36.915,00:23:43.622
keep uh to remember what value
it is in order to deal with the
buffer on the third argument

00:23:43.622,00:23:49.028
later on. As I said, the buffer.
The processing information
buffer we can treat it as

00:23:49.028,00:23:54.833
garbage because uh its data will
be overridden by the system API.
So we don’t have to add it into

00:23:54.833,00:24:01.006
the request message at all. Now
the process information length
is the size of that buffer. We

00:24:01.006,00:24:07.112
do have the serialize it before
as you’ll see later we do have
to allocate in a on the target

00:24:07.112,00:24:13.585
site for the actual system API
call. The return length is also
an output only argument so we

00:24:13.585,00:24:17.990
don’t have to serialize it into
the request message. Now we have
all the data we need in the

00:24:17.990,00:24:23.128
request and we can send it to
the target where we deserialize
all the input arguments. And now

00:24:23.128,00:24:28.233
we have to allocate enough
memory space for the output
arguments. The third argument

00:24:28.233,00:24:34.073
size, we know it because it is
set in the fourth argument
value. The fifth arguments uh

00:24:34.073,00:24:39.545
size is fixed. It is unsigned
long It’s always four bytes long
so we can allocate enough memory

00:24:39.545,00:24:44.550
for it and call the actual API.
Now once we uh the API returns
we need to serialize the output

00:24:46.852,00:24:51.357
arguments to the response
message solets start with the
easiest case which is the return

00:24:51.357,00:24:56.028
length because we know its size
in advance we know the structure
is simply an unsigned long. So

00:24:56.028,00:25:01.734
we can uh serialize it into the
response message. But handling
the process information might be

00:25:01.734,00:25:06.171
difficult because it might be a
complex status structure that
tells pointers to other data

00:25:06.171,00:25:12.244
structures. Tells more pointers
to other data structures. And
this memory block might not be

00:25:12.244,00:25:17.216
it might not even be continuous
individual address space. So we
do have to take the informa- the

00:25:17.216,00:25:22.354
relative information and
serialize it into one continuous
memory block in the response

00:25:22.354,00:25:27.926
message and we have to implement
the deserialization logic to
deserialize and rebuild the

00:25:27.926,00:25:34.199
complex data structure back uh
back on the attacker site. All
is left is to serialize the

00:25:34.199,00:25:40.639
return value and return status
which is also defined to be
numeric value. And uh now we are

00:25:40.639,00:25:45.744
ready to send the message back
to the attacker site. Where we
need to deserialize all the

00:25:45.744,00:25:51.150
output arguments, rebuild the
complex data structure, and
return the values back to the

00:25:51.150,00:25:56.588
caller code. And the caller code
is totally unaware of those of
that proxy operation. As far as

00:25:56.588,00:26:02.194
is its concerned, it called the
API function and got the results
back where it expected them to

00:26:02.194,00:26:07.533
be. Nowlet’s have a quick recap
of what we have here. We have
two stubs. The attacker site

00:26:07.533,00:26:13.138
stub and the target site stub
that proxies system API calls
over a network channel. The

00:26:13.138,00:26:18.177
attacker site loads the
malicious code and hooks some of
the API functions that interact

00:26:18.177,00:26:23.916
with the target site operating
system. The target site receives
the commands that should be

00:26:23.916,00:26:29.521
executed, the API calls and the
arguments, and actually makes
the call to uh to the target

00:26:29.521,00:26:34.593
operating system. All the
results, the output arguments
and the return value are

00:26:34.593,00:26:39.832
serialized back into the
response message and sent to the
attacker site which deserialized

00:26:39.832,00:26:45.170
them and returns them to the
original caller code. And as I
said the caller is unaware of

00:26:45.170,00:26:51.710
those proxy operation so we
don’t have to modify it at all.
We just we can just take a

00:26:51.710,00:26:57.983
precompiled malicious code and
execute it. This flow happens
over and over again for every

00:26:57.983,00:27:04.022
API that is called and proxied.
So now we understand how a
single API code can be proxied.

00:27:04.022,00:27:09.261
Now let’s have a look on the
scope of an entire process. And
for that we chose to show you

00:27:09.261,00:27:14.366
again Mimikatz because first we
love it and second it is uh
verdicted by most of the

00:27:14.366,00:27:20.405
antivirus engines in virus
total. So it is a very challenge
to execute its logic without

00:27:20.405,00:27:25.410
being detected. So in order to
run uh specifically the login
passwords command in Mimikatz uh

00:27:29.147,00:27:34.553
you can see we analyze some of
the API calls that are used by
the login passwords command. And

00:27:34.553,00:27:40.592
in fact we don’t have to proxy
them all we can just proxy those
functions that interact with the

00:27:40.592,00:27:45.764
target operating system. So
let's simplify the execution
flow of the login passwords

00:27:45.764,00:27:51.403
command. So it can be simplified
to this flow of API calls. And
let's inspect them one by one.

00:27:51.403,00:27:56.141
What APIs we need to proxy and
what APIs we don’t need to
proxy. So first

00:27:56.141,00:28:00.846
RtlAdjustPrivilege. Actually
gives us an elevated token and
we need an elevated token in

00:28:00.846,00:28:05.417
order to interact with the
target site Elsas. Because we
need to interact with the target

00:28:05.417,00:28:11.790
site Elsas we need an elevated
token on the target site so we
do need to proxy this API call

00:28:11.790,00:28:17.229
to the target. Then we need to
enumerate all the processes in
the target system to get some

00:28:17.229,00:28:23.235
metadata about Elsas because we
need to interact with the target
site Elsas. So we call Nt Query

00:28:23.235,00:28:28.941
System Information with some
flex that indicate that this the
processes should be returned

00:28:28.941,00:28:35.480
from that API. And we get all
the data we need inside a user
allocated buffer. We proxy that

00:28:35.480,00:28:41.353
API call to get the information
from the target site. Now we
have all the information we need

00:28:41.353,00:28:46.692
in the user allocated buffer we
can just look for Elsas in the
metadata list. Simply by

00:28:46.692,00:28:51.663
comparing strings using Rtl
Equal Unicode String and this
can be done entirely locally on

00:28:51.663,00:28:57.869
the attacker site. Then, we call
Open Process with the process ID
that we extracted from the

00:28:57.869,00:29:02.274
metadata. And the Open Process
is called on the target site
because we need the handle to

00:29:02.274,00:29:07.179
the target site Elsas. And we
get back that handle and, as you
remember, the handle has a

00:29:07.179,00:29:11.316
meaning only on the target site.
As far as the attacker is
concerned, this is some magical

00:29:11.316,00:29:16.722
value that doesn’t have any
meaning in the process besides
calling other API functions for

00:29:16.722,00:29:22.361
example Nt Query Information
Process. Mimikatz uses that to
get the location of the Process

00:29:22.361,00:29:27.766
Environment Block, the PEB. So,
it acquires the PEB location and
based on the data stored in that

00:29:27.766,00:29:34.272
PEB it calculates what memory
buffers are of interest and
contain potential credentials in

00:29:34.272,00:29:39.911
Elsas. Then all those memory
buffers are read using Read
Process Memory. It creates

00:29:39.911,00:29:45.884
memory from um distant process.
So we need to proxy this API as
well because we need to to query

00:29:45.884,00:29:52.691
the memory of the target site
Elsas. Once Mimikatz cotains all
the information needed insided

00:29:52.691,00:29:57.696
uh its visual address space on
the attacker site we can simply
decrypt the data and now we got

00:30:00.966,00:30:05.971
the password we need and we
pwned the system. So this is all
nice in theory but let’s see how

00:30:08.173,00:30:12.911
it works in real life. And for
that we installed two Windows
Ten machines. One is the

00:30:12.911,00:30:19.685
attacker and one is the victim,
the target. And the victim has
Windows has the latest Windows

00:30:19.685,00:30:25.957
Ten with Windows Defender active
with the latest security patches
and our goal is to execute

00:30:25.957,00:30:32.164
Mimikatz login password
operation without being detected
by Windows Defender. So in this

00:30:32.164,00:30:37.769
demonstration I will simply
double click the uh the target
site stub but in real life it

00:30:37.769,00:30:42.641
will be executed by some
exploitation flow or whatever.
It doesn’t matter for the

00:30:42.641,00:30:47.646
demonstration purposes but keep
in mind that we do have to
execute our code on the target

00:30:47.646,00:30:52.651
site. So, let’s see how it
actually works. So this is our
uh target site and as you can

00:30:56.988,00:31:01.927
see we have Windows Defender
installed. Everything is active.
All the checks are green. And we

00:31:04.863,00:31:10.502
have zero threats in the in the
history and the settings are all
active. We didn’t define any

00:31:10.502,00:31:15.507
exclusions or whatever. And now
we launch our target site stub.
To do that we run it as an admin

00:31:17.709,00:31:22.614
to get an elevated taken later.
And that as far as we know
Windows Defender didn’t detect

00:31:22.614,00:31:28.186
anything. Now let’s look on the
attacker site. Can see this is
the command on the attacker site

00:31:28.186,00:31:33.492
we will run on the attacker
machine under the attacker user
and we want to run our attacker

00:31:33.492,00:31:39.998
site stub. And to do that we
simply launch it with the
command line arguments off the

00:31:39.998,00:31:46.037
path two the actual Mimikatz
execute to build down to the
truncate app and the host name

00:31:46.037,00:31:51.042
NTCP pulled off the target site.
So now let’s look how both sides
interact with one another. On

00:31:54.112,00:31:58.717
the left side you can see the
attacker and on the right side
you see the victim the target.

00:31:58.717,00:32:04.356
And every operation that is
executed by the attacker will be
reflected on the target site. So

00:32:04.356,00:32:10.095
when we launch Mimikatz many
dlls are loaded. Those uh dll
loads are reflected on the

00:32:10.095,00:32:15.534
righthand side. Now the first
command we will execute is
privilege debug. This will give

00:32:15.534,00:32:20.539
us the elevated token we need.
And it is it is reflected by
calling Rtl Adjust Privilege on

00:32:20.539,00:32:25.544
the target site. You can see it
in the bottom line. Now the
second command that that we

00:32:25.544,00:32:31.383
execute is the securlsa login
passwords command. And this
actually opens a handle to

00:32:31.383,00:32:36.521
Elsas, read it’s memory, and
process the credentials. So once
we launch it you will see that

00:32:36.521,00:32:41.493
many API functions are called.
And while the are called the
results are already passed on

00:32:41.493,00:32:47.933
the attacker site. So now we
have the credentials we need We
can scroll and inspect them and

00:32:47.933,00:32:54.739
find whatever we look for and in
this example this is the NTLM
hash of the victim account. So

00:32:54.739,00:33:00.712
we got what we wanted but did it
we do it silently. So let’s
inspect for Windows Defender. As

00:33:00.712,00:33:06.685
far as we can see we have zero
threats in history still. And we
do don’t have any quarantined

00:33:06.685,00:33:12.824
items or threats uh detected.
But most importantly de do not
uh we did not get blocked by

00:33:12.824,00:33:17.095
Windows Defender. We
successfully executed whatever
we wanted without being

00:33:17.095,00:33:22.100
detected. [applause] So now Hila
will talk about how we
implemented our code to bypass

00:33:31.710,00:33:36.715
those security mechanisms. >> So
all of the find that we show so
far runs under the radar of many

00:33:41.052,00:33:48.059
security solutions. Why? Because
our target stub looks innocent
and as well know, naive idiots

00:33:48.059,00:33:53.064
are not the threat. So, why do
we run under the radar? This is
not a magic. We now know what

00:33:56.034,00:34:00.739
are the major mechanisms exist
in most of the security
solutions to detect malicious

00:34:00.739,00:34:06.978
code. Our target stub avoids the
static signatures detection
because it doesn’t have any

00:34:06.978,00:34:12.350
malicious logic in its base
form. The malicious code is
never deployed on the target

00:34:12.350,00:34:17.789
site so the Mimikatz executable
strings that Amit showed you
earlier will never be on the

00:34:17.789,00:34:24.729
target operating system.
Moreover our target stub avoids
the heuristic rules detection

00:34:24.729,00:34:30.168
because it doesn’t have any of
the Mimikatz executable
properties. So static signatures

00:34:30.168,00:34:34.706
and heuristic rules are not a
threat to us. But let’s keep in
mind that the behavioral

00:34:34.706,00:34:39.678
signatures might detect us. And
this is the only mechanism that
might detect our malicious

00:34:39.678,00:34:45.550
activity. But those signatures
are expensive. Expensive to
develop and expensive to

00:34:45.550,00:34:50.555
execute. We executed malproxy
under the leading security
solutions in the market and here

00:34:53.191,00:34:58.196
are the results. As you can see,
in most cases, malproxy executed
Mimikatz successfully while in

00:35:00.532,00:35:07.372
other cases security uh security
solution blocked some API call
with access deny error. The

00:35:07.372,00:35:12.377
operation is simply failed but
no verdict was made. So, we are
almost at the end of our talk.

00:35:16.281,00:35:21.386
We have seen the limitations in
existing security products and
showed a way to bypass their

00:35:21.386,00:35:26.391
detection mechanisms. So how can
those products catch us? As we
said our ops rely on behavioral

00:35:30.528,00:35:35.533
signatures. Obviously our target
stub can be statically signed by
it’s IOCs and start another race

00:35:37.802,00:35:44.109
between the defense and offense
players to find the best IOCs on
one end and change the code to

00:35:44.109,00:35:49.647
avoid detection on the other
end. We believe that pretty good
static signatures can be

00:35:49.647,00:35:55.553
generated to detect our tool.
But as we have seen during this
talk this mechanism is far from

00:35:55.553,00:36:01.926
being rheumatic. Another option
is to improve the behavioral
signatures detection. As we said

00:36:01.926,00:36:06.431
in the bottom line the operating
system interacts with the target
er um the malicious code

00:36:06.431,00:36:12.303
interacts with the target
operating system. We can monitor
the operations taken by the

00:36:12.303,00:36:16.908
malicious code to make sure that
all system calls are fully
tracked. The-The signatures uh

00:36:16.908,00:36:22.180
building the log of executed
system calls and the signatures
which define what malicious

00:36:22.180,00:36:27.185
behavior is have to become more
robust. So those are the idea
that we had but you are more

00:36:31.322,00:36:36.961
than welcome to think about more
ways to bypass detection on one
end and detect your bypassers on

00:36:36.961,00:36:41.966
the other end. You’re welcome to
send your ideas to the address
presented now on the screen. So,

00:36:47.372,00:36:52.510
we want to thank our colleague
Yaron Shani for pointing out
this concept to us and

00:36:52.510,00:36:58.016
maintaining his cool blob with
lots of interesting stuff
inside. We also want to mention

00:36:58.016,00:37:03.054
other articles which were
published many years ago and
described this proxying concept

00:37:03.054,00:37:08.059
breifly. Thank you very much for
coming. We really appreciate it.
[applause] >> So we do actually

00:37:16.034,00:37:21.973
uh we will publish the code of
malproxy online on Github uh
shortly uh just have to make a

00:37:21.973,00:37:26.778
few fixes in the code and then
it will be publicly available in
any- if anyone is interested.

00:37:26.778,00:37:31.783
>>Thank you [applause]

