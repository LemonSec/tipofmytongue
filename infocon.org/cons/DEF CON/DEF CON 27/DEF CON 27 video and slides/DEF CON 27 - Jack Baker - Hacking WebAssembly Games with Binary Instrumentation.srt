00:00:00.100,00:00:03.604
>>Uh, thank you all for coming.
I know you’re all missing church
to be here so I really

00:00:03.604,00:00:10.611
appreciate it. Um, uh so my name
is Jack Baker, uh I’m just gonna
get right into it uh by talking

00:00:10.611,00:00:17.084
about WebAssembly. So I want to
start uh by talking about what
WebAssembly actually is. Uh, so

00:00:17.084,00:00:22.456
you may already be familiar with
this, bear with me but um as a
little bit of background, uh

00:00:22.456,00:00:29.162
developers have done and
continue to uh really incredible
job of speeding up Javascript in

00:00:29.162,00:00:35.602
your browser. With stuff like
JIT compilers and a million
other optimizations. Uh, the

00:00:35.602,00:00:41.842
problem is Javascript is such a
dynamic language and that
dynamic nature uh will always be

00:00:41.842,00:00:48.048
a roadblock for optimizations.
There’s only so much a JIT
compiler can get away with. Uh

00:00:48.048,00:00:53.153
so what web assembly does is it
provides sort of a compliment to
Javascript in the form of a

00:00:53.153,00:00:58.959
static precompiled binary format
that can be used for like
performance intensive

00:00:58.959,00:01:05.799
applications and is much more uh
-much easier for your browser to
optimize. Uh so from a practical

00:01:05.799,00:01:10.871
sense what WebAssembly actually
is, it’s is basically an
instruction set like a

00:01:10.871,00:01:16.843
simplified CPU architecture that
runs in your browser. Uh so
WebAssembly is built to be

00:01:16.843,00:01:21.248
targetable by existing compilers
and existing languages meaning
we’re finally at the point where

00:01:21.248,00:01:27.587
we can start writing web
applications in C!, awesome. Uh,
so uh I want to talk a little

00:01:27.587,00:01:32.426
bit about what WebAssembly’s
actually used for. Uh, so as you
probably gathered from the name

00:01:32.426,00:01:37.264
of the talk, uh WebAssembly is
used for video games uh and this
is actually becoming really

00:01:37.264,00:01:42.369
common. If you look at any of
those like, old school like
flash game sites, ya know,

00:01:42.369,00:01:47.607
Newgrounds, Kongregate, stuff
like that, what you’ll notice is
that a huge portion of the new

00:01:47.607,00:01:52.045
stuff that’s uploaded is
actually using WebAssembly as
the back end and that’s with

00:01:52.045,00:01:58.185
good reason. Uh, because the two
really common engines that
you’ll run into these days is

00:01:58.185,00:02:03.824
for video games are Unity3D and
Unreal Engine 4. And both of
these engines can now target

00:02:03.824,00:02:08.462
WebAssembly. So you can build
your Unity3D game, you can click
a couple buttons and it’s

00:02:08.462,00:02:13.033
running in your browser using
WebAssembly as a back end. So as
a hacker, this means that

00:02:13.033,00:02:17.537
there’s a ton of targets out
there. There’s not really a lot
of tools to interface with them.

00:02:17.537,00:02:23.210
Uh, just for completion's sake,
I should say WebAssembly is used
for a lot of different stuff,

00:02:23.210,00:02:28.348
not just video games so like
you’ll see a lot of like desktop
applications that have been

00:02:28.348,00:02:34.221
retargeted as uh web
applications. Anything 3D is a
really good candidate for

00:02:34.221,00:02:40.027
WebAssembly. Obviously you’ll
see crypto miners cause we live
in a horrible world, uh and

00:02:40.027,00:02:44.765
there’s -there’s all sorts of
other stuff. Uh so the reason I
say this is that these

00:02:44.765,00:02:48.969
techniques are not, the
techniques I’m gonna show are
not really WebAssembly -I’m

00:02:48.969,00:02:53.640
sorry, not really video game
specific. Video games are just
really the most common and in a

00:02:53.640,00:02:58.912
lot of ways, the most fun
targets you’ll run into. Uh so
with that in mind, I want to

00:02:58.912,00:03:03.717
talk about reverse engineering
WebAssembly. So the interesting
thing about WebAssembly is that

00:03:03.717,00:03:09.589
uh, it makes web reverse
engineering start to feel more
like traditional like binary

00:03:09.589,00:03:13.994
reverse engineering of like ELF
files, PE files. For instance,
we’re back to using a

00:03:13.994,00:03:20.233
disassembler. Uh so there are a
few tools, uh that actually
support WebAssembly as is but

00:03:20.233,00:03:25.372
it’s mostly for static analysis.
So there’s stuff like Radare2;
there’s like no chance I’m

00:03:25.372,00:03:30.377
pronouncing that right. Uh, JEB
decompiler has some experimental
support for WebAssembly and then

00:03:32.379,00:03:37.184
there’s some WebAssembly
specific tools like the
WebAssembly binary toolkit or

00:03:37.184,00:03:43.023
WABT. Uh but that’s mostly
static analysis. When we talk
about dynamic analysis, the

00:03:43.023,00:03:47.928
story changes a little bit. If
you’re talking about debugging
WebAssembly, you’re probably

00:03:47.928,00:03:52.933
talking about using your
browser. And if you’ve used the
debugging tools in your browser

00:03:52.933,00:03:57.604
for WebAssembly, you’ve probably
noticed that they’re pretty
lacking. So you’ll see that

00:03:57.604,00:04:01.908
there’s no like watch points, uh
there’s no conditional
breakpoints and there’s a ton of

00:04:01.908,00:04:06.913
random bugs. Uh so with that in
mind, I wanna talk a little bit
specifically about what video

00:04:09.850,00:04:15.255
game reverse engineering is. So
video games are actually a
really unique challenge when it

00:04:15.255,00:04:20.093
comes to reverse engineering and
this is for a couple reasons.
The first is that video games

00:04:20.093,00:04:25.298
compared to like other types of
applications are so much more
complex. Because when you’re

00:04:25.298,00:04:29.636
looking at a video game, you’re
not looking at just the code
that the game developer wrote,

00:04:29.636,00:04:33.840
you’re looking at the entire
game engine, you know, the
graphics, the sound, physics,

00:04:33.840,00:04:39.579
everything like that. It makes
for so much code to look
through, uh that it -it can be

00:04:39.579,00:04:44.217
daunting. Um, the second thing,
is that video games are of
course more performance

00:04:44.217,00:04:48.655
intensive than most other
application and performance
impacts are a lot more

00:04:48.655,00:04:53.660
noticeable. If you’re using some
ya know, dynamic analysis tool
and it’s slowing down the game,

00:04:53.660,00:04:58.732
no one wants to play a game at 5
FPS, it just doesn’t work. So
there’s an extra challenge when

00:04:58.732,00:05:03.804
you’re developing tools for
dynamic analysis or hacking
video games. So with that in

00:05:03.804,00:05:09.309
mind, when I started looking at
hacking WebAssembly games, what
I was really looking for was a

00:05:09.309,00:05:14.414
tool like Cheat Engine
specifically for WebAssembly. So
I want to talk about what Cheat

00:05:14.414,00:05:20.187
Engine is. Um, if you haven’t
heard of Cheat Engine, uh you
probably didn't play Maple Story

00:05:20.187,00:05:25.091
growing up. Uh, what Cheat
Engine is, uh is it’s a tool
made by a guy named Dark Byte

00:05:25.091,00:05:29.796
and it’s effectively a
specialized debugger
specifically for hacking video

00:05:29.796,00:05:35.835
games. So what Cheat Engine can
do is it can search memory, it
can modify memory, it can freeze

00:05:35.835,00:05:41.641
memory meaning that attempted
changes to that memory location
won’t take. Uh, it can use

00:05:41.641,00:05:47.214
watchpoints and it can inject or
patch code in the binary. So
that sorta makes sense but to

00:05:47.214,00:05:52.118
understand why Cheat Engine is
so cool, why it’s worth trying
to ya know emulate these

00:05:52.118,00:05:58.091
methods, I want to go through
sota a 101 example of using
Cheat Engine. So with that uh

00:05:58.091,00:06:04.097
image we’re -we’re playing our
game and our goal is to make our
player character invincible and

00:06:04.097,00:06:08.268
the one thing we do know uh we
haven't done any reverse
engineering but the one thing we

00:06:08.268,00:06:13.740
do know is that our player
currently has 5 health. So what
we do is we ask Cheat Engine,

00:06:13.740,00:06:18.311
look for everything in memory
that has the value 5. And Cheat
Engine comes back and it’s say

00:06:18.311,00:06:23.016
okay I found ya know a few
thousand re- places where I
found the value 5. Uh that

00:06:23.016,00:06:29.256
doesn’t quite narrow it down. Uh
it’s way -still too much to look
through by hand but uh it starts

00:06:29.256,00:06:34.527
to narrow it down. And so what
we can do then is uh we cause
our value to change. We get hurt

00:06:34.527,00:06:39.499
uh and now our health value is 4
and we search for that and we
say okay, of all those values

00:06:39.499,00:06:45.605
that used to be 5, which ones
are now 4, and we narrow it down
some more. Um, and then we

00:06:45.605,00:06:51.111
continue that process as many
times as we need to until we
found the one value in memory

00:06:51.111,00:06:56.483
that is associated with our
health value. And once we found
that -that memory address we can

00:06:56.483,00:07:00.654
manipulate it, we can heal
ourselves back to full, we can
give ourselves more health than

00:07:00.654,00:07:05.792
we’re supposed to have, uh we
can even freeze our health so
that basically any attempt to

00:07:05.792,00:07:10.497
change it, ya know decrement our
health when we get hurt doesn’t
take, it just goes back to 5.

00:07:10.497,00:07:15.502
Um, so just -just like this,
with just a couple pretty quick
steps we were able to go from

00:07:17.537,00:07:22.309
knowing nothing about this uh
application, no reverse
engineering to doing something

00:07:22.309,00:07:27.814
practical. We were able to find
some value and manipulate it.
The problem with this method is

00:07:27.814,00:07:33.687
that it can take a little while
um and it needs to be -re -need
to be redone every time we play

00:07:33.687,00:07:37.557
the game. Odds are the next time
we start up the game, our health
value is going to be somewhere

00:07:37.557,00:07:42.429
else either because of like
address space, layout
randomization, or just the fact

00:07:42.429,00:07:48.601
that uh dynamic memory uh
mapping is not really
predictable. Uh basic- we

00:07:48.601,00:07:53.606
probably have to start from
scratch every time. So ideally
what we want to do is just do

00:07:53.606,00:07:57.344
this once and then make some
permanent change so that we
don’t have to go through this

00:07:57.344,00:08:02.282
process every time we want to do
this to the game. So uh the next
step we take is we set a

00:08:04.551,00:08:09.556
watchpoint on our health address
and then we get hurt again to
trigger it. And then Cheat

00:08:09.556,00:08:14.594
Engine comes back and it says I
-uh something tried to write to
this value in memory and it

00:08:14.594,00:08:18.098
occurred right here. And so
basically uh we’re able to see
exactly which code is

00:08:18.098,00:08:20.100
responsible for causing our
charac- player character to get
hurt. Uh and what we can do once

00:08:20.100,00:08:25.105
we find that is we’re able to
patch it out, basically take out
the ability for our character to

00:08:33.713,00:08:38.451
get hurt. And so without we’ve
made a permanent change to the
binary so that our character is

00:08:38.451,00:08:43.723
now invincible. Um so the reason
that I go through this example
is that it shows that not only

00:08:43.723,00:08:48.161
is Cheat Engine ya know helpful
for like hacking video games, we
made our character invincible

00:08:48.161,00:08:52.932
but it’s also a huge help when
we’re talking about the reverse
engineering process. Like we

00:08:52.932,00:08:59.472
said um, video games are like
dauntingly large as fall -as far
as applications go when you’re

00:08:59.472,00:09:02.909
talking about reverse
engineering. So going -going
through this process we were

00:09:02.909,00:09:08.748
able to narrow down this
gigantic codebase and uh
associate a value in memory with

00:09:08.748,00:09:13.453
its purpose and then associate
that value in memory with the
code that affects it; we were

00:09:13.453,00:09:18.691
able to really easily find the
relevant code without doing a
whole ton of work. So this is

00:09:18.691,00:09:24.130
what’s so cool about Cheat
Engine. So um, with that in mind
I had the question of, well

00:09:24.130,00:09:29.769
could I apply these same
techniques to WebAssembly and
you run into one really big road

00:09:29.769,00:09:34.274
block when you try to do that
and that’s that WebAssembly
doesn’t have watchpoints. And

00:09:34.274,00:09:39.279
that was a big uh a big part of
uh the Cheat Engine process was
using watchpoints. So my

00:09:41.414,00:09:48.154
question was, can we emulate the
behavior of watchpoints without
them being uh and without them

00:09:48.154,00:09:53.927
being supported by the spec or
our browser or anything like
that. So uh my first attempt at

00:09:53.927,00:09:59.699
doing that was basically the
dumbest, simplest thing I could
come up with which was just use

00:09:59.699,00:10:05.638
your built in browser debugger,
put a breakpoint at every single
load or store instruction in

00:10:05.638,00:10:11.244
WebAssembly and then when that
breakpoint is hit, uh check, do
some math to check if that

00:10:11.244,00:10:16.816
access is gonna affect the
address we’re watching. And this
amounts to thousands upon

00:10:16.816,00:10:23.156
thousands of breakpoints and ya
know any decently sized video
game binary. Uh so as you can

00:10:23.156,00:10:28.261
probably imagine, didn’t work at
all. Um browser basically
becomes completely unusable, ya

00:10:28.261,00:10:34.434
know X Kill Chrome, start again,
no chance. Uh so I started
thinking, if I wanted to do this

00:10:34.434,00:10:39.305
in a way that wasn’t like
stupid, uh what would that look
like. Uh so from like a high

00:10:39.305,00:10:44.611
level perspective what I came up
with was if we wanna emulate the
behavior of watchpoints, what we

00:10:44.611,00:10:50.783
want to do is inject code into
the binary at every single
memory load or memory store

00:10:50.783,00:10:56.055
instruction. And what that
code’s gonna to do is gonna
check if that access is

00:10:56.055,00:11:00.693
affecting a memory area that
we’re watching, our -our
watchpoint address. And if it

00:11:00.693,00:11:06.399
does, we want it to call a
breakpoint, call our code to
basically alert us that this

00:11:06.399,00:11:11.070
change was made, maybe give us a
stack trace, something that
tells us something tried to

00:11:11.070,00:11:17.010
change our memory address and it
occurred right here. So to do
all this, we need to employ some

00:11:17.010,00:11:22.982
form of binary instrumentation
so let’s uh talk about that term
a little bit. Uh so binary

00:11:22.982,00:11:28.888
instrumentation uh basically is
the process of manipulating an
application binary whether it’s

00:11:28.888,00:11:35.228
ya know an ELF or PE file
whatever, uh to aid in some form
of analysis. So there’s a lot of

00:11:35.228,00:11:39.799
really cool binary
instrumentation tools that
already exist for other types of

00:11:39.799,00:11:45.104
binaries so like Frida is an
awesome tool for ya know ELFs,
PE’s, Android applications,

00:11:45.104,00:11:50.910
stuff like that. DyamoRIo is
another real cool, uh real cool
tool um there’s, I’m sure there

00:11:50.910,00:11:55.214
others I haven’t used. Uh but
this is not, like, a new
concept; I'm not coming up with

00:11:55.214,00:12:00.019
the concept of binary
instrumentation. Uh there’s even
some existing tools specifically

00:12:00.019,00:12:05.558
for WebAssembly so I wanna talk
about those a little bit. The
first one I wana talk about is a

00:12:05.558,00:12:11.130
tool called Wasabi by uh Daniel
Lehman, I hope I’m pronouncing
that right. Uh and it’s a really

00:12:11.130,00:12:16.869
cool instrumentation and
analysis tool specifically for
WebAssembly, uh unfortunately it

00:12:16.869,00:12:22.008
doesn’t really fit our needs for
a couple of reasons. The first,
is that Wasabi is written in

00:12:22.008,00:12:26.646
Rust and it’s intended to be run
from the terminal so if we wanna
instrument some WebAssembly

00:12:26.646,00:12:30.617
binary what we have to do is we
have to download it, we
instrument it from the terminal,

00:12:30.617,00:12:35.388
we upload it again and then we
run it uh and that’s -that’s a
little annoying. Potentially we

00:12:35.388,00:12:40.760
could modify Wasabi and compile
something that could run in the
browser but then we run into our

00:12:40.760,00:12:46.432
second problem and that’s that
Wasabi does all it’s analysis by
injecting Javascript into the

00:12:46.432,00:12:51.437
binary. So basically Wasabi will
put calls into the WebAssembly
binary to Javascript functions

00:12:53.606,00:12:59.812
in order to do it’s analysis.
And in testing this, it became
really clear, really quickly

00:12:59.812,00:13:04.784
that if we wanna run a game at
any decent performance at all,
uh we need to call Javascript as

00:13:04.784,00:13:10.023
infrequently as I -as we can. Uh
so basically if you imagine the
WebAssembly VM and the

00:13:10.023,00:13:15.395
Javascript VM are two different
virtual machines and calls
between the two are still a

00:13:15.395,00:13:20.066
little bit uh performance
intensive uh and if you’re
talking about injecting code at

00:13:20.066,00:13:26.305
every single memory load or
memory store instruction, excuse
me, uh this just becomes

00:13:26.305,00:13:32.078
completely overwhelming for the
browser very quickly. So
unfortunately Wasabi didn’t work

00:13:32.078,00:13:36.883
for us. Let’s look at our next
tool which I’ve actually already
mentioned which is the

00:13:36.883,00:13:41.888
WebAssembly Binary Toolkit or
WABT. Uh so WABT is uh library
specifically for uh modifying

00:13:44.991,00:13:49.429
and parsing WebAssembly
binaries. Um there’s even a
version of it that’s been

00:13:49.429,00:13:55.568
compiled to Javascript so it
seemed like the perfect starting
point uh for -for doing this

00:13:55.568,00:14:01.374
type of manipulation. The
problem is that uh in -in
reality when you try to use WABT

00:14:01.374,00:14:07.213
to parce like uh uh video game
binary, it just takes way too
long and way too much memory. So

00:14:07.213,00:14:12.819
I tried this with a demo Unity 3
binary, nothing too big,
basically just hello world of

00:14:12.819,00:14:18.591
Unity. And what you would see is
WABT would spin its wheels for
10 or 15 seconds and then just

00:14:18.591,00:14:23.129
crash with an out of memory
error. So already we’re seeing
it’s taking way too long.10 or

00:14:23.129,00:14:27.633
15 seconds is way longer than we
want to wait even if it worked
but it didn’t; it’s running out

00:14:27.633,00:14:32.638
of memory. Who knows how long a
-a in the parsing process. So
after looking at uh the two

00:14:35.508,00:14:40.747
tools I could find, I sorta
drafted a set of prerequisites
for what we would want in a tool

00:14:40.747,00:14:45.084
that we could use for our
purpose. So the first thing is
we wanna be able to instrument

00:14:45.084,00:14:49.388
binaries from within the
browser. We don't wanna have to
download something, instrument

00:14:49.388,00:14:55.161
it, put it back up; that’s
-that’s boring. Uh, it also
needs to be able to handle large

00:14:55.161,00:15:01.267
WebAssembly binaries. Ya know
video game binaries are very
commonly like 40 MB plus a needs

00:15:01.267,00:15:05.705
to be able to do this quickly
and without running out of
memory in the process . So since

00:15:05.705,00:15:10.510
as far as I know, this tool
didn’t exist uh I developed my
own library which I very

00:15:10.510,00:15:16.149
creatively titled the uh
WebAssembly Instrumentation
Library or WAIL. Uh and this is

00:15:16.149,00:15:21.154
uh, WAIL is a Javascript library
uh specifically focused on
making targeted modifications to

00:15:23.222,00:15:28.327
WebAssembly binaries. Uh so if
you think of a WebAssembly
binary kind of like an ELF file

00:15:28.327,00:15:34.567
uh uh, an ELF file has sections
that have different purposes and
so does a WebAssembly binary. So

00:15:34.567,00:15:40.873
what WAIL does is it can add
entries to any uh any section of
the binary. It can edit existing

00:15:40.873,00:15:45.878
entries of sections; it can also
add or remove sections from the
binary. Uh so WAIL actually uses

00:15:48.014,00:15:53.152
a couple trick to modify
binaries quite a bit faster and
with a lot less memory usage

00:15:53.152,00:15:59.192
than other library. The first
one’s kinda a no brainer. Uh
WAIL only parces the sections or

00:15:59.192,00:16:04.063
elements of sections that are
necessary to perform the
modifications you defined. If

00:16:04.063,00:16:08.167
you’re doing some modification
that doesn't require parsing the
code section, it not gonna parse

00:16:08.167,00:16:14.040
it, just skips it and that saves
a ton of time right off the bat.
Uh, the second part is a bit

00:16:14.040,00:16:19.111
more complicated. So what WAIL
does is it parses binaries
basically as a stream and I

00:16:19.111,00:16:23.749
wanna explain a little bit about
what that means. So if you’re
talking about parsing some sort

00:16:23.749,00:16:29.188
of binary whether it’s an
application or an image or
whatever. Uh the normal way you

00:16:29.188,00:16:34.493
do that involves ya know, you
break that binary up into its
pieces, you create a map of all

00:16:34.493,00:16:39.298
those pieces, and then once
you’ve got that map created, you
change the parts you want to

00:16:39.298,00:16:43.636
change and then you stick
everything back together into
one big binary. This is

00:16:43.636,00:16:46.873
convenient, it’s
straightforward, it’s sorta the
obvious way to parse the binary

00:16:46.873,00:16:51.143
but it’s also sort of slow and a
little bit more memory
intensive. And the reason for

00:16:51.143,00:16:57.650
that is that you have to uh
split the binary up, store every
piece as a different object in

00:16:57.650,00:17:03.289
memory with all the memory
overhead that might entail uh
and then do the work of putting

00:17:03.289,00:17:09.028
it all back together. It takes a
little while. So what WAIL does
is, as I mentioned, it parses

00:17:09.028,00:17:15.401
binaries as a stream meaning it
uh handles and modifies every
single element as soon as it’s

00:17:15.401,00:17:20.573
read. Basically it goes from -
goes through the binary from the
start reading only one element

00:17:20.573,00:17:25.811
at a time, changes if it has-
changes it if it has to, throws
it away if it has to and then it

00:17:25.811,00:17:31.083
moves onto the next one, forgets
that last element ever existed.
This way we don’t ever have to

00:17:31.083,00:17:36.622
do the work of storing the
entire binary all -and all its
pieces in memory at once. We’re

00:17:36.622,00:17:41.160
just working with one single
element at a time and then
forgetting about it once we move

00:17:41.160,00:17:46.832
onto the next one. . Uh there
are some downsides to this
approach.Uh, the first one is

00:17:46.832,00:17:51.570
the parser can never go
backward. Once we finished
parsing past a particular

00:17:51.570,00:17:55.608
element, we’ve stopped looking
at it, we can’t go back and we
can’t make changes to it. We

00:17:55.608,00:17:57.610
have to do everything
-everything we need to do to
that element the second we see

00:17:57.610,00:17:59.612
it. Uh, so to deal with this, we
have to define all of our
modifications before we start

00:17:59.612,00:18:01.547
parsing. There’s no moment where
we can parse the entire binary
and then say okay I want to

00:18:01.547,00:18:03.549
change this or that or whatever.
We have to define everything
upfront and then let the parser

00:18:03.549,00:18:08.554
run with it. This sorta causes a
second problem which is sorta
WebAssembly specific. So uh when

00:18:21.801,00:18:27.673
you’re talking about modifying a
WebAssembly binary or making
additions, uh there’s a lot of

00:18:27.673,00:18:32.979
cases where making one addition
or making one change will rely
on information about another

00:18:32.979,00:18:39.385
section or another -another
element. So I wanna give the
example of adding a new function

00:18:39.385,00:18:45.491
into a binary. So you’re adding
a new like built-in assembly
called from WebAssembly VM. This

00:18:45.491,00:18:51.097
is actually a three part
process. The first thing you
gotta do is you uh define a new

00:18:51.097,00:18:57.136
element in the type section
which says, this is a function
it takes two parameters, one is

00:18:57.136,00:18:59.271
a N32 and the other one’s a
Float32, eh it returns one value
and that value is also a Float

00:18:59.271,00:19:04.210
32, something like that. Uh the
next thing you need to do is you
add an element into the function

00:19:08.547,00:19:14.587
section. And this basically
declares your function without
defining its body, without

00:19:14.587,00:19:19.759
defining the instructions that
are actually -that actually make
up the function. And when you

00:19:19.759,00:19:26.632
create this function section
entry, you have to reference the
index of your new type section

00:19:26.632,00:19:32.071
entry so if that new entry
you’ve created in the type
section is index 1,000, your

00:19:32.071,00:19:37.076
function section entry has to
say, “I’m a function, I
reference type element 1,000”.

00:19:39.278,00:19:44.884
Um, and then, you have to create
an element in the code section
that is basically the body of

00:19:44.884,00:19:51.057
your function, basically uh the
instructions that will be called
when your function is called.

00:19:51.057,00:19:56.062
And this section also has to
correspond to the index of your
F- your newly created function

00:19:58.831,00:20:03.836
element uh similar to with the
type section. Uh so as you can
sorta see with this, there’s a

00:20:05.905,00:20:10.843
couple different pieces of
information that we don’t know
up front. We don’t know what

00:20:10.843,00:20:16.715
index our new type section entry
is gonna be until we know how
many existing type section

00:20:16.715,00:20:20.786
entries there - this is gonna
be. So this causes a problem
when we’re talking about doing

00:20:20.786,00:20:27.259
everything upfront because
there’s some knowledge that we
don’t have upfront. So uh WAIL

00:20:27.259,00:20:32.098
does what the uh WAIL deals with
this using sorta a special
grammar. Basically every

00:20:32.098,00:20:36.969
addition you make to a binary,
you’re given back a handle. And
this handle doesn’t have a value

00:20:36.969,00:20:43.542
until the parses starts running
but it can be used to make these
complicated additions so -i in

00:20:43.542,00:20:48.614
the previous example, we add our
new type entry, we’re given back
some handle and then we use that

00:20:48.614,00:20:54.186
handle when we define our new
function entry. Uh and then we
use the handle from that new

00:20:54.186,00:20:59.592
function entry to create our
code entry. And basically by
doing this, the parser will see

00:20:59.592,00:21:05.564
these handles, fill in the gaps
for us and so we can do these
complex like chained

00:21:05.564,00:21:09.835
modifications while still doing
everything upfront. We still
don’t have to know anything

00:21:09.835,00:21:16.075
about the binary before we start
parsing it. Uh if you’re not
already sick of uh hearing me

00:21:16.075,00:21:21.213
talk about WebAssembly uh
parsing, there is one more
really annoying uh catch and

00:21:21.213,00:21:25.951
this is actually a two part
problem. And it has to do with
the uh the uh function tables

00:21:25.951,00:21:31.624
and the global variable tables.
So uh if we take the example of
like calling a function in

00:21:31.624,00:21:37.096
WebAssembly, you’re not calling
that function by its address or
by its name, you’re calling it

00:21:37.096,00:21:42.101
by its index into a table. And
so uh that table is created by
the engine when it first starts

00:21:44.470,00:21:50.843
parsing the binary. So basically
what the -what the engine does
is it takes all the imported

00:21:50.843,00:21:55.481
function, all the functions that
have been sorta given to the
WebAssembly binary by

00:21:55.481,00:22:00.553
Javascripts and it puts them at
-as the first elements at the
table. So if you have 10

00:22:00.553,00:22:06.392
imported functions, the first
one will -will be 0 1 2 3
whatever all the way to 9. Uh

00:22:06.392,00:22:10.462
and then, it takes all the
internal functions, the
functions that are actually

00:22:10.462,00:22:17.469
built into the binary uh and it
puts them in the table after
those imported functions. So the

00:22:17.469,00:22:22.441
first internal function, will i-
if you have 10 imported
functions, the first imported

00:22:22.441,00:22:27.513
internal function will be index
10, 11, 12 whatever. And the
exact same process exists when

00:22:27.513,00:22:34.220
you’re talking about global
variables whether their imported
or internal. So the problem here

00:22:34.220,00:22:39.725
is that the second that you add
a new imported function or
imported global variable, you

00:22:39.725,00:22:45.831
throw off the entire rest of the
table. So if you have ya know
your 10 imported functions and

00:22:45.831,00:22:51.537
you add one, what used to be in
uh function index number 10,
your internal function is now

00:22:51.537,00:22:58.377
11, 11 is 12 et cetera. And that
throws off every single call,
every function uh reference

00:22:58.377,00:23:03.983
pretty much the rest of the
binary is broken. Uh and the
same with global variables. So

00:23:03.983,00:23:09.688
this is very annoying but it’s
actually pretty easy to fix
automatically. So WAIL fixes

00:23:09.688,00:23:16.061
this basically by parsing uh all
-any section that could
potentially be affected by this

00:23:16.061,00:23:22.935
change uh and it finds those
elements and it say “Oh uh, you
are -you’re now off by one, I

00:23:22.935,00:23:28.440
add one to that” uh in order to
fix those references so that you
don’t have to do the work

00:23:28.440,00:23:34.113
yourself. So now that we’ve
talked about the boring stuff uh
and we’ve got our -our parsing

00:23:34.113,00:23:40.252
tool, we can actually go back to
our goal of emulating the
behavior of watchpoints uh using

00:23:40.252,00:23:46.225
WAIL. So let’s talk specifically
about what that process looks
like. Uh, so the first thing

00:23:46.225,00:23:52.765
we’re gonna do is we’re gonna
create two new global variables
within the binary. Uh and so the

00:23:52.765,00:23:58.270
first one of those is gonna hold
the address that we’re watching,
literally the address of our

00:23:58.270,00:24:03.475
watchpoint. The second one is
gonna hold two different flags
for us, the first is just, “Is

00:24:03.475,00:24:10.182
this watchpoint enabled?”, yes,
no. Uh the second one is how big
of a value are we watching. Are

00:24:10.182,00:24:15.187
we watching 1 byte, are we
watching 2,4,8 whatever? Um,
then once we have that the next

00:24:17.456,00:24:22.962
thing we’re gonna do is add an
import entry, we’re gonna import
a new Javascript function, and

00:24:22.962,00:24:27.199
this function in -this
function’s purpose is to be
called when our watchpoint is

00:24:27.199,00:24:32.604
triggered. And it’s gonna do the
work of alerting us to that fact
and it’s gonna uh give us the

00:24:32.604,00:24:37.409
stack trace or something so that
we’re able to work backwards and
say oh that watchpoint was hit

00:24:37.409,00:24:42.815
at that address by this
instruction. Um, as long as this
function is only called when a

00:24:42.815,00:24:48.354
watchpoint is triggered, the
performance impact of this is
negligible. Uh, the next thing

00:24:48.354,00:24:52.991
we’re gonna do is create a new
internal function. As I
mentioned before, this is

00:24:52.991,00:24:58.163
actually a 3 step process but
we’re gonna skip over that now.
Uh and what this internal

00:24:58.163,00:25:02.868
function is gonna do, is it’s
gonna perform the actual logic
of our watchpoint. So it’s going

00:25:02.868,00:25:07.873
to do the math of uh, does this
attempted access overlap with uh
the address we’re watching and

00:25:10.943,00:25:15.681
if it does, it’s gonna call the
trigger function, that
Javascript function we just

00:25:15.681,00:25:21.620
imported. Finally, we have one
more step which is that we’re
gonna place calls to our

00:25:21.620,00:25:26.392
watchpoint function, that
internal function we just
created uh before every single

00:25:26.392,00:25:32.197
memory load or memory store
instruction. Uh so as long as
we’re really careful about how

00:25:32.197,00:25:37.269
many instructions we execute
every time we check our
watchpoints, we can actually do

00:25:37.269,00:25:42.374
this with no noticeable drop in
FPS. We can still play video
games, we can have all this

00:25:42.374,00:25:46.812
stuff running in the background,
we don’t even notice it’s there.
So now that we understand this

00:25:46.812,00:25:52.184
process and we’ve sorta filled
in the gaps, what I wanted to do
was see if I could sorta emulate

00:25:52.184,00:25:58.323
Cheat Engine for WebAssembly and
so I build another tool which I
call CETUS uh and it is a

00:25:58.323,00:26:03.695
browser extension that’s
basically Chetus -Cheat Engine
for WebAssembly. Uh the name

00:26:03.695,00:26:07.900
CETUS comes from the Latin word
for sea monster so you can
probably see the theme I was

00:26:07.900,00:26:14.740
going for here. Uh so what CETUS
does, is it intercepts and
instruments WebAssembly binaries

00:26:14.740,00:26:20.279
in your browser on the fly, uh
before the’re executed. And that
instrumentation consists of

00:26:20.279,00:26:26.518
adding read or reading and write
watchpoints. Uh it has the
functionality to functionality

00:26:26.518,00:26:32.090
to freeze memory making it so
that attempts to change some
value in memory don’t take. Uh

00:26:32.090,00:26:38.797
and it can apply uh patches
defined by the user, so we can
do code patching, change code,

00:26:38.797,00:26:44.570
uh through this exten
-extension. Excuse me. So uh
with that in mind, uh I want to

00:26:44.570,00:26:49.575
get to my first demo if I can
figure out how to use this.
Okay, so this is just uh a

00:26:52.511,00:26:57.516
really simple demo Unity game
and our goal here is we’re gonna
make this red uh tank here

00:26:59.651,00:27:05.357
invincible. So the first thing
we want to do is uh, is we know
that this tank is at 100 percent

00:27:05.357,00:27:10.362
health so we can guess that uh,
it’s health is stored as a float
value of 100 so we’re gonna

00:27:13.432,00:27:19.838
search for that in memory. We,
uh give our value of 100, our
comparison of equal as in we’re

00:27:19.838,00:27:24.843
asking the extension. Look for
all value in memory that are
equal to 100 of type float 32.

00:27:28.647,00:27:35.220
And we get back 112 results so
we still have to narrow it down
some. So what we do next is we

00:27:35.220,00:27:40.993
cause that red tank’s health
value to change. So we shoot it,
it takes some damage, and now

00:27:40.993,00:27:45.297
what we’re going to do is we’re
gonna search for, of all the
values we got last time, which

00:27:45.297,00:27:50.936
ones are less than 100 now and
this narrows it down. We find
two of them that are somewhere

00:27:50.936,00:27:55.107
around 50 percent which looks
about right, it looks like our
tank has something like 50

00:27:55.107,00:28:01.313
percent health. So we’ve uh
there’s a pretty good chance
that one of these two is holding

00:28:01.313,00:28:06.351
our health value. So what we’re
gonna do is we’re gonna start
with our first one. We’re gonna

00:28:06.351,00:28:10.422
uh -uh just bookmark it and from
there we can uh start, we’ve
saved the value in memory and we

00:28:10.422,00:28:12.424
cam start to manipulate it. So
the first things we’re gonna do
is freeze that value in memory.

00:28:12.424,00:28:17.429
Uh so now what we see is that
when we try to change that value
in memory basically our, our

00:28:24.770,00:28:31.610
-our uh injected instructions
basically say no, don’t do that.
We’re uh, this value is frozen

00:28:31.610,00:28:38.450
that change doesn’t take. Uh so
our tank is now invincible. Uh
so that’s ya know a good start

00:28:38.450,00:28:42.955
but again we wanna -we wanna
make this process a little bit
simpler; we don’t wanna have to

00:28:42.955,00:28:47.960
do it again. Oh I’m sorry, I uh
got a little bit ahead of
myself. Uh so, what uh we do now

00:28:50.062,00:28:55.901
is we wanna set our write
watchpoint. Basically we’re
asking the extension uh tell us

00:28:55.901,00:29:02.708
what instructions are trying to
write to this memory address, or
trying to ya know cause the red

00:29:02.708,00:29:07.713
tank to take damage. And then uh
we trigger it by uh causing that
tank to take damage and in just

00:29:10.148,00:29:15.854
a second uh we get uh
disassembly of exactly where
that code occurred. So we have

00:29:15.854,00:29:21.627
this function uh that uh I’ll
-I’ll save you the trouble of
reading it. Basically what it’s

00:29:21.627,00:29:28.066
doing is it takes some damage
value, it loads our health
value, subtracts that damage

00:29:28.066,00:29:33.171
value from it, and then it
stores it uh stores the new
value in memory as our new

00:29:33.171,00:29:39.378
health value. So what we wanna
do here is just take out the
part where it storing that new

00:29:39.378,00:29:44.149
value, basically make it so we
can’t get hurt anymore. Uh, I
should say that this is -this

00:29:44.149,00:29:48.854
was recorded on a little bit of
an older version of CETUS so
there’s some graphical issues

00:29:48.854,00:29:53.859
here, they’re worked out now I
promise. Um, but so what we do
is find this F32 store

00:29:56.595,00:30:00.766
instruction, this instruction
that’s gonna write to our new
memory address and we just

00:30:00.766,00:30:06.905
replace it with a couple uh
other instructions and then we
save our patch. And that’s

00:30:06.905,00:30:13.178
pretty much it. Now the one uh
annoying thing here is that we
can’t modify code while the

00:30:13.178,00:30:17.616
binary is running; there’s no
way to do that within
WebAssembly so what we have to

00:30:17.616,00:30:22.954
do is we have to restart the
game to apply that patch. But as
we can see here, we’re not using

00:30:22.954,00:30:29.728
the extension, we’re not using
CETUS, uh and even still we can
uh shoot our new tank and we can

00:30:29.728,00:30:34.733
see it’s invincible. [Applause]
Oh, okay umm I’m ahead of myself
here. Don’t look. Okay, so uh

00:30:48.680,00:30:52.384
with that being said, I wanna
talk about a couple other
features of CETUS that I didn’t

00:30:52.384,00:30:58.056
really show uh in the demo but
uh the first of those is
differential searching. So, in

00:30:58.056,00:31:02.527
the example we just showed we
had the benefit of knowing the
starting value we were looking

00:31:02.527,00:31:07.799
for. We knew we were looking for
the float value of 100. Uh
that’s not always the case

00:31:07.799,00:31:12.738
though. If you wanna talk about
the example of, let’s say you’re
trying to manipulate the

00:31:12.738,00:31:18.477
location of your player, their X
and Y coordinates or X,Y,Z if
it’s 3D. Uh you may not know

00:31:18.477,00:31:24.116
that your Y coordinates is 0 or
whatever but you may be able to
say, well if I go up the Y

00:31:24.116,00:31:29.321
coordinate goes up, if I go
down, it goes down, left and
right affect X stuff like that.

00:31:29.321,00:31:35.460
So differential searching
basically lets us find these
unknown values uh by taking a

00:31:35.460,00:31:42.434
big slice of all of memory and
then saying ok uh, what -which
of those values increased since

00:31:42.434,00:31:47.405
the last time we searched, which
one decreased, which ones stayed
the same? And that way you can

00:31:47.405,00:31:53.512
narrow it down and find those
values without ever actually
having to know a starting value.

00:31:53.512,00:31:59.551
Um, another really fun uh
feature of Cheat Engine is the
built in speed hack which is

00:31:59.551,00:32:05.390
basically used to speed up or
slow down games by some
multiple. Uh, I tried to emulate

00:32:05.390,00:32:10.562
this a little bit in uh CETUS;
it’s actually really easy to do.
Basically all it does is it

00:32:10.562,00:32:16.568
replaces the two functions
commonly used to keep track of
clock time in your browser and

00:32:16.568,00:32:22.307
changes the return value by some
multiple. And this is typically
all you need to do to speed up

00:32:22.307,00:32:27.312
or slow down a game by whatever
-whatever multiple you want. Um,
so with that, with CETUS sorta

00:32:29.614,00:32:34.519
out of the way, I wanna talk
about a couple other examples of
fun things you can do using

00:32:34.519,00:32:39.524
WAIL, using binary
instrumentation on uh video
games. So the first thing that’s

00:32:39.524,00:32:44.329
really useful is you can do
function tracing. Uh, this is uh
pretty simple, it’s just

00:32:44.329,00:32:50.135
injecting some code at the start
of each function that says, hey
I was called at ya know, I was

00:32:50.135,00:32:55.106
called, I was called by uh this
parent function, stuff like
that. Uh this is pretty slow no

00:32:55.106,00:33:01.479
matter how you do it but it is
pretty useful. Uh, the next
thing I want to talk about is

00:33:01.479,00:33:07.485
replacing functions. So using
WAIL, you can uh swap out all
references to a function

00:33:07.485,00:33:12.257
basically replacing it entirely.
Uh, so one fun thing you can do
is you can import a new

00:33:12.257,00:33:17.062
Javascript function and you can
replace all references to an
internal function with

00:33:17.062,00:33:22.400
references to that Javascript
function basically allowing you
to patch a WebAssembly binary

00:33:22.400,00:33:27.472
with Javascript. Uh you have to
be a little careful about
performance impacts but this is

00:33:27.472,00:33:32.477
still super useful. Uh this next
example is kind of the opposite
of that. Uh so what WAIL can do

00:33:35.680,00:33:41.953
is can take an internal function
and export it, basically make it
something that can be called by

00:33:41.953,00:33:47.859
Javascript. Uh so for ex
-example in the case of one
particular game, uh the game

00:33:47.859,00:33:54.833
would update a player’s stats by
making an http request to its
-its application server. Uh and

00:33:54.833,00:33:59.170
the way that it would prevent
you from just making the request
yourself or editing it on the

00:33:59.170,00:34:05.543
wire, is that it would hash the
request and uh verify that hash.
So the obvious way to deal with

00:34:05.543,00:34:11.616
this is you just disassemble the
binary, find that hashing
function uh and implement it

00:34:11.616,00:34:16.621
yourself so that you can uh hash
your own uh request. But it was
actually easier to just find

00:34:18.690,00:34:22.994
that hashing function, export
it, and then just call it
arbitrarily, just ask the

00:34:22.994,00:34:27.999
binary, hey hash this for me uh
and that was a really simple way
to uh be able to uh fake these

00:34:30.568,00:34:36.074
requests uh despite the fact
that I didn’t have to do any
real reverse engineering. Uh

00:34:36.074,00:34:41.079
then I got banned, uh. So uh
this is less of a video game
hack but uh still very useful.

00:34:44.316,00:34:51.323
Uh you can add symbols to
WebAssembly binaries using WAIL.
Uh so there’s actually two ways

00:34:51.323,00:34:56.027
that I came -came up with to do
this. The first one’s sort of
obvious. Uh the WebAssembly

00:34:56.027,00:35:00.966
specification defines a section
specially for symbols so like an
ELF uh and ELF binary symbol

00:35:03.368,00:35:08.473
table uh the -there’s something
called the name section in
WebAssembly which is just sorta

00:35:08.473,00:35:13.478
a list of this name corresponds
to this function et cetera. Um,
another kind of interesting way

00:35:16.014,00:35:21.786
to do this though was to just
add an export entry for every
function you want to name. So

00:35:21.786,00:35:26.625
when you add an export entry to
a function basically when you
ask WebAssembly export this

00:35:26.625,00:35:32.897
function for me, um you have to
give that function a name
because that -that name is the

00:35:32.897,00:35:38.636
variable you’re gonna call when
you wanna call that function
from Javascript. Uh and just in

00:35:38.636,00:35:45.043
my experience, pretty much every
WebAssembly tool treats the
export entry name as the

00:35:45.043,00:35:50.048
canonical symbol name uh for
that web -WebAssembly binary. So
this is a really simple way to

00:35:52.817,00:35:57.689
add symbols into a binary
without having to add an entire
uh -entirely new section to the

00:35:57.689,00:36:04.229
binary. Uh that sorta covers my
examples uh I have one more demo
but before I show it to you guy,

00:36:04.229,00:36:08.800
since I know you -you’re all
busy, this is where you can find
everything. It should all be up

00:36:08.800,00:36:15.106
right now. Uh I -I made all the
github repost uh public right
before I walked in here.

00:36:15.106,00:36:19.177
Hopefully I didn’t hit the
delete button instead but if I
did uh they’ll be up in a few

00:36:19.177,00:36:24.182
minutes. Uh before I show you
this uh last demo I just want to
say I -I uh had a little bit of

00:36:26.484,00:36:31.289
trouble figuring out what I
wanted to do for a final demo so
I sorta out together a montage

00:36:31.289,00:36:36.528
of different game hacks uh so I
hope you guys enjoy it. Um I
hope you guys take these tool, I

00:36:36.528,00:36:41.533
hope you use them, and I hope
you all get banned from New
Grounds for doing it. [laughter

00:36:48.573,00:36:53.578
in audience] Okay so this is me
invincible in a first person
shooter. Uh this is me no

00:36:55.680,00:37:00.618
clipping just a little too hard.
Uh this is me throwing infinite
grenades through a wall at some

00:37:06.891,00:37:11.896
poor soul. This one I think is
obvious. Uh this is uh just
cheating at some sorta pseudo

00:37:21.139,00:37:27.679
RTS. Uh as you can see, uh I
have a million of these units.
My uh money never goes down when

00:37:27.679,00:37:32.951
I uh buy something new. This
game actually used a bunch of
anti-cheat mechanics. You can’t

00:37:32.951,00:37:37.956
see any of it but I was kinda
proud of this. I don’t know what
this is. This is the speed hack

00:37:42.360,00:37:49.200
uh. Uh this is sorta my favorite
part. Uh, if you’ve played Prop
Hunt, you’ve probably seen this

00:37:49.200,00:37:54.105
before. This is me cheating at
Prop Hunt. Uh I should be taking
damage right now; I’m -I’m the

00:37:54.105,00:37:59.110
table if you can’t tell. And as
you’ll see these guys get fed up
and kill themselves. [laughter

00:38:03.982,00:38:08.987
in audience] Alright, thank you
very much guys. [Applause]

