00:00:00.133,00:00:05.138
>>Welcome to track 1 noon talk
this is uh Itzik Kotler and Amit
Klein. So please give ‘em a

00:00:10.444,00:00:15.449
welcome to DEFCON. [applause]
>>Thank you ladies and gentlemen
and uh welcome to the

00:00:24.958,00:00:30.998
presentation about uh process
injection techniques. Uh some
words about uh Itzik you can see

00:00:30.998,00:00:36.003
on the screen there. [cheers]
And also a few words about
myself [applause]. And let’s,

00:00:39.740,00:00:46.213
let’s begin. So why do we do-
why do we even care about uh
process injections. Uh so to f-

00:00:46.213,00:00:50.417
>>They can’t see the slides,
actually. >>They don’t see the
slides? >>Yeah. >>You have to

00:00:50.417,00:00:56.323
believe me on that. [laughter]
So- when we started res- uh
researching process injection

00:00:56.323,00:01:02.696
back in uh late 2018 uh we
obviously wanted to first
understand what other people

00:01:02.696,00:01:07.701
already did in this area and to
our surprise we couldn’t find
any comprehensive collection or

00:01:07.701,00:01:13.674
catalogue of process injection
techniques. We find credit all
over the internet in write ups

00:01:13.674,00:01:18.679
in proof of concept codes and in
uh blogs. Uh also we didn’t f-
we didn't find any, mm, we

00:01:21.682,00:01:26.687
didn’t find, ok, we did- we
couldn't find a text that
described uh the solely true

00:01:29.990,00:01:36.196
process injections as we like to
call them. And the text uh oft-
often uh took a bit of uh of a

00:01:36.196,00:01:41.568
liberal approach to what process
injection is uh and uh lumped
into process injection uh some

00:01:41.568,00:01:46.606
related but not true process
injection techniques like uh
process holding and spawning. Uh

00:01:46.606,00:01:53.013
also we couldn’t find uh uh
categorization around the the
sub- sub techniques of process

00:01:53.013,00:01:58.018
injection, mainly proc- memory
allocation, uh memory writing
and uh code execution. And also

00:02:00.520,00:02:05.525
we we there was a lack of
analysis and comparison between
process injection techniques. Um

00:02:08.362,00:02:14.267
finally uh we couldn’t find any
updates for the old uh uh
techniques that sometimes were

00:02:14.267,00:02:20.340
developed for in the Windows XP
days to uh Windows 10 uh with
its uh latest security uh

00:02:20.340,00:02:25.345
mechanisms and the 64 bit
architecture. Before we begin uh
I want to uh extend kudos to

00:02:28.915,00:02:35.822
Adam of Hexacorn, old Jaume and
the Insylo team, and Exceba
Fitzel of the also known as the

00:02:35.822,00:02:42.562
EvilBit and uh many others that
I have no uh no space here to
mention uh for their uh research

00:02:42.562,00:02:48.568
uh in their in their invention
in- inventions in process uh uh
uh in process injection

00:02:48.568,00:02:54.374
techniques uh, development,
documentation, and proof of
concepts uh in many of many many

00:02:54.374,00:02:59.346
techniques. And of course hat
tip to End Game for providing
the first compilation of

00:02:59.346,00:03:04.284
injection techniques although
that compilation uh did lump
together some non true process

00:03:04.284,00:03:11.258
injection techniques. So let us
first define what true process
injection is. Uh we’re talking

00:03:11.258,00:03:17.097
about injection from live user
space process uh typically
malware to another live user

00:03:17.097,00:03:21.701
space process which is the- the
target for injection which is
typically benign on a legitimate

00:03:21.701,00:03:27.641
process, it can be a system
process like Explorer DXC or
Microsoft Office uh process,

00:03:27.641,00:03:33.013
your browser, your messaging
software, your email software
what have you. Uh this is in

00:03:33.013,00:03:38.385
contrast to that which is out of
scope for this project uh
process spawning and hallowing

00:03:38.385,00:03:44.658
uh and also some pre execution
techniques that require uh the
uh malware to install or to

00:03:44.658,00:03:49.463
configure things before the
target process starts running
like DLL hijacking, upset,

00:03:49.463,00:03:54.468
opinate, LSP providers, and
image file executions.
>>[unclear off mic] >>[unclear]

00:04:06.813,00:04:11.818
Um so what’s what’s important
and interesting about Windows 10
and and about 64 bit

00:04:14.955,00:04:20.560
architecture? First uh Windows
10 introduced several security
mechanisms, such as uh CFG the

00:04:20.560,00:04:25.565
control flow guard uh which
prevents uh indirect c- calls to
non approved addresses. And uh

00:04:27.667,00:04:33.874
CIG the code integrity guard
which only allows modules or as
we call them DLLs to be loaded

00:04:33.874,00:04:38.879
if they are signed by Microsoft,
a Microsoft store, or WHQ- HQL.
Uh what’s interesting about the

00:04:41.248,00:04:47.020
64 bit architecture as opposed
to 32 bit architecture is that
to 64 bit architecture, the

00:04:47.020,00:04:52.025
calling convention is different.
Uh if the first 4 arguments of a
function are passed through it

00:04:54.161,00:04:59.166
uh uh 4 uh uh volatile registers
uh that would be uh RCX, RDX,
R8, and R9. So that if eh so

00:05:04.337,00:05:08.308
that in order to invoke a
successful invoke functioning
the target process you need to

00:05:08.308,00:05:13.880
control at least 1 or in in
depending on the number of
arguments in the function up to

00:05:13.880,00:05:18.018
4 registers as opposed to on- as
opposed to only uh cooking up
the stack which was uh the uh

00:05:18.018,00:05:23.023
uh- which was the way to invoke
functions in the 32 bit world.
Also in the 64 bit world there’s

00:05:28.428,00:05:33.433
no eh pop all registers eh in op
code. And that prevents us from
uh uh elegantly populating all

00:05:36.102,00:05:41.107
registers of uh desired values.
The proof- there- there are a
lot of proof good proof,

00:05:43.410,00:05:50.083
excellent proof of concepts out
there for uh uh injection
techniques uh but the problem is

00:05:50.083,00:05:55.655
that that is that exact
definition there. Excellent
proof of concepts uh in in that

00:05:55.655,00:06:02.562
uh what I mean is that the uh
prove- they handle- they they
have proper error handling and

00:06:02.562,00:06:07.567
exception handling. Uh they are
uh tailored for both 32 bit
applications and 64 bit

00:06:09.836,00:06:14.841
applications and they also lump
together uh in this case uh the
in- in the novel memory writing

00:06:18.278,00:06:24.417
technique with an execution
technique in order to
demonstrate uh a full end to end

00:06:24.417,00:06:29.422
uh process injection. And that
makes the uh source code uh ex-
uh blo- blow into 1500 lines of

00:06:33.426,00:06:40.133
code, I don’t know if you can
see that. Uh and I and as a
researcher I was I found it very

00:06:40.133,00:06:45.872
difficult to focus on exactly
what the novelty of the
technique is. Whereas what I

00:06:45.872,00:06:50.877
wanted to find or wanted what I
searched for uh is those those-
f- those 3 lines that are- that

00:06:53.213,00:06:58.918
are wrapped into 5 lines at the
right hand side of the screen
where you can see the exact uh

00:06:58.918,00:07:05.191
technique that is uh the exact
technique that is used in this
case it’s atom bombing. So what

00:07:05.191,00:07:10.196
I w- what uh uh what we could
not find uh in in many cases uh
uh is a concise 3, 4, 10 lines

00:07:15.468,00:07:22.142
of code that that that describe
exactly the technique and
nothing more. So we set out to

00:07:22.142,00:07:27.147
fix this uh situation and to
fill this gap uh and to document
all those uh process injection

00:07:29.215,00:07:35.121
techniques. Uh and the scope of
our project was uh true process
injection running a sequence of

00:07:35.121,00:07:40.694
logic core commands in the
target process so we’re not
talking about just uh forcing a

00:07:40.694,00:07:45.699
system uh function call, and and
spawning another process. Uh the
focus was on Windows 10 version

00:07:47.834,00:07:52.839
1803 and above so we’re talking
about uh pretty recent versions
of Windows 10. Uh X64 injection

00:07:55.975,00:08:00.914
injecting process and X64 target
process both medium integrity.
We only look at techniques that

00:08:02.916,00:08:08.688
do not require admin rights and
we evaluate all the techniques
against uh the recent Windows 10

00:08:08.688,00:08:13.693
protections, specifically CFG
and CIG. Few words about CFG
strategy, the attacker that

00:08:16.663,00:08:21.668
wants to uh inject into a CFG
protected target process has
several options uh to choose

00:08:24.337,00:08:29.776
from. The first 1 obviously is
to disable CFG and this is
possible for a standard Windows

00:08:29.776,00:08:35.982
API set process valid call
targets. Um however if you think
about it, this is a pretty

00:08:35.982,00:08:42.789
suspicious a- action in itself
and can be flagged by security
products. Also I uh speculate

00:08:42.789,00:08:47.560
that it may be disabled or
restricted in the future by
Microsoft. Another approach

00:08:47.560,00:08:53.733
would be to allocate or set
executable memory uh which uh as
a side effect makes all the

00:08:53.733,00:08:59.305
allocated uh memory CFG valid.
Uh this can be done with uh
VirtualAllocateEx or

00:08:59.305,00:09:04.310
VirtualProtectEx. But then again
if you think about it, this is
extremely suspicious, we all

00:09:04.310,00:09:09.282
know what happens next we just
allocated a bunch of executable
pages in the target process.

00:09:09.282,00:09:15.922
Obviously we know what’s going
to happen, so this is extremely
suspicious- suspicious. The

00:09:15.922,00:09:21.394
third option, and I think this
is the future of process
injection techniques is to play

00:09:21.394,00:09:27.367
by the rules that is writing in
non-executable data which is up-
can be a ROP chain and then

00:09:27.367,00:09:33.506
using a CFG agnostic execution
method to run the stack pivot
gadget and start running to

00:09:33.506,00:09:38.678
start executing the ROP chain.
Uh unfortunately or fortunately
depending on your point of view

00:09:38.678,00:09:45.251
only very few uh uh execution
techniques are CFG agnostic, and
uh we’ll touch on this subject

00:09:45.251,00:09:52.091
uh later in this presentation.
With respect to CIG and other
defenses, there used to be- uh

00:09:52.091,00:09:57.664
the there used to be a technique
to eliminate those defenses
using set process mitigation

00:09:57.664,00:10:03.503
policy in the target process
involving the ant- NTQueueAPC
thread because that function has

00:10:03.503,00:10:10.043
only 3 arguments uh that
NTQueueAPC thread could cover
them all, we’ll see that in a

00:10:10.043,00:10:16.216
later slide. However this
technique no longer works, as of
1809 uh and I want to mention

00:10:16.216,00:10:21.821
that CIG is most painful because
it prevents us from loading a
arbitrary, non-Microsoft signed

00:10:21.821,00:10:27.060
DLLs. So what are the typical
process injection building
blocks? We have memory

00:10:27.060,00:10:31.297
allocation and when we are- when
we are looking at uh such
techniques we need to uh

00:10:31.297,00:10:36.903
consider uh whether the
allocation is implicit, like a
cave or a stack or explicit

00:10:36.903,00:10:42.942
where we actually allocate the
memory ourselves. What page
permissions are there? What

00:10:42.942,00:10:48.848
control do we have over the
allocation address? And whether
the target addresses will be CFG

00:10:48.848,00:10:55.255
valid or not. Then we have
memory writing populating that
uh memory area with our desired

00:10:55.255,00:11:00.693
values. And the questions are
whether the d- whether a memory
writing technique allows us to

00:11:00.693,00:11:05.598
write arbitrary data or are
there restrictions on size or
character set? And whether the

00:11:05.598,00:11:11.004
writes are atomic or not.
Finally there’s the- there are
the execution techniques uh and

00:11:11.004,00:11:16.276
they need to be evaluated
against whether the target has
to be CFG valid or not what

00:11:16.276,00:11:21.314
controls do we have over the
registers, and what limitations
and pre- requisites are there

00:11:21.314,00:11:26.686
for the execution methods and
there are a lot of restrictions
and limitations for some

00:11:26.686,00:11:32.792
techniques out there. Without
much ado let’s go over some
process injection techniques.

00:11:32.792,00:11:38.965
I’m going to go over very
quickly the uh uh very known
ones and focus a bit more on the

00:11:38.965,00:11:45.405
lesser known ones. So I’m going
to uh go quickly now. Uh there’s
the virtual allocate ex uh

00:11:45.405,00:11:51.411
memory allocation technique that
we’re all familiar with, it can
allocate executable pages so

00:11:51.411,00:11:57.517
those pages become uh CFG valid
automatically by Windows and of
course we can uh on the- we can

00:11:57.517,00:12:03.256
allocated to just read write it
later uh at the uh at page
execute uh privileges with

00:12:03.256,00:12:08.261
VirtualProtectDX. Um then we
have the classic memory uh
writing technique call of using

00:12:10.964,00:12:15.935
write process memory, again no
prerequisites or limitations,
the address is fully controlled

00:12:15.935,00:12:21.608
uh with regard to CFG if the
allocation is- sets executable
privileges and there are no

00:12:21.608,00:12:27.647
problems. And CIG is of course
not uh relevant because we are
not handling DLLs here. And

00:12:27.647,00:12:32.685
finally there’s the create
remote thread execution
technique uh in which uh CIG has

00:12:32.685,00:12:38.191
no impact because we’re just,
we’re not talking about DLLs
here. And with respect to CFG

00:12:38.191,00:12:44.130
the target execution has to be
CFG vali- a valid target and
this is ver- val- this is

00:12:44.130,00:12:50.770
enforced by uh the operating
system. Uh we only have controls
over RCX so we can only safely

00:12:50.770,00:12:56.609
invoke functions of a single
argument in this way. Then we
have a classic DLL injection

00:12:56.609,00:13:01.714
execution technique using again
create remote thread but this
time assuming we will use the

00:13:01.714,00:13:07.020
writing technique to write the
DLL path into dat- target
process already. We invoke

00:13:07.020,00:13:11.958
create remote thread to- with-
we invoke load library A with
create remote thread and the

00:13:11.958,00:13:17.430
argument of load library- load
library A would be the t- the
path to the DLL already written

00:13:17.430,00:13:24.003
to the target process. Uh in
this case uh the prerequisite is
that the this DLL disk and uh

00:13:24.003,00:13:30.610
then please note that DLL main
disk is there what uh the loader
executes uh in such case is

00:13:30.610,00:13:37.417
restricted to the load of the
loader lock. CIG however blocks
this technique so it no longer

00:13:37.417,00:13:42.855
works if CIG is turned on in the
target process. And I’ve just
mentioned that the far end of

00:13:42.855,00:13:47.193
this technique can use
QueueUserAPC or NTQueueAPC
thread instead of create remote

00:13:47.193,00:13:53.566
thread. Uh another well known uh
classic execution DLL injection
technique is uh using

00:13:53.566,00:14:00.006
SetWindowsHookEx in which case
uh the DLL is loaded to the
target process when the target

00:14:00.006,00:14:04.944
process receives an event of a
certain kind. And uh after we s-
we s- uh invoke SetWindowsHookEx

00:14:08.081,00:14:13.086
uh we uh artificially send such
events to the target thread and
execution ensues. Again the

00:14:16.155,00:14:22.161
prerequisite is that the DLL is
on disk and again CIG blocks
this technique. Uh 1 other

00:14:22.161,00:14:27.166
classic uh execution technique
is APC you can use a
QueueUserAPC to send out a

00:14:29.235,00:14:35.541
Windows API or NTQueueAPC thread
which is an internal function a
more uh uh flexible function and

00:14:35.541,00:14:40.513
more useful 1. Now the
prerequisite here starts with-
starts getting interesting

00:14:40.513,00:14:44.117
because the thread must be in an
alertable state. I’ll talk
about- I’ll talk about that in

00:14:44.117,00:14:50.923
the next slide. CIG has no
impact, we’re not talking DLLs
here and their CFG uh is uh- is

00:14:50.923,00:14:56.162
uh- is relevant because the
target execution should be valid
CFG target again en- enforced by

00:14:56.162,00:15:01.100
Window- uh Windows D uh uh uh
wh- the execution time. Um
QueueUserAPC grants us control

00:15:04.403,00:15:10.777
over RCX. NTQueueAPCthread
grants us control over 2 and a
half registers, RCX, RDX, and

00:15:10.777,00:15:16.215
the lower half of R8. This can
be quite useful for fu-
functions that uh accept up to 3

00:15:16.215,00:15:22.855
arguments. Now what is an
alertable state? It means that
the- uh that the thread is

00:15:22.855,00:15:29.328
executing or is hanging in 1 of
5 functions SleepEx,
WaitForSingleObjectEx, et cetera

00:15:29.328,00:15:34.333
et cetera. And uh in in all 5
cases, it means that the actual
uh internal function execute uh

00:15:37.703,00:15:43.309
uh executed once the third is
hung is NTDelayExecution and
NTWaitForSingleObject and so

00:15:43.309,00:15:48.281
forth they all follow the same
pattern, they all follow the
same template of code, in which

00:15:48.281,00:15:53.219
case the RIP is in uh uh the
entry point, like
NTDelayExecution plu- plus x14

00:15:53.219,00:15:58.224
so therefore very easy to uh
discover what uh thread is in an
alertable state if you know its

00:16:00.893,00:16:05.898
RIP. So this is 1 handy uh uh s-
handy uh bi-product of our
research. Moving on to another

00:16:10.236,00:16:15.241
pretty known technique uh
there’s suspend inject uh resume
thread execution uh as the name

00:16:17.376,00:16:23.683
hints we suspend the thread and
then we set the RIP using set
thread context to our desired

00:16:23.683,00:16:27.954
execution l- location and then
we resume the thread; the thread
starts running in the new

00:16:27.954,00:16:32.959
location. Now with respect to
CFG, amazingly there’s no
impact. There- there’s no check

00:16:37.396,00:16:43.669
in- in Windows anywhere that
this is a uh a CFG valid uh
address because there’s it it it

00:16:43.669,00:16:49.842
it does not represent a callable
function in the first place. And
there is a bit of a restriction

00:16:49.842,00:16:56.282
on RSP. Should be within the
stack allocated region. Uh as
for control over registers

00:16:56.282,00:17:01.821
there’s no guaranteed control
over the volatile registers uh
this is a bit of a puzzle. As in

00:17:01.821,00:17:07.527
some processes uh we can control
those volatile registers, in
others we cannot, so we assume

00:17:07.527,00:17:13.733
the worst, we assume we cannot
control the volatile registers.
What if we on- can only write uh

00:17:13.733,00:17:20.339
read write memory, no execution
in the target process, well we
can use write primitive uh to

00:17:20.339,00:17:25.978
write uh ROP chain uh to the
target process and then uh set
the RIP to stack pivot and start

00:17:25.978,00:17:30.983
executing ROP chain for this
mechanism. Now here is uh an
exotic uh technique that’s uh

00:17:33.552,00:17:38.891
not too well known, it’s called
ghost-writing, I believe it
dates back to 2007 and its a

00:17:38.891,00:17:44.330
monolithic technique in the
sense that it carries out both
uh memory writing and execution

00:17:44.330,00:17:50.002
uh together. So it’s quite
similar to thread hijacking but
without the need for memory

00:17:50.002,00:17:56.375
writing uh uh primitive. The
idea here is that memory writing
is achieved in steps using

00:17:56.375,00:18:01.981
SetThreadContext to set the
regist- to set registers. And
that the each at at the end of

00:18:01.981,00:18:07.620
each step the thread is running
an infinite loop which will be
our success marker. Once the uh

00:18:07.620,00:18:13.759
the malware sees that the thread
is in uh in the- in its infinite
loop marker it knows that it’s

00:18:13.759,00:18:18.764
safe to move to the next step.
So we need 3 ROP gadgets for
this, uh a sink gadget which is

00:18:21.067,00:18:26.906
simple- simply an infinite loop
at JMP minus 2 which will be the
marker of a successful end of

00:18:26.906,00:18:31.911
execution. I believe it’s just 2
bytes of uh- of op codes. And
then we have a write gadget,

00:18:35.081,00:18:40.086
something like MOV into the uh
uh set by RDI the value for RBX
followed by return. And then a

00:18:43.923,00:18:50.629
stack pivot or something
equivalent. So the first step is
to write on stack the uh address

00:18:50.629,00:18:57.003
of the infinite loop, and the-
and and using the write gadget
and then finally the return from

00:18:57.003,00:19:02.141
the write gadget will branch
into the infinite loop. And uh
this will mark the successful

00:19:02.141,00:19:07.146
end of this step. Moving to we
write our arbitrary Q WORDS uh
so we repeatedly execute step 2

00:19:10.616,00:19:15.321
until we have all the memory
that we need uh written to the
target process, and the idea

00:19:15.321,00:19:20.326
here is to use the write to- to-
to start the registers uh and to
point at the write gadget so

00:19:22.428,00:19:27.433
that the write gadget will write
this QWORD and then it’s return
will branch right into the uh uh

00:19:29.769,00:19:36.242
infinite loop so marking the
successful end of writing a
single QWORD and repeating this

00:19:36.242,00:19:41.881
process as oft- as many times as
needed to write all the
arbitrary memory we need.

00:19:41.881,00:19:46.886
Finally we just set RIP and RSP
uh to desired values to start uh
uh uh um stack pivot to

00:19:49.221,00:19:54.226
something similar and to start
running over the ROP chain. 1 uh
1 lovely location for uh for uh

00:20:00.633,00:20:07.506
debut stack is the unused part
of the existing stack and here
are some tips of how to do this

00:20:07.506,00:20:13.012
right. Uh first you need to
maintain some distance from the
official top of stack the RSP

00:20:13.012,00:20:18.818
value in order to- to provide
some space for stack for natural
stack growing as- as it’s the

00:20:18.818,00:20:24.590
stack is used by Windows API
calls. But on the other hand you
can’t go too far because the

00:20:24.590,00:20:31.263
stack is limited by 1 megabyte
so some like 64 kilobytes is
probably in the in the ind- in

00:20:31.263,00:20:36.268
the right neighborhood. Now you
need to grow the stack s- uh uh
1 page at a time, 1 guard page

00:20:38.637,00:20:44.343
at a time in order to get from
the TOS to where you really want
to start writing your own stack

00:20:44.343,00:20:50.716
and you do that by touching the
memory at page size intervals so
that the the uh the guard page

00:20:50.716,00:20:57.423
would will keep uh uh will will
so the uh kernel will- will keep
committing new pages uh as as as

00:20:57.423,00:21:02.995
we follow this algorithm.
Finally you need to mind the
stack alignment which is set to

00:21:02.995,00:21:08.000
16 bytes and it’s uh really uh
observed by some functions. So
the the prerequisites from ghost

00:21:10.035,00:21:16.809
writing is simply just the place
where you can we can write some
some data. There’s no impact

00:21:16.809,00:21:23.215
from CFG except wha- what we
already know about RSP now of
course no impact uh by from CIG

00:21:23.215,00:21:27.686
because there's- there are no
DLLs involved and we have
control over some registers

00:21:27.686,00:21:31.824
which is nice. Now moving to um
shared memory writing technique
uh in this case, the

00:21:31.824,00:21:33.826
prerequisite is that we know
that the uh target process uh
has a shared memory section, we

00:21:33.826,00:21:35.828
know its name and we know its
size. And now it’s pretty uh
predictable if we know the exact

00:21:35.828,00:21:37.830
software that we are targeting
and- and it’s build we know
whether there are uh uh sh-

00:21:37.830,00:21:39.832
whether it uses shared memory
and and affords size. So this is
uh, we assume that this

00:21:39.832,00:21:42.434
knowledge is available to the
attacker. So the attacker first
maps this uh shared memory to

00:21:42.434,00:21:47.439
its own process, writes the
payload at the end of this uh
shared memory, hopefully it’s an

00:21:58.751,00:22:03.689
area not used by the legitimate
software. And then uh opens the
target process uh and starts

00:22:16.001,00:22:21.407
looking for uh scanning its
memory uh region by region
trying to find the region that

00:22:21.407,00:22:26.412
matches the attributes of the
shared memory uh uh section. And
this um so we are comparing,

00:22:29.715,00:22:35.521
we’re looking for map- mapped
memory, map committed uh of page
read write attributes and the

00:22:35.521,00:22:41.794
exact uh size that we expect the
shared memory to have. Once we
find we’ll also do a read memory

00:22:41.794,00:22:46.832
to make sure that the payload is
at the at the end of the shared
memory, and once we know that we

00:22:46.832,00:22:52.538
can start using this as memory
written to the pro- to the
target process. Uh so the

00:22:52.538,00:22:57.243
prerequisites obviously is that
the target process has a read
write shared memory and that the

00:22:57.243,00:23:02.715
attacker knows the name and the
size. Uh with respect to CFG
this is probably irrelevant

00:23:02.715,00:23:07.686
because this memory is typically
uh read and write only, not
executable. And CIG of course is

00:23:07.686,00:23:12.691
irrelevant. Now we move to the
atom bombing writing technique.
So naively speaking assuming the

00:23:15.394,00:23:21.433
payload is small and it has
contains no null bytes and
except for terminating null byte

00:23:21.433,00:23:27.840
uh what we have here is uh uh uh
the essence of this uh writing
technique. We define a global uh

00:23:27.840,00:23:32.845
uh an atom object in Windows
that uh contains this payload
for in this in the malware

00:23:35.547,00:23:42.421
process in the injecting process
and then we use NTQueueAPC
thread uh to invoke the function

00:23:42.421,00:23:47.426
Get- GlobalGetAtomNameA in the
target uh process asking it to
copy the value of the atom that

00:23:50.929,00:23:55.934
we just created uh into the
designated address. Now uh this
is uh pretty uh pretty neat. The

00:23:59.972,00:24:05.944
original paper uh doesn’t write-
doesn’t uh provide uh uh-
doesn’t support writing null

00:24:05.944,00:24:11.016
bytes. It simply assumes that a
MemTargetMemory zeroed out which
is the case because they chose

00:24:11.016,00:24:17.690
to use a code cave. Uh we
devised a technique to write
null bytes and it’s- it’s in our

00:24:17.690,00:24:23.329
paper. The prerequisites are
again that the thread must be in
an alertable state and that the

00:24:23.329,00:24:28.600
target payload is allocated and
writable. As for CFG and CIG
there’s no impact of course, um.

00:24:28.600,00:24:33.605
And then we have another uh
interesting uh allocation and
writing technique combined. Uh

00:24:39.111,00:24:44.116
using NTMapViewOfSection. Uh in
this case, the uh malware
process forces uh a section to

00:24:48.620,00:24:54.760
be mapped in the target process.
It does so by first uh defining
a section, populating it with

00:24:54.760,00:25:00.666
the desired values and then uh
opening the target process and
uh do- doing- running

00:25:00.666,00:25:06.805
NTMapViewOfSection of the target
process uh of this uh section
into the target process, it’s uh

00:25:06.805,00:25:11.810
uh and it can also control the
uh uh page attributes. You can
uh ask for executable uh and

00:25:14.279,00:25:19.852
read execute and read write. So
this cannot be used for already
allocated memory, so for

00:25:19.852,00:25:26.058
example, we cannot write values
on the stack using this
technique. Uh and uh the- the

00:25:26.058,00:25:31.063
nice thing is the- CFG wise is
that Windows wants because we
requested the page executable

00:25:33.198,00:25:38.203
Windows will- will mark the
whole region as uh CFG valid. Um
this is uh a quite fascinating

00:25:43.709,00:25:48.714
execution technique, the Unmap
plus rewrite, and it works like
this. We- we look at a DLL used

00:25:52.384,00:25:57.389
heavily in the target process
NTDLL is of course a prime
choice. And then we first copy

00:25:59.458,00:26:01.393
all the region of this DLL into
our own process. Uh we suspend
the targets of uh first we

00:26:01.393,00:26:03.395
suspend the process then we copy
the existing NTDLL en- entire
module space into our process,

00:26:03.395,00:26:05.397
we’ll make a copy of it. We
patch it- this copy locally for
example we can uh uh patch NT-

00:26:05.397,00:26:10.402
NTclose which is heavily used
function. And then uh we unmap
the original NTDLL section from

00:26:15.908,00:26:20.913
the target process, and use any
uh writing- allocation and
writing technique to map and and

00:26:41.967,00:26:46.972
write the uh the the patch the
patch to NTDLL copy uh back to
where the original NTDLL uh used

00:26:52.411,00:26:58.450
to reside in the target process
memory. And finally we flash the
instructions from the CPU so

00:26:58.450,00:27:03.322
that it will not- it will forget
everything it knows- it- it
thought it knew about those uh

00:27:03.322,00:27:08.327
addresses um and we resume the
process. Now this is uh quite
elegant. And of course with-

00:27:14.066,00:27:19.071
with respect to CFG it’s a bit
tricky because there are many
old entry f- and older entry uh

00:27:22.741,00:27:27.746
uh uh lo- addresses in NTDLL
must be also uh be CFG valid uh
now after this uh switch. Uh

00:27:32.417,00:27:39.157
however fortunately when using
NTMapViewOfSection and
VirtualAlloc- AllocEx uh it is

00:27:39.157,00:27:45.864
guaranteed- guaranteed that
Windows sets the whole region in
fact to be uh CFG valid so this

00:27:45.864,00:27:50.869
is taken care of. Um and there
are some uh tips res- regarding
how not to destabilize the

00:27:53.739,00:27:58.410
process uh first we need of
course to do a process wide
suspend because we can’t know

00:27:58.410,00:28:04.950
which thread will use uh NTDLL
and when. And then the whole
thing about copying the complete

00:28:04.950,00:28:09.955
NTDLL memory and then uh copying
it back instead of just say uh
uh copying parts of NTDLL is

00:28:13.959,00:28:18.964
because we need to make sure
that some uh variables inside
the NT- the NTDLL space are

00:28:22.501,00:28:28.440
consistent and if we just copy
code and not the uh some uh uh
variables that are part of the

00:28:28.440,00:28:33.078
uh static variables et cetera
that are part of NTDLL we’re
bound to get in into

00:28:33.078,00:28:38.083
inconsistency which will
immediately crash the process.
So if you do that, copy the

00:28:40.118,00:28:45.123
whole region. Uh there’s a bunch
of uh callback override
execution techniques uh that uh

00:28:50.329,00:28:57.235
operate under the same uh
concept that we have uh set,
things from GetWindowLongPTR to

00:28:57.235,00:29:03.408
uh shatter-like uh functions uh
uh techniques though ALPC
control injects et cetera. The

00:29:03.408,00:29:08.880
idea is that uh we write the- we
write some code into the target
process using any writing

00:29:08.880,00:29:13.385
technique then we try to obtain
the memory uh so- uh object with
the virtual table, callback uh

00:29:13.385,00:29:15.387
table, uh this may be tricky
because uh it’s not uh not all
processes have all objects like

00:29:15.387,00:29:17.389
ALPC or con- some sometimes-
some objects only uh exist in
console applications, some

00:29:17.389,00:29:19.391
objects only exist if the uh
application has a uh private
clip board. And this finding or

00:29:19.391,00:29:21.393
obtaining uh can be done via a
standard API like
GetWindowLongPtr or via memory

00:29:21.393,00:29:23.395
search like uh as is the case
with ALPC. Then we replace this
object or callback uh to point

00:29:23.395,00:29:28.400
at our uh desired execution
point which must be CFG value
target because Windows will

00:29:38.477,00:29:43.482
check each and every of those uh
uh execution techniques in each
of every 1 of them, CFG is is

00:29:59.698,00:30:05.704
checked. And it may also require
some adjustments to the object
and to- to the code. We trigger

00:30:05.704,00:30:11.109
execution which may be tricky
because some uh techniques are
not uh uh deterministic and we

00:30:11.109,00:30:16.114
cannot really force uh the
execution uh on- upon them. And
finally we restore the original

00:30:18.450,00:30:24.389
object in callback so the
process can resume normally. Uh
this is an example a control

00:30:24.389,00:30:29.394
inject uh in which uh we uh
encode pointer to our desired
address, and then we copy this

00:30:32.831,00:30:37.836
pointer uh to where to the
control C uh handler in the
target process which is uh taken

00:30:40.172,00:30:46.645
the address of the kernel based
uh single handler. And finally
we trigger execution by uh first

00:30:46.645,00:30:51.650
uh simulating pressing the
control key using send input and
then uh sending the C character

00:30:55.020,00:31:01.026
to the target process. Now we
move to a nice technique that we
developed uh we uh a nice

00:31:01.026,00:31:07.799
writing technique we developed
uh based on memset and memmove
in which uh the idea is that we

00:31:07.799,00:31:13.805
write uh arbitrary data to the
process uh a byte- byte at a
time. And we use

00:31:13.805,00:31:18.810
NTQueueAPCThread uh with uh the
target function invoked being
memset, this is a classic uh

00:31:21.680,00:31:27.018
NTDLL function so it- it’s-
there’s- there are no CFG
problems here. And since memset

00:31:27.018,00:31:32.224
takes 3 arguments, the
destination address, the byte to
write, and how many copies, we

00:31:32.224,00:31:39.197
simply use it with the address
we desire, the byte we desire,
and the uh constant 1. And we

00:31:39.197,00:31:45.704
can look through our buffer and
copy to the destination address.
Uh by the way Alon Weinberg will

00:31:45.704,00:31:51.610
be presenting here at today at
4pm I believe dev- developed a
similar uh technique. The

00:31:51.610,00:31:57.983
prerequisites are that the
thread must be in an alertable
state, we already discussed

00:31:57.983,00:32:02.921
that. And CFG is not affected
because as I mentioned NTDLL
memset is CFG valid. Finally

00:32:05.323,00:32:11.363
there’s this the execution
technique we developed we call
stack-bombing. Uh in this case

00:32:11.363,00:32:16.368
uh the idea here is that we over
ride uh it’s a single uh return
address on stack to point at our

00:32:19.237,00:32:25.544
desired uh destination address.
Now if the thread happens to be
in an alertable state, it

00:32:25.544,00:32:30.549
becomes pretty simple. The code
for uh an alaertable- a classic
alertable state internal

00:32:30.549,00:32:36.354
function is this as I said uh
the the code the the thread is
hanging right after syscall at

00:32:36.354,00:32:42.761
uh uh at M2 point plus x14. And
as you can see what will happen
next is an immediate return

00:32:42.761,00:32:49.201
without touching the stack or
the registers, so that if we
modified the the value pointed

00:32:49.201,00:32:55.373
to the value on stack pointed to
by RSP, we are bound to get
execution. Of course the

00:32:55.373,00:33:00.312
implementation is much more uh
sophisticated and complex, there
is a- a nice proof of concept uh

00:33:02.480,00:33:07.485
in our paper and in our uh uh
Git uh repository. Uh and uh eh
the- beauty of this uh technique

00:33:11.556,00:33:16.561
is that uh there is no impact on
CFG uh so we can use ROP chain
and start executing even if CFG

00:33:21.733,00:33:28.673
is enabled in the uh in the
target process. There are 2
techniques that we could not uh

00:33:28.673,00:33:34.379
make uh we could not implement
uh successfully for Windows 10.
The SetWinEventHook and the

00:33:34.379,00:33:40.852
Desktop Heap technique. If you
manage to run them on Windows 10
x 64 version 1903, please please

00:33:40.852,00:33:45.857
contact us, we will be delighted
to know. To summarize, we looked
at 6 uh sorry 5 writing

00:33:49.027,00:33:55.333
techniques and you can c- see
the comparison here and in our
paper. We also looked at over 20

00:33:55.333,00:34:00.739
execution techniques and uh you
will see that uh tech-
techniques that are CFG

00:34:00.739,00:34:06.678
agnostics marked in the yellow
uh at the uh right hand side
column are pretty rare. There

00:34:06.678,00:34:11.683
are uh, 1 2, 3 and ours is the
fourth. And uh we believe this
is the future of process

00:34:15.153,00:34:20.158
injection. Uh uh quick bonus if
you need to load a DLL in- a
system DLL into an arbitrary

00:34:22.794,00:34:29.734
process maybe and you don’t have
a writing technique to write its
path uh into the process first,

00:34:29.734,00:34:35.340
maybe your whole ROP ga- maybe
your favorite ROP gadget is
there, uh we have good news for

00:34:35.340,00:34:40.345
you. Kernel based DLL contains
the names of uh more than 1,000
system DLLs including some

00:34:42.914,00:34:49.287
things like SendMessageDLL,
Shell 32 dot DLL, and
[inaudible] dot DLL, and you can

00:34:49.287,00:34:54.292
use that uh to load this uh the
DLL using load library yay. And
with that I hand it over to you,

00:34:56.995,00:35:03.702
Itzik. >>Thank you Amit.
[coughs] As Amit mentioned, our
research was not only theory,

00:35:03.702,00:35:08.173
there’s also the practical
implementation side of it. And
as we went through in scraping

00:35:08.173,00:35:13.011
different proof of concept
trying to compile together, we
decided to take it to the next

00:35:13.011,00:35:18.483
level and create PINJECTRA. So
in a nut shell, PINJECTRA is a
framework that allows you to

00:35:18.483,00:35:23.688
combine, mix and match,
different elements uh as Amit
presented, writing and

00:35:23.688,00:35:28.460
execution, and obviously the
payload in the mix and match
style. And we’re gonna see it in

00:35:28.460,00:35:35.433
the next few slides, feel free
to go to the GitHub right now
and download your copy. Ok so

00:35:35.433,00:35:39.604
once you go to the GitHub you
will see that the PINJECTRA
solution is basically made from

00:35:39.604,00:35:45.477
4 major projects. As Amit
mentioned, some of the injection
techniques require some artifact

00:35:45.477,00:35:50.815
DLL. We already provided it for
you. So the first 2 projects
here are DLLs that are

00:35:50.815,00:35:56.654
implementing certain interfaces
so they can be easily used for
the purpose of the injection.

00:35:56.654,00:36:01.026
The other 2 is the PINJECTRA
itself which contains the
library of the knowledge, as

00:36:01.026,00:36:06.031
well as the implementation and
also for your convenience we
also released a test process.

00:36:06.031,00:36:10.735
This is a dummy program that
puts itself into an alertable
state, as Amit mentioned it’s a

00:36:10.735,00:36:16.274
prerequisite for certain attack
techniques, and so this will do
the job for you. Now let’s step

00:36:16.274,00:36:19.878
a little bit outside and
understand what’s the
philosophy. As I mentioned,

00:36:19.878,00:36:25.683
PINJECTRA is a mix and match
it’s using obligatory ended so
we leverage the CC plus plus

00:36:25.683,00:36:31.222
static type system to create
different classes from different
types and so it’s very easily

00:36:31.222,00:36:37.062
kind of mixing together into a
full attack. And how does it
looks like? Pretty much like

00:36:37.062,00:36:42.300
that. So what you can see right
now is the implementation of our
new technique; the stack bombing

00:36:42.300,00:36:47.305
in PINJECTRA. It’s very easy,
it’s very clean, it’s very
elegant. Looking on 3 major

00:36:47.305,00:36:53.311
classes here. The first 1 code
via which provides the actual
execution, so that’s a class of

00:36:53.311,00:36:59.317
an execution technique. Then we
can see the NTQueueAPCThread,
it’s the writing technique and

00:36:59.317,00:37:04.055
then at the end, we can see the
ROP chain, that’s class
representing of the payload. The

00:37:04.055,00:37:08.393
mix and match philosophy means
that you can now play and try
different techniques, different

00:37:08.393,00:37:13.398
primitives, and see how they can
combine together. You can
obviously create a new 1 and

00:37:13.398,00:37:19.270
then explore different avenues.
And now all this wrapped up in a
very nice model, at the end of

00:37:19.270,00:37:21.739
it there is a method for this
class called Inject that ex-
expects the process ID and

00:37:21.739,00:37:23.741
thread ID and there you have it.
And now let’s go into a demo.
No. Some technical difficulties.

00:37:23.741,00:37:25.743
Ok. Ok. So what you can see here
is 2 CMD consoles, there’s a red
1 which will be the attacker and

00:37:25.743,00:37:27.745
the green 1 which will be the
attackee or the victim. So right
now we’re first going to run the

00:37:27.745,00:37:32.750
test process. Again as I
mentioned, that the purpose of
that was to be the victim of the

00:38:11.089,00:38:16.094
process injection. As you can
see running it will conveniently
bring to the process ID thread

00:38:22.500,00:38:27.505
ID as well as will put it into
an alertable state. Going into
the PINJECTRA we will run it

00:38:30.708,00:38:35.780
once without any parameters,
that will give us the usage for
the different attacks that are

00:38:35.780,00:38:40.785
possible within the demo. Now
finding the right combination
with the process ID and thread

00:38:44.122,00:38:50.428
ID will invoke the actual
injection. In our payload by
default we’re using a very nifty

00:38:50.428,00:38:55.833
hello box word so that’s- that’s
a process that you will have if
you have a successful injection

00:38:55.833,00:39:00.772
using PINJECTRA right now. Ok
and as a bonus uh which we’ve
seen for the last second there,

00:39:04.442,00:39:09.747
the process itself continues to
run as uninterruptibly. So again
the process doesn’t crash, it

00:39:09.747,00:39:14.719
keeps running. Moving on to a
few other techniques that Amit
has mentioned and how they have

00:39:14.719,00:39:18.723
been- how they can be
implemented within PINJECTRA,
here’s the ghost writing

00:39:18.723,00:39:23.728
technique. So as you can see
we’re using conceptually the
suspend inject resume design

00:39:23.728,00:39:28.933
pathway not to be confused with
the set thread context technique
that Amit has presented for the

00:39:28.933,00:39:34.439
classical seer. Then we have the
ghost writing as the actual
writing primitive and then that

00:39:34.439,00:39:40.778
accepts the payload. So again a
pretty fairly simple way to
combine different techniques in

00:39:40.778,00:39:45.783
to 1 fusion process. So let’s
check this demo as well. Ok so
the same idea applies. We’re

00:40:00.865,00:40:05.870
creating the green process to be
injected to, and then we’re
going into PINJECTRA again

00:40:09.607,00:40:13.378
running it without any
parameters we will see the
different usage that contains

00:40:13.378,00:40:18.383
the different options. Giving it
the process ID and thread ID.
And we got the box. [applause]

00:40:26.391,00:40:31.396
Thank you. [unclear off mic] Ok
uh again continuing with the
series of demos that we have

00:40:35.900,00:40:40.905
planned for you today, as Amit
mentioned the uh very exotic and
uh interesting technique of the

00:40:45.410,00:40:51.516
unmap in map which includes many
different steps in the way again
with PINJECTRA can be broken

00:40:51.516,00:40:56.821
down into these 3 different
classes for the people here that
were uh keeping notes on the

00:40:56.821,00:41:02.894
actual class names, you can see
that the code via pinject resume
underscore complex was already

00:41:02.894,00:41:07.265
actually used in our own
implementation of the stack
bombing. This is just 1 of the

00:41:07.265,00:41:13.538
features of using this library
is the ability to reuse existing
code and logic. And so we do not

00:41:13.538,00:41:18.910
have to reimplement the uh
conceptual execution technique,
we can then just focus on the

00:41:18.910,00:41:25.750
create file mapping, map file,
map view file, NtUnmap and map
of the- of the section. This is

00:41:25.750,00:41:31.689
the combination that essentially
identifies these techniques. And
of course the payload that has

00:41:31.689,00:41:36.694
been accepted as the payload
comes on top of it. Ok. Hmm. K.
Oh yeah. Ok. Uh. So the idea

00:41:57.582,00:42:03.254
again is we’re creating a- a
green process and a red process.
In this case as Amit mentioned

00:42:03.254,00:42:08.025
our test process was not
complicated enough to include
all the different uh results and

00:42:08.025,00:42:13.698
APIs and so basically we also
provided this very small batch
file to simply return the uh

00:42:13.698,00:42:19.804
peet of the explorer. So in this
case we are going to actually
attack explorer itself. So that

00:42:19.804,00:42:25.877
gave us back the PAD of the
explorer process and now going
to PINJECTRA we’re going to use

00:42:25.877,00:42:30.882
that as the destination of the
process injection. Takes a
little bit of a time. And here

00:42:40.558,00:42:45.563
it is. [applause] Ok uh the set
window long pointer is quite an
interesting implementation as

00:42:52.170,00:42:56.007
Amit mentioned we need to
retrieve the actual structure
and then change the callback

00:42:56.007,00:43:00.611
within it. So for here it’s
actually a mixture of an
execution technique which stands

00:43:00.611,00:43:05.983
on it’s own that’s the code via
set window long PTR, and then
what we actually did is uh

00:43:05.983,00:43:09.987
within the framework we refactor
1 of the most primitive
techniques which is a

00:43:09.987,00:43:15.693
combination of virtual uh
allocation in write memory in
conjunction with a payload. And

00:43:15.693,00:43:20.231
the connector that actually
brings them together is a
metadata that calls complex to

00:43:20.231,00:43:24.035
mutable advanced memory writer.
As you will dive into the
framework, you will see there is

00:43:24.035,00:43:28.739
different types of classes to
accommodate different types of
attacks that is actually a

00:43:28.739,00:43:33.744
converter that we created for
the purpose of this attack. So
let’s jump into the demo. It’s

00:43:40.485,00:43:45.556
important to mention that since
this attack requires retrieval
of a specific structure, it’s

00:43:45.556,00:43:51.095
much easier to find to implement
the discovery of finding of
explorer within the attack

00:43:51.095,00:43:55.099
itself and that’s what you’re
going to see right now. So
there’s not gonna be any green

00:43:55.099,00:44:00.037
screen right now, it’s all only
be contained within PINJECTRA.
So we’ll pass 0 0 as an

00:44:03.374,00:44:09.013
indication that again PINJECTRA
made it will come out with the
PAD and DAD of explorer while

00:44:09.013,00:44:14.018
using the set long window PTR
API. And here it is. [applause]
Ok and last but not least let’s

00:44:23.461,00:44:26.931
now talk about the atom bombing
technique and how it’s
implemented again within

00:44:26.931,00:44:33.137
PINJECTRA. As you can see the uh
QueueUserAPC is uses the code
execution technique and then the

00:44:33.137,00:44:38.910
sequence of open thread, open
process, virtual allocate, and
global add atom A are the actual

00:44:38.910,00:44:43.214
writing sequence. And again you
can see you can control the
different parameters and you can

00:44:43.214,00:44:47.418
control the function that
returns the payload and having
said that, let’s see how it

00:44:47.418,00:44:52.423
looks on our platform. K. So
here again we will be using the
peet of the actual explorer to

00:45:04.702,00:45:11.609
perform the actual uh testing.
Again we need a- a much complex
process providing the PAD and

00:45:11.609,00:45:16.614
DAD of explorer. Takes uh a
second there and boom.
[applause] Ex- excellent, thank

00:45:24.789,00:45:29.794
you. And with that, back to
Amit. >>Thank you Itzik. So what
have we seen today? Uh we have

00:45:33.364,00:45:39.303
we we have actually 3
deliverables you know for our
project. 1 is a mapping of a

00:45:39.303,00:45:44.842
vast territory of true process
injection. And together with
that we provide an analysis and

00:45:44.842,00:45:50.481
comparison, it’s all in a single
collection, repository,
compendium, however way you like

00:45:50.481,00:45:55.486
to call it. Uh it’s part of the
DEFCON uh deliverables uh from
our site which so it’s a PDF uh

00:45:58.990,00:46:05.496
document. Uh for your uh
enjoyment and pleasure. It’s
also uh on our website. We also

00:46:05.496,00:46:12.236
provide this uh library that uh
Itzik uh demonstrated called uh
PINJECTRA for a mix and match

00:46:12.236,00:46:16.374
generation of uh process
injection attacks. Now this is
extremely important because a

00:46:16.374,00:46:21.379
lot of the POCs out there will a
couple a single uh new say
memory writing technique like in

00:46:23.914,00:46:29.020
atom bombing with a single
execution technique just to
demonstrate that. And this

00:46:29.020,00:46:34.025
becomes the atom bombing process
injection, eh technique so if
you’re if you want to test

00:46:36.894,00:46:43.367
you’re environment against or
your system against uh atom
bombing, you may as well test

00:46:43.367,00:46:49.373
that with not just a single
execution technique but uh uh
all the area of possible

00:46:49.373,00:46:54.912
execution techniques that- that
can be coupled to- to atom
bombing. And that’s exactly what

00:46:54.912,00:47:00.785
we provide with PINJECTRA, the
ability to couple or to match
any, almost any writing

00:47:00.785,00:47:05.489
technique with almost any
execution technique, and thereby
we allow uh red teamers, blue

00:47:05.489,00:47:11.328
teamers, say uh security
researchers to cover almost all
the possible- all possible uh

00:47:11.328,00:47:16.333
combinations in this uh in this
uh universe. Finally, we also
describe a new CFG agnostic

00:47:19.136,00:47:24.108
execution technique and I remind
you that this- I- I believe that
this is the future of process

00:47:24.108,00:47:29.914
injections. The- the ones that
are based on uh uh CFG agnostic
execution techniques which we

00:47:29.914,00:47:34.919
call stack bombing. And we then
and coupled with that we also uh
uh disc- we also uh uh-

00:47:36.987,00:47:43.494
described a new memory technique
using a memset and memmove over
APC. So that’s our 3

00:47:43.494,00:47:48.499
deliverables. Thank you very
much, ladies and gentlemen.
[applause]

