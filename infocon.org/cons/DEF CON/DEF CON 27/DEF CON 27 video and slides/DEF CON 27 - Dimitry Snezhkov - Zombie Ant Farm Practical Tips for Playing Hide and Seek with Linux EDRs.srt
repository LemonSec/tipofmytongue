00:00:00.200,00:00:05.672
>>So next, um Im gonna make the
same joke I did earlier, don’t
care. Um how many people use

00:00:05.672,00:00:10.677
antivirus at work? [audience
laughs] How many people think
that antivirus is worth a shit?

00:00:13.914,00:00:18.919
Oh man [audience laughs] CISSP
over here [audience laughs] How
many people have said well I've

00:00:20.988,00:00:27.628
solved this problem I'll get an
EDR, yeah? How many people think
that EDR's are worth a shit?

00:00:27.628,00:00:32.599
Ahhhh sucker! Time to learn
about how EDR's may not be as
effective as you think they are.

00:00:36.770,00:00:43.610
Let's give Nomad a big round of
applause. [audience applauds]
Have a great time man. >>Thank

00:00:43.610,00:00:49.182
you I appreciate it. Hello
DEFCON [cheers from audience]
and today we are going to well,

00:00:49.182,00:00:54.187
my name is Dimitry Snezhkov and
um couple of words about what i
do and who i am, just because it

00:00:56.423,00:01:01.895
is applicable to our talk. Um
red team operator, helped my
team execute the testing at

00:01:01.895,00:01:06.900
first, um sometimes create
tools, sometimes release them.
And so because this talk is

00:01:09.236,00:01:14.241
going to be from the perspective
of red team operator, um I want
to set some stage before we go

00:01:16.476,00:01:22.916
and dive into details. Um I
think that Linux matters, I
think they run payloads on cloud

00:01:22.916,00:01:28.488
and elsewhere. And I do think
that uh attack and offense
actually tries to get there as

00:01:28.488,00:01:33.493
fast as the they can bypassing
office networks dropping there
thru applications and I do think

00:01:36.763,00:01:42.302
that the defense follows the
attack and as such we start
seeing as operators, we start

00:01:42.302,00:01:49.176
seeing a lot of presence of EDR
on Linux. And so what is EDR's
-Endpoint Detection Response-

00:01:49.176,00:01:54.181
right? And we as operators are
suppose to kinda respond to that
by trust us in them and see what

00:01:57.317,00:02:02.255
they can do. So its a story
right? it's a story of us
getting onto the Linux box time

00:02:05.359,00:02:12.332
and time again and being caught
15 minutes, 10 minutes. What
happened? 2-3 years ago it

00:02:12.332,00:02:17.371
wasn't the case we knew exactly
what we are doing there, now
there is this fancy thing called

00:02:17.371,00:02:22.376
the EDR but we can't really
define what it is. Is it a pure
play EDR product?, is it a side

00:02:25.612,00:02:30.617
gig for whitelisting
applications?, is it a DLP?
Perhaps its, maybe some home

00:02:33.020,00:02:38.025
grown scripts right? that catch
us or some form of other manual
or tool assisted thread Hunting.

00:02:41.194,00:02:47.567
And so when we drop thru the box
we do not know what it is. On
top of that we have to address

00:02:47.567,00:02:53.206
initial foothold, let's say our
exploit worked, we got there but
so what do we do? How do we

00:02:53.206,00:02:58.211
maintain presence there? Our
activities may be logged,
supervised, right? We need to

00:03:00.614,00:03:06.119
stay there for a while, it's not
a 15 minute job to establish a
foothold and basically

00:03:06.119,00:03:12.325
compromise anything else in that
network. We have to persist,
while we are doing it we are

00:03:12.325,00:03:17.898
supposed to evade automation
that is definitely watching over
our actions, and maybe even

00:03:17.898,00:03:22.903
deflect the artifacts that were
brought in, into that
environment. On top of that we

00:03:25.539,00:03:30.544
may be in a position that we are
in quiet boxes and defense
actually knows what they run.

00:03:32.579,00:03:37.584
White listed binaries, processes
are quite. Right?, so we are the
anomaly. There are 2 sort of

00:03:41.922,00:03:48.228
ways of uh tackling our issues
strategically right? Is an
operational evasion where we

00:03:48.228,00:03:54.334
shut down the EDR, blind it in a
way you know, maybe we are
confusing it from the

00:03:54.334,00:03:58.972
operational perspective, and you
guys really need to check out
the talk that Teams and then

00:03:58.972,00:04:04.978
R00tkiller has done this morning
for that. Here we are going to
take a look at the behavioral

00:04:04.978,00:04:11.084
evasion. Right? So what does
that mean? We are going to try
to take the execution of our

00:04:11.084,00:04:16.022
programs and we are going to
confuse EDR's from that
standpoint. We are gonna try to

00:04:16.022,00:04:21.027
bypass them from behavior of our
uh cradle, payload, push trap
whatever the case maybe that we

00:04:24.331,00:04:29.136
are gonna talk about. And then
we are also going to try to
deflect that artifact discovery

00:04:29.136,00:04:36.009
that we've been talking about.
Alright so what are the
objectives strategically, well

00:04:36.009,00:04:38.111
we know we need to um we need to
avoid detection at run time,
thats thats a given, right?

00:04:38.111,00:04:40.113
Somehow we need to serve their
payloa our payload in such a way
that they are either

00:04:40.113,00:04:42.115
undetectable or maybe easily
sort of umm, you know, ther they
are created in such a way that

00:04:42.115,00:04:47.120
the EDR doesn't know what to do
with it. Strategically there are
3 choices, we can drop our our

00:05:00.734,00:05:06.606
our tools right in a box, but
that may not work because they
may detect our our our programs

00:05:06.606,00:05:11.244
are malicious payloads right
there . We are going to start
developing offensive tools right

00:05:11.244,00:05:15.916
on the box but then we have to
make sure that we have the
development facilities ,We have

00:05:15.916,00:05:22.756
to have compilers, maybe we can
have some tools on the box
themselves to compile all that.

00:05:22.756,00:05:27.761
Also not ideal. And the 3rd
choice is full of living of the
land, utilization right? We take

00:05:30.430,00:05:35.969
what we are given and try to
work with it, but then again, we
do not know where we are, how

00:05:35.969,00:05:41.975
quiet the box is, what is
whitelisted. Are we going to
find what we can rely on to

00:05:41.975,00:05:46.980
extend and maintain our
foothold? And so maybe there is
a way to do an Assembled Attack,

00:05:49.115,00:05:54.120
right? It's a blended approach
that has a couple of ideas.
First idea maybe we can bring in

00:05:57.724,00:06:04.297
small malware cradles, they are
not malicious in nature they are
just bush strip code that gets

00:06:04.297,00:06:09.302
loaded with malicious code at
run time. As it runs. And so
EDR's they are building the

00:06:11.371,00:06:17.544
story of consistent execution of
a program, is not going to be
able to do that, or maybe we can

00:06:17.544,00:06:22.449
interject into that story. And
then build the iterative
capabilities by loading our

00:06:22.449,00:06:27.454
cradle with a malware. The
second idea is probably more
powerful depends on where you

00:06:30.123,00:06:36.429
are, is to take the whitelisted
binaries and essentially turn
them into trojan horses, turn

00:06:36.429,00:06:43.336
them into decoys of our own
actions. The reason why is
powerful is because the

00:06:43.336,00:06:48.975
whitelisted binaries are
there,there are suppose to be,
they are trusted. So the story

00:06:48.975,00:06:54.481
that the EDR builds were its
taken the trust, right and
that's more powerful. In this

00:06:54.481,00:06:58.218
talk we are going to talk about
both of these ideas, how they
can actually progress in

00:06:58.218,00:07:03.156
parallel. So in the first stage
we are going to see , how can
actually work with, what

00:07:06.526,00:07:12.165
ingredient ingredients do we
have to build that cake,you know
to cook it, to bake it rather.

00:07:12.165,00:07:17.170
Um and we are gonna heavily rely
on preloader in Linux operating
system for that, we are going to

00:07:20.507,00:07:25.512
see how we can chain our
preloading and then maybe hide
somethings from the EDR. And

00:07:28.548,00:07:33.353
last but not least we are gonna
talk about the concept of rapid
prototyping which is really

00:07:33.353,00:07:39.025
important because of the
constraints that we cannot bring
our own tools and we have to

00:07:39.025,00:07:45.565
somehow try to build them on
site rapid tooling prototype is
really important for us, the

00:07:45.565,00:07:51.538
second stage we are going to try
to weaponize and operationalize
the offensive capabilities that

00:07:51.538,00:07:57.177
we build, we are going to look
at mimicry and decoys in
operating system for our own

00:07:57.177,00:08:02.115
actions and benefit, and we are
going to see some other things
that will help us persist. So

00:08:04.217,00:08:11.124
Stage number 1, let's take a
quick trip you know down the
memory lane into the dynamic

00:08:11.124,00:08:16.129
linking and loading. Just like
in other operating systems your
linker is a tool, set of tools,

00:08:20.734,00:08:27.107
a frame work, that allows you to
to basically assemble your
executable with dynamic

00:08:27.107,00:08:32.011
libraries, static libraries
whatever the case may be.
Essentially present a um

00:08:32.011,00:08:37.016
consistent view of that binary,
right? The loader and linker
they see two different execution

00:08:39.786,00:08:45.592
views. They have um or two
different memory footprint views
right. There is a linking view

00:08:45.592,00:08:50.597
and there is an execution view,
segments vs um sections. And the
linker basically says ok well?

00:08:54.501,00:08:59.939
I'm going to find your dynamic
library if your looking for the
run time I'm gonna patch it into

00:08:59.939,00:09:04.811
the security board, I'm gonna
run relocation of the memory,
I'm gonna hand it off to the

00:09:04.811,00:09:10.683
actual execution.In practice If
you are the operator or any user
of the Linux system, it looks

00:09:10.683,00:09:15.422
very simple. When your
executable is compound with the
dependencies on the dynamic

00:09:15.422,00:09:21.094
library, if it runs and it
doesnt find the dependency bums
out and you are given an error

00:09:21.094,00:09:26.766
pointing to the actual library
that is missing.Once the
dependency is found and you can

00:09:26.766,00:09:32.071
do that by various tools
available on a Linux machine,
you can actually launch it back

00:09:32.071,00:09:37.076
and everything is going to be
fine. If your library path is
set up right and your dependency

00:09:37.076,00:09:42.081
is found. And it also the other
concept is um is um ELF hooking,
right? Used everywhere from

00:09:47.320,00:09:51.424
malicious and non malicious
purposes to introspect binaries
to change its behavior to hot

00:09:51.424,00:09:57.330
patch a binary. Essentially what
it does is you can use the
preloader to actually find a

00:09:57.330,00:10:02.335
library that is supposed to be
loaded into the memory space of
the executable with the feature

00:10:04.704,00:10:10.710
and functionality that you can
introduce into that is foreign
to the execution of that binary

00:10:10.710,00:10:15.715
itself. And so you can basically
say ok well i can take a
functionality, I can reroute it.

00:10:19.185,00:10:25.325
We are breaking the API contract
here by rerouting our execution
to to the libraries that we

00:10:25.325,00:10:30.330
bring in, but there is a problem
with that, the problem is that
you need to know the API.If libc

00:10:33.466,00:10:38.304
library, is libc library is
known very well there are many
pages for it, the contracts are

00:10:38.304,00:10:44.911
known, the API's are known. For
example, for fopen case, fopen
API you know exactly what it

00:10:44.911,00:10:50.416
returns, what it takes and how
that works and so when you are
preloading the binary with a

00:10:50.416,00:10:57.023
known fopen API, you know how to
interject that. Right? You can
reroute it and interject it, but

00:10:57.023,00:11:01.094
unfortunately in a black box
scenario that we are working in
when we are dropping in a box,

00:11:01.094,00:11:07.300
and we do not know what we are
trying to preload, that presents
a problem. But first need to

00:11:07.300,00:11:12.238
understand what that binary
does, we need to trace it, maybe
reverse engineer it a little

00:11:12.238,00:11:17.243
bit. We cannot do it most of the
time on the box itself. So what
if, we are going to be a little

00:11:22.015,00:11:27.153
bit more agnostic as to the
specifics of the API we are
trying to hook. What if we are

00:11:27.153,00:11:33.092
not going to the actual version
of the target, we are not going
to re write functionality in the

00:11:33.092,00:11:38.765
library that we are preloading.
But we are still going to compel
it to execute our code. How do

00:11:38.765,00:11:43.770
we do this? Let's look at the
relationship that the processes
have on Linux, parent and child

00:11:45.872,00:11:52.512
process. If you are the parent
of a process you likely, lets
just say, own the bootstrap

00:11:52.512,00:11:57.650
process of it, you can
introspect it and you can have
some formal relationship between

00:11:57.650,00:12:02.589
the two, and so we can try and
deliver the payload generically
in a known way by abusing a

00:12:04.591,00:12:10.863
relationship and trust. And then
you know the word is your
oyster, you can do other things

00:12:10.863,00:12:16.235
with it, lets see how that
works. But first is just the
viability check. Why do we need

00:12:16.235,00:12:23.142
to do this? Well if we are
taking the two pads, the clean
preload uh um cradles, right and

00:12:23.142,00:12:29.649
the second path is using the
binaries that you find on a
disk, you can time the loading

00:12:29.649,00:12:35.955
of the modules and you can
actually work towards um um
towards um blinding EDR's that

00:12:35.955,00:12:41.728
way. The EDR's may not be able
to fully trace your execution if
you are taking care of um

00:12:41.728,00:12:47.533
splitting a payload into
different libraries using the
preloads and you can abuse the

00:12:47.533,00:12:52.538
parent child relationship on
Linux and attain your um your
goals that way. What we want is

00:12:57.310,00:13:02.181
we wanna take a target process
and turn it into this
monstrosity instrument with our

00:13:02.181,00:13:07.186
payload, our malicious payload
and also trigger that payload or
parts of it when we want to. So

00:13:11.457,00:13:16.462
let's walk through that process.
In order for us to do this, um
let's turn our attention to back

00:13:20.299,00:13:25.405
into the ELF format but in this
case we are going to look at it
from a defensive standpoint. We

00:13:25.405,00:13:30.677
are going to take the sections
of the ELF and we are going to
try to introduce malicious code

00:13:30.677,00:13:36.549
in it. Well in the case of uh a
cradle that we are bringing in,
it should be easy cause we can

00:13:36.549,00:13:42.221
compile things into those
sections and our compiler, our
friendly compiler is helping us

00:13:42.221,00:13:47.226
with that, by using sections
like init_array or fini or maybe
even as a preinit_array.

00:13:49.929,00:13:54.934
Essentially we can supersede the
understanding of the execution
by injection code into the

00:13:57.136,00:14:02.075
sections that we'll be executing
before your main, right? And so
the one curios thing or side

00:14:05.344,00:14:10.349
effect of the loading and
linking i guess in this case, is
that control is given to that

00:14:13.219,00:14:18.091
shared object that you are
introducing thru loading before
transferring control to the

00:14:18.091,00:14:24.030
main. Do you see what we are
going here? We are basically
trying to preload the executable

00:14:24.030,00:14:30.103
and interject and control its
execution before it even starts.
Parent child relationship maybe?

00:14:30.103,00:14:35.108
The other thing is we can take a
look at things past ELF format
at the library, the libc library

00:14:38.811,00:14:45.017
in in Linux um operating system
we can actually hook libc start
main, there reason why that is

00:14:45.017,00:14:51.758
useful is because libc start
main is everywhere, its outside
the memory um you know um hooks

00:14:51.758,00:14:58.498
up different things, sets up
execution contents for
executables on Linux, um at

00:14:58.498,00:15:04.437
least in many cases, and we can
do that right? by basically
hooking libc start main and then

00:15:04.437,00:15:09.442
looking for a dynamic um next
function that goes into , into
the regional main by using the

00:15:13.913,00:15:18.918
dlsym and dlopen. But that's not
optimal, why is this not
optimal. Well - let's go back

00:15:21.320,00:15:27.326
actually, the reason why is not
optimal is because EDR's can
actually look for dlsym and

00:15:27.326,00:15:33.199
dlopen and basically deny your
execution, its very easy to
trace and see what dlsym is

00:15:33.199,00:15:38.204
being used and just say no. You
guys cannot load any libraries
into this process. Ok, well if

00:15:41.040,00:15:46.612
you if you the EDR do not like
us that way what we are what we
are do, we are gonna use a

00:15:46.612,00:15:51.617
facility call weak symbols, what
weak symbols mean is that if you
are trying to load a binary with

00:15:54.320,00:15:59.325
um, with the lib a binary of the
library of your choosing and you
define ah,um function, maybe a

00:16:03.296,00:16:09.569
global function or some variable
that you are exporting from that
library. Normally as we've seen

00:16:09.569,00:16:14.640
before when you cannot aaa
feature or function that you are
looking for, your destination

00:16:14.640,00:16:20.112
bums out, it basically says 'No
I can't continue, I can't find
that code' well with weak

00:16:20.112,00:16:25.484
symbols are doing for you is it
says ‘ok! well, if its not
present, just skip it' maybe

00:16:25.484,00:16:31.257
slowed it down the line but we
don't care about that. So if we
are dropping in the sandbox and

00:16:31.257,00:16:37.830
we are seeing ok! well do we
have a library sitting next to
our executable or otherwise

00:16:37.830,00:16:43.903
found thru the library path. We
can find it or load it, if its
not there on the sandbox, If we

00:16:43.903,00:16:50.810
did not, if for example incident
response has taken our library
but not has taken our boundary

00:16:50.810,00:16:56.983
cradle but not the library then,
um we are not gonna launch it.
And so the story unravels right?

00:16:56.983,00:17:01.921
You can chain, um preloads and
libraries through to the weak
symbols, you can say if its

00:17:04.557,00:17:10.696
present launch it into memory,
if not then skip it. That's
called control weak refs-

00:17:10.696,00:17:16.335
there's also foreign weak refs.
Did you know that almost every
binary on Linux contains weak

00:17:16.335,00:17:22.074
symbols? And did you know that
you can actually hookem from the
library preloading them? Cxa

00:17:22.074,00:17:28.347
finalize and gmon start is a
good example, there are others,
especially in the um, in um in

00:17:28.347,00:17:34.754
solutions that deal with for
example java version machine. So
essentially what that gives us

00:17:34.754,00:17:41.360
is, if we are not able to bring
our cradles we can find weak
symbols in libraries or

00:17:41.360,00:17:46.465
executables on the box itself
because they are given to us and
we are going to take advantage

00:17:46.465,00:17:52.538
of that. Also, I talked about
the chain weak refs, you can
actually split the execution of

00:17:52.538,00:17:58.878
your payload, or the payload
itself across a chain of dynamic
libraries. So when the EDR gets

00:17:58.878,00:18:05.551
one library it doesn’t see the
full picture, that's what we
want. Next up is the

00:18:05.551,00:18:11.424
construction right, the
constructors are very useful
when you are coding um, crc++

00:18:11.424,00:18:17.463
application, you have a way to
say ok well ok? that's my
constructor, you know it's just

00:18:17.463,00:18:22.068
a virtual memory for
dependencies and all that good
stuff, we can take advantage of

00:18:22.068,00:18:27.073
that. How do we do this, well
what we do is we preload a
binary with the library that

00:18:31.377,00:18:36.382
defines a constructor for that
execution. So essentially before
it gets to the main, were saying

00:18:39.685,00:18:44.690
oops that's an object, don't do
execution of the main, instead
round the constructor before you

00:18:47.927,00:18:52.698
hand it off to main. And the
same thing with destructor.
Before the um binary is uh you

00:18:52.698,00:18:58.504
know, ends its execution. Just
execute whatever we are given in
the destructor. Destructors are

00:18:58.504,00:19:03.943
powerful that way because you
can time the execution of your
malware. Nothing tells you to,

00:19:03.943,00:19:08.948
if you are preloading/bin/ls,
your malware has to run at the
outside of that executing. You

00:19:12.184,00:19:18.457
can run for hours and then when
the, well bin ls is not a good
idea but maybe some long running

00:19:18.457,00:19:23.562
process, right? and when you
kill it, maybe sending a signal
to it, whatever the case may be,

00:19:23.562,00:19:27.633
this is where you trigger the
execution of your malware.
Right? So now with the

00:19:27.633,00:19:34.373
constructors we can do it in a
target agnostic manner, we can
take any executable on linux and

00:19:34.373,00:19:39.845
basically start preloading it in
a generic way. And if EDR
technology actually knows about

00:19:39.845,00:19:44.116
that trick, and it says well
we'll interject and we'll just
give you constructor, default

00:19:44.116,00:19:49.455
constructor. Turns out there are
priorities on the constructors
and so if they load at a default

00:19:49.455,00:19:55.294
priority of 200 what we can do
is what we basically load it
priority higher than that and

00:19:55.294,00:20:00.299
101 right, and the same thing
with destructor we'll basically
patch a different priority to

00:20:02.468,00:20:07.473
constructor to override the
defense. The other thing that we
can do to break that story, that

00:20:11.510,00:20:17.683
EDR kinda builds by saying ok
well, indicators are compromised
are there, you know. Are they

00:20:17.683,00:20:21.687
building a story? Is the
malicious executable, Is it not?
Am I going to kill it? Am I not

00:20:21.687,00:20:26.692
going to kill it? Its to trigger
that malware loading through our
event signals. Not only regular

00:20:29.729,00:20:35.601
signals but even exception
handling, right? Nothing tells
us that we cannot instrument our

00:20:35.601,00:20:40.606
cradle or preload the decoy
library, decoy binary on the
system and then basically divide

00:20:44.009,00:20:49.949
by 0. That's not a recoverable
event in most cases but we can
implement the handler, so what

00:20:49.949,00:20:55.321
EDR sees as a completely
disastrous event and it stops
looking, we recover from i and

00:20:55.321,00:21:01.861
we continue running. Tips and
tricks like that, so you can
self trigger your own execution

00:21:01.861,00:21:08.634
there. And we are actually going
to see um that coupled with
other things later on, and then

00:21:08.634,00:21:13.639
it obviously if you are bringing
in your libraries, you can start
building userland rootkits on

00:21:16.075,00:21:20.112
it. You can clean your ld
preload from your own
environment, so if EDR is

00:21:20.112,00:21:25.184
looking at your memory space and
says 'Hey! Where is the payload?
and if they are relying on

00:21:25.184,00:21:30.322
environmental variables they are
not going to be able to find it.
All that good stuff can go in

00:21:30.322,00:21:35.327
the obfuscation of your loaders,
right? Runtime situational
checks, um possibly even for

00:21:37.797,00:21:42.835
going the main itself, maybe you
are doing some assembly tricks
to basically saying ok, if EDR

00:21:42.835,00:21:47.673
is looking for main, I'm not
going to have it or I can rename
it to something else, something

00:21:47.673,00:21:52.678
innocuous and you can even
substitute the actual loader,
ld.so on linux to have your own

00:21:57.750,00:22:02.688
into the interpreter section. So
if EDR instrumenting in some way
the ld.so they are not going to

00:22:04.890,00:22:09.895
see executing. Ok so now we have
some primitives to work with,
some recipes, some tips. How do

00:22:15.334,00:22:21.240
we progress, um further? How do
we expand and scale our, our
presence there? right, that's

00:22:21.240,00:22:27.279
important because we have to
have almost a la carte set of
tools and primitives in order to

00:22:27.279,00:22:31.817
bypass different versions of
EDR's cause we do not know what
it is right? Could be white

00:22:31.817,00:22:36.822
listing technology we know
about, could be something else.
Ok, well we mention the ld.so as

00:22:39.158,00:22:46.131
a default linker and loader for,
um Linux operating system. What
about system libraries and

00:22:46.131,00:22:51.136
binaries that run other binaries
on systems? Well ld.so not only
runs programs that you know?

00:22:53.439,00:22:59.945
that it finds or loop start
patches it in, but it can also
run directly your payloads

00:22:59.945,00:23:05.885
right? And if your EDR are
watching over the regular
expressions, like what is your

00:23:05.885,00:23:10.556
process name? right? I'm not
going to allow something that I
do not like and I can only do

00:23:10.556,00:23:15.561
things a certain way, that known
good story, that trust its been
broken if you are able to

00:23:18.697,00:23:23.702
preload the actual loader with
chain execution of other systems
binaries on the system that you

00:23:27.506,00:23:34.313
can find them. right? And that
goes into the whole idea of you
know who gets there first?

00:23:34.313,00:23:39.852
Right? Like are you watching for
busy box, are you watching for
ld linux .so, are you watching

00:23:39.852,00:23:45.190
for vi launching into the
memories TTY and basically
executing your code. Are you

00:23:45.190,00:23:50.896
doing all that EDR? If you are
not doing all that, then
obviously you are gonna miss

00:23:50.896,00:23:57.236
that. But from our perspective,
from the operating perspective,
that's too chatty right? Because

00:23:57.236,00:24:02.174
that assumes that the defense
can analyze our command line
right? And so it's also all that

00:24:04.810,00:24:09.815
um, you know, it may be really
easily defeated. Ok, well we
need to device some other

00:24:12.217,00:24:17.222
things, maybe we can up our anti
on the vision capabilities.
Maybe, we can bring in,

00:24:20.025,00:24:26.365
interpret the languages into the
mix, right? So we can prototype
easily once we drop in the box.

00:24:26.365,00:24:32.905
And so before we actually get to
interpret languages we can even
talk about highly reflected

00:24:32.905,00:24:37.910
pieces of code that are encoded
into the shared libraries.
Nothing to say that you have to

00:24:40.446,00:24:45.784
create your shared libraries out
of the c or c++ right, you are
going to actually use foreign

00:24:45.784,00:24:50.889
function interface and round
things out of python or maybe
compile things with the C. And

00:24:50.889,00:24:55.894
by the way what does it give us?
It give us as an attacker a
privilege of 256 functions.

00:25:01.667,00:25:07.673
Highly reflective before the
dense can actually define our
main, and figure out how we are

00:25:07.673,00:25:12.678
executing so just by shimming
it, shimming out of the um,
consistent execution of C

00:25:15.047,00:25:21.854
language into some other stacks,
for example interpretive
language or var or other things

00:25:21.854,00:25:27.326
that are very highly reflective,
the EDR loses our trail and
therefore it cannot build a

00:25:27.326,00:25:33.298
consistent story to be able to
determine if we are malicious or
not. And the same thing with

00:25:33.298,00:25:39.271
interpreted languages, you can
actually run something um, in
it. For example you can preload

00:25:39.271,00:25:45.577
things with lua, that's a
completely different execution
and it gives you, um different

00:25:45.577,00:25:50.482
memory footprint if EDR's are
not watching for it and you can,
with shim, you can mix and match

00:25:50.482,00:25:56.121
all these things. So see how
many, it's a death by a thousand
cuts in many respects as far as

00:25:56.121,00:26:01.093
EDR building that story, that's
what we are after. We are
basically trying to obstruct it

00:26:01.093,00:26:06.298
to the to the point where we are
persistent, you know. Ifs not a
know good, and it's not a known

00:26:06.298,00:26:11.303
bad because EDR's are running on
you know, most EDR's run on
performance and they cannot

00:26:14.273,00:26:20.779
consume too much CPU type, or or
analysis time, they will say
fine I'll let you go. 26:19 And

00:26:20.779,00:26:25.918
so right now we know that those
primitives that we are trying to
build are not that primitive,

00:26:25.918,00:26:30.923
right? But stage 2 is how do we
package this whole thing. How do
we make this rapid prototyping

00:26:35.160,00:26:40.165
actionable? How do we make it
maybe even more defensible for
us? So start thinking about pre

00:26:43.202,00:26:48.707
preloaders and lets start
thinking how do we expand the
functionality and make them

00:26:48.707,00:26:55.714
more, um flexible i should say.
In this example if we are taking
/bin/ls and we are preloading

00:26:55.714,00:27:00.652
with our malware execution
chain, right? Any arguments that
we are passing into the

00:27:03.021,00:27:08.026
preloader are not gonna end up
being used because they are
eaten by the ls, well you know

00:27:10.195,00:27:16.301
what can we do with this? How
can we make our loader even more
expanded? We can start moving

00:27:16.301,00:27:21.874
back on the command line with
environmental variables that are
been consumed by the preloader,

00:27:21.874,00:27:26.879
right and mind you in this case
the preloader is only a dynamic
library, it's not an executable.

00:27:28.947,00:27:33.952
It is loaded as a constructor
into /bin/ls and so in this case
we are saying hey! you know take

00:27:36.922,00:27:43.795
that bin/ls preload it with
libctx.so by the way go into the
background, by the way rename

00:27:43.795,00:27:48.800
itself in the process table as
smtp process, by the way have a
chain of shims that load into

00:27:51.370,00:27:56.308
you know you dynamically unravel
that chain and load it back into
the memory. And by the way past

00:27:56.308,00:28:02.080
arguments to those chain, to to
the chain or to those um,
libraries that we are

00:28:02.080,00:28:07.085
preloading. That's one way of
doing it. And those chains can
use all the things that we

00:28:09.855,00:28:16.628
talked about, they can be highly
reflective, they can escape into
um, into interpretive languages.

00:28:16.628,00:28:20.799
They can even switch on
different IPC's right, they can
run over pipes or, they can

00:28:20.799,00:28:25.804
source their payloads over um
various several facilities that
operating system has. Now , and

00:28:30.309,00:28:33.712
obviously they can clean up
after themselves, right they can
remove all the things that

00:28:33.712,00:28:39.618
they've loaded ld_preload, all
the environmental variables so
um, if you are there first

00:28:39.618,00:28:44.623
you'll probably see that if you
are not you won't. One small
little problem, the loader that

00:28:46.992,00:28:51.496
we are trying to do, the
preloader chain that we are
trying to launch, at least one

00:28:51.496,00:28:56.501
of them is a file right? a file
ld.so tries to loads first and
as such its on disk, its

00:29:00.205,00:29:07.045
scannable, admins can find it,
whatever the case may be. But
yes we know about EDR identity

00:29:07.045,00:29:12.150
crisis, yes we know not
everything is being watched but
there is a chance. So we want

00:29:12.150,00:29:19.091
flexibility. Can we work with
memory? Can we load things over
memory? Well loading modules

00:29:19.091,00:29:25.597
into the memories is really
interesting thing, its its very
common right, mapping um memory

00:29:25.597,00:29:29.001
and stuff like that so your
operating system is going to
love you for that, there are

00:29:29.001,00:29:34.306
facilities. But as soon as you
start executing something from
memory your operating system

00:29:34.306,00:29:39.311
will not like it at all. So
historically it's been there
been um many different um ways

00:29:41.780,00:29:48.787
of operating and sharing memory
linux. Dev/shm right, you can
stop something in there but

00:29:48.787,00:29:55.627
again EDR's may know about that,
they watch it. Naked memory
mapping of files is also

00:29:55.627,00:30:00.799
something that is been watched
by EDR's because you can put
permissions on it, you can

00:30:00.799,00:30:06.438
change permissions, you can
create , rewrite execute
sections in there and then you

00:30:06.438,00:30:12.878
know obviously that's
detectable. And most of the time
you can't really obtain

00:30:12.878,00:30:18.750
execution from memory location
because of that, cause you
cannot mark your ummm memory

00:30:18.750,00:30:23.755
executable you know sometimes
you can't do that. As Kernel 3
uh 317 rolls in, um you- we are

00:30:27.759,00:30:32.764
gaining a specific separate
system call memfd create. That's
not a new technique to load

00:30:35.033,00:30:40.038
things into memory from um,
memfd create. But if you wanna
do this, here is the API to this

00:30:43.442,00:30:49.781
memfd create, you allocate
memory and then you basically
pass it to fexecve or maybe you

00:30:49.781,00:30:54.786
emulate execution but the point
that it works. You basically
have a way to execute things

00:30:56.788,00:31:03.095
over memory right, um
essentially it is the relaxed um
, the the operating system

00:31:03.095,00:31:08.934
relaxes rules on execution when
you use that specific system
call. But that's not what we are

00:31:08.934,00:31:15.140
after, it is going to help but
we are not after that. A curious
side effect of running memfd

00:31:15.140,00:31:20.145
create is that, it exposes a
file descriptor, like any other
linux process in a proc right

00:31:24.449,00:31:30.288
and that memdf create a proac fd
in this case, uhh you kno 2,
descriptor number 2 for example

00:31:30.288,00:31:34.626
or 3 or whatever the case may
be. That's what we are after,
let's review what we can do with

00:31:34.626,00:31:39.631
this. Well, if we are breaking
the story of EDR and we are
splitting payloads across

00:31:42.634,00:31:47.639
libraries, we can split payloads
across memory spaces of
processes. We can say we can

00:31:49.741,00:31:56.314
have we can line up 10 cradles,
launch them up into the memory
and those 10 cradles are going

00:31:56.314,00:32:02.420
to be separate processes that
may host a part of the payload.
How do we reach out to those

00:32:02.420,00:32:07.425
processes? And ask them hey give
your part, give me one 10th of
the payload so I can execute it.

00:32:09.694,00:32:16.368
This is what we can do with
memfd create, instead of um if
we are taking the preloader and

00:32:16.368,00:32:21.373
instead of executing and loading
the module from um, a disk. We
can ask a different process to

00:32:24.776,00:32:31.716
give us a descriptor that
maintains or contains the
library or payload in such a way

00:32:31.716,00:32:38.123
that we can execute it. So we
are gaining, we are reaching out
to process id 564117 and saying

00:32:38.123,00:32:43.128
hey! give me an exposed um, um
proc file descriptor ok. The
only problem here is while we

00:32:48.733,00:32:55.740
are actually doing execution and
loading from memory, what is
564117? And if we are not in a

00:32:55.740,00:33:00.078
relationship with that process,
we are not the parent child
relationship or we are not super

00:33:00.078,00:33:05.083
user, then we are not going to
be able to see that, you know,
that process descriptor because

00:33:05.083,00:33:10.088
of the Linux security model. So
let's work on 564117, and before
we do that we have to look at

00:33:13.825,00:33:19.497
the nature, which is really
brutal at allocating resources,
very efficient. And there are

00:33:19.497,00:33:24.803
things in nature that you can
learn from, right, We can learn
from, one of these things is a

00:33:24.803,00:33:29.808
phenomenon of a virus that
infects specific um, ant colony
right, and once the ant is

00:33:33.645,00:33:39.117
infected the virus does not kill
the ant. What it does, it
basically turns it into a zombie

00:33:39.117,00:33:45.757
by saying ok ant, i'm going to
control your muscles instead of
your nervous system and as such

00:33:45.757,00:33:51.596
you are gonna climb up the tree,
bite on the leaf and you are
going to stay there until I tell

00:33:51.596,00:33:56.701
you to release yourself or die
or whatever the case may be. At
this point the spores mature,

00:33:56.701,00:34:02.440
and they rain down in other ants
and the story continues, the
cycle of life right. The

00:34:02.440,00:34:06.945
interesting part from this is
the fact that we are controlling
the muscle system of an ant

00:34:06.945,00:34:13.652
without killing it. And so
zombie ant farm is design to do
exactly that. It is an out of

00:34:13.652,00:34:18.690
target process store of
payloads, it's a broker and the
dealer of the payload that is

00:34:18.690,00:34:25.330
somewhere in the memory that the
preloaders that we are looking
at can ask it to release payload

00:34:25.330,00:34:32.003
for its you know, for their
consumption. So it is a broker
that reaches over the cross

00:34:32.003,00:34:37.008
process memory for a payload,
without going into details on
how it actually does that in

00:34:39.010,00:34:44.115
terms of what features it has,
defensive capabilities and what
not. Lets first think how it

00:34:44.115,00:34:49.120
works conceptually, conceptually
this ZAF essentially it loads
things into the memory, it asks

00:34:51.323,00:34:56.328
the operator to load um payloads
directly from the url into its
memory and then expose the um,

00:34:59.698,00:35:04.636
the payload that was loaded from
the url into the memories, into
the operating system, into the

00:35:04.636,00:35:09.341
file system thru the proc,
right. And then your uber
payload basically goes out and

00:35:09.341,00:35:14.346
says -retrieve it- and because i
can actually launch my parent
child relationship with the

00:35:16.681,00:35:21.686
payload, then i gain access to
the um payloaders memory space.
This is how that looks, right.

00:35:24.823,00:35:30.829
Your payload chain, because we
are operating on the same user
id so we can introspect

00:35:30.829,00:35:37.235
processes. We are saying go get
me a payload out of somebody
else's memory space, and by the

00:35:37.235,00:35:40.839
way, do it in the proc, and by
the way, do it from the memory,
and by the way I don't care

00:35:40.839,00:35:45.844
about your EDR right. And so in
this case 564117 that we've see
before, it acts as a broker and

00:35:50.982,00:35:57.122
a dealer for the payloads for
us. Conceptually you know the
big picture is how that

00:35:57.122,00:36:03.461
works,right. You have facilities
and primitives were you create
this monster target process that

00:36:03.461,00:36:08.633
you can instrument with
different um, you know u code,
writing through sections or

00:36:08.633,00:36:14.672
compailors or loaders, whatever
the case may be. Your loader
asks ZAF to basically give him

00:36:14.672,00:36:21.179
the payload or features or
functionality and it loads the
target executable with them. So

00:36:21.179,00:36:27.652
what EDR sees, now it needs to
connect the dots and see the
full story across my memory

00:36:27.652,00:36:33.291
process of the entire you know
between 10 or 20 different
mechanisms. The IPC, the

00:36:33.291,00:36:38.997
sockets, the url retrieval, um
you know 2 different processes
that are involved or 3 different

00:36:38.997,00:36:44.235
processes that are involved. And
if it guess the real cradle, our
clean executable is not going to

00:36:44.235,00:36:49.240
see any of that. So that's what
we are after. So the pipeline is
getting stronger here. Ok, well

00:36:54.712,00:36:59.717
one other problem that ZAF
itself as an executable, how do
we, it's a catch 22 right, like

00:37:02.987,00:37:09.360
how do we get executable that
doesn't drop on disk. So we can
get the library payload that

00:37:09.360,00:37:14.499
doesn't drop on disk by using
ZAF but how does ZAF get there
right? And so we are returning

00:37:14.499,00:37:19.971
our attention back into memfd
create but only doing this from
an interpreter language. For

00:37:19.971,00:37:26.811
example python, right thru
common function interface you
can call up the linux operating

00:37:26.811,00:37:31.816
systems sis calls.You can say
hey! memfd create from linux or
from python execute itself and

00:37:34.619,00:37:39.891
give me whatever you are going
to give me. Well Python is just
a string of text right, you are

00:37:39.891,00:37:44.696
not dropping executables on a
disk anymore. What you are doing
is you are writing a script into

00:37:44.696,00:37:51.536
python so now you are extending
that story for EDR all the way
out into this just a string of

00:37:51.536,00:37:56.541
text that loads, that executes
the url retrieval of ZAF itself
and launches into the memory

00:37:59.010,00:38:04.949
through the interpretation,
through interpretive language.
Pypreload is what I call it

00:38:04.949,00:38:11.890
right, it reaches out thru the
url endpoint to web server,
fetches things and launches them

00:38:11.890,00:38:16.895
into the memory by using decoys,
so for example when EDR or url
treat hunters are looking at the

00:38:19.164,00:38:24.102
process table, what they see is
a batch for example that
launches bin ls but they do not

00:38:24.102,00:38:30.508
see the relationship of the
python code, basically getting
things out from elsewhere and

00:38:30.508,00:38:36.114
unraveling that chain. So again
we are trying to blind the EDR
from the behavioral standpoint

00:38:36.114,00:38:40.385
so it doesn't build, does not
have a chance to build that
story and along the way we are

00:38:40.385,00:38:47.225
basically trying to prevent EDR
from having to launch on any
kind of trust that we are doing.

00:38:47.225,00:38:52.230
OK, and so you know,
conceptually is really easy now
right? Like a python script that

00:38:54.599,00:39:00.205
is very small is a task, you
drop it, it gets ZAF, ZAF
launches into the memory, ZAF

00:39:00.205,00:39:06.177
itself has facilities to
interface with, so we are having
a shell script go out to its

00:39:06.177,00:39:12.817
socket and say hey load all of
your payloads from all these
other locations, file system or

00:39:12.817,00:39:17.922
you know! external network
interface or url or whatever the
case may be. Stored it in your

00:39:17.922,00:39:22.927
own memory space and delve it
out as needed, as asked. In a
whole you know, if we were to

00:39:26.731,00:39:32.036
have a visual of this whole
thing, it looks like this.
right? Number 1 is pypreload

00:39:32.036,00:39:37.041
driver that gets the ZAF out of
the external um location in
memory execution of a process

00:39:40.511,00:39:45.516
for ZAF, ZAF presents um a
driver, sort of a socket that
says ok, well here is your you

00:39:47.585,00:39:54.525
know uh JSON go get me something
from external, expose me some
payloads and Im gonna use the

00:39:54.525,00:39:59.697
uber preloader pipeline to go
get the payloads from it and I'm
gonna instrument the process

00:39:59.697,00:40:04.702
that I want /bin/ls whatever the
case may be to do the bidding on
our end, so all that is , we are

00:40:06.704,00:40:11.709
gonna we are gonna go into demo.
And this demo is going to show-
see if we can do that- Ok, so

00:40:18.917,00:40:24.322
that's zombie ant farm, right?
First we are gonna fetch a
remote binary and execute it

00:40:24.322,00:40:29.327
from memory as we talked, and so
we have a, we watch the file
system just to make sure we are

00:40:32.063,00:40:37.068
not dropping anything on
disk,right? And then we are
launching a a http server to

00:40:37.068,00:40:40.905
serve the payloads and in this
case there is going to be a
malicious ls command. For

00:40:40.905,00:40:46.544
example, that comes out of that
url and pypreloader is a python
script that says ok, that's

00:40:46.544,00:40:53.484
binary go fetch it, execute it
and load it from a specific file
descriptor. We have um a way to

00:40:53.484,00:40:59.090
do this and yet we see that
nothing has been dumped on disk,
right, nothing is there. The

00:40:59.090,00:41:05.163
second thing that we are going
is, we are actually um you know
fetching um the preloader

00:41:05.163,00:41:07.165
library if we want to. Executing
it without preloader, seen that
it works right, then we are

00:41:07.165,00:41:09.167
watching the file system making
sure is not dropping anything on
disk, starting the http server

00:41:09.167,00:41:14.172
and then essentially uh telling
the preloader that what we are
loading is a shared object out

00:41:21.379,00:41:26.384
of somewhere in the url,
executing it in the bin/ls and
by the way, you know that bin/ls

00:41:33.324,00:41:39.364
is not good so it's going to
describe something in a box. So
both bin/ls and the preloader

00:41:39.364,00:41:44.369
runs in memory with you know,
loaded um malicious code here,
ok! Then lets fetch ZAF, let's

00:41:52.243,00:41:59.050
do exactly the same thing to it
as we did previously to the ls.
So lets basically break that

00:41:59.050,00:42:03.988
story even more. Um same thing
watching the um file system,
launching ZAF, seeing that is

00:42:07.658,00:42:12.663
showing as bash, executing
loading it into the memory as
process 128224. ZAF itself opens

00:42:15.666,00:42:22.140
up ah a management socket that
we can send uh commands to and
basically saying Ok, well ZAF

00:42:22.140,00:42:27.145
now load the same ls from
external location as a module in
its own memory space. And let's

00:42:32.183,00:42:37.188
make sure that we can actually
see that module loaded in there,
right. File descriptor 6, root 4

00:42:40.058,00:42:46.230
is the last one, lets see where
it loaded, right. So memfd is a
femoral descriptor that is

00:42:46.230,00:42:51.235
executing itself in ZAF memory
space and then we can just go
directly for execution of that

00:42:54.038,00:43:00.211
ls, instead of doing a path on
disk, we are doing a path in the
memory catching a fail

00:43:00.211,00:43:06.083
descriptor 6 from ZAF, right?
And that's a regular executable
that fetch. Pretty Powerful! And

00:43:06.083,00:43:11.089
then um, you know, we basically
just just keep doing this, we
can you know, create preloader

00:43:13.157,00:43:18.162
chains and um, those things.
Doing exactly the same thing
here, right we have our previous

00:43:24.202,00:43:29.207
module that we have loaded but
instead of loading executable
over again unload a library for

00:43:31.776,00:43:36.781
preloading and it should end up
been on file descriptor 7 which
is true, and then instead of

00:43:44.088,00:43:49.093
executing out of proc we preload
ls with exploid that comes out
of, you know, ZAF's memory

00:43:51.162,00:43:56.167
alright. The modules are there
you can stage it however you
want. But the point here is that

00:44:02.874,00:44:07.879
we are now splitting execution
of payloads and deliver it into
two memory processes. Ok, other

00:44:13.518,00:44:17.922
things, other research to break
that story that is going on
right now is not fully complete

00:44:17.922,00:44:22.927
but I kinda wanted to talk about
it a little bit, is if we are
owning our code crave code cave,

00:44:24.929,00:44:29.934
essentially we can randomize, we
can remove ASLR from the process
by uh creating a personality

00:44:34.038,00:44:39.176
trick, right. Were basically
forking executable, we are
changing the personality and we

00:44:39.176,00:44:45.950
are executing it without the
memory space,with memory space
that is not randomized anymore.

00:44:45.950,00:44:52.023
And then we write or read into
the memory pros, into the
processed memory our exploit. So

00:44:52.023,00:44:57.228
our exploit no longer needs to
come from a library that you
preload, it can come from a

00:44:57.228,00:45:04.135
text, right. How do we do this?
Well we essentially like i was
saying we fork then address the

00:45:04.135,00:45:10.708
uh randomized uh put a fork on
the personality adjustment of a
process that we are launching

00:45:10.708,00:45:14.979
because we are parent and child
relationship we are able to do
that and we are releasing it for

00:45:14.979,00:45:21.686
execution. And then if we have a
destination process that has a
code cave that we can stuff our

00:45:21.686,00:45:26.691
exploit in, we are able to do
that in an address in a user to
user address space by writing a

00:45:28.726,00:45:33.731
process called process vm
writev. So we are working on
this. Summary- preloading is a

00:45:33.731,00:45:39.570
viable path to exasion, grab the
executable from linux, preload
it to the memory . Out of

00:45:39.570,00:45:44.575
process preload delivery works
and it, I in my view is gonna
continue um to to extend into

00:45:47.511,00:45:53.618
more attacks and we are gonna do
more research on it. From the
red team perspective do not use,

00:45:53.618,00:45:58.022
you know, all of that on one
engagement at the same time
because its gonna burn your

00:45:58.022,00:46:04.061
payloads and mechanisms of
delivery, choose things wisely.
See foreign function interface

00:46:04.061,00:46:09.066
is important to interfaces and
to escape from EDR story by
basically switching the uh the

00:46:11.068,00:46:18.009
stacks, the technical stacks.
And then use those as a source
of ensemble attack, splitting,

00:46:18.009,00:46:24.582
scattering and assembling things
on a box as you chose to um, it
depends on which EDR you are

00:46:24.582,00:46:29.286
going against and what the
consequences may be. The code
for both zombie and all these

00:46:29.286,00:46:34.292
examples is released, you guys
can download it, play with it,
send bugs its open. Defense

00:46:38.963,00:46:43.968
optics into proc, optics into
IPC, optics into process loader,
optics in memfd create must

00:46:50.341,00:46:55.112
clearly define what EDR's do for
you in the scope of your uh
trade model. What I can and

00:46:55.112,00:47:00.918
cannot do, and start
implementing Linux capabilities
there is no reason why bin/ls

00:47:00.918,00:47:05.923
should run a socket code, right?
And obviously last but not least
is start thinking about the

00:47:09.093,00:47:14.332
protective contex, creating your
boxes making sure you know what
runs and how you are protecting

00:47:14.332,00:47:19.336
your stuff. Thank you! [audience
applause] Wonderful, yeah thank
you! [applause]

