00:00:00.100,00:00:04.972
>>These gentlemen have come all
the way from China to you guys
about breaking Google Home and

00:00:04.972,00:00:10.744
exploiting it with SQLite. Let’s
give them a gigantic round of
applause. [applause] Have a

00:00:10.744,00:00:15.749
great time. Smile. I’m going to
take pictures. Have fun.
[applause] >>Hello everyone.

00:00:18.518,00:00:23.524
Thank you for coming. We are
very exciting to share our
search at the DefCon 27. The

00:00:28.462,00:00:33.467
title of our talk today is a
Breaking Google Home Exploit
with SQLite Magellan alg-

00:00:37.604,00:00:42.209
vulnerability. First let me
introduce my teammates and
myself. We are senior security

00:00:42.209,00:00:47.214
se- uh se- at Tencent Blade
Team. And this is my teammate
Qian Wenxiang. Now he’s focusing

00:00:51.385,00:00:57.591
on browser security and IoT
security. And this is YuXiang,
he is focusing on mobile

00:00:57.591,00:01:03.964
security and IoT security. And
my name HuiYu. I’m a bug hunter
and the GeekPwn winner. I also

00:01:03.964,00:01:08.969
be called, I also speak of uh
DefCon and Hat in Box and POC.
Next I will introduce the

00:01:13.540,00:01:18.545
Tencent Blade Team. Our team was
founded by Tencent Security
Platform Department at the 2017.

00:01:20.547,00:01:25.552
And then now we are focusing on
the security research in areas
such as AIot device, mobile

00:01:28.522,00:01:34.795
devices, cloud and the
Blockchain. In the past 3 years
we have reported more than 200

00:01:34.795,00:01:40.067
in the security vulnerabilities
to many companies such as uh
Google, Apple, Amazon, Microsoft

00:01:40.067,00:01:45.072
and the so um. Last year we
showed how to break Amazon Echo
at the DefCon 26. So cannot get,

00:01:50.043,00:01:55.048
so we cannot get this year.And
you can connect us at the blade
dot tencent dot com. Ok. Next

00:02:05.192,00:02:11.098
let’s take a brief look at the
itinerary. First, we will
introduce the attack surface of

00:02:11.098,00:02:16.103
Google Home smart speaker. Then
we will share the details on how
to find the exploit, SQLite and

00:02:19.272,00:02:24.277
Curl. Finally we will summarize
our research. Ok. Let’s start
with the first part. Smart

00:02:31.518,00:02:37.924
speaker are the most popular
mobile home devices of the past
few years. Amazon, google and

00:02:37.924,00:02:42.929
some Chinese companies are the
main player in this field. In
the fourth quarter of 2- 2018,

00:02:45.932,00:02:52.806
Amazon and Google’s market share
has been very similar. After we
shared uh after we shared how to

00:02:52.806,00:02:57.811
break Amazon Echo and XiaoMi AI
Speaker in DefCon 26, we began
to study the security of Google

00:03:00.814,00:03:05.819
Home’s mother speaker. The
Google Home family include 4
devices. All of which have

00:03:09.456,00:03:14.461
similar hardware. We choose the
best discerning Google Home mini
as the main tester devices. The

00:03:18.231,00:03:23.236
first part is about hardware
analyze. We find that the Google
Home mini use the Marvell CPU

00:03:25.505,00:03:31.478
and the Toshiba flash chip. But
we did not did not find the any
debugging and flashing

00:03:31.478,00:03:36.483
interface. So we kindly choose
to extract firmware directly
from the flash chip. Similar to

00:03:42.656,00:03:47.661
the Amazon Echo, we first use a
hidden dump to sort the chip
from the port. By analyzing the

00:03:50.363,00:03:55.869
data strip of the chip, we found
that has the circuit of BGA67
chip. And the difference is that

00:03:55.869,00:04:00.807
the pins of BGA67 chip are very
same. So we have not found the
adapter that it can connect to

00:04:09.983,00:04:14.988
the test circuit, to the
programmer. So we designed a new
adapter. Its main function is to

00:04:17.858,00:04:24.197
explore the pins of the test
circuit to a notch pitch. The
pins so that we can easily

00:04:24.197,00:04:29.202
connect the chip to the
programmer. And this is the
finished product that we finally

00:04:32.005,00:04:37.010
produced. We connected it to the
RT908H programmer, which is a
universal programmer that

00:04:40.747,00:04:45.752
supports reading and writing
most of flash chips. Finally, we
coded the RAM imaged in Google

00:04:51.358,00:04:56.363
Home uh flash chip. We also
needed to pad the olb data and
the ECC trig piece according to

00:04:58.865,00:05:05.639
the specification in the data
sheet. And then it’s dragged to
the company system firmware. By

00:05:05.639,00:05:10.644
analyzing the system first you
can know that a Google Home is
using a lite Chrome OS. The ma-

00:05:13.580,00:05:18.585
the main function are
implemented by the Chrome OS by
the Chrome browser. And there’s

00:05:22.422,00:05:27.427
an update speed where there’s a
little slower than the Chrome
browser. Ok. My part ends here.

00:05:31.498,00:05:36.503
And my teammate YuXiang will
continue to share the next part.
>>Uh thanks for your

00:05:47.347,00:05:52.352
introductions. Let’s introduce
the security overview of Google
Home. Fir. Uh firstly let’s look

00:05:54.421,00:05:59.726
at the security overview of
google home. On the OTA
mechanisms, the firmwares relat-

00:05:59.726,00:06:04.664
source of Google Home is open to
public. These source uh include
bootloader, kernels and related

00:06:07.033,00:06:13.073
bi- uh binaries programs and
some even has symbols. Google
Home use the attribute across to

00:06:13.073,00:06:18.078
download the firmwares. We can
also simulate the request for
device update, the latest OTA

00:06:20.747,00:06:25.752
package can be obtained curse
commands in the picture uh
below. So we can easy to get a

00:06:28.121,00:06:33.126
firmware and then try to analyze
the firmware. Um through analyze
of firmwares and related

00:06:38.531,00:06:45.205
resource, we believe that the
security mechanism are taught by
Google Home is worth learning.

00:06:45.205,00:06:50.944
About this, enabling a security
port on iot device is in is a
good example. That boot loader

00:06:50.944,00:06:55.915
put a system measures is
protected by the security
mechanism throughout a boot

00:06:55.915,00:07:01.721
process. The details as follows.
The bootloader and boot imager
use the [inaudible] and SHAs and

00:07:01.721,00:07:06.726
RSAs and uh no logic to provide
unlocking. And in directions,
Google Homes also pro- uh

00:07:15.035,00:07:20.040
perform in integrities are very
[inaudible] on system image. Uh
lets look at the um main

00:07:25.645,00:07:31.584
programs in the firmwares. The
firmwares has uh memory
directories as saw in these

00:07:31.584,00:07:36.589
pictures. This contains a main
program calls cast shell. The
program just Chrome. So it’s

00:07:38.992,00:07:45.165
program is protect by sandbox.
On Chrome OS the sandbox
mechanism mainly includes

00:07:45.165,00:07:50.170
setuid, user namespaces and
seccomp-BPF. In additions the
system also enable ASLR and the

00:07:52.405,00:07:57.410
cast shell also add NX and the
stack canarys. Next we will
introduce the attack surface of

00:08:02.916,00:08:08.421
google home combined with with
existing security research and
our attackings google homes

00:08:08.421,00:08:14.527
attacks of which includes the
following uh four aspects. Goo-
Google Home has module, multiple

00:08:14.527,00:08:19.532
part of port opens once the port
the 8008 is the uh http servers
uh we can control some basic

00:08:23.770,00:08:30.009
operations of google homes
through this port in the LAN.
There is also a port of 8009,

00:08:30.009,00:08:36.016
the port is the target of our
attacks. Using the Cast
protocol. We will demonstrate

00:08:36.016,00:08:41.221
the following sections. And the
wireless protocol is also attack
surface. Google Home used the

00:08:41.221,00:08:47.861
Marvell chip, so an idea about
Marvell wifi and BLE firmware
attack can be tried. It is also

00:08:47.861,00:08:54.334
possible to try to uh find a
vulnerabilities of the boot
loaders and added load module

00:08:54.334,00:08:59.339
firmwares. Finally we can try to
find other um other uh hardware
interface. In this instance we

00:09:04.711,00:09:10.683
will show you how to extend the
attack surface of Google Homes.
First let’s introduce the basic

00:09:10.683,00:09:17.357
knowledge about a CAST Protocol.
Uh Google allow developer to
develop CAST APP and publish it

00:09:17.357,00:09:23.530
to every every store. In general
the CAST APP includes senders
and receivers. Send the devices

00:09:23.530,00:09:29.903
may be mobile devices or PC
running a Chrome. Uh receiver is
a Googles iot devices such as

00:09:29.903,00:09:36.176
Google Home. The entire uh
picture is as follows, the URL a
sends the sender application URL

00:09:36.176,00:09:42.715
and the sender application use
the CAST Protocol to find the
receivers in the LAN. When the

00:09:42.715,00:09:48.655
receiver uh is discovered the
sender application will
communicate directly with the

00:09:48.655,00:09:53.660
URLs. Uh with the uh reader
applications on the receivers.
With the CAST protocol. Uh in

00:09:58.364,00:10:03.002
detail, the Google Homes will
pull the URL of each receiver
application according to the

00:10:03.002,00:10:05.805
CAST ID and accept the receiver
application through the Chrome
address. After our attempt we

00:10:05.805,00:10:10.810
found that CAST protocol will
have the following uh security
uh security risk including the

00:10:14.013,00:10:19.018
CAST app can be any webpage. The
CAST app in the app store may be
malicious. Uh and the senders

00:10:24.858,00:10:31.498
can directly trigger uh CAST
protocol with may even require
no router interruption. Based on

00:10:31.498,00:10:38.204
this uh this security risk we
can convert an attack on a
Chrome Google Home into an

00:10:38.204,00:10:43.209
attack on our browser. Let’s
take a look at a some special
steps. The attackers is

00:10:46.579,00:10:51.751
registered as the CAST
developers CAST application can
be developed and distributed.

00:10:51.751,00:10:57.490
When you publish an applications
you need to spec- uh CAST
receiver URL, hardware, Google

00:10:57.490,00:10:59.993
does not automate CAST Apps.
then we can specify as a webpage
in any contact. Remotely trigger

00:10:59.993,00:11:01.928
Google Home to us at any
webpage. If if the attackers and
our Google Homes are in the in

00:11:01.928,00:11:06.933
the LANS the attackers can also
send the CAST protocols such as
the launch APPs through CAST.

00:11:16.543,00:11:22.215
This request will directly
trigger Google Home’s except to
the CAST receiver URL. to make

00:11:22.215,00:11:28.821
matters worse if the router in
the victim’s homes homes, uh
turn on the UPMP port following

00:11:28.821,00:11:34.093
the attacker can also complete
the remote sing in attacks on
the internet. The attackers

00:11:34.093,00:11:39.098
modified CAST u- uh receiver URL
webpage to a malicious uh page.
Lets Google Homes may assist in

00:11:42.735,00:11:47.740
renders after visiting the page.
So now we only need to a Chrome
RCE vulnerability to exploit

00:11:52.312,00:11:57.317
Google Homes. Now Wenxiang Qian
will introduce um Magellans and
other vulnerabilities. >>Um ok

00:12:05.191,00:12:10.930
thank you for uh the
introduction. Now I will
continue with uh part 3. Uh

00:12:10.930,00:12:15.935
fuzzing and uh manual auditing
SQLite and Lib Curl. Uh first
why do I audit this to

00:12:19.005,00:12:24.677
libraries? Um because third
party libraries are always
sweet. They have less code and

00:12:24.677,00:12:29.682
uh focused functions and almost
every device has them installed.
And the most important thing is

00:12:31.718,00:12:36.723
Google Home or Google Chrome are
using them too. Uh before
introducing the code audit part

00:12:39.959,00:12:45.832
I would like to mention some
previous researches. Uh first
Michal Zalewski fuzzing has

00:12:45.832,00:12:50.837
significantly improved the uh
SQLite quality. And then there
is a talk on Black Hat in 2017

00:12:53.773,00:12:58.778
which also explains the idea of
exploiting SQLite. And after
there doesn’t seem to be a lot

00:13:00.913,00:13:06.586
of news about the
vulnerabilities of SQLite. But
we have found some. In the next

00:13:06.586,00:13:11.991
part, we will introduce the code
auditing and the exploiting of
Magellan. Which is a search of

00:13:11.991,00:13:16.996
vulnerabilities in SQLite. And
DS which is a search of
vulnerability vulnerabilities in

00:13:20.033,00:13:25.038
Lib Curl. The Chrome project
come with a father for SQLite.
Uh we have made some simple

00:13:27.874,00:13:33.913
changes to it uh such as adding
use sum send text based first.
When we look back we found that

00:13:33.913,00:13:40.153
there were uh were was a lot of
crash files generated. However,
these test cases only trigger

00:13:40.153,00:13:45.158
empty pointer de-referencing.
One of this test crashes is
caused by duplicate primary keys

00:13:47.293,00:13:52.098
and when I was bugging, I typed
the first three, create the
tables statements to see what

00:13:52.098,00:13:57.103
was going on in memory. However,
I was surprised to find that the
dot tables command showed 6

00:13:59.439,00:14:04.377
tables. The question is uh what
else content, segdir, segments
sent for? The SQLite manual

00:14:09.182,00:14:14.187
shows that the tables are called
shadow tables. The 5 types of
shadow tables content, segdir,

00:14:16.355,00:14:21.360
segments are FTS3 or 4 and stat
and docsize are FTS4 only.
However, because of the tables

00:14:25.264,00:14:29.802
are treated like standard
tables, you can create
corresponding stat and docsize

00:14:29.802,00:14:34.807
table, even you are operating on
a FTS3 table. Uh you can create
stat and docsize by simple uh by

00:14:37.777,00:14:42.782
simple create a table statement.
Because SQLite itself is doing
this too. And FTS3 and 4 is

00:14:44.984,00:14:50.656
sharing some code which means
stat and uh docsize might change
the code flow in some

00:14:50.656,00:14:55.661
conditions. For example, one of
our exploit uh simulating an
FTS4 on FTS3 environment. This

00:14:59.699,00:15:06.139
is useful because some some
software like Chrome use only
FTS3 and explicably disable

00:15:06.139,00:15:12.378
FTS4. This would extend the
attack surface by entering some
code branch that should never be

00:15:12.378,00:15:18.785
entered. The shadow table is
used as a container to store the
content of the four tag search

00:15:18.785,00:15:23.790
metadata. What is shown on this
slide is uh definition and
meaning of each Shadow table. We

00:15:26.259,00:15:32.498
can see that almost every Shadow
table has a field of type BLOB.
That’s because to support four

00:15:32.498,00:15:38.971
text queries, FTS maintains an
inverted index that maps from
each unique term or word that

00:15:38.971,00:15:43.743
appears in the data set to the
local- locations you- which it
appears within the table

00:15:43.743,00:15:49.816
contents. It is complicated, but
all we know is that compared to
the other fields, those BLOBs

00:15:49.816,00:15:54.821
may have an important influence
on FTS queries. In SQLite the
real binary data is typically

00:15:58.624,00:16:04.263
present in the form of x single
quotation mark and uh
hexadecimal numbers. However,

00:16:04.263,00:16:10.169
the BLOBs here are binary data
to represent the entire BTREE.
Since it represents such a

00:16:10.169,00:16:14.507
complex structure, is it
possible to create a memory
corruption vulnerability by

00:16:14.507,00:16:19.879
destroying the data of the
structure? Let’s read about the
document of the serialized data

00:16:19.879,00:16:24.884
structure first. You can check
the SQLite manual to easily get
the definition. I will show you

00:16:27.553,00:16:33.059
a simplified version so you can
understand what I’m modifying
when I’m trying to exploit them.

00:16:33.059,00:16:37.330
Basically I’m modifying the
bytes with a different
functional sections to mislead

00:16:37.330,00:16:43.703
the code flow. The first segment
B-Tree leaf nodes, the first
term stored on each node which

00:16:43.703,00:16:50.443
is term 1 in the figure above is
stored [inaudible]. Each
subsequent term is prefixed,

00:16:50.443,00:16:56.849
compressed with respect to its
uh to its producer. In the real
nodes, non-leaf nodes have

00:16:56.849,00:17:01.787
different structure. And then
the doclist format. A doclist
consists of an area of 64 bit

00:17:04.624,00:17:09.629
signed integers. Serialized
using the FTS4 inch format. Each
doclist entry is made up of a

00:17:11.797,00:17:18.471
series of two or more integers
as follows. One the docID value
and two the zero or more term

00:17:18.471,00:17:25.044
offset-list. In general, those
BLOBs that just serialized the
B-Tree data when the SQLite

00:17:25.044,00:17:30.917
wants to perform operations on
those tables, it will simply
deserialize or pass this BLOBs

00:17:30.917,00:17:35.922
to get a complete B-Tree. Then I
have found some problems. The
problems are mainly treated to

00:17:38.891,00:17:44.363
merge and match. Because they
are deeply related to the
B-Tree, two of the merge the

00:17:44.363,00:17:50.770
node of the tree and other is to
traverse nodes of the tree to
find the match to the content.

00:17:50.770,00:17:56.309
Also the last one is the crash I
mentioned before. It was that
brought uh serious problems into

00:17:56.309,00:18:02.848
my attention. And software must
enable FTS3 support and support
external cycle query to trigger

00:18:02.848,00:18:07.853
this problem. Ok, the first one
and 20346 which is also the main
vulnerability we use lately to

00:18:12.325,00:18:18.631
exploit Google Home. It requires
a lot of complex, pre-conditions
that is we have to carefully

00:18:18.631,00:18:23.269
construct a lot of tables and
content. But once the
pre-conditions are met,

00:18:23.269,00:18:30.042
vulnerability exploitation will
be very simple and stable. The
vulnerability is located in the

00:18:30.042,00:18:35.047
function FTS3 append to node. It
can be triggered with a special
symantec. The merge equals 1 2.

00:18:37.984,00:18:42.521
Which means a level to be
merged. As you can see, this
function will try to append a

00:18:42.521,00:18:47.626
node to another. The node is
stored in the blob. So this
function and other function will

00:18:47.626,00:18:52.798
first parse in the B-Tree and
then get a start position and
the learns of a binary data of

00:18:52.798,00:18:58.637
the node that will be processed.
And last, perform the memory
copy operation to copy them into

00:18:58.637,00:19:03.576
a new BLOB that represents a new
Tree. Ok, lets go to this caller
function. Uh Truncate Node. If

00:19:07.780,00:19:13.252
you get the binary of set and
learns from the BLOB data that
will describe the node being

00:19:13.252,00:19:18.391
processed. Then the node
information is returned in the
reader object, passed to the

00:19:18.391,00:19:24.864
vulnerability F- uh FTS3 append
to node. To control the memory
copying append to node, we need

00:19:24.864,00:19:29.869
to control adoclist and nDoclist
which is returned from node
reader next. The edoclist is a

00:19:31.904,00:19:38.077
source of the char pointer to
the blob data and nDoclist is
the node size. Which our second

00:19:38.077,00:19:43.082
and third parameter of memory
copy respectively. To control
them is not a difficult thing.

00:19:45.684,00:19:50.756
Let’s read the code then you
will know what I’m saying that
is easy. To save the space of

00:19:50.756,00:19:57.430
storing an integer. SQLite use a
variant integer or a reason. You
can just consider FS get varin

00:19:57.430,00:20:03.903
32 as a function to convert a
bunch of bytes into an integer.
And to else store the result in

00:20:03.903,00:20:10.076
nSuffix. Then it moved the
current cursor by adding the
content of bytes and it write it

00:20:10.076,00:20:16.415
to iOff. The data for a node is
stored as a list following by
corresponding data with exactly

00:20:16.415,00:20:22.488
size of a list. Normally they
should appear in pairs, but we
can modify the blob to make the

00:20:22.488,00:20:27.493
end of the blob binary as only
in the list field, but no data
field. Ok let’s go to the append

00:20:30.629,00:20:36.969
to node. Since uh in the last
step adoclist and nDoclist is
controlled, we can now overflow

00:20:36.969,00:20:43.976
the buffer of pNode a in lines
310. Or we can copy some raw
memory data to it. As long as it

00:20:43.976,00:20:49.381
does not exceed the allowed
value. Then we can query the new
table to get the leaked raw

00:20:49.381,00:20:55.654
memory. By setting up adjacent
tables we can overflow the
function pointers of table very

00:20:55.654,00:21:00.593
uh accurately to exploit a code
execution. And here’s another
one. Uh 506 in functions scan

00:21:03.028,00:21:07.600
interior node and the
precondition of this one is
rather simpler. All you need to

00:21:07.600,00:21:13.472
do is modify the shadow tables,
se- huh, set a node in secd are
two now root node. You can

00:21:13.472,00:21:19.311
change the BLOB data to change
the code flow. Query the
modified table by QR match, then

00:21:19.311,00:21:24.817
the code will scan every node
inside the B-Tree. Then the code
will trigger memory corruption

00:21:24.817,00:21:30.789
because it has many constrained
conditions. It was considered to
be very hard to exploit. Um, but

00:21:30.789,00:21:36.462
this one is the is is possible
anyway. Uh you can check the
wonderful write up by a Korean

00:21:36.462,00:21:41.467
researcher named Wenxiang And
last on 20505, this one is very
like to a combination of the

00:21:43.969,00:21:49.942
previous two. The vulnerable
function is uh set to a reader
test. You can modify to a shadow

00:21:49.942,00:21:56.148
table and basically the code
flow. All these three
vulnerabilities can be modified

00:21:56.148,00:22:01.854
to leak raw memories so we can
also use this to leak address of
uh for examples functions

00:22:01.854,00:22:06.859
structures global variables,
constant variables to bypass the
ASLR. And here’s another one.

00:22:09.028,00:22:15.968
Lib Curl. Um, our targ- our
target is uh remote code
execution, but lib curl has

00:22:15.968,00:22:21.941
already been used by a lot of
users and their code it was very
quickly to to find a vulnerable

00:22:21.941,00:22:27.313
function, here are some
guidelines for finding problems
by reading the code quickly. The

00:22:27.313,00:22:33.652
first find big functions. Most
with a lot of lines is not
recommended in software

00:22:33.652,00:22:39.258
engineering. And functions that
are too long should be
refactored into shorter function

00:22:39.258,00:22:43.796
fragments. Usually such a large
function is difficult to test
and there will be a lot of

00:22:43.796,00:22:49.768
attack surface. And most of a
functions seenable in lib Curl
is related to remote

00:22:49.768,00:22:54.940
interactions and communicate
with a remote server more than
once. After carefully sifting

00:22:54.940,00:22:59.945
through the protocols we
confirmed that NTLM over HTTP
was what we wanted to test. And

00:23:03.849,00:23:09.455
here are those problems we have
found in lib Curl. We named them
as Dias. Um name of another

00:23:09.455,00:23:14.460
famous navigator. The first one
um 890 is a vulnerability NTLM
Type-2 message. It can leak at

00:23:17.363,00:23:23.836
most 64 kilobytes client memory
per request to attacker. The
result is very like to to the

00:23:23.836,00:23:29.975
heartbleed but is the client
version. And the second one 3822
is a vulnerability in type-3

00:23:29.975,00:23:36.415
message. It will result in a
stack buffer overflow. Lanquist
also wrote this in his blog and

00:23:36.415,00:23:41.420
so this very bad security issue.
Ok let me show you how this
happen. The first one. The

00:23:44.523,00:23:50.496
vulnerable function is in the
code type 2 target and there is
a setting to be integer from the

00:23:50.496,00:23:57.236
type 2 message header. Then we
know we can set info of set with
a larger value. And target info

00:23:57.236,00:24:03.976
len to a profit value which if
you added them together an
integer overflow will happen.

00:24:03.976,00:24:10.516
The overflow restart is very
small and will pass the check in
line YH5. And next memory copy

00:24:10.516,00:24:16.722
where copy data out of bugs. For
example if we use the value
above it will act- actually copy

00:24:16.722,00:24:22.528
data from the front of variable
buffer. Instead into beat
environment. And then the data

00:24:22.528,00:24:28.600
will be sent to the attacker in
type-3 message, leaking maximum
and 64 kilobytes data per

00:24:28.600,00:24:33.605
request to the attacker. And
let’s go to 382. This
vulnerability is located in the

00:24:37.042,00:24:43.215
big function name curl offscript
NTLM type-3 message. In the
beginning this function declares

00:24:43.215,00:24:48.220
a lot of variable on stack
memory. The NTLM buffer is a big
buffer which has around uh 4 uh

00:24:50.622,00:24:56.028
kilobytes memory. Then the
function tries to read NT
response list from the Type-2

00:24:56.028,00:25:01.567
response which is sent from the
server. Attack could return a
value bigger than the buffer

00:25:01.567,00:25:06.572
size 2 client. And next in line
779 let’s check. Should check if
the size of the data is bigger

00:25:09.708,00:25:16.648
than NTLM buf remaining size.
But the inexplicit sign outside
the cast prevents the check from

00:25:16.648,00:25:23.555
operating correctly. This check
compares two unsigned variable
and a marco ntlm buf size which

00:25:23.555,00:25:30.329
simply defines a number a solid
and the 24. But this value is a
signed integer in the view of

00:25:30.329,00:25:35.334
compiler. When unsigned and
signed are compared in the same
place, some of them must be

00:25:37.536,00:25:43.575
casted in order to compare
correctly. And this is a
problem. The compiler prefers to

00:25:43.575,00:25:48.914
convert signed to unsigned
numbers. So if we have nt
response length greater than nt

00:25:48.914,00:25:54.920
lm buff size the result will be
a large unsigned number. And it
is of course bigger than the

00:25:54.920,00:26:01.760
remaining size we are pass the
check. In line 781 because nt
respons is bigger than the

00:26:01.760,00:26:06.765
remaining size of ntlmbug hence
there will be a stack buffer
overflow. When the code triggers

00:26:10.135,00:26:14.807
a stack buffer overflow, the
overflow variant is in the
middle of a lot of stack

00:26:14.807,00:26:20.212
variables. Although the program
may have stack cookies and
attacker could choose not to

00:26:20.212,00:26:25.184
follow that match bytes, but
instead override stack variance
and control the flow of the

00:26:25.184,00:26:30.889
code. I marked the position
where the where it triggers the
buffer overflow. You can see in

00:26:30.889,00:26:36.495
this big function, they are al-
they are almost 80 lines after
it. And many of them are

00:26:36.495,00:26:42.901
operating heap or stack memory
and operating is based on the
value of those stack variables.

00:26:42.901,00:26:47.906
But the reason why I say big
function is never good coding
practice. Ok, my part is done.

00:26:49.908,00:26:54.913
And uh YuXiang will go ahead to
introduce how to exploit. >>Uh
thank you for partners

00:27:04.423,00:27:10.529
introductions. Now uh lets
review the following uh
vulnerabilities. The keys

00:27:10.529,00:27:15.534
vulnerability trigger is how to
use the insert date to control
the variables used by our memory

00:27:18.203,00:27:23.208
c- memory counting function in
group pn uh pnode a, pnode n and
adoclist, doclist. The insert

00:27:25.878,00:27:30.883
data is as follow. First the
entire date is store in a buffer
of pnode a uh we can control the

00:27:33.986,00:27:38.991
size of the pnode a. But first
by modifying the length of the
insert date. Uh in hex functions

00:27:41.593,00:27:46.598
we are able to allow pnode a to
the appreciate areas to cover
the attacking me- memory. In

00:27:50.903,00:27:55.908
this state, uh the orange colors
indi- indicate that’s the size
of pnode n and p- uh and

00:27:58.410,00:28:03.348
nDoclist. Which is we are int
type. Ndoclist is used to
control the length to be

00:28:06.485,00:28:11.490
overflow uh pnode n which is the
obsess or the write overwritten
memory areas. The green part is

00:28:14.426,00:28:19.431
the a- adoclist status. Which
can be used for rp read or rp
write. The next section uh we

00:28:25.037,00:28:27.039
will introduce the ideas of
using these vulnerabilities. We
expect expect to find uh a

00:28:27.039,00:28:32.044
function pointers that can be
used on a heap. Then creating
our FTS tree tables the token is

00:28:40.252,00:28:45.257
uh create by default. And the
token is uh default is simple
tokenizer. Uh as shown in uh

00:28:48.694,00:28:53.699
following pictures, simple
tokenizer is the structures on
the heap, where is um members

00:28:56.101,00:29:01.039
base points to the sql 3s
tokenizer structures. The
members pmodule or the sql 3

00:29:04.409,00:29:09.414
tokenizer structure points to
the tokenizer module. The
tokenizers module contains the

00:29:11.416,00:29:16.421
some interesting functions uh
callback functions. Such as the
xcreate, xopen [inaudible] when

00:29:19.024,00:29:25.430
is inserting FTS3 tables, the
xopen callback functions will be
triggered. Uh if a function Uh

00:29:25.430,00:29:29.901
if a function will be triggered.
Uh if a function address up
xOpen can be modified to the at-

00:29:29.901,00:29:34.906
a attributes uh address the PCs
can be highjacked. And how to
use the uh variables functions

00:29:40.912,00:29:45.917
pointers for PC highjacking. Uh
here’s two conditions need to be
met. The first after his table

00:29:48.186,00:29:53.191
froze is necessary to be able to
operate the fts3 tables. In
addition, when highjacking is to

00:29:56.461,00:30:01.466
be compilate before the memory
is produced otherwise the crash
will be interrupt. By analyzing

00:30:03.602,00:30:08.607
the logical uh memory copy to
frees, we found it interesting
function. Uh which performed uh

00:30:11.677,00:30:18.417
as uh secure update operation
before listing the memory. And
so in the the protect code.

00:30:18.417,00:30:21.420
Finally, we use the at sql
triggers to perform the fts3
table inert operation before the

00:30:21.420,00:30:26.425
secure update operations and
free memories. Since uh
triggering the xopen callback

00:30:34.766,00:30:39.771
functions, so that’s the PCs can
be highjacked. The next stage is
to mirror memory a layouts. The

00:30:45.143,00:30:50.148
SQL logic code of the Cast shell
use tmalloc a feasible memory
layout idea eh as forced.The

00:30:52.651,00:30:57.656
first by creating a mou-
multiple first uh fts3 tables,
we will create a multi- multiple

00:30:59.991,00:31:04.996
simple tokenizer structures,
drop the previous uh created
fts3 tables at a appropriate

00:31:07.933,00:31:12.938
table. Uh the simple token is
the structure we will be free.
The uh reassigning payload of

00:31:15.173,00:31:20.712
the same size as simple
tokenizers eh- it has the high
uh prob- probabilities that

00:31:20.712,00:31:22.714
payloads will be allowed to the
private release simple tokenizer
structures. So our payloads has

00:31:22.714,00:31:24.716
a greater change of operating
the simple tokenizer structures
of existing of fts3 tables. With

00:31:24.716,00:31:29.721
the s- sql triggers that perform
operations of fts3 tables,
before the 3. Last a change,

00:31:37.496,00:31:42.501
that’s the tokenizer model call
their functions uh will be
triggers to hijack the PC. Uh

00:31:54.479,00:31:59.484
when we have the ability to
hijack the PCs and control the
odd zero rejectors, we only need

00:32:01.520,00:32:08.293
to be able to leak information
and bypass ASLRs. The previous
sections. Uh uh also intro-

00:32:08.293,00:32:13.298
introduce, uh we can try to uh
address the the ndoclist pNode a
and leak memory after heap. We

00:32:16.835,00:32:23.441
need to describe the following,
two types of address. Leaking
address of cast shell based on

00:32:23.441,00:32:28.446
uh based on this address and
upsets calculate the require ROP
gadgets. Uh leading address of

00:32:30.549,00:32:36.955
the last heap, according to this
address and upset the
probabilities and calculating

00:32:36.955,00:32:41.960
the address of the heap spray.
The last is the heap sprays and
ROPs. After this three test, we

00:32:49.434,00:32:54.439
can ask this in google homes
renders. A cast shell is uh lack
binary program that contain many

00:32:57.209,00:33:03.882
of the uh variable ROP gadgets.
So the ROP gadget used cast
shell is most stable and

00:33:03.882,00:33:08.887
convenient. In the uh in the
pictures on the right the
realized amongst the red lines

00:33:12.290,00:33:17.295
mark the heap spray unit. Which
sprays tokenizer models and ROP
gadget. The xcreate, xopen

00:33:21.333,00:33:26.338
address in the first tokenizer
model structures will be aside
the stack hardware address. The

00:33:30.141,00:33:36.648
blue lines marks our first
simple structure of a tokenizer
structures. When the arbitrary

00:33:36.648,00:33:41.653
tables operate can be triggered,
SQLite will get a model shell
xopen through the structures of

00:33:47.325,00:33:52.330
simple tokenizer and then RCE.
Abust- above is the screen shot
of our RCE in cast shell that

00:33:56.001,00:34:00.939
reprogs on the last so that the
register we can control that
that layout Mozilla 11 the

00:34:03.441,00:34:08.446
function chat is read from the
11s and finally goes to prx.
Then as the result we have been

00:34:12.083,00:34:17.088
able to hijack the PC. The uh
imagine on the device uh so
should uh result of our shell

00:34:19.491,00:34:24.496
codes. The SQL Javascript codes
for fetch, your OS and uh
navigators appname in the exp

00:34:28.633,00:34:33.638
get doc html calls. Normally, uh
negotia- uh navigators appname
is read only and a and its next

00:34:38.743,00:34:43.748
skip, but our shell code changed
the appname to AAAA. Uh lets
look at some extra attack sends.

00:34:49.754,00:34:54.759
There are three types of attack
web tools that attack Google
homes remotely. First the

00:34:56.828,00:35:01.766
attacker is located in the LAN,
the attacker send the launch
APPID 1 command through uh uh

00:35:04.636,00:35:09.641
cast protocol and google homes
will pull the leak dot html on
the application application

00:35:12.677,00:35:17.682
stop. APP stops according to the
APPID and load it. At this times
le- leak days can be obtained by

00:35:20.385,00:35:22.387
the attackers. The second the
attackers send launch APPID 2
commands, uh google homes loads

00:35:22.387,00:35:27.392
exp dot html, so that’s the RCE
happen. The entire process does
not require your interaction. In

00:35:39.004,00:35:45.043
the other tools senders. You
don’t need to be on the send uh
on the send LANs to start the

00:35:45.043,00:35:50.048
attacks. The attacker invites
the victims to asses the URLs of
the sender application and we

00:35:54.285,00:36:00.492
can scan the networks on the
routers that uh if the router
have the upnp forwarding try- uh

00:36:00.492,00:36:05.497
we can try to launch remote
remote attacks. On an internet.
Conclusion. Here the here is the

00:36:11.770,00:36:16.775
timelines of the Magellans. We
have reported in uh November and
its create fix by SQLite in uh

00:36:19.511,00:36:24.516
Chrome in the Decembers. Google
decide to give us the $10,000
reward for the bunch of

00:36:27.052,00:36:32.057
vulnerabilities and they have a
an an they have a enhancements.
There is the defense in-depth

00:36:34.993,00:36:39.998
flag. Disallowing modifying
shadow tables from untrusted
source. For backwards

00:36:42.834,00:36:47.839
compatibility it is default off
in the sqlite so if you are
using sqlite with fts, you may

00:36:51.710,00:36:58.483
want to enable this one or two
proven attacker. From the
modifying your shell table. But

00:36:58.483,00:37:03.421
uh the good news is is default
on in go- in Chrome from commit
in the last November. Here is

00:37:09.360,00:37:14.365
the timelines of Dias. These
could create fix and release by
lib Curl in two weeks. Also, uh

00:37:20.171,00:37:25.176
uh also we have a noted uh since
uh two urge dis- disable the
vulnerable FTS3 or WebSQL before

00:37:31.382,00:37:36.387
the patch come out. If they
don’t use these features. And uh
we have not- notified security

00:37:39.524,00:37:44.529
teams of Apple, Intel, Facebook
and Microsoft about how to fix
the problem and how to mitigate

00:37:47.599,00:37:52.604
the threats in some of their
products. Uh to analyze the
securities otherwise, enhance

00:37:57.942,00:38:02.881
your systems with the newest
available defense in depth
mechanism in time. Two keep your

00:38:05.850,00:38:10.855
uh do- the third party libraries
up to date. Three, improve the
qualities of security auding- uh

00:38:14.058,00:38:20.231
auditing and testing of the
third-party libraries. Fourth,
introduce security

00:38:20.231,00:38:25.236
specifications into the
developments and testing. Thank
you. [applause]

