00:00:00.000,00:00:05.005
>>Alright we’ve got a talk here
on weaponizing hypo-hypervisors
by Ali and Dan uh and we have a

00:00:07.274,00:00:13.881
little tradition here uh at
DefCon for those that are new to
speaking at DefCon and the- does

00:00:13.881,00:00:18.886
anybody know what that is?
>>[audience] shots? >>yeah
[laughter] >>thank you >>thank

00:00:24.658,00:00:31.598
you >>so this is called shoot
the noob uh and uh you know
those of you can cheer them on

00:00:31.598,00:00:36.603
as we do our shot here for the
first time speakers. [applause]
alright, good luck fellas.

00:00:38.972,00:00:43.977
>>Thank you. Can we start >>Yeah
go ahead >>Hey guys, thank you
for coming, uh really excited to

00:00:52.986,00:00:59.559
be hear uh it’s our first time
as you saw. Uh I am Ali Islam I
am the cofounder and CEO of

00:00:59.559,00:01:05.866
Newman. Uh I have been in the
cyber security industry for last
uh 13 plus years. And for a long

00:01:05.866,00:01:12.606
time I was working for a company
called Fireeye it’s another
cyber security company. Soooo,

00:01:12.606,00:01:18.812
that’s yeah, Dan you wanna?
>>[clears throat] hey guys my
name is Dan Regalado um I am so

00:01:18.812,00:01:25.185
excited to be here because you
know it’s the first time DefCon
so so glad and and blessed y

00:01:25.185,00:01:30.190
quiero agradecer mi esposa y mis
hermanos y los amigos, esta de
mexicana de aqui senores

00:01:35.963,00:01:42.903
[applause] mi- make DefCon speak
Spanish [cheers] >>haha cool,
okay let’s uh, let’s get

00:01:42.903,00:01:49.242
started. So, here’s a quick
overview of like how we organize
our talk, so we’re going to

00:01:49.242,00:01:53.380
introduce some- some of the
basic concepts. Uh, these
concepts are really important

00:01:53.380,00:01:59.786
uh, and kind of a foundation
upon which we build our later
detection cases uh and you know

00:01:59.786,00:02:04.791
other policies. Uh apart from
that, uh then we’re going to
explain the enviro- whole

00:02:04.791,00:02:09.129
embedded environment, the
journey you know setting up the
bull and uh you know the

00:02:09.129,00:02:15.068
environment that they play in.
And then we’re going to talk
about the very important VMI on

00:02:15.068,00:02:21.775
ARM uh I’ll explain shortly what
VMI is. And uh finally we’ll
discuss about different attacks,

00:02:21.775,00:02:26.780
uh use cases and some other
recommendations um. Okay, so um,
why is hypervisors so important

00:02:33.587,00:02:38.592
and relevant? Uh, as you can
see, uh all of the major players
automotive grade linux, Renesas,

00:02:41.328,00:02:46.333
uh DENSO, and ALIBABA NXP, uh
Perrone robotics, uh you I mean
there are many, uh Green Hill,

00:02:50.437,00:02:57.044
Intel, they all have now the
hypervisor in their
architecture. And, uh, the

00:02:57.044,00:03:01.381
traditional use case for
hypervisor is basically the
efficient utilization of the

00:03:01.381,00:03:06.386
resources and uh probably the
isolation use case, uh, however,
uh not many people have explored

00:03:09.556,00:03:15.862
hypervisor uh for security in
terms of uh you know how you can
use hypervisor to build a really

00:03:15.862,00:03:22.169
good security system. Uh,
isolation is there but not the
VMI uh that we’re gonna talk

00:03:22.169,00:03:27.174
about. Okay, so um what the
beauty of hypervisor is that it
exposes an interface which is

00:03:30.710,00:03:34.715
called uh you know the
introspection interface, it’s
also called washer machine

00:03:34.715,00:03:41.455
introspection. What it does or
uh it allows you to do is um you
can monitor the whole system

00:03:41.455,00:03:46.560
from the outside. Uh that’s
really powerful and uh, we
haven’t seen many people using

00:03:46.560,00:03:53.433
it especially on the ARM um so
you know, we very, very excited
to start on it and it was a

00:03:53.433,00:03:59.840
long, very hard journey because
there’s not much out there-there
like few projects and papers out

00:03:59.840,00:04:04.778
there um, so, traditionally the
anti virus we all know that it
has a lot of issues it sucks,

00:04:09.249,00:04:15.655
but um, mainly you know when the
anagrams malware comes into the
system uh the first thing uh it

00:04:15.655,00:04:21.261
does, is basically check if
there’s an agent inside or if
some- somehow it’s being

00:04:21.261,00:04:27.300
monitored. And um, uh if you’re
sitting outside of the printing
system you saw that very

00:04:27.300,00:04:33.373
important problem automatically.
You so basically you have that
sophisticated invisibility.

00:04:33.373,00:04:38.178
Apart from that uh not having
anything inside the operating
system also helps with the you

00:04:38.178,00:04:43.283
know uh the different
certifications because you’re
not messing up with the device

00:04:43.283,00:04:47.888
functionality. Imagine you know
you’re securing a car
infotainment and then you know

00:04:47.888,00:04:52.292
certainly you know there’s a bug
in your software which kind of
messes up everything right so

00:04:52.292,00:04:57.297
you don’t want that. Okay, so
let’s get started, on the on the
VMI um what is, what is VMI or

00:05:01.301,00:05:07.774
what-what kind of interface
hypervisor expose. Basically
what you have is raw memory, and

00:05:07.774,00:05:13.947
um you take the raw memory and
you use some of the os specific
knowledge to actually make sense

00:05:13.947,00:05:19.819
out of it. For example, you
should really know where kernel
is doing what and um and then um

00:05:19.819,00:05:26.059
you know you kind of like build
your logic around it to really
make sense out of it. For

00:05:26.059,00:05:31.064
example, if you-if you uh take
the raw memory and you know
where the uh linux task list is

00:05:33.633,00:05:38.738
stored in the memory you can go
to those offsets and then you
can start decoding and you know

00:05:38.738,00:05:43.743
finally as you can see here you
can uh decode the task list and
traverse the task list from the

00:05:46.580,00:05:53.053
rom memory. Uh, to give you an
example um, for example if you
have to read a Kernel symbol

00:05:53.053,00:05:58.592
value from the rom memory, you
know it looks like a simple
thing if you are inside the

00:05:58.592,00:06:05.198
operating system. However, from
a VMI it’s a very complex uh
process. So, what will happen is

00:06:05.198,00:06:11.838
um, first of all you know, once
you say hey you know, I- I want
to read the val- value of this

00:06:11.838,00:06:16.843
virtual address, first of all,
vmi by the way we are using
LibVMI um we highly recommend

00:06:19.112,00:06:24.117
it’s an open source project, it
kind of provides the basic
functionality uh that you need

00:06:24.117,00:06:28.188
and on top of that we build our
own functionality. Some of the
basic functionality might be

00:06:28.188,00:06:33.326
like the you know I’ll explain
you shortly like once this is
done, for like the caching

00:06:33.326,00:06:38.732
and-and some of those uh
capabilities so uh we really
recommend using LibVMI. So, what

00:06:38.732,00:06:44.304
will happen let’s say if you
have to read the value. Uh,
you’ll get the virtual address,

00:06:44.304,00:06:50.710
LibVMI will first go and check
with the system map, uh to see
you know where the virtual

00:06:50.710,00:06:55.715
address is and then um, take
that and then um, map it to the
page directory. Um the page

00:06:58.618,00:07:03.556
directory will be added uh to
some of the bytes from the
virtual address to map the page

00:07:05.992,00:07:12.832
table and finally to the actual
physical location in the memory.
And then, it will come back and

00:07:12.832,00:07:19.205
give that value back to the VMI
application. So, that's the-
that’s the general flow of uh

00:07:19.205,00:07:25.912
you know can uh get the
value-value out. Uh, also uh
here you can see that once you

00:07:25.912,00:07:31.651
go through this process you’re
not gonna do that again for this
particular uuuuhhhhh virtual

00:07:31.651,00:07:37.390
address. That’s where again
LibVMI comes it has a very
efficient caching mechanism, you

00:07:37.390,00:07:42.996
can do on your own also but you
know, incase you want to wipe
some of that work you can just

00:07:42.996,00:07:48.001
simply use the LibVmi. Okay,
another very important uh
concept that is critical to you

00:07:50.236,00:07:55.909
know what- what we’re going to
show today as single stepping.
Uh, because we’re going to show

00:07:55.909,00:08:02.449
eventually how you can um get
the system calls out, uh by
staying outside of the operating

00:08:02.449,00:08:07.454
system through VMI and the raw
memory. So, I’m sure you have
all used debuggers and single

00:08:10.256,00:08:15.261
stepping in your own use cases
including reversing, however uh,
the-the-the-there are other uh

00:08:18.064,00:08:22.335
single stepping and break point
mechanism that I want to quickly
touch on, the hardware

00:08:22.335,00:08:27.340
breakpoints is basically um-um a
really useful code that sits in
the room uh so basically uh when

00:08:31.678,00:08:37.384
the code is not in the ram you
cannot overwrite the breakpoint
instruction so what you do is

00:08:37.384,00:08:44.357
um, you have these special
registers provided by ARM and
intel for example on intel it’s

00:08:44.357,00:08:49.362
D02D3 um and you store-store uh
locations uh memory location
value in those registers and

00:08:52.766,00:08:58.705
then when a program counter
comes to that particular
location or that instruction it

00:08:58.705,00:09:03.810
just halts execution and then
you can analyze the whole
system. Uh another is the

00:09:03.810,00:09:08.848
software breakpoints um you know
it’s the most common one CPU
assisted that we use in

00:09:08.848,00:09:14.320
debuggers uh for example, you
will set the trap flag in the e
flags register and then you’ll

00:09:14.320,00:09:21.027
uh- uh let the CPU do the work.
Uh, once the breakpoint hits the
cpu automatically do the single

00:09:21.027,00:09:26.566
stepping. But, what really is
single stepping uh you know when
we say what happens in the back

00:09:26.566,00:09:31.538
end? Uh, so in the back what
happens there’s a special [audio
drops] for example called entron

00:09:31.538,00:09:37.977
uh when the breakpoint hits, you
know you-you do the whole
analysis however, in the back

00:09:37.977,00:09:44.417
end that instruction uh the cpu
makes sure that it also executes
with original instruction and

00:09:44.417,00:09:48.755
then move on and then move on so
that’s very important. And now
the third one is software

00:09:48.755,00:09:53.927
breakpoints with no CPUS so
we’re gonna use that uh, in our
implementation and the reasons

00:09:53.927,00:09:59.866
for that um that I will explain
you once we are done with the
basic concepts but ju-just keep

00:09:59.866,00:10:05.572
that the concept the single
stepping concept in your mind.
Um apart from that uh in our

00:10:05.572,00:10:10.577
implementation, as I said right
you’re playing with the live raw
memory so you really need to

00:10:10.577,00:10:17.050
know how the kernel internals uh
and how the kernel is you know
organizing the memory how

00:10:17.050,00:10:22.856
everything is uh working inside.
So, you ha-you need to have that
uh basic knowledge. So uh, we

00:10:22.856,00:10:27.260
all know that um, from quite
some time we now have the
paging, the virtual addressing,

00:10:27.260,00:10:32.832
um since two word six we have
the real-real addressing mode
ended um and then this is a

00:10:32.832,00:10:39.806
depictal two level uh paging uh
we also call it slat, second
level address translation or you

00:10:39.806,00:10:43.943
know the an-and it is
implemented using the standing
page table and the

00:10:43.943,00:10:49.249
virtualization exten-uhhh
extensions that the newer
architectures provide nowadays.

00:10:49.249,00:10:54.254
Um, so to quickly follow the
flow uh like I was saying, for
example if you are going to read

00:10:57.557,00:11:02.495
a value this is how it looks
like, so basically you take the
first 10 bytes, uh added to the

00:11:04.631,00:11:11.404
Cr3-Cr3 is a special register
which stores the base of the
page directly, and you add that

00:11:11.404,00:11:18.011
um 10 bytes of the Cr3 and then
uh it takes you to the base of
the page table entry and there

00:11:18.011,00:11:23.283
you can then depict the next 10
bytes and then you add them to
get to the right page table and

00:11:23.283,00:11:28.821
finally you add the 12-uh 12
bytes which are the off set into
a specific memory page uh from

00:11:28.821,00:11:33.826
which then you fetch the value.
Okay, this is uh-uh this is
another view of just what I-I

00:11:37.230,00:11:43.836
just explained uh two levels of
translation first, from uh
virtual machine to the VM

00:11:43.836,00:11:48.841
physical uh wh um VM virtual to
VM physical address, and then
from VM physical to machine

00:11:50.944,00:11:56.883
physical. So basically you have
this hardware on uh running
right on top of the by the way

00:11:56.883,00:12:01.387
we’re talking about the bare
metal the type 1 hypervisor
right so-so you have this uh

00:12:01.387,00:12:06.225
hardware, the hypervisor sitting
right on top of it and then you
know there are there are like

00:12:06.225,00:12:11.230
different domains of the VMs.
Um, so the second level of
translation is uh handled by a

00:12:15.134,00:12:20.406
table called extended page
tables and there’s a point of
EPT uh, for example zen

00:12:20.406,00:12:25.411
hypervisors stores that uh per
diem and it is used to uh, do
the translation. Uh, EPT there's

00:12:29.015,00:12:34.020
something very interesting about
EPT. So, what EPT as you guys
can see what EPT is doing it is

00:12:36.489,00:12:41.527
eventually giving you the value
from the memory right. It-It
points to that eventual physical

00:12:41.527,00:12:47.700
location where the where the
value is. And, uh the newer uh
virtualization extensions uh um

00:12:47.700,00:12:52.705
for example Intel and ARM uh
they have um a way where you can
store multiple EPT uh pointers

00:12:56.275,00:13:01.214
uh per diem. Now that is very
powerful because 1) you can uh
each page table there are

00:13:04.984,00:13:10.957
permissions right? So, you can
assign different permissions to
it and um that way you know for

00:13:10.957,00:13:16.329
example you know if you assign,
if you assign permission execute
to one page and then rewrite to

00:13:16.329,00:13:22.802
another page, you know, you can
play with those permissions. Uh,
and I’m gonna show you um later

00:13:22.802,00:13:29.208
in our talk, uh some of the use
cases uh but for now I think
it’s very uh critical you know

00:13:29.208,00:13:34.213
what we gonna do uh uh what we
have implemented in our
implementation. The second uh

00:13:36.716,00:13:42.021
interesting fact about EPT is
like you can as I said you can
store more EPT pointers apart

00:13:42.021,00:13:47.026
from uh partition what you can
do is you can actually point a
EPT to a different memory

00:13:49.696,00:13:55.768
location. Now, what that means
is basically for example if you
are uh you have to translate one

00:13:55.768,00:14:00.707
virtual address right? Uh you
can play with that last level of
translation, and then you know

00:14:02.775,00:14:08.414
at one time, you are uh giving
one value, the other time you
are giving another values.

00:14:08.414,00:14:14.854
Basically, you are using the
same code, you are creating two
different behaviors eh which is

00:14:14.854,00:14:21.527
very powerful um, and there are
many use cases for it and uh you
can see the cosnippet and the

00:14:21.527,00:14:27.867
sin where it stores and and the
permission also. Uh yeah that’s
the one I was talking about like

00:14:27.867,00:14:32.872
for example um, second EPT is
actually pointing to uh another
uh memory location and uh I-I’ll

00:14:35.341,00:14:40.546
also talk to some of the
implementation details uh you
know it’s it looks, it looks

00:14:40.546,00:14:46.753
easy but it’s not that easy so
for example you have to create
um all of the pages in the

00:14:46.753,00:14:51.758
memory yourself, uh what xen-
xen hypervisor for example have
two have API’s so uh but they’re

00:14:53.826,00:14:58.598
not very well documented so you
have to play with them and you
create for example increased

00:14:58.598,00:15:03.069
reservation as one that you can
use to create pages. So, once
you create the pages you have to

00:15:03.069,00:15:08.074
maintain all the mappings, but
you know xen provides the uh
functionality to switch between

00:15:10.376,00:15:15.381
different pointers. And um,
another very uh aspect of this
is like um you know uh this

00:15:18.551,00:15:23.189
switching between different
EPT’s or you can call them the
memory views because essentially

00:15:23.189,00:15:28.060
what you’re doing is you’re
creating different views of-of
the memory so you can present

00:15:28.060,00:15:34.267
one view to one user and other
view to other user and you know
by user, user can be malware

00:15:34.267,00:15:39.272
also. Um, the-the-the best part
is um the VM exit, uh VM exit is
a very uh expensive operation,

00:15:41.641,00:15:47.914
uh what-what why VM exit means
is like when uh you know you’re
running your domain on top of

00:15:47.914,00:15:53.252
hypervisor and certainly the
control has to be transferred to
the hypervisor. What that means

00:15:53.252,00:15:58.758
is hypervisor has to st-store
all of the virtual CPUs inside
that domain, the contacts of all

00:15:58.758,00:16:04.597
those virtual CPUs and then, get
out and get take the give the
control to the hypervisor. But,

00:16:04.597,00:16:11.037
uh switching between these EPTs,
there’s no VM exit so, it’s very
fast and I-I will explain later

00:16:11.037,00:16:15.842
like why performance is very
critical to uh anything you’re
doing especially building a

00:16:15.842,00:16:20.847
protection system using VMI.
>>So okay yeah so, once we
understand the basics eh we

00:16:24.984,00:16:30.590
started playing with an
environment right. When you have
a board to play with this whole

00:16:30.590,00:16:35.595
implementation and in our case
we didn’t have any specific
board so we went to LinkedIN we

00:16:38.030,00:16:44.370
used Google eh sitelinks you
know sitelinks the FBGA graders
and turns out that these guys

00:16:44.370,00:16:49.375
has a pretty cool eh board eh
which is eh MPSoc ZCU 102. The
problem was that that board is

00:16:51.611,00:16:57.383
$2,500 just the starter kit. So,
we talked to those guys, we tell
them hey you know what we have

00:16:57.383,00:17:03.322
this product in mind eh Google
sitelinks they use cheaper,
ship-ship the board to our house

00:17:03.322,00:17:08.160
and then eh with other playing
with with the whole environment.
So, this is the board, it’s just

00:17:08.160,00:17:15.034
a pres a standard eh eh input
and output so we have an SD card
to put the root up fast we have

00:17:15.034,00:17:20.039
ethernet, UART, is JTAG eh and
we have a quad-core A53s that
are the ARMS CPUs dual-core R5F

00:17:25.411,00:17:30.583
so, this is the board that is
very expensive but don’t worry
the ehh when we’re presenting

00:17:30.583,00:17:35.988
these, these can be used in in
any other board. So, the first
thing that we were learning guys

00:17:35.988,00:17:40.993
because in in I am like in
reverser you know exploiter guy
this kind of board I never

00:17:43.262,00:17:47.900
played with it but it’s very
challenging because we are
running same hypervisor in it

00:17:47.900,00:17:53.839
and there is no implementation
in this board with the VMI
introspection on it so it was

00:17:53.839,00:17:57.810
kind of hard for us because
there is no support. So, we
learned that there is a p-p para

00:17:57.810,00:18:03.649
linux project which basically
helps you to eh deploy the whole
eh, eh information into the

00:18:03.649,00:18:08.888
board so that you can put it up.
It’s pretty cool, the only
problem is that um, it works

00:18:08.888,00:18:13.893
with a specific images. So we
have our own xen hypervisor
custom eh, deployment, so, it

00:18:16.629,00:18:21.300
was a problem for us. That’s the
first thing, second thing is
para linux is for site links

00:18:21.300,00:18:27.373
right? What if tomorrow we want
to deploy the same environment
in renesas, NXP, others, so, we

00:18:27.373,00:18:32.044
don’t want to just tie to site
links or regular stuff. So, then
w-we went to Yocto you know many

00:18:32.044,00:18:36.949
of you guys know Yocto really
well- well in my case that’s
like I don’t have any idea,

00:18:36.949,00:18:41.821
i-i-it turns out pretty cool, eh
the only problem was that the
rootfs at the end was PC box

00:18:41.821,00:18:47.159
related that was a pain in the
a** for us because eh once we
happy everything up and running,

00:18:47.159,00:18:51.797
we really need python libraries
to run our machine learning and
stuff, and it was a pain to just

00:18:51.797,00:18:56.602
compile a single library like
tensorflow for example a machine
learning. So, it was pretty

00:18:56.602,00:19:01.640
cool, pretty easy to run but at
the end of the day a PC box
rootfs it was a-a pain for us.

00:19:01.640,00:19:07.947
So we end up choosing
Debootstrap, Debootstrap allows
you to have a rootfs in this

00:19:07.947,00:19:13.986
case ARM64 Debian based flavor,
so you have EPT yet you can
download all the libraries so it

00:19:13.986,00:19:19.892
was the way for us to go better
recommend it instead of the
previous ones. Now, in the Dev

00:19:19.892,00:19:24.330
environment guys, so, you don’t
want to push everything on the
board right because the board is

00:19:24.330,00:19:28.901
like the production environment
so you really want to have a
test environment. So, in our

00:19:28.901,00:19:33.906
case, eh w-we pick uh ch-schroot
we saw wrapper for schroot it’s
pretty cool because we have uber

00:19:36.342,00:19:42.748
tool Intel x64 environment as
you can see in the picture in
-in the bottom. So, with this eh

00:19:42.748,00:19:49.221
Intel based environment via
schroot you can you know you eh
using camo you can chroot into

00:19:49.221,00:19:53.626
the environment, you can do all
your testing install libraries
connect to internet everything

00:19:53.626,00:19:57.997
like you were in the board but
once you test everything then
you can jump into the board it

00:19:57.997,00:20:02.268
pretty convenient for us. Eh
now, let’s boot the board right
so what do we need to boot the

00:20:02.268,00:20:07.173
board? Xilinx casts in a
specific eh debugger which is
called Xilinx System Debugger

00:20:07.173,00:20:12.678
client but it basically does it
reads a tcl file that gives you
that tcl file jus you guys to

00:20:12.678,00:20:18.784
have an idea what basically it’s
doing is gonna boot 4 different
files, the PMUFW which is just

00:20:18.784,00:20:24.557
to setup the p-the clock and the
platform management on the
board, then, the first uh stage

00:20:24.557,00:20:27.793
bootloader is gonna initialize
U-Boot and then U-Boot which is
gonna allow us to boot the

00:20:27.793,00:20:32.798
hypervisor in this case same
hypervisor then the linux kernel
and finally the rootfs, uh and

00:20:35.401,00:20:41.107
the BI31 which is ARM trusted
firmware. We didn’t play with
these components, eh we just use

00:20:41.107,00:20:46.679
them with the versions of
silence and forgot to mention
that if you combine versions eh

00:20:46.679,00:20:51.650
it will never boot the board so
we have a lot of pain eh trying
to play with different version

00:20:51.650,00:20:57.857
and it was not booting. So once
you reach eh this initial state
of JTAG you get into the U-Boot

00:20:57.857,00:21:03.929
prompt and now let’s boot the
board right? So the first thing
is you know the data device tree

00:21:03.929,00:21:08.400
blob, eh that’s where all the
configuration from the board
is-is located. So the first

00:21:08.400,00:21:14.340
thing is the root eh location
right? Where did you rootfs eh
that you want to boot on in our

00:21:14.340,00:21:20.112
case it’s a nasty card partition
as you can see there then, the
second thing is eh we have our

00:21:20.112,00:21:25.651
same hypervisor just converted
into U-Boot format with that
common line and then you start

00:21:25.651,00:21:30.322
booting up the assistant. You
know this is that typical U-Boot
eh command, so the first thing

00:21:30.322,00:21:36.829
is U-Boot eh the xen.dtb which
is the device tree blob in the
specific eh location then you

00:21:36.829,00:21:42.635
boot the eh eh linux kernel,
that linux kernel you see the
80,000 address, that address

00:21:42.635,00:21:47.273
will be exactly the same address
that you have in the DTB,
otherwise, when it is booting

00:21:47.273,00:21:52.378
up, it doesn’t it’s not going to
find the linux kernel address on
the board is not going to boot

00:21:52.378,00:21:57.349
eh and then you load the second
hypervisor and finally you run
the program which is basically

00:21:57.349,00:22:03.889
telling you okay so put the
board in the address you know
140 eh hundred thousand, which

00:22:03.889,00:22:09.094
is eh the same hypervisor then
the hyphen in the middle is
telling that you need to grab

00:22:09.094,00:22:14.099
the rootfs direct eh path from
the DTB and finally you have a
the xen.dtb with this eh we can

00:22:16.836,00:22:21.840
boot it to the board. This ta-
this sim uh specific eh steps
guys for us eh it took us many

00:22:24.143,00:22:30.583
days and months because it was a
lot of issues putting the xen
hypervisor eh another important

00:22:30.583,00:22:34.987
point here guys is that those
addresses that you see there
loading, if you don’t have it

00:22:34.987,00:22:39.625
enough space between them they
are gonna overlap and then your
board is gonna crash so suddenly

00:22:39.625,00:22:44.463
we were just you know putting
up, it was crashing and turns
out that eh you need to have

00:22:44.463,00:22:49.134
enough space what every single
memory address bad there is no
variation on it so you need to

00:22:49.134,00:22:54.907
make sure that whatever the same
hypervisor is load in the memory
the linux kernel that has enough

00:22:54.907,00:22:59.612
space so that your not overlap
eh and you don’t you know
you-you don’t get a kernel panic

00:22:59.612,00:23:04.550
or or same hypervisor problem.
>>okay, so let’s get the damn
syscalls out um basically, um I

00:23:13.125,00:23:19.198
know I mean it’s it’s it was a
it was kind of um almost became
a dream for us to see this ARM

00:23:19.198,00:23:21.267
syscalls on the screen because
we have been going back and
forth we try different things we

00:23:21.267,00:23:23.269
always get guards stuck because
you know as I said it’s not very
well documented and you know uh

00:23:23.269,00:23:25.271
there are few research papers
out there so we were like just
trying different things playing

00:23:25.271,00:23:27.273
with the memory and finally you
know uh we figured out uh um we
did our own implementation. So,

00:23:27.273,00:23:29.275
a-a as you guys remember I was
mentioning about why single
stepping and you know this why

00:23:29.275,00:23:34.280
single stepping is very
important why you know we’ve
been we-we’re gonna use the um

00:23:38.751,00:23:43.055
known cpu assisted single
stepping. Uh the reason is like
uh since we were using the xen

00:23:43.055,00:23:47.860
hypervisor, and xen hypervisor
does not support single stepping
on ARM so, we have to figure out

00:23:47.860,00:23:52.865
our own way of doing what
normally a CPU does. And uh, we
found a-a very interesting paper

00:23:57.069,00:24:00.773
online uh we talked to that guy
also Sergei from Germany um so
and then we reviewed some other

00:24:00.773,00:24:05.778
techniques online and we finally
uh decided to use this technique
its its a very fascinat-uh

00:24:18.023,00:24:23.028
fascinating one uh so remember
EPT helps you create different
views of the memory right? And

00:24:30.002,00:24:35.874
so first, the first step is uh
basically you create two views
of the memory. By views I mean

00:24:35.874,00:24:40.879
like um you just take the whole
memory, take all the pages, you
create the copy of those pages

00:24:44.183,00:24:50.356
and then you know you have these
two copies in your memory of
those pages and then uh since

00:24:50.356,00:24:56.261
xen hypervisor provide the
support to have multiple EPTs so
you point one EPT, you know

00:24:56.261,00:24:59.631
let’s just call one your default
view and the other the single
stepping view so you have two

00:24:59.631,00:25:06.438
EPTs now, uh, one is the default
view, default view is the one
where you know you’ll y-y-you’re

00:25:06.438,00:25:11.577
gonna run by default when the
system starts, that is the view
where you’re gonna the control

00:25:11.577,00:25:16.215
will be and the execution will
happen. And then you have
another view in the memory

00:25:16.215,00:25:22.221
waiting uh if you want to switch
to that one. So, we have these
two views and uh I’m talking uh

00:25:22.221,00:25:28.060
remember I now I’m talking in
context of the- the syscalls.
The goal is to start monitoring

00:25:28.060,00:25:33.065
the ARM syscalls um or the
operating system system calls on
an ARM platform right? So, so

00:25:35.167,00:25:39.872
think of it like okay you want
to monitor a particular system
call it, the code isn’t in the

00:25:39.872,00:25:44.877
memory somewhere so you find the
location of that mem uhhh, um uh
th- that API uh in the memory

00:25:47.679,00:25:52.684
so, you for the uh at the first
instruction you put uh one break
point. And on ARM its uh sorry.

00:25:58.090,00:26:03.028
So on ARM, the break point is
this D4000003, it’s also called
SMC it’s a special instruction

00:26:05.964,00:26:12.004
on Intel it’s n3 so you can use
the same for Intel also. But,
you don’t have to use the- the

00:26:12.004,00:26:18.610
the swan for Intel just to
mention that because uh xen
actually supports uh single

00:26:18.610,00:26:23.615
stepping on Intel so you can
just use that one. Um, on the f,
the first instruction uh you put

00:26:26.718,00:26:32.524
one breakpoint in the default
view. And then, um on the second
instruction, you put another

00:26:32.524,00:26:38.497
breakpoint but in the single
stepping view. Now what will
happen, uh, in the-the control

00:26:38.497,00:26:43.502
is in the default view and uh
you know you just uh once the
first breakpoint hits, uh what

00:26:45.704,00:26:49.208
you do is you do your analysis,
you want to get the syscall you
know you note down all the

00:26:49.208,00:26:51.210
parameters what process call,
the syscall, whatever analysis
you want to do right? And then,

00:26:51.210,00:26:57.683
you know, you switch the view,
you switch the view and the
control will go to the

00:26:57.683,00:27:02.621
instruction 1 in the second
view. Instruction 1 will get
executed, and then the second

00:27:07.459,00:27:12.231
breakpoint will hit. When the
second breakpoint hits again you
get the control, you’ll switch

00:27:12.231,00:27:18.303
back to the default view and
then the second instruction gets
executed. So basically that’s

00:27:18.303,00:27:24.343
how you single step uh on ARM if
you’re using the xen hypervisor
and not many hypervisor support

00:27:24.343,00:27:30.482
ARM so xen is probably your best
choice on or unless you want to
build your own hypervisor from

00:27:30.482,00:27:37.256
scratch, that is an option too.
So, uh this techniques is i-i-is
very fascinating and you know as

00:27:37.256,00:27:42.261
I was saying this is one of the
applications of the views that
the underlying architecture uh

00:27:42.261,00:27:48.000
provides to vir- the
virtualization extensions so
that’s how we- we single step uh

00:27:48.000,00:27:54.907
on ARM in our implementation.
And so, let’s take a look
overall how do you now um as a

00:27:54.907,00:28:00.646
detection or as a monitoring
system using VMI, how do you
monitor from the outside right?

00:28:00.646,00:28:06.318
So using all the concept that we
have uh so far shared right? So
what you will do is uh uh first

00:28:06.318,00:28:11.323
of all, you will um put a hook
on any- every function, or every
API uh in the memory that you

00:28:15.160,00:28:21.833
want to really analyze r for
example you might want to uh
always analyze sleep, with

00:28:21.833,00:28:28.340
malware you sleep a lot. Um, so
the first step is to uh put that
breakpoint, uh go to the memory

00:28:28.340,00:28:32.444
location and put that
instruction eh and in
combination you have to register

00:28:32.444,00:28:39.217
an event. Now, a good hypervisor
always provides event mechanism
right? So, you wanna you wanna

00:28:39.217,00:28:43.488
monitor something it provides
you an even mechanism and xen
does the same. So you register

00:28:43.488,00:28:47.793
your event and then you also
register your call back. So,
that’s the second most important

00:28:47.793,00:28:52.431
because with the call back
function that you’re going to
register, what it does is you’re

00:28:52.431,00:28:58.370
telling the hypervisor hey
anytime my breakpoint hit you
you know give me the control and

00:28:58.370,00:29:02.407
execute this function. So, in
this function you’re gonna do
everything for example you’re

00:29:02.407,00:29:07.212
gonna extract once the
breakpoint hits, you’re gonna
extract the parameter values of

00:29:07.212,00:29:11.917
the function, you know the
function name, process name, or
whatever you want to do you do

00:29:11.917,00:29:16.388
in this function. The single
stepping functionality that I
showed you uh in the previous

00:29:16.388,00:29:22.060
slide, you will also do in this
function. So, that’s the second
uh most important step. Uh, the

00:29:22.060,00:29:27.366
third step is obviously, you
know you need to single step.
Remember, so, if you don’t

00:29:27.366,00:29:34.172
single step, what will happen?
Uh, the breakpoint will hit, you
don’t single step, the control

00:29:34.172,00:29:39.611
will stay there, it will
continue to execute the same
instruction the system will get

00:29:39.611,00:29:45.584
into a very unstable state and
you know imagine you are
protecting a car infotainment

00:29:45.584,00:29:50.355
and then you’ll- you’ll crash
the system. It’s very important
to make sure you know you

00:29:50.355,00:29:54.860
properly single step.
And,finally, you know once
you’re done monitoring uh make

00:29:54.860,00:29:59.831
sure you remove all your hooks
from the memory and uh you know
you- you know you do a clean

00:29:59.831,00:30:01.833
exit. So, that’s how you
basically um do uh the syscall
monitoring through VMI and uh on

00:30:01.833,00:30:03.835
ARM especially it was
challenging because you know as
I mentioned there was no single

00:30:03.835,00:30:05.837
stepping, and there was no
documentation so it took us some
time but you know finally we

00:30:05.837,00:30:08.407
really happy that you know we
achieved this. So, let me- let
me now show you what looks like

00:30:08.407,00:30:10.409
uh our moment of uh happiness
when we first saw this so, I
hope it. Okay so how do I show

00:30:10.409,00:30:12.744
>>eh, hit escape and uh >>okay
>>escape, escape the
presentation. Yep, yep. >>and

00:30:12.744,00:30:14.746
then yeah so this is our xilinx
board. Uh we have our
introspection framew- we call it

00:30:14.746,00:30:16.748
Numen introspection framework
and um uh yeah these are how the
syscall looks like you know the

00:30:16.748,00:30:18.750
process name and everything uh
and all see you know we’re
typing, and then you see all the

00:30:18.750,00:30:20.752
syscalls being lo-logged on the
upper right and then I type top
and then you can see the process

00:30:20.752,00:30:22.754
name being tracked. This is
happening, everything happening
from the raw memory outside of

00:30:22.754,00:30:24.756
the operating system. So that’s
pretty cool. And now finally you
know we do-we do a sleep and

00:30:24.756,00:30:31.496
then you’re gonna see the sleep
being shown and not only shown
because we have other components

00:30:31.496,00:30:36.501
uh it-it’s also being monitored
as highlighted here so uh not
only we get the syscalls out we

00:30:43.375,00:30:48.380
also uh send it to our machine
learning monitor uh to monitor
it. So, that was our um took us

00:30:56.555,00:31:01.493
quite some time to achieve that
one and yeah that was the-
>>okay guys so let’s get to the

00:31:04.996,00:31:08.700
fun part because eh uh after
these whole efforts that you can
see now we know the basics, we

00:31:08.700,00:31:12.070
know how to ARM uh use VMI to
introspect in machine learning
and it’s already into the

00:31:12.070,00:31:17.075
machine and now we -we are able
to have the board everything,
right? Now, let’s see what we

00:31:22.614,00:31:27.619
can do eh from attacks
perspective and detection with
this components eh in the board

00:32:09.661,00:32:14.666
right? So, the first approach is
the typical malware eh coming
into a car into a medical device

00:32:26.745,00:32:31.616
right? Can we tackle that
problem from VMI? So, if you
have been working on uh

00:32:31.616,00:32:37.789
anti-virus companies or sandbox
related companies it’s the
typical way to do it is very

00:32:37.789,00:32:43.428
common but keep in mind here
guys we are out of the box we
don’t have an agent inside a-and

00:32:43.428,00:32:47.132
this is totally
different-different piece. So,
eh let’s see the first example.

00:32:47.132,00:32:52.537
The first example eh we have
a-a-a malware running. So what
we do, in this specific scenario

00:32:52.537,00:32:57.876
is u- we’re gonna use machine
learning in order to detect
attacks. So what we do is we get

00:32:57.876,00:33:03.348
let’s say the infotainment from
the car and we profile it, get
all the processes running, we

00:33:03.348,00:33:10.121
feed it into-into our
autoencoder which is newer
network eh based approach and

00:33:10.121,00:33:15.527
what it’s gonna do it’s gonna
learn how a healthy sys how a
healthy system looks like, all

00:33:15.527,00:33:21.266
the processes all the different
syscalls being executed so that
once it learns that eh when we

00:33:21.266,00:33:25.403
when it is running a process in
the infotainment it’s gonna grab
that profile which is in the

00:33:25.403,00:33:30.809
left side, the actual profile
that is going to be fit into the
autoencoder and then keep the

00:33:30.809,00:33:35.747
autoencoder is going to create a
new profile based on his
learning experience. Once it

00:33:35.747,00:33:40.986
generated if the similarity
between the reconstructed
profile and the and and the

00:33:40.986,00:33:45.423
actual profile that was running
in the in the in the device
is-is it becomes really low

00:33:45.423,00:33:50.729
error which means it’s very
similar is when we know we are
dealing with a benign process.

00:33:50.729,00:33:55.333
But what-what happened when we
have a malicious process. So,
the same process happens, we

00:33:55.333,00:34:00.372
have this malicious process, we
profile it we find the actual
profile fit it into the

00:34:00.372,00:34:04.910
autoencoder, the autoencoder is
going to create his own
construction of the profile and

00:34:04.910,00:34:10.348
he’s going to realize that the
sequence and the syscalls we use
is totally off is the error

00:34:10.348,00:34:14.920
label really really high and
that way it’s easy for us when
we have machine learning to

00:34:14.920,00:34:19.925
detect that isn’t normally
inside the device. That’s uh pre
eh eh step one. Second approach

00:34:22.427,00:34:27.666
guys, let’s say that we have a
an exploit going on right? In
the left side you can see an

00:34:27.666,00:34:33.438
application running and the list
of all the syscalls going on
there. So, you are gonna see

00:34:33.438,00:34:39.477
always the way it executes. But
what happen if suddenly that
application is compromised? So,

00:34:39.477,00:34:46.284
you if you see in the right side
a- a- a at the end in the-in the
red uh eh bo- in the red square

00:34:46.284,00:34:51.856
eh you will see that comparing
the two applications the benign
one without being exploited is

00:34:51.856,00:34:56.628
gonna exit the program, but when
you look at the second one it’s
gonna it’s gonna call exit b.

00:34:56.628,00:35:01.399
Why exit b? Obviously because
it’s gaining a shell. So in this
case we don’t ne- we don’t

00:35:01.399,00:35:06.237
really need machine learning to
realize that the flow has been
affected right? We call it

00:35:06.237,00:35:11.242
sequence base, people call it
control flow- same S-H- S-H-*-T
so at the end of the day eh eh

00:35:13.278,00:35:19.884
you just need to measure the
sequence base and realize if
there is any alteration and in

00:35:19.884,00:35:26.791
this case one exit properly and
the second one called exit b so
it it is deleted. Eh, now let’s

00:35:26.791,00:35:33.264
talk about the delay. Eh, you-
if you guys are familiar with
anti virus in eh in sandboxes

00:35:33.264,00:35:38.470
right in one of the techniques
of-of the EPTs for example is
through the late execution, so

00:35:38.470,00:35:45.276
that it executes and then it’s
gonna wait for execution so that
an anti-virus take a decision in

00:35:45.276,00:35:50.015
milliseconds to know if is
malicious or not right? It
doesn’t it cannot be a scanning

00:35:50.015,00:35:56.087
the process all the time so by
delayed execution, those engines
are gonna give up and they are

00:35:56.087,00:36:01.292
gonna stop monitoring it and
that’s a way to bypass it. So,
that scenario is a pain always

00:36:01.292,00:36:07.332
in eh in-in-in the enterprise
with anti-virus. In our case,
it’s the same issue but how we

00:36:07.332,00:36:12.570
can tackle it eh compared with
them so, in our case for example
we have this pretty simple delay

00:36:12.570,00:36:18.343
in ARM eh uh and it’s just a
simple loop that's gonna you
know delay execution for 8

00:36:18.343,00:36:23.548
seconds, 8 minutes and then
after that, it’s gonna trigger
the shell. If you remember the

00:36:23.548,00:36:29.020
previous slide, in that one we
have all the execution at the
end we have the exit b to be

00:36:29.020,00:36:34.092
called in this case what
happened is that the exit b is
never going to be called and

00:36:34.092,00:36:38.596
therefore, we’re not gonna see
any anomaly. So that’s a
pre-pretty challenging

00:36:38.596,00:36:43.234
cha-challenge that people have
so, what the people does for
example in the xen boxes they

00:36:43.234,00:36:48.473
hook all this asleep or non
asleep or those syscalls and
once they see the syscall

00:36:48.473,00:36:53.278
triggering they say that they
say that asleep for 5 minutes
they will change a drone time 5

00:36:53.278,00:36:58.750
minutes to zero so that they
force the malware to execute
right, that’s one technique but

00:36:58.750,00:37:02.654
that’s a cat and mouse game
because today it's asleep
tomorrow it’s not asleep and

00:37:02.654,00:37:07.058
there’s gonna be multiple
techniques all the time so you
need to keep updating these

00:37:07.058,00:37:11.863
techniques so that anytime there
is new way to bypass it, you
need to update it. I-in this

00:37:11.863,00:37:16.634
case for example we don’t even
use a sleep we don’t use a
syscall so in this case it’s

00:37:16.634,00:37:21.506
just a code that’s gonna delay
execution so you don’t, you
cannot rely on hook in syscall.

00:37:21.506,00:37:26.511
So, eh this eh challenge for
everyone. In our case, eh we
tackle it in a different way eh

00:37:28.546,00:37:34.419
one way is you don’t wanna eh
monitor these executions all the
time right? We were talking

00:37:34.419,00:37:39.958
about we are in a car we don’t
want to delay execution can you
imagine the GPS just slowing

00:37:39.958,00:37:45.396
down or any application in the
car so we need to decide quickly
but if this application is

00:37:45.396,00:37:50.869
running and it’s a sleeping, we
can not wait forever. So, we
have a way to attack the process

00:37:50.869,00:37:56.107
so that when the process stop
running so then it goes to
sleep, we stop executing and

00:37:56.107,00:38:02.113
then we monitor it in a way that
eh we cannot eh kn-know when
the-the malware wakes up. Eh

00:38:02.113,00:38:06.651
this is our way to do it via
profile based approach that
Ali’s gonna explain in a second

00:38:06.651,00:38:12.157
but from VMI perspective eh same
challenge but we don’t wanna
follow the syscall

00:38:12.157,00:38:16.895
implementation in order to
understand when they isolate in
our case we tag it the process

00:38:16.895,00:38:22.367
we just you are sleeping we
sleep we don’t do any
performance issue but as soon as

00:38:22.367,00:38:27.572
you wake up we wake up. So
that’s the profile based police
that we’re gonna explain in a

00:38:27.572,00:38:33.478
second. Now, Ali was explaining
us that his technique right eh
I’m sorry the technique that he

00:38:33.478,00:38:38.183
was explaining to hook into the
memory so he was telling us that
you know you need to put a

00:38:38.183,00:38:44.722
D40003 SMC hook right? So,
that’s pretty cool eh uh but
it’s pretty easy to bypass so,

00:38:44.722,00:38:51.095
uh I mean eh if I have a kernel
module I can just go to the
syscall grab the first 4 bytes

00:38:51.095,00:38:56.634
and then get the-the-the SMC
there and for me it’s a malware
I’m gonna be able to detect

00:38:56.634,00:39:00.538
right away that I’m being
monitored right? Yeah a-in that
moment I’m gonna say you know

00:39:00.538,00:39:05.043
what man I have this SMC hook
I’m being monitored so I’m not
going to execute anything I’m

00:39:05.043,00:39:11.583
gonna wipe the system or even
worse I can override if-if the
memory eh the page allow me I

00:39:11.583,00:39:17.088
can override that SMC hook eh to
put it in the-in the original
state and then I can just

00:39:17.088,00:39:22.093
totally bypass the hooks in the
system and then this code
technique being showed by Ali is

00:39:22.093,00:39:27.232
totally screwed because it’s
pretty easy to identify so I
don’t know how come Ali come up

00:39:27.232,00:39:32.237
with this technique, but
anyways. >>ok, okay so, let me
think how we can uh answer Dan.

00:39:35.640,00:39:41.713
So, you remember the views
right? And I keep saying the
views are very powerful so

00:39:41.713,00:39:48.686
here’s another use case and
we’ll we’ll see how we can um
answer Dan’s question. Um, in

00:39:48.686,00:39:52.824
this case what we are doing is
again we’re creating uh you know
two views actually you know you

00:39:52.824,00:39:58.830
don’t need to create um um the
whole the whole memory pages
what-what we’re essentially

00:39:58.830,00:40:05.069
doing is we are um assigning
different permissions to
different eh EPT’s. So, we have

00:40:05.069,00:40:11.843
two EPT’s, uh one is going to be
the execute only the other is
going to be the read/write only.

00:40:11.843,00:40:17.682
Now, what will happen? Well,
let’s say by default we are in
the execute only view right and

00:40:17.682,00:40:22.687
the malware comes and tries to
read the hooks that we have
placed in the memory. Um, since

00:40:25.456,00:40:31.229
the page is execute only there
will be an exception the control
will be transferred to me and I

00:40:31.229,00:40:36.000
will see that the malware is
trying to be smart, what I will
do is I will switch the view uh

00:40:36.000,00:40:42.040
which is the clean view by the
way there is no hooks in ho-hook
in a this view. So that’s th-

00:40:42.040,00:40:46.911
that’s the trick. So, I have
this view where there’s no hook.
I’ll-I’ll switch the view, I’ll

00:40:46.911,00:40:53.451
let the malware read the memory
pages in this view and then eh
it’s read request will be

00:40:53.451,00:40:58.656
satisfied. The malware will not
know you know that there are any
hooks or it’s being monitored.

00:40:58.656,00:41:03.594
So, that’s how and then once
the-the that read request is
done uh we’ll switch back to the

00:41:06.698,00:41:13.338
execute view. So, you saw the
previous application where you
know we created these views um

00:41:13.338,00:41:18.676
to do the single stepping. Now
you saw another one where you
know we use the same

00:41:18.676,00:41:23.681
capabilities that you know the
Intel and the ARM provides to um
bypass uh or train you know

00:41:26.050,00:41:32.190
malware detecting us as we
bypass that. >>Okay guys so
let’s see another eh other

00:41:32.190,00:41:38.229
examples. Eh em in this case we
have an anti VMM you know
hypervisors are known to be

00:41:38.229,00:41:43.835
virtual machine monitors it’s
another name. So, what we have
here is eh I’m again I’m a

00:41:43.835,00:41:49.207
malware right. So, I wanna know
if I’m being monitored if I’m
I-I’m being monitored so I’m

00:41:49.207,00:41:55.446
gonna stop at security. So, in
this case, eh see the square
switch CPUs as we explain that

00:41:55.446,00:42:01.185
has a cost, has a time in-in
terms of performance so what a
malware can do a-and we use to

00:42:01.185,00:42:05.790
approve concept here is we
measure as a baseline
with-without having the page

00:42:05.790,00:42:11.295
view switching, we have special
time in this case it’s 38
nanoseconds and then, once we do

00:42:11.295,00:42:16.901
that we then measure the time it
takes to write into the memory
and you will see in that red eh

00:42:16.901,00:42:23.408
color, that the time is highly
significant so that you will
realize that eh the time to

00:42:23.408,00:42:27.779
write into memory is totally
different with your baseline and
this is another technique that

00:42:27.779,00:42:32.216
we can use to detect that we’re
being monitored just my
measuring the time that it takes

00:42:32.216,00:42:36.888
to write into memory we can
realize it’s taking too much
time that the baseline a-and

00:42:36.888,00:42:41.759
this is another way to-to find a
-a way to bypass eh to
understand we are being

00:42:41.759,00:42:48.132
monitored. Now, eh let’s talk
about process killing guys so,
when we when we kill a process

00:42:48.132,00:42:53.938
right eh we all know how it
works right? Eh, if you want
implement it on-on code you will

00:42:53.938,00:42:58.810
just need to call the syscall
kill and you pass the PID and
the way you want to kill it

00:42:58.810,00:43:04.649
right? That’s not if you want to
force it so that’s the way it
works normally in a user mode

00:43:04.649,00:43:09.720
scenario and we all know. But,
what happens here is eh what
happen if we want to implement

00:43:09.720,00:43:16.027
like simple killing process in
VMI? Keep in mind that we don’t
have any agent inside so, people

00:43:16.027,00:43:20.731
o-other companies what eh what
they do is they just drop an
agent inside, they code kill in

00:43:20.731,00:43:25.670
the user mode and then you
execute the process. But in our
case guys we don’t have an agent

00:43:25.670,00:43:31.342
inside an-and we don’t wanna
have an agent inside we want to
keep being out of the box. How a

00:43:31.342,00:43:38.116
simple kill process can be done
from VMI? So, we have a way to
do it here it doesn’t need to be

00:43:38.116,00:43:42.353
the perfect solution the idea
here is that you guys can see
the challenge when you wanna

00:43:42.353,00:43:47.558
just kill a simple process it’s
very easy to do but from the
hypervisor. So, what we do is

00:43:47.558,00:43:53.030
let’s say that we want to kill
the process id 300. So, what we
do in the kernel because this

00:43:53.030,00:43:58.803
code VMI guys is being inside
the kernel we are not using user
mode syscalls because it’s to

00:43:58.803,00:44:03.774
hi-to consuming it’s a lot of
performance issues so we are
just hooking in the kernel. So

00:44:03.774,00:44:09.413
when these 300 processes running
what we’re gonna do from VMI is
we-we’re gonna monitor all the

00:44:09.413,00:44:14.652
syscalls so when the syscalls
come in from the process, what
we’re gonna do is w-we’re gonna

00:44:14.652,00:44:18.789
mess with the stack and that
i-information that you see in
the green, is the fullest

00:44:18.789,00:44:24.662
stacked dumped for n- for al-
for one syscall. So, what we do
is you know there is something

00:44:24.662,00:44:29.901
that is called a saved user
state registers so when you
transfer from user mode to

00:44:29.901,00:44:34.972
kernel mode, those registers in
user mode are stored in the
kernel so that when the kernel

00:44:34.972,00:44:41.245
resumes execution in user mode
those registers are used again
right? So, what we do in kernel

00:44:41.245,00:44:45.917
is that we get that stack
content, we get those same
registers which are not being

00:44:45.917,00:44:51.022
used by the kernel and we just
modify them. What-what's gonna
happen guys is that when the

00:44:51.022,00:44:56.027
syscalls come back into the user
mode since those registers are
totally modified, it’s gonna

00:44:56.027,00:45:01.699
cause an exception and it’s
gonna exit the process. You can
see it’s totally a different

00:45:01.699,00:45:08.439
way, it-it’s not a traditional
one but t-taking advantage of
VMI we are able to mess up with

00:45:08.439,00:45:14.845
the stack then force the process
to kill. Important to mention
that eh it’s not easy to do

00:45:14.845,00:45:21.018
because eh in this example you
see the yellow box eh if you
mess with any kernel related

00:45:21.018,00:45:25.856
information which is in the
lower addresses you’re gonna get
a crash in the- in the device.

00:45:25.856,00:45:32.463
You wanna make sure that you are
really eh overriding only eh the
user mode eh erase their

00:45:32.463,00:45:39.203
information. So, we learn that
from experience and then we come
up with these uh specific offset

00:45:39.203,00:45:45.509
that is calculated dynamically
that we always override only eh
user mode registers a-and the

00:45:45.509,00:45:52.383
way it works guys, is that
everytime we get a we say to to
the device hey kill PID 300 it’s

00:45:52.383,00:45:57.088
gonna grab all the syscalls,
everytime we grab it it’s gonna
mess up with the stack sometimes

00:45:57.088,00:46:01.559
in the first syscall it gra-
it-it-it get the exception and
kills it, sometimes in the

00:46:01.559,00:46:07.164
second and third one so sometime
it-it sometimes needs to take
like 5 or 7 syscalls to be code

00:46:07.164,00:46:11.969
in order to in order to be
killed. But, this simple example
guys as I said is totally

00:46:11.969,00:46:17.575
different beast as you can see.
It’s not it’s not easy to do it
a-at the VMI if you want to be

00:46:17.575,00:46:22.580
totally a in this so let’s see a
quick example of-of-of eh how we
kill it eh in-in-in um in the

00:46:25.383,00:46:30.388
device. So, here we have our our
eh system eh so what we’re gonna
do guy eh guys is in the upper

00:46:36.694,00:46:41.699
left eh we’re gonna run a simple
like malware mirror right which
is a very common one in the

00:46:46.437,00:46:51.442
mirai we have our inspector
monitoring it here is Mirai were
gonna execute it as soon as we

00:46:55.680,00:47:02.053
execute it mi-mirai deletes
itself and expand the busybox
process eh pretending to be

00:47:02.053,00:47:07.191
normal, an-and using the 336
pid. So, let’s go back to the
virtual machine that we’re

00:47:07.191,00:47:12.963
monitoring we search for that
process 336 and we can see that
it is there running right? 336

00:47:12.963,00:47:17.735
is there, we click on it and
then we can see that the pc box
is-is showing up right? There is

00:47:17.735,00:47:23.307
pcbox now, let’s try to kill it
from VMI so we go to our eh
front end, we go and try to find

00:47:23.307,00:47:28.679
the 336 process we find it there
and then we click on kill
button. That’s gonna be from VMI

00:47:28.679,00:47:34.385
sending the a-a signal to kill
it, so then we go back to the VM
and send for the mirai which is

00:47:34.385,00:47:39.290
gone already you know it is up
here a-as we said and now let’s
look for the 336 and you can see

00:47:39.290,00:47:44.295
that it is totally killed. Eh,
this is totally ummm eh clean we
don’t crash the system and this

00:47:47.531,00:47:52.536
way to do it which is not the
best way uh it works for us
a-a-and that way we are able to

00:47:59.677,00:48:04.615
kill from VMI perspective.
>>okay, okay, so, so um just
want to quickly mention that you

00:48:09.386,00:48:15.326
know once you get hold of VMI
once you understand it, uh it’s
pretty cool and you can do a lot

00:48:15.326,00:48:19.764
of other things uh, other that
it’s very powerful. So, um one
of the things that we did

00:48:19.764,00:48:25.803
additional in addition to
detection is the policy. So, not
only um you can do the detection

00:48:25.803,00:48:30.608
with VMI but you can also
implement policies. Again, not
putting anything inside the

00:48:30.608,00:48:34.512
operating system and still
maintain these policies. One
other example that I want to

00:48:34.512,00:48:39.984
quickly share with you is um a
lot of uh infotainment or any
IOT device, for example medical

00:48:39.984,00:48:44.155
device there are certain
processes very limited which are
responsible for going out to the

00:48:44.155,00:48:48.626
internet. So, what you can do is
you can you know the task list
that I showed you, you can

00:48:48.626,00:48:52.830
continuously monitor that from
the outside and and since socket
is a special file you can see if

00:48:52.830,00:48:54.832
there is another uh socket being
opened. That might be slow
because your actively traversing

00:48:54.832,00:48:57.701
uh alternatively what you can do
is you can hook a connect or a-a
network API. And then you know

00:48:57.701,00:49:02.640
in events that API gets called
you’ll see if this process is
allowed to communicate outside

00:49:10.347,00:49:15.352
or not. So here’s you know just
a quick view of um how it um it
looks like in our system. Um,

00:49:18.122,00:49:23.561
like Dan was mentioning uh
remediation is another topic
that we are tackling aspect once

00:49:23.561,00:49:27.198
we detect something we need to
kill, it’s not always easy to
kill from outside we always have

00:49:27.198,00:49:31.302
the option to put an agent
inside, but we don’t want to do
that we want to be completely

00:49:31.302,00:49:36.607
out of the box. So, you want to
try I mean the matter that we
showed you is not one of the I

00:49:36.607,00:49:42.646
mean we-we figured that out on
our own but we-we have another
one you know that-that’s that we

00:49:42.646,00:49:46.150
exploring right now so you can
try different things you can
make the parameters null and

00:49:46.150,00:49:50.187
try-try tho- some of those
things. Quickly want to share
some of the recommendations with

00:49:50.187,00:49:54.558
you guys for an end to end
system let’s say you’re working
with some other hypervisor, like

00:49:54.558,00:49:59.296
in our case you know xen is just
the start we are already working
with some you know another

00:49:59.296,00:50:04.201
hypervisor. Um, and that’s a
custom one. So, you really need
to have good way of putting the

00:50:04.201,00:50:09.139
breakpoints, efficient single
stepping mechanism, uh the event
mechanism now we didn’t talk too

00:50:09.139,00:50:12.910
much about event mechanism
because xen provides a really
good event mechanism if you’re

00:50:12.910,00:50:16.647
working with some other
hypervisor you wanna make sure
you know you have a good event

00:50:16.647,00:50:22.987
mechanism. Anything that you
translate using those page
pa-pa-page tables or the page

00:50:22.987,00:50:28.392
walk uh you know you want to
make sure uh you cache those and
in efficient hash tables. Um,

00:50:28.392,00:50:32.930
multiple views is awesome as you
can see, I mean we have few
other use cases which have

00:50:32.930,00:50:37.434
patent pending we cannot talk
about it. Uh we can mind views
uh you know with other

00:50:37.434,00:50:42.473
techniques uh to really, really
improve the performance and VMI-
VMI monitoring system

00:50:42.473,00:50:48.512
performance is the key. And,
finally the permission
management. Um, finally guys we

00:50:48.512,00:50:55.452
are uh releasing some tools uh
for you guys to play with um you
can see the-the dropbox you can

00:50:55.452,00:51:00.524
go and check them out so we have
the ARM and Intel VMI monitoring
tools that you know you can play

00:51:00.524,00:51:06.897
with um uh we have all the files
that we have used to you know
boot up the xilinx board and

00:51:06.897,00:51:12.403
finally we have the one malware
ARM64 based malware that you can
use to do and and do in

00:51:12.403,00:51:17.408
scenario. So do check that out
an and um you know play with it.
Uh, okay so finally the-the

00:51:19.743,00:51:24.782
takeaways. Uh, in today's world
of advanced malware we really
need to make sure you know we

00:51:24.782,00:51:29.253
make the hypervisor smart.
Hypervisor is everywhere so you
know you want to make sure you

00:51:29.253,00:51:35.125
know you you make it smart and
you know eh agentless is the way
to go, because we know that you

00:51:35.125,00:51:41.398
know anytime you have an agent
inside it-it’s a it’s a losing
game. ARM syscall monitoring

00:51:41.398,00:51:46.470
obviously was a great
achievement for us but it’s just
a start. I mean, we there’s now

00:51:46.470,00:51:51.208
there’s a lot we can do so don’t
just stop at the you know
syscall monitoring you know

00:51:51.208,00:51:56.280
think of new use cases and you
know especially switching
between views is very powerful

00:51:56.280,00:52:00.417
so you can also think of new use
cases around that. And finally,
performance is the key. We have

00:52:00.417,00:52:06.423
a patent pending uh numan
adaptive uh monitoring and then
we-we-we use that um in our

00:52:06.423,00:52:12.229
system we cannot talk about it
right now we need another talk
for that. Okay, finally I really

00:52:12.229,00:52:19.203
want to thank um Saqib, Matt,
Stefano, Waleed I don’t know if
you guys are here uh but still

00:52:19.203,00:52:21.205
these guys really helped us
along uh uh our journey and it
wouldn’t have been possible what

00:52:21.205,00:52:26.210
we achieved without these guys.
Thank you guys, thank you
[applause]

