00:00:00.067,00:00:04.705
>>We’re gonna get started this
morning with what looks to be a
very exciting talk, with a

00:00:04.705,00:00:08.442
couple ah, couple-couple of
recorded demos because these
guys are smart and they don’t do

00:00:08.442,00:00:13.180
live demos at DefCon. That
is-that is >>We’re not allowed
to >>Well, you're allowed, but

00:00:13.180,00:00:18.952
it's just a really really
terrible idea. [Laughter] Um, so
if you if this is your first

00:00:18.952,00:00:23.957
time in track four, which we are
calling fancy track. Here in
fancy track, you cannot vape,

00:00:26.026,00:00:31.832
you cannot smoke anything of any
kind. Ah, you are not supposed
to be having any kind of outside

00:00:31.832,00:00:37.571
beverages other than water.
There you go. Um, like I said,
if you want to kinda move

00:00:37.571,00:00:41.642
towards the centre so that
people can get in and out, that
will help because we’re gonna,

00:00:41.642,00:00:47.381
have a lot of people coming to a
lot of really good talks today.
With that said, let’s get Topher

00:00:47.381,00:00:52.252
and Michael up here. Um, how
many people use antivirus at
work? How many believe it does

00:00:52.252,00:00:58.258
anything? There we go, how many
people use EDR at work?. Yeah,
how many people b-believe it

00:00:58.258,00:01:03.196
does something? A-ha [Laughter]
Suckers [Laughter] Let’s give
Michael and Topher a big round

00:01:06.900,00:01:11.905
of applause [Applause] >>Have a
good time bro >>Thank you >>Oh
my gosh. Alright, thank you for

00:01:17.945,00:01:23.483
coming, ah. On an early, ah
Saturday morning, this is, ah
EDR is coming; hide yo sh!t. Um,

00:01:23.483,00:01:28.488
I’m really happy to, ah be here
this year. This sort of, ah came
about as a hallway conversation

00:01:31.291,00:01:36.763
at DefCon last year. We had some
ideas, we talked it over, it
turned into some research and,

00:01:36.763,00:01:42.202
ah here we are and that’s pretty
exciting. So, go out there and
talk to all the people and have

00:01:42.202,00:01:47.207
all the ideas and submit
something next year. Alright,
so, um who are we. Well first of

00:01:50.410,00:01:54.748
all we-we don’t speak for our
employer, these are, this is
speaking all on behalf of

00:01:54.748,00:02:01.555
ourselves and nothing that we’re
saying is to be construed as,
you know, from our employer. I,

00:02:01.555,00:02:07.894
I-I’m Michael Leibowitz, I like
to ah w-on my, in-in my free
time write, ah armaic hardware

00:02:07.894,00:02:14.768
implants, reimplementing NSA, ah
hardware implants and I’m a
principal trouble maker. And?

00:02:14.768,00:02:19.139
>>And, ah I’m Topher Timzen. I
like doing, like C sharp Malware
stuff, so hilariously enough

00:02:19.139,00:02:23.310
some of the things you're gonna
see in this talk I've talked
about, ah previously at DefCon

00:02:23.310,00:02:27.414
23. So, it’s kinda like the old
is still new. Ah, I’m a
principal vulnerability

00:02:27.414,00:02:32.419
enthusiast, we both work on Red
Teams. And as you can see by our
matching attire, we, ah we just

00:02:32.419,00:02:37.424
want to drink coffee and write
malware. [Laughter] >>Alright
so, ah here’s what we’re gonna

00:02:40.627,00:02:44.898
go through. And we have a-a lot
to cover, so we’re gonna go
through it pretty fast.

00:02:44.898,00:02:51.605
Basically, what EDR is, why we
care. Ah, UEFI and the thing to
know about UEFI, is that UEFI is

00:02:51.605,00:02:56.476
cross-platform, which is why
we're doing a-a Windows and a
Linux demo and why we have a

00:02:56.476,00:03:00.447
Windows and Linux payload. Of
course, you know, what
everyone’s wondering, what does

00:03:00.447,00:03:04.551
this all mean. And then, you
know, some mitigation or
whatever. And then future work

00:03:04.551,00:03:10.524
and then conclusions. [Laughter]
>>Ah so, we’re gonna kind of
start off with talking about

00:03:10.524,00:03:13.994
EDR. So, a lot of you raised
your hands that you use this
and-and think it works, So,

00:03:13.994,00:03:19.900
we’re about to, you know, kind
of ruin that for you. [Laughter]
Um, so kind-kind of, ah so it’s

00:03:19.900,00:03:24.137
ten o’ clock, the slides are a
little bit hungover. So, ah EDR,
is endpoint detection and

00:03:24.137,00:03:29.276
response, not enterprise, ah
think slides been up early with
us. Um, the biggest thing about

00:03:29.276,00:03:33.914
EDR it that it’s really just
defensive tooling that focuses
on like detecting, investigating

00:03:33.914,00:03:38.819
and mitigating suspicious
activities going on within an
environment. The big thing that

00:03:38.819,00:03:45.325
it really provides Blue Teams is
a hunt capability. So, this how
and a lot of, ah organisations

00:03:45.325,00:03:51.131
they’re making like lar-large
scale-like correlations for hunt
stages. So, like oh this machine

00:03:51.131,00:03:54.734
over here is doing these sorts
of things that’s not really
typical this alert fired on our

00:03:54.734,00:04:00.240
SIEM, let’s go and investigate.
Um, typically it really just
means that like for us on Red

00:04:00.240,00:04:05.579
Teams that Blue Teams gonna find
you and we don’t wanna be found.
Ah, so we’re gonna sort of look

00:04:05.579,00:04:11.852
at how we avoid that. Um, and
then like the one big thing with
EDR, is that typically

00:04:11.852,00:04:16.590
everything's mapped to, ah like
MITRE Attack and if you’re not
familiar with MITRE Attack,

00:04:16.590,00:04:20.660
that’s essentially just like
this huge knowledge-knowledge
base of ah of things that

00:04:20.660,00:04:25.098
attackers tend to do based off
of real-world observation. So,
like you probably hear the term

00:04:25.098,00:04:30.070
like TTP’s thrown around
everywhere. Um, in essence, it’s
really just this huge table that

00:04:30.070,00:04:35.242
lists things that attackers like
to do. So, you kinda like think
back to a previous life when

00:04:35.242,00:04:39.479
you’re in kindergarten and you
get like a gold star for like
turning in your homework on time

00:04:39.479,00:04:44.117
and like being polite. It’s
essentially like that but for
like us as bad guys, we get gold

00:04:44.117,00:04:48.421
stars when we do like
persistence, we get a gold star
for privilege escalation. Ah, so

00:04:48.421,00:04:52.025
like we wanna fill out all the
things but not have anybody
know, so we don’t actually get

00:04:52.025,00:04:58.999
the gold stars. Ah, we just
wanna do it. Um, so like, I’m
saying like EDR’s really just

00:04:58.999,00:05:04.070
tuned like in actuality for like
processes, commands and API
Calls. So, if you’re like

00:05:04.070,00:05:09.042
running say like ah cmd dot exe
or PowerShell or doing like some
registry stuff or trying to set

00:05:09.042,00:05:14.481
up persistence. Because those
are like TTP’s in the MITRE
Attack Framework. Those tend to

00:05:14.481,00:05:20.287
be flagged and mapped and then
alerted on for the-the Blue
team, um and we wanna make sure

00:05:20.287,00:05:25.292
that none of that actually
happens. >>So, ah a lot of
people talk about, you know, the

00:05:27.394,00:05:32.399
Risk Curve. And, um, you know,
this is the Other Side of the
Risk Curve. Basically, you know,

00:05:34.834,00:05:39.573
no-no attack, no breach lasts
forever right? You can see from
the right side of the graph that

00:05:39.573,00:05:44.678
eventually you’re gonna get
busted. And you, you-you land
your shell. You know, that’s

00:05:44.678,00:05:48.215
kind of the highest risk time
you move around a little bit and
eventually you sort of settle

00:05:48.215,00:05:52.552
into persistence. And like the
longer, you hold on, the more
chance it is that someone’s

00:05:52.552,00:05:57.557
gonna roll you up. And really
what we want to do is, you know,
make this curve flattened a

00:05:59.926,00:06:05.599
little bit. And, you know,
what-what does it mean when, you
know, the breach gets detected

00:06:05.599,00:06:10.103
like no-ones sleeping well
tonight, this is-this is
terrible. You know, you’ve

00:06:10.103,00:06:16.676
lovingly crafted payload becomes
the analysts' sample, you’re
like very upset because all

00:06:16.676,00:06:21.248
these months of work and
crafting that, super awesome
payload are just down the drain

00:06:21.248,00:06:27.020
and the analyst is like, oh
shit, there goes my Friday
night. [Laughter] No-Nobody’s

00:06:27.020,00:06:32.025
happy. So, what we wanna do is,
we want to modify this risk
curve. We want to make it such

00:06:34.794,00:06:41.201
that, you know, you, we’re not
gonna flatten that initial shell
pop kina-kinda part. Like that’s

00:06:41.201,00:06:45.505
kinda the same, but we just
wanna, we just want to hang onto
the good stuff for longer.

00:06:45.505,00:06:50.010
Eventually, eventually we’re
gonna get rolled up, but we’re
just, just hang out and chill

00:06:50.010,00:06:56.816
out for a little bit longer [
Laughter] >>So, as we were
investigating ways that we can

00:06:56.816,00:07:03.156
hide from, ah UEFI, oh from EDR,
Mike and I had some pre-existing
platform experience. A

00:07:03.156,00:07:08.395
particular UEFI platform
experience, so like platform
firmware. Um, so in sort of this

00:07:08.395,00:07:13.166
research, it’s like, ah we were
thinking that we can utilise
this sort of functionality to

00:07:13.166,00:07:17.771
evade all of these detections
and make that risk of, ah and
the dwell time for us last a

00:07:17.771,00:07:22.876
little bit longer. Um, so, if
you’re not familiar with UEFI,
ah I have to include this

00:07:22.876,00:07:27.647
awesome diagram of it, because
John Lukades told everybody ever
talking about UEFI that they

00:07:27.647,00:07:32.986
have to. Um, essentially if
you’re not familiar with UEFI,
it’s essentially what modern

00:07:32.986,00:07:38.325
BIOS is now, so it does all the
things that you don’t really,
ah, care about like CPU init,

00:07:38.325,00:07:44.597
change your memory, it loads a
bunch of option ROM's from like
your PCI devices. Ah, there’s

00:07:44.597,00:07:48.902
other talks that go over what
this actually means. Ah, but
what we’re concerned about is if

00:07:48.902,00:07:54.908
you look at the bottom, there’s
this notion of runtime services
and after the OS boots those are

00:07:54.908,00:08:00.013
exposed at the operating system
level. Some of the things that
get exposed within the runtime

00:08:00.013,00:08:05.652
services stage of UEFI are, ah
UFEI firmware variables. So,
these are persistent variables

00:08:05.652,00:08:10.557
that actually live within your
NVRAM on your, on-on your
platform. Ah, that are

00:08:10.557,00:08:15.061
accessible both to UEFI
applications like, if you're
familiar with secure boot, all

00:08:15.061,00:08:19.432
of your secure boot like
variables and stuff live there,
so like boot order, like your,

00:08:19.432,00:08:25.205
ah the keys that secure boot
utilises, things of that, ah
nature. So, we’re gonna take

00:08:25.205,00:08:29.943
advantage of the fact that we
can persist within NVRAM within
the UEFI platform that we can

00:08:29.943,00:08:36.182
then access it operating system
run time. Um, so sort of like,
you’re probably thinking at this

00:08:36.182,00:08:41.154
point, well why UEFI firmware
variables? Well, like I was
saying, it- it’s a way that you

00:08:41.154,00:08:45.825
can hide your payloads from all
of these detective capabilities,
cause its a-it’s a blind spot

00:08:45.825,00:08:50.597
for all of them. Nobody looks
here, like really at all,
especially within AV and EDR

00:08:50.597,00:08:55.435
platforms. Um, if you’re not
familiar really with what UEFI
firmware variables are either,

00:08:55.435,00:09:00.840
it essentially consists of like
a name and a GUID. So, it’s like
this 2pl and if you are able to

00:09:00.840,00:09:05.745
set or get that, ah that 2pl,
you can pull the contents of
what that variable is out of

00:09:05.745,00:09:10.850
NVRAM and we’re gonna kind of
showcase that we can execute
those live on the system, to

00:09:10.850,00:09:15.855
both stash our stuff and to sort
have like the persistence, ah
mechanism. >>So, really quickly,

00:09:19.125,00:09:23.863
ah like UEFI firmware variables
have a couple of types. There’s
authenticated and

00:09:23.863,00:09:28.401
unauthenticated. This isn’t so
much important but we kind of
just wanted to briefly touch on

00:09:28.401,00:09:32.405
it. Ah, just in case you’re
concerned at all with the
specification of what we’re

00:09:32.405,00:09:37.143
doing. Like, um if you’ve heard
of like authenticated variables,
these are signed like x509 certs

00:09:37.143,00:09:41.347
that, ah that perform like a
certificate check when writing.
Ah, we’re not gonna worry about

00:09:41.347,00:09:46.352
those, there are unauthenticated
variables that are also, um
present, ah at that runtime

00:09:46.352,00:09:50.590
stage. These have no
verification on write, the
majority of variables on a

00:09:50.590,00:09:55.462
platform is we will show you in
a demo, are unauthenticated. Ah,
so it’s not really abnormal for

00:09:55.462,00:09:59.299
these to be there and it's not
atypical for things to
necessarily be writing or

00:09:59.299,00:10:02.902
reading from there. Um, if
you’re like, a platform
researcher or something, you

00:10:02.902,00:10:08.641
know about this. Ah, there’s a
couple of attributes as well to
verify firmware variables, ah

00:10:08.641,00:10:13.279
within the specification. We’re
gonna really just focus on three
out of the six, because as I’ll

00:10:13.279,00:10:19.185
showcase in the Windows ten API,
ah you have to have non-volatile
boot service access and runtime

00:10:19.185,00:10:25.692
access in order to have, ah UEFI
variables that persist within
the Windows runtime, after boot

00:10:25.692,00:10:30.630
on your NVRAM. Um, so just note
that those three are gonna be
utilised and that’ll be shown in

00:10:30.630,00:10:36.002
the demo as well. Sort of the
hilarious little thing here too,
with the why we sort of started

00:10:36.002,00:10:42.375
thinking about UEFI as a, as a
way to hide from EDR. Is a in-in
an old old life we’re were

00:10:42.375,00:10:46.012
walking, you know, with some
Blue team, ah folks and we’re
talking about ways that we’ve

00:10:46.012,00:10:52.152
been-been tricky on engagements
and sharing some techniques.
And, we’re kinda talking about

00:10:52.152,00:10:56.489
like, ah IoT devices and how it
would be cool to hide in like in
IoT firmware. And they were

00:10:56.489,00:11:00.393
like, yeah that’d be cool but
like please don’t ever hide like
in platform firmware, you know,

00:11:00.393,00:11:05.398
Mike and I kind of stopped and
we were like, oh shit.
[Laughter] Ah, so we’re gonna do

00:11:07.667,00:11:11.938
Windows and Linux like Mike
said, ah UEFI is platform
agnostics so it doesn’t matter

00:11:11.938,00:11:16.943
what it's running on. it’s-it’s
part of your platform, it helps
boot intel like processors, it

00:11:16.943,00:11:22.649
also works like on AMD. Ah, it’s
kind of different there, its,
it’s a specification, whatever.

00:11:22.649,00:11:27.654
Um, so UEFI on Windows.
Basically, um I was re-looking
at the MSDN articles for Windows

00:11:31.524,00:11:37.163
ten and I recognised. So, they
had taken this off and then they
reintroduced the ability to do

00:11:37.163,00:11:43.836
UEFI platform stuff with an
1803. Um, so I was kinda like
reading the documents, they-they

00:11:43.836,00:11:48.541
listed all of these requirements
for actually been able to use
this-these API function, this

00:11:48.541,00:11:53.079
API functionality within Windows
now. So, it’s kinda concerning
cause there’s-there’s a lot

00:11:53.079,00:11:57.050
there that they say you need
this otherwise it won’t work.
Such as, you need to declare

00:11:57.050,00:12:01.588
firmware read and write in your
application manifest, you need
to have it be protected App, so

00:12:01.588,00:12:05.992
like a signed App that the
Microsoft store signs, it needs
to be signed. You need to be an

00:12:05.992,00:12:11.064
admin that has access to this
special privilege SE System
Environment name, ah like

00:12:11.064,00:12:15.902
privilege token in your process
space. So looking at it, it was
kinda daunting cause it’s-it’s

00:12:15.902,00:12:20.740
such a long list of
requirements. But, you know,
we’re hackers, that doesn’t mean

00:12:20.740,00:12:26.713
anything. Ah, so we started
looking at w-ways to bypass
this. This like spectre ops puts

00:12:26.713,00:12:31.417
out a lot of like w dot
byapsses, which is a way to
execute signed Windows binaries

00:12:31.417,00:12:36.222
but that will unsign Windows
binary, so like unsigned Windows
binaries you can still execute.

00:12:36.222,00:12:42.161
Um, obviously on Red Teams we
sometimes jump to conclusions or
we me make, ah some leaps

00:12:42.161,00:12:48.601
forward to speed up engagement
time with like assume breach
type, um scenarios or sort of

00:12:48.601,00:12:52.972
the methodology in thinking that
we’re gonna wind up being admin,
why don’t we just become admin

00:12:52.972,00:12:58.544
now. Um, so like that sort of
stuff for our purposes of doing
this sort of thing on Red team

00:12:58.544,00:13:02.882
engagements wasn’t necessarily
impactful. So, we just kinda
went with it, with the

00:13:02.882,00:13:06.486
assumption that we’re gonna be,
we can be an admin on a box and
we’re not gonna need it to be

00:13:06.486,00:13:13.092
assigned a Windows application.
So, like ah just to showcase
what the read and write firmware

00:13:13.092,00:13:19.065
variable API looks like from the
MSDN articles. You can do set
and get firmware variables from

00:13:19.065,00:13:24.203
NVRAM. Ah, really the key thing
here is you just have like the
name in GUID 2pl, that I was

00:13:24.203,00:13:30.410
mentioning earlier. Um, and for
a set, all you do is you point,
ah the buffer you want to write

00:13:30.410,00:13:34.614
into the variable, you give it
the size and the attributes that
you want it have to be declared

00:13:34.614,00:13:39.519
as and it just sets it in NVRAM
for you. And then forget it's
the same sort of idea, you give

00:13:39.519,00:13:44.190
it a name and a GUID 2pl and
then you give it the buffer you
want to read into and then it

00:13:44.190,00:13:48.995
reads the NVRAM out into some
memory buffer that you control
as the attacker and, of course,

00:13:48.995,00:13:53.966
you’ll wind up executing that
once you get the variable out of
NVRAM. Ah, these are the

00:13:53.966,00:13:57.003
attributes, not really
important, it’s on the slide
more for reference, but this is

00:13:57.003,00:14:02.575
from the MSDN article. Note that
for variable, ah attribute
runtime services, it says if you

00:14:02.575,00:14:07.547
want this to be accessible
during RT, it needs to also be
accessible to boot services. So,

00:14:07.547,00:14:11.784
that’s kinda why we’re gonna
have to set all three in
Windows, so, NVBS and RT

00:14:11.784,00:14:18.558
variables. So, when I was
initially implementing this, ah
it was sort of the decision

00:14:18.558,00:14:23.763
between if I wanted it to be in
C plus plus or in C sharp. So, I
initially implemented all of

00:14:23.763,00:14:29.202
this in C plus plus just because
it was, it was easy, cause the
MSDN articles basically just

00:14:29.202,00:14:33.740
give you the code you need. But
as I was kinda doing the
research, it occured to me that

00:14:33.740,00:14:38.644
C plus plus wasn’t a viable
option cause AV flags it very
easily. Um, like one thing you

00:14:38.644,00:14:43.583
have to do, obviously if we’re
getting a firmware variable is
you need RWX memory. So, doing a

00:14:43.583,00:14:48.387
lot of calls to like Virtual
Alloc, Virtual Protect is kinda
a red flag right now, especially

00:14:48.387,00:14:53.259
for EDR products cause they
start querying all these APIs.
Um, like most applications are

00:14:53.259,00:14:57.497
at like making an RWX memory
buffer and then executing it
like it was shell code. So,

00:14:57.497,00:15:01.901
we’re not gonna do that. Um, C
sharp can basically do
everything C plus plus can,

00:15:01.901,00:15:06.572
either with P/Invoke or
reflection. And having C sharp
malware experience in the past,

00:15:06.572,00:15:11.377
was like yeah lets just do it in
C sharp. Furthermore, most of
the C sharp bypasses or some of

00:15:11.377,00:15:15.748
the, most of the WDAC bypasses
are in C sharp anyway. So, that
kind like checked out that flag

00:15:15.748,00:15:20.086
off for us. And then in order to
make things kind of easier for
all of our Red Teams friends to

00:15:20.086,00:15:23.689
use, particularly on Windows
environments. We wanted to make
sure that they could, that they

00:15:23.689,00:15:28.995
could use it in C sharp is like
kinda the direction that, ah
malware authors and Windows are

00:15:28.995,00:15:33.800
kinda going for Red Team
engagements these days. Or-or
goaling. Um, but there’s

00:15:33.800,00:15:38.404
reference code for both in the
repo, which we will showcase
later after the talk. So,

00:15:38.404,00:15:42.708
essentially the steps for
writing a UEFI variable in
Windows, is really easy once you

00:15:42.708,00:15:47.180
have that admin privilege. Ah,
you essentially just need to
obtain the SE System Environment

00:15:47.180,00:15:52.351
name with SetPriv. Ah, this is
the only case, of like P/Invoke
that we’re gonna be using. Um,

00:15:52.351,00:15:55.688
furthermore, like I was saying,
like in the manifest where you
needed read and write

00:15:55.688,00:16:00.560
capabilities. The MSDN article
is weird in that it lists all of
those things for C plus plus

00:16:00.560,00:16:05.364
applications, it makes no notion
of ever doing the stuff in C
sharp. So, I’ve never had to

00:16:05.364,00:16:09.569
declare those things and I don’t
really know what Microsoft is
stating in that, so just ignore

00:16:09.569,00:16:13.940
that completely. You don’t need
it for C sharp. Ah, you can then
get the address of your pinned

00:16:13.940,00:16:18.477
buffer, so that’s our payload
and then we just write the UEFI
variable to NVRAM and now it's

00:16:18.477,00:16:25.084
persistent storage. So,here’s
some code really quickly to set
the privilege. Um, it just

00:16:25.084,00:16:30.256
P/Invokes, you get process, you
say that you want the new-the
new token privilege, you set it,

00:16:30.256,00:16:35.328
boom we’re good. Then you can
get the address of your, ah
pinned buffer in C sharp. Like I

00:16:35.328,00:16:41.467
said, this was your payload. So,
you initialize an end pointer,
you call, ah InteropServices to

00:16:41.467,00:16:46.305
get a pinned array of your-of
your buffer that you want to
write. You pin it, so the

00:16:46.305,00:16:50.509
garbage collector, n-nothing
can-can touch it as you’re
working with it. And then you

00:16:50.509,00:16:55.815
just simply write that UEFI
variable with the set firm
variable call with the-the 2pl.

00:16:55.815,00:17:00.253
And in this case, it’s gonna be
C sharp UEFI. And then I have a
super secret, ah super secret

00:17:00.253,00:17:05.258
super secret QUID, say that five
times fast. Um, that you can
Google and figure out what it

00:17:07.960,00:17:13.266
is. Ah, so the stuff for
executing UEFI variable are
pretty much similar. You still

00:17:13.266,00:17:18.537
need that token and the first
thing I did in C sharp was I did
P/Invoke with Virtual Alloc to

00:17:18.537,00:17:23.075
obtain an RWX memory pointer
that I can execute. And then I
was just obtaining that UEFI

00:17:23.075,00:17:28.547
variable back into that buffer
so I can execute it. Ah, so the
first step, same idea, you need

00:17:28.547,00:17:33.552
that privilege. Second step, is
I start P/Invoking some memory,
so I have RWX. Oh, but you can’t

00:17:36.222,00:17:40.893
actually really do that in C
sharp because it’s abnormal to
bring things into your import

00:17:40.893,00:17:46.499
address table that are in
actually C sharp specific. Um,
so like all of the Virtual calls

00:17:46.499,00:17:51.103
are more suspicious than getting
a new process token. Cause, ah
within like C sharp there’s no

00:17:51.103,00:17:54.840
real way to do like process
token stuff, you have to pretty
much P/Invoke, so it’s not

00:17:54.840,00:18:01.547
suspicious. It is suspicious for
EDR products, that you’re doing
Virtual Alloc, Virtual Free and

00:18:01.547,00:18:05.818
Virtual Protect within C sharp.
It’s like woah, stop right
there, we’re gonna tell the Blue

00:18:05.818,00:18:11.257
Team about this and they’re
gonna hunt you down. So, we
can’t do that. Hilariously

00:18:11.257,00:18:16.829
enough, as we were going through
this research, um OJ is working
on like a-a C sharp C alarm

00:18:16.829,00:18:21.867
interpreter. And he was dealing
with some stuff and he also says
the same thing, like don’t

00:18:21.867,00:18:26.706
P/Invoke your dot net apps. Like
EDR is gonna find you, like as
he says it’s the proverbial

00:18:26.706,00:18:31.744
solution for them hunting you
down. Ah, so we were not gonna
have, we’re gonna lose the

00:18:31.744,00:18:36.749
ability to P/Invoke to get RWX
memory. Ah, which is kind of a
problem. So, we can’t do step

00:18:38.784,00:18:45.358
two anymore, but fear not, ah
the CLR and C sharp is fantastic
for malware, so. We gonna

00:18:45.358,00:18:49.295
actually just now, instead of
doing any virtual calls, we’re
gonna use reflection within C

00:18:49.295,00:18:55.601
sharp to obtain RWX JIT memory,
which just in time compilation
leaves RWX memory pages if

00:18:55.601,00:19:00.906
you’re not familiar with it. To
read the UEFI variable into
that. Then we’re gonna write the

00:19:00.906,00:19:05.745
UEFI variable into a method
table printer and then we’re
gonna execute the method as if

00:19:05.745,00:19:10.750
nothing actually ever happened.
Ah, so those-those are the
steps, we’re gonna actually go

00:19:10.750,00:19:16.489
through that in detail cause
that was probably a little bit
jarring. Basically, in C sharp

00:19:16.489,00:19:22.261
if you’re not familiar with it,
because it’s an intermediate, ah
level language representation of

00:19:22.261,00:19:27.266
code, it has to get just in time
compiled to assembly code before
it gets executed by the

00:19:27.266,00:19:32.571
processor. So, within C sharp
there's a huge method table that
contains all the methods that

00:19:32.571,00:19:37.510
the C sharp application knows
about. And all of those contain
a JIT stub for those class’s

00:19:37.510,00:19:42.815
methods. So, essentially what
that means is at the time of
just in time compilation the

00:19:42.815,00:19:48.854
method table gets referenced.
You then get a function pointer
to the executable assembly code

00:19:48.854,00:19:54.160
that the processor will run,
which is RWX due to the notion
of JIT. You can grab that method

00:19:54.160,00:19:58.164
pointer, dereference the
function pointer that the
assembly code links to,which is,

00:19:58.164,00:20:02.768
ah just a location of the method
that you’re clobbering and
override it. So, this

00:20:02.768,00:20:07.006
essentially means that we can
declare a method that we don’t
care about, force it to just in

00:20:07.006,00:20:13.212
time compile, get the pointer to
it and then override it. Ah, so
it’s basically like read to libc

00:20:13.212,00:20:20.219
but in C sharp and it's like
more fucky. [Laughter] So, the
steps for that look like this.

00:20:20.219,00:20:25.191
We are essentially going to now
obtain an RWX JIT memory page,
read the variable into. That’s

00:20:25.191,00:20:30.663
gonna consist of defining a
method, ah to overwrite, JITing
the method, obtaining the

00:20:30.663,00:20:35.401
pointer to the method and then
overriding it and calling it.
So, we’ll define a method to

00:20:35.401,00:20:40.005
overwrite, this is in the code
that I’m going to be releasing,
it’s just called overwrite me,

00:20:40.005,00:20:46.512
it does nothing. We’ll JIT the
method. So, here you can see in
reflection I’m doing a type of,

00:20:46.512,00:20:52.051
the program I’m in get method
overwrite me,I call compile
service runtime helpers, prepare

00:20:52.051,00:20:55.788
method, which is essentially
just gonna to JIT that with the
method handle. So I have my

00:20:55.788,00:20:59.859
method dot method handle that’s
dereferencing one of the
pointers. And then I obtain the

00:20:59.859,00:21:04.230
pointer to the method, which is
just get function pointer once
I’ve JITed it. So, now I have

00:21:04.230,00:21:09.235
the location of the raw assembly
code after JIT and that RWX
memory location. So, now I write

00:21:11.270,00:21:16.909
the UEFI variable payload that’s
stored in NVRAM enter the
pointer to method, so I just

00:21:16.909,00:21:21.647
enter get firmware variable EX.
Ah, you can see the third
argument there, after the 2pl is

00:21:21.647,00:21:26.418
pointer to method. With then,
the fourth argument being buffer
length, that’s gonna take the

00:21:26.418,00:21:31.056
NVRAM out, plop it in and then I
can just execute the method
called overwrite me as if it was

00:21:31.056,00:21:37.363
actual C sharp code and I hadn’t
done anything malice. So, we’re
gonna do a quick demo, what that

00:21:37.363,00:21:42.034
looks like, ah to kind of tie it
all together in Windows. Um,
step one, you obtain your shell

00:21:42.034,00:21:47.907
on target. Ah, we’ve already
done that, so step one’s kind of
skipped. We’re then gonna run

00:21:47.907,00:21:52.845
write UEFI C sharp. You’ll see
this with the-with the writer
binary that I’ve written. Ah, in

00:21:52.845,00:21:56.048
an actual like Red team
engagement, or in a campaign
you’d probably do this with like

00:21:56.048,00:22:00.019
whatever C2 framework you were
using. So, you can use the C
sharp code say like in Cobalt

00:22:00.019,00:22:03.856
Strike with some of the
functionality there and do it on
Windows boxes. Um, you’ll then

00:22:03.856,00:22:08.527
do some sort persistence
mechanism for the reader binary,
which is going to go through and

00:22:08.527,00:22:13.465
do the steps I just demonstrated
with reflection. Um, it’s like a
four kilobyte binary, you’ll use

00:22:13.465,00:22:17.069
for persistence. You can, you
know, we’re not giving you
persistence mechanism. I’m sure

00:22:17.069,00:22:21.273
all of you have lots in your
bag. Ah, you just need to throw
this binary somewhere and-and

00:22:21.273,00:22:26.278
run it. And then we’ll, ah we’ll
run it to showcase what it looks
like. So, the Windows demo. Is,

00:22:32.551,00:22:39.058
this one. >>Computers are hard
>>Computers are hard. So, here I
am on Windows. Um, I’m gonna

00:22:39.058,00:22:43.229
first go through and write a
really quick Chipsec module. If
you’re not familiar with

00:22:43.229,00:22:48.133
Chipsec, it’s a UEFI platform
security tool that helps
security researchers analyse

00:22:48.133,00:22:53.739
platform firmware. Ah, it does a
lot of cool things for UEFI,
particularly variables. So, what

00:22:53.739,00:22:58.377
I did here, I just ran a module
to dump and list what all the
UEFI variables currently on my

00:22:58.377,00:23:03.415
system are. You can see that
there’s a lot of them. Do note
that most of these are NVBS plus

00:23:03.415,00:23:08.954
RT. Ah, so most of them are
accessible, ah at runtime
services to the operating system

00:23:08.954,00:23:14.560
and they’re, of course, because
they’re persistent they’re
persistent in NVRAM. So, there

00:23:14.560,00:23:18.864
they are, you didn’t see mine.
Here I’m gonna dump really
quickly the variable is to show

00:23:18.864,00:23:23.335
you that there’s content to all
of these variables. Like, this
one is kinda funny like test

00:23:23.335,00:23:29.441
zero, this is a test. Um, so
there’s lots of variables here,
nobody really ever audits them.

00:23:29.441,00:23:33.979
Like I said AV and EDR doesn’t
look here. So, now what I’m
gonna do is I’m gonna run write

00:23:33.979,00:23:39.885
UEFI or UEFI write C sharp,
that’s gonna write a UEFI
variable to NVRAM. I ran Chipsec

00:23:39.885,00:23:44.890
again to show you that it’s now
there. There it is, ah C sharp
dash UEFI. So, now that that’s

00:23:47.526,00:23:53.699
there on box, I can execute what
the payload is. Um, but first
I’m gonna show you what that

00:23:53.699,00:23:57.936
there's actual like, ah
shellcode there. So, I'll go
into the UEFI variables

00:23:57.936,00:24:01.774
directory with Chipsec, I’ll
dump it out and there you can
see that I have some shellcode

00:24:01.774,00:24:06.945
there that I’m gonna execute out
of NVRAM with the-with
the-the-the reader binary. Ah,

00:24:06.945,00:24:12.117
that payload for demo purposes
is gonna be our-our favourite
demo. Ah, metasploit, so it’s

00:24:12.117,00:24:17.222
just an interpreter shell that
I’m gonna spin up. I’m gonna go
through run UEFI read C sharp

00:24:17.222,00:24:22.428
and then as you can see from
that, ah I successfully just
executed a payload out of NVRAM

00:24:22.428,00:24:27.433
with like a four kilobyte binary
using a reflection. [Applause]
Thank you. So the fun doesn’t

00:24:31.637,00:24:36.442
actually end there. So because
this is a persistence mechanism
and it’s persistent, ah in

00:24:36.442,00:24:41.013
NVRAM. This means it’s gonna
survive reboots, it’s gonna
survive reinstalling your

00:24:41.013,00:24:45.017
operating system. The only way
to clear this out, is to like
clobber whatever that variable

00:24:45.017,00:24:52.024
or, ah pull NVRAM with like a
dediprog and we, ah like rewrite
your UEFI, um variable space.

00:24:52.024,00:24:57.029
So, I’m gonna shut down the box,
reboot it, go back to my
metasploit shell, Um, re-run the

00:24:59.064,00:25:04.036
console and then it’s a cooking
show, it takes a lot of time for
Windows to boot, so speed up, ah

00:25:04.036,00:25:08.340
you know, I just put the payload
in the oven. It’s gonna be done
pretty quickly. The machines

00:25:08.340,00:25:13.345
booting. Still booting. It’s a
cooking show, wait a minute,
there it is. Let’s see. And

00:25:17.483,00:25:21.854
there we go, I just executed my
payload out of NVRAM again, ah
with a persistence mechanism out

00:25:21.854,00:25:26.859
of a UEFI variable. [Applause]
>>Woo hoo, fresh cookies >>Yay,
cookies and shells. I baked some

00:25:31.830,00:25:37.169
shells, awesome. Um, so we kind
of like have hand waved the
persistence thing. We’re gonna

00:25:37.169,00:25:41.240
leave that as an exercise up to
the reader. Like I said, w dot
bypass’s are a great way to do

00:25:41.240,00:25:47.012
this. Ah, in actuality, ah your
payloads a UEFI variable, like
good luck have fun analysts. Ah,

00:25:47.012,00:25:52.284
we love you still though,like
we’re gonna help you but this is
fun. So like what about Windows

00:25:52.284,00:25:56.155
EDR products? We haven’t
necessarily touched on that.
Like obviously this is a way to

00:25:56.155,00:26:01.860
mitigate detection. Um, so we
looked at a couple of, ah EDR
vendors and we found no relevant

00:26:01.860,00:26:07.466
information pertaining to the
usage of either these API calls,
executing at a unified variable

00:26:07.466,00:26:11.737
or anything of that nature. The
only thing you’re really going
to see is that you’re executing

00:26:11.737,00:26:16.175
this binary. Ah, but like
there’s binary’s executed on
systems all the time, that’s not

00:26:16.175,00:26:22.047
really something too relevant
too-relevant that’s gonna
trigger a hunt. Um, furthermore,

00:26:22.047,00:26:27.486
ah there’s a lot of ways
currently to sinkhole or to
tamper with EDR products. So,

00:26:27.486,00:26:31.657
here’s like a five line power
shell script that you can use to
like sinkhole EDR products. This

00:26:31.657,00:26:37.296
works on a lot of them. Ah, like
EDR products are things of
software running on a box.

00:26:37.296,00:26:42.434
Software have configs, configs
can be tampered with, so just
tamper with configs a lot of the

00:26:42.434,00:26:46.805
times and you can get away with
anything on a box on Windows.
Um, there’s a lot of other ways

00:26:46.805,00:26:50.709
to go about it, we can chat like
after the talk about it. Ah,
this isn’t really a talk about

00:26:50.709,00:26:54.980
this, so it’s a talk about
hiding your shit. And that’s how
you hide your shit in Windows.

00:26:54.980,00:26:59.451
Um, some WDAC Bypasses just for
references. Ah, now that I’ve
talked about hiding your shit

00:26:59.451,00:27:05.991
in-in Windows, ah Mike’s gonna
talk about some Linux stuff.
>>Boy Windows is silly

00:27:05.991,00:27:10.729
[Laughter] Let’s, let’s-let’s
talk about Linux-Linux is you
know everyone knows that’s where

00:27:10.729,00:27:15.734
the real loot is. So, let’s talk
about the problem Space. Ah,
basically let’s introduce our

00:27:18.804,00:27:23.976
players here. We have, you know,
the kernel, we have the EDR and
we have on the right, we have,

00:27:23.976,00:27:30.115
your sample. And, you know, EDR
is looking at your sample and
that’s-that’s bad that’s what

00:27:30.115,00:27:35.988
makes it your sample and not
your payload. Um, and you know
the EDR and your sample are

00:27:35.988,00:27:41.727
actually kind of peers right?
We’re both running as privileged
processes and the EDR has some

00:27:41.727,00:27:46.632
hucks into kernel space to help
do, help it do its job and so
that’s what that sort of

00:27:46.632,00:27:51.637
rectangle just above the
eyeballs is. Eyeballs are
obviously EDR. [Laughter] And

00:27:54.206,00:27:59.211
so, like what does our solution
space look like? Well, you know.
What we really want is just to

00:28:01.513,00:28:05.717
make, you know, just to sucker
punch the EDR a little bit, you
know, while it’s not looking,

00:28:05.717,00:28:09.922
make sure that it just doesn’t
look at us at all. And then,
then it’s back to being our

00:28:09.922,00:28:14.927
payload. So, you know, how are
we gonna do that? We-we need to
like, we need to show up early

00:28:18.163,00:28:25.137
to the fight, right? So that it
never sees us coming. So we need
to infect something. So, you

00:28:25.137,00:28:30.609
know, how does your computer,
how does your computer boot? And
what can we infect? Well, the

00:28:30.609,00:28:35.013
first thing that boots, is
platform firmware and that’s
signed by the OEM, it can’t

00:28:35.013,00:28:40.586
really infect that easily. Boo.
The next things that’s signed by
Micro, the shim, that’s signed

00:28:40.586,00:28:46.525
by Microsoft and it pivots the
key over to the distro. That’s a
little bit harder to infect. Ah,

00:28:46.525,00:28:51.530
grub, you know, signed by the
distro, no good. The kernel
signed by the distro, no good.

00:28:54.099,00:29:01.006
But the ramdisk is generated on
system and not signed. This
sounds like a good time. And

00:29:01.006,00:29:06.645
then sometime later, some shit
happens in the EDR’s is started.
So, obviously what we need to

00:29:06.645,00:29:11.683
infect is the ramdisk. So how’re
we gonna, what capabilities do
we have? What-what-what-what

00:29:11.683,00:29:15.554
tools do we have at our disposal
in the Linux environment to-to
make things happen and-and-and

00:29:15.554,00:29:21.193
make the EDR not look at us? So,
ah the first sort of, ah
wonderful sys call to, ah

00:29:21.193,00:29:25.864
introduce is ptrace, right. And
this is, you know why we say the
90’s are back again, like

00:29:25.864,00:29:32.070
ptrace, ah exploitation of
processes been like, ah as-as
old as time itself. But, you

00:29:32.070,00:29:37.275
know, in-in it’s-it’s tapered
off in the, in the modern era
because we have policies that

00:29:37.275,00:29:43.081
prevent you from doing it. We
have like YAMA and SELinux and
AppArmor and silly stuff like

00:29:43.081,00:29:48.487
Smack and Tomoyo and whatever.
But the best part about all this
stuff is the policy is implied,

00:29:48.487,00:29:54.893
is applied in user space.
Alrighty. So, let’s-let’s-let’s
go through this, um, let’s go

00:29:54.893,00:29:59.898
through this in flow chart sort
of land. So, we have, um the
ramdisk is actually the original

00:30:05.103,00:30:10.108
Pid one, that’s actually where
ah, a init starts from. And then
it finds a root file system, you

00:30:14.046,00:30:18.850
know, draw some pretty stuff on
screen, like make sure you have
the right fonts, whatever. And

00:30:18.850,00:30:25.657
then it does,it actually deletes
everything out of the-out of the
root files system, except for

00:30:25.657,00:30:30.662
the target directory and then it
moves the mount from the target
to root. And then it exec’s

00:30:33.465,00:30:39.771
system D. And that will come
again in the sort of deleting
everything. And then like system

00:30:39.771,00:30:44.543
D starts and like, you know the
thumbs down is the policy being
loaded that prevents you from

00:30:44.543,00:30:48.947
attacking the EDR and then, of
course, our eyeballs here are
the EDR. So, let’s-let’s talk

00:30:48.947,00:30:54.186
about some other things we have,
fanotify. Fanotify, is kind of,
ah a obscure API, but like it’s

00:30:54.186,00:30:59.357
designed for AV. I don’t think
any AV actually uses it, but,
you know, who cares.

00:30:59.357,00:31:04.296
Ex-Exploding using security
API’s for unintended things is
like one of my favorite things.

00:31:07.032,00:31:12.838
[Laughter] So, basically what
this let’s you do is this let’s
you, um, you know do the AV

00:31:12.838,00:31:17.342
thing, right. Like a-a file is
accessed, you get to stop that
process from accessing that

00:31:17.342,00:31:23.181
file, decide whether it’s okay
and then you can say, if it is,
to go ahead, which is

00:31:23.181,00:31:28.186
effectively allows us to inhibit
start-up of other processes. Ah,
another fantastic utility is, ah

00:31:32.724,00:31:37.729
memfd create. Um, this has been
talked about a lot in-in, in
the-in the hackers scene but

00:31:40.065,00:31:45.070
essentially like you can create
an, ah anonymous file and, ah
this works like a file, get a

00:31:47.472,00:31:52.477
file descriptor. Ah,and then you
can actually access it through,
you know, proc pidfd, ah even

00:31:56.548,00:32:01.553
from other processes. This is
fantastic. Ah, and you know the
best part is, like everyone

00:32:01.553,00:32:06.558
says, never touch dis kids.
[Laughter] Ah, and then another
API that we can use is, and this

00:32:09.127,00:32:15.767
is also somewhat obscure and not
really security relevant, is, um
a PR Set PR Timer slack. So we

00:32:15.767,00:32:20.772
need some marker for our
process. Ah, to say, to the EDR,
don’t look at this. And so we

00:32:26.578,00:32:31.316
need something that’s
inheritable, right. So, you
know, you can-you can have your

00:32:31.316,00:32:37.155
malicious shell, you can catch
shadow and wincat does, cat also
inherits the marker. So, um, we

00:32:37.155,00:32:43.328
do the set timer slack that’s
basically, ah controls how often
you wake up the CPU. It’s

00:32:43.328,00:32:49.835
designed to save power, but I
don't care about that. And then
lastly like the config EFI VARS,

00:32:49.835,00:32:53.672
this is the final config to make
the EFI VARs file system, you
saw what a pain in the ass it

00:32:53.672,00:32:58.777
was to do stuff with UEFI and
Windows. Windows is dumb, it’s
just a file system, you just

00:32:58.777,00:33:05.383
read and write files, it’s super
easy, you can do it form a shell
script. [Laughter] And then I

00:33:05.383,00:33:11.423
talked previously about MS Move.
Like basically, um this, if you
look in the code, this is

00:33:11.423,00:33:16.795
labeled as black magic fuckery.
Um, [Laughter] I can go through
these steps but it’s really

00:33:16.795,00:33:21.800
convoluted. But essentially, um
if you want to have a malicious
processes survive pivoting the

00:33:24.502,00:33:30.308
root system out from under you,
there’s a whole lot a of really
weird stuff involving containers

00:33:30.308,00:33:37.148
and chroot’s and namespaces and
weird stuff to do just so that
your malicious process sees the

00:33:37.148,00:33:42.721
real root file system as opposed
to seeing the init root file
system, which has nothing in it.

00:33:42.721,00:33:48.193
Um, funny story, like even
though you can never have two
root file systems. Unless if you

00:33:48.193,00:33:53.231
don’t do this, you have two root
file systems in that process.
And, ah the-the real one and the

00:33:53.231,00:33:59.004
init one and you, and nothing is
there, it’s like really messed
up. So anyway, let’s go through

00:33:59.004,00:34:05.477
how this is, how-how this works
in practice. So, a little, ah a
little devil emoji here. I like

00:34:05.477,00:34:10.482
emojis. Ah, is our malicious
daemon. This is, this is
effectively stage one. Um, we,

00:34:12.684,00:34:17.689
in the-the init script in the
ramfs forks and execs that. We
open the, ah EFI virus, we

00:34:21.092,00:34:26.398
actually mount the EFI virus
file system, ah and mount proc
and all that. And then we fetch

00:34:26.398,00:34:31.403
it out of the, ah. We fetch
stage two and three out of EFI,
out of UEFI land. And then we

00:34:34.139,00:34:40.679
just kind of stay there and we
cross that boundary between init
REM MFS land and, you know the

00:34:40.679,00:34:46.351
real system land. And that
execs, you know our friend
system D, which then spawns all

00:34:46.351,00:34:52.891
kinds of other garbage. And when
it spawns the policy load, which
we detected through fanotify, we

00:34:52.891,00:34:59.631
give as stop signal to sysctl,
right. Sysctls’s gonna apply the
policy that says you cannot be

00:34:59.631,00:35:06.538
ptrace. And there’s our EDR over
there. You think you can figure
out the next step. Ah, we’re

00:35:06.538,00:35:11.543
gonna ptrace the, ah the EDR end
then like have our with it.
[Laughter] So, ah what ptrace

00:35:15.080,00:35:20.085
allows us to do, is basically we
stop the process. You can see,
ah we probably end up stopping

00:35:22.554,00:35:27.559
it right after or before a-a
syscall. And we can just back
up. Ah, we can just back up to

00:35:31.129,00:35:36.134
the syscall and we can c-control
the IP back to the syscall and
then we can just set EAX and set

00:35:38.370,00:35:42.207
what syscalls we would like to
make. So, we’re effectively
coercing syscalls into the

00:35:42.207,00:35:48.313
process. So, we can call memfd
create. Then in our other
process because we can access

00:35:48.313,00:35:53.318
proc fd, proc pidfd, we can
shove stage-stage three in
there, which is embedded in

00:35:55.954,00:36:00.892
stage two. Which, by the way,
never touched disk. [Laughter]
And then we can do an mmap. Ah,

00:36:03.962,00:36:09.134
fortunately unlike in-in
Windows, ah, mmapping
rewrite-write execute pages is

00:36:09.134,00:36:13.938
like totally normal, libc does
it all the time. Um, and then we
can just put our shellcode in

00:36:13.938,00:36:18.943
there. And then we set, oop, I
went too fast. Then we set our
EIP to the sled there. And we

00:36:22.347,00:36:27.352
actually just jump over. And
then we effectively return to-we
return to dlopen as um,

00:36:32.557,00:36:37.962
as-as-as,as we learned
yesterday. And this I kind of
already new, like [Laughter] Ah,

00:36:37.962,00:36:44.736
I’m sorry I forgot the speaker's
name who talked about it
yesterday. >>Tommy-Tommy Newcart

00:36:44.736,00:36:49.741
>>Tommy Newcart, oh no, I’m out
of sync, anyway. [Laughter] So,
ah lipc has an internal dlopen,

00:36:52.210,00:36:57.148
we can do, ah the old school, ah
ld preload trick, accept for
without ld preloading we can

00:36:57.148,00:37:03.221
call the internal dlopen, then
we can and hack our malicious
SO. And that malicious SO can

00:37:03.221,00:37:08.226
clobber whatever we need to
clobber. And then we return,
alright. So, now we can send the

00:37:10.895,00:37:15.900
continue to our, ah policy load
and load the actual policy that
prevents us from doing this. And

00:37:18.269,00:37:24.509
our EDR is actually now looking
the other way. So, basically, um
if you look in the code and you

00:37:24.509,00:37:29.514
see our payload, um and this is
sort of a-a point that also
Topher t-touched on. That, ah

00:37:32.550,00:37:37.122
you don’t wanna there’s two
options here about clobbering
the EDR, either the input stage

00:37:37.122,00:37:40.725
or the output stage. And the
input stage is complicated you
have to understand how it

00:37:40.725,00:37:44.562
processes information from the
kernel. The output stage is
super simple, you-you’ve already

00:37:44.562,00:37:48.833
looked at the logs, you know
what they say. You just wanna,
you know compromise its ability

00:37:48.833,00:37:53.905
to write things to the output
log, or things you don’t want to
the output log. And then there’s

00:37:53.905,00:37:58.109
our malicious process and
everybody’s happy. The EDR is
look away and we can plunder

00:37:58.109,00:38:03.047
away. So, ah, let's do a little
demo. Um, what I’m gonna do is,
ah we’re gonna, ah tune up

00:38:06.551,00:38:12.323
auditd. Auditd is our example
EDR, ah you know, I know that
like auditd is not a commercial

00:38:12.323,00:38:17.228
EDR vendor and your wondering
does this work on commercial EDR
vendor, yep, probably. Ah. And,

00:38:17.228,00:38:22.734
ah we’ll install an implant,
we’ll reboot, we’ll set the
marker. We’ll done, do the

00:38:22.734,00:38:27.739
exploit again and we’ll show
that we’re invisible. Alright,
let’s do the demo. Okay, ah, oh

00:38:32.510,00:38:37.515
god how do you do this? Windows
is hard. Oh god >>Do it, okay,
oh god, what did do. Oh god.

00:38:50.061,00:38:54.699
[Laughter] >>I-I know how to use
Windows [ Laughter] >>This
Windows shit is complicated.

00:38:54.699,00:38:59.704
Alright, here we go. We got the
analyst on-on the right, we got
the hacker on the left and um

00:39:04.475,00:39:08.046
what we’re gonna do, is the
analyst is gonna turn on the
audit rules. He’s gonna tune up

00:39:08.046,00:39:14.852
audit so that’s it just, ah has
every exec. Then we’re going to
tale the audit log, we’re going

00:39:14.852,00:39:18.156
to exploit the enterprise tool.
You can see we root, we’re
making all this noise, it’s

00:39:18.156,00:39:24.462
terrible. You know,
they’re-they’re gonna roll us
up. You can see it on the right,

00:39:24.462,00:39:27.999
all that noise. Then we’re gonna
run our infector binary on. Our
infector binary is gonna make a

00:39:27.999,00:39:34.005
whole lot of noise. But, um this
noise is actually really normal
because, ah systems generate, ah

00:39:34.005,00:39:39.811
init REM MFS’s all the time. So,
it’s fine. So, it’s gonna make
basically all the noise that it

00:39:39.811,00:39:44.816
makes on a, ah, on ah UEFI or on
a init MFS update. Ah, this is
kind of a lot of reuse harness

00:39:48.987,00:39:54.092
from my horsepill talk from a
few years ago. But, you know
it’s as true today as it was

00:39:54.092,00:39:59.163
there, and like you know
everything’s affected, have a
nice day. [Laughter] And then

00:39:59.163,00:40:04.435
we’re gonna reboot.
Do-do-do-doo, let’s do some
quicky showtime, let’s see-let’s

00:40:04.435,00:40:09.440
see if I edited this video well
enough. Well, here we are,
waiting, okay waiting. I’ll-I’ll

00:40:12.143,00:40:17.148
edit it tighter next time. Okay,
and again we’ve tuned up audit
and you can see we-we’re, um

00:40:19.183,00:40:24.188
displaying the audit, ah, log
there. Let’s, let’s see make a
little space there, do-do-doo.

00:40:28.393,00:40:33.398
Okay, and then we’re gonna do
the same thing. We’re gonna
exploit, ah, actually we’re

00:40:33.398,00:40:37.635
gonna set our marker first and
that’s gonna make a little bit
of noise. But once you set the

00:40:37.635,00:40:43.174
timer slack, that’s what that
prtcl call is, you can see, ah
the marker’s set and you can

00:40:43.174,00:40:48.846
also see that there’s no noise
in the audit log. We’re- and
then I- I- I gain root again.

00:40:48.846,00:40:53.851
And you can see again, no noise,
we’re-we’re invisible. We can-we
can do all those nasty things we

00:40:56.454,00:41:01.392
did before. Invisible, it’s
awesome, ta da. [Laughter]
[Applause] And then, ah, we can

00:41:05.997,00:41:11.936
show that we can show the policy
is applied. You can see like
mmode three, it means ptrace is

00:41:11.936,00:41:15.506
completely disabled in the
system and that is true. Like
ptrace is now completely

00:41:15.506,00:41:21.379
disabled in the system, but we
inhibited the policy load that
prevented us from doing that.

00:41:21.379,00:41:25.683
And then, ah like I said
everything’s a file-a file
system, or everything's a file

00:41:25.683,00:41:30.922
in Linux. Like there’s an EFI
file system if you look like, ah
somewhere in there should be a

00:41:30.922,00:41:35.927
lol key, yeah there it is. Yeah,
right around there. Cause
hacking is funny. And then ta

00:41:38.129,00:41:43.134
da, we did it. [Laughter] How do
we get back to the slides. Okay
[Laughter] [Applause] Thank you.

00:41:46.738,00:41:53.678
And, you know, everyone on a
Saturday morning at DefCon is
always thinking to themselves,

00:41:53.678,00:41:59.917
what-what does this all mean?
[Laughter] You know, we just
want to bring happiness to

00:41:59.917,00:42:06.557
everyone. [Laughter] Everyone’s
gonna sleep well tonight this is
a net happiness increase, you’re

00:42:06.557,00:42:11.696
happy. The, the analyst is
happy, that-that payload that
you spent months working on is

00:42:11.696,00:42:16.601
still your payload and not their
sample. Everything is good,
that’s what we’re all about.

00:42:16.601,00:42:22.440
Bringing happiness to the world.
[Laughter] Alright, I don’t
really care about mitigation, so

00:42:22.440,00:42:25.943
I’ll have Topher talk about
that. >>Ah, I mean I don’t
really care either but we felt

00:42:25.943,00:42:30.415
it necessary. Um, there’s a
couple of things that you can do
to mitigate this. Like, the one

00:42:30.415,00:42:35.586
biggest thing is, cause we’re
utilising UEFI variables, is to
actually monitor and audit those

00:42:35.586,00:42:38.990
against your organization's
fleet. That would, ah, that
would be like the first step to

00:42:38.990,00:42:43.628
sort of mitigating these risks
that we’ve presented. Um,
furthermore, EDR vendors, if any

00:42:43.628,00:42:48.633
of you are out there, you should
be detecting UEFI APIs and this
functionality in Windows in

00:42:48.633,00:42:53.071
Linux bases if you happen to be
doing, like Linux EDR. Um, it’s
not really common for

00:42:53.071,00:42:57.575
applications to set and get
firmware variables. Um, and
furthermore, like after the

00:42:57.575,00:43:03.948
installation of a platform. Ah,
NV, BS and RT variables being
set is-is pretty weird. Ah, I’ve

00:43:03.948,00:43:07.618
never actually seen that in
practice. If you have seen that
in practice come talk to me

00:43:07.618,00:43:13.391
about it, cause I’d like to know
where cause I want to abuse it.
[Laughter] Um, furthermore, as

00:43:13.391,00:43:17.995
we kinda showcase EDR tamper
resistance is not at all
effective. Ah, it’s very easy to

00:43:17.995,00:43:23.868
like sinkhole, ah the sensor,
kill the sensor. As Mike showed,
it’s very easy to ptrace the

00:43:23.868,00:43:28.806
sensor. Um, so vendors really
just need to work on securing
their, ah agents and their

00:43:28.806,00:43:33.444
processes a little bit better.
Um, furthermore, um Mike kinda
said this in his horsetail talk

00:43:33.444,00:43:38.349
at Blackhat a few years ago.
Assembling ramdisks on systems
is just silly. Stop doing that

00:43:38.349,00:43:44.055
if you’re on Linux distro. Um,
so like as far as closing and
the rest goes, ah we have some

00:43:44.055,00:43:49.060
future work. >>So, you know, the
system firmware is, ah a great-a
great place to-to hide and

00:43:51.229,00:43:56.634
there’s all kinds of goodies in
there. And we’re just touching
the surface of it. And it’s

00:43:56.634,00:44:01.539
interesting like, as we were
doing this research a lot of
companies started announcing

00:44:01.539,00:44:06.544
that they’re going to start
looking at the firmware space as
a place to hunt. But, you know,

00:44:08.579,00:44:13.351
this is a cat and mouse game
and, ah as far as I can tell the
ah. Are we the mouse or are we

00:44:13.351,00:44:18.356
the cat? Anyway one of us >>
Depends on the day >>is already
ahead [Laughter] and I think

00:44:20.558,00:44:26.564
it’s us. I’m not sure we’re the
cat or the mouse. [Laughter]
Alright. >>So, like in closing

00:44:26.564,00:44:30.668
we’re bringing net happiness to
everybody. We're gonna have
ourselves a UEFI dot party.

00:44:30.668,00:44:36.073
We’re plundering away our loot,
we’re sucker punching that pesky
EDR. Um, and all of our code is

00:44:36.073,00:44:40.511
located on this GitHub link. Ah,
perturbed platypus or you know,
as we like to call ourselves

00:44:40.511,00:44:47.151
aptpp. [Laughter] Ah, we-we just
pushed the code, we just
confirmed it. We had a- we had a

00:44:47.151,00:44:53.324
timer on a-on a box that pushed
at exactly ten forty five. Ah,
it’s live so go-go have it.

00:44:53.324,00:44:58.296
Plunder away. Ah, here’s some
references you can look at. Ah,
that-that’s all we got for ya.

00:44:58.296,00:45:02.400
[Applause]

