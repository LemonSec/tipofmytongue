1
00:00:01,850 --> 00:00:07,609
[Music]

2
00:00:09,200 --> 00:00:10,639
hi

3
00:00:10,639 --> 00:00:13,360
cool so thanks everybody for coming

4
00:00:13,360 --> 00:00:17,799
this talk is called morpheus malware

5
00:00:18,400 --> 00:00:21,119
and yeah my name is sebastian

6
00:00:21,119 --> 00:00:23,279
i'm working as a red team operator at a

7
00:00:23,279 --> 00:00:25,439
company called codewide

8
00:00:25,439 --> 00:00:27,199
we're basically doing all sorts of red

9
00:00:27,199 --> 00:00:29,439
teaming purple teaming

10
00:00:29,439 --> 00:00:31,039
also regular pen tests but we

11
00:00:31,039 --> 00:00:33,520
specialized on red and purple teaming

12
00:00:33,520 --> 00:00:36,079
my main part in the team is the creation

13
00:00:36,079 --> 00:00:38,879
of offensive tools and

14
00:00:38,879 --> 00:00:40,640
probably most importantly the creation

15
00:00:40,640 --> 00:00:42,399
of a custom c2 which we are using in our

16
00:00:42,399 --> 00:00:44,160
assessments

17
00:00:44,160 --> 00:00:46,960
and this talk is about the execution and

18
00:00:46,960 --> 00:00:49,920
the hiding of malware in the

19
00:00:49,920 --> 00:00:52,640
context of another process

20
00:00:52,640 --> 00:00:54,320
we will be taking a look at techniques

21
00:00:54,320 --> 00:00:56,480
which are typically used by adversaries

22
00:00:56,480 --> 00:00:58,719
to avoid detection either by security

23
00:00:58,719 --> 00:01:01,520
products or by analysts which are

24
00:01:01,520 --> 00:01:03,520
manually taking a look at

25
00:01:03,520 --> 00:01:05,519
processes which might be infected

26
00:01:05,519 --> 00:01:07,200
and we will be trying to finger

27
00:01:07,200 --> 00:01:09,360
fingerprint infected processes

28
00:01:09,360 --> 00:01:12,720
simply by looking at the memory

29
00:01:12,720 --> 00:01:15,439
the states of certain threads

30
00:01:15,439 --> 00:01:18,159
and by taking a look at the call stack

31
00:01:18,159 --> 00:01:20,240
of certain threads

32
00:01:20,240 --> 00:01:21,920
i then show you

33
00:01:21,920 --> 00:01:23,840
i will try to give you an idea of how to

34
00:01:23,840 --> 00:01:25,759
avoid being fingerprinted

35
00:01:25,759 --> 00:01:28,159
by blending by blending in with false

36
00:01:28,159 --> 00:01:30,320
positives or by using a bit more

37
00:01:30,320 --> 00:01:32,640
advanced techniques

38
00:01:32,640 --> 00:01:35,200
so two slides of

39
00:01:35,200 --> 00:01:37,040
general talk

40
00:01:37,040 --> 00:01:38,720
why does it actually matter

41
00:01:38,720 --> 00:01:40,479
for us red teams

42
00:01:40,479 --> 00:01:41,840
protecting and hiding our tools

43
00:01:41,840 --> 00:01:44,000
definitely has priority for two reasons

44
00:01:44,000 --> 00:01:46,079
the first reason is that we obviously do

45
00:01:46,079 --> 00:01:48,399
not want to get caught if we get caught

46
00:01:48,399 --> 00:01:50,000
um then the operation is pretty much

47
00:01:50,000 --> 00:01:52,159
ruined we didn't fulfill the goal

48
00:01:52,159 --> 00:01:54,320
the second reason is that custom tooling

49
00:01:54,320 --> 00:01:56,479
is quite complex and also precious

50
00:01:56,479 --> 00:01:57,840
those of you who are developing their

51
00:01:57,840 --> 00:01:59,840
own c2 know that it's a quite painful

52
00:01:59,840 --> 00:02:02,079
task and it might take ages

53
00:02:02,079 --> 00:02:03,520
to to achieve it

54
00:02:03,520 --> 00:02:05,600
um dropping tools on disk is obviously

55
00:02:05,600 --> 00:02:07,280
considered an upset fail

56
00:02:07,280 --> 00:02:08,479
operators

57
00:02:08,479 --> 00:02:10,239
tend to forget their tools on disk which

58
00:02:10,239 --> 00:02:11,680
is a big problem

59
00:02:11,680 --> 00:02:13,680
because security solutions are really

60
00:02:13,680 --> 00:02:15,520
good at analyzing stuff that you ever

61
00:02:15,520 --> 00:02:16,879
put on disk

62
00:02:16,879 --> 00:02:19,120
um but even more important like before

63
00:02:19,120 --> 00:02:21,040
real operators forget what they stored

64
00:02:21,040 --> 00:02:23,840
on disk at some point

65
00:02:24,560 --> 00:02:25,920
the thing with the memory malware is

66
00:02:25,920 --> 00:02:27,520
that it needs a host process otherwise

67
00:02:27,520 --> 00:02:28,800
it wouldn't work

68
00:02:28,800 --> 00:02:30,400
you cannot simply choose any process

69
00:02:30,400 --> 00:02:32,720
that you like notepad.exe for example it

70
00:02:32,720 --> 00:02:34,879
doesn't make any sense why

71
00:02:34,879 --> 00:02:37,040
because usually the process that you're

72
00:02:37,040 --> 00:02:38,879
injecting your tool into

73
00:02:38,879 --> 00:02:41,440
um the behavior of this process should

74
00:02:41,440 --> 00:02:44,879
be as similar as um as possible compared

75
00:02:44,879 --> 00:02:46,720
to the tool that you're injecting

76
00:02:46,720 --> 00:02:48,000
for example it doesn't make any sense to

77
00:02:48,000 --> 00:02:49,599
inject the cobalt beaking into notepad

78
00:02:49,599 --> 00:02:51,280
why because notepad usually doesn't have

79
00:02:51,280 --> 00:02:53,519
any internet connections right

80
00:02:53,519 --> 00:02:55,360
so you will

81
00:02:55,360 --> 00:02:57,040
have to carefully choose the host

82
00:02:57,040 --> 00:02:59,200
process um based on does it make any

83
00:02:59,200 --> 00:03:01,200
internet or internet connections is it

84
00:03:01,200 --> 00:03:03,280
making use of dp api or is it even

85
00:03:03,280 --> 00:03:05,280
probably known to legitimately access

86
00:03:05,280 --> 00:03:06,239
elders

87
00:03:06,239 --> 00:03:07,760
i personally like to target browsers

88
00:03:07,760 --> 00:03:09,200
because they're doing pretty much all of

89
00:03:09,200 --> 00:03:10,400
this

90
00:03:10,400 --> 00:03:11,760
um so and the thing with process

91
00:03:11,760 --> 00:03:13,360
injection is that it's nowadays quite

92
00:03:13,360 --> 00:03:15,200
heavily monitored and this is what this

93
00:03:15,200 --> 00:03:17,360
talk is going to be about so how does it

94
00:03:17,360 --> 00:03:19,920
work basically it works in three steps

95
00:03:19,920 --> 00:03:21,519
the first step being that you kind of

96
00:03:21,519 --> 00:03:23,280
need to open a handle on the process

97
00:03:23,280 --> 00:03:25,040
that you're trying to inject into

98
00:03:25,040 --> 00:03:26,959
a handle basically allows you to perform

99
00:03:26,959 --> 00:03:28,319
certain operations on the process that

100
00:03:28,319 --> 00:03:30,319
you're trying to fiddle with

101
00:03:30,319 --> 00:03:32,640
the second step is then to kind of

102
00:03:32,640 --> 00:03:34,000
somehow inject the payload that you're

103
00:03:34,000 --> 00:03:36,319
trying to execute so you need to write

104
00:03:36,319 --> 00:03:38,640
code into the context of another process

105
00:03:38,640 --> 00:03:40,319
and the last step is that you somehow

106
00:03:40,319 --> 00:03:41,840
need to make the process into which

107
00:03:41,840 --> 00:03:43,599
you're injecting to actually execute the

108
00:03:43,599 --> 00:03:45,920
payload

109
00:03:45,920 --> 00:03:48,400
so once again first step handle creation

110
00:03:48,400 --> 00:03:50,000
um

111
00:03:50,000 --> 00:03:51,680
the most obvious way to do this is to

112
00:03:51,680 --> 00:03:53,360
simply make use of an api call called

113
00:03:53,360 --> 00:03:55,439
open process you specify a pid you

114
00:03:55,439 --> 00:03:57,760
specify a process access mask

115
00:03:57,760 --> 00:03:59,920
and depending on if you have the right x

116
00:03:59,920 --> 00:04:01,280
the right um

117
00:04:01,280 --> 00:04:02,720
permissions on the process that you're

118
00:04:02,720 --> 00:04:04,319
trying to access you will be given a

119
00:04:04,319 --> 00:04:05,519
handle

120
00:04:05,519 --> 00:04:06,879
there are a bunch of problems with this

121
00:04:06,879 --> 00:04:08,640
approach then the first or the big

122
00:04:08,640 --> 00:04:10,720
problem is that

123
00:04:10,720 --> 00:04:13,439
upon process access there's a there's a

124
00:04:13,439 --> 00:04:14,879
kernel callback

125
00:04:14,879 --> 00:04:17,120
meaning that um the kernel is going to

126
00:04:17,120 --> 00:04:19,040
notify every single driver which is

127
00:04:19,040 --> 00:04:20,798
subscribing to this kernel callback

128
00:04:20,798 --> 00:04:22,800
about this process

129
00:04:22,800 --> 00:04:24,639
is actually opening another process with

130
00:04:24,639 --> 00:04:26,560
this access mask

131
00:04:26,560 --> 00:04:27,680
which makes

132
00:04:27,680 --> 00:04:29,440
the creation of a new handle quite easy

133
00:04:29,440 --> 00:04:31,520
to observe for security products because

134
00:04:31,520 --> 00:04:33,440
of this kernel callback

135
00:04:33,440 --> 00:04:34,800
and this is why you have the the swiss

136
00:04:34,800 --> 00:04:35,919
mount event

137
00:04:35,919 --> 00:04:37,600
um which is letting you know that

138
00:04:37,600 --> 00:04:39,840
scratchpad xc is opening node.xc in this

139
00:04:39,840 --> 00:04:41,440
case

140
00:04:41,440 --> 00:04:42,960
a probably better way would be to make

141
00:04:42,960 --> 00:04:45,360
use of a concept called hand duplication

142
00:04:45,360 --> 00:04:46,960
and it basically works as follows the

143
00:04:46,960 --> 00:04:49,199
observation is that there are multiple

144
00:04:49,199 --> 00:04:52,160
processes on windows and there might

145
00:04:52,160 --> 00:04:53,520
even be a process which is already

146
00:04:53,520 --> 00:04:54,960
holding a handle on the process that

147
00:04:54,960 --> 00:04:56,720
you're trying to inject into

148
00:04:56,720 --> 00:04:58,400
uh that means that

149
00:04:58,400 --> 00:04:59,840
everything you need to do is you need to

150
00:04:59,840 --> 00:05:01,280
open the other process which already

151
00:05:01,280 --> 00:05:02,560
holds a handle to the process that

152
00:05:02,560 --> 00:05:04,160
you're trying to inject into

153
00:05:04,160 --> 00:05:06,320
um duplicate or steal this toke this

154
00:05:06,320 --> 00:05:07,919
handle from the other process and then

155
00:05:07,919 --> 00:05:10,479
reuse it in another context like this

156
00:05:10,479 --> 00:05:12,160
you're kind of shifting the problem away

157
00:05:12,160 --> 00:05:13,759
from opening the target process but

158
00:05:13,759 --> 00:05:17,039
you're opening another process

159
00:05:17,759 --> 00:05:19,120
last year i released the tool which is

160
00:05:19,120 --> 00:05:21,520
called handlecads it leverages this

161
00:05:21,520 --> 00:05:23,440
exact technique to obtain a handle to

162
00:05:23,440 --> 00:05:26,320
elsa's and it went pretty well by uh

163
00:05:26,320 --> 00:05:28,720
bypassing a bunch of security products

164
00:05:28,720 --> 00:05:30,560
because there is no process access event

165
00:05:30,560 --> 00:05:32,320
anymore on azure right

166
00:05:32,320 --> 00:05:33,919
um there's a big problem with this

167
00:05:33,919 --> 00:05:35,360
approach however and this approach is

168
00:05:35,360 --> 00:05:36,320
that

169
00:05:36,320 --> 00:05:37,840
there is not always a suitable handle

170
00:05:37,840 --> 00:05:39,280
pre-existing on the system that you

171
00:05:39,280 --> 00:05:42,639
infected so it's not really reliable

172
00:05:42,639 --> 00:05:44,960
what is probably a bit less known is

173
00:05:44,960 --> 00:05:46,720
that existing handles can also be

174
00:05:46,720 --> 00:05:48,880
upgraded this means that you can

175
00:05:48,880 --> 00:05:51,120
basically create a new handle on the

176
00:05:51,120 --> 00:05:52,639
target process with a very limited

177
00:05:52,639 --> 00:05:54,320
access mask which doesn't show your your

178
00:05:54,320 --> 00:05:55,759
real intent

179
00:05:55,759 --> 00:05:57,440
and before you actually use it you

180
00:05:57,440 --> 00:05:59,120
duplicate it once again and when you

181
00:05:59,120 --> 00:06:00,880
duplicate it you say well the duplicated

182
00:06:00,880 --> 00:06:02,720
version of this handle it would be nice

183
00:06:02,720 --> 00:06:05,280
if it had another process another axis

184
00:06:05,280 --> 00:06:06,800
mask

185
00:06:06,800 --> 00:06:08,479
this is really cool because

186
00:06:08,479 --> 00:06:11,280
there is no suspicious process access

187
00:06:11,280 --> 00:06:13,600
event there is only process the

188
00:06:13,600 --> 00:06:15,199
duplication of a pre-existing handle

189
00:06:15,199 --> 00:06:18,160
with another access mask

190
00:06:18,400 --> 00:06:20,479
this is quite cool because there is

191
00:06:20,479 --> 00:06:22,400
there are kernel callbacks for handle

192
00:06:22,400 --> 00:06:24,560
duplication but system for example is

193
00:06:24,560 --> 00:06:25,680
not

194
00:06:25,680 --> 00:06:27,280
subscribing to this

195
00:06:27,280 --> 00:06:29,440
kernel callback you can still observe

196
00:06:29,440 --> 00:06:31,280
observe this

197
00:06:31,280 --> 00:06:33,360
in the windows security lock

198
00:06:33,360 --> 00:06:34,960
but the problem with this is that it

199
00:06:34,960 --> 00:06:37,600
must actually be configured per process

200
00:06:37,600 --> 00:06:39,919
and it's not enabled by default so i

201
00:06:39,919 --> 00:06:41,280
really like to go with this approach in

202
00:06:41,280 --> 00:06:44,000
order to get a handle to another process

203
00:06:44,000 --> 00:06:45,680
the thing is that obtaining a handle was

204
00:06:45,680 --> 00:06:47,280
only the first step right i showed you

205
00:06:47,280 --> 00:06:49,120
three steps that we need to need to do

206
00:06:49,120 --> 00:06:51,039
um the first step was actually not that

207
00:06:51,039 --> 00:06:52,160
difficult

208
00:06:52,160 --> 00:06:54,880
um the real problem starts we need to we

209
00:06:54,880 --> 00:06:57,680
now need to use our newly created handle

210
00:06:57,680 --> 00:06:59,680
in order to inject the payload into

211
00:06:59,680 --> 00:07:02,160
another process how do we do this and

212
00:07:02,160 --> 00:07:04,160
the problem with this is that there are

213
00:07:04,160 --> 00:07:05,599
a bunch of

214
00:07:05,599 --> 00:07:06,880
security

215
00:07:06,880 --> 00:07:08,800
techniques um trying to make your life

216
00:07:08,800 --> 00:07:10,479
more difficult so for example you guys

217
00:07:10,479 --> 00:07:11,759
might have heard of a concept called

218
00:07:11,759 --> 00:07:13,599
user land hooks there are even more

219
00:07:13,599 --> 00:07:15,280
kernel callbacks and there's also event

220
00:07:15,280 --> 00:07:17,759
tracing for windows

221
00:07:17,759 --> 00:07:18,560
um

222
00:07:18,560 --> 00:07:20,479
let us first talk about a bit about user

223
00:07:20,479 --> 00:07:22,880
land hooks and system calls

224
00:07:22,880 --> 00:07:24,720
this is a quite old concept and it's

225
00:07:24,720 --> 00:07:27,120
being widely used and exploited in the

226
00:07:27,120 --> 00:07:28,880
security scene but for those of you who

227
00:07:28,880 --> 00:07:30,960
might have never heard of are two slides

228
00:07:30,960 --> 00:07:31,680
of

229
00:07:31,680 --> 00:07:32,800
of theory

230
00:07:32,800 --> 00:07:34,720
um the thing is that antivirus really

231
00:07:34,720 --> 00:07:36,960
like to redirect the execution flow of

232
00:07:36,960 --> 00:07:39,199
suspicious api calls

233
00:07:39,199 --> 00:07:41,280
they do so so that they understand when

234
00:07:41,280 --> 00:07:43,840
a certain api call was used by a process

235
00:07:43,840 --> 00:07:46,240
and with which parameters it was used

236
00:07:46,240 --> 00:07:48,160
um they do so because

237
00:07:48,160 --> 00:07:48,960
they

238
00:07:48,960 --> 00:07:50,639
do not really have any other chance to

239
00:07:50,639 --> 00:07:52,240
understand when a certain api call is

240
00:07:52,240 --> 00:07:53,039
used

241
00:07:53,039 --> 00:07:54,479
there are not there's not a kernel

242
00:07:54,479 --> 00:07:56,080
callback for every single system call

243
00:07:56,080 --> 00:07:58,479
this this used to be true we will later

244
00:07:58,479 --> 00:07:59,440
get

245
00:07:59,440 --> 00:08:01,680
to how it is nowadays

246
00:08:01,680 --> 00:08:03,840
and the thing is that system calls which

247
00:08:03,840 --> 00:08:05,520
are usually used for process injection

248
00:08:05,520 --> 00:08:07,280
are obviously hooked because the

249
00:08:07,280 --> 00:08:09,680
antivirus product is quite interested in

250
00:08:09,680 --> 00:08:11,919
why this api is actually used and how it

251
00:08:11,919 --> 00:08:13,360
is used

252
00:08:13,360 --> 00:08:16,240
so basically

253
00:08:16,560 --> 00:08:19,759
basically um if you're making use of if

254
00:08:19,759 --> 00:08:21,280
you're trying to

255
00:08:21,280 --> 00:08:23,120
create a remote thread the mower is

256
00:08:23,120 --> 00:08:24,160
going to

257
00:08:24,160 --> 00:08:25,440
go through the abstraction layer in the

258
00:08:25,440 --> 00:08:28,639
kernel 32 dll which is then calling um

259
00:08:28,639 --> 00:08:30,479
something in the entity dll and the

260
00:08:30,479 --> 00:08:31,919
entity is then going to perform the

261
00:08:31,919 --> 00:08:34,240
system call for you

262
00:08:34,240 --> 00:08:35,760
yeah

263
00:08:35,760 --> 00:08:36,799
um

264
00:08:36,799 --> 00:08:39,120
if there's a user lent hook in place

265
00:08:39,120 --> 00:08:40,958
the first steps are similar you still go

266
00:08:40,958 --> 00:08:43,519
through kernel dll you you then go to

267
00:08:43,519 --> 00:08:45,440
entity layer

268
00:08:45,440 --> 00:08:47,519
and last but not least you end up in the

269
00:08:47,519 --> 00:08:49,680
antivirus dll which is then doing

270
00:08:49,680 --> 00:08:52,719
some analysis for you

271
00:08:52,959 --> 00:08:54,480
there are some obvious ways to bypass

272
00:08:54,480 --> 00:08:55,920
user networks and they are i don't know

273
00:08:55,920 --> 00:08:57,600
they are a hundred thousand ways

274
00:08:57,600 --> 00:09:00,000
probably um the most obvious way to

275
00:09:00,000 --> 00:09:02,240
bypass this is uh to directly conduct

276
00:09:02,240 --> 00:09:04,160
the system call and this is doable by

277
00:09:04,160 --> 00:09:05,120
simply

278
00:09:05,120 --> 00:09:06,959
embedding the code uh snippets of the

279
00:09:06,959 --> 00:09:09,279
ntdl into your own malware

280
00:09:09,279 --> 00:09:10,160
and then

281
00:09:10,160 --> 00:09:11,760
um doing

282
00:09:11,760 --> 00:09:13,120
letting your moorway actually do with

283
00:09:13,120 --> 00:09:14,320
the

284
00:09:14,320 --> 00:09:16,000
the system call for you which directly

285
00:09:16,000 --> 00:09:18,000
which effectively bypasses current32

286
00:09:18,000 --> 00:09:21,120
ntdl and the other antivirus data

287
00:09:21,120 --> 00:09:22,399
however

288
00:09:22,399 --> 00:09:24,160
i mean it does bypass user lane hooks

289
00:09:24,160 --> 00:09:25,760
but there are some very obvious problems

290
00:09:25,760 --> 00:09:27,440
with this approach

291
00:09:27,440 --> 00:09:29,200
the obvious problem is that all system

292
00:09:29,200 --> 00:09:32,399
calls should go through anti-dll

293
00:09:32,399 --> 00:09:34,480
if any other module then ntdl is doing a

294
00:09:34,480 --> 00:09:35,920
system call then this is quite

295
00:09:35,920 --> 00:09:37,440
suspicious because this should actually

296
00:09:37,440 --> 00:09:39,920
never be the case

297
00:09:39,920 --> 00:09:40,800
and

298
00:09:40,800 --> 00:09:42,640
if we take a look at sysmon

299
00:09:42,640 --> 00:09:44,399
in the first in the upper screenshot we

300
00:09:44,399 --> 00:09:46,160
see the usage of the windows api and we

301
00:09:46,160 --> 00:09:47,680
see that the last module in the call

302
00:09:47,680 --> 00:09:49,920
trace is actually ntdla but if we make

303
00:09:49,920 --> 00:09:52,080
use of direct system calls uh here i use

304
00:09:52,080 --> 00:09:56,720
the tool by by outflank uh hello

305
00:09:56,800 --> 00:09:58,640
we see that the last module in the call

306
00:09:58,640 --> 00:10:01,040
trace is actually not anti-dll but it's

307
00:10:01,040 --> 00:10:03,519
outflanked dumped which is a

308
00:10:03,519 --> 00:10:06,320
big indicator of compromise i'm assuming

309
00:10:06,320 --> 00:10:08,880
um the problem however is that yes you

310
00:10:08,880 --> 00:10:10,560
can sometimes observe direct system

311
00:10:10,560 --> 00:10:12,079
calls using sysmon

312
00:10:12,079 --> 00:10:14,079
but there are not kernel callbacks for

313
00:10:14,079 --> 00:10:15,440
every single single system called there

314
00:10:15,440 --> 00:10:17,839
is there's one for anti-open process but

315
00:10:17,839 --> 00:10:20,399
there are way more

316
00:10:20,399 --> 00:10:21,600
system calls you guys might be

317
00:10:21,600 --> 00:10:22,959
interested in

318
00:10:22,959 --> 00:10:24,320
um

319
00:10:24,320 --> 00:10:25,839
and since there is no kernel callback

320
00:10:25,839 --> 00:10:28,000
for every single system call you might

321
00:10:28,000 --> 00:10:31,440
want to use an additional framework

322
00:10:31,440 --> 00:10:33,440
um and an additional framework which you

323
00:10:33,440 --> 00:10:35,839
might be leveraging is called novana

324
00:10:35,839 --> 00:10:37,360
which is an instrumentation engine used

325
00:10:37,360 --> 00:10:39,920
by microsoft it's present in windows

326
00:10:39,920 --> 00:10:41,040
since vista

327
00:10:41,040 --> 00:10:42,560
it's a quite complicated thing and i'm

328
00:10:42,560 --> 00:10:44,480
not going to get into too many details

329
00:10:44,480 --> 00:10:46,480
here but it can actually be used to

330
00:10:46,480 --> 00:10:48,480
monitor and control user-made processes

331
00:10:48,480 --> 00:10:51,519
without recompiling the target

332
00:10:51,519 --> 00:10:53,200
more importantly it even allows us to

333
00:10:53,200 --> 00:10:55,360
define callbacks for system calls upon

334
00:10:55,360 --> 00:10:57,120
return from kernel mode

335
00:10:57,120 --> 00:10:59,040
and what that means is that we can

336
00:10:59,040 --> 00:11:01,839
basically specify if

337
00:11:01,839 --> 00:11:04,000
a system call returns from kernel mode

338
00:11:04,000 --> 00:11:05,519
um it should

339
00:11:05,519 --> 00:11:07,360
before it continues execution in user

340
00:11:07,360 --> 00:11:08,160
mode

341
00:11:08,160 --> 00:11:10,720
it should execute our user specified

342
00:11:10,720 --> 00:11:12,000
callback

343
00:11:12,000 --> 00:11:14,800
and this actually allows us to hook

344
00:11:14,800 --> 00:11:17,839
basically every single system call

345
00:11:17,839 --> 00:11:19,760
and perform some additional code before

346
00:11:19,760 --> 00:11:22,800
it transitions back to user mode

347
00:11:22,800 --> 00:11:24,640
more importantly it allows us to check

348
00:11:24,640 --> 00:11:26,240
where the system call is returning in

349
00:11:26,240 --> 00:11:27,920
user mode if it's not returning to

350
00:11:27,920 --> 00:11:29,760
somewhere in ntdl then this is obviously

351
00:11:29,760 --> 00:11:31,040
an ioc

352
00:11:31,040 --> 00:11:32,560
and there's a really cool sample

353
00:11:32,560 --> 00:11:34,640
implementation by wind turner and if we

354
00:11:34,640 --> 00:11:36,079
make use of

355
00:11:36,079 --> 00:11:38,160
this implementation

356
00:11:38,160 --> 00:11:41,600
again against outflank dumper

357
00:11:41,600 --> 00:11:42,480
the

358
00:11:42,480 --> 00:11:44,000
implementation by internal i call i

359
00:11:44,000 --> 00:11:45,680
think it's called syscall detect is

360
00:11:45,680 --> 00:11:48,160
immediately complaining that

361
00:11:48,160 --> 00:11:49,760
the kernel returns to an unverified

362
00:11:49,760 --> 00:11:51,760
module and it's going to

363
00:11:51,760 --> 00:11:52,880
to exit

364
00:11:52,880 --> 00:11:54,959
so this can actually potentially be used

365
00:11:54,959 --> 00:11:56,240
by security products in order to

366
00:11:56,240 --> 00:11:58,480
identify direct system calls uh it's

367
00:11:58,480 --> 00:12:00,000
just that the performance overhead might

368
00:12:00,000 --> 00:12:02,959
actually be a big issue here

369
00:12:02,959 --> 00:12:04,800
um so okay so what can we do against

370
00:12:04,800 --> 00:12:06,800
this um obviously we need to make sure

371
00:12:06,800 --> 00:12:09,279
that our system calls go through ntdl

372
00:12:09,279 --> 00:12:11,120
and bypass user land hooks at the same

373
00:12:11,120 --> 00:12:12,160
time

374
00:12:12,160 --> 00:12:14,639
and the cool observation is that an

375
00:12:14,639 --> 00:12:16,079
enterprise product does of course not

376
00:12:16,079 --> 00:12:18,079
hook every single system call there is

377
00:12:18,079 --> 00:12:19,920
otherwise it would also run into

378
00:12:19,920 --> 00:12:21,920
performance problems

379
00:12:21,920 --> 00:12:24,240
it only hooks those system calls it's

380
00:12:24,240 --> 00:12:26,079
actually interested in

381
00:12:26,079 --> 00:12:28,560
um this leaves us to the observation or

382
00:12:28,560 --> 00:12:30,000
this brings us to the observation that

383
00:12:30,000 --> 00:12:31,600
some system call stops are simply not

384
00:12:31,600 --> 00:12:32,720
hooked because

385
00:12:32,720 --> 00:12:35,040
the api calls are simply not interesting

386
00:12:35,040 --> 00:12:36,160
enough

387
00:12:36,160 --> 00:12:38,959
um yet all system coil stops do pretty

388
00:12:38,959 --> 00:12:40,399
much the same thing but they use a

389
00:12:40,399 --> 00:12:41,680
different system call number so

390
00:12:41,680 --> 00:12:43,120
basically they move the system call

391
00:12:43,120 --> 00:12:45,040
number to eax and then perform the

392
00:12:45,040 --> 00:12:48,880
system call by syscall red

393
00:12:49,120 --> 00:12:52,000
what can we do um the idea could be to

394
00:12:52,000 --> 00:12:54,399
first resolve the system call number um

395
00:12:54,399 --> 00:12:56,399
by using a technique called taylorsgate

396
00:12:56,399 --> 00:12:58,800
which is by sector seven and then we

397
00:12:58,800 --> 00:13:01,200
initialize the system call manually and

398
00:13:01,200 --> 00:13:03,600
then we reuse uh existing syscall web

399
00:13:03,600 --> 00:13:05,120
instructions from a clean system call

400
00:13:05,120 --> 00:13:08,000
stop in order to perform the system call

401
00:13:08,000 --> 00:13:10,560
so we basically jump um to a very

402
00:13:10,560 --> 00:13:11,760
certain

403
00:13:11,760 --> 00:13:14,240
location of a clean system called stop

404
00:13:14,240 --> 00:13:15,760
which is the system called retrospection

405
00:13:15,760 --> 00:13:18,560
we basically we use these instructions

406
00:13:18,560 --> 00:13:21,279
from a clean system crosstab

407
00:13:21,279 --> 00:13:22,800
so

408
00:13:22,800 --> 00:13:25,200
i'm a paint master

409
00:13:25,200 --> 00:13:28,079
we first set up the vegas

410
00:13:28,079 --> 00:13:30,079
then we kind of reuse the stub once

411
00:13:30,079 --> 00:13:31,920
again meaning that we choose a clean

412
00:13:31,920 --> 00:13:33,600
system called stub which is not hooked

413
00:13:33,600 --> 00:13:35,040
and then we use the system callback

414
00:13:35,040 --> 00:13:35,920
instructions from there which

415
00:13:35,920 --> 00:13:37,600
effectively bypasses the user land hooks

416
00:13:37,600 --> 00:13:39,040
and we're going through entity delay at

417
00:13:39,040 --> 00:13:41,199
the same time

418
00:13:41,199 --> 00:13:42,639
i wrote a small implementation for this

419
00:13:42,639 --> 00:13:44,720
you can find it on my github and if i

420
00:13:44,720 --> 00:13:46,079
make use of this

421
00:13:46,079 --> 00:13:48,560
and i let i use the syscall detect tool

422
00:13:48,560 --> 00:13:50,240
at the same time it's not complaining

423
00:13:50,240 --> 00:13:51,600
why is it not complaining because the

424
00:13:51,600 --> 00:13:53,920
system calls they all returned to ncdl

425
00:13:53,920 --> 00:13:54,880
um

426
00:13:54,880 --> 00:13:55,760
and

427
00:13:55,760 --> 00:13:57,040
you see on

428
00:13:57,040 --> 00:13:58,320
in this month the last module in the

429
00:13:58,320 --> 00:14:00,880
call stack is anti-dla

430
00:14:00,880 --> 00:14:02,800
there are still some iucs though um

431
00:14:02,800 --> 00:14:05,040
because usually system calls go through

432
00:14:05,040 --> 00:14:07,600
kernel-based dll and then to anti-dla

433
00:14:07,600 --> 00:14:09,600
this is the first ic

434
00:14:09,600 --> 00:14:11,839
the second ioc is that yeah the system

435
00:14:11,839 --> 00:14:13,600
call returns to ntdl but it does not

436
00:14:13,600 --> 00:14:15,360
return to the correct step which is

437
00:14:15,360 --> 00:14:17,760
associated with the executed system call

438
00:14:17,760 --> 00:14:19,839
and by leveraging hooking nirvana this

439
00:14:19,839 --> 00:14:21,600
might be an idea in order to leverage

440
00:14:21,600 --> 00:14:22,800
this

441
00:14:22,800 --> 00:14:23,920
cool so

442
00:14:23,920 --> 00:14:25,199
user land hooks are still a thing in

443
00:14:25,199 --> 00:14:27,680
2022 actually and i was quite surprised

444
00:14:27,680 --> 00:14:29,680
about this um because i thought it's

445
00:14:29,680 --> 00:14:31,199
like a relic from the past but that's

446
00:14:31,199 --> 00:14:34,160
not the case many antivirus security

447
00:14:34,160 --> 00:14:35,760
products still rely heavily on them and

448
00:14:35,760 --> 00:14:38,240
the question is why

449
00:14:38,240 --> 00:14:40,480
the first reason is that monitoring from

450
00:14:40,480 --> 00:14:43,360
kernel only can cause stability issues

451
00:14:43,360 --> 00:14:44,720
because if you

452
00:14:44,720 --> 00:14:47,120
 up your kernel driver then your

453
00:14:47,120 --> 00:14:49,519
client won't be protected but have a

454
00:14:49,519 --> 00:14:51,279
blue screen

455
00:14:51,279 --> 00:14:53,199
and the second problem was this is not

456
00:14:53,199 --> 00:14:55,920
the case anymore but it was that

457
00:14:55,920 --> 00:14:57,680
missing telemetry because there was no

458
00:14:57,680 --> 00:14:59,600
other no no other way for an antivirus

459
00:14:59,600 --> 00:15:01,120
to understand

460
00:15:01,120 --> 00:15:03,040
if and how a certain api call was used

461
00:15:03,040 --> 00:15:04,639
so it was used kind of a patch to under

462
00:15:04,639 --> 00:15:07,279
to get to get more telemetry

463
00:15:07,279 --> 00:15:08,560
what matters from the attacker's

464
00:15:08,560 --> 00:15:10,560
perspective is basically that user and

465
00:15:10,560 --> 00:15:11,760
hooks

466
00:15:11,760 --> 00:15:13,120
are not a problem they can always be

467
00:15:13,120 --> 00:15:14,720
efficiently and stealthy bypass and

468
00:15:14,720 --> 00:15:16,720
github is full of user into bypassing

469
00:15:16,720 --> 00:15:18,399
techniques

470
00:15:18,399 --> 00:15:20,399
cool so now we should be able to conduct

471
00:15:20,399 --> 00:15:22,399
memory operations on the remote process

472
00:15:22,399 --> 00:15:23,920
with the handle we gained earlier in a

473
00:15:23,920 --> 00:15:26,320
very stealth way so we should be able to

474
00:15:26,320 --> 00:15:28,240
inject our payload using every single

475
00:15:28,240 --> 00:15:29,759
api call we want

476
00:15:29,759 --> 00:15:32,320
is that true and the thing is we still

477
00:15:32,320 --> 00:15:34,399
need to keep some some effects in mind

478
00:15:34,399 --> 00:15:36,000
because some system calls trigger a

479
00:15:36,000 --> 00:15:38,000
kernel callback as i was saying before

480
00:15:38,000 --> 00:15:39,920
and others can actually be observed by

481
00:15:39,920 --> 00:15:43,519
etw because there's a etw provider which

482
00:15:43,519 --> 00:15:46,000
many security solutions have begun

483
00:15:46,000 --> 00:15:47,440
subscribing on

484
00:15:47,440 --> 00:15:49,440
and it's called the microsoft windows

485
00:15:49,440 --> 00:15:51,040
web intelligence

486
00:15:51,040 --> 00:15:53,279
dtw provider the provider sits in

487
00:15:53,279 --> 00:15:54,959
kernels so there's not a lot you can do

488
00:15:54,959 --> 00:15:56,720
against this from user mode

489
00:15:56,720 --> 00:15:57,519
and

490
00:15:57,519 --> 00:16:00,160
for us it's kind of a problem because um

491
00:16:00,160 --> 00:16:02,560
it delivers uh events for everything

492
00:16:02,560 --> 00:16:04,320
that might be used for process injection

493
00:16:04,320 --> 00:16:06,240
you know apc's suspending threats

494
00:16:06,240 --> 00:16:08,560
resuming that and so on and so on

495
00:16:08,560 --> 00:16:10,800
um so it should provide enough telemetry

496
00:16:10,800 --> 00:16:12,240
in order to observe typical process

497
00:16:12,240 --> 00:16:14,160
injection techniques and there are a

498
00:16:14,160 --> 00:16:15,680
bunch of device

499
00:16:15,680 --> 00:16:17,839
event action types you can use

500
00:16:17,839 --> 00:16:18,639
um

501
00:16:18,639 --> 00:16:20,880
i tried to write rules for this

502
00:16:20,880 --> 00:16:23,279
for for a client for a very big client

503
00:16:23,279 --> 00:16:25,040
in a purple teaming assessment

504
00:16:25,040 --> 00:16:26,000
and

505
00:16:26,000 --> 00:16:26,800
yeah

506
00:16:26,800 --> 00:16:28,240
you can see the process injection it's

507
00:16:28,240 --> 00:16:30,399
just that these api calls are often are

508
00:16:30,399 --> 00:16:32,160
so often used in a legitimate context

509
00:16:32,160 --> 00:16:34,079
that it's almost impossible to write a

510
00:16:34,079 --> 00:16:35,519
working detection for this without

511
00:16:35,519 --> 00:16:37,360
having any first positives

512
00:16:37,360 --> 00:16:39,199
so what actually matters in my in my

513
00:16:39,199 --> 00:16:41,199
opinion is which process and injects

514
00:16:41,199 --> 00:16:42,800
into which other process and more

515
00:16:42,800 --> 00:16:44,800
importantly what is actually being

516
00:16:44,800 --> 00:16:46,720
ejected if you inject a plain cobalt

517
00:16:46,720 --> 00:16:48,639
stock beaking into another process in

518
00:16:48,639 --> 00:16:50,959
the most stealth way it will still be it

519
00:16:50,959 --> 00:16:52,399
will still be picked up simply because

520
00:16:52,399 --> 00:16:55,040
it's cobia strike so our next problem is

521
00:16:55,040 --> 00:16:57,360
actually static signatures and we need

522
00:16:57,360 --> 00:16:59,120
to think about how to avoid static

523
00:16:59,120 --> 00:17:00,560
signatures

524
00:17:00,560 --> 00:17:02,720
or evade static signatures

525
00:17:02,720 --> 00:17:04,720
um okay once again we successfully

526
00:17:04,720 --> 00:17:06,240
injected our payload into the target

527
00:17:06,240 --> 00:17:08,640
process and obviously now uh jaga rules

528
00:17:08,640 --> 00:17:10,160
are applied by security products in

529
00:17:10,160 --> 00:17:12,160
order to identify if it is something

530
00:17:12,160 --> 00:17:14,079
they already know and there might be

531
00:17:14,079 --> 00:17:15,760
ways to bypass this some are better than

532
00:17:15,760 --> 00:17:18,720
others but let us take a look at this um

533
00:17:18,720 --> 00:17:21,439
the first concept is called polymorphism

534
00:17:21,439 --> 00:17:22,959
it's a very old concept what you're

535
00:17:22,959 --> 00:17:24,480
doing is basically you encrypt your

536
00:17:24,480 --> 00:17:26,079
payload and you glue it together with a

537
00:17:26,079 --> 00:17:28,400
decryption step uh the decryption slab

538
00:17:28,400 --> 00:17:30,080
decrypts the payload and then actually

539
00:17:30,080 --> 00:17:33,200
executes it cool um so here we have a

540
00:17:33,200 --> 00:17:34,880
hello world.pin which basically pops up

541
00:17:34,880 --> 00:17:36,960
the message box and we remember it

542
00:17:36,960 --> 00:17:40,400
starts with ascii vh something something

543
00:17:40,400 --> 00:17:42,240
if we if you put it into executable

544
00:17:42,240 --> 00:17:43,360
memory

545
00:17:43,360 --> 00:17:44,799
it pops the message box and we see the

546
00:17:44,799 --> 00:17:47,039
vh something something in an executable

547
00:17:47,039 --> 00:17:49,280
memory page cool

548
00:17:49,280 --> 00:17:50,880
now if we make use of the category which

549
00:17:50,880 --> 00:17:53,200
is a polymorph encoder we see that yeah

550
00:17:53,200 --> 00:17:54,480
it looks really different it doesn't

551
00:17:54,480 --> 00:17:56,080
start with vh and there's no vh

552
00:17:56,080 --> 00:17:57,360
something something anymore because it's

553
00:17:57,360 --> 00:17:58,799
encrypted

554
00:17:58,799 --> 00:18:00,480
but what happens if we actually actually

555
00:18:00,480 --> 00:18:02,080
execute it in memory we see that the

556
00:18:02,080 --> 00:18:03,600
first bytes are different but at some

557
00:18:03,600 --> 00:18:06,240
point uh our vh something something pops

558
00:18:06,240 --> 00:18:07,840
up once again

559
00:18:07,840 --> 00:18:10,400
and we wanted to avoid this wasn't it

560
00:18:10,400 --> 00:18:12,400
um so there are a bunch of problems with

561
00:18:12,400 --> 00:18:14,080
polymorphism

562
00:18:14,080 --> 00:18:16,880
first it needs rwx which is an indicator

563
00:18:16,880 --> 00:18:19,440
as such second thing the decryption step

564
00:18:19,440 --> 00:18:21,440
as such can be fingerprinted and after

565
00:18:21,440 --> 00:18:23,200
decryption your malware or your tool or

566
00:18:23,200 --> 00:18:24,720
whatever is not protected in plain

567
00:18:24,720 --> 00:18:27,200
memory so it might help to bypass the

568
00:18:27,200 --> 00:18:29,120
initial memory scan but

569
00:18:29,120 --> 00:18:30,960
uh at some point if memory scan happens

570
00:18:30,960 --> 00:18:33,120
like i don't know 20 minutes later your

571
00:18:33,120 --> 00:18:34,480
codes are peaking or whatever is going

572
00:18:34,480 --> 00:18:36,400
to be playing the memory

573
00:18:36,400 --> 00:18:38,720
copy strike makes use of or tackles this

574
00:18:38,720 --> 00:18:40,400
problem with a concept called sleep mask

575
00:18:40,400 --> 00:18:42,880
it was introduced in version four the

576
00:18:42,880 --> 00:18:45,280
three is wrong it's four or something

577
00:18:45,280 --> 00:18:46,720
and the core idea is actually quite

578
00:18:46,720 --> 00:18:47,919
simple

579
00:18:47,919 --> 00:18:49,919
the observation is that a beacon

580
00:18:49,919 --> 00:18:51,280
basically spends most of the time

581
00:18:51,280 --> 00:18:53,120
sleeping and waiting for new commands so

582
00:18:53,120 --> 00:18:55,039
what you can do is while sleeping

583
00:18:55,039 --> 00:18:56,559
sleeping the beaking actually obvious

584
00:18:56,559 --> 00:18:58,320
skates and encrypts itself in memory

585
00:18:58,320 --> 00:18:59,840
while it is sleeping

586
00:18:59,840 --> 00:19:02,400
and you must be quite unlucky if um the

587
00:19:02,400 --> 00:19:04,559
memory scanner hits you right in the in

588
00:19:04,559 --> 00:19:06,559
the situation where your beacon is

589
00:19:06,559 --> 00:19:07,919
active because usually a beacon is

590
00:19:07,919 --> 00:19:09,919
active only for i don't know a fraction

591
00:19:09,919 --> 00:19:12,240
of a second or something like that

592
00:19:12,240 --> 00:19:13,440
there are some limitations with this

593
00:19:13,440 --> 00:19:14,960
however because the first limitation

594
00:19:14,960 --> 00:19:16,559
might be that the sleep mask itself can

595
00:19:16,559 --> 00:19:18,240
be fingerprinted you can customize this

596
00:19:18,240 --> 00:19:20,480
in cobblestock and we also have other

597
00:19:20,480 --> 00:19:22,400
memory artifacts which we will which we

598
00:19:22,400 --> 00:19:24,720
will take a look at later i however like

599
00:19:24,720 --> 00:19:26,720
to use another concept

600
00:19:26,720 --> 00:19:28,960
and the idea is to change the appearance

601
00:19:28,960 --> 00:19:31,440
of a program on instruction level

602
00:19:31,440 --> 00:19:33,120
if we change the appearance of a program

603
00:19:33,120 --> 00:19:34,960
on instruction level uh we do not need

604
00:19:34,960 --> 00:19:36,960
any encoding or encryption or whatever

605
00:19:36,960 --> 00:19:39,280
and we do also not need any rwx because

606
00:19:39,280 --> 00:19:41,520
we're not encrypting anything

607
00:19:41,520 --> 00:19:44,080
there might be ways to achieve this

608
00:19:44,080 --> 00:19:46,480
one way to achieve this is to substitute

609
00:19:46,480 --> 00:19:48,320
instructions with a sequence of

610
00:19:48,320 --> 00:19:49,760
instructions

611
00:19:49,760 --> 00:19:51,520
which lead to the same result yet these

612
00:19:51,520 --> 00:19:53,600
are other instructions what you got what

613
00:19:53,600 --> 00:19:55,760
you could also be doing is add useless

614
00:19:55,760 --> 00:19:58,559
instructions or add trash and jump over

615
00:19:58,559 --> 00:20:00,080
the trash or you shuffle the basic

616
00:20:00,080 --> 00:20:02,159
blocks or whatever

617
00:20:02,159 --> 00:20:04,159
the terminology for this is quite

618
00:20:04,159 --> 00:20:05,840
unclear for me if you google this some

619
00:20:05,840 --> 00:20:07,039
actually call it a variant of

620
00:20:07,039 --> 00:20:09,360
polymorphism other called metamorphism

621
00:20:09,360 --> 00:20:10,640
in this talk we call it keyless

622
00:20:10,640 --> 00:20:13,360
polymorphism

623
00:20:13,600 --> 00:20:16,159
so some ideas for substitutions if you

624
00:20:16,159 --> 00:20:17,679
want to null out a register either you

625
00:20:17,679 --> 00:20:21,120
can write xor i i x or you move 0 to i x

626
00:20:21,120 --> 00:20:22,880
or you store another register on the

627
00:20:22,880 --> 00:20:23,760
stack

628
00:20:23,760 --> 00:20:25,360
null out this register move this

629
00:20:25,360 --> 00:20:27,120
register to ix and then restore this

630
00:20:27,120 --> 00:20:28,159
register

631
00:20:28,159 --> 00:20:30,159
if you want to jump to rcx you could

632
00:20:30,159 --> 00:20:32,640
also write push rcx and then return

633
00:20:32,640 --> 00:20:34,559
where push rcx could also be written

634
00:20:34,559 --> 00:20:37,360
like this so there are a bunch of ideas

635
00:20:37,360 --> 00:20:38,080
or

636
00:20:38,080 --> 00:20:39,520
instructions which can be substituted

637
00:20:39,520 --> 00:20:43,120
with an equivalent of other instructions

638
00:20:43,120 --> 00:20:45,679
by adding trash as i said basically you

639
00:20:45,679 --> 00:20:47,440
add complete trash bytes or instructions

640
00:20:47,440 --> 00:20:49,520
which don't make any sense at all and

641
00:20:49,520 --> 00:20:52,159
you add a jump over the trash

642
00:20:52,159 --> 00:20:53,919
and however you do it in the end of the

643
00:20:53,919 --> 00:20:54,720
day

644
00:20:54,720 --> 00:20:57,280
so on the left side we see our actual

645
00:20:57,280 --> 00:20:58,480
program

646
00:20:58,480 --> 00:21:00,159
which is not

647
00:21:00,159 --> 00:21:01,919
obfuscated or whatever and on the right

648
00:21:01,919 --> 00:21:04,320
side we see that the first instruction

649
00:21:04,320 --> 00:21:06,400
was substituted with another instruction

650
00:21:06,400 --> 00:21:08,320
second one is also substituted then we

651
00:21:08,320 --> 00:21:10,480
have a jump over the trash then probably

652
00:21:10,480 --> 00:21:11,520
an instruction which could not be

653
00:21:11,520 --> 00:21:13,200
substituted and last but not least

654
00:21:13,200 --> 00:21:15,840
another substitution

655
00:21:15,840 --> 00:21:17,440
i really like to leverage this technique

656
00:21:17,440 --> 00:21:19,039
to protect my tools from automated

657
00:21:19,039 --> 00:21:21,039
memory scanners and it's quite powerful

658
00:21:21,039 --> 00:21:23,200
if enough instructions are substituted

659
00:21:23,200 --> 00:21:24,720
you obviously need the source code for

660
00:21:24,720 --> 00:21:25,919
this because otherwise you would be

661
00:21:25,919 --> 00:21:28,480
breaking relative gems

662
00:21:28,480 --> 00:21:30,400
and if you consider this to be a problem

663
00:21:30,400 --> 00:21:31,600
it makes your payload obviously

664
00:21:31,600 --> 00:21:33,440
significantly larger

665
00:21:33,440 --> 00:21:35,600
um also you need to take into

666
00:21:35,600 --> 00:21:37,520
consideration that strings and constants

667
00:21:37,520 --> 00:21:39,039
need to be encrypted and obfuscated

668
00:21:39,039 --> 00:21:41,120
additionally because this is not part of

669
00:21:41,120 --> 00:21:43,280
the polymorph process

670
00:21:43,280 --> 00:21:44,640
i'm doing this by hand it's really

671
00:21:44,640 --> 00:21:46,000
really annoying and you should automate

672
00:21:46,000 --> 00:21:49,039
this i'll get i will later get back to

673
00:21:49,039 --> 00:21:50,960
how to automate this

674
00:21:50,960 --> 00:21:53,440
cool so once again we remember our vh

675
00:21:53,440 --> 00:21:55,600
something something shellcode

676
00:21:55,600 --> 00:21:58,480
it pops a message box

677
00:21:58,480 --> 00:22:00,320
and here if we use this keyless

678
00:22:00,320 --> 00:22:02,480
polymorph concept we see that it

679
00:22:02,480 --> 00:22:04,480
actually doesn't start with vh anymore

680
00:22:04,480 --> 00:22:06,640
actually you don't find these constants

681
00:22:06,640 --> 00:22:07,600
anymore

682
00:22:07,600 --> 00:22:10,240
in an executable memory page

683
00:22:10,240 --> 00:22:12,880
yet the method box still pops up if

684
00:22:12,880 --> 00:22:14,880
there's someone really uh

685
00:22:14,880 --> 00:22:17,039
careful you see that this is actually in

686
00:22:17,039 --> 00:22:19,120
an rwx page i earlier said you don't

687
00:22:19,120 --> 00:22:21,600
need rwx it's because i forgot to change

688
00:22:21,600 --> 00:22:23,440
the page permissions

689
00:22:23,440 --> 00:22:24,480
um

690
00:22:24,480 --> 00:22:26,240
cool so now we gained a handle in a very

691
00:22:26,240 --> 00:22:28,640
stealthy way uh we defended user land

692
00:22:28,640 --> 00:22:30,480
hooks while still we go

693
00:22:30,480 --> 00:22:32,720
through ntdl and we defeated scanners

694
00:22:32,720 --> 00:22:34,880
using some kind of polymorphism

695
00:22:34,880 --> 00:22:36,480
the problem now is that in fact the

696
00:22:36,480 --> 00:22:38,480
processes leave a lot of other iocs so

697
00:22:38,480 --> 00:22:40,799
even if you managed to infect a process

698
00:22:40,799 --> 00:22:42,400
that you wanted to infect you still have

699
00:22:42,400 --> 00:22:44,320
a lot of other iocs

700
00:22:44,320 --> 00:22:46,080
let us take a look look at suspicious

701
00:22:46,080 --> 00:22:48,240
artifacts

702
00:22:48,240 --> 00:22:50,799
to understand this some

703
00:22:50,799 --> 00:22:53,120
some basics windows roughly has three

704
00:22:53,120 --> 00:22:54,480
types of memory there's private

705
00:22:54,480 --> 00:22:55,919
committed memory which is reserved for

706
00:22:55,919 --> 00:22:57,679
heap and stack there's map memory which

707
00:22:57,679 --> 00:22:59,840
is used for file mapping and ipc and

708
00:22:59,840 --> 00:23:01,440
there's also image committed memory

709
00:23:01,440 --> 00:23:03,919
which is basically used by pe files and

710
00:23:03,919 --> 00:23:06,159
executable executables

711
00:23:06,159 --> 00:23:09,440
and the thing is that usually only um

712
00:23:09,440 --> 00:23:10,960
image-committed memory should be marked

713
00:23:10,960 --> 00:23:12,559
as executable

714
00:23:12,559 --> 00:23:15,039
um there are some false positives or

715
00:23:15,039 --> 00:23:17,280
some some exceptions for example managed

716
00:23:17,280 --> 00:23:19,919
code like c-sharp because it's a

717
00:23:19,919 --> 00:23:22,799
bytecode which is compiled interpreted

718
00:23:22,799 --> 00:23:23,679
at

719
00:23:23,679 --> 00:23:26,000
runtime but as we see on the screenshot

720
00:23:26,000 --> 00:23:29,039
actually only or normally only image

721
00:23:29,039 --> 00:23:30,320
converted memory should be marked as

722
00:23:30,320 --> 00:23:31,520
executable

723
00:23:31,520 --> 00:23:32,480
and this

724
00:23:32,480 --> 00:23:34,720
gives us a big problem because

725
00:23:34,720 --> 00:23:36,559
somehow we need to gain

726
00:23:36,559 --> 00:23:39,039
executable memory uh while injecting

727
00:23:39,039 --> 00:23:40,880
into remote process and the problem is

728
00:23:40,880 --> 00:23:42,880
how do we actually get or we execute a

729
00:23:42,880 --> 00:23:45,679
memory in a remote process

730
00:23:45,679 --> 00:23:47,600
and there are a bunch of memory scanners

731
00:23:47,600 --> 00:23:49,600
which are really really good at

732
00:23:49,600 --> 00:23:50,799
finding

733
00:23:50,799 --> 00:23:53,440
memories or abnormal memory allocations

734
00:23:53,440 --> 00:23:55,200
the one by monitor is

735
00:23:55,200 --> 00:23:56,960
really popular and they're really good

736
00:23:56,960 --> 00:23:59,919
at detecting optimal memory allocations

737
00:23:59,919 --> 00:24:01,279
so for example if you make use of

738
00:24:01,279 --> 00:24:02,880
virtual alloc or anti-map view of

739
00:24:02,880 --> 00:24:04,720
section or whatever

740
00:24:04,720 --> 00:24:07,279
monitor is quickly complaining about hey

741
00:24:07,279 --> 00:24:08,720
there are two

742
00:24:08,720 --> 00:24:11,039
pages which are marked as executable yet

743
00:24:11,039 --> 00:24:13,039
they are marked as private commit what

744
00:24:13,039 --> 00:24:14,480
the is this that doesn't make any

745
00:24:14,480 --> 00:24:16,159
sense

746
00:24:16,159 --> 00:24:18,480
the next next try could be to make use

747
00:24:18,480 --> 00:24:21,120
of dll hollowing where we load an unused

748
00:24:21,120 --> 00:24:23,039
dll into the remote process and then

749
00:24:23,039 --> 00:24:25,760
replace the text segment

750
00:24:25,760 --> 00:24:27,600
with our own code

751
00:24:27,600 --> 00:24:30,400
problem monitor is complaining again why

752
00:24:30,400 --> 00:24:32,720
for two reasons first monitor is asking

753
00:24:32,720 --> 00:24:35,440
why did this process load this dll it's

754
00:24:35,440 --> 00:24:38,240
not declared in the peb or anywhere why

755
00:24:38,240 --> 00:24:40,480
did it decide to load this dlr second

756
00:24:40,480 --> 00:24:41,600
problem

757
00:24:41,600 --> 00:24:44,000
the text segment of the dll on disk is

758
00:24:44,000 --> 00:24:45,440
not the same as the text segment of the

759
00:24:45,440 --> 00:24:47,760
dll in memory it's also a big problem

760
00:24:47,760 --> 00:24:49,279
for monitor

761
00:24:49,279 --> 00:24:50,159
and

762
00:24:50,159 --> 00:24:51,440
there are a bunch of ways to bypass

763
00:24:51,440 --> 00:24:52,960
memory scanners

764
00:24:52,960 --> 00:24:57,600
and they basically all boil down to

765
00:24:57,600 --> 00:24:59,520
changing the page permission of the

766
00:24:59,520 --> 00:25:00,400
beacon

767
00:25:00,400 --> 00:25:03,120
while it's actually sleeping

768
00:25:03,120 --> 00:25:04,960
because memory scanners only check for

769
00:25:04,960 --> 00:25:06,480
executable memory regions in order to

770
00:25:06,480 --> 00:25:09,360
find known better

771
00:25:09,679 --> 00:25:11,840
this leaves us this brings us a big

772
00:25:11,840 --> 00:25:13,440
problem because how do you mark your own

773
00:25:13,440 --> 00:25:16,080
code as not executable while you're

774
00:25:16,080 --> 00:25:18,880
executing this should not actually

775
00:25:18,880 --> 00:25:21,520
happen this note should not work

776
00:25:21,520 --> 00:25:23,520
but it does work with a bit of black

777
00:25:23,520 --> 00:25:25,520
magic and i like to you leverage a

778
00:25:25,520 --> 00:25:27,520
concept used by exploit coders which is

779
00:25:27,520 --> 00:25:30,799
called return origami programming

780
00:25:30,799 --> 00:25:32,880
which leverages stack pivoting and

781
00:25:32,880 --> 00:25:35,039
existing small code snippets

782
00:25:35,039 --> 00:25:37,520
from any ntdl or other executable memory

783
00:25:37,520 --> 00:25:39,520
which is there legitimately

784
00:25:39,520 --> 00:25:41,600
so the idea is before the beacon goes to

785
00:25:41,600 --> 00:25:43,760
sleep uh we set up a robbed chain which

786
00:25:43,760 --> 00:25:45,919
first calls virtual protect marking our

787
00:25:45,919 --> 00:25:48,159
beacon as not executable then it drops

788
00:25:48,159 --> 00:25:50,159
itself to sleep and then it robs itself

789
00:25:50,159 --> 00:25:53,600
again to page execute read

790
00:25:53,600 --> 00:25:55,279
this is

791
00:25:55,279 --> 00:25:57,520
nothing new as such um the original idea

792
00:25:57,520 --> 00:26:00,640
was called gargoyle i'm assuming it was

793
00:26:00,640 --> 00:26:02,480
first implemented by f-secure but i'm

794
00:26:02,480 --> 00:26:03,760
not sure about this

795
00:26:03,760 --> 00:26:05,039
um

796
00:26:05,039 --> 00:26:07,520
and the core idea here is that before we

797
00:26:07,520 --> 00:26:09,279
go to sleep we set up the stack and we

798
00:26:09,279 --> 00:26:11,200
set up the stack as follows

799
00:26:11,200 --> 00:26:13,200
the first return address on the stack

800
00:26:13,200 --> 00:26:15,520
points to a gadget which sets up the

801
00:26:15,520 --> 00:26:16,640
registers

802
00:26:16,640 --> 00:26:18,400
or which pop which pops

803
00:26:18,400 --> 00:26:20,320
the other values on the stack in a

804
00:26:20,320 --> 00:26:22,640
certain way and in such a way that on

805
00:26:22,640 --> 00:26:24,480
the next return when woodward protect

806
00:26:24,480 --> 00:26:27,120
happens um the address of the beacon is

807
00:26:27,120 --> 00:26:28,640
not marked or the page of the beating is

808
00:26:28,640 --> 00:26:31,360
not marked as executable anymore so upon

809
00:26:31,360 --> 00:26:32,799
the next return our beacon looks like

810
00:26:32,799 --> 00:26:34,960
this it's not executed anymore and the

811
00:26:34,960 --> 00:26:37,279
stack looks like this and now the first

812
00:26:37,279 --> 00:26:40,159
gadget on the stack points to a pop rc

813
00:26:40,159 --> 00:26:42,880
uh gadget which effectively puts the

814
00:26:42,880 --> 00:26:45,279
5000 on the stack um

815
00:26:45,279 --> 00:26:47,279
to rcx which is the first parameter for

816
00:26:47,279 --> 00:26:48,799
sleep and then it pops the return

817
00:26:48,799 --> 00:26:50,240
address of sleep and goes to sleep for

818
00:26:50,240 --> 00:26:53,279
5000 milliseconds now the beacon is not

819
00:26:53,279 --> 00:26:55,279
executable and it's sleeping at the same

820
00:26:55,279 --> 00:26:56,799
time

821
00:26:56,799 --> 00:26:57,760
and

822
00:26:57,760 --> 00:26:59,600
when the beacon returns obviously it

823
00:26:59,600 --> 00:27:01,039
takes the first return address from the

824
00:27:01,039 --> 00:27:01,919
stack

825
00:27:01,919 --> 00:27:02,880
again

826
00:27:02,880 --> 00:27:05,200
setting up the registers for virtual

827
00:27:05,200 --> 00:27:08,159
protect which then upon returning

828
00:27:08,159 --> 00:27:11,200
makes or beacon resuming

829
00:27:11,200 --> 00:27:12,480
i released the

830
00:27:12,480 --> 00:27:14,080
small proof of concept for this which i

831
00:27:14,080 --> 00:27:17,600
call deep sleep it's also on my github

832
00:27:17,600 --> 00:27:19,520
while it is active it's actually popping

833
00:27:19,520 --> 00:27:22,159
a message box and monitor complains why

834
00:27:22,159 --> 00:27:24,000
because there is private executable

835
00:27:24,000 --> 00:27:25,840
memory or something

836
00:27:25,840 --> 00:27:26,799
um

837
00:27:26,799 --> 00:27:29,360
but while sleeping we see that the page

838
00:27:29,360 --> 00:27:31,760
of deep sleep is actually marked as not

839
00:27:31,760 --> 00:27:35,440
available or execute

840
00:27:35,440 --> 00:27:38,559
read only yeah we'd only make sense

841
00:27:38,559 --> 00:27:40,880
so we bypass memory scanners looking for

842
00:27:40,880 --> 00:27:43,039
executable memory

843
00:27:43,039 --> 00:27:43,919
there are a bunch of other

844
00:27:43,919 --> 00:27:45,760
implementations

845
00:27:45,760 --> 00:27:47,520
they all boil down once again to the to

846
00:27:47,520 --> 00:27:49,360
the same idea which is changing the page

847
00:27:49,360 --> 00:27:50,880
permissions while sleeping

848
00:27:50,880 --> 00:27:52,880
um there's one by a cracked spider

849
00:27:52,880 --> 00:27:55,200
there's one by sec idiot called foliage

850
00:27:55,200 --> 00:27:57,039
um yeah but they are all pretty much

851
00:27:57,039 --> 00:27:59,360
boiled down to the same idea

852
00:27:59,360 --> 00:28:01,279
now the question is actually this was

853
00:28:01,279 --> 00:28:02,960
quite complicated and the question is is

854
00:28:02,960 --> 00:28:05,600
that actually necessary and i would say

855
00:28:05,600 --> 00:28:08,320
no because if you run moneta on firefox

856
00:28:08,320 --> 00:28:10,000
for example you see a bunch of forced

857
00:28:10,000 --> 00:28:12,159
positives once again so you also see in

858
00:28:12,159 --> 00:28:14,880
firefox there's that there is a bunch of

859
00:28:14,880 --> 00:28:17,039
private and executive memory and it even

860
00:28:17,039 --> 00:28:19,679
modified it on its own dla its own entry

861
00:28:19,679 --> 00:28:21,440
dla

862
00:28:21,440 --> 00:28:23,760
so i believe that memory artifacts alone

863
00:28:23,760 --> 00:28:26,159
are quite good first indicator

864
00:28:26,159 --> 00:28:28,000
but they have way way too many false

865
00:28:28,000 --> 00:28:29,200
positives

866
00:28:29,200 --> 00:28:32,000
for example why did firefox change its

867
00:28:32,000 --> 00:28:33,760
own anti-dll it's because it likes to

868
00:28:33,760 --> 00:28:35,840
hook its own create thread as a matter

869
00:28:35,840 --> 00:28:38,240
of an anti-exploit mechanism

870
00:28:38,240 --> 00:28:40,399
memory scanners can also be bypassed

871
00:28:40,399 --> 00:28:42,559
using gargoyle-like techniques and so

872
00:28:42,559 --> 00:28:44,799
the problem is that we definitely more

873
00:28:44,799 --> 00:28:46,799
need more metrics in order to identify

874
00:28:46,799 --> 00:28:49,200
infected processes

875
00:28:49,200 --> 00:28:51,919
once again the um observation is that we

876
00:28:51,919 --> 00:28:53,840
can spend most of the time waiting for

877
00:28:53,840 --> 00:28:55,279
new commands

878
00:28:55,279 --> 00:28:58,159
and what developers really like to do

879
00:28:58,159 --> 00:29:00,080
to make the beating sleep is to simply

880
00:29:00,080 --> 00:29:03,440
call sleep this is really obvious right

881
00:29:03,440 --> 00:29:05,200
but there's a big problem with sleep and

882
00:29:05,200 --> 00:29:07,919
the problem with this api call is that

883
00:29:07,919 --> 00:29:10,000
it sets this threat which is calling

884
00:29:10,000 --> 00:29:11,919
sleep to a very special state it's

885
00:29:11,919 --> 00:29:15,679
called anti it's called delay execution

886
00:29:15,679 --> 00:29:18,960
and on my machine i had 1 500 threats

887
00:29:18,960 --> 00:29:22,559
out of these 1 500 threats and only 20

888
00:29:22,559 --> 00:29:25,200
were in the state delay execution so we

889
00:29:25,200 --> 00:29:29,200
boil down from 1 500 to 20 threads which

890
00:29:29,200 --> 00:29:30,880
might be a beacon

891
00:29:30,880 --> 00:29:32,960
20 are still too many to check so we

892
00:29:32,960 --> 00:29:34,720
need another metric

893
00:29:34,720 --> 00:29:36,720
the net next metric could be a call

894
00:29:36,720 --> 00:29:38,559
stack on the left side we see a normal

895
00:29:38,559 --> 00:29:40,799
call stack we see that that it starts

896
00:29:40,799 --> 00:29:43,440
somewhere in user thread start

897
00:29:43,440 --> 00:29:45,200
and it can map every return address on

898
00:29:45,200 --> 00:29:48,080
the stack to a

899
00:29:48,080 --> 00:29:49,679
to a module on disk

900
00:29:49,679 --> 00:29:51,039
on the right side we see the one of the

901
00:29:51,039 --> 00:29:53,039
cobblestock beacon and we see that it

902
00:29:53,039 --> 00:29:54,480
does not start where it's supposed to

903
00:29:54,480 --> 00:29:56,559
start and at the same time there is this

904
00:29:56,559 --> 00:29:58,000
hex 1a

905
00:29:58,000 --> 00:29:59,520
what is this this cannot be associated

906
00:29:59,520 --> 00:30:00,880
with a file on this because this is

907
00:30:00,880 --> 00:30:02,799
quite abnormal

908
00:30:02,799 --> 00:30:04,320
and if you take a look at the

909
00:30:04,320 --> 00:30:06,559
implementation of gargoyle also of the

910
00:30:06,559 --> 00:30:08,799
deep sleep thing um the call stack looks

911
00:30:08,799 --> 00:30:10,320
even more broken because there are a

912
00:30:10,320 --> 00:30:11,760
bunch of pointers which cannot be mapped

913
00:30:11,760 --> 00:30:13,919
to a file on disk and it looks like

914
00:30:13,919 --> 00:30:16,399
virtual protect is calling sleep if you

915
00:30:16,399 --> 00:30:17,760
show me a developer who does this

916
00:30:17,760 --> 00:30:20,240
legitimately i want to talk to him

917
00:30:20,240 --> 00:30:21,120
um

918
00:30:21,120 --> 00:30:23,919
so yeah call stacks are also a thing and

919
00:30:23,919 --> 00:30:26,159
now the question is out of the 1500

920
00:30:26,159 --> 00:30:28,320
threads i have on my machine how many of

921
00:30:28,320 --> 00:30:30,799
these are in delay execution and have a

922
00:30:30,799 --> 00:30:32,640
stack trace to delay execution which

923
00:30:32,640 --> 00:30:34,880
contains unknown or tempered regions the

924
00:30:34,880 --> 00:30:38,720
answer is only one and it's a beacon

925
00:30:38,720 --> 00:30:40,880
so also for this i created a small tool

926
00:30:40,880 --> 00:30:42,720
to automate these steps it's called hans

927
00:30:42,720 --> 00:30:45,840
sleeping beacons and it first enumerates

928
00:30:45,840 --> 00:30:48,000
threads which are in delay execution and

929
00:30:48,000 --> 00:30:50,240
then it checks the call stack for

930
00:30:50,240 --> 00:30:52,640
unknown regions and also for

931
00:30:52,640 --> 00:30:54,399
text segments which

932
00:30:54,399 --> 00:30:55,679
do differ

933
00:30:55,679 --> 00:30:57,840
compared from the

934
00:30:57,840 --> 00:30:59,760
in memory compared to the version on

935
00:30:59,760 --> 00:31:02,080
disk

936
00:31:02,399 --> 00:31:04,640
yeah it picks up deep sleep because

937
00:31:04,640 --> 00:31:05,760
um

938
00:31:05,760 --> 00:31:07,679
this the threat is called is in delay

939
00:31:07,679 --> 00:31:09,679
execution and the stack is really really

940
00:31:09,679 --> 00:31:11,840
broken

941
00:31:11,840 --> 00:31:13,840
i had some false positives with this

942
00:31:13,840 --> 00:31:16,159
approach um i had positive false

943
00:31:16,159 --> 00:31:18,399
positives with updaters which are trying

944
00:31:18,399 --> 00:31:19,760
to protect itself because they're

945
00:31:19,760 --> 00:31:21,919
actually behaving like a beacon you know

946
00:31:21,919 --> 00:31:23,200
they're also trying to obfuscate

947
00:31:23,200 --> 00:31:25,039
themselves in memory because you don't

948
00:31:25,039 --> 00:31:27,039
they don't want you to reverse it

949
00:31:27,039 --> 00:31:28,880
at the same time they're also sleeping

950
00:31:28,880 --> 00:31:30,840
between their intervals

951
00:31:30,840 --> 00:31:32,480
um

952
00:31:32,480 --> 00:31:34,080
and i also had some false positives with

953
00:31:34,080 --> 00:31:36,799
very crappy c-sharp applications

954
00:31:36,799 --> 00:31:38,399
there are some other very easy bypasses

955
00:31:38,399 --> 00:31:40,159
for hand sleeping beacons the first idea

956
00:31:40,159 --> 00:31:41,840
could be to simply spoof the call stack

957
00:31:41,840 --> 00:31:43,919
which is actually not very easy if you

958
00:31:43,919 --> 00:31:45,919
want to do it correctly

959
00:31:45,919 --> 00:31:48,240
but the more easy way would even be to

960
00:31:48,240 --> 00:31:50,320
simply don't use sleep to weight between

961
00:31:50,320 --> 00:31:51,919
your callbacks you can also make use of

962
00:31:51,919 --> 00:31:54,000
weightable timers in order to have a bit

963
00:31:54,000 --> 00:31:55,679
of delay

964
00:31:55,679 --> 00:31:57,919
this then sets the thread in a state

965
00:31:57,919 --> 00:31:59,519
called weight user request which is way

966
00:31:59,519 --> 00:32:02,080
more common than delay execution

967
00:32:02,080 --> 00:32:04,320
cool so call stacks definitely leave

968
00:32:04,320 --> 00:32:06,480
significant iocs and this does not only

969
00:32:06,480 --> 00:32:08,559
apply to end delay execution but it also

970
00:32:08,559 --> 00:32:10,640
applies to other system calls

971
00:32:10,640 --> 00:32:12,320
memory scanners can actually fully be

972
00:32:12,320 --> 00:32:14,559
bypassed using gargoyle or gargoyle-like

973
00:32:14,559 --> 00:32:15,600
techniques

974
00:32:15,600 --> 00:32:16,880
and the

975
00:32:16,880 --> 00:32:19,600
c2 coders should definitely avoid using

976
00:32:19,600 --> 00:32:20,799
sleep

977
00:32:20,799 --> 00:32:23,200
internally from ic2 i use a modified

978
00:32:23,200 --> 00:32:24,880
version of deep sleep which is using

979
00:32:24,880 --> 00:32:27,279
weightable timers

980
00:32:27,279 --> 00:32:28,880
cool um this is almost the end of my

981
00:32:28,880 --> 00:32:31,440
presentation um i have some tools to

982
00:32:31,440 --> 00:32:32,640
release

983
00:32:32,640 --> 00:32:34,480
uh because earlier we were talking about

984
00:32:34,480 --> 00:32:37,440
keyless polymorphism i created a tool to

985
00:32:37,440 --> 00:32:39,039
automate the step which i call spider

986
00:32:39,039 --> 00:32:40,840
pick

987
00:32:40,840 --> 00:32:43,519
um and it actually

988
00:32:43,519 --> 00:32:45,679
does the objection on assembly level so

989
00:32:45,679 --> 00:32:46,960
what you do is

990
00:32:46,960 --> 00:32:50,159
um you first compile it using gcc or

991
00:32:50,159 --> 00:32:51,200
whatever

992
00:32:51,200 --> 00:32:52,000
to

993
00:32:52,000 --> 00:32:53,279
and you make the compiler output

994
00:32:53,279 --> 00:32:55,279
assembly then you make

995
00:32:55,279 --> 00:32:57,440
that spider pic do its job it's doing

996
00:32:57,440 --> 00:32:59,519
the obfuscation and then you compile it

997
00:32:59,519 --> 00:33:01,360
just as normal

998
00:33:01,360 --> 00:33:03,600
and in order to show how greatly this

999
00:33:03,600 --> 00:33:05,360
actually works we're also releasing a

1000
00:33:05,360 --> 00:33:06,720
sox proxy which is implemented as

1001
00:33:06,720 --> 00:33:08,720
position independent code the client

1002
00:33:08,720 --> 00:33:10,320
makes user web sockets and is

1003
00:33:10,320 --> 00:33:12,480
implemented as pic and the spyder pick

1004
00:33:12,480 --> 00:33:15,039
is integrated into makefile so it looks

1005
00:33:15,039 --> 00:33:16,480
differently every single time you

1006
00:33:16,480 --> 00:33:18,000
compile

1007
00:33:18,000 --> 00:33:19,200
the

1008
00:33:19,200 --> 00:33:21,279
the client version the backend is

1009
00:33:21,279 --> 00:33:22,799
written by my colleague and good friend

1010
00:33:22,799 --> 00:33:25,519
christian

1011
00:33:25,519 --> 00:33:27,840
and yeah you can find it on our github

1012
00:33:27,840 --> 00:33:28,640
so

1013
00:33:28,640 --> 00:33:30,480
if every time you compile lessons you

1014
00:33:30,480 --> 00:33:32,159
see that the fuzzy hash is completely

1015
00:33:32,159 --> 00:33:33,840
different

1016
00:33:33,840 --> 00:33:34,880
yet

1017
00:33:34,880 --> 00:33:37,279
they are all the same program

1018
00:33:37,279 --> 00:33:38,720
you can find it here on our github i

1019
00:33:38,720 --> 00:33:40,559
think my boss clicked on release right

1020
00:33:40,559 --> 00:33:41,679
now

1021
00:33:41,679 --> 00:33:45,120
and you simply type make to build it

1022
00:33:45,120 --> 00:33:48,600
okay that's it

