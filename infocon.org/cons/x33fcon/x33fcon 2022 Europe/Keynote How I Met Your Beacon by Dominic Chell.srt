1
00:00:01,850 --> 00:00:05,839
[Music]

2
00:00:05,839 --> 00:00:08,160
welcome to my talk i'm dominic one of

3
00:00:08,160 --> 00:00:10,719
the uh the red teamers from dusek

4
00:00:10,719 --> 00:00:13,040
um so my talk today is

5
00:00:13,040 --> 00:00:14,920
um how i met your

6
00:00:14,920 --> 00:00:17,920
beacons excellent that worked

7
00:00:17,920 --> 00:00:19,760
it i had to get some guy on fiverr to

8
00:00:19,760 --> 00:00:21,039
make that for me

9
00:00:21,039 --> 00:00:22,400
um

10
00:00:22,400 --> 00:00:23,600
so

11
00:00:23,600 --> 00:00:25,519
um so today i'm we'll be more focused on

12
00:00:25,519 --> 00:00:27,119
the blue side really um so i'm going to

13
00:00:27,119 --> 00:00:28,960
be looking at some effective strategies

14
00:00:28,960 --> 00:00:31,439
for detecting beacons on windows um

15
00:00:31,439 --> 00:00:34,079
including detections for behavior

16
00:00:34,079 --> 00:00:37,040
in-memory analysis network interaction

17
00:00:37,040 --> 00:00:38,879
and that kind of stuff

18
00:00:38,879 --> 00:00:41,520
i guess my interest in this topic is

19
00:00:41,520 --> 00:00:43,760
really three-fold and so firstly it's no

20
00:00:43,760 --> 00:00:45,200
secret that we've got some skin in the

21
00:00:45,200 --> 00:00:48,399
game um because we you know produce a

22
00:00:48,399 --> 00:00:51,520
framework ourselves um so i'm interested

23
00:00:51,520 --> 00:00:52,719
in this kind of stuff because obviously

24
00:00:52,719 --> 00:00:54,879
i want to improve our talk

25
00:00:54,879 --> 00:00:58,320
secondly from a red team perspective um

26
00:00:58,320 --> 00:00:59,600
i'm interested in it because i want to

27
00:00:59,600 --> 00:01:02,000
improve my craft and make sure that we

28
00:01:02,000 --> 00:01:04,000
avoid doing certain actions that might

29
00:01:04,000 --> 00:01:06,080
end up kind of leaving dangling iocs

30
00:01:06,080 --> 00:01:07,520
behind

31
00:01:07,520 --> 00:01:09,119
and then finally

32
00:01:09,119 --> 00:01:10,799
um yeah i do get involved with threat

33
00:01:10,799 --> 00:01:12,159
hunting exercises that kind of stuff at

34
00:01:12,159 --> 00:01:14,720
md sex so it is useful for me to have a

35
00:01:14,720 --> 00:01:16,240
good understanding on how to kind of

36
00:01:16,240 --> 00:01:17,920
spot beacons

37
00:01:17,920 --> 00:01:19,040
and i guess i've always been in the

38
00:01:19,040 --> 00:01:20,479
mindset

39
00:01:20,479 --> 00:01:22,240
in order to hide you kind of really need

40
00:01:22,240 --> 00:01:23,520
to understand all the different ways

41
00:01:23,520 --> 00:01:25,439
that you can be found

42
00:01:25,439 --> 00:01:27,600
i'll also kind of demo a tool that i've

43
00:01:27,600 --> 00:01:28,799
been working on that we're going to open

44
00:01:28,799 --> 00:01:30,560
source called beacon hunter which

45
00:01:30,560 --> 00:01:31,759
implements some of the strategies that

46
00:01:31,759 --> 00:01:33,680
i'm going to talk about today

47
00:01:33,680 --> 00:01:35,040
and then we'll look at some real world

48
00:01:35,040 --> 00:01:40,320
examples from some popular c2 frameworks

49
00:01:40,320 --> 00:01:41,600
so

50
00:01:41,600 --> 00:01:43,040
the c2 frameworks that we're going to

51
00:01:43,040 --> 00:01:44,399
focus on is probably going to make gene

52
00:01:44,399 --> 00:01:46,079
sweat a little bit over there

53
00:01:46,079 --> 00:01:48,399
the first one will be cobot strike

54
00:01:48,399 --> 00:01:50,000
i'm sure everybody's you know kind of

55
00:01:50,000 --> 00:01:51,360
familiar with this doesn't really need

56
00:01:51,360 --> 00:01:54,159
any introduction um yeah it's as popular

57
00:01:54,159 --> 00:01:56,159
with red teams as it is with threat

58
00:01:56,159 --> 00:01:57,200
actors

59
00:01:57,200 --> 00:01:59,280
and so having kind of an understanding

60
00:01:59,280 --> 00:02:00,960
on how to detect cobalt strike is really

61
00:02:00,960 --> 00:02:03,119
beneficial for defenders

62
00:02:03,119 --> 00:02:04,240
i guess like one of the great things

63
00:02:04,240 --> 00:02:05,680
about cobalt though

64
00:02:05,680 --> 00:02:07,280
at least from the red team perspective

65
00:02:07,280 --> 00:02:10,239
is that it's it's highly customizable so

66
00:02:10,239 --> 00:02:12,239
and there's a lot of flexibility for the

67
00:02:12,239 --> 00:02:14,560
operator to to kind of mix up how it

68
00:02:14,560 --> 00:02:17,120
behaves and that can make um pinning

69
00:02:17,120 --> 00:02:19,920
down generic detections quite tricky

70
00:02:19,920 --> 00:02:22,160
and so all the analysis that we did was

71
00:02:22,160 --> 00:02:24,879
on cable strike 4.6.1 which is the

72
00:02:24,879 --> 00:02:26,720
latest version

73
00:02:26,720 --> 00:02:28,160
the other c2 framework that we're going

74
00:02:28,160 --> 00:02:31,040
to talk about will be brute retell um

75
00:02:31,040 --> 00:02:32,720
this is another commercial framework

76
00:02:32,720 --> 00:02:34,000
developed by a company called dart

77
00:02:34,000 --> 00:02:36,319
vortex um it's a little bit less popular

78
00:02:36,319 --> 00:02:38,319
but it seems to be growing um in

79
00:02:38,319 --> 00:02:40,480
popularity amongst other actors at least

80
00:02:40,480 --> 00:02:42,879
um unit 42 and dropped a blog post

81
00:02:42,879 --> 00:02:44,560
recently talking about how it was being

82
00:02:44,560 --> 00:02:46,800
abused by apt 29

83
00:02:46,800 --> 00:02:48,080
and then i think maybe last week the

84
00:02:48,080 --> 00:02:49,599
week before i'm so fast dropped a blog

85
00:02:49,599 --> 00:02:52,480
post uh documenting on how the black cat

86
00:02:52,480 --> 00:02:54,800
ransomware group were using it

87
00:02:54,800 --> 00:02:56,239
um

88
00:02:56,239 --> 00:02:58,319
i guess um they kind of like stole some

89
00:02:58,319 --> 00:02:59,760
of my content actually because i wrote

90
00:02:59,760 --> 00:03:01,200
this talk a while ago and then people

91
00:03:01,200 --> 00:03:03,120
started like focusing on it and blogging

92
00:03:03,120 --> 00:03:04,480
about some of the stuff that i'd already

93
00:03:04,480 --> 00:03:05,599
knew about

94
00:03:05,599 --> 00:03:06,800
but hopefully you know a few things will

95
00:03:06,800 --> 00:03:08,560
still be quite unique

96
00:03:08,560 --> 00:03:10,640
um one of the interesting things i guess

97
00:03:10,640 --> 00:03:13,200
about um detections for boot retell is

98
00:03:13,200 --> 00:03:14,560
that the agent is not particularly

99
00:03:14,560 --> 00:03:17,680
customizable so um outside of the c2 you

100
00:03:17,680 --> 00:03:20,000
can't really change how it behaves and

101
00:03:20,000 --> 00:03:21,840
so for example there's no real way to

102
00:03:21,840 --> 00:03:23,120
kind of customize the obfuscate and

103
00:03:23,120 --> 00:03:25,040
sleep strategies um or it's loading

104
00:03:25,040 --> 00:03:26,319
process that kind of stuff so if you

105
00:03:26,319 --> 00:03:27,599
start to build detections for it they

106
00:03:27,599 --> 00:03:29,760
can be quite powerful

107
00:03:29,760 --> 00:03:30,720
um

108
00:03:30,720 --> 00:03:33,519
and then you know i saw this image on uh

109
00:03:33,519 --> 00:03:34,959
on twitter i think it's like vx

110
00:03:34,959 --> 00:03:36,720
underground put it up there and they you

111
00:03:36,720 --> 00:03:37,760
can see they've gone to the effort of

112
00:03:37,760 --> 00:03:39,680
obscuring all this kind of stuff but you

113
00:03:39,680 --> 00:03:40,959
probably can't see it's not too clear

114
00:03:40,959 --> 00:03:42,720
but there's actually an ip address in

115
00:03:42,720 --> 00:03:44,799
there that's not been obfuscated and i

116
00:03:44,799 --> 00:03:46,159
just randomly who is there and it

117
00:03:46,159 --> 00:03:48,480
pointed to moscow so um it kind of gives

118
00:03:48,480 --> 00:03:50,080
you an indication of who might be using

119
00:03:50,080 --> 00:03:51,360
this framework

120
00:03:51,360 --> 00:03:52,640
um

121
00:03:52,640 --> 00:03:54,640
all the analysis that we did was on the

122
00:03:54,640 --> 00:03:57,599
latest version which was one zero seven

123
00:03:57,599 --> 00:03:59,760
as of today

124
00:03:59,760 --> 00:04:00,879
so

125
00:04:00,879 --> 00:04:02,560
let's start from the beginning and look

126
00:04:02,560 --> 00:04:04,400
at how a beacon might actually begin its

127
00:04:04,400 --> 00:04:05,280
life

128
00:04:05,280 --> 00:04:06,959
um firstly there'd be some kind of

129
00:04:06,959 --> 00:04:08,159
loader

130
00:04:08,159 --> 00:04:09,519
that load has probably got an encrypted

131
00:04:09,519 --> 00:04:11,840
copy of the beacon inside it um the

132
00:04:11,840 --> 00:04:13,280
loader then will probably perform some

133
00:04:13,280 --> 00:04:15,760
kind of process injection and maybe to a

134
00:04:15,760 --> 00:04:18,160
remote process maybe in a local thread

135
00:04:18,160 --> 00:04:20,160
um then the shell code will probably

136
00:04:20,160 --> 00:04:23,359
unlock itself and

137
00:04:23,919 --> 00:04:24,720
and

138
00:04:24,720 --> 00:04:26,000
it will then go on to load any

139
00:04:26,000 --> 00:04:29,040
dependencies that required by the beacon

140
00:04:29,040 --> 00:04:30,960
um and then the reflective loader will

141
00:04:30,960 --> 00:04:32,720
be executing the reflective dll will be

142
00:04:32,720 --> 00:04:34,880
executing in memory doing it's all at c2

143
00:04:34,880 --> 00:04:36,000
from a thread

144
00:04:36,000 --> 00:04:37,759
and that's a pretty standard way for a

145
00:04:37,759 --> 00:04:39,759
beacon to kind of initialize itself and

146
00:04:39,759 --> 00:04:42,400
kind of get itself running in memory um

147
00:04:42,400 --> 00:04:45,040
what we're going to look at is um kind

148
00:04:45,040 --> 00:04:46,880
of like through each step of this this

149
00:04:46,880 --> 00:04:48,000
process

150
00:04:48,000 --> 00:04:50,000
oh

151
00:04:50,000 --> 00:04:52,000
what is going on here

152
00:04:52,000 --> 00:04:53,360
through each step of this process

153
00:04:53,360 --> 00:04:54,960
where's my thing yeah for each one of

154
00:04:54,960 --> 00:04:56,080
these steps we're going to look at

155
00:04:56,080 --> 00:04:58,560
basically um different iocs that can

156
00:04:58,560 --> 00:04:59,840
kind of trigger

157
00:04:59,840 --> 00:05:01,280
and where we can build detections around

158
00:05:01,280 --> 00:05:03,440
them

159
00:05:03,680 --> 00:05:05,039
so the first one that i'm going to focus

160
00:05:05,039 --> 00:05:07,199
on is behavior

161
00:05:07,199 --> 00:05:08,320
and i think behavior is quite

162
00:05:08,320 --> 00:05:10,160
interesting

163
00:05:10,160 --> 00:05:12,720
particularly when you look at

164
00:05:12,720 --> 00:05:14,080
commercial products because you can't

165
00:05:14,080 --> 00:05:15,759
necessarily change the behavior if it's

166
00:05:15,759 --> 00:05:18,080
a behavior that is built into the

167
00:05:18,080 --> 00:05:21,080
architecture

168
00:05:27,520 --> 00:05:30,719
okay that's back

169
00:05:31,759 --> 00:05:34,240
having some technical difficulties today

170
00:05:34,240 --> 00:05:35,680
um

171
00:05:35,680 --> 00:05:36,639
so

172
00:05:36,639 --> 00:05:38,400
some good examples of behaviors that we

173
00:05:38,400 --> 00:05:40,240
might be interested in and that could

174
00:05:40,240 --> 00:05:42,080
leave dangling iocs

175
00:05:42,080 --> 00:05:43,600
are things like image loads things like

176
00:05:43,600 --> 00:05:46,479
name pipes they might not necessarily be

177
00:05:46,479 --> 00:05:49,039
customizable by the operator

178
00:05:49,039 --> 00:05:50,880
so

179
00:05:50,880 --> 00:05:52,479
let's look at image loads to start off

180
00:05:52,479 --> 00:05:54,400
with um

181
00:05:54,400 --> 00:05:56,160
i guess so in order for a beacon to kind

182
00:05:56,160 --> 00:05:58,960
of remain small

183
00:06:00,080 --> 00:06:01,600
i'm not gonna change this it's just not

184
00:06:01,600 --> 00:06:05,880
working it's not working great

185
00:06:06,960 --> 00:06:10,160
okay that's better

186
00:06:10,160 --> 00:06:12,000
and so in order for the beacon to remain

187
00:06:12,000 --> 00:06:14,160
small it usually relies on functionality

188
00:06:14,160 --> 00:06:16,479
from the operating system um using dll

189
00:06:16,479 --> 00:06:18,000
dependencies

190
00:06:18,000 --> 00:06:19,759
so for example rather than building your

191
00:06:19,759 --> 00:06:21,600
own http client it kind of makes much

192
00:06:21,600 --> 00:06:22,880
more sense to use something like win

193
00:06:22,880 --> 00:06:24,720
http or win inept

194
00:06:24,720 --> 00:06:27,520
um now when the beacon loads these dlls

195
00:06:27,520 --> 00:06:30,000
we can obviously capture this telemetry

196
00:06:30,000 --> 00:06:32,080
if we're um

197
00:06:32,080 --> 00:06:33,840
you know collecting image load events um

198
00:06:33,840 --> 00:06:35,600
so for example here we can see we're

199
00:06:35,600 --> 00:06:37,600
capturing our notepad loading loading

200
00:06:37,600 --> 00:06:40,639
kernel base um.dll um with sysmol and

201
00:06:40,639 --> 00:06:43,280
event seven

202
00:06:44,560 --> 00:06:46,639
um so image load telemetry is kind of

203
00:06:46,639 --> 00:06:47,759
interesting for us because it gives us

204
00:06:47,759 --> 00:06:49,520
hunting opportunities

205
00:06:49,520 --> 00:06:51,280
um so some of the things that we can

206
00:06:51,280 --> 00:06:53,039
focus on are

207
00:06:53,039 --> 00:06:55,280
um beacon frameworks loading all its

208
00:06:55,280 --> 00:06:57,199
dependencies on at the start

209
00:06:57,199 --> 00:06:58,720
um

210
00:06:58,720 --> 00:07:00,720
we can start to build signatures on that

211
00:07:00,720 --> 00:07:02,960
and if we're hunting for egress beacons

212
00:07:02,960 --> 00:07:04,400
um we can see that they'll typically

213
00:07:04,400 --> 00:07:06,880
load things like win http or when inet

214
00:07:06,880 --> 00:07:09,680
and if we kind of create baselines of um

215
00:07:09,680 --> 00:07:12,080
dll loads from specific processes and we

216
00:07:12,080 --> 00:07:13,840
can look for anomalies so for example if

217
00:07:13,840 --> 00:07:15,840
we saw something like notepad loading

218
00:07:15,840 --> 00:07:17,599
dbg help that would probably be

219
00:07:17,599 --> 00:07:20,080
irregular

220
00:07:20,479 --> 00:07:21,840
um so how do we go about hunting for

221
00:07:21,840 --> 00:07:23,599
these kind of things um well usually

222
00:07:23,599 --> 00:07:25,520
most ddrs have this built into them you

223
00:07:25,520 --> 00:07:28,160
can you can build like hunt rules within

224
00:07:28,160 --> 00:07:30,560
your edr um but for for my examples i'm

225
00:07:30,560 --> 00:07:32,479
just going to use elastic um so if

226
00:07:32,479 --> 00:07:35,680
you're not familiar um with eql it's

227
00:07:35,680 --> 00:07:37,120
basically a sql like language that

228
00:07:37,120 --> 00:07:38,800
elastic provides you

229
00:07:38,800 --> 00:07:40,880
allows you to query the event database

230
00:07:40,880 --> 00:07:42,800
and so in this example all i'm basically

231
00:07:42,800 --> 00:07:44,400
saying is

232
00:07:44,400 --> 00:07:45,280
um

233
00:07:45,280 --> 00:07:48,080
give me all the processes that have

234
00:07:48,080 --> 00:07:51,919
loaded um cred ui.dll win http.dll

235
00:07:51,919 --> 00:07:53,520
within the space of a minute and we can

236
00:07:53,520 --> 00:07:55,840
just pump that into our events database

237
00:07:55,840 --> 00:07:58,080
and find all those processes so let's

238
00:07:58,080 --> 00:08:00,720
look at a real example

239
00:08:00,720 --> 00:08:01,520
so

240
00:08:01,520 --> 00:08:04,800
i took brute retail um and i injected it

241
00:08:04,800 --> 00:08:07,360
into notepad i'm using the built-in pc

242
00:08:07,360 --> 00:08:09,360
and jet command and then i just watched

243
00:08:09,360 --> 00:08:10,960
for dll loads

244
00:08:10,960 --> 00:08:12,800
and as you can see when the reflective

245
00:08:12,800 --> 00:08:15,360
loader executes um it loads all the

246
00:08:15,360 --> 00:08:17,759
dependencies for the dll effect for the

247
00:08:17,759 --> 00:08:19,360
reflective dll

248
00:08:19,360 --> 00:08:20,960
and there's quite a lot of stuff in

249
00:08:20,960 --> 00:08:22,560
there it kind of pretty much loads the

250
00:08:22,560 --> 00:08:25,280
kitchen sync

251
00:08:25,599 --> 00:08:27,199
so and there's some quite unique stuff

252
00:08:27,199 --> 00:08:28,560
that you wouldn't necessarily expect to

253
00:08:28,560 --> 00:08:31,759
see in all processes so for example um

254
00:08:31,759 --> 00:08:33,440
you know we can see cred ui here which

255
00:08:33,440 --> 00:08:34,799
is probably

256
00:08:34,799 --> 00:08:37,519
um wherever it is um it's probably down

257
00:08:37,519 --> 00:08:39,200
to his you know credential prompt

258
00:08:39,200 --> 00:08:40,640
phishing thing tool that he's got built

259
00:08:40,640 --> 00:08:43,360
into the c2

260
00:08:43,360 --> 00:08:46,160
um so what can we do with this um we're

261
00:08:46,160 --> 00:08:50,399
using eql we can trivially um build um

262
00:08:50,399 --> 00:08:52,000
you know signatures to detect brute

263
00:08:52,000 --> 00:08:53,920
retell when it's loading and when it's

264
00:08:53,920 --> 00:08:55,760
injected into beacons

265
00:08:55,760 --> 00:08:58,080
so for example if we took this eql rule

266
00:08:58,080 --> 00:09:00,160
we're basically saying give me all the

267
00:09:00,160 --> 00:09:03,200
processes where cred ui dbg help and win

268
00:09:03,200 --> 00:09:05,360
http are all loaded within the space of

269
00:09:05,360 --> 00:09:06,880
a minute

270
00:09:06,880 --> 00:09:08,320
and as we can see here i just pumped it

271
00:09:08,320 --> 00:09:10,240
into my events database and i was able

272
00:09:10,240 --> 00:09:12,720
to trivially find all the injected

273
00:09:12,720 --> 00:09:14,320
notepad processors

274
00:09:14,320 --> 00:09:16,000
and this is cool because we can use this

275
00:09:16,000 --> 00:09:16,880
um

276
00:09:16,880 --> 00:09:18,880
retrospectively so we can actually hunt

277
00:09:18,880 --> 00:09:21,200
for all injections that have occurred in

278
00:09:21,200 --> 00:09:23,440
our environment over time

279
00:09:23,440 --> 00:09:26,720
assuming we've got the telemetry

280
00:09:28,080 --> 00:09:30,720
so let's look at in memory stuff

281
00:09:30,720 --> 00:09:32,560
so once the beacon is injected it will

282
00:09:32,560 --> 00:09:34,880
typically remain memory resident really

283
00:09:34,880 --> 00:09:36,959
to avoid any undis detections

284
00:09:36,959 --> 00:09:38,959
um the beacon as i mentioned before is

285
00:09:38,959 --> 00:09:40,320
usually injected into memory using a

286
00:09:40,320 --> 00:09:42,320
loader which will like create a thread

287
00:09:42,320 --> 00:09:43,760
or hijack a thread

288
00:09:43,760 --> 00:09:44,959
um and then it will typically be

289
00:09:44,959 --> 00:09:47,040
operating from virtual memory or from a

290
00:09:47,040 --> 00:09:49,040
stomped module um so there's various

291
00:09:49,040 --> 00:09:50,480
kind of like things that we can look at

292
00:09:50,480 --> 00:09:52,800
and for in-memory detections

293
00:09:52,800 --> 00:09:54,560
the first one is probably the most

294
00:09:54,560 --> 00:09:56,640
straightforward and the most simple but

295
00:09:56,640 --> 00:09:58,080
is also possibly one of the most

296
00:09:58,080 --> 00:10:00,240
effective for detecting no malware which

297
00:10:00,240 --> 00:10:02,800
is using previous pre-built signatures

298
00:10:02,800 --> 00:10:04,880
essentially this involves um scanning

299
00:10:04,880 --> 00:10:06,720
memory with a tool something like yara

300
00:10:06,720 --> 00:10:08,959
or through your edr for known signatures

301
00:10:08,959 --> 00:10:10,560
of a beacon these could be like strings

302
00:10:10,560 --> 00:10:12,160
that might be in the reflective dll or

303
00:10:12,160 --> 00:10:13,839
they could be specific op codes from the

304
00:10:13,839 --> 00:10:16,640
text section of the implant

305
00:10:16,640 --> 00:10:17,920
so if you've not played with yara before

306
00:10:17,920 --> 00:10:20,160
it's pretty straightforward um a simple

307
00:10:20,160 --> 00:10:21,839
yar rule probably the most simple url

308
00:10:21,839 --> 00:10:23,600
might look something like this all we're

309
00:10:23,600 --> 00:10:25,920
basically saying is um

310
00:10:25,920 --> 00:10:28,800
scan this process memory um and if you

311
00:10:28,800 --> 00:10:30,240
spot two of these strings that are in

312
00:10:30,240 --> 00:10:33,360
blue this hello and thiefcon 2022. if

313
00:10:33,360 --> 00:10:36,079
you spot two of those um then then tell

314
00:10:36,079 --> 00:10:37,519
me about it

315
00:10:37,519 --> 00:10:38,800
so let's look

316
00:10:38,800 --> 00:10:42,640
at how this might apply to cobalt strike

317
00:10:42,640 --> 00:10:44,160
so

318
00:10:44,160 --> 00:10:45,680
cobblestrike has got some evasion

319
00:10:45,680 --> 00:10:47,600
configurations built into it for

320
00:10:47,600 --> 00:10:49,519
avoiding in-memory detections so the

321
00:10:49,519 --> 00:10:51,440
first one is the

322
00:10:51,440 --> 00:10:53,680
rep malleable config option and this

323
00:10:53,680 --> 00:10:56,000
basically allows the operator to replace

324
00:10:56,000 --> 00:10:57,600
strings that might exist within the

325
00:10:57,600 --> 00:10:59,279
beacon's reflective dll with whatever

326
00:10:59,279 --> 00:11:00,720
they want

327
00:11:00,720 --> 00:11:01,680
um

328
00:11:01,680 --> 00:11:04,560
now i think in-memory detections are

329
00:11:04,560 --> 00:11:06,079
probably a bit of a problem for cobalt

330
00:11:06,079 --> 00:11:07,440
strike at the moment because of its

331
00:11:07,440 --> 00:11:08,959
popularity

332
00:11:08,959 --> 00:11:10,800
and it's gained much more focus from edr

333
00:11:10,800 --> 00:11:13,040
and av companies and so what they did

334
00:11:13,040 --> 00:11:15,600
was in the 4.4 release they basically

335
00:11:15,600 --> 00:11:17,440
introduced a um something called the

336
00:11:17,440 --> 00:11:18,880
sleep mask kit

337
00:11:18,880 --> 00:11:21,279
which effectively allows the operator to

338
00:11:21,279 --> 00:11:22,959
provide their own custom code for

339
00:11:22,959 --> 00:11:24,560
sleeping and obfuscating the beacon in

340
00:11:24,560 --> 00:11:27,560
memory

341
00:11:28,000 --> 00:11:29,680
there's three kind of configurations

342
00:11:29,680 --> 00:11:31,440
that you can go with for this um for

343
00:11:31,440 --> 00:11:32,959
sleep masking obviously there's no sleep

344
00:11:32,959 --> 00:11:35,360
mask um in this kind of scenario the

345
00:11:35,360 --> 00:11:36,880
strings the code that will all remain in

346
00:11:36,880 --> 00:11:39,440
plain text and the beacon can trivially

347
00:11:39,440 --> 00:11:40,720
be picked out of memory through memory

348
00:11:40,720 --> 00:11:42,640
scanning

349
00:11:42,640 --> 00:11:45,120
we can enable sneak the sleep mask with

350
00:11:45,120 --> 00:11:46,560
sleep mask equals true in the marble

351
00:11:46,560 --> 00:11:49,519
profile and so when this is turned on um

352
00:11:49,519 --> 00:11:52,079
basically it will coax right will mask

353
00:11:52,079 --> 00:11:54,320
the beacon in memory and it will use xor

354
00:11:54,320 --> 00:11:56,800
to obfuscate the strings and data

355
00:11:56,800 --> 00:11:58,800
um and but this can still be

356
00:11:58,800 --> 00:12:00,160
fingerprinted because it's basically

357
00:12:00,160 --> 00:12:02,880
using like a pre-built um

358
00:12:02,880 --> 00:12:04,720
a pre-pre-built obfuscate and sleep

359
00:12:04,720 --> 00:12:05,760
strategy

360
00:12:05,760 --> 00:12:07,600
and you can you can build your rules for

361
00:12:07,600 --> 00:12:09,760
it on the uh on the on the actual code

362
00:12:09,760 --> 00:12:11,920
that does the sleeping

363
00:12:11,920 --> 00:12:13,279
and then finally which is probably the

364
00:12:13,279 --> 00:12:14,800
preferred option and you've got the

365
00:12:14,800 --> 00:12:16,959
user-defined sleep mask

366
00:12:16,959 --> 00:12:18,959
and this basically exposes the sleep

367
00:12:18,959 --> 00:12:21,839
mass functionality to the operator

368
00:12:21,839 --> 00:12:24,560
it provides them with pointers to be

369
00:12:24,560 --> 00:12:26,639
conceit memory and it basically allows

370
00:12:26,639 --> 00:12:27,760
you to kind of walk through it and

371
00:12:27,760 --> 00:12:30,160
obfuscate the text section and obfuscate

372
00:12:30,160 --> 00:12:32,000
all the heat records for the beacon

373
00:12:32,000 --> 00:12:34,720
which is pretty cool

374
00:12:35,360 --> 00:12:38,480
so if we look at how this actually works

375
00:12:38,480 --> 00:12:40,399
so using the user-defined sleep mask and

376
00:12:40,399 --> 00:12:41,680
there are a couple of things you need to

377
00:12:41,680 --> 00:12:43,839
be aware of a couple of trade-offs

378
00:12:43,839 --> 00:12:46,320
so notably

379
00:12:46,320 --> 00:12:49,519
if you're operating from

380
00:12:49,519 --> 00:12:52,480
kind of read execute memory only then it

381
00:12:52,480 --> 00:12:54,320
the beacon doesn't actually obfuscate

382
00:12:54,320 --> 00:12:55,760
the text section because it can't write

383
00:12:55,760 --> 00:12:56,639
to it

384
00:12:56,639 --> 00:12:58,240
so um

385
00:12:58,240 --> 00:13:00,079
in essence it's not actually adding

386
00:13:00,079 --> 00:13:01,279
anything

387
00:13:01,279 --> 00:13:03,279
so you can still build your rules for

388
00:13:03,279 --> 00:13:06,639
the text section of the beacon um so you

389
00:13:06,639 --> 00:13:08,800
can see in this example um we've got

390
00:13:08,800 --> 00:13:11,360
like userwx equals false

391
00:13:11,360 --> 00:13:13,120
and we're still able to pick up cobalt

392
00:13:13,120 --> 00:13:17,040
strike um with a url

393
00:13:17,120 --> 00:13:18,480
and that as i said that's basically

394
00:13:18,480 --> 00:13:20,320
because the text section is not

395
00:13:20,320 --> 00:13:22,959
modifiable

396
00:13:23,360 --> 00:13:24,720
if we

397
00:13:24,720 --> 00:13:26,160
if we wanted to obfuscate the text

398
00:13:26,160 --> 00:13:27,040
section

399
00:13:27,040 --> 00:13:28,720
we can do that

400
00:13:28,720 --> 00:13:30,720
but i guess the trade-off is we have to

401
00:13:30,720 --> 00:13:31,920
operate from

402
00:13:31,920 --> 00:13:34,639
read write execute memory um so i think

403
00:13:34,639 --> 00:13:36,320
it's probably a case of you know pick

404
00:13:36,320 --> 00:13:37,519
your poison what do you think is the

405
00:13:37,519 --> 00:13:40,240
bigger ioc

406
00:13:41,279 --> 00:13:42,560
how about brute retell does that fair

407
00:13:42,560 --> 00:13:45,279
any better um

408
00:13:45,279 --> 00:13:46,959
so if we took a look at the

409
00:13:46,959 --> 00:13:49,279
documentation for brute retell

410
00:13:49,279 --> 00:13:51,839
it basically says something along the

411
00:13:51,839 --> 00:13:54,000
lines of it's got a pretty complex sleep

412
00:13:54,000 --> 00:13:56,320
and obfuscate mechanism

413
00:13:56,320 --> 00:13:58,880
it uses a mixture of windows event

414
00:13:58,880 --> 00:14:00,000
creation

415
00:14:00,000 --> 00:14:02,399
weight objects timers in addition to

416
00:14:02,399 --> 00:14:04,959
kind of rock gadgets and apcs

417
00:14:04,959 --> 00:14:06,560
so you would think

418
00:14:06,560 --> 00:14:08,160
it would be pretty complex to detect the

419
00:14:08,160 --> 00:14:10,560
beacon right

420
00:14:10,560 --> 00:14:13,839
um so what we did was uh we injected a

421
00:14:13,839 --> 00:14:16,240
badger as he calls it to

422
00:14:16,240 --> 00:14:18,880
process put the badger to sleep

423
00:14:18,880 --> 00:14:21,519
on quite a high sleep and then just

424
00:14:21,519 --> 00:14:23,680
did a strings dump over the um all the

425
00:14:23,680 --> 00:14:25,519
strings that were in memory

426
00:14:25,519 --> 00:14:26,959
and i was a little bit surprised to see

427
00:14:26,959 --> 00:14:29,440
some stuff like this sitting around

428
00:14:29,440 --> 00:14:30,720
um

429
00:14:30,720 --> 00:14:32,240
so as i said all i did was use process

430
00:14:32,240 --> 00:14:34,240
hacker and don't dump to the strings and

431
00:14:34,240 --> 00:14:36,399
we can see randomly there's things like

432
00:14:36,399 --> 00:14:38,880
ansi ecw patched that kind of stuff i

433
00:14:38,880 --> 00:14:42,000
mean it sounds totally legit

434
00:14:42,639 --> 00:14:44,560
and basically that was because the the

435
00:14:44,560 --> 00:14:46,320
obvious gate and sleep mechanism is only

436
00:14:46,320 --> 00:14:48,480
only protecting the tech section

437
00:14:48,480 --> 00:14:50,560
um

438
00:14:50,560 --> 00:14:52,240
so what i did was i was kind of curious

439
00:14:52,240 --> 00:14:53,760
about how this was working so i wanted

440
00:14:53,760 --> 00:14:55,760
to reverse engineer it um so i threw it

441
00:14:55,760 --> 00:14:57,440
into either and i wanted to kind of

442
00:14:57,440 --> 00:14:59,040
start to build some some more reliable

443
00:14:59,040 --> 00:15:00,320
detections

444
00:15:00,320 --> 00:15:01,519
um

445
00:15:01,519 --> 00:15:04,079
so when i threw it into ida one of the

446
00:15:04,079 --> 00:15:05,839
things that i kind of spotted initially

447
00:15:05,839 --> 00:15:07,199
was um

448
00:15:07,199 --> 00:15:09,839
brute loader that's basically the export

449
00:15:09,839 --> 00:15:11,199
for the entry point for the reflective

450
00:15:11,199 --> 00:15:12,480
dll

451
00:15:12,480 --> 00:15:14,720
and so i searched memory for

452
00:15:14,720 --> 00:15:16,880
the string brute loader and we spotted

453
00:15:16,880 --> 00:15:19,519
it inside the sleeping badger

454
00:15:19,519 --> 00:15:21,120
and so what can we do with this well we

455
00:15:21,120 --> 00:15:24,560
can build a very simple url and to

456
00:15:24,560 --> 00:15:26,639
search for all instances of brute retell

457
00:15:26,639 --> 00:15:28,160
that might be running in any process in

458
00:15:28,160 --> 00:15:29,360
memory

459
00:15:29,360 --> 00:15:31,839
and pluck them out quite trivially

460
00:15:31,839 --> 00:15:32,800
um

461
00:15:32,800 --> 00:15:34,880
but can we take this one step further

462
00:15:34,880 --> 00:15:37,680
and we can so i plugged into virustotal

463
00:15:37,680 --> 00:15:40,160
and we can find all the other samples of

464
00:15:40,160 --> 00:15:42,079
brute retell that are sitting around in

465
00:15:42,079 --> 00:15:44,000
there and pull them down

466
00:15:44,000 --> 00:15:45,199
and have a look what they're doing as

467
00:15:45,199 --> 00:15:46,480
well

468
00:15:46,480 --> 00:15:47,519
and i'll come back to this because

469
00:15:47,519 --> 00:15:50,320
actually what we did was um we wrote a

470
00:15:50,320 --> 00:15:52,959
tool to extract all the configurations

471
00:15:52,959 --> 00:15:55,519
from the artifacts on disk and from the

472
00:15:55,519 --> 00:15:57,600
artifacts in memory and so you can get

473
00:15:57,600 --> 00:15:59,279
all the c2 information all that kind of

474
00:15:59,279 --> 00:16:01,519
stuff

475
00:16:02,000 --> 00:16:04,240
um so kind of moving on from signatures

476
00:16:04,240 --> 00:16:06,160
and what else can we use to spot the

477
00:16:06,160 --> 00:16:07,839
beacon

478
00:16:07,839 --> 00:16:10,240
well once the beacon's up and running

479
00:16:10,240 --> 00:16:12,240
in memory it will typically operate from

480
00:16:12,240 --> 00:16:13,759
as i said virtual memory or from like a

481
00:16:13,759 --> 00:16:15,120
stomp dll

482
00:16:15,120 --> 00:16:16,880
it's operating from virtual memory

483
00:16:16,880 --> 00:16:18,320
there's a few kind of like telltale

484
00:16:18,320 --> 00:16:19,920
indicators

485
00:16:19,920 --> 00:16:21,759
that we can use or we can focus on to

486
00:16:21,759 --> 00:16:23,920
build detections and so perhaps one of

487
00:16:23,920 --> 00:16:25,920
the most obvious things is is the page

488
00:16:25,920 --> 00:16:27,759
permissions as i kind of touched on with

489
00:16:27,759 --> 00:16:30,000
um with cobalt strike already

490
00:16:30,000 --> 00:16:32,720
um so outside of the the clr outside of

491
00:16:32,720 --> 00:16:35,920
clr jits it's pretty irregular to see

492
00:16:35,920 --> 00:16:37,839
executable pages that are not not backed

493
00:16:37,839 --> 00:16:39,279
by a dll

494
00:16:39,279 --> 00:16:41,120
so if we saw something like this where

495
00:16:41,120 --> 00:16:42,160
we've got

496
00:16:42,160 --> 00:16:44,560
the read execute page permission set and

497
00:16:44,560 --> 00:16:45,920
it's not

498
00:16:45,920 --> 00:16:48,240
backed against a physical dll on disk

499
00:16:48,240 --> 00:16:49,360
then it's probably a little bit

500
00:16:49,360 --> 00:16:51,759
suspicious

501
00:16:51,759 --> 00:16:54,079
um so if we can start to hunt for these

502
00:16:54,079 --> 00:16:55,759
um and you know if we kind of maybe

503
00:16:55,759 --> 00:16:58,160
disregard the cll modules for a moment

504
00:16:58,160 --> 00:17:00,639
um you know we can start to build kind

505
00:17:00,639 --> 00:17:02,320
of relatively high signal detections

506
00:17:02,320 --> 00:17:06,000
around them um obviously there are um

507
00:17:06,000 --> 00:17:08,799
there are ways around this um so some

508
00:17:08,799 --> 00:17:12,160
beacons have strategies built into them

509
00:17:12,160 --> 00:17:14,640
within their obfuscate and sleep to

510
00:17:14,640 --> 00:17:17,280
basically modify the page permissions

511
00:17:17,280 --> 00:17:18,720
and so basically when the beacon goes to

512
00:17:18,720 --> 00:17:20,480
sleep it removes the execute bit from

513
00:17:20,480 --> 00:17:22,000
that page

514
00:17:22,000 --> 00:17:23,359
and these strategies they typically

515
00:17:23,359 --> 00:17:25,839
leverage um some form of event driven

516
00:17:25,839 --> 00:17:28,960
execution within its sleep and wake

517
00:17:28,960 --> 00:17:31,600
and when it re-engages execution or use

518
00:17:31,600 --> 00:17:33,280
something like rob gadgets to call um

519
00:17:33,280 --> 00:17:35,120
virtual protect and we set the beacon's

520
00:17:35,120 --> 00:17:37,919
page permissions back to executable

521
00:17:37,919 --> 00:17:40,160
um so there is like some um you know

522
00:17:40,160 --> 00:17:41,600
blog posts out there detailing some of

523
00:17:41,600 --> 00:17:42,880
the techniques that we just that we

524
00:17:42,880 --> 00:17:44,320
discovered and we're using in our

525
00:17:44,320 --> 00:17:45,760
product and one of my colleagues peter

526
00:17:45,760 --> 00:17:47,120
wintersmith

527
00:17:47,120 --> 00:17:50,400
built a technique that uses um windows

528
00:17:50,400 --> 00:17:51,440
timers

529
00:17:51,440 --> 00:17:53,039
and this technique basically works by

530
00:17:53,039 --> 00:17:54,720
cueing a number of timers using queue

531
00:17:54,720 --> 00:17:56,080
time eq

532
00:17:56,080 --> 00:17:58,240
crate timer queue timer

533
00:17:58,240 --> 00:18:00,960
which then when it triggers um ends up

534
00:18:00,960 --> 00:18:03,520
returning to some previously defined

535
00:18:03,520 --> 00:18:05,919
context records which um call empty

536
00:18:05,919 --> 00:18:07,440
continue and end up calling virtual

537
00:18:07,440 --> 00:18:09,039
protect acting like a form of rop to

538
00:18:09,039 --> 00:18:11,440
engage the um execute bit back on the

539
00:18:11,440 --> 00:18:13,120
page

540
00:18:13,120 --> 00:18:14,720
so it might look something like this

541
00:18:14,720 --> 00:18:16,559
where when the beacon's awake and it's

542
00:18:16,559 --> 00:18:19,039
doing its tasking and the um the execute

543
00:18:19,039 --> 00:18:20,799
bit is set on that page

544
00:18:20,799 --> 00:18:22,080
um and then when the beacon goes to

545
00:18:22,080 --> 00:18:24,480
sleep it might be reset back to um we'd

546
00:18:24,480 --> 00:18:26,720
write

547
00:18:27,200 --> 00:18:28,480
so how does this work within cobalt

548
00:18:28,480 --> 00:18:30,559
strike um

549
00:18:30,559 --> 00:18:32,000
the well the page permissions were

550
00:18:32,000 --> 00:18:33,360
always executable in cobalt strike it

551
00:18:33,360 --> 00:18:35,679
doesn't have a strategy to um to remove

552
00:18:35,679 --> 00:18:37,600
them on on sleep um so the page

553
00:18:37,600 --> 00:18:39,520
permissions will typically remain um

554
00:18:39,520 --> 00:18:42,080
read execute or read write execute and

555
00:18:42,080 --> 00:18:44,559
without module stomping um this will

556
00:18:44,559 --> 00:18:45,919
always um

557
00:18:45,919 --> 00:18:47,840
you know run from virtual memory won't

558
00:18:47,840 --> 00:18:49,679
have a dll packed against it so that's

559
00:18:49,679 --> 00:18:52,320
that's pretty straightforward to pick up

560
00:18:52,320 --> 00:18:55,679
brute retail does have um a of the skate

561
00:18:55,679 --> 00:18:56,960
and sleep strategy that modifies the

562
00:18:56,960 --> 00:18:59,280
page permissions so you can see here

563
00:18:59,280 --> 00:19:01,679
it's um read execute and then when the

564
00:19:01,679 --> 00:19:03,600
beacon's asleep it's um it's really

565
00:19:03,600 --> 00:19:04,640
right

566
00:19:04,640 --> 00:19:07,440
um so i was kind of like curious um to

567
00:19:07,440 --> 00:19:09,360
see you know kind of how this works and

568
00:19:09,360 --> 00:19:11,039
one of the interesting things about this

569
00:19:11,039 --> 00:19:12,880
strategy within brute retell is you know

570
00:19:12,880 --> 00:19:14,160
it's kind of cool that it's like

571
00:19:14,160 --> 00:19:15,280
flipping the page permissions because it

572
00:19:15,280 --> 00:19:16,400
does make it harder to set when it's

573
00:19:16,400 --> 00:19:17,440
sleeping

574
00:19:17,440 --> 00:19:19,280
that is unless you've got a badger

575
00:19:19,280 --> 00:19:22,000
linked to peer-to-peer um because

576
00:19:22,000 --> 00:19:23,840
obviously those two need to communicate

577
00:19:23,840 --> 00:19:25,679
so if you've got a pivot enabled within

578
00:19:25,679 --> 00:19:28,240
brute retell um you know all bets are

579
00:19:28,240 --> 00:19:30,880
off it just doesn't encrypt itself and

580
00:19:30,880 --> 00:19:32,960
it remains executable all the time so if

581
00:19:32,960 --> 00:19:34,559
you've got a egress beacon link to

582
00:19:34,559 --> 00:19:36,240
appear to be become

583
00:19:36,240 --> 00:19:38,799
there's no obfuscating sleep um so i was

584
00:19:38,799 --> 00:19:40,880
kind of like curious again at how this

585
00:19:40,880 --> 00:19:44,400
um how this worked

586
00:19:45,360 --> 00:19:47,520
so what i did was um

587
00:19:47,520 --> 00:19:49,919
while i was reversing brute retell um i

588
00:19:49,919 --> 00:19:51,520
had to look at the obfuscate skating

589
00:19:51,520 --> 00:19:54,720
sleep inside either

590
00:19:54,799 --> 00:19:56,880
and

591
00:19:56,880 --> 00:19:58,480
i guess like basically the way it works

592
00:19:58,480 --> 00:19:59,840
is or what it does the first thing it

593
00:19:59,840 --> 00:20:01,760
does is it creates a new thread

594
00:20:01,760 --> 00:20:03,200
and it splits the start address of that

595
00:20:03,200 --> 00:20:05,200
thread to be tp release

596
00:20:05,200 --> 00:20:08,880
clean up group members plus 55 hex

597
00:20:08,880 --> 00:20:11,440
and then once it creates that thread it

598
00:20:11,440 --> 00:20:13,600
sets up a number of context structures

599
00:20:13,600 --> 00:20:15,120
and so these context structures are

600
00:20:15,120 --> 00:20:17,120
basically used to call things like

601
00:20:17,120 --> 00:20:18,559
anti-wave single object to delay

602
00:20:18,559 --> 00:20:21,760
execution um nt virtual memory to change

603
00:20:21,760 --> 00:20:24,320
page permissions system function uh 32

604
00:20:24,320 --> 00:20:28,080
to do rt4 that kind of stuff

605
00:20:28,080 --> 00:20:29,200
and these are basically the different

606
00:20:29,200 --> 00:20:31,760
steps within its um it's encrypt

607
00:20:31,760 --> 00:20:34,559
obfuscate and sleep strategy

608
00:20:34,559 --> 00:20:35,760
and then once it's set up the context

609
00:20:35,760 --> 00:20:37,200
structures it basically queues a bunch

610
00:20:37,200 --> 00:20:39,360
of apcs against nt continue

611
00:20:39,360 --> 00:20:41,600
and these will end up proxying calls um

612
00:20:41,600 --> 00:20:43,600
to those contact structures as i kind of

613
00:20:43,600 --> 00:20:45,120
mentioned

614
00:20:45,120 --> 00:20:48,240
um so by the time i'd kind of like put a

615
00:20:48,240 --> 00:20:50,720
couple of hours into into reversing this

616
00:20:50,720 --> 00:20:53,520
um it kind of like clicked on me um i've

617
00:20:53,520 --> 00:20:54,799
seen this before

618
00:20:54,799 --> 00:20:57,760
um and it basically it's just the um the

619
00:20:57,760 --> 00:20:59,760
open source implementation of foliage

620
00:20:59,760 --> 00:21:01,840
that austin hudson's got on his github

621
00:21:01,840 --> 00:21:04,159
repo

622
00:21:04,159 --> 00:21:06,400
um i like interestingly you know based

623
00:21:06,400 --> 00:21:07,919
on the description about the timers and

624
00:21:07,919 --> 00:21:09,200
all that kind of like stuff that was in

625
00:21:09,200 --> 00:21:10,400
the blog post i was expecting to see a

626
00:21:10,400 --> 00:21:11,840
little bit more but um actually i

627
00:21:11,840 --> 00:21:13,360
couldn't find any imports for any of the

628
00:21:13,360 --> 00:21:16,799
timer apis or anything like that so um

629
00:21:16,799 --> 00:21:19,679
maybe i missed something

630
00:21:19,760 --> 00:21:21,440
um

631
00:21:21,440 --> 00:21:23,919
so moving on um there are other kind of

632
00:21:23,919 --> 00:21:26,400
like in-memory iocs that can can be left

633
00:21:26,400 --> 00:21:28,159
around dangling around

634
00:21:28,159 --> 00:21:29,600
that threat hunters can use to build

635
00:21:29,600 --> 00:21:30,799
detections

636
00:21:30,799 --> 00:21:31,760
um

637
00:21:31,760 --> 00:21:32,960
so these might be deplored by the

638
00:21:32,960 --> 00:21:34,159
operator they might be deployed by the

639
00:21:34,159 --> 00:21:36,480
beacon um so some good examples of these

640
00:21:36,480 --> 00:21:39,120
are um patches like memory hooks um so

641
00:21:39,120 --> 00:21:41,039
things that might be um applied to

642
00:21:41,039 --> 00:21:43,039
things like etw or ramsey i mean maybe

643
00:21:43,039 --> 00:21:44,640
to disabled telemetry or to avoid

644
00:21:44,640 --> 00:21:46,960
scanning from antivirus engines

645
00:21:46,960 --> 00:21:48,559
um so hunting for these can give us a

646
00:21:48,559 --> 00:21:50,640
really high signal um that something

647
00:21:50,640 --> 00:21:53,120
suspicious is going on inside a beacon

648
00:21:53,120 --> 00:21:54,799
um so in this example and these are

649
00:21:54,799 --> 00:21:58,799
taken from um the sliver armory um so

650
00:21:58,799 --> 00:22:00,880
basically patching ecw you can see all

651
00:22:00,880 --> 00:22:02,640
it's doing is finding the address of et

652
00:22:02,640 --> 00:22:03,520
um

653
00:22:03,520 --> 00:22:05,600
etw event right and it's patching it

654
00:22:05,600 --> 00:22:06,559
with the ret

655
00:22:06,559 --> 00:22:07,600
um

656
00:22:07,600 --> 00:22:08,880
and then we've got an amd scan buffer

657
00:22:08,880 --> 00:22:11,039
bypass down here um so if we can

658
00:22:11,039 --> 00:22:13,760
actually hunt for these in processes we

659
00:22:13,760 --> 00:22:15,679
um looking for these patches then we

660
00:22:15,679 --> 00:22:16,880
know that there's something suspicious

661
00:22:16,880 --> 00:22:19,200
going on

662
00:22:19,760 --> 00:22:21,200
um the only kind of like problem with

663
00:22:21,200 --> 00:22:22,559
this of course is that some of those

664
00:22:22,559 --> 00:22:24,559
patches might be reverted so they could

665
00:22:24,559 --> 00:22:26,799
be temporary so for example maybe you've

666
00:22:26,799 --> 00:22:28,559
got like a clr harness that's used to

667
00:22:28,559 --> 00:22:30,559
run an assembly in memory um you might

668
00:22:30,559 --> 00:22:33,200
pack gtw and amse do the post

669
00:22:33,200 --> 00:22:35,760
exploitation um assembly execution and

670
00:22:35,760 --> 00:22:38,240
then remove those patches so um hunting

671
00:22:38,240 --> 00:22:40,400
for the patches alone is not necessarily

672
00:22:40,400 --> 00:22:42,320
the best thing to do

673
00:22:42,320 --> 00:22:43,679
but there are some kind of like dangling

674
00:22:43,679 --> 00:22:46,960
iocs that do get left around

675
00:22:46,960 --> 00:22:49,039
and so the way windows works is it will

676
00:22:49,039 --> 00:22:51,520
back common dlls to physical memory and

677
00:22:51,520 --> 00:22:52,799
these are shared across different

678
00:22:52,799 --> 00:22:55,360
processes on the host now if a beacon

679
00:22:55,360 --> 00:22:56,400
patches

680
00:22:56,400 --> 00:22:57,840
a dll something like

681
00:22:57,840 --> 00:23:00,000
ntdll um in our previous example like

682
00:23:00,000 --> 00:23:02,000
etw and that triggers what's known as a

683
00:23:02,000 --> 00:23:03,919
copy on white operation so that

684
00:23:03,919 --> 00:23:05,840
basically means that that

685
00:23:05,840 --> 00:23:08,400
that process gets its own copy of the

686
00:23:08,400 --> 00:23:09,440
dll

687
00:23:09,440 --> 00:23:11,440
and that page gets marked as private and

688
00:23:11,440 --> 00:23:13,600
when the page gets marked as private um

689
00:23:13,600 --> 00:23:15,520
it basically clears a specific bit known

690
00:23:15,520 --> 00:23:17,520
as the shared bit on that page so what

691
00:23:17,520 --> 00:23:19,919
we can do is we can hunt four processes

692
00:23:19,919 --> 00:23:21,679
and hunt for pages with the shared bit

693
00:23:21,679 --> 00:23:23,919
cleared and then we can resolve all the

694
00:23:23,919 --> 00:23:25,919
exports in those pages and we can get a

695
00:23:25,919 --> 00:23:28,159
good indicator um if something that has

696
00:23:28,159 --> 00:23:30,400
been um has been hooked on the on that

697
00:23:30,400 --> 00:23:32,400
page

698
00:23:32,400 --> 00:23:33,760
so if we took a look at an example of

699
00:23:33,760 --> 00:23:35,840
this from from brook retail and so

700
00:23:35,840 --> 00:23:39,520
brutal's got a shop in line um command

701
00:23:39,520 --> 00:23:41,279
um and

702
00:23:41,279 --> 00:23:43,200
you can see here when we run shop in

703
00:23:43,200 --> 00:23:45,840
line with an assembly um it says on the

704
00:23:45,840 --> 00:23:47,919
console you know patch dtw event right

705
00:23:47,919 --> 00:23:49,919
and patch ramsey and now these patches

706
00:23:49,919 --> 00:23:51,760
are permanent so what i did was um i

707
00:23:51,760 --> 00:23:53,360
just ran sharp in line let it run the

708
00:23:53,360 --> 00:23:56,000
assembly and then i attached when dbg to

709
00:23:56,000 --> 00:23:57,360
the process

710
00:23:57,360 --> 00:24:00,480
and i just um disassembled etw event

711
00:24:00,480 --> 00:24:02,240
right and amazing scan buffer and you

712
00:24:02,240 --> 00:24:04,320
can see even after the assemblies um

713
00:24:04,320 --> 00:24:06,080
finished executing the the function

714
00:24:06,080 --> 00:24:08,080
remains patched so if we're threat

715
00:24:08,080 --> 00:24:10,080
hunting that we can trivially detect

716
00:24:10,080 --> 00:24:12,640
brute retell um based on some of the

717
00:24:12,640 --> 00:24:14,799
post exploitation actions of the

718
00:24:14,799 --> 00:24:17,039
operator when they're running clr

719
00:24:17,039 --> 00:24:18,480
assemblies

720
00:24:18,480 --> 00:24:21,679
by looking for these patches

721
00:24:22,880 --> 00:24:23,840
um

722
00:24:23,840 --> 00:24:26,000
in addition to this um threads can give

723
00:24:26,000 --> 00:24:27,200
us a

724
00:24:27,200 --> 00:24:29,120
a relatively kind of good hunting

725
00:24:29,120 --> 00:24:30,720
opportunity as well

726
00:24:30,720 --> 00:24:32,240
so threads as i kind of mentioned before

727
00:24:32,240 --> 00:24:34,400
will typically um be operating virtual

728
00:24:34,400 --> 00:24:36,640
memory or from from storm dll and there

729
00:24:36,640 --> 00:24:38,320
may be one or more threads depending on

730
00:24:38,320 --> 00:24:39,840
whether the beacon is synchronous or

731
00:24:39,840 --> 00:24:41,520
asynchronous and so looking for

732
00:24:41,520 --> 00:24:43,360
anomalies in these threads um can be

733
00:24:43,360 --> 00:24:46,000
extremely useful to us

734
00:24:46,000 --> 00:24:47,840
um so you can see in this example we've

735
00:24:47,840 --> 00:24:50,720
got uh we've got cobalt strike um um we

736
00:24:50,720 --> 00:24:51,919
could we can tell it's like one of the

737
00:24:51,919 --> 00:24:53,679
kerbal strike threads because it just it

738
00:24:53,679 --> 00:24:55,760
just looks entirely suspicious um so

739
00:24:55,760 --> 00:24:57,200
we've got this kind of like null start

740
00:24:57,200 --> 00:24:58,720
address and then if we look at the call

741
00:24:58,720 --> 00:24:59,919
stack for the thread we can see there's

742
00:24:59,919 --> 00:25:03,120
a bunch of calls to virtual memory

743
00:25:03,120 --> 00:25:04,799
um

744
00:25:04,799 --> 00:25:06,480
but kind of like what else can we look

745
00:25:06,480 --> 00:25:08,400
for um

746
00:25:08,400 --> 00:25:09,440
well

747
00:25:09,440 --> 00:25:10,720
at some point when the beacon goes to

748
00:25:10,720 --> 00:25:12,720
sleep it needs to delay execution it

749
00:25:12,720 --> 00:25:15,919
needs to wait so um if we examine the

750
00:25:15,919 --> 00:25:18,480
call stack of different threads um

751
00:25:18,480 --> 00:25:20,559
and we see um some of the functions that

752
00:25:20,559 --> 00:25:22,320
are typically used to delay execution so

753
00:25:22,320 --> 00:25:24,880
things like sleep x and sleep x ends up

754
00:25:24,880 --> 00:25:27,279
calling the nt api into nt delay

755
00:25:27,279 --> 00:25:28,559
execution

756
00:25:28,559 --> 00:25:30,640
if we hunt for these threads and we

757
00:25:30,640 --> 00:25:32,559
combine them with other iocs like the

758
00:25:32,559 --> 00:25:35,120
virtual memory and then you know that's

759
00:25:35,120 --> 00:25:36,559
a pretty good indicator that this is a

760
00:25:36,559 --> 00:25:39,200
sleeping beacon

761
00:25:40,799 --> 00:25:42,480
obviously there are kind of like ways to

762
00:25:42,480 --> 00:25:45,360
kind of get around this um

763
00:25:45,360 --> 00:25:46,480
you know to kind of mask these

764
00:25:46,480 --> 00:25:48,640
suspicious goals within your call stack

765
00:25:48,640 --> 00:25:50,080
um and it seems to be quite a popular

766
00:25:50,080 --> 00:25:52,799
thing at the moment

767
00:25:55,200 --> 00:25:57,919
so some of the techniques are um

768
00:25:57,919 --> 00:26:00,720
to kind of like spoof the call stack um

769
00:26:00,720 --> 00:26:01,840
there's a few different ways we can do

770
00:26:01,840 --> 00:26:03,679
this and so we can

771
00:26:03,679 --> 00:26:05,919
could truncate the stack and so

772
00:26:05,919 --> 00:26:07,520
basically we end it before some of these

773
00:26:07,520 --> 00:26:09,120
suspicious calls

774
00:26:09,120 --> 00:26:10,880
and this is pretty easy to do and you

775
00:26:10,880 --> 00:26:12,080
can basically

776
00:26:12,080 --> 00:26:14,240
just um set the return address of the

777
00:26:14,240 --> 00:26:15,600
frame that you where you want to end to

778
00:26:15,600 --> 00:26:18,880
null um and that will effectively kind

779
00:26:18,880 --> 00:26:20,400
of match that stack for us or end it

780
00:26:20,400 --> 00:26:22,720
early

781
00:26:22,880 --> 00:26:24,720
another approach might be to actually

782
00:26:24,720 --> 00:26:26,240
clone the context of the legitimate

783
00:26:26,240 --> 00:26:30,000
thread um so we can find a a legitimate

784
00:26:30,000 --> 00:26:31,840
thread that is running in the process

785
00:26:31,840 --> 00:26:33,120
um and then when the beacon goes to

786
00:26:33,120 --> 00:26:35,919
sleep we copy the context of it um and

787
00:26:35,919 --> 00:26:38,159
we overwrite our own context with it and

788
00:26:38,159 --> 00:26:40,400
then we update the tib to make sure that

789
00:26:40,400 --> 00:26:43,679
the tip values match for that thread

790
00:26:43,679 --> 00:26:46,640
that's pretty effective

791
00:26:47,360 --> 00:26:48,720
or another approach this is the one

792
00:26:48,720 --> 00:26:52,240
that's used by kebab strike um is to

793
00:26:52,240 --> 00:26:54,400
switch the thread to a fiber um so when

794
00:26:54,400 --> 00:26:56,240
the beacon goes to sleep it changes it

795
00:26:56,240 --> 00:26:58,159
changes to a fiber and calling crate

796
00:26:58,159 --> 00:27:00,799
fiber x um and that effectively creates

797
00:27:00,799 --> 00:27:03,200
a new stack um so what you actually look

798
00:27:03,200 --> 00:27:05,440
at when you retrieve the stack is is the

799
00:27:05,440 --> 00:27:07,039
stack for the fiber rather than the

800
00:27:07,039 --> 00:27:09,120
thread and it looks a lot less

801
00:27:09,120 --> 00:27:10,480
suspicious because it hides the kind of

802
00:27:10,480 --> 00:27:12,960
calls to virtual memory

803
00:27:12,960 --> 00:27:13,679
so

804
00:27:13,679 --> 00:27:14,880
they might look something like this so

805
00:27:14,880 --> 00:27:17,679
the first one up here is uh is brute

806
00:27:17,679 --> 00:27:19,520
retell

807
00:27:19,520 --> 00:27:21,840
now the the bit stop highlighted um are

808
00:27:21,840 --> 00:27:24,320
the bits that are suspicious so we can

809
00:27:24,320 --> 00:27:26,320
see the start address um of the boot

810
00:27:26,320 --> 00:27:28,640
retail thread is i'm tp release cleanup

811
00:27:28,640 --> 00:27:31,399
group members plus

812
00:27:31,399 --> 00:27:33,440
5550 hex

813
00:27:33,440 --> 00:27:35,200
um now

814
00:27:35,200 --> 00:27:37,120
every brute retell thread gets this as a

815
00:27:37,120 --> 00:27:38,880
start address and this is not a common

816
00:27:38,880 --> 00:27:41,120
start address like i i scanned my host

817
00:27:41,120 --> 00:27:42,640
and i couldn't find any other processes

818
00:27:42,640 --> 00:27:44,399
other than the retail ones that are

819
00:27:44,399 --> 00:27:45,840
using this as a start address i'm not

820
00:27:45,840 --> 00:27:48,240
sure why why this one was picked but it

821
00:27:48,240 --> 00:27:50,320
becomes quite a trivial way to actually

822
00:27:50,320 --> 00:27:52,399
pluck these beacons out of memory

823
00:27:52,399 --> 00:27:54,320
if we looked at the call stack for it we

824
00:27:54,320 --> 00:27:56,559
can see we've got some calls to delay

825
00:27:56,559 --> 00:27:58,640
execution and then at the end we've got

826
00:27:58,640 --> 00:28:00,799
this nt terminate job object now that is

827
00:28:00,799 --> 00:28:03,760
actually just a rop gadget um so if if

828
00:28:03,760 --> 00:28:05,919
you look at this in one dbg you can

829
00:28:05,919 --> 00:28:07,039
actually see it's a rock gadget for

830
00:28:07,039 --> 00:28:08,480
anti-test alert and he basically just

831
00:28:08,480 --> 00:28:12,000
uses it to make the um the the uh to

832
00:28:12,000 --> 00:28:13,440
execute the abcs that are cued on the

833
00:28:13,440 --> 00:28:15,039
thread

834
00:28:15,039 --> 00:28:17,840
um if we look at cobalt strikes um

835
00:28:17,840 --> 00:28:19,600
thread stack spoofing and this is quite

836
00:28:19,600 --> 00:28:21,440
a new thing um it's only actually

837
00:28:21,440 --> 00:28:24,399
available like in the artifact kit um

838
00:28:24,399 --> 00:28:26,640
which was kind of quite surprising so

839
00:28:26,640 --> 00:28:30,240
only the um the dll and the xc artifacts

840
00:28:30,240 --> 00:28:31,919
that you produce

841
00:28:31,919 --> 00:28:34,080
are able to spoof the call stack it

842
00:28:34,080 --> 00:28:35,840
doesn't work for shell code or the

843
00:28:35,840 --> 00:28:37,360
reflective dll

844
00:28:37,360 --> 00:28:39,520
um so if you are i don't know don't know

845
00:28:39,520 --> 00:28:41,520
who uses the the the artifacts but if

846
00:28:41,520 --> 00:28:43,600
you do then you can spoof the call stack

847
00:28:43,600 --> 00:28:44,720
and it might look something like this

848
00:28:44,720 --> 00:28:46,640
and again um

849
00:28:46,640 --> 00:28:48,240
i think that's a i think it still looks

850
00:28:48,240 --> 00:28:50,399
a bit suspicious because i'm not sure

851
00:28:50,399 --> 00:28:53,200
how popular fibers actually are um but

852
00:28:53,200 --> 00:28:55,120
we can we can spot the fiber just by the

853
00:28:55,120 --> 00:28:58,080
call to rtl user fiber start as the um

854
00:28:58,080 --> 00:28:59,520
the first in the first frame in the call

855
00:28:59,520 --> 00:29:01,840
stack

856
00:29:02,320 --> 00:29:04,960
um so like some suspicious indicators um

857
00:29:04,960 --> 00:29:07,760
for stack spoofing um that we can use to

858
00:29:07,760 --> 00:29:10,480
kind of build hunt rules

859
00:29:10,480 --> 00:29:13,520
um so i guess um firstly um at least in

860
00:29:13,520 --> 00:29:15,200
most of the threads that i've looked at

861
00:29:15,200 --> 00:29:16,480
and they tend to have a common start

862
00:29:16,480 --> 00:29:18,480
address so if the start address of the

863
00:29:18,480 --> 00:29:19,440
um

864
00:29:19,440 --> 00:29:22,399
the thread is rtl user thread start uh

865
00:29:22,399 --> 00:29:24,240
sorry it's not rtl user that's start and

866
00:29:24,240 --> 00:29:26,080
the second frame is not base um thread

867
00:29:26,080 --> 00:29:28,480
and it thunk then it's possibly that the

868
00:29:28,480 --> 00:29:29,919
call stack has been truncated in some

869
00:29:29,919 --> 00:29:31,440
way

870
00:29:31,440 --> 00:29:33,039
um in terms of like looking for clone

871
00:29:33,039 --> 00:29:34,960
context and what we can do is recover

872
00:29:34,960 --> 00:29:37,039
the tib for each thread

873
00:29:37,039 --> 00:29:38,000
and

874
00:29:38,000 --> 00:29:40,320
we just look for duplicated values so if

875
00:29:40,320 --> 00:29:42,480
we saw something like um stack base and

876
00:29:42,480 --> 00:29:44,720
stat limit attributes and that

877
00:29:44,720 --> 00:29:46,559
within the tip that i duplicated across

878
00:29:46,559 --> 00:29:48,720
different threads then um that's

879
00:29:48,720 --> 00:29:50,000
probably irregular and it means that

880
00:29:50,000 --> 00:29:51,520
that thread has been spoofed or cloned

881
00:29:51,520 --> 00:29:53,600
in some way

882
00:29:53,600 --> 00:29:55,120
and then finally kind of as i mentioned

883
00:29:55,120 --> 00:29:57,360
it's not not too common to see fibers um

884
00:29:57,360 --> 00:29:58,960
anymore so scanner my own system i

885
00:29:58,960 --> 00:30:00,880
didn't didn't find any examples of them

886
00:30:00,880 --> 00:30:02,399
but basically we could potentially build

887
00:30:02,399 --> 00:30:05,200
um hunt rules looking for um for fibers

888
00:30:05,200 --> 00:30:07,039
so things with thread stacks with the

889
00:30:07,039 --> 00:30:08,399
start address of rtl

890
00:30:08,399 --> 00:30:11,360
use a fiber start

891
00:30:11,600 --> 00:30:12,559
um

892
00:30:12,559 --> 00:30:14,799
so one one kind of approach for avoiding

893
00:30:14,799 --> 00:30:16,159
threads running from virtual memory is

894
00:30:16,159 --> 00:30:19,120
to use module stomping

895
00:30:19,120 --> 00:30:21,520
so this technique basically involves

896
00:30:21,520 --> 00:30:24,720
loading a legitimate module and then we

897
00:30:24,720 --> 00:30:27,200
stomp a copy of the beacon over it um

898
00:30:27,200 --> 00:30:29,039
either over the text section or over the

899
00:30:29,039 --> 00:30:30,960
whole dll itself a thread is then

900
00:30:30,960 --> 00:30:33,039
created that is backed by the module

901
00:30:33,039 --> 00:30:35,360
so we can see in this example um for

902
00:30:35,360 --> 00:30:37,840
cobalt strike we're using like net shell

903
00:30:37,840 --> 00:30:40,240
as um as our stomp dll and then if we

904
00:30:40,240 --> 00:30:42,000
look in the call stack we can see uh

905
00:30:42,000 --> 00:30:45,600
like the thread coming from that shell

906
00:30:45,600 --> 00:30:46,799
so there's a few different like

907
00:30:46,799 --> 00:30:48,640
approaches for detecting module stomping

908
00:30:48,640 --> 00:30:50,880
we've got a few different options um so

909
00:30:50,880 --> 00:30:52,320
firstly the most simple one is probably

910
00:30:52,320 --> 00:30:54,480
comparing the copy of the module that's

911
00:30:54,480 --> 00:30:56,720
in memory with one that's on disk

912
00:30:56,720 --> 00:30:58,159
um

913
00:30:58,159 --> 00:30:59,440
and but i don't think this is

914
00:30:59,440 --> 00:31:00,960
particularly feasible to do at scale

915
00:31:00,960 --> 00:31:02,000
because

916
00:31:02,000 --> 00:31:03,600
it kind of means reading a copy of every

917
00:31:03,600 --> 00:31:05,360
single dll so it can be quite resource

918
00:31:05,360 --> 00:31:06,640
incentive

919
00:31:06,640 --> 00:31:08,799
um another option might be to look at

920
00:31:08,799 --> 00:31:10,240
the modified working set so as i

921
00:31:10,240 --> 00:31:11,760
mentioned before we look we basically

922
00:31:11,760 --> 00:31:13,360
hunt for these copy on right operations

923
00:31:13,360 --> 00:31:15,360
and we can tell tell that that dll has

924
00:31:15,360 --> 00:31:17,120
been modified because it doesn't have

925
00:31:17,120 --> 00:31:20,080
the um the shared bits up

926
00:31:20,080 --> 00:31:22,640
um or we can look for indicators that

927
00:31:22,640 --> 00:31:24,159
might actually be associated with that

928
00:31:24,159 --> 00:31:27,679
specific module stomping technique

929
00:31:27,679 --> 00:31:29,039
so if we look at how cobalt strike

930
00:31:29,039 --> 00:31:30,960
implements its module stomping and we'll

931
00:31:30,960 --> 00:31:32,640
find it does leave some dangling iocs

932
00:31:32,640 --> 00:31:34,880
within the peb

933
00:31:34,880 --> 00:31:36,159
so the way the cobalt strike module

934
00:31:36,159 --> 00:31:38,720
stomping works is

935
00:31:38,720 --> 00:31:39,919
it will

936
00:31:39,919 --> 00:31:42,480
effectively

937
00:31:42,480 --> 00:31:44,960
load a new dll with load library x and

938
00:31:44,960 --> 00:31:46,960
with these arguments so null and do not

939
00:31:46,960 --> 00:31:49,200
resolve dlr references um and that all

940
00:31:49,200 --> 00:31:51,039
that is doing is basically telling the

941
00:31:51,039 --> 00:31:53,600
loader um not to call the entry point

942
00:31:53,600 --> 00:31:55,919
and not to resolve any the import table

943
00:31:55,919 --> 00:31:58,000
for for the dll because we don't want to

944
00:31:58,000 --> 00:32:01,200
load all the dlls dependencies um

945
00:32:01,200 --> 00:32:03,120
so this ends up leaving like um some

946
00:32:03,120 --> 00:32:04,960
iocs in the peb as i kind of mentioned

947
00:32:04,960 --> 00:32:07,200
um so this is there's a structure which

948
00:32:07,200 --> 00:32:09,519
is this ldr data table entry structure

949
00:32:09,519 --> 00:32:11,120
and if we look at that what we'll see is

950
00:32:11,120 --> 00:32:13,440
the entry point attribute will be null

951
00:32:13,440 --> 00:32:15,279
um and the image bit will be set to

952
00:32:15,279 --> 00:32:16,960
false and that will basically is a good

953
00:32:16,960 --> 00:32:19,200
strong indicator that that module has

954
00:32:19,200 --> 00:32:20,799
been stomped using cobalt strikes and

955
00:32:20,799 --> 00:32:23,840
module stumping technique

956
00:32:23,840 --> 00:32:25,840
how about like um kind of moving away

957
00:32:25,840 --> 00:32:27,919
from the endpoint how about um like

958
00:32:27,919 --> 00:32:30,720
network level detections

959
00:32:30,720 --> 00:32:32,000
because if we're actually able to

960
00:32:32,000 --> 00:32:33,919
fingerprint the c2 server then that

961
00:32:33,919 --> 00:32:35,679
might give us sufficient intelligence to

962
00:32:35,679 --> 00:32:37,919
detect beaconing coming from the network

963
00:32:37,919 --> 00:32:39,200
um

964
00:32:39,200 --> 00:32:40,399
so some of the things that we might be

965
00:32:40,399 --> 00:32:42,640
interested in are you know any any kind

966
00:32:42,640 --> 00:32:44,320
of bugs that might be in the the c2

967
00:32:44,320 --> 00:32:46,399
server that might allow us to

968
00:32:46,399 --> 00:32:48,559
fingerprint it so foxit and fox it did

969
00:32:48,559 --> 00:32:50,000
some good research on this a couple

970
00:32:50,000 --> 00:32:51,039
years ago

971
00:32:51,039 --> 00:32:52,480
and they did a census and found a bunch

972
00:32:52,480 --> 00:32:54,240
of kerbal strike servers that were on

973
00:32:54,240 --> 00:32:55,919
the internet based on the response

974
00:32:55,919 --> 00:32:59,279
containing an extra space at the end

975
00:32:59,279 --> 00:33:01,679
um if we can hunt staging uris you know

976
00:33:01,679 --> 00:33:03,120
we can pull down the beacons as well

977
00:33:03,120 --> 00:33:04,320
because they're there in a predictable

978
00:33:04,320 --> 00:33:05,440
format

979
00:33:05,440 --> 00:33:06,960
um or otherwise you know any kind of

980
00:33:06,960 --> 00:33:08,399
like default content that might be

981
00:33:08,399 --> 00:33:09,600
exposed so things like the default

982
00:33:09,600 --> 00:33:11,440
landing page or default ssl certs that

983
00:33:11,440 --> 00:33:13,279
are exposed by the c2 servers we can use

984
00:33:13,279 --> 00:33:16,080
these to hunt for the c2 infrastructure

985
00:33:16,080 --> 00:33:18,320
so let's look at some examples

986
00:33:18,320 --> 00:33:21,120
so cobalt strike um sql strike is um

987
00:33:21,120 --> 00:33:24,080
based on nano httpd

988
00:33:24,080 --> 00:33:27,600
um and nano http is um basically an open

989
00:33:27,600 --> 00:33:30,320
source like java web server um i think

990
00:33:30,320 --> 00:33:31,600
like i think it's built by some

991
00:33:31,600 --> 00:33:33,200
university student

992
00:33:33,200 --> 00:33:34,480
um

993
00:33:34,480 --> 00:33:35,440
now

994
00:33:35,440 --> 00:33:37,600
one of the things that in the fox here

995
00:33:37,600 --> 00:33:39,919
fox city census and they basically

996
00:33:39,919 --> 00:33:41,679
showed that there's probably more cobalt

997
00:33:41,679 --> 00:33:43,279
strike servers on the internet than

998
00:33:43,279 --> 00:33:46,320
there were nano http servers

999
00:33:46,320 --> 00:33:47,440
um so if you do find one of these

1000
00:33:47,440 --> 00:33:48,399
there's probably a good chance it's

1001
00:33:48,399 --> 00:33:49,440
cobalt

1002
00:33:49,440 --> 00:33:50,720
um so let's look at some ways to kind of

1003
00:33:50,720 --> 00:33:52,240
fingerprint this so the first one is in

1004
00:33:52,240 --> 00:33:55,120
the range header and so if you send a

1005
00:33:55,120 --> 00:33:57,760
request with a range header um where

1006
00:33:57,760 --> 00:33:59,519
you've got bytes equals and then you've

1007
00:33:59,519 --> 00:34:02,480
got an invalid um integer as one of the

1008
00:34:02,480 --> 00:34:05,279
values um you get no response back from

1009
00:34:05,279 --> 00:34:06,720
the from the team server so you can use

1010
00:34:06,720 --> 00:34:08,159
this to kind of like fingerprint for

1011
00:34:08,159 --> 00:34:09,760
scan for cobalt strike right so i built

1012
00:34:09,760 --> 00:34:11,599
a nuclei template to scan the internet

1013
00:34:11,599 --> 00:34:13,119
for this this stuff

1014
00:34:13,119 --> 00:34:14,480
and now you might wonder like why do we

1015
00:34:14,480 --> 00:34:16,399
get no response um well if we look on

1016
00:34:16,399 --> 00:34:18,480
the um the team server the reason we get

1017
00:34:18,480 --> 00:34:20,159
no response is because we get an

1018
00:34:20,159 --> 00:34:22,000
unhandled exception in the team server

1019
00:34:22,000 --> 00:34:23,679
and it crashes the thread

1020
00:34:23,679 --> 00:34:25,040
um

1021
00:34:25,040 --> 00:34:26,480
so you get something printed like this

1022
00:34:26,480 --> 00:34:28,960
which basically says um you know invalid

1023
00:34:28,960 --> 00:34:30,639
like number format

1024
00:34:30,639 --> 00:34:32,560
um so if we want to dig deeper and see

1025
00:34:32,560 --> 00:34:34,159
what's going on here we can jump into

1026
00:34:34,159 --> 00:34:36,800
the source code um

1027
00:34:36,800 --> 00:34:38,560
and we can see basically what it's doing

1028
00:34:38,560 --> 00:34:40,560
when it's processing the range header

1029
00:34:40,560 --> 00:34:43,280
is it's trying to convert the string

1030
00:34:43,280 --> 00:34:45,040
read from from the header into an

1031
00:34:45,040 --> 00:34:46,719
integer and there's no exception

1032
00:34:46,719 --> 00:34:49,119
handling around this um so when you send

1033
00:34:49,119 --> 00:34:51,280
an invalid um

1034
00:34:51,280 --> 00:34:52,960
an invalid integer it ends up throwing

1035
00:34:52,960 --> 00:34:56,000
this unhandled exception

1036
00:34:56,560 --> 00:34:58,560
um other ways we can fingerprint code

1037
00:34:58,560 --> 00:35:02,240
strike again with the range header so um

1038
00:35:02,240 --> 00:35:04,400
this is this this ioc is shared with

1039
00:35:04,400 --> 00:35:05,920
nano httpd

1040
00:35:05,920 --> 00:35:07,599
um but we can figure out whether it's

1041
00:35:07,599 --> 00:35:10,000
cobalt strike or nano httpd

1042
00:35:10,000 --> 00:35:12,560
um based on the server header because if

1043
00:35:12,560 --> 00:35:14,320
you don't expect ies and apache to

1044
00:35:14,320 --> 00:35:15,359
behave like this we're turning these

1045
00:35:15,359 --> 00:35:17,599
responses so basically if you send a

1046
00:35:17,599 --> 00:35:18,640
range

1047
00:35:18,640 --> 00:35:21,200
um like back from byte one to zero if

1048
00:35:21,200 --> 00:35:22,720
you're asking for the content in byte

1049
00:35:22,720 --> 00:35:24,400
one to zero that's a range that the

1050
00:35:24,400 --> 00:35:27,280
server can't um facilitate so it ends up

1051
00:35:27,280 --> 00:35:28,720
providing this

1052
00:35:28,720 --> 00:35:31,520
fixed response of range not satisfied

1053
00:35:31,520 --> 00:35:33,040
and so again we can scan the internet

1054
00:35:33,040 --> 00:35:34,640
for these and use it to plug out cobalt

1055
00:35:34,640 --> 00:35:37,279
strike servers

1056
00:35:37,440 --> 00:35:39,359
another fingerprint within the um the

1057
00:35:39,359 --> 00:35:42,400
kerbal strike team server is um

1058
00:35:42,400 --> 00:35:44,880
is when we send an invalid byte

1059
00:35:44,880 --> 00:35:47,040
um so what i spotted this in the source

1060
00:35:47,040 --> 00:35:49,359
code and we get this like fixed response

1061
00:35:49,359 --> 00:35:52,000
um so if you send um an invalid url

1062
00:35:52,000 --> 00:35:55,040
encoded and by so percent zero like

1063
00:35:55,040 --> 00:35:56,400
obviously it needs to be two bytes for

1064
00:35:56,400 --> 00:35:59,119
it to be to be available um we end up

1065
00:35:59,119 --> 00:36:02,560
getting a fixed response back um which

1066
00:36:02,560 --> 00:36:04,960
is this uh bad percent encoding so again

1067
00:36:04,960 --> 00:36:07,200
we can use this just to scan to scan for

1068
00:36:07,200 --> 00:36:09,200
cable stripe

1069
00:36:09,200 --> 00:36:10,079
um

1070
00:36:10,079 --> 00:36:13,520
how about brute retell um so we can

1071
00:36:13,520 --> 00:36:16,480
fingerprint the brutal c2 server um so

1072
00:36:16,480 --> 00:36:18,640
if you send a post request um with some

1073
00:36:18,640 --> 00:36:22,480
base64 and valid base64 but the base64

1074
00:36:22,480 --> 00:36:24,800
does not um

1075
00:36:24,800 --> 00:36:27,200
unpack to the c2 traffic um again that

1076
00:36:27,200 --> 00:36:29,520
triggles triggers um a unhandled

1077
00:36:29,520 --> 00:36:30,960
exception and you get no response back

1078
00:36:30,960 --> 00:36:32,640
from the from the team server so again

1079
00:36:32,640 --> 00:36:35,680
we can use this to um to scan for retail

1080
00:36:35,680 --> 00:36:37,359
servers

1081
00:36:37,359 --> 00:36:38,640
now i'm pretty confident people are

1082
00:36:38,640 --> 00:36:40,000
scanning for group retail servers

1083
00:36:40,000 --> 00:36:41,119
because

1084
00:36:41,119 --> 00:36:42,880
i had got a brute retail server um

1085
00:36:42,880 --> 00:36:45,280
sitting in aws and then i wasn't

1086
00:36:45,280 --> 00:36:47,440
actually using it at the time but i got

1087
00:36:47,440 --> 00:36:51,040
a takedown notice from um from amazon

1088
00:36:51,040 --> 00:36:52,400
and at first i thought it was like one

1089
00:36:52,400 --> 00:36:53,920
of our red team gigs and you know

1090
00:36:53,920 --> 00:36:55,760
someone had been busted um and then when

1091
00:36:55,760 --> 00:36:57,680
i took a look at the instance id it was

1092
00:36:57,680 --> 00:36:59,599
basically the test but retail instance

1093
00:36:59,599 --> 00:37:01,359
that we got so i think you know some

1094
00:37:01,359 --> 00:37:03,119
internet hero is like scanning the

1095
00:37:03,119 --> 00:37:04,480
internet and reporting all the retail

1096
00:37:04,480 --> 00:37:06,640
instances

1097
00:37:06,640 --> 00:37:08,240
now these are pretty trivial to pick up

1098
00:37:08,240 --> 00:37:10,240
with um like showdown so if the default

1099
00:37:10,240 --> 00:37:12,640
landing page is exposed um we can

1100
00:37:12,640 --> 00:37:14,400
basically just take the hash for it pump

1101
00:37:14,400 --> 00:37:16,400
it into showdown uh and find out where

1102
00:37:16,400 --> 00:37:17,920
some of these are

1103
00:37:17,920 --> 00:37:19,680
and we can see you know

1104
00:37:19,680 --> 00:37:21,119
there's a few of them out there like the

1105
00:37:21,119 --> 00:37:22,640
majority of them seem to be in the u.s

1106
00:37:22,640 --> 00:37:24,400
there's a couple in russia i don't know

1107
00:37:24,400 --> 00:37:25,680
what they might be

1108
00:37:25,680 --> 00:37:27,280
um

1109
00:37:27,280 --> 00:37:28,880
and then i saw this tweet from this guy

1110
00:37:28,880 --> 00:37:30,720
and was basically saying you know

1111
00:37:30,720 --> 00:37:32,560
russians obviously you know they don't

1112
00:37:32,560 --> 00:37:34,880
discriminate against any specific c2

1113
00:37:34,880 --> 00:37:36,960
they like to host both cobalt strike

1114
00:37:36,960 --> 00:37:40,000
amber at retail on their infrastructure

1115
00:37:40,000 --> 00:37:42,640
um so once we found uh once we found one

1116
00:37:42,640 --> 00:37:44,800
of these um we found a badger you know

1117
00:37:44,800 --> 00:37:46,640
what can we do with it um so as i kind

1118
00:37:46,640 --> 00:37:48,000
of mentioned before

1119
00:37:48,000 --> 00:37:51,280
we built a little tool to um

1120
00:37:51,280 --> 00:37:54,240
scan artifacts um so dlls xes that i've

1121
00:37:54,240 --> 00:37:55,839
got brute telling them and extract all

1122
00:37:55,839 --> 00:37:57,680
the configuration information um so we

1123
00:37:57,680 --> 00:37:59,280
can get the c2 uris we can get the

1124
00:37:59,280 --> 00:38:02,000
secrets for the the team server

1125
00:38:02,000 --> 00:38:04,880
that kind of stuff um we can also scan

1126
00:38:04,880 --> 00:38:06,079
these in memory so you can see i'm just

1127
00:38:06,079 --> 00:38:08,160
giving a pid here uh and basically it's

1128
00:38:08,160 --> 00:38:09,200
like

1129
00:38:09,200 --> 00:38:11,359
like looking for the the badges config

1130
00:38:11,359 --> 00:38:12,880
structure in memory and then when it

1131
00:38:12,880 --> 00:38:14,640
finds it just prints it out so we can we

1132
00:38:14,640 --> 00:38:16,480
can actually extract all these from any

1133
00:38:16,480 --> 00:38:19,760
kind of processes too

1134
00:38:19,760 --> 00:38:20,960
so i guess you know we put all this

1135
00:38:20,960 --> 00:38:22,640
together like what can we do with it

1136
00:38:22,640 --> 00:38:23,920
like what was the point of all this

1137
00:38:23,920 --> 00:38:27,599
research um well what i did was um i

1138
00:38:27,599 --> 00:38:30,240
basically used it to to build a tool and

1139
00:38:30,240 --> 00:38:32,560
i called beacon hunter

1140
00:38:32,560 --> 00:38:34,000
which i'm going to open source there's

1141
00:38:34,000 --> 00:38:35,359
also like a whole bunch of blog posts

1142
00:38:35,359 --> 00:38:36,640
then we've got like four or five blog

1143
00:38:36,640 --> 00:38:39,440
posts we did look at like other c2s um

1144
00:38:39,440 --> 00:38:40,480
but like when i was putting this

1145
00:38:40,480 --> 00:38:42,079
together for the presentation i just had

1146
00:38:42,079 --> 00:38:43,920
way too much material so i just picked

1147
00:38:43,920 --> 00:38:45,119
the two that were probably the most

1148
00:38:45,119 --> 00:38:47,520
popular um

1149
00:38:47,520 --> 00:38:48,800
but some of the things that the beacon

1150
00:38:48,800 --> 00:38:50,720
hunter will currently do

1151
00:38:50,720 --> 00:38:53,359
is it will look for things like um it

1152
00:38:53,359 --> 00:38:54,880
will analyze call stacks it will look

1153
00:38:54,880 --> 00:38:57,040
for um beacons that are running in a map

1154
00:38:57,040 --> 00:38:58,960
memory and look for suspicious start

1155
00:38:58,960 --> 00:39:01,760
addresses it will um look for suspicious

1156
00:39:01,760 --> 00:39:04,560
execute pages um it will detect cobalt

1157
00:39:04,560 --> 00:39:06,560
strikes module stomping it will detect

1158
00:39:06,560 --> 00:39:07,920
in-memory hooks even if they've been

1159
00:39:07,920 --> 00:39:09,839
reverted that kind of stuff

1160
00:39:09,839 --> 00:39:13,200
so let me give you a quick demo of this

1161
00:39:13,200 --> 00:39:16,560
um now i have cheated and i have

1162
00:39:16,560 --> 00:39:20,560
recorded the demo so it cannot go wrong

1163
00:39:20,560 --> 00:39:22,560
i've given talks before so you know this

1164
00:39:22,560 --> 00:39:25,599
is the the safest way to operate

1165
00:39:25,599 --> 00:39:27,440
um okay

1166
00:39:27,440 --> 00:39:29,839
so

1167
00:39:30,240 --> 00:39:31,200
we're going to start off with brute

1168
00:39:31,200 --> 00:39:33,598
retell

1169
00:39:33,839 --> 00:39:35,920
so basically i've got brute retell here

1170
00:39:35,920 --> 00:39:38,560
i've injected it into notepad and what

1171
00:39:38,560 --> 00:39:41,119
we're going to take a look at is now you

1172
00:39:41,119 --> 00:39:42,480
might not have seen that but the start

1173
00:39:42,480 --> 00:39:44,880
address of this this thread this uh

1174
00:39:44,880 --> 00:39:46,800
thread is it was null

1175
00:39:46,800 --> 00:39:48,000
and if we took a look at the call stack

1176
00:39:48,000 --> 00:39:49,680
for it we can see it's got our way for

1177
00:39:49,680 --> 00:39:51,680
single object and so it's just a thread

1178
00:39:51,680 --> 00:39:54,400
that's delaying execution

1179
00:39:54,400 --> 00:39:57,400
um

1180
00:39:57,599 --> 00:39:58,720
and then

1181
00:39:58,720 --> 00:40:01,920
if we take a look at the next thread

1182
00:40:01,920 --> 00:40:03,599
uh what we can do

1183
00:40:03,599 --> 00:40:05,040
i'm just gonna pause that we can tell

1184
00:40:05,040 --> 00:40:06,560
this is brutal and i might not

1185
00:40:06,560 --> 00:40:07,839
necessarily be clear but the start

1186
00:40:07,839 --> 00:40:10,560
address of this one is um tp release

1187
00:40:10,560 --> 00:40:13,520
cleanup group members plus um 550x

1188
00:40:13,520 --> 00:40:14,720
whereas all the other ones you can see

1189
00:40:14,720 --> 00:40:17,119
are 450 hex so that one's 550x so we

1190
00:40:17,119 --> 00:40:18,400
know immediately that that one's brick

1191
00:40:18,400 --> 00:40:20,160
retail

1192
00:40:20,160 --> 00:40:21,280
and then if we took a look at the call

1193
00:40:21,280 --> 00:40:23,359
stack for it and we can see as i kind of

1194
00:40:23,359 --> 00:40:26,160
mentioned before we've got the um

1195
00:40:26,160 --> 00:40:27,839
the calls to delay execution and then at

1196
00:40:27,839 --> 00:40:30,240
the end we've got the the rop gadget for

1197
00:40:30,240 --> 00:40:32,800
nt tesla to execute the apcs that are

1198
00:40:32,800 --> 00:40:35,599
queued on the thread

1199
00:40:36,079 --> 00:40:37,920
now what i'm going to do is i'm just

1200
00:40:37,920 --> 00:40:39,119
going to run

1201
00:40:39,119 --> 00:40:41,680
beacon hunter over this pid

1202
00:40:41,680 --> 00:40:43,599
so i'm just going to pause this um so

1203
00:40:43,599 --> 00:40:46,640
what we're doing is i'm telling it to um

1204
00:40:46,640 --> 00:40:48,480
it supports filters so you can say you

1205
00:40:48,480 --> 00:40:50,240
know scan 4 processors that i've got win

1206
00:40:50,240 --> 00:40:52,800
http.dll loaded and i'm giving it a pid

1207
00:40:52,800 --> 00:40:54,880
just so i don't have to scan all of them

1208
00:40:54,880 --> 00:40:57,839
and i'm basically saying um so m is for

1209
00:40:57,839 --> 00:41:02,480
memory t is for threads um h

1210
00:41:02,480 --> 00:41:04,400
i can't remember p is for page

1211
00:41:04,400 --> 00:41:06,240
permissions

1212
00:41:06,240 --> 00:41:08,400
um so i'm just going to scan

1213
00:41:08,400 --> 00:41:10,720
this brute retail process i'm just going

1214
00:41:10,720 --> 00:41:13,119
to pause i think i highlight them um so

1215
00:41:13,119 --> 00:41:15,359
some of the stuff that we pick up um or

1216
00:41:15,359 --> 00:41:16,880
the beacon hunter picks up is we've got

1217
00:41:16,880 --> 00:41:19,599
the suspicious start address and then it

1218
00:41:19,599 --> 00:41:21,599
tells us that it's brute retell

1219
00:41:21,599 --> 00:41:23,119
because we know it's brute retell

1220
00:41:23,119 --> 00:41:24,480
because brutal tell's the only thing

1221
00:41:24,480 --> 00:41:26,400
that has that that fixed start address

1222
00:41:26,400 --> 00:41:27,920
so we found both of the brute retail

1223
00:41:27,920 --> 00:41:32,839
threads um so thread id 102 36 thread od

1224
00:41:32,839 --> 00:41:35,760
2900 uh and uh we know that with that

1225
00:41:35,760 --> 00:41:37,040
one is group retail as well and we can

1226
00:41:37,040 --> 00:41:38,319
see that they're delaying execution

1227
00:41:38,319 --> 00:41:39,520
because we've got the call to wait for

1228
00:41:39,520 --> 00:41:42,000
single object

1229
00:41:42,000 --> 00:41:44,000
um so that's the

1230
00:41:44,000 --> 00:41:47,400
first one

1231
00:41:48,960 --> 00:41:50,079
i'm gonna have to speed up because he's

1232
00:41:50,079 --> 00:41:52,720
telling me well i've got five minutes

1233
00:41:52,720 --> 00:41:56,319
um what i'm going to do next is um

1234
00:41:56,319 --> 00:41:57,680
to show you how we can detect the memory

1235
00:41:57,680 --> 00:42:00,160
hooks um so what i'll do is i'm just

1236
00:42:00,160 --> 00:42:03,119
going to run shop in line in boot retell

1237
00:42:03,119 --> 00:42:04,720
and just run any old assembly i think i

1238
00:42:04,720 --> 00:42:07,279
run seat belt

1239
00:42:10,000 --> 00:42:11,440
now if you remember when i was talking i

1240
00:42:11,440 --> 00:42:13,839
said that um the in the shop in line

1241
00:42:13,839 --> 00:42:15,280
command basically does leave these

1242
00:42:15,280 --> 00:42:18,079
dangling ircs so it patches um etw and

1243
00:42:18,079 --> 00:42:19,440
it patches amazing scan buffer and it

1244
00:42:19,440 --> 00:42:21,599
leaves them sitting in memory

1245
00:42:21,599 --> 00:42:23,760
so we're going to run seat belt

1246
00:42:23,760 --> 00:42:24,880
and then

1247
00:42:24,880 --> 00:42:30,200
if we run beacon hunter over the process

1248
00:42:35,680 --> 00:42:38,000
so same thing again same process

1249
00:42:38,000 --> 00:42:40,800
um but what we get this time is

1250
00:42:40,800 --> 00:42:42,880
um it actually tells us

1251
00:42:42,880 --> 00:42:44,640
that um

1252
00:42:44,640 --> 00:42:45,839
there's a bunch of hooks that have been

1253
00:42:45,839 --> 00:42:47,119
applied now this is not looking for the

1254
00:42:47,119 --> 00:42:48,480
op codes on the hooks it's basically

1255
00:42:48,480 --> 00:42:51,599
doing it by um looking if the shared bit

1256
00:42:51,599 --> 00:42:54,000
has been cleared on those pages and then

1257
00:42:54,000 --> 00:42:55,440
it resolves all the exports in those

1258
00:42:55,440 --> 00:42:57,839
pages so we don't know exactly which

1259
00:42:57,839 --> 00:42:59,359
function has been hooked but all the

1260
00:42:59,359 --> 00:43:01,280
exports that are on that page might have

1261
00:43:01,280 --> 00:43:03,440
been so we can see it's probably ecw

1262
00:43:03,440 --> 00:43:05,119
event right and we can see here on this

1263
00:43:05,119 --> 00:43:07,359
page that it's probably the um the

1264
00:43:07,359 --> 00:43:09,119
amazing scan buffer

1265
00:43:09,119 --> 00:43:11,359
um so again that gives us a good way to

1266
00:43:11,359 --> 00:43:14,720
detect these hooks in memory

1267
00:43:21,920 --> 00:43:23,760
the next one i'm going to do is um is

1268
00:43:23,760 --> 00:43:27,079
cobalt strike

1269
00:43:32,880 --> 00:43:34,800
so i've got a couple of beacons here um

1270
00:43:34,800 --> 00:43:36,720
both injected into notepad and one of

1271
00:43:36,720 --> 00:43:38,319
them is using module stumping and one of

1272
00:43:38,319 --> 00:43:41,839
them is running from virtual memory

1273
00:43:42,640 --> 00:43:43,680
so i think i'll look at the virtual

1274
00:43:43,680 --> 00:43:46,640
memory one first

1275
00:43:48,079 --> 00:43:50,960
let's find the pid

1276
00:43:53,040 --> 00:43:54,400
so if we took a look at this one here

1277
00:43:54,400 --> 00:43:55,920
just pause it for a second

1278
00:43:55,920 --> 00:43:57,119
um

1279
00:43:57,119 --> 00:43:59,359
we can see that the um basically in this

1280
00:43:59,359 --> 00:44:00,960
thread we've got a call in the stack of

1281
00:44:00,960 --> 00:44:02,160
the thread we've got a call from virtual

1282
00:44:02,160 --> 00:44:03,760
memory and we can see it's calling sleep

1283
00:44:03,760 --> 00:44:05,760
x and then nt delay execution so we know

1284
00:44:05,760 --> 00:44:08,319
that is um a pretty good candidate for

1285
00:44:08,319 --> 00:44:11,200
being a sleeping beacon

1286
00:44:13,119 --> 00:44:15,200
so i'll just run our beacon hunter over

1287
00:44:15,200 --> 00:44:18,680
this one as well

1288
00:44:24,480 --> 00:44:26,319
i did mess up here i gave it the i tried

1289
00:44:26,319 --> 00:44:28,160
to cut it out but i gave it the wrong

1290
00:44:28,160 --> 00:44:30,960
piece initially um so if we scan it with

1291
00:44:30,960 --> 00:44:32,960
um beacon hunter we can see some of the

1292
00:44:32,960 --> 00:44:34,480
stuff that's picked up um so it's picked

1293
00:44:34,480 --> 00:44:36,000
up the sleeping beacon it's telling me

1294
00:44:36,000 --> 00:44:38,000
it's got calls to um sleep x and

1295
00:44:38,000 --> 00:44:40,480
anti-delay execution in the stack um

1296
00:44:40,480 --> 00:44:42,800
it's basically telling me uh that it's

1297
00:44:42,800 --> 00:44:45,359
running from unmapped and unmapped image

1298
00:44:45,359 --> 00:44:46,480
um

1299
00:44:46,480 --> 00:44:48,000
and we can see the suspicious looking

1300
00:44:48,000 --> 00:44:51,839
like start address of null

1301
00:44:53,599 --> 00:44:56,720
so again those are pretty good um iocs

1302
00:44:56,720 --> 00:44:57,440
to

1303
00:44:57,440 --> 00:44:58,880
to flag that something suspicious is

1304
00:44:58,880 --> 00:45:01,839
going on in this process

1305
00:45:02,640 --> 00:45:04,480
the next one we're going to look at is

1306
00:45:04,480 --> 00:45:06,960
uh the module stomped one um so just to

1307
00:45:06,960 --> 00:45:09,839
prove it's module stumping um we will

1308
00:45:09,839 --> 00:45:10,960
have a look at the call stack for this

1309
00:45:10,960 --> 00:45:13,359
one and you can see we're stomping from

1310
00:45:13,359 --> 00:45:15,119
uh ww

1311
00:45:15,119 --> 00:45:17,119
i know whatever that deal i was

1312
00:45:17,119 --> 00:45:18,480
uh and then i'm just going to run beacon

1313
00:45:18,480 --> 00:45:20,800
hunter over it again

1314
00:45:20,800 --> 00:45:22,480
and what we should see

1315
00:45:22,480 --> 00:45:24,400
is um it picks up the same stuff with

1316
00:45:24,400 --> 00:45:26,079
the threads but um like down here you

1317
00:45:26,079 --> 00:45:27,599
can see it basically says checking for

1318
00:45:27,599 --> 00:45:29,280
module stomping and it says found stomp

1319
00:45:29,280 --> 00:45:31,680
dll and that is um it's able to detect

1320
00:45:31,680 --> 00:45:33,200
cobalt strikes and module stomping

1321
00:45:33,200 --> 00:45:36,319
functionality basically down to um the

1322
00:45:36,319 --> 00:45:38,000
specific dll that's been stomped because

1323
00:45:38,000 --> 00:45:39,599
of those dangling iocs that get left in

1324
00:45:39,599 --> 00:45:41,920
the pub

1325
00:45:42,079 --> 00:45:46,040
cool all right

1326
00:45:46,880 --> 00:45:49,760
where's my mouse

1327
00:45:52,720 --> 00:45:54,319
okay not too much more

1328
00:45:54,319 --> 00:45:56,240
that that's pretty much it really um but

1329
00:45:56,240 --> 00:45:58,880
just a quick thank you to um

1330
00:45:58,880 --> 00:46:00,480
some of the other guys from dc

1331
00:46:00,480 --> 00:46:02,400
um particularly peter who gave me lots

1332
00:46:02,400 --> 00:46:03,920
of advice when like doing some of this

1333
00:46:03,920 --> 00:46:05,760
stuff give me some example code and

1334
00:46:05,760 --> 00:46:09,119
things to look at um and also uh mod exp

1335
00:46:09,119 --> 00:46:10,400
uh who helped me with some of the

1336
00:46:10,400 --> 00:46:12,160
reversing the brit retell

1337
00:46:12,160 --> 00:46:13,680
there's a bunch of like really good uh

1338
00:46:13,680 --> 00:46:15,359
like references i'm here to different

1339
00:46:15,359 --> 00:46:18,560
techniques um both for detection and for

1340
00:46:18,560 --> 00:46:21,680
building um you know evasion strategies

1341
00:46:21,680 --> 00:46:23,359
um which i would kind of like recommend

1342
00:46:23,359 --> 00:46:26,680
going and reading

1343
00:46:29,680 --> 00:46:31,839
foreign

