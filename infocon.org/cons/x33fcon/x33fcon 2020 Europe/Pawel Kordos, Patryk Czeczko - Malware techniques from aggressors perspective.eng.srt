1
00:00:10,160 --> 00:00:14,000
welcome

2
00:00:10,719 --> 00:00:15,120
welcome everybody hello so hopefully you

3
00:00:14,000 --> 00:00:18,560
will enjoy this

4
00:00:15,120 --> 00:00:20,560
okay so we would like to talk about um

5
00:00:18,560 --> 00:00:22,080
malware development a quite an

6
00:00:20,560 --> 00:00:24,000
interesting topic we've been recently

7
00:00:22,080 --> 00:00:27,919
browsing with pavel

8
00:00:24,000 --> 00:00:31,679
so let us start with uh introduction

9
00:00:27,920 --> 00:00:35,200
can we change slides here

10
00:00:31,679 --> 00:00:37,680
okay so my name is patrick chesco

11
00:00:35,200 --> 00:00:39,280
i currently work at this purple team in

12
00:00:37,680 --> 00:00:41,360
standard chartered bank

13
00:00:39,280 --> 00:00:45,039
previously i work at deloitte at the red

14
00:00:41,360 --> 00:00:48,079
team deloitte together with pavel

15
00:00:45,039 --> 00:00:49,520
and yes that's my front story yeah my

16
00:00:48,079 --> 00:00:50,960
name is power cordless i work as a

17
00:00:49,520 --> 00:00:52,480
penetration tester in knd

18
00:00:50,960 --> 00:00:54,399
and previously we've been working with

19
00:00:52,480 --> 00:00:56,398
patrick in erecting deloitte i was

20
00:00:54,399 --> 00:00:58,079
planting a consultant here

21
00:00:56,399 --> 00:00:59,600
we've done a couple of interesting

22
00:00:58,079 --> 00:01:00,399
engagements we've gained some knowledge

23
00:00:59,600 --> 00:01:03,359
and we'd like to

24
00:01:00,399 --> 00:01:03,359
share it with you today

25
00:01:05,920 --> 00:01:10,960
yes that's it so uh about this

26
00:01:09,119 --> 00:01:13,439
presentation uh

27
00:01:10,960 --> 00:01:14,320
we are going to focus on malicious code

28
00:01:13,439 --> 00:01:18,320
development

29
00:01:14,320 --> 00:01:21,279
and mainly on windows platforms because

30
00:01:18,320 --> 00:01:23,039
during retiming engagements we usually

31
00:01:21,280 --> 00:01:24,880
exploit post-exploit to windows

32
00:01:23,040 --> 00:01:25,680
environments active directory domain so

33
00:01:24,880 --> 00:01:28,880
that's

34
00:01:25,680 --> 00:01:30,640
our main area of interest and we are

35
00:01:28,880 --> 00:01:33,520
using cpus plus because it

36
00:01:30,640 --> 00:01:34,400
gives us a direct access to windows api

37
00:01:33,520 --> 00:01:36,399
since it's

38
00:01:34,400 --> 00:01:37,840
harder to reverse than for example

39
00:01:36,400 --> 00:01:39,920
powershell script or

40
00:01:37,840 --> 00:01:43,520
dotnet application so we're sticking

41
00:01:39,920 --> 00:01:46,799
with pure sequence plus for c

42
00:01:43,520 --> 00:01:49,520
we will talk about bypassing modern

43
00:01:46,799 --> 00:01:51,600
defenses like antiviruses cdrs or

44
00:01:49,520 --> 00:01:55,199
sandboxes virtualized

45
00:01:51,600 --> 00:01:58,640
environments but also

46
00:01:55,200 --> 00:02:01,600
some techniques to make um

47
00:01:58,640 --> 00:02:02,960
malware analysis harder to obfuscate

48
00:02:01,600 --> 00:02:06,960
code

49
00:02:02,960 --> 00:02:09,919
hinder debugging and also

50
00:02:06,960 --> 00:02:11,200
few words about hiding malicious code in

51
00:02:09,919 --> 00:02:14,319
legitimate apps

52
00:02:11,200 --> 00:02:17,599
so this includes both code injection and

53
00:02:14,319 --> 00:02:21,040
backdooring so pablo will turn more

54
00:02:17,599 --> 00:02:24,720
tell more about the bacters later

55
00:02:21,040 --> 00:02:28,160
so let me start with uh

56
00:02:24,720 --> 00:02:31,519
basic information on how

57
00:02:28,160 --> 00:02:34,840
detection mechanism mechanisms work now

58
00:02:31,519 --> 00:02:37,840
so we can say we have three types of

59
00:02:34,840 --> 00:02:40,879
detections first one is the basic

60
00:02:37,840 --> 00:02:44,959
signature base detection so files

61
00:02:40,879 --> 00:02:48,160
are analyzed for checksums

62
00:02:44,959 --> 00:02:50,400
for known strings

63
00:02:48,160 --> 00:02:51,440
characters inside the executable for

64
00:02:50,400 --> 00:02:54,640
example and

65
00:02:51,440 --> 00:02:55,599
known by sequences associated with some

66
00:02:54,640 --> 00:02:58,480
malicious

67
00:02:55,599 --> 00:03:00,000
op codes malicious uh assembly

68
00:02:58,480 --> 00:03:02,959
instructions for example

69
00:03:00,000 --> 00:03:04,159
then we have heuristic detection so it's

70
00:03:02,959 --> 00:03:07,200
basically an analysis

71
00:03:04,159 --> 00:03:08,879
of application behavior it can be um for

72
00:03:07,200 --> 00:03:12,799
example based on

73
00:03:08,879 --> 00:03:14,640
import table in windows executables so

74
00:03:12,800 --> 00:03:16,319
antivirus can analyze or analyze and

75
00:03:14,640 --> 00:03:19,279
analyze the

76
00:03:16,319 --> 00:03:20,238
file to understand what action is it

77
00:03:19,280 --> 00:03:23,120
going to perform

78
00:03:20,239 --> 00:03:25,040
on the system based on on functions in

79
00:03:23,120 --> 00:03:28,560
its importing from the system from

80
00:03:25,040 --> 00:03:32,159
windows dls for example and the third

81
00:03:28,560 --> 00:03:33,120
kind is sandboxing which is uh dynamic

82
00:03:32,159 --> 00:03:36,159
analysis

83
00:03:33,120 --> 00:03:38,319
when the sample is executed or as

84
00:03:36,159 --> 00:03:39,599
it's called detonated in the controlled

85
00:03:38,319 --> 00:03:43,280
environment

86
00:03:39,599 --> 00:03:46,798
and as the the the application

87
00:03:43,280 --> 00:03:50,319
is executed it's analyzed by by this

88
00:03:46,799 --> 00:03:53,519
for example the sandbox to see exactly

89
00:03:50,319 --> 00:03:55,599
what is it performing during runtime and

90
00:03:53,519 --> 00:03:57,360
actions are monitored to better

91
00:03:55,599 --> 00:04:00,959
understand this this

92
00:03:57,360 --> 00:04:03,519
malicious application

93
00:04:00,959 --> 00:04:05,360
so how are we going to fight those

94
00:04:03,519 --> 00:04:07,280
detections

95
00:04:05,360 --> 00:04:09,200
so for a signature-based detection we

96
00:04:07,280 --> 00:04:12,159
can

97
00:04:09,200 --> 00:04:13,200
simple thing to do is to recompile the

98
00:04:12,159 --> 00:04:15,359
executable

99
00:04:13,200 --> 00:04:16,880
that that's how we can get a different

100
00:04:15,360 --> 00:04:21,040
checksum each time so

101
00:04:16,880 --> 00:04:25,840
we will find this uh basic very basic uh

102
00:04:21,040 --> 00:04:29,520
ioc which is md5 for sha signature

103
00:04:25,840 --> 00:04:32,400
we can also do something more difficult

104
00:04:29,520 --> 00:04:34,639
and a little bit sophisticated which is

105
00:04:32,400 --> 00:04:34,960
polymorphism so it's basically the code

106
00:04:34,639 --> 00:04:38,479
that

107
00:04:34,960 --> 00:04:42,080
modifies itself and it actually it's

108
00:04:38,479 --> 00:04:44,240
maybe quite easy to to add some some

109
00:04:42,080 --> 00:04:45,758
garbage data to an executable every time

110
00:04:44,240 --> 00:04:49,520
it's run

111
00:04:45,759 --> 00:04:52,720
so the checksum is changed and

112
00:04:49,520 --> 00:04:54,799
resources encryption is valid or

113
00:04:52,720 --> 00:04:56,639
for signature-based detection and here

114
00:04:54,800 --> 00:04:59,759
heroes detection so

115
00:04:56,639 --> 00:05:03,840
it's commonly used in malware

116
00:04:59,759 --> 00:05:05,759
malicious code so any data stored in the

117
00:05:03,840 --> 00:05:07,758
executable like strings configurations

118
00:05:05,759 --> 00:05:09,919
and so it's executed and it's

119
00:05:07,759 --> 00:05:12,320
encrypted and it's only decrypted during

120
00:05:09,919 --> 00:05:15,520
runtime

121
00:05:12,320 --> 00:05:17,199
so for accuracy detection for combating

122
00:05:15,520 --> 00:05:21,440
those detections we can

123
00:05:17,199 --> 00:05:23,840
also implement some code obfuscation

124
00:05:21,440 --> 00:05:24,639
for example a low low-level virtual

125
00:05:23,840 --> 00:05:28,080
machine

126
00:05:24,639 --> 00:05:31,759
opposition or anything else that makes

127
00:05:28,080 --> 00:05:34,400
the code harder to analyze dynamic code

128
00:05:31,759 --> 00:05:34,400
which means

129
00:05:34,720 --> 00:05:41,680
like loading functions during runtime

130
00:05:38,400 --> 00:05:43,679
and maybe changing the the code using

131
00:05:41,680 --> 00:05:46,880
reflection on the shellcode level

132
00:05:43,680 --> 00:05:50,240
and for sandboxing we can use

133
00:05:46,880 --> 00:05:51,520
simple environment checks and if for

134
00:05:50,240 --> 00:05:56,160
example if the

135
00:05:51,520 --> 00:05:57,758
machine the sample is executed on is

136
00:05:56,160 --> 00:05:59,919
constrained with resources for example

137
00:05:57,759 --> 00:06:00,800
it has only one or two gigabytes of ram

138
00:05:59,919 --> 00:06:04,080
it's probably

139
00:06:00,800 --> 00:06:07,120
some sandbox and we can terminate our

140
00:06:04,080 --> 00:06:10,318
process here

141
00:06:07,120 --> 00:06:14,240
so starting with the basics

142
00:06:10,319 --> 00:06:14,240
we have like this

143
00:06:14,479 --> 00:06:18,400
malware primitive primitive which is a

144
00:06:16,240 --> 00:06:19,120
shell code and what is a circle check

145
00:06:18,400 --> 00:06:22,719
out this some

146
00:06:19,120 --> 00:06:26,400
kind of position independent code which

147
00:06:22,720 --> 00:06:28,560
for example may be injected

148
00:06:26,400 --> 00:06:31,039
during a binary exploitation of an

149
00:06:28,560 --> 00:06:34,240
application or injected

150
00:06:31,039 --> 00:06:38,159
in some process

151
00:06:34,240 --> 00:06:40,479
and it usually bootstraps itself to find

152
00:06:38,160 --> 00:06:42,560
specific memory structures and functions

153
00:06:40,479 --> 00:06:44,240
in memory and

154
00:06:42,560 --> 00:06:46,840
and use those functions for example to

155
00:06:44,240 --> 00:06:49,840
open a bind shell or river shell or

156
00:06:46,840 --> 00:06:51,840
anything

157
00:06:49,840 --> 00:06:52,880
the shellcode by design contains some

158
00:06:51,840 --> 00:06:56,400
clever features

159
00:06:52,880 --> 00:07:01,120
which we will discuss briefly and uh

160
00:06:56,400 --> 00:07:03,198
shellcodes are like ultimate

161
00:07:01,120 --> 00:07:04,639
reflective code because it can change

162
00:07:03,199 --> 00:07:06,880
itself very easily

163
00:07:04,639 --> 00:07:08,560
so that's why there are a lot of for

164
00:07:06,880 --> 00:07:12,319
example just those simple

165
00:07:08,560 --> 00:07:13,840
xor encryptors that that so-called the

166
00:07:12,319 --> 00:07:16,240
the crypts itself on the runtime and

167
00:07:13,840 --> 00:07:19,520
then executed so it's

168
00:07:16,240 --> 00:07:20,240
some anti-analysis mechanism implemented

169
00:07:19,520 --> 00:07:23,680
in shortcode

170
00:07:20,240 --> 00:07:27,039
usually so how

171
00:07:23,680 --> 00:07:29,840
windows shell code works

172
00:07:27,039 --> 00:07:31,280
first process environment block is

173
00:07:29,840 --> 00:07:33,758
located memory

174
00:07:31,280 --> 00:07:34,638
it's it's quite easy to locate it then

175
00:07:33,759 --> 00:07:37,840
uh

176
00:07:34,639 --> 00:07:40,800
process modeling block has the links to

177
00:07:37,840 --> 00:07:41,599
loader data which has information about

178
00:07:40,800 --> 00:07:45,280
loaded

179
00:07:41,599 --> 00:07:48,560
modules yes

180
00:07:45,280 --> 00:07:50,559
every application has those windows

181
00:07:48,560 --> 00:07:52,160
libraries loaded at runtime like kernel

182
00:07:50,560 --> 00:07:54,800
32 or dll

183
00:07:52,160 --> 00:07:56,080
and we can browse those libraries in

184
00:07:54,800 --> 00:07:59,120
memory to find the

185
00:07:56,080 --> 00:08:00,560
functions that we need and mainly these

186
00:07:59,120 --> 00:08:02,560
are get pros address

187
00:08:00,560 --> 00:08:04,000
and to get module handle and to load

188
00:08:02,560 --> 00:08:05,840
library and you

189
00:08:04,000 --> 00:08:07,440
we shall can use those specific

190
00:08:05,840 --> 00:08:11,599
functions to

191
00:08:07,440 --> 00:08:15,039
find any any other function for example

192
00:08:11,599 --> 00:08:16,479
load socket library and call functions

193
00:08:15,039 --> 00:08:18,550
to

194
00:08:16,479 --> 00:08:19,758
in this example create process and

195
00:08:18,550 --> 00:08:22,319
[Music]

196
00:08:19,759 --> 00:08:22,800
assign the standard input and output to

197
00:08:22,319 --> 00:08:25,199
create

198
00:08:22,800 --> 00:08:26,720
sockets so it's a basic very basic

199
00:08:25,199 --> 00:08:30,479
reverse shell

200
00:08:26,720 --> 00:08:30,479
for example generated by metasploit

201
00:08:30,560 --> 00:08:37,279
and and here is example of

202
00:08:34,320 --> 00:08:37,839
of basic injection for example when we

203
00:08:37,279 --> 00:08:41,360
implement

204
00:08:37,839 --> 00:08:43,440
some loader in cpus plus which

205
00:08:41,360 --> 00:08:45,760
injects our shell code wherever it is

206
00:08:43,440 --> 00:08:48,800
for example cobalt strike shell code or

207
00:08:45,760 --> 00:08:49,120
circle from any command and control tool

208
00:08:48,800 --> 00:08:53,120
or

209
00:08:49,120 --> 00:08:55,760
or whatever and the basic

210
00:08:53,120 --> 00:08:57,440
technique is to allocate virtual memory

211
00:08:55,760 --> 00:08:58,720
in the process and then create a new

212
00:08:57,440 --> 00:09:02,399
thread

213
00:08:58,720 --> 00:09:04,000
and note a few things here that

214
00:09:02,399 --> 00:09:05,600
when data execution prevention is

215
00:09:04,000 --> 00:09:09,839
enabled which

216
00:09:05,600 --> 00:09:09,839
is common nowadays we need to

217
00:09:10,080 --> 00:09:13,680
give a proper permissions to the memory

218
00:09:12,240 --> 00:09:18,800
so this is second

219
00:09:13,680 --> 00:09:20,399
uh second code snippet like casting

220
00:09:18,800 --> 00:09:22,640
shell code to function pointer and

221
00:09:20,399 --> 00:09:23,120
executing it won't work because we need

222
00:09:22,640 --> 00:09:25,199
to

223
00:09:23,120 --> 00:09:26,320
have memory with a read write

224
00:09:25,200 --> 00:09:29,360
permissions

225
00:09:26,320 --> 00:09:32,480
as you can see on the second line code

226
00:09:29,360 --> 00:09:36,000
so it's a very rudimentary technique of

227
00:09:32,480 --> 00:09:39,680
injection but sometimes it's

228
00:09:36,000 --> 00:09:42,640
used okay so we have this

229
00:09:39,680 --> 00:09:44,560
basic proof of concept which injects our

230
00:09:42,640 --> 00:09:48,399
metasploit check out in the process

231
00:09:44,560 --> 00:09:51,119
let's test it against bios total so uh

232
00:09:48,399 --> 00:09:51,519
after uploading the raw shell code we

233
00:09:51,120 --> 00:09:54,640
can

234
00:09:51,519 --> 00:09:57,920
we get such detection like

235
00:09:54,640 --> 00:10:01,199
23 or 50. and

236
00:09:57,920 --> 00:10:04,010
this injector compiled in c application

237
00:10:01,200 --> 00:10:05,360
is also pretty much detected by by

238
00:10:04,010 --> 00:10:09,040
[Music]

239
00:10:05,360 --> 00:10:09,760
antiviruses and we can implement some

240
00:10:09,040 --> 00:10:12,640
very

241
00:10:09,760 --> 00:10:12,640
basic uh

242
00:10:13,200 --> 00:10:19,120
things here to to hinder the analysis

243
00:10:17,360 --> 00:10:21,760
and why you started to

244
00:10:19,120 --> 00:10:22,640
obfuscate the code a little bit so first

245
00:10:21,760 --> 00:10:26,079
thing is

246
00:10:22,640 --> 00:10:28,399
extraordinary encryption very simple we

247
00:10:26,079 --> 00:10:29,920
just accelerated every byte with some

248
00:10:28,399 --> 00:10:33,600
value

249
00:10:29,920 --> 00:10:37,439
uh then we great thing

250
00:10:33,600 --> 00:10:41,120
to do is to create some uh fake

251
00:10:37,440 --> 00:10:44,000
well just some software certificate

252
00:10:41,120 --> 00:10:44,720
uh and use it to sign we don't need to

253
00:10:44,000 --> 00:10:47,760
be in

254
00:10:44,720 --> 00:10:51,839
any certificate path just

255
00:10:47,760 --> 00:10:54,399
any code signing certificate we will do

256
00:10:51,839 --> 00:10:54,880
here and we can drop the detection rate

257
00:10:54,399 --> 00:10:58,240
use

258
00:10:54,880 --> 00:11:01,360
when the executable is signed

259
00:10:58,240 --> 00:11:04,720
and uh other thing

260
00:11:01,360 --> 00:11:07,680
is to switch to x64 architecture and uh

261
00:11:04,720 --> 00:11:08,320
using those three basic very basic uh

262
00:11:07,680 --> 00:11:10,800
techniques

263
00:11:08,320 --> 00:11:12,240
sewing extra encryption code science

264
00:11:10,800 --> 00:11:15,920
certificate and

265
00:11:12,240 --> 00:11:18,399
um x 64-bit architecture allowed us to

266
00:11:15,920 --> 00:11:19,279
drop the detection rate to only three

267
00:11:18,399 --> 00:11:23,839
from

268
00:11:19,279 --> 00:11:23,839
20 something that was before

269
00:11:27,200 --> 00:11:30,800
yeah all right and i now would like to

270
00:11:28,880 --> 00:11:33,760
focus more about the anti-vm

271
00:11:30,800 --> 00:11:34,719
uh solutions because the uh two main

272
00:11:33,760 --> 00:11:36,959
threats which we

273
00:11:34,720 --> 00:11:38,079
will be actually finding uh in our

274
00:11:36,959 --> 00:11:39,839
development is

275
00:11:38,079 --> 00:11:41,680
first this is antivirus solution but

276
00:11:39,839 --> 00:11:42,640
probably would like not to get catched

277
00:11:41,680 --> 00:11:45,680
so easy

278
00:11:42,640 --> 00:11:47,519
so he also has to face malware analysts

279
00:11:45,680 --> 00:11:49,040
which probably will receive all malware

280
00:11:47,519 --> 00:11:52,480
for further analysts

281
00:11:49,040 --> 00:11:54,719
and we'd like also to make some security

282
00:11:52,480 --> 00:11:58,079
measures against them

283
00:11:54,720 --> 00:11:58,399
so uh with the first step both sandboxes

284
00:11:58,079 --> 00:12:00,959
and

285
00:11:58,399 --> 00:12:01,839
analysts virtualizers os usually can't

286
00:12:00,959 --> 00:12:04,719
100

287
00:12:01,839 --> 00:12:05,360
emulate the actual execution machine

288
00:12:04,720 --> 00:12:07,200
like a

289
00:12:05,360 --> 00:12:08,399
workstation and they usually are

290
00:12:07,200 --> 00:12:11,279
simplified machines with

291
00:12:08,399 --> 00:12:12,560
limited resources and there are some

292
00:12:11,279 --> 00:12:15,120
other things which

293
00:12:12,560 --> 00:12:16,880
may be and our indicators to verify

294
00:12:15,120 --> 00:12:17,600
whether we are facing a virtual machine

295
00:12:16,880 --> 00:12:19,680
or

296
00:12:17,600 --> 00:12:21,040
a physical one like for example device

297
00:12:19,680 --> 00:12:24,079
name or some

298
00:12:21,040 --> 00:12:26,000
usb information also mac address of the

299
00:12:24,079 --> 00:12:28,719
network cards is useful here

300
00:12:26,000 --> 00:12:29,360
and let's go through a couple of these

301
00:12:28,720 --> 00:12:31,440
so

302
00:12:29,360 --> 00:12:32,880
as i told the first thing are the

303
00:12:31,440 --> 00:12:36,079
limited resources

304
00:12:32,880 --> 00:12:37,279
sandboxes may not be able to 100

305
00:12:36,079 --> 00:12:40,800
simulate

306
00:12:37,279 --> 00:12:42,720
the physical machine therefore we can

307
00:12:40,800 --> 00:12:44,319
simply check the number of processor

308
00:12:42,720 --> 00:12:47,120
cores on the system

309
00:12:44,320 --> 00:12:48,880
uh most maybe not know some of the av

310
00:12:47,120 --> 00:12:49,920
products cannot afford allocating too

311
00:12:48,880 --> 00:12:51,519
much resource

312
00:12:49,920 --> 00:12:53,040
from a host computer in order not to

313
00:12:51,519 --> 00:12:55,760
slow it down too much

314
00:12:53,040 --> 00:12:56,480
so we can first check uh how much core

315
00:12:55,760 --> 00:13:00,079
is on the

316
00:12:56,480 --> 00:13:02,639
on the machine we are currently running

317
00:13:00,079 --> 00:13:03,199
and if not if less than for example two

318
00:13:02,639 --> 00:13:06,480
we can

319
00:13:03,200 --> 00:13:09,120
uh shut the shutter shut our program

320
00:13:06,480 --> 00:13:10,320
second is uh check the amount of the of

321
00:13:09,120 --> 00:13:13,360
the memory system

322
00:13:10,320 --> 00:13:15,040
uh same story as before uh we

323
00:13:13,360 --> 00:13:17,360
send boxes cannot allocate too much

324
00:13:15,040 --> 00:13:18,639
memory and

325
00:13:17,360 --> 00:13:20,000
we can check how much memory is

326
00:13:18,639 --> 00:13:20,720
available on the on the production

327
00:13:20,000 --> 00:13:22,560
system

328
00:13:20,720 --> 00:13:24,079
in this particular example we are

329
00:13:22,560 --> 00:13:27,040
assuming that a

330
00:13:24,079 --> 00:13:27,760
minimum of two gigs of ram will be on on

331
00:13:27,040 --> 00:13:29,760
our target

332
00:13:27,760 --> 00:13:31,760
but we can modify that if we know that

333
00:13:29,760 --> 00:13:34,240
for example this company is using

334
00:13:31,760 --> 00:13:36,480
machines like a developer units with uh

335
00:13:34,240 --> 00:13:39,120
32 gigs we can increase that

336
00:13:36,480 --> 00:13:40,560
so if it's less our program will not run

337
00:13:39,120 --> 00:13:44,160
and i assume that

338
00:13:40,560 --> 00:13:46,560
none of the uh antivirus solution or the

339
00:13:44,160 --> 00:13:47,600
malware analyst will have such a big

340
00:13:46,560 --> 00:13:51,359
amount of memory

341
00:13:47,600 --> 00:13:54,399
shared with um with the virtual machine

342
00:13:51,360 --> 00:13:56,560
uh other things which we can do we can

343
00:13:54,399 --> 00:13:57,680
uh make a huge memory allocation this

344
00:13:56,560 --> 00:13:59,518
one is uh

345
00:13:57,680 --> 00:14:01,120
pretty much just like 10 gigs pretty

346
00:13:59,519 --> 00:14:02,480
probably too much because it may

347
00:14:01,120 --> 00:14:04,399
actually crash on a

348
00:14:02,480 --> 00:14:05,600
target machine but we can try to

349
00:14:04,399 --> 00:14:08,320
allocate uh i

350
00:14:05,600 --> 00:14:09,839
know around one gig of ram so antivirus

351
00:14:08,320 --> 00:14:12,240
probably would not be able to run

352
00:14:09,839 --> 00:14:13,920
uh to allocate that much of memory for

353
00:14:12,240 --> 00:14:15,279
obvious reasons so we can

354
00:14:13,920 --> 00:14:18,319
we can do that then we can free this

355
00:14:15,279 --> 00:14:20,800
memory and one interesting trick to

356
00:14:18,320 --> 00:14:21,839
to fool the machine is to try to load a

357
00:14:20,800 --> 00:14:24,880
library

358
00:14:21,839 --> 00:14:25,440
so uh loading library uh may be useful

359
00:14:24,880 --> 00:14:27,439
but

360
00:14:25,440 --> 00:14:28,639
try to log a library called for example

361
00:14:27,440 --> 00:14:31,040
fake dll

362
00:14:28,639 --> 00:14:32,079
and probably fake dll would not exist on

363
00:14:31,040 --> 00:14:34,560
our target machine

364
00:14:32,079 --> 00:14:35,599
and this is what we actually will uh

365
00:14:34,560 --> 00:14:37,839
will suspect

366
00:14:35,600 --> 00:14:39,199
and normally when we try to load an

367
00:14:37,839 --> 00:14:40,800
unexisting dll

368
00:14:39,199 --> 00:14:43,599
it probably the function should return

369
00:14:40,800 --> 00:14:45,359
no but some dynamic analysis mechanism

370
00:14:43,600 --> 00:14:45,920
in antivirus solutions allows such a

371
00:14:45,360 --> 00:14:47,680
cases

372
00:14:45,920 --> 00:14:49,199
in order to further investigate the

373
00:14:47,680 --> 00:14:51,199
execution of the

374
00:14:49,199 --> 00:14:54,479
of the flow so we can make use of that

375
00:14:51,199 --> 00:14:58,399
and try to load an existing

376
00:14:54,480 --> 00:15:00,240
dll the the next thing which

377
00:14:58,399 --> 00:15:02,160
patrick previously mentioned is a

378
00:15:00,240 --> 00:15:04,959
multi-threading so

379
00:15:02,160 --> 00:15:07,120
uh automated analysis in a is performed

380
00:15:04,959 --> 00:15:09,518
in a simplified sandbox environment

381
00:15:07,120 --> 00:15:11,279
and sometimes it may not be able to

382
00:15:09,519 --> 00:15:12,800
enumerate of the nuances of the real

383
00:15:11,279 --> 00:15:14,000
environment such as for example

384
00:15:12,800 --> 00:15:15,439
multi-threading

385
00:15:14,000 --> 00:15:17,600
and it's always harder to reverse

386
00:15:15,440 --> 00:15:20,800
engineer a multi-thro

387
00:15:17,600 --> 00:15:23,920
this file and it's also

388
00:15:20,800 --> 00:15:25,680
challenging for an av product so uh this

389
00:15:23,920 --> 00:15:26,719
multi-threading approach can be used

390
00:15:25,680 --> 00:15:29,839
with

391
00:15:26,720 --> 00:15:32,480
all of the other execution methods uh

392
00:15:29,839 --> 00:15:32,959
so uh we will just create a create a new

393
00:15:32,480 --> 00:15:36,959
thread

394
00:15:32,959 --> 00:15:39,758
with our shell code

395
00:15:36,959 --> 00:15:40,000
and i've mentioned before that virtual

396
00:15:39,759 --> 00:15:41,920
machine

397
00:15:40,000 --> 00:15:43,040
can be supported because they make use

398
00:15:41,920 --> 00:15:46,639
of

399
00:15:43,040 --> 00:15:48,639
similar computer names and uh

400
00:15:46,639 --> 00:15:50,160
such a thing like this so we can also

401
00:15:48,639 --> 00:15:52,480
check the computer name

402
00:15:50,160 --> 00:15:55,279
probably your workstation in a corporate

403
00:15:52,480 --> 00:15:58,800
environment would not be called admin or

404
00:15:55,279 --> 00:16:00,480
or a desktop this pattern actually

405
00:15:58,800 --> 00:16:02,880
differs from a for a different

406
00:16:00,480 --> 00:16:06,000
engagement if we have a knowledge

407
00:16:02,880 --> 00:16:08,399
of a target environment we can

408
00:16:06,000 --> 00:16:09,920
for example try if the computer actually

409
00:16:08,399 --> 00:16:13,519
matches our pattern

410
00:16:09,920 --> 00:16:16,399
but if not we can uh just just uh

411
00:16:13,519 --> 00:16:18,000
try to avoid machines like admin or

412
00:16:16,399 --> 00:16:20,399
desktop so if

413
00:16:18,000 --> 00:16:22,639
if it matches this pattern the old

414
00:16:20,399 --> 00:16:24,959
malware will simply not run

415
00:16:22,639 --> 00:16:26,959
and we can also check the the username

416
00:16:24,959 --> 00:16:29,839
because probably most of you

417
00:16:26,959 --> 00:16:31,518
do not work on a username an account

418
00:16:29,839 --> 00:16:34,959
with a username admin or

419
00:16:31,519 --> 00:16:36,880
a user and some of them

420
00:16:34,959 --> 00:16:39,439
some of the antivirus solutions they

421
00:16:36,880 --> 00:16:43,199
just simulate things like

422
00:16:39,440 --> 00:16:45,920
things like this so

423
00:16:43,199 --> 00:16:47,920
we can check that and since we will be

424
00:16:45,920 --> 00:16:49,599
targeting a corporate environment

425
00:16:47,920 --> 00:16:51,360
we can assume that the computer is

426
00:16:49,600 --> 00:16:53,360
actually a member of a domain

427
00:16:51,360 --> 00:16:54,800
so we can check the domain membership

428
00:16:53,360 --> 00:16:57,440
status and if

429
00:16:54,800 --> 00:16:59,279
the computer which runs the malware is

430
00:16:57,440 --> 00:17:01,199
not a member of the domain our mod will

431
00:16:59,279 --> 00:17:03,439
simply not run

432
00:17:01,199 --> 00:17:04,319
i assume that most of the malware

433
00:17:03,440 --> 00:17:07,760
analysis

434
00:17:04,319 --> 00:17:09,678
have the lab but for sure not always the

435
00:17:07,760 --> 00:17:10,799
they run our malware in a domain

436
00:17:09,679 --> 00:17:15,360
environment so

437
00:17:10,799 --> 00:17:19,439
we can also make use of that

438
00:17:15,359 --> 00:17:23,359
some of them environments

439
00:17:19,439 --> 00:17:25,199
which are used by both sandboxes and for

440
00:17:23,359 --> 00:17:27,359
malware analysis purposes they are

441
00:17:25,199 --> 00:17:27,760
usually a fresh windows installation or

442
00:17:27,359 --> 00:17:30,639
at least

443
00:17:27,760 --> 00:17:31,280
looks like a flash installation and they

444
00:17:30,640 --> 00:17:33,600
may like

445
00:17:31,280 --> 00:17:35,280
some artifacts that appear over a time

446
00:17:33,600 --> 00:17:37,918
on a typical workstation

447
00:17:35,280 --> 00:17:38,320
so uh one one of the good example in

448
00:17:37,919 --> 00:17:40,559
this

449
00:17:38,320 --> 00:17:42,000
is a number of usb storage devices

450
00:17:40,559 --> 00:17:44,320
mounted in the system

451
00:17:42,000 --> 00:17:45,679
which is stored in the registry so we

452
00:17:44,320 --> 00:17:47,678
can check if a user

453
00:17:45,679 --> 00:17:48,880
usb device has ever been mounted on the

454
00:17:47,679 --> 00:17:51,120
system

455
00:17:48,880 --> 00:17:52,400
and it it will probably give us some

456
00:17:51,120 --> 00:17:54,159
interesting knowledge whether this

457
00:17:52,400 --> 00:17:58,160
machine has actually been used in

458
00:17:54,160 --> 00:18:00,960
a in a reality or uh or not

459
00:17:58,160 --> 00:18:01,840
there are also some other artifacts uh

460
00:18:00,960 --> 00:18:03,679
which are

461
00:18:01,840 --> 00:18:05,600
uh typical for the virtual machine like

462
00:18:03,679 --> 00:18:09,840
for example we use roblox

463
00:18:05,600 --> 00:18:11,678
gas conditions or some registry entries

464
00:18:09,840 --> 00:18:13,360
and we probably would like to check that

465
00:18:11,679 --> 00:18:15,120
and verify whether we are facing a

466
00:18:13,360 --> 00:18:17,918
virtual machine or a

467
00:18:15,120 --> 00:18:19,600
or a physical physical device so on a

468
00:18:17,919 --> 00:18:22,720
physical device you probably

469
00:18:19,600 --> 00:18:22,719
will not have a

470
00:18:23,760 --> 00:18:27,440
regular virtual box on other guest

471
00:18:26,640 --> 00:18:30,320
additions

472
00:18:27,440 --> 00:18:31,039
we can also check uh if some of the

473
00:18:30,320 --> 00:18:32,960
programs

474
00:18:31,039 --> 00:18:34,799
are running on on a machine so for

475
00:18:32,960 --> 00:18:36,880
example uh

476
00:18:34,799 --> 00:18:38,639
a regular user uh such a corporate

477
00:18:36,880 --> 00:18:39,120
worker would not make use of a wire

478
00:18:38,640 --> 00:18:41,919
shark

479
00:18:39,120 --> 00:18:43,280
on it's on his device so and that will

480
00:18:41,919 --> 00:18:44,320
make that may be actually a good

481
00:18:43,280 --> 00:18:46,320
indicator for us

482
00:18:44,320 --> 00:18:47,840
whether to verify if we are facing a

483
00:18:46,320 --> 00:18:51,280
real machine

484
00:18:47,840 --> 00:18:52,959
uh and uh usually when it comes to the

485
00:18:51,280 --> 00:18:54,879
network devices for uh

486
00:18:52,960 --> 00:18:56,640
for any virtual machine they have to be

487
00:18:54,880 --> 00:18:57,440
simulated for most of the cases of

488
00:18:56,640 --> 00:18:59,840
course

489
00:18:57,440 --> 00:19:01,360
and especially you should pay attention

490
00:18:59,840 --> 00:19:03,600
to those networks devices

491
00:19:01,360 --> 00:19:05,280
because as you as probably most of you

492
00:19:03,600 --> 00:19:06,639
know the mac address can indicate the

493
00:19:05,280 --> 00:19:09,039
presence of a virtual

494
00:19:06,640 --> 00:19:10,160
environment since the first three bytes

495
00:19:09,039 --> 00:19:12,160
of the mac address

496
00:19:10,160 --> 00:19:13,360
are actually a manufacturer

497
00:19:12,160 --> 00:19:15,919
identification

498
00:19:13,360 --> 00:19:18,000
number so we can alliterate all the

499
00:19:15,919 --> 00:19:19,120
available network devices and compare

500
00:19:18,000 --> 00:19:21,600
those first three

501
00:19:19,120 --> 00:19:23,600
first bytes with well-known values of

502
00:19:21,600 --> 00:19:27,280
course you can also simulate that

503
00:19:23,600 --> 00:19:28,959
but uh it will it works for uh

504
00:19:27,280 --> 00:19:31,360
some of the antivirus solutions and

505
00:19:28,960 --> 00:19:34,559
probably uh vast majority of

506
00:19:31,360 --> 00:19:35,280
animal analytics won't uh uh won't make

507
00:19:34,559 --> 00:19:38,639
use of a

508
00:19:35,280 --> 00:19:41,200
real mac address and we would like

509
00:19:38,640 --> 00:19:41,760
also to focus on some anti-debugging

510
00:19:41,200 --> 00:19:44,000
features

511
00:19:41,760 --> 00:19:46,000
because our malware may be uh maybe then

512
00:19:44,000 --> 00:19:47,280
debugged and there are some specific

513
00:19:46,000 --> 00:19:49,200
characteristics

514
00:19:47,280 --> 00:19:51,600
indicating then the application is being

515
00:19:49,200 --> 00:19:55,280
manually inspected by a malware analyst

516
00:19:51,600 --> 00:19:57,600
and we can then set some some traps and

517
00:19:55,280 --> 00:19:58,960
make it harder for for analytics to

518
00:19:57,600 --> 00:20:00,959
reverse our code

519
00:19:58,960 --> 00:20:02,799
so our first thing we want to do is

520
00:20:00,960 --> 00:20:04,960
probably to check if the application is

521
00:20:02,799 --> 00:20:08,400
executed with a debugger attached

522
00:20:04,960 --> 00:20:09,440
so there's a simple uh simple function

523
00:20:08,400 --> 00:20:12,480
is debugger present

524
00:20:09,440 --> 00:20:14,480
so we can just just uh check that

525
00:20:12,480 --> 00:20:16,240
and there are some other specific facts

526
00:20:14,480 --> 00:20:17,919
uh for example set in the process under

527
00:20:16,240 --> 00:20:19,600
space when it's being debugged like

528
00:20:17,919 --> 00:20:21,360
anti-global it's a collection of

529
00:20:19,600 --> 00:20:24,000
flux located in the

530
00:20:21,360 --> 00:20:24,879
uh ppebb which may indicate the bugger

531
00:20:24,000 --> 00:20:26,240
presence

532
00:20:24,880 --> 00:20:28,240
of course there are a couple more

533
00:20:26,240 --> 00:20:30,080
debugging debugging technique and those

534
00:20:28,240 --> 00:20:32,159
are just just two of this

535
00:20:30,080 --> 00:20:33,439
but it mostly depends on what kind of

536
00:20:32,159 --> 00:20:36,000
software we are actually

537
00:20:33,440 --> 00:20:37,039
facing and one more one more tip if you

538
00:20:36,000 --> 00:20:39,840
are try to

539
00:20:37,039 --> 00:20:40,559
uh place such a trap in your code just

540
00:20:39,840 --> 00:20:43,600
make sure that

541
00:20:40,559 --> 00:20:45,520
you are not actually dropping for you so

542
00:20:43,600 --> 00:20:46,559
if you are using uh for example virtual

543
00:20:45,520 --> 00:20:49,120
studio debugger

544
00:20:46,559 --> 00:20:50,158
try not to bypass this debugger because

545
00:20:49,120 --> 00:20:52,639
you may have some

546
00:20:50,159 --> 00:20:53,919
problems with debugging your own code

547
00:20:52,640 --> 00:20:55,760
and

548
00:20:53,919 --> 00:20:57,840
we have now some we've done some basic

549
00:20:55,760 --> 00:20:58,640
steps and those are the actual steps and

550
00:20:57,840 --> 00:21:01,280
then in a

551
00:20:58,640 --> 00:21:02,559
in a piece of the shell called patrick

552
00:21:01,280 --> 00:21:05,600
presented before

553
00:21:02,559 --> 00:21:08,639
and i think that uh

554
00:21:05,600 --> 00:21:09,120
this may be enough and let's check if it

555
00:21:08,640 --> 00:21:12,480
actually

556
00:21:09,120 --> 00:21:12,479
did something to our code

557
00:21:12,720 --> 00:21:16,240
and was it magic no it's a it's a it's a

558
00:21:15,760 --> 00:21:19,120
score

559
00:21:16,240 --> 00:21:20,640
on this smaller uh dot executable file

560
00:21:19,120 --> 00:21:21,678
and it actually wasn't detected on the

561
00:21:20,640 --> 00:21:23,200
virus total

562
00:21:21,679 --> 00:21:24,799
well wireless total is not the perfect

563
00:21:23,200 --> 00:21:27,039
solution because even

564
00:21:24,799 --> 00:21:29,200
though there are some sandboxes inside

565
00:21:27,039 --> 00:21:31,520
of it those are the simplified some

566
00:21:29,200 --> 00:21:34,159
boxes of a simplified environment

567
00:21:31,520 --> 00:21:34,799
so probably this is not 100 sure but

568
00:21:34,159 --> 00:21:36,880
anyway

569
00:21:34,799 --> 00:21:38,480
uh we tricked the virus total we've got

570
00:21:36,880 --> 00:21:39,200
zero score so will marvel is a

571
00:21:38,480 --> 00:21:42,480
definitely

572
00:21:39,200 --> 00:21:43,200
a legitimate file and recommend to open

573
00:21:42,480 --> 00:21:46,880
in a

574
00:21:43,200 --> 00:21:49,679
real environment and there's one

575
00:21:46,880 --> 00:21:50,080
one big uh one big thing regarding the

576
00:21:49,679 --> 00:21:52,080
uh

577
00:21:50,080 --> 00:21:54,080
evading of the antivirus solution as

578
00:21:52,080 --> 00:21:55,439
usual the most valuable time i think in

579
00:21:54,080 --> 00:21:58,320
uh in the world is a time

580
00:21:55,440 --> 00:21:59,440
so it is in a marvel development so the

581
00:21:58,320 --> 00:22:02,559
clock is ticking

582
00:21:59,440 --> 00:22:04,640
and that's patrick okay so

583
00:22:02,559 --> 00:22:05,678
there's the thing with uh delaying

584
00:22:04,640 --> 00:22:08,320
execution because

585
00:22:05,679 --> 00:22:09,520
for example to evade the sandbox

586
00:22:08,320 --> 00:22:11,918
analysis we could

587
00:22:09,520 --> 00:22:12,639
just sleep our application for a few

588
00:22:11,919 --> 00:22:15,520
minutes

589
00:22:12,640 --> 00:22:16,320
but sandboxes are uh wise now and they

590
00:22:15,520 --> 00:22:20,240
can just

591
00:22:16,320 --> 00:22:23,760
uh fast forward those slips for

592
00:22:20,240 --> 00:22:27,440
by hooking windows api functions

593
00:22:23,760 --> 00:22:30,640
so uh here you see the uh

594
00:22:27,440 --> 00:22:33,280
execution flow of sleeping uh finally

595
00:22:30,640 --> 00:22:34,080
and delay execution is called is called

596
00:22:33,280 --> 00:22:37,440
and

597
00:22:34,080 --> 00:22:39,360
um it can be the this empty deal

598
00:22:37,440 --> 00:22:42,799
execution function can be hooked by

599
00:22:39,360 --> 00:22:46,479
some edr or on google sandbox

600
00:22:42,799 --> 00:22:46,480
whatever and

601
00:22:46,559 --> 00:22:50,960
some long sleeves called by by us on the

602
00:22:50,080 --> 00:22:54,158
code can be

603
00:22:50,960 --> 00:22:57,440
bypassed simply fast forwarded by by

604
00:22:54,159 --> 00:22:58,240
analysis analysis environment and it may

605
00:22:57,440 --> 00:23:01,919
not be

606
00:22:58,240 --> 00:23:04,640
that easy to actually

607
00:23:01,919 --> 00:23:06,080
delay our code execution for a few

608
00:23:04,640 --> 00:23:09,600
minutes

609
00:23:06,080 --> 00:23:13,360
and uh we can uh

610
00:23:09,600 --> 00:23:14,320
use the sleep or entity execution

611
00:23:13,360 --> 00:23:17,760
function but

612
00:23:14,320 --> 00:23:17,760
it may both be

613
00:23:18,559 --> 00:23:25,760
hooked and

614
00:23:22,159 --> 00:23:29,280
what what we can do to

615
00:23:25,760 --> 00:23:31,440
avoid this this detection

616
00:23:29,280 --> 00:23:32,639
is to for example use get the count

617
00:23:31,440 --> 00:23:36,720
function which

618
00:23:32,640 --> 00:23:40,080
gives us time in processor ticks or some

619
00:23:36,720 --> 00:23:42,240
100 nanoseconds intervals from the

620
00:23:40,080 --> 00:23:43,840
when the computer was started but this

621
00:23:42,240 --> 00:23:47,120
function also could be hooked

622
00:23:43,840 --> 00:23:50,158
but there is some cool thing

623
00:23:47,120 --> 00:23:53,760
which uh

624
00:23:50,159 --> 00:23:56,400
is kernel user search data and

625
00:23:53,760 --> 00:23:57,440
it's some read-only data available from

626
00:23:56,400 --> 00:24:00,799
usual land

627
00:23:57,440 --> 00:24:04,080
and on specific offsets

628
00:24:00,799 --> 00:24:07,279
it stores this a thick account

629
00:24:04,080 --> 00:24:10,720
and we can for example read the the time

630
00:24:07,279 --> 00:24:11,200
from from from there so for example when

631
00:24:10,720 --> 00:24:13,440
we

632
00:24:11,200 --> 00:24:14,320
sleep our application for a few minutes

633
00:24:13,440 --> 00:24:17,360
and then the

634
00:24:14,320 --> 00:24:18,000
sleep was fast forwarded we can use get

635
00:24:17,360 --> 00:24:20,479
the count

636
00:24:18,000 --> 00:24:21,760
or read the tick out from kernel user

637
00:24:20,480 --> 00:24:24,880
trajectory data

638
00:24:21,760 --> 00:24:28,430
to validate if the

639
00:24:24,880 --> 00:24:29,679
the count is bigger than before sleep

640
00:24:28,430 --> 00:24:32,720
[Music]

641
00:24:29,679 --> 00:24:35,520
for the specific value or if not if

642
00:24:32,720 --> 00:24:36,159
this analysis was fast forwarded our

643
00:24:35,520 --> 00:24:39,360
delay

644
00:24:36,159 --> 00:24:40,320
was fast forwarded we will get a

645
00:24:39,360 --> 00:24:43,120
discrepancy in

646
00:24:40,320 --> 00:24:44,080
in thick count so it's for us it's an

647
00:24:43,120 --> 00:24:48,158
indicator that

648
00:24:44,080 --> 00:24:51,360
the sleeping function was hooked and uh

649
00:24:48,159 --> 00:24:55,120
some uh analysis environment uh

650
00:24:51,360 --> 00:24:57,279
fast forwarded our uh execution delay so

651
00:24:55,120 --> 00:24:59,199
it's a good idea to terminate the

652
00:24:57,279 --> 00:25:01,360
application here

653
00:24:59,200 --> 00:25:02,640
so that was a thing about uh sleeping

654
00:25:01,360 --> 00:25:06,479
and now

655
00:25:02,640 --> 00:25:10,159
into function hooking and unhooking so

656
00:25:06,480 --> 00:25:13,520
um as i said for example

657
00:25:10,159 --> 00:25:14,000
a crucial system functions may be hooked

658
00:25:13,520 --> 00:25:17,918
by

659
00:25:14,000 --> 00:25:21,440
edrs or antiviruses or venice sandbox

660
00:25:17,919 --> 00:25:25,840
environments to monitor and combat

661
00:25:21,440 --> 00:25:29,039
our malicious behavior so for example uh

662
00:25:25,840 --> 00:25:30,959
to add creation or process creation or

663
00:25:29,039 --> 00:25:34,158
memory allocation functions can be

664
00:25:30,960 --> 00:25:34,159
hooked to to

665
00:25:34,720 --> 00:25:42,640
intercept and investigate

666
00:25:37,919 --> 00:25:45,279
actions that our code is performing

667
00:25:42,640 --> 00:25:45,840
so what what can we do about it uh we

668
00:25:45,279 --> 00:25:48,880
can't

669
00:25:45,840 --> 00:25:51,918
we can just find those hooks in memory

670
00:25:48,880 --> 00:25:52,880
by uh loading specific functions in

671
00:25:51,919 --> 00:25:56,799
memory and then

672
00:25:52,880 --> 00:25:59,919
comparing the op codes with

673
00:25:56,799 --> 00:26:02,158
assembly in the librarian a disk because

674
00:25:59,919 --> 00:26:06,640
when the dll was selected from a disk

675
00:26:02,159 --> 00:26:09,200
and modified by some edr solution

676
00:26:06,640 --> 00:26:10,000
the first op codes first instructions

677
00:26:09,200 --> 00:26:12,640
would be different

678
00:26:10,000 --> 00:26:14,240
than in the original library because

679
00:26:12,640 --> 00:26:17,919
there probably will be some

680
00:26:14,240 --> 00:26:18,640
call to external function located in for

681
00:26:17,919 --> 00:26:22,240
example

682
00:26:18,640 --> 00:26:25,440
antivirus module so we can

683
00:26:22,240 --> 00:26:28,080
compare the op codes to find hooks

684
00:26:25,440 --> 00:26:29,200
if if there are any we can unhook

685
00:26:28,080 --> 00:26:32,320
functions by

686
00:26:29,200 --> 00:26:35,840
overwriting uh

687
00:26:32,320 --> 00:26:39,120
those op codes with original code so

688
00:26:35,840 --> 00:26:42,799
like restore the original assembly

689
00:26:39,120 --> 00:26:45,279
and that's the way that way the

690
00:26:42,799 --> 00:26:48,960
functions will be unhooked because the

691
00:26:45,279 --> 00:26:48,960
they will be executed as normal

692
00:26:50,840 --> 00:26:57,520
and and

693
00:26:54,000 --> 00:27:00,559
uh we can try to completely bypass

694
00:26:57,520 --> 00:27:02,639
function hooks by issuing cisco's the

695
00:27:00,559 --> 00:27:05,360
directive the kernel

696
00:27:02,640 --> 00:27:06,960
so uh here is an example of create

697
00:27:05,360 --> 00:27:09,760
thread function execution

698
00:27:06,960 --> 00:27:11,039
when we call a create thread from kernel

699
00:27:09,760 --> 00:27:14,000
32 32

700
00:27:11,039 --> 00:27:15,279
like in this shortcut injection proof of

701
00:27:14,000 --> 00:27:18,159
concept

702
00:27:15,279 --> 00:27:19,440
several functions are called and then

703
00:27:18,159 --> 00:27:22,880
anti-create

704
00:27:19,440 --> 00:27:24,799
thread external is called and then this

705
00:27:22,880 --> 00:27:26,399
antiquatret function is basically a

706
00:27:24,799 --> 00:27:29,760
wrapper to assist call

707
00:27:26,399 --> 00:27:33,039
and cisco works like this

708
00:27:29,760 --> 00:27:34,799
cisco id is pushed to eax register and

709
00:27:33,039 --> 00:27:38,000
then this

710
00:27:34,799 --> 00:27:40,480
is execution switch to kernel mode by

711
00:27:38,000 --> 00:27:42,640
this cisco instruction and you can see

712
00:27:40,480 --> 00:27:44,880
on the process monitor except here

713
00:27:42,640 --> 00:27:44,880
that

714
00:27:47,360 --> 00:27:50,479
at some point execution is switched to

715
00:27:49,360 --> 00:27:53,600
kernel so

716
00:27:50,480 --> 00:27:54,159
to avoid to bypass cisco function

717
00:27:53,600 --> 00:27:57,760
hooking

718
00:27:54,159 --> 00:28:03,279
we could just uh issue those cisco

719
00:27:57,760 --> 00:28:06,720
directly to the kernel

720
00:28:03,279 --> 00:28:09,039
so uh for example we can uh that's

721
00:28:06,720 --> 00:28:10,080
how i implemented it we can write some

722
00:28:09,039 --> 00:28:12,530
uh

723
00:28:10,080 --> 00:28:14,960
simple assembly to

724
00:28:12,530 --> 00:28:18,799
[Music]

725
00:28:14,960 --> 00:28:22,159
call the issue to syscall and then uh

726
00:28:18,799 --> 00:28:24,879
call this assembly function but as

727
00:28:22,159 --> 00:28:26,080
a pointer to create antiquate thread

728
00:28:24,880 --> 00:28:28,159
function so

729
00:28:26,080 --> 00:28:30,399
specific parameters will be passed plus

730
00:28:28,159 --> 00:28:35,279
two registers into the stack and then

731
00:28:30,399 --> 00:28:38,320
uh the function from

732
00:28:35,279 --> 00:28:41,360
ntdl library won't be called but

733
00:28:38,320 --> 00:28:45,439
we will call the kernel direct directly

734
00:28:41,360 --> 00:28:46,719
to for example allocate memory for us or

735
00:28:45,440 --> 00:28:49,840
here create a

736
00:28:46,720 --> 00:28:52,159
thread in a process for us so it's a

737
00:28:49,840 --> 00:28:54,480
good technique to bypass those function

738
00:28:52,159 --> 00:28:54,480
hooks

739
00:28:56,159 --> 00:29:00,399
yeah and the previous part we of uh we

740
00:28:58,159 --> 00:29:03,200
always created a new file which

741
00:29:00,399 --> 00:29:04,719
is really means that it actually has to

742
00:29:03,200 --> 00:29:06,880
force our victim to

743
00:29:04,720 --> 00:29:08,880
to use this file and we can also some

744
00:29:06,880 --> 00:29:10,799
make use of an interesting

745
00:29:08,880 --> 00:29:12,159
already existing file of the target

746
00:29:10,799 --> 00:29:15,760
machine so

747
00:29:12,159 --> 00:29:18,000
uh this is uh this is we will focus on

748
00:29:15,760 --> 00:29:20,320
executable file and we like to backdoor

749
00:29:18,000 --> 00:29:22,960
some portable executable file

750
00:29:20,320 --> 00:29:24,480
and unless we are forced to use a

751
00:29:22,960 --> 00:29:26,320
specific binary

752
00:29:24,480 --> 00:29:28,320
during this file there are some points

753
00:29:26,320 --> 00:29:30,480
which actually should be kept in mind

754
00:29:28,320 --> 00:29:32,240
they are however not required to be

755
00:29:30,480 --> 00:29:35,200
followed but preferred because

756
00:29:32,240 --> 00:29:36,080
they will help uh reducing the antivirus

757
00:29:35,200 --> 00:29:37,760
detection rate

758
00:29:36,080 --> 00:29:39,520
and probably making the product more

759
00:29:37,760 --> 00:29:42,799
visible uh

760
00:29:39,520 --> 00:29:43,360
so first of all is try to uh make make a

761
00:29:42,799 --> 00:29:46,080
look at the

762
00:29:43,360 --> 00:29:47,520
file size small smaller file it was uh

763
00:29:46,080 --> 00:29:50,720
easier to transfer of course

764
00:29:47,520 --> 00:29:52,320
and usually uh it's easier to debug them

765
00:29:50,720 --> 00:29:55,440
in case of issues

766
00:29:52,320 --> 00:29:58,240
and uh it's a good idea to uh

767
00:29:55,440 --> 00:30:00,640
by a well-known product for example a

768
00:29:58,240 --> 00:30:02,799
program which actually our victim uses

769
00:30:00,640 --> 00:30:03,760
and using this known particular

770
00:30:02,799 --> 00:30:05,360
executable file

771
00:30:03,760 --> 00:30:08,720
is actually not required but there are

772
00:30:05,360 --> 00:30:12,320
some changes chances that antivirus will

773
00:30:08,720 --> 00:30:13,440
be more inclined to execute a known

774
00:30:12,320 --> 00:30:16,639
program

775
00:30:13,440 --> 00:30:18,880
and uh it's always a good idea to uh to

776
00:30:16,640 --> 00:30:22,559
use a c or c plus plus native binaries

777
00:30:18,880 --> 00:30:25,039
and try to use the file that legitimate

778
00:30:22,559 --> 00:30:26,399
feature is using a network because we if

779
00:30:25,039 --> 00:30:29,039
we use uh for example

780
00:30:26,399 --> 00:30:29,760
a paint uh application it probably won't

781
00:30:29,039 --> 00:30:32,158
be using

782
00:30:29,760 --> 00:30:32,799
what we're using network and it's uh

783
00:30:32,159 --> 00:30:36,320
it's

784
00:30:32,799 --> 00:30:39,600
more uh more likely to be detected by a

785
00:30:36,320 --> 00:30:42,960
by a blue team so we

786
00:30:39,600 --> 00:30:46,080
want to be so easy uh

787
00:30:42,960 --> 00:30:47,039
cached and the last idea the last thing

788
00:30:46,080 --> 00:30:49,360
is avoid using

789
00:30:47,039 --> 00:30:51,200
files that are not protected using a

790
00:30:49,360 --> 00:30:55,520
security security features

791
00:30:51,200 --> 00:30:59,200
such a aslr or deep execution prevention

792
00:30:55,520 --> 00:31:02,480
and let's let's go

793
00:30:59,200 --> 00:31:04,880
and verify that so there are some

794
00:31:02,480 --> 00:31:06,559
techniques like aslr

795
00:31:04,880 --> 00:31:08,880
and deep execution prevention which

796
00:31:06,559 --> 00:31:11,918
actually prevents us

797
00:31:08,880 --> 00:31:13,519
from hijacking our our code like for

798
00:31:11,919 --> 00:31:16,159
example randomizing the

799
00:31:13,519 --> 00:31:17,120
uh the memory and preventing from

800
00:31:16,159 --> 00:31:20,159
running other

801
00:31:17,120 --> 00:31:22,799
uh code from memory

802
00:31:20,159 --> 00:31:23,919
and there are there is a interesting

803
00:31:22,799 --> 00:31:26,559
script called

804
00:31:23,919 --> 00:31:27,679
get pe security which actually gives you

805
00:31:26,559 --> 00:31:30,799
an idea

806
00:31:27,679 --> 00:31:32,399
uh what the program has been or what

807
00:31:30,799 --> 00:31:34,000
the features that the program has been

808
00:31:32,399 --> 00:31:35,678
uh compiled with

809
00:31:34,000 --> 00:31:37,679
and we can make a look uh for example

810
00:31:35,679 --> 00:31:41,039
we've had two different versions of a

811
00:31:37,679 --> 00:31:43,039
7-zip file one of which consists of uh

812
00:31:41,039 --> 00:31:44,399
depth protection and one not so probably

813
00:31:43,039 --> 00:31:47,360
the most uh

814
00:31:44,399 --> 00:31:48,080
we will be with this one that did not

815
00:31:47,360 --> 00:31:50,719
have

816
00:31:48,080 --> 00:31:52,000
don't do not have this uh uh the

817
00:31:50,720 --> 00:31:55,440
protection

818
00:31:52,000 --> 00:31:57,919
uh okay and once we uh once we found our

819
00:31:55,440 --> 00:32:00,399
uh our target we probably would like to

820
00:31:57,919 --> 00:32:01,440
make some static analysis of it and we

821
00:32:00,399 --> 00:32:04,639
will make use of

822
00:32:01,440 --> 00:32:06,320
uh in this case on a putty file so what

823
00:32:04,640 --> 00:32:07,279
is an interesting file because it's a

824
00:32:06,320 --> 00:32:09,439
native c plus

825
00:32:07,279 --> 00:32:12,720
project so which include which users

826
00:32:09,440 --> 00:32:15,760
have multiple libraries and windows apis

827
00:32:12,720 --> 00:32:17,919
and it's also a network uh

828
00:32:15,760 --> 00:32:18,799
program that use a network for a normal

829
00:32:17,919 --> 00:32:20,799
activity

830
00:32:18,799 --> 00:32:22,399
so we probably won't be attracting so

831
00:32:20,799 --> 00:32:24,399
much attention when it comes to the

832
00:32:22,399 --> 00:32:25,439
network monitoring so the blue team

833
00:32:24,399 --> 00:32:29,120
won't probably

834
00:32:25,440 --> 00:32:31,919
uh be so suspicious about this

835
00:32:29,120 --> 00:32:32,399
and what we're gonna do we're gonna

836
00:32:31,919 --> 00:32:35,679
actually

837
00:32:32,399 --> 00:32:37,600
inject uh our uh our code

838
00:32:35,679 --> 00:32:39,600
and there are there are two actually

839
00:32:37,600 --> 00:32:40,959
approaches to this portable executable

840
00:32:39,600 --> 00:32:44,000
file exploitation

841
00:32:40,960 --> 00:32:46,320
one of which main the main uh

842
00:32:44,000 --> 00:32:47,120
diverse is to add a new new section in

843
00:32:46,320 --> 00:32:49,039
the memory

844
00:32:47,120 --> 00:32:50,719
or to find an available space for a

845
00:32:49,039 --> 00:32:52,559
circle it's called uh

846
00:32:50,720 --> 00:32:54,799
which is called the code cave then the

847
00:32:52,559 --> 00:32:56,080
flow is pretty same so we copy the hop

848
00:32:54,799 --> 00:32:57,918
codes from the stack at the beginning

849
00:32:56,080 --> 00:32:59,918
of the programs then replace those

850
00:32:57,919 --> 00:33:02,000
instructions with our own up codes to

851
00:32:59,919 --> 00:33:03,440
hijack the execution flow once we

852
00:33:02,000 --> 00:33:05,919
highlight the execution flow

853
00:33:03,440 --> 00:33:08,640
our inject our shell code and we set the

854
00:33:05,919 --> 00:33:11,120
registers back

855
00:33:08,640 --> 00:33:12,000
so uh we will allow the normal execution

856
00:33:11,120 --> 00:33:15,360
flow of the

857
00:33:12,000 --> 00:33:17,600
uh of the application so uh the first

858
00:33:15,360 --> 00:33:18,479
uh the first one would be adding a new

859
00:33:17,600 --> 00:33:21,519
section

860
00:33:18,480 --> 00:33:23,360
so we pro we will be going to add a new

861
00:33:21,519 --> 00:33:26,559
section in this case i've added

862
00:33:23,360 --> 00:33:28,240
zivcon section and just to ima just to

863
00:33:26,559 --> 00:33:31,519
remember not only when using

864
00:33:28,240 --> 00:33:33,279
for example uh cff explorer uh

865
00:33:31,519 --> 00:33:35,120
add a new section of the with the empty

866
00:33:33,279 --> 00:33:37,760
data on it in case you

867
00:33:35,120 --> 00:33:39,120
had only a header you need to fill it

868
00:33:37,760 --> 00:33:41,679
fill the section before running the

869
00:33:39,120 --> 00:33:44,719
program because it will probably crash

870
00:33:41,679 --> 00:33:48,640
and the once we once we do that

871
00:33:44,720 --> 00:33:50,960
we need to change them the flags on this

872
00:33:48,640 --> 00:33:52,559
section in order to make it executable

873
00:33:50,960 --> 00:33:56,559
so we can execute our

874
00:33:52,559 --> 00:33:58,960
our uh code from this section and

875
00:33:56,559 --> 00:34:00,240
that's what we did we placed an empty

876
00:33:58,960 --> 00:34:03,360
section which

877
00:34:00,240 --> 00:34:04,320
now has zero and this one has a full

878
00:34:03,360 --> 00:34:07,360
permission

879
00:34:04,320 --> 00:34:08,960
and we are uh ready to proceed uh

880
00:34:07,360 --> 00:34:10,480
we're not actually proceeding it's not

881
00:34:08,960 --> 00:34:12,560
uh it's not so easy

882
00:34:10,480 --> 00:34:13,520
because uh once we do that probably uh

883
00:34:12,560 --> 00:34:15,440
windows defender

884
00:34:13,520 --> 00:34:17,440
and or maybe what kind of antivirus do

885
00:34:15,440 --> 00:34:17,760
you use will probably at the moment eat

886
00:34:17,440 --> 00:34:20,320
this

887
00:34:17,760 --> 00:34:20,879
in this file because even when adding an

888
00:34:20,320 --> 00:34:22,560
empty

889
00:34:20,879 --> 00:34:24,480
section with a full permissions to an

890
00:34:22,560 --> 00:34:25,839
executable file and the first solution

891
00:34:24,480 --> 00:34:29,040
may consider this file as

892
00:34:25,839 --> 00:34:32,560
suspicion suspicious so defender

893
00:34:29,040 --> 00:34:34,399
do that and we have a problem let's try

894
00:34:32,560 --> 00:34:37,119
what's what the ios total says

895
00:34:34,399 --> 00:34:38,638
and it says that there is really

896
00:34:37,119 --> 00:34:41,679
relatively high score

897
00:34:38,639 --> 00:34:43,359
and we literally didn't start it even uh

898
00:34:41,679 --> 00:34:46,000
placing commercial code and the file

899
00:34:43,359 --> 00:34:47,119
is already executed so maybe it's

900
00:34:46,000 --> 00:34:49,440
already catched

901
00:34:47,119 --> 00:34:50,960
so maybe it's not a great idea to to

902
00:34:49,440 --> 00:34:53,119
follow the step

903
00:34:50,960 --> 00:34:54,639
as a short summary we make we can see

904
00:34:53,119 --> 00:34:57,359
pros and cons of this

905
00:34:54,639 --> 00:34:58,560
this method of course we can we can move

906
00:34:57,359 --> 00:35:01,279
forward with that

907
00:34:58,560 --> 00:35:02,078
but the chances that we are going to

908
00:35:01,280 --> 00:35:05,280
make the detection

909
00:35:02,079 --> 00:35:09,040
rate rate slower or very unlikely or

910
00:35:05,280 --> 00:35:11,760
uh not so high as the other other method

911
00:35:09,040 --> 00:35:13,599
so the biggest problem is that we don't

912
00:35:11,760 --> 00:35:15,119
need to worry about a space for our

913
00:35:13,599 --> 00:35:18,960
shell code

914
00:35:15,119 --> 00:35:22,480
and so this this is really really useful

915
00:35:18,960 --> 00:35:24,079
uh we can also place uh our own encoders

916
00:35:22,480 --> 00:35:25,839
because there's a plenty of space

917
00:35:24,079 --> 00:35:27,520
but actually as we said as we've seen

918
00:35:25,839 --> 00:35:28,240
before adding a new section header and

919
00:35:27,520 --> 00:35:30,880
assigning it

920
00:35:28,240 --> 00:35:32,240
execution flag will most likely alert an

921
00:35:30,880 --> 00:35:35,440
antivirus solution

922
00:35:32,240 --> 00:35:38,560
and we also increase the size of a file

923
00:35:35,440 --> 00:35:40,560
not so much but still

924
00:35:38,560 --> 00:35:41,759
there's a there's a better better

925
00:35:40,560 --> 00:35:45,279
solution

926
00:35:41,760 --> 00:35:47,680
this is called a method with a code cave

927
00:35:45,280 --> 00:35:49,839
so what are the code caves code keys are

928
00:35:47,680 --> 00:35:51,839
that or empty blocks in memory

929
00:35:49,839 --> 00:35:53,599
of a program which can be used to inject

930
00:35:51,839 --> 00:35:55,520
our own code

931
00:35:53,599 --> 00:35:56,800
so instead of creating a new section we

932
00:35:55,520 --> 00:36:00,880
will make use of

933
00:35:56,800 --> 00:36:00,880
existing one and

934
00:36:01,280 --> 00:36:06,000
to find an existing one in our memory of

935
00:36:04,079 --> 00:36:07,359
course we want to do it by our hand

936
00:36:06,000 --> 00:36:09,599
there's there are a couple of scripts

937
00:36:07,359 --> 00:36:11,440
and tools to do that i prefer using

938
00:36:09,599 --> 00:36:14,480
caveminer

939
00:36:11,440 --> 00:36:17,599
so we can use the cave miner uh to

940
00:36:14,480 --> 00:36:19,920
find shellcode in our uh in our file

941
00:36:17,599 --> 00:36:21,760
uh caveminer is really interesting

942
00:36:19,920 --> 00:36:22,560
because it also gives you an ability to

943
00:36:21,760 --> 00:36:24,720
check whether

944
00:36:22,560 --> 00:36:26,160
the inappropriate flags has been used in

945
00:36:24,720 --> 00:36:28,640
this uh

946
00:36:26,160 --> 00:36:29,359
in this file and as we can see uh there

947
00:36:28,640 --> 00:36:31,200
is a the

948
00:36:29,359 --> 00:36:33,040
the input only which we need to provide

949
00:36:31,200 --> 00:36:36,078
is a desired size of a

950
00:36:33,040 --> 00:36:38,720
uh of a shell code uh

951
00:36:36,079 --> 00:36:40,079
we can go uh then once we find once we

952
00:36:38,720 --> 00:36:42,319
find an appropriate uh

953
00:36:40,079 --> 00:36:44,640
code key if we need to check which which

954
00:36:42,320 --> 00:36:46,160
section uh does it exist in and we know

955
00:36:44,640 --> 00:36:47,359
there's a data section we need to make

956
00:36:46,160 --> 00:36:51,118
it executable

957
00:36:47,359 --> 00:36:53,440
in order to to work and once we

958
00:36:51,119 --> 00:36:54,400
once we do that we probably would like

959
00:36:53,440 --> 00:36:58,079
to hide

960
00:36:54,400 --> 00:37:02,079
uh behind the user action because

961
00:36:58,079 --> 00:37:04,320
the way we want to uh run our code is

962
00:37:02,079 --> 00:37:06,079
to hide the execution flow straight

963
00:37:04,320 --> 00:37:09,119
after the user interaction because

964
00:37:06,079 --> 00:37:12,000
it's not a suspicious action then

965
00:37:09,119 --> 00:37:13,760
and we need to find some action so in

966
00:37:12,000 --> 00:37:17,200
this example we will probably

967
00:37:13,760 --> 00:37:18,079
uh use uh the main feature of the prodi

968
00:37:17,200 --> 00:37:19,839
which is clicking

969
00:37:18,079 --> 00:37:21,920
open button and once we click open

970
00:37:19,839 --> 00:37:23,279
button connecting to a legitimate server

971
00:37:21,920 --> 00:37:26,400
we probably see that string

972
00:37:23,280 --> 00:37:28,640
a log login ass so the the first

973
00:37:26,400 --> 00:37:29,440
step would be to look for a test string

974
00:37:28,640 --> 00:37:32,560
references

975
00:37:29,440 --> 00:37:33,040
in our ipv file then place a breakpoint

976
00:37:32,560 --> 00:37:34,560
there

977
00:37:33,040 --> 00:37:37,200
because there may be a couple of

978
00:37:34,560 --> 00:37:38,880
different uh strings in the in this file

979
00:37:37,200 --> 00:37:40,640
good idea is to pre to to put a

980
00:37:38,880 --> 00:37:43,599
breakpoints at each uh

981
00:37:40,640 --> 00:37:46,319
existing uh string reference and then

982
00:37:43,599 --> 00:37:48,960
run the program and verify if we

983
00:37:46,320 --> 00:37:50,000
do the desired action and we hit do we

984
00:37:48,960 --> 00:37:51,839
hit our breakpoint

985
00:37:50,000 --> 00:37:53,599
and that's what we actually did we hit

986
00:37:51,839 --> 00:37:56,799
the breakpoint and this

987
00:37:53,599 --> 00:37:59,760
will be our uh injection starting point

988
00:37:56,800 --> 00:38:02,480
of our injection

989
00:37:59,760 --> 00:38:05,760
so we actually need to do how much space

990
00:38:02,480 --> 00:38:08,320
do we need for our shell code so let's

991
00:38:05,760 --> 00:38:09,359
generate our our payload and as we can

992
00:38:08,320 --> 00:38:13,520
see we need

993
00:38:09,359 --> 00:38:16,720
as much as 324 bytes for our shellcode

994
00:38:13,520 --> 00:38:19,119
let's go back to caveminer we got uh

995
00:38:16,720 --> 00:38:21,118
we got a couple of uh two uh two

996
00:38:19,119 --> 00:38:23,599
different uh catechos let's lose the

997
00:38:21,119 --> 00:38:26,800
second one change the appropriate flags

998
00:38:23,599 --> 00:38:29,599
uh and we can we can uh proceed

999
00:38:26,800 --> 00:38:30,800
uh as we can see uh the code the cave

1000
00:38:29,599 --> 00:38:32,720
looks pretty nice

1001
00:38:30,800 --> 00:38:34,640
it's it's empty and it looks like a

1002
00:38:32,720 --> 00:38:36,480
perfect place for our shell code

1003
00:38:34,640 --> 00:38:38,000
but it's always a good idea to run a

1004
00:38:36,480 --> 00:38:39,680
program and verify whether

1005
00:38:38,000 --> 00:38:42,160
it actually changes during the program

1006
00:38:39,680 --> 00:38:45,040
run and it happened in this case

1007
00:38:42,160 --> 00:38:46,399
the program the the space get handled

1008
00:38:45,040 --> 00:38:47,119
and some of the instructions were

1009
00:38:46,400 --> 00:38:49,200
changed

1010
00:38:47,119 --> 00:38:51,440
so we need to find another code cave

1011
00:38:49,200 --> 00:38:55,439
which was relatively close like

1012
00:38:51,440 --> 00:38:59,520
uh like 20 bytes further so

1013
00:38:55,440 --> 00:39:01,920
we will use we will use this one and

1014
00:38:59,520 --> 00:39:02,720
we would like to uh hijack the program

1015
00:39:01,920 --> 00:39:04,880
execution flow

1016
00:39:02,720 --> 00:39:06,720
starting from this entry point which we

1017
00:39:04,880 --> 00:39:09,520
said previously as a breakpoint

1018
00:39:06,720 --> 00:39:10,000
to this empty sanction we we've done

1019
00:39:09,520 --> 00:39:12,960
that

1020
00:39:10,000 --> 00:39:14,960
and we can now proceed to a placing of

1021
00:39:12,960 --> 00:39:15,680
our share code in this particular code

1022
00:39:14,960 --> 00:39:18,400
cave

1023
00:39:15,680 --> 00:39:19,200
which is really simple we can use this

1024
00:39:18,400 --> 00:39:21,040
piece of code

1025
00:39:19,200 --> 00:39:23,439
first we need to save the registers save

1026
00:39:21,040 --> 00:39:24,079
the flags then put our modified shell

1027
00:39:23,440 --> 00:39:26,400
code

1028
00:39:24,079 --> 00:39:27,440
why modified i will talk in a second

1029
00:39:26,400 --> 00:39:29,359
then we need to

1030
00:39:27,440 --> 00:39:31,119
restore the flags we store the registers

1031
00:39:29,359 --> 00:39:34,319
and make a stack alignment

1032
00:39:31,119 --> 00:39:37,200
and that will be enough uh and this

1033
00:39:34,320 --> 00:39:37,760
this little modification which we need

1034
00:39:37,200 --> 00:39:41,279
to do

1035
00:39:37,760 --> 00:39:42,240
is because due to the uh our metasploit

1036
00:39:41,280 --> 00:39:44,160
uh payload

1037
00:39:42,240 --> 00:39:45,598
because at the end of the shell code we

1038
00:39:44,160 --> 00:39:48,319
see there's now there's an

1039
00:39:45,599 --> 00:39:50,000
op code called call ebp which actually

1040
00:39:48,320 --> 00:39:50,960
actually terminates the execution of the

1041
00:39:50,000 --> 00:39:53,920
program

1042
00:39:50,960 --> 00:39:56,160
uh uh right after the shellcode is

1043
00:39:53,920 --> 00:39:57,760
executed we don't want to

1044
00:39:56,160 --> 00:40:00,319
program to terminate once the shortcode

1045
00:39:57,760 --> 00:40:00,720
is executed so we will like to change

1046
00:40:00,320 --> 00:40:03,760
that

1047
00:40:00,720 --> 00:40:05,759
to a no no op code no operation

1048
00:40:03,760 --> 00:40:07,520
and because the call vp is two bytes

1049
00:40:05,760 --> 00:40:10,480
long we actually need to

1050
00:40:07,520 --> 00:40:11,920
use two no operations and inside of it

1051
00:40:10,480 --> 00:40:13,680
there's a

1052
00:40:11,920 --> 00:40:15,040
there's another place we need to change

1053
00:40:13,680 --> 00:40:18,960
to knob it's

1054
00:40:15,040 --> 00:40:21,599
uh dec inc which actually is a feature

1055
00:40:18,960 --> 00:40:23,119
uh that once the once once the program

1056
00:40:21,599 --> 00:40:24,000
is running the shortcut is running it

1057
00:40:23,119 --> 00:40:25,680
waits for the user

1058
00:40:24,000 --> 00:40:28,400
input we don't want to do wait for the

1059
00:40:25,680 --> 00:40:33,359
user input so we need to change

1060
00:40:28,400 --> 00:40:36,800
this dc ink for no ob2

1061
00:40:33,359 --> 00:40:38,640
and once we once we place that inside of

1062
00:40:36,800 --> 00:40:40,160
the the code cave we can run the program

1063
00:40:38,640 --> 00:40:41,598
and we can see that there's a shell

1064
00:40:40,160 --> 00:40:45,920
coming to us

1065
00:40:41,599 --> 00:40:49,760
lucky us and see whether uh it actually

1066
00:40:45,920 --> 00:40:53,040
uh was was a usable in this case

1067
00:40:49,760 --> 00:40:56,160
and uh well it

1068
00:40:53,040 --> 00:40:58,720
it actually is not the perfect one uh

1069
00:40:56,160 --> 00:41:00,160
it's still a high detection rate why

1070
00:40:58,720 --> 00:41:02,240
detection rate is so high

1071
00:41:00,160 --> 00:41:03,279
uh because maybe because we used a row

1072
00:41:02,240 --> 00:41:07,279
shell code

1073
00:41:03,280 --> 00:41:09,119
uh from uh from uh matthew pretter so

1074
00:41:07,280 --> 00:41:10,720
we probably what we're gonna do we're

1075
00:41:09,119 --> 00:41:12,720
gonna use the method

1076
00:41:10,720 --> 00:41:14,319
you previously mentioned by patrick we

1077
00:41:12,720 --> 00:41:16,799
use xor encryption

1078
00:41:14,319 --> 00:41:17,759
nobody and no a solution will try to

1079
00:41:16,800 --> 00:41:20,880
break our

1080
00:41:17,760 --> 00:41:22,720
uh our code our encryption at this point

1081
00:41:20,880 --> 00:41:25,760
because it's not it's not what is going

1082
00:41:22,720 --> 00:41:30,319
on with what is going

1083
00:41:25,760 --> 00:41:33,359
in the in the in the memory and uh

1084
00:41:30,319 --> 00:41:36,000
we will like to uh encrypt that

1085
00:41:33,359 --> 00:41:37,759
and the shell code in the code cave will

1086
00:41:36,000 --> 00:41:39,680
look pretty the same

1087
00:41:37,760 --> 00:41:42,319
but before just before the shell code we

1088
00:41:39,680 --> 00:41:45,520
need to place our encoder and decoder

1089
00:41:42,319 --> 00:41:46,160
which will uh decode our our our

1090
00:41:45,520 --> 00:41:49,680
shellcode

1091
00:41:46,160 --> 00:41:51,040
uh to avoid static analysis and decoder

1092
00:41:49,680 --> 00:41:52,879
right is right there the code is

1093
00:41:51,040 --> 00:41:55,200
relatively simple because first we need

1094
00:41:52,880 --> 00:41:56,319
to place a code start address in an ebx

1095
00:41:55,200 --> 00:41:58,078
register

1096
00:41:56,319 --> 00:41:59,599
then uh we would like to sort the

1097
00:41:58,079 --> 00:42:03,599
content of the ebx

1098
00:41:59,599 --> 00:42:05,520
register using the our own key then

1099
00:42:03,599 --> 00:42:07,119
increase the ebx and check whether we

1100
00:42:05,520 --> 00:42:08,079
already reached the last address of the

1101
00:42:07,119 --> 00:42:11,280
shellcode

1102
00:42:08,079 --> 00:42:13,599
and if not jump back to our command

1103
00:42:11,280 --> 00:42:15,040
until we reach the end of the shellcode

1104
00:42:13,599 --> 00:42:17,839
and

1105
00:42:15,040 --> 00:42:18,160
was it a success uh well as we look we

1106
00:42:17,839 --> 00:42:20,000
can

1107
00:42:18,160 --> 00:42:21,359
place a breakpoint just in the end of

1108
00:42:20,000 --> 00:42:23,680
the recorder and this week

1109
00:42:21,359 --> 00:42:24,400
as we can see the rest of the shellcode

1110
00:42:23,680 --> 00:42:27,839
has been

1111
00:42:24,400 --> 00:42:30,000
uh uh has been changed

1112
00:42:27,839 --> 00:42:31,839
we can now save this this file as it is

1113
00:42:30,000 --> 00:42:32,800
because encoder already encoded our

1114
00:42:31,839 --> 00:42:34,960
payload

1115
00:42:32,800 --> 00:42:35,920
and was once we run it again it will

1116
00:42:34,960 --> 00:42:38,560
work

1117
00:42:35,920 --> 00:42:39,119
and the detection rate is relatively

1118
00:42:38,560 --> 00:42:42,160
slow

1119
00:42:39,119 --> 00:42:43,920
we managed to get five and a virus total

1120
00:42:42,160 --> 00:42:45,759
so it's a it's a good starting point

1121
00:42:43,920 --> 00:42:48,160
there are a couple more options to

1122
00:42:45,760 --> 00:42:49,359
uh to make it really low for example we

1123
00:42:48,160 --> 00:42:52,000
can chunk our

1124
00:42:49,359 --> 00:42:52,480
shark into a multiple cold caves so it

1125
00:42:52,000 --> 00:42:54,640
will be

1126
00:42:52,480 --> 00:42:55,599
even harder to static you know static

1127
00:42:54,640 --> 00:42:58,078
analysis for

1128
00:42:55,599 --> 00:43:00,000
antivirus solutions but this is a story

1129
00:42:58,079 --> 00:43:03,359
for a completely new presentation

1130
00:43:00,000 --> 00:43:05,359
and we think we can go to the

1131
00:43:03,359 --> 00:43:07,839
last section which is hiding imports by

1132
00:43:05,359 --> 00:43:07,839
patrick

1133
00:43:08,319 --> 00:43:12,480
patrick microphone you have a muted

1134
00:43:11,040 --> 00:43:14,640
microphone

1135
00:43:12,480 --> 00:43:17,119
thanks so we are running our time so

1136
00:43:14,640 --> 00:43:19,118
let's quickly discuss the

1137
00:43:17,119 --> 00:43:20,160
import table and hiding function from

1138
00:43:19,119 --> 00:43:22,240
there

1139
00:43:20,160 --> 00:43:24,399
so when we compile and windows

1140
00:43:22,240 --> 00:43:25,279
executable when we are using some api

1141
00:43:24,400 --> 00:43:28,480
functions or

1142
00:43:25,280 --> 00:43:30,880
new functions from external libraries

1143
00:43:28,480 --> 00:43:32,640
the information is placed in import

1144
00:43:30,880 --> 00:43:35,839
table of the executable

1145
00:43:32,640 --> 00:43:38,560
and one the simple thing to

1146
00:43:35,839 --> 00:43:41,279
do to bypass this is to load the

1147
00:43:38,560 --> 00:43:44,240
functions uh dynamically during runtime

1148
00:43:41,280 --> 00:43:44,800
using get process address get model

1149
00:43:44,240 --> 00:43:48,319
handle

1150
00:43:44,800 --> 00:43:50,880
or load library so we can hide

1151
00:43:48,319 --> 00:43:52,640
those sensitive functions like create

1152
00:43:50,880 --> 00:43:56,480
thread create process

1153
00:43:52,640 --> 00:43:59,279
allocate memory or wherever to

1154
00:43:56,480 --> 00:44:01,280
so only get process address function is

1155
00:43:59,280 --> 00:44:03,920
visible in the import table but

1156
00:44:01,280 --> 00:44:06,839
those library loading and process

1157
00:44:03,920 --> 00:44:10,400
locating functions are also

1158
00:44:06,839 --> 00:44:13,520
uh an indicator of of some malware

1159
00:44:10,400 --> 00:44:16,480
especially packers you like upx

1160
00:44:13,520 --> 00:44:18,480
you use those functions often so we can

1161
00:44:16,480 --> 00:44:22,000
take some measures to

1162
00:44:18,480 --> 00:44:25,040
hide those imports too and to to do

1163
00:44:22,000 --> 00:44:27,680
this we can use the algorithm

1164
00:44:25,040 --> 00:44:28,960
used by shellcodes so we are locating

1165
00:44:27,680 --> 00:44:32,399
process environment block

1166
00:44:28,960 --> 00:44:35,760
in memory and then finding loader data

1167
00:44:32,400 --> 00:44:39,200
and modules and kernel 32 module

1168
00:44:35,760 --> 00:44:43,200
and browse for for function addresses

1169
00:44:39,200 --> 00:44:47,279
so uh it's quite a

1170
00:44:43,200 --> 00:44:50,399
long code snippet here so uh

1171
00:44:47,280 --> 00:44:51,920
to briefly show what's going on in the

1172
00:44:50,400 --> 00:44:52,319
debugger we can see process environment

1173
00:44:51,920 --> 00:44:55,760
block

1174
00:44:52,319 --> 00:44:58,880
and among other

1175
00:44:55,760 --> 00:44:59,760
things there are there is loader data

1176
00:44:58,880 --> 00:45:02,480
and

1177
00:44:59,760 --> 00:45:03,119
information about loaded modules so we

1178
00:45:02,480 --> 00:45:07,280
can locate

1179
00:45:03,119 --> 00:45:10,960
kernel 32 others in memory and then find

1180
00:45:07,280 --> 00:45:12,079
in its export table get process address

1181
00:45:10,960 --> 00:45:14,400
function and any other

1182
00:45:12,079 --> 00:45:15,680
other functions and we then can

1183
00:45:14,400 --> 00:45:19,280
basically

1184
00:45:15,680 --> 00:45:21,680
load any function from from memory and

1185
00:45:19,280 --> 00:45:24,319
that's why nothing is visible in in the

1186
00:45:21,680 --> 00:45:24,319
import table

1187
00:45:25,119 --> 00:45:32,400
and another thing is api hashing

1188
00:45:29,119 --> 00:45:35,040
so for example if we don't want to use

1189
00:45:32,400 --> 00:45:35,920
function names in plain strings in the

1190
00:45:35,040 --> 00:45:39,759
executable

1191
00:45:35,920 --> 00:45:42,560
which are then located in in memory

1192
00:45:39,760 --> 00:45:43,440
we can use hashes of those names so for

1193
00:45:42,560 --> 00:45:46,799
example we can

1194
00:45:43,440 --> 00:45:49,040
use djp2 simple hash function

1195
00:45:46,800 --> 00:45:50,079
and precalculate hashes of function

1196
00:45:49,040 --> 00:45:53,759
names and then

1197
00:45:50,079 --> 00:45:54,960
just browse the exports of library and

1198
00:45:53,760 --> 00:45:56,880
find

1199
00:45:54,960 --> 00:45:58,720
and find names to have those names and

1200
00:45:56,880 --> 00:46:00,640
compare hashes with our functions and

1201
00:45:58,720 --> 00:46:02,480
that's how we can locate needed

1202
00:46:00,640 --> 00:46:04,640
functions and

1203
00:46:02,480 --> 00:46:05,760
on doing static analysis an analyst

1204
00:46:04,640 --> 00:46:07,839
won't see

1205
00:46:05,760 --> 00:46:09,440
those function names and we'll need to

1206
00:46:07,839 --> 00:46:12,480
run the executable to actually

1207
00:46:09,440 --> 00:46:15,119
find out what's uh

1208
00:46:12,480 --> 00:46:16,400
what functions are used or just to

1209
00:46:15,119 --> 00:46:20,240
calculate those hashes

1210
00:46:16,400 --> 00:46:21,839
so it's one of many many ways or an idea

1211
00:46:20,240 --> 00:46:25,200
is to to obfuscate the

1212
00:46:21,839 --> 00:46:25,200
the code so

1213
00:46:25,599 --> 00:46:30,240
that's it you can find a lot more of

1214
00:46:28,560 --> 00:46:33,279
samples on my blog

1215
00:46:30,240 --> 00:46:35,520
and i'm trying to regularly post some

1216
00:46:33,280 --> 00:46:36,319
uh some new articles regarding that i

1217
00:46:35,520 --> 00:46:39,440
hope you

1218
00:46:36,319 --> 00:46:42,079
found this interesting and

1219
00:46:39,440 --> 00:46:42,960
maybe someone would be interested in

1220
00:46:42,079 --> 00:46:45,200
some

1221
00:46:42,960 --> 00:46:47,599
longer workshop because it's there is a

1222
00:46:45,200 --> 00:46:50,560
material for i think

1223
00:46:47,599 --> 00:46:51,920
two or three days workshop not for a

1224
00:46:50,560 --> 00:46:55,359
short presentation so

1225
00:46:51,920 --> 00:46:58,160
anyway we try to uh

1226
00:46:55,359 --> 00:47:00,319
we hope you enjoyed the rest of the rest

1227
00:46:58,160 --> 00:47:03,359
of the conference and i think

1228
00:47:00,319 --> 00:47:07,279
yeah and i think

1229
00:47:03,359 --> 00:47:07,279
thank you for uh for watching us

1230
00:47:08,839 --> 00:47:11,839
bye

1231
00:47:13,119 --> 00:47:15,200
you

