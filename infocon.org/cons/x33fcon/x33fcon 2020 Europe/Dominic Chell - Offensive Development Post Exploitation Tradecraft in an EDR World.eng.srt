1
00:00:10,639 --> 00:00:13,599
today

2
00:00:11,120 --> 00:00:15,759
uh is entitled offensive development and

3
00:00:13,599 --> 00:00:17,440
post exploitation tradecraft in an edr

4
00:00:15,759 --> 00:00:19,840
world

5
00:00:17,440 --> 00:00:20,800
um so who am i um well my name is

6
00:00:19,840 --> 00:00:24,000
dominic chow

7
00:00:20,800 --> 00:00:26,640
i work for a company over in the uk

8
00:00:24,000 --> 00:00:28,640
uh called mdsec mainly focusing on

9
00:00:26,640 --> 00:00:31,760
offensive security

10
00:00:28,640 --> 00:00:33,040
um day to day uh my role is is

11
00:00:31,760 --> 00:00:35,680
relatively hands-on

12
00:00:33,040 --> 00:00:37,200
and so i spend most of my time um

13
00:00:35,680 --> 00:00:39,040
leading and executing red team

14
00:00:37,200 --> 00:00:41,360
operations for our clients

15
00:00:39,040 --> 00:00:44,719
and you can find me on twitter under the

16
00:00:41,360 --> 00:00:47,440
unimaginative handle of at domgel

17
00:00:44,719 --> 00:00:48,800
i try and also contribute to contribute

18
00:00:47,440 --> 00:00:52,399
back to the red team community

19
00:00:48,800 --> 00:00:54,640
so i'm quite active um on twitter on the

20
00:00:52,399 --> 00:00:55,920
mdsep blog so you can find some of

21
00:00:54,640 --> 00:00:58,559
some of my research and some of the

22
00:00:55,920 --> 00:01:00,320
blogs posts on that

23
00:00:58,559 --> 00:01:02,800
um so before i dive into the talk i'm

24
00:01:00,320 --> 00:01:05,920
going to start off with a little story

25
00:01:02,800 --> 00:01:08,960
um so let's say uh

26
00:01:05,920 --> 00:01:11,200
maybe this is atypical for many kind of

27
00:01:08,960 --> 00:01:13,919
red teams

28
00:01:11,200 --> 00:01:14,320
so maybe you've spent days um concocting

29
00:01:13,920 --> 00:01:17,680
the

30
00:01:14,320 --> 00:01:19,919
the perfect fish you've engaged the user

31
00:01:17,680 --> 00:01:22,000
um you finally got them to open that

32
00:01:19,920 --> 00:01:25,040
payload that you've weaponized and

33
00:01:22,000 --> 00:01:26,000
uh prepped to bypass edr and then you

34
00:01:25,040 --> 00:01:29,600
get your beacon check

35
00:01:26,000 --> 00:01:31,920
in and so what's next how do you operate

36
00:01:29,600 --> 00:01:33,520
well maybe um you want to do some basic

37
00:01:31,920 --> 00:01:35,439
situational awareness

38
00:01:33,520 --> 00:01:36,960
so maybe you check your privileges with

39
00:01:35,439 --> 00:01:38,798
things like who am i

40
00:01:36,960 --> 00:01:40,000
and maybe you check that you're on the

41
00:01:38,799 --> 00:01:43,280
right network on the right

42
00:01:40,000 --> 00:01:44,960
environment with things like ipconfig

43
00:01:43,280 --> 00:01:47,040
maybe you probe the endpoint a little

44
00:01:44,960 --> 00:01:50,240
bit trying to discover some

45
00:01:47,040 --> 00:01:51,759
documents that might be of interest

46
00:01:50,240 --> 00:01:53,839
and then once you've kind of you're

47
00:01:51,759 --> 00:01:55,600
happy that you're on the right endpoint

48
00:01:53,840 --> 00:01:57,040
and you you finish with it maybe you

49
00:01:55,600 --> 00:01:58,240
want to kind of move laterally

50
00:01:57,040 --> 00:02:00,880
so maybe you use something like

51
00:01:58,240 --> 00:02:02,320
bloodhound to gather information about

52
00:02:00,880 --> 00:02:03,920
the active directory and look for

53
00:02:02,320 --> 00:02:07,520
potential opportunities for

54
00:02:03,920 --> 00:02:09,199
actual movement and then finally

55
00:02:07,520 --> 00:02:11,519
uh you discover another system in the

56
00:02:09,199 --> 00:02:14,640
network where you've got admin rights

57
00:02:11,520 --> 00:02:16,480
and so maybe you um you want to move

58
00:02:14,640 --> 00:02:17,679
laterally so you upload a dll to the

59
00:02:16,480 --> 00:02:19,679
remote system

60
00:02:17,680 --> 00:02:20,800
uh to the remote host and then you stage

61
00:02:19,680 --> 00:02:24,959
it with something like

62
00:02:20,800 --> 00:02:27,440
one doll 32 or equivalent

63
00:02:24,959 --> 00:02:28,959
and then suddenly the beacon's gone it

64
00:02:27,440 --> 00:02:30,319
stops checking in

65
00:02:28,959 --> 00:02:31,840
uh you probably start to question

66
00:02:30,319 --> 00:02:32,799
yourself maybe the user went to a

67
00:02:31,840 --> 00:02:34,879
meeting

68
00:02:32,800 --> 00:02:36,720
and maybe they finished for the day you

69
00:02:34,879 --> 00:02:38,239
start to kind of wonder what's happened

70
00:02:36,720 --> 00:02:40,720
up until the client drops you that

71
00:02:38,239 --> 00:02:42,640
message saying oh sorry the blue team

72
00:02:40,720 --> 00:02:45,120
detected you and they've isolated your

73
00:02:42,640 --> 00:02:45,119
endpoint

74
00:02:45,360 --> 00:02:49,760
so at that point you may have spent um

75
00:02:48,160 --> 00:02:51,760
days or weeks

76
00:02:49,760 --> 00:02:53,040
and then suddenly you need to start over

77
00:02:51,760 --> 00:02:56,239
i'm sure this

78
00:02:53,040 --> 00:02:57,040
um situation has happened to almost all

79
00:02:56,239 --> 00:02:59,760
red teamers

80
00:02:57,040 --> 00:03:01,040
and it can be quite frustrating um so

81
00:02:59,760 --> 00:03:02,720
let's take a little look

82
00:03:01,040 --> 00:03:05,040
at what the blue team actually saw in

83
00:03:02,720 --> 00:03:07,200
this scenario and perhaps we can

84
00:03:05,040 --> 00:03:10,319
look at some potential approaches to

85
00:03:07,200 --> 00:03:13,040
improve our tradecraft

86
00:03:10,319 --> 00:03:15,359
okay so um firstly they've got an edr

87
00:03:13,040 --> 00:03:17,679
that captures process creation events

88
00:03:15,360 --> 00:03:18,800
and so they can see powershell spawning

89
00:03:17,680 --> 00:03:20,560
ip config

90
00:03:18,800 --> 00:03:21,920
they can see us running who am i they

91
00:03:20,560 --> 00:03:24,480
might be able to see us using

92
00:03:21,920 --> 00:03:26,559
uh you know various lol bins this of

93
00:03:24,480 --> 00:03:28,560
course doesn't blend in very well

94
00:03:26,560 --> 00:03:30,000
and will no doubt raise the threat

95
00:03:28,560 --> 00:03:31,519
profile of the endpoint

96
00:03:30,000 --> 00:03:34,480
particularly if the user has never won

97
00:03:31,519 --> 00:03:34,480
any of these before

98
00:03:34,640 --> 00:03:39,839
and ddr's also catching um etw

99
00:03:37,680 --> 00:03:41,360
events so they've seen all of our net

100
00:03:39,840 --> 00:03:42,959
tradecraft and this

101
00:03:41,360 --> 00:03:45,440
maybe they're even like baselining the

102
00:03:42,959 --> 00:03:46,560
processes that will load the clr so the

103
00:03:45,440 --> 00:03:49,599
fact that we've got

104
00:03:46,560 --> 00:03:52,319
w32 tms our spawn to process

105
00:03:49,599 --> 00:03:53,599
and it's loading the dot net runtime and

106
00:03:52,319 --> 00:03:57,040
this might in itself be

107
00:03:53,599 --> 00:03:58,079
an indicator um but then we've also got

108
00:03:57,040 --> 00:04:00,000
um things like

109
00:03:58,080 --> 00:04:01,680
and the sharp hound assembly names

110
00:04:00,000 --> 00:04:04,879
sitting uh it being

111
00:04:01,680 --> 00:04:06,879
communicated back through etw events so

112
00:04:04,879 --> 00:04:11,359
this is probably not ideal and probably

113
00:04:06,879 --> 00:04:11,359
stands out and if not it probably should

114
00:04:12,239 --> 00:04:16,160
um so perhaps some some elements of that

115
00:04:14,560 --> 00:04:19,199
story resonated with you

116
00:04:16,160 --> 00:04:22,240
um and that is the crux of my talk today

117
00:04:19,199 --> 00:04:24,080
um it's really that the defenses and the

118
00:04:22,240 --> 00:04:26,080
environments are becoming more mature

119
00:04:24,080 --> 00:04:27,599
and blue teams really have got that home

120
00:04:26,080 --> 00:04:29,359
field advantage

121
00:04:27,600 --> 00:04:30,880
as a red teamer there's a lot of

122
00:04:29,360 --> 00:04:32,720
different things that we actually need

123
00:04:30,880 --> 00:04:33,840
to deal with

124
00:04:32,720 --> 00:04:36,080
and at least most of the client

125
00:04:33,840 --> 00:04:38,159
environments that we uh kind of

126
00:04:36,080 --> 00:04:39,440
red team against and they'll have things

127
00:04:38,160 --> 00:04:41,840
like command line logging

128
00:04:39,440 --> 00:04:43,280
powershell logging and they'll have some

129
00:04:41,840 --> 00:04:46,479
boxes edr's

130
00:04:43,280 --> 00:04:49,599
um edps application whitelisting amz

131
00:04:46,479 --> 00:04:52,880
etw um all these kind of technologies

132
00:04:49,600 --> 00:04:54,160
um are basically creating a minefield of

133
00:04:52,880 --> 00:04:56,000
defenses that we

134
00:04:54,160 --> 00:04:58,240
we as a red team i need to navigate

135
00:04:56,000 --> 00:04:58,240
through

136
00:04:58,880 --> 00:05:02,880
and because of this um actually in order

137
00:05:01,039 --> 00:05:05,120
to be successful

138
00:05:02,880 --> 00:05:07,120
what we find is that as a red team we

139
00:05:05,120 --> 00:05:09,759
have um a growing

140
00:05:07,120 --> 00:05:11,680
investment in our operations and the

141
00:05:09,759 --> 00:05:14,800
last thing that we want to do

142
00:05:11,680 --> 00:05:17,919
really is have entire campaigns

143
00:05:14,800 --> 00:05:19,520
entire techniques or entire tools burned

144
00:05:17,919 --> 00:05:23,120
very quickly

145
00:05:19,520 --> 00:05:23,120
through incident response

146
00:05:23,280 --> 00:05:27,440
um so in this talk i plan to basically

147
00:05:26,479 --> 00:05:29,919
look at this problem

148
00:05:27,440 --> 00:05:30,639
in greater detail so i'll start off by

149
00:05:29,919 --> 00:05:32,240
examining

150
00:05:30,639 --> 00:05:34,240
some of the techniques that are used by

151
00:05:32,240 --> 00:05:36,479
blue teams to actually detect

152
00:05:34,240 --> 00:05:39,600
post-exploitation tradecraft

153
00:05:36,479 --> 00:05:40,800
um i'll look at uh once we've kind of

154
00:05:39,600 --> 00:05:43,440
looked at those

155
00:05:40,800 --> 00:05:45,280
i will um look at ways to actually go

156
00:05:43,440 --> 00:05:46,960
and understand how they're catching us

157
00:05:45,280 --> 00:05:50,159
and then potential ways

158
00:05:46,960 --> 00:05:52,799
and to evade these detections

159
00:05:50,160 --> 00:05:54,720
we don't just want to actually evade

160
00:05:52,800 --> 00:05:57,680
them but we also want to integrate

161
00:05:54,720 --> 00:05:59,280
these evasions into all of our tools so

162
00:05:57,680 --> 00:06:00,880
every tool that we run we want to

163
00:05:59,280 --> 00:06:04,239
basically bootstrap

164
00:06:00,880 --> 00:06:06,719
um these techniques into them

165
00:06:04,240 --> 00:06:08,639
um in addition to that i'll also cover

166
00:06:06,720 --> 00:06:08,960
um a few different approaches that we

167
00:06:08,639 --> 00:06:12,400
can

168
00:06:08,960 --> 00:06:14,239
leverage to um really better protect all

169
00:06:12,400 --> 00:06:15,758
our tools and intellectual property

170
00:06:14,240 --> 00:06:18,240
in scenarios where we do end up being

171
00:06:15,759 --> 00:06:21,199
detected and i'll try and and try and

172
00:06:18,240 --> 00:06:21,759
increase that time from detection to

173
00:06:21,199 --> 00:06:25,199
kind of

174
00:06:21,759 --> 00:06:25,199
um ejection really

175
00:06:25,280 --> 00:06:31,039
um so i'm going to start off initially

176
00:06:28,720 --> 00:06:33,360
looking at kind of historic tradecraft

177
00:06:31,039 --> 00:06:34,560
and and traditional trade crafters

178
00:06:33,360 --> 00:06:37,440
typically involved

179
00:06:34,560 --> 00:06:38,880
um running os commands on on the

180
00:06:37,440 --> 00:06:41,120
endpoint

181
00:06:38,880 --> 00:06:42,960
and so this might include things like

182
00:06:41,120 --> 00:06:45,120
leveraging wall but bins to perform

183
00:06:42,960 --> 00:06:46,799
certain actions so for example

184
00:06:45,120 --> 00:06:49,120
and maybe we want to actually download a

185
00:06:46,800 --> 00:06:50,400
file and so to do that you might use

186
00:06:49,120 --> 00:06:53,039
something like bits admin

187
00:06:50,400 --> 00:06:54,159
as a means to accomplish it now of

188
00:06:53,039 --> 00:06:56,159
course this is not a

189
00:06:54,160 --> 00:06:57,520
recommended approach for a mature

190
00:06:56,160 --> 00:06:59,759
environment

191
00:06:57,520 --> 00:07:01,120
and that's basically because the blue if

192
00:06:59,759 --> 00:07:02,720
the blue team is capturing process

193
00:07:01,120 --> 00:07:04,319
creation events they'll trivially be

194
00:07:02,720 --> 00:07:06,160
able to monitor and see everything that

195
00:07:04,319 --> 00:07:07,680
we're doing

196
00:07:06,160 --> 00:07:10,560
so one of the methodologies that i want

197
00:07:07,680 --> 00:07:12,880
to propose is can we actually abstract

198
00:07:10,560 --> 00:07:15,199
ourselves entirely from the concept

199
00:07:12,880 --> 00:07:16,880
can we actually only ever operate on an

200
00:07:15,199 --> 00:07:19,440
endpoint in code

201
00:07:16,880 --> 00:07:21,039
um now there have been some steps taken

202
00:07:19,440 --> 00:07:22,880
i do think the answer is yes and there

203
00:07:21,039 --> 00:07:25,120
have been some steps taken to

204
00:07:22,880 --> 00:07:26,000
move in this direction um so we've seen

205
00:07:25,120 --> 00:07:29,120
the introduction

206
00:07:26,000 --> 00:07:29,440
of um features such as execute assembly

207
00:07:29,120 --> 00:07:31,919
in

208
00:07:29,440 --> 00:07:33,280
cobalt strike which basically allows us

209
00:07:31,919 --> 00:07:36,880
to

210
00:07:33,280 --> 00:07:38,080
execute net tools um in unmanaged

211
00:07:36,880 --> 00:07:41,039
processes

212
00:07:38,080 --> 00:07:42,400
and we've also more recently seen the

213
00:07:41,039 --> 00:07:44,479
introduction of things like

214
00:07:42,400 --> 00:07:46,799
beacon object files which basically

215
00:07:44,479 --> 00:07:50,479
provide a an interface to execute

216
00:07:46,800 --> 00:07:50,479
and see code inside a process

217
00:07:52,160 --> 00:07:55,840
so i'm going to start off i'm looking at

218
00:07:54,319 --> 00:07:57,599
some

219
00:07:55,840 --> 00:08:01,198
different approaches for actually

220
00:07:57,599 --> 00:08:03,039
detecting uh net tradecraft

221
00:08:01,199 --> 00:08:04,319
and the reason we're starting to see

222
00:08:03,039 --> 00:08:06,960
this really is

223
00:08:04,319 --> 00:08:08,319
mainly because red teams moved over to

224
00:08:06,960 --> 00:08:10,878
2.net

225
00:08:08,319 --> 00:08:13,599
following the introduction of powershell

226
00:08:10,879 --> 00:08:16,400
defenses

227
00:08:13,599 --> 00:08:17,759
so this of course led to much more focus

228
00:08:16,400 --> 00:08:20,960
from the blue teams

229
00:08:17,759 --> 00:08:23,280
in in techniques to detect um

230
00:08:20,960 --> 00:08:24,560
dot-net post-exploitation tradecraft and

231
00:08:23,280 --> 00:08:27,198
one of these techniques

232
00:08:24,560 --> 00:08:28,960
um which is as documented in this great

233
00:08:27,199 --> 00:08:31,599
blog post by the guys from

234
00:08:28,960 --> 00:08:33,760
um from countercept f secure and

235
00:08:31,599 --> 00:08:35,360
basically shows how we can use um event

236
00:08:33,760 --> 00:08:39,120
tracing for windows

237
00:08:35,360 --> 00:08:41,279
to um to integrate it into our edrs and

238
00:08:39,120 --> 00:08:42,159
into our edr telemetry our blue team

239
00:08:41,279 --> 00:08:45,600
telemetry

240
00:08:42,159 --> 00:08:46,640
to actually go on and receive um clr

241
00:08:45,600 --> 00:08:49,200
runtime traces

242
00:08:46,640 --> 00:08:51,040
and through an etw consumer and this is

243
00:08:49,200 --> 00:08:54,080
really powerful because it can provide

244
00:08:51,040 --> 00:08:56,640
um deep visibility of all the assembly

245
00:08:54,080 --> 00:08:57,360
names name spaces class names method

246
00:08:56,640 --> 00:08:59,279
names

247
00:08:57,360 --> 00:09:00,640
and that are being run in in the dotnet

248
00:08:59,279 --> 00:09:02,399
runtime even

249
00:09:00,640 --> 00:09:04,240
through even when we're using like an

250
00:09:02,399 --> 00:09:04,880
unmanaged surrogate so using something

251
00:09:04,240 --> 00:09:08,160
like

252
00:09:04,880 --> 00:09:10,959
execute assembly um

253
00:09:08,160 --> 00:09:13,680
so the consequence of this really is the

254
00:09:10,959 --> 00:09:16,880
blue teams now have at their disposal

255
00:09:13,680 --> 00:09:19,120
tools like silky etw by fuzzysec

256
00:09:16,880 --> 00:09:21,519
um which can basically allow them to

257
00:09:19,120 --> 00:09:23,680
monitor all.net executions

258
00:09:21,519 --> 00:09:24,720
even in unmanaged processes and actually

259
00:09:23,680 --> 00:09:26,319
signature them so

260
00:09:24,720 --> 00:09:27,839
signature all the function calls and

261
00:09:26,320 --> 00:09:28,880
method names and class names and things

262
00:09:27,839 --> 00:09:33,040
that are being run

263
00:09:28,880 --> 00:09:35,200
looking for known um known.net tools

264
00:09:33,040 --> 00:09:36,079
and so that gives the blue team great

265
00:09:35,200 --> 00:09:39,839
insight

266
00:09:36,080 --> 00:09:41,600
to net post exploitation

267
00:09:39,839 --> 00:09:43,120
and so what are some approaches we can

268
00:09:41,600 --> 00:09:45,760
actually

269
00:09:43,120 --> 00:09:47,200
leverage to kind of evade or get around

270
00:09:45,760 --> 00:09:49,120
these detections

271
00:09:47,200 --> 00:09:51,200
um so the most obvious one and the most

272
00:09:49,120 --> 00:09:52,399
trivial one and to avoid at least

273
00:09:51,200 --> 00:09:54,800
signature detection

274
00:09:52,399 --> 00:09:57,040
is just to obfuscate the assemblies so

275
00:09:54,800 --> 00:10:00,079
um renaming the namespaces

276
00:09:57,040 --> 00:10:01,920
um the class names the method names um

277
00:10:00,080 --> 00:10:04,959
all this kind of stuff can actually help

278
00:10:01,920 --> 00:10:07,439
us and slip past some of the

279
00:10:04,959 --> 00:10:09,599
signature-based detections that um some

280
00:10:07,440 --> 00:10:12,320
of the blue team tools might be using

281
00:10:09,600 --> 00:10:13,839
um this is quite simple to do and we can

282
00:10:12,320 --> 00:10:17,200
take advantage of some of the open

283
00:10:13,839 --> 00:10:20,079
source obfuscators things like confuserx

284
00:10:17,200 --> 00:10:20,480
and these will actually help us to um

285
00:10:20,079 --> 00:10:24,319
change

286
00:10:20,480 --> 00:10:25,920
change up our binary before we run it

287
00:10:24,320 --> 00:10:27,600
and so as you can see here we've got a

288
00:10:25,920 --> 00:10:29,920
very simple example of

289
00:10:27,600 --> 00:10:31,519
how a safety caps assembly might look in

290
00:10:29,920 --> 00:10:33,519
the disassembler after it's been run

291
00:10:31,519 --> 00:10:35,040
through something like infuser x

292
00:10:33,519 --> 00:10:37,600
and as you can see it's much less

293
00:10:35,040 --> 00:10:40,160
signature friendly there's fewer strings

294
00:10:37,600 --> 00:10:42,079
than in the original unprotected binary

295
00:10:40,160 --> 00:10:45,360
so that's great we can we can now

296
00:10:42,079 --> 00:10:47,120
obfuscate all our binaries

297
00:10:45,360 --> 00:10:48,720
um another thing that we might want to

298
00:10:47,120 --> 00:10:52,000
do aside from obfuscation

299
00:10:48,720 --> 00:10:54,480
is potentially just try and stop the um

300
00:10:52,000 --> 00:10:55,200
the net assembly actually sending any

301
00:10:54,480 --> 00:10:58,240
etw

302
00:10:55,200 --> 00:10:59,600
events uh entirely um so we can actually

303
00:10:58,240 --> 00:11:00,000
do this and the reason for this is

304
00:10:59,600 --> 00:11:03,680
mainly

305
00:11:00,000 --> 00:11:04,800
because um the etw events are sent from

306
00:11:03,680 --> 00:11:06,399
user land

307
00:11:04,800 --> 00:11:08,800
and they're sent from a process that we

308
00:11:06,399 --> 00:11:10,959
have already got code execution inside

309
00:11:08,800 --> 00:11:12,880
and because inside.net we've got access

310
00:11:10,959 --> 00:11:16,319
to the full process

311
00:11:12,880 --> 00:11:18,240
memory we can actually just go on and

312
00:11:16,320 --> 00:11:19,519
simply patch the the relevant the

313
00:11:18,240 --> 00:11:22,800
functions that are

314
00:11:19,519 --> 00:11:24,160
relevant for sending etw events so for

315
00:11:22,800 --> 00:11:27,199
example

316
00:11:24,160 --> 00:11:30,319
inside ntdl there's the etw event

317
00:11:27,200 --> 00:11:32,480
write our function and if we patch this

318
00:11:30,320 --> 00:11:35,519
to just return we can basically

319
00:11:32,480 --> 00:11:38,560
remove that ability or visibility um

320
00:11:35,519 --> 00:11:41,680
of the etw events for for the bluetooth

321
00:11:38,560 --> 00:11:42,000
how that might look um if we've got a

322
00:11:41,680 --> 00:11:43,599
patch

323
00:11:42,000 --> 00:11:45,360
process so if we dive into it with

324
00:11:43,600 --> 00:11:46,800
something like process hacker

325
00:11:45,360 --> 00:11:48,800
we might see something like this where

326
00:11:46,800 --> 00:11:56,240
we haven't actually got any events

327
00:11:48,800 --> 00:12:00,399
um it being reported up to the consumer

328
00:11:56,240 --> 00:12:02,079
um so what other kind of tools um

329
00:12:00,399 --> 00:12:03,760
what other kind of techniques and things

330
00:12:02,079 --> 00:12:07,040
are available or at the

331
00:12:03,760 --> 00:12:11,120
team's um disposal for detecting

332
00:12:07,040 --> 00:12:13,360
our.net tradecraft well um

333
00:12:11,120 --> 00:12:14,720
version 4.8 of dotnet framework

334
00:12:13,360 --> 00:12:18,000
introduced damsy

335
00:12:14,720 --> 00:12:21,440
um and i'm sure many of you are

336
00:12:18,000 --> 00:12:22,639
are familiar with this um and basically

337
00:12:21,440 --> 00:12:25,360
it will be called

338
00:12:22,639 --> 00:12:26,639
amazing will be triggered any time a an

339
00:12:25,360 --> 00:12:28,079
assembly is loaded through something

340
00:12:26,639 --> 00:12:30,399
like assembly.load it will basically

341
00:12:28,079 --> 00:12:33,040
allow the av engine to go on and scan

342
00:12:30,399 --> 00:12:35,440
those bytes of memory

343
00:12:33,040 --> 00:12:37,680
this of course isn't a huge problem as i

344
00:12:35,440 --> 00:12:39,920
already mentioned.net exposes the full

345
00:12:37,680 --> 00:12:40,800
process memory so you can leverage one

346
00:12:39,920 --> 00:12:43,839
of the

347
00:12:40,800 --> 00:12:46,240
traditional amsi bypasses um something

348
00:12:43,839 --> 00:12:48,240
like uh the ansi scan buffer patch

349
00:12:46,240 --> 00:12:50,160
um which cable strike actually offers

350
00:12:48,240 --> 00:12:53,279
through the the ansi disable

351
00:12:50,160 --> 00:12:54,319
um marble profile uh malleable profile

352
00:12:53,279 --> 00:12:55,680
config option

353
00:12:54,320 --> 00:12:57,360
uh you can actually leverage this to

354
00:12:55,680 --> 00:13:00,560
just go on and patch um zoom

355
00:12:57,360 --> 00:13:02,800
now um that in itself is is you know

356
00:13:00,560 --> 00:13:05,599
fine from a renting perspective but

357
00:13:02,800 --> 00:13:06,079
inadvertently you might also be creating

358
00:13:05,600 --> 00:13:08,079
a

359
00:13:06,079 --> 00:13:09,439
an indicator of compromise because what

360
00:13:08,079 --> 00:13:10,880
we've started to see

361
00:13:09,440 --> 00:13:13,360
and there is a blog post referenced at

362
00:13:10,880 --> 00:13:16,320
the bottom by um the guys again from

363
00:13:13,360 --> 00:13:19,600
sql concepts and we started to see blue

364
00:13:16,320 --> 00:13:23,600
teams actually using memory scanners to

365
00:13:19,600 --> 00:13:25,519
hunt for modifications of um

366
00:13:23,600 --> 00:13:28,240
of code sections so basically looking

367
00:13:25,519 --> 00:13:31,040
for patches to ramsey dll and memory

368
00:13:28,240 --> 00:13:33,200
um so as a red teamer you might want to

369
00:13:31,040 --> 00:13:36,639
kind of leverage this technique

370
00:13:33,200 --> 00:13:39,279
cautiously and once you have leveraged

371
00:13:36,639 --> 00:13:42,720
it go on and restore the original values

372
00:13:39,279 --> 00:13:48,079
inside the ramsay dol to basically limit

373
00:13:42,720 --> 00:13:51,920
the the window for detection

374
00:13:48,079 --> 00:13:55,680
so aside from that how about actual um

375
00:13:51,920 --> 00:13:58,800
detecting actual tools so

376
00:13:55,680 --> 00:14:01,359
one of the one of the most common um

377
00:13:58,800 --> 00:14:03,199
clr harnesses that are used is the

378
00:14:01,360 --> 00:14:05,519
execute assembly method inside cable

379
00:14:03,199 --> 00:14:05,519
strike

380
00:14:05,600 --> 00:14:09,519
so i've mentioned this a couple of times

381
00:14:07,519 --> 00:14:12,880
um the way it basically works

382
00:14:09,519 --> 00:14:15,199
is um it will inject the clr into an

383
00:14:12,880 --> 00:14:17,519
unmanaged surrogate process

384
00:14:15,199 --> 00:14:19,040
and this is one of the probably the most

385
00:14:17,519 --> 00:14:22,560
widely used tools for

386
00:14:19,040 --> 00:14:24,480
um achieving um execution

387
00:14:22,560 --> 00:14:26,079
and now there's a few kind of techniques

388
00:14:24,480 --> 00:14:29,120
that the blue teams can

389
00:14:26,079 --> 00:14:32,239
employ to actually go on and and detect

390
00:14:29,120 --> 00:14:35,440
uh tools like execute assembly

391
00:14:32,240 --> 00:14:38,480
um so the first one um is basically

392
00:14:35,440 --> 00:14:39,839
down to the fork and run behavior and so

393
00:14:38,480 --> 00:14:41,839
as i mentioned before the way it works

394
00:14:39,839 --> 00:14:42,560
is it will spawn a new process injects

395
00:14:41,839 --> 00:14:45,839
the clr

396
00:14:42,560 --> 00:14:48,319
inside it now um that kind of behavior

397
00:14:45,839 --> 00:14:49,519
um from the blue team perspective you

398
00:14:48,320 --> 00:14:53,199
might want to actually

399
00:14:49,519 --> 00:14:55,040
look for suspicious process creations um

400
00:14:53,199 --> 00:14:57,599
anomalous parent-child relationship so

401
00:14:55,040 --> 00:15:00,079
it's potential to detect it that way

402
00:14:57,600 --> 00:15:01,600
um additionally there's no kind of etw

403
00:15:00,079 --> 00:15:05,439
bypasses built inside

404
00:15:01,600 --> 00:15:07,440
um execute assembly so um if you are if

405
00:15:05,440 --> 00:15:08,800
you have got an etw consumer you can

406
00:15:07,440 --> 00:15:11,279
collect all these events

407
00:15:08,800 --> 00:15:14,560
uh and look for the signatures and

408
00:15:11,279 --> 00:15:18,320
things that i kind of mentioned before

409
00:15:14,560 --> 00:15:20,800
um aside from that um we might also

410
00:15:18,320 --> 00:15:21,519
if we if we're monitoring for module

411
00:15:20,800 --> 00:15:23,839
loads

412
00:15:21,519 --> 00:15:24,720
uh is maintain like a baseline of

413
00:15:23,839 --> 00:15:27,199
processes

414
00:15:24,720 --> 00:15:28,399
that are actually loading the clr so

415
00:15:27,199 --> 00:15:31,040
that every time

416
00:15:28,399 --> 00:15:32,240
um execute assembly runs it will cause

417
00:15:31,040 --> 00:15:34,399
the clr to be

418
00:15:32,240 --> 00:15:35,600
loaded into the surrogate process and

419
00:15:34,399 --> 00:15:37,440
several modules

420
00:15:35,600 --> 00:15:40,079
um will actually be loaded inside the

421
00:15:37,440 --> 00:15:42,880
process so things like clrjit.dll

422
00:15:40,079 --> 00:15:45,040
and clr.dll and whatnot so if we're

423
00:15:42,880 --> 00:15:46,240
maintaining a baseline of processes that

424
00:15:45,040 --> 00:15:49,599
will legitimately

425
00:15:46,240 --> 00:15:51,759
load the clr and the um the operator is

426
00:15:49,600 --> 00:15:54,079
not blending in

427
00:15:51,759 --> 00:15:55,920
with that with their spawn2 then

428
00:15:54,079 --> 00:15:56,479
potentially we might have an indicator

429
00:15:55,920 --> 00:15:58,719
of

430
00:15:56,480 --> 00:16:01,519
um some dot net post exploitation uh

431
00:15:58,720 --> 00:16:01,519
behavior happening

432
00:16:01,600 --> 00:16:05,759
um and then finally i also spent some

433
00:16:04,240 --> 00:16:08,320
time actually digging into

434
00:16:05,759 --> 00:16:10,160
how execute assembly works and what i

435
00:16:08,320 --> 00:16:12,880
discovered were there are a number of

436
00:16:10,160 --> 00:16:15,759
specific iocs in this behavior

437
00:16:12,880 --> 00:16:17,680
so and because of this um fork and run

438
00:16:15,759 --> 00:16:20,079
kind of methodology that it uses

439
00:16:17,680 --> 00:16:22,880
um that basically means it's going to

440
00:16:20,079 --> 00:16:25,199
require process injection

441
00:16:22,880 --> 00:16:26,639
so um within cable strike you can

442
00:16:25,199 --> 00:16:28,240
actually customize

443
00:16:26,639 --> 00:16:30,000
the process injection techniques are

444
00:16:28,240 --> 00:16:32,959
malleable so you can customize them

445
00:16:30,000 --> 00:16:34,399
so you can control and things like the

446
00:16:32,959 --> 00:16:37,199
the page protections

447
00:16:34,399 --> 00:16:38,320
so for example you can basically say um

448
00:16:37,199 --> 00:16:40,240
a page

449
00:16:38,320 --> 00:16:42,160
should you know start read write execute

450
00:16:40,240 --> 00:16:45,279
or can be read or execute

451
00:16:42,160 --> 00:16:48,719
um or a page and you know can

452
00:16:45,279 --> 00:16:52,000
end up um read execute and this is done

453
00:16:48,720 --> 00:16:55,519
through the start rwx and uh use rwx

454
00:16:52,000 --> 00:16:56,399
model profile options um basically what

455
00:16:55,519 --> 00:16:59,440
that means

456
00:16:56,399 --> 00:17:03,199
is um that our net binary

457
00:16:59,440 --> 00:17:06,319
will um always be sitting um

458
00:17:03,199 --> 00:17:07,280
inside a page that is allocated read

459
00:17:06,319 --> 00:17:10,559
write execute

460
00:17:07,280 --> 00:17:13,760
or read execute in the surrogate process

461
00:17:10,559 --> 00:17:16,559
um so if as a blue team we start to

462
00:17:13,760 --> 00:17:18,400
hunt for um firstly processes that are

463
00:17:16,559 --> 00:17:19,918
loading the clr

464
00:17:18,400 --> 00:17:21,520
and secondly once we've found those

465
00:17:19,919 --> 00:17:24,400
processes um

466
00:17:21,520 --> 00:17:26,319
pages inside them that are our read

467
00:17:24,400 --> 00:17:29,840
write xq or read xq

468
00:17:26,319 --> 00:17:33,120
and have a net pe binary inside of them

469
00:17:29,840 --> 00:17:36,080
then we can actually not only detect

470
00:17:33,120 --> 00:17:36,879
um when a net post exploitation but we

471
00:17:36,080 --> 00:17:40,879
can also actually

472
00:17:36,880 --> 00:17:42,799
carve out the net pe and now

473
00:17:40,880 --> 00:17:44,080
you might think well what about things

474
00:17:42,799 --> 00:17:46,240
like um

475
00:17:44,080 --> 00:17:48,080
you know assembly.load when it happens

476
00:17:46,240 --> 00:17:50,720
legitimately inside the clr

477
00:17:48,080 --> 00:17:52,080
well actually just because of um the way

478
00:17:50,720 --> 00:17:54,000
the clr works

479
00:17:52,080 --> 00:17:55,120
um the pages with the things like

480
00:17:54,000 --> 00:17:57,600
assembly.load

481
00:17:55,120 --> 00:17:58,719
are never actually executable because

482
00:17:57,600 --> 00:18:01,678
they're jitted

483
00:17:58,720 --> 00:18:03,840
so um this at least from my testing this

484
00:18:01,679 --> 00:18:07,360
becomes a very specific behavior on

485
00:18:03,840 --> 00:18:09,678
on through execute assembly um and

486
00:18:07,360 --> 00:18:12,159
becomes a way to actually detect it

487
00:18:09,679 --> 00:18:15,080
so i can show you a demo of this um so

488
00:18:12,160 --> 00:18:18,080
i'm just going to try and uh

489
00:18:15,080 --> 00:18:18,080
screenshot

490
00:18:21,280 --> 00:18:32,160
um let's try this

491
00:18:28,640 --> 00:18:36,640
uh can

492
00:18:32,160 --> 00:18:36,640
can everybody see my video

493
00:18:38,799 --> 00:18:43,440
yes excellent okay i have videoed all

494
00:18:42,000 --> 00:18:44,160
these because i was a little bit nervous

495
00:18:43,440 --> 00:18:46,320
about uh

496
00:18:44,160 --> 00:18:48,320
doing them over a live stream um but

497
00:18:46,320 --> 00:18:50,399
basically um

498
00:18:48,320 --> 00:18:52,000
i've got a cable strike running with uh

499
00:18:50,400 --> 00:18:54,640
with a beacon up here

500
00:18:52,000 --> 00:18:55,919
and then i've got a very simple um i'm

501
00:18:54,640 --> 00:18:56,480
just showing you the code for a very

502
00:18:55,919 --> 00:19:00,000
simple

503
00:18:56,480 --> 00:19:01,600
uh.net binary uh dominic uh

504
00:19:00,000 --> 00:19:05,200
tool that we're gonna run through

505
00:19:01,600 --> 00:19:08,159
execute assembly on on the endpoint

506
00:19:05,200 --> 00:19:09,120
now all this tool does um as you can see

507
00:19:08,160 --> 00:19:13,520
is just sit there

508
00:19:09,120 --> 00:19:17,280
printing something to the console um so

509
00:19:13,520 --> 00:19:18,720
um basically i'm just gonna run this

510
00:19:17,280 --> 00:19:24,160
um so we're gonna run it on this

511
00:19:18,720 --> 00:19:26,480
endpoint through execute assembly

512
00:19:24,160 --> 00:19:28,000
okay and you'll see it all it does is

513
00:19:26,480 --> 00:19:29,360
just print sleeping the reason i've done

514
00:19:28,000 --> 00:19:31,840
this is just so we can

515
00:19:29,360 --> 00:19:32,479
uh leave the process running and and

516
00:19:31,840 --> 00:19:34,799
kind of

517
00:19:32,480 --> 00:19:37,200
show you how to kind of pull this out so

518
00:19:34,799 --> 00:19:41,480
uh inside the malleable profile the

519
00:19:37,200 --> 00:19:43,520
um the spawn tube is set to background

520
00:19:41,480 --> 00:19:45,840
taskhost.exe which we can see is now

521
00:19:43,520 --> 00:19:49,039
spawned in process hacker

522
00:19:45,840 --> 00:19:53,360
so um i wrote a tool called

523
00:19:49,039 --> 00:19:57,200
um sniper which um will basically

524
00:19:53,360 --> 00:19:59,280
scan all the processes on an endpoint

525
00:19:57,200 --> 00:20:01,200
um i'll just pause this here it will

526
00:19:59,280 --> 00:20:02,720
scan all the processes on an endpoint

527
00:20:01,200 --> 00:20:03,360
and it will look for the ones that are

528
00:20:02,720 --> 00:20:06,480
using

529
00:20:03,360 --> 00:20:08,799
uh that have clr.dll loaded

530
00:20:06,480 --> 00:20:10,320
and then when it when it finds those

531
00:20:08,799 --> 00:20:13,760
processes it will then

532
00:20:10,320 --> 00:20:17,120
walk through virtually allocated memory

533
00:20:13,760 --> 00:20:19,760
looking for pages with um

534
00:20:17,120 --> 00:20:20,879
read write execute or read execute page

535
00:20:19,760 --> 00:20:22,960
permissions

536
00:20:20,880 --> 00:20:24,960
and if it finds them it will then look

537
00:20:22,960 --> 00:20:28,400
at the start of those pages

538
00:20:24,960 --> 00:20:30,880
looking for pe binary headers okay

539
00:20:28,400 --> 00:20:32,880
and what you can see here is um the

540
00:20:30,880 --> 00:20:36,159
sniper tools basically found a process

541
00:20:32,880 --> 00:20:39,039
called background task host uh it's

542
00:20:36,159 --> 00:20:41,280
it's shown that it's loaded the clr.dll

543
00:20:39,039 --> 00:20:43,280
and then um

544
00:20:41,280 --> 00:20:44,480
about midway through on this command

545
00:20:43,280 --> 00:20:46,480
prompt it says foundp

546
00:20:44,480 --> 00:20:49,039
binary in region and let's give the base

547
00:20:46,480 --> 00:20:50,000
address and then it says carving pe from

548
00:20:49,039 --> 00:20:52,879
memory

549
00:20:50,000 --> 00:20:53,520
so um i'll let this i'll let this run

550
00:20:52,880 --> 00:20:55,280
through

551
00:20:53,520 --> 00:20:57,280
um just this bit that i've highlighted

552
00:20:55,280 --> 00:20:59,280
here um

553
00:20:57,280 --> 00:21:00,639
so if we take a look at that actual page

554
00:20:59,280 --> 00:21:02,158
in memory

555
00:21:00,640 --> 00:21:03,840
so i'm just going to use process hacker

556
00:21:02,159 --> 00:21:06,880
to actually uh

557
00:21:03,840 --> 00:21:09,360
find the right uh

558
00:21:06,880 --> 00:21:09,360
page

559
00:21:10,960 --> 00:21:16,240
so just just here so

560
00:21:14,400 --> 00:21:17,840
just pause this here so um i've used

561
00:21:16,240 --> 00:21:20,159
process hacker basically just to

562
00:21:17,840 --> 00:21:22,158
show you what the memory looks like uh

563
00:21:20,159 --> 00:21:23,280
and at the page that it's identified we

564
00:21:22,159 --> 00:21:26,960
can see we've actually got

565
00:21:23,280 --> 00:21:30,000
a um a pe binary you know which is

566
00:21:26,960 --> 00:21:31,440
um has been caught using the sniper tool

567
00:21:30,000 --> 00:21:32,320
has actually been carved and written to

568
00:21:31,440 --> 00:21:34,880
disk

569
00:21:32,320 --> 00:21:37,200
so um we can take a look at that actual

570
00:21:34,880 --> 00:21:37,200
pe

571
00:21:38,960 --> 00:21:42,640
so you can see here it writes it to a

572
00:21:40,799 --> 00:21:44,639
file called out.exe

573
00:21:42,640 --> 00:21:45,840
and so if i run this now obviously i

574
00:21:44,640 --> 00:21:47,760
wouldn't recommend running

575
00:21:45,840 --> 00:21:49,120
any arbitrary p you've just called from

576
00:21:47,760 --> 00:21:50,480
memory on um

577
00:21:49,120 --> 00:21:52,158
in a real kind of bluetooth

578
00:21:50,480 --> 00:21:54,080
investigation but given i know what it

579
00:21:52,159 --> 00:21:56,960
is you know it's relatively safe to do

580
00:21:54,080 --> 00:21:58,320
we can see it's actually the original um

581
00:21:56,960 --> 00:22:00,240
net pe binary

582
00:21:58,320 --> 00:22:02,000
that we run through cobalt strike with

583
00:22:00,240 --> 00:22:04,960
execute assembly

584
00:22:02,000 --> 00:22:06,000
so now we've got um a great way to not

585
00:22:04,960 --> 00:22:10,559
only detect

586
00:22:06,000 --> 00:22:13,200
um execute assembly but also um

587
00:22:10,559 --> 00:22:14,080
recover the binaries that are being run

588
00:22:13,200 --> 00:22:17,280
um

589
00:22:14,080 --> 00:22:17,280
through it through global strike

590
00:22:24,840 --> 00:22:29,199
okay

591
00:22:26,159 --> 00:22:30,320
so uh hopefully you can see the slides

592
00:22:29,200 --> 00:22:33,520
again now

593
00:22:30,320 --> 00:22:37,120
um so

594
00:22:33,520 --> 00:22:38,240
as a if we're if we're a red teamer and

595
00:22:37,120 --> 00:22:41,439
we're looking to actually

596
00:22:38,240 --> 00:22:43,840
improve our tradecraft um

597
00:22:41,440 --> 00:22:46,240
with execute assembly and there's a

598
00:22:43,840 --> 00:22:48,879
couple of things that we might want to

599
00:22:46,240 --> 00:22:50,480
consider so firstly we might want to

600
00:22:48,880 --> 00:22:52,080
actually try and select

601
00:22:50,480 --> 00:22:55,039
a surrogate process that will

602
00:22:52,080 --> 00:22:57,760
legitimately be loading the clr

603
00:22:55,039 --> 00:22:59,760
and this can help us avoid those clr

604
00:22:57,760 --> 00:23:02,799
load baselines

605
00:22:59,760 --> 00:23:06,000
secondly we might actually want to um

606
00:23:02,799 --> 00:23:09,039
stomp the net pe headers

607
00:23:06,000 --> 00:23:10,480
inside that inside of our net binary

608
00:23:09,039 --> 00:23:13,280
um because they're not actually even

609
00:23:10,480 --> 00:23:16,320
used uh and then we might want to

610
00:23:13,280 --> 00:23:18,559
um actually go on uh and reset the page

611
00:23:16,320 --> 00:23:21,520
permissions so maybe we want to

612
00:23:18,559 --> 00:23:23,520
reset them to bleed right so that we

613
00:23:21,520 --> 00:23:25,120
actually blend in with the behavior of

614
00:23:23,520 --> 00:23:26,960
things like assembly.load

615
00:23:25,120 --> 00:23:29,280
because as i mentioned before uh the

616
00:23:26,960 --> 00:23:30,720
page never actually needs to be execute

617
00:23:29,280 --> 00:23:33,200
never needs to actually have the execute

618
00:23:30,720 --> 00:23:35,360
permission because um the clr will jit

619
00:23:33,200 --> 00:23:35,360
it

620
00:23:35,440 --> 00:23:38,799
um so how can we actually go and find

621
00:23:38,080 --> 00:23:42,320
suitable

622
00:23:38,799 --> 00:23:45,760
um pro surrogate processors um well

623
00:23:42,320 --> 00:23:49,200
i i did this using sysmon um so

624
00:23:45,760 --> 00:23:51,919
um sysmon event id 7

625
00:23:49,200 --> 00:23:52,640
will basically show module loads so we

626
00:23:51,919 --> 00:23:55,279
can use

627
00:23:52,640 --> 00:23:56,799
sysmon offensively to actually go on and

628
00:23:55,279 --> 00:23:59,840
look for processes

629
00:23:56,799 --> 00:24:01,039
and that are loading the clr so a good

630
00:23:59,840 --> 00:24:03,120
example of this

631
00:24:01,039 --> 00:24:07,679
is background test case which you can

632
00:24:03,120 --> 00:24:07,678
see is loading the clr.dll

633
00:24:08,240 --> 00:24:11,600
so this might potentially be a good

634
00:24:09,760 --> 00:24:13,200
option to use in our

635
00:24:11,600 --> 00:24:15,760
in our spawn2 configuration within

636
00:24:13,200 --> 00:24:18,960
cobalt strike

637
00:24:15,760 --> 00:24:20,720
um secondly um

638
00:24:18,960 --> 00:24:22,320
if we want to actually stomp the pe

639
00:24:20,720 --> 00:24:24,960
headers um again

640
00:24:22,320 --> 00:24:26,080
what we can do is bootstrap um something

641
00:24:24,960 --> 00:24:28,960
like this

642
00:24:26,080 --> 00:24:29,918
into our net code so we would bootstrap

643
00:24:28,960 --> 00:24:32,320
this into every

644
00:24:29,919 --> 00:24:34,559
net binary that we run and this will

645
00:24:32,320 --> 00:24:35,039
basically just firstly recover the base

646
00:24:34,559 --> 00:24:38,320
address

647
00:24:35,039 --> 00:24:39,279
of the process it will then um overwrite

648
00:24:38,320 --> 00:24:42,240
the first

649
00:24:39,279 --> 00:24:43,039
132 bytes of memory um from the base

650
00:24:42,240 --> 00:24:45,840
address

651
00:24:43,039 --> 00:24:46,559
and such that it basically nukes the pe

652
00:24:45,840 --> 00:24:48,799
header

653
00:24:46,559 --> 00:24:50,240
uh and then we would go on and reset

654
00:24:48,799 --> 00:24:52,639
those pay permissions to be

655
00:24:50,240 --> 00:24:53,279
um read write and this might actually

656
00:24:52,640 --> 00:24:57,279
help us

657
00:24:53,279 --> 00:24:58,559
avoid um detection from um

658
00:24:57,279 --> 00:25:00,400
you know memory scanners that are

659
00:24:58,559 --> 00:25:03,918
looking for

660
00:25:00,400 --> 00:25:03,919
net binaries in memory

661
00:25:04,320 --> 00:25:09,678
um so i guess like

662
00:25:07,760 --> 00:25:11,520
to summarize like what i'm trying to

663
00:25:09,679 --> 00:25:13,120
show or trying to say

664
00:25:11,520 --> 00:25:14,799
um and we've covered a few different

665
00:25:13,120 --> 00:25:17,439
evasions there and

666
00:25:14,799 --> 00:25:18,320
to actually go on and maximize our net

667
00:25:17,440 --> 00:25:21,039
tradecraft

668
00:25:18,320 --> 00:25:22,720
we might want to um you know we might

669
00:25:21,039 --> 00:25:25,120
need to bypass amsi

670
00:25:22,720 --> 00:25:26,880
we might need to bypass etw we might

671
00:25:25,120 --> 00:25:29,360
need to stomp pe headers

672
00:25:26,880 --> 00:25:31,520
we might need to reset page permissions

673
00:25:29,360 --> 00:25:34,320
we might need to obfuscate our binaries

674
00:25:31,520 --> 00:25:35,440
so a lot of different things that we

675
00:25:34,320 --> 00:25:38,639
might need to do

676
00:25:35,440 --> 00:25:39,520
to try and keep our net post

677
00:25:38,640 --> 00:25:42,480
exploitation

678
00:25:39,520 --> 00:25:43,600
tradecraft invisible if we're trying to

679
00:25:42,480 --> 00:25:46,400
actually manually

680
00:25:43,600 --> 00:25:48,240
apply these and to every net assembly

681
00:25:46,400 --> 00:25:49,840
that we run it's probably not going to

682
00:25:48,240 --> 00:25:51,919
be feasible

683
00:25:49,840 --> 00:25:52,959
um so i guess like fundamentally what

684
00:25:51,919 --> 00:25:55,120
i'm trying to

685
00:25:52,960 --> 00:25:56,000
show is that because we want to

686
00:25:55,120 --> 00:25:59,199
bootstrap all

687
00:25:56,000 --> 00:26:00,000
our code and dynamically build all our

688
00:25:59,200 --> 00:26:03,440
code

689
00:26:00,000 --> 00:26:06,559
um then in an automated way this is very

690
00:26:03,440 --> 00:26:10,240
much in in the devops territory

691
00:26:06,559 --> 00:26:11,039
um so i started to kind of look at this

692
00:26:10,240 --> 00:26:14,240
problem

693
00:26:11,039 --> 00:26:15,600
um and it seemed to me um that the best

694
00:26:14,240 --> 00:26:18,400
solution

695
00:26:15,600 --> 00:26:19,199
was to actually try and integrate all my

696
00:26:18,400 --> 00:26:21,760
tools

697
00:26:19,200 --> 00:26:24,000
um inside the ci cd pipeline and that

698
00:26:21,760 --> 00:26:26,799
would hopefully allow me to

699
00:26:24,000 --> 00:26:28,720
weaponize them on every build and before

700
00:26:26,799 --> 00:26:30,720
i dive into my approach and the tools

701
00:26:28,720 --> 00:26:32,559
that i kind of created to do this

702
00:26:30,720 --> 00:26:34,080
um there has been some work in in this

703
00:26:32,559 --> 00:26:34,960
space already which you should probably

704
00:26:34,080 --> 00:26:36,720
recognize

705
00:26:34,960 --> 00:26:39,039
so firstly um there was a really

706
00:26:36,720 --> 00:26:40,640
interesting blog post from uh from adam

707
00:26:39,039 --> 00:26:42,240
called building modifying and packing

708
00:26:40,640 --> 00:26:45,760
with azor devops

709
00:26:42,240 --> 00:26:48,240
uh and secondly um there was also some

710
00:26:45,760 --> 00:26:49,120
another blog post uh on the md set blog

711
00:26:48,240 --> 00:26:51,120
um

712
00:26:49,120 --> 00:26:53,199
called offensive development with uh

713
00:26:51,120 --> 00:26:57,199
github action actions which again

714
00:26:53,200 --> 00:26:57,760
um uses this um ci cd pipeline approach

715
00:26:57,200 --> 00:26:59,520
to

716
00:26:57,760 --> 00:27:00,799
automatically build and obfuscate all

717
00:26:59,520 --> 00:27:04,879
your tools

718
00:27:00,799 --> 00:27:06,639
um but for me rather than trying to use

719
00:27:04,880 --> 00:27:07,919
something like one of the existing

720
00:27:06,640 --> 00:27:11,200
pipelines something like

721
00:27:07,919 --> 00:27:12,880
github actions or devops um the approach

722
00:27:11,200 --> 00:27:15,760
i took was basically

723
00:27:12,880 --> 00:27:17,440
to try and build my own custom one and

724
00:27:15,760 --> 00:27:19,679
the reason for this was mainly because

725
00:27:17,440 --> 00:27:21,600
it would give me greater flexibility

726
00:27:19,679 --> 00:27:22,720
and it would also allow me to easily

727
00:27:21,600 --> 00:27:26,158
integrate

728
00:27:22,720 --> 00:27:29,120
other third-party tools and

729
00:27:26,159 --> 00:27:30,000
so to to do this i basically ended up

730
00:27:29,120 --> 00:27:33,520
building

731
00:27:30,000 --> 00:27:35,600
a net core web api project

732
00:27:33,520 --> 00:27:37,200
the reason i chose.net core was um

733
00:27:35,600 --> 00:27:38,158
because it was you know it's platform

734
00:27:37,200 --> 00:27:40,720
agnostic

735
00:27:38,159 --> 00:27:42,000
and you can use it in docker um and it's

736
00:27:40,720 --> 00:27:44,880
also got a really

737
00:27:42,000 --> 00:27:45,679
cool compiler built inside it um called

738
00:27:44,880 --> 00:27:47,840
roslyn

739
00:27:45,679 --> 00:27:49,120
and which basically acts at least in my

740
00:27:47,840 --> 00:27:51,600
projects as the the core

741
00:27:49,120 --> 00:27:53,360
engine for building and manipulating all

742
00:27:51,600 --> 00:27:56,000
my tools

743
00:27:53,360 --> 00:27:57,120
uh and then finally um i was also

744
00:27:56,000 --> 00:28:00,000
actually able to

745
00:27:57,120 --> 00:28:01,279
integrate my tool this pipeline with

746
00:28:00,000 --> 00:28:05,039
things like donut

747
00:28:01,279 --> 00:28:08,000
so um that basically then gave me the

748
00:28:05,039 --> 00:28:09,039
ability using um donuts.net core

749
00:28:08,000 --> 00:28:11,919
bindings

750
00:28:09,039 --> 00:28:13,200
to actually turn any of my projects or

751
00:28:11,919 --> 00:28:16,159
any of my code

752
00:28:13,200 --> 00:28:18,159
um into shell code um so that basically

753
00:28:16,159 --> 00:28:20,880
means that i can also use them

754
00:28:18,159 --> 00:28:23,840
um within a custom any kind of custom

755
00:28:20,880 --> 00:28:23,840
loaders that i might have

756
00:28:24,480 --> 00:28:29,919
um so the project that i um created um

757
00:28:28,240 --> 00:28:32,080
the pipeline that i created was um

758
00:28:29,919 --> 00:28:35,279
basically a tool called um

759
00:28:32,080 --> 00:28:37,918
covert toolsmith um i'm hoping to

760
00:28:35,279 --> 00:28:38,399
actually um release this at some point

761
00:28:37,919 --> 00:28:40,640
uh

762
00:28:38,399 --> 00:28:42,639
in the near future and so there's three

763
00:28:40,640 --> 00:28:46,399
kind of core components to it

764
00:28:42,640 --> 00:28:47,919
so firstly there's a loader um which

765
00:28:46,399 --> 00:28:50,559
ends up getting run on the target

766
00:28:47,919 --> 00:28:52,960
endpoint i'm using a clr harness so

767
00:28:50,559 --> 00:28:54,639
something like execute assembly or any

768
00:28:52,960 --> 00:28:55,919
kind of custom clr harness that you

769
00:28:54,640 --> 00:28:58,159
might have

770
00:28:55,919 --> 00:28:59,760
and this is basically what is used to um

771
00:28:58,159 --> 00:29:02,880
bootstrap all the code

772
00:28:59,760 --> 00:29:05,440
and so you can use it for um adding like

773
00:29:02,880 --> 00:29:08,480
bootstrapping an etw bypass or

774
00:29:05,440 --> 00:29:12,080
um you know keying your binary

775
00:29:08,480 --> 00:29:13,039
um before it actually gets run i'll talk

776
00:29:12,080 --> 00:29:14,879
a little bit

777
00:29:13,039 --> 00:29:16,320
in more detail around how that works

778
00:29:14,880 --> 00:29:18,880
later

779
00:29:16,320 --> 00:29:20,080
um then there's also the projects so

780
00:29:18,880 --> 00:29:22,159
these are basically

781
00:29:20,080 --> 00:29:23,600
all the kind of.net tools whether those

782
00:29:22,159 --> 00:29:25,200
you know public tools or whether they're

783
00:29:23,600 --> 00:29:28,000
your own kind of in-house

784
00:29:25,200 --> 00:29:28,640
custom tools so things like a ghost pack

785
00:29:28,000 --> 00:29:30,880
or maybe

786
00:29:28,640 --> 00:29:32,480
any kind of artifact loaders and things

787
00:29:30,880 --> 00:29:34,080
that we might want to drop to disk or

788
00:29:32,480 --> 00:29:35,919
execute in memory

789
00:29:34,080 --> 00:29:38,399
um and then the final component is the

790
00:29:35,919 --> 00:29:41,760
actual engines this is basically the

791
00:29:38,399 --> 00:29:43,439
the.net core uh web api that will

792
00:29:41,760 --> 00:29:45,279
receive requests for projects it will

793
00:29:43,440 --> 00:29:45,840
consume it will then go on and consume

794
00:29:45,279 --> 00:29:48,240
the project

795
00:29:45,840 --> 00:29:49,439
source code and bootstrap them compile

796
00:29:48,240 --> 00:29:51,679
them uh protect

797
00:29:49,440 --> 00:29:52,640
those binaries and then return the

798
00:29:51,679 --> 00:29:55,520
compiled

799
00:29:52,640 --> 00:29:57,679
and encrypted project back to um back to

800
00:29:55,520 --> 00:30:00,000
the user back to the loader

801
00:29:57,679 --> 00:30:01,440
um the loader and there is like a lot of

802
00:30:00,000 --> 00:30:03,200
flexibility in this i've

803
00:30:01,440 --> 00:30:05,520
kind of tried to build it um such that

804
00:30:03,200 --> 00:30:06,799
you could use it in different ways

805
00:30:05,520 --> 00:30:08,639
because it's all done through it through

806
00:30:06,799 --> 00:30:10,879
api requests um

807
00:30:08,640 --> 00:30:12,480
but basically the loader is optional um

808
00:30:10,880 --> 00:30:13,120
so you can if you wanted to say just

809
00:30:12,480 --> 00:30:16,720
recover

810
00:30:13,120 --> 00:30:18,959
um an obfuscated or keyed uh copy of

811
00:30:16,720 --> 00:30:20,960
like rubust or a copy of

812
00:30:18,960 --> 00:30:23,039
um you know whatever you whatever

813
00:30:20,960 --> 00:30:25,039
project you could do that

814
00:30:23,039 --> 00:30:27,200
and then you could run it on an endpoint

815
00:30:25,039 --> 00:30:29,919
or you could use it with a clr harness

816
00:30:27,200 --> 00:30:30,799
however you wanted to approach it really

817
00:30:29,919 --> 00:30:33,600
um

818
00:30:30,799 --> 00:30:35,279
so the architecture looks a little bit

819
00:30:33,600 --> 00:30:37,520
like this and this is like a

820
00:30:35,279 --> 00:30:38,960
an example of one way you might want to

821
00:30:37,520 --> 00:30:42,158
you might be able to use it

822
00:30:38,960 --> 00:30:45,440
so i also tried to make it um like

823
00:30:42,159 --> 00:30:46,880
c2 agnostic um because because it is

824
00:30:45,440 --> 00:30:47,600
just a web api so as long as there's

825
00:30:46,880 --> 00:30:49,840
some way to

826
00:30:47,600 --> 00:30:51,360
script inside your c2 then you could

827
00:30:49,840 --> 00:30:53,360
basically take advantage of it because

828
00:30:51,360 --> 00:30:55,520
we we use multiple c2s and

829
00:30:53,360 --> 00:30:57,039
uh we've got our own uh implant and

830
00:30:55,520 --> 00:30:59,039
things as well so

831
00:30:57,039 --> 00:31:00,640
um but if you're using it with something

832
00:30:59,039 --> 00:31:01,840
like cobalt strike i basically wrote

833
00:31:00,640 --> 00:31:05,440
like an aggressive script

834
00:31:01,840 --> 00:31:08,480
um that will firstly make a request

835
00:31:05,440 --> 00:31:11,039
um to the covert toolsmith api

836
00:31:08,480 --> 00:31:11,760
um saying i want this tool whether that

837
00:31:11,039 --> 00:31:15,120
tool is

838
00:31:11,760 --> 00:31:17,600
um you know safetycats rubus or whatever

839
00:31:15,120 --> 00:31:19,199
you know projects that you want and then

840
00:31:17,600 --> 00:31:21,840
curve toolsmith will um

841
00:31:19,200 --> 00:31:23,919
build that tool modify it obfuscate it

842
00:31:21,840 --> 00:31:26,879
and bootstrap it as needed

843
00:31:23,919 --> 00:31:27,600
uh return that tool to the um to the

844
00:31:26,880 --> 00:31:30,720
actual

845
00:31:27,600 --> 00:31:33,519
the c2 client uh and then

846
00:31:30,720 --> 00:31:35,120
the c2 claim can basically use run that

847
00:31:33,519 --> 00:31:37,440
however you want it can

848
00:31:35,120 --> 00:31:39,518
um you deliver it to the endpoint and

849
00:31:37,440 --> 00:31:41,279
use like a custom clr harness or use

850
00:31:39,519 --> 00:31:43,279
execute assembly whatever whatever

851
00:31:41,279 --> 00:31:46,720
um you know kind of harness you want to

852
00:31:43,279 --> 00:31:47,679
actually use to execute it i'll show you

853
00:31:46,720 --> 00:31:50,000
a little example

854
00:31:47,679 --> 00:31:52,960
uh in a few slides time so you can kind

855
00:31:50,000 --> 00:31:55,519
of get an idea of how it actually works

856
00:31:52,960 --> 00:31:56,559
and then in the end the actual compiled

857
00:31:55,519 --> 00:31:59,440
and protected tool

858
00:31:56,559 --> 00:32:00,799
is um run on the actual endpoint in

859
00:31:59,440 --> 00:32:02,960
memory

860
00:32:00,799 --> 00:32:04,559
um and it might say for example if it's

861
00:32:02,960 --> 00:32:06,880
keyed to that endpoint

862
00:32:04,559 --> 00:32:08,639
it can uh brute force its own decryption

863
00:32:06,880 --> 00:32:11,200
key and run it in memory there

864
00:32:08,640 --> 00:32:12,720
um it can apply the etw bypasses and

865
00:32:11,200 --> 00:32:14,960
things anything that's been bootstrapped

866
00:32:12,720 --> 00:32:18,640
onto it

867
00:32:14,960 --> 00:32:20,399
um in order to kind of um

868
00:32:18,640 --> 00:32:22,000
build tools there is a little bit of

869
00:32:20,399 --> 00:32:24,320
configuration that needs to happen

870
00:32:22,000 --> 00:32:25,919
in advance and basically what we need to

871
00:32:24,320 --> 00:32:28,158
do is tell rosalind

872
00:32:25,919 --> 00:32:30,480
and the resources that are required to

873
00:32:28,159 --> 00:32:32,799
actually go on and compile that tool

874
00:32:30,480 --> 00:32:34,559
and so every project has got a little

875
00:32:32,799 --> 00:32:36,080
json configuration file that is

876
00:32:34,559 --> 00:32:38,158
associated with it

877
00:32:36,080 --> 00:32:39,199
and it basically says in this example

878
00:32:38,159 --> 00:32:41,600
when you compile

879
00:32:39,200 --> 00:32:42,559
uh this project uh use all these

880
00:32:41,600 --> 00:32:46,320
references

881
00:32:42,559 --> 00:32:48,799
um to um to basically build it

882
00:32:46,320 --> 00:32:50,559
uh and then each of these config files

883
00:32:48,799 --> 00:32:52,399
are serialized and stored in like a

884
00:32:50,559 --> 00:32:54,399
small sqlite database that is

885
00:32:52,399 --> 00:32:55,439
uh within the uh within the docker

886
00:32:54,399 --> 00:32:58,799
container

887
00:32:55,440 --> 00:33:00,559
um and these are basically then accessed

888
00:32:58,799 --> 00:33:03,760
on every compilation request

889
00:33:00,559 --> 00:33:04,158
for that project and so i'll show you

890
00:33:03,760 --> 00:33:07,440
again

891
00:33:04,159 --> 00:33:12,320
a little demo of how we can run

892
00:33:07,440 --> 00:33:12,320
a.net tool i'm using this this pipeline

893
00:33:19,919 --> 00:33:24,080
so hopefully uh everybody can see that i

894
00:33:22,399 --> 00:33:26,320
can see there's like um

895
00:33:24,080 --> 00:33:27,760
i can see there's a few questions uh i

896
00:33:26,320 --> 00:33:30,960
will um

897
00:33:27,760 --> 00:33:33,860
i will kind of address these at the end

898
00:33:30,960 --> 00:33:36,640
um so

899
00:33:33,860 --> 00:33:38,639
[Music]

900
00:33:36,640 --> 00:33:40,399
um so firstly i'm just going to reset

901
00:33:38,640 --> 00:33:43,600
the uh the parent process

902
00:33:40,399 --> 00:33:45,600
um basically just so we can see

903
00:33:43,600 --> 00:33:47,519
what i'm going to i can i'm going to

904
00:33:45,600 --> 00:33:49,600
show you how this works in that and

905
00:33:47,519 --> 00:33:50,880
if we were using something like execute

906
00:33:49,600 --> 00:33:53,600
assembly um

907
00:33:50,880 --> 00:33:54,559
it would spawn a new process um where

908
00:33:53,600 --> 00:33:56,639
the

909
00:33:54,559 --> 00:33:57,840
the the child process whatever's defined

910
00:33:56,640 --> 00:34:01,279
then i'll spawn to

911
00:33:57,840 --> 00:34:01,918
um is uh associated with the parent of

912
00:34:01,279 --> 00:34:03,360
beacon

913
00:34:01,919 --> 00:34:05,360
uh because we're not doing any pupid

914
00:34:03,360 --> 00:34:06,639
spoofing so i'm just gonna show you this

915
00:34:05,360 --> 00:34:08,799
initially

916
00:34:06,640 --> 00:34:10,480
and to show you how how it might work

917
00:34:08,800 --> 00:34:12,720
with execute assembly

918
00:34:10,480 --> 00:34:13,760
so i'm going to run a binary and we can

919
00:34:12,719 --> 00:34:15,598
see we've run

920
00:34:13,760 --> 00:34:16,879
um you can see on the left hand side

921
00:34:15,599 --> 00:34:20,079
we've run rubus

922
00:34:16,879 --> 00:34:20,879
uh and on the let's just backtrack a

923
00:34:20,079 --> 00:34:22,800
second

924
00:34:20,879 --> 00:34:24,639
uh on the right hand side and pro side

925
00:34:22,800 --> 00:34:25,280
process hacker we've got background task

926
00:34:24,639 --> 00:34:28,639
host

927
00:34:25,280 --> 00:34:31,119
um spawning as a child of beacon.exe

928
00:34:28,639 --> 00:34:32,720
okay so that that is not ideal um so

929
00:34:31,119 --> 00:34:35,040
what i'm going to show you now

930
00:34:32,719 --> 00:34:36,239
is i'm actually running using covert

931
00:34:35,040 --> 00:34:39,199
toolsmith

932
00:34:36,239 --> 00:34:40,638
um so i'm going to talk over till smith

933
00:34:39,199 --> 00:34:44,480
to run rubis

934
00:34:40,639 --> 00:34:44,480
and just going to give it some arguments

935
00:34:45,520 --> 00:34:50,800
and what you'll see here is

936
00:34:48,879 --> 00:34:52,639
we ran rubus but there was no child

937
00:34:50,800 --> 00:34:55,679
processors created

938
00:34:52,639 --> 00:34:56,639
now um what has actually happened is in

939
00:34:55,679 --> 00:34:59,839
the background

940
00:34:56,639 --> 00:35:02,880
is covert covert toolsmith has

941
00:34:59,839 --> 00:35:05,920
made a request to the web api

942
00:35:02,880 --> 00:35:08,640
it's recovered a um

943
00:35:05,920 --> 00:35:09,760
a net binary which has been um

944
00:35:08,640 --> 00:35:13,279
bootstrapped with

945
00:35:09,760 --> 00:35:16,800
ansi etw um it's

946
00:35:13,280 --> 00:35:20,720
uh yeah it's obfuscated and encrypted um

947
00:35:16,800 --> 00:35:24,240
and then it's executed that process um

948
00:35:20,720 --> 00:35:29,200
inside um actually inside the beacon

949
00:35:24,240 --> 00:35:31,759
um so sorry just skip that for a second

950
00:35:29,200 --> 00:35:33,359
and basically we've used our own custom

951
00:35:31,760 --> 00:35:36,800
clr harness to

952
00:35:33,359 --> 00:35:38,319
um inject that inside beacon's memory

953
00:35:36,800 --> 00:35:41,839
and run it all within beacons so there's

954
00:35:38,320 --> 00:35:43,440
no additional processes created

955
00:35:41,839 --> 00:35:45,920
and afterwards actually we unload the

956
00:35:43,440 --> 00:35:48,160
clr to kind of clean it down

957
00:35:45,920 --> 00:35:49,440
and so if we take a look at the um the

958
00:35:48,160 --> 00:35:50,480
the binary that comes back from the

959
00:35:49,440 --> 00:35:53,920
covert toolsmith

960
00:35:50,480 --> 00:35:56,000
and before it is um bootstrapped into

961
00:35:53,920 --> 00:35:56,480
the reflective dll that is used in our

962
00:35:56,000 --> 00:35:59,119
custom

963
00:35:56,480 --> 00:36:00,320
clr harness uh it's dropped disc and

964
00:35:59,119 --> 00:36:03,520
temporarily

965
00:36:00,320 --> 00:36:05,920
so i i basically turned up i sorry

966
00:36:03,520 --> 00:36:07,280
dropped a disc on the c2 client not on

967
00:36:05,920 --> 00:36:09,599
the actual endpoint

968
00:36:07,280 --> 00:36:10,880
um but i'm just going to recover that um

969
00:36:09,599 --> 00:36:11,359
so we can take a look so you can

970
00:36:10,880 --> 00:36:14,160
actually

971
00:36:11,359 --> 00:36:15,759
see um what that binary looks like and

972
00:36:14,160 --> 00:36:17,440
just to show you that it's an obfuscated

973
00:36:15,760 --> 00:36:20,240
one as well

974
00:36:17,440 --> 00:36:21,440
so i'm just going to pop that up in peak

975
00:36:20,240 --> 00:36:24,959
and you can see

976
00:36:21,440 --> 00:36:27,680
uh firstly firstly the assembly name is

977
00:36:24,960 --> 00:36:29,440
is completely obfuscated and you can see

978
00:36:27,680 --> 00:36:32,799
not none of the class names and things

979
00:36:29,440 --> 00:36:34,640
are visible as well um

980
00:36:32,800 --> 00:36:36,160
and that is basically how it works and

981
00:36:34,640 --> 00:36:38,400
that is

982
00:36:36,160 --> 00:36:40,399
a nice little approach for executing our

983
00:36:38,400 --> 00:36:43,440
own obfuscated bootstraps

984
00:36:40,400 --> 00:36:46,640
um binaries in process

985
00:36:43,440 --> 00:36:49,200
um without uh using that kind of

986
00:36:46,640 --> 00:36:51,920
fork and run uh technique that uh cobalt

987
00:36:49,200 --> 00:36:51,919
strike uses

988
00:36:52,839 --> 00:36:57,680
um

989
00:36:55,440 --> 00:36:57,680
so

990
00:37:01,760 --> 00:37:06,079
so whenever um basically what i want to

991
00:37:04,000 --> 00:37:07,280
show is that every time we want to run a

992
00:37:06,079 --> 00:37:09,040
tool

993
00:37:07,280 --> 00:37:10,560
we want to we want to build it before we

994
00:37:09,040 --> 00:37:11,520
run it so it's completely fresh every

995
00:37:10,560 --> 00:37:14,078
single time

996
00:37:11,520 --> 00:37:15,359
it's uh completely obfuscated every

997
00:37:14,079 --> 00:37:17,440
every iteration

998
00:37:15,359 --> 00:37:18,640
uh if we take this approach it makes it

999
00:37:17,440 --> 00:37:21,200
much harder

1000
00:37:18,640 --> 00:37:23,520
um for blue teams to triage the use of

1001
00:37:21,200 --> 00:37:25,439
tools and artifacts across the network

1002
00:37:23,520 --> 00:37:27,040
and in turn that increases their

1003
00:37:25,440 --> 00:37:28,079
response time and their investigation

1004
00:37:27,040 --> 00:37:31,680
with time

1005
00:37:28,079 --> 00:37:34,800
um so the

1006
00:37:31,680 --> 00:37:36,720
in addition to some um kind of custom

1007
00:37:34,800 --> 00:37:39,520
obfuscation that occurs within the

1008
00:37:36,720 --> 00:37:42,078
pipeline uh it also integrates into q

1009
00:37:39,520 --> 00:37:42,880
with confusor x and so confusor x is

1010
00:37:42,079 --> 00:37:45,760
actually

1011
00:37:42,880 --> 00:37:47,760
really nice in that it's got uh an api

1012
00:37:45,760 --> 00:37:50,240
um so we leverage that

1013
00:37:47,760 --> 00:37:51,920
api to rename all the resources add

1014
00:37:50,240 --> 00:37:54,479
control for obfuscation

1015
00:37:51,920 --> 00:37:55,200
uh add anti-tampering anti-debugging

1016
00:37:54,480 --> 00:37:56,480
that kind of stuff

1017
00:37:55,200 --> 00:37:58,480
encrypt all the resources and all the

1018
00:37:56,480 --> 00:37:58,880
constants to make our binary much harder

1019
00:37:58,480 --> 00:38:00,720
to

1020
00:37:58,880 --> 00:38:02,320
analyze even though we're never touching

1021
00:38:00,720 --> 00:38:03,279
this with it and we're just reflectively

1022
00:38:02,320 --> 00:38:06,800
running it in

1023
00:38:03,280 --> 00:38:09,680
inside memory um

1024
00:38:06,800 --> 00:38:11,599
so to do this basically confusor x has

1025
00:38:09,680 --> 00:38:12,799
got like a small config option that is

1026
00:38:11,599 --> 00:38:15,760
built inside the

1027
00:38:12,800 --> 00:38:17,040
um covert toolsmith web api and we can

1028
00:38:15,760 --> 00:38:19,680
just pick and choose

1029
00:38:17,040 --> 00:38:21,119
which protections we actually want to uh

1030
00:38:19,680 --> 00:38:23,200
to run

1031
00:38:21,119 --> 00:38:24,560
and then rosalind will um basically

1032
00:38:23,200 --> 00:38:26,319
compile

1033
00:38:24,560 --> 00:38:27,599
whatever tool whether that's rubus or

1034
00:38:26,320 --> 00:38:30,480
whatever into

1035
00:38:27,599 --> 00:38:31,520
um into the kind of intermediate

1036
00:38:30,480 --> 00:38:33,320
language

1037
00:38:31,520 --> 00:38:34,880
it will then run them through our

1038
00:38:33,320 --> 00:38:36,560
confuserx's

1039
00:38:34,880 --> 00:38:39,359
engine and then it will take that

1040
00:38:36,560 --> 00:38:41,279
obfuscated binary and pass it down to

1041
00:38:39,359 --> 00:38:44,880
the c2 client before it ends up getting

1042
00:38:41,280 --> 00:38:44,880
delivered to the compromise endpoint

1043
00:38:45,200 --> 00:38:48,319
aside from obfuscation we might actually

1044
00:38:47,520 --> 00:38:52,880
want to

1045
00:38:48,320 --> 00:38:54,960
um invest you know spend some time um

1046
00:38:52,880 --> 00:38:56,480
kind of uh protecting our actual

1047
00:38:54,960 --> 00:38:59,520
individual binaries

1048
00:38:56,480 --> 00:39:01,280
um because you know as i mentioned

1049
00:38:59,520 --> 00:39:04,320
before there is like a significant

1050
00:39:01,280 --> 00:39:05,280
r d investment from red teams and we

1051
00:39:04,320 --> 00:39:06,640
don't want to

1052
00:39:05,280 --> 00:39:08,560
we don't want all our kind of

1053
00:39:06,640 --> 00:39:09,598
intellectual property to end up on virus

1054
00:39:08,560 --> 00:39:11,520
total

1055
00:39:09,599 --> 00:39:13,040
and so because we have this if we're

1056
00:39:11,520 --> 00:39:14,560
using a pipeline because we've now got

1057
00:39:13,040 --> 00:39:16,960
this ability to

1058
00:39:14,560 --> 00:39:18,799
programmatically modify every tool or

1059
00:39:16,960 --> 00:39:21,520
every artifact that we create

1060
00:39:18,800 --> 00:39:22,400
we can also key them and so what i mean

1061
00:39:21,520 --> 00:39:25,680
by keying

1062
00:39:22,400 --> 00:39:28,160
is as a concept we're basically using

1063
00:39:25,680 --> 00:39:29,520
like a local or a remote resource to

1064
00:39:28,160 --> 00:39:32,799
build

1065
00:39:29,520 --> 00:39:34,640
a decryption key um and so there's you

1066
00:39:32,800 --> 00:39:35,040
can find this this described better

1067
00:39:34,640 --> 00:39:37,200
under

1068
00:39:35,040 --> 00:39:39,599
mitral attacks execution guard rails um

1069
00:39:37,200 --> 00:39:41,598
tactic but basically what we're doing

1070
00:39:39,599 --> 00:39:43,119
is we let's say for example we want to

1071
00:39:41,599 --> 00:39:45,520
create like a dll

1072
00:39:43,119 --> 00:39:47,280
uh that we're using for persistence or

1073
00:39:45,520 --> 00:39:48,000
um a dll that we're using for lateral

1074
00:39:47,280 --> 00:39:51,680
movement

1075
00:39:48,000 --> 00:39:54,720
we using the pipeline we can do that to

1076
00:39:51,680 --> 00:39:57,759
actually key it such that that dll only

1077
00:39:54,720 --> 00:40:00,240
ever executes on that endpoint

1078
00:39:57,760 --> 00:40:01,119
because the decryption key material for

1079
00:40:00,240 --> 00:40:03,040
running the

1080
00:40:01,119 --> 00:40:04,319
uh the main contents the core kind of

1081
00:40:03,040 --> 00:40:06,560
contents of the dll

1082
00:40:04,319 --> 00:40:07,599
is derived from the environment so maybe

1083
00:40:06,560 --> 00:40:09,520
we take the

1084
00:40:07,599 --> 00:40:11,280
you know the user's username the domain

1085
00:40:09,520 --> 00:40:13,119
name the computer name

1086
00:40:11,280 --> 00:40:14,480
and we kind of add all these together

1087
00:40:13,119 --> 00:40:16,400
into an algorithm maybe we take

1088
00:40:14,480 --> 00:40:17,760
directory listings from program files

1089
00:40:16,400 --> 00:40:19,920
that kind of stuff

1090
00:40:17,760 --> 00:40:21,040
and we gather all this information we

1091
00:40:19,920 --> 00:40:24,319
store it in the

1092
00:40:21,040 --> 00:40:27,359
um the kind of covert uh toolsmith

1093
00:40:24,319 --> 00:40:29,440
um back end so we know how what

1094
00:40:27,359 --> 00:40:30,400
what that endpoint looks like and we use

1095
00:40:29,440 --> 00:40:33,119
it to build a

1096
00:40:30,400 --> 00:40:34,960
a decryption key um for our core kind of

1097
00:40:33,119 --> 00:40:37,599
functionality

1098
00:40:34,960 --> 00:40:38,800
uh that is basically how it works is so

1099
00:40:37,599 --> 00:40:42,000
i i've got like a little

1100
00:40:38,800 --> 00:40:45,119
um collection um tool that runs

1101
00:40:42,000 --> 00:40:45,760
uh and it will um firstly recover a

1102
00:40:45,119 --> 00:40:48,000
bunch of

1103
00:40:45,760 --> 00:40:49,520
information about the endpoint uh it

1104
00:40:48,000 --> 00:40:50,800
will then submit it to the covert

1105
00:40:49,520 --> 00:40:52,960
toolsmith api

1106
00:40:50,800 --> 00:40:54,560
or alternatively it's actually with

1107
00:40:52,960 --> 00:40:56,319
cobalt strikers actually also able to

1108
00:40:54,560 --> 00:40:58,720
use um beacon

1109
00:40:56,319 --> 00:40:59,920
beacon's built-in data model and to

1110
00:40:58,720 --> 00:41:01,680
gather some information about the

1111
00:40:59,920 --> 00:41:04,640
endpoint whether that's username

1112
00:41:01,680 --> 00:41:05,598
um usernames computer names that kind of

1113
00:41:04,640 --> 00:41:07,680
stuff

1114
00:41:05,599 --> 00:41:08,800
and once we've got this information when

1115
00:41:07,680 --> 00:41:12,319
a request for a tool

1116
00:41:08,800 --> 00:41:14,640
is made if we also say key this tool

1117
00:41:12,319 --> 00:41:16,400
um and i say whether that's a loader or

1118
00:41:14,640 --> 00:41:18,240
whatever that's you know whatever

1119
00:41:16,400 --> 00:41:19,760
and we'll basically look at the keys

1120
00:41:18,240 --> 00:41:22,560
from the internal database

1121
00:41:19,760 --> 00:41:24,160
and then provide a an encrypted copy of

1122
00:41:22,560 --> 00:41:26,480
the tool or the artifact

1123
00:41:24,160 --> 00:41:28,560
and that can only be decrypted based on

1124
00:41:26,480 --> 00:41:31,200
the environmental keys

1125
00:41:28,560 --> 00:41:32,880
and then when the when the tool runs on

1126
00:41:31,200 --> 00:41:33,680
the endpoint or the artifact runs on the

1127
00:41:32,880 --> 00:41:35,440
endpoint

1128
00:41:33,680 --> 00:41:37,520
it will basically it doesn't have the

1129
00:41:35,440 --> 00:41:38,960
key built in but it knows which various

1130
00:41:37,520 --> 00:41:40,240
different types of properties are used

1131
00:41:38,960 --> 00:41:42,560
to actually build the key

1132
00:41:40,240 --> 00:41:44,078
so it will gather lots of information

1133
00:41:42,560 --> 00:41:46,160
and then it will try and brute force

1134
00:41:44,079 --> 00:41:50,000
its own decryption key and before it

1135
00:41:46,160 --> 00:41:50,000
ends up getting run with assembly.load

1136
00:41:50,160 --> 00:41:56,560
um so let's look at a little

1137
00:41:53,280 --> 00:41:56,560
example of this

1138
00:42:00,839 --> 00:42:07,839
okay so

1139
00:42:05,680 --> 00:42:09,040
so i've got um two screens uh cable

1140
00:42:07,839 --> 00:42:12,078
strike up on the left

1141
00:42:09,040 --> 00:42:12,800
um and then a virtual machine uh with

1142
00:42:12,079 --> 00:42:17,200
dot peak

1143
00:42:12,800 --> 00:42:19,119
up on the right um

1144
00:42:17,200 --> 00:42:21,040
so what the first thing i'm going to do

1145
00:42:19,119 --> 00:42:23,040
is i'm just going to tell

1146
00:42:21,040 --> 00:42:24,160
uh using the aggressor script i'm going

1147
00:42:23,040 --> 00:42:27,040
to tell it to

1148
00:42:24,160 --> 00:42:28,960
recover an artifact um which has got

1149
00:42:27,040 --> 00:42:32,400
some built-in shell code inside it

1150
00:42:28,960 --> 00:42:34,400
um from covert uh from

1151
00:42:32,400 --> 00:42:36,800
covet toolsmith uh and we'll cover an

1152
00:42:34,400 --> 00:42:38,480
artifact called foobar.dxe

1153
00:42:36,800 --> 00:42:40,079
and then uh it will end up getting

1154
00:42:38,480 --> 00:42:43,359
uploaded to the endpoint uh

1155
00:42:40,079 --> 00:42:44,880
inside this um temp directory so on the

1156
00:42:43,359 --> 00:42:48,078
right hand side what i've done

1157
00:42:44,880 --> 00:42:49,359
is just dragged fubar.exe over into dot

1158
00:42:48,079 --> 00:42:50,960
peak

1159
00:42:49,359 --> 00:42:52,640
and then if we take a look at it we can

1160
00:42:50,960 --> 00:42:54,319
firstly see it's it's all completely

1161
00:42:52,640 --> 00:42:57,520
obfuscated

1162
00:42:54,319 --> 00:42:59,200
but if we dive into one of the functions

1163
00:42:57,520 --> 00:43:01,920
uh we can see here this is where the

1164
00:42:59,200 --> 00:43:04,960
keying is actually uh occurring

1165
00:43:01,920 --> 00:43:05,520
and basically we have this um we have a

1166
00:43:04,960 --> 00:43:08,720
number of

1167
00:43:05,520 --> 00:43:10,480
um variables that it's taking in like

1168
00:43:08,720 --> 00:43:13,359
the machine name the username

1169
00:43:10,480 --> 00:43:14,720
the domain name external ip addresses oh

1170
00:43:13,359 --> 00:43:16,560
sorry internal ip addresses

1171
00:43:14,720 --> 00:43:19,040
uh and then we've also got this big

1172
00:43:16,560 --> 00:43:21,759
block of um base64

1173
00:43:19,040 --> 00:43:23,759
which is actually the encrypted uh

1174
00:43:21,760 --> 00:43:26,800
artifact or shell code or whatever

1175
00:43:23,760 --> 00:43:30,480
in this case um

1176
00:43:26,800 --> 00:43:33,280
so if we if we run uh

1177
00:43:30,480 --> 00:43:35,359
the foobar.exe what you'll see and i've

1178
00:43:33,280 --> 00:43:37,760
turned on the debugging just so we can

1179
00:43:35,359 --> 00:43:38,480
you can see this better um you can see

1180
00:43:37,760 --> 00:43:40,310
it basically

1181
00:43:38,480 --> 00:43:43,389
is trying to um

1182
00:43:40,310 --> 00:43:43,389
[Music]

1183
00:43:45,200 --> 00:43:48,000
i was trying to see if i could zoom in i

1184
00:43:46,960 --> 00:43:49,200
don't know if that's zooming for

1185
00:43:48,000 --> 00:43:51,839
everybody but it

1186
00:43:49,200 --> 00:43:53,439
at least zooms for me um it's basically

1187
00:43:51,839 --> 00:43:54,078
trying to brute force its own decryption

1188
00:43:53,440 --> 00:43:56,880
key based

1189
00:43:54,079 --> 00:43:57,520
on variables that are derived from the

1190
00:43:56,880 --> 00:43:59,200
environment

1191
00:43:57,520 --> 00:44:00,880
in this case i made it really simple and

1192
00:43:59,200 --> 00:44:03,680
it's just using the user's username

1193
00:44:00,880 --> 00:44:04,319
so basically when the user runs it um

1194
00:44:03,680 --> 00:44:07,279
they would

1195
00:44:04,319 --> 00:44:08,160
if like the blue team captured this xc

1196
00:44:07,280 --> 00:44:10,079
in this case

1197
00:44:08,160 --> 00:44:11,520
they would need to be running it as the

1198
00:44:10,079 --> 00:44:13,520
same username as the

1199
00:44:11,520 --> 00:44:14,960
end point that um we originally

1200
00:44:13,520 --> 00:44:17,119
generated it for

1201
00:44:14,960 --> 00:44:18,160
uh and that in this case basically

1202
00:44:17,119 --> 00:44:20,000
causes the

1203
00:44:18,160 --> 00:44:23,759
um the xc to decrypt when it gets the

1204
00:44:20,000 --> 00:44:26,240
right username um

1205
00:44:23,760 --> 00:44:27,839
and uh we get a beacon pop-up because

1206
00:44:26,240 --> 00:44:30,000
this is basically just using like some

1207
00:44:27,839 --> 00:44:33,040
injections to spawn internet explorer

1208
00:44:30,000 --> 00:44:37,839
that's what this artifact does uh and

1209
00:44:33,040 --> 00:44:37,839
that's pretty much how it works

1210
00:44:42,720 --> 00:44:49,839
um so as i kind of mentioned the

1211
00:44:46,319 --> 00:44:50,720
um the kind of real benefit of using

1212
00:44:49,839 --> 00:44:53,279
this approach

1213
00:44:50,720 --> 00:44:53,919
this um kind of operating in code

1214
00:44:53,280 --> 00:44:55,680
approach

1215
00:44:53,920 --> 00:44:57,040
rather than operating with commands is

1216
00:44:55,680 --> 00:44:58,399
that we don't actually

1217
00:44:57,040 --> 00:45:01,520
need to heavily interact with the

1218
00:44:58,400 --> 00:45:03,680
operating system at all

1219
00:45:01,520 --> 00:45:04,960
so if we employ this concept of

1220
00:45:03,680 --> 00:45:06,720
offensive development

1221
00:45:04,960 --> 00:45:08,800
we can achieve everything that we want

1222
00:45:06,720 --> 00:45:11,040
to do using code

1223
00:45:08,800 --> 00:45:12,079
so let's look at like an example problem

1224
00:45:11,040 --> 00:45:13,920
that we might have

1225
00:45:12,079 --> 00:45:15,200
let's say for example we wanted to

1226
00:45:13,920 --> 00:45:16,560
search we're you know we're searching

1227
00:45:15,200 --> 00:45:19,279
for passwords

1228
00:45:16,560 --> 00:45:20,480
in files on the endpoint traditionally

1229
00:45:19,280 --> 00:45:22,960
you might use something like

1230
00:45:20,480 --> 00:45:24,000
fine string and you know searching for

1231
00:45:22,960 --> 00:45:26,000
the path as a string

1232
00:45:24,000 --> 00:45:27,520
inside the users folder now this would

1233
00:45:26,000 --> 00:45:29,839
not look pretty at all from

1234
00:45:27,520 --> 00:45:31,119
an edr telemetry perspective so how do

1235
00:45:29,839 --> 00:45:33,680
we actually go on

1236
00:45:31,119 --> 00:45:35,520
and solve this so using defensive

1237
00:45:33,680 --> 00:45:36,960
development what we can do

1238
00:45:35,520 --> 00:45:38,960
and this is really cool because you can

1239
00:45:36,960 --> 00:45:41,200
actually just have the file

1240
00:45:38,960 --> 00:45:42,480
and the source code file open so i have

1241
00:45:41,200 --> 00:45:44,160
a project called like offensive

1242
00:45:42,480 --> 00:45:44,720
development i just write things in c

1243
00:45:44,160 --> 00:45:46,078
sharp

1244
00:45:44,720 --> 00:45:47,839
as i'm trying to operate on the end

1245
00:45:46,079 --> 00:45:49,280
point and then just just run them using

1246
00:45:47,839 --> 00:45:52,240
the clr harness

1247
00:45:49,280 --> 00:45:53,520
so um maybe we've just got a source code

1248
00:45:52,240 --> 00:45:55,279
file that we're

1249
00:45:53,520 --> 00:45:56,880
working on and we're just adding stuff

1250
00:45:55,280 --> 00:45:59,119
to and every time we because it's

1251
00:45:56,880 --> 00:46:00,319
uh the tool is compiled and built on

1252
00:45:59,119 --> 00:46:03,920
every run

1253
00:46:00,319 --> 00:46:05,599
um we can just have the the ide open and

1254
00:46:03,920 --> 00:46:06,720
just just add lines of code to the

1255
00:46:05,599 --> 00:46:08,160
source code file

1256
00:46:06,720 --> 00:46:09,520
and then submit and then it will

1257
00:46:08,160 --> 00:46:10,640
automatically run on the endpoint when

1258
00:46:09,520 --> 00:46:13,280
we want it to

1259
00:46:10,640 --> 00:46:14,799
and so i'll show you an example of this

1260
00:46:13,280 --> 00:46:16,880
how we can actually go about

1261
00:46:14,800 --> 00:46:19,280
red teaming entirely just from from our

1262
00:46:16,880 --> 00:46:19,280
ide

1263
00:46:23,200 --> 00:46:26,799
okay so

1264
00:46:27,119 --> 00:46:30,160
so again on the right hand side i've got

1265
00:46:29,599 --> 00:46:32,720
um

1266
00:46:30,160 --> 00:46:34,640
a source code file um which is literally

1267
00:46:32,720 --> 00:46:37,118
just printing something to the console

1268
00:46:34,640 --> 00:46:39,440
i've got it open in visual studio on the

1269
00:46:37,119 --> 00:46:41,200
left hand side i've got cobalt strike

1270
00:46:39,440 --> 00:46:42,960
and so what i'm going to do is i'm going

1271
00:46:41,200 --> 00:46:45,919
to use a covert tool smith

1272
00:46:42,960 --> 00:46:47,200
to run this offensive dev project on the

1273
00:46:45,920 --> 00:46:48,800
endpoint and again this is actually

1274
00:46:47,200 --> 00:46:50,240
running from like a docker container

1275
00:46:48,800 --> 00:46:53,119
that i'm

1276
00:46:50,240 --> 00:46:53,759
running inside visual studio so you can

1277
00:46:53,119 --> 00:46:56,160
see

1278
00:46:53,760 --> 00:46:57,560
um firstly it's just printed what what

1279
00:46:56,160 --> 00:46:58,720
we've got in the tool so it's done the

1280
00:46:57,560 --> 00:47:01,680
console.writeline

1281
00:46:58,720 --> 00:47:02,640
and we can see it on the screen um

1282
00:47:01,680 --> 00:47:04,640
secondly

1283
00:47:02,640 --> 00:47:05,920
uh what i'm going to do is just make a

1284
00:47:04,640 --> 00:47:07,279
change to this project

1285
00:47:05,920 --> 00:47:10,000
so i'm just going to delete the bits and

1286
00:47:07,280 --> 00:47:13,280
comments uh and then i'm going to add

1287
00:47:10,000 --> 00:47:17,520
an extra line uh console.writeline

1288
00:47:13,280 --> 00:47:19,119
um yeah hello zeefcom um

1289
00:47:17,520 --> 00:47:21,680
so we're now changing that source code

1290
00:47:19,119 --> 00:47:23,680
file and so what all this is going to do

1291
00:47:21,680 --> 00:47:26,480
now is search in the folder uses

1292
00:47:23,680 --> 00:47:27,919
dmc test for text files and then it will

1293
00:47:26,480 --> 00:47:31,119
look inside those text files

1294
00:47:27,920 --> 00:47:34,160
looking for the string password so

1295
00:47:31,119 --> 00:47:34,640
um we now just save that file and run it

1296
00:47:34,160 --> 00:47:36,720
again

1297
00:47:34,640 --> 00:47:38,160
using curve at toolsmith and again this

1298
00:47:36,720 --> 00:47:42,240
makes a request to

1299
00:47:38,160 --> 00:47:44,319
the um to the covert toolsmith api

1300
00:47:42,240 --> 00:47:46,479
uh which is inside the docker container

1301
00:47:44,319 --> 00:47:47,119
that folder inside docker is actually

1302
00:47:46,480 --> 00:47:49,680
shared

1303
00:47:47,119 --> 00:47:51,359
um with my virtual machine in this case

1304
00:47:49,680 --> 00:47:52,399
where i've got visual studio open with

1305
00:47:51,359 --> 00:47:56,000
that file

1306
00:47:52,400 --> 00:47:57,119
uh and it will then um read the new file

1307
00:47:56,000 --> 00:47:59,680
compile the project

1308
00:47:57,119 --> 00:48:00,240
uh and execute it in memory inside that

1309
00:47:59,680 --> 00:48:02,558
process

1310
00:48:00,240 --> 00:48:04,319
on the endpoint and you can see now it's

1311
00:48:02,559 --> 00:48:05,040
come back saying you know we've found

1312
00:48:04,319 --> 00:48:08,400
this

1313
00:48:05,040 --> 00:48:11,599
file called password.txt

1314
00:48:08,400 --> 00:48:13,760
and we can confirm it's working just by

1315
00:48:11,599 --> 00:48:14,800
you know kind of looking at the contents

1316
00:48:13,760 --> 00:48:16,880
of this file

1317
00:48:14,800 --> 00:48:17,920
you'd probably download it you wouldn't

1318
00:48:16,880 --> 00:48:19,200
if we're trying to avoid winning

1319
00:48:17,920 --> 00:48:20,720
commands you probably wouldn't win shell

1320
00:48:19,200 --> 00:48:22,399
type but for the purposes of this demo

1321
00:48:20,720 --> 00:48:24,558
we can see it's working

1322
00:48:22,400 --> 00:48:26,319
and that basically allows us to and do

1323
00:48:24,559 --> 00:48:28,880
whatever we want completely

1324
00:48:26,319 --> 00:48:28,880
in code

1325
00:48:29,839 --> 00:48:37,200
um so

1326
00:48:33,040 --> 00:48:39,119
not long left now um

1327
00:48:37,200 --> 00:48:40,399
so in conclusion i guess what i'm trying

1328
00:48:39,119 --> 00:48:43,760
to show is

1329
00:48:40,400 --> 00:48:44,559
um that kind of modern edr rich

1330
00:48:43,760 --> 00:48:46,480
environments

1331
00:48:44,559 --> 00:48:48,079
um blue teams have got a wealth of

1332
00:48:46,480 --> 00:48:50,400
telemetry they can see

1333
00:48:48,079 --> 00:48:51,920
um all the processes do you want they

1334
00:48:50,400 --> 00:48:54,160
can see your etw

1335
00:48:51,920 --> 00:48:55,040
events um they basically got full

1336
00:48:54,160 --> 00:48:56,640
visibility

1337
00:48:55,040 --> 00:48:58,240
of what you're doing on an endpoint yeah

1338
00:48:56,640 --> 00:48:59,839
as is mentioned early on

1339
00:48:58,240 --> 00:49:02,319
you know they've got the home home field

1340
00:48:59,839 --> 00:49:03,920
advantage in order for us to be

1341
00:49:02,319 --> 00:49:05,359
successful as a red teamer

1342
00:49:03,920 --> 00:49:07,119
uh we need to adapt our post

1343
00:49:05,359 --> 00:49:09,839
exploitation tradecraft

1344
00:49:07,119 --> 00:49:11,359
so we need to try and blend in better so

1345
00:49:09,839 --> 00:49:12,640
blending with the processes that are

1346
00:49:11,359 --> 00:49:15,200
loading the clr

1347
00:49:12,640 --> 00:49:16,160
and we need to be aware of how they're

1348
00:49:15,200 --> 00:49:18,960
detecting us

1349
00:49:16,160 --> 00:49:20,480
so that we can build innovations and

1350
00:49:18,960 --> 00:49:21,760
because there's so many different types

1351
00:49:20,480 --> 00:49:22,640
of evasions that we might need to

1352
00:49:21,760 --> 00:49:25,280
consider

1353
00:49:22,640 --> 00:49:27,118
if we've got the ability to integrate

1354
00:49:25,280 --> 00:49:30,000
and leverage devops principles

1355
00:49:27,119 --> 00:49:31,359
into this by using things like um a ci

1356
00:49:30,000 --> 00:49:34,400
cd pipeline

1357
00:49:31,359 --> 00:49:37,279
then that will help us better weaponize

1358
00:49:34,400 --> 00:49:39,760
and better protect all of our tools

1359
00:49:37,280 --> 00:49:40,559
um let's finally talk just a couple of

1360
00:49:39,760 --> 00:49:43,760
shout outs

1361
00:49:40,559 --> 00:49:44,079
um so firstly to peter winton smith who

1362
00:49:43,760 --> 00:49:46,800
did

1363
00:49:44,079 --> 00:49:47,200
some uh really awesome work on building

1364
00:49:46,800 --> 00:49:50,000
the

1365
00:49:47,200 --> 00:49:51,040
uh the in-process and clr harness that

1366
00:49:50,000 --> 00:49:54,240
we use

1367
00:49:51,040 --> 00:49:56,558
um a couple of ideas i borrowed from um

1368
00:49:54,240 --> 00:49:58,000
shot compile which was uh written by

1369
00:49:56,559 --> 00:50:00,480
another uh andy sucker

1370
00:49:58,000 --> 00:50:01,200
from uh dave middlehurst uh and then

1371
00:50:00,480 --> 00:50:04,319
finally

1372
00:50:01,200 --> 00:50:06,319
um ryan cobb did some really cool um

1373
00:50:04,319 --> 00:50:07,759
automation stuff inside covenant if you

1374
00:50:06,319 --> 00:50:08,800
dig into the source code of comment

1375
00:50:07,760 --> 00:50:11,119
covenant you'll see

1376
00:50:08,800 --> 00:50:12,559
uh how it uses rosalind and some similar

1377
00:50:11,119 --> 00:50:14,400
principles

1378
00:50:12,559 --> 00:50:16,079
to what i what i've kind of used in the

1379
00:50:14,400 --> 00:50:17,760
pipeline

1380
00:50:16,079 --> 00:50:26,559
and that's basically it i don't know if

1381
00:50:17,760 --> 00:50:28,640
we've got any questions at all

1382
00:50:26,559 --> 00:50:28,640
you

