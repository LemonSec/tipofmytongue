1
00:00:10,660 --> 00:00:12,090
hi everyone

2
00:00:12,090 --> 00:00:16,250
today to give a presentation entitled I
am the one hundred percent

3
00:00:16,250 --> 00:00:20,610
risk terms and conditions apply we're
really gonna talk about is reliable

4
00:00:20,610 --> 00:00:25,020
exploitation what it means for about to
be reliable

5
00:00:25,020 --> 00:00:33,090
can you hear me now

6
00:00:33,090 --> 00:00:40,150
ok sorry about that so we're really
gonna talk about today is reliable

7
00:00:40,150 --> 00:00:44,980
actually see what it means for an
exploit to be reliable and what are the

8
00:00:44,980 --> 00:00:49,180
properties of OC exploit in the
underlying bugs that make it reliable

9
00:00:49,180 --> 00:00:55,960
will also prevent to actually put in
that we think are 100% accurate reliable

10
00:00:55,960 --> 00:01:01,750
and explain how they work and what the
factors are that make them reliable

11
00:01:01,750 --> 00:01:07,120
we begin I said to myself I'm not only
solve any of it and I'm a security

12
00:01:07,120 --> 00:01:11,180
researcher with Google's Project Zero
and the second half of the presentation

13
00:01:11,180 --> 00:01:15,410
will be given by Chris Evans which you
in case you missed this morning's

14
00:01:15,410 --> 00:01:19,100
keynote is project zero fearless leader

15
00:01:19,100 --> 00:01:23,740
and when we started talking about
reliability we realize that a reliable

16
00:01:23,740 --> 00:01:28,789
exploit communal lot of different things
obviously the most fundamental level it

17
00:01:28,790 --> 00:01:32,619
means that the excellent always work
every time you run it you loaded in the

18
00:01:32,619 --> 00:01:35,950
browser the code or whatever payload you
had good sex

19
00:01:35,950 --> 00:01:40,420
picketed the wisdom that there can be a
lot of different subtleties for example

20
00:01:40,420 --> 00:01:44,310
does it really need to only work on one
version or platform or does it need to

21
00:01:44,310 --> 00:01:49,340
be more keepers in multi-platform also
doesn't need to work with the best

22
00:01:49,340 --> 00:02:03,210
medical and CSG execution need to
continue clearly put with exploitation

23
00:02:03,210 --> 00:02:10,329
is it ok that you will travel thing did
execute code and then the target crashes

24
00:02:10,330 --> 00:02:16,190
or does it need to exit cleanly
execution has occurred and also display

25
00:02:16,190 --> 00:02:20,190
actually need to be reentrant doesn't
need to run more than one against the

26
00:02:20,190 --> 00:02:24,739
same host or is it ok if you just run it
once on a clean hosting get code and

27
00:02:24,739 --> 00:02:29,440
that's it also doesn't matter to be
actually takes long time or uses a lot

28
00:02:29,440 --> 00:02:34,140
of memory you have to worry about the
user carefully worded ok yes some time

29
00:02:34,140 --> 00:02:35,260
to wait

30
00:02:35,260 --> 00:02:39,429
also if it fails what happens there's
really two things that can happen here

31
00:02:39,430 --> 00:02:45,940
either the card that can crash execution
can still continue it like the grief and

32
00:02:45,940 --> 00:02:49,880
for the purpose of this presentation
we're gonna call that and a board and

33
00:02:49,880 --> 00:02:53,680
crashing is bad for a couple of
different reasons first it's kind of

34
00:02:53,680 --> 00:02:58,260
noisy signal if someone opened up
something and it crashes maybe the

35
00:02:58,260 --> 00:03:03,200
things they're being it also in some
situations if you are bored you exit

36
00:03:03,200 --> 00:03:08,040
gracefully you get a chance to try again
maybe if you attack something and then

37
00:03:08,040 --> 00:03:12,410
there's an exit you can really attack at
it again but then maybe fix crashes the

38
00:03:12,410 --> 00:03:16,840
process won't come back and you lost
your 10 and we talked about it than we

39
00:03:16,840 --> 00:03:21,590
realize that when reliability means
really depends on the class of attacker

40
00:03:21,590 --> 00:03:25,000
for example for a profit motivated
attacker

41
00:03:25,000 --> 00:03:30,440
operator they really want to be able to
30 minutes later there and compromise as

42
00:03:30,440 --> 00:03:32,300
many times as possible

43
00:03:32,300 --> 00:03:35,830
and maybe they don't know a lot about
the systems and if someone opened up

44
00:03:35,830 --> 00:03:40,180
something and get the crash and get the
suspicious it doesn't really matter for

45
00:03:40,180 --> 00:03:43,580
the purposes of this research we decided
to think a bit more about targeted

46
00:03:43,580 --> 00:03:48,110
attackers these are the tapes of
attackers they are trying to attack a

47
00:03:48,110 --> 00:03:53,020
very small number of target they know a
lot about it every time they met them

48
00:03:53,020 --> 00:03:59,250
they want to hit and if they do this
they want to not get cut we came up with

49
00:03:59,250 --> 00:04:04,250
this definition of reliability and
isolated 100% reliable if it's

50
00:04:04,250 --> 00:04:08,930
guaranteed to succeed against the
specific version and environment and how

51
00:04:08,930 --> 00:04:13,130
would we ever know that well for the
purpose of this research because we

52
00:04:13,130 --> 00:04:16,690
fully understand the exploit because we
understand both the system were

53
00:04:16,690 --> 00:04:20,079
exploiting and the exploit the level
that we can go through every step and

54
00:04:20,079 --> 00:04:24,060
say that it's determined there's no
entropy and we know that it will succeed

55
00:04:24,060 --> 00:04:29,240
but you'll notice this definition has an
asterisk in it and that's because

56
00:04:29,240 --> 00:04:35,000
neither of these exploits at this point
are perfect bill still a small number of

57
00:04:35,000 --> 00:04:39,030
situations and come up two cases that we
can detect but we aren't able to get

58
00:04:39,030 --> 00:04:43,919
around so that small number of cases he
decided it's ok if we go with a 95

59
00:04:43,919 --> 00:04:49,870
reliability and in a small number of
cases aboard but these exploits we think

60
00:04:49,870 --> 00:04:56,850
we'll never crash the next thing I
wanted to do was to look for some bugs

61
00:04:56,850 --> 00:05:00,800
that he thought could be exploited
reliably they came across this quote

62
00:05:00,800 --> 00:05:05,110
shakespeare generally had a limited
amount to say excellent reliability but

63
00:05:05,110 --> 00:05:10,460
there's this boy reliable some achieve
reliability and some other liabilities

64
00:05:10,460 --> 00:05:15,719
thrust upon them and we found that this
was generally really true there are some

65
00:05:15,720 --> 00:05:19,419
bugs that really lent themselves
reliability really well and something we

66
00:05:19,419 --> 00:05:25,140
had to work a bit harder and the other
part that is missing is that were

67
00:05:25,140 --> 00:05:28,950
unreliable and will never be reliable
and there's nothing you can do to help

68
00:05:28,950 --> 00:05:39,669
them when he fell and was deep over
flows that go over the junk boundary it

69
00:05:39,669 --> 00:05:43,520
can never be reliable for two reasons
I'm the first one we thought of is when

70
00:05:43,520 --> 00:05:47,690
you're exploiting a heap overflow that's
been trunks usually you're relying on

71
00:05:47,690 --> 00:05:54,140
that next chunk seeing something
specific and not always guaranteed to

72
00:05:54,140 --> 00:05:58,870
have heat serbia complicated system so
you can never really be sure that

73
00:05:58,870 --> 00:06:02,789
exactly what you want we'll be there
then we got to thinking well what if you

74
00:06:02,789 --> 00:06:07,440
can read check and make sure it's ok but
even then have this problem of what if

75
00:06:07,440 --> 00:06:12,039
you're the chunk at the end of the page
then if you try and read you'll get a

76
00:06:12,039 --> 00:06:15,820
steak fall and then you'll crash so
there's really no way or at least nobody

77
00:06:15,820 --> 00:06:20,890
could think of that you can exploit this
type of issue 100% reliably get their

78
00:06:20,890 --> 00:06:25,000
class which we think is maybe 100%
reliable but probably not

79
00:06:25,000 --> 00:06:28,979
is used after freeze and it's once again
because they have this same problem

80
00:06:28,979 --> 00:06:32,770
where when you use after free you're
freaking something and then you're

81
00:06:32,770 --> 00:06:36,010
waiting for it to be reallocated and
you're hoping that something specific is

82
00:06:36,010 --> 00:06:40,740
there but what if it's not so maybe you
can find a special use after free where

83
00:06:40,740 --> 00:06:43,440
you could read and make sure
everything's okay but we think almost

84
00:06:43,440 --> 00:06:47,719
eight years after four years can't be
100% reliably exploited now there are

85
00:06:47,720 --> 00:06:52,370
three classes we think can be exploited
in this way the first is the people over

86
00:06:52,370 --> 00:06:56,710
flow with any heat because in that case
you really overflowing into other parts

87
00:06:56,710 --> 00:07:00,219
of the same object or whatever is
allocated their phones in situations

88
00:07:00,220 --> 00:07:03,650
that you could probably guarantee that
those are the same thing and then

89
00:07:03,650 --> 00:07:08,650
there's going to be no end to you and
your ex liked was that corruption

90
00:07:08,650 --> 00:07:13,560
usually with stat exam every time you
hit the bug that stack is laid out

91
00:07:13,560 --> 00:07:17,500
exactly the same way these things like
that cookies are left to get around but

92
00:07:17,500 --> 00:07:20,640
generally you know if he'll get a
specific place it's not going to be in a

93
00:07:20,640 --> 00:07:24,760
different place the next time you
exploit the bug so it's possible to

94
00:07:24,760 --> 00:07:32,330
probably get 100% reliable snack bag and
the final one is keep take confusion it

95
00:07:32,330 --> 00:07:37,430
to objects are taken fuse in the fuel
flow I'm usually that deterministic so

96
00:07:37,430 --> 00:07:41,560
it's possible in some situations to do a
reliable exploit was taken fusion

97
00:07:41,560 --> 00:07:45,070
so what we're gonna go through two
different bugs here I'm gonna start with

98
00:07:45,070 --> 00:07:52,520
the tape confusion bug and then chris is
going to present people over flu bug guy

99
00:07:52,520 --> 00:07:59,400
exploited is tbe 2015 3077 which is a
confusion if you in flash reported this

100
00:07:59,400 --> 00:08:05,830
one in February and it was patched in
May and this is i think is kind of an

101
00:08:05,830 --> 00:08:11,020
ideal bug for reliability the sort of
bug that chris is exploiting a little

102
00:08:11,020 --> 00:08:15,250
bit more generic heap overflow but this
one is kind of a special bug that's a

103
00:08:15,250 --> 00:08:20,820
bit unusual and it lends itself to
reliability really well so this is the

104
00:08:20,820 --> 00:08:25,919
bug and this code is really complicated
unfortunately on the margins of validity

105
00:08:25,919 --> 00:08:29,840
ActionScript especially the compiler
stops working really well it is

106
00:08:29,840 --> 00:08:32,689
compelled to the code doesn't work that
way it's supposed to

107
00:08:32,690 --> 00:08:37,560
or doesn't compile so this is what I had
to do a simplified version I promise

108
00:08:37,559 --> 00:08:41,739
that logically it exactly the same code
it just won't compile and basically what

109
00:08:41,740 --> 00:08:47,750
it does is there is the flat class color
filter so it creates a blur filter and

110
00:08:47,750 --> 00:08:52,930
then it sets the object filters center
to this filter and the object is either

111
00:08:52,930 --> 00:08:56,510
a movie clip for about it in and it has
this step function and basically what it

112
00:08:56,510 --> 00:09:00,900
does is the object you set the filter
and it costs he is a native object for

113
00:09:00,900 --> 00:09:06,030
the filter and then it creates a pointer
to it in the object and then it just or

114
00:09:06,030 --> 00:09:10,490
is it and then what I do here is i
overwrite the blur filter construction

115
00:09:10,490 --> 00:09:14,540
constructor and ActionScript with the
convolution filter instruct constructor

116
00:09:14,540 --> 00:09:20,319
and then get the filters object and you
can go to know where this goes wrong

117
00:09:20,320 --> 00:09:26,060
together but it does it takes meanness
native object stored coffees it into the

118
00:09:26,060 --> 00:09:30,640
new object and then an ActionScript
every object has a native backing and

119
00:09:30,640 --> 00:09:34,500
then an object in ActionScript with a
pointer soyuz's the constructor to

120
00:09:34,500 --> 00:09:38,300
create the ActionScript object except
it's no different tape because it's an

121
00:09:38,300 --> 00:09:42,209
issue like using the convolution filter
constructor know who is this allows you

122
00:09:42,209 --> 00:09:45,859
to create an inconsistent object in
memory basically in ActionScript the

123
00:09:45,860 --> 00:09:50,180
convolution filter but in need of
objects

124
00:09:50,180 --> 00:09:55,770
it's a blur filter and it is quite bad
this is fundamentally what the issue

125
00:09:55,770 --> 00:09:59,020
will let you do these are all the
different filter classes and those other

126
00:09:59,020 --> 00:10:04,410
ones I didn't include and basically you
can create any of these objects you can

127
00:10:04,410 --> 00:10:07,980
set the members you can get the members
then you can cast it to the next tape

128
00:10:07,980 --> 00:10:11,589
and then you can get in said those same
members so there's a really interesting

129
00:10:11,589 --> 00:10:15,450
things here you know floats can be
confused with pointers pointers can be

130
00:10:15,450 --> 00:10:19,200
confused with float they can all be
confused with in so it's really a lot of

131
00:10:19,200 --> 00:10:24,790
opportunities here so the first thing I
wanted to do was to buy test Ellis and I

132
00:10:24,790 --> 00:10:28,959
did this using this displacement map
filter and I confused it with the devil

133
00:10:28,959 --> 00:10:34,510
filter so that's what happened and then
I was able to fetch this point her and

134
00:10:34,510 --> 00:10:39,110
that's it using the color properties and
you can see there there's an example of

135
00:10:39,110 --> 00:10:42,839
what the code to actually do this looks
like but unfortunately this is just a

136
00:10:42,839 --> 00:10:48,860
pointer to the bitmap data not to the V
table let's do it one more time I can

137
00:10:48,860 --> 00:10:49,500
fuse

138
00:10:49,500 --> 00:10:53,890
used this pointer to the bitmap data
with a pointer to a float matrix and I

139
00:10:53,890 --> 00:10:59,360
can fetch between the beginning that I V
table points her and then I have a plan

140
00:10:59,360 --> 00:11:05,530
to the table but then there's a problem
this is a floating-point specification

141
00:11:05,530 --> 00:11:09,420
this table at least I think it is I've
never completely ruled out the

142
00:11:09,420 --> 00:11:13,910
possibility that the idea police killing
me because it's just so complicated and

143
00:11:13,910 --> 00:11:18,900
it has a number of problems especially
if you're trying to cast a 2002 flows

144
00:11:18,900 --> 00:11:25,870
for example there's the code below which
is that in memory is seven FSS and if

145
00:11:25,870 --> 00:11:31,380
you documented and you access it again
it's still seven and that because it's

146
00:11:31,380 --> 00:11:36,689
an end including point and those values
can be represented as anything including

147
00:11:36,690 --> 00:11:43,040
seven SSSs and they're often a crack in
C to be a different value so there's a

148
00:11:43,040 --> 00:11:47,880
few things I thought I could do here I
started off writing float converter been

149
00:11:47,880 --> 00:11:51,520
there done that got the office I ones
and I discovered that this actually

150
00:11:51,520 --> 00:11:55,420
wasn't possible because in my script
interpreters including ActionScript

151
00:11:55,420 --> 00:11:59,750
there's no casting afloat to an end so
it's something you can never really tell

152
00:11:59,750 --> 00:12:04,380
what's inside the net so do you think a
confusion to solve this problem

153
00:12:04,380 --> 00:12:09,610
ActionScript has this good property
where

154
00:12:09,610 --> 00:12:14,019
if you don't have the flu is in memory
and basically don't access it in action

155
00:12:14,019 --> 00:12:17,950
script and you don't do math on it and
see it won't be corrected into it

156
00:12:17,950 --> 00:12:22,450
actually access so so long as something
to float but you cast it to an int every

157
00:12:22,450 --> 00:12:26,010
time you take on it won't get corrupted

158
00:12:26,010 --> 00:12:30,060
doing this and basically never
performing on a flute so I started off

159
00:12:30,060 --> 00:12:34,380
doing and this converter to take
confusion converter and on one side of

160
00:12:34,380 --> 00:12:37,790
the color matrix field through which has
afloat and on the other side of the blue

161
00:12:37,790 --> 00:12:42,449
filter which is an internet you can go
back and forth and cast into a float

162
00:12:42,450 --> 00:12:47,070
accept this doesn't actually work this
is one of the more interesting things

163
00:12:47,070 --> 00:12:51,390
that led to the unreliability that I
think it's something that you might not

164
00:12:51,390 --> 00:12:55,550
expect when you started basically the
problem with this is that this area

165
00:12:55,550 --> 00:13:01,380
color filter is when you access it even
if you access like element was it

166
00:13:01,380 --> 00:13:04,700
actually call the whole thing to an
array and ActionScript and when it does

167
00:13:04,700 --> 00:13:08,950
this it converts everything to a number
because colors are numbers including

168
00:13:08,950 --> 00:13:12,550
things like objects where it might say
called value on them or that sort of

169
00:13:12,550 --> 00:13:16,949
thing and even worse because the blur
filter that is confusing it with this

170
00:13:16,949 --> 00:13:22,209
tiny extends onto the heat so there's a
very small but real probability that it

171
00:13:22,209 --> 00:13:26,670
will get off the heat from trying
converted to a number and then just

172
00:13:26,670 --> 00:13:31,439
reference valid and invalid pointer and
cause a crash so I'm just worked fine

173
00:13:31,440 --> 00:13:34,089
for

174
00:13:34,089 --> 00:13:40,939
to flow you ever since crash condition
so ended up i doing another

175
00:13:40,939 --> 00:13:47,309
converter for the other direction and
this is mostly one more problem here

176
00:13:47,309 --> 00:13:53,219
likely to go out to diagnose but
strangely enough in flash floods are

177
00:13:53,220 --> 00:13:56,550
never ever represented as follows when
they are stored and the representatives

178
00:13:56,550 --> 00:14:01,290
doubles and then we discovered that this
assembly when you catch the flu to a

179
00:14:01,290 --> 00:14:06,519
double and back in one situation it will
actually change the value and that's

180
00:14:06,519 --> 00:14:13,430
because the floating-point specification
I'm supports ethnic units units are

181
00:14:13,430 --> 00:14:19,979
quiet now and if you get a thing happens
it's just ordered a cute x-men three

182
00:14:19,980 --> 00:14:25,040
different they're called signaling and
according to a police raid 37 40

183
00:14:25,040 --> 00:14:28,540
depending on the alignment of the
planets at some point they may throw a

184
00:14:28,540 --> 00:14:35,309
floating point exception so this
assembly basically correct network units

185
00:14:35,309 --> 00:14:38,579
so you're not seriously throwing
exceptions but it also has a problem

186
00:14:38,579 --> 00:14:43,378
then you lose about you so I can detect
this case which means my exploit will

187
00:14:43,379 --> 00:14:49,579
fail when it out of 512 times but
detectable so if this ever health ins

188
00:14:49,579 --> 00:14:53,878
may actually just exit at this point I'm
gonna start ignoring flute because I

189
00:14:53,879 --> 00:14:58,300
honestly never want to think about them
again so this excellent I'll be talking

190
00:14:58,300 --> 00:15:00,878
about setting follows the pointers
pointers to float just imagine I'm

191
00:15:00,879 --> 00:15:05,999
running it through that converter every
single time I do it so the next thing I

192
00:15:05,999 --> 00:15:10,290
wanted to do was move the instruction
point and to do this I had to basically

193
00:15:10,290 --> 00:15:16,420
create a filthy object when I got the
beat table it was enough that it just

194
00:15:16,420 --> 00:15:20,300
fetch TV table but when you're setting
the instruction pointer you have one

195
00:15:20,300 --> 00:15:24,149
more thing you have to worry about which
is it's not enough to just overwrite IV

196
00:15:24,149 --> 00:15:28,110
table you have to actually be able to
call something on the table and the way

197
00:15:28,110 --> 00:15:31,839
the bitmap where there is a bit man with
a plan to get my outfit with a pointer

198
00:15:31,839 --> 00:15:35,949
to AV table and all the calls are
actually on that didn't fit so I had to

199
00:15:35,949 --> 00:15:38,969
create a fake bitmap for the put into
effect that method for the planet with

200
00:15:38,970 --> 00:15:42,799
eight feet able to move instruction
pointer so I did this using tape

201
00:15:42,799 --> 00:15:47,540
confusion so it started off I use this
some float matrix constructed

202
00:15:47,540 --> 00:15:51,219
and that allows you to create a float
matrix with whatever you want in it with

203
00:15:51,220 --> 00:15:55,649
whatever size and then I used his
current coordinates in the displacement

204
00:15:55,649 --> 00:16:01,380
map filter to fetch it and I did this
again and again and again to create and

205
00:16:01,380 --> 00:16:06,560
three objects with winners to each other
that emulate the object and then after

206
00:16:06,560 --> 00:16:10,439
that there's one more thing I needed to
do with the pointer to the data object

207
00:16:10,440 --> 00:16:14,410
in that was to make ActionScript
actually think it's this data object so

208
00:16:14,410 --> 00:16:18,769
I did that but I am setting the colors
on this double filter and then confusing

209
00:16:18,769 --> 00:16:21,959
it with something with the bitmap data
plan through the same spot and then you

210
00:16:21,959 --> 00:16:28,479
have something that it is a bit putting
to this fake so then all I have to do at

211
00:16:28,480 --> 00:16:35,899
this point is to call a method on it in
this case at 6:32 and then I executing

212
00:16:35,899 --> 00:16:41,350
the secret cable so I was a little bit
is what you see in this fake fee table

213
00:16:41,350 --> 00:16:47,509
and using an ethical of coffee color
into programming that could talk a bit

214
00:16:47,509 --> 00:16:53,850
more about later but basically it's a
message for feeding a series of digits

215
00:16:53,850 --> 00:17:00,230
at Exit very cleanly you can see the
rich will call and that enters at the

216
00:17:00,230 --> 00:17:04,730
left and then it calls into the first
got it at the talk and that sets it

217
00:17:04,730 --> 00:17:09,709
would set the parameter 2 system is da
dit and that exits and it doesn't text

218
00:17:09,709 --> 00:17:14,290
coal which actually called system and
then adjust the staff and exits clearly

219
00:17:14,290 --> 00:17:19,520
so that means not only physical system
but it doesn't crash afterwards so

220
00:17:19,520 --> 00:17:24,480
reliable well I think the best or the
most important part is just the high

221
00:17:24,480 --> 00:17:28,590
quality of all those object members
online and you have a lot of different

222
00:17:28,590 --> 00:17:30,290
options so that's great

223
00:17:30,290 --> 00:17:34,129
the other thing is that the object
members are beautiful they're like

224
00:17:34,130 --> 00:17:37,400
basically unusable you can get and you
can read and write every single property

225
00:17:37,400 --> 00:17:42,659
and I'm not important in making this
reliable the other thing that's good is

226
00:17:42,659 --> 00:17:45,150
that the tape confused objects are
fairly lately

227
00:17:45,150 --> 00:17:48,550
used sometimes they have problems with
safe threads running and causing

228
00:17:48,550 --> 00:17:52,149
something to crash but in this case I
was able to just set the movie clip

229
00:17:52,150 --> 00:17:56,760
object 2010 which means any of this
thread that typically use these objects

230
00:17:56,760 --> 00:18:00,390
won't run there's no pixels in the
object to that deals with reliability

231
00:18:00,390 --> 00:18:08,940
that way so what makes it unreliable
well low conversion 102 512 times it

232
00:18:08,940 --> 00:18:10,040
just won't work

233
00:18:10,040 --> 00:18:16,340
get their problem I had was garbage
collection and obvious from the diagrams

234
00:18:16,340 --> 00:18:20,300
but when I take confuse the two objects
it's not actually seem objects making a

235
00:18:20,300 --> 00:18:25,110
coffee every time which is fine for the
exploit but then when you get to and

236
00:18:25,110 --> 00:18:29,250
garbage collection you have all these
like half objects on the heat and that

237
00:18:29,250 --> 00:18:33,230
some fairly bad so what makes lead
actually does it every time it makes it

238
00:18:33,230 --> 00:18:37,190
feel to it basically puts it into an
array so that you and that you always

239
00:18:37,190 --> 00:18:40,830
have a reference to it and we'll never
attempt to garbage collected and that

240
00:18:40,830 --> 00:18:46,340
fun as long as flash is running but as
soon as flash goes away for example you

241
00:18:46,340 --> 00:18:50,949
refresh the test or close to it had
caused the crash and it's actually not a

242
00:18:50,950 --> 00:18:54,680
visible crash so you've noticed but it
could create a crash dump which may be

243
00:18:54,680 --> 00:18:59,400
noticeable and I think you can't you can
probably prevent this problem but

244
00:18:59,400 --> 00:19:02,560
instead of calling system calling
executable that actually fix a memory

245
00:19:02,560 --> 00:19:08,540
space I actually doesn't actually do
that one last question is you know now

246
00:19:08,540 --> 00:19:14,500
I've got 10 to five hundred and twelve
411 002 512 times working I could I make

247
00:19:14,500 --> 00:19:19,530
it 100% reliable I think there's a few
options the most obvious one if you just

248
00:19:19,530 --> 00:19:22,850
stop using flute buffers I'm not the
cause of the problem if I could find a

249
00:19:22,850 --> 00:19:30,129
different buffer that could fix up the
problem another option would be to have

250
00:19:30,130 --> 00:19:35,020
a set of different budget because it
only fails when the pointer is an ass

251
00:19:35,020 --> 00:19:36,930
but if you have enough judges

252
00:19:36,930 --> 00:19:41,410
mathematically the hell can't possibly
be us know that one and then that may be

253
00:19:41,410 --> 00:19:44,990
a way around the problem another way
would be if I could find a way to write

254
00:19:44,990 --> 00:19:50,910
an integer into that folder maybe using
a pointer to a different so that

255
00:19:50,910 --> 00:19:53,890
everything that is wrong with my
actually I'm going to attempt the demo

256
00:19:53,890 --> 00:19:59,120
they said there is a hundred eleven in
five hundred and twelve chips that this

257
00:19:59,120 --> 00:20:11,010
will work

258
00:20:11,010 --> 00:20:22,920
were gonna happen first is this as i
said well just punch yet it when you

259
00:20:22,920 --> 00:20:30,210
open up the browser does well I'm gonna
have to go over to Chris notice show his

260
00:20:30,210 --> 00:20:52,519
ex late

261
00:20:52,519 --> 00:21:03,359
so we're going to exploit with briefly
couple of the buckets it's a problem in

262
00:21:03,359 --> 00:21:09,208
an area of flash coach Ottis shade is a
little actual programs you can run if

263
00:21:09,209 --> 00:21:10,259
you like that

264
00:21:10,259 --> 00:21:16,159
output images basically and flashes this
shooting API and what you do is you you

265
00:21:16,159 --> 00:21:19,830
passing you share the definition to
flash and it will compile that not a

266
00:21:19,830 --> 00:21:25,968
real covert with virtual shade execution
language and anything that to generate

267
00:21:25,969 --> 00:21:31,149
an image and when you do this you might
want to input into a shed a program like

268
00:21:31,149 --> 00:21:34,508
for example if you're going to use a
shared her render a circle you want to

269
00:21:34,509 --> 00:21:40,159
pass in the radius of the circle the
perimeter so we have not just the shader

270
00:21:40,159 --> 00:21:44,249
objective the API level but we have a
shadow primer to object in the API and

271
00:21:44,249 --> 00:21:48,200
also you compile a program I think the
presence of South Campus you get these

272
00:21:48,200 --> 00:21:56,440
texts back to run the shaded to render
the actual the circle for example you

273
00:21:56,440 --> 00:22:03,749
set your promises to be the greatest 10
and then internally at runtime that that

274
00:22:03,749 --> 00:22:08,320
valujet sort of written back into the
program just in time to run home run

275
00:22:08,320 --> 00:22:11,729
with the values you choose so far so
good

276
00:22:11,729 --> 00:22:16,679
the expected case of course you might
want to see more complicated program to

277
00:22:16,679 --> 00:22:22,179
this one is like twice as long and we
were setting a promoter position 18 in

278
00:22:22,179 --> 00:22:24,940
this one began working as expected

279
00:22:24,940 --> 00:22:30,209
interesting where the actual book
manifested is you could do to CK but you

280
00:22:30,209 --> 00:22:34,859
could take the shade of primitive from
the longer program and associated with

281
00:22:34,859 --> 00:22:40,259
the short program and then run back
combination and lets you put a length 12

282
00:22:40,259 --> 00:22:43,869
program and you've written a promise of
value

283
00:22:43,869 --> 00:22:51,889
18 relatively programs out of bounds and
that's cheaper option is a CVA 2015 3105

284
00:22:51,889 --> 00:23:00,610
long since passed in patch for Easter
month sting bug

285
00:23:00,610 --> 00:23:07,379
so how do you explain about the
traditional way to exploit that bug and

286
00:23:07,380 --> 00:23:12,480
this is if you see a flash exploit
either written by a defensive research

287
00:23:12,480 --> 00:23:15,140
will want ends up in the wild being
abused

288
00:23:15,140 --> 00:23:18,690
almost all of them interesting enough
used exactly the same technique to to

289
00:23:18,690 --> 00:23:22,809
exploit a heap corruption in flash so it
is if you gotta keep russian something

290
00:23:22,809 --> 00:23:29,139
going off the end of a trunk it is you
say you arrange for another type of

291
00:23:29,140 --> 00:23:33,870
Flash object victor of Newent to be just
after the object where the corruption

292
00:23:33,870 --> 00:23:38,139
because of the end of and you club the
first field inspector of you Michelle

293
00:23:38,140 --> 00:23:42,620
Lang and you make it bigger and then
suddenly you're kind of all done just

294
00:23:42,620 --> 00:23:47,360
have already done that because when
you've got this vector of you in and you

295
00:23:47,360 --> 00:23:50,639
put his lengthy bigger you've got this
wonderful exportation primitive where

296
00:23:50,640 --> 00:23:54,960
you can arbitrarily reading right of the
end you basically full control of the

297
00:23:54,960 --> 00:23:59,240
processes memory space at that point in
time from their exploitation is pretty

298
00:23:59,240 --> 00:24:10,530
easy so explaining something this way
the traditional way is it reliable it is

299
00:24:10,530 --> 00:24:16,160
not what we've done here is natalie
covered this in her public what we've

300
00:24:16,160 --> 00:24:21,000
done here is our expertise has done more
because crossing a huge chunk and ideas

301
00:24:21,000 --> 00:24:25,890
not a 100% guaranteed to succeed
operation as in we we cannot be sure

302
00:24:25,890 --> 00:24:30,530
that when we cross the heat chance that
right next to our objectives of it wrong

303
00:24:30,530 --> 00:24:35,899
is a vector of you can be sure that is
the case because when we use this

304
00:24:35,900 --> 00:24:40,620
technique he keeps playing it as a
probabilistic you get the probability of

305
00:24:40,620 --> 00:24:49,020
succeeding against layout quite high but
a hundred percent No

306
00:24:49,020 --> 00:24:56,550
so yourself so it was very interesting
bug and we've said that a traditional

307
00:24:56,550 --> 00:25:00,280
exploitation technique is not 100%
reliable and the goal of this research

308
00:25:00,280 --> 00:25:02,930
is to make something that is
unacceptable

309
00:25:02,930 --> 00:25:07,650
with the same bug and we do better he
also tended to be yes so we actually

310
00:25:07,650 --> 00:25:13,450
have two possibilities when we have used
this blog we can either be carried out

311
00:25:13,450 --> 00:25:17,080
of bounds right which is why we cross
the heat game over

312
00:25:17,080 --> 00:25:24,110
not reliable all we can do is we can do
an inbounds or within the heat chunk bad

313
00:25:24,110 --> 00:25:31,159
right so what we can do is instead of
taking a shower prompted this from a

314
00:25:31,160 --> 00:25:35,010
different program of course things go
wrong instead of taking a shower

315
00:25:35,010 --> 00:25:39,020
primitive this way out of bounds
relative to a comp program we can grab

316
00:25:39,020 --> 00:25:43,930
on the inbounds ready for cum program
but pointing to a different operator and

317
00:25:43,930 --> 00:25:49,920
ok that is not supposed to be used for
input parameter resolution so we can do

318
00:25:49,920 --> 00:25:50,590
that

319
00:25:50,590 --> 00:25:54,050
something interesting occurs like I was
looking at this and initially I thought

320
00:25:54,050 --> 00:25:59,180
there were no good possibilities to go
forward using this description primitive

321
00:25:59,180 --> 00:26:03,420
but it turns out there is exactly one
way forward when you see the

322
00:26:03,420 --> 00:26:07,840
possibilities and this is opcode court
area code if you're familiar with the C

323
00:26:07,840 --> 00:26:13,100
language in all this is but it's it's
not pay that kind of doing quite a bit

324
00:26:13,100 --> 00:26:16,629
of work with just one coat and that
means that it uses all of its parameters

325
00:26:16,630 --> 00:26:22,370
Park Forest is one of interest here so
we're putting all of that is within this

326
00:26:22,370 --> 00:26:27,250
virtual shader execution language there
are only two things that you thought for

327
00:26:27,250 --> 00:26:33,580
and that's all the input parameters and
the territorial so that we've only got

328
00:26:33,580 --> 00:26:37,540
one path forward is both really good and
reading everything could potentially bad

329
00:26:37,540 --> 00:26:41,170
it's really good because it acts as an
expert writer if there's any if they're

330
00:26:41,170 --> 00:26:43,980
limited number of paths forward to
investigate that that's good you have to

331
00:26:43,980 --> 00:26:47,830
worry about missing something unique
powerful using the one part that might

332
00:26:47,830 --> 00:26:53,480
get you somewhere and a few was feels
kind of good because you know that we

333
00:26:53,480 --> 00:26:58,400
need to succeed or prove definitively
that it cannot be done it's really bad

334
00:26:58,400 --> 00:27:00,429
because my end of the didn't so

335
00:27:00,429 --> 00:27:07,639
destroyed pharmacy ever gonna proceed
forward with determinism liability or

336
00:27:07,639 --> 00:27:12,209
hit that and so we've done within he
jumped out of bounds right and thats

337
00:27:12,210 --> 00:27:13,879
deterministic

338
00:27:13,879 --> 00:27:19,039
reliable and we found exactly one side
effect that we can carry forward see if

339
00:27:19,039 --> 00:27:22,360
we can get further with this so we
prompted the fourth argument with 10

340
00:27:22,360 --> 00:27:23,309
area code

341
00:27:23,309 --> 00:27:29,190
the ternary operator written out in
sassy likes intact looks looks like this

342
00:27:29,190 --> 00:27:34,610
and it turns out that we were messing up
source register too and we can say that

343
00:27:34,610 --> 00:27:40,039
whatever we want so actually happens
when you compile the shader programs is

344
00:27:40,039 --> 00:27:45,940
it looks at how many variables are using
register so using 81 time it will

345
00:27:45,940 --> 00:27:51,240
allocate space than 48 registers we can
corrupt the source register and for

346
00:27:51,240 --> 00:27:58,980
example reference register a hundred
pounds so in effect we've turned out of

347
00:27:58,980 --> 00:28:05,559
bounds right into and out of bounds read
kind of doesn't sound great like as an

348
00:28:05,559 --> 00:28:09,059
attacker and out of bounds read is
usually less powerful primitive than out

349
00:28:09,059 --> 00:28:12,840
of bounds right so perhaps it sounds
like we've downgraded our capability

350
00:28:12,840 --> 00:28:19,629
which will be disappointing but you know
that's keep with it and see if we can

351
00:28:19,629 --> 00:28:26,610
proceed forward keep a 100% reliability
get someone so when things turn in our

352
00:28:26,610 --> 00:28:30,360
favor again is that at runtime there's
this kind of Franklin object that's

353
00:28:30,360 --> 00:28:36,860
unusual to see in in programs but but
but this is what we got so we got to

354
00:28:36,860 --> 00:28:41,549
sort of registers that we talked about
say five runtime registers concatenated

355
00:28:41,549 --> 00:28:46,009
in the same heat from C++ object like
bolted right next to each other the same

356
00:28:46,009 --> 00:28:52,690
application to construct but it's going
to help us so what happens if we read

357
00:28:52,690 --> 00:28:57,700
using a corruption primitive register
1000 well that's gonna be an that's

358
00:28:57,700 --> 00:29:03,619
going to be go way out of bounds
relative to this this heap object here I

359
00:29:03,619 --> 00:29:10,519
hate junk and came over as we as we as
we covered earlier do that so again with

360
00:29:10,519 --> 00:29:13,059
just one other possibility which is what
we read

361
00:29:13,059 --> 00:29:18,799
inbounds so I disappointing start to
look start to read so if we've got five

362
00:29:18,799 --> 00:29:23,629
registers at runtime and corruption we
read registers 6 20 and 30 these are all

363
00:29:23,629 --> 00:29:27,799
inbounds rejected by the reach the night
by the green here and we can read some

364
00:29:27,799 --> 00:29:32,200
really interesting things one of the
things we can read it if the table and

365
00:29:32,200 --> 00:29:34,899
that's one of the most important
prerequisites for defeating SLR

366
00:29:34,899 --> 00:29:40,539
protection that getting away as an
exploit the other thing that's really

367
00:29:40,539 --> 00:29:44,419
awesome is for some reason this this
ranking object at runtime here has

368
00:29:44,419 --> 00:29:48,570
appointed to itself and that's really
useful to suddenly you start to know a

369
00:29:48,570 --> 00:29:52,189
lot about the heat play out like you you
know the address of an object in memory

370
00:29:52,190 --> 00:29:58,610
and that another component in defeating
a solo so things are looking better as

371
00:29:58,610 --> 00:30:05,428
if we're getting them done so far so
we're just gonna check the we've got our

372
00:30:05,429 --> 00:30:09,639
one hundred and reliability or so we did
it with in chunks out of bounds right

373
00:30:09,639 --> 00:30:14,949
deterministic reliabilities coup that
enables our fans read we've decided

374
00:30:14,950 --> 00:30:18,980
we're gonna do it within chunk out of
bounds read that's deterministic or

375
00:30:18,980 --> 00:30:24,769
reliability is still with us we think
the values and reduced with things but

376
00:30:24,769 --> 00:30:30,610
just to read say I said as I was inside
I said but you can't take over a process

377
00:30:30,610 --> 00:30:34,879
with a read only occur to me that it
James for sure did this heat he spoke

378
00:30:34,879 --> 00:30:40,299
earlier he's got a blog posts LinkedIn
these slides did over a takeover pursue

379
00:30:40,299 --> 00:30:44,340
the read about the crack myself that but
this type of read we have here is not

380
00:30:44,340 --> 00:30:50,439
what I've read is going to help us take
over the process what are the primitives

381
00:30:50,440 --> 00:30:55,320
are not well we know we can read we can
keep chunks and do cross he jumped out

382
00:30:55,320 --> 00:30:58,350
of bounds reason rights but we found a
written those office not being reliable

383
00:30:58,350 --> 00:31:04,070
because we really are doing everything
we really can insist on December

384
00:31:04,070 --> 00:31:09,570
liability so those were the primitives
we have a dead end or can we put all the

385
00:31:09,570 --> 00:31:14,600
pieces together a couple of realizations

386
00:31:14,600 --> 00:31:19,419
when we train them together we we
realize that there is a possible so

387
00:31:19,420 --> 00:31:25,330
so let's see when I say we know are in
the dress go back to get back to this

388
00:31:25,330 --> 00:31:30,300
light here at runtime we're unashamed a
program that is done these dodgy reads

389
00:31:30,300 --> 00:31:36,100
we've determined the address of our own
shader object in memory and that's kind

390
00:31:36,100 --> 00:31:40,389
of cool because if we know the address
for NJ dropped the memory we know the

391
00:31:40,390 --> 00:31:43,810
address of the next thing in memory and
if we know little bit about the heap

392
00:31:43,810 --> 00:31:49,090
implementation may be knowing what
address which corresponds to the next

393
00:31:49,090 --> 00:31:54,340
maybe we can work out if that luxury
fault or not if we do that read that

394
00:31:54,340 --> 00:31:59,240
suddenly very interesting will cover the
exact mechanics in a minute but we we do

395
00:31:59,240 --> 00:32:03,500
get situation where we by knowing
already but yes we know whether it is

396
00:32:03,500 --> 00:32:08,240
safe to read out of bounds on and that's
to say we announce the question if we

397
00:32:08,240 --> 00:32:12,660
read out of bounds what will happen in
the two options are crash do not crash

398
00:32:12,660 --> 00:32:21,220
so the second realization is if we can
do a safe out of bounds read maybe we

399
00:32:21,220 --> 00:32:25,490
can use that to prove that are out of
bounds right he's actually gonna write

400
00:32:25,490 --> 00:32:31,130
what we think it's gonna write so if we
go back to get back to you that I

401
00:32:31,130 --> 00:32:35,190
dislike here what we want to do is we
want to line up the heat like this it

402
00:32:35,190 --> 00:32:39,990
will clobbering this length but we want
to kind of prove that are shaded program

403
00:32:39,990 --> 00:32:44,480
is next to this vector so we can use a
lot of bands read a safe route of entry

404
00:32:44,480 --> 00:32:50,210
to prove that in fact we did he printed
estate here and then we can proceed with

405
00:32:50,210 --> 00:32:53,620
a hundred and reliability clobbering
that length knowing that when we do the

406
00:32:53,620 --> 00:33:05,000
club right has put it all together so
many hits break to this attempted state

407
00:33:05,000 --> 00:33:09,590
and when I say attempted say I mean we
do his brain and we think this is where

408
00:33:09,590 --> 00:33:14,530
we ended up not sure but we can use the
primitives we have to prove that this is

409
00:33:14,530 --> 00:33:20,129
where we ended up so gonna line up a
bunch of a kilobyte chunks in a row you

410
00:33:20,130 --> 00:33:23,410
do that by just spraying a bunch of a
kilobyte chunks in the heat to fill any

411
00:33:23,410 --> 00:33:27,350
holes and maybe an eight and then spray
bunch morning theory though he himself

412
00:33:27,350 --> 00:33:30,780
was lined them up in a row because
that's what he can permit Asians tend to

413
00:33:30,780 --> 00:33:31,720
do

414
00:33:31,720 --> 00:33:38,049
what you've done that we are going to
run off a shade other regions and

415
00:33:38,049 --> 00:33:43,870
address and I will read accepting them
free itself from that process will get

416
00:33:43,870 --> 00:33:47,049
back he progressed and there's a
somebody progress on the slide and

417
00:33:47,049 --> 00:33:52,299
that's kind of cool we know the address
because when we run the next when we run

418
00:33:52,299 --> 00:33:58,010
the holes that primitive again mister
step so after this thing exits with an

419
00:33:58,010 --> 00:34:03,000
allocator he promotes direct that's the
3d object in this is the object if all

420
00:34:03,000 --> 00:34:06,700
is well we want to put their own a
previous there and if it doesn't do that

421
00:34:06,700 --> 00:34:12,389
we can use of these a plan that
execution so it is you run the whole

422
00:34:12,389 --> 00:34:18,250
cycle through again it kind of proves
itself is an Hiep address and if he is

423
00:34:18,250 --> 00:34:23,679
all going well like if things are run
time as we draw a slide that we know

424
00:34:23,679 --> 00:34:27,659
what address do expect it's it's a kid's

425
00:34:27,659 --> 00:34:33,179
8,000 by so I kilobytes less than the
previous address so 7000 texts to 5,000

426
00:34:33,179 --> 00:34:39,359
acts so we can do to check our address
it turns out is not what we expect them

427
00:34:39,359 --> 00:34:43,029
we keep room is not successfully and
will do what Natalie times in a boat

428
00:34:43,030 --> 00:34:48,540
that's a safe exit of the exploit
without doing a noisy crashed my signal

429
00:34:48,540 --> 00:34:54,089
something is going on but if it is where
we expect we can we we've proved safety

430
00:34:54,089 --> 00:34:57,779
and out of bounds read and then without
about street we can prove or disprove

431
00:34:57,780 --> 00:35:02,630
the theory that the 3d object is next

432
00:35:02,630 --> 00:35:09,190
precedes a bit more in exactly the same
primitive over and over again to like

433
00:35:09,190 --> 00:35:14,080
prove that what we thought happened it
happened so slowly building up backwards

434
00:35:14,080 --> 00:35:18,049
this this list of objects that are like
getting a lot ducks in a row I guess but

435
00:35:18,050 --> 00:35:25,930
these are not duck season / objects and
eventually once we've actually five

436
00:35:25,930 --> 00:35:30,720
objects we care about what we prove that
they're all in a row

437
00:35:30,720 --> 00:35:36,589
place know we've got the shade a program
to the second object along and and

438
00:35:36,589 --> 00:35:40,029
that's why we have this bug where we can
write out of bounds crossing each of

439
00:35:40,030 --> 00:35:44,670
which normally will be reliability done
done but what we've done is we've proved

440
00:35:44,670 --> 00:35:50,130
this vector of UN is exactly two objects
next to us in the heat so we decided on

441
00:35:50,130 --> 00:35:54,270
the right we know with certainty
deterministically we're going to talk

442
00:35:54,270 --> 00:35:58,109
about what we think we're gonna so we
cover the vector of you in length and

443
00:35:58,109 --> 00:36:02,180
then we're done because that gives us
access to your access to the processes

444
00:36:02,180 --> 00:36:08,730
memory and we're going to take every
table on the 3d object and and calculate

445
00:36:08,730 --> 00:36:18,290
so so damaged so I don't have the
demagogues demagogues were not kind to

446
00:36:18,290 --> 00:36:22,230
me earlier this year context I'm hoping
that you know I can be kind to me today

447
00:36:22,230 --> 00:36:31,660
so I run my exploits as a character data
but we get too excited what does it when

448
00:36:31,660 --> 00:36:34,410
you've got exploit which you can
plausibly claim is a hundred percent

449
00:36:34,410 --> 00:36:41,470
reliable what does it look like a nice
weather that's not the end of his life

450
00:36:41,470 --> 00:36:46,558
and it could it could for the first time
I've seen die any minute and I'll look

451
00:36:46,559 --> 00:36:49,770
pretty silly for claiming under some
reliable but I've not seen it done

452
00:36:49,770 --> 00:36:58,799
that's that's a lot of calculators that
works I'm really tempted because that

453
00:36:58,799 --> 00:37:03,759
was nice lot calculators but that was a
very fresh process state I just launched

454
00:37:03,760 --> 00:37:08,630
a browser which just launched the fact
process very clean heat state quite easy

455
00:37:08,630 --> 00:37:12,980
to get a reliable exploit with a clean
slate so I sort of town this flash file

456
00:37:12,980 --> 00:37:17,630
here like a 3d demo and for whatever
reason it seems to really turn the heat

457
00:37:17,630 --> 00:37:21,390
in the background but I can see it's
actually this is not a static image as a

458
00:37:21,390 --> 00:37:26,339
little bit of motion that the water is
like shimmering a bit this is 60

459
00:37:26,339 --> 00:37:29,920
frames-per-second 3d rendering the heat
has been tortured in the background so

460
00:37:29,920 --> 00:37:42,020
so so we didn't get a few times in a row
but we don't crash they decided by

461
00:37:42,020 --> 00:37:47,630
stopping incorrect prague heap address
so it some stage during that lineup of

462
00:37:47,630 --> 00:37:54,140
objects that we would buy one place we
have to prove that with a safe way so we

463
00:37:54,140 --> 00:37:57,828
just stopped if this is a real explains
if that happened it would just be

464
00:37:57,829 --> 00:37:58,180
running

465
00:37:58,180 --> 00:38:07,960
and eventually but I like a 20 percent
how great maybe I mean this exploit runs

466
00:38:07,960 --> 00:38:13,090
in milliseconds so you know it's a real
attack running 10 times gonna succeed

467
00:38:13,090 --> 00:38:21,720
even when he was like being tortured so
the demigods I didn't give me cancer

468
00:38:21,720 --> 00:38:28,399
Chaka Khan Thank You demagogues
calculators to a bog down the rest of

469
00:38:28,400 --> 00:38:37,460
the presentation

470
00:38:37,460 --> 00:38:56,930
rock courses return oriented programming
it's well documented in the literature

471
00:38:56,930 --> 00:39:02,310
and a very security-conscious I'm not
saying much about it is a term has been

472
00:39:02,310 --> 00:39:02,869
used

473
00:39:02,869 --> 00:39:06,080
I'm not claiming this time its attempts
been used before the best efforts I

474
00:39:06,080 --> 00:39:11,540
found in an academic paper which is
quite something similar to what I've

475
00:39:11,540 --> 00:39:16,619
done but basically instead of having a
simple gadget return you have assembly

476
00:39:16,619 --> 00:39:20,890
gotcha why is it so much better well the
cockpit

477
00:39:20,890 --> 00:39:25,310
there some significant advances to call
the main one i think is there's no time

478
00:39:25,310 --> 00:39:31,470
to stack so if you doing Rocky do the
single stack stack is a tricky get it to

479
00:39:31,470 --> 00:39:37,450
find special 64 bit and national myself
that did them again 64 bit processor is

480
00:39:37,450 --> 00:39:44,660
mainly because of several liability
should give it a hard case detectability

481
00:39:44,660 --> 00:39:50,520
is really nothing changed so did you
stack if you make a mistake after

482
00:39:50,520 --> 00:39:54,040
mistake before you've got successful
execution

483
00:39:54,040 --> 00:39:59,580
just you've just given out of room so
there's a lot of crash dump analysis

484
00:39:59,580 --> 00:40:03,759
going on right now in the world scale is
crash dumps and fly here there and

485
00:40:03,760 --> 00:40:09,130
everywhere and I don't know this for
sure but I'm pretty certain that their

486
00:40:09,130 --> 00:40:15,690
alarm bells going off if you crash was
looking at a crash dummie it's fairly

487
00:40:15,690 --> 00:40:18,820
obvious that there's a stack of it going
on if you didn't send signals and that's

488
00:40:18,820 --> 00:40:22,830
it that's a big signal that may be an
expert is underway and it failed

489
00:40:22,830 --> 00:40:26,770
is not given the staff does not have
that problem

490
00:40:26,770 --> 00:40:30,750
gadgets are pretty common instruction
sequence I am I explained I used 3

491
00:40:30,750 --> 00:40:34,800
gadgets I find them all by hand I think
that's proof that is defined as the

492
00:40:34,800 --> 00:40:38,490
number of programs to find them for me

493
00:40:38,490 --> 00:40:43,509
gadget was a series of khap khap got its
run this tax was valid because the

494
00:40:43,510 --> 00:40:45,339
construction automatically

495
00:40:45,339 --> 00:40:50,930
does he does the stock management for
you and a continuation of execution is

496
00:40:50,930 --> 00:40:55,149
pretty easy with this as well so I
continuation of execution after you've

497
00:40:55,150 --> 00:40:58,519
popped the calc the process is still
stable when I was popping all these

498
00:40:58,519 --> 00:41:04,169
counts that was the same process not
damaged during shipping check out the

499
00:41:04,170 --> 00:41:09,119
continuation of execution is good with
because you didn't get back to you don't

500
00:41:09,119 --> 00:41:18,160
have to undergo I'm hitting the sack can
be difficult so nothing like a bit but

501
00:41:18,160 --> 00:41:28,270
to do a copy you set up you think the
table a bit like this

502
00:41:28,270 --> 00:41:32,630
the beginning we put a string which is
what we're going to execute loan

503
00:41:32,630 --> 00:41:40,340
calculator calculator on my Linux
distribution and when you enter it when

504
00:41:40,340 --> 00:41:44,090
you enter the vehicle Thursday according
to the exploitation sequence where the

505
00:41:44,090 --> 00:41:49,780
video was corrupted at least on Linux
the compiler that seems to compile

506
00:41:49,780 --> 00:41:55,010
fashion crime likes using the IRIX
register is a registered so we we coming

507
00:41:55,010 --> 00:42:00,420
with iraq's control them pointing to
this buffer started name calculator and

508
00:42:00,420 --> 00:42:07,130
then the vehicle is a position x 76
first gadget so we do there is we just

509
00:42:07,130 --> 00:42:14,260
copy and all that's doing is pointing
the audio register at the gnome

510
00:42:14,260 --> 00:42:18,110
calculator strength so that when we call
system the calculator will pop up within

511
00:42:18,110 --> 00:42:25,160
jump to get 250 ready to jump to get it
30 x20 that jump system and then the

512
00:42:25,160 --> 00:42:30,690
online sequences is pretty sweet so the
second gadget which I found very common

513
00:42:30,690 --> 00:42:33,870
just a little bit of the stock and then
returns so depending on how many copies

514
00:42:33,870 --> 00:42:37,609
you chained together you just the right
amount of the stack and you lost gadget

515
00:42:37,610 --> 00:42:41,700
and have it and then returned and
actually the expectation sequence on

516
00:42:41,700 --> 00:42:46,379
every count of them is like how many is
like this 7 well the first one is valued

517
00:42:46,380 --> 00:42:49,620
is the retail core which is part of the
real code but our faith has six

518
00:42:49,620 --> 00:42:53,700
instructions and then we're done so I
guess that may factor into the

519
00:42:53,700 --> 00:43:00,770
reliability of something so simply worth
mentioning mopping up so continuation of

520
00:43:00,770 --> 00:43:06,190
execution again because we have this
100% reliability / determine something

521
00:43:06,190 --> 00:43:10,410
going on that kind of memory were
operating with quite a bit of care as in

522
00:43:10,410 --> 00:43:13,100
when we did actually perform the actual
corruption that has taken over the

523
00:43:13,100 --> 00:43:16,750
process they're very small and precise
corruptions done in a very careful way

524
00:43:16,750 --> 00:43:20,460
so I'm doing them with it we didn't we
didn't have any sort of shotgun approach

525
00:43:20,460 --> 00:43:23,790
is going on at or anything like that so
I'm doing what we trash is easy we trust

526
00:43:23,790 --> 00:43:28,020
to small things I'm doing them is a
simple is preparing the V table at which

527
00:43:28,020 --> 00:43:31,550
rushed to the same out of bounds right
that we used to set their feet able to

528
00:43:31,550 --> 00:43:36,200
effectively table we decide it back
towards should be as easy as the first

529
00:43:36,200 --> 00:43:38,649
thing we trashed the second and the
other thing we trust is the vector

530
00:43:38,650 --> 00:43:39,470
length

531
00:43:39,470 --> 00:43:43,750
turns out we trashed at length by
running a shade of program that tracks

532
00:43:43,750 --> 00:43:47,140
the length because we're on the same
shade program but with a different input

533
00:43:47,140 --> 00:43:52,420
parameter to put it back to the original
value so again simplicity is was helping

534
00:43:52,420 --> 00:44:00,910
us get reliability in some ways what we
did it sounds complicated because a lot

535
00:44:00,910 --> 00:44:04,720
of steps doesn't matter if you've got
ten steps to a hundred steps if you know

536
00:44:04,720 --> 00:44:09,000
that each step is deterministic you have
as many steps you like things would work

537
00:44:09,000 --> 00:44:14,200
out for you so we did within chunk out
of bounds right to corrupt code in a

538
00:44:14,200 --> 00:44:18,348
shaded program will use that to do
within chunk out of bounds read to grab

539
00:44:18,349 --> 00:44:23,180
some useful stuff like every table
itself people dress using a healthy

540
00:44:23,180 --> 00:44:28,710
progresses knowledge we did a between
chunk out of bounds read but we know

541
00:44:28,710 --> 00:44:33,099
it's safe because if we had knowledge of
the heap addresses involved will use

542
00:44:33,099 --> 00:44:37,210
those safe but out of bounds reads to
prove that he play out of 5 very

543
00:44:37,210 --> 00:44:42,790
important objects was as we expected or
in a row and then we used our between

544
00:44:42,790 --> 00:44:47,420
chunk rights to clobber filled and
unfilled of an object and that works

545
00:44:47,420 --> 00:44:51,210
because if we pull the trigger on that
we proved that the heat was lined up

546
00:44:51,210 --> 00:44:55,710
exactly as we needed to be and then but
of course we discuss with its reliable

547
00:44:55,710 --> 00:45:02,200
them repair the damage and success but
always need to be asking ourselves this

548
00:45:02,200 --> 00:45:02,950
question

549
00:45:02,950 --> 00:45:07,598
trying to do a hundred reliable
exploitation we need to be asking

550
00:45:07,599 --> 00:45:12,380
yourself is it reliable is there some
sort of unreliable didn't think of is

551
00:45:12,380 --> 00:45:19,020
this one reliable reliable but for being
honest I don't I can't claim this is

552
00:45:19,020 --> 00:45:20,020
unacceptable

553
00:45:20,020 --> 00:45:21,690
let's look at why not

554
00:45:21,690 --> 00:45:27,470
so there's a common sources of
unreliability should always be asking

555
00:45:27,470 --> 00:45:31,540
yourself when you're doing an excellent
the first one you should ask is what

556
00:45:31,540 --> 00:45:38,900
about threats threats are joined there a
synchronous how to understand the heart

557
00:45:38,900 --> 00:45:43,910
to reason about it what about the
expertise damage just now versus threats

558
00:45:43,910 --> 00:45:45,779
so I'm grading myself here

559
00:45:45,780 --> 00:45:51,940
yellow sort of ok so the most likely
thing a threat is gonna mess up on is

560
00:45:51,940 --> 00:45:56,520
what actually is running in one thread
and access another thread is going to be

561
00:45:56,520 --> 00:46:01,770
doing something maybe rendering some 3d
stuff on the screen right and it will be

562
00:46:01,770 --> 00:46:05,410
allocating and freeing objects from the
same heat so it might mess up our he

563
00:46:05,410 --> 00:46:12,750
well that's ok will detect that cleanly
and will exit so that's ok but where the

564
00:46:12,750 --> 00:46:17,120
reason I'm giving myself a yellow sort
of ok great is this next statement here

565
00:46:17,120 --> 00:46:22,480
I do not believe that a threat to touch
the corrupted 3d object during the

566
00:46:22,480 --> 00:46:27,310
window of corruption so that's as I
think the exploit is unacceptable

567
00:46:27,310 --> 00:46:31,120
disregard what I have approved private I
would need to like study that area in

568
00:46:31,120 --> 00:46:35,880
quite some depth and spent quite some
time on it to to prove that the case I

569
00:46:35,880 --> 00:46:39,250
haven't done that so although I think
it's cool I can't claim is unacceptable

570
00:46:39,250 --> 00:46:47,260
haven't done the work so that's sort of
what I paid reload a page latest refresh

571
00:46:47,260 --> 00:46:56,090
the browser page reload is a tricky case
because Patriots will shut down

572
00:46:56,090 --> 00:47:01,080
everything and restart it so in the case
when you shutting everything down what

573
00:47:01,080 --> 00:47:04,040
sort of touching every opportunity and
deleting it destroying its it is a

574
00:47:04,040 --> 00:47:08,990
slightest mistake you've made your been
another or if the patriotic odes right

575
00:47:08,990 --> 00:47:12,709
in the middle of your expert running
things are in a dubious in the middle of

576
00:47:12,710 --> 00:47:17,630
exploitation state you might explode
with anger came here because they paid

577
00:47:17,630 --> 00:47:20,560
relied works and flashing tits
synchronous with respect to running

578
00:47:20,560 --> 00:47:25,890
script so as long as you don't accept
your script was your expectations half

579
00:47:25,890 --> 00:47:28,230
done and enjoy your freedom for you
access

580
00:47:28,230 --> 00:47:32,630
you'll be fine because the page reload
assembly handle office trip to Spain is

581
00:47:32,630 --> 00:47:37,460
running so given this also green for
that one out of memory pressure exhaust

582
00:47:37,460 --> 00:47:44,820
yourself running the process of you know
and any sort of state is hard to tell so

583
00:47:44,820 --> 00:47:50,430
what about what if this process just low
on memory was gonna happen so there is a

584
00:47:50,430 --> 00:47:54,910
case that will cause us trouble is a
well in fact sheet when members getting

585
00:47:54,910 --> 00:47:59,618
low this low on memory panic signal gets
sent around all over the place and one

586
00:47:59,619 --> 00:48:04,320
response to that is a start committing
pages in the heat and that's a problem

587
00:48:04,320 --> 00:48:08,500
he committed pages you touch it you blow
up and that's kind of annoying she might

588
00:48:08,500 --> 00:48:13,630
prove that address is invalid he
progressed he committed you touch it and

589
00:48:13,630 --> 00:48:17,480
you blow up but was digging ourselves
green great because you can actually

590
00:48:17,480 --> 00:48:23,040
there are rich ap / to query systems
including how much memory is free so you

591
00:48:23,040 --> 00:48:26,890
can't tell if you if you're in a tight
spot in all an act accordingly

592
00:48:26,890 --> 00:48:31,609
finally what about unusual virtual
address space layout and this is the

593
00:48:31,609 --> 00:48:35,930
problem that caused natalie is in
trouble with their floats but I'm giving

594
00:48:35,930 --> 00:48:39,770
myself a few great here because I
actually managed to understand the

595
00:48:39,770 --> 00:48:44,730
problems fish near to declare to to
understand and describe the problem is

596
00:48:44,730 --> 00:48:49,080
due to constraints of the che language
limiting these comparisons of where I

597
00:48:49,080 --> 00:48:53,710
miami Heat expect it turns out I'm only
comparing the lower 32 bits of a pointer

598
00:48:53,710 --> 00:48:59,109
and this is a 64 bit XP so it is
possible that if the heat gets really

599
00:48:59,109 --> 00:49:03,000
big and spans four gigabytes you can
have two point is that look the same on

600
00:49:03,000 --> 00:49:07,290
the lower 32 bits and one of them could
be safe to read off the end of the other

601
00:49:07,290 --> 00:49:13,210
might not so I'm giving myself a great
read because I can describe the

602
00:49:13,210 --> 00:49:16,980
situation that would cause a crash that
explain its not gonna happen without

603
00:49:16,980 --> 00:49:24,470
braces and also I think I could repair
it I would do if I were taking any

604
00:49:24,470 --> 00:49:27,560
further but I have to give us a ride
great that because I understand it

605
00:49:27,560 --> 00:49:33,430
condition that will determine if a fault
even if it's very likely so let's

606
00:49:33,430 --> 00:49:35,180
conclude

607
00:49:35,180 --> 00:49:40,180
so during this research what dominates
whether you can create a reliable

608
00:49:40,180 --> 00:49:45,640
exploit out of something I know is the
bug that used to say you don't start

609
00:49:45,640 --> 00:49:50,490
with a good which is good bug bug class
you're probably not going to get refunds

610
00:49:50,490 --> 00:49:55,799
conversely even if you do find a really
good starting bug can proceed forward

611
00:49:55,800 --> 00:50:01,160
with it so hard I think we thought we
got into this when we started with all

612
00:50:01,160 --> 00:50:06,490
some bugs that we were gonna have like a
three-step excellently done and we both

613
00:50:06,490 --> 00:50:10,359
ended up with like 20 step exploits what
we've struggled to keep our hands on a

614
00:50:10,359 --> 00:50:13,598
hundred on determinism at each step so
hard

615
00:50:13,599 --> 00:50:19,290
which was a bit of a surprise and there
always will support the fact that it

616
00:50:19,290 --> 00:50:22,619
difficult to control for so I was quite
surprised that virtual address space

617
00:50:22,619 --> 00:50:27,319
layout course I me headaches for us but
it did that was a surprise when you

618
00:50:27,319 --> 00:50:32,369
start thinking about threading think
just over thinking threading because

619
00:50:32,369 --> 00:50:39,230
they're doing is just difficult to think
about a reason about and finally one

620
00:50:39,230 --> 00:50:42,780
thing one question people ask why this
research is you know can use this can

621
00:50:42,780 --> 00:50:47,190
you use this research profitably for
defense and the answer is yes

622
00:50:47,190 --> 00:50:53,359
reasons for that one is that we think
you can't defend fully you can't defend

623
00:50:53,359 --> 00:51:00,190
with maximum maximum potency and she
really understand the extreme limits of

624
00:51:00,190 --> 00:51:05,010
what's possible in attack by trying to
make some of the best pieces of attack

625
00:51:05,010 --> 00:51:08,240
research possible hundred central a
blacksmith that's given us many sites

626
00:51:08,240 --> 00:51:11,189
that we weren't expecting to gain but
now that we've gained them are going to

627
00:51:11,190 --> 00:51:15,619
use his insights to start thinking about
well where could we have broken out of a

628
00:51:15,619 --> 00:51:19,559
liability was little defensive tweaks I
would definitely carry that forward over

629
00:51:19,559 --> 00:51:22,500
the next months and have you been
blogging about some ideas and perhaps

630
00:51:22,500 --> 00:51:31,240
even when landed solutions so with that
thanks very much for being so pretty

631
00:51:31,240 --> 00:51:46,490
intense technical couple of experts and
if we have time to take some question

632
00:51:46,490 --> 00:52:12,410
really probably this was the ability
dispute calculators and perhaps

633
00:52:12,410 --> 00:52:28,609
the sheer volume technical pace

634
00:52:28,610 --> 00:52:34,120
not releasing what we've just seen so
for those of you that saw the keynote

635
00:52:34,120 --> 00:52:38,009
earlier today we really believe in doing
everything we do we do it in the open

636
00:52:38,010 --> 00:52:42,000
and that means release everything we do
so over the next days will be releasing

637
00:52:42,000 --> 00:52:46,920
the slides will be releasing blog post
the site more accessible perhaps

638
00:52:46,920 --> 00:52:51,240
descriptions of what we've just seen
along with Facebook post links to the

639
00:52:51,240 --> 00:52:58,180
actual raw exploit materials say yes
follow blog here and over the next days

640
00:52:58,180 --> 00:53:04,500
/ weeks everything will be released we
just have to write will have to take up

641
00:53:04,500 --> 00:53:17,240
the bookcase and get it done really
coming very soon

642
00:53:17,240 --> 00:53:18,500
thank you very much

