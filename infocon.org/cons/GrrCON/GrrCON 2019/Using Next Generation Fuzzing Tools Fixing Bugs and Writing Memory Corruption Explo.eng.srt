1
00:00:08,540 --> 00:00:18,359
good afternoon I feel like I need a way

2
00:00:13,920 --> 00:00:20,340
bigger like intro I mean I'm looking for

3
00:00:18,359 --> 00:00:26,189
like explosion and I get one person kind

4
00:00:20,340 --> 00:00:28,560
of yeah hey hey how you doing see if I

5
00:00:26,189 --> 00:00:29,760
know it's freaking steaming in here I've

6
00:00:28,560 --> 00:00:30,840
been trying to figure out what we can do

7
00:00:29,760 --> 00:00:34,620
with that because we can't keep the

8
00:00:30,840 --> 00:00:35,790
doors open so sorry that's that's our

9
00:00:34,620 --> 00:00:37,349
attempt to try to put you to sleep

10
00:00:35,790 --> 00:00:38,730
that's how we see how good the speakers

11
00:00:37,350 --> 00:00:40,530
are because if you don't fall asleep

12
00:00:38,730 --> 00:00:42,870
that means they're pretty damn good and

13
00:00:40,530 --> 00:00:45,270
we have the best speakers here at con so

14
00:00:42,870 --> 00:00:46,800
we're gonna keep that trend going couple

15
00:00:45,270 --> 00:00:48,870
things one I don't think it's gonna be

16
00:00:46,800 --> 00:00:51,180
an issue but do not block the fire

17
00:00:48,870 --> 00:00:53,459
escapes please stay away from the doors

18
00:00:51,180 --> 00:00:54,930
come in come out I don't care what

19
00:00:53,460 --> 00:00:57,899
you're gonna do just do one or the other

20
00:00:54,930 --> 00:01:00,510
on that note you are in ballroom C this

21
00:00:57,899 --> 00:01:01,949
is the anything track so hopefully by

22
00:01:00,510 --> 00:01:03,899
now you've figured out where the three

23
00:01:01,949 --> 00:01:06,950
ballrooms are you're in the right one if

24
00:01:03,899 --> 00:01:09,299
not we're locking you in you're stuck

25
00:01:06,950 --> 00:01:11,070
cellphones that sort of thing turn them

26
00:01:09,299 --> 00:01:13,470
off no sounds please

27
00:01:11,070 --> 00:01:15,479
silent whatever I've been telling people

28
00:01:13,470 --> 00:01:19,470
all day I wore boots today I don't want

29
00:01:15,479 --> 00:01:23,429
to have to use them but I will alright

30
00:01:19,470 --> 00:01:26,640
so with that our next speaker we are

31
00:01:23,430 --> 00:01:29,579
talking all about the latest in fuzzing

32
00:01:26,640 --> 00:01:31,229
techniques and we're gonna get into some

33
00:01:29,579 --> 00:01:34,439
pretty deep discussion here I can't wait

34
00:01:31,229 --> 00:01:42,780
to hear this one at that with that hey

35
00:01:34,439 --> 00:01:44,490
give it on up for dr. Jared Zuma alright

36
00:01:42,780 --> 00:01:47,280
thanks for that appreciate it very

37
00:01:44,490 --> 00:01:51,390
excited to be here and be part of

38
00:01:47,280 --> 00:01:52,890
another amazing gurken hope everybody is

39
00:01:51,390 --> 00:01:55,860
having a great day so many exciting

40
00:01:52,890 --> 00:01:57,360
things going on we had some cool custom

41
00:01:55,860 --> 00:01:58,950
coffees this morning some of our other

42
00:01:57,360 --> 00:02:00,630
engineers right down here Greg and James

43
00:01:58,950 --> 00:02:02,640
are you talking about male where at 3:30

44
00:02:00,630 --> 00:02:04,229
next hour and what were you guys in a

45
00:02:02,640 --> 00:02:06,299
the first one what's the first one

46
00:02:04,229 --> 00:02:08,520
called Hackett defense you don't even

47
00:02:06,299 --> 00:02:11,700
know you might want to find out just

48
00:02:08,520 --> 00:02:13,770
letting you know that'd be good let's

49
00:02:11,700 --> 00:02:16,530
figure that out so my name is Jared

50
00:02:13,770 --> 00:02:18,570
my co-presenter John is not here

51
00:02:16,530 --> 00:02:21,060
physically but he helped me put this

52
00:02:18,570 --> 00:02:21,989
together so obviously appreciate that

53
00:02:21,060 --> 00:02:23,550
we're be talking about next generation

54
00:02:21,990 --> 00:02:26,130
fuzzing which is really cool kind of

55
00:02:23,550 --> 00:02:28,050
takes me back a long ways my first talk

56
00:02:26,130 --> 00:02:29,760
I ever gave at a security conference was

57
00:02:28,050 --> 00:02:31,800
well that was the first one but it was

58
00:02:29,760 --> 00:02:33,390
one of the major ones it's probably 2006

59
00:02:31,800 --> 00:02:36,570
or 7 and DEF CON I gave a talk on

60
00:02:33,390 --> 00:02:38,670
fuzzing and that was what's funny is the

61
00:02:36,570 --> 00:02:39,989
tools I'm gonna refer to as yesteryears

62
00:02:38,670 --> 00:02:41,519
tools at some point during this talk

63
00:02:39,990 --> 00:02:43,800
we're like the tools I was referring to

64
00:02:41,520 --> 00:02:45,780
as like the hottest at that time so

65
00:02:43,800 --> 00:02:48,870
that's the people we work in right where

66
00:02:45,780 --> 00:02:50,490
today's stuff becomes yesterday stuff at

67
00:02:48,870 --> 00:02:53,430
some point but that's cool because it

68
00:02:50,490 --> 00:02:54,780
you know it gives us all you know

69
00:02:53,430 --> 00:02:56,310
there's always something new there's

70
00:02:54,780 --> 00:02:58,560
always something fresh you always

71
00:02:56,310 --> 00:03:01,290
somebody always has to be kind of awake

72
00:02:58,560 --> 00:03:02,910
at the wheel and guiding the security of

73
00:03:01,290 --> 00:03:04,950
your software or your company or

74
00:03:02,910 --> 00:03:06,960
whatever it is because you know what

75
00:03:04,950 --> 00:03:08,790
you're what you did five years ago isn't

76
00:03:06,960 --> 00:03:13,170
gonna work today so that's a really

77
00:03:08,790 --> 00:03:14,579
interesting thing so yeah so about me

78
00:03:13,170 --> 00:03:18,170
real quick I started my career at the

79
00:03:14,580 --> 00:03:20,940
NSA 20 years ago worked in various other

80
00:03:18,170 --> 00:03:22,079
high tech companies and startups and

81
00:03:20,940 --> 00:03:23,820
things like that we have some training

82
00:03:22,080 --> 00:03:25,170
content on Pluralsight as well as we

83
00:03:23,820 --> 00:03:28,590
teach that in person if you guys are

84
00:03:25,170 --> 00:03:29,910
interested in any type of EPs a core ir

85
00:03:28,590 --> 00:03:32,610
or anything like that we do have a

86
00:03:29,910 --> 00:03:35,120
number of courses that we offer also the

87
00:03:32,610 --> 00:03:37,530
founder of ETA labs speaking of which

88
00:03:35,120 --> 00:03:39,840
I'll just go to that real quick without

89
00:03:37,530 --> 00:03:41,790
giving you guys a real long in-depth

90
00:03:39,840 --> 00:03:43,800
thing but in terms of what kind of what

91
00:03:41,790 --> 00:03:45,780
do we do at vda we basically do a lot of

92
00:03:43,800 --> 00:03:48,660
things across the number of sectors from

93
00:03:45,780 --> 00:03:50,790
pen testing to code auditing to training

94
00:03:48,660 --> 00:03:52,770
to IR for a lot of different kind of

95
00:03:50,790 --> 00:03:54,209
very interesting very fun customers we

96
00:03:52,770 --> 00:03:56,280
work on a lot of really cool projects

97
00:03:54,210 --> 00:03:58,590
for the enterprise and a lot of you guys

98
00:03:56,280 --> 00:04:01,260
work for businesses also for makers so

99
00:03:58,590 --> 00:04:02,940
if you're developing a product or if

100
00:04:01,260 --> 00:04:04,500
you're you know in the federal we do we

101
00:04:02,940 --> 00:04:06,050
even do some very interesting stuff for

102
00:04:04,500 --> 00:04:08,880
the law enforcement federal kind of a

103
00:04:06,050 --> 00:04:10,890
helping track down some some bad actors

104
00:04:08,880 --> 00:04:12,930
at some point so that's kind of a quick

105
00:04:10,890 --> 00:04:14,130
brief on who we are what we do and so

106
00:04:12,930 --> 00:04:15,660
what I'm talking about today is

107
00:04:14,130 --> 00:04:17,219
something called fuzzing maybe some of

108
00:04:15,660 --> 00:04:19,140
you've heard of it maybe you haven't and

109
00:04:17,220 --> 00:04:22,109
it relates to the whole space of apps

110
00:04:19,140 --> 00:04:23,789
EXO coach security and it's a huge field

111
00:04:22,108 --> 00:04:25,380
it's a broad I mean we could spend weeks

112
00:04:23,790 --> 00:04:27,120
talking about coach security there's a

113
00:04:25,380 --> 00:04:27,690
lot of things in the space bugs can show

114
00:04:27,120 --> 00:04:29,130
up

115
00:04:27,690 --> 00:04:31,800
you know in the governance in the

116
00:04:29,130 --> 00:04:34,400
training or you know kind of design bugs

117
00:04:31,800 --> 00:04:37,680
could show up in the construction

118
00:04:34,400 --> 00:04:38,609
verification you know there's just so

119
00:04:37,680 --> 00:04:40,590
many different places where

120
00:04:38,610 --> 00:04:42,030
vulnerabilities can creep into code and

121
00:04:40,590 --> 00:04:44,070
obviously we're not gonna have time to

122
00:04:42,030 --> 00:04:45,390
discuss each and every one of those so

123
00:04:44,070 --> 00:04:48,540
the major point we're talking about in

124
00:04:45,390 --> 00:04:50,550
this talk is security testing that's the

125
00:04:48,540 --> 00:04:51,630
kind of the area we're gonna focus on

126
00:04:50,550 --> 00:04:53,490
and some people feel like hey is

127
00:04:51,630 --> 00:04:56,010
security testing the actual testing part

128
00:04:53,490 --> 00:04:58,110
is that sort of over focused on relative

129
00:04:56,010 --> 00:05:00,900
to training or pushing security left and

130
00:04:58,110 --> 00:05:02,910
all that and maybe it's sometimes it can

131
00:05:00,900 --> 00:05:05,010
be but it's also probably one of the

132
00:05:02,910 --> 00:05:06,480
most important parts because that's

133
00:05:05,010 --> 00:05:08,969
where the vulnerabilities tend to show

134
00:05:06,480 --> 00:05:10,470
up in code is when software is actually

135
00:05:08,970 --> 00:05:12,810
constructed you may have had a great

136
00:05:10,470 --> 00:05:14,190
design you may have a great theory but

137
00:05:12,810 --> 00:05:16,620
then when it's actually implemented

138
00:05:14,190 --> 00:05:18,810
there's a confusing or misused API that

139
00:05:16,620 --> 00:05:21,210
leads to a vulnerability in the actual

140
00:05:18,810 --> 00:05:23,070
software and so the the basic business

141
00:05:21,210 --> 00:05:24,870
case for why do we even need to do any

142
00:05:23,070 --> 00:05:26,250
of this security testing it's it's the

143
00:05:24,870 --> 00:05:28,320
same business case we use across

144
00:05:26,250 --> 00:05:29,730
everything in security which is if we

145
00:05:28,320 --> 00:05:31,140
don't spend a little bit of money now

146
00:05:29,730 --> 00:05:32,580
we'll spend a lotta bit of money later

147
00:05:31,140 --> 00:05:34,710
that's that's the essential business

148
00:05:32,580 --> 00:05:37,500
case that is true in every part of

149
00:05:34,710 --> 00:05:41,880
security and it's true in software as

150
00:05:37,500 --> 00:05:43,620
well so in terms of you know software

151
00:05:41,880 --> 00:05:45,900
security since that is the topic of the

152
00:05:43,620 --> 00:05:47,190
day which piece of that specifically

153
00:05:45,900 --> 00:05:49,590
because there's component analysis

154
00:05:47,190 --> 00:05:51,450
there's static analysis there's dynamic

155
00:05:49,590 --> 00:05:53,789
there's manual you know yearly

156
00:05:51,450 --> 00:05:55,380
third-party code out of pen test that

157
00:05:53,790 --> 00:05:57,570
needs to be done in most cases it's

158
00:05:55,380 --> 00:05:59,100
either required or desired so which of

159
00:05:57,570 --> 00:06:01,020
that piece mostly we're gonna be talking

160
00:05:59,100 --> 00:06:03,060
about dynamic analysis that's where

161
00:06:01,020 --> 00:06:05,250
fuzzing fits into that product security

162
00:06:03,060 --> 00:06:08,310
engineering lifecycle and it could also

163
00:06:05,250 --> 00:06:11,160
be called - dynamic application security

164
00:06:08,310 --> 00:06:13,410
testing so that's another phrase you may

165
00:06:11,160 --> 00:06:14,490
hear called so we're not going to talk

166
00:06:13,410 --> 00:06:16,140
about every piece of that like I said

167
00:06:14,490 --> 00:06:18,000
we're also not gonna spend a lot of time

168
00:06:16,140 --> 00:06:20,340
talking about different languages or

169
00:06:18,000 --> 00:06:22,080
different vulnerabilities or OS top ten

170
00:06:20,340 --> 00:06:24,359
versus memory corruption vulnerabilities

171
00:06:22,080 --> 00:06:26,130
are so many different things across the

172
00:06:24,360 --> 00:06:27,900
spectrum of what matters when it comes

173
00:06:26,130 --> 00:06:29,880
to security testing it depends on a lot

174
00:06:27,900 --> 00:06:31,890
of things your product the language

175
00:06:29,880 --> 00:06:34,590
there's all these different things and

176
00:06:31,890 --> 00:06:37,860
we do cover that much more deeply in the

177
00:06:34,590 --> 00:06:39,479
app set course that we cover so why are

178
00:06:37,860 --> 00:06:41,490
we why are we talking about fuzzing then

179
00:06:39,479 --> 00:06:43,979
in particular why not dev sec ops or

180
00:06:41,490 --> 00:06:45,330
cloud sack or mobile apps or web apps

181
00:06:43,979 --> 00:06:48,120
there's so many other topics I could

182
00:06:45,330 --> 00:06:49,560
have chosen to speak on and research and

183
00:06:48,120 --> 00:06:50,880
there's there's those are all great

184
00:06:49,560 --> 00:06:53,759
things to speak about those are all

185
00:06:50,880 --> 00:06:55,620
amazing topics and there's tools in all

186
00:06:53,759 --> 00:06:56,970
of those areas this is a couple

187
00:06:55,620 --> 00:06:58,639
screenshots of different commercial

188
00:06:56,970 --> 00:07:00,960
static analysis tools that we've used

189
00:06:58,639 --> 00:07:03,509
they're great we can spend time talking

190
00:07:00,960 --> 00:07:05,008
about those all day long and that would

191
00:07:03,509 --> 00:07:07,080
be very good to cover as well but

192
00:07:05,009 --> 00:07:08,849
there's a couple reasons why I decided

193
00:07:07,080 --> 00:07:10,409
to focus on fuzzing for this research

194
00:07:08,849 --> 00:07:12,330
that we did this year we kind of pick a

195
00:07:10,410 --> 00:07:14,310
topic something that we look into and

196
00:07:12,330 --> 00:07:15,990
research each year and prior years

197
00:07:14,310 --> 00:07:17,940
you've heard me speak here at ger con

198
00:07:15,990 --> 00:07:20,310
about IOT security for example we do a

199
00:07:17,940 --> 00:07:22,919
lot of that and other topics in the past

200
00:07:20,310 --> 00:07:24,389
as well related to different topics but

201
00:07:22,919 --> 00:07:26,880
one of the things that's cool about

202
00:07:24,389 --> 00:07:30,060
fuzzing is that not a lot had really

203
00:07:26,880 --> 00:07:31,680
changed in the last five years until

204
00:07:30,060 --> 00:07:33,120
just recently there's some new tools

205
00:07:31,680 --> 00:07:35,300
that just came out within the last

206
00:07:33,120 --> 00:07:37,770
couple years that are really kind of

207
00:07:35,300 --> 00:07:39,750
game-changing very different in the way

208
00:07:37,770 --> 00:07:41,969
that they operate kind of move the ball

209
00:07:39,750 --> 00:07:43,229
forward and sort of a a new sort of

210
00:07:41,970 --> 00:07:44,340
breakthrough type of thing and so that's

211
00:07:43,229 --> 00:07:46,859
one that's the reason why I really

212
00:07:44,340 --> 00:07:48,929
decided to focus on - and fuzzing in

213
00:07:46,860 --> 00:07:52,199
this particular thing the other reason

214
00:07:48,930 --> 00:07:54,449
is that you know dat fuzzing in

215
00:07:52,199 --> 00:07:56,250
particular is an interesting niche of

216
00:07:54,449 --> 00:07:59,190
security testing because it does focus

217
00:07:56,250 --> 00:08:01,469
mostly on native code so fully compiled

218
00:07:59,190 --> 00:08:02,940
C and C++ type apps and you might think

219
00:08:01,469 --> 00:08:05,639
boys are really much of that anymore

220
00:08:02,940 --> 00:08:07,050
because really most businesses should be

221
00:08:05,639 --> 00:08:09,090
writing a mobile app they should be

222
00:08:07,050 --> 00:08:11,400
using like maybe react JavaScript or

223
00:08:09,090 --> 00:08:13,198
maybe they're using some Python for

224
00:08:11,400 --> 00:08:15,388
their cloud stuff or they're using Ruby

225
00:08:13,199 --> 00:08:17,009
or c-sharp or Java there's all the other

226
00:08:15,389 --> 00:08:18,630
languages that have different types of

227
00:08:17,009 --> 00:08:22,319
vulnerabilities more focused on the OS

228
00:08:18,630 --> 00:08:24,060
top 10 but some of the spaces that we

229
00:08:22,319 --> 00:08:25,860
work in we've been like I said we do

230
00:08:24,060 --> 00:08:27,599
work even in the federal and other other

231
00:08:25,860 --> 00:08:29,280
types of places and platform we've been

232
00:08:27,599 --> 00:08:30,719
helping Microsoft with some work and so

233
00:08:29,280 --> 00:08:34,348
when you look at operating system

234
00:08:30,719 --> 00:08:39,539
kernels embedded systems you know space

235
00:08:34,349 --> 00:08:41,370
systems missiles airplanes SCADA ICS IOT

236
00:08:39,539 --> 00:08:42,750
under the hood they're all still running

237
00:08:41,370 --> 00:08:46,380
native code they're all still running

238
00:08:42,750 --> 00:08:48,420
unmanaged unsafe C and C++ and it's in

239
00:08:46,380 --> 00:08:50,339
many cases it might be code that's been

240
00:08:48,420 --> 00:08:52,170
running for 20 30 years some Linux

241
00:08:50,339 --> 00:08:54,010
utilities or something like that that's

242
00:08:52,170 --> 00:08:55,719
considered to be safe code

243
00:08:54,010 --> 00:08:57,310
because it's been out there so long it's

244
00:08:55,720 --> 00:08:58,750
been fielded so long it's pretty like

245
00:08:57,310 --> 00:09:01,119
you know you're not gonna find a

246
00:08:58,750 --> 00:09:02,680
vulnerability in the LS command in UNIX

247
00:09:01,120 --> 00:09:04,000
if you try to fuzz it or something or

248
00:09:02,680 --> 00:09:05,109
you wouldn't think so at least but we

249
00:09:04,000 --> 00:09:07,269
actually did some of that in this

250
00:09:05,110 --> 00:09:08,680
project and surprisingly we find that if

251
00:09:07,269 --> 00:09:10,570
you have the right technique we can find

252
00:09:08,680 --> 00:09:13,149
vulnerabilities and code that's been

253
00:09:10,570 --> 00:09:17,170
around for 30 years that it's very

254
00:09:13,149 --> 00:09:18,760
interesting so well tested you know code

255
00:09:17,170 --> 00:09:19,959
we can still find vulnerabilities with

256
00:09:18,760 --> 00:09:21,010
these new fuzzing techniques so that's

257
00:09:19,959 --> 00:09:23,018
that's the reason why I got excited

258
00:09:21,010 --> 00:09:24,399
about this and wanted to speak about

259
00:09:23,019 --> 00:09:27,250
this rather than some of the other

260
00:09:24,399 --> 00:09:28,209
topics like api's or input fields or all

261
00:09:27,250 --> 00:09:30,970
these other things that we could talk

262
00:09:28,209 --> 00:09:32,260
about related to other things which we

263
00:09:30,970 --> 00:09:34,690
can still talk about so in terms of

264
00:09:32,260 --> 00:09:37,720
fuzzing the pros are basically that we

265
00:09:34,690 --> 00:09:39,490
have less false positives related to

266
00:09:37,720 --> 00:09:41,680
compared to static analysis basically

267
00:09:39,490 --> 00:09:43,420
the cons is that it's been criticized

268
00:09:41,680 --> 00:09:45,609
for is that basically you don't go quite

269
00:09:43,420 --> 00:09:48,099
as deep in your analysis when you're

270
00:09:45,610 --> 00:09:49,360
doing you know that took me because

271
00:09:48,100 --> 00:09:51,160
you're basically touching the attack

272
00:09:49,360 --> 00:09:52,389
surface you're not necessarily testing

273
00:09:51,160 --> 00:09:53,980
the whole code base like a static

274
00:09:52,389 --> 00:09:56,230
analysis tool could do so that's kind of

275
00:09:53,980 --> 00:09:57,550
the the pros and cons of static versus

276
00:09:56,230 --> 00:09:58,899
dynamic and really the reality is we

277
00:09:57,550 --> 00:10:01,359
need them all we need component static

278
00:09:58,899 --> 00:10:02,620
dynamic manual and I can talk more you

279
00:10:01,360 --> 00:10:04,360
know about each one of those in detail

280
00:10:02,620 --> 00:10:06,819
and depth if you guys want to find me

281
00:10:04,360 --> 00:10:09,069
afterwards and we'll we'll cover you

282
00:10:06,819 --> 00:10:11,229
know more on that so what I want to do

283
00:10:09,069 --> 00:10:13,360
is give you just a real brief background

284
00:10:11,230 --> 00:10:15,160
on some of the traditional fuzzing tools

285
00:10:13,360 --> 00:10:17,470
kind of where the field was and now

286
00:10:15,160 --> 00:10:20,290
where it is now so traditionally we had

287
00:10:17,470 --> 00:10:21,699
a few methods we had mutation fuzzing

288
00:10:20,290 --> 00:10:23,709
and that was basically you take some

289
00:10:21,699 --> 00:10:25,180
seeds which those are your input files

290
00:10:23,709 --> 00:10:26,500
that you want to test with so for

291
00:10:25,180 --> 00:10:29,949
example if you're testing an image

292
00:10:26,500 --> 00:10:32,380
viewer in a PDF platform you know a

293
00:10:29,949 --> 00:10:34,630
document reader anything like that or a

294
00:10:32,380 --> 00:10:36,790
network service with a pcap you know

295
00:10:34,630 --> 00:10:38,680
might be your input you just take that

296
00:10:36,790 --> 00:10:39,790
and you mutate it you slide a D word of

297
00:10:38,680 --> 00:10:41,649
data through it or you flip a couple

298
00:10:39,790 --> 00:10:43,899
bits or you zero out some fields and

299
00:10:41,649 --> 00:10:45,339
that's pretty good the only downside of

300
00:10:43,899 --> 00:10:47,529
that is really you have long run times

301
00:10:45,339 --> 00:10:49,089
so the criticism of mutation fuzzing is

302
00:10:47,529 --> 00:10:50,260
a we're not really sure what kind of

303
00:10:49,089 --> 00:10:53,170
coverage we're getting with most of

304
00:10:50,260 --> 00:10:54,670
these traditional techniques and B we

305
00:10:53,170 --> 00:10:55,959
need a lot of horsepower to let it run

306
00:10:54,670 --> 00:10:56,920
forever to find vulnerabilities because

307
00:10:55,959 --> 00:10:58,359
what you're doing is you're basically

308
00:10:56,920 --> 00:11:00,339
taking an input and you're saying okay

309
00:10:58,360 --> 00:11:02,019
let me give this document to power point

310
00:11:00,339 --> 00:11:03,339
does it crash no okay let me twill a few

311
00:11:02,019 --> 00:11:04,540
bits does it crash now nope still

312
00:11:03,339 --> 00:11:06,430
doesn't crash let me twiddle a few bits

313
00:11:04,540 --> 00:11:07,360
does it crash now no you just do this

314
00:11:06,430 --> 00:11:09,010
like millions of

315
00:11:07,360 --> 00:11:11,230
until you finally find a crash and

316
00:11:09,010 --> 00:11:12,279
whatever you're testing and then okay

317
00:11:11,230 --> 00:11:14,170
you found a vulnerability very

318
00:11:12,279 --> 00:11:15,730
interesting well that worked pretty well

319
00:11:14,170 --> 00:11:17,740
and then later on came a thing called

320
00:11:15,730 --> 00:11:19,899
generation fuzzing which is where you

321
00:11:17,740 --> 00:11:22,779
actually know about the the model of the

322
00:11:19,899 --> 00:11:24,519
data so first four bytes are hashed next

323
00:11:22,779 --> 00:11:26,200
three bytes are a length the next few

324
00:11:24,519 --> 00:11:27,519
bytes are the font and the colors and

325
00:11:26,200 --> 00:11:29,620
all you you understand the structure of

326
00:11:27,519 --> 00:11:31,209
the data and you create test cases based

327
00:11:29,620 --> 00:11:33,610
on the structure of the data and that's

328
00:11:31,209 --> 00:11:35,109
really great the the sort of criticism

329
00:11:33,610 --> 00:11:36,790
of that approach is that those data

330
00:11:35,110 --> 00:11:38,110
models are laborious to create you

331
00:11:36,790 --> 00:11:39,849
basically need a fuzz engineer on staff

332
00:11:38,110 --> 00:11:42,970
that understands data models to be able

333
00:11:39,850 --> 00:11:44,470
to create those so good stuff then we

334
00:11:42,970 --> 00:11:46,180
had another approach called sweet based

335
00:11:44,470 --> 00:11:47,800
fuzzing and that was there was a company

336
00:11:46,180 --> 00:11:50,040
called Cody nomicon out of Finland they

337
00:11:47,800 --> 00:11:52,329
got acquired by synopsis in there that

338
00:11:50,040 --> 00:11:54,189
capability is now called Defense X and

339
00:11:52,329 --> 00:11:57,579
what they have is basically a bunch of

340
00:11:54,190 --> 00:11:58,930
pre-built fuzzers that can send test

341
00:11:57,579 --> 00:12:00,370
cases based on certain protocols

342
00:11:58,930 --> 00:12:01,750
especially Network protocols so like if

343
00:12:00,370 --> 00:12:03,370
you want to fuzz Bluetooth interface

344
00:12:01,750 --> 00:12:05,620
they have a Bluetooth buzzer you just

345
00:12:03,370 --> 00:12:06,970
run all these test cases and probably

346
00:12:05,620 --> 00:12:08,680
it'll find a crash in your Bluetooth

347
00:12:06,970 --> 00:12:10,120
interface that's kind of the way that

348
00:12:08,680 --> 00:12:11,949
they they did that and that was really

349
00:12:10,120 --> 00:12:13,060
good approach again the problem with

350
00:12:11,949 --> 00:12:14,649
that is though it's just you're just

351
00:12:13,060 --> 00:12:16,390
running the suite as it is it's not

352
00:12:14,649 --> 00:12:18,640
getting better over time it's not

353
00:12:16,390 --> 00:12:19,990
measuring code coverage the in fact you

354
00:12:18,640 --> 00:12:21,399
have to do the monitoring yourself it's

355
00:12:19,990 --> 00:12:24,279
just you're just buying this suite of

356
00:12:21,399 --> 00:12:26,589
test cases really so good stuff but not

357
00:12:24,279 --> 00:12:28,720
perfect so in summary of the older

358
00:12:26,589 --> 00:12:31,839
techniques of fuzzing we had tools like

359
00:12:28,720 --> 00:12:33,339
GPFS by the artifice a mini fuzz B F F

360
00:12:31,839 --> 00:12:36,550
word asthma

361
00:12:33,339 --> 00:12:38,769
Sully peach let me see if it my clicker

362
00:12:36,550 --> 00:12:41,560
is sort of slowly catching up to me

363
00:12:38,769 --> 00:12:43,570
kernel fuzz again defense sakes all

364
00:12:41,560 --> 00:12:45,399
these other approaches all great tools

365
00:12:43,570 --> 00:12:48,190
they found play bugs you know they were

366
00:12:45,399 --> 00:12:50,260
good in their day but really they don't

367
00:12:48,190 --> 00:12:52,240
keep up with the most modern standards

368
00:12:50,260 --> 00:12:53,829
of fuzzing now so that's sort of the

369
00:12:52,240 --> 00:12:54,970
backdrop those names may or may not mean

370
00:12:53,829 --> 00:12:56,410
anything to you whether or not you've

371
00:12:54,970 --> 00:12:58,690
spent time research in this field I

372
00:12:56,410 --> 00:13:00,040
spend a lot of my time researching this

373
00:12:58,690 --> 00:13:01,720
kind of stuff because I actually did

374
00:13:00,040 --> 00:13:03,790
some of this nextgen fuzzing stuff as

375
00:13:01,720 --> 00:13:05,829
part of my PhD thesis when I went to

376
00:13:03,790 --> 00:13:07,540
Michigan State so and the idea behind

377
00:13:05,829 --> 00:13:10,449
feedback buzzing that's the newest type

378
00:13:07,540 --> 00:13:12,459
is imagine some code where you've got a

379
00:13:10,449 --> 00:13:15,069
bug like this assert sort of hidden in

380
00:13:12,459 --> 00:13:16,239
this place in the code and the only way

381
00:13:15,070 --> 00:13:17,589
you'll ever trigger that vulnerability

382
00:13:16,240 --> 00:13:19,480
is if you put in two very specific

383
00:13:17,589 --> 00:13:21,209
inputs that you're unlikely to randomly

384
00:13:19,480 --> 00:13:24,179
guess so if you have

385
00:13:21,209 --> 00:13:26,998
sample input of 1 & 2 you might mutate x

386
00:13:24,179 --> 00:13:29,220
& y in this case to be 10 and 12 you

387
00:13:26,999 --> 00:13:31,079
don't hit the bug you mutate it to be 74

388
00:13:29,220 --> 00:13:32,579
and 63 you still don't hit the book so

389
00:13:31,079 --> 00:13:35,790
your mutation fuzzers they're not likely

390
00:13:32,579 --> 00:13:38,819
to hit this vulnerability and so that

391
00:13:35,790 --> 00:13:40,410
testing approach is only so-so and so

392
00:13:38,819 --> 00:13:42,628
there was this idea of well what if we

393
00:13:40,410 --> 00:13:43,740
created some fuzzing approaches that

394
00:13:42,629 --> 00:13:45,240
could actually find those

395
00:13:43,740 --> 00:13:47,160
vulnerabilities themselves in some way

396
00:13:45,240 --> 00:13:48,720
they could they could you know get

397
00:13:47,160 --> 00:13:51,179
feedback from the application in the

398
00:13:48,720 --> 00:13:52,649
form of code coverage or in the form of

399
00:13:51,179 --> 00:13:54,629
constraint solving so those are called

400
00:13:52,649 --> 00:13:57,540
feedback or guided fuzzing and there's

401
00:13:54,629 --> 00:13:59,759
two main approaches that are kind of

402
00:13:57,540 --> 00:14:01,439
came out of that one came out of

403
00:13:59,759 --> 00:14:04,350
Microsoft's Research Lab it was a tool

404
00:14:01,439 --> 00:14:07,079
called sage and the way sage works is it

405
00:14:04,350 --> 00:14:09,449
basically solves constraints as well as

406
00:14:07,079 --> 00:14:11,099
adding fuzzing heuristics so you take

407
00:14:09,449 --> 00:14:12,839
those if statements and if you went down

408
00:14:11,100 --> 00:14:14,249
one branch one time the next time you

409
00:14:12,839 --> 00:14:16,410
hit that same branch statement it'll

410
00:14:14,249 --> 00:14:18,600
reverse or change the input such that

411
00:14:16,410 --> 00:14:20,730
you follow the other leg of that logic

412
00:14:18,600 --> 00:14:23,069
and that's called constraint solving or

413
00:14:20,730 --> 00:14:24,540
symbolic execution and that's what

414
00:14:23,069 --> 00:14:25,769
they've done and that's very effective

415
00:14:24,540 --> 00:14:27,629
because basically now all of a sudden

416
00:14:25,769 --> 00:14:29,699
your code coverage is exploding much

417
00:14:27,629 --> 00:14:31,529
more quickly you're making sort of

418
00:14:29,699 --> 00:14:33,209
progress through the binary in terms of

419
00:14:31,529 --> 00:14:35,009
testing more of the attack surface much

420
00:14:33,209 --> 00:14:36,989
more quickly than you would with kind of

421
00:14:35,009 --> 00:14:39,480
randomly guessing the other approach and

422
00:14:36,990 --> 00:14:40,829
what I took in my research is AFL this

423
00:14:39,480 --> 00:14:41,279
act this tool actually came out of

424
00:14:40,829 --> 00:14:43,229
Google's

425
00:14:41,279 --> 00:14:45,209
research and they use it a lot when they

426
00:14:43,230 --> 00:14:46,769
fuzz chrome and many of their other

427
00:14:45,209 --> 00:14:48,508
applications they also have a huge

428
00:14:46,769 --> 00:14:51,569
amount of CPUs that they throw at stuff

429
00:14:48,509 --> 00:14:54,860
so they have that advantage as well but

430
00:14:51,569 --> 00:14:58,729
they use what's called evolutionary or

431
00:14:54,860 --> 00:15:00,959
generation based fuzzing so you ve a

432
00:14:58,730 --> 00:15:02,610
genetic algorithm and what that does is

433
00:15:00,959 --> 00:15:06,329
that measures code coverage but instead

434
00:15:02,610 --> 00:15:07,920
of solving constraints precisely it just

435
00:15:06,329 --> 00:15:09,299
sort of guesses says this input went

436
00:15:07,920 --> 00:15:11,009
down this path this other input went

437
00:15:09,299 --> 00:15:12,540
down this path what if we cut those two

438
00:15:11,009 --> 00:15:13,829
inputs in half and we basically marry

439
00:15:12,540 --> 00:15:15,389
them together we made them in some way

440
00:15:13,829 --> 00:15:17,368
then we have the children of these prior

441
00:15:15,389 --> 00:15:18,990
generation of inputs perhaps that will

442
00:15:17,369 --> 00:15:20,850
get better input so it's sort of

443
00:15:18,990 --> 00:15:22,799
inspired by this evolutionary idea and

444
00:15:20,850 --> 00:15:25,170
so it's a less precise algorithm for

445
00:15:22,799 --> 00:15:26,970
seeking and searching but it tends to in

446
00:15:25,170 --> 00:15:29,969
large programs in practice where there's

447
00:15:26,970 --> 00:15:32,399
thousands or millions of logic cases it

448
00:15:29,970 --> 00:15:34,650
finds all these weird cases fairly

449
00:15:32,399 --> 00:15:35,960
quickly compared to sort of brute force

450
00:15:34,650 --> 00:15:37,980
constraint solving so it's not as

451
00:15:35,960 --> 00:15:40,530
theoretically solid as constraint

452
00:15:37,980 --> 00:15:42,120
solving but it does some things that are

453
00:15:40,530 --> 00:15:45,390
kind of interesting in terms of search

454
00:15:42,120 --> 00:15:47,970
so what I want to talk about really what

455
00:15:45,390 --> 00:15:49,710
the kind of the the crux of this talk is

456
00:15:47,970 --> 00:15:51,240
is there's two new tools that are on the

457
00:15:49,710 --> 00:15:52,470
market they're both commercial tools and

458
00:15:51,240 --> 00:15:53,910
we're not here to sort of pitch them or

459
00:15:52,470 --> 00:15:55,050
sell them in any way we just got access

460
00:15:53,910 --> 00:15:56,520
to them and we were allowed to play with

461
00:15:55,050 --> 00:15:57,839
them and we thought we'd share our

462
00:15:56,520 --> 00:16:00,000
results because it's been really fun

463
00:15:57,840 --> 00:16:01,710
kind of we're probably the only company

464
00:16:00,000 --> 00:16:03,180
that I know maybe even like in the whole

465
00:16:01,710 --> 00:16:04,770
world or at least that I know of around

466
00:16:03,180 --> 00:16:07,469
here that has access to both these tool

467
00:16:04,770 --> 00:16:09,300
because they're both private tools MS RD

468
00:16:07,470 --> 00:16:11,790
is Microsoft's commercial offering of

469
00:16:09,300 --> 00:16:12,900
sage which you can now buy so I guess if

470
00:16:11,790 --> 00:16:14,339
you're willing to buy both you'd have

471
00:16:12,900 --> 00:16:15,540
both but they're both pretty new so

472
00:16:14,340 --> 00:16:17,580
there's probably not a lot of places

473
00:16:15,540 --> 00:16:20,730
that have bought both already and mayham

474
00:16:17,580 --> 00:16:24,390
comes from the Carnegie Mellon Research

475
00:16:20,730 --> 00:16:26,280
Unit led by David Bromley he had a

476
00:16:24,390 --> 00:16:28,530
hacking team and captured the flag team

477
00:16:26,280 --> 00:16:30,600
that was doing quite well and they

478
00:16:28,530 --> 00:16:32,189
decided to compete in DARPA cyber Grand

479
00:16:30,600 --> 00:16:34,560
Challenge so they created a tool called

480
00:16:32,190 --> 00:16:36,480
mayham that actually won that challenge

481
00:16:34,560 --> 00:16:39,119
and it used basically AFL under the hood

482
00:16:36,480 --> 00:16:41,040
as a buzzer but they added a symbolic

483
00:16:39,120 --> 00:16:42,690
execution as well so they kind of made

484
00:16:41,040 --> 00:16:44,400
it staged like in that sense so they're

485
00:16:42,690 --> 00:16:46,700
kind of similar tools in a way even

486
00:16:44,400 --> 00:16:49,079
though under the hood what the actual

487
00:16:46,700 --> 00:16:52,620
tech that they use is slightly different

488
00:16:49,080 --> 00:16:54,960
but the concept of you know guided

489
00:16:52,620 --> 00:16:56,370
fuzzing basically guided testing and

490
00:16:54,960 --> 00:16:58,770
driving toward better inputs

491
00:16:56,370 --> 00:16:59,970
automatically is very similar so we've

492
00:16:58,770 --> 00:17:02,610
been able to play with both and it's

493
00:16:59,970 --> 00:17:04,740
been really exciting so there's an even

494
00:17:02,610 --> 00:17:07,250
newer thought around I saw a gentleman

495
00:17:04,740 --> 00:17:09,630
give a talk blackhat this year a Brown

496
00:17:07,250 --> 00:17:11,250
structured plus guided fuzzing so taking

497
00:17:09,630 --> 00:17:13,080
these concepts of guided fuzzing and

498
00:17:11,250 --> 00:17:14,700
then adding structure to that as well

499
00:17:13,079 --> 00:17:16,710
and that makes a lot of sense because

500
00:17:14,700 --> 00:17:20,060
basically the the case he was making

501
00:17:16,710 --> 00:17:22,530
there was it makes a lot of sense to

502
00:17:20,060 --> 00:17:25,200
employ guided fuzzing in all this but

503
00:17:22,530 --> 00:17:27,389
still if your search strategy is more or

504
00:17:25,200 --> 00:17:30,510
less changing bits it may take a very

505
00:17:27,390 --> 00:17:32,610
long time to you know get significant

506
00:17:30,510 --> 00:17:34,590
code coverage of a large and complex

507
00:17:32,610 --> 00:17:35,939
application for example if the thing

508
00:17:34,590 --> 00:17:38,010
that you're fuzzing is a JavaScript

509
00:17:35,940 --> 00:17:41,040
engine and you're just sort of flipping

510
00:17:38,010 --> 00:17:42,620
bits in a sample program well you're

511
00:17:41,040 --> 00:17:44,370
probably just changing the program in

512
00:17:42,620 --> 00:17:46,379
nonsensical ways that won't actually

513
00:17:44,370 --> 00:17:48,418
compile and it has to compile for it to

514
00:17:46,380 --> 00:17:49,799
be parsed by the JavaScript

515
00:17:48,419 --> 00:17:52,350
such that vulnerabilities would be

516
00:17:49,799 --> 00:17:54,239
discovered so it makes sense to add

517
00:17:52,350 --> 00:17:56,908
structure to that so that your mutations

518
00:17:54,239 --> 00:17:58,409
are specific toward the protocol in

519
00:17:56,909 --> 00:17:59,820
which you're fuzzing so in other words

520
00:17:58,409 --> 00:18:01,499
instead of just flipping a few bits in a

521
00:17:59,820 --> 00:18:03,059
binary file you're actually saying hey

522
00:18:01,499 --> 00:18:04,559
if we're gonna change a curly brace here

523
00:18:03,059 --> 00:18:06,840
we better change the opening one too and

524
00:18:04,559 --> 00:18:08,249
make it have it still makes sense to the

525
00:18:06,840 --> 00:18:10,590
application in which it's going to be

526
00:18:08,249 --> 00:18:12,509
processed so they're still I would say

527
00:18:10,590 --> 00:18:14,369
fuzzing is still a it's not like

528
00:18:12,509 --> 00:18:15,749
everything in security it's still not

529
00:18:14,369 --> 00:18:17,129
like solved it's not like hey we're just

530
00:18:15,749 --> 00:18:19,049
done because we've found this new tool

531
00:18:17,129 --> 00:18:20,820
and we have this new technique there in

532
00:18:19,049 --> 00:18:22,289
ten years I'll probably be back talking

533
00:18:20,820 --> 00:18:23,369
about another tool that's even newer and

534
00:18:22,289 --> 00:18:25,109
better than these right it's just kind

535
00:18:23,369 --> 00:18:27,269
of the nature of the field in which we

536
00:18:25,109 --> 00:18:28,590
work so again if that didn't quite make

537
00:18:27,269 --> 00:18:30,570
sense a picture of sort of what I'm

538
00:18:28,590 --> 00:18:32,939
talking about is you take an input you

539
00:18:30,570 --> 00:18:35,279
test to see against your fuzzing tool to

540
00:18:32,940 --> 00:18:37,109
make sure that those original seeds and

541
00:18:35,279 --> 00:18:41,220
the original seeds you choose are very

542
00:18:37,109 --> 00:18:42,539
important and the reason for that is you

543
00:18:41,220 --> 00:18:44,220
know you want to make sure that you get

544
00:18:42,539 --> 00:18:45,629
good coverage to start with across your

545
00:18:44,220 --> 00:18:47,340
application so your original seed

546
00:18:45,629 --> 00:18:48,480
shouldn't crash your application and it

547
00:18:47,340 --> 00:18:50,970
should maybe you have a whole directory

548
00:18:48,480 --> 00:18:53,850
full of seeds that cover different parts

549
00:18:50,970 --> 00:18:55,769
of different fonts or colors or you know

550
00:18:53,850 --> 00:18:57,629
different pieces embedding different

551
00:18:55,769 --> 00:18:59,369
content inside a complex file format

552
00:18:57,629 --> 00:19:01,649
whatever it may be use those as your

553
00:18:59,369 --> 00:19:04,559
starting seeds and then you basically

554
00:19:01,649 --> 00:19:05,820
test for coverage create new inputs run

555
00:19:04,559 --> 00:19:07,350
it through your constraint solver or

556
00:19:05,820 --> 00:19:08,850
your genetic algorithm create a new

557
00:19:07,350 --> 00:19:10,980
generation of inputs and then run that

558
00:19:08,850 --> 00:19:13,469
back through the test engine as well to

559
00:19:10,980 --> 00:19:14,429
look for further buds so that's the idea

560
00:19:13,470 --> 00:19:15,659
of what we're talking about and there

561
00:19:14,429 --> 00:19:17,070
are a lot of other tools that I won't

562
00:19:15,659 --> 00:19:18,210
mention so I can't mention every tool in

563
00:19:17,070 --> 00:19:20,460
the fuzzing field there's a lot of other

564
00:19:18,210 --> 00:19:22,440
tools that leverage AFL in particular

565
00:19:20,460 --> 00:19:24,330
and the reason for that is Google's

566
00:19:22,440 --> 00:19:26,609
fuzzing tool AFL is open source and free

567
00:19:24,330 --> 00:19:27,899
so it's the only next-generation tool

568
00:19:26,609 --> 00:19:30,119
that's out there that's free everything

569
00:19:27,899 --> 00:19:32,580
else is commercial so you'll find tools

570
00:19:30,119 --> 00:19:34,340
like Google's clustered buzz or buzz

571
00:19:32,580 --> 00:19:36,389
buzz or fuzz that there's some other

572
00:19:34,340 --> 00:19:38,009
startup companies and commercial tools

573
00:19:36,389 --> 00:19:40,949
that are leveraging AFL under the hood

574
00:19:38,009 --> 00:19:43,470
to bring that to a more commercial

575
00:19:40,950 --> 00:19:46,109
market that needs a little bit more help

576
00:19:43,470 --> 00:19:47,759
and the reason for that is security work

577
00:19:46,109 --> 00:19:49,769
in general is a pretty technical field

578
00:19:47,759 --> 00:19:50,940
that we work in right you guys all know

579
00:19:49,769 --> 00:19:53,999
that right everything we do in this

580
00:19:50,940 --> 00:19:55,799
field is sort of confusing essentially

581
00:19:53,999 --> 00:19:57,509
to somebody who's not you know heavily

582
00:19:55,799 --> 00:19:58,769
indoctrinated into the field in which we

583
00:19:57,509 --> 00:20:01,180
work and that's true of course in

584
00:19:58,769 --> 00:20:03,040
software testing as well

585
00:20:01,180 --> 00:20:04,810
so if you're not a fuzzing expert you

586
00:20:03,040 --> 00:20:06,490
know using a command-line utility and

587
00:20:04,810 --> 00:20:07,990
setting up the environment even getting

588
00:20:06,490 --> 00:20:09,280
all the right Linux utilities or

589
00:20:07,990 --> 00:20:11,080
whatever it might be in place to even

590
00:20:09,280 --> 00:20:13,570
set up the tool to use it could be

591
00:20:11,080 --> 00:20:15,760
difficult so like the free tool AFL

592
00:20:13,570 --> 00:20:16,960
basically is sort of not it's not I

593
00:20:15,760 --> 00:20:19,060
wouldn't say it's hard to use but it's

594
00:20:16,960 --> 00:20:21,130
not super it's not a SAS tool let's say

595
00:20:19,060 --> 00:20:22,330
that in terms of easy use where so a lot

596
00:20:21,130 --> 00:20:23,890
of these commercial tools they're coming

597
00:20:22,330 --> 00:20:25,600
to bear they're want to make it more SAS

598
00:20:23,890 --> 00:20:27,580
like so you can O go to a website you

599
00:20:25,600 --> 00:20:29,500
point you click you drag your app you're

600
00:20:27,580 --> 00:20:31,179
fuzzing sort of thing that's the idea

601
00:20:29,500 --> 00:20:32,920
it's not quite there I would say that's

602
00:20:31,180 --> 00:20:35,350
not still not a reality of how you use

603
00:20:32,920 --> 00:20:37,330
those tools but that's sort of what's

604
00:20:35,350 --> 00:20:38,500
driving it now these tools again like I

605
00:20:37,330 --> 00:20:39,850
said they're not perfect they have

606
00:20:38,500 --> 00:20:42,520
limitations as well there could be

607
00:20:39,850 --> 00:20:45,219
difficulties in the path explosion or

608
00:20:42,520 --> 00:20:46,720
non-deterministic nature of the program

609
00:20:45,220 --> 00:20:48,760
which might make constraint solving

610
00:20:46,720 --> 00:20:50,740
difficult so like if you put in this

611
00:20:48,760 --> 00:20:51,910
input you got on this path you put in

612
00:20:50,740 --> 00:20:52,870
the exact same input you go down a

613
00:20:51,910 --> 00:20:54,130
different path that's hard for

614
00:20:52,870 --> 00:20:55,689
constraint solvers right because now all

615
00:20:54,130 --> 00:20:57,910
of a sudden the same input generated two

616
00:20:55,690 --> 00:20:59,200
different paths it's not able to just

617
00:20:57,910 --> 00:21:01,210
solve a constraint based on that if your

618
00:20:59,200 --> 00:21:02,530
code is weird in some way there's things

619
00:21:01,210 --> 00:21:03,820
like that or if the constraints are

620
00:21:02,530 --> 00:21:05,230
cryptographically be hard for the

621
00:21:03,820 --> 00:21:07,300
algorithm to solve that would be really

622
00:21:05,230 --> 00:21:09,070
hard for for it to get past a point like

623
00:21:07,300 --> 00:21:10,990
that but that's not really what limits

624
00:21:09,070 --> 00:21:13,330
fuzzing it's not so much the limitations

625
00:21:10,990 --> 00:21:15,730
of the algorithms or the tools or the

626
00:21:13,330 --> 00:21:17,310
cost a lot of what really limits fuzzing

627
00:21:15,730 --> 00:21:19,990
is the fact that it's simply not used

628
00:21:17,310 --> 00:21:21,790
and there you know a lot of companies

629
00:21:19,990 --> 00:21:23,680
are pretty good about using static

630
00:21:21,790 --> 00:21:25,270
analysis tools even though they do

631
00:21:23,680 --> 00:21:27,070
generate false positives and things like

632
00:21:25,270 --> 00:21:29,020
that but it's easier to deploy so you

633
00:21:27,070 --> 00:21:30,669
can every time developers write code

634
00:21:29,020 --> 00:21:32,379
they check it in you have it you know

635
00:21:30,670 --> 00:21:34,090
checked by some sort of static analysis

636
00:21:32,380 --> 00:21:35,860
engine that's great and you if you don't

637
00:21:34,090 --> 00:21:37,419
do that you should but what they're not

638
00:21:35,860 --> 00:21:39,250
usually as good about doing is

639
00:21:37,420 --> 00:21:41,290
integrating a fuzzing tool or dynamic

640
00:21:39,250 --> 00:21:43,090
testing into the CI CD the continuous

641
00:21:41,290 --> 00:21:45,190
integration continuous delivery nature

642
00:21:43,090 --> 00:21:47,290
of the DevOps world in which we now live

643
00:21:45,190 --> 00:21:49,900
so most code is being continuously

644
00:21:47,290 --> 00:21:52,090
changed continuously fielded and that's

645
00:21:49,900 --> 00:21:54,100
the kind of code we have to work with so

646
00:21:52,090 --> 00:21:56,560
I know for like Microsoft for example

647
00:21:54,100 --> 00:21:58,179
there Azure DevOps does allow an MS RD

648
00:21:56,560 --> 00:21:59,830
extension which you know basically

649
00:21:58,180 --> 00:22:02,170
allows you to integrate their fuzzing

650
00:21:59,830 --> 00:22:03,669
tool into a devops project environment

651
00:22:02,170 --> 00:22:05,410
so that's good so we're definitely

652
00:22:03,670 --> 00:22:06,760
seeing progress there now we just have

653
00:22:05,410 --> 00:22:08,410
to convince people that they should do

654
00:22:06,760 --> 00:22:11,080
this that they should use this that

655
00:22:08,410 --> 00:22:12,280
there's value and fuzz testing and it's

656
00:22:11,080 --> 00:22:13,720
something that they need and then

657
00:22:12,280 --> 00:22:14,190
doesn't make sense for every project I

658
00:22:13,720 --> 00:22:15,389
don't

659
00:22:14,190 --> 00:22:17,009
take that from this talk it's not

660
00:22:15,389 --> 00:22:18,508
appropriate for every type of code and

661
00:22:17,009 --> 00:22:20,970
every type of project but it is

662
00:22:18,509 --> 00:22:22,559
appropriate for many certain types so

663
00:22:20,970 --> 00:22:24,210
you kind of need to understand what's

664
00:22:22,559 --> 00:22:25,889
the dynamic testing that's appropriate

665
00:22:24,210 --> 00:22:27,600
for my project so ask yourself that and

666
00:22:25,889 --> 00:22:28,799
then you can figure out if next-gen

667
00:22:27,600 --> 00:22:31,139
fuzzing tools are something you might

668
00:22:28,799 --> 00:22:33,029
want to look at okay so that's all the

669
00:22:31,139 --> 00:22:34,439
background without further ado basically

670
00:22:33,029 --> 00:22:36,750
then Microsoft security risk detection

671
00:22:34,440 --> 00:22:38,610
is where you'll find MSR D and for all

672
00:22:36,750 --> 00:22:40,230
secure comm is where you'll find more

673
00:22:38,610 --> 00:22:42,750
information about mayhem the other tool

674
00:22:40,230 --> 00:22:44,519
they're both scalable cloud-based easy

675
00:22:42,750 --> 00:22:46,889
to set up easy to integrate basically

676
00:22:44,519 --> 00:22:48,779
what they provide is a virtual machines

677
00:22:46,889 --> 00:22:50,969
that you upload your application to with

678
00:22:48,779 --> 00:22:53,399
your seed files and you you know do some

679
00:22:50,970 --> 00:22:56,309
other basic setup type stuff to get the

680
00:22:53,399 --> 00:22:59,158
fuzzing going the triaging is quite in

681
00:22:56,309 --> 00:23:00,570
quite intuitive if you're again but only

682
00:22:59,159 --> 00:23:02,159
if you have sort of a deep developer

683
00:23:00,570 --> 00:23:03,809
background so intuitive is sort of like

684
00:23:02,159 --> 00:23:06,269
you know your mouth mileage may vary on

685
00:23:03,809 --> 00:23:08,340
that term right it's intuitive to you

686
00:23:06,269 --> 00:23:10,710
know if you understand what a segfault

687
00:23:08,340 --> 00:23:12,899
and signal 11and in linux means and

688
00:23:10,710 --> 00:23:14,220
stuff like that so maybe may not be

689
00:23:12,899 --> 00:23:15,629
intuitive to everybody but basically you

690
00:23:14,220 --> 00:23:17,009
can click on a bug that it finds and

691
00:23:15,629 --> 00:23:18,658
it'll show you like a stack trace in a

692
00:23:17,009 --> 00:23:20,759
call stack of what the you know what

693
00:23:18,659 --> 00:23:22,769
went wrong so that you can debug the

694
00:23:20,759 --> 00:23:24,299
issue and work with it from there so

695
00:23:22,769 --> 00:23:25,919
these these are basically O'Dea machines

696
00:23:24,299 --> 00:23:28,620
we found a lot of a vulnerabilities by

697
00:23:25,919 --> 00:23:29,970
running products and and things through

698
00:23:28,620 --> 00:23:32,039
these tools so that's very interesting

699
00:23:29,970 --> 00:23:33,210
and we've of course been responsible in

700
00:23:32,039 --> 00:23:35,879
the way that we've disclosed those to

701
00:23:33,210 --> 00:23:37,320
vendors so here's a look at MSR d I

702
00:23:35,879 --> 00:23:39,600
don't know if you can see that from

703
00:23:37,320 --> 00:23:41,009
where you're sitting but basically once

704
00:23:39,600 --> 00:23:42,299
you've got it and these are actual like

705
00:23:41,009 --> 00:23:43,740
the vulnerabilities that you'll see

706
00:23:42,299 --> 00:23:45,000
these are actual products and actual

707
00:23:43,740 --> 00:23:47,100
vulnerabilities and stuff like that

708
00:23:45,000 --> 00:23:50,460
you'll see that we're fuzzing you know

709
00:23:47,100 --> 00:23:51,928
this JPEG reader or this you know PDF

710
00:23:50,460 --> 00:23:54,090
view or whatever we did we did a whole

711
00:23:51,929 --> 00:23:55,110
bunch of different ones and well it's

712
00:23:54,090 --> 00:23:56,789
fuzzing you're seeing that it's finding

713
00:23:55,110 --> 00:23:58,758
ten results or however many results and

714
00:23:56,789 --> 00:24:01,049
you can click on that and when you do

715
00:23:58,759 --> 00:24:02,669
it'll tell you more information about

716
00:24:01,049 --> 00:24:05,970
the type of vulnerability like it found

717
00:24:02,669 --> 00:24:09,389
a stack buffer overflow crash this is

718
00:24:05,970 --> 00:24:11,039
this is mmm interesting thing about MS

719
00:24:09,389 --> 00:24:12,658
RD is it allows you to fuzz on either

720
00:24:11,039 --> 00:24:14,340
Windows or Linux which is kind of wild

721
00:24:12,659 --> 00:24:15,480
because this Microsoft we're talking

722
00:24:14,340 --> 00:24:17,250
about right so the fact that they let

723
00:24:15,480 --> 00:24:18,929
you fuzz on a Linux VM is kind of

724
00:24:17,250 --> 00:24:20,610
interesting and kind of cool

725
00:24:18,929 --> 00:24:21,509
really there you traditionally you

726
00:24:20,610 --> 00:24:24,750
wouldn't think that they would provide

727
00:24:21,509 --> 00:24:26,399
that but they do so and this this

728
00:24:24,750 --> 00:24:27,750
vulnerability is interesting too in the

729
00:24:26,399 --> 00:24:30,090
sense that this is a it's just

730
00:24:27,750 --> 00:24:32,850
common Linux utility that's you know in

731
00:24:30,090 --> 00:24:34,230
any normal Linux build like a Debian you

732
00:24:32,850 --> 00:24:36,389
know release or something like that it's

733
00:24:34,230 --> 00:24:38,280
called ISO info it's just a command-line

734
00:24:36,390 --> 00:24:40,799
utility that allows you to parse ISO

735
00:24:38,280 --> 00:24:42,120
files and it's well tested code it's

736
00:24:40,799 --> 00:24:43,559
code like I said it's been around 30

737
00:24:42,120 --> 00:24:44,969
years you wouldn't think that if we

738
00:24:43,559 --> 00:24:46,678
throw it in some fuzzing tool we'd be

739
00:24:44,970 --> 00:24:48,630
likely to find zero-day vulnerabilities

740
00:24:46,679 --> 00:24:50,100
in like 20 minutes but in fact that's

741
00:24:48,630 --> 00:24:51,419
exactly what we did this is that these

742
00:24:50,100 --> 00:24:54,059
are actual zero-day vulnerabilities that

743
00:24:51,419 --> 00:24:55,890
we found very rapidly and we spent a

744
00:24:54,059 --> 00:24:57,720
little time triaging them the crashes

745
00:24:55,890 --> 00:24:58,980
and reversing and debugging and exploit

746
00:24:57,720 --> 00:25:00,690
development and that kind of stuff and

747
00:24:58,980 --> 00:25:02,340
this is not really a talk on that but if

748
00:25:00,690 --> 00:25:04,080
you're interested in that we do cover

749
00:25:02,340 --> 00:25:06,959
that in our AB set course as well how to

750
00:25:04,080 --> 00:25:08,699
use tools like Deidre and Ida Pro and

751
00:25:06,960 --> 00:25:10,470
and wind a bug and all this sort of

752
00:25:08,700 --> 00:25:12,450
reversing and debugging tools that you

753
00:25:10,470 --> 00:25:14,610
would need to basically figure out what

754
00:25:12,450 --> 00:25:15,960
the assembly or the pseudo C code is

755
00:25:14,610 --> 00:25:18,479
doing this the actual location of the

756
00:25:15,960 --> 00:25:22,770
vulnerability and that ISO info program

757
00:25:18,480 --> 00:25:25,049
so pretty cool stuff so what I want to

758
00:25:22,770 --> 00:25:26,668
do now is just give a demonstration and

759
00:25:25,049 --> 00:25:28,139
show you kind of more of the interface

760
00:25:26,669 --> 00:25:30,570
kind of walking through setting up a

761
00:25:28,140 --> 00:25:32,640
fuzz job what that looks like how that

762
00:25:30,570 --> 00:25:36,389
works when we run it and stuff so let me

763
00:25:32,640 --> 00:25:40,590
go ahead and play a video here if you

764
00:25:36,390 --> 00:25:44,429
can all see that well or not but it's

765
00:25:40,590 --> 00:25:45,870
going to be showing first starting a job

766
00:25:44,429 --> 00:25:48,570
so basically what we do is we

767
00:25:45,870 --> 00:25:50,760
instantiate a virtual machine so in ms

768
00:25:48,570 --> 00:25:52,740
rd it allows you to pick like Windows

769
00:25:50,760 --> 00:25:55,470
Server or Linux different versions of

770
00:25:52,740 --> 00:25:58,260
Windows things like that and what we'll

771
00:25:55,470 --> 00:25:59,970
be shooting for obviously at the end is

772
00:25:58,260 --> 00:26:01,950
a series of results like we showed just

773
00:25:59,970 --> 00:26:05,730
a second ago and so then what you need

774
00:26:01,950 --> 00:26:07,530
to continue configuring your fuzz job

775
00:26:05,730 --> 00:26:09,990
setup is you remote into the machine and

776
00:26:07,530 --> 00:26:11,850
then from there you do a preparation

777
00:26:09,990 --> 00:26:13,830
phase where you basically upload a

778
00:26:11,850 --> 00:26:14,969
packet or the binary the application you

779
00:26:13,830 --> 00:26:18,240
have to installed in the virtual machine

780
00:26:14,970 --> 00:26:19,980
and then you install the sample file is

781
00:26:18,240 --> 00:26:21,600
called the seeds as well and again

782
00:26:19,980 --> 00:26:23,130
that's important to choose good seeds

783
00:26:21,600 --> 00:26:25,980
that get good coverage across your

784
00:26:23,130 --> 00:26:30,600
application this is just a picture of me

785
00:26:25,980 --> 00:26:32,940
remoting in Stowe here and so this is

786
00:26:30,600 --> 00:26:35,399
just still app set up stuff and it's not

787
00:26:32,940 --> 00:26:38,909
too complex you click through a series

788
00:26:35,400 --> 00:26:40,980
of graphical menus so it's even if

789
00:26:38,909 --> 00:26:41,580
you're not a huge application developer

790
00:26:40,980 --> 00:26:43,649
type

791
00:26:41,580 --> 00:26:45,029
it's pretty intuitive how - this is -

792
00:26:43,649 --> 00:26:46,879
viewer I think is what I'm setting up

793
00:26:45,029 --> 00:26:49,499
here

794
00:26:46,879 --> 00:26:51,719
yep and then setting the directory where

795
00:26:49,499 --> 00:26:53,700
you keep your input files and then once

796
00:26:51,720 --> 00:26:57,029
you get all that set up you choose a few

797
00:26:53,700 --> 00:26:59,399
further configurations options based on

798
00:26:57,029 --> 00:27:01,139
whether or not the process can run in

799
00:26:59,399 --> 00:27:03,299
multiple instances under the same name

800
00:27:01,139 --> 00:27:05,279
and things like that I won't go through

801
00:27:03,299 --> 00:27:06,869
all the details of every little setup

802
00:27:05,279 --> 00:27:08,070
because there's not that many and I

803
00:27:06,869 --> 00:27:09,629
don't want to spend too much time on it

804
00:27:08,070 --> 00:27:10,739
it's more just sort of a picture of the

805
00:27:09,629 --> 00:27:12,600
tools in general and then it goes

806
00:27:10,739 --> 00:27:13,919
through a validation phase to make sure

807
00:27:12,600 --> 00:27:15,570
that it can start and stop the

808
00:27:13,919 --> 00:27:17,580
application without it crashing at the

809
00:27:15,570 --> 00:27:20,730
first seed will open up an image in this

810
00:27:17,580 --> 00:27:22,168
case without the application crashing

811
00:27:20,730 --> 00:27:24,450
which it does okay so then eventually

812
00:27:22,169 --> 00:27:27,539
it'll validate once it validates you can

813
00:27:24,450 --> 00:27:31,309
click run from the main sass menu and

814
00:27:27,539 --> 00:27:33,149
it'll start fuzzing that application and

815
00:27:31,309 --> 00:27:34,350
hopefully you'll find lots of

816
00:27:33,149 --> 00:27:36,418
vulnerabilities and the idea is that

817
00:27:34,350 --> 00:27:38,340
you're doing this in a repeatable

818
00:27:36,419 --> 00:27:40,710
fashion across your project these tools

819
00:27:38,340 --> 00:27:42,209
are both meant more for developers than

820
00:27:40,710 --> 00:27:44,700
they are for hackers or security

821
00:27:42,210 --> 00:27:46,049
researchers or you know pen testers or

822
00:27:44,700 --> 00:27:48,600
anything like that they're more meant to

823
00:27:46,049 --> 00:27:50,549
be integrated in an ongoing fashion in

824
00:27:48,600 --> 00:27:53,519
your project such that you can increase

825
00:27:50,549 --> 00:27:56,369
the code quality of your projects over

826
00:27:53,519 --> 00:27:58,289
time and you can also you know do

827
00:27:56,369 --> 00:28:00,418
regression testing so some of the a lot

828
00:27:58,289 --> 00:28:02,399
of these types of tools will allow you

829
00:28:00,419 --> 00:28:06,919
to if it found a vulnerability in the

830
00:28:02,399 --> 00:28:06,918
past remember that and do that specific

831
00:28:09,940 --> 00:28:12,000
you

832
00:28:12,950 --> 00:28:17,480
put again when you upload a new binary

833
00:28:15,080 --> 00:28:18,860
as a regression test I know that's

834
00:28:17,480 --> 00:28:21,289
that's definitely something that's a

835
00:28:18,860 --> 00:28:25,840
focus for some of these next-gen SAS

836
00:28:21,289 --> 00:28:28,340
tools okay so anyway we got the

837
00:28:25,840 --> 00:28:31,879
application set up we let it run for a

838
00:28:28,340 --> 00:28:33,320
while basically you know maybe a week it

839
00:28:31,880 --> 00:28:34,850
doesn't doesn't have to run that long

840
00:28:33,320 --> 00:28:36,580
typically to find some pretty good

841
00:28:34,850 --> 00:28:38,240
vulnerabilities and you can click on

842
00:28:36,580 --> 00:28:39,649
these are some of the actual

843
00:28:38,240 --> 00:28:41,570
vulnerabilities you found read access

844
00:28:39,649 --> 00:28:42,529
violations write access violations and

845
00:28:41,570 --> 00:28:44,840
native code those are serious

846
00:28:42,529 --> 00:28:47,240
vulnerabilities indicative of memory

847
00:28:44,840 --> 00:28:48,649
corruption and then you have this is the

848
00:28:47,240 --> 00:28:51,049
triaging which is quote unquote

849
00:28:48,649 --> 00:28:52,879
easy triaging which means that if you

850
00:28:51,049 --> 00:28:54,559
spend a lot of your life in wind a bug

851
00:28:52,880 --> 00:28:56,389
and things like that you'll understand

852
00:28:54,559 --> 00:28:57,379
somewhat what this means but it's it's

853
00:28:56,389 --> 00:29:00,139
just showing you the state of the

854
00:28:57,380 --> 00:29:02,330
registers the call stack the fact that

855
00:29:00,139 --> 00:29:03,649
you got a c0 0 0 5 which is an access

856
00:29:02,330 --> 00:29:06,019
violation that's the same thing as a

857
00:29:03,649 --> 00:29:07,610
signal 11 on linux which basically means

858
00:29:06,019 --> 00:29:10,070
that we access memory that's either not

859
00:29:07,610 --> 00:29:12,889
mapped or are unreadable or unraidable

860
00:29:10,070 --> 00:29:14,269
in some way and typically means that you

861
00:29:12,889 --> 00:29:16,459
have the beginning of a proof-of-concept

862
00:29:14,269 --> 00:29:18,830
boner abilities so with this crash if

863
00:29:16,460 --> 00:29:20,600
you've got the right tools skills that

864
00:29:18,830 --> 00:29:23,960
are interest you could probably possibly

865
00:29:20,600 --> 00:29:25,219
turn that into an actual exploitable you

866
00:29:23,960 --> 00:29:26,929
know exploit a vulnerability type

867
00:29:25,220 --> 00:29:29,570
situation that you could use on a pen

868
00:29:26,929 --> 00:29:31,309
tester or whatever many cases that

869
00:29:29,570 --> 00:29:32,928
wouldn't be really necessary if this is

870
00:29:31,309 --> 00:29:34,820
integrated with the developers it's more

871
00:29:32,929 --> 00:29:35,899
take these findings to the developers

872
00:29:34,820 --> 00:29:37,668
and say hey it looks like we have a

873
00:29:35,899 --> 00:29:39,408
crash on this function who's in charge

874
00:29:37,669 --> 00:29:41,029
of this function that's this developer

875
00:29:39,409 --> 00:29:43,490
over here they should be the ones to

876
00:29:41,029 --> 00:29:46,190
repair that code because you know we

877
00:29:43,490 --> 00:29:48,230
don't want to you know have our security

878
00:29:46,190 --> 00:29:49,700
teams been three weeks writing a

879
00:29:48,230 --> 00:29:51,019
vulnerability when really what we want

880
00:29:49,700 --> 00:29:52,639
to do is have the developers fix the

881
00:29:51,019 --> 00:29:54,620
code so you know whether or not a

882
00:29:52,639 --> 00:29:55,969
proof-of-concept exploit is necessary

883
00:29:54,620 --> 00:29:58,070
kind of depends on the culture of your

884
00:29:55,970 --> 00:29:59,630
organization some are really big on that

885
00:29:58,070 --> 00:30:01,580
they really want to see the impact and

886
00:29:59,630 --> 00:30:03,950
see that you can do that other places

887
00:30:01,580 --> 00:30:05,120
you know would say no we don't need you

888
00:30:03,950 --> 00:30:07,220
spending all your day and this is a

889
00:30:05,120 --> 00:30:08,809
picture of window bug here which is

890
00:30:07,220 --> 00:30:10,639
where you would do a lot of that sort of

891
00:30:08,809 --> 00:30:12,799
exploit development just debugging the

892
00:30:10,639 --> 00:30:16,459
crash and figuring out ok what part of

893
00:30:12,799 --> 00:30:19,309
memory was corrupted what where in our

894
00:30:16,460 --> 00:30:21,440
input caused that corruption it's a lot

895
00:30:19,309 --> 00:30:23,149
of sort of tracing back through this was

896
00:30:21,440 --> 00:30:24,860
the original input this is the mutated

897
00:30:23,149 --> 00:30:26,300
input what did we change understanding

898
00:30:24,860 --> 00:30:27,679
that field structure that

899
00:30:26,300 --> 00:30:30,440
understanding why does that actually

900
00:30:27,680 --> 00:30:31,850
make this application crash typically

901
00:30:30,440 --> 00:30:33,500
figuring out like it's some assembly

902
00:30:31,850 --> 00:30:36,949
instruction like if it looks like okay

903
00:30:33,500 --> 00:30:40,340
it's crashing because ESI is being be

904
00:30:36,950 --> 00:30:42,170
referenced or what si si si some value

905
00:30:40,340 --> 00:30:43,550
like one which is not it doesn't look

906
00:30:42,170 --> 00:30:44,990
like a valid memory address how did it

907
00:30:43,550 --> 00:30:46,909
become one something got screwed up in

908
00:30:44,990 --> 00:30:48,380
the program such that it tried to write

909
00:30:46,910 --> 00:30:51,170
to an address that doesn't exist so

910
00:30:48,380 --> 00:30:53,720
anyway that's the kind of overview of

911
00:30:51,170 --> 00:30:54,980
how to use MS RD in in terms of a

912
00:30:53,720 --> 00:30:56,570
summary results these are some of the

913
00:30:54,980 --> 00:30:58,940
applications that we decided to test

914
00:30:56,570 --> 00:31:01,730
Foxit PDF reader Wednesday plain wire

915
00:30:58,940 --> 00:31:06,350
Chrome Firefox Open Office Libre Office

916
00:31:01,730 --> 00:31:08,690
office plug-in WPS - view X view Ison

917
00:31:06,350 --> 00:31:12,439
ISO info and other applications like

918
00:31:08,690 --> 00:31:13,310
that during that time we found a lot of

919
00:31:12,440 --> 00:31:15,080
different vulnerabilities about a

920
00:31:13,310 --> 00:31:17,480
thousand vulnerabilities are crashes

921
00:31:15,080 --> 00:31:19,669
anyway of different types right access

922
00:31:17,480 --> 00:31:24,110
read access violations Nell P reference

923
00:31:19,670 --> 00:31:28,220
heap stack corruptions / 0 floating

924
00:31:24,110 --> 00:31:30,500
issues exception handlers C++ mistakes

925
00:31:28,220 --> 00:31:32,120
all kinds of things many of those which

926
00:31:30,500 --> 00:31:34,310
we've kind of already showed you already

927
00:31:32,120 --> 00:31:35,449
again you you know you sort through your

928
00:31:34,310 --> 00:31:37,520
list figure out which ones are most

929
00:31:35,450 --> 00:31:38,960
severe a lot of that's based on

930
00:31:37,520 --> 00:31:40,400
knowledge in the field like write access

931
00:31:38,960 --> 00:31:42,050
violations tend to be more severe than

932
00:31:40,400 --> 00:31:46,040
read but that you know could go either

933
00:31:42,050 --> 00:31:48,379
way and so yeah that's that's basically

934
00:31:46,040 --> 00:31:49,790
the kind of the process and in many

935
00:31:48,380 --> 00:31:51,380
cases it didn't take us that long to

936
00:31:49,790 --> 00:31:53,960
find serious vulnerabilities like in the

937
00:31:51,380 --> 00:31:57,410
case of when we when we fuzz ISO info on

938
00:31:53,960 --> 00:32:00,200
Linux 25 minutes O'Day and I am you know

939
00:31:57,410 --> 00:32:02,000
well tested major application and so

940
00:32:00,200 --> 00:32:04,100
that's that's really important and again

941
00:32:02,000 --> 00:32:06,140
you know if you want more information on

942
00:32:04,100 --> 00:32:07,820
triaging how to understand which bugs

943
00:32:06,140 --> 00:32:09,590
are serious a critical you know that

944
00:32:07,820 --> 00:32:10,730
type of thing that's something that we

945
00:32:09,590 --> 00:32:11,959
could help you or think through and

946
00:32:10,730 --> 00:32:14,480
understand a little bit more but it's

947
00:32:11,960 --> 00:32:15,710
kind of a deep complex subject that not

948
00:32:14,480 --> 00:32:17,600
everybody would have interested unless

949
00:32:15,710 --> 00:32:21,500
you're really into that so some of the

950
00:32:17,600 --> 00:32:23,030
stats at least I named SRD when debug

951
00:32:21,500 --> 00:32:24,650
does use an extension called being

952
00:32:23,030 --> 00:32:26,450
exploitable which tries to take a guess

953
00:32:24,650 --> 00:32:28,880
at the exploitable nature of the crash

954
00:32:26,450 --> 00:32:30,590
so it'll look at things like what type

955
00:32:28,880 --> 00:32:33,050
of violation is it what are the state of

956
00:32:30,590 --> 00:32:34,490
this of the call stack you know that

957
00:32:33,050 --> 00:32:36,139
type of stuff and it'll try to guess is

958
00:32:34,490 --> 00:32:38,600
this crash look exploitable probably

959
00:32:36,140 --> 00:32:40,250
exploitable probably not unknown that

960
00:32:38,600 --> 00:32:42,919
type of thing so across 50

961
00:32:40,250 --> 00:32:44,390
locations we found without really doing

962
00:32:42,920 --> 00:32:46,130
a ton of testing this kind of in our

963
00:32:44,390 --> 00:32:47,900
spare time one of our engineers mostly

964
00:32:46,130 --> 00:32:51,500
was doing this and doing a great job

965
00:32:47,900 --> 00:32:53,150
found a thousand bugs so of that

966
00:32:51,500 --> 00:32:54,680
thousand crashes I would say probably at

967
00:32:53,150 --> 00:32:56,420
least a hundred of those are exploitable

968
00:32:54,680 --> 00:32:58,040
just from a rough guess based on some of

969
00:32:56,420 --> 00:32:59,300
the data that we have which that's

970
00:32:58,040 --> 00:33:01,220
pretty serious you know that's really

971
00:32:59,300 --> 00:33:02,330
interesting that's far superior to other

972
00:33:01,220 --> 00:33:04,430
tools that are out there if you take

973
00:33:02,330 --> 00:33:05,720
other open-source buzzers that you could

974
00:33:04,430 --> 00:33:07,670
download and run you would not get that

975
00:33:05,720 --> 00:33:09,290
kind of results against well tested

976
00:33:07,670 --> 00:33:10,910
applications so that's really the unique

977
00:33:09,290 --> 00:33:13,010
part of what I'm talking about today is

978
00:33:10,910 --> 00:33:15,020
that these new guided fuzzing algorithms

979
00:33:13,010 --> 00:33:17,420
really do make a difference they are

980
00:33:15,020 --> 00:33:18,860
superior to other types of mutation and

981
00:33:17,420 --> 00:33:21,290
generation fuzzing which is kind of

982
00:33:18,860 --> 00:33:23,149
interesting in terms of actually

983
00:33:21,290 --> 00:33:24,530
developing one of those bugs into a

984
00:33:23,150 --> 00:33:29,930
working exploit this is a picture of

985
00:33:24,530 --> 00:33:31,730
that this is the POC and basically all

986
00:33:29,930 --> 00:33:33,320
we do is run this with with a malicious

987
00:33:31,730 --> 00:33:35,540
input that we turn into an exploit and

988
00:33:33,320 --> 00:33:37,939
you'll see it pop calculator so it's

989
00:33:35,540 --> 00:33:40,460
kind of like maybe not that interesting

990
00:33:37,940 --> 00:33:42,020
other than proving that some of those

991
00:33:40,460 --> 00:33:44,960
crashes could actually be turned into

992
00:33:42,020 --> 00:33:46,100
zero day exploits which is you know if

993
00:33:44,960 --> 00:33:47,150
you've been following this field and

994
00:33:46,100 --> 00:33:49,490
know anything about that it's pretty

995
00:33:47,150 --> 00:33:52,370
serious and very interesting so that's a

996
00:33:49,490 --> 00:33:54,350
mess Rd the mayhem results we more

997
00:33:52,370 --> 00:33:58,939
recently got access to so we don't have

998
00:33:54,350 --> 00:34:00,620
as lengthy a list of results and mayhem

999
00:33:58,940 --> 00:34:02,690
as we do an MS RD just because we just

1000
00:34:00,620 --> 00:34:05,419
started playing with it's actually about

1001
00:34:02,690 --> 00:34:06,770
a week ago so you know our list is a

1002
00:34:05,420 --> 00:34:09,100
little shorter but basically what we're

1003
00:34:06,770 --> 00:34:12,290
finding is almost the exact same thing

1004
00:34:09,100 --> 00:34:14,418
so it's behavior testing like I said

1005
00:34:12,290 --> 00:34:17,179
from the CMU team that started a

1006
00:34:14,418 --> 00:34:18,679
business and they've been mostly focused

1007
00:34:17,179 --> 00:34:20,929
on Linux I don't think their platform

1008
00:34:18,679 --> 00:34:23,179
supports Windows yet for example so it's

1009
00:34:20,929 --> 00:34:25,820
probably not quite it doesn't have quite

1010
00:34:23,179 --> 00:34:27,230
as much support just yet but like MS RD

1011
00:34:25,820 --> 00:34:28,460
it doesn't require source code neither

1012
00:34:27,230 --> 00:34:29,600
one of them does which that's a huge

1013
00:34:28,460 --> 00:34:31,550
enhancement to a lot of the other

1014
00:34:29,600 --> 00:34:34,610
fuzzers do you require you to like

1015
00:34:31,550 --> 00:34:36,470
recompile the the binary with extra

1016
00:34:34,610 --> 00:34:38,480
instrumentation inserted so that it can

1017
00:34:36,469 --> 00:34:39,830
do the fuzzing the deeper guided

1018
00:34:38,480 --> 00:34:41,870
analysis stuff neither of these tools

1019
00:34:39,830 --> 00:34:44,090
require that which is really cool so you

1020
00:34:41,870 --> 00:34:45,739
can just do you know basically here's a

1021
00:34:44,090 --> 00:34:48,590
binary let's fuzz it with some inputs

1022
00:34:45,739 --> 00:34:50,509
type of thing and it's really cool and

1023
00:34:48,590 --> 00:34:52,790
so here's a picture of the SAS interface

1024
00:34:50,510 --> 00:34:53,210
from mayham and what's neat is you can

1025
00:34:52,790 --> 00:34:54,739
actually

1026
00:34:53,210 --> 00:34:56,179
see it making its generational

1027
00:34:54,739 --> 00:34:59,209
breakthrough so these aren't necessarily

1028
00:34:56,179 --> 00:35:01,010
the test runs these are more of the when

1029
00:34:59,210 --> 00:35:03,200
it actually found a new test case that

1030
00:35:01,010 --> 00:35:04,690
got a code coverage breakthrough so you

1031
00:35:03,200 --> 00:35:06,680
can kind of see it making these

1032
00:35:04,690 --> 00:35:08,720
evolutionary breakthroughs as the

1033
00:35:06,680 --> 00:35:09,950
fuzzers running it's covering more code

1034
00:35:08,720 --> 00:35:11,899
you can see a lot of times you will

1035
00:35:09,950 --> 00:35:13,520
notice these flat points to where you

1036
00:35:11,900 --> 00:35:15,500
know it's using trying to using fuzzing

1037
00:35:13,520 --> 00:35:16,640
heuristics and and but it's just flat

1038
00:35:15,500 --> 00:35:18,500
line right it hasn't made a breakthrough

1039
00:35:16,640 --> 00:35:20,540
until finally it finds a new input that

1040
00:35:18,500 --> 00:35:21,800
can cover new branches of code that

1041
00:35:20,540 --> 00:35:23,980
haven't been covered before and that's

1042
00:35:21,800 --> 00:35:26,869
kind of fun to watch that's kind of neat

1043
00:35:23,980 --> 00:35:29,150
and then of course the way that it

1044
00:35:26,869 --> 00:35:30,349
reports crashes it looks a little bit

1045
00:35:29,150 --> 00:35:32,119
different the interface is slightly

1046
00:35:30,349 --> 00:35:34,040
different I would say it's got a

1047
00:35:32,119 --> 00:35:36,970
slightly cleaner more modern sass

1048
00:35:34,040 --> 00:35:38,990
interface look to it compared to MS Rd

1049
00:35:36,970 --> 00:35:40,790
which is kind of cool I think that's

1050
00:35:38,990 --> 00:35:42,410
partly because this product is slightly

1051
00:35:40,790 --> 00:35:44,540
newer the team that's working on it's

1052
00:35:42,410 --> 00:35:47,149
very fresh it's a it's a startup venture

1053
00:35:44,540 --> 00:35:48,740
backed company so they're kind of you

1054
00:35:47,150 --> 00:35:50,930
know ready - ready to roll with this

1055
00:35:48,740 --> 00:35:54,379
product and when you click on any one of

1056
00:35:50,930 --> 00:35:56,839
these defects you'll see similar sort of

1057
00:35:54,380 --> 00:35:57,920
sorting by out of bounds read or out of

1058
00:35:56,839 --> 00:35:59,420
bounds right it's kind of cool they have

1059
00:35:57,920 --> 00:36:00,740
a little icon the outer boundaries like

1060
00:35:59,420 --> 00:36:01,970
broken glasses and the outer bounds

1061
00:36:00,740 --> 00:36:03,470
right is like some little bytes that

1062
00:36:01,970 --> 00:36:04,730
like went out of the out of the array

1063
00:36:03,470 --> 00:36:06,290
which is kind of fun so they've got

1064
00:36:04,730 --> 00:36:09,200
little icons that I think are cute if

1065
00:36:06,290 --> 00:36:10,310
you're into this whole thing unknown all

1066
00:36:09,200 --> 00:36:13,399
this kind of stuff and then you can

1067
00:36:10,310 --> 00:36:14,750
click on one of those outer bound reads

1068
00:36:13,400 --> 00:36:17,839
and this is the same thing so we thought

1069
00:36:14,750 --> 00:36:19,520
we went the same sort of Linux utilities

1070
00:36:17,839 --> 00:36:21,020
like ISO info through this and sound

1071
00:36:19,520 --> 00:36:23,540
that found the same vulnerability same

1072
00:36:21,020 --> 00:36:25,970
zero-day vulnerabilities and well tested

1073
00:36:23,540 --> 00:36:28,820
Linux applications very fast both these

1074
00:36:25,970 --> 00:36:31,910
tools are very good at finding new new

1075
00:36:28,820 --> 00:36:33,619
vulnerabilities in older native code

1076
00:36:31,910 --> 00:36:34,790
especially that's kind of its sweet spot

1077
00:36:33,619 --> 00:36:37,930
but other things as well

1078
00:36:34,790 --> 00:36:40,430
you can see the command that was run and

1079
00:36:37,930 --> 00:36:41,779
then as you click on it you can see the

1080
00:36:40,430 --> 00:36:43,640
type of fault which is a memory access

1081
00:36:41,780 --> 00:36:44,900
violation the falling address and then

1082
00:36:43,640 --> 00:36:46,279
there's a bunch of other data that you

1083
00:36:44,900 --> 00:36:48,560
can sort of scroll through in terms of

1084
00:36:46,280 --> 00:36:50,599
triage like the disassembly around the

1085
00:36:48,560 --> 00:36:55,190
crash point and that type of stuff so

1086
00:36:50,599 --> 00:36:58,400
quick video for this one as well this is

1087
00:36:55,190 --> 00:36:59,930
a video of very much like with sage what

1088
00:36:58,400 --> 00:37:03,109
I already showed showing the setup and

1089
00:36:59,930 --> 00:37:05,029
the use of the platform so in this case

1090
00:37:03,109 --> 00:37:06,619
it's a for now anyway it's a CLI

1091
00:37:05,030 --> 00:37:07,070
interface from Linux that's what they

1092
00:37:06,619 --> 00:37:08,810
require

1093
00:37:07,070 --> 00:37:10,790
the moment although they they do have a

1094
00:37:08,810 --> 00:37:12,920
1.1 this is the 1.0 version of their

1095
00:37:10,790 --> 00:37:14,870
product the 1.1 will allow you to do

1096
00:37:12,920 --> 00:37:17,210
everything through the SAS interface as

1097
00:37:14,870 --> 00:37:19,400
well to make it even more sort of user

1098
00:37:17,210 --> 00:37:22,340
friendly but basically you kind of

1099
00:37:19,400 --> 00:37:24,890
instantiate and install your product in

1100
00:37:22,340 --> 00:37:26,600
a package directory and then you run a

1101
00:37:24,890 --> 00:37:29,089
certain mayhem command

1102
00:37:26,600 --> 00:37:30,650
that'll upload your seed files in this

1103
00:37:29,090 --> 00:37:31,730
case that Ubuntu ISO files right because

1104
00:37:30,650 --> 00:37:33,920
that's what we're fuzzing we're fuzzing

1105
00:37:31,730 --> 00:37:35,660
this ISO info command so I souls are

1106
00:37:33,920 --> 00:37:37,850
what we have to give to it it's it

1107
00:37:35,660 --> 00:37:39,049
normally expects to parse ISO files so

1108
00:37:37,850 --> 00:37:40,850
if we're gonna find a vulnerability and

1109
00:37:39,050 --> 00:37:42,890
something that parses ISO files we need

1110
00:37:40,850 --> 00:37:44,150
sample iso files so it's just any

1111
00:37:42,890 --> 00:37:45,049
particular file form I could have been

1112
00:37:44,150 --> 00:37:46,430
any program though there's nothing

1113
00:37:45,050 --> 00:37:48,740
special about ISO don't get hung up on

1114
00:37:46,430 --> 00:37:50,779
that and then this is the configuration

1115
00:37:48,740 --> 00:37:53,689
file showing some various parameters

1116
00:37:50,780 --> 00:37:56,000
associated with the Mayhem fuzzing job

1117
00:37:53,690 --> 00:37:57,140
there's nothing sort of extra special in

1118
00:37:56,000 --> 00:37:58,820
this other than it's just showing you

1119
00:37:57,140 --> 00:38:00,319
how you have to set up the command it's

1120
00:37:58,820 --> 00:38:01,790
very AFL like because that's what it's

1121
00:38:00,320 --> 00:38:04,430
leveraging under the hood in terms of

1122
00:38:01,790 --> 00:38:08,660
its fuzzing engine it pairs that again

1123
00:38:04,430 --> 00:38:10,100
with a symbolic execution engine and

1124
00:38:08,660 --> 00:38:12,520
then this is some of the man page

1125
00:38:10,100 --> 00:38:16,160
information also that you can find

1126
00:38:12,520 --> 00:38:17,360
related to this if you wonder what some

1127
00:38:16,160 --> 00:38:18,560
of the switches that we're running it

1128
00:38:17,360 --> 00:38:20,690
with although I think it's not really

1129
00:38:18,560 --> 00:38:22,490
that important for this part of the talk

1130
00:38:20,690 --> 00:38:24,560
to understand that the point is that

1131
00:38:22,490 --> 00:38:26,209
we're submitting there fuzz job and then

1132
00:38:24,560 --> 00:38:28,490
we'll wait a little bit and within some

1133
00:38:26,210 --> 00:38:29,620
very short period of time we'll find the

1134
00:38:28,490 --> 00:38:31,490
vulnerabilities that I already

1135
00:38:29,620 --> 00:38:32,900
demonstrated for you and you can then go

1136
00:38:31,490 --> 00:38:34,580
through that sass interface and you can

1137
00:38:32,900 --> 00:38:36,680
click through and start triage in

1138
00:38:34,580 --> 00:38:38,270
individual bugs and find out hey what's

1139
00:38:36,680 --> 00:38:40,609
the priority we need to get the

1140
00:38:38,270 --> 00:38:41,840
developers in here fast we need to you

1141
00:38:40,610 --> 00:38:43,310
know whatever whatever your mission is

1142
00:38:41,840 --> 00:38:44,480
whether you have more of a defense or

1143
00:38:43,310 --> 00:38:46,310
offense emission then you figure out

1144
00:38:44,480 --> 00:38:49,960
what you want to do with the with the

1145
00:38:46,310 --> 00:38:52,730
results but this is just the may M tool

1146
00:38:49,960 --> 00:38:54,590
doing its thing packaging up what you're

1147
00:38:52,730 --> 00:38:58,070
gonna fuzz and sending it to the cloud

1148
00:38:54,590 --> 00:38:59,810
service which is where the action

1149
00:38:58,070 --> 00:39:03,290
happens and they've been kind enough to

1150
00:38:59,810 --> 00:39:04,580
give us quite some number of cores on

1151
00:39:03,290 --> 00:39:09,230
their range to do this kind of research

1152
00:39:04,580 --> 00:39:10,819
which is really fun so we do have kind

1153
00:39:09,230 --> 00:39:12,880
of a unique ability to find O'Day's

1154
00:39:10,820 --> 00:39:17,570
because of that the power and of the

1155
00:39:12,880 --> 00:39:20,930
cloud mixed with the fuzzing algorithms

1156
00:39:17,570 --> 00:39:22,610
is is what we're leveraging essentially

1157
00:39:20,930 --> 00:39:23,899
and again this is just kind of showing

1158
00:39:22,610 --> 00:39:25,550
the same stuff I already showed you

1159
00:39:23,900 --> 00:39:26,960
through slides but showing it kind of in

1160
00:39:25,550 --> 00:39:29,450
real time as we click through the

1161
00:39:26,960 --> 00:39:32,540
results and go into these individual

1162
00:39:29,450 --> 00:39:35,899
bugs to show what was found what it

1163
00:39:32,540 --> 00:39:36,860
looks like that kind of stuff so very

1164
00:39:35,900 --> 00:39:38,960
interesting stuff hopefully you guys

1165
00:39:36,860 --> 00:39:40,160
have some passing interest in fuzzing I

1166
00:39:38,960 --> 00:39:41,630
know it's kind of a it's sort of a weird

1167
00:39:40,160 --> 00:39:43,759
topic sort of a deep topic it's not a

1168
00:39:41,630 --> 00:39:46,130
very surfacy topic like malware

1169
00:39:43,760 --> 00:39:48,860
campaigns it's very different relative

1170
00:39:46,130 --> 00:39:50,900
to other IT security topics I think

1171
00:39:48,860 --> 00:39:53,840
fuzzing is sort of a sort of a niche

1172
00:39:50,900 --> 00:39:56,180
developer testing security kind of owed

1173
00:39:53,840 --> 00:39:57,380
a-hunting kind of topic but I've always

1174
00:39:56,180 --> 00:39:59,240
found really interesting I've always had

1175
00:39:57,380 --> 00:40:01,340
a you know a deep interest in this kind

1176
00:39:59,240 --> 00:40:02,569
of security so hopefully this talk at

1177
00:40:01,340 --> 00:40:04,460
least piques your interest in it if

1178
00:40:02,570 --> 00:40:06,530
you're not necessarily planning on

1179
00:40:04,460 --> 00:40:08,720
spending you know significant parts of

1180
00:40:06,530 --> 00:40:09,470
your career focused on this you can kind

1181
00:40:08,720 --> 00:40:10,669
of see whether one interesting thing

1182
00:40:09,470 --> 00:40:11,870
about mayhem two is it does actually

1183
00:40:10,670 --> 00:40:13,340
give you some other information about

1184
00:40:11,870 --> 00:40:14,810
the binary to some of the security

1185
00:40:13,340 --> 00:40:16,700
attributes like whether it used stack

1186
00:40:14,810 --> 00:40:18,410
cookies or that's kind of interesting so

1187
00:40:16,700 --> 00:40:20,180
it's doing some uh now some really

1188
00:40:18,410 --> 00:40:21,589
basically some static analysis as well

1189
00:40:20,180 --> 00:40:23,359
when you upload it before it starts its

1190
00:40:21,590 --> 00:40:24,800
dynamic analysis which was kind of

1191
00:40:23,360 --> 00:40:27,680
interesting and something that's not

1192
00:40:24,800 --> 00:40:29,000
necessarily a fuzzing related activity I

1193
00:40:27,680 --> 00:40:31,100
think you'll see more of that basically

1194
00:40:29,000 --> 00:40:32,480
over time consumers demand more from

1195
00:40:31,100 --> 00:40:33,770
their tools or like hey we've got this

1196
00:40:32,480 --> 00:40:35,090
tool that's supposed to be checking the

1197
00:40:33,770 --> 00:40:37,070
security I don't want it to just do the

1198
00:40:35,090 --> 00:40:39,110
fuzzing I wanted to maybe look at the

1199
00:40:37,070 --> 00:40:40,190
you know does it opt into a SLR and app

1200
00:40:39,110 --> 00:40:43,520
or you know some other security

1201
00:40:40,190 --> 00:40:46,490
attribute analysis so okay that's you

1202
00:40:43,520 --> 00:40:49,130
know kind of a quick and furious run

1203
00:40:46,490 --> 00:40:50,689
through all of the things fuzzing the

1204
00:40:49,130 --> 00:40:52,400
background and the new tools and so

1205
00:40:50,690 --> 00:40:55,250
lastly I'll just say that even though

1206
00:40:52,400 --> 00:40:56,720
these tools are very easy to use there's

1207
00:40:55,250 --> 00:40:57,950
probably still some level of

1208
00:40:56,720 --> 00:41:00,350
professional services you'll need

1209
00:40:57,950 --> 00:41:03,049
because setting up understanding

1210
00:41:00,350 --> 00:41:05,690
triaging understanding fixing the

1211
00:41:03,050 --> 00:41:07,460
results is not necessarily something

1212
00:41:05,690 --> 00:41:09,770
that everybody has interest in learning

1213
00:41:07,460 --> 00:41:10,550
that deep of a subject about but it's

1214
00:41:09,770 --> 00:41:13,520
something that we're very passionate

1215
00:41:10,550 --> 00:41:16,550
about we do it a lot so whether it's on

1216
00:41:13,520 --> 00:41:19,040
seed discovery or creation or whether

1217
00:41:16,550 --> 00:41:21,760
it's you know fixing the software or

1218
00:41:19,040 --> 00:41:24,320
creating a proof-of-concept exploit

1219
00:41:21,760 --> 00:41:26,390
we've got a lot of expertise we could go

1220
00:41:24,320 --> 00:41:27,650
more into all the details about that but

1221
00:41:26,390 --> 00:41:30,080
those are some of the services that we

1222
00:41:27,650 --> 00:41:32,360
provided also setting up fuzzing

1223
00:41:30,080 --> 00:41:33,660
harnesses is really important basically

1224
00:41:32,360 --> 00:41:35,010
we've got a blog on that if you want to

1225
00:41:33,660 --> 00:41:39,210
learn more about that but that's where

1226
00:41:35,010 --> 00:41:40,799
not every application is very suited to

1227
00:41:39,210 --> 00:41:42,960
the way that these tools work so you may

1228
00:41:40,799 --> 00:41:44,970
have to create some glue logic maybe a

1229
00:41:42,960 --> 00:41:46,619
wrapper for the program may be some kind

1230
00:41:44,970 --> 00:41:48,169
of redirection thing that sends data out

1231
00:41:46,619 --> 00:41:50,309
of network pipe whatever it might be

1232
00:41:48,170 --> 00:41:52,349
that's called a fuzzing harness we can

1233
00:41:50,309 --> 00:41:54,180
help you set that up as well and again

1234
00:41:52,349 --> 00:41:56,039
whether it's creating a patch or doing

1235
00:41:54,180 --> 00:41:57,930
some proof-of-concept exploit

1236
00:41:56,039 --> 00:42:00,510
development that's something that we can

1237
00:41:57,930 --> 00:42:01,890
help you with as well lastly we do have

1238
00:42:00,510 --> 00:42:03,750
a github we've got a lot of different

1239
00:42:01,890 --> 00:42:04,980
things on that we've got our blog and

1240
00:42:03,750 --> 00:42:06,569
our github that's probably two of the

1241
00:42:04,980 --> 00:42:07,799
main ways you can find information if

1242
00:42:06,569 --> 00:42:10,349
you want to follow the research that we

1243
00:42:07,799 --> 00:42:12,720
do and we do intend to post some of the

1244
00:42:10,349 --> 00:42:14,490
results and things there so I want to

1245
00:42:12,720 --> 00:42:18,169
leave a couple minutes to see if anybody

1246
00:42:14,490 --> 00:42:20,700
has any questions about software testing

1247
00:42:18,170 --> 00:42:23,490
fuzzing apps sack really anything in

1248
00:42:20,700 --> 00:42:32,549
general any questions at all related to

1249
00:42:23,490 --> 00:42:34,049
this yeah go ahead yes we haven't done

1250
00:42:32,549 --> 00:42:35,759
that yeah we haven't crossed that bridge

1251
00:42:34,049 --> 00:42:37,770
in terms of bug bounty I think they

1252
00:42:35,760 --> 00:42:38,970
would at least want to be credited that

1253
00:42:37,770 --> 00:42:40,710
their tool was the one that found the

1254
00:42:38,970 --> 00:42:42,180
vulnerability and make sure that the

1255
00:42:40,710 --> 00:42:45,569
vulnerability was dealt with responsibly

1256
00:42:42,180 --> 00:42:47,339
and things like that mostly you know the

1257
00:42:45,569 --> 00:42:49,288
intent for these tools is to then be

1258
00:42:47,339 --> 00:42:50,849
later you know purchased and used by

1259
00:42:49,289 --> 00:42:51,960
private corporations that are gonna do

1260
00:42:50,849 --> 00:42:54,119
their own apps tech work rather than

1261
00:42:51,960 --> 00:42:54,869
just kind of rapidly bug bounty or

1262
00:42:54,119 --> 00:42:56,789
anything I don't think that's the

1263
00:42:54,869 --> 00:42:57,990
original intent of this but I do like

1264
00:42:56,789 --> 00:42:59,460
the question I totally understand where

1265
00:42:57,990 --> 00:43:03,470
your what your head's at on it's good

1266
00:42:59,460 --> 00:43:03,470
question anything else yeah go ahead

1267
00:43:03,500 --> 00:43:11,760
uh-huh it's a great question yeah yeah

1268
00:43:09,900 --> 00:43:13,500
especially people that do kind of you

1269
00:43:11,760 --> 00:43:16,289
know they work in environments that are

1270
00:43:13,500 --> 00:43:18,240
kind of like closed-door Rd environments

1271
00:43:16,289 --> 00:43:19,619
or you know that type of stuff if you

1272
00:43:18,240 --> 00:43:21,299
have a SAS or a cloud tool sometimes

1273
00:43:19,619 --> 00:43:22,500
it's difficult to do because you may not

1274
00:43:21,299 --> 00:43:23,279
be connected to the Internet so that's a

1275
00:43:22,500 --> 00:43:27,839
really good question

1276
00:43:23,279 --> 00:43:30,180
and the answer is I'm pretty sure both

1277
00:43:27,839 --> 00:43:32,430
can be set up that way I'm not percent

1278
00:43:30,180 --> 00:43:33,629
sure about Ms Rd they mostly want it in

1279
00:43:32,430 --> 00:43:35,250
their space because it runs you know

1280
00:43:33,630 --> 00:43:36,569
it's Microsoft's proprietary stuff it

1281
00:43:35,250 --> 00:43:38,549
runs in their in their cloud in their

1282
00:43:36,569 --> 00:43:40,380
space I know mayhem for sure said that

1283
00:43:38,549 --> 00:43:42,299
they are facilitating it to be set up in

1284
00:43:40,380 --> 00:43:44,279
private spaces because a lot of their

1285
00:43:42,299 --> 00:43:47,589
use cases DoD work and things like that

1286
00:43:44,279 --> 00:43:49,569
so the answer is maybe I'm per

1287
00:43:47,589 --> 00:43:51,369
pretty sure maybe in at least one case

1288
00:43:49,569 --> 00:43:55,150
not so sure about the other case but

1289
00:43:51,369 --> 00:44:02,009
that is a good question yeah and yeah go

1290
00:43:55,150 --> 00:44:04,959
ahead so that's a good question can

1291
00:44:02,009 --> 00:44:06,189
android mobile apps which are because

1292
00:44:04,959 --> 00:44:07,989
mobile apps on Android are written in

1293
00:44:06,189 --> 00:44:10,420
Java they're an APK file can they be

1294
00:44:07,989 --> 00:44:12,249
tested fuzz tested in this way and the

1295
00:44:10,420 --> 00:44:14,019
answer is you could but it wouldn't

1296
00:44:12,249 --> 00:44:15,848
really be appropriate because this is

1297
00:44:14,019 --> 00:44:18,368
really meant to test native code so the

1298
00:44:15,849 --> 00:44:20,680
Android operating system the Bluetooth

1299
00:44:18,369 --> 00:44:23,949
interface the LTE the Wi-Fi the

1300
00:44:20,680 --> 00:44:25,058
operating system kernel file or parsing

1301
00:44:23,949 --> 00:44:27,219
that type of stuff it would be very

1302
00:44:25,059 --> 00:44:29,229
appropriate for that but mobile apps

1303
00:44:27,219 --> 00:44:30,430
themselves are usually tested in a

1304
00:44:29,229 --> 00:44:31,749
different way mobile app testing is

1305
00:44:30,430 --> 00:44:34,919
usually a different discipline so I

1306
00:44:31,749 --> 00:44:39,848
would say probably not good question

1307
00:44:34,920 --> 00:44:43,140
other questions all right well thank you

1308
00:44:39,849 --> 00:44:43,140
so much go ahead we got one more

1309
00:44:51,110 --> 00:44:54,800
yeah it's good question so AFL is the

1310
00:44:53,270 --> 00:44:56,270
only open-source tool that's really in

1311
00:44:54,800 --> 00:44:57,650
the next-gen fuzzing space you can

1312
00:44:56,270 --> 00:44:58,970
download that and play with it for free

1313
00:44:57,650 --> 00:45:00,260
and I highly recommend you do if you

1314
00:44:58,970 --> 00:45:01,759
want to kind of kind of get your feet

1315
00:45:00,260 --> 00:45:15,920
wet with this stuff so good question

1316
00:45:01,760 --> 00:45:17,450
yeah um you can yeah you would have to

1317
00:45:15,920 --> 00:45:19,400
write a harness though so we take some

1318
00:45:17,450 --> 00:45:21,200
further sort of complicated set up but

1319
00:45:19,400 --> 00:45:26,590
it is possible yes for kernels good

1320
00:45:21,200 --> 00:45:26,589
question yeah all right well thanks

