1
00:00:00,000 --> 00:00:06,450
did they get the beer machine fixed well

2
00:00:04,170 --> 00:00:07,740
I see beer so it must be yes

3
00:00:06,450 --> 00:00:09,480
somebody told me last when there's no

4
00:00:07,740 --> 00:00:10,679
the beer wasn't working correctly so I

5
00:00:09,480 --> 00:00:13,620
just wanted to double-check before I

6
00:00:10,679 --> 00:00:15,240
walk all the way over there so well

7
00:00:13,620 --> 00:00:16,820
thanks for being in our afternoon

8
00:00:15,240 --> 00:00:19,770
session we're going to talk about

9
00:00:16,820 --> 00:00:23,220
symbolically executing a fuzzy tyrant

10
00:00:19,770 --> 00:00:26,400
with our friend logical all right

11
00:00:23,220 --> 00:00:27,390
thank you very much everyone uh I will

12
00:00:26,400 --> 00:00:30,060
be talking about symbolic execution

13
00:00:27,390 --> 00:00:32,399
fuzzing that sort of stuff today I have

14
00:00:30,060 --> 00:00:35,280
a flair for whimsy so you'll notice that

15
00:00:32,399 --> 00:00:37,829
this is mostly using Nabucco verdes

16
00:00:35,280 --> 00:00:39,960
Nabucco as a theme has no tie-in

17
00:00:37,829 --> 00:00:42,450
whatsoever but you'll see it throughout

18
00:00:39,960 --> 00:00:44,460
the talk my name though is stefan

19
00:00:42,450 --> 00:00:46,620
Edwards I am the assurance practice lead

20
00:00:44,460 --> 00:00:50,610
at trail of bits if you're not familiar

21
00:00:46,620 --> 00:00:52,649
with Trello bits we are a low-level like

22
00:00:50,610 --> 00:00:54,660
cyber security research firm we do lots

23
00:00:52,649 --> 00:00:57,030
of like blockchain sorts of stuff in

24
00:00:54,660 --> 00:00:58,349
tech reverse engineering those sorts of

25
00:00:57,030 --> 00:01:01,800
things you may be familiar with our

26
00:00:58,350 --> 00:01:04,229
tools I myself work in defense

27
00:01:01,800 --> 00:01:06,060
blockchain IOT compilers that sort of

28
00:01:04,229 --> 00:01:09,750
stuff a lot of our VCO Services

29
00:01:06,060 --> 00:01:11,640
procedural services go through me and I

30
00:01:09,750 --> 00:01:13,650
also do like our threat modeling things

31
00:01:11,640 --> 00:01:16,200
if you read the kubernetes threat model

32
00:01:13,650 --> 00:01:19,320
or if you saw the the kubernetes

33
00:01:16,200 --> 00:01:21,409
technical assessment for the CN CF that

34
00:01:19,320 --> 00:01:23,758
was myself and my team at Trello bits

35
00:01:21,409 --> 00:01:25,560
you also may have heard me on absolute

36
00:01:23,759 --> 00:01:28,259
apps a core risky business which just

37
00:01:25,560 --> 00:01:28,890
came out I think yesterday so just two

38
00:01:28,259 --> 00:01:30,689
warnings

39
00:01:28,890 --> 00:01:32,460
I'm extremely hard of hearing I'm also

40
00:01:30,689 --> 00:01:33,990
extremely sick at the moment so my

41
00:01:32,460 --> 00:01:35,429
hearing is completely gone so if you

42
00:01:33,990 --> 00:01:38,130
have questions and I ask you to repeat

43
00:01:35,430 --> 00:01:40,799
like 37,000 times it's just from that

44
00:01:38,130 --> 00:01:43,259
and then I'm also from New York

45
00:01:40,799 --> 00:01:45,810
I slept enough so my accent shouldn't

46
00:01:43,259 --> 00:01:47,939
come out but if I do speak too fast or

47
00:01:45,810 --> 00:01:51,509
if my accents too thick or anything like

48
00:01:47,939 --> 00:01:54,929
that just let me know so what are we

49
00:01:51,509 --> 00:01:56,490
actually talking about today today we'll

50
00:01:54,930 --> 00:01:59,369
be going over some of the basic tools

51
00:01:56,490 --> 00:02:01,289
that we use to understand code right and

52
00:01:59,369 --> 00:02:02,520
then we'll move a little bit deeper into

53
00:02:01,290 --> 00:02:04,590
the stack of things and I'll explain

54
00:02:02,520 --> 00:02:06,960
what I mean by that as we go through but

55
00:02:04,590 --> 00:02:09,000
I wanted to talk about first the the two

56
00:02:06,960 --> 00:02:12,209
major ways that we attempt to understand

57
00:02:09,000 --> 00:02:13,350
code currently and then try to try to

58
00:02:12,209 --> 00:02:14,640
suss out what

59
00:02:13,350 --> 00:02:17,359
sort of coverage we get from those

60
00:02:14,640 --> 00:02:19,829
things and then move into fuzzing

61
00:02:17,360 --> 00:02:21,810
understanding what maybe we think of as

62
00:02:19,830 --> 00:02:23,640
fuzzing versus what someone from trail

63
00:02:21,810 --> 00:02:25,080
of bits or from some of the other

64
00:02:23,640 --> 00:02:27,750
speakers I think Jared DeMott is

65
00:02:25,080 --> 00:02:30,630
speaking on on symbolic execution and

66
00:02:27,750 --> 00:02:32,520
fuzzing later but what others may mean

67
00:02:30,630 --> 00:02:35,010
about fuzzing and that sort of thing and

68
00:02:32,520 --> 00:02:38,070
then move into symbolic execution what

69
00:02:35,010 --> 00:02:40,079
it is and what I'm using it for in my

70
00:02:38,070 --> 00:02:45,359
personal time I'm releasing a framework

71
00:02:40,080 --> 00:02:48,510
today and I apologize I'm presenting out

72
00:02:45,360 --> 00:02:50,430
of marpe normally I don't but for some

73
00:02:48,510 --> 00:02:53,880
reason mark is generating a bad PDF

74
00:02:50,430 --> 00:02:57,150
today but this talk mainly covers three

75
00:02:53,880 --> 00:02:58,650
things I really want you to understand

76
00:02:57,150 --> 00:03:01,080
that we can do better than traditional

77
00:02:58,650 --> 00:03:03,240
tooling right the sorts of things that

78
00:03:01,080 --> 00:03:04,020
we run to understand code we can do much

79
00:03:03,240 --> 00:03:07,530
better than that

80
00:03:04,020 --> 00:03:10,230
for malware for pen testers for whoever

81
00:03:07,530 --> 00:03:11,340
you are and then I want to explain what

82
00:03:10,230 --> 00:03:13,380
the hell does this actually look like

83
00:03:11,340 --> 00:03:15,840
right very frequently you'll see things

84
00:03:13,380 --> 00:03:19,170
that reference formal tooling formal

85
00:03:15,840 --> 00:03:20,880
verification symbolic execution it's not

86
00:03:19,170 --> 00:03:23,100
really nearly as scary as it might

87
00:03:20,880 --> 00:03:26,370
necessarily sound the framework that I'm

88
00:03:23,100 --> 00:03:28,230
releasing today it's up on github it was

89
00:03:26,370 --> 00:03:29,970
written in about a month it does some

90
00:03:28,230 --> 00:03:31,769
Pathak's pleurae ssin and things like

91
00:03:29,970 --> 00:03:34,470
that it's very simple very

92
00:03:31,770 --> 00:03:36,090
straightforward to follow but these

93
00:03:34,470 --> 00:03:37,920
these sorts of things are not used by

94
00:03:36,090 --> 00:03:39,740
the vast majority of folks because it's

95
00:03:37,920 --> 00:03:41,790
like this hidden area of academic

96
00:03:39,740 --> 00:03:44,700
InfoSec that we don't normally touch

97
00:03:41,790 --> 00:03:46,410
upon and then the last is how to make

98
00:03:44,700 --> 00:03:49,140
these things much more accessible right

99
00:03:46,410 --> 00:03:52,230
there's a lots of papers on these sorts

100
00:03:49,140 --> 00:03:54,359
of things Fabrice good gutta freud will

101
00:03:52,230 --> 00:03:56,310
publish on these sorts of things we've

102
00:03:54,360 --> 00:03:58,110
published on these sorts of things but

103
00:03:56,310 --> 00:03:59,910
they're not really accessible for for

104
00:03:58,110 --> 00:04:01,470
normal folks people don't think of these

105
00:03:59,910 --> 00:04:03,180
sorts of tools when they're thinking of

106
00:04:01,470 --> 00:04:04,920
how do I understand my code how do I

107
00:04:03,180 --> 00:04:06,600
understand what I'm doing so I want to

108
00:04:04,920 --> 00:04:10,859
try to break down that barrier and make

109
00:04:06,600 --> 00:04:12,510
it a little bit more accessible but if

110
00:04:10,860 --> 00:04:14,160
there's three things that you really

111
00:04:12,510 --> 00:04:15,450
take away from this talk is that there's

112
00:04:14,160 --> 00:04:19,230
nothing wrong with the way that we do

113
00:04:15,450 --> 00:04:20,640
traditional tooling for code for for pen

114
00:04:19,230 --> 00:04:22,470
tests for those sorts of things there's

115
00:04:20,640 --> 00:04:25,320
absolutely nothing wrong with it it does

116
00:04:22,470 --> 00:04:26,740
have its place I'll talk later

117
00:04:25,320 --> 00:04:28,870
but as much

118
00:04:26,740 --> 00:04:30,460
I love symbolic execution and think it's

119
00:04:28,870 --> 00:04:32,500
super interesting lots of findings can

120
00:04:30,460 --> 00:04:34,810
come out of it I still find most of my

121
00:04:32,500 --> 00:04:37,030
findings either with fuzzing or with my

122
00:04:34,810 --> 00:04:38,740
own two fists very little of what I find

123
00:04:37,030 --> 00:04:41,289
is necessarily from symbolic execution

124
00:04:38,740 --> 00:04:43,360
symbolic execution can colic execution

125
00:04:41,289 --> 00:04:44,469
those sorts of things they help a lot

126
00:04:43,360 --> 00:04:46,030
they helped me understand the

127
00:04:44,470 --> 00:04:48,370
constraints under which things execute

128
00:04:46,030 --> 00:04:50,049
and whatnot but traditional tooling

129
00:04:48,370 --> 00:04:51,699
still shouldn't be thrown out just based

130
00:04:50,050 --> 00:04:53,880
on anything that I'm presenting here

131
00:04:51,699 --> 00:04:56,770
today or Jared or anyone else presents

132
00:04:53,880 --> 00:04:58,449
and that formal verification techniques

133
00:04:56,770 --> 00:05:00,130
themselves are not actually that scary

134
00:04:58,449 --> 00:05:01,539
they're very accessible once you

135
00:05:00,130 --> 00:05:03,969
understand what they're doing once you

136
00:05:01,539 --> 00:05:05,740
understand what they're actually how to

137
00:05:03,970 --> 00:05:06,940
use them they're not very difficult to

138
00:05:05,740 --> 00:05:08,620
get into themselves even though they

139
00:05:06,940 --> 00:05:10,180
might necessarily be a little bit more

140
00:05:08,620 --> 00:05:13,449
academic than what you're normally doing

141
00:05:10,180 --> 00:05:15,669
and then lastly I wanted to just give a

142
00:05:13,449 --> 00:05:17,740
really quick really brief introduction

143
00:05:15,669 --> 00:05:24,430
to the sorts of program analysis things

144
00:05:17,740 --> 00:05:27,130
that we do so what is actually program

145
00:05:24,430 --> 00:05:29,590
analysis right programs actually have a

146
00:05:27,130 --> 00:05:31,389
space over which they execute now I'll

147
00:05:29,590 --> 00:05:34,539
demo what I'm talking about in a minute

148
00:05:31,389 --> 00:05:36,400
but there's a large space that we intend

149
00:05:34,539 --> 00:05:39,099
so if you think about your program as a

150
00:05:36,400 --> 00:05:40,900
graph and all the things your program

151
00:05:39,099 --> 00:05:43,479
can do you probably intended for it to

152
00:05:40,900 --> 00:05:45,698
do a very small slice of that entire

153
00:05:43,479 --> 00:05:48,460
graph of potential actions and yet

154
00:05:45,699 --> 00:05:50,409
attackers people like myself reverse

155
00:05:48,460 --> 00:05:53,859
engineers whomever will discover the

156
00:05:50,409 --> 00:05:55,180
entire set the entire domain of of

157
00:05:53,860 --> 00:05:56,710
operations that your program can

158
00:05:55,180 --> 00:05:58,630
undertake so that's what we're

159
00:05:56,710 --> 00:06:00,880
attempting to uncover we're attempting

160
00:05:58,630 --> 00:06:03,699
to find the ways in which your program

161
00:06:00,880 --> 00:06:05,590
can operate in unintended consequences

162
00:06:03,699 --> 00:06:06,639
and there's there's multiple techniques

163
00:06:05,590 --> 00:06:08,349
for you doing this I'll talk about

164
00:06:06,639 --> 00:06:10,060
fuzzing the various techniques of

165
00:06:08,349 --> 00:06:11,620
fuzzing I'll talk about symbolic and can

166
00:06:10,060 --> 00:06:14,400
colic execution but there's a large

167
00:06:11,620 --> 00:06:16,900
world of both academic and practical

168
00:06:14,400 --> 00:06:18,729
methods for actually uncovering these

169
00:06:16,900 --> 00:06:20,258
sorts of things themselves but

170
00:06:18,729 --> 00:06:21,818
effectively whenever you hear me say

171
00:06:20,259 --> 00:06:24,400
program analysis you can just think of

172
00:06:21,819 --> 00:06:29,740
it as very fancy potentially automated

173
00:06:24,400 --> 00:06:31,719
and very formalized debugging itself so

174
00:06:29,740 --> 00:06:36,520
has has anyone heard of weird machines

175
00:06:31,719 --> 00:06:40,360
before perfect one person - maybe so

176
00:06:36,520 --> 00:06:42,008
weird machines is is this actual area

177
00:06:40,360 --> 00:06:43,659
I'm talking about these are the sorts of

178
00:06:42,009 --> 00:06:45,909
things that your program is normally

179
00:06:43,659 --> 00:06:47,830
meant to do you may have codified it to

180
00:06:45,909 --> 00:06:49,389
accept some user input and do something

181
00:06:47,830 --> 00:06:52,210
on it and then there's an entire

182
00:06:49,389 --> 00:06:53,680
universe of think of other things that

183
00:06:52,210 --> 00:06:55,508
your program can do from unintended

184
00:06:53,680 --> 00:06:57,340
consequences and these are called weird

185
00:06:55,509 --> 00:06:58,780
machines there's several names for them

186
00:06:57,340 --> 00:07:00,310
but that's that's the most common name

187
00:06:58,780 --> 00:07:01,750
that you hear and there's many different

188
00:07:00,310 --> 00:07:04,629
techniques for actually exploiting

189
00:07:01,750 --> 00:07:08,770
discovering and actually using weird

190
00:07:04,629 --> 00:07:10,990
machines for all sorts of fun things so

191
00:07:08,770 --> 00:07:13,060
I think the most interesting one are the

192
00:07:10,990 --> 00:07:15,789
three that I've I've picked here

193
00:07:13,060 --> 00:07:17,919
everyone knows Rob gadgets right yes

194
00:07:15,789 --> 00:07:19,840
at least I've heard about them right so

195
00:07:17,919 --> 00:07:21,279
Rob gadgets are certainly a type of

196
00:07:19,840 --> 00:07:23,020
weird machine but I think the more

197
00:07:21,279 --> 00:07:25,120
interesting ones are that the move

198
00:07:23,020 --> 00:07:28,419
instruction on x86 is actually Turing

199
00:07:25,120 --> 00:07:30,669
complete so you can use move no other

200
00:07:28,419 --> 00:07:32,620
instructions whatsoever with in x86 to

201
00:07:30,669 --> 00:07:34,210
completely encode effectively any

202
00:07:32,620 --> 00:07:36,219
program that can be encoded in a Turing

203
00:07:34,210 --> 00:07:38,560
machine so that's a neat one and then

204
00:07:36,219 --> 00:07:40,870
pythons pickle is also another one

205
00:07:38,560 --> 00:07:42,370
pythons pickle is a serialization format

206
00:07:40,870 --> 00:07:44,050
similar to like JSON or something like

207
00:07:42,370 --> 00:07:47,169
this but it's actually implemented as a

208
00:07:44,050 --> 00:07:48,879
virtual machine so most folks use it to

209
00:07:47,169 --> 00:07:50,258
store class or maybe some structured

210
00:07:48,879 --> 00:07:51,879
data in a dictionary or something like

211
00:07:50,259 --> 00:07:54,490
that but pickles can actually execute

212
00:07:51,879 --> 00:07:56,199
all sorts of functionality external to

213
00:07:54,490 --> 00:07:59,110
that so discovering those sorts of

214
00:07:56,199 --> 00:08:02,289
things is a lot of fun if you ever see

215
00:07:59,110 --> 00:08:03,729
things that use pickles or consume

216
00:08:02,289 --> 00:08:06,039
pickles from untrusted sources you

217
00:08:03,729 --> 00:08:07,839
basically have remote code execution and

218
00:08:06,039 --> 00:08:10,060
it's fun because I've actually created a

219
00:08:07,839 --> 00:08:12,580
ripple that compiles a small subset of

220
00:08:10,060 --> 00:08:18,009
Python into pickles and then executes

221
00:08:12,580 --> 00:08:21,878
sit on the target machine so when I'm

222
00:08:18,009 --> 00:08:23,680
thinking about programs the techniques

223
00:08:21,879 --> 00:08:26,199
that I'm talking about will fit into one

224
00:08:23,680 --> 00:08:29,289
of these areas right in the in the top

225
00:08:26,199 --> 00:08:30,819
left over here we have the potential

226
00:08:29,289 --> 00:08:33,760
domain of your entire program and

227
00:08:30,819 --> 00:08:35,620
ideally we have this little box that we

228
00:08:33,760 --> 00:08:38,078
expect our program to actually execute

229
00:08:35,620 --> 00:08:40,149
that's what we want our program to

230
00:08:38,078 --> 00:08:42,039
execute but the ways in which we

231
00:08:40,149 --> 00:08:45,279
actually discover if our program does

232
00:08:42,039 --> 00:08:47,050
that very to the way to how much they

233
00:08:45,279 --> 00:08:49,569
actually map to our ideal so

234
00:08:47,050 --> 00:08:51,640
traditionally we may have spot checks we

235
00:08:49,569 --> 00:08:53,500
may think of something check it and then

236
00:08:51,640 --> 00:08:54,279
we'll put a little dot and hopefully

237
00:08:53,500 --> 00:08:56,800
those forms

238
00:08:54,279 --> 00:08:58,839
for a little box we may create tests but

239
00:08:56,800 --> 00:09:00,878
these tests can test anything that we

240
00:08:58,839 --> 00:09:02,649
want them to they don't necessarily have

241
00:09:00,879 --> 00:09:04,810
to test anything that's related to the

242
00:09:02,649 --> 00:09:06,069
program itself correct functionality we

243
00:09:04,810 --> 00:09:09,128
have no idea what they actually end up

244
00:09:06,069 --> 00:09:11,498
testing we can fuzz the bejesus out of

245
00:09:09,129 --> 00:09:13,509
something right we can have this giant

246
00:09:11,499 --> 00:09:15,579
Oort cloud of things we have no idea how

247
00:09:13,509 --> 00:09:17,680
this relates to things necessarily and

248
00:09:15,579 --> 00:09:19,029
then we can use these higher-level

249
00:09:17,680 --> 00:09:20,620
techniques that I'll be talking about

250
00:09:19,029 --> 00:09:23,079
today abstract interpretation and

251
00:09:20,620 --> 00:09:24,579
symbolic execution but those don't

252
00:09:23,079 --> 00:09:27,069
necessarily get you to an ideal either

253
00:09:24,579 --> 00:09:28,540
they may map out a domain of what your

254
00:09:27,069 --> 00:09:29,949
program is doing but it doesn't

255
00:09:28,540 --> 00:09:32,829
necessarily mean that it maps to your

256
00:09:29,949 --> 00:09:34,149
intended domain I know this is crazy and

257
00:09:32,829 --> 00:09:35,378
there's probably a lot of people who are

258
00:09:34,149 --> 00:09:35,860
thinking what the that I just walk

259
00:09:35,379 --> 00:09:40,079
into

260
00:09:35,860 --> 00:09:42,819
but I'll hopefully explain most of this

261
00:09:40,079 --> 00:09:44,859
but more than anything I want you to

262
00:09:42,819 --> 00:09:48,998
walk away with this talk or from this

263
00:09:44,860 --> 00:09:50,769
talk that you can understand code using

264
00:09:48,999 --> 00:09:52,839
automated techniques discovering

265
00:09:50,769 --> 00:09:55,420
constraints discovering these sorts of

266
00:09:52,839 --> 00:09:57,449
weird machines that are in programs that

267
00:09:55,420 --> 00:09:59,740
are in software that you'll be using and

268
00:09:57,449 --> 00:10:00,099
apply them to the domains that we work

269
00:09:59,740 --> 00:10:02,680
in

270
00:10:00,100 --> 00:10:04,420
I at trail of bits obviously run the

271
00:10:02,680 --> 00:10:08,378
assurance practice I do quite a bit of

272
00:10:04,420 --> 00:10:09,910
like you know the normal code reviews

273
00:10:08,379 --> 00:10:11,500
and those sorts of things right we do

274
00:10:09,910 --> 00:10:14,649
hire surance we're Cottrell vets but

275
00:10:11,500 --> 00:10:16,660
still we look at a lot of code so for us

276
00:10:14,649 --> 00:10:18,430
understanding code is is bread and

277
00:10:16,660 --> 00:10:20,050
butter to what we do but there's nothing

278
00:10:18,430 --> 00:10:22,660
stopping folks who work in malware

279
00:10:20,050 --> 00:10:23,829
analysis who work in reverse engineering

280
00:10:22,660 --> 00:10:25,029
from applying many of these same

281
00:10:23,829 --> 00:10:27,370
techniques and indeed there are

282
00:10:25,029 --> 00:10:28,870
mechanisms for applying what we'll be

283
00:10:27,370 --> 00:10:34,000
talking about today - like reverse

284
00:10:28,870 --> 00:10:35,470
engineered code so before I dive into

285
00:10:34,000 --> 00:10:38,649
those higher-level technique techniques

286
00:10:35,470 --> 00:10:40,329
and before I dive into the sorts of

287
00:10:38,649 --> 00:10:42,100
things that I think are better that we

288
00:10:40,329 --> 00:10:43,239
can be using let's let's talk about some

289
00:10:42,100 --> 00:10:48,910
of the traditional tools that are out

290
00:10:43,240 --> 00:10:51,999
there so traditionally we have two basic

291
00:10:48,910 --> 00:10:54,850
divisions right and this is probably

292
00:10:51,999 --> 00:10:56,800
semi controversial to say this but

293
00:10:54,850 --> 00:10:57,879
there's two basic divisions of what

294
00:10:56,800 --> 00:10:59,949
we're talking about we either have

295
00:10:57,879 --> 00:11:02,410
dynamic testing in which were we're

296
00:10:59,949 --> 00:11:05,439
actually exercising the system under

297
00:11:02,410 --> 00:11:07,740
test an application code whatever it is

298
00:11:05,439 --> 00:11:10,599
and we have static testing

299
00:11:07,740 --> 00:11:12,339
and that's the the usual dichotomy that

300
00:11:10,600 --> 00:11:14,410
we see so these are the sorts of things

301
00:11:12,339 --> 00:11:16,060
that might scan code look for

302
00:11:14,410 --> 00:11:17,560
misconfigured credentials look for

303
00:11:16,060 --> 00:11:19,689
default credentials that sort of thing

304
00:11:17,560 --> 00:11:22,119
or they would go through you'd see your

305
00:11:19,690 --> 00:11:23,740
fortifies your your rats your splints

306
00:11:22,120 --> 00:11:26,470
those sorts of things and just look

307
00:11:23,740 --> 00:11:29,740
through for dependencies this is the

308
00:11:26,470 --> 00:11:31,029
traditional stack as much as as much as

309
00:11:29,740 --> 00:11:32,709
we want to move beyond this this is

310
00:11:31,029 --> 00:11:34,720
really the dichotomy that we focus on

311
00:11:32,709 --> 00:11:37,839
even though we can move beyond these

312
00:11:34,720 --> 00:11:39,790
sorts of things so in a static world

313
00:11:37,839 --> 00:11:41,320
we've all seen linters we've all seen

314
00:11:39,790 --> 00:11:44,019
those sorts of like code check tools

315
00:11:41,320 --> 00:11:45,850
we'll look at some today unsafe function

316
00:11:44,019 --> 00:11:47,680
checkers basically things that either

317
00:11:45,850 --> 00:11:49,870
look through for Strings grep for things

318
00:11:47,680 --> 00:11:52,029
whatever they are and then we have the

319
00:11:49,870 --> 00:11:53,949
the dynamic runners themselves if you

320
00:11:52,029 --> 00:11:56,769
work in MySpace they may be something

321
00:11:53,949 --> 00:11:58,380
that you know goes through a web

322
00:11:56,769 --> 00:12:01,029
application goes through blockchain

323
00:11:58,380 --> 00:12:03,130
exercises ER c20 functionality something

324
00:12:01,029 --> 00:12:05,410
like that or it may just be malware that

325
00:12:03,130 --> 00:12:07,300
you run in a sandbox but those fall into

326
00:12:05,410 --> 00:12:09,459
basically the dynamic domain themselves

327
00:12:07,300 --> 00:12:11,410
and these are the simplest possible

328
00:12:09,459 --> 00:12:13,060
tests that you can run these are the

329
00:12:11,410 --> 00:12:15,899
sort of like you must be this tall to be

330
00:12:13,060 --> 00:12:19,719
audited sorts of tests that you have and

331
00:12:15,899 --> 00:12:22,300
whilst they do provide usable usable

332
00:12:19,720 --> 00:12:24,399
findings and usable bugs they're usually

333
00:12:22,300 --> 00:12:26,829
lower quality or lower issue lower

334
00:12:24,399 --> 00:12:28,180
severity sorts of bugs for several

335
00:12:26,829 --> 00:12:30,010
reasons right and we'll get into that

336
00:12:28,180 --> 00:12:32,589
but partially because you just don't

337
00:12:30,010 --> 00:12:36,670
know much more than the actual location

338
00:12:32,589 --> 00:12:38,940
that something has occurred so let's

339
00:12:36,670 --> 00:12:42,189
take a let's take a quick look at this

340
00:12:38,940 --> 00:12:45,130
some C code right not everyone's going

341
00:12:42,190 --> 00:12:47,529
to know C but just some simple code here

342
00:12:45,130 --> 00:12:49,060
right this is actually something that I

343
00:12:47,529 --> 00:12:52,420
use for interviews when folks come in

344
00:12:49,060 --> 00:12:55,000
right now hopefully several people have

345
00:12:52,420 --> 00:12:56,469
spotted a few different bugs here but

346
00:12:55,000 --> 00:13:00,130
there's actually a subtle bug in here as

347
00:12:56,470 --> 00:13:05,560
well that not everyone catches so we

348
00:13:00,130 --> 00:13:08,589
have some simple C so the simplest

349
00:13:05,560 --> 00:13:10,359
possible type of scanner that you can do

350
00:13:08,589 --> 00:13:13,240
is something that just checks for

351
00:13:10,360 --> 00:13:15,100
Strings right we've all done this we've

352
00:13:13,240 --> 00:13:17,439
grep through some code we've used act

353
00:13:15,100 --> 00:13:19,300
through some code we use rats for things

354
00:13:17,439 --> 00:13:20,400
to look for for Strings within code

355
00:13:19,300 --> 00:13:22,560
bases and

356
00:13:20,400 --> 00:13:24,209
indeed rats does actually find some

357
00:13:22,560 --> 00:13:25,979
things in here there are some problems

358
00:13:24,210 --> 00:13:29,279
with this source code that rat rats

359
00:13:25,980 --> 00:13:31,980
actually captures so we do get two hits

360
00:13:29,279 --> 00:13:33,960
that they call two gets is is incorrect

361
00:13:31,980 --> 00:13:37,020
and the call to stir copies is

362
00:13:33,960 --> 00:13:38,910
problematic the F gets recommendation

363
00:13:37,020 --> 00:13:41,579
itself is fine there's nothing wrong

364
00:13:38,910 --> 00:13:44,189
with what rats suggests for it F gets

365
00:13:41,580 --> 00:13:45,990
instead of gets the stir copy one is

366
00:13:44,190 --> 00:13:48,630
everyone familiar with stir or is anyone

367
00:13:45,990 --> 00:13:52,589
familiar with stir copy itself few folks

368
00:13:48,630 --> 00:13:54,810
so stir copy one is is not so useful but

369
00:13:52,589 --> 00:13:56,790
it's about as simple as we get we have

370
00:13:54,810 --> 00:13:58,829
no set-up time there's no understanding

371
00:13:56,790 --> 00:14:01,670
literally anyone can run this code and

372
00:13:58,830 --> 00:14:06,150
look for things that are problematic air

373
00:14:01,670 --> 00:14:07,829
so we may want to upgrade ourselves we

374
00:14:06,150 --> 00:14:09,300
may want to see okay look

375
00:14:07,830 --> 00:14:12,480
rats doesn't give us very much

376
00:14:09,300 --> 00:14:15,300
information will run splint splint does

377
00:14:12,480 --> 00:14:17,130
some higher-level checks it reports six

378
00:14:15,300 --> 00:14:18,900
things some of them are our

379
00:14:17,130 --> 00:14:20,550
initialization related some of them are

380
00:14:18,900 --> 00:14:25,230
our type related some of them are

381
00:14:20,550 --> 00:14:28,410
function related perfectly fine the

382
00:14:25,230 --> 00:14:30,450
problem with splint is that of those two

383
00:14:28,410 --> 00:14:32,670
of them are false positives the get

384
00:14:30,450 --> 00:14:34,230
there's the get s finding and there's a

385
00:14:32,670 --> 00:14:37,290
potential memory leak with it with our

386
00:14:34,230 --> 00:14:38,959
use of foo however despite the fact that

387
00:14:37,290 --> 00:14:41,040
stir copy is extremely problematic

388
00:14:38,959 --> 00:14:42,839
splint doesn't actually recommend

389
00:14:41,040 --> 00:14:45,329
anything to do with it right because

390
00:14:42,839 --> 00:14:47,190
splint can't determine intention for

391
00:14:45,330 --> 00:14:49,529
what we're actually intending to do here

392
00:14:47,190 --> 00:14:50,640
but it's still pretty simple we do

393
00:14:49,529 --> 00:14:54,390
something a little bit better we get

394
00:14:50,640 --> 00:14:56,339
some better findings out of it but

395
00:14:54,390 --> 00:14:57,449
there's lots of false positives and even

396
00:14:56,339 --> 00:15:01,770
these things are completely fooled

397
00:14:57,450 --> 00:15:03,990
easily has anyone ever seen PMD run PMD

398
00:15:01,770 --> 00:15:05,370
and gotten clean results from it and

399
00:15:03,990 --> 00:15:07,860
then looked at the source code and

400
00:15:05,370 --> 00:15:10,080
noticed that someone put no PMD at the

401
00:15:07,860 --> 00:15:12,810
top of source code which means don't run

402
00:15:10,080 --> 00:15:15,390
PMD on this so I've had I've had

403
00:15:12,810 --> 00:15:17,430
developers who when things were failing

404
00:15:15,390 --> 00:15:19,410
in see ICD pipelines or things like that

405
00:15:17,430 --> 00:15:21,420
instead of fixing it they just add no

406
00:15:19,410 --> 00:15:23,910
PMD so that it stops failing but that

407
00:15:21,420 --> 00:15:26,189
also means it's not being checked the

408
00:15:23,910 --> 00:15:29,490
other interesting thing is that the stir

409
00:15:26,190 --> 00:15:31,110
copy is completely wrong so stir copies

410
00:15:29,490 --> 00:15:33,410
arguments are actually backwards this is

411
00:15:31,110 --> 00:15:36,769
a UNIX historical

412
00:15:33,410 --> 00:15:38,000
tradition or convention and neither one

413
00:15:36,769 --> 00:15:40,329
of these tools noted that we were

414
00:15:38,000 --> 00:15:44,930
actually using foo which is the source

415
00:15:40,329 --> 00:15:46,339
for the destination now so it at this

416
00:15:44,930 --> 00:15:48,949
level when we have these sorts of

417
00:15:46,339 --> 00:15:50,899
lower-level traditional tools things are

418
00:15:48,949 --> 00:15:53,089
very easily confused there's lots of

419
00:15:50,899 --> 00:15:54,740
false positives but we basically have a

420
00:15:53,089 --> 00:15:56,439
lot of things that we can triage for a

421
00:15:54,740 --> 00:16:00,829
minimal effort

422
00:15:56,439 --> 00:16:02,839
and indeed these all go back to the way

423
00:16:00,829 --> 00:16:04,758
that these tools work they don't model

424
00:16:02,839 --> 00:16:07,129
things necessarily too strongly for

425
00:16:04,759 --> 00:16:09,470
example rats is literally doing this

426
00:16:07,129 --> 00:16:11,120
it's literally highlighting boxes in

427
00:16:09,470 --> 00:16:13,069
your code and says hey this is probably

428
00:16:11,120 --> 00:16:14,269
problematic there's nothing that you can

429
00:16:13,069 --> 00:16:17,899
do that's safe about these sorts of

430
00:16:14,269 --> 00:16:19,970
things so at a simple model right and we

431
00:16:17,899 --> 00:16:22,069
all form mental models doesn't matter if

432
00:16:19,970 --> 00:16:23,600
you're developing code doesn't matter if

433
00:16:22,069 --> 00:16:25,339
you're analyzing something you develop

434
00:16:23,600 --> 00:16:28,730
these sort of mental models yourself as

435
00:16:25,339 --> 00:16:31,550
well so this is the sorts of model that

436
00:16:28,730 --> 00:16:34,430
rats is actually using a splint is a

437
00:16:31,550 --> 00:16:38,240
little bit more formal it actually

438
00:16:34,430 --> 00:16:40,099
builds up a tree of things to walk all

439
00:16:38,240 --> 00:16:42,709
right and that's how it does this sort

440
00:16:40,100 --> 00:16:45,500
of coloring on objects right so it knows

441
00:16:42,709 --> 00:16:47,180
that foo if you remember back to the the

442
00:16:45,500 --> 00:16:49,759
actual code that we have it remembers

443
00:16:47,180 --> 00:16:51,709
that foo is nullable that foo itself

444
00:16:49,759 --> 00:16:53,300
actually could be null and could be

445
00:16:51,709 --> 00:16:55,819
passed into these sorts of problematic

446
00:16:53,300 --> 00:16:58,310
functions so it does some sort of

447
00:16:55,819 --> 00:16:59,779
checking it actually understands the

448
00:16:58,310 --> 00:17:02,599
model of the code that it's executing

449
00:16:59,779 --> 00:17:04,039
right and so it can actually capture

450
00:17:02,600 --> 00:17:07,010
more things whether or not those are

451
00:17:04,039 --> 00:17:10,429
false positives that's left to behold

452
00:17:07,010 --> 00:17:12,349
but it actually does build up a greater

453
00:17:10,429 --> 00:17:15,500
understanding of things and greater

454
00:17:12,349 --> 00:17:18,319
understanding of programs themselves and

455
00:17:15,500 --> 00:17:20,539
the model of things impact what we

456
00:17:18,319 --> 00:17:22,299
actually can test that it impacts what

457
00:17:20,539 --> 00:17:25,339
we understand about our code itself

458
00:17:22,299 --> 00:17:27,530
right so we have two strings here we

459
00:17:25,339 --> 00:17:31,668
stir copy one and to the other and then

460
00:17:27,530 --> 00:17:34,970
we attempt to printf right and splint

461
00:17:31,669 --> 00:17:37,220
based on its model realizes that the

462
00:17:34,970 --> 00:17:39,890
start copy the initializations

463
00:17:37,220 --> 00:17:43,669
and the use of all of this functionality

464
00:17:39,890 --> 00:17:45,559
is completely acceptable but rats still

465
00:17:43,669 --> 00:17:46,800
warns you and now you have to go back

466
00:17:45,559 --> 00:17:48,600
and triage

467
00:17:46,800 --> 00:17:51,030
what's actually happening in the code

468
00:17:48,600 --> 00:17:53,250
itself to actually understand what is

469
00:17:51,030 --> 00:17:55,530
what is being impacted here which at the

470
00:17:53,250 --> 00:17:56,970
end of the day is nothing so you get

471
00:17:55,530 --> 00:17:58,860
these findings very quickly you get

472
00:17:56,970 --> 00:18:01,140
these issues very quickly and then you

473
00:17:58,860 --> 00:18:02,459
end up having to triage them much more

474
00:18:01,140 --> 00:18:12,780
because of the sorts of things that you

475
00:18:02,460 --> 00:18:15,240
have here so yes so what we're trying to

476
00:18:12,780 --> 00:18:18,720
do is actually form models of our code

477
00:18:15,240 --> 00:18:20,160
this is this is from a ideation that I

478
00:18:18,720 --> 00:18:22,140
was having when I was talking through

479
00:18:20,160 --> 00:18:23,730
some of these sorts of things and on the

480
00:18:22,140 --> 00:18:26,840
static side we have the like the simple

481
00:18:23,730 --> 00:18:30,060
string searches regex is linters paint

482
00:18:26,840 --> 00:18:33,899
and then symbolic execution and dynamic

483
00:18:30,060 --> 00:18:35,700
side we go down in power but as we're

484
00:18:33,900 --> 00:18:38,730
attempting to understand code we're

485
00:18:35,700 --> 00:18:40,440
attempting to go down this list on

486
00:18:38,730 --> 00:18:41,940
either side until you get to something

487
00:18:40,440 --> 00:18:45,180
like abstract interpretation which

488
00:18:41,940 --> 00:18:47,490
straddles both sides we're trying to go

489
00:18:45,180 --> 00:18:49,500
down and gain understanding of our code

490
00:18:47,490 --> 00:18:51,750
and gain understanding of the exploits

491
00:18:49,500 --> 00:18:54,990
issues and surface area of our code

492
00:18:51,750 --> 00:18:59,000
itself using these techniques does make

493
00:18:54,990 --> 00:19:08,160
sense to everyone probably yes No yeah

494
00:18:59,000 --> 00:19:10,140
cool so let's talk about fuzzing I think

495
00:19:08,160 --> 00:19:11,910
people have a notion of fuzzing they

496
00:19:10,140 --> 00:19:15,380
think of it as just random testing it's

497
00:19:11,910 --> 00:19:17,550
not necessarily what we always mean but

498
00:19:15,380 --> 00:19:19,470
fuzzing itself is an extremely useful

499
00:19:17,550 --> 00:19:21,600
technique probably everyone has seen it

500
00:19:19,470 --> 00:19:23,670
or used it in some fashion but I want to

501
00:19:21,600 --> 00:19:25,530
talk about what we mean by fuzzing

502
00:19:23,670 --> 00:19:28,500
versus what is often used as fuzzing

503
00:19:25,530 --> 00:19:29,760
itself so traditionally people think of

504
00:19:28,500 --> 00:19:32,370
fuzzing is just throwing random garbage

505
00:19:29,760 --> 00:19:34,080
on an application right you can think of

506
00:19:32,370 --> 00:19:36,629
you know I don't know reading out of

507
00:19:34,080 --> 00:19:38,429
like dev you ran or something of this

508
00:19:36,630 --> 00:19:40,770
nature to throw out an application

509
00:19:38,430 --> 00:19:42,930
itself that's not what I mean when I say

510
00:19:40,770 --> 00:19:44,520
fuzzing I'm talking about mutation

511
00:19:42,930 --> 00:19:47,880
testing and I'm talking about property

512
00:19:44,520 --> 00:19:50,400
testing so we can do something like

513
00:19:47,880 --> 00:19:52,800
we're given a valid input from an

514
00:19:50,400 --> 00:19:56,070
application we're given something from

515
00:19:52,800 --> 00:19:58,080
an application and we bit flip that to

516
00:19:56,070 --> 00:20:00,060
see and watch what an application does

517
00:19:58,080 --> 00:20:00,720
right that's the sort of mutation

518
00:20:00,060 --> 00:20:03,210
testing

519
00:20:00,720 --> 00:20:05,190
so we start from a valid input we

520
00:20:03,210 --> 00:20:06,870
mutated as many times as possible see

521
00:20:05,190 --> 00:20:10,020
what the application does see if it

522
00:20:06,870 --> 00:20:12,449
crashes right and this also can be

523
00:20:10,020 --> 00:20:14,639
highly structured right so I've had

524
00:20:12,450 --> 00:20:16,710
applications that required some some

525
00:20:14,640 --> 00:20:18,660
form of JSON in we want we don't want to

526
00:20:16,710 --> 00:20:21,450
fuzz the JSON parser that's probably not

527
00:20:18,660 --> 00:20:23,490
useful to to the end-user right we want

528
00:20:21,450 --> 00:20:25,620
to actually fuzz the application itself

529
00:20:23,490 --> 00:20:27,450
so there are techniques and there are

530
00:20:25,620 --> 00:20:29,370
ways of doing these sorts of things via

531
00:20:27,450 --> 00:20:35,040
property testing and via other other

532
00:20:29,370 --> 00:20:38,070
related tools and these are remote in

533
00:20:35,040 --> 00:20:40,110
most folks tool sets right they people

534
00:20:38,070 --> 00:20:42,480
use the fuzz DB they use SEC lists they

535
00:20:40,110 --> 00:20:44,459
use intruder if they're using burp right

536
00:20:42,480 --> 00:20:46,860
they have these sorts of things it's

537
00:20:44,460 --> 00:20:49,140
completely normal right but we're not

538
00:20:46,860 --> 00:20:51,419
actually mutating program State with

539
00:20:49,140 --> 00:20:53,820
many of these right think about SEC

540
00:20:51,420 --> 00:20:56,010
lists not to pick on Daniel but to think

541
00:20:53,820 --> 00:20:58,590
about SEC lists right if you're looking

542
00:20:56,010 --> 00:21:01,020
for XSS or you're looking for something

543
00:20:58,590 --> 00:21:03,720
in an application if you just run SEC

544
00:21:01,020 --> 00:21:05,879
lists it's a literal huge list of XSS

545
00:21:03,720 --> 00:21:07,500
payloads super useful you may discover

546
00:21:05,880 --> 00:21:09,300
something there but it's not actually

547
00:21:07,500 --> 00:21:10,890
mutating program State there may be

548
00:21:09,300 --> 00:21:13,740
things that the program is doing that

549
00:21:10,890 --> 00:21:16,140
are contextually interesting for what

550
00:21:13,740 --> 00:21:18,060
the program is that will never be found

551
00:21:16,140 --> 00:21:21,660
by just throwing a random list of words

552
00:21:18,060 --> 00:21:23,610
at it so we're trying to uncover the

553
00:21:21,660 --> 00:21:25,170
light yellow portion of our applications

554
00:21:23,610 --> 00:21:27,030
by throwing random data at it and

555
00:21:25,170 --> 00:21:28,350
mutation is is one of the most useful

556
00:21:27,030 --> 00:21:36,570
ways that we can do those sorts of

557
00:21:28,350 --> 00:21:39,060
things so this is the this is the

558
00:21:36,570 --> 00:21:42,600
easiest example here we're looking for

559
00:21:39,060 --> 00:21:44,399
something that's a strength right we we

560
00:21:42,600 --> 00:21:46,590
may just throw random bytes on it they

561
00:21:44,400 --> 00:21:48,690
may be valid ASCII they may not be they

562
00:21:46,590 --> 00:21:50,909
may be utf-8 we have no idea we don't

563
00:21:48,690 --> 00:21:53,850
care we're just throwing random data at

564
00:21:50,910 --> 00:21:56,580
our application if we're doing mutation

565
00:21:53,850 --> 00:21:58,679
testing we actually take valid data and

566
00:21:56,580 --> 00:22:02,040
then output invariance of it has anyone

567
00:21:58,680 --> 00:22:05,940
used read and saw before for fuzzing now

568
00:22:02,040 --> 00:22:07,889
so Radames a naive fuzzer it it does

569
00:22:05,940 --> 00:22:09,720
mutation testing has many different

570
00:22:07,890 --> 00:22:11,460
techniques and algorithms that you can

571
00:22:09,720 --> 00:22:13,740
use for these sorts of things and I

572
00:22:11,460 --> 00:22:14,370
found a large number of vulnerabilities

573
00:22:13,740 --> 00:22:16,860
just by running

574
00:22:14,370 --> 00:22:19,530
Radames that things we can also have

575
00:22:16,860 --> 00:22:22,050
grammar based fuzzing so basically we

576
00:22:19,530 --> 00:22:23,700
describe the data we describe how things

577
00:22:22,050 --> 00:22:25,800
work so for example I've done grammar

578
00:22:23,700 --> 00:22:27,230
based fuzzing by describing the

579
00:22:25,800 --> 00:22:30,090
instructions of a virtual machine

580
00:22:27,230 --> 00:22:32,610
describing the opcodes and the operands

581
00:22:30,090 --> 00:22:35,070
and then having something randomly walk

582
00:22:32,610 --> 00:22:37,139
through and generate grammars of these

583
00:22:35,070 --> 00:22:39,419
sorts of things and then we can have

584
00:22:37,140 --> 00:22:42,000
property testing so property testing is

585
00:22:39,420 --> 00:22:43,380
like unit testing on steroids it's

586
00:22:42,000 --> 00:22:45,870
probably the easiest way to describe it

587
00:22:43,380 --> 00:22:47,220
we describe some set of invariants we

588
00:22:45,870 --> 00:22:49,530
describe some set of properties within

589
00:22:47,220 --> 00:22:51,420
our within our code base and then we run

590
00:22:49,530 --> 00:22:52,559
random generation on these sorts of

591
00:22:51,420 --> 00:22:56,160
things and see what we can actually

592
00:22:52,559 --> 00:22:58,080
cause to break and perhaps perhaps not

593
00:22:56,160 --> 00:23:00,090
with things like AFL we can actually

594
00:22:58,080 --> 00:23:07,050
implement or instrument our program to

595
00:23:00,090 --> 00:23:09,928
see what the actual state is itself so

596
00:23:07,050 --> 00:23:12,149
the goal is to get greater depth right

597
00:23:09,929 --> 00:23:14,550
beyond what humans can see and and we do

598
00:23:12,150 --> 00:23:18,390
see these sorts of results I myself have

599
00:23:14,550 --> 00:23:20,850
had 50 I think 57 bugs just from radon

600
00:23:18,390 --> 00:23:23,250
so in the last two years doing nothing

601
00:23:20,850 --> 00:23:25,860
else not being smart about it not being

602
00:23:23,250 --> 00:23:28,050
you know not modeling anything not

603
00:23:25,860 --> 00:23:30,840
actually attempting to go into any depth

604
00:23:28,050 --> 00:23:34,860
of these sorts of things I've had 57 or

605
00:23:30,840 --> 00:23:37,379
so bugs say 50 right and AFL actually

606
00:23:34,860 --> 00:23:39,928
has to maintain a repository of all of

607
00:23:37,380 --> 00:23:42,750
the bugs that it's found so we're

608
00:23:39,929 --> 00:23:44,160
clearly finding some some random we're

609
00:23:42,750 --> 00:23:48,140
clearly finding some issues with random

610
00:23:44,160 --> 00:23:48,140
testing right bless you

611
00:23:48,910 --> 00:23:54,310
but can we actually tell what we're

612
00:23:51,940 --> 00:23:55,720
covering here right

613
00:23:54,310 --> 00:23:56,950
if you throw random data at an

614
00:23:55,720 --> 00:23:58,600
application do you know what you're

615
00:23:56,950 --> 00:24:00,400
getting out of it do you have any idea

616
00:23:58,600 --> 00:24:03,280
if that state was intended if it wasn't

617
00:24:00,400 --> 00:24:05,140
and like what are we actually getting

618
00:24:03,280 --> 00:24:08,139
out we can watch for crashes but what if

619
00:24:05,140 --> 00:24:09,520
the application doesn't crash right what

620
00:24:08,140 --> 00:24:11,440
if it just gets into some weird state

621
00:24:09,520 --> 00:24:14,040
and continues to hang we've seen these

622
00:24:11,440 --> 00:24:16,600
sorts of things before kubernetes itself

623
00:24:14,040 --> 00:24:20,560
fuzzing it you there are ways to make

624
00:24:16,600 --> 00:24:22,449
kubernetes like cubelet hang or ways to

625
00:24:20,560 --> 00:24:25,149
cause things like block chains to hang

626
00:24:22,450 --> 00:24:28,330
that don't produce any any actual valid

627
00:24:25,150 --> 00:24:29,830
results but that doesn't mean that we

628
00:24:28,330 --> 00:24:31,840
can watch for a crash they never panic

629
00:24:29,830 --> 00:24:32,830
right so we have to have some

630
00:24:31,840 --> 00:24:34,480
understanding of what we're actually

631
00:24:32,830 --> 00:24:40,389
looking for in order to get this sort of

632
00:24:34,480 --> 00:24:43,690
coverage then we can write we can use

633
00:24:40,390 --> 00:24:46,600
some things like a FL FL American fuzzy

634
00:24:43,690 --> 00:24:51,010
lop it is a tool for for actually

635
00:24:46,600 --> 00:24:53,110
instrumenting binaries or code it hooks

636
00:24:51,010 --> 00:24:55,890
in watches which paths things work down

637
00:24:53,110 --> 00:24:59,320
fuzz's those and we can also spend time

638
00:24:55,890 --> 00:25:01,060
specifying property tests so if you've

639
00:24:59,320 --> 00:25:03,460
written unit tests before imagine

640
00:25:01,060 --> 00:25:05,740
writing these sorts of tests and saying

641
00:25:03,460 --> 00:25:08,710
hey no matter what happens this this

642
00:25:05,740 --> 00:25:10,480
function should never fail right based

643
00:25:08,710 --> 00:25:12,190
on this property you can do this and

644
00:25:10,480 --> 00:25:13,720
have a have a tool actually randomly

645
00:25:12,190 --> 00:25:15,570
generate that but the amount of time

646
00:25:13,720 --> 00:25:18,610
that you actually spend doing that is

647
00:25:15,570 --> 00:25:20,080
very high compared to what we maybe

648
00:25:18,610 --> 00:25:22,270
would want to do we want those that's

649
00:25:20,080 --> 00:25:24,010
sort of like quick fix that we have with

650
00:25:22,270 --> 00:25:26,379
with the sort of rats and splint and

651
00:25:24,010 --> 00:25:28,750
things like that and we can use newer

652
00:25:26,380 --> 00:25:30,310
techniques to gray box fuzzing is a new

653
00:25:28,750 --> 00:25:31,630
technique that's that's out super

654
00:25:30,310 --> 00:25:33,010
interesting if you're fascinated by

655
00:25:31,630 --> 00:25:35,230
these sorts of things gray box fuzzing

656
00:25:33,010 --> 00:25:37,570
is interesting but no matter what we're

657
00:25:35,230 --> 00:25:39,880
trying to do the whole purpose of this

658
00:25:37,570 --> 00:25:42,790
is to discover the that light yellow

659
00:25:39,880 --> 00:25:45,070
area in our weird machines picture we're

660
00:25:42,790 --> 00:25:46,180
trying to find and exercise new

661
00:25:45,070 --> 00:25:48,870
functionality within an application

662
00:25:46,180 --> 00:25:48,870
itself

663
00:25:49,320 --> 00:25:54,679
so we need to uncover these paths right

664
00:25:52,410 --> 00:25:58,020
because programs themselves are just

665
00:25:54,680 --> 00:25:59,310
fancy graphs has anyone seen graphs of

666
00:25:58,020 --> 00:26:01,650
programs before like a control flow

667
00:25:59,310 --> 00:26:03,240
graph or a data flow graph sure if

668
00:26:01,650 --> 00:26:05,520
you've done any reverse engineering if

669
00:26:03,240 --> 00:26:07,740
you've done any like code analysis with

670
00:26:05,520 --> 00:26:10,020
compilers those sorts of things programs

671
00:26:07,740 --> 00:26:12,930
themselves are just graphs there's some

672
00:26:10,020 --> 00:26:15,320
constraint there's some like basically

673
00:26:12,930 --> 00:26:17,370
boolean check or whatever there that

674
00:26:15,320 --> 00:26:19,260
specifies some condition under which we

675
00:26:17,370 --> 00:26:21,719
execute this piece of code this portion

676
00:26:19,260 --> 00:26:24,030
of code and then we also are constrained

677
00:26:21,720 --> 00:26:26,160
by input right it doesn't matter if it's

678
00:26:24,030 --> 00:26:27,629
user input or if it's system input we're

679
00:26:26,160 --> 00:26:29,700
constrained by these sorts of things but

680
00:26:27,630 --> 00:26:33,570
really the question that we're trying to

681
00:26:29,700 --> 00:26:42,080
ask is can we discover and graph all

682
00:26:33,570 --> 00:26:46,950
paths within an application itself so

683
00:26:42,080 --> 00:26:49,919
let's talk about symbolic execution so

684
00:26:46,950 --> 00:26:52,140
program space itself is usually quite

685
00:26:49,920 --> 00:26:54,150
wide right there's lots of things that

686
00:26:52,140 --> 00:26:56,790
go on in an application there's lots of

687
00:26:54,150 --> 00:26:58,260
things that that happened within an

688
00:26:56,790 --> 00:27:00,750
application that we want to discover

689
00:26:58,260 --> 00:27:02,910
them without having to do much ourselves

690
00:27:00,750 --> 00:27:04,170
we want the cheapest fastest way to

691
00:27:02,910 --> 00:27:05,880
discover these sorts of things and

692
00:27:04,170 --> 00:27:08,220
symbolic execution can certainly work

693
00:27:05,880 --> 00:27:11,040
that and one of the things that I'll be

694
00:27:08,220 --> 00:27:12,990
introducing is what I've been working on

695
00:27:11,040 --> 00:27:15,240
for like the last a month it's not a

696
00:27:12,990 --> 00:27:16,620
month's worth of actual time it's bits

697
00:27:15,240 --> 00:27:21,480
and pieces here and there as I need

698
00:27:16,620 --> 00:27:24,300
things but programs themselves are just

699
00:27:21,480 --> 00:27:26,310
grass they're textual graphs that we

700
00:27:24,300 --> 00:27:28,830
write things together and string them

701
00:27:26,310 --> 00:27:30,149
together write nodes represent some sort

702
00:27:28,830 --> 00:27:32,129
of action within the system and then we

703
00:27:30,150 --> 00:27:34,140
have edges that represent constraints so

704
00:27:32,130 --> 00:27:36,300
think about this code this is some

705
00:27:34,140 --> 00:27:37,980
simplified code that I've seen many

706
00:27:36,300 --> 00:27:39,930
times I'm sure everyone has seen things

707
00:27:37,980 --> 00:27:41,580
like this so we have an if and we have

708
00:27:39,930 --> 00:27:44,250
an else we undertake two different

709
00:27:41,580 --> 00:27:49,439
actions depending on if J is actually

710
00:27:44,250 --> 00:27:51,350
less than K so there's actually no

711
00:27:49,440 --> 00:27:54,120
difference between those two programs

712
00:27:51,350 --> 00:27:55,949
right the textual representation before

713
00:27:54,120 --> 00:27:58,620
can be just as easily represented as a

714
00:27:55,950 --> 00:28:00,300
graph here right we don't know what J

715
00:27:58,620 --> 00:28:02,879
and K are so we set them to some lambda

716
00:28:00,300 --> 00:28:04,560
we don't know there's some some

717
00:28:02,880 --> 00:28:06,150
you to say symbolically we know that

718
00:28:04,560 --> 00:28:07,879
these are two different values or we

719
00:28:06,150 --> 00:28:11,280
suspect they're two different values and

720
00:28:07,880 --> 00:28:13,980
then we have this graph on one slide we

721
00:28:11,280 --> 00:28:15,389
know that J's J is less than K and on

722
00:28:13,980 --> 00:28:17,190
some other side we know that J is

723
00:28:15,390 --> 00:28:18,810
greater than or equal to K those are the

724
00:28:17,190 --> 00:28:26,340
that's the dichotomy of this program

725
00:28:18,810 --> 00:28:29,070
itself so what we're actually attempting

726
00:28:26,340 --> 00:28:30,600
to do is is provide these graphs or find

727
00:28:29,070 --> 00:28:33,000
these graphs generate the constraints

728
00:28:30,600 --> 00:28:35,730
and then solve them has anyone seen

729
00:28:33,000 --> 00:28:37,650
constraint solving before yes

730
00:28:35,730 --> 00:28:41,880
so constraint solving is basically a

731
00:28:37,650 --> 00:28:44,610
system that takes a you know like a SMT

732
00:28:41,880 --> 00:28:46,230
formula and then attempts to apply a

733
00:28:44,610 --> 00:28:47,669
bunch of binary techniques to generate

734
00:28:46,230 --> 00:28:48,930
these sorts of things there's bit

735
00:28:47,670 --> 00:28:51,480
bashing in a lot in here

736
00:28:48,930 --> 00:28:54,750
my focus is mostly on combining fuzzing

737
00:28:51,480 --> 00:28:56,670
with symbolic execution but nonetheless

738
00:28:54,750 --> 00:28:58,590
there's various means by which you can

739
00:28:56,670 --> 00:29:00,000
actually generate these graphs generate

740
00:28:58,590 --> 00:29:03,570
these constraints and then solve them

741
00:29:00,000 --> 00:29:06,660
and it's extremely useful Klee is it

742
00:29:03,570 --> 00:29:11,250
helps if I don't lock myself out Klee is

743
00:29:06,660 --> 00:29:13,380
a common one that works atop LLVM we at

744
00:29:11,250 --> 00:29:16,290
Trello bits have a symbolic executor in

745
00:29:13,380 --> 00:29:19,620
a Manticore consensus diligence has one

746
00:29:16,290 --> 00:29:21,870
named mithril mythix now and these two

747
00:29:19,620 --> 00:29:23,939
Manticore and mithril are both used in

748
00:29:21,870 --> 00:29:26,340
the blockchain space quite heavily right

749
00:29:23,940 --> 00:29:28,290
so if you have aetherium code you can

750
00:29:26,340 --> 00:29:30,810
symbolically execute them and understand

751
00:29:28,290 --> 00:29:36,540
your programs much more deeply just with

752
00:29:30,810 --> 00:29:37,950
with using Manticore mithril so the

753
00:29:36,540 --> 00:29:39,720
problem with many of these tools though

754
00:29:37,950 --> 00:29:42,840
is that they they generally tend to work

755
00:29:39,720 --> 00:29:44,550
on binary code itself and you know if

756
00:29:42,840 --> 00:29:46,620
we're doing malware analysis my interest

757
00:29:44,550 --> 00:29:49,200
my side interest is in malware analysis

758
00:29:46,620 --> 00:29:51,750
especially with with languages right I'm

759
00:29:49,200 --> 00:29:54,900
kind of curious how we get safe

760
00:29:51,750 --> 00:29:56,700
execution of of office macros of

761
00:29:54,900 --> 00:29:59,750
JavaScript of jscript those sorts of

762
00:29:56,700 --> 00:30:01,410
things and we want to uncover

763
00:29:59,750 --> 00:30:03,300
second-stage things in a safe

764
00:30:01,410 --> 00:30:05,220
environment and I'm kind of tired of

765
00:30:03,300 --> 00:30:06,600
setting up a VM to do these sorts of

766
00:30:05,220 --> 00:30:08,340
things when we have better techniques

767
00:30:06,600 --> 00:30:10,439
and better tools to handle these sorts

768
00:30:08,340 --> 00:30:12,510
of things and the other thing too is

769
00:30:10,440 --> 00:30:14,610
that very frequently they require full

770
00:30:12,510 --> 00:30:16,230
code bases I don't want to walk through

771
00:30:14,610 --> 00:30:16,740
your entire code base I want to see

772
00:30:16,230 --> 00:30:18,150
something that

773
00:30:16,740 --> 00:30:19,770
looks extremely interesting in the

774
00:30:18,150 --> 00:30:22,170
middle of your code I want to pull that

775
00:30:19,770 --> 00:30:27,300
out execute it and find the constraints

776
00:30:22,170 --> 00:30:30,320
itself so I I've been working on this

777
00:30:27,300 --> 00:30:32,399
unnamed cindex project number nine

778
00:30:30,320 --> 00:30:33,870
there's been several all the ones that

779
00:30:32,400 --> 00:30:37,140
I've written either for clients or

780
00:30:33,870 --> 00:30:38,250
written for myself but it's live right

781
00:30:37,140 --> 00:30:41,630
now you can go look at it

782
00:30:38,250 --> 00:30:44,040
it's basically a high-level language

783
00:30:41,630 --> 00:30:46,470
symbolic execution and constraint

784
00:30:44,040 --> 00:30:49,649
environment I'm not focusing on the

785
00:30:46,470 --> 00:30:51,000
these sorts of like you know XIII and

786
00:30:49,650 --> 00:30:53,400
those sorts of constraint algorithms

787
00:30:51,000 --> 00:30:55,350
themselves but it's it's certainly a

788
00:30:53,400 --> 00:30:56,760
possible area then there's a whole list

789
00:30:55,350 --> 00:30:58,320
of references up there as well if you're

790
00:30:56,760 --> 00:31:00,000
interested in these sorts of things but

791
00:30:58,320 --> 00:31:01,710
what I'm actually looking for is a few

792
00:31:00,000 --> 00:31:03,990
different things I want it to be able to

793
00:31:01,710 --> 00:31:06,390
work on partial code like I mentioned I

794
00:31:03,990 --> 00:31:08,580
don't really care to execute your entire

795
00:31:06,390 --> 00:31:11,370
program if you're familiar with symbolic

796
00:31:08,580 --> 00:31:12,928
execution search spaces will explode if

797
00:31:11,370 --> 00:31:15,199
I have to execute your entire program

798
00:31:12,929 --> 00:31:17,309
and I also want to be safe by default

799
00:31:15,200 --> 00:31:19,620
especially because I want to run malware

800
00:31:17,309 --> 00:31:21,809
in this thing so I want something that I

801
00:31:19,620 --> 00:31:23,489
can run arbitrary malware not on the

802
00:31:21,809 --> 00:31:25,379
sandbox and not have to worry about

803
00:31:23,490 --> 00:31:27,179
what's happening in the background so

804
00:31:25,380 --> 00:31:29,580
that's where I'm working here it's it's

805
00:31:27,179 --> 00:31:31,440
roughly a month old currently but the

806
00:31:29,580 --> 00:31:34,470
way it works is it translates languages

807
00:31:31,440 --> 00:31:36,240
like JavaScript into an ugly scheme

808
00:31:34,470 --> 00:31:38,309
dialect does everyone remember scheme

809
00:31:36,240 --> 00:31:40,110
from school like if you went to in

810
00:31:38,309 --> 00:31:41,280
colleges it's very the last time most

811
00:31:40,110 --> 00:31:42,600
people have seen it I actually was a

812
00:31:41,280 --> 00:31:44,639
professional scheme programmer for a

813
00:31:42,600 --> 00:31:46,678
while but it's basically a scheme

814
00:31:44,640 --> 00:31:52,020
dialect and a Python library for

815
00:31:46,679 --> 00:31:54,210
interacting with it and it handles two

816
00:31:52,020 --> 00:31:56,610
different edge cases this can colic

817
00:31:54,210 --> 00:31:58,770
execution concrete execution this is

818
00:31:56,610 --> 00:32:01,229
what we normally think of as execution

819
00:31:58,770 --> 00:32:04,100
when we execute code we concretely go

820
00:32:01,230 --> 00:32:06,450
through we get a set of values we

821
00:32:04,100 --> 00:32:08,909
execute those values return them to the

822
00:32:06,450 --> 00:32:11,490
user display them run them however it is

823
00:32:08,910 --> 00:32:13,410
and then we have symbolic execution now

824
00:32:11,490 --> 00:32:15,030
symbolic execution will go through in a

825
00:32:13,410 --> 00:32:17,070
second but it's basically working on

826
00:32:15,030 --> 00:32:17,850
unknown data itself we don't know what

827
00:32:17,070 --> 00:32:18,960
it is we don't know where the

828
00:32:17,850 --> 00:32:22,129
constraints are we want the application

829
00:32:18,960 --> 00:32:22,130
to tell us that

830
00:32:22,900 --> 00:32:30,130
so we want to map program space itself

831
00:32:26,580 --> 00:32:34,000
so in this code itself I generate two

832
00:32:30,130 --> 00:32:38,680
concrete integers themselves here F and

833
00:32:34,000 --> 00:32:40,210
G and I just add them now that's not in

834
00:32:38,680 --> 00:32:43,180
and of itself interesting where this

835
00:32:40,210 --> 00:32:47,850
becomes interesting is that we have the

836
00:32:43,180 --> 00:32:51,520
trace that's here so in this system

837
00:32:47,850 --> 00:32:53,439
every single value is tagged so you can

838
00:32:51,520 --> 00:32:55,690
actually look through and find even

839
00:32:53,440 --> 00:32:58,150
where constants are used so for example

840
00:32:55,690 --> 00:33:00,160
if the number 10 exists multiple times

841
00:32:58,150 --> 00:33:03,070
within this application you'll actually

842
00:33:00,160 --> 00:33:05,230
see the unique location that that 10 is

843
00:33:03,070 --> 00:33:07,300
actually instantiated each and every

844
00:33:05,230 --> 00:33:09,970
time within within it within an

845
00:33:07,300 --> 00:33:12,460
execution and then we have the trace so

846
00:33:09,970 --> 00:33:16,090
we have the execution path by which we

847
00:33:12,460 --> 00:33:18,910
actually got to this value so it's not

848
00:33:16,090 --> 00:33:20,590
useful to know that H is equal to 21 we

849
00:33:18,910 --> 00:33:23,559
don't care about that we want to know

850
00:33:20,590 --> 00:33:25,120
where and how we got to 21 and these

851
00:33:23,559 --> 00:33:26,740
sorts of value constraints and these

852
00:33:25,120 --> 00:33:32,290
sorts of value traces allow us to do

853
00:33:26,740 --> 00:33:34,570
that but more interestingly is when we

854
00:33:32,290 --> 00:33:38,649
can work on unknown or symbolic data

855
00:33:34,570 --> 00:33:40,870
here so here's a relatively simple st.

856
00:33:38,650 --> 00:33:43,750
almost the same program but now G is

857
00:33:40,870 --> 00:33:48,879
symbolic means we don't know what value

858
00:33:43,750 --> 00:33:50,920
G actually represents right so here when

859
00:33:48,880 --> 00:33:53,800
we add two values we just say we have 10

860
00:33:50,920 --> 00:33:57,640
plus something else now we know for the

861
00:33:53,800 --> 00:34:00,639
lifetime of the program that H is always

862
00:33:57,640 --> 00:34:03,100
10 plus whatever the value of G is we

863
00:34:00,640 --> 00:34:05,200
have no idea what G is we may solve it

864
00:34:03,100 --> 00:34:06,760
we may not solve it we may fuzz it we

865
00:34:05,200 --> 00:34:09,429
may generate it we may constrain it

866
00:34:06,760 --> 00:34:11,199
ourselves we may say hey later on in the

867
00:34:09,429 --> 00:34:14,139
rest of this program G is actually equal

868
00:34:11,199 --> 00:34:16,689
to 20 but from now on the program

869
00:34:14,139 --> 00:34:19,240
actually can trace and follow that H

870
00:34:16,690 --> 00:34:23,379
itself is always 10 greater than

871
00:34:19,239 --> 00:34:25,120
whatever the value of G is and then we

872
00:34:23,379 --> 00:34:27,460
have these unique tags themselves no

873
00:34:25,120 --> 00:34:29,440
matter what so wherever we see that you

874
00:34:27,460 --> 00:34:30,940
UID and I'm using you IDs because that's

875
00:34:29,440 --> 00:34:34,090
the easiest way of getting fresh stems

876
00:34:30,940 --> 00:34:37,440
but no matter what we do we can see

877
00:34:34,090 --> 00:34:37,440
where those values came from themselves

878
00:34:39,299 --> 00:34:47,980
so who actually cares about this right

879
00:34:43,510 --> 00:34:49,269
like why why do we care right why why do

880
00:34:47,980 --> 00:34:51,159
I care about these sorts of things well

881
00:34:49,268 --> 00:34:52,839
there it becomes interesting when you

882
00:34:51,159 --> 00:34:55,000
actually start to look at constraints

883
00:34:52,839 --> 00:34:57,430
themselves so this is what the scheme

884
00:34:55,000 --> 00:34:59,799
dialect itself looks like if you haven't

885
00:34:57,430 --> 00:35:03,190
seen scheme I apologize or Lisp itself

886
00:34:59,799 --> 00:35:05,079
but basically we have some variable foo

887
00:35:03,190 --> 00:35:08,529
and we have no information about it it's

888
00:35:05,079 --> 00:35:10,569
purely symbolic to us and under certain

889
00:35:08,529 --> 00:35:12,279
conditions we return twelve and under

890
00:35:10,569 --> 00:35:15,279
certain conditions we return thirteen

891
00:35:12,279 --> 00:35:17,260
but we know nothing else about about foo

892
00:35:15,279 --> 00:35:26,650
we only know these these sorts of path

893
00:35:17,260 --> 00:35:28,000
constraints so we can start to ask this

894
00:35:26,650 --> 00:35:31,119
questions I know this is a little

895
00:35:28,000 --> 00:35:32,950
difficult to see but we can actually

896
00:35:31,119 --> 00:35:35,470
start to ask questions here so the first

897
00:35:32,950 --> 00:35:38,169
one we have two virtual machines here we

898
00:35:35,470 --> 00:35:41,140
have test VM one and test VM zero so

899
00:35:38,170 --> 00:35:44,170
test VM zero it has some value for foo

900
00:35:41,140 --> 00:35:47,828
itself it has this this information so

901
00:35:44,170 --> 00:35:50,200
when we execute when we execute foo when

902
00:35:47,829 --> 00:35:52,509
we execute this if it actually knows and

903
00:35:50,200 --> 00:35:54,009
can provide a value it says oh hey under

904
00:35:52,509 --> 00:35:56,769
these constraints we actually get a path

905
00:35:54,009 --> 00:36:00,549
execution that returns the value of 12

906
00:35:56,769 --> 00:36:04,288
and it does it under this condition so

907
00:36:00,549 --> 00:36:07,359
you SPE VAR f ast says when foo is true

908
00:36:04,289 --> 00:36:11,500
so foo itself under this path execution

909
00:36:07,359 --> 00:36:13,630
is true now we may have another path

910
00:36:11,500 --> 00:36:16,450
execution so in VM one we have no

911
00:36:13,630 --> 00:36:17,890
information about what food is so VM one

912
00:36:16,450 --> 00:36:20,259
actually says hey there's two different

913
00:36:17,890 --> 00:36:21,490
paths that we have to walk there's one

914
00:36:20,259 --> 00:36:24,339
path that's false

915
00:36:21,490 --> 00:36:26,410
right foo is is false itself it

916
00:36:24,339 --> 00:36:28,450
definitely has to be a boolean and we

917
00:36:26,410 --> 00:36:31,509
have no idea what that returns but under

918
00:36:28,450 --> 00:36:35,379
that path if the application was false

919
00:36:31,509 --> 00:36:38,079
we would get we actually get it twelve

920
00:36:35,380 --> 00:36:40,839
and then if it's if it's true we

921
00:36:38,079 --> 00:36:42,849
actually get 13 we get these two

922
00:36:40,839 --> 00:36:45,009
different paths and they walk they walk

923
00:36:42,849 --> 00:36:47,259
the same constraints so the program is

924
00:36:45,009 --> 00:36:49,819
actually telling us under these

925
00:36:47,259 --> 00:36:52,069
conditions we either have a concrete

926
00:36:49,819 --> 00:36:54,410
execution we execute some path return it

927
00:36:52,069 --> 00:36:56,269
or we have a fork the program doesn't

928
00:36:54,410 --> 00:36:58,279
know which direction we go and you have

929
00:36:56,269 --> 00:37:00,649
to figure that out you have to start to

930
00:36:58,279 --> 00:37:02,839
walk this can be extremely useful if you

931
00:37:00,650 --> 00:37:05,170
have a giant nested if if you have

932
00:37:02,839 --> 00:37:07,749
something that rely trip relies on

933
00:37:05,170 --> 00:37:10,400
environmental data so for example

934
00:37:07,749 --> 00:37:12,618
certain malware we're actually check how

935
00:37:10,400 --> 00:37:14,269
many files you've opened recently on the

936
00:37:12,619 --> 00:37:16,099
system and if you're in a virtual

937
00:37:14,269 --> 00:37:18,890
machine you've probably opened not

938
00:37:16,099 --> 00:37:20,690
enough right because you're not actually

939
00:37:18,890 --> 00:37:22,249
interacting with this system as a normal

940
00:37:20,690 --> 00:37:23,869
as a normal system you're not actually

941
00:37:22,249 --> 00:37:25,399
opening things you're not running things

942
00:37:23,869 --> 00:37:28,759
you're not running programs there

943
00:37:25,400 --> 00:37:30,589
well symbolic execution allows us to say

944
00:37:28,759 --> 00:37:32,390
hey under this condition under this

945
00:37:30,589 --> 00:37:36,109
constraint the program will do X and

946
00:37:32,390 --> 00:37:37,759
split and fork there so we can then

947
00:37:36,109 --> 00:37:39,529
start to trace down and say okay that's

948
00:37:37,759 --> 00:37:45,769
interesting let's continue execution

949
00:37:39,529 --> 00:37:47,269
from there so we want to find the

950
00:37:45,769 --> 00:37:48,979
constraints under which things execute

951
00:37:47,269 --> 00:37:51,319
and symbolic execution allows us to do

952
00:37:48,979 --> 00:37:54,319
this it has many problems but it's

953
00:37:51,319 --> 00:37:57,109
extremely easy currently to at least get

954
00:37:54,319 --> 00:37:59,630
path constraints here and one of the

955
00:37:57,109 --> 00:38:01,489
things that I am very interested in is

956
00:37:59,630 --> 00:38:04,130
is the new techniques that actually

957
00:38:01,489 --> 00:38:06,170
combine symbolic execution and fuzzing

958
00:38:04,130 --> 00:38:09,170
the sorts of gray box fuzzing the sorts

959
00:38:06,170 --> 00:38:11,719
of like learning inputs for for

960
00:38:09,170 --> 00:38:13,940
applications so that's that's my next

961
00:38:11,719 --> 00:38:15,289
step is to actually go through and say

962
00:38:13,940 --> 00:38:19,130
hey if we see something that looks

963
00:38:15,289 --> 00:38:22,789
reasonably like it traces through to a

964
00:38:19,130 --> 00:38:24,949
sink that is XSS let's try X ssing this

965
00:38:22,789 --> 00:38:26,839
let's try something that's contextually

966
00:38:24,949 --> 00:38:28,940
relevant based on the constraints that

967
00:38:26,839 --> 00:38:33,619
we have and let's actually attempt to to

968
00:38:28,940 --> 00:38:36,259
execute that there and then also we have

969
00:38:33,619 --> 00:38:38,209
both concrete and symbolic executions so

970
00:38:36,259 --> 00:38:39,709
we can go through with unknown data we

971
00:38:38,209 --> 00:38:41,868
can go through without data so if you

972
00:38:39,709 --> 00:38:45,948
have valid data you can execute this as

973
00:38:41,869 --> 00:38:48,249
well and I support both micro execution

974
00:38:45,949 --> 00:38:50,630
and standard execution throughout now

975
00:38:48,249 --> 00:38:54,499
has anyone heard of micro execution

976
00:38:50,630 --> 00:38:55,670
before no new technique so micro

977
00:38:54,499 --> 00:39:01,100
execution is actually an extremely

978
00:38:55,670 --> 00:39:05,120
fascinating technique you literally run

979
00:39:01,100 --> 00:39:07,400
one form or one instruction a form is is

980
00:39:05,120 --> 00:39:08,690
a syntactic form like an if block or a

981
00:39:07,400 --> 00:39:11,240
function call or something of that

982
00:39:08,690 --> 00:39:12,860
nature and you provide it with a stack

983
00:39:11,240 --> 00:39:14,149
and E and V all sorts of things that you

984
00:39:12,860 --> 00:39:17,840
need to set up maybe some user input

985
00:39:14,150 --> 00:39:19,820
maybe not but you literally run this one

986
00:39:17,840 --> 00:39:21,680
instruction in the stack in the

987
00:39:19,820 --> 00:39:23,090
environment in whatever you have set up

988
00:39:21,680 --> 00:39:25,399
now why is this interesting

989
00:39:23,090 --> 00:39:27,710
because you can continuously manipulate

990
00:39:25,400 --> 00:39:28,880
the other factors to this instruction

991
00:39:27,710 --> 00:39:30,950
and see what it does to the

992
00:39:28,880 --> 00:39:33,440
environmental variables so for example

993
00:39:30,950 --> 00:39:34,220
if you wanted to discover that move was

994
00:39:33,440 --> 00:39:36,290
turing-complete

995
00:39:34,220 --> 00:39:39,560
you could provide a stack you could

996
00:39:36,290 --> 00:39:42,080
provide certain like certain register

997
00:39:39,560 --> 00:39:44,720
values and see what move actually does

998
00:39:42,080 --> 00:39:46,610
based on the on the execution path that

999
00:39:44,720 --> 00:39:48,709
you see for each single time that you

1000
00:39:46,610 --> 00:39:50,630
call move so you change nothing else

1001
00:39:48,710 --> 00:39:54,200
about the program other than the stack

1002
00:39:50,630 --> 00:39:56,960
and you micro execute it trailer bits we

1003
00:39:54,200 --> 00:39:58,460
have a we have a certain section of the

1004
00:39:56,960 --> 00:40:00,230
company called lifting bits it deals

1005
00:39:58,460 --> 00:40:02,360
with binary representations to higher

1006
00:40:00,230 --> 00:40:04,700
level representations but we do have a

1007
00:40:02,360 --> 00:40:06,800
micro executor called micro X and then

1008
00:40:04,700 --> 00:40:08,569
Patrice could go to Freud has actually

1009
00:40:06,800 --> 00:40:10,880
worked on this quite a bit Microsoft has

1010
00:40:08,570 --> 00:40:13,370
quite a bit of work into micro execution

1011
00:40:10,880 --> 00:40:15,140
but it's a super fascinating technique

1012
00:40:13,370 --> 00:40:17,420
and one of the things that I wanted to

1013
00:40:15,140 --> 00:40:18,980
explore was how does this actually

1014
00:40:17,420 --> 00:40:22,780
interact with high-level languages and

1015
00:40:18,980 --> 00:40:25,430
USP number 9 is actually part of that

1016
00:40:22,780 --> 00:40:27,650
but there's a lot to do if if any of

1017
00:40:25,430 --> 00:40:29,990
this is actually interesting to you I'd

1018
00:40:27,650 --> 00:40:31,460
love to talk afterwards but there's a

1019
00:40:29,990 --> 00:40:33,200
quite a few things that I want to do

1020
00:40:31,460 --> 00:40:35,090
here I want to flesh out the JavaScript

1021
00:40:33,200 --> 00:40:36,589
parser that I have currently it's quite

1022
00:40:35,090 --> 00:40:39,500
manual there's there's quite a bit

1023
00:40:36,590 --> 00:40:42,170
that's going on in there I want to do a

1024
00:40:39,500 --> 00:40:45,470
normal form and Static single static

1025
00:40:42,170 --> 00:40:47,120
assignment a and F and and SSA are super

1026
00:40:45,470 --> 00:40:49,279
useful and lambda lifting so lambda

1027
00:40:47,120 --> 00:40:52,040
lifting basically takes anonymous

1028
00:40:49,280 --> 00:40:53,840
functions from an in situ representation

1029
00:40:52,040 --> 00:40:56,060
and moves them to a higher level and

1030
00:40:53,840 --> 00:40:58,280
then passes in anything that's captured

1031
00:40:56,060 --> 00:41:00,170
from that lambda and I want to add a ton

1032
00:40:58,280 --> 00:41:01,880
more tests and strategies so if you're

1033
00:41:00,170 --> 00:41:05,270
interested in fuzzing and you want to

1034
00:41:01,880 --> 00:41:06,740
understand code more I'd love to see PRS

1035
00:41:05,270 --> 00:41:10,340
and poles to help with some of the

1036
00:41:06,740 --> 00:41:12,589
generation strategy but my use case is I

1037
00:41:10,340 --> 00:41:14,690
want to understand gnarly code that I

1038
00:41:12,590 --> 00:41:17,180
get from either clients from malware

1039
00:41:14,690 --> 00:41:19,520
from those sorts of things and I want to

1040
00:41:17,180 --> 00:41:21,529
exercise them as much as possible see

1041
00:41:19,520 --> 00:41:24,470
under which constraints these programs

1042
00:41:21,530 --> 00:41:26,540
work see how things are going and then

1043
00:41:24,470 --> 00:41:28,279
actually execute them without having to

1044
00:41:26,540 --> 00:41:29,990
know the entire code base without having

1045
00:41:28,280 --> 00:41:33,110
to understand much here and that's what

1046
00:41:29,990 --> 00:41:35,180
I'm using this for so I'm a bit early

1047
00:41:33,110 --> 00:41:36,080
but that's it thank you very much

1048
00:41:35,180 --> 00:41:38,359
everyone for coming

1049
00:41:36,080 --> 00:41:40,400
does anyone have questions since I can

1050
00:41:38,360 --> 00:41:45,050
now play like I can be tortured by

1051
00:41:40,400 --> 00:41:49,750
questions here now everyone everyone

1052
00:41:45,050 --> 00:41:49,750
will wake yeah sure

1053
00:41:56,970 --> 00:42:01,140
sure so the question is like if you want

1054
00:41:59,430 --> 00:42:02,940
to execute gnarly code are you just

1055
00:42:01,140 --> 00:42:05,368
doing sections the entire application

1056
00:42:02,940 --> 00:42:08,160
that sort of thing my my use case is

1057
00:42:05,369 --> 00:42:09,869
very frequently when we have say go code

1058
00:42:08,160 --> 00:42:11,700
or JavaScript typescript that sort of

1059
00:42:09,869 --> 00:42:14,520
thing I want to know what this section

1060
00:42:11,700 --> 00:42:16,470
is doing I may be able to understand how

1061
00:42:14,520 --> 00:42:18,089
to get there but I want to know what

1062
00:42:16,470 --> 00:42:19,859
this is doing and I don't want to

1063
00:42:18,089 --> 00:42:22,020
include the rest of the execution path I

1064
00:42:19,859 --> 00:42:23,848
don't want to walk through so yes I want

1065
00:42:22,020 --> 00:42:26,369
to just rip this out see what this thing

1066
00:42:23,849 --> 00:42:28,349
does and then walk back to those

1067
00:42:26,369 --> 00:42:30,810
constraints myself and then you can

1068
00:42:28,349 --> 00:42:32,520
obviously do control flow graphs to get

1069
00:42:30,810 --> 00:42:35,250
there you can do other walks to get back

1070
00:42:32,520 --> 00:42:37,259
to it but mine is to really pull out in

1071
00:42:35,250 --> 00:42:39,240
situ sections of high-level code and do

1072
00:42:37,260 --> 00:42:41,880
those sorts of things so for example and

1073
00:42:39,240 --> 00:42:44,040
go in JavaScript you manipulate the

1074
00:42:41,880 --> 00:42:46,290
stack quite frequently right you may

1075
00:42:44,040 --> 00:42:48,390
have defers and go you may have

1076
00:42:46,290 --> 00:42:49,500
continuations those sorts of things that

1077
00:42:48,390 --> 00:42:53,250
manipulate the stack

1078
00:42:49,500 --> 00:42:55,890
I want to mechanize those to CPS or ANF

1079
00:42:53,250 --> 00:42:58,020
and then actually walk through those

1080
00:42:55,890 --> 00:42:59,940
constraints there themselves just for

1081
00:42:58,020 --> 00:43:01,560
that one function instead of the entire

1082
00:42:59,940 --> 00:43:04,500
search space of an application that can

1083
00:43:01,560 --> 00:43:06,150
break does that answer your question ok

1084
00:43:04,500 --> 00:43:10,349
quite fully anyone have any other

1085
00:43:06,150 --> 00:43:12,060
questions well perfect thank you very

1086
00:43:10,349 --> 00:43:12,750
much everyone for coming it was a

1087
00:43:12,060 --> 00:43:16,989
pleasure

1088
00:43:12,750 --> 00:43:16,989
[Applause]

