1
00:00:00,380 --> 00:00:06,569
three minutes to start everybody copy

2
00:00:04,080 --> 00:00:08,900
this down if they're going to all right

3
00:00:06,569 --> 00:00:11,490
did you decode it yet

4
00:00:08,900 --> 00:00:14,160
really don't tell anybody with the

5
00:00:11,490 --> 00:00:15,330
secret is you can tell them what the

6
00:00:14,160 --> 00:00:16,890
message is but don't tell them how to

7
00:00:15,330 --> 00:00:25,410
decode it and you got to get it on your

8
00:00:16,890 --> 00:00:29,250
own so this is the point before the talk

9
00:00:25,410 --> 00:00:30,599
where I apologize because those of you

10
00:00:29,250 --> 00:00:33,329
who have come to my talks in the past

11
00:00:30,599 --> 00:00:35,880
you know that I have a particular slide

12
00:00:33,329 --> 00:00:39,680
that I love the slide format that I love

13
00:00:35,880 --> 00:00:43,559
and it's this sadly due to some

14
00:00:39,680 --> 00:00:45,570
unforeseen creation circumstances this

15
00:00:43,559 --> 00:00:47,250
is the only slide that was able to stay

16
00:00:45,570 --> 00:00:50,460
like this for this presentation but

17
00:00:47,250 --> 00:00:55,769
it'll be back in the next one stupid

18
00:00:50,460 --> 00:00:58,280
white background pictures all right

19
00:00:55,770 --> 00:01:00,600
thank you so much for coming out today

20
00:00:58,280 --> 00:01:03,559
anybody coming to see a talk entitled

21
00:01:00,600 --> 00:01:03,559
Shh

22
00:01:09,320 --> 00:01:15,500
and not walking in saying it is welcome

23
00:01:13,370 --> 00:01:18,680
here I appreciate you very very much and

24
00:01:15,500 --> 00:01:22,850
your faith in at least being interesting

25
00:01:18,680 --> 00:01:24,160
and entertaining is is wonderful thank

26
00:01:22,850 --> 00:01:27,320
you so much

27
00:01:24,160 --> 00:01:31,820
so the talk of the title of this talk is

28
00:01:27,320 --> 00:01:33,949
actually a puppy PC style and I won't

29
00:01:31,820 --> 00:01:37,660
try to dance I partly because I sprained

30
00:01:33,950 --> 00:01:37,660
my ankle and it would not be pretty

31
00:01:38,090 --> 00:01:43,150
we're gonna talk a little bit about

32
00:01:39,770 --> 00:01:51,160
powered PC anybody heard of PowerPC

33
00:01:43,150 --> 00:01:57,800
anybody under 40 heard of PowerPC good

34
00:01:51,160 --> 00:02:00,830
good so in typical atlas fashion I'm

35
00:01:57,800 --> 00:02:03,759
gonna try to have a lot of fun technical

36
00:02:00,830 --> 00:02:07,810
stuff if you've never heard of PowerPC

37
00:02:03,759 --> 00:02:13,459
welcome to the 20th century however I

38
00:02:07,810 --> 00:02:15,739
will probably surprise most of you so

39
00:02:13,459 --> 00:02:18,410
Who am I my name is Atlas of doom of

40
00:02:15,739 --> 00:02:24,650
doom got thrown in there because some

41
00:02:18,410 --> 00:02:27,709
forms require a last name I have been

42
00:02:24,650 --> 00:02:29,570
blessed to be a part of some of the

43
00:02:27,709 --> 00:02:33,140
coolest projects that I can even imagine

44
00:02:29,570 --> 00:02:35,329
including breaking out of VMware hacking

45
00:02:33,140 --> 00:02:36,559
on power grid I got to write a tool

46
00:02:35,330 --> 00:02:39,290
called our FCAT some of you have

47
00:02:36,560 --> 00:02:41,000
probably heard of the last several years

48
00:02:39,290 --> 00:02:44,750
I've been hacking and breaking into

49
00:02:41,000 --> 00:02:46,790
vehicles and I can't get over playing

50
00:02:44,750 --> 00:02:49,970
capture the flag even though I feel like

51
00:02:46,790 --> 00:02:52,070
about PowerPC well first of all cuz it

52
00:02:49,970 --> 00:02:56,239
was really cool chipset back in the 90s

53
00:02:52,070 --> 00:02:57,530
that died off oh no wait PowerPC is dead

54
00:02:56,239 --> 00:02:59,370
right let me hear you say it

55
00:02:57,530 --> 00:03:02,469
PowerPC is dead

56
00:02:59,370 --> 00:03:02,469
[Music]

57
00:03:03,769 --> 00:03:14,580
malcontents disrupter along with Power

58
00:03:07,950 --> 00:03:16,319
PC so PowerPC is everywhere a few years

59
00:03:14,580 --> 00:03:19,440
ago when I first ran into it in a

60
00:03:16,319 --> 00:03:23,548
professional project I'm going i thought

61
00:03:19,440 --> 00:03:29,250
this died before Sun did you guys heard

62
00:03:23,549 --> 00:03:31,290
of spark right no PowerPC lives on in

63
00:03:29,250 --> 00:03:34,170
fact we'll talk a little bit about

64
00:03:31,290 --> 00:03:36,150
history in a bit because I'm in my adult

65
00:03:34,170 --> 00:03:40,679
life I become a history buff because

66
00:03:36,150 --> 00:03:44,459
history is not a bunch of dates and dead

67
00:03:40,680 --> 00:03:47,549
dudes and ladies history is how the

68
00:03:44,459 --> 00:03:48,690
world works so I get really excited

69
00:03:47,549 --> 00:03:50,760
about how the world works and how it

70
00:03:48,690 --> 00:03:54,150
comes together because this was a pain

71
00:03:50,760 --> 00:03:55,890
in the ass anybody who's ever read any

72
00:03:54,150 --> 00:03:58,910
documentation and tried to make sense of

73
00:03:55,890 --> 00:04:01,768
a PowerPC chip will resonate with

74
00:03:58,910 --> 00:04:03,420
PowerPC being a pain in the ass it has a

75
00:04:01,769 --> 00:04:03,870
reason and we'll talk about it in just a

76
00:04:03,420 --> 00:04:07,768
second

77
00:04:03,870 --> 00:04:11,819
PowerPC can be found turn today shipping

78
00:04:07,769 --> 00:04:15,060
product in aerospace in automotive and

79
00:04:11,819 --> 00:04:19,289
heavy trucking in shipping in maritime

80
00:04:15,060 --> 00:04:24,410
stuff did you know that a huge segment

81
00:04:19,289 --> 00:04:29,490
of IBM's current sales ship powered pcs

82
00:04:24,410 --> 00:04:32,210
anybody heard of a p-series all your AIX

83
00:04:29,490 --> 00:04:34,139
stuff has always loved the power in fact

84
00:04:32,210 --> 00:04:37,099
PowerPC got its start

85
00:04:34,139 --> 00:04:41,669
based on IBM's original Power

86
00:04:37,099 --> 00:04:45,030
Architecture so hacking one of these

87
00:04:41,669 --> 00:04:49,049
systems can get you really interesting

88
00:04:45,030 --> 00:04:50,609
capabilities and because your life and

89
00:04:49,050 --> 00:04:51,169
the life of your loved ones may depend

90
00:04:50,610 --> 00:04:54,030
on it

91
00:04:51,169 --> 00:04:57,690
PowerPC may become very interesting to

92
00:04:54,030 --> 00:04:59,299
you I know that it is for me so we need

93
00:04:57,690 --> 00:05:05,460
to be able to protect these systems

94
00:04:59,300 --> 00:05:07,110
because they're in your car typically in

95
00:05:05,460 --> 00:05:09,380
your brake controller I mean if you're

96
00:05:07,110 --> 00:05:11,820
gonna have something fail on your car

97
00:05:09,380 --> 00:05:12,810
probably not that one that's not my

98
00:05:11,820 --> 00:05:15,000
first race

99
00:05:12,810 --> 00:05:17,280
so it turns out a number a few years ago

100
00:05:15,000 --> 00:05:20,430
when Grimm first started doing

101
00:05:17,280 --> 00:05:22,888
professional automotive exploitation we

102
00:05:20,430 --> 00:05:25,290
were we were given a car and we had this

103
00:05:22,889 --> 00:05:29,220
hack a certain number of things in it

104
00:05:25,290 --> 00:05:31,200
and we figured out a whole bunch of

105
00:05:29,220 --> 00:05:33,180
stuff it was great we were able to pull

106
00:05:31,200 --> 00:05:36,719
down firmware for all the different

107
00:05:33,180 --> 00:05:38,880
things and we took the firmware and we

108
00:05:36,720 --> 00:05:46,530
were going okay this is arm

109
00:05:38,880 --> 00:05:47,219
this is renesis this is no idea not a

110
00:05:46,530 --> 00:05:49,500
clue

111
00:05:47,220 --> 00:05:50,760
and so we ended up rolling through

112
00:05:49,500 --> 00:05:54,479
different architectures and then

113
00:05:50,760 --> 00:05:56,490
disassembler going nope nope nope hey

114
00:05:54,479 --> 00:05:58,530
that has some instruction those are

115
00:05:56,490 --> 00:06:01,020
weird-ass instructions nope keep going

116
00:05:58,530 --> 00:06:03,330
keep going we failed in a two-week

117
00:06:01,020 --> 00:06:05,669
period that we limited ourselves while

118
00:06:03,330 --> 00:06:07,349
doing other things but we're like at the

119
00:06:05,669 --> 00:06:09,270
end of this we're gonna cut it and take

120
00:06:07,350 --> 00:06:12,030
this other route we ended up cutting and

121
00:06:09,270 --> 00:06:14,990
taking this other route only to figure

122
00:06:12,030 --> 00:06:20,099
out at the very end of the engagement

123
00:06:14,990 --> 00:06:22,979
the disassemblers have a bug the tooling

124
00:06:20,100 --> 00:06:27,240
that we were trying to use didn't make

125
00:06:22,979 --> 00:06:32,419
sense of the code because every one of

126
00:06:27,240 --> 00:06:35,340
them had a bug Ida had a bug obstinate a

127
00:06:32,419 --> 00:06:37,440
read re well let's not even go there

128
00:06:35,340 --> 00:06:40,950
and vivisected and support it which is

129
00:06:37,440 --> 00:06:45,600
my favorite so that got my brain

130
00:06:40,950 --> 00:06:48,450
spinning we didn't actually confirm it

131
00:06:45,600 --> 00:06:51,060
until one of my guys I think is here

132
00:06:48,450 --> 00:06:54,750
today Mitch Johnson he's no longer my

133
00:06:51,060 --> 00:06:58,200
guy he's an awesome dude he's like huh

134
00:06:54,750 --> 00:07:00,030
Bob's dumb has this thing where the

135
00:06:58,200 --> 00:07:02,639
particular type of encoding that this

136
00:07:00,030 --> 00:07:07,020
this firmware uses because that's what I

137
00:07:02,639 --> 00:07:09,930
think this chip should be it only turns

138
00:07:07,020 --> 00:07:12,870
on that it only enables that if it's

139
00:07:09,930 --> 00:07:15,750
loading an elf binary you guys know what

140
00:07:12,870 --> 00:07:18,240
an elf binary is right it's like it's

141
00:07:15,750 --> 00:07:21,990
the UNIX II way of storing binary

142
00:07:18,240 --> 00:07:25,690
executable code so if we had a raw image

143
00:07:21,990 --> 00:07:28,300
of firmware which is what we did nothing

144
00:07:25,690 --> 00:07:32,380
could not get option for Ida or anything

145
00:07:28,300 --> 00:07:33,670
else to disassemble it I don't know

146
00:07:32,380 --> 00:07:35,260
about you I don't know how you like to

147
00:07:33,670 --> 00:07:36,370
learn architectures but I like to learn

148
00:07:35,260 --> 00:07:39,010
architectures by writing and

149
00:07:36,370 --> 00:07:42,310
disassembler teaches me how the bits

150
00:07:39,010 --> 00:07:44,530
turn into assembly and teaches me really

151
00:07:42,310 --> 00:07:46,840
interesting things like hey these these

152
00:07:44,530 --> 00:07:49,119
four bytes look like this type of

153
00:07:46,840 --> 00:07:51,310
instruction and this bunch of things

154
00:07:49,120 --> 00:07:52,510
figures out that kind of looks like this

155
00:07:51,310 --> 00:07:54,370
architecture and believe it or not

156
00:07:52,510 --> 00:07:57,820
that's been very successful for me so

157
00:07:54,370 --> 00:07:59,980
far so some of the Grimm folks embarked

158
00:07:57,820 --> 00:08:02,080
on a journey to create a PowerPC

159
00:07:59,980 --> 00:08:04,450
disassembler for a vivisect why because

160
00:08:02,080 --> 00:08:06,340
I love data sent but we'll talk more

161
00:08:04,450 --> 00:08:10,479
about the reasons in a minute because it

162
00:08:06,340 --> 00:08:15,849
was a business decision so that was the

163
00:08:10,480 --> 00:08:18,340
light-duty ABS module we also found

164
00:08:15,850 --> 00:08:22,270
PowerPC on a very interesting heavy

165
00:08:18,340 --> 00:08:26,080
trucking ECM in a gig just for that one

166
00:08:22,270 --> 00:08:29,409
so turns out PowerPC is playing into my

167
00:08:26,080 --> 00:08:33,909
life on a virtually daily basis when I'm

168
00:08:29,410 --> 00:08:37,360
doing the fun stuff yes this is a this

169
00:08:33,909 --> 00:08:40,240
is a 72 Datsun 240z there's not an ounce

170
00:08:37,360 --> 00:08:44,560
of PowerPC in there because it's not got

171
00:08:40,240 --> 00:08:46,360
a computer I did that because well I

172
00:08:44,560 --> 00:08:48,010
work with these car companies and I

173
00:08:46,360 --> 00:08:50,170
didn't want to out anybody or make

174
00:08:48,010 --> 00:08:52,020
anybody uncomfortable done that it's

175
00:08:50,170 --> 00:08:56,319
caused lawsuits not a good thing

176
00:08:52,020 --> 00:09:00,579
PowerPC is some crazy shit so back in

177
00:08:56,320 --> 00:09:04,810
the day back in the 90s Apple IBM and

178
00:09:00,580 --> 00:09:09,040
Motorola forms the aim collaboration or

179
00:09:04,810 --> 00:09:13,089
the the aim project where aim Apple IBM

180
00:09:09,040 --> 00:09:14,589
Motorola they're like you know those

181
00:09:13,090 --> 00:09:19,600
wind tell guys they're getting pretty

182
00:09:14,590 --> 00:09:21,130
tight and it's limited to 32 bits when

183
00:09:19,600 --> 00:09:22,960
we really want to have a 64-bit

184
00:09:21,130 --> 00:09:25,270
architecture let's go make the next

185
00:09:22,960 --> 00:09:27,340
killer architecture and it'll take over

186
00:09:25,270 --> 00:09:29,500
we'll have Windows and T work on it will

187
00:09:27,340 --> 00:09:34,540
have os/2 work on it yes this is back

188
00:09:29,500 --> 00:09:36,960
then so they created this architecture

189
00:09:34,540 --> 00:09:38,670
based on the IBM

190
00:09:36,960 --> 00:09:41,190
mini computer architecture which

191
00:09:38,670 --> 00:09:46,319
supposedly is so much better than the

192
00:09:41,190 --> 00:09:50,340
Intel microcomputers it's been around

193
00:09:46,320 --> 00:09:50,820
for 27 years a few a few tidbits about

194
00:09:50,340 --> 00:09:55,130
it

195
00:09:50,820 --> 00:09:58,590
it's a 32-bit fixed instruction set

196
00:09:55,130 --> 00:10:01,439
what's that mean it means every

197
00:09:58,590 --> 00:10:03,300
instruction is 4 bytes long as opposed

198
00:10:01,440 --> 00:10:06,750
to Intel where it could be one byte all

199
00:10:03,300 --> 00:10:08,729
the way up to 15 bytes in length or they

200
00:10:06,750 --> 00:10:12,660
could be actually making it bigger as we

201
00:10:08,730 --> 00:10:16,140
speak so 32-bit fixed size instruction

202
00:10:12,660 --> 00:10:19,650
set except they added in this nifty

203
00:10:16,140 --> 00:10:23,220
little thing called VLE variable length

204
00:10:19,650 --> 00:10:25,680
encoding anybody heard of arm thumb ARM

205
00:10:23,220 --> 00:10:28,410
architecture just stick them up if

206
00:10:25,680 --> 00:10:31,859
you're heard of arm all right good how

207
00:10:28,410 --> 00:10:35,370
many of you can understand why they

208
00:10:31,860 --> 00:10:41,120
invented thumb aside from causing pain

209
00:10:35,370 --> 00:10:43,530
to reverse engineers what's that power

210
00:10:41,120 --> 00:10:47,940
close you're getting there give me

211
00:10:43,530 --> 00:10:49,620
something code density cheap is the word

212
00:10:47,940 --> 00:10:52,250
extra I was looking for code density

213
00:10:49,620 --> 00:10:56,490
means cheap on little embedded II things

214
00:10:52,250 --> 00:11:00,570
you can fit a reduced instruction set

215
00:10:56,490 --> 00:11:02,550
thing to make a smaller piece of code so

216
00:11:00,570 --> 00:11:03,960
you can buy a smaller flash chip or

217
00:11:02,550 --> 00:11:09,510
EEPROM okay

218
00:11:03,960 --> 00:11:12,500
the reason they create a thumb VLE is

219
00:11:09,510 --> 00:11:15,300
basically PowerPC dispersion of thumb

220
00:11:12,500 --> 00:11:17,580
variable length encoding says we're

221
00:11:15,300 --> 00:11:19,439
gonna keep a bunch of a bunch of 32-bit

222
00:11:17,580 --> 00:11:22,380
instructions because we kind of gotta

223
00:11:19,440 --> 00:11:24,180
and we're gonna make a whole bunch of

224
00:11:22,380 --> 00:11:28,500
16-bit instructions so that we can have

225
00:11:24,180 --> 00:11:31,349
code density the architecture that we

226
00:11:28,500 --> 00:11:35,190
were looking at for the ABS module was

227
00:11:31,350 --> 00:11:38,640
running pure VLE from the get-go so like

228
00:11:35,190 --> 00:11:40,860
everything was a either a 16 or a 32-bit

229
00:11:38,640 --> 00:11:42,630
instruction and it caused all of our

230
00:11:40,860 --> 00:11:46,980
disassemblers to take a shit

231
00:11:42,630 --> 00:11:49,120
it is big endian there are a number of

232
00:11:46,980 --> 00:11:52,089
add-on modules that can

233
00:11:49,120 --> 00:11:55,750
you a bunch of specialized registers but

234
00:11:52,089 --> 00:11:59,980
generally speaking PowerPC has 32 bit or

235
00:11:55,750 --> 00:12:03,610
32 general-purpose registers like in

236
00:11:59,980 --> 00:12:05,200
Intel we you know we've got re x and r

237
00:12:03,610 --> 00:12:08,830
bx and RCX

238
00:12:05,200 --> 00:12:11,410
okay there's like 16 of them this one

239
00:12:08,830 --> 00:12:13,620
has 32 and then 32 floating-point

240
00:12:11,410 --> 00:12:16,930
registers as well

241
00:12:13,620 --> 00:12:21,430
one interesting tidbit that I found I

242
00:12:16,930 --> 00:12:24,219
didn't realize right away said most

243
00:12:21,430 --> 00:12:27,239
chips for power PC because PowerPC was

244
00:12:24,220 --> 00:12:30,100
supposed to be a full-blown like

245
00:12:27,240 --> 00:12:36,040
supercomputer type machine and a desktop

246
00:12:30,100 --> 00:12:39,339
and a server so they have a buddhist

247
00:12:36,040 --> 00:12:42,360
module that looks through and different

248
00:12:39,339 --> 00:12:47,650
Lodger different physical addresses of

249
00:12:42,360 --> 00:12:50,560
firmware or disk to look for a

250
00:12:47,650 --> 00:12:52,089
particular sequence of bytes and if it

251
00:12:50,560 --> 00:12:55,239
finds those particular sequence of bytes

252
00:12:52,089 --> 00:12:58,170
it starts executing code from a pointer

253
00:12:55,240 --> 00:13:01,330
that follows those bytes so intro to

254
00:12:58,170 --> 00:13:03,069
reverse engineering PowerPC you're very

255
00:13:01,330 --> 00:13:07,470
welcome you can send checks to them just

256
00:13:03,070 --> 00:13:10,720
kidding oh and those sequence of bytes

257
00:13:07,470 --> 00:13:13,089
it's called an RC HW if you ever see

258
00:13:10,720 --> 00:13:17,620
arch our CHW you don't just know hey

259
00:13:13,089 --> 00:13:21,910
that is a reset config word I just made

260
00:13:17,620 --> 00:13:23,080
your life that much better ok dig in

261
00:13:21,910 --> 00:13:25,209
trying to figure out how this thing

262
00:13:23,080 --> 00:13:26,529
works now I've done a lot of

263
00:13:25,209 --> 00:13:28,779
architecture reverse engineering

264
00:13:26,529 --> 00:13:31,959
particularly on an embedded system so

265
00:13:28,779 --> 00:13:34,990
the idea of layered documentation is not

266
00:13:31,959 --> 00:13:37,599
new to me so we dig in oK we've got this

267
00:13:34,990 --> 00:13:40,209
ear F what the hell is an ear F I have

268
00:13:37,600 --> 00:13:41,350
no idea but I know that it is important

269
00:13:40,209 --> 00:13:43,959
for the code that I'm looking at some

270
00:13:41,350 --> 00:13:46,510
I'm reading it reading it oh I then run

271
00:13:43,959 --> 00:13:50,079
into a power is a an instruction set

272
00:13:46,510 --> 00:13:53,680
architecture reference manual okay

273
00:13:50,080 --> 00:13:59,430
interesting oh oh then we've got this

274
00:13:53,680 --> 00:14:01,640
altivec pimp em pimp what and envy you

275
00:13:59,430 --> 00:14:04,550
come on

276
00:14:01,640 --> 00:14:09,140
the easy button turns out there really

277
00:14:04,550 --> 00:14:11,209
isn't an easy button because oh and then

278
00:14:09,140 --> 00:14:15,260
we've got these implementations of chips

279
00:14:11,209 --> 00:14:20,540
documentation but it turns out because

280
00:14:15,260 --> 00:14:25,550
of the aim alliance as they named

281
00:14:20,540 --> 00:14:30,310
themselves realizing oh shit wind tells

282
00:14:25,550 --> 00:14:33,589
not going away we can't win this war

283
00:14:30,310 --> 00:14:34,849
they kind of panicked and all wet and

284
00:14:33,589 --> 00:14:37,040
did their own thing because they all

285
00:14:34,850 --> 00:14:39,980
owns the intellectual property might as

286
00:14:37,040 --> 00:14:42,589
well make use of it riot try to recoup

287
00:14:39,980 --> 00:14:46,519
some of our investment so IBM continued

288
00:14:42,589 --> 00:14:50,320
to make their now the p-series probably

289
00:14:46,519 --> 00:14:52,160
change names again since I look that up

290
00:14:50,320 --> 00:14:54,500
Apple did there

291
00:14:52,160 --> 00:14:57,589
you've heard of g3 and their g4 and

292
00:14:54,500 --> 00:15:01,220
their g5 processors back just before

293
00:14:57,589 --> 00:15:04,390
they switch to BSD on Intel that was all

294
00:15:01,220 --> 00:15:09,320
their PowerPC stuff down the desktop and

295
00:15:04,390 --> 00:15:11,380
of course Motorola what do they do well

296
00:15:09,320 --> 00:15:13,370
they're an embedded chip company right

297
00:15:11,380 --> 00:15:15,680
well they do a bunch of more than that

298
00:15:13,370 --> 00:15:20,060
they spun off their embedded stuff and

299
00:15:15,680 --> 00:15:26,239
sold it to an XP + XP still running and

300
00:15:20,060 --> 00:15:28,880
selling PowerPC chips to ECU

301
00:15:26,240 --> 00:15:34,399
manufacturers for automotive and heavy

302
00:15:28,880 --> 00:15:37,070
truck embedded systems for aerospace all

303
00:15:34,399 --> 00:15:38,029
of the stuff that I said early on the

304
00:15:37,070 --> 00:15:41,690
stuff that can kill you

305
00:15:38,029 --> 00:15:42,740
and XP is selling those chips like

306
00:15:41,690 --> 00:15:50,089
they're going out of style you just

307
00:15:42,740 --> 00:15:51,500
never see it the problem is Apple wants

308
00:15:50,089 --> 00:15:53,779
to do their thing because Apple is the

309
00:15:51,500 --> 00:15:57,190
easy button of computing right hey I

310
00:15:53,779 --> 00:16:01,370
need it to be easy fast and beautiful

311
00:15:57,190 --> 00:16:05,660
well IBM's like this has got to be the

312
00:16:01,370 --> 00:16:10,630
next mainframe killer thingy and NXP is

313
00:16:05,660 --> 00:16:10,630
going better not draw over 2 amps

314
00:16:11,050 --> 00:16:15,560
so they had very different directions

315
00:16:13,790 --> 00:16:17,420
that they're taking and as you might

316
00:16:15,560 --> 00:16:21,649
expect when they're not working together

317
00:16:17,420 --> 00:16:25,790
they do their own thing in recent years

318
00:16:21,649 --> 00:16:28,759
in the you mid odds in the early 2000s

319
00:16:25,790 --> 00:16:31,250
to mid 2000s we see them coming together

320
00:16:28,759 --> 00:16:32,899
in putting together a unified

321
00:16:31,250 --> 00:16:36,079
documentation called the power

322
00:16:32,899 --> 00:16:40,880
eisah with an open source community

323
00:16:36,079 --> 00:16:44,630
called power org or nonprofit dump our

324
00:16:40,880 --> 00:16:47,630
org and then they're finding out oh shit

325
00:16:44,630 --> 00:16:49,519
I wish we wouldn't have done that I wish

326
00:16:47,630 --> 00:16:52,660
you wouldn't have done that so they're

327
00:16:49,519 --> 00:16:52,660
trying to merge these things together

328
00:16:53,079 --> 00:17:00,888
but in 2013 we ended up with something

329
00:16:56,269 --> 00:17:02,389
somewhat cohesive and in 2017 we we came

330
00:17:00,889 --> 00:17:03,680
out with the power ice of Version three

331
00:17:02,389 --> 00:17:05,990
all right

332
00:17:03,680 --> 00:17:07,520
history lesson over sorry to dwell so

333
00:17:05,990 --> 00:17:12,049
much it caused me so much pain I just

334
00:17:07,520 --> 00:17:14,539
needed to share the pain why why did we

335
00:17:12,049 --> 00:17:17,089
build this for vivisect why not deidre

336
00:17:14,539 --> 00:17:21,079
Ida or whatever

337
00:17:17,089 --> 00:17:24,530
hopper first of all they're the sex what

338
00:17:21,079 --> 00:17:27,619
is it a sect it's a very powerful binary

339
00:17:24,530 --> 00:17:33,740
analysis framework focus specifically on

340
00:17:27,619 --> 00:17:35,809
bug hunting let's go on some O'Day is it

341
00:17:33,740 --> 00:17:40,940
has lightweight or heavy weight

342
00:17:35,809 --> 00:17:44,240
emulation capabilities built-in as well

343
00:17:40,940 --> 00:17:47,809
as a symbolic emulation engine anybody

344
00:17:44,240 --> 00:17:50,600
heard of symbolic analysis okay stick

345
00:17:47,809 --> 00:17:53,620
them away hi you can you can own it loud

346
00:17:50,600 --> 00:17:55,240
and proud okay about a thirtieth of you

347
00:17:53,620 --> 00:17:59,658
that's fine

348
00:17:55,240 --> 00:18:04,190
symbolic analysis is where you take code

349
00:17:59,659 --> 00:18:09,440
and you translate each instruction into

350
00:18:04,190 --> 00:18:10,850
its symbolic effects and then one thing

351
00:18:09,440 --> 00:18:14,210
that's special about vivisect

352
00:18:10,850 --> 00:18:18,770
is that you run those effects through a

353
00:18:14,210 --> 00:18:22,640
symbolic emulator and it extrudes the

354
00:18:18,770 --> 00:18:23,480
state of the system in a very trackable

355
00:18:22,640 --> 00:18:26,240
way

356
00:18:23,480 --> 00:18:29,860
through an entire code ban code path why

357
00:18:26,240 --> 00:18:32,030
do we care who whatever you know nerd

358
00:18:29,860 --> 00:18:37,129
because I like to write code that

359
00:18:32,030 --> 00:18:41,180
answers questions about code symbolic

360
00:18:37,130 --> 00:18:44,470
analysis and emulation together provide

361
00:18:41,180 --> 00:18:48,890
a very very powerful but a platform for

362
00:18:44,470 --> 00:18:51,020
finding no shit zero to a collaboration

363
00:18:48,890 --> 00:18:52,910
server built-in powerful graph library

364
00:18:51,020 --> 00:18:56,690
if you forgetting this symbolic analysis

365
00:18:52,910 --> 00:18:59,720
you'll find graph theory is a lovely

366
00:18:56,690 --> 00:19:02,090
thing it is open source it runs

367
00:18:59,720 --> 00:19:04,940
virtually pure Python except where it

368
00:19:02,090 --> 00:19:06,290
hooks into the OS to to do debugging but

369
00:19:04,940 --> 00:19:08,570
of course you know you can't do pure

370
00:19:06,290 --> 00:19:10,670
Python and debugging doesn't work and

371
00:19:08,570 --> 00:19:13,760
it's easily extended because it's pure

372
00:19:10,670 --> 00:19:15,680
Python the in it's open source you look

373
00:19:13,760 --> 00:19:17,320
through read the code changed whatever

374
00:19:15,680 --> 00:19:19,580
you want

375
00:19:17,320 --> 00:19:22,480
he's got wrapped into it something

376
00:19:19,580 --> 00:19:26,449
called VB a vulnerability debugger again

377
00:19:22,480 --> 00:19:30,830
debugging system focused on finding

378
00:19:26,450 --> 00:19:36,860
vulnerabilities anybody heard of the apt

379
00:19:30,830 --> 00:19:39,439
one report really the mandiant HPT one

380
00:19:36,860 --> 00:19:41,990
report may have something that long okay

381
00:19:39,440 --> 00:19:45,170
it was the report that told the world in

382
00:19:41,990 --> 00:19:46,970
no uncertain terms with proof that China

383
00:19:45,170 --> 00:19:48,950
has been stealing intellectual property

384
00:19:46,970 --> 00:20:03,260
from the u.s. to the tune of ten million

385
00:19:48,950 --> 00:20:05,450
a day not many people got it okay that

386
00:20:03,260 --> 00:20:09,110
makes sense to me it was pretty epic

387
00:20:05,450 --> 00:20:13,460
because we had all assumed that it was

388
00:20:09,110 --> 00:20:16,840
working that way but really I'm my worst

389
00:20:13,460 --> 00:20:22,749
person here I need to shut off my phone

390
00:20:16,840 --> 00:20:25,059
I have thrown my phone against well so

391
00:20:22,749 --> 00:20:27,460
yes this report basically made it so

392
00:20:25,059 --> 00:20:29,999
that congressman had leverage to say

393
00:20:27,460 --> 00:20:32,169
that's not okay

394
00:20:29,999 --> 00:20:33,990
before that we just can all said yeah

395
00:20:32,169 --> 00:20:38,019
they're doing it and we all know it so

396
00:20:33,990 --> 00:20:41,169
the apt one report was based on an

397
00:20:38,019 --> 00:20:43,259
intelligence gathering and manipulation

398
00:20:41,169 --> 00:20:49,419
system not manipulation that's on span

399
00:20:43,259 --> 00:20:51,690
intelligence digesting system the

400
00:20:49,419 --> 00:20:53,919
interface actually was called Jarvis and

401
00:20:51,690 --> 00:20:58,330
when you logged in and said good morning

402
00:20:53,919 --> 00:21:00,850
mister start anyway it was based on a

403
00:20:58,330 --> 00:21:01,090
whole bunch of code vivisect was part of

404
00:21:00,850 --> 00:21:03,759
it

405
00:21:01,090 --> 00:21:06,939
so they streamed all the things off of

406
00:21:03,759 --> 00:21:09,460
the internet they parsed them and did a

407
00:21:06,940 --> 00:21:12,789
lot of binary analysis into the sect was

408
00:21:09,460 --> 00:21:15,789
at the core there again the main reason

409
00:21:12,789 --> 00:21:17,279
is cuz I love it and that's enough but I

410
00:21:15,789 --> 00:21:19,389
thought I'd give you the other stuff

411
00:21:17,279 --> 00:21:23,259
with a service sector built and

412
00:21:19,389 --> 00:21:26,619
maintained bug hunting tools Rob gadget

413
00:21:23,259 --> 00:21:32,350
finders and auto generators for a chain

414
00:21:26,619 --> 00:21:34,209
and other behavioral analysis modules so

415
00:21:32,350 --> 00:21:36,399
how do you start writing and

416
00:21:34,210 --> 00:21:38,200
disassembler in python we won't even get

417
00:21:36,399 --> 00:21:40,799
into why again because i love it and

418
00:21:38,200 --> 00:21:43,450
python it just makes me happy

419
00:21:40,799 --> 00:21:46,480
turns out writing at this assembler it's

420
00:21:43,450 --> 00:21:49,480
not really that difficult it is entirely

421
00:21:46,480 --> 00:21:53,409
too tedious and time-consuming for me to

422
00:21:49,480 --> 00:21:55,539
convey to you but it's surprising how

423
00:21:53,409 --> 00:22:02,679
quickly you can come up with something

424
00:21:55,539 --> 00:22:04,749
of real value it is also error-prone so

425
00:22:02,679 --> 00:22:07,110
lots of testing and unit testing come

426
00:22:04,749 --> 00:22:07,110
into play

427
00:22:09,840 --> 00:22:17,470
so writing a disassembler by scraping

428
00:22:13,470 --> 00:22:19,210
documentation however gets rid of a lot

429
00:22:17,470 --> 00:22:21,820
of the tedium at least from the

430
00:22:19,210 --> 00:22:25,690
disassembler print perspective so what I

431
00:22:21,820 --> 00:22:28,720
did was I took the EF doc manual and

432
00:22:25,690 --> 00:22:31,300
they've got several different tables of

433
00:22:28,720 --> 00:22:37,270
how bits decode into instructions with

434
00:22:31,300 --> 00:22:42,300
fields and whatever in ASCII and I

435
00:22:37,270 --> 00:22:46,020
scraped out one of the tables and wrote

436
00:22:42,300 --> 00:22:49,629
parsing code for that copy and paste

437
00:22:46,020 --> 00:22:51,940
sounds horrible it's really ugly shit

438
00:22:49,630 --> 00:22:53,770
I'm sorry it is but it was really

439
00:22:51,940 --> 00:22:56,380
powerful and save me a ton of headache

440
00:22:53,770 --> 00:22:58,780
even had I put in the same amount of

441
00:22:56,380 --> 00:23:01,240
effort that I would have put in by

442
00:22:58,780 --> 00:23:02,920
writing all the tables a it's less

443
00:23:01,240 --> 00:23:05,940
error-prone because I wrote it

444
00:23:02,920 --> 00:23:08,410
specifically against their data and B I

445
00:23:05,940 --> 00:23:10,060
felt a lot less drained at the end

446
00:23:08,410 --> 00:23:15,190
because I got to write logical code

447
00:23:10,060 --> 00:23:16,929
instead of tedium so once we write we

448
00:23:15,190 --> 00:23:20,620
end up spitting out tables that we can

449
00:23:16,930 --> 00:23:23,980
look up and do cool stuff with we write

450
00:23:20,620 --> 00:23:26,409
some supporting code including a dis

451
00:23:23,980 --> 00:23:29,340
azzam function that says give me some

452
00:23:26,410 --> 00:23:30,760
bikes and I'll do something with them a

453
00:23:29,340 --> 00:23:33,159
PowerPC

454
00:23:30,760 --> 00:23:35,800
opcode object it's a Python thing right

455
00:23:33,160 --> 00:23:38,400
so we create a Python object that stores

456
00:23:35,800 --> 00:23:42,700
all the things about the opcode itself

457
00:23:38,400 --> 00:23:44,260
including a list of operands and

458
00:23:42,700 --> 00:23:48,160
operating anybody written an assembly

459
00:23:44,260 --> 00:23:49,060
language all right good like 50 or more

460
00:23:48,160 --> 00:23:52,480
that's wonderful

461
00:23:49,060 --> 00:23:55,600
so in assembly language you have the

462
00:23:52,480 --> 00:23:57,340
mnemonic the word that tells you what it

463
00:23:55,600 --> 00:24:00,879
is like a move and then you have a

464
00:23:57,340 --> 00:24:03,370
couple comma delimited operands so move

465
00:24:00,880 --> 00:24:06,100
from this thing to that thing

466
00:24:03,370 --> 00:24:09,340
these things are called operands so we

467
00:24:06,100 --> 00:24:12,370
start writing operand objects and then

468
00:24:09,340 --> 00:24:14,379
the opcode object and it just mirrors

469
00:24:12,370 --> 00:24:20,639
what the PowerPC needs and it stores

470
00:24:14,380 --> 00:24:21,940
whatever it is so because I wrote a tool

471
00:24:20,640 --> 00:24:25,100
that

472
00:24:21,940 --> 00:24:28,550
parse out a bunch of junk this is what I

473
00:24:25,100 --> 00:24:32,689
copied and pasted and it's the beauty of

474
00:24:28,550 --> 00:24:33,770
Python this variable equals three three

475
00:24:32,690 --> 00:24:35,030
tick marks and then like just

476
00:24:33,770 --> 00:24:37,190
gobbledygook

477
00:24:35,030 --> 00:24:39,590
for forever and then three more tick

478
00:24:37,190 --> 00:24:42,260
marks to end the string and then I parse

479
00:24:39,590 --> 00:24:44,389
it out and here's the parsing code parse

480
00:24:42,260 --> 00:24:46,040
this stuff out okay blah blah blah blah

481
00:24:44,390 --> 00:24:48,440
just you know break it up into new lines

482
00:24:46,040 --> 00:24:50,000
and and whatnot and look for these

483
00:24:48,440 --> 00:24:55,460
things because this means I'm on to

484
00:24:50,000 --> 00:24:59,480
another instruction blah blah blah can

485
00:24:55,460 --> 00:25:01,960
be ugly but super powerful and to date I

486
00:24:59,480 --> 00:25:04,640
have not modified those tables by hand

487
00:25:01,960 --> 00:25:07,850
when it found a bug and yes there are

488
00:25:04,640 --> 00:25:09,980
bugs in the documentation too I'll go in

489
00:25:07,850 --> 00:25:12,320
and I'll fix the bug in the scraped

490
00:25:09,980 --> 00:25:14,570
portion and regenerate because I'm not

491
00:25:12,320 --> 00:25:20,600
ready to let go of that safety balloon

492
00:25:14,570 --> 00:25:23,059
just yet but it can take a lot of stuff

493
00:25:20,600 --> 00:25:25,790
and a lot of code this is not a lot of

494
00:25:23,059 --> 00:25:29,149
code actually I am a lot of slides I

495
00:25:25,790 --> 00:25:31,700
suppose to describe it and a piece of

496
00:25:29,150 --> 00:25:33,110
the table so we break it down into

497
00:25:31,700 --> 00:25:36,020
little sub components so that we can

498
00:25:33,110 --> 00:25:37,760
easily search quickly instead of what

499
00:25:36,020 --> 00:25:41,540
you never want to do when you're writing

500
00:25:37,760 --> 00:25:44,059
fast code is put in a list of everything

501
00:25:41,540 --> 00:25:46,490
that you have to hunt through from the

502
00:25:44,059 --> 00:25:48,379
beginning even if it's the last thing in

503
00:25:46,490 --> 00:25:50,450
your list that you want to get to so a

504
00:25:48,380 --> 00:25:52,520
nice dictionary lookup with the

505
00:25:50,450 --> 00:25:54,290
different segments breaking it down into

506
00:25:52,520 --> 00:25:56,510
a bunch of tables that you then scroll

507
00:25:54,290 --> 00:25:58,580
through very quickly and when you're

508
00:25:56,510 --> 00:26:01,100
doing disassembly you need to write the

509
00:25:58,580 --> 00:26:03,678
code you need to write the code such

510
00:26:01,100 --> 00:26:09,290
that it could run millions of times and

511
00:26:03,679 --> 00:26:12,140
not really caused you pain all right so

512
00:26:09,290 --> 00:26:14,928
our operand class is here here's an

513
00:26:12,140 --> 00:26:19,880
example of an assembly instruction move

514
00:26:14,929 --> 00:26:24,530
register r7 into r4 whatever was in our

515
00:26:19,880 --> 00:26:27,020
7 put it into r4 the register r4 cool so

516
00:26:24,530 --> 00:26:29,750
we store all the information about the

517
00:26:27,020 --> 00:26:30,610
mr and any other special flags that

518
00:26:29,750 --> 00:26:35,350
might happen

519
00:26:30,610 --> 00:26:37,629
in the opcode and then we store the

520
00:26:35,350 --> 00:26:41,350
information about each operand into an

521
00:26:37,630 --> 00:26:44,470
operand object the operand object

522
00:26:41,350 --> 00:26:46,959
because there are probably about fifteen

523
00:26:44,470 --> 00:26:49,720
or twenty operon objects that amusing it

524
00:26:46,960 --> 00:26:52,419
knows how to render itself so if it's a

525
00:26:49,720 --> 00:26:54,279
number five does that mean it's binary

526
00:26:52,419 --> 00:26:56,710
it's got to be one zero one would that

527
00:26:54,279 --> 00:26:58,960
be the number five would it be zero X 5

528
00:26:56,710 --> 00:27:02,710
what makes sense and the operand object

529
00:26:58,960 --> 00:27:05,679
knows that just by context it also the

530
00:27:02,710 --> 00:27:09,789
operating object knows how to get stuff

531
00:27:05,679 --> 00:27:12,120
from that operand and to write stuff to

532
00:27:09,789 --> 00:27:15,789
that operand so it's if it's a register

533
00:27:12,120 --> 00:27:17,289
it says oh grab the registers of data in

534
00:27:15,789 --> 00:27:23,019
this register that we're storing and

535
00:27:17,289 --> 00:27:24,639
when we're writing to it put it back so

536
00:27:23,019 --> 00:27:28,330
we've got some examples of operand

537
00:27:24,639 --> 00:27:29,949
classes including storing evaluating

538
00:27:28,330 --> 00:27:33,279
equality normalizing getting the data

539
00:27:29,950 --> 00:27:35,700
get upper value the thing that's in the

540
00:27:33,279 --> 00:27:38,679
in the register or hey if we're

541
00:27:35,700 --> 00:27:40,120
dereferencing memory the thing that

542
00:27:38,679 --> 00:27:44,620
actually goes and grabs the thing out of

543
00:27:40,120 --> 00:27:48,340
memory set opera value same thing the

544
00:27:44,620 --> 00:27:49,629
thing that puts the data into memory get

545
00:27:48,340 --> 00:27:52,269
upper adder ooh

546
00:27:49,630 --> 00:27:53,559
so if it's registers it's just as none

547
00:27:52,269 --> 00:27:55,840
there's there's no address because it's

548
00:27:53,559 --> 00:27:58,029
register but if it is a memory location

549
00:27:55,840 --> 00:28:00,490
get operator points - it actually

550
00:27:58,029 --> 00:28:04,029
returns the location in memory instead

551
00:28:00,490 --> 00:28:05,590
of the data value there we have a render

552
00:28:04,029 --> 00:28:07,779
object which is like the pretty thing

553
00:28:05,590 --> 00:28:09,789
for all the gooey math magic and then we

554
00:28:07,779 --> 00:28:13,000
have a wrapper I'm sorry I rep or

555
00:28:09,789 --> 00:28:16,269
function not object that prints it out

556
00:28:13,000 --> 00:28:18,190
if I just say print and I do a lot of

557
00:28:16,269 --> 00:28:20,470
interactive disassembly an interactive

558
00:28:18,190 --> 00:28:27,340
Python so the print stuff is important

559
00:28:20,470 --> 00:28:32,080
to me enter the unit tests ok this is

560
00:28:27,340 --> 00:28:34,449
where you all groan oh unit tests are

561
00:28:32,080 --> 00:28:36,010
fun unit tests are your friends really

562
00:28:34,450 --> 00:28:37,720
I'm selling you something

563
00:28:36,010 --> 00:28:39,399
turns out unit tests kind of suck

564
00:28:37,720 --> 00:28:40,760
they're a little tedious anybody tells

565
00:28:39,399 --> 00:28:42,590
the otherwise they

566
00:28:40,760 --> 00:28:46,490
either on a better drug than you or

567
00:28:42,590 --> 00:28:51,980
they're full of shit but the alternative

568
00:28:46,490 --> 00:28:53,090
is much worse unit tests it's hard

569
00:28:51,980 --> 00:28:56,720
enough to write the thing right in the

570
00:28:53,090 --> 00:28:59,810
first place it's harder to maintain it

571
00:28:56,720 --> 00:29:02,090
and fix all the bugs because you will

572
00:28:59,810 --> 00:29:04,010
write bugs you interpret the

573
00:29:02,090 --> 00:29:07,610
documentation wrong which is even worse

574
00:29:04,010 --> 00:29:10,640
like typos or one thing but I had no

575
00:29:07,610 --> 00:29:13,610
idea that's actually what that meant and

576
00:29:10,640 --> 00:29:14,930
as you maintain the project you'll break

577
00:29:13,610 --> 00:29:17,719
shit that you didn't mean to and you

578
00:29:14,930 --> 00:29:19,340
don't even know it so unit tests are

579
00:29:17,720 --> 00:29:24,290
worth it even a hacker has to accept

580
00:29:19,340 --> 00:29:26,810
that so entered my good friend Aaron

581
00:29:24,290 --> 00:29:31,600
Cornelius who hopefully he's here today

582
00:29:26,810 --> 00:29:34,159
but if not give him hell because he

583
00:29:31,600 --> 00:29:35,929
agreed on his own time like not work

584
00:29:34,160 --> 00:29:39,440
time he agreed on his own time to help

585
00:29:35,930 --> 00:29:41,990
me out with this project and he knows a

586
00:29:39,440 --> 00:29:46,010
lot more PowerPC than I do but I will

587
00:29:41,990 --> 00:29:48,170
say I wrote the disassembler he wrote it

588
00:29:46,010 --> 00:29:50,270
like an entire disassembler to write

589
00:29:48,170 --> 00:29:53,120
unit tests I have no idea what the hell

590
00:29:50,270 --> 00:29:55,760
that man thinks but I love him for it

591
00:29:53,120 --> 00:29:58,040
because it's like it was like he wrote

592
00:29:55,760 --> 00:29:59,690
an operating system I'd say hey you know

593
00:29:58,040 --> 00:30:02,810
this unit test is weird here is like oh

594
00:29:59,690 --> 00:30:07,370
wait a second and he like changes his

595
00:30:02,810 --> 00:30:09,950
generation module and then recompiles is

596
00:30:07,370 --> 00:30:11,600
that your code for urine test is more

597
00:30:09,950 --> 00:30:14,390
complex than my code to actually do the

598
00:30:11,600 --> 00:30:14,689
thing it's like that's the way it should

599
00:30:14,390 --> 00:30:17,330
be

600
00:30:14,690 --> 00:30:21,080
Thank You Aaron I very much appreciate

601
00:30:17,330 --> 00:30:23,750
it so we we started off with a bunch of

602
00:30:21,080 --> 00:30:27,320
code from other disassemblies like ida a

603
00:30:23,750 --> 00:30:28,490
knobs jump and we parse them out we

604
00:30:27,320 --> 00:30:30,470
normalize them

605
00:30:28,490 --> 00:30:34,010
that's what Aaron did and then spit them

606
00:30:30,470 --> 00:30:37,340
out into unit tests and we found bugs in

607
00:30:34,010 --> 00:30:40,280
there disassemblies as well spirit but

608
00:30:37,340 --> 00:30:42,230
it's always very fun to start using

609
00:30:40,280 --> 00:30:44,270
other tools to test your tools because

610
00:30:42,230 --> 00:30:48,050
when they differ don't don't assume that

611
00:30:44,270 --> 00:30:51,889
your tools in error go back to the

612
00:30:48,050 --> 00:30:54,490
documentation if the docs favor you they

613
00:30:51,890 --> 00:30:54,490
have got a bug

614
00:30:54,620 --> 00:30:59,479
and then we rewrote some emulation tests

615
00:30:57,470 --> 00:31:01,789
we're still writing emulation tests so

616
00:30:59,480 --> 00:31:06,799
there's no real easy way to make that

617
00:31:01,789 --> 00:31:11,500
happen automatically so who in their

618
00:31:06,799 --> 00:31:16,279
right mind writes an emulator in Python

619
00:31:11,500 --> 00:31:17,870
yes we gotta talk so I don't know how

620
00:31:16,279 --> 00:31:19,669
many of you were in my talk last year

621
00:31:17,870 --> 00:31:21,678
probably most of you went away cuz they

622
00:31:19,669 --> 00:31:25,010
realize the catastrophe that that was

623
00:31:21,679 --> 00:31:26,779
but I wrote an emulation an emulator for

624
00:31:25,010 --> 00:31:29,149
arm and then I described it for the

625
00:31:26,779 --> 00:31:32,450
first 15 minutes without slides because

626
00:31:29,149 --> 00:31:40,820
we had technical difficulties emulation

627
00:31:32,450 --> 00:31:45,640
in Python it's mind boggling but it's

628
00:31:40,820 --> 00:31:48,860
easy you set up fake memory you set up

629
00:31:45,640 --> 00:31:51,970
fake processor like things with

630
00:31:48,860 --> 00:31:56,360
registers and and you write code that

631
00:31:51,970 --> 00:31:58,580
executes or emulates what the Machine

632
00:31:56,360 --> 00:32:01,699
would do to the fake memory and the fake

633
00:31:58,580 --> 00:32:03,770
registers CPU stay stuff it's actually

634
00:32:01,700 --> 00:32:05,179
pretty straightforward I was floored at

635
00:32:03,770 --> 00:32:09,649
how straightforward it was which is why

636
00:32:05,179 --> 00:32:13,940
I still love to do it again why would we

637
00:32:09,649 --> 00:32:16,070
do it because with an emulator a

638
00:32:13,940 --> 00:32:18,620
lightweight emulator you can answer

639
00:32:16,070 --> 00:32:21,980
questions about code very quickly and

640
00:32:18,620 --> 00:32:25,010
easily differently than from symbolic

641
00:32:21,980 --> 00:32:27,919
analysis but equally as powerful and

642
00:32:25,010 --> 00:32:30,529
combined as the best and you can

643
00:32:27,919 --> 00:32:32,450
visually watch your code so a lot of em

644
00:32:30,529 --> 00:32:34,390
embedded systems don't give me debug

645
00:32:32,450 --> 00:32:36,770
access or I have to go buy addy

646
00:32:34,390 --> 00:32:38,090
developers kid that might be close

647
00:32:36,770 --> 00:32:40,100
enough to the chip that I'm hacking

648
00:32:38,090 --> 00:32:42,039
there for whatever if I can throw the

649
00:32:40,100 --> 00:32:44,809
thing into a lightweight emulator and

650
00:32:42,039 --> 00:32:46,490
with a little bit of help just kind of

651
00:32:44,809 --> 00:32:53,840
single step through and watch what code

652
00:32:46,490 --> 00:32:56,240
does just basically recreating the

653
00:32:53,840 --> 00:32:59,620
behaviors that it should does so let me

654
00:32:56,240 --> 00:32:59,620
introduce you to my little friend

655
00:33:00,669 --> 00:33:08,390
nobody ok a couple of you but who under

656
00:33:05,000 --> 00:33:12,500
40 got that really all right

657
00:33:08,390 --> 00:33:14,960
very good so this is a truly it's a

658
00:33:12,500 --> 00:33:18,529
shitty-ass thing that I wrote but it's

659
00:33:14,960 --> 00:33:22,010
so powerful because it's easy and it

660
00:33:18,529 --> 00:33:24,500
works basically it just spits out what

661
00:33:22,010 --> 00:33:28,309
the emulator has as the registers and

662
00:33:24,500 --> 00:33:30,110
the values in the registers highlights

663
00:33:28,309 --> 00:33:32,240
what changed since last time

664
00:33:30,110 --> 00:33:34,519
and gives me the next instruction that

665
00:33:32,240 --> 00:33:36,590
lets me hit enter or enter a couple

666
00:33:34,519 --> 00:33:40,360
commands that allow me to modify or you

667
00:33:36,590 --> 00:33:44,209
know do things on the fly simple stupid

668
00:33:40,360 --> 00:33:46,340
but it's so powerful like gdb but

669
00:33:44,210 --> 00:33:50,630
without requiring that the processor

670
00:33:46,340 --> 00:33:53,889
support debugging so writing an emulator

671
00:33:50,630 --> 00:33:53,889
is a lot easier than you might think

672
00:33:53,919 --> 00:33:59,480
vivisect provides an emulation framework

673
00:33:56,809 --> 00:34:03,010
where you just create an emulator for

674
00:33:59,480 --> 00:34:06,919
particular architecture like PowerPC and

675
00:34:03,010 --> 00:34:09,560
after setting up some some stuff that is

676
00:34:06,919 --> 00:34:12,290
generic for most processors or maybe

677
00:34:09,560 --> 00:34:15,830
specialized for yours you've been in you

678
00:34:12,290 --> 00:34:17,690
create function definitions where the

679
00:34:15,830 --> 00:34:22,848
name is i underscore and then the

680
00:34:17,690 --> 00:34:25,790
mnemonic that you're emulating you write

681
00:34:22,849 --> 00:34:29,359
a function with that name and attach it

682
00:34:25,790 --> 00:34:32,300
to your emulator object hand in an

683
00:34:29,359 --> 00:34:35,149
operon or an opcode and then you just do

684
00:34:32,300 --> 00:34:37,669
to the emulator which is handed in as

685
00:34:35,149 --> 00:34:40,368
the self or the first option the first

686
00:34:37,668 --> 00:34:42,859
argument then you do the thing that the

687
00:34:40,369 --> 00:34:46,159
processor would do this one this is a

688
00:34:42,859 --> 00:34:48,379
branch to the CTR register with link

689
00:34:46,159 --> 00:34:49,879
which means it's a call with length just

690
00:34:48,379 --> 00:34:53,418
means store where we're at and we're

691
00:34:49,879 --> 00:34:56,239
going to return here so we say the next

692
00:34:53,418 --> 00:34:59,390
operand and I'm sorry the next address

693
00:34:56,239 --> 00:35:02,540
after this one is the current address

694
00:34:59,390 --> 00:35:06,799
plus the length of the OP code simple

695
00:35:02,540 --> 00:35:11,270
okay right we then get the value of the

696
00:35:06,800 --> 00:35:14,839
CTR edge astir the counter register we

697
00:35:11,270 --> 00:35:19,730
then set the link register to the next

698
00:35:14,839 --> 00:35:21,799
virtual address and next V a and because

699
00:35:19,730 --> 00:35:25,610
of the way the emulator works if you

700
00:35:21,800 --> 00:35:28,250
turn of value from this function it will

701
00:35:25,610 --> 00:35:31,370
take that as a jump and it'll make the

702
00:35:28,250 --> 00:35:33,530
program counter end up at that return to

703
00:35:31,370 --> 00:35:34,910
value before executing the next

704
00:35:33,530 --> 00:35:39,110
instruction so we just returned the

705
00:35:34,910 --> 00:35:42,109
counter how easy is that even more

706
00:35:39,110 --> 00:35:43,910
importantly how fun is that I didn't

707
00:35:42,110 --> 00:35:49,120
think that writing a processor emulator

708
00:35:43,910 --> 00:35:49,120
could be that easy and simple but it is

709
00:35:50,110 --> 00:35:55,360
ok let's take something a little bigger

710
00:35:52,220 --> 00:35:58,549
a branch conditional

711
00:35:55,360 --> 00:36:01,210
okay so PowerPC is a pain in the ass I

712
00:35:58,550 --> 00:36:04,640
may have mentioned that they have about

713
00:36:01,210 --> 00:36:08,870
3,000 branch instructions including

714
00:36:04,640 --> 00:36:14,240
things like decrement the counter and if

715
00:36:08,870 --> 00:36:17,089
it's zero and the true bit is set and

716
00:36:14,240 --> 00:36:20,600
with link and like we've got all these

717
00:36:17,090 --> 00:36:23,560
different gargantuan named branch

718
00:36:20,600 --> 00:36:30,110
instructions so here's the branch

719
00:36:23,560 --> 00:36:32,779
decrement not zero and false flag who

720
00:36:30,110 --> 00:36:35,330
makes this shit up start off hey you

721
00:36:32,780 --> 00:36:40,130
know if we've got if we don't have two

722
00:36:35,330 --> 00:36:42,170
operands print an error message then get

723
00:36:40,130 --> 00:36:44,870
to the counter register decrement it by

724
00:36:42,170 --> 00:36:46,970
one and then write the counter register

725
00:36:44,870 --> 00:36:48,410
with the new value if it's zero return

726
00:36:46,970 --> 00:36:58,009
because we're not going to branch that's

727
00:36:48,410 --> 00:37:01,910
the not zero if the first operand is is

728
00:36:58,010 --> 00:37:05,660
true or is nonzero then also return

729
00:37:01,910 --> 00:37:07,990
because this is the false on the end if

730
00:37:05,660 --> 00:37:12,680
we've made it through that craziness

731
00:37:07,990 --> 00:37:15,609
return the value in operand number one

732
00:37:12,680 --> 00:37:19,339
remember zero based zero and then one

733
00:37:15,610 --> 00:37:21,680
and what does that do that says make the

734
00:37:19,340 --> 00:37:30,410
program counter point to whatever was in

735
00:37:21,680 --> 00:37:32,540
the operand index one a little crazy but

736
00:37:30,410 --> 00:37:34,020
it's PowerPC crazy not writing and

737
00:37:32,540 --> 00:37:35,610
emulator crazy and actually

738
00:37:34,020 --> 00:37:37,650
find that kind of refreshing because it

739
00:37:35,610 --> 00:37:41,310
helps me understand when all those

740
00:37:37,650 --> 00:37:45,840
stupid crazy assembly instructions mean

741
00:37:41,310 --> 00:37:46,890
I mean you can read through it but you

742
00:37:45,840 --> 00:37:50,700
learn it much better if you write a

743
00:37:46,890 --> 00:37:52,410
disassembler for it or in an emulator so

744
00:37:50,700 --> 00:37:55,470
we did bring in a hardware debugger and

745
00:37:52,410 --> 00:37:57,480
what this looks like is this piece of

746
00:37:55,470 --> 00:38:00,299
equipment right here we call it noisy

747
00:37:57,480 --> 00:38:04,800
because it's like sitting listening to a

748
00:38:00,300 --> 00:38:11,700
jet engine all day but it's NX piece

749
00:38:04,800 --> 00:38:13,680
server 1u rack mounted module why do I

750
00:38:11,700 --> 00:38:17,129
care why do I want that well it's

751
00:38:13,680 --> 00:38:21,270
running Linux so I actually get into gdb

752
00:38:17,130 --> 00:38:23,100
and I can gdb and I attach to whatever

753
00:38:21,270 --> 00:38:26,820
processor I start up whatever process

754
00:38:23,100 --> 00:38:29,100
and I just write stuff into memory and

755
00:38:26,820 --> 00:38:31,380
then I execute it so I can make sure

756
00:38:29,100 --> 00:38:33,750
that what happens on the real Hardware

757
00:38:31,380 --> 00:38:35,790
is what happens in my emulator it turns

758
00:38:33,750 --> 00:38:41,640
out there are some very interesting

759
00:38:35,790 --> 00:38:45,930
things lamentable things about nxp is

760
00:38:41,640 --> 00:38:48,900
documentation style like what is that

761
00:38:45,930 --> 00:38:50,669
zero went to you is it the most

762
00:38:48,900 --> 00:38:54,470
significant bit or the least significant

763
00:38:50,670 --> 00:38:57,240
bit what's that

764
00:38:54,470 --> 00:39:00,660
it's the least significant but in any

765
00:38:57,240 --> 00:39:01,819
sane documentation written by human

766
00:39:00,660 --> 00:39:06,210
beings

767
00:39:01,820 --> 00:39:08,820
this was not any of that so we start

768
00:39:06,210 --> 00:39:10,830
everything with zero being the most

769
00:39:08,820 --> 00:39:14,730
significant bit oh by the way it's a

770
00:39:10,830 --> 00:39:18,660
64-bit operating architecture design

771
00:39:14,730 --> 00:39:20,640
that is made to be used as a 32-bit

772
00:39:18,660 --> 00:39:23,670
architecture as well like for keepo

773
00:39:20,640 --> 00:39:32,460
things and a lot of the instructions are

774
00:39:23,670 --> 00:39:35,280
literally take bits 60 32 through 63 the

775
00:39:32,460 --> 00:39:36,900
least significant bits and do these

776
00:39:35,280 --> 00:39:39,180
things when it's like would you just

777
00:39:36,900 --> 00:39:42,030
please get with the program anyway we

778
00:39:39,180 --> 00:39:43,830
found several bugs that were class

779
00:39:42,030 --> 00:39:45,160
oriented like that that were easy to fix

780
00:39:43,830 --> 00:39:47,828
but only

781
00:39:45,160 --> 00:39:49,660
because we were able to use hardware to

782
00:39:47,829 --> 00:39:55,329
make sure that what we thought was going

783
00:39:49,660 --> 00:39:56,680
on was really what was going on you guys

784
00:39:55,329 --> 00:40:00,970
got some brain power laughs no blood

785
00:39:56,680 --> 00:40:02,259
dripping out yet okay I see like more

786
00:40:00,970 --> 00:40:04,000
than three-quarters of you have stuck

787
00:40:02,260 --> 00:40:05,589
with me thank you I think people have

788
00:40:04,000 --> 00:40:08,079
actually come in in addition to leaving

789
00:40:05,589 --> 00:40:11,140
and that's totally cool because it's

790
00:40:08,079 --> 00:40:13,329
really thick gritty stuff symbolics

791
00:40:11,140 --> 00:40:15,940
let's talk about Symbolics a little bit

792
00:40:13,329 --> 00:40:18,130
I said before that you that symbolic

793
00:40:15,940 --> 00:40:19,990
analysis is the art of breaking down

794
00:40:18,130 --> 00:40:25,859
assembly instructions into their

795
00:40:19,990 --> 00:40:27,848
symbolic effects like push EBP for Intel

796
00:40:25,859 --> 00:40:32,460
Architecture right what's that do

797
00:40:27,849 --> 00:40:35,200
well it decrements the the stack pointer

798
00:40:32,460 --> 00:40:37,930
by four or eight depending on the system

799
00:40:35,200 --> 00:40:42,339
you're on 32 bit or 64 and then it

800
00:40:37,930 --> 00:40:45,279
writes the value from EBP into the

801
00:40:42,339 --> 00:40:48,339
memory location pointed to by the stack

802
00:40:45,280 --> 00:40:51,369
pointer right those are the tool effects

803
00:40:48,339 --> 00:40:51,849
of the push EBP instruction does that

804
00:40:51,369 --> 00:40:55,119
make sense

805
00:40:51,849 --> 00:40:59,200
didn't lose anybody right okay symbolics

806
00:40:55,119 --> 00:41:03,309
basically says if I've got the push

807
00:40:59,200 --> 00:41:06,819
instruction do the push things and spit

808
00:41:03,309 --> 00:41:09,849
out a list of symbolic effects okay

809
00:41:06,819 --> 00:41:13,859
really magical word Atlas great thanks

810
00:41:09,849 --> 00:41:17,380
what is symbolic effects I'll tell you

811
00:41:13,859 --> 00:41:22,328
we wrote a bunch of Python objects which

812
00:41:17,380 --> 00:41:25,299
represent operands like registers and

813
00:41:22,329 --> 00:41:31,710
memory D references or memory operands

814
00:41:25,299 --> 00:41:38,819
and we wrote a bunch of operators like

815
00:41:31,710 --> 00:41:41,890
equals and less than and subtract and

816
00:41:38,819 --> 00:41:44,430
multiply and all the things that you

817
00:41:41,890 --> 00:41:48,940
would do in a computer system turns out

818
00:41:44,430 --> 00:41:53,078
in a loose sense a computer system is

819
00:41:48,940 --> 00:41:54,820
just a really powerful math machine so

820
00:41:53,079 --> 00:41:56,590
the majority of code

821
00:41:54,820 --> 00:42:00,160
that you that has been written can be

822
00:41:56,590 --> 00:42:02,140
reduced to algebraic minimums now I'm

823
00:42:00,160 --> 00:42:04,240
not gonna go down that road because the

824
00:42:02,140 --> 00:42:08,080
using jargon doesn't make anybody happy

825
00:42:04,240 --> 00:42:13,209
but basically I can say the effects are

826
00:42:08,080 --> 00:42:16,840
these objects and then we use the power

827
00:42:13,210 --> 00:42:22,540
of the magic of Python to allow us to

828
00:42:16,840 --> 00:42:24,940
overload all of the mathematical or the

829
00:42:22,540 --> 00:42:28,029
algebraic functionality built into

830
00:42:24,940 --> 00:42:33,520
objects so when we say we have an object

831
00:42:28,030 --> 00:42:37,030
here the we say x equals some static

832
00:42:33,520 --> 00:42:38,860
constant object with the number 4 so it

833
00:42:37,030 --> 00:42:41,250
creates a Python object and it knows

834
00:42:38,860 --> 00:42:47,410
that it's the number 4 and then we say

835
00:42:41,250 --> 00:42:51,330
that that variable plus constant value 8

836
00:42:47,410 --> 00:42:55,839
and because we've changed the actual

837
00:42:51,330 --> 00:42:57,700
plus handler for each of those one of

838
00:42:55,840 --> 00:42:59,860
them gets called and the other thing is

839
00:42:57,700 --> 00:43:06,009
handed in to it and it's able to spit

840
00:42:59,860 --> 00:43:08,560
out and an add operator that has both of

841
00:43:06,010 --> 00:43:14,830
those two things as its children so we

842
00:43:08,560 --> 00:43:17,560
end up with a symbolic tree of objects

843
00:43:14,830 --> 00:43:19,120
that as we just do mathematical things

844
00:43:17,560 --> 00:43:24,490
to them like add subtract multiply

845
00:43:19,120 --> 00:43:28,270
divided we end up having Python just

846
00:43:24,490 --> 00:43:30,220
track the state and what it was all the

847
00:43:28,270 --> 00:43:34,090
way through now we do have code that

848
00:43:30,220 --> 00:43:37,000
says solve and it'll go as long as

849
00:43:34,090 --> 00:43:38,170
there's no nothing that's not solved it

850
00:43:37,000 --> 00:43:41,760
will go through and it'll add everything

851
00:43:38,170 --> 00:43:41,760
up and it'll go Boop there's your answer

852
00:43:42,900 --> 00:43:46,450
now you'll see a directed graph on this

853
00:43:46,000 --> 00:43:49,630
slide

854
00:43:46,450 --> 00:43:51,460
that's not symbolic but if you try to do

855
00:43:49,630 --> 00:43:54,370
Symbolics without using a directed graph

856
00:43:51,460 --> 00:43:59,830
you'll be very limited so vivisect wraps

857
00:43:54,370 --> 00:44:01,589
in a directed graph library we won't get

858
00:43:59,830 --> 00:44:07,480
it too much into that right now but

859
00:44:01,590 --> 00:44:08,890
basically we select a path of code we

860
00:44:07,480 --> 00:44:11,020
translate all of the

861
00:44:08,890 --> 00:44:12,490
instructions in that path of code into

862
00:44:11,020 --> 00:44:17,650
their symbolic effects which I like to

863
00:44:12,490 --> 00:44:19,959
call simple symbolic effects and then we

864
00:44:17,650 --> 00:44:21,850
run and we end up with a list of

865
00:44:19,960 --> 00:44:23,440
symbolic effects we run that list of

866
00:44:21,850 --> 00:44:28,330
symbolic effects through a symbolic

867
00:44:23,440 --> 00:44:31,330
emulator and it says oh I've got all

868
00:44:28,330 --> 00:44:33,910
these you know hey EBP is this or you

869
00:44:31,330 --> 00:44:37,240
know whatever in it stores in the

870
00:44:33,910 --> 00:44:39,310
emulator the register state or things

871
00:44:37,240 --> 00:44:45,069
like we don't even call them registers

872
00:44:39,310 --> 00:44:47,200
they're just things and so when we do a

873
00:44:45,070 --> 00:44:48,730
function Prolog you guys know what a

874
00:44:47,200 --> 00:44:51,069
function Prolog is it's the first couple

875
00:44:48,730 --> 00:44:52,630
instructions that a compiler will almost

876
00:44:51,070 --> 00:44:58,510
always put at the beginning of a

877
00:44:52,630 --> 00:45:01,530
function like push CVP move ESB EBP

878
00:44:58,510 --> 00:45:05,350
right that's a xat that's an x86 32-bit

879
00:45:01,530 --> 00:45:07,060
function Prolog very very common we'll

880
00:45:05,350 --> 00:45:11,110
talk about that in a minute what that

881
00:45:07,060 --> 00:45:13,990
looks like but as we extrude through

882
00:45:11,110 --> 00:45:16,810
there instead of say we say no I'll walk

883
00:45:13,990 --> 00:45:19,569
you through a real quick bushy VP so we

884
00:45:16,810 --> 00:45:21,880
subtract four from the from the stack

885
00:45:19,570 --> 00:45:23,290
pointer and we put EVP onto the stack in

886
00:45:21,880 --> 00:45:26,890
the memory that the point of the stack

887
00:45:23,290 --> 00:45:32,830
pointer points out then move ESP into

888
00:45:26,890 --> 00:45:38,589
EBP so the simple effect is we set EVP

889
00:45:32,830 --> 00:45:41,710
to the value of ESP but when you start

890
00:45:38,590 --> 00:45:44,980
to extrude state data through this path

891
00:45:41,710 --> 00:45:47,890
this cone path that second instruction

892
00:45:44,980 --> 00:45:50,410
which I if we once we translate it I'm

893
00:45:47,890 --> 00:45:54,730
sorry once we emulate it it turns into

894
00:45:50,410 --> 00:45:57,940
an applied symbolic effect where instead

895
00:45:54,730 --> 00:46:05,710
of putting the data and the value of ESP

896
00:45:57,940 --> 00:46:10,480
into EBP we end up putting the value of

897
00:46:05,710 --> 00:46:12,420
ESP minus 4 because ESP has been

898
00:46:10,480 --> 00:46:18,040
modified from the beginning state and

899
00:46:12,420 --> 00:46:20,260
the emulator knows that a little bit of

900
00:46:18,040 --> 00:46:22,480
PowerPC assembly your brains are melting

901
00:46:20,260 --> 00:46:25,210
yet good

902
00:46:22,480 --> 00:46:27,990
no emergency rooms here today so this is

903
00:46:25,210 --> 00:46:31,839
a PowerPC set of assembly instructions

904
00:46:27,990 --> 00:46:35,259
store right back update blah blah this

905
00:46:31,839 --> 00:46:40,180
is basically push EBP and move ESP EBP

906
00:46:35,260 --> 00:46:43,359
in PowerPC parlance so and we're going

907
00:46:40,180 --> 00:46:45,069
right here we move from the special

908
00:46:43,359 --> 00:46:48,848
register called the link register we put

909
00:46:45,070 --> 00:46:50,260
the value into register 0 okay and then

910
00:46:48,849 --> 00:46:52,780
we store blah blah blah blah blah blah

911
00:46:50,260 --> 00:46:54,880
okay so you don't have to know PowerPC

912
00:46:52,780 --> 00:47:00,130
assembly to know that these are PowerPC

913
00:46:54,880 --> 00:47:02,579
assembly instructions can you see that

914
00:47:00,130 --> 00:47:02,579
at all

915
00:47:03,150 --> 00:47:09,310
so what we've done here is here are your

916
00:47:05,920 --> 00:47:12,869
instruction that we just looked at the

917
00:47:09,310 --> 00:47:19,509
simple effects of these instructions

918
00:47:12,869 --> 00:47:24,670
convert to write memory the location of

919
00:47:19,510 --> 00:47:29,079
memory is subtraction of variable r 1 -

920
00:47:24,670 --> 00:47:34,119
hex 10 and it's 4 bytes in length 32

921
00:47:29,079 --> 00:47:38,290
bits and we write into that location the

922
00:47:34,119 --> 00:47:40,810
variable R 1 we then so we've written

923
00:47:38,290 --> 00:47:48,880
the memory we then set variable R 1

924
00:47:40,810 --> 00:47:52,599
equal to and R 1 plus negative 16 okay

925
00:47:48,880 --> 00:47:55,630
this is a little lame but it works that

926
00:47:52,599 --> 00:47:59,140
is actually following what the pseudo

927
00:47:55,630 --> 00:48:01,630
code in the PowerPC manual say to do I

928
00:47:59,140 --> 00:48:05,890
would have personally chosen to use a

929
00:48:01,630 --> 00:48:07,450
subtract but hey want to keep really

930
00:48:05,890 --> 00:48:11,348
close to what the documentation says

931
00:48:07,450 --> 00:48:13,930
then we set variable r0 to the variable

932
00:48:11,349 --> 00:48:17,440
the link register variable okay so

933
00:48:13,930 --> 00:48:20,560
simple effects here write memory and the

934
00:48:17,440 --> 00:48:26,560
location is the addition of our 0 plus

935
00:48:20,560 --> 00:48:30,910
hex C or 12 added together 4 bytes in

936
00:48:26,560 --> 00:48:34,690
length the value of our 31 and then

937
00:48:30,910 --> 00:48:36,020
another one right memory the addition of

938
00:48:34,690 --> 00:48:41,960
variable R 1

939
00:48:36,020 --> 00:48:47,060
Plus hex 14 size 32 bits of the value

940
00:48:41,960 --> 00:48:49,220
are zero now you'll notice r0 has

941
00:48:47,060 --> 00:48:53,299
already been updated to be the link

942
00:48:49,220 --> 00:48:54,830
register here right so in simple effects

943
00:48:53,300 --> 00:48:56,270
we don't care to

944
00:48:54,830 --> 00:48:59,150
boom-boom-boom-boom-boom these are the

945
00:48:56,270 --> 00:49:01,460
things the processor has to do once we

946
00:48:59,150 --> 00:49:04,100
apply them however we have applied

947
00:49:01,460 --> 00:49:06,200
effects and they're all actually the

948
00:49:04,100 --> 00:49:08,509
same effects until you reach this one

949
00:49:06,200 --> 00:49:15,290
right here right memory the location of

950
00:49:08,510 --> 00:49:21,950
which is r1 plus 4 and make that equal

951
00:49:15,290 --> 00:49:24,050
to the link register starting to see why

952
00:49:21,950 --> 00:49:25,549
I think this is very powerful does it

953
00:49:24,050 --> 00:49:27,790
make sense it doesn't have to make total

954
00:49:25,550 --> 00:49:32,180
sense you don't have to be a guru yet

955
00:49:27,790 --> 00:49:34,340
that'll come later symbolic also has

956
00:49:32,180 --> 00:49:36,740
what we like to call pretty output so

957
00:49:34,340 --> 00:49:39,670
this is the verbose output we made the

958
00:49:36,740 --> 00:49:42,589
verbose output something that if I

959
00:49:39,670 --> 00:49:44,720
literally copied it and pasted this into

960
00:49:42,590 --> 00:49:51,110
an interactive Python interpreter it

961
00:49:44,720 --> 00:49:54,740
would regenerate the state loves but the

962
00:49:51,110 --> 00:50:00,110
pretty output is hey our 1 minus 16

963
00:49:54,740 --> 00:50:04,339
equals r0 r1 r1 equals r1 plus negative

964
00:50:00,110 --> 00:50:09,920
16 our 0 equals link register r1 plus

965
00:50:04,340 --> 00:50:13,880
negative negative 4 so r1 minus 4 equals

966
00:50:09,920 --> 00:50:19,130
our 31 our 1 plus 4 equals link register

967
00:50:13,880 --> 00:50:20,660
our 13 plus this constant is red because

968
00:50:19,130 --> 00:50:22,960
it doesn't do anything but it wants us

969
00:50:20,660 --> 00:50:29,000
to keep tracted we did a read here and

970
00:50:22,960 --> 00:50:33,440
then our 12 is the memory read of the

971
00:50:29,000 --> 00:50:38,360
location our 13 plus this thing 2 bytes

972
00:50:33,440 --> 00:50:41,090
in length 16 bits this is just the

973
00:50:38,360 --> 00:50:45,980
representation just the printing of the

974
00:50:41,090 --> 00:50:47,960
state for ease of working with it but

975
00:50:45,980 --> 00:50:49,460
once but I end up having the entire

976
00:50:47,960 --> 00:50:53,119
programmatic state

977
00:50:49,460 --> 00:50:55,250
sword so that I can roll through and say

978
00:50:53,119 --> 00:50:58,760
what's the last thing that was put into

979
00:50:55,250 --> 00:51:01,160
our 31 and I just start at the end of

980
00:50:58,760 --> 00:51:04,309
the state and go up boom Oh our 31 was

981
00:51:01,160 --> 00:51:08,359
set here it has this full symbolic state

982
00:51:04,309 --> 00:51:10,819
I can reduce it to the very simplest of

983
00:51:08,359 --> 00:51:13,308
function things like the plus 4 minus 10

984
00:51:10,819 --> 00:51:17,058
blah blah blah all collapses into into

985
00:51:13,309 --> 00:51:20,300
one number or I can look through and say

986
00:51:17,059 --> 00:51:22,849
this has had 5 different things done to

987
00:51:20,300 --> 00:51:25,250
it I know how exactly that value is

988
00:51:22,849 --> 00:51:27,290
being calculated which tells me actually

989
00:51:25,250 --> 00:51:31,309
a lot about what the compiler was doing

990
00:51:27,290 --> 00:51:35,869
which helps me figure out things like we

991
00:51:31,309 --> 00:51:39,770
are adding some arbitrary value to

992
00:51:35,869 --> 00:51:42,230
memory to a piece of data that I handed

993
00:51:39,770 --> 00:51:47,869
it in as an attacker and that is being

994
00:51:42,230 --> 00:51:52,010
handed in to malloc when why is that a

995
00:51:47,869 --> 00:51:55,640
win anybody tell me because it's a

996
00:51:52,010 --> 00:51:59,540
finite number system if I hand in data

997
00:51:55,640 --> 00:52:03,470
that I control and it's added to or

998
00:51:59,540 --> 00:52:07,460
subtracted to by some number if I have

999
00:52:03,470 --> 00:52:10,279
enough control I can have an under run

1000
00:52:07,460 --> 00:52:12,859
where the number gets very very large or

1001
00:52:10,280 --> 00:52:15,589
an overrun which means the number gets

1002
00:52:12,859 --> 00:52:18,650
very very small in which case malloc

1003
00:52:15,589 --> 00:52:20,420
returns too small of a value or a piece

1004
00:52:18,650 --> 00:52:23,089
of memory for the things that's going to

1005
00:52:20,420 --> 00:52:29,630
be written into it and from there we've

1006
00:52:23,089 --> 00:52:31,130
got a heap overflow writing Symbolics

1007
00:52:29,630 --> 00:52:33,470
translator code is actually probably a

1008
00:52:31,130 --> 00:52:34,819
lot easier than understanding all the

1009
00:52:33,470 --> 00:52:38,868
stuff that I just dumped on you so this

1010
00:52:34,819 --> 00:52:40,720
is gonna go really easily again in the

1011
00:52:38,869 --> 00:52:44,140
same fashion as the emulator we write

1012
00:52:40,720 --> 00:52:46,399
helper functions that start off the the

1013
00:52:44,140 --> 00:52:48,950
symbolic translator is what we call this

1014
00:52:46,400 --> 00:52:53,630
if you create a function with an i

1015
00:52:48,950 --> 00:52:57,529
underscore that's a instruction so I add

1016
00:52:53,630 --> 00:53:02,650
is which is add an immediate shifted so

1017
00:52:57,530 --> 00:53:02,650
we shifted the 16 bits

1018
00:53:02,680 --> 00:53:08,299
but it's a little different way of

1019
00:53:05,059 --> 00:53:10,099
thinking because remember we have to we

1020
00:53:08,299 --> 00:53:14,749
have to return a list of symbolic

1021
00:53:10,099 --> 00:53:16,999
effects we can't make concrete use of

1022
00:53:14,749 --> 00:53:19,160
data like in an emulator we can say you

1023
00:53:16,999 --> 00:53:21,049
know give me this flag value and if it's

1024
00:53:19,160 --> 00:53:22,368
this flag value then I want to go this

1025
00:53:21,049 --> 00:53:24,140
way and if it's the other thing that

1026
00:53:22,369 --> 00:53:29,059
I'll go this other way no no you have to

1027
00:53:24,140 --> 00:53:35,029
think in terms of actual just symbolic

1028
00:53:29,059 --> 00:53:37,759
effects so ADUs we the source one is the

1029
00:53:35,029 --> 00:53:40,309
opera object the operand object number

1030
00:53:37,759 --> 00:53:44,779
one in the instruction source two is the

1031
00:53:40,309 --> 00:53:49,430
operand object to source two is then

1032
00:53:44,779 --> 00:53:51,289
shifted left constant of sixteen and we

1033
00:53:49,430 --> 00:53:54,319
have to hand in because it's a concrete

1034
00:53:51,289 --> 00:53:56,900
number system the numbers can only be an

1035
00:53:54,319 --> 00:54:00,319
actual size it can be sixteen bits 32

1036
00:53:56,900 --> 00:54:01,729
bits 64 bits so we track that throughout

1037
00:54:00,319 --> 00:54:03,308
the state because it's important it's

1038
00:54:01,729 --> 00:54:06,739
valuable

1039
00:54:03,309 --> 00:54:09,650
so we shift source to this operand

1040
00:54:06,739 --> 00:54:12,440
number two which is a symbolic object by

1041
00:54:09,650 --> 00:54:15,920
the way it's not a concrete number we

1042
00:54:12,440 --> 00:54:20,660
shift that by the constant 16 and then

1043
00:54:15,920 --> 00:54:24,259
we sign extended to the right size just

1044
00:54:20,660 --> 00:54:28,190
making sure that it's all tracked and

1045
00:54:24,259 --> 00:54:31,579
state we then add the result now source

1046
00:54:28,190 --> 00:54:33,739
1 is a symbolic object it's probably a

1047
00:54:31,579 --> 00:54:37,759
constant in many cases or a register

1048
00:54:33,739 --> 00:54:42,200
value and so we end up with an O

1049
00:54:37,759 --> 00:54:46,569
underscore add object with source 1 and

1050
00:54:42,200 --> 00:54:53,390
source twos symbolic objects as children

1051
00:54:46,569 --> 00:55:01,130
we then set that back to operand 0 the

1052
00:54:53,390 --> 00:55:04,339
result over here on the right if you can

1053
00:55:01,130 --> 00:55:06,710
see it we've got an effect set variable

1054
00:55:04,339 --> 00:55:09,229
function and effect read mat variable

1055
00:55:06,710 --> 00:55:12,650
read memory effect rewrite memory effect

1056
00:55:09,229 --> 00:55:17,000
f of X which is a way of reducing a

1057
00:55:12,650 --> 00:55:20,570
function call and EF f constraint so

1058
00:55:17,000 --> 00:55:23,780
let's see if we go this is going to

1059
00:55:20,570 --> 00:55:26,660
generate an e FF right memory it's going

1060
00:55:23,780 --> 00:55:29,330
to take in the symbolic address the

1061
00:55:26,660 --> 00:55:32,390
symbolic size and then the object that's

1062
00:55:29,330 --> 00:55:36,170
going to be written there and we just

1063
00:55:32,390 --> 00:55:38,629
add to the effects log a write memory

1064
00:55:36,170 --> 00:55:40,700
object and we hand in the virtual

1065
00:55:38,630 --> 00:55:43,250
address the symbolic address because we

1066
00:55:40,700 --> 00:55:46,189
want to track for troubleshooting and

1067
00:55:43,250 --> 00:55:49,430
put in other things we want to track

1068
00:55:46,190 --> 00:55:51,770
which instruction created the created

1069
00:55:49,430 --> 00:55:54,618
the symbolic effect so we store the V a

1070
00:55:51,770 --> 00:55:58,280
current V a virtual address then we

1071
00:55:54,619 --> 00:56:00,500
store the symbolic address that we're

1072
00:55:58,280 --> 00:56:02,660
writing to the size that we're writing

1073
00:56:00,500 --> 00:56:04,460
to and then the symbolic object that

1074
00:56:02,660 --> 00:56:10,790
we're going to be writing there and we

1075
00:56:04,460 --> 00:56:13,310
track that that is a lot to digest and

1076
00:56:10,790 --> 00:56:15,020
if nothing else you've come away with

1077
00:56:13,310 --> 00:56:17,330
the fact that I'm Way too nerdy for my

1078
00:56:15,020 --> 00:56:18,950
own good hopefully you've been

1079
00:56:17,330 --> 00:56:22,670
entertained I do want to give a few

1080
00:56:18,950 --> 00:56:24,759
props here the nmf FDA the National

1081
00:56:22,670 --> 00:56:28,910
motor freight traffic Association a

1082
00:56:24,760 --> 00:56:31,790
conglomeration devoted to cybersecurity

1083
00:56:28,910 --> 00:56:34,848
of heavy trucking they gave us funding

1084
00:56:31,790 --> 00:56:37,160
to work on this project because it's in

1085
00:56:34,849 --> 00:56:40,880
their best interest that we have good

1086
00:56:37,160 --> 00:56:45,140
tooling to find bugs and make good use

1087
00:56:40,880 --> 00:56:47,030
of I mean kill them right they also they

1088
00:56:45,140 --> 00:56:48,799
funded us they also connected Grimm with

1089
00:56:47,030 --> 00:56:51,290
NX P and then we created a partnership

1090
00:56:48,800 --> 00:56:53,300
and did cool stuff and they kept us on

1091
00:56:51,290 --> 00:56:54,349
task like they they're like can you send

1092
00:56:53,300 --> 00:56:56,720
me a status update

1093
00:56:54,349 --> 00:56:58,520
yeah keep keep asking me in two weeks ok

1094
00:56:56,720 --> 00:57:01,250
can you can you send me a status thank

1095
00:56:58,520 --> 00:57:03,830
you yeah sure and thank you for an XP

1096
00:57:01,250 --> 00:57:04,849
they provided us hardware and tech

1097
00:57:03,830 --> 00:57:09,020
support on how to get the hardware

1098
00:57:04,849 --> 00:57:10,670
working and then a few things that are

1099
00:57:09,020 --> 00:57:13,280
next we're just going to continue to

1100
00:57:10,670 --> 00:57:15,650
enhance it and hopefully it will be

1101
00:57:13,280 --> 00:57:18,950
merged into mainline vivisect within the

1102
00:57:15,650 --> 00:57:21,800
next month takes a long time when you

1103
00:57:18,950 --> 00:57:25,040
got that much code so you can get access

1104
00:57:21,800 --> 00:57:28,040
to it right now at my github github

1105
00:57:25,040 --> 00:57:30,230
atlas of doom with zeros vivisect

1106
00:57:28,040 --> 00:57:32,990
in the env underscore

1107
00:57:30,230 --> 00:57:34,880
PPC branch the powerpc branch I should

1108
00:57:32,990 --> 00:57:36,319
have that merged into the Atlas merge

1109
00:57:34,880 --> 00:57:39,170
branch which is what I recommend people

1110
00:57:36,320 --> 00:57:41,300
use most the time anyway and then when

1111
00:57:39,170 --> 00:57:45,920
it gets merged in it'll be in the actual

1112
00:57:41,300 --> 00:57:48,470
vivisect repo thank you very much I

1113
00:57:45,920 --> 00:57:50,740
appreciate your indulgence and I hope

1114
00:57:48,470 --> 00:57:50,740
you were entertained

