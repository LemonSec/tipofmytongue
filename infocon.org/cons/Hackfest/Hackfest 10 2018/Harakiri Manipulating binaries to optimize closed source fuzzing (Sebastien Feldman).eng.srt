1
00:00:00,030 --> 00:00:04,890
hello everyone my name is Sebastian and

2
00:00:02,760 --> 00:00:06,240
I'm going to speak about fuzzing more

3
00:00:04,890 --> 00:00:08,490
precisely I'm going to speak about

4
00:00:06,240 --> 00:00:11,429
fuzzing in the context of closed source

5
00:00:08,490 --> 00:00:13,469
applications on Windows so for the

6
00:00:11,429 --> 00:00:14,969
targets that I've chosen I assume that I

7
00:00:13,469 --> 00:00:17,430
have zero knowledge about the program

8
00:00:14,969 --> 00:00:18,900
that I'm trying to test I don't have the

9
00:00:17,430 --> 00:00:21,210
source code I don't have debugging

10
00:00:18,900 --> 00:00:23,669
symbols I only see it as a from the

11
00:00:21,210 --> 00:00:25,260
perspective of a regular users I'm going

12
00:00:23,670 --> 00:00:27,300
to speak about features of which I think

13
00:00:25,260 --> 00:00:29,580
that a sophisticated father should have

14
00:00:27,300 --> 00:00:31,650
and I'm going to mention approaches that

15
00:00:29,580 --> 00:00:33,899
exists to implement these features for

16
00:00:31,650 --> 00:00:35,610
open source applications and then going

17
00:00:33,899 --> 00:00:37,440
to mention why these features are not

18
00:00:35,610 --> 00:00:39,809
going to work if you try to first close

19
00:00:37,440 --> 00:00:42,089
those applications and then I'm going to

20
00:00:39,809 --> 00:00:44,099
mention approaches some of these I came

21
00:00:42,090 --> 00:00:46,020
up with some of some already exists in

22
00:00:44,100 --> 00:00:48,899
our way known that we can use to get

23
00:00:46,020 --> 00:00:51,030
these features every one to thousands

24
00:00:48,899 --> 00:00:53,309
most of the stuff with I said early on

25
00:00:51,030 --> 00:00:54,750
static patching on this emulator so we

26
00:00:53,309 --> 00:00:58,349
might be seeing some assembly in this

27
00:00:54,750 --> 00:01:00,989
Court let me first say a couple of rules

28
00:00:58,350 --> 00:01:02,850
of myself so I'm Sebastian and I'm

29
00:01:00,989 --> 00:01:05,700
working at all secure as a pen tester

30
00:01:02,850 --> 00:01:08,760
and security researcher I originally I'm

31
00:01:05,700 --> 00:01:10,619
from Germany so I'm still a student the

32
00:01:08,760 --> 00:01:12,600
Technical University of Darmstadt and

33
00:01:10,619 --> 00:01:14,820
used to live and study in Estonia as

34
00:01:12,600 --> 00:01:16,679
well I'm finally meant to graduate from

35
00:01:14,820 --> 00:01:20,339
university in December after way too

36
00:01:16,680 --> 00:01:22,470
long I used to play CDF underling zero

37
00:01:20,340 --> 00:01:23,850
income which is actually reason why I

38
00:01:22,470 --> 00:01:26,100
ended up in Quebec because the guy who

39
00:01:23,850 --> 00:01:28,229
runs wing zero team was a guy from

40
00:01:26,100 --> 00:01:29,520
Quebec I'm mostly interested in

41
00:01:28,229 --> 00:01:31,740
low-level stuff such as binary

42
00:01:29,520 --> 00:01:33,390
exploitation reversing I got involved

43
00:01:31,740 --> 00:01:35,820
into a lot of antivirus and sandbox

44
00:01:33,390 --> 00:01:39,030
evasion for my job and obviously I also

45
00:01:35,820 --> 00:01:40,679
do like a lot of fuzzing as well but let

46
00:01:39,030 --> 00:01:42,060
us first start with the question why was

47
00:01:40,680 --> 00:01:44,270
we even what is the intention behind

48
00:01:42,060 --> 00:01:46,890
fuzzing closed source applications and

49
00:01:44,270 --> 00:01:48,089
the main or the most honorable intention

50
00:01:46,890 --> 00:01:49,770
would be that we want to sign memory

51
00:01:48,090 --> 00:01:51,899
corruptions in order to make programs

52
00:01:49,770 --> 00:01:53,789
that are widely used more secure the

53
00:01:51,899 --> 00:01:55,200
more corruptions we find the less likely

54
00:01:53,790 --> 00:01:57,540
the program is going to be exploited

55
00:01:55,200 --> 00:02:00,450
I guess that's obvious at the same time

56
00:01:57,540 --> 00:02:02,310
finding crashes is as easy as it is

57
00:02:00,450 --> 00:02:03,930
rewarding and are quite rewarding to

58
00:02:02,310 --> 00:02:07,500
find crashes and applications of major

59
00:02:03,930 --> 00:02:08,960
vendors such as fox video or doe and it

60
00:02:07,500 --> 00:02:10,850
is obviously not obvious

61
00:02:08,960 --> 00:02:12,350
but actually I was surprised how easy it

62
00:02:10,850 --> 00:02:15,170
is to find any Crashers in death

63
00:02:12,350 --> 00:02:16,730
a crude thing about fuzzing is that if

64
00:02:15,170 --> 00:02:17,720
you implemented your files away then

65
00:02:16,730 --> 00:02:18,980
your father runs for you in the

66
00:02:17,720 --> 00:02:20,840
background where you have time to do

67
00:02:18,980 --> 00:02:22,730
support while you have time to do

68
00:02:20,840 --> 00:02:24,410
something else with your life so what my

69
00:02:22,730 --> 00:02:25,760
father does is every time he found an

70
00:02:24,410 --> 00:02:26,720
interesting crash you could send me a

71
00:02:25,760 --> 00:02:28,519
push notification

72
00:02:26,720 --> 00:02:30,410
all I have to do is sit on my cell

73
00:02:28,520 --> 00:02:31,820
phones call through the crash reports

74
00:02:30,410 --> 00:02:34,100
and decide if I want to dig deep into

75
00:02:31,820 --> 00:02:36,410
the sauna now the cool thing about this

76
00:02:34,100 --> 00:02:38,690
project is that if you have a working

77
00:02:36,410 --> 00:02:40,700
exploit or if you have a crash that you

78
00:02:38,690 --> 00:02:42,560
don't that you couldn't exploit but that

79
00:02:40,700 --> 00:02:44,089
looks somehow interesting

80
00:02:42,560 --> 00:02:45,560
you can submit these crashes to

81
00:02:44,090 --> 00:02:48,170
organizations such as zero day

82
00:02:45,560 --> 00:02:50,510
initiative and depending on how widely

83
00:02:48,170 --> 00:02:52,280
the program that you found the question

84
00:02:50,510 --> 00:02:53,959
is used you might even get a bounty for

85
00:02:52,280 --> 00:02:58,190
this so it might even pay off in terms

86
00:02:53,960 --> 00:03:00,530
of money and if I say that finding

87
00:02:58,190 --> 00:03:02,030
crashes is actually not so difficult so

88
00:03:00,530 --> 00:03:04,190
the screenshot in the background shows

89
00:03:02,030 --> 00:03:06,470
the amount of crashes that my father has

90
00:03:04,190 --> 00:03:09,500
found in 2-month so this is at the

91
00:03:06,470 --> 00:03:11,720
moment forty-three unique crashes this

92
00:03:09,500 --> 00:03:13,070
is like two month old I submitted some

93
00:03:11,720 --> 00:03:15,140
of these crashes to zero day initiative

94
00:03:13,070 --> 00:03:17,390
which were accepted and other crashes

95
00:03:15,140 --> 00:03:20,869
were submitted to the vendor directly so

96
00:03:17,390 --> 00:03:22,820
that they could fix the vulnerability so

97
00:03:20,870 --> 00:03:24,650
basic what is the idea behind fuzzing

98
00:03:22,820 --> 00:03:25,760
close those applications and basically

99
00:03:24,650 --> 00:03:27,740
it's the same thing as when we first

100
00:03:25,760 --> 00:03:29,870
open source applications all we need to

101
00:03:27,740 --> 00:03:31,400
do is we throw random input at our

102
00:03:29,870 --> 00:03:33,560
target and hope that our target dies

103
00:03:31,400 --> 00:03:35,390
because we hope that the input triggers

104
00:03:33,560 --> 00:03:37,070
behavior that was unintended by the

105
00:03:35,390 --> 00:03:39,350
developer and therefore it doesn't know

106
00:03:37,070 --> 00:03:41,720
how to handle it and dies so while this

107
00:03:39,350 --> 00:03:44,120
concept sounds extremely simple it's

108
00:03:41,720 --> 00:03:45,890
both very effective and difficult to

109
00:03:44,120 --> 00:03:48,290
master because if you want your father

110
00:03:45,890 --> 00:03:49,640
to find deep bugs so bugs that are

111
00:03:48,290 --> 00:03:51,799
hidden somewhere deep deep in the

112
00:03:49,640 --> 00:03:53,390
codebase your father needs some

113
00:03:51,800 --> 00:03:54,920
sophisticated features because you want

114
00:03:53,390 --> 00:03:57,200
to find bugs that nobody else has found

115
00:03:54,920 --> 00:03:58,700
before you right so these features are

116
00:03:57,200 --> 00:04:00,440
actually quite easy to implement if you

117
00:03:58,700 --> 00:04:02,209
first open source targets for the reason

118
00:04:00,440 --> 00:04:03,620
that we have the source code but quite

119
00:04:02,210 --> 00:04:07,490
difficult to implement that you want to

120
00:04:03,620 --> 00:04:09,110
first close source applications so but

121
00:04:07,490 --> 00:04:10,700
which challenges am I am I going to

122
00:04:09,110 --> 00:04:11,930
speak about I'm not going to mention all

123
00:04:10,700 --> 00:04:13,160
of these challenges that exist because

124
00:04:11,930 --> 00:04:14,720
you might have some specific challenges

125
00:04:13,160 --> 00:04:17,418
depending on the target as you want to

126
00:04:14,720 --> 00:04:19,790
test going to mention three challenges

127
00:04:17,418 --> 00:04:21,169
that arise when you first open a closed

128
00:04:19,790 --> 00:04:23,180
source applications

129
00:04:21,170 --> 00:04:24,830
and the first challenge might actually

130
00:04:23,180 --> 00:04:27,620
sound stupid but if you think about it

131
00:04:24,830 --> 00:04:29,419
it's quite important because how can you

132
00:04:27,620 --> 00:04:31,130
Father be sure that no crash hairs are

133
00:04:29,420 --> 00:04:33,200
cured right so if you if you felt an

134
00:04:31,130 --> 00:04:35,240
application like md5sum which is a

135
00:04:33,200 --> 00:04:37,490
command line application what it does is

136
00:04:35,240 --> 00:04:39,530
it takes your file it calculates the the

137
00:04:37,490 --> 00:04:41,030
hair some prints it out and then exits

138
00:04:39,530 --> 00:04:42,619
so as soon as the program exits your

139
00:04:41,030 --> 00:04:44,750
father knows that it can start the next

140
00:04:42,620 --> 00:04:46,790
iteration of first testing so we have a

141
00:04:44,750 --> 00:04:48,410
metric to know now the program is done

142
00:04:46,790 --> 00:04:50,300
doing something that we want to test and

143
00:04:48,410 --> 00:04:52,250
we can start the next iteration if you

144
00:04:50,300 --> 00:04:53,930
test the PDF viewer PDF viewer has a

145
00:04:52,250 --> 00:04:56,570
graphical interface so what it does is

146
00:04:53,930 --> 00:04:58,730
it takes your PDF I pause the PDF

147
00:04:56,570 --> 00:05:00,349
renders the PDF displays it back to you

148
00:04:58,730 --> 00:05:02,180
and then waits for user input right word

149
00:05:00,350 --> 00:05:03,500
expects you to click on your something

150
00:05:02,180 --> 00:05:06,470
so it's not gonna close up there because

151
00:05:03,500 --> 00:05:08,210
this would be useless so for this PDF

152
00:05:06,470 --> 00:05:09,950
heroes or if as I has a problem because

153
00:05:08,210 --> 00:05:12,409
we never really know when it's actually

154
00:05:09,950 --> 00:05:13,670
done with parsing the PDF and when is

155
00:05:12,410 --> 00:05:15,050
when is it in the state of just

156
00:05:13,670 --> 00:05:17,210
displaying it back to you and that's not

157
00:05:15,050 --> 00:05:19,100
something that we watch with us another

158
00:05:17,210 --> 00:05:21,289
thing is we want to have root input

159
00:05:19,100 --> 00:05:22,940
generation and coverage feedback so

160
00:05:21,290 --> 00:05:24,950
input generation is really important

161
00:05:22,940 --> 00:05:27,740
because the behavior of our target

162
00:05:24,950 --> 00:05:29,120
depends solely on the input that we give

163
00:05:27,740 --> 00:05:32,090
it to right because it is trying to

164
00:05:29,120 --> 00:05:34,190
cross as our input and coverage feedback

165
00:05:32,090 --> 00:05:36,469
is basically a metric to determine if

166
00:05:34,190 --> 00:05:38,630
our input was useful or not because

167
00:05:36,470 --> 00:05:41,120
coverage feedback makes the program that

168
00:05:38,630 --> 00:05:42,980
we test export information about its

169
00:05:41,120 --> 00:05:45,170
execution with a certain input so

170
00:05:42,980 --> 00:05:47,030
coverage feedback is going it's going to

171
00:05:45,170 --> 00:05:49,250
make the program that we test to tell us

172
00:05:47,030 --> 00:05:51,679
I was started with this program air with

173
00:05:49,250 --> 00:05:54,920
his input and doing with his input I

174
00:05:51,680 --> 00:05:57,050
executed these code areas and by by

175
00:05:54,920 --> 00:05:58,610
seeing which code errors are executed we

176
00:05:57,050 --> 00:06:00,380
can determine of code areas have been

177
00:05:58,610 --> 00:06:02,090
executed that we have not seen in tested

178
00:06:00,380 --> 00:06:04,040
yet so we want to have court coverage

179
00:06:02,090 --> 00:06:05,840
feedback as well and obviously

180
00:06:04,040 --> 00:06:07,910
development least we want to have a high

181
00:06:05,840 --> 00:06:09,770
number of executions per second which is

182
00:06:07,910 --> 00:06:11,600
obvious because the more number of

183
00:06:09,770 --> 00:06:12,890
executions we have the more tests we can

184
00:06:11,600 --> 00:06:16,550
do in a given time frame I guess it's

185
00:06:12,890 --> 00:06:18,200
it's obvious so how do we do this for

186
00:06:16,550 --> 00:06:19,370
open source applications and for open

187
00:06:18,200 --> 00:06:20,960
source applications we have very good

188
00:06:19,370 --> 00:06:22,940
news because obviously we do have the

189
00:06:20,960 --> 00:06:24,380
source code right so what we can do is

190
00:06:22,940 --> 00:06:26,660
we are able to change the source code to

191
00:06:24,380 --> 00:06:28,520
our needs so we are able to change the

192
00:06:26,660 --> 00:06:30,860
source code so that the program behaves

193
00:06:28,520 --> 00:06:34,520
in a way that makes it easier for us to

194
00:06:30,860 --> 00:06:35,870
fast test it what we can do is we can

195
00:06:34,520 --> 00:06:37,639
use of a concept that is called static

196
00:06:35,870 --> 00:06:39,919
binary instrumentation and it basically

197
00:06:37,639 --> 00:06:42,080
works by adding booking or replacing

198
00:06:39,919 --> 00:06:44,210
existing functions these at compile time

199
00:06:42,080 --> 00:06:45,770
or and source code itself and what's the

200
00:06:44,210 --> 00:06:48,229
instrumentation that we apply to this

201
00:06:45,770 --> 00:06:50,090
binary does is it takes care of creating

202
00:06:48,229 --> 00:06:51,859
program traces and the pro template is

203
00:06:50,090 --> 00:06:53,840
basically a set which contains

204
00:06:51,860 --> 00:06:55,580
information about the code coverage and

205
00:06:53,840 --> 00:06:56,979
possibly the memory management depending

206
00:06:55,580 --> 00:06:59,030
on the implementation the

207
00:06:56,979 --> 00:07:01,460
instrumentation is then going to lock

208
00:06:59,030 --> 00:07:03,049
the traces that we are created on disk

209
00:07:01,460 --> 00:07:06,469
that your father is able to read them in

210
00:07:03,050 --> 00:07:08,150
and correlate a given input to come

211
00:07:06,470 --> 00:07:11,210
through the trace and then see if the

212
00:07:08,150 --> 00:07:13,669
input was actually useful or not cool

213
00:07:11,210 --> 00:07:15,500
thing about this is we have pre-existing

214
00:07:13,669 --> 00:07:17,240
tools like ether sanitizer or Aysen

215
00:07:15,500 --> 00:07:18,860
which is basically a compiler extension

216
00:07:17,240 --> 00:07:20,840
all you need to do is you have to

217
00:07:18,860 --> 00:07:22,970
recompile your program with eizan's

218
00:07:20,840 --> 00:07:24,799
to compiler flex and a syn we compile

219
00:07:22,970 --> 00:07:26,870
the program and instrument it at compile

220
00:07:24,800 --> 00:07:28,130
time for you the overhead of Aysen or

221
00:07:26,870 --> 00:07:29,509
for the program that we have

222
00:07:28,130 --> 00:07:32,030
instrumented is quite low that's only

223
00:07:29,509 --> 00:07:33,319
factor two so that's not too much to

224
00:07:32,030 --> 00:07:35,388
give you a better idea of how a syn

225
00:07:33,319 --> 00:07:37,129
actually works so this is an

226
00:07:35,389 --> 00:07:39,440
uninstrumented program as we see

227
00:07:37,129 --> 00:07:43,250
depending on the input it's either going

228
00:07:39,440 --> 00:07:45,139
to call ABC or only D or only a write

229
00:07:43,250 --> 00:07:47,930
that what the program is doing and if

230
00:07:45,139 --> 00:07:50,090
you compile it with Aysen as such we see

231
00:07:47,930 --> 00:07:52,370
that in each basic block it has added a

232
00:07:50,090 --> 00:07:55,460
call to another function which is here

233
00:07:52,370 --> 00:07:56,750
sanitized and this extra call makes the

234
00:07:55,460 --> 00:07:59,150
text care of creating this program

235
00:07:56,750 --> 00:08:00,770
traces and writes entities and all we

236
00:07:59,150 --> 00:08:04,638
have to do for this is we compile a

237
00:08:00,770 --> 00:08:07,549
program and add to compile expert so

238
00:08:04,639 --> 00:08:08,960
that's really really easy if we do not

239
00:08:07,550 --> 00:08:11,750
have the source code we actually have a

240
00:08:08,960 --> 00:08:13,729
problem but we can possibly make use of

241
00:08:11,750 --> 00:08:15,139
dynamic binary instrumentation I'm not

242
00:08:13,729 --> 00:08:17,750
going to dig too deep into this I

243
00:08:15,139 --> 00:08:20,270
basically worked by injecting arbitrary

244
00:08:17,750 --> 00:08:21,919
code into an already running process and

245
00:08:20,270 --> 00:08:23,599
the injected code is then running in

246
00:08:21,919 --> 00:08:25,250
parallel with the original code and then

247
00:08:23,599 --> 00:08:28,279
takes care for creating this program

248
00:08:25,250 --> 00:08:31,069
traces field we do not need the source

249
00:08:28,279 --> 00:08:32,719
code that's good and we have already

250
00:08:31,069 --> 00:08:34,310
existing in frameworks with this so the

251
00:08:32,719 --> 00:08:36,680
most popular that I know is input pin

252
00:08:34,309 --> 00:08:39,289
and in amarillo the only issue is that

253
00:08:36,679 --> 00:08:41,029
it causes a significant overhead at

254
00:08:39,289 --> 00:08:41,828
least in the way that that I have used

255
00:08:41,029 --> 00:08:43,969
it so far

256
00:08:41,828 --> 00:08:45,829
we will let us see how public the

257
00:08:43,969 --> 00:08:48,150
overhead actually is

258
00:08:45,830 --> 00:08:49,980
to give you an idea of how such a trace

259
00:08:48,150 --> 00:08:51,420
mind might look like here we see a

260
00:08:49,980 --> 00:08:52,500
sandwich face that was created within

261
00:08:51,420 --> 00:08:55,860
Amarillo

262
00:08:52,500 --> 00:08:58,170
so we see each shared object that was

263
00:08:55,860 --> 00:08:59,190
loaded by the binary at one time so we

264
00:08:58,170 --> 00:09:00,630
see each DLL

265
00:08:59,190 --> 00:09:03,180
we see the base notice of the D layer

266
00:09:00,630 --> 00:09:06,780
and it gives us a unique identifier and

267
00:09:03,180 --> 00:09:08,819
then we see which basic blocks have ever

268
00:09:06,780 --> 00:09:10,890
been executed by the original order of

269
00:09:08,820 --> 00:09:13,710
the basic blocks are retained so we see

270
00:09:10,890 --> 00:09:15,840
that in the first basic block that has

271
00:09:13,710 --> 00:09:17,880
ever been executed is a module 13 which

272
00:09:15,840 --> 00:09:19,170
is anti dll out here and then we see the

273
00:09:17,880 --> 00:09:20,189
next basic block that has been executed

274
00:09:19,170 --> 00:09:22,170
and so on and so on

275
00:09:20,190 --> 00:09:23,550
so it gives us a really good feedback

276
00:09:22,170 --> 00:09:25,579
about what actually happened in the

277
00:09:23,550 --> 00:09:28,319
program and we would later be using it

278
00:09:25,580 --> 00:09:30,120
so ok but back to the problems that we

279
00:09:28,320 --> 00:09:33,390
that we had 4,000 closed with

280
00:09:30,120 --> 00:09:35,400
applications as I said programs that do

281
00:09:33,390 --> 00:09:36,900
not return our problem for the reason

282
00:09:35,400 --> 00:09:38,250
that we don't know when can we kill it

283
00:09:36,900 --> 00:09:40,470
when do when can we start the next

284
00:09:38,250 --> 00:09:41,700
iteration of first testing for open

285
00:09:40,470 --> 00:09:43,770
source applications again that's not a

286
00:09:41,700 --> 00:09:44,880
big problem because we have the source

287
00:09:43,770 --> 00:09:47,310
code so all we need to do is read the

288
00:09:44,880 --> 00:09:49,290
source code obviously the Afghanistan to

289
00:09:47,310 --> 00:09:51,660
source code find the end of the parsing

290
00:09:49,290 --> 00:09:53,550
routine at an exit we compile the

291
00:09:51,660 --> 00:09:54,839
program and problems basically solved

292
00:09:53,550 --> 00:09:56,250
right because a PDF II was going to

293
00:09:54,840 --> 00:09:59,910
create just at the time that when we

294
00:09:56,250 --> 00:10:02,040
wanted to flow if we don't have the

295
00:09:59,910 --> 00:10:04,829
source code it can't be compared

296
00:10:02,040 --> 00:10:07,349
obviously and we can't apply changes to

297
00:10:04,830 --> 00:10:09,990
it on it on source code 11 so what I've

298
00:10:07,350 --> 00:10:11,790
seen most researchers doing is they kind

299
00:10:09,990 --> 00:10:13,710
of guess when the PDF is done rendering

300
00:10:11,790 --> 00:10:15,569
right so they start the PDF viewer and

301
00:10:13,710 --> 00:10:17,670
then estimate you know I think after 3 4

302
00:10:15,570 --> 00:10:19,470
5 seconds whatever the viewer should see

303
00:10:17,670 --> 00:10:22,199
done rendering and I tell my father to

304
00:10:19,470 --> 00:10:24,780
as Hume that nothing that happened and I

305
00:10:22,200 --> 00:10:26,460
kill the program so they make use of

306
00:10:24,780 --> 00:10:28,170
half quarter timeouts which is obviously

307
00:10:26,460 --> 00:10:30,060
not a good idea because the timeouts on

308
00:10:28,170 --> 00:10:31,620
wall as guessed which basically means

309
00:10:30,060 --> 00:10:33,030
that the determination either happens

310
00:10:31,620 --> 00:10:35,100
too early which means there would be

311
00:10:33,030 --> 00:10:36,540
more code to be executed but we never

312
00:10:35,100 --> 00:10:39,540
reach it because we kill the program too

313
00:10:36,540 --> 00:10:42,150
early or we kill it too late that would

314
00:10:39,540 --> 00:10:43,319
mean that we raised CPU cycles right and

315
00:10:42,150 --> 00:10:44,490
as we've seen earlier like we want to

316
00:10:43,320 --> 00:10:47,040
have a high number of executions per

317
00:10:44,490 --> 00:10:49,260
second we could also try to measure the

318
00:10:47,040 --> 00:10:50,790
CPU cycle that a program takes so we

319
00:10:49,260 --> 00:10:53,130
could possibly start the PDF you are

320
00:10:50,790 --> 00:10:54,839
measure how many CPU cycles it takes and

321
00:10:53,130 --> 00:10:56,340
when the amount of CPU cycles goes down

322
00:10:54,840 --> 00:10:57,200
we can assume that it's not really doing

323
00:10:56,340 --> 00:10:58,910
anything

324
00:10:57,200 --> 00:11:01,040
I tried this I didn't find it precise

325
00:10:58,910 --> 00:11:02,900
and at the same time by constantly

326
00:11:01,040 --> 00:11:05,620
pulling this you could see the CPU cycle

327
00:11:02,900 --> 00:11:08,540
of a program you create overhead as well

328
00:11:05,620 --> 00:11:10,520
so here's what I try to do so what I try

329
00:11:08,540 --> 00:11:12,290
to do is I find I would try to find out

330
00:11:10,520 --> 00:11:14,240
if there is a basic block in this

331
00:11:12,290 --> 00:11:16,459
program that is always executed but

332
00:11:14,240 --> 00:11:18,320
always executed last for each four

333
00:11:16,460 --> 00:11:19,850
different inputs because if there is

334
00:11:18,320 --> 00:11:22,220
such a basic block I can assume that

335
00:11:19,850 --> 00:11:24,740
this basic block is executed only if the

336
00:11:22,220 --> 00:11:27,110
parsing routine is finished and that

337
00:11:24,740 --> 00:11:29,570
perhaps weights and blocks for GUI

338
00:11:27,110 --> 00:11:30,950
events or more user input it is

339
00:11:29,570 --> 00:11:32,630
important that this basic block is

340
00:11:30,950 --> 00:11:34,460
triggered without any user interaction

341
00:11:32,630 --> 00:11:36,430
so to give you an idea of what I'm

342
00:11:34,460 --> 00:11:41,390
trying to find so we have the sample

343
00:11:36,430 --> 00:11:44,060
call graph and so for the first trace

344
00:11:41,390 --> 00:11:46,939
the PDF here would go like a BEF and a

345
00:11:44,060 --> 00:11:48,770
PDF and in the end a CF and what we can

346
00:11:46,940 --> 00:11:52,070
see is that the PDF you are always start

347
00:11:48,770 --> 00:11:55,550
at Point F right so it never too big as

348
00:11:52,070 --> 00:11:57,560
G or H after F so my goal would he be to

349
00:11:55,550 --> 00:11:59,359
find out the location of basic block F

350
00:11:57,560 --> 00:12:01,160
and then patch it so that program

351
00:11:59,360 --> 00:12:04,070
actually closes itself gets the

352
00:12:01,160 --> 00:12:05,930
attention behind and to do this what I

353
00:12:04,070 --> 00:12:07,700
do is I create program traces of the

354
00:12:05,930 --> 00:12:10,160
viewer with a different or valid input

355
00:12:07,700 --> 00:12:11,810
and the traces contain the executed

356
00:12:10,160 --> 00:12:14,209
basic blocks in the original order and

357
00:12:11,810 --> 00:12:16,699
then I calculate the intersection of all

358
00:12:14,210 --> 00:12:18,440
traces so that I end up with one set of

359
00:12:16,700 --> 00:12:20,450
basic blocks that appear in each of

360
00:12:18,440 --> 00:12:22,010
these form traces and choose the last

361
00:12:20,450 --> 00:12:24,470
basic block and apply some

362
00:12:22,010 --> 00:12:25,730
instrumentation to it obviously why we

363
00:12:24,470 --> 00:12:28,250
perform the tracing we must make sure

364
00:12:25,730 --> 00:12:29,690
not to apply any events on the grid

365
00:12:28,250 --> 00:12:30,980
because otherwise you would end up on a

366
00:12:29,690 --> 00:12:34,340
basic block that cannot be reached

367
00:12:30,980 --> 00:12:35,660
without user interaction as an

368
00:12:34,340 --> 00:12:37,910
implementation what I did has used

369
00:12:35,660 --> 00:12:39,680
anomaly you as you've seen earlier and I

370
00:12:37,910 --> 00:12:42,319
assumed that a PDF viewer would be done

371
00:12:39,680 --> 00:12:44,510
passing after 30 seconds I think it

372
00:12:42,320 --> 00:12:45,800
should be done after 30 seconds and then

373
00:12:44,510 --> 00:12:47,270
I passed the output that we've seen

374
00:12:45,800 --> 00:12:48,829
earlier and calculated the intersection

375
00:12:47,270 --> 00:12:50,990
with pipe which is not actually worth

376
00:12:48,830 --> 00:12:52,640
mentioning here and then finally I have

377
00:12:50,990 --> 00:12:54,830
a recite which is the last basic block

378
00:12:52,640 --> 00:12:56,300
which is executed each trace so now what

379
00:12:54,830 --> 00:12:58,220
I want to do is I want to patch this

380
00:12:56,300 --> 00:13:00,920
basic block and erase that it fast

381
00:12:58,220 --> 00:13:03,590
creates the program itself there's a

382
00:13:00,920 --> 00:13:05,360
problem like how do i patch this this

383
00:13:03,590 --> 00:13:07,040
basic block and assembly level without

384
00:13:05,360 --> 00:13:08,570
corrupting the entire execution and

385
00:13:07,040 --> 00:13:11,180
binary

386
00:13:08,570 --> 00:13:12,500
because in exit process on a 32-bit

387
00:13:11,180 --> 00:13:13,819
machine might look something like this

388
00:13:12,500 --> 00:13:17,300
right so you're not allowed to register

389
00:13:13,820 --> 00:13:18,560
push it on the stack push the address of

390
00:13:17,300 --> 00:13:21,920
exit process on the stack and then

391
00:13:18,560 --> 00:13:24,619
return so this is this this issue is

392
00:13:21,920 --> 00:13:26,060
that you call exit process with zero the

393
00:13:24,620 --> 00:13:28,010
problem is that this course template

394
00:13:26,060 --> 00:13:29,810
would be nine bytes in size but what

395
00:13:28,010 --> 00:13:31,340
would happen if the basic block that we

396
00:13:29,810 --> 00:13:32,510
have chosen is not nine bytes

397
00:13:31,340 --> 00:13:34,370
those would basically mean that we

398
00:13:32,510 --> 00:13:35,900
overwrite instructions that are behind

399
00:13:34,370 --> 00:13:37,790
the basic block which would mean that we

400
00:13:35,900 --> 00:13:39,110
would corrupt the binary so we have to

401
00:13:37,790 --> 00:13:42,349
make sure that the instrumentation that

402
00:13:39,110 --> 00:13:43,790
we apply is as small as possible and the

403
00:13:42,350 --> 00:13:46,280
first approach that I came up with for

404
00:13:43,790 --> 00:13:48,890
this is that I add a new executable

405
00:13:46,280 --> 00:13:50,600
section to the PE file which is good

406
00:13:48,890 --> 00:13:52,670
because the section has a static address

407
00:13:50,600 --> 00:13:55,160
so I know where it is and this section

408
00:13:52,670 --> 00:13:57,589
contains the exit process routine and

409
00:13:55,160 --> 00:13:59,420
all I have to do is I have to jump to

410
00:13:57,590 --> 00:14:00,800
this basic block which saves me three

411
00:13:59,420 --> 00:14:02,300
baths all I have to do is push the

412
00:14:00,800 --> 00:14:04,490
Edwards off section address and then

413
00:14:02,300 --> 00:14:07,160
return so this saves me three bytes on

414
00:14:04,490 --> 00:14:09,280
now at six bytes that's not enough we

415
00:14:07,160 --> 00:14:11,449
will let us see how we can do it better

416
00:14:09,280 --> 00:14:12,920
first you might be asking yourself why

417
00:14:11,450 --> 00:14:14,210
so complicated why do you want to catch

418
00:14:12,920 --> 00:14:14,750
an exit process we're at the mosque an

419
00:14:14,210 --> 00:14:18,020
easier way

420
00:14:14,750 --> 00:14:21,560
yeah they would later see what it is why

421
00:14:18,020 --> 00:14:23,569
I do it is because existing fathers rely

422
00:14:21,560 --> 00:14:25,430
usually on most photos that I know rely

423
00:14:23,570 --> 00:14:28,880
on the fact that a program returns and

424
00:14:25,430 --> 00:14:30,530
by making the program's returning I can

425
00:14:28,880 --> 00:14:31,970
make sure that I am able to use fuzzles

426
00:14:30,530 --> 00:14:33,800
that already exists them which might be

427
00:14:31,970 --> 00:14:37,340
better than my own crappy implementation

428
00:14:33,800 --> 00:14:40,280
right so that's the intention behind the

429
00:14:37,340 --> 00:14:43,040
exit process if you want to applies kind

430
00:14:40,280 --> 00:14:44,329
of instrumentation I would tell you not

431
00:14:43,040 --> 00:14:44,719
to do it by hand this is a true first

432
00:14:44,330 --> 00:14:46,850
trading

433
00:14:44,720 --> 00:14:48,770
rather make use of leaf which is a

434
00:14:46,850 --> 00:14:50,120
library called which is a library

435
00:14:48,770 --> 00:14:52,220
developed like Fox there

436
00:14:50,120 --> 00:14:54,050
it literally means library to instrument

437
00:14:52,220 --> 00:14:56,480
execute a performance so that's exactly

438
00:14:54,050 --> 00:14:58,880
what you want to do and to give an idea

439
00:14:56,480 --> 00:15:01,370
of how it works so first we get a handle

440
00:14:58,880 --> 00:15:01,970
to the TV file then we create new

441
00:15:01,370 --> 00:15:04,820
sections

442
00:15:01,970 --> 00:15:07,130
apply certain characteristics file such

443
00:15:04,820 --> 00:15:10,100
as mega decks cuticles and we add the

444
00:15:07,130 --> 00:15:12,470
byte that encodes the instructions for

445
00:15:10,100 --> 00:15:15,890
our exit process routine and then add

446
00:15:12,470 --> 00:15:18,470
the section to our binary and then ask

447
00:15:15,890 --> 00:15:20,480
if to read the library and to rebuild

448
00:15:18,470 --> 00:15:21,779
the binary I don't know how if does it

449
00:15:20,480 --> 00:15:25,079
in the background but

450
00:15:21,779 --> 00:15:27,209
that's good but again so why it's so

451
00:15:25,079 --> 00:15:28,949
complicated why do we have a protect to

452
00:15:27,209 --> 00:15:30,508
Apache next proces and as I said I'm

453
00:15:28,949 --> 00:15:34,050
trying to make use of existing far as

454
00:15:30,509 --> 00:15:36,060
possible but as in my case I wanted to

455
00:15:34,050 --> 00:15:38,490
write my own Houser anyway so what I can

456
00:15:36,060 --> 00:15:40,829
do is I override this basic block not

457
00:15:38,490 --> 00:15:42,300
with exit process but with a break point

458
00:15:40,829 --> 00:15:45,689
and a break point is a one byte

459
00:15:42,300 --> 00:15:47,339
instruction in 32-bit with hex cc all I

460
00:15:45,689 --> 00:15:49,259
need to do is write a new father that is

461
00:15:47,339 --> 00:15:51,899
aware of the grapevine that appears in

462
00:15:49,259 --> 00:15:53,339
our binary which most fathers are not

463
00:15:51,899 --> 00:15:54,360
aware of but if you want to implement

464
00:15:53,339 --> 00:15:57,360
your own father from scratch in that

465
00:15:54,360 --> 00:15:58,620
that's something that you can do in the

466
00:15:57,360 --> 00:16:00,300
end of future if you have chosen to

467
00:15:58,620 --> 00:16:02,309
write the exit process congratulations

468
00:16:00,300 --> 00:16:03,899
you created a completely useless PDF

469
00:16:02,309 --> 00:16:06,329
viewer right but close it so you will

470
00:16:03,899 --> 00:16:08,220
never be able to use it again but you

471
00:16:06,329 --> 00:16:09,599
will be able to fuzz it better I wanted

472
00:16:08,220 --> 00:16:11,579
to give you a live demo of this but then

473
00:16:09,600 --> 00:16:14,939
I decided that a PDF viewer that closes

474
00:16:11,579 --> 00:16:16,290
that if it's not so interesting so on

475
00:16:14,939 --> 00:16:18,660
the left side received a basic block

476
00:16:16,290 --> 00:16:21,050
which is not instrumented on the right

477
00:16:18,660 --> 00:16:23,850
side we see the a very clean in scratch

478
00:16:21,050 --> 00:16:25,769
very clean instrumentation so the last

479
00:16:23,850 --> 00:16:27,809
two instructions are basically I push

480
00:16:25,769 --> 00:16:31,620
the address of our section and then

481
00:16:27,809 --> 00:16:33,240
returns the jump back to our edit

482
00:16:31,620 --> 00:16:35,699
executable sections so that's good

483
00:16:33,240 --> 00:16:37,410
because now existing files do not need

484
00:16:35,699 --> 00:16:39,599
to fall squid anymore we can make use of

485
00:16:37,410 --> 00:16:41,670
existing father's and we ensure that our

486
00:16:39,600 --> 00:16:42,899
PDF you are scaling itself just at the

487
00:16:41,670 --> 00:16:45,329
right time

488
00:16:42,899 --> 00:16:47,490
I oughta mated this process so I

489
00:16:45,329 --> 00:16:49,559
implemented a tool that automates all

490
00:16:47,490 --> 00:16:51,449
these steps and then I ran it on various

491
00:16:49,559 --> 00:16:53,339
PDF and image viewers just suggest if it

492
00:16:51,449 --> 00:16:55,258
actually works and worked out for most

493
00:16:53,339 --> 00:16:56,879
surprisingly so it worked out for Foxit

494
00:16:55,259 --> 00:17:00,389
reader pdf-xchange viewer and other

495
00:16:56,879 --> 00:17:01,829
viewers but not for adults and i am

496
00:17:00,389 --> 00:17:03,720
honestly i don't really know why did not

497
00:17:01,829 --> 00:17:05,158
look for a dog i assume that it is

498
00:17:03,720 --> 00:17:07,500
because a dope is running in its own

499
00:17:05,159 --> 00:17:09,510
sandbox and against the number of fails

500
00:17:07,500 --> 00:17:11,250
to create protein traces for programs

501
00:17:09,510 --> 00:17:14,549
that are running its own sandbox at

502
00:17:11,250 --> 00:17:16,589
least what I think so now we basically

503
00:17:14,549 --> 00:17:18,809
solve the first problem right so we are

504
00:17:16,589 --> 00:17:21,329
sure that the program is closing itself

505
00:17:18,809 --> 00:17:22,859
just after it has executed the program

506
00:17:21,329 --> 00:17:25,619
areas that we are actually interested in

507
00:17:22,859 --> 00:17:27,148
fuzz on to our second problem as I said

508
00:17:25,619 --> 00:17:28,049
we're going to have input generation and

509
00:17:27,148 --> 00:17:30,899
code coverage

510
00:17:28,049 --> 00:17:33,750
input generation because with behavior

511
00:17:30,899 --> 00:17:34,300
of our fuzzy possible target depends on

512
00:17:33,750 --> 00:17:36,550
the

513
00:17:34,300 --> 00:17:39,129
that we give it and code covers or

514
00:17:36,550 --> 00:17:42,250
metric to determine if the input is

515
00:17:39,130 --> 00:17:44,470
actually value or not so first how can

516
00:17:42,250 --> 00:17:47,020
we get input what can we do to get

517
00:17:44,470 --> 00:17:48,610
samples and the first thing that I've

518
00:17:47,020 --> 00:17:50,230
seen people doing is let us just read

519
00:17:48,610 --> 00:17:52,629
some bite from deftly random and pretend

520
00:17:50,230 --> 00:17:54,220
it's a PDF it's obviously not gonna work

521
00:17:52,630 --> 00:17:56,890
we could also let's try to specify

522
00:17:54,220 --> 00:17:59,650
certain grammar rules for our input

523
00:17:56,890 --> 00:18:01,330
generator so we generate input from

524
00:17:59,650 --> 00:18:03,460
scratch and specify certain rules and

525
00:18:01,330 --> 00:18:05,830
how the input should look like so what

526
00:18:03,460 --> 00:18:08,260
we do is we specify you like if you want

527
00:18:05,830 --> 00:18:10,540
to create an HTML document it has always

528
00:18:08,260 --> 00:18:12,550
to start with the opening HTML tag and

529
00:18:10,540 --> 00:18:15,370
it has always to end with the closing

530
00:18:12,550 --> 00:18:17,110
HTML tag we could possibly make use of

531
00:18:15,370 --> 00:18:18,669
genetic passing which basically means

532
00:18:17,110 --> 00:18:20,889
that we try to learn the file format on

533
00:18:18,670 --> 00:18:24,070
the fly so we give the input and we give

534
00:18:20,890 --> 00:18:25,570
our target some random bytes see if it

535
00:18:24,070 --> 00:18:27,040
triggered any code areas that we have

536
00:18:25,570 --> 00:18:29,050
not seen yet and try and try to

537
00:18:27,040 --> 00:18:32,980
correlate the bite that we gave it

538
00:18:29,050 --> 00:18:34,510
through the to the basic block would

539
00:18:32,980 --> 00:18:36,630
happen execute it and then slowly try to

540
00:18:34,510 --> 00:18:38,890
understand the file format from scratch

541
00:18:36,630 --> 00:18:41,080
what we can also do is we can make use

542
00:18:38,890 --> 00:18:42,910
of mutation based input generation which

543
00:18:41,080 --> 00:18:44,679
basically means that we take input of

544
00:18:42,910 --> 00:18:47,260
which we know that it's valid and then

545
00:18:44,680 --> 00:18:48,850
corrupted so basically we take a PDF or

546
00:18:47,260 --> 00:18:51,580
which we know that it's valid corrupt it

547
00:18:48,850 --> 00:18:53,139
and give it to our PDF here so let us

548
00:18:51,580 --> 00:18:55,120
first look take a look at our random

549
00:18:53,140 --> 00:18:58,390
input approach and that's usually

550
00:18:55,120 --> 00:19:01,479
completely useless because the idea of a

551
00:18:58,390 --> 00:19:03,910
file format is where to specify that our

552
00:19:01,480 --> 00:19:06,430
bytes must have a certain pattern so for

553
00:19:03,910 --> 00:19:08,140
example a PDF the file format of a PDF

554
00:19:06,430 --> 00:19:11,170
says that it always has to start with

555
00:19:08,140 --> 00:19:13,360
PDF at least we bite if these three

556
00:19:11,170 --> 00:19:14,620
bytes do not accurate when a PDF you is

557
00:19:13,360 --> 00:19:17,110
going to tell you that's what you know

558
00:19:14,620 --> 00:19:19,209
PS I'm not going I'm not even trying to

559
00:19:17,110 --> 00:19:20,949
render it for you this so in our process

560
00:19:19,210 --> 00:19:23,260
we would never be able to hit the

561
00:19:20,950 --> 00:19:25,300
process function and even less likely we

562
00:19:23,260 --> 00:19:28,690
would be able to find it back on the

563
00:19:25,300 --> 00:19:30,909
process function right what I prefer

564
00:19:28,690 --> 00:19:32,530
doing is I prefer making use of a

565
00:19:30,910 --> 00:19:34,660
concept that we call mutation based on

566
00:19:32,530 --> 00:19:38,410
post as I said I take a PDF which I know

567
00:19:34,660 --> 00:19:39,610
it's valid we apply certain corruptions

568
00:19:38,410 --> 00:19:42,550
to it and then filled with the PDF

569
00:19:39,610 --> 00:19:43,959
viewer the problem is which PDF do we

570
00:19:42,550 --> 00:19:45,460
choose or which PDFs do we choose

571
00:19:43,960 --> 00:19:46,880
because the PDF is a really really

572
00:19:45,460 --> 00:19:48,740
mighty fire from that right

573
00:19:46,880 --> 00:19:51,440
do a lot of things that can do a stuff

574
00:19:48,740 --> 00:19:54,200
like it has checkboxes it has can verify

575
00:19:51,440 --> 00:19:56,390
a digital signatures it has 3d objects

576
00:19:54,200 --> 00:19:58,190
in it and so on and so on and we want to

577
00:19:56,390 --> 00:20:00,080
have input that covers basically all of

578
00:19:58,190 --> 00:20:03,140
this and you will never be able to find

579
00:20:00,080 --> 00:20:06,889
a PDF that covers all of these functions

580
00:20:03,140 --> 00:20:09,080
so and at the same time you don't want

581
00:20:06,890 --> 00:20:10,190
to scroll through all the PDFs that you

582
00:20:09,080 --> 00:20:11,720
might find on the Internet

583
00:20:10,190 --> 00:20:14,420
just to find out if there's a PDF that

584
00:20:11,720 --> 00:20:16,220
trigger something new at the same time

585
00:20:14,420 --> 00:20:18,140
the way to a won't avoid redundancy

586
00:20:16,220 --> 00:20:20,450
which basically means we have two PDFs

587
00:20:18,140 --> 00:20:22,790
in our test set which trigger the exact

588
00:20:20,450 --> 00:20:24,680
same behavior in our PDF because this

589
00:20:22,790 --> 00:20:26,060
would be redundant the same behaviors

590
00:20:24,680 --> 00:20:30,310
trigger twice we would be ending up

591
00:20:26,060 --> 00:20:32,840
trigger testing the same behavior twice

592
00:20:30,310 --> 00:20:34,340
so in order to overcome this issue

593
00:20:32,840 --> 00:20:36,740
there's a approach for this which is

594
00:20:34,340 --> 00:20:38,629
called corpus distillation and corpus

595
00:20:36,740 --> 00:20:40,550
installation basically works by first

596
00:20:38,630 --> 00:20:43,190
collecting a huge number of vetted

597
00:20:40,550 --> 00:20:45,200
caucuses in my case I took 80,000 PDF

598
00:20:43,190 --> 00:20:45,950
files simply by quoting the internet and

599
00:20:45,200 --> 00:20:47,360
gets on TV a lot

600
00:20:45,950 --> 00:20:49,490
so I've seen researchers collecting

601
00:20:47,360 --> 00:20:51,490
around millions of PFS and millions of

602
00:20:49,490 --> 00:20:52,910
different input samples and then doing

603
00:20:51,490 --> 00:20:55,760
conversational errors

604
00:20:52,910 --> 00:20:57,350
so first how can we get those inputs we

605
00:20:55,760 --> 00:20:59,480
could possibly make use of search

606
00:20:57,350 --> 00:21:01,340
engines so we crawl the internet or use

607
00:20:59,480 --> 00:21:03,980
test sets of open source PDF viewers

608
00:21:01,340 --> 00:21:06,679
such as PDF um they export a PDF that

609
00:21:03,980 --> 00:21:08,420
they test at their product and then we

610
00:21:06,680 --> 00:21:08,960
measure the code coverage for each

611
00:21:08,420 --> 00:21:11,000
caucus

612
00:21:08,960 --> 00:21:14,570
so for each PDF that is in our tester

613
00:21:11,000 --> 00:21:16,910
and so I start a PDF viewer with once

614
00:21:14,570 --> 00:21:19,399
with each PDF and then get the code

615
00:21:16,910 --> 00:21:20,810
coverage and check if a new behavior was

616
00:21:19,400 --> 00:21:23,150
to figure out if any new basic blocks

617
00:21:20,810 --> 00:21:25,610
have been executed if this is not the

618
00:21:23,150 --> 00:21:27,800
case so if this PDF chili got a behavior

619
00:21:25,610 --> 00:21:30,229
that I've seen already by a previous PDF

620
00:21:27,800 --> 00:21:32,930
I can kick out this PDF because this

621
00:21:30,230 --> 00:21:35,720
would be redundant PDF in our corpus

622
00:21:32,930 --> 00:21:38,390
so in the end if you do this you end up

623
00:21:35,720 --> 00:21:40,070
with a set of PDFs of which each

624
00:21:38,390 --> 00:21:42,320
triggers are unique behavior in your PDF

625
00:21:40,070 --> 00:21:46,429
you want and at the same time it avoids

626
00:21:42,320 --> 00:21:48,679
redundancy in your periods so as I said

627
00:21:46,430 --> 00:21:50,420
we need code coverage to do this corpus

628
00:21:48,680 --> 00:21:52,160
oscillation approach obviously you

629
00:21:50,420 --> 00:21:54,860
protein source no problem just will

630
00:21:52,160 --> 00:21:56,510
compile the program with Asian but what

631
00:21:54,860 --> 00:21:58,370
what happens if we don't have a source

632
00:21:56,510 --> 00:21:59,870
code you could possibly try to apply the

633
00:21:58,370 --> 00:22:00,959
same instrumentation on assembly level

634
00:21:59,870 --> 00:22:03,060
as

635
00:22:00,960 --> 00:22:04,860
but as we've seen earlier is really easy

636
00:22:03,060 --> 00:22:07,620
to corrupt a binary by doing some

637
00:22:04,860 --> 00:22:09,449
assembly magic so we could possibly make

638
00:22:07,620 --> 00:22:11,159
use of dynamic manner instrumentation

639
00:22:09,450 --> 00:22:14,010
right si plus for our first problem by

640
00:22:11,160 --> 00:22:16,500
warner/chappell for a second problem and

641
00:22:14,010 --> 00:22:19,320
as I said earlier the problem is speed

642
00:22:16,500 --> 00:22:22,050
or it is performance so to show you how

643
00:22:19,320 --> 00:22:24,000
big the overhead actually is I patched

644
00:22:22,050 --> 00:22:25,740
oxygen vida which is a random pdf/ua

645
00:22:24,000 --> 00:22:27,180
with the auto access codes that I

646
00:22:25,740 --> 00:22:28,920
mentioned earlier and then measure the

647
00:22:27,180 --> 00:22:31,470
time until exit process was finally

648
00:22:28,920 --> 00:22:33,960
called and the uninstrumented version of

649
00:22:31,470 --> 00:22:36,300
Huck's Rita took around 1.5 seconds to

650
00:22:33,960 --> 00:22:38,790
call exit process while with ginamarie

651
00:22:36,300 --> 00:22:40,710
oh it took 6 or 4 seconds so that's an

652
00:22:38,790 --> 00:22:42,270
overhead of almost 5 seconds and that's

653
00:22:40,710 --> 00:22:43,620
obviously nothing that we can use for

654
00:22:42,270 --> 00:22:46,590
fuzzing because we want to have a high

655
00:22:43,620 --> 00:22:48,629
number of executions per second so if

656
00:22:46,590 --> 00:22:50,730
you want to do Corpus installation with

657
00:22:48,630 --> 00:22:53,760
dynamo Rio it would take you six days

658
00:22:50,730 --> 00:22:56,400
for 80k PDFs that's way too long at the

659
00:22:53,760 --> 00:22:58,050
same time as I said educate PDF is not

660
00:22:56,400 --> 00:23:01,500
even enough you want to have millions of

661
00:22:58,050 --> 00:23:03,060
PDFs and you said ok so let's try to get

662
00:23:01,500 --> 00:23:05,730
a bit creative so what can we possibly

663
00:23:03,060 --> 00:23:07,169
do we could possibly try as I said to

664
00:23:05,730 --> 00:23:09,150
apply this instrumentation on assembly

665
00:23:07,170 --> 00:23:11,520
level but we've seen it's very easy to

666
00:23:09,150 --> 00:23:13,770
go up the vinery by changing the

667
00:23:11,520 --> 00:23:15,420
instructions on assembly level at the

668
00:23:13,770 --> 00:23:17,220
same time we would have to fix all of a

669
00:23:15,420 --> 00:23:19,680
lot of jumps and relocate instructions

670
00:23:17,220 --> 00:23:21,810
and whatnot I don't want to do this so

671
00:23:19,680 --> 00:23:24,120
we basically need an instrumentation

672
00:23:21,810 --> 00:23:25,860
approach for basic block coverage the

673
00:23:24,120 --> 00:23:27,840
less bytes we have to change the better

674
00:23:25,860 --> 00:23:29,909
because less likely we are to corrupt a

675
00:23:27,840 --> 00:23:31,530
binary and obviously it must be very

676
00:23:29,910 --> 00:23:35,130
performance and scaling at the same time

677
00:23:31,530 --> 00:23:36,990
and away in own approach that exists for

678
00:23:35,130 --> 00:23:38,850
this is that we make use of breakpoints

679
00:23:36,990 --> 00:23:41,340
again so as I said a break kind of the

680
00:23:38,850 --> 00:23:43,050
one by the fraction is hex EC and then

681
00:23:41,340 --> 00:23:44,730
what I do is I override the first bite

682
00:23:43,050 --> 00:23:47,129
of each basic block that exists on a

683
00:23:44,730 --> 00:23:50,310
binary with a breakpoint statically on

684
00:23:47,130 --> 00:23:52,950
binary on disk and then all you have to

685
00:23:50,310 --> 00:23:55,409
do is implement a custom debugger which

686
00:23:52,950 --> 00:23:57,300
at one time start array start program

687
00:23:55,410 --> 00:23:59,310
and fetches all the breakpoint events

688
00:23:57,300 --> 00:24:02,040
which overrides the breakpoint with the

689
00:23:59,310 --> 00:24:05,399
original byte that it over roadable both

690
00:24:02,040 --> 00:24:06,629
in the address space and on disk and

691
00:24:05,400 --> 00:24:09,480
then we decrement the instruction

692
00:24:06,630 --> 00:24:10,830
pointer and resume the execution so now

693
00:24:09,480 --> 00:24:12,540
you might be thinking but this is crazy

694
00:24:10,830 --> 00:24:14,129
right each basic block is going to

695
00:24:12,540 --> 00:24:15,600
trigger a break for which we wrote

696
00:24:14,130 --> 00:24:18,480
have to fix so the overhead must be

697
00:24:15,600 --> 00:24:19,919
inverse actually that's true but it's

698
00:24:18,480 --> 00:24:23,550
only true for the first iterations

699
00:24:19,920 --> 00:24:24,690
because as we undo the instrumentation

700
00:24:23,550 --> 00:24:27,030
for the basic blocks that we have

701
00:24:24,690 --> 00:24:28,980
already seen we ensure that only those

702
00:24:27,030 --> 00:24:30,720
basic blocks that we have not triggered

703
00:24:28,980 --> 00:24:32,910
yet I'm going to trigger a new break

704
00:24:30,720 --> 00:24:34,200
frontage because we undo the

705
00:24:32,910 --> 00:24:36,240
instrumentation for the basic blocks

706
00:24:34,200 --> 00:24:39,840
that we have already found during our

707
00:24:36,240 --> 00:24:42,060
execution so I assume that after the

708
00:24:39,840 --> 00:24:43,709
first iteration of testing we almost one

709
00:24:42,060 --> 00:24:45,450
in real time again because most basic

710
00:24:43,710 --> 00:24:49,890
blocks implementation has been undone

711
00:24:45,450 --> 00:24:51,510
again let us see how this works so to

712
00:24:49,890 --> 00:24:53,280
get an idea of this again I patched oxid

713
00:24:51,510 --> 00:24:55,200
video with the auto exodus file II it

714
00:24:53,280 --> 00:24:57,540
clears itself right and then I

715
00:24:55,200 --> 00:24:59,280
implemented a custom debugger and C++ I

716
00:24:57,540 --> 00:25:02,730
said like it's super easy but it worked

717
00:24:59,280 --> 00:25:04,470
for me like a month and and then I

718
00:25:02,730 --> 00:25:06,920
patched all basic blocks at a pn Foxit

719
00:25:04,470 --> 00:25:10,050
reader and this was a number of

720
00:25:06,920 --> 00:25:11,640
1,700,000 sometimes a she blocks i have

721
00:25:10,050 --> 00:25:15,840
not done this by hand obviously i wrote

722
00:25:11,640 --> 00:25:17,700
a script for this and then I ran my

723
00:25:15,840 --> 00:25:19,230
constant debugger on this and from the

724
00:25:17,700 --> 00:25:22,530
first iteration as we have assumed the

725
00:25:19,230 --> 00:25:25,110
over was like crazy right because 48

726
00:25:22,530 --> 00:25:27,780
thousand something breakpoints had to

727
00:25:25,110 --> 00:25:29,729
been fixed at one time at one time the

728
00:25:27,780 --> 00:25:32,790
original bias that we looked at had to

729
00:25:29,730 --> 00:25:34,350
be looked up over wrote on disk and in

730
00:25:32,790 --> 00:25:36,510
address space and so on and so on so

731
00:25:34,350 --> 00:25:37,770
this took 16 seconds that's way more

732
00:25:36,510 --> 00:25:39,510
than four dynamic binary

733
00:25:37,770 --> 00:25:43,320
instrumentations but for the second

734
00:25:39,510 --> 00:25:45,210
iteration most basic blocks that most

735
00:25:43,320 --> 00:25:46,679
basic blocks have already triggered so

736
00:25:45,210 --> 00:25:48,470
this means that only new basic block

737
00:25:46,680 --> 00:25:51,270
will trigger so in the second iteration

738
00:25:48,470 --> 00:25:53,940
22,000 new basic blocks have been hit by

739
00:25:51,270 --> 00:25:55,770
the next PDF and this was only two

740
00:25:53,940 --> 00:25:57,330
thousand more and so it was only two

741
00:25:55,770 --> 00:26:00,120
seconds until the auto exit was caught

742
00:25:57,330 --> 00:26:01,860
and for the third iteration I took a PDF

743
00:26:00,120 --> 00:26:03,540
that would trigger the exact same

744
00:26:01,860 --> 00:26:05,760
behavior as a PDF that I've tested with

745
00:26:03,540 --> 00:26:07,110
earlier obviously I didn't have any

746
00:26:05,760 --> 00:26:08,460
overhead anymore because there was no

747
00:26:07,110 --> 00:26:10,979
breakfast anymore that was triggered

748
00:26:08,460 --> 00:26:12,420
newly right so I was running with 1.5

749
00:26:10,980 --> 00:26:14,850
seconds and it remember that is running

750
00:26:12,420 --> 00:26:19,350
in real time again so on the right side

751
00:26:14,850 --> 00:26:21,590
next what we see we see the basic blocks

752
00:26:19,350 --> 00:26:24,570
and the first instruction as I said is

753
00:26:21,590 --> 00:26:26,720
added in three events which is basically

754
00:26:24,570 --> 00:26:28,760
a breakpoint in the excited

755
00:26:26,720 --> 00:26:30,830
as I said this was a rare known approach

756
00:26:28,760 --> 00:26:32,270
I didn't come up with it myself this is

757
00:26:30,830 --> 00:26:35,090
I got it from a guy that was called

758
00:26:32,270 --> 00:26:36,770
Janos cast from from Estonia he

759
00:26:35,090 --> 00:26:39,409
open-source despite an implementation I

760
00:26:36,770 --> 00:26:43,240
brought it in C++ and he described it a

761
00:26:39,410 --> 00:26:46,220
bit better on his on his talk

762
00:26:43,240 --> 00:26:48,380
so to recap now we basically have solved

763
00:26:46,220 --> 00:26:50,330
two big problems right we made sure that

764
00:26:48,380 --> 00:26:52,640
the PDF viewer is finally killing itself

765
00:26:50,330 --> 00:26:53,840
just at the right time and at the same

766
00:26:52,640 --> 00:26:56,750
time we are able to measure code

767
00:26:53,840 --> 00:26:59,209
coverage with very low or almost zero

768
00:26:56,750 --> 00:27:01,460
overhead in case it does not figure and

769
00:26:59,210 --> 00:27:03,620
in your basic locks right so but we had

770
00:27:01,460 --> 00:27:05,510
a third problem which is speed we want

771
00:27:03,620 --> 00:27:07,429
to have a high number of executions per

772
00:27:05,510 --> 00:27:10,340
second what could we possibly do here

773
00:27:07,430 --> 00:27:12,320
and ask myself so what is the biggest

774
00:27:10,340 --> 00:27:13,879
bottleneck for fuzzing right the biggest

775
00:27:12,320 --> 00:27:16,129
bottleneck is that you have to restart

776
00:27:13,880 --> 00:27:17,690
your program for each iteration each

777
00:27:16,130 --> 00:27:20,300
time you give it a new input you have to

778
00:27:17,690 --> 00:27:22,760
restart program at the test be starting

779
00:27:20,300 --> 00:27:24,919
a program basically means that the

780
00:27:22,760 --> 00:27:26,300
operating system has to create space for

781
00:27:24,920 --> 00:27:28,790
the program has to allocate space for

782
00:27:26,300 --> 00:27:30,440
the program if it has to load all the

783
00:27:28,790 --> 00:27:32,899
libraries and do a lot of other stuff as

784
00:27:30,440 --> 00:27:34,910
well so this creates a lot of overhead

785
00:27:32,900 --> 00:27:36,740
but at the same time we are absolutely

786
00:27:34,910 --> 00:27:38,570
not interested in fuzzing the start of

787
00:27:36,740 --> 00:27:40,730
the program because starting a program

788
00:27:38,570 --> 00:27:43,700
or why starting the program the program

789
00:27:40,730 --> 00:27:46,400
is not going to handle our input so we

790
00:27:43,700 --> 00:27:48,110
want to - we want to try to avoid that

791
00:27:46,400 --> 00:27:51,800
we have to restart the program let's you

792
00:27:48,110 --> 00:27:53,360
approach him for open source

793
00:27:51,800 --> 00:27:55,310
applications again it's not so difficult

794
00:27:53,360 --> 00:27:57,010
all we have to do is we can make use of

795
00:27:55,310 --> 00:28:00,320
a concept that we call fork service

796
00:27:57,010 --> 00:28:03,290
which basically works by you start this

797
00:28:00,320 --> 00:28:05,120
process and suspend its execution on the

798
00:28:03,290 --> 00:28:07,750
first line of main or wherever you

799
00:28:05,120 --> 00:28:10,639
wanted to and you suspend its execution

800
00:28:07,750 --> 00:28:12,530
at a point where you know that loaded

801
00:28:10,640 --> 00:28:14,270
orders libraries and then you click in

802
00:28:12,530 --> 00:28:16,070
the instrumentation which Fox the

803
00:28:14,270 --> 00:28:17,690
process and line looks for basically

804
00:28:16,070 --> 00:28:20,000
means which create two complete copies

805
00:28:17,690 --> 00:28:23,600
of the program which includes all the

806
00:28:20,000 --> 00:28:26,170
libraries and concern and so we have a

807
00:28:23,600 --> 00:28:29,300
container like an exact copy of our

808
00:28:26,170 --> 00:28:32,180
program that we want to fast and then we

809
00:28:29,300 --> 00:28:34,669
seal the execution of our copy so by

810
00:28:32,180 --> 00:28:36,380
doing this we avoid that we have to

811
00:28:34,670 --> 00:28:38,330
restart the program because all we do is

812
00:28:36,380 --> 00:28:39,530
we take a snapshot of an already running

813
00:28:38,330 --> 00:28:42,559
process

814
00:28:39,530 --> 00:28:44,450
and resume its execution this is cool

815
00:28:42,559 --> 00:28:48,440
because we avoid so the parent process

816
00:28:44,450 --> 00:28:49,940
never X's and the snapshot has all its

817
00:28:48,440 --> 00:28:52,970
loaded libraries and a complete snapshot

818
00:28:49,940 --> 00:28:55,159
of us memory layout is obviously Windows

819
00:28:52,970 --> 00:28:56,780
does not know the concept of fork and we

820
00:28:55,159 --> 00:28:59,750
don't have the source code so what are

821
00:28:56,780 --> 00:29:01,220
we gonna do this time again so we need

822
00:28:59,750 --> 00:29:03,200
to find a way to speed up execution

823
00:29:01,220 --> 00:29:05,210
without the source code and fork we're

824
00:29:03,200 --> 00:29:07,039
going to avoid to restart the program we

825
00:29:05,210 --> 00:29:08,150
usually have two observations so even

826
00:29:07,039 --> 00:29:09,620
though we don't have the source code we

827
00:29:08,150 --> 00:29:11,900
are usually able to figure out where the

828
00:29:09,620 --> 00:29:13,668
location of the main function is and as

829
00:29:11,900 --> 00:29:15,559
presented earlier we can find out what

830
00:29:13,669 --> 00:29:21,409
the last basic block is that the program

831
00:29:15,559 --> 00:29:22,879
is executing so we see here as more code

832
00:29:21,409 --> 00:29:25,039
snippet and we want to try to further

833
00:29:22,880 --> 00:29:27,140
fast test this code snippet without

834
00:29:25,039 --> 00:29:29,240
having to restart the program all it

835
00:29:27,140 --> 00:29:32,110
does is it takes a one it would takes

836
00:29:29,240 --> 00:29:34,669
one argument passes it to process and

837
00:29:32,110 --> 00:29:36,439
what it does is what process passes it

838
00:29:34,669 --> 00:29:37,909
prints it out and then performs a very

839
00:29:36,440 --> 00:29:40,610
obvious protective stack based buffer

840
00:29:37,909 --> 00:29:43,730
overflow and our goal here is that we

841
00:29:40,610 --> 00:29:45,439
want to pass the process function we

842
00:29:43,730 --> 00:29:46,520
have two observations even though we are

843
00:29:45,440 --> 00:29:47,840
seeing that we don't have a source code

844
00:29:46,520 --> 00:29:50,720
by finding the main function of the

845
00:29:47,840 --> 00:29:55,309
crisis at the same time our user input

846
00:29:50,720 --> 00:29:57,350
our arc v is on the step and what I like

847
00:29:55,309 --> 00:30:01,280
to do is I like to catch the first line

848
00:29:57,350 --> 00:30:02,809
of main and the last line of main so the

849
00:30:01,280 --> 00:30:05,120
first basic block and the last basic

850
00:30:02,809 --> 00:30:06,470
block each with a breakpoint so i frame

851
00:30:05,120 --> 00:30:08,689
the code every yesterday i'm actually

852
00:30:06,470 --> 00:30:10,309
interested in fuzzing and if the main

853
00:30:08,690 --> 00:30:12,470
prey greteman triggers what i do is i

854
00:30:10,309 --> 00:30:15,740
store the context the execution context

855
00:30:12,470 --> 00:30:17,750
so I so I store the CPU registers I saw

856
00:30:15,740 --> 00:30:19,820
the flags and so on and then I try to

857
00:30:17,750 --> 00:30:22,039
find my user input in memory so in this

858
00:30:19,820 --> 00:30:23,389
case I agree and then I undo the first

859
00:30:22,039 --> 00:30:25,879
Greg point because we don't need it in

860
00:30:23,390 --> 00:30:28,039
anymore and then what I do is with the

861
00:30:25,880 --> 00:30:29,929
second breakpoint triggers we restore

862
00:30:28,039 --> 00:30:31,908
the execution context we restore the CPU

863
00:30:29,929 --> 00:30:33,890
biggest of the restore the flags we

864
00:30:31,909 --> 00:30:35,870
restore the stack and so on and then we

865
00:30:33,890 --> 00:30:37,880
mutate our key because we found our

866
00:30:35,870 --> 00:30:39,860
input on this deck so we mutated in

867
00:30:37,880 --> 00:30:41,659
memory and then put the instruction

868
00:30:39,860 --> 00:30:43,428
pointer back to main right so that it

869
00:30:41,659 --> 00:30:46,940
runs in a loop we avoid that the program

870
00:30:43,429 --> 00:30:48,350
has to close itself I tested this

871
00:30:46,940 --> 00:30:49,909
approach for the some program that we've

872
00:30:48,350 --> 00:30:52,370
just seen and the researcher for now

873
00:30:49,909 --> 00:30:53,270
surprisingly group I tested it with 1000

874
00:30:52,370 --> 00:30:54,949
iterations

875
00:30:53,270 --> 00:30:56,510
and with the usual approach of having to

876
00:30:54,950 --> 00:30:58,820
reset the program it took like 10

877
00:30:56,510 --> 00:31:00,200
seconds with the in-memory pausing

878
00:30:58,820 --> 00:31:02,720
approach it took me half a second for

879
00:31:00,200 --> 00:31:06,740
1,000 I think we can all agree that this

880
00:31:02,720 --> 00:31:09,470
is a massive speed up it's not always

881
00:31:06,740 --> 00:31:11,450
that easy so as you've seen the code

882
00:31:09,470 --> 00:31:14,090
snippet that I've associated that I've

883
00:31:11,450 --> 00:31:16,430
just shown you is very trivial it does

884
00:31:14,090 --> 00:31:18,500
not do a lot for programs such as keep

885
00:31:16,430 --> 00:31:20,660
such as a PDF viewer you have a way

886
00:31:18,500 --> 00:31:23,360
bigger execution context to restore like

887
00:31:20,660 --> 00:31:25,430
PDF viewer has several request PDF

888
00:31:23,360 --> 00:31:27,709
viewer takes care of like it has a

889
00:31:25,430 --> 00:31:29,480
graphical interface which always handles

890
00:31:27,710 --> 00:31:31,790
and so on and so on at the same time it

891
00:31:29,480 --> 00:31:34,730
does a lot of stuff on the heap so we

892
00:31:31,790 --> 00:31:36,770
need to take care of that we free memory

893
00:31:34,730 --> 00:31:38,450
that has been allocated it's not very

894
00:31:36,770 --> 00:31:39,590
difficult to do for the stack because we

895
00:31:38,450 --> 00:31:41,720
have to do is we set the stack pointer

896
00:31:39,590 --> 00:31:42,860
but for the heap is a problem because

897
00:31:41,720 --> 00:31:44,570
what we have to do is you would have to

898
00:31:42,860 --> 00:31:46,879
hook the malloc or a location function

899
00:31:44,570 --> 00:31:49,520
so that we have pointers that we can

900
00:31:46,880 --> 00:31:52,100
individually free again this is a lot of

901
00:31:49,520 --> 00:31:54,560
overhead again same goes for the handles

902
00:31:52,100 --> 00:31:57,020
but we can do this for smaller programs

903
00:31:54,560 --> 00:31:58,909
as we've just seen what I do is I just

904
00:31:57,020 --> 00:32:01,660
don't run the fast loop forever because

905
00:31:58,910 --> 00:32:04,580
of what one out of memory at some point

906
00:32:01,660 --> 00:32:06,410
but yeah that's not something that we

907
00:32:04,580 --> 00:32:07,850
can use for PDF viewers but for smaller

908
00:32:06,410 --> 00:32:12,020
command and application that's something

909
00:32:07,850 --> 00:32:15,379
that we can do so finally what have we

910
00:32:12,020 --> 00:32:17,300
seen so we made use of dynamic binary

911
00:32:15,380 --> 00:32:19,340
instrumentation to identify code areas

912
00:32:17,300 --> 00:32:21,409
in our PDF viewer that we are actually

913
00:32:19,340 --> 00:32:23,149
interested in so that we finally make a

914
00:32:21,410 --> 00:32:25,550
PDF you are killing itself when we are

915
00:32:23,150 --> 00:32:27,530
not interested in it in it anymore we

916
00:32:25,550 --> 00:32:30,290
made use of small instructions to signal

917
00:32:27,530 --> 00:32:32,980
our father in this case Greg clients as

918
00:32:30,290 --> 00:32:36,200
a way to communicate between father and

919
00:32:32,980 --> 00:32:37,820
and or target we made use of a custom

920
00:32:36,200 --> 00:32:40,220
debugger to handle our instrumentation

921
00:32:37,820 --> 00:32:42,679
and we've seen that we can use that we

922
00:32:40,220 --> 00:32:45,050
can generate block coverage with low or

923
00:32:42,680 --> 00:32:46,850
internal overhead in case remember if no

924
00:32:45,050 --> 00:32:49,070
new black points are triggered only by

925
00:32:46,850 --> 00:32:50,870
using breakpoints and using the concept

926
00:32:49,070 --> 00:32:52,760
of an instrumenting or undoing the

927
00:32:50,870 --> 00:32:54,889
instrumentation for quote pass that we

928
00:32:52,760 --> 00:32:57,500
have already seen and we have seen that

929
00:32:54,890 --> 00:32:59,660
a memory fuzzing is both extremely fast

930
00:32:57,500 --> 00:33:01,220
but I was as I was trying to tell you

931
00:32:59,660 --> 00:33:03,410
it's really difficult to implement for a

932
00:33:01,220 --> 00:33:05,110
big project

933
00:33:03,410 --> 00:33:09,040
so that's what I wanted to tell you

934
00:33:05,110 --> 00:33:09,040
thank you for your attention

