1
00:00:00,000 --> 00:00:08,480
[Music]

2
00:00:08,480 --> 00:00:10,080
so far we've been focusing on

3
00:00:10,080 --> 00:00:12,480
pre-programmed lighting patterns

4
00:00:12,480 --> 00:00:14,480
we can program them to be random or to

5
00:00:14,480 --> 00:00:16,239
change over time

6
00:00:16,239 --> 00:00:17,920
what if we wanted to trigger changes in

7
00:00:17,920 --> 00:00:19,600
our lighting to be based on human

8
00:00:19,600 --> 00:00:20,480
activity

9
00:00:20,480 --> 00:00:23,519
making them interactive in interactive

10
00:00:23,519 --> 00:00:25,920
programs there are inputs and outputs

11
00:00:25,920 --> 00:00:28,240
our led lighting is an output sound

12
00:00:28,240 --> 00:00:30,480
could be another output but what about

13
00:00:30,480 --> 00:00:31,840
inputs

14
00:00:31,840 --> 00:00:33,920
interactive programs rely on inputs like

15
00:00:33,920 --> 00:00:36,079
touch motion or sound sensing to trigger

16
00:00:36,079 --> 00:00:37,520
interactivity

17
00:00:37,520 --> 00:00:39,280
lucky for us the circuit playground

18
00:00:39,280 --> 00:00:41,040
express comes with a number of onboard

19
00:00:41,040 --> 00:00:41,680
sensors

20
00:00:41,680 --> 00:00:44,480
that we can use as inputs in this class

21
00:00:44,480 --> 00:00:45,920
we'll explore some of the onboard

22
00:00:45,920 --> 00:00:47,280
sensors of the circuit playground

23
00:00:47,280 --> 00:00:48,079
express

24
00:00:48,079 --> 00:00:51,440
to trigger our lighting effects

25
00:00:51,680 --> 00:00:53,600
sensors are electronic components that

26
00:00:53,600 --> 00:00:55,840
allow us to register and respond to data

27
00:00:55,840 --> 00:00:58,239
about the surrounding environment

28
00:00:58,239 --> 00:00:59,760
the circuit playground express has a

29
00:00:59,760 --> 00:01:02,000
wealth of onboard sensors we can use to

30
00:01:02,000 --> 00:01:02,399
create

31
00:01:02,399 --> 00:01:04,799
interactive lighting effects these

32
00:01:04,799 --> 00:01:06,640
include environmental sensors like a

33
00:01:06,640 --> 00:01:09,119
light sensor and a temperature sensor

34
00:01:09,119 --> 00:01:11,040
a small microphone which can be used as

35
00:01:11,040 --> 00:01:12,400
a sound sensor

36
00:01:12,400 --> 00:01:14,240
an accelerometer which can be used to

37
00:01:14,240 --> 00:01:15,439
measure movements

38
00:01:15,439 --> 00:01:17,520
and capacitive touch sensing pads which

39
00:01:17,520 --> 00:01:19,520
can detect touch

40
00:01:19,520 --> 00:01:21,680
the adafruit circuit playground library

41
00:01:21,680 --> 00:01:23,840
has example sketches you can use to get

42
00:01:23,840 --> 00:01:26,320
started with exploring these sensors

43
00:01:26,320 --> 00:01:28,159
many of the examples are located under

44
00:01:28,159 --> 00:01:31,119
the hello circuit playground sub library

45
00:01:31,119 --> 00:01:33,200
now we're going to try using capacitive

46
00:01:33,200 --> 00:01:35,040
touch if you've never heard of this

47
00:01:35,040 --> 00:01:36,960
technology it's a little difficult to

48
00:01:36,960 --> 00:01:38,159
explain

49
00:01:38,159 --> 00:01:40,000
but basically on board our circuit

50
00:01:40,000 --> 00:01:42,720
playground we have different copper pads

51
00:01:42,720 --> 00:01:45,040
these copper pads can be used to sense

52
00:01:45,040 --> 00:01:45,920
touch

53
00:01:45,920 --> 00:01:48,240
the way that this works is that each pad

54
00:01:48,240 --> 00:01:50,960
has an em or an electromagnetic field

55
00:01:50,960 --> 00:01:53,360
when this field is disturbed as you can

56
00:01:53,360 --> 00:01:55,280
see in the left photo

57
00:01:55,280 --> 00:01:58,799
it changes the reading of this field

58
00:01:58,799 --> 00:02:01,520
we can use this value of change in order

59
00:02:01,520 --> 00:02:02,159
to trigger

60
00:02:02,159 --> 00:02:05,040
different effects for a more detailed

61
00:02:05,040 --> 00:02:06,960
explanation of capacitive touch

62
00:02:06,960 --> 00:02:08,720
feel free to look at the following two

63
00:02:08,720 --> 00:02:10,239
links

64
00:02:10,239 --> 00:02:11,599
the circuit playground has seven

65
00:02:11,599 --> 00:02:14,160
built-in capacitive touch sensing pads

66
00:02:14,160 --> 00:02:17,040
these are labeled as a1 through a7 on

67
00:02:17,040 --> 00:02:17,840
the board

68
00:02:17,840 --> 00:02:19,840
and correspond to the following digital

69
00:02:19,840 --> 00:02:21,360
pins

70
00:02:21,360 --> 00:02:22,959
you should note that the digital pins

71
00:02:22,959 --> 00:02:25,120
are not printed on the pcb

72
00:02:25,120 --> 00:02:27,360
but you can see the pin out on the next

73
00:02:27,360 --> 00:02:29,440
slide to see what each digital pin

74
00:02:29,440 --> 00:02:32,000
is here's the pin out map for the

75
00:02:32,000 --> 00:02:34,319
adafruit circuit playground express

76
00:02:34,319 --> 00:02:36,480
here you can see which pin each sensor

77
00:02:36,480 --> 00:02:37,599
is connected to

78
00:02:37,599 --> 00:02:40,160
as well as which pin is each analog and

79
00:02:40,160 --> 00:02:42,879
digital pin

80
00:02:46,879 --> 00:02:50,720
open up the sketch cap touch simple

81
00:02:50,720 --> 00:02:52,879
this looks a bit familiar to us but with

82
00:02:52,879 --> 00:02:54,480
some changes

83
00:02:54,480 --> 00:02:56,000
we're still including the adafruit

84
00:02:56,000 --> 00:02:57,680
circuit playground library

85
00:02:57,680 --> 00:03:00,480
but here we're defining a capped touch

86
00:03:00,480 --> 00:03:01,200
pin

87
00:03:01,200 --> 00:03:05,360
as a1 can change this number to a

88
00:03:05,360 --> 00:03:06,640
different pin

89
00:03:06,640 --> 00:03:08,879
and include any cap touch pin that we

90
00:03:08,879 --> 00:03:11,599
want to use

91
00:03:11,680 --> 00:03:14,400
in our loop function we're having a

92
00:03:14,400 --> 00:03:15,840
print statement

93
00:03:15,840 --> 00:03:18,800
that reads out the cap touch value of

94
00:03:18,800 --> 00:03:20,720
that pin

95
00:03:20,720 --> 00:03:23,760
here cap pin 1 is used

96
00:03:23,760 --> 00:03:27,040
in place of a1 but we can just as easily

97
00:03:27,040 --> 00:03:27,680
say

98
00:03:27,680 --> 00:03:31,680
a1 why would we want to do it this way

99
00:03:31,680 --> 00:03:33,680
well if we want to change the cap touch

100
00:03:33,680 --> 00:03:35,760
pin all we need to do is change the

101
00:03:35,760 --> 00:03:37,440
number here

102
00:03:37,440 --> 00:03:40,720
this keeps our code nice and tidy

103
00:03:40,720 --> 00:03:43,760
after we read the cap touch value

104
00:03:43,760 --> 00:03:46,799
then we have a small delay a small delay

105
00:03:46,799 --> 00:03:48,319
is useful to keep our

106
00:03:48,319 --> 00:03:51,680
arduino from getting overwhelmed

107
00:03:51,680 --> 00:03:53,599
let's try uploading the sketch and then

108
00:03:53,599 --> 00:03:55,920
see what happens

109
00:03:55,920 --> 00:03:57,920
if you open up serial monitor you'll see

110
00:03:57,920 --> 00:03:59,680
different values

111
00:03:59,680 --> 00:04:02,720
but if you open up serial plotter

112
00:04:02,720 --> 00:04:04,560
you'll be able to see a plot of those

113
00:04:04,560 --> 00:04:07,040
values

114
00:04:07,519 --> 00:04:11,519
we're reading the value from pin a1

115
00:04:11,519 --> 00:04:14,080
try putting your finger on the copper

116
00:04:14,080 --> 00:04:14,959
pad that says

117
00:04:14,959 --> 00:04:19,440
a1 what happens

118
00:04:23,280 --> 00:04:26,080
we notice a spike in the values try

119
00:04:26,080 --> 00:04:29,840
removing your finger

120
00:04:30,479 --> 00:04:32,000
you'll notice that it goes back to

121
00:04:32,000 --> 00:04:33,919
normal

122
00:04:33,919 --> 00:04:36,080
how does it look if you hold your finger

123
00:04:36,080 --> 00:04:43,520
versus if you take it on and off

124
00:04:43,520 --> 00:04:45,120
try this yourself with your own

125
00:04:45,120 --> 00:04:47,199
controller you can try different pins to

126
00:04:47,199 --> 00:04:49,280
compare them if you'd like

127
00:04:49,280 --> 00:04:50,720
what if we want to design using

128
00:04:50,720 --> 00:04:52,720
capacitive touch to trigger some kind of

129
00:04:52,720 --> 00:04:53,919
output

130
00:04:53,919 --> 00:04:56,160
we need to set a threshold value in

131
00:04:56,160 --> 00:04:58,320
order to decide what value means the pad

132
00:04:58,320 --> 00:05:00,560
has been touched

133
00:05:00,560 --> 00:05:05,199
open up the sketch cap touch threshold

134
00:05:05,280 --> 00:05:08,479
in this sketch cap touch threshold we

135
00:05:08,479 --> 00:05:08,960
have

136
00:05:08,960 --> 00:05:11,280
again an inclusion of our adafruit

137
00:05:11,280 --> 00:05:13,280
circuit playground library

138
00:05:13,280 --> 00:05:15,360
we also are still defining our cap touch

139
00:05:15,360 --> 00:05:17,600
pin remember we can change this value to

140
00:05:17,600 --> 00:05:20,080
look at other cap touch pins

141
00:05:20,080 --> 00:05:21,759
then we have a definition for a

142
00:05:21,759 --> 00:05:23,680
threshold value

143
00:05:23,680 --> 00:05:25,440
this is the minimum reading that we're

144
00:05:25,440 --> 00:05:27,120
counting as a touch

145
00:05:27,120 --> 00:05:29,520
if you remember from our last sketch

146
00:05:29,520 --> 00:05:31,360
when we were touching the pin

147
00:05:31,360 --> 00:05:34,320
the value spiked so we want to choose

148
00:05:34,320 --> 00:05:36,479
what is the number that's the minimum

149
00:05:36,479 --> 00:05:39,440
that will count as a touch in this case

150
00:05:39,440 --> 00:05:42,000
we're counting it as 500.

151
00:05:42,000 --> 00:05:44,160
in the loop we're again reading the cap

152
00:05:44,160 --> 00:05:45,039
touch pin

153
00:05:45,039 --> 00:05:47,520
but in this case we're storing it as a

154
00:05:47,520 --> 00:05:48,240
variable

155
00:05:48,240 --> 00:05:50,880
called an integer then we're printing

156
00:05:50,880 --> 00:05:52,560
capacitive touch reading

157
00:05:52,560 --> 00:05:55,120
and then printing the data for that

158
00:05:55,120 --> 00:05:57,120
reading

159
00:05:57,120 --> 00:05:59,680
if the data is greater than our

160
00:05:59,680 --> 00:06:01,280
threshold value

161
00:06:01,280 --> 00:06:04,160
then we're going to print touch else

162
00:06:04,160 --> 00:06:06,240
we're not going to do anything

163
00:06:06,240 --> 00:06:08,400
this is called an if else statement and

164
00:06:08,400 --> 00:06:10,400
it's useful for creating logic in our

165
00:06:10,400 --> 00:06:11,120
programs

166
00:06:11,120 --> 00:06:13,440
especially if we want to use sensor data

167
00:06:13,440 --> 00:06:15,440
then do something based on the sensor

168
00:06:15,440 --> 00:06:17,759
data

169
00:06:18,160 --> 00:06:21,360
then we have a small delay so in this

170
00:06:21,360 --> 00:06:22,880
sketch what we're doing

171
00:06:22,880 --> 00:06:25,120
is we're over and over again reading the

172
00:06:25,120 --> 00:06:26,639
cap touch pins data

173
00:06:26,639 --> 00:06:29,680
storing it as a variable printing out

174
00:06:29,680 --> 00:06:31,039
that data

175
00:06:31,039 --> 00:06:33,199
and then if the data is greater than our

176
00:06:33,199 --> 00:06:34,639
threshold value

177
00:06:34,639 --> 00:06:37,759
we'll print touched let's try this

178
00:06:37,759 --> 00:06:40,319
and see if it works make sure that you

179
00:06:40,319 --> 00:06:41,840
have your correct board

180
00:06:41,840 --> 00:06:44,960
and port selected

181
00:06:45,039 --> 00:06:48,400
open up serial monitor

182
00:06:48,400 --> 00:06:50,639
now you'll see capacitive touch reading

183
00:06:50,639 --> 00:06:52,560
and then the data

184
00:06:52,560 --> 00:06:56,720
what happens if you touch pin a1

185
00:06:56,880 --> 00:06:59,199
now we see a statement that says touched

186
00:06:59,199 --> 00:07:02,720
and we also see the cap touch data

187
00:07:02,720 --> 00:07:04,400
using a threshold is a great way to

188
00:07:04,400 --> 00:07:05,759
trigger interactivity

189
00:07:05,759 --> 00:07:07,440
but capacitive touch is a finicky

190
00:07:07,440 --> 00:07:09,440
technology any small change in the

191
00:07:09,440 --> 00:07:11,039
environment can change the outcome of

192
00:07:11,039 --> 00:07:12,160
the data

193
00:07:12,160 --> 00:07:13,680
you can see this yourself by putting

194
00:07:13,680 --> 00:07:15,440
other objects next to your pins to

195
00:07:15,440 --> 00:07:16,880
change the values

196
00:07:16,880 --> 00:07:18,560
in this next section we'll learn how to

197
00:07:18,560 --> 00:07:20,240
calculate a running average

198
00:07:20,240 --> 00:07:22,240
a useful technique for self-calibrating

199
00:07:22,240 --> 00:07:24,000
your cap touch pins

200
00:07:24,000 --> 00:07:26,080
using a running average plus threshold

201
00:07:26,080 --> 00:07:27,919
ensures that your cap touch installation

202
00:07:27,919 --> 00:07:28,560
can

203
00:07:28,560 --> 00:07:32,240
almost always react to a touch

204
00:07:36,240 --> 00:07:38,240
open up the sketch cap touch running

205
00:07:38,240 --> 00:07:40,080
average

206
00:07:40,080 --> 00:07:41,440
in the sketch we'll learn how to

207
00:07:41,440 --> 00:07:43,120
calculate a running average

208
00:07:43,120 --> 00:07:45,120
and then self-calibrate for our cap

209
00:07:45,120 --> 00:07:46,560
touch pins

210
00:07:46,560 --> 00:07:48,560
the basic principle of a running average

211
00:07:48,560 --> 00:07:50,960
is create an array of measurements

212
00:07:50,960 --> 00:07:52,800
a variable to keep track of which one

213
00:07:52,800 --> 00:07:54,879
you're currently on and a variable to

214
00:07:54,879 --> 00:07:56,479
hold your average

215
00:07:56,479 --> 00:07:58,400
then every time you take a measurement

216
00:07:58,400 --> 00:08:00,319
you'll put your new measurement in the

217
00:08:00,319 --> 00:08:02,160
current element of the array

218
00:08:02,160 --> 00:08:04,400
and you'll increase the position by one

219
00:08:04,400 --> 00:08:06,319
or reset it to zero if you're at the end

220
00:08:06,319 --> 00:08:07,759
of the array

221
00:08:07,759 --> 00:08:09,360
then you'll divide the sum of all the

222
00:08:09,360 --> 00:08:11,120
measurements here accomplished by

223
00:08:11,120 --> 00:08:13,599
continuously subtracting the old reading

224
00:08:13,599 --> 00:08:16,160
and then adding the new one by the total

225
00:08:16,160 --> 00:08:19,120
number of measurements in the array

226
00:08:19,120 --> 00:08:21,039
you can see this at work in the take

227
00:08:21,039 --> 00:08:23,199
reading function

228
00:08:23,199 --> 00:08:26,479
here we have a save index of zero

229
00:08:26,479 --> 00:08:28,319
next we're going to subtract the last

230
00:08:28,319 --> 00:08:30,080
reading as indicated by

231
00:08:30,080 --> 00:08:33,360
total equals total minus readings read

232
00:08:33,360 --> 00:08:35,760
index

233
00:08:35,760 --> 00:08:37,839
then we're going to read from the sensor

234
00:08:37,839 --> 00:08:39,360
using circuit playground

235
00:08:39,360 --> 00:08:42,800
recap cap pin

236
00:08:43,120 --> 00:08:45,519
then we save our index so we can return

237
00:08:45,519 --> 00:08:48,080
the value

238
00:08:48,640 --> 00:08:51,519
then we add the reading to the total and

239
00:08:51,519 --> 00:08:53,440
then we go to the next position in the

240
00:08:53,440 --> 00:08:55,839
array

241
00:08:55,920 --> 00:08:57,920
if we're at the end of the array we go

242
00:08:57,920 --> 00:09:00,719
back to zero

243
00:09:01,360 --> 00:09:03,440
on line 61 is where we actually

244
00:09:03,440 --> 00:09:06,560
calculate the average

245
00:09:07,040 --> 00:09:10,079
and then we return it

246
00:09:12,560 --> 00:09:14,480
doing this gives you an average of the

247
00:09:14,480 --> 00:09:17,279
last n values read by the sensor

248
00:09:17,279 --> 00:09:19,200
one that continually updates as new

249
00:09:19,200 --> 00:09:21,120
values are red

250
00:09:21,120 --> 00:09:23,120
this trick is very useful for smoothing

251
00:09:23,120 --> 00:09:25,040
data if you have a sensor that is

252
00:09:25,040 --> 00:09:26,399
susceptible to noise

253
00:09:26,399 --> 00:09:29,200
or tends to spike between values it's

254
00:09:29,200 --> 00:09:31,200
also good for self-calibrating systems

255
00:09:31,200 --> 00:09:32,720
that depend on a threshold

256
00:09:32,720 --> 00:09:37,440
which can change like capacitive touch

257
00:09:37,440 --> 00:09:40,560
upload the sketch and give it a try

258
00:09:40,560 --> 00:09:43,200
try touching pad a1 and watching the

259
00:09:43,200 --> 00:09:45,040
serial monitor for change

260
00:09:45,040 --> 00:09:47,040
you can watch the running average rise

261
00:09:47,040 --> 00:09:51,839
and drop as you touch the pad

262
00:10:02,720 --> 00:10:04,399
the one downside to using a running

263
00:10:04,399 --> 00:10:06,320
average system with capacitive touch is

264
00:10:06,320 --> 00:10:08,800
a continuous touch or a long touch

265
00:10:08,800 --> 00:10:10,560
if someone's always touching the pin

266
00:10:10,560 --> 00:10:12,560
your running average will trend upward

267
00:10:12,560 --> 00:10:15,120
towards the actual touch value over time

268
00:10:15,120 --> 00:10:16,800
which means that a touch will eventually

269
00:10:16,800 --> 00:10:18,480
fail to cross your measurement

270
00:10:18,480 --> 00:10:20,800
plus threshold in the case of a

271
00:10:20,800 --> 00:10:22,480
continuous touch you're better off with

272
00:10:22,480 --> 00:10:24,079
a static threshold value

273
00:10:24,079 --> 00:10:26,800
or with a system that combines the two

274
00:10:26,800 --> 00:10:28,640
in our case i used the ladder

275
00:10:28,640 --> 00:10:30,560
i added a special check for whether the

276
00:10:30,560 --> 00:10:32,399
value read is close to the max touch

277
00:10:32,399 --> 00:10:33,279
value

278
00:10:33,279 --> 00:10:34,800
since that's where the running average

279
00:10:34,800 --> 00:10:36,959
of a long touch will tend to congregate

280
00:10:36,959 --> 00:10:38,720
to learn more about smoothing and

281
00:10:38,720 --> 00:10:40,640
running averages see the arduino

282
00:10:40,640 --> 00:10:42,000
reference below

283
00:10:42,000 --> 00:10:43,600
now it's time to add in our lighting

284
00:10:43,600 --> 00:10:45,040
interactivity

285
00:10:45,040 --> 00:10:49,200
open up the sketch cap touch lighting

286
00:10:49,200 --> 00:10:51,839
in the sketch cap touch lighting will be

287
00:10:51,839 --> 00:10:53,760
controlling lighting using our cap touch

288
00:10:53,760 --> 00:10:55,120
data

289
00:10:55,120 --> 00:10:57,200
one of the most satisfying parameters to

290
00:10:57,200 --> 00:10:58,560
attach to sensor data

291
00:10:58,560 --> 00:11:01,839
is the animation update time by picking

292
00:11:01,839 --> 00:11:04,240
appropriate values for the max and min

293
00:11:04,240 --> 00:11:05,360
update time

294
00:11:05,360 --> 00:11:07,519
you can make your animation speed up or

295
00:11:07,519 --> 00:11:10,000
slow down in response to input

296
00:11:10,000 --> 00:11:13,040
we can see this on line 20.

297
00:11:13,040 --> 00:11:15,120
as in the last class we'll be using the

298
00:11:15,120 --> 00:11:17,440
map function to translate our data from

299
00:11:17,440 --> 00:11:19,120
the cap touch value range

300
00:11:19,120 --> 00:11:20,959
to the range we'd like to use for our

301
00:11:20,959 --> 00:11:22,959
animation speed

302
00:11:22,959 --> 00:11:24,800
here i've included one of the functions

303
00:11:24,800 --> 00:11:26,959
from the custom algorithm hello world

304
00:11:26,959 --> 00:11:27,600
file

305
00:11:27,600 --> 00:11:30,560
smartest chase

306
00:11:30,720 --> 00:11:32,640
instead of a constant value that's

307
00:11:32,640 --> 00:11:34,079
always the same

308
00:11:34,079 --> 00:11:36,000
now we're adding the contents of a

309
00:11:36,000 --> 00:11:38,320
variable to our timer

310
00:11:38,320 --> 00:11:40,160
this allows us to change the value of

311
00:11:40,160 --> 00:11:42,160
the variable inside the loop

312
00:11:42,160 --> 00:11:44,000
speeding up or slowing down our

313
00:11:44,000 --> 00:11:46,560
animation

314
00:11:47,839 --> 00:11:49,839
likewise i've added this to the top of

315
00:11:49,839 --> 00:11:52,399
the file

316
00:11:53,920 --> 00:11:56,160
instead of using one constant to hold

317
00:11:56,160 --> 00:11:58,079
the animation update speed

318
00:11:58,079 --> 00:12:01,360
i'm defining two constants a min and a

319
00:12:01,360 --> 00:12:03,040
max

320
00:12:03,040 --> 00:12:06,399
in this case slow and fast and then i'm

321
00:12:06,399 --> 00:12:07,600
creating a variable

322
00:12:07,600 --> 00:12:09,920
to hold the speed which starts at the

323
00:12:09,920 --> 00:12:11,440
max update speed

324
00:12:11,440 --> 00:12:14,320
slow it's a bit counter-intuitive but

325
00:12:14,320 --> 00:12:16,320
timers kind of work backwards in this

326
00:12:16,320 --> 00:12:17,200
way

327
00:12:17,200 --> 00:12:19,200
smaller values for the milliseconds to

328
00:12:19,200 --> 00:12:21,279
delay make timers run faster

329
00:12:21,279 --> 00:12:23,839
more often and larger values make them

330
00:12:23,839 --> 00:12:26,639
run slower or less often

331
00:12:26,639 --> 00:12:28,240
now that we've got this set up all we

332
00:12:28,240 --> 00:12:29,760
need to add to our lighting file

333
00:12:29,760 --> 00:12:31,760
other than the usual fast led boiler

334
00:12:31,760 --> 00:12:33,440
plate which is added for you

335
00:12:33,440 --> 00:12:37,680
is the following as in the last class

336
00:12:37,680 --> 00:12:39,839
we're going to use the map function to

337
00:12:39,839 --> 00:12:42,000
transform the range expected by the cap

338
00:12:42,000 --> 00:12:43,120
touch sensor

339
00:12:43,120 --> 00:12:46,560
which is about 200 through 1016

340
00:12:46,560 --> 00:12:48,240
to the range we'd like to use for our

341
00:12:48,240 --> 00:12:49,839
lighting slow

342
00:12:49,839 --> 00:12:53,920
60 through fast 20. you can see this

343
00:12:53,920 --> 00:12:57,200
down here note that map can easily map

344
00:12:57,200 --> 00:12:59,600
smaller values to larger values and vice

345
00:12:59,600 --> 00:13:00,399
versa

346
00:13:00,399 --> 00:13:02,320
all you need to do is match each value

347
00:13:02,320 --> 00:13:04,560
to the one you want to map to

348
00:13:04,560 --> 00:13:07,040
so what our map call says is here's a

349
00:13:07,040 --> 00:13:07,680
value

350
00:13:07,680 --> 00:13:12,000
gap data which goes from 200 to 1016.

351
00:13:12,000 --> 00:13:14,000
please smoothly map it to an equivalent

352
00:13:14,000 --> 00:13:15,120
value between

353
00:13:15,120 --> 00:13:18,079
slow light update and fast light update

354
00:13:18,079 --> 00:13:19,360
then return it

355
00:13:19,360 --> 00:13:22,880
here's more on the map function

356
00:13:26,800 --> 00:13:28,639
the cool thing about this is that all

357
00:13:28,639 --> 00:13:30,240
you need to do to change the speed of

358
00:13:30,240 --> 00:13:31,120
the animation

359
00:13:31,120 --> 00:13:32,959
is to change the value of the lighting

360
00:13:32,959 --> 00:13:36,240
update timer inside your loop

361
00:13:36,240 --> 00:13:37,920
now that you've checked out this file

362
00:13:37,920 --> 00:13:39,760
let's upload it and touch the cap touch

363
00:13:39,760 --> 00:13:49,839
pins to see what it does

364
00:13:56,720 --> 00:13:58,720
likewise you could use the same trick to

365
00:13:58,720 --> 00:14:00,560
attach other values to a different cap

366
00:14:00,560 --> 00:14:01,360
touch pin

367
00:14:01,360 --> 00:14:03,760
for instance you could have pin a2

368
00:14:03,760 --> 00:14:04,720
change colors

369
00:14:04,720 --> 00:14:07,360
in this sketch by changing g-hue or you

370
00:14:07,360 --> 00:14:09,600
could have pin a3 change fade times by

371
00:14:09,600 --> 00:14:11,040
changing the value given to fade to

372
00:14:11,040 --> 00:14:12,000
black by

373
00:14:12,000 --> 00:14:14,000
give this a try on your own time and see

374
00:14:14,000 --> 00:14:15,760
what interesting chase patterns you can

375
00:14:15,760 --> 00:14:19,519
generate by using the map function

376
00:14:22,959 --> 00:14:25,199
in this sketch we see a new kind of

377
00:14:25,199 --> 00:14:27,839
variable which is called a float

378
00:14:27,839 --> 00:14:31,199
a float is a variable that has a decimal

379
00:14:31,199 --> 00:14:33,440
this allows us to store more specific

380
00:14:33,440 --> 00:14:35,680
data than if we are using an integer

381
00:14:35,680 --> 00:14:38,399
which does not have a decimal this will

382
00:14:38,399 --> 00:14:41,760
make more sense once we see the value

383
00:14:41,760 --> 00:14:44,320
here we see we're using our float sound

384
00:14:44,320 --> 00:14:44,959
value

385
00:14:44,959 --> 00:14:48,079
to store some data the data we're

386
00:14:48,079 --> 00:14:48,639
storing

387
00:14:48,639 --> 00:14:50,480
is coming from the circuit playground's

388
00:14:50,480 --> 00:14:52,800
mic and it's for the function

389
00:14:52,800 --> 00:14:55,839
sound pressure level we then see

390
00:14:55,839 --> 00:14:58,959
a number that's in parentheses this is

391
00:14:58,959 --> 00:15:00,959
because in order to calculate the sound

392
00:15:00,959 --> 00:15:02,000
pressure level

393
00:15:02,000 --> 00:15:04,240
the circuit playground has to take a

394
00:15:04,240 --> 00:15:05,920
specific piece of data

395
00:15:05,920 --> 00:15:08,959
and then calculate the result the kind

396
00:15:08,959 --> 00:15:10,240
of data that it's taking

397
00:15:10,240 --> 00:15:13,199
is a recording over a period of time so

398
00:15:13,199 --> 00:15:15,920
this is a recording of 10 milliseconds

399
00:15:15,920 --> 00:15:18,000
so it will use these 10 milliseconds in

400
00:15:18,000 --> 00:15:19,680
order to calculate the sound pressure

401
00:15:19,680 --> 00:15:20,880
level

402
00:15:20,880 --> 00:15:22,959
we can change this if desired but for

403
00:15:22,959 --> 00:15:25,680
now let's leave it at 10.

404
00:15:25,680 --> 00:15:27,120
then we're seeing a serial print

405
00:15:27,120 --> 00:15:29,360
statement that's printing out this

406
00:15:29,360 --> 00:15:32,079
sound sensor sound pressure level and

407
00:15:32,079 --> 00:15:35,360
then also printing the exact value

408
00:15:35,360 --> 00:15:37,120
then we see a short delay of 90

409
00:15:37,120 --> 00:15:38,720
milliseconds

410
00:15:38,720 --> 00:15:40,720
let's upload this and then try making

411
00:15:40,720 --> 00:15:41,920
some sounds

412
00:15:41,920 --> 00:15:44,880
if we open serial monitor under tools

413
00:15:44,880 --> 00:15:47,519
we'll see the sound pressure level

414
00:15:47,519 --> 00:15:49,279
as i'm speaking you can see that the

415
00:15:49,279 --> 00:15:52,160
sound level increases

416
00:15:52,160 --> 00:15:55,680
the baseline looks like it's about 58.89

417
00:15:55,680 --> 00:15:57,440
this might be a little different for you

418
00:15:57,440 --> 00:15:59,040
depending on what kind of environment

419
00:15:59,040 --> 00:16:00,480
you're in

420
00:16:00,480 --> 00:16:03,079
when i'm speaking it goes up to about

421
00:16:03,079 --> 00:16:05,680
62.41

422
00:16:05,680 --> 00:16:07,839
to see this increase more clearly we can

423
00:16:07,839 --> 00:16:09,759
look at the serial plotter

424
00:16:09,759 --> 00:16:11,759
this is next to serial monitor under

425
00:16:11,759 --> 00:16:13,839
tools

426
00:16:13,839 --> 00:16:16,000
if you open this up and then try

427
00:16:16,000 --> 00:16:17,360
speaking

428
00:16:17,360 --> 00:16:19,360
you'll see that the value increases when

429
00:16:19,360 --> 00:16:21,600
i'm speaking

430
00:16:21,600 --> 00:16:25,199
try clapping yelling and talking

431
00:16:25,199 --> 00:16:27,519
and making other sounds to see how the

432
00:16:27,519 --> 00:16:30,399
sound pressure level changes

433
00:16:30,399 --> 00:16:32,240
circuit playground's sound pressure

434
00:16:32,240 --> 00:16:34,560
level takes a sample of a specific

435
00:16:34,560 --> 00:16:37,120
length which is a number in parentheses

436
00:16:37,120 --> 00:16:38,079
in milliseconds

437
00:16:38,079 --> 00:16:40,079
and calculates a value between 50

438
00:16:40,079 --> 00:16:44,880
decibels to 100 decibels for that sample

439
00:16:44,880 --> 00:16:47,759
from the course files open up the sketch

440
00:16:47,759 --> 00:16:48,839
sound sensor

441
00:16:48,839 --> 00:16:52,240
lighting open up the sketch

442
00:16:52,240 --> 00:16:55,120
sound sensor lighting in this sketch

443
00:16:55,120 --> 00:16:56,800
we'll be changing lighting animation

444
00:16:56,800 --> 00:16:58,959
modes using sound sensor data

445
00:16:58,959 --> 00:17:00,720
to create an animation which reacts

446
00:17:00,720 --> 00:17:03,199
differently to a quiet ambient room

447
00:17:03,199 --> 00:17:06,400
people speaking and music

448
00:17:06,400 --> 00:17:08,400
the first thing you need to do actually

449
00:17:08,400 --> 00:17:09,760
is upload the sketch

450
00:17:09,760 --> 00:17:11,599
and then adjust the three sound level

451
00:17:11,599 --> 00:17:14,000
variables which are on lines

452
00:17:14,000 --> 00:17:18,240
29 to 31. we need to adjust these levels

453
00:17:18,240 --> 00:17:21,119
so they reflect the correct values

454
00:17:21,119 --> 00:17:23,280
open the serial monitor and experiment

455
00:17:23,280 --> 00:17:26,480
with ambient speaking and music levels

456
00:17:26,480 --> 00:17:28,400
and then enter the max values you

457
00:17:28,400 --> 00:17:31,440
noticed for each variable

458
00:17:31,440 --> 00:17:34,400
you might want to add 20 or so to music

459
00:17:34,400 --> 00:17:36,320
just to ensure we're always going to be

460
00:17:36,320 --> 00:17:38,960
animating

461
00:17:38,960 --> 00:17:41,440
the animations we used in this sketch

462
00:17:41,440 --> 00:17:43,840
should look familiar to you

463
00:17:43,840 --> 00:17:47,200
we're using juggle confetti

464
00:17:47,200 --> 00:17:50,320
and cyan now let's look at our loop

465
00:17:50,320 --> 00:17:51,600
function

466
00:17:51,600 --> 00:17:54,799
this is the real meat of our algorithm

467
00:17:54,799 --> 00:17:57,280
at the top is our sound sensor update

468
00:17:57,280 --> 00:17:58,559
loop

469
00:17:58,559 --> 00:18:01,840
we have a sensor update time we've given

470
00:18:01,840 --> 00:18:05,600
which is slow around 200 milliseconds

471
00:18:05,600 --> 00:18:07,520
this is because we get too many false

472
00:18:07,520 --> 00:18:10,720
positives otherwise

473
00:18:11,520 --> 00:18:13,760
you might want to slow it down even more

474
00:18:13,760 --> 00:18:15,039
or speed it up

475
00:18:15,039 --> 00:18:17,039
so experiment with it and see how you

476
00:18:17,039 --> 00:18:18,480
feel

477
00:18:18,480 --> 00:18:21,120
the value could depend on your mood do

478
00:18:21,120 --> 00:18:22,480
you want a rather static

479
00:18:22,480 --> 00:18:24,799
music detector with a value of around

480
00:18:24,799 --> 00:18:26,559
600 to a thousand

481
00:18:26,559 --> 00:18:28,160
or do you want a more reactive

482
00:18:28,160 --> 00:18:30,000
experience that might catch a sense of

483
00:18:30,000 --> 00:18:31,600
the beats it's hearing

484
00:18:31,600 --> 00:18:35,039
if so set it to around 100 to 200

485
00:18:35,039 --> 00:18:37,600
or it could depend on experimentation it

486
00:18:37,600 --> 00:18:39,360
could even depend on the bpm of the

487
00:18:39,360 --> 00:18:41,280
music you're trying to light

488
00:18:41,280 --> 00:18:43,200
mess with this value for a few minutes

489
00:18:43,200 --> 00:18:45,280
and see what you like

490
00:18:45,280 --> 00:18:48,160
next let's look at the if else block

491
00:18:48,160 --> 00:18:49,200
that's around

492
00:18:49,200 --> 00:18:52,000
line 88. this is one way to change

493
00:18:52,000 --> 00:18:53,520
animation behavior

494
00:18:53,520 --> 00:18:56,480
when data changes if you put your

495
00:18:56,480 --> 00:18:58,400
animations in separate functions

496
00:18:58,400 --> 00:19:00,640
making sure not to include fast leds

497
00:19:00,640 --> 00:19:01,679
show

498
00:19:01,679 --> 00:19:03,520
you can choose the animation based on

499
00:19:03,520 --> 00:19:05,360
your incoming sensor data

500
00:19:05,360 --> 00:19:08,320
and then run fast led shows separately

501
00:19:08,320 --> 00:19:10,240
here we're also changing the light

502
00:19:10,240 --> 00:19:12,559
update time to give each animation the

503
00:19:12,559 --> 00:19:13,440
right feel

504
00:19:13,440 --> 00:19:16,080
for the level of input we're getting

505
00:19:16,080 --> 00:19:18,080
quiet moments want to be calm but not

506
00:19:18,080 --> 00:19:18,880
too calm

507
00:19:18,880 --> 00:19:21,280
like a waiting state so i thought sign

508
00:19:21,280 --> 00:19:23,039
lawn was appropriate

509
00:19:23,039 --> 00:19:25,039
i chose the juggling algorithm in a

510
00:19:25,039 --> 00:19:27,120
slower update speed to give the speaking

511
00:19:27,120 --> 00:19:28,960
state a bubbly feel

512
00:19:28,960 --> 00:19:30,880
and the music state feels like it ought

513
00:19:30,880 --> 00:19:32,320
to be busy and bright

514
00:19:32,320 --> 00:19:34,799
like sparkly lightning you might make

515
00:19:34,799 --> 00:19:36,640
other choices so experiment with the

516
00:19:36,640 --> 00:19:38,559
file and see what you think

517
00:19:38,559 --> 00:19:40,559
can you create three new animations that

518
00:19:40,559 --> 00:19:42,080
match these moods

519
00:19:42,080 --> 00:19:44,000
can you add more than three different

520
00:19:44,000 --> 00:19:45,520
sound levels and corresponding

521
00:19:45,520 --> 00:19:46,799
animations

522
00:19:46,799 --> 00:19:50,320
give it a try see how it goes next let's

523
00:19:50,320 --> 00:19:54,159
have a look at the temperature sensor

524
00:19:54,320 --> 00:19:56,400
it's easy to calculate the temperature

525
00:19:56,400 --> 00:19:58,160
based on the analog voltage

526
00:19:58,160 --> 00:20:01,840
on analog pin a0 there's a 10k

527
00:20:01,840 --> 00:20:04,000
one percent resistor connected to it as

528
00:20:04,000 --> 00:20:05,120
a pull down

529
00:20:05,120 --> 00:20:06,960
and you can read the analog value and

530
00:20:06,960 --> 00:20:08,400
calculate the temperature

531
00:20:08,400 --> 00:20:10,880
with the beta constant or just use the

532
00:20:10,880 --> 00:20:13,120
circuit playground library

533
00:20:13,120 --> 00:20:14,799
the circuit playground library has a

534
00:20:14,799 --> 00:20:17,919
built-in circuitplayground.temperature

535
00:20:17,919 --> 00:20:20,240
function which will give you a floating

536
00:20:20,240 --> 00:20:22,799
point number in centigrade

537
00:20:22,799 --> 00:20:25,120
also if you need to use fahrenheit they

538
00:20:25,120 --> 00:20:26,640
have a built-in function for that as

539
00:20:26,640 --> 00:20:27,200
well

540
00:20:27,200 --> 00:20:29,520
which is circuit playground.temperature

541
00:20:29,520 --> 00:20:31,280
f

542
00:20:31,280 --> 00:20:35,840
we'll have a look at both of these

543
00:20:37,039 --> 00:20:39,440
open up the file hello temperature

544
00:20:39,440 --> 00:20:41,520
upload it and check serial monitor to

545
00:20:41,520 --> 00:20:43,919
see what temperature it is

546
00:20:43,919 --> 00:20:46,080
in this sketch we have float variables

547
00:20:46,080 --> 00:20:47,280
for both the temperature

548
00:20:47,280 --> 00:20:49,039
and celsius and the temperature in

549
00:20:49,039 --> 00:20:50,880
fahrenheit temp c

550
00:20:50,880 --> 00:20:53,919
and temp f accordingly in our loop

551
00:20:53,919 --> 00:20:54,640
function

552
00:20:54,640 --> 00:20:56,640
we're updating the values for each

553
00:20:56,640 --> 00:20:58,640
variable then we're printing out the

554
00:20:58,640 --> 00:20:59,280
data

555
00:20:59,280 --> 00:21:01,120
there's a one second delay between

556
00:21:01,120 --> 00:21:02,320
readings

557
00:21:02,320 --> 00:21:04,320
if we upload the sketch and then open

558
00:21:04,320 --> 00:21:07,280
serial monitor

559
00:21:08,000 --> 00:21:09,760
we can see the temperature readings for

560
00:21:09,760 --> 00:21:17,440
both celsius and fahrenheit

561
00:21:17,440 --> 00:21:20,000
as a challenge what can you do to change

562
00:21:20,000 --> 00:21:22,320
the reading on the temperature sensor

563
00:21:22,320 --> 00:21:23,520
try to think about how you can

564
00:21:23,520 --> 00:21:25,600
manipulate your environment to make it

565
00:21:25,600 --> 00:21:28,640
colder or hotter

566
00:21:28,640 --> 00:21:30,640
here are a few potential solutions to

567
00:21:30,640 --> 00:21:32,480
this challenge but there are probably

568
00:21:32,480 --> 00:21:33,840
many more

569
00:21:33,840 --> 00:21:37,200
one is to use fans or heaters to heat or

570
00:21:37,200 --> 00:21:40,320
cool the sensor another

571
00:21:40,320 --> 00:21:42,159
option would be to take your circuit

572
00:21:42,159 --> 00:21:44,000
playground express outside

573
00:21:44,000 --> 00:21:46,720
or bring it into different rooms you can

574
00:21:46,720 --> 00:21:48,799
also try warming the sensor by putting

575
00:21:48,799 --> 00:21:50,559
it between your hands

576
00:21:50,559 --> 00:21:54,159
or you can try breathing on the sensor

577
00:21:54,159 --> 00:21:55,840
have a look at the birthday candles

578
00:21:55,840 --> 00:21:58,000
example under microphone demos

579
00:21:58,000 --> 00:22:00,159
in the circuit playground library to see

580
00:22:00,159 --> 00:22:03,360
how this might be used

581
00:22:04,480 --> 00:22:07,440
now it's time for a big challenge what

582
00:22:07,440 --> 00:22:09,520
if you wanted to create a lamp

583
00:22:09,520 --> 00:22:11,520
that had different lighting animations

584
00:22:11,520 --> 00:22:14,640
depending on what temperature it was

585
00:22:14,640 --> 00:22:17,120
maybe on hot days you wanted a bright

586
00:22:17,120 --> 00:22:18,559
and sunny animation

587
00:22:18,559 --> 00:22:21,760
full of yellows and reds and maybe

588
00:22:21,760 --> 00:22:24,640
on a more rainy and dim day you wanted

589
00:22:24,640 --> 00:22:27,200
cool blues and purples

590
00:22:27,200 --> 00:22:30,159
how would you do this

591
00:22:30,559 --> 00:22:32,880
you might begin by considering how are

592
00:22:32,880 --> 00:22:34,320
you going to install

593
00:22:34,320 --> 00:22:37,360
the circuit playground so you might put

594
00:22:37,360 --> 00:22:38,559
it inside of

595
00:22:38,559 --> 00:22:41,520
a paper sculpture or you could put it

596
00:22:41,520 --> 00:22:44,799
inside of the 3d printed cover

597
00:22:44,799 --> 00:22:48,080
you could take an object that's hollow

598
00:22:48,080 --> 00:22:51,360
and put the circuit playground inside

599
00:22:51,360 --> 00:22:52,960
you could even use something like a

600
00:22:52,960 --> 00:22:54,720
basket or colander

601
00:22:54,720 --> 00:22:57,760
to let the light shine through

602
00:22:57,760 --> 00:22:59,520
for the programming you're going to

603
00:22:59,520 --> 00:23:01,520
start by wanting to keep track of the

604
00:23:01,520 --> 00:23:03,280
sensor data

605
00:23:03,280 --> 00:23:05,760
and then in certain circumstances you'll

606
00:23:05,760 --> 00:23:08,240
want to switch the animation

607
00:23:08,240 --> 00:23:10,240
we've done this before but see if you

608
00:23:10,240 --> 00:23:13,039
can give it a try

609
00:23:13,039 --> 00:23:14,960
the circuit playground express has an

610
00:23:14,960 --> 00:23:17,200
onboard light sensor that's connected to

611
00:23:17,200 --> 00:23:19,120
analog pin 5.

612
00:23:19,120 --> 00:23:21,600
you can use analog read or you can use

613
00:23:21,600 --> 00:23:23,120
the light sensor function

614
00:23:23,120 --> 00:23:25,120
from the library in order to read the

615
00:23:25,120 --> 00:23:26,159
value

616
00:23:26,159 --> 00:23:29,440
the value will be between 0 and 123 with

617
00:23:29,440 --> 00:23:31,360
higher values corresponding to brighter

618
00:23:31,360 --> 00:23:32,720
light levels

619
00:23:32,720 --> 00:23:35,679
the range is approximately 0 lux to 1500

620
00:23:35,679 --> 00:23:36,080
lux

621
00:23:36,080 --> 00:23:39,280
maximum because average daylight is 10

622
00:23:39,280 --> 00:23:41,919
000 lux or so this sensor is best suited

623
00:23:41,919 --> 00:23:44,000
for indoor lighting

624
00:23:44,000 --> 00:23:46,000
an average indoor light level will be

625
00:23:46,000 --> 00:23:48,080
about 300.

626
00:23:48,080 --> 00:23:50,080
we'll use the following sketch in order

627
00:23:50,080 --> 00:23:52,080
to tell what the average light level is

628
00:23:52,080 --> 00:23:53,440
for your environment

629
00:23:53,440 --> 00:23:56,400
as well as what is dark or bright for

630
00:23:56,400 --> 00:23:58,480
your environment

631
00:23:58,480 --> 00:24:00,880
open the sketch hello light sensor from

632
00:24:00,880 --> 00:24:02,720
either your course files or from the

633
00:24:02,720 --> 00:24:06,080
adafruit circuit playground library

634
00:24:06,080 --> 00:24:08,159
upload the sketch and try putting your

635
00:24:08,159 --> 00:24:10,159
hand over the circuit playground

636
00:24:10,159 --> 00:24:12,400
then taking it away to see changes in

637
00:24:12,400 --> 00:24:15,840
the data in serial monitor

638
00:24:15,840 --> 00:24:18,159
so in this sketch we're storing the

639
00:24:18,159 --> 00:24:19,440
light sensor value

640
00:24:19,440 --> 00:24:23,600
as a integer into value

641
00:24:23,600 --> 00:24:26,880
and then we're updating that in the loop

642
00:24:26,880 --> 00:24:30,559
by calling circuitplayground.lightsensor

643
00:24:30,559 --> 00:24:32,320
we're then printing out the light sensor

644
00:24:32,320 --> 00:24:34,159
and the value

645
00:24:34,159 --> 00:24:37,200
and then we have a delay of one second

646
00:24:37,200 --> 00:24:40,240
so it's taking readings pretty slow we

647
00:24:40,240 --> 00:24:41,120
could update this

648
00:24:41,120 --> 00:24:43,600
if we want to take the readings faster

649
00:24:43,600 --> 00:24:45,919
let's have a look at serial monitor and

650
00:24:45,919 --> 00:24:46,480
see

651
00:24:46,480 --> 00:24:49,520
what the default reading is for this

652
00:24:49,520 --> 00:24:51,840
room

653
00:24:54,559 --> 00:24:56,159
so you can see that the reading is

654
00:24:56,159 --> 00:24:58,840
pretty stable it's either

655
00:24:58,840 --> 00:25:03,200
197 to 199

656
00:25:03,200 --> 00:25:05,679
so it's a today is an overcast day which

657
00:25:05,679 --> 00:25:07,840
is typical in copenhagen

658
00:25:07,840 --> 00:25:10,000
not a lot of light in the room pretty

659
00:25:10,000 --> 00:25:12,159
dim if your room is brighter

660
00:25:12,159 --> 00:25:13,600
you probably have a light reading of

661
00:25:13,600 --> 00:25:15,600
about 300 or so

662
00:25:15,600 --> 00:25:17,440
and if it's very bright it's probably

663
00:25:17,440 --> 00:25:18,640
above that

664
00:25:18,640 --> 00:25:20,240
if it's lower than that i'm guessing

665
00:25:20,240 --> 00:25:21,919
that it's night time where you were at

666
00:25:21,919 --> 00:25:22,400
or

667
00:25:22,400 --> 00:25:24,880
it's very dim lighting now when i put my

668
00:25:24,880 --> 00:25:27,120
hand over the sensor

669
00:25:27,120 --> 00:25:30,000
you can see that it drops down to about

670
00:25:30,000 --> 00:25:31,440
40.

671
00:25:31,440 --> 00:25:33,520
this is with my hand completely covering

672
00:25:33,520 --> 00:25:36,158
the sensor

673
00:25:38,400 --> 00:25:40,240
if i put my hand on the circuit

674
00:25:40,240 --> 00:25:41,840
playground it drops down even

675
00:25:41,840 --> 00:25:44,000
further and now i'm just getting a

676
00:25:44,000 --> 00:25:47,120
single digit reading

677
00:25:48,960 --> 00:25:52,480
if i hold my hand over the sensor

678
00:25:52,480 --> 00:25:57,840
i get a reading of about 100 or so

679
00:26:05,919 --> 00:26:07,760
so you can see how you might start to

680
00:26:07,760 --> 00:26:09,200
play with these values

681
00:26:09,200 --> 00:26:11,039
as thresholds in order to trigger

682
00:26:11,039 --> 00:26:12,720
different kinds of interactivity

683
00:26:12,720 --> 00:26:15,760
depending on how light or dark something

684
00:26:15,760 --> 00:26:16,159
is

685
00:26:16,159 --> 00:26:18,320
you can also in this way use a light

686
00:26:18,320 --> 00:26:20,640
sensor as a proximity sensor

687
00:26:20,640 --> 00:26:22,000
because if light isn't shining on the

688
00:26:22,000 --> 00:26:23,840
sensor then you know that something is

689
00:26:23,840 --> 00:26:25,120
blocking it

690
00:26:25,120 --> 00:26:27,360
so in this way it can kind of be used to

691
00:26:27,360 --> 00:26:30,159
detect motion or an obstruction

692
00:26:30,159 --> 00:26:31,760
there are other sensors that do this

693
00:26:31,760 --> 00:26:33,520
more efficiently but

694
00:26:33,520 --> 00:26:35,360
unfortunately the circuit playground

695
00:26:35,360 --> 00:26:37,679
doesn't have any other proximity sensors

696
00:26:37,679 --> 00:26:38,640
on board

697
00:26:38,640 --> 00:26:40,480
so the light sensor is a good candidate

698
00:26:40,480 --> 00:26:42,080
if you're trying to see if something is

699
00:26:42,080 --> 00:26:45,279
in the way of the sensor

700
00:26:45,360 --> 00:26:50,400
open up the sketch light sensor if else

701
00:26:50,400 --> 00:26:52,720
in this sketch we have three different

702
00:26:52,720 --> 00:26:53,919
variables

703
00:26:53,919 --> 00:26:56,799
we have a light value and this is the

704
00:26:56,799 --> 00:26:57,600
variable

705
00:26:57,600 --> 00:27:00,799
that will store our light sensor value

706
00:27:00,799 --> 00:27:03,279
then we have a variable for average

707
00:27:03,279 --> 00:27:04,320
light

708
00:27:04,320 --> 00:27:06,880
and a variable for bright light so these

709
00:27:06,880 --> 00:27:09,360
are two different threshold values

710
00:27:09,360 --> 00:27:12,320
so we've decided that average light is

711
00:27:12,320 --> 00:27:13,039
anything

712
00:27:13,039 --> 00:27:16,400
between 150 to 550

713
00:27:16,400 --> 00:27:19,679
and then bright light is 550 or above

714
00:27:19,679 --> 00:27:21,679
anything that's under average light

715
00:27:21,679 --> 00:27:24,080
would be low lighting

716
00:27:24,080 --> 00:27:25,840
so let's take a look at how this might

717
00:27:25,840 --> 00:27:27,279
work if we wanted to have three

718
00:27:27,279 --> 00:27:29,440
different thresholds

719
00:27:29,440 --> 00:27:31,679
first we still want to update the

720
00:27:31,679 --> 00:27:34,559
variable for light value every loop

721
00:27:34,559 --> 00:27:36,640
and that is taking the reading from the

722
00:27:36,640 --> 00:27:38,640
light sensor and storing it as light

723
00:27:38,640 --> 00:27:39,919
value

724
00:27:39,919 --> 00:27:42,399
then we're going to print the value and

725
00:27:42,399 --> 00:27:43,760
then we have an if

726
00:27:43,760 --> 00:27:46,799
else if else statement

727
00:27:46,799 --> 00:27:49,840
so we've seen if and else before

728
00:27:49,840 --> 00:27:52,480
but now we're seeing else if which is a

729
00:27:52,480 --> 00:27:54,159
third condition

730
00:27:54,159 --> 00:27:56,799
and this is a program so it's going to

731
00:27:56,799 --> 00:27:57,360
be

732
00:27:57,360 --> 00:27:59,919
computing this in order so it's first

733
00:27:59,919 --> 00:28:01,840
going to check the if statement

734
00:28:01,840 --> 00:28:03,360
then it's going to check the else if

735
00:28:03,360 --> 00:28:05,039
statement and then it's going to check

736
00:28:05,039 --> 00:28:07,120
the else statement

737
00:28:07,120 --> 00:28:10,399
so first it checks is the light value

738
00:28:10,399 --> 00:28:12,000
which again is our reading from the

739
00:28:12,000 --> 00:28:13,440
sensor is that

740
00:28:13,440 --> 00:28:15,600
greater than or equal to the value for

741
00:28:15,600 --> 00:28:16,880
bright light

742
00:28:16,880 --> 00:28:20,559
which again is 550.

743
00:28:20,559 --> 00:28:22,720
if it is then we're going to have it

744
00:28:22,720 --> 00:28:25,279
print bright light

745
00:28:25,279 --> 00:28:27,760
and then we're also going to have a for

746
00:28:27,760 --> 00:28:30,320
loop where we set the pixel color

747
00:28:30,320 --> 00:28:32,720
to red

748
00:28:34,000 --> 00:28:38,480
and that's for each led

749
00:28:38,960 --> 00:28:40,480
then we want to check if it's medium

750
00:28:40,480 --> 00:28:43,120
light so we have this else if statement

751
00:28:43,120 --> 00:28:44,480
that says

752
00:28:44,480 --> 00:28:47,840
else if the light value is less than

753
00:28:47,840 --> 00:28:49,279
bright light

754
00:28:49,279 --> 00:28:52,480
and the light value is above average

755
00:28:52,480 --> 00:28:53,919
light

756
00:28:53,919 --> 00:28:55,760
so this is checking to make sure both of

757
00:28:55,760 --> 00:28:57,600
these conditions are true

758
00:28:57,600 --> 00:29:00,000
and this is how this double ampersand is

759
00:29:00,000 --> 00:29:00,880
how you do an

760
00:29:00,880 --> 00:29:03,840
and you can't use a plus because a plus

761
00:29:03,840 --> 00:29:05,360
is a mathematical

762
00:29:05,360 --> 00:29:08,159
operation so if you used a plus it would

763
00:29:08,159 --> 00:29:09,679
try to add these two

764
00:29:09,679 --> 00:29:13,279
together so we have to use this

765
00:29:13,279 --> 00:29:15,919
combination of two ampersands to make an

766
00:29:15,919 --> 00:29:16,320
and

767
00:29:16,320 --> 00:29:19,840
statement but it's basically saying

768
00:29:19,840 --> 00:29:23,840
if this is true and if this is true

769
00:29:23,840 --> 00:29:26,000
so if both those things are true then we

770
00:29:26,000 --> 00:29:28,000
want to print medium light

771
00:29:28,000 --> 00:29:29,440
and then we want to set all the pixels

772
00:29:29,440 --> 00:29:31,760
to green

773
00:29:31,760 --> 00:29:34,480
lastly we want to see if it's low light

774
00:29:34,480 --> 00:29:36,159
and we don't have to check that

775
00:29:36,159 --> 00:29:38,000
because we know if these two things

776
00:29:38,000 --> 00:29:39,600
aren't true

777
00:29:39,600 --> 00:29:41,600
then it's going to be low light because

778
00:29:41,600 --> 00:29:44,320
it's the only option that's remaining

779
00:29:44,320 --> 00:29:46,320
so if it's low light it'll print low

780
00:29:46,320 --> 00:29:48,080
light and then it'll set

781
00:29:48,080 --> 00:29:51,039
all the pixels to blue and then we have

782
00:29:51,039 --> 00:29:51,760
a delay

783
00:29:51,760 --> 00:29:54,399
of half of a second and that's between

784
00:29:54,399 --> 00:29:55,440
every check

785
00:29:55,440 --> 00:29:58,640
of this whole loop so let's try it out

786
00:29:58,640 --> 00:30:02,320
and try to put our hand over the sensor

787
00:30:02,320 --> 00:30:05,440
at varying distances and see if we can

788
00:30:05,440 --> 00:30:07,760
get those three thresholds to work

789
00:30:07,760 --> 00:30:09,520
you might have to adjust these numbers

790
00:30:09,520 --> 00:30:11,039
so that they're more accurate to your

791
00:30:11,039 --> 00:30:12,320
lighting environment

792
00:30:12,320 --> 00:30:14,320
but the goal should be that when your

793
00:30:14,320 --> 00:30:17,120
hand is not on the sensor

794
00:30:17,120 --> 00:30:18,960
and there's bright light then it should

795
00:30:18,960 --> 00:30:20,840
have its own

796
00:30:20,840 --> 00:30:24,000
threshold and there should also be a

797
00:30:24,000 --> 00:30:26,000
threshold for average light so if your

798
00:30:26,000 --> 00:30:28,320
hand is hovering above the sensor

799
00:30:28,320 --> 00:30:30,960
it should be whatever this value is and

800
00:30:30,960 --> 00:30:32,240
then low light would be

801
00:30:32,240 --> 00:30:33,760
if you have your hand covering the

802
00:30:33,760 --> 00:30:35,600
sensor completely

803
00:30:35,600 --> 00:30:38,639
so let's give it a try

804
00:30:43,440 --> 00:30:45,440
for a challenge how would you automate

805
00:30:45,440 --> 00:30:46,880
your lighting system

806
00:30:46,880 --> 00:30:49,120
so that when it's completely dark a

807
00:30:49,120 --> 00:30:51,360
certain lighting animation plays

808
00:30:51,360 --> 00:30:53,520
but when it's medium or low light a

809
00:30:53,520 --> 00:30:55,360
different animation plays

810
00:30:55,360 --> 00:30:58,080
what about when it's very very bright

811
00:30:58,080 --> 00:30:59,519
can you create a lamp

812
00:30:59,519 --> 00:31:01,200
that will respond to these different

813
00:31:01,200 --> 00:31:02,960
lighting situations

814
00:31:02,960 --> 00:31:06,320
try using fast led to solve this

815
00:31:06,320 --> 00:31:06,960
challenge

816
00:31:06,960 --> 00:31:09,120
i looked at a few sketches we've already

817
00:31:09,120 --> 00:31:10,240
done

818
00:31:10,240 --> 00:31:12,320
for starters i looked at our light

819
00:31:12,320 --> 00:31:14,080
sensor example

820
00:31:14,080 --> 00:31:16,559
and then i also looked at our color

821
00:31:16,559 --> 00:31:18,240
palette example

822
00:31:18,240 --> 00:31:21,919
and i decided to basically merge the two

823
00:31:21,919 --> 00:31:24,320
so i began of course by including all of

824
00:31:24,320 --> 00:31:25,120
the normal

825
00:31:25,120 --> 00:31:28,640
fast led setup instructions

826
00:31:28,640 --> 00:31:30,480
including the adafruit circuit

827
00:31:30,480 --> 00:31:31,679
playground library

828
00:31:31,679 --> 00:31:34,720
fast led library and all of the

829
00:31:34,720 --> 00:31:36,880
information that fast led will need in

830
00:31:36,880 --> 00:31:39,760
order to output to our lights

831
00:31:39,760 --> 00:31:42,559
i then also copied over our three

832
00:31:42,559 --> 00:31:43,760
variables

833
00:31:43,760 --> 00:31:47,039
one to detect the light value meaning

834
00:31:47,039 --> 00:31:51,120
the value that will store the light

835
00:31:51,120 --> 00:31:53,679
and also an average light and a bright

836
00:31:53,679 --> 00:31:55,120
light value

837
00:31:55,120 --> 00:31:56,640
if you're going to try the sketch out

838
00:31:56,640 --> 00:31:58,320
you're of course going to want to

839
00:31:58,320 --> 00:32:00,480
tell what average light and bright light

840
00:32:00,480 --> 00:32:02,720
are for you in your environment

841
00:32:02,720 --> 00:32:06,960
they'll be different than what mine is

842
00:32:06,960 --> 00:32:10,000
then i have some timers and of course i

843
00:32:10,000 --> 00:32:11,760
have these because i need

844
00:32:11,760 --> 00:32:13,760
to have different timers for different

845
00:32:13,760 --> 00:32:15,279
lighting patterns

846
00:32:15,279 --> 00:32:17,519
this will really change the feel of the

847
00:32:17,519 --> 00:32:19,840
pattern and i wanted to make a lamp that

848
00:32:19,840 --> 00:32:21,279
really responds to

849
00:32:21,279 --> 00:32:24,480
times of day or different weather

850
00:32:24,480 --> 00:32:25,279
patterns

851
00:32:25,279 --> 00:32:27,919
so to really give a matching feel or

852
00:32:27,919 --> 00:32:28,960
evocative

853
00:32:28,960 --> 00:32:32,480
lighting pattern and then i also

854
00:32:32,480 --> 00:32:35,600
want to have a

855
00:32:35,600 --> 00:32:39,120
sensor update timer because

856
00:32:39,120 --> 00:32:41,760
i can't actually measure the light while

857
00:32:41,760 --> 00:32:42,799
the leds are

858
00:32:42,799 --> 00:32:45,760
on if they're on because they're all

859
00:32:45,760 --> 00:32:47,760
attached to the same board

860
00:32:47,760 --> 00:32:49,440
it changes the reading for the light

861
00:32:49,440 --> 00:32:52,159
sensor and so i need to turn off the

862
00:32:52,159 --> 00:32:55,279
leds in order to take a reading and i've

863
00:32:55,279 --> 00:32:56,240
set that to be

864
00:32:56,240 --> 00:32:59,919
once per minute so uh once per minute

865
00:32:59,919 --> 00:33:02,399
you'll see the leds go off

866
00:33:02,399 --> 00:33:04,960
um this was the simplest way i could

867
00:33:04,960 --> 00:33:06,159
find to resolve

868
00:33:06,159 --> 00:33:08,720
this problem but you also could

869
00:33:08,720 --> 00:33:10,000
depending on what you're trying

870
00:33:10,000 --> 00:33:11,600
to make if you're just trying to make a

871
00:33:11,600 --> 00:33:13,360
lamp that responds to different times of

872
00:33:13,360 --> 00:33:13,840
day

873
00:33:13,840 --> 00:33:16,399
you might have this to do it only once

874
00:33:16,399 --> 00:33:17,519
every hour

875
00:33:17,519 --> 00:33:20,799
and then it's not really an issue

876
00:33:20,799 --> 00:33:22,640
and then of course i'm storing sensor

877
00:33:22,640 --> 00:33:25,840
millis so i can keep track

878
00:33:27,279 --> 00:33:29,440
then i have some random palettes for

879
00:33:29,440 --> 00:33:30,799
each light level

880
00:33:30,799 --> 00:33:33,279
and these will change every five seconds

881
00:33:33,279 --> 00:33:34,640
as can be seen in our

882
00:33:34,640 --> 00:33:38,000
palette update timer i wanted to provide

883
00:33:38,000 --> 00:33:39,919
not just one example of a lighting

884
00:33:39,919 --> 00:33:41,760
pattern that might work for a specific

885
00:33:41,760 --> 00:33:42,720
situation

886
00:33:42,720 --> 00:33:46,000
but multiple examples so i decided to do

887
00:33:46,000 --> 00:33:46,399
that

888
00:33:46,399 --> 00:33:49,518
by shifting them up

889
00:33:50,880 --> 00:33:53,600
and then of course i have my palettes

890
00:33:53,600 --> 00:33:55,840
which are gradient palettes

891
00:33:55,840 --> 00:33:59,279
and these i just made in the usual way

892
00:33:59,279 --> 00:34:02,399
by using a palette knife and going to

893
00:34:02,399 --> 00:34:03,039
cpt

894
00:34:03,039 --> 00:34:06,240
city and as you can see i have three for

895
00:34:06,240 --> 00:34:06,960
low light

896
00:34:06,960 --> 00:34:09,199
three for medium light and three for

897
00:34:09,199 --> 00:34:10,800
bright light

898
00:34:10,800 --> 00:34:13,679
and if you upload this you'll see um

899
00:34:13,679 --> 00:34:15,040
what my choices were

900
00:34:15,040 --> 00:34:17,359
and if you had different choices that's

901
00:34:17,359 --> 00:34:18,320
absolutely fine

902
00:34:18,320 --> 00:34:21,040
it really is about creating the the lamp

903
00:34:21,040 --> 00:34:21,679
for you

904
00:34:21,679 --> 00:34:24,159
and the lamp that would be ideal for you

905
00:34:24,159 --> 00:34:25,760
and how you feel in different times of

906
00:34:25,760 --> 00:34:26,639
day or

907
00:34:26,639 --> 00:34:28,800
what you would want from a lamp that

908
00:34:28,800 --> 00:34:30,079
changes

909
00:34:30,079 --> 00:34:33,440
according to different light levels

910
00:34:33,760 --> 00:34:35,760
then i have my normal setup for using

911
00:34:35,760 --> 00:34:37,280
palettes

912
00:34:37,280 --> 00:34:40,560
and in setup i have my usual for

913
00:34:40,560 --> 00:34:45,119
fast led and for the circuit playground

914
00:34:45,119 --> 00:34:47,440
then in my loop as you might expect i'm

915
00:34:47,440 --> 00:34:49,440
checking first and foremost

916
00:34:49,440 --> 00:34:52,480
to see if the time has elapsed

917
00:34:52,480 --> 00:34:56,000
for me to take a sensor reading and if

918
00:34:56,000 --> 00:34:57,200
it has

919
00:34:57,200 --> 00:35:00,320
then what i want to do is i want to

920
00:35:00,320 --> 00:35:03,200
turn all of the leds off and so i've

921
00:35:03,200 --> 00:35:05,520
decided to use maximize brightness in

922
00:35:05,520 --> 00:35:06,480
order to do that

923
00:35:06,480 --> 00:35:08,400
so that just sets the brightness to zero

924
00:35:08,400 --> 00:35:09,920
for all the leds

925
00:35:09,920 --> 00:35:12,720
then i'm doing a fast led show call and

926
00:35:12,720 --> 00:35:14,640
i'm setting the light value equal to the

927
00:35:14,640 --> 00:35:18,240
circuit playground's light sensor

928
00:35:19,599 --> 00:35:21,440
finally i'm printing out the data for

929
00:35:21,440 --> 00:35:24,160
the light sensor

930
00:35:24,160 --> 00:35:27,920
and then i'm turning the leds back on

931
00:35:27,920 --> 00:35:30,800
by maximizing the brightness so it's a

932
00:35:30,800 --> 00:35:31,520
very quick

933
00:35:31,520 --> 00:35:34,800
turn everything off and then

934
00:35:34,800 --> 00:35:37,839
display that data using fast led show in

935
00:35:37,839 --> 00:35:39,119
order to turn it to

936
00:35:39,119 --> 00:35:41,440
all the way off then take a reading from

937
00:35:41,440 --> 00:35:43,040
the light sensor

938
00:35:43,040 --> 00:35:45,839
and then turn the leds back to full on

939
00:35:45,839 --> 00:35:46,320
and

940
00:35:46,320 --> 00:35:48,640
then i'm updating my timer if you want

941
00:35:48,640 --> 00:35:50,640
to have a look at how this is done you

942
00:35:50,640 --> 00:35:52,240
can also see

943
00:35:52,240 --> 00:35:55,599
the light value change in our serial

944
00:35:55,599 --> 00:35:58,560
print line statement here

945
00:35:58,560 --> 00:36:00,640
and then i wanted to change the palette

946
00:36:00,640 --> 00:36:01,839
periodically

947
00:36:01,839 --> 00:36:05,280
so this will happen of course even if

948
00:36:05,280 --> 00:36:06,480
millie's hasn't

949
00:36:06,480 --> 00:36:09,200
elapsed so this is what's keeping track

950
00:36:09,200 --> 00:36:10,240
of that shifting

951
00:36:10,240 --> 00:36:13,520
it's its own uh function

952
00:36:13,520 --> 00:36:15,760
and then we see the familiar max changes

953
00:36:15,760 --> 00:36:17,520
of 24

954
00:36:17,520 --> 00:36:19,839
and every n milliseconds we're blending

955
00:36:19,839 --> 00:36:21,839
one palette towards another so that we

956
00:36:21,839 --> 00:36:22,880
get that nice

957
00:36:22,880 --> 00:36:26,000
blend in the next

958
00:36:26,000 --> 00:36:28,800
loop i'm checking if melody's as is

959
00:36:28,800 --> 00:36:30,320
greater than lighting millies

960
00:36:30,320 --> 00:36:32,320
and if it's time then we'll animate our

961
00:36:32,320 --> 00:36:34,720
lights

962
00:36:37,599 --> 00:36:39,599
then i have some functions for our

963
00:36:39,599 --> 00:36:41,280
lighting so the first is

964
00:36:41,280 --> 00:36:43,040
fill leds from palette colors which

965
00:36:43,040 --> 00:36:44,480
we've seen before

966
00:36:44,480 --> 00:36:47,760
and this will just turn all of the leds

967
00:36:47,760 --> 00:36:51,200
to be filled with our patterns from our

968
00:36:51,200 --> 00:36:54,880
color palettes and then i have

969
00:36:54,880 --> 00:36:56,560
my call to change the palette

970
00:36:56,560 --> 00:36:57,920
periodically

971
00:36:57,920 --> 00:37:00,880
and so this is checked again against

972
00:37:00,880 --> 00:37:01,839
palette melees

973
00:37:01,839 --> 00:37:03,920
so if it's time to change the palette

974
00:37:03,920 --> 00:37:05,200
this will change

975
00:37:05,200 --> 00:37:06,880
because we have all these timers that

976
00:37:06,880 --> 00:37:08,880
are going concurrently it means we can

977
00:37:08,880 --> 00:37:10,320
keep track of time

978
00:37:10,320 --> 00:37:12,000
for each event and we don't have to

979
00:37:12,000 --> 00:37:14,480
worry about relying on one thing

980
00:37:14,480 --> 00:37:16,880
for another because the reading of the

981
00:37:16,880 --> 00:37:18,480
sensor is independent

982
00:37:18,480 --> 00:37:20,240
from the changing of the palette that's

983
00:37:20,240 --> 00:37:23,200
going to happen

984
00:37:23,200 --> 00:37:25,040
in our change palette periodically you

985
00:37:25,040 --> 00:37:26,720
might be wondering where are we actually

986
00:37:26,720 --> 00:37:27,680
checking

987
00:37:27,680 --> 00:37:29,839
our lights our light data our sensor

988
00:37:29,839 --> 00:37:32,960
data and it's happening here

989
00:37:32,960 --> 00:37:36,240
so here we have our if else if else

990
00:37:36,240 --> 00:37:38,720
block that we've seen before

991
00:37:38,720 --> 00:37:41,760
and we're saying if the light value is

992
00:37:41,760 --> 00:37:44,000
greater than or equal to bright light

993
00:37:44,000 --> 00:37:46,720
then we want the min p which is a

994
00:37:46,720 --> 00:37:49,040
variable we've set up here

995
00:37:49,040 --> 00:37:52,480
to be the bright light min palette

996
00:37:52,480 --> 00:37:55,599
and if it's and then we want max p

997
00:37:55,599 --> 00:37:58,800
to be the bright light max palette

998
00:37:58,800 --> 00:38:00,640
and what that does is it just makes it

999
00:38:00,640 --> 00:38:02,160
so that we can play through those

1000
00:38:02,160 --> 00:38:03,440
palettes

1001
00:38:03,440 --> 00:38:05,520
we only have three here but we could add

1002
00:38:05,520 --> 00:38:09,119
more using this structure

1003
00:38:10,079 --> 00:38:11,920
and then we also want to pick a random

1004
00:38:11,920 --> 00:38:13,520
palette every time

1005
00:38:13,520 --> 00:38:16,839
so we have some random function down

1006
00:38:16,839 --> 00:38:18,079
here

1007
00:38:18,079 --> 00:38:19,520
and then we have our playlist of

1008
00:38:19,520 --> 00:38:21,440
gradient palettes at the very

1009
00:38:21,440 --> 00:38:23,599
bottom which go from low light one

1010
00:38:23,599 --> 00:38:25,119
through three medium light one through

1011
00:38:25,119 --> 00:38:27,440
three to bright light one through three

1012
00:38:27,440 --> 00:38:29,680
finally we are able to calculate the

1013
00:38:29,680 --> 00:38:32,560
size of the array automatically using

1014
00:38:32,560 --> 00:38:36,560
this variable that keeps track

1015
00:38:36,560 --> 00:38:39,599
and that's pretty much it so try giving

1016
00:38:39,599 --> 00:38:40,560
that a shot

1017
00:38:40,560 --> 00:38:42,400
you might change this out with your own

1018
00:38:42,400 --> 00:38:44,560
pallets if you came up with a different

1019
00:38:44,560 --> 00:38:45,520
solution that's

1020
00:38:45,520 --> 00:38:48,560
absolutely fine if this is unclear feel

1021
00:38:48,560 --> 00:38:50,400
free to join us in our office hour and

1022
00:38:50,400 --> 00:38:52,960
we can talk about it

1023
00:38:52,960 --> 00:38:54,640
the circuit playground comes with a

1024
00:38:54,640 --> 00:38:56,240
powerful mems

1025
00:38:56,240 --> 00:38:59,280
accelerometer in the very center

1026
00:38:59,280 --> 00:39:01,839
this is labeled with an x y and z

1027
00:39:01,839 --> 00:39:03,280
because it can measure three

1028
00:39:03,280 --> 00:39:06,720
values x orientation y orientation

1029
00:39:06,720 --> 00:39:10,720
and z orientation accelerometers

1030
00:39:10,720 --> 00:39:12,880
are popular devices that are in your

1031
00:39:12,880 --> 00:39:14,720
smartphone wiimote

1032
00:39:14,720 --> 00:39:17,680
or other devices that sense tilt gravity

1033
00:39:17,680 --> 00:39:20,400
motion and tap effects

1034
00:39:20,400 --> 00:39:22,320
an accelerometer like the one included

1035
00:39:22,320 --> 00:39:24,240
with the playground measures relative

1036
00:39:24,240 --> 00:39:25,839
movement

1037
00:39:25,839 --> 00:39:28,640
ours measures in three directions any

1038
00:39:28,640 --> 00:39:30,640
change in location of the accelerometer

1039
00:39:30,640 --> 00:39:32,079
chip will be registered as

1040
00:39:32,079 --> 00:39:35,040
changes in the values it sends out you

1041
00:39:35,040 --> 00:39:37,119
can use this to detect movement in any

1042
00:39:37,119 --> 00:39:38,240
of the directions

1043
00:39:38,240 --> 00:39:41,200
or you can pull the xyz values and use

1044
00:39:41,200 --> 00:39:42,960
the values to see which directions the

1045
00:39:42,960 --> 00:39:44,560
motion has taken place

1046
00:39:44,560 --> 00:39:47,440
and how much it has moved if a project

1047
00:39:47,440 --> 00:39:49,440
needs to detect movement or measuring

1048
00:39:49,440 --> 00:39:50,079
movement

1049
00:39:50,079 --> 00:39:53,440
an accelerometer is a perfect fit

1050
00:39:53,440 --> 00:39:55,599
our accelerometer also includes support

1051
00:39:55,599 --> 00:39:57,040
for tap detection

1052
00:39:57,040 --> 00:39:59,520
double tap detection orientation

1053
00:39:59,520 --> 00:40:00,400
information

1054
00:40:00,400 --> 00:40:03,040
i.e which side is up which site is down

1055
00:40:03,040 --> 00:40:05,040
and free fall detection

1056
00:40:05,040 --> 00:40:06,720
let's learn how to use it by trying it

1057
00:40:06,720 --> 00:40:08,880
out

1058
00:40:08,880 --> 00:40:11,119
from your course files open hello

1059
00:40:11,119 --> 00:40:13,359
accelerometer

1060
00:40:13,359 --> 00:40:15,920
open the file hello accelerometer and

1061
00:40:15,920 --> 00:40:18,079
check out the built-in 3-axis motion

1062
00:40:18,079 --> 00:40:22,000
sensor on the circuit playground express

1063
00:40:22,000 --> 00:40:24,160
as you can see reading motion data from

1064
00:40:24,160 --> 00:40:26,240
all three axes is very easy

1065
00:40:26,240 --> 00:40:30,000
it's just three different function calls

1066
00:40:33,280 --> 00:40:38,960
and then we're just printing the values

1067
00:40:38,960 --> 00:40:40,960
note that motion detection is always

1068
00:40:40,960 --> 00:40:42,640
relative to the position

1069
00:40:42,640 --> 00:40:45,040
in which the circuit playground starts

1070
00:40:45,040 --> 00:40:47,040
you can't get objective position data

1071
00:40:47,040 --> 00:40:48,319
from an accelerometer

1072
00:40:48,319 --> 00:40:50,000
since it's more about motion than

1073
00:40:50,000 --> 00:40:51,760
location

1074
00:40:51,760 --> 00:40:54,079
the three axes work like this put the

1075
00:40:54,079 --> 00:40:56,160
board on a table with the usb cable

1076
00:40:56,160 --> 00:40:58,480
facing away from you

1077
00:40:58,480 --> 00:41:02,560
then upload the code and look at serial

1078
00:41:04,839 --> 00:41:07,839
monitor

1079
00:41:09,680 --> 00:41:12,400
the x-axis is aligned horizontally from

1080
00:41:12,400 --> 00:41:14,400
left to right

1081
00:41:14,400 --> 00:41:16,720
in a neutral position x should always be

1082
00:41:16,720 --> 00:41:18,560
around zero

1083
00:41:18,560 --> 00:41:21,839
if you tilt the board to the left

1084
00:41:22,160 --> 00:41:25,040
you'll see that x is positive if you

1085
00:41:25,040 --> 00:41:27,599
tilt it to the right

1086
00:41:27,599 --> 00:41:31,200
you'll see that x is negative

1087
00:41:32,160 --> 00:41:34,560
the y axis is aligned vertically from

1088
00:41:34,560 --> 00:41:36,480
bottom to top

1089
00:41:36,480 --> 00:41:39,200
in a neutral position y should always be

1090
00:41:39,200 --> 00:41:39,680
around

1091
00:41:39,680 --> 00:41:43,040
zero if you tilt the board forward

1092
00:41:43,040 --> 00:41:45,759
up towards you

1093
00:41:47,040 --> 00:41:49,839
y is positive

1094
00:41:50,240 --> 00:41:53,839
if you tilt the board away from you

1095
00:41:54,400 --> 00:41:57,280
y is negative

1096
00:41:59,760 --> 00:42:02,960
the z axis is perpendicular to the board

1097
00:42:02,960 --> 00:42:06,720
and pointing down when the board is at

1098
00:42:06,720 --> 00:42:07,280
rest

1099
00:42:07,280 --> 00:42:10,319
z is aligned with earth's gravity it

1100
00:42:10,319 --> 00:42:11,440
should read around

1101
00:42:11,440 --> 00:42:16,319
9.8 meters per second each second

1102
00:42:16,319 --> 00:42:18,560
feel free to move the circuit playground

1103
00:42:18,560 --> 00:42:31,839
around and see the values change

1104
00:42:39,040 --> 00:42:41,839
open up the sketch hello accelerometer

1105
00:42:41,839 --> 00:42:43,680
lighting

1106
00:42:43,680 --> 00:42:45,680
in the sketch hello accelerometer

1107
00:42:45,680 --> 00:42:47,920
lighting we'll connect some lighting to

1108
00:42:47,920 --> 00:42:50,400
the three axes of motion

1109
00:42:50,400 --> 00:42:52,640
let's start with something simple once

1110
00:42:52,640 --> 00:42:54,319
you've got this down you can try

1111
00:42:54,319 --> 00:42:56,000
experimenting with the animation

1112
00:42:56,000 --> 00:42:57,440
parameters on your own

1113
00:42:57,440 --> 00:43:00,560
to create your own motion-based art in

1114
00:43:00,560 --> 00:43:02,400
the sketch we're recording the data for

1115
00:43:02,400 --> 00:43:02,720
x

1116
00:43:02,720 --> 00:43:05,760
y and z but then we're mapping it

1117
00:43:05,760 --> 00:43:08,480
to red green and blue you can see that

1118
00:43:08,480 --> 00:43:10,640
we're using our map function here as we

1119
00:43:10,640 --> 00:43:12,640
described in the last section

1120
00:43:12,640 --> 00:43:15,280
to convert the max and min values we're

1121
00:43:15,280 --> 00:43:16,960
seeing from the accelerometer

1122
00:43:16,960 --> 00:43:19,119
to the range we expect for red green and

1123
00:43:19,119 --> 00:43:20,560
blue which is between

1124
00:43:20,560 --> 00:43:23,680
0 and 255

1125
00:43:23,680 --> 00:43:25,440
it's kind of hard to show this effect in

1126
00:43:25,440 --> 00:43:41,839
a video but have a look here

1127
00:43:45,440 --> 00:43:47,520
this is pretty cool but can you make it

1128
00:43:47,520 --> 00:43:49,040
even cooler

1129
00:43:49,040 --> 00:43:51,839
try using x y and z to drive some of the

1130
00:43:51,839 --> 00:43:53,520
variables and more complicated

1131
00:43:53,520 --> 00:43:54,640
animations

1132
00:43:54,640 --> 00:43:56,400
like the ones we finished in the last

1133
00:43:56,400 --> 00:43:58,400
class or the ones that are in the fast

1134
00:43:58,400 --> 00:44:00,160
led examples folder

1135
00:44:00,160 --> 00:44:03,359
and see what you can come up with open

1136
00:44:03,359 --> 00:44:04,160
up the file

1137
00:44:04,160 --> 00:44:07,440
excel tab in this sketch we'll look at

1138
00:44:07,440 --> 00:44:09,280
the accelerometer's built-in tap

1139
00:44:09,280 --> 00:44:12,400
and double tap detection tap and double

1140
00:44:12,400 --> 00:44:13,359
tap detection

1141
00:44:13,359 --> 00:44:15,359
work best via interrupts which are a

1142
00:44:15,359 --> 00:44:17,760
built-in mechanism arduino provides

1143
00:44:17,760 --> 00:44:19,280
to allow you to interrupt normal

1144
00:44:19,280 --> 00:44:22,160
execution upon detection of an event

1145
00:44:22,160 --> 00:44:23,599
these are a little beyond the scope of

1146
00:44:23,599 --> 00:44:25,520
this class but luckily most sensors

1147
00:44:25,520 --> 00:44:26,560
which use them

1148
00:44:26,560 --> 00:44:28,800
come with an example so you can get

1149
00:44:28,800 --> 00:44:30,480
started without knowing too much about

1150
00:44:30,480 --> 00:44:33,440
how interrupts work

1151
00:44:33,440 --> 00:44:35,040
let's take a look at how this sketch

1152
00:44:35,040 --> 00:44:36,720
works

1153
00:44:36,720 --> 00:44:38,400
upload it as is and have a look at

1154
00:44:38,400 --> 00:44:41,200
serial monitor

1155
00:44:48,240 --> 00:44:51,839
so how is this sketch working

1156
00:44:52,240 --> 00:44:56,240
the magic is all right here on this line

1157
00:44:56,240 --> 00:44:57,680
there are different arguments you can

1158
00:44:57,680 --> 00:45:00,800
give to circuitplayground.excel tab

1159
00:45:00,800 --> 00:45:03,040
in order to detect different things

1160
00:45:03,040 --> 00:45:05,440
you'll use one for single tap detection

1161
00:45:05,440 --> 00:45:07,839
as shown and two for double tap

1162
00:45:07,839 --> 00:45:09,200
detection

1163
00:45:09,200 --> 00:45:12,400
zero turns tap detection off

1164
00:45:12,400 --> 00:45:14,720
let's give this a try and try changing

1165
00:45:14,720 --> 00:45:16,240
one to two

1166
00:45:16,240 --> 00:45:19,359
then try uploading the sketch

1167
00:45:19,359 --> 00:45:21,200
now see if you can get it to detect a

1168
00:45:21,200 --> 00:45:23,040
double tap

1169
00:45:23,040 --> 00:45:24,960
you'll see it print tapped to the serial

1170
00:45:24,960 --> 00:45:26,480
monitor when you tap twice

1171
00:45:26,480 --> 00:45:28,000
and you should notice that it mostly

1172
00:45:28,000 --> 00:45:30,480
doesn't respond to a single tap anymore

1173
00:45:30,480 --> 00:45:34,079
pretty cool you might be wondering what

1174
00:45:34,079 --> 00:45:36,560
this line is doing

1175
00:45:36,560 --> 00:45:39,599
the first argument takes a digital pin c

1176
00:45:39,599 --> 00:45:43,359
play lis 3dh interrupt which is a

1177
00:45:43,359 --> 00:45:45,280
defined value that circuit playground

1178
00:45:45,280 --> 00:45:47,200
sets up for you in the library

1179
00:45:47,200 --> 00:45:49,040
and converts it from an ordinary digital

1180
00:45:49,040 --> 00:45:50,640
pin to an interrupt

1181
00:45:50,640 --> 00:45:52,560
this is the pin arduino will be watching

1182
00:45:52,560 --> 00:45:55,680
to trigger the interrupt

1183
00:45:58,800 --> 00:46:02,880
next comes a function tab time

1184
00:46:03,599 --> 00:46:06,400
to be run when the interrupt goes off

1185
00:46:06,400 --> 00:46:08,160
note that you can put literally anything

1186
00:46:08,160 --> 00:46:09,839
inside your interrupt function

1187
00:46:09,839 --> 00:46:11,440
but keep in mind that interrupts will

1188
00:46:11,440 --> 00:46:13,520
block ie interrupt

1189
00:46:13,520 --> 00:46:16,000
normal execution so normally what you

1190
00:46:16,000 --> 00:46:17,920
want to do is something quick

1191
00:46:17,920 --> 00:46:19,760
you can just change a global variable

1192
00:46:19,760 --> 00:46:21,839
defined as a volatile variable so the

1193
00:46:21,839 --> 00:46:23,440
arduino knows that it might change

1194
00:46:23,440 --> 00:46:24,960
outside the control block in which it

1195
00:46:24,960 --> 00:46:25,839
appears

1196
00:46:25,839 --> 00:46:27,680
for instance so that your main loop

1197
00:46:27,680 --> 00:46:29,760
knows you've detected a tap

1198
00:46:29,760 --> 00:46:32,319
we'll walk through this in a second the

1199
00:46:32,319 --> 00:46:33,440
third argument

1200
00:46:33,440 --> 00:46:36,800
you see is falling

1201
00:46:37,359 --> 00:46:40,640
the three options here are falling

1202
00:46:40,640 --> 00:46:42,640
interrupt when the pin goes from high to

1203
00:46:42,640 --> 00:46:44,160
low

1204
00:46:44,160 --> 00:46:47,680
or rising low to high

1205
00:46:47,680 --> 00:46:51,680
or change interrupt on both changes

1206
00:46:51,680 --> 00:46:53,920
in this case falling and rising are

1207
00:46:53,920 --> 00:46:55,520
basically interchangeable

1208
00:46:55,520 --> 00:46:58,079
since we only care about a tap but there

1209
00:46:58,079 --> 00:46:59,040
are times

1210
00:46:59,040 --> 00:47:01,760
i.e when reading a momentary button when

1211
00:47:01,760 --> 00:47:03,920
this really matters

1212
00:47:03,920 --> 00:47:06,079
as a bonus what do you think will happen

1213
00:47:06,079 --> 00:47:08,880
if you set it to change

1214
00:47:08,880 --> 00:47:11,200
if you said it'll detect two taps every

1215
00:47:11,200 --> 00:47:12,480
time you tap it

1216
00:47:12,480 --> 00:47:14,720
you're right give it a try and see what

1217
00:47:14,720 --> 00:47:15,520
you get

1218
00:47:15,520 --> 00:47:17,280
be sure to change it back to falling

1219
00:47:17,280 --> 00:47:19,839
afterwards for more information about

1220
00:47:19,839 --> 00:47:22,839
interrupts you can see the arduino

1221
00:47:22,839 --> 00:47:25,040
reference open up the file

1222
00:47:25,040 --> 00:47:28,640
excel tap lighting

1223
00:47:28,720 --> 00:47:31,200
in excel tap lighting we'll make our

1224
00:47:31,200 --> 00:47:34,000
lights respond to a double tap

1225
00:47:34,000 --> 00:47:36,160
first we'll add our usual fast led

1226
00:47:36,160 --> 00:47:38,800
boiler plate to the top of the file

1227
00:47:38,800 --> 00:47:41,440
in our usual fast led setup code to set

1228
00:47:41,440 --> 00:47:43,520
up

1229
00:47:49,599 --> 00:47:51,599
i recommend you just cut and paste it

1230
00:47:51,599 --> 00:47:54,319
from the custom algorithm helloworld.eno

1231
00:47:54,319 --> 00:47:54,800
file

1232
00:47:54,800 --> 00:47:57,200
if you're making it from scratch let's

1233
00:47:57,200 --> 00:47:59,599
also make sure our leds are set to black

1234
00:47:59,599 --> 00:48:02,559
to start then we'll do a fast led show

1235
00:48:02,559 --> 00:48:03,040
call

1236
00:48:03,040 --> 00:48:05,119
then we'll want to create a volatile

1237
00:48:05,119 --> 00:48:07,119
variable to run our tap detection

1238
00:48:07,119 --> 00:48:10,880
for us and let's add a second timer so

1239
00:48:10,880 --> 00:48:12,559
we can decide how long we want the

1240
00:48:12,559 --> 00:48:14,559
lights to show after someone taps the

1241
00:48:14,559 --> 00:48:17,280
circuit playground

1242
00:48:17,280 --> 00:48:19,440
let's make this one volatile so we can

1243
00:48:19,440 --> 00:48:21,839
use it inside the interrupt

1244
00:48:21,839 --> 00:48:23,599
cool now we're ready to change our

1245
00:48:23,599 --> 00:48:24,880
lights

1246
00:48:24,880 --> 00:48:26,640
add the following to the tap time

1247
00:48:26,640 --> 00:48:30,079
function by changing tapped to 1

1248
00:48:30,079 --> 00:48:32,160
we'll be signaling the main execution

1249
00:48:32,160 --> 00:48:33,520
thread

1250
00:48:33,520 --> 00:48:36,559
interrupts are technically threads to

1251
00:48:36,559 --> 00:48:39,280
let it know that the interrupt went off

1252
00:48:39,280 --> 00:48:42,160
then it'll do our work for us likewise

1253
00:48:42,160 --> 00:48:44,000
we're capturing the time in our tap

1254
00:48:44,000 --> 00:48:45,599
millies variable

1255
00:48:45,599 --> 00:48:47,599
so that we can start a timer based on

1256
00:48:47,599 --> 00:48:50,559
when we were inside the interrupt

1257
00:48:50,559 --> 00:48:52,640
as above you always want to use this

1258
00:48:52,640 --> 00:48:55,119
method because delay and millies

1259
00:48:55,119 --> 00:48:58,319
do not work inside interrupt functions

1260
00:48:58,319 --> 00:48:59,920
you might notice that you can call

1261
00:48:59,920 --> 00:49:01,680
millies over and over inside an

1262
00:49:01,680 --> 00:49:04,319
interrupt and it will never update it's

1263
00:49:04,319 --> 00:49:06,160
always frozen at the moment arduino

1264
00:49:06,160 --> 00:49:08,880
entered the interrupt

1265
00:49:08,880 --> 00:49:10,800
that makes it pretty hard to do almost

1266
00:49:10,800 --> 00:49:14,240
anything with lighting inside interrupts

1267
00:49:14,240 --> 00:49:16,400
anyway let's cut and paste the smartest

1268
00:49:16,400 --> 00:49:17,280
chase function

1269
00:49:17,280 --> 00:49:21,280
from the custom algorithm hello world

1270
00:49:23,680 --> 00:49:25,440
and then we'll add the following to our

1271
00:49:25,440 --> 00:49:27,599
loop and light some lights

1272
00:49:27,599 --> 00:49:29,280
you might notice that the logic we're

1273
00:49:29,280 --> 00:49:31,040
using for our millis timer

1274
00:49:31,040 --> 00:49:32,880
is essentially backwards from what we've

1275
00:49:32,880 --> 00:49:35,040
been doing with the lights

1276
00:49:35,040 --> 00:49:37,040
this is because a lighting timer runs

1277
00:49:37,040 --> 00:49:38,400
eternally

1278
00:49:38,400 --> 00:49:40,400
we know we always want it to run at the

1279
00:49:40,400 --> 00:49:41,920
current value of millies

1280
00:49:41,920 --> 00:49:45,520
plus time but in this case we only want

1281
00:49:45,520 --> 00:49:47,440
our timer to go off once

1282
00:49:47,440 --> 00:49:49,680
and only if the current time is our

1283
00:49:49,680 --> 00:49:50,880
interrupt time

1284
00:49:50,880 --> 00:49:53,680
plus time so that's why the logic is

1285
00:49:53,680 --> 00:49:55,040
backwards

1286
00:49:55,040 --> 00:49:56,880
and you'll notice that we don't set tap

1287
00:49:56,880 --> 00:49:59,760
melees at the end of our loop this time

1288
00:49:59,760 --> 00:50:01,680
instead only the interrupt changes it

1289
00:50:01,680 --> 00:50:03,920
this is a good general way to do timing

1290
00:50:03,920 --> 00:50:05,440
based on an event

1291
00:50:05,440 --> 00:50:07,599
in this case our interrupt but you can

1292
00:50:07,599 --> 00:50:08,800
use it when values

1293
00:50:08,800 --> 00:50:11,200
exceed a given threshold when buttons

1294
00:50:11,200 --> 00:50:12,000
are pressed and

1295
00:50:12,000 --> 00:50:15,839
more it's a super useful construct

1296
00:50:15,839 --> 00:50:17,599
let's try uploading the file and see

1297
00:50:17,599 --> 00:50:27,839
what happens

1298
00:50:31,040 --> 00:50:32,640
this is most often how you'll want to

1299
00:50:32,640 --> 00:50:34,240
use the accelerometer

1300
00:50:34,240 --> 00:50:35,920
examples of cool projects you can make

1301
00:50:35,920 --> 00:50:38,079
with this include using it as a mouse

1302
00:50:38,079 --> 00:50:39,359
there's an example for this in the

1303
00:50:39,359 --> 00:50:42,000
arduino ide under circuit playground

1304
00:50:42,000 --> 00:50:44,160
making a motion-driven sound experience

1305
00:50:44,160 --> 00:50:46,319
or activating dance and other movement

1306
00:50:46,319 --> 00:50:49,440
arts with light and sound

1307
00:50:49,440 --> 00:50:51,839
fall detection is left as an exercise

1308
00:50:51,839 --> 00:50:52,880
for you

1309
00:50:52,880 --> 00:50:54,319
mainly because there's still another

1310
00:50:54,319 --> 00:50:55,760
class so i'm not going to tell you to

1311
00:50:55,760 --> 00:50:57,520
drop your microcontroller

1312
00:50:57,520 --> 00:50:59,599
however freefall detection also works

1313
00:50:59,599 --> 00:51:00,559
via interrupts

1314
00:51:00,559 --> 00:51:02,559
and adafruit has an extensive example on

1315
00:51:02,559 --> 00:51:04,319
how to use it here

1316
00:51:04,319 --> 00:51:05,839
there's a lot of code in there but

1317
00:51:05,839 --> 00:51:07,599
everything you need is in setup

1318
00:51:07,599 --> 00:51:11,119
interrupt handler and loop

1319
00:51:11,839 --> 00:51:13,359
by now you might be getting used to

1320
00:51:13,359 --> 00:51:14,960
finding the part you need and cutting

1321
00:51:14,960 --> 00:51:17,359
and pasting into a fast led sketch

1322
00:51:17,359 --> 00:51:19,119
so check it out and experiment with it

1323
00:51:19,119 --> 00:51:20,640
in your own time

1324
00:51:20,640 --> 00:51:22,400
try changing animation colors and

1325
00:51:22,400 --> 00:51:25,440
palettes changing animation parameters

1326
00:51:25,440 --> 00:51:27,760
and changing entire animations modes

1327
00:51:27,760 --> 00:51:29,680
based on input

1328
00:51:29,680 --> 00:51:31,520
once you've exhausted the possibilities

1329
00:51:31,520 --> 00:51:33,359
of the onboard sensors of the circuit

1330
00:51:33,359 --> 00:51:34,559
playground express

1331
00:51:34,559 --> 00:51:36,720
the fun is just beginning you can

1332
00:51:36,720 --> 00:51:38,800
control any number of input output

1333
00:51:38,800 --> 00:51:39,680
devices

1334
00:51:39,680 --> 00:51:42,079
using the digital and analog pins on the

1335
00:51:42,079 --> 00:51:44,079
circuit playground express

1336
00:51:44,079 --> 00:51:46,480
you can even control sensors which use

1337
00:51:46,480 --> 00:51:48,720
some relatively advanced protocols

1338
00:51:48,720 --> 00:51:51,760
like serial and i2c

1339
00:51:51,760 --> 00:51:53,760
one thing to note when using external

1340
00:51:53,760 --> 00:51:57,040
sensors is the logic level of the sensor

1341
00:51:57,040 --> 00:52:00,079
3.3 volts and 5 volts are two very

1342
00:52:00,079 --> 00:52:01,760
common control voltages

1343
00:52:01,760 --> 00:52:04,480
that sensors are built to run on the

1344
00:52:04,480 --> 00:52:05,280
gpio

1345
00:52:05,280 --> 00:52:07,599
pins on the circuit playground express

1346
00:52:07,599 --> 00:52:09,680
run on 3.3 volts

1347
00:52:09,680 --> 00:52:12,720
like most teensies while the gpio pins

1348
00:52:12,720 --> 00:52:14,319
on an arduino uno

1349
00:52:14,319 --> 00:52:17,359
or omega run on 5 volts

1350
00:52:17,359 --> 00:52:19,760
while most output devices built for 5

1351
00:52:19,760 --> 00:52:20,640
volts will work

1352
00:52:20,640 --> 00:52:23,680
okay at a 3.3 volt logic level

1353
00:52:23,680 --> 00:52:26,880
like our neopixels some input sensors

1354
00:52:26,880 --> 00:52:29,200
are built for a 5 volt logic level

1355
00:52:29,200 --> 00:52:32,400
and won't work at 3.3 volts

1356
00:52:32,400 --> 00:52:35,119
if you run into this problem an easy way

1357
00:52:35,119 --> 00:52:35,920
to address it

1358
00:52:35,920 --> 00:52:39,280
is to add a logic level shifter

1359
00:52:39,280 --> 00:52:41,839
this is about 3 bucks and is a board

1360
00:52:41,839 --> 00:52:43,839
that converts 3.3 volts

1361
00:52:43,839 --> 00:52:47,359
logic to 5 volts logic or vice versa

1362
00:52:47,359 --> 00:52:51,359
i like to use this one from sparkfun

1363
00:52:52,640 --> 00:52:54,800
at this point you might be asking where

1364
00:52:54,800 --> 00:52:58,079
do i find sensors and how do i use them

1365
00:52:58,079 --> 00:53:00,559
i always recommend starting at adafruit

1366
00:53:00,559 --> 00:53:01,920
and sparkfun

1367
00:53:01,920 --> 00:53:03,920
both sites are aimed at makers and

1368
00:53:03,920 --> 00:53:06,400
artists so they sell tons of sensors

1369
00:53:06,400 --> 00:53:09,040
which work with the arduino ide and come

1370
00:53:09,040 --> 00:53:11,440
with libraries or example code that you

1371
00:53:11,440 --> 00:53:13,599
can download and use

1372
00:53:13,599 --> 00:53:15,920
they also provide plenty of step-by-step

1373
00:53:15,920 --> 00:53:16,960
tutorials

1374
00:53:16,960 --> 00:53:18,960
for many of their sensors and output

1375
00:53:18,960 --> 00:53:20,640
devices

1376
00:53:20,640 --> 00:53:22,079
here you'll find everything from

1377
00:53:22,079 --> 00:53:23,839
distance and movement sensors

1378
00:53:23,839 --> 00:53:26,480
to tiny cameras and lcd screens that you

1379
00:53:26,480 --> 00:53:29,839
can drive with your circuit playground

1380
00:53:32,480 --> 00:53:34,880
i've also found a ton of useful stuff

1381
00:53:34,880 --> 00:53:36,960
especially servos and other motors

1382
00:53:36,960 --> 00:53:39,280
lighter scanners and rangefinders and

1383
00:53:39,280 --> 00:53:40,880
other things one might want to put in a

1384
00:53:40,880 --> 00:53:45,040
mobile robot on df robot

1385
00:53:45,040 --> 00:53:47,599
digikey and mouser are more advanced

1386
00:53:47,599 --> 00:53:49,119
sources for sensors

1387
00:53:49,119 --> 00:53:51,119
mostly because it can be hard to search

1388
00:53:51,119 --> 00:53:52,880
through tens of thousands of items they

1389
00:53:52,880 --> 00:53:54,000
have in stock

1390
00:53:54,000 --> 00:53:55,920
but braving the onslaught can be worth

1391
00:53:55,920 --> 00:53:57,599
it in particular

1392
00:53:57,599 --> 00:53:59,440
they can be a great place to pick up a

1393
00:53:59,440 --> 00:54:01,680
sensor or device if it's out of stock at

1394
00:54:01,680 --> 00:54:03,599
adafruit or sparkfun

1395
00:54:03,599 --> 00:54:06,720
digikey carries a lot of brands

1396
00:54:06,720 --> 00:54:08,720
both are also great places to pick up

1397
00:54:08,720 --> 00:54:10,559
general electronic supplies like

1398
00:54:10,559 --> 00:54:13,680
wire protoboards hand tools soldering

1399
00:54:13,680 --> 00:54:14,319
supplies

1400
00:54:14,319 --> 00:54:17,599
thermal tape and more

1401
00:54:18,640 --> 00:54:20,240
okay so now you know where to find

1402
00:54:20,240 --> 00:54:22,240
sensors but you might not know what

1403
00:54:22,240 --> 00:54:23,599
you'd like to get

1404
00:54:23,599 --> 00:54:25,440
so here's a quick overview of some

1405
00:54:25,440 --> 00:54:26,800
sensors i have known

1406
00:54:26,800 --> 00:54:29,800
and loved first of all is the

1407
00:54:29,800 --> 00:54:32,400
potentiometer

1408
00:54:32,400 --> 00:54:34,880
a rotary potentiometer is essentially a

1409
00:54:34,880 --> 00:54:35,440
knob

1410
00:54:35,440 --> 00:54:37,440
or at least the inside of a knob the

1411
00:54:37,440 --> 00:54:39,520
ones that you buy for use as sensors

1412
00:54:39,520 --> 00:54:41,200
typically let you add your own

1413
00:54:41,200 --> 00:54:44,079
knob cap to them there are hundreds and

1414
00:54:44,079 --> 00:54:45,599
hundreds of different kinds

1415
00:54:45,599 --> 00:54:47,839
but each lets you measure voltage across

1416
00:54:47,839 --> 00:54:49,119
an analog pin

1417
00:54:49,119 --> 00:54:51,839
which then changes as you turn the knob

1418
00:54:51,839 --> 00:54:53,680
this can be great for controlling things

1419
00:54:53,680 --> 00:54:54,559
like volume

1420
00:54:54,559 --> 00:54:56,400
or the intensity of your algorithm's

1421
00:54:56,400 --> 00:54:57,680
parameters

1422
00:54:57,680 --> 00:55:00,400
if you get a contactless potentiometer

1423
00:55:00,400 --> 00:55:02,000
you'll spend way more money

1424
00:55:02,000 --> 00:55:04,079
but people who use it will be unable to

1425
00:55:04,079 --> 00:55:05,119
turn it too far

1426
00:55:05,119 --> 00:55:07,440
and rip the wires out this can be great

1427
00:55:07,440 --> 00:55:10,400
for permanent installations

1428
00:55:10,400 --> 00:55:12,079
i like arcade buttons for their

1429
00:55:12,079 --> 00:55:14,079
familiarity longevity

1430
00:55:14,079 --> 00:55:16,640
and ease of installation and wiring

1431
00:55:16,640 --> 00:55:18,480
adafruit has some that even come with

1432
00:55:18,480 --> 00:55:20,880
controllable leds

1433
00:55:20,880 --> 00:55:23,520
buttons are incredibly easy to read the

1434
00:55:23,520 --> 00:55:24,640
pin connected to them

1435
00:55:24,640 --> 00:55:27,119
is either digital high or digital low

1436
00:55:27,119 --> 00:55:28,559
depending on whether the button is

1437
00:55:28,559 --> 00:55:29,599
pressed

1438
00:55:29,599 --> 00:55:31,440
you can experiment with this using the

1439
00:55:31,440 --> 00:55:32,799
onboard buttons of the circuit

1440
00:55:32,799 --> 00:55:33,599
playground

1441
00:55:33,599 --> 00:55:35,359
but if you want a fancier button

1442
00:55:35,359 --> 00:55:38,400
consider going off board

1443
00:55:38,400 --> 00:55:41,839
a hall effect sensor detects magnetism

1444
00:55:41,839 --> 00:55:44,160
along with a small rare earth magnet

1445
00:55:44,160 --> 00:55:46,640
glued to the object you wish to detect

1446
00:55:46,640 --> 00:55:48,960
it's an astonishingly affordable way to

1447
00:55:48,960 --> 00:55:50,559
detect whether things are in their

1448
00:55:50,559 --> 00:55:52,079
resting position

1449
00:55:52,079 --> 00:55:55,119
or have been moved for instance it's one

1450
00:55:55,119 --> 00:55:57,359
of my go-to sensors when i need to check

1451
00:55:57,359 --> 00:55:59,200
whether a cabinet or drawer has been

1452
00:55:59,200 --> 00:56:00,480
opened or closed

1453
00:56:00,480 --> 00:56:16,079
or whether a not available

1454
00:56:16,079 --> 00:56:18,720
sensors detect distance and thus can

1455
00:56:18,720 --> 00:56:20,160
also work as motion

1456
00:56:20,160 --> 00:56:23,200
or person detectors i've found that they

1457
00:56:23,200 --> 00:56:25,040
often work better than the small

1458
00:56:25,040 --> 00:56:27,920
pir sensors you see in a lot of arduino

1459
00:56:27,920 --> 00:56:28,960
motion detection

1460
00:56:28,960 --> 00:56:32,160
applications this one is cool

1461
00:56:32,160 --> 00:56:34,559
due to the long length of its cord

1462
00:56:34,559 --> 00:56:35,440
almost eight

1463
00:56:35,440 --> 00:56:38,079
feet combined with a waterproof sensor

1464
00:56:38,079 --> 00:56:38,559
probe

1465
00:56:38,559 --> 00:56:42,000
you can hide anywhere check out df robot

1466
00:56:42,000 --> 00:56:43,520
for this product

1467
00:56:43,520 --> 00:56:45,359
so far we've only been using one

1468
00:56:45,359 --> 00:56:47,520
communication protocol to control our

1469
00:56:47,520 --> 00:56:50,079
sensors

1470
00:56:50,079 --> 00:56:53,119
going beyond simple one-pin sensors i2c

1471
00:56:53,119 --> 00:56:54,880
is a two-wire protocol

1472
00:56:54,880 --> 00:56:56,720
for communicating with simple sensors

1473
00:56:56,720 --> 00:56:58,319
and devices

1474
00:56:58,319 --> 00:57:01,680
you need two pins to control i2c usually

1475
00:57:01,680 --> 00:57:02,640
referred to as

1476
00:57:02,640 --> 00:57:06,720
scl and sda if you look closely at the

1477
00:57:06,720 --> 00:57:07,839
pinout map

1478
00:57:07,839 --> 00:57:09,839
you'll see that scl on the circuit

1479
00:57:09,839 --> 00:57:10,880
playground express

1480
00:57:10,880 --> 00:57:14,480
is pin a4 slash 48

1481
00:57:14,480 --> 00:57:19,040
and sda is pin a5 47

1482
00:57:19,040 --> 00:57:21,200
knowing this you can control just about

1483
00:57:21,200 --> 00:57:24,720
any sensor or device that speaks i2c

1484
00:57:24,720 --> 00:57:26,400
if you're wondering if your sensor

1485
00:57:26,400 --> 00:57:27,920
speaks i2c

1486
00:57:27,920 --> 00:57:31,760
it should say it on its spec sheet

1487
00:57:31,839 --> 00:57:34,319
you can learn more about i2c here

1488
00:57:34,319 --> 00:57:40,400
including some code examples one of my

1489
00:57:40,400 --> 00:57:42,319
favorite i2c devices

1490
00:57:42,319 --> 00:57:46,400
is the vl53l0x time-of-flight

1491
00:57:46,400 --> 00:57:49,680
distance sensor this sensor measures

1492
00:57:49,680 --> 00:57:51,760
distances between the sensor and

1493
00:57:51,760 --> 00:57:54,559
any object or person within 30

1494
00:57:54,559 --> 00:57:56,799
millimeters and a thousand millimeters

1495
00:57:56,799 --> 00:58:00,079
or about three feet it's perfect for

1496
00:58:00,079 --> 00:58:01,119
person detection

1497
00:58:01,119 --> 00:58:03,680
directly in front of an object like for

1498
00:58:03,680 --> 00:58:04,240
instance

1499
00:58:04,240 --> 00:58:06,559
triggering a video or interactivity when

1500
00:58:06,559 --> 00:58:08,640
someone approaches your artwork

1501
00:58:08,640 --> 00:58:10,319
and it can also be used to measure

1502
00:58:10,319 --> 00:58:12,400
distance if you need to measure how far

1503
00:58:12,400 --> 00:58:13,200
away things

1504
00:58:13,200 --> 00:58:16,319
are in a linear fashion

1505
00:58:16,319 --> 00:58:18,880
however its field of detection is very

1506
00:58:18,880 --> 00:58:19,520
narrow

1507
00:58:19,520 --> 00:58:21,839
so it only measures things directly in

1508
00:58:21,839 --> 00:58:22,799
front of it

1509
00:58:22,799 --> 00:58:24,799
if you need to monitor a small area

1510
00:58:24,799 --> 00:58:25,920
rather than a narrow

1511
00:58:25,920 --> 00:58:28,480
single location the ultrasonic sensors

1512
00:58:28,480 --> 00:58:31,599
might be a better choice

1513
00:58:31,760 --> 00:58:33,839
what's your favorite sensor let us know

1514
00:58:33,839 --> 00:58:36,319
in the discord or in our office hours

1515
00:58:36,319 --> 00:58:38,400
we've covered a lot of ground today

1516
00:58:38,400 --> 00:58:40,000
we've learned how to use nearly all of

1517
00:58:40,000 --> 00:58:41,520
the onboard sensors of the circuit

1518
00:58:41,520 --> 00:58:42,880
playground express

1519
00:58:42,880 --> 00:58:44,559
we've explored the light sensor the

1520
00:58:44,559 --> 00:58:46,720
temperature sensor capacitive touch

1521
00:58:46,720 --> 00:58:49,200
the sound sensor or microphone and the

1522
00:58:49,200 --> 00:58:50,880
accelerometer

1523
00:58:50,880 --> 00:58:52,559
we've also learned how to use data from

1524
00:58:52,559 --> 00:58:54,000
these sensors to make interactive

1525
00:58:54,000 --> 00:58:56,079
programs like a color changing lamp that

1526
00:58:56,079 --> 00:58:57,760
responds to light values

1527
00:58:57,760 --> 00:59:00,160
or lighting that responds to orientation

1528
00:59:00,160 --> 00:59:01,119
movement

1529
00:59:01,119 --> 00:59:04,000
sounds temperature and tapping we've

1530
00:59:04,000 --> 00:59:05,680
even discussed the possibilities for

1531
00:59:05,680 --> 00:59:07,040
off-board sensors

1532
00:59:07,040 --> 00:59:08,480
although there's a lot more that could

1533
00:59:08,480 --> 00:59:10,240
be explored there

1534
00:59:10,240 --> 00:59:11,760
if you're wondering which projects you

1535
00:59:11,760 --> 00:59:13,359
can use these sensors in

1536
00:59:13,359 --> 00:59:14,799
i recommend having a look at the

1537
00:59:14,799 --> 00:59:17,280
tutorials and projects on hackaday

1538
00:59:17,280 --> 00:59:20,480
hackster arduino forums instructables

1539
00:59:20,480 --> 00:59:23,760
adafruit sparkfun and more interactivity

1540
00:59:23,760 --> 00:59:25,440
can really bring a project to life by

1541
00:59:25,440 --> 00:59:27,359
adding sound lighting and other outputs

1542
00:59:27,359 --> 00:59:29,359
which respond to human input

1543
00:59:29,359 --> 00:59:30,960
for homework see if you can't come up

1544
00:59:30,960 --> 00:59:33,200
with some ideas for interactive artworks

1545
00:59:33,200 --> 00:59:35,599
instruments even room scale experiences

1546
00:59:35,599 --> 00:59:37,760
that use one or more of these sensors

1547
00:59:37,760 --> 00:59:39,760
as inputs to trigger responsive lighting

1548
00:59:39,760 --> 00:59:40,799
or sound

1549
00:59:40,799 --> 00:59:42,640
if you'd like to go one step further try

1550
00:59:42,640 --> 00:59:44,640
writing pseudocode or real code for this

1551
00:59:44,640 --> 00:59:45,440
program

1552
00:59:45,440 --> 00:59:47,440
and prototyping using paper and other

1553
00:59:47,440 --> 00:59:49,119
tools that you have on hand

1554
00:59:49,119 --> 00:59:50,640
in this next class we'll take our

1555
00:59:50,640 --> 00:59:52,240
lighting design and development skills

1556
00:59:52,240 --> 00:59:53,440
to the next level

1557
00:59:53,440 --> 00:59:55,839
by exploring advanced matrix patterns

1558
00:59:55,839 --> 00:59:57,359
we'll also learn more about lighting

1559
00:59:57,359 --> 00:59:59,040
effects and how to create interesting

1560
00:59:59,040 --> 01:00:01,200
interactivity using lighting

1561
01:00:01,200 --> 01:00:08,558
see you next time

