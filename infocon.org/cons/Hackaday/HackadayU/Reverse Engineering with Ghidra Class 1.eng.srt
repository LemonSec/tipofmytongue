1
00:00:05,020 --> 00:00:07,790
hello everybody my name is Matthew alt

2
00:00:07,790 --> 00:00:10,850
and I'm gonna be teaching you the heck

3
00:00:10,850 --> 00:00:12,530
of a new course introduction to software

4
00:00:12,530 --> 00:00:15,650
reverse engineering using deidre so get

5
00:00:15,650 --> 00:00:20,150
this chat out of the way so I am a

6
00:00:20,150 --> 00:00:21,849
reverse engineer with a focus on

7
00:00:21,849 --> 00:00:24,590
embedded systems currently I work for

8
00:00:24,590 --> 00:00:27,079
Caesar Creek software as a security

9
00:00:27,079 --> 00:00:28,849
researcher but I also provide training

10
00:00:28,849 --> 00:00:31,130
and assessments through a company called

11
00:00:31,130 --> 00:00:34,370
Floyd Star security some of you may also

12
00:00:34,370 --> 00:00:36,710
be familiar with some of my work through

13
00:00:36,710 --> 00:00:38,929
that's been presented on hackaday before

14
00:00:38,929 --> 00:00:41,239
under the username Ron bot where I tear

15
00:00:41,239 --> 00:00:43,609
down various embedded platforms and use

16
00:00:43,609 --> 00:00:46,460
those is a mechanism to teach various

17
00:00:46,460 --> 00:00:49,190
Hardware reverse engineering concepts so

18
00:00:49,190 --> 00:00:51,739
without further ado let's jump into what

19
00:00:51,739 --> 00:00:55,820
we're gonna learn today so today we're

20
00:00:55,820 --> 00:00:58,100
gonna talk about what software reverse

21
00:00:58,100 --> 00:01:00,260
engineering is and in order to do that

22
00:01:00,260 --> 00:01:02,140
we need to understand how software is

23
00:01:02,140 --> 00:01:05,059
engineered in the first place so what

24
00:01:05,059 --> 00:01:06,920
we're gonna do is kind of start with an

25
00:01:06,920 --> 00:01:10,600
initial run-through of how you go from

26
00:01:10,600 --> 00:01:12,560
you know C code or some high-level

27
00:01:12,560 --> 00:01:14,299
language to something that actually runs

28
00:01:14,299 --> 00:01:16,220
on your processor and then after that

29
00:01:16,220 --> 00:01:19,130
we're gonna jump into software reverse

30
00:01:19,130 --> 00:01:21,740
engineering 101 so taking a look at how

31
00:01:21,740 --> 00:01:23,540
can we pull information out of these

32
00:01:23,540 --> 00:01:25,759
programs and how can we gleam

33
00:01:25,759 --> 00:01:28,040
information from these compiled programs

34
00:01:28,040 --> 00:01:29,899
and kind of start working backwards and

35
00:01:29,899 --> 00:01:32,719
that's where we're gonna get into deidre

36
00:01:32,719 --> 00:01:34,189
we're gonna talk about you know how to

37
00:01:34,189 --> 00:01:36,020
install it and then how to use it with a

38
00:01:36,020 --> 00:01:37,460
couple of exercises that we'll work

39
00:01:37,460 --> 00:01:40,880
through together and then finally at the

40
00:01:40,880 --> 00:01:43,310
end we'll take some questions and kind

41
00:01:43,310 --> 00:01:44,930
of walk through everything that we we

42
00:01:44,930 --> 00:01:48,859
learned throughout today so you know the

43
00:01:48,859 --> 00:01:50,180
big question here what is software

44
00:01:50,180 --> 00:01:53,119
reverse engineering right this is the

45
00:01:53,119 --> 00:01:55,280
process of analyzing some software

46
00:01:55,280 --> 00:01:57,320
system for which you don't have the

47
00:01:57,320 --> 00:01:59,390
source code for so maybe that's a

48
00:01:59,390 --> 00:02:01,789
firmware blob maybe it's some shared

49
00:02:01,789 --> 00:02:04,420
object or an executable let's say

50
00:02:04,420 --> 00:02:06,979
perhaps you want to figure out how some

51
00:02:06,979 --> 00:02:08,990
proprietary binary blob works that was

52
00:02:08,990 --> 00:02:11,000
distributed with a microcontroller that

53
00:02:11,000 --> 00:02:14,240
you got or maybe some game drops a DLL

54
00:02:14,240 --> 00:02:16,100
to your system when you play online and

55
00:02:16,100 --> 00:02:17,450
you want to know exactly you know what

56
00:02:17,450 --> 00:02:18,270
that

57
00:02:18,270 --> 00:02:21,840
so in order to do that we kind of have

58
00:02:21,840 --> 00:02:24,240
to break down software to its

59
00:02:24,240 --> 00:02:26,760
fundamental like core components so we

60
00:02:26,760 --> 00:02:28,650
have to go down to the lowest layer of

61
00:02:28,650 --> 00:02:30,900
abstraction because that's all we're

62
00:02:30,900 --> 00:02:33,180
that's all we know as a ground truth

63
00:02:33,180 --> 00:02:34,950
when we're reverse engineering something

64
00:02:34,950 --> 00:02:38,670
and what that is is machine code right

65
00:02:38,670 --> 00:02:40,410
so most of us are probably familiar with

66
00:02:40,410 --> 00:02:42,480
the concepts of you know machine code

67
00:02:42,480 --> 00:02:44,670
and assembly language and we're gonna go

68
00:02:44,670 --> 00:02:47,040
over that throughout today just so we

69
00:02:47,040 --> 00:02:48,290
know that everybody's on the same page

70
00:02:48,290 --> 00:02:51,090
but what we wanted to kind of clear up

71
00:02:51,090 --> 00:02:53,070
with this slide is you know software

72
00:02:53,070 --> 00:02:54,480
reverse engineering is kind of the

73
00:02:54,480 --> 00:02:57,959
process of taking a compiled piece of

74
00:02:57,959 --> 00:03:01,170
code and working backwards from that to

75
00:03:01,170 --> 00:03:03,330
figure out maybe what that code does by

76
00:03:03,330 --> 00:03:05,670
starting at the lowest layer of

77
00:03:05,670 --> 00:03:06,990
abstraction the lowest level of

78
00:03:06,990 --> 00:03:11,459
abstraction the machine code and so in

79
00:03:11,459 --> 00:03:13,680
order to understand how to kind of work

80
00:03:13,680 --> 00:03:15,450
backwards from this stuff we need to

81
00:03:15,450 --> 00:03:16,950
know how it's engineered and how it's

82
00:03:16,950 --> 00:03:19,440
built moving forwards and so most of you

83
00:03:19,440 --> 00:03:21,480
that have written code whether it be for

84
00:03:21,480 --> 00:03:24,900
you know a microcontroller or a desktop

85
00:03:24,900 --> 00:03:27,480
operating system etc that code is

86
00:03:27,480 --> 00:03:29,670
written in some high-level language C

87
00:03:29,670 --> 00:03:32,880
C++ Java Script some maybe even a

88
00:03:32,880 --> 00:03:35,160
scripting language like that that code

89
00:03:35,160 --> 00:03:37,650
is eventually compiled and interpreted

90
00:03:37,650 --> 00:03:41,160
into machine code which are sequences of

91
00:03:41,160 --> 00:03:43,860
bytes that the CPU then interprets and

92
00:03:43,860 --> 00:03:47,549
interprets into terms to perform various

93
00:03:47,549 --> 00:03:51,739
abstract arithmetic operations and so

94
00:03:51,739 --> 00:03:54,660
disassembly is the process of taking

95
00:03:54,660 --> 00:03:58,049
those byte sequences and reconstructing

96
00:03:58,049 --> 00:04:00,150
assembly level instructions from there

97
00:04:00,150 --> 00:04:02,580
and if those terms are you know in

98
00:04:02,580 --> 00:04:04,260
familiar to you and you're not super

99
00:04:04,260 --> 00:04:05,400
familiar with what they mean we're gonna

100
00:04:05,400 --> 00:04:08,519
go over that today but the core point

101
00:04:08,519 --> 00:04:11,940
here is that as reverse engineers that

102
00:04:11,940 --> 00:04:15,180
final product that compiled bytecode

103
00:04:15,180 --> 00:04:17,130
that's going to run on the CPU is gonna

104
00:04:17,130 --> 00:04:18,690
be our starting point so that's where

105
00:04:18,690 --> 00:04:19,760
we're gonna start

106
00:04:19,760 --> 00:04:22,890
but again in order to figure out how to

107
00:04:22,890 --> 00:04:24,479
work backwards we need to understand how

108
00:04:24,479 --> 00:04:26,010
we got to that point to begin with so

109
00:04:26,010 --> 00:04:29,550
we're gonna do a brief review of what

110
00:04:29,550 --> 00:04:31,920
happens when you compile code or you run

111
00:04:31,920 --> 00:04:36,120
and quick disclaimer here I am NOT an

112
00:04:36,120 --> 00:04:38,010
expert in compiler theory these are all

113
00:04:38,010 --> 00:04:41,130
this is kind of a high-level overview of

114
00:04:41,130 --> 00:04:43,710
how code goes from a human readable

115
00:04:43,710 --> 00:04:45,180
language that you and I can understand

116
00:04:45,180 --> 00:04:47,640
to a sequence of bytes that run on your

117
00:04:47,640 --> 00:04:49,350
CPU that we're gonna learn how to

118
00:04:49,350 --> 00:04:54,750
understand and so compilation is kind of

119
00:04:54,750 --> 00:04:56,910
a multi-stage process so we're going

120
00:04:56,910 --> 00:04:59,610
like we said from source code to a

121
00:04:59,610 --> 00:05:01,560
sequence of bytes that are gonna run CPU

122
00:05:01,560 --> 00:05:04,620
and that involves four steps

123
00:05:04,620 --> 00:05:07,260
pre-processing compilation which is

124
00:05:07,260 --> 00:05:09,360
slightly confusing because it's under

125
00:05:09,360 --> 00:05:11,520
the umbrella of compiling a program and

126
00:05:11,520 --> 00:05:15,000
then assembly and linking and again the

127
00:05:15,000 --> 00:05:18,390
result is a file that will be run on

128
00:05:18,390 --> 00:05:20,340
your CPU I'm gonna check this chat real

129
00:05:20,340 --> 00:05:21,840
quick to make sure everything's ok all

130
00:05:21,840 --> 00:05:25,740
right looks good and so typically when

131
00:05:25,740 --> 00:05:27,510
you write code if any of you've written

132
00:05:27,510 --> 00:05:29,910
code for you know Arduino or maybe

133
00:05:29,910 --> 00:05:32,160
you've written something using code

134
00:05:32,160 --> 00:05:34,110
blocks a lot of these steps are

135
00:05:34,110 --> 00:05:35,880
performed automatically for you so you

136
00:05:35,880 --> 00:05:39,690
don't really get a deep look into how

137
00:05:39,690 --> 00:05:41,040
this works now some of you that work in

138
00:05:41,040 --> 00:05:42,300
the embedded space you're gonna be

139
00:05:42,300 --> 00:05:43,560
familiar with this because you kind of

140
00:05:43,560 --> 00:05:45,720
have to be in order to get code to rot

141
00:05:45,720 --> 00:05:47,430
on some of the more esoteric platforms

142
00:05:47,430 --> 00:05:49,920
but we're gonna go through this process

143
00:05:49,920 --> 00:05:51,360
from kind of a high level so that

144
00:05:51,360 --> 00:05:53,190
everybody understands what happens when

145
00:05:53,190 --> 00:05:56,130
we take C code and compile it to

146
00:05:56,130 --> 00:05:57,930
something that'll run you know our

147
00:05:57,930 --> 00:06:01,350
modern computer and again really want to

148
00:06:01,350 --> 00:06:02,610
highlight the disclaimer here that each

149
00:06:02,610 --> 00:06:04,620
of these fields are you know extremely

150
00:06:04,620 --> 00:06:06,870
complex fields with you know multiple

151
00:06:06,870 --> 00:06:09,000
research areas etc this is just gonna be

152
00:06:09,000 --> 00:06:11,340
a high-level overview for all of us so

153
00:06:11,340 --> 00:06:12,840
that we know we're all kind of from the

154
00:06:12,840 --> 00:06:15,650
same starting point

155
00:06:18,060 --> 00:06:21,090
so we talked about how compiling is

156
00:06:21,090 --> 00:06:24,630
phase two of compilation phase one is

157
00:06:24,630 --> 00:06:27,630
kind of the pre-processing so if you've

158
00:06:27,630 --> 00:06:29,370
written code before you're familiar with

159
00:06:29,370 --> 00:06:32,190
the idea of you know adding comments and

160
00:06:32,190 --> 00:06:34,350
maybe macros and things like that when

161
00:06:34,350 --> 00:06:36,330
you put include headers at the top of

162
00:06:36,330 --> 00:06:39,860
your code these are all things that are

163
00:06:39,860 --> 00:06:42,180
interpreted and then processed during

164
00:06:42,180 --> 00:06:44,760
this pre-processing phase because the

165
00:06:44,760 --> 00:06:47,610
comment that you put in the code is not

166
00:06:47,610 --> 00:06:49,530
going to actually be run by your

167
00:06:49,530 --> 00:06:50,639
processor or interpreted by your

168
00:06:50,639 --> 00:06:53,520
processor anyway so the pre-processing

169
00:06:53,520 --> 00:06:56,090
phase gets rid of all that stuff and

170
00:06:56,090 --> 00:06:58,350
expands any macros that you might write

171
00:06:58,350 --> 00:07:00,720
and kind of gets rid of that extra fluff

172
00:07:00,720 --> 00:07:03,030
that we don't need and what actually

173
00:07:03,030 --> 00:07:05,580
happens during you know phase two when

174
00:07:05,580 --> 00:07:08,030
we compile it we take the output of that

175
00:07:08,030 --> 00:07:10,169
preprocessor that's C code that you've

176
00:07:10,169 --> 00:07:12,690
written and that then gets converted

177
00:07:12,690 --> 00:07:16,500
into assembly code so here's a simple

178
00:07:16,500 --> 00:07:19,620
example of what happens when you take

179
00:07:19,620 --> 00:07:21,690
you know the classic hello world example

180
00:07:21,690 --> 00:07:26,910
and compile it so this is just assembly

181
00:07:26,910 --> 00:07:29,640
code this hasn't been converted to

182
00:07:29,640 --> 00:07:30,810
anything that can run on the processor

183
00:07:30,810 --> 00:07:34,740
etc you can run GCC with a certain flag

184
00:07:34,740 --> 00:07:36,810
to only produce the assembly code and

185
00:07:36,810 --> 00:07:40,410
this is just a small segment of the

186
00:07:40,410 --> 00:07:42,000
assembly code that's present for hello

187
00:07:42,000 --> 00:07:43,890
world but what I wanted to illustrate

188
00:07:43,890 --> 00:07:47,760
here is that the first stage in taking

189
00:07:47,760 --> 00:07:49,860
that C code to something that can

190
00:07:49,860 --> 00:07:51,330
actually be run on your processor

191
00:07:51,330 --> 00:07:54,150
involves interpreting it and then

192
00:07:54,150 --> 00:07:57,389
turning it into this assembly code which

193
00:07:57,389 --> 00:07:59,280
is still you know technically human

194
00:07:59,280 --> 00:08:00,840
readable but you wouldn't necessarily

195
00:08:00,840 --> 00:08:03,600
want to be writing in this all the time

196
00:08:03,600 --> 00:08:07,800
which is why we have the C compiler or

197
00:08:07,800 --> 00:08:10,889
any other compiler for that matter so

198
00:08:10,889 --> 00:08:15,539
after that we go into the assembly phase

199
00:08:15,539 --> 00:08:19,940
and so what that does is it takes these

200
00:08:19,940 --> 00:08:22,169
instructions that we have here so these

201
00:08:22,169 --> 00:08:23,760
machine level instructions these

202
00:08:23,760 --> 00:08:26,610
low-level instructions and these

203
00:08:26,610 --> 00:08:30,080
instructions get converted into

204
00:08:30,080 --> 00:08:33,779
hexadecimal or binary opt to be

205
00:08:33,779 --> 00:08:35,849
interpreted and run by the CPU so when

206
00:08:35,849 --> 00:08:38,190
we talk about machine code this is what

207
00:08:38,190 --> 00:08:40,469
we're talking about and so for example

208
00:08:40,469 --> 00:08:42,960
that'll what happens during this phase

209
00:08:42,960 --> 00:08:45,420
is you take something like the move

210
00:08:45,420 --> 00:08:47,520
instruction which if these look

211
00:08:47,520 --> 00:08:49,230
unfamiliar to you we're gonna cover them

212
00:08:49,230 --> 00:08:51,089
in a second this is just a sort of

213
00:08:51,089 --> 00:08:54,960
outline how the end-to-end process works

214
00:08:54,960 --> 00:08:57,089
when you write software or build a

215
00:08:57,089 --> 00:08:58,410
program for those that might not be

216
00:08:58,410 --> 00:09:01,440
familiar so we take this move

217
00:09:01,440 --> 00:09:03,029
instruction and that gets converted into

218
00:09:03,029 --> 00:09:06,180
this number sequence essentially this

219
00:09:06,180 --> 00:09:09,600
binary opto that is actually interpreted

220
00:09:09,600 --> 00:09:13,830
and run by your cpu hardware eventually

221
00:09:13,830 --> 00:09:17,460
and so the output of the assembler is an

222
00:09:17,460 --> 00:09:22,529
object file this object file has opcodes

223
00:09:22,529 --> 00:09:25,440
in it and so again what these are are

224
00:09:25,440 --> 00:09:28,650
the binary representation of what

225
00:09:28,650 --> 00:09:30,390
actually gets interpreted in processed

226
00:09:30,390 --> 00:09:34,500
by your CPU and so I know most of you

227
00:09:34,500 --> 00:09:36,390
are probably familiar with the concept

228
00:09:36,390 --> 00:09:37,860
of assembly language maybe you've never

229
00:09:37,860 --> 00:09:40,920
written it before but this is an example

230
00:09:40,920 --> 00:09:43,320
of what happens when you assemble this

231
00:09:43,320 --> 00:09:45,900
to something that can again actually be

232
00:09:45,900 --> 00:09:48,320
interpreted by your computer and as

233
00:09:48,320 --> 00:09:51,510
reverse engineers this is gonna be our

234
00:09:51,510 --> 00:09:54,570
starting point so we have to use tools

235
00:09:54,570 --> 00:09:57,839
like deidre and others to work backwards

236
00:09:57,839 --> 00:10:01,020
from these binary sequences to the

237
00:10:01,020 --> 00:10:03,120
assembly code and then eventually we can

238
00:10:03,120 --> 00:10:04,770
even go back to C code and we'll show

239
00:10:04,770 --> 00:10:05,190
how

240
00:10:05,190 --> 00:10:08,160
deidre enables us to do that later but

241
00:10:08,160 --> 00:10:11,010
we're not quite done with the process of

242
00:10:11,010 --> 00:10:13,650
building code so we've taken that C code

243
00:10:13,650 --> 00:10:15,450
we've ripped out all the comments we've

244
00:10:15,450 --> 00:10:17,640
expanded the macros anything else like

245
00:10:17,640 --> 00:10:20,100
that we've generated the assembly code

246
00:10:20,100 --> 00:10:22,530
from that from there we generate the

247
00:10:22,530 --> 00:10:24,480
byte sequence with the assembler or the

248
00:10:24,480 --> 00:10:27,089
byte code the machine code here but

249
00:10:27,089 --> 00:10:30,720
there's still lots of things that the

250
00:10:30,720 --> 00:10:33,270
operating system needs to know right so

251
00:10:33,270 --> 00:10:35,040
these are just instructions that the CPU

252
00:10:35,040 --> 00:10:37,560
will certainly run but the operating

253
00:10:37,560 --> 00:10:39,660
system needs to know things like you

254
00:10:39,660 --> 00:10:41,490
know where do I put this in memory

255
00:10:41,490 --> 00:10:44,070
what other libraries what does the

256
00:10:44,070 --> 00:10:47,100
runtime look like etc so all this

257
00:10:47,100 --> 00:10:50,399
information is added during linking

258
00:10:50,399 --> 00:10:53,850
because again this object code is almost

259
00:10:53,850 --> 00:10:55,320
there where you know three quarters of

260
00:10:55,320 --> 00:10:58,260
the way there but the operating system

261
00:10:58,260 --> 00:11:00,779
needs to know you know where do I load

262
00:11:00,779 --> 00:11:03,089
this in virtual memory what are you know

263
00:11:03,089 --> 00:11:04,440
the various memory permissions things

264
00:11:04,440 --> 00:11:07,260
like that and so this is what linking

265
00:11:07,260 --> 00:11:09,930
does and if you've worked in the

266
00:11:09,930 --> 00:11:11,760
embedded system space before you've

267
00:11:11,760 --> 00:11:13,770
probably written linker scripts to

268
00:11:13,770 --> 00:11:16,410
define things like this chunk of memory

269
00:11:16,410 --> 00:11:19,050
is for SRAM and this chunk of memory is

270
00:11:19,050 --> 00:11:21,450
gonna be for the stack or the heat etc

271
00:11:21,450 --> 00:11:25,649
and so the linking phase adds all that

272
00:11:25,649 --> 00:11:27,690
information in to the object file so

273
00:11:27,690 --> 00:11:29,339
that it can finally be run by the

274
00:11:29,339 --> 00:11:32,430
computer and so what that might look

275
00:11:32,430 --> 00:11:36,510
like is we have the output of odd stuff

276
00:11:36,510 --> 00:11:40,020
here and so if you notice on the Left we

277
00:11:40,020 --> 00:11:42,300
have all these fields like the text

278
00:11:42,300 --> 00:11:45,120
section the data section VSS these all

279
00:11:45,120 --> 00:11:47,130
might be you know alien terms too you

280
00:11:47,130 --> 00:11:48,750
might not be sure what these mean yet

281
00:11:48,750 --> 00:11:50,880
and we're gonna go over that but what

282
00:11:50,880 --> 00:11:54,270
happens after linking is these fields

283
00:11:54,270 --> 00:11:57,360
get filled out with actual addresses so

284
00:11:57,360 --> 00:12:00,240
that the operating system knows went

285
00:12:00,240 --> 00:12:01,890
where to put these things in memory

286
00:12:01,890 --> 00:12:07,230
before they get run and so in that text

287
00:12:07,230 --> 00:12:09,329
section you have the wrong machine code

288
00:12:09,329 --> 00:12:11,850
in the data section you have you know

289
00:12:11,850 --> 00:12:14,130
any kind of variables that you might

290
00:12:14,130 --> 00:12:16,380
need while it's running etc and so

291
00:12:16,380 --> 00:12:20,520
linking basically fills in the needed

292
00:12:20,520 --> 00:12:22,740
information by the OS to run this

293
00:12:22,740 --> 00:12:26,100
program and there's also the linking is

294
00:12:26,100 --> 00:12:28,620
also used when you're compiling against

295
00:12:28,620 --> 00:12:30,779
another piece of code etc but for right

296
00:12:30,779 --> 00:12:33,540
now what we need to understand is that

297
00:12:33,540 --> 00:12:36,600
linking fills in the necessary fields

298
00:12:36,600 --> 00:12:37,800
and information that the operating

299
00:12:37,800 --> 00:12:41,750
system needs to run a program

300
00:12:42,070 --> 00:12:44,860
and so what happens after things have

301
00:12:44,860 --> 00:12:47,620
been linked is you finally have you know

302
00:12:47,620 --> 00:12:51,160
an executable output format and so on

303
00:12:51,160 --> 00:12:53,110
windows that's you know a PE or a dot

304
00:12:53,110 --> 00:12:54,640
exe file that you're all familiar with

305
00:12:54,640 --> 00:12:57,070
on Linux that's an elf file which is

306
00:12:57,070 --> 00:12:58,990
what we're gonna be focusing on and on

307
00:12:58,990 --> 00:13:01,570
OS X it's a mock oh and then some of you

308
00:13:01,570 --> 00:13:03,100
again may be from the embedded space

309
00:13:03,100 --> 00:13:04,510
after you build something you either

310
00:13:04,510 --> 00:13:07,210
have maybe a dot hex file or maybe it's

311
00:13:07,210 --> 00:13:08,920
an elf file that you'll then load on to

312
00:13:08,920 --> 00:13:12,670
an FPGA or something like that but the

313
00:13:12,670 --> 00:13:15,190
key point that I wanted to make here is

314
00:13:15,190 --> 00:13:17,860
that this output file after the result

315
00:13:17,860 --> 00:13:19,480
of everything we just talked about is

316
00:13:19,480 --> 00:13:21,430
gonna be your starting point as a

317
00:13:21,430 --> 00:13:22,810
reverse engineer you don't have source

318
00:13:22,810 --> 00:13:23,980
code you don't have anything else like

319
00:13:23,980 --> 00:13:26,290
that and so for this course we're gonna

320
00:13:26,290 --> 00:13:29,200
focus on the elf format and so we're

321
00:13:29,200 --> 00:13:31,360
gonna talk a little bit about how the

322
00:13:31,360 --> 00:13:36,340
elf files are formatted here so elf

323
00:13:36,340 --> 00:13:39,130
stands for executable linking format and

324
00:13:39,130 --> 00:13:40,170
again it contains information

325
00:13:40,170 --> 00:13:42,580
identifying what operating system it's

326
00:13:42,580 --> 00:13:44,890
supposed to run on the endian this is

327
00:13:44,890 --> 00:13:47,980
the data things like that and so elfs

328
00:13:47,980 --> 00:13:51,250
provide lots of information whether

329
00:13:51,250 --> 00:13:53,380
they're being used for you know linking

330
00:13:53,380 --> 00:13:56,260
or actually running and what we need to

331
00:13:56,260 --> 00:13:58,360
know for the purposes of this course is

332
00:13:58,360 --> 00:14:01,480
that in the elf file in that header it

333
00:14:01,480 --> 00:14:02,800
provides all the information that's

334
00:14:02,800 --> 00:14:05,320
needed for the operating system to load

335
00:14:05,320 --> 00:14:07,870
and run that program and we can kind of

336
00:14:07,870 --> 00:14:09,970
break the elf files up into three

337
00:14:09,970 --> 00:14:11,530
components we have the header that sort

338
00:14:11,530 --> 00:14:13,630
of defines the program and then sections

339
00:14:13,630 --> 00:14:17,650
in segments and so the reason we want to

340
00:14:17,650 --> 00:14:20,140
go over this is that this is a kind of a

341
00:14:20,140 --> 00:14:22,060
treasure trove of information for you as

342
00:14:22,060 --> 00:14:24,550
a reverse engineer because this format

343
00:14:24,550 --> 00:14:26,860
it's standardized you can use it to kind

344
00:14:26,860 --> 00:14:27,940
of figure out different things about

345
00:14:27,940 --> 00:14:31,000
binaries it will show later on today how

346
00:14:31,000 --> 00:14:32,890
it can take the fields from male file

347
00:14:32,890 --> 00:14:38,260
and use it to aid us in re and you know

348
00:14:38,260 --> 00:14:40,420
another thing about elf files as reverse

349
00:14:40,420 --> 00:14:41,440
engineer that you're gonna find

350
00:14:41,440 --> 00:14:43,630
extremely useful there are debug symbols

351
00:14:43,630 --> 00:14:46,690
so again those of you that have written

352
00:14:46,690 --> 00:14:48,850
code in something you know like code

353
00:14:48,850 --> 00:14:51,970
blocks or etc you can set watch point

354
00:14:51,970 --> 00:14:53,649
sensor variables you can

355
00:14:53,649 --> 00:14:55,509
you know set breakpoints on specific

356
00:14:55,509 --> 00:14:58,300
function names this is possible because

357
00:14:58,300 --> 00:15:00,970
the elf file basically presents this

358
00:15:00,970 --> 00:15:03,040
information to the operating system or

359
00:15:03,040 --> 00:15:05,439
to whoever's running it and says hey you

360
00:15:05,439 --> 00:15:06,610
know this function is going to be at

361
00:15:06,610 --> 00:15:08,350
this location this variable is going to

362
00:15:08,350 --> 00:15:10,240
be at this location and so you can

363
00:15:10,240 --> 00:15:12,309
imagine if you're trying to figure out

364
00:15:12,309 --> 00:15:15,699
what code is doing having symbols

365
00:15:15,699 --> 00:15:17,800
contained within there is extremely

366
00:15:17,800 --> 00:15:20,319
useful because it might you might be

367
00:15:20,319 --> 00:15:22,209
able to figure out what a functions name

368
00:15:22,209 --> 00:15:25,089
is you might be able to figure out you

369
00:15:25,089 --> 00:15:26,769
know things like that which if you're

370
00:15:26,769 --> 00:15:28,329
looking at a function and you're not

371
00:15:28,329 --> 00:15:30,189
sure what it does but then you can find

372
00:15:30,189 --> 00:15:31,600
out from the symbol that function is

373
00:15:31,600 --> 00:15:33,639
called you know check password or

374
00:15:33,639 --> 00:15:34,420
something like that

375
00:15:34,420 --> 00:15:35,860
that's extremely useful for you as a

376
00:15:35,860 --> 00:15:38,800
reverse engineer

377
00:15:38,800 --> 00:15:42,550
and so to kind of close out elf files

378
00:15:42,550 --> 00:15:47,360
the elf file is used to deterrant the

379
00:15:47,360 --> 00:15:50,600
how to layout a process in memory or how

380
00:15:50,600 --> 00:15:53,120
to set up everything such that that

381
00:15:53,120 --> 00:15:55,399
machine code that we generated from the

382
00:15:55,399 --> 00:15:57,769
C code can actually be run and processed

383
00:15:57,769 --> 00:16:01,700
by your CPU and so there are lots of

384
00:16:01,700 --> 00:16:03,860
tools to kind of read and analyze elf

385
00:16:03,860 --> 00:16:06,170
files and some of them are listed here

386
00:16:06,170 --> 00:16:09,200
we also have a couple of exercises about

387
00:16:09,200 --> 00:16:12,200
elf files in the git repo that we're

388
00:16:12,200 --> 00:16:13,760
going to talk about during the office

389
00:16:13,760 --> 00:16:16,160
hours and so the point of this was just

390
00:16:16,160 --> 00:16:19,220
to give an overview of the output file

391
00:16:19,220 --> 00:16:20,690
that you're gonna be working with in

392
00:16:20,690 --> 00:16:23,480
this class and kind of how you get to

393
00:16:23,480 --> 00:16:27,260
that output file starting from C code

394
00:16:27,260 --> 00:16:30,950
and you know because we're all gonna be

395
00:16:30,950 --> 00:16:34,010
low-level people after after this course

396
00:16:34,010 --> 00:16:36,740
we have a kind of a pixelated view here

397
00:16:36,740 --> 00:16:39,980
of what the compilation process looks

398
00:16:39,980 --> 00:16:42,589
like right so just to kind of recap what

399
00:16:42,589 --> 00:16:44,199
we talked about and again this was a

400
00:16:44,199 --> 00:16:47,269
10,000 foot view of compilation and

401
00:16:47,269 --> 00:16:49,610
assembly and linking I you know do not

402
00:16:49,610 --> 00:16:51,019
claim to be an expert of any of these

403
00:16:51,019 --> 00:16:53,810
fields this is just an overview for

404
00:16:53,810 --> 00:16:55,220
everybody so that we can all be on the

405
00:16:55,220 --> 00:16:58,100
same page so we go from you know our C

406
00:16:58,100 --> 00:17:00,769
code we compile that and then we have

407
00:17:00,769 --> 00:17:03,800
assembly code that gets generated and so

408
00:17:03,800 --> 00:17:06,199
that assembly code is then assembled

409
00:17:06,199 --> 00:17:09,530
into a sequence of bytes but that

410
00:17:09,530 --> 00:17:11,869
sequence of fights needs more context to

411
00:17:11,869 --> 00:17:14,720
actually properly be interpreted by the

412
00:17:14,720 --> 00:17:17,750
CPU and and run by the operating system

413
00:17:17,750 --> 00:17:19,760
so that's where linking comes into play

414
00:17:19,760 --> 00:17:22,579
so after we link it were left with an

415
00:17:22,579 --> 00:17:25,099
elf file and I know links not an elf

416
00:17:25,099 --> 00:17:28,580
he's I forget exactly what he is like a

417
00:17:28,580 --> 00:17:30,770
Kokiri or something but I think the

418
00:17:30,770 --> 00:17:35,270
point is is made here and so with that

419
00:17:35,270 --> 00:17:39,169
just to kind of close out this first

420
00:17:39,169 --> 00:17:41,960
initial session why are we going over

421
00:17:41,960 --> 00:17:43,730
this why are why do we care about this

422
00:17:43,730 --> 00:17:46,610
we're reverse engineers well when you're

423
00:17:46,610 --> 00:17:48,530
reverse engineering be it you know

424
00:17:48,530 --> 00:17:51,230
software or hardware information is

425
00:17:51,230 --> 00:17:51,740
extreme

426
00:17:51,740 --> 00:17:55,100
limited.you you don't have source code

427
00:17:55,100 --> 00:17:56,750
you might not even have something like

428
00:17:56,750 --> 00:17:58,460
an elf file as you get into more

429
00:17:58,460 --> 00:18:02,030
advanced targets right so you need to

430
00:18:02,030 --> 00:18:03,980
have some understanding of these

431
00:18:03,980 --> 00:18:07,250
fundamentals so that you can step

432
00:18:07,250 --> 00:18:08,960
backwards from this and then eventually

433
00:18:08,960 --> 00:18:11,300
get to that machine code and then get to

434
00:18:11,300 --> 00:18:13,820
the assembly code that you care about or

435
00:18:13,820 --> 00:18:16,450
that we're trying to figure out and so

436
00:18:16,450 --> 00:18:19,070
the main reason that we go over all of

437
00:18:19,070 --> 00:18:21,980
this is just that so that you know from

438
00:18:21,980 --> 00:18:24,770
your starting point where to go when

439
00:18:24,770 --> 00:18:26,900
you're handed a file if for this course

440
00:18:26,900 --> 00:18:28,820
and you have to work backwards to figure

441
00:18:28,820 --> 00:18:29,510
out what it does

442
00:18:29,510 --> 00:18:32,270
as we said you know this resulting elf

443
00:18:32,270 --> 00:18:34,670
file from the compilation process has

444
00:18:34,670 --> 00:18:37,730
that machine code embedded in it and the

445
00:18:37,730 --> 00:18:40,730
elf headers fields can be used to pull

446
00:18:40,730 --> 00:18:43,550
that out and from those bytes we can

447
00:18:43,550 --> 00:18:46,520
actually work backwards and to create

448
00:18:46,520 --> 00:18:48,110
you know it's an assembly language

449
00:18:48,110 --> 00:18:51,050
representation and that process is as

450
00:18:51,050 --> 00:18:53,380
you might have guessed called

451
00:18:53,380 --> 00:18:57,650
disassembly so what I'd like to do here

452
00:18:57,650 --> 00:18:59,720
is I see there's a couple questions in

453
00:18:59,720 --> 00:19:01,850
the QA so I want to take a quick pause

454
00:19:01,850 --> 00:19:03,559
right here now that we've gone through

455
00:19:03,559 --> 00:19:06,530
you know your 19 minute introduction

456
00:19:06,530 --> 00:19:09,110
through software engineering and make

457
00:19:09,110 --> 00:19:10,820
sure that there aren't any any huge

458
00:19:10,820 --> 00:19:13,450
questions here

459
00:19:13,450 --> 00:19:16,010
let's look at the Q&A

460
00:19:16,010 --> 00:19:20,880
so okay so we got two good questions one

461
00:19:20,880 --> 00:19:22,980
from Michael biases when is code

462
00:19:22,980 --> 00:19:26,640
obfuscation executed and that can happen

463
00:19:26,640 --> 00:19:29,400
in a variety of phases depending on the

464
00:19:29,400 --> 00:19:31,830
type of obfuscation that's being added

465
00:19:31,830 --> 00:19:32,970
and so I know that's not a perfect

466
00:19:32,970 --> 00:19:36,120
answer but there are things that will

467
00:19:36,120 --> 00:19:37,320
manipulate you know the jump

468
00:19:37,320 --> 00:19:39,210
instructions so that it might not jump

469
00:19:39,210 --> 00:19:40,440
to where you think it's gonna jump them

470
00:19:40,440 --> 00:19:42,840
things like that so obfuscation can kind

471
00:19:42,840 --> 00:19:44,820
of happen at multiple points in the

472
00:19:44,820 --> 00:19:46,710
compilation process depending on the

473
00:19:46,710 --> 00:19:49,950
method of obfuscation used and for those

474
00:19:49,950 --> 00:19:51,780
of you that don't know what obfuscation

475
00:19:51,780 --> 00:19:55,110
is obfuscation is when you try to

476
00:19:55,110 --> 00:19:58,230
manipulate the result of compilation so

477
00:19:58,230 --> 00:20:00,090
that it's harder for people like us

478
00:20:00,090 --> 00:20:01,470
to come in and figure out what it's

479
00:20:01,470 --> 00:20:05,610
doing and then Dave asks what we would

480
00:20:05,610 --> 00:20:10,170
consider dotnet stuff so dotnet is kind

481
00:20:10,170 --> 00:20:12,960
of a runtime that everything exists and

482
00:20:12,960 --> 00:20:14,790
it's it's certainly not my area of

483
00:20:14,790 --> 00:20:19,050
expertise necessarily but essentially

484
00:20:19,050 --> 00:20:21,900
that stuff still gets broken down into a

485
00:20:21,900 --> 00:20:23,760
sequence of instructions that run on

486
00:20:23,760 --> 00:20:25,980
your CPU and that you know at some point

487
00:20:25,980 --> 00:20:27,810
in the process regardless of how high

488
00:20:27,810 --> 00:20:30,090
the abstraction layer is it does get

489
00:20:30,090 --> 00:20:32,010
down to that point now if you're

490
00:20:32,010 --> 00:20:33,930
reversing dotnet does it make sense to

491
00:20:33,930 --> 00:20:36,630
immediately throw it into a disassembler

492
00:20:36,630 --> 00:20:38,910
no there's things like dotnet reflectors

493
00:20:38,910 --> 00:20:44,130
that can be used to decompile decompile

494
00:20:44,130 --> 00:20:45,630
is probably the right word you know

495
00:20:45,630 --> 00:20:49,470
dotnet code okay then I have another

496
00:20:49,470 --> 00:20:51,210
question oh yeah we are definitely gonna

497
00:20:51,210 --> 00:20:53,760
post the slides after the class what I'd

498
00:20:53,760 --> 00:20:55,260
like to do is probably clean them up and

499
00:20:55,260 --> 00:20:57,180
take some notes out things like that but

500
00:20:57,180 --> 00:21:00,480
I'll post them on the project page after

501
00:21:00,480 --> 00:21:03,660
after the class and so I'll take one

502
00:21:03,660 --> 00:21:05,400
more question here we have two people

503
00:21:05,400 --> 00:21:07,200
obvious Kate by handwriting assembly or

504
00:21:07,200 --> 00:21:09,480
are there obfuscating compilers so you

505
00:21:09,480 --> 00:21:11,250
can do it again you kind of do it in

506
00:21:11,250 --> 00:21:15,300
either way there are tools to obfuscate

507
00:21:15,300 --> 00:21:18,870
and I believe that there are tools that

508
00:21:18,870 --> 00:21:21,030
exist you can try to kind of obfuscate

509
00:21:21,030 --> 00:21:22,790
it different again different stages of

510
00:21:22,790 --> 00:21:26,250
the compilation process so it depends

511
00:21:26,250 --> 00:21:27,750
really on what you're trying to protect

512
00:21:27,750 --> 00:21:29,220
against necess

513
00:21:29,220 --> 00:21:31,049
early so yeah there are tools that can

514
00:21:31,049 --> 00:21:33,809
do it it would be kind of difficult to

515
00:21:33,809 --> 00:21:36,720
do it by hand on a modern machine I

516
00:21:36,720 --> 00:21:37,650
would say but that certainly doesn't

517
00:21:37,650 --> 00:21:40,919
mean you know people do it okay one more

518
00:21:40,919 --> 00:21:42,570
question how often is obfuscation in

519
00:21:42,570 --> 00:21:46,440
play great question it really depends on

520
00:21:46,440 --> 00:21:48,179
your target and kind of what they care

521
00:21:48,179 --> 00:21:52,650
about so you know you'll see it for you

522
00:21:52,650 --> 00:21:54,090
know think essentially things people are

523
00:21:54,090 --> 00:22:01,650
trying to protect so yeah it's how often

524
00:22:01,650 --> 00:22:03,510
is kind of a tough question to answer I

525
00:22:03,510 --> 00:22:05,010
would say it depends on kind of the

526
00:22:05,010 --> 00:22:06,270
research area that you're working in

527
00:22:06,270 --> 00:22:08,789
right so if you're looking at lots of

528
00:22:08,789 --> 00:22:10,710
bare metal firmware that has limited

529
00:22:10,710 --> 00:22:12,150
code space they don't really have the

530
00:22:12,150 --> 00:22:15,030
resources to you know obfuscate and D

531
00:22:15,030 --> 00:22:17,309
obfuscate necessarily but you know if

532
00:22:17,309 --> 00:22:18,539
you're looking at a game or you're

533
00:22:18,539 --> 00:22:20,580
looking at some other platform like a

534
00:22:20,580 --> 00:22:22,320
more modern platform like that there's a

535
00:22:22,320 --> 00:22:26,130
good chance you'll see it and okay so

536
00:22:26,130 --> 00:22:29,309
Harry is asking how to identify you know

537
00:22:29,309 --> 00:22:31,500
Pachter encrypted data using Hedra we

538
00:22:31,500 --> 00:22:34,740
will get into that at a later kind of in

539
00:22:34,740 --> 00:22:37,289
a later session and we can also you know

540
00:22:37,289 --> 00:22:38,760
we can discuss that on the course page

541
00:22:38,760 --> 00:22:42,539
if you want as well and then okay so

542
00:22:42,539 --> 00:22:44,280
this is gonna be the last question for

543
00:22:44,280 --> 00:22:44,880
this section

544
00:22:44,880 --> 00:22:47,669
Mike ts any binary can be reversed I

545
00:22:47,669 --> 00:22:50,720
mean technically yes right so if

546
00:22:50,720 --> 00:22:53,460
depending on you know like we had the

547
00:22:53,460 --> 00:22:55,350
question earlier about dotnet and things

548
00:22:55,350 --> 00:22:57,120
like that so depending on the format of

549
00:22:57,120 --> 00:22:59,190
the binary yes eventually it can be

550
00:22:59,190 --> 00:23:01,080
reversed now the steps that you might

551
00:23:01,080 --> 00:23:03,120
have to take to get it to a point where

552
00:23:03,120 --> 00:23:04,470
you can actually understand it are gonna

553
00:23:04,470 --> 00:23:07,289
vary based on whatever the target is and

554
00:23:07,289 --> 00:23:08,730
that's why for this course we're

555
00:23:08,730 --> 00:23:12,960
focusing on you know L files okay

556
00:23:12,960 --> 00:23:14,580
Mikey's lab do you have resources for

557
00:23:14,580 --> 00:23:16,650
extracting binaries from a platform of

558
00:23:16,650 --> 00:23:19,140
microcontroller uh yeah actually so if

559
00:23:19,140 --> 00:23:22,080
you look at my website I do that fairly

560
00:23:22,080 --> 00:23:23,490
regularly on a handful of different

561
00:23:23,490 --> 00:23:25,650
platforms so grabbing things over JTAG

562
00:23:25,650 --> 00:23:28,440
spy flash etc and that's that's a wrong

563
00:23:28,440 --> 00:23:31,830
Bob github dot and that might be a good

564
00:23:31,830 --> 00:23:33,270
starting point if you're looking to do

565
00:23:33,270 --> 00:23:34,840
that

566
00:23:34,840 --> 00:23:39,250
so all that being said what I'd like to

567
00:23:39,250 --> 00:23:43,570
do is move on to kind of the next step

568
00:23:43,570 --> 00:23:46,060
so we've gone over how you know programs

569
00:23:46,060 --> 00:23:47,710
go from high-level C code to something

570
00:23:47,710 --> 00:23:49,600
that we can understand let's talk about

571
00:23:49,600 --> 00:23:51,070
now how that's interpreted and what that

572
00:23:51,070 --> 00:23:53,920
might look like so you know computer

573
00:23:53,920 --> 00:23:55,930
architecture 101 again this is probably

574
00:23:55,930 --> 00:23:57,490
something a lot of you are familiar with

575
00:23:57,490 --> 00:23:59,410
but for those of you that aren't it's

576
00:23:59,410 --> 00:24:01,030
important to kind of understand from a

577
00:24:01,030 --> 00:24:04,900
high level when a C program is running

578
00:24:04,900 --> 00:24:07,060
or any program is running there is a

579
00:24:07,060 --> 00:24:08,410
sequence of events that have to happen

580
00:24:08,410 --> 00:24:10,290
so the instruction gets read into memory

581
00:24:10,290 --> 00:24:12,910
that instruction is then processed by

582
00:24:12,910 --> 00:24:15,580
the control unit at ALU and then the

583
00:24:15,580 --> 00:24:18,160
result of that instruction or operation

584
00:24:18,160 --> 00:24:20,820
is stored into memory or registers and

585
00:24:20,820 --> 00:24:23,470
if some of those terms maybe don't make

586
00:24:23,470 --> 00:24:25,780
sense to you we're gonna kind of go

587
00:24:25,780 --> 00:24:28,030
through all those right now and so for

588
00:24:28,030 --> 00:24:29,620
this course we're gonna be looking at

589
00:24:29,620 --> 00:24:32,620
predominantly C programs and from a

590
00:24:32,620 --> 00:24:34,720
high-level again we can sort of break

591
00:24:34,720 --> 00:24:38,050
these programs down into four core

592
00:24:38,050 --> 00:24:40,510
components so we can think of them in

593
00:24:40,510 --> 00:24:43,030
terms of you know registers instructions

594
00:24:43,030 --> 00:24:45,970
stack memory and heap memory and we're

595
00:24:45,970 --> 00:24:47,530
not going to cover heap memory today

596
00:24:47,530 --> 00:24:49,330
we're gonna get into that in the next

597
00:24:49,330 --> 00:24:51,120
section so for today we're gonna cover

598
00:24:51,120 --> 00:24:53,800
registers instructions and what the

599
00:24:53,800 --> 00:24:57,760
stack is and so this is you know kind of

600
00:24:57,760 --> 00:25:00,130
a nice picture of what is actually

601
00:25:00,130 --> 00:25:01,900
happening while your computer is you

602
00:25:01,900 --> 00:25:03,280
know running and doing things so you've

603
00:25:03,280 --> 00:25:06,910
got this multi-step process where you

604
00:25:06,910 --> 00:25:10,180
fetch an instruction from memory run it

605
00:25:10,180 --> 00:25:14,950
and then store the results and so you

606
00:25:14,950 --> 00:25:17,110
know this is again a extremely

607
00:25:17,110 --> 00:25:18,880
high-level view of how that stuff works

608
00:25:18,880 --> 00:25:22,000
but to kind of dig down a little deeper

609
00:25:22,000 --> 00:25:23,860
what we're gonna have to do is reverse

610
00:25:23,860 --> 00:25:25,330
engineers right we're going backwards

611
00:25:25,330 --> 00:25:28,270
from you know machine code we're gonna

612
00:25:28,270 --> 00:25:34,360
focus on x86 64 bit so x86 64 as the

613
00:25:34,360 --> 00:25:37,930
name implies is Intel's x86 64 bit

614
00:25:37,930 --> 00:25:40,960
version of the x86 architecture you know

615
00:25:40,960 --> 00:25:43,210
it contains multiple modes for back

616
00:25:43,210 --> 00:25:47,200
compat with 32-bit binaries etc the spec

617
00:25:47,200 --> 00:25:48,760
was originally created by

618
00:25:48,760 --> 00:25:51,580
mm and the reason we're you know picking

619
00:25:51,580 --> 00:25:53,560
this for a starting point is because

620
00:25:53,560 --> 00:25:55,690
it's commonly used and you know desktop

621
00:25:55,690 --> 00:25:59,140
and laptop computers and so we talked

622
00:25:59,140 --> 00:26:01,780
about you know breaking down programs

623
00:26:01,780 --> 00:26:03,550
into what we're gonna call today just

624
00:26:03,550 --> 00:26:07,020
three core components stack registers

625
00:26:07,020 --> 00:26:09,340
instructions let's talk about you know

626
00:26:09,340 --> 00:26:13,450
what registers are so registers are

627
00:26:13,450 --> 00:26:15,700
small so you can think of them as small

628
00:26:15,700 --> 00:26:17,920
storage areas used by the processor you

629
00:26:17,920 --> 00:26:19,840
can even sort of think of them as you

630
00:26:19,840 --> 00:26:21,460
know variables in a sense when we're

631
00:26:21,460 --> 00:26:22,870
looking at assembly language but that's

632
00:26:22,870 --> 00:26:26,040
probably not the best way to think of it

633
00:26:26,040 --> 00:26:31,060
x86 64 has 16 64-bit general-purpose

634
00:26:31,060 --> 00:26:33,310
registers that you'll see used you know

635
00:26:33,310 --> 00:26:35,860
in assembly language and these registers

636
00:26:35,860 --> 00:26:38,980
in assembly are typically represented

637
00:26:38,980 --> 00:26:42,310
with different mnemonics here based on

638
00:26:42,310 --> 00:26:44,920
their size and they can be operated out

639
00:26:44,920 --> 00:26:47,860
differently you know based on this the

640
00:26:47,860 --> 00:26:50,050
way that they're represented here and so

641
00:26:50,050 --> 00:26:52,090
are 0 through our 7 have particular

642
00:26:52,090 --> 00:26:55,120
names that we kind of cover here in this

643
00:26:55,120 --> 00:26:57,520
table and we'll get into what these

644
00:26:57,520 --> 00:27:00,010
names mean what they stand for later on

645
00:27:00,010 --> 00:27:04,140
in the course and then our 8 through 15

646
00:27:04,140 --> 00:27:06,130
for the purposes of this course don't

647
00:27:06,130 --> 00:27:07,570
have any particular name they're just

648
00:27:07,570 --> 00:27:11,800
used when extra space is used or needed

649
00:27:11,800 --> 00:27:16,210
rather but we've also got some special

650
00:27:16,210 --> 00:27:17,710
purpose registers like our IP the

651
00:27:17,710 --> 00:27:19,990
instruction player and as the name

652
00:27:19,990 --> 00:27:22,390
implies this implies this points to the

653
00:27:22,390 --> 00:27:24,160
next instruction to be executed and it's

654
00:27:24,160 --> 00:27:27,940
64 bits one you also have the are Flags

655
00:27:27,940 --> 00:27:30,250
register and what this is used for is

656
00:27:30,250 --> 00:27:33,630
kind of storing the results of different

657
00:27:33,630 --> 00:27:36,490
conditional flags that are set during

658
00:27:36,490 --> 00:27:38,230
arithmetic operations and we'll talk

659
00:27:38,230 --> 00:27:40,060
about what that means later in all the

660
00:27:40,060 --> 00:27:42,460
implications within that you also have

661
00:27:42,460 --> 00:27:44,020
you know floating-point status and

662
00:27:44,020 --> 00:27:45,550
control registers we probably won't get

663
00:27:45,550 --> 00:27:48,850
into those in this lesson but you know

664
00:27:48,850 --> 00:27:50,680
maybe in 3 & 4 we might talk about those

665
00:27:50,680 --> 00:27:52,870
and then most importantly we have you

666
00:27:52,870 --> 00:27:54,880
know our BP and our SP which is for

667
00:27:54,880 --> 00:27:57,310
stack manipulation and usage and I know

668
00:27:57,310 --> 00:27:59,530
we're throwing the term stack around a

669
00:27:59,530 --> 00:28:02,110
lot and if anyone here doesn't know that

670
00:28:02,110 --> 00:28:04,450
we're gonna get into that later so this

671
00:28:04,450 --> 00:28:05,860
is just to kind of highlight the

672
00:28:05,860 --> 00:28:10,000
different registers that x86 64 uses and

673
00:28:10,000 --> 00:28:11,559
that we'll be focusing on for the first

674
00:28:11,559 --> 00:28:14,890
few exercises in this course so we have

675
00:28:14,890 --> 00:28:16,750
registers these are kind of like our

676
00:28:16,750 --> 00:28:19,720
variables our storage buckets for data

677
00:28:19,720 --> 00:28:22,390
as we you know run instructions on the

678
00:28:22,390 --> 00:28:25,570
CPU but what am I talking about when I

679
00:28:25,570 --> 00:28:28,660
talk about an instruction so an

680
00:28:28,660 --> 00:28:30,340
instruction you know at an extremely

681
00:28:30,340 --> 00:28:32,950
high level defines the Optus particular

682
00:28:32,950 --> 00:28:35,440
operation that's being performed by the

683
00:28:35,440 --> 00:28:37,750
CPU and so that might be you know

684
00:28:37,750 --> 00:28:40,480
addition subtraction multiplication etc

685
00:28:40,480 --> 00:28:42,700
because even though you know when we

686
00:28:42,700 --> 00:28:44,080
look at a modern computer and there's

687
00:28:44,080 --> 00:28:45,850
all kinds of stuff going on all of that

688
00:28:45,850 --> 00:28:48,130
eventually gets boiled down into you

689
00:28:48,130 --> 00:28:49,419
know what are essentially arithmetic

690
00:28:49,419 --> 00:28:51,040
instructions that are being run by your

691
00:28:51,040 --> 00:28:54,690
CPU and that's that lowest low level of

692
00:28:54,690 --> 00:28:56,620
abstraction that we're starting with and

693
00:28:56,620 --> 00:28:58,870
so that's why it's kind of important to

694
00:28:58,870 --> 00:29:02,169
cover this stuff instructions can have

695
00:29:02,169 --> 00:29:05,440
multiple operands they there's a ton of

696
00:29:05,440 --> 00:29:09,100
them for x86 64 when you're reverse

697
00:29:09,100 --> 00:29:11,169
engineering something like this you

698
00:29:11,169 --> 00:29:13,419
typically want to have those manuals

699
00:29:13,419 --> 00:29:14,919
kind of ready to go so you can look

700
00:29:14,919 --> 00:29:17,140
things up but what I wanted to do to

701
00:29:17,140 --> 00:29:18,400
kind of get everybody up to speed again

702
00:29:18,400 --> 00:29:20,650
and you know sort of on the same page is

703
00:29:20,650 --> 00:29:22,990
go over some of the commonly used

704
00:29:22,990 --> 00:29:26,910
instructions for x86 64

705
00:29:27,200 --> 00:29:29,520
the first one we're going to talk about

706
00:29:29,520 --> 00:29:33,180
is the move instruction and you know if

707
00:29:33,180 --> 00:29:35,370
you could guess by the name what this

708
00:29:35,370 --> 00:29:37,620
instruction does is it moves data from

709
00:29:37,620 --> 00:29:39,660
one register to another or a memory

710
00:29:39,660 --> 00:29:42,660
memory location to a register so again

711
00:29:42,660 --> 00:29:44,760
if registers are these fields that we

712
00:29:44,760 --> 00:29:48,390
use to store data in move can swap the

713
00:29:48,390 --> 00:29:50,550
data around or move read move data from

714
00:29:50,550 --> 00:29:52,380
one register to another or a memory

715
00:29:52,380 --> 00:29:54,480
location to another so the two examples

716
00:29:54,480 --> 00:29:56,700
we have here we have the instruction

717
00:29:56,700 --> 00:30:00,390
move r ax r bx and what that does takes

718
00:30:00,390 --> 00:30:02,880
the value in our BX and stores it in our

719
00:30:02,880 --> 00:30:07,050
ax and then next we have move r ax r CX

720
00:30:07,050 --> 00:30:09,540
but you'll notice our CX is in brackets

721
00:30:09,540 --> 00:30:12,240
and we'll talk about this later on today

722
00:30:12,240 --> 00:30:14,310
but what that means what those brackets

723
00:30:14,310 --> 00:30:17,220
is that that is a different type of

724
00:30:17,220 --> 00:30:19,110
addressing mode and essentially what

725
00:30:19,110 --> 00:30:21,180
that means is instead of the value in R

726
00:30:21,180 --> 00:30:25,110
CX we're gonna take the value pointed to

727
00:30:25,110 --> 00:30:27,930
by the value in R CX and so when I say

728
00:30:27,930 --> 00:30:30,690
pointed to what I mean is let's say R C

729
00:30:30,690 --> 00:30:34,110
X has the value hex 10,000 in it instead

730
00:30:34,110 --> 00:30:36,840
of storing hex 10,000 in the r ax we're

731
00:30:36,840 --> 00:30:39,360
gonna store what is at address hex

732
00:30:39,360 --> 00:30:44,550
10,000 into R ax and so this is you know

733
00:30:44,550 --> 00:30:46,290
the move instruction and our examples

734
00:30:46,290 --> 00:30:48,720
here have our ax and r bx this could be

735
00:30:48,720 --> 00:30:50,070
any of those general-purpose registers

736
00:30:50,070 --> 00:30:53,100
that we talked about right

737
00:30:53,100 --> 00:30:56,040
so after that let's talk about you know

738
00:30:56,040 --> 00:30:58,440
kind of the next building block here

739
00:30:58,440 --> 00:31:00,510
adding and subtracting right so we

740
00:31:00,510 --> 00:31:02,550
talked about how the you know a modern

741
00:31:02,550 --> 00:31:04,680
CPU is still just fundamentally running

742
00:31:04,680 --> 00:31:06,360
you know various arithmetic operations

743
00:31:06,360 --> 00:31:09,960
at a low level so add and subtract as

744
00:31:09,960 --> 00:31:11,430
one of those causes that it can do and

745
00:31:11,430 --> 00:31:14,430
so what the add instruction does is it

746
00:31:14,430 --> 00:31:16,830
adds the two values together and then

747
00:31:16,830 --> 00:31:18,870
stores the result in the first argument

748
00:31:18,870 --> 00:31:22,320
so for example add our ax r bx we add

749
00:31:22,320 --> 00:31:25,890
our BX to the we add the value of RB X

750
00:31:25,890 --> 00:31:27,540
to the value and our ax and then we

751
00:31:27,540 --> 00:31:30,740
store that result back into our ax and

752
00:31:30,740 --> 00:31:32,550
those of you that are you know familiar

753
00:31:32,550 --> 00:31:34,440
with C or have written some code before

754
00:31:34,440 --> 00:31:38,160
this kind of pseudocode here represents

755
00:31:38,160 --> 00:31:40,679
what this does and as you might

756
00:31:40,679 --> 00:31:42,869
guests subtract works in a very similar

757
00:31:42,869 --> 00:31:46,169
way except for we subtract the value in

758
00:31:46,169 --> 00:31:47,850
the second operand from the first one

759
00:31:47,850 --> 00:31:49,830
and we store the result in the first

760
00:31:49,830 --> 00:31:53,789
operand so these are two more you know

761
00:31:53,789 --> 00:31:56,009
arithmetic instructions that can be run

762
00:31:56,009 --> 00:31:58,710
and that you'll see and so the purpose

763
00:31:58,710 --> 00:32:00,210
of this course and like what we're gonna

764
00:32:00,210 --> 00:32:02,220
learn how to do and what Guidry is gonna

765
00:32:02,220 --> 00:32:05,399
help us do is go from these arithmetic

766
00:32:05,399 --> 00:32:07,289
instructions that might at surface level

767
00:32:07,289 --> 00:32:11,639
seem you know very abstract and very you

768
00:32:11,639 --> 00:32:14,850
know kind of non informative to we're

769
00:32:14,850 --> 00:32:16,499
gonna be able to take these and turn

770
00:32:16,499 --> 00:32:19,499
them into you know high-level c-code

771
00:32:19,499 --> 00:32:21,210
operations and then you know eventually

772
00:32:21,210 --> 00:32:23,309
we'll take that even farther into saying

773
00:32:23,309 --> 00:32:25,289
like oh I think this program based on

774
00:32:25,289 --> 00:32:28,080
these instructions is reading data from

775
00:32:28,080 --> 00:32:31,529
here doing this operation on it and then

776
00:32:31,529 --> 00:32:33,389
returning and so that's why we're going

777
00:32:33,389 --> 00:32:35,519
over these things at a low level because

778
00:32:35,519 --> 00:32:38,519
we're gonna learn how to work backwards

779
00:32:38,519 --> 00:32:42,259
from this to give it you know kind of a

780
00:32:42,259 --> 00:32:45,480
bigger meaning than just the arithmetic

781
00:32:45,480 --> 00:32:47,250
that we're looking at

782
00:32:47,250 --> 00:32:49,650
and so you know in addition to these you

783
00:32:49,650 --> 00:32:51,390
know more common arithmetic instructions

784
00:32:51,390 --> 00:32:53,820
you have of course binary operations

785
00:32:53,820 --> 00:32:55,170
that can occur so those of you that are

786
00:32:55,170 --> 00:32:58,950
familiar with digital logic are you know

787
00:32:58,950 --> 00:33:00,120
gonna be familiar with some of these

788
00:33:00,120 --> 00:33:03,870
operations and Zoar or etc and they work

789
00:33:03,870 --> 00:33:06,960
in a very similar way to you know add

790
00:33:06,960 --> 00:33:11,130
subtract so and our ax our ax and those

791
00:33:11,130 --> 00:33:12,960
two values together and stores it back

792
00:33:12,960 --> 00:33:16,920
into our ax and you know as you can

793
00:33:16,920 --> 00:33:19,380
imagine this does very little right

794
00:33:19,380 --> 00:33:21,330
because because if you an something with

795
00:33:21,330 --> 00:33:23,730
itself you get the thing the thing that

796
00:33:23,730 --> 00:33:27,210
you added but this same exact syntax is

797
00:33:27,210 --> 00:33:28,920
used for the zuhr instruction the or

798
00:33:28,920 --> 00:33:32,010
instruction and it's just it's an

799
00:33:32,010 --> 00:33:35,940
important one to cover so we talked

800
00:33:35,940 --> 00:33:38,010
before about we've talked about

801
00:33:38,010 --> 00:33:39,660
registers we've gone over you know a

802
00:33:39,660 --> 00:33:42,240
couple instructions next we kind of to

803
00:33:42,240 --> 00:33:43,980
talk about further instructions we need

804
00:33:43,980 --> 00:33:45,990
to go over something called the stack

805
00:33:45,990 --> 00:33:49,980
and so what the stat is essentially is

806
00:33:49,980 --> 00:33:52,950
it's a region of contiguous memory

807
00:33:52,950 --> 00:33:55,350
that's used as kind of like a scratch

808
00:33:55,350 --> 00:33:59,070
space for for functions and for you know

809
00:33:59,070 --> 00:34:02,610
various operations so stack memory is

810
00:34:02,610 --> 00:34:06,090
used to pass data to from locations it's

811
00:34:06,090 --> 00:34:08,820
used for you know local variables things

812
00:34:08,820 --> 00:34:10,949
like that and we'll get into more

813
00:34:10,949 --> 00:34:13,500
advanced you know usage of the stack in

814
00:34:13,500 --> 00:34:16,830
at a later date but for now the way you

815
00:34:16,830 --> 00:34:18,210
need to understand about the stack is

816
00:34:18,210 --> 00:34:20,129
just kind of how it operates at its core

817
00:34:20,129 --> 00:34:22,230
level so we're gonna talk about two

818
00:34:22,230 --> 00:34:23,969
instructions that interact with the

819
00:34:23,969 --> 00:34:27,600
stack push which writes to it and then

820
00:34:27,600 --> 00:34:31,560
pop which reads from it and we had those

821
00:34:31,560 --> 00:34:33,929
two registers before our BP and our SP

822
00:34:33,929 --> 00:34:36,690
so our BP points to the base of the

823
00:34:36,690 --> 00:34:38,550
stack and then our SP kind of points to

824
00:34:38,550 --> 00:34:39,780
what we'll call you know to the top of

825
00:34:39,780 --> 00:34:42,239
the stack and since it goes from it

826
00:34:42,239 --> 00:34:43,980
actually grows from a high memory

827
00:34:43,980 --> 00:34:45,899
address to a low memory address so

828
00:34:45,899 --> 00:34:47,940
talking about top and bottom with the

829
00:34:47,940 --> 00:34:50,520
stack is sometimes confusing but just

830
00:34:50,520 --> 00:34:51,690
you know keep that in mind and we'll

831
00:34:51,690 --> 00:34:53,699
have a graphic later to kind of go over

832
00:34:53,699 --> 00:34:57,750
how the stack works but think of it as

833
00:34:57,750 --> 00:35:00,060
just kind of scratch space and memory

834
00:35:00,060 --> 00:35:03,120
that the computer can use to store

835
00:35:03,120 --> 00:35:05,190
values for later because we only have so

836
00:35:05,190 --> 00:35:06,810
many general-purpose registers we need

837
00:35:06,810 --> 00:35:08,430
to be able to save things for later and

838
00:35:08,430 --> 00:35:10,490
so that's kind of what the stack is for

839
00:35:10,490 --> 00:35:13,470
and so we have these two instructions

840
00:35:13,470 --> 00:35:15,120
push and pop that interact with the

841
00:35:15,120 --> 00:35:19,020
stack and so push will grow the stack by

842
00:35:19,020 --> 00:35:21,270
eight and again if this is still not

843
00:35:21,270 --> 00:35:22,740
quite clicking we have an animation

844
00:35:22,740 --> 00:35:24,330
after this that might help this make

845
00:35:24,330 --> 00:35:27,960
sense so push takes the value from the

846
00:35:27,960 --> 00:35:30,450
register that it's being called by so

847
00:35:30,450 --> 00:35:32,970
with this particular instruction we'll

848
00:35:32,970 --> 00:35:35,310
take the value in rx and push that onto

849
00:35:35,310 --> 00:35:36,750
the stack and increase the stack pointer

850
00:35:36,750 --> 00:35:38,880
by eight to point to the next location

851
00:35:38,880 --> 00:35:43,140
and pop does the exact opposite so it

852
00:35:43,140 --> 00:35:45,600
grabs the value that RSP is pointing to

853
00:35:45,600 --> 00:35:47,190
so it grabs the value at the top of the

854
00:35:47,190 --> 00:35:48,990
stack and then decrements the stack

855
00:35:48,990 --> 00:35:50,640
pointer to that point at the next one

856
00:35:50,640 --> 00:35:53,250
and so you can think of it as you know

857
00:35:53,250 --> 00:35:55,530
you're putting you're stacking up plates

858
00:35:55,530 --> 00:35:57,210
and then you're pulling you know you're

859
00:35:57,210 --> 00:36:00,720
pulling plates from the same stack so to

860
00:36:00,720 --> 00:36:02,370
sort of illustrate this we have a

861
00:36:02,370 --> 00:36:04,140
PowerPoint animation here so let's say

862
00:36:04,140 --> 00:36:05,610
we have this sequence of instructions

863
00:36:05,610 --> 00:36:08,910
we're gonna push our a x RB x and our C

864
00:36:08,910 --> 00:36:10,830
X onto the stack and then we're gonna

865
00:36:10,830 --> 00:36:14,420
pop the value on this from the stack off

866
00:36:14,420 --> 00:36:16,770
into our a X so here's what that looks

867
00:36:16,770 --> 00:36:20,430
like with a nice animation here so the

868
00:36:20,430 --> 00:36:22,800
first instruction executes and we push

869
00:36:22,800 --> 00:36:25,590
our a X onto the stack the second

870
00:36:25,590 --> 00:36:28,350
instruction executes and we push our BX

871
00:36:28,350 --> 00:36:30,630
on the stack the third instruction

872
00:36:30,630 --> 00:36:32,670
execute you can guess what happens here

873
00:36:32,670 --> 00:36:35,220
it points RC exogamous it pushes our CX

874
00:36:35,220 --> 00:36:37,920
onto the stack but now when we run this

875
00:36:37,920 --> 00:36:40,980
pop our ax command what that's gonna do

876
00:36:40,980 --> 00:36:42,810
is pop whatever's at the top of the

877
00:36:42,810 --> 00:36:46,020
stack and store that in our ax so this

878
00:36:46,020 --> 00:36:47,730
is gonna be what we look what the stack

879
00:36:47,730 --> 00:36:49,770
looks like at the end of this at the end

880
00:36:49,770 --> 00:36:52,140
of the sequence of instructions and so

881
00:36:52,140 --> 00:36:54,330
the stack is important for understanding

882
00:36:54,330 --> 00:36:57,390
how functions are called later and you

883
00:36:57,390 --> 00:37:00,720
know it's often used for to store local

884
00:37:00,720 --> 00:37:02,670
variables and things like that but we'll

885
00:37:02,670 --> 00:37:04,470
get into that you know later on in the

886
00:37:04,470 --> 00:37:06,060
course kind of how to interpret that

887
00:37:06,060 --> 00:37:08,160
right now I just want you to be familiar

888
00:37:08,160 --> 00:37:10,170
with you know the concept of how a stack

889
00:37:10,170 --> 00:37:11,670
works and the instructions that

890
00:37:11,670 --> 00:37:12,770
manipulate it

891
00:37:12,770 --> 00:37:15,770
and so next we have the jump and call

892
00:37:15,770 --> 00:37:18,190
instructions the the jump instruction

893
00:37:18,190 --> 00:37:22,220
just modifies the value in the ID IP

894
00:37:22,220 --> 00:37:24,890
here are at the instruction pointer so

895
00:37:24,890 --> 00:37:26,600
again what this does is it causes the

896
00:37:26,600 --> 00:37:29,870
code to jump to another location and the

897
00:37:29,870 --> 00:37:31,760
call is used to implement function calls

898
00:37:31,760 --> 00:37:34,340
and what that will do is it will fix up

899
00:37:34,340 --> 00:37:37,100
the stack appropriately and then jump to

900
00:37:37,100 --> 00:37:40,160
a new location and it does that so that

901
00:37:40,160 --> 00:37:42,950
when it's done calling that function it

902
00:37:42,950 --> 00:37:45,230
knows where to jump back to but we'll

903
00:37:45,230 --> 00:37:47,810
get into that in greater detail later on

904
00:37:47,810 --> 00:37:50,180
what I want you to be familiar with now

905
00:37:50,180 --> 00:37:51,650
and kind understand now is that call is

906
00:37:51,650 --> 00:37:53,900
used to implement function calls and

907
00:37:53,900 --> 00:37:55,220
you'll see some of that with the

908
00:37:55,220 --> 00:37:59,180
exercises we're going to do the last

909
00:37:59,180 --> 00:38:00,730
instruction we're going to talk about is

910
00:38:00,730 --> 00:38:02,780
compare because you're gonna see it a

911
00:38:02,780 --> 00:38:04,880
lot when it comes to things like control

912
00:38:04,880 --> 00:38:08,390
flow so compare performs you know a

913
00:38:08,390 --> 00:38:10,700
comparison operation by subtracting the

914
00:38:10,700 --> 00:38:13,430
operands that is provided except for

915
00:38:13,430 --> 00:38:15,680
there's no storage face so the result is

916
00:38:15,680 --> 00:38:18,800
never stored and based on the result of

917
00:38:18,800 --> 00:38:21,320
this subtraction operation if there was

918
00:38:21,320 --> 00:38:25,250
you know maybe an overflow or if you

919
00:38:25,250 --> 00:38:27,590
know a signed bit was set etcetera flags

920
00:38:27,590 --> 00:38:29,720
in that our flags register you're gonna

921
00:38:29,720 --> 00:38:33,320
be set and those are flags bits the bits

922
00:38:33,320 --> 00:38:35,480
in that register are important because

923
00:38:35,480 --> 00:38:37,490
the jump instruction has variants that

924
00:38:37,490 --> 00:38:40,070
will check those flags before actually

925
00:38:40,070 --> 00:38:42,440
performing the jump so if the zero flag

926
00:38:42,440 --> 00:38:45,710
gets set let's say our ax contains zero

927
00:38:45,710 --> 00:38:47,810
and the zero flag gets X we subtracted

928
00:38:47,810 --> 00:38:50,420
five from that since the zero flag now

929
00:38:50,420 --> 00:38:53,990
the jump zero instruction is gonna is

930
00:38:53,990 --> 00:38:57,050
gonna run and if that flag isn't set the

931
00:38:57,050 --> 00:38:59,900
jump 0 instruction won't won't jump it

932
00:38:59,900 --> 00:39:02,540
won't modify EIP and so that kind of

933
00:39:02,540 --> 00:39:04,400
gets into the topic of you know control

934
00:39:04,400 --> 00:39:08,390
flow and how programs determine kind of

935
00:39:08,390 --> 00:39:09,950
the map of which they're gonna execute

936
00:39:09,950 --> 00:39:11,570
through and we're gonna talk about a lot

937
00:39:11,570 --> 00:39:14,090
that a lot in the second session but for

938
00:39:14,090 --> 00:39:15,320
today I just wanted you to be aware of

939
00:39:15,320 --> 00:39:17,060
you know this compare instruction kind

940
00:39:17,060 --> 00:39:18,640
of how it works at a lower level and

941
00:39:18,640 --> 00:39:21,500
then you know lastly what we're going to

942
00:39:21,500 --> 00:39:25,829
talk about with x86 64 bit today is

943
00:39:25,829 --> 00:39:27,329
you know addressing modes we talked

944
00:39:27,329 --> 00:39:29,099
about this before but essentially

945
00:39:29,099 --> 00:39:30,869
there's different ways instructions can

946
00:39:30,869 --> 00:39:34,380
reference registers and memory so the

947
00:39:34,380 --> 00:39:36,630
simplest form is using an immediate

948
00:39:36,630 --> 00:39:38,459
addressing mode like this where this

949
00:39:38,459 --> 00:39:43,259
instruction add RA x-14 right adds 14 to

950
00:39:43,259 --> 00:39:43,739
RX

951
00:39:43,739 --> 00:39:46,739
stores it back into RA X and you can

952
00:39:46,739 --> 00:39:48,599
also as we showed before you can do this

953
00:39:48,599 --> 00:39:50,700
and on a register to register basics

954
00:39:50,700 --> 00:39:53,579
basis so you can soar RA X with itself

955
00:39:53,579 --> 00:39:55,289
which again would kind of clear the

956
00:39:55,289 --> 00:39:58,380
value but most importantly what I want

957
00:39:58,380 --> 00:40:00,930
to show here is that you'll see things

958
00:40:00,930 --> 00:40:03,479
with brackets which reference what's

959
00:40:03,479 --> 00:40:04,920
called you know an indirect access and

960
00:40:04,920 --> 00:40:07,709
this essentially treats these values

961
00:40:07,709 --> 00:40:10,859
like pointers and that's something

962
00:40:10,859 --> 00:40:12,420
you're gonna see fairly regularly so I

963
00:40:12,420 --> 00:40:13,739
wanted you to be familiar with it so

964
00:40:13,739 --> 00:40:14,969
when you see something in brackets like

965
00:40:14,969 --> 00:40:18,450
that depending on the instruction it's

966
00:40:18,450 --> 00:40:19,890
actually referencing what is at that

967
00:40:19,890 --> 00:40:21,390
memory location and you'll see

968
00:40:21,390 --> 00:40:24,269
oftentimes you know arithmetic operands

969
00:40:24,269 --> 00:40:26,519
get applied inside of these brackets and

970
00:40:26,519 --> 00:40:28,140
so we have an example of that here and

971
00:40:28,140 --> 00:40:29,999
what that might look like with the Intel

972
00:40:29,999 --> 00:40:35,039
syntax so to kind of wrap up x86 64

973
00:40:35,039 --> 00:40:37,319
instructions we're gonna walk through

974
00:40:37,319 --> 00:40:38,940
you know very simple sequence of

975
00:40:38,940 --> 00:40:40,349
instructions here to make sure that we

976
00:40:40,349 --> 00:40:43,289
all are kind of on the same page so this

977
00:40:43,289 --> 00:40:44,640
first instruction is going to move the

978
00:40:44,640 --> 00:40:48,349
value re error to F F F into our ax and

979
00:40:48,349 --> 00:40:50,819
you'll see we have our real time power

980
00:40:50,819 --> 00:40:52,349
point debugger here that's going to kind

981
00:40:52,349 --> 00:40:54,539
of you know highlight what's going on as

982
00:40:54,539 --> 00:40:58,559
we go through this assembly code and so

983
00:40:58,559 --> 00:41:00,269
the second instruction as you might have

984
00:41:00,269 --> 00:41:02,309
guessed is going to move the value you

985
00:41:02,309 --> 00:41:06,299
know hex 3000 in the RPX now we're gonna

986
00:41:06,299 --> 00:41:08,910
or those two values and store the result

987
00:41:08,910 --> 00:41:11,540
into our ax

988
00:41:11,540 --> 00:41:14,330
so you see that resulted in three FFF in

989
00:41:14,330 --> 00:41:17,510
our X now we're gonna move hex 10,000 in

990
00:41:17,510 --> 00:41:23,450
the RCX we're gonna subtract our ax from

991
00:41:23,450 --> 00:41:25,550
our CX and we're gonna then store the

992
00:41:25,550 --> 00:41:27,710
result back into our CX because that's

993
00:41:27,710 --> 00:41:31,820
our first operand and so now we can see

994
00:41:31,820 --> 00:41:32,690
the result here

995
00:41:32,690 --> 00:41:34,730
we went from hex 10,000 because we

996
00:41:34,730 --> 00:41:39,590
subtract 3 F F F to see 0 0 1 now we're

997
00:41:39,590 --> 00:41:42,950
gonna add our CX RBX together and where

998
00:41:42,950 --> 00:41:44,450
are we going to store the result we're

999
00:41:44,450 --> 00:41:49,550
gonna store it back into our CX and so

1000
00:41:49,550 --> 00:41:51,530
now we have a comparison instruction so

1001
00:41:51,530 --> 00:41:54,680
we're gonna compare the values are B X

1002
00:41:54,680 --> 00:41:57,380
and our ax and you'll notice underneath

1003
00:41:57,380 --> 00:42:00,440
we have this jg which is the jump

1004
00:42:00,440 --> 00:42:02,180
instruction but it only jumps if the

1005
00:42:02,180 --> 00:42:05,270
greater than flag is been set so we're

1006
00:42:05,270 --> 00:42:06,770
gonna compare these two values and

1007
00:42:06,770 --> 00:42:08,600
because our ax is indeed greater than

1008
00:42:08,600 --> 00:42:11,630
our BX where do we are we gonna jump to

1009
00:42:11,630 --> 00:42:13,490
the greater than label and execute these

1010
00:42:13,490 --> 00:42:16,940
instructions or are we going to execute

1011
00:42:16,940 --> 00:42:20,090
move our ax 2 so let's let's find out

1012
00:42:20,090 --> 00:42:23,690
let's dig through this so the comparison

1013
00:42:23,690 --> 00:42:26,120
instruction runs and it sets the

1014
00:42:26,120 --> 00:42:28,100
appropriate flags and now jump greater

1015
00:42:28,100 --> 00:42:32,960
than runs and because the value in our X

1016
00:42:32,960 --> 00:42:34,550
is greater than we jump to this label

1017
00:42:34,550 --> 00:42:36,860
and so our IP now points to greater than

1018
00:42:36,860 --> 00:42:39,740
as to the address that this would be at

1019
00:42:39,740 --> 00:42:41,600
as opposed to this other instruction so

1020
00:42:41,600 --> 00:42:44,660
then we move 1 into our ax and then we

1021
00:42:44,660 --> 00:42:49,510
return and so that was kind of a

1022
00:42:49,510 --> 00:42:52,580
lightning-fast introduction to x86 64

1023
00:42:52,580 --> 00:42:55,820
and how the architecture works I wanted

1024
00:42:55,820 --> 00:42:57,590
to go through that because I wasn't sure

1025
00:42:57,590 --> 00:42:59,570
you know where everybody was gonna be in

1026
00:42:59,570 --> 00:43:02,660
terms of the architecture there's we put

1027
00:43:02,660 --> 00:43:04,910
resources up on the course page for

1028
00:43:04,910 --> 00:43:05,780
those of you that might not be familiar

1029
00:43:05,780 --> 00:43:09,350
with x86 64 and assembly language things

1030
00:43:09,350 --> 00:43:12,980
like that and as we use Ghidorah you're

1031
00:43:12,980 --> 00:43:14,980
gonna find that it actually has a

1032
00:43:14,980 --> 00:43:18,580
extremely powerful D compiler which is

1033
00:43:18,580 --> 00:43:20,450
implemented by understanding you know

1034
00:43:20,450 --> 00:43:22,010
the underlying assembly code but it's

1035
00:43:22,010 --> 00:43:24,530
still important for us to have that kind

1036
00:43:24,530 --> 00:43:24,970
of strong

1037
00:43:24,970 --> 00:43:26,830
fundamental core of understanding what's

1038
00:43:26,830 --> 00:43:28,750
going on under the hood because they're

1039
00:43:28,750 --> 00:43:31,060
gonna be times maybe when the decompiler

1040
00:43:31,060 --> 00:43:33,520
doesn't work or you need to go in and

1041
00:43:33,520 --> 00:43:34,869
understand the assembly so it's

1042
00:43:34,869 --> 00:43:36,250
important to have an understanding of

1043
00:43:36,250 --> 00:43:38,980
that and I I see that we have some QA

1044
00:43:38,980 --> 00:43:41,050
here what I'd like to do is get through

1045
00:43:41,050 --> 00:43:42,790
the next section because we are running

1046
00:43:42,790 --> 00:43:45,070
short on not short on time but we're

1047
00:43:45,070 --> 00:43:46,690
gonna be kind of cutting it close here

1048
00:43:46,690 --> 00:43:51,420
so what I would like to do is

1049
00:43:51,620 --> 00:43:56,390
get through to the Geezer section so now

1050
00:43:56,390 --> 00:44:00,620
that we've gone over what happens with

1051
00:44:00,620 --> 00:44:03,410
how x86 64 works and things like that

1052
00:44:03,410 --> 00:44:05,600
let's talk about you know

1053
00:44:05,600 --> 00:44:07,420
deidre in what we're going to use it for

1054
00:44:07,420 --> 00:44:12,140
so Deidre is an open source software

1055
00:44:12,140 --> 00:44:14,000
reverse engineering tool was developed

1056
00:44:14,000 --> 00:44:16,310
by NSA it was open sourced in March of

1057
00:44:16,310 --> 00:44:16,970
last year

1058
00:44:16,970 --> 00:44:19,520
it's Java based and again it's it's free

1059
00:44:19,520 --> 00:44:22,100
it's open source which makes it kind of

1060
00:44:22,100 --> 00:44:24,590
a big competitor in in the re tool

1061
00:44:24,590 --> 00:44:26,210
market there's lots of great reverse

1062
00:44:26,210 --> 00:44:27,830
engineering tools that exist

1063
00:44:27,830 --> 00:44:29,960
we're mainly focusing on deidre because

1064
00:44:29,960 --> 00:44:32,750
of all of the capabilities that it has

1065
00:44:32,750 --> 00:44:35,030
the fact that it's open source and so

1066
00:44:35,030 --> 00:44:37,430
guitro provides both a disassembler and

1067
00:44:37,430 --> 00:44:39,350
addy compiler we talked about this

1068
00:44:39,350 --> 00:44:41,210
assembly before and that's the process

1069
00:44:41,210 --> 00:44:44,780
of going from those byte codes back to

1070
00:44:44,780 --> 00:44:46,880
you know assembly language but deitrick

1071
00:44:46,880 --> 00:44:48,170
can take that a step further and

1072
00:44:48,170 --> 00:44:50,330
actually go from you know that assembly

1073
00:44:50,330 --> 00:44:52,270
language for what it actually represents

1074
00:44:52,270 --> 00:44:56,780
in terms of P code into like a pseudo C

1075
00:44:56,780 --> 00:44:58,250
code we'll take a look at that hair to

1076
00:44:58,250 --> 00:45:00,980
met and so you know it's actively

1077
00:45:00,980 --> 00:45:02,540
developed there's been lots of great

1078
00:45:02,540 --> 00:45:04,160
community contributions to it since its

1079
00:45:04,160 --> 00:45:07,550
released and in case anyone hasn't

1080
00:45:07,550 --> 00:45:09,290
installed it and followed the

1081
00:45:09,290 --> 00:45:10,760
instructions on the page we have a slide

1082
00:45:10,760 --> 00:45:14,620
here for how to you know install deidre

1083
00:45:14,620 --> 00:45:17,600
but I believe most of you probably

1084
00:45:17,600 --> 00:45:19,040
already followed the instructions that

1085
00:45:19,040 --> 00:45:20,930
are on the page if you haven't here's

1086
00:45:20,930 --> 00:45:22,310
the instructions for how to do it you

1087
00:45:22,310 --> 00:45:24,230
know manually it's fairly

1088
00:45:24,230 --> 00:45:25,550
straightforward to install all you need

1089
00:45:25,550 --> 00:45:26,900
to do is install make sure you have Java

1090
00:45:26,900 --> 00:45:30,190
11 that's the one they recommend and

1091
00:45:30,190 --> 00:45:32,480
based on whether you're on you know OS X

1092
00:45:32,480 --> 00:45:34,400
or Windows or Linux you run one of the

1093
00:45:34,400 --> 00:45:35,840
two launch scripts and then you can

1094
00:45:35,840 --> 00:45:38,030
launch deidre but you know let's get

1095
00:45:38,030 --> 00:45:41,000
into what you're gonna do once it's

1096
00:45:41,000 --> 00:45:44,930
launched so deidre groups binaries into

1097
00:45:44,930 --> 00:45:46,520
things called projects so maybe you're

1098
00:45:46,520 --> 00:45:48,140
looking at a game and you want to you

1099
00:45:48,140 --> 00:45:50,900
know keep it all organized projects can

1100
00:45:50,900 --> 00:45:53,900
be shared and there's also an idea of

1101
00:45:53,900 --> 00:45:55,580
version control with projects which is

1102
00:45:55,580 --> 00:45:57,170
very cool so if you're reversing

1103
00:45:57,170 --> 00:46:00,290
something with a friend or colleague you

1104
00:46:00,290 --> 00:46:02,819
can commit a change to

1105
00:46:02,819 --> 00:46:05,549
the project and then they can pull it

1106
00:46:05,549 --> 00:46:06,569
later so you get like a nice

1107
00:46:06,569 --> 00:46:08,039
collaborative versus engineering

1108
00:46:08,039 --> 00:46:10,890
environment going and so you know

1109
00:46:10,890 --> 00:46:12,660
programs and binaries can be imported

1110
00:46:12,660 --> 00:46:14,579
into a project and so to create a

1111
00:46:14,579 --> 00:46:16,979
project in Dedra what you're gonna do is

1112
00:46:16,979 --> 00:46:19,410
click on file and then new project and

1113
00:46:19,410 --> 00:46:21,689
for the purposes of this course you'll

1114
00:46:21,689 --> 00:46:23,489
be doing an on shared project a shared

1115
00:46:23,489 --> 00:46:25,169
project is one that requires you to run

1116
00:46:25,169 --> 00:46:28,079
you know teacher server and you can then

1117
00:46:28,079 --> 00:46:29,429
you know add collaborators and things

1118
00:46:29,429 --> 00:46:31,529
like that but for the purposes of this

1119
00:46:31,529 --> 00:46:33,689
course you can just name this project

1120
00:46:33,689 --> 00:46:36,869
hackaday you - feed you or whatever you

1121
00:46:36,869 --> 00:46:39,029
want to name it really and so what's

1122
00:46:39,029 --> 00:46:40,410
gonna happen is you're gonna be granted

1123
00:46:40,410 --> 00:46:43,589
with this window and so you select a

1124
00:46:43,589 --> 00:46:45,869
location for the project and then you

1125
00:46:45,869 --> 00:46:49,049
know add a project name it's gonna ask

1126
00:46:49,049 --> 00:46:51,179
you do you want a shared or non shared

1127
00:46:51,179 --> 00:46:53,579
project again for our purposes you can

1128
00:46:53,579 --> 00:46:55,919
just select non shared and you're gonna

1129
00:46:55,919 --> 00:46:57,989
be given this window so this is kind of

1130
00:46:57,989 --> 00:47:00,539
like the project management view and so

1131
00:47:00,539 --> 00:47:02,849
this is the hackaday you project but now

1132
00:47:02,849 --> 00:47:06,059
what we want to do is take this and load

1133
00:47:06,059 --> 00:47:08,309
a binary so we want to import a binary

1134
00:47:08,309 --> 00:47:11,640
into Deidre and so in order to do this

1135
00:47:11,640 --> 00:47:14,369
you can hit you go to file and then

1136
00:47:14,369 --> 00:47:16,619
import and what Deidre is gonna do for

1137
00:47:16,619 --> 00:47:18,299
you is it's gonna go through and try to

1138
00:47:18,299 --> 00:47:21,150
auto detect the file format so in our

1139
00:47:21,150 --> 00:47:22,739
case that's extremely useful because elf

1140
00:47:22,739 --> 00:47:24,630
is a well defined well understood file

1141
00:47:24,630 --> 00:47:27,839
format and so the import window will pop

1142
00:47:27,839 --> 00:47:29,999
up and we'll go through this both in an

1143
00:47:29,999 --> 00:47:32,369
exercise here in a moment and in

1144
00:47:32,369 --> 00:47:35,099
animations in the slides but Deidre is

1145
00:47:35,099 --> 00:47:37,319
going to you know attempt to auto detect

1146
00:47:37,319 --> 00:47:38,729
the information that it can from the

1147
00:47:38,729 --> 00:47:40,049
executable that you're trying to load

1148
00:47:40,049 --> 00:47:43,650
and determine everything that it can

1149
00:47:43,650 --> 00:47:46,679
based on the fields of that file so what

1150
00:47:46,679 --> 00:47:48,509
that looks like is you'll select a file

1151
00:47:48,509 --> 00:47:50,609
so example maybe you're gonna load the

1152
00:47:50,609 --> 00:47:53,359
crackme one from the git repo

1153
00:47:53,359 --> 00:47:56,159
you're gonna import it and Ghidorah can

1154
00:47:56,159 --> 00:47:57,900
already say like oh this is an elf file

1155
00:47:57,900 --> 00:48:00,029
at first it was compiled for 64-bit

1156
00:48:00,029 --> 00:48:02,329
looks like it was compiled with GCC and

1157
00:48:02,329 --> 00:48:05,190
so then you click OK

1158
00:48:05,190 --> 00:48:07,290
and you'll be greeted with you know the

1159
00:48:07,290 --> 00:48:10,349
result of importing the file and so

1160
00:48:10,349 --> 00:48:12,390
there's basically here it's talking

1161
00:48:12,390 --> 00:48:14,430
about some information that it you know

1162
00:48:14,430 --> 00:48:16,980
read from the elf file etc and now like

1163
00:48:16,980 --> 00:48:19,050
this file has been imported into kitra

1164
00:48:19,050 --> 00:48:22,550
and you'll see this in the project view

1165
00:48:22,550 --> 00:48:27,300
and so now if you want to load the code

1166
00:48:27,300 --> 00:48:30,780
browser and analyze it you will double

1167
00:48:30,780 --> 00:48:32,490
click on that program and then you'll

1168
00:48:32,490 --> 00:48:34,800
see like a green dragon pop-up and it'll

1169
00:48:34,800 --> 00:48:37,589
open the code browser window and so he

1170
00:48:37,589 --> 00:48:39,359
drew can attempt to auto analyze the

1171
00:48:39,359 --> 00:48:41,339
binary which again information when the

1172
00:48:41,339 --> 00:48:43,200
elf file tells it oh hey this address

1173
00:48:43,200 --> 00:48:45,450
this is where the program starts and so

1174
00:48:45,450 --> 00:48:48,180
kitra will go through and you know try

1175
00:48:48,180 --> 00:48:49,950
to disassemble everything automatically

1176
00:48:49,950 --> 00:48:52,079
create and label any functions it might

1177
00:48:52,079 --> 00:48:54,510
find things like that and so when you

1178
00:48:54,510 --> 00:48:57,060
double-click on the program you're gonna

1179
00:48:57,060 --> 00:48:59,760
be greeted with this and so this is kind

1180
00:48:59,760 --> 00:49:01,319
of the code browser window this is where

1181
00:49:01,319 --> 00:49:02,520
you're gonna be spending a lot of your

1182
00:49:02,520 --> 00:49:05,730
time and you're gonna get a window that

1183
00:49:05,730 --> 00:49:07,290
says hey this hasn't analyzed would you

1184
00:49:07,290 --> 00:49:09,420
like to analyze it now so you're gonna

1185
00:49:09,420 --> 00:49:11,099
quickly yes unless you don't want to

1186
00:49:11,099 --> 00:49:12,510
reverse engineer it and you could click

1187
00:49:12,510 --> 00:49:15,119
the oh I suppose and it's gonna bring up

1188
00:49:15,119 --> 00:49:16,589
you know a bunch of analysis options

1189
00:49:16,589 --> 00:49:18,540
here so there are things to try to

1190
00:49:18,540 --> 00:49:20,640
aggressively find instructions there's I

1191
00:49:20,640 --> 00:49:22,829
know someone talked about finding like

1192
00:49:22,829 --> 00:49:24,180
embedded or encrypted data there's

1193
00:49:24,180 --> 00:49:27,060
plugins to do that here and so once you

1194
00:49:27,060 --> 00:49:28,890
click analyze feature is gonna go

1195
00:49:28,890 --> 00:49:31,280
through and it's going to take the

1196
00:49:31,280 --> 00:49:33,900
excuse me the bytecode that it sees and

1197
00:49:33,900 --> 00:49:35,760
try to disassemble that and generate you

1198
00:49:35,760 --> 00:49:37,190
know assembly instructions from that and

1199
00:49:37,190 --> 00:49:39,210
then in addition to that it also

1200
00:49:39,210 --> 00:49:40,770
generates its intermediate

1201
00:49:40,770 --> 00:49:43,200
representation that's known as P code

1202
00:49:43,200 --> 00:49:45,270
and it uses that to generate D compiler

1203
00:49:45,270 --> 00:49:47,160
output but we'll talk about that you

1204
00:49:47,160 --> 00:49:50,099
know later on so you know once you've

1205
00:49:50,099 --> 00:49:51,960
clicked analyze and it's running it's

1206
00:49:51,960 --> 00:49:54,150
doing its thing you get like the main

1207
00:49:54,150 --> 00:49:56,339
program window open and now you can

1208
00:49:56,339 --> 00:50:00,780
start to explore and dig around and the

1209
00:50:00,780 --> 00:50:02,250
these slides are kind of meant to be a

1210
00:50:02,250 --> 00:50:04,140
reference for you later on so that when

1211
00:50:04,140 --> 00:50:06,300
you're looking at the exercises engage

1212
00:50:06,300 --> 00:50:08,400
where you can kind of be aware of what's

1213
00:50:08,400 --> 00:50:10,170
available to you and so you've got the

1214
00:50:10,170 --> 00:50:12,300
program tree that shows the segments

1215
00:50:12,300 --> 00:50:14,069
that it found for the elf file the

1216
00:50:14,069 --> 00:50:15,599
symbol tree which grabs some of the

1217
00:50:15,599 --> 00:50:17,490
symbols that may have found things like

1218
00:50:17,490 --> 00:50:18,910
the datatype manager

1219
00:50:18,910 --> 00:50:21,069
it show you know the different types of

1220
00:50:21,069 --> 00:50:23,589
the actual different you know data types

1221
00:50:23,589 --> 00:50:26,349
used during analysis the listing which

1222
00:50:26,349 --> 00:50:27,880
is gonna show the assembly code and then

1223
00:50:27,880 --> 00:50:30,010
you have the console for you know tool

1224
00:50:30,010 --> 00:50:33,730
output and things like that so this is

1225
00:50:33,730 --> 00:50:35,380
what the program tree looks like again

1226
00:50:35,380 --> 00:50:37,569
you'll see we have segments from the elf

1227
00:50:37,569 --> 00:50:39,849
file that are loaded in here the symbol

1228
00:50:39,849 --> 00:50:41,619
tree which is kind of kind of be our

1229
00:50:41,619 --> 00:50:43,359
starting point every time we look at a

1230
00:50:43,359 --> 00:50:44,920
binary in this class you're gonna look

1231
00:50:44,920 --> 00:50:47,079
at the symbol tree and click on main to

1232
00:50:47,079 --> 00:50:49,119
navigate to the the main function or the

1233
00:50:49,119 --> 00:50:51,940
main entry point of the binary the data

1234
00:50:51,940 --> 00:50:53,470
type manager if you have you know a

1235
00:50:53,470 --> 00:50:54,760
custom data type that you need to

1236
00:50:54,760 --> 00:50:56,380
implement things like that this is where

1237
00:50:56,380 --> 00:50:58,240
you would do that we're not gonna do

1238
00:50:58,240 --> 00:51:02,950
that maybe until lesson 4 but it's you

1239
00:51:02,950 --> 00:51:04,569
know it's a window that's useful when

1240
00:51:04,569 --> 00:51:06,190
you need to use it and so and then this

1241
00:51:06,190 --> 00:51:08,309
is you know the the listing this is the

1242
00:51:08,309 --> 00:51:10,930
disassembly view that you're gonna spend

1243
00:51:10,930 --> 00:51:14,980
a lot of time and so this disassembly

1244
00:51:14,980 --> 00:51:16,869
view is where you know the resulting

1245
00:51:16,869 --> 00:51:18,549
assembly code that's been generated can

1246
00:51:18,549 --> 00:51:20,530
be displayed and you can actually edit

1247
00:51:20,530 --> 00:51:21,760
the way this looks by clicking on this

1248
00:51:21,760 --> 00:51:25,119
symbol here and change what's displayed

1249
00:51:25,119 --> 00:51:26,950
into listing and so we have an example

1250
00:51:26,950 --> 00:51:29,740
of that here so here's our main function

1251
00:51:29,740 --> 00:51:32,680
that we've jumped to and we have the

1252
00:51:32,680 --> 00:51:34,450
address or the virtual address that this

1253
00:51:34,450 --> 00:51:35,920
instruction is that again this is

1254
00:51:35,920 --> 00:51:39,609
grabbed from the elf file the raw byte

1255
00:51:39,609 --> 00:51:41,440
that represents this instruction so this

1256
00:51:41,440 --> 00:51:43,420
is the machine code right this is the

1257
00:51:43,420 --> 00:51:46,569
raw byte we have then the instruction

1258
00:51:46,569 --> 00:51:49,599
mnemonic here or you know the speed may

1259
00:51:49,599 --> 00:51:51,789
be the opcode and then the register that

1260
00:51:51,789 --> 00:51:54,940
it's operating on and so this is kind of

1261
00:51:54,940 --> 00:51:56,829
the core piece of the the listing view

1262
00:51:56,829 --> 00:51:58,539
in the disassembly view and then you

1263
00:51:58,539 --> 00:52:00,339
also see something called xrefs that

1264
00:52:00,339 --> 00:52:02,109
stands for is a cross reference so this

1265
00:52:02,109 --> 00:52:04,839
is Dedra detecting oh hey something else

1266
00:52:04,839 --> 00:52:06,180
is referenced this memory location

1267
00:52:06,180 --> 00:52:08,559
because it you know it understands

1268
00:52:08,559 --> 00:52:11,319
enough of the syntax is to generate

1269
00:52:11,319 --> 00:52:13,900
these cross references when memory

1270
00:52:13,900 --> 00:52:17,090
locations are used or referenced

1271
00:52:17,090 --> 00:52:19,580
and so the next thing that the most

1272
00:52:19,580 --> 00:52:21,260
powerful feature with engage a that will

1273
00:52:21,260 --> 00:52:23,120
learn how to use is the D compiler and

1274
00:52:23,120 --> 00:52:26,630
so if the assembly code was kind of

1275
00:52:26,630 --> 00:52:28,070
uncomfortable for you to read a major

1276
00:52:28,070 --> 00:52:28,940
slightly uncomfortable

1277
00:52:28,940 --> 00:52:30,830
deidre actually has a D compiler that

1278
00:52:30,830 --> 00:52:33,890
can take that assembly code and generate

1279
00:52:33,890 --> 00:52:36,710
you know pseudo C code from that and so

1280
00:52:36,710 --> 00:52:39,410
it's not just to be clear and for those

1281
00:52:39,410 --> 00:52:43,040
the pedants out there the the C code is

1282
00:52:43,040 --> 00:52:45,980
actually generated from P code which is

1283
00:52:45,980 --> 00:52:48,070
Deidre's intermediate representation of

1284
00:52:48,070 --> 00:52:51,410
the instruction set and we can get into

1285
00:52:51,410 --> 00:52:53,090
that later or in office hours if people

1286
00:52:53,090 --> 00:52:54,440
have more instruct or more questions

1287
00:52:54,440 --> 00:52:57,860
about it but essentially the d compiler

1288
00:52:57,860 --> 00:53:00,230
is able to generate C code from the

1289
00:53:00,230 --> 00:53:02,990
analysis that feature is done and so if

1290
00:53:02,990 --> 00:53:06,080
we have this assembly code which might

1291
00:53:06,080 --> 00:53:07,880
look cumbersome to some of you maybe you

1292
00:53:07,880 --> 00:53:09,200
haven't worked with something like this

1293
00:53:09,200 --> 00:53:11,360
before you know it certainly doesn't

1294
00:53:11,360 --> 00:53:13,880
look fun to read the D compiler will

1295
00:53:13,880 --> 00:53:16,370
take that and give you this which if

1296
00:53:16,370 --> 00:53:17,870
you're a reverse engineer this is

1297
00:53:17,870 --> 00:53:19,580
extremely powerful because now you've

1298
00:53:19,580 --> 00:53:22,130
gone from looking at assembly code to

1299
00:53:22,130 --> 00:53:24,440
you know D compiled code this is kind of

1300
00:53:24,440 --> 00:53:27,170
the core sort of selling point of deidre

1301
00:53:27,170 --> 00:53:29,270
and we're gonna learn how to approach a

1302
00:53:29,270 --> 00:53:31,070
binary from from both angles we're gonna

1303
00:53:31,070 --> 00:53:32,630
look at assembly we're gonna look at the

1304
00:53:32,630 --> 00:53:36,110
compiled output and we're gonna kind of

1305
00:53:36,110 --> 00:53:37,550
make sure we have an understanding of

1306
00:53:37,550 --> 00:53:38,960
how to use both because you don't want

1307
00:53:38,960 --> 00:53:40,790
to always rely on the D compiler but it

1308
00:53:40,790 --> 00:53:42,650
is extremely powerful as you can see

1309
00:53:42,650 --> 00:53:46,910
here so gauge also has a bite view so if

1310
00:53:46,910 --> 00:53:48,050
you want to see you know the raw bytes

1311
00:53:48,050 --> 00:53:50,090
that are generated outside of the

1312
00:53:50,090 --> 00:53:52,400
assembly listing you can do that and you

1313
00:53:52,400 --> 00:53:54,020
can also you know synchronize it so that

1314
00:53:54,020 --> 00:53:55,820
they line up and when you highlight an

1315
00:53:55,820 --> 00:53:57,290
instruction here you'll see that it

1316
00:53:57,290 --> 00:53:59,289
jumps over here

1317
00:53:59,289 --> 00:54:01,640
and there's a handful of other views I

1318
00:54:01,640 --> 00:54:03,199
mean there's lots we'll get into more of

1319
00:54:03,199 --> 00:54:04,459
the views you know later on in the

1320
00:54:04,459 --> 00:54:06,469
course but you have the defined strings

1321
00:54:06,469 --> 00:54:09,829
that it finds you have you know defined

1322
00:54:09,829 --> 00:54:11,689
data types that have found things like

1323
00:54:11,689 --> 00:54:12,979
that you know you see there's some

1324
00:54:12,979 --> 00:54:14,749
strings in there from the D compilation

1325
00:54:14,749 --> 00:54:16,630
example that we were looking at and

1326
00:54:16,630 --> 00:54:20,119
you've got the function call tree which

1327
00:54:20,119 --> 00:54:21,890
is pretty interesting so this shows you

1328
00:54:21,890 --> 00:54:24,909
know okay from Maine I call you know

1329
00:54:24,909 --> 00:54:28,369
turtle and puts and so it's kind of cool

1330
00:54:28,369 --> 00:54:29,899
to be able to see you know what

1331
00:54:29,899 --> 00:54:31,459
functions are called from your main

1332
00:54:31,459 --> 00:54:34,009
function and so all of these are you

1333
00:54:34,009 --> 00:54:36,169
know available to you you know in

1334
00:54:36,169 --> 00:54:39,649
giedrius but you know how do you how do

1335
00:54:39,649 --> 00:54:41,149
you navigate once you're in there once

1336
00:54:41,149 --> 00:54:43,039
you're in the listing view so you can

1337
00:54:43,039 --> 00:54:44,599
you can scroll through the listing view

1338
00:54:44,599 --> 00:54:46,279
you can use the arrow keys you know it's

1339
00:54:46,279 --> 00:54:48,229
it's fairly intuitive of how you

1340
00:54:48,229 --> 00:54:50,449
navigate and then when you're looking at

1341
00:54:50,449 --> 00:54:52,399
those xrefs that we talked about earlier

1342
00:54:52,399 --> 00:54:53,809
you can double click on that and it'll

1343
00:54:53,809 --> 00:54:55,819
jump to the location that's referencing

1344
00:54:55,819 --> 00:54:58,130
it and you can also jump to a particular

1345
00:54:58,130 --> 00:55:01,369
location of memory by pressing the G key

1346
00:55:01,369 --> 00:55:07,399
and so with all that we've generated you

1347
00:55:07,399 --> 00:55:09,049
know challenge binaries for this course

1348
00:55:09,049 --> 00:55:11,479
and each of these was kind of developed

1349
00:55:11,479 --> 00:55:13,519
to kind of highlight the deidre features

1350
00:55:13,519 --> 00:55:15,079
that we talked about as well as the x86

1351
00:55:15,079 --> 00:55:16,759
64 features that we're going to talk

1352
00:55:16,759 --> 00:55:18,739
about because as the exercises get more

1353
00:55:18,739 --> 00:55:22,099
complex so are the challenges and we're

1354
00:55:22,099 --> 00:55:23,509
gonna review these during office hours

1355
00:55:23,509 --> 00:55:25,549
the page is up and active and will

1356
00:55:25,549 --> 00:55:26,959
respond as best we can to people's

1357
00:55:26,959 --> 00:55:29,719
queries on the page and then I think the

1358
00:55:29,719 --> 00:55:31,549
plan is probably on Wednesday to release

1359
00:55:31,549 --> 00:55:33,499
maybe an advanced challenge for those

1360
00:55:33,499 --> 00:55:35,989
that are maybe ahead of the course and

1361
00:55:35,989 --> 00:55:38,779
so we have about five minutes left on

1362
00:55:38,779 --> 00:55:41,239
the timer here and so what I'd like to

1363
00:55:41,239 --> 00:55:43,759
do is walk you through how to load

1364
00:55:43,759 --> 00:55:47,179
exercise c1 and he drew and how you

1365
00:55:47,179 --> 00:55:49,909
might navigate that so let's go ahead

1366
00:55:49,909 --> 00:55:52,639
and do that so if you haven't downloaded

1367
00:55:52,639 --> 00:55:54,679
the exercises go ahead and do that from

1368
00:55:54,679 --> 00:55:55,069
github

1369
00:55:55,069 --> 00:55:57,769
it's the link is there it's also up on

1370
00:55:57,769 --> 00:55:59,809
the page this repository is gonna hold

1371
00:55:59,809 --> 00:56:01,429
all the materials for the course and the

1372
00:56:01,429 --> 00:56:03,319
plan is you know before session two

1373
00:56:03,319 --> 00:56:04,369
we're gonna upload it with this

1374
00:56:04,369 --> 00:56:06,529
exercises from session two same for

1375
00:56:06,529 --> 00:56:09,259
three and four and you'll be able to

1376
00:56:09,259 --> 00:56:10,690
pull that down whenever you want

1377
00:56:10,690 --> 00:56:13,060
so if you have you know things you would

1378
00:56:13,060 --> 00:56:15,160
like to see in it I'm not opposed to

1379
00:56:15,160 --> 00:56:17,260
pull requests and things like that but

1380
00:56:17,260 --> 00:56:19,680
so let's let's get out a PowerPoint and

1381
00:56:19,680 --> 00:56:22,510
let's load this binary into gear and see

1382
00:56:22,510 --> 00:56:24,870
what it's doing

1383
00:56:24,870 --> 00:56:31,500
so I have a heater project here and what

1384
00:56:31,500 --> 00:56:36,060
I'm gonna do is so we can start from

1385
00:56:36,060 --> 00:56:38,940
square one we have our Gager project is

1386
00:56:38,940 --> 00:56:39,750
called hackaday

1387
00:56:39,750 --> 00:56:44,460
I'm gonna go file import file and then I

1388
00:56:44,460 --> 00:56:46,110
have the exercises here that I've pulled

1389
00:56:46,110 --> 00:56:48,720
from the repo and so let's load up c1

1390
00:56:48,720 --> 00:56:55,920
challenge one we can see here that that

1391
00:56:55,920 --> 00:57:00,690
the that Deidre has already two figured

1392
00:57:00,690 --> 00:57:02,100
out you know the format it's telling us

1393
00:57:02,100 --> 00:57:04,170
though its 64-bit x86 looks like it was

1394
00:57:04,170 --> 00:57:06,000
compiled with GCC and they are a hundred

1395
00:57:06,000 --> 00:57:09,030
percent correct and so you can name it

1396
00:57:09,030 --> 00:57:10,200
something different if you wanted to

1397
00:57:10,200 --> 00:57:12,090
look something different in the program

1398
00:57:12,090 --> 00:57:14,940
view so we'll just call it challenge one

1399
00:57:14,940 --> 00:57:18,780
and then again here's the results of it

1400
00:57:18,780 --> 00:57:22,980
being imported and now that we're here

1401
00:57:22,980 --> 00:57:25,230
double click on this or we can click

1402
00:57:25,230 --> 00:57:31,290
here of course it loads halfway on the

1403
00:57:31,290 --> 00:57:36,300
other monitor and so it asked me if I

1404
00:57:36,300 --> 00:57:38,160
wanted to analyze I clicked yes and then

1405
00:57:38,160 --> 00:57:40,680
I clicked analyze so here we are we're

1406
00:57:40,680 --> 00:57:43,710
in this listing view the first thing you

1407
00:57:43,710 --> 00:57:45,630
want to do with these challenges is go

1408
00:57:45,630 --> 00:57:47,850
to the functions tab here in the symbol

1409
00:57:47,850 --> 00:57:50,250
tree so this is gonna tell us you know

1410
00:57:50,250 --> 00:57:52,320
the imports the exports the functions

1411
00:57:52,320 --> 00:57:54,690
that it's able to find and we're gonna

1412
00:57:54,690 --> 00:57:55,980
jump straight to make because if you've

1413
00:57:55,980 --> 00:57:57,720
written C code you understand that you

1414
00:57:57,720 --> 00:58:00,660
know main is the entry point for you

1415
00:58:00,660 --> 00:58:02,310
know an executor was defined by the e

1416
00:58:02,310 --> 00:58:05,230
API and so

1417
00:58:05,230 --> 00:58:07,119
before looking at any of this because

1418
00:58:07,119 --> 00:58:09,760
this gives it away we can look at the

1419
00:58:09,760 --> 00:58:11,830
assembly here and you'll see that we

1420
00:58:11,830 --> 00:58:14,650
have you know it's setting up this we're

1421
00:58:14,650 --> 00:58:18,280
setting up the stack here and this is

1422
00:58:18,280 --> 00:58:20,650
setting up the environment variables are

1423
00:58:20,650 --> 00:58:22,480
the variables that are maybe passed into

1424
00:58:22,480 --> 00:58:24,790
the C program setting these up as local

1425
00:58:24,790 --> 00:58:27,550
variables on the stack but we're gonna

1426
00:58:27,550 --> 00:58:29,380
get into doing kind of more you know

1427
00:58:29,380 --> 00:58:31,660
detailed analysis of these during during

1428
00:58:31,660 --> 00:58:33,130
the office hours and we're gonna kind of

1429
00:58:33,130 --> 00:58:35,740
walk through exactly how these work but

1430
00:58:35,740 --> 00:58:38,380
from an extremely high level if you know

1431
00:58:38,380 --> 00:58:39,820
you were to look at just this assembly

1432
00:58:39,820 --> 00:58:42,400
for a second you can see that it's

1433
00:58:42,400 --> 00:58:44,470
grabbing a string here it's loading the

1434
00:58:44,470 --> 00:58:46,710
address le a is load effective address

1435
00:58:46,710 --> 00:58:49,390
it's loading the address of what looks

1436
00:58:49,390 --> 00:58:51,670
like this string so if we double click

1437
00:58:51,670 --> 00:58:54,730
this we jump down here to a string that

1438
00:58:54,730 --> 00:58:57,280
says please supply the password okay

1439
00:58:57,280 --> 00:59:00,369
well we go back to where we came from by

1440
00:59:00,369 --> 00:59:02,470
clicking the xref from that and then we

1441
00:59:02,470 --> 00:59:05,500
call the puts function and so even

1442
00:59:05,500 --> 00:59:07,030
without you know a detailed

1443
00:59:07,030 --> 00:59:08,500
understanding of how a function calls

1444
00:59:08,500 --> 00:59:09,910
are implemented you can probably assume

1445
00:59:09,910 --> 00:59:12,670
that what this is gonna do is print out

1446
00:59:12,670 --> 00:59:15,550
you know please supply the password via

1447
00:59:15,550 --> 00:59:17,380
the puts function and again if you're

1448
00:59:17,380 --> 00:59:18,790
looking over here you can see that

1449
00:59:18,790 --> 00:59:25,330
that's exactly what it's gonna do so we

1450
00:59:25,330 --> 00:59:28,480
then you know the puts the puts call

1451
00:59:28,480 --> 00:59:31,530
occurs and then here we've got a call to

1452
00:59:31,530 --> 00:59:35,140
you know string length and it looks like

1453
00:59:35,140 --> 00:59:36,900
it's just calling it with the string

1454
00:59:36,900 --> 00:59:40,630
hackaday you and so we can again we can

1455
00:59:40,630 --> 00:59:42,490
look at this memory address and see

1456
00:59:42,490 --> 00:59:44,859
what's there we have this string Hackett

1457
00:59:44,859 --> 00:59:47,740
at U and we can see here in these xrefs

1458
00:59:47,740 --> 00:59:49,060
that it's actually referenced multiple

1459
00:59:49,060 --> 00:59:51,580
times throughout this program and so

1460
00:59:51,580 --> 00:59:52,690
let's jump back to the main function

1461
00:59:52,690 --> 00:59:55,950
where we came from so it's grabbing

1462
00:59:55,950 --> 00:59:58,210
presumably we're grabbing the length of

1463
00:59:58,210 --> 01:00:00,040
this string here right so even without

1464
01:00:00,040 --> 01:00:03,280
knowing you know the the e ABI which

1465
01:00:03,280 --> 01:00:05,560
we're gonna get into in the next kind of

1466
01:00:05,560 --> 01:00:07,660
the next lesson in during the office

1467
01:00:07,660 --> 01:00:09,940
hours we can assume we're calling string

1468
01:00:09,940 --> 01:00:12,190
length here on the hackaday u string and

1469
01:00:12,190 --> 01:00:13,540
again if you're looking at the d

1470
01:00:13,540 --> 01:00:15,100
compiler output you can see that that's

1471
01:00:15,100 --> 01:00:15,910
true

1472
01:00:15,910 --> 01:00:18,460
and so next you can see that we're

1473
01:00:18,460 --> 01:00:21,069
grabbing some variable here and we're

1474
01:00:21,069 --> 01:00:23,470
storing it in our ax and then we're

1475
01:00:23,470 --> 01:00:25,480
dereferencing that variable with another

1476
01:00:25,480 --> 01:00:26,950
move instruction and storing that back

1477
01:00:26,950 --> 01:00:32,579
into our ax and then we're storing into

1478
01:00:32,579 --> 01:00:35,980
you know RSI another variable here and

1479
01:00:35,980 --> 01:00:40,450
calling string compare so what we're

1480
01:00:40,450 --> 01:00:42,190
seeing here is that we're taking this

1481
01:00:42,190 --> 01:00:45,400
packet au string and we're comparing it

1482
01:00:45,400 --> 01:00:48,819
with some other string right and we'll

1483
01:00:48,819 --> 01:00:50,710
get into more in more detail how we can

1484
01:00:50,710 --> 01:00:52,000
tell what the string is during the

1485
01:00:52,000 --> 01:00:54,130
office hour but it's a pretty safe

1486
01:00:54,130 --> 01:00:56,289
assumption that this string that's being

1487
01:00:56,289 --> 01:00:58,059
compared against it right is our you

1488
01:00:58,059 --> 01:01:01,990
know password string and so after this

1489
01:01:01,990 --> 01:01:04,180
is called so we call string compare on

1490
01:01:04,180 --> 01:01:08,740
both you know the packet au string and

1491
01:01:08,740 --> 01:01:10,630
then whatever's in this local variable

1492
01:01:10,630 --> 01:01:15,220
here we check the return code for the

1493
01:01:15,220 --> 01:01:16,809
call instruction because the return code

1494
01:01:16,809 --> 01:01:20,260
is stored in EAX for this instruction

1495
01:01:20,260 --> 01:01:24,130
and then depending on whether it's the

1496
01:01:24,130 --> 01:01:28,240
or not we jump to either printing we can

1497
01:01:28,240 --> 01:01:29,710
see here if we look in the d compiler

1498
01:01:29,710 --> 01:01:30,160
output

1499
01:01:30,160 --> 01:01:36,280
you know correct or wrong answer and so

1500
01:01:36,280 --> 01:01:38,170
fairly straightforward if you sit down

1501
01:01:38,170 --> 01:01:40,720
we know what the Intel manual you can go

1502
01:01:40,720 --> 01:01:41,980
through and figure out exactly what each

1503
01:01:41,980 --> 01:01:43,450
of these instructions is doing and it's

1504
01:01:43,450 --> 01:01:44,950
it's important to do that so that's

1505
01:01:44,950 --> 01:01:48,180
something you want to do before the

1506
01:01:48,180 --> 01:01:50,440
office hours if you can or just before

1507
01:01:50,440 --> 01:01:52,150
you know the session next weekend will

1508
01:01:52,150 --> 01:01:54,310
be available on the course page to talk

1509
01:01:54,310 --> 01:01:56,770
to you about it things like that but you

1510
01:01:56,770 --> 01:01:58,690
know looking over at the decompiler view

1511
01:01:58,690 --> 01:02:01,930
it's pretty clear what this program is

1512
01:02:01,930 --> 01:02:09,050
doing right so if you provide a password

1513
01:02:09,050 --> 01:02:11,630
it does a string compare on it and then

1514
01:02:11,630 --> 01:02:14,030
if that string compare if it's equal to

1515
01:02:14,030 --> 01:02:16,940
hackaday you we print correct otherwise

1516
01:02:16,940 --> 01:02:19,850
we print wrong answer and so the the

1517
01:02:19,850 --> 01:02:21,680
purpose of this was and we can we can

1518
01:02:21,680 --> 01:02:23,360
verify that right so if we run that

1519
01:02:23,360 --> 01:02:24,650
program and those of you that were

1520
01:02:24,650 --> 01:02:26,090
paying attention price saw that I had

1521
01:02:26,090 --> 01:02:28,250
the answers up already but if we run

1522
01:02:28,250 --> 01:02:31,700
that program with no arguments it says

1523
01:02:31,700 --> 01:02:33,860
please supply the password alright well

1524
01:02:33,860 --> 01:02:35,690
let's compare that with our D compiler

1525
01:02:35,690 --> 01:02:37,850
output here so we're checking whatever

1526
01:02:37,850 --> 01:02:39,980
this parameter is whatever this is and

1527
01:02:39,980 --> 01:02:43,370
if it's equal to two we execute this

1528
01:02:43,370 --> 01:02:45,320
block of code you can see that when we

1529
01:02:45,320 --> 01:02:47,930
highlight the bracket here it shows us

1530
01:02:47,930 --> 01:02:50,870
the closing bracket so if taking what

1531
01:02:50,870 --> 01:02:53,360
you might know about C code it's

1532
01:02:53,360 --> 01:02:55,490
probably it could be checking any number

1533
01:02:55,490 --> 01:02:56,900
of things but it there's a good chance

1534
01:02:56,900 --> 01:02:58,880
that it's checking you know Arg C or the

1535
01:02:58,880 --> 01:03:01,040
argument count so let's find out if we

1536
01:03:01,040 --> 01:03:05,090
just do C one testing

1537
01:03:05,090 --> 01:03:06,830
okay we're set wrong answer we'd never

1538
01:03:06,830 --> 01:03:09,020
use and then you see we have the format

1539
01:03:09,020 --> 01:03:11,240
string percent s followed by this local

1540
01:03:11,240 --> 01:03:14,030
variable so this local variable is our

1541
01:03:14,030 --> 01:03:16,670
password right so this parameter two

1542
01:03:16,670 --> 01:03:19,250
plus eight is pointing to our password

1543
01:03:19,250 --> 01:03:20,960
and that is indeed what's getting passed

1544
01:03:20,960 --> 01:03:23,330
to the string compare that's comparing

1545
01:03:23,330 --> 01:03:25,730
it with hackaday you so let's see what

1546
01:03:25,730 --> 01:03:28,400
happens when we run c1 hackaday you I

1547
01:03:28,400 --> 01:03:30,140
think everybody can probably guess

1548
01:03:30,140 --> 01:03:32,060
what's gonna happen here this is correct

1549
01:03:32,060 --> 01:03:35,090
the password was the whole time and so I

1550
01:03:35,090 --> 01:03:37,670
know we're about out of time here

1551
01:03:37,670 --> 01:03:42,290
so exercise c2 if people want to load

1552
01:03:42,290 --> 01:03:44,240
that up and take a look at it I'll be

1553
01:03:44,240 --> 01:03:46,280
available to talk about it we there's

1554
01:03:46,280 --> 01:03:47,990
the chatroom on the court pay on the

1555
01:03:47,990 --> 01:03:50,180
course page and we can kind of go over

1556
01:03:50,180 --> 01:03:53,030
that if people want and run this

1557
01:03:53,030 --> 01:03:54,620
application see what it's doing

1558
01:03:54,620 --> 01:03:56,690
differently and and see what it's doing

1559
01:03:56,690 --> 01:03:58,250
and figure out if you can determine what

1560
01:03:58,250 --> 01:03:59,750
you know kind of password it might be

1561
01:03:59,750 --> 01:04:03,440
looking for and so to finally wrap

1562
01:04:03,440 --> 01:04:05,450
things all up today what we covered was

1563
01:04:05,450 --> 01:04:07,310
quite a bit so I apologize if we went

1564
01:04:07,310 --> 01:04:09,410
over a little bit here but we covered

1565
01:04:09,410 --> 01:04:11,720
you know the basic x86 instructions we

1566
01:04:11,720 --> 01:04:14,150
covered how old software is built from

1567
01:04:14,150 --> 01:04:16,370
an extremely high level we went over you

1568
01:04:16,370 --> 01:04:18,080
know some common Geezer features then we

1569
01:04:18,080 --> 01:04:20,150
talked about how to navigate and use

1570
01:04:20,150 --> 01:04:23,660
deidre and the office hours are gonna be

1571
01:04:23,660 --> 01:04:25,730
more of what we just did of us loading

1572
01:04:25,730 --> 01:04:27,350
up deidre together and walking through

1573
01:04:27,350 --> 01:04:29,510
these exercises and getting more of you

1574
01:04:29,510 --> 01:04:31,160
know that hands-on experience and so

1575
01:04:31,160 --> 01:04:32,540
were the rest of the lectures this one

1576
01:04:32,540 --> 01:04:35,870
was definitely the most you know text

1577
01:04:35,870 --> 01:04:38,240
and kind of the most info so my

1578
01:04:38,240 --> 01:04:39,950
apologies if it felt like a fire hose of

1579
01:04:39,950 --> 01:04:41,210
information there was just a lot of

1580
01:04:41,210 --> 01:04:42,740
ground to cover to make sure everybody

1581
01:04:42,740 --> 01:04:46,040
was on the same page and if you have any

1582
01:04:46,040 --> 01:04:47,420
questions about what we talked about

1583
01:04:47,420 --> 01:04:50,480
feel free to message me on the page you

1584
01:04:50,480 --> 01:04:51,970
know no stupid questions here

1585
01:04:51,970 --> 01:04:53,480
everybody's coming from different

1586
01:04:53,480 --> 01:04:54,920
backgrounds so whatever questions you

1587
01:04:54,920 --> 01:04:56,960
may have let them rip and we'll do what

1588
01:04:56,960 --> 01:05:01,300
we can to you know fill those gaps

