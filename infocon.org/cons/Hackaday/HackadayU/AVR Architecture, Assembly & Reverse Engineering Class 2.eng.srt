1
00:00:00,000 --> 00:00:06,660
[Music]

2
00:00:07,600 --> 00:00:10,320
hey everybody and welcome back to the

3
00:00:10,320 --> 00:00:13,519
uh avr architecture assembly and reverse

4
00:00:13,519 --> 00:00:15,839
engineering class this is our second

5
00:00:15,839 --> 00:00:17,920
session and i'm glad to have you back

6
00:00:17,920 --> 00:00:19,119
here um

7
00:00:19,119 --> 00:00:21,520
i got some feedback uh on the first

8
00:00:21,520 --> 00:00:23,119
session and i really appreciate your

9
00:00:23,119 --> 00:00:24,320
feedback so

10
00:00:24,320 --> 00:00:25,840
if you have a chance at the end of the

11
00:00:25,840 --> 00:00:28,400
session just drop me a line

12
00:00:28,400 --> 00:00:31,679
um just like the last time i will be

13
00:00:31,679 --> 00:00:32,320
using

14
00:00:32,320 --> 00:00:35,440
uh this shared document to share links

15
00:00:35,440 --> 00:00:36,000
and the

16
00:00:36,000 --> 00:00:39,040
thoughts uh there is a second a new page

17
00:00:39,040 --> 00:00:40,079
in the documents

18
00:00:40,079 --> 00:00:42,320
uh with the title cluster links and

19
00:00:42,320 --> 00:00:43,520
resources

20
00:00:43,520 --> 00:00:46,719
so uh i will be posting their links so

21
00:00:46,719 --> 00:00:49,120
uh you can find the link to the uh

22
00:00:49,120 --> 00:00:50,399
document

23
00:00:50,399 --> 00:00:53,840
inside the uh chat of the zoom and there

24
00:00:53,840 --> 00:00:55,680
is somebody who can't hear me

25
00:00:55,680 --> 00:00:58,640
uh i i just want to confirm that it's

26
00:00:58,640 --> 00:01:00,879
not everybody who can hear me only mr

27
00:01:00,879 --> 00:01:02,000
nello

28
00:01:02,000 --> 00:01:05,119
um can hear you just fine

29
00:01:05,119 --> 00:01:09,119
okay thank you so uh i'm really sorry

30
00:01:09,119 --> 00:01:12,159
um mr um nello probably

31
00:01:12,159 --> 00:01:16,000
uh something on your end um

32
00:01:16,000 --> 00:01:19,040
okay so um i'm going to go ahead and

33
00:01:19,040 --> 00:01:22,400
share my screen and we will uh continue

34
00:01:22,400 --> 00:01:25,119
more or less where we left off last time

35
00:01:25,119 --> 00:01:28,240
um screen sharing

36
00:01:28,240 --> 00:01:31,759
zoom screen number one okay

37
00:01:31,759 --> 00:01:34,320
so now you should be seeing my screen i

38
00:01:34,320 --> 00:01:34,960
will just

39
00:01:34,960 --> 00:01:37,920
make sure i can see the chat at the same

40
00:01:37,920 --> 00:01:39,200
time

41
00:01:39,200 --> 00:01:42,640
all right um cool

42
00:01:42,640 --> 00:01:44,880
so this is the document the document

43
00:01:44,880 --> 00:01:45,759
somebody has

44
00:01:45,759 --> 00:01:49,600
already added an x don't know why

45
00:01:49,600 --> 00:01:53,600
and class two and last time we

46
00:01:53,600 --> 00:01:57,040
played around with those uh nice

47
00:01:57,040 --> 00:01:59,680
leds and we are going to keep playing

48
00:01:59,680 --> 00:02:01,119
with them today

49
00:02:01,119 --> 00:02:04,240
um the first thing we are going to do

50
00:02:04,240 --> 00:02:08,000
we are going to uh um

51
00:02:08,000 --> 00:02:10,318
do something i forgot to do last time so

52
00:02:10,318 --> 00:02:12,000
we started playing around with

53
00:02:12,000 --> 00:02:15,200
uh the timers and um

54
00:02:15,200 --> 00:02:17,680
we had this demo where we would use a

55
00:02:17,680 --> 00:02:18,480
timer

56
00:02:18,480 --> 00:02:22,560
to uh blink one of the leds

57
00:02:22,560 --> 00:02:25,760
and then we had the loop empty and we

58
00:02:25,760 --> 00:02:28,480
set up an interrupt handler to toggle

59
00:02:28,480 --> 00:02:29,520
the pin

60
00:02:29,520 --> 00:02:32,640
and i forgot to mention that i have a

61
00:02:32,640 --> 00:02:34,480
blog post about that

62
00:02:34,480 --> 00:02:37,519
which basically uh goes uh

63
00:02:37,519 --> 00:02:40,400
and explained is exactly what we did

64
00:02:40,400 --> 00:02:41,440
last time

65
00:02:41,440 --> 00:02:43,599
so you can even see like the code here

66
00:02:43,599 --> 00:02:45,599
which is more or less what we did last

67
00:02:45,599 --> 00:02:46,400
time

68
00:02:46,400 --> 00:02:50,080
um we can just copy it here

69
00:02:50,080 --> 00:02:53,120
and run it uh basically uh it's

70
00:02:53,120 --> 00:02:54,800
currently set to blink the

71
00:02:54,800 --> 00:02:58,000
uh built-in led so that's the led on the

72
00:02:58,000 --> 00:03:00,800
arduino board and uh you can see that

73
00:03:00,800 --> 00:03:01,200
this

74
00:03:01,200 --> 00:03:05,839
led blinks roughly every one second

75
00:03:06,159 --> 00:03:09,040
so um as i mentioned last time there are

76
00:03:09,040 --> 00:03:11,360
a lot of things we can do with timers

77
00:03:11,360 --> 00:03:15,519
and um they are

78
00:03:15,680 --> 00:03:18,720
we would have to set aside just like

79
00:03:18,720 --> 00:03:20,640
five sessions if we wanted to cover

80
00:03:20,640 --> 00:03:22,879
everything but i just wanted to give you

81
00:03:22,879 --> 00:03:24,400
the basics of

82
00:03:24,400 --> 00:03:28,080
what timers are and how they work

83
00:03:28,080 --> 00:03:31,440
and before we say goodbye to timers i

84
00:03:31,440 --> 00:03:32,000
want to show

85
00:03:32,000 --> 00:03:36,959
you another nice use case of timers and

86
00:03:36,959 --> 00:03:40,239
the use case will be measuring the

87
00:03:40,239 --> 00:03:42,080
performance of our code

88
00:03:42,080 --> 00:03:45,680
so right now we have set up timer number

89
00:03:45,680 --> 00:03:46,159
one

90
00:03:46,159 --> 00:03:49,680
and if we open the datasheet we can see

91
00:03:49,680 --> 00:03:53,360
somewhere in here there is the uh

92
00:03:53,360 --> 00:03:57,439
yeah timer counter number one

93
00:03:57,439 --> 00:04:00,799
and we set up the registers uh

94
00:04:00,799 --> 00:04:04,799
like i think the important part was um

95
00:04:04,799 --> 00:04:07,920
setting those uh clock select bits

96
00:04:07,920 --> 00:04:11,280
those bits so we set them to uh

97
00:04:11,280 --> 00:04:14,400
we only set cs12 uh

98
00:04:14,400 --> 00:04:18,238
to one so uh this basically means

99
00:04:18,238 --> 00:04:22,240
we divide the clock by 256.

100
00:04:22,240 --> 00:04:26,400
um so uh that's this line

101
00:04:26,400 --> 00:04:29,440
and what this basically means so we have

102
00:04:29,440 --> 00:04:30,400
the clock

103
00:04:30,400 --> 00:04:33,440
arduino clock running at uh

104
00:04:33,440 --> 00:04:36,639
16 megahertz um so

105
00:04:36,639 --> 00:04:40,160
if we divide it by uh so that's uh

106
00:04:40,160 --> 00:04:43,280
16 million instructions

107
00:04:43,280 --> 00:04:46,800
per second and uh or 60

108
00:04:46,800 --> 00:04:50,240
million clock cycles per second and

109
00:04:50,240 --> 00:04:53,280
um if we divide it

110
00:04:53,280 --> 00:04:58,160
uh by uh if we set a prescaler to 256

111
00:04:58,160 --> 00:05:01,360
it means that the uh clock will uh

112
00:05:01,360 --> 00:05:04,479
the counter this timer will go up

113
00:05:04,479 --> 00:05:08,720
every uh 256 clock cycles

114
00:05:08,720 --> 00:05:12,080
so uh that was uh 16

115
00:05:12,080 --> 00:05:17,440
big number divided by 256

116
00:05:17,440 --> 00:05:21,440
and uh the result was uh

117
00:05:21,440 --> 00:05:24,720
like something like this like uh

118
00:05:24,720 --> 00:05:28,720
almost uh the maximum value of um

119
00:05:28,720 --> 00:05:32,560
a 16-bit integer so uh the counter

120
00:05:32,560 --> 00:05:35,680
would count this amount of uh would go

121
00:05:35,680 --> 00:05:37,680
up this amount of

122
00:05:37,680 --> 00:05:41,440
times per second so that's with

123
00:05:41,440 --> 00:05:45,120
uh basically with this line

124
00:05:45,120 --> 00:05:48,720
but um in if we wanted to

125
00:05:48,720 --> 00:05:52,000
measure uh how fast a piece of code runs

126
00:05:52,000 --> 00:05:55,039
we can uh actually uh

127
00:05:55,039 --> 00:05:58,400
set it prescaler to just one so we can

128
00:05:58,400 --> 00:06:01,199
measure count every single clock tick

129
00:06:01,199 --> 00:06:01,600
and

130
00:06:01,600 --> 00:06:04,000
in order to do that let's just comment

131
00:06:04,000 --> 00:06:05,360
out this line

132
00:06:05,360 --> 00:06:09,120
and use this one free scaler so

133
00:06:09,120 --> 00:06:12,080
it runs uh

134
00:06:12,160 --> 00:06:14,880
every single clock cycle and in order to

135
00:06:14,880 --> 00:06:16,160
select this

136
00:06:16,160 --> 00:06:18,720
prescaler of one we can go back to the

137
00:06:18,720 --> 00:06:20,800
data sheet not this one this one

138
00:06:20,800 --> 00:06:23,360
and we see that we need to set this bit

139
00:06:23,360 --> 00:06:24,479
cs

140
00:06:24,479 --> 00:06:28,000
one zero uh we need to have it high

141
00:06:28,000 --> 00:06:31,360
so um let's do that

142
00:06:31,360 --> 00:06:34,240
and right now if i'm going to run this

143
00:06:34,240 --> 00:06:35,520
which i will do

144
00:06:35,520 --> 00:06:37,919
you will see that the led blinks like

145
00:06:37,919 --> 00:06:38,639
crazy

146
00:06:38,639 --> 00:06:41,919
uh like it will uh blink

147
00:06:41,919 --> 00:06:44,639
roughly uh 200 times per second it will

148
00:06:44,639 --> 00:06:46,479
be so fast that it will probably

149
00:06:46,479 --> 00:06:49,120
seem that this led yeah it seems like

150
00:06:49,120 --> 00:06:50,400
it's constantly on

151
00:06:50,400 --> 00:06:54,638
because it blinks so fast

152
00:06:55,280 --> 00:06:58,000
but we are not interested in this led

153
00:06:58,000 --> 00:06:58,880
anymore

154
00:06:58,880 --> 00:07:02,400
instead we are going to um set

155
00:07:02,400 --> 00:07:06,080
to reset this timer to set its value to

156
00:07:06,080 --> 00:07:06,560
zero

157
00:07:06,560 --> 00:07:09,680
so how do we do that in order to set its

158
00:07:09,680 --> 00:07:10,720
value to zero

159
00:07:10,720 --> 00:07:15,039
we have um two registers tc and t1h and

160
00:07:15,039 --> 00:07:16,639
tc and t1l

161
00:07:16,639 --> 00:07:19,360
and these registers give direct access

162
00:07:19,360 --> 00:07:21,039
both for read and write operation

163
00:07:21,039 --> 00:07:24,000
to the uh primary counter you need 16

164
00:07:24,000 --> 00:07:25,680
bit counter so they let us

165
00:07:25,680 --> 00:07:28,080
set the value of the counter and then

166
00:07:28,080 --> 00:07:30,240
read it back

167
00:07:30,240 --> 00:07:33,919
so we are going to set it to 0

168
00:07:33,919 --> 00:07:37,840
and if we didn't have a friendly

169
00:07:37,840 --> 00:07:38,880
compiler

170
00:07:38,880 --> 00:07:42,400
we would have to write first to

171
00:07:42,400 --> 00:07:46,720
i think and th and then to cdc and t1l

172
00:07:46,720 --> 00:07:49,919
i think uh there is some explanation

173
00:07:49,919 --> 00:07:52,800
uh how you need to write to them but uh

174
00:07:52,800 --> 00:07:54,160
you don't need to worry about that

175
00:07:54,160 --> 00:07:55,759
because the compiler

176
00:07:55,759 --> 00:07:58,479
already knows that if we write to tc and

177
00:07:58,479 --> 00:07:59,039
t1

178
00:07:59,039 --> 00:08:01,360
it should write to these two registers

179
00:08:01,360 --> 00:08:02,960
so it does the

180
00:08:02,960 --> 00:08:06,240
uh it does this for us so we are zeroing

181
00:08:06,240 --> 00:08:06,560
it

182
00:08:06,560 --> 00:08:08,319
out and the next thing we are going to

183
00:08:08,319 --> 00:08:09,840
do we are going to

184
00:08:09,840 --> 00:08:12,800
uh just read its value back uh let's

185
00:08:12,800 --> 00:08:14,479
call it cycles

186
00:08:14,479 --> 00:08:17,680
um so that's and we will uh print the

187
00:08:17,680 --> 00:08:18,319
results

188
00:08:18,319 --> 00:08:21,840
let's uh serial begin

189
00:08:21,840 --> 00:08:25,440
and serial println um

190
00:08:25,440 --> 00:08:28,560
cycles so right now

191
00:08:28,560 --> 00:08:32,719
we have like uh set the counter

192
00:08:32,719 --> 00:08:36,640
to zero and read it back

193
00:08:36,640 --> 00:08:40,000
and you may think uh that this

194
00:08:40,000 --> 00:08:43,360
will print the value zero but when i run

195
00:08:43,360 --> 00:08:45,120
this code you can see that it prints the

196
00:08:45,120 --> 00:08:46,320
value one

197
00:08:46,320 --> 00:08:50,000
and the reason for that is um

198
00:08:50,000 --> 00:08:52,160
this copying of the timer reading it

199
00:08:52,160 --> 00:08:54,399
back actually takes time and

200
00:08:54,399 --> 00:08:57,040
during that time the counter increases

201
00:08:57,040 --> 00:08:58,160
by one

202
00:08:58,160 --> 00:09:01,760
so uh if you want to measure a piece of

203
00:09:01,760 --> 00:09:02,560
code

204
00:09:02,560 --> 00:09:05,600
like let's say we want to

205
00:09:05,600 --> 00:09:09,360
measure how long digital right

206
00:09:11,200 --> 00:09:15,360
takes then we need to

207
00:09:15,360 --> 00:09:18,000
subtract one from this value because we

208
00:09:18,000 --> 00:09:20,160
don't want to

209
00:09:20,160 --> 00:09:22,320
account we want to account for that

210
00:09:22,320 --> 00:09:24,240
extra clock cycle that

211
00:09:24,240 --> 00:09:27,440
this scoping takes so uh right now

212
00:09:27,440 --> 00:09:30,480
i'm running it and it prints zero so

213
00:09:30,480 --> 00:09:33,440
uh we sort of calibrated our code so

214
00:09:33,440 --> 00:09:34,480
when we don't have

215
00:09:34,480 --> 00:09:36,480
anything to measure we just get zero

216
00:09:36,480 --> 00:09:37,920
which makes sense

217
00:09:37,920 --> 00:09:40,000
and now we are going to compare uh

218
00:09:40,000 --> 00:09:41,680
digital right

219
00:09:41,680 --> 00:09:44,000
versus direct port access and somebody

220
00:09:44,000 --> 00:09:45,040
asked about that

221
00:09:45,040 --> 00:09:47,200
i think last session uh how did they

222
00:09:47,200 --> 00:09:48,480
compare in terms of

223
00:09:48,480 --> 00:09:51,440
performance so using this super simple

224
00:09:51,440 --> 00:09:51,839
tool

225
00:09:51,839 --> 00:09:54,240
let's remove this we no longer need this

226
00:09:54,240 --> 00:09:57,200
uh using this super simple tool like

227
00:09:57,200 --> 00:10:00,080
resetting the timer to zero and then

228
00:10:00,080 --> 00:10:01,279
reading it back

229
00:10:01,279 --> 00:10:04,320
we can actually uh get the answer so if

230
00:10:04,320 --> 00:10:05,440
we are using

231
00:10:05,440 --> 00:10:08,079
digital right let's write 2d actually

232
00:10:08,079 --> 00:10:09,760
let's try just to

233
00:10:09,760 --> 00:10:15,079
led number one it's going to be

234
00:10:15,079 --> 00:10:17,839
73

235
00:10:17,839 --> 00:10:20,880
cycles wow that's a lot or maybe it's

236
00:10:20,880 --> 00:10:21,440
not

237
00:10:21,440 --> 00:10:24,079
let's compare it to uh direct port

238
00:10:24,079 --> 00:10:25,040
access so

239
00:10:25,040 --> 00:10:28,160
uh i'm going to do the same like port

240
00:10:28,160 --> 00:10:32,079
uh that was port d uh for pin number one

241
00:10:32,079 --> 00:10:35,440
so port d equals uh we want

242
00:10:35,440 --> 00:10:39,279
uh the uh second led so

243
00:10:39,279 --> 00:10:42,959
we want to set bit number one um

244
00:10:42,959 --> 00:10:45,279
and we are going to run this and this

245
00:10:45,279 --> 00:10:46,160
time it's

246
00:10:46,160 --> 00:10:49,200
only two clock cycles so

247
00:10:49,200 --> 00:10:50,640
as you can see there is a huge

248
00:10:50,640 --> 00:10:53,200
difference between uh digital right

249
00:10:53,200 --> 00:10:56,800
and uh port direct uh port access

250
00:10:56,800 --> 00:11:00,720
it's about 20 times faster

251
00:11:00,720 --> 00:11:02,560
and somebody asked in the chat whether

252
00:11:02,560 --> 00:11:03,920
this uh counter

253
00:11:03,920 --> 00:11:06,000
affects the performance of the

254
00:11:06,000 --> 00:11:08,320
microcontroller in any way

255
00:11:08,320 --> 00:11:10,399
as far as i know it doesn't it's a

256
00:11:10,399 --> 00:11:12,560
separate unit it's in the same chip but

257
00:11:12,560 --> 00:11:14,160
it's a separate unit so

258
00:11:14,160 --> 00:11:17,120
the processor continues running uh at

259
00:11:17,120 --> 00:11:18,079
the same rate

260
00:11:18,079 --> 00:11:20,560
um like the code will run in the same

261
00:11:20,560 --> 00:11:21,360
speed

262
00:11:21,360 --> 00:11:24,800
uh regardless of like the timer counting

263
00:11:24,800 --> 00:11:26,959
every single clock cycle so that's a

264
00:11:26,959 --> 00:11:28,000
good question thanks for

265
00:11:28,000 --> 00:11:31,440
asking um so that's

266
00:11:31,440 --> 00:11:35,120
pretty much uh i think my favorite use

267
00:11:35,120 --> 00:11:36,160
case of timers

268
00:11:36,160 --> 00:11:39,440
or of uh this specific timer just to uh

269
00:11:39,440 --> 00:11:42,800
measure the speed of some of code

270
00:11:42,800 --> 00:11:46,640
and um i also got a blog post that uh

271
00:11:46,640 --> 00:11:49,920
covers that and uh well it goes into

272
00:11:49,920 --> 00:11:52,720
all the details and compar compares all

273
00:11:52,720 --> 00:11:53,920
sort of like

274
00:11:53,920 --> 00:11:56,560
things like you can see here like uh we

275
00:11:56,560 --> 00:11:58,240
are measuring digital right

276
00:11:58,240 --> 00:12:02,160
and etc so if you want to check it out i

277
00:12:02,160 --> 00:12:03,040
will uh

278
00:12:03,040 --> 00:12:05,440
put the link here so you can check it

279
00:12:05,440 --> 00:12:06,720
out later

280
00:12:06,720 --> 00:12:10,399
uh yep so this is the blog post

281
00:12:10,399 --> 00:12:14,000
um and i think that's about it

282
00:12:14,000 --> 00:12:17,519
with timers i think it's a good time uh

283
00:12:17,519 --> 00:12:21,440
speaking of timers to um

284
00:12:21,440 --> 00:12:24,720
move to assembly and

285
00:12:24,720 --> 00:12:29,120
that's a bit of a big shift but

286
00:12:29,120 --> 00:12:32,480
in order to learn about assembly

287
00:12:32,480 --> 00:12:35,120
for avr we can no longer use the

288
00:12:35,120 --> 00:12:37,519
datasheet the datasheet only includes

289
00:12:37,519 --> 00:12:40,079
a quick summary of all the assembly

290
00:12:40,079 --> 00:12:41,360
instructions

291
00:12:41,360 --> 00:12:43,920
and it's useful if you already know

292
00:12:43,920 --> 00:12:44,560
assembly

293
00:12:44,560 --> 00:12:46,720
and you just want a quick reminder of

294
00:12:46,720 --> 00:12:48,000
what each

295
00:12:48,000 --> 00:12:51,120
instruction does but in order to

296
00:12:51,120 --> 00:12:53,120
actually learn about the instructions

297
00:12:53,120 --> 00:12:55,600
we have to consult the avr instruction

298
00:12:55,600 --> 00:12:56,240
manual

299
00:12:56,240 --> 00:12:58,720
and it's a different document it's

300
00:12:58,720 --> 00:12:59,920
pretty long

301
00:12:59,920 --> 00:13:03,120
and as you can see it has

302
00:13:03,120 --> 00:13:07,839
more than 100 instructions and

303
00:13:07,920 --> 00:13:11,440
that really uh sounds like a lot

304
00:13:11,440 --> 00:13:14,720
but we don't need to remember all of

305
00:13:14,720 --> 00:13:15,040
them

306
00:13:15,040 --> 00:13:18,000
i will show you the most useful ones and

307
00:13:18,000 --> 00:13:19,680
then

308
00:13:19,680 --> 00:13:21,839
more importantly i will explain to you

309
00:13:21,839 --> 00:13:23,839
how to read this manual so

310
00:13:23,839 --> 00:13:26,240
uh whenever you need some instruction or

311
00:13:26,240 --> 00:13:26,880
more

312
00:13:26,880 --> 00:13:29,279
or i think that would make even more

313
00:13:29,279 --> 00:13:30,959
sense whenever you read some code and

314
00:13:30,959 --> 00:13:32,560
encounter some instruction that you

315
00:13:32,560 --> 00:13:33,680
don't know about

316
00:13:33,680 --> 00:13:38,560
you can just go here and read about it

317
00:13:38,639 --> 00:13:41,839
so let's just paste this link

318
00:13:41,839 --> 00:13:46,240
in the document as well so you can

319
00:13:46,240 --> 00:13:50,639
so you can have it as well

320
00:13:50,720 --> 00:13:53,360
okay cool so we have this one and this

321
00:13:53,360 --> 00:13:55,920
is the instruction manual

322
00:13:55,920 --> 00:13:59,279
oh we can just yep

323
00:13:59,279 --> 00:14:02,800
that's more human friendly um all right

324
00:14:02,800 --> 00:14:06,800
so um the first instruction we are going

325
00:14:06,800 --> 00:14:07,760
to learn about

326
00:14:07,760 --> 00:14:10,959
is called um nop

327
00:14:10,959 --> 00:14:15,920
nlp and um before we are going to uh

328
00:14:15,920 --> 00:14:17,360
talk about this instruction

329
00:14:17,360 --> 00:14:20,560
i'm actually going to uh explain a

330
00:14:20,560 --> 00:14:21,680
little bit

331
00:14:21,680 --> 00:14:26,240
more about uh something called registers

332
00:14:26,240 --> 00:14:29,279
and uh registers are like

333
00:14:29,279 --> 00:14:33,760
um so registers are like

334
00:14:33,760 --> 00:14:36,399
uh they are a bit aching to local

335
00:14:36,399 --> 00:14:37,519
variables

336
00:14:37,519 --> 00:14:40,320
so they let you they are like pieces of

337
00:14:40,320 --> 00:14:41,839
memory that you can

338
00:14:41,839 --> 00:14:45,040
uh work with you can

339
00:14:45,040 --> 00:14:48,079
insert data or set them with some value

340
00:14:48,079 --> 00:14:49,120
insert some

341
00:14:49,120 --> 00:14:51,519
load some data into them you can perform

342
00:14:51,519 --> 00:14:53,920
calculations on them and then you can

343
00:14:53,920 --> 00:14:57,040
copy them back to the memory or whatever

344
00:14:57,040 --> 00:15:00,320
and specifically in avr you can only do

345
00:15:00,320 --> 00:15:02,560
arithmetic instructions so all the

346
00:15:02,560 --> 00:15:05,680
re arithmetic instructions

347
00:15:05,680 --> 00:15:08,160
they only work on registers so if you

348
00:15:08,160 --> 00:15:08,720
want to

349
00:15:08,720 --> 00:15:10,959
add two numbers you first need to copy

350
00:15:10,959 --> 00:15:12,000
them to into

351
00:15:12,000 --> 00:15:16,639
a register and also if you are specific

352
00:15:16,639 --> 00:15:20,000
you have a few

353
00:15:20,000 --> 00:15:22,240
general purpose registers more

354
00:15:22,240 --> 00:15:23,040
specifically

355
00:15:23,040 --> 00:15:27,040
you have 31 general purpose registers so

356
00:15:27,040 --> 00:15:32,800
um they are called r0 through r21

357
00:15:32,800 --> 00:15:37,120
and these registers are uh 8 bit wide

358
00:15:37,120 --> 00:15:41,440
so they can hold one byte uh so one byte

359
00:15:41,440 --> 00:15:44,639
and the reason uh that's the reason uh

360
00:15:44,639 --> 00:15:48,800
avr is called um 8-bit architecture

361
00:15:48,800 --> 00:15:50,399
because these registers

362
00:15:50,399 --> 00:15:53,920
are um they hold 8-bit and all the

363
00:15:53,920 --> 00:15:55,600
arithmetic operations are

364
00:15:55,600 --> 00:15:58,000
performed or most of them are performed

365
00:15:58,000 --> 00:16:00,079
on 8-bit registers

366
00:16:00,079 --> 00:16:03,120
so other than these

367
00:16:03,120 --> 00:16:05,610
registers we also have um

368
00:16:05,610 --> 00:16:06,880
[Music]

369
00:16:06,880 --> 00:16:09,839
they aren't exactly registers but uh

370
00:16:09,839 --> 00:16:10,639
they are just

371
00:16:10,639 --> 00:16:14,880
uh uh pseudonames for uh

372
00:16:14,880 --> 00:16:18,320
uh some of these registers so we have x

373
00:16:18,320 --> 00:16:21,040
and x when we talk about x we basically

374
00:16:21,040 --> 00:16:21,519
refer

375
00:16:21,519 --> 00:16:25,600
to r26 and r27

376
00:16:25,600 --> 00:16:28,959
and then we have uh six

377
00:16:28,959 --> 00:16:32,240
seven and then we have y which is

378
00:16:32,240 --> 00:16:36,000
eight and nine and z which refers to

379
00:16:36,000 --> 00:16:39,360
the uh two last registers and

380
00:16:39,360 --> 00:16:42,480
there are some operations that work on

381
00:16:42,480 --> 00:16:45,839
uh so x is 16 bits because it's two

382
00:16:45,839 --> 00:16:48,880
18 bit registers and same goes for y and

383
00:16:48,880 --> 00:16:49,680
z

384
00:16:49,680 --> 00:16:51,920
and there are some operations that work

385
00:16:51,920 --> 00:16:53,680
on 16 bits like

386
00:16:53,680 --> 00:16:57,839
uh um adding 260 bits numbers

387
00:16:57,839 --> 00:17:01,360
or copying two registers at once

388
00:17:01,360 --> 00:17:05,199
and these operations uh use x y and z

389
00:17:05,199 --> 00:17:08,240
and they are also used to um

390
00:17:08,240 --> 00:17:10,720
hold memory addresses the reason for

391
00:17:10,720 --> 00:17:11,760
that is that

392
00:17:11,760 --> 00:17:14,559
eight bits couldn't hold all the uh

393
00:17:14,559 --> 00:17:15,119
memory

394
00:17:15,119 --> 00:17:18,640
uh in avr we have like uh

395
00:17:18,640 --> 00:17:22,240
so avr avr i mean the 80 mega

396
00:17:22,240 --> 00:17:26,240
32p uh on the uno it has two kilobytes

397
00:17:26,240 --> 00:17:28,640
of memory so we need more than eight

398
00:17:28,640 --> 00:17:30,160
bits to address that

399
00:17:30,160 --> 00:17:32,720
and that's why we have those uh register

400
00:17:32,720 --> 00:17:33,360
pairs

401
00:17:33,360 --> 00:17:36,080
and they have those spatial names but

402
00:17:36,080 --> 00:17:37,200
they are essentially

403
00:17:37,200 --> 00:17:41,840
uh the same thing with different names

404
00:17:41,840 --> 00:17:44,320
and uh there are two more registers that

405
00:17:44,320 --> 00:17:46,080
will uh

406
00:17:46,080 --> 00:17:49,280
sort of encounter today uh pc

407
00:17:49,280 --> 00:17:53,280
which is um it's the program counter

408
00:17:53,280 --> 00:17:56,160
and it's not really a register that you

409
00:17:56,160 --> 00:17:57,120
can

410
00:17:57,120 --> 00:18:00,080
access from the code directly it's more

411
00:18:00,080 --> 00:18:02,559
like an implicit register

412
00:18:02,559 --> 00:18:06,080
and this register holds the memory

413
00:18:06,080 --> 00:18:10,559
or the flash memory address

414
00:18:10,559 --> 00:18:13,679
of the currently executing

415
00:18:13,679 --> 00:18:17,039
instruction or in some cases uh it holds

416
00:18:17,039 --> 00:18:17,679
the

417
00:18:17,679 --> 00:18:20,799
address of the next instruction

418
00:18:20,799 --> 00:18:23,840
uh to execute but we don't have to worry

419
00:18:23,840 --> 00:18:24,400
about that

420
00:18:24,400 --> 00:18:26,320
right now we just have to remember that

421
00:18:26,320 --> 00:18:27,679
pc tells us

422
00:18:27,679 --> 00:18:30,559
which instruction is going to run next

423
00:18:30,559 --> 00:18:31,280
and there is

424
00:18:31,280 --> 00:18:34,640
also s reg this status register

425
00:18:34,640 --> 00:18:37,760
and it contains uh so it's this one is

426
00:18:37,760 --> 00:18:41,760
eight bits and this one is uh

427
00:18:41,760 --> 00:18:43,600
it really depends on the microcontroller

428
00:18:43,600 --> 00:18:44,880
but it can go uh

429
00:18:44,880 --> 00:18:49,880
from i think uh eight bits to uh

430
00:18:49,880 --> 00:18:53,039
24 bits or something like that or 22

431
00:18:53,039 --> 00:18:53,840
bits

432
00:18:53,840 --> 00:18:56,400
uh but again you don't really get any

433
00:18:56,400 --> 00:18:58,400
direct access to pc so you don't care

434
00:18:58,400 --> 00:18:59,520
about it

435
00:18:59,520 --> 00:19:03,440
um and the s reg um basically holds some

436
00:19:03,440 --> 00:19:04,400
information

437
00:19:04,400 --> 00:19:06,799
about uh the state of the uh

438
00:19:06,799 --> 00:19:07,840
microcontroller

439
00:19:07,840 --> 00:19:10,240
like whether interrupts are enables or

440
00:19:10,240 --> 00:19:12,160
are enabled or not

441
00:19:12,160 --> 00:19:15,679
um and if you want to uh see

442
00:19:15,679 --> 00:19:19,120
uh learn about s reg we can find it

443
00:19:19,120 --> 00:19:22,960
uh in the avr cpio core status register

444
00:19:22,960 --> 00:19:24,080
yeah

445
00:19:24,080 --> 00:19:26,720
and we can see that the s reg actually

446
00:19:26,720 --> 00:19:27,600
contains

447
00:19:27,600 --> 00:19:31,039
um eight bits and

448
00:19:31,039 --> 00:19:34,160
we won't uh talk about uh all these bits

449
00:19:34,160 --> 00:19:34,799
today

450
00:19:34,799 --> 00:19:38,080
uh just uh dr these are

451
00:19:38,080 --> 00:19:40,400
like uh affected by arithmetic

452
00:19:40,400 --> 00:19:41,679
instructions

453
00:19:41,679 --> 00:19:44,080
uh but one thing i want to show you is

454
00:19:44,080 --> 00:19:46,240
that uh the most significant bit

455
00:19:46,240 --> 00:19:49,360
is uh called global interrupt enable

456
00:19:49,360 --> 00:19:52,320
and actually when you disable or enable

457
00:19:52,320 --> 00:19:53,760
interrupts you just

458
00:19:53,760 --> 00:19:56,960
switch this bit off or on so if we

459
00:19:56,960 --> 00:19:59,280
wanted to disable interrupts

460
00:19:59,280 --> 00:20:03,760
uh we could do like last time

461
00:20:03,760 --> 00:20:07,120
let's do yeah so uh

462
00:20:07,120 --> 00:20:09,039
if we run this code again we can see

463
00:20:09,039 --> 00:20:10,559
that this led is

464
00:20:10,559 --> 00:20:13,280
blinking really rapidly because we have

465
00:20:13,280 --> 00:20:15,120
interrupts enabled and this

466
00:20:15,120 --> 00:20:18,320
uh interrupt vector first

467
00:20:18,320 --> 00:20:21,280
and it's so rapid we can see but it

468
00:20:21,280 --> 00:20:23,200
switches it on and off

469
00:20:23,200 --> 00:20:25,840
but if we disable interrupts we'll see

470
00:20:25,840 --> 00:20:26,240
that

471
00:20:26,240 --> 00:20:29,280
uh it will no longer uh

472
00:20:29,280 --> 00:20:33,919
blink um so instead of calling this

473
00:20:33,919 --> 00:20:35,679
function the c function to disable

474
00:20:35,679 --> 00:20:37,280
interrupt we can just write

475
00:20:37,280 --> 00:20:40,720
0 to s reg and by writing 0 to s reg

476
00:20:40,720 --> 00:20:43,840
we will clear this interrupt a bit so

477
00:20:43,840 --> 00:20:46,080
let's do this yeah and you can see we

478
00:20:46,080 --> 00:20:48,320
are getting the same result the

479
00:20:48,320 --> 00:20:52,320
uh interrupt doesn't fire and um

480
00:20:52,320 --> 00:20:55,440
nothing is happening with this led um

481
00:20:55,440 --> 00:20:58,880
and we can also print like let's do it

482
00:20:58,880 --> 00:20:59,760
here

483
00:20:59,760 --> 00:21:03,039
so let's print lan

484
00:21:03,039 --> 00:21:06,080
the value of s switch as binary

485
00:21:06,080 --> 00:21:09,039
and we can see that uh by default when

486
00:21:09,039 --> 00:21:10,240
we haven't changed it

487
00:21:10,240 --> 00:21:13,520
the most significant bit is set so

488
00:21:13,520 --> 00:21:16,799
that's the interrupt flag so

489
00:21:16,799 --> 00:21:18,880
these are the registers of the

490
00:21:18,880 --> 00:21:20,320
microcontroller

491
00:21:20,320 --> 00:21:23,600
and we are going to work with them a lot

492
00:21:23,600 --> 00:21:25,679
especially with those general purpose

493
00:21:25,679 --> 00:21:27,120
registers when we

494
00:21:27,120 --> 00:21:30,480
write assembly and now when we have this

495
00:21:30,480 --> 00:21:33,039
uh information when we uh know about

496
00:21:33,039 --> 00:21:34,080
those registers

497
00:21:34,080 --> 00:21:37,360
we can uh start writing assembly code

498
00:21:37,360 --> 00:21:40,480
um let's just uh

499
00:21:40,480 --> 00:21:43,280
get this back to work because i still

500
00:21:43,280 --> 00:21:46,080
want to be able to count cycles

501
00:21:46,080 --> 00:21:48,480
so yeah so we have this code that we

502
00:21:48,480 --> 00:21:51,919
created to count cycles

503
00:21:52,400 --> 00:21:56,559
and now we are going to

504
00:21:56,559 --> 00:21:58,960
look at the first instruction that's uh

505
00:21:58,960 --> 00:22:00,960
nopenop

506
00:22:00,960 --> 00:22:04,159
and uh if you have ever worked with

507
00:22:04,159 --> 00:22:05,039
assembly you

508
00:22:05,039 --> 00:22:08,240
probably of any kind of uh architecture

509
00:22:08,240 --> 00:22:09,360
you probably know that

510
00:22:09,360 --> 00:22:12,559
nope means no operation

511
00:22:12,559 --> 00:22:15,679
and um this like format

512
00:22:15,679 --> 00:22:17,840
is very common you will find it in all

513
00:22:17,840 --> 00:22:19,840
the instruction page so you have the

514
00:22:19,840 --> 00:22:23,120
uh instruction name and like a

515
00:22:23,120 --> 00:22:26,640
quick description uh or just what this

516
00:22:26,640 --> 00:22:27,679
name means

517
00:22:27,679 --> 00:22:29,919
and then uh it explains what this

518
00:22:29,919 --> 00:22:31,600
instruction does

519
00:22:31,600 --> 00:22:34,640
and uh it sort of uh shows you the

520
00:22:34,640 --> 00:22:36,400
episode code of

521
00:22:36,400 --> 00:22:38,799
how this instruction works in this case

522
00:22:38,799 --> 00:22:41,440
it doesn't do anything so it says no

523
00:22:41,440 --> 00:22:43,280
then it shows you the syntax in this

524
00:22:43,280 --> 00:22:45,200
case the syntax is just not

525
00:22:45,200 --> 00:22:47,840
it doesn't have any operands and you can

526
00:22:47,840 --> 00:22:48,480
also

527
00:22:48,480 --> 00:22:50,960
already see that this instruction does

528
00:22:50,960 --> 00:22:51,679
something

529
00:22:51,679 --> 00:22:54,960
it even though it's no operation

530
00:22:54,960 --> 00:22:57,120
it increments the value of pc the

531
00:22:57,120 --> 00:22:58,080
program counter

532
00:22:58,080 --> 00:23:00,240
so uh it will continue executing the

533
00:23:00,240 --> 00:23:02,000
next instruction if it wouldn't do that

534
00:23:02,000 --> 00:23:04,480
then we would just be stuck on up

535
00:23:04,480 --> 00:23:07,200
and then uh you can basically ignore

536
00:23:07,200 --> 00:23:08,000
this you don't care

537
00:23:08,000 --> 00:23:10,720
about this right now and for some

538
00:23:10,720 --> 00:23:11,840
instructions

539
00:23:11,840 --> 00:23:14,000
they modify the status register so they

540
00:23:14,000 --> 00:23:15,760
can modify some of the bits in this

541
00:23:15,760 --> 00:23:16,880
register

542
00:23:16,880 --> 00:23:20,159
uh in case of nope it doesn't we'll soon

543
00:23:20,159 --> 00:23:22,080
see an instruction that

544
00:23:22,080 --> 00:23:25,280
does modify the um

545
00:23:25,280 --> 00:23:28,880
the status register

546
00:23:28,880 --> 00:23:32,000
and one more bit that is useful

547
00:23:32,000 --> 00:23:34,640
is the cycles the cycles tells us how

548
00:23:34,640 --> 00:23:36,799
many clock cycles it takes to this

549
00:23:36,799 --> 00:23:39,600
microcontroller to run this instruction

550
00:23:39,600 --> 00:23:40,080
so

551
00:23:40,080 --> 00:23:44,320
um usually if we included a knob in our

552
00:23:44,320 --> 00:23:44,960
program

553
00:23:44,960 --> 00:23:46,640
we couldn't really see the effect

554
00:23:46,640 --> 00:23:48,480
because we don't have direct access to

555
00:23:48,480 --> 00:23:50,799
pc so we couldn't like just print the x

556
00:23:50,799 --> 00:23:52,720
the value of pc

557
00:23:52,720 --> 00:23:55,840
but since it takes one cycle uh

558
00:23:55,840 --> 00:23:58,240
we will be able to measure it and that's

559
00:23:58,240 --> 00:23:59,840
what we are going to do now

560
00:23:59,840 --> 00:24:03,520
so uh let's just remove all this in the

561
00:24:03,520 --> 00:24:04,880
uh

562
00:24:04,880 --> 00:24:10,240
measurement code measure code under test

563
00:24:10,240 --> 00:24:13,039
cool and now uh when we run it without

564
00:24:13,039 --> 00:24:13,760
any code

565
00:24:13,760 --> 00:24:16,320
uh just like before it prints zero but

566
00:24:16,320 --> 00:24:18,159
then we can

567
00:24:18,159 --> 00:24:21,279
call this asm so asm is a spatial

568
00:24:21,279 --> 00:24:23,440
construct that tells the compiler the c

569
00:24:23,440 --> 00:24:24,400
compiler

570
00:24:24,400 --> 00:24:27,679
uh just uh emit this

571
00:24:27,679 --> 00:24:30,840
uh just use this assembly instruction

572
00:24:30,840 --> 00:24:35,360
um and then uh i'm calling asm knop

573
00:24:35,360 --> 00:24:38,159
and you can see or you can't see any

574
00:24:38,159 --> 00:24:39,279
effect on the uh

575
00:24:39,279 --> 00:24:42,080
program except for like the number of

576
00:24:42,080 --> 00:24:42,799
cycles

577
00:24:42,799 --> 00:24:45,760
uh like this code now uh takes one

578
00:24:45,760 --> 00:24:46,640
cycles

579
00:24:46,640 --> 00:24:49,200
and if you have if we have five knobs we

580
00:24:49,200 --> 00:24:49,760
can see

581
00:24:49,760 --> 00:24:52,880
uh it wasted five cpu cycles

582
00:24:52,880 --> 00:24:55,919
so um basically

583
00:24:55,919 --> 00:25:00,000
uh this instruction is usually useless

584
00:25:00,000 --> 00:25:03,120
uh unless for some reason you want to

585
00:25:03,120 --> 00:25:04,720
delay the cpu for a

586
00:25:04,720 --> 00:25:07,600
very very short period like in this case

587
00:25:07,600 --> 00:25:08,240
it's like

588
00:25:08,240 --> 00:25:11,919
uh if we put uh 16 knobs

589
00:25:11,919 --> 00:25:15,760
like that's 10 15 16.

590
00:25:15,760 --> 00:25:19,200
so that would uh delay the cpu by uh one

591
00:25:19,200 --> 00:25:20,480
microsecond or

592
00:25:20,480 --> 00:25:23,600
uh 16 cycles

593
00:25:23,600 --> 00:25:27,120
so it's not very useful but since it's

594
00:25:27,120 --> 00:25:28,320
very simple instruction

595
00:25:28,320 --> 00:25:31,520
i wanted to start with it now the next

596
00:25:31,520 --> 00:25:33,279
instruction we are going to see

597
00:25:33,279 --> 00:25:36,400
um is a bit

598
00:25:36,400 --> 00:25:39,840
more interesting um and you already know

599
00:25:39,840 --> 00:25:40,080
it

600
00:25:40,080 --> 00:25:43,200
because uh we just uh call use this

601
00:25:43,200 --> 00:25:44,159
instruction

602
00:25:44,159 --> 00:25:47,279
by calling a c function and that's uh

603
00:25:47,279 --> 00:25:47,600
the

604
00:25:47,600 --> 00:25:50,880
seis say or let's start

605
00:25:50,880 --> 00:25:54,240
actually with um cli

606
00:25:54,240 --> 00:25:57,440
uh where is that cli

607
00:25:57,440 --> 00:26:01,360
uh cli clear global interrupt flag

608
00:26:01,360 --> 00:26:02,960
and you can see it's like the same

609
00:26:02,960 --> 00:26:05,200
format uh it sells

610
00:26:05,200 --> 00:26:07,600
this clears the global interrupt flag i

611
00:26:07,600 --> 00:26:08,880
in s reg

612
00:26:08,880 --> 00:26:11,200
interrupts will be immediately disabled

613
00:26:11,200 --> 00:26:13,200
no interrupts will be executed after the

614
00:26:13,200 --> 00:26:15,200
cli instruction even if it occurs

615
00:26:15,200 --> 00:26:18,720
simultaneously with the cli instruction

616
00:26:18,720 --> 00:26:21,279
and now we can see that the operation is

617
00:26:21,279 --> 00:26:22,400
putting 0

618
00:26:22,400 --> 00:26:25,279
into i if we have here just one letter

619
00:26:25,279 --> 00:26:25,919
it

620
00:26:25,919 --> 00:26:28,400
always uh it usually refers to one of

621
00:26:28,400 --> 00:26:30,320
the abilities in the status register so

622
00:26:30,320 --> 00:26:30,880
it puts

623
00:26:30,880 --> 00:26:34,240
0 in i this is the syntax it gets no

624
00:26:34,240 --> 00:26:35,120
operands

625
00:26:35,120 --> 00:26:37,840
just like before it increments the pc by

626
00:26:37,840 --> 00:26:38,799
one

627
00:26:38,799 --> 00:26:41,760
and you can see that it has an effect on

628
00:26:41,760 --> 00:26:42,240
the

629
00:26:42,240 --> 00:26:45,279
uh i bit it sets its to zero

630
00:26:45,279 --> 00:26:49,279
and this clears the um

631
00:26:49,520 --> 00:26:52,000
to the global interrupt flex and it

632
00:26:52,000 --> 00:26:53,600
takes one cycle

633
00:26:53,600 --> 00:26:58,000
so uh we are going to use this now

634
00:26:58,000 --> 00:27:00,400
and this time we are going to see a

635
00:27:00,400 --> 00:27:02,880
effect on our program because as soon as

636
00:27:02,880 --> 00:27:04,000
we call

637
00:27:04,000 --> 00:27:08,960
cli something will break for example

638
00:27:08,960 --> 00:27:12,320
the led doesn't light up anymore because

639
00:27:12,320 --> 00:27:12,960
this

640
00:27:12,960 --> 00:27:16,480
vector isn't executed and

641
00:27:16,480 --> 00:27:19,600
it has a sister instruction

642
00:27:19,600 --> 00:27:22,640
called sci that sets this bit

643
00:27:22,640 --> 00:27:26,240
so um sci is

644
00:27:26,240 --> 00:27:29,600
started you can see it's pretty much the

645
00:27:29,600 --> 00:27:30,399
same

646
00:27:30,399 --> 00:27:34,000
1 into i i is 1 and it also takes one

647
00:27:34,000 --> 00:27:34,960
cycle

648
00:27:34,960 --> 00:27:38,880
so we can call sci right after

649
00:27:38,880 --> 00:27:42,159
and interrupts are restored

650
00:27:42,159 --> 00:27:44,480
and as we can expect calling both

651
00:27:44,480 --> 00:27:45,360
instructions

652
00:27:45,360 --> 00:27:47,840
takes two cycles because each one is a

653
00:27:47,840 --> 00:27:50,639
single cycle

654
00:27:50,960 --> 00:27:54,000
so uh these are like the first

655
00:27:54,000 --> 00:27:54,799
instructions

656
00:27:54,799 --> 00:27:57,440
they do something they do very simple

657
00:27:57,440 --> 00:27:58,240
things

658
00:27:58,240 --> 00:28:01,600
but we already covered three out of 100

659
00:28:01,600 --> 00:28:05,200
something it's a good progress i think

660
00:28:05,200 --> 00:28:08,320
um and

661
00:28:08,320 --> 00:28:10,480
the next thing we're going to look into

662
00:28:10,480 --> 00:28:11,679
is okay

663
00:28:11,679 --> 00:28:14,159
we have some instructions but then how

664
00:28:14,159 --> 00:28:16,559
do we work with these registers

665
00:28:16,559 --> 00:28:18,159
so the first thing we are going to do we

666
00:28:18,159 --> 00:28:20,159
are going to look at an

667
00:28:20,159 --> 00:28:22,159
instruction that will allow us to load

668
00:28:22,159 --> 00:28:23,919
some value into a register

669
00:28:23,919 --> 00:28:28,159
so it's called ldi

670
00:28:28,159 --> 00:28:31,760
load immediate where is that ldi

671
00:28:31,760 --> 00:28:35,200
and we can see ldi loads eight bit

672
00:28:35,200 --> 00:28:36,480
constant so one by

673
00:28:36,480 --> 00:28:40,640
directly to register and uh one thing to

674
00:28:40,640 --> 00:28:42,799
note here it doesn't work with any

675
00:28:42,799 --> 00:28:46,240
register it only works with registers

676
00:28:46,240 --> 00:28:50,240
16 or greater and the operation is just

677
00:28:50,240 --> 00:28:52,960
rd so i think before the operation it's

678
00:28:52,960 --> 00:28:54,640
better to look at the syntax

679
00:28:54,640 --> 00:28:58,000
the syntax is ldi rd d is like

680
00:28:58,000 --> 00:29:00,559
the destination register the this stands

681
00:29:00,559 --> 00:29:01,120
for

682
00:29:01,120 --> 00:29:04,159
uh the register index so between 16

683
00:29:04,159 --> 00:29:07,760
and 31 and ldi rd

684
00:29:07,760 --> 00:29:11,039
and some constant k is the constant

685
00:29:11,039 --> 00:29:15,600
and it's between 0 and 255 so one byte

686
00:29:15,600 --> 00:29:17,279
and you can see that what it does it

687
00:29:17,279 --> 00:29:19,200
basically puts the value k

688
00:29:19,200 --> 00:29:22,240
into the register rd so

689
00:29:22,240 --> 00:29:25,679
um it takes one cycle so it's a quick

690
00:29:25,679 --> 00:29:27,440
instruction just one cycle

691
00:29:27,440 --> 00:29:29,440
and it doesn't affect the status

692
00:29:29,440 --> 00:29:31,360
register so we don't uh

693
00:29:31,360 --> 00:29:34,880
need to worry about it and uh

694
00:29:34,880 --> 00:29:37,840
let's see that so um we are going to

695
00:29:37,840 --> 00:29:39,440
load

696
00:29:39,440 --> 00:29:42,480
let's say r16 with the value

697
00:29:42,480 --> 00:29:45,520
55. now um

698
00:29:45,520 --> 00:29:48,320
when we run it you can see that it took

699
00:29:48,320 --> 00:29:49,760
one cycle

700
00:29:49,760 --> 00:29:52,159
but we couldn't really observe the

701
00:29:52,159 --> 00:29:53,039
effect of

702
00:29:53,039 --> 00:29:57,120
loading um r50 uh r16 with

703
00:29:57,120 --> 00:30:01,200
uh 55 and uh the reason for that

704
00:30:01,200 --> 00:30:04,240
is that um at this point

705
00:30:04,240 --> 00:30:07,039
the c compiler was probably not using

706
00:30:07,039 --> 00:30:08,000
r16 for

707
00:30:08,000 --> 00:30:11,360
anything important otherwise uh we could

708
00:30:11,360 --> 00:30:11,679
have

709
00:30:11,679 --> 00:30:14,240
probably disrupted the flow of the

710
00:30:14,240 --> 00:30:15,279
program

711
00:30:15,279 --> 00:30:19,279
um but um

712
00:30:19,279 --> 00:30:22,480
i mean there is no way uh in

713
00:30:22,480 --> 00:30:25,600
c that we can actually there is some way

714
00:30:25,600 --> 00:30:27,760
to tell it uh to read the specific

715
00:30:27,760 --> 00:30:28,480
register

716
00:30:28,480 --> 00:30:31,600
but it's pretty involved um

717
00:30:31,600 --> 00:30:34,720
we are going to see now a few ways in

718
00:30:34,720 --> 00:30:36,080
which we can

719
00:30:36,080 --> 00:30:38,480
indirectly or directly observe the

720
00:30:38,480 --> 00:30:40,159
values of the register

721
00:30:40,159 --> 00:30:42,559
so the first thing we are going to see

722
00:30:42,559 --> 00:30:44,480
is um

723
00:30:44,480 --> 00:30:46,399
something that is specific to the quokui

724
00:30:46,399 --> 00:30:48,880
simulator and i actually edit it

725
00:30:48,880 --> 00:30:51,840
today just for you

726
00:30:52,399 --> 00:30:54,480
we are going to use um another

727
00:30:54,480 --> 00:30:55,520
instruction

728
00:30:55,520 --> 00:30:58,559
and that instruction is called break and

729
00:30:58,559 --> 00:30:59,360
usually

730
00:30:59,360 --> 00:31:02,240
it's used to set um let's see break

731
00:31:02,240 --> 00:31:04,080
where are you

732
00:31:04,080 --> 00:31:08,000
yeah so usually brake uh is uh

733
00:31:08,000 --> 00:31:12,399
used to uh toggle a breakpoint to um

734
00:31:12,399 --> 00:31:14,559
if you have a debugger connected to the

735
00:31:14,559 --> 00:31:16,000
chip it will

736
00:31:16,000 --> 00:31:19,039
uh just uh pause the cpu

737
00:31:19,039 --> 00:31:22,799
and um break the code execution

738
00:31:22,799 --> 00:31:27,120
and you will be able to debug it

739
00:31:27,120 --> 00:31:30,640
but in the simulator

740
00:31:30,640 --> 00:31:33,200
you can connect debugger but it's kind

741
00:31:33,200 --> 00:31:34,880
of complex right now

742
00:31:34,880 --> 00:31:38,640
so uh i think uh we will probably do it

743
00:31:38,640 --> 00:31:41,440
in the next session or the session after

744
00:31:41,440 --> 00:31:41,919
but

745
00:31:41,919 --> 00:31:44,320
if you don't connect a debugger uh you

746
00:31:44,320 --> 00:31:46,240
can still see um

747
00:31:46,240 --> 00:31:48,960
use this instruction and it's very

748
00:31:48,960 --> 00:31:50,000
useful because

749
00:31:50,000 --> 00:31:53,279
uh it's a bit hacky but if you open the

750
00:31:53,279 --> 00:31:56,559
chrome dev tools let's clear it

751
00:31:56,559 --> 00:32:00,640
and you run this code you will see that

752
00:32:00,640 --> 00:32:03,279
every break instruction actually dumps

753
00:32:03,279 --> 00:32:06,399
all the values of the registers

754
00:32:06,399 --> 00:32:09,039
and it dumps them in hexadecimal so

755
00:32:09,039 --> 00:32:09,840
let's put an

756
00:32:09,840 --> 00:32:12,159
hexadecimal value so it will be easier

757
00:32:12,159 --> 00:32:13,440
for us to see

758
00:32:13,440 --> 00:32:17,679
and we can see that r16 got the value 37

759
00:32:17,679 --> 00:32:20,480
so while you are learning about assembly

760
00:32:20,480 --> 00:32:21,120
uh

761
00:32:21,120 --> 00:32:23,840
this this is like super useful in order

762
00:32:23,840 --> 00:32:24,480
to just

763
00:32:24,480 --> 00:32:27,919
uh get some insight into uh the value of

764
00:32:27,919 --> 00:32:29,120
registers

765
00:32:29,120 --> 00:32:31,120
and you can see are all these 31

766
00:32:31,120 --> 00:32:32,960
registers you can see here

767
00:32:32,960 --> 00:32:36,000
the program counter sp which we will

768
00:32:36,000 --> 00:32:38,559
talk about next time and also you can

769
00:32:38,559 --> 00:32:39,120
see

770
00:32:39,120 --> 00:32:41,519
x y and z and for instance you can see

771
00:32:41,519 --> 00:32:42,960
that the value of y

772
00:32:42,960 --> 00:32:46,799
is actually made of the values of r28

773
00:32:46,799 --> 00:32:47,039
and

774
00:32:47,039 --> 00:32:50,880
r29 and uh same goes for the value of z

775
00:32:50,880 --> 00:32:54,080
it's just a little indian um

776
00:32:54,080 --> 00:32:57,039
the 16-bit value of those two registers

777
00:32:57,039 --> 00:32:59,120
and you can also see the status register

778
00:32:59,120 --> 00:32:59,919
in this case

779
00:32:59,919 --> 00:33:02,080
uh all the bits are off and only the

780
00:33:02,080 --> 00:33:03,600
ibid is on so

781
00:33:03,600 --> 00:33:07,360
interrupts are enabled so um

782
00:33:07,360 --> 00:33:12,159
yeah uh so um that's one way you can uh

783
00:33:12,159 --> 00:33:14,320
debug your code or see the values of

784
00:33:14,320 --> 00:33:15,679
registers

785
00:33:15,679 --> 00:33:19,120
but um i'm going to show you a few more

786
00:33:19,120 --> 00:33:20,080
ways

787
00:33:20,080 --> 00:33:24,880
so um one other another way to

788
00:33:24,880 --> 00:33:27,760
look at the value of a register is just

789
00:33:27,760 --> 00:33:28,240
to

790
00:33:28,240 --> 00:33:30,799
store it somewhere in the memory and for

791
00:33:30,799 --> 00:33:32,159
that we are going to use

792
00:33:32,159 --> 00:33:35,519
a global variable variable let's call it

793
00:33:35,519 --> 00:33:36,480
value

794
00:33:36,480 --> 00:33:39,360
and it will be set to zero and at this

795
00:33:39,360 --> 00:33:39,919
point

796
00:33:39,919 --> 00:33:43,200
i will just remove all this uh um

797
00:33:43,200 --> 00:33:46,320
you know uh all this code that measures

798
00:33:46,320 --> 00:33:48,480
the performance because we don't need it

799
00:33:48,480 --> 00:33:49,200
anymore

800
00:33:49,200 --> 00:33:52,320
at this point and um

801
00:33:52,320 --> 00:33:54,559
let's remove this as well so we have

802
00:33:54,559 --> 00:33:57,360
only assembly

803
00:33:57,360 --> 00:34:01,039
and um what i'm going to do i'm going to

804
00:34:01,039 --> 00:34:04,720
uh print the address of this variable

805
00:34:04,720 --> 00:34:07,279
first of all so we'll know where it uh

806
00:34:07,279 --> 00:34:08,960
where it sits in the memory

807
00:34:08,960 --> 00:34:11,679
so we are going to appear into the this

808
00:34:11,679 --> 00:34:12,800
value

809
00:34:12,800 --> 00:34:16,079
let's do it as an integer and let's

810
00:34:16,079 --> 00:34:19,119
also print uh the value of this variable

811
00:34:19,119 --> 00:34:22,879
which we expect to be zero println

812
00:34:22,879 --> 00:34:26,079
um value

813
00:34:26,079 --> 00:34:29,359
cool all right so uh

814
00:34:29,359 --> 00:34:32,639
that's the address to uh 86 and the

815
00:34:32,639 --> 00:34:34,399
value is 0.

816
00:34:34,399 --> 00:34:38,399
and now that we know the address

817
00:34:38,399 --> 00:34:41,839
we can try to copy the value of r16

818
00:34:41,839 --> 00:34:44,399
into that address and for that we are

819
00:34:44,399 --> 00:34:46,960
going to use another instruction

820
00:34:46,960 --> 00:34:50,480
uh called uh sdsa

821
00:34:50,480 --> 00:34:53,839
thing store uh something

822
00:34:53,839 --> 00:34:57,119
uh sts

823
00:34:57,119 --> 00:35:00,160
sds yep

824
00:35:00,160 --> 00:35:04,000
yep sds store direct to data space

825
00:35:04,000 --> 00:35:06,880
stores one byte from a register to the

826
00:35:06,880 --> 00:35:08,079
data space

827
00:35:08,079 --> 00:35:10,640
so the data space if you remember is

828
00:35:10,640 --> 00:35:11,680
where we have the

829
00:35:11,680 --> 00:35:14,960
uh ram and we also have those uh

830
00:35:14,960 --> 00:35:17,040
port b poor d and all of the other

831
00:35:17,040 --> 00:35:18,880
peripheral registers

832
00:35:18,880 --> 00:35:21,280
and there is another interesting thing

833
00:35:21,280 --> 00:35:22,800
uh the

834
00:35:22,800 --> 00:35:26,800
r 0 through r 31 are also like a part of

835
00:35:26,800 --> 00:35:28,720
the data space so the first

836
00:35:28,720 --> 00:35:32,640
um 31 bits of um

837
00:35:32,640 --> 00:35:35,599
of the ram 31 bytes of the ram are

838
00:35:35,599 --> 00:35:36,880
actually this register

839
00:35:36,880 --> 00:35:40,480
so this is how you can sort of access

840
00:35:40,480 --> 00:35:41,119
them in

841
00:35:41,119 --> 00:35:45,200
c if you just read from memory address 5

842
00:35:45,200 --> 00:35:47,440
it will return you to val you will get a

843
00:35:47,440 --> 00:35:49,599
value of r5

844
00:35:49,599 --> 00:35:52,720
um but we are not going to do that

845
00:35:52,720 --> 00:35:54,240
instead we are going to use this

846
00:35:54,240 --> 00:35:56,640
function to copy the value of some

847
00:35:56,640 --> 00:35:57,520
register

848
00:35:57,520 --> 00:36:01,839
into the address given by k so sds gets

849
00:36:01,839 --> 00:36:04,270
k which is an address in the

850
00:36:04,270 --> 00:36:06,000
[Music]

851
00:36:06,000 --> 00:36:09,200
data space and a register and it copies

852
00:36:09,200 --> 00:36:10,880
the content of that register

853
00:36:10,880 --> 00:36:13,040
into that memory address and you can see

854
00:36:13,040 --> 00:36:14,640
that it can work with

855
00:36:14,640 --> 00:36:18,000
any of the uh r uh zero to r

856
00:36:18,000 --> 00:36:21,520
third rm through r21 registers

857
00:36:21,520 --> 00:36:25,200
and it can set them to it can

858
00:36:25,200 --> 00:36:28,480
set any memory address between 0 and

859
00:36:28,480 --> 00:36:30,079
that value which is

860
00:36:30,079 --> 00:36:33,119
more than enough for the 32 kilobytes of

861
00:36:33,119 --> 00:36:34,320
the 80 mega

862
00:36:34,320 --> 00:36:37,359
32 8b um

863
00:36:37,359 --> 00:36:38,800
and it doesn't affect the status

864
00:36:38,800 --> 00:36:40,400
registers and they take

865
00:36:40,400 --> 00:36:44,400
two cycles so let's use that um

866
00:36:44,400 --> 00:36:47,680
so we want to

867
00:36:47,680 --> 00:36:51,200
store the value of r16

868
00:36:51,200 --> 00:36:55,040
into some memory address

869
00:36:55,040 --> 00:36:58,560
r16 and the memory address uh we know it

870
00:36:58,560 --> 00:37:00,800
because we printed the address of values

871
00:37:00,800 --> 00:37:05,040
so that would be 286

872
00:37:05,040 --> 00:37:08,320
and build failed because we forgot a

873
00:37:08,320 --> 00:37:10,560
semicolon of course

874
00:37:10,560 --> 00:37:14,480
and now again we can see that uh

875
00:37:14,480 --> 00:37:17,520
um our um let's actually print it in

876
00:37:17,520 --> 00:37:20,240
hexadecimal so it will be easier to see

877
00:37:20,240 --> 00:37:23,760
uh it contains 37 hexa so

878
00:37:23,760 --> 00:37:27,280
uh we copied 37 we loaded the value 37

879
00:37:27,280 --> 00:37:28,720
into r16

880
00:37:28,720 --> 00:37:32,079
and then uh stored the value from r16

881
00:37:32,079 --> 00:37:34,320
into this memory address which we know

882
00:37:34,320 --> 00:37:36,400
happens to be the address of

883
00:37:36,400 --> 00:37:40,079
value and what i just showed you now

884
00:37:40,079 --> 00:37:42,880
it is what you have just seen now it is

885
00:37:42,880 --> 00:37:43,520
what you

886
00:37:43,520 --> 00:37:46,560
shouldn't do and in a moment i will show

887
00:37:46,560 --> 00:37:47,839
you how to do it

888
00:37:47,839 --> 00:37:51,200
uh what's the proper way uh to access

889
00:37:51,200 --> 00:37:53,760
variables uh when you are writing

890
00:37:53,760 --> 00:37:55,520
assembly code inside

891
00:37:55,520 --> 00:37:59,200
um inside uh

892
00:37:59,200 --> 00:38:02,560
see inside um

893
00:38:02,560 --> 00:38:05,599
c or arduino code there is a question

894
00:38:05,599 --> 00:38:07,920
on the chat whether the program counter

895
00:38:07,920 --> 00:38:09,359
and clock cycles

896
00:38:09,359 --> 00:38:12,240
are related to each other so not really

897
00:38:12,240 --> 00:38:14,720
like the program counter can go back and

898
00:38:14,720 --> 00:38:15,839
forth

899
00:38:15,839 --> 00:38:19,440
and uh depending on the uh instruction

900
00:38:19,440 --> 00:38:22,880
uh it can take it a few cycles

901
00:38:22,880 --> 00:38:24,880
like in this case this instruction

902
00:38:24,880 --> 00:38:26,320
actually

903
00:38:26,320 --> 00:38:28,800
increments the program counter by two

904
00:38:28,800 --> 00:38:30,800
and it takes two cycles

905
00:38:30,800 --> 00:38:32,880
so it might seem that they are related

906
00:38:32,880 --> 00:38:34,960
but there are other instructions that

907
00:38:34,960 --> 00:38:37,200
uh we'll see in the next lesson that

908
00:38:37,200 --> 00:38:39,599
just set a program counter to some

909
00:38:39,599 --> 00:38:41,280
arbitrary value

910
00:38:41,280 --> 00:38:44,320
and there are instructions uh like i

911
00:38:44,320 --> 00:38:44,800
think

912
00:38:44,800 --> 00:38:48,240
even ldi does that i'm not sure let's

913
00:38:48,240 --> 00:38:49,359
see

914
00:38:49,359 --> 00:38:51,920
no lda it takes one cycle but there are

915
00:38:51,920 --> 00:38:53,920
instructions that take two cycles while

916
00:38:53,920 --> 00:38:54,640
they still

917
00:38:54,640 --> 00:38:56,480
uh they only increment the program

918
00:38:56,480 --> 00:38:57,880
counter by

919
00:38:57,880 --> 00:39:01,040
one um cool

920
00:39:01,040 --> 00:39:04,160
so um yeah so that's one way

921
00:39:04,160 --> 00:39:07,760
to observe the value of r16 just copy it

922
00:39:07,760 --> 00:39:09,839
somewhere in the memory and then

923
00:39:09,839 --> 00:39:12,720
uh hopefully uh read from the same

924
00:39:12,720 --> 00:39:14,240
memory inside the

925
00:39:14,240 --> 00:39:17,359
c plus plus length and print it

926
00:39:17,359 --> 00:39:20,079
but that's not the only way another way

927
00:39:20,079 --> 00:39:20,880
to do it

928
00:39:20,880 --> 00:39:25,040
would be um to store it to the location

929
00:39:25,040 --> 00:39:28,880
where the ports d register besides so

930
00:39:28,880 --> 00:39:30,000
basically write

931
00:39:30,000 --> 00:39:31,839
the value of copy the value of this

932
00:39:31,839 --> 00:39:33,200
register into

933
00:39:33,200 --> 00:39:36,000
port d and for that we are first going

934
00:39:36,000 --> 00:39:38,480
to print the address of port d

935
00:39:38,480 --> 00:39:41,040
and we can see let's do it hexa just to

936
00:39:41,040 --> 00:39:42,160
keep everything

937
00:39:42,160 --> 00:39:46,320
uh similar so we can see this is the

938
00:39:46,320 --> 00:39:47,680
memory address of

939
00:39:47,680 --> 00:39:51,040
port it's uh the data address space

940
00:39:51,040 --> 00:39:54,240
of port d and we can just write

941
00:39:54,240 --> 00:39:57,760
the value of our 16 there let's

942
00:39:57,760 --> 00:40:01,200
just you know set the least significant

943
00:40:01,200 --> 00:40:02,000
bit

944
00:40:02,000 --> 00:40:04,240
and as we run it we can see that it

945
00:40:04,240 --> 00:40:06,079
turned the led on

946
00:40:06,079 --> 00:40:08,800
so now we have a simple mechanism that

947
00:40:08,800 --> 00:40:09,359
allows

948
00:40:09,359 --> 00:40:12,400
us to um write

949
00:40:12,400 --> 00:40:15,760
any value any register to

950
00:40:15,760 --> 00:40:18,480
this memory address and as long as we

951
00:40:18,480 --> 00:40:20,640
have led disconnected we can

952
00:40:20,640 --> 00:40:23,520
see the bits of this register so that's

953
00:40:23,520 --> 00:40:25,839
what i usually do when i need to debug

954
00:40:25,839 --> 00:40:28,319
something with assembly and arduino and

955
00:40:28,319 --> 00:40:30,000
you know i just want to

956
00:40:30,000 --> 00:40:32,079
dump the bits of a register in a

957
00:40:32,079 --> 00:40:33,440
specific point so that's

958
00:40:33,440 --> 00:40:37,359
the easiest way to do it um

959
00:40:37,359 --> 00:40:38,310
so uh

960
00:40:38,310 --> 00:40:40,400
[Music]

961
00:40:40,400 --> 00:40:44,000
um so yeah uh there is

962
00:40:44,000 --> 00:40:46,640
a question but let's leave it uh for

963
00:40:46,640 --> 00:40:47,440
after the

964
00:40:47,440 --> 00:40:50,720
q and a session and um

965
00:40:50,720 --> 00:40:53,760
now that uh we covered sds there is

966
00:40:53,760 --> 00:40:57,040
also lds that lets us uh

967
00:40:57,040 --> 00:41:00,880
read a value from uh a specific uh

968
00:41:00,880 --> 00:41:03,760
place in memory so for instance we could

969
00:41:03,760 --> 00:41:05,359
do something like that

970
00:41:05,359 --> 00:41:08,640
we could load so uh where did we have

971
00:41:08,640 --> 00:41:09,760
value

972
00:41:09,760 --> 00:41:12,880
let's print that again

973
00:41:13,280 --> 00:41:16,880
so yeah so uh that's the address

974
00:41:16,880 --> 00:41:20,880
of our value

975
00:41:20,880 --> 00:41:25,680
load wait a moment let's just

976
00:41:26,800 --> 00:41:31,040
still load uh from this memory address

977
00:41:31,040 --> 00:41:35,359
into r16 and then

978
00:41:35,359 --> 00:41:39,040
store r16 into our dots we know

979
00:41:39,040 --> 00:41:42,319
is 4d and what we are going to what we

980
00:41:42,319 --> 00:41:42,960
did now

981
00:41:42,960 --> 00:41:45,760
is essentially uh let's set bit number

982
00:41:45,760 --> 00:41:46,720
two

983
00:41:46,720 --> 00:41:50,560
uh what we did now oh wait a moment

984
00:41:50,560 --> 00:41:53,359
uh the address of value has changed

985
00:41:53,359 --> 00:41:54,319
interesting

986
00:41:54,319 --> 00:41:56,560
yeah that's the problem working with

987
00:41:56,560 --> 00:41:58,720
memory addresses they change

988
00:41:58,720 --> 00:42:01,599
okay and what we did now we basically

989
00:42:01,599 --> 00:42:02,690
copied

990
00:42:02,690 --> 00:42:03,920
[Music]

991
00:42:03,920 --> 00:42:07,280
this this value from here

992
00:42:07,280 --> 00:42:10,000
into r16 and then stored it into a

993
00:42:10,000 --> 00:42:11,599
different memory location

994
00:42:11,599 --> 00:42:15,280
which happens to be port d

995
00:42:15,280 --> 00:42:18,560
and there is a question on the chat from

996
00:42:18,560 --> 00:42:20,560
rafael whether we can

997
00:42:20,560 --> 00:42:24,319
tell the compiler that we want um

998
00:42:24,319 --> 00:42:26,560
to load like we want the address of this

999
00:42:26,560 --> 00:42:27,839
variable or we want

1000
00:42:27,839 --> 00:42:30,960
uh something else and the answer is yes

1001
00:42:30,960 --> 00:42:32,160
we'll see that in a moment

1002
00:42:32,160 --> 00:42:36,480
that's actually the right thing to do um

1003
00:42:36,480 --> 00:42:39,839
so instead of like um

1004
00:42:39,839 --> 00:42:42,319
loading the values from memory like we

1005
00:42:42,319 --> 00:42:43,520
did here

1006
00:42:43,520 --> 00:42:47,760
we can um use um a spatial

1007
00:42:47,760 --> 00:42:50,480
syntax and i think in my opinion it's a

1008
00:42:50,480 --> 00:42:52,000
horrible syntax

1009
00:42:52,000 --> 00:42:55,359
it doesn't resemble anything

1010
00:42:55,359 --> 00:42:58,720
but fortunately there is like uh

1011
00:42:58,720 --> 00:43:01,040
this cookbook which explains about this

1012
00:43:01,040 --> 00:43:02,160
syntax

1013
00:43:02,160 --> 00:43:05,440
and it's pretty long uh it's uh

1014
00:43:05,440 --> 00:43:08,160
not it's pretty friend it's okay i mean

1015
00:43:08,160 --> 00:43:09,839
it's not the friendliest thing in the

1016
00:43:09,839 --> 00:43:10,960
world but

1017
00:43:10,960 --> 00:43:14,800
uh the thing is um if you

1018
00:43:14,800 --> 00:43:18,319
are sort of if you are sort of familiar

1019
00:43:18,319 --> 00:43:19,680
with the syntax you don't have to

1020
00:43:19,680 --> 00:43:21,040
remember it you can just

1021
00:43:21,040 --> 00:43:24,240
uh like look at this reference whenever

1022
00:43:24,240 --> 00:43:25,440
you need

1023
00:43:25,440 --> 00:43:29,680
so let's add it into the

1024
00:43:29,680 --> 00:43:33,440
into this document and

1025
00:43:33,440 --> 00:43:35,280
what we are going to do we are going to

1026
00:43:35,280 --> 00:43:36,800
use this syntax

1027
00:43:36,800 --> 00:43:40,800
so in this case we want to

1028
00:43:40,800 --> 00:43:44,480
load a value into a register

1029
00:43:44,480 --> 00:43:46,240
and actually we don't need this

1030
00:43:46,240 --> 00:43:48,400
instruction because we can

1031
00:43:48,400 --> 00:43:51,760
already we can tell uh we can use this

1032
00:43:51,760 --> 00:43:52,880
syntax

1033
00:43:52,880 --> 00:43:55,920
uh to get a compiler to copy uh

1034
00:43:55,920 --> 00:43:59,119
this uh value of the variable into

1035
00:43:59,119 --> 00:44:02,720
uh some register for us uh so basically

1036
00:44:02,720 --> 00:44:04,640
uh figure out the first instruction that

1037
00:44:04,640 --> 00:44:05,839
we had here

1038
00:44:05,839 --> 00:44:08,880
itself and in order to do that

1039
00:44:08,880 --> 00:44:12,480
we need to use those fancy columns

1040
00:44:12,480 --> 00:44:15,520
and the first one specifies

1041
00:44:15,520 --> 00:44:18,880
which variables we want to write

1042
00:44:18,880 --> 00:44:20,800
and the second one which variables we

1043
00:44:20,800 --> 00:44:22,079
want to read

1044
00:44:22,079 --> 00:44:24,560
and in this case we are only want to

1045
00:44:24,560 --> 00:44:26,480
read from a variable we want to read

1046
00:44:26,480 --> 00:44:27,599
from

1047
00:44:27,599 --> 00:44:32,000
value so we can write

1048
00:44:32,000 --> 00:44:36,000
value but it won't understand

1049
00:44:36,000 --> 00:44:38,800
it because it needs to know uh what to

1050
00:44:38,800 --> 00:44:39,680
do with this

1051
00:44:39,680 --> 00:44:42,960
uh value where to put it so

1052
00:44:42,960 --> 00:44:45,440
we give it a string and i said before

1053
00:44:45,440 --> 00:44:48,000
it's an awkward syntax so bear with me

1054
00:44:48,000 --> 00:44:50,000
we give it a string and this string

1055
00:44:50,000 --> 00:44:51,359
tells the compiler

1056
00:44:51,359 --> 00:44:54,560
uh what to do or how to treat the value

1057
00:44:54,560 --> 00:44:57,520
it's also called constraints so if we

1058
00:44:57,520 --> 00:44:58,480
put it ah

1059
00:44:58,480 --> 00:45:01,680
we set it to r it means we want you to

1060
00:45:01,680 --> 00:45:04,240
put this value in some arbitrary

1061
00:45:04,240 --> 00:45:06,640
register you get a choice you you get to

1062
00:45:06,640 --> 00:45:08,640
choose what register to use

1063
00:45:08,640 --> 00:45:11,680
um but uh

1064
00:45:11,680 --> 00:45:15,200
um it's up to you and

1065
00:45:15,200 --> 00:45:17,760
the compiler takes care of that and then

1066
00:45:17,760 --> 00:45:20,240
inside a parenthesis we tell it uh

1067
00:45:20,240 --> 00:45:22,480
what value we want to put into that

1068
00:45:22,480 --> 00:45:23,440
register

1069
00:45:23,440 --> 00:45:25,920
now you're probably asking yourself okay

1070
00:45:25,920 --> 00:45:26,480
so

1071
00:45:26,480 --> 00:45:29,680
how do we access this in the code so

1072
00:45:29,680 --> 00:45:33,040
um instead of writing uh the register we

1073
00:45:33,040 --> 00:45:35,119
don't know which register the compiler

1074
00:45:35,119 --> 00:45:36,319
is going to choose

1075
00:45:36,319 --> 00:45:39,280
we have this syntax which is a percent

1076
00:45:39,280 --> 00:45:39,760
sign

1077
00:45:39,760 --> 00:45:43,020
and then the index of this um

1078
00:45:43,020 --> 00:45:44,160
[Music]

1079
00:45:44,160 --> 00:45:47,040
of these i don't remember even how they

1080
00:45:47,040 --> 00:45:48,240
call this uh

1081
00:45:48,240 --> 00:45:50,640
input and output operands of this

1082
00:45:50,640 --> 00:45:51,760
operand

1083
00:45:51,760 --> 00:45:54,800
so um in this case this is the first one

1084
00:45:54,800 --> 00:45:55,920
so we do

1085
00:45:55,920 --> 00:45:58,960
percent zero so this will be replaced by

1086
00:45:58,960 --> 00:45:59,359
some

1087
00:45:59,359 --> 00:46:02,640
register it could be r1 r5 r6 i don't

1088
00:46:02,640 --> 00:46:03,359
know

1089
00:46:03,359 --> 00:46:06,079
uh and the compiler will make sure that

1090
00:46:06,079 --> 00:46:07,440
it copies this

1091
00:46:07,440 --> 00:46:09,119
value from the variable into that

1092
00:46:09,119 --> 00:46:10,720
register for us

1093
00:46:10,720 --> 00:46:13,359
so let's see that in action we are going

1094
00:46:13,359 --> 00:46:14,000
to run it

1095
00:46:14,000 --> 00:46:16,960
let's just change the value to four and

1096
00:46:16,960 --> 00:46:18,000
we can see that

1097
00:46:18,000 --> 00:46:21,280
it actually put the value um

1098
00:46:21,280 --> 00:46:24,880
four into um yeah

1099
00:46:24,880 --> 00:46:26,640
we don't need this sprint but we can see

1100
00:46:26,640 --> 00:46:28,240
in the leds that it has

1101
00:46:28,240 --> 00:46:32,480
put the value 4 into uh this port d

1102
00:46:32,480 --> 00:46:35,520
and um to make it actually

1103
00:46:35,520 --> 00:46:38,560
uh more uh

1104
00:46:38,560 --> 00:46:43,760
human friendly i would say instead of uh

1105
00:46:43,760 --> 00:46:47,839
writing this um address of port d we can

1106
00:46:47,839 --> 00:46:49,359
also tell the compiler

1107
00:46:49,359 --> 00:46:53,200
to put the address of port d here

1108
00:46:53,200 --> 00:46:55,599
and we can do it by introducing another

1109
00:46:55,599 --> 00:46:56,960
register that we want

1110
00:46:56,960 --> 00:47:00,400
to or another value another operand that

1111
00:47:00,400 --> 00:47:01,040
we want

1112
00:47:01,040 --> 00:47:04,480
to use in the asm statement but this

1113
00:47:04,480 --> 00:47:06,560
time it's not going to be a register

1114
00:47:06,560 --> 00:47:09,119
because sts doesn't get a register it

1115
00:47:09,119 --> 00:47:10,000
gets a number

1116
00:47:10,000 --> 00:47:13,040
it gets a memory address so

1117
00:47:13,040 --> 00:47:16,480
uh we can just say uh m and there is a

1118
00:47:16,480 --> 00:47:18,560
big table here somewhere here that

1119
00:47:18,560 --> 00:47:20,960
uh tells you what are all these letters

1120
00:47:20,960 --> 00:47:21,760
so r

1121
00:47:21,760 --> 00:47:25,040
stands for any register and you can see

1122
00:47:25,040 --> 00:47:25,680
that m

1123
00:47:25,680 --> 00:47:30,160
is just an 8 bit constant um

1124
00:47:30,160 --> 00:47:33,359
and then we can tell it that this

1125
00:47:33,359 --> 00:47:36,640
m is actually going to be the address of

1126
00:47:36,640 --> 00:47:41,119
port d and we can reference here

1127
00:47:41,119 --> 00:47:44,240
here as uh percent one so

1128
00:47:44,240 --> 00:47:46,720
uh hopefully let's set it to eight run

1129
00:47:46,720 --> 00:47:47,680
the code

1130
00:47:47,680 --> 00:47:51,520
and hopefully yeah we got this uh led on

1131
00:47:51,520 --> 00:47:55,280
so this worked so this is how you

1132
00:47:55,280 --> 00:47:57,520
use inline assembly you don't write any

1133
00:47:57,520 --> 00:47:58,800
magic values here

1134
00:47:58,800 --> 00:48:01,680
you just write uh use all the constants

1135
00:48:01,680 --> 00:48:02,160
uh

1136
00:48:02,160 --> 00:48:06,000
in these uh two strange columns

1137
00:48:06,000 --> 00:48:08,079
and then you just reference them from

1138
00:48:08,079 --> 00:48:09,680
the assembly code

1139
00:48:09,680 --> 00:48:12,720
now um this can get quite confusing when

1140
00:48:12,720 --> 00:48:14,160
you have many of them

1141
00:48:14,160 --> 00:48:16,800
so fortunately you can give them names

1142
00:48:16,800 --> 00:48:18,240
so for instance

1143
00:48:18,240 --> 00:48:21,280
we can call this uh val so

1144
00:48:21,280 --> 00:48:25,280
we use uh uh

1145
00:48:25,520 --> 00:48:29,040
yeah uh we can call this val and then

1146
00:48:29,040 --> 00:48:32,800
just uh that was here uh

1147
00:48:32,800 --> 00:48:35,920
percent sign uh square brackets well

1148
00:48:35,920 --> 00:48:39,760
and that uh would be uh address

1149
00:48:39,760 --> 00:48:42,960
or uh whatever and then

1150
00:48:42,960 --> 00:48:46,800
address so usually uh that's what i do

1151
00:48:46,800 --> 00:48:47,599
when i have

1152
00:48:47,599 --> 00:48:50,800
more than two or three otherwise it gets

1153
00:48:50,800 --> 00:48:51,920
really confusing

1154
00:48:51,920 --> 00:48:55,680
and if i have only like one i just use

1155
00:48:55,680 --> 00:48:59,200
percent zero like we did before so

1156
00:48:59,200 --> 00:49:02,240
cool now we can interface our

1157
00:49:02,240 --> 00:49:06,319
um c code into the assembly code

1158
00:49:06,319 --> 00:49:08,480
and that allows us to do some

1159
00:49:08,480 --> 00:49:10,160
interesting things

1160
00:49:10,160 --> 00:49:13,460
like start using assembly to actually

1161
00:49:13,460 --> 00:49:14,839
[Music]

1162
00:49:14,839 --> 00:49:16,559
um do some

1163
00:49:16,559 --> 00:49:19,760
manipulations uh on things so

1164
00:49:19,760 --> 00:49:21,520
uh the first thing i'm going to do

1165
00:49:21,520 --> 00:49:23,440
actually just out of pure interest

1166
00:49:23,440 --> 00:49:27,760
i'm going to uh put a break instruction

1167
00:49:27,760 --> 00:49:28,839
right after this

1168
00:49:28,839 --> 00:49:32,240
sds and um

1169
00:49:32,240 --> 00:49:34,640
the reason i want to see which register

1170
00:49:34,640 --> 00:49:36,880
the compiler has chosen to

1171
00:49:36,880 --> 00:49:39,440
to put the value in so one of the

1172
00:49:39,440 --> 00:49:41,599
registers will have the value 8 and

1173
00:49:41,599 --> 00:49:43,440
we'll know that this is the register the

1174
00:49:43,440 --> 00:49:44,079
compiler

1175
00:49:44,079 --> 00:49:48,000
chose for us and let's see

1176
00:49:48,000 --> 00:49:51,440
yeah you can see that r24 has the value

1177
00:49:51,440 --> 00:49:52,240
eight

1178
00:49:52,240 --> 00:49:55,760
um and if we change it to 81 for

1179
00:49:55,760 --> 00:49:56,400
instance

1180
00:49:56,400 --> 00:49:59,920
you can see that now it holds 81. so the

1181
00:49:59,920 --> 00:50:03,440
compiler shows r24

1182
00:50:03,440 --> 00:50:08,480
for us in this case um so

1183
00:50:08,800 --> 00:50:11,839
that's what it did in this case

1184
00:50:11,839 --> 00:50:15,040
behind the scenes and instead of r

1185
00:50:15,040 --> 00:50:18,160
we could ask it to use a specific

1186
00:50:18,160 --> 00:50:19,680
register for instance

1187
00:50:19,680 --> 00:50:22,960
uh if we uh told it uh

1188
00:50:22,960 --> 00:50:26,000
to use l it would have to use

1189
00:50:26,000 --> 00:50:29,440
r0 through r15 and

1190
00:50:29,440 --> 00:50:32,160
let's just try that and see if it works

1191
00:50:32,160 --> 00:50:34,240
i haven't tried it so i don't know

1192
00:50:34,240 --> 00:50:36,400
that would be a complete surprise to me

1193
00:50:36,400 --> 00:50:38,160
if it doesn't but yep

1194
00:50:38,160 --> 00:50:41,200
and in this case 81 goes into

1195
00:50:41,200 --> 00:50:44,240
r15 so it uses used r15 because we

1196
00:50:44,240 --> 00:50:44,880
totally

1197
00:50:44,880 --> 00:50:48,160
use one of the lower registers so we can

1198
00:50:48,160 --> 00:50:50,400
sort of tell the compiler uh which

1199
00:50:50,400 --> 00:50:52,480
registers we want to use

1200
00:50:52,480 --> 00:50:54,720
and the reason we want uh to do it

1201
00:50:54,720 --> 00:50:55,520
sometimes

1202
00:50:55,520 --> 00:50:58,240
is because uh as we have seen some

1203
00:50:58,240 --> 00:50:59,280
instructions

1204
00:50:59,280 --> 00:51:03,200
don't accept any register like ldi

1205
00:51:03,200 --> 00:51:06,720
only wants uh r16 through r31 so

1206
00:51:06,720 --> 00:51:08,319
sometimes you want to tell it you know

1207
00:51:08,319 --> 00:51:09,280
what you just

1208
00:51:09,280 --> 00:51:13,440
are there is yeah d r 16 to r

1209
00:51:13,440 --> 00:51:15,359
31 you're just one of them because we

1210
00:51:15,359 --> 00:51:17,119
know the instruction we are calling

1211
00:51:17,119 --> 00:51:19,760
can't work with other registers and if

1212
00:51:19,760 --> 00:51:23,680
we use r0 we'll get a compilation error

1213
00:51:23,680 --> 00:51:26,960
um cool so um

1214
00:51:26,960 --> 00:51:29,599
now that we have that um one more

1215
00:51:29,599 --> 00:51:30,640
instruction that

1216
00:51:30,640 --> 00:51:34,000
is sometimes useful

1217
00:51:34,000 --> 00:51:37,599
that's the move instruction and uh

1218
00:51:37,599 --> 00:51:40,319
move basically copies data between two

1219
00:51:40,319 --> 00:51:41,440
registers

1220
00:51:41,440 --> 00:51:44,559
where is move move move yep

1221
00:51:44,559 --> 00:51:48,720
yep it gets uh rd destination and

1222
00:51:48,720 --> 00:51:51,200
rr source register and just copies the

1223
00:51:51,200 --> 00:51:52,720
value of source register into

1224
00:51:52,720 --> 00:51:54,960
destination register

1225
00:51:54,960 --> 00:51:58,480
and this is pretty useful um

1226
00:51:58,480 --> 00:52:02,640
if you for instance want to load some

1227
00:52:02,640 --> 00:52:06,480
value into r0 for instance you want to

1228
00:52:06,480 --> 00:52:10,400
load this value 15 into r0 for some

1229
00:52:10,400 --> 00:52:13,839
reason because you need to use it later

1230
00:52:13,839 --> 00:52:17,040
but you can't actually do it because ldi

1231
00:52:17,040 --> 00:52:20,480
doesn't uh let's go back to ldi

1232
00:52:20,480 --> 00:52:25,280
ldi only gets registers from 16 to 31.

1233
00:52:25,280 --> 00:52:28,000
so what we would have to do is to load

1234
00:52:28,000 --> 00:52:30,240
it to a different register and then we

1235
00:52:30,240 --> 00:52:31,119
can copy

1236
00:52:31,119 --> 00:52:35,200
to r0 so for instance

1237
00:52:35,200 --> 00:52:38,720
if we go back to this example

1238
00:52:40,640 --> 00:52:44,160
we had this 81 in

1239
00:52:44,160 --> 00:52:47,920
r24 and then we can like add a bunch of

1240
00:52:47,920 --> 00:52:49,119
instruction like

1241
00:52:49,119 --> 00:52:53,040
move r0 r24 and let's do it

1242
00:52:53,040 --> 00:52:56,720
with all the the first five registers

1243
00:52:56,720 --> 00:52:59,119
just for the circuit of it and we can

1244
00:52:59,119 --> 00:53:00,960
see that it copied the values to all

1245
00:53:00,960 --> 00:53:02,160
these registers

1246
00:53:02,160 --> 00:53:04,079
so it's pretty useful because it allows

1247
00:53:04,079 --> 00:53:06,319
us to copy data between registers

1248
00:53:06,319 --> 00:53:08,960
and as we can see uh setting those

1249
00:53:08,960 --> 00:53:09,680
registers

1250
00:53:09,680 --> 00:53:10,710
actually

1251
00:53:10,710 --> 00:53:12,720
[Music]

1252
00:53:12,720 --> 00:53:15,359
broke the c program it no longer runs it

1253
00:53:15,359 --> 00:53:16,640
as expected uh

1254
00:53:16,640 --> 00:53:19,839
it printed some garbage so we have to be

1255
00:53:19,839 --> 00:53:22,160
careful which registers we use

1256
00:53:22,160 --> 00:53:25,280
the best practice is just uh not to use

1257
00:53:25,280 --> 00:53:28,400
any registers uh unless uh

1258
00:53:28,400 --> 00:53:30,559
like you declare them here if you need

1259
00:53:30,559 --> 00:53:32,400
some register to all the

1260
00:53:32,400 --> 00:53:34,960
temporary value just declare a variable

1261
00:53:34,960 --> 00:53:36,160
and use it here

1262
00:53:36,160 --> 00:53:40,640
in the read or right section um

1263
00:53:40,640 --> 00:53:44,480
and uh now i'm going to show you

1264
00:53:44,480 --> 00:53:47,599
another instruction um and it

1265
00:53:47,599 --> 00:53:49,599
will be i think the first instruction

1266
00:53:49,599 --> 00:53:50,880
that actually uh

1267
00:53:50,880 --> 00:53:53,599
interacts with the status register that

1268
00:53:53,599 --> 00:53:55,440
sets some of the flex here

1269
00:53:55,440 --> 00:54:00,079
and that instruction is increment it

1270
00:54:00,079 --> 00:54:02,800
adds one to the content of this the

1271
00:54:02,800 --> 00:54:04,400
register so it gets

1272
00:54:04,400 --> 00:54:07,200
one register as an operand and it adds

1273
00:54:07,200 --> 00:54:08,000
one to the

1274
00:54:08,000 --> 00:54:11,119
content of that register and you can see

1275
00:54:11,119 --> 00:54:11,920
that it

1276
00:54:11,920 --> 00:54:15,040
modifies the flags now we are not going

1277
00:54:15,040 --> 00:54:17,040
to worry about this too much now we'll

1278
00:54:17,040 --> 00:54:19,280
talk about them in the next lesson

1279
00:54:19,280 --> 00:54:22,480
but uh for now let's just uh see

1280
00:54:22,480 --> 00:54:25,760
how we um take the value

1281
00:54:25,760 --> 00:54:29,040
of um of uh

1282
00:54:29,040 --> 00:54:31,839
this value increment it by one and then

1283
00:54:31,839 --> 00:54:32,640
put it back

1284
00:54:32,640 --> 00:54:35,760
into the uh into the variable

1285
00:54:35,760 --> 00:54:39,599
and uh first of all how do we

1286
00:54:39,599 --> 00:54:41,760
use multiple instructions how do we

1287
00:54:41,760 --> 00:54:43,680
avoid writing like

1288
00:54:43,680 --> 00:54:46,720
multiple asm statements so

1289
00:54:46,720 --> 00:54:49,280
one way to do it would be just to

1290
00:54:49,280 --> 00:54:50,000
introduce

1291
00:54:50,000 --> 00:54:54,319
a new line and you know then we can uh

1292
00:54:54,319 --> 00:54:57,680
have multiple instructions like here uh

1293
00:54:57,680 --> 00:54:59,440
so it ran this instruction and then

1294
00:54:59,440 --> 00:55:01,839
break um

1295
00:55:01,839 --> 00:55:04,640
that's not very readable the second way

1296
00:55:04,640 --> 00:55:06,160
would be just uh

1297
00:55:06,160 --> 00:55:08,160
to put these two strings and the

1298
00:55:08,160 --> 00:55:10,319
compiler would concatenate them

1299
00:55:10,319 --> 00:55:12,720
but we still have to remember this slash

1300
00:55:12,720 --> 00:55:14,640
n otherwise we would get

1301
00:55:14,640 --> 00:55:18,079
uh error because uh and it's a pretty

1302
00:55:18,079 --> 00:55:18,960
cryptic error

1303
00:55:18,960 --> 00:55:21,599
garbage at the end of line not very

1304
00:55:21,599 --> 00:55:24,480
useful for us

1305
00:55:25,040 --> 00:55:27,680
so uh there is actually a better way to

1306
00:55:27,680 --> 00:55:28,160
do it

1307
00:55:28,160 --> 00:55:30,400
and it's something that is specific to

1308
00:55:30,400 --> 00:55:31,839
the newer versions of c

1309
00:55:31,839 --> 00:55:34,720
plus plus i think it's called row string

1310
00:55:34,720 --> 00:55:36,400
literal or something like that

1311
00:55:36,400 --> 00:55:39,760
and the syntax goes like this our

1312
00:55:39,760 --> 00:55:43,119
quote mark and then open parenthesis

1313
00:55:43,119 --> 00:55:46,240
then we have all our instructions

1314
00:55:46,240 --> 00:55:50,319
and then we just uh close the quotes

1315
00:55:50,319 --> 00:55:55,440
so yeah again some more uh oh

1316
00:55:55,440 --> 00:55:59,280
and it doesn't work for some reason

1317
00:55:59,440 --> 00:56:01,760
oh yeah we need to close the parenthesis

1318
00:56:01,760 --> 00:56:02,559
inside

1319
00:56:02,559 --> 00:56:05,839
uh the quotes not outside them and just

1320
00:56:05,839 --> 00:56:07,280
one more piece of

1321
00:56:07,280 --> 00:56:11,839
awkward syntax to remember i know um

1322
00:56:11,839 --> 00:56:14,640
and then if we run it it will just run

1323
00:56:14,640 --> 00:56:16,559
these instructions one by one

1324
00:56:16,559 --> 00:56:19,119
and the big advantage is that now we can

1325
00:56:19,119 --> 00:56:19,760
uh

1326
00:56:19,760 --> 00:56:24,000
use these uh instructions um

1327
00:56:24,000 --> 00:56:27,119
like these uh variables these operands

1328
00:56:27,119 --> 00:56:28,079
in multiple

1329
00:56:28,079 --> 00:56:30,480
instructions the same operands so for

1330
00:56:30,480 --> 00:56:31,200
instance

1331
00:56:31,200 --> 00:56:34,720
we can say that we also want to be able

1332
00:56:34,720 --> 00:56:38,319
uh so equals mean right

1333
00:56:38,319 --> 00:56:41,200
to uh value we don't need the address

1334
00:56:41,200 --> 00:56:42,160
anymore

1335
00:56:42,160 --> 00:56:44,240
and then we can do something like that

1336
00:56:44,240 --> 00:56:46,640
ink

1337
00:56:46,640 --> 00:56:49,920
val and i haven't tried it before i hope

1338
00:56:49,920 --> 00:56:51,680
that it will work let's see

1339
00:56:51,680 --> 00:56:54,079
we don't need to print 4d because we

1340
00:56:54,079 --> 00:56:55,920
already print value

1341
00:56:55,920 --> 00:56:59,680
and it didn't compile because

1342
00:56:59,680 --> 00:57:03,440
yep um yeah

1343
00:57:03,440 --> 00:57:06,880
so in this case uh we can use

1344
00:57:06,880 --> 00:57:09,359
um

1345
00:57:11,440 --> 00:57:15,200
yeah i think there is another syntax

1346
00:57:15,200 --> 00:57:16,079
that tells it

1347
00:57:16,079 --> 00:57:18,480
that we want to use the same variable as

1348
00:57:18,480 --> 00:57:19,359
before

1349
00:57:19,359 --> 00:57:21,280
i don't remember it right now but we can

1350
00:57:21,280 --> 00:57:22,640
just give it a

1351
00:57:22,640 --> 00:57:24,960
a different name i guess we'll call it

1352
00:57:24,960 --> 00:57:25,760
val1

1353
00:57:25,760 --> 00:57:28,799
and then we'll call this vol and then

1354
00:57:28,799 --> 00:57:32,160
we can do uh move uh

1355
00:57:32,160 --> 00:57:36,160
so increment first of all let's copy

1356
00:57:36,160 --> 00:57:40,319
val into um uh

1357
00:57:40,319 --> 00:57:43,040
let's copy

1358
00:57:43,839 --> 00:57:47,599
cell 1 into uh val into l1

1359
00:57:47,599 --> 00:57:51,359
let's call it result that will be

1360
00:57:51,359 --> 00:57:53,680
easier to understand so let's copy vel

1361
00:57:53,680 --> 00:57:55,440
into result

1362
00:57:55,440 --> 00:57:58,559
and then let's

1363
00:57:58,559 --> 00:58:03,040
uh increment the result

1364
00:58:03,040 --> 00:58:06,319
and then print everything

1365
00:58:06,319 --> 00:58:09,359
and it didn't fail

1366
00:58:09,359 --> 00:58:11,680
impossible oh yeah we need to tell it

1367
00:58:11,680 --> 00:58:13,200
that this is a register

1368
00:58:13,200 --> 00:58:16,319
we can't just uh copy the value because

1369
00:58:16,319 --> 00:58:17,440
it won't be able

1370
00:58:17,440 --> 00:58:19,920
to write to this value it needs a

1371
00:58:19,920 --> 00:58:22,160
register for that

1372
00:58:22,160 --> 00:58:24,400
okay and now it worked and we see that

1373
00:58:24,400 --> 00:58:26,079
it incremented the value

1374
00:58:26,079 --> 00:58:29,040
so the first line copied this value into

1375
00:58:29,040 --> 00:58:30,960
some temporal register that would hold

1376
00:58:30,960 --> 00:58:32,160
the result

1377
00:58:32,160 --> 00:58:34,079
and then the second line incremented

1378
00:58:34,079 --> 00:58:36,079
that register

1379
00:58:36,079 --> 00:58:38,000
and there is also a syntax i don't

1380
00:58:38,000 --> 00:58:39,920
remember it right now i have to check it

1381
00:58:39,920 --> 00:58:40,960
that would

1382
00:58:40,960 --> 00:58:44,000
allow us to use the the same name

1383
00:58:44,000 --> 00:58:46,319
uh for both of them so we don't have to

1384
00:58:46,319 --> 00:58:47,200
do this

1385
00:58:47,200 --> 00:58:50,319
copy um but

1386
00:58:50,319 --> 00:58:52,960
you can find it here maybe that could be

1387
00:58:52,960 --> 00:58:54,079
your homework just

1388
00:58:54,079 --> 00:58:56,960
looking at this document and uh finding

1389
00:58:56,960 --> 00:58:57,280
it

1390
00:58:57,280 --> 00:59:00,640
here and uh we are pretty much uh

1391
00:59:00,640 --> 00:59:03,839
out of time um

1392
00:59:03,839 --> 00:59:06,640
uh we have we have covered quite a lot

1393
00:59:06,640 --> 00:59:07,599
and in the next

1394
00:59:07,599 --> 00:59:09,599
uh lesson we'll cover a few more

1395
00:59:09,599 --> 00:59:10,960
instructions like

1396
00:59:10,960 --> 00:59:14,079
uh all the arithmetic instructions but

1397
00:59:14,079 --> 00:59:16,720
if you feel curious you can like you

1398
00:59:16,720 --> 00:59:18,799
already have like the basic blocks that

1399
00:59:18,799 --> 00:59:19,839
you can use

1400
00:59:19,839 --> 00:59:23,040
to play around and uh you can try to

1401
00:59:23,040 --> 00:59:26,319
uh see how you like use the add

1402
00:59:26,319 --> 00:59:28,559
instruction to add to numbers

1403
00:59:28,559 --> 00:59:32,160
or like uh the uh if you feel really

1404
00:59:32,160 --> 00:59:33,680
adventurous there is a

1405
00:59:33,680 --> 00:59:36,000
multiply instruction and mold to

1406
00:59:36,000 --> 00:59:37,839
multiply two numbers

1407
00:59:37,839 --> 00:59:41,520
um and get a bit of sense of

1408
00:59:41,520 --> 00:59:44,559
how those uh instructions work

1409
00:59:44,559 --> 00:59:46,799
uh so there is the instruction manual

1410
00:59:46,799 --> 00:59:48,799
and you can consult it you can use this

1411
00:59:48,799 --> 00:59:49,920
freak to

1412
00:59:49,920 --> 00:59:52,480
print the values of registers and you

1413
00:59:52,480 --> 00:59:54,720
have this syntax i will actually copy it

1414
00:59:54,720 --> 00:59:56,160
over so

1415
00:59:56,160 --> 00:59:59,599
you have this as an example if you want

1416
00:59:59,599 --> 01:00:00,400
to

1417
01:00:00,400 --> 01:00:03,440
keep playing around

1418
01:00:03,839 --> 01:00:07,599
um and before we

1419
01:00:07,599 --> 01:00:10,720
move to the q and a

1420
01:00:10,720 --> 01:00:13,920
session which will be in just a moment

1421
01:00:13,920 --> 01:00:14,880
uh

1422
01:00:14,880 --> 01:00:18,319
i want to uh mention uh two more things

1423
01:00:18,319 --> 01:00:21,440
so first of all uh at the end of the

1424
01:00:21,440 --> 01:00:22,799
course we will have

1425
01:00:22,799 --> 01:00:26,240
um a final project where

1426
01:00:26,240 --> 01:00:29,280
it's optional uh but if you want to

1427
01:00:29,280 --> 01:00:31,680
get a certificate from hackaday you will

1428
01:00:31,680 --> 01:00:33,040
have to do it

1429
01:00:33,040 --> 01:00:34,960
we'll have some project where you will

1430
01:00:34,960 --> 01:00:36,960
have to write um

1431
01:00:36,960 --> 01:00:40,079
some assembly code that will do

1432
01:00:40,079 --> 01:00:40,880
something

1433
01:00:40,880 --> 01:00:44,000
we are still deciding what i think would

1434
01:00:44,000 --> 01:00:47,760
be maybe a seven segment cloak or some

1435
01:00:47,760 --> 01:00:48,160
game

1436
01:00:48,160 --> 01:00:50,160
if you have any ideas or things that you

1437
01:00:50,160 --> 01:00:52,400
want to do you are invited to

1438
01:00:52,400 --> 01:00:56,720
uh let me know and will come up with

1439
01:00:56,720 --> 01:00:59,680
will decide this week and let you know

1440
01:00:59,680 --> 01:01:01,119
um

1441
01:01:01,119 --> 01:01:04,240
and uh as always uh we have like

1442
01:01:04,240 --> 01:01:06,319
i think we have the link here there is

1443
01:01:06,319 --> 01:01:07,839
the discord channel so

1444
01:01:07,839 --> 01:01:10,000
if you want to catch me and ask any

1445
01:01:10,000 --> 01:01:11,280
questions you can

1446
01:01:11,280 --> 01:01:13,599
find me on this discord channel and

1447
01:01:13,599 --> 01:01:15,520
there is also like a chat on

1448
01:01:15,520 --> 01:01:18,960
hackaday io uh where you can also

1449
01:01:18,960 --> 01:01:21,440
um for this course where you can also

1450
01:01:21,440 --> 01:01:25,760
ask questions during the week

1451
01:01:25,760 --> 01:01:28,799
so uh that's basically it for today i

1452
01:01:28,799 --> 01:01:29,440
want

1453
01:01:29,440 --> 01:01:31,920
i really want you to feel comfortable

1454
01:01:31,920 --> 01:01:33,119
with just like

1455
01:01:33,119 --> 01:01:35,280
going through this instruction manual

1456
01:01:35,280 --> 01:01:36,559
and

1457
01:01:36,559 --> 01:01:38,400
you know learning about the different

1458
01:01:38,400 --> 01:01:40,079
instructions so i gave you a few

1459
01:01:40,079 --> 01:01:41,280
examples

1460
01:01:41,280 --> 01:01:49,839
and we'll continue with that next week

