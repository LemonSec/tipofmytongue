1
00:00:00,000 --> 00:00:06,660
[Music]

2
00:00:07,279 --> 00:00:08,240
hey

3
00:00:08,240 --> 00:00:11,280
great to see everyone even mr nello

4
00:00:11,280 --> 00:00:14,000
um you told me your name today but i

5
00:00:14,000 --> 00:00:14,960
forgot it

6
00:00:14,960 --> 00:00:18,080
so embarrassing anyway uh welcome back

7
00:00:18,080 --> 00:00:18,960
to the

8
00:00:18,960 --> 00:00:22,480
arduino avr uh reverse engineering and

9
00:00:22,480 --> 00:00:23,439
whatever class

10
00:00:23,439 --> 00:00:26,160
and great to have you back um i know

11
00:00:26,160 --> 00:00:27,359
last week has been

12
00:00:27,359 --> 00:00:30,080
uh a little last time has been a little

13
00:00:30,080 --> 00:00:32,159
intense and this time is going to be two

14
00:00:32,159 --> 00:00:32,960
so

15
00:00:32,960 --> 00:00:36,160
um before jumping right into the deep

16
00:00:36,160 --> 00:00:37,040
order

17
00:00:37,040 --> 00:00:40,320
um i just want to say that i hope that

18
00:00:40,320 --> 00:00:41,840
you had a great week

19
00:00:41,840 --> 00:00:44,800
and let me share my screen and just let

20
00:00:44,800 --> 00:00:45,920
me know in the chat

21
00:00:45,920 --> 00:00:49,200
if uh you can if everybody can see my

22
00:00:49,200 --> 00:00:49,680
screen

23
00:00:49,680 --> 00:00:53,920
as soon as i will share it in a moment

24
00:00:53,920 --> 00:00:57,280
so screen shared let's just make sure

25
00:00:57,280 --> 00:00:59,680
that i can see the chat

26
00:00:59,680 --> 00:01:02,640
while i'm sharing the screen and uh

27
00:01:02,640 --> 00:01:03,920
please let me know

28
00:01:03,920 --> 00:01:07,119
if you can see my screen

29
00:01:07,119 --> 00:01:10,159
there are like leds one of them should

30
00:01:10,159 --> 00:01:11,040
be blinking

31
00:01:11,040 --> 00:01:13,439
looks good thanks christina okay so

32
00:01:13,439 --> 00:01:14,320
great

33
00:01:14,320 --> 00:01:17,680
so um last time we uh

34
00:01:17,680 --> 00:01:20,080
walked through a couple of instructions

35
00:01:20,080 --> 00:01:20,960
in assembly

36
00:01:20,960 --> 00:01:24,799
we have met like this uh asm statement

37
00:01:24,799 --> 00:01:29,200
and this horrible syntax with uh

38
00:01:29,200 --> 00:01:31,439
things you want to write to and read

39
00:01:31,439 --> 00:01:33,840
from and they had a few questions

40
00:01:33,840 --> 00:01:36,960
uh in the following uh q and a session

41
00:01:36,960 --> 00:01:40,400
um and uh

42
00:01:40,400 --> 00:01:43,040
i i realized this is an awkward syntax

43
00:01:43,040 --> 00:01:44,079
like it

44
00:01:44,079 --> 00:01:46,240
i still i'm still not used to it and i

45
00:01:46,240 --> 00:01:47,759
make errors every time

46
00:01:47,759 --> 00:01:50,000
it's it doesn't look like c or c plus

47
00:01:50,000 --> 00:01:51,840
plus it's strange

48
00:01:51,840 --> 00:01:55,040
but um anyway it is what it is and

49
00:01:55,040 --> 00:01:58,560
today uh pretty um

50
00:01:58,560 --> 00:02:00,719
in in a few minutes we are going to see

51
00:02:00,719 --> 00:02:02,960
another way to write assembly which is

52
00:02:02,960 --> 00:02:06,640
a bit less awkward in my opinion so um

53
00:02:06,640 --> 00:02:09,520
last time uh we started talking about

54
00:02:09,520 --> 00:02:11,280
our arithmetic instructions

55
00:02:11,280 --> 00:02:14,560
specifically uh i think uh

56
00:02:14,560 --> 00:02:16,800
this is the instruction set and uh you

57
00:02:16,800 --> 00:02:18,480
have the link in this document

58
00:02:18,480 --> 00:02:22,080
and just uh so everybody have the link

59
00:02:22,080 --> 00:02:25,280
i just copied it to the chat so uh the

60
00:02:25,280 --> 00:02:26,080
instruction

61
00:02:26,080 --> 00:02:28,720
manual is linked from here the previous

62
00:02:28,720 --> 00:02:30,400
class documents and resources

63
00:02:30,400 --> 00:02:32,400
and now we are in the third class and

64
00:02:32,400 --> 00:02:34,000
we'll have a few more

65
00:02:34,000 --> 00:02:37,840
resources soon um so last time i think

66
00:02:37,840 --> 00:02:39,360
we stopped on the

67
00:02:39,360 --> 00:02:41,840
inc instruction uh it's the first

68
00:02:41,840 --> 00:02:42,959
instruction that

69
00:02:42,959 --> 00:02:46,000
uh is doing arithmetic before of that we

70
00:02:46,000 --> 00:02:46,400
just

71
00:02:46,400 --> 00:02:48,840
load the data and save data and move

72
00:02:48,840 --> 00:02:50,720
data

73
00:02:50,720 --> 00:02:54,560
between registers um so where is the

74
00:02:54,560 --> 00:02:57,920
ink ink ink

75
00:02:57,920 --> 00:03:01,680
okay increment so um we did it

76
00:03:01,680 --> 00:03:04,000
but let's do it real quick again just as

77
00:03:04,000 --> 00:03:05,120
a refresher

78
00:03:05,120 --> 00:03:07,280
uh so this is the name of the

79
00:03:07,280 --> 00:03:08,959
instruction the description

80
00:03:08,959 --> 00:03:13,040
it's it adds one one not minus one one

81
00:03:13,040 --> 00:03:14,720
to the contents of the register and

82
00:03:14,720 --> 00:03:17,519
places the result in the same register

83
00:03:17,519 --> 00:03:21,200
um and you can see like it can work on

84
00:03:21,200 --> 00:03:25,200
rd so ink rd and d can be between 0 to

85
00:03:25,200 --> 00:03:27,120
31 so it can work on

86
00:03:27,120 --> 00:03:29,200
any of the registers and if you need a

87
00:03:29,200 --> 00:03:31,200
refresher there is like a quick summary

88
00:03:31,200 --> 00:03:32,159
here

89
00:03:32,159 --> 00:03:35,120
about the registers that we have in avr

90
00:03:35,120 --> 00:03:37,040
there is actually one more which we will

91
00:03:37,040 --> 00:03:40,080
probably touch today the stack pointer

92
00:03:40,080 --> 00:03:43,599
but we'll get to that um

93
00:03:43,599 --> 00:03:46,799
so inky's

94
00:03:46,799 --> 00:03:48,720
and all the all the other automatic

95
00:03:48,720 --> 00:03:49,840
instructions

96
00:03:49,840 --> 00:03:53,120
actually uh updates this status and flex

97
00:03:53,120 --> 00:03:55,200
register that we have seen last time

98
00:03:55,200 --> 00:03:58,239
for instance it updates the uh z flag

99
00:03:58,239 --> 00:03:59,519
the zero flag

100
00:03:59,519 --> 00:04:02,480
and that flag is set to one if the

101
00:04:02,480 --> 00:04:04,000
result was zero

102
00:04:04,000 --> 00:04:07,360
and there is like this um

103
00:04:07,360 --> 00:04:09,360
flag and that tells us if it was

104
00:04:09,360 --> 00:04:11,680
negative um

105
00:04:11,680 --> 00:04:15,840
and uh if there was uh an overflow

106
00:04:15,840 --> 00:04:19,759
uh from uh signed integer to answer

107
00:04:19,759 --> 00:04:22,479
from answer like in if it was a side

108
00:04:22,479 --> 00:04:23,919
integer and there was an overflow but

109
00:04:23,919 --> 00:04:25,840
let's not worry about this for now

110
00:04:25,840 --> 00:04:28,880
let's just worry about z because it's

111
00:04:28,880 --> 00:04:31,040
going to be the most useful

112
00:04:31,040 --> 00:04:34,560
um anyway let's just

113
00:04:34,560 --> 00:04:39,520
uh do a quick demo so let's say we have

114
00:04:39,520 --> 00:04:42,240
value actually i want it to be just one

115
00:04:42,240 --> 00:04:43,040
byte

116
00:04:43,040 --> 00:04:46,720
you need eight so uh value

117
00:04:46,720 --> 00:04:50,080
is uh five never mind

118
00:04:50,080 --> 00:04:52,320
uh let's also set up the serial output

119
00:04:52,320 --> 00:04:54,639
so we can see

120
00:04:54,639 --> 00:04:58,479
the output uh and let serial println

121
00:04:58,479 --> 00:05:02,160
value and obviously this will be

122
00:05:02,160 --> 00:05:05,280
one okay why did that happen

123
00:05:05,280 --> 00:05:08,560
uh interesting i didn't expect that to

124
00:05:08,560 --> 00:05:10,950
happen that's strange

125
00:05:10,950 --> 00:05:14,060
[Music]

126
00:05:16,400 --> 00:05:20,400
i don't know why it prints one

127
00:05:22,639 --> 00:05:25,680
something is wrong um anyway let's

128
00:05:25,680 --> 00:05:28,400
try to refresh the page it may or may

129
00:05:28,400 --> 00:05:30,240
not help

130
00:05:30,240 --> 00:05:34,160
and try that again

131
00:05:35,759 --> 00:05:39,840
surely missing out something

132
00:05:43,440 --> 00:05:46,479
okay interesting

133
00:05:48,639 --> 00:05:53,000
oh yeah yeah yeah it should have been

134
00:05:53,000 --> 00:05:54,160
serial.begin.println

135
00:05:54,160 --> 00:05:56,560
uh so it tries to print that number and

136
00:05:56,560 --> 00:05:58,960
then we haven't set up the serial so

137
00:05:58,960 --> 00:06:00,960
uh it doesn't continue printing it just

138
00:06:00,960 --> 00:06:02,639
sends out the first character

139
00:06:02,639 --> 00:06:06,080
um okay so now this

140
00:06:06,080 --> 00:06:08,720
looks more sane so we have this and it

141
00:06:08,720 --> 00:06:09,680
prints five

142
00:06:09,680 --> 00:06:12,479
perfect and now let's just uh increment

143
00:06:12,479 --> 00:06:13,120
it

144
00:06:13,120 --> 00:06:16,080
and we we don't really know which

145
00:06:16,080 --> 00:06:17,120
register

146
00:06:17,120 --> 00:06:19,280
the compiler uses for this variable in

147
00:06:19,280 --> 00:06:21,199
fact it will probably optimize this to

148
00:06:21,199 --> 00:06:21,919
read as

149
00:06:21,919 --> 00:06:25,120
just real println five but um

150
00:06:25,120 --> 00:06:27,680
if we use the read we can actually uh

151
00:06:27,680 --> 00:06:29,440
force it to be copied uh

152
00:06:29,440 --> 00:06:32,080
into a register so we want it to be in a

153
00:06:32,080 --> 00:06:32,880
register

154
00:06:32,880 --> 00:06:37,440
and a value and then we can ink

155
00:06:37,440 --> 00:06:41,039
the first uh opera at the first operand

156
00:06:41,039 --> 00:06:42,080
which is

157
00:06:42,080 --> 00:06:45,600
r and this doesn't work

158
00:06:45,600 --> 00:06:48,160
because the compiler doesn't actually

159
00:06:48,160 --> 00:06:50,240
expect us to update value

160
00:06:50,240 --> 00:06:53,440
so we could use this syntax which tells

161
00:06:53,440 --> 00:06:54,319
its we want

162
00:06:54,319 --> 00:06:57,840
to write back to uh r

163
00:06:57,840 --> 00:06:59,919
but if we wanted to use the same

164
00:06:59,919 --> 00:07:01,360
register for both

165
00:07:01,360 --> 00:07:04,240
we can actually write here um instead of

166
00:07:04,240 --> 00:07:05,120
this r

167
00:07:05,120 --> 00:07:08,400
just the number of the argument so 0

168
00:07:08,400 --> 00:07:10,960
is like the same as this it tells the

169
00:07:10,960 --> 00:07:12,240
compiler

170
00:07:12,240 --> 00:07:14,800
i want you to use the same register or

171
00:07:14,800 --> 00:07:15,520
the same

172
00:07:15,520 --> 00:07:18,880
constraint as i defined here uh in this

173
00:07:18,880 --> 00:07:22,160
uh read so basically it will read uh the

174
00:07:22,160 --> 00:07:22,639
value

175
00:07:22,639 --> 00:07:24,800
from this register and then write it

176
00:07:24,800 --> 00:07:26,720
back to the same register

177
00:07:26,720 --> 00:07:28,880
and if we run it now we can see that we

178
00:07:28,880 --> 00:07:30,080
got six

179
00:07:30,080 --> 00:07:33,199
so um basically that's what ink does

180
00:07:33,199 --> 00:07:35,599
and uh like increment we also have

181
00:07:35,599 --> 00:07:36,479
decrement

182
00:07:36,479 --> 00:07:40,560
which is minus one and um

183
00:07:40,560 --> 00:07:44,639
the uh decrement like uh

184
00:07:44,639 --> 00:07:48,000
is pretty similar uh actually uh we

185
00:07:48,000 --> 00:07:48,720
don't need

186
00:07:48,720 --> 00:07:52,160
even need to uh look at the manual

187
00:07:52,160 --> 00:07:53,759
because it does the same

188
00:07:53,759 --> 00:07:56,400
uh to make it a bit more interesting we

189
00:07:56,400 --> 00:07:58,080
can also see how it affects

190
00:07:58,080 --> 00:08:01,680
the flag the flex

191
00:08:01,680 --> 00:08:05,919
multi-line assembly statement

192
00:08:06,479 --> 00:08:09,599
close the multiline

193
00:08:10,080 --> 00:08:13,360
okay so uh we have this trick where uh

194
00:08:13,360 --> 00:08:15,280
if we have this break it will print out

195
00:08:15,280 --> 00:08:16,479
the registers

196
00:08:16,479 --> 00:08:19,599
and um specifically

197
00:08:19,599 --> 00:08:21,599
when we decremented this value we can

198
00:08:21,599 --> 00:08:23,199
see like there were

199
00:08:23,199 --> 00:08:25,919
a bunch of registers set like the carry

200
00:08:25,919 --> 00:08:26,479
and

201
00:08:26,479 --> 00:08:29,680
the h um if we use

202
00:08:29,680 --> 00:08:33,440
increment again we can see um

203
00:08:33,440 --> 00:08:36,640
yeah yeah we can see like

204
00:08:36,640 --> 00:08:39,360
uh it's basically the same flex that

205
00:08:39,360 --> 00:08:40,320
were set

206
00:08:40,320 --> 00:08:44,080
and if we have here like uh this value

207
00:08:44,080 --> 00:08:47,120
then uh after incrementing it's one byte

208
00:08:47,120 --> 00:08:49,120
so it overflows to zero

209
00:08:49,120 --> 00:08:51,440
and we can see that the z register was

210
00:08:51,440 --> 00:08:52,240
set so

211
00:08:52,240 --> 00:08:55,360
uh just like uh the manual says uh where

212
00:08:55,360 --> 00:08:55,680
is

213
00:08:55,680 --> 00:08:59,839
increment uh that's increment yeah

214
00:08:59,839 --> 00:09:02,800
uh if the result is zero then uh we set

215
00:09:02,800 --> 00:09:03,200
the c

216
00:09:03,200 --> 00:09:06,399
the c flag so uh we can see verify here

217
00:09:06,399 --> 00:09:08,480
that it actually worked it actually said

218
00:09:08,480 --> 00:09:10,399
it's flag when the result was

219
00:09:10,399 --> 00:09:13,519
zero um just like

220
00:09:13,519 --> 00:09:16,800
ink and add we have uh instructions to

221
00:09:16,800 --> 00:09:18,959
shift right and shift left so for

222
00:09:18,959 --> 00:09:19,680
instance

223
00:09:19,680 --> 00:09:23,680
let's say we have this value of

224
00:09:23,680 --> 00:09:26,959
4 and we want to

225
00:09:26,959 --> 00:09:29,920
uh shift it left so basically shifting

226
00:09:29,920 --> 00:09:30,720
left is like

227
00:09:30,720 --> 00:09:34,000
multiplying by 2. so

228
00:09:34,000 --> 00:09:37,600
logical shift left zero uh

229
00:09:37,600 --> 00:09:40,160
the register name that's uh zero uh

230
00:09:40,160 --> 00:09:41,440
percent zero

231
00:09:41,440 --> 00:09:43,680
and uh we can see we got eight so

232
00:09:43,680 --> 00:09:46,000
basically multiplying by two

233
00:09:46,000 --> 00:09:49,040
and then we have shift right which is

234
00:09:49,040 --> 00:09:52,240
the equivalent of dividing by two and uh

235
00:09:52,240 --> 00:09:53,279
just like before

236
00:09:53,279 --> 00:09:56,320
they uh update the flags for example if

237
00:09:56,320 --> 00:09:57,519
we had one here

238
00:09:57,519 --> 00:10:00,240
and we would divide it by two uh we see

239
00:10:00,240 --> 00:10:02,160
that the zero flag has been set

240
00:10:02,160 --> 00:10:05,519
and a bunch of other flags so

241
00:10:05,519 --> 00:10:08,880
um basically these are like the basic

242
00:10:08,880 --> 00:10:09,839
operations

243
00:10:09,839 --> 00:10:13,200
of uh um shifting right and left

244
00:10:13,200 --> 00:10:16,800
incrementing decrementing another useful

245
00:10:16,800 --> 00:10:17,279
one

246
00:10:17,279 --> 00:10:21,200
is uh com which is just a complement

247
00:10:21,200 --> 00:10:21,760
which means

248
00:10:21,760 --> 00:10:26,079
bitwise not so if we have for instance 0

249
00:10:26,079 --> 00:10:30,720
the nut value of 0 is 255

250
00:10:30,720 --> 00:10:35,120
so bitwise not um we can actually see

251
00:10:35,120 --> 00:10:39,360
uh yeah basically bitwise not again

252
00:10:39,360 --> 00:10:43,120
uh you can check out the um

253
00:10:43,120 --> 00:10:47,120
the instruction manual and see

254
00:10:47,120 --> 00:10:50,399
how many uh cycles it takes one cycle

255
00:10:50,399 --> 00:10:53,920
and carry is always set to one after

256
00:10:53,920 --> 00:10:55,839
note and this one is always cleared and

257
00:10:55,839 --> 00:10:56,560
zero is

258
00:10:56,560 --> 00:11:02,240
only if the result is zero and um

259
00:11:02,240 --> 00:11:04,959
basically they all all the instructions

260
00:11:04,959 --> 00:11:07,680
the arithmetic instructions have uh

261
00:11:07,680 --> 00:11:11,600
a similar effect on the flex um

262
00:11:11,600 --> 00:11:15,839
okay and then um the next instruction

263
00:11:15,839 --> 00:11:19,360
um this one is uh i think

264
00:11:19,360 --> 00:11:23,200
uh it's a bit unique i'm not sure if it

265
00:11:23,200 --> 00:11:25,760
uh if there is such extraction on the

266
00:11:25,760 --> 00:11:27,440
x86 or other

267
00:11:27,440 --> 00:11:30,079
architectures it's called swap and what

268
00:11:30,079 --> 00:11:31,519
it does is basically

269
00:11:31,519 --> 00:11:35,839
uh swapping the nibbles of

270
00:11:35,839 --> 00:11:39,440
a byte so instead of 42 hexa once we run

271
00:11:39,440 --> 00:11:40,160
this

272
00:11:40,160 --> 00:11:42,560
we can see that now we have 24 so it

273
00:11:42,560 --> 00:11:43,440
just

274
00:11:43,440 --> 00:11:45,920
swaps the digits uh the hexadecimal

275
00:11:45,920 --> 00:11:46,480
digit

276
00:11:46,480 --> 00:11:49,600
of um the number so another useful

277
00:11:49,600 --> 00:11:50,720
instruction

278
00:11:50,720 --> 00:11:53,839
and uh let's just quickly write down the

279
00:11:53,839 --> 00:11:55,680
instructions that we covered

280
00:11:55,680 --> 00:11:58,800
that so that we won't forget so we had

281
00:11:58,800 --> 00:12:02,800
uh ink and deck we had um

282
00:12:02,800 --> 00:12:08,000
then lsl r shift right left

283
00:12:08,000 --> 00:12:11,120
and then we had uh comp which is bit

284
00:12:11,120 --> 00:12:12,240
while it's not

285
00:12:12,240 --> 00:12:15,360
and swap nibbles

286
00:12:15,360 --> 00:12:18,320
um so these are all uh unary

287
00:12:18,320 --> 00:12:20,399
instructions so they get one value

288
00:12:20,399 --> 00:12:22,880
and or run register and they work on the

289
00:12:22,880 --> 00:12:25,839
value in this register

290
00:12:26,000 --> 00:12:28,160
another instruction which is a binary

291
00:12:28,160 --> 00:12:29,040
instruction

292
00:12:29,040 --> 00:12:33,600
is sbr and there is also cbr

293
00:12:33,600 --> 00:12:38,000
and what they do are they let us um

294
00:12:38,000 --> 00:12:40,720
set a beat on a register so sbr sets bit

295
00:12:40,720 --> 00:12:42,000
in a register

296
00:12:42,000 --> 00:12:45,120
uh basically we give it a constant uh

297
00:12:45,120 --> 00:12:48,880
k some kind of constant and it will set

298
00:12:48,880 --> 00:12:50,880
all the bits in the constants

299
00:12:50,880 --> 00:12:53,360
uh to the on the register so it will do

300
00:12:53,360 --> 00:12:54,800
a bitwise or

301
00:12:54,800 --> 00:12:57,360
logical or between the contents of the

302
00:12:57,360 --> 00:12:58,160
register

303
00:12:58,160 --> 00:13:00,880
and the constant and this way it will

304
00:13:00,880 --> 00:13:03,040
allow us to set some bits in the

305
00:13:03,040 --> 00:13:06,320
uh register uh for instance

306
00:13:06,320 --> 00:13:09,360
uh we can uh we have this value

307
00:13:09,360 --> 00:13:12,560
42 we can set bit number

308
00:13:12,560 --> 00:13:15,920
uh one and then it will be

309
00:13:15,920 --> 00:13:19,839
43 and if we set bit number two which is

310
00:13:19,839 --> 00:13:21,760
already set in this case

311
00:13:21,760 --> 00:13:23,600
uh there won't be any effect we'll get

312
00:13:23,600 --> 00:13:24,880
the same result

313
00:13:24,880 --> 00:13:28,240
so sbr sets a bit um we have

314
00:13:28,240 --> 00:13:31,519
sbr and cbr uh

315
00:13:31,519 --> 00:13:34,800
similarly clears the given bits so

316
00:13:34,800 --> 00:13:38,320
this will actually clear that bit number

317
00:13:38,320 --> 00:13:42,079
two and then we are only left with 40.

318
00:13:42,079 --> 00:13:46,079
and we can also clear this uh this bit

319
00:13:46,079 --> 00:13:49,839
so basically cbr with this mask

320
00:13:49,839 --> 00:13:54,560
will uh clear this bit the uh 40 hexa

321
00:13:54,560 --> 00:13:57,600
that's the uh second most significant

322
00:13:57,600 --> 00:13:58,160
bit

323
00:13:58,160 --> 00:14:01,519
and we will be left with two so cbr is

324
00:14:01,519 --> 00:14:04,639
just uh uh steps and

325
00:14:04,639 --> 00:14:07,360
clear bits uh i'm hearing something in

326
00:14:07,360 --> 00:14:08,639
the audio is there

327
00:14:08,639 --> 00:14:12,160
anyone who okay

328
00:14:12,160 --> 00:14:16,720
probably just an artifact um

329
00:14:16,720 --> 00:14:19,839
cool so uh these are like uh

330
00:14:19,839 --> 00:14:22,079
all the operations the basic operations

331
00:14:22,079 --> 00:14:24,079
that uh work on a single register

332
00:14:24,079 --> 00:14:26,320
there are probably a few more like neg

333
00:14:26,320 --> 00:14:27,120
but

334
00:14:27,120 --> 00:14:29,040
they aren't really interesting right now

335
00:14:29,040 --> 00:14:30,480
and

336
00:14:30,480 --> 00:14:32,720
just like we did here you can you know

337
00:14:32,720 --> 00:14:33,760
find any of them

338
00:14:33,760 --> 00:14:35,920
in the manual if you encounter them or

339
00:14:35,920 --> 00:14:36,959
need them

340
00:14:36,959 --> 00:14:40,480
um and then there are a few um

341
00:14:40,480 --> 00:14:44,720
few operations that uh work on um

342
00:14:44,720 --> 00:14:46,880
two operations or two operands like

343
00:14:46,880 --> 00:14:48,480
adding two numbers so

344
00:14:48,480 --> 00:14:52,800
let's for instance value and value two

345
00:14:52,800 --> 00:14:57,600
so we want to add two and forty hexa

346
00:14:57,600 --> 00:15:00,800
and then we will add it as another

347
00:15:00,800 --> 00:15:04,160
register we get we read from actually

348
00:15:04,160 --> 00:15:05,920
let's give it a name

349
00:15:05,920 --> 00:15:09,120
so it will be easier to follow and then

350
00:15:09,120 --> 00:15:10,000
we add

351
00:15:10,000 --> 00:15:13,519
to the first register this one we add

352
00:15:13,519 --> 00:15:13,839
the

353
00:15:13,839 --> 00:15:16,000
value to actually let's give this one a

354
00:15:16,000 --> 00:15:19,360
name as well let's call it

355
00:15:19,360 --> 00:15:22,399
in one and

356
00:15:22,399 --> 00:15:25,680
here in one

357
00:15:25,680 --> 00:15:30,160
the same one and this will be in two

358
00:15:30,160 --> 00:15:33,360
and then add in one in

359
00:15:33,360 --> 00:15:37,279
two um and

360
00:15:37,279 --> 00:15:40,240
hopefully we'll get here 42 as it will

361
00:15:40,240 --> 00:15:42,079
be adding the two numbers

362
00:15:42,079 --> 00:15:45,040
and it's also uh let's make this a bit

363
00:15:45,040 --> 00:15:46,000
bigger

364
00:15:46,000 --> 00:15:49,120
yep it's also one more

365
00:15:49,120 --> 00:15:51,360
yep it's also updating the flag so in

366
00:15:51,360 --> 00:15:52,240
this case

367
00:15:52,240 --> 00:15:55,040
uh the result uh was not zero but for

368
00:15:55,040 --> 00:15:56,320
instance if we

369
00:15:56,320 --> 00:15:59,600
add two to uh fe

370
00:15:59,600 --> 00:16:03,279
exa then it will overflow and we'll have

371
00:16:03,279 --> 00:16:06,639
zero and carry uh so the result was zero

372
00:16:06,639 --> 00:16:09,199
that's why the zero flag was set and

373
00:16:09,199 --> 00:16:12,160
carry because

374
00:16:12,560 --> 00:16:16,079
f e plus two

375
00:16:16,079 --> 00:16:19,199
actually equals uh

376
00:16:19,199 --> 00:16:22,079
100 extra so this is the result but we

377
00:16:22,079 --> 00:16:22,639
got

378
00:16:22,639 --> 00:16:26,160
an overflow we got uh a carry uh

379
00:16:26,160 --> 00:16:28,160
another bit to the left which was

380
00:16:28,160 --> 00:16:30,160
omitted so it ended up in the

381
00:16:30,160 --> 00:16:33,600
carry flag um and

382
00:16:33,600 --> 00:16:37,040
um just like adding two numbers we can

383
00:16:37,040 --> 00:16:37,680
also

384
00:16:37,680 --> 00:16:41,440
uh subtract two numbers so uh

385
00:16:41,440 --> 00:16:44,560
this will basically do value

386
00:16:44,560 --> 00:16:48,399
uh minus value two so the result is one

387
00:16:48,399 --> 00:16:52,560
or twenty-two minus 1 is 15

388
00:16:52,560 --> 00:16:55,680
that's actually hexa so that's right so

389
00:16:55,680 --> 00:16:59,839
it should be 21 in decimal um

390
00:16:59,839 --> 00:17:03,040
so adding and subtracting and

391
00:17:03,040 --> 00:17:06,160
sub uh

392
00:17:06,160 --> 00:17:10,240
oh thanks for uh for this comment uh

393
00:17:10,240 --> 00:17:13,280
mikhail um yeah

394
00:17:13,280 --> 00:17:16,640
and um i think a few more useful

395
00:17:16,640 --> 00:17:19,839
are like uh bitwise and or

396
00:17:19,839 --> 00:17:22,959
and uh xor

397
00:17:22,959 --> 00:17:25,520
exclusive or one thing to note they

398
00:17:25,520 --> 00:17:26,160
don't

399
00:17:26,160 --> 00:17:30,480
call it xor they call it exclusive or er

400
00:17:30,480 --> 00:17:33,600
um and let's just uh you know do

401
00:17:33,600 --> 00:17:36,960
exclusive or between two numbers and

402
00:17:36,960 --> 00:17:39,360
sir when you sort two numbers that are

403
00:17:39,360 --> 00:17:41,120
the same value you get zero

404
00:17:41,120 --> 00:17:44,400
so let's try that and yeah we can see we

405
00:17:44,400 --> 00:17:45,200
got zero

406
00:17:45,200 --> 00:17:47,120
also the zero flag is set because the

407
00:17:47,120 --> 00:17:49,039
result is zero zero

408
00:17:49,039 --> 00:17:52,880
um and uh and and or

409
00:17:52,880 --> 00:17:55,840
they work similarly get two arguments

410
00:17:55,840 --> 00:17:56,320
and

411
00:17:56,320 --> 00:17:58,160
two registers and update the first

412
00:17:58,160 --> 00:18:00,160
register with the result of the

413
00:18:00,160 --> 00:18:03,440
operation so we have

414
00:18:03,440 --> 00:18:07,280
also and or and er which is

415
00:18:07,280 --> 00:18:10,960
sore which are just bitwise operations

416
00:18:10,960 --> 00:18:15,760
cool thanks for the edition mikhail

417
00:18:15,760 --> 00:18:17,679
okay so that is that's it with

418
00:18:17,679 --> 00:18:19,200
arithmetic instructions

419
00:18:19,200 --> 00:18:22,799
and right now uh we can uh there are a

420
00:18:22,799 --> 00:18:23,919
few more

421
00:18:23,919 --> 00:18:26,160
like multiplying numbers and dividing

422
00:18:26,160 --> 00:18:28,320
numbers and i encourage you to test

423
00:18:28,320 --> 00:18:32,000
check them out like uh mull and

424
00:18:32,000 --> 00:18:33,840
i think there is one for division i'm

425
00:18:33,840 --> 00:18:35,360
not sure actually i think there isn't

426
00:18:35,360 --> 00:18:38,400
uh division in the avr um

427
00:18:38,400 --> 00:18:42,799
as far as i remember i just multiplied

428
00:18:42,799 --> 00:18:46,080
yeah there isn't uh just uh shifting

429
00:18:46,080 --> 00:18:47,360
if you want if you want to divide

430
00:18:47,360 --> 00:18:48,799
numbers you have to write a code for

431
00:18:48,799 --> 00:18:50,320
that yourself

432
00:18:50,320 --> 00:18:53,520
uh isn't that hilarious anyway

433
00:18:53,520 --> 00:18:55,200
so there is uh instruction for

434
00:18:55,200 --> 00:18:57,200
multiplication add width carries

435
00:18:57,200 --> 00:18:58,480
subtract would carry

436
00:18:58,480 --> 00:19:02,320
and all of that but um let's go

437
00:19:02,320 --> 00:19:04,880
what happened here let's go over to the

438
00:19:04,880 --> 00:19:07,039
more interesting stuff

439
00:19:07,039 --> 00:19:09,679
so uh we know how to load data from the

440
00:19:09,679 --> 00:19:12,559
memory how to save data from the memory

441
00:19:12,559 --> 00:19:15,039
and how to uh perform arithmetic

442
00:19:15,039 --> 00:19:16,960
operations on it

443
00:19:16,960 --> 00:19:20,480
um but what about control flow

444
00:19:20,480 --> 00:19:22,960
so the first thing we are going to see

445
00:19:22,960 --> 00:19:24,559
is actually this

446
00:19:24,559 --> 00:19:27,600
useful instruction it's called jump

447
00:19:27,600 --> 00:19:30,960
and it lets you um go to a different

448
00:19:30,960 --> 00:19:32,240
location in the program

449
00:19:32,240 --> 00:19:35,840
just like the go to

450
00:19:35,840 --> 00:19:38,880
the go to keyword in c that you should

451
00:19:38,880 --> 00:19:41,520
never use

452
00:19:41,600 --> 00:19:44,160
so basically the syntax is jump and

453
00:19:44,160 --> 00:19:45,120
where to jump

454
00:19:45,120 --> 00:19:49,280
and um we can give it an offset like uh

455
00:19:49,280 --> 00:19:52,480
100 and it will jump to location 100 in

456
00:19:52,480 --> 00:19:53,600
the program

457
00:19:53,600 --> 00:19:55,760
but we don't really know where we will

458
00:19:55,760 --> 00:19:57,520
end up unless we end up

459
00:19:57,520 --> 00:20:00,720
we write all the instructions and

460
00:20:00,720 --> 00:20:04,240
figure out their uh calculator addresses

461
00:20:04,240 --> 00:20:07,440
uh so we can use labels like uh let's

462
00:20:07,440 --> 00:20:10,640
jump to before and before just uh define

463
00:20:10,640 --> 00:20:11,440
before just

464
00:20:11,440 --> 00:20:13,600
after the jump and that would create an

465
00:20:13,600 --> 00:20:14,880
endless loop so

466
00:20:14,880 --> 00:20:17,760
if i run the program you can see it sort

467
00:20:17,760 --> 00:20:18,080
of

468
00:20:18,080 --> 00:20:20,080
got stuck here it never printed the

469
00:20:20,080 --> 00:20:23,039
value and the break was not executed

470
00:20:23,039 --> 00:20:26,480
or i can jump forward

471
00:20:26,480 --> 00:20:30,240
let's jump to after and

472
00:20:30,240 --> 00:20:33,120
yeah so after the break and you can see

473
00:20:33,120 --> 00:20:33,600
that

474
00:20:33,600 --> 00:20:36,320
the break didn't uh execute so i didn't

475
00:20:36,320 --> 00:20:38,320
get the debugging for the console

476
00:20:38,320 --> 00:20:41,440
so um yeah so

477
00:20:41,440 --> 00:20:45,440
um that's jump and by itself it's

478
00:20:45,440 --> 00:20:48,559
not very useful so how can we

479
00:20:48,559 --> 00:20:52,000
um how can we make some kind of

480
00:20:52,000 --> 00:20:54,400
conditional jump jump if

481
00:20:54,400 --> 00:20:58,080
and the answer for that um

482
00:20:58,080 --> 00:21:01,760
there are like a bunch of instructions

483
00:21:01,760 --> 00:21:02,960
which are called

484
00:21:02,960 --> 00:21:06,400
conditional branches which are just like

485
00:21:06,400 --> 00:21:07,520
jmp but

486
00:21:07,520 --> 00:21:10,320
they jump depending on the value of the

487
00:21:10,320 --> 00:21:11,840
um

488
00:21:11,840 --> 00:21:14,720
the flex so they are defined here in

489
00:21:14,720 --> 00:21:17,200
conditional brands summary

490
00:21:17,200 --> 00:21:20,159
and basically there is a bunch of them

491
00:21:20,159 --> 00:21:21,039
and we'll go

492
00:21:21,039 --> 00:21:24,640
over it in a moment but first of all you

493
00:21:24,640 --> 00:21:25,440
need to

494
00:21:25,440 --> 00:21:28,159
uh you can see here that they all like

495
00:21:28,159 --> 00:21:29,120
look at the flex

496
00:21:29,120 --> 00:21:31,600
and decide based on deflects on this

497
00:21:31,600 --> 00:21:33,520
condition whether they should jump

498
00:21:33,520 --> 00:21:37,360
for instance uh we can jump if

499
00:21:37,360 --> 00:21:41,200
it's zero or jump if not zero

500
00:21:41,200 --> 00:21:43,840
um like if the zero flag is set or if

501
00:21:43,840 --> 00:21:44,240
it's

502
00:21:44,240 --> 00:21:47,600
not set and um

503
00:21:47,600 --> 00:21:50,400
what we can uh do for instance so we

504
00:21:50,400 --> 00:21:51,520
know this uh

505
00:21:51,520 --> 00:21:55,919
e or only x uh will return zero if these

506
00:21:55,919 --> 00:21:58,880
values are equal because that's what

507
00:21:58,880 --> 00:22:00,720
sword has we have just seen that

508
00:22:00,720 --> 00:22:03,919
so for instance we can say instead of

509
00:22:03,919 --> 00:22:06,799
jumping over break we can say that we

510
00:22:06,799 --> 00:22:07,280
want

511
00:22:07,280 --> 00:22:10,320
to jump

512
00:22:10,320 --> 00:22:14,000
to after only if uh it's the result is

513
00:22:14,000 --> 00:22:15,280
not zero so that's

514
00:22:15,280 --> 00:22:18,720
uh brne um so

515
00:22:18,720 --> 00:22:22,000
um let's do that so

516
00:22:22,000 --> 00:22:26,080
um now when i run the program

517
00:22:26,080 --> 00:22:29,760
uh we can see that uh

518
00:22:30,400 --> 00:22:33,520
interesting it

519
00:22:34,880 --> 00:22:38,640
oh yeah it's not zero so it didn't jump

520
00:22:38,640 --> 00:22:41,840
so uh the result is zero so this jump

521
00:22:41,840 --> 00:22:42,640
didn't happen

522
00:22:42,640 --> 00:22:45,919
and we had this output but if the result

523
00:22:45,919 --> 00:22:46,960
would have been different

524
00:22:46,960 --> 00:22:51,600
like 54 and 50 which would not give zero

525
00:22:51,600 --> 00:22:53,679
then uh it would take the branch because

526
00:22:53,679 --> 00:22:54,720
the result is not

527
00:22:54,720 --> 00:22:57,440
zero and we won't get a debug output so

528
00:22:57,440 --> 00:22:58,159
basically

529
00:22:58,159 --> 00:23:01,200
uh once we uh perform some kind of

530
00:23:01,200 --> 00:23:02,880
arithmetic instruction

531
00:23:02,880 --> 00:23:05,200
we can use the result in the flex in

532
00:23:05,200 --> 00:23:06,640
order to conditionally

533
00:23:06,640 --> 00:23:10,000
branch to another place and that's how

534
00:23:10,000 --> 00:23:11,200
we implement

535
00:23:11,200 --> 00:23:14,480
we implement conditional logic

536
00:23:14,480 --> 00:23:19,360
and and also loops and

537
00:23:19,520 --> 00:23:22,159
before we see a more complex example i

538
00:23:22,159 --> 00:23:23,440
will show you one more

539
00:23:23,440 --> 00:23:25,919
useful instruction and it's super useful

540
00:23:25,919 --> 00:23:28,400
with those branch instructions

541
00:23:28,400 --> 00:23:31,280
because usually you want just to compare

542
00:23:31,280 --> 00:23:33,120
two numbers and you don't care about the

543
00:23:33,120 --> 00:23:33,919
result

544
00:23:33,919 --> 00:23:36,880
here the exclusive or actually stores

545
00:23:36,880 --> 00:23:37,679
the result

546
00:23:37,679 --> 00:23:40,799
into in one so there is another

547
00:23:40,799 --> 00:23:41,919
instructions

548
00:23:41,919 --> 00:23:45,200
instruction called cp compare

549
00:23:45,200 --> 00:23:48,240
and it compares to register and none of

550
00:23:48,240 --> 00:23:50,720
the registers are changed

551
00:23:50,720 --> 00:23:52,720
and all conditional branches can be used

552
00:23:52,720 --> 00:23:54,400
after his instruction

553
00:23:54,400 --> 00:23:56,880
so basically this instruction just

554
00:23:56,880 --> 00:23:57,440
checks

555
00:23:57,440 --> 00:24:00,799
uh compares these registers and

556
00:24:00,799 --> 00:24:03,120
updates the flex whether the result was

557
00:24:03,120 --> 00:24:04,080
negative or

558
00:24:04,080 --> 00:24:07,120
positive and the nice thing about it you

559
00:24:07,120 --> 00:24:08,720
don't really have to worry about the

560
00:24:08,720 --> 00:24:09,840
meaning of the flags

561
00:24:09,840 --> 00:24:12,799
uh if you check out the table uh that we

562
00:24:12,799 --> 00:24:14,400
have seen before this

563
00:24:14,400 --> 00:24:18,559
summary um we can just like uh

564
00:24:18,559 --> 00:24:21,120
call compare with two registers and then

565
00:24:21,120 --> 00:24:21,840
uh

566
00:24:21,840 --> 00:24:23,679
choose the condition that we want let's

567
00:24:23,679 --> 00:24:25,760
see how we do that in practice

568
00:24:25,760 --> 00:24:29,039
so we are going to define a new function

569
00:24:29,039 --> 00:24:31,760
uh we'll call it uh max 8 and in

570
00:24:31,760 --> 00:24:32,320
function

571
00:24:32,320 --> 00:24:34,880
this function gets two arguments let's

572
00:24:34,880 --> 00:24:35,440
call it

573
00:24:35,440 --> 00:24:39,679
uh left and right

574
00:24:39,679 --> 00:24:42,400
and uh basically what it's going to do

575
00:24:42,400 --> 00:24:44,559
it's going to compare them

576
00:24:44,559 --> 00:24:47,600
and then um return the maximum

577
00:24:47,600 --> 00:24:50,240
of them so let's have another variable

578
00:24:50,240 --> 00:24:50,640
for

579
00:24:50,640 --> 00:24:54,240
to hold the result and then we can uh

580
00:24:54,240 --> 00:24:58,000
just uh copy this that's what i always

581
00:24:58,000 --> 00:25:00,080
do within my assembly just copy it

582
00:25:00,080 --> 00:25:02,400
instead of writing this from scratch

583
00:25:02,400 --> 00:25:05,039
and uh we can start writing the logic

584
00:25:05,039 --> 00:25:06,880
here first of all

585
00:25:06,880 --> 00:25:10,480
we want to store the result into

586
00:25:10,480 --> 00:25:14,880
result and we want to read from

587
00:25:14,880 --> 00:25:18,480
a register left

588
00:25:18,480 --> 00:25:21,600
and another register

589
00:25:21,600 --> 00:25:24,960
right and let's call them right and left

590
00:25:24,960 --> 00:25:26,559
in assembly as well

591
00:25:26,559 --> 00:25:28,400
so these are the names we'll use inside

592
00:25:28,400 --> 00:25:30,159
the assembly these are the variables we

593
00:25:30,159 --> 00:25:31,520
are reading from or

594
00:25:31,520 --> 00:25:34,320
writing to and then we are going to

595
00:25:34,320 --> 00:25:35,039
compare them

596
00:25:35,039 --> 00:25:39,279
so comparing uh

597
00:25:39,279 --> 00:25:43,520
left and right and uh

598
00:25:43,520 --> 00:25:46,559
i have two rights uh do hi where

599
00:25:46,559 --> 00:25:49,600
uh if you mean here oh here yeah right

600
00:25:49,600 --> 00:25:53,440
thanks uh thanks uh maro

601
00:25:53,440 --> 00:25:56,640
um and if i have

602
00:25:56,640 --> 00:25:59,760
uh so i compare these two numbers and

603
00:25:59,760 --> 00:26:02,159
now i want to decide what to do

604
00:26:02,159 --> 00:26:06,480
so uh basically if left is bigger

605
00:26:06,480 --> 00:26:10,960
store left into result otherwise

606
00:26:10,960 --> 00:26:14,240
store write into result

607
00:26:14,240 --> 00:26:16,880
so the first thing i want to do before i

608
00:26:16,880 --> 00:26:18,240
jump into the table

609
00:26:18,240 --> 00:26:21,520
i want to see if i'm doing this with

610
00:26:21,520 --> 00:26:24,480
signed integers or unsigned integers and

611
00:26:24,480 --> 00:26:27,279
in this case i'm using unsigned integers

612
00:26:27,279 --> 00:26:29,919
so when i'm looking at the table i will

613
00:26:29,919 --> 00:26:31,600
only look at this section

614
00:26:31,600 --> 00:26:34,799
which is talking about unsigned i don't

615
00:26:34,799 --> 00:26:36,720
care about assigned now i'm looking at

616
00:26:36,720 --> 00:26:38,080
the sign section

617
00:26:38,080 --> 00:26:41,760
and now i want to check if um

618
00:26:41,760 --> 00:26:45,039
rd is greater or equal than

619
00:26:45,039 --> 00:26:49,039
rr and uh for that i can use this

620
00:26:49,039 --> 00:26:50,360
instruction

621
00:26:50,360 --> 00:26:52,799
brsh um

622
00:26:52,799 --> 00:26:56,639
yeah funny

623
00:26:56,880 --> 00:27:00,799
so brsh

624
00:27:00,799 --> 00:27:05,520
and so brsh

625
00:27:05,520 --> 00:27:08,640
and we'll go to uh left

626
00:27:08,640 --> 00:27:11,840
is greater is

627
00:27:11,840 --> 00:27:16,159
greater so if left is greater or equal

628
00:27:16,159 --> 00:27:20,000
uh then we will oh s8 stands for same or

629
00:27:20,000 --> 00:27:23,279
higher and i guess if uh we will

630
00:27:23,279 --> 00:27:26,640
check yeah same fire thanks uh mikhail

631
00:27:26,640 --> 00:27:30,399
uh yeah and that's also

632
00:27:30,399 --> 00:27:35,120
and other branches and we also had a cp

633
00:27:35,120 --> 00:27:39,679
compared to registers okay

634
00:27:39,679 --> 00:27:42,720
so uh if this is same or higher

635
00:27:42,720 --> 00:27:46,399
then we are going to this

636
00:27:46,399 --> 00:27:50,000
left is greater than eq otherwise

637
00:27:50,000 --> 00:27:53,279
uh we are just we know that right is uh

638
00:27:53,279 --> 00:27:56,640
greater so we will move uh we'll copy it

639
00:27:56,640 --> 00:27:59,440
into result

640
00:28:00,000 --> 00:28:03,440
right and if left oh and

641
00:28:03,440 --> 00:28:06,480
uh we don't want to execute the code in

642
00:28:06,480 --> 00:28:08,640
leftist greater so we'll need to

643
00:28:08,640 --> 00:28:11,919
use jump here and jump uh to the end

644
00:28:11,919 --> 00:28:15,120
so jumping to the end and

645
00:28:15,120 --> 00:28:17,679
uh if left is greater then we just want

646
00:28:17,679 --> 00:28:18,480
to move

647
00:28:18,480 --> 00:28:22,480
um left into the result

648
00:28:22,480 --> 00:28:25,679
and now hopefully we have a function

649
00:28:25,679 --> 00:28:27,840
that compiles and works we don't need

650
00:28:27,840 --> 00:28:29,440
those comments

651
00:28:29,440 --> 00:28:33,520
um and um

652
00:28:33,520 --> 00:28:36,880
i will compile it and let's actually

653
00:28:36,880 --> 00:28:40,399
print some use the test cases already so

654
00:28:40,399 --> 00:28:43,760
uh max 8 of

655
00:28:43,760 --> 00:28:47,360
10 and 20 and

656
00:28:47,360 --> 00:28:51,440
20 and 10 and some edge cases like

657
00:28:51,440 --> 00:28:55,559
0 and 255 0 and -1 which is

658
00:28:55,559 --> 00:29:00,639
255 because these are unsigned integers

659
00:29:00,960 --> 00:29:03,520
and let's run this and we can see that

660
00:29:03,520 --> 00:29:04,480
uh

661
00:29:04,480 --> 00:29:08,880
it doesn't work maximum of 10 and 20

662
00:29:08,880 --> 00:29:12,399
is not 10. this works

663
00:29:12,399 --> 00:29:16,480
so it seems to always return the

664
00:29:16,480 --> 00:29:20,720
left argument let's try to figure out

665
00:29:20,720 --> 00:29:26,080
what's the reason for that

666
00:29:26,080 --> 00:29:30,000
um yeah um

667
00:29:30,000 --> 00:29:33,679
first of all let's check um

668
00:29:33,679 --> 00:29:38,840
so let's call it only once with

669
00:29:38,840 --> 00:29:41,520
actually here it should return 20.

670
00:29:41,520 --> 00:29:44,320
so let's call it only once and then add

671
00:29:44,320 --> 00:29:45,520
a break here

672
00:29:45,520 --> 00:29:48,960
so we can see what's going on and we can

673
00:29:48,960 --> 00:29:51,919
see that uh it took the branch

674
00:29:51,919 --> 00:29:53,039
interesting

675
00:29:53,039 --> 00:29:56,080
oh it didn't it took the branch left is

676
00:29:56,080 --> 00:29:56,559
greater

677
00:29:56,559 --> 00:30:00,000
even though the right value is greater

678
00:30:00,000 --> 00:30:03,200
in this case um

679
00:30:03,200 --> 00:30:06,640
because if we put a break here we can

680
00:30:06,640 --> 00:30:09,440
oh it doesn't print the debug output

681
00:30:09,440 --> 00:30:12,080
interesting

682
00:30:14,880 --> 00:30:16,720
interesting we don't get any debug

683
00:30:16,720 --> 00:30:17,919
output at all at

684
00:30:17,919 --> 00:30:20,960
all here uh did we

685
00:30:20,960 --> 00:30:23,840
call

686
00:30:26,399 --> 00:30:29,120
um let's see

687
00:30:29,120 --> 00:30:33,279
[Music]

688
00:30:33,279 --> 00:30:35,760
just a sanity check that we get into

689
00:30:35,760 --> 00:30:37,679
this function

690
00:30:37,679 --> 00:30:42,000
yep and let's print left

691
00:30:42,320 --> 00:30:45,679
and right yeah it works so

692
00:30:45,679 --> 00:30:48,240
uh what's happened what happens with the

693
00:30:48,240 --> 00:30:48,880
asm

694
00:30:48,880 --> 00:30:52,480
statement and uh

695
00:30:52,480 --> 00:30:56,960
i have an idea what it might be

696
00:30:56,960 --> 00:31:00,159
no interesting

697
00:31:00,159 --> 00:31:02,640
let's just narrow it down for instance

698
00:31:02,640 --> 00:31:03,519
for a second

699
00:31:03,519 --> 00:31:07,279
to okay that's interesting

700
00:31:07,279 --> 00:31:10,480
uh one more thing to that

701
00:31:10,480 --> 00:31:13,840
oh okay so uh this is

702
00:31:13,840 --> 00:31:16,559
something that sometimes happens the

703
00:31:16,559 --> 00:31:18,159
compiler figures out

704
00:31:18,159 --> 00:31:21,039
that disassembly is not needed for

705
00:31:21,039 --> 00:31:22,880
whatever optimization reasons

706
00:31:22,880 --> 00:31:26,159
and just removes it all together so

707
00:31:26,159 --> 00:31:28,880
using the keyword volatile can actually

708
00:31:28,880 --> 00:31:29,919
help here

709
00:31:29,919 --> 00:31:33,200
and the reason uh the compiler optimized

710
00:31:33,200 --> 00:31:33,679
this

711
00:31:33,679 --> 00:31:36,880
output is this uh code out

712
00:31:36,880 --> 00:31:41,760
is pretty simple uh we um

713
00:31:41,760 --> 00:31:44,000
do the calculation and store it into

714
00:31:44,000 --> 00:31:46,320
result but we do nothing with result

715
00:31:46,320 --> 00:31:50,000
so basically what happened is that uh

716
00:31:50,000 --> 00:31:52,880
the compiler so this code and then okay

717
00:31:52,880 --> 00:31:53,760
it does something

718
00:31:53,760 --> 00:31:56,159
stores the result or introduced variable

719
00:31:56,159 --> 00:31:57,919
but nobody is using this variable

720
00:31:57,919 --> 00:32:00,480
so uh i'm just going to optimize that

721
00:32:00,480 --> 00:32:01,200
out

722
00:32:01,200 --> 00:32:04,240
and that's the reason why when we called

723
00:32:04,240 --> 00:32:04,960
break

724
00:32:04,960 --> 00:32:06,799
we didn't see anything in the console

725
00:32:06,799 --> 00:32:08,240
because this code was

726
00:32:08,240 --> 00:32:11,279
never emitted and then volatile is a

727
00:32:11,279 --> 00:32:13,519
special keyword that tells the compiler

728
00:32:13,519 --> 00:32:16,000
you know what never optimize this code

729
00:32:16,000 --> 00:32:16,799
away

730
00:32:16,799 --> 00:32:18,960
and when we added volatile we can see

731
00:32:18,960 --> 00:32:21,039
that this code is executed and we have

732
00:32:21,039 --> 00:32:22,240
seen the break

733
00:32:22,240 --> 00:32:25,519
and this helped me figure out that

734
00:32:25,519 --> 00:32:28,399
normally this code didn't execute it was

735
00:32:28,399 --> 00:32:30,399
optimized out and then i realized that

736
00:32:30,399 --> 00:32:32,320
this is because we forgot to return

737
00:32:32,320 --> 00:32:34,399
results so let's do that

738
00:32:34,399 --> 00:32:39,039
um and let's return all the test cases

739
00:32:39,039 --> 00:32:42,080
and now let's also remove this print so

740
00:32:42,080 --> 00:32:45,440
it won't confuse that confuse us and now

741
00:32:45,440 --> 00:32:47,840
running it again we get expected results

742
00:32:47,840 --> 00:32:48,320
so

743
00:32:48,320 --> 00:32:54,240
2020 and 255 255 that's the maximum

744
00:32:54,240 --> 00:32:58,240
now um just uh to show you

745
00:32:58,240 --> 00:33:01,279
uh what would happen if we use the

746
00:33:01,279 --> 00:33:05,440
signed instructions uh so that was

747
00:33:05,440 --> 00:33:08,640
signed branches so instead of using

748
00:33:08,640 --> 00:33:11,919
brsh we could have used brge which is

749
00:33:11,919 --> 00:33:14,799
the signed version of this condition

750
00:33:14,799 --> 00:33:18,080
then we would get something different

751
00:33:18,080 --> 00:33:22,000
suddenly zero is greater than 255

752
00:33:22,000 --> 00:33:23,760
because this number is no longer

753
00:33:23,760 --> 00:33:25,200
interpreted as a

754
00:33:25,200 --> 00:33:27,519
positive integer it's interpreted as

755
00:33:27,519 --> 00:33:29,200
minus one

756
00:33:29,200 --> 00:33:32,640
um so yeah so

757
00:33:32,640 --> 00:33:35,279
uh bs is adding in the chat that

758
00:33:35,279 --> 00:33:37,440
volatile is also useful

759
00:33:37,440 --> 00:33:38,880
for the same reason when debugging

760
00:33:38,880 --> 00:33:41,039
because often some parts of the code are

761
00:33:41,039 --> 00:33:43,120
optimized out and no longer match the c

762
00:33:43,120 --> 00:33:43,919
source

763
00:33:43,919 --> 00:33:46,240
that's true and you can also define

764
00:33:46,240 --> 00:33:48,320
variables volatile so if we had this

765
00:33:48,320 --> 00:33:50,480
variable volatile then

766
00:33:50,480 --> 00:33:52,640
assembly would uh the compiler would see

767
00:33:52,640 --> 00:33:53,679
we are referencing

768
00:33:53,679 --> 00:33:56,960
it inside the asm statement and it would

769
00:33:56,960 --> 00:33:57,279
not

770
00:33:57,279 --> 00:34:00,159
optimize it away so i think uh if you

771
00:34:00,159 --> 00:34:02,320
are writing inline assembly it's best to

772
00:34:02,320 --> 00:34:02,880
start

773
00:34:02,880 --> 00:34:04,960
with volatile probably and then remove

774
00:34:04,960 --> 00:34:06,640
it and

775
00:34:06,640 --> 00:34:08,879
as you have seen it it really helps you

776
00:34:08,879 --> 00:34:09,679
catching backs

777
00:34:09,679 --> 00:34:11,918
if you see that the behavior changes

778
00:34:11,918 --> 00:34:14,719
when volatile is not there

779
00:34:14,719 --> 00:34:18,800
um so um

780
00:34:18,800 --> 00:34:20,879
and yeah somebody also mentioned

781
00:34:20,879 --> 00:34:22,320
interrupts so

782
00:34:22,320 --> 00:34:24,560
defining a variable as volatile is also

783
00:34:24,560 --> 00:34:25,679
useful if it's

784
00:34:25,679 --> 00:34:28,480
accessed from interrupts but that's out

785
00:34:28,480 --> 00:34:30,000
of scope right now

786
00:34:30,000 --> 00:34:32,719
so yeah so we implemented our first

787
00:34:32,719 --> 00:34:34,560
logic in assembly

788
00:34:34,560 --> 00:34:38,399
and there is a little problem that you

789
00:34:38,399 --> 00:34:40,159
should be aware of

790
00:34:40,159 --> 00:34:44,000
with those labels so actually

791
00:34:44,000 --> 00:34:47,599
let's say i want to

792
00:34:47,599 --> 00:34:50,480
change this code and call this one end

793
00:34:50,480 --> 00:34:51,520
as well

794
00:34:51,520 --> 00:34:55,440
and i will try to compile it and

795
00:34:55,440 --> 00:34:58,160
actually did compile because i think

796
00:34:58,160 --> 00:34:59,040
this one was

797
00:34:59,040 --> 00:35:02,240
optimized away yep now it

798
00:35:02,240 --> 00:35:03,760
wasn't um

799
00:35:03,760 --> 00:35:05,359
[Music]

800
00:35:05,359 --> 00:35:08,720
again i calculated something and i

801
00:35:08,720 --> 00:35:10,400
didn't print the value i didn't use it

802
00:35:10,400 --> 00:35:12,560
so it was optimized so that way

803
00:35:12,560 --> 00:35:14,800
it wasn't compiled but now it was

804
00:35:14,800 --> 00:35:16,800
compiled and the assembler tell me

805
00:35:16,800 --> 00:35:20,160
and is already defined and that's an

806
00:35:20,160 --> 00:35:22,480
issue with those labels because they are

807
00:35:22,480 --> 00:35:23,359
global

808
00:35:23,359 --> 00:35:26,480
in the entire source file so uh

809
00:35:26,480 --> 00:35:29,200
just like that i couldn't use a label

810
00:35:29,200 --> 00:35:31,359
that matches the name of function like

811
00:35:31,359 --> 00:35:33,839
if i call it setup

812
00:35:33,839 --> 00:35:36,960
for some reason it worked

813
00:35:36,960 --> 00:35:39,040
probably because that's a c plus plus

814
00:35:39,040 --> 00:35:41,359
function we'll talk about it in a moment

815
00:35:41,359 --> 00:35:44,560
but if i called it for instance i think

816
00:35:44,560 --> 00:35:46,400
digitalwrite for instance

817
00:35:46,400 --> 00:35:49,599
is a c function let's check that

818
00:35:49,599 --> 00:35:54,800
no interesting um or maybe start

819
00:35:54,800 --> 00:35:58,240
yep so for some reason uh

820
00:35:58,240 --> 00:36:00,880
i guess the cd plus plus name mangling

821
00:36:00,880 --> 00:36:01,440
doesn't

822
00:36:01,440 --> 00:36:04,960
uh doesn't uh changes the name of the

823
00:36:04,960 --> 00:36:06,000
function so

824
00:36:06,000 --> 00:36:08,960
uh it doesn't make a problem but still

825
00:36:08,960 --> 00:36:10,480
they are global like

826
00:36:10,480 --> 00:36:13,280
i can't use and in two different places

827
00:36:13,280 --> 00:36:14,640
that would fail

828
00:36:14,640 --> 00:36:17,520
so uh there are a few ways around it one

829
00:36:17,520 --> 00:36:17,920
way

830
00:36:17,920 --> 00:36:20,880
is just uh use the name the function

831
00:36:20,880 --> 00:36:21,359
name

832
00:36:21,359 --> 00:36:24,079
in front of each label inside a function

833
00:36:24,079 --> 00:36:25,760
something like that

834
00:36:25,760 --> 00:36:27,839
to sort of guarantee uniqueness that

835
00:36:27,839 --> 00:36:29,119
could work

836
00:36:29,119 --> 00:36:32,880
um and there is also a syntax for local

837
00:36:32,880 --> 00:36:33,839
labels

838
00:36:33,839 --> 00:36:36,320
so instead of calling them names i just

839
00:36:36,320 --> 00:36:38,640
give them numbers so that would be one

840
00:36:38,640 --> 00:36:41,440
and that would be two and then instead

841
00:36:41,440 --> 00:36:42,320
of

842
00:36:42,320 --> 00:36:45,760
branching to one i need to tell it

843
00:36:45,760 --> 00:36:48,800
whether it should branch forward go down

844
00:36:48,800 --> 00:36:51,280
or branch backward go up so in this case

845
00:36:51,280 --> 00:36:52,640
i want it to go down

846
00:36:52,640 --> 00:36:56,640
so one f means one look for the closest

847
00:36:56,640 --> 00:36:57,920
one down

848
00:36:57,920 --> 00:37:01,280
and here i want to branch to two f so

849
00:37:01,280 --> 00:37:04,480
go to uh the closest two tile uh down

850
00:37:04,480 --> 00:37:07,200
and then i can compile it happily and it

851
00:37:07,200 --> 00:37:09,040
works

852
00:37:09,040 --> 00:37:13,440
and if i add another one here

853
00:37:13,599 --> 00:37:16,800
this branch would still go to this

854
00:37:16,800 --> 00:37:19,280
number one because it looks for the

855
00:37:19,280 --> 00:37:20,560
closest

856
00:37:20,560 --> 00:37:23,760
number one so that's why they are sort

857
00:37:23,760 --> 00:37:24,720
of local

858
00:37:24,720 --> 00:37:27,359
and you can have a hub to up to uh nine

859
00:37:27,359 --> 00:37:29,760
of those so from one to nine

860
00:37:29,760 --> 00:37:32,800
um and they are pretty useful for

861
00:37:32,800 --> 00:37:36,079
uh i wanted to remove that one

862
00:37:36,079 --> 00:37:40,480
for shorter code snippets um

863
00:37:40,480 --> 00:37:43,200
and for longer one i usually just break

864
00:37:43,200 --> 00:37:45,520
it down to smaller functions

865
00:37:45,520 --> 00:37:47,760
um there is also another syntax that

866
00:37:47,760 --> 00:37:50,400
lets us add a unique number uh

867
00:37:50,400 --> 00:37:53,200
so let's call it greater uh that's the

868
00:37:53,200 --> 00:37:54,240
syntax

869
00:37:54,240 --> 00:37:57,440
but it only works in inline assembly so

870
00:37:57,440 --> 00:38:00,400
i usually don't use that uh syntax it

871
00:38:00,400 --> 00:38:01,760
just adds some unique

872
00:38:01,760 --> 00:38:04,880
a random number uh that is unique per

873
00:38:04,880 --> 00:38:06,800
each asm statement or something like

874
00:38:06,800 --> 00:38:07,520
that

875
00:38:07,520 --> 00:38:10,079
so it exists but i usually don't advise

876
00:38:10,079 --> 00:38:11,200
using it because

877
00:38:11,200 --> 00:38:13,760
then the code only works in inline

878
00:38:13,760 --> 00:38:15,119
assembly

879
00:38:15,119 --> 00:38:19,040
um cool so um

880
00:38:19,040 --> 00:38:22,079
we had uh max eight and now

881
00:38:22,079 --> 00:38:26,160
um i i i will briefly mention

882
00:38:26,160 --> 00:38:29,520
so uh we had cp oh thank you

883
00:38:29,520 --> 00:38:31,440
i will briefly mention a few more

884
00:38:31,440 --> 00:38:33,680
instructions that are useful

885
00:38:33,680 --> 00:38:36,880
so there is uh for instance uh

886
00:38:36,880 --> 00:38:40,640
cpi comparing with immediate just

887
00:38:40,640 --> 00:38:43,200
compare a register with some value

888
00:38:43,200 --> 00:38:45,599
instead of another register

889
00:38:45,599 --> 00:38:48,400
this is a nice shortcut if you know you

890
00:38:48,400 --> 00:38:50,640
just want to compare

891
00:38:50,640 --> 00:38:53,040
with some value so you don't have to

892
00:38:53,040 --> 00:38:54,800
copy that into a different register

893
00:38:54,800 --> 00:38:57,119
first

894
00:38:57,440 --> 00:39:00,079
and there is also a bunch of

895
00:39:00,079 --> 00:39:01,839
instructions that

896
00:39:01,839 --> 00:39:02,740
are unique

897
00:39:02,740 --> 00:39:05,919
[Music]

898
00:39:08,000 --> 00:39:10,079
there is also a bunch of instructions

899
00:39:10,079 --> 00:39:11,680
that are

900
00:39:11,680 --> 00:39:15,280
unique to avr i think and these

901
00:39:15,280 --> 00:39:16,880
instructions are called

902
00:39:16,880 --> 00:39:19,680
uh skip so we can skip the next

903
00:39:19,680 --> 00:39:20,560
instruction

904
00:39:20,560 --> 00:39:23,520
on in some conditions like if a specific

905
00:39:23,520 --> 00:39:24,800
bit in the register

906
00:39:24,800 --> 00:39:28,000
is set or cleared uh so

907
00:39:28,000 --> 00:39:30,240
if this bit is set or clicked it will

908
00:39:30,240 --> 00:39:31,520
just uh skip

909
00:39:31,520 --> 00:39:34,880
the next instruction um but

910
00:39:34,880 --> 00:39:37,200
they are useful uh i mean you can get

911
00:39:37,200 --> 00:39:38,079
the same thing

912
00:39:38,079 --> 00:39:40,160
you can do the same thing with the

913
00:39:40,160 --> 00:39:43,599
branches and uh

914
00:39:43,599 --> 00:39:46,560
bitwise operations so they are useful

915
00:39:46,560 --> 00:39:48,240
but

916
00:39:48,240 --> 00:39:52,000
i mean you can find them here if you

917
00:39:52,000 --> 00:39:54,720
need them but we are not going to go and

918
00:39:54,720 --> 00:39:56,480
use them right now

919
00:39:56,480 --> 00:40:00,800
um and uh the next topic i want

920
00:40:00,800 --> 00:40:03,760
to the next thing i want to do actually

921
00:40:03,760 --> 00:40:04,319
is

922
00:40:04,319 --> 00:40:07,520
uh to get rid of this asm to stop

923
00:40:07,520 --> 00:40:10,000
writing inline assembly because

924
00:40:10,000 --> 00:40:12,560
when we wanted to test just one or two

925
00:40:12,560 --> 00:40:13,359
instructions

926
00:40:13,359 --> 00:40:16,480
that was fine but now we have a whole

927
00:40:16,480 --> 00:40:18,480
function that is basically assembly but

928
00:40:18,480 --> 00:40:19,359
we have to write

929
00:40:19,359 --> 00:40:21,920
all these fancy syntax just to get it to

930
00:40:21,920 --> 00:40:23,040
work

931
00:40:23,040 --> 00:40:26,880
and uh for that to work we need to

932
00:40:26,880 --> 00:40:29,760
uh we if we want to define our own

933
00:40:29,760 --> 00:40:30,480
functions

934
00:40:30,480 --> 00:40:33,920
in uh assembly we actually need to know

935
00:40:33,920 --> 00:40:37,040
how the compiler uh

936
00:40:37,040 --> 00:40:39,839
expect a function what it expects from a

937
00:40:39,839 --> 00:40:41,040
function

938
00:40:41,040 --> 00:40:44,880
and we can find this information

939
00:40:44,880 --> 00:40:48,960
in uh here yep

940
00:40:48,960 --> 00:40:52,640
in the uh avr gcc wiki

941
00:40:52,640 --> 00:40:56,000
and uh this is a section called abi

942
00:40:56,000 --> 00:40:59,839
application binary interface let's um

943
00:40:59,839 --> 00:41:03,119
put it in this document so

944
00:41:03,119 --> 00:41:06,240
uh that's

945
00:41:06,240 --> 00:41:09,280
the text would be gc avr

946
00:41:09,280 --> 00:41:12,400
gcc application binary

947
00:41:12,400 --> 00:41:15,200
interface and the application binary

948
00:41:15,200 --> 00:41:17,280
interface basically defines

949
00:41:17,280 --> 00:41:21,680
how the uh compiler uses the registers

950
00:41:21,680 --> 00:41:24,640
and how it calls functions how it passes

951
00:41:24,640 --> 00:41:25,839
the arguments

952
00:41:25,839 --> 00:41:28,079
so it's all defined here and we can see

953
00:41:28,079 --> 00:41:31,040
like uh it defines the sizes of types

954
00:41:31,040 --> 00:41:35,040
so in is two bytes long is four bytes

955
00:41:35,040 --> 00:41:35,920
long long is

956
00:41:35,920 --> 00:41:39,920
eight bytes etc um

957
00:41:39,920 --> 00:41:42,720
and there is a bunch of other uh things

958
00:41:42,720 --> 00:41:44,000
regarding types

959
00:41:44,000 --> 00:41:45,440
but then there is this section about

960
00:41:45,440 --> 00:41:47,490
register layouts and

961
00:41:47,490 --> 00:41:49,440
[Music]

962
00:41:49,440 --> 00:41:51,280
there are like a few interesting bits

963
00:41:51,280 --> 00:41:53,839
here first of all values that occupy

964
00:41:53,839 --> 00:41:56,560
uh more than eight bit one eight bit

965
00:41:56,560 --> 00:41:57,599
register so

966
00:41:57,599 --> 00:42:00,960
16 bits or 32 values always start in an

967
00:42:00,960 --> 00:42:03,440
even register so if the compiler needed

968
00:42:03,440 --> 00:42:05,119
needs to store a value

969
00:42:05,119 --> 00:42:08,160
in two registers because it's too big it

970
00:42:08,160 --> 00:42:09,599
will always start with

971
00:42:09,599 --> 00:42:12,960
an even register like r30

972
00:42:12,960 --> 00:42:16,960
r22 r4 and then we have a few registers

973
00:42:16,960 --> 00:42:18,400
that are spatial

974
00:42:18,400 --> 00:42:22,560
so r0 is used as a scratch resistor that

975
00:42:22,560 --> 00:42:24,640
not need not to be restored after it's

976
00:42:24,640 --> 00:42:25,599
used after

977
00:42:25,599 --> 00:42:28,640
its usage so if we want to use some

978
00:42:28,640 --> 00:42:29,200
temporal

979
00:42:29,200 --> 00:42:32,079
register inside inline assembly we can

980
00:42:32,079 --> 00:42:33,440
actually use r0

981
00:42:33,440 --> 00:42:35,920
because uh it's a scratch resistor a

982
00:42:35,920 --> 00:42:38,160
register the compiler doesn't expect it

983
00:42:38,160 --> 00:42:42,400
to preserve its value so um

984
00:42:42,400 --> 00:42:44,960
that's okay the only way uh time we need

985
00:42:44,960 --> 00:42:46,240
to take care of it is

986
00:42:46,240 --> 00:42:49,440
inside an isr um and

987
00:42:49,440 --> 00:42:51,599
if we are using inline assembly we can

988
00:42:51,599 --> 00:42:55,040
use this macro instead of writing r0

989
00:42:55,040 --> 00:42:58,960
and r1 always contains zero so uh

990
00:42:58,960 --> 00:43:03,040
the the um compiler needs the value zero

991
00:43:03,040 --> 00:43:03,440
in

992
00:43:03,440 --> 00:43:05,839
many different cases so it just stores

993
00:43:05,839 --> 00:43:08,079
this value in this register

994
00:43:08,079 --> 00:43:11,200
and whenever it needs a zero like uh to

995
00:43:11,200 --> 00:43:13,200
end something with zero to add

996
00:43:13,200 --> 00:43:17,359
to multiply by zero or whatever um

997
00:43:17,359 --> 00:43:21,119
it just uh uses the value in r1

998
00:43:21,119 --> 00:43:24,560
um so uh you can always

999
00:43:24,560 --> 00:43:27,680
if you are running inside

1000
00:43:27,680 --> 00:43:30,960
this c environment you can always assume

1001
00:43:30,960 --> 00:43:31,280
that

1002
00:43:31,280 --> 00:43:33,680
r1 is equal to 0 and you must never

1003
00:43:33,680 --> 00:43:35,440
change its value

1004
00:43:35,440 --> 00:43:39,119
and then there are a few other registers

1005
00:43:39,119 --> 00:43:42,319
uh these registers are call clobbered

1006
00:43:42,319 --> 00:43:44,640
this means that any function can use

1007
00:43:44,640 --> 00:43:45,839
them and

1008
00:43:45,839 --> 00:43:47,920
it doesn't need to restore the content

1009
00:43:47,920 --> 00:43:49,440
so if you write your

1010
00:43:49,440 --> 00:43:52,720
if you create your own function uh like

1011
00:43:52,720 --> 00:43:55,119
we did here you can basically use these

1012
00:43:55,119 --> 00:43:56,079
registers

1013
00:43:56,079 --> 00:43:59,599
uh for free um and you know that

1014
00:43:59,599 --> 00:44:02,400
uh the compiler doesn't really uh care

1015
00:44:02,400 --> 00:44:04,160
about their content

1016
00:44:04,160 --> 00:44:06,960
if we had non-assembly con the code here

1017
00:44:06,960 --> 00:44:08,000
then that would have

1018
00:44:08,000 --> 00:44:11,599
probably been different um but if it's

1019
00:44:11,599 --> 00:44:14,319
a pure assembly function then these

1020
00:44:14,319 --> 00:44:16,640
registers are free to use

1021
00:44:16,640 --> 00:44:20,319
um and then the remaining registers

1022
00:44:20,319 --> 00:44:23,440
are called saved so if you change them

1023
00:44:23,440 --> 00:44:26,319
you must store them to the memory or to

1024
00:44:26,319 --> 00:44:27,920
the stack as you will see

1025
00:44:27,920 --> 00:44:30,640
and then before your function returns

1026
00:44:30,640 --> 00:44:31,839
you must restore their

1027
00:44:31,839 --> 00:44:35,680
original content so uh if you want

1028
00:44:35,680 --> 00:44:38,800
to write code that will uh work uh

1029
00:44:38,800 --> 00:44:40,720
in harmony with this environment just

1030
00:44:40,720 --> 00:44:41,920
like we did here

1031
00:44:41,920 --> 00:44:43,839
uh and we had to respect the fact that

1032
00:44:43,839 --> 00:44:45,440
we are running uh

1033
00:44:45,440 --> 00:44:48,480
inside uh the gc compiled uh

1034
00:44:48,480 --> 00:44:52,240
code we have to respect this constraint

1035
00:44:52,240 --> 00:44:56,160
in order not to um to

1036
00:44:56,160 --> 00:44:58,880
interfere with uh the other code that

1037
00:44:58,880 --> 00:45:01,040
gcc compiled for us

1038
00:45:01,040 --> 00:45:03,040
and another interesting piece of

1039
00:45:03,040 --> 00:45:04,319
information

1040
00:45:04,319 --> 00:45:07,599
is the calling convention so uh

1041
00:45:07,599 --> 00:45:10,800
i won't go over this uh long text

1042
00:45:10,800 --> 00:45:13,359
it's a bit cumbersome but basically

1043
00:45:13,359 --> 00:45:14,340
defines

1044
00:45:14,340 --> 00:45:15,920
[Music]

1045
00:45:15,920 --> 00:45:19,040
how parameters are passed to functions

1046
00:45:19,040 --> 00:45:22,079
and i think this

1047
00:45:22,079 --> 00:45:25,599
summarizes uh this example summarizes

1048
00:45:25,599 --> 00:45:26,160
this

1049
00:45:26,160 --> 00:45:28,720
uh pretty good so we have a function

1050
00:45:28,720 --> 00:45:29,920
that returns in

1051
00:45:29,920 --> 00:45:32,800
and take two arguments a character and

1052
00:45:32,800 --> 00:45:34,319
um

1053
00:45:34,319 --> 00:45:37,599
a long value and we can see that the

1054
00:45:37,599 --> 00:45:39,520
first argument will be pressed in

1055
00:45:39,520 --> 00:45:43,520
r24 and then b will be passed in these

1056
00:45:43,520 --> 00:45:44,960
four registers so

1057
00:45:44,960 --> 00:45:48,240
20 to 33

1058
00:45:48,240 --> 00:45:51,920
so in a nutshell if it's uh

1059
00:45:51,920 --> 00:45:54,560
one or two bytes then the first argument

1060
00:45:54,560 --> 00:45:55,680
will always be in

1061
00:45:55,680 --> 00:45:59,359
r24 and if it's two bytes like un16 it

1062
00:45:59,359 --> 00:46:00,240
will be also

1063
00:46:00,240 --> 00:46:03,359
the high byte will be in r25 and then

1064
00:46:03,359 --> 00:46:04,720
the result is stored

1065
00:46:04,720 --> 00:46:08,560
r24 lsb and r25 msp

1066
00:46:08,560 --> 00:46:12,640
and uh like this example is useful for

1067
00:46:12,640 --> 00:46:14,240
most of the functions that you will

1068
00:46:14,240 --> 00:46:16,160
create uh

1069
00:46:16,160 --> 00:46:18,000
they will probably not take more than

1070
00:46:18,000 --> 00:46:19,680
one or two arguments

1071
00:46:19,680 --> 00:46:22,240
uh if this argument wasn't long if it

1072
00:46:22,240 --> 00:46:24,400
was like a character or

1073
00:46:24,400 --> 00:46:27,680
unit 16 it would start in artwork with

1074
00:46:27,680 --> 00:46:31,280
in r22 and not r20

1075
00:46:31,280 --> 00:46:34,640
but to really understand how to

1076
00:46:34,640 --> 00:46:36,160
calculate this just uh

1077
00:46:36,160 --> 00:46:38,480
you can go over this and it explains the

1078
00:46:38,480 --> 00:46:39,839
algorithm

1079
00:46:39,839 --> 00:46:44,480
um so uh

1080
00:46:47,440 --> 00:46:50,560
okay so uh julian is asking whether

1081
00:46:50,560 --> 00:46:51,280
there is

1082
00:46:51,280 --> 00:46:54,640
uh a reference for the

1083
00:46:54,640 --> 00:46:57,680
assembler level format

1084
00:46:57,680 --> 00:47:00,720
uh as far as i can tell i couldn't

1085
00:47:00,720 --> 00:47:01,119
really

1086
00:47:01,119 --> 00:47:04,400
find a coherent reference

1087
00:47:04,400 --> 00:47:08,240
uh these 1f and 2f i will look for it

1088
00:47:08,240 --> 00:47:09,760
for the next time if i can find

1089
00:47:09,760 --> 00:47:10,800
something better but

1090
00:47:10,800 --> 00:47:13,760
uh basically everything is global except

1091
00:47:13,760 --> 00:47:15,520
for those look a little bit

1092
00:47:15,520 --> 00:47:19,040
like labels with numbers um

1093
00:47:19,040 --> 00:47:25,839
that's what i found um

1094
00:47:26,000 --> 00:47:29,040
so cool so uh now that we

1095
00:47:29,040 --> 00:47:32,480
uh know how the uh

1096
00:47:32,480 --> 00:47:35,280
compiler passes arguments and what it

1097
00:47:35,280 --> 00:47:37,359
expects from functions we can actually

1098
00:47:37,359 --> 00:47:38,079
create our

1099
00:47:38,079 --> 00:47:41,280
first uh pure assembly functions

1100
00:47:41,280 --> 00:47:44,960
and um i think we i haven't tried it but

1101
00:47:44,960 --> 00:47:46,720
i think we can't really do this

1102
00:47:46,720 --> 00:47:50,160
like uh like

1103
00:47:50,160 --> 00:47:53,599
here that would probably not work

1104
00:47:53,599 --> 00:47:56,240
just emitting assembly code random

1105
00:47:56,240 --> 00:47:58,319
assembly code globally

1106
00:47:58,319 --> 00:48:01,599
oh it works so uh there might be

1107
00:48:01,599 --> 00:48:05,359
uh it might work you may be able to

1108
00:48:05,359 --> 00:48:10,000
define functions pure assembly functions

1109
00:48:10,000 --> 00:48:13,599
using this asm statement i haven't tried

1110
00:48:13,599 --> 00:48:13,920
it

1111
00:48:13,920 --> 00:48:16,960
but what i usually do which makes a lot

1112
00:48:16,960 --> 00:48:18,480
more sense to me

1113
00:48:18,480 --> 00:48:21,599
is just uh to create a new file uh

1114
00:48:21,599 --> 00:48:25,119
with assembly code so let's

1115
00:48:25,200 --> 00:48:28,400
let's call it uh hackaday

1116
00:48:28,400 --> 00:48:31,200
and the extension has to be s so it will

1117
00:48:31,200 --> 00:48:31,520
be

1118
00:48:31,520 --> 00:48:34,079
uh assembled and not compiled with the c

1119
00:48:34,079 --> 00:48:36,160
compiler

1120
00:48:36,160 --> 00:48:38,160
and then let's start with a really

1121
00:48:38,160 --> 00:48:39,200
simple function

1122
00:48:39,200 --> 00:48:43,359
that uh uh basically we don't we want to

1123
00:48:43,359 --> 00:48:45,200
create a swap function that

1124
00:48:45,200 --> 00:48:47,680
will uh swap the evils just like the

1125
00:48:47,680 --> 00:48:49,680
instruction does we don't have that

1126
00:48:49,680 --> 00:48:52,400
operator in c so let's create a function

1127
00:48:52,400 --> 00:48:53,359
for that

1128
00:48:53,359 --> 00:48:56,160
so uh for that we just need to define a

1129
00:48:56,160 --> 00:48:56,880
label

1130
00:48:56,880 --> 00:48:59,520
like we did here and that would be the

1131
00:48:59,520 --> 00:49:01,040
name of the function

1132
00:49:01,040 --> 00:49:06,079
and then we remember that

1133
00:49:06,880 --> 00:49:09,119
oh somebody asking about the extension

1134
00:49:09,119 --> 00:49:10,559
that's an uppercase

1135
00:49:10,559 --> 00:49:14,160
s hackaday.uppercase s um

1136
00:49:14,160 --> 00:49:17,119
so we said that the first argument will

1137
00:49:17,119 --> 00:49:17,599
if it's

1138
00:49:17,599 --> 00:49:20,720
uh uh one byte or two will be passed in

1139
00:49:20,720 --> 00:49:21,680
r24

1140
00:49:21,680 --> 00:49:24,960
and the result in r24 as well so

1141
00:49:24,960 --> 00:49:29,200
uh basically we just need to swap r24

1142
00:49:29,200 --> 00:49:32,720
because uh arc 1

1143
00:49:32,720 --> 00:49:36,240
r24 result in r34 it's the same

1144
00:49:36,240 --> 00:49:39,280
register so we can just uh

1145
00:49:39,280 --> 00:49:43,040
you know do whatever and then

1146
00:49:43,040 --> 00:49:45,680
the other thing we need to do we need to

1147
00:49:45,680 --> 00:49:46,480
uh

1148
00:49:46,480 --> 00:49:50,400
write red which means there is no syntax

1149
00:49:50,400 --> 00:49:51,520
highlighting here

1150
00:49:51,520 --> 00:49:54,160
or autocomplete for assembly uh i will

1151
00:49:54,160 --> 00:49:55,280
probably fix it

1152
00:49:55,280 --> 00:49:57,520
over the next few weeks but for now

1153
00:49:57,520 --> 00:49:58,720
we'll have to

1154
00:49:58,720 --> 00:50:01,920
imagine it's colored

1155
00:50:01,920 --> 00:50:05,760
and then in order to be able to call

1156
00:50:05,760 --> 00:50:08,800
this function from other another

1157
00:50:08,800 --> 00:50:13,119
module from the main sketch for instance

1158
00:50:13,119 --> 00:50:15,440
i need to say to declare that it's

1159
00:50:15,440 --> 00:50:16,400
global so

1160
00:50:16,400 --> 00:50:18,640
it's sort of a way to say that this

1161
00:50:18,640 --> 00:50:21,520
label is actually exported from this

1162
00:50:21,520 --> 00:50:24,640
file and that's all we need to do

1163
00:50:24,640 --> 00:50:27,839
from the assembly side of thing and

1164
00:50:27,839 --> 00:50:29,839
in an idle world we could just say

1165
00:50:29,839 --> 00:50:31,280
something like

1166
00:50:31,280 --> 00:50:35,200
let's say this let's remove those

1167
00:50:35,200 --> 00:50:38,319
actually let's keep them for later so

1168
00:50:38,319 --> 00:50:40,480
let's remove all this clutter we don't

1169
00:50:40,480 --> 00:50:42,720
need it anymore

1170
00:50:42,720 --> 00:50:46,079
um yeah maybe i will just copy this to

1171
00:50:46,079 --> 00:50:48,559
uh the document so you will have it as a

1172
00:50:48,559 --> 00:50:50,319
reference later

1173
00:50:50,319 --> 00:50:53,520
um okay and

1174
00:50:53,520 --> 00:50:56,640
um in an idle world we could just say

1175
00:50:56,640 --> 00:50:57,920
something like

1176
00:50:57,920 --> 00:51:01,839
uh serial println and then

1177
00:51:01,839 --> 00:51:05,200
println swap uh let's say

1178
00:51:05,200 --> 00:51:10,559
42 and expected to expect it to be 24

1179
00:51:10,559 --> 00:51:14,319
but unfortunately uh the compiler said

1180
00:51:14,319 --> 00:51:17,440
i don't know about swap what swap

1181
00:51:17,440 --> 00:51:21,359
and in order to uh make the compiler

1182
00:51:21,359 --> 00:51:23,040
recognize that function we need to

1183
00:51:23,040 --> 00:51:24,000
declare it

1184
00:51:24,000 --> 00:51:26,160
so just tell it there is a function

1185
00:51:26,160 --> 00:51:27,440
called swap

1186
00:51:27,440 --> 00:51:30,960
it returns uh unit eight and

1187
00:51:30,960 --> 00:51:34,079
um it also takes the you indeed

1188
00:51:34,079 --> 00:51:37,200
argument um and

1189
00:51:37,200 --> 00:51:39,680
the reason we need to do it is so that

1190
00:51:39,680 --> 00:51:41,280
the compiler know

1191
00:51:41,280 --> 00:51:43,280
which registers to use because this

1192
00:51:43,280 --> 00:51:44,800
depends on the size

1193
00:51:44,800 --> 00:51:48,400
of the uh like argument which registers

1194
00:51:48,400 --> 00:51:51,359
it should use to pass this value

1195
00:51:51,359 --> 00:51:54,160
and if we run it it still doesn't

1196
00:51:54,160 --> 00:51:55,280
compile it says

1197
00:51:55,280 --> 00:51:58,559
undefined reference to swap and that's

1198
00:51:58,559 --> 00:51:59,760
pretty tricky

1199
00:51:59,760 --> 00:52:02,880
the reason it's it does it is because it

1200
00:52:02,880 --> 00:52:05,599
actually expects a different function

1201
00:52:05,599 --> 00:52:06,160
name

1202
00:52:06,160 --> 00:52:08,160
uh i don't remember what's the name of

1203
00:52:08,160 --> 00:52:10,319
this but c plus plus adds

1204
00:52:10,319 --> 00:52:12,720
uh some sort of decoration to the

1205
00:52:12,720 --> 00:52:13,920
function name so

1206
00:52:13,920 --> 00:52:17,200
it's something like swaps underscore

1207
00:52:17,200 --> 00:52:18,000
something i don't

1208
00:52:18,000 --> 00:52:21,119
remember the exact syntax uh because

1209
00:52:21,119 --> 00:52:24,000
uh the function name also uh the

1210
00:52:24,000 --> 00:52:25,280
compiled function name

1211
00:52:25,280 --> 00:52:26,960
also includes information about the

1212
00:52:26,960 --> 00:52:28,960
types of the uh parameters and the

1213
00:52:28,960 --> 00:52:30,160
return value

1214
00:52:30,160 --> 00:52:33,520
so uh in order to fix that we can just

1215
00:52:33,520 --> 00:52:36,640
uh say this is a c function which is

1216
00:52:36,640 --> 00:52:38,480
a bit of a cheating because it's an

1217
00:52:38,480 --> 00:52:39,680
assembly function

1218
00:52:39,680 --> 00:52:41,680
but basically what this does is tell the

1219
00:52:41,680 --> 00:52:42,880
compiler hey

1220
00:52:42,880 --> 00:52:46,160
just call it swap don't do any like name

1221
00:52:46,160 --> 00:52:46,880
angling

1222
00:52:46,880 --> 00:52:50,240
i think that's what it's called um

1223
00:52:50,240 --> 00:52:52,800
just uh look for a function called swap

1224
00:52:52,800 --> 00:52:54,800
without every addition any additions or

1225
00:52:54,800 --> 00:52:55,760
changes

1226
00:52:55,760 --> 00:52:59,119
and now if we compile it uh

1227
00:52:59,119 --> 00:53:01,200
it actually compiled and we got the

1228
00:53:01,200 --> 00:53:02,400
correct result

1229
00:53:02,400 --> 00:53:05,440
so that was our first assembly function

1230
00:53:05,440 --> 00:53:08,559
and now i want to show you how we take

1231
00:53:08,559 --> 00:53:12,079
this uh max 8 and implement it

1232
00:53:12,079 --> 00:53:15,440
in inline assembly in assembly

1233
00:53:15,440 --> 00:53:18,640
uh how it would look in assembly so

1234
00:53:18,640 --> 00:53:19,680
basically

1235
00:53:19,680 --> 00:53:23,119
we have max 8 and

1236
00:53:23,119 --> 00:53:26,839
just like before let's make it also

1237
00:53:26,839 --> 00:53:28,400
global

1238
00:53:28,400 --> 00:53:32,079
max eight uh arg1 in r24

1239
00:53:32,079 --> 00:53:35,680
r2 in r22 so going

1240
00:53:35,680 --> 00:53:38,960
uh down by two for each argument as long

1241
00:53:38,960 --> 00:53:39,599
as they are

1242
00:53:39,599 --> 00:53:43,200
uh one or two bytes um

1243
00:53:43,200 --> 00:53:47,119
and then we just define it and then uh

1244
00:53:47,119 --> 00:53:50,240
we don't need all the variables and we

1245
00:53:50,240 --> 00:53:51,920
don't need all this clutter

1246
00:53:51,920 --> 00:53:54,160
we just need to do something like this

1247
00:53:54,160 --> 00:53:56,880
uh we compare part one

1248
00:53:56,880 --> 00:54:00,559
with part two uh if it's greater then

1249
00:54:00,559 --> 00:54:03,920
jump here otherwise uh we move

1250
00:54:03,920 --> 00:54:07,520
uh we copy um

1251
00:54:07,520 --> 00:54:11,040
result so r24

1252
00:54:11,040 --> 00:54:15,200
and r2 that was r22 so we just copy the

1253
00:54:15,200 --> 00:54:17,599
second argument to the result

1254
00:54:17,599 --> 00:54:21,119
um but actually uh if

1255
00:54:21,119 --> 00:54:23,680
here if we are here if there this is

1256
00:54:23,680 --> 00:54:24,400
greater

1257
00:54:24,400 --> 00:54:28,319
we have to copy r24 into hardware d4

1258
00:54:28,319 --> 00:54:31,440
but we don't really need this right so

1259
00:54:31,440 --> 00:54:33,200
basically we can remove it because it

1260
00:54:33,200 --> 00:54:34,880
doesn't do anything

1261
00:54:34,880 --> 00:54:39,119
and now we can see that uh jumping 2f

1262
00:54:39,119 --> 00:54:42,160
actually does nothing because uh it just

1263
00:54:42,160 --> 00:54:44,960
jumps to the next instruction so we can

1264
00:54:44,960 --> 00:54:45,440
uh

1265
00:54:45,440 --> 00:54:48,480
remove it as well and then a lot and the

1266
00:54:48,480 --> 00:54:49,440
label as well

1267
00:54:49,440 --> 00:54:51,599
and then the last thing we need is just

1268
00:54:51,599 --> 00:54:52,799
the return the red

1269
00:54:52,799 --> 00:54:54,880
to tell it to go back to the function

1270
00:54:54,880 --> 00:54:56,559
that uh called us

1271
00:54:56,559 --> 00:54:59,760
so uh just changing this

1272
00:54:59,760 --> 00:55:03,280
lowercase so basically now compare this

1273
00:55:03,280 --> 00:55:06,640
with this and i think you understand why

1274
00:55:06,640 --> 00:55:08,960
you want to avoid inline assembly

1275
00:55:08,960 --> 00:55:10,640
whenever you can like if you can just

1276
00:55:10,640 --> 00:55:11,920
write a function

1277
00:55:11,920 --> 00:55:14,240
uh straight in assembly then it's much

1278
00:55:14,240 --> 00:55:15,920
shorter easier

1279
00:55:15,920 --> 00:55:18,720
um and you don't have to work very hard

1280
00:55:18,720 --> 00:55:19,359
to

1281
00:55:19,359 --> 00:55:22,400
cooperate with the compiler and now

1282
00:55:22,400 --> 00:55:23,440
let's just

1283
00:55:23,440 --> 00:55:25,760
make sure that it still works we still

1284
00:55:25,760 --> 00:55:26,640
need a function

1285
00:55:26,640 --> 00:55:30,799
signature though like we had for uh

1286
00:55:30,799 --> 00:55:34,480
swap and let's have all these test cases

1287
00:55:34,480 --> 00:55:38,400
again and we can see it still works

1288
00:55:38,400 --> 00:55:41,119
uh i don't know if you remember but we

1289
00:55:41,119 --> 00:55:42,000
are getting here

1290
00:55:42,000 --> 00:55:44,640
uh zero instead of this because this is

1291
00:55:44,640 --> 00:55:45,119
uh

1292
00:55:45,119 --> 00:55:48,799
sign we we change it to be

1293
00:55:49,520 --> 00:55:51,760
a signed comparison if we go back to

1294
00:55:51,760 --> 00:55:53,440
brsh then

1295
00:55:53,440 --> 00:55:55,920
it will be unsigned comparison and this

1296
00:55:55,920 --> 00:55:57,599
one will be greater than

1297
00:55:57,599 --> 00:56:01,280
zero so yeah that's how we are going to

1298
00:56:01,280 --> 00:56:03,280
write assembly for the rest of the

1299
00:56:03,280 --> 00:56:04,400
course

1300
00:56:04,400 --> 00:56:06,960
no more having to fiddle with those uh

1301
00:56:06,960 --> 00:56:09,359
with this awkward syntax

1302
00:56:09,359 --> 00:56:12,480
um and

1303
00:56:12,480 --> 00:56:16,000
uh one more thing uh

1304
00:56:16,000 --> 00:56:19,040
about function calls so

1305
00:56:19,040 --> 00:56:22,400
whenever you uh call a function like uh

1306
00:56:22,400 --> 00:56:26,079
here where was that yeah like here

1307
00:56:26,079 --> 00:56:29,920
or calling swap it's actually uh

1308
00:56:29,920 --> 00:56:33,599
pushing the address of the return

1309
00:56:33,599 --> 00:56:35,200
address like the address of the next

1310
00:56:35,200 --> 00:56:37,520
instruction into the stack

1311
00:56:37,520 --> 00:56:40,160
and this stack is like a data structure

1312
00:56:40,160 --> 00:56:42,640
that starts at the end of the memory

1313
00:56:42,640 --> 00:56:45,359
and it goes down so whenever we are

1314
00:56:45,359 --> 00:56:46,559
calling a function

1315
00:56:46,559 --> 00:56:49,200
uh there is a new value at the bottom of

1316
00:56:49,200 --> 00:56:49,839
the stack

1317
00:56:49,839 --> 00:56:53,119
and then the stack pointer goes uh

1318
00:56:53,119 --> 00:56:56,079
decrements to point to the uh next

1319
00:56:56,079 --> 00:56:58,079
location in the stack which is uh

1320
00:56:58,079 --> 00:57:01,119
down in the memory and then

1321
00:57:01,119 --> 00:57:03,839
what ret does it basically takes the

1322
00:57:03,839 --> 00:57:05,119
instruction

1323
00:57:05,119 --> 00:57:08,079
from uh the top of the stack so

1324
00:57:08,079 --> 00:57:08,799
basically

1325
00:57:08,799 --> 00:57:12,319
uh it's the instruction that the the

1326
00:57:12,319 --> 00:57:14,079
address that was pushed when we

1327
00:57:14,079 --> 00:57:16,799
call this function and it jumps to that

1328
00:57:16,799 --> 00:57:19,040
instruction so it removes the top value

1329
00:57:19,040 --> 00:57:20,240
from the stack

1330
00:57:20,240 --> 00:57:23,440
and uh go sets the

1331
00:57:23,440 --> 00:57:26,640
pc the program counter to that value and

1332
00:57:26,640 --> 00:57:28,720
that's how calling function works

1333
00:57:28,720 --> 00:57:32,160
functions work and we have a few utility

1334
00:57:32,160 --> 00:57:33,200
functions so

1335
00:57:33,200 --> 00:57:35,920
in this utility instructions so in this

1336
00:57:35,920 --> 00:57:36,319
case

1337
00:57:36,319 --> 00:57:39,440
we had really simple functions and we

1338
00:57:39,440 --> 00:57:41,280
didn't really need to

1339
00:57:41,280 --> 00:57:44,480
use any temporal registers

1340
00:57:44,480 --> 00:57:47,359
if we needed some temporary registers we

1341
00:57:47,359 --> 00:57:48,240
could have used

1342
00:57:48,240 --> 00:57:51,359
all of those

1343
00:57:51,359 --> 00:57:53,839
scratch regis clobbered registers

1344
00:57:53,839 --> 00:57:55,280
without worrying too much

1345
00:57:55,280 --> 00:57:57,920
because this c doesn't the compiler

1346
00:57:57,920 --> 00:58:00,319
doesn't expect us to save them

1347
00:58:00,319 --> 00:58:04,319
but in the next lesson we are going to

1348
00:58:04,319 --> 00:58:07,520
implement fibonacci

1349
00:58:07,520 --> 00:58:10,240
which is a recursive function and then

1350
00:58:10,240 --> 00:58:11,200
we'll have to

1351
00:58:11,200 --> 00:58:13,780
have some temporary space to

1352
00:58:13,780 --> 00:58:14,960
[Music]

1353
00:58:14,960 --> 00:58:18,160
store the registers while

1354
00:58:18,160 --> 00:58:21,680
we call the function recursively

1355
00:58:21,680 --> 00:58:23,920
and then we'll see how we use uh the

1356
00:58:23,920 --> 00:58:25,839
stack for that with the push and pop

1357
00:58:25,839 --> 00:58:27,040
instructions

1358
00:58:27,040 --> 00:58:29,920
but i think that would be for uh the

1359
00:58:29,920 --> 00:58:31,359
next time

1360
00:58:31,359 --> 00:58:36,079
um so let's do a quick review of what we

1361
00:58:36,079 --> 00:58:37,359
had today

1362
00:58:37,359 --> 00:58:40,640
um so we learned about a bunch of new

1363
00:58:40,640 --> 00:58:42,799
arithmetic instructions

1364
00:58:42,799 --> 00:58:46,720
and now we have also red and then

1365
00:58:46,720 --> 00:58:50,640
we saw how to compare numbers and

1366
00:58:50,640 --> 00:58:53,440
how to define functions in pure assembly

1367
00:58:53,440 --> 00:58:53,839
and

1368
00:58:53,839 --> 00:58:56,960
how to uh return from functions but

1369
00:58:56,960 --> 00:58:59,440
more importantly i think we'll learn

1370
00:58:59,440 --> 00:59:00,079
about

1371
00:59:00,079 --> 00:59:03,280
uh thanks for the reminder

1372
00:59:03,280 --> 00:59:07,680
we learned about the avr gcc abi which

1373
00:59:07,680 --> 00:59:11,280
lets us call

1374
00:59:11,280 --> 00:59:14,319
our assembly functions from c

1375
00:59:14,319 --> 00:59:17,359
and we can also do the opposite like we

1376
00:59:17,359 --> 00:59:18,079
could also

1377
00:59:18,079 --> 00:59:21,359
call uh some of the uh actually we have

1378
00:59:21,359 --> 00:59:22,720
one one in it so

1379
00:59:22,720 --> 00:59:25,440
we can do that let's make swap also uh

1380
00:59:25,440 --> 00:59:26,960
turn this uh

1381
00:59:26,960 --> 00:59:30,559
led on so basically we want to call

1382
00:59:30,559 --> 00:59:32,799
digital write that's a c library

1383
00:59:32,799 --> 00:59:33,920
function

1384
00:59:33,920 --> 00:59:38,240
and we know it gets p number

1385
00:59:38,240 --> 00:59:41,440
and a high or low so uh that's pin

1386
00:59:41,440 --> 00:59:47,000
13 first argument hold the ir2413

1387
00:59:47,000 --> 00:59:51,040
ldir22 um

1388
00:59:51,400 --> 00:59:53,839
r321 because it's high

1389
00:59:53,839 --> 00:59:57,839
and now our um yeah it won't swap

1390
00:59:57,839 --> 00:59:59,119
anymore because now

1391
00:59:59,119 --> 01:00:02,160
we are destroying the value in r24 but

1392
01:00:02,160 --> 01:00:05,280
now our swap function uh actually should

1393
01:00:05,280 --> 01:00:06,960
actually turn on this

1394
01:00:06,960 --> 01:00:10,079
built-in led let's see that yep it

1395
01:00:10,079 --> 01:00:11,200
worked so

1396
01:00:11,200 --> 01:00:14,799
uh we we can now that we know the api we

1397
01:00:14,799 --> 01:00:18,799
we can define functions in uh avr

1398
01:00:18,799 --> 01:00:21,119
in pure avr assembly not the inline

1399
01:00:21,119 --> 01:00:21,839
assembly

1400
01:00:21,839 --> 01:00:25,119
and we can also use that to uh call c or

1401
01:00:25,119 --> 01:00:26,880
c plus plus functions

1402
01:00:26,880 --> 01:00:30,319
from our assembly code which lets us

1403
01:00:30,319 --> 01:00:33,520
basically uh integrate the two pieces

1404
01:00:33,520 --> 01:00:36,720
so uh yeah we can also add call to the

1405
01:00:36,720 --> 01:00:37,280
list

1406
01:00:37,280 --> 01:00:40,400
you now know how to use it and the

1407
01:00:40,400 --> 01:00:42,400
the really important piece here is the

1408
01:00:42,400 --> 01:00:43,599
abi

1409
01:00:43,599 --> 01:00:47,839
so um that's it for today um

1410
01:00:47,839 --> 01:00:50,960
i hope it was uh intense but not too

1411
01:00:50,960 --> 01:00:52,160
intense

1412
01:00:52,160 --> 01:00:56,000
and um yeah i will take questions

1413
01:00:56,000 --> 01:00:58,720
in a moment before that uh last week we

1414
01:00:58,720 --> 01:00:59,599
announced that

1415
01:00:59,599 --> 01:01:02,960
uh we will have a final project in

1416
01:01:02,960 --> 01:01:06,000
the course and i've put together a

1417
01:01:06,000 --> 01:01:08,000
description of the project

1418
01:01:08,000 --> 01:01:11,280
it's basically building a pong game

1419
01:01:11,280 --> 01:01:14,319
in avr uh assembly like

1420
01:01:14,319 --> 01:01:17,359
we have here but from scratch uh without

1421
01:01:17,359 --> 01:01:19,760
using any of the library functions

1422
01:01:19,760 --> 01:01:22,799
and uh right now i guess

1423
01:01:22,799 --> 01:01:25,040
you still don't have all the information

1424
01:01:25,040 --> 01:01:27,280
you need in order to

1425
01:01:27,280 --> 01:01:30,640
create this game um but after lesson

1426
01:01:30,640 --> 01:01:31,599
number five

1427
01:01:31,599 --> 01:01:33,599
you should have it so we still have a

1428
01:01:33,599 --> 01:01:34,640
long way to go

1429
01:01:34,640 --> 01:01:37,920
in the next two lessons but uh

1430
01:01:37,920 --> 01:01:40,240
this is just to give you a general sense

1431
01:01:40,240 --> 01:01:42,640
of uh the final project

1432
01:01:42,640 --> 01:01:44,640
and uh if you want to get a certificate

1433
01:01:44,640 --> 01:01:45,920
from hackaday then

1434
01:01:45,920 --> 01:01:49,599
you would have to uh do that

1435
01:01:49,599 --> 01:01:52,000
and if you have any questions about

1436
01:01:52,000 --> 01:01:53,280
instructions just

1437
01:01:53,280 --> 01:01:56,480
or about anything here we learned today

1438
01:01:56,480 --> 01:01:59,280
i just hit me on the hackaday chat or

1439
01:01:59,280 --> 01:02:01,280
the discord channel of walkway i'm

1440
01:02:01,280 --> 01:02:04,799
always there waiting for you um

1441
01:02:04,799 --> 01:02:08,319
i'll also add this link even though it's

1442
01:02:08,319 --> 01:02:10,400
uh i will probably add some more

1443
01:02:10,400 --> 01:02:11,760
information

1444
01:02:11,760 --> 01:02:14,880
over the next couple of days uh that

1445
01:02:14,880 --> 01:02:16,960
would be

1446
01:02:16,960 --> 01:02:20,319
final project oh i love this uh

1447
01:02:20,319 --> 01:02:22,960
this responses challenge accepted

1448
01:02:22,960 --> 01:02:24,720
intense but no the intense

1449
01:02:24,720 --> 01:02:29,760
perfect thanks uh project description

1450
01:02:29,760 --> 01:02:31,839
i'm looking forward to see what kind of

1451
01:02:31,839 --> 01:02:35,839
punks you will make

