1
00:00:00,000 --> 00:00:09,860
[Music]

2
00:00:10,080 --> 00:00:11,759
all right so welcome everybody

3
00:00:11,759 --> 00:00:15,120
to the final

4
00:00:15,120 --> 00:00:18,480
session for our first uh hackaday guidra

5
00:00:18,480 --> 00:00:19,439
course

6
00:00:19,439 --> 00:00:21,199
and so today what we're going to go over

7
00:00:21,199 --> 00:00:23,279
are some more i won't call them advanced

8
00:00:23,279 --> 00:00:24,720
features but just some feature features

9
00:00:24,720 --> 00:00:26,160
we haven't touched on yet

10
00:00:26,160 --> 00:00:29,279
some of the internals of how gager works

11
00:00:29,279 --> 00:00:30,640
we've gotten a lot of questions about

12
00:00:30,640 --> 00:00:32,320
how the decompiler works and things like

13
00:00:32,320 --> 00:00:32,880
that

14
00:00:32,880 --> 00:00:34,079
so we're going to get into some of that

15
00:00:34,079 --> 00:00:36,000
today and

16
00:00:36,000 --> 00:00:38,079
hopefully everybody enjoys it so let's

17
00:00:38,079 --> 00:00:39,760
get started

18
00:00:39,760 --> 00:00:41,200
so today we're going to go over a

19
00:00:41,200 --> 00:00:43,360
handful of additional key drift features

20
00:00:43,360 --> 00:00:45,680
that people have asked about in class

21
00:00:45,680 --> 00:00:47,360
and things that i think you'll find

22
00:00:47,360 --> 00:00:49,520
useful as you either revisit these

23
00:00:49,520 --> 00:00:50,399
exercises

24
00:00:50,399 --> 00:00:52,800
or look at you know later exercises in

25
00:00:52,800 --> 00:00:53,600
the future

26
00:00:53,600 --> 00:00:55,280
so we're going to talk about loading

27
00:00:55,280 --> 00:00:56,960
external libraries we're going to talk

28
00:00:56,960 --> 00:00:57,440
about

29
00:00:57,440 --> 00:00:59,520
patch analysis and diffing we're going

30
00:00:59,520 --> 00:01:01,120
to take a look at some of the other

31
00:01:01,120 --> 00:01:02,960
interesting features giger has like the

32
00:01:02,960 --> 00:01:04,640
checksum generation we'll take a look at

33
00:01:04,640 --> 00:01:06,240
how to manage memory maps

34
00:01:06,240 --> 00:01:07,680
for those of you that have been watching

35
00:01:07,680 --> 00:01:09,439
the office hours we've done a lot of

36
00:01:09,439 --> 00:01:10,159
that

37
00:01:10,159 --> 00:01:11,840
with some of the embedded firmware

38
00:01:11,840 --> 00:01:13,280
images we've been looking at

39
00:01:13,280 --> 00:01:14,479
and then we're going to talk about you

40
00:01:14,479 --> 00:01:16,080
know giger extensions and writing

41
00:01:16,080 --> 00:01:17,759
scripts and we'll walk through

42
00:01:17,759 --> 00:01:20,479
how to integrate eclipse with gedra so

43
00:01:20,479 --> 00:01:21,439
that you can

44
00:01:21,439 --> 00:01:23,200
develop your own python and java

45
00:01:23,200 --> 00:01:24,640
extensions for it as well

46
00:01:24,640 --> 00:01:25,759
and then we'll just do like a nice

47
00:01:25,759 --> 00:01:27,280
little wrap up where people can ask any

48
00:01:27,280 --> 00:01:28,640
additional questions they might have and

49
00:01:28,640 --> 00:01:31,280
things like that

50
00:01:31,920 --> 00:01:33,920
so again quick admin like we do every

51
00:01:33,920 --> 00:01:35,520
time this is going to be our final

52
00:01:35,520 --> 00:01:37,840
session for now so uh feedback and

53
00:01:37,840 --> 00:01:38,960
thoughts on the course

54
00:01:38,960 --> 00:01:42,159
are highly appreciated for everybody

55
00:01:42,159 --> 00:01:43,119
involved

56
00:01:43,119 --> 00:01:45,200
and so the other thing that we'd like to

57
00:01:45,200 --> 00:01:47,119
add is i'm working on a google form for

58
00:01:47,119 --> 00:01:49,040
the course for everybody to fill out

59
00:01:49,040 --> 00:01:51,759
if they want to where they can provide

60
00:01:51,759 --> 00:01:53,680
kind of more in-depth information

61
00:01:53,680 --> 00:01:56,320
about the course so you can send the

62
00:01:56,320 --> 00:01:57,200
feedback

63
00:01:57,200 --> 00:02:01,040
to either super conference okay great

64
00:02:01,040 --> 00:02:02,320
give me one second i'm actually going to

65
00:02:02,320 --> 00:02:03,680
shut this door behind me because of the

66
00:02:03,680 --> 00:02:09,840
light excuse me

67
00:02:12,959 --> 00:02:14,480
all right apologies for that everybody

68
00:02:14,480 --> 00:02:16,400
so office hours are gonna be thursday at

69
00:02:16,400 --> 00:02:17,840
six just like usual

70
00:02:17,840 --> 00:02:20,239
and then again so any questions you have

71
00:02:20,239 --> 00:02:21,920
feel free to toss them at me through the

72
00:02:21,920 --> 00:02:24,080
hackaday io chat room my username is

73
00:02:24,080 --> 00:02:25,120
wrongbod

74
00:02:25,120 --> 00:02:28,720
or the super conference at hackadayio

75
00:02:28,720 --> 00:02:31,440
and like i said um i'm putting together

76
00:02:31,440 --> 00:02:32,080
a

77
00:02:32,080 --> 00:02:34,239
google form for everybody to fill out if

78
00:02:34,239 --> 00:02:35,920
they would like to and we'll get that to

79
00:02:35,920 --> 00:02:39,040
you as well this week

80
00:02:39,599 --> 00:02:41,680
so again today just to kind of give you

81
00:02:41,680 --> 00:02:42,879
another overview of what we're going to

82
00:02:42,879 --> 00:02:44,319
be doing our

83
00:02:44,319 --> 00:02:46,080
final session for this first part here

84
00:02:46,080 --> 00:02:48,319
is talk about patch analysis the memory

85
00:02:48,319 --> 00:02:49,040
manager

86
00:02:49,040 --> 00:02:50,400
extension via scripting and we're going

87
00:02:50,400 --> 00:02:52,239
to dig into p-code which is

88
00:02:52,239 --> 00:02:53,840
the intermediate representation of

89
00:02:53,840 --> 00:02:55,280
assembly language that we've talked

90
00:02:55,280 --> 00:02:55,760
about

91
00:02:55,760 --> 00:02:58,720
in office hours here and there and so

92
00:02:58,720 --> 00:02:59,280
we'll walk

93
00:02:59,280 --> 00:03:01,599
through you know how to set all this

94
00:03:01,599 --> 00:03:02,800
stuff up how to set up the dev

95
00:03:02,800 --> 00:03:04,000
environment and things like that

96
00:03:04,000 --> 00:03:06,319
to kind of give you those initial tools

97
00:03:06,319 --> 00:03:07,519
that you would need

98
00:03:07,519 --> 00:03:08,959
if you wanted to take things further and

99
00:03:08,959 --> 00:03:11,200
start you know scripting and automating

100
00:03:11,200 --> 00:03:13,200
and just getting deeper into ghidra's

101
00:03:13,200 --> 00:03:15,040
internals

102
00:03:15,040 --> 00:03:18,319
and so with that the first thing we're

103
00:03:18,319 --> 00:03:20,000
going to talk about today is loading

104
00:03:20,000 --> 00:03:21,760
external libraries so some of you may

105
00:03:21,760 --> 00:03:22,800
have looked at

106
00:03:22,800 --> 00:03:27,120
the elf exercise from the first session

107
00:03:27,120 --> 00:03:29,440
where we had two different l files one

108
00:03:29,440 --> 00:03:30,159
of them

109
00:03:30,159 --> 00:03:32,000
loaded the other and called a function

110
00:03:32,000 --> 00:03:34,000
within it and so

111
00:03:34,000 --> 00:03:37,200
you can do this with gidra

112
00:03:37,200 --> 00:03:38,799
so you can when you're analyzing a

113
00:03:38,799 --> 00:03:40,239
binary if you see

114
00:03:40,239 --> 00:03:43,280
that it calls an external library that

115
00:03:43,280 --> 00:03:44,720
has some kind of function

116
00:03:44,720 --> 00:03:47,840
you can have guidra load that library on

117
00:03:47,840 --> 00:03:50,239
import and then when you're analyzing

118
00:03:50,239 --> 00:03:52,239
that binary you can actually navigate to

119
00:03:52,239 --> 00:03:53,120
that function

120
00:03:53,120 --> 00:03:56,080
in the other shared object and take a

121
00:03:56,080 --> 00:03:57,680
look at that

122
00:03:57,680 --> 00:04:00,640
as the you know as the decompiled output

123
00:04:00,640 --> 00:04:01,200
and so

124
00:04:01,200 --> 00:04:02,959
this can help with auto analysis because

125
00:04:02,959 --> 00:04:04,959
sometimes it can help generate

126
00:04:04,959 --> 00:04:08,000
better type recognition and also assist

127
00:04:08,000 --> 00:04:08,879
with the function

128
00:04:08,879 --> 00:04:12,319
prototype generation so i know we've

129
00:04:12,319 --> 00:04:13,519
talked about before

130
00:04:13,519 --> 00:04:16,000
some folks were wondering you know why

131
00:04:16,000 --> 00:04:17,519
sometimes the function prototypes are

132
00:04:17,519 --> 00:04:18,238
wrong

133
00:04:18,238 --> 00:04:19,519
and things like that and it's because a

134
00:04:19,519 --> 00:04:22,000
lot of guesses have to be made when that

135
00:04:22,000 --> 00:04:24,000
it takes place in order for it to be

136
00:04:24,000 --> 00:04:26,240
more generalized but if you can provide

137
00:04:26,240 --> 00:04:27,600
those other functions that are being

138
00:04:27,600 --> 00:04:28,240
called

139
00:04:28,240 --> 00:04:30,960
you can kind of assist the decompiler

140
00:04:30,960 --> 00:04:31,919
with

141
00:04:31,919 --> 00:04:34,400
generating those function prototypes and

142
00:04:34,400 --> 00:04:36,800
just general type recognition as well

143
00:04:36,800 --> 00:04:38,160
so we'll take a look at that real quick

144
00:04:38,160 --> 00:04:40,320
and how we might do that using

145
00:04:40,320 --> 00:04:43,040
the elf example from session one kind of

146
00:04:43,040 --> 00:04:46,320
is a springboard for that

147
00:04:47,199 --> 00:04:48,960
so here you can see this window that

148
00:04:48,960 --> 00:04:50,160
most of you are probably very familiar

149
00:04:50,160 --> 00:04:51,040
with by now

150
00:04:51,040 --> 00:04:52,560
right we're looking at kind of the

151
00:04:52,560 --> 00:04:54,560
summary of importing

152
00:04:54,560 --> 00:04:57,680
the legolas file okay

153
00:04:57,680 --> 00:04:59,919
and so if we look underneath in

154
00:04:59,919 --> 00:05:01,520
additional information

155
00:05:01,520 --> 00:05:04,400
we can see that these two libraries were

156
00:05:04,400 --> 00:05:06,080
not found

157
00:05:06,080 --> 00:05:09,520
and libsy.so.6 you've seen that for

158
00:05:09,520 --> 00:05:12,080
every binary that we've uh analyzed so

159
00:05:12,080 --> 00:05:12,639
far

160
00:05:12,639 --> 00:05:13,840
because they've all been linked with

161
00:05:13,840 --> 00:05:16,560
lipsy and but with this one you're also

162
00:05:16,560 --> 00:05:18,080
looking for this lib dobby

163
00:05:18,080 --> 00:05:20,320
dot so this additional library and so

164
00:05:20,320 --> 00:05:21,680
guidry can tell us that

165
00:05:21,680 --> 00:05:23,919
hey there were three external symbols

166
00:05:23,919 --> 00:05:25,600
that i actually couldn't find

167
00:05:25,600 --> 00:05:27,680
and so we're going to walk through how

168
00:05:27,680 --> 00:05:29,759
to point guidry to those external

169
00:05:29,759 --> 00:05:30,479
binaries

170
00:05:30,479 --> 00:05:33,758
and analyze those as well

171
00:05:34,400 --> 00:05:36,880
so when we're looking at this legolas

172
00:05:36,880 --> 00:05:38,880
binary this elf that we'd written

173
00:05:38,880 --> 00:05:40,400
those of you that looked at it probably

174
00:05:40,400 --> 00:05:42,240
got to this point where

175
00:05:42,240 --> 00:05:45,680
we see that main calls puts and says

176
00:05:45,680 --> 00:05:47,440
you have my program headers and then we

177
00:05:47,440 --> 00:05:49,199
call and this function called elf

178
00:05:49,199 --> 00:05:50,080
example

179
00:05:50,080 --> 00:05:51,840
and this function alpha example doesn't

180
00:05:51,840 --> 00:05:53,360
exist anywhere in the binary because

181
00:05:53,360 --> 00:05:53,919
it's being

182
00:05:53,919 --> 00:05:58,240
imported from the other shared object

183
00:05:58,240 --> 00:06:01,120
and so in order to on at load time when

184
00:06:01,120 --> 00:06:02,319
we load this into geidra

185
00:06:02,319 --> 00:06:05,120
in order to tell guidra hey i know i

186
00:06:05,120 --> 00:06:07,360
have a place that i will point you to

187
00:06:07,360 --> 00:06:09,759
to look for other shared objects that

188
00:06:09,759 --> 00:06:11,199
are used by this binary

189
00:06:11,199 --> 00:06:13,440
you click options and then that's going

190
00:06:13,440 --> 00:06:15,120
to bring up this options menu

191
00:06:15,120 --> 00:06:16,400
and some of you probably saw some of

192
00:06:16,400 --> 00:06:18,800
this when we were working on the various

193
00:06:18,800 --> 00:06:20,240
firmware images and things in the office

194
00:06:20,240 --> 00:06:21,919
hour where we changed the image base and

195
00:06:21,919 --> 00:06:23,120
things like that

196
00:06:23,120 --> 00:06:24,479
but what we're going to do for this

197
00:06:24,479 --> 00:06:26,240
because we're trying to load an

198
00:06:26,240 --> 00:06:27,680
additional library

199
00:06:27,680 --> 00:06:29,840
we're going to click the check box for

200
00:06:29,840 --> 00:06:31,440
load external libraries and then we're

201
00:06:31,440 --> 00:06:32,840
going to click edit

202
00:06:32,840 --> 00:06:35,759
paths

203
00:06:35,759 --> 00:06:37,520
and that's going to bring up this window

204
00:06:37,520 --> 00:06:39,440
of all the paths that it uses to look

205
00:06:39,440 --> 00:06:40,080
for

206
00:06:40,080 --> 00:06:42,560
some of these shared objects so i am on

207
00:06:42,560 --> 00:06:43,520
a windows machine

208
00:06:43,520 --> 00:06:45,600
analyzing linux binary so it wasn't able

209
00:06:45,600 --> 00:06:47,360
to find libc.so

210
00:06:47,360 --> 00:06:49,360
right now if i were on a linux machine

211
00:06:49,360 --> 00:06:50,560
maybe it would have it would have been

212
00:06:50,560 --> 00:06:52,080
able to find that but it wasn't able to

213
00:06:52,080 --> 00:06:53,520
and it also

214
00:06:53,520 --> 00:06:55,479
certainly wasn't able to find

215
00:06:55,479 --> 00:06:56,720
lib.dabi.sl

216
00:06:56,720 --> 00:06:58,560
because that's not a standard binary

217
00:06:58,560 --> 00:07:00,400
that's included so

218
00:07:00,400 --> 00:07:02,800
in order to add that folder just click

219
00:07:02,800 --> 00:07:03,680
on

220
00:07:03,680 --> 00:07:06,560
this plus sign here and that's going to

221
00:07:06,560 --> 00:07:07,520
bring you to

222
00:07:07,520 --> 00:07:11,039
a file navigation window here and so

223
00:07:11,039 --> 00:07:12,639
what you're going to do is just point it

224
00:07:12,639 --> 00:07:14,880
to the directory that contains the

225
00:07:14,880 --> 00:07:15,759
additional l

226
00:07:15,759 --> 00:07:18,560
files that you want to analyze so you do

227
00:07:18,560 --> 00:07:21,360
that and click ok

228
00:07:22,960 --> 00:07:25,039
and then here now we can see when we

229
00:07:25,039 --> 00:07:27,360
re-import legolas with the new

230
00:07:27,360 --> 00:07:30,319
import definitions in place that we

231
00:07:30,319 --> 00:07:31,680
found libdabi.cell

232
00:07:31,680 --> 00:07:33,599
and there's only two unresolved symbols

233
00:07:33,599 --> 00:07:36,400
the ones that were previously from libsy

234
00:07:36,400 --> 00:07:37,680
so let's take a look at this let's see

235
00:07:37,680 --> 00:07:40,160
what this looks like now that we have

236
00:07:40,160 --> 00:07:45,840
imported this you know additional binary

237
00:07:46,479 --> 00:07:48,879
so it looks fairly similar right we've

238
00:07:48,879 --> 00:07:49,680
got

239
00:07:49,680 --> 00:07:52,160
the elf example function call here that

240
00:07:52,160 --> 00:07:53,919
we saw previously and if we double click

241
00:07:53,919 --> 00:07:55,360
that right it's going to take us

242
00:07:55,360 --> 00:07:59,280
to the relevant plt entry in the binary

243
00:07:59,280 --> 00:08:02,639
and so we get here and it's still

244
00:08:02,639 --> 00:08:04,639
not something we can analyze we have bad

245
00:08:04,639 --> 00:08:07,039
data but if we want to

246
00:08:07,039 --> 00:08:09,440
we have the other shared object loaded

247
00:08:09,440 --> 00:08:10,960
so we can tell guidra

248
00:08:10,960 --> 00:08:13,120
to open that for us and analyze it for

249
00:08:13,120 --> 00:08:14,800
us by opening up

250
00:08:14,800 --> 00:08:17,120
the imports window and so as you

251
00:08:17,120 --> 00:08:17,919
remember from

252
00:08:17,919 --> 00:08:21,120
session one we talked about the imports

253
00:08:21,120 --> 00:08:22,720
and exports window

254
00:08:22,720 --> 00:08:24,800
and so here we can open up this imports

255
00:08:24,800 --> 00:08:26,080
window and find

256
00:08:26,080 --> 00:08:28,599
that function that we care about from

257
00:08:28,599 --> 00:08:30,400
libdabi.so

258
00:08:30,400 --> 00:08:32,000
and then we can click go to external

259
00:08:32,000 --> 00:08:33,839
location and so when we do that it's

260
00:08:33,839 --> 00:08:35,679
actually going to import and analyze

261
00:08:35,679 --> 00:08:37,200
that shared object and so it's going to

262
00:08:37,200 --> 00:08:39,200
look very similar you're going to get

263
00:08:39,200 --> 00:08:40,640
this message that we've always got

264
00:08:40,640 --> 00:08:42,719
before so lib dobby.so it's not been

265
00:08:42,719 --> 00:08:44,640
analyzed would you like to analyze it

266
00:08:44,640 --> 00:08:46,080
and then when you click yes it's going

267
00:08:46,080 --> 00:08:48,000
to import the binary and analyze it just

268
00:08:48,000 --> 00:08:49,440
like any other elf file because that's

269
00:08:49,440 --> 00:08:50,959
all these shared objects are

270
00:08:50,959 --> 00:08:55,360
right these are just standard out files

271
00:08:55,360 --> 00:08:57,279
and so now now that we've done that you

272
00:08:57,279 --> 00:08:59,600
can see here we have this other tab

273
00:08:59,600 --> 00:09:03,360
with the libby.so and so when we double

274
00:09:03,360 --> 00:09:04,000
click

275
00:09:04,000 --> 00:09:07,360
on this label right here

276
00:09:07,360 --> 00:09:09,200
it's actually going to jump to it in the

277
00:09:09,200 --> 00:09:12,880
other function and so when we do that

278
00:09:12,880 --> 00:09:14,240
it jumps into the other function and it

279
00:09:14,240 --> 00:09:16,080
shows us right here where all that

280
00:09:16,080 --> 00:09:17,760
function does is just call puts

281
00:09:17,760 --> 00:09:19,920
you know bad elf go back to your library

282
00:09:19,920 --> 00:09:20,800
and so the

283
00:09:20,800 --> 00:09:22,800
the purpose of of this exercise

284
00:09:22,800 --> 00:09:24,959
originally was just to show

285
00:09:24,959 --> 00:09:27,120
uh those of you that were interested how

286
00:09:27,120 --> 00:09:28,560
to take a look

287
00:09:28,560 --> 00:09:30,480
at the elf headers and figure out

288
00:09:30,480 --> 00:09:32,480
imports and exports even though

289
00:09:32,480 --> 00:09:35,519
geidra lays those out for you in the

290
00:09:35,519 --> 00:09:37,120
imports and exports table

291
00:09:37,120 --> 00:09:39,519
the point of that exercise was just for

292
00:09:39,519 --> 00:09:40,880
everybody to understand okay

293
00:09:40,880 --> 00:09:43,440
this l file loads this other one and

294
00:09:43,440 --> 00:09:44,080
calls

295
00:09:44,080 --> 00:09:46,080
this particular function from it and so

296
00:09:46,080 --> 00:09:47,200
that's how you can

297
00:09:47,200 --> 00:09:49,040
set up gidra to do that for you when

298
00:09:49,040 --> 00:09:50,560
you're analyzing some of these binaries

299
00:09:50,560 --> 00:09:51,040
so

300
00:09:51,040 --> 00:09:52,880
this would be useful if maybe you have a

301
00:09:52,880 --> 00:09:54,399
file system image from something that

302
00:09:54,399 --> 00:09:56,000
you're trying to look at and there's

303
00:09:56,000 --> 00:09:58,800
a massive amount of you know proprietary

304
00:09:58,800 --> 00:09:59,760
shared objects

305
00:09:59,760 --> 00:10:02,640
that you need to analyze not necessarily

306
00:10:02,640 --> 00:10:03,920
at once but you want them to be

307
00:10:03,920 --> 00:10:07,040
available in case you need them so

308
00:10:07,040 --> 00:10:08,480
you can jump to them in the external

309
00:10:08,480 --> 00:10:10,000
function then analyze them and see what

310
00:10:10,000 --> 00:10:11,519
the code does and then jump back and

311
00:10:11,519 --> 00:10:13,360
then you can use that information right

312
00:10:13,360 --> 00:10:14,880
to better inform

313
00:10:14,880 --> 00:10:17,440
the decompiler and to better manage your

314
00:10:17,440 --> 00:10:20,720
function prototypes and things like that

315
00:10:20,720 --> 00:10:23,519
and so with that you know we're talking

316
00:10:23,519 --> 00:10:25,200
about looking at multiple binaries we're

317
00:10:25,200 --> 00:10:26,000
talking about

318
00:10:26,000 --> 00:10:28,560
binaries that import other binaries and

319
00:10:28,560 --> 00:10:30,000
so one thing i wanted to go over with

320
00:10:30,000 --> 00:10:30,560
everybody

321
00:10:30,560 --> 00:10:32,720
that for those of you that are maybe

322
00:10:32,720 --> 00:10:34,480
watching these videos before doing all

323
00:10:34,480 --> 00:10:35,839
the exercises

324
00:10:35,839 --> 00:10:38,079
is patch diffing and that's something

325
00:10:38,079 --> 00:10:39,360
that guidry can do

326
00:10:39,360 --> 00:10:42,640
fairly well so one of the other

327
00:10:42,640 --> 00:10:44,240
main features that geidra has that's

328
00:10:44,240 --> 00:10:48,160
super useful is giger allows you to

329
00:10:48,160 --> 00:10:50,560
check in and check out changes to

330
00:10:50,560 --> 00:10:52,320
binaries in a project we haven't really

331
00:10:52,320 --> 00:10:54,160
talked a whole lot about

332
00:10:54,160 --> 00:10:56,079
setting up a guitar server and setting

333
00:10:56,079 --> 00:10:57,519
up a collaborative

334
00:10:57,519 --> 00:10:59,519
re environment but that's something

335
00:10:59,519 --> 00:11:01,120
deidre is capable of doing

336
00:11:01,120 --> 00:11:04,480
so similar to a get workflow when you

337
00:11:04,480 --> 00:11:06,720
log into a guide server and pull down a

338
00:11:06,720 --> 00:11:08,320
project you can check out the latest

339
00:11:08,320 --> 00:11:09,279
changes

340
00:11:09,279 --> 00:11:11,839
and apply those to your binary and using

341
00:11:11,839 --> 00:11:12,959
that same

342
00:11:12,959 --> 00:11:16,240
functionality guidra has a patch diffing

343
00:11:16,240 --> 00:11:19,360
feature that lets you track differences

344
00:11:19,360 --> 00:11:20,000
between

345
00:11:20,000 --> 00:11:21,360
you know two different binaries that are

346
00:11:21,360 --> 00:11:23,040
fairly similar and run

347
00:11:23,040 --> 00:11:24,959
you know various analysis scripts on top

348
00:11:24,959 --> 00:11:27,600
of that and so

349
00:11:27,600 --> 00:11:29,839
the version tracking feature you can use

350
00:11:29,839 --> 00:11:30,800
to kind of

351
00:11:30,800 --> 00:11:32,480
track maybe like minor changes to a

352
00:11:32,480 --> 00:11:34,240
binary and things like that and so we're

353
00:11:34,240 --> 00:11:35,440
going to show

354
00:11:35,440 --> 00:11:37,920
how to set that up with uh with a simple

355
00:11:37,920 --> 00:11:42,000
example here

356
00:11:42,000 --> 00:11:43,360
so we have this project where we have

357
00:11:43,360 --> 00:11:45,600
two files patch and patch two and these

358
00:11:45,600 --> 00:11:47,600
files are are slightly different

359
00:11:47,600 --> 00:11:49,519
but again we're working from just the

360
00:11:49,519 --> 00:11:50,639
compiled

361
00:11:50,639 --> 00:11:52,240
binaries that we have here of patch one

362
00:11:52,240 --> 00:11:54,000
and patch two so you know

363
00:11:54,000 --> 00:11:57,040
running you can run diff and you can you

364
00:11:57,040 --> 00:11:58,560
know diff the hex dumps if you want to

365
00:11:58,560 --> 00:11:59,680
see where things are different but

366
00:11:59,680 --> 00:12:00,000
that's

367
00:12:00,000 --> 00:12:01,360
that's only going to get you so far

368
00:12:01,360 --> 00:12:02,320
right obviously they're going to be

369
00:12:02,320 --> 00:12:03,519
different header information is

370
00:12:03,519 --> 00:12:05,120
different size is different checksums

371
00:12:05,120 --> 00:12:05,600
are different

372
00:12:05,600 --> 00:12:09,920
etc so we can start the version tracking

373
00:12:09,920 --> 00:12:12,079
manager by clicking these little feet

374
00:12:12,079 --> 00:12:16,079
right next to the dragon here

375
00:12:16,079 --> 00:12:17,279
and so that's going to bring up this

376
00:12:17,279 --> 00:12:19,200
this version tracking wizard and

377
00:12:19,200 --> 00:12:20,880
there's lots of fields in here there's

378
00:12:20,880 --> 00:12:22,800
lots of different columns there's all

379
00:12:22,800 --> 00:12:24,000
kinds of stuff here

380
00:12:24,000 --> 00:12:26,560
and so what we're going to do is start

381
00:12:26,560 --> 00:12:28,399
up the version tracking wizard which is

382
00:12:28,399 --> 00:12:29,839
a quick and easy way to kind of

383
00:12:29,839 --> 00:12:31,600
import two things to compare them

384
00:12:31,600 --> 00:12:33,040
against one another

385
00:12:33,040 --> 00:12:37,200
and so to do that we again click up here

386
00:12:37,200 --> 00:12:39,120
and so what this is going to do is this

387
00:12:39,120 --> 00:12:40,639
is going to open up

388
00:12:40,639 --> 00:12:43,440
this version tracking wizard for us and

389
00:12:43,440 --> 00:12:44,800
if you want to start it up in a new

390
00:12:44,800 --> 00:12:45,839
session you can

391
00:12:45,839 --> 00:12:48,320
it's going to load this into the same

392
00:12:48,320 --> 00:12:49,839
project folder that you were working in

393
00:12:49,839 --> 00:12:50,959
before

394
00:12:50,959 --> 00:12:52,800
and so what we're going to do is we're

395
00:12:52,800 --> 00:12:54,720
going to load a source and a destination

396
00:12:54,720 --> 00:12:56,320
program so the source is going to be our

397
00:12:56,320 --> 00:12:57,600
baseline

398
00:12:57,600 --> 00:12:59,839
and the destination program is what

399
00:12:59,839 --> 00:13:01,040
we're going to be comparing everything

400
00:13:01,040 --> 00:13:02,160
against

401
00:13:02,160 --> 00:13:03,200
and so those of you that have already

402
00:13:03,200 --> 00:13:05,519
done all the exercises you're probably

403
00:13:05,519 --> 00:13:06,959
realizing that you know this this

404
00:13:06,959 --> 00:13:08,800
feature would be

405
00:13:08,800 --> 00:13:10,560
pretty useful especially for all the

406
00:13:10,560 --> 00:13:12,160
exercises in session three

407
00:13:12,160 --> 00:13:13,680
because all the ones in session three

408
00:13:13,680 --> 00:13:15,360
are kind of built off the same

409
00:13:15,360 --> 00:13:18,880
core code base and so if you want to go

410
00:13:18,880 --> 00:13:19,279
back

411
00:13:19,279 --> 00:13:21,440
as a test to see what change between the

412
00:13:21,440 --> 00:13:23,040
two i'd highly recommend using this

413
00:13:23,040 --> 00:13:24,800
as a way to get more familiar with the

414
00:13:24,800 --> 00:13:26,560
patch but let's

415
00:13:26,560 --> 00:13:28,720
actually see what it looks like right so

416
00:13:28,720 --> 00:13:31,200
we add those two binaries

417
00:13:31,200 --> 00:13:32,959
and then it asks for our source program

418
00:13:32,959 --> 00:13:34,639
so we tell it patch we'll do the same

419
00:13:34,639 --> 00:13:36,079
thing for patch two

420
00:13:36,079 --> 00:13:38,959
and so now we have our source binary

421
00:13:38,959 --> 00:13:40,560
which is just patch and our

422
00:13:40,560 --> 00:13:43,360
destination binary which is patch two

423
00:13:43,360 --> 00:13:44,320
and so when we click

424
00:13:44,320 --> 00:13:46,160
next it's gonna bring us up to this

425
00:13:46,160 --> 00:13:47,519
precondition checklist

426
00:13:47,519 --> 00:13:49,920
so this just goes through and make sure

427
00:13:49,920 --> 00:13:51,360
that all the conditions are met so that

428
00:13:51,360 --> 00:13:52,639
it can actually run

429
00:13:52,639 --> 00:13:55,279
the various patch analyses on it so what

430
00:13:55,279 --> 00:13:56,720
you're going to do here is click run

431
00:13:56,720 --> 00:13:59,199
precondition checks

432
00:13:59,199 --> 00:14:01,199
okay great so in this case they all

433
00:14:01,199 --> 00:14:02,959
passed

434
00:14:02,959 --> 00:14:05,600
and then click next and then you're just

435
00:14:05,600 --> 00:14:07,120
going to click finish

436
00:14:07,120 --> 00:14:08,720
and what happens when you click finish

437
00:14:08,720 --> 00:14:10,160
is it will open up

438
00:14:10,160 --> 00:14:12,000
two versions two different two separate

439
00:14:12,000 --> 00:14:14,000
code browsers

440
00:14:14,000 --> 00:14:15,519
and you'll see we have one for source

441
00:14:15,519 --> 00:14:17,279
tool on the left i apologize if the font

442
00:14:17,279 --> 00:14:18,959
is fairly small and you can't see

443
00:14:18,959 --> 00:14:21,360
but the code browser for source tools on

444
00:14:21,360 --> 00:14:22,079
the left

445
00:14:22,079 --> 00:14:23,760
and the one for destination tool is on

446
00:14:23,760 --> 00:14:26,000
the right and so you also see if you

447
00:14:26,000 --> 00:14:27,519
look in this bottom right hand corner

448
00:14:27,519 --> 00:14:29,279
here of each one we have the version

449
00:14:29,279 --> 00:14:30,160
tracking

450
00:14:30,160 --> 00:14:32,720
match window there which can be used to

451
00:14:32,720 --> 00:14:34,160
kind of synchronize between the two

452
00:14:34,160 --> 00:14:34,880
windows

453
00:14:34,880 --> 00:14:36,880
but you'll notice that there's nothing

454
00:14:36,880 --> 00:14:38,880
in here that's because we didn't give it

455
00:14:38,880 --> 00:14:40,639
certain things to track

456
00:14:40,639 --> 00:14:42,560
so if we go back into the version

457
00:14:42,560 --> 00:14:43,680
tracking wizard

458
00:14:43,680 --> 00:14:46,240
we can add correlations to be tracked

459
00:14:46,240 --> 00:14:47,040
across

460
00:14:47,040 --> 00:14:49,440
these two different binaries right so we

461
00:14:49,440 --> 00:14:51,920
do that by clicking on the plus sign

462
00:14:51,920 --> 00:14:54,160
and here we get all kinds of correlation

463
00:14:54,160 --> 00:14:55,680
algorithms and so these are the only

464
00:14:55,680 --> 00:14:57,120
ones these are the ones that are you

465
00:14:57,120 --> 00:14:58,320
know included

466
00:14:58,320 --> 00:15:01,199
but if you you know look for these in

467
00:15:01,199 --> 00:15:02,720
the git repository you could add your

468
00:15:02,720 --> 00:15:04,320
own if you had other correlations that

469
00:15:04,320 --> 00:15:05,920
you wanted to run

470
00:15:05,920 --> 00:15:08,240
so let's say you wanted to try to

471
00:15:08,240 --> 00:15:09,040
compare

472
00:15:09,040 --> 00:15:10,800
you know specific set of symbols across

473
00:15:10,800 --> 00:15:12,160
two binaries or something like that you

474
00:15:12,160 --> 00:15:13,360
could add your own

475
00:15:13,360 --> 00:15:15,279
correlation algorithm here which would

476
00:15:15,279 --> 00:15:16,560
which is

477
00:15:16,560 --> 00:15:18,160
you know a fun exercise to do if you

478
00:15:18,160 --> 00:15:20,000
haven't and so

479
00:15:20,000 --> 00:15:21,040
what we're going to do is we're just

480
00:15:21,040 --> 00:15:22,639
going to select all of these so we want

481
00:15:22,639 --> 00:15:24,399
it to tell us every kind of match so if

482
00:15:24,399 --> 00:15:25,839
you look at these correlation algorithms

483
00:15:25,839 --> 00:15:27,199
there's all kinds of you have

484
00:15:27,199 --> 00:15:29,440
exact data match exact function bytes

485
00:15:29,440 --> 00:15:30,880
match exact function

486
00:15:30,880 --> 00:15:33,600
instructions match so this is going to

487
00:15:33,600 --> 00:15:34,959
do kind of a by byte

488
00:15:34,959 --> 00:15:37,600
comparison of these two binaries and

489
00:15:37,600 --> 00:15:40,959
gather all of this information for us

490
00:15:40,959 --> 00:15:42,399
and so once we set up the correlations

491
00:15:42,399 --> 00:15:44,240
we click next and this is going to bring

492
00:15:44,240 --> 00:15:46,480
you into kind of an options

493
00:15:46,480 --> 00:15:49,279
window that you can use to set the

494
00:15:49,279 --> 00:15:50,480
various

495
00:15:50,480 --> 00:15:52,959
parameters for these algorithms that are

496
00:15:52,959 --> 00:15:54,399
going to run and so if you're doing this

497
00:15:54,399 --> 00:15:54,959
you know

498
00:15:54,959 --> 00:15:57,759
if you're comparing two fairly large uh

499
00:15:57,759 --> 00:15:59,360
programs this might take some time so

500
00:15:59,360 --> 00:16:01,519
this will let you set various things

501
00:16:01,519 --> 00:16:04,160
like how many instructions you want to

502
00:16:04,160 --> 00:16:06,079
match in a function before

503
00:16:06,079 --> 00:16:08,320
you spit out a proper function

504
00:16:08,320 --> 00:16:10,240
correlation match so you can say oh here

505
00:16:10,240 --> 00:16:11,839
we're saying oh i want at least 10

506
00:16:11,839 --> 00:16:13,279
instructions to match before i say it's

507
00:16:13,279 --> 00:16:14,320
okay and here i

508
00:16:14,320 --> 00:16:17,360
want at least 10 mnemonic matches before

509
00:16:17,360 --> 00:16:19,360
we actually say that it's a match so you

510
00:16:19,360 --> 00:16:21,600
can tweak these to meet whatever

511
00:16:21,600 --> 00:16:23,600
use case you have when you're setting up

512
00:16:23,600 --> 00:16:25,440
the patch different

513
00:16:25,440 --> 00:16:28,240
and so from here we click next and then

514
00:16:28,240 --> 00:16:30,000
again there's more options that you can

515
00:16:30,000 --> 00:16:31,440
configure we're not going to set any of

516
00:16:31,440 --> 00:16:34,000
these for this example

517
00:16:34,000 --> 00:16:36,959
and then again we click next and so here

518
00:16:36,959 --> 00:16:38,079
it's telling us

519
00:16:38,079 --> 00:16:39,759
all right here's my source program the

520
00:16:39,759 --> 00:16:41,519
destination program here's everything

521
00:16:41,519 --> 00:16:43,360
all the correlators we're going to run

522
00:16:43,360 --> 00:16:46,720
and then finally we click finish

523
00:16:47,199 --> 00:16:48,720
and so it'll tell you right away okay

524
00:16:48,720 --> 00:16:50,000
there weren't any function reference

525
00:16:50,000 --> 00:16:52,000
matches or data reference matches

526
00:16:52,000 --> 00:16:54,959
but there was plenty of other matches so

527
00:16:54,959 --> 00:16:56,000
now

528
00:16:56,000 --> 00:16:57,600
our version tracking wizard looks like

529
00:16:57,600 --> 00:16:59,360
this and we've got all kinds of

530
00:16:59,360 --> 00:17:00,720
different things that

531
00:17:00,720 --> 00:17:02,240
you know some of these things match some

532
00:17:02,240 --> 00:17:03,839
of them don't some of them are similar

533
00:17:03,839 --> 00:17:05,280
some of them are exact

534
00:17:05,280 --> 00:17:07,119
and so if you look in the right column

535
00:17:07,119 --> 00:17:09,119
here we have the algorithm column and

536
00:17:09,119 --> 00:17:09,599
you can

537
00:17:09,599 --> 00:17:11,199
sort by that if you're looking for

538
00:17:11,199 --> 00:17:13,520
things that maybe are an exact match

539
00:17:13,520 --> 00:17:16,640
or a similar match and you can

540
00:17:16,640 --> 00:17:20,400
sort them by clicking on whatever column

541
00:17:20,400 --> 00:17:22,480
so maybe if you're only interested in if

542
00:17:22,480 --> 00:17:24,160
you want to source by address and just

543
00:17:24,160 --> 00:17:25,280
start at the

544
00:17:25,280 --> 00:17:26,640
base of the executable and work your way

545
00:17:26,640 --> 00:17:28,319
down you can do that if you want to sort

546
00:17:28,319 --> 00:17:30,240
by confidence level you can do that

547
00:17:30,240 --> 00:17:32,400
and you know all of these variables are

548
00:17:32,400 --> 00:17:34,240
tweaked within the various correlation

549
00:17:34,240 --> 00:17:36,080
algorithms that you're using

550
00:17:36,080 --> 00:17:39,840
so one difference here right we've

551
00:17:39,840 --> 00:17:41,760
selected the main function

552
00:17:41,760 --> 00:17:44,000
and here in the two patch windows we can

553
00:17:44,000 --> 00:17:44,799
see

554
00:17:44,799 --> 00:17:47,440
where some of these differences are so

555
00:17:47,440 --> 00:17:49,200
again just as a simple example right on

556
00:17:49,200 --> 00:17:50,880
the left most window we can see

557
00:17:50,880 --> 00:17:53,120
that the version string is version one

558
00:17:53,120 --> 00:17:55,200
and here it's version 1.1

559
00:17:55,200 --> 00:17:57,840
and then we can see that these constants

560
00:17:57,840 --> 00:17:58,559
are different

561
00:17:58,559 --> 00:18:01,760
we have beef deed and beef face

562
00:18:01,760 --> 00:18:04,960
and so these

563
00:18:04,960 --> 00:18:06,640
programs that we're looking at right now

564
00:18:06,640 --> 00:18:08,080
are fairly small but you can see if

565
00:18:08,080 --> 00:18:09,760
you're looking at you know a longer

566
00:18:09,760 --> 00:18:11,840
program that was maybe more complicated

567
00:18:11,840 --> 00:18:13,679
this is a super useful feature that you

568
00:18:13,679 --> 00:18:15,200
can take advantage of for doing you know

569
00:18:15,200 --> 00:18:17,760
patch diff

570
00:18:17,840 --> 00:18:20,240
and so this is just the way that it all

571
00:18:20,240 --> 00:18:22,559
looks in the version tracking wizard but

572
00:18:22,559 --> 00:18:24,160
you also again you'll have the same

573
00:18:24,160 --> 00:18:25,120
thing now

574
00:18:25,120 --> 00:18:28,240
in the code browser for each of these

575
00:18:28,240 --> 00:18:29,120
ones each for

576
00:18:29,120 --> 00:18:31,440
source and desk and so when you click on

577
00:18:31,440 --> 00:18:33,360
an area it'll populate

578
00:18:33,360 --> 00:18:37,039
the various uh algorithm matches that

579
00:18:37,039 --> 00:18:38,720
happened you know within within this

580
00:18:38,720 --> 00:18:39,600
function or

581
00:18:39,600 --> 00:18:41,679
near whatever you've recently clicked on

582
00:18:41,679 --> 00:18:43,440
so that's pretty cool too so if you just

583
00:18:43,440 --> 00:18:44,480
want it

584
00:18:44,480 --> 00:18:45,840
if you just want to have this there to

585
00:18:45,840 --> 00:18:47,600
analyze as you're going through the

586
00:18:47,600 --> 00:18:48,240
binary

587
00:18:48,240 --> 00:18:50,000
this is a fairly useful window to have

588
00:18:50,000 --> 00:18:51,679
comparing it to you know another patch

589
00:18:51,679 --> 00:18:56,799
spine area or something similar

590
00:18:56,799 --> 00:18:59,679
and so here is a different stripe the

591
00:18:59,679 --> 00:19:01,280
guidera was able to determine okay well

592
00:19:01,280 --> 00:19:02,720
you have the exact same symbol match

593
00:19:02,720 --> 00:19:03,919
here for this function and then when we

594
00:19:03,919 --> 00:19:04,720
load it up

595
00:19:04,720 --> 00:19:06,240
we can see that this is where they start

596
00:19:06,240 --> 00:19:08,080
to differ so if you look at the bottom

597
00:19:08,080 --> 00:19:09,280
here you'll see that the

598
00:19:09,280 --> 00:19:11,919
patch 2 actually added an additional add

599
00:19:11,919 --> 00:19:13,600
operation to this function

600
00:19:13,600 --> 00:19:15,520
as opposed to what patch one had and so

601
00:19:15,520 --> 00:19:16,960
this just lets you kind of

602
00:19:16,960 --> 00:19:18,640
cut through everything and get right

603
00:19:18,640 --> 00:19:20,240
down to the bottom of you know what has

604
00:19:20,240 --> 00:19:22,160
changed between these two binaries and

605
00:19:22,160 --> 00:19:24,080
so that'll be super useful

606
00:19:24,080 --> 00:19:26,080
if you want to go back and look at what

607
00:19:26,080 --> 00:19:27,919
changed between the various exercises

608
00:19:27,919 --> 00:19:28,960
for session three

609
00:19:28,960 --> 00:19:30,240
i would recommend doing that to get a

610
00:19:30,240 --> 00:19:32,640
better handle on how to use this patch

611
00:19:32,640 --> 00:19:34,559
stiffing tool

612
00:19:34,559 --> 00:19:38,080
and so another simple way to check you

613
00:19:38,080 --> 00:19:39,600
know whether two binaries are different

614
00:19:39,600 --> 00:19:40,000
or

615
00:19:40,000 --> 00:19:41,440
things like that there are you know

616
00:19:41,440 --> 00:19:43,200
using checksums

617
00:19:43,200 --> 00:19:45,600
so let's say you're looking at firmware

618
00:19:45,600 --> 00:19:46,880
image or something and maybe you've

619
00:19:46,880 --> 00:19:49,120
patched it and you want to quickly

620
00:19:49,120 --> 00:19:52,000
check all of the various checksums let's

621
00:19:52,000 --> 00:19:53,440
say you want you know that this image

622
00:19:53,440 --> 00:19:55,200
has a crc32

623
00:19:55,200 --> 00:19:57,280
and you've made your patches to it you

624
00:19:57,280 --> 00:19:58,559
think you've fixed up the checksum

625
00:19:58,559 --> 00:19:59,840
appropriately and you just want to check

626
00:19:59,840 --> 00:20:01,440
that quickly well geedra has you know a

627
00:20:01,440 --> 00:20:02,960
built-in checksum tool that you can

628
00:20:02,960 --> 00:20:03,840
access

629
00:20:03,840 --> 00:20:05,760
and on top of that within that checksum

630
00:20:05,760 --> 00:20:06,960
tool there's

631
00:20:06,960 --> 00:20:08,720
various transformations and operations

632
00:20:08,720 --> 00:20:11,280
you can apply to the checksum itself

633
00:20:11,280 --> 00:20:15,120
oh i've got a raised hand

634
00:20:16,880 --> 00:20:18,480
do you want to type out your question

635
00:20:18,480 --> 00:20:21,840
whoever raised their hand

636
00:20:30,080 --> 00:20:31,679
okay well if you type out your question

637
00:20:31,679 --> 00:20:34,159
uh for the raised hand i will get back

638
00:20:34,159 --> 00:20:35,600
to it

639
00:20:35,600 --> 00:20:37,039
at the end of the at the end of the

640
00:20:37,039 --> 00:20:38,880
session today

641
00:20:38,880 --> 00:20:41,760
so again with the checksum generator

642
00:20:41,760 --> 00:20:42,960
there's all kinds of options you can

643
00:20:42,960 --> 00:20:44,159
apply to the checksums

644
00:20:44,159 --> 00:20:46,799
and to open that just click window and

645
00:20:46,799 --> 00:20:48,159
then check some generator and some of

646
00:20:48,159 --> 00:20:49,600
you may have already seen this before i

647
00:20:49,600 --> 00:20:50,960
just wanted to go through it

648
00:20:50,960 --> 00:20:53,120
because this is sometimes a useful tool

649
00:20:53,120 --> 00:20:54,080
if you're looking at

650
00:20:54,080 --> 00:20:55,280
firmware images or things from an

651
00:20:55,280 --> 00:20:57,679
embedded system and so

652
00:20:57,679 --> 00:21:00,080
this is the checksum window and so you

653
00:21:00,080 --> 00:21:01,360
can see here we've got all kinds of

654
00:21:01,360 --> 00:21:03,120
different checksums that it includes by

655
00:21:03,120 --> 00:21:04,480
default you could of course add your own

656
00:21:04,480 --> 00:21:05,840
if you wanted to

657
00:21:05,840 --> 00:21:08,240
and so within that we've got you know

658
00:21:08,240 --> 00:21:10,880
ones complement you can see here

659
00:21:10,880 --> 00:21:12,240
once you click that you get the ones

660
00:21:12,240 --> 00:21:14,840
complement and here you've got the two's

661
00:21:14,840 --> 00:21:16,880
complement you can

662
00:21:16,880 --> 00:21:18,559
show it you know in hexadecimal value

663
00:21:18,559 --> 00:21:20,320
whatever and so there's all kinds of

664
00:21:20,320 --> 00:21:21,520
ways you can

665
00:21:21,520 --> 00:21:23,760
print out and show the various you know

666
00:21:23,760 --> 00:21:25,200
checksums for whatever program you're

667
00:21:25,200 --> 00:21:26,320
looking at

668
00:21:26,320 --> 00:21:27,520
and that's just something that i wanted

669
00:21:27,520 --> 00:21:28,960
to cover really quickly because that's a

670
00:21:28,960 --> 00:21:29,760
feature that

671
00:21:29,760 --> 00:21:31,679
some of you may end up needing later on

672
00:21:31,679 --> 00:21:33,280
down the road

673
00:21:33,280 --> 00:21:35,200
and probably what's more important for

674
00:21:35,200 --> 00:21:36,320
those of you that are interested in

675
00:21:36,320 --> 00:21:37,200
looking at

676
00:21:37,200 --> 00:21:38,640
embedded systems because you've talked

677
00:21:38,640 --> 00:21:39,840
we've talked about this quite a bit

678
00:21:39,840 --> 00:21:41,440
during the office hour it seems to be a

679
00:21:41,440 --> 00:21:43,200
fairly popular topic

680
00:21:43,200 --> 00:21:46,400
is the memory manager and so again those

681
00:21:46,400 --> 00:21:47,120
of you that

682
00:21:47,120 --> 00:21:48,559
were around for the office hours saw

683
00:21:48,559 --> 00:21:50,400
that we used this to

684
00:21:50,400 --> 00:21:53,360
fix up the memory map for an embedded

685
00:21:53,360 --> 00:21:55,360
processor that we were looking at

686
00:21:55,360 --> 00:21:58,400
and so the

687
00:21:58,400 --> 00:22:00,320
memory manager lets you add memory

688
00:22:00,320 --> 00:22:02,000
regions to giger's baked in memory map

689
00:22:02,000 --> 00:22:03,840
now we haven't had to do that

690
00:22:03,840 --> 00:22:06,080
for the elf files because all that

691
00:22:06,080 --> 00:22:07,760
information is already in the header

692
00:22:07,760 --> 00:22:10,799
and guide can do that and so

693
00:22:10,799 --> 00:22:12,799
for each memory region that you might

694
00:22:12,799 --> 00:22:14,559
add to the memory map

695
00:22:14,559 --> 00:22:16,000
you can set things like the start

696
00:22:16,000 --> 00:22:17,919
address the end address the

697
00:22:17,919 --> 00:22:19,520
memory permissions whether it's read

698
00:22:19,520 --> 00:22:21,280
write or execute and we kind of talked

699
00:22:21,280 --> 00:22:22,640
about this a little bit

700
00:22:22,640 --> 00:22:25,360
during office hour is that the way you

701
00:22:25,360 --> 00:22:27,280
set permissions for these

702
00:22:27,280 --> 00:22:29,280
memory regions changes the way that the

703
00:22:29,280 --> 00:22:31,200
analysis is performed on it right so

704
00:22:31,200 --> 00:22:32,799
if kidro knows that it's only read or

705
00:22:32,799 --> 00:22:34,159
write then it's not going to worry about

706
00:22:34,159 --> 00:22:35,679
anything that it might think it would be

707
00:22:35,679 --> 00:22:36,240
code

708
00:22:36,240 --> 00:22:39,440
in that region and so you can also set

709
00:22:39,440 --> 00:22:41,039
up a memory region as like an

710
00:22:41,039 --> 00:22:42,400
overlay region which would mean that it

711
00:22:42,400 --> 00:22:44,159
might overlap with another

712
00:22:44,159 --> 00:22:46,320
and so let's take a look at how to open

713
00:22:46,320 --> 00:22:49,918
up the memory manager and utilize it

714
00:22:50,880 --> 00:22:55,039
so from the gydra toolbar here

715
00:22:55,039 --> 00:22:56,799
you select this little looks like a

716
00:22:56,799 --> 00:22:58,240
little ic

717
00:22:58,240 --> 00:22:59,919
and you click on that and then it brings

718
00:22:59,919 --> 00:23:01,360
up the memory map and so

719
00:23:01,360 --> 00:23:03,440
what we have here is half of the memory

720
00:23:03,440 --> 00:23:05,760
map for what is the what's the game boy

721
00:23:05,760 --> 00:23:06,960
advanced memory map

722
00:23:06,960 --> 00:23:09,360
but if you wanted to add a new region of

723
00:23:09,360 --> 00:23:10,400
memory to this

724
00:23:10,400 --> 00:23:12,320
you would click on this plus sign and

725
00:23:12,320 --> 00:23:13,760
that's going to bring up

726
00:23:13,760 --> 00:23:16,960
this and so this is the window where you

727
00:23:16,960 --> 00:23:19,600
add all the parameters for the memory

728
00:23:19,600 --> 00:23:21,200
region that you're trying to add into

729
00:23:21,200 --> 00:23:21,760
ghidra

730
00:23:21,760 --> 00:23:23,440
so again we can set whether it's read

731
00:23:23,440 --> 00:23:25,120
write execute volatile

732
00:23:25,120 --> 00:23:26,880
you can set the name you can give it a

733
00:23:26,880 --> 00:23:28,240
start address length

734
00:23:28,240 --> 00:23:30,960
etc and so if you want to initialize

735
00:23:30,960 --> 00:23:31,760
that memory

736
00:23:31,760 --> 00:23:34,320
with a file let's say you've grabbed a

737
00:23:34,320 --> 00:23:35,840
random from something and you want to

738
00:23:35,840 --> 00:23:36,640
toss it in there

739
00:23:36,640 --> 00:23:38,559
you can do that so you can set it with

740
00:23:38,559 --> 00:23:40,159
file bytes you can set it to initialized

741
00:23:40,159 --> 00:23:41,520
or uninitialized

742
00:23:41,520 --> 00:23:44,559
and then let's say we just fill that out

743
00:23:44,559 --> 00:23:47,039
with this test block region here and

744
00:23:47,039 --> 00:23:48,000
we've set it to be

745
00:23:48,000 --> 00:23:51,120
rwx because it's extremely unsafe

746
00:23:51,120 --> 00:23:53,760
and we don't initialize it even better

747
00:23:53,760 --> 00:23:55,279
and so now we can see that this test

748
00:23:55,279 --> 00:23:56,240
block region

749
00:23:56,240 --> 00:23:58,080
shows up here and for those of you

750
00:23:58,080 --> 00:23:59,200
familiar with the game boy advance you

751
00:23:59,200 --> 00:24:00,559
probably realize that's actually where

752
00:24:00,559 --> 00:24:01,919
the bios would be

753
00:24:01,919 --> 00:24:05,679
in the gba and so

754
00:24:05,679 --> 00:24:07,760
when you're working with these memory

755
00:24:07,760 --> 00:24:09,360
regions particularly if you're working

756
00:24:09,360 --> 00:24:10,960
on you know some embedded platform where

757
00:24:10,960 --> 00:24:12,799
you might have like jtag access or

758
00:24:12,799 --> 00:24:13,840
something like that

759
00:24:13,840 --> 00:24:16,480
you can add binary files to these

760
00:24:16,480 --> 00:24:17,360
regions

761
00:24:17,360 --> 00:24:19,520
so if you get a ram dump or if you get a

762
00:24:19,520 --> 00:24:21,279
dump of some values in a peripheral

763
00:24:21,279 --> 00:24:21,840
maybe

764
00:24:21,840 --> 00:24:24,799
you can add that info to the program and

765
00:24:24,799 --> 00:24:25,440
then

766
00:24:25,440 --> 00:24:27,600
if it's something that you know might be

767
00:24:27,600 --> 00:24:28,880
bank switched or

768
00:24:28,880 --> 00:24:30,480
referenced you know fairly regularly and

769
00:24:30,480 --> 00:24:32,480
you want to still try to map out the

770
00:24:32,480 --> 00:24:33,440
entire

771
00:24:33,440 --> 00:24:35,120
memory region of whatever target you're

772
00:24:35,120 --> 00:24:37,440
looking at you can set up memory regions

773
00:24:37,440 --> 00:24:39,200
as overlay blocks

774
00:24:39,200 --> 00:24:41,760
and probably most importantly and one of

775
00:24:41,760 --> 00:24:43,520
the more useful things about this

776
00:24:43,520 --> 00:24:46,240
is you can instrument this through

777
00:24:46,240 --> 00:24:47,440
guidra's api

778
00:24:47,440 --> 00:24:49,120
and so if you look at you know people

779
00:24:49,120 --> 00:24:50,960
that have written example loaders

780
00:24:50,960 --> 00:24:53,760
there's the svd loader for stm32 chips

781
00:24:53,760 --> 00:24:55,200
that's really good and that you know

782
00:24:55,200 --> 00:24:57,440
utilizes this functionality to

783
00:24:57,440 --> 00:25:00,320
on-the-fly generate memory regions for

784
00:25:00,320 --> 00:25:03,678
whatever you're reverse engineering

785
00:25:04,640 --> 00:25:06,799
and so with that you know we've talked

786
00:25:06,799 --> 00:25:08,880
about some of the

787
00:25:08,880 --> 00:25:11,279
user facing features that everybody can

788
00:25:11,279 --> 00:25:13,200
take advantage of if they're looking at

789
00:25:13,200 --> 00:25:14,000
you know these

790
00:25:14,000 --> 00:25:15,600
exercises if they're looking at you know

791
00:25:15,600 --> 00:25:17,039
maybe a firmware image

792
00:25:17,039 --> 00:25:19,360
something i really wanted to get through

793
00:25:19,360 --> 00:25:20,799
with everybody here

794
00:25:20,799 --> 00:25:22,960
before we closed out this first chunk of

795
00:25:22,960 --> 00:25:24,080
the course

796
00:25:24,080 --> 00:25:27,120
is some of the more internal features of

797
00:25:27,120 --> 00:25:28,960
gedra and kind of how it works

798
00:25:28,960 --> 00:25:32,080
uh from the inside and so the

799
00:25:32,080 --> 00:25:33,760
we've gotten a lot of questions about

800
00:25:33,760 --> 00:25:35,120
the compiler we've gotten a lot of

801
00:25:35,120 --> 00:25:37,039
questions about the disassembler and

802
00:25:37,039 --> 00:25:38,640
things like that and i wanted to just

803
00:25:38,640 --> 00:25:41,360
provide kind of a 10 000 foot view of

804
00:25:41,360 --> 00:25:42,080
how that stuff

805
00:25:42,080 --> 00:25:44,720
works and so we've talked about you know

806
00:25:44,720 --> 00:25:46,480
one of guidra's most powerful

807
00:25:46,480 --> 00:25:48,640
features being that it has this

808
00:25:48,640 --> 00:25:49,840
decompiler

809
00:25:49,840 --> 00:25:52,080
right that works with almost every

810
00:25:52,080 --> 00:25:53,840
processor that it supports

811
00:25:53,840 --> 00:25:56,320
and so if you want to include a new

812
00:25:56,320 --> 00:25:58,159
processor if you want to add support for

813
00:25:58,159 --> 00:25:59,279
a new processor you're going to

814
00:25:59,279 --> 00:26:01,520
implement that in what's called slay

815
00:26:01,520 --> 00:26:03,520
and we'll talk about that later on but

816
00:26:03,520 --> 00:26:05,600
slay is the language that's used to

817
00:26:05,600 --> 00:26:06,400
define

818
00:26:06,400 --> 00:26:09,760
these processors and what that defines

819
00:26:09,760 --> 00:26:10,159
is

820
00:26:10,159 --> 00:26:13,520
how we actually go from the raw bytes

821
00:26:13,520 --> 00:26:15,200
that we talked about back in session one

822
00:26:15,200 --> 00:26:16,640
remember we discussed how

823
00:26:16,640 --> 00:26:18,320
you know going from raw bytes to

824
00:26:18,320 --> 00:26:19,679
assembly is disassembly

825
00:26:19,679 --> 00:26:21,840
and then going from that to a higher

826
00:26:21,840 --> 00:26:23,440
level of something that looks like

827
00:26:23,440 --> 00:26:24,720
c that we're used to is you know

828
00:26:24,720 --> 00:26:27,200
decompilation and so the way gidra does

829
00:26:27,200 --> 00:26:28,559
that

830
00:26:28,559 --> 00:26:31,520
is we decode the bytes to assembly code

831
00:26:31,520 --> 00:26:32,159
via

832
00:26:32,159 --> 00:26:33,679
parameters that are outlined in slave

833
00:26:33,679 --> 00:26:35,600
files that we're going to talk about

834
00:26:35,600 --> 00:26:37,200
and then that also generates what's

835
00:26:37,200 --> 00:26:38,799
called p code which is an

836
00:26:38,799 --> 00:26:41,360
intermediate representation of how the

837
00:26:41,360 --> 00:26:42,960
assembly instructions work and we'll get

838
00:26:42,960 --> 00:26:44,799
into what that looks like as well

839
00:26:44,799 --> 00:26:46,640
and what you really need to take home

840
00:26:46,640 --> 00:26:48,480
about all this is that

841
00:26:48,480 --> 00:26:51,360
the p code is used across every

842
00:26:51,360 --> 00:26:52,080
processor

843
00:26:52,080 --> 00:26:55,200
and the reason for that is so that the

844
00:26:55,200 --> 00:26:56,480
algorithms that generate the

845
00:26:56,480 --> 00:26:58,480
decompilation you know can operate on p

846
00:26:58,480 --> 00:27:00,799
code instead of worrying about specifics

847
00:27:00,799 --> 00:27:02,960
for each particular processor

848
00:27:02,960 --> 00:27:05,440
so whatever no matter what the processor

849
00:27:05,440 --> 00:27:06,880
is when it gets loaded and analyzed by

850
00:27:06,880 --> 00:27:09,120
ghidra and p code gets generated that p

851
00:27:09,120 --> 00:27:11,840
code language can almost be thought of

852
00:27:11,840 --> 00:27:13,279
as a language for

853
00:27:13,279 --> 00:27:15,440
modeling processor behavior and the

854
00:27:15,440 --> 00:27:17,440
documentation for it in the gig resource

855
00:27:17,440 --> 00:27:18,799
is actually really good

856
00:27:18,799 --> 00:27:20,960
so essentially when something gets

857
00:27:20,960 --> 00:27:22,080
initially analyzed we

858
00:27:22,080 --> 00:27:24,640
can have you know two passes when

859
00:27:24,640 --> 00:27:26,480
disassembly we have disassembly and then

860
00:27:26,480 --> 00:27:27,440
we have p code

861
00:27:27,440 --> 00:27:29,200
and those are both generated by what is

862
00:27:29,200 --> 00:27:30,799
in these slave files

863
00:27:30,799 --> 00:27:35,120
so let's talk about those really quickly

864
00:27:35,120 --> 00:27:37,520
so again slay kind of specifies that

865
00:27:37,520 --> 00:27:39,919
translation from assembly language to p

866
00:27:39,919 --> 00:27:42,960
code it also is what

867
00:27:42,960 --> 00:27:44,799
defines the parameters needed for

868
00:27:44,799 --> 00:27:46,480
disassembly as well

869
00:27:46,480 --> 00:27:49,760
and so this is kind of like we mentioned

870
00:27:49,760 --> 00:27:50,399
before

871
00:27:50,399 --> 00:27:53,600
this is a language that's used to create

872
00:27:53,600 --> 00:27:56,559
these processor modules that then

873
00:27:56,559 --> 00:27:57,520
generates

874
00:27:57,520 --> 00:27:59,760
the immediate representation or the il

875
00:27:59,760 --> 00:28:01,039
of the language

876
00:28:01,039 --> 00:28:03,600
that defines the processor behavior and

877
00:28:03,600 --> 00:28:05,200
so there's some great examples for this

878
00:28:05,200 --> 00:28:07,840
in ghidra processors if you want

879
00:28:07,840 --> 00:28:10,399
a simple example what i would recommend

880
00:28:10,399 --> 00:28:11,440
starting out with

881
00:28:11,440 --> 00:28:14,799
is something like the 6502 and for those

882
00:28:14,799 --> 00:28:16,159
of you that may or may not be

883
00:28:16,159 --> 00:28:19,679
familiar with the 6502 it's a

884
00:28:19,679 --> 00:28:22,480
you know 16-bit instruction set computer

885
00:28:22,480 --> 00:28:23,360
with

886
00:28:23,360 --> 00:28:25,600
like less than i don't know it's very

887
00:28:25,600 --> 00:28:27,200
not nearly as many instructions as some

888
00:28:27,200 --> 00:28:28,320
of the other

889
00:28:28,320 --> 00:28:30,159
cpus that you might see and this is what

890
00:28:30,159 --> 00:28:32,000
was used you know in the nest

891
00:28:32,000 --> 00:28:33,919
and i believe even in the snes as well

892
00:28:33,919 --> 00:28:36,240
an extended version of the 6502

893
00:28:36,240 --> 00:28:39,679
and so when you look at this processor

894
00:28:39,679 --> 00:28:40,240
example

895
00:28:40,240 --> 00:28:42,480
in any processor example in the gitra

896
00:28:42,480 --> 00:28:44,080
source code you're going to have four

897
00:28:44,080 --> 00:28:47,760
files c-spec the ldefs p-spec

898
00:28:47,760 --> 00:28:51,520
and slice back and so the c-spec

899
00:28:51,520 --> 00:28:53,760
is the compiler specification that's

900
00:28:53,760 --> 00:28:55,120
what's going to define

901
00:28:55,120 --> 00:28:57,279
you know how various compilers will

902
00:28:57,279 --> 00:28:58,720
handle things like

903
00:28:58,720 --> 00:29:00,720
you know function prototypes and

904
00:29:00,720 --> 00:29:02,320
epilogues and prologues like we talked

905
00:29:02,320 --> 00:29:03,440
about before

906
00:29:03,440 --> 00:29:06,159
you've got the language definitions

907
00:29:06,159 --> 00:29:06,720
which

908
00:29:06,720 --> 00:29:08,159
you know will define things like

909
00:29:08,159 --> 00:29:10,080
endianness and things like that

910
00:29:10,080 --> 00:29:12,559
the processor specification which again

911
00:29:12,559 --> 00:29:14,880
kind of defines the various features of

912
00:29:14,880 --> 00:29:15,840
the chip so

913
00:29:15,840 --> 00:29:17,360
you're talking about you know memory

914
00:29:17,360 --> 00:29:18,640
maps and things like that and then

915
00:29:18,640 --> 00:29:20,720
finally the slay specification

916
00:29:20,720 --> 00:29:23,039
which lays out how instructions are

917
00:29:23,039 --> 00:29:24,320
decoded and how p

918
00:29:24,320 --> 00:29:28,879
code is actually going to be generated

919
00:29:29,600 --> 00:29:31,039
and so if we look at the language

920
00:29:31,039 --> 00:29:33,039
definition for the 6502

921
00:29:33,039 --> 00:29:35,279
we can see that it defines a handful of

922
00:29:35,279 --> 00:29:37,120
fairly standard things right so

923
00:29:37,120 --> 00:29:39,760
we define the endianness we define the

924
00:29:39,760 --> 00:29:40,240
size

925
00:29:40,240 --> 00:29:42,960
processor size we define various things

926
00:29:42,960 --> 00:29:43,440
like

927
00:29:43,440 --> 00:29:45,279
where do you find the slave file for

928
00:29:45,279 --> 00:29:46,720
this etc

929
00:29:46,720 --> 00:29:49,679
and so we also point it to you know you

930
00:29:49,679 --> 00:29:51,679
see here we have we point it to

931
00:29:51,679 --> 00:29:53,360
processor spec we point it to the

932
00:29:53,360 --> 00:29:55,279
compiler spec things like that

933
00:29:55,279 --> 00:29:56,640
and so you can see this one actually

934
00:29:56,640 --> 00:29:58,559
imports some manuals and some

935
00:29:58,559 --> 00:29:59,919
information from

936
00:29:59,919 --> 00:30:01,360
from ida if you actually have that

937
00:30:01,360 --> 00:30:03,840
installed

938
00:30:03,840 --> 00:30:06,080
and so you know what does the processor

939
00:30:06,080 --> 00:30:07,440
spec look like well

940
00:30:07,440 --> 00:30:09,440
so if you're familiar at all with 6502

941
00:30:09,440 --> 00:30:11,679
these are various i o ports

942
00:30:11,679 --> 00:30:13,840
okay and so these i o ports are just

943
00:30:13,840 --> 00:30:15,600
memory mapped registers

944
00:30:15,600 --> 00:30:18,799
for that particular cpu so any you know

945
00:30:18,799 --> 00:30:20,000
memory mapped register

946
00:30:20,000 --> 00:30:22,080
or you know maybe a reset vector

947
00:30:22,080 --> 00:30:23,760
interrupt handler that you know is going

948
00:30:23,760 --> 00:30:24,640
to be

949
00:30:24,640 --> 00:30:27,200
for a specific cpu is going to go in

950
00:30:27,200 --> 00:30:29,039
this pspec file

951
00:30:29,039 --> 00:30:31,919
and so don't confuse this with things

952
00:30:31,919 --> 00:30:32,559
you don't

953
00:30:32,559 --> 00:30:33,919
necessarily want to confuse it with

954
00:30:33,919 --> 00:30:36,000
things like peripherals like you

955
00:30:36,000 --> 00:30:38,320
might see you know like a spy controller

956
00:30:38,320 --> 00:30:39,440
or something like that

957
00:30:39,440 --> 00:30:41,679
you can just add those as memory regions

958
00:30:41,679 --> 00:30:43,360
you don't necessarily have to go to this

959
00:30:43,360 --> 00:30:45,520
level to add something like a spy

960
00:30:45,520 --> 00:30:48,559
controller or a uart controller

961
00:30:48,559 --> 00:30:50,159
and so another example of something that

962
00:30:50,159 --> 00:30:51,440
might be in a piece back again is the

963
00:30:51,440 --> 00:30:52,880
memory blocks but this is

964
00:30:52,880 --> 00:30:55,840
for that particular cpu right so the

965
00:30:55,840 --> 00:30:57,919
6502 has like a dedicated

966
00:30:57,919 --> 00:31:00,080
stack space that we have laid out here

967
00:31:00,080 --> 00:31:01,760
and i have another ram region load out

968
00:31:01,760 --> 00:31:03,919
here as well

969
00:31:03,919 --> 00:31:06,159
so

970
00:31:07,360 --> 00:31:08,880
next you're going to have once you've

971
00:31:08,880 --> 00:31:10,559
gone through kind of the p spec the

972
00:31:10,559 --> 00:31:12,240
processor specifications we're going to

973
00:31:12,240 --> 00:31:13,200
talk about

974
00:31:13,200 --> 00:31:14,960
you know the different types of function

975
00:31:14,960 --> 00:31:16,880
prototypes that

976
00:31:16,880 --> 00:31:18,240
some code that have been written for

977
00:31:18,240 --> 00:31:20,240
this processor might use and so for the

978
00:31:20,240 --> 00:31:21,840
6502 which was largely

979
00:31:21,840 --> 00:31:25,120
handwritten in assembly uh it's

980
00:31:25,120 --> 00:31:27,279
fairly straightforward right so we can

981
00:31:27,279 --> 00:31:28,159
see here

982
00:31:28,159 --> 00:31:29,440
the various parameters that are

983
00:31:29,440 --> 00:31:31,200
necessary for

984
00:31:31,200 --> 00:31:34,320
the function prototypes for 6502 and

985
00:31:34,320 --> 00:31:35,600
that's what's going to be defined in the

986
00:31:35,600 --> 00:31:37,440
c-spec or the compiler specification

987
00:31:37,440 --> 00:31:38,720
which you know makes sense

988
00:31:38,720 --> 00:31:40,559
talks about calling conventions stack

989
00:31:40,559 --> 00:31:42,960
growth alignment which we talked about

990
00:31:42,960 --> 00:31:43,760
with structs

991
00:31:43,760 --> 00:31:48,559
in session three and things like that

992
00:31:48,559 --> 00:31:51,919
and so finally the slay spec is going to

993
00:31:51,919 --> 00:31:52,880
be one of the

994
00:31:52,880 --> 00:31:54,320
all these file formats are fairly

995
00:31:54,320 --> 00:31:56,240
complicated which is why i wanted to use

996
00:31:56,240 --> 00:31:58,480
the 6502 as an example because it's a

997
00:31:58,480 --> 00:32:00,960
relatively straightforward processor

998
00:32:00,960 --> 00:32:03,279
and so this finally has things like

999
00:32:03,279 --> 00:32:04,799
instruction definitions

1000
00:32:04,799 --> 00:32:07,200
register definitions things like that

1001
00:32:07,200 --> 00:32:09,279
defining various address spaces and what

1002
00:32:09,279 --> 00:32:10,159
types they are

1003
00:32:10,159 --> 00:32:12,080
and so all this data is what's going to

1004
00:32:12,080 --> 00:32:14,399
eventually get fed into and utilized

1005
00:32:14,399 --> 00:32:17,519
by the the p code later in a sense so

1006
00:32:17,519 --> 00:32:19,360
we're defining these registers that the

1007
00:32:19,360 --> 00:32:20,960
p code is going to operate on

1008
00:32:20,960 --> 00:32:23,679
right and so we have you know we're

1009
00:32:23,679 --> 00:32:25,200
defining the alignment so

1010
00:32:25,200 --> 00:32:26,880
you know one byte aligned we're defining

1011
00:32:26,880 --> 00:32:28,720
the endianness things like that

1012
00:32:28,720 --> 00:32:30,559
we're going through and telling it the

1013
00:32:30,559 --> 00:32:32,799
address spaces that it can work through

1014
00:32:32,799 --> 00:32:34,240
and then we're mapping out all the

1015
00:32:34,240 --> 00:32:36,640
various registers that 6502 has which as

1016
00:32:36,640 --> 00:32:37,200
you can see

1017
00:32:37,200 --> 00:32:39,279
are not that many right so on i think on

1018
00:32:39,279 --> 00:32:40,320
our x86

1019
00:32:40,320 --> 00:32:43,360
we only have four here and we're looking

1020
00:32:43,360 --> 00:32:44,880
at you know more than 32 on

1021
00:32:44,880 --> 00:32:48,799
our regular x86 64-bit cpu

1022
00:32:48,799 --> 00:32:51,279
and so the slay spec in addition to all

1023
00:32:51,279 --> 00:32:51,840
this where

1024
00:32:51,840 --> 00:32:53,279
it's defining the registers it's

1025
00:32:53,279 --> 00:32:54,960
defining the address space things like

1026
00:32:54,960 --> 00:32:55,440
that

1027
00:32:55,440 --> 00:32:58,960
it also defines how the instructions are

1028
00:32:58,960 --> 00:33:02,080
decoded so

1029
00:33:02,080 --> 00:33:06,960
very quick crash course in 6502 assembly

1030
00:33:06,960 --> 00:33:10,000
please don't fall asleep on me is the

1031
00:33:10,000 --> 00:33:13,919
funk the the instruction store a will

1032
00:33:13,919 --> 00:33:17,120
store what is in register a at

1033
00:33:17,120 --> 00:33:20,080
this operation at this address and so

1034
00:33:20,080 --> 00:33:21,200
what we can see here

1035
00:33:21,200 --> 00:33:23,120
is that we have the conditions that are

1036
00:33:23,120 --> 00:33:25,600
needed for this assembly instruction

1037
00:33:25,600 --> 00:33:28,320
these both represent bit ranges in the

1038
00:33:28,320 --> 00:33:30,240
actual instruction byte that are set

1039
00:33:30,240 --> 00:33:32,799
as well as the operand here and then we

1040
00:33:32,799 --> 00:33:34,159
have the resulting you know p

1041
00:33:34,159 --> 00:33:37,600
code underneath of it and so what we do

1042
00:33:37,600 --> 00:33:39,519
in this slice spec file is define all

1043
00:33:39,519 --> 00:33:41,279
the parameters needed for disassembly

1044
00:33:41,279 --> 00:33:43,039
and then we also define up here how the

1045
00:33:43,039 --> 00:33:44,960
instructions are going to be shown

1046
00:33:44,960 --> 00:33:47,519
in the disassembly listing which is

1047
00:33:47,519 --> 00:33:49,279
fairly useful as well if you ever want

1048
00:33:49,279 --> 00:33:49,760
to

1049
00:33:49,760 --> 00:33:51,279
if you ever want to try to modify things

1050
00:33:51,279 --> 00:33:53,440
like that you may have to modify things

1051
00:33:53,440 --> 00:33:55,679
at the slight spec

1052
00:33:55,679 --> 00:33:58,799
and so this is what from a

1053
00:33:58,799 --> 00:34:00,720
this was kind of a very quick overview

1054
00:34:00,720 --> 00:34:02,320
of how that works

1055
00:34:02,320 --> 00:34:05,840
and i wanted to go over it just so

1056
00:34:05,840 --> 00:34:08,480
everyone kind of understands from a

1057
00:34:08,480 --> 00:34:10,480
super high level how this stuff works

1058
00:34:10,480 --> 00:34:12,000
and how it looks

1059
00:34:12,000 --> 00:34:14,079
and so we talked about you know p code

1060
00:34:14,079 --> 00:34:15,040
and we talked about how

1061
00:34:15,040 --> 00:34:18,320
the slay spec is used to generate p code

1062
00:34:18,320 --> 00:34:21,679
so let's talk about that so p code is

1063
00:34:21,679 --> 00:34:22,320
designed

1064
00:34:22,320 --> 00:34:25,199
to if you read the docs in the source

1065
00:34:25,199 --> 00:34:26,800
which i would highly recommend

1066
00:34:26,800 --> 00:34:28,879
it's designed to be capable of modeling

1067
00:34:28,879 --> 00:34:31,199
you know a general purpose processor

1068
00:34:31,199 --> 00:34:34,000
and so this language is a registered

1069
00:34:34,000 --> 00:34:35,599
transfer language

1070
00:34:35,599 --> 00:34:37,520
and it's used like we talked about

1071
00:34:37,520 --> 00:34:39,359
before is kind of an abstraction layer

1072
00:34:39,359 --> 00:34:41,440
for all the cpu specific stuff

1073
00:34:41,440 --> 00:34:44,560
so if you can analyze p

1074
00:34:44,560 --> 00:34:47,679
code for you know one processor you can

1075
00:34:47,679 --> 00:34:48,079
analyze

1076
00:34:48,079 --> 00:34:49,679
it for another and that's why the

1077
00:34:49,679 --> 00:34:51,679
decompiler works across all these

1078
00:34:51,679 --> 00:34:52,560
various

1079
00:34:52,560 --> 00:34:56,079
processors by operating on this

1080
00:34:56,079 --> 00:34:58,560
immediate representation or this ir il

1081
00:34:58,560 --> 00:35:01,119
that you might hear people discuss

1082
00:35:01,119 --> 00:35:03,440
and so this is what's operated on to

1083
00:35:03,440 --> 00:35:06,560
generate that decompiled code

1084
00:35:06,560 --> 00:35:07,760
but you know what does all that look

1085
00:35:07,760 --> 00:35:10,720
like right so if we're looking at

1086
00:35:10,720 --> 00:35:13,119
an assembly listing and again this is

1087
00:35:13,119 --> 00:35:14,400
6502

1088
00:35:14,400 --> 00:35:16,240
this is you know fairly simple assembly

1089
00:35:16,240 --> 00:35:18,400
so if we look at this instruction load a

1090
00:35:18,400 --> 00:35:20,480
three what does that do that loads the

1091
00:35:20,480 --> 00:35:22,640
value three into register a

1092
00:35:22,640 --> 00:35:23,839
these are very straightforward

1093
00:35:23,839 --> 00:35:26,160
instructions and so

1094
00:35:26,160 --> 00:35:30,000
now if we want to look at the p code

1095
00:35:30,000 --> 00:35:33,119
we click on this

1096
00:35:33,119 --> 00:35:34,079
i don't even i don't know what you'd

1097
00:35:34,079 --> 00:35:35,839
call it these bricks here right so you

1098
00:35:35,839 --> 00:35:36,880
click on this and what that's going to

1099
00:35:36,880 --> 00:35:38,160
do is it's going to open up the editor

1100
00:35:38,160 --> 00:35:39,440
for the assembly listing and i believe

1101
00:35:39,440 --> 00:35:41,359
we talked about this in session one

1102
00:35:41,359 --> 00:35:44,000
so we open up this editor and then we'll

1103
00:35:44,000 --> 00:35:44,640
see here

1104
00:35:44,640 --> 00:35:47,200
that an instruction slash data p code is

1105
00:35:47,200 --> 00:35:49,280
grayed out

1106
00:35:49,280 --> 00:35:51,040
and so if we right click that and enable

1107
00:35:51,040 --> 00:35:52,720
the field

1108
00:35:52,720 --> 00:35:55,760
now for every instruction we see you

1109
00:35:55,760 --> 00:35:56,880
know four five six

1110
00:35:56,880 --> 00:36:01,280
instructions so when we read this is 65

1111
00:36:01,280 --> 00:36:03,599
6502 assembly we're saying all right

1112
00:36:03,599 --> 00:36:04,800
store the value

1113
00:36:04,800 --> 00:36:07,920
in register a at this address

1114
00:36:07,920 --> 00:36:09,760
okay but what does that look like when

1115
00:36:09,760 --> 00:36:11,280
it gets translated into that

1116
00:36:11,280 --> 00:36:13,280
intermediate representation of p code

1117
00:36:13,280 --> 00:36:14,640
well it says all right

1118
00:36:14,640 --> 00:36:17,359
at this register in ram at this location

1119
00:36:17,359 --> 00:36:17,920
in ram

1120
00:36:17,920 --> 00:36:20,000
at this value we're gonna store a copy

1121
00:36:20,000 --> 00:36:21,680
of a

1122
00:36:21,680 --> 00:36:23,440
and then we're gonna check the zero flag

1123
00:36:23,440 --> 00:36:25,520
and we're gonna check the less than zero

1124
00:36:25,520 --> 00:36:26,240
flag

1125
00:36:26,240 --> 00:36:28,640
and set those in case they're necessary

1126
00:36:28,640 --> 00:36:31,359
so you know when we're looking at

1127
00:36:31,359 --> 00:36:35,040
things that branch this is how you would

1128
00:36:35,040 --> 00:36:37,599
set flags and things like that so again

1129
00:36:37,599 --> 00:36:38,160
what we

1130
00:36:38,160 --> 00:36:39,520
so when we talk about what this

1131
00:36:39,520 --> 00:36:41,520
instruction does and we talk about flags

1132
00:36:41,520 --> 00:36:43,599
that might get set when we do a compare

1133
00:36:43,599 --> 00:36:45,440
it's all we kind of think of it as a

1134
00:36:45,440 --> 00:36:47,119
linear process where yeah you just check

1135
00:36:47,119 --> 00:36:48,800
these values and then you move on

1136
00:36:48,800 --> 00:36:51,040
and so the p code is the representation

1137
00:36:51,040 --> 00:36:53,680
of kind of every single step that has to

1138
00:36:53,680 --> 00:36:55,520
take place for one of these instructions

1139
00:36:55,520 --> 00:36:56,320
to

1140
00:36:56,320 --> 00:36:59,839
be performed right so it lays out okay

1141
00:36:59,839 --> 00:37:00,720
you've got

1142
00:37:00,720 --> 00:37:02,800
your moving value this value from a into

1143
00:37:02,800 --> 00:37:04,240
this address of ram

1144
00:37:04,240 --> 00:37:05,760
and then we're checking these flags and

1145
00:37:05,760 --> 00:37:07,680
then we move on to the next instruction

1146
00:37:07,680 --> 00:37:11,359
and so p code is an even more granular

1147
00:37:11,359 --> 00:37:12,800
way to look at these instructions than

1148
00:37:12,800 --> 00:37:14,960
assembly a lot of the times and again

1149
00:37:14,960 --> 00:37:18,079
the reason we use this is because this

1150
00:37:18,079 --> 00:37:21,119
p code is the same you know core concept

1151
00:37:21,119 --> 00:37:23,599
same language that's used across all the

1152
00:37:23,599 --> 00:37:26,800
various processors that getra supports

1153
00:37:26,800 --> 00:37:29,599
and so let's really quick just to make

1154
00:37:29,599 --> 00:37:31,359
sure you've fallen asleep by now

1155
00:37:31,359 --> 00:37:33,440
let's take a look at you know this p

1156
00:37:33,440 --> 00:37:35,599
code from kind of a lower level so

1157
00:37:35,599 --> 00:37:37,599
again we talked about what this

1158
00:37:37,599 --> 00:37:39,520
instruction does is it stores the value

1159
00:37:39,520 --> 00:37:42,160
in the a register at this address

1160
00:37:42,160 --> 00:37:43,839
and so we see that happening with this

1161
00:37:43,839 --> 00:37:45,680
first one and then we also see

1162
00:37:45,680 --> 00:37:47,359
the flag checks that happen after the

1163
00:37:47,359 --> 00:37:49,119
fact and so

1164
00:37:49,119 --> 00:37:51,760
first thing we do right at this value in

1165
00:37:51,760 --> 00:37:53,440
ram we're storing one byte

1166
00:37:53,440 --> 00:37:55,760
and it's the copy of this register or

1167
00:37:55,760 --> 00:37:58,160
the copy the value in that a register

1168
00:37:58,160 --> 00:38:00,480
then we're checking zero flag setting it

1169
00:38:00,480 --> 00:38:01,359
if necessary

1170
00:38:01,359 --> 00:38:02,560
and then we're checking the less than

1171
00:38:02,560 --> 00:38:05,280
zero flag in checking that if necessary

1172
00:38:05,280 --> 00:38:08,720
and so with all that what i would like

1173
00:38:08,720 --> 00:38:10,560
for everybody to do

1174
00:38:10,560 --> 00:38:12,800
is in the exercises folder which hasn't

1175
00:38:12,800 --> 00:38:14,240
been pushed yet and we pushed later this

1176
00:38:14,240 --> 00:38:14,880
evening

1177
00:38:14,880 --> 00:38:16,880
there's going to be four exercises that

1178
00:38:16,880 --> 00:38:18,079
are all the same

1179
00:38:18,079 --> 00:38:20,400
c code compiled for four different

1180
00:38:20,400 --> 00:38:21,280
architectures

1181
00:38:21,280 --> 00:38:22,560
and they're going to be l files so

1182
00:38:22,560 --> 00:38:24,400
guidry will be able to tell you the

1183
00:38:24,400 --> 00:38:25,760
architecture and you won't have to set

1184
00:38:25,760 --> 00:38:26,720
that manually

1185
00:38:26,720 --> 00:38:28,320
but what i would just like for you to do

1186
00:38:28,320 --> 00:38:30,240
is for each of them take a look at the p

1187
00:38:30,240 --> 00:38:33,200
code and think about how it's different

1188
00:38:33,200 --> 00:38:34,720
see if any parts of it are

1189
00:38:34,720 --> 00:38:36,480
similar and see if there are any

1190
00:38:36,480 --> 00:38:38,160
patterns that you might see

1191
00:38:38,160 --> 00:38:42,799
in the p code that gets generated

1192
00:38:43,440 --> 00:38:44,880
and so with that you know we've talked

1193
00:38:44,880 --> 00:38:47,040
about kind of

1194
00:38:47,040 --> 00:38:49,040
from a very high level how geedra works

1195
00:38:49,040 --> 00:38:51,599
internally we've gone over a few

1196
00:38:51,599 --> 00:38:53,040
features that we haven't really touched

1197
00:38:53,040 --> 00:38:54,720
on before the end of this first

1198
00:38:54,720 --> 00:38:56,800
sequence of session sequence of classes

1199
00:38:56,800 --> 00:38:58,720
and so what i wanted to get through with

1200
00:38:58,720 --> 00:39:00,000
everybody before we finally

1201
00:39:00,000 --> 00:39:02,960
close out is kind of how to extend the

1202
00:39:02,960 --> 00:39:03,839
ghidra

1203
00:39:03,839 --> 00:39:05,520
via scripting so we're going to talk

1204
00:39:05,520 --> 00:39:07,839
about that now

1205
00:39:07,839 --> 00:39:10,160
so you can extend guidra via various

1206
00:39:10,160 --> 00:39:11,920
plugins right you can write scripts you

1207
00:39:11,920 --> 00:39:12,560
can write

1208
00:39:12,560 --> 00:39:14,800
loaders you can write processor modules

1209
00:39:14,800 --> 00:39:16,320
like we just talked about

1210
00:39:16,320 --> 00:39:18,640
and so you can do this with the didra

1211
00:39:18,640 --> 00:39:20,160
dev plugin

1212
00:39:20,160 --> 00:39:22,400
that is designed to be integrated with

1213
00:39:22,400 --> 00:39:23,760
eclipse and this lets you

1214
00:39:23,760 --> 00:39:27,119
write either java or python

1215
00:39:27,119 --> 00:39:28,560
and so you can kind of pick whichever

1216
00:39:28,560 --> 00:39:30,400
one you want because the apis between

1217
00:39:30,400 --> 00:39:32,720
both of them are the same or as close to

1218
00:39:32,720 --> 00:39:34,079
the same as they can be

1219
00:39:34,079 --> 00:39:37,440
right and so if you want to install

1220
00:39:37,440 --> 00:39:40,640
the guidra dev plugin into eclipse i'm

1221
00:39:40,640 --> 00:39:42,160
going to show you how to do that so this

1222
00:39:42,160 --> 00:39:43,440
example that we're going to walk through

1223
00:39:43,440 --> 00:39:43,760
is

1224
00:39:43,760 --> 00:39:45,839
me using the latest version of eclipse

1225
00:39:45,839 --> 00:39:48,000
pulled from the eclipse website

1226
00:39:48,000 --> 00:39:50,960
and you go to help and then install new

1227
00:39:50,960 --> 00:39:52,320
software

1228
00:39:52,320 --> 00:39:53,839
and then this will pop up and it's going

1229
00:39:53,839 --> 00:39:56,160
to ask you where you want to install or

1230
00:39:56,160 --> 00:39:57,920
what you want to install from

1231
00:39:57,920 --> 00:40:01,440
so we click add it'll bring up this menu

1232
00:40:01,440 --> 00:40:03,280
an archive because we're grabbing an

1233
00:40:03,280 --> 00:40:05,359
archive that's included with

1234
00:40:05,359 --> 00:40:09,200
the repo when you pull it from get

1235
00:40:09,200 --> 00:40:10,480
and then here it's going to parse that

1236
00:40:10,480 --> 00:40:12,400
and let you select what you want we want

1237
00:40:12,400 --> 00:40:13,839
to select both of these things and click

1238
00:40:13,839 --> 00:40:16,160
next

1239
00:40:16,720 --> 00:40:17,920
and so here it's going to tell you all

1240
00:40:17,920 --> 00:40:19,359
right you're installing this guitra dev

1241
00:40:19,359 --> 00:40:21,280
plugin

1242
00:40:21,280 --> 00:40:24,400
go through accept the licenses etc

1243
00:40:24,400 --> 00:40:27,280
and so now in our eclipse window here in

1244
00:40:27,280 --> 00:40:28,400
our eclipse toolbar

1245
00:40:28,400 --> 00:40:31,359
we have a little guidradev button here

1246
00:40:31,359 --> 00:40:32,720
which we can use

1247
00:40:32,720 --> 00:40:34,880
to kind of integrate our ghidra

1248
00:40:34,880 --> 00:40:36,480
installation with eclipse and use that

1249
00:40:36,480 --> 00:40:38,160
for more verbose information when we

1250
00:40:38,160 --> 00:40:40,079
start writing scripts and expanding on

1251
00:40:40,079 --> 00:40:43,280
gedra's core capabilities so

1252
00:40:43,280 --> 00:40:44,880
the first thing we have to do though is

1253
00:40:44,880 --> 00:40:46,560
we have to link our geezer installation

1254
00:40:46,560 --> 00:40:47,440
with this

1255
00:40:47,440 --> 00:40:49,520
instance of eclipse so click on

1256
00:40:49,520 --> 00:40:50,640
geezerdev

1257
00:40:50,640 --> 00:40:53,040
link gidra and it's going to tell you we

1258
00:40:53,040 --> 00:40:54,319
don't know where geezer is installed you

1259
00:40:54,319 --> 00:40:55,680
need to tell us

1260
00:40:55,680 --> 00:40:58,160
so click on this plus sign and point it

1261
00:40:58,160 --> 00:40:58,800
to

1262
00:40:58,800 --> 00:41:01,359
your guidra install which again is just

1263
00:41:01,359 --> 00:41:02,920
what you would have pulled from

1264
00:41:02,920 --> 00:41:04,720
geidrasre.org

1265
00:41:04,720 --> 00:41:08,000
and so you select that folder and then

1266
00:41:08,000 --> 00:41:09,760
click apply and close

1267
00:41:09,760 --> 00:41:11,599
and then now when you go under new

1268
00:41:11,599 --> 00:41:13,119
you're going to have options to create

1269
00:41:13,119 --> 00:41:14,800
new gidra scripts and things like that

1270
00:41:14,800 --> 00:41:15,359
so

1271
00:41:15,359 --> 00:41:17,040
we're just going to write a simple hello

1272
00:41:17,040 --> 00:41:18,319
world script that's going to print a

1273
00:41:18,319 --> 00:41:19,760
pop-up to the screen and then we're

1274
00:41:19,760 --> 00:41:21,920
going to go over some of the more simple

1275
00:41:21,920 --> 00:41:26,160
apis that people might find useful

1276
00:41:26,240 --> 00:41:28,560
take a look at the q a real quick just

1277
00:41:28,560 --> 00:41:30,319
the stock java one yeah so we got a

1278
00:41:30,319 --> 00:41:32,000
question for which eclipse build variant

1279
00:41:32,000 --> 00:41:34,319
do you use just the stock java one yeah

1280
00:41:34,319 --> 00:41:37,359
so just the java ide so

1281
00:41:37,359 --> 00:41:40,400
we're going to click gitra's script

1282
00:41:40,400 --> 00:41:42,000
and then this is going to look like if

1283
00:41:42,000 --> 00:41:43,599
those of you have used eclipse before

1284
00:41:43,599 --> 00:41:45,040
this just looks like any other project

1285
00:41:45,040 --> 00:41:46,000
manager right

1286
00:41:46,000 --> 00:41:48,720
so we just call it example script and

1287
00:41:48,720 --> 00:41:50,400
the root directory you set that wherever

1288
00:41:50,400 --> 00:41:51,680
you want it to be

1289
00:41:51,680 --> 00:41:54,160
and then we run it and then you're going

1290
00:41:54,160 --> 00:41:55,599
to get something like this so you see

1291
00:41:55,599 --> 00:41:57,280
here i have two i have example script

1292
00:41:57,280 --> 00:41:58,960
and hack day example

1293
00:41:58,960 --> 00:42:01,440
and so what you want to do is right

1294
00:42:01,440 --> 00:42:03,440
click on home scripts or you can

1295
00:42:03,440 --> 00:42:05,760
really you can do this in any of these

1296
00:42:05,760 --> 00:42:07,839
included modules but

1297
00:42:07,839 --> 00:42:09,280
to make it easier just right click home

1298
00:42:09,280 --> 00:42:11,280
scripts and then go down to guidra dev

1299
00:42:11,280 --> 00:42:14,400
new guide script

1300
00:42:14,400 --> 00:42:16,560
and then that's going to ask you for you

1301
00:42:16,560 --> 00:42:18,480
know the name of your script the

1302
00:42:18,480 --> 00:42:20,560
language you want it to be in

1303
00:42:20,560 --> 00:42:22,079
in any of these categories i would

1304
00:42:22,079 --> 00:42:24,160
recommend filling out the category

1305
00:42:24,160 --> 00:42:26,480
and just call it you know example or

1306
00:42:26,480 --> 00:42:27,760
call it whatever you want so you can

1307
00:42:27,760 --> 00:42:30,000
find it in the script manager later

1308
00:42:30,000 --> 00:42:31,520
and we're going to walk through what

1309
00:42:31,520 --> 00:42:33,680
that looks like as well

1310
00:42:33,680 --> 00:42:35,359
so here we filled out the kind of

1311
00:42:35,359 --> 00:42:37,760
example info for our script

1312
00:42:37,760 --> 00:42:39,920
click finish and then we get like this

1313
00:42:39,920 --> 00:42:41,200
nice little template

1314
00:42:41,200 --> 00:42:43,520
and so for our script again for now all

1315
00:42:43,520 --> 00:42:44,960
we're going to do is just pop up and say

1316
00:42:44,960 --> 00:42:47,280
hello hackaday

1317
00:42:47,280 --> 00:42:48,880
and so in order to run this right we've

1318
00:42:48,880 --> 00:42:50,160
already linked it with our installation

1319
00:42:50,160 --> 00:42:50,800
of fedra

1320
00:42:50,800 --> 00:42:52,240
so you're going to click on this arrow

1321
00:42:52,240 --> 00:42:53,440
and it's going to ask you what you want

1322
00:42:53,440 --> 00:42:55,280
to do do you want to run it as

1323
00:42:55,280 --> 00:42:56,960
a regular you know giger app do you want

1324
00:42:56,960 --> 00:42:58,560
to run it as guitar headless

1325
00:42:58,560 --> 00:43:00,480
and so we want to run this as a regular

1326
00:43:00,480 --> 00:43:02,640
gi drab if you were writing a script

1327
00:43:02,640 --> 00:43:05,280
to do analysis on a bunch of binaries

1328
00:43:05,280 --> 00:43:06,560
and you didn't care about you know

1329
00:43:06,560 --> 00:43:07,920
interacting with gui you would want to

1330
00:43:07,920 --> 00:43:09,440
do that with guitra headless

1331
00:43:09,440 --> 00:43:10,640
so we're telling we're going to tell it

1332
00:43:10,640 --> 00:43:12,480
to do it with just regular deidre and

1333
00:43:12,480 --> 00:43:13,760
what that's going to do is it's going to

1334
00:43:13,760 --> 00:43:15,440
launch ghidra for us

1335
00:43:15,440 --> 00:43:18,720
and so once you have that you can open

1336
00:43:18,720 --> 00:43:19,520
whatever

1337
00:43:19,520 --> 00:43:20,800
target program you want to test the

1338
00:43:20,800 --> 00:43:22,640
script on so i opened up the

1339
00:43:22,640 --> 00:43:24,079
gameboy advance rom that we've been

1340
00:43:24,079 --> 00:43:26,400
looking at and the next thing you want

1341
00:43:26,400 --> 00:43:26,800
to do

1342
00:43:26,800 --> 00:43:29,200
is click window and then script manager

1343
00:43:29,200 --> 00:43:30,560
and that's going to bring up the script

1344
00:43:30,560 --> 00:43:31,359
manager

1345
00:43:31,359 --> 00:43:34,319
that you can use to you know edit and

1346
00:43:34,319 --> 00:43:36,240
run scripts and add new folders to be

1347
00:43:36,240 --> 00:43:37,200
run from here

1348
00:43:37,200 --> 00:43:39,920
and so ours was under the category

1349
00:43:39,920 --> 00:43:40,720
hackaday

1350
00:43:40,720 --> 00:43:42,880
in the comments here and so that's why

1351
00:43:42,880 --> 00:43:44,240
it shows up under this folder and i

1352
00:43:44,240 --> 00:43:45,520
would recommend doing that even if you

1353
00:43:45,520 --> 00:43:46,319
just

1354
00:43:46,319 --> 00:43:48,400
put you know your name here so it shows

1355
00:43:48,400 --> 00:43:49,760
up here and it's easier to

1356
00:43:49,760 --> 00:43:52,400
to find right and you can also add

1357
00:43:52,400 --> 00:43:54,960
things like key bindings menu paths

1358
00:43:54,960 --> 00:43:57,599
and a toolbar image for it to show up if

1359
00:43:57,599 --> 00:43:59,040
you want to just run it by clicking an

1360
00:43:59,040 --> 00:44:00,319
image in the toolbar

1361
00:44:00,319 --> 00:44:02,319
and so you can do you can fill out as

1362
00:44:02,319 --> 00:44:03,680
much of this as you want

1363
00:44:03,680 --> 00:44:06,240
to make it sort of easier to access but

1364
00:44:06,240 --> 00:44:07,680
the script manager is an important part

1365
00:44:07,680 --> 00:44:09,040
of deidre as well and it's something you

1366
00:44:09,040 --> 00:44:10,800
should be familiar with to find you know

1367
00:44:10,800 --> 00:44:12,640
other examples of scripts that people

1368
00:44:12,640 --> 00:44:15,040
have written

1369
00:44:15,280 --> 00:44:17,839
and so with that we have our script we

1370
00:44:17,839 --> 00:44:19,359
see it right here we see all the fields

1371
00:44:19,359 --> 00:44:21,119
that we filled out

1372
00:44:21,119 --> 00:44:22,560
and then to run it we're just going to

1373
00:44:22,560 --> 00:44:24,560
click the play button up here

1374
00:44:24,560 --> 00:44:26,560
and when we do that we get this little

1375
00:44:26,560 --> 00:44:27,839
pop-up that says

1376
00:44:27,839 --> 00:44:30,319
you know hello hackaday very

1377
00:44:30,319 --> 00:44:31,280
straightforward

1378
00:44:31,280 --> 00:44:32,720
but just wanted to walk you through i

1379
00:44:32,720 --> 00:44:34,000
actually had a hard time the very first

1380
00:44:34,000 --> 00:44:34,880
time i wrote something

1381
00:44:34,880 --> 00:44:37,280
finding how to actually run it from

1382
00:44:37,280 --> 00:44:38,640
ghidra and you do it within the script

1383
00:44:38,640 --> 00:44:41,040
manager and without a category

1384
00:44:41,040 --> 00:44:43,200
chosen it's kind of difficult to find

1385
00:44:43,200 --> 00:44:44,880
your particular script that you've

1386
00:44:44,880 --> 00:44:46,000
written and that's in the

1387
00:44:46,000 --> 00:44:48,560
gitra ide and so as you run this any

1388
00:44:48,560 --> 00:44:49,359
logging that you

1389
00:44:49,359 --> 00:44:51,520
output or any information that you

1390
00:44:51,520 --> 00:44:53,119
choose to print out to the console will

1391
00:44:53,119 --> 00:44:53,760
show up

1392
00:44:53,760 --> 00:44:55,920
you know both in ghidra and in eclipse

1393
00:44:55,920 --> 00:44:57,520
and so you can set breakpoints you can

1394
00:44:57,520 --> 00:44:58,720
do things like that

1395
00:44:58,720 --> 00:45:02,000
for loading your script and kind of

1396
00:45:02,000 --> 00:45:03,680
debugging your script or processor

1397
00:45:03,680 --> 00:45:05,599
module

1398
00:45:05,599 --> 00:45:07,200
and so the example that we looked at

1399
00:45:07,200 --> 00:45:08,800
just a second ago

1400
00:45:08,800 --> 00:45:11,839
right was python or was java rather

1401
00:45:11,839 --> 00:45:13,440
and you can also write the stuff in

1402
00:45:13,440 --> 00:45:15,359
python and if you want you know the pi

1403
00:45:15,359 --> 00:45:17,440
that you can use the pidev plugin for

1404
00:45:17,440 --> 00:45:19,200
eclipse integration

1405
00:45:19,200 --> 00:45:20,560
another really interesting feature and

1406
00:45:20,560 --> 00:45:22,560
useful feature is the python shell

1407
00:45:22,560 --> 00:45:24,319
that's already built into gitra and some

1408
00:45:24,319 --> 00:45:26,160
of you may have already seen this

1409
00:45:26,160 --> 00:45:27,280
and so we're asking do you have to

1410
00:45:27,280 --> 00:45:28,960
restart dedra when you change the script

1411
00:45:28,960 --> 00:45:29,839
in eclipse no

1412
00:45:29,839 --> 00:45:31,520
you don't have to do that that's very

1413
00:45:31,520 --> 00:45:32,960
useful

1414
00:45:32,960 --> 00:45:36,240
so the python interpreter utilizes the

1415
00:45:36,240 --> 00:45:38,079
flat program api which is kind of what

1416
00:45:38,079 --> 00:45:39,599
we're going to focus on for the rest of

1417
00:45:39,599 --> 00:45:40,319
the session

1418
00:45:40,319 --> 00:45:42,160
which is kind of the more standard api

1419
00:45:42,160 --> 00:45:43,359
that you can use

1420
00:45:43,359 --> 00:45:46,400
and so that standard api

1421
00:45:46,400 --> 00:45:48,400
provides lots of you know global

1422
00:45:48,400 --> 00:45:50,079
variables for you and is a quick way to

1423
00:45:50,079 --> 00:45:51,599
kind of get up and running

1424
00:45:51,599 --> 00:45:54,720
with scripting with ghidra and so when

1425
00:45:54,720 --> 00:45:55,920
you're running a program

1426
00:45:55,920 --> 00:45:58,319
and using this flat api hedra

1427
00:45:58,319 --> 00:45:59,839
instantiates a handful of global

1428
00:45:59,839 --> 00:46:01,599
variables for you that you can use while

1429
00:46:01,599 --> 00:46:02,160
scripting

1430
00:46:02,160 --> 00:46:04,160
including you know current address

1431
00:46:04,160 --> 00:46:05,839
current highlight current program

1432
00:46:05,839 --> 00:46:06,880
current selection

1433
00:46:06,880 --> 00:46:08,880
current location and so all of these are

1434
00:46:08,880 --> 00:46:10,880
relevant to your cursor location so

1435
00:46:10,880 --> 00:46:12,560
if you've clicked on a certain location

1436
00:46:12,560 --> 00:46:14,319
or a certain address that's the value

1437
00:46:14,319 --> 00:46:16,000
that's going to be in current address

1438
00:46:16,000 --> 00:46:18,160
and so you'll see how we reference these

1439
00:46:18,160 --> 00:46:19,280
globals later

1440
00:46:19,280 --> 00:46:21,280
with some of the flat program api calls

1441
00:46:21,280 --> 00:46:23,599
from the python shell

1442
00:46:23,599 --> 00:46:26,000
and one of the more kind of important

1443
00:46:26,000 --> 00:46:27,520
things to understand or at least was the

1444
00:46:27,520 --> 00:46:28,000
most difficult

1445
00:46:28,000 --> 00:46:30,000
for me initially was getting used to the

1446
00:46:30,000 --> 00:46:31,200
concept of addresses

1447
00:46:31,200 --> 00:46:33,680
being an object so if you've written you

1448
00:46:33,680 --> 00:46:35,119
know item python scripts and things like

1449
00:46:35,119 --> 00:46:36,720
that lots of times addresses can just be

1450
00:46:36,720 --> 00:46:37,520
represented as

1451
00:46:37,520 --> 00:46:39,760
you know a regular integer and so

1452
00:46:39,760 --> 00:46:40,960
address objects

1453
00:46:40,960 --> 00:46:43,040
are their own separate thing and they

1454
00:46:43,040 --> 00:46:44,880
have their own you know sub functions

1455
00:46:44,880 --> 00:46:46,880
for you know adding and subtracting and

1456
00:46:46,880 --> 00:46:48,160
things like that

1457
00:46:48,160 --> 00:46:50,720
and you can also generate addresses

1458
00:46:50,720 --> 00:46:52,800
easily using this

1459
00:46:52,800 --> 00:46:55,359
address factory here down below but one

1460
00:46:55,359 --> 00:46:56,480
thing i just wanted to cover

1461
00:46:56,480 --> 00:46:58,960
is that you know these address objects

1462
00:46:58,960 --> 00:47:00,640
are not necessarily

1463
00:47:00,640 --> 00:47:02,400
integers they are you know additional

1464
00:47:02,400 --> 00:47:03,680
objects in future which which makes

1465
00:47:03,680 --> 00:47:04,960
sense when you think about it it's just

1466
00:47:04,960 --> 00:47:05,760
sometimes

1467
00:47:05,760 --> 00:47:07,280
it's tricky to kind of wrap your head

1468
00:47:07,280 --> 00:47:08,720
around that so if you do you know

1469
00:47:08,720 --> 00:47:10,240
address plus equals

1470
00:47:10,240 --> 00:47:11,599
something sometimes that might not work

1471
00:47:11,599 --> 00:47:14,560
the way you want it to

1472
00:47:14,720 --> 00:47:17,599
and so with these addresses right we can

1473
00:47:17,599 --> 00:47:19,839
do things like if you want to create

1474
00:47:19,839 --> 00:47:21,520
data one of the things that we had to do

1475
00:47:21,520 --> 00:47:23,119
before right we had to create data

1476
00:47:23,119 --> 00:47:25,280
fields for these various structs

1477
00:47:25,280 --> 00:47:27,440
and so some flat program api calls that

1478
00:47:27,440 --> 00:47:28,800
you can make would be things like

1479
00:47:28,800 --> 00:47:30,720
create byte create character create d

1480
00:47:30,720 --> 00:47:32,400
word create ascii string

1481
00:47:32,400 --> 00:47:34,800
and that will operate on the address

1482
00:47:34,800 --> 00:47:36,079
that you pass it

1483
00:47:36,079 --> 00:47:39,119
right and so these are things that you

1484
00:47:39,119 --> 00:47:40,160
probably would use

1485
00:47:40,160 --> 00:47:42,240
more if you're looking at you know say a

1486
00:47:42,240 --> 00:47:43,760
firmware image or something that

1487
00:47:43,760 --> 00:47:45,920
hasn't quite been flushed out by the

1488
00:47:45,920 --> 00:47:47,520
analysis process and you need to you

1489
00:47:47,520 --> 00:47:48,960
want to script through and create

1490
00:47:48,960 --> 00:47:49,760
strings and

1491
00:47:49,760 --> 00:47:52,720
pointers and things like that but you

1492
00:47:52,720 --> 00:47:55,040
can also use the flat program api to

1493
00:47:55,040 --> 00:47:55,920
interact with

1494
00:47:55,920 --> 00:47:58,960
instructions so you can write programs

1495
00:47:58,960 --> 00:48:00,240
to you know parse the various

1496
00:48:00,240 --> 00:48:02,160
instructions get the mnemonics get the

1497
00:48:02,160 --> 00:48:03,680
operands you can even get the p

1498
00:48:03,680 --> 00:48:05,599
code representation of the instruction

1499
00:48:05,599 --> 00:48:07,680
from a guide script

1500
00:48:07,680 --> 00:48:10,240
and i wanted to show you what that might

1501
00:48:10,240 --> 00:48:11,359
look like

1502
00:48:11,359 --> 00:48:14,559
so here we have an example program

1503
00:48:14,559 --> 00:48:16,640
for those of you that watched the some

1504
00:48:16,640 --> 00:48:18,079
of the office hours again this is just

1505
00:48:18,079 --> 00:48:20,800
a function in this game boy rom that we

1506
00:48:20,800 --> 00:48:22,079
looked at so this is all

1507
00:48:22,079 --> 00:48:25,040
arm here and you'll see that we have we

1508
00:48:25,040 --> 00:48:25,760
use the

1509
00:48:25,760 --> 00:48:27,440
function get instruction at as part of

1510
00:48:27,440 --> 00:48:28,960
the flat program api

1511
00:48:28,960 --> 00:48:30,880
and we use the current address global

1512
00:48:30,880 --> 00:48:32,720
variable and because our current address

1513
00:48:32,720 --> 00:48:33,359
is eight

1514
00:48:33,359 --> 00:48:36,720
zero zero zero zero c zero

1515
00:48:36,720 --> 00:48:39,440
it grabs this move instruction and if we

1516
00:48:39,440 --> 00:48:40,880
want to do something like get the number

1517
00:48:40,880 --> 00:48:42,960
of operands you can do in stuck it

1518
00:48:42,960 --> 00:48:44,720
on operands it returns that and stock

1519
00:48:44,720 --> 00:48:46,800
get bytes if you want the raw bytes

1520
00:48:46,800 --> 00:48:49,359
and then we have you know dot get p code

1521
00:48:49,359 --> 00:48:50,400
which gives you

1522
00:48:50,400 --> 00:48:53,040
the p code for the instruction and so if

1523
00:48:53,040 --> 00:48:54,000
you want to

1524
00:48:54,000 --> 00:48:57,040
iterate over instructions you can do you

1525
00:48:57,040 --> 00:48:58,480
can interact with

1526
00:48:58,480 --> 00:49:00,960
functions or you can call it get next

1527
00:49:00,960 --> 00:49:02,000
instruction which will grab

1528
00:49:02,000 --> 00:49:03,920
you the next instruction in the given

1529
00:49:03,920 --> 00:49:05,359
function

1530
00:49:05,359 --> 00:49:07,920
and so with the flat program api not

1531
00:49:07,920 --> 00:49:11,119
only can we we can manipulate and modify

1532
00:49:11,119 --> 00:49:13,599
instructions data we can also take a

1533
00:49:13,599 --> 00:49:15,280
look at functions so we can look at the

1534
00:49:15,280 --> 00:49:16,960
function signature we can look at the

1535
00:49:16,960 --> 00:49:18,720
parameters things like that so let's say

1536
00:49:18,720 --> 00:49:20,160
you wanted to clean up the function

1537
00:49:20,160 --> 00:49:22,079
prototype or the function parameters

1538
00:49:22,079 --> 00:49:23,599
and you knew that something was

1539
00:49:23,599 --> 00:49:25,839
consistently being calculated improperly

1540
00:49:25,839 --> 00:49:27,280
you could write a script to clean that

1541
00:49:27,280 --> 00:49:29,040
up by manipulating those functions and

1542
00:49:29,040 --> 00:49:30,720
modifying those functions

1543
00:49:30,720 --> 00:49:32,960
and again you can create one simply by

1544
00:49:32,960 --> 00:49:34,559
using you know get function at

1545
00:49:34,559 --> 00:49:36,880
address there's also create function

1546
00:49:36,880 --> 00:49:38,240
address

1547
00:49:38,240 --> 00:49:39,839
and so in this next window we have a

1548
00:49:39,839 --> 00:49:41,839
couple examples of what that might look

1549
00:49:41,839 --> 00:49:42,640
like here

1550
00:49:42,640 --> 00:49:44,720
with that same function we say get

1551
00:49:44,720 --> 00:49:46,319
function at current address

1552
00:49:46,319 --> 00:49:48,960
and it returns our init function and so

1553
00:49:48,960 --> 00:49:50,480
we can do things like get the entry

1554
00:49:50,480 --> 00:49:51,680
point get the name

1555
00:49:51,680 --> 00:49:53,440
get the return type this is the init

1556
00:49:53,440 --> 00:49:55,359
function so it doesn't really return

1557
00:49:55,359 --> 00:49:57,839
on the gameboy but if it did you would

1558
00:49:57,839 --> 00:49:59,040
be able to

1559
00:49:59,040 --> 00:50:00,880
see what return values that it actually

1560
00:50:00,880 --> 00:50:03,680
tries to return to the types rather

1561
00:50:03,680 --> 00:50:05,119
and so that's just a really quick

1562
00:50:05,119 --> 00:50:06,960
example of some of the

1563
00:50:06,960 --> 00:50:08,960
function level calls that you can use

1564
00:50:08,960 --> 00:50:12,000
within gidra's flat program api

1565
00:50:12,000 --> 00:50:14,559
and we talked about you know generating

1566
00:50:14,559 --> 00:50:16,160
p code we talked about

1567
00:50:16,160 --> 00:50:18,720
grabbing instructions so yeah we can use

1568
00:50:18,720 --> 00:50:20,240
this flat program api

1569
00:50:20,240 --> 00:50:24,079
to get the p code for the instruction

1570
00:50:24,079 --> 00:50:27,119
and so these p code ops this

1571
00:50:27,119 --> 00:50:28,880
object that is returned from that

1572
00:50:28,880 --> 00:50:30,319
provide the p

1573
00:50:30,319 --> 00:50:31,359
code operations for the given

1574
00:50:31,359 --> 00:50:32,640
instruction and you know kind of

1575
00:50:32,640 --> 00:50:34,319
describe what's happening and then

1576
00:50:34,319 --> 00:50:37,040
the really interesting thing is you can

1577
00:50:37,040 --> 00:50:37,920
take

1578
00:50:37,920 --> 00:50:39,920
these picots and you can actually

1579
00:50:39,920 --> 00:50:41,839
emulate them using gizra's p code

1580
00:50:41,839 --> 00:50:42,880
emulator

1581
00:50:42,880 --> 00:50:45,839
and that's something that is that's a

1582
00:50:45,839 --> 00:50:47,839
super powerful tool that gedra has

1583
00:50:47,839 --> 00:50:50,000
is an emulator for that underlying p

1584
00:50:50,000 --> 00:50:52,240
code and so if we want to look at how we

1585
00:50:52,240 --> 00:50:53,119
might

1586
00:50:53,119 --> 00:50:54,960
just you know iterate over some of the p

1587
00:50:54,960 --> 00:50:56,559
code in the function this is just a very

1588
00:50:56,559 --> 00:50:57,760
simple example

1589
00:50:57,760 --> 00:51:00,319
of we have our same thing of you know

1590
00:51:00,319 --> 00:51:01,520
get instruction at

1591
00:51:01,520 --> 00:51:03,200
where we grab this instruction at this

1592
00:51:03,200 --> 00:51:04,960
address and then we

1593
00:51:04,960 --> 00:51:08,319
call get.p code and just iterate over

1594
00:51:08,319 --> 00:51:10,640
the p code functions that are they're

1595
00:51:10,640 --> 00:51:11,760
actually called or the p code

1596
00:51:11,760 --> 00:51:13,359
representation of

1597
00:51:13,359 --> 00:51:16,078
that instruction

1598
00:51:17,119 --> 00:51:18,640
and so that is kind of how you can

1599
00:51:18,640 --> 00:51:20,480
script with the p

1600
00:51:20,480 --> 00:51:23,200
code the get p code function using the

1601
00:51:23,200 --> 00:51:26,240
flat program api

1602
00:51:26,640 --> 00:51:28,480
and so finally to kind of wrap things up

1603
00:51:28,480 --> 00:51:29,920
we're getting close to the end here and

1604
00:51:29,920 --> 00:51:31,520
i wanted people to have a chance to ask

1605
00:51:31,520 --> 00:51:32,240
any other

1606
00:51:32,240 --> 00:51:34,400
questions that might be more generic is

1607
00:51:34,400 --> 00:51:36,000
the final exercises i

1608
00:51:36,000 --> 00:51:39,040
pulled from crackme.1 after

1609
00:51:39,040 --> 00:51:40,559
solving them and kind of assessing the

1610
00:51:40,559 --> 00:51:43,119
difficulty and so these are not

1611
00:51:43,119 --> 00:51:45,119
uh ones that i've written these are ones

1612
00:51:45,119 --> 00:51:46,240
that i have

1613
00:51:46,240 --> 00:51:48,800
will say artisanally handpicked for you

1614
00:51:48,800 --> 00:51:49,680
that

1615
00:51:49,680 --> 00:51:51,119
are in kind of an ascending order of

1616
00:51:51,119 --> 00:51:53,599
difficulty and i wanted to use this as

1617
00:51:53,599 --> 00:51:55,680
an opportunity to introduce this site to

1618
00:51:55,680 --> 00:51:57,359
everybody so they can use this to

1619
00:51:57,359 --> 00:51:58,480
practice reversing

1620
00:51:58,480 --> 00:52:00,880
in the future and so this is a really

1621
00:52:00,880 --> 00:52:02,160
fun site you can go through and set

1622
00:52:02,160 --> 00:52:03,440
parameters for what you want to learn

1623
00:52:03,440 --> 00:52:04,559
how to take a look at

1624
00:52:04,559 --> 00:52:06,800
and what you want to maybe understand

1625
00:52:06,800 --> 00:52:08,160
better

1626
00:52:08,160 --> 00:52:10,319
and i used it a lot back when i was

1627
00:52:10,319 --> 00:52:11,839
initially learning how to do re and it

1628
00:52:11,839 --> 00:52:13,359
was very useful

1629
00:52:13,359 --> 00:52:15,520
and also we had some questions about the

1630
00:52:15,520 --> 00:52:17,200
source code for the exercises

1631
00:52:17,200 --> 00:52:19,920
so we'll be reversing or releasing those

1632
00:52:19,920 --> 00:52:20,240
uh

1633
00:52:20,240 --> 00:52:23,119
after the office hours this week as well

1634
00:52:23,119 --> 00:52:25,760
so folks can take a look at that

1635
00:52:25,760 --> 00:52:27,760
and so to kind of close things out this

1636
00:52:27,760 --> 00:52:29,200
evening this is going to be our final

1637
00:52:29,200 --> 00:52:30,800
session for now and i wanted to thank

1638
00:52:30,800 --> 00:52:31,440
everybody for

1639
00:52:31,440 --> 00:52:32,880
showing up and participating it was a

1640
00:52:32,880 --> 00:52:35,280
lot of fun and if you have any questions

1641
00:52:35,280 --> 00:52:37,200
or commentary prep that and let us know

1642
00:52:37,200 --> 00:52:43,520
for the office hour

