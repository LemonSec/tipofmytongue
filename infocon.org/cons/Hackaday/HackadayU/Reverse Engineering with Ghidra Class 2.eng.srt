1
00:00:05,029 --> 00:00:07,979
welcome everybody to the second session

2
00:00:07,979 --> 00:00:10,799
of the hackaday introduction to software

3
00:00:10,799 --> 00:00:12,840
reverse engineering with Diedrich course

4
00:00:12,840 --> 00:00:16,079
I am your instructor Matthew all and

5
00:00:16,079 --> 00:00:18,869
today what we're gonna be talking about

6
00:00:18,869 --> 00:00:23,130
is identifying C constructs in assembly

7
00:00:23,130 --> 00:00:25,529
language so a lot of people reached out

8
00:00:25,529 --> 00:00:28,589
with questions about you know how to

9
00:00:28,589 --> 00:00:32,750
identify certain constructs like this

10
00:00:32,750 --> 00:00:35,130
when looking at assembly language and

11
00:00:35,130 --> 00:00:37,170
trying to kind of determine what the C

12
00:00:37,170 --> 00:00:38,580
code was that wrote it and so that's

13
00:00:38,580 --> 00:00:43,980
what we're gonna get into today so quick

14
00:00:43,980 --> 00:00:46,500
overview we'll do a little bit of really

15
00:00:46,500 --> 00:00:48,240
quick class admin here just to make sure

16
00:00:48,240 --> 00:00:49,680
everybody's on the same page with

17
00:00:49,680 --> 00:00:51,900
regards to the office hours the

18
00:00:51,900 --> 00:00:54,810
exercises and everything and then for

19
00:00:54,810 --> 00:00:57,870
those of you that didn't show up to or

20
00:00:57,870 --> 00:00:59,520
couldn't make it to office hours last

21
00:00:59,520 --> 00:01:01,590
week we have a few quick tips for the

22
00:01:01,590 --> 00:01:03,630
exercises that people have found useful

23
00:01:03,630 --> 00:01:05,009
so I wanted to go over those kind of

24
00:01:05,009 --> 00:01:07,110
with everybody here and then we're gonna

25
00:01:07,110 --> 00:01:10,530
talk about control flow so how a program

26
00:01:10,530 --> 00:01:12,600
executes and kind of the different

27
00:01:12,600 --> 00:01:14,850
directions or pads it might take when it

28
00:01:14,850 --> 00:01:17,249
executes which involves going over

29
00:01:17,249 --> 00:01:20,369
things like function calls which as you

30
00:01:20,369 --> 00:01:22,439
can imagine are you know function calls

31
00:01:22,439 --> 00:01:24,899
in C but how we're going to address them

32
00:01:24,899 --> 00:01:26,969
from the perspective of the assembly

33
00:01:26,969 --> 00:01:29,549
language we'll talk about loops and

34
00:01:29,549 --> 00:01:31,409
iterators how to identify those in

35
00:01:31,409 --> 00:01:33,479
assembly will talk about switch

36
00:01:33,479 --> 00:01:35,909
statements and how to identify those and

37
00:01:35,909 --> 00:01:38,189
then we're gonna go over global and

38
00:01:38,189 --> 00:01:39,929
local variables what those look like

39
00:01:39,929 --> 00:01:42,569
and then array accesses and manipulation

40
00:01:42,569 --> 00:01:46,439
and so for each of these things we're

41
00:01:46,439 --> 00:01:49,109
going to be kind of going over what they

42
00:01:49,109 --> 00:01:50,999
look like in assembly how they translate

43
00:01:50,999 --> 00:01:53,880
back to C and then what you can do using

44
00:01:53,880 --> 00:01:56,819
Edra to make them a little more readable

45
00:01:56,819 --> 00:01:58,709
and a little more we'll call it you know

46
00:01:58,709 --> 00:02:03,299
accessible for the D compiler so again

47
00:02:03,299 --> 00:02:05,759
today we're gonna be going over kind of

48
00:02:05,759 --> 00:02:07,740
identifying some of these basic c

49
00:02:07,740 --> 00:02:09,990
constructs and assembly language some of

50
00:02:09,990 --> 00:02:12,360
you are probably familiar with these and

51
00:02:12,360 --> 00:02:13,590
if you're not we go over what they do

52
00:02:13,590 --> 00:02:15,180
during the class as well so everybody

53
00:02:15,180 --> 00:02:16,680
should be on the same page

54
00:02:16,680 --> 00:02:19,050
and so here again is another list of

55
00:02:19,050 --> 00:02:20,100
what we're gonna look at we're also

56
00:02:20,100 --> 00:02:22,500
gonna talk about heat memory today which

57
00:02:22,500 --> 00:02:24,420
we skipped over in the last class and

58
00:02:24,420 --> 00:02:26,580
sort of how to identify that when you're

59
00:02:26,580 --> 00:02:29,070
looking at assembly language and again

60
00:02:29,070 --> 00:02:31,680
for each of these you know C constructs

61
00:02:31,680 --> 00:02:35,340
we're gonna talk about how you can sort

62
00:02:35,340 --> 00:02:38,220
of interpret view and modify these with

63
00:02:38,220 --> 00:02:40,730
Deidre

64
00:02:40,849 --> 00:02:43,709
so you know real quick for everybody I

65
00:02:43,709 --> 00:02:44,730
think it's already already been

66
00:02:44,730 --> 00:02:46,140
mentioned in the chat so this is a bit

67
00:02:46,140 --> 00:02:47,879
redundant but office hours are gonna be

68
00:02:47,879 --> 00:02:50,370
Thursday at 6 o'clock if you have

69
00:02:50,370 --> 00:02:52,319
questions please submit them via the

70
00:02:52,319 --> 00:02:55,349
zoom chat or the group chat on the

71
00:02:55,349 --> 00:02:57,690
hackaday IO page so you can submit

72
00:02:57,690 --> 00:02:59,160
questions through any one of those and

73
00:02:59,160 --> 00:03:01,980
we will answer those questions and then

74
00:03:01,980 --> 00:03:04,200
post them up onto the hackaday page

75
00:03:04,200 --> 00:03:07,440
after the office hours so with all that

76
00:03:07,440 --> 00:03:09,900
out of the way let's get started with

77
00:03:09,900 --> 00:03:13,140
talking about how programs actually

78
00:03:13,140 --> 00:03:16,200
start up so you've probably noticed if

79
00:03:16,200 --> 00:03:17,790
you looked at the exercises there's

80
00:03:17,790 --> 00:03:21,060
additional code to you know just the

81
00:03:21,060 --> 00:03:23,579
main function right and so all of these

82
00:03:23,579 --> 00:03:26,069
code blocks are kind of used to assist

83
00:03:26,069 --> 00:03:28,680
with properly launching the binary and

84
00:03:28,680 --> 00:03:32,220
all of this program behavior in all of

85
00:03:32,220 --> 00:03:33,510
this sort of start-up behavior is

86
00:03:33,510 --> 00:03:38,129
defined by kind of the ABI and so when

87
00:03:38,129 --> 00:03:40,290
you look at the elf header there is a

88
00:03:40,290 --> 00:03:43,019
specific field called the e entry field

89
00:03:43,019 --> 00:03:46,290
and this points to the underscore start

90
00:03:46,290 --> 00:03:47,970
function and if you take a look at that

91
00:03:47,970 --> 00:03:50,519
when you're looking at your code and

92
00:03:50,519 --> 00:03:52,290
Diedre that eventually is what calls

93
00:03:52,290 --> 00:03:55,230
made and so the reason I kind of wanted

94
00:03:55,230 --> 00:03:57,329
to quickly go over this with you is if

95
00:03:57,329 --> 00:03:58,709
any of you were struggling kind of where

96
00:03:58,709 --> 00:04:01,380
to find the code of interest when you're

97
00:04:01,380 --> 00:04:05,280
looking at the exercises this is kind of

98
00:04:05,280 --> 00:04:07,169
how these programs are constructed and

99
00:04:07,169 --> 00:04:10,980
kind of how they start up so since all

100
00:04:10,980 --> 00:04:14,340
of our exercises are for x86 64 Linux

101
00:04:14,340 --> 00:04:16,440
they're going to conform to the system V

102
00:04:16,440 --> 00:04:21,510
ABI and so we can take information from

103
00:04:21,510 --> 00:04:24,000
that from that you know we talked about

104
00:04:24,000 --> 00:04:25,020
that in the last session of the

105
00:04:25,020 --> 00:04:27,510
application binary interface we can take

106
00:04:27,510 --> 00:04:29,280
that information and use it to kind of

107
00:04:29,280 --> 00:04:32,760
clean up the D compiler output and we

108
00:04:32,760 --> 00:04:34,830
the arguments to the main function then

109
00:04:34,830 --> 00:04:36,870
are actually going to be determined by

110
00:04:36,870 --> 00:04:38,760
this ABI so we can utilize that

111
00:04:38,760 --> 00:04:41,870
information as well

112
00:04:43,740 --> 00:04:48,190
so when talking about this stuff and we

113
00:04:48,190 --> 00:04:49,330
talked about this a little bit during

114
00:04:49,330 --> 00:04:51,280
the office hour you have things called

115
00:04:51,280 --> 00:04:54,190
function signatures in Deidre and so

116
00:04:54,190 --> 00:04:55,660
those of you that are familiar with

117
00:04:55,660 --> 00:04:57,280
coding or you know understand what kind

118
00:04:57,280 --> 00:04:58,630
of a function signature is but

119
00:04:58,630 --> 00:05:01,300
essentially this tells us you know the

120
00:05:01,300 --> 00:05:03,670
argument count the types for the various

121
00:05:03,670 --> 00:05:06,010
arguments and the return values for a

122
00:05:06,010 --> 00:05:08,980
specific function and as we displayed

123
00:05:08,980 --> 00:05:11,170
quickly during the office hour fixing up

124
00:05:11,170 --> 00:05:14,620
that function signature can make the

125
00:05:14,620 --> 00:05:17,980
output of the decompiler a whole lot

126
00:05:17,980 --> 00:05:20,320
more readable and so we're gonna have a

127
00:05:20,320 --> 00:05:22,990
quick example of that yeah after this

128
00:05:22,990 --> 00:05:25,570
next slide and then I saw somebody raise

129
00:05:25,570 --> 00:05:26,800
their hand so we'll take the question

130
00:05:26,800 --> 00:05:30,970
really quick and so part of cleaning up

131
00:05:30,970 --> 00:05:34,180
this function signature involves you

132
00:05:34,180 --> 00:05:35,620
know fixing up these arguments that are

133
00:05:35,620 --> 00:05:37,000
passed to the function and so those of

134
00:05:37,000 --> 00:05:39,160
you that have written C before are

135
00:05:39,160 --> 00:05:41,620
familiar with kind of the two common

136
00:05:41,620 --> 00:05:44,230
arguments that you passed an AC program

137
00:05:44,230 --> 00:05:47,080
and again this is defined by the ABI so

138
00:05:47,080 --> 00:05:50,410
this is kind of the same concept we

139
00:05:50,410 --> 00:05:52,140
talked about in the last session of

140
00:05:52,140 --> 00:05:55,000
looking for the few things that we know

141
00:05:55,000 --> 00:05:56,860
to sort of be true when we're running a

142
00:05:56,860 --> 00:05:58,780
program right if the ABI defines these

143
00:05:58,780 --> 00:06:01,720
certain things it's relatively safe for

144
00:06:01,720 --> 00:06:03,550
us to assume that they're going to be

145
00:06:03,550 --> 00:06:05,550
there for our particular target which is

146
00:06:05,550 --> 00:06:10,450
x86 64 Linux so since we know that the

147
00:06:10,450 --> 00:06:12,940
main function is gonna get called with

148
00:06:12,940 --> 00:06:15,220
two arguments right the argument count

149
00:06:15,220 --> 00:06:18,400
in the argument vector we can clean that

150
00:06:18,400 --> 00:06:21,640
up in Dedra to make it a little more

151
00:06:21,640 --> 00:06:24,340
readable and so what that would look

152
00:06:24,340 --> 00:06:27,100
like is let's say you have a function

153
00:06:27,100 --> 00:06:28,420
and this was pulled from one of the

154
00:06:28,420 --> 00:06:31,870
exercises from last week so we have our

155
00:06:31,870 --> 00:06:34,090
main function here and you can see that

156
00:06:34,090 --> 00:06:37,090
we have you know two arguments but for

157
00:06:37,090 --> 00:06:39,070
some reason Dedra believes the second

158
00:06:39,070 --> 00:06:40,780
argument is long in the first argument

159
00:06:40,780 --> 00:06:43,210
isn't it the first are the first one is

160
00:06:43,210 --> 00:06:44,800
correct but the second one is obviously

161
00:06:44,800 --> 00:06:46,690
not right because we know that the

162
00:06:46,690 --> 00:06:47,860
second one is supposed to be our

163
00:06:47,860 --> 00:06:50,470
argument vector so if we want to fix

164
00:06:50,470 --> 00:06:52,390
that up what we can do engage RIA is

165
00:06:52,390 --> 00:06:55,030
this you can right click the function

166
00:06:55,030 --> 00:06:56,100
name and

167
00:06:56,100 --> 00:06:58,890
like edit function signature and when

168
00:06:58,890 --> 00:07:02,310
you do that that's gonna bring up this

169
00:07:02,310 --> 00:07:04,680
menu here which will let you edit the

170
00:07:04,680 --> 00:07:05,940
function signature you can change the

171
00:07:05,940 --> 00:07:08,100
name you can change the return value and

172
00:07:08,100 --> 00:07:10,500
what we're gonna do is you can change

173
00:07:10,500 --> 00:07:14,160
the arguments and so if we take those

174
00:07:14,160 --> 00:07:17,820
values and change them to match the c

175
00:07:17,820 --> 00:07:22,290
standard right and the regular avi let's

176
00:07:22,290 --> 00:07:24,210
take a look at how that affects the d

177
00:07:24,210 --> 00:07:28,140
compiler output afterwards so look at

178
00:07:28,140 --> 00:07:30,060
that so before where we had all kinds of

179
00:07:30,060 --> 00:07:32,460
you know we'll just go back real quick

180
00:07:32,460 --> 00:07:35,400
we had all these crazy accesses going on

181
00:07:35,400 --> 00:07:37,500
to get to this variable in and yes if

182
00:07:37,500 --> 00:07:38,700
you look at the assembly and you're

183
00:07:38,700 --> 00:07:40,770
familiar with this you may be able to

184
00:07:40,770 --> 00:07:42,210
figure out like oh yeah this is the

185
00:07:42,210 --> 00:07:45,330
first element in the argument vector but

186
00:07:45,330 --> 00:07:48,270
once you clean up the when you clean up

187
00:07:48,270 --> 00:07:50,700
the function signature it just becomes a

188
00:07:50,700 --> 00:07:52,980
lot more readable right and so here also

189
00:07:52,980 --> 00:07:55,380
these we have accesses to these

190
00:07:55,380 --> 00:07:57,390
two-dimensional arrays and again if we

191
00:07:57,390 --> 00:07:58,920
go back and look at these before

192
00:07:58,920 --> 00:08:00,450
cleaning up the function signature I

193
00:08:00,450 --> 00:08:03,690
mean this is this is certainly readable

194
00:08:03,690 --> 00:08:05,460
for those of you that are that are used

195
00:08:05,460 --> 00:08:07,470
to it but you know when we go through

196
00:08:07,470 --> 00:08:08,490
and clean that up

197
00:08:08,490 --> 00:08:10,470
it just becomes no much more streamlined

198
00:08:10,470 --> 00:08:12,120
it much more readable in this little

199
00:08:12,120 --> 00:08:14,370
this little trick will work on all of

200
00:08:14,370 --> 00:08:17,880
the exercises that we have for this

201
00:08:17,880 --> 00:08:21,270
course and so this was just kind of a

202
00:08:21,270 --> 00:08:24,300
refresher and a bit of a series of tips

203
00:08:24,300 --> 00:08:26,700
for these exercises as everybody works

204
00:08:26,700 --> 00:08:28,920
through them and for new ones were added

205
00:08:28,920 --> 00:08:31,230
today so those of you that are following

206
00:08:31,230 --> 00:08:33,120
along with those have a for new

207
00:08:33,120 --> 00:08:36,179
exercises to look forward to maybe

208
00:08:36,179 --> 00:08:38,460
actually it might be five so more

209
00:08:38,460 --> 00:08:41,539
homework exactly what you want sure so

210
00:08:41,539 --> 00:08:43,770
the next thing I want to talk about in

211
00:08:43,770 --> 00:08:46,320
relation to making sure everybody knows

212
00:08:46,320 --> 00:08:50,100
what to do with these exercises is we're

213
00:08:50,100 --> 00:08:51,860
gonna review kind of imports and exports

214
00:08:51,860 --> 00:08:55,560
so these things are defined you know by

215
00:08:55,560 --> 00:08:57,870
the elf header and essentially these are

216
00:08:57,870 --> 00:09:00,390
either functions that you know might be

217
00:09:00,390 --> 00:09:02,760
being exported for other programs to use

218
00:09:02,760 --> 00:09:04,980
and they also define functions that are

219
00:09:04,980 --> 00:09:06,570
imported that our program needs to use

220
00:09:06,570 --> 00:09:09,660
and so for our challenge

221
00:09:09,660 --> 00:09:13,020
if we want to find Maine we can look at

222
00:09:13,020 --> 00:09:15,930
the symbol tree and gira and navigate to

223
00:09:15,930 --> 00:09:17,940
that because again that's defined by the

224
00:09:17,940 --> 00:09:20,700
ABI and if you can't find that a good

225
00:09:20,700 --> 00:09:23,130
place to start is the underscore start

226
00:09:23,130 --> 00:09:27,420
function and so the imports window and

227
00:09:27,420 --> 00:09:31,350
nidra looks like this and so you'll see

228
00:09:31,350 --> 00:09:33,300
in the symbol tree of imports exports it

229
00:09:33,300 --> 00:09:36,150
finds all the functions that are that it

230
00:09:36,150 --> 00:09:38,160
can define string Auto analysis any

231
00:09:38,160 --> 00:09:40,380
labels that you make in additional

232
00:09:40,380 --> 00:09:41,730
classes that you make in the various

233
00:09:41,730 --> 00:09:43,620
namespaces and of course you can go in

234
00:09:43,620 --> 00:09:45,900
here and rename things and edit things

235
00:09:45,900 --> 00:09:50,510
but for our exercises if you want to

236
00:09:50,510 --> 00:09:53,430
jump to the kind of jump right to the

237
00:09:53,430 --> 00:09:54,780
main function and what you'll be

238
00:09:54,780 --> 00:09:57,180
interested in you can open the functions

239
00:09:57,180 --> 00:09:59,850
window here scroll down to main and

240
00:09:59,850 --> 00:10:02,070
double click on that and that'll take

241
00:10:02,070 --> 00:10:04,560
you to the main function which for the

242
00:10:04,560 --> 00:10:06,180
exercises that we're gonna be doing are

243
00:10:06,180 --> 00:10:08,670
gonna be your starting point and so I

244
00:10:08,670 --> 00:10:11,550
just wanted to go over those few quick

245
00:10:11,550 --> 00:10:15,420
tips regarding the exercises so that

246
00:10:15,420 --> 00:10:17,040
everybody was kind of on the same page

247
00:10:17,040 --> 00:10:18,450
for those of you that may not have made

248
00:10:18,450 --> 00:10:26,510
to the office hours so really quickly

249
00:10:32,190 --> 00:10:34,530
okay yeah so those of you that have

250
00:10:34,530 --> 00:10:37,020
questions please feel free to submit

251
00:10:37,020 --> 00:10:41,130
those to the QA for the office hours and

252
00:10:41,130 --> 00:10:43,230
I noticed somebody asked about answers

253
00:10:43,230 --> 00:10:46,080
to the exercises the what I would like

254
00:10:46,080 --> 00:10:47,340
to do if you have a question about a

255
00:10:47,340 --> 00:10:49,950
specific exercise for now reach out to

256
00:10:49,950 --> 00:10:51,720
me and I can either help you with it or

257
00:10:51,720 --> 00:10:53,880
give you the answer I don't want to post

258
00:10:53,880 --> 00:10:56,280
the answers just yet I want people to

259
00:10:56,280 --> 00:10:58,500
try to work through them so we'll

260
00:10:58,500 --> 00:11:01,380
probably post the answers at a staggered

261
00:11:01,380 --> 00:11:03,120
rate or if you want to reach out to

262
00:11:03,120 --> 00:11:05,040
other people in the chat on the i/o page

263
00:11:05,040 --> 00:11:06,840
to ask for some help and work through

264
00:11:06,840 --> 00:11:08,790
them that that's something you can do as

265
00:11:08,790 --> 00:11:11,910
well the reason being is I don't want

266
00:11:11,910 --> 00:11:14,280
the answer to be there as kind of a

267
00:11:14,280 --> 00:11:15,870
temptation for you to just look at so

268
00:11:15,870 --> 00:11:17,940
I'd like for everybody to try it you

269
00:11:17,940 --> 00:11:19,140
know to work through those as best they

270
00:11:19,140 --> 00:11:21,990
can and then we'll release the answers

271
00:11:21,990 --> 00:11:23,730
kind of in a staggered fashion so that

272
00:11:23,730 --> 00:11:25,890
nobody gets caught up for too long or

273
00:11:25,890 --> 00:11:29,880
hung up for too long rather so now that

274
00:11:29,880 --> 00:11:33,240
we've gone over the how to kind of load

275
00:11:33,240 --> 00:11:35,100
our exercises of the deidre is a bit of

276
00:11:35,100 --> 00:11:37,590
a recap for those of you that weren't in

277
00:11:37,590 --> 00:11:39,930
the office hour we want to talk a little

278
00:11:39,930 --> 00:11:43,770
bit about control flow and so from kind

279
00:11:43,770 --> 00:11:46,470
of a 10,000 foot view control flow is

280
00:11:46,470 --> 00:11:47,910
the order in which instructions are

281
00:11:47,910 --> 00:11:51,360
executed on your computer and these kind

282
00:11:51,360 --> 00:11:54,870
of commands or constructs in C might

283
00:11:54,870 --> 00:11:57,480
look like if statements go-to statements

284
00:11:57,480 --> 00:11:59,520
switch statements while statements etc

285
00:11:59,520 --> 00:12:05,010
and so these as the name describes right

286
00:12:05,010 --> 00:12:07,770
kind of control the flow of execution

287
00:12:07,770 --> 00:12:09,870
and so if you're trying to figure out

288
00:12:09,870 --> 00:12:13,080
what a program does figuring out the

289
00:12:13,080 --> 00:12:15,720
path that it's taking when executing is

290
00:12:15,720 --> 00:12:17,340
very important because you may not

291
00:12:17,340 --> 00:12:20,730
always have a full fledged debugger at

292
00:12:20,730 --> 00:12:23,640
your disposal and you may not be able to

293
00:12:23,640 --> 00:12:25,290
even run the code you're looking at

294
00:12:25,290 --> 00:12:26,880
right so if you're looking at maybe a

295
00:12:26,880 --> 00:12:29,310
firmware image and you don't have

296
00:12:29,310 --> 00:12:32,010
hardware debugging on your platform you

297
00:12:32,010 --> 00:12:35,070
are gonna have to have a pretty solid

298
00:12:35,070 --> 00:12:36,150
understanding of this because you won't

299
00:12:36,150 --> 00:12:37,530
be able to set breakpoints and see

300
00:12:37,530 --> 00:12:40,740
exactly how things are running and so as

301
00:12:40,740 --> 00:12:44,339
we kind of covered in the previous class

302
00:12:44,339 --> 00:12:45,810
right we know that our IP

303
00:12:45,810 --> 00:12:47,430
the address of the next instruction to

304
00:12:47,430 --> 00:12:50,550
execute and the jump instruction can

305
00:12:50,550 --> 00:12:53,009
alter our IP and we talked about the

306
00:12:53,009 --> 00:12:55,170
syntax of that instruction if you need a

307
00:12:55,170 --> 00:12:56,699
refresher to that please refer to the

308
00:12:56,699 --> 00:12:59,600
the first class slides or the Intel x86

309
00:12:59,600 --> 00:13:02,490
manual that's linked on the page we

310
00:13:02,490 --> 00:13:04,439
briefly talked about how the jump

311
00:13:04,439 --> 00:13:07,439
instruction can selectively execute

312
00:13:07,439 --> 00:13:10,230
based on the contents of the flag's

313
00:13:10,230 --> 00:13:12,180
register and we talked about how the

314
00:13:12,180 --> 00:13:15,029
flags register is set after a compare

315
00:13:15,029 --> 00:13:17,309
instruction based on the two values

316
00:13:17,309 --> 00:13:20,819
right so the second argument subtracted

317
00:13:20,819 --> 00:13:23,009
from the first and then based on the

318
00:13:23,009 --> 00:13:24,899
arithmetic result their various flags

319
00:13:24,899 --> 00:13:28,050
are set in the flags register and you

320
00:13:28,050 --> 00:13:31,889
can then determine how you want to move

321
00:13:31,889 --> 00:13:33,420
forward with your program based on those

322
00:13:33,420 --> 00:13:36,089
flags with these jump instructions so if

323
00:13:36,089 --> 00:13:37,860
the two arguments are equal you can take

324
00:13:37,860 --> 00:13:39,540
a branch if they're not equal you can

325
00:13:39,540 --> 00:13:42,149
take a branch you can jump if greater

326
00:13:42,149 --> 00:13:46,559
jump if less and so these are at the low

327
00:13:46,559 --> 00:13:49,170
level what you're gonna see in terms of

328
00:13:49,170 --> 00:13:51,990
instead of maybe your if-else statement

329
00:13:51,990 --> 00:13:55,410
or and things like that so for example

330
00:13:55,410 --> 00:13:57,029
if we have this block of assembly here

331
00:13:57,029 --> 00:13:59,399
and we take a look at let's take a look

332
00:13:59,399 --> 00:14:01,230
at this instruction so here we're

333
00:14:01,230 --> 00:14:04,559
comparing some variable on the stack to

334
00:14:04,559 --> 00:14:07,439
the value 100 okay so what this is gonna

335
00:14:07,439 --> 00:14:09,629
do it's gonna subtract 100 from this

336
00:14:09,629 --> 00:14:12,899
variable on the stack store any flags

337
00:14:12,899 --> 00:14:15,329
that get set in the flags register

338
00:14:15,329 --> 00:14:17,790
remember the compare instruction doesn't

339
00:14:17,790 --> 00:14:21,779
actually alter the with the contents of

340
00:14:21,779 --> 00:14:23,730
the registers it's just used to set the

341
00:14:23,730 --> 00:14:29,279
flags instruction and so if our variable

342
00:14:29,279 --> 00:14:31,559
on the stack here was less than 100

343
00:14:31,559 --> 00:14:33,779
we're gonna jump to this portion of the

344
00:14:33,779 --> 00:14:35,730
program otherwise we're gonna continue

345
00:14:35,730 --> 00:14:39,449
execution as normal right so this is

346
00:14:39,449 --> 00:14:41,550
kind of an example of how when an

347
00:14:41,550 --> 00:14:43,199
if-else might look like and don't worry

348
00:14:43,199 --> 00:14:45,179
we're gonna we're gonna go into this in

349
00:14:45,179 --> 00:14:47,579
much more detail this is just kind of a

350
00:14:47,579 --> 00:14:49,470
high-level view of what these compare

351
00:14:49,470 --> 00:14:50,699
instructions are going to look like when

352
00:14:50,699 --> 00:14:52,420
you come across them

353
00:14:52,420 --> 00:14:54,760
and how the jump instruction can be used

354
00:14:54,760 --> 00:14:56,620
with these extensions to figure out

355
00:14:56,620 --> 00:15:00,690
where where you're going to land

356
00:15:03,200 --> 00:15:10,740
okay I'm just checking the okay so to

357
00:15:10,740 --> 00:15:13,860
get a better understanding of control

358
00:15:13,860 --> 00:15:16,530
flow deidre has something called a graph

359
00:15:16,530 --> 00:15:18,300
view because when you're looking at

360
00:15:18,300 --> 00:15:21,270
something like this right you it might

361
00:15:21,270 --> 00:15:24,300
not maybe you know super clear where

362
00:15:24,300 --> 00:15:25,890
this jump is actually gonna go or how

363
00:15:25,890 --> 00:15:27,720
the overall flow of the program is

364
00:15:27,720 --> 00:15:29,220
structured especially if there are

365
00:15:29,220 --> 00:15:31,850
multiple jump obstructions right so

366
00:15:31,850 --> 00:15:34,530
Deidre has a graph view that you can use

367
00:15:34,530 --> 00:15:35,970
that will actually break out all the

368
00:15:35,970 --> 00:15:38,310
different conditional statements into

369
00:15:38,310 --> 00:15:41,340
their own blocks of code and this can be

370
00:15:41,340 --> 00:15:43,290
extremely useful when you're trying to

371
00:15:43,290 --> 00:15:44,880
figure out sort of the overall flow of

372
00:15:44,880 --> 00:15:48,210
the program right and you can get to

373
00:15:48,210 --> 00:15:50,430
this by highlighting a function name and

374
00:15:50,430 --> 00:15:53,010
then go to window and a function graph

375
00:15:53,010 --> 00:15:55,830
so what that would look like in a draw

376
00:15:55,830 --> 00:15:59,880
is this so we've got the window tab here

377
00:15:59,880 --> 00:16:01,620
we click function graph and we've

378
00:16:01,620 --> 00:16:04,050
highlighted the main function and then

379
00:16:04,050 --> 00:16:06,930
this is what it's going to show and so

380
00:16:06,930 --> 00:16:08,850
you can see where this is it's probably

381
00:16:08,850 --> 00:16:11,040
not the easiest thing to read right but

382
00:16:11,040 --> 00:16:13,500
it still gives you an idea of this is

383
00:16:13,500 --> 00:16:16,230
probably our you know our final else

384
00:16:16,230 --> 00:16:22,050
block here right so looking at this we

385
00:16:22,050 --> 00:16:24,210
can see that there are multiple checks

386
00:16:24,210 --> 00:16:29,250
here that if the condition is if the

387
00:16:29,250 --> 00:16:31,620
call function if the call occurs we go

388
00:16:31,620 --> 00:16:33,870
down here if not we jump down here so

389
00:16:33,870 --> 00:16:36,870
this kind of function graph is super

390
00:16:36,870 --> 00:16:40,140
useful for getting a quick view of the

391
00:16:40,140 --> 00:16:43,680
overall structure of the program and so

392
00:16:43,680 --> 00:16:46,140
for control flow we've got an exercise

393
00:16:46,140 --> 00:16:49,070
in the github repo and a couple of

394
00:16:49,070 --> 00:16:51,150
supplemental questions for the exercise

395
00:16:51,150 --> 00:16:52,680
in addition to trying to solve you know

396
00:16:52,680 --> 00:16:54,480
the pass code which is that's gonna be

397
00:16:54,480 --> 00:16:56,280
the format most of these take is you

398
00:16:56,280 --> 00:16:58,260
know solving for the pass code when we

399
00:16:58,260 --> 00:17:00,930
get into sessions three and four you're

400
00:17:00,930 --> 00:17:03,060
going to be doing you're gonna be

401
00:17:03,060 --> 00:17:04,440
interacting with these programs in a

402
00:17:04,440 --> 00:17:06,119
slightly more advanced way but for

403
00:17:06,119 --> 00:17:09,990
Session two your pass codes and your key

404
00:17:09,990 --> 00:17:11,579
codes for the exercises are gonna be

405
00:17:11,579 --> 00:17:14,190
things that you can enter in through the

406
00:17:14,190 --> 00:17:15,359
keyboard so they're all gonna be

407
00:17:15,359 --> 00:17:17,040
Aled ask you French now that's gonna

408
00:17:17,040 --> 00:17:19,770
change soon and we're gonna go over how

409
00:17:19,770 --> 00:17:23,099
to get around that in later sessions so

410
00:17:23,099 --> 00:17:25,589
in exercise one and control flow one

411
00:17:25,589 --> 00:17:27,660
load it up an engager like we did in the

412
00:17:27,660 --> 00:17:30,750
previous one fix up main like we talked

413
00:17:30,750 --> 00:17:32,630
about with the function signature and

414
00:17:32,630 --> 00:17:36,299
the first thing once you find main look

415
00:17:36,299 --> 00:17:37,860
at how many comparison statements there

416
00:17:37,860 --> 00:17:40,140
are and what are the three values that

417
00:17:40,140 --> 00:17:42,179
are being compared and then lastly can

418
00:17:42,179 --> 00:17:44,820
you pass the check so there's three

419
00:17:44,820 --> 00:17:46,049
different checks that are gonna be

420
00:17:46,049 --> 00:17:48,090
performed on the values that you enter

421
00:17:48,090 --> 00:17:51,270
into the program and if you can figure

422
00:17:51,270 --> 00:17:52,860
out these comparisons that are being

423
00:17:52,860 --> 00:17:55,679
made you should be able to feed it the

424
00:17:55,679 --> 00:17:58,260
two values that should properly pass all

425
00:17:58,260 --> 00:18:01,919
the checks and so we can go over that if

426
00:18:01,919 --> 00:18:04,350
anybody has any questions about that we

427
00:18:04,350 --> 00:18:05,940
can go over it during office hours we

428
00:18:05,940 --> 00:18:07,860
can talk about it on the course page any

429
00:18:07,860 --> 00:18:11,549
of those any of those work so another

430
00:18:11,549 --> 00:18:14,880
form of control flow our switch cases

431
00:18:14,880 --> 00:18:16,890
and and those of you that have written C

432
00:18:16,890 --> 00:18:19,440
code have seen these before so switch

433
00:18:19,440 --> 00:18:21,210
cases essentially allow you know a

434
00:18:21,210 --> 00:18:23,880
single variable to be compared against a

435
00:18:23,880 --> 00:18:26,340
list of values in each of these values

436
00:18:26,340 --> 00:18:29,010
is you know considered a case and you

437
00:18:29,010 --> 00:18:31,950
can have any number of cases and there

438
00:18:31,950 --> 00:18:33,690
are you know very few rules kind of for

439
00:18:33,690 --> 00:18:35,309
the switch case but the expression for

440
00:18:35,309 --> 00:18:37,860
the case has to be the same data type as

441
00:18:37,860 --> 00:18:40,230
to the variable in the switch and so

442
00:18:40,230 --> 00:18:42,960
each of these cases then terminates on

443
00:18:42,960 --> 00:18:45,809
what's called a break statement and what

444
00:18:45,809 --> 00:18:47,600
that would look like and see is

445
00:18:47,600 --> 00:18:49,980
something like this so on the Left we

446
00:18:49,980 --> 00:18:53,400
have some C code here that grabs an

447
00:18:53,400 --> 00:18:56,760
integer value note that we cast it to a

448
00:18:56,760 --> 00:18:59,490
character and then if the integer value

449
00:18:59,490 --> 00:19:01,830
is either lower case a lower case B if

450
00:19:01,830 --> 00:19:04,230
it's lower case a we set the value a to

451
00:19:04,230 --> 00:19:06,419
1 and then we exit if it's lower case B

452
00:19:06,419 --> 00:19:09,330
we set it equal to 2 and then we exit

453
00:19:09,330 --> 00:19:12,059
and so this is a very boilerplate

454
00:19:12,059 --> 00:19:14,429
example for how switch cases would work

455
00:19:14,429 --> 00:19:17,250
and on the right we have the assembly

456
00:19:17,250 --> 00:19:20,100
representation for this code so let's

457
00:19:20,100 --> 00:19:22,980
talk about how this is actually going to

458
00:19:22,980 --> 00:19:24,010
execute in what's gonna

459
00:19:24,010 --> 00:19:28,809
so first we're gonna call the a to I

460
00:19:28,809 --> 00:19:32,380
function right our return value is gonna

461
00:19:32,380 --> 00:19:34,360
be an e X and we're gonna store that

462
00:19:34,360 --> 00:19:36,040
we're gonna store that onto the stack

463
00:19:36,040 --> 00:19:37,960
and then we're gonna immediately copy it

464
00:19:37,960 --> 00:19:43,540
right back in to ei X so EA X contains

465
00:19:43,540 --> 00:19:47,140
our return value from the ADA Y function

466
00:19:47,140 --> 00:19:49,450
and so when this first check gets

467
00:19:49,450 --> 00:19:51,760
performed in the switch case those of

468
00:19:51,760 --> 00:19:53,110
you if you're looking at the Assembly on

469
00:19:53,110 --> 00:19:55,360
the right you can probably guess where

470
00:19:55,360 --> 00:19:57,850
this is going right so this is the

471
00:19:57,850 --> 00:20:01,960
comparison hex 61 is also lowercase a so

472
00:20:01,960 --> 00:20:04,090
this is the comparison that's being

473
00:20:04,090 --> 00:20:07,960
performed now this is setting the

474
00:20:07,960 --> 00:20:10,330
relevant flags in the flags register and

475
00:20:10,330 --> 00:20:13,059
if they are equal we're gonna jump to

476
00:20:13,059 --> 00:20:17,740
main plus hex 50 okay which is also 6d a

477
00:20:17,740 --> 00:20:19,929
as you can see in the assembly listing

478
00:20:19,929 --> 00:20:22,809
and so what's at 60 a if they're equal

479
00:20:22,809 --> 00:20:28,030
we jump to 60 a and remember this is the

480
00:20:28,030 --> 00:20:30,970
address this is where our result was

481
00:20:30,970 --> 00:20:34,450
stored on the stack right and so we're

482
00:20:34,450 --> 00:20:37,419
storing one to that result on the stack

483
00:20:37,419 --> 00:20:41,850
so this is a setting a equal to one and

484
00:20:41,850 --> 00:20:46,000
then after that we have the break

485
00:20:46,000 --> 00:20:49,000
statement right and this jumps to kind

486
00:20:49,000 --> 00:20:50,950
of the end of the function where we

487
00:20:50,950 --> 00:20:54,610
return and so this is sort of how this

488
00:20:54,610 --> 00:20:58,450
switch construct gets converted from you

489
00:20:58,450 --> 00:21:00,820
know C code to assembly code and again

490
00:21:00,820 --> 00:21:03,610
if we looked at the case for B if it

491
00:21:03,610 --> 00:21:06,760
didn't pass this comparison right so if

492
00:21:06,760 --> 00:21:08,230
we failed and they weren't equal it

493
00:21:08,230 --> 00:21:09,970
would then just execute the next

494
00:21:09,970 --> 00:21:12,669
instruction and so that would compare

495
00:21:12,669 --> 00:21:15,669
our value to hex 62 which is lower case

496
00:21:15,669 --> 00:21:20,710
B excuse me and if that comparison

497
00:21:20,710 --> 00:21:24,780
passed we would jump if equal to 63

498
00:21:24,780 --> 00:21:28,090
where we would store two into that

499
00:21:28,090 --> 00:21:31,120
variable and then the last case the

500
00:21:31,120 --> 00:21:32,679
default case in the switch statement

501
00:21:32,679 --> 00:21:34,240
which is kind of the fall through stores

502
00:21:34,240 --> 00:21:37,059
three and we can see that here

503
00:21:37,059 --> 00:21:40,720
so this is kind of what switch

504
00:21:40,720 --> 00:21:43,690
statements look like when you go from C

505
00:21:43,690 --> 00:21:46,539
to assembly and and this can change you

506
00:21:46,539 --> 00:21:48,909
know based on the value that you're

507
00:21:48,909 --> 00:21:52,360
using to compare with but this is kind

508
00:21:52,360 --> 00:21:56,200
of a quick look at how these statements

509
00:21:56,200 --> 00:21:59,110
get generated in assembly and so it's

510
00:21:59,110 --> 00:22:00,429
important to be able to see something

511
00:22:00,429 --> 00:22:02,200
like this and kind of understand from

512
00:22:02,200 --> 00:22:03,759
looking at this okay I have you know a

513
00:22:03,759 --> 00:22:05,820
handful of comparisons and then

514
00:22:05,820 --> 00:22:08,950
eventually they all jump out to the same

515
00:22:08,950 --> 00:22:11,470
location so you can kind of look at that

516
00:22:11,470 --> 00:22:13,869
and start to reconstruct the switch case

517
00:22:13,869 --> 00:22:15,249
from that right because the location

518
00:22:15,249 --> 00:22:16,779
that they all eventually jump out to is

519
00:22:16,779 --> 00:22:18,970
where you go when you brake and so you

520
00:22:18,970 --> 00:22:20,619
can kind of work backwards from there to

521
00:22:20,619 --> 00:22:25,590
reconstruct this the switch state and so

522
00:22:25,590 --> 00:22:27,970
when you were looking at something like

523
00:22:27,970 --> 00:22:29,889
this and when you're looking at you know

524
00:22:29,889 --> 00:22:32,249
kind of data in deidre in general

525
00:22:32,249 --> 00:22:35,110
something that you might want to do is

526
00:22:35,110 --> 00:22:37,600
convert the data types so as we were

527
00:22:37,600 --> 00:22:38,860
going back and forth here we were

528
00:22:38,860 --> 00:22:40,840
talking about how oh this is also you

529
00:22:40,840 --> 00:22:43,710
know hex 61 and this is hex 62 and

530
00:22:43,710 --> 00:22:46,179
sometimes you might just want to you

531
00:22:46,179 --> 00:22:47,860
know convert those so that it's more

532
00:22:47,860 --> 00:22:50,080
readable so that it's easier for you to

533
00:22:50,080 --> 00:22:52,149
understand etc there are multiple

534
00:22:52,149 --> 00:22:53,440
reasons you would want to change data

535
00:22:53,440 --> 00:22:54,610
types and it might be because the

536
00:22:54,610 --> 00:22:56,470
program is casting it a certain way and

537
00:22:56,470 --> 00:22:58,720
you want the output to display it in the

538
00:22:58,720 --> 00:23:00,369
way that it's being cast so you can

539
00:23:00,369 --> 00:23:02,860
understand it better and so Deidre will

540
00:23:02,860 --> 00:23:04,960
let you do that by right-clicking an

541
00:23:04,960 --> 00:23:06,789
immediate value in the assembly listing

542
00:23:06,789 --> 00:23:08,740
and then selecting convert and this can

543
00:23:08,740 --> 00:23:10,990
also propagate out to the decompiler

544
00:23:10,990 --> 00:23:12,220
output and make it a little more

545
00:23:12,220 --> 00:23:15,309
readable and really quick what we're

546
00:23:15,309 --> 00:23:16,990
gonna be doing throughout this lesson is

547
00:23:16,990 --> 00:23:18,809
kind of going over these C constructs

548
00:23:18,809 --> 00:23:21,279
looking at them from C to assembly and

549
00:23:21,279 --> 00:23:23,049
then talking about a Ghidorah tip to

550
00:23:23,049 --> 00:23:25,029
make looking at these constructs a

551
00:23:25,029 --> 00:23:27,580
little more doable and a little more

552
00:23:27,580 --> 00:23:29,889
user-friendly and then we'll close out

553
00:23:29,889 --> 00:23:31,539
with a description of the exercise for

554
00:23:31,539 --> 00:23:35,619
each one so indeed rillettes say this

555
00:23:35,619 --> 00:23:36,730
probably looks very familiar because

556
00:23:36,730 --> 00:23:38,049
it's the code we were looking at before

557
00:23:38,049 --> 00:23:40,690
and so let's say you want to change this

558
00:23:40,690 --> 00:23:42,570
to actually display this character

559
00:23:42,570 --> 00:23:45,759
lowercase a so you can right-click that

560
00:23:45,759 --> 00:23:47,980
immediate value and go down to convert

561
00:23:47,980 --> 00:23:50,590
and then select you know character

562
00:23:50,590 --> 00:23:51,640
sequence

563
00:23:51,640 --> 00:23:55,930
so once you do that that will be

564
00:23:55,930 --> 00:23:58,240
propagated throughout the decompiler

565
00:23:58,240 --> 00:23:59,500
applet so it'll actually have the

566
00:23:59,500 --> 00:24:01,240
characters instead of the decimal value

567
00:24:01,240 --> 00:24:03,040
and you can do that you know in either

568
00:24:03,040 --> 00:24:04,180
direction if you wanted to look at them

569
00:24:04,180 --> 00:24:05,620
in decimal do it in decimal if you want

570
00:24:05,620 --> 00:24:06,790
to look at them as the character

571
00:24:06,790 --> 00:24:09,190
representation you can look at them as

572
00:24:09,190 --> 00:24:11,380
the character representation this is

573
00:24:11,380 --> 00:24:13,150
mainly useful to make things more

574
00:24:13,150 --> 00:24:14,950
readable and to make you know the code

575
00:24:14,950 --> 00:24:16,270
make a little more sense to you when

576
00:24:16,270 --> 00:24:19,540
you're looking at it so that is kind of

577
00:24:19,540 --> 00:24:21,310
a quick deidre tip for how to convert

578
00:24:21,310 --> 00:24:25,300
various data types and so we don't have

579
00:24:25,300 --> 00:24:26,830
an exercise for switch cases because

580
00:24:26,830 --> 00:24:28,300
you're gonna find a lot of these looping

581
00:24:28,300 --> 00:24:30,550
structures in these kind of comparison

582
00:24:30,550 --> 00:24:32,050
structures break down to look very

583
00:24:32,050 --> 00:24:34,540
similar in assembly language so the next

584
00:24:34,540 --> 00:24:35,830
thing that we're gonna talk about are

585
00:24:35,830 --> 00:24:39,720
loops and so loops are kind of day1

586
00:24:39,720 --> 00:24:42,130
programming right everyone has probably

587
00:24:42,130 --> 00:24:43,960
written you know for loop or a while

588
00:24:43,960 --> 00:24:46,960
loop etc but for those of you that maybe

589
00:24:46,960 --> 00:24:49,330
haven't loops allow for you know

590
00:24:49,330 --> 00:24:51,880
repeated execution of a certain block of

591
00:24:51,880 --> 00:24:53,470
code and again it's a very common

592
00:24:53,470 --> 00:24:55,270
programming structure and the statements

593
00:24:55,270 --> 00:24:57,730
in the loop are typically executed you

594
00:24:57,730 --> 00:25:00,130
know sequentially and you can see that

595
00:25:00,130 --> 00:25:01,720
represented an assembly language in a

596
00:25:01,720 --> 00:25:03,670
lot of ways there there's actually some

597
00:25:03,670 --> 00:25:06,340
x86 instructions that are built to you

598
00:25:06,340 --> 00:25:08,740
know loop and you can look those up in

599
00:25:08,740 --> 00:25:10,690
the manual loop and rep or two of those

600
00:25:10,690 --> 00:25:13,750
and loops you know typically operate

601
00:25:13,750 --> 00:25:15,700
under like a conditional code so it'll

602
00:25:15,700 --> 00:25:17,860
be you know for X less than this or a

603
00:25:17,860 --> 00:25:20,170
while you know some variable is not

604
00:25:20,170 --> 00:25:23,590
equal to some some value there are some

605
00:25:23,590 --> 00:25:25,120
exceptions when you're looking at you

606
00:25:25,120 --> 00:25:26,500
know embedded systems those of you that

607
00:25:26,500 --> 00:25:27,580
have written code for embedded systems

608
00:25:27,580 --> 00:25:29,740
most of the time the main function is

609
00:25:29,740 --> 00:25:32,710
surrounded by just a wild true loop so

610
00:25:32,710 --> 00:25:34,540
that it is always executing and that's

611
00:25:34,540 --> 00:25:36,790
sometimes done as a last-ditch effort to

612
00:25:36,790 --> 00:25:38,470
make things you know failsafe and to

613
00:25:38,470 --> 00:25:41,170
make sure the code is always running so

614
00:25:41,170 --> 00:25:43,210
you may sometimes see like a wild true

615
00:25:43,210 --> 00:25:44,920
when you're looking at a firmware blog

616
00:25:44,920 --> 00:25:49,150
or you know an embedded system so let's

617
00:25:49,150 --> 00:25:51,040
talk about loops let's go kind of from C

618
00:25:51,040 --> 00:25:53,020
to assembly so we have a very very

619
00:25:53,020 --> 00:25:54,820
similar structure to what we were

620
00:25:54,820 --> 00:25:56,530
looking at before we have the C code on

621
00:25:56,530 --> 00:25:58,360
the left and the assembly code on the

622
00:25:58,360 --> 00:26:01,180
right so the first thing that happens is

623
00:26:01,180 --> 00:26:03,670
we call you know our function to grab

624
00:26:03,670 --> 00:26:05,590
the

625
00:26:05,590 --> 00:26:07,419
integer representation of the first

626
00:26:07,419 --> 00:26:09,010
argument that's passed to the program

627
00:26:09,010 --> 00:26:12,000
and we're storing that on the stack at

628
00:26:12,000 --> 00:26:15,370
base pointer - hex for okay

629
00:26:15,370 --> 00:26:18,539
the next thing we're gonna do if we

630
00:26:18,539 --> 00:26:21,640
follow this code sequentially is we have

631
00:26:21,640 --> 00:26:23,380
another local variable called sum and

632
00:26:23,380 --> 00:26:28,360
we're storing that at - hex C and we're

633
00:26:28,360 --> 00:26:31,090
storing 0 into that just like we see in

634
00:26:31,090 --> 00:26:33,130
the C representation on the left side

635
00:26:33,130 --> 00:26:35,919
and then we have a variable X and just

636
00:26:35,919 --> 00:26:37,419
really quick right you'll notice X is

637
00:26:37,419 --> 00:26:39,490
used we declare it here and we also

638
00:26:39,490 --> 00:26:42,220
declare it again down here so with no

639
00:26:42,220 --> 00:26:44,440
optimizations turned on you'll see that

640
00:26:44,440 --> 00:26:46,450
we have you know 0 getting moved into

641
00:26:46,450 --> 00:26:49,840
our X variable which is at our BP - 8

642
00:26:49,840 --> 00:26:52,690
and then we have it again when we talk

643
00:26:52,690 --> 00:26:56,679
about the loop and so you're probably

644
00:26:56,679 --> 00:26:57,760
wondering if you're looking at this

645
00:26:57,760 --> 00:27:00,190
assembly right what this loop is doing

646
00:27:00,190 --> 00:27:06,730
is we are adding up for every value or

647
00:27:06,730 --> 00:27:09,940
for you know 0 to whatever value we add

648
00:27:09,940 --> 00:27:14,110
we increment some by our x value here as

649
00:27:14,110 --> 00:27:16,360
the loop continues so very simple very

650
00:27:16,360 --> 00:27:19,510
straightforward loop and so the next

651
00:27:19,510 --> 00:27:21,010
instruction right you notice we jump to

652
00:27:21,010 --> 00:27:24,789
65 and so why are we doing that we're

653
00:27:24,789 --> 00:27:28,330
doing that because at 65 you see we have

654
00:27:28,330 --> 00:27:32,580
this compare instruction right that is

655
00:27:32,580 --> 00:27:36,370
comparing our it moves our X variable in

656
00:27:36,370 --> 00:27:38,860
the eix right and then it compares it

657
00:27:38,860 --> 00:27:42,250
against our count variable right so

658
00:27:42,250 --> 00:27:44,799
here's our count variable which again we

659
00:27:44,799 --> 00:27:49,510
stored at our BP - 4 and X as we talked

660
00:27:49,510 --> 00:27:52,270
about before is it our BP minus 8 so at

661
00:27:52,270 --> 00:27:55,330
this point X is an AIX count is it our

662
00:27:55,330 --> 00:27:58,299
VP minus 4 and we are comparing those

663
00:27:58,299 --> 00:28:01,419
two just like we're doing here in the

664
00:28:01,419 --> 00:28:03,970
for loop and so if it's less than which

665
00:28:03,970 --> 00:28:06,220
means we're gonna continue to loop we

666
00:28:06,220 --> 00:28:08,049
jump back we jump to the start of the

667
00:28:08,049 --> 00:28:11,830
loop here and so the first thing we do

668
00:28:11,830 --> 00:28:15,340
here is again we grab our x value we

669
00:28:15,340 --> 00:28:18,440
store it in the EAX and then we

670
00:28:18,440 --> 00:28:22,159
add our x value which is now an EI x - r

671
00:28:22,159 --> 00:28:25,490
BP - hexie right and that is our some

672
00:28:25,490 --> 00:28:27,649
variable here right we talked about that

673
00:28:27,649 --> 00:28:28,190
before

674
00:28:28,190 --> 00:28:31,690
some was stored here on the stack and

675
00:28:31,690 --> 00:28:35,600
then we the last statement kind of in

676
00:28:35,600 --> 00:28:38,690
the loop structure here is we add one to

677
00:28:38,690 --> 00:28:42,200
again our X variable at our BP - hex

678
00:28:42,200 --> 00:28:45,620
eight and then we go we continue to go

679
00:28:45,620 --> 00:28:49,070
down and do this comparison so again we

680
00:28:49,070 --> 00:28:52,039
check we load X in the EI X then we

681
00:28:52,039 --> 00:28:53,539
compare it against our count variable

682
00:28:53,539 --> 00:28:55,549
and if it's still less we continue the

683
00:28:55,549 --> 00:29:00,350
loop and so this is kind of a fairly you

684
00:29:00,350 --> 00:29:03,080
know simple example of how a for loop

685
00:29:03,080 --> 00:29:05,120
goes from something that you write in C

686
00:29:05,120 --> 00:29:08,659
to an assembly structure and if you

687
00:29:08,659 --> 00:29:09,830
would look at this and graph you there

688
00:29:09,830 --> 00:29:11,600
would be an arrow that would loop around

689
00:29:11,600 --> 00:29:14,870
and point to that same block of code as

690
00:29:14,870 --> 00:29:19,309
the loop would continue and so another

691
00:29:19,309 --> 00:29:21,200
type of loop that you know you'll see

692
00:29:21,200 --> 00:29:23,360
and it's gonna look very similar from

693
00:29:23,360 --> 00:29:25,789
the assembly perspective is you know the

694
00:29:25,789 --> 00:29:27,679
while loop and you'll notice here that

695
00:29:27,679 --> 00:29:30,309
the differences between these two are

696
00:29:30,309 --> 00:29:33,799
there's not many right so you'll notice

697
00:29:33,799 --> 00:29:37,418
that there's not the additional

698
00:29:37,570 --> 00:29:40,100
assignment of X to zero because we're

699
00:29:40,100 --> 00:29:41,779
not doing that here but again the first

700
00:29:41,779 --> 00:29:43,429
thing it does is it jumps down and

701
00:29:43,429 --> 00:29:45,799
checks to make sure that X is less than

702
00:29:45,799 --> 00:29:49,220
count before continuing and then we do

703
00:29:49,220 --> 00:29:51,590
kind of the same exact loop that we had

704
00:29:51,590 --> 00:29:55,309
before so determining whether it's a

705
00:29:55,309 --> 00:29:56,539
while loop or a for loop may be

706
00:29:56,539 --> 00:29:57,919
important to you later on when you're

707
00:29:57,919 --> 00:29:59,360
looking at you know more advanced things

708
00:29:59,360 --> 00:30:01,009
but I just wanted to illustrate here

709
00:30:01,009 --> 00:30:02,269
that you know while these look

710
00:30:02,269 --> 00:30:04,309
differently in may behave slightly

711
00:30:04,309 --> 00:30:08,120
differently in you know see they the

712
00:30:08,120 --> 00:30:10,460
assembly representation is fairly

713
00:30:10,460 --> 00:30:13,490
similar and so when you're looking at

714
00:30:13,490 --> 00:30:15,259
you know big blocks of assembly where

715
00:30:15,259 --> 00:30:16,460
you're keeping track of you know we're

716
00:30:16,460 --> 00:30:18,200
keeping track of lots of little local

717
00:30:18,200 --> 00:30:20,600
variables here and it's kind of hard to

718
00:30:20,600 --> 00:30:22,490
without you know renaming them or

719
00:30:22,490 --> 00:30:24,409
labeling them to figure out where you

720
00:30:24,409 --> 00:30:26,840
are and so this is where kind of

721
00:30:26,840 --> 00:30:28,309
highlighting and slicing comments to

722
00:30:28,309 --> 00:30:31,429
play comes into play and this is really

723
00:30:31,429 --> 00:30:32,460
nice for if you had

724
00:30:32,460 --> 00:30:34,620
big loop and a variable was getting

725
00:30:34,620 --> 00:30:37,950
reused a lot you can use this to

726
00:30:37,950 --> 00:30:39,930
highlight a variable and see where it's

727
00:30:39,930 --> 00:30:41,730
used throughout the entire function and

728
00:30:41,730 --> 00:30:44,370
so you can apply this in the decompiler

729
00:30:44,370 --> 00:30:45,930
window and it will attempt to you know

730
00:30:45,930 --> 00:30:47,610
kind of synchronize the highlights

731
00:30:47,610 --> 00:30:49,890
between the disassembling the decompiler

732
00:30:49,890 --> 00:30:51,780
view and you know sometimes that works

733
00:30:51,780 --> 00:30:53,550
better than others but an example of

734
00:30:53,550 --> 00:30:57,960
what that might look like is this so you

735
00:30:57,960 --> 00:30:59,460
know here again this is kind of one of

736
00:30:59,460 --> 00:31:02,190
the this is an example this is one of

737
00:31:02,190 --> 00:31:04,080
the bonus exercises that we released

738
00:31:04,080 --> 00:31:06,270
last week that was pulled from cracking

739
00:31:06,270 --> 00:31:12,510
stop one and so we have this function

740
00:31:12,510 --> 00:31:15,810
and if you middle-click a specific

741
00:31:15,810 --> 00:31:17,280
variable so if we want to highlight

742
00:31:17,280 --> 00:31:18,960
string length and follow it all the way

743
00:31:18,960 --> 00:31:20,670
through we can just highlight it here

744
00:31:20,670 --> 00:31:22,710
and it will show us all the uses of it

745
00:31:22,710 --> 00:31:24,660
and you know this is nice when you're

746
00:31:24,660 --> 00:31:25,860
looking at larger functions or you're

747
00:31:25,860 --> 00:31:26,700
trying to keep track of multiple

748
00:31:26,700 --> 00:31:29,760
variables things like that and you can

749
00:31:29,760 --> 00:31:32,190
also highlight you know all uses of that

750
00:31:32,190 --> 00:31:34,680
variable moving forward so if you want

751
00:31:34,680 --> 00:31:37,500
to only see how a certain variable is

752
00:31:37,500 --> 00:31:39,480
used moving forward you can right click

753
00:31:39,480 --> 00:31:41,040
and do like highlight forward

754
00:31:41,040 --> 00:31:42,720
instructions slice or if you want to see

755
00:31:42,720 --> 00:31:44,610
no backwards you can do highlight

756
00:31:44,610 --> 00:31:47,160
backwards instruction slice and so

757
00:31:47,160 --> 00:31:48,870
here's an example of that as well you'll

758
00:31:48,870 --> 00:31:51,510
notice it didn't highlight the per my

759
00:31:51,510 --> 00:31:53,910
Mac so this is us keeping track of all

760
00:31:53,910 --> 00:31:57,000
the parameters here which is the first

761
00:31:57,000 --> 00:31:58,950
argument to our check serial function

762
00:31:58,950 --> 00:32:03,000
and so for you know loops and iterations

763
00:32:03,000 --> 00:32:05,790
we've got an exercise for you and this

764
00:32:05,790 --> 00:32:07,740
is going to be in session two exercises

765
00:32:07,740 --> 00:32:10,260
loop the example one and in addition to

766
00:32:10,260 --> 00:32:12,600
sort of solving for the the pass code as

767
00:32:12,600 --> 00:32:16,080
you're fairly used to do by now a couple

768
00:32:16,080 --> 00:32:18,540
of additional questions for you to sort

769
00:32:18,540 --> 00:32:20,190
of solidify your understanding of loops

770
00:32:20,190 --> 00:32:22,920
is you know how many times does run is

771
00:32:22,920 --> 00:32:24,540
it looking for anything in particular

772
00:32:24,540 --> 00:32:26,280
while it's looping through things and

773
00:32:26,280 --> 00:32:29,070
then can you generate you know the right

774
00:32:29,070 --> 00:32:32,280
and the right pass code here and so we

775
00:32:32,280 --> 00:32:33,840
can go over all these during the office

776
00:32:33,840 --> 00:32:36,540
hours if people want and we can also you

777
00:32:36,540 --> 00:32:38,250
know talk about them in chat on the

778
00:32:38,250 --> 00:32:41,040
class page as well

779
00:32:41,040 --> 00:32:43,680
and so you know we're talking about

780
00:32:43,680 --> 00:32:45,210
loops we're talking about variables

781
00:32:45,210 --> 00:32:46,590
that's something we haven't really

782
00:32:46,590 --> 00:32:48,510
covered yet and I wanted to talk about

783
00:32:48,510 --> 00:32:51,060
you know variable representation in

784
00:32:51,060 --> 00:32:53,460
assembly language and kind of how that

785
00:32:53,460 --> 00:32:57,390
translates from C to assembly so those

786
00:32:57,390 --> 00:32:59,550
of you that have you know written code

787
00:32:59,550 --> 00:33:01,500
before you know that when a variable is

788
00:33:01,500 --> 00:33:03,240
declared its declared within a

789
00:33:03,240 --> 00:33:04,860
particular scope which means that

790
00:33:04,860 --> 00:33:06,330
certain things have access to it certain

791
00:33:06,330 --> 00:33:09,060
things don't and so for our purposes

792
00:33:09,060 --> 00:33:11,100
we're gonna kind of talk about two the

793
00:33:11,100 --> 00:33:15,660
two big kind of blocks that variables

794
00:33:15,660 --> 00:33:17,850
can fall under so local and global so

795
00:33:17,850 --> 00:33:19,560
local variables are defined that a

796
00:33:19,560 --> 00:33:20,910
function they're typically only

797
00:33:20,910 --> 00:33:22,710
accessible within the function unless

798
00:33:22,710 --> 00:33:24,600
they are passed out you know by

799
00:33:24,600 --> 00:33:28,260
reference or by value rather and even

800
00:33:28,260 --> 00:33:30,240
then it's just the value not necessarily

801
00:33:30,240 --> 00:33:32,220
the actual variable so you know global

802
00:33:32,220 --> 00:33:33,720
variables are declared outside of a

803
00:33:33,720 --> 00:33:35,400
function they can be used across you

804
00:33:35,400 --> 00:33:37,170
know your entire program and these are

805
00:33:37,170 --> 00:33:39,150
both represented differently in assembly

806
00:33:39,150 --> 00:33:41,400
language and so we have an example here

807
00:33:41,400 --> 00:33:44,610
to sort of walk through you know what

808
00:33:44,610 --> 00:33:47,970
that looks like so you know here we've

809
00:33:47,970 --> 00:33:51,270
got again a fairly simple example of

810
00:33:51,270 --> 00:33:53,310
some C code we have a global variable of

811
00:33:53,310 --> 00:33:56,790
hex 15 we have two local variables we do

812
00:33:56,790 --> 00:33:58,890
some arithmetic on the local and global

813
00:33:58,890 --> 00:34:01,530
variables and then we exit and again the

814
00:34:01,530 --> 00:34:03,270
purpose of this is just to show you kind

815
00:34:03,270 --> 00:34:06,000
of what these constructs are actually

816
00:34:06,000 --> 00:34:07,740
gonna look like when you start looking

817
00:34:07,740 --> 00:34:09,480
at assembly and trying to work your way

818
00:34:09,480 --> 00:34:12,360
backwards so the you know first things

819
00:34:12,360 --> 00:34:16,050
first here we've got our function Prolog

820
00:34:16,050 --> 00:34:17,699
where we're kind of setting up the

821
00:34:17,699 --> 00:34:21,870
function we're storing both the argument

822
00:34:21,870 --> 00:34:23,340
count and the argument vector onto the

823
00:34:23,340 --> 00:34:25,730
stack and the next thing we're gonna do

824
00:34:25,730 --> 00:34:30,900
is declare our local variables and so we

825
00:34:30,900 --> 00:34:32,730
talked about the stack before and how

826
00:34:32,730 --> 00:34:34,860
the base pointer you know points to the

827
00:34:34,860 --> 00:34:36,870
bottom of the stack or the base of the

828
00:34:36,870 --> 00:34:40,168
stack right so at offset base pointer

829
00:34:40,168 --> 00:34:42,360
minus eight we're storing our local

830
00:34:42,360 --> 00:34:45,929
variable local bar and we're storing hex

831
00:34:45,929 --> 00:34:49,830
10 there and at minus four we're storing

832
00:34:49,830 --> 00:34:53,040
hex 11 which is local bar two so these

833
00:34:53,040 --> 00:34:54,540
two locations on the stack are going to

834
00:34:54,540 --> 00:34:55,050
be

835
00:34:55,050 --> 00:34:57,000
the placeholders for these variables

836
00:34:57,000 --> 00:34:58,650
these local variables that we talk about

837
00:34:58,650 --> 00:35:01,830
now we've also got this global variable

838
00:35:01,830 --> 00:35:04,200
which doesn't reside on the stack as we

839
00:35:04,200 --> 00:35:08,490
can see so if we look at the next

840
00:35:08,490 --> 00:35:11,190
statement with the global variable we

841
00:35:11,190 --> 00:35:13,200
see that we're grabbing something at an

842
00:35:13,200 --> 00:35:15,570
offset from our IP and that's because

843
00:35:15,570 --> 00:35:18,390
this global variable is stored in the

844
00:35:18,390 --> 00:35:21,660
data section of this elf file so we

845
00:35:21,660 --> 00:35:23,220
talked about how the elf file has like

846
00:35:23,220 --> 00:35:24,540
various sections and things like that

847
00:35:24,540 --> 00:35:26,730
one of those is used for you know

848
00:35:26,730 --> 00:35:29,580
storing global variables so the

849
00:35:29,580 --> 00:35:31,860
disassembler was able to read the elf

850
00:35:31,860 --> 00:35:34,350
file and see a symbol for the global var

851
00:35:34,350 --> 00:35:35,940
and know that it's gonna be at our IP

852
00:35:35,940 --> 00:35:38,670
Plus this value and it's going to point

853
00:35:38,670 --> 00:35:43,040
to our global variable so here we are

854
00:35:43,040 --> 00:35:47,450
moving our global variable global var

855
00:35:47,450 --> 00:35:53,820
into e DX we're moving our local var

856
00:35:53,820 --> 00:35:57,090
right which is an RVP - hex eight into

857
00:35:57,090 --> 00:36:00,870
EAX right and then we're adding the two

858
00:36:00,870 --> 00:36:03,720
which is what we can see what we can see

859
00:36:03,720 --> 00:36:08,810
down here right and so next we then take

860
00:36:08,810 --> 00:36:12,690
the value in EAX and we're storing that

861
00:36:12,690 --> 00:36:15,930
back into the location where the global

862
00:36:15,930 --> 00:36:19,340
variable lives and so our next statement

863
00:36:19,340 --> 00:36:22,410
and again as we talked about before it

864
00:36:22,410 --> 00:36:24,300
this is actually stored in the dot data

865
00:36:24,300 --> 00:36:27,720
section of the elf file and so you have

866
00:36:27,720 --> 00:36:29,010
this kind of mix of interacting with

867
00:36:29,010 --> 00:36:30,660
things on the stack and interacting with

868
00:36:30,660 --> 00:36:32,820
things in the data section and remember

869
00:36:32,820 --> 00:36:35,700
the elf file maps out where these things

870
00:36:35,700 --> 00:36:37,380
are gonna be loaded into Ram and so

871
00:36:37,380 --> 00:36:39,060
that's how the OS knows ok even though

872
00:36:39,060 --> 00:36:41,490
it's not on the stack I dunno

873
00:36:41,490 --> 00:36:42,960
you know relative to me where it's gonna

874
00:36:42,960 --> 00:36:50,420
be loaded and then so now right we have

875
00:36:50,420 --> 00:36:53,690
remember our excuse me

876
00:36:53,690 --> 00:36:57,030
local bar - right which was at our BP -

877
00:36:57,030 --> 00:37:02,700
for we are grabbing the global variable

878
00:37:02,700 --> 00:37:05,370
again from this offset storing it into

879
00:37:05,370 --> 00:37:06,000
EAX

880
00:37:06,000 --> 00:37:08,579
and then we're adding it to

881
00:37:08,579 --> 00:37:11,219
remember what was it our bp- for our

882
00:37:11,219 --> 00:37:15,509
local variable to write and so we are

883
00:37:15,509 --> 00:37:17,459
adding that to it and storing it back

884
00:37:17,459 --> 00:37:20,459
into that location and I know this is a

885
00:37:20,459 --> 00:37:22,529
lot to kind of keep track of with you

886
00:37:22,529 --> 00:37:24,809
know PowerPoint and I hope that this is

887
00:37:24,809 --> 00:37:26,880
able to illustrate these concepts in

888
00:37:26,880 --> 00:37:28,650
some way and if anybody has any

889
00:37:28,650 --> 00:37:29,880
questions about this we can definitely

890
00:37:29,880 --> 00:37:31,949
go over this more you know during the

891
00:37:31,949 --> 00:37:33,589
office hours around the course page and

892
00:37:33,589 --> 00:37:36,329
so the last thing that we do right is

893
00:37:36,329 --> 00:37:38,579
we're moving the value 0 into the

894
00:37:38,579 --> 00:37:40,920
location of our global variable and then

895
00:37:40,920 --> 00:37:42,420
we're setting our return code and

896
00:37:42,420 --> 00:37:45,630
exiting and so I know that was a lot but

897
00:37:45,630 --> 00:37:48,929
the two big takeaways are that local

898
00:37:48,929 --> 00:37:50,219
variables are going to be on the stack

899
00:37:50,219 --> 00:37:51,900
and then global variables are either

900
00:37:51,900 --> 00:37:53,640
going to be you know on the heap or on

901
00:37:53,640 --> 00:37:57,209
the in the data section and so when

902
00:37:57,209 --> 00:37:58,469
you're looking at all these variables

903
00:37:58,469 --> 00:38:00,390
right instead of you know remembering

904
00:38:00,390 --> 00:38:02,400
these offsets and things like that it's

905
00:38:02,400 --> 00:38:04,170
you know much easier to kind of label

906
00:38:04,170 --> 00:38:05,489
and rename these things to something

907
00:38:05,489 --> 00:38:07,019
that's a little more human readable and

908
00:38:07,019 --> 00:38:09,029
Diedre can do that for you so we'll talk

909
00:38:09,029 --> 00:38:12,199
about how you can do that

910
00:38:12,199 --> 00:38:15,779
so let's say you have a function like

911
00:38:15,779 --> 00:38:17,579
this and this is you know it's kind of

912
00:38:17,579 --> 00:38:19,349
tough to read right we haven't fixed up

913
00:38:19,349 --> 00:38:22,949
the we haven't fixed fixed up the

914
00:38:22,949 --> 00:38:24,989
function parameters yet we haven't

915
00:38:24,989 --> 00:38:26,670
renamed any of these variables this all

916
00:38:26,670 --> 00:38:29,219
is you know fairly difficult to read but

917
00:38:29,219 --> 00:38:30,869
if we wanted to say rename something

918
00:38:30,869 --> 00:38:33,749
like this if we look at this we can see

919
00:38:33,749 --> 00:38:36,359
that this variable is probably being

920
00:38:36,359 --> 00:38:40,529
used as a counter right because if we

921
00:38:40,529 --> 00:38:42,719
look at the bottom of this loop we see

922
00:38:42,719 --> 00:38:44,640
it being incremented by one it's checked

923
00:38:44,640 --> 00:38:46,769
against 8 and so instead of you know I

924
00:38:46,769 --> 00:38:49,319
stack 20 if we wanted to name that to

925
00:38:49,319 --> 00:38:50,880
something more human readable you can

926
00:38:50,880 --> 00:38:53,640
right click it and click rename variable

927
00:38:53,640 --> 00:38:55,979
and then a window will pop up asking you

928
00:38:55,979 --> 00:38:58,229
what you want to rename it as we will

929
00:38:58,229 --> 00:38:59,670
call it count so that's what it's being

930
00:38:59,670 --> 00:39:02,489
used for and then band that gets

931
00:39:02,489 --> 00:39:03,839
propagated kind of throughout the rest

932
00:39:03,839 --> 00:39:05,880
of the program and it just makes it a

933
00:39:05,880 --> 00:39:07,229
little more easy to understand it's

934
00:39:07,229 --> 00:39:08,910
easier to keep track of you know you

935
00:39:08,910 --> 00:39:10,979
don't because the default names will

936
00:39:10,979 --> 00:39:13,019
just be you know you VAR one you bar two

937
00:39:13,019 --> 00:39:15,989
you are 3 etc and so having these named

938
00:39:15,989 --> 00:39:18,239
makes it a little easier for you to sort

939
00:39:18,239 --> 00:39:20,009
of keep track of them as you go through

940
00:39:20,009 --> 00:39:21,880
some of these exercises

941
00:39:21,880 --> 00:39:26,020
and so for variables we have an exercise

942
00:39:26,020 --> 00:39:29,890
and exercises variables example and as

943
00:39:29,890 --> 00:39:31,840
you go through this and figure out what

944
00:39:31,840 --> 00:39:34,060
the password is think about and try to

945
00:39:34,060 --> 00:39:35,380
determine you know how many global

946
00:39:35,380 --> 00:39:37,360
variables are being used how many local

947
00:39:37,360 --> 00:39:39,640
variables are being used and can you

948
00:39:39,640 --> 00:39:42,870
solve for you know the proper key code

949
00:39:42,870 --> 00:39:46,240
and so you know we have we've talked

950
00:39:46,240 --> 00:39:48,760
about control flow we've talked about

951
00:39:48,760 --> 00:39:50,620
variables we've talked about things like

952
00:39:50,620 --> 00:39:51,790
that and you can't really get in a

953
00:39:51,790 --> 00:39:53,290
control flow without talking about

954
00:39:53,290 --> 00:39:57,480
function calls and so functions in C are

955
00:39:57,480 --> 00:39:59,920
implemented using the call instruction

956
00:39:59,920 --> 00:40:02,140
of assembly and what that does is it

957
00:40:02,140 --> 00:40:04,420
pushes the return address to the stack

958
00:40:04,420 --> 00:40:08,170
and then jumps to the address that it is

959
00:40:08,170 --> 00:40:12,490
used as an argument and when you issue

960
00:40:12,490 --> 00:40:15,220
the call instruction the first six

961
00:40:15,220 --> 00:40:16,960
parameters are passed in through

962
00:40:16,960 --> 00:40:19,300
registers so when you are analyzing a

963
00:40:19,300 --> 00:40:20,770
function and you see a pull something

964
00:40:20,770 --> 00:40:23,320
from our dir si RDX those are the

965
00:40:23,320 --> 00:40:26,080
arguments that it's loading and so these

966
00:40:26,080 --> 00:40:29,200
are all again defined by the ABI that we

967
00:40:29,200 --> 00:40:31,900
talked about before and so call is used

968
00:40:31,900 --> 00:40:34,390
to jump to a function and then ret is

969
00:40:34,390 --> 00:40:36,730
used to return from it and what the RET

970
00:40:36,730 --> 00:40:39,010
instruction does is it actually pops the

971
00:40:39,010 --> 00:40:41,020
address off the stack and it assumes

972
00:40:41,020 --> 00:40:44,500
that you're now pointing to the address

973
00:40:44,500 --> 00:40:46,900
that call push there and then you jump

974
00:40:46,900 --> 00:40:49,450
back and you store that into our IP and

975
00:40:49,450 --> 00:40:53,650
so that's kind of a tough thing to you

976
00:40:53,650 --> 00:40:55,270
know strictly relay verbally so let's

977
00:40:55,270 --> 00:40:56,800
talk about what a function call would

978
00:40:56,800 --> 00:40:58,750
look like from someone calling the

979
00:40:58,750 --> 00:41:00,190
function so what do you need to do if

980
00:41:00,190 --> 00:41:02,320
you're gonna call a function in assembly

981
00:41:02,320 --> 00:41:05,140
language and what does that look like so

982
00:41:05,140 --> 00:41:06,580
we've got our stack here on the right

983
00:41:06,580 --> 00:41:08,020
now remember the stack grows from high

984
00:41:08,020 --> 00:41:10,150
to low and we have our main function

985
00:41:10,150 --> 00:41:11,860
here so the first thing that we're gonna

986
00:41:11,860 --> 00:41:14,820
do we push our BP onto the stack and now

987
00:41:14,820 --> 00:41:17,890
we point our BP and our SP to the same

988
00:41:17,890 --> 00:41:20,350
thing so we've moved our SP value into

989
00:41:20,350 --> 00:41:23,850
our BP and so this is now you know mains

990
00:41:23,850 --> 00:41:28,210
stack frame right the next thing that we

991
00:41:28,210 --> 00:41:30,790
do is we subtract 10 from our SP which

992
00:41:30,790 --> 00:41:33,310
now means that our SP points too will

993
00:41:33,310 --> 00:41:35,350
call you know the

994
00:41:35,350 --> 00:41:38,620
the stack here and the next thing that

995
00:41:38,620 --> 00:41:41,140
we do is we're loading some variables

996
00:41:41,140 --> 00:41:42,940
onto the stack so what are we doing

997
00:41:42,940 --> 00:41:43,630
we're moving

998
00:41:43,630 --> 00:41:47,200
EDI onto the stack right because we're

999
00:41:47,200 --> 00:41:51,190
doing our BP minus 4 which is gonna be

1000
00:41:51,190 --> 00:41:52,900
here because remember this grows from

1001
00:41:52,900 --> 00:41:55,840
high to low and then next we move RSI

1002
00:41:55,840 --> 00:42:00,250
onto the stack and then we are moving

1003
00:42:00,250 --> 00:42:04,810
hex F into EDI and then we're calling a

1004
00:42:04,810 --> 00:42:07,420
function okay so what we're doing here

1005
00:42:07,420 --> 00:42:10,840
when we call this function is we push

1006
00:42:10,840 --> 00:42:14,320
the next address onto the stack and then

1007
00:42:14,320 --> 00:42:19,060
jump to this code okay and so when we

1008
00:42:19,060 --> 00:42:24,340
jump to this function it's gonna return

1009
00:42:24,340 --> 00:42:26,230
by issuing you know a ret instruction

1010
00:42:26,230 --> 00:42:30,730
and it's going to use the EDI value

1011
00:42:30,730 --> 00:42:33,010
which is passed through the register as

1012
00:42:33,010 --> 00:42:34,330
an argument

1013
00:42:34,330 --> 00:42:35,830
so arguments are passed through

1014
00:42:35,830 --> 00:42:38,530
registers and in order to do that what

1015
00:42:38,530 --> 00:42:40,210
the main function had to do here was

1016
00:42:40,210 --> 00:42:42,550
store its EDI value onto the stack

1017
00:42:42,550 --> 00:42:44,890
before it jumped so it knew okay I'm

1018
00:42:44,890 --> 00:42:48,040
gonna I have to feed you know hex F to

1019
00:42:48,040 --> 00:42:49,510
this function this is what I'm gonna

1020
00:42:49,510 --> 00:42:52,870
call it with I need to save my eval you

1021
00:42:52,870 --> 00:42:55,990
before I call it and so this falls on

1022
00:42:55,990 --> 00:42:59,680
you know the responsibility of the code

1023
00:42:59,680 --> 00:43:01,480
calling the function they need to store

1024
00:43:01,480 --> 00:43:02,950
their state before they call the

1025
00:43:02,950 --> 00:43:04,270
function they have to store the state

1026
00:43:04,270 --> 00:43:06,160
and set up the registers appropriately

1027
00:43:06,160 --> 00:43:09,340
and so you know where's all this defined

1028
00:43:09,340 --> 00:43:11,680
this again is kind of it's defined in

1029
00:43:11,680 --> 00:43:13,870
the calling conventions that are defined

1030
00:43:13,870 --> 00:43:18,010
in the you know system V ABI and it's

1031
00:43:18,010 --> 00:43:19,630
gonna define you know how you pass

1032
00:43:19,630 --> 00:43:22,090
arguments how you return values and how

1033
00:43:22,090 --> 00:43:24,190
the stack is managed and how registers

1034
00:43:24,190 --> 00:43:26,890
need to be cleaned up and this calling

1035
00:43:26,890 --> 00:43:28,900
convention defines you know like the

1036
00:43:28,900 --> 00:43:30,940
epilogue and the prologue for functions

1037
00:43:30,940 --> 00:43:32,860
so it defines you know what you need to

1038
00:43:32,860 --> 00:43:34,270
do when you enter a function and what

1039
00:43:34,270 --> 00:43:37,420
you need to do before you leave and so

1040
00:43:37,420 --> 00:43:40,060
you can refer to that document for you

1041
00:43:40,060 --> 00:43:42,670
know a much more detailed description of

1042
00:43:42,670 --> 00:43:44,440
what to do and what those things will

1043
00:43:44,440 --> 00:43:45,910
look like and we can post links to that

1044
00:43:45,910 --> 00:43:48,890
on the course page as well but really

1045
00:43:48,890 --> 00:43:50,240
the cool thing is that the prologue

1046
00:43:50,240 --> 00:43:51,950
reserves the space for variables on the

1047
00:43:51,950 --> 00:43:53,450
stack and then the epilogue cleans it up

1048
00:43:53,450 --> 00:43:55,570
and returns it to its original state and

1049
00:43:55,570 --> 00:43:59,360
so again what that might look like it

1050
00:43:59,360 --> 00:44:02,030
going from C to assembly is we have our

1051
00:44:02,030 --> 00:44:04,940
function here we are where we have you

1052
00:44:04,940 --> 00:44:06,920
know two local variables some variable

1053
00:44:06,920 --> 00:44:09,770
and we're just gonna add the value that

1054
00:44:09,770 --> 00:44:12,350
we pass to this function to sum and

1055
00:44:12,350 --> 00:44:13,790
we're gonna add the local variable to

1056
00:44:13,790 --> 00:44:14,840
sell okay

1057
00:44:14,840 --> 00:44:17,840
so we're actually not even using a local

1058
00:44:17,840 --> 00:44:19,580
bar - it's just here to kind of

1059
00:44:19,580 --> 00:44:22,490
demonstrate a point you know as to like

1060
00:44:22,490 --> 00:44:25,070
where local variables get put on the

1061
00:44:25,070 --> 00:44:28,100
stack so again we have the initial

1062
00:44:28,100 --> 00:44:29,420
function set up where we set up our

1063
00:44:29,420 --> 00:44:31,970
stack pointer we push our BP onto the

1064
00:44:31,970 --> 00:44:33,500
stack and then like we did in the

1065
00:44:33,500 --> 00:44:35,180
previous one we set our stack pointer

1066
00:44:35,180 --> 00:44:38,210
equal to RB P so now we have like a

1067
00:44:38,210 --> 00:44:40,520
fresh new you know untouched region of

1068
00:44:40,520 --> 00:44:44,180
memory to work with and so the first

1069
00:44:44,180 --> 00:44:46,520
thing we're doing is we are taking the

1070
00:44:46,520 --> 00:44:49,280
EDI value right which is the argument

1071
00:44:49,280 --> 00:44:50,780
that's passed to the function that's

1072
00:44:50,780 --> 00:44:53,420
stored in EDI so this in our case is

1073
00:44:53,420 --> 00:44:56,150
gonna be our x value right and that's

1074
00:44:56,150 --> 00:44:58,580
gonna go on the stack at our VP minus X

1075
00:44:58,580 --> 00:45:06,650
14 next we are going to load 10 into our

1076
00:45:06,650 --> 00:45:09,910
first local variable local bar right and

1077
00:45:09,910 --> 00:45:12,530
then following that as you would imagine

1078
00:45:12,530 --> 00:45:15,620
we're gonna load 14 into our VP minus 8

1079
00:45:15,620 --> 00:45:19,130
and then some which is gonna be at our

1080
00:45:19,130 --> 00:45:23,390
BP minus 4 we're loading 0 into and so

1081
00:45:23,390 --> 00:45:25,850
here right remember what was at our BP

1082
00:45:25,850 --> 00:45:28,910
minus 14 the EDI value that we were

1083
00:45:28,910 --> 00:45:32,360
passed to or was passed to us when the

1084
00:45:32,360 --> 00:45:34,100
function got called so again EDI

1085
00:45:34,100 --> 00:45:36,230
contains the argument to our function

1086
00:45:36,230 --> 00:45:40,220
and we're moving that into EAX and then

1087
00:45:40,220 --> 00:45:42,080
we're adding it to some right remember

1088
00:45:42,080 --> 00:45:44,060
we talked about some is stored at our VP

1089
00:45:44,060 --> 00:45:46,610
minus 4 and we're adding our EI x value

1090
00:45:46,610 --> 00:45:49,070
or the EI x value here which now

1091
00:45:49,070 --> 00:45:50,780
contains the argument to this function

1092
00:45:50,780 --> 00:45:56,330
and so next we're grabbing that local

1093
00:45:56,330 --> 00:45:58,550
variable here and storing it into EAX

1094
00:45:58,550 --> 00:46:02,450
right and then we are adding to the

1095
00:46:02,450 --> 00:46:06,049
some variable which again at our bp- for

1096
00:46:06,049 --> 00:46:08,089
we're adding this value to it and

1097
00:46:08,089 --> 00:46:10,430
storing it back into some and then

1098
00:46:10,430 --> 00:46:13,819
before we exit we restore the base

1099
00:46:13,819 --> 00:46:17,059
pointer and then we ret so we grab the

1100
00:46:17,059 --> 00:46:19,160
next address off we grab the address

1101
00:46:19,160 --> 00:46:21,680
that was pushed to the stack when we

1102
00:46:21,680 --> 00:46:24,440
issued the call statement and we jump to

1103
00:46:24,440 --> 00:46:28,250
that and resume execution and so when

1104
00:46:28,250 --> 00:46:30,819
you're working with functions in Dedra

1105
00:46:30,819 --> 00:46:33,170
it can be difficult too if you want to

1106
00:46:33,170 --> 00:46:35,480
maybe compare two functions or you want

1107
00:46:35,480 --> 00:46:37,400
to get you know maybe a new version of a

1108
00:46:37,400 --> 00:46:38,720
program came out that you're looking at

1109
00:46:38,720 --> 00:46:40,339
and you want to compare those two you

1110
00:46:40,339 --> 00:46:42,020
can do that because Gaeta has a function

1111
00:46:42,020 --> 00:46:43,640
comparison window and this is super

1112
00:46:43,640 --> 00:46:45,079
useful when doing you know side-by-side

1113
00:46:45,079 --> 00:46:47,660
comparisons of functions and you can do

1114
00:46:47,660 --> 00:46:49,640
it such that it will compare both the

1115
00:46:49,640 --> 00:46:51,920
listing the assembly listing and the B

1116
00:46:51,920 --> 00:46:54,829
compiler view and so to do that you

1117
00:46:54,829 --> 00:46:56,390
highlight two functions you right-click

1118
00:46:56,390 --> 00:46:58,910
compare selected functions so let's talk

1119
00:46:58,910 --> 00:47:00,200
about what that would look like in the

1120
00:47:00,200 --> 00:47:05,960
deidre listing so we've got you know two

1121
00:47:05,960 --> 00:47:07,579
functions here and obviously these

1122
00:47:07,579 --> 00:47:08,660
functions are very different this is

1123
00:47:08,660 --> 00:47:11,450
just to demonstrate the capability so we

1124
00:47:11,450 --> 00:47:12,859
highlight you know start in this

1125
00:47:12,859 --> 00:47:16,640
deregister team clones and click compare

1126
00:47:16,640 --> 00:47:18,559
functions and so here you know we can

1127
00:47:18,559 --> 00:47:20,240
obviously see these functions are very

1128
00:47:20,240 --> 00:47:22,520
different and you know these differences

1129
00:47:22,520 --> 00:47:26,690
are highlighted here too so the I just

1130
00:47:26,690 --> 00:47:28,490
wanted to show this as something that

1131
00:47:28,490 --> 00:47:29,569
you might find useful if you're ever

1132
00:47:29,569 --> 00:47:31,700
comparing two functions it's a pretty

1133
00:47:31,700 --> 00:47:34,309
useful component that guitro has to

1134
00:47:34,309 --> 00:47:38,420
offer and so for functions we have an

1135
00:47:38,420 --> 00:47:42,230
example in the exercises and in addition

1136
00:47:42,230 --> 00:47:44,540
again to kind of solving for the

1137
00:47:44,540 --> 00:47:46,190
password and trying to crack the

1138
00:47:46,190 --> 00:47:49,099
password can you also figure out how

1139
00:47:49,099 --> 00:47:50,839
many functions does the regular auto

1140
00:47:50,839 --> 00:47:52,819
analysis discover and within those

1141
00:47:52,819 --> 00:47:54,829
functions how many local variables are

1142
00:47:54,829 --> 00:47:57,049
present and what are their values so

1143
00:47:57,049 --> 00:47:58,579
this kind of builds off of the other

1144
00:47:58,579 --> 00:48:00,020
things that we've learned and talked

1145
00:48:00,020 --> 00:48:02,720
about through this lesson and do any of

1146
00:48:02,720 --> 00:48:04,369
these functions take any arguments if so

1147
00:48:04,369 --> 00:48:07,150
you know what are they

1148
00:48:07,840 --> 00:48:10,270
and so you know we've talked about local

1149
00:48:10,270 --> 00:48:11,860
variables we've talked about stack

1150
00:48:11,860 --> 00:48:13,570
memory and the next thing we kind of

1151
00:48:13,570 --> 00:48:15,370
have on our list to talk about is is

1152
00:48:15,370 --> 00:48:17,500
heat memory which is used for you know

1153
00:48:17,500 --> 00:48:19,510
those of you that have used you know

1154
00:48:19,510 --> 00:48:21,250
malloc and calloc before aware that it's

1155
00:48:21,250 --> 00:48:23,110
used for dynamic memory allocations and

1156
00:48:23,110 --> 00:48:26,380
so heat memory typically in our

1157
00:48:26,380 --> 00:48:27,970
environment that we're working and isn't

1158
00:48:27,970 --> 00:48:29,860
managed automatically so developers have

1159
00:48:29,860 --> 00:48:32,170
to manage it you have to free it when

1160
00:48:32,170 --> 00:48:34,120
you're done with it and failure to do so

1161
00:48:34,120 --> 00:48:35,710
can result in memory leaks and failure

1162
00:48:35,710 --> 00:48:37,990
to properly you know manage your code

1163
00:48:37,990 --> 00:48:39,190
that you allocate on the heat can also

1164
00:48:39,190 --> 00:48:41,350
heap can also lead to other kinds of

1165
00:48:41,350 --> 00:48:43,450
vulnerabilities as well but heat

1166
00:48:43,450 --> 00:48:44,800
variables can be accessed

1167
00:48:44,800 --> 00:48:47,260
you know globally really bypassing the

1168
00:48:47,260 --> 00:48:49,090
point or to the thing that was allocated

1169
00:48:49,090 --> 00:48:52,660
on the heat and so just to kind of talk

1170
00:48:52,660 --> 00:48:54,610
about you know stack versus heap the

1171
00:48:54,610 --> 00:48:56,290
stack is kind of managed for us for the

1172
00:48:56,290 --> 00:48:57,910
most part there's not really an ET no

1173
00:48:57,910 --> 00:48:59,320
deallocate unless you're hand rolling

1174
00:48:59,320 --> 00:49:01,660
assembly it's limited you know by stack

1175
00:49:01,660 --> 00:49:03,610
size which is always dependent you've

1176
00:49:03,610 --> 00:49:05,470
got sort of statically sized variables

1177
00:49:05,470 --> 00:49:08,140
whereas the heap you know there's within

1178
00:49:08,140 --> 00:49:09,310
reason and within the amount of memory

1179
00:49:09,310 --> 00:49:10,540
that you have in the virtual address

1180
00:49:10,540 --> 00:49:11,800
space that you have there's not really a

1181
00:49:11,800 --> 00:49:13,690
huge limit on size and it has to be

1182
00:49:13,690 --> 00:49:17,230
managed by the user and to kind of

1183
00:49:17,230 --> 00:49:20,430
illustrate what this looks like as

1184
00:49:20,430 --> 00:49:22,840
opposed to what we've looked at before

1185
00:49:22,840 --> 00:49:26,110
we have an exercise in the exercises

1186
00:49:26,110 --> 00:49:28,180
folder called you know heap example one

1187
00:49:28,180 --> 00:49:30,940
and this one is it's not a very complex

1188
00:49:30,940 --> 00:49:32,800
exercise it's just to show you kind of

1189
00:49:32,800 --> 00:49:36,730
what the calls to malloc look like from

1190
00:49:36,730 --> 00:49:38,920
you know an assembly representation and

1191
00:49:38,920 --> 00:49:41,080
so when you're looking at this it's

1192
00:49:41,080 --> 00:49:43,930
gonna be very similar to example so you

1193
00:49:43,930 --> 00:49:45,580
know a couple additional questions as

1194
00:49:45,580 --> 00:49:47,680
you go through and solve this are you

1195
00:49:47,680 --> 00:49:49,180
know how is how much memory are we

1196
00:49:49,180 --> 00:49:51,820
allocating and how is this different

1197
00:49:51,820 --> 00:49:54,850
than the loop example and so that was

1198
00:49:54,850 --> 00:49:56,080
kind of a quick overview on heap memory

1199
00:49:56,080 --> 00:49:57,820
we'll get into it more in later sessions

1200
00:49:57,820 --> 00:49:59,500
I just wanted to touch on it so that

1201
00:49:59,500 --> 00:50:02,500
everyone is aware of what it is and we

1202
00:50:02,500 --> 00:50:04,030
have a very simple exercise for that

1203
00:50:04,030 --> 00:50:05,680
that as I said before it's very similar

1204
00:50:05,680 --> 00:50:07,720
to the loop example it shouldn't really

1205
00:50:07,720 --> 00:50:09,160
give you too much trouble once you solve

1206
00:50:09,160 --> 00:50:13,240
for the loop example and so kind of the

1207
00:50:13,240 --> 00:50:15,670
last C construct we're going to talk

1208
00:50:15,670 --> 00:50:17,710
about and I are you know array accesses

1209
00:50:17,710 --> 00:50:21,160
and when you act when you see accesses

1210
00:50:21,160 --> 00:50:21,460
of a

1211
00:50:21,460 --> 00:50:23,140
ray we're gonna see an instruction that

1212
00:50:23,140 --> 00:50:25,330
we haven't talked about yet and that's

1213
00:50:25,330 --> 00:50:27,339
the load effective address instruction

1214
00:50:27,339 --> 00:50:29,380
and so remember in the previous one we

1215
00:50:29,380 --> 00:50:31,900
talked about how when there are you know

1216
00:50:31,900 --> 00:50:34,359
brackets around an argument the the

1217
00:50:34,359 --> 00:50:38,730
calculation is performed on those those

1218
00:50:38,730 --> 00:50:41,950
arguments and then the memory is fetched

1219
00:50:41,950 --> 00:50:44,170
at that address and that is the case for

1220
00:50:44,170 --> 00:50:46,060
the move instruction but for the load

1221
00:50:46,060 --> 00:50:47,920
effective address instruction we

1222
00:50:47,920 --> 00:50:49,780
actually just calculate this value and

1223
00:50:49,780 --> 00:50:52,420
store it into EAX so we're loading this

1224
00:50:52,420 --> 00:50:54,490
calculated address with this calculated

1225
00:50:54,490 --> 00:50:57,190
value into EAX without actually

1226
00:50:57,190 --> 00:51:01,150
dereferencing memory and so what this

1227
00:51:01,150 --> 00:51:03,570
looks like from a see to assembly

1228
00:51:03,570 --> 00:51:07,210
representation is as follows so here

1229
00:51:07,210 --> 00:51:09,369
again we've got our standard function

1230
00:51:09,369 --> 00:51:11,230
Prolog we're setting everything up we're

1231
00:51:11,230 --> 00:51:14,369
grabbing the Arg C RV

1232
00:51:14,369 --> 00:51:17,920
we've got X which we're setting to 0

1233
00:51:17,920 --> 00:51:22,359
here then of course we have this jump

1234
00:51:22,359 --> 00:51:25,060
where we go down and check if X is less

1235
00:51:25,060 --> 00:51:27,250
than 10 right so see we're comparing X

1236
00:51:27,250 --> 00:51:29,560
which is at our BP minus 4 to 9 if it's

1237
00:51:29,560 --> 00:51:31,690
less than we jump back and go through to

1238
00:51:31,690 --> 00:51:35,560
here and then so next we jump through

1239
00:51:35,560 --> 00:51:40,589
and we grab X and store it into EAX and

1240
00:51:40,589 --> 00:51:43,599
this the next instruction like sign

1241
00:51:43,599 --> 00:51:48,099
extends XC d QE and so here we're

1242
00:51:48,099 --> 00:51:50,589
loading the effective address of you

1243
00:51:50,589 --> 00:51:52,780
know what X is in the re X so we're

1244
00:51:52,780 --> 00:51:56,859
taking you know our our x value times 4

1245
00:51:56,859 --> 00:51:59,500
and we're using that and we're taking

1246
00:51:59,500 --> 00:52:04,359
that and loading it into our CX now here

1247
00:52:04,359 --> 00:52:05,770
right you'll notice that we have another

1248
00:52:05,770 --> 00:52:10,380
global variable which is our nums and

1249
00:52:10,380 --> 00:52:13,690
we're grabbing our x value right

1250
00:52:13,690 --> 00:52:15,970
remember at our BP - for storing that

1251
00:52:15,970 --> 00:52:17,020
into edx

1252
00:52:17,020 --> 00:52:21,310
and then finally we are storing that

1253
00:52:21,310 --> 00:52:24,790
value at our ax which is the address of

1254
00:52:24,790 --> 00:52:28,000
our variable plus the RCX offset which

1255
00:52:28,000 --> 00:52:31,869
is calculated here and then we're

1256
00:52:31,869 --> 00:52:34,770
storing edx into that

1257
00:52:34,770 --> 00:52:37,470
and so this is how we are indexing into

1258
00:52:37,470 --> 00:52:41,580
that array so the reason X is being

1259
00:52:41,580 --> 00:52:44,720
multiplied by four is because it is a

1260
00:52:44,720 --> 00:52:47,430
it's an index into an array of integers

1261
00:52:47,430 --> 00:52:49,410
so that are gonna be you know in this

1262
00:52:49,410 --> 00:52:53,370
case these ones are four bytes and so

1263
00:52:53,370 --> 00:52:56,970
here we increment X compare it to nine

1264
00:52:56,970 --> 00:53:00,570
and if it's once we get to the point

1265
00:53:00,570 --> 00:53:04,080
where this comparison fails we exit the

1266
00:53:04,080 --> 00:53:05,970
function and so this is kind of how the

1267
00:53:05,970 --> 00:53:07,800
le.a instruction is used to calculate

1268
00:53:07,800 --> 00:53:15,270
offsets in arrays and so with deidre you

1269
00:53:15,270 --> 00:53:18,420
can create arrays and if Geezer doesn't

1270
00:53:18,420 --> 00:53:19,890
automatically detect them if the types

1271
00:53:19,890 --> 00:53:23,100
are not properly set in the D compiler

1272
00:53:23,100 --> 00:53:24,660
you can go through and create an array

1273
00:53:24,660 --> 00:53:27,750
and so let's say we have this function

1274
00:53:27,750 --> 00:53:29,430
call here where we're printing something

1275
00:53:29,430 --> 00:53:31,110
and you can see that we're do you

1276
00:53:31,110 --> 00:53:32,550
referencing something with an offset

1277
00:53:32,550 --> 00:53:34,920
that is used in the loop x course

1278
00:53:34,920 --> 00:53:36,330
there's a good chance that this is an

1279
00:53:36,330 --> 00:53:38,730
array right so if we double click on

1280
00:53:38,730 --> 00:53:41,580
this to jump to that location we see

1281
00:53:41,580 --> 00:53:43,560
here okay we have a list of you know

1282
00:53:43,560 --> 00:53:45,660
values here and we can see that it's X

1283
00:53:45,660 --> 00:53:48,270
raft it's read from where we were

1284
00:53:48,270 --> 00:53:50,670
previously in the function now to create

1285
00:53:50,670 --> 00:53:52,170
an array first you have to identify you

1286
00:53:52,170 --> 00:53:53,820
know the datatype of what we think the

1287
00:53:53,820 --> 00:53:56,790
array is and so here it looks like you

1288
00:53:56,790 --> 00:53:59,220
know it's an unsigned integer and so if

1289
00:53:59,220 --> 00:54:01,620
we go here and we right click and click

1290
00:54:01,620 --> 00:54:03,840
data and create we create an unsigned

1291
00:54:03,840 --> 00:54:06,240
integer so we go to data and then you

1292
00:54:06,240 --> 00:54:10,950
nth and once we've done that once we can

1293
00:54:10,950 --> 00:54:13,560
go through and create an array and so if

1294
00:54:13,560 --> 00:54:15,510
we look back this code right it's

1295
00:54:15,510 --> 00:54:17,700
counting ten times so we can probably

1296
00:54:17,700 --> 00:54:19,260
assume there's ten elements in this

1297
00:54:19,260 --> 00:54:21,600
array and so we go through we create the

1298
00:54:21,600 --> 00:54:22,710
unsigned integer and now we're gonna

1299
00:54:22,710 --> 00:54:24,440
tell it hey there's actually an array of

1300
00:54:24,440 --> 00:54:28,350
ten unsigned integers here and so you

1301
00:54:28,350 --> 00:54:30,960
just click create array tell it how many

1302
00:54:30,960 --> 00:54:32,580
elements are gonna be there and it will

1303
00:54:32,580 --> 00:54:33,930
try to give you an estimate of what it

1304
00:54:33,930 --> 00:54:34,800
thinks should be there without

1305
00:54:34,800 --> 00:54:36,870
overwriting any existing data which is a

1306
00:54:36,870 --> 00:54:40,920
nice feature and then once you click OK

1307
00:54:40,920 --> 00:54:43,760
you'll see here we have our array of

1308
00:54:43,760 --> 00:54:46,760
integers

1309
00:54:47,250 --> 00:54:49,440
and this just makes the code you know

1310
00:54:49,440 --> 00:54:50,910
much more readable right so we have our

1311
00:54:50,910 --> 00:54:53,490
our array of unsigned integers here with

1312
00:54:53,490 --> 00:54:56,790
the index and that's slightly more

1313
00:54:56,790 --> 00:54:58,740
readable than what we had before because

1314
00:54:58,740 --> 00:55:00,330
we were able to use geat ria to define

1315
00:55:00,330 --> 00:55:05,520
you know this array structure and so for

1316
00:55:05,520 --> 00:55:08,250
this exercise we have an example as well

1317
00:55:08,250 --> 00:55:10,250
it's called you know array example and

1318
00:55:10,250 --> 00:55:12,450
when you're going through this and

1319
00:55:12,450 --> 00:55:16,140
trying to figure out what the pass code

1320
00:55:16,140 --> 00:55:18,240
is for the various indexes you can pass

1321
00:55:18,240 --> 00:55:20,580
into the program what are the scope of

1322
00:55:20,580 --> 00:55:22,830
these arrays are they global how many of

1323
00:55:22,830 --> 00:55:24,810
these are in use can you reconstruct

1324
00:55:24,810 --> 00:55:27,780
them in Ghidorah using the various

1325
00:55:27,780 --> 00:55:30,930
things that we've learned today and so

1326
00:55:30,930 --> 00:55:33,690
finally to wrap up right on time today

1327
00:55:33,690 --> 00:55:36,930
we've reviewed how to identify various c

1328
00:55:36,930 --> 00:55:38,940
constructs in c and i know a lot of

1329
00:55:38,940 --> 00:55:40,050
people have talked with me about you

1330
00:55:40,050 --> 00:55:41,670
know it's it feels really great to use

1331
00:55:41,670 --> 00:55:42,990
the d compiler and they're they're

1332
00:55:42,990 --> 00:55:44,610
leaning heavily on the d compiler or

1333
00:55:44,610 --> 00:55:46,080
solve the exercises and that's that's

1334
00:55:46,080 --> 00:55:46,560
great

1335
00:55:46,560 --> 00:55:48,960
and it's important to understand though

1336
00:55:48,960 --> 00:55:51,000
that the D compiler isn't always a

1337
00:55:51,000 --> 00:55:53,310
hundred percent perfect so sometimes you

1338
00:55:53,310 --> 00:55:55,350
have to you know look at the assembly

1339
00:55:55,350 --> 00:55:58,500
side and infer things from that to sort

1340
00:55:58,500 --> 00:56:03,090
of fix up the D compiler and by doing

1341
00:56:03,090 --> 00:56:06,180
that you can kind of cover more options

1342
00:56:06,180 --> 00:56:07,770
than if you're just solely looking at

1343
00:56:07,770 --> 00:56:09,480
the B compiler again the d compiler is

1344
00:56:09,480 --> 00:56:12,230
excellent but sometimes knowing how to

1345
00:56:12,230 --> 00:56:14,910
sort of manipulate the data types and

1346
00:56:14,910 --> 00:56:17,040
Diedre allows you to kind of streamline

1347
00:56:17,040 --> 00:56:18,750
the reversing process a little more and

1348
00:56:18,750 --> 00:56:20,640
make things a little I won't say easier

1349
00:56:20,640 --> 00:56:22,800
but easier to read and kind of easier to

1350
00:56:22,800 --> 00:56:26,550
understand and so that's why for each of

1351
00:56:26,550 --> 00:56:28,890
these kind of constructs we went over a

1352
00:56:28,890 --> 00:56:32,010
way to make deidre understand those

1353
00:56:32,010 --> 00:56:33,510
constructs a little better and to make

1354
00:56:33,510 --> 00:56:36,660
them easier for you to read and so the

1355
00:56:36,660 --> 00:56:38,280
exercises all these exercises are

1356
00:56:38,280 --> 00:56:42,000
available on the github page and with

1357
00:56:42,000 --> 00:56:45,780
that are there any you know quick

1358
00:56:45,780 --> 00:56:48,090
questions I'm gonna stop screen share

1359
00:56:48,090 --> 00:56:50,760
real quick and look at the chat log not

1360
00:56:50,760 --> 00:56:54,200
yet had a chance to look

1361
00:56:58,460 --> 00:57:00,780
okay so Brian says you found the

1362
00:57:00,780 --> 00:57:02,070
binaries but there isn't a description

1363
00:57:02,070 --> 00:57:04,080
of what you're trying to find B so if

1364
00:57:04,080 --> 00:57:05,370
you run them without arguments it'll

1365
00:57:05,370 --> 00:57:08,370
tell you what it's looking for and if

1366
00:57:08,370 --> 00:57:10,410
you need more help please reach out and

1367
00:57:10,410 --> 00:57:15,330
chat the the chat is public on the

1368
00:57:15,330 --> 00:57:17,340
github IO page and I check it fairly

1369
00:57:17,340 --> 00:57:20,580
regularly so and so are there questions

1370
00:57:20,580 --> 00:57:23,100
for the exercises no so the format of

1371
00:57:23,100 --> 00:57:26,040
these exercises folks are kind of like a

1372
00:57:26,040 --> 00:57:28,170
typical they're called you know crack

1373
00:57:28,170 --> 00:57:31,200
knees so they are you're typically

1374
00:57:31,200 --> 00:57:33,300
trying to provide you know a password

1375
00:57:33,300 --> 00:57:35,490
and the program is gonna tell you that

1376
00:57:35,490 --> 00:57:37,080
you either provided the right password

1377
00:57:37,080 --> 00:57:39,450
or the wrong password and that's gonna

1378
00:57:39,450 --> 00:57:43,260
be the structure of the these exercises

1379
00:57:43,260 --> 00:57:44,550
and for the next session we're gonna

1380
00:57:44,550 --> 00:57:47,910
change that up a little bit and we're

1381
00:57:47,910 --> 00:57:50,040
going to go over kind of how to do that

1382
00:57:50,040 --> 00:57:54,330
in session 3 so andrew says arc arrays

1383
00:57:54,330 --> 00:57:59,190
again yeah sure so when you make a raise

1384
00:57:59,190 --> 00:58:01,590
you have to create the datatype first at

1385
00:58:01,590 --> 00:58:03,390
the address so that's why we go here and

1386
00:58:03,390 --> 00:58:06,030
we right click and click data you int

1387
00:58:06,030 --> 00:58:07,800
because it's an unsigned integer and

1388
00:58:07,800 --> 00:58:10,800
then once you have that you go through

1389
00:58:10,800 --> 00:58:13,140
and actually create the array and there

1390
00:58:13,140 --> 00:58:14,670
might be a way to create the array just

1391
00:58:14,670 --> 00:58:16,200
without creating the datatype first this

1392
00:58:16,200 --> 00:58:20,760
is just how I've always done it so

1393
00:58:20,760 --> 00:58:22,050
you'll click create array tell it how

1394
00:58:22,050 --> 00:58:24,660
many elements are there and then it'll

1395
00:58:24,660 --> 00:58:27,720
generate the array for you and yes you

1396
00:58:27,720 --> 00:58:30,630
will have to run chmod on the binaries

1397
00:58:30,630 --> 00:58:33,180
to execute them I'll add that to to the

1398
00:58:33,180 --> 00:58:35,100
to the readme for those that's a really

1399
00:58:35,100 --> 00:58:37,170
good point I think it was Chris that

1400
00:58:37,170 --> 00:58:40,230
said that so thank you for that Chris

1401
00:58:40,230 --> 00:58:42,090
make sure I actually got that name right

1402
00:58:42,090 --> 00:58:47,700
I apologize if I didn't yeah so that's

1403
00:58:47,700 --> 00:58:49,740
that's it for today everybody thanks for

1404
00:58:49,740 --> 00:58:51,480
thanks for joining us again and and

1405
00:58:51,480 --> 00:58:54,390
please you know ask ask away on the

1406
00:58:54,390 --> 00:58:54,840
hackaday

1407
00:58:54,840 --> 00:58:57,060
IO page I know some of you were really

1408
00:58:57,060 --> 00:58:59,250
tearing through these exercises and it

1409
00:58:59,250 --> 00:59:01,080
would be cool to start you know seeing

1410
00:59:01,080 --> 00:59:02,670
people maybe work together on some of

1411
00:59:02,670 --> 00:59:03,720
these and things like that

1412
00:59:03,720 --> 00:59:06,330
so and you know reach out to me on

1413
00:59:06,330 --> 00:59:08,460
Twitter or where else if you have any

1414
00:59:08,460 --> 00:59:11,660
other questions or need anything else

1415
00:59:11,660 --> 00:59:13,430
so thanks for coming again appreciate

1416
00:59:13,430 --> 00:59:16,610
everybody taking the time and those of

1417
00:59:16,610 --> 00:59:17,870
you that want to come to the office hour

1418
00:59:17,870 --> 00:59:21,440
just reach out to - you can reach out to

1419
00:59:21,440 --> 00:59:24,260
me or the super conference email that

1420
00:59:24,260 --> 00:59:25,550
was posted and we can get you guys a

1421
00:59:25,550 --> 00:59:29,020
link to the office hour

