1
00:00:00,000 --> 00:00:08,639
[Music]

2
00:00:08,639 --> 00:00:09,360
hi there

3
00:00:09,360 --> 00:00:11,599
my name is alexander rousell and we're

4
00:00:11,599 --> 00:00:12,880
starting today with the

5
00:00:12,880 --> 00:00:15,200
first week of the serial buses hackaday

6
00:00:15,200 --> 00:00:16,480
u course

7
00:00:16,480 --> 00:00:17,840
we're going to be learning about i

8
00:00:17,840 --> 00:00:21,439
squared c in this the first part

9
00:00:21,439 --> 00:00:23,119
we're going to be covering both the

10
00:00:23,119 --> 00:00:25,359
hardware and protocol layers

11
00:00:25,359 --> 00:00:28,240
of i squared c in this first lesson

12
00:00:28,240 --> 00:00:29,279
we're going to go

13
00:00:29,279 --> 00:00:31,199
through things quite thoroughly the

14
00:00:31,199 --> 00:00:32,640
prerequisites as we

15
00:00:32,640 --> 00:00:35,920
posted were some understanding of

16
00:00:35,920 --> 00:00:38,160
programming microcontrollers

17
00:00:38,160 --> 00:00:40,800
experience with arduino is good basic

18
00:00:40,800 --> 00:00:43,120
understanding of circuit elements but

19
00:00:43,120 --> 00:00:44,640
as long as you have sort of a general

20
00:00:44,640 --> 00:00:46,719
idea of how

21
00:00:46,719 --> 00:00:48,079
chips work and if you have any

22
00:00:48,079 --> 00:00:49,360
experience programming you should be

23
00:00:49,360 --> 00:00:50,399
okay

24
00:00:50,399 --> 00:00:53,039
my email address is there on screen am

25
00:00:53,039 --> 00:00:53,600
rousal

26
00:00:53,600 --> 00:00:56,960
at frozenelectronics.ca uh

27
00:00:56,960 --> 00:01:00,399
so welcome to week one super excited to

28
00:01:00,399 --> 00:01:02,000
be teaching this course this is gonna be

29
00:01:02,000 --> 00:01:03,280
a lot of fun

30
00:01:03,280 --> 00:01:05,438
so the goal of this course is to

31
00:01:05,438 --> 00:01:07,600
familiarize you with i squared c and one

32
00:01:07,600 --> 00:01:08,320
wire

33
00:01:08,320 --> 00:01:11,600
uh in two separate parts

34
00:01:11,600 --> 00:01:13,840
which are two very popular serial buses

35
00:01:13,840 --> 00:01:16,080
from microcontroller communication

36
00:01:16,080 --> 00:01:17,119
we're going to be starting with i

37
00:01:17,119 --> 00:01:18,880
squared c at the hardware and protocol

38
00:01:18,880 --> 00:01:19,520
level

39
00:01:19,520 --> 00:01:21,600
and next week will be i squared c at the

40
00:01:21,600 --> 00:01:23,680
software level we'll be taking a look at

41
00:01:23,680 --> 00:01:25,040
software examples in

42
00:01:25,040 --> 00:01:28,720
c c plus plus with an msp430

43
00:01:28,720 --> 00:01:30,320
microcontroller

44
00:01:30,320 --> 00:01:31,759
there is an easter egg in this

45
00:01:31,759 --> 00:01:34,400
presentation yes the first person to

46
00:01:34,400 --> 00:01:35,280
find it

47
00:01:35,280 --> 00:01:36,960
and send it to my email address which

48
00:01:36,960 --> 00:01:38,400
was on the first slide

49
00:01:38,400 --> 00:01:40,720
will get a 10 tindy gift certificate

50
00:01:40,720 --> 00:01:42,479
which is really cool

51
00:01:42,479 --> 00:01:45,439
this only applies to the first running

52
00:01:45,439 --> 00:01:47,040
of this course which is the week of

53
00:01:47,040 --> 00:01:49,600
september 2nd to the 9th

54
00:01:49,600 --> 00:01:51,119
if you're watching this right after it's

55
00:01:51,119 --> 00:01:52,880
come out and you're the first one to

56
00:01:52,880 --> 00:01:55,119
find the easter egg and email to me

57
00:01:55,119 --> 00:01:57,280
then you will get that 10 tindy gift

58
00:01:57,280 --> 00:01:59,040
certificate which is really cool

59
00:01:59,040 --> 00:02:01,280
a big thanks to tindy for helping

60
00:02:01,280 --> 00:02:03,200
support this course

61
00:02:03,200 --> 00:02:05,759
so a little bit about me i'm a canadian

62
00:02:05,759 --> 00:02:06,320
hacker

63
00:02:06,320 --> 00:02:07,840
i specialize in designing and

64
00:02:07,840 --> 00:02:10,000
prototyping building

65
00:02:10,000 --> 00:02:13,040
testing debugging embedded systems

66
00:02:13,040 --> 00:02:14,959
embedded is what i do it's what i am

67
00:02:14,959 --> 00:02:16,480
good at and what i love doing

68
00:02:16,480 --> 00:02:18,400
i have a lot of years of experience with

69
00:02:18,400 --> 00:02:20,160
i squared cn1 wire

70
00:02:20,160 --> 00:02:21,760
i squared c in particular i've done a

71
00:02:21,760 --> 00:02:23,520
lot of work with

72
00:02:23,520 --> 00:02:25,680
i'm a writer and contributor on the side

73
00:02:25,680 --> 00:02:28,480
for hackaday.io the tindy blog supply

74
00:02:28,480 --> 00:02:30,319
frame hardware blog

75
00:02:30,319 --> 00:02:32,239
and also other websites over the years

76
00:02:32,239 --> 00:02:33,599
i've done a lot of

77
00:02:33,599 --> 00:02:35,360
writing and contributing to various

78
00:02:35,360 --> 00:02:37,040
websites um

79
00:02:37,040 --> 00:02:38,879
i spend way too much time drooling over

80
00:02:38,879 --> 00:02:40,879
expensive logic analyzers

81
00:02:40,879 --> 00:02:42,720
eventually i'd like to get that uh

82
00:02:42,720 --> 00:02:45,360
tektronix mso is it the mso5 or the 8

83
00:02:45,360 --> 00:02:46,239
series

84
00:02:46,239 --> 00:02:48,400
where you can have 64 logic channels at

85
00:02:48,400 --> 00:02:50,239
once in real time

86
00:02:50,239 --> 00:02:53,519
it's just they're so cool

87
00:02:53,519 --> 00:02:56,560
so let's jump into it what is i squared

88
00:02:56,560 --> 00:02:57,519
c

89
00:02:57,519 --> 00:03:00,800
well i2c or i squared c short for inter

90
00:03:00,800 --> 00:03:02,400
integrated circuit bus is a

91
00:03:02,400 --> 00:03:04,080
specification for an electrical

92
00:03:04,080 --> 00:03:04,959
connection

93
00:03:04,959 --> 00:03:07,440
which transmits serial data between any

94
00:03:07,440 --> 00:03:09,280
integrated circuits

95
00:03:09,280 --> 00:03:12,159
uh it can be any arbitrary data at all

96
00:03:12,159 --> 00:03:15,120
with any arbitrary length of data

97
00:03:15,120 --> 00:03:16,280
and it's usually between a

98
00:03:16,280 --> 00:03:18,879
microprocessor microcontroller

99
00:03:18,879 --> 00:03:20,720
and various peripherals and sensors

100
00:03:20,720 --> 00:03:22,159
although that's not a rule

101
00:03:22,159 --> 00:03:24,319
it can be between two microcontrollers

102
00:03:24,319 --> 00:03:25,840
or it could even be in some cases

103
00:03:25,840 --> 00:03:28,400
between two different sensors

104
00:03:28,400 --> 00:03:31,040
data is sent in a packetized format

105
00:03:31,040 --> 00:03:32,400
meaning that each

106
00:03:32,400 --> 00:03:36,159
chunk of data is sent in a specific

107
00:03:36,159 --> 00:03:39,040
order and with a delineator of the start

108
00:03:39,040 --> 00:03:40,400
and the end of the packet which we'll

109
00:03:40,400 --> 00:03:42,239
get into

110
00:03:42,239 --> 00:03:43,920
where did it come from this is a really

111
00:03:43,920 --> 00:03:46,080
good question it was developed by

112
00:03:46,080 --> 00:03:49,440
phillips who are now owned by nxp

113
00:03:49,440 --> 00:03:51,040
they started developing it in the late

114
00:03:51,040 --> 00:03:52,640
70s and early 80s

115
00:03:52,640 --> 00:03:55,920
originally called cbus

116
00:03:55,920 --> 00:03:57,760
for use in creating simple control

117
00:03:57,760 --> 00:03:59,599
system with their family of integrated

118
00:03:59,599 --> 00:04:00,959
circuits

119
00:04:00,959 --> 00:04:02,959
it was supposed to be very simple to

120
00:04:02,959 --> 00:04:04,959
implement if you're a chip designer

121
00:04:04,959 --> 00:04:06,720
and you want to add a serial bus to your

122
00:04:06,720 --> 00:04:08,799
chip the idea was that it was going to

123
00:04:08,799 --> 00:04:10,400
take up less room on an integrated

124
00:04:10,400 --> 00:04:12,400
circuit than competing serial buses like

125
00:04:12,400 --> 00:04:13,200
uart or

126
00:04:13,200 --> 00:04:16,160
there's many other choices at the time

127
00:04:16,160 --> 00:04:17,680
it was supposed to be very easy

128
00:04:17,680 --> 00:04:19,358
and specifically designed for

129
00:04:19,358 --> 00:04:21,120
communication between different portions

130
00:04:21,120 --> 00:04:21,839
of a circuit

131
00:04:21,839 --> 00:04:23,600
it's not really intended for

132
00:04:23,600 --> 00:04:26,160
communications between

133
00:04:26,160 --> 00:04:28,240
two different boards or over long

134
00:04:28,240 --> 00:04:29,919
distances it's really

135
00:04:29,919 --> 00:04:33,199
um ideal for communicating

136
00:04:33,199 --> 00:04:34,800
from one part of a circuit board to

137
00:04:34,800 --> 00:04:37,840
another or between various chips

138
00:04:37,840 --> 00:04:40,160
by the early 90s i squared c had become

139
00:04:40,160 --> 00:04:41,120
quite popular

140
00:04:41,120 --> 00:04:42,080
and there was a lot of other

141
00:04:42,080 --> 00:04:44,400
manufacturers that had started creating

142
00:04:44,400 --> 00:04:46,479
circuits compatible with the i squared c

143
00:04:46,479 --> 00:04:48,240
specification

144
00:04:48,240 --> 00:04:51,040
if you wanted to create them you had to

145
00:04:51,040 --> 00:04:52,639
pay a license fee

146
00:04:52,639 --> 00:04:55,759
to phillips to use the i squared z logo

147
00:04:55,759 --> 00:04:57,520
and implement the standard using their

148
00:04:57,520 --> 00:05:00,160
official names like sda and scl

149
00:05:00,160 --> 00:05:02,160
a lot of companies avoided this by

150
00:05:02,160 --> 00:05:04,400
calling it two wire or twi

151
00:05:04,400 --> 00:05:06,400
atmel in particular you might know on

152
00:05:06,400 --> 00:05:08,080
the app mega chips

153
00:05:08,080 --> 00:05:10,080
for a long time it was called twi that

154
00:05:10,080 --> 00:05:12,080
was to avoid paying these licensing fees

155
00:05:12,080 --> 00:05:13,680
to phillips

156
00:05:13,680 --> 00:05:15,840
in 2006 phillips which had then been

157
00:05:15,840 --> 00:05:17,919
bought by nxp made it a semi-open

158
00:05:17,919 --> 00:05:19,759
standard so you no longer require a

159
00:05:19,759 --> 00:05:20,880
license fee

160
00:05:20,880 --> 00:05:24,080
to be paid to implement i squared c on a

161
00:05:24,080 --> 00:05:24,639
chip

162
00:05:24,639 --> 00:05:27,199
or to use the official names and all the

163
00:05:27,199 --> 00:05:29,280
you know stuff from the specification

164
00:05:29,280 --> 00:05:31,440
you still do require license fee if you

165
00:05:31,440 --> 00:05:32,479
want to reserve an

166
00:05:32,479 --> 00:05:34,880
address in the i squared c address space

167
00:05:34,880 --> 00:05:36,160
so if you're making a new

168
00:05:36,160 --> 00:05:39,520
chip that is unique from other types of

169
00:05:39,520 --> 00:05:41,120
chips and you want a whole brand new

170
00:05:41,120 --> 00:05:42,400
address for it

171
00:05:42,400 --> 00:05:44,720
you do have to pay a fee for that and

172
00:05:44,720 --> 00:05:46,080
i'm just an aside here we won't be

173
00:05:46,080 --> 00:05:46,560
covering

174
00:05:46,560 --> 00:05:49,520
sm bus much at all but just so you know

175
00:05:49,520 --> 00:05:49,840
that

176
00:05:49,840 --> 00:05:53,280
intel in 1995 they made an addition

177
00:05:53,280 --> 00:05:56,000
to the i squared c standard called sm

178
00:05:56,000 --> 00:05:56,720
bus

179
00:05:56,720 --> 00:05:59,360
for use in personal computers the

180
00:05:59,360 --> 00:06:00,319
differences are

181
00:06:00,319 --> 00:06:02,400
that it's much more stringent when it

182
00:06:02,400 --> 00:06:04,000
comes to timing

183
00:06:04,000 --> 00:06:08,800
and and keeping things um

184
00:06:08,960 --> 00:06:11,199
free of interference as much as possible

185
00:06:11,199 --> 00:06:12,160
on a

186
00:06:12,160 --> 00:06:14,400
pc motherboard there can be a lot of

187
00:06:14,400 --> 00:06:16,400
high-speed switching going on you've got

188
00:06:16,400 --> 00:06:17,199
at that time

189
00:06:17,199 --> 00:06:20,160
isa and pci now you've got pci express

190
00:06:20,160 --> 00:06:20,800
you've got

191
00:06:20,800 --> 00:06:22,319
ethernet there's all sorts of stuff

192
00:06:22,319 --> 00:06:25,039
going on they wanted a simple bus to

193
00:06:25,039 --> 00:06:26,479
communicate between

194
00:06:26,479 --> 00:06:28,720
the processor and temperature sensors

195
00:06:28,720 --> 00:06:31,520
and basic eproms that sort of thing

196
00:06:31,520 --> 00:06:34,080
but they wanted it to be a bit more

197
00:06:34,080 --> 00:06:35,840
stringent so that it could withstand the

198
00:06:35,840 --> 00:06:37,440
conditions on a motherboard

199
00:06:37,440 --> 00:06:39,919
and be standardized specifically for use

200
00:06:39,919 --> 00:06:41,520
on motherboards but we won't be covering

201
00:06:41,520 --> 00:06:43,120
sm bus

202
00:06:43,120 --> 00:06:45,199
it's not that different from i squared c

203
00:06:45,199 --> 00:06:47,440
most chips that support i squared c

204
00:06:47,440 --> 00:06:50,560
will support sm bus so

205
00:06:50,560 --> 00:06:53,840
we come to the why well we talked about

206
00:06:53,840 --> 00:06:55,360
how it's simple to implement but there

207
00:06:55,360 --> 00:06:57,680
are a lot of alternatives to i squared c

208
00:06:57,680 --> 00:07:00,080
uh now we've got a whole ton of serial

209
00:07:00,080 --> 00:07:01,759
buses that are commonly available

210
00:07:01,759 --> 00:07:04,639
on microcontrollers can which is often

211
00:07:04,639 --> 00:07:05,919
used in automotive

212
00:07:05,919 --> 00:07:08,720
uh stuff you get about a megahertz spi

213
00:07:08,720 --> 00:07:10,400
which we'll be covering in part two of

214
00:07:10,400 --> 00:07:11,440
this course

215
00:07:11,440 --> 00:07:14,560
uh potentially up to 100 megahertz so a

216
00:07:14,560 --> 00:07:15,520
lot more

217
00:07:15,520 --> 00:07:18,479
speed a lot more data throughput usb you

218
00:07:18,479 --> 00:07:20,720
can even step up to that 480 megahertz

219
00:07:20,720 --> 00:07:22,319
for usb 2.0

220
00:07:22,319 --> 00:07:25,360
now we've got usb 3.1 gen 2

221
00:07:25,360 --> 00:07:27,919
at 10 gigabits per second so you can

222
00:07:27,919 --> 00:07:29,120
stuff a lot of data

223
00:07:29,120 --> 00:07:32,160
over a serial bus uart which was

224
00:07:32,160 --> 00:07:33,599
competitive at the time when it was

225
00:07:33,599 --> 00:07:35,039
developed

226
00:07:35,039 --> 00:07:36,400
you can get you know easily up to 10

227
00:07:36,400 --> 00:07:38,479
megabyte nowadays one wire ethernet

228
00:07:38,479 --> 00:07:39,520
bluetooth there's lots of different

229
00:07:39,520 --> 00:07:40,160
options but

230
00:07:40,160 --> 00:07:42,479
none of these really at the time because

231
00:07:42,479 --> 00:07:45,039
spi wasn't really implemented then

232
00:07:45,039 --> 00:07:47,280
none of these address the ease of use

233
00:07:47,280 --> 00:07:49,759
and the low cost of implementation

234
00:07:49,759 --> 00:07:53,280
as well as the low external cost

235
00:07:53,280 --> 00:07:56,840
a lot of these for example usb ethernet

236
00:07:56,840 --> 00:08:00,240
bluetooth you often need an external

237
00:08:00,240 --> 00:08:03,199
piece of hardware to the microcontroller

238
00:08:03,199 --> 00:08:04,080
for usb

239
00:08:04,080 --> 00:08:05,599
and ethernet you have what's called a

240
00:08:05,599 --> 00:08:07,440
phi which is

241
00:08:07,440 --> 00:08:09,440
essentially it contains the drivers and

242
00:08:09,440 --> 00:08:11,759
the low level logic for that

243
00:08:11,759 --> 00:08:14,639
serial standard those chips add cost to

244
00:08:14,639 --> 00:08:15,840
your bomb

245
00:08:15,840 --> 00:08:17,599
and if you're doing short range

246
00:08:17,599 --> 00:08:19,199
communications between chips

247
00:08:19,199 --> 00:08:21,840
it's not worth spending the money on

248
00:08:21,840 --> 00:08:23,039
that sort of thing when you can have a

249
00:08:23,039 --> 00:08:24,720
very simple fi

250
00:08:24,720 --> 00:08:27,039
integrated into the chip and all you

251
00:08:27,039 --> 00:08:28,479
need externally are a couple of

252
00:08:28,479 --> 00:08:30,080
resistors as we'll see

253
00:08:30,080 --> 00:08:32,159
so what makes i squared c a good choice

254
00:08:32,159 --> 00:08:35,279
well as i said the ease of use and cost

255
00:08:35,279 --> 00:08:37,200
doesn't require external transceivers

256
00:08:37,200 --> 00:08:39,200
and it's integrated into almost all

257
00:08:39,200 --> 00:08:40,719
microcontrollers

258
00:08:40,719 --> 00:08:42,880
there's lots of software libraries that

259
00:08:42,880 --> 00:08:44,640
are freely available to use

260
00:08:44,640 --> 00:08:47,040
either full software implementations of

261
00:08:47,040 --> 00:08:47,920
i squared c

262
00:08:47,920 --> 00:08:50,880
or library specific to the chip that

263
00:08:50,880 --> 00:08:52,640
will take advantage of the hardware i

264
00:08:52,640 --> 00:08:54,080
squared c that's built into

265
00:08:54,080 --> 00:08:56,560
it the only external components that you

266
00:08:56,560 --> 00:08:58,320
need are a couple of resistors

267
00:08:58,320 --> 00:09:00,959
less than a cent in your bond cost and

268
00:09:00,959 --> 00:09:02,399
if you're buying resistors by

269
00:09:02,399 --> 00:09:05,680
you know huge reels of 10 000 at a time

270
00:09:05,680 --> 00:09:08,320
often way less than even that it's a

271
00:09:08,320 --> 00:09:09,920
simple protocol you can learn very

272
00:09:09,920 --> 00:09:11,440
quickly by taking a course

273
00:09:11,440 --> 00:09:15,519
like this so let's dive into i squared c

274
00:09:15,519 --> 00:09:19,120
at the hardware level there's only three

275
00:09:19,120 --> 00:09:19,920
things

276
00:09:19,920 --> 00:09:22,240
that are actually connected to the bus

277
00:09:22,240 --> 00:09:23,600
we have a controller

278
00:09:23,600 --> 00:09:25,440
a device which is currently in control

279
00:09:25,440 --> 00:09:28,320
of the bus it controls the clock line

280
00:09:28,320 --> 00:09:29,920
and therefore controls the speed at

281
00:09:29,920 --> 00:09:32,720
which data is sent and received

282
00:09:32,720 --> 00:09:35,279
you have peripherals a device which

283
00:09:35,279 --> 00:09:36,560
cannot control the bus

284
00:09:36,560 --> 00:09:39,200
directly has to be told to control the

285
00:09:39,200 --> 00:09:39,600
bus

286
00:09:39,600 --> 00:09:41,519
by the controller it's typically a

287
00:09:41,519 --> 00:09:43,360
sensor something that only

288
00:09:43,360 --> 00:09:45,279
responds to commands but doesn't

289
00:09:45,279 --> 00:09:47,600
actually control the bus directly

290
00:09:47,600 --> 00:09:49,279
and then we have that pair of pull-up

291
00:09:49,279 --> 00:09:51,040
resistors which keep both

292
00:09:51,040 --> 00:09:54,399
of the s both of the i squared c lines

293
00:09:54,399 --> 00:09:57,120
in their high idle state i just want to

294
00:09:57,120 --> 00:09:57,600
go

295
00:09:57,600 --> 00:10:00,480
over a very brief aside here the i

296
00:10:00,480 --> 00:10:01,040
squared c

297
00:10:01,040 --> 00:10:03,200
specification and in the industry for

298
00:10:03,200 --> 00:10:05,360
many many years they've been using

299
00:10:05,360 --> 00:10:07,040
terms that are now recognized to be

300
00:10:07,040 --> 00:10:09,360
problematic uh i squared c

301
00:10:09,360 --> 00:10:11,600
specification uses the term master for

302
00:10:11,600 --> 00:10:12,640
controller

303
00:10:12,640 --> 00:10:15,839
and slave for peripherals in this course

304
00:10:15,839 --> 00:10:18,079
and on hackaday.i o and many other

305
00:10:18,079 --> 00:10:19,040
places

306
00:10:19,040 --> 00:10:20,480
we're just going to use controller and

307
00:10:20,480 --> 00:10:22,320
peripheral

308
00:10:22,320 --> 00:10:24,240
partially in response to the fact that

309
00:10:24,240 --> 00:10:25,440
they're problematic but also to

310
00:10:25,440 --> 00:10:26,480
demonstrate how

311
00:10:26,480 --> 00:10:28,880
easy and seamless the change is and that

312
00:10:28,880 --> 00:10:30,720
it's not a big deal so

313
00:10:30,720 --> 00:10:32,320
hopefully no one will be upset by that

314
00:10:32,320 --> 00:10:34,800
if you are times move on and

315
00:10:34,800 --> 00:10:35,839
these are the terms we're going to be

316
00:10:35,839 --> 00:10:38,079
using in this course so if you need to

317
00:10:38,079 --> 00:10:40,000
refer to the specification

318
00:10:40,000 --> 00:10:42,079
just remember which one pertains to

319
00:10:42,079 --> 00:10:44,160
which and just replace the words it's

320
00:10:44,160 --> 00:10:46,079
that simple

321
00:10:46,079 --> 00:10:49,360
so the two lines that are key to i

322
00:10:49,360 --> 00:10:50,160
squared c

323
00:10:50,160 --> 00:10:53,519
as i mentioned are called sda and scl

324
00:10:53,519 --> 00:10:57,120
scl serial clock used to synchronize

325
00:10:57,120 --> 00:10:58,240
each bit

326
00:10:58,240 --> 00:11:00,160
because i squared t is a synchronous

327
00:11:00,160 --> 00:11:02,240
protocol it has to have a clock that

328
00:11:02,240 --> 00:11:05,040
lines up with each data bit to clock it

329
00:11:05,040 --> 00:11:06,560
in

330
00:11:06,560 --> 00:11:09,279
and sda serial data which is driven low

331
00:11:09,279 --> 00:11:11,440
or release high to send the actual bits

332
00:11:11,440 --> 00:11:13,279
of data that are being communicated back

333
00:11:13,279 --> 00:11:14,959
and forth

334
00:11:14,959 --> 00:11:17,839
this is a very quick look at what an

335
00:11:17,839 --> 00:11:18,720
average

336
00:11:18,720 --> 00:11:20,640
trace looks like from an i squared c bus

337
00:11:20,640 --> 00:11:21,519
you don't need to worry about the

338
00:11:21,519 --> 00:11:23,279
decoded logic i just want you to see

339
00:11:23,279 --> 00:11:23,920
that

340
00:11:23,920 --> 00:11:27,040
the top trace has

341
00:11:27,040 --> 00:11:28,560
just a clock line it's just going up and

342
00:11:28,560 --> 00:11:30,160
down up and down up and down

343
00:11:30,160 --> 00:11:32,240
and the bottom trace is going up and

344
00:11:32,240 --> 00:11:34,720
down and it represents the actual bits

345
00:11:34,720 --> 00:11:37,200
that are being sent

346
00:11:37,200 --> 00:11:40,480
top trace scl bottom trace sda

347
00:11:40,480 --> 00:11:42,800
how are they built now this is where the

348
00:11:42,800 --> 00:11:44,240
prerequisite of having a basic

349
00:11:44,240 --> 00:11:46,640
understanding of circuit symbols is good

350
00:11:46,640 --> 00:11:50,079
but we'll go over this in detail so on

351
00:11:50,079 --> 00:11:52,560
the bus we have the two pull-up

352
00:11:52,560 --> 00:11:53,279
resistors

353
00:11:53,279 --> 00:11:55,519
these whenever nothing is happening on

354
00:11:55,519 --> 00:11:57,839
the bus they return the bus to its

355
00:11:57,839 --> 00:12:01,680
state of idle which is vcc

356
00:12:01,680 --> 00:12:03,920
it could be 3.3 volts it could be 5

357
00:12:03,920 --> 00:12:06,160
volts it could be 1.8 volts

358
00:12:06,160 --> 00:12:09,440
it doesn't matter as long as it's agreed

359
00:12:09,440 --> 00:12:10,800
upon between the chips and

360
00:12:10,800 --> 00:12:12,800
all the chips will work with that

361
00:12:12,800 --> 00:12:14,160
voltage level

362
00:12:14,160 --> 00:12:17,360
most commonly you'll see 3.3 and 5 volts

363
00:12:17,360 --> 00:12:20,480
we have a buffer which is connected to

364
00:12:20,480 --> 00:12:23,360
each line internally inside the chip

365
00:12:23,360 --> 00:12:24,079
this is how it

366
00:12:24,079 --> 00:12:25,839
samples what's actually happening on the

367
00:12:25,839 --> 00:12:28,079
bus this is how it listens to what's

368
00:12:28,079 --> 00:12:29,600
going on

369
00:12:29,600 --> 00:12:32,160
and then we have fets which are

370
00:12:32,160 --> 00:12:33,600
transistors which can turn

371
00:12:33,600 --> 00:12:36,160
on and off these are called open drain

372
00:12:36,160 --> 00:12:38,880
or open collector because

373
00:12:38,880 --> 00:12:40,959
they are connected directly to ground

374
00:12:40,959 --> 00:12:42,480
and to the

375
00:12:42,480 --> 00:12:45,600
line itself when you turn them on they

376
00:12:45,600 --> 00:12:47,760
essentially become a short circuit

377
00:12:47,760 --> 00:12:49,680
and because we've got a high resistance

378
00:12:49,680 --> 00:12:51,600
to vcc

379
00:12:51,600 --> 00:12:53,440
it pulls it to ground now this is a

380
00:12:53,440 --> 00:12:55,279
really key point with i squared c

381
00:12:55,279 --> 00:12:59,040
the only thing a device can do is pull

382
00:12:59,040 --> 00:13:01,360
the bus to ground it can't drive the bus

383
00:13:01,360 --> 00:13:03,519
high it relies on the external pull-ups

384
00:13:03,519 --> 00:13:04,399
for that

385
00:13:04,399 --> 00:13:06,639
this has some trade-offs but it makes

386
00:13:06,639 --> 00:13:08,800
some things very simple such as bus

387
00:13:08,800 --> 00:13:11,519
arbitration which we'll get into later

388
00:13:11,519 --> 00:13:14,000
uh we also have uh there's just some

389
00:13:14,000 --> 00:13:15,200
boxes to show

390
00:13:15,200 --> 00:13:16,639
on the left-hand side we have a

391
00:13:16,639 --> 00:13:18,079
controller on the right-hand side we

392
00:13:18,079 --> 00:13:19,200
have a peripheral

393
00:13:19,200 --> 00:13:21,040
you'll notice that the peripheral only

394
00:13:21,040 --> 00:13:22,399
has effect

395
00:13:22,399 --> 00:13:25,040
on the data line it doesn't have a fet

396
00:13:25,040 --> 00:13:26,399
on the clock line

397
00:13:26,399 --> 00:13:28,240
that's because as i mentioned the

398
00:13:28,240 --> 00:13:30,160
controller controls the clock line and

399
00:13:30,160 --> 00:13:32,320
therefore it sort of is in control of

400
00:13:32,320 --> 00:13:34,399
how quickly data is sent and when things

401
00:13:34,399 --> 00:13:36,639
happen on the bus

402
00:13:36,639 --> 00:13:38,880
there's also equivalent capacitance on

403
00:13:38,880 --> 00:13:40,240
the bus now we're going to just

404
00:13:40,240 --> 00:13:43,279
touch on this briefly if you know your

405
00:13:43,279 --> 00:13:44,800
ohm's law and you've

406
00:13:44,800 --> 00:13:46,639
dealt with capacitors at all you'll know

407
00:13:46,639 --> 00:13:48,639
that equivalent capacitance

408
00:13:48,639 --> 00:13:50,959
on things like serial buses is a bad

409
00:13:50,959 --> 00:13:51,680
thing

410
00:13:51,680 --> 00:13:54,720
capacitors resist change in voltage but

411
00:13:54,720 --> 00:13:56,399
changes in voltage is how we are

412
00:13:56,399 --> 00:13:57,279
signaling

413
00:13:57,279 --> 00:13:59,360
and communicating so we don't want

414
00:13:59,360 --> 00:14:01,040
capacitance

415
00:14:01,040 --> 00:14:03,120
so things that are important to remember

416
00:14:03,120 --> 00:14:04,320
as i said the bus

417
00:14:04,320 --> 00:14:06,880
can only be pulled to ground they rely

418
00:14:06,880 --> 00:14:08,079
on the external

419
00:14:08,079 --> 00:14:10,160
resistors to pull them back up to their

420
00:14:10,160 --> 00:14:12,160
idle state

421
00:14:12,160 --> 00:14:13,760
the value of the pull-up resistors can

422
00:14:13,760 --> 00:14:15,920
affect the maximum transmission speed

423
00:14:15,920 --> 00:14:17,839
especially in systems that have many

424
00:14:17,839 --> 00:14:20,560
devices attached to the bus

425
00:14:20,560 --> 00:14:23,199
because we can only pull the ground yeah

426
00:14:23,199 --> 00:14:24,720
as i said this has some benefits that

427
00:14:24,720 --> 00:14:26,480
make bus arbitration and acknowledge

428
00:14:26,480 --> 00:14:28,639
sequences much easier

429
00:14:28,639 --> 00:14:30,959
so this is why pull-ups matter remember

430
00:14:30,959 --> 00:14:31,760
our rc

431
00:14:31,760 --> 00:14:33,680
circuit basics the length of time it

432
00:14:33,680 --> 00:14:35,760
takes to charge a capacitor is directly

433
00:14:35,760 --> 00:14:36,880
proportional

434
00:14:36,880 --> 00:14:38,800
to the size of the resistor times the

435
00:14:38,800 --> 00:14:40,639
size of the capacitor in ohms and

436
00:14:40,639 --> 00:14:42,560
ferrets

437
00:14:42,560 --> 00:14:44,000
if we have too much resistance or too

438
00:14:44,000 --> 00:14:46,320
much capacitance it can make the charge

439
00:14:46,320 --> 00:14:46,639
time

440
00:14:46,639 --> 00:14:48,880
so long that the voltage is unable to

441
00:14:48,880 --> 00:14:50,560
get back to the idle state

442
00:14:50,560 --> 00:14:52,720
making communication intermittent or in

443
00:14:52,720 --> 00:14:54,959
many cases completely impossible

444
00:14:54,959 --> 00:14:56,560
so let's take a quick look at what this

445
00:14:56,560 --> 00:14:58,320
looks like in practice with some

446
00:14:58,320 --> 00:14:59,760
exaggerated examples that help

447
00:14:59,760 --> 00:15:01,120
illustrate what can go wrong

448
00:15:01,120 --> 00:15:02,880
so we're going to be looking at some

449
00:15:02,880 --> 00:15:04,720
circuit simulation software

450
00:15:04,720 --> 00:15:06,160
don't worry about all the different

451
00:15:06,160 --> 00:15:07,519
symbols you see we'll go over the

452
00:15:07,519 --> 00:15:08,560
important ones

453
00:15:08,560 --> 00:15:10,480
so this is our first example where our

454
00:15:10,480 --> 00:15:12,800
bus has too much resistance

455
00:15:12,800 --> 00:15:15,120
we've used pull-up resistors of one mega

456
00:15:15,120 --> 00:15:17,120
ohm which is a lot of

457
00:15:17,120 --> 00:15:18,880
resistance and the equivalent

458
00:15:18,880 --> 00:15:20,639
capacitance on the bus is quite high as

459
00:15:20,639 --> 00:15:22,560
well at one nano farad

460
00:15:22,560 --> 00:15:24,399
over on the left hand side we have a

461
00:15:24,399 --> 00:15:26,639
voltage source which is our bus at 5

462
00:15:26,639 --> 00:15:27,600
volts

463
00:15:27,600 --> 00:15:29,440
and over on the right hand side we have

464
00:15:29,440 --> 00:15:31,040
that fet that we saw

465
00:15:31,040 --> 00:15:33,519
inside the devices earlier and that's

466
00:15:33,519 --> 00:15:35,199
going to be turning on and off to

467
00:15:35,199 --> 00:15:37,040
simulate

468
00:15:37,040 --> 00:15:40,240
the data or clock line being sent so in

469
00:15:40,240 --> 00:15:42,399
this case with one mega ohm

470
00:15:42,399 --> 00:15:44,800
of resistance and one nano farad of

471
00:15:44,800 --> 00:15:46,160
capacitance

472
00:15:46,160 --> 00:15:47,519
there's the resistor there's the

473
00:15:47,519 --> 00:15:49,839
capacitor we get this

474
00:15:49,839 --> 00:15:52,720
this is a very typical signature you'll

475
00:15:52,720 --> 00:15:54,560
see on an oscilloscope

476
00:15:54,560 --> 00:15:56,079
we call it shark finning because it

477
00:15:56,079 --> 00:15:57,839
looks like a shark's fin

478
00:15:57,839 --> 00:16:00,320
we're starting up at five volts but when

479
00:16:00,320 --> 00:16:02,079
we turn the transistor on

480
00:16:02,079 --> 00:16:03,759
we get all the way down to zero volts

481
00:16:03,759 --> 00:16:06,079
but then we only get back up to just

482
00:16:06,079 --> 00:16:08,079
over three volts

483
00:16:08,079 --> 00:16:09,600
you can see the charge time has that

484
00:16:09,600 --> 00:16:11,759
very characteristic curve to it

485
00:16:11,759 --> 00:16:14,079
we want to avoid this because this will

486
00:16:14,079 --> 00:16:14,959
make

487
00:16:14,959 --> 00:16:17,279
will have to slow down communication

488
00:16:17,279 --> 00:16:19,040
make those pulses further and further

489
00:16:19,040 --> 00:16:19,920
apart so

490
00:16:19,920 --> 00:16:22,240
the bus has time to return to its idle

491
00:16:22,240 --> 00:16:23,199
state

492
00:16:23,199 --> 00:16:24,880
obviously we don't want that so the

493
00:16:24,880 --> 00:16:26,240
solution is to

494
00:16:26,240 --> 00:16:28,320
increase the resistance or sorry

495
00:16:28,320 --> 00:16:30,000
decrease the amount of resistance

496
00:16:30,000 --> 00:16:32,560
pardon me or decrease the amount of

497
00:16:32,560 --> 00:16:33,440
capacitance

498
00:16:33,440 --> 00:16:35,519
sometimes we can't decrease the amount

499
00:16:35,519 --> 00:16:36,800
of capacitance

500
00:16:36,800 --> 00:16:38,399
so the easiest thing to do is to lower

501
00:16:38,399 --> 00:16:40,240
the resistor so this is an example where

502
00:16:40,240 --> 00:16:41,920
it's just right we have our sort of

503
00:16:41,920 --> 00:16:42,560
average

504
00:16:42,560 --> 00:16:45,920
value of 4.7 k very common pull up

505
00:16:45,920 --> 00:16:48,240
resistor size for i squared c

506
00:16:48,240 --> 00:16:51,120
now we've got our nice clean 5 volts

507
00:16:51,120 --> 00:16:51,600
when we

508
00:16:51,600 --> 00:16:54,079
let go of the line it snaps back up to 5

509
00:16:54,079 --> 00:16:55,519
volts very quickly

510
00:16:55,519 --> 00:16:57,360
we've got nice clean transitions this

511
00:16:57,360 --> 00:16:59,680
will work great

512
00:16:59,680 --> 00:17:02,560
so speaking about speed we have various

513
00:17:02,560 --> 00:17:03,600
speed options

514
00:17:03,600 --> 00:17:06,559
on the i squared c bus we've got the

515
00:17:06,559 --> 00:17:08,640
standard speed of 100 kilohertz

516
00:17:08,640 --> 00:17:10,880
later on there was a 400 kilohertz mode

517
00:17:10,880 --> 00:17:13,679
that was introduced called fast mode

518
00:17:13,679 --> 00:17:16,240
later a fast mode plus 1 megahertz high

519
00:17:16,240 --> 00:17:18,079
speed mode 3.4 megahertz and then

520
00:17:18,079 --> 00:17:20,400
there's a new addition to the standard

521
00:17:20,400 --> 00:17:22,880
called ultra fast mode uh that runs at

522
00:17:22,880 --> 00:17:25,119
five megahertz and it uses a traditional

523
00:17:25,119 --> 00:17:26,400
push-pull

524
00:17:26,400 --> 00:17:28,240
type of serial bus so it doesn't use

525
00:17:28,240 --> 00:17:29,679
pull-up resistors it's a completely

526
00:17:29,679 --> 00:17:30,799
different thing

527
00:17:30,799 --> 00:17:33,360
it's not very common at all yet so we

528
00:17:33,360 --> 00:17:34,160
won't really be

529
00:17:34,160 --> 00:17:36,160
touching on it most of the time you're

530
00:17:36,160 --> 00:17:38,880
going to see 100 or 400 kilohertz

531
00:17:38,880 --> 00:17:41,039
most microcontrollers do support fast

532
00:17:41,039 --> 00:17:43,600
mode plus in high speed mode

533
00:17:43,600 --> 00:17:46,720
but most chips typically support 400

534
00:17:46,720 --> 00:17:48,000
kilohertz

535
00:17:48,000 --> 00:17:50,240
or fast mode plus one megahertz as their

536
00:17:50,240 --> 00:17:51,520
top speed

537
00:17:51,520 --> 00:17:53,679
r squared c is not really the best if

538
00:17:53,679 --> 00:17:55,200
you need to move huge amounts of data

539
00:17:55,200 --> 00:17:57,440
really fast it's really meant for

540
00:17:57,440 --> 00:18:00,559
communicating small amounts of data to

541
00:18:00,559 --> 00:18:02,480
in between various chips on a circuit

542
00:18:02,480 --> 00:18:03,760
board

543
00:18:03,760 --> 00:18:05,200
as i said yeah it uses a traditional

544
00:18:05,200 --> 00:18:07,440
push-pull architecture like spi

545
00:18:07,440 --> 00:18:09,679
hasn't found mainstream usage yet so

546
00:18:09,679 --> 00:18:11,440
here's a typical i square

547
00:18:11,440 --> 00:18:14,640
c bus we've got a microcontroller that

548
00:18:14,640 --> 00:18:15,039
has

549
00:18:15,039 --> 00:18:19,280
sdn scl lines connected to some

550
00:18:19,280 --> 00:18:20,720
pull-up resistors which are then

551
00:18:20,720 --> 00:18:22,080
connected to a bunch of different things

552
00:18:22,080 --> 00:18:23,679
on the bus we've got all sorts of

553
00:18:23,679 --> 00:18:26,080
options when it comes to i squared c

554
00:18:26,080 --> 00:18:28,799
temperature sensors accelerometers we've

555
00:18:28,799 --> 00:18:29,919
got eeproms

556
00:18:29,919 --> 00:18:32,320
barometric pressure sensors so we can

557
00:18:32,320 --> 00:18:34,160
connect as many devices as we want in

558
00:18:34,160 --> 00:18:35,039
parallel

559
00:18:35,039 --> 00:18:38,160
they're all connected to the same sd8

560
00:18:38,160 --> 00:18:41,360
scl and the only limit on this as we

561
00:18:41,360 --> 00:18:42,080
talked about earlier

562
00:18:42,080 --> 00:18:43,679
is the amount of capacitance each one of

563
00:18:43,679 --> 00:18:45,600
these devices that we add to the bus

564
00:18:45,600 --> 00:18:48,000
will increase the amount of capacitance

565
00:18:48,000 --> 00:18:50,000
and eventually we'll hit a limit you

566
00:18:50,000 --> 00:18:51,360
might have to lower the amount of

567
00:18:51,360 --> 00:18:54,480
resistance in the pull-up resistors

568
00:18:54,480 --> 00:18:56,400
or you might run into a hard limit but

569
00:18:56,400 --> 00:18:58,080
it's fairly uncommon most

570
00:18:58,080 --> 00:18:59,919
buses only have a few devices on them

571
00:18:59,919 --> 00:19:02,160
and you don't need to worry about it

572
00:19:02,160 --> 00:19:05,280
so it's time to look at i squared c

573
00:19:05,280 --> 00:19:08,000
at the protocol level timing is

574
00:19:08,000 --> 00:19:08,720
everything

575
00:19:08,720 --> 00:19:10,320
like with any synchronous protocol

576
00:19:10,320 --> 00:19:12,559
everything is timed against a clock

577
00:19:12,559 --> 00:19:14,720
i squared c packets are formed from

578
00:19:14,720 --> 00:19:16,799
events that happen on the bus like any

579
00:19:16,799 --> 00:19:19,360
packetized serial format

580
00:19:19,360 --> 00:19:21,039
every packet starts and ends with a

581
00:19:21,039 --> 00:19:23,039
specific event in the case of i squared

582
00:19:23,039 --> 00:19:24,799
c these are called start and stop

583
00:19:24,799 --> 00:19:25,840
conditions

584
00:19:25,840 --> 00:19:27,840
they're quite simple how can a

585
00:19:27,840 --> 00:19:29,679
peripheral tell a start or stop

586
00:19:29,679 --> 00:19:31,760
condition apart from just data

587
00:19:31,760 --> 00:19:34,240
well here's the hard and fast rule the

588
00:19:34,240 --> 00:19:35,840
only time the data line

589
00:19:35,840 --> 00:19:38,160
sda can change when the clock line is

590
00:19:38,160 --> 00:19:39,120
high

591
00:19:39,120 --> 00:19:41,600
is during start or stop conditions so if

592
00:19:41,600 --> 00:19:43,440
the clock line is high

593
00:19:43,440 --> 00:19:46,240
and the deadline transitions it is

594
00:19:46,240 --> 00:19:47,840
either a start or a stop condition

595
00:19:47,840 --> 00:19:49,840
there's no other situation in which that

596
00:19:49,840 --> 00:19:51,200
happens

597
00:19:51,200 --> 00:19:52,720
so during regular transmissions the

598
00:19:52,720 --> 00:19:54,720
controller peripheral must wait until

599
00:19:54,720 --> 00:19:56,720
the clock line is low before changing

600
00:19:56,720 --> 00:19:58,000
the data line

601
00:19:58,000 --> 00:19:59,760
if you're just sending a regular byte of

602
00:19:59,760 --> 00:20:01,440
data you have to make sure the clock

603
00:20:01,440 --> 00:20:03,200
line is low before you change the data

604
00:20:03,200 --> 00:20:03,840
line

605
00:20:03,840 --> 00:20:05,679
otherwise you'll be sending a start or a

606
00:20:05,679 --> 00:20:07,360
stop condition

607
00:20:07,360 --> 00:20:08,799
let's look at what these actually look

608
00:20:08,799 --> 00:20:11,120
like here's our start condition

609
00:20:11,120 --> 00:20:13,120
marks the beginning of an i squared c

610
00:20:13,120 --> 00:20:14,400
transaction

611
00:20:14,400 --> 00:20:17,760
the bus starts idle so both sda and scl

612
00:20:17,760 --> 00:20:19,760
are pulled high by the pull-up resistors

613
00:20:19,760 --> 00:20:20,000
to

614
00:20:20,000 --> 00:20:22,880
5 volts or whatever it may be the data

615
00:20:22,880 --> 00:20:24,640
line goes low first

616
00:20:24,640 --> 00:20:27,360
followed shortly by the clock line the

617
00:20:27,360 --> 00:20:28,880
reason that it's a start condition again

618
00:20:28,880 --> 00:20:29,840
is because we see

619
00:20:29,840 --> 00:20:32,960
the data line goes low first it changes

620
00:20:32,960 --> 00:20:35,440
while the clock line is still high this

621
00:20:35,440 --> 00:20:36,640
is what it looks like

622
00:20:36,640 --> 00:20:38,799
on the bus over at the left hand side

623
00:20:38,799 --> 00:20:40,559
you can see clock is on top and

624
00:20:40,559 --> 00:20:42,880
data is on the bottom the data line

625
00:20:42,880 --> 00:20:44,880
transitions low while the clock line is

626
00:20:44,880 --> 00:20:46,000
still high

627
00:20:46,000 --> 00:20:48,400
then some amount of time later the clock

628
00:20:48,400 --> 00:20:49,760
line goes low and that

629
00:20:49,760 --> 00:20:51,600
signals a start condition so now we're

630
00:20:51,600 --> 00:20:54,320
ready to start sending data

631
00:20:54,320 --> 00:20:56,000
well what's a stop condition it's

632
00:20:56,000 --> 00:20:58,159
essentially the inverse it's a mirror

633
00:20:58,159 --> 00:20:58,880
image

634
00:20:58,880 --> 00:21:00,840
it marks the end of an i squared c

635
00:21:00,840 --> 00:21:02,480
transaction

636
00:21:02,480 --> 00:21:04,240
so it's an exact mirror image the bus

637
00:21:04,240 --> 00:21:05,760
must be active

638
00:21:05,760 --> 00:21:08,720
both sda and scl are in their low state

639
00:21:08,720 --> 00:21:10,559
so zero volts

640
00:21:10,559 --> 00:21:13,760
the clock goes high first followed by

641
00:21:13,760 --> 00:21:15,919
data afterwards of course the clock has

642
00:21:15,919 --> 00:21:17,679
to go high first to signal a stop

643
00:21:17,679 --> 00:21:18,720
condition

644
00:21:18,720 --> 00:21:20,480
because the only way we can signal these

645
00:21:20,480 --> 00:21:22,480
conditions is by changing the data line

646
00:21:22,480 --> 00:21:24,240
while the clock line is high

647
00:21:24,240 --> 00:21:25,919
this is what it looks like on the bus we

648
00:21:25,919 --> 00:21:28,000
start with both lines low

649
00:21:28,000 --> 00:21:30,640
clock line goes high and sometime later

650
00:21:30,640 --> 00:21:32,159
the data line goes high

651
00:21:32,159 --> 00:21:34,720
this signals a stop condition now the

652
00:21:34,720 --> 00:21:36,559
bus is free to be used by other

653
00:21:36,559 --> 00:21:37,600
controllers if there

654
00:21:37,600 --> 00:21:41,039
are any um or sometimes this will signal

655
00:21:41,039 --> 00:21:43,120
to the chip to start executing whatever

656
00:21:43,120 --> 00:21:45,120
command we just gave it

657
00:21:45,120 --> 00:21:47,280
there's also a variation of the start

658
00:21:47,280 --> 00:21:49,360
condition called a repeated start

659
00:21:49,360 --> 00:21:51,679
this is when we send another start

660
00:21:51,679 --> 00:21:54,559
condition instead of a stop condition

661
00:21:54,559 --> 00:21:58,000
this leads into bus arbitration

662
00:21:58,000 --> 00:21:59,600
it's a repeated start and it's when we

663
00:21:59,600 --> 00:22:01,200
want to immediately start a new

664
00:22:01,200 --> 00:22:02,480
transaction without

665
00:22:02,480 --> 00:22:05,039
letting go of the bus and potentially

666
00:22:05,039 --> 00:22:05,600
having

667
00:22:05,600 --> 00:22:07,200
another chip step in and start

668
00:22:07,200 --> 00:22:09,440
communicating this is really important

669
00:22:09,440 --> 00:22:10,640
if for example

670
00:22:10,640 --> 00:22:12,799
you've just written a value to a chip

671
00:22:12,799 --> 00:22:14,320
it's done something and you want to read

672
00:22:14,320 --> 00:22:15,840
the result out because it's time

673
00:22:15,840 --> 00:22:16,480
sensitive

674
00:22:16,480 --> 00:22:18,799
you can't wait you know however long

675
00:22:18,799 --> 00:22:20,480
it's going to take for another chip to

676
00:22:20,480 --> 00:22:23,120
do some sort of communication

677
00:22:23,120 --> 00:22:25,919
so you can do a repeated start it's also

678
00:22:25,919 --> 00:22:27,520
commonly used when you're

679
00:22:27,520 --> 00:22:29,280
when you finish writing data and now you

680
00:22:29,280 --> 00:22:31,360
want to read data back from a peripheral

681
00:22:31,360 --> 00:22:34,400
for example we might send the register

682
00:22:34,400 --> 00:22:36,320
of the data we want to read then we'd

683
00:22:36,320 --> 00:22:37,760
send a repeated start

684
00:22:37,760 --> 00:22:40,799
and then read the data out instead of

685
00:22:40,799 --> 00:22:42,320
doing a stop condition and then another

686
00:22:42,320 --> 00:22:43,919
start condition

687
00:22:43,919 --> 00:22:46,320
this leads us into bus arbitration this

688
00:22:46,320 --> 00:22:47,760
is one of the

689
00:22:47,760 --> 00:22:50,400
lesser known parts of i squared c and

690
00:22:50,400 --> 00:22:51,600
it's not something you see

691
00:22:51,600 --> 00:22:54,000
terribly commonly unless you have more

692
00:22:54,000 --> 00:22:56,240
than one controller on a bus

693
00:22:56,240 --> 00:22:59,120
i squared c does support this but it's

694
00:22:59,120 --> 00:23:00,400
not something you'll see commonly

695
00:23:00,400 --> 00:23:01,440
usually you have a single

696
00:23:01,440 --> 00:23:03,280
microcontroller and multiple peripherals

697
00:23:03,280 --> 00:23:05,440
but i squared c is capable of

698
00:23:05,440 --> 00:23:07,760
either so why can't it just start

699
00:23:07,760 --> 00:23:09,440
reading and writing data to a peripheral

700
00:23:09,440 --> 00:23:10,480
because there might be another

701
00:23:10,480 --> 00:23:12,320
controller on the bus

702
00:23:12,320 --> 00:23:14,880
whenever any communications protocol has

703
00:23:14,880 --> 00:23:16,240
more than one controller

704
00:23:16,240 --> 00:23:18,000
they must have a way to talk to each

705
00:23:18,000 --> 00:23:19,360
other and decide

706
00:23:19,360 --> 00:23:21,440
who gets to talk when because we can't

707
00:23:21,440 --> 00:23:23,039
all talk at the same time or else the

708
00:23:23,039 --> 00:23:25,200
bus turns into a mess

709
00:23:25,200 --> 00:23:27,760
because i squared c devices can only

710
00:23:27,760 --> 00:23:28,960
pull the bus to ground

711
00:23:28,960 --> 00:23:31,280
arbitration actually becomes automatic

712
00:23:31,280 --> 00:23:32,720
it's something that you don't need to

713
00:23:32,720 --> 00:23:33,280
program

714
00:23:33,280 --> 00:23:35,600
in to your software because it's taken

715
00:23:35,600 --> 00:23:37,520
care of by the hardware

716
00:23:37,520 --> 00:23:40,159
here's an example one controller sends a

717
00:23:40,159 --> 00:23:41,919
start condition at the exact same time

718
00:23:41,919 --> 00:23:43,440
as another controller

719
00:23:43,440 --> 00:23:45,360
unlikely but it might happen they both

720
00:23:45,360 --> 00:23:49,039
then start to send data on the bus

721
00:23:49,039 --> 00:23:51,919
every time the controller changes the

722
00:23:51,919 --> 00:23:53,120
state of the bus

723
00:23:53,120 --> 00:23:55,919
sets it to a one or a zero it then needs

724
00:23:55,919 --> 00:23:56,240
to

725
00:23:56,240 --> 00:23:58,640
look at the bus and check that it's

726
00:23:58,640 --> 00:23:59,279
actually

727
00:23:59,279 --> 00:24:01,840
in the state that it was set to so for

728
00:24:01,840 --> 00:24:02,400
example

729
00:24:02,400 --> 00:24:04,720
if you're trying to send a one you need

730
00:24:04,720 --> 00:24:05,679
to release the bus

731
00:24:05,679 --> 00:24:08,000
line and the pull-up resistors will pull

732
00:24:08,000 --> 00:24:09,760
it back up to five volts

733
00:24:09,760 --> 00:24:11,440
but if you've done that and you look at

734
00:24:11,440 --> 00:24:13,760
the bus and the bus is still low

735
00:24:13,760 --> 00:24:16,000
that must mean another controller is

736
00:24:16,000 --> 00:24:16,960
talking

737
00:24:16,960 --> 00:24:19,039
so we need to stop sending data and wait

738
00:24:19,039 --> 00:24:21,919
until we see a stop condition

739
00:24:21,919 --> 00:24:25,120
it's non-destructive as well because we

740
00:24:25,120 --> 00:24:26,720
haven't stepped on what the other

741
00:24:26,720 --> 00:24:29,360
controller is sending

742
00:24:29,360 --> 00:24:31,360
we released the bus but nothing happened

743
00:24:31,360 --> 00:24:32,720
so it didn't change what the other

744
00:24:32,720 --> 00:24:34,080
controller was sending

745
00:24:34,080 --> 00:24:36,159
and the controller that won arbitration

746
00:24:36,159 --> 00:24:38,080
doesn't even know what happened it never

747
00:24:38,080 --> 00:24:39,679
even knew another controller was trying

748
00:24:39,679 --> 00:24:40,240
to talk

749
00:24:40,240 --> 00:24:41,760
which is one of the great things about i

750
00:24:41,760 --> 00:24:44,000
squared c bus arbitration

751
00:24:44,000 --> 00:24:47,120
here's a very simplified diagram often

752
00:24:47,120 --> 00:24:48,960
bus arbitration would happen on the very

753
00:24:48,960 --> 00:24:50,559
first bit or two but i've sort of

754
00:24:50,559 --> 00:24:52,960
extended this out to show what happens

755
00:24:52,960 --> 00:24:54,720
two controllers are sending data at the

756
00:24:54,720 --> 00:24:57,200
same time one of them goes to send a one

757
00:24:57,200 --> 00:24:58,400
at the same time the other one is

758
00:24:58,400 --> 00:25:01,200
sending a zero and the losing controller

759
00:25:01,200 --> 00:25:03,200
looks and sees uh oh i wanted there to

760
00:25:03,200 --> 00:25:05,919
be a one here but there's a zero

761
00:25:05,919 --> 00:25:07,520
that must mean that another controller

762
00:25:07,520 --> 00:25:09,440
is talking so i need to stop

763
00:25:09,440 --> 00:25:12,960
sending data and wait until i see a stop

764
00:25:12,960 --> 00:25:16,000
condition before talking again so this

765
00:25:16,000 --> 00:25:17,679
leads us into again the two

766
00:25:17,679 --> 00:25:20,559
roles we can have on the bus one device

767
00:25:20,559 --> 00:25:21,679
is sending data

768
00:25:21,679 --> 00:25:24,960
and the other device is listening

769
00:25:24,960 --> 00:25:26,960
these roles can change during the course

770
00:25:26,960 --> 00:25:28,799
of a transaction the controller is not

771
00:25:28,799 --> 00:25:29,600
always the one

772
00:25:29,600 --> 00:25:31,919
talking peripheral's not always the one

773
00:25:31,919 --> 00:25:34,080
listening because of course we can read

774
00:25:34,080 --> 00:25:36,080
data from a peripheral or we can write

775
00:25:36,080 --> 00:25:38,159
data to a peripheral

776
00:25:38,159 --> 00:25:40,159
no matter who is talking or listening

777
00:25:40,159 --> 00:25:41,279
though as we mentioned

778
00:25:41,279 --> 00:25:43,200
earlier the controller is in control of

779
00:25:43,200 --> 00:25:44,400
the clock line

780
00:25:44,400 --> 00:25:47,440
therefore the speed of the transaction

781
00:25:47,440 --> 00:25:49,919
and transitioning between them is simply

782
00:25:49,919 --> 00:25:50,640
done by

783
00:25:50,640 --> 00:25:52,880
letting go of the sda line if you want

784
00:25:52,880 --> 00:25:53,760
the other

785
00:25:53,760 --> 00:25:56,559
side to talk you tell them you know you

786
00:25:56,559 --> 00:25:57,039
signal

787
00:25:57,039 --> 00:25:59,760
command then you let go and you let them

788
00:25:59,760 --> 00:26:01,039
take over controlling the

789
00:26:01,039 --> 00:26:04,559
sda line but during that time

790
00:26:04,559 --> 00:26:06,880
the controller is still sending clock

791
00:26:06,880 --> 00:26:08,799
pulses so now that we've mastered starts

792
00:26:08,799 --> 00:26:09,039
off

793
00:26:09,039 --> 00:26:10,480
by arbitration we'll look at how it's

794
00:26:10,480 --> 00:26:12,080
actually sent

795
00:26:12,080 --> 00:26:14,400
every bit is accompanied by a clock

796
00:26:14,400 --> 00:26:15,840
pulse

797
00:26:15,840 --> 00:26:17,840
a transition from low to high on the

798
00:26:17,840 --> 00:26:19,120
clock line

799
00:26:19,120 --> 00:26:20,720
indicates that whatever is currently on

800
00:26:20,720 --> 00:26:22,480
the data line is

801
00:26:22,480 --> 00:26:24,320
the bit that we're trying to send it

802
00:26:24,320 --> 00:26:26,159
makes it's basically saying this bit is

803
00:26:26,159 --> 00:26:27,440
valid right now

804
00:26:27,440 --> 00:26:29,520
so read what's on the line and that's

805
00:26:29,520 --> 00:26:31,840
the bit that we're trying to send

806
00:26:31,840 --> 00:26:34,400
after the clock line goes low the device

807
00:26:34,400 --> 00:26:35,840
currently sending the data

808
00:26:35,840 --> 00:26:38,320
changes the data line to the state of

809
00:26:38,320 --> 00:26:40,080
the next bit so again we have to wait

810
00:26:40,080 --> 00:26:42,159
until the clock line goes low

811
00:26:42,159 --> 00:26:44,720
to change the data line otherwise it

812
00:26:44,720 --> 00:26:46,320
would be interpreted as a start

813
00:26:46,320 --> 00:26:48,960
or stop condition data is always sent

814
00:26:48,960 --> 00:26:51,120
one byte at a time bit by bit

815
00:26:51,120 --> 00:26:53,520
and bytes are always eight bits long now

816
00:26:53,520 --> 00:26:55,760
this doesn't mean that we can't send

817
00:26:55,760 --> 00:26:58,960
16 or 32 or 64-bit values we just have

818
00:26:58,960 --> 00:27:00,480
to always send them in multiples of

819
00:27:00,480 --> 00:27:01,039
eight

820
00:27:01,039 --> 00:27:02,400
this is because i squared c was

821
00:27:02,400 --> 00:27:04,480
developed in the 80s when everything was

822
00:27:04,480 --> 00:27:05,679
8-bit

823
00:27:05,679 --> 00:27:07,840
but because it's an arbitrary length

824
00:27:07,840 --> 00:27:09,760
format we can send however much data we

825
00:27:09,760 --> 00:27:10,960
want

826
00:27:10,960 --> 00:27:13,600
so if we actually decode what's going on

827
00:27:13,600 --> 00:27:14,400
every

828
00:27:14,400 --> 00:27:15,679
transaction is initiated by the

829
00:27:15,679 --> 00:27:18,159
controller sending a start condition

830
00:27:18,159 --> 00:27:19,679
peripherals can't control the bus once

831
00:27:19,679 --> 00:27:21,600
they're requested to do so

832
00:27:21,600 --> 00:27:23,600
the controller must send an address with

833
00:27:23,600 --> 00:27:24,960
every transaction

834
00:27:24,960 --> 00:27:27,200
and that address identifies the exact

835
00:27:27,200 --> 00:27:29,279
peripheral it wants to communicate with

836
00:27:29,279 --> 00:27:31,200
if we've got five or six devices on the

837
00:27:31,200 --> 00:27:32,799
box we have to have a way to tell them

838
00:27:32,799 --> 00:27:33,360
apart

839
00:27:33,360 --> 00:27:36,399
and they have to know which device is

840
00:27:36,399 --> 00:27:38,240
being talked to by the controller or

841
00:27:38,240 --> 00:27:39,200
else they're all going to start

842
00:27:39,200 --> 00:27:41,200
responding so that's why we have

843
00:27:41,200 --> 00:27:44,399
addresses and at the end of every byte

844
00:27:44,399 --> 00:27:46,840
they also acknowledge what's just

845
00:27:46,840 --> 00:27:48,399
happened

846
00:27:48,399 --> 00:27:49,840
there's what's called the acknowledge

847
00:27:49,840 --> 00:27:52,320
bit it actually looks like a ninth bit

848
00:27:52,320 --> 00:27:55,520
being sent but it's uh whatever device

849
00:27:55,520 --> 00:27:58,240
is currently receiving data

850
00:27:58,240 --> 00:28:00,240
so whoever's listening at the time they

851
00:28:00,240 --> 00:28:02,480
send the acknowledge bit to say

852
00:28:02,480 --> 00:28:04,480
whatever you've just sent me is valid

853
00:28:04,480 --> 00:28:06,240
and i understand it

854
00:28:06,240 --> 00:28:08,960
so we'll look at the acknowledge or not

855
00:28:08,960 --> 00:28:10,640
acknowledge as it may be in a bit more

856
00:28:10,640 --> 00:28:11,600
depth

857
00:28:11,600 --> 00:28:13,279
when a controller starts a transaction

858
00:28:13,279 --> 00:28:14,960
and sends an address out

859
00:28:14,960 --> 00:28:18,000
to one of these devices the peripheral

860
00:28:18,000 --> 00:28:19,840
if there's a peripheral there that has

861
00:28:19,840 --> 00:28:21,679
that address it will respond to that

862
00:28:21,679 --> 00:28:24,559
address with the acknowledge bit

863
00:28:24,559 --> 00:28:26,480
this is done by the controller briefly

864
00:28:26,480 --> 00:28:28,399
letting go of the data line

865
00:28:28,399 --> 00:28:30,240
and if you let go of the data line and

866
00:28:30,240 --> 00:28:31,760
there was no device there it would

867
00:28:31,760 --> 00:28:33,520
return to its idle state

868
00:28:33,520 --> 00:28:36,159
so if there is a device there it holds

869
00:28:36,159 --> 00:28:36,880
the

870
00:28:36,880 --> 00:28:39,279
data line low while the controller sends

871
00:28:39,279 --> 00:28:41,120
another clock pulse and this is how it

872
00:28:41,120 --> 00:28:42,320
says hey i'm here

873
00:28:42,320 --> 00:28:45,279
i'm acknowledging the address if it

874
00:28:45,279 --> 00:28:47,279
doesn't match any peripheral or the data

875
00:28:47,279 --> 00:28:48,320
set is incorrect

876
00:28:48,320 --> 00:28:50,640
and not acknowledge is sent this is

877
00:28:50,640 --> 00:28:52,080
actually the default state

878
00:28:52,080 --> 00:28:54,240
because the bus is pulled high by

879
00:28:54,240 --> 00:28:55,440
resistors

880
00:28:55,440 --> 00:28:57,600
if no one does anything to send an

881
00:28:57,600 --> 00:28:59,440
acknowledge bit the default is not

882
00:28:59,440 --> 00:29:00,559
acknowledged

883
00:29:00,559 --> 00:29:02,799
um yeah the natural state is being

884
00:29:02,799 --> 00:29:04,640
pulled high

885
00:29:04,640 --> 00:29:06,159
so let's actually look at how this all

886
00:29:06,159 --> 00:29:08,559
sort of goes together

887
00:29:08,559 --> 00:29:10,240
we have at the beginning like we

888
00:29:10,240 --> 00:29:12,159
established we have a start

889
00:29:12,159 --> 00:29:14,480
so we start with the star condition in

890
00:29:14,480 --> 00:29:16,240
this trace again the clock line is on

891
00:29:16,240 --> 00:29:19,200
top the data line is on the bottom

892
00:29:19,200 --> 00:29:22,159
then while the clock line is low we set

893
00:29:22,159 --> 00:29:24,000
up the first bit you can see it goes

894
00:29:24,000 --> 00:29:25,200
high there

895
00:29:25,200 --> 00:29:27,440
then the first time that the clock line

896
00:29:27,440 --> 00:29:30,000
on the top goes from low to high

897
00:29:30,000 --> 00:29:31,919
that's a clocking in the first bit which

898
00:29:31,919 --> 00:29:33,840
is in this case a one

899
00:29:33,840 --> 00:29:36,240
then the peripheral or whoever is

900
00:29:36,240 --> 00:29:37,760
talking at this point waits for the

901
00:29:37,760 --> 00:29:39,600
clock line to go low

902
00:29:39,600 --> 00:29:41,760
and then it sets the data line low it

903
00:29:41,760 --> 00:29:43,440
might look like that's happening at the

904
00:29:43,440 --> 00:29:44,240
same time

905
00:29:44,240 --> 00:29:46,080
there on that very first clock pulse but

906
00:29:46,080 --> 00:29:47,919
if you zoom in really close

907
00:29:47,919 --> 00:29:49,360
there's actually a delay between the

908
00:29:49,360 --> 00:29:51,440
clock line going low and then the

909
00:29:51,440 --> 00:29:53,600
state of the data line changing and then

910
00:29:53,600 --> 00:29:55,279
the rest of the bits are all zeros

911
00:29:55,279 --> 00:29:57,039
including the acknowledge bit at the end

912
00:29:57,039 --> 00:29:59,760
there so each bit is set as what we just

913
00:29:59,760 --> 00:30:01,039
pointed out

914
00:30:01,039 --> 00:30:03,520
and then after the falling edge the next

915
00:30:03,520 --> 00:30:04,320
bit is set up

916
00:30:04,320 --> 00:30:08,320
so on the byte below is hexadecimal 80

917
00:30:08,320 --> 00:30:11,520
or one with seven zeros in binary

918
00:30:11,520 --> 00:30:13,840
uh don't worry about the actual d code

919
00:30:13,840 --> 00:30:15,600
below we'll get to that later but

920
00:30:15,600 --> 00:30:17,760
at the end as we said we send eight bits

921
00:30:17,760 --> 00:30:19,120
as you can see you can count them

922
00:30:19,120 --> 00:30:19,760
there's

923
00:30:19,760 --> 00:30:21,440
eight clock pulses and then there's that

924
00:30:21,440 --> 00:30:22,799
ninth bit

925
00:30:22,799 --> 00:30:24,880
below it there you can see in pink it

926
00:30:24,880 --> 00:30:26,000
says ack

927
00:30:26,000 --> 00:30:28,480
because the bus remained low during that

928
00:30:28,480 --> 00:30:30,320
last clock pulse that means whatever

929
00:30:30,320 --> 00:30:32,880
device was listening to this data

930
00:30:32,880 --> 00:30:34,880
acknowledged it and said yes this is

931
00:30:34,880 --> 00:30:36,640
valid

932
00:30:36,640 --> 00:30:38,559
so let's take a closer look at how

933
00:30:38,559 --> 00:30:39,919
addressing happens that's actually what

934
00:30:39,919 --> 00:30:41,360
we just looked at there

935
00:30:41,360 --> 00:30:44,559
was an address being sent addresses are

936
00:30:44,559 --> 00:30:47,760
7-bit values they're unique to each type

937
00:30:47,760 --> 00:30:48,640
of device

938
00:30:48,640 --> 00:30:52,240
and ice philips and nxp have tried to

939
00:30:52,240 --> 00:30:52,720
sort of

940
00:30:52,720 --> 00:30:55,919
keep all similar devices using similar

941
00:30:55,919 --> 00:30:57,200
addresses

942
00:30:57,200 --> 00:30:59,360
so temperature sensors might have a

943
00:30:59,360 --> 00:31:00,960
specific address that they

944
00:31:00,960 --> 00:31:03,519
typically use ebroms have a different

945
00:31:03,519 --> 00:31:05,279
address barometric pressure sensors have

946
00:31:05,279 --> 00:31:07,440
a different address

947
00:31:07,440 --> 00:31:09,519
and because there's seven bit values

948
00:31:09,519 --> 00:31:11,120
that leaves an extra bit

949
00:31:11,120 --> 00:31:13,679
on the end to make an eight bit value

950
00:31:13,679 --> 00:31:15,200
this bit is actually

951
00:31:15,200 --> 00:31:17,519
um how we determine what's happening if

952
00:31:17,519 --> 00:31:19,039
it's a reader or right so yeah we

953
00:31:19,039 --> 00:31:19,919
reserve

954
00:31:19,919 --> 00:31:22,240
those addresses by paying a fee to nxp

955
00:31:22,240 --> 00:31:24,159
if you were a chip designer creating a

956
00:31:24,159 --> 00:31:25,279
new peripheral

957
00:31:25,279 --> 00:31:26,880
you'd have to pay a fee for one of these

958
00:31:26,880 --> 00:31:28,880
addresses

959
00:31:28,880 --> 00:31:30,880
as i said the address is also how the

960
00:31:30,880 --> 00:31:32,320
peripheral knows if this

961
00:31:32,320 --> 00:31:34,080
upcoming transaction is going to be a

962
00:31:34,080 --> 00:31:35,360
read or a write

963
00:31:35,360 --> 00:31:37,519
the seven bit address is followed by an

964
00:31:37,519 --> 00:31:38,640
eighth bit

965
00:31:38,640 --> 00:31:40,559
which is low if the following

966
00:31:40,559 --> 00:31:42,000
transaction is a right

967
00:31:42,000 --> 00:31:44,559
or high if it's a read this is referred

968
00:31:44,559 --> 00:31:45,440
to as the read

969
00:31:45,440 --> 00:31:48,720
write bit now because we're adding a bit

970
00:31:48,720 --> 00:31:49,760
to the end

971
00:31:49,760 --> 00:31:51,279
effectively what we're doing is we're

972
00:31:51,279 --> 00:31:53,279
taking that seven bit address

973
00:31:53,279 --> 00:31:55,039
we're shifting it to the left by one

974
00:31:55,039 --> 00:31:57,039
place and then we're adding

975
00:31:57,039 --> 00:32:00,159
that zero or one on the end to tell the

976
00:32:00,159 --> 00:32:01,440
peripheral

977
00:32:01,440 --> 00:32:02,960
either we're writing data to the

978
00:32:02,960 --> 00:32:04,960
peripheral or we're trying to read data

979
00:32:04,960 --> 00:32:06,240
from it

980
00:32:06,240 --> 00:32:09,200
so here's some examples the sht21

981
00:32:09,200 --> 00:32:10,960
temperature and humidity sensor which is

982
00:32:10,960 --> 00:32:12,880
actually the sensor we'll be using

983
00:32:12,880 --> 00:32:16,000
in our examples in part two week two

984
00:32:16,000 --> 00:32:19,120
the address is 40 hexadecimal and the

985
00:32:19,120 --> 00:32:20,080
seven bit

986
00:32:20,080 --> 00:32:23,200
uh it's sort of native uh address

987
00:32:23,200 --> 00:32:24,880
but if we actually want to talk to it we

988
00:32:24,880 --> 00:32:27,200
have to shift it to the left by one

989
00:32:27,200 --> 00:32:30,720
so it becomes an 80 if we want to

990
00:32:30,720 --> 00:32:32,399
write to the device because that last

991
00:32:32,399 --> 00:32:33,760
bit is a zero

992
00:32:33,760 --> 00:32:35,840
or if we want to read something from it

993
00:32:35,840 --> 00:32:38,640
we add a 1 and it becomes 81.

994
00:32:38,640 --> 00:32:40,640
so if you sort of know your basic binary

995
00:32:40,640 --> 00:32:42,720
and hexadecimal if you shift

996
00:32:42,720 --> 00:32:46,000
everything over to the left by one

997
00:32:46,000 --> 00:32:49,120
then it changes the value and

998
00:32:49,120 --> 00:32:53,519
we basically we do a logical or

999
00:32:53,519 --> 00:32:54,799
i won't get into the details we'll get

1000
00:32:54,799 --> 00:32:56,399
into that in the software implementation

1001
00:32:56,399 --> 00:32:57,200
but

1002
00:32:57,200 --> 00:32:59,279
we change the last bit to tell it what

1003
00:32:59,279 --> 00:33:00,720
we want to do

1004
00:33:00,720 --> 00:33:02,720
now here's a stumbling block is that a

1005
00:33:02,720 --> 00:33:04,559
lot of data sheets will use

1006
00:33:04,559 --> 00:33:06,320
either of these forms some companies

1007
00:33:06,320 --> 00:33:08,559
will always display things as the 7-bit

1008
00:33:08,559 --> 00:33:10,080
address and then they'll

1009
00:33:10,080 --> 00:33:12,320
specify if you need to add the reader

1010
00:33:12,320 --> 00:33:13,279
right bit

1011
00:33:13,279 --> 00:33:17,440
others will show the

1012
00:33:17,440 --> 00:33:20,080
right address like for example the data

1013
00:33:20,080 --> 00:33:22,159
sheet might show hexadecimal 80 as the

1014
00:33:22,159 --> 00:33:23,039
address

1015
00:33:23,039 --> 00:33:25,120
so you have to read carefully and ask

1016
00:33:25,120 --> 00:33:27,039
are they giving me the 8-bit address or

1017
00:33:27,039 --> 00:33:29,679
the 7-bit address

1018
00:33:29,679 --> 00:33:31,360
most of the time the data sheets make it

1019
00:33:31,360 --> 00:33:33,200
clear just don't assume that it's one or

1020
00:33:33,200 --> 00:33:34,720
the other

1021
00:33:34,720 --> 00:33:36,720
so we'll take another look here that

1022
00:33:36,720 --> 00:33:38,880
same transaction we looked at earlier

1023
00:33:38,880 --> 00:33:40,720
the software the logic analyzer that i

1024
00:33:40,720 --> 00:33:42,240
had hooked up to this the software has

1025
00:33:42,240 --> 00:33:44,159
actually decoded this for us

1026
00:33:44,159 --> 00:33:47,440
so that byte 0x80 and hexadecimal is

1027
00:33:47,440 --> 00:33:48,559
actually a right

1028
00:33:48,559 --> 00:33:50,799
to address 40. so you can see at the

1029
00:33:50,799 --> 00:33:52,320
bottom there it's decoded it to

1030
00:33:52,320 --> 00:33:55,679
address right 40. the read write bit is

1031
00:33:55,679 --> 00:33:56,480
a zero

1032
00:33:56,480 --> 00:33:57,919
and then we have an acknowledge at the

1033
00:33:57,919 --> 00:33:59,840
end so even though the byte being sent

1034
00:33:59,840 --> 00:34:00,159
is

1035
00:34:00,159 --> 00:34:02,960
hexadecimal 80 the logic analyzer is

1036
00:34:02,960 --> 00:34:05,519
showing us that this is a write to 7-bit

1037
00:34:05,519 --> 00:34:06,000
address

1038
00:34:06,000 --> 00:34:08,000
40. i know it's a little bit confusing

1039
00:34:08,000 --> 00:34:09,280
to have these eight and seven-bit

1040
00:34:09,280 --> 00:34:10,719
addresses floating around but you get

1041
00:34:10,719 --> 00:34:12,000
used to it very quickly when you're

1042
00:34:12,000 --> 00:34:14,800
working with these devices

1043
00:34:14,800 --> 00:34:17,040
at the end we pull the act bit low

1044
00:34:17,040 --> 00:34:18,239
meaning the device

1045
00:34:18,239 --> 00:34:20,159
has responded to this address and it's

1046
00:34:20,159 --> 00:34:21,918
ready for the transaction which in this

1047
00:34:21,918 --> 00:34:24,560
case would be a write

1048
00:34:24,560 --> 00:34:26,399
so if we take a summary of everything

1049
00:34:26,399 --> 00:34:27,760
we've looked at so far

1050
00:34:27,760 --> 00:34:29,599
the controller starts any transaction

1051
00:34:29,599 --> 00:34:31,280
with a start condition

1052
00:34:31,280 --> 00:34:33,280
and then sends the address with the last

1053
00:34:33,280 --> 00:34:34,399
bit high or low

1054
00:34:34,399 --> 00:34:35,839
depending on whether it's a read or a

1055
00:34:35,839 --> 00:34:38,560
write the device either acknowledges it

1056
00:34:38,560 --> 00:34:39,918
by pulling the data line

1057
00:34:39,918 --> 00:34:42,879
low during the ack bit or if there's no

1058
00:34:42,879 --> 00:34:44,000
device there

1059
00:34:44,000 --> 00:34:46,879
the default state is for the lines to be

1060
00:34:46,879 --> 00:34:48,960
in the high state and therefore it would

1061
00:34:48,960 --> 00:34:49,199
be

1062
00:34:49,199 --> 00:34:50,960
not acknowledged which is one of the

1063
00:34:50,960 --> 00:34:52,079
nice things about having pull up

1064
00:34:52,079 --> 00:34:54,239
resistors and having the idle state

1065
00:34:54,239 --> 00:34:57,680
being high if nothing responds then it's

1066
00:34:57,680 --> 00:34:59,920
very easy to tell that because the line

1067
00:34:59,920 --> 00:35:01,440
will be high

1068
00:35:01,440 --> 00:35:03,119
controller will then continue depending

1069
00:35:03,119 --> 00:35:05,440
on the status of that acknowledged bit

1070
00:35:05,440 --> 00:35:07,520
it'll either keep going or if it got a

1071
00:35:07,520 --> 00:35:10,240
not acknowledged it'll handle that error

1072
00:35:10,240 --> 00:35:12,240
so let's actually look at some examples

1073
00:35:12,240 --> 00:35:14,720
for writing and reading data

1074
00:35:14,720 --> 00:35:16,480
only the controller is able to change

1075
00:35:16,480 --> 00:35:18,000
the state of the clock line so it's

1076
00:35:18,000 --> 00:35:20,240
always controlling the timing

1077
00:35:20,240 --> 00:35:22,800
this is very key and can be sort of

1078
00:35:22,800 --> 00:35:24,880
confusing when you're reading data from

1079
00:35:24,880 --> 00:35:26,079
a peripheral

1080
00:35:26,079 --> 00:35:28,400
you need to provide the clot pulses to

1081
00:35:28,400 --> 00:35:29,440
it it doesn't

1082
00:35:29,440 --> 00:35:32,800
control the clock line so

1083
00:35:32,800 --> 00:35:34,880
when the controller is the one putting

1084
00:35:34,880 --> 00:35:36,240
data on the bus

1085
00:35:36,240 --> 00:35:38,320
it is simultaneously setting both the

1086
00:35:38,320 --> 00:35:40,079
clock and data lines

1087
00:35:40,079 --> 00:35:41,920
but when the controller is reading data

1088
00:35:41,920 --> 00:35:43,839
it just sends out clock pulses and

1089
00:35:43,839 --> 00:35:46,000
whatever it sees coming back on the data

1090
00:35:46,000 --> 00:35:46,400
line

1091
00:35:46,400 --> 00:35:48,480
is the data that's being sent back from

1092
00:35:48,480 --> 00:35:50,640
the peripheral

1093
00:35:50,640 --> 00:35:52,880
when the controller is writing the

1094
00:35:52,880 --> 00:35:54,400
peripheral is the one that's sending an

1095
00:35:54,400 --> 00:35:55,040
acknowledge

1096
00:35:55,040 --> 00:35:56,720
because in that case the peripheral is

1097
00:35:56,720 --> 00:35:59,119
the one listening whichever device is

1098
00:35:59,119 --> 00:36:01,119
listening is the one that sends the

1099
00:36:01,119 --> 00:36:03,280
acknowledge of course that makes sense

1100
00:36:03,280 --> 00:36:05,680
whatever devices is listening is the one

1101
00:36:05,680 --> 00:36:06,720
that needs to say hey

1102
00:36:06,720 --> 00:36:09,119
yes i heard what you said and then vice

1103
00:36:09,119 --> 00:36:11,280
versa when the controller is reading

1104
00:36:11,280 --> 00:36:13,280
it sends acknowledge or not acknowledge

1105
00:36:13,280 --> 00:36:14,320
bits

1106
00:36:14,320 --> 00:36:16,480
so it sends out clock pulses gets data

1107
00:36:16,480 --> 00:36:18,320
back at the end of every byte

1108
00:36:18,320 --> 00:36:20,160
the peripheral is expecting the

1109
00:36:20,160 --> 00:36:22,000
controller to send and acknowledge

1110
00:36:22,000 --> 00:36:23,760
saying yes i want to read more bytes

1111
00:36:23,760 --> 00:36:25,040
from you or

1112
00:36:25,040 --> 00:36:26,800
not acknowledged saying i'm either done

1113
00:36:26,800 --> 00:36:28,240
reading bytes from you or there is

1114
00:36:28,240 --> 00:36:29,920
something wrong with what you sent

1115
00:36:29,920 --> 00:36:33,040
um uh yeah they'll

1116
00:36:33,040 --> 00:36:34,160
send a knack when they're finished

1117
00:36:34,160 --> 00:36:35,920
reading data peripherals will send a

1118
00:36:35,920 --> 00:36:36,320
knack

1119
00:36:36,320 --> 00:36:39,119
if there's been some sort of error so

1120
00:36:39,119 --> 00:36:41,200
let's look at a practical example

1121
00:36:41,200 --> 00:36:43,440
a microcontroller is connected to an

1122
00:36:43,440 --> 00:36:44,640
eprom

1123
00:36:44,640 --> 00:36:46,640
via an i squared c bus which is what

1124
00:36:46,640 --> 00:36:48,400
we've been looking at it wants to read

1125
00:36:48,400 --> 00:36:52,079
10 bytes from address 1 0 f4

1126
00:36:52,079 --> 00:36:53,760
inside the eeprom if you know anything

1127
00:36:53,760 --> 00:36:55,839
about how memory is organized

1128
00:36:55,839 --> 00:36:57,839
it's just a whole bunch of 8-bit bytes

1129
00:36:57,839 --> 00:36:59,760
in this case each one has a unique

1130
00:36:59,760 --> 00:37:00,640
address

1131
00:37:00,640 --> 00:37:03,680
so we want to read whatever 10 bytes

1132
00:37:03,680 --> 00:37:07,440
start at 1 0 f4 don't confuse the

1133
00:37:07,440 --> 00:37:08,400
address

1134
00:37:08,400 --> 00:37:11,200
inside the eeprom uh like the memory

1135
00:37:11,200 --> 00:37:12,640
address we want to read from don't

1136
00:37:12,640 --> 00:37:14,480
confuse that with the device address

1137
00:37:14,480 --> 00:37:16,000
which is always seven bits

1138
00:37:16,000 --> 00:37:20,079
or eight bits the eeprom's i squared c

1139
00:37:20,079 --> 00:37:21,839
device address is 50

1140
00:37:21,839 --> 00:37:24,079
which is actually one of the standard

1141
00:37:24,079 --> 00:37:26,160
addresses for eproms that's the seven

1142
00:37:26,160 --> 00:37:28,880
bit value so the transaction will take

1143
00:37:28,880 --> 00:37:30,640
place in two parts because we want to

1144
00:37:30,640 --> 00:37:31,599
read

1145
00:37:31,599 --> 00:37:33,359
so if we want to read something we first

1146
00:37:33,359 --> 00:37:35,200
have to write to the peripheral to tell

1147
00:37:35,200 --> 00:37:36,720
it what we want to do

1148
00:37:36,720 --> 00:37:38,160
microcontroller will send a start

1149
00:37:38,160 --> 00:37:40,720
condition with the right address

1150
00:37:40,720 --> 00:37:43,680
which is a zero that's hexadecimal five

1151
00:37:43,680 --> 00:37:44,160
zero

1152
00:37:44,160 --> 00:37:46,560
shifted to the left by one bit and then

1153
00:37:46,560 --> 00:37:48,400
the last bit is set to a zero because

1154
00:37:48,400 --> 00:37:50,320
this is the write

1155
00:37:50,320 --> 00:37:52,960
and then after it sends that address the

1156
00:37:52,960 --> 00:37:55,280
device address of a0 it then sends the

1157
00:37:55,280 --> 00:37:56,960
memory address that it wants to read

1158
00:37:56,960 --> 00:37:58,079
from in this case 1

1159
00:37:58,079 --> 00:38:02,400
0 f4 then it will send a repeated start

1160
00:38:02,400 --> 00:38:04,720
because we don't want another controller

1161
00:38:04,720 --> 00:38:07,040
on the bus potentially butting in

1162
00:38:07,040 --> 00:38:08,480
right after we've told the memory we

1163
00:38:08,480 --> 00:38:10,240
want to read from this address

1164
00:38:10,240 --> 00:38:12,320
if we were to send a stop it's possible

1165
00:38:12,320 --> 00:38:13,520
that another controller

1166
00:38:13,520 --> 00:38:15,760
might connect to that same device and

1167
00:38:15,760 --> 00:38:16,720
change

1168
00:38:16,720 --> 00:38:18,480
what address is being looked at we want

1169
00:38:18,480 --> 00:38:20,240
to make sure that doesn't happen

1170
00:38:20,240 --> 00:38:22,560
so we send a repeated start followed by

1171
00:38:22,560 --> 00:38:24,800
the read address which is just the right

1172
00:38:24,800 --> 00:38:26,960
address but the last bit is a one so in

1173
00:38:26,960 --> 00:38:27,839
this case it's

1174
00:38:27,839 --> 00:38:31,119
a one in hexadecimal the controller will

1175
00:38:31,119 --> 00:38:33,200
then send clock pulses

1176
00:38:33,200 --> 00:38:35,359
and the eeprom will send a bit for every

1177
00:38:35,359 --> 00:38:37,200
clock pulse that the controller

1178
00:38:37,200 --> 00:38:38,240
generates

1179
00:38:38,240 --> 00:38:40,000
at the end of each byte the controller

1180
00:38:40,000 --> 00:38:41,280
will send an ack

1181
00:38:41,280 --> 00:38:43,040
until the final byte when it will send a

1182
00:38:43,040 --> 00:38:44,720
knack and in this case we want to read

1183
00:38:44,720 --> 00:38:47,040
10 bytes so it'll send an acknowledge

1184
00:38:47,040 --> 00:38:48,720
and it'll count up until it gets to the

1185
00:38:48,720 --> 00:38:49,760
10th byte

1186
00:38:49,760 --> 00:38:52,160
then it'll set and not acknowledge let's

1187
00:38:52,160 --> 00:38:52,800
actually

1188
00:38:52,800 --> 00:38:56,079
take a look at this in pulse view so

1189
00:38:56,079 --> 00:38:58,640
this is actually the software that i

1190
00:38:58,640 --> 00:38:59,520
used

1191
00:38:59,520 --> 00:39:03,440
to probe this exact example transaction

1192
00:39:03,440 --> 00:39:06,000
i set up a microcontroller and an eeprom

1193
00:39:06,000 --> 00:39:07,920
and i actually did exactly what we just

1194
00:39:07,920 --> 00:39:09,760
discussed in that last slide

1195
00:39:09,760 --> 00:39:12,880
so if we zoom in here over on the left

1196
00:39:12,880 --> 00:39:14,960
you can see the bottom traces data

1197
00:39:14,960 --> 00:39:17,200
top traces clock we have a start

1198
00:39:17,200 --> 00:39:18,400
condition

1199
00:39:18,400 --> 00:39:21,680
both lines are high data line goes low

1200
00:39:21,680 --> 00:39:23,920
then the clock line goes low the

1201
00:39:23,920 --> 00:39:25,760
software has decoded that for us and

1202
00:39:25,760 --> 00:39:26,560
shows us

1203
00:39:26,560 --> 00:39:30,400
that's start then we send the first byte

1204
00:39:30,400 --> 00:39:33,119
which is an address and it's a write to

1205
00:39:33,119 --> 00:39:34,240
address 50.

1206
00:39:34,240 --> 00:39:37,599
so as you can see it's actually 1 0 1 0

1207
00:39:37,599 --> 00:39:40,960
which is a a0 as we determine is the

1208
00:39:40,960 --> 00:39:42,079
8-bit address

1209
00:39:42,079 --> 00:39:43,520
if we're writing and we get an

1210
00:39:43,520 --> 00:39:45,200
acknowledge back because during this

1211
00:39:45,200 --> 00:39:46,720
ninth clock pulse

1212
00:39:46,720 --> 00:39:49,760
right around here the controller would

1213
00:39:49,760 --> 00:39:51,280
let go of the bus

1214
00:39:51,280 --> 00:39:53,680
and then the peripheral will hold the

1215
00:39:53,680 --> 00:39:54,480
bus low

1216
00:39:54,480 --> 00:39:57,119
while this final clock pulse is sent out

1217
00:39:57,119 --> 00:39:58,880
then it will release it again

1218
00:39:58,880 --> 00:40:01,200
as soon as it sees the falling edge of

1219
00:40:01,200 --> 00:40:02,240
that

1220
00:40:02,240 --> 00:40:04,240
clock pulse and that's when the bus goes

1221
00:40:04,240 --> 00:40:06,240
high there for a moment

1222
00:40:06,240 --> 00:40:08,079
then the next two bytes that we write

1223
00:40:08,079 --> 00:40:09,760
are the address

1224
00:40:09,760 --> 00:40:11,839
that we want to read data from inside

1225
00:40:11,839 --> 00:40:13,440
the eprom so as you can see

1226
00:40:13,440 --> 00:40:16,240
one zero f4 is what's actually being

1227
00:40:16,240 --> 00:40:17,760
written

1228
00:40:17,760 --> 00:40:19,680
then because now we want to switch to

1229
00:40:19,680 --> 00:40:21,440
reading data we have to send

1230
00:40:21,440 --> 00:40:24,560
a repeated start condition we could as i

1231
00:40:24,560 --> 00:40:26,000
said in theory

1232
00:40:26,000 --> 00:40:28,480
we could send a stop condition followed

1233
00:40:28,480 --> 00:40:29,040
by

1234
00:40:29,040 --> 00:40:30,640
another start condition but then we're

1235
00:40:30,640 --> 00:40:33,119
risking another controller potentially

1236
00:40:33,119 --> 00:40:34,720
taking control of the bus from us which

1237
00:40:34,720 --> 00:40:36,800
is something we want to avoid

1238
00:40:36,800 --> 00:40:39,280
so we send another start condition again

1239
00:40:39,280 --> 00:40:41,520
it's the exact same as the usual start

1240
00:40:41,520 --> 00:40:44,640
we start with both lines high

1241
00:40:44,640 --> 00:40:46,960
the data line goes low first then the

1242
00:40:46,960 --> 00:40:48,640
clock line

1243
00:40:48,640 --> 00:40:52,160
then we're sending an address read from

1244
00:40:52,160 --> 00:40:54,160
address 50. so again

1245
00:40:54,160 --> 00:40:57,520
we have a1 as the address you can see it

1246
00:40:57,520 --> 00:40:59,440
actually separates out the read write

1247
00:40:59,440 --> 00:41:01,119
bit for us in this software which is

1248
00:41:01,119 --> 00:41:02,880
really nice

1249
00:41:02,880 --> 00:41:06,079
so this is actually byte a1

1250
00:41:06,079 --> 00:41:08,240
but the software has decoded it for us

1251
00:41:08,240 --> 00:41:10,880
into a read from address 50 we get an

1252
00:41:10,880 --> 00:41:11,520
acknowledge

1253
00:41:11,520 --> 00:41:13,359
because we know the eprom is at that

1254
00:41:13,359 --> 00:41:14,720
address

1255
00:41:14,720 --> 00:41:16,560
then we start reading bytes from it we

1256
00:41:16,560 --> 00:41:18,720
read the first byte

1257
00:41:18,720 --> 00:41:20,800
and then at the end of that byte you

1258
00:41:20,800 --> 00:41:22,079
know during this

1259
00:41:22,079 --> 00:41:25,280
section now as soon as we as soon as um

1260
00:41:25,280 --> 00:41:27,119
the device acknowledges

1261
00:41:27,119 --> 00:41:30,160
that read address the controller then

1262
00:41:30,160 --> 00:41:32,240
lets go of the data line and now the

1263
00:41:32,240 --> 00:41:34,640
peripheral is controlling the data line

1264
00:41:34,640 --> 00:41:36,720
the controller keeps sending out clock

1265
00:41:36,720 --> 00:41:37,920
pulses

1266
00:41:37,920 --> 00:41:39,440
and that's how the peripheral

1267
00:41:39,440 --> 00:41:41,040
synchronizes this but

1268
00:41:41,040 --> 00:41:43,200
from then on out the peripheral is

1269
00:41:43,200 --> 00:41:45,280
controlling the data line so it sends

1270
00:41:45,280 --> 00:41:46,480
out the first byte

1271
00:41:46,480 --> 00:41:47,760
which in this case happens to be

1272
00:41:47,760 --> 00:41:49,680
hexadecimal 48

1273
00:41:49,680 --> 00:41:52,240
then at the end it lets go of the data

1274
00:41:52,240 --> 00:41:52,880
line

1275
00:41:52,880 --> 00:41:54,960
and the controller then sends the

1276
00:41:54,960 --> 00:41:56,480
acknowledged pulse because now the

1277
00:41:56,480 --> 00:41:57,680
controller is the one

1278
00:41:57,680 --> 00:42:01,119
listening so it lets go the controller

1279
00:42:01,119 --> 00:42:02,319
keeps the data line

1280
00:42:02,319 --> 00:42:04,880
low through that ninth clock pulse and

1281
00:42:04,880 --> 00:42:06,400
that's an acknowledge and that's us

1282
00:42:06,400 --> 00:42:08,640
saying we want to read another byte

1283
00:42:08,640 --> 00:42:11,920
it keeps doing this one two three four

1284
00:42:11,920 --> 00:42:15,359
five six seven eight nine times

1285
00:42:15,359 --> 00:42:19,040
then we get to the final byte

1286
00:42:19,040 --> 00:42:21,440
this final byte same thing happens we

1287
00:42:21,440 --> 00:42:23,839
read it out but at the end

1288
00:42:23,839 --> 00:42:26,480
the controller just lets the line return

1289
00:42:26,480 --> 00:42:28,160
to its idle state

1290
00:42:28,160 --> 00:42:30,160
it sends another clock pulse and the

1291
00:42:30,160 --> 00:42:31,920
device now you know it's

1292
00:42:31,920 --> 00:42:34,800
not acknowledged so the device stops

1293
00:42:34,800 --> 00:42:35,920
sending data

1294
00:42:35,920 --> 00:42:37,760
and we're done with this transaction so

1295
00:42:37,760 --> 00:42:39,920
we send a stop condition

1296
00:42:39,920 --> 00:42:43,200
which again we start with both lines low

1297
00:42:43,200 --> 00:42:46,560
we set the clock line high then we set

1298
00:42:46,560 --> 00:42:47,680
the data line high

1299
00:42:47,680 --> 00:42:49,200
and that's the stop condition as you can

1300
00:42:49,200 --> 00:42:51,280
see it's been decoded as for us

1301
00:42:51,280 --> 00:42:53,680
it's decoded it for us there as a p for

1302
00:42:53,680 --> 00:42:55,839
the stop condition so that's a full

1303
00:42:55,839 --> 00:42:58,480
transaction reading 10 bytes from an

1304
00:42:58,480 --> 00:42:59,760
eeprom

1305
00:42:59,760 --> 00:43:01,839
when you look at it piece by piece it's

1306
00:43:01,839 --> 00:43:03,520
actually quite a simple protocol as you

1307
00:43:03,520 --> 00:43:04,160
can see

1308
00:43:04,160 --> 00:43:06,319
we write an address depending on the

1309
00:43:06,319 --> 00:43:08,319
type of device

1310
00:43:08,319 --> 00:43:10,319
it'll change what we're actually writing

1311
00:43:10,319 --> 00:43:12,400
to the device but

1312
00:43:12,400 --> 00:43:14,880
we write whatever we want we send a

1313
00:43:14,880 --> 00:43:16,160
repeated start

1314
00:43:16,160 --> 00:43:18,160
or sometimes a stop and then another

1315
00:43:18,160 --> 00:43:20,160
start and then we read

1316
00:43:20,160 --> 00:43:22,480
from that same address and it sends us

1317
00:43:22,480 --> 00:43:23,440
whatever data

1318
00:43:23,440 --> 00:43:25,680
in this case it's data from an eeprom it

1319
00:43:25,680 --> 00:43:26,480
could be

1320
00:43:26,480 --> 00:43:28,400
temperature sensor data it could be

1321
00:43:28,400 --> 00:43:29,760
barometric pressure

1322
00:43:29,760 --> 00:43:32,800
data it could be anything and when you

1323
00:43:32,800 --> 00:43:34,880
have multiple devices on the bus

1324
00:43:34,880 --> 00:43:36,480
all you have to do is change what

1325
00:43:36,480 --> 00:43:38,079
address that you're reading and writing

1326
00:43:38,079 --> 00:43:39,680
from and you're talking to a completely

1327
00:43:39,680 --> 00:43:40,000
different

1328
00:43:40,000 --> 00:43:43,359
device again i want to point out that

1329
00:43:43,359 --> 00:43:43,680
the

1330
00:43:43,680 --> 00:43:45,359
clock pulses here as you can see are

1331
00:43:45,359 --> 00:43:47,599
very regular if we actually zoom in

1332
00:43:47,599 --> 00:43:49,280
and we use the cursors to take a

1333
00:43:49,280 --> 00:43:50,640
measurement

1334
00:43:50,640 --> 00:43:53,520
from this end of one clock pulse to this

1335
00:43:53,520 --> 00:43:55,599
end of the next one

1336
00:43:55,599 --> 00:43:57,200
you can see we're running at about 100

1337
00:43:57,200 --> 00:44:00,400
kilohertz 102.5 kilohertz so this is

1338
00:44:00,400 --> 00:44:01,520
running at

1339
00:44:01,520 --> 00:44:04,000
uh the lowest i squared c speed but

1340
00:44:04,000 --> 00:44:05,920
that's perfectly fine

1341
00:44:05,920 --> 00:44:08,480
uh you know it's not super fast we end

1342
00:44:08,480 --> 00:44:08,960
up

1343
00:44:08,960 --> 00:44:12,800
reading 10 bytes in

1344
00:44:12,960 --> 00:44:15,280
oh you know about just over a

1345
00:44:15,280 --> 00:44:16,160
millisecond

1346
00:44:16,160 --> 00:44:18,960
1.3 milliseconds it might be too slow

1347
00:44:18,960 --> 00:44:20,720
for some applications so you can either

1348
00:44:20,720 --> 00:44:22,319
increase the speed if the device

1349
00:44:22,319 --> 00:44:23,760
supports it or you might need to choose

1350
00:44:23,760 --> 00:44:25,359
a different serial bus this is just an

1351
00:44:25,359 --> 00:44:26,960
example

1352
00:44:26,960 --> 00:44:28,400
so whenever you're working with i

1353
00:44:28,400 --> 00:44:30,880
squared c having a logic analyzer and

1354
00:44:30,880 --> 00:44:32,560
having software like this

1355
00:44:32,560 --> 00:44:34,400
makes it really easy to visualize what's

1356
00:44:34,400 --> 00:44:35,599
going on on the bus

1357
00:44:35,599 --> 00:44:37,440
and it makes it really easy to make

1358
00:44:37,440 --> 00:44:39,040
changes uh

1359
00:44:39,040 --> 00:44:40,960
and you can see the changes that you've

1360
00:44:40,960 --> 00:44:42,800
made being reflected in whatever is

1361
00:44:42,800 --> 00:44:44,880
being sampled on the bus by the logic

1362
00:44:44,880 --> 00:44:46,240
analyzer so

1363
00:44:46,240 --> 00:44:48,319
let's go back over to the slides and

1364
00:44:48,319 --> 00:44:50,079
finish up our presentation all right so

1365
00:44:50,079 --> 00:44:51,839
we took a look at pulseview now let's

1366
00:44:51,839 --> 00:44:52,480
sort of

1367
00:44:52,480 --> 00:44:53,920
summarize everything that we've gone

1368
00:44:53,920 --> 00:44:56,079
over i squared c

1369
00:44:56,079 --> 00:44:58,160
transactions are made up of sequences of

1370
00:44:58,160 --> 00:45:00,240
events on the bus

1371
00:45:00,240 --> 00:45:01,839
start condition is how we start

1372
00:45:01,839 --> 00:45:04,319
everything followed by the address of

1373
00:45:04,319 --> 00:45:05,440
the device that we want to

1374
00:45:05,440 --> 00:45:07,920
talk to and it's a read or write bit

1375
00:45:07,920 --> 00:45:09,839
depending on what kind of transaction it

1376
00:45:09,839 --> 00:45:10,720
is

1377
00:45:10,720 --> 00:45:12,720
then we send the data to be read or

1378
00:45:12,720 --> 00:45:14,240
written depending on what direction it

1379
00:45:14,240 --> 00:45:15,040
is

1380
00:45:15,040 --> 00:45:16,480
there's an acknowledge or not

1381
00:45:16,480 --> 00:45:18,079
acknowledge for each byte

1382
00:45:18,079 --> 00:45:20,079
sent by whichever side is currently

1383
00:45:20,079 --> 00:45:21,520
listening

1384
00:45:21,520 --> 00:45:24,319
at the end we have a stop condition or a

1385
00:45:24,319 --> 00:45:26,960
repeated start in some cases

1386
00:45:26,960 --> 00:45:28,800
bus arbitration is automatic and

1387
00:45:28,800 --> 00:45:30,800
non-destructive because of the fact that

1388
00:45:30,800 --> 00:45:33,119
we use pull-up resistors

1389
00:45:33,119 --> 00:45:35,359
that takes care of bus arbitration for

1390
00:45:35,359 --> 00:45:37,599
us essentially as long as every device

1391
00:45:37,599 --> 00:45:40,319
always looks at the bus after it's

1392
00:45:40,319 --> 00:45:42,400
changed it to make sure that it's in the

1393
00:45:42,400 --> 00:45:44,560
state that it expects it to be

1394
00:45:44,560 --> 00:45:46,240
and if it's not in the state that it

1395
00:45:46,240 --> 00:45:47,599
expects it to be

1396
00:45:47,599 --> 00:45:50,240
it has to stop and wait for a stop

1397
00:45:50,240 --> 00:45:52,160
condition to appear on the bus before it

1398
00:45:52,160 --> 00:45:52,480
can

1399
00:45:52,480 --> 00:45:56,079
try communicating again most of the time

1400
00:45:56,079 --> 00:45:58,319
if you're not doing serious embedded

1401
00:45:58,319 --> 00:45:59,280
device

1402
00:45:59,280 --> 00:46:02,000
work where you have multiple controllers

1403
00:46:02,000 --> 00:46:03,440
on the same bus

1404
00:46:03,440 --> 00:46:05,839
and tons of peripherals you're very

1405
00:46:05,839 --> 00:46:07,359
rarely going to have to deal with bus

1406
00:46:07,359 --> 00:46:08,960
arbitration

1407
00:46:08,960 --> 00:46:11,200
in the majority of systems it's going to

1408
00:46:11,200 --> 00:46:13,040
be a single microcontroller

1409
00:46:13,040 --> 00:46:15,359
talking to a variety of sensors or

1410
00:46:15,359 --> 00:46:17,119
memories or something

1411
00:46:17,119 --> 00:46:18,880
but again it's good to understand how it

1412
00:46:18,880 --> 00:46:20,800
works and this same

1413
00:46:20,800 --> 00:46:22,640
benefit from pull-up resistors as

1414
00:46:22,640 --> 00:46:24,240
apparent in the acknowledge not

1415
00:46:24,240 --> 00:46:25,200
acknowledge

1416
00:46:25,200 --> 00:46:27,359
by default and not acknowledge will

1417
00:46:27,359 --> 00:46:29,440
always be sent

1418
00:46:29,440 --> 00:46:32,240
the chip actually has to intervene pull

1419
00:46:32,240 --> 00:46:33,440
the bus low

1420
00:46:33,440 --> 00:46:35,680
to say that it is acknowledging which is

1421
00:46:35,680 --> 00:46:37,440
important because

1422
00:46:37,440 --> 00:46:40,400
that makes it sort of by default error

1423
00:46:40,400 --> 00:46:40,880
proof

1424
00:46:40,880 --> 00:46:42,480
if something goes wrong you're always

1425
00:46:42,480 --> 00:46:44,880
going to get a not acknowledged back

1426
00:46:44,880 --> 00:46:46,000
you don't have to worry about

1427
00:46:46,000 --> 00:46:47,440
accidentally getting something on the

1428
00:46:47,440 --> 00:46:49,040
bus that you don't expect

1429
00:46:49,040 --> 00:46:51,280
because the idle state is forced by

1430
00:46:51,280 --> 00:46:52,960
those pull-up resistors which can't do

1431
00:46:52,960 --> 00:46:53,839
anything but

1432
00:46:53,839 --> 00:46:55,440
pull the bus high there's no active

1433
00:46:55,440 --> 00:46:57,680
device

1434
00:46:57,680 --> 00:46:59,760
that pulls it high which is really

1435
00:46:59,760 --> 00:47:01,520
interesting so either device can be

1436
00:47:01,520 --> 00:47:02,960
talking or listening

1437
00:47:02,960 --> 00:47:05,200
as we said either side might be sending

1438
00:47:05,200 --> 00:47:07,200
data but the controller is always in

1439
00:47:07,200 --> 00:47:08,960
control the clock line

1440
00:47:08,960 --> 00:47:11,119
so as we just saw in pulseview even when

1441
00:47:11,119 --> 00:47:13,599
we were reading bytes from the eeprom

1442
00:47:13,599 --> 00:47:15,200
the controller was actually the one

1443
00:47:15,200 --> 00:47:17,520
still generating those clock pulses

1444
00:47:17,520 --> 00:47:19,839
and then it was just allowing the

1445
00:47:19,839 --> 00:47:20,960
peripheral to

1446
00:47:20,960 --> 00:47:23,359
change the state of the data line and

1447
00:47:23,359 --> 00:47:25,440
then at the end of each byte

1448
00:47:25,440 --> 00:47:27,119
it would send an acknowledge saying yes

1449
00:47:27,119 --> 00:47:29,520
we want more data from you

1450
00:47:29,520 --> 00:47:31,920
only the controller can start and end

1451
00:47:31,920 --> 00:47:32,800
transactions

1452
00:47:32,800 --> 00:47:35,599
again the peripherals can't do anything

1453
00:47:35,599 --> 00:47:36,640
unless they see

1454
00:47:36,640 --> 00:47:40,079
a start and then their valid address on

1455
00:47:40,079 --> 00:47:41,200
the bus

1456
00:47:41,200 --> 00:47:43,920
followed by whatever happens and then a

1457
00:47:43,920 --> 00:47:46,160
stop condition or repeated start in some

1458
00:47:46,160 --> 00:47:48,240
cases

1459
00:47:48,240 --> 00:47:51,280
that's it for this presentation

1460
00:47:51,280 --> 00:47:52,960
i went over things you know tried to

1461
00:47:52,960 --> 00:47:54,480
squeeze it into an hour here a little

1462
00:47:54,480 --> 00:47:56,000
under an hour

1463
00:47:56,000 --> 00:47:58,079
uh the first question and answer session

1464
00:47:58,079 --> 00:47:59,599
is going to be tomorrow night

1465
00:47:59,599 --> 00:48:02,960
thursday and it's going to

1466
00:48:02,960 --> 00:48:04,640
cover any questions you have we're going

1467
00:48:04,640 --> 00:48:06,400
to be doing a live session

1468
00:48:06,400 --> 00:48:08,640
so if you have any questions go back

1469
00:48:08,640 --> 00:48:10,400
through the presentation write down any

1470
00:48:10,400 --> 00:48:11,680
questions you have or anything you

1471
00:48:11,680 --> 00:48:12,559
missed

1472
00:48:12,559 --> 00:48:14,559
and i'll be more than happy to answer

1473
00:48:14,559 --> 00:48:16,960
any questions you have

1474
00:48:16,960 --> 00:48:19,440
if you want we can take a look again at

1475
00:48:19,440 --> 00:48:21,599
that example transaction we can look at

1476
00:48:21,599 --> 00:48:21,920
it

1477
00:48:21,920 --> 00:48:24,400
in more in depth if you have any

1478
00:48:24,400 --> 00:48:26,000
questions later

1479
00:48:26,000 --> 00:48:28,079
after this course is complete you can

1480
00:48:28,079 --> 00:48:30,079
always email me at the email address at

1481
00:48:30,079 --> 00:48:32,400
the first slide i can't promise

1482
00:48:32,400 --> 00:48:34,160
that i'm going to be able to give

1483
00:48:34,160 --> 00:48:35,760
everyone a full

1484
00:48:35,760 --> 00:48:37,280
you know detailed answer but i'll always

1485
00:48:37,280 --> 00:48:38,480
be able to point you in the right

1486
00:48:38,480 --> 00:48:39,920
direction

1487
00:48:39,920 --> 00:48:41,760
and speaking of which there's a book

1488
00:48:41,760 --> 00:48:43,520
that if you're interested in learning

1489
00:48:43,520 --> 00:48:46,160
more about the i squared c bus

1490
00:48:46,160 --> 00:48:47,680
we're going to look at it again next

1491
00:48:47,680 --> 00:48:49,359
week there's a bus called

1492
00:48:49,359 --> 00:48:51,920
mastering the i squared c bus by an

1493
00:48:51,920 --> 00:48:52,640
amazing

1494
00:48:52,640 --> 00:48:56,079
electronics engineer named vincent hempe

1495
00:48:56,079 --> 00:48:58,559
if you're interested in buying that book

1496
00:48:58,559 --> 00:49:00,400
it's available online it's no longer in

1497
00:49:00,400 --> 00:49:02,400
print so it's a little bit pricey but

1498
00:49:02,400 --> 00:49:05,520
it is the textbook on i squared c uh so

1499
00:49:05,520 --> 00:49:07,599
i highly recommend that

1500
00:49:07,599 --> 00:49:09,119
and next week we'll be going into

1501
00:49:09,119 --> 00:49:10,800
software examples so

1502
00:49:10,800 --> 00:49:12,720
uh hopefully if you want to follow along

1503
00:49:12,720 --> 00:49:14,839
with those examples you'll have your

1504
00:49:14,839 --> 00:49:16,000
msp430

1505
00:49:16,000 --> 00:49:17,920
launch pad we're going to be going over

1506
00:49:17,920 --> 00:49:20,400
some example msp430

1507
00:49:20,400 --> 00:49:22,800
code looking at how you actually use an

1508
00:49:22,800 --> 00:49:24,800
i squared c peripheral to send

1509
00:49:24,800 --> 00:49:28,000
a i squared c block inside a

1510
00:49:28,000 --> 00:49:29,680
microcontroller to communicate with

1511
00:49:29,680 --> 00:49:30,640
peripherals

1512
00:49:30,640 --> 00:49:32,559
and actually do something with it which

1513
00:49:32,559 --> 00:49:34,319
is the whole point of learning i squared

1514
00:49:34,319 --> 00:49:35,839
c

1515
00:49:35,839 --> 00:49:38,800
i'm going to put a link to these slides

1516
00:49:38,800 --> 00:49:40,319
so you can download them

1517
00:49:40,319 --> 00:49:43,119
on the project page for this course so

1518
00:49:43,119 --> 00:49:44,000
if you want to go back

1519
00:49:44,000 --> 00:49:45,520
through the slides and take a closer

1520
00:49:45,520 --> 00:49:47,119
look at anything you're more than

1521
00:49:47,119 --> 00:49:48,400
welcome to do that

1522
00:49:48,400 --> 00:49:49,839
the same thing will be true with the

1523
00:49:49,839 --> 00:49:52,000
software it'll be posted into a

1524
00:49:52,000 --> 00:49:54,559
get lab repository where anyone can take

1525
00:49:54,559 --> 00:49:56,400
a look at the code

1526
00:49:56,400 --> 00:49:58,079
and we'll be going over that in detail

1527
00:49:58,079 --> 00:50:01,839
next week so thank you so much for

1528
00:50:02,760 --> 00:50:05,760
watching

