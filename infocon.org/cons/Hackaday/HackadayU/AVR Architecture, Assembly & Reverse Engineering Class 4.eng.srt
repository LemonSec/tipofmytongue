1
00:00:00,000 --> 00:00:08,000
[Music]

2
00:00:08,000 --> 00:00:08,480
so

3
00:00:08,480 --> 00:00:11,599
uh hello everybody uh welcome back to

4
00:00:11,599 --> 00:00:14,320
our wow it's already lesson number four

5
00:00:14,320 --> 00:00:14,880
of the

6
00:00:14,880 --> 00:00:18,080
uh avr reverse engineering and whatever

7
00:00:18,080 --> 00:00:19,840
class actually today it's going to be

8
00:00:19,840 --> 00:00:22,080
mostly about reverse engineering

9
00:00:22,080 --> 00:00:25,199
um great to see everyone

10
00:00:25,199 --> 00:00:28,640
coming back and i had an

11
00:00:28,640 --> 00:00:30,960
interesting chat this week with uh one

12
00:00:30,960 --> 00:00:32,960
of the folks who is taking this course

13
00:00:32,960 --> 00:00:33,360
uh

14
00:00:33,360 --> 00:00:36,399
he pinged me on this card and uh told me

15
00:00:36,399 --> 00:00:37,040
that he's

16
00:00:37,040 --> 00:00:40,879
starting to um use the knowledge that

17
00:00:40,879 --> 00:00:43,840
uh about the avr architecture to solve

18
00:00:43,840 --> 00:00:44,480
some

19
00:00:44,480 --> 00:00:47,520
ctf uh some ctf challenge capture the

20
00:00:47,520 --> 00:00:49,200
flag a security challenge

21
00:00:49,200 --> 00:00:52,239
using um avr that's

22
00:00:52,239 --> 00:00:55,360
pretty cool to know so

23
00:00:55,360 --> 00:00:58,320
if you have any stories like that like

24
00:00:58,320 --> 00:00:58,719
what

25
00:00:58,719 --> 00:01:00,879
are you doing with this knowledge please

26
00:01:00,879 --> 00:01:03,359
uh let me know i love hearing about

27
00:01:03,359 --> 00:01:03,920
those

28
00:01:03,920 --> 00:01:07,760
stories and your success stories um

29
00:01:07,760 --> 00:01:10,560
mikhail says that audio isn't working is

30
00:01:10,560 --> 00:01:12,799
it just him or uh did i just

31
00:01:12,799 --> 00:01:15,840
speak to myself this entire time okay

32
00:01:15,840 --> 00:01:16,799
thank you giver

33
00:01:16,799 --> 00:01:20,159
so mikhail a problem on your head and

34
00:01:20,159 --> 00:01:22,720
hi nikati and uh yeah i start

35
00:01:22,720 --> 00:01:24,640
recognizing the names that

36
00:01:24,640 --> 00:01:26,560
because they're you're here every every

37
00:01:26,560 --> 00:01:27,759
week

38
00:01:27,759 --> 00:01:31,200
um okay let me share my screen and let's

39
00:01:31,200 --> 00:01:34,799
jump into the water so screen sharing uh

40
00:01:34,799 --> 00:01:37,920
check you should be seeing my screen now

41
00:01:37,920 --> 00:01:39,920
with the infamous document where you

42
00:01:39,920 --> 00:01:40,960
have all those

43
00:01:40,960 --> 00:01:43,920
um all the stuff we have been doing over

44
00:01:43,920 --> 00:01:45,600
the past few weeks

45
00:01:45,600 --> 00:01:49,360
and um before we get started

46
00:01:49,360 --> 00:01:52,720
i uh actually uh let's

47
00:01:52,720 --> 00:01:55,439
yeah let's reopen this because i want to

48
00:01:55,439 --> 00:01:57,119
start from scratch

49
00:01:57,119 --> 00:02:00,240
not what we had last week so um

50
00:02:00,240 --> 00:02:02,960
yeah and let's make the font size a bit

51
00:02:02,960 --> 00:02:04,799
bigger

52
00:02:04,799 --> 00:02:08,160
okay so uh one announcement small

53
00:02:08,160 --> 00:02:09,360
announcement about

54
00:02:09,360 --> 00:02:12,560
uh writing assembly in walkway so now

55
00:02:12,560 --> 00:02:16,080
uh last week if you remember uh we wrote

56
00:02:16,080 --> 00:02:19,040
this uh max 8 function it's in the

57
00:02:19,040 --> 00:02:21,680
document i copied it into the document

58
00:02:21,680 --> 00:02:24,640
and unfortunately writing assembly code

59
00:02:24,640 --> 00:02:26,879
we didn't get all those fancy colors

60
00:02:26,879 --> 00:02:27,599
that we

61
00:02:27,599 --> 00:02:31,280
get when we write arduino or c code so

62
00:02:31,280 --> 00:02:36,000
uh i'm happy to announce that from

63
00:02:36,000 --> 00:02:38,640
sometime this week whenever you write

64
00:02:38,640 --> 00:02:40,239
assembly code you have syntax

65
00:02:40,239 --> 00:02:41,920
highlighting so i added the

66
00:02:41,920 --> 00:02:45,040
syntax highlighting to

67
00:02:45,040 --> 00:02:48,080
this assembly editor and let me just

68
00:02:48,080 --> 00:02:50,160
quickly open the chat because i see

69
00:02:50,160 --> 00:02:51,680
there are a few more messages

70
00:02:51,680 --> 00:02:55,519
and i somehow i don't see them

71
00:02:55,519 --> 00:02:58,959
so where's the chat it's hidden

72
00:02:58,959 --> 00:03:02,560
okay um yeah

73
00:03:02,560 --> 00:03:04,800
why can't i see i don't know the chat

74
00:03:04,800 --> 00:03:06,480
has disappeared interesting

75
00:03:06,480 --> 00:03:09,760
anyway uh i will look at it uh if

76
00:03:09,760 --> 00:03:13,840
there are like the qri session um

77
00:03:13,840 --> 00:03:16,720
so uh a quick recap of what we did last

78
00:03:16,720 --> 00:03:18,159
week

79
00:03:18,159 --> 00:03:20,720
we started writing assembly code without

80
00:03:20,720 --> 00:03:21,200
um

81
00:03:21,200 --> 00:03:24,239
this uh asm statement and you were super

82
00:03:24,239 --> 00:03:25,280
happy about it

83
00:03:25,280 --> 00:03:28,080
and i can see why uh no longer awkward

84
00:03:28,080 --> 00:03:28,879
syntax

85
00:03:28,879 --> 00:03:32,239
and compare this to like

86
00:03:32,239 --> 00:03:34,400
i don't think we have it here but we had

87
00:03:34,400 --> 00:03:36,560
like the same version with asm and it

88
00:03:36,560 --> 00:03:37,200
was like

89
00:03:37,200 --> 00:03:40,239
uh four times more lines

90
00:03:40,239 --> 00:03:43,519
um and today i'm going to

91
00:03:43,519 --> 00:03:46,159
uh we are going to learn about two new

92
00:03:46,159 --> 00:03:46,879
instructions

93
00:03:46,879 --> 00:03:49,599
and then uh super fascinating stuff how

94
00:03:49,599 --> 00:03:50,799
to actually

95
00:03:50,799 --> 00:03:52,640
uh read the code that the compiler

96
00:03:52,640 --> 00:03:55,040
creates and how to debug stuff

97
00:03:55,040 --> 00:03:58,480
um and reverse engineering um

98
00:03:58,480 --> 00:04:01,840
okay so uh quick recap let's

99
00:04:01,840 --> 00:04:05,439
uh just get to the same state as we were

100
00:04:05,439 --> 00:04:07,519
last week when we had this max 8

101
00:04:07,519 --> 00:04:08,400
function

102
00:04:08,400 --> 00:04:10,799
we need to define it in the c code and

103
00:04:10,799 --> 00:04:12,000
then let's just

104
00:04:12,000 --> 00:04:14,560
do a quick sanity and see that uh it

105
00:04:14,560 --> 00:04:15,920
still works

106
00:04:15,920 --> 00:04:20,160
uh so max between 50 and 55 that's 55.

107
00:04:20,160 --> 00:04:23,600
uh so uh probably it still works and

108
00:04:23,600 --> 00:04:27,120
um oh i got a chat back cool

109
00:04:27,120 --> 00:04:31,120
um somehow

110
00:04:31,770 --> 00:04:33,919
[Music]

111
00:04:33,919 --> 00:04:36,240
yeah cool comment from mikhail there is

112
00:04:36,240 --> 00:04:38,080
no manual for this because it's

113
00:04:38,080 --> 00:04:40,720
changing too fast but actually for there

114
00:04:40,720 --> 00:04:42,000
is one feature i'm going to show

115
00:04:42,000 --> 00:04:43,840
you today and i prepared a manual

116
00:04:43,840 --> 00:04:45,600
exactly for you so

117
00:04:45,600 --> 00:04:49,280
i hope that you like it um

118
00:04:49,280 --> 00:04:52,800
and uh okay

119
00:04:52,800 --> 00:04:56,000
so we have this function max eight

120
00:04:56,000 --> 00:04:59,360
it's pretty simple and i want to write

121
00:04:59,360 --> 00:05:01,680
uh a more complex function we are going

122
00:05:01,680 --> 00:05:02,720
to write

123
00:05:02,720 --> 00:05:05,520
fibonacci so uh you know fibonacci is

124
00:05:05,520 --> 00:05:07,440
like the sequence where

125
00:05:07,440 --> 00:05:12,639
uh fibonacci and is just uh fibonacci

126
00:05:12,639 --> 00:05:16,160
n minus one and plus

127
00:05:16,160 --> 00:05:20,560
fib n minus two uh and fibonacci of zero

128
00:05:20,560 --> 00:05:22,320
is zero and fibonacci

129
00:05:22,320 --> 00:05:25,440
of one is one and it's basically a

130
00:05:25,440 --> 00:05:28,400
simple sinter a simple uh sequence that

131
00:05:28,400 --> 00:05:29,360
uh

132
00:05:29,360 --> 00:05:32,560
um i think it's very famous for

133
00:05:32,560 --> 00:05:36,639
uh teaching recursion so um

134
00:05:36,639 --> 00:05:39,919
we know how to call functions um

135
00:05:39,919 --> 00:05:42,639
i think we did it last week uh with uh

136
00:05:42,639 --> 00:05:44,240
the call instruction

137
00:05:44,240 --> 00:05:47,280
so ideally we should be able to create

138
00:05:47,280 --> 00:05:52,320
um a function that calls itself and um

139
00:05:52,320 --> 00:05:55,600
and uh calculates the fibonacci sequence

140
00:05:55,600 --> 00:05:57,680
so let's get started so we are writing

141
00:05:57,680 --> 00:05:58,639
fibo

142
00:05:58,639 --> 00:06:02,080
and uh because it's a function we want

143
00:06:02,080 --> 00:06:03,919
the red instruction to return to the

144
00:06:03,919 --> 00:06:04,880
color

145
00:06:04,880 --> 00:06:08,160
and we did this last week but

146
00:06:08,160 --> 00:06:10,319
so i'm not going to repeat it all but we

147
00:06:10,319 --> 00:06:11,199
know that uh

148
00:06:11,199 --> 00:06:14,160
if it's get it gets one argument it will

149
00:06:14,160 --> 00:06:16,639
be passed in r24 and the result is

150
00:06:16,639 --> 00:06:17,919
expected in artwork

151
00:06:17,919 --> 00:06:21,680
r24 as well just like with um

152
00:06:21,680 --> 00:06:25,120
max 8 and we also need

153
00:06:25,120 --> 00:06:27,120
to tell the assembler to export the

154
00:06:27,120 --> 00:06:28,400
symbol so the

155
00:06:28,400 --> 00:06:31,120
c code will be able to find it and

156
00:06:31,120 --> 00:06:31,759
finally

157
00:06:31,759 --> 00:06:34,720
we need to declare it in the c code and

158
00:06:34,720 --> 00:06:35,520
it takes

159
00:06:35,520 --> 00:06:38,479
only one argument by the way you can

160
00:06:38,479 --> 00:06:40,160
also write the name of the argument

161
00:06:40,160 --> 00:06:41,360
that's optional but

162
00:06:41,360 --> 00:06:44,479
it makes it a bit more readable

163
00:06:44,479 --> 00:06:46,840
it doesn't do anything just a sort of

164
00:06:46,840 --> 00:06:48,000
documentation

165
00:06:48,000 --> 00:06:51,120
so now we have defined fibo we can call

166
00:06:51,120 --> 00:06:51,520
it

167
00:06:51,520 --> 00:06:54,720
uh let's say we want to print

168
00:06:54,720 --> 00:06:58,560
the first number so i want to ester

169
00:06:58,560 --> 00:07:02,639
210 serial println fibo

170
00:07:02,639 --> 00:07:05,840
i and let's remove this

171
00:07:05,840 --> 00:07:09,199
one and right now the the function does

172
00:07:09,199 --> 00:07:09,759
nothing

173
00:07:09,759 --> 00:07:12,720
so we expect the arg1 to be the same as

174
00:07:12,720 --> 00:07:13,680
the result so

175
00:07:13,680 --> 00:07:16,160
it should bring print zero to nine let's

176
00:07:16,160 --> 00:07:17,680
see that in action

177
00:07:17,680 --> 00:07:20,880
and hooray we got zero to nine exciting

178
00:07:20,880 --> 00:07:24,160
or not so um so now

179
00:07:24,160 --> 00:07:27,360
um let's write down a plan of what we're

180
00:07:27,360 --> 00:07:28,479
going to do so

181
00:07:28,479 --> 00:07:31,919
uh we go we want to call uh uh

182
00:07:31,919 --> 00:07:35,520
fifa n minus one fibo

183
00:07:35,520 --> 00:07:38,960
n minus two uh add them

184
00:07:38,960 --> 00:07:41,680
and that's the result but we also want

185
00:07:41,680 --> 00:07:42,840
to check

186
00:07:42,840 --> 00:07:46,000
check if

187
00:07:46,000 --> 00:07:49,599
n is zero then return zero

188
00:07:49,599 --> 00:07:54,080
check if n is one then return one

189
00:07:54,080 --> 00:07:56,479
so uh let's start by just uh dealing

190
00:07:56,479 --> 00:07:58,160
with these two edge cases

191
00:07:58,160 --> 00:08:02,240
so uh it's just compare immediate uh

192
00:08:02,240 --> 00:08:06,560
r24 with zero and branch if equal

193
00:08:06,560 --> 00:08:09,520
uh we did uh you probably remember this

194
00:08:09,520 --> 00:08:09,840
uh

195
00:08:09,840 --> 00:08:13,199
branch table uh somewhere here from last

196
00:08:13,199 --> 00:08:13,599
week

197
00:08:13,599 --> 00:08:17,039
so we want to check if the two

198
00:08:17,039 --> 00:08:19,599
registers or the two values are equal so

199
00:08:19,599 --> 00:08:22,319
preq

200
00:08:22,720 --> 00:08:25,280
if equal and then we we need to define a

201
00:08:25,280 --> 00:08:26,879
label let's call it

202
00:08:26,879 --> 00:08:31,199
one so branch to one branch four to one

203
00:08:31,199 --> 00:08:34,479
um and in this case we don't really need

204
00:08:34,479 --> 00:08:36,559
to specify the return value because

205
00:08:36,559 --> 00:08:40,240
uh it's already in r24 if we have zero

206
00:08:40,240 --> 00:08:41,839
then we want to return zero so

207
00:08:41,839 --> 00:08:44,159
no need to do anything here and same

208
00:08:44,159 --> 00:08:44,959
goes with one

209
00:08:44,959 --> 00:08:48,640
if it's uh if it's it equals to one then

210
00:08:48,640 --> 00:08:51,279
we just go to red and we return the same

211
00:08:51,279 --> 00:08:53,200
value like we did here

212
00:08:53,200 --> 00:08:56,560
um nothing too special and

213
00:08:56,560 --> 00:08:59,519
now we need to call fibo with n minus

214
00:08:59,519 --> 00:09:00,160
one and

215
00:09:00,160 --> 00:09:04,000
fibo with n minus two so i i i could do

216
00:09:04,000 --> 00:09:04,399
like

217
00:09:04,399 --> 00:09:07,760
deck r 24 to calculate n

218
00:09:07,760 --> 00:09:10,880
minus one and then call fibo and

219
00:09:10,880 --> 00:09:13,360
then i know that i will have the result

220
00:09:13,360 --> 00:09:14,000
inside

221
00:09:14,000 --> 00:09:17,279
um r24 so uh

222
00:09:17,279 --> 00:09:20,480
now r24

223
00:09:20,480 --> 00:09:24,000
is just fibo shell fib of n minus one

224
00:09:24,000 --> 00:09:27,440
um but there is an issue here because

225
00:09:27,440 --> 00:09:29,920
now i don't have this uh input value

226
00:09:29,920 --> 00:09:32,560
anymore this argument so i can't call

227
00:09:32,560 --> 00:09:35,680
fibo of n minus two and

228
00:09:35,680 --> 00:09:38,399
i could probably copy it to a different

229
00:09:38,399 --> 00:09:39,839
register let's say

230
00:09:39,839 --> 00:09:43,440
uh i could do something like move r18

231
00:09:43,440 --> 00:09:46,959
r24 and then i would

232
00:09:46,959 --> 00:09:50,480
uh just move r24

233
00:09:50,480 --> 00:09:53,760
r18 so copy it back but

234
00:09:53,760 --> 00:09:55,839
there is a problem and the problem is

235
00:09:55,839 --> 00:09:57,200
that fibo

236
00:09:57,200 --> 00:09:59,600
when i call it again will override the

237
00:09:59,600 --> 00:10:00,480
value of

238
00:10:00,480 --> 00:10:03,200
r18 or any other register that i will

239
00:10:03,200 --> 00:10:03,600
use

240
00:10:03,600 --> 00:10:06,640
so um basically it's sort of

241
00:10:06,640 --> 00:10:09,040
catch 22. i can't use any register

242
00:10:09,040 --> 00:10:10,800
because then the recursive

243
00:10:10,800 --> 00:10:13,519
uh the recursion will override it so i

244
00:10:13,519 --> 00:10:16,320
need to store the value somewhere else

245
00:10:16,320 --> 00:10:19,519
and that's exactly where

246
00:10:19,519 --> 00:10:21,519
the next two instructions i'm going to

247
00:10:21,519 --> 00:10:23,519
show you uh shine

248
00:10:23,519 --> 00:10:26,000
um i think we mentioned it briefly last

249
00:10:26,000 --> 00:10:28,320
week um the stack so

250
00:10:28,320 --> 00:10:32,000
um the stack is uh just um

251
00:10:32,000 --> 00:10:35,680
region of data at the end of the

252
00:10:35,680 --> 00:10:39,279
sram and whenever

253
00:10:39,279 --> 00:10:42,000
we call a function we actually when we

254
00:10:42,000 --> 00:10:43,200
do call fibo or

255
00:10:43,200 --> 00:10:45,839
any other function we actually push the

256
00:10:45,839 --> 00:10:46,640
uh

257
00:10:46,640 --> 00:10:49,279
edit the return address uh of the

258
00:10:49,279 --> 00:10:50,720
function

259
00:10:50,720 --> 00:10:54,720
into the stack so the return address

260
00:10:54,720 --> 00:10:57,760
written into the stack and

261
00:10:57,760 --> 00:11:00,160
how does the microcontroller know where

262
00:11:00,160 --> 00:11:01,040
uh

263
00:11:01,040 --> 00:11:03,279
where to write into the stack so it has

264
00:11:03,279 --> 00:11:04,079
this

265
00:11:04,079 --> 00:11:07,279
register called sp stack pointer

266
00:11:07,279 --> 00:11:10,000
which points at the bottom of this of

267
00:11:10,000 --> 00:11:10,640
the stack

268
00:11:10,640 --> 00:11:14,880
and this sp uh is uh decremented when we

269
00:11:14,880 --> 00:11:17,200
write info into the stack so whenever we

270
00:11:17,200 --> 00:11:20,079
um write a new we call a function we

271
00:11:20,079 --> 00:11:21,519
write the return address

272
00:11:21,519 --> 00:11:26,000
into uh the location pointed by sp

273
00:11:26,000 --> 00:11:29,920
uh into uh the location that

274
00:11:29,920 --> 00:11:33,519
sp points at and then

275
00:11:33,519 --> 00:11:37,519
uh the second thing we do we just uh

276
00:11:37,519 --> 00:11:40,079
in this case uh a return address is two

277
00:11:40,079 --> 00:11:40,800
bytes so

278
00:11:40,800 --> 00:11:42,880
we decrement the stack pointer so it

279
00:11:42,880 --> 00:11:44,480
grows down

280
00:11:44,480 --> 00:11:47,839
um and whenever we do red it just

281
00:11:47,839 --> 00:11:51,279
uh do this it just uh

282
00:11:51,279 --> 00:11:54,839
copies the uh current value of

283
00:11:54,839 --> 00:11:59,040
sb so it basically adds two to sp

284
00:11:59,040 --> 00:12:02,959
so uh to remove uh the return address

285
00:12:02,959 --> 00:12:04,079
from the stack

286
00:12:04,079 --> 00:12:06,880
uh but like the actual return address is

287
00:12:06,880 --> 00:12:07,839
still in that

288
00:12:07,839 --> 00:12:10,800
memory address and then it does a pc

289
00:12:10,800 --> 00:12:12,880
program counter gets the

290
00:12:12,880 --> 00:12:15,839
value inside sp so it loads the program

291
00:12:15,839 --> 00:12:16,639
counter

292
00:12:16,639 --> 00:12:18,560
with the value that we stored into the

293
00:12:18,560 --> 00:12:20,000
stack and

294
00:12:20,000 --> 00:12:22,000
the stack is very useful to keep track

295
00:12:22,000 --> 00:12:23,360
of function calls

296
00:12:23,360 --> 00:12:25,200
but we can also use it to store

297
00:12:25,200 --> 00:12:27,680
registers or to store values

298
00:12:27,680 --> 00:12:32,480
so in our case we can just

299
00:12:32,480 --> 00:12:35,040
call the push instruction which pushes a

300
00:12:35,040 --> 00:12:36,639
new value into the stack so

301
00:12:36,639 --> 00:12:40,160
push our r24 that will push n minus one

302
00:12:40,160 --> 00:12:41,519
into the stack

303
00:12:41,519 --> 00:12:44,639
and then um if we want to restore it

304
00:12:44,639 --> 00:12:45,760
later we can just

305
00:12:45,760 --> 00:12:48,800
pop r24 so that would

306
00:12:48,800 --> 00:12:52,320
uh take the value of r24 and push it

307
00:12:52,320 --> 00:12:55,680
and restore it from the stack

308
00:12:55,680 --> 00:12:58,800
um but then there is um an

309
00:12:58,800 --> 00:13:01,760
interesting uh problem because we just

310
00:13:01,760 --> 00:13:03,120
overridden

311
00:13:03,120 --> 00:13:06,320
the return value of fibo because it's

312
00:13:06,320 --> 00:13:09,519
in r24 so uh we can do

313
00:13:09,519 --> 00:13:13,519
something like that move r18 r24

314
00:13:13,519 --> 00:13:16,560
so copy the return

315
00:13:16,560 --> 00:13:20,240
value or copy uh

316
00:13:20,240 --> 00:13:23,920
fiber copy

317
00:13:23,920 --> 00:13:27,600
this into uh r18

318
00:13:27,600 --> 00:13:30,959
and then um we need to

319
00:13:30,959 --> 00:13:33,360
we can push it so it will be available

320
00:13:33,360 --> 00:13:34,000
as for

321
00:13:34,000 --> 00:13:37,360
uh after we call uh fibo again so

322
00:13:37,360 --> 00:13:40,480
uh save fibo and

323
00:13:40,480 --> 00:13:43,600
minus one into the stack and then

324
00:13:43,600 --> 00:13:45,040
finally

325
00:13:45,040 --> 00:13:48,880
uh we can decrement r24 so now

326
00:13:48,880 --> 00:13:52,160
when we popped it we got uh n minus one

327
00:13:52,160 --> 00:13:54,560
because that's what we pushed and then

328
00:13:54,560 --> 00:13:55,199
when we

329
00:13:55,199 --> 00:13:58,079
decrement it it's n minus two and then

330
00:13:58,079 --> 00:13:59,519
we can call fibo

331
00:13:59,519 --> 00:14:02,800
again and now uh

332
00:14:02,800 --> 00:14:05,920
we have this uh so now we have

333
00:14:05,920 --> 00:14:09,120
uh in r24 fibo n

334
00:14:09,120 --> 00:14:12,560
minus two and we can just pop

335
00:14:12,560 --> 00:14:14,959
the value that we saved uh we can pop it

336
00:14:14,959 --> 00:14:16,639
into any register it doesn't have to be

337
00:14:16,639 --> 00:14:18,160
the same so we could pop it

338
00:14:18,160 --> 00:14:21,920
into pop it into r23 for instance

339
00:14:21,920 --> 00:14:25,360
and now we have uh both

340
00:14:25,360 --> 00:14:28,880
fibo of n minus 2 and n minus 1 and we

341
00:14:28,880 --> 00:14:31,600
can do add r24

342
00:14:31,600 --> 00:14:34,959
r23 to add these two values and

343
00:14:34,959 --> 00:14:37,440
uh it's been a lot of good and there is

344
00:14:37,440 --> 00:14:38,320
a good chance

345
00:14:38,320 --> 00:14:42,880
i made some um some mistakes

346
00:14:42,880 --> 00:14:45,279
but let's run it and find out if this

347
00:14:45,279 --> 00:14:45,920
works

348
00:14:45,920 --> 00:14:48,320
to make it a little bit more exciting

349
00:14:48,320 --> 00:14:49,519
let's also add

350
00:14:49,519 --> 00:14:52,880
the let's also print the number of uh

351
00:14:52,880 --> 00:14:55,920
the index so

352
00:14:55,920 --> 00:14:59,279
index column and then the result okay

353
00:14:59,279 --> 00:15:02,959
are you ready ready set go yep and you

354
00:15:02,959 --> 00:15:03,600
can see

355
00:15:03,600 --> 00:15:06,959
it did calculate uh fibo correctly like

356
00:15:06,959 --> 00:15:09,360
this is the fibonacci sequence

357
00:15:09,360 --> 00:15:11,760
and we couldn't have done it uh with

358
00:15:11,760 --> 00:15:13,120
this recursion method

359
00:15:13,120 --> 00:15:16,240
if we didn't have the stack um

360
00:15:16,240 --> 00:15:18,959
okay so we could have like used the

361
00:15:18,959 --> 00:15:20,320
memory and sort of

362
00:15:20,320 --> 00:15:22,240
implemented some kind of data structure

363
00:15:22,240 --> 00:15:23,360
like the stack

364
00:15:23,360 --> 00:15:25,199
but it's very convenient to have those

365
00:15:25,199 --> 00:15:26,639
instructions

366
00:15:26,639 --> 00:15:30,320
um and that's one way to use the

367
00:15:30,320 --> 00:15:31,199
instructions

368
00:15:31,199 --> 00:15:34,560
another way to do it is just uh so

369
00:15:34,560 --> 00:15:37,279
if you remember there are some registers

370
00:15:37,279 --> 00:15:37,920
in the

371
00:15:37,920 --> 00:15:41,360
uh calling convention that uh i think

372
00:15:41,360 --> 00:15:44,480
yeah call use registers uh that we can

373
00:15:44,480 --> 00:15:45,120
modify

374
00:15:45,120 --> 00:15:46,959
so these are registers that we are

375
00:15:46,959 --> 00:15:48,399
freely allowed to modify

376
00:15:48,399 --> 00:15:50,720
and we use them and there are some call

377
00:15:50,720 --> 00:15:52,639
saved registers that we are not allowed

378
00:15:52,639 --> 00:15:53,759
to modify

379
00:15:53,759 --> 00:15:56,240
so we could alternatively do something

380
00:15:56,240 --> 00:15:56,880
like that

381
00:15:56,880 --> 00:15:59,759
we could have just uh used one of those

382
00:15:59,759 --> 00:16:02,160
registers to store the temporary values

383
00:16:02,160 --> 00:16:03,040
for instance

384
00:16:03,040 --> 00:16:06,480
uh r16 is in this range so we could have

385
00:16:06,480 --> 00:16:07,600
done something like

386
00:16:07,600 --> 00:16:10,800
push r16 and then we have to

387
00:16:10,800 --> 00:16:13,680
pop it at the end to restore it and then

388
00:16:13,680 --> 00:16:14,079
uh

389
00:16:14,079 --> 00:16:17,040
mid function we could instead of just uh

390
00:16:17,040 --> 00:16:17,839
pushing and

391
00:16:17,839 --> 00:16:21,519
popping uh like instead of for instance

392
00:16:21,519 --> 00:16:25,040
pushing this value uh fibo n

393
00:16:25,040 --> 00:16:27,120
minus one we could have just stored it

394
00:16:27,120 --> 00:16:28,639
into r16

395
00:16:28,639 --> 00:16:30,800
and then uh we didn't need this and

396
00:16:30,800 --> 00:16:32,079
didn't need this

397
00:16:32,079 --> 00:16:36,880
uh just uh pop uh just you know uh

398
00:16:36,880 --> 00:16:40,000
use r16 and this is just a convention

399
00:16:40,000 --> 00:16:42,399
thing like uh if we write our own

400
00:16:42,399 --> 00:16:43,279
assembly code

401
00:16:43,279 --> 00:16:46,880
we can decide how we do it but if we are

402
00:16:46,880 --> 00:16:47,759
working with

403
00:16:47,759 --> 00:16:50,959
uh arduino code that is compiled by gcc

404
00:16:50,959 --> 00:16:52,800
and gcc expect us to

405
00:16:52,800 --> 00:16:55,920
uh to to preserve the value of these

406
00:16:55,920 --> 00:16:59,279
uh registers so it's totally up to us

407
00:16:59,279 --> 00:17:00,240
whether we want

408
00:17:00,240 --> 00:17:02,240
to you know just uh push them at the

409
00:17:02,240 --> 00:17:03,839
beginning of the

410
00:17:03,839 --> 00:17:06,319
function and then use them and treat

411
00:17:06,319 --> 00:17:07,199
them as sort of

412
00:17:07,199 --> 00:17:10,799
local variables that belong to us

413
00:17:10,799 --> 00:17:14,160
or we can just use those

414
00:17:14,160 --> 00:17:17,359
generic registers those

415
00:17:17,359 --> 00:17:19,679
call clobbered registers and then

416
00:17:19,679 --> 00:17:21,280
whenever we modify them

417
00:17:21,280 --> 00:17:23,520
uh push them into the stack before we

418
00:17:23,520 --> 00:17:25,199
call other functions because we know

419
00:17:25,199 --> 00:17:25,679
they can

420
00:17:25,679 --> 00:17:28,720
also modify them so that was fibo

421
00:17:28,720 --> 00:17:32,000
nachi and um

422
00:17:32,000 --> 00:17:35,039
push and pop pretty useful and

423
00:17:35,039 --> 00:17:37,360
um

424
00:17:37,800 --> 00:17:38,960
[Music]

425
00:17:38,960 --> 00:17:41,840
okay i would love to hear about that uh

426
00:17:41,840 --> 00:17:43,360
clever trick in the

427
00:17:43,360 --> 00:17:46,720
uh q and a session letter

428
00:17:46,720 --> 00:17:50,000
thanks justin uh please uh

429
00:17:50,000 --> 00:17:53,520
tell me about it later i'm curious um

430
00:17:53,520 --> 00:17:57,600
and once we uh have those instructions

431
00:17:57,600 --> 00:18:00,960
for me like i think let's write it down

432
00:18:00,960 --> 00:18:04,640
push and pop so for me

433
00:18:04,640 --> 00:18:06,400
there are still a few more instructions

434
00:18:06,400 --> 00:18:08,320
that are less common but

435
00:18:08,320 --> 00:18:10,720
i think you have enough instructions to

436
00:18:10,720 --> 00:18:13,440
be able to do useful things

437
00:18:13,440 --> 00:18:16,880
and um what i want to

438
00:18:16,880 --> 00:18:20,160
move on to is i what i think is the more

439
00:18:20,160 --> 00:18:21,520
interesting thing

440
00:18:21,520 --> 00:18:25,039
or of just seeing the code that

441
00:18:25,039 --> 00:18:27,679
the compiler generates when we write c

442
00:18:27,679 --> 00:18:28,480
code

443
00:18:28,480 --> 00:18:31,360
so we already know like how to write our

444
00:18:31,360 --> 00:18:32,720
own assembly functions

445
00:18:32,720 --> 00:18:35,520
and we know to write arduino code but

446
00:18:35,520 --> 00:18:38,000
would it be interesting to see what the

447
00:18:38,000 --> 00:18:39,120
compiler

448
00:18:39,120 --> 00:18:42,080
generated for this loop for instance or

449
00:18:42,080 --> 00:18:42,799
even

450
00:18:42,799 --> 00:18:46,000
how did it uh did it actually

451
00:18:46,000 --> 00:18:49,039
write these functions the way we uh we

452
00:18:49,039 --> 00:18:52,000
wrote them did it modify them in any way

453
00:18:52,000 --> 00:18:52,480
so

454
00:18:52,480 --> 00:18:56,000
um for that there is a command line

455
00:18:56,000 --> 00:18:58,080
tool that can show you this information

456
00:18:58,080 --> 00:18:59,280
it's called uh

457
00:18:59,280 --> 00:19:02,799
avr objemp but luckily uh

458
00:19:02,799 --> 00:19:04,640
if you want i can show you how to do it

459
00:19:04,640 --> 00:19:06,400
in the command line during the q a

460
00:19:06,400 --> 00:19:06,960
session

461
00:19:06,960 --> 00:19:09,679
but luckily it's i already integrated it

462
00:19:09,679 --> 00:19:11,039
into walkway because

463
00:19:11,039 --> 00:19:12,559
that was the first thing i wanted to do

464
00:19:12,559 --> 00:19:14,240
to see what the compiler

465
00:19:14,240 --> 00:19:17,919
does and you can just f1 and uh

466
00:19:17,919 --> 00:19:20,960
look for assembly and you have this

467
00:19:20,960 --> 00:19:23,919
view compiled assembly code listing and

468
00:19:23,919 --> 00:19:25,520
as soon as i hit it

469
00:19:25,520 --> 00:19:28,799
there is a new tab called sketch.lsd

470
00:19:28,799 --> 00:19:32,480
and it might be a little bit

471
00:19:32,480 --> 00:19:35,520
overwhelming because this is like a

472
00:19:35,520 --> 00:19:38,880
27 lines program but the listing

473
00:19:38,880 --> 00:19:42,320
oh my god oh my god more than a thousand

474
00:19:42,320 --> 00:19:43,280
lines

475
00:19:43,280 --> 00:19:47,280
but they are good news um first of all

476
00:19:47,280 --> 00:19:50,720
um it has comments so you can see like

477
00:19:50,720 --> 00:19:52,880
for instance if i want to do to see what

478
00:19:52,880 --> 00:19:54,160
my loop looks like i

479
00:19:54,160 --> 00:19:56,960
can just search for void loop and

480
00:19:56,960 --> 00:19:57,760
hopefully

481
00:19:57,760 --> 00:20:00,880
i will find how it compiled yeah i can

482
00:20:00,880 --> 00:20:01,679
see the co

483
00:20:01,679 --> 00:20:04,320
the compiled code for loop and there are

484
00:20:04,320 --> 00:20:04,720
like

485
00:20:04,720 --> 00:20:06,880
uh i i can see the source code next to

486
00:20:06,880 --> 00:20:08,720
the instructions so like i know that

487
00:20:08,720 --> 00:20:10,880
this like digital write

488
00:20:10,880 --> 00:20:14,159
was compiled into these um

489
00:20:14,159 --> 00:20:18,000
introduced to uh into these two

490
00:20:18,000 --> 00:20:21,760
uh instructions so uh it loads uh

491
00:20:21,760 --> 00:20:24,799
one into r24 which is the first argument

492
00:20:24,799 --> 00:20:28,080
and then calls this function so uh

493
00:20:28,080 --> 00:20:31,520
because we we asked it to uh call it

494
00:20:31,520 --> 00:20:33,360
with the number one

495
00:20:33,360 --> 00:20:36,480
but then uh we can also already see

496
00:20:36,480 --> 00:20:36,960
something

497
00:20:36,960 --> 00:20:40,000
interesting when we call delay the next

498
00:20:40,000 --> 00:20:40,799
line

499
00:20:40,799 --> 00:20:42,880
it doesn't uh do anything with the

500
00:20:42,880 --> 00:20:44,640
argument what happens here

501
00:20:44,640 --> 00:20:49,039
i mean where is this 1000 why isn't it

502
00:20:49,039 --> 00:20:52,320
loaded into r24 or r25

503
00:20:52,320 --> 00:20:55,280
and um the answer is pretty interesting

504
00:20:55,280 --> 00:20:56,000
that's

505
00:20:56,000 --> 00:20:58,720
how the compiler optimizes the code it

506
00:20:58,720 --> 00:21:00,880
says that we only call delay with

507
00:21:00,880 --> 00:21:04,400
1000 so it creates um

508
00:21:04,400 --> 00:21:07,200
a spatial we can look for it here it can

509
00:21:07,200 --> 00:21:08,000
it creates

510
00:21:08,000 --> 00:21:11,200
a spatial version of delay that's the

511
00:21:11,200 --> 00:21:12,400
delay function

512
00:21:12,400 --> 00:21:16,400
but the value 1000 is hard-coded

513
00:21:16,400 --> 00:21:18,799
um i think that's that's pretty

514
00:21:18,799 --> 00:21:19,679
brilliant

515
00:21:19,679 --> 00:21:23,200
um if i'm not mistaken that's 1000

516
00:21:23,200 --> 00:21:25,600
let's let's check it out if this is

517
00:21:25,600 --> 00:21:26,720
really 1000

518
00:21:26,720 --> 00:21:30,480
i think it is fs3 b

519
00:21:30,480 --> 00:21:34,480
1003 yeah i think um

520
00:21:34,480 --> 00:21:37,840
yeah i think um that there is

521
00:21:37,840 --> 00:21:41,039
uh a place where they add tree or

522
00:21:41,039 --> 00:21:42,640
something like that not sure

523
00:21:42,640 --> 00:21:46,240
anyway uh that that's pretty brilliant

524
00:21:46,240 --> 00:21:46,640
like

525
00:21:46,640 --> 00:21:49,200
this is how the compiler optimizes the

526
00:21:49,200 --> 00:21:50,480
code so

527
00:21:50,480 --> 00:21:54,000
uh if you um

528
00:21:54,000 --> 00:21:55,679
if i had something like this for

529
00:21:55,679 --> 00:21:57,280
instance uh

530
00:21:57,280 --> 00:22:00,799
i added delay i ear so it wouldn't be

531
00:22:00,799 --> 00:22:02,880
able to optimize the code and let's

532
00:22:02,880 --> 00:22:04,640
update the listing

533
00:22:04,640 --> 00:22:06,960
because it wouldn't be able to create a

534
00:22:06,960 --> 00:22:09,280
function

535
00:22:10,640 --> 00:22:13,039
version of delay with this it would but

536
00:22:13,039 --> 00:22:15,440
it wouldn't make any uh sense to create

537
00:22:15,440 --> 00:22:16,159
a

538
00:22:16,159 --> 00:22:18,240
a version of delay with this very hard

539
00:22:18,240 --> 00:22:20,000
coded and another one

540
00:22:20,000 --> 00:22:23,520
with uh the dynamic value so now

541
00:22:23,520 --> 00:22:26,720
if i uh look at loop

542
00:22:26,720 --> 00:22:29,760
i can see that it yeah it actually calls

543
00:22:29,760 --> 00:22:32,000
delay and it loads this value

544
00:22:32,000 --> 00:22:36,400
when calling delay so um

545
00:22:36,799 --> 00:22:38,880
this is like one of the optimizations

546
00:22:38,880 --> 00:22:41,280
that the compiler in doing is doing

547
00:22:41,280 --> 00:22:44,559
and there are many optimizations that uh

548
00:22:44,559 --> 00:22:46,960
that you can see for example um

549
00:22:46,960 --> 00:22:48,400
[Music]

550
00:22:48,400 --> 00:22:50,720
if you check out this code this is where

551
00:22:50,720 --> 00:22:52,080
loop begins

552
00:22:52,080 --> 00:22:55,760
but there is no return

553
00:22:55,760 --> 00:22:59,039
how comes like uh this is like uh loop

554
00:22:59,039 --> 00:23:01,840
digital write delay digital right delay

555
00:23:01,840 --> 00:23:03,520
and then there is a bunch of

556
00:23:03,520 --> 00:23:05,600
instructions after the call to delay

557
00:23:05,600 --> 00:23:07,679
that are actually

558
00:23:07,679 --> 00:23:11,280
main what's that so it turns out that

559
00:23:11,280 --> 00:23:14,400
um the compiler notices that

560
00:23:14,400 --> 00:23:17,440
both setup and loop they they

561
00:23:17,440 --> 00:23:22,000
they aren't called by anyone or

562
00:23:22,000 --> 00:23:24,400
to to to put it down more accurately

563
00:23:24,400 --> 00:23:26,559
they are called by the main function

564
00:23:26,559 --> 00:23:29,919
and um the main function

565
00:23:29,919 --> 00:23:33,039
which you can sort of see parts of it

566
00:23:33,039 --> 00:23:33,919
here

567
00:23:33,919 --> 00:23:37,200
is a part of the avr standard library

568
00:23:37,200 --> 00:23:40,080
you can find it on github specifically i

569
00:23:40,080 --> 00:23:43,840
will post the link so it'll have it

570
00:23:44,240 --> 00:23:47,679
so yeah i will later

571
00:23:47,679 --> 00:23:50,159
change the title but there is a file

572
00:23:50,159 --> 00:23:52,080
called wiring.c

573
00:23:52,080 --> 00:23:54,960
and that's the main function somewhere

574
00:23:54,960 --> 00:23:56,000
here i think

575
00:23:56,000 --> 00:23:59,760
or not here in init

576
00:23:59,760 --> 00:24:02,799
wiring oh main of course

577
00:24:02,799 --> 00:24:04,640
so there is this main function and you

578
00:24:04,640 --> 00:24:06,159
can see that main calls

579
00:24:06,159 --> 00:24:08,240
init which is an internal function of

580
00:24:08,240 --> 00:24:10,159
the library in it variant

581
00:24:10,159 --> 00:24:12,159
then it calls your setup and then it

582
00:24:12,159 --> 00:24:13,279
calls or it

583
00:24:13,279 --> 00:24:15,039
goes into a loop where it calls your

584
00:24:15,039 --> 00:24:17,760
loop and then it calls some

585
00:24:17,760 --> 00:24:20,960
other internal function so this

586
00:24:20,960 --> 00:24:23,600
uh when the compiler sees this it

587
00:24:23,600 --> 00:24:24,960
realizes that setup

588
00:24:24,960 --> 00:24:28,080
and loop are only users used here so it

589
00:24:28,080 --> 00:24:30,799
inlines them so what you are seeing here

590
00:24:30,799 --> 00:24:35,200
is actually the combination of um

591
00:24:35,200 --> 00:24:38,400
its uh loop and parts of uh

592
00:24:38,400 --> 00:24:42,080
main like uh this serial event run

593
00:24:42,080 --> 00:24:45,440
which we have here is also inlined

594
00:24:45,440 --> 00:24:49,039
into this um into this very gigantic

595
00:24:49,039 --> 00:24:50,640
function which contains

596
00:24:50,640 --> 00:24:53,840
uh several parts of main and

597
00:24:53,840 --> 00:24:56,240
uh what do we see here yeah you see the

598
00:24:56,240 --> 00:24:57,279
setup

599
00:24:57,279 --> 00:24:59,919
and pin mode is also inlined here for

600
00:24:59,919 --> 00:25:01,440
some reason i think uh

601
00:25:01,440 --> 00:25:03,440
we only call it once here so it's

602
00:25:03,440 --> 00:25:04,640
inlined

603
00:25:04,640 --> 00:25:07,760
um and you can see like

604
00:25:07,760 --> 00:25:11,520
it's where does main begin

605
00:25:11,520 --> 00:25:14,799
so main begins here

606
00:25:14,799 --> 00:25:18,240
so main includes all these like

607
00:25:18,240 --> 00:25:21,039
very long initialization code and the

608
00:25:21,039 --> 00:25:23,520
setup and your loop and everything

609
00:25:23,520 --> 00:25:26,000
so that's what a compiler does for us

610
00:25:26,000 --> 00:25:27,279
behind the scenes

611
00:25:27,279 --> 00:25:30,640
and now since we actually we we can

612
00:25:30,640 --> 00:25:32,799
we know how to read this uh assembly

613
00:25:32,799 --> 00:25:34,480
code we can see what the compiler is

614
00:25:34,480 --> 00:25:36,159
doing behind the scenes

615
00:25:36,159 --> 00:25:38,960
now um let's see something else uh

616
00:25:38,960 --> 00:25:40,159
something fun

617
00:25:40,159 --> 00:25:42,720
so uh let's pretend i have this loop

618
00:25:42,720 --> 00:25:44,240
that goes from

619
00:25:44,240 --> 00:25:47,679
uh zero to two let's remove fibonacci we

620
00:25:47,679 --> 00:25:49,120
don't need it anymore

621
00:25:49,120 --> 00:25:51,679
um you know what let me just uh copy it

622
00:25:51,679 --> 00:25:53,679
to the document so that you have it as

623
00:25:53,679 --> 00:25:54,840
well

624
00:25:54,840 --> 00:25:58,880
um that's people

625
00:25:58,880 --> 00:26:02,720
cool and um so i have this loop that

626
00:26:02,720 --> 00:26:03,279
sets

627
00:26:03,279 --> 00:26:07,039
a pin number i to output and if i go to

628
00:26:07,039 --> 00:26:07,360
the

629
00:26:07,360 --> 00:26:10,400
assembly code listing i will be able to

630
00:26:10,400 --> 00:26:11,840
see that

631
00:26:11,840 --> 00:26:14,880
that was in my setup

632
00:26:14,880 --> 00:26:18,400
where is my setup yep i can see that

633
00:26:18,400 --> 00:26:20,799
this is the source code but there was no

634
00:26:20,799 --> 00:26:21,760
loop generated

635
00:26:21,760 --> 00:26:24,720
it just did something that is called

636
00:26:24,720 --> 00:26:25,679
loop unrolling

637
00:26:25,679 --> 00:26:27,760
instead of doing the loop it just uh

638
00:26:27,760 --> 00:26:30,080
called those um

639
00:26:30,080 --> 00:26:33,440
uh basically did instead of like doing

640
00:26:33,440 --> 00:26:35,679
the loop it just did something like

641
00:26:35,679 --> 00:26:39,440
uh as if i wrote pin mode 0

642
00:26:39,440 --> 00:26:43,039
and pin mount 1 and obviously

643
00:26:43,039 --> 00:26:46,080
if i will put a large enough number

644
00:26:46,080 --> 00:26:48,080
it will stop unrolling the loop and i

645
00:26:48,080 --> 00:26:50,080
want you to try guessing in the chat

646
00:26:50,080 --> 00:26:51,600
what this number would be

647
00:26:51,600 --> 00:26:55,120
i mean at what number it would stop um

648
00:26:55,120 --> 00:26:57,440
unrolling the loop and we would actually

649
00:26:57,440 --> 00:26:58,159
uh create

650
00:26:58,159 --> 00:27:00,960
the code for the loop so someone says 16

651
00:27:00,960 --> 00:27:01,760
maru

652
00:27:01,760 --> 00:27:05,520
um any more guesses uh let's go

653
00:27:05,520 --> 00:27:07,840
to three while you are guessing to see

654
00:27:07,840 --> 00:27:08,640
if it all

655
00:27:08,640 --> 00:27:11,520
it may already stop a tree we don't know

656
00:27:11,520 --> 00:27:12,240
random

657
00:27:12,240 --> 00:27:14,480
zero twelve okay any more concrete

658
00:27:14,480 --> 00:27:15,520
guesses

659
00:27:15,520 --> 00:27:17,919
so the answer for three it's still

660
00:27:17,919 --> 00:27:20,240
unrolling the loop

661
00:27:20,240 --> 00:27:23,360
where would it stop i'm waiting for your

662
00:27:23,360 --> 00:27:24,000
guesses

663
00:27:24,000 --> 00:27:27,039
the answer for four still loop unrolling

664
00:27:27,039 --> 00:27:30,720
let's see what happens with five so

665
00:27:30,720 --> 00:27:34,720
view compiled and still not generating a

666
00:27:34,720 --> 00:27:35,600
loop

667
00:27:35,600 --> 00:27:37,600
still no loop and let's see what happens

668
00:27:37,600 --> 00:27:40,158
with six

669
00:27:41,039 --> 00:27:43,520
finally there is a loop so i think term

670
00:27:43,520 --> 00:27:44,480
w was

671
00:27:44,480 --> 00:27:46,880
the closest to the right answer which is

672
00:27:46,880 --> 00:27:48,399
six

673
00:27:48,399 --> 00:27:50,159
finally you see there is a loop and the

674
00:27:50,159 --> 00:27:51,520
loop only consists

675
00:27:51,520 --> 00:27:54,080
of like five instructions but for some

676
00:27:54,080 --> 00:27:57,440
reason the compiler decided that

677
00:27:57,440 --> 00:27:59,600
five or less should be unrolled i don't

678
00:27:59,600 --> 00:28:00,799
know how the

679
00:28:00,799 --> 00:28:04,000
compiler decides on that um

680
00:28:04,000 --> 00:28:07,840
but yeah there is like optimization for

681
00:28:07,840 --> 00:28:09,200
speed or for size

682
00:28:09,200 --> 00:28:12,559
um i guess it's

683
00:28:12,559 --> 00:28:15,120
been optimized for speed but i can't

684
00:28:15,120 --> 00:28:17,039
really like

685
00:28:17,039 --> 00:28:19,360
we can try to measure the speed of uh

686
00:28:19,360 --> 00:28:20,960
this and

687
00:28:20,960 --> 00:28:22,640
like we did with the timer and see

688
00:28:22,640 --> 00:28:24,000
what's faster

689
00:28:24,000 --> 00:28:27,279
if we want to know for sure um one more

690
00:28:27,279 --> 00:28:29,279
thing because before we

691
00:28:29,279 --> 00:28:32,559
sign off and move to the next subject uh

692
00:28:32,559 --> 00:28:33,600
just

693
00:28:33,600 --> 00:28:36,720
we did this comparison with uh digital

694
00:28:36,720 --> 00:28:40,000
right versus direct burst access and

695
00:28:40,000 --> 00:28:42,720
now i just want to show it in practice

696
00:28:42,720 --> 00:28:43,360
so

697
00:28:43,360 --> 00:28:45,919
when i write something like this it

698
00:28:45,919 --> 00:28:46,880
compiles

699
00:28:46,880 --> 00:28:50,159
two i think two instructions uh where is

700
00:28:50,159 --> 00:28:52,559
setup

701
00:28:53,360 --> 00:28:57,360
yeah so i load this value into r24

702
00:28:57,360 --> 00:28:59,679
and then and out as an instruction that

703
00:28:59,679 --> 00:29:02,799
uh writes to one of the i o registers

704
00:29:02,799 --> 00:29:06,399
so um and uh

705
00:29:06,399 --> 00:29:09,440
if i do digital write instead let's do

706
00:29:09,440 --> 00:29:13,679
also digital right here

707
00:29:13,679 --> 00:29:16,399
let's say pin five i want to write it

708
00:29:16,399 --> 00:29:16,960
high

709
00:29:16,960 --> 00:29:19,120
and then i will look at the code listing

710
00:29:19,120 --> 00:29:20,559
for that

711
00:29:20,559 --> 00:29:24,240
where am i every code listing is totally

712
00:29:24,240 --> 00:29:25,200
new

713
00:29:25,200 --> 00:29:27,600
okay so we can see like direct port

714
00:29:27,600 --> 00:29:29,679
access is two instructions

715
00:29:29,679 --> 00:29:32,320
and in some cases it might be one uh

716
00:29:32,320 --> 00:29:33,200
depending of

717
00:29:33,200 --> 00:29:35,919
it is it somehow already has this value

718
00:29:35,919 --> 00:29:37,120
in another register

719
00:29:37,120 --> 00:29:38,720
it might optimize it to just one

720
00:29:38,720 --> 00:29:41,200
instruction opposed to digital right

721
00:29:41,200 --> 00:29:42,080
where we have

722
00:29:42,080 --> 00:29:45,600
all of these mumble jumble until here

723
00:29:45,600 --> 00:29:49,039
this is like digital right so uh you can

724
00:29:49,039 --> 00:29:50,240
see that it does

725
00:29:50,240 --> 00:29:53,679
uh stuff with um

726
00:29:53,679 --> 00:29:57,520
uh ports the number to port and register

727
00:29:57,520 --> 00:29:59,600
digital pin to ma blah blah blah blah

728
00:29:59,600 --> 00:30:00,880
blah and

729
00:30:00,880 --> 00:30:03,279
um if you are curious you can uh again

730
00:30:03,279 --> 00:30:04,880
you can find it here like there is

731
00:30:04,880 --> 00:30:07,279
uh i think inside wiring digital there

732
00:30:07,279 --> 00:30:09,120
is like the definition of

733
00:30:09,120 --> 00:30:11,840
digital right so you can see all that it

734
00:30:11,840 --> 00:30:12,720
does

735
00:30:12,720 --> 00:30:16,000
it has to deal with pwm for some of the

736
00:30:16,000 --> 00:30:16,640
pins

737
00:30:16,640 --> 00:30:21,039
and clearly interrupts and

738
00:30:21,039 --> 00:30:25,200
a lot of fun anyway so um

739
00:30:25,200 --> 00:30:28,320
yeah so that was it about like

740
00:30:28,320 --> 00:30:30,240
uh looking at the code that the compiler

741
00:30:30,240 --> 00:30:31,840
generate and we could go

742
00:30:31,840 --> 00:30:34,399
on it for like hours it's fascinating

743
00:30:34,399 --> 00:30:35,200
stuff

744
00:30:35,200 --> 00:30:37,760
but you know how to do it yourself so

745
00:30:37,760 --> 00:30:38,880
you can just you know

746
00:30:38,880 --> 00:30:40,720
keep experimenting trying stuff and

747
00:30:40,720 --> 00:30:42,640
seeing what a compiler generates i think

748
00:30:42,640 --> 00:30:44,480
it's the best way to learn

749
00:30:44,480 --> 00:30:47,039
and this is also a good way to see if

750
00:30:47,039 --> 00:30:47,520
you are

751
00:30:47,520 --> 00:30:50,000
uh missing any instructions that you

752
00:30:50,000 --> 00:30:50,880
don't know

753
00:30:50,880 --> 00:30:54,640
like i think we haven't discussed um

754
00:30:54,640 --> 00:30:57,519
lpm which loads uh data from the program

755
00:30:57,519 --> 00:30:58,320
memory

756
00:30:58,320 --> 00:31:00,799
so uh if you see an instruction that

757
00:31:00,799 --> 00:31:03,760
like in or npm that we haven't discussed

758
00:31:03,760 --> 00:31:05,840
that's totally fine just go to the

759
00:31:05,840 --> 00:31:06,880
instruction set

760
00:31:06,880 --> 00:31:10,159
and you know what to do there like

761
00:31:10,159 --> 00:31:13,279
how to read this we already done this

762
00:31:13,279 --> 00:31:18,559
um so now i want to move on to

763
00:31:18,559 --> 00:31:21,200
the topic that i find most fascinating

764
00:31:21,200 --> 00:31:22,960
and that's debugging

765
00:31:22,960 --> 00:31:26,240
and when we have a program like this uh

766
00:31:26,240 --> 00:31:28,240
you know what i actually want to use

767
00:31:28,240 --> 00:31:29,760
fibonacci again here

768
00:31:29,760 --> 00:31:32,799
so uh let's

769
00:31:32,799 --> 00:31:36,480
um tomorrow that's good question keep

770
00:31:36,480 --> 00:31:39,039
it for the q a we'll i would love to

771
00:31:39,039 --> 00:31:40,240
answer that

772
00:31:40,240 --> 00:31:44,159
um so uh we have this uh serial println

773
00:31:44,159 --> 00:31:47,679
uh and we are printing fibo for example

774
00:31:47,679 --> 00:31:48,559
of

775
00:31:48,559 --> 00:31:51,600
one so it doesn't recurse and we should

776
00:31:51,600 --> 00:31:55,120
just print one and now um

777
00:31:55,120 --> 00:31:58,159
we want to debug fibo so there is like

778
00:31:58,159 --> 00:32:00,559
uh the break instruction that i showed

779
00:32:00,559 --> 00:32:02,640
you and we can use it here like

780
00:32:02,640 --> 00:32:05,679
we can for instance call break here

781
00:32:05,679 --> 00:32:08,799
and then call break again here and that

782
00:32:08,799 --> 00:32:11,120
would show us the stack pointer you see

783
00:32:11,120 --> 00:32:13,679
it's been decremented by one because we

784
00:32:13,679 --> 00:32:14,880
push the value of

785
00:32:14,880 --> 00:32:17,919
r16 and

786
00:32:17,919 --> 00:32:20,320
that's a really bad way to debug i mean

787
00:32:20,320 --> 00:32:22,480
if we just want to see the values of the

788
00:32:22,480 --> 00:32:24,640
registers at a certain point

789
00:32:24,640 --> 00:32:27,519
one or two times then that's fine but

790
00:32:27,519 --> 00:32:28,000
that's

791
00:32:28,000 --> 00:32:32,240
not a good debugging experience so

792
00:32:32,240 --> 00:32:34,799
what i'm going to show you now is how to

793
00:32:34,799 --> 00:32:37,679
use a tool called gdp the gnu debugger

794
00:32:37,679 --> 00:32:39,760
and this tool is super powerful and

795
00:32:39,760 --> 00:32:42,640
super useful so uh you can take this

796
00:32:42,640 --> 00:32:44,880
knowledge and apply most of it to any

797
00:32:44,880 --> 00:32:46,320
other architecture

798
00:32:46,320 --> 00:32:49,679
arm pc whatever it's super useful

799
00:32:49,679 --> 00:32:51,919
and i spent the last week making sure

800
00:32:51,919 --> 00:32:53,840
that you can run gdb

801
00:32:53,840 --> 00:32:56,880
from walkway so um

802
00:32:56,880 --> 00:32:59,679
before that uh and you can still know

803
00:32:59,679 --> 00:33:00,960
that if you want you ju

804
00:33:00,960 --> 00:33:03,840
you had to like uh install and run stuff

805
00:33:03,840 --> 00:33:04,960
on your computer

806
00:33:04,960 --> 00:33:08,080
and do a lot of stuff um to get it to

807
00:33:08,080 --> 00:33:08,880
work

808
00:33:08,880 --> 00:33:11,679
uh it's like 10 or 15 minutes of work

809
00:33:11,679 --> 00:33:13,760
but it's annoying to have to do that uh

810
00:33:13,760 --> 00:33:15,679
when you want to just you know debug the

811
00:33:15,679 --> 00:33:17,279
program so if you

812
00:33:17,279 --> 00:33:19,360
do want to try that at home uh i

813
00:33:19,360 --> 00:33:20,320
encourage you

814
00:33:20,320 --> 00:33:24,159
these are like the instructions but um

815
00:33:24,159 --> 00:33:26,720
i managed to get gdb to run inside a

816
00:33:26,720 --> 00:33:27,519
browser

817
00:33:27,519 --> 00:33:29,919
so now we can just go ahead and type

818
00:33:29,919 --> 00:33:31,120
your gdb

819
00:33:31,120 --> 00:33:33,519
and there are two options uh debug build

820
00:33:33,519 --> 00:33:35,279
and release build

821
00:33:35,279 --> 00:33:38,880
release build is the optimized code and

822
00:33:38,880 --> 00:33:41,919
we will usually not want to debug that

823
00:33:41,919 --> 00:33:44,640
because it's harder to debug because of

824
00:33:44,640 --> 00:33:47,039
the optimizations

825
00:33:47,039 --> 00:33:50,240
but sometimes you know

826
00:33:50,240 --> 00:33:52,320
you want to debug the actual thing that

827
00:33:52,320 --> 00:33:54,799
runs on the chip so we'll use that

828
00:33:54,799 --> 00:33:57,840
um and debug build is just uh without

829
00:33:57,840 --> 00:33:59,679
most of the optimizations like inline

830
00:33:59,679 --> 00:34:00,559
income functions

831
00:34:00,559 --> 00:34:03,840
and so on so if we just want to look at

832
00:34:03,840 --> 00:34:06,080
the source code and do stuff then we'll

833
00:34:06,080 --> 00:34:07,279
use debug build

834
00:34:07,279 --> 00:34:10,239
and as soon as we do that there is um a

835
00:34:10,239 --> 00:34:12,239
virtual machine booted inside your

836
00:34:12,239 --> 00:34:12,960
browser

837
00:34:12,960 --> 00:34:17,040
um and it runs gdb it's a tiny linux

838
00:34:17,040 --> 00:34:19,839
that runs in your browser and runs gdb

839
00:34:19,839 --> 00:34:20,560
and let's

840
00:34:20,560 --> 00:34:23,918
actually put them side by side so

841
00:34:23,918 --> 00:34:27,839
we get to see both at the same time

842
00:34:27,839 --> 00:34:30,960
and there is a small issue if i resize

843
00:34:30,960 --> 00:34:31,679
the window

844
00:34:31,679 --> 00:34:34,399
i have to quit gdp and it will

845
00:34:34,399 --> 00:34:36,159
automatically restart and figure out

846
00:34:36,159 --> 00:34:38,239
that the window has been resized

847
00:34:38,239 --> 00:34:41,520
anyway uh you can see it tells me now uh

848
00:34:41,520 --> 00:34:44,159
the program is paused is not running yet

849
00:34:44,159 --> 00:34:45,599
and it's in address

850
00:34:45,599 --> 00:34:48,560
zero so the first thing i can do in gdp

851
00:34:48,560 --> 00:34:48,879
uh

852
00:34:48,879 --> 00:34:51,440
let me just clear the screen so you

853
00:34:51,440 --> 00:34:52,879
don't have all these uh

854
00:34:52,879 --> 00:34:56,079
debug prints um i can just type uh

855
00:34:56,079 --> 00:34:59,680
c so uh if i type c it just runs the

856
00:34:59,680 --> 00:35:01,359
program and the program is running

857
00:35:01,359 --> 00:35:02,240
perfect

858
00:35:02,240 --> 00:35:05,760
but then um it continues to run

859
00:35:05,760 --> 00:35:07,760
and i can't interact with the debugger

860
00:35:07,760 --> 00:35:09,599
like i can write stuff but it won't do

861
00:35:09,599 --> 00:35:10,640
anything

862
00:35:10,640 --> 00:35:13,920
until i either pause the program

863
00:35:13,920 --> 00:35:17,040
which i will do now uh and then when i

864
00:35:17,040 --> 00:35:19,760
pause it you can see where it posed uh

865
00:35:19,760 --> 00:35:20,560
in this case

866
00:35:20,560 --> 00:35:22,640
it posed in this memory address in the

867
00:35:22,640 --> 00:35:23,920
micros function

868
00:35:23,920 --> 00:35:26,079
we haven't used the file the micros

869
00:35:26,079 --> 00:35:26,960
function

870
00:35:26,960 --> 00:35:30,800
so whenever like i randomly pose in a

871
00:35:30,800 --> 00:35:33,599
place in the program uh it shows me like

872
00:35:33,599 --> 00:35:35,920
the source code uh where it posed but

873
00:35:35,920 --> 00:35:36,560
that's

874
00:35:36,560 --> 00:35:39,119
not my source code that's part of the

875
00:35:39,119 --> 00:35:42,400
arduino wiring library that we have seen

876
00:35:42,400 --> 00:35:45,200
there is a nice command that we can use

877
00:35:45,200 --> 00:35:45,680
it's

878
00:35:45,680 --> 00:35:48,000
backtraced it shows us where we are at

879
00:35:48,000 --> 00:35:49,920
the program they're call stack

880
00:35:49,920 --> 00:35:53,440
so backtrace tells us uh we are inside

881
00:35:53,440 --> 00:35:55,839
micros that was called from delay

882
00:35:55,839 --> 00:35:57,839
that was called from loop and we did

883
00:35:57,839 --> 00:36:00,240
that that was called from main

884
00:36:00,240 --> 00:36:03,359
and it also says that the milliseconds

885
00:36:03,359 --> 00:36:04,960
the argument for delay

886
00:36:04,960 --> 00:36:08,400
is 420 493

887
00:36:08,400 --> 00:36:10,720
and we know it's 1000 the reason it says

888
00:36:10,720 --> 00:36:12,079
lower number is because

889
00:36:12,079 --> 00:36:14,480
delay is uh let's have a look at the

890
00:36:14,480 --> 00:36:16,800
source code for delay you will see

891
00:36:16,800 --> 00:36:20,240
i think it's inside uh wiring

892
00:36:20,240 --> 00:36:23,520
um you will see uh

893
00:36:23,520 --> 00:36:27,440
it actually updates milliseconds um

894
00:36:27,440 --> 00:36:30,880
but uh we don't have to go to the source

895
00:36:30,880 --> 00:36:31,760
code we can

896
00:36:31,760 --> 00:36:34,720
ask gdb list delay will show us uh the

897
00:36:34,720 --> 00:36:36,480
source code the source code of delay so

898
00:36:36,480 --> 00:36:37,200
we can

899
00:36:37,200 --> 00:36:40,240
see uh where it is right now um

900
00:36:40,240 --> 00:36:43,440
it's uh showing us uh i think

901
00:36:43,440 --> 00:36:46,640
it's yeah for some reason it has

902
00:36:46,640 --> 00:36:49,119
it has an offset so i don't know why but

903
00:36:49,119 --> 00:36:51,520
uh it started a bit before delay

904
00:36:51,520 --> 00:36:55,200
but um so uh

905
00:36:55,200 --> 00:36:57,599
whenever we want to uh run the program

906
00:36:57,599 --> 00:36:59,520
again we can just type

907
00:36:59,520 --> 00:37:02,640
c to continue or the word continue

908
00:37:02,640 --> 00:37:05,119
and there are like a lot of commands in

909
00:37:05,119 --> 00:37:07,119
gdb it's very powerful but there are a

910
00:37:07,119 --> 00:37:08,400
lot of commands

911
00:37:08,400 --> 00:37:11,440
and that's why i have prepared today a

912
00:37:11,440 --> 00:37:12,400
cheat sheet

913
00:37:12,400 --> 00:37:15,200
where is that yep a cheat sheet with the

914
00:37:15,200 --> 00:37:16,720
most common command like

915
00:37:16,720 --> 00:37:19,440
continue that we have seen or uh there

916
00:37:19,440 --> 00:37:21,280
is back trace somewhere here yeah back

917
00:37:21,280 --> 00:37:23,040
trace that we have seen

918
00:37:23,040 --> 00:37:25,599
and many other commands that we'll cover

919
00:37:25,599 --> 00:37:26,560
now or

920
00:37:26,560 --> 00:37:29,440
not cover uh but you will be able to

921
00:37:29,440 --> 00:37:30,880
learn about them

922
00:37:30,880 --> 00:37:34,240
um so yeah there is this cheat sheet

923
00:37:34,240 --> 00:37:36,960
that you can use and let's

924
00:37:36,960 --> 00:37:40,320
go and try to debug our fibo function

925
00:37:40,320 --> 00:37:42,800
so in order to debug our fiba function

926
00:37:42,800 --> 00:37:44,160
we need to do a few things

927
00:37:44,160 --> 00:37:46,480
first of all the program is already

928
00:37:46,480 --> 00:37:47,920
running so we can

929
00:37:47,920 --> 00:37:50,320
either press the pause button or just

930
00:37:50,320 --> 00:37:51,599
ctrl c

931
00:37:51,599 --> 00:37:54,960
ctrl control and c that would uh

932
00:37:54,960 --> 00:37:58,160
be the equivalent of pausing the program

933
00:37:58,160 --> 00:38:01,520
and yeah it tells us we are let's do

934
00:38:01,520 --> 00:38:04,560
uh backtrace again we are again inside

935
00:38:04,560 --> 00:38:06,400
delay inside loop

936
00:38:06,400 --> 00:38:09,920
and the first thing we want to do um

937
00:38:09,920 --> 00:38:12,160
we want to restart the program because

938
00:38:12,160 --> 00:38:13,760
uh right now

939
00:38:13,760 --> 00:38:16,400
um we have passed the place where fibo

940
00:38:16,400 --> 00:38:17,520
is

941
00:38:17,520 --> 00:38:21,920
so we can do that by

942
00:38:21,920 --> 00:38:25,839
setting the pc register to zero

943
00:38:25,839 --> 00:38:28,160
and let's have a look if we type in for

944
00:38:28,160 --> 00:38:29,200
registers

945
00:38:29,200 --> 00:38:31,680
we can see all the cpu registers so

946
00:38:31,680 --> 00:38:33,440
that's the equivalent of the brake

947
00:38:33,440 --> 00:38:34,640
instruction that we

948
00:38:34,640 --> 00:38:38,079
uh used on the and seen the value in the

949
00:38:38,079 --> 00:38:39,119
console

950
00:38:39,119 --> 00:38:41,280
so we can see all the registers and one

951
00:38:41,280 --> 00:38:42,160
of them is

952
00:38:42,160 --> 00:38:45,040
pc which is right now pointing at some

953
00:38:45,040 --> 00:38:46,480
point in delay

954
00:38:46,480 --> 00:38:50,240
and we can do something like uh set

955
00:38:50,240 --> 00:38:53,680
let's create a screen set pc dollar

956
00:38:53,680 --> 00:38:57,359
pc equals zero and if we do info

957
00:38:57,359 --> 00:38:58,800
registers again

958
00:38:58,800 --> 00:39:01,920
we can see that now pc has been

959
00:39:01,920 --> 00:39:04,160
set to zero so we jumped we forced the

960
00:39:04,160 --> 00:39:06,079
debugger to jump to the beginning of the

961
00:39:06,079 --> 00:39:06,880
program

962
00:39:06,880 --> 00:39:08,960
that's a nice way to get to the

963
00:39:08,960 --> 00:39:10,720
beginning of the program

964
00:39:10,720 --> 00:39:14,079
so right now if we type backtrace

965
00:39:14,079 --> 00:39:16,880
it will tell us you are like in this

966
00:39:16,880 --> 00:39:17,440
address

967
00:39:17,440 --> 00:39:19,920
0 at the beginning of program of the

968
00:39:19,920 --> 00:39:21,280
program you can

969
00:39:21,280 --> 00:39:23,359
see this here this is the beginning of

970
00:39:23,359 --> 00:39:24,400
the program

971
00:39:24,400 --> 00:39:26,800
and the first instruction is like a jump

972
00:39:26,800 --> 00:39:28,560
to um

973
00:39:28,560 --> 00:39:32,240
the beginning of uh of the code

974
00:39:32,240 --> 00:39:34,800
and we can tell it to run just one

975
00:39:34,800 --> 00:39:37,200
instruction we can type step i

976
00:39:37,200 --> 00:39:39,119
which would jump you see it took the

977
00:39:39,119 --> 00:39:41,280
jump and now it's in this address in

978
00:39:41,280 --> 00:39:44,079
underscore underscore init where is that

979
00:39:44,079 --> 00:39:45,040
for some reason

980
00:39:45,040 --> 00:39:48,240
it's not showing in the listing

981
00:39:48,240 --> 00:39:52,000
uh but yeah it's called here citor's

982
00:39:52,000 --> 00:39:54,640
end but it's the same and then we can

983
00:39:54,640 --> 00:39:55,680
just go you know

984
00:39:55,680 --> 00:40:00,079
instruction by instruction but um

985
00:40:00,079 --> 00:40:03,040
we don't want to do that we want just to

986
00:40:03,040 --> 00:40:03,440
go

987
00:40:03,440 --> 00:40:07,440
to uh fibonacci so what we can do

988
00:40:07,440 --> 00:40:10,560
we can uh tell the code hey we want you

989
00:40:10,560 --> 00:40:11,119
to

990
00:40:11,119 --> 00:40:13,280
do a break point to break before this

991
00:40:13,280 --> 00:40:14,800
instruction so

992
00:40:14,800 --> 00:40:17,119
we just write break fibble and that

993
00:40:17,119 --> 00:40:18,560
would uh place a

994
00:40:18,560 --> 00:40:21,599
breakpoint you see hackaday.s

995
00:40:21,599 --> 00:40:24,800
that's our file line 16 in this line

996
00:40:24,800 --> 00:40:28,000
um and then we can just uh run

997
00:40:28,000 --> 00:40:31,040
the program continue and you see it

998
00:40:31,040 --> 00:40:32,240
started running

999
00:40:32,240 --> 00:40:35,680
the led went on for some reason probably

1000
00:40:35,680 --> 00:40:38,640
i don't know even why uh maybe it never

1001
00:40:38,640 --> 00:40:40,319
went off because we sort of

1002
00:40:40,319 --> 00:40:42,000
uh jumped to the beginning of the

1003
00:40:42,000 --> 00:40:44,160
program and you can see that we are in

1004
00:40:44,160 --> 00:40:44,800
this

1005
00:40:44,800 --> 00:40:48,640
push r16 line and um

1006
00:40:48,640 --> 00:40:51,040
we can print the value of sp here and

1007
00:40:51,040 --> 00:40:52,800
see this is the value

1008
00:40:52,800 --> 00:40:56,000
and we can also use this instruction and

1009
00:40:56,000 --> 00:40:57,760
again like i don't expect you to

1010
00:40:57,760 --> 00:40:59,920
remember all these instructions that

1011
00:40:59,920 --> 00:41:02,560
just know that they exist so uh you can

1012
00:41:02,560 --> 00:41:03,280
use this

1013
00:41:03,280 --> 00:41:06,319
uh uh cheat sheet that uh

1014
00:41:06,319 --> 00:41:08,880
we have somewhere here um you can use

1015
00:41:08,880 --> 00:41:09,359
that

1016
00:41:09,359 --> 00:41:12,400
cheat sheet to uh recall them so we can

1017
00:41:12,400 --> 00:41:15,599
tell it uh print eight bytes in

1018
00:41:15,599 --> 00:41:18,400
uh hexadecimal so eight hexadecimal

1019
00:41:18,400 --> 00:41:18,880
bytes

1020
00:41:18,880 --> 00:41:21,920
it's really cryptic i know like the asm

1021
00:41:21,920 --> 00:41:25,200
starting from the address of sp and

1022
00:41:25,200 --> 00:41:28,240
uh actually hexadecimal is x

1023
00:41:28,240 --> 00:41:31,599
you see i even get confused sometimes

1024
00:41:31,599 --> 00:41:33,599
so yeah so that's what we have at the

1025
00:41:33,599 --> 00:41:34,800
stack right now

1026
00:41:34,800 --> 00:41:38,079
6 3 7 c probably some

1027
00:41:38,079 --> 00:41:40,480
return address of the function that

1028
00:41:40,480 --> 00:41:41,760
called us

1029
00:41:41,760 --> 00:41:44,960
and then um if we run the next

1030
00:41:44,960 --> 00:41:46,240
instruction so

1031
00:41:46,240 --> 00:41:49,280
next or next i we we see that now it's

1032
00:41:49,280 --> 00:41:50,720
inside cpi

1033
00:41:50,720 --> 00:41:53,760
but if we print sp again we can see that

1034
00:41:53,760 --> 00:41:54,560
the value

1035
00:41:54,560 --> 00:41:58,000
was decremented so uh push decremented

1036
00:41:58,000 --> 00:41:58,960
the value

1037
00:41:58,960 --> 00:42:02,000
and r16 i think it was

1038
00:42:02,000 --> 00:42:05,040
zero if i'm not mistaken uh

1039
00:42:05,040 --> 00:42:07,359
the val when we did break before i saw

1040
00:42:07,359 --> 00:42:08,880
that the value was zero

1041
00:42:08,880 --> 00:42:11,599
we can print the stack and we can see

1042
00:42:11,599 --> 00:42:12,319
that there is

1043
00:42:12,319 --> 00:42:17,040
um zero at the top of the stack um

1044
00:42:17,040 --> 00:42:18,880
yeah that's the value it pushed to the

1045
00:42:18,880 --> 00:42:20,400
top of the stack and that's

1046
00:42:20,400 --> 00:42:24,160
the previous value um sp always points

1047
00:42:24,160 --> 00:42:26,960
on the next byte of the stack so uh this

1048
00:42:26,960 --> 00:42:27,680
was like

1049
00:42:27,680 --> 00:42:30,079
uh when we printed it here this was like

1050
00:42:30,079 --> 00:42:30,960
the next byte

1051
00:42:30,960 --> 00:42:33,760
to be uh overhead and by push and now

1052
00:42:33,760 --> 00:42:34,480
push just

1053
00:42:34,480 --> 00:42:37,599
overrode it and wrote this zero value

1054
00:42:37,599 --> 00:42:40,319
and we can just you know continue and

1055
00:42:40,319 --> 00:42:40,960
see that

1056
00:42:40,960 --> 00:42:44,640
uh it goes to line 18 bre q1f

1057
00:42:44,640 --> 00:42:47,839
and it didn't take the branch because

1058
00:42:47,839 --> 00:42:51,839
um it wasn't equal and then compare

1059
00:42:51,839 --> 00:42:55,520
and bre q1f and then if we type next

1060
00:42:55,520 --> 00:42:58,960
we can see it actually took the branch

1061
00:42:58,960 --> 00:43:00,720
it skipped all this code and went

1062
00:43:00,720 --> 00:43:03,200
straight into pop r16

1063
00:43:03,200 --> 00:43:07,919
so um that's like the very basic

1064
00:43:10,560 --> 00:43:14,640
of working with gdb uh to debug assembly

1065
00:43:14,640 --> 00:43:15,119
code

1066
00:43:15,119 --> 00:43:18,240
but it doesn't have to stop here

1067
00:43:18,240 --> 00:43:20,720
first of all let me show you one feature

1068
00:43:20,720 --> 00:43:21,520
that i think

1069
00:43:21,520 --> 00:43:24,839
makes a amazing difference

1070
00:43:24,839 --> 00:43:28,079
um instead of uh typing all those

1071
00:43:28,079 --> 00:43:29,839
commands and like seeing

1072
00:43:29,839 --> 00:43:32,240
where we are in the current uh function

1073
00:43:32,240 --> 00:43:34,079
we can like always

1074
00:43:34,079 --> 00:43:36,800
list fibo to see the uh beginning of the

1075
00:43:36,800 --> 00:43:37,760
function

1076
00:43:37,760 --> 00:43:40,800
um or i think we can tell list

1077
00:43:40,800 --> 00:43:44,160
how many lines to show

1078
00:43:45,680 --> 00:43:50,960
yeah we can change show list size

1079
00:43:50,960 --> 00:43:54,160
yeah by default it will show 10 um

1080
00:43:54,160 --> 00:43:55,599
[Music]

1081
00:43:55,599 --> 00:43:57,599
but we can change this leaf default

1082
00:43:57,599 --> 00:44:00,000
probably we're using yeah

1083
00:44:00,000 --> 00:44:03,680
set list size but um

1084
00:44:03,680 --> 00:44:06,319
we can also give it two arguments uh

1085
00:44:06,319 --> 00:44:07,280
yeah it's a bit

1086
00:44:07,280 --> 00:44:09,839
uh the font is big so it's cutting the

1087
00:44:09,839 --> 00:44:11,280
line but

1088
00:44:11,280 --> 00:44:16,480
we can do just like this fibo 20 or

1089
00:44:16,480 --> 00:44:19,280
maybe this one

1090
00:44:20,800 --> 00:44:24,480
okay not sure why uh yeah it's hard to

1091
00:44:24,480 --> 00:44:26,240
really help this way but you can figure

1092
00:44:26,240 --> 00:44:26,880
it out

1093
00:44:26,880 --> 00:44:30,720
later uh to see how to tell it

1094
00:44:30,720 --> 00:44:33,760
uh yeah i think

1095
00:44:33,760 --> 00:44:37,520
ah maybe fibo plus 10

1096
00:44:37,520 --> 00:44:39,839
something like that not sure you can

1097
00:44:39,839 --> 00:44:40,880
check it out later

1098
00:44:40,880 --> 00:44:44,720
anyway uh so that's the uh archaic way

1099
00:44:44,720 --> 00:44:46,079
to use gdb

1100
00:44:46,079 --> 00:44:49,440
there is a better way which uh shows you

1101
00:44:49,440 --> 00:44:50,000
the code

1102
00:44:50,000 --> 00:44:52,319
in split screen and to do that uh you

1103
00:44:52,319 --> 00:44:53,440
need to write uh

1104
00:44:53,440 --> 00:44:55,680
there are a few ways to enable that in

1105
00:44:55,680 --> 00:44:57,520
gdb in general they're like

1106
00:44:57,520 --> 00:45:01,119
uh you can write big back trace okay

1107
00:45:01,119 --> 00:45:02,880
back trace to like show the back

1108
00:45:02,880 --> 00:45:05,040
pictures you can also type bt

1109
00:45:05,040 --> 00:45:07,040
you can also type work they all do the

1110
00:45:07,040 --> 00:45:09,440
same so there are like a few ways to do

1111
00:45:09,440 --> 00:45:13,280
everything which is a bit confusing

1112
00:45:13,280 --> 00:45:16,480
um but if you just want this uh

1113
00:45:16,480 --> 00:45:18,960
nice feature one way is to write a

1114
00:45:18,960 --> 00:45:19,839
layout

1115
00:45:19,839 --> 00:45:23,599
asm and that would show a split screen

1116
00:45:23,599 --> 00:45:26,160
where on the top you see the assembly

1117
00:45:26,160 --> 00:45:26,640
source

1118
00:45:26,640 --> 00:45:29,920
and you can like scroll it and uh

1119
00:45:29,920 --> 00:45:32,960
yeah and see everything that

1120
00:45:32,960 --> 00:45:36,880
uh yeah gdp ui that's what it's called

1121
00:45:36,880 --> 00:45:39,280
uh and scroll it and see where you are

1122
00:45:39,280 --> 00:45:40,000
right now

1123
00:45:40,000 --> 00:45:42,319
uh like right now we are in the pop and

1124
00:45:42,319 --> 00:45:43,520
then if we

1125
00:45:43,520 --> 00:45:46,640
do uh next or we can just write n

1126
00:45:46,640 --> 00:45:47,920
instead of next

1127
00:45:47,920 --> 00:45:50,880
it will just uh go to the next line and

1128
00:45:50,880 --> 00:45:52,000
to the red

1129
00:45:52,000 --> 00:45:55,280
and then we can go next again and

1130
00:45:55,280 --> 00:45:57,520
whoa well now we are in a totally

1131
00:45:57,520 --> 00:46:00,480
different location

1132
00:46:00,640 --> 00:46:04,480
but now this is actually c code so

1133
00:46:04,480 --> 00:46:07,839
uh we can ask gdb to show us

1134
00:46:07,839 --> 00:46:11,520
a layout src to switch to showing us the

1135
00:46:11,520 --> 00:46:12,560
source code

1136
00:46:12,560 --> 00:46:14,560
so now we can see where we are at the

1137
00:46:14,560 --> 00:46:16,640
source code and i can scroll here

1138
00:46:16,640 --> 00:46:19,119
a bit with the mouse so you can see or

1139
00:46:19,119 --> 00:46:20,160
with the keyboard

1140
00:46:20,160 --> 00:46:22,880
you can see now we are inside a setup in

1141
00:46:22,880 --> 00:46:24,000
this line

1142
00:46:24,000 --> 00:46:27,520
or we can ask it to use a split layout

1143
00:46:27,520 --> 00:46:28,000
lay

1144
00:46:28,000 --> 00:46:31,200
out split and then we see both

1145
00:46:31,200 --> 00:46:34,960
the uh source code and the corresponding

1146
00:46:34,960 --> 00:46:39,280
assembly code oh well i scroll too much

1147
00:46:39,280 --> 00:46:42,880
okay yeah and um

1148
00:46:42,880 --> 00:46:45,119
one thing to know if you are using that

1149
00:46:45,119 --> 00:46:47,440
then you can no longer use the

1150
00:46:47,440 --> 00:46:50,960
up and down keys to scroll through the

1151
00:46:50,960 --> 00:46:53,359
history of the commands

1152
00:46:53,359 --> 00:46:55,599
or you can if you change the focus so

1153
00:46:55,599 --> 00:46:57,839
you can type focus next and now the

1154
00:46:57,839 --> 00:46:58,400
focus

1155
00:46:58,400 --> 00:47:00,480
is on the assembly window and we can

1156
00:47:00,480 --> 00:47:01,760
scroll there

1157
00:47:01,760 --> 00:47:04,800
and focus next again to uh

1158
00:47:04,800 --> 00:47:07,359
go to the command window and now we can

1159
00:47:07,359 --> 00:47:08,560
uh

1160
00:47:08,560 --> 00:47:11,040
just you know go to the command history

1161
00:47:11,040 --> 00:47:11,680
so

1162
00:47:11,680 --> 00:47:13,839
i find this super useful when you debug

1163
00:47:13,839 --> 00:47:15,599
code and you want to see

1164
00:47:15,599 --> 00:47:18,480
actually where you are at and if i type

1165
00:47:18,480 --> 00:47:19,119
next

1166
00:47:19,119 --> 00:47:22,400
then uh i will go out of setup and

1167
00:47:22,400 --> 00:47:26,000
here i am inside main and i can

1168
00:47:26,000 --> 00:47:29,280
see both the um

1169
00:47:29,280 --> 00:47:32,400
the c code and uh the

1170
00:47:32,400 --> 00:47:35,440
assembly code now if i want to go

1171
00:47:35,440 --> 00:47:37,760
if i type next here it goes overloop so

1172
00:47:37,760 --> 00:47:40,000
you can see it blinks the led once

1173
00:47:40,000 --> 00:47:43,280
and pauses but

1174
00:47:43,280 --> 00:47:46,240
if you want to go into loop you can just

1175
00:47:46,240 --> 00:47:46,640
type

1176
00:47:46,640 --> 00:47:49,760
step and that's like step into so

1177
00:47:49,760 --> 00:47:53,599
now i'm inside loop and i can i

1178
00:47:53,599 --> 00:47:55,920
type next and you see when i type next

1179
00:47:55,920 --> 00:47:57,440
it skipped all those assembly

1180
00:47:57,440 --> 00:47:58,559
instruction

1181
00:47:58,559 --> 00:48:00,800
but i can also go instruction by

1182
00:48:00,800 --> 00:48:02,000
instruction if i do

1183
00:48:02,000 --> 00:48:04,559
next i next instruction then it will

1184
00:48:04,559 --> 00:48:05,520
just jump

1185
00:48:05,520 --> 00:48:09,040
one instruction at a time and

1186
00:48:09,040 --> 00:48:12,960
uh since it's next it just uh

1187
00:48:12,960 --> 00:48:16,000
stepped over delay but uh i can

1188
00:48:16,000 --> 00:48:20,079
uh like like i did before i can just

1189
00:48:20,079 --> 00:48:22,880
step into digital write and here i can

1190
00:48:22,880 --> 00:48:25,440
also like debug it line by line

1191
00:48:25,440 --> 00:48:28,240
by typing next at the c code level or

1192
00:48:28,240 --> 00:48:30,800
next i just to go one instruction at a

1193
00:48:30,800 --> 00:48:31,599
time

1194
00:48:31,599 --> 00:48:34,160
and at any time i can print any of the

1195
00:48:34,160 --> 00:48:35,599
registers like

1196
00:48:35,599 --> 00:48:37,920
let's say i want to know uh it did

1197
00:48:37,920 --> 00:48:38,640
something with

1198
00:48:38,640 --> 00:48:42,240
r30 i can print r30 and see the value

1199
00:48:42,240 --> 00:48:45,200
or i can print it with x that would give

1200
00:48:45,200 --> 00:48:45,520
me

1201
00:48:45,520 --> 00:48:48,559
hexa decimal version

1202
00:48:48,559 --> 00:48:49,430
and um

1203
00:48:49,430 --> 00:48:51,680
[Music]

1204
00:48:51,680 --> 00:48:53,599
this is fun i mean i can modify

1205
00:48:53,599 --> 00:48:56,079
registers i can do stuff like

1206
00:48:56,079 --> 00:48:58,800
uh read from memory right from the

1207
00:48:58,800 --> 00:48:59,520
memory

1208
00:48:59,520 --> 00:49:02,160
i i have total god mode on this

1209
00:49:02,160 --> 00:49:03,520
microcontroller

1210
00:49:03,520 --> 00:49:06,480
um one fun thing i can do i can do

1211
00:49:06,480 --> 00:49:07,680
something like

1212
00:49:07,680 --> 00:49:11,359
set port b to say uh

1213
00:49:11,359 --> 00:49:14,960
port d so poor d is like

1214
00:49:14,960 --> 00:49:18,720
wait a second okay so uh let's set

1215
00:49:18,720 --> 00:49:21,760
uh ddrd so if you remember from the

1216
00:49:21,760 --> 00:49:22,720
first lesson

1217
00:49:22,720 --> 00:49:25,760
ddrd controls uh the data direction

1218
00:49:25,760 --> 00:49:28,480
of the pins zero to seven all pins in

1219
00:49:28,480 --> 00:49:29,440
for 4d

1220
00:49:29,440 --> 00:49:32,800
so i can set it to 0ff and then

1221
00:49:32,800 --> 00:49:35,920
set port d to 0ff

1222
00:49:35,920 --> 00:49:39,200
and see what happens all the leds are on

1223
00:49:39,200 --> 00:49:41,839
because i just wrote to the register to

1224
00:49:41,839 --> 00:49:44,319
the mcu register that controls them so

1225
00:49:44,319 --> 00:49:47,359
i can basically you know just write

1226
00:49:47,359 --> 00:49:49,359
to any location in the memory including

1227
00:49:49,359 --> 00:49:50,400
registers and

1228
00:49:50,400 --> 00:49:54,319
it just works not only that i can even

1229
00:49:54,319 --> 00:49:58,720
call functions i can call fibo 24

1230
00:49:58,720 --> 00:50:01,200
and oh i need to tell you that fibo

1231
00:50:01,200 --> 00:50:02,079
returns an

1232
00:50:02,079 --> 00:50:05,520
integer and ooh

1233
00:50:05,520 --> 00:50:09,200
yeah we had a problem uh with fibo what

1234
00:50:09,200 --> 00:50:12,880
what's that yeah maybe 24 was too big

1235
00:50:12,880 --> 00:50:14,800
oh yeah i think we had a break point

1236
00:50:14,800 --> 00:50:16,160
there right let's see

1237
00:50:16,160 --> 00:50:18,960
so there is info break points in for

1238
00:50:18,960 --> 00:50:21,040
break points

1239
00:50:21,040 --> 00:50:23,680
uh yeah we have a fibo breakpoint and

1240
00:50:23,680 --> 00:50:24,319
that's why

1241
00:50:24,319 --> 00:50:27,359
uh the debugger stopped there instead of

1242
00:50:27,359 --> 00:50:30,400
executing the function

1243
00:50:30,400 --> 00:50:32,559
so we can delete this breakpoint and

1244
00:50:32,559 --> 00:50:34,079
then we can try to

1245
00:50:34,079 --> 00:50:38,319
call fibo fibo 10 for instance

1246
00:50:38,319 --> 00:50:42,000
and we need to tell it it's an integer

1247
00:50:42,000 --> 00:50:44,960
and we can see like yeah we can call it

1248
00:50:44,960 --> 00:50:45,680
from the

1249
00:50:45,680 --> 00:50:48,400
uh command line uh from gdb unless we

1250
00:50:48,400 --> 00:50:50,240
have a breakpoint

1251
00:50:50,240 --> 00:50:53,119
um another useful thing we can do let's

1252
00:50:53,119 --> 00:50:54,000
say right now

1253
00:50:54,000 --> 00:50:56,800
we are uh actually we are in a strange

1254
00:50:56,800 --> 00:50:58,559
situation because we are in the middle

1255
00:50:58,559 --> 00:51:00,559
of fibo that was called from the middle

1256
00:51:00,559 --> 00:51:02,720
of digital right so it might screw up

1257
00:51:02,720 --> 00:51:03,760
things a little

1258
00:51:03,760 --> 00:51:07,599
uh so let's just set pc again to zero to

1259
00:51:07,599 --> 00:51:09,520
go to the beginning of the program and

1260
00:51:09,520 --> 00:51:10,480
start from

1261
00:51:10,480 --> 00:51:13,520
a clean state um and then there is

1262
00:51:13,520 --> 00:51:15,839
another nice uh function that called

1263
00:51:15,839 --> 00:51:18,640
advanced which advanced which tells the

1264
00:51:18,640 --> 00:51:19,760
cpu to go

1265
00:51:19,760 --> 00:51:23,280
until to run until it gets into

1266
00:51:23,280 --> 00:51:25,280
another into the given function in this

1267
00:51:25,280 --> 00:51:27,440
case loop so advanced loop

1268
00:51:27,440 --> 00:51:31,680
uh yeah wow i think we are

1269
00:51:31,680 --> 00:51:34,160
uh calling fibo and putting a breakpoint

1270
00:51:34,160 --> 00:51:34,880
in sort

1271
00:51:34,880 --> 00:51:38,079
sort of um sort of

1272
00:51:38,079 --> 00:51:41,440
uh interfered with gdb so

1273
00:51:41,440 --> 00:51:44,720
uh yes let's just quit gdb and

1274
00:51:44,720 --> 00:51:47,680
uh yeah it will just reload and now

1275
00:51:47,680 --> 00:51:49,040
let's see

1276
00:51:49,040 --> 00:51:52,240
where are we oh wow now there is a

1277
00:51:52,240 --> 00:51:54,559
strange situation with the console

1278
00:51:54,559 --> 00:51:58,559
um yeah

1279
00:52:02,839 --> 00:52:05,839
maybe

1280
00:52:08,319 --> 00:52:10,800
okay let's just uh open it again that

1281
00:52:10,800 --> 00:52:14,079
would be the easiest solution

1282
00:52:14,319 --> 00:52:16,640
yeah so that's the better way to restart

1283
00:52:16,640 --> 00:52:18,079
the simulation just

1284
00:52:18,079 --> 00:52:21,359
restart gdp altogether anyway

1285
00:52:21,359 --> 00:52:23,280
so where were we oh we were speaking

1286
00:52:23,280 --> 00:52:24,559
about advanced so

1287
00:52:24,559 --> 00:52:28,000
again we are uh x-rays

1288
00:52:28,000 --> 00:52:31,359
at the beginning and uh we can just tell

1289
00:52:31,359 --> 00:52:33,440
it advanced loop and it will run the

1290
00:52:33,440 --> 00:52:36,160
program until the first line of loop

1291
00:52:36,160 --> 00:52:39,280
and now let's again do layout

1292
00:52:39,280 --> 00:52:42,960
so uh split to see both the assembly and

1293
00:52:42,960 --> 00:52:43,359
the

1294
00:52:43,359 --> 00:52:46,559
uh and the

1295
00:52:46,559 --> 00:52:51,040
c code and we can do something like um

1296
00:52:51,040 --> 00:52:55,920
step i to go over the loop function

1297
00:52:55,920 --> 00:52:59,599
step by step instruction by instruction

1298
00:52:59,599 --> 00:53:02,640
and it's pretty annoying

1299
00:53:02,640 --> 00:53:05,599
to type step i every time so i can use

1300
00:53:05,599 --> 00:53:06,720
the short version

1301
00:53:06,720 --> 00:53:11,280
si which will do the same or i can just

1302
00:53:11,280 --> 00:53:14,400
hit enter and hitting enter return

1303
00:53:14,400 --> 00:53:16,880
will just execute the last command again

1304
00:53:16,880 --> 00:53:19,520
so that's a cool way to just you know

1305
00:53:19,520 --> 00:53:21,200
run the program instruction by

1306
00:53:21,200 --> 00:53:23,119
instruction or line by line

1307
00:53:23,119 --> 00:53:26,720
if i do step and not step i so it would

1308
00:53:26,720 --> 00:53:29,760
right now uh you see it skips a line in

1309
00:53:29,760 --> 00:53:31,839
the source code every time

1310
00:53:31,839 --> 00:53:35,119
so um yeah so

1311
00:53:35,119 --> 00:53:39,280
uh that's another cool keyboard shortcut

1312
00:53:39,280 --> 00:53:42,800
now um this is just the basic of gdb

1313
00:53:42,800 --> 00:53:44,800
where you can set breakpoints you can

1314
00:53:44,800 --> 00:53:46,319
step through the program

1315
00:53:46,319 --> 00:53:49,440
and um you can do all these

1316
00:53:49,440 --> 00:53:51,760
things that you probably expect debugger

1317
00:53:51,760 --> 00:53:52,480
to do

1318
00:53:52,480 --> 00:53:55,520
but it has a lot more to offer one of

1319
00:53:55,520 --> 00:53:57,119
the features that i really like

1320
00:53:57,119 --> 00:54:00,640
is this d print function so

1321
00:54:00,640 --> 00:54:04,800
let's just disable the dui for a moment

1322
00:54:04,800 --> 00:54:08,319
disable dui disable that would

1323
00:54:08,319 --> 00:54:11,839
hide the text interface and d print

1324
00:54:11,839 --> 00:54:15,040
allows me to print something whenever uh

1325
00:54:15,040 --> 00:54:17,760
the com the source code gets to a

1326
00:54:17,760 --> 00:54:19,040
specific point

1327
00:54:19,040 --> 00:54:22,000
for instance i can say i want to print

1328
00:54:22,000 --> 00:54:23,119
uh every time

1329
00:54:23,119 --> 00:54:27,440
i start loop i want to print hello loop

1330
00:54:27,440 --> 00:54:30,400
and then if i hit continue i will see

1331
00:54:30,400 --> 00:54:30,800
that

1332
00:54:30,800 --> 00:54:34,079
whenever a loop runs i get this output

1333
00:54:34,079 --> 00:54:34,880
to the

1334
00:54:34,880 --> 00:54:38,559
terminal so basically uh i can

1335
00:54:38,559 --> 00:54:41,200
uh see what's going on with how without

1336
00:54:41,200 --> 00:54:43,760
having to uh type things or you know set

1337
00:54:43,760 --> 00:54:45,280
up breakpoints

1338
00:54:45,280 --> 00:54:48,079
and we can even make it a bit more a bit

1339
00:54:48,079 --> 00:54:49,760
smarter let's say we had

1340
00:54:49,760 --> 00:54:53,280
um some counter here and that counter

1341
00:54:53,280 --> 00:54:54,000
just you know

1342
00:54:54,000 --> 00:54:57,839
increments and we use this for the delay

1343
00:54:57,839 --> 00:54:59,680
for the first delay so

1344
00:54:59,680 --> 00:55:03,599
some kind of uh dump pwm or i don't know

1345
00:55:03,599 --> 00:55:04,559
what

1346
00:55:04,559 --> 00:55:07,200
and uh let's restart the gdb with the

1347
00:55:07,200 --> 00:55:09,280
new program

1348
00:55:09,280 --> 00:55:12,720
move it over there okay

1349
00:55:12,720 --> 00:55:16,240
so uh now i can do oh sometimes

1350
00:55:16,240 --> 00:55:18,720
it doesn't work correctly if it gets

1351
00:55:18,720 --> 00:55:20,079
taxier it gets

1352
00:55:20,079 --> 00:55:22,240
stuck here it will print an error

1353
00:55:22,240 --> 00:55:23,520
message in a moment

1354
00:55:23,520 --> 00:55:25,839
just try it again this is still

1355
00:55:25,839 --> 00:55:28,400
something i'm trying to iron out

1356
00:55:28,400 --> 00:55:33,520
uh okay so uh now we can do

1357
00:55:33,520 --> 00:55:35,839
something like the print loop and we can

1358
00:55:35,839 --> 00:55:37,119
print something like

1359
00:55:37,119 --> 00:55:41,119
counter and

1360
00:55:41,119 --> 00:55:43,920
print the value of counter and then if

1361
00:55:43,920 --> 00:55:45,920
we run the program it will actually

1362
00:55:45,920 --> 00:55:47,760
print the values of counter as the

1363
00:55:47,760 --> 00:55:48,880
program is running

1364
00:55:48,880 --> 00:55:52,240
so we can sort of oh it stopped because

1365
00:55:52,240 --> 00:55:52,880
uh

1366
00:55:52,880 --> 00:55:55,599
the screen was uh over the screen space

1367
00:55:55,599 --> 00:55:56,400
was over

1368
00:55:56,400 --> 00:55:59,200
so we can actually add debug prints a

1369
00:55:59,200 --> 00:56:00,720
priori after the

1370
00:56:00,720 --> 00:56:03,119
like to the ready program while we're

1371
00:56:03,119 --> 00:56:05,280
debugging and we can remove them and we

1372
00:56:05,280 --> 00:56:05,680
can

1373
00:56:05,680 --> 00:56:08,880
uh play around with them and you know

1374
00:56:08,880 --> 00:56:09,599
this was

1375
00:56:09,599 --> 00:56:12,640
uh just a quick introduction to gdb

1376
00:56:12,640 --> 00:56:15,680
to scratch the surface but uh

1377
00:56:15,680 --> 00:56:18,000
there is a lot more to it i don't know

1378
00:56:18,000 --> 00:56:19,200
where i put the

1379
00:56:19,200 --> 00:56:23,280
uh link oh here it is uh there are like

1380
00:56:23,280 --> 00:56:26,799
a lot many other things you can do um

1381
00:56:26,799 --> 00:56:30,720
like showing um disassembly of functions

1382
00:56:30,720 --> 00:56:34,160
and uh dumping random memory

1383
00:56:34,160 --> 00:56:38,160
bytes and uh like uh

1384
00:56:38,160 --> 00:56:40,240
setting registers we have seen that

1385
00:56:40,240 --> 00:56:42,319
setting variables we can change the

1386
00:56:42,319 --> 00:56:44,000
value of counter as the program

1387
00:56:44,000 --> 00:56:48,240
is running and

1388
00:56:48,799 --> 00:56:52,400
if you really want to dive into gdb then

1389
00:56:52,400 --> 00:56:55,119
i think the best way to do it is to read

1390
00:56:55,119 --> 00:56:55,520
this

1391
00:56:55,520 --> 00:56:58,319
very long manual it's very long it's

1392
00:56:58,319 --> 00:56:59,599
detailed but

1393
00:56:59,599 --> 00:57:02,720
uh it's good it i will

1394
00:57:02,720 --> 00:57:06,240
just post the link but uh

1395
00:57:06,240 --> 00:57:08,319
what you have seen today is probably

1396
00:57:08,319 --> 00:57:09,359
enough to

1397
00:57:09,359 --> 00:57:13,359
you know get by and start exploring

1398
00:57:13,359 --> 00:57:16,240
arduino code and assembly code with ggb

1399
00:57:16,240 --> 00:57:16,880
and

1400
00:57:16,880 --> 00:57:19,599
also it's good enough to be useful for

1401
00:57:19,599 --> 00:57:21,440
you when you debug your code and you

1402
00:57:21,440 --> 00:57:22,720
want to know

1403
00:57:22,720 --> 00:57:26,079
why like something doesn't work

1404
00:57:26,079 --> 00:57:28,240
as you want then you can just set

1405
00:57:28,240 --> 00:57:30,000
breakpoints or

1406
00:57:30,000 --> 00:57:34,079
um step instructions one by one or use

1407
00:57:34,079 --> 00:57:35,440
this d print

1408
00:57:35,440 --> 00:57:37,920
to print whatever you can like print uh

1409
00:57:37,920 --> 00:57:38,720
the value of

1410
00:57:38,720 --> 00:57:42,640
register instead of counter so like uh

1411
00:57:42,640 --> 00:57:45,040
it's not very useful i guess uh in this

1412
00:57:45,040 --> 00:57:46,079
context but

1413
00:57:46,079 --> 00:57:49,760
uh yeah so we can see that now it prints

1414
00:57:49,760 --> 00:57:50,559
both

1415
00:57:50,559 --> 00:57:53,680
uh the value of uh r0

1416
00:57:53,680 --> 00:57:57,200
and the uh value of counter so

1417
00:57:57,200 --> 00:57:59,040
it's not really useful in this context

1418
00:57:59,040 --> 00:58:00,640
because this is c code and you don't

1419
00:58:00,640 --> 00:58:02,400
really care about r0

1420
00:58:02,400 --> 00:58:04,480
but in your code you can actually use it

1421
00:58:04,480 --> 00:58:07,680
to if you have a function that runs

1422
00:58:07,680 --> 00:58:10,079
you know many iterations that runs for

1423
00:58:10,079 --> 00:58:11,119
many iterations

1424
00:58:11,119 --> 00:58:14,000
and you only want to uh print the values

1425
00:58:14,000 --> 00:58:15,680
and you don't want to break every time

1426
00:58:15,680 --> 00:58:17,760
then you can use d print for that

1427
00:58:17,760 --> 00:58:19,680
and there are like conditional break

1428
00:58:19,680 --> 00:58:21,599
points so you can only break

1429
00:58:21,599 --> 00:58:24,960
if our 16 equals to something

1430
00:58:24,960 --> 00:58:28,240
or like the possibilities are endless

1431
00:58:28,240 --> 00:58:30,480
we are like just scratching the surface

1432
00:58:30,480 --> 00:58:32,319
there are macros

1433
00:58:32,319 --> 00:58:34,960
that you can define and it's very

1434
00:58:34,960 --> 00:58:36,079
powerful

1435
00:58:36,079 --> 00:58:38,720
and this version of gdb is a bit it's

1436
00:58:38,720 --> 00:58:41,280
like the latest version 10.1 but

1437
00:58:41,280 --> 00:58:43,520
it's a bit strict it doesn't include a

1438
00:58:43,520 --> 00:58:45,359
very powerful feature which is the

1439
00:58:45,359 --> 00:58:47,119
python scripting engine

1440
00:58:47,119 --> 00:58:49,440
but if you use local gdb you can also

1441
00:58:49,440 --> 00:58:51,200
script it with python

1442
00:58:51,200 --> 00:58:55,280
and create scripts that will pretty

1443
00:58:55,280 --> 00:58:57,119
print your data structures

1444
00:58:57,119 --> 00:59:00,640
and whatnot so um

1445
00:59:00,640 --> 00:59:03,680
that's a very powerful tool and um

1446
00:59:03,680 --> 00:59:06,559
it's very i think it will be very useful

1447
00:59:06,559 --> 00:59:07,520
for you when you

1448
00:59:07,520 --> 00:59:10,559
uh work on your uh final project

1449
00:59:10,559 --> 00:59:13,920
and uh before we move to the q a uh

1450
00:59:13,920 --> 00:59:16,400
i think that's a good opportunity um

1451
00:59:16,400 --> 00:59:18,720
about to tell you that uh

1452
00:59:18,720 --> 00:59:20,480
deadline for the final project i think

1453
00:59:20,480 --> 00:59:22,000
you should have received an email about

1454
00:59:22,000 --> 00:59:22,559
that

1455
00:59:22,559 --> 00:59:24,559
but the deadline for the final project

1456
00:59:24,559 --> 00:59:25,599
is

1457
00:59:25,599 --> 00:59:28,720
march 21 so the end of march

1458
00:59:28,720 --> 00:59:31,119
so you'll have about one month to

1459
00:59:31,119 --> 00:59:32,799
complete it if you want

1460
00:59:32,799 --> 00:59:35,920
once the course end and

1461
00:59:35,920 --> 00:59:38,880
that's it for today's lesson and now

1462
00:59:38,880 --> 00:59:39,440
let's

1463
00:59:39,440 --> 00:59:41,599
check out the chat to see what we have

1464
00:59:41,599 --> 00:59:42,799
in the

1465
00:59:42,799 --> 00:59:47,040
q a

1466
00:59:47,040 --> 00:59:49,119
you

