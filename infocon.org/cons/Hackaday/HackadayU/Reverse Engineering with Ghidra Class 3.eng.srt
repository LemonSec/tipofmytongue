1
00:00:00,000 --> 00:00:09,440
[Music]

2
00:00:09,440 --> 00:00:11,440
all right so let's get started so

3
00:00:11,440 --> 00:00:13,440
welcome to session three of introduction

4
00:00:13,440 --> 00:00:14,960
to reverse engineering software with

5
00:00:14,960 --> 00:00:15,679
geidra

6
00:00:15,679 --> 00:00:17,840
today we're going to go over a little

7
00:00:17,840 --> 00:00:20,000
more of you know the sea to assembly

8
00:00:20,000 --> 00:00:21,520
kind of translation that we talked about

9
00:00:21,520 --> 00:00:22,240
before

10
00:00:22,240 --> 00:00:24,560
and we're also going to talk about some

11
00:00:24,560 --> 00:00:26,240
other deidra features that we

12
00:00:26,240 --> 00:00:27,840
haven't really covered yet that are

13
00:00:27,840 --> 00:00:29,519
going to come in handy as you do this

14
00:00:29,519 --> 00:00:32,720
next round of exercises

15
00:00:33,280 --> 00:00:34,960
so like i said today we'll do a quick

16
00:00:34,960 --> 00:00:36,320
amount of class admin we kind of got

17
00:00:36,320 --> 00:00:38,000
that out of the way earlier

18
00:00:38,000 --> 00:00:39,680
a lot of folks have asked about the

19
00:00:39,680 --> 00:00:41,040
differences between

20
00:00:41,040 --> 00:00:42,640
certain software reverse engineering

21
00:00:42,640 --> 00:00:44,239
tools so i put together a few slides

22
00:00:44,239 --> 00:00:46,000
just listing pros and cons of all of

23
00:00:46,000 --> 00:00:46,480
them

24
00:00:46,480 --> 00:00:48,000
and we'll go through those together

25
00:00:48,000 --> 00:00:49,440
we're going to talk about structures and

26
00:00:49,440 --> 00:00:49,760
how

27
00:00:49,760 --> 00:00:52,160
those look in compiled c programs we'll

28
00:00:52,160 --> 00:00:53,520
talk about enums

29
00:00:53,520 --> 00:00:56,239
pointers file operations patching

30
00:00:56,239 --> 00:00:57,199
binaries

31
00:00:57,199 --> 00:00:58,960
and then some other additional dedra

32
00:00:58,960 --> 00:01:00,640
features that are going to aid you

33
00:01:00,640 --> 00:01:04,559
with this week's challenges

34
00:01:04,559 --> 00:01:06,320
so real quick for those that may have

35
00:01:06,320 --> 00:01:08,320
just jumped in office hours are

36
00:01:08,320 --> 00:01:10,960
thursday at 6 eastern the questions for

37
00:01:10,960 --> 00:01:12,640
that can be submitted either via

38
00:01:12,640 --> 00:01:15,200
zoom in the chat that you're now in the

39
00:01:15,200 --> 00:01:16,000
q a

40
00:01:16,000 --> 00:01:18,560
or on the hackaday io chat room or you

41
00:01:18,560 --> 00:01:19,040
can

42
00:01:19,040 --> 00:01:21,759
message me on twitter if that's your

43
00:01:21,759 --> 00:01:23,280
preferred

44
00:01:23,280 --> 00:01:25,200
way to get the questions across any of

45
00:01:25,200 --> 00:01:26,799
those are fine with me

46
00:01:26,799 --> 00:01:29,040
we go over the questions during the

47
00:01:29,040 --> 00:01:30,400
office hour and then

48
00:01:30,400 --> 00:01:32,640
for whatever time is left last time we

49
00:01:32,640 --> 00:01:34,400
just reverse engineered a firmware image

50
00:01:34,400 --> 00:01:35,759
and people seem to enjoy

51
00:01:35,759 --> 00:01:37,759
kind of walking through that so we'll

52
00:01:37,759 --> 00:01:39,280
probably do something similar to that

53
00:01:39,280 --> 00:01:40,960
again depending on

54
00:01:40,960 --> 00:01:43,040
what people are interested in so let us

55
00:01:43,040 --> 00:01:44,240
know what you're interested in let us

56
00:01:44,240 --> 00:01:45,520
know any questions that you might have

57
00:01:45,520 --> 00:01:47,759
for the office hours and we'll do

58
00:01:47,759 --> 00:01:48,880
do what we can to make that as

59
00:01:48,880 --> 00:01:51,839
productive as possible

60
00:01:52,000 --> 00:01:54,479
so today we're going to talk about the

61
00:01:54,479 --> 00:01:56,159
kind of the landscape of different

62
00:01:56,159 --> 00:01:57,759
software reverse engineering tools we've

63
00:01:57,759 --> 00:01:59,040
gotten a couple of questions about this

64
00:01:59,040 --> 00:02:00,079
and it's important to

65
00:02:00,079 --> 00:02:01,360
understand that there's there are more

66
00:02:01,360 --> 00:02:03,040
tools to do this with than than just

67
00:02:03,040 --> 00:02:04,000
ghidra right

68
00:02:04,000 --> 00:02:04,960
so we're going to talk about a couple

69
00:02:04,960 --> 00:02:06,799
popular tools kind of the pros and cons

70
00:02:06,799 --> 00:02:08,080
for all of them

71
00:02:08,080 --> 00:02:09,679
and then as i mentioned before we're

72
00:02:09,679 --> 00:02:11,120
going to go into some additional kind of

73
00:02:11,120 --> 00:02:11,360
c

74
00:02:11,360 --> 00:02:14,000
structures and then some os concepts to

75
00:02:14,000 --> 00:02:14,480
help

76
00:02:14,480 --> 00:02:15,760
illustrate what you might see when you

77
00:02:15,760 --> 00:02:17,120
start looking at more complicated

78
00:02:17,120 --> 00:02:17,920
programs

79
00:02:17,920 --> 00:02:20,319
we're going to talk about all the c

80
00:02:20,319 --> 00:02:21,920
types that i just mentioned earlier plus

81
00:02:21,920 --> 00:02:24,080
we're going to go over system calls

82
00:02:24,080 --> 00:02:26,319
and then we're going to kind of close

83
00:02:26,319 --> 00:02:27,440
out today

84
00:02:27,440 --> 00:02:29,680
with a bunch of features in dedra that

85
00:02:29,680 --> 00:02:31,280
we haven't really gotten to yet

86
00:02:31,280 --> 00:02:32,800
and they're going to become useful when

87
00:02:32,800 --> 00:02:34,400
you start looking at these new

88
00:02:34,400 --> 00:02:37,599
exercises that we released today

89
00:02:37,599 --> 00:02:40,640
so real quick though uh software re tool

90
00:02:40,640 --> 00:02:41,680
landscape

91
00:02:41,680 --> 00:02:43,120
there are lots of different tools you

92
00:02:43,120 --> 00:02:45,120
can use to reverse engineer software and

93
00:02:45,120 --> 00:02:46,480
i've just listed a few

94
00:02:46,480 --> 00:02:48,080
you know down below you've got you know

95
00:02:48,080 --> 00:02:50,080
redair radar r2

96
00:02:50,080 --> 00:02:51,519
ida pro some of you are familiar with

97
00:02:51,519 --> 00:02:53,200
guidro we're using that now and of

98
00:02:53,200 --> 00:02:54,080
course you've got

99
00:02:54,080 --> 00:02:55,760
you know classic object if you want to

100
00:02:55,760 --> 00:02:57,440
use something like that

101
00:02:57,440 --> 00:03:00,720
the these tools all kind of have their

102
00:03:00,720 --> 00:03:02,800
strengths and weaknesses pros and cons

103
00:03:02,800 --> 00:03:04,400
and a lot of it too can boil down to

104
00:03:04,400 --> 00:03:05,840
personal preference

105
00:03:05,840 --> 00:03:09,200
but most of the time when you're working

106
00:03:09,200 --> 00:03:10,560
on you know some target

107
00:03:10,560 --> 00:03:12,800
software system you will pick whatever

108
00:03:12,800 --> 00:03:14,480
tool you think

109
00:03:14,480 --> 00:03:17,760
is best fit for the job so i use gidger

110
00:03:17,760 --> 00:03:20,159
a fair amount i use ida fair amount i

111
00:03:20,159 --> 00:03:21,680
don't have a lot of experience with r2

112
00:03:21,680 --> 00:03:23,120
so it's not a go-to for me but i've

113
00:03:23,120 --> 00:03:24,480
worked alongside of people

114
00:03:24,480 --> 00:03:27,519
that use r2 really really well and are

115
00:03:27,519 --> 00:03:29,440
able to get the job done really well so

116
00:03:29,440 --> 00:03:30,799
you know at the end of the day it does

117
00:03:30,799 --> 00:03:32,319
kind of boil down to what you're most

118
00:03:32,319 --> 00:03:33,360
comfortable with and what

119
00:03:33,360 --> 00:03:36,799
suits your goals with re

120
00:03:36,799 --> 00:03:38,879
so real quick you know for those of you

121
00:03:38,879 --> 00:03:40,720
that aren't familiar with ida pro

122
00:03:40,720 --> 00:03:42,959
it's one of the most popular reverse

123
00:03:42,959 --> 00:03:44,000
engineering tools

124
00:03:44,000 --> 00:03:45,440
out there most of you have probably seen

125
00:03:45,440 --> 00:03:47,280
it before and

126
00:03:47,280 --> 00:03:50,159
it's got a lot of existing plugins and

127
00:03:50,159 --> 00:03:51,519
community tools because it's been around

128
00:03:51,519 --> 00:03:52,879
for such a long time

129
00:03:52,879 --> 00:03:54,959
it handles you know c plus plus binaries

130
00:03:54,959 --> 00:03:56,560
fairly well it can handle things like

131
00:03:56,560 --> 00:03:58,879
pdb parsing fairly well and again

132
00:03:58,879 --> 00:04:01,040
it's kind of been sort of the industry

133
00:04:01,040 --> 00:04:02,080
standard for

134
00:04:02,080 --> 00:04:04,959
a really long time so lots of people

135
00:04:04,959 --> 00:04:07,040
familiar with that lots of places use it

136
00:04:07,040 --> 00:04:10,000
the the cons with ida pro are that it's

137
00:04:10,000 --> 00:04:11,360
fairly expensive

138
00:04:11,360 --> 00:04:14,159
so it's they've recently tried to

139
00:04:14,159 --> 00:04:14,879
release

140
00:04:14,879 --> 00:04:16,720
the ida pro community edition which

141
00:04:16,720 --> 00:04:18,238
drops the price a little bit

142
00:04:18,238 --> 00:04:20,560
but it's still fairly costly for you

143
00:04:20,560 --> 00:04:22,479
know a hobbyist or someone who's doing

144
00:04:22,479 --> 00:04:22,960
this

145
00:04:22,960 --> 00:04:25,440
you know on the side or just for fun the

146
00:04:25,440 --> 00:04:27,199
documentation can sometimes be a little

147
00:04:27,199 --> 00:04:28,479
lacking in my experience

148
00:04:28,479 --> 00:04:31,040
but that i think they are that is all

149
00:04:31,040 --> 00:04:32,400
improving they're working really hard to

150
00:04:32,400 --> 00:04:33,680
improve that and

151
00:04:33,680 --> 00:04:35,680
it can sometimes be difficult to sort of

152
00:04:35,680 --> 00:04:37,600
modify the core

153
00:04:37,600 --> 00:04:40,000
analysis pieces and and with all these

154
00:04:40,000 --> 00:04:42,000
cons right ida pro is a great program

155
00:04:42,000 --> 00:04:45,360
we all you know everybody uses it and

156
00:04:45,360 --> 00:04:47,040
it's it's really great these cons are

157
00:04:47,040 --> 00:04:48,400
just some of the things that i've had

158
00:04:48,400 --> 00:04:49,520
issues with

159
00:04:49,520 --> 00:04:51,280
in the past and i've heard other people

160
00:04:51,280 --> 00:04:53,680
discuss as well

161
00:04:53,680 --> 00:04:56,000
and so people talk about r2 quite a bit

162
00:04:56,000 --> 00:04:56,880
as well and

163
00:04:56,880 --> 00:04:59,360
and r2 is great it's open source the

164
00:04:59,360 --> 00:05:00,720
community's super active

165
00:05:00,720 --> 00:05:03,199
very enthusiastic it has you know lots

166
00:05:03,199 --> 00:05:04,720
of architecture support

167
00:05:04,720 --> 00:05:06,880
support for various file formats

168
00:05:06,880 --> 00:05:08,400
operating systems

169
00:05:08,400 --> 00:05:11,520
and r2 because it's

170
00:05:11,520 --> 00:05:13,280
you know bare bones probably isn't the

171
00:05:13,280 --> 00:05:15,120
right word but because it's such

172
00:05:15,120 --> 00:05:18,080
a low-level tool it's easy to kind of

173
00:05:18,080 --> 00:05:19,759
extend and script upon any of the

174
00:05:19,759 --> 00:05:21,600
features that we kind of listed above so

175
00:05:21,600 --> 00:05:22,080
it's got

176
00:05:22,080 --> 00:05:23,520
you know forensic features and things

177
00:05:23,520 --> 00:05:25,199
like that if you want to feed it like

178
00:05:25,199 --> 00:05:27,840
you know file system images and stuff

179
00:05:27,840 --> 00:05:29,520
but the the thing with r2

180
00:05:29,520 --> 00:05:30,880
that i think turns a lot of people off

181
00:05:30,880 --> 00:05:32,800
initially is that the learning curve

182
00:05:32,800 --> 00:05:35,919
is fairly steep now there are lots of

183
00:05:35,919 --> 00:05:37,600
blog posts and things that are out right

184
00:05:37,600 --> 00:05:39,600
now there's a guy arctic blue on twitter

185
00:05:39,600 --> 00:05:40,880
that has a great

186
00:05:40,880 --> 00:05:44,000
series of r2 posts on how to get started

187
00:05:44,000 --> 00:05:44,800
with it

188
00:05:44,800 --> 00:05:47,520
and there's this could be a pro or a con

189
00:05:47,520 --> 00:05:48,560
depending on how you look at it there's

190
00:05:48,560 --> 00:05:50,320
not really a maintained gui

191
00:05:50,320 --> 00:05:52,080
it's not part of their you know core

192
00:05:52,080 --> 00:05:53,520
project but there is a program called

193
00:05:53,520 --> 00:05:54,080
cutter

194
00:05:54,080 --> 00:05:56,080
that uses r2 on the back end that's

195
00:05:56,080 --> 00:05:57,199
fairly decent and

196
00:05:57,199 --> 00:05:59,440
and of course there's no decompiler um

197
00:05:59,440 --> 00:06:00,800
that that i'm aware of

198
00:06:00,800 --> 00:06:03,600
but again i'm not really an r2 expert

199
00:06:03,600 --> 00:06:05,199
but

200
00:06:05,199 --> 00:06:09,440
they okay so yeah r2 looks like

201
00:06:09,440 --> 00:06:13,039
can incorporate the guidry compiler

202
00:06:13,039 --> 00:06:15,680
according to the fellow in chat there

203
00:06:15,680 --> 00:06:16,400
which is

204
00:06:16,400 --> 00:06:18,319
which is great but again i'm not really

205
00:06:18,319 --> 00:06:19,759
an r2 expert but i know a lot of people

206
00:06:19,759 --> 00:06:22,960
that use it and use it very well

207
00:06:22,960 --> 00:06:25,120
and so really kind of just to wrap that

208
00:06:25,120 --> 00:06:27,039
up quickly

209
00:06:27,039 --> 00:06:30,080
the the thing when you're doing software

210
00:06:30,080 --> 00:06:31,280
re is you just kind of

211
00:06:31,280 --> 00:06:32,560
you want to experiment with different

212
00:06:32,560 --> 00:06:34,720
tools to see which tool suits

213
00:06:34,720 --> 00:06:38,240
your workflow the best there's really no

214
00:06:38,240 --> 00:06:40,080
tool you can point to and say oh this is

215
00:06:40,080 --> 00:06:41,360
the best out of all of them

216
00:06:41,360 --> 00:06:43,440
and so you know everybody has all these

217
00:06:43,440 --> 00:06:44,720
different tools in their tool belt that

218
00:06:44,720 --> 00:06:45,440
they'll use

219
00:06:45,440 --> 00:06:48,000
you know based on whatever software

220
00:06:48,000 --> 00:06:49,520
target they're looking at so

221
00:06:49,520 --> 00:06:51,840
i know a lot of people prefer gidra for

222
00:06:51,840 --> 00:06:52,720
lower level

223
00:06:52,720 --> 00:06:54,639
firmware images and you know they might

224
00:06:54,639 --> 00:06:56,880
prefer ida for windows binaries

225
00:06:56,880 --> 00:06:59,599
and ida for you know l files i

226
00:06:59,599 --> 00:07:02,240
personally like ghidra for

227
00:07:02,240 --> 00:07:04,560
firmware images and l files and then for

228
00:07:04,560 --> 00:07:05,599
windows and c

229
00:07:05,599 --> 00:07:07,280
plus i do tend to lean on ida a little

230
00:07:07,280 --> 00:07:09,520
heavier but that's just me everybody's

231
00:07:09,520 --> 00:07:11,360
preferences are different here

232
00:07:11,360 --> 00:07:17,840
so i'm just gonna

233
00:07:19,680 --> 00:07:22,160
all right

234
00:07:23,919 --> 00:07:26,479
so a good example of what ida is good at

235
00:07:26,479 --> 00:07:28,160
that nobody else has so

236
00:07:28,160 --> 00:07:30,240
i mean ida what ida has that nobody else

237
00:07:30,240 --> 00:07:32,240
has is a fair amount of you know

238
00:07:32,240 --> 00:07:34,479
existing plug-ins a lot of community

239
00:07:34,479 --> 00:07:35,280
support

240
00:07:35,280 --> 00:07:37,039
the decompile is really good the c-plus

241
00:07:37,039 --> 00:07:39,840
plus d-mangling is fairly decent as well

242
00:07:39,840 --> 00:07:44,080
um and so guidry and r2 i mean gidra you

243
00:07:44,080 --> 00:07:45,759
know has a built-in decompiler which you

244
00:07:45,759 --> 00:07:47,919
know r2 does have plug-ins to lean on

245
00:07:47,919 --> 00:07:50,000
but you know giger's decompiler and its

246
00:07:50,000 --> 00:07:51,440
intermediate representation are kind of

247
00:07:51,440 --> 00:07:52,560
what set it apart from

248
00:07:52,560 --> 00:07:55,520
from r2 in that way

249
00:07:55,599 --> 00:07:57,360
so now that we've kind of gone over the

250
00:07:57,360 --> 00:08:00,000
various tools uh you know that's a very

251
00:08:00,000 --> 00:08:01,039
high level overview

252
00:08:01,039 --> 00:08:02,800
we're going to jump back into where what

253
00:08:02,800 --> 00:08:05,039
we were looking at last week and that's

254
00:08:05,039 --> 00:08:06,720
talking about how you can identify some

255
00:08:06,720 --> 00:08:08,160
of these c

256
00:08:08,160 --> 00:08:10,800
structures and see concepts that you

257
00:08:10,800 --> 00:08:11,759
might see when you're reverse

258
00:08:11,759 --> 00:08:12,879
engineering something

259
00:08:12,879 --> 00:08:15,919
and we're going to start with structures

260
00:08:15,919 --> 00:08:18,000
so those of you that have written c

261
00:08:18,000 --> 00:08:19,599
before probably familiar with structures

262
00:08:19,599 --> 00:08:21,919
structures are a user-defined data type

263
00:08:21,919 --> 00:08:24,080
that allow you to sort of combine

264
00:08:24,080 --> 00:08:25,520
various data types and what they

265
00:08:25,520 --> 00:08:26,000
eventually

266
00:08:26,000 --> 00:08:29,120
represent once they get compiled is a

267
00:08:29,120 --> 00:08:31,199
composite data type with multiple

268
00:08:31,199 --> 00:08:33,679
variables contained within it under one

269
00:08:33,679 --> 00:08:36,080
like contiguous block of memory

270
00:08:36,080 --> 00:08:37,919
so you can think of it as like a group

271
00:08:37,919 --> 00:08:39,120
of variables

272
00:08:39,120 --> 00:08:41,919
that eventually will get you know padded

273
00:08:41,919 --> 00:08:44,399
for alignment purposes for the

274
00:08:44,399 --> 00:08:47,600
for the processor and what that means

275
00:08:47,600 --> 00:08:49,200
is if you have a structure with two

276
00:08:49,200 --> 00:08:51,120
integers and one byte field

277
00:08:51,120 --> 00:08:53,040
that bite field's going to get padded

278
00:08:53,040 --> 00:08:54,160
probably to

279
00:08:54,160 --> 00:08:57,519
a four byte field so that it can be in

280
00:08:57,519 --> 00:08:59,360
proper alignment with the rest of the

281
00:08:59,360 --> 00:09:00,640
processor and

282
00:09:00,640 --> 00:09:01,920
typically you know as a developer this

283
00:09:01,920 --> 00:09:03,200
might not be something you care about a

284
00:09:03,200 --> 00:09:04,399
whole lot if you're an embedded

285
00:09:04,399 --> 00:09:05,920
developer you'll probably run into this

286
00:09:05,920 --> 00:09:09,120
and you know sometimes it might use up

287
00:09:09,120 --> 00:09:10,959
additional space you weren't aware of

288
00:09:10,959 --> 00:09:12,640
but we really care about this when we're

289
00:09:12,640 --> 00:09:13,519
doing re

290
00:09:13,519 --> 00:09:16,480
because we need to sometimes reconstruct

291
00:09:16,480 --> 00:09:18,000
these structures from the assembly

292
00:09:18,000 --> 00:09:18,880
language

293
00:09:18,880 --> 00:09:22,080
and so what that ends up looking

294
00:09:22,080 --> 00:09:24,640
like in assembly so we'll take a look

295
00:09:24,640 --> 00:09:26,800
here

296
00:09:30,880 --> 00:09:34,480
so we have a simple structure here

297
00:09:34,480 --> 00:09:36,320
with two integer fields and a character

298
00:09:36,320 --> 00:09:37,920
field and

299
00:09:37,920 --> 00:09:39,200
for the sake of argument let's just

300
00:09:39,200 --> 00:09:41,440
assume this is 30 a 32-bit system

301
00:09:41,440 --> 00:09:43,440
and so all we're doing here in main is

302
00:09:43,440 --> 00:09:45,839
we're instantiating the structure

303
00:09:45,839 --> 00:09:47,680
and we are setting the fields to their

304
00:09:47,680 --> 00:09:49,200
various values so

305
00:09:49,200 --> 00:09:51,360
let's take a look on the right at the

306
00:09:51,360 --> 00:09:52,480
assembly code

307
00:09:52,480 --> 00:09:54,560
that represents this and we're also

308
00:09:54,560 --> 00:09:55,839
going to show you

309
00:09:55,839 --> 00:09:58,480
what the stack is going to look like and

310
00:09:58,480 --> 00:10:00,720
where these variables are going to be

311
00:10:00,720 --> 00:10:02,399
presented or how they're going to be

312
00:10:02,399 --> 00:10:04,000
presented on the stack

313
00:10:04,000 --> 00:10:07,200
so there you go

314
00:10:07,200 --> 00:10:08,640
all right so first we have you know our

315
00:10:08,640 --> 00:10:10,560
function pro we're setting everything up

316
00:10:10,560 --> 00:10:13,600
our stack is set up so

317
00:10:13,600 --> 00:10:15,519
we have our two our two arguments here

318
00:10:15,519 --> 00:10:17,040
we went over what those are during

319
00:10:17,040 --> 00:10:18,160
office hours

320
00:10:18,160 --> 00:10:20,959
last week and so the first instruction

321
00:10:20,959 --> 00:10:21,519
we have

322
00:10:21,519 --> 00:10:24,720
is setting the x field of this structure

323
00:10:24,720 --> 00:10:26,959
to hex 100 and you'll notice that that

324
00:10:26,959 --> 00:10:28,800
field is located on the stack

325
00:10:28,800 --> 00:10:32,079
at rbp minus hex 10.

326
00:10:32,079 --> 00:10:35,200
and so the next field the byte field

327
00:10:35,200 --> 00:10:37,360
you might immediately assume that it's

328
00:10:37,360 --> 00:10:39,360
just going to be one byte

329
00:10:39,360 --> 00:10:42,320
above you know hex 10 or under hex 10

330
00:10:42,320 --> 00:10:43,680
right since we're on the stack

331
00:10:43,680 --> 00:10:44,880
you would assume that it might be plus

332
00:10:44,880 --> 00:10:46,800
or minus one well that's not the case

333
00:10:46,800 --> 00:10:48,320
right it's a plus or minus

334
00:10:48,320 --> 00:10:51,600
four because it needs to be aligned

335
00:10:51,600 --> 00:10:53,360
with the processor architecture right

336
00:10:53,360 --> 00:10:54,640
because if you try to

337
00:10:54,640 --> 00:10:56,079
you know if this were armed for example

338
00:10:56,079 --> 00:10:58,839
when you try to address

339
00:10:58,839 --> 00:11:01,600
and an instruction that wasn't properly

340
00:11:01,600 --> 00:11:02,800
aligned you would get an alignment

341
00:11:02,800 --> 00:11:03,600
exception

342
00:11:03,600 --> 00:11:05,839
so you'll see that even though the point

343
00:11:05,839 --> 00:11:07,920
we're trying to make here is even though

344
00:11:07,920 --> 00:11:10,880
the member of the struct is just one

345
00:11:10,880 --> 00:11:12,399
character it's just one byte it's going

346
00:11:12,399 --> 00:11:13,680
to take up

347
00:11:13,680 --> 00:11:16,880
four bytes here on the stack

348
00:11:16,880 --> 00:11:18,320
and of course that will change you know

349
00:11:18,320 --> 00:11:19,519
if this were a pointer to a struct it

350
00:11:19,519 --> 00:11:21,440
would obviously be four bytes etc but

351
00:11:21,440 --> 00:11:23,519
since this is it's just one byte and it

352
00:11:23,519 --> 00:11:25,040
takes up four bytes on the stack because

353
00:11:25,040 --> 00:11:26,160
it needs to be properly

354
00:11:26,160 --> 00:11:28,000
aligned and sometimes this is done for

355
00:11:28,000 --> 00:11:30,079
optimization purposes as well

356
00:11:30,079 --> 00:11:32,480
so the last portion of this here we see

357
00:11:32,480 --> 00:11:33,440
it set

358
00:11:33,440 --> 00:11:36,560
the final member of the struct to 300

359
00:11:36,560 --> 00:11:38,959
and then we just exit and so you know

360
00:11:38,959 --> 00:11:39,839
this isn't

361
00:11:39,839 --> 00:11:41,920
super complicated assembly it's not

362
00:11:41,920 --> 00:11:43,440
super complicated c code

363
00:11:43,440 --> 00:11:46,399
the point in showing you guys this was

364
00:11:46,399 --> 00:11:47,680
to show you that

365
00:11:47,680 --> 00:11:50,720
these structs when they are you know

366
00:11:50,720 --> 00:11:52,240
created on the stack or when they're you

367
00:11:52,240 --> 00:11:53,600
know converted and created in this

368
00:11:53,600 --> 00:11:55,200
assembly language is that they're gonna

369
00:11:55,200 --> 00:11:56,000
be

370
00:11:56,000 --> 00:11:59,040
you know bite aligned and then lastly we

371
00:11:59,040 --> 00:11:59,920
have

372
00:11:59,920 --> 00:12:01,839
you know the cleanup here for the

373
00:12:01,839 --> 00:12:04,000
function

374
00:12:04,000 --> 00:12:07,600
and so when you're using ghidra

375
00:12:07,600 --> 00:12:10,000
and you're trying to create a structure

376
00:12:10,000 --> 00:12:11,680
there's a couple different ways

377
00:12:11,680 --> 00:12:13,360
you can do this so let's say you're

378
00:12:13,360 --> 00:12:14,800
looking at some c code and you've

379
00:12:14,800 --> 00:12:16,240
identified what you think might be a

380
00:12:16,240 --> 00:12:16,959
structure

381
00:12:16,959 --> 00:12:18,240
you've identified some assembly

382
00:12:18,240 --> 00:12:20,000
structures that you think might be

383
00:12:20,000 --> 00:12:22,320
related to filling out fields of the

384
00:12:22,320 --> 00:12:23,279
structure there's

385
00:12:23,279 --> 00:12:25,360
a couple of ways you can import this

386
00:12:25,360 --> 00:12:26,480
into ghidra

387
00:12:26,480 --> 00:12:30,000
you can manually create it in the struct

388
00:12:30,000 --> 00:12:31,519
creator which we'll show an example of

389
00:12:31,519 --> 00:12:33,279
how to do where you go in and manually

390
00:12:33,279 --> 00:12:34,560
define the fields

391
00:12:34,560 --> 00:12:36,720
and things like that or you can actually

392
00:12:36,720 --> 00:12:38,160
import a header file

393
00:12:38,160 --> 00:12:40,320
which we did in an example in the last

394
00:12:40,320 --> 00:12:41,519
office hour of

395
00:12:41,519 --> 00:12:44,560
you can define a header file of the

396
00:12:44,560 --> 00:12:46,320
struct that you're looking at

397
00:12:46,320 --> 00:12:48,560
import that into gidra and then apply it

398
00:12:48,560 --> 00:12:49,920
to a data type

399
00:12:49,920 --> 00:12:51,440
in order to do that you click file and

400
00:12:51,440 --> 00:12:53,360
then import c source

401
00:12:53,360 --> 00:12:55,760
navigate to the header file parse it to

402
00:12:55,760 --> 00:12:56,399
the program

403
00:12:56,399 --> 00:12:59,200
and then apply it to the data type and

404
00:12:59,200 --> 00:13:00,240
so

405
00:13:00,240 --> 00:13:02,880
what we're going to start with is manual

406
00:13:02,880 --> 00:13:04,880
struct creation so not importing it from

407
00:13:04,880 --> 00:13:06,959
a c header file and that can be done

408
00:13:06,959 --> 00:13:10,479
from the data types manager

409
00:13:10,959 --> 00:13:13,040
so this is the data type manager uh if

410
00:13:13,040 --> 00:13:14,560
you've not modified

411
00:13:14,560 --> 00:13:16,560
the core guide layout this is the bottom

412
00:13:16,560 --> 00:13:18,079
left-hand corner

413
00:13:18,079 --> 00:13:20,560
and so here what you want to do is right

414
00:13:20,560 --> 00:13:21,200
click

415
00:13:21,200 --> 00:13:23,519
this see we have struct ex2 which is the

416
00:13:23,519 --> 00:13:24,720
name of the program

417
00:13:24,720 --> 00:13:26,639
you want to right click this you click

418
00:13:26,639 --> 00:13:28,880
new and then structure

419
00:13:28,880 --> 00:13:31,040
and then when you click that this window

420
00:13:31,040 --> 00:13:33,120
will appear

421
00:13:33,120 --> 00:13:35,120
and so this is the structure editor this

422
00:13:35,120 --> 00:13:36,800
is where you can generate a structure

423
00:13:36,800 --> 00:13:38,560
you can add fields you can make sure the

424
00:13:38,560 --> 00:13:39,920
fields are aligned

425
00:13:39,920 --> 00:13:41,920
and you can't even you know you can see

426
00:13:41,920 --> 00:13:43,519
what bits are set for the certain fields

427
00:13:43,519 --> 00:13:45,360
if you want to create bit fields etc we

428
00:13:45,360 --> 00:13:46,160
talked about that

429
00:13:46,160 --> 00:13:48,320
someone had asked that question uh last

430
00:13:48,320 --> 00:13:49,680
week as well we'll go over that

431
00:13:49,680 --> 00:13:51,199
this week during the office hour whether

432
00:13:51,199 --> 00:13:53,040
or not you can have or how to do you

433
00:13:53,040 --> 00:13:55,279
know bitfields with instructs

434
00:13:55,279 --> 00:13:57,279
so if we want to add a member to this

435
00:13:57,279 --> 00:13:59,040
struct

436
00:13:59,040 --> 00:14:01,680
you click on data type and then edit

437
00:14:01,680 --> 00:14:04,560
component field

438
00:14:05,360 --> 00:14:07,279
and so this is where you're going to

439
00:14:07,279 --> 00:14:09,279
fill out the actual data type

440
00:14:09,279 --> 00:14:11,519
that resides within the struct right so

441
00:14:11,519 --> 00:14:12,880
if it's an integer you're going to type

442
00:14:12,880 --> 00:14:13,279
in

443
00:14:13,279 --> 00:14:14,560
if it's a character you're just going to

444
00:14:14,560 --> 00:14:16,800
use jar if it's a pointer you know you

445
00:14:16,800 --> 00:14:17,600
do instar

446
00:14:17,600 --> 00:14:20,880
charstar etc whatever the pointer is too

447
00:14:20,880 --> 00:14:24,160
and so let's next

448
00:14:24,160 --> 00:14:26,320
you'll see that we've added one integer

449
00:14:26,320 --> 00:14:28,560
and you've got the byte offsets here

450
00:14:28,560 --> 00:14:30,240
at the bottom of the struct and then you

451
00:14:30,240 --> 00:14:32,639
can also if you want to you can name

452
00:14:32,639 --> 00:14:34,639
that field as well

453
00:14:34,639 --> 00:14:38,320
so next we'll go through and fill out

454
00:14:38,320 --> 00:14:40,480
the struct for the rest of the elements

455
00:14:40,480 --> 00:14:41,839
that we saw in the previous example

456
00:14:41,839 --> 00:14:42,880
remember that it was

457
00:14:42,880 --> 00:14:46,800
int character int so we do that

458
00:14:46,800 --> 00:14:49,920
right now notice here that the length is

459
00:14:49,920 --> 00:14:50,720
only one

460
00:14:50,720 --> 00:14:52,639
and this is why we have to pay attention

461
00:14:52,639 --> 00:14:54,800
to how these things are actually

462
00:14:54,800 --> 00:14:56,160
created and managed right and how

463
00:14:56,160 --> 00:14:58,160
they're padded so this is actually

464
00:14:58,160 --> 00:15:00,480
nine bytes total and in reality we want

465
00:15:00,480 --> 00:15:01,279
it to be 12

466
00:15:01,279 --> 00:15:02,959
because remember it was three four byte

467
00:15:02,959 --> 00:15:04,639
fields even though technically

468
00:15:04,639 --> 00:15:07,360
there's only nine bytes of data that we

469
00:15:07,360 --> 00:15:08,000
really

470
00:15:08,000 --> 00:15:11,279
you know quote unquote use or care about

471
00:15:11,279 --> 00:15:14,720
so in order to fix this

472
00:15:14,720 --> 00:15:18,000
you can click the align button so you

473
00:15:18,000 --> 00:15:19,920
can select a member of the struct

474
00:15:19,920 --> 00:15:23,120
and click the align button

475
00:15:23,360 --> 00:15:25,920
so we've selected our y member here

476
00:15:25,920 --> 00:15:27,279
because again remember what we're trying

477
00:15:27,279 --> 00:15:29,040
to do here is we want this to be a four

478
00:15:29,040 --> 00:15:29,920
byte field

479
00:15:29,920 --> 00:15:31,600
but we also want to make sure that the

480
00:15:31,600 --> 00:15:33,519
data type is

481
00:15:33,519 --> 00:15:36,160
properly labeled so you could make a 12

482
00:15:36,160 --> 00:15:37,680
byte struct by just having three

483
00:15:37,680 --> 00:15:38,480
integers

484
00:15:38,480 --> 00:15:41,279
right but when gidra tries to do

485
00:15:41,279 --> 00:15:42,720
analysis on the structure you created

486
00:15:42,720 --> 00:15:44,320
it's going to assume that middle type is

487
00:15:44,320 --> 00:15:46,240
an integer when we know it's actually a

488
00:15:46,240 --> 00:15:47,759
byte right

489
00:15:47,759 --> 00:15:51,440
so when you click a line here

490
00:15:51,440 --> 00:15:54,320
you'll see that now this is four bytes

491
00:15:54,320 --> 00:15:55,519
in length and it's still only

492
00:15:55,519 --> 00:15:56,880
highlighting the field that we care

493
00:15:56,880 --> 00:15:57,839
about

494
00:15:57,839 --> 00:16:02,160
and so that's how you

495
00:16:03,680 --> 00:16:08,240
you are aligning it with the um

496
00:16:08,240 --> 00:16:10,399
so tony's asking what what are you

497
00:16:10,399 --> 00:16:12,160
aligning it with that causes it to need

498
00:16:12,160 --> 00:16:13,199
a pad so

499
00:16:13,199 --> 00:16:14,959
for a lot of times it's just for

500
00:16:14,959 --> 00:16:16,800
optimization reasons right if these

501
00:16:16,800 --> 00:16:17,759
things are going to be stored on the

502
00:16:17,759 --> 00:16:19,279
stack they need to be on you know four

503
00:16:19,279 --> 00:16:21,839
byte boundaries

504
00:16:21,839 --> 00:16:23,680
the compiler does a lot of that in the

505
00:16:23,680 --> 00:16:24,959
background

506
00:16:24,959 --> 00:16:28,320
so what we've got here now

507
00:16:28,320 --> 00:16:30,399
is a properly aligned struct where each

508
00:16:30,399 --> 00:16:31,440
member takes up

509
00:16:31,440 --> 00:16:33,120
the appropriate four bytes just like we

510
00:16:33,120 --> 00:16:35,680
saw in the assembly code

511
00:16:35,680 --> 00:16:38,639
and so that's how you can do this

512
00:16:38,639 --> 00:16:39,600
manually

513
00:16:39,600 --> 00:16:42,399
in the struct creator and this is a

514
00:16:42,399 --> 00:16:43,680
super useful feature

515
00:16:43,680 --> 00:16:45,600
it's really it's nice to have to go

516
00:16:45,600 --> 00:16:46,959
through and kind of manually twiddle

517
00:16:46,959 --> 00:16:48,399
things and edit things if you don't want

518
00:16:48,399 --> 00:16:50,639
to constantly reimport csource

519
00:16:50,639 --> 00:16:51,759
but let's say you're looking at

520
00:16:51,759 --> 00:16:53,279
something that maybe you've been

521
00:16:53,279 --> 00:16:54,880
reversing for a while

522
00:16:54,880 --> 00:16:57,360
and you have a nice header file with all

523
00:16:57,360 --> 00:16:58,720
the structs that you think you've pulled

524
00:16:58,720 --> 00:17:00,000
out of it or you know

525
00:17:00,000 --> 00:17:02,839
perhaps that it imports an open source

526
00:17:02,839 --> 00:17:04,240
library and

527
00:17:04,240 --> 00:17:05,439
some of the structures that are being

528
00:17:05,439 --> 00:17:07,119
used are in header files for that open

529
00:17:07,119 --> 00:17:08,400
source library

530
00:17:08,400 --> 00:17:10,079
you can actually grab those header files

531
00:17:10,079 --> 00:17:11,919
and import them into your program to get

532
00:17:11,919 --> 00:17:13,280
the resulting data types

533
00:17:13,280 --> 00:17:16,240
and we'll show you how to do that next

534
00:17:16,240 --> 00:17:16,559
so

535
00:17:16,559 --> 00:17:19,599
within the guidry window

536
00:17:19,599 --> 00:17:24,000
you click file and then parse c source

537
00:17:24,000 --> 00:17:25,199
and so what that's going to do is it's

538
00:17:25,199 --> 00:17:27,520
going to bring you up bring this window

539
00:17:27,520 --> 00:17:29,200
and you can already see that guidra has

540
00:17:29,200 --> 00:17:30,640
a fair amount of you know

541
00:17:30,640 --> 00:17:32,559
predetermined header files that it grabs

542
00:17:32,559 --> 00:17:34,559
but we want to add you know a custom one

543
00:17:34,559 --> 00:17:37,600
so i have a header file with the struct

544
00:17:37,600 --> 00:17:40,480
that we've been working with to find and

545
00:17:40,480 --> 00:17:43,600
so you click this here

546
00:17:43,600 --> 00:17:45,280
and then this is going to bring up like

547
00:17:45,280 --> 00:17:48,400
a file selection window

548
00:17:48,400 --> 00:17:50,880
and so i have point.h which contains the

549
00:17:50,880 --> 00:17:51,760
struct

550
00:17:51,760 --> 00:17:53,919
that i've defined so we click on that

551
00:17:53,919 --> 00:17:55,760
and load it

552
00:17:55,760 --> 00:17:57,200
and then we'll see down here at the

553
00:17:57,200 --> 00:17:59,520
bottom this is now added to the selected

554
00:17:59,520 --> 00:18:01,840
files to parse

555
00:18:01,840 --> 00:18:07,760
so now we click parse to program

556
00:18:10,160 --> 00:18:11,440
it's going to ask you if you want to do

557
00:18:11,440 --> 00:18:13,520
it

558
00:18:13,679 --> 00:18:15,679
and then presumably if your struct was

559
00:18:15,679 --> 00:18:16,799
written properly

560
00:18:16,799 --> 00:18:19,120
and passes all the checks it'll get

561
00:18:19,120 --> 00:18:19,840
properly

562
00:18:19,840 --> 00:18:22,320
parsed and added to the data type

563
00:18:22,320 --> 00:18:23,679
manager

564
00:18:23,679 --> 00:18:25,360
so now we have it in here and you can

565
00:18:25,360 --> 00:18:26,880
see this is actually interesting right

566
00:18:26,880 --> 00:18:28,640
it'll tell us here that it was imported

567
00:18:28,640 --> 00:18:30,640
from point.h

568
00:18:30,640 --> 00:18:32,160
so if you're if you've got multiple

569
00:18:32,160 --> 00:18:34,160
definitions of a similar struct it will

570
00:18:34,160 --> 00:18:35,679
try to organize them for you here

571
00:18:35,679 --> 00:18:37,679
so that's kind of nice and so now we

572
00:18:37,679 --> 00:18:39,120
have point.h

573
00:18:39,120 --> 00:18:42,559
here in the program

574
00:18:42,559 --> 00:18:44,799
and so let's say we're looking at that

575
00:18:44,799 --> 00:18:46,640
previous example that we just had

576
00:18:46,640 --> 00:18:50,000
where we know the struct started at this

577
00:18:50,000 --> 00:18:53,120
variable on the stack so minus hex 18.

578
00:18:53,120 --> 00:18:56,480
if we want to apply this struct

579
00:18:56,480 --> 00:18:58,640
to these variables you can right click

580
00:18:58,640 --> 00:19:00,160
at where you think the struct begins

581
00:19:00,160 --> 00:19:02,320
which is at minus x 18 like we showed

582
00:19:02,320 --> 00:19:03,600
before

583
00:19:03,600 --> 00:19:06,720
and then click set data type choose data

584
00:19:06,720 --> 00:19:07,919
type because our struct isn't going to

585
00:19:07,919 --> 00:19:09,520
show up in the automatically

586
00:19:09,520 --> 00:19:12,160
selected ones and then you're going to

587
00:19:12,160 --> 00:19:14,000
get this type chooser dialog

588
00:19:14,000 --> 00:19:16,480
and so just start typing the struct that

589
00:19:16,480 --> 00:19:18,400
we imported which is called point

590
00:19:18,400 --> 00:19:20,960
and then it will auto fill down here so

591
00:19:20,960 --> 00:19:22,960
you can select that

592
00:19:22,960 --> 00:19:26,480
and then just like that instead of

593
00:19:26,480 --> 00:19:29,039
having assorted offsets right where we

594
00:19:29,039 --> 00:19:30,320
were having to kind of manually keep

595
00:19:30,320 --> 00:19:31,600
track of what was where

596
00:19:31,600 --> 00:19:33,440
now we can see that it's oh this is it's

597
00:19:33,440 --> 00:19:35,039
grabbing the x member here

598
00:19:35,039 --> 00:19:37,120
the y member here and the z member here

599
00:19:37,120 --> 00:19:38,640
and of course this all will also apply

600
00:19:38,640 --> 00:19:40,320
to the compiler and make it look a lot

601
00:19:40,320 --> 00:19:40,720
more

602
00:19:40,720 --> 00:19:44,400
readable as well and so with that

603
00:19:44,400 --> 00:19:47,600
we have an exercise for you

604
00:19:47,600 --> 00:19:50,960
so the structs exercise which has been

605
00:19:50,960 --> 00:19:51,760
uploaded

606
00:19:51,760 --> 00:19:53,840
they all got uploaded right before class

607
00:19:53,840 --> 00:19:55,840
see if you can reconstruct

608
00:19:55,840 --> 00:19:58,000
the struct that's being used how many

609
00:19:58,000 --> 00:19:59,520
members does it have how often are these

610
00:19:59,520 --> 00:20:00,880
members getting used what do those

611
00:20:00,880 --> 00:20:01,679
members

612
00:20:01,679 --> 00:20:05,280
represent and like the other

613
00:20:05,280 --> 00:20:08,640
like all of the other uh exercises this

614
00:20:08,640 --> 00:20:09,600
one's going to involve you know

615
00:20:09,600 --> 00:20:11,760
providing a username and a password

616
00:20:11,760 --> 00:20:13,360
so see if you can recreate this struct

617
00:20:13,360 --> 00:20:16,000
in gedra and then see if you can figure

618
00:20:16,000 --> 00:20:17,520
out how the struct is being used to

619
00:20:17,520 --> 00:20:18,240
calculate

620
00:20:18,240 --> 00:20:21,520
a passcode for you and one thing that i

621
00:20:21,520 --> 00:20:22,400
want to cover

622
00:20:22,400 --> 00:20:25,120
before everyone starts looking at the

623
00:20:25,120 --> 00:20:26,080
exercises

624
00:20:26,080 --> 00:20:30,000
from session three this session is

625
00:20:30,000 --> 00:20:32,880
providing non-ascii input to a c program

626
00:20:32,880 --> 00:20:34,080
from the command line

627
00:20:34,080 --> 00:20:35,600
so i think a lot of you might already

628
00:20:35,600 --> 00:20:37,360
know how to do this but i know

629
00:20:37,360 --> 00:20:38,559
everybody's kind of coming from

630
00:20:38,559 --> 00:20:39,919
different backgrounds and experience

631
00:20:39,919 --> 00:20:41,440
levels so i wanted to cover how to do

632
00:20:41,440 --> 00:20:43,360
this so most of the exercises you've

633
00:20:43,360 --> 00:20:45,120
been given so far

634
00:20:45,120 --> 00:20:47,120
all work on you know ascii inputs and

635
00:20:47,120 --> 00:20:48,240
outputs

636
00:20:48,240 --> 00:20:51,039
and from here on out they're no longer

637
00:20:51,039 --> 00:20:51,919
going to

638
00:20:51,919 --> 00:20:54,640
um excuse me they are no longer going to

639
00:20:54,640 --> 00:20:56,000
conform to that notion

640
00:20:56,000 --> 00:20:57,760
so the arguments now are going to be

641
00:20:57,760 --> 00:20:59,280
anything and they can be just

642
00:20:59,280 --> 00:21:00,400
hexadecimal

643
00:21:00,400 --> 00:21:02,640
strings you know just raw byte strings

644
00:21:02,640 --> 00:21:03,840
and so to

645
00:21:03,840 --> 00:21:06,159
feed that kind of data into a c program

646
00:21:06,159 --> 00:21:07,760
you can use

647
00:21:07,760 --> 00:21:10,960
uh python i've put an example down here

648
00:21:10,960 --> 00:21:12,640
of how you could feed

649
00:21:12,640 --> 00:21:15,600
python hex values into the program and

650
00:21:15,600 --> 00:21:16,240
there's a couple

651
00:21:16,240 --> 00:21:18,480
there's an example of this in the get

652
00:21:18,480 --> 00:21:20,240
repo as well in the readme

653
00:21:20,240 --> 00:21:21,919
and if you have any more questions about

654
00:21:21,919 --> 00:21:24,480
how to do this just reach out in the

655
00:21:24,480 --> 00:21:27,440
hackaday chat and folks in there can try

656
00:21:27,440 --> 00:21:31,840
to help as well

657
00:21:34,320 --> 00:21:37,760
so now that we've gone over structures

658
00:21:37,760 --> 00:21:39,520
the next logical thing for us to start

659
00:21:39,520 --> 00:21:41,120
taking a look at is going to be

660
00:21:41,120 --> 00:21:43,200
pointers and so again those of you that

661
00:21:43,200 --> 00:21:44,159
have done

662
00:21:44,159 --> 00:21:45,679
kind of embedded c or any kind of

663
00:21:45,679 --> 00:21:47,200
embedded development before

664
00:21:47,200 --> 00:21:48,640
are going to be familiar with this and

665
00:21:48,640 --> 00:21:51,120
the reason i keep going back to

666
00:21:51,120 --> 00:21:53,039
you know mentioning folks that do

667
00:21:53,039 --> 00:21:54,480
embedded development is that embedded

668
00:21:54,480 --> 00:21:55,679
development involves

669
00:21:55,679 --> 00:21:57,840
understanding of a lot of these sort of

670
00:21:57,840 --> 00:21:59,600
lower level concepts

671
00:21:59,600 --> 00:22:01,039
and i know that someone in the chat

672
00:22:01,039 --> 00:22:02,720
earlier today asked if it's you know

673
00:22:02,720 --> 00:22:04,720
okay to rely on the compiler

674
00:22:04,720 --> 00:22:06,320
as opposed to the assembly and yeah of

675
00:22:06,320 --> 00:22:08,320
course it's okay to use the decompiler

676
00:22:08,320 --> 00:22:11,679
it's just important to also have an

677
00:22:11,679 --> 00:22:13,120
understanding of these underlying

678
00:22:13,120 --> 00:22:14,559
principles because eventually the

679
00:22:14,559 --> 00:22:15,600
decompiler

680
00:22:15,600 --> 00:22:17,600
may not work or you may need to tweak it

681
00:22:17,600 --> 00:22:19,280
like in some of the examples we saw

682
00:22:19,280 --> 00:22:21,120
so everyone that remembers how much

683
00:22:21,120 --> 00:22:22,559
easier the exercises got

684
00:22:22,559 --> 00:22:25,760
once you've fixed up the prototype for

685
00:22:25,760 --> 00:22:26,400
the function

686
00:22:26,400 --> 00:22:29,200
you could see you know rgv and how it

687
00:22:29,200 --> 00:22:30,559
was indexed and things like that as

688
00:22:30,559 --> 00:22:31,919
opposed to looking at

689
00:22:31,919 --> 00:22:34,240
just the the offsets that were being

690
00:22:34,240 --> 00:22:35,200
calculated

691
00:22:35,200 --> 00:22:37,919
and so with an understanding of all the

692
00:22:37,919 --> 00:22:39,360
underlying

693
00:22:39,360 --> 00:22:40,960
things that are going on i.e you know

694
00:22:40,960 --> 00:22:42,960
assembly language and how these programs

695
00:22:42,960 --> 00:22:44,080
are constructed

696
00:22:44,080 --> 00:22:46,960
it makes this process a lot a lot easier

697
00:22:46,960 --> 00:22:49,360
and it kind of helps you

698
00:22:49,360 --> 00:22:50,559
figure out what you need to figure out

699
00:22:50,559 --> 00:22:52,080
in order to get the information that

700
00:22:52,080 --> 00:22:52,799
you're trying to

701
00:22:52,799 --> 00:22:55,520
extract from the program so we're going

702
00:22:55,520 --> 00:22:56,720
to talk about pointers

703
00:22:56,720 --> 00:22:58,400
and again those of you that have written

704
00:22:58,400 --> 00:23:00,080
any kind of c before with pointers and

705
00:23:00,080 --> 00:23:01,600
essentially what a pointer is

706
00:23:01,600 --> 00:23:04,159
for those of you that may not be

707
00:23:04,159 --> 00:23:05,280
familiar

708
00:23:05,280 --> 00:23:07,520
is a pointer is a variable whose value

709
00:23:07,520 --> 00:23:09,120
is the address of another variable

710
00:23:09,120 --> 00:23:09,840
essentially

711
00:23:09,840 --> 00:23:14,799
so it is an address of a memory location

712
00:23:14,799 --> 00:23:17,440
and pointers essentially provide you

713
00:23:17,440 --> 00:23:18,720
know an indirect method

714
00:23:18,720 --> 00:23:22,720
of accessing variables and this

715
00:23:22,720 --> 00:23:24,880
last bullet may be you know slightly

716
00:23:24,880 --> 00:23:26,720
debated again i'm not i'm not a compiler

717
00:23:26,720 --> 00:23:27,679
expert here but

718
00:23:27,679 --> 00:23:28,960
you know depending on the architecture

719
00:23:28,960 --> 00:23:30,960
depending on the compiler pointers are

720
00:23:30,960 --> 00:23:31,600
typically

721
00:23:31,600 --> 00:23:33,360
you know the same size because they

722
00:23:33,360 --> 00:23:35,200
represent an address in memory they

723
00:23:35,200 --> 00:23:37,760
point to something

724
00:23:37,760 --> 00:23:41,200
so this again it's going to be you know

725
00:23:41,200 --> 00:23:43,200
compiler architecture dependent

726
00:23:43,200 --> 00:23:45,919
and that's just something to be aware of

727
00:23:45,919 --> 00:23:46,880
right they're always going to have

728
00:23:46,880 --> 00:23:47,760
roughly the same

729
00:23:47,760 --> 00:23:50,159
they're always going to be the same size

730
00:23:50,159 --> 00:23:51,039
and so

731
00:23:51,039 --> 00:23:54,640
let's take a look at this chunk of code

732
00:23:54,640 --> 00:23:55,760
here

733
00:23:55,760 --> 00:23:57,600
talk about how it translates to assembly

734
00:23:57,600 --> 00:23:59,840
language

735
00:23:59,840 --> 00:24:02,559
so we have some c code on the left right

736
00:24:02,559 --> 00:24:04,559
and we have two integer values

737
00:24:04,559 --> 00:24:06,400
and what we're doing is with this

738
00:24:06,400 --> 00:24:08,480
ampersand here we are passing the

739
00:24:08,480 --> 00:24:09,360
address

740
00:24:09,360 --> 00:24:12,480
of these two integer values which let's

741
00:24:12,480 --> 00:24:13,760
take a look back here right

742
00:24:13,760 --> 00:24:15,520
these are local variables so they're

743
00:24:15,520 --> 00:24:16,880
going to be on the stack remember we

744
00:24:16,880 --> 00:24:18,320
covered that in session two

745
00:24:18,320 --> 00:24:20,400
we have these two local variables we are

746
00:24:20,400 --> 00:24:21,679
passing the address

747
00:24:21,679 --> 00:24:23,760
of these local variables to the swap

748
00:24:23,760 --> 00:24:24,880
function

749
00:24:24,880 --> 00:24:27,279
and so what the swap function is doing

750
00:24:27,279 --> 00:24:28,880
is changing

751
00:24:28,880 --> 00:24:31,360
the address of what each of these points

752
00:24:31,360 --> 00:24:33,200
to or it's changing the value that's

753
00:24:33,200 --> 00:24:34,240
pointed to

754
00:24:34,240 --> 00:24:37,279
at this address so after calling the

755
00:24:37,279 --> 00:24:38,480
swap function

756
00:24:38,480 --> 00:24:41,679
a is gonna point to three and b is going

757
00:24:41,679 --> 00:24:42,640
to point

758
00:24:42,640 --> 00:24:46,080
to two and so

759
00:24:46,080 --> 00:24:48,000
we're gonna take a look at how that

760
00:24:48,000 --> 00:24:49,279
translates

761
00:24:49,279 --> 00:24:52,720
into assembly language so here right we

762
00:24:52,720 --> 00:24:53,520
de-reference

763
00:24:53,520 --> 00:24:55,679
x which means we're gonna grab the value

764
00:24:55,679 --> 00:24:56,559
at x

765
00:24:56,559 --> 00:24:59,919
so temp is now gonna hold two so temp

766
00:24:59,919 --> 00:25:01,760
has the value two in it

767
00:25:01,760 --> 00:25:04,880
and then we de-reference x and we set

768
00:25:04,880 --> 00:25:06,320
that equal to

769
00:25:06,320 --> 00:25:09,200
the value that's dereferenced at y right

770
00:25:09,200 --> 00:25:10,640
and then we set

771
00:25:10,640 --> 00:25:13,679
the value df we change this to now point

772
00:25:13,679 --> 00:25:16,720
to two so this sets b

773
00:25:16,720 --> 00:25:20,880
equal to two right and a equal to three

774
00:25:21,520 --> 00:25:22,880
so let's go through and take a look at

775
00:25:22,880 --> 00:25:24,080
you know what this looks like at the

776
00:25:24,080 --> 00:25:26,320
underlying assembly

777
00:25:26,320 --> 00:25:28,640
so as usual right we have our function

778
00:25:28,640 --> 00:25:30,320
prolog we're creating space on the stack

779
00:25:30,320 --> 00:25:31,520
et cetera

780
00:25:31,520 --> 00:25:32,799
now here we're creating our local

781
00:25:32,799 --> 00:25:34,559
variables right so remember last time we

782
00:25:34,559 --> 00:25:35,520
talked about

783
00:25:35,520 --> 00:25:37,039
how local variables are stored on the

784
00:25:37,039 --> 00:25:39,840
stack and so we can see that here

785
00:25:39,840 --> 00:25:43,039
so at rbp minus eight we've got two

786
00:25:43,039 --> 00:25:46,080
so rbp minus eight is going to be

787
00:25:46,080 --> 00:25:50,720
a right and then here at rbp minus four

788
00:25:50,720 --> 00:25:52,799
we have three so rbp minus four

789
00:25:52,799 --> 00:25:54,240
represents b

790
00:25:54,240 --> 00:25:57,360
okay and so next remember

791
00:25:57,360 --> 00:26:00,799
when we call functions in c we pass the

792
00:26:00,799 --> 00:26:01,440
arguments

793
00:26:01,440 --> 00:26:04,080
through the to the functions through rdi

794
00:26:04,080 --> 00:26:05,520
and rsi

795
00:26:05,520 --> 00:26:07,679
but remember we're passing the addresses

796
00:26:07,679 --> 00:26:08,720
of these variables

797
00:26:08,720 --> 00:26:10,480
right which are going to be addresses on

798
00:26:10,480 --> 00:26:11,919
the stack because these are local

799
00:26:11,919 --> 00:26:13,200
variables so let's look at how that

800
00:26:13,200 --> 00:26:16,720
how that's played out so we use the

801
00:26:16,720 --> 00:26:20,240
load effective address instruction okay

802
00:26:20,240 --> 00:26:22,320
so i know we talked about before how

803
00:26:22,320 --> 00:26:24,159
this will dereference

804
00:26:24,159 --> 00:26:26,640
this value the brackets it won't it

805
00:26:26,640 --> 00:26:28,640
won't do that for lea

806
00:26:28,640 --> 00:26:31,600
so what we are loading into rdx here is

807
00:26:31,600 --> 00:26:32,880
the value

808
00:26:32,880 --> 00:26:36,080
of this address so we are loading this

809
00:26:36,080 --> 00:26:37,200
stack address

810
00:26:37,200 --> 00:26:40,480
into rdx so rdx contains

811
00:26:40,480 --> 00:26:43,600
a stack address for this function okay

812
00:26:43,600 --> 00:26:45,679
which event which points to the value

813
00:26:45,679 --> 00:26:47,039
three

814
00:26:47,039 --> 00:26:49,600
and then we do the same thing with rax

815
00:26:49,600 --> 00:26:50,159
except for

816
00:26:50,159 --> 00:26:53,200
grabbing a okay so

817
00:26:53,200 --> 00:26:55,440
rdx contains a stack address that points

818
00:26:55,440 --> 00:26:56,400
to b

819
00:26:56,400 --> 00:26:58,960
our ax contains a stack address that

820
00:26:58,960 --> 00:27:01,360
points to a

821
00:27:01,360 --> 00:27:03,840
and so before we call the function we

822
00:27:03,840 --> 00:27:06,000
move that value into rsi

823
00:27:06,000 --> 00:27:09,520
so we move the value for b into rsi

824
00:27:09,520 --> 00:27:12,640
we move the value for a into rdi

825
00:27:12,640 --> 00:27:14,240
because remember that's how we pass

826
00:27:14,240 --> 00:27:15,919
arguments to functions right we pass

827
00:27:15,919 --> 00:27:16,880
them through

828
00:27:16,880 --> 00:27:19,520
those registers and so now before we

829
00:27:19,520 --> 00:27:20,480
call this function

830
00:27:20,480 --> 00:27:22,640
much like we talked about here the first

831
00:27:22,640 --> 00:27:24,799
argument we passed is the address of a

832
00:27:24,799 --> 00:27:26,640
which is a stack address in this

833
00:27:26,640 --> 00:27:28,080
function right

834
00:27:28,080 --> 00:27:29,520
and then the second argument is the

835
00:27:29,520 --> 00:27:31,520
address of b again

836
00:27:31,520 --> 00:27:33,279
another stack address to a local

837
00:27:33,279 --> 00:27:35,120
variable in this function

838
00:27:35,120 --> 00:27:37,760
so we call the swap function remember we

839
00:27:37,760 --> 00:27:38,960
talked about how that

840
00:27:38,960 --> 00:27:41,279
what that does right so that's going to

841
00:27:41,279 --> 00:27:42,799
push the next instruction that we want

842
00:27:42,799 --> 00:27:44,320
to execute onto the stack

843
00:27:44,320 --> 00:27:47,440
and then jump to this call structure to

844
00:27:47,440 --> 00:27:48,880
the address here

845
00:27:48,880 --> 00:27:50,720
which as we can see points to swap so

846
00:27:50,720 --> 00:27:51,840
let's see what that looks like in a

847
00:27:51,840 --> 00:27:54,240
sample

848
00:27:56,559 --> 00:27:57,600
all right so we got a lot more

849
00:27:57,600 --> 00:28:00,840
instructions here right so remember

850
00:28:00,840 --> 00:28:04,080
rdi contains

851
00:28:04,080 --> 00:28:06,399
the address of a and rsi contains the

852
00:28:06,399 --> 00:28:08,960
address of b

853
00:28:08,960 --> 00:28:11,279
we are taking that stack address and

854
00:28:11,279 --> 00:28:13,840
storing it at this stack address

855
00:28:13,840 --> 00:28:16,880
right so here we're storing the stack

856
00:28:16,880 --> 00:28:18,240
address

857
00:28:18,240 --> 00:28:20,720
pointing to a at this address on the

858
00:28:20,720 --> 00:28:21,440
stack here

859
00:28:21,440 --> 00:28:22,559
right because these are going to be

860
00:28:22,559 --> 00:28:25,200
local variables within

861
00:28:25,200 --> 00:28:28,640
this function so this is the function

862
00:28:28,640 --> 00:28:30,240
prolog we're grabbing our register

863
00:28:30,240 --> 00:28:31,279
values that were passed and we're

864
00:28:31,279 --> 00:28:33,919
storing them locally so we can use them

865
00:28:33,919 --> 00:28:37,440
and so now at rbp minus hex

866
00:28:37,440 --> 00:28:40,320
18 we have the stack address of a so

867
00:28:40,320 --> 00:28:41,039
again it's not

868
00:28:41,039 --> 00:28:43,360
yet the value that a points to it's a

869
00:28:43,360 --> 00:28:45,520
value pointing to a

870
00:28:45,520 --> 00:28:48,559
so and then at rbp minus hex

871
00:28:48,559 --> 00:28:51,679
20 we have the value pointing to b

872
00:28:51,679 --> 00:28:54,960
and so this next chunk of code right now

873
00:28:54,960 --> 00:28:56,399
after running this instruction we're

874
00:28:56,399 --> 00:28:58,000
dereferencing this

875
00:28:58,000 --> 00:29:00,240
so rax has that stack address that we

876
00:29:00,240 --> 00:29:01,520
passed it

877
00:29:01,520 --> 00:29:05,200
right and the next instruction we call

878
00:29:05,200 --> 00:29:09,279
actually grabs that value pointed to

879
00:29:09,279 --> 00:29:12,320
by a which is going to be right and

880
00:29:12,320 --> 00:29:14,240
stores in eax

881
00:29:14,240 --> 00:29:17,200
and the last thing we do is we take that

882
00:29:17,200 --> 00:29:18,880
value and we store it to a local

883
00:29:18,880 --> 00:29:19,840
variable

884
00:29:19,840 --> 00:29:21,840
and that variable is what our our

885
00:29:21,840 --> 00:29:24,080
representation of temp here is

886
00:29:24,080 --> 00:29:26,320
and so i hope i hope that was relatively

887
00:29:26,320 --> 00:29:27,840
easy enough to follow there's a lot of

888
00:29:27,840 --> 00:29:29,360
instructions going on here and so if

889
00:29:29,360 --> 00:29:30,559
people have questions

890
00:29:30,559 --> 00:29:32,080
i'll take a second after we go over this

891
00:29:32,080 --> 00:29:33,679
to look at the chat

892
00:29:33,679 --> 00:29:37,279
and so okay so now we've we've

893
00:29:37,279 --> 00:29:39,520
set this local variable tab to the value

894
00:29:39,520 --> 00:29:40,880
pointed to

895
00:29:40,880 --> 00:29:44,960
by you know rbp minus 18 dereferenced

896
00:29:44,960 --> 00:29:49,120
twice so next we go down here

897
00:29:49,120 --> 00:29:52,240
and remember this points to our b

898
00:29:52,240 --> 00:29:55,120
variable right or y here right this is

899
00:29:55,120 --> 00:29:55,840
our y

900
00:29:55,840 --> 00:29:58,320
argument that was passed so now after

901
00:29:58,320 --> 00:30:01,039
running this first instruction

902
00:30:01,039 --> 00:30:03,679
rex points to rx contains a stack

903
00:30:03,679 --> 00:30:04,320
address

904
00:30:04,320 --> 00:30:07,360
that we passed into it previously so now

905
00:30:07,360 --> 00:30:09,200
we dereference that address

906
00:30:09,200 --> 00:30:11,360
to get the actual value which is going

907
00:30:11,360 --> 00:30:13,760
to be three

908
00:30:13,760 --> 00:30:17,440
okay and so edx at this point contains

909
00:30:17,440 --> 00:30:19,840
the value three we've grabbed it off the

910
00:30:19,840 --> 00:30:21,039
stack we've grabbed it from what was

911
00:30:21,039 --> 00:30:22,399
passed to us and now we've stored it in

912
00:30:22,399 --> 00:30:23,679
the edx

913
00:30:23,679 --> 00:30:27,520
so now we grab the address

914
00:30:27,520 --> 00:30:31,200
that a points to and we store into rax

915
00:30:31,200 --> 00:30:33,039
and then the last thing that we do is we

916
00:30:33,039 --> 00:30:34,399
store

917
00:30:34,399 --> 00:30:37,919
that value into that address

918
00:30:37,919 --> 00:30:39,840
so this point we've taken the value from

919
00:30:39,840 --> 00:30:42,240
y and we're storing it to what

920
00:30:42,240 --> 00:30:44,559
x points at or the value from b and

921
00:30:44,559 --> 00:30:46,880
storing it to what a

922
00:30:46,880 --> 00:30:49,360
and then the last segment here remember

923
00:30:49,360 --> 00:30:51,440
before we had the temp variable

924
00:30:51,440 --> 00:30:53,679
at rbp minus 4 which contains the value

925
00:30:53,679 --> 00:30:55,120
pointed to by x

926
00:30:55,120 --> 00:30:58,399
right which is 2. and so we're grabbing

927
00:30:58,399 --> 00:31:00,240
the address of the second variable here

928
00:31:00,240 --> 00:31:01,840
which again remember is a stack address

929
00:31:01,840 --> 00:31:04,720
this isn't this doesn't yet point to

930
00:31:04,720 --> 00:31:07,760
the value that we passed we dereference

931
00:31:07,760 --> 00:31:09,039
that

932
00:31:09,039 --> 00:31:11,519
and store it here we dereference our

933
00:31:11,519 --> 00:31:13,840
temp variable here store in the edx

934
00:31:13,840 --> 00:31:18,320
which is our star x value here and then

935
00:31:18,320 --> 00:31:20,799
finally we store

936
00:31:20,799 --> 00:31:24,159
that temp value at the address that y

937
00:31:24,159 --> 00:31:24,960
points to

938
00:31:24,960 --> 00:31:27,840
and essentially what this is doing is

939
00:31:27,840 --> 00:31:29,760
it's taking the values

940
00:31:29,760 --> 00:31:31,600
that each of these point two and

941
00:31:31,600 --> 00:31:34,000
swapping them

942
00:31:34,000 --> 00:31:36,480
so i know that was a lot i know that was

943
00:31:36,480 --> 00:31:37,840
a lot to get through it's also kind of

944
00:31:37,840 --> 00:31:40,159
difficult to explain without you know a

945
00:31:40,159 --> 00:31:41,200
debugger

946
00:31:41,200 --> 00:31:42,399
right there so i'm gonna take a quick

947
00:31:42,399 --> 00:31:43,679
second look at the chat and see what

948
00:31:43,679 --> 00:31:47,840
people say

949
00:31:48,960 --> 00:31:51,519
okay nobody has any questions that's

950
00:31:51,519 --> 00:31:52,159
awesome

951
00:31:52,159 --> 00:31:55,919
good all right so uh pointers in guitar

952
00:31:55,919 --> 00:31:57,039
we talked about pointers we talked about

953
00:31:57,039 --> 00:31:58,159
how confusing they can be

954
00:31:58,159 --> 00:31:59,440
when you're looking at them from an

955
00:31:59,440 --> 00:32:02,000
assembly perspective you can

956
00:32:02,000 --> 00:32:04,559
create pointers engage your using the

957
00:32:04,559 --> 00:32:05,840
pointer data type

958
00:32:05,840 --> 00:32:10,320
and so there you can have a pointer to

959
00:32:10,320 --> 00:32:11,919
you know multiple types of data so when

960
00:32:11,919 --> 00:32:13,440
you're making one if you want to make it

961
00:32:13,440 --> 00:32:14,000
a pointer to

962
00:32:14,000 --> 00:32:15,840
a structure when you're creating one of

963
00:32:15,840 --> 00:32:17,360
these types you can just do

964
00:32:17,360 --> 00:32:18,720
in the same way that we just did you

965
00:32:18,720 --> 00:32:20,480
know remember we did structure point

966
00:32:20,480 --> 00:32:21,919
for the structure that we were making if

967
00:32:21,919 --> 00:32:24,559
it were a pointer to the structure point

968
00:32:24,559 --> 00:32:26,559
you could just do point star so we'll

969
00:32:26,559 --> 00:32:28,159
take an example we'll take a quick look

970
00:32:28,159 --> 00:32:31,519
at some examples of this

971
00:32:37,039 --> 00:32:39,279
so

972
00:32:40,240 --> 00:32:42,480
let's take a look here at this schedule

973
00:32:42,480 --> 00:32:44,159
window we've got

974
00:32:44,159 --> 00:32:46,799
these values here these 32-bit values

975
00:32:46,799 --> 00:32:47,919
and

976
00:32:47,919 --> 00:32:50,240
if we look here at this address range

977
00:32:50,240 --> 00:32:51,600
right you look at the address and then

978
00:32:51,600 --> 00:32:52,799
you look at these values

979
00:32:52,799 --> 00:32:56,240
there's a really good chance that this

980
00:32:56,240 --> 00:32:58,960
value points to something roughly in

981
00:32:58,960 --> 00:33:00,000
this address range

982
00:33:00,000 --> 00:33:01,279
and so this is something that you'll

983
00:33:01,279 --> 00:33:03,120
kind of learn to spot and learn to look

984
00:33:03,120 --> 00:33:04,640
for especially when you're doing

985
00:33:04,640 --> 00:33:06,159
you know firmware re and things like

986
00:33:06,159 --> 00:33:09,120
that so if we want to turn that value

987
00:33:09,120 --> 00:33:10,000
this value here

988
00:33:10,000 --> 00:33:13,600
at 601048 into a pointer

989
00:33:13,600 --> 00:33:16,639
what you're going to do is this

990
00:33:16,960 --> 00:33:18,080
you're going to first click on

991
00:33:18,080 --> 00:33:19,440
powerpoint so you can click the right

992
00:33:19,440 --> 00:33:20,559
thing you're going to click

993
00:33:20,559 --> 00:33:24,240
data and then pointer and so

994
00:33:24,240 --> 00:33:25,840
what that's going to do is it's going to

995
00:33:25,840 --> 00:33:29,440
create then a pointer to 601040 and of

996
00:33:29,440 --> 00:33:31,360
course when you double click on this

997
00:33:31,360 --> 00:33:33,200
that's going to point back to this value

998
00:33:33,200 --> 00:33:35,039
so it'll it'll jump to what it's

999
00:33:35,039 --> 00:33:35,919
pointing to

1000
00:33:35,919 --> 00:33:37,519
so creating the pointer type just tells

1001
00:33:37,519 --> 00:33:39,200
it to treat that grouping of bytes as an

1002
00:33:39,200 --> 00:33:42,480
address that you can then jump to

1003
00:33:43,760 --> 00:33:46,080
and so here's an example of what some c

1004
00:33:46,080 --> 00:33:47,919
code to the left that i wrote to kind of

1005
00:33:47,919 --> 00:33:49,840
generate this to demonstrate you know

1006
00:33:49,840 --> 00:33:51,440
pointers two pointers and things like

1007
00:33:51,440 --> 00:33:53,760
that so

1008
00:33:53,760 --> 00:33:55,760
we have the first pointer which points

1009
00:33:55,760 --> 00:33:58,000
to this integer that we made here

1010
00:33:58,000 --> 00:33:59,919
and so that's right here you can see

1011
00:33:59,919 --> 00:34:01,200
that this

1012
00:34:01,200 --> 00:34:03,519
pointer at six zero one zero four eight

1013
00:34:03,519 --> 00:34:05,600
points to six zero one zero four zero

1014
00:34:05,600 --> 00:34:06,960
and then we have the second pointer

1015
00:34:06,960 --> 00:34:08,719
aptly named pointer two

1016
00:34:08,719 --> 00:34:12,079
that points to that first one and so

1017
00:34:12,079 --> 00:34:13,599
you can see the giger can even tell wait

1018
00:34:13,599 --> 00:34:15,359
a minute that's a pointer to yet another

1019
00:34:15,359 --> 00:34:16,480
pointer because you already have it

1020
00:34:16,480 --> 00:34:17,440
defined

1021
00:34:17,440 --> 00:34:20,639
and so that's how you define you know

1022
00:34:20,639 --> 00:34:22,560
pointers in ghidra and so

1023
00:34:22,560 --> 00:34:24,879
to kind of dig into that even more

1024
00:34:24,879 --> 00:34:25,918
remember that

1025
00:34:25,918 --> 00:34:27,520
with pointers pointers can point to any

1026
00:34:27,520 --> 00:34:28,960
data type right it could point to

1027
00:34:28,960 --> 00:34:30,800
it might point to a function it could

1028
00:34:30,800 --> 00:34:32,560
point to you know any

1029
00:34:32,560 --> 00:34:34,079
applicable data type that you have in

1030
00:34:34,079 --> 00:34:36,159
your c program and so

1031
00:34:36,159 --> 00:34:37,679
for this exercise i want you to keep

1032
00:34:37,679 --> 00:34:39,599
that in mind because

1033
00:34:39,599 --> 00:34:41,199
this kind of builds off of the structs

1034
00:34:41,199 --> 00:34:43,280
example except for

1035
00:34:43,280 --> 00:34:45,280
within this struct now there's going to

1036
00:34:45,280 --> 00:34:46,639
be there's going to be a pointer to

1037
00:34:46,639 --> 00:34:47,040
something

1038
00:34:47,040 --> 00:34:49,280
i'm not going to tell you what it's for

1039
00:34:49,280 --> 00:34:50,800
but i want you to take a look at that

1040
00:34:50,800 --> 00:34:52,320
and see if you can get that sorted and

1041
00:34:52,320 --> 00:34:52,800
so

1042
00:34:52,800 --> 00:34:54,800
you know much like the structures

1043
00:34:54,800 --> 00:34:56,239
exercise

1044
00:34:56,239 --> 00:34:57,520
try to figure out what the members of

1045
00:34:57,520 --> 00:34:59,119
the structure represent and what they're

1046
00:34:59,119 --> 00:35:00,640
used for

1047
00:35:00,640 --> 00:35:02,640
and as you're going through this and

1048
00:35:02,640 --> 00:35:03,920
even looking at the compiler

1049
00:35:03,920 --> 00:35:05,280
just try to figure out all right how are

1050
00:35:05,280 --> 00:35:07,200
we using

1051
00:35:07,200 --> 00:35:09,359
pointers here and what's the purpose of

1052
00:35:09,359 --> 00:35:10,640
using them here

1053
00:35:10,640 --> 00:35:12,720
so this exercise is up in the github

1054
00:35:12,720 --> 00:35:14,000
repo and

1055
00:35:14,000 --> 00:35:16,240
these i will say these exercises for

1056
00:35:16,240 --> 00:35:17,599
session three are

1057
00:35:17,599 --> 00:35:19,200
the difficulty is gonna be ramped up

1058
00:35:19,200 --> 00:35:21,119
just a little bit so if you have

1059
00:35:21,119 --> 00:35:21,920
questions

1060
00:35:21,920 --> 00:35:24,079
reach out in the chat and let us know uh

1061
00:35:24,079 --> 00:35:25,520
so we can help you

1062
00:35:25,520 --> 00:35:27,440
solve these because i think i think this

1063
00:35:27,440 --> 00:35:29,040
new set of challenges is gonna be very

1064
00:35:29,040 --> 00:35:29,599
fun

1065
00:35:29,599 --> 00:35:32,640
for everybody so

1066
00:35:32,640 --> 00:35:34,160
we've talked about structs we've talked

1067
00:35:34,160 --> 00:35:35,440
about pointers there's another

1068
00:35:35,440 --> 00:35:37,119
interesting data type that's

1069
00:35:37,119 --> 00:35:40,960
not necessarily super useful as far as

1070
00:35:40,960 --> 00:35:43,119
reconstructing and things like that but

1071
00:35:43,119 --> 00:35:44,160
enums

1072
00:35:44,160 --> 00:35:47,599
are another user-defined data type

1073
00:35:47,599 --> 00:35:50,560
in c and again they kind of if you look

1074
00:35:50,560 --> 00:35:52,000
up you know the formal definition it

1075
00:35:52,000 --> 00:35:53,440
assigns names to these integral

1076
00:35:53,440 --> 00:35:56,320
constructs and a lot of times you'll see

1077
00:35:56,320 --> 00:35:57,200
these

1078
00:35:57,200 --> 00:35:59,599
if you're looking at code for maybe

1079
00:35:59,599 --> 00:36:01,680
implementing a particular protocol

1080
00:36:01,680 --> 00:36:04,240
or you know code where particular

1081
00:36:04,240 --> 00:36:06,720
constants might always increase by one

1082
00:36:06,720 --> 00:36:08,480
and so you need to have like you want to

1083
00:36:08,480 --> 00:36:10,000
have an array of them not an array but

1084
00:36:10,000 --> 00:36:11,280
you want to have a way of representing

1085
00:36:11,280 --> 00:36:12,640
them that only takes up a certain amount

1086
00:36:12,640 --> 00:36:14,160
of space

1087
00:36:14,160 --> 00:36:18,000
so these are often used in

1088
00:36:18,000 --> 00:36:19,680
you know larger c programs to kind of

1089
00:36:19,680 --> 00:36:21,359
increase the readability of code and

1090
00:36:21,359 --> 00:36:22,720
what it is it's just a collection of

1091
00:36:22,720 --> 00:36:25,920
values that the compiler will assign

1092
00:36:25,920 --> 00:36:28,960
constants to you know at compile time it

1093
00:36:28,960 --> 00:36:30,480
just makes the code a little more

1094
00:36:30,480 --> 00:36:31,359
readable

1095
00:36:31,359 --> 00:36:33,680
and so by constructing these in guidra

1096
00:36:33,680 --> 00:36:35,040
you can make your gauge recode a lot

1097
00:36:35,040 --> 00:36:36,720
more readable as well or your guidra you

1098
00:36:36,720 --> 00:36:38,240
know disassembly and your decompilation

1099
00:36:38,240 --> 00:36:39,599
a lot more readable

1100
00:36:39,599 --> 00:36:41,760
so much like structures we talked about

1101
00:36:41,760 --> 00:36:42,720
before

1102
00:36:42,720 --> 00:36:45,599
you can import enums in through c files

1103
00:36:45,599 --> 00:36:47,280
or header files or if you want you can

1104
00:36:47,280 --> 00:36:48,800
define them manually

1105
00:36:48,800 --> 00:36:50,960
and so you can apply these to both you

1106
00:36:50,960 --> 00:36:51,839
know variables

1107
00:36:51,839 --> 00:36:53,920
and scalars in the disassembly listing

1108
00:36:53,920 --> 00:36:55,119
and we haven't talked about what a

1109
00:36:55,119 --> 00:36:56,320
scalar is yet

1110
00:36:56,320 --> 00:36:57,680
but essentially when you see someone

1111
00:36:57,680 --> 00:36:59,280
talking about scalars a scalar is an

1112
00:36:59,280 --> 00:37:00,480
immediate value

1113
00:37:00,480 --> 00:37:02,560
right it's a it's a raw binary value

1114
00:37:02,560 --> 00:37:04,800
that's used in the program

1115
00:37:04,800 --> 00:37:08,240
and so you can do you can retype a

1116
00:37:08,240 --> 00:37:08,960
variable to

1117
00:37:08,960 --> 00:37:11,119
an enum in the compiler view or in the

1118
00:37:11,119 --> 00:37:13,040
listing view and again gigi will try to

1119
00:37:13,040 --> 00:37:15,040
propagate those changes across both

1120
00:37:15,040 --> 00:37:16,880
and sometimes it works i've had times

1121
00:37:16,880 --> 00:37:18,240
where it doesn't but

1122
00:37:18,240 --> 00:37:21,280
you can experiment for yourself and see

1123
00:37:21,280 --> 00:37:24,480
you know how well that works for you so

1124
00:37:24,480 --> 00:37:26,960
here's a simple example of a program

1125
00:37:26,960 --> 00:37:28,960
that has an enum that represents each

1126
00:37:28,960 --> 00:37:30,079
day of the week

1127
00:37:30,079 --> 00:37:33,280
and so that is represented here with

1128
00:37:33,280 --> 00:37:33,920
ivar

1129
00:37:33,920 --> 00:37:37,920
zero or ibr1 so this enum is the classic

1130
00:37:37,920 --> 00:37:39,839
enum example of it's got all the days

1131
00:37:39,839 --> 00:37:40,960
sunday through saturday

1132
00:37:40,960 --> 00:37:42,720
and it goes zero one two three four five

1133
00:37:42,720 --> 00:37:45,119
six okay

1134
00:37:45,119 --> 00:37:47,599
so if we wanted to maybe make this a

1135
00:37:47,599 --> 00:37:48,960
little more readable and i'm using the

1136
00:37:48,960 --> 00:37:49,760
days

1137
00:37:49,760 --> 00:37:51,839
is a simple example here right so

1138
00:37:51,839 --> 00:37:53,119
obviously you can look at this and kind

1139
00:37:53,119 --> 00:37:54,640
of see what the program is doing

1140
00:37:54,640 --> 00:37:55,920
the point of this exercise is to

1141
00:37:55,920 --> 00:37:58,880
illustrate how to illustr how to

1142
00:37:58,880 --> 00:38:01,040
add an enum to your program in order to

1143
00:38:01,040 --> 00:38:02,400
make it more readable because eventually

1144
00:38:02,400 --> 00:38:03,440
you're going to look at something much

1145
00:38:03,440 --> 00:38:04,000
more complex

1146
00:38:04,000 --> 00:38:05,280
than this and you're going to want to

1147
00:38:05,280 --> 00:38:07,040
make it a little more readable

1148
00:38:07,040 --> 00:38:11,760
and so you can load up the enum editor

1149
00:38:11,760 --> 00:38:14,320
right and so you can see in this enum

1150
00:38:14,320 --> 00:38:15,119
editor

1151
00:38:15,119 --> 00:38:17,200
which you can add just like we did with

1152
00:38:17,200 --> 00:38:18,640
struxx if you go to the data types

1153
00:38:18,640 --> 00:38:19,119
window

1154
00:38:19,119 --> 00:38:21,839
and right click you know new you can add

1155
00:38:21,839 --> 00:38:23,359
a new enum

1156
00:38:23,359 --> 00:38:25,760
and then you can just create by clicking

1157
00:38:25,760 --> 00:38:27,599
the plus button you add a new field

1158
00:38:27,599 --> 00:38:29,119
and i didn't i didn't think i needed to

1159
00:38:29,119 --> 00:38:30,400
kind of go through how to do that six

1160
00:38:30,400 --> 00:38:32,480
times for everybody so if anybody has

1161
00:38:32,480 --> 00:38:34,079
any questions on how to do that please

1162
00:38:34,079 --> 00:38:35,680
let me know in the chat and uh we can

1163
00:38:35,680 --> 00:38:37,760
walk through it but so you can name the

1164
00:38:37,760 --> 00:38:38,560
enum

1165
00:38:38,560 --> 00:38:39,920
and you can give it a description even

1166
00:38:39,920 --> 00:38:41,760
if you want and then this is how you

1167
00:38:41,760 --> 00:38:43,520
create it much like we created the

1168
00:38:43,520 --> 00:38:45,680
struct originally

1169
00:38:45,680 --> 00:38:47,359
and so now we want to take that right

1170
00:38:47,359 --> 00:38:48,400
and we want to apply it to this

1171
00:38:48,400 --> 00:38:49,280
decompilation

1172
00:38:49,280 --> 00:38:52,800
to make it a little more readable

1173
00:38:52,800 --> 00:38:54,800
and so much like we've done in the past

1174
00:38:54,800 --> 00:38:56,560
right you right click the variable click

1175
00:38:56,560 --> 00:39:00,079
retype and then provide the type

1176
00:39:00,079 --> 00:39:03,760
so we created the day enum right

1177
00:39:03,760 --> 00:39:06,960
and so we type in day

1178
00:39:06,960 --> 00:39:09,680
and then once we do that it knows that

1179
00:39:09,680 --> 00:39:10,000
this

1180
00:39:10,000 --> 00:39:12,640
is the day enum so anytime it's compared

1181
00:39:12,640 --> 00:39:13,040
to

1182
00:39:13,040 --> 00:39:14,720
an immediate value it will put the

1183
00:39:14,720 --> 00:39:16,640
representative immediate value

1184
00:39:16,640 --> 00:39:18,960
in the decompilation listing which again

1185
00:39:18,960 --> 00:39:20,480
just makes things a little more readable

1186
00:39:20,480 --> 00:39:22,000
you can imagine that if you had

1187
00:39:22,000 --> 00:39:25,440
a much bigger program and you had

1188
00:39:25,440 --> 00:39:28,640
you know more constants in play that

1189
00:39:28,640 --> 00:39:30,079
these this would be more useful

1190
00:39:30,079 --> 00:39:32,079
but this is just an example of showing

1191
00:39:32,079 --> 00:39:33,520
you how to

1192
00:39:33,520 --> 00:39:35,599
how to create enums and dj i figured

1193
00:39:35,599 --> 00:39:37,040
since we were going over structures it's

1194
00:39:37,040 --> 00:39:38,240
important to also go over this

1195
00:39:38,240 --> 00:39:39,680
you're not going to get an exercise for

1196
00:39:39,680 --> 00:39:42,560
this but it's important to understand

1197
00:39:42,560 --> 00:39:46,320
uh nonetheless so

1198
00:39:46,320 --> 00:39:48,079
we've gone over all these user-defined

1199
00:39:48,079 --> 00:39:49,680
data types and see and kind of how you

1200
00:39:49,680 --> 00:39:51,200
can attempt to reconstruct them in

1201
00:39:51,200 --> 00:39:51,839
ghidra

1202
00:39:51,839 --> 00:39:54,400
there are there are other parts of you

1203
00:39:54,400 --> 00:39:55,680
know c programs that we really haven't

1204
00:39:55,680 --> 00:39:56,000
gotten

1205
00:39:56,000 --> 00:39:58,560
into yet and in order to understand some

1206
00:39:58,560 --> 00:40:00,240
of these things we need to actually

1207
00:40:00,240 --> 00:40:02,960
go even deeper and talk really quickly

1208
00:40:02,960 --> 00:40:03,440
about

1209
00:40:03,440 --> 00:40:07,440
system calls for x86 so

1210
00:40:07,440 --> 00:40:09,440
system calls are used to interface with

1211
00:40:09,440 --> 00:40:11,040
the operating system anytime you need

1212
00:40:11,040 --> 00:40:12,400
something that might require additional

1213
00:40:12,400 --> 00:40:13,280
privilege like

1214
00:40:13,280 --> 00:40:15,280
opening a file writing to a file things

1215
00:40:15,280 --> 00:40:17,440
like that you need to do this through

1216
00:40:17,440 --> 00:40:19,440
you know a system call

1217
00:40:19,440 --> 00:40:21,200
and the operating system has a syscall

1218
00:40:21,200 --> 00:40:22,880
handler to catch these system calls when

1219
00:40:22,880 --> 00:40:23,760
they occur

1220
00:40:23,760 --> 00:40:25,760
and they are called by using an

1221
00:40:25,760 --> 00:40:26,880
instruction called

1222
00:40:26,880 --> 00:40:30,160
syscall and so

1223
00:40:30,160 --> 00:40:32,800
if you want to call a particular syscall

1224
00:40:32,800 --> 00:40:34,800
the information you use

1225
00:40:34,800 --> 00:40:36,400
to tell the operating system which

1226
00:40:36,400 --> 00:40:38,000
syscall you want to call

1227
00:40:38,000 --> 00:40:40,319
are requested by passing values through

1228
00:40:40,319 --> 00:40:42,000
these registers

1229
00:40:42,000 --> 00:40:44,319
so much like you know we talked about

1230
00:40:44,319 --> 00:40:46,000
how you set up a function call by

1231
00:40:46,000 --> 00:40:47,359
passing certain things in through

1232
00:40:47,359 --> 00:40:49,599
registers right there's a defined api

1233
00:40:49,599 --> 00:40:50,800
that says

1234
00:40:50,800 --> 00:40:52,560
arguments go in in this order through

1235
00:40:52,560 --> 00:40:54,000
these registers you have something very

1236
00:40:54,000 --> 00:40:55,440
similar to the syscall instruction and

1237
00:40:55,440 --> 00:40:57,200
this is the linux version this is how

1238
00:40:57,200 --> 00:40:58,160
linux handles

1239
00:40:58,160 --> 00:41:02,400
you know the cisco instruction so

1240
00:41:02,400 --> 00:41:04,240
register rax has the system called

1241
00:41:04,240 --> 00:41:06,079
number and if you

1242
00:41:06,079 --> 00:41:08,319
google you know linux system call table

1243
00:41:08,319 --> 00:41:09,520
you'll be able to see

1244
00:41:09,520 --> 00:41:11,520
which system call numbers correlate to

1245
00:41:11,520 --> 00:41:12,720
which system call

1246
00:41:12,720 --> 00:41:14,720
and so a system call can be something as

1247
00:41:14,720 --> 00:41:15,839
simple as you know

1248
00:41:15,839 --> 00:41:18,000
writing a file opening a file things

1249
00:41:18,000 --> 00:41:20,720
like that exiting a program etc

1250
00:41:20,720 --> 00:41:22,960
and so at rcx you have the return

1251
00:41:22,960 --> 00:41:23,760
address

1252
00:41:23,760 --> 00:41:26,480
r11 you have the flags like the saved

1253
00:41:26,480 --> 00:41:28,079
our flags we talked about that how that

1254
00:41:28,079 --> 00:41:31,119
gets set for conditional statements

1255
00:41:31,119 --> 00:41:33,520
and then the rest of these are just

1256
00:41:33,520 --> 00:41:35,599
arguments for that syscall

1257
00:41:35,599 --> 00:41:37,839
and so a lot of you probably haven't

1258
00:41:37,839 --> 00:41:39,520
seen this instruction because nine times

1259
00:41:39,520 --> 00:41:40,640
out of ten it's going to be implemented

1260
00:41:40,640 --> 00:41:41,599
by libsy

1261
00:41:41,599 --> 00:41:44,000
so when you call printf right printf is

1262
00:41:44,000 --> 00:41:46,400
gonna call the right syscall

1263
00:41:46,400 --> 00:41:48,640
and it's gonna write to you know

1264
00:41:48,640 --> 00:41:49,440
standard out

1265
00:41:49,440 --> 00:41:51,839
but you provide those arguments through

1266
00:41:51,839 --> 00:41:53,280
the libsy function call but we're going

1267
00:41:53,280 --> 00:41:54,720
to take a look at what this might look

1268
00:41:54,720 --> 00:41:55,040
like

1269
00:41:55,040 --> 00:41:57,680
in assembly

1270
00:41:58,800 --> 00:42:02,000
so here is some assembly code

1271
00:42:02,000 --> 00:42:04,960
that is going to print out hackaday you

1272
00:42:04,960 --> 00:42:06,160
to the screen

1273
00:42:06,160 --> 00:42:07,920
okay now i know a couple of you had

1274
00:42:07,920 --> 00:42:09,200
mentioned that you're still having

1275
00:42:09,200 --> 00:42:09,920
trouble

1276
00:42:09,920 --> 00:42:10,960
kind of reading assembly and

1277
00:42:10,960 --> 00:42:13,200
understanding it and

1278
00:42:13,200 --> 00:42:16,319
we can talk about that here so the first

1279
00:42:16,319 --> 00:42:17,520
thing that this thing does

1280
00:42:17,520 --> 00:42:21,119
is it sets up all the parameters for

1281
00:42:21,119 --> 00:42:23,680
the right system call okay so if you

1282
00:42:23,680 --> 00:42:25,440
look up the system call table

1283
00:42:25,440 --> 00:42:28,000
you'll see that value one is the right

1284
00:42:28,000 --> 00:42:29,839
syscall

1285
00:42:29,839 --> 00:42:31,440
second the first argument that gets

1286
00:42:31,440 --> 00:42:33,520
passed to it is the file descriptor that

1287
00:42:33,520 --> 00:42:34,720
it's going to write to

1288
00:42:34,720 --> 00:42:36,720
and so the standard out file descriptor

1289
00:42:36,720 --> 00:42:38,480
is just one

1290
00:42:38,480 --> 00:42:41,760
the second argument is an address

1291
00:42:41,760 --> 00:42:43,760
to the buffer that it's going to write

1292
00:42:43,760 --> 00:42:45,599
out and so you'll see here

1293
00:42:45,599 --> 00:42:46,880
that that points to something in the

1294
00:42:46,880 --> 00:42:49,680
read-only data this hackadayu string

1295
00:42:49,680 --> 00:42:51,520
and then the last argument which we load

1296
00:42:51,520 --> 00:42:53,440
up into rdx is how many

1297
00:42:53,440 --> 00:42:56,720
characters to write out and so this is

1298
00:42:56,720 --> 00:42:58,400
if you were to look at

1299
00:42:58,400 --> 00:43:01,680
you know the c source code

1300
00:43:01,680 --> 00:43:04,240
for you know the lib c implementation of

1301
00:43:04,240 --> 00:43:05,920
printf it might look something similar

1302
00:43:05,920 --> 00:43:07,680
to this except for these values would be

1303
00:43:07,680 --> 00:43:10,000
provided by whoever calls it

1304
00:43:10,000 --> 00:43:11,920
right the system call number would be

1305
00:43:11,920 --> 00:43:13,920
the same but these are the three things

1306
00:43:13,920 --> 00:43:15,119
if you've written c before that you

1307
00:43:15,119 --> 00:43:15,920
recognize

1308
00:43:15,920 --> 00:43:18,240
are the variables you pass in to you

1309
00:43:18,240 --> 00:43:19,920
know print effort to write or what have

1310
00:43:19,920 --> 00:43:20,880
you

1311
00:43:20,880 --> 00:43:23,520
so this is how that's implemented like

1312
00:43:23,520 --> 00:43:24,640
at the assembly level

1313
00:43:24,640 --> 00:43:26,079
and so the operating system has a

1314
00:43:26,079 --> 00:43:27,599
handler for this that will catch this

1315
00:43:27,599 --> 00:43:28,640
when it's called

1316
00:43:28,640 --> 00:43:30,880
and read these values and say okay i

1317
00:43:30,880 --> 00:43:32,000
know what i need to do

1318
00:43:32,000 --> 00:43:35,200
i just caught a syscall instruction with

1319
00:43:35,200 --> 00:43:37,839
one as rex i need to write somewhere and

1320
00:43:37,839 --> 00:43:38,880
then it grabs

1321
00:43:38,880 --> 00:43:40,640
the information that it needs in order

1322
00:43:40,640 --> 00:43:42,160
to perform that right and performs it

1323
00:43:42,160 --> 00:43:43,839
and returns

1324
00:43:43,839 --> 00:43:46,720
and so so this is essentially just a

1325
00:43:46,720 --> 00:43:47,839
printf

1326
00:43:47,839 --> 00:43:50,800
of you know the string hackaday u that's

1327
00:43:50,800 --> 00:43:51,839
all it is

1328
00:43:51,839 --> 00:43:55,200
and this last system call that we have

1329
00:43:55,200 --> 00:43:58,960
will exit the program that's it

1330
00:43:58,960 --> 00:44:01,040
and so if you look at syscall you know

1331
00:44:01,040 --> 00:44:02,720
60 that's

1332
00:44:02,720 --> 00:44:06,160
exit program so this is just a quick and

1333
00:44:06,160 --> 00:44:07,040
dirty example

1334
00:44:07,040 --> 00:44:09,760
of you know what system calls are and

1335
00:44:09,760 --> 00:44:11,040
how they're implemented

1336
00:44:11,040 --> 00:44:12,560
and again it's important to understand

1337
00:44:12,560 --> 00:44:14,079
this because if you start looking at you

1338
00:44:14,079 --> 00:44:15,599
know really low level stuff you start

1339
00:44:15,599 --> 00:44:16,880
looking at

1340
00:44:16,880 --> 00:44:20,000
um you know things that improv that

1341
00:44:20,000 --> 00:44:20,720
interface

1342
00:44:20,720 --> 00:44:22,800
you know they might interface with the

1343
00:44:22,800 --> 00:44:24,480
driver you might be looking at kernel

1344
00:44:24,480 --> 00:44:26,079
code etc

1345
00:44:26,079 --> 00:44:27,920
it's important to understand how these

1346
00:44:27,920 --> 00:44:29,119
things are structured before they're

1347
00:44:29,119 --> 00:44:30,960
actually called

1348
00:44:30,960 --> 00:44:33,520
and so we have an exercise for this

1349
00:44:33,520 --> 00:44:35,520
that's called syscall exercise

1350
00:44:35,520 --> 00:44:37,280
and so what i'd like you to do before

1351
00:44:37,280 --> 00:44:38,800
you run the program

1352
00:44:38,800 --> 00:44:41,839
get as far as you can with figuring out

1353
00:44:41,839 --> 00:44:42,960
you know okay

1354
00:44:42,960 --> 00:44:45,599
what's this calls are is it calling so

1355
00:44:45,599 --> 00:44:47,680
what values are in rax when it calls

1356
00:44:47,680 --> 00:44:49,359
this call and write those down figure

1357
00:44:49,359 --> 00:44:50,960
out like okay it's using

1358
00:44:50,960 --> 00:44:53,520
xyz syscalls what are the arguments to

1359
00:44:53,520 --> 00:44:54,720
those sys calls

1360
00:44:54,720 --> 00:44:56,880
and then based on that can you figure

1361
00:44:56,880 --> 00:44:57,920
out what this

1362
00:44:57,920 --> 00:45:01,280
syscalls program is doing if you run it

1363
00:45:01,280 --> 00:45:02,800
it's going to be fairly apparent but

1364
00:45:02,800 --> 00:45:04,400
what i'd really like for

1365
00:45:04,400 --> 00:45:06,400
everyone to do before they run it is to

1366
00:45:06,400 --> 00:45:08,079
look at it statically

1367
00:45:08,079 --> 00:45:12,400
for a while and try to figure it out so

1368
00:45:12,400 --> 00:45:14,079
this is a fairly this exercise won't

1369
00:45:14,079 --> 00:45:16,079
take a whole lot of time this is

1370
00:45:16,079 --> 00:45:18,319
some artisanal handcrafted assembly

1371
00:45:18,319 --> 00:45:21,759
language that we wrote for you guys

1372
00:45:22,079 --> 00:45:23,760
and also one thing you'll notice about

1373
00:45:23,760 --> 00:45:25,200
this you know the entry point might be a

1374
00:45:25,200 --> 00:45:26,400
little different so

1375
00:45:26,400 --> 00:45:27,839
take a look at that and remember that we

1376
00:45:27,839 --> 00:45:29,680
talked about before you want to always

1377
00:45:29,680 --> 00:45:31,520
start with if you can't find maine start

1378
00:45:31,520 --> 00:45:33,440
with underscore start

1379
00:45:33,440 --> 00:45:35,359
right because you see here you've got

1380
00:45:35,359 --> 00:45:38,078
underscore start

1381
00:45:38,640 --> 00:45:41,200
and so we talked about system calls

1382
00:45:41,200 --> 00:45:42,800
because i want everybody to understand

1383
00:45:42,800 --> 00:45:44,400
have a better understanding of file

1384
00:45:44,400 --> 00:45:46,160
operations and see

1385
00:45:46,160 --> 00:45:48,480
and again these system calls are used to

1386
00:45:48,480 --> 00:45:50,160
implement those low level operations if

1387
00:45:50,160 --> 00:45:50,880
you know reading

1388
00:45:50,880 --> 00:45:54,240
to files opening files closing them etc

1389
00:45:54,240 --> 00:45:57,280
and when you write c code you often are

1390
00:45:57,280 --> 00:45:58,240
using you know a

1391
00:45:58,240 --> 00:46:00,640
function that wraps those syscalls so

1392
00:46:00,640 --> 00:46:01,760
you're using you know libsy's

1393
00:46:01,760 --> 00:46:03,280
implementation of open or right which

1394
00:46:03,280 --> 00:46:04,640
eventually does call the cisco

1395
00:46:04,640 --> 00:46:06,079
instruction with the arguments you

1396
00:46:06,079 --> 00:46:07,280
provide

1397
00:46:07,280 --> 00:46:09,359
and so for the purpose of our exercises

1398
00:46:09,359 --> 00:46:10,560
that we're doing here these file

1399
00:46:10,560 --> 00:46:12,319
operations are they're not necessarily

1400
00:46:12,319 --> 00:46:13,680
going to look like the syscalls that you

1401
00:46:13,680 --> 00:46:14,720
just saw they're going to look like

1402
00:46:14,720 --> 00:46:16,400
regular function calls

1403
00:46:16,400 --> 00:46:18,240
because again libsy kind of utilizes the

1404
00:46:18,240 --> 00:46:19,760
system called instruction for you to

1405
00:46:19,760 --> 00:46:21,680
provide these in a

1406
00:46:21,680 --> 00:46:23,599
more approachable way so let's take a

1407
00:46:23,599 --> 00:46:25,200
look at some example code and

1408
00:46:25,200 --> 00:46:26,960
how it'll translate that does some

1409
00:46:26,960 --> 00:46:30,240
operations on some files

1410
00:46:30,880 --> 00:46:33,119
so we've got a fairly standard chunk of

1411
00:46:33,119 --> 00:46:34,240
c here on the left

1412
00:46:34,240 --> 00:46:36,000
where we're just going to open a file

1413
00:46:36,000 --> 00:46:38,240
called testfile.txt and write the string

1414
00:46:38,240 --> 00:46:39,440
write to file to it

1415
00:46:39,440 --> 00:46:41,920
and then we're going to close it right

1416
00:46:41,920 --> 00:46:44,000
so let's take a look at how this

1417
00:46:44,000 --> 00:46:47,200
translates into assembly

1418
00:46:47,599 --> 00:46:49,760
so we've got our function prolog here

1419
00:46:49,760 --> 00:46:51,200
nothing new this is all stuff we're used

1420
00:46:51,200 --> 00:46:52,640
to right these are all local variables

1421
00:46:52,640 --> 00:46:53,920
right we've got

1422
00:46:53,920 --> 00:46:56,960
rxc we've got our v and then we've got

1423
00:46:56,960 --> 00:46:57,760
this value

1424
00:46:57,760 --> 00:47:00,880
here hex 400 6a4 that's being stored

1425
00:47:00,880 --> 00:47:02,000
locally

1426
00:47:02,000 --> 00:47:05,040
so if we want to figure out what that is

1427
00:47:05,040 --> 00:47:07,040
you can use you know object you can use

1428
00:47:07,040 --> 00:47:09,280
any of the tools we talked about

1429
00:47:09,280 --> 00:47:14,079
that analyze elf files and if we do that

1430
00:47:14,079 --> 00:47:16,480
we see that in the read-only data we've

1431
00:47:16,480 --> 00:47:18,560
got both of these strings here

1432
00:47:18,560 --> 00:47:22,160
right so at 6a4 we've got right to file

1433
00:47:22,160 --> 00:47:24,400
the null terminated ascii string and

1434
00:47:24,400 --> 00:47:26,319
that's going to be stored

1435
00:47:26,319 --> 00:47:29,760
at rbp minus x8 and then

1436
00:47:29,760 --> 00:47:33,920
at 6b4 we've got the name of the file

1437
00:47:33,920 --> 00:47:35,200
so we'll just keep that in mind for

1438
00:47:35,200 --> 00:47:36,960
later but that's where these variables

1439
00:47:36,960 --> 00:47:38,400
are being stored in the elf file and you

1440
00:47:38,400 --> 00:47:39,920
can find that by using some of the

1441
00:47:39,920 --> 00:47:41,520
utilities we talked about in the first

1442
00:47:41,520 --> 00:47:42,400
session

1443
00:47:42,400 --> 00:47:43,920
or gauger would tell you this if you

1444
00:47:43,920 --> 00:47:45,520
were looking at it in assembly

1445
00:47:45,520 --> 00:47:46,880
or if you were just looking at the

1446
00:47:46,880 --> 00:47:49,359
compiler

1447
00:47:49,839 --> 00:47:53,200
and so when we call the open function

1448
00:47:53,200 --> 00:47:54,000
right

1449
00:47:54,000 --> 00:47:57,440
so we're passing it remember 6b2

1450
00:47:57,440 --> 00:48:00,480
so if we look back 6b

1451
00:48:00,480 --> 00:48:04,000
1 6b2 that's the address of our file

1452
00:48:04,000 --> 00:48:05,280
name

1453
00:48:05,280 --> 00:48:08,319
so we're passing it the file name in edi

1454
00:48:08,319 --> 00:48:11,520
we are passing it the permissions

1455
00:48:11,520 --> 00:48:15,119
in esi and then we are calling

1456
00:48:15,119 --> 00:48:18,960
open right and so

1457
00:48:18,960 --> 00:48:22,079
what this is going to return is a file

1458
00:48:22,079 --> 00:48:24,319
much like we see here when this function

1459
00:48:24,319 --> 00:48:25,760
returns we know because of the

1460
00:48:25,760 --> 00:48:28,559
eabi it's going to return the handle to

1461
00:48:28,559 --> 00:48:29,440
the file in

1462
00:48:29,440 --> 00:48:33,119
you know rax right so next after that

1463
00:48:33,119 --> 00:48:37,280
we have our eax value here

1464
00:48:37,280 --> 00:48:39,280
which is our file descriptor which is

1465
00:48:39,280 --> 00:48:40,400
returned from open

1466
00:48:40,400 --> 00:48:42,640
and we're storing that here on the stack

1467
00:48:42,640 --> 00:48:45,839
okay rbp minus x14

1468
00:48:45,839 --> 00:48:47,839
and so now we're grabbing rbp minus hex

1469
00:48:47,839 --> 00:48:50,559
eight storing that into rcx

1470
00:48:50,559 --> 00:48:52,480
the address of that right now remember

1471
00:48:52,480 --> 00:48:55,119
what was that rbp minus

1472
00:48:55,119 --> 00:48:57,839
eight that was our string that we're

1473
00:48:57,839 --> 00:49:00,880
gonna write out to the file

1474
00:49:00,960 --> 00:49:03,680
so rcx now completes the address of our

1475
00:49:03,680 --> 00:49:06,480
output variable

1476
00:49:06,640 --> 00:49:11,440
eax now contains our file descriptor

1477
00:49:11,440 --> 00:49:14,240
hexd contains the amount that we're

1478
00:49:14,240 --> 00:49:16,240
going to write out to the file and so

1479
00:49:16,240 --> 00:49:17,680
here we're setting up the stack with all

1480
00:49:17,680 --> 00:49:19,760
the arguments that we need to call right

1481
00:49:19,760 --> 00:49:21,440
so we're setting it up with the file

1482
00:49:21,440 --> 00:49:23,440
descriptor the buffer and the count

1483
00:49:23,440 --> 00:49:26,400
and then we call that we call that

1484
00:49:26,400 --> 00:49:28,800
function

1485
00:49:28,800 --> 00:49:31,040
and so lastly here we're grabbing the

1486
00:49:31,040 --> 00:49:32,800
return value but since

1487
00:49:32,800 --> 00:49:34,400
i wrote very poor c here and didn't

1488
00:49:34,400 --> 00:49:35,680
check the return value we don't do

1489
00:49:35,680 --> 00:49:37,520
anything with it

1490
00:49:37,520 --> 00:49:39,599
but the next thing that we do is we

1491
00:49:39,599 --> 00:49:41,440
again grab our file descriptor which we

1492
00:49:41,440 --> 00:49:43,599
previously stored in rbp minus 14. load

1493
00:49:43,599 --> 00:49:45,359
it into eax

1494
00:49:45,359 --> 00:49:47,599
copy that value into edi and then we

1495
00:49:47,599 --> 00:49:49,920
call close to close the file descriptor

1496
00:49:49,920 --> 00:49:52,880
so this is what file operations look

1497
00:49:52,880 --> 00:49:53,359
like

1498
00:49:53,359 --> 00:49:54,800
when they're translated from you know

1499
00:49:54,800 --> 00:49:57,440
ellipsey function call into assembly and

1500
00:49:57,440 --> 00:49:59,119
again to most of us here they just look

1501
00:49:59,119 --> 00:50:00,880
like regular function calls but i wanted

1502
00:50:00,880 --> 00:50:02,319
to go over syscalls so that you're aware

1503
00:50:02,319 --> 00:50:03,200
of how they

1504
00:50:03,200 --> 00:50:06,880
operate under the hood and so we have an

1505
00:50:06,880 --> 00:50:07,680
exercise

1506
00:50:07,680 --> 00:50:10,319
that again this files exercise builds

1507
00:50:10,319 --> 00:50:10,880
off of

1508
00:50:10,880 --> 00:50:12,319
what you learned in the pointers

1509
00:50:12,319 --> 00:50:14,000
exercise so

1510
00:50:14,000 --> 00:50:16,480
all of the exercises in this lesson

1511
00:50:16,480 --> 00:50:17,680
except for

1512
00:50:17,680 --> 00:50:20,000
the syscall exercise are modified

1513
00:50:20,000 --> 00:50:21,760
versions of the same program so they all

1514
00:50:21,760 --> 00:50:22,880
expand on each other

1515
00:50:22,880 --> 00:50:24,800
so it's going to be important to use

1516
00:50:24,800 --> 00:50:26,720
maybe the function comparison

1517
00:50:26,720 --> 00:50:28,319
feature that we talked about in the last

1518
00:50:28,319 --> 00:50:30,160
section and to you know label your

1519
00:50:30,160 --> 00:50:31,599
database appropriately and create your

1520
00:50:31,599 --> 00:50:33,359
structs because all of that is going to

1521
00:50:33,359 --> 00:50:35,119
carry over into the next

1522
00:50:35,119 --> 00:50:37,760
exercise every time you do an exercise

1523
00:50:37,760 --> 00:50:39,200
so when you're looking at this one

1524
00:50:39,200 --> 00:50:40,640
think about you know what's different

1525
00:50:40,640 --> 00:50:42,400
about it what's it doing differently

1526
00:50:42,400 --> 00:50:44,079
are there file operations being

1527
00:50:44,079 --> 00:50:46,319
performed what file operations are being

1528
00:50:46,319 --> 00:50:46,880
performed

1529
00:50:46,880 --> 00:50:49,599
and can we provide what it's looking for

1530
00:50:49,599 --> 00:50:50,319
in

1531
00:50:50,319 --> 00:50:52,240
said files and again this is going to be

1532
00:50:52,240 --> 00:50:54,000
very similar to the struct

1533
00:50:54,000 --> 00:50:58,160
and pointer exercise so

1534
00:50:59,119 --> 00:51:01,040
now that we've kind of gone over some of

1535
00:51:01,040 --> 00:51:02,480
these

1536
00:51:02,480 --> 00:51:04,880
lower level c functions and how they're

1537
00:51:04,880 --> 00:51:06,480
going to play into the exercises i

1538
00:51:06,480 --> 00:51:08,079
wanted to go through just a few

1539
00:51:08,079 --> 00:51:09,920
quick you know deidre tips that you guys

1540
00:51:09,920 --> 00:51:11,920
can use as you're doing

1541
00:51:11,920 --> 00:51:14,079
you know these these exercises and some

1542
00:51:14,079 --> 00:51:15,200
of these are based on things that people

1543
00:51:15,200 --> 00:51:15,920
have asked for

1544
00:51:15,920 --> 00:51:17,200
so we're going to talk really quickly

1545
00:51:17,200 --> 00:51:18,800
and we've only got a few minutes left

1546
00:51:18,800 --> 00:51:20,240
we're talking about patching

1547
00:51:20,240 --> 00:51:23,760
bookmarks searching and then

1548
00:51:23,760 --> 00:51:25,599
we'll probably save check summing and

1549
00:51:25,599 --> 00:51:27,040
adding additional libraries for the next

1550
00:51:27,040 --> 00:51:28,240
lesson because we're coming up

1551
00:51:28,240 --> 00:51:32,079
close to the hour so binary patching we

1552
00:51:32,079 --> 00:51:33,680
talked about this briefly before

1553
00:51:33,680 --> 00:51:35,680
we started class but you can use gauger

1554
00:51:35,680 --> 00:51:37,200
to patch binary files

1555
00:51:37,200 --> 00:51:40,559
now what this is going to result in is

1556
00:51:40,559 --> 00:51:42,319
you're going to be able to actually

1557
00:51:42,319 --> 00:51:43,839
write you know new assembly and patch it

1558
00:51:43,839 --> 00:51:46,079
to the file the thing is this won't work

1559
00:51:46,079 --> 00:51:48,160
on things like l files and pe files

1560
00:51:48,160 --> 00:51:50,160
unless you use the plugin that we posted

1561
00:51:50,160 --> 00:51:51,440
in chat earlier

1562
00:51:51,440 --> 00:51:53,280
so this works very well for raw firmware

1563
00:51:53,280 --> 00:51:55,119
images because what guidra does when you

1564
00:51:55,119 --> 00:51:57,040
export the program is it writes all the

1565
00:51:57,040 --> 00:51:59,359
memory regions out to the file

1566
00:51:59,359 --> 00:52:01,359
so it's going to essentially write out

1567
00:52:01,359 --> 00:52:03,680
like an entire virtual address space of

1568
00:52:03,680 --> 00:52:06,800
you know an elf file and so that won't

1569
00:52:06,800 --> 00:52:08,800
result obviously in a valid l file

1570
00:52:08,800 --> 00:52:10,559
but someone wrote a plugin to make that

1571
00:52:10,559 --> 00:52:14,240
work and we linked to that in the chat

1572
00:52:14,480 --> 00:52:16,000
so the way you would want to do this

1573
00:52:16,000 --> 00:52:17,280
right is let's say we want to change

1574
00:52:17,280 --> 00:52:18,000
this comparison

1575
00:52:18,000 --> 00:52:20,559
instruction to maybe compare this local

1576
00:52:20,559 --> 00:52:21,599
variable to

1577
00:52:21,599 --> 00:52:23,839
two so we're going to right click it and

1578
00:52:23,839 --> 00:52:25,839
click patch instruction

1579
00:52:25,839 --> 00:52:26,800
and this is going to come up because

1580
00:52:26,800 --> 00:52:28,559
it's actually using you know it's

1581
00:52:28,559 --> 00:52:30,400
constructing the assembler based on

1582
00:52:30,400 --> 00:52:34,720
the slice spec for this processor

1583
00:52:34,720 --> 00:52:36,720
and then now we can just edit the

1584
00:52:36,720 --> 00:52:38,559
instruction as we see fit

1585
00:52:38,559 --> 00:52:40,079
so all we're going to do is just change

1586
00:52:40,079 --> 00:52:41,839
the console it's comparing it to here to

1587
00:52:41,839 --> 00:52:43,200
2.

1588
00:52:43,200 --> 00:52:45,520
and then once we save that back and take

1589
00:52:45,520 --> 00:52:47,520
another look at the decompilation

1590
00:52:47,520 --> 00:52:49,359
we see here that instead of comparing it

1591
00:52:49,359 --> 00:52:50,880
to one which would have previously been

1592
00:52:50,880 --> 00:52:53,040
monday in our previous enum example it's

1593
00:52:53,040 --> 00:52:53,520
now

1594
00:52:53,520 --> 00:52:56,079
tuesday so we've effectively patched

1595
00:52:56,079 --> 00:53:00,640
this binary that way

1596
00:53:00,640 --> 00:53:03,520
and so patching like we said before it

1597
00:53:03,520 --> 00:53:04,640
won't result

1598
00:53:04,640 --> 00:53:06,400
when you're using you know l files exe

1599
00:53:06,400 --> 00:53:07,760
files it won't result in like an

1600
00:53:07,760 --> 00:53:09,119
executable file but if you're doing you

1601
00:53:09,119 --> 00:53:10,559
know a flat firmware image

1602
00:53:10,559 --> 00:53:12,720
it will properly export a flat firmware

1603
00:53:12,720 --> 00:53:14,160
image for you because again it just

1604
00:53:14,160 --> 00:53:15,839
dumps out the address space that it has

1605
00:53:15,839 --> 00:53:18,160
loaded

1606
00:53:18,400 --> 00:53:20,480
and so another you know useful guitar

1607
00:53:20,480 --> 00:53:22,240
tip as you're

1608
00:53:22,240 --> 00:53:24,000
maybe digging through a larger file are

1609
00:53:24,000 --> 00:53:25,280
bookmarks

1610
00:53:25,280 --> 00:53:27,119
so much like you know a pdf or anything

1611
00:53:27,119 --> 00:53:29,200
else you can bookmark addresses and

1612
00:53:29,200 --> 00:53:30,319
locations of interest

1613
00:53:30,319 --> 00:53:32,079
and to see the bookmarks window you can

1614
00:53:32,079 --> 00:53:34,000
just click window bookmarks

1615
00:53:34,000 --> 00:53:36,480
and bookmarks are really useful because

1616
00:53:36,480 --> 00:53:37,920
not only you know they're tied to

1617
00:53:37,920 --> 00:53:39,200
specific addresses but you can

1618
00:53:39,200 --> 00:53:40,640
categorize them as well

1619
00:53:40,640 --> 00:53:42,079
so let's take a look at how we might do

1620
00:53:42,079 --> 00:53:44,240
that so let's say you want to bookmark

1621
00:53:44,240 --> 00:53:45,520
this check for monday

1622
00:53:45,520 --> 00:53:46,720
you just you want to be able to jump

1623
00:53:46,720 --> 00:53:47,680
back to it when you're looking at

1624
00:53:47,680 --> 00:53:48,640
something else

1625
00:53:48,640 --> 00:53:50,240
so we're going to right click here at

1626
00:53:50,240 --> 00:53:52,559
this label and click bookmark

1627
00:53:52,559 --> 00:53:54,400
that brings up this bookmark window

1628
00:53:54,400 --> 00:53:56,000
where you can even add you know a

1629
00:53:56,000 --> 00:53:58,000
category to this bookmark and we'll see

1630
00:53:58,000 --> 00:53:59,520
how that's useful later so if you wanted

1631
00:53:59,520 --> 00:54:01,520
to add a category just call it maybe day

1632
00:54:01,520 --> 00:54:03,839
switch one and then in the description

1633
00:54:03,839 --> 00:54:04,960
you would add

1634
00:54:04,960 --> 00:54:06,400
you know what this bookmark is for so

1635
00:54:06,400 --> 00:54:08,839
you would say like monday check or

1636
00:54:08,839 --> 00:54:10,160
something

1637
00:54:10,160 --> 00:54:12,559
so you could if you wanted to bookmark

1638
00:54:12,559 --> 00:54:13,359
any of the other

1639
00:54:13,359 --> 00:54:14,800
checks you could do it under the same

1640
00:54:14,800 --> 00:54:17,040
category and they would all show up in

1641
00:54:17,040 --> 00:54:19,520
under the same category in the bookmarks

1642
00:54:19,520 --> 00:54:20,240
viewer

1643
00:54:20,240 --> 00:54:22,000
which is kind of nice so when you're

1644
00:54:22,000 --> 00:54:23,119
looking at you know larger things

1645
00:54:23,119 --> 00:54:24,720
especially firmware images it's nice to

1646
00:54:24,720 --> 00:54:26,720
have multiple bookmarks and to have them

1647
00:54:26,720 --> 00:54:30,319
you know appropriately categorized

1648
00:54:30,559 --> 00:54:33,359
so how might you find something you want

1649
00:54:33,359 --> 00:54:34,400
to bookmark right

1650
00:54:34,400 --> 00:54:37,280
you can search in ghidra for all kinds

1651
00:54:37,280 --> 00:54:38,480
of things there's

1652
00:54:38,480 --> 00:54:40,640
you can search for instructions scalars

1653
00:54:40,640 --> 00:54:41,760
direct references

1654
00:54:41,760 --> 00:54:44,000
instruction pattern strings and you can

1655
00:54:44,000 --> 00:54:45,040
choose whether you want to

1656
00:54:45,040 --> 00:54:47,760
you know search just program text or you

1657
00:54:47,760 --> 00:54:49,520
know like the listing display or just

1658
00:54:49,520 --> 00:54:50,319
the raw

1659
00:54:50,319 --> 00:54:52,559
values in memory and so we're going to

1660
00:54:52,559 --> 00:54:54,480
do a couple examples of how to do that

1661
00:54:54,480 --> 00:54:57,599
and then that'll be it for today but the

1662
00:54:57,599 --> 00:54:58,720
instruction search

1663
00:54:58,720 --> 00:55:00,720
is really useful if you're looking for a

1664
00:55:00,720 --> 00:55:02,400
specific instruction you can search for

1665
00:55:02,400 --> 00:55:03,440
that with geidra

1666
00:55:03,440 --> 00:55:05,599
if you want to find something that you

1667
00:55:05,599 --> 00:55:07,599
know maybe references and address you

1668
00:55:07,599 --> 00:55:09,119
can search for that using the direct

1669
00:55:09,119 --> 00:55:10,480
references search

1670
00:55:10,480 --> 00:55:12,559
one of the more interesting searches you

1671
00:55:12,559 --> 00:55:14,160
can do is an instruction

1672
00:55:14,160 --> 00:55:16,880
pattern search so if you want to look

1673
00:55:16,880 --> 00:55:18,160
for something that maybe does like a

1674
00:55:18,160 --> 00:55:20,079
move move move compare lea

1675
00:55:20,079 --> 00:55:22,319
move you can search for that exact

1676
00:55:22,319 --> 00:55:24,160
pattern throughout the entire binary and

1677
00:55:24,160 --> 00:55:25,280
guidra will show you

1678
00:55:25,280 --> 00:55:27,200
where it finds instances of those

1679
00:55:27,200 --> 00:55:28,960
patterns and then of course you can

1680
00:55:28,960 --> 00:55:30,559
search just for immediate values if

1681
00:55:30,559 --> 00:55:31,920
you're looking for something specific

1682
00:55:31,920 --> 00:55:33,440
say you're looking for crypto constants

1683
00:55:33,440 --> 00:55:34,480
or what have you

1684
00:55:34,480 --> 00:55:35,520
and then of course you can search for

1685
00:55:35,520 --> 00:55:37,440
defined strings everybody's favorite

1686
00:55:37,440 --> 00:55:38,799
go-to

1687
00:55:38,799 --> 00:55:40,160
so i want to talk about a couple of

1688
00:55:40,160 --> 00:55:41,839
these uh

1689
00:55:41,839 --> 00:55:43,839
search features here and show you how

1690
00:55:43,839 --> 00:55:44,960
you can use them

1691
00:55:44,960 --> 00:55:46,799
in keydrip and again this is all going

1692
00:55:46,799 --> 00:55:48,480
to kind of be based off of the

1693
00:55:48,480 --> 00:55:51,599
that days enum example just so everybody

1694
00:55:51,599 --> 00:55:54,720
knows where we're coming from there

1695
00:55:54,799 --> 00:55:56,480
so let's say we want to look for an

1696
00:55:56,480 --> 00:55:57,839
instruction pattern right

1697
00:55:57,839 --> 00:56:00,319
let's say we know that this comparison

1698
00:56:00,319 --> 00:56:01,520
is switching

1699
00:56:01,520 --> 00:56:03,200
against that enum that we're interested

1700
00:56:03,200 --> 00:56:04,960
in maybe we want to find out if there's

1701
00:56:04,960 --> 00:56:06,400
somewhere else in the program that's

1702
00:56:06,400 --> 00:56:08,240
using the same sequence of assembly

1703
00:56:08,240 --> 00:56:09,520
instructions

1704
00:56:09,520 --> 00:56:11,920
so we can highlight these instructions

1705
00:56:11,920 --> 00:56:13,200
and then click search

1706
00:56:13,200 --> 00:56:14,720
instruction patterns and it brings up

1707
00:56:14,720 --> 00:56:16,240
this window

1708
00:56:16,240 --> 00:56:18,240
and so in this window you can choose

1709
00:56:18,240 --> 00:56:20,240
what things you want to filter on here

1710
00:56:20,240 --> 00:56:22,640
so if you only want to if you only care

1711
00:56:22,640 --> 00:56:23,680
about

1712
00:56:23,680 --> 00:56:25,599
the just these instructions and you

1713
00:56:25,599 --> 00:56:26,880
don't care about what arguments are

1714
00:56:26,880 --> 00:56:27,680
called to them

1715
00:56:27,680 --> 00:56:31,119
you can filter that out here so you can

1716
00:56:31,119 --> 00:56:33,359
either mask the entire column or unmask

1717
00:56:33,359 --> 00:56:35,520
it and you can even see here

1718
00:56:35,520 --> 00:56:38,079
as you remove elements from it these dot

1719
00:56:38,079 --> 00:56:39,200
dots are essentially you know don't

1720
00:56:39,200 --> 00:56:40,559
cares

1721
00:56:40,559 --> 00:56:42,880
and so if we do that and we do it with

1722
00:56:42,880 --> 00:56:45,040
just we keep the valuables we keep the

1723
00:56:45,040 --> 00:56:46,640
variables here

1724
00:56:46,640 --> 00:56:48,400
to be you know the specific ones that

1725
00:56:48,400 --> 00:56:49,760
they were when we called it which

1726
00:56:49,760 --> 00:56:50,880
there's probably not going to be that

1727
00:56:50,880 --> 00:56:51,920
many instances

1728
00:56:51,920 --> 00:56:54,000
of move instructions of this address to

1729
00:56:54,000 --> 00:56:55,920
edi because that's printing

1730
00:56:55,920 --> 00:56:57,839
you know that's adding that's adding the

1731
00:56:57,839 --> 00:56:59,119
address of something we want to print to

1732
00:56:59,119 --> 00:57:00,160
edi

1733
00:57:00,160 --> 00:57:03,119
but if we got rid of all those and we're

1734
00:57:03,119 --> 00:57:04,559
looking for just this sequence of

1735
00:57:04,559 --> 00:57:06,000
instructions and we want to see how many

1736
00:57:06,000 --> 00:57:07,680
times that occurs

1737
00:57:07,680 --> 00:57:09,200
without any of the arguments so this is

1738
00:57:09,200 --> 00:57:10,480
a searching for this sequence of

1739
00:57:10,480 --> 00:57:11,359
instructions

1740
00:57:11,359 --> 00:57:14,559
and ignoring the arguments we see that

1741
00:57:14,559 --> 00:57:15,920
we have it five times

1742
00:57:15,920 --> 00:57:17,599
here right which is exactly how many

1743
00:57:17,599 --> 00:57:20,319
comparison cases happen in our state

1744
00:57:20,319 --> 00:57:23,200
with the so this is a really useful

1745
00:57:23,200 --> 00:57:24,000
feature

1746
00:57:24,000 --> 00:57:26,240
when you're looking for you know maybe

1747
00:57:26,240 --> 00:57:27,280
chunks of code that could have been

1748
00:57:27,280 --> 00:57:29,520
repeated and things like that

1749
00:57:29,520 --> 00:57:32,799
and this editor is also very

1750
00:57:32,799 --> 00:57:37,200
very useful i've used it many times

1751
00:57:37,280 --> 00:57:39,040
and so let's say you want to maybe look

1752
00:57:39,040 --> 00:57:41,440
for x references you want to see

1753
00:57:41,440 --> 00:57:42,559
you know you want to search for

1754
00:57:42,559 --> 00:57:44,400
references to an address or references

1755
00:57:44,400 --> 00:57:45,680
to a certain function

1756
00:57:45,680 --> 00:57:47,599
so you highlight a variable in this case

1757
00:57:47,599 --> 00:57:50,880
we've got the main function highlighted

1758
00:57:50,880 --> 00:57:53,359
we look for direct references and so

1759
00:57:53,359 --> 00:57:54,240
what this is going to do it's going to

1760
00:57:54,240 --> 00:57:55,760
look for direct references of the

1761
00:57:55,760 --> 00:57:56,799
address

1762
00:57:56,799 --> 00:57:59,040
that maine is at right so four zero zero

1763
00:57:59,040 --> 00:58:01,680
five seven d

1764
00:58:01,760 --> 00:58:03,680
so then we see okay yeah i have an

1765
00:58:03,680 --> 00:58:04,799
address for that here and it's

1766
00:58:04,799 --> 00:58:06,000
referenced and it's in

1767
00:58:06,000 --> 00:58:07,359
you know the elf header right so it's

1768
00:58:07,359 --> 00:58:11,359
got the elf symbol here list listed

1769
00:58:12,240 --> 00:58:14,319
and so you can also search you know for

1770
00:58:14,319 --> 00:58:16,000
scalars you can search for strings

1771
00:58:16,000 --> 00:58:17,599
but those are fairly straightforward we

1772
00:58:17,599 --> 00:58:19,359
don't really have to go into that here

1773
00:58:19,359 --> 00:58:20,640
another thing i wanted to kind of walk

1774
00:58:20,640 --> 00:58:22,559
you folks through before we close out

1775
00:58:22,559 --> 00:58:23,040
today

1776
00:58:23,040 --> 00:58:24,960
is how to add you know comments to your

1777
00:58:24,960 --> 00:58:26,400
teacher database

1778
00:58:26,400 --> 00:58:28,799
so you can use these to sort of enhance

1779
00:58:28,799 --> 00:58:30,720
both the listing view and the compiler

1780
00:58:30,720 --> 00:58:32,079
view and there's all kinds of different

1781
00:58:32,079 --> 00:58:33,359
comments and they can be a little

1782
00:58:33,359 --> 00:58:34,559
confusing

1783
00:58:34,559 --> 00:58:36,480
and so to add a comment all you want to

1784
00:58:36,480 --> 00:58:37,760
do is right click the variable

1785
00:58:37,760 --> 00:58:40,480
or the area that you want to add text to

1786
00:58:40,480 --> 00:58:41,839
and click comment or

1787
00:58:41,839 --> 00:58:43,200
just highlight it and press the

1788
00:58:43,200 --> 00:58:45,760
semicolon so let's say we want to

1789
00:58:45,760 --> 00:58:46,880
comment

1790
00:58:46,880 --> 00:58:50,160
above monday here in our

1791
00:58:50,160 --> 00:58:51,599
example program that we've been looking

1792
00:58:51,599 --> 00:58:54,319
at we've got all different types of

1793
00:58:54,319 --> 00:58:55,280
comments pre

1794
00:58:55,280 --> 00:58:59,760
eol post plate etc and so

1795
00:58:59,760 --> 00:59:00,960
the pre comment will show up in the

1796
00:59:00,960 --> 00:59:02,880
decompiler output

1797
00:59:02,880 --> 00:59:04,319
and then the rest of them if we look

1798
00:59:04,319 --> 00:59:07,119
here all show up in the disassembly

1799
00:59:07,119 --> 00:59:07,680
listing

1800
00:59:07,680 --> 00:59:09,200
so we've got a plate comment which you

1801
00:59:09,200 --> 00:59:10,720
can use to maybe you want to

1802
00:59:10,720 --> 00:59:12,240
annotate an entire block and say

1803
00:59:12,240 --> 00:59:14,480
everything from here below is whatever

1804
00:59:14,480 --> 00:59:16,000
and then you've got you know pre-comment

1805
00:59:16,000 --> 00:59:18,000
here before the instruction an end of

1806
00:59:18,000 --> 00:59:20,240
line comment after the instruction

1807
00:59:20,240 --> 00:59:22,160
or after the end of the instruction and

1808
00:59:22,160 --> 00:59:23,760
then a post comment

1809
00:59:23,760 --> 00:59:25,440
one line under the instruction and so

1810
00:59:25,440 --> 00:59:26,880
that's what all those

1811
00:59:26,880 --> 00:59:30,640
different comments look like

1812
00:59:30,640 --> 00:59:33,520
and so to kind of wrap up today i know

1813
00:59:33,520 --> 00:59:34,880
we went through we went through a lot

1814
00:59:34,880 --> 00:59:35,680
again

1815
00:59:35,680 --> 00:59:38,160
so today we talked about how to find

1816
00:59:38,160 --> 00:59:40,000
more constructs in c and how to relate

1817
00:59:40,000 --> 00:59:41,599
those back to the assembly

1818
00:59:41,599 --> 00:59:44,000
and i know we had a question again in

1819
00:59:44,000 --> 00:59:45,599
chat today about you know how important

1820
00:59:45,599 --> 00:59:47,599
is it to lean on the compiler

1821
00:59:47,599 --> 00:59:49,119
versus you know understanding the

1822
00:59:49,119 --> 00:59:51,520
assembly and you really want to be able

1823
00:59:51,520 --> 00:59:51,839
to

1824
00:59:51,839 --> 00:59:53,599
be able to do both because they're like

1825
00:59:53,599 --> 00:59:55,680
i've said this before

1826
00:59:55,680 --> 00:59:56,880
you know stamping on my forehead there

1827
00:59:56,880 --> 00:59:57,920
are going to be times when the

1828
00:59:57,920 --> 00:59:59,520
decompiler isn't going to work for you

1829
00:59:59,520 --> 01:00:01,119
and you're going to need to know

1830
01:00:01,119 --> 01:00:04,079
the underlying assembly constructs to

1831
01:00:04,079 --> 01:00:05,920
make sense of the code

1832
01:00:05,920 --> 01:00:08,000
and so we also kind of went over a few

1833
01:00:08,000 --> 01:00:09,680
more guidra tips to make the process

1834
01:00:09,680 --> 01:00:11,200
more streamlined and how to

1835
01:00:11,200 --> 01:00:12,720
maybe assist you folks with doing the

1836
01:00:12,720 --> 01:00:14,160
exercises because a lot of people seem

1837
01:00:14,160 --> 01:00:15,599
to enjoy that we did it during the

1838
01:00:15,599 --> 01:00:16,960
office hour

1839
01:00:16,960 --> 01:00:19,680
and lastly the exercises for this course

1840
01:00:19,680 --> 01:00:20,640
are

1841
01:00:20,640 --> 01:00:23,920
up on the github page so thanks

1842
01:00:23,920 --> 01:00:24,640
everybody

1843
01:00:24,640 --> 01:00:26,480
for for showing up to this last one i

1844
01:00:26,480 --> 01:00:28,319
know is a lot of info i'm going to open

1845
01:00:28,319 --> 01:00:29,680
the chat real quick

1846
01:00:29,680 --> 01:00:31,920
and stop sharing my screen and just see

1847
01:00:31,920 --> 01:00:40,480
if there's

