1
00:00:00,000 --> 00:00:06,660
[Music]

2
00:00:07,520 --> 00:00:09,360
welcome back uh this is our

3
00:00:09,360 --> 00:00:12,639
final session apparently wow this was uh

4
00:00:12,639 --> 00:00:16,000
like i remember we started and like dug

5
00:00:16,000 --> 00:00:17,600
into the dash sheet and

6
00:00:17,600 --> 00:00:20,240
everyone and everything and wow finally

7
00:00:20,240 --> 00:00:21,439
suddenly

8
00:00:21,439 --> 00:00:23,840
we reached to the end um today is going

9
00:00:23,840 --> 00:00:24,480
to be

10
00:00:24,480 --> 00:00:27,920
a bit less intense than the usual um

11
00:00:27,920 --> 00:00:31,599
and let me share my screen and

12
00:00:31,599 --> 00:00:35,680
then you will let me know if you can uh

13
00:00:35,680 --> 00:00:38,719
what happens here okay so screen sharing

14
00:00:38,719 --> 00:00:39,360
on

15
00:00:39,360 --> 00:00:41,840
you should be seeing the screen with the

16
00:00:41,840 --> 00:00:42,879
document

17
00:00:42,879 --> 00:00:44,800
the standard document that we use every

18
00:00:44,800 --> 00:00:46,160
week so

19
00:00:46,160 --> 00:00:49,360
i will open the chat and let's see can

20
00:00:49,360 --> 00:00:51,680
you see my screen hey nekari

21
00:00:51,680 --> 00:00:54,719
good to see you here um yeah mikhail

22
00:00:54,719 --> 00:00:56,559
says okay mikhail usually you have

23
00:00:56,559 --> 00:00:58,160
issues with the sound does it work

24
00:00:58,160 --> 00:01:01,359
good today do you hear me it's all well

25
00:01:01,359 --> 00:01:04,960
um okay

26
00:01:05,360 --> 00:01:08,560
oh perfect thank you um

27
00:01:08,560 --> 00:01:11,280
all right so um the first thing we are

28
00:01:11,280 --> 00:01:12,320
going to do

29
00:01:12,320 --> 00:01:15,439
uh there is uh the final project

30
00:01:15,439 --> 00:01:18,640
that um we will uh some of you

31
00:01:18,640 --> 00:01:20,560
uh those of you who want to get the

32
00:01:20,560 --> 00:01:21,920
certificate uh

33
00:01:21,920 --> 00:01:24,960
will have to work on it and uh it's

34
00:01:24,960 --> 00:01:26,799
the deadline is at the end of march

35
00:01:26,799 --> 00:01:28,000
march 31

36
00:01:28,000 --> 00:01:30,240
and i was really happy to see that some

37
00:01:30,240 --> 00:01:31,759
people have already started

38
00:01:31,759 --> 00:01:35,759
uh working on it um so today the audio

39
00:01:35,759 --> 00:01:38,000
is broken for justin i hope uh

40
00:01:38,000 --> 00:01:41,920
it's not for everyone just for justin

41
00:01:41,920 --> 00:01:45,920
um so um

42
00:01:45,920 --> 00:01:48,240
there is like a lot of discussion you

43
00:01:48,240 --> 00:01:50,399
can see here the discord the avr

44
00:01:50,399 --> 00:01:52,479
internals channel so people are asking

45
00:01:52,479 --> 00:01:53,119
questions

46
00:01:53,119 --> 00:01:55,200
and starting to work under projects and

47
00:01:55,200 --> 00:01:57,520
that's great um i love seeing your

48
00:01:57,520 --> 00:01:58,159
question

49
00:01:58,159 --> 00:02:01,520
and i try to help as much as i can

50
00:02:01,520 --> 00:02:04,960
um and i think one other

51
00:02:04,960 --> 00:02:07,119
point which i really liked is to see how

52
00:02:07,119 --> 00:02:09,199
people are already using gdp

53
00:02:09,199 --> 00:02:11,038
that we learned about in the last

54
00:02:11,038 --> 00:02:13,920
session so they're using gdb to debug

55
00:02:13,920 --> 00:02:14,800
their code and

56
00:02:14,800 --> 00:02:17,040
understand what's wrong which is really

57
00:02:17,040 --> 00:02:18,800
i love seeing this so thank you for

58
00:02:18,800 --> 00:02:19,360
sharing

59
00:02:19,360 --> 00:02:21,680
um what you're doing and your progress

60
00:02:21,680 --> 00:02:22,959
with me

61
00:02:22,959 --> 00:02:26,560
um and uh

62
00:02:26,560 --> 00:02:30,000
we did like this gdp last time and um

63
00:02:30,000 --> 00:02:33,200
some people wanted to know how i got gdp

64
00:02:33,200 --> 00:02:34,800
to work in the browser so

65
00:02:34,800 --> 00:02:37,120
i spent a week running writing a blog

66
00:02:37,120 --> 00:02:38,480
post about it

67
00:02:38,480 --> 00:02:40,239
so this is the blog post we are not

68
00:02:40,239 --> 00:02:41,840
going to read it now but

69
00:02:41,840 --> 00:02:44,640
i will share the link if you want to uh

70
00:02:44,640 --> 00:02:45,599
have a look later

71
00:02:45,599 --> 00:02:50,080
so um you can see how it was done

72
00:02:50,080 --> 00:02:53,040
behind the scenes let me just close this

73
00:02:53,040 --> 00:02:55,760
chord otherwise i will get distracted

74
00:02:55,760 --> 00:02:59,920
um okay and um

75
00:02:59,920 --> 00:03:02,959
one final uh we can close this as well

76
00:03:02,959 --> 00:03:07,040
one final uh update um some new feature

77
00:03:07,040 --> 00:03:09,840
uh that will be probably useful for you

78
00:03:09,840 --> 00:03:10,239
so

79
00:03:10,239 --> 00:03:13,440
uh before if you had an issue with the

80
00:03:13,440 --> 00:03:16,319
assembly code in walkway i'll it's like

81
00:03:16,319 --> 00:03:17,599
right

82
00:03:17,599 --> 00:03:21,599
a test function so test and just

83
00:03:21,599 --> 00:03:24,640
returns so if we run this code it

84
00:03:24,640 --> 00:03:25,760
compiles and

85
00:03:25,760 --> 00:03:28,239
everything is fine great but if we add

86
00:03:28,239 --> 00:03:29,920
an error like

87
00:03:29,920 --> 00:03:33,200
hello which is an invalid up code uh we

88
00:03:33,200 --> 00:03:33,680
would

89
00:03:33,680 --> 00:03:36,159
we had to open the console to see that

90
00:03:36,159 --> 00:03:37,040
and uh

91
00:03:37,040 --> 00:03:39,920
starting from uh yesterday it actually

92
00:03:39,920 --> 00:03:42,400
shows that in the editor the error so

93
00:03:42,400 --> 00:03:45,519
um something useful for you and if while

94
00:03:45,519 --> 00:03:47,280
working on the project you see

95
00:03:47,280 --> 00:03:49,360
that there is some feature that will

96
00:03:49,360 --> 00:03:51,599
make your life easier just let me know

97
00:03:51,599 --> 00:03:54,480
um and i will do my best to edit like i

98
00:03:54,480 --> 00:03:55,120
did

99
00:03:55,120 --> 00:03:59,040
like i did here um so that's about

100
00:03:59,040 --> 00:04:02,080
uh what's uh new and

101
00:04:02,080 --> 00:04:06,000
um one uh comment that i received

102
00:04:06,000 --> 00:04:09,360
uh last since last week i think it's

103
00:04:09,360 --> 00:04:09,840
here

104
00:04:09,840 --> 00:04:14,640
mikhail said that uh he needed some uh

105
00:04:14,640 --> 00:04:17,120
information about the register versus io

106
00:04:17,120 --> 00:04:18,320
space registers

107
00:04:18,320 --> 00:04:21,680
in and out instructions and uh i'm going

108
00:04:21,680 --> 00:04:22,720
to resolve it

109
00:04:22,720 --> 00:04:25,759
uh i actually remove this suggestion but

110
00:04:25,759 --> 00:04:29,040
i'm going to just implement it um so

111
00:04:29,040 --> 00:04:31,600
uh some people who already started

112
00:04:31,600 --> 00:04:32,960
working on their projects

113
00:04:32,960 --> 00:04:36,320
asked me about this as well um so that's

114
00:04:36,320 --> 00:04:39,040
what we are going to start with today

115
00:04:39,040 --> 00:04:42,160
um learning about the um

116
00:04:42,160 --> 00:04:46,560
io the register i o register space

117
00:04:46,560 --> 00:04:49,520
of the avr so let's go back to the data

118
00:04:49,520 --> 00:04:51,280
sheet and there is this nice section

119
00:04:51,280 --> 00:04:53,440
about the avr memories

120
00:04:53,440 --> 00:04:56,720
and uh we visited it in the first

121
00:04:56,720 --> 00:04:59,759
session when we talked about um the

122
00:04:59,759 --> 00:05:00,880
program memory

123
00:05:00,880 --> 00:05:05,199
versus uh the data space um

124
00:05:05,199 --> 00:05:07,520
but uh i think we mentioned that there

125
00:05:07,520 --> 00:05:08,479
is also

126
00:05:08,479 --> 00:05:12,080
an ios register space but we'll

127
00:05:12,080 --> 00:05:15,039
get into it later so now this is that

128
00:05:15,039 --> 00:05:15,520
later

129
00:05:15,520 --> 00:05:19,280
now we are going to get into it and um

130
00:05:19,280 --> 00:05:21,680
there is this data memory map which

131
00:05:21,680 --> 00:05:22,479
tells us

132
00:05:22,479 --> 00:05:26,000
how the um data address space

133
00:05:26,000 --> 00:05:28,960
is uh what it looks like like how it's

134
00:05:28,960 --> 00:05:30,400
split into regions

135
00:05:30,400 --> 00:05:32,720
so you can see there is uh these 32

136
00:05:32,720 --> 00:05:34,240
registers at the beginning

137
00:05:34,240 --> 00:05:36,479
and we'll talk about that in a moment

138
00:05:36,479 --> 00:05:37,680
then there are like those

139
00:05:37,680 --> 00:05:41,600
64 i o registers 116

140
00:05:41,600 --> 00:05:45,199
extended i registers and only then at

141
00:05:45,199 --> 00:05:48,160
under at 100 hexa this is where the

142
00:05:48,160 --> 00:05:50,160
internal sram is mapped

143
00:05:50,160 --> 00:05:53,039
so uh whenever we declare a global

144
00:05:53,039 --> 00:05:53,840
variable

145
00:05:53,840 --> 00:05:56,240
it will only start it will always start

146
00:05:56,240 --> 00:05:58,080
after this address because

147
00:05:58,080 --> 00:06:01,199
this is like these are the addresses

148
00:06:01,199 --> 00:06:04,560
in the data space that are um reserved

149
00:06:04,560 --> 00:06:05,199
for the

150
00:06:05,199 --> 00:06:07,919
registers and i or registers so for

151
00:06:07,919 --> 00:06:08,560
instance

152
00:06:08,560 --> 00:06:11,600
uh port the ddrd and all of those

153
00:06:11,600 --> 00:06:14,800
are either uh in this place or that

154
00:06:14,800 --> 00:06:16,000
place like they are

155
00:06:16,000 --> 00:06:18,800
specifically the um port ones are in

156
00:06:18,800 --> 00:06:19,280
this

157
00:06:19,280 --> 00:06:23,440
uh first uh bank of 64 i registers but

158
00:06:23,440 --> 00:06:26,400
other like i think timer one registers

159
00:06:26,400 --> 00:06:27,520
for instance are

160
00:06:27,520 --> 00:06:31,600
here um and there is an interesting

161
00:06:31,600 --> 00:06:34,960
thing those 64 io registers

162
00:06:34,960 --> 00:06:36,960
they can be accessed in two different

163
00:06:36,960 --> 00:06:38,400
ways so

164
00:06:38,400 --> 00:06:41,759
um we can access them with uh

165
00:06:41,759 --> 00:06:45,199
the like this using this

166
00:06:45,199 --> 00:06:49,360
data address space or we can use very sp

167
00:06:49,360 --> 00:06:52,080
specific instructions that access them

168
00:06:52,080 --> 00:06:54,000
using a different address space

169
00:06:54,000 --> 00:06:57,599
so here their address is always uh

170
00:06:57,599 --> 00:07:00,800
the addresses starts from 20 extra but

171
00:07:00,800 --> 00:07:03,599
if we look at the i o memory we can see

172
00:07:03,599 --> 00:07:03,919
that

173
00:07:03,919 --> 00:07:06,960
uh this paragraph explains it all

174
00:07:06,960 --> 00:07:09,840
basically it says that uh all blah blah

175
00:07:09,840 --> 00:07:11,919
all the i o and peripherals are placed

176
00:07:11,919 --> 00:07:13,759
in the io space

177
00:07:13,759 --> 00:07:16,080
and all the i o locations can be

178
00:07:16,080 --> 00:07:19,199
accessed by ld lds we already know lds

179
00:07:19,199 --> 00:07:22,720
and sdsds instructions transferring data

180
00:07:22,720 --> 00:07:23,280
between

181
00:07:23,280 --> 00:07:25,840
32 general purpose working registers so

182
00:07:25,840 --> 00:07:27,520
r0 to r31

183
00:07:27,520 --> 00:07:30,160
and the i o space so we can use the same

184
00:07:30,160 --> 00:07:32,000
instructions as we use to

185
00:07:32,000 --> 00:07:35,280
access uh the data space but

186
00:07:35,280 --> 00:07:39,440
those spatial registers only the first

187
00:07:39,440 --> 00:07:43,199
32 ones are

188
00:07:43,199 --> 00:07:46,160
also directly bit accessible using those

189
00:07:46,160 --> 00:07:47,759
two spatial instruction

190
00:07:47,759 --> 00:07:50,879
sbi and cbi set bit i o

191
00:07:50,879 --> 00:07:52,800
and clear bit i o and we'll see them in

192
00:07:52,800 --> 00:07:55,280
a moment in these registers the value of

193
00:07:55,280 --> 00:07:57,199
the single bit can be checked using

194
00:07:57,199 --> 00:08:00,400
sbis and sbac and

195
00:08:00,400 --> 00:08:02,560
then refer to the instruction set for my

196
00:08:02,560 --> 00:08:03,759
instruction

197
00:08:03,759 --> 00:08:07,039
and then uh if we use uh two specific

198
00:08:07,039 --> 00:08:07,759
instructions

199
00:08:07,759 --> 00:08:10,800
in and out we can even uh

200
00:08:10,800 --> 00:08:13,759
we can use them for all the registers

201
00:08:13,759 --> 00:08:14,479
from

202
00:08:14,479 --> 00:08:17,440
zero to uh three f so that's 64

203
00:08:17,440 --> 00:08:19,360
registers that we can

204
00:08:19,360 --> 00:08:23,440
access using those instructions um

205
00:08:23,440 --> 00:08:25,280
so and then they say when we are

206
00:08:25,280 --> 00:08:27,360
addressing those i registers

207
00:08:27,360 --> 00:08:29,919
using the data space uh using the early

208
00:08:29,919 --> 00:08:31,440
and sd structions

209
00:08:31,440 --> 00:08:34,479
uh we have to add 20 hexa so

210
00:08:34,479 --> 00:08:37,679
uh that's a pretty complex way uh

211
00:08:37,679 --> 00:08:40,880
to say uh the following

212
00:08:40,880 --> 00:08:44,560
basically we have

213
00:08:44,560 --> 00:08:47,680
many i o registers and then

214
00:08:47,680 --> 00:08:50,800
first 64 io registers

215
00:08:50,800 --> 00:08:54,720
can be accessed in two different

216
00:08:54,720 --> 00:08:57,760
ways so we can access them using the

217
00:08:57,760 --> 00:08:59,279
data space so that's

218
00:08:59,279 --> 00:09:03,760
lds sds etc or we can access them using

219
00:09:03,760 --> 00:09:07,279
i or register space instructions

220
00:09:07,279 --> 00:09:10,240
and there are exactly uh i think foreign

221
00:09:10,240 --> 00:09:12,880
six instructions so in and out which are

222
00:09:12,880 --> 00:09:14,959
like the most popular ones

223
00:09:14,959 --> 00:09:17,920
and then there is uh also uh i think

224
00:09:17,920 --> 00:09:19,279
they mentioned here uh

225
00:09:19,279 --> 00:09:24,000
sb is cbi and sbis sbic

226
00:09:24,000 --> 00:09:27,680
sbi cbi sb is

227
00:09:27,680 --> 00:09:30,959
sbac and those ones can

228
00:09:30,959 --> 00:09:34,560
access all 64 and those only

229
00:09:34,560 --> 00:09:38,560
first 32 and it's pretty arbitrary so

230
00:09:38,560 --> 00:09:40,640
uh you know just consult the data sheet

231
00:09:40,640 --> 00:09:43,200
to remember what can be accessed

232
00:09:43,200 --> 00:09:46,320
um and then if you need uh

233
00:09:46,320 --> 00:09:49,120
any of the remaining i registers you can

234
00:09:49,120 --> 00:09:50,080
only access them

235
00:09:50,080 --> 00:09:53,120
this way so uh

236
00:09:53,120 --> 00:09:56,240
if you just write code you don't need to

237
00:09:56,240 --> 00:09:57,120
care about this

238
00:09:57,120 --> 00:09:59,440
you can just use this always and it will

239
00:09:59,440 --> 00:10:00,560
work you don't

240
00:10:00,560 --> 00:10:03,440
like these extractions they let you do

241
00:10:03,440 --> 00:10:05,200
something that you already can do with

242
00:10:05,200 --> 00:10:06,880
the other instructions

243
00:10:06,880 --> 00:10:10,320
but i if i'm not mistaken uh let let's

244
00:10:10,320 --> 00:10:12,079
check the do i have the instruction

245
00:10:12,079 --> 00:10:13,600
manual so

246
00:10:13,600 --> 00:10:17,120
for instance lds uh takes

247
00:10:17,120 --> 00:10:20,240
two cycles and let's check about in i'm

248
00:10:20,240 --> 00:10:20,959
not sure

249
00:10:20,959 --> 00:10:23,920
uh in which is reading from an io

250
00:10:23,920 --> 00:10:24,720
register

251
00:10:24,720 --> 00:10:27,839
um where is it in um

252
00:10:27,839 --> 00:10:30,959
so in takes only one cycle so it's

253
00:10:30,959 --> 00:10:32,000
faster so

254
00:10:32,000 --> 00:10:34,640
if you want to uh take advantage of

255
00:10:34,640 --> 00:10:35,839
those in

256
00:10:35,839 --> 00:10:38,880
registers of those function faster

257
00:10:38,880 --> 00:10:39,839
instructions then

258
00:10:39,839 --> 00:10:42,399
uh you can use them but they are totally

259
00:10:42,399 --> 00:10:43,279
optional

260
00:10:43,279 --> 00:10:45,279
and i think for starters let's see what

261
00:10:45,279 --> 00:10:46,560
happens when we

262
00:10:46,560 --> 00:10:50,320
um just do something like that in c

263
00:10:50,320 --> 00:10:53,519
so if we set a port d to

264
00:10:53,519 --> 00:10:56,720
uh ff that will turn on all the

265
00:10:56,720 --> 00:11:01,519
leds and if we look at the disassembly

266
00:11:01,519 --> 00:11:05,200
uh view compile the assembly code

267
00:11:05,200 --> 00:11:06,320
listing

268
00:11:06,320 --> 00:11:10,000
and we look at uh so we can see that

269
00:11:10,000 --> 00:11:12,640
the compiler generated an out

270
00:11:12,640 --> 00:11:14,240
instruction for us

271
00:11:14,240 --> 00:11:17,519
so uh this is the equivalent code so

272
00:11:17,519 --> 00:11:20,000
the compiler uses the out instruction

273
00:11:20,000 --> 00:11:21,279
because it knows it's

274
00:11:21,279 --> 00:11:24,800
uh it runs faster um and

275
00:11:24,800 --> 00:11:28,240
let's just uh you know uh c

276
00:11:28,240 --> 00:11:31,519
what uh call test this is c so let's

277
00:11:31,519 --> 00:11:32,720
call our function

278
00:11:32,720 --> 00:11:35,760
and uh we need to declare it so x turn

279
00:11:35,760 --> 00:11:40,160
c test so that's our assembly function

280
00:11:40,160 --> 00:11:43,040
and then um we can copy those

281
00:11:43,040 --> 00:11:44,000
instructions

282
00:11:44,000 --> 00:11:48,000
um just copy this value

283
00:11:48,000 --> 00:11:52,000
so this is one way to do it with out

284
00:11:52,000 --> 00:11:54,079
um this is blinking by the way because

285
00:11:54,079 --> 00:11:56,240
of the loop let's remove it so

286
00:11:56,240 --> 00:11:59,440
it doesn't confuse us okay perfect so

287
00:11:59,440 --> 00:12:02,720
um yeah so that's one way to do it um

288
00:12:02,720 --> 00:12:06,160
and then if we wanted to use um sds

289
00:12:06,160 --> 00:12:09,279
just to write r24 to the data space we

290
00:12:09,279 --> 00:12:10,720
can do sts

291
00:12:10,720 --> 00:12:14,079
and then just add 20 hexa and we get the

292
00:12:14,079 --> 00:12:15,680
same result

293
00:12:15,680 --> 00:12:18,560
actually we don't have to remember those

294
00:12:18,560 --> 00:12:18,959
uh

295
00:12:18,959 --> 00:12:22,079
addresses we can use this um

296
00:12:22,079 --> 00:12:25,200
there is um a header file

297
00:12:25,200 --> 00:12:29,200
avr slash io.h which already defines so

298
00:12:29,200 --> 00:12:29,920
this was

299
00:12:29,920 --> 00:12:33,279
uh port b right no poor d

300
00:12:33,279 --> 00:12:36,079
so we can write port d instead of uh

301
00:12:36,079 --> 00:12:36,480
this

302
00:12:36,480 --> 00:12:40,240
address so port d is just uh

303
00:12:40,240 --> 00:12:43,680
24 hex hour how much was that 24

304
00:12:43,680 --> 00:12:47,279
i don't remember 20 bx so to report b

305
00:12:47,279 --> 00:12:49,680
is 20 b extra and you can see that it

306
00:12:49,680 --> 00:12:50,560
works

307
00:12:50,560 --> 00:12:52,480
um but if you try to do something like

308
00:12:52,480 --> 00:12:53,920
this it won't work

309
00:12:53,920 --> 00:12:57,120
because part d can only contain one

310
00:12:57,120 --> 00:12:58,160
value and that's

311
00:12:58,160 --> 00:13:01,360
uh by convention it's the value of the

312
00:13:01,360 --> 00:13:03,600
data address space so you could do

313
00:13:03,600 --> 00:13:04,480
something

314
00:13:04,480 --> 00:13:07,680
like this which would work or you can

315
00:13:07,680 --> 00:13:08,079
use

316
00:13:08,079 --> 00:13:10,399
uh the best the the recommended way is

317
00:13:10,399 --> 00:13:11,440
to use this

318
00:13:11,440 --> 00:13:14,959
uh cryptic macro that just does it for

319
00:13:14,959 --> 00:13:15,360
you

320
00:13:15,360 --> 00:13:19,839
so oh ah

321
00:13:19,920 --> 00:13:23,360
why did they mess it up somehow um

322
00:13:23,360 --> 00:13:26,160
that was

323
00:13:26,480 --> 00:13:29,360
let me google that

324
00:13:29,920 --> 00:13:33,360
oh i owe note id right i owe other

325
00:13:33,360 --> 00:13:36,560
thanks um yeah

326
00:13:36,560 --> 00:13:39,040
and yeah you can see that now it works

327
00:13:39,040 --> 00:13:39,760
so

328
00:13:39,760 --> 00:13:43,120
uh just uh to summarize if you want to

329
00:13:43,120 --> 00:13:43,519
use

330
00:13:43,519 --> 00:13:46,839
any of those instructions uh you can use

331
00:13:46,839 --> 00:13:50,560
um you can use this macro

332
00:13:50,560 --> 00:13:53,680
and if you just want to access port d or

333
00:13:53,680 --> 00:13:55,199
any other io register

334
00:13:55,199 --> 00:13:58,320
of using the data space just use it as

335
00:13:58,320 --> 00:14:00,959
is without this macro

336
00:14:00,959 --> 00:14:02,720
and let's take a look at those

337
00:14:02,720 --> 00:14:04,160
instructions uh

338
00:14:04,160 --> 00:14:08,240
sbi and cbi or first of all out is just

339
00:14:08,240 --> 00:14:11,519
to write a value from a register into

340
00:14:11,519 --> 00:14:14,079
an i o register so for instance to set

341
00:14:14,079 --> 00:14:15,519
the value of a pin

342
00:14:15,519 --> 00:14:17,920
and then in does the opposite it reads

343
00:14:17,920 --> 00:14:19,839
so you can like

344
00:14:19,839 --> 00:14:23,040
read the value of one of those pins

345
00:14:23,040 --> 00:14:26,639
from the pnd register

346
00:14:26,720 --> 00:14:30,399
and let's take a look at sbi

347
00:14:30,399 --> 00:14:33,120
and i think cbi as well they are also

348
00:14:33,120 --> 00:14:34,480
very useful

349
00:14:34,480 --> 00:14:38,399
so uh where is sbi not this one set beat

350
00:14:38,399 --> 00:14:40,000
in io register

351
00:14:40,000 --> 00:14:42,399
and remember it only works on very

352
00:14:42,399 --> 00:14:44,079
specific registers

353
00:14:44,079 --> 00:14:46,160
if you try to use it with a invalid

354
00:14:46,160 --> 00:14:47,519
address you will get

355
00:14:47,519 --> 00:14:51,279
an error from the assembler

356
00:14:51,680 --> 00:14:54,959
and we can just use

357
00:14:54,959 --> 00:14:58,480
let's make this larger sbi a

358
00:14:58,480 --> 00:15:01,760
b and it basically sets the bit b of the

359
00:15:01,760 --> 00:15:02,959
i o register a

360
00:15:02,959 --> 00:15:06,480
to one so uh we can do it for instance

361
00:15:06,480 --> 00:15:08,880
uh instead of those two commands if we

362
00:15:08,880 --> 00:15:10,160
just wanted to

363
00:15:10,160 --> 00:15:14,639
uh switch on oh and uh what was that

364
00:15:14,639 --> 00:15:17,839
it also takes it takes two cycles

365
00:15:17,839 --> 00:15:20,880
so uh a little bit slower than out

366
00:15:20,880 --> 00:15:22,639
but if we wanted just to switch a

367
00:15:22,639 --> 00:15:24,560
specific pin on let's say

368
00:15:24,560 --> 00:15:27,519
we wanted a number four to go on we

369
00:15:27,519 --> 00:15:28,720
could have used our

370
00:15:28,720 --> 00:15:32,160
sbi and just bit four is pin

371
00:15:32,160 --> 00:15:35,839
four and that saved one instruction

372
00:15:35,839 --> 00:15:39,279
so um this is pretty useful and then

373
00:15:39,279 --> 00:15:41,920
cpi does the opposite it clears the bit

374
00:15:41,920 --> 00:15:44,399
and those two instructions lets you

375
00:15:44,399 --> 00:15:46,240
check the value of a bit and then skip

376
00:15:46,240 --> 00:15:48,399
the next instruction uh we are not going

377
00:15:48,399 --> 00:15:48,800
to

378
00:15:48,800 --> 00:15:51,279
uh talk about them because you can read

379
00:15:51,279 --> 00:15:52,560
in the data sheet they are

380
00:15:52,560 --> 00:15:55,199
sometimes useful but um maybe we'll use

381
00:15:55,199 --> 00:15:55,839
them later

382
00:15:55,839 --> 00:15:58,639
not sure yet so these are like uh the

383
00:15:58,639 --> 00:15:59,839
new instructions

384
00:15:59,839 --> 00:16:04,079
that let you use the um the i o space

385
00:16:04,079 --> 00:16:08,639
um and um i think

386
00:16:08,639 --> 00:16:11,759
uh one more thing i want to uh

387
00:16:11,759 --> 00:16:14,480
to share with you before we uh finish

388
00:16:14,480 --> 00:16:15,600
talking about the i

389
00:16:15,600 --> 00:16:18,959
registers so if we go back to the data

390
00:16:18,959 --> 00:16:19,680
sheet

391
00:16:19,680 --> 00:16:23,040
and look at the um sram data memory

392
00:16:23,040 --> 00:16:25,360
we can see that there are like those 32

393
00:16:25,360 --> 00:16:26,160
registers

394
00:16:26,160 --> 00:16:28,560
at the beginning and these are actually

395
00:16:28,560 --> 00:16:29,600
r0

396
00:16:29,600 --> 00:16:32,880
through r31 so you can also access them

397
00:16:32,880 --> 00:16:33,600
using the

398
00:16:33,600 --> 00:16:36,720
um data memory uh space

399
00:16:36,720 --> 00:16:39,839
so um let me show you something

400
00:16:39,839 --> 00:16:42,720
uh let's write like this uh piece of

401
00:16:42,720 --> 00:16:44,079
code let's say

402
00:16:44,079 --> 00:16:47,759
uh ldir18

403
00:16:47,759 --> 00:16:51,279
so it will have 55 and then move

404
00:16:51,279 --> 00:16:55,440
r22 r18 so uh now we expect uh

405
00:16:55,440 --> 00:16:59,040
our 22 to have um

406
00:16:59,040 --> 00:17:02,399
to have uh 55 hexa

407
00:17:02,399 --> 00:17:05,760
and break break without a debugger will

408
00:17:05,760 --> 00:17:06,799
print it for us

409
00:17:06,799 --> 00:17:09,919
in the console and yeah we can see that

410
00:17:09,919 --> 00:17:13,599
r22 has 55 a hexa but i can

411
00:17:13,599 --> 00:17:16,959
also do the same if i just call sts

412
00:17:16,959 --> 00:17:20,160
and store the value of r18

413
00:17:20,160 --> 00:17:23,039
into location 22 in the data address

414
00:17:23,039 --> 00:17:23,839
space

415
00:17:23,839 --> 00:17:27,119
so let's try that and uh

416
00:17:27,119 --> 00:17:29,360
i'll just clear this console so you can

417
00:17:29,360 --> 00:17:30,240
see that there is

418
00:17:30,240 --> 00:17:33,919
uh no different you can see that r22 has

419
00:17:33,919 --> 00:17:37,440
55 and we can have fun with that like

420
00:17:37,440 --> 00:17:40,720
let's say we want 20 and 21 also just so

421
00:17:40,720 --> 00:17:41,600
you see

422
00:17:41,600 --> 00:17:44,960
so um you can use um like

423
00:17:44,960 --> 00:17:47,520
there is no reason to do that but uh

424
00:17:47,520 --> 00:17:49,039
just so you know that

425
00:17:49,039 --> 00:17:52,720
the uh data space also includes those uh

426
00:17:52,720 --> 00:17:56,559
uh 31 registers that uh usually access

427
00:17:56,559 --> 00:17:59,120
using uh their specific instructions

428
00:17:59,120 --> 00:18:00,640
most of the instructions just

429
00:18:00,640 --> 00:18:02,640
manipulate those registers but you can

430
00:18:02,640 --> 00:18:04,240
also access them

431
00:18:04,240 --> 00:18:06,480
using the data space if you want to so

432
00:18:06,480 --> 00:18:07,919
that's something that is really unique

433
00:18:07,919 --> 00:18:09,520
for avr i don't think

434
00:18:09,520 --> 00:18:11,520
i've seen something similar in other

435
00:18:11,520 --> 00:18:12,720
architectures when

436
00:18:12,720 --> 00:18:15,679
the registers and the sram and

437
00:18:15,679 --> 00:18:17,840
everything is mapped into the same

438
00:18:17,840 --> 00:18:21,120
memory space okay so

439
00:18:21,120 --> 00:18:24,640
um we will now do a

440
00:18:24,640 --> 00:18:28,400
big shift um from talking about

441
00:18:28,400 --> 00:18:31,600
those instructions into talking about

442
00:18:31,600 --> 00:18:34,960
uh how this piece of hardware that you

443
00:18:34,960 --> 00:18:36,960
are going to use for your final project

444
00:18:36,960 --> 00:18:37,679
works

445
00:18:37,679 --> 00:18:39,440
i got some questions from people who

446
00:18:39,440 --> 00:18:41,840
already started so i figured out it

447
00:18:41,840 --> 00:18:44,000
would make sense to spend a few minutes

448
00:18:44,000 --> 00:18:45,039
you know just uh

449
00:18:45,039 --> 00:18:48,960
going over it so uh this is um

450
00:18:48,960 --> 00:18:53,280
a max 7219 uh some kind of chip that

451
00:18:53,280 --> 00:18:54,160
controls

452
00:18:54,160 --> 00:18:57,360
uh seven segments and uh seven segment

453
00:18:57,360 --> 00:18:58,400
displays and

454
00:18:58,400 --> 00:19:02,640
uh led dot matrices and

455
00:19:02,640 --> 00:19:04,640
before we look into the code i want you

456
00:19:04,640 --> 00:19:06,400
to note this

457
00:19:06,400 --> 00:19:09,120
uh chain attribute in the simulator so

458
00:19:09,120 --> 00:19:10,240
usually

459
00:19:10,240 --> 00:19:13,520
those chips are chained together to form

460
00:19:13,520 --> 00:19:17,280
uh larger displays and this is a very

461
00:19:17,280 --> 00:19:18,240
common form

462
00:19:18,240 --> 00:19:20,080
uh if you if you want i can check in the

463
00:19:20,080 --> 00:19:22,000
q a i think i have a physical

464
00:19:22,000 --> 00:19:25,360
uh one that has four segments like here

465
00:19:25,360 --> 00:19:27,440
and the chain says how many segments we

466
00:19:27,440 --> 00:19:29,360
have so i think in your

467
00:19:29,360 --> 00:19:31,440
uh template there are only like two

468
00:19:31,440 --> 00:19:33,280
segments but you can go for

469
00:19:33,280 --> 00:19:37,440
four or six and even 100 if you really

470
00:19:37,440 --> 00:19:38,799
like it works

471
00:19:38,799 --> 00:19:42,160
but let's not get that crazy um so now i

472
00:19:42,160 --> 00:19:43,760
have declared a chain of 10

473
00:19:43,760 --> 00:19:45,760
and let's see how the protocol for this

474
00:19:45,760 --> 00:19:47,840
works so the protocol for this is

475
00:19:47,840 --> 00:19:51,440
just uh spi and the wires are already

476
00:19:51,440 --> 00:19:52,000
connected

477
00:19:52,000 --> 00:19:53,760
so you don't have to worry about it too

478
00:19:53,760 --> 00:19:55,280
much

479
00:19:55,280 --> 00:19:58,080
and if i run it you can see that it

480
00:19:58,080 --> 00:19:58,960
animates

481
00:19:58,960 --> 00:20:01,440
uh but only the four segments and we'll

482
00:20:01,440 --> 00:20:04,960
see the reason for that in a second

483
00:20:05,679 --> 00:20:08,480
so um

484
00:20:09,039 --> 00:20:11,180
um mikhail i will

485
00:20:11,180 --> 00:20:12,960
[Music]

486
00:20:12,960 --> 00:20:15,520
let keep this answer about the vector

487
00:20:15,520 --> 00:20:16,159
table

488
00:20:16,159 --> 00:20:19,200
uh for later but in a short vector table

489
00:20:19,200 --> 00:20:21,200
resides in the program space but not in

490
00:20:21,200 --> 00:20:22,799
the data space

491
00:20:22,799 --> 00:20:25,919
but just ask me in the q a and i will

492
00:20:25,919 --> 00:20:29,440
explain that better anyway so the c code

493
00:20:29,440 --> 00:20:31,520
that controls this and you'll probably

494
00:20:31,520 --> 00:20:33,919
want to do the equivalent with assembly

495
00:20:33,919 --> 00:20:36,400
we first of all initialize the spi

496
00:20:36,400 --> 00:20:38,960
and then we do a bunch of things and i

497
00:20:38,960 --> 00:20:41,360
will actually remove those for a moment

498
00:20:41,360 --> 00:20:44,240
so uh you know just uh to show you the

499
00:20:44,240 --> 00:20:45,280
basics

500
00:20:45,280 --> 00:20:47,840
so uh the first thing that we do we

501
00:20:47,840 --> 00:20:49,919
started transactions whenever we want to

502
00:20:49,919 --> 00:20:51,360
change something here we start

503
00:20:51,360 --> 00:20:54,880
a transaction by setting the cs pin

504
00:20:54,880 --> 00:20:57,919
that's uh pin 10 cs

505
00:20:57,919 --> 00:21:00,960
to low and then uh we

506
00:21:00,960 --> 00:21:04,559
end it here and a transaction now

507
00:21:04,559 --> 00:21:07,679
uh you know we we uh defined the number

508
00:21:07,679 --> 00:21:08,880
of segments so

509
00:21:08,880 --> 00:21:12,000
in this case we have 10 segments um

510
00:21:12,000 --> 00:21:15,200
and the transaction includes uh pieces

511
00:21:15,200 --> 00:21:19,360
are let's call them frames so uh

512
00:21:19,360 --> 00:21:23,120
two bytes per frame or two bytes per

513
00:21:23,120 --> 00:21:24,640
segment so each

514
00:21:24,640 --> 00:21:28,080
uh segments gets uh one chunk of two

515
00:21:28,080 --> 00:21:30,000
bytes so the first two bytes that we

516
00:21:30,000 --> 00:21:31,440
will write that would be

517
00:21:31,440 --> 00:21:36,000
uh what was that spider transfer i think

518
00:21:36,000 --> 00:21:39,039
uh svi dot transfer

519
00:21:39,039 --> 00:21:42,240
um and then um

520
00:21:42,240 --> 00:21:45,440
we we are sending two bytes so the first

521
00:21:45,440 --> 00:21:45,919
byte

522
00:21:45,919 --> 00:21:49,280
is the row address so uh

523
00:21:49,280 --> 00:21:52,799
either first row second row etc so from

524
00:21:52,799 --> 00:21:56,320
uh one to eight it's not zero based it's

525
00:21:56,320 --> 00:21:57,120
one based

526
00:21:57,120 --> 00:22:00,240
so uh if we put here zero it just skips

527
00:22:00,240 --> 00:22:03,440
uh the next byte so let's say we are

528
00:22:03,440 --> 00:22:06,480
uh we want to update row number two

529
00:22:06,480 --> 00:22:09,360
of the first segment and then the second

530
00:22:09,360 --> 00:22:10,400
byte is just

531
00:22:10,400 --> 00:22:13,600
uh which pixels

532
00:22:13,600 --> 00:22:17,360
to light on so if we set it to let's say

533
00:22:17,360 --> 00:22:20,240
ff it will just slide on all the pixels

534
00:22:20,240 --> 00:22:22,000
on the second row let's see that in

535
00:22:22,000 --> 00:22:22,799
action

536
00:22:22,799 --> 00:22:26,000
and we can see it lit all the pixels in

537
00:22:26,000 --> 00:22:28,880
the second row and then the next two

538
00:22:28,880 --> 00:22:30,480
bytes that we send with

539
00:22:30,480 --> 00:22:33,200
spider transfer will actually go to the

540
00:22:33,200 --> 00:22:35,039
next segment so we can

541
00:22:35,039 --> 00:22:37,919
tell it let's say uh we want this time

542
00:22:37,919 --> 00:22:38,720
segment

543
00:22:38,720 --> 00:22:41,760
our number row number four

544
00:22:41,760 --> 00:22:44,880
and we can see that it lit those uh

545
00:22:44,880 --> 00:22:48,159
um leds on row number four and of course

546
00:22:48,159 --> 00:22:50,159
we don't have to use this pattern we can

547
00:22:50,159 --> 00:22:51,120
like use

548
00:22:51,120 --> 00:22:54,480
let's say 81 to light just the

549
00:22:54,480 --> 00:22:57,600
uh extremes and uh

550
00:22:57,600 --> 00:22:59,840
as long as you go like if i just copied

551
00:22:59,840 --> 00:23:01,360
it again and again and again

552
00:23:01,360 --> 00:23:02,960
then you would see the same pattern

553
00:23:02,960 --> 00:23:05,200
repeating on all the segments

554
00:23:05,200 --> 00:23:08,400
but what happens if i want to uh

555
00:23:08,400 --> 00:23:10,640
just update two rows of the first

556
00:23:10,640 --> 00:23:11,520
segment

557
00:23:11,520 --> 00:23:13,600
so basically i can do something like

558
00:23:13,600 --> 00:23:14,720
this let's say

559
00:23:14,720 --> 00:23:16,159
i don't care about the rest of the

560
00:23:16,159 --> 00:23:18,960
segments right now i can just you know

561
00:23:18,960 --> 00:23:22,080
write the first uh uh

562
00:23:22,080 --> 00:23:24,559
the first word that i want to update and

563
00:23:24,559 --> 00:23:26,080
then i can just do

564
00:23:26,080 --> 00:23:29,440
another transaction and um

565
00:23:29,440 --> 00:23:32,080
i can say uh in this second transaction

566
00:23:32,080 --> 00:23:33,919
i will update row number four

567
00:23:33,919 --> 00:23:37,360
and let's set it to 55 just

568
00:23:37,360 --> 00:23:40,480
for an interesting pattern um

569
00:23:40,480 --> 00:23:43,919
and let's say um i wanted to

570
00:23:43,919 --> 00:23:47,600
update uh only segment number four

571
00:23:47,600 --> 00:23:51,360
i could do it um by just you know

572
00:23:51,360 --> 00:23:54,000
sending zeros so for the previous

573
00:23:54,000 --> 00:23:55,200
segment so

574
00:23:55,200 --> 00:23:57,200
the first page should be zero then the

575
00:23:57,200 --> 00:23:59,039
second one can be zero it doesn't really

576
00:23:59,039 --> 00:23:59,919
matter

577
00:23:59,919 --> 00:24:03,440
so uh if i uh send uh

578
00:24:03,440 --> 00:24:06,799
three more groups of

579
00:24:06,799 --> 00:24:10,240
commands so you can see now it updates

580
00:24:10,240 --> 00:24:12,000
segment number four

581
00:24:12,000 --> 00:24:15,120
so to recap each transaction

582
00:24:15,120 --> 00:24:18,400
sends one command per segment and each

583
00:24:18,400 --> 00:24:19,440
of those commands

584
00:24:19,440 --> 00:24:22,480
is two bytes and they update one line

585
00:24:22,480 --> 00:24:24,640
and if you want to update multiple lines

586
00:24:24,640 --> 00:24:26,080
then you need to issue

587
00:24:26,080 --> 00:24:29,360
multiple transactions and if you want to

588
00:24:29,360 --> 00:24:32,400
uh just uh

589
00:24:32,400 --> 00:24:34,480
change a specific segment then you can

590
00:24:34,480 --> 00:24:37,120
send zeros all the way to that segment

591
00:24:37,120 --> 00:24:39,120
and that's basically how this piece of

592
00:24:39,120 --> 00:24:40,799
hardware works

593
00:24:40,799 --> 00:24:43,760
and um one more important note about a

594
00:24:43,760 --> 00:24:46,240
simulator um

595
00:24:46,240 --> 00:24:50,080
so um in the simulator if you

596
00:24:50,080 --> 00:24:53,120
use spi it works but if you don't use

597
00:24:53,120 --> 00:24:53,840
sbi

598
00:24:53,840 --> 00:24:56,480
and you start to you try to bring back

599
00:24:56,480 --> 00:24:57,760
bitbankit

600
00:24:57,760 --> 00:25:01,200
then this uh part doesn't

601
00:25:01,200 --> 00:25:04,559
know yet how to decode uh bit band sbi

602
00:25:04,559 --> 00:25:07,440
it will probably be fixed in a few weeks

603
00:25:07,440 --> 00:25:07,840
but

604
00:25:07,840 --> 00:25:10,960
right now it doesn't so um when you do

605
00:25:10,960 --> 00:25:11,919
your project

606
00:25:11,919 --> 00:25:14,240
that just use the hardware sbi

607
00:25:14,240 --> 00:25:15,039
peripheral

608
00:25:15,039 --> 00:25:17,760
of the atmega and i think it's like a

609
00:25:17,760 --> 00:25:18,159
good

610
00:25:18,159 --> 00:25:21,919
uh opportunity to see how you can

611
00:25:21,919 --> 00:25:24,720
get along with the datasheet and you see

612
00:25:24,720 --> 00:25:25,760
there are like

613
00:25:25,760 --> 00:25:28,799
all the registers here so the

614
00:25:28,799 --> 00:25:32,000
spi is uh not too complex

615
00:25:32,000 --> 00:25:36,640
um so um that's about

616
00:25:36,640 --> 00:25:40,080
this uh max 72 20

617
00:25:40,080 --> 00:25:43,200
19 display and of course if you have any

618
00:25:43,200 --> 00:25:43,760
questions

619
00:25:43,760 --> 00:25:46,080
just uh hit me on the hackaday chat or

620
00:25:46,080 --> 00:25:47,279
discord um

621
00:25:47,279 --> 00:25:50,480
and i will i will be glad to help so

622
00:25:50,480 --> 00:25:53,520
uh this is uh that uh demo by the way

623
00:25:53,520 --> 00:25:57,120
uh you have this link also in the

624
00:25:57,120 --> 00:25:59,840
end of the document here that's the uh

625
00:25:59,840 --> 00:26:01,679
sbi code example

626
00:26:01,679 --> 00:26:04,720
and uh where was that that was here

627
00:26:04,720 --> 00:26:09,039
and if you run it you can see like um

628
00:26:09,039 --> 00:26:12,480
the uh yeah

629
00:26:12,480 --> 00:26:15,679
like th this one uh just uh controls

630
00:26:15,679 --> 00:26:17,840
four segments with a simple animation

631
00:26:17,840 --> 00:26:19,279
that moves one pixel

632
00:26:19,279 --> 00:26:20,799
you can look at the code later if you

633
00:26:20,799 --> 00:26:22,559
like and mario is asking

634
00:26:22,559 --> 00:26:24,159
how we can address the spi with the

635
00:26:24,159 --> 00:26:25,840
assembler the same

636
00:26:25,840 --> 00:26:27,840
way you would address it with c if you

637
00:26:27,840 --> 00:26:29,039
didn't have the spi

638
00:26:29,039 --> 00:26:31,840
library uh you know just write to those

639
00:26:31,840 --> 00:26:33,440
registers there are i think

640
00:26:33,440 --> 00:26:36,880
only three of them for spi uh

641
00:26:36,880 --> 00:26:40,480
like uh spi control spi

642
00:26:40,480 --> 00:26:44,480
data register status and data register

643
00:26:44,480 --> 00:26:47,200
so uh i i think with a little bit of

644
00:26:47,200 --> 00:26:48,000
reading

645
00:26:48,000 --> 00:26:51,679
you should be able to easily

646
00:26:51,679 --> 00:26:54,400
figure out how to use the spi hardware

647
00:26:54,400 --> 00:26:56,159
using these registers

648
00:26:56,159 --> 00:26:59,840
if you like uh feel a bit uncomfortable

649
00:26:59,840 --> 00:27:01,600
with this you can start with

650
00:27:01,600 --> 00:27:03,679
doing it from c like just writing to

651
00:27:03,679 --> 00:27:06,320
these registers from c to see that you

652
00:27:06,320 --> 00:27:07,919
understand the interface and then when

653
00:27:07,919 --> 00:27:10,880
you get it working move to assembler

654
00:27:10,880 --> 00:27:13,360
one more note uh when you have in the

655
00:27:13,360 --> 00:27:15,200
datasheets uh information about the

656
00:27:15,200 --> 00:27:17,039
register you will always see two

657
00:27:17,039 --> 00:27:17,760
addresses

658
00:27:17,760 --> 00:27:20,559
the first one is the i o address or not

659
00:27:20,559 --> 00:27:21,679
always

660
00:27:21,679 --> 00:27:25,039
some of them don't have a register

661
00:27:25,039 --> 00:27:27,440
i register address but if they do you

662
00:27:27,440 --> 00:27:29,840
will see the ir register

663
00:27:29,840 --> 00:27:33,279
space address in

664
00:27:33,279 --> 00:27:34,720
the first one and then the second one

665
00:27:34,720 --> 00:27:36,320
will be the data address space

666
00:27:36,320 --> 00:27:38,559
and there is also the list of all

667
00:27:38,559 --> 00:27:39,679
registers here

668
00:27:39,679 --> 00:27:42,720
and you can see like their uh

669
00:27:42,720 --> 00:27:46,080
io register address and data space

670
00:27:46,080 --> 00:27:47,039
address for

671
00:27:47,039 --> 00:27:49,360
those who have an ir register address

672
00:27:49,360 --> 00:27:52,159
those don't only data space address

673
00:27:52,159 --> 00:27:56,760
um so cool so that was uh the max

674
00:27:56,760 --> 00:28:00,799
7220 and now um

675
00:28:00,799 --> 00:28:03,360
i'm going to move on to the final part

676
00:28:03,360 --> 00:28:04,320
of today's

677
00:28:04,320 --> 00:28:06,720
lesson and we are not going to learn

678
00:28:06,720 --> 00:28:07,360
anything

679
00:28:07,360 --> 00:28:10,480
specific rather we are going to um

680
00:28:10,480 --> 00:28:13,840
oh just before that one more uh thing

681
00:28:13,840 --> 00:28:16,480
uh so this is the template that you will

682
00:28:16,480 --> 00:28:17,120
be using

683
00:28:17,120 --> 00:28:20,559
for your projects uh i have set it with

684
00:28:20,559 --> 00:28:22,799
two buttons so uh they can be used to

685
00:28:22,799 --> 00:28:23,919
move the pedal of

686
00:28:23,919 --> 00:28:27,679
pong and then you have this display with

687
00:28:27,679 --> 00:28:31,919
uh a chain of um uh

688
00:28:31,919 --> 00:28:35,440
this is like uh two where is that yeah

689
00:28:35,440 --> 00:28:38,080
and uh feel free to use more than two if

690
00:28:38,080 --> 00:28:38,880
you want to use

691
00:28:38,880 --> 00:28:41,840
four or eight or whatever to make it

692
00:28:41,840 --> 00:28:43,120
more interesting then

693
00:28:43,120 --> 00:28:45,600
sure go ahead i would love to see what

694
00:28:45,600 --> 00:28:46,399
you do

695
00:28:46,399 --> 00:28:48,480
this is just a suggestion this is not a

696
00:28:48,480 --> 00:28:50,159
constraint

697
00:28:50,159 --> 00:28:52,159
and if you already started working on

698
00:28:52,159 --> 00:28:54,559
this project i just wanted to tell you

699
00:28:54,559 --> 00:28:55,440
that

700
00:28:55,440 --> 00:28:57,760
this is a feature it's not there yet but

701
00:28:57,760 --> 00:28:58,640
it will be there

702
00:28:58,640 --> 00:29:01,360
uh sometime this week where you can

703
00:29:01,360 --> 00:29:02,480
assign a key

704
00:29:02,480 --> 00:29:04,640
a keyboard key to a button so instead of

705
00:29:04,640 --> 00:29:06,559
having to press on them with the mouse

706
00:29:06,559 --> 00:29:08,559
when you play the simulation

707
00:29:08,559 --> 00:29:12,000
you can also just you can just hit the

708
00:29:12,000 --> 00:29:13,360
key on the button

709
00:29:13,360 --> 00:29:15,840
so if you already started you you may

710
00:29:15,840 --> 00:29:17,200
want to copy this

711
00:29:17,200 --> 00:29:19,919
key attribute so uh you will have this

712
00:29:19,919 --> 00:29:20,640
feature too

713
00:29:20,640 --> 00:29:22,320
and then you will be able to control

714
00:29:22,320 --> 00:29:25,360
your point with w and s in the keyboard

715
00:29:25,360 --> 00:29:27,360
and again this is still not working it

716
00:29:27,360 --> 00:29:29,760
will be working sometime this week and

717
00:29:29,760 --> 00:29:31,600
if you want to get an email when it's

718
00:29:31,600 --> 00:29:33,679
ready uh just uh you know

719
00:29:33,679 --> 00:29:37,120
uh on the homepage you can find this

720
00:29:37,120 --> 00:29:40,240
form where you can sign up and i send an

721
00:29:40,240 --> 00:29:42,320
update every week when i

722
00:29:42,320 --> 00:29:46,240
with all the new things with

723
00:29:46,240 --> 00:29:49,360
with all the new things that i added

724
00:29:49,360 --> 00:29:52,840
um okay so

725
00:29:52,840 --> 00:29:55,919
um that's it about uh this

726
00:29:55,919 --> 00:29:58,720
uh dot matrix display and the final

727
00:29:58,720 --> 00:29:59,919
project and these

728
00:29:59,919 --> 00:30:03,440
keys and whatever um and uh

729
00:30:03,440 --> 00:30:06,559
yeah it's exactly the time to move on to

730
00:30:06,559 --> 00:30:08,799
our last mission for today

731
00:30:08,799 --> 00:30:11,360
and our last mission we have this uh

732
00:30:11,360 --> 00:30:14,159
simon game that i wrote long time ago

733
00:30:14,159 --> 00:30:17,679
in arduino and it's a pretty simple game

734
00:30:17,679 --> 00:30:22,480
with uh it's a pretty simple game with

735
00:30:22,480 --> 00:30:26,080
memory and stuff like with like a memory

736
00:30:26,080 --> 00:30:26,720
game

737
00:30:26,720 --> 00:30:32,000
with i think 150 100 lines of code

738
00:30:32,000 --> 00:30:33,279
and the first thing we're going to do

739
00:30:33,279 --> 00:30:36,240
we're going to play the game but before

740
00:30:36,240 --> 00:30:36,640
that

741
00:30:36,640 --> 00:30:38,720
i don't want to get depth so we are

742
00:30:38,720 --> 00:30:39,679
going to

743
00:30:39,679 --> 00:30:42,159
just you know change this uh buzzer

744
00:30:42,159 --> 00:30:43,360
element

745
00:30:43,360 --> 00:30:46,720
and just a moment change the volume

746
00:30:46,720 --> 00:30:49,120
and you want to do this too if you are

747
00:30:49,120 --> 00:30:50,080
playing this game

748
00:30:50,080 --> 00:30:54,320
trust me 2.1 so it's not as loud

749
00:30:54,320 --> 00:30:56,559
and yeah i have this gameplay right now

750
00:30:56,559 --> 00:30:58,159
and it shows me a sequence

751
00:30:58,159 --> 00:31:00,640
i have to repeat the sequence so blue

752
00:31:00,640 --> 00:31:01,600
red

753
00:31:01,600 --> 00:31:05,679
and uh yeah yeah and blue red green

754
00:31:05,679 --> 00:31:08,320
yeah and then if i don't play it

755
00:31:08,320 --> 00:31:08,880
correctly

756
00:31:08,880 --> 00:31:10,640
it also plays sounds but i think you

757
00:31:10,640 --> 00:31:12,880
can't hear them right now

758
00:31:12,880 --> 00:31:14,960
and then if i don't play the sequence

759
00:31:14,960 --> 00:31:17,600
correctly then it says game over

760
00:31:17,600 --> 00:31:20,000
and then it starts all over again it

761
00:31:20,000 --> 00:31:21,279
also plays a said

762
00:31:21,279 --> 00:31:24,000
sound but i don't think you can hear it

763
00:31:24,000 --> 00:31:25,279
tourism

764
00:31:25,279 --> 00:31:28,720
anyways so the goal of today

765
00:31:28,720 --> 00:31:31,919
would be just to ditch all this code and

766
00:31:31,919 --> 00:31:32,559
to try

767
00:31:32,559 --> 00:31:35,519
writing as much as we can from scratch

768
00:31:35,519 --> 00:31:36,559
in assembly

769
00:31:36,559 --> 00:31:38,880
so you will get a feeling of what it is

770
00:31:38,880 --> 00:31:41,840
to write code in assembly from scratch

771
00:31:41,840 --> 00:31:45,120
and um the good

772
00:31:45,120 --> 00:31:47,279
i don't know if it's good or bad news

773
00:31:47,279 --> 00:31:49,279
there is no way we are going to finish

774
00:31:49,279 --> 00:31:50,159
this in like

775
00:31:50,159 --> 00:31:53,360
30 minutes uh it's way too much to write

776
00:31:53,360 --> 00:31:54,640
in 30 minutes

777
00:31:54,640 --> 00:31:57,840
so we are going to uh write a few parts

778
00:31:57,840 --> 00:31:58,559
and then

779
00:31:58,559 --> 00:32:03,760
uh you will have the opportunity to um

780
00:32:03,840 --> 00:32:05,679
i will share with you a link with a

781
00:32:05,679 --> 00:32:07,360
complete game um

782
00:32:07,360 --> 00:32:09,519
at the end so you can check it out or if

783
00:32:09,519 --> 00:32:11,840
you want i even prefer i will

784
00:32:11,840 --> 00:32:15,120
save what we get to here and you can uh

785
00:32:15,120 --> 00:32:18,480
continue hacking it on it on your own

786
00:32:18,480 --> 00:32:21,200
and complete the game just as another

787
00:32:21,200 --> 00:32:22,000
exercise

788
00:32:22,000 --> 00:32:24,159
so let's get started so this time it's

789
00:32:24,159 --> 00:32:25,440
the first time

790
00:32:25,440 --> 00:32:27,600
we are not using any arduino code it's

791
00:32:27,600 --> 00:32:29,279
going to be pure assembly

792
00:32:29,279 --> 00:32:31,200
so the first thing we are going to do we

793
00:32:31,200 --> 00:32:33,760
will just create a new assembly file

794
00:32:33,760 --> 00:32:37,440
simon.s no code remove removed all the

795
00:32:37,440 --> 00:32:38,480
code from the

796
00:32:38,480 --> 00:32:41,760
ino file and

797
00:32:41,760 --> 00:32:45,200
let's declare uh the main function since

798
00:32:45,200 --> 00:32:48,640
uh we no longer uh want to use arduino

799
00:32:48,640 --> 00:32:50,799
we just declare our our own main

800
00:32:50,799 --> 00:32:52,480
function and

801
00:32:52,480 --> 00:32:56,799
basically this means that uh the

802
00:32:56,799 --> 00:32:59,360
uh run time this three run time we'll

803
00:32:59,360 --> 00:33:00,240
just uh

804
00:33:00,240 --> 00:33:03,360
call our main function and there will be

805
00:33:03,360 --> 00:33:04,399
no c code

806
00:33:04,399 --> 00:33:07,360
uh included no setup no loop no need to

807
00:33:07,360 --> 00:33:08,559
worry about it

808
00:33:08,559 --> 00:33:11,360
and let's do main that goes back to main

809
00:33:11,360 --> 00:33:11,760
so

810
00:33:11,760 --> 00:33:14,399
it just endless loop just to see that it

811
00:33:14,399 --> 00:33:16,640
compiles yeah it compiled

812
00:33:16,640 --> 00:33:18,799
and if we check the assembly listing we

813
00:33:18,799 --> 00:33:21,200
can see that it's super minimal now

814
00:33:21,200 --> 00:33:23,039
like there are all those interrupt

815
00:33:23,039 --> 00:33:24,240
vectors and then

816
00:33:24,240 --> 00:33:27,679
some code from the c runtime and this is

817
00:33:27,679 --> 00:33:28,559
our main

818
00:33:28,559 --> 00:33:31,279
so this is all the assembly code that

819
00:33:31,279 --> 00:33:33,200
was generated super minimal

820
00:33:33,200 --> 00:33:36,240
no init no nonsense of this

821
00:33:36,240 --> 00:33:39,279
arduino library just our code by the way

822
00:33:39,279 --> 00:33:40,080
this is like

823
00:33:40,080 --> 00:33:43,200
a four byte instruction jmp

824
00:33:43,200 --> 00:33:46,080
we could change it to a similar but the

825
00:33:46,080 --> 00:33:47,840
shorter instruction

826
00:33:47,840 --> 00:33:50,799
rjmp it doesn't really matter it does

827
00:33:50,799 --> 00:33:51,519
the same

828
00:33:51,519 --> 00:33:55,120
it uh it can address most of the

829
00:33:55,120 --> 00:33:58,640
memory space um and it's only two bytes

830
00:33:58,640 --> 00:34:01,039
so uh we don't have to worry about the

831
00:34:01,039 --> 00:34:01,760
offset the

832
00:34:01,760 --> 00:34:04,240
assembler does this for us so uh we can

833
00:34:04,240 --> 00:34:04,880
use either

834
00:34:04,880 --> 00:34:07,919
just uh this one is a bit shorter and

835
00:34:07,919 --> 00:34:10,800
i wonder if there is a difference in the

836
00:34:10,800 --> 00:34:12,879
um

837
00:34:12,879 --> 00:34:16,399
rgmp in the number of uh cycles so rgmp

838
00:34:16,399 --> 00:34:19,918
is two cycles i guess gmp is also too

839
00:34:19,918 --> 00:34:23,599
jmp is also uh two cycles but let's

840
00:34:23,599 --> 00:34:26,879
check it out so

841
00:34:27,440 --> 00:34:30,560
yeah where are you jmp no jmp is three

842
00:34:30,560 --> 00:34:33,199
cycles so uh it's faster so yeah uh if

843
00:34:33,199 --> 00:34:34,000
you you care about

844
00:34:34,000 --> 00:34:37,520
speed and use rgmp um yeah

845
00:34:37,520 --> 00:34:40,239
so the first thing we are going to do um

846
00:34:40,239 --> 00:34:41,440
we are going to

847
00:34:41,440 --> 00:34:44,320
um do a sanity test just to know uh

848
00:34:44,320 --> 00:34:46,480
first of all let's include this

849
00:34:46,480 --> 00:34:50,639
avr io.a so we can have those constant

850
00:34:50,639 --> 00:34:54,239
and um oh i didn't copy that but we have

851
00:34:54,239 --> 00:34:55,918
this table here somewhere

852
00:34:55,918 --> 00:34:58,320
yeah so this is like the connections

853
00:34:58,320 --> 00:34:59,200
let's just

854
00:34:59,200 --> 00:35:03,200
copy this for a moment so we have uh

855
00:35:03,200 --> 00:35:06,399
yeah we have uh

856
00:35:06,560 --> 00:35:10,560
this reference so uh basically

857
00:35:10,560 --> 00:35:14,160
uh this is uh pd2

858
00:35:14,160 --> 00:35:18,960
pd3 pd4 pd5 we're not going to do the

859
00:35:18,960 --> 00:35:19,599
buzzer

860
00:35:19,599 --> 00:35:22,560
it's just uh

861
00:35:22,800 --> 00:35:26,400
too much work and uh yeah oh that's not

862
00:35:26,400 --> 00:35:29,440
who that's pb one

863
00:35:29,440 --> 00:35:33,200
p b two p b

864
00:35:33,200 --> 00:35:36,800
three p b four yeah these uh these are

865
00:35:36,800 --> 00:35:38,400
the connections so we have them

866
00:35:38,400 --> 00:35:41,440
um as a reference

867
00:35:41,440 --> 00:35:44,480
um and now uh just for sanity let's uh

868
00:35:44,480 --> 00:35:44,960
you know

869
00:35:44,960 --> 00:35:47,599
just uh set all the pins in port b to

870
00:35:47,599 --> 00:35:48,960
output so

871
00:35:48,960 --> 00:35:53,680
uh let's uh ldir18ff

872
00:35:53,680 --> 00:35:57,359
and out to sfrio

873
00:35:57,359 --> 00:36:01,359
adder of port b

874
00:36:01,359 --> 00:36:04,960
r18 uh and we won't see any effect of

875
00:36:04,960 --> 00:36:06,880
this because we just send them to our

876
00:36:06,880 --> 00:36:10,000
output but we can also uh let's set bit

877
00:36:10,000 --> 00:36:11,280
of this

878
00:36:11,280 --> 00:36:14,400
nice thing actually of port b

879
00:36:14,400 --> 00:36:18,320
let's set bit number uh two for instance

880
00:36:18,320 --> 00:36:20,720
and this should light on the blue led

881
00:36:20,720 --> 00:36:23,440
and it works by the way we could have

882
00:36:23,440 --> 00:36:24,240
cheated

883
00:36:24,240 --> 00:36:27,760
and uh we work with assembly but

884
00:36:27,760 --> 00:36:30,400
we still have uh the standard library of

885
00:36:30,400 --> 00:36:32,800
arduino hanging around and we could like

886
00:36:32,800 --> 00:36:34,880
do something like this calling digital

887
00:36:34,880 --> 00:36:38,560
right and passing the pin number so r24

888
00:36:38,560 --> 00:36:41,280
that's the first argument would be

889
00:36:41,280 --> 00:36:43,520
i think the blue one was connected to

890
00:36:43,520 --> 00:36:44,720
pin 10

891
00:36:44,720 --> 00:36:47,839
and r22 that's the second argument one

892
00:36:47,839 --> 00:36:50,720
set it to too high and it would achieve

893
00:36:50,720 --> 00:36:52,000
the same

894
00:36:52,000 --> 00:36:53,760
and it's a bit more convenient because

895
00:36:53,760 --> 00:36:55,200
we use arduino port

896
00:36:55,200 --> 00:36:57,760
pin numbers but you know the digital

897
00:36:57,760 --> 00:36:59,520
right is not very efficient and

898
00:36:59,520 --> 00:37:02,400
that's not our purpose here so please uh

899
00:37:02,400 --> 00:37:04,560
don't use the standard library functions

900
00:37:04,560 --> 00:37:06,960
uh in your solutions just do everything

901
00:37:06,960 --> 00:37:07,680
for struct

902
00:37:07,680 --> 00:37:11,440
from scratch um it may also break

903
00:37:11,440 --> 00:37:13,119
because there are some assumptions in

904
00:37:13,119 --> 00:37:15,119
the standard library like delay won't

905
00:37:15,119 --> 00:37:15,520
work

906
00:37:15,520 --> 00:37:17,520
unless you call the initialization

907
00:37:17,520 --> 00:37:19,520
function which sets up the timers

908
00:37:19,520 --> 00:37:22,079
etc so just don't do it but you know

909
00:37:22,079 --> 00:37:23,200
it's possible

910
00:37:23,200 --> 00:37:27,598
um cool so um

911
00:37:29,040 --> 00:37:32,079
okay so we have this sanity check um

912
00:37:32,079 --> 00:37:34,000
and you know what let's write our first

913
00:37:34,000 --> 00:37:36,160
function uh gpio init

914
00:37:36,160 --> 00:37:39,440
and gpioint will set up the uh this

915
00:37:39,440 --> 00:37:44,480
will do this basically set up the uh

916
00:37:44,800 --> 00:37:48,160
set all leds pins

917
00:37:48,160 --> 00:37:52,560
to output and then

918
00:37:52,560 --> 00:37:56,000
uh set all button bins

919
00:37:56,000 --> 00:37:59,200
to input pull up so by default there are

920
00:37:59,200 --> 00:38:01,119
inputs so we don't need to write

921
00:38:01,119 --> 00:38:05,280
to uh ddrd those pins are input

922
00:38:05,280 --> 00:38:07,760
by default but we want to pull them up

923
00:38:07,760 --> 00:38:09,280
so when the button is done

924
00:38:09,280 --> 00:38:12,320
depressed we will read one uh so

925
00:38:12,320 --> 00:38:15,359
we'll do uh this thing

926
00:38:15,359 --> 00:38:18,400
so we already have this value in r18

927
00:38:18,400 --> 00:38:22,000
so uh we can write it uh to port d

928
00:38:22,000 --> 00:38:24,480
so port d when the pins are in input

929
00:38:24,480 --> 00:38:25,280
mode port d

930
00:38:25,280 --> 00:38:28,320
controls the pull up um when they are in

931
00:38:28,320 --> 00:38:30,400
output mode it controls where it's high

932
00:38:30,400 --> 00:38:32,400
or low and return

933
00:38:32,400 --> 00:38:35,440
and we can call gpio init

934
00:38:35,440 --> 00:38:38,079
and we have our function first function

935
00:38:38,079 --> 00:38:40,480
ready it initializes the pins

936
00:38:40,480 --> 00:38:43,040
and cool the next function we are going

937
00:38:43,040 --> 00:38:44,640
to implement will just

938
00:38:44,640 --> 00:38:47,839
um get a number of led

939
00:38:47,839 --> 00:38:50,720
and we light it up so uh let's call it

940
00:38:50,720 --> 00:38:51,280
light

941
00:38:51,280 --> 00:38:54,320
led uh gets

942
00:38:54,320 --> 00:38:58,800
a number of led in our or maybe r24

943
00:38:58,800 --> 00:39:02,079
number or index

944
00:39:02,079 --> 00:39:05,680
led index so uh

945
00:39:05,880 --> 00:39:08,560
fs023

946
00:39:08,560 --> 00:39:12,240
uh and then what it basically does

947
00:39:12,240 --> 00:39:15,839
uh return of course so it will just

948
00:39:15,839 --> 00:39:18,400
uh there are a lot of ways to go about

949
00:39:18,400 --> 00:39:19,040
this like

950
00:39:19,040 --> 00:39:22,400
uh the thing with assembly you can use

951
00:39:22,400 --> 00:39:24,640
many combinations of instructions to

952
00:39:24,640 --> 00:39:26,079
achieve the same thing

953
00:39:26,079 --> 00:39:27,520
and i'm going to do the super

954
00:39:27,520 --> 00:39:29,280
straightforward thing right now

955
00:39:29,280 --> 00:39:33,040
which is just you know compare uh r24

956
00:39:33,040 --> 00:39:36,640
cpi compare with immediate uh with zero

957
00:39:36,640 --> 00:39:40,000
if it's not zero uh then we are going to

958
00:39:40,000 --> 00:39:40,960
jump ahead

959
00:39:40,960 --> 00:39:44,240
so jump to one f so

960
00:39:44,240 --> 00:39:47,280
one forward one down and if our

961
00:39:47,280 --> 00:39:50,560
um uh if it's uh

962
00:39:50,560 --> 00:39:54,079
zero then we are going to uh

963
00:39:54,079 --> 00:39:56,640
and we'll do this in a moment light up

964
00:39:56,640 --> 00:39:57,520
led

965
00:39:57,520 --> 00:40:00,960
uh at pin so the first led is at the pin

966
00:40:00,960 --> 00:40:02,400
pb1

967
00:40:02,400 --> 00:40:05,520
and then the next um the next piece will

968
00:40:05,520 --> 00:40:07,119
just uh do the same

969
00:40:07,119 --> 00:40:11,359
uh you know just um compare it with one

970
00:40:11,359 --> 00:40:14,240
and then compare it with two and then

971
00:40:14,240 --> 00:40:16,800
compare it with three

972
00:40:16,800 --> 00:40:19,119
and uh you can see i use the same label

973
00:40:19,119 --> 00:40:21,920
name and that's fine because one f

974
00:40:21,920 --> 00:40:23,920
just looks for the next one and it's

975
00:40:23,920 --> 00:40:26,079
okay to define the same number multiple

976
00:40:26,079 --> 00:40:26,640
times

977
00:40:26,640 --> 00:40:29,839
just uh make sure that uh it might get

978
00:40:29,839 --> 00:40:30,640
confusing

979
00:40:30,640 --> 00:40:33,760
if you uh not use it

980
00:40:33,760 --> 00:40:39,119
carefully so uh now uh finally um

981
00:40:39,119 --> 00:40:41,119
we we have this skeleton of code that

982
00:40:41,119 --> 00:40:42,720
we'll just compare and

983
00:40:42,720 --> 00:40:46,079
r22 r24 against those four values

984
00:40:46,079 --> 00:40:48,319
and depending on their values will uh

985
00:40:48,319 --> 00:40:49,599
this two

986
00:40:49,599 --> 00:40:52,960
three and four will execute one of those

987
00:40:52,960 --> 00:40:56,079
and we can um actually um

988
00:40:56,079 --> 00:40:59,680
write this code um so there are

989
00:40:59,680 --> 00:41:04,240
again a few ways to go about it um

990
00:41:04,720 --> 00:41:07,440
i could use that instruction that sets a

991
00:41:07,440 --> 00:41:10,640
specific bit of the i o register

992
00:41:10,640 --> 00:41:13,920
um and that would look like a set

993
00:41:13,920 --> 00:41:16,720
bit i o register and we want to set it

994
00:41:16,720 --> 00:41:17,119
in

995
00:41:17,119 --> 00:41:20,240
port b so

996
00:41:20,240 --> 00:41:24,319
port b and pb1

997
00:41:24,319 --> 00:41:27,280
and then uh if i get here i can just you

998
00:41:27,280 --> 00:41:29,200
know return because i did what i had to

999
00:41:29,200 --> 00:41:30,000
do

1000
00:41:30,000 --> 00:41:33,280
but in the future i actually want to add

1001
00:41:33,280 --> 00:41:36,400
some more logic into a light led

1002
00:41:36,400 --> 00:41:38,319
for instance i would want it to make

1003
00:41:38,319 --> 00:41:40,079
sure all the other leds are off

1004
00:41:40,079 --> 00:41:43,119
only that specific one is on

1005
00:41:43,119 --> 00:41:46,720
so i will implement it a bit differently

1006
00:41:46,720 --> 00:41:50,160
we are going to load um another

1007
00:41:50,160 --> 00:41:54,240
uh register let's uh r18

1008
00:41:54,240 --> 00:41:57,599
so it starts with zero and then um

1009
00:41:57,599 --> 00:42:01,599
if i want to uh light a specific uh

1010
00:42:01,599 --> 00:42:04,880
pin i will just uh copy the number the

1011
00:42:04,880 --> 00:42:08,079
uh bit pattern into this register so

1012
00:42:08,079 --> 00:42:11,200
uh that would be pb1 and

1013
00:42:11,200 --> 00:42:14,839
then i'm going to jump uh somewhere

1014
00:42:14,839 --> 00:42:17,520
um spatial where uh

1015
00:42:17,520 --> 00:42:21,200
i'm going to apply this so i'm going to

1016
00:42:21,200 --> 00:42:21,680
jump

1017
00:42:21,680 --> 00:42:24,160
to or our jump because we have seen it's

1018
00:42:24,160 --> 00:42:25,440
nicer to two

1019
00:42:25,440 --> 00:42:29,680
number two and this is number two

1020
00:42:29,680 --> 00:42:33,200
and number two uh will basically

1021
00:42:33,200 --> 00:42:36,960
for now we'll just out this uh

1022
00:42:36,960 --> 00:42:40,319
to port b so

1023
00:42:40,319 --> 00:42:44,000
port b uh we want to out the value

1024
00:42:44,000 --> 00:42:47,520
of r18 yep

1025
00:42:47,520 --> 00:42:50,480
and then we can repeat this uh so this

1026
00:42:50,480 --> 00:42:52,319
is for pb2

1027
00:42:52,319 --> 00:42:56,240
and this is for pp3 and this is

1028
00:42:56,240 --> 00:42:59,680
for pv 4

1029
00:42:59,680 --> 00:43:03,040
yeah pb1 to p4 yes and

1030
00:43:03,040 --> 00:43:06,800
um if it's not equal then skip

1031
00:43:06,800 --> 00:43:08,720
yeah we could have probably uh remove

1032
00:43:08,720 --> 00:43:11,359
this label and just you know br and e2f

1033
00:43:11,359 --> 00:43:13,440
but you know just to keep it consistent

1034
00:43:13,440 --> 00:43:16,800
that should also work um and then

1035
00:43:16,800 --> 00:43:19,119
since i'm initializing this to zero if

1036
00:43:19,119 --> 00:43:20,880
we pass an invalid number

1037
00:43:20,880 --> 00:43:23,680
it will just uh skip here skip here skip

1038
00:43:23,680 --> 00:43:24,720
here skip here

1039
00:43:24,720 --> 00:43:28,000
and just turn all the leds off so that's

1040
00:43:28,000 --> 00:43:30,240
one of many ways to achieve this

1041
00:43:30,240 --> 00:43:33,119
and we have the function let's check the

1042
00:43:33,119 --> 00:43:34,560
code compiles

1043
00:43:34,560 --> 00:43:37,599
and now instead of calling sbi

1044
00:43:37,599 --> 00:43:40,880
let's try our function so let's ldi into

1045
00:43:40,880 --> 00:43:42,480
r24

1046
00:43:42,480 --> 00:43:45,760
0 should be the yellow

1047
00:43:45,760 --> 00:43:48,400
the first one let's see if it works yep

1048
00:43:48,400 --> 00:43:49,920
yellow works

1049
00:43:49,920 --> 00:43:53,440
then this one then

1050
00:43:53,440 --> 00:43:55,599
that one yep so we have our first

1051
00:43:55,599 --> 00:43:56,880
function that takes an

1052
00:43:56,880 --> 00:44:00,000
index of an led and lights it up

1053
00:44:00,000 --> 00:44:02,160
and we could have done this in so many

1054
00:44:02,160 --> 00:44:04,480
ways like we could have created a

1055
00:44:04,480 --> 00:44:08,160
lookup table and then um use that

1056
00:44:08,160 --> 00:44:10,560
or uh you have seen like the other

1057
00:44:10,560 --> 00:44:11,520
approach with

1058
00:44:11,520 --> 00:44:14,640
calling sbi to turn off on the specific

1059
00:44:14,640 --> 00:44:16,400
beat and then return

1060
00:44:16,400 --> 00:44:19,359
um but here we have it working and

1061
00:44:19,359 --> 00:44:21,359
that's what important for now

1062
00:44:21,359 --> 00:44:23,440
and the next thing we are going to do is

1063
00:44:23,440 --> 00:44:25,359
to read inputs from the patterns

1064
00:44:25,359 --> 00:44:28,000
so we are going to declare a read btn

1065
00:44:28,000 --> 00:44:28,880
function

1066
00:44:28,880 --> 00:44:31,920
and read btn uh waits

1067
00:44:31,920 --> 00:44:35,200
so waits until one some

1068
00:44:35,200 --> 00:44:38,400
button is pressed

1069
00:44:38,400 --> 00:44:41,680
returns the index

1070
00:44:41,680 --> 00:44:46,960
0 to 3 in r 24

1071
00:44:47,359 --> 00:44:49,280
by the way we don't have to use the same

1072
00:44:49,280 --> 00:44:50,640
conventions as the

1073
00:44:50,640 --> 00:44:53,440
gcc api but it's convenient because they

1074
00:44:53,440 --> 00:44:54,400
are already there

1075
00:44:54,400 --> 00:44:57,200
so i in my code i always stick to those

1076
00:44:57,200 --> 00:44:58,560
conventions

1077
00:44:58,560 --> 00:45:00,240
but you don't have you can come up with

1078
00:45:00,240 --> 00:45:01,920
any convention that you like as long as

1079
00:45:01,920 --> 00:45:03,440
you are

1080
00:45:03,440 --> 00:45:04,880
the only one who is writing the

1081
00:45:04,880 --> 00:45:07,520
assembler code then uh you can also use

1082
00:45:07,520 --> 00:45:08,079
like

1083
00:45:08,079 --> 00:45:10,880
instead of this uh underscore case you

1084
00:45:10,880 --> 00:45:11,680
can also use

1085
00:45:11,680 --> 00:45:13,920
camel case for function name so whatever

1086
00:45:13,920 --> 00:45:14,880
you like

1087
00:45:14,880 --> 00:45:17,359
it's up to you and same for like how you

1088
00:45:17,359 --> 00:45:18,240
pass and return

1089
00:45:18,240 --> 00:45:21,599
values etc um okay

1090
00:45:21,599 --> 00:45:25,599
so read button so um we want to read

1091
00:45:25,599 --> 00:45:29,040
uh from those uh pins these are this is

1092
00:45:29,040 --> 00:45:33,040
port d so uh we can um

1093
00:45:33,040 --> 00:45:36,640
we can do it in many ways um

1094
00:45:36,640 --> 00:45:38,720
and you know what i'm actually going to

1095
00:45:38,720 --> 00:45:40,319
use um

1096
00:45:40,319 --> 00:45:43,760
this uh instruction that we mentioned

1097
00:45:43,760 --> 00:45:47,319
but we haven't talked about which is

1098
00:45:47,319 --> 00:45:48,960
sbis

1099
00:45:48,960 --> 00:45:52,400
skip if bit in io register is set

1100
00:45:52,400 --> 00:45:56,160
um so this instruction test a single bit

1101
00:45:56,160 --> 00:45:58,160
in the i o register and skips the next

1102
00:45:58,160 --> 00:46:00,079
instruction if the bit is set

1103
00:46:00,079 --> 00:46:02,160
this instruction operates on the 32

1104
00:46:02,160 --> 00:46:03,680
dollar i o registers

1105
00:46:03,680 --> 00:46:07,760
and i know that the input register

1106
00:46:07,760 --> 00:46:10,960
for port d that's pin d so

1107
00:46:10,960 --> 00:46:14,640
pin d is less than 31

1108
00:46:14,640 --> 00:46:17,119
um but you can see it in the data sheet

1109
00:46:17,119 --> 00:46:18,480
um

1110
00:46:18,480 --> 00:46:21,280
and then since those are pull ups they

1111
00:46:21,280 --> 00:46:22,079
will read

1112
00:46:22,079 --> 00:46:25,920
one if the button is

1113
00:46:25,920 --> 00:46:29,760
not pressed or zero if it is pressed

1114
00:46:29,760 --> 00:46:31,839
so what i'm going to do i'm basically

1115
00:46:31,839 --> 00:46:33,839
going to do this i'm going to

1116
00:46:33,839 --> 00:46:38,560
uh look at this uh specific bit of

1117
00:46:38,560 --> 00:46:42,960
the pin d so uh this uh i o port uh

1118
00:46:42,960 --> 00:46:44,400
input register

1119
00:46:44,400 --> 00:46:47,280
and uh let's start with the first button

1120
00:46:47,280 --> 00:46:47,599
uh

1121
00:46:47,599 --> 00:46:51,839
pd0 so i'm asking um

1122
00:46:51,839 --> 00:46:54,880
if this bit is sorry if it's

1123
00:46:54,880 --> 00:46:58,000
set not if it's clear sbis not

1124
00:46:58,000 --> 00:47:00,960
c is the opposite if it's uh clear but

1125
00:47:00,960 --> 00:47:01,599
here i am

1126
00:47:01,599 --> 00:47:03,599
i want to skip if it's set so if the

1127
00:47:03,599 --> 00:47:05,200
button is not pressed

1128
00:47:05,200 --> 00:47:08,240
so if the button is not pressed then i'm

1129
00:47:08,240 --> 00:47:10,079
just going to skip the next instruction

1130
00:47:10,079 --> 00:47:12,640
by the way this uh is in interesting

1131
00:47:12,640 --> 00:47:14,240
instructions

1132
00:47:14,240 --> 00:47:16,240
in interesting instruction the number of

1133
00:47:16,240 --> 00:47:18,480
cycles depends on whether the condition

1134
00:47:18,480 --> 00:47:19,680
is false or true

1135
00:47:19,680 --> 00:47:23,200
and how many um

1136
00:47:23,200 --> 00:47:26,480
how many bytes or words you skip

1137
00:47:26,480 --> 00:47:30,880
anyway so uh going back to simon

1138
00:47:30,880 --> 00:47:33,040
so what i'm going to do now i'm going to

1139
00:47:33,040 --> 00:47:34,480
do this so

1140
00:47:34,480 --> 00:47:38,160
if uh this button uh is

1141
00:47:38,160 --> 00:47:42,480
not pressed so if pd 2

1142
00:47:42,480 --> 00:47:46,319
is high not pressed

1143
00:47:46,319 --> 00:47:48,559
skip next and in the next instruction

1144
00:47:48,559 --> 00:47:50,720
i'm just going to

1145
00:47:50,720 --> 00:47:54,480
load into um r24 the number

1146
00:47:54,480 --> 00:47:56,720
of this button so if it's pressed it

1147
00:47:56,720 --> 00:47:57,520
will

1148
00:47:57,520 --> 00:47:59,680
do this if it's not it will it will just

1149
00:47:59,680 --> 00:48:01,520
skip to the next instruction

1150
00:48:01,520 --> 00:48:04,960
and then i can repeat it so pd3

1151
00:48:04,960 --> 00:48:08,559
pd4 pd5 let's just remove those comments

1152
00:48:08,559 --> 00:48:11,280
because you got the idea and then this

1153
00:48:11,280 --> 00:48:12,400
loads one

1154
00:48:12,400 --> 00:48:16,160
two and three and uh one final thing i

1155
00:48:16,160 --> 00:48:17,839
want to wait until somebody

1156
00:48:17,839 --> 00:48:20,240
is pressed so i need a way to detect

1157
00:48:20,240 --> 00:48:22,240
whether some button was pressed

1158
00:48:22,240 --> 00:48:24,319
and in order to do that i will just

1159
00:48:24,319 --> 00:48:26,160
initialize r24

1160
00:48:26,160 --> 00:48:30,000
with some random value let's say ff

1161
00:48:30,000 --> 00:48:33,599
and then at the end i can say compare

1162
00:48:33,599 --> 00:48:37,119
r24 with ff so if it's uh

1163
00:48:37,119 --> 00:48:39,839
uh skipped uh all of those because none

1164
00:48:39,839 --> 00:48:41,920
of the buttons were pressed it will just

1165
00:48:41,920 --> 00:48:45,839
uh equal ff and then if it does uh br

1166
00:48:45,839 --> 00:48:49,119
eq we are going to just

1167
00:48:49,119 --> 00:48:51,280
return to the beginning of the function

1168
00:48:51,280 --> 00:48:53,440
so it's basically a loop that

1169
00:48:53,440 --> 00:48:56,960
um executes until one of those bits

1170
00:48:56,960 --> 00:48:59,599
is uh clear and whenever it's clear it

1171
00:48:59,599 --> 00:49:00,640
will uh

1172
00:49:00,640 --> 00:49:04,319
set r24 to the uh relevant value

1173
00:49:04,319 --> 00:49:07,440
and then uh if it

1174
00:49:07,440 --> 00:49:10,160
said it it will just not take the branch

1175
00:49:10,160 --> 00:49:12,160
and return to the color so that's how it

1176
00:49:12,160 --> 00:49:12,880
work

1177
00:49:12,880 --> 00:49:15,280
and in order to test it we can just call

1178
00:49:15,280 --> 00:49:17,119
those two functions in sequence so we

1179
00:49:17,119 --> 00:49:19,200
can call read btn

1180
00:49:19,200 --> 00:49:21,920
and then it will return the value in r24

1181
00:49:21,920 --> 00:49:23,200
the index of the button

1182
00:49:23,200 --> 00:49:25,280
and then light led which will lie the

1183
00:49:25,280 --> 00:49:26,319
respective

1184
00:49:26,319 --> 00:49:31,040
led let's try that and see if it works

1185
00:49:31,040 --> 00:49:35,280
oh yeah it works nice so this is like

1186
00:49:35,280 --> 00:49:38,559
the first uh bit of logic that is

1187
00:49:38,559 --> 00:49:40,319
actually working we built it from

1188
00:49:40,319 --> 00:49:40,880
scratch

1189
00:49:40,880 --> 00:49:44,000
in assembly uh not too short not

1190
00:49:44,000 --> 00:49:46,640
too long and now the next thing we are

1191
00:49:46,640 --> 00:49:47,599
going to do

1192
00:49:47,599 --> 00:49:51,839
is actually um create the piece of code

1193
00:49:51,839 --> 00:49:56,000
that will um display the user

1194
00:49:56,000 --> 00:49:59,280
display the next sequence to the user so

1195
00:49:59,280 --> 00:50:01,200
we assume there is always already a

1196
00:50:01,200 --> 00:50:03,200
sequence of light and we want to display

1197
00:50:03,200 --> 00:50:04,720
it to the user

1198
00:50:04,720 --> 00:50:08,240
and in order to do that um we have to do

1199
00:50:08,240 --> 00:50:10,079
two things first of all we have to

1200
00:50:10,079 --> 00:50:11,680
declare the sequence

1201
00:50:11,680 --> 00:50:14,160
and now i'm going to show you how we can

1202
00:50:14,160 --> 00:50:15,440
store variables

1203
00:50:15,440 --> 00:50:18,880
in the sram so for that we would need

1204
00:50:18,880 --> 00:50:22,160
to declare a data section

1205
00:50:22,160 --> 00:50:25,200
and then we can declare those bytes so

1206
00:50:25,200 --> 00:50:27,359
let's say the first bar this the first

1207
00:50:27,359 --> 00:50:29,440
uh variable will be the sequence

1208
00:50:29,440 --> 00:50:32,720
and it will have a few bytes let's say

1209
00:50:32,720 --> 00:50:35,839
uh we will start with uh just you know

1210
00:50:35,839 --> 00:50:39,280
just to test it uh so

1211
00:50:39,280 --> 00:50:42,559
just go one two three four ta

1212
00:50:42,559 --> 00:50:45,119
ta ta go forward and back but we could

1213
00:50:45,119 --> 00:50:46,559
do any other sequence

1214
00:50:46,559 --> 00:50:48,640
and another that will hold the sequence

1215
00:50:48,640 --> 00:50:50,319
length and whenever the user

1216
00:50:50,319 --> 00:50:53,680
um types uh

1217
00:50:53,680 --> 00:50:55,440
like whenever the user moves to the next

1218
00:50:55,440 --> 00:50:57,359
level we'll just add something to the

1219
00:50:57,359 --> 00:50:58,000
sequence

1220
00:50:58,000 --> 00:51:00,079
and increase the sequence lengths

1221
00:51:00,079 --> 00:51:02,000
actually we can put the sequence

1222
00:51:02,000 --> 00:51:05,680
um uh you know what

1223
00:51:05,680 --> 00:51:07,839
never mind we can do it this way as well

1224
00:51:07,839 --> 00:51:09,280
uh by

1225
00:51:09,280 --> 00:51:12,160
let's say we just start with seven so

1226
00:51:12,160 --> 00:51:12,960
we'll see the

1227
00:51:12,960 --> 00:51:15,839
entire sequence and if we want like to

1228
00:51:15,839 --> 00:51:16,640
leave a

1229
00:51:16,640 --> 00:51:19,359
some space for the sequence to grow we

1230
00:51:19,359 --> 00:51:20,000
can just

1231
00:51:20,000 --> 00:51:23,119
i think it's dot space um so

1232
00:51:23,119 --> 00:51:25,359
uh if you want to know about all those

1233
00:51:25,359 --> 00:51:27,520
directives like byte and space

1234
00:51:27,520 --> 00:51:30,319
they are uh defined in this document so

1235
00:51:30,319 --> 00:51:31,119
there is like

1236
00:51:31,119 --> 00:51:34,240
byte and there is like word or

1237
00:51:34,240 --> 00:51:36,160
and there is like whatever there are

1238
00:51:36,160 --> 00:51:37,839
like a lot of uh

1239
00:51:37,839 --> 00:51:40,880
here is like a space which uh

1240
00:51:40,880 --> 00:51:44,640
um just fills uh with uh specific value

1241
00:51:44,640 --> 00:51:47,200
anyway let me just put this link so uh

1242
00:51:47,200 --> 00:51:50,559
if you want you can check it later like

1243
00:51:50,559 --> 00:51:53,920
all the gnu assembler directives

1244
00:51:53,920 --> 00:51:57,200
um cool and

1245
00:51:57,200 --> 00:51:59,440
one other important very important

1246
00:51:59,440 --> 00:52:00,480
directive

1247
00:52:00,480 --> 00:52:03,680
if we run the code now you will see that

1248
00:52:03,680 --> 00:52:04,000
uh

1249
00:52:04,000 --> 00:52:07,280
nothing happens because uh

1250
00:52:07,280 --> 00:52:09,440
suddenly we declared this data section

1251
00:52:09,440 --> 00:52:11,040
so it actually put all of the

1252
00:52:11,040 --> 00:52:12,800
instructions in the data section

1253
00:52:12,800 --> 00:52:14,400
and there is no code in the program

1254
00:52:14,400 --> 00:52:16,800
anymore so to fix that we need to write

1255
00:52:16,800 --> 00:52:17,200
dot

1256
00:52:17,200 --> 00:52:20,640
text dot text tells the assembler that

1257
00:52:20,640 --> 00:52:23,680
the following uh declarations go

1258
00:52:23,680 --> 00:52:26,880
into uh the code section

1259
00:52:26,880 --> 00:52:29,040
if you want to know why it's called sex

1260
00:52:29,040 --> 00:52:30,000
then there is this

1261
00:52:30,000 --> 00:52:33,760
stack overflow uh the the tl dr is that

1262
00:52:33,760 --> 00:52:36,480
nobody really knows there are like uh

1263
00:52:36,480 --> 00:52:37,280
always

1264
00:52:37,280 --> 00:52:40,800
there are a lot of um theories but uh

1265
00:52:40,800 --> 00:52:42,960
i have no idea why it's called text and

1266
00:52:42,960 --> 00:52:44,160
i don't think every

1267
00:52:44,160 --> 00:52:47,599
anyone in this world knows for sure but

1268
00:52:47,599 --> 00:52:50,160
maybe just to confuse us a little more

1269
00:52:50,160 --> 00:52:50,720
as if

1270
00:52:50,720 --> 00:52:53,040
things are not confusing enough and now

1271
00:52:53,040 --> 00:52:55,280
if we run the code we can see that it

1272
00:52:55,280 --> 00:52:57,280
works

1273
00:52:57,280 --> 00:53:00,880
now let me save you a lot of time um

1274
00:53:00,880 --> 00:53:04,800
because if we write this and um

1275
00:53:04,800 --> 00:53:07,680
look at the uh try to read values let's

1276
00:53:07,680 --> 00:53:08,079
say

1277
00:53:08,079 --> 00:53:10,559
uh let me show you what happens if i

1278
00:53:10,559 --> 00:53:11,599
read

1279
00:53:11,599 --> 00:53:14,400
a value from sequence length i expected

1280
00:53:14,400 --> 00:53:15,280
to have

1281
00:53:15,280 --> 00:53:17,200
the value seven if i read the byte from

1282
00:53:17,200 --> 00:53:19,359
this memory location but let's see

1283
00:53:19,359 --> 00:53:22,880
let me show you what happens so uh lds

1284
00:53:22,880 --> 00:53:25,920
art when r18 let's load a short from

1285
00:53:25,920 --> 00:53:26,400
this

1286
00:53:26,400 --> 00:53:28,960
location and then just break so we can

1287
00:53:28,960 --> 00:53:30,079
see the value

1288
00:53:30,079 --> 00:53:34,000
and let's do that and if you check out

1289
00:53:34,000 --> 00:53:36,640
r18 it's actually zero and we can

1290
00:53:36,640 --> 00:53:37,119
actually

1291
00:53:37,119 --> 00:53:39,599
open gdb and look at this memory address

1292
00:53:39,599 --> 00:53:41,520
and it will be zero like the

1293
00:53:41,520 --> 00:53:43,280
memory address pointed by sequence

1294
00:53:43,280 --> 00:53:45,359
length and the reason for that

1295
00:53:45,359 --> 00:53:48,880
um is that by default

1296
00:53:48,880 --> 00:53:49,280
um

1297
00:53:49,280 --> 00:53:52,000
[Music]

1298
00:53:52,000 --> 00:53:54,480
there is no code that copies this into

1299
00:53:54,480 --> 00:53:56,480
the ram when the program starts in

1300
00:53:56,480 --> 00:53:58,720
arduino there is a piece of code

1301
00:53:58,720 --> 00:54:01,359
and that code is called do copy data a

1302
00:54:01,359 --> 00:54:03,200
function that copies this

1303
00:54:03,200 --> 00:54:06,640
section into uh into the ram

1304
00:54:06,640 --> 00:54:09,760
from the program memory and since we

1305
00:54:09,760 --> 00:54:12,160
don't have any arduino code or we don't

1306
00:54:12,160 --> 00:54:14,400
have any global variables in the arduino

1307
00:54:14,400 --> 00:54:14,800
code

1308
00:54:14,800 --> 00:54:17,119
this piece of code is just not included

1309
00:54:17,119 --> 00:54:19,359
but we can force the linker to include

1310
00:54:19,359 --> 00:54:19,599
it

1311
00:54:19,599 --> 00:54:22,160
if we declare this and this is like just

1312
00:54:22,160 --> 00:54:22,960
uh

1313
00:54:22,960 --> 00:54:26,319
a magic name of the function

1314
00:54:26,319 --> 00:54:28,800
and if we try this again now that we

1315
00:54:28,800 --> 00:54:30,480
added this global

1316
00:54:30,480 --> 00:54:34,559
we will see that suddenly that was r18

1317
00:54:34,559 --> 00:54:37,599
r18 where you includes the contains the

1318
00:54:37,599 --> 00:54:38,000
value

1319
00:54:38,000 --> 00:54:40,559
seven so i think that's a very important

1320
00:54:40,559 --> 00:54:41,119
piece

1321
00:54:41,119 --> 00:54:43,520
and if we look at the assembly code

1322
00:54:43,520 --> 00:54:45,599
listing

1323
00:54:45,599 --> 00:54:48,960
we can see that um where is that

1324
00:54:48,960 --> 00:54:51,440
assembly code listing

1325
00:54:51,440 --> 00:54:54,720
yeah uh to copy data

1326
00:54:54,720 --> 00:54:57,200
yeah we can see that now we included

1327
00:54:57,200 --> 00:54:58,000
this function

1328
00:54:58,000 --> 00:54:59,599
and this function you can check it out

1329
00:54:59,599 --> 00:55:01,200
later but it just copies

1330
00:55:01,200 --> 00:55:03,599
a bunch of data from the program memory

1331
00:55:03,599 --> 00:55:06,079
lpm reads from the program memory

1332
00:55:06,079 --> 00:55:09,760
into sd stores data into the sram

1333
00:55:09,760 --> 00:55:13,200
into the sram so

1334
00:55:13,280 --> 00:55:15,920
just automatically include this i will

1335
00:55:15,920 --> 00:55:18,240
copy to the document so we won't forget

1336
00:55:18,240 --> 00:55:19,040
about it

1337
00:55:19,040 --> 00:55:21,680
it's very important automatically do

1338
00:55:21,680 --> 00:55:22,319
this in

1339
00:55:22,319 --> 00:55:24,640
every assembly program that you write

1340
00:55:24,640 --> 00:55:25,680
from scratch

1341
00:55:25,680 --> 00:55:30,160
that will save you a lot of pain

1342
00:55:30,720 --> 00:55:33,599
okay so now we have those variables in

1343
00:55:33,599 --> 00:55:34,160
memory

1344
00:55:34,160 --> 00:55:37,839
let's uh try to implement

1345
00:55:37,839 --> 00:55:40,000
play sequence real quick so play

1346
00:55:40,000 --> 00:55:41,280
sequence just

1347
00:55:41,280 --> 00:55:44,480
uh does this we want to

1348
00:55:44,480 --> 00:55:47,440
load the sequence lengths into some

1349
00:55:47,440 --> 00:55:48,799
register

1350
00:55:48,799 --> 00:55:53,040
so load let's say into r18

1351
00:55:53,040 --> 00:55:56,640
because we love r18 so sequence lengths

1352
00:55:56,640 --> 00:55:59,599
and then we want to loop uh as long as

1353
00:55:59,599 --> 00:56:00,559
uh

1354
00:56:00,559 --> 00:56:03,280
as many as sequence lengths by so uh we

1355
00:56:03,280 --> 00:56:05,599
will just decrement r18

1356
00:56:05,599 --> 00:56:09,200
let's do a loop here so one and then

1357
00:56:09,200 --> 00:56:12,480
uh brne so if it's not zero

1358
00:56:12,480 --> 00:56:15,359
uh we will jump uh backward to one so

1359
00:56:15,359 --> 00:56:16,240
that will loop

1360
00:56:16,240 --> 00:56:19,599
uh sequence length bytes and then

1361
00:56:19,599 --> 00:56:21,839
uh we are going to use a new instruction

1362
00:56:21,839 --> 00:56:22,640
here to load

1363
00:56:22,640 --> 00:56:24,880
the next number from the sequence and

1364
00:56:24,880 --> 00:56:26,000
that instruction

1365
00:56:26,000 --> 00:56:29,520
is um uh

1366
00:56:29,520 --> 00:56:33,280
ld ld loads uh like lds which gets an

1367
00:56:33,280 --> 00:56:36,480
address ld loads um there are like

1368
00:56:36,480 --> 00:56:40,240
several variations of ld where is that

1369
00:56:40,240 --> 00:56:44,079
ld ld yeah it can load from either the x

1370
00:56:44,079 --> 00:56:48,480
y or z and um we we just uh load into

1371
00:56:48,480 --> 00:56:50,400
one of the registers and we can also

1372
00:56:50,400 --> 00:56:50,960
tell it

1373
00:56:50,960 --> 00:56:55,040
to post increment x so load and then

1374
00:56:55,040 --> 00:56:57,359
move x set x to point to the next

1375
00:56:57,359 --> 00:56:58,319
location

1376
00:56:58,319 --> 00:57:00,240
so that's how we are loading going to

1377
00:57:00,240 --> 00:57:01,440
load the values uh

1378
00:57:01,440 --> 00:57:04,960
one by one um so that was

1379
00:57:04,960 --> 00:57:08,079
here so uh ld

1380
00:57:08,079 --> 00:57:10,640
so first of all let's initialize x so x

1381
00:57:10,640 --> 00:57:11,200
is just

1382
00:57:11,200 --> 00:57:15,920
r 26 and r 27 r 26 will have the low

1383
00:57:15,920 --> 00:57:18,559
part of this sequence so the address of

1384
00:57:18,559 --> 00:57:20,880
the variable sequence we take the low

1385
00:57:20,880 --> 00:57:21,359
part of

1386
00:57:21,359 --> 00:57:24,160
it the low by and then the high byte and

1387
00:57:24,160 --> 00:57:24,720
this is

1388
00:57:24,720 --> 00:57:28,079
how we initialize x

1389
00:57:28,079 --> 00:57:30,079
and then we can just load the load the

1390
00:57:30,079 --> 00:57:31,200
bytes one by one

1391
00:57:31,200 --> 00:57:34,240
so ldx ld

1392
00:57:34,240 --> 00:57:38,079
um let's load them into r24

1393
00:57:38,079 --> 00:57:41,280
and x plus means increment it by one

1394
00:57:41,280 --> 00:57:44,000
and now all we have to do is just call

1395
00:57:44,000 --> 00:57:44,480
this

1396
00:57:44,480 --> 00:57:48,400
uh light led note that it changes

1397
00:57:48,400 --> 00:57:52,000
our uh 18 and we are using r8 in here so

1398
00:57:52,000 --> 00:57:52,640
we'll just

1399
00:57:52,640 --> 00:57:55,680
push r18 and then pop it to preserve the

1400
00:57:55,680 --> 00:57:56,480
value

1401
00:57:56,480 --> 00:57:59,680
and if we uh if we

1402
00:57:59,680 --> 00:58:02,079
buy the api we should also do it for x

1403
00:58:02,079 --> 00:58:03,119
because uh

1404
00:58:03,119 --> 00:58:05,520
functions uh those are called clobbered

1405
00:58:05,520 --> 00:58:06,799
registers functions

1406
00:58:06,799 --> 00:58:08,559
may change them but in this case we'll

1407
00:58:08,559 --> 00:58:10,160
just skip it because we know that

1408
00:58:10,160 --> 00:58:11,200
function doesn't

1409
00:58:11,200 --> 00:58:14,559
touch x register and then we can call

1410
00:58:14,559 --> 00:58:18,720
light led and we have the value in r24

1411
00:58:18,720 --> 00:58:21,760
so it will just have uh

1412
00:58:21,760 --> 00:58:23,839
load an x value from the sequence and

1413
00:58:23,839 --> 00:58:25,520
call this function

1414
00:58:25,520 --> 00:58:28,160
and uh if we just uh you know let's

1415
00:58:28,160 --> 00:58:29,359
remove this and just

1416
00:58:29,359 --> 00:58:32,559
call this place sequence if we just

1417
00:58:32,559 --> 00:58:36,000
test it we can see it fails because what

1418
00:58:36,000 --> 00:58:38,559
happens

1419
00:58:39,680 --> 00:58:43,200
oh ldi not lds yeah we are loading a

1420
00:58:43,200 --> 00:58:46,000
value not uh like we are loading the

1421
00:58:46,000 --> 00:58:47,280
address of sequence not

1422
00:58:47,280 --> 00:58:50,559
the value of sequence yeah and now you

1423
00:58:50,559 --> 00:58:52,400
can see that all the leds are lighting

1424
00:58:52,400 --> 00:58:53,119
at once

1425
00:58:53,119 --> 00:58:54,880
and the reason for that is that we don't

1426
00:58:54,880 --> 00:58:56,720
have any delays here

1427
00:58:56,720 --> 00:58:59,040
luckily we don't have to write delay

1428
00:58:59,040 --> 00:59:01,200
from scratch because we already did it

1429
00:59:01,200 --> 00:59:02,720
so

1430
00:59:02,720 --> 00:59:05,760
there is this delay millis and uh

1431
00:59:05,760 --> 00:59:08,160
that we created in the past so we can

1432
00:59:08,160 --> 00:59:09,040
just uh

1433
00:59:09,040 --> 00:59:12,960
add a small delay uh to um

1434
00:59:12,960 --> 00:59:15,680
let's just change it to the same naming

1435
00:59:15,680 --> 00:59:17,359
convention that we use here with

1436
00:59:17,359 --> 00:59:18,079
underscore

1437
00:59:18,079 --> 00:59:20,720
we don't need to make it global and we

1438
00:59:20,720 --> 00:59:21,440
can do it

1439
00:59:21,440 --> 00:59:24,480
uh right after calling a light led just

1440
00:59:24,480 --> 00:59:25,760
you know

1441
00:59:25,760 --> 00:59:28,000
or we can do it inside light led doesn't

1442
00:59:28,000 --> 00:59:30,000
really matter let's do it after

1443
00:59:30,000 --> 00:59:33,200
so uh ldir24

1444
00:59:33,200 --> 00:59:35,760
let's delay for half a second so high

1445
00:59:35,760 --> 00:59:36,240
eight

1446
00:59:36,240 --> 00:59:40,240
uh sequence uh low eight actually

1447
00:59:40,240 --> 00:59:43,760
low eight uh 500 and

1448
00:59:43,760 --> 00:59:47,040
this will be the high byte of 500 and

1449
00:59:47,040 --> 00:59:48,319
just all this

1450
00:59:48,319 --> 00:59:50,079
magic function that we have from the

1451
00:59:50,079 --> 00:59:52,319
past and if we run the code again

1452
00:59:52,319 --> 00:59:54,960
we can see that it doesn't do what it's

1453
00:59:54,960 --> 00:59:57,620
supposed to do for some reason

1454
00:59:57,620 --> 00:59:58,839
[Music]

1455
00:59:58,839 --> 01:00:00,559
um

1456
01:00:00,559 --> 01:00:03,599
ah okay so delay millis uh messes up

1457
01:00:03,599 --> 01:00:03,920
with

1458
01:00:03,920 --> 01:00:07,680
x so uh we should uh yeah you saw it

1459
01:00:07,680 --> 01:00:10,000
it lit the first led and then it blew

1460
01:00:10,000 --> 01:00:11,119
off so

1461
01:00:11,119 --> 01:00:13,520
yeah we should uh push that and pop out

1462
01:00:13,520 --> 01:00:14,720
that as well

1463
01:00:14,720 --> 01:00:17,760
so where was that place sequence

1464
01:00:17,760 --> 01:00:21,280
so uh yeah we should push

1465
01:00:21,280 --> 01:00:24,559
our 26

1466
01:00:24,559 --> 01:00:28,480
and r27 and then after we finish calling

1467
01:00:28,480 --> 01:00:30,520
those functions we can pop them

1468
01:00:30,520 --> 01:00:34,960
r27 and our 26

1469
01:00:34,960 --> 01:00:37,760
and you see now it plays the sequence

1470
01:00:37,760 --> 01:00:40,400
that we have in the memory

1471
01:00:40,400 --> 01:00:44,160
so um at this point uh i will finish

1472
01:00:44,160 --> 01:00:45,839
with assignment for today

1473
01:00:45,839 --> 01:00:49,200
i will just say what we uh still need to

1474
01:00:49,200 --> 01:00:52,240
do to have a working game so we have

1475
01:00:52,240 --> 01:00:53,280
most of the logic

1476
01:00:53,280 --> 01:00:56,240
in we need to create a function that

1477
01:00:56,240 --> 01:00:56,720
will

1478
01:00:56,720 --> 01:00:59,599
uh extend the sequence so add a new

1479
01:00:59,599 --> 01:01:00,160
value

1480
01:01:00,160 --> 01:01:03,119
at the end of the sequence so add a new

1481
01:01:03,119 --> 01:01:03,599
value

1482
01:01:03,599 --> 01:01:06,160
after the existing values and increase

1483
01:01:06,160 --> 01:01:08,160
sequence lengths by one

1484
01:01:08,160 --> 01:01:11,760
and it brings up an interesting question

1485
01:01:11,760 --> 01:01:14,079
how can we get a random value to add to

1486
01:01:14,079 --> 01:01:14,960
the sequence

1487
01:01:14,960 --> 01:01:18,720
uh on every turn and the easiest way to

1488
01:01:18,720 --> 01:01:20,000
get a random value on

1489
01:01:20,000 --> 01:01:23,760
arduino is just to use the timer and

1490
01:01:23,760 --> 01:01:24,240
read the

1491
01:01:24,240 --> 01:01:26,480
current value of clock cycles and since

1492
01:01:26,480 --> 01:01:27,760
the game is going to

1493
01:01:27,760 --> 01:01:30,559
wait for the user to press a button this

1494
01:01:30,559 --> 01:01:32,559
value will be seemingly random because

1495
01:01:32,559 --> 01:01:35,040
the user presses won't be

1496
01:01:35,040 --> 01:01:38,319
timed exactly the same every time so uh

1497
01:01:38,319 --> 01:01:40,880
extend sequence would just uh we would

1498
01:01:40,880 --> 01:01:42,079
just set up the

1499
01:01:42,079 --> 01:01:44,319
timer number zero and extend sequence

1500
01:01:44,319 --> 01:01:46,000
would just read the value of the

1501
01:01:46,000 --> 01:01:49,760
timer and use that to uh find or to

1502
01:01:49,760 --> 01:01:51,520
figure out the next number to enter the

1503
01:01:51,520 --> 01:01:54,000
sequence and then we also need

1504
01:01:54,000 --> 01:01:57,599
um another function that will uh

1505
01:01:57,599 --> 01:02:01,039
check uh test the user and this function

1506
01:02:01,039 --> 01:02:02,000
will just uh

1507
01:02:02,000 --> 01:02:05,119
call read btn repeatedly it will

1508
01:02:05,119 --> 01:02:07,200
go over the sequence similarly to what

1509
01:02:07,200 --> 01:02:08,400
we did here

1510
01:02:08,400 --> 01:02:11,440
uh call read btn repeatedly and just

1511
01:02:11,440 --> 01:02:12,640
compare the

1512
01:02:12,640 --> 01:02:14,559
value the button that the user pressed

1513
01:02:14,559 --> 01:02:16,880
with the current sequence item

1514
01:02:16,880 --> 01:02:19,039
and if there is a match it will move on

1515
01:02:19,039 --> 01:02:20,000
otherwise

1516
01:02:20,000 --> 01:02:22,160
this is a game over we reset the

1517
01:02:22,160 --> 01:02:23,200
sequence and

1518
01:02:23,200 --> 01:02:25,359
go back to the beginning so that's the

1519
01:02:25,359 --> 01:02:27,440
missing part i guess if we

1520
01:02:27,440 --> 01:02:30,480
uh if we had like 30 more minutes or so

1521
01:02:30,480 --> 01:02:31,920
we could implement it but

1522
01:02:31,920 --> 01:02:34,559
i think i showed you the most important

1523
01:02:34,559 --> 01:02:35,760
parts of

1524
01:02:35,760 --> 01:02:37,760
writing assembly on your own from

1525
01:02:37,760 --> 01:02:40,160
scratch so i think now you should have

1526
01:02:40,160 --> 01:02:42,720
uh mostly everything that you need to do

1527
01:02:42,720 --> 01:02:43,520
it for

1528
01:02:43,520 --> 01:02:46,319
the final project and with that let's

1529
01:02:46,319 --> 01:02:47,039
move to the

1530
01:02:47,039 --> 01:02:54,319
q and a session

