1
00:00:00,000 --> 00:00:08,960
[Music]

2
00:00:08,960 --> 00:00:09,519
hi there

3
00:00:09,519 --> 00:00:12,240
welcome to week three of the hackaday u

4
00:00:12,240 --> 00:00:14,160
serial buses course

5
00:00:14,160 --> 00:00:16,320
this week we're going into one wire

6
00:00:16,320 --> 00:00:17,840
which is a really cool

7
00:00:17,840 --> 00:00:20,960
serial bus used in low power devices and

8
00:00:20,960 --> 00:00:23,039
low power sensors and such

9
00:00:23,039 --> 00:00:25,199
again i'm alexander rousell there's my

10
00:00:25,199 --> 00:00:27,199
email address on screen

11
00:00:27,199 --> 00:00:29,760
and let's jump into it so a quick intro

12
00:00:29,760 --> 00:00:31,279
to what one wire is

13
00:00:31,279 --> 00:00:34,160
it's an asynchronous serial protocol

14
00:00:34,160 --> 00:00:36,640
that was originally developed by dallas

15
00:00:36,640 --> 00:00:38,800
i couldn't find any references exactly

16
00:00:38,800 --> 00:00:40,160
to when it was developed but it was

17
00:00:40,160 --> 00:00:42,719
patented in 1989

18
00:00:42,719 --> 00:00:44,719
it's similar to i squared c in that it

19
00:00:44,719 --> 00:00:46,480
uses an open drain device

20
00:00:46,480 --> 00:00:48,640
connected together in a common bus with

21
00:00:48,640 --> 00:00:51,199
a pull-up resistor so all the devices

22
00:00:51,199 --> 00:00:52,559
connected to the bus

23
00:00:52,559 --> 00:00:54,559
can only pull the bus low and they

24
00:00:54,559 --> 00:00:57,120
require an external pull-up resistor

25
00:00:57,120 --> 00:01:00,079
to keep the bus high this has the same

26
00:01:00,079 --> 00:01:03,920
advantages as it does on i squared c

27
00:01:04,000 --> 00:01:06,000
in that the default state of the bus for

28
00:01:06,000 --> 00:01:07,520
example

29
00:01:07,520 --> 00:01:10,960
is a safe state where things you know

30
00:01:10,960 --> 00:01:14,240
you assume that things aren't connected

31
00:01:14,240 --> 00:01:17,119
uh the power line is optional this is a

32
00:01:17,119 --> 00:01:19,040
really neat thing about one wire and why

33
00:01:19,040 --> 00:01:20,320
it's called one wire

34
00:01:20,320 --> 00:01:21,920
literally all you need to communicate

35
00:01:21,920 --> 00:01:24,320
with it is one wire

36
00:01:24,320 --> 00:01:26,400
which does data and power and of course

37
00:01:26,400 --> 00:01:27,600
a ground

38
00:01:27,600 --> 00:01:29,920
technically it's two wires but ground

39
00:01:29,920 --> 00:01:32,560
you know we usually don't count

40
00:01:32,560 --> 00:01:36,159
so it's uses this thing called parasitic

41
00:01:36,159 --> 00:01:38,400
power mode where it literally will store

42
00:01:38,400 --> 00:01:41,280
charge from the data bus it'll actually

43
00:01:41,280 --> 00:01:42,960
use the high state of the data bus to

44
00:01:42,960 --> 00:01:44,320
store charge and then when it gets

45
00:01:44,320 --> 00:01:45,200
communicated with

46
00:01:45,200 --> 00:01:48,079
it uses that stored charging in order to

47
00:01:48,079 --> 00:01:49,040
respond or

48
00:01:49,040 --> 00:01:52,000
whatever it needs to do every device has

49
00:01:52,000 --> 00:01:52,640
a unique

50
00:01:52,640 --> 00:01:54,799
64-bit serial number this is one of the

51
00:01:54,799 --> 00:01:56,799
distinguishing features of one wire as

52
00:01:56,799 --> 00:01:58,560
opposed to i squared c

53
00:01:58,560 --> 00:02:00,000
where in i squared c you could have

54
00:02:00,000 --> 00:02:01,759
multiple devices that were identical but

55
00:02:01,759 --> 00:02:03,360
they all shared the same y squared c

56
00:02:03,360 --> 00:02:06,320
address on one wire every single

57
00:02:06,320 --> 00:02:07,040
produced

58
00:02:07,040 --> 00:02:10,318
device has a unique 64-bit serial number

59
00:02:10,318 --> 00:02:13,040
so you can have as many of the same as

60
00:02:13,040 --> 00:02:13,520
you

61
00:02:13,520 --> 00:02:15,440
same device as you want on a bus and as

62
00:02:15,440 --> 00:02:17,280
long as you have all the serial numbers

63
00:02:17,280 --> 00:02:20,160
in your code you can communicate to as

64
00:02:20,160 --> 00:02:22,959
many as you want

65
00:02:22,959 --> 00:02:24,480
there's lots of different devices

66
00:02:24,480 --> 00:02:27,200
available there's you know often eeproms

67
00:02:27,200 --> 00:02:28,879
up to 64k

68
00:02:28,879 --> 00:02:31,519
temperature sensors real-time clocks

69
00:02:31,519 --> 00:02:33,440
battery monitoring which can be really

70
00:02:33,440 --> 00:02:35,519
useful in low power devices

71
00:02:35,519 --> 00:02:37,760
and acting just as a silicon serial

72
00:02:37,760 --> 00:02:40,160
number literally just having that 64-bit

73
00:02:40,160 --> 00:02:41,440
serial number

74
00:02:41,440 --> 00:02:43,599
can be used to identify an individual

75
00:02:43,599 --> 00:02:46,080
board that gets installed into

76
00:02:46,080 --> 00:02:47,760
you know a device somewhere in case you

77
00:02:47,760 --> 00:02:50,560
need to know exactly which board it is

78
00:02:50,560 --> 00:02:52,160
make sure it's been swapped out with the

79
00:02:52,160 --> 00:02:54,080
correct board um

80
00:02:54,080 --> 00:02:56,080
validate that it is a valid device that

81
00:02:56,080 --> 00:02:58,080
was manufactured by you that sort of

82
00:02:58,080 --> 00:02:59,760
thing

83
00:02:59,760 --> 00:03:02,879
so let's jump into the hardwell hardware

84
00:03:02,879 --> 00:03:04,959
level stuff

85
00:03:04,959 --> 00:03:07,680
it's similar to i squared c so they all

86
00:03:07,680 --> 00:03:09,760
connected with an open drain transistor

87
00:03:09,760 --> 00:03:11,760
and a fairly strong pull up resistor

88
00:03:11,760 --> 00:03:14,640
keeps the bus high when it is idle

89
00:03:14,640 --> 00:03:17,120
unlike i squared c where you'd see 10k

90
00:03:17,120 --> 00:03:18,640
to 47k

91
00:03:18,640 --> 00:03:20,640
with one wire you're likely to see sort

92
00:03:20,640 --> 00:03:23,360
of 4.7 to 22k

93
00:03:23,360 --> 00:03:26,400
slightly stronger pull up devices can

94
00:03:26,400 --> 00:03:28,159
optionally connect to a power bus so

95
00:03:28,159 --> 00:03:30,560
they can also connect to vcc and act in

96
00:03:30,560 --> 00:03:32,159
sort of a three-wire mode where they

97
00:03:32,159 --> 00:03:32,720
have

98
00:03:32,720 --> 00:03:35,760
power data and ground or they can just

99
00:03:35,760 --> 00:03:38,239
act parasitically and store

100
00:03:38,239 --> 00:03:40,319
power from the actual data bus in an

101
00:03:40,319 --> 00:03:42,239
internal capacitor

102
00:03:42,239 --> 00:03:44,159
the bus runs at a much slower rate than

103
00:03:44,159 --> 00:03:46,000
i squared c by default about

104
00:03:46,000 --> 00:03:49,920
16.7 kilobits per second um

105
00:03:49,920 --> 00:03:51,519
there is an overdrive mode where the

106
00:03:51,519 --> 00:03:53,439
speed is multiplied by 10

107
00:03:53,439 --> 00:03:56,080
so you get 167 kilobits per second which

108
00:03:56,080 --> 00:03:57,920
is slightly faster than i square

109
00:03:57,920 --> 00:04:01,519
c's default 100 kilohertz mode

110
00:04:01,519 --> 00:04:03,439
but you know not super fast data rate

111
00:04:03,439 --> 00:04:04,640
but reliable

112
00:04:04,640 --> 00:04:07,920
and low power the only limiting factor

113
00:04:07,920 --> 00:04:09,599
to the number of devices on a device is

114
00:04:09,599 --> 00:04:10,640
capacitance

115
00:04:10,640 --> 00:04:12,879
just like with i squared c the more i

116
00:04:12,879 --> 00:04:14,239
devices you have on the bus the more

117
00:04:14,239 --> 00:04:15,680
capacitance you have

118
00:04:15,680 --> 00:04:17,680
that can start to cause problems

119
00:04:17,680 --> 00:04:18,880
technically there is

120
00:04:18,880 --> 00:04:21,759
1.4 times 10 to the 19 unique serial

121
00:04:21,759 --> 00:04:23,120
numbers so they're not going to run out

122
00:04:23,120 --> 00:04:26,880
of serial numbers anytime soon

123
00:04:27,360 --> 00:04:29,440
so the parasitic power mode which is a

124
00:04:29,440 --> 00:04:32,720
defining feature of one wire

125
00:04:32,720 --> 00:04:34,560
because the power line is optional

126
00:04:34,560 --> 00:04:36,560
devices need some way to store power for

127
00:04:36,560 --> 00:04:38,400
when the bus is pulled low

128
00:04:38,400 --> 00:04:40,320
because just like an i squared c the bus

129
00:04:40,320 --> 00:04:41,520
being pulled low

130
00:04:41,520 --> 00:04:44,240
is how you communicate so a diode

131
00:04:44,240 --> 00:04:46,160
connects the data line to an internal

132
00:04:46,160 --> 00:04:49,360
capacitor typically about 80 picofarads

133
00:04:49,360 --> 00:04:50,800
and this value is kept small

134
00:04:50,800 --> 00:04:52,560
intentionally to avoid loading the bus

135
00:04:52,560 --> 00:04:54,000
with too much capacitance of course you

136
00:04:54,000 --> 00:04:55,680
could whack a great big capacitor in

137
00:04:55,680 --> 00:04:56,320
there

138
00:04:56,320 --> 00:04:57,280
that's going to affect your

139
00:04:57,280 --> 00:04:58,960
communication on the data line so they

140
00:04:58,960 --> 00:05:01,039
use as little capacitance as they need

141
00:05:01,039 --> 00:05:01,759
to store

142
00:05:01,759 --> 00:05:04,720
some charge in order to respond to this

143
00:05:04,720 --> 00:05:05,280
bit

144
00:05:05,280 --> 00:05:06,639
and then you know the next time the bus

145
00:05:06,639 --> 00:05:08,000
goes higher we store a little more

146
00:05:08,000 --> 00:05:10,000
charge we respond to the next bit that

147
00:05:10,000 --> 00:05:11,840
sort of thing

148
00:05:11,840 --> 00:05:15,280
so yeah the power the

149
00:05:15,280 --> 00:05:18,720
bus logic when the bus is pulled low

150
00:05:18,720 --> 00:05:21,199
or of course uh the one wire device

151
00:05:21,199 --> 00:05:22,800
itself has to be able to pull

152
00:05:22,800 --> 00:05:24,880
the bus low so it uses the stored charge

153
00:05:24,880 --> 00:05:27,440
and the capacitor to do that

154
00:05:27,440 --> 00:05:30,080
yeah the resistors are typically smaller

155
00:05:30,080 --> 00:05:31,360
as i said typically

156
00:05:31,360 --> 00:05:35,440
0.2 k to 2.2 k so it varies but again

157
00:05:35,440 --> 00:05:35,919
it's

158
00:05:35,919 --> 00:05:37,759
quite usually quite a bit of a stronger

159
00:05:37,759 --> 00:05:39,520
pull up especially if it's operating in

160
00:05:39,520 --> 00:05:41,120
parasitic power mode

161
00:05:41,120 --> 00:05:43,759
that way it charges that capacitor

162
00:05:43,759 --> 00:05:44,400
faster

163
00:05:44,400 --> 00:05:46,000
and you can handle more devices on the

164
00:05:46,000 --> 00:05:48,320
bus more easily

165
00:05:48,320 --> 00:05:50,400
so as you can see it's a pretty simple

166
00:05:50,400 --> 00:05:51,680
device uh

167
00:05:51,680 --> 00:05:54,560
we've got owd which stands for one wire

168
00:05:54,560 --> 00:05:56,319
data

169
00:05:56,319 --> 00:06:00,000
ground in vcc that one wire data

170
00:06:00,000 --> 00:06:01,440
can be pulled to ground by that

171
00:06:01,440 --> 00:06:03,680
transistor you turn that transistor

172
00:06:03,680 --> 00:06:04,080
there

173
00:06:04,080 --> 00:06:07,280
on and the drain will be connected to

174
00:06:07,280 --> 00:06:08,960
the source and it'll connect it to

175
00:06:08,960 --> 00:06:10,880
ground

176
00:06:10,880 --> 00:06:14,240
it's got that diode so that when the bus

177
00:06:14,240 --> 00:06:17,520
goes low it won't immediately drain that

178
00:06:17,520 --> 00:06:20,000
internal capacitor it can be used to

179
00:06:20,000 --> 00:06:22,000
for example turn that transistor on or

180
00:06:22,000 --> 00:06:23,440
sample the state of the bus

181
00:06:23,440 --> 00:06:25,680
it's got an internal vcc which is

182
00:06:25,680 --> 00:06:27,759
derived from that capacitor or

183
00:06:27,759 --> 00:06:29,840
from vcc itself which powers the

184
00:06:29,840 --> 00:06:32,479
internal logic whatever that may be

185
00:06:32,479 --> 00:06:34,000
and then it's got a ground wire and

186
00:06:34,000 --> 00:06:36,160
that's it so pretty simple

187
00:06:36,160 --> 00:06:38,560
so why do we have this external strong

188
00:06:38,560 --> 00:06:40,400
pull-up being so strong well what

189
00:06:40,400 --> 00:06:42,160
happens if the one-wire device needs

190
00:06:42,160 --> 00:06:44,479
more current than the bus can provide

191
00:06:44,479 --> 00:06:46,639
because we have that pull-up resistor it

192
00:06:46,639 --> 00:06:48,000
limits the amount of current that can

193
00:06:48,000 --> 00:06:50,400
flow into the device some devices might

194
00:06:50,400 --> 00:06:53,039
need a peak current 5 to 10 milliamps

195
00:06:53,039 --> 00:06:54,639
if it's doing a temperature measurement

196
00:06:54,639 --> 00:06:56,960
or some a to d or d to a conversion

197
00:06:56,960 --> 00:06:58,240
something like that

198
00:06:58,240 --> 00:07:00,319
much more than most data lines are

199
00:07:00,319 --> 00:07:02,160
configured to provide

200
00:07:02,160 --> 00:07:04,080
so in this case the controller can

201
00:07:04,080 --> 00:07:05,280
connect vcc

202
00:07:05,280 --> 00:07:06,800
directly to the data line for a

203
00:07:06,800 --> 00:07:09,120
predetermined amount of time

204
00:07:09,120 --> 00:07:10,880
this is done by using an external

205
00:07:10,880 --> 00:07:12,960
transistor typically or configuring the

206
00:07:12,960 --> 00:07:15,120
output pin to be a regular output pin

207
00:07:15,120 --> 00:07:16,400
instead of an open drain and then

208
00:07:16,400 --> 00:07:18,720
setting the output high

209
00:07:18,720 --> 00:07:20,479
this is effectively the same thing as

210
00:07:20,479 --> 00:07:22,080
enabling an external transistor it

211
00:07:22,080 --> 00:07:24,160
literally just connects vcc directly to

212
00:07:24,160 --> 00:07:25,440
the data line

213
00:07:25,440 --> 00:07:27,440
most microcontroller gpio pins are

214
00:07:27,440 --> 00:07:31,440
capable of sourcing up to 20 milliamps

215
00:07:31,440 --> 00:07:33,680
so if we're going to use an external

216
00:07:33,680 --> 00:07:35,120
transistor this is what that could look

217
00:07:35,120 --> 00:07:35,680
like

218
00:07:35,680 --> 00:07:38,800
so here's a sort of typical bus we've

219
00:07:38,800 --> 00:07:40,639
got our microcontroller and we've got a

220
00:07:40,639 --> 00:07:42,840
whole bunch of devices

221
00:07:42,840 --> 00:07:46,639
ds-24 serial number a temperature probe

222
00:07:46,639 --> 00:07:47,120
4k

223
00:07:47,120 --> 00:07:50,400
eeprom uh battery fuel gauge

224
00:07:50,400 --> 00:07:51,919
they're all connected to that same one

225
00:07:51,919 --> 00:07:53,919
wired data and they're all connected to

226
00:07:53,919 --> 00:07:55,199
ground and that's it

227
00:07:55,199 --> 00:07:57,199
so all of these devices in this example

228
00:07:57,199 --> 00:07:58,960
are running off of the parasitic power

229
00:07:58,960 --> 00:08:00,000
mode

230
00:08:00,000 --> 00:08:01,759
now for some of these like the

231
00:08:01,759 --> 00:08:03,360
temperature probe or the battery fuel

232
00:08:03,360 --> 00:08:04,479
gauge in order to do

233
00:08:04,479 --> 00:08:06,479
measurements they might need more than

234
00:08:06,479 --> 00:08:08,879
what that pull-up resistor can provide

235
00:08:08,879 --> 00:08:10,560
in that case the microcontroller can

236
00:08:10,560 --> 00:08:12,400
switch on that resistor or that

237
00:08:12,400 --> 00:08:14,639
transistor you see

238
00:08:14,639 --> 00:08:16,400
just to the right of vcc there and that

239
00:08:16,400 --> 00:08:18,479
will literally connect vcc to the one

240
00:08:18,479 --> 00:08:19,680
wire data bus

241
00:08:19,680 --> 00:08:22,319
and temporarily turn the data bus into a

242
00:08:22,319 --> 00:08:23,599
power line

243
00:08:23,599 --> 00:08:25,440
so that the devices can draw more

244
00:08:25,440 --> 00:08:26,720
current

245
00:08:26,720 --> 00:08:29,680
it's a really elegant way to do it that

246
00:08:29,680 --> 00:08:30,240
way you

247
00:08:30,240 --> 00:08:31,599
keep all the complexity near the

248
00:08:31,599 --> 00:08:33,839
microcontroller and then down the line

249
00:08:33,839 --> 00:08:35,120
which could be

250
00:08:35,120 --> 00:08:36,880
you know a fairly long distance in the

251
00:08:36,880 --> 00:08:38,240
case of some of these things like a

252
00:08:38,240 --> 00:08:39,599
temperature probe

253
00:08:39,599 --> 00:08:40,958
it might be connected to a wire that's

254
00:08:40,958 --> 00:08:42,880
sort of snaking through your device

255
00:08:42,880 --> 00:08:44,159
somewhere else

256
00:08:44,159 --> 00:08:47,040
so we can send you know strong power

257
00:08:47,040 --> 00:08:49,200
down that line

258
00:08:49,200 --> 00:08:50,959
and overcome any capacitance on the

259
00:08:50,959 --> 00:08:52,800
cable or whatever and we do it for a

260
00:08:52,800 --> 00:08:54,080
predetermined amount of time

261
00:08:54,080 --> 00:08:57,040
so we you know we might tell it do a

262
00:08:57,040 --> 00:08:58,160
temperature measurement

263
00:08:58,160 --> 00:08:59,519
and we know from looking at the data

264
00:08:59,519 --> 00:09:01,200
sheet okay it needs

265
00:09:01,200 --> 00:09:03,279
50 milliseconds of strong pull-up or

266
00:09:03,279 --> 00:09:04,720
whatever it may be

267
00:09:04,720 --> 00:09:06,480
we turn on the strong pull-up for that

268
00:09:06,480 --> 00:09:08,640
long and then at the end we turn it off

269
00:09:08,640 --> 00:09:12,080
and we get the results back

270
00:09:13,120 --> 00:09:15,120
so let's look at the protocol level the

271
00:09:15,120 --> 00:09:16,640
hardware level is pretty simple so let's

272
00:09:16,640 --> 00:09:18,480
jump into the protocol

273
00:09:18,480 --> 00:09:21,920
so one wire signaling because one wire

274
00:09:21,920 --> 00:09:22,959
is asynchronous

275
00:09:22,959 --> 00:09:25,360
all communication is done in terms of

276
00:09:25,360 --> 00:09:26,160
absolute

277
00:09:26,160 --> 00:09:29,360
timing so instead of being connected to

278
00:09:29,360 --> 00:09:30,240
a clock

279
00:09:30,240 --> 00:09:33,279
everything is done based on real

280
00:09:33,279 --> 00:09:35,519
amounts of time passing 5 microseconds

281
00:09:35,519 --> 00:09:37,440
10 microseconds it's very specifically

282
00:09:37,440 --> 00:09:38,880
defined

283
00:09:38,880 --> 00:09:41,360
every one wire bit is sent within a

284
00:09:41,360 --> 00:09:42,640
certain amount of time

285
00:09:42,640 --> 00:09:44,480
typically called the frame time or the

286
00:09:44,480 --> 00:09:45,920
bit frame time

287
00:09:45,920 --> 00:09:47,839
so each bit has to be sent within a

288
00:09:47,839 --> 00:09:50,080
certain period of time

289
00:09:50,080 --> 00:09:51,760
for devices running at the normal speed

290
00:09:51,760 --> 00:09:54,160
this frame time is about 60 microseconds

291
00:09:54,160 --> 00:09:57,120
roughly the period of a 16.7 kilohertz

292
00:09:57,120 --> 00:09:58,560
clock

293
00:09:58,560 --> 00:10:01,920
timing is not super precise because the

294
00:10:01,920 --> 00:10:04,800
peripheral devices use a simple rc timer

295
00:10:04,800 --> 00:10:06,480
internally to measure time

296
00:10:06,480 --> 00:10:08,720
they're not very precise they vary quite

297
00:10:08,720 --> 00:10:10,160
a bit over temperature

298
00:10:10,160 --> 00:10:12,560
so these timings are important to meet

299
00:10:12,560 --> 00:10:13,360
but

300
00:10:13,360 --> 00:10:15,360
they're not so strict that if you're off

301
00:10:15,360 --> 00:10:16,880
a few microseconds in either direction

302
00:10:16,880 --> 00:10:18,240
it's not going to work

303
00:10:18,240 --> 00:10:19,920
they have quite a bit of tolerance built

304
00:10:19,920 --> 00:10:21,279
in

305
00:10:21,279 --> 00:10:24,079
all communication starts at 16.7

306
00:10:24,079 --> 00:10:25,920
kilohertz and can optionally enter

307
00:10:25,920 --> 00:10:28,160
overdrive mode with a special command

308
00:10:28,160 --> 00:10:30,000
and again when we're in overdrive mode

309
00:10:30,000 --> 00:10:31,680
the bit time

310
00:10:31,680 --> 00:10:33,519
is 10 times faster roughly 6

311
00:10:33,519 --> 00:10:36,720
microseconds instead of 60.

312
00:10:36,720 --> 00:10:39,040
so there's something called the sample

313
00:10:39,040 --> 00:10:40,000
period

314
00:10:40,000 --> 00:10:42,560
every time the bus is pulled low by the

315
00:10:42,560 --> 00:10:43,360
controller

316
00:10:43,360 --> 00:10:45,120
so no matter what's going to happen next

317
00:10:45,120 --> 00:10:47,360
be it a read or a write a timer starts

318
00:10:47,360 --> 00:10:49,200
inside the device

319
00:10:49,200 --> 00:10:51,680
after roughly 15 microseconds the device

320
00:10:51,680 --> 00:10:54,000
samples the state of the bus

321
00:10:54,000 --> 00:10:57,519
so after that amount of time has passed

322
00:10:57,519 --> 00:10:59,360
it looks at the bus to see what's there

323
00:10:59,360 --> 00:11:00,079
if the bus is

324
00:11:00,079 --> 00:11:03,120
high it's reading a one if it's a low

325
00:11:03,120 --> 00:11:06,000
it's a zero because the timer is

326
00:11:06,000 --> 00:11:08,320
imprecise that sample time is supposed

327
00:11:08,320 --> 00:11:09,360
to happen

328
00:11:09,360 --> 00:11:11,279
it can happen as early as 15

329
00:11:11,279 --> 00:11:12,560
microseconds

330
00:11:12,560 --> 00:11:15,360
it can take as long as 60 microseconds

331
00:11:15,360 --> 00:11:16,480
so

332
00:11:16,480 --> 00:11:19,279
we usually if we're sending a zero we'll

333
00:11:19,279 --> 00:11:21,040
keep it low that entire time and if

334
00:11:21,040 --> 00:11:22,560
we're sending a one

335
00:11:22,560 --> 00:11:25,040
we'll keep the bus low just long enough

336
00:11:25,040 --> 00:11:27,600
to start that internal timer and then

337
00:11:27,600 --> 00:11:31,040
let the bus return to high

338
00:11:31,200 --> 00:11:34,800
so that 16.7 kilobits per second

339
00:11:34,800 --> 00:11:37,440
speed is an upper limit on the speed of

340
00:11:37,440 --> 00:11:38,880
communications

341
00:11:38,880 --> 00:11:40,880
you can go a little bit slower than that

342
00:11:40,880 --> 00:11:43,120
but typically you can't go faster than

343
00:11:43,120 --> 00:11:44,720
that or else the devices will

344
00:11:44,720 --> 00:11:47,120
respond they have filters to filter up

345
00:11:47,120 --> 00:11:48,480
transient spikes

346
00:11:48,480 --> 00:11:51,120
so if you go too fast they won't be able

347
00:11:51,120 --> 00:11:52,000
to

348
00:11:52,000 --> 00:11:53,920
communicate back or acknowledge you

349
00:11:53,920 --> 00:11:55,600
unless you're in overdrive mode in which

350
00:11:55,600 --> 00:11:57,200
case that's a whole separate thing they

351
00:11:57,200 --> 00:11:59,120
turn off their internal filters usually

352
00:11:59,120 --> 00:12:01,839
and then they can respond more quickly

353
00:12:01,839 --> 00:12:03,760
so there's no issue with going slower

354
00:12:03,760 --> 00:12:05,360
than that as long as you stay under the

355
00:12:05,360 --> 00:12:08,160
maximum signaling time per bit

356
00:12:08,160 --> 00:12:09,600
so this is where it gets a little bit

357
00:12:09,600 --> 00:12:11,600
sort of hand wavy that

358
00:12:11,600 --> 00:12:13,760
each bit does not necessarily have to

359
00:12:13,760 --> 00:12:15,920
take up the same amount of time

360
00:12:15,920 --> 00:12:18,000
they sort of have an upper maximum of

361
00:12:18,000 --> 00:12:20,720
120 microseconds

362
00:12:20,720 --> 00:12:22,800
where we start with that pulling the bus

363
00:12:22,800 --> 00:12:23,920
low for five

364
00:12:23,920 --> 00:12:26,079
to ten microseconds then it reads the

365
00:12:26,079 --> 00:12:26,959
state of the bus

366
00:12:26,959 --> 00:12:28,880
then we have a little bit of time after

367
00:12:28,880 --> 00:12:30,399
that where the bus

368
00:12:30,399 --> 00:12:33,120
is guaranteed to be high so that the

369
00:12:33,120 --> 00:12:34,800
device can charge up the internal

370
00:12:34,800 --> 00:12:36,240
capacitor

371
00:12:36,240 --> 00:12:39,040
these times can vary a little bit and as

372
00:12:39,040 --> 00:12:39,519
you'll see

373
00:12:39,519 --> 00:12:42,240
i typically design around sort of the

374
00:12:42,240 --> 00:12:44,000
maximum lengths

375
00:12:44,000 --> 00:12:46,000
so that it's sort of guaranteed to work

376
00:12:46,000 --> 00:12:49,200
even if it's a bit slower

377
00:12:49,360 --> 00:12:51,360
the only critical really critical time

378
00:12:51,360 --> 00:12:53,200
is the time between the bus going low

379
00:12:53,200 --> 00:12:55,040
and the bit being sampled

380
00:12:55,040 --> 00:12:57,760
so if you're trying to send a one for

381
00:12:57,760 --> 00:12:59,680
example you have to make sure that

382
00:12:59,680 --> 00:13:01,519
you've let go of the bus

383
00:13:01,519 --> 00:13:04,720
before 15 microseconds have passed

384
00:13:04,720 --> 00:13:06,560
if you hold it low any longer than that

385
00:13:06,560 --> 00:13:08,320
it's going to read it as zero

386
00:13:08,320 --> 00:13:09,920
or it could potentially read it as a

387
00:13:09,920 --> 00:13:11,760
zero as i said each

388
00:13:11,760 --> 00:13:13,040
device is going to have slightly

389
00:13:13,040 --> 00:13:14,720
different timing because of that rc

390
00:13:14,720 --> 00:13:16,000
oscillator

391
00:13:16,000 --> 00:13:19,040
so if you want to send a zero

392
00:13:19,040 --> 00:13:21,519
we might hold it for even longer than 60

393
00:13:21,519 --> 00:13:23,519
microseconds but if we want to send a

394
00:13:23,519 --> 00:13:25,440
one we might only hold it low for

395
00:13:25,440 --> 00:13:28,560
five or ten microseconds yeah many data

396
00:13:28,560 --> 00:13:30,240
sheets will recommend that the total bit

397
00:13:30,240 --> 00:13:33,120
time not exceed 120 microseconds

398
00:13:33,120 --> 00:13:36,000
that gives it time to recover afterwards

399
00:13:36,000 --> 00:13:37,440
so let's actually look at a practical

400
00:13:37,440 --> 00:13:40,480
example of what this looks like

401
00:13:40,480 --> 00:13:42,399
to send a one the controller pulls the

402
00:13:42,399 --> 00:13:43,600
bus low for at least

403
00:13:43,600 --> 00:13:45,600
one microsecond that's the very very

404
00:13:45,600 --> 00:13:47,760
minimum typically they'll say about

405
00:13:47,760 --> 00:13:49,760
five microseconds anywhere between one

406
00:13:49,760 --> 00:13:51,920
and ten microseconds

407
00:13:51,920 --> 00:13:54,320
it must not keep the bus low longer than

408
00:13:54,320 --> 00:13:56,240
15 microseconds or it'll be interpreted

409
00:13:56,240 --> 00:13:57,920
as a zero so this is what that looks

410
00:13:57,920 --> 00:13:58,639
like

411
00:13:58,639 --> 00:14:01,279
over on the left there you can see the

412
00:14:01,279 --> 00:14:02,160
bus gets pulled

413
00:14:02,160 --> 00:14:05,440
low it's pulled low for

414
00:14:05,440 --> 00:14:08,160
about eight to ten microseconds and then

415
00:14:08,160 --> 00:14:09,120
it's high

416
00:14:09,120 --> 00:14:11,920
for quite a while about 110 microseconds

417
00:14:11,920 --> 00:14:15,120
so that's that full 120 microsecond

418
00:14:15,120 --> 00:14:17,519
bit period that we were talking about

419
00:14:17,519 --> 00:14:18,160
that's a

420
00:14:18,160 --> 00:14:20,160
one being sent that's all it is you pull

421
00:14:20,160 --> 00:14:22,079
the bus low and you let go at a certain

422
00:14:22,079 --> 00:14:23,440
time

423
00:14:23,440 --> 00:14:25,199
uh it allows the pull-up resistor to

424
00:14:25,199 --> 00:14:26,720
bring the bus back to the high state and

425
00:14:26,720 --> 00:14:28,560
then it waits until that bit frame

426
00:14:28,560 --> 00:14:31,839
time is over at least 55 microseconds

427
00:14:31,839 --> 00:14:32,399
later

428
00:14:32,399 --> 00:14:35,760
so that's 55 microseconds plus that 10

429
00:14:35,760 --> 00:14:37,279
microseconds we had the bus

430
00:14:37,279 --> 00:14:40,320
low so again at least

431
00:14:40,320 --> 00:14:44,240
sort of 60 to 65 microseconds per bit

432
00:14:44,240 --> 00:14:46,480
which again works out to the 16.7

433
00:14:46,480 --> 00:14:47,680
kilobits per second

434
00:14:47,680 --> 00:14:50,160
clock rate clock rate because there's no

435
00:14:50,160 --> 00:14:51,600
actual clock

436
00:14:51,600 --> 00:14:54,639
sending a zero we pull the bus low for

437
00:14:54,639 --> 00:14:55,120
at least

438
00:14:55,120 --> 00:14:57,040
15 microseconds typically up to a

439
00:14:57,040 --> 00:14:59,760
maximum of 120 microseconds

440
00:14:59,760 --> 00:15:02,560
so here's a zero being sent we pull the

441
00:15:02,560 --> 00:15:03,600
bus low

442
00:15:03,600 --> 00:15:07,199
we hold it low for let's see 10 20 30 40

443
00:15:07,199 --> 00:15:08,880
50 60 70 about 80

444
00:15:08,880 --> 00:15:12,000
85 microseconds well long enough for it

445
00:15:12,000 --> 00:15:14,000
to detect that it's a zero

446
00:15:14,000 --> 00:15:16,079
then we release it and let the bus stay

447
00:15:16,079 --> 00:15:17,199
high until that

448
00:15:17,199 --> 00:15:20,000
120 microsecond bit frame is over again

449
00:15:20,000 --> 00:15:22,000
that gives the device time to charge up

450
00:15:22,000 --> 00:15:25,440
its internal capacitor a little bit

451
00:15:25,440 --> 00:15:27,760
um yeah it's going to sample the boss

452
00:15:27,760 --> 00:15:29,920
about 15 to 60 microseconds

453
00:15:29,920 --> 00:15:33,680
so well we make sure that we uh

454
00:15:33,680 --> 00:15:35,440
we make sure that we keep it low for

455
00:15:35,440 --> 00:15:37,759
that entire time

456
00:15:37,759 --> 00:15:42,000
and then we wait until 120 microseconds

457
00:15:42,000 --> 00:15:45,040
for the next bit so reading a bit

458
00:15:45,040 --> 00:15:47,440
this is sort of the opposite of course

459
00:15:47,440 --> 00:15:49,040
in order to read a bit

460
00:15:49,040 --> 00:15:51,279
same with i squared c you must have sent

461
00:15:51,279 --> 00:15:52,800
a command to the peripheral

462
00:15:52,800 --> 00:15:54,880
that requires a response so the

463
00:15:54,880 --> 00:15:57,440
peripheral must be expecting read slots

464
00:15:57,440 --> 00:15:59,120
or else it's going to just think you're

465
00:15:59,120 --> 00:16:01,920
sending more data

466
00:16:01,920 --> 00:16:04,560
so you issue something called a read

467
00:16:04,560 --> 00:16:05,440
slot

468
00:16:05,440 --> 00:16:07,519
this is signaled by it's just like

469
00:16:07,519 --> 00:16:08,480
signaling any

470
00:16:08,480 --> 00:16:10,959
any other bit you pull the device you

471
00:16:10,959 --> 00:16:13,440
pull the bus low for five microseconds

472
00:16:13,440 --> 00:16:16,079
and then you let go the peripheral

473
00:16:16,079 --> 00:16:18,560
device will see the bus being pulled low

474
00:16:18,560 --> 00:16:20,880
if it wants to send a one to you it does

475
00:16:20,880 --> 00:16:22,560
nothing it lets the bus

476
00:16:22,560 --> 00:16:25,759
be pulled back to the high state

477
00:16:25,759 --> 00:16:28,399
after we let go of the bus we wait 10 to

478
00:16:28,399 --> 00:16:29,839
15 microseconds

479
00:16:29,839 --> 00:16:32,160
up to 60 microseconds and then we sample

480
00:16:32,160 --> 00:16:34,320
the state of the bus

481
00:16:34,320 --> 00:16:36,880
if it wants to send to zero it sees us

482
00:16:36,880 --> 00:16:37,440
pulling

483
00:16:37,440 --> 00:16:39,600
the bus low and then it holds it low

484
00:16:39,600 --> 00:16:41,199
after we let go

485
00:16:41,199 --> 00:16:42,720
and we wait you know five or ten

486
00:16:42,720 --> 00:16:45,440
microseconds sample the state of the bus

487
00:16:45,440 --> 00:16:47,360
and then we can see that the bus is

488
00:16:47,360 --> 00:16:48,959
still low so

489
00:16:48,959 --> 00:16:51,120
the peripheral must be pulling it low

490
00:16:51,120 --> 00:16:53,920
therefore it wants to send to zero

491
00:16:53,920 --> 00:16:55,120
we'll sample the state of the bias

492
00:16:55,120 --> 00:16:57,199
around 15 microseconds after it issues

493
00:16:57,199 --> 00:16:58,399
the read slot when we're

494
00:16:58,399 --> 00:17:00,079
reading from the peripheral we kind of

495
00:17:00,079 --> 00:17:02,000
want to attend towards

496
00:17:02,000 --> 00:17:05,280
the minimum amount of time um because

497
00:17:05,280 --> 00:17:07,199
it's possible that if we wait too long

498
00:17:07,199 --> 00:17:09,039
to sample that it might have let

499
00:17:09,039 --> 00:17:10,799
go of the bus by then so we kind of want

500
00:17:10,799 --> 00:17:12,559
to keep it on the sort of shorter end of

501
00:17:12,559 --> 00:17:13,760
things

502
00:17:13,760 --> 00:17:15,439
and of course it's just the state of the

503
00:17:15,439 --> 00:17:17,359
bus corresponds to the bit being sent by

504
00:17:17,359 --> 00:17:19,839
the peripheral

505
00:17:20,319 --> 00:17:22,480
it looks quite similar to writing bits

506
00:17:22,480 --> 00:17:24,000
if you're just looking at the bus and

507
00:17:24,000 --> 00:17:25,359
you don't know what's going on

508
00:17:25,359 --> 00:17:26,959
it's almost impossible to tell who's

509
00:17:26,959 --> 00:17:28,960
talking

510
00:17:28,960 --> 00:17:30,799
same with i squared c unless you look at

511
00:17:30,799 --> 00:17:32,720
the address and see if it's a read or a

512
00:17:32,720 --> 00:17:34,240
write bit like with i squared c you

513
00:17:34,240 --> 00:17:35,520
wouldn't really be able to tell what's

514
00:17:35,520 --> 00:17:36,640
going on which direction the

515
00:17:36,640 --> 00:17:38,240
communication is going

516
00:17:38,240 --> 00:17:40,160
but the devices on each end know what's

517
00:17:40,160 --> 00:17:41,360
going on

518
00:17:41,360 --> 00:17:44,559
so there's a one bit being read the

519
00:17:44,559 --> 00:17:46,640
controller pulls the bus low for that

520
00:17:46,640 --> 00:17:48,559
you know five or ten microseconds

521
00:17:48,559 --> 00:17:51,919
let's go later on it pulls it low and as

522
00:17:51,919 --> 00:17:52,960
you can see it gets

523
00:17:52,960 --> 00:17:56,160
held low by the device and that's a zero

524
00:17:56,160 --> 00:17:57,760
and then we see another zero being

525
00:17:57,760 --> 00:18:00,000
pulled so in all three of these

526
00:18:00,000 --> 00:18:02,400
bits the controller is only holding the

527
00:18:02,400 --> 00:18:04,320
bus low for that little sliver that you

528
00:18:04,320 --> 00:18:05,360
see at the one

529
00:18:05,360 --> 00:18:07,760
bit then the peripheral takes over and

530
00:18:07,760 --> 00:18:08,960
holds the bus low

531
00:18:08,960 --> 00:18:12,160
for the remainder of that bit time it's

532
00:18:12,160 --> 00:18:13,440
all clear as mud

533
00:18:13,440 --> 00:18:15,360
i know there's a lot of numbers flying

534
00:18:15,360 --> 00:18:16,559
around but let's just sort of look at

535
00:18:16,559 --> 00:18:18,320
the maximums and minimums for each of

536
00:18:18,320 --> 00:18:19,919
these so

537
00:18:19,919 --> 00:18:22,640
the amount of time you need to hold low

538
00:18:22,640 --> 00:18:24,160
to write a zero

539
00:18:24,160 --> 00:18:28,080
is between 60 and 100 120 microseconds

540
00:18:28,080 --> 00:18:30,880
in order to write a 1 it's between 5 and

541
00:18:30,880 --> 00:18:32,559
15 microseconds

542
00:18:32,559 --> 00:18:36,000
pretty simple if we're reading if we

543
00:18:36,000 --> 00:18:38,640
are reading low we have to wait at least

544
00:18:38,640 --> 00:18:41,440
5 to 15 microseconds before sampling the

545
00:18:41,440 --> 00:18:43,039
bus

546
00:18:43,039 --> 00:18:45,679
uh sorry that's how long we hold the bus

547
00:18:45,679 --> 00:18:46,080
low

548
00:18:46,080 --> 00:18:48,080
we hold the bus low for five to 15

549
00:18:48,080 --> 00:18:49,520
microseconds

550
00:18:49,520 --> 00:18:53,520
and then we sample the bus less than 15

551
00:18:53,520 --> 00:18:55,200
microseconds later basically is what

552
00:18:55,200 --> 00:18:57,280
that's saying

553
00:18:57,280 --> 00:19:00,000
so the only other important part of the

554
00:19:00,000 --> 00:19:02,000
boss besides reading and writing bits is

555
00:19:02,000 --> 00:19:05,919
the reset and presence pulse

556
00:19:06,000 --> 00:19:08,880
when we first connect to a device or

557
00:19:08,880 --> 00:19:10,080
before we do

558
00:19:10,080 --> 00:19:14,000
any commands at all we issue a reset

559
00:19:14,000 --> 00:19:17,440
that is holding the bus low for at least

560
00:19:17,440 --> 00:19:19,679
480 microseconds now that's a pretty

561
00:19:19,679 --> 00:19:20,480
long time

562
00:19:20,480 --> 00:19:21,840
compared to what we've been talking

563
00:19:21,840 --> 00:19:24,559
about this will

564
00:19:24,559 --> 00:19:26,799
actually drain the capacitor inside the

565
00:19:26,799 --> 00:19:28,720
device if it's running on parasitic

566
00:19:28,720 --> 00:19:29,520
power mode

567
00:19:29,520 --> 00:19:32,160
and it'll do a full power on reset if

568
00:19:32,160 --> 00:19:34,000
the device is being powered externally

569
00:19:34,000 --> 00:19:35,600
it'll act as if it's done a

570
00:19:35,600 --> 00:19:38,480
power on reset it'll see this low period

571
00:19:38,480 --> 00:19:40,160
so as you can see here the controller

572
00:19:40,160 --> 00:19:41,600
pulls the bus low

573
00:19:41,600 --> 00:19:44,400
we are holding it for almost exactly 480

574
00:19:44,400 --> 00:19:46,960
microseconds here we let go

575
00:19:46,960 --> 00:19:50,160
then a brief time later typically

576
00:19:50,160 --> 00:19:53,919
about 40 or so microseconds later if

577
00:19:53,919 --> 00:19:56,240
there's any devices attached to the bus

578
00:19:56,240 --> 00:19:59,039
any one wire devices at all they will

579
00:19:59,039 --> 00:20:01,039
pull the bus low

580
00:20:01,039 --> 00:20:03,520
for about 100 microseconds there and

581
00:20:03,520 --> 00:20:05,520
that's called the presence pulse

582
00:20:05,520 --> 00:20:07,200
if you can see that that means that

583
00:20:07,200 --> 00:20:08,799
there's a device there

584
00:20:08,799 --> 00:20:10,880
it got the reset command and it's

585
00:20:10,880 --> 00:20:12,240
resetting itself

586
00:20:12,240 --> 00:20:13,840
and you know it's basically saying here

587
00:20:13,840 --> 00:20:16,799
i am i'm on the bus

588
00:20:16,799 --> 00:20:19,360
i pull the bus low for 480 microseconds

589
00:20:19,360 --> 00:20:21,039
they will briefly pull the bus low after

590
00:20:21,039 --> 00:20:22,799
the reset pulse

591
00:20:22,799 --> 00:20:24,480
and that's called the presence pulse as

592
00:20:24,480 --> 00:20:26,559
you can see it's actually decoded for us

593
00:20:26,559 --> 00:20:28,880
in the logic analyzer software it says

594
00:20:28,880 --> 00:20:31,919
presence true

595
00:20:32,320 --> 00:20:34,559
so let's look at sort of an example bus

596
00:20:34,559 --> 00:20:37,440
transaction putting all this together

597
00:20:37,440 --> 00:20:39,679
at the start there we have the reset

598
00:20:39,679 --> 00:20:42,640
followed by the presence pulse

599
00:20:42,640 --> 00:20:44,640
then we send a command we're going to go

600
00:20:44,640 --> 00:20:46,240
over the list of commands in a bit we

601
00:20:46,240 --> 00:20:49,120
send a command and then we start issuing

602
00:20:49,120 --> 00:20:52,080
read slots and we read the response back

603
00:20:52,080 --> 00:20:53,919
and that's it there's no clock it's just

604
00:20:53,919 --> 00:20:56,159
a series of pulses and

605
00:20:56,159 --> 00:20:57,840
you know you have to be able to decode

606
00:20:57,840 --> 00:21:00,320
them based on your knowledge of what

607
00:21:00,320 --> 00:21:03,679
is going on on both sides so

608
00:21:03,679 --> 00:21:06,720
every transaction has to start with the

609
00:21:06,720 --> 00:21:08,159
controller sending one of these

610
00:21:08,159 --> 00:21:09,919
following commands to determine

611
00:21:09,919 --> 00:21:11,919
which device on the bus it wants to talk

612
00:21:11,919 --> 00:21:13,039
to

613
00:21:13,039 --> 00:21:17,360
read rom match rom search rom

614
00:21:17,360 --> 00:21:20,640
skip rom you see a theme resume

615
00:21:20,640 --> 00:21:23,919
overdrive skip rom overdrive matron and

616
00:21:23,919 --> 00:21:24,960
we're just going to look at the most

617
00:21:24,960 --> 00:21:26,640
important ones we're not really going to

618
00:21:26,640 --> 00:21:28,159
be looking at overdrive much

619
00:21:28,159 --> 00:21:30,559
uh this week it's basically the exact

620
00:21:30,559 --> 00:21:33,120
same thing just at a higher speed

621
00:21:33,120 --> 00:21:35,840
so let's go through these these have

622
00:21:35,840 --> 00:21:36,960
codes

623
00:21:36,960 --> 00:21:39,919
that are in the standard so these codes

624
00:21:39,919 --> 00:21:40,720
mean

625
00:21:40,720 --> 00:21:42,559
these things when they're sent and

626
00:21:42,559 --> 00:21:44,480
that's like all the devices are

627
00:21:44,480 --> 00:21:46,960
programmed to recognize these codes

628
00:21:46,960 --> 00:21:51,760
read rom 33 in hexadecimal

629
00:21:52,240 --> 00:21:55,679
this basically says i want to read

630
00:21:55,679 --> 00:21:59,039
your 64-bit serial number and if there's

631
00:21:59,039 --> 00:22:00,159
a device on the bus

632
00:22:00,159 --> 00:22:02,320
it'll respond with its 64-bit serial

633
00:22:02,320 --> 00:22:04,400
number

634
00:22:04,400 --> 00:22:05,919
that's a problem if we've got more than

635
00:22:05,919 --> 00:22:08,080
one device on the bus we might have more

636
00:22:08,080 --> 00:22:10,559
than one device responding

637
00:22:10,559 --> 00:22:13,840
in this case every uh

638
00:22:13,840 --> 00:22:17,200
every 64-bit address that's sent has a

639
00:22:17,200 --> 00:22:17,840
crc

640
00:22:17,840 --> 00:22:21,039
checksum and if you're actually checking

641
00:22:21,039 --> 00:22:21,919
this

642
00:22:21,919 --> 00:22:24,080
it'll be obvious if more than one device

643
00:22:24,080 --> 00:22:26,240
responded because that crc checksum will

644
00:22:26,240 --> 00:22:28,080
not be correct

645
00:22:28,080 --> 00:22:30,159
if that happens if there's more than one

646
00:22:30,159 --> 00:22:31,760
device on the bus that you don't know

647
00:22:31,760 --> 00:22:34,159
the addresses of already

648
00:22:34,159 --> 00:22:36,159
then you can issue this search rom

649
00:22:36,159 --> 00:22:37,679
command which we'll get into later and

650
00:22:37,679 --> 00:22:39,440
you go through this

651
00:22:39,440 --> 00:22:42,320
very complicated process to figure out

652
00:22:42,320 --> 00:22:44,320
the addresses of every single device on

653
00:22:44,320 --> 00:22:44,880
the bus

654
00:22:44,880 --> 00:22:46,480
but if there's just one device on the

655
00:22:46,480 --> 00:22:50,240
bus it'll return its 64 bit address

656
00:22:50,240 --> 00:22:53,520
pretty simple match rom

657
00:22:53,520 --> 00:22:57,120
this is hexadecimal 55.

658
00:22:57,120 --> 00:22:58,960
this is used to address the device on

659
00:22:58,960 --> 00:23:00,559
the bus for further communication

660
00:23:00,559 --> 00:23:04,240
so we send 55 followed by the 64-bit

661
00:23:04,240 --> 00:23:05,360
address of the device we want to

662
00:23:05,360 --> 00:23:06,320
communicate with

663
00:23:06,320 --> 00:23:09,120
we are telling it we want to match this

664
00:23:09,120 --> 00:23:09,760
rom

665
00:23:09,760 --> 00:23:12,640
to a particular device this rom serial

666
00:23:12,640 --> 00:23:13,679
number

667
00:23:13,679 --> 00:23:15,280
then it communicates with that device

668
00:23:15,280 --> 00:23:18,720
and all other devices will remain idle

669
00:23:18,720 --> 00:23:23,120
skip rom this is hexadecimal cc

670
00:23:23,120 --> 00:23:25,200
this completely ignores the addressing

671
00:23:25,200 --> 00:23:26,480
process this can

672
00:23:26,480 --> 00:23:28,960
only be used if you are certain there is

673
00:23:28,960 --> 00:23:31,200
only a single device on the bus

674
00:23:31,200 --> 00:23:33,039
because if you issue the skip rom

675
00:23:33,039 --> 00:23:34,880
command anything that's listening is

676
00:23:34,880 --> 00:23:36,000
going to respond because

677
00:23:36,000 --> 00:23:38,640
it's not checking the address of that

678
00:23:38,640 --> 00:23:40,640
device it's just going to respond

679
00:23:40,640 --> 00:23:42,559
this is the simplest way to implement

680
00:23:42,559 --> 00:23:44,159
things when there's only one device on

681
00:23:44,159 --> 00:23:44,720
the bus

682
00:23:44,720 --> 00:23:46,240
and if you know there's only one device

683
00:23:46,240 --> 00:23:47,840
on the bus this makes things a lot

684
00:23:47,840 --> 00:23:49,120
easier

685
00:23:49,120 --> 00:23:50,559
instead of having to read the device's

686
00:23:50,559 --> 00:23:53,120
rom address and then use a match rom

687
00:23:53,120 --> 00:23:56,000
we can just skip this addressing and

688
00:23:56,000 --> 00:23:58,000
then communicate with it

689
00:23:58,000 --> 00:24:01,200
so be sure there's only one device

690
00:24:01,200 --> 00:24:02,640
or that you actually want to send the

691
00:24:02,640 --> 00:24:04,320
same thing to all devices

692
00:24:04,320 --> 00:24:05,919
there might be cases where you actually

693
00:24:05,919 --> 00:24:08,320
want to do that

694
00:24:08,320 --> 00:24:13,279
a resume command this is hexadecimal a5

695
00:24:13,279 --> 00:24:16,320
after a successful matron command the

696
00:24:16,320 --> 00:24:18,320
device that was addressed will sort of

697
00:24:18,320 --> 00:24:19,279
remember

698
00:24:19,279 --> 00:24:20,960
i was the last one that the controller

699
00:24:20,960 --> 00:24:23,760
talked to and if i see a resume command

700
00:24:23,760 --> 00:24:25,760
that means it wants to talk to me again

701
00:24:25,760 --> 00:24:26,720
but it doesn't want to go through the

702
00:24:26,720 --> 00:24:28,159
whole match rom process

703
00:24:28,159 --> 00:24:31,440
again so instead of having to send the

704
00:24:31,440 --> 00:24:33,360
address it just sends this command

705
00:24:33,360 --> 00:24:34,880
a5 and then it can do another

706
00:24:34,880 --> 00:24:38,400
transaction with that same chip

707
00:24:38,720 --> 00:24:40,320
uh yeah it wants to communicate with the

708
00:24:40,320 --> 00:24:42,000
same device it previously addre

709
00:24:42,000 --> 00:24:43,919
previously addressed this is almost like

710
00:24:43,919 --> 00:24:46,320
a repeated start from i squared c

711
00:24:46,320 --> 00:24:48,480
we're basically saying we want to you

712
00:24:48,480 --> 00:24:50,240
know talk to you again right away

713
00:24:50,240 --> 00:24:51,760
not quite the same thing as a repeated

714
00:24:51,760 --> 00:24:53,360
start but

715
00:24:53,360 --> 00:24:56,799
it's sort of the same concept often

716
00:24:56,799 --> 00:24:59,200
as in i squared c used to read back the

717
00:24:59,200 --> 00:25:01,679
response to an earlier command you know

718
00:25:01,679 --> 00:25:05,440
do a temperature measurement okay resume

719
00:25:05,440 --> 00:25:06,799
read back the results of that

720
00:25:06,799 --> 00:25:09,200
temperature measurement

721
00:25:09,200 --> 00:25:12,960
search rom f0 hexadecimal we save the

722
00:25:12,960 --> 00:25:14,880
best for last

723
00:25:14,880 --> 00:25:18,559
because when this bus was designed

724
00:25:18,559 --> 00:25:20,400
it was designed to be robust and

725
00:25:20,400 --> 00:25:21,840
reliable

726
00:25:21,840 --> 00:25:24,400
you needed a way to determine what

727
00:25:24,400 --> 00:25:26,840
devices were on the bus

728
00:25:26,840 --> 00:25:29,679
without uh you know an i squared c if

729
00:25:29,679 --> 00:25:31,200
you wanted to see if there's devices on

730
00:25:31,200 --> 00:25:31,679
the bus

731
00:25:31,679 --> 00:25:35,760
you can just try reading from all 255

732
00:25:35,760 --> 00:25:37,679
addresses that's not that many addresses

733
00:25:37,679 --> 00:25:40,159
you'll get through them pretty quickly

734
00:25:40,159 --> 00:25:41,840
we've got a problem with one wire we've

735
00:25:41,840 --> 00:25:44,080
got what was it like you know

736
00:25:44,080 --> 00:25:47,120
10 to the 19 addresses we can't possibly

737
00:25:47,120 --> 00:25:48,240
do that

738
00:25:48,240 --> 00:25:51,520
so in order to simplify this we can do

739
00:25:51,520 --> 00:25:54,320
something called a search rom this uses

740
00:25:54,320 --> 00:25:59,200
a binary tree it's hexadecimal f0

741
00:25:59,200 --> 00:26:01,919
it starts at enumeration process so

742
00:26:01,919 --> 00:26:03,919
every single device on the bus will send

743
00:26:03,919 --> 00:26:05,840
its address to the controller

744
00:26:05,840 --> 00:26:07,760
but in this special pattern called a

745
00:26:07,760 --> 00:26:09,120
binary tree

746
00:26:09,120 --> 00:26:11,200
you start at the top and then you pick

747
00:26:11,200 --> 00:26:12,400
one direction to go

748
00:26:12,400 --> 00:26:15,760
you can go to the right for a one or a

749
00:26:15,760 --> 00:26:17,039
left for a zero

750
00:26:17,039 --> 00:26:18,799
the right and left the actual tree is

751
00:26:18,799 --> 00:26:20,320
just for humans to sort of understand

752
00:26:20,320 --> 00:26:21,600
what's going on

753
00:26:21,600 --> 00:26:24,960
um bus all the devices will start

754
00:26:24,960 --> 00:26:26,640
talking at once how can we possibly

755
00:26:26,640 --> 00:26:28,480
figure out which devices which say we've

756
00:26:28,480 --> 00:26:30,159
got 10 devices on the bus and we're

757
00:26:30,159 --> 00:26:31,679
trying to get the addresses from all of

758
00:26:31,679 --> 00:26:32,480
them

759
00:26:32,480 --> 00:26:33,679
they're all going to start talking at

760
00:26:33,679 --> 00:26:35,919
the same time so

761
00:26:35,919 --> 00:26:39,760
we send the command f zero

762
00:26:39,760 --> 00:26:42,320
after that we will issue two read slots

763
00:26:42,320 --> 00:26:43,039
we're going to read

764
00:26:43,039 --> 00:26:46,240
two bits back if

765
00:26:46,240 --> 00:26:49,600
the device responding has a one

766
00:26:49,600 --> 00:26:52,799
in the first bit of its serial number

767
00:26:52,799 --> 00:26:55,039
it will send a one in the first read

768
00:26:55,039 --> 00:26:57,200
slot

769
00:26:57,200 --> 00:27:00,400
and then it will send the opposite

770
00:27:00,400 --> 00:27:03,039
of that first bit so if you have a one

771
00:27:03,039 --> 00:27:04,000
in that position

772
00:27:04,000 --> 00:27:06,159
you send a one if you have a zero in

773
00:27:06,159 --> 00:27:08,240
that position you send a zero

774
00:27:08,240 --> 00:27:10,640
then on the second read slot whatever

775
00:27:10,640 --> 00:27:12,240
you sent on the first

776
00:27:12,240 --> 00:27:14,960
read slot you send the inverse of so

777
00:27:14,960 --> 00:27:17,919
this will make sense in a second here

778
00:27:17,919 --> 00:27:20,640
then we pick depending on what devices

779
00:27:20,640 --> 00:27:21,440
responded

780
00:27:21,440 --> 00:27:24,640
if only devices with a 1 in that

781
00:27:24,640 --> 00:27:26,240
position responded

782
00:27:26,240 --> 00:27:28,000
we want to go down that direction in the

783
00:27:28,000 --> 00:27:30,320
search tree so we're going to respond

784
00:27:30,320 --> 00:27:31,360
with a 1

785
00:27:31,360 --> 00:27:33,120
and then we move on to the next bit of

786
00:27:33,120 --> 00:27:34,880
the serial address

787
00:27:34,880 --> 00:27:37,279
and then we repeat this process over and

788
00:27:37,279 --> 00:27:38,799
over again

789
00:27:38,799 --> 00:27:41,600
therefore there's only four sequences

790
00:27:41,600 --> 00:27:44,799
that can happen during this bit search

791
00:27:44,799 --> 00:27:46,640
the first bit is a zero and the second

792
00:27:46,640 --> 00:27:48,320
bit is a zero well that means that

793
00:27:48,320 --> 00:27:49,840
there's devices that have both

794
00:27:49,840 --> 00:27:53,600
zeros and ones in this bit because

795
00:27:53,600 --> 00:27:56,799
devices sent both

796
00:27:56,799 --> 00:27:58,720
a one and the inverse of a one which is

797
00:27:58,720 --> 00:28:00,559
zero and a zero which is the inverse of

798
00:28:00,559 --> 00:28:01,600
a one

799
00:28:01,600 --> 00:28:04,000
which the inverse of which is a one so

800
00:28:04,000 --> 00:28:06,240
in both read slots we had a zero

801
00:28:06,240 --> 00:28:07,679
so that means we can go in either

802
00:28:07,679 --> 00:28:10,320
direction on the binary search tree

803
00:28:10,320 --> 00:28:12,399
if we got a zero followed by a one

804
00:28:12,399 --> 00:28:14,159
there's at least one device on the bus

805
00:28:14,159 --> 00:28:16,640
that has a zero in this location of the

806
00:28:16,640 --> 00:28:18,399
serial address

807
00:28:18,399 --> 00:28:20,399
if we got a one and a zero there's at

808
00:28:20,399 --> 00:28:22,080
least one device with a one

809
00:28:22,080 --> 00:28:24,399
and if we got two ones that means no

810
00:28:24,399 --> 00:28:26,320
devices responded at all this either

811
00:28:26,320 --> 00:28:27,600
means we're finished with this whole

812
00:28:27,600 --> 00:28:30,880
process or there's no devices on the bus

813
00:28:30,880 --> 00:28:33,039
the controller will choose which path it

814
00:28:33,039 --> 00:28:35,360
wants to continue down

815
00:28:35,360 --> 00:28:38,080
so let's look at an example and then

816
00:28:38,080 --> 00:28:39,919
once you once we select which direction

817
00:28:39,919 --> 00:28:40,559
we're going

818
00:28:40,559 --> 00:28:43,200
if we didn't pick the direction that a

819
00:28:43,200 --> 00:28:44,399
certain device

820
00:28:44,399 --> 00:28:47,120
has say we're picking a one from that

821
00:28:47,120 --> 00:28:49,039
point and it has a zero it'll just shut

822
00:28:49,039 --> 00:28:50,640
up until we get all the way back around

823
00:28:50,640 --> 00:28:52,000
to the beginning again

824
00:28:52,000 --> 00:28:54,640
let's look at a very simplified example

825
00:28:54,640 --> 00:28:55,600
of this because i know it's very

826
00:28:55,600 --> 00:28:57,039
confusing

827
00:28:57,039 --> 00:29:00,159
we repeat this 63 more times for a

828
00:29:00,159 --> 00:29:02,399
64-bit serial number

829
00:29:02,399 --> 00:29:05,360
whenever we have the 0-0 condition where

830
00:29:05,360 --> 00:29:06,240
there's devices

831
00:29:06,240 --> 00:29:08,480
that have both zeros and once at this

832
00:29:08,480 --> 00:29:09,760
bit position

833
00:29:09,760 --> 00:29:12,080
the controller according to the standard

834
00:29:12,080 --> 00:29:14,080
should always pick the zero path

835
00:29:14,080 --> 00:29:16,480
first then the one path the next time

836
00:29:16,480 --> 00:29:18,080
around

837
00:29:18,080 --> 00:29:20,080
so we follow this binary tree pattern

838
00:29:20,080 --> 00:29:21,760
repeat it until every device has been

839
00:29:21,760 --> 00:29:24,320
enumerated

840
00:29:24,320 --> 00:29:27,279
so this is sort of what that looks like

841
00:29:27,279 --> 00:29:28,320
this is a very

842
00:29:28,320 --> 00:29:30,799
this is just the very top of the tree we

843
00:29:30,799 --> 00:29:31,840
send 0 by f

844
00:29:31,840 --> 00:29:35,360
0 and then we read back either

845
00:29:35,360 --> 00:29:38,880
1 0 0 1 or 0 0.

846
00:29:38,880 --> 00:29:40,480
let's say we want to pick the zero

847
00:29:40,480 --> 00:29:42,240
direction we

848
00:29:42,240 --> 00:29:45,600
send a zero out on the bus and then any

849
00:29:45,600 --> 00:29:48,000
device that has a zero in the very first

850
00:29:48,000 --> 00:29:48,399
bit

851
00:29:48,399 --> 00:29:51,840
of its serial number when we send out

852
00:29:51,840 --> 00:29:52,640
two more

853
00:29:52,640 --> 00:29:55,919
read slots it'll send out the second bit

854
00:29:55,919 --> 00:29:57,440
of its serial number

855
00:29:57,440 --> 00:30:00,159
any devices that had a one in the first

856
00:30:00,159 --> 00:30:00,799
bit

857
00:30:00,799 --> 00:30:02,559
they're just gonna have to wait until we

858
00:30:02,559 --> 00:30:03,919
come all the way back to the top of the

859
00:30:03,919 --> 00:30:05,919
tree and then we start over

860
00:30:05,919 --> 00:30:09,840
with a one in the first bit position

861
00:30:10,000 --> 00:30:12,080
here's a very simple example we have two

862
00:30:12,080 --> 00:30:13,679
devices on the bus

863
00:30:13,679 --> 00:30:14,880
for this example we're just going to

864
00:30:14,880 --> 00:30:17,120
look at four bits

865
00:30:17,120 --> 00:30:19,279
device one has the serial number zero

866
00:30:19,279 --> 00:30:20,720
one one zero

867
00:30:20,720 --> 00:30:24,159
device 2 has a serial number 0 0 1 1.

868
00:30:24,159 --> 00:30:26,399
in the first bit position both devices

869
00:30:26,399 --> 00:30:27,919
have 0

870
00:30:27,919 --> 00:30:31,520
so the 0 1 pattern is sent so the

871
00:30:31,520 --> 00:30:34,080
controller will issue two read slots the

872
00:30:34,080 --> 00:30:36,000
first read slot it'll get a zero

873
00:30:36,000 --> 00:30:37,440
the second read slot it gets the

874
00:30:37,440 --> 00:30:39,520
opposite of that which is a one

875
00:30:39,520 --> 00:30:41,200
because we get that particular pattern

876
00:30:41,200 --> 00:30:43,039
we know that there's only

877
00:30:43,039 --> 00:30:45,120
devices with a zero in this bit position

878
00:30:45,120 --> 00:30:46,720
and if we look there are

879
00:30:46,720 --> 00:30:48,480
the first bit is zero for all the

880
00:30:48,480 --> 00:30:50,480
devices on the bus

881
00:30:50,480 --> 00:30:52,799
so we write a zero back because we want

882
00:30:52,799 --> 00:30:54,880
to continue with the devices that have a

883
00:30:54,880 --> 00:30:56,640
zero in that position

884
00:30:56,640 --> 00:30:58,000
because there's no devices with a one in

885
00:30:58,000 --> 00:30:59,600
that position so writing a one would be

886
00:30:59,600 --> 00:31:00,799
pointless

887
00:31:00,799 --> 00:31:03,279
we write a zero the second position

888
00:31:03,279 --> 00:31:06,000
device one has a one and device two has

889
00:31:06,000 --> 00:31:08,080
a zero as you can see we have our first

890
00:31:08,080 --> 00:31:10,399
conflict so we're gonna get the zero

891
00:31:10,399 --> 00:31:12,480
zero pattern sent back

892
00:31:12,480 --> 00:31:14,720
there's both a zero and a one at this

893
00:31:14,720 --> 00:31:16,240
bit position

894
00:31:16,240 --> 00:31:18,399
according to the standard we're supposed

895
00:31:18,399 --> 00:31:20,799
to go with the zero direction so

896
00:31:20,799 --> 00:31:22,640
we'll write back a zero we'll select

897
00:31:22,640 --> 00:31:25,120
device two device one is gonna go silent

898
00:31:25,120 --> 00:31:27,120
from this point because we've chosen

899
00:31:27,120 --> 00:31:29,919
a tree a branch that deviates away from

900
00:31:29,919 --> 00:31:32,000
its serial number

901
00:31:32,000 --> 00:31:35,039
at this point the rest of device 2

902
00:31:35,039 --> 00:31:36,399
serial number is going to be read out

903
00:31:36,399 --> 00:31:38,240
because it's the only remaining device

904
00:31:38,240 --> 00:31:40,720
so we finish reading out its serial

905
00:31:40,720 --> 00:31:41,600
number

906
00:31:41,600 --> 00:31:44,480
then we go back to the top we issue the

907
00:31:44,480 --> 00:31:46,159
search rom command again

908
00:31:46,159 --> 00:31:47,919
start from the top of the tree but

909
00:31:47,919 --> 00:31:49,760
wherever we forked

910
00:31:49,760 --> 00:31:51,519
last time this time we're going to take

911
00:31:51,519 --> 00:31:53,200
the other branch

912
00:31:53,200 --> 00:31:56,159
so this time around device 2 knows that

913
00:31:56,159 --> 00:31:57,840
it has sent its entire serial number

914
00:31:57,840 --> 00:31:59,919
already so it's going to remain silent

915
00:31:59,919 --> 00:32:01,760
it's enumerated we've got its full

916
00:32:01,760 --> 00:32:03,679
serial number stored in ram

917
00:32:03,679 --> 00:32:05,679
it's just going to shut up and let us

918
00:32:05,679 --> 00:32:07,120
deal with the rest of the devices on the

919
00:32:07,120 --> 00:32:08,399
bus

920
00:32:08,399 --> 00:32:10,240
because there's only one more device now

921
00:32:10,240 --> 00:32:11,760
we're going to read out device one's

922
00:32:11,760 --> 00:32:14,159
entire serial number

923
00:32:14,159 --> 00:32:16,480
then after we read out device one we're

924
00:32:16,480 --> 00:32:17,919
going to send the search rom command

925
00:32:17,919 --> 00:32:19,120
again because we don't know if there's

926
00:32:19,120 --> 00:32:21,279
another device possibly

927
00:32:21,279 --> 00:32:23,519
no devices are going to respond we're

928
00:32:23,519 --> 00:32:25,760
going to get the one one pattern

929
00:32:25,760 --> 00:32:29,679
and the search rom process is complete

930
00:32:29,679 --> 00:32:32,399
oh my god so complicated this is

931
00:32:32,399 --> 00:32:33,679
actually supposed to say how to avoid

932
00:32:33,679 --> 00:32:35,679
search rom whoops

933
00:32:35,679 --> 00:32:37,519
you don't want to implement this if you

934
00:32:37,519 --> 00:32:39,440
can help it it's complex it's sort of

935
00:32:39,440 --> 00:32:41,279
hard to wrap your head around

936
00:32:41,279 --> 00:32:44,320
and it's honestly there's very few

937
00:32:44,320 --> 00:32:45,840
use cases where you would actually need

938
00:32:45,840 --> 00:32:47,519
to do this um

939
00:32:47,519 --> 00:32:49,440
unless you're doing mass production of

940
00:32:49,440 --> 00:32:50,960
devices

941
00:32:50,960 --> 00:32:52,720
and the first time they power on they

942
00:32:52,720 --> 00:32:54,240
might need to go through this process to

943
00:32:54,240 --> 00:32:56,240
figure out their own serial number or

944
00:32:56,240 --> 00:32:59,039
whatever the case may be but if you're

945
00:32:59,039 --> 00:32:59,519
just

946
00:32:59,519 --> 00:33:02,240
a hacker designing a simple device you

947
00:33:02,240 --> 00:33:03,200
can just

948
00:33:03,200 --> 00:33:06,000
read the serial numbers using read rom

949
00:33:06,000 --> 00:33:08,080
just you know make sure you've only got

950
00:33:08,080 --> 00:33:11,679
one device on the bus because it only

951
00:33:11,679 --> 00:33:13,919
takes a single gpio pin

952
00:33:13,919 --> 00:33:16,080
you can just put each device on its own

953
00:33:16,080 --> 00:33:17,919
gpio pen so there's lots of ways to

954
00:33:17,919 --> 00:33:19,039
avoid match rom

955
00:33:19,039 --> 00:33:21,279
so let's look at these ways sorry to

956
00:33:21,279 --> 00:33:22,480
avoid search rom

957
00:33:22,480 --> 00:33:25,279
that's the typo in the title there so

958
00:33:25,279 --> 00:33:27,120
this algorithm is painful to implement

959
00:33:27,120 --> 00:33:28,960
so let's avoid it if at all possible

960
00:33:28,960 --> 00:33:29,360
right

961
00:33:29,360 --> 00:33:31,120
if there's only a single device on the

962
00:33:31,120 --> 00:33:33,760
bus we can just use skip rom we can just

963
00:33:33,760 --> 00:33:35,120
skip the matching process

964
00:33:35,120 --> 00:33:37,919
entirely and that's a good way to avoid

965
00:33:37,919 --> 00:33:38,399
it

966
00:33:38,399 --> 00:33:41,039
if you can if there's multiple devices

967
00:33:41,039 --> 00:33:42,720
on the bus

968
00:33:42,720 --> 00:33:44,880
we'll connect them one at a time if we

969
00:33:44,880 --> 00:33:46,960
can read the rom of each

970
00:33:46,960 --> 00:33:49,679
and store them in a con a constant

971
00:33:49,679 --> 00:33:50,640
variable

972
00:33:50,640 --> 00:33:53,120
and then from then on use matron you can

973
00:33:53,120 --> 00:33:54,880
do this in a one-off device if you're

974
00:33:54,880 --> 00:33:55,519
just making

975
00:33:55,519 --> 00:33:58,159
one of something you can physically

976
00:33:58,159 --> 00:33:58,640
connect

977
00:33:58,640 --> 00:34:01,840
one device read its rom store it

978
00:34:01,840 --> 00:34:03,919
disconnect it connect the next device

979
00:34:03,919 --> 00:34:05,760
read its rom et cetera

980
00:34:05,760 --> 00:34:08,079
and that way you'll avoid having to do

981
00:34:08,079 --> 00:34:09,520
search rom

982
00:34:09,520 --> 00:34:11,359
it's much easier to do one of these

983
00:34:11,359 --> 00:34:14,719
options than write the search rom code

984
00:34:14,719 --> 00:34:16,480
maxim have provided an extremely

985
00:34:16,480 --> 00:34:18,639
detailed application note on the search

986
00:34:18,639 --> 00:34:19,679
rom algorithm

987
00:34:19,679 --> 00:34:22,079
of course because it's so complicated it

988
00:34:22,079 --> 00:34:22,800
includes

989
00:34:22,800 --> 00:34:26,000
example c code if you really do need to

990
00:34:26,000 --> 00:34:28,239
use search rom you can use their example

991
00:34:28,239 --> 00:34:28,480
c

992
00:34:28,480 --> 00:34:31,040
code there is a link to that application

993
00:34:31,040 --> 00:34:31,839
note

994
00:34:31,839 --> 00:34:33,280
it's good to know about it's good to

995
00:34:33,280 --> 00:34:35,679
understand sort of generally how it

996
00:34:35,679 --> 00:34:36,560
works

997
00:34:36,560 --> 00:34:38,800
but in most cases you want to avoid

998
00:34:38,800 --> 00:34:39,839
using cert rom

999
00:34:39,839 --> 00:34:43,918
if you can all right

1000
00:34:43,918 --> 00:34:45,760
now we've covered all the different

1001
00:34:45,760 --> 00:34:48,560
protocol related things let's look at

1002
00:34:48,560 --> 00:34:51,520
the software level

1003
00:34:52,000 --> 00:34:55,520
all right so everything is done

1004
00:34:55,520 --> 00:34:58,640
typically through gpio very few

1005
00:34:58,640 --> 00:35:00,079
microcontrollers have a hardware

1006
00:35:00,079 --> 00:35:03,280
peripheral block as we mentioned before

1007
00:35:03,280 --> 00:35:04,720
therefore everything needs to be

1008
00:35:04,720 --> 00:35:07,280
implemented with gpio pins

1009
00:35:07,280 --> 00:35:10,400
just plain old input output pins

1010
00:35:10,400 --> 00:35:12,800
take advantage of open drain output if

1011
00:35:12,800 --> 00:35:14,000
the chip supports it

1012
00:35:14,000 --> 00:35:18,160
many pic devices do for accurate timing

1013
00:35:18,160 --> 00:35:20,480
we can either use a timer module

1014
00:35:20,480 --> 00:35:24,079
or we can simply issue knobs no

1015
00:35:24,079 --> 00:35:25,680
operations for a certain number of

1016
00:35:25,680 --> 00:35:28,000
processor cycles and just do a software

1017
00:35:28,000 --> 00:35:30,079
delay

1018
00:35:30,079 --> 00:35:31,599
we're just going to use a software delay

1019
00:35:31,599 --> 00:35:33,520
in our simple example because

1020
00:35:33,520 --> 00:35:35,839
it's a lot easier to implement and you

1021
00:35:35,839 --> 00:35:37,680
can sort of roughly calibrate it through

1022
00:35:37,680 --> 00:35:39,520
trial and error if you have a

1023
00:35:39,520 --> 00:35:42,839
a logic analyzer to look at the bus

1024
00:35:42,839 --> 00:35:44,960
so we're going to take a look at the

1025
00:35:44,960 --> 00:35:47,440
gpio section of the data sheet or family

1026
00:35:47,440 --> 00:35:48,400
reference manual

1027
00:35:48,400 --> 00:35:49,920
for the particular chip that we're

1028
00:35:49,920 --> 00:35:51,440
working with

1029
00:35:51,440 --> 00:35:53,119
the quirks of each chip can make it

1030
00:35:53,119 --> 00:35:54,800
easier or more difficult to implement

1031
00:35:54,800 --> 00:35:56,320
and it's good to know

1032
00:35:56,320 --> 00:35:58,240
what you're dealing with before you dive

1033
00:35:58,240 --> 00:35:59,520
in

1034
00:35:59,520 --> 00:36:00,880
we're going to need to switch the pin

1035
00:36:00,880 --> 00:36:02,720
between being an input and an output

1036
00:36:02,720 --> 00:36:03,839
quite often

1037
00:36:03,839 --> 00:36:05,520
some chips can do this in a single

1038
00:36:05,520 --> 00:36:07,200
instruction which is really good that'll

1039
00:36:07,200 --> 00:36:09,359
speed things up for us

1040
00:36:09,359 --> 00:36:12,079
open drain can also make one wire easier

1041
00:36:12,079 --> 00:36:14,800
unfortunately the msp430 doesn't support

1042
00:36:14,800 --> 00:36:17,599
open drain gpio pins but that's okay we

1043
00:36:17,599 --> 00:36:20,000
can work around that

1044
00:36:20,000 --> 00:36:22,000
basically we're gonna set the pin as a

1045
00:36:22,000 --> 00:36:23,440
low output

1046
00:36:23,440 --> 00:36:25,040
and that'll bring the bus to a ground

1047
00:36:25,040 --> 00:36:27,920
when we want to bring the bus low

1048
00:36:27,920 --> 00:36:29,599
then we're going to set the pin as an

1049
00:36:29,599 --> 00:36:30,960
input

1050
00:36:30,960 --> 00:36:34,240
and the enely set high that's going to

1051
00:36:34,240 --> 00:36:36,079
tri-state the pin which means it's going

1052
00:36:36,079 --> 00:36:37,599
to let go of the bus

1053
00:36:37,599 --> 00:36:38,800
it's basically going to be high

1054
00:36:38,800 --> 00:36:40,720
impedance and not do anything to the bus

1055
00:36:40,720 --> 00:36:41,520
at all

1056
00:36:41,520 --> 00:36:43,200
so just by switching between these two

1057
00:36:43,200 --> 00:36:45,680
states we can bring the bus low and then

1058
00:36:45,680 --> 00:36:47,599
release it to go high again

1059
00:36:47,599 --> 00:36:50,160
remember that we don't actually want to

1060
00:36:50,160 --> 00:36:51,520
set the bus

1061
00:36:51,520 --> 00:36:53,680
to an output high because then we're

1062
00:36:53,680 --> 00:36:55,680
going to be driving the bus

1063
00:36:55,680 --> 00:36:58,720
and the devices we're talking to

1064
00:36:58,720 --> 00:37:00,240
are going to have to try and pull the

1065
00:37:00,240 --> 00:37:02,320
bus low even though we're sourcing

1066
00:37:02,320 --> 00:37:04,400
you know potentially up to 20 or 30

1067
00:37:04,400 --> 00:37:05,839
milliamps which is just not going to

1068
00:37:05,839 --> 00:37:07,440
work

1069
00:37:07,440 --> 00:37:09,359
so let's take a very quick look at the

1070
00:37:09,359 --> 00:37:11,440
gpio section of the family reference

1071
00:37:11,440 --> 00:37:15,280
manual for the msp430

1072
00:37:16,160 --> 00:37:18,160
all right so here is the family

1073
00:37:18,160 --> 00:37:20,880
reference manual for the ti msp430

1074
00:37:20,880 --> 00:37:24,000
that we're using section 12 is the

1075
00:37:24,000 --> 00:37:25,760
digital i o module

1076
00:37:25,760 --> 00:37:28,079
basically we're just going to take a

1077
00:37:28,079 --> 00:37:29,520
quick look at what registers are

1078
00:37:29,520 --> 00:37:30,160
available

1079
00:37:30,160 --> 00:37:33,599
and the you know the operation so every

1080
00:37:33,599 --> 00:37:34,079
port

1081
00:37:34,079 --> 00:37:37,200
has input registers to set a bit low or

1082
00:37:37,200 --> 00:37:38,400
high

1083
00:37:38,400 --> 00:37:41,440
uh or to read the state of the bus

1084
00:37:41,440 --> 00:37:45,760
my pardon me it has output registers

1085
00:37:45,760 --> 00:37:48,720
uh which will set the corresponding i o

1086
00:37:48,720 --> 00:37:49,359
pin

1087
00:37:49,359 --> 00:37:52,160
if the pin is configured as an input

1088
00:37:52,160 --> 00:37:53,119
direction

1089
00:37:53,119 --> 00:37:54,800
and the pull-up or pull-down resistor

1090
00:37:54,800 --> 00:37:56,160
are enabled

1091
00:37:56,160 --> 00:37:57,920
then we can turn that that pull-up

1092
00:37:57,920 --> 00:37:59,680
resistor on or off by writing to the

1093
00:37:59,680 --> 00:38:01,040
output register

1094
00:38:01,040 --> 00:38:03,040
while it's in input state we're not

1095
00:38:03,040 --> 00:38:04,160
going to be doing this because we're

1096
00:38:04,160 --> 00:38:06,720
using an external pull-up resistor

1097
00:38:06,720 --> 00:38:08,320
so we're going to make sure that the

1098
00:38:08,320 --> 00:38:10,320
pull-up resistor

1099
00:38:10,320 --> 00:38:13,599
is not enabled by default

1100
00:38:13,599 --> 00:38:16,400
that pxren is going to be disabled for

1101
00:38:16,400 --> 00:38:17,760
our pins

1102
00:38:17,760 --> 00:38:19,760
we need to switch the direction back and

1103
00:38:19,760 --> 00:38:21,200
forth so we'll need that

1104
00:38:21,200 --> 00:38:24,480
register output drive strength register

1105
00:38:24,480 --> 00:38:24,960
this

1106
00:38:24,960 --> 00:38:28,320
could be a way to

1107
00:38:28,480 --> 00:38:31,520
give the peripheral device that high

1108
00:38:31,520 --> 00:38:34,640
current peak if it needs it instead of

1109
00:38:34,640 --> 00:38:36,320
connecting an external transistor

1110
00:38:36,320 --> 00:38:39,920
across vcc and the one wire bus

1111
00:38:39,920 --> 00:38:42,000
you might just be able to set the bus to

1112
00:38:42,000 --> 00:38:43,359
an output with this

1113
00:38:43,359 --> 00:38:47,119
full drive strength um that will

1114
00:38:47,119 --> 00:38:49,200
as it said will increase emi but it

1115
00:38:49,200 --> 00:38:50,800
doesn't really matter in this case

1116
00:38:50,800 --> 00:38:52,960
that'll probably source at least 20

1117
00:38:52,960 --> 00:38:55,760
milliamps if not more

1118
00:38:55,760 --> 00:38:57,760
again i o function is selected for this

1119
00:38:57,760 --> 00:38:59,599
pin we don't want the peripheral module

1120
00:38:59,599 --> 00:39:00,079
function

1121
00:39:00,079 --> 00:39:01,760
because we're going to be doing

1122
00:39:01,760 --> 00:39:03,599
everything as a gpio

1123
00:39:03,599 --> 00:39:06,640
we're not worried about interrupts

1124
00:39:06,640 --> 00:39:07,839
so basically we're just going to be

1125
00:39:07,839 --> 00:39:10,000
using these registers actually we're

1126
00:39:10,000 --> 00:39:11,760
only going to be using the

1127
00:39:11,760 --> 00:39:15,359
pxn px out and px dir

1128
00:39:15,359 --> 00:39:17,200
that's it everything else is just going

1129
00:39:17,200 --> 00:39:18,640
to be left as default

1130
00:39:18,640 --> 00:39:22,079
so pretty simple actually

1131
00:39:22,079 --> 00:39:24,640
okay so let's take a quick look at

1132
00:39:24,640 --> 00:39:26,560
timing as well

1133
00:39:26,560 --> 00:39:29,920
so to do these software delays there's a

1134
00:39:29,920 --> 00:39:32,440
header file for the msp430 called

1135
00:39:32,440 --> 00:39:34,000
intrinsics.h

1136
00:39:34,000 --> 00:39:36,160
and it's got a function called delay

1137
00:39:36,160 --> 00:39:37,200
cycles that's

1138
00:39:37,200 --> 00:39:40,320
two underscores delay single underscore

1139
00:39:40,320 --> 00:39:43,440
cycles which simply executes no

1140
00:39:43,440 --> 00:39:45,839
operations for however many cycles we

1141
00:39:45,839 --> 00:39:47,680
tell it to

1142
00:39:47,680 --> 00:39:49,359
we're going to test out different delay

1143
00:39:49,359 --> 00:39:51,359
times through trial and error

1144
00:39:51,359 --> 00:39:53,119
once we sort of figure out the number of

1145
00:39:53,119 --> 00:39:54,960
cycles that corresponds to the amount of

1146
00:39:54,960 --> 00:39:56,079
delay time we want

1147
00:39:56,079 --> 00:39:58,000
we're going to store those numbers and

1148
00:39:58,000 --> 00:39:59,680
then we'll use them when we're writing

1149
00:39:59,680 --> 00:40:02,160
our code

1150
00:40:02,160 --> 00:40:04,560
that's actually those numbers that just

1151
00:40:04,560 --> 00:40:05,680
appeared there are the

1152
00:40:05,680 --> 00:40:08,960
numbers that i figured out using my

1153
00:40:08,960 --> 00:40:11,200
chip running at 20 megahertz through

1154
00:40:11,200 --> 00:40:12,800
trial and error

1155
00:40:12,800 --> 00:40:15,680
for example to get a 480 microsecond

1156
00:40:15,680 --> 00:40:16,720
reset pulse

1157
00:40:16,720 --> 00:40:19,920
we need to delay for 9800 clock

1158
00:40:19,920 --> 00:40:22,960
cycles you can sort of calculate this

1159
00:40:22,960 --> 00:40:24,000
based on the clock speed

1160
00:40:24,000 --> 00:40:25,440
of the chip but there's other factors

1161
00:40:25,440 --> 00:40:27,119
that play into it

1162
00:40:27,119 --> 00:40:28,640
doing it through trial and error is

1163
00:40:28,640 --> 00:40:30,880
usually the best way to do it

1164
00:40:30,880 --> 00:40:32,480
and a good way to determine if your

1165
00:40:32,480 --> 00:40:34,560
timings are correct is to use a logic

1166
00:40:34,560 --> 00:40:35,200
analyzer

1167
00:40:35,200 --> 00:40:38,319
because you can just send one wire bits

1168
00:40:38,319 --> 00:40:40,000
out without actually knowing if there's

1169
00:40:40,000 --> 00:40:41,520
a device there or not

1170
00:40:41,520 --> 00:40:43,359
and just have the logic analyzer look at

1171
00:40:43,359 --> 00:40:45,040
them and if it's able to decode what

1172
00:40:45,040 --> 00:40:46,240
you're sending

1173
00:40:46,240 --> 00:40:48,319
it will you know that's a confirmation

1174
00:40:48,319 --> 00:40:50,079
that your timings are good

1175
00:40:50,079 --> 00:40:51,839
a nice thing about pulse view in

1176
00:40:51,839 --> 00:40:54,240
particular if your timings aren't good

1177
00:40:54,240 --> 00:40:56,000
it will usually tell you exactly what's

1178
00:40:56,000 --> 00:40:58,079
wrong you know the read slot is too

1179
00:40:58,079 --> 00:41:00,079
short the read slot is too long the

1180
00:41:00,079 --> 00:41:02,000
reset pulse is too short

1181
00:41:02,000 --> 00:41:04,079
no presence pulse detected it's really

1182
00:41:04,079 --> 00:41:05,839
good at actually giving you feedback on

1183
00:41:05,839 --> 00:41:07,440
what's wrong which can be really really

1184
00:41:07,440 --> 00:41:08,400
handy

1185
00:41:08,400 --> 00:41:10,319
so again these numbers here are only

1186
00:41:10,319 --> 00:41:12,560
applicable when running at 20 megahertz

1187
00:41:12,560 --> 00:41:14,319
if you're using the example code from

1188
00:41:14,319 --> 00:41:16,160
our gitlab repository

1189
00:41:16,160 --> 00:41:18,160
then it will be running in 20 megahertz

1190
00:41:18,160 --> 00:41:19,280
because that's how the chip is

1191
00:41:19,280 --> 00:41:20,240
configured

1192
00:41:20,240 --> 00:41:23,599
so the reset pulse we're going to write

1193
00:41:23,599 --> 00:41:25,520
a separate function for it

1194
00:41:25,520 --> 00:41:27,119
as it gets called before every single

1195
00:41:27,119 --> 00:41:29,680
transaction it's got to be 480

1196
00:41:29,680 --> 00:41:31,359
microseconds long

1197
00:41:31,359 --> 00:41:33,839
so we set the output low we wait for

1198
00:41:33,839 --> 00:41:35,839
about 500 microseconds and then we

1199
00:41:35,839 --> 00:41:39,359
set the gpio pin to an input and high

1200
00:41:39,359 --> 00:41:41,040
which tri-states it and disconnects it

1201
00:41:41,040 --> 00:41:43,119
from the bus this is what that actual

1202
00:41:43,119 --> 00:41:45,440
snippet of code looks like

1203
00:41:45,440 --> 00:41:48,800
we're using port 2 pin 2 so all the

1204
00:41:48,800 --> 00:41:50,880
registers are going to be p2

1205
00:41:50,880 --> 00:41:53,839
and then out in direction and they're

1206
00:41:53,839 --> 00:41:54,800
all going to be working with

1207
00:41:54,800 --> 00:41:58,319
bit 2 which is pin number 2 of port 2.

1208
00:41:58,319 --> 00:41:59,680
so first thing we do is we set the

1209
00:41:59,680 --> 00:42:01,520
output low

1210
00:42:01,520 --> 00:42:04,079
we wait however long it takes for the

1211
00:42:04,079 --> 00:42:05,200
reset pulse

1212
00:42:05,200 --> 00:42:09,440
480 microseconds we set the

1213
00:42:09,440 --> 00:42:12,480
the pin high and at the same time we set

1214
00:42:12,480 --> 00:42:14,560
it to an input so it disconnects it from

1215
00:42:14,560 --> 00:42:15,599
the bus

1216
00:42:15,599 --> 00:42:17,680
so the presence pulse after the reset

1217
00:42:17,680 --> 00:42:19,599
pulse is complete we then need to wait

1218
00:42:19,599 --> 00:42:21,200
and see if we get a presence pulse from

1219
00:42:21,200 --> 00:42:23,599
any devices on the bus

1220
00:42:23,599 --> 00:42:25,440
if we get a presence pulse this function

1221
00:42:25,440 --> 00:42:27,359
is going to return a zero

1222
00:42:27,359 --> 00:42:29,040
if we don't get a presence pulse we're

1223
00:42:29,040 --> 00:42:30,880
going to return a 1.

1224
00:42:30,880 --> 00:42:32,720
this allows the program to decide how to

1225
00:42:32,720 --> 00:42:35,520
proceed if there is no response

1226
00:42:35,520 --> 00:42:37,119
we're going to delay so this is leading

1227
00:42:37,119 --> 00:42:38,640
off from the code we just saw we're

1228
00:42:38,640 --> 00:42:39,520
going to wait

1229
00:42:39,520 --> 00:42:42,319
about 40 to 60 microseconds we're going

1230
00:42:42,319 --> 00:42:42,640
to

1231
00:42:42,640 --> 00:42:44,960
check to see if there is a presence

1232
00:42:44,960 --> 00:42:46,560
pulse there basically we're looking at

1233
00:42:46,560 --> 00:42:48,560
bit two of the input

1234
00:42:48,560 --> 00:42:50,880
if it's a zero that means we have a

1235
00:42:50,880 --> 00:42:51,920
presence pulse

1236
00:42:51,920 --> 00:42:53,760
we're going to do a bit of housekeeping

1237
00:42:53,760 --> 00:42:55,760
which is we're going to set the

1238
00:42:55,760 --> 00:43:00,079
bit to an output again still set high

1239
00:43:00,079 --> 00:43:03,839
we're going to wait and finish out the

1240
00:43:03,839 --> 00:43:05,200
reset

1241
00:43:05,200 --> 00:43:08,560
and we'll return a zero otherwise

1242
00:43:08,560 --> 00:43:11,760
we'll do the same thing we'll set bit 2

1243
00:43:11,760 --> 00:43:12,000
to

1244
00:43:12,000 --> 00:43:15,680
an output we'll finish out waiting

1245
00:43:15,680 --> 00:43:19,040
for the appropriate amount of time

1246
00:43:19,040 --> 00:43:20,720
because after the presence pulse the

1247
00:43:20,720 --> 00:43:22,560
devices need a little bit more time

1248
00:43:22,560 --> 00:43:25,359
until they're ready we'll return a 1

1249
00:43:25,359 --> 00:43:26,720
although in this case we didn't get a

1250
00:43:26,720 --> 00:43:28,079
presence pulse but we're still going to

1251
00:43:28,079 --> 00:43:29,440
delay

1252
00:43:29,440 --> 00:43:32,000
and that's it so so the actual

1253
00:43:32,000 --> 00:43:33,359
transaction function

1254
00:43:33,359 --> 00:43:35,839
similar to i squared c like last week i

1255
00:43:35,839 --> 00:43:37,359
write a single function typically that

1256
00:43:37,359 --> 00:43:39,359
takes a pointer to the data

1257
00:43:39,359 --> 00:43:41,440
that is either to be transmitted or it's

1258
00:43:41,440 --> 00:43:42,720
a pointer to the buffer

1259
00:43:42,720 --> 00:43:44,640
where we're going to store data that

1260
00:43:44,640 --> 00:43:46,240
we're reading

1261
00:43:46,240 --> 00:43:48,560
the length of data to be read or written

1262
00:43:48,560 --> 00:43:50,400
and a variable to indicate what type of

1263
00:43:50,400 --> 00:43:52,000
transaction we want whether this is a

1264
00:43:52,000 --> 00:43:52,560
read or

1265
00:43:52,560 --> 00:43:54,880
write this function is actually a lot

1266
00:43:54,880 --> 00:43:56,160
simpler than the i squared c

1267
00:43:56,160 --> 00:43:58,000
transact function because one wire is a

1268
00:43:58,000 --> 00:43:59,680
much simpler protocol

1269
00:43:59,680 --> 00:44:01,520
if we're reading we just bring the bus

1270
00:44:01,520 --> 00:44:03,359
low for five microseconds and then we

1271
00:44:03,359 --> 00:44:05,280
read the state of the bus to determine

1272
00:44:05,280 --> 00:44:08,160
what bit we're reading if we're writing

1273
00:44:08,160 --> 00:44:09,680
we simply hold the bus low for a

1274
00:44:09,680 --> 00:44:10,720
different length of time

1275
00:44:10,720 --> 00:44:13,359
depending on if it's a 0 or 1. it's that

1276
00:44:13,359 --> 00:44:14,720
simple

1277
00:44:14,720 --> 00:44:17,520
unlike the i squared c library commands

1278
00:44:17,520 --> 00:44:19,680
addresses and data are all sent the same

1279
00:44:19,680 --> 00:44:21,520
way and they're all treated as data so

1280
00:44:21,520 --> 00:44:22,160
there's no

1281
00:44:22,160 --> 00:44:25,280
separate registers for the address

1282
00:44:25,280 --> 00:44:28,560
everything is treated as if it's data um

1283
00:44:28,560 --> 00:44:30,960
so the one wire library itself doesn't

1284
00:44:30,960 --> 00:44:31,839
actually know

1285
00:44:31,839 --> 00:44:34,319
if it's sending a command or if it's

1286
00:44:34,319 --> 00:44:36,640
sending data or what

1287
00:44:36,640 --> 00:44:39,760
that's up to the end user to implement

1288
00:44:39,760 --> 00:44:42,160
so it's quite simple so let's actually

1289
00:44:42,160 --> 00:44:44,079
take a quick look at that library before

1290
00:44:44,079 --> 00:44:46,079
we finish things up here

1291
00:44:46,079 --> 00:44:49,200
okay so this is the one wire library

1292
00:44:49,200 --> 00:44:50,800
this is the constructure function

1293
00:44:50,800 --> 00:44:52,800
constructor function i actually made a

1294
00:44:52,800 --> 00:44:54,160
mistake earlier i actually

1295
00:44:54,160 --> 00:44:57,040
am using the internal pull-ups um

1296
00:44:57,040 --> 00:44:58,480
basically

1297
00:44:58,480 --> 00:45:00,480
in parallel with the external pull-up

1298
00:45:00,480 --> 00:45:01,760
it's not going to make much difference

1299
00:45:01,760 --> 00:45:03,520
and i guess it was just an easier way to

1300
00:45:03,520 --> 00:45:05,119
tri-state the bus

1301
00:45:05,119 --> 00:45:08,079
or to not have any effect on the bus

1302
00:45:08,079 --> 00:45:09,839
this sets up

1303
00:45:09,839 --> 00:45:14,000
one-wire data as being on port 2.2

1304
00:45:14,000 --> 00:45:16,319
says the direction as an output and then

1305
00:45:16,319 --> 00:45:17,520
it sets it

1306
00:45:17,520 --> 00:45:20,240
high so as soon as we enable the one

1307
00:45:20,240 --> 00:45:21,839
wire bus it's going to set the bus to

1308
00:45:21,839 --> 00:45:23,200
high which will

1309
00:45:23,200 --> 00:45:26,720
hopefully charge the uh whatever device

1310
00:45:26,720 --> 00:45:28,400
we're using so this is

1311
00:45:28,400 --> 00:45:31,040
fully connecting the output driver to

1312
00:45:31,040 --> 00:45:32,640
the bus

1313
00:45:32,640 --> 00:45:34,319
to charge up the external device make

1314
00:45:34,319 --> 00:45:36,000
sure it's fully powered

1315
00:45:36,000 --> 00:45:37,920
we've got our simple function that

1316
00:45:37,920 --> 00:45:39,599
resets the bus

1317
00:45:39,599 --> 00:45:42,880
it assumes that we're

1318
00:45:42,880 --> 00:45:46,560
actually set as an output which is

1319
00:45:46,560 --> 00:45:49,839
maybe i should probably fix that but

1320
00:45:49,839 --> 00:45:52,640
we set the bus low wait we went through

1321
00:45:52,640 --> 00:45:54,079
this function in the slides

1322
00:45:54,079 --> 00:45:56,160
and then based on the status of that bus

1323
00:45:56,160 --> 00:45:57,599
if it's low

1324
00:45:57,599 --> 00:45:59,440
when we have a presence pulse we return

1325
00:45:59,440 --> 00:46:03,599
a zero otherwise we return a one

1326
00:46:04,720 --> 00:46:06,800
uh and then here's the big transact

1327
00:46:06,800 --> 00:46:08,000
function

1328
00:46:08,000 --> 00:46:10,560
we've got read and a write and look this

1329
00:46:10,560 --> 00:46:12,560
is basically the entire library

1330
00:46:12,560 --> 00:46:15,119
that many lines of code so there's not a

1331
00:46:15,119 --> 00:46:17,200
whole lot here

1332
00:46:17,200 --> 00:46:20,240
basically if we're reading we

1333
00:46:20,240 --> 00:46:23,119
go through however many bytes we're

1334
00:46:23,119 --> 00:46:23,680
reading

1335
00:46:23,680 --> 00:46:26,480
that's one for loop then the internal

1336
00:46:26,480 --> 00:46:27,200
for loop

1337
00:46:27,200 --> 00:46:29,680
is going through bit by bit reading 8

1338
00:46:29,680 --> 00:46:30,640
bits

1339
00:46:30,640 --> 00:46:33,920
so we set the bus low for however long

1340
00:46:33,920 --> 00:46:34,880
that read

1341
00:46:34,880 --> 00:46:38,960
window is then we

1342
00:46:38,960 --> 00:46:43,680
set it to high and set it as an input

1343
00:46:43,680 --> 00:46:47,280
then we wait however long to sample the

1344
00:46:47,280 --> 00:46:47,920
bus

1345
00:46:47,920 --> 00:46:50,960
then we sample the bus and basically

1346
00:46:50,960 --> 00:46:52,240
whatever the bus is

1347
00:46:52,240 --> 00:46:56,480
goes into the byte buffer and then we

1348
00:46:56,480 --> 00:46:59,680
set it as an output um which won't

1349
00:46:59,680 --> 00:47:01,280
actually do anything at the moment

1350
00:47:01,280 --> 00:47:05,839
and we wait until the next bit period

1351
00:47:05,839 --> 00:47:07,599
and we do that over and over and over

1352
00:47:07,599 --> 00:47:10,079
again until we've read however many bits

1353
00:47:10,079 --> 00:47:12,319
and bytes we need to read from the

1354
00:47:12,319 --> 00:47:13,440
device

1355
00:47:13,440 --> 00:47:16,560
if we're writing very similar thing we

1356
00:47:16,560 --> 00:47:19,680
pull the bus low if it's a one in this

1357
00:47:19,680 --> 00:47:20,720
location

1358
00:47:20,720 --> 00:47:23,280
we'll hold it low for a different amount

1359
00:47:23,280 --> 00:47:24,160
of time

1360
00:47:24,160 --> 00:47:25,680
and then leave it high for a different

1361
00:47:25,680 --> 00:47:27,760
amount of time

1362
00:47:27,760 --> 00:47:29,920
as opposed to if it's a zero we just

1363
00:47:29,920 --> 00:47:31,839
have different lengths of time

1364
00:47:31,839 --> 00:47:33,520
for holding the bus low and then

1365
00:47:33,520 --> 00:47:35,280
bringing it high again

1366
00:47:35,280 --> 00:47:37,839
that's it at the end of each bit we make

1367
00:47:37,839 --> 00:47:40,000
sure that we've taken up that full 120

1368
00:47:40,000 --> 00:47:41,520
second window

1369
00:47:41,520 --> 00:47:44,960
pretty simple basically these three

1370
00:47:44,960 --> 00:47:47,280
variables one low length one high length

1371
00:47:47,280 --> 00:47:48,880
and bit period length

1372
00:47:48,880 --> 00:47:51,680
or zero low length zero high length and

1373
00:47:51,680 --> 00:47:53,359
bit period length those should all add

1374
00:47:53,359 --> 00:47:54,640
up to 120

1375
00:47:54,640 --> 00:47:57,200
microseconds that's it i have a write

1376
00:47:57,200 --> 00:47:58,640
read function which i didn't actually

1377
00:47:58,640 --> 00:48:01,599
implement then i have a test which just

1378
00:48:01,599 --> 00:48:02,400
sends out

1379
00:48:02,400 --> 00:48:06,000
a one followed by a zero that's it and

1380
00:48:06,000 --> 00:48:07,839
then we have a function here to

1381
00:48:07,839 --> 00:48:11,359
compare a red rom which we're actually

1382
00:48:11,359 --> 00:48:12,880
going to use for our really simple

1383
00:48:12,880 --> 00:48:16,480
example here with the ds2401

1384
00:48:16,480 --> 00:48:20,400
we take a variable that's stored

1385
00:48:20,400 --> 00:48:23,119
which is eight bytes long 64 bits and

1386
00:48:23,119 --> 00:48:24,640
then we take a variable that we've

1387
00:48:24,640 --> 00:48:25,599
received

1388
00:48:25,599 --> 00:48:28,400
from the device we compare them together

1389
00:48:28,400 --> 00:48:29,839
if they're the same

1390
00:48:29,839 --> 00:48:32,960
we return the fact that they're the same

1391
00:48:32,960 --> 00:48:34,720
and if there is a difference between

1392
00:48:34,720 --> 00:48:36,319
them then we

1393
00:48:36,319 --> 00:48:39,599
return zero basically uh and that's

1394
00:48:39,599 --> 00:48:42,640
used in our main function to determine

1395
00:48:42,640 --> 00:48:44,480
if we're talking to the right chip

1396
00:48:44,480 --> 00:48:46,559
it is a very simple example we'll see in

1397
00:48:46,559 --> 00:48:48,079
a minute the header file

1398
00:48:48,079 --> 00:48:51,200
just has all those different delay times

1399
00:48:51,200 --> 00:48:53,680
defined as well as the command type we

1400
00:48:53,680 --> 00:48:55,200
might want to send

1401
00:48:55,200 --> 00:48:56,720
just as sort of a convenience for the

1402
00:48:56,720 --> 00:48:58,800
end user

1403
00:48:58,800 --> 00:49:00,559
and the declaration of a class and

1404
00:49:00,559 --> 00:49:02,079
that's it

1405
00:49:02,079 --> 00:49:03,680
so let's quickly switch back to the

1406
00:49:03,680 --> 00:49:06,079
slides here we have a very simple

1407
00:49:06,079 --> 00:49:07,839
example

1408
00:49:07,839 --> 00:49:09,520
i wanted to write a very simple example

1409
00:49:09,520 --> 00:49:11,680
just to see if the code was working

1410
00:49:11,680 --> 00:49:14,800
i had a ds 2401 in my stockpile

1411
00:49:14,800 --> 00:49:17,599
this is the simplest one wire device

1412
00:49:17,599 --> 00:49:18,400
that exists

1413
00:49:18,400 --> 00:49:21,359
it's called a silicon serial number all

1414
00:49:21,359 --> 00:49:23,440
it does is respond to read

1415
00:49:23,440 --> 00:49:26,720
rom commands and reply with its 64-bit

1416
00:49:26,720 --> 00:49:28,640
unique address that's all it does these

1417
00:49:28,640 --> 00:49:30,720
are tips that are often used to

1418
00:49:30,720 --> 00:49:33,119
give a board a particular serial number

1419
00:49:33,119 --> 00:49:35,440
so that it can be identified for

1420
00:49:35,440 --> 00:49:38,720
quality assurance or whatever it can

1421
00:49:38,720 --> 00:49:39,359
also be

1422
00:49:39,359 --> 00:49:42,559
used for any other need if you need a

1423
00:49:42,559 --> 00:49:44,319
64-bit number for something maybe as a

1424
00:49:44,319 --> 00:49:45,119
random number

1425
00:49:45,119 --> 00:49:48,880
seed or for any purpose you want if you

1426
00:49:48,880 --> 00:49:51,200
need a 64-bit unique number

1427
00:49:51,200 --> 00:49:52,640
the data sheet for this particular

1428
00:49:52,640 --> 00:49:54,720
device is there but it's literally so

1429
00:49:54,720 --> 00:49:55,760
simple we're not even going to look at

1430
00:49:55,760 --> 00:49:57,440
the device we're just going to issue the

1431
00:49:57,440 --> 00:49:59,440
read rom command

1432
00:49:59,440 --> 00:50:01,280
compare what gets back to with what i

1433
00:50:01,280 --> 00:50:03,040
know the correct value is

1434
00:50:03,040 --> 00:50:05,040
if it's correct we proceed if it's

1435
00:50:05,040 --> 00:50:06,800
incorrect we

1436
00:50:06,800 --> 00:50:08,319
basically stop the chip because there's

1437
00:50:08,319 --> 00:50:10,480
something wrong

1438
00:50:10,480 --> 00:50:12,720
and otherwise we'll proceed into the

1439
00:50:12,720 --> 00:50:14,880
code from last week where we read

1440
00:50:14,880 --> 00:50:16,720
the temperature and humidity from the

1441
00:50:16,720 --> 00:50:18,079
sht chip

1442
00:50:18,079 --> 00:50:19,760
so this is basically just adding in a

1443
00:50:19,760 --> 00:50:21,359
one-wire device as a

1444
00:50:21,359 --> 00:50:23,760
fail-safe to make sure we have a valid

1445
00:50:23,760 --> 00:50:25,280
device this is sort of a

1446
00:50:25,280 --> 00:50:29,040
you know a contrived example

1447
00:50:29,040 --> 00:50:30,720
so let's take a very quick look at that

1448
00:50:30,720 --> 00:50:33,680
code so let's switch back over to

1449
00:50:33,680 --> 00:50:38,400
code composer studio so here in the main

1450
00:50:38,400 --> 00:50:40,720
now we're also creating a one-wire

1451
00:50:40,720 --> 00:50:41,839
device

1452
00:50:41,839 --> 00:50:45,359
owb up here i have the stored serial

1453
00:50:45,359 --> 00:50:46,720
number this is what i know

1454
00:50:46,720 --> 00:50:50,480
my chip has so i store that

1455
00:50:50,480 --> 00:50:54,240
as a const then down here the first

1456
00:50:54,240 --> 00:50:57,520
thing we do is we reset the bus

1457
00:50:57,520 --> 00:51:00,640
we send the skip rom

1458
00:51:00,640 --> 00:51:04,000
command which is just a right of one

1459
00:51:04,000 --> 00:51:06,319
byte

1460
00:51:06,839 --> 00:51:10,160
we read eight bytes from the

1461
00:51:10,160 --> 00:51:12,160
bus which is going to be the serial

1462
00:51:12,160 --> 00:51:14,559
number of this device

1463
00:51:14,559 --> 00:51:17,359
then we use that function i showed to

1464
00:51:17,359 --> 00:51:20,000
compare the storage serial number

1465
00:51:20,000 --> 00:51:23,119
versus what we just read if they're not

1466
00:51:23,119 --> 00:51:24,480
the same

1467
00:51:24,480 --> 00:51:26,800
we're going to print this to the output

1468
00:51:26,800 --> 00:51:27,599
critical error

1469
00:51:27,599 --> 00:51:29,599
rom number mismatch all your base are

1470
00:51:29,599 --> 00:51:31,280
belong to us

1471
00:51:31,280 --> 00:51:34,480
uh and then we'll return from the main

1472
00:51:34,480 --> 00:51:35,760
function which basically doesn't

1473
00:51:35,760 --> 00:51:36,000
actually

1474
00:51:36,000 --> 00:51:38,319
crash the processor it just halts and

1475
00:51:38,319 --> 00:51:39,599
then you have to do a power

1476
00:51:39,599 --> 00:51:42,800
cycle otherwise we'll go into our code

1477
00:51:42,800 --> 00:51:44,800
from last week where we start reading

1478
00:51:44,800 --> 00:51:46,480
the humidity and temperature

1479
00:51:46,480 --> 00:51:47,920
so this is something you might actually

1480
00:51:47,920 --> 00:51:50,079
do in a real world scenario you want to

1481
00:51:50,079 --> 00:51:53,280
check that this device is valid um for

1482
00:51:53,280 --> 00:51:54,640
whatever reason you want to make sure

1483
00:51:54,640 --> 00:51:56,640
it's your device or that it hasn't been

1484
00:51:56,640 --> 00:51:58,160
tampered with

1485
00:51:58,160 --> 00:52:00,160
this is one way to do it you check the

1486
00:52:00,160 --> 00:52:02,400
serial number of a one wire device

1487
00:52:02,400 --> 00:52:05,680
so pretty simple if we actually go back

1488
00:52:05,680 --> 00:52:08,399
to the slides

1489
00:52:11,520 --> 00:52:13,440
that's what that example transaction we

1490
00:52:13,440 --> 00:52:14,880
were looking at earlier was

1491
00:52:14,880 --> 00:52:18,160
this is us sending a reset pulse

1492
00:52:18,160 --> 00:52:20,319
then we get the presence we send the

1493
00:52:20,319 --> 00:52:22,079
read rom command there you can see it's

1494
00:52:22,079 --> 00:52:24,240
hexadecimal 33

1495
00:52:24,240 --> 00:52:28,640
then we get this huge 64-bit value back

1496
00:52:28,640 --> 00:52:32,079
it's actually flipped around from the

1497
00:52:32,079 --> 00:52:34,400
way i have it stored because of the way

1498
00:52:34,400 --> 00:52:35,920
this decodes it

1499
00:52:35,920 --> 00:52:39,599
um pulseview actually assumes that its

1500
00:52:39,599 --> 00:52:41,839
least significant bite first

1501
00:52:41,839 --> 00:52:43,680
uh which is normally how it would be

1502
00:52:43,680 --> 00:52:44,960
displayed but

1503
00:52:44,960 --> 00:52:46,079
i have it the other way around in my

1504
00:52:46,079 --> 00:52:48,000
code it doesn't really matter uh

1505
00:52:48,000 --> 00:52:51,040
and that's that uh pretty simple

1506
00:52:51,040 --> 00:52:53,680
example but it shows that our code works

1507
00:52:53,680 --> 00:52:54,559
and

1508
00:52:54,559 --> 00:52:56,640
it's you know a very contrived example

1509
00:52:56,640 --> 00:52:58,240
but one that you might actually see in

1510
00:52:58,240 --> 00:52:59,680
the real world

1511
00:52:59,680 --> 00:53:02,160
so a quick summary of everything we went

1512
00:53:02,160 --> 00:53:03,280
over

1513
00:53:03,280 --> 00:53:06,079
one wire is slower than i squared c but

1514
00:53:06,079 --> 00:53:07,599
it's a simpler protocol to implement

1515
00:53:07,599 --> 00:53:08,480
than many other

1516
00:53:08,480 --> 00:53:11,520
serial protocols it's great for acting

1517
00:53:11,520 --> 00:53:12,960
as a unique serial number for your

1518
00:53:12,960 --> 00:53:14,559
circuit if you need a unique serial

1519
00:53:14,559 --> 00:53:16,000
number

1520
00:53:16,000 --> 00:53:18,160
it's usually implemented as bit banging

1521
00:53:18,160 --> 00:53:19,920
with the gpio commands the way we've

1522
00:53:19,920 --> 00:53:21,520
done it with some exceptions there are

1523
00:53:21,520 --> 00:53:24,079
some chips that have built-in one-wire

1524
00:53:24,079 --> 00:53:27,040
peripheral blocks not a lot of chips do

1525
00:53:27,040 --> 00:53:29,359
because it's so simple to implement

1526
00:53:29,359 --> 00:53:30,800
the hardware level is similar to i

1527
00:53:30,800 --> 00:53:32,960
squared c external pull-up resistors are

1528
00:53:32,960 --> 00:53:34,800
required

1529
00:53:34,800 --> 00:53:36,880
it's often very fast to prototype and

1530
00:53:36,880 --> 00:53:38,480
test especially if you have a logic

1531
00:53:38,480 --> 00:53:40,480
analyzer to confirm the timing of

1532
00:53:40,480 --> 00:53:42,079
everything like i do

1533
00:53:42,079 --> 00:53:44,000
writing that code was very quick because

1534
00:53:44,000 --> 00:53:46,480
i already knew the one wire protocol but

1535
00:53:46,480 --> 00:53:48,720
also because with an external device

1536
00:53:48,720 --> 00:53:50,640
like a logic analyzer to confirm your

1537
00:53:50,640 --> 00:53:51,520
timings

1538
00:53:51,520 --> 00:53:53,520
you can very rapidly make changes and

1539
00:53:53,520 --> 00:53:55,839
get everything dialed in

1540
00:53:55,839 --> 00:53:57,680
it's excellent for low powered devices

1541
00:53:57,680 --> 00:53:59,599
running on batteries one wire devices

1542
00:53:59,599 --> 00:54:00,319
when they're not

1543
00:54:00,319 --> 00:54:02,319
in use and they're just sitting there

1544
00:54:02,319 --> 00:54:04,720
take very very little power

1545
00:54:04,720 --> 00:54:06,079
many of them you can just turn them off

1546
00:54:06,079 --> 00:54:09,280
completely you can just bring the

1547
00:54:09,280 --> 00:54:13,119
one wire data line low

1548
00:54:13,119 --> 00:54:15,520
and if it's running on parasitic power

1549
00:54:15,520 --> 00:54:17,280
you can literally just shut the chip off

1550
00:54:17,280 --> 00:54:20,640
which is a good way to save power

1551
00:54:20,640 --> 00:54:22,720
so additional resources oh another slide

1552
00:54:22,720 --> 00:54:24,640
that's all glitch

1553
00:54:24,640 --> 00:54:26,400
maximum of an entire section on their

1554
00:54:26,400 --> 00:54:28,640
website which is a guide to one wire

1555
00:54:28,640 --> 00:54:29,920
communication

1556
00:54:29,920 --> 00:54:32,400
there's the link almost all one wire

1557
00:54:32,400 --> 00:54:34,240
devices have a great summary

1558
00:54:34,240 --> 00:54:36,559
of the essential pieces of the protocol

1559
00:54:36,559 --> 00:54:38,319
just like i squared c they'll have

1560
00:54:38,319 --> 00:54:39,839
an overview of the basics of the

1561
00:54:39,839 --> 00:54:42,240
protocol if you have any questions feel

1562
00:54:42,240 --> 00:54:43,760
free to comment on the

1563
00:54:43,760 --> 00:54:45,680
project page on hackaday io for this

1564
00:54:45,680 --> 00:54:47,520
course that way everyone else can see

1565
00:54:47,520 --> 00:54:48,559
your questions and

1566
00:54:48,559 --> 00:54:50,960
and they can see my answers there or

1567
00:54:50,960 --> 00:54:52,319
tune in to the q a

1568
00:54:52,319 --> 00:54:55,440
thursday evening 6 p.m eastern

1569
00:54:55,440 --> 00:54:57,680
the day after this course goes live this

1570
00:54:57,680 --> 00:54:58,720
particular class

1571
00:54:58,720 --> 00:55:00,559
and uh feel free to ask any questions

1572
00:55:00,559 --> 00:55:02,079
there that's

1573
00:55:02,079 --> 00:55:04,559
it for one wire next week we're going to

1574
00:55:04,559 --> 00:55:06,000
be combining everything

1575
00:55:06,000 --> 00:55:08,640
together and reading from both i squared

1576
00:55:08,640 --> 00:55:11,040
c and one wire chips and combining it

1577
00:55:11,040 --> 00:55:11,680
all together

1578
00:55:11,680 --> 00:55:14,880
into an actual project so thank you so

1579
00:55:14,880 --> 00:55:16,160
much for tuning in

1580
00:55:16,160 --> 00:55:18,480
hopefully we'll see you tomorrow night

1581
00:55:18,480 --> 00:55:20,559
if you're watching this as it's come out

1582
00:55:20,559 --> 00:55:22,799
uh hopefully we'll see you at the q a if

1583
00:55:22,799 --> 00:55:24,040
you have any questions go to the

1584
00:55:24,040 --> 00:55:26,400
hackadaya dot io page and

1585
00:55:26,400 --> 00:55:28,880
thank you very much for joining us for

1586
00:55:28,880 --> 00:55:35,839
the week three of this course

