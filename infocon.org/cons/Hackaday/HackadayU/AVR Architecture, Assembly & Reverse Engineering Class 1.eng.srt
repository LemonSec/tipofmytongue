1
00:00:00,000 --> 00:00:02,583
(upbeat music)

2
00:00:08,400 --> 00:00:12,090
- Okay, so let the party commence.

3
00:00:12,090 --> 00:00:15,270
Hello everyone and
welcome to the first class

4
00:00:15,270 --> 00:00:18,750
of AVR architecture assembly

5
00:00:18,750 --> 00:00:20,493
or reverse engineering whatever.

6
00:00:22,120 --> 00:00:23,760
In this series,

7
00:00:23,760 --> 00:00:27,130
I'm going to introduce
to you my best friend

8
00:00:27,130 --> 00:00:29,009
for the best meet few months.

9
00:00:29,010 --> 00:00:32,930
It's the data sheets
for the microcontroller

10
00:00:32,930 --> 00:00:37,350
that I guess many of you have or had

11
00:00:37,350 --> 00:00:39,920
and Arduino board at some point.

12
00:00:39,920 --> 00:00:44,920
So we are going to talk
about this microcontroller,

13
00:00:45,650 --> 00:00:49,803
in the heart of the UNO
board and many other boards.

14
00:00:51,530 --> 00:00:55,240
And I will share my screen in a second

15
00:00:55,240 --> 00:00:58,830
but I'm also going to share,

16
00:00:58,830 --> 00:01:02,004
thank you Practuce for
your comments on the chat.

17
00:01:02,005 --> 00:01:05,470
I'm also going to share a bunch
of links during the session.

18
00:01:05,470 --> 00:01:08,670
So I've created these shared document,

19
00:01:08,670 --> 00:01:11,810
where you will be able
to just find the links

20
00:01:11,810 --> 00:01:13,380
that I share in real time.

21
00:01:13,380 --> 00:01:15,810
And you can also comment there

22
00:01:15,810 --> 00:01:18,886
if you have any suggestions or anything.

23
00:01:18,886 --> 00:01:21,386
And I'm also going to be
monitoring the Zoom chat.

24
00:01:23,220 --> 00:01:24,660
So, right, let's get started.

25
00:01:24,660 --> 00:01:25,810
I'm sharing my screen.

26
00:01:25,810 --> 00:01:29,860
I will just need an indication from you

27
00:01:29,860 --> 00:01:33,610
that you can actually see my screen.

28
00:01:33,610 --> 00:01:36,530
And then we can, where is it?

29
00:01:36,530 --> 00:01:38,963
The chat, okay.

30
00:01:39,910 --> 00:01:41,200
Where is the chat?

31
00:01:41,200 --> 00:01:42,190
Here it is.

32
00:01:42,190 --> 00:01:46,020
So as soon as you tell me
that you can see my screen,

33
00:01:46,020 --> 00:01:46,990
we'll get this rolling.

34
00:01:46,990 --> 00:01:48,570
It's visible, thank you.

35
00:01:48,570 --> 00:01:53,070
Perfect, so, oh, embarrassing.

36
00:01:53,070 --> 00:01:54,083
That's my homepage.

37
00:01:55,020 --> 00:01:56,280
I'm not a unicorn.

38
00:01:56,280 --> 00:02:00,280
Anyway, so this is the document

39
00:02:00,280 --> 00:02:03,870
and we are going to dive

40
00:02:03,870 --> 00:02:08,073
into this data sheet write
away in a few minutes.

41
00:02:09,050 --> 00:02:12,550
But before we do, let
me just introduce to you

42
00:02:12,550 --> 00:02:16,440
the environment we'll be
using for the experiments.

43
00:02:16,440 --> 00:02:18,440
So this is Wokwi,

44
00:02:18,440 --> 00:02:20,800
an online Arduino stimulation environment

45
00:02:20,800 --> 00:02:23,220
I've been working on and that's why

46
00:02:23,220 --> 00:02:26,303
the data sheets and I
are such good friends.

47
00:02:27,930 --> 00:02:31,183
And we'll just get the blink examples.

48
00:02:32,068 --> 00:02:34,963
I always like to start with blink.

49
00:02:36,000 --> 00:02:38,543
Let's make the font size a bit larger.

50
00:02:39,400 --> 00:02:40,343
Let's say 24,

51
00:02:42,001 --> 00:02:45,210
and yeah, let's run it

52
00:02:45,210 --> 00:02:48,130
and we can see the LED blinking.

53
00:02:48,130 --> 00:02:50,853
Fun, fun let's remove all the comments.

54
00:02:56,009 --> 00:02:59,209
Yeah, just to get you familiar with this,

55
00:02:59,210 --> 00:03:01,580
basically we have the Arduino source code

56
00:03:01,580 --> 00:03:05,730
on the left side of the screen,
and then we also have a file

57
00:03:05,730 --> 00:03:09,609
that defines which parts
we have in the simulation.

58
00:03:09,610 --> 00:03:12,350
So in this case, we have an Arduino UNO,

59
00:03:12,350 --> 00:03:14,213
a resistor, and an LED.

60
00:03:16,240 --> 00:03:18,080
And then there is another section

61
00:03:18,080 --> 00:03:20,753
that defines the wiring, the connection.

62
00:03:22,050 --> 00:03:25,860
So UNO being ground is connected
to the cathode of the led.

63
00:03:25,860 --> 00:03:28,190
That's the blink connection.

64
00:03:28,190 --> 00:03:32,303
And we have two more blue
connections defined here.

65
00:03:34,040 --> 00:03:37,840
And we are not really going to spend time

66
00:03:37,840 --> 00:03:41,150
writing new diagrams
or changing the wiring.

67
00:03:41,150 --> 00:03:44,660
I just wanted to let you know
that this is how it's defined,

68
00:03:44,660 --> 00:03:47,058
but in this session

69
00:03:47,058 --> 00:03:50,200
and probably in all the other sessions,

70
00:03:50,200 --> 00:03:53,243
we are just going to focus on the code.

71
00:03:55,526 --> 00:03:58,620
So I asked you to do some homework

72
00:03:58,620 --> 00:04:01,213
and get yourself familiar with,

73
00:04:02,100 --> 00:04:03,963
first of all, let me share the link.

74
00:04:04,890 --> 00:04:08,269
So if any of you want
to go to the blink demo,

75
00:04:08,270 --> 00:04:09,383
this is the link.

76
00:04:11,090 --> 00:04:14,750
So I asked you to go
over some bit wise stuff

77
00:04:14,750 --> 00:04:19,480
and I will do a really
quick rehearsal of like

78
00:04:20,360 --> 00:04:22,960
how to do bit wise stuff in Arduino.

79
00:04:22,960 --> 00:04:26,419
Just show you a few
tricks that can be useful.

80
00:04:26,420 --> 00:04:29,870
So first of all, let's
set up a serial console

81
00:04:29,870 --> 00:04:32,443
and let's bring there.

82
00:04:33,650 --> 00:04:37,630
So if you want to type a
number in binary Arduino,

83
00:04:37,630 --> 00:04:39,330
there are like a few ways.

84
00:04:39,330 --> 00:04:43,039
You can just zero B and
then the sequence of bits.

85
00:04:43,040 --> 00:04:47,800
So for instance, let's
do one, zero, zero, zero

86
00:04:47,800 --> 00:04:49,993
and one, zero, zero, zero.

87
00:04:51,290 --> 00:04:53,590
And then if we run this code,

88
00:04:53,590 --> 00:04:56,940
this will actually print the decimal value

89
00:04:56,940 --> 00:04:59,290
of this binary number.

90
00:04:59,290 --> 00:05:00,123
Let's do this.

91
00:05:00,123 --> 00:05:02,183
So 136,

92
00:05:05,949 --> 00:05:07,170
that's the decimal code.

93
00:05:08,040 --> 00:05:09,910
And we can go the other way around.

94
00:05:09,910 --> 00:05:14,870
If you wanted to print
the binary value of 136,

95
00:05:14,870 --> 00:05:18,230
we could just give
serial the (indistinct).

96
00:05:18,230 --> 00:05:22,730
A second value and they
to print it in binary.

97
00:05:22,730 --> 00:05:26,580
And we got the binary result right here.

98
00:05:27,560 --> 00:05:31,123
So these are like just
a few useful utilities.

99
00:05:32,190 --> 00:05:36,890
One more utility that I
really like is the bit macro.

100
00:05:36,890 --> 00:05:40,330
So if you want like to set a specific bit,

101
00:05:40,330 --> 00:05:44,810
let's say the most significant
bit, the seventh bit,

102
00:05:44,810 --> 00:05:48,580
we just write bit seven and
that would return a number

103
00:05:49,784 --> 00:05:53,380
with the eighth from the right,

104
00:05:53,380 --> 00:05:55,240
the most significant bit set.

105
00:05:55,240 --> 00:05:58,603
And then we can go ahead and change it,

106
00:06:00,390 --> 00:06:03,400
like add a few more
bits, like bit number one

107
00:06:04,810 --> 00:06:06,690
which is the second bit, because we start

108
00:06:06,690 --> 00:06:10,730
with zero the second bit from the right.

109
00:06:10,730 --> 00:06:14,290
And basically it is Macro so useful

110
00:06:14,290 --> 00:06:16,663
and we'll use them a lot today.

111
00:06:18,874 --> 00:06:21,220
And if you're still having any questions

112
00:06:21,220 --> 00:06:25,570
about bit wise operations and
how to use them in Arduino,

113
00:06:25,570 --> 00:06:28,130
feel free to ask after in the office hours

114
00:06:28,130 --> 00:06:32,330
and we have a three
assistant here, Bow, Jake,

115
00:06:32,330 --> 00:06:36,623
and I think Alexander is the,

116
00:06:38,030 --> 00:06:39,203
the third one, right?

117
00:06:41,230 --> 00:06:42,933
Thank you Bow for the comment.

118
00:06:44,600 --> 00:06:48,510
So that was a really quick
overview of a few utilities

119
00:06:48,510 --> 00:06:51,060
that we can use to work
with bit in Arduino,

120
00:06:51,060 --> 00:06:55,750
there are a few more like
bit set, bit clear, bit read

121
00:06:55,750 --> 00:06:59,230
and we might meet them in a few moments.

122
00:06:59,230 --> 00:07:02,320
And now that we covered that,

123
00:07:02,320 --> 00:07:05,750
I want to show you an interesting example.

124
00:07:05,750 --> 00:07:09,060
So this is the short program.

125
00:07:09,060 --> 00:07:10,980
I will also share the link

126
00:07:10,980 --> 00:07:13,223
if you want to play with it yourself.

127
00:07:15,120 --> 00:07:20,120
And this program actually
does something very simple.

128
00:07:20,400 --> 00:07:23,030
It setups the serial console

129
00:07:27,526 --> 00:07:32,340
and then it prints the
address of the variable.

130
00:07:32,340 --> 00:07:35,599
So we have a variable
and it brings the address

131
00:07:35,600 --> 00:07:37,440
of the setup function.

132
00:07:37,440 --> 00:07:42,440
And I'm going to run it
and while I'm running it,

133
00:07:42,830 --> 00:07:44,263
observe the results.

134
00:07:45,620 --> 00:07:50,620
So apparently, it seems like
both this variable, var1,

135
00:07:50,910 --> 00:07:55,450
and set up they occupied
the same memory location.

136
00:07:55,450 --> 00:08:00,450
Now, usually that wouldn't
really be possible.

137
00:08:01,710 --> 00:08:04,359
Like there is a memory location,

138
00:08:04,360 --> 00:08:06,380
and it can contain one thing.

139
00:08:06,380 --> 00:08:10,190
So, how comes both the variable

140
00:08:10,190 --> 00:08:13,963
and the setup function have
the same memory address?

141
00:08:16,600 --> 00:08:21,600
And by the way, if I change
this value a bit like let's 119,

142
00:08:23,250 --> 00:08:27,560
so you can see that
var1 moves a bit above.

143
00:08:27,560 --> 00:08:30,670
So it's actually the real address of var1.

144
00:08:31,670 --> 00:08:34,039
So how could it be?

145
00:08:34,039 --> 00:08:38,793
And I think this is the first
interesting thing about AVR

146
00:08:40,750 --> 00:08:45,660
and we can find it in the section.

147
00:08:45,660 --> 00:08:48,863
Let me just move away the
participant list, okay.

148
00:08:49,730 --> 00:08:51,910
About the memory section.

149
00:08:51,910 --> 00:08:56,533
And as soon as we open the
memory section in the data sheet,

150
00:08:57,520 --> 00:08:58,760
and actually, you know what?

151
00:08:58,760 --> 00:09:02,173
Let me paste the link to this data sheet,

152
00:09:02,173 --> 00:09:06,173
so you all have it, just a moment.

153
00:09:07,090 --> 00:09:12,090
This is the link AVR (indistinct).

154
00:09:16,371 --> 00:09:17,573
If you want to check it out,

155
00:09:17,573 --> 00:09:20,451
this is the data sheet.

156
00:09:20,451 --> 00:09:24,201
So you can see that the AVR architecture

157
00:09:26,350 --> 00:09:28,470
actually has two main memory spaces,

158
00:09:28,470 --> 00:09:31,660
the data memory and the
program memory spaces.

159
00:09:31,660 --> 00:09:35,160
So basically, there are like two sets

160
00:09:35,160 --> 00:09:40,060
of memory addresses and they are separate.

161
00:09:40,060 --> 00:09:42,689
And that's something
that is not very common.

162
00:09:42,690 --> 00:09:45,840
If you are used to other
platforms such as XAD6,

163
00:09:47,980 --> 00:09:52,210
like Intel or Arm, they
have one address space,

164
00:09:52,210 --> 00:09:55,040
with everything, with
the code and the data,

165
00:09:55,040 --> 00:09:57,260
but no, AVR is different.

166
00:09:57,260 --> 00:09:58,150
You have...

167
00:10:02,254 --> 00:10:04,480
A different space of
addresses for the variables

168
00:10:04,480 --> 00:10:08,170
and the data and another set for the code.

169
00:10:08,170 --> 00:10:12,569
And that's the reason why the var1

170
00:10:12,570 --> 00:10:14,980
and the setup had the same address.

171
00:10:14,980 --> 00:10:17,470
Like it's the same address,

172
00:10:17,470 --> 00:10:20,380
but it's a different address pace.

173
00:10:20,380 --> 00:10:24,633
And if we want to be accurate,

174
00:10:25,506 --> 00:10:29,010
actually the datasheet
also mentioned that,

175
00:10:29,010 --> 00:10:32,770
there is a third address
space for the E-Pro memory

176
00:10:34,170 --> 00:10:37,229
and we are not going to
bother with it right now

177
00:10:37,230 --> 00:10:39,530
but there are like three memory addresses,

178
00:10:39,530 --> 00:10:43,563
three different spaces of addresses.

179
00:10:45,520 --> 00:10:49,329
And then it goes in depth
to describe the memory.

180
00:10:49,330 --> 00:10:52,450
And we can see that the program memory,

181
00:10:52,450 --> 00:10:55,890
starts at this address and actually, yeah,

182
00:10:55,890 --> 00:10:58,093
this is for the 32 eight.

183
00:10:59,140 --> 00:11:01,939
So the program memory
starts at this address,

184
00:11:01,940 --> 00:11:04,760
and ends at this address,

185
00:11:04,760 --> 00:11:09,640
and then this is for our worksheet,

186
00:11:09,640 --> 00:11:14,600
this is the starter address,
and this is the end address.

187
00:11:14,600 --> 00:11:18,410
But if we check out the
second address space,

188
00:11:18,410 --> 00:11:21,949
the data memory, it's actually
a bit more interesting.

189
00:11:21,950 --> 00:11:26,950
And we can see that it has a few sections.

190
00:11:27,340 --> 00:11:30,280
So the program memory is pretty simple,

191
00:11:30,280 --> 00:11:33,670
one address space with
the code of the program

192
00:11:33,670 --> 00:11:36,260
from the flesh, but the data memory,

193
00:11:36,260 --> 00:11:39,140
it has like these registers

194
00:11:39,140 --> 00:11:42,830
which we will get to when
we dive into assembly.

195
00:11:42,830 --> 00:11:47,720
And then it has that IO registers,

196
00:11:47,720 --> 00:11:52,720
and you can see that there
are like 64 IO registers,

197
00:11:53,130 --> 00:11:56,939
and then there are a few
extended IO registers.

198
00:11:56,940 --> 00:11:59,150
And these IO registers,

199
00:11:59,150 --> 00:12:03,180
let us control the peripherals
like the GPIO ports

200
00:12:03,180 --> 00:12:06,900
and things that are a part
of the microcontroller.

201
00:12:06,900 --> 00:12:11,030
So (indistinct) SPI,

202
00:12:11,030 --> 00:12:13,780
they are all controlled
by writing and reading

203
00:12:13,780 --> 00:12:18,480
from these addresses, either
these ones or these ones.

204
00:12:18,480 --> 00:12:22,530
And for now, there isn't a big difference

205
00:12:22,530 --> 00:12:26,189
for you between the standard
and the extended IRA registers.

206
00:12:26,190 --> 00:12:29,030
When we get to assembly,
there will be a difference.

207
00:12:29,030 --> 00:12:34,030
And we also have another
sort of address space,

208
00:12:35,020 --> 00:12:37,050
which is the IO address space.

209
00:12:37,050 --> 00:12:38,790
I'm not going to talk about it today,

210
00:12:38,790 --> 00:12:40,089
but when we get to assembly,

211
00:12:40,090 --> 00:12:42,757
we'll have to recognize that it exists.

212
00:12:43,670 --> 00:12:47,469
And finally, after the
registers and the IO registers,

213
00:12:47,470 --> 00:12:49,970
we also have the SRAM memory,

214
00:12:49,970 --> 00:12:52,493
which is where we store our variable.

215
00:12:53,440 --> 00:12:56,450
So that's why all the
variables that we have,

216
00:12:56,450 --> 00:13:01,450
will always have this address
of 100 hexa and above.

217
00:13:01,610 --> 00:13:05,510
If we declare a variable, it
will always get an address

218
00:13:05,510 --> 00:13:08,530
between this value and that value,

219
00:13:08,530 --> 00:13:13,530
which is the maximum for the
chip that we are working with.

220
00:13:14,050 --> 00:13:16,483
It would be 30, 30 to eight.

221
00:13:17,770 --> 00:13:20,069
So that was like a quick overview

222
00:13:20,070 --> 00:13:22,650
about the memories that we have,

223
00:13:22,650 --> 00:13:25,270
the program memory and the data memory.

224
00:13:25,270 --> 00:13:28,949
And I think the important
takeaway is to remember

225
00:13:28,950 --> 00:13:31,530
that they are two distinct things.

226
00:13:31,530 --> 00:13:34,839
And when we are asking to read data

227
00:13:34,839 --> 00:13:39,839
we should tell the microcontroller,

228
00:13:40,130 --> 00:13:42,160
if we want to read from the memory

229
00:13:42,160 --> 00:13:44,560
or from the program at risk space.

230
00:13:44,560 --> 00:13:46,199
When we write, it's pretty simple,

231
00:13:46,200 --> 00:13:49,630
because we can only
write to the data space

232
00:13:49,630 --> 00:13:51,273
and not to the program space.

233
00:13:53,350 --> 00:13:58,350
So with that, let's start
exploring how we can interface

234
00:14:00,360 --> 00:14:02,880
with the actual hardware.

235
00:14:02,880 --> 00:14:06,610
So, as I mentioned, there
are like these IRA registers

236
00:14:06,610 --> 00:14:09,700
and they let us control the hardware.

237
00:14:09,700 --> 00:14:13,810
And the first piece of hardware
that we are going to control

238
00:14:13,810 --> 00:14:16,949
is the GPA or ports.

239
00:14:16,950 --> 00:14:21,870
So these are like the
PINDS that you have on your

240
00:14:21,870 --> 00:14:23,480
Arduino UNO.

241
00:14:23,480 --> 00:14:28,240
And if we go to the
section that talks about

242
00:14:28,240 --> 00:14:30,303
the PIND configurations,

243
00:14:31,210 --> 00:14:34,230
it shows us the, the layout of the chip.

244
00:14:34,230 --> 00:14:36,970
This is the layout of the chip.

245
00:14:36,970 --> 00:14:38,440
And you can see, like,

246
00:14:38,440 --> 00:14:43,440
it has all those different
PINDS called PC 0, PC one,

247
00:14:44,252 --> 00:14:47,359
PB one, Pb five, et cetera.

248
00:14:47,360 --> 00:14:51,661
And if you are used to
working with Arduino UNO,

249
00:14:51,661 --> 00:14:56,661
you are probably just
used to PINDS zero to 13

250
00:14:57,210 --> 00:14:59,193
and A zero to A five.

251
00:15:00,170 --> 00:15:04,380
And the quick way to know which is which

252
00:15:04,380 --> 00:15:07,370
is just to Google images
Arduino UNO PIND out,

253
00:15:07,370 --> 00:15:11,280
And like, there are many
guides like this one.

254
00:15:11,280 --> 00:15:15,903
So you can find a bunch of
images that show you the PINDS

255
00:15:17,490 --> 00:15:22,313
but usually you get, opening your tab.

256
00:15:23,280 --> 00:15:25,713
Usually you get used to it really quick.

257
00:15:28,439 --> 00:15:33,000
Yeah, usually you get
used to it real quick.

258
00:15:33,000 --> 00:15:38,000
Basically all the analog PINDS
are just PC zero to PC five

259
00:15:38,060 --> 00:15:39,619
and then the digital PIND,

260
00:15:39,620 --> 00:15:43,890
or PTC or two PD eight to PD seven.

261
00:15:43,890 --> 00:15:48,890
So starting with PD, and then
let's remove this window.

262
00:15:49,330 --> 00:15:54,100
And then the remaining few
are PB zero two PB five.

263
00:15:54,100 --> 00:15:55,840
So you just need to remember

264
00:15:55,840 --> 00:15:59,420
that these are their
names when you are working

265
00:15:59,420 --> 00:16:03,579
with the microcontroller, not
with the Arduino environment

266
00:16:03,580 --> 00:16:07,500
and Arduino itself takes
care of the mapping.

267
00:16:07,500 --> 00:16:09,720
I think I actually have the code here.

268
00:16:09,720 --> 00:16:13,200
So if we have time, we
can take a look at it

269
00:16:13,200 --> 00:16:16,950
during the office hours and see
how the PIND mapping happens

270
00:16:16,950 --> 00:16:19,023
in the Arduino runtime library.

271
00:16:20,150 --> 00:16:23,829
Anyways, getting back to the PINDS.

272
00:16:23,830 --> 00:16:28,320
So we now know how to map
between Arduino PIND numbers

273
00:16:28,320 --> 00:16:30,890
and those PC one, PC two.

274
00:16:30,890 --> 00:16:32,660
And let's see, we have this LED,

275
00:16:32,660 --> 00:16:36,060
it's connected to PIND number 13.

276
00:16:36,060 --> 00:16:38,900
And according to this PIND out,

277
00:16:38,900 --> 00:16:42,550
PIND number 13 is actually PB five.

278
00:16:42,550 --> 00:16:47,250
So what we are going
to do, we are going to,

279
00:16:47,250 --> 00:16:50,580
instead of using the Arduino functions,

280
00:16:50,580 --> 00:16:53,020
we don't, we do need these one.

281
00:16:53,020 --> 00:16:56,560
Instead of using the Arduino
functions to control this PIND

282
00:16:56,560 --> 00:17:01,560
we are going to use the GPIO registers,

283
00:17:01,990 --> 00:17:03,500
just write to the registers

284
00:17:03,500 --> 00:17:07,119
and turn the LED on and off.

285
00:17:07,119 --> 00:17:08,469
And in order to do that,

286
00:17:08,470 --> 00:17:13,470
we will open the section that
talks about the IO ports.

287
00:17:15,477 --> 00:17:19,603
And if you, you will
probably recognize soon

288
00:17:19,603 --> 00:17:21,470
that there is a pattern.

289
00:17:21,470 --> 00:17:24,619
Each section starts with like an overview

290
00:17:24,619 --> 00:17:28,040
or description of that peripheral.

291
00:17:28,040 --> 00:17:29,659
In this case, the GPIO

292
00:17:31,076 --> 00:17:34,340
then at some specific section,

293
00:17:34,340 --> 00:17:37,030
depending on the specific peripheral,

294
00:17:37,030 --> 00:17:39,870
but it always ends with
register description.

295
00:17:39,870 --> 00:17:41,340
So it tells us

296
00:17:42,440 --> 00:17:47,440
which registers we have
available to work with.

297
00:17:48,020 --> 00:17:52,500
So in this case, we can see that we have

298
00:17:54,390 --> 00:17:58,820
for each of the ports, PB
PC, and PD port C and port D,

299
00:18:00,150 --> 00:18:01,350
we have three registers.

300
00:18:02,470 --> 00:18:05,090
The port data register,
data direction register,

301
00:18:05,090 --> 00:18:07,260
and the input PIND address.

302
00:18:07,260 --> 00:18:09,890
So there is a set of
these three registers,

303
00:18:09,890 --> 00:18:14,690
for port B, for port C,

304
00:18:14,690 --> 00:18:17,810
and for port D,

305
00:18:17,810 --> 00:18:20,682
and what we basically want to do.

306
00:18:20,682 --> 00:18:25,682
We want to set one of the PINDS to high.

307
00:18:27,400 --> 00:18:30,500
But before we can set it to high or low,

308
00:18:30,500 --> 00:18:33,850
we need to also set it
PIND mode to output.

309
00:18:33,850 --> 00:18:36,110
So what is the equivalent of this code

310
00:18:36,110 --> 00:18:39,663
in this GPIO length?

311
00:18:41,300 --> 00:18:42,879
To get an answer for that,

312
00:18:42,880 --> 00:18:45,100
we actually need to read the texts

313
00:18:45,100 --> 00:18:47,040
and not just look at the registers.

314
00:18:47,040 --> 00:18:49,680
Even though sometimes just
by looking at the registers

315
00:18:49,680 --> 00:18:52,940
you can get a pretty good understanding

316
00:18:52,940 --> 00:18:56,593
of how you would do things.

317
00:18:58,016 --> 00:19:02,950
And there is pretty a lot of data here,

318
00:19:02,950 --> 00:19:05,553
but I think this,

319
00:19:11,760 --> 00:19:16,343
this is where they start
to explain how things work.

320
00:19:21,785 --> 00:19:26,040
So you can see that if we
want to configure the PIND,

321
00:19:26,040 --> 00:19:30,332
then we have to use the DDXN.

322
00:19:31,730 --> 00:19:33,970
So DDRA, DDRBC or D

323
00:19:38,290 --> 00:19:39,879
to select the direction of the PIND.

324
00:19:39,880 --> 00:19:41,860
If we are writing logic one,

325
00:19:41,860 --> 00:19:45,830
so if the DDX and bit,

326
00:19:45,830 --> 00:19:48,370
when we look at the
register, we will see this DD

327
00:19:48,370 --> 00:19:53,280
like, they call the bits DD zero to DDC,

328
00:19:53,280 --> 00:19:55,000
zero to DDC seven.

329
00:19:55,000 --> 00:19:56,420
So if it's written one

330
00:19:56,420 --> 00:19:58,700
then the PIND is configured as output.

331
00:19:58,700 --> 00:20:02,130
If it's original zero, the
PIND is configured as input.

332
00:20:02,130 --> 00:20:05,800
So in our case, let's write it down,

333
00:20:05,800 --> 00:20:09,620
we want to to configure

334
00:20:13,925 --> 00:20:15,409
PD, that was PD five,

335
00:20:15,410 --> 00:20:18,683
PB sorry, PB five, that was PIND 13.

336
00:20:18,683 --> 00:20:22,000
We used the mapping and
we saw it's PB five.

337
00:20:22,000 --> 00:20:25,277
So we want to configure PB five as output,

338
00:20:26,984 --> 00:20:31,300
and we can do it as the
data sheet suggested,

339
00:20:31,300 --> 00:20:33,147
by setting a DDRB

340
00:20:35,100 --> 00:20:39,270
and just setting a bit number five.

341
00:20:39,270 --> 00:20:41,370
So let's try it out.

342
00:20:41,370 --> 00:20:43,889
And we can see our code still works.

343
00:20:43,890 --> 00:20:48,250
If we remove that then the,
actually the LED still blinks

344
00:20:48,250 --> 00:20:52,263
because of the pull up register.

345
00:20:53,610 --> 00:20:56,439
But, and you can't
really see the difference

346
00:20:56,440 --> 00:20:58,340
in the simulation write now.

347
00:20:58,340 --> 00:21:01,899
But this is the equivalent of this code.

348
00:21:01,900 --> 00:21:05,970
And now let's replace this digital writes

349
00:21:05,970 --> 00:21:09,660
with a port like writing two registers.

350
00:21:09,660 --> 00:21:14,660
So we can see that if port,
whatever is written logic one

351
00:21:15,090 --> 00:21:15,985
when the PIND is
configured as output PIND,

352
00:21:15,985 --> 00:21:18,729
it's driven high.

353
00:21:18,730 --> 00:21:22,520
If it's written logic zero and
the PIND is configured output

354
00:21:23,872 --> 00:21:25,820
then that PIND is driven low.

355
00:21:25,820 --> 00:21:30,040
So basically we just need
to toggle the ports register

356
00:21:32,780 --> 00:21:36,520
so we could write, instead of this,

357
00:21:36,520 --> 00:21:41,520
we can write port B, so B is set.

358
00:21:41,550 --> 00:21:43,713
We want to set bit number five,

359
00:21:44,740 --> 00:21:48,600
and then to toggle it low,

360
00:21:48,600 --> 00:21:53,080
we would like to just
clear that bit, unset it.

361
00:21:53,080 --> 00:21:56,500
And again, these are like,
just help our macros.

362
00:21:56,500 --> 00:21:58,750
And we can see that we
get the same behavior.

363
00:21:58,750 --> 00:22:03,027
So now we blink the LED instead of five,

364
00:22:04,930 --> 00:22:07,940
we could have also used like,

365
00:22:07,940 --> 00:22:10,730
those like, they have constance,

366
00:22:10,730 --> 00:22:15,730
so we can say port B five,
and that's basically,

367
00:22:17,340 --> 00:22:22,340
equals to five, but
usually I just write five

368
00:22:22,760 --> 00:22:26,570
instead of using this
constants because it's shorter.

369
00:22:26,570 --> 00:22:28,362
And I think it's clear enough.

370
00:22:30,190 --> 00:22:35,020
And by the way, we could have
also written it like this way

371
00:22:38,480 --> 00:22:40,740
instead of using the macros,

372
00:22:40,740 --> 00:22:44,970
that's what these macros expend to.

373
00:22:44,970 --> 00:22:46,663
So basically,

374
00:22:50,180 --> 00:22:53,300
that would be the equivalent
of what we had but

375
00:22:53,300 --> 00:22:56,310
I think the macros are much more

376
00:22:57,274 --> 00:22:59,300
easy to follow in those thirds.

377
00:22:59,300 --> 00:23:02,300
So I usually use them
when I work with Arduino.

378
00:23:02,300 --> 00:23:04,250
And these are Arduino specific macros,

379
00:23:04,250 --> 00:23:08,170
if you are with the AVR
C compiler tool chain,

380
00:23:08,170 --> 00:23:10,363
then you obviously can't use them.

381
00:23:12,340 --> 00:23:17,053
And then there is another
interesting bit of information.

382
00:23:18,120 --> 00:23:22,070
It says that writing logic one to PIND XN,

383
00:23:22,070 --> 00:23:24,370
toggles the value of PORTx

384
00:23:24,370 --> 00:23:27,270
and independent of the failure of DDR.

385
00:23:27,270 --> 00:23:31,070
So instead of like setting it too high

386
00:23:31,070 --> 00:23:32,639
then setting it too low,

387
00:23:32,640 --> 00:23:34,960
we can just, so,

388
00:23:34,960 --> 00:23:38,280
if we just do it like
that, it will always be on.

389
00:23:38,280 --> 00:23:43,280
But if we write to bit number
five of the PIND B register

390
00:23:43,840 --> 00:23:45,179
as the (indistinct) said,

391
00:23:45,180 --> 00:23:47,850
it will actually toggle the PIND.

392
00:23:47,850 --> 00:23:52,850
So it turns out that using
the direct register Xs,

393
00:23:53,960 --> 00:23:56,890
actually produces shorter code,

394
00:23:56,890 --> 00:24:01,377
in comparison with, you know, just using

395
00:24:04,330 --> 00:24:09,320
digital write and PIND mode
and to make it more fun,

396
00:24:09,320 --> 00:24:13,379
let's look what happens
when we connect LEDs

397
00:24:13,380 --> 00:24:15,780
to all these PINDS.

398
00:24:15,780 --> 00:24:20,340
So, PIND zero to PIND
seven, these all are...

399
00:24:21,370 --> 00:24:22,939
Where was that?

400
00:24:22,940 --> 00:24:25,910
Yup, PIND zero through PIND seven,

401
00:24:25,910 --> 00:24:29,700
They are like PD zero to PD seven.

402
00:24:29,700 --> 00:24:32,480
And usually if you wanted to use the

403
00:24:32,480 --> 00:24:37,200
Arduino digital write API
to control these PINDS,

404
00:24:37,200 --> 00:24:39,610
we would have to write a loop.

405
00:24:39,610 --> 00:24:44,510
So right now I have like
this code that toggles

406
00:24:45,720 --> 00:24:48,840
that specific PIND number one.

407
00:24:48,840 --> 00:24:53,230
But if we work directly
with the registers,

408
00:24:53,230 --> 00:24:56,353
we can just say something like this.

409
00:24:58,440 --> 00:25:02,720
Port D because these
are PD zero to PD seven

410
00:25:02,720 --> 00:25:07,720
is just all ones, or maybe this will even

411
00:25:07,960 --> 00:25:12,520
be a bit clearer, just set
all the PINDS to output.

412
00:25:12,520 --> 00:25:15,847
And then we can say,
just toggle (indistinct).

413
00:25:18,372 --> 00:25:23,270
We can just, sorry, DDR
to set a better direction.

414
00:25:23,270 --> 00:25:26,000
And then we can just
like, we did it before,

415
00:25:26,000 --> 00:25:28,280
write to the PIND registered to toggle,

416
00:25:28,280 --> 00:25:30,020
all those PINDS at once.

417
00:25:30,020 --> 00:25:31,840
Let's see that.

418
00:25:31,840 --> 00:25:33,699
So isn't it amazing?

419
00:25:33,700 --> 00:25:36,730
Controlling eight different LEDs,

420
00:25:36,730 --> 00:25:41,453
in just like a few lines of code.

421
00:25:42,520 --> 00:25:45,840
We can either do other fun things like,

422
00:25:45,840 --> 00:25:49,503
using bit shifts to, you know,

423
00:25:50,750 --> 00:25:52,457
use the.....

424
00:25:54,250 --> 00:25:57,710
To create sliding patterns
and stuff like that.

425
00:25:57,710 --> 00:26:01,440
But the thing is, this
is how you would normally

426
00:26:01,440 --> 00:26:04,960
write code to interface
with the GPA opiates.

427
00:26:04,960 --> 00:26:08,170
If you didn't have the
Arduino library that provides

428
00:26:08,170 --> 00:26:10,079
all these obstructions.

429
00:26:10,079 --> 00:26:13,760
If we check out the source
code for the Arduino library,

430
00:26:13,760 --> 00:26:17,420
we'll see that they're
using these exact registers

431
00:26:18,490 --> 00:26:19,900
behind the scenes.

432
00:26:19,900 --> 00:26:23,240
So let me also share
the link to this setup,

433
00:26:23,240 --> 00:26:26,913
if you want to take a look.

434
00:26:31,060 --> 00:26:34,753
Yup, somebody added
some useful information,

435
00:26:36,087 --> 00:26:39,433
LEDs on port D.

436
00:26:41,280 --> 00:26:44,812
Okay, so this is the link,
if you want to check it out.

437
00:26:46,320 --> 00:26:50,270
And, okay.

438
00:26:50,270 --> 00:26:54,490
And one more fun experiment,

439
00:26:54,490 --> 00:26:58,073
so we worked with the output PINDS,

440
00:26:59,436 --> 00:27:04,139
and that's when we said DDR to one,

441
00:27:04,140 --> 00:27:06,470
we know we set a PIND to output,

442
00:27:06,470 --> 00:27:09,430
but we can also set it to input,

443
00:27:09,430 --> 00:27:12,973
and let's go back to the
section about the registers.

444
00:27:17,001 --> 00:27:20,760
So, yeah, so we use like
all these three registers

445
00:27:20,760 --> 00:27:22,710
like, for it to be just, you know,

446
00:27:22,710 --> 00:27:27,473
to write who I want, I
clicked the wrong link.

447
00:27:28,860 --> 00:27:31,773
So let's go to the last one.

448
00:27:35,121 --> 00:27:37,980
So port D to write

449
00:27:42,250 --> 00:27:44,370
to control these eight PINDS

450
00:27:44,370 --> 00:27:48,049
and then through set them high or low

451
00:27:48,049 --> 00:27:49,730
DDRT to set a direction.

452
00:27:49,730 --> 00:27:53,080
And then we used PIND, it
actually says input PINDS,

453
00:27:53,080 --> 00:27:55,696
but we use it to toggle.

454
00:27:55,696 --> 00:27:56,529
So, right?

455
00:27:56,529 --> 00:27:57,960
It also mentioned that the, here,

456
00:27:57,960 --> 00:28:01,020
writing to the PIND register
provides toggle functionality

457
00:28:01,020 --> 00:28:01,853
for the IO.

458
00:28:03,791 --> 00:28:05,200
(indistinct)Thanks for
sharing the link for

459
00:28:05,200 --> 00:28:06,980
the core library.

460
00:28:06,980 --> 00:28:08,913
Let me just add it to the document,

461
00:28:11,777 --> 00:28:14,160
AVR or get a report to do oh, nice!

462
00:28:14,160 --> 00:28:19,160
Somebody added to do with
the link so I will do it.

463
00:28:20,860 --> 00:28:22,080
So there we go.

464
00:28:22,080 --> 00:28:23,362
You have that link here.

465
00:28:27,647 --> 00:28:30,370
So yeah, let's see what happens,

466
00:28:30,370 --> 00:28:32,989
when we try to use these as input.

467
00:28:32,990 --> 00:28:35,640
So I have another demo here with,

468
00:28:35,640 --> 00:28:37,720
this time with the eight switches,

469
00:28:37,720 --> 00:28:39,730
that are connected to the PINDS.

470
00:28:39,730 --> 00:28:42,993
And normally,

471
00:28:44,080 --> 00:28:46,840
I wouldn't be able to use those two.

472
00:28:46,840 --> 00:28:50,860
If I enabled serial
output in the simulator,

473
00:28:50,860 --> 00:28:53,919
it would work, but normally it wouldn't.

474
00:28:53,920 --> 00:28:57,180
So instead I connected a small LCD screen,

475
00:28:57,180 --> 00:29:01,370
so we can just print out
boot to this LCD screen.

476
00:29:01,370 --> 00:29:04,169
And in this case,

477
00:29:04,170 --> 00:29:07,230
we are going to set all
these PINDS as input.

478
00:29:07,230 --> 00:29:09,530
So basically we need to write to DDRD.

479
00:29:10,670 --> 00:29:14,400
We need to write our zero
for all the PINDS, so,

480
00:29:14,400 --> 00:29:16,060
to send them as input.

481
00:29:16,060 --> 00:29:20,639
But if you remember, when
we read from a button,

482
00:29:20,640 --> 00:29:23,140
we usually need a pull up resistor.

483
00:29:23,140 --> 00:29:26,760
And we don't have any pull up
resistors in this schematics.

484
00:29:26,760 --> 00:29:29,760
So we want to enable the pull up resistors

485
00:29:29,760 --> 00:29:31,913
for those PINDS and for that,

486
00:29:32,980 --> 00:29:36,133
if we go back to the description,

487
00:29:38,320 --> 00:29:43,023
somewhere, you can see that....

488
00:29:47,909 --> 00:29:52,200
So if PORTxn is written logic one

489
00:29:52,200 --> 00:29:54,550
when the PIND is configured
as digital input PIND,

490
00:29:54,550 --> 00:29:58,430
like we are doing now, the
pull-up resistor is activated.

491
00:29:58,430 --> 00:30:03,430
So writing zero, deactivates the

492
00:30:03,510 --> 00:30:05,403
switch (indistinct) for resistor off.

493
00:30:08,229 --> 00:30:11,630
So basically in order
to enable the pull up,

494
00:30:11,630 --> 00:30:15,000
that was this one, let me also
put the link in the document.

495
00:30:15,000 --> 00:30:18,830
So that's switches,

496
00:30:18,830 --> 00:30:20,582
has to be switches.

497
00:30:21,556 --> 00:30:24,520
Okay, so in order to

498
00:30:26,290 --> 00:30:29,817
set up the data register,

499
00:30:29,817 --> 00:30:31,457
the pull up resistors,

500
00:30:32,690 --> 00:30:35,950
we just need to write to port D

501
00:30:35,950 --> 00:30:40,580
and tell it to enable it
for set (indistinct) to one

502
00:30:40,580 --> 00:30:44,379
to enable it to, for all these PINDS.

503
00:30:44,380 --> 00:30:45,853
And now all we need to do,

504
00:30:47,720 --> 00:30:49,170
we can just, you know,

505
00:30:49,170 --> 00:30:53,730
LCD clear, let's actually,

506
00:30:53,730 --> 00:30:55,060
okay, let's start this way.

507
00:30:55,060 --> 00:30:58,090
LCD that's clear, and then LCD the print

508
00:30:58,090 --> 00:31:03,090
and we can print the value
of PIND B, PIND D sorry.

509
00:31:04,720 --> 00:31:07,920
We said that PIND is the
port in port register,

510
00:31:07,920 --> 00:31:11,380
It let's us read from
the port or toggle 18,

511
00:31:11,380 --> 00:31:12,970
that output mode.

512
00:31:12,970 --> 00:31:15,073
And we want to print it as binary.

513
00:31:16,240 --> 00:31:18,283
I need to disable notifications.

514
00:31:20,570 --> 00:31:24,080
Yeah, so we can see
it's quite interesting,

515
00:31:24,080 --> 00:31:26,633
because we run this continuously.

516
00:31:35,583 --> 00:31:37,790
So we run this continuously,

517
00:31:37,790 --> 00:31:41,960
so we clear the screen repeatedly and...

518
00:31:44,240 --> 00:31:45,300
What do we want to do?

519
00:31:45,300 --> 00:31:47,590
We just want to print it
if the value has changed.

520
00:31:47,590 --> 00:31:51,770
So let's start by value.

521
00:31:51,770 --> 00:31:56,770
And then we can say value
byte, new value equals PIND B.

522
00:31:58,930 --> 00:32:02,340
And then if new value doesn't equal

523
00:32:02,340 --> 00:32:07,312
to the existing value,
then we only print it,

524
00:32:08,870 --> 00:32:12,523
and then value equals to new value.

525
00:32:13,380 --> 00:32:16,690
So just so we can see the output,

526
00:32:16,690 --> 00:32:20,050
and let's just set it to
some random value initially.

527
00:32:20,050 --> 00:32:22,480
So yeah.

528
00:32:22,480 --> 00:32:27,480
And so yeah.

529
00:32:27,560 --> 00:32:29,600
You can see those...

530
00:32:30,710 --> 00:32:32,210
Yeah, for some reason...

531
00:32:32,210 --> 00:32:34,150
Yeah, I said it, so yeah...

532
00:32:34,150 --> 00:32:36,540
I need to print a new
value and not the value,

533
00:32:36,540 --> 00:32:38,250
now it will be correct.

534
00:32:38,250 --> 00:32:40,660
So you can see it prints all ones.

535
00:32:40,660 --> 00:32:43,830
And if I start toggling these PINDS,

536
00:32:43,830 --> 00:32:46,460
it will actually flip the bit,

537
00:32:46,460 --> 00:32:51,283
when one of these switches is closed,

538
00:32:51,283 --> 00:32:52,793
when the circuit is closed.

539
00:32:54,360 --> 00:32:55,193
So yeah.

540
00:32:55,193 --> 00:32:56,889
So that's how it works.

541
00:32:56,890 --> 00:32:58,980
And you can play with it.

542
00:32:58,980 --> 00:33:03,130
By the way, using Bing, isn't
the perfect solution here

543
00:33:03,130 --> 00:33:05,570
because it won't print any leading zeros.

544
00:33:05,570 --> 00:33:10,070
So if I switch this one,
it will actually disappear.

545
00:33:10,070 --> 00:33:11,540
There should have been a zero,

546
00:33:11,540 --> 00:33:14,750
but it doesn't print learning zeros.

547
00:33:14,750 --> 00:33:19,750
So, you know, the leftmost
zeros just disappear.

548
00:33:20,940 --> 00:33:24,812
So we could have written a short follow

549
00:33:24,812 --> 00:33:28,370
that would print the, all
the bits, nevertheless.

550
00:33:28,370 --> 00:33:32,379
But I think just for the
demo purposes, this is fine.

551
00:33:32,380 --> 00:33:34,930
So I just wanted you
to know this limitation

552
00:33:34,930 --> 00:33:37,603
of using the print with Bing.

553
00:33:38,730 --> 00:33:43,730
Okay, so that was like a quick
tour of the GPRI registers.

554
00:33:44,010 --> 00:33:47,150
And what I want you to
take away from here,

555
00:33:47,150 --> 00:33:49,720
is not just like, okay.

556
00:33:49,720 --> 00:33:52,973
We now know how to work
with those registers.

557
00:33:54,810 --> 00:33:58,429
But I want you to start
getting comfortable

558
00:33:58,430 --> 00:34:01,120
with reading this data sheet.

559
00:34:01,120 --> 00:34:03,570
And, you know, it takes time.

560
00:34:03,570 --> 00:34:06,883
I mean, I knew where to look
because I read it before.

561
00:34:08,137 --> 00:34:09,139
What I usually do,

562
00:34:09,139 --> 00:34:12,759
I just, you know, read
the entire section once,

563
00:34:12,760 --> 00:34:14,670
then look at the registers.

564
00:34:14,670 --> 00:34:17,590
Only then I start to, you know,

565
00:34:17,590 --> 00:34:19,693
go back and forth like I did now.

566
00:34:21,530 --> 00:34:22,980
And before we...

567
00:34:26,000 --> 00:34:30,130
Somebody asked if there is
a way to get leading zeros.

568
00:34:30,130 --> 00:34:32,133
Not that I'm aware of.

569
00:34:34,020 --> 00:34:38,270
I guess there could be some.

570
00:34:38,270 --> 00:34:41,270
No, I don't have anything
that comes to my mind.

571
00:34:41,270 --> 00:34:42,780
Let's close this.

572
00:34:42,780 --> 00:34:44,810
We didn't need this anymore.

573
00:34:44,810 --> 00:34:48,422
Neither of these, nothing that
comes to my mind right now.

574
00:34:49,520 --> 00:34:51,500
So you probably have to do it manually,

575
00:34:51,500 --> 00:34:53,973
or use some external library.

576
00:34:59,064 --> 00:35:02,770
So, before we part ways
with the GPA (indistinct)

577
00:35:02,770 --> 00:35:04,363
one more thing to show you,

578
00:35:05,530 --> 00:35:10,530
so this register description
is like super common.

579
00:35:10,750 --> 00:35:12,510
You will find it in every section

580
00:35:12,510 --> 00:35:15,450
and it has a very specific format.

581
00:35:15,450 --> 00:35:18,870
So you see the name of the
register, quick description,

582
00:35:18,870 --> 00:35:21,859
then all the bits and each bit has a name.

583
00:35:21,860 --> 00:35:25,120
And this name is actually
a constant that equals

584
00:35:25,120 --> 00:35:26,230
to the index of the bit.

585
00:35:26,230 --> 00:35:29,830
So port before just equals four.

586
00:35:29,830 --> 00:35:33,600
And the register itself, you can see like

587
00:35:33,600 --> 00:35:37,060
for each of the bits, if
it's read, write or browse,

588
00:35:37,060 --> 00:35:40,549
in most cases, the bits
will be read, write.

589
00:35:40,550 --> 00:35:44,033
Unless they don't have
a specific function.

590
00:35:46,140 --> 00:35:50,650
And some cases like this one,

591
00:35:50,650 --> 00:35:52,450
it doesn't have a specific function

592
00:35:52,450 --> 00:35:55,270
and you can also see the
initial value of the PIND.

593
00:35:55,270 --> 00:36:00,270
And usually almost every
time, almost always it's zero,

594
00:36:00,640 --> 00:36:02,620
but there are a very few cases,

595
00:36:02,620 --> 00:36:04,020
I think in the (indistinct).

596
00:36:05,920 --> 00:36:10,110
Registers that they actually
start with the value of one.

597
00:36:10,110 --> 00:36:13,260
And one last thing to point
to know about the registers,

598
00:36:13,260 --> 00:36:16,620
there is like these two numbers,

599
00:36:16,620 --> 00:36:18,770
and this is the first time we'll meet

600
00:36:18,770 --> 00:36:20,330
the IO address space.

601
00:36:20,330 --> 00:36:23,692
So this is the IO address space,

602
00:36:25,130 --> 00:36:26,150
address of the memory.

603
00:36:26,150 --> 00:36:27,850
And this is the data address space.

604
00:36:27,850 --> 00:36:30,529
So this is the address
that you will normally use.

605
00:36:30,530 --> 00:36:34,610
The one in the parentheses,
I fell for it multiple times.

606
00:36:34,610 --> 00:36:39,610
And we can, you know, verify
if let's just take this demo,

607
00:36:40,280 --> 00:36:45,268
and serial begin, serial
print (indistinct)

608
00:36:45,268 --> 00:36:48,583
So, let's print the address of port B.

609
00:36:51,320 --> 00:36:56,320
Has (indistinct) and bit failed...

610
00:36:57,700 --> 00:36:59,939
Yeah, we need to type that stage,

611
00:36:59,940 --> 00:37:01,690
so it will be happy.

612
00:37:01,690 --> 00:37:04,700
And yeah, you can see it's 25 hexa,

613
00:37:04,700 --> 00:37:06,640
just like the data sheet says.

614
00:37:06,640 --> 00:37:10,549
So this constant is
actually equals to 25 hexa.

615
00:37:12,150 --> 00:37:13,333
This is how it works.

616
00:37:15,720 --> 00:37:19,259
So that's all about the GPI (indistinct).

617
00:37:19,260 --> 00:37:23,880
Now actually there is,

618
00:37:23,880 --> 00:37:26,600
the next thing we will talk about also

619
00:37:26,600 --> 00:37:30,230
Has something to do with GPLs.

620
00:37:30,230 --> 00:37:32,160
We are going to talk about interrupts.

621
00:37:32,160 --> 00:37:37,007
And interrupts, are basically
the way of the processor,

622
00:37:37,007 --> 00:37:38,830
the microcontroller,

623
00:37:38,830 --> 00:37:41,660
to let us know that
something has happened.

624
00:37:41,660 --> 00:37:46,660
And we can see the list of
all the supported interrupts.

625
00:37:47,730 --> 00:37:51,410
Somewhere, actually don't
remember where it is.

626
00:37:51,410 --> 00:37:54,299
I usually just search for vectors.

627
00:37:54,300 --> 00:37:58,410
Let's see if I can spot it
real quick or interrupts.

628
00:37:58,410 --> 00:38:01,069
Yup, very useful.

629
00:38:01,070 --> 00:38:02,900
So yeah, that's our chip.

630
00:38:02,900 --> 00:38:05,770
And we can see, like, these
are like all the interrupts

631
00:38:05,770 --> 00:38:08,300
that this chip can generate.

632
00:38:08,300 --> 00:38:13,300
And right now we are not
going to talk about how to

633
00:38:13,600 --> 00:38:18,029
handle interrupt in non
Arduino environment or in...

634
00:38:18,030 --> 00:38:20,923
When we get to assembly,
we'll probably mention that.

635
00:38:23,090 --> 00:38:27,420
And instead I'm going to show you two ways

636
00:38:27,420 --> 00:38:29,310
to do these within Arduino.

637
00:38:29,310 --> 00:38:33,430
So let's go back to the
switches and inside UNO,

638
00:38:33,430 --> 00:38:38,430
there are actually two
external PIND interrupts.

639
00:38:39,360 --> 00:38:42,837
So the two interrupts
that can be dispatched

640
00:38:45,200 --> 00:38:48,493
whenever a specific being is changed.

641
00:38:50,079 --> 00:38:51,820
In zero and in one,

642
00:38:51,820 --> 00:38:55,180
and if we go back to the PIND descriptions

643
00:38:55,180 --> 00:38:59,660
we can see which PINDS they
are of PIND configuration.

644
00:38:59,660 --> 00:39:02,920
We can see the PINDS they belong to.

645
00:39:02,920 --> 00:39:04,723
So you can see that....

646
00:39:07,440 --> 00:39:10,280
In zero is for PD two.

647
00:39:10,280 --> 00:39:12,610
So that's PIND two of the Arduino,

648
00:39:12,610 --> 00:39:16,310
and in one is for PB three.

649
00:39:16,310 --> 00:39:18,423
And in order to listen to them,

650
00:39:19,260 --> 00:39:22,163
we can just do something like that.

651
00:39:22,163 --> 00:39:24,950
It's just a set up.

652
00:39:24,950 --> 00:39:27,549
Serial printing anyway,

653
00:39:27,550 --> 00:39:29,450
we are not going to use
zero and one anyways.

654
00:39:29,450 --> 00:39:31,029
So it doesn't matter right now.

655
00:39:31,030 --> 00:39:35,730
And I'm going to use the
touch interrupt method,

656
00:39:35,730 --> 00:39:38,513
and call PIND.

657
00:39:39,378 --> 00:39:41,473
I don't remember the
name of that function.

658
00:39:43,500 --> 00:39:44,933
We can actually write....

659
00:39:46,610 --> 00:39:50,070
Yeah, think it was digital

660
00:39:51,510 --> 00:39:53,803
PIND two interrupt number.

661
00:39:54,940 --> 00:39:56,653
Just Google that very quick.

662
00:39:59,130 --> 00:40:00,640
Did show up in to interrupt.

663
00:40:00,640 --> 00:40:04,359
Okay, so that would attach to in zero

664
00:40:04,360 --> 00:40:07,330
because this belongs to this PIND

665
00:40:07,330 --> 00:40:12,210
and then we need to give it
an address of a function.

666
00:40:12,210 --> 00:40:15,553
Let's call it, interrupt, interrupted.

667
00:40:16,700 --> 00:40:19,299
And then interrupted.

668
00:40:19,300 --> 00:40:22,270
And then we need to tell it
when to call the interrupt.

669
00:40:22,270 --> 00:40:24,360
So for instance, on the rising edge.

670
00:40:24,360 --> 00:40:28,420
So whenever these PIND
goes from low to high.

671
00:40:28,420 --> 00:40:31,453
And in interrupted we can just print,

672
00:40:33,047 --> 00:40:34,927
"I was interrupted."

673
00:40:35,850 --> 00:40:39,759
It's (indistinct) and we can see that

674
00:40:39,760 --> 00:40:44,760
as soon as I click the
switch that is connected to

675
00:40:44,914 --> 00:40:47,710
PIND number two, it was interrupted.

676
00:40:47,710 --> 00:40:51,080
Now, if I switched off it
doesn't really matter because

677
00:40:52,100 --> 00:40:55,259
we asked to be notified
on the rising edge,

678
00:40:55,260 --> 00:40:59,700
and that's the falling edge,
but then whenever it goes on,

679
00:40:59,700 --> 00:41:02,120
or in this case, whenever
the circuit is open

680
00:41:02,120 --> 00:41:05,313
and the PIND goes high,
we get the interrupt.

681
00:41:06,260 --> 00:41:09,420
And that was like the Arduino-ish way

682
00:41:09,420 --> 00:41:12,930
to define this interrupt handler.

683
00:41:12,930 --> 00:41:17,529
And now I'm going to show you
how to do it via registers.

684
00:41:17,530 --> 00:41:21,633
How to enable this interrupt
and act upon this interrupt.

685
00:41:22,610 --> 00:41:26,200
So if we go back to these section,

686
00:41:26,200 --> 00:41:30,790
there is like external, a
section about external interrupt.

687
00:41:30,790 --> 00:41:35,470
So in zero in one, those are
interrupts that are associated

688
00:41:35,470 --> 00:41:40,209
with these PINDS are external interrupts.

689
00:41:40,210 --> 00:41:43,360
And if you wanted to enable them,

690
00:41:43,360 --> 00:41:47,200
we would need to check out the
external interrupt section.

691
00:41:47,200 --> 00:41:51,279
And there are two kinds
of external interrupts.

692
00:41:51,280 --> 00:41:54,310
In this case, we are interested

693
00:41:54,310 --> 00:41:58,350
in the kind of controls
in zero and in one.

694
00:41:58,350 --> 00:42:03,350
And we can see that there
are like two registers

695
00:42:04,610 --> 00:42:08,050
that control the external interrupts.

696
00:42:08,050 --> 00:42:10,013
There is control register A,

697
00:42:10,990 --> 00:42:14,970
and there is interrupt
(indistinct) register.

698
00:42:14,970 --> 00:42:19,883
So we can say that, we
can see that EIM escape,

699
00:42:20,804 --> 00:42:24,210
let us enable interact requests zero

700
00:42:24,210 --> 00:42:27,300
and interrupt requests
one or in zero in one.

701
00:42:27,300 --> 00:42:29,117
So if we want to enable this interrupt,

702
00:42:29,117 --> 00:42:32,700
we want this interrupt to happen.

703
00:42:32,700 --> 00:42:36,410
We need to set this bit to one.

704
00:42:36,410 --> 00:42:37,410
So let's do that.

705
00:42:37,410 --> 00:42:41,089
Let's go ahead and set it up.

706
00:42:41,090 --> 00:42:43,280
That was the (indistinct) switches,

707
00:42:43,280 --> 00:42:45,630
so instead of doing it the Arduino way,

708
00:42:45,630 --> 00:42:47,773
let's say bit set,

709
00:42:48,950 --> 00:42:53,950
and we can either write a
zero here, like the index,

710
00:42:53,970 --> 00:42:57,799
or we can just, you know,
use this constant in zero.

711
00:42:57,800 --> 00:43:01,943
So that would enable the
interrupt, but only enable it,

712
00:43:03,320 --> 00:43:05,940
I mean, we also had this
rising bar Metairie.

713
00:43:05,940 --> 00:43:07,670
So how do we set that?

714
00:43:07,670 --> 00:43:10,630
And for that, we would need
to look at a second register.

715
00:43:10,630 --> 00:43:15,630
The EICRA, external
interrupt control register.

716
00:43:16,680 --> 00:43:18,669
And we can set it

717
00:43:18,670 --> 00:43:23,480
to decide when this interrupt fires.

718
00:43:23,480 --> 00:43:26,200
So, we basically,

719
00:43:26,200 --> 00:43:28,149
actually, we can just do
it with the assignment,

720
00:43:28,150 --> 00:43:30,430
because I think we'll need multiple bits.

721
00:43:30,430 --> 00:43:35,430
We want it to go on
the, so that's in zero.

722
00:43:35,840 --> 00:43:40,840
We wanted to go on the
rising gauge of in zero.

723
00:43:40,850 --> 00:43:43,940
So we need to set those two bits to one.

724
00:43:43,940 --> 00:43:47,280
Highest is zero, zero,
and highest zero one.

725
00:43:47,280 --> 00:43:51,350
And again, we could just
like use their indices,

726
00:43:51,350 --> 00:43:53,770
zero and one, but in this case,

727
00:43:53,770 --> 00:43:55,930
I think it's better to use the constant.

728
00:43:55,930 --> 00:44:00,930
So it's easy to figure out
what these bits actually mean.

729
00:44:04,090 --> 00:44:06,520
And now we are almost done.

730
00:44:06,520 --> 00:44:09,080
We configure the external interrupts.

731
00:44:09,080 --> 00:44:12,440
The only thing we need to do
is to declare the function

732
00:44:12,440 --> 00:44:15,230
that handles that these interrupts.

733
00:44:15,230 --> 00:44:17,170
And for that we would need to use

734
00:44:19,140 --> 00:44:22,920
something called a macro
that will define and ISR,

735
00:44:22,920 --> 00:44:25,240
an interrupt service routine.

736
00:44:25,240 --> 00:44:28,223
And there is some convention I think,

737
00:44:31,650 --> 00:44:34,453
it's the name of the
interrupt underscore vect.

738
00:44:35,340 --> 00:44:37,350
And that would tell the compiler,

739
00:44:37,350 --> 00:44:39,450
to put the address of this function

740
00:44:39,450 --> 00:44:40,720
that we defined here

741
00:44:41,610 --> 00:44:46,610
inside like the memory address
specified in this table.

742
00:44:47,460 --> 00:44:51,830
So it will just put it here
inside address number two,

743
00:44:51,830 --> 00:44:56,103
where in zero handler lifts.

744
00:44:57,990 --> 00:45:02,990
Okay, let's restart a simulation
and see if it is worth,

745
00:45:03,390 --> 00:45:04,843
if it registers.

746
00:45:07,030 --> 00:45:10,910
Okay, and then as soon
as they toggle this PIND,

747
00:45:10,910 --> 00:45:14,270
we can see that it's
basically the equivalent.

748
00:45:14,270 --> 00:45:19,070
And if we just, you know,
let's do this finally

749
00:45:19,070 --> 00:45:20,700
let's go to the Arduino library

750
00:45:20,700 --> 00:45:23,730
and look at the source
code for attach interrupt.

751
00:45:23,730 --> 00:45:26,190
If we check out the source
code for attach interrupt,

752
00:45:26,190 --> 00:45:27,533
we can find it here.

753
00:45:28,760 --> 00:45:33,760
And there is basically
a very big switch case,

754
00:45:34,420 --> 00:45:37,570
that depends on the PIND number

755
00:45:37,570 --> 00:45:40,810
and which processor we are running on.

756
00:45:40,810 --> 00:45:44,000
But you can see that it sets basically

757
00:45:44,000 --> 00:45:46,400
those two registers, like

758
00:45:46,400 --> 00:45:50,993
like we did like E I C R A N E I M escape.

759
00:45:51,970 --> 00:45:55,709
On some other processor,
like the registered names

760
00:45:55,710 --> 00:45:57,760
are quite a bit different

761
00:45:57,760 --> 00:46:00,930
but basically it does the
same things like we do,

762
00:46:00,930 --> 00:46:05,292
just sending up those two
registers to enable the interrupt.

763
00:46:07,080 --> 00:46:10,680
So that's it, the Arduino
library is just like

764
00:46:10,680 --> 00:46:12,950
most of the time, it's just like

765
00:46:12,950 --> 00:46:15,950
reading and writing the
right registers for us,

766
00:46:15,950 --> 00:46:17,073
like we did here.

767
00:46:19,140 --> 00:46:21,600
Before we move on,

768
00:46:21,600 --> 00:46:25,942
I want to introduce you
to two more functions.

769
00:46:26,910 --> 00:46:28,640
So um..

770
00:46:28,640 --> 00:46:31,890
Let's say we don't want interrupts,

771
00:46:31,890 --> 00:46:33,170
any kind of interrupts.

772
00:46:33,170 --> 00:46:35,080
There is a function called CLI,

773
00:46:35,080 --> 00:46:38,380
that will simply clear interrupts.

774
00:46:38,380 --> 00:46:40,877
Oh, Andreas is asking,

775
00:46:40,877 --> 00:46:42,900
"Don't we need to enable
global interrupt."

776
00:46:42,900 --> 00:46:46,740
So when Arduino starts,

777
00:46:46,740 --> 00:46:49,939
it already sets up interrupts for us.

778
00:46:49,940 --> 00:46:54,940
So it enables the interrupts
and CLI does the opposite.

779
00:46:55,490 --> 00:46:57,712
We are going to disable the interrupts.

780
00:46:58,750 --> 00:47:00,680
So if I call this in my setup,

781
00:47:00,680 --> 00:47:04,240
and I run the code, we
will notice a few things.

782
00:47:04,240 --> 00:47:09,240
First of all, the interrupt
doesn't get fired anymore.

783
00:47:09,720 --> 00:47:11,669
We don't see the prints.

784
00:47:11,670 --> 00:47:15,350
And second, the LCD stops updating.

785
00:47:15,350 --> 00:47:20,350
So probably the LCD somehow
also depends on interrupts.

786
00:47:20,790 --> 00:47:22,320
And that would be fixed,

787
00:47:22,320 --> 00:47:25,460
if I re enabled interrupts at some point.

788
00:47:25,460 --> 00:47:28,610
So now I clear them, set some flags,

789
00:47:28,610 --> 00:47:30,480
and then when we enable them,

790
00:47:30,480 --> 00:47:32,920
and we can see that the interrupt,

791
00:47:32,920 --> 00:47:35,620
everything is working as normal.

792
00:47:35,620 --> 00:47:38,160
Now, disabling interrupts,

793
00:47:38,160 --> 00:47:41,200
is usually something that
you don't want to do,

794
00:47:41,200 --> 00:47:44,580
unless you need a precise timing,

795
00:47:44,580 --> 00:47:47,009
or you want to write to a few registers

796
00:47:47,010 --> 00:47:50,180
and make sure that nothing
happens in the mail.

797
00:47:50,180 --> 00:47:53,379
Like in this case, if I
enable this interrupt,

798
00:47:53,380 --> 00:47:56,310
but I don't set the condition

799
00:47:56,310 --> 00:48:01,310
it could like, a fire before
I have this assignment done

800
00:48:01,810 --> 00:48:04,710
because the previous condition was met.

801
00:48:04,710 --> 00:48:08,150
So it makes sense to first of all,

802
00:48:08,150 --> 00:48:11,493
disable interrupts and then set this up.

803
00:48:13,000 --> 00:48:16,250
And I want to show you something,

804
00:48:16,250 --> 00:48:20,350
another thing, what happens
when I disable interrupt.

805
00:48:20,350 --> 00:48:25,113
So let's dump this down
to a very simple program.

806
00:48:27,020 --> 00:48:31,410
Serial begin, serial print land.

807
00:48:31,410 --> 00:48:34,009
Hello, so, hello.

808
00:48:34,010 --> 00:48:35,393
Hi, how good are you?

809
00:48:36,620 --> 00:48:39,109
So these (indistinct) prints,
"Hello, how good are you?"

810
00:48:39,110 --> 00:48:42,560
And we are all happy, but
if I disable interrupts

811
00:48:42,560 --> 00:48:45,256
even after recording this (indistinct).

812
00:48:45,256 --> 00:48:47,480
We'll see that it's just sprinted head.

813
00:48:47,480 --> 00:48:49,550
And the reason for that,

814
00:48:49,550 --> 00:48:53,380
the serial library depends on interrupts

815
00:48:53,380 --> 00:48:55,440
to know when to send the next character.

816
00:48:55,440 --> 00:48:57,523
So if we disabled the interrupts,

817
00:48:58,520 --> 00:49:00,450
we basically killed the serial.

818
00:49:00,450 --> 00:49:05,450
Not only that, let's see,
let's try something else.

819
00:49:06,670 --> 00:49:11,670
Hello, and then print the
other one after one second.

820
00:49:11,930 --> 00:49:14,690
So we have, "Hello, how good are you?"

821
00:49:14,690 --> 00:49:16,520
After one second.

822
00:49:16,520 --> 00:49:19,350
And we can see it prints "Hello."

823
00:49:19,350 --> 00:49:22,343
Let's restart it.(indistinct)

824
00:49:24,980 --> 00:49:29,790
So it prints, there is some
issue with the simulation.

825
00:49:29,790 --> 00:49:31,870
It doesn't clear the
output when it begins.

826
00:49:31,870 --> 00:49:32,703
Let's restart it.

827
00:49:32,703 --> 00:49:35,500
"Hello," and say one second
after, "how good are you?"

828
00:49:35,500 --> 00:49:37,820
And we can even change it to five seconds

829
00:49:37,820 --> 00:49:39,550
to make this more apparent, "hello."

830
00:49:39,550 --> 00:49:42,227
And then after a short
while, it will print,

831
00:49:42,227 --> 00:49:43,417
"how good are you?"

832
00:49:44,490 --> 00:49:49,319
But then see what happens
if I disable interrupts

833
00:49:49,320 --> 00:49:51,070
while I'm calling delay.

834
00:49:51,070 --> 00:49:54,230
So I'm disabling it, calling
delay, and enabling it again.

835
00:49:54,230 --> 00:49:56,640
So I can see the output of the prints

836
00:49:56,640 --> 00:49:58,560
And see what happens.

837
00:49:58,560 --> 00:49:59,750
It didn't delay.

838
00:49:59,750 --> 00:50:02,180
So delay also depends on interrupts.

839
00:50:02,180 --> 00:50:05,160
And if at some point
you disabled interrupts,

840
00:50:05,160 --> 00:50:06,690
and then call delay,

841
00:50:06,690 --> 00:50:09,560
then delay is not going to delay at all.

842
00:50:09,560 --> 00:50:13,360
So that's one important thing to know.

843
00:50:13,360 --> 00:50:17,090
Disabling the interrupts for
more than a few commands,

844
00:50:17,090 --> 00:50:21,530
will probably get you very
unpredictable results.

845
00:50:21,530 --> 00:50:24,790
Delay is not working, serial
blueprint does not print.

846
00:50:24,790 --> 00:50:28,610
So you want to use this CLI tool,

847
00:50:28,610 --> 00:50:31,233
clear interrupts command sparingly.

848
00:50:33,092 --> 00:50:34,943
You don't want to use it too much.

849
00:50:37,700 --> 00:50:41,689
So that's all about
interrupts and Christina,

850
00:50:41,690 --> 00:50:44,420
I would appreciate if
you write in the chat,

851
00:50:44,420 --> 00:50:46,193
how much time we have left,

852
00:50:47,590 --> 00:50:49,407
because I want to.....

853
00:50:54,983 --> 00:50:58,430
Okay, I will answer that question,

854
00:50:58,430 --> 00:51:02,283
that we have from (indistinct)
later in the Q and A session.

855
00:51:04,780 --> 00:51:07,310
Okay, so we have about five minutes left,

856
00:51:07,310 --> 00:51:12,310
and that would be a good time
to briefly talk about timers.

857
00:51:12,870 --> 00:51:14,690
So in AVR,

858
00:51:14,690 --> 00:51:19,690
timers, they basically let us
interact with or count timers,

859
00:51:21,320 --> 00:51:22,980
time the time.

860
00:51:22,980 --> 00:51:27,670
And we can see that we
have, where's the timer?

861
00:51:27,670 --> 00:51:32,640
We have like three timers,
timer zero timer one

862
00:51:32,640 --> 00:51:34,680
and timer two.

863
00:51:34,680 --> 00:51:37,529
Now, before we get into,

864
00:51:37,530 --> 00:51:40,480
and we won't like, finish this today,

865
00:51:40,480 --> 00:51:43,090
we'll continue talking
about timers next time

866
00:51:43,090 --> 00:51:45,640
because they are really complex.

867
00:51:45,640 --> 00:51:49,330
In fact, they are the
most complex peripheral

868
00:51:49,330 --> 00:51:51,442
that exists on the AVR.

869
00:51:51,442 --> 00:51:53,592
They are more complex
that anything in AVR.

870
00:51:55,670 --> 00:52:00,160
And basically you can figure it out

871
00:52:00,160 --> 00:52:02,049
only by looking at,

872
00:52:02,050 --> 00:52:03,990
so this is time or number one,

873
00:52:03,990 --> 00:52:06,979
and if we take a look at
the registered description,

874
00:52:06,980 --> 00:52:11,980
we can see like it has 16, 11 one,

875
00:52:12,687 --> 00:52:17,230
and it goes down all the way to huh?

876
00:52:17,230 --> 00:52:21,010
Yeah, you can see how many
different registers it had.

877
00:52:21,010 --> 00:52:24,520
It had like nine different registers.

878
00:52:24,520 --> 00:52:29,440
And it has like so many
different modes of operation

879
00:52:29,440 --> 00:52:30,763
and whatnot.

880
00:52:31,980 --> 00:52:36,270
So if we wanted to cover timers,

881
00:52:36,270 --> 00:52:39,840
we would have to dedicate
like, cover them end to end,

882
00:52:39,840 --> 00:52:42,950
we would probably have
to dedicate five sessions

883
00:52:42,950 --> 00:52:44,580
just for that.

884
00:52:44,580 --> 00:52:47,660
So we are not going to
do that in this course,

885
00:52:47,660 --> 00:52:50,009
but I'm going to give you a little taste.

886
00:52:50,010 --> 00:52:53,430
And what I'm going to do.

887
00:52:53,430 --> 00:52:57,710
I'm going to set up a simple program,

888
00:52:57,710 --> 00:53:00,840
that will sort of

889
00:53:04,060 --> 00:53:06,360
simulate this blink.

890
00:53:06,360 --> 00:53:09,230
Let's open blink again, we have it here.

891
00:53:09,230 --> 00:53:11,020
Simulate blink using timers.

892
00:53:11,020 --> 00:53:16,020
So I won't go into all the
details because you can find them

893
00:53:16,100 --> 00:53:19,830
in the data sheet, but what I will do,

894
00:53:19,830 --> 00:53:23,240
I will, so we have this delay here,

895
00:53:23,240 --> 00:53:26,740
and I'm going to replace this delay or,

896
00:53:26,740 --> 00:53:28,779
you know what the entire loop with

897
00:53:29,860 --> 00:53:32,530
timer that will do this for me.

898
00:53:32,530 --> 00:53:36,660
So basically we are going
to use this TCCR one,

899
00:53:36,660 --> 00:53:39,500
and we are going to configure the timer,

900
00:53:39,500 --> 00:53:44,050
so that it counts one.

901
00:53:44,050 --> 00:53:47,480
It goes up by one every...

902
00:53:49,480 --> 00:53:51,080
Where is that?(indistinct)

903
00:53:51,080 --> 00:53:54,160
Every two 56 clock cycles.

904
00:53:54,160 --> 00:53:58,692
So a clock cycle is basically, you know,

905
00:53:58,692 --> 00:54:01,130
(indistinct) 16 megahertz.

906
00:54:01,130 --> 00:54:06,130
So a clock cycle is one divided
by 16 million of a second.

907
00:54:08,870 --> 00:54:13,870
There are 16 million
clock cycles in a second.

908
00:54:15,030 --> 00:54:20,030
So every 256 clock cycles,
the timer will go up by one.

909
00:54:20,590 --> 00:54:24,610
So we can say the control register A,

910
00:54:24,610 --> 00:54:26,180
will just set it to zero,

911
00:54:26,180 --> 00:54:29,120
because we are not
interested in any of the

912
00:54:30,380 --> 00:54:31,720
configuration options there.

913
00:54:31,720 --> 00:54:34,029
And you can check them up later.

914
00:54:34,030 --> 00:54:37,020
But for the second control
register of the timer,

915
00:54:37,020 --> 00:54:40,093
we actually want to set it to this value.

916
00:54:40,093 --> 00:54:44,752
So to set it to count every 256 cycles.

917
00:54:46,150 --> 00:54:48,450
So we want to enable the speed,

918
00:54:48,450 --> 00:54:52,129
count every 256 cycles.

919
00:54:52,130 --> 00:54:55,980
And now we want to define a
function that will be called

920
00:54:55,980 --> 00:54:57,980
whenever these timer overflows.

921
00:54:57,980 --> 00:55:01,170
So this timer counts 16 bits.

922
00:55:01,170 --> 00:55:06,170
So from zero to 65, five, three, five,

923
00:55:06,790 --> 00:55:09,310
and we want whenever it overflows,

924
00:55:09,310 --> 00:55:13,040
whenever it gets to the top,
we want to call a function,

925
00:55:13,040 --> 00:55:15,279
to declare an interrupt
that will be called.

926
00:55:15,280 --> 00:55:19,780
So we define an interrupt
that is called timer one,

927
00:55:19,780 --> 00:55:24,360
because this is timer one, overflow vect.

928
00:55:24,360 --> 00:55:26,680
And whenever this happens, just, you know,

929
00:55:26,680 --> 00:55:28,507
toggle the bit, the PIND.

930
00:55:29,800 --> 00:55:33,010
And if you will multiply
this number by that number,

931
00:55:33,010 --> 00:55:36,880
you will see it's roughly
equals 16 million.

932
00:55:36,880 --> 00:55:39,380
And that's the number
of cycles in a second.

933
00:55:39,380 --> 00:55:43,640
So we basically, whenever it overflows,

934
00:55:43,640 --> 00:55:46,830
we know that one second
best, more or less.

935
00:55:46,830 --> 00:55:51,140
And before, if we run it, it
won't do anything right now,

936
00:55:51,140 --> 00:55:54,770
because we can remove this serial prints,

937
00:55:54,770 --> 00:55:57,009
It won't do anything
interesting right now,

938
00:55:57,010 --> 00:56:00,290
because we have set up
the counter to count,

939
00:56:00,290 --> 00:56:03,690
but we haven't set up the interrupt.

940
00:56:03,690 --> 00:56:05,360
And to enable that,

941
00:56:05,360 --> 00:56:10,360
we just need to enable the interrupt bit

942
00:56:10,510 --> 00:56:13,020
similar to what we did with the GPO PINDS.

943
00:56:16,720 --> 00:56:20,169
This register controls the
interrupt for the timer,

944
00:56:20,170 --> 00:56:25,170
and I E timer overflow interrupt enable,

945
00:56:25,770 --> 00:56:27,670
we enable this overflow interrupt.

946
00:56:27,670 --> 00:56:28,900
Let's run it.

947
00:56:28,900 --> 00:56:32,460
And we can see the LED is blinking,

948
00:56:32,460 --> 00:56:34,430
roughly once a second.

949
00:56:34,430 --> 00:56:38,560
So this was like a real
quick introduction,

950
00:56:38,560 --> 00:56:42,083
to using the timer to count clock cycles.

951
00:56:43,950 --> 00:56:46,040
And I think now is a good time

952
00:56:46,040 --> 00:56:49,263
to move on to the Q and A session.

953
00:56:49,263 --> 00:56:51,200
And for the timers,

954
00:56:51,200 --> 00:56:54,299
we still have some more
things to learn about them.

955
00:56:54,300 --> 00:56:57,120
So, I hope you will
join for the next class,

956
00:56:57,120 --> 00:57:00,580
where we will dive into the timers.

957
00:57:00,580 --> 00:57:05,390
And then after going
more deeply into timers,

958
00:57:05,390 --> 00:57:08,020
we'll start talking about
the assembly leg in which,

959
00:57:08,020 --> 00:57:08,977
of the AVR.

