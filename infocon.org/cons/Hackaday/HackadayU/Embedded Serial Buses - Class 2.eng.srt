1
00:00:00,000 --> 00:00:08,240
[Music]

2
00:00:08,240 --> 00:00:10,719
hi there welcome to week two of hackaday

3
00:00:10,719 --> 00:00:12,240
u serial buses with

4
00:00:12,240 --> 00:00:14,960
me alexander rousell my email is there

5
00:00:14,960 --> 00:00:16,160
on screen again

6
00:00:16,160 --> 00:00:18,960
a congratulations to david choi who won

7
00:00:18,960 --> 00:00:19,359
the

8
00:00:19,359 --> 00:00:21,600
10 tindy gift certificate by finding

9
00:00:21,600 --> 00:00:23,519
last week's easter egg

10
00:00:23,519 --> 00:00:25,760
he found it very quickly after the video

11
00:00:25,760 --> 00:00:27,199
went up so good

12
00:00:27,199 --> 00:00:29,920
uh good on him the easter egg was the

13
00:00:29,920 --> 00:00:31,840
eeprom data that i was reading from that

14
00:00:31,840 --> 00:00:33,760
eprom actually spelled out

15
00:00:33,760 --> 00:00:35,680
hackaday u exclamation mark so

16
00:00:35,680 --> 00:00:37,360
congratulations to him

17
00:00:37,360 --> 00:00:39,600
and uh enjoy your 10 attendee gift

18
00:00:39,600 --> 00:00:41,120
certificate hopefully you can find

19
00:00:41,120 --> 00:00:42,320
something really cool

20
00:00:42,320 --> 00:00:44,960
to buy so now we're going to be diving

21
00:00:44,960 --> 00:00:45,680
into

22
00:00:45,680 --> 00:00:49,280
the msp 430 f-5529

23
00:00:49,280 --> 00:00:52,559
the i squared c plus implementation

24
00:00:52,559 --> 00:00:54,160
the steps are going to be specific to

25
00:00:54,160 --> 00:00:56,079
this chip but i'm going to generalize it

26
00:00:56,079 --> 00:00:58,640
as much as possible for all chips

27
00:00:58,640 --> 00:01:02,000
so a quick recap of last week we looked

28
00:01:02,000 --> 00:01:02,320
at

29
00:01:02,320 --> 00:01:03,920
i squared c from the hardware and

30
00:01:03,920 --> 00:01:05,600
protocol level

31
00:01:05,600 --> 00:01:07,040
this week we're going to be looking at i

32
00:01:07,040 --> 00:01:09,119
squared c implementation in software and

33
00:01:09,119 --> 00:01:10,840
how that works with hardware and

34
00:01:10,840 --> 00:01:12,240
protocol

35
00:01:12,240 --> 00:01:14,159
last week's lesson is fairly vital to

36
00:01:14,159 --> 00:01:15,840
understanding the content in this week's

37
00:01:15,840 --> 00:01:17,600
lesson so if you haven't seen last week

38
00:01:17,600 --> 00:01:20,080
so you might want to go watch that first

39
00:01:20,080 --> 00:01:22,159
if you already know how i squared c

40
00:01:22,159 --> 00:01:23,360
works and you just want to see some

41
00:01:23,360 --> 00:01:25,200
hardware examples software examples of

42
00:01:25,200 --> 00:01:26,720
hardware implementation

43
00:01:26,720 --> 00:01:28,720
uh you can just watch this lesson on its

44
00:01:28,720 --> 00:01:30,880
own uh if you haven't watched

45
00:01:30,880 --> 00:01:32,400
week one good idea to watch that one

46
00:01:32,400 --> 00:01:34,720
first so most data sheets still use

47
00:01:34,720 --> 00:01:36,079
problematic language we talked about

48
00:01:36,079 --> 00:01:37,040
this last week

49
00:01:37,040 --> 00:01:38,479
we're going to be avoiding those usages

50
00:01:38,479 --> 00:01:40,240
wherever possible and we're going to be

51
00:01:40,240 --> 00:01:41,759
continuing to use controller and

52
00:01:41,759 --> 00:01:43,520
peripheral as we have done so far in

53
00:01:43,520 --> 00:01:45,200
this course

54
00:01:45,200 --> 00:01:48,240
so software level there are two main

55
00:01:48,240 --> 00:01:49,840
approaches to implementing an i squared

56
00:01:49,840 --> 00:01:51,200
c controller

57
00:01:51,200 --> 00:01:53,840
using a hardware peripheral if available

58
00:01:53,840 --> 00:01:54,560
most

59
00:01:54,560 --> 00:01:56,560
modern microcontrollers have these or

60
00:01:56,560 --> 00:01:58,960
you can implement it using gpio commands

61
00:01:58,960 --> 00:01:59,439
which is

62
00:01:59,439 --> 00:02:01,759
also known as bit banging there's

63
00:02:01,759 --> 00:02:03,759
advantages and disadvantages to

64
00:02:03,759 --> 00:02:05,759
either approach hardware peripherals

65
00:02:05,759 --> 00:02:07,680
take care of all the bus timing clock

66
00:02:07,680 --> 00:02:10,000
generation acknowledge not acknowledge

67
00:02:10,000 --> 00:02:12,640
start and stop we can focus for the most

68
00:02:12,640 --> 00:02:14,640
part on just sending and receiving data

69
00:02:14,640 --> 00:02:15,760
we have to monitor

70
00:02:15,760 --> 00:02:18,800
interrupt flags and monitor status

71
00:02:18,800 --> 00:02:20,720
registers and set things up but for the

72
00:02:20,720 --> 00:02:22,319
most part it takes care of the nitty

73
00:02:22,319 --> 00:02:24,319
gritty for us

74
00:02:24,319 --> 00:02:26,319
software implementations were bit

75
00:02:26,319 --> 00:02:27,680
banging for example

76
00:02:27,680 --> 00:02:30,239
they allow us total control but at the

77
00:02:30,239 --> 00:02:33,200
cost of processor usage

78
00:02:33,200 --> 00:02:35,680
often you're going to be implementing

79
00:02:35,680 --> 00:02:36,400
delays

80
00:02:36,400 --> 00:02:39,519
between each successive bit or

81
00:02:39,519 --> 00:02:42,959
byte and using literal just

82
00:02:42,959 --> 00:02:45,680
loops in assembly code so knobs looped

83
00:02:45,680 --> 00:02:47,360
over and over so your processor usage is

84
00:02:47,360 --> 00:02:49,440
going to be very high

85
00:02:49,440 --> 00:02:51,200
which means it's going to limit you to

86
00:02:51,200 --> 00:02:53,760
just doing one thing at a time

87
00:02:53,760 --> 00:02:55,599
this can sometimes be necessary to

88
00:02:55,599 --> 00:02:56,959
circumvent bugs in the hardware

89
00:02:56,959 --> 00:02:58,000
controller

90
00:02:58,000 --> 00:02:59,840
or if we don't even have a hardware

91
00:02:59,840 --> 00:03:01,360
controller on the microcontroller we're

92
00:03:01,360 --> 00:03:03,200
using older microcontrollers often

93
00:03:03,200 --> 00:03:05,120
didn't have i squared c peripherals

94
00:03:05,120 --> 00:03:06,000
built in

95
00:03:06,000 --> 00:03:07,280
so you would have to write it in

96
00:03:07,280 --> 00:03:11,440
software doing bit banging with the gpio

97
00:03:11,440 --> 00:03:13,040
or there may not be enough i square c

98
00:03:13,040 --> 00:03:15,280
buses on the microcontroller we can add

99
00:03:15,280 --> 00:03:19,760
additional i squared c buses in software

100
00:03:19,760 --> 00:03:21,280
so all the examples are going to be

101
00:03:21,280 --> 00:03:22,959
written in c plus plus

102
00:03:22,959 --> 00:03:26,000
but my c plus plus looks a lot like c

103
00:03:26,000 --> 00:03:29,120
because i learned c and u c for a long

104
00:03:29,120 --> 00:03:30,000
time and have

105
00:03:30,000 --> 00:03:32,239
been recently migrating to using c plus

106
00:03:32,239 --> 00:03:34,159
and embedded

107
00:03:34,159 --> 00:03:35,840
if you've worked with arduino it'll look

108
00:03:35,840 --> 00:03:37,280
very familiar

109
00:03:37,280 --> 00:03:39,599
so a list of microcontrollers that have

110
00:03:39,599 --> 00:03:41,040
i squared c hardware

111
00:03:41,040 --> 00:03:43,840
most microcontroller families do have it

112
00:03:43,840 --> 00:03:47,280
msp430 and 432 almost all of them do

113
00:03:47,280 --> 00:03:49,360
most picks do except for the smallest

114
00:03:49,360 --> 00:03:51,040
picks like the pick 10.

115
00:03:51,040 --> 00:03:54,239
the stm8 and 32 almost all of them do

116
00:03:54,239 --> 00:03:56,560
almost all the atmega and 80 tinies do

117
00:03:56,560 --> 00:03:59,519
except for the very smallest ones

118
00:03:59,519 --> 00:04:01,280
and any microcontroller that's based on

119
00:04:01,280 --> 00:04:03,040
an arm cortex m

120
00:04:03,040 --> 00:04:05,200
no matter what size it is zero zero plus

121
00:04:05,200 --> 00:04:06,480
three four seven

122
00:04:06,480 --> 00:04:08,319
uh it's going to almost certainly have

123
00:04:08,319 --> 00:04:09,840
an i squared c uh

124
00:04:09,840 --> 00:04:13,040
bus at least one 805 one based

125
00:04:13,040 --> 00:04:14,720
microcontroller microcontrollers usually

126
00:04:14,720 --> 00:04:16,798
don't have i squared c peripherals they

127
00:04:16,798 --> 00:04:19,918
usually have just very basic peripherals

128
00:04:19,918 --> 00:04:22,320
some microcontrollers like the tiva c

129
00:04:22,320 --> 00:04:23,199
series from

130
00:04:23,199 --> 00:04:26,560
texas instruments can have like 11 12

131
00:04:26,560 --> 00:04:29,440
hardware i squared c buses on the chip

132
00:04:29,440 --> 00:04:30,080
which is just

133
00:04:30,080 --> 00:04:32,560
insane it's very important to check the

134
00:04:32,560 --> 00:04:34,000
data sheet for the microcontroller you

135
00:04:34,000 --> 00:04:35,840
want to use here the tvs c series can

136
00:04:35,840 --> 00:04:36,240
have

137
00:04:36,240 --> 00:04:39,360
many buses per chip so the most

138
00:04:39,360 --> 00:04:41,360
important thing to do

139
00:04:41,360 --> 00:04:42,720
when you're implementing anything but

140
00:04:42,720 --> 00:04:44,800
especially i scored c or any serial bus

141
00:04:44,800 --> 00:04:45,680
is to gather

142
00:04:45,680 --> 00:04:48,800
information you need to be able to

143
00:04:48,800 --> 00:04:50,960
quickly find data that is relevant to

144
00:04:50,960 --> 00:04:52,800
your application

145
00:04:52,800 --> 00:04:54,479
many microcontroller data sheets and

146
00:04:54,479 --> 00:04:56,160
family reference guides are hundreds

147
00:04:56,160 --> 00:04:56,800
sometimes

148
00:04:56,800 --> 00:04:59,520
thousands of pages long we're going to

149
00:04:59,520 --> 00:05:01,320
be going over examples with the

150
00:05:01,320 --> 00:05:03,919
5529 but the same techniques apply to

151
00:05:03,919 --> 00:05:06,160
any microcontroller

152
00:05:06,160 --> 00:05:07,759
you need to find the section of the

153
00:05:07,759 --> 00:05:09,759
datasheet or the family reference manual

154
00:05:09,759 --> 00:05:11,440
pertaining to i squared c

155
00:05:11,440 --> 00:05:13,039
and you might also need to refer to the

156
00:05:13,039 --> 00:05:14,720
section on gpio

157
00:05:14,720 --> 00:05:16,720
remapping peripherals or clock

158
00:05:16,720 --> 00:05:18,400
structures in the

159
00:05:18,400 --> 00:05:20,639
case of the msp430 we actually do need

160
00:05:20,639 --> 00:05:21,759
to refer to both

161
00:05:21,759 --> 00:05:24,720
gpio and the clock structure well

162
00:05:24,720 --> 00:05:26,240
written data sheets will include

163
00:05:26,240 --> 00:05:27,919
references to the parts of the data

164
00:05:27,919 --> 00:05:29,680
sheet that are relevant to using that

165
00:05:29,680 --> 00:05:31,680
peripheral

166
00:05:31,680 --> 00:05:34,000
make use of all available resources look

167
00:05:34,000 --> 00:05:36,840
at example libraries or example usage

168
00:05:36,840 --> 00:05:38,880
code

169
00:05:38,880 --> 00:05:40,479
look for open source projects that use

170
00:05:40,479 --> 00:05:42,400
the same chip and peripheral

171
00:05:42,400 --> 00:05:44,720
if you're running into confusing errors

172
00:05:44,720 --> 00:05:46,800
this is something that bit me recently

173
00:05:46,800 --> 00:05:48,560
check the errata page for the chip you

174
00:05:48,560 --> 00:05:50,639
are using sometimes hardware bugs are

175
00:05:50,639 --> 00:05:52,160
the issue and there will be workarounds

176
00:05:52,160 --> 00:05:53,039
in the errata

177
00:05:53,039 --> 00:05:55,840
on how to fix those so your terminology

178
00:05:55,840 --> 00:05:56,800
is going to vary

179
00:05:56,800 --> 00:05:59,520
from microcontroller family to family

180
00:05:59,520 --> 00:06:02,479
atmel calls i squared c twi for example

181
00:06:02,479 --> 00:06:05,600
other terms will vary from chip to chip

182
00:06:05,600 --> 00:06:07,600
some manufacturers combine all their

183
00:06:07,600 --> 00:06:09,600
serial buses into a single block this is

184
00:06:09,600 --> 00:06:11,840
how the msp430 does it it calls it the

185
00:06:11,840 --> 00:06:14,400
universal serial communication interface

186
00:06:14,400 --> 00:06:16,000
you get a couple of these blocks and

187
00:06:16,000 --> 00:06:18,319
each one can be configured as uart spi

188
00:06:18,319 --> 00:06:20,960
or i squared c other microcontrollers

189
00:06:20,960 --> 00:06:21,280
will

190
00:06:21,280 --> 00:06:23,759
have each serial bus in their own block

191
00:06:23,759 --> 00:06:24,960
this is how many other

192
00:06:24,960 --> 00:06:28,160
manufacturers do it either way

193
00:06:28,160 --> 00:06:30,240
the setup process is broadly similar is

194
00:06:30,240 --> 00:06:32,080
only one difference essentially

195
00:06:32,080 --> 00:06:33,840
and the process we cover here can easily

196
00:06:33,840 --> 00:06:35,520
be adapted to other chips when you're in

197
00:06:35,520 --> 00:06:37,280
doubt read the data sheet carefully

198
00:06:37,280 --> 00:06:39,199
utilize all the resources you have at

199
00:06:39,199 --> 00:06:40,560
hand

200
00:06:40,560 --> 00:06:42,240
register names and layouts are going to

201
00:06:42,240 --> 00:06:43,680
differ greatly but the

202
00:06:43,680 --> 00:06:45,840
options and configuration bits that you

203
00:06:45,840 --> 00:06:47,520
are able to choose from

204
00:06:47,520 --> 00:06:49,759
will be similarly grouped in most cases

205
00:06:49,759 --> 00:06:51,360
because of course things go together

206
00:06:51,360 --> 00:06:52,800
logically

207
00:06:52,800 --> 00:06:54,479
for example most microcontrollers have

208
00:06:54,479 --> 00:06:56,319
baud rate as a separate register they'll

209
00:06:56,319 --> 00:06:58,000
have the peripheral address as a

210
00:06:58,000 --> 00:06:59,199
separate register

211
00:06:59,199 --> 00:07:00,960
they'll often have both transmit and

212
00:07:00,960 --> 00:07:02,639
receive buffers for incoming and

213
00:07:02,639 --> 00:07:05,360
outgoing data that sort of thing

214
00:07:05,360 --> 00:07:07,120
so let's take a look at the general

215
00:07:07,120 --> 00:07:09,360
setup process

216
00:07:09,360 --> 00:07:11,280
so generally the following steps are

217
00:07:11,280 --> 00:07:12,720
taken you

218
00:07:12,720 --> 00:07:14,560
make sure the i squared c peripheral is

219
00:07:14,560 --> 00:07:16,880
disabled you put it into reset if

220
00:07:16,880 --> 00:07:18,319
applicable some require

221
00:07:18,319 --> 00:07:21,520
you to enable a reset bit

222
00:07:21,520 --> 00:07:23,680
it's a bit often called on or reset or

223
00:07:23,680 --> 00:07:25,599
something similar to that

224
00:07:25,599 --> 00:07:28,960
select the pins you want to connect to

225
00:07:28,960 --> 00:07:31,919
sometimes you are restricted to a

226
00:07:31,919 --> 00:07:33,759
certain subset of pens

227
00:07:33,759 --> 00:07:35,360
others can be connected to a range of

228
00:07:35,360 --> 00:07:37,039
different pins using an

229
00:07:37,039 --> 00:07:39,039
interconnected matrix this is how the

230
00:07:39,039 --> 00:07:41,919
pics do it um either you can select from

231
00:07:41,919 --> 00:07:43,840
a subset of pins to put your i squared c

232
00:07:43,840 --> 00:07:46,000
bus on on the msp430

233
00:07:46,000 --> 00:07:49,120
uh you're hardwired to particular pins

234
00:07:49,120 --> 00:07:51,440
configure the speed of the bus so decide

235
00:07:51,440 --> 00:07:52,400
whether you're going to be running at

236
00:07:52,400 --> 00:07:55,599
100 kilohertz 400 kilohertz

237
00:07:55,599 --> 00:07:58,720
usually this is going to be you have to

238
00:07:58,720 --> 00:08:00,720
calculate a divisor based on the clock

239
00:08:00,720 --> 00:08:02,160
speed of the chip

240
00:08:02,160 --> 00:08:04,639
some chips have separate clock systems

241
00:08:04,639 --> 00:08:06,080
just for the peripherals

242
00:08:06,080 --> 00:08:07,919
so make sure that you have the clock

243
00:08:07,919 --> 00:08:09,680
system set up correctly

244
00:08:09,680 --> 00:08:11,440
or just look up what the defaults are

245
00:08:11,440 --> 00:08:12,960
for the chip you're using and then make

246
00:08:12,960 --> 00:08:14,639
sure you base it on that the data sheet

247
00:08:14,639 --> 00:08:16,160
should tell you

248
00:08:16,160 --> 00:08:18,319
which clock it's based on or it'll let

249
00:08:18,319 --> 00:08:20,479
you pick which clock you want to

250
00:08:20,479 --> 00:08:23,520
derive your baud rate from sometimes

251
00:08:23,520 --> 00:08:24,960
there's a formula that goes along with

252
00:08:24,960 --> 00:08:25,599
it

253
00:08:25,599 --> 00:08:27,759
sometimes it's as simple as dividing say

254
00:08:27,759 --> 00:08:29,599
you're running at six megahertz and you

255
00:08:29,599 --> 00:08:30,479
want to

256
00:08:30,479 --> 00:08:32,640
run at 100 kilohertz well your divisor

257
00:08:32,640 --> 00:08:34,080
is going to be 60.

258
00:08:34,080 --> 00:08:37,519
sometimes you have to divide by 32

259
00:08:37,519 --> 00:08:39,919
or you know multiply by eight sometimes

260
00:08:39,919 --> 00:08:42,559
there's a prescaler value you can add

261
00:08:42,559 --> 00:08:44,880
um which can be useful if you're running

262
00:08:44,880 --> 00:08:46,560
at a very high clock rate say you're

263
00:08:46,560 --> 00:08:48,399
running at 100 megahertz but you want to

264
00:08:48,399 --> 00:08:50,160
run at 100 kilohertz

265
00:08:50,160 --> 00:08:51,760
normally that would be quite a big

266
00:08:51,760 --> 00:08:54,080
divisor but if you add a prescaler

267
00:08:54,080 --> 00:08:56,720
to the clock of two or four that divides

268
00:08:56,720 --> 00:08:57,760
it down

269
00:08:57,760 --> 00:08:59,519
first and then you can divide it down

270
00:08:59,519 --> 00:09:02,320
more using the actual baud rate

271
00:09:02,320 --> 00:09:05,360
divisor set the peripheral into i

272
00:09:05,360 --> 00:09:05,920
squared c

273
00:09:05,920 --> 00:09:08,080
mode if applicable as i said this is how

274
00:09:08,080 --> 00:09:10,160
it works on the msp430 you have to tell

275
00:09:10,160 --> 00:09:12,160
it i want this block to operate as i

276
00:09:12,160 --> 00:09:13,760
squared c

277
00:09:13,760 --> 00:09:15,360
uh sometimes you need to do this

278
00:09:15,360 --> 00:09:16,720
immediately after putting the block into

279
00:09:16,720 --> 00:09:17,440
reset

280
00:09:17,440 --> 00:09:19,360
if that you need to the data sheet will

281
00:09:19,360 --> 00:09:20,959
tell you then

282
00:09:20,959 --> 00:09:23,279
enable the peripheral and communication

283
00:09:23,279 --> 00:09:26,240
commands so it's just a few simple steps

284
00:09:26,240 --> 00:09:28,240
this will apply to pretty much all i

285
00:09:28,240 --> 00:09:30,240
squared c hardware peripherals across

286
00:09:30,240 --> 00:09:32,959
all microcontrollers these steps might

287
00:09:32,959 --> 00:09:35,040
be in a different order

288
00:09:35,040 --> 00:09:36,880
there might be other little caveats

289
00:09:36,880 --> 00:09:38,640
depending on the chip but these are the

290
00:09:38,640 --> 00:09:41,040
goals that you need to get done

291
00:09:41,040 --> 00:09:44,080
so specifically on the f5529 let's go

292
00:09:44,080 --> 00:09:46,560
take a look at the family users guide

293
00:09:46,560 --> 00:09:49,760
and we're going to take a brief look

294
00:09:49,760 --> 00:09:50,000
through

295
00:09:50,000 --> 00:09:53,920
it at how initialization and reset works

296
00:09:53,920 --> 00:09:55,120
and in a minute we're actually going to

297
00:09:55,120 --> 00:09:57,040
be going and looking at the pdf but for

298
00:09:57,040 --> 00:09:59,440
initialization and reset

299
00:09:59,440 --> 00:10:02,839
this is the very first step so in the

300
00:10:02,839 --> 00:10:04,000
f5529

301
00:10:04,000 --> 00:10:07,440
the reset bit is called uc swr

302
00:10:07,440 --> 00:10:11,279
rst sw rst which stands for

303
00:10:11,279 --> 00:10:14,720
software reset so you only configure

304
00:10:14,720 --> 00:10:16,880
or reconfigure the module when that

305
00:10:16,880 --> 00:10:18,320
software bit is set

306
00:10:18,320 --> 00:10:19,760
so that's the very first thing we need

307
00:10:19,760 --> 00:10:22,720
to do if you look down below

308
00:10:22,720 --> 00:10:25,040
initializing or reconfiguring the usci

309
00:10:25,040 --> 00:10:25,839
module

310
00:10:25,839 --> 00:10:28,959
the recommended process is to set that

311
00:10:28,959 --> 00:10:30,000
reset bit

312
00:10:30,000 --> 00:10:32,399
initialize all the usci registers with

313
00:10:32,399 --> 00:10:34,560
whatever you need to set them to

314
00:10:34,560 --> 00:10:37,839
configure the i o ports then

315
00:10:37,839 --> 00:10:41,200
clear the software reset bit and you can

316
00:10:41,200 --> 00:10:42,079
then enable an

317
00:10:42,079 --> 00:10:45,440
interrupts if you want to so data sheets

318
00:10:45,440 --> 00:10:46,000
will usually

319
00:10:46,000 --> 00:10:48,480
have a step-by-step list because there

320
00:10:48,480 --> 00:10:50,240
may be reasons why things need to be

321
00:10:50,240 --> 00:10:52,320
done in a certain order

322
00:10:52,320 --> 00:10:55,040
uh so configuring speed which is the

323
00:10:55,040 --> 00:10:55,600
next step

324
00:10:55,600 --> 00:10:58,399
after the module is put in reset for the

325
00:10:58,399 --> 00:10:59,360
msp

326
00:10:59,360 --> 00:11:00,880
we then have to set the speed of the bus

327
00:11:00,880 --> 00:11:02,480
by calculating the values

328
00:11:02,480 --> 00:11:04,959
for the baud rate registers so all the

329
00:11:04,959 --> 00:11:07,839
registers on the msp430

330
00:11:07,839 --> 00:11:09,440
because the block is called the

331
00:11:09,440 --> 00:11:11,839
universal serial communication interface

332
00:11:11,839 --> 00:11:15,600
all of the blocks start with uc

333
00:11:15,600 --> 00:11:17,839
b and then a number we're using block

334
00:11:17,839 --> 00:11:19,760
number one so they're all going to start

335
00:11:19,760 --> 00:11:20,640
with ucb

336
00:11:20,640 --> 00:11:23,600
one so all we really need to look at is

337
00:11:23,600 --> 00:11:24,320
those last

338
00:11:24,320 --> 00:11:28,240
letters br0 and br1 this is a 16 bit

339
00:11:28,240 --> 00:11:29,839
value

340
00:11:29,839 --> 00:11:34,800
so we can divide the clock by up to 1024

341
00:11:34,800 --> 00:11:38,399
so we need to very carefully calculate

342
00:11:38,399 --> 00:11:39,839
what that baud rate division is going to

343
00:11:39,839 --> 00:11:40,160
be

344
00:11:40,160 --> 00:11:44,880
see if it fits in 16 bits or just 8 bits

345
00:11:44,880 --> 00:11:46,640
here's the actual description of those

346
00:11:46,640 --> 00:11:48,399
registers from the data sheet you can

347
00:11:48,399 --> 00:11:48,880
see

348
00:11:48,880 --> 00:11:51,360
we can only modify these when that reset

349
00:11:51,360 --> 00:11:53,680
bit is set so that's really important to

350
00:11:53,680 --> 00:11:56,399
reset the reset bit and then do all your

351
00:11:56,399 --> 00:11:57,839
configuration

352
00:11:57,839 --> 00:12:01,120
as you can see the prescaler is a 16-bit

353
00:12:01,120 --> 00:12:01,600
value

354
00:12:01,600 --> 00:12:05,440
it's br0 plus br 1 times 256 so it's

355
00:12:05,440 --> 00:12:07,360
just concatenating these two

356
00:12:07,360 --> 00:12:10,880
bytes together to make a 16-bit value

357
00:12:10,880 --> 00:12:12,880
simply treat them as a 16 bit value for

358
00:12:12,880 --> 00:12:14,639
a 6 megahertz peripheral clock to get

359
00:12:14,639 --> 00:12:17,120
100 kilohertz our divisor would be 60.

360
00:12:17,120 --> 00:12:19,279
it's a 16 bit value partially because

361
00:12:19,279 --> 00:12:22,480
the msp 430 is a 16 bit processor

362
00:12:22,480 --> 00:12:24,560
but also because we might need to divide

363
00:12:24,560 --> 00:12:26,720
by more than 255

364
00:12:26,720 --> 00:12:28,000
especially if you're running at a higher

365
00:12:28,000 --> 00:12:30,160
clock speed

366
00:12:30,160 --> 00:12:31,680
after that we need to set up the control

367
00:12:31,680 --> 00:12:35,519
registers on the msp430 there's two

368
00:12:35,519 --> 00:12:38,320
control registers that configure how the

369
00:12:38,320 --> 00:12:40,399
i squared c module is set up

370
00:12:40,399 --> 00:12:42,560
control 0 and control run remember we

371
00:12:42,560 --> 00:12:44,959
can ignore ucb1 that's going to be

372
00:12:44,959 --> 00:12:46,880
present in front of all these register

373
00:12:46,880 --> 00:12:48,399
names

374
00:12:48,399 --> 00:12:49,920
these set things like the peripheral

375
00:12:49,920 --> 00:12:51,279
address length whether it's going to be

376
00:12:51,279 --> 00:12:52,160
7 bit or

377
00:12:52,160 --> 00:12:54,320
10 bit almost all the time we'll be

378
00:12:54,320 --> 00:12:55,360
using 7-bit

379
00:12:55,360 --> 00:12:56,959
whether we are currently acting against

380
00:12:56,959 --> 00:12:58,639
the controller or the peripheral

381
00:12:58,639 --> 00:13:00,959
because of course the msp430 can act as

382
00:13:00,959 --> 00:13:01,680
a peripheral

383
00:13:01,680 --> 00:13:05,120
and let another chip control the bus

384
00:13:05,120 --> 00:13:06,720
and act as if we're a sensor or

385
00:13:06,720 --> 00:13:08,639
something uh

386
00:13:08,639 --> 00:13:10,079
this will also set whether we're

387
00:13:10,079 --> 00:13:12,160
currently transmitting or receiving as

388
00:13:12,160 --> 00:13:13,680
well as there's bits to generate

389
00:13:13,680 --> 00:13:15,600
star conditions stop conditions

390
00:13:15,600 --> 00:13:16,959
acknowledge not acknowledge

391
00:13:16,959 --> 00:13:19,040
all the hardware bits that we looked at

392
00:13:19,040 --> 00:13:20,399
last week

393
00:13:20,399 --> 00:13:22,720
for initialization we just need to make

394
00:13:22,720 --> 00:13:23,920
sure that we have them set up for i

395
00:13:23,920 --> 00:13:25,040
squared c mode

396
00:13:25,040 --> 00:13:27,920
acting as the controller and this

397
00:13:27,920 --> 00:13:29,600
process is generally similar in all

398
00:13:29,600 --> 00:13:30,959
microcontrollers you're going to be

399
00:13:30,959 --> 00:13:31,839
setting whether

400
00:13:31,839 --> 00:13:34,480
you want 7 or 10 bit peripheral

401
00:13:34,480 --> 00:13:35,519
addresses

402
00:13:35,519 --> 00:13:37,200
whether we are acting as the controller

403
00:13:37,200 --> 00:13:38,959
or the peripheral

404
00:13:38,959 --> 00:13:40,240
and then there's going to be bits to

405
00:13:40,240 --> 00:13:43,120
generate start condition stop conditions

406
00:13:43,120 --> 00:13:44,880
let's take a closer look at this part of

407
00:13:44,880 --> 00:13:46,399
the data sheet just to

408
00:13:46,399 --> 00:13:48,279
show you exactly how it's done on the

409
00:13:48,279 --> 00:13:50,320
msp430

410
00:13:50,320 --> 00:13:53,440
all right so here is the family user's

411
00:13:53,440 --> 00:13:54,800
guide for the

412
00:13:54,800 --> 00:13:58,639
five and six series msp430s

413
00:13:58,639 --> 00:14:00,839
these are the higher end more powerful

414
00:14:00,839 --> 00:14:02,399
chips

415
00:14:02,399 --> 00:14:04,160
these are all the different peripherals

416
00:14:04,160 --> 00:14:05,279
on the side but of course we're

417
00:14:05,279 --> 00:14:06,959
interested in the universal serial

418
00:14:06,959 --> 00:14:08,320
communication interface

419
00:14:08,320 --> 00:14:10,399
running in i squared c mode so section

420
00:14:10,399 --> 00:14:12,560
38

421
00:14:12,560 --> 00:14:13,519
and we're going to take a look

422
00:14:13,519 --> 00:14:15,760
specifically at the registers i just

423
00:14:15,760 --> 00:14:17,199
want to show you

424
00:14:17,199 --> 00:14:19,600
what things you'll typically find in

425
00:14:19,600 --> 00:14:21,279
configuration registers so here's

426
00:14:21,279 --> 00:14:22,800
control zero

427
00:14:22,800 --> 00:14:25,920
so there's each of these is a single bit

428
00:14:25,920 --> 00:14:26,880
that you set

429
00:14:26,880 --> 00:14:28,480
in these registers and they configure

430
00:14:28,480 --> 00:14:30,160
different things if we're acting as a

431
00:14:30,160 --> 00:14:30,959
peripheral

432
00:14:30,959 --> 00:14:32,959
do we want to use a 7-bit or 10-bit

433
00:14:32,959 --> 00:14:34,560
address if we're acting as the

434
00:14:34,560 --> 00:14:35,839
controller

435
00:14:35,839 --> 00:14:37,600
does the peripheral have a 7-bit or

436
00:14:37,600 --> 00:14:40,160
10-bit address are there more than one

437
00:14:40,160 --> 00:14:41,360
controller

438
00:14:41,360 --> 00:14:44,639
on this bus if it's a single controller

439
00:14:44,639 --> 00:14:45,839
environment

440
00:14:45,839 --> 00:14:47,440
um then we don't need to worry about

441
00:14:47,440 --> 00:14:50,079
stuff like bus arbitration

442
00:14:50,079 --> 00:14:53,680
or address comparison that sort of thing

443
00:14:53,680 --> 00:14:56,720
whether we are currently a controller

444
00:14:56,720 --> 00:15:00,000
or a peripheral and then this is the

445
00:15:00,000 --> 00:15:03,680
bit the this us uc mode x bit

446
00:15:03,680 --> 00:15:06,079
this is what actually changes the the

447
00:15:06,079 --> 00:15:07,279
type of

448
00:15:07,279 --> 00:15:09,920
universal serial communication interface

449
00:15:09,920 --> 00:15:10,959
we have three pin

450
00:15:10,959 --> 00:15:14,399
spi four pin spi i squared c mode

451
00:15:14,399 --> 00:15:15,760
and then below that we have both

452
00:15:15,760 --> 00:15:17,680
asynchronous and synchronous mode

453
00:15:17,680 --> 00:15:20,000
i squared c is always synchronous and

454
00:15:20,000 --> 00:15:22,240
this is actually set to a one by default

455
00:15:22,240 --> 00:15:25,360
for us which is kind of nice

456
00:15:25,360 --> 00:15:27,920
actually that's a read-only uh so that's

457
00:15:27,920 --> 00:15:29,040
just telling us what

458
00:15:29,040 --> 00:15:32,000
it's set to and then here's the control

459
00:15:32,000 --> 00:15:34,720
1 register

460
00:15:34,720 --> 00:15:37,759
so again we can choose what clock source

461
00:15:37,759 --> 00:15:38,480
we want

462
00:15:38,480 --> 00:15:41,839
to clock the i squared c peripheral from

463
00:15:41,839 --> 00:15:44,720
these terms a clock sm clock these are

464
00:15:44,720 --> 00:15:47,040
unique to the msp 430 they'll be called

465
00:15:47,040 --> 00:15:48,560
different things on different clock

466
00:15:48,560 --> 00:15:51,839
on different chips sm clock on the msp

467
00:15:51,839 --> 00:15:53,519
430 is the

468
00:15:53,519 --> 00:15:55,680
peripheral clock so there's m clock

469
00:15:55,680 --> 00:15:57,199
which is the clock that goes directly to

470
00:15:57,199 --> 00:15:58,320
the cpu

471
00:15:58,320 --> 00:16:00,160
then there's sm clock which goes to all

472
00:16:00,160 --> 00:16:02,560
the peripherals the reason that chips do

473
00:16:02,560 --> 00:16:03,759
this is because

474
00:16:03,759 --> 00:16:05,519
it gives you more control over power

475
00:16:05,519 --> 00:16:07,600
consumption if you want to just turn off

476
00:16:07,600 --> 00:16:09,680
the peripherals you can or even just

477
00:16:09,680 --> 00:16:11,680
reduce power usage you can slow down the

478
00:16:11,680 --> 00:16:13,199
clock on the peripherals

479
00:16:13,199 --> 00:16:15,360
or on the cpu while leaving the

480
00:16:15,360 --> 00:16:17,519
peripherals running at full speed

481
00:16:17,519 --> 00:16:19,680
that's why they're split up on simpler

482
00:16:19,680 --> 00:16:21,600
chips it'll just be all one clock and

483
00:16:21,600 --> 00:16:23,199
you won't need to worry about the clock

484
00:16:23,199 --> 00:16:25,920
source selection

485
00:16:26,160 --> 00:16:27,519
whether we're currently acting as the

486
00:16:27,519 --> 00:16:29,759
transmitter or receiver this bit

487
00:16:29,759 --> 00:16:34,079
will essentially change that read write

488
00:16:34,079 --> 00:16:35,839
bit remember at the end of the i squared

489
00:16:35,839 --> 00:16:36,639
c

490
00:16:36,639 --> 00:16:38,399
peripheral address we have that read

491
00:16:38,399 --> 00:16:40,160
write bit to tell the chip

492
00:16:40,160 --> 00:16:42,000
whether we want to write to it or read

493
00:16:42,000 --> 00:16:43,759
from it that's what this

494
00:16:43,759 --> 00:16:46,639
bit is going to set for us there's a bit

495
00:16:46,639 --> 00:16:48,240
here to transmit a knack

496
00:16:48,240 --> 00:16:50,959
this is obviously if we're reading data

497
00:16:50,959 --> 00:16:52,160
like we saw last

498
00:16:52,160 --> 00:16:54,720
in week in that example i read 10 bits

499
00:16:54,720 --> 00:16:55,839
from that eprom

500
00:16:55,839 --> 00:16:58,079
then at the end i had to transmit a

501
00:16:58,079 --> 00:16:59,839
knack so after 10 bit

502
00:16:59,839 --> 00:17:03,040
or after 10 bytes you would set this

503
00:17:03,040 --> 00:17:05,599
bit to one and then at the end of that

504
00:17:05,599 --> 00:17:09,520
byte it will generate a knack for you

505
00:17:09,839 --> 00:17:12,160
we have bits to transmit a stop

506
00:17:12,160 --> 00:17:13,760
condition and a start condition

507
00:17:13,760 --> 00:17:15,919
and then here's that software reset bit

508
00:17:15,919 --> 00:17:17,199
that we need to set

509
00:17:17,199 --> 00:17:20,319
before we can modify these registers

510
00:17:20,319 --> 00:17:22,480
now here's another difference between

511
00:17:22,480 --> 00:17:24,559
certain chips you have to watch out for

512
00:17:24,559 --> 00:17:28,000
the msp430 when you set this bit here

513
00:17:28,000 --> 00:17:31,600
the start bit that will send the start

514
00:17:31,600 --> 00:17:32,480
condition

515
00:17:32,480 --> 00:17:35,520
and the address of the peripheral with

516
00:17:35,520 --> 00:17:36,880
the reader write bit

517
00:17:36,880 --> 00:17:40,640
set according to how uctr is set

518
00:17:40,640 --> 00:17:43,280
not all chips do this for you some chips

519
00:17:43,280 --> 00:17:44,400
when you

520
00:17:44,400 --> 00:17:46,960
set the bit to do the start address or

521
00:17:46,960 --> 00:17:48,320
the start condition

522
00:17:48,320 --> 00:17:51,520
it expects you to send the address as if

523
00:17:51,520 --> 00:17:53,120
it were a piece of data

524
00:17:53,120 --> 00:17:56,240
the msp430 does it for you just make

525
00:17:56,240 --> 00:17:58,320
sure you know what your chip is doing so

526
00:17:58,320 --> 00:17:59,760
that you're not sending the address

527
00:17:59,760 --> 00:18:01,120
twice for example or

528
00:18:01,120 --> 00:18:02,720
not sending an address at all if you're

529
00:18:02,720 --> 00:18:04,640
expecting the chip to do it for you

530
00:18:04,640 --> 00:18:06,400
and it's not you're going to run into

531
00:18:06,400 --> 00:18:08,559
problems

532
00:18:08,559 --> 00:18:10,400
below that we have as you can see our

533
00:18:10,400 --> 00:18:12,000
baud rate registers

534
00:18:12,000 --> 00:18:14,880
we also have a status register which not

535
00:18:14,880 --> 00:18:17,039
too much useful in there for us

536
00:18:17,039 --> 00:18:19,200
all chips you'll have these two buffers

537
00:18:19,200 --> 00:18:21,280
a receive buffer and a transmit buffer

538
00:18:21,280 --> 00:18:22,880
this is where we actually read and write

539
00:18:22,880 --> 00:18:24,160
data from

540
00:18:24,160 --> 00:18:26,160
when you write a byte in here it gets

541
00:18:26,160 --> 00:18:28,080
sent out on the i squared c bus when

542
00:18:28,080 --> 00:18:28,799
you're reading

543
00:18:28,799 --> 00:18:30,400
bytes from a peripheral they're going to

544
00:18:30,400 --> 00:18:33,120
show up in that rx buff

545
00:18:33,120 --> 00:18:36,080
and then we have settings for our own

546
00:18:36,080 --> 00:18:38,000
address if we're acting as a peripheral

547
00:18:38,000 --> 00:18:40,080
we won't be using that at all and then

548
00:18:40,080 --> 00:18:41,840
an address for the peripheral we're

549
00:18:41,840 --> 00:18:44,080
talking to which can be up to 10 bits

550
00:18:44,080 --> 00:18:44,880
long

551
00:18:44,880 --> 00:18:46,320
we're going to be using the 7-bit

552
00:18:46,320 --> 00:18:48,559
version this is a chip

553
00:18:48,559 --> 00:18:50,799
as i mentioned last week some chips will

554
00:18:50,799 --> 00:18:51,600
automatically

555
00:18:51,600 --> 00:18:53,440
shift the address for you and add the

556
00:18:53,440 --> 00:18:54,640
read write bit

557
00:18:54,640 --> 00:18:56,640
this is one of those chips so we take

558
00:18:56,640 --> 00:18:58,480
the 7-bit address

559
00:18:58,480 --> 00:19:00,720
of whatever peripheral we're talking to

560
00:19:00,720 --> 00:19:02,559
we put it into this register and it

561
00:19:02,559 --> 00:19:04,080
takes care of everything else for us

562
00:19:04,080 --> 00:19:05,600
which is really nice

563
00:19:05,600 --> 00:19:08,000
down here we've got interrupt enables

564
00:19:08,000 --> 00:19:09,760
which we won't be using

565
00:19:09,760 --> 00:19:11,760
but we also have interrupt flags which

566
00:19:11,760 --> 00:19:12,799
we will be using

567
00:19:12,799 --> 00:19:15,200
these flags get set whether or not we're

568
00:19:15,200 --> 00:19:16,720
using interrupts and they're a good way

569
00:19:16,720 --> 00:19:19,280
to tell what's going on

570
00:19:19,280 --> 00:19:21,120
these flags get set for example when

571
00:19:21,120 --> 00:19:24,160
start conditions are complete um

572
00:19:24,160 --> 00:19:27,280
when we're transmitting when the

573
00:19:27,280 --> 00:19:29,039
transmit buffer is empty when the

574
00:19:29,039 --> 00:19:30,880
receive buffer has received a complete

575
00:19:30,880 --> 00:19:31,760
character

576
00:19:31,760 --> 00:19:33,360
these will tell us when certain events

577
00:19:33,360 --> 00:19:36,400
have happened so that we can act on them

578
00:19:36,400 --> 00:19:38,080
so that's just a quick overview of the

579
00:19:38,080 --> 00:19:39,600
registers um

580
00:19:39,600 --> 00:19:42,960
as you can see we can set these just by

581
00:19:42,960 --> 00:19:43,840
writing

582
00:19:43,840 --> 00:19:46,679
a hexadecimal number to them or the

583
00:19:46,679 --> 00:19:48,080
msp430

584
00:19:48,080 --> 00:19:50,960
like many microcontrollers will have an

585
00:19:50,960 --> 00:19:51,600
include

586
00:19:51,600 --> 00:19:54,559
header file in the case the msp430 it's

587
00:19:54,559 --> 00:19:55,559
called

588
00:19:55,559 --> 00:19:58,559
msp430.h and these names here

589
00:19:58,559 --> 00:20:01,840
uca10 ucmm ucmst

590
00:20:01,840 --> 00:20:03,600
you can actually use those directly in

591
00:20:03,600 --> 00:20:05,600
your code and it will know

592
00:20:05,600 --> 00:20:08,240
which bit you're talking about in these

593
00:20:08,240 --> 00:20:08,720
different

594
00:20:08,720 --> 00:20:10,480
registers which is really handy it makes

595
00:20:10,480 --> 00:20:13,039
the code a lot easier to read

596
00:20:13,039 --> 00:20:14,960
instead of just having a hexadecimal

597
00:20:14,960 --> 00:20:16,400
number which then

598
00:20:16,400 --> 00:20:17,679
you know if you're a good programmer

599
00:20:17,679 --> 00:20:19,200
you'd have to put a comment next to

600
00:20:19,200 --> 00:20:20,559
explaining what it does

601
00:20:20,559 --> 00:20:22,400
this makes it a lot more evident what

602
00:20:22,400 --> 00:20:24,240
you're actually writing to the registers

603
00:20:24,240 --> 00:20:25,440
and so it makes it easier for other

604
00:20:25,440 --> 00:20:26,960
people to read your code

605
00:20:26,960 --> 00:20:28,720
okay so now we're back from looking at

606
00:20:28,720 --> 00:20:31,200
the pdf let's take a look

607
00:20:31,200 --> 00:20:32,960
at actually setting up those control

608
00:20:32,960 --> 00:20:35,200
registers what options do we want well

609
00:20:35,200 --> 00:20:37,600
we basically figured it out by looking

610
00:20:37,600 --> 00:20:40,080
at those registers we need to set the

611
00:20:40,080 --> 00:20:41,520
two main control registers to the

612
00:20:41,520 --> 00:20:42,480
following values

613
00:20:42,480 --> 00:20:45,440
first we need to set that software reset

614
00:20:45,440 --> 00:20:45,919
but

615
00:20:45,919 --> 00:20:48,960
a bit that's the most important part

616
00:20:48,960 --> 00:20:50,640
if we don't do this we're probably going

617
00:20:50,640 --> 00:20:52,320
to crash the processor or have

618
00:20:52,320 --> 00:20:54,880
unexpected results that may end up with

619
00:20:54,880 --> 00:20:56,960
corrupt data on the bus

620
00:20:56,960 --> 00:21:00,640
then we set the control 0 the three bits

621
00:21:00,640 --> 00:21:01,600
we're setting here

622
00:21:01,600 --> 00:21:03,200
remember how i said you can use that

623
00:21:03,200 --> 00:21:04,960
include file so that you can write the

624
00:21:04,960 --> 00:21:06,240
names of the bits

625
00:21:06,240 --> 00:21:08,720
well this one you see mst that's setting

626
00:21:08,720 --> 00:21:10,400
us as the controller

627
00:21:10,400 --> 00:21:13,120
uc mode three that's selecting i squared

628
00:21:13,120 --> 00:21:13,919
c mode

629
00:21:13,919 --> 00:21:16,320
and uc sync is also setting the

630
00:21:16,320 --> 00:21:17,840
synchronous mode bit

631
00:21:17,840 --> 00:21:20,640
um as i explained here set the module as

632
00:21:20,640 --> 00:21:21,919
the controller i squared c mode

633
00:21:21,919 --> 00:21:22,880
synchronous mode

634
00:21:22,880 --> 00:21:26,480
control 1 we're going to do ucs cell

635
00:21:26,480 --> 00:21:29,919
that's actually two underscores sm clock

636
00:21:29,919 --> 00:21:30,559
that's

637
00:21:30,559 --> 00:21:32,559
saying we want to clock this peripheral

638
00:21:32,559 --> 00:21:34,000
from the sm clock

639
00:21:34,000 --> 00:21:35,679
and then because we're writing to this

640
00:21:35,679 --> 00:21:37,120
peripheral or this

641
00:21:37,120 --> 00:21:38,960
register we need to make sure that we

642
00:21:38,960 --> 00:21:41,200
keep that software reset bit set so

643
00:21:41,200 --> 00:21:45,039
that's why it's added there as well

644
00:21:45,039 --> 00:21:46,400
as i just said we're going to be using

645
00:21:46,400 --> 00:21:48,400
sm clock then we're ready to set the

646
00:21:48,400 --> 00:21:49,760
baud rate divisor we're going to be

647
00:21:49,760 --> 00:21:51,280
running at 6 megahertz i actually

648
00:21:51,280 --> 00:21:53,840
there's a typo there it should say 60.

649
00:21:53,840 --> 00:21:57,679
so we're going to set baud rate 0 to 3c

650
00:21:57,679 --> 00:22:00,080
because our divisor is only 8 bits long

651
00:22:00,080 --> 00:22:02,799
we can just set the top bit to 0

652
00:22:02,799 --> 00:22:04,400
and actually we don't even necessarily

653
00:22:04,400 --> 00:22:06,159
have to do that it's just good practice

654
00:22:06,159 --> 00:22:06,799
it will be

655
00:22:06,799 --> 00:22:09,679
0 upon reset but we should never assume

656
00:22:09,679 --> 00:22:10,960
that it's in

657
00:22:10,960 --> 00:22:13,840
a reset state something else could have

658
00:22:13,840 --> 00:22:15,360
written to that in the meantime so we

659
00:22:15,360 --> 00:22:16,960
always set it to zero

660
00:22:16,960 --> 00:22:19,520
so the full 16 bit value is zero zero

661
00:22:19,520 --> 00:22:20,240
three c

662
00:22:20,240 --> 00:22:23,200
so it's going to divide by 60. then we

663
00:22:23,200 --> 00:22:25,520
need to configure the i o pins now

664
00:22:25,520 --> 00:22:27,440
many microcontrollers allow peripherals

665
00:22:27,440 --> 00:22:29,840
to be connected to whatever pin

666
00:22:29,840 --> 00:22:32,480
um some microcontrollers offer a lot of

667
00:22:32,480 --> 00:22:34,400
flexibility the pic

668
00:22:34,400 --> 00:22:36,480
microcontrollers will let you choose

669
00:22:36,480 --> 00:22:37,679
almost any pin

670
00:22:37,679 --> 00:22:40,400
on the chip which is really nice the

671
00:22:40,400 --> 00:22:42,640
msp430 like many others

672
00:22:42,640 --> 00:22:45,919
are hardwired so we're using

673
00:22:45,919 --> 00:22:48,799
the universal serial block b because

674
00:22:48,799 --> 00:22:50,159
that's the only one that supports i

675
00:22:50,159 --> 00:22:51,120
squared c

676
00:22:51,120 --> 00:22:53,919
and we're using block zero so it's going

677
00:22:53,919 --> 00:22:55,280
to be coming out

678
00:22:55,280 --> 00:22:59,200
on p 3.0 and p 3.1

679
00:22:59,200 --> 00:23:02,559
this is sda and scl as you can see there

680
00:23:02,559 --> 00:23:05,200
unlike other things we're not allowed to

681
00:23:05,200 --> 00:23:06,559
remap it elsewhere

682
00:23:06,559 --> 00:23:08,720
so we're going to have to remember to

683
00:23:08,720 --> 00:23:10,159
set these

684
00:23:10,159 --> 00:23:12,240
to the i squared c peripheral we need to

685
00:23:12,240 --> 00:23:13,520
tell the chip

686
00:23:13,520 --> 00:23:15,360
we want the i squared c peripheral to

687
00:23:15,360 --> 00:23:17,440
have control of these pins we don't want

688
00:23:17,440 --> 00:23:20,159
them to be just regular gpio

689
00:23:20,159 --> 00:23:22,080
so this is actually taken care of in the

690
00:23:22,080 --> 00:23:24,960
gpio section of the data sheet

691
00:23:24,960 --> 00:23:28,159
so on the msp430 every

692
00:23:28,159 --> 00:23:31,919
port has a register called cell

693
00:23:31,919 --> 00:23:34,240
in this case it's port 3. so it's going

694
00:23:34,240 --> 00:23:35,440
to be p3

695
00:23:35,440 --> 00:23:39,039
cell if we set and each bit

696
00:23:39,039 --> 00:23:41,360
in that register represents an actual

697
00:23:41,360 --> 00:23:43,440
physical pin so we're going to have bits

698
00:23:43,440 --> 00:23:47,919
0 and 1 because we want port 3.0 and 3.1

699
00:23:47,919 --> 00:23:51,279
as as peripheral functions so

700
00:23:51,279 --> 00:23:54,720
we just need to set p3 cell

701
00:23:54,720 --> 00:23:56,559
to we'd either set it to a hexadecimal

702
00:23:56,559 --> 00:23:59,600
value 0x03 or the header file

703
00:23:59,600 --> 00:24:02,960
includes names for us again so we can

704
00:24:02,960 --> 00:24:04,080
use bit 1 and bit

705
00:24:04,080 --> 00:24:07,039
2 and that'll do the same thing that's a

706
00:24:07,039 --> 00:24:08,880
little bit more readable

707
00:24:08,880 --> 00:24:11,360
so that's usually what i do and then

708
00:24:11,360 --> 00:24:12,720
these pins are now

709
00:24:12,720 --> 00:24:17,120
selected to be data and clock for us

710
00:24:17,120 --> 00:24:20,559
that process is broadly similar some

711
00:24:20,559 --> 00:24:22,960
chips when you enable the i squared c

712
00:24:22,960 --> 00:24:23,760
module

713
00:24:23,760 --> 00:24:26,000
it will automatically change the gpio

714
00:24:26,000 --> 00:24:27,039
for you

715
00:24:27,039 --> 00:24:28,960
on other chips it won't so you just need

716
00:24:28,960 --> 00:24:31,679
to check and see what you need to do

717
00:24:31,679 --> 00:24:33,360
at this point we're essentially ready to

718
00:24:33,360 --> 00:24:35,200
enable the chip we can bring the i

719
00:24:35,200 --> 00:24:37,120
squared c module out of reset and start

720
00:24:37,120 --> 00:24:38,480
communicating

721
00:24:38,480 --> 00:24:42,240
so if you know your c syntax you can see

722
00:24:42,240 --> 00:24:42,640
we're

723
00:24:42,640 --> 00:24:46,080
unsetting that software reset bit

724
00:24:46,080 --> 00:24:47,440
we're connected to the bus and we're

725
00:24:47,440 --> 00:24:49,440
ready to communicate we need to

726
00:24:49,440 --> 00:24:51,600
set the peripheral address of whatever

727
00:24:51,600 --> 00:24:53,039
chip we want to talk to

728
00:24:53,039 --> 00:24:55,360
we can do that now or we can do it when

729
00:24:55,360 --> 00:24:58,080
we actually go to send bytes

730
00:24:58,080 --> 00:24:59,840
typically at this point when i'm writing

731
00:24:59,840 --> 00:25:02,480
my code i would send a start followed by

732
00:25:02,480 --> 00:25:03,600
a stop

733
00:25:03,600 --> 00:25:06,080
connect my oscilloscope or logic

734
00:25:06,080 --> 00:25:07,120
analyzer to the bus

735
00:25:07,120 --> 00:25:08,960
make sure that we're actually seeing a

736
00:25:08,960 --> 00:25:10,159
start and a stop

737
00:25:10,159 --> 00:25:11,600
so that we're actually getting output on

738
00:25:11,600 --> 00:25:13,200
the pins

739
00:25:13,200 --> 00:25:15,279
and that will also reset some chips

740
00:25:15,279 --> 00:25:16,720
although you can't really rely on that

741
00:25:16,720 --> 00:25:17,840
working

742
00:25:17,840 --> 00:25:19,679
if i'm having problems at this point i

743
00:25:19,679 --> 00:25:21,039
will have the chip go into an

744
00:25:21,039 --> 00:25:23,039
infinite loop sending either random

745
00:25:23,039 --> 00:25:24,720
values or the same value over and over

746
00:25:24,720 --> 00:25:26,000
while i debug

747
00:25:26,000 --> 00:25:27,840
um so i'll you know change different

748
00:25:27,840 --> 00:25:29,200
register values

749
00:25:29,200 --> 00:25:30,880
re-read the data sheet make sure that i

750
00:25:30,880 --> 00:25:32,720
have everything set up correctly

751
00:25:32,720 --> 00:25:36,240
so let's actually send some data so

752
00:25:36,240 --> 00:25:38,559
those same registers the control 0 and

753
00:25:38,559 --> 00:25:40,640
control 1

754
00:25:40,640 --> 00:25:42,240
we're going to be using those as well as

755
00:25:42,240 --> 00:25:44,640
i squared csa which has the peripheral

756
00:25:44,640 --> 00:25:46,000
address

757
00:25:46,000 --> 00:25:47,840
the transmit and receive buffers and

758
00:25:47,840 --> 00:25:50,080
also those interrupt flags those are the

759
00:25:50,080 --> 00:25:51,520
registers that we'll be using to

760
00:25:51,520 --> 00:25:54,080
actually control communication

761
00:25:54,080 --> 00:25:55,600
so at this point we're going to take

762
00:25:55,600 --> 00:25:58,080
another quick look at the data sheet

763
00:25:58,080 --> 00:26:00,960
so let's switch back to that quickly

764
00:26:00,960 --> 00:26:02,880
okay so when we actually go to operate

765
00:26:02,880 --> 00:26:03,279
as

766
00:26:03,279 --> 00:26:06,480
a controller transmitter of course

767
00:26:06,480 --> 00:26:08,000
they're using problematic language here

768
00:26:08,000 --> 00:26:09,360
but that's hopefully they'll update

769
00:26:09,360 --> 00:26:10,000
these data

770
00:26:10,000 --> 00:26:12,720
sheets at some point so we initiate this

771
00:26:12,720 --> 00:26:14,960
mode by writing the desired address to

772
00:26:14,960 --> 00:26:15,679
the

773
00:26:15,679 --> 00:26:18,159
address register for the peripheral

774
00:26:18,159 --> 00:26:20,159
setting the size with that

775
00:26:20,159 --> 00:26:22,400
10 bit or 7-bit address which we've

776
00:26:22,400 --> 00:26:23,520
already done

777
00:26:23,520 --> 00:26:26,080
setting transmit for transmitter mode

778
00:26:26,080 --> 00:26:28,080
and then generating a start condition

779
00:26:28,080 --> 00:26:29,679
the module checks if the bus is

780
00:26:29,679 --> 00:26:32,320
available generates the start condition

781
00:26:32,320 --> 00:26:35,679
and transmits the address for us

782
00:26:35,679 --> 00:26:39,279
the tx ifg which is that transmit flag

783
00:26:39,279 --> 00:26:40,720
is set when the start condition is

784
00:26:40,720 --> 00:26:42,480
generated and the first data to be

785
00:26:42,480 --> 00:26:43,440
transmitted

786
00:26:43,440 --> 00:26:45,760
can be written into the transmit buffer

787
00:26:45,760 --> 00:26:47,520
so as soon as we see that flag set

788
00:26:47,520 --> 00:26:50,400
we can write our first byte as soon as

789
00:26:50,400 --> 00:26:52,559
the peripheral acknowledges the address

790
00:26:52,559 --> 00:26:56,320
the stt bit is cleared so we can also

791
00:26:56,320 --> 00:26:57,840
watch that to see if

792
00:26:57,840 --> 00:26:59,600
the peripheral is acknowledging the

793
00:26:59,600 --> 00:27:01,760
address the data written into the

794
00:27:01,760 --> 00:27:03,440
transmit buffer is transmitted if

795
00:27:03,440 --> 00:27:04,559
arbitration is not

796
00:27:04,559 --> 00:27:06,880
lost which it won't happen because we're

797
00:27:06,880 --> 00:27:09,200
the only controller on the bus

798
00:27:09,200 --> 00:27:12,240
the transmit flag is set again as soon

799
00:27:12,240 --> 00:27:13,600
as the data is transferred from the

800
00:27:13,600 --> 00:27:15,600
buffer into the shift register

801
00:27:15,600 --> 00:27:19,200
so we can actually just keep writing

802
00:27:19,200 --> 00:27:21,200
bytes to that transmit buffer as soon as

803
00:27:21,200 --> 00:27:22,399
we see that flag

804
00:27:22,399 --> 00:27:26,159
set if we happen to take too long

805
00:27:26,159 --> 00:27:28,000
and there's no data loaded before the

806
00:27:28,000 --> 00:27:29,200
acknowledged cycle

807
00:27:29,200 --> 00:27:31,760
the bus is held so it'll actually hold

808
00:27:31,760 --> 00:27:34,000
the clock line low and wait for you to

809
00:27:34,000 --> 00:27:36,240
send the next byte which we want to

810
00:27:36,240 --> 00:27:39,120
avoid obviously

811
00:27:39,120 --> 00:27:40,960
setting the stop bit generates a stop

812
00:27:40,960 --> 00:27:43,600
condition after the next acknowledge

813
00:27:43,600 --> 00:27:46,080
or not acknowledge if it's set during

814
00:27:46,080 --> 00:27:47,360
the transmission of the

815
00:27:47,360 --> 00:27:49,840
address or while we're waiting for data

816
00:27:49,840 --> 00:27:51,679
to be written into the buffer a stop

817
00:27:51,679 --> 00:27:54,559
condition is generated immediately

818
00:27:54,559 --> 00:27:57,520
so this is sort of complex but this is

819
00:27:57,520 --> 00:28:00,840
an important thing to point out on the

820
00:28:00,840 --> 00:28:02,240
msp430

821
00:28:02,240 --> 00:28:04,640
even if we're only sending a single byte

822
00:28:04,640 --> 00:28:05,679
of data

823
00:28:05,679 --> 00:28:07,840
we need to set the stop bit while the

824
00:28:07,840 --> 00:28:09,440
byte is being transmitted

825
00:28:09,440 --> 00:28:11,279
otherwise it's going to try and

826
00:28:11,279 --> 00:28:12,799
immediately send another byte

827
00:28:12,799 --> 00:28:16,720
afterwards um otherwise only the address

828
00:28:16,720 --> 00:28:17,520
is transmitted

829
00:28:17,520 --> 00:28:18,880
when the data is transferred from the

830
00:28:18,880 --> 00:28:20,640
buffer into the shift register the flag

831
00:28:20,640 --> 00:28:21,840
is set

832
00:28:21,840 --> 00:28:24,640
um and then the stop bit may be set so

833
00:28:24,640 --> 00:28:26,399
you'll see in our code we have to handle

834
00:28:26,399 --> 00:28:28,159
that as a special case if we're only

835
00:28:28,159 --> 00:28:29,679
sending one byte

836
00:28:29,679 --> 00:28:31,520
basically as soon as we load the data

837
00:28:31,520 --> 00:28:33,200
into the transmit buffer we have to set

838
00:28:33,200 --> 00:28:35,440
the stop bit

839
00:28:35,440 --> 00:28:37,760
if the if it does not acknowledge the

840
00:28:37,760 --> 00:28:39,200
transmitted data then we

841
00:28:39,200 --> 00:28:41,840
get that knack flag set then we have to

842
00:28:41,840 --> 00:28:43,279
either send with a stop

843
00:28:43,279 --> 00:28:47,760
or a repeated start um if we get a knack

844
00:28:47,760 --> 00:28:49,200
and we've already written data into the

845
00:28:49,200 --> 00:28:51,120
transmit buffer it's discarded that's a

846
00:28:51,120 --> 00:28:52,960
good thing to know

847
00:28:52,960 --> 00:28:54,640
if this data should be transmitted after

848
00:28:54,640 --> 00:28:56,399
a repeated start it must be written into

849
00:28:56,399 --> 00:28:57,520
the buffer again

850
00:28:57,520 --> 00:29:00,559
so this is basically just

851
00:29:00,559 --> 00:29:03,279
very simple how the flow goes there's

852
00:29:03,279 --> 00:29:04,880
actually a flowchart here

853
00:29:04,880 --> 00:29:06,640
which can be handy to show you exactly

854
00:29:06,640 --> 00:29:08,399
what happens at each step

855
00:29:08,399 --> 00:29:10,159
which i've had to refer to when writing

856
00:29:10,159 --> 00:29:11,760
this code so

857
00:29:11,760 --> 00:29:13,120
that's just a quick overview of how it

858
00:29:13,120 --> 00:29:15,120
works on the msp430

859
00:29:15,120 --> 00:29:17,679
so as we just saw the process is going

860
00:29:17,679 --> 00:29:19,279
to be broadly similar on most

861
00:29:19,279 --> 00:29:20,640
microcontrollers

862
00:29:20,640 --> 00:29:23,440
ensure the peripheral address is loaded

863
00:29:23,440 --> 00:29:25,039
there will be a register bit to send a

864
00:29:25,039 --> 00:29:26,559
start condition

865
00:29:26,559 --> 00:29:28,960
as i said some chips will also send the

866
00:29:28,960 --> 00:29:30,640
peripheral address at the same time as

867
00:29:30,640 --> 00:29:31,520
the start

868
00:29:31,520 --> 00:29:33,120
others might require you to send it

869
00:29:33,120 --> 00:29:35,360
separately then you load each byte of

870
00:29:35,360 --> 00:29:37,840
data to be sent into the transmit buffer

871
00:29:37,840 --> 00:29:39,760
between each of these steps we check the

872
00:29:39,760 --> 00:29:41,919
flags so

873
00:29:41,919 --> 00:29:43,760
we check to see is it ready for the next

874
00:29:43,760 --> 00:29:45,440
byte was there a not acknowledge

875
00:29:45,440 --> 00:29:46,559
received

876
00:29:46,559 --> 00:29:47,840
and then we take different actions

877
00:29:47,840 --> 00:29:50,080
depending on that so if we actually go

878
00:29:50,080 --> 00:29:52,799
look at our basic code example

879
00:29:52,799 --> 00:29:54,559
this is after everything's been set up

880
00:29:54,559 --> 00:29:57,039
the first thing we do is we set the uctr

881
00:29:57,039 --> 00:29:57,440
bit

882
00:29:57,440 --> 00:29:59,520
so we're transmitting and we send the

883
00:29:59,520 --> 00:30:01,440
start so that's going to send

884
00:30:01,440 --> 00:30:04,080
a start condition followed by the

885
00:30:04,080 --> 00:30:06,240
peripheral address with the read write

886
00:30:06,240 --> 00:30:06,880
bit

887
00:30:06,880 --> 00:30:10,720
set to right which is a zero

888
00:30:10,720 --> 00:30:13,919
then we wait in this while loop until

889
00:30:13,919 --> 00:30:16,720
we can put the first byte of data into

890
00:30:16,720 --> 00:30:18,399
the transmit buffer

891
00:30:18,399 --> 00:30:20,640
as soon as that flag is ready it'll go

892
00:30:20,640 --> 00:30:22,080
on to the next line where we

893
00:30:22,080 --> 00:30:24,559
load the first byte in to the transmit

894
00:30:24,559 --> 00:30:26,960
buffer

895
00:30:27,760 --> 00:30:29,520
the reason we're sending that first byte

896
00:30:29,520 --> 00:30:33,039
outside of the for loop below is because

897
00:30:33,039 --> 00:30:35,200
we have to send that first byte to be

898
00:30:35,200 --> 00:30:36,960
able to check if an address knack

899
00:30:36,960 --> 00:30:38,520
happened this is another quirk of the

900
00:30:38,520 --> 00:30:40,080
msp430

901
00:30:40,080 --> 00:30:42,799
so we start sending that first byte then

902
00:30:42,799 --> 00:30:43,120
we

903
00:30:43,120 --> 00:30:45,360
check to see if the start condition

904
00:30:45,360 --> 00:30:46,399
completed

905
00:30:46,399 --> 00:30:48,080
you have to start complete if the start

906
00:30:48,080 --> 00:30:50,080
condition completed and we have a

907
00:30:50,080 --> 00:30:52,559
knack flag set that means that the

908
00:30:52,559 --> 00:30:53,440
peripheral

909
00:30:53,440 --> 00:30:55,840
did not acknowledge the address we sent

910
00:30:55,840 --> 00:30:58,080
we must immediately send a stop which we

911
00:30:58,080 --> 00:30:58,799
do

912
00:30:58,799 --> 00:31:00,080
and then we wait for the stop to

913
00:31:00,080 --> 00:31:02,080
complete and then we return from this

914
00:31:02,080 --> 00:31:04,559
function with an error code however if

915
00:31:04,559 --> 00:31:05,120
it

916
00:31:05,120 --> 00:31:06,799
does acknowledge the address then we go

917
00:31:06,799 --> 00:31:08,960
down to the next while loop here we wait

918
00:31:08,960 --> 00:31:10,799
for the buffer to be clear

919
00:31:10,799 --> 00:31:13,679
then from byte number one remember the

920
00:31:13,679 --> 00:31:15,440
first byte we sent was byte zero

921
00:31:15,440 --> 00:31:18,080
from byte one until however many bytes

922
00:31:18,080 --> 00:31:19,039
we're sending

923
00:31:19,039 --> 00:31:21,679
we loop through this little for loop we

924
00:31:21,679 --> 00:31:23,440
load the data into the buffer

925
00:31:23,440 --> 00:31:25,360
we wait for the buffer to be clear we

926
00:31:25,360 --> 00:31:27,840
check to see if we gotta not acknowledge

927
00:31:27,840 --> 00:31:30,320
from the data we sent if we gotta not

928
00:31:30,320 --> 00:31:31,039
acknowledge

929
00:31:31,039 --> 00:31:34,240
we send the stop bit and then we return

930
00:31:34,240 --> 00:31:35,440
from the function

931
00:31:35,440 --> 00:31:37,360
otherwise we just send all our data and

932
00:31:37,360 --> 00:31:38,799
then at the bottom we

933
00:31:38,799 --> 00:31:41,840
send the stop bit so pretty simple if

934
00:31:41,840 --> 00:31:43,360
you look at how many lines of code this

935
00:31:43,360 --> 00:31:45,919
is this is actively sending i squared c

936
00:31:45,919 --> 00:31:48,080
data using the hardware peripheral

937
00:31:48,080 --> 00:31:50,240
much smaller code than would be required

938
00:31:50,240 --> 00:31:54,000
to bit bang it or do it via gpio

939
00:31:54,000 --> 00:31:56,159
if we want to read some data it

940
00:31:56,159 --> 00:31:57,919
typically looks too

941
00:31:57,919 --> 00:32:00,720
similar to writing data we just read

942
00:32:00,720 --> 00:32:01,360
from the

943
00:32:01,360 --> 00:32:03,600
receiving buffer instead of writing to

944
00:32:03,600 --> 00:32:05,440
the transmit buffer

945
00:32:05,440 --> 00:32:07,200
that's a typo there it should say tx

946
00:32:07,200 --> 00:32:09,679
buff the msp 430 has

947
00:32:09,679 --> 00:32:11,120
a few quirks compared to other

948
00:32:11,120 --> 00:32:13,440
microcontrollers

949
00:32:13,440 --> 00:32:15,200
unlike most other microcontrollers like

950
00:32:15,200 --> 00:32:17,120
we just saw in the data sheet we must

951
00:32:17,120 --> 00:32:18,880
initiate sending the stop bit

952
00:32:18,880 --> 00:32:22,240
before reading the final byte um

953
00:32:22,240 --> 00:32:24,720
if we wait until after that it's going

954
00:32:24,720 --> 00:32:26,159
to read another byte

955
00:32:26,159 --> 00:32:29,279
which we may or may not want so

956
00:32:29,279 --> 00:32:31,840
there's another bug i'm trying to fix

957
00:32:31,840 --> 00:32:33,600
where for some reason

958
00:32:33,600 --> 00:32:36,240
we're missing a byte of data i fixed

959
00:32:36,240 --> 00:32:36,720
this by

960
00:32:36,720 --> 00:32:39,039
reading another byte of data past what

961
00:32:39,039 --> 00:32:41,360
we should need to read you'll see this

962
00:32:41,360 --> 00:32:43,039
in the code

963
00:32:43,039 --> 00:32:46,559
i'm still not sure what's causing this

964
00:32:46,559 --> 00:32:49,679
hopefully it's not a hardware issue but

965
00:32:49,679 --> 00:32:51,120
at least the code does work which is

966
00:32:51,120 --> 00:32:52,320
good so the same process

967
00:32:52,320 --> 00:32:54,880
as before send to start condition but

968
00:32:54,880 --> 00:32:56,320
this time the transmitter bit

969
00:32:56,320 --> 00:32:58,240
is off because we want to read from the

970
00:32:58,240 --> 00:33:01,200
device we start reading bytes from rx

971
00:33:01,200 --> 00:33:02,080
buff

972
00:33:02,080 --> 00:33:04,080
checking the byte received flag in

973
00:33:04,080 --> 00:33:05,760
between each byte

974
00:33:05,760 --> 00:33:07,200
when we've read the required number of

975
00:33:07,200 --> 00:33:09,519
bytes send a stop condition

976
00:33:09,519 --> 00:33:11,039
it's going to handle everything else for

977
00:33:11,039 --> 00:33:12,480
us it's going to handle sending the

978
00:33:12,480 --> 00:33:13,840
address to the peripheral

979
00:33:13,840 --> 00:33:15,360
it's going to handle generating the

980
00:33:15,360 --> 00:33:18,399
clock cycles and the acknowledge

981
00:33:18,399 --> 00:33:19,919
so let's look at the code example for

982
00:33:19,919 --> 00:33:22,000
this same thing

983
00:33:22,000 --> 00:33:25,519
essentially we clear the transmit byte

984
00:33:25,519 --> 00:33:29,440
bit uctr then we send a start so this

985
00:33:29,440 --> 00:33:31,360
will send the address with the

986
00:33:31,360 --> 00:33:34,480
read bit set so where it's the address

987
00:33:34,480 --> 00:33:37,039
for reading data we wait for the start

988
00:33:37,039 --> 00:33:38,480
condition to be completed

989
00:33:38,480 --> 00:33:40,240
and then we check to see if we got an

990
00:33:40,240 --> 00:33:42,159
acknowledge if we didn't get an

991
00:33:42,159 --> 00:33:44,000
acknowledge just like before we send a

992
00:33:44,000 --> 00:33:45,039
stop

993
00:33:45,039 --> 00:33:46,799
and then we return from the function

994
00:33:46,799 --> 00:33:49,600
with an error code knack address

995
00:33:49,600 --> 00:33:52,399
if it did acknowledge we wait until

996
00:33:52,399 --> 00:33:53,840
we're told we can

997
00:33:53,840 --> 00:33:55,600
read the first byte which is what that

998
00:33:55,600 --> 00:33:58,159
rx ifg flag does

999
00:33:58,159 --> 00:34:00,240
if we're only reading one byte remember

1000
00:34:00,240 --> 00:34:01,519
this weird quark

1001
00:34:01,519 --> 00:34:04,640
we have to immediately set the stop byte

1002
00:34:04,640 --> 00:34:06,559
stop bit sorry while the first byte is

1003
00:34:06,559 --> 00:34:09,520
being read if it's single byte only read

1004
00:34:09,520 --> 00:34:12,879
we set the stop bit we uh clear that

1005
00:34:12,879 --> 00:34:15,119
flag the transmit flag and then we read

1006
00:34:15,119 --> 00:34:17,040
the data out of the buffer

1007
00:34:17,040 --> 00:34:20,079
then we wait until the stop is completed

1008
00:34:20,079 --> 00:34:21,359
and we return success

1009
00:34:21,359 --> 00:34:22,960
so if we're just reading one byte it's

1010
00:34:22,960 --> 00:34:25,440
that simple otherwise

1011
00:34:25,440 --> 00:34:27,839
we go into a for loop doing the same

1012
00:34:27,839 --> 00:34:28,560
thing

1013
00:34:28,560 --> 00:34:32,079
if there's a special case here if we're

1014
00:34:32,079 --> 00:34:33,440
on the last byte

1015
00:34:33,440 --> 00:34:35,679
remember we have to set the stop bit

1016
00:34:35,679 --> 00:34:38,560
before we read the byte from the re

1017
00:34:38,560 --> 00:34:41,839
receive buffer so if we're

1018
00:34:41,839 --> 00:34:45,280
at the last byte

1019
00:34:45,280 --> 00:34:48,639
then we need to set the stop bit

1020
00:34:48,639 --> 00:34:51,199
read the bite of data and then wait for

1021
00:34:51,199 --> 00:34:52,719
the stop bit to complete

1022
00:34:52,719 --> 00:34:55,440
break out of the loop otherwise if it's

1023
00:34:55,440 --> 00:34:56,159
not

1024
00:34:56,159 --> 00:34:59,200
the last bite we just wait for the next

1025
00:34:59,200 --> 00:35:00,240
bite to come

1026
00:35:00,240 --> 00:35:02,000
read the bite and then go back to the

1027
00:35:02,000 --> 00:35:04,560
for loop at the end there you can see

1028
00:35:04,560 --> 00:35:08,560
dummy byte so if i remove that line of

1029
00:35:08,560 --> 00:35:09,280
code

1030
00:35:09,280 --> 00:35:11,839
we end up getting cut off and we don't

1031
00:35:11,839 --> 00:35:13,680
read the final byte

1032
00:35:13,680 --> 00:35:16,560
i don't know why this happens this

1033
00:35:16,560 --> 00:35:17,359
actually does

1034
00:35:17,359 --> 00:35:20,000
cause another bite to be written red

1035
00:35:20,000 --> 00:35:21,040
from the chip which

1036
00:35:21,040 --> 00:35:23,200
is just garbage that we throw away but

1037
00:35:23,200 --> 00:35:25,839
if we don't do this for some reason

1038
00:35:25,839 --> 00:35:28,640
it won't give us that last bite so just

1039
00:35:28,640 --> 00:35:30,640
an unusual quark i

1040
00:35:30,640 --> 00:35:33,920
not sure why but it does work

1041
00:35:33,920 --> 00:35:36,800
so let's actually go look at code

1042
00:35:36,800 --> 00:35:38,240
composer studio

1043
00:35:38,240 --> 00:35:40,640
and we'll take a sort of quick tour of

1044
00:35:40,640 --> 00:35:42,640
the full i squared c library that i've

1045
00:35:42,640 --> 00:35:43,040
read

1046
00:35:43,040 --> 00:35:45,920
that i've written okay so let's take a

1047
00:35:45,920 --> 00:35:46,880
close look

1048
00:35:46,880 --> 00:35:49,599
at the library i've written this is an

1049
00:35:49,599 --> 00:35:51,280
example code that you can download and

1050
00:35:51,280 --> 00:35:54,000
play with if you want

1051
00:35:54,000 --> 00:35:57,119
so i've implemented i squared c as a

1052
00:35:57,119 --> 00:35:58,079
class in c

1053
00:35:58,079 --> 00:36:00,640
plus plus so this first function here is

1054
00:36:00,640 --> 00:36:02,160
the constructor function

1055
00:36:02,160 --> 00:36:04,640
this is called when the user wants to

1056
00:36:04,640 --> 00:36:05,359
start

1057
00:36:05,359 --> 00:36:07,760
communication with an i squared c

1058
00:36:07,760 --> 00:36:09,119
peripheral

1059
00:36:09,119 --> 00:36:11,280
it gets passed in the speed that we want

1060
00:36:11,280 --> 00:36:12,320
it to run at

1061
00:36:12,320 --> 00:36:14,240
and it also gets sent the address of the

1062
00:36:14,240 --> 00:36:16,240
peripheral

1063
00:36:16,240 --> 00:36:18,800
we actually i actually wrote a little

1064
00:36:18,800 --> 00:36:20,240
bit of math here

1065
00:36:20,240 --> 00:36:22,640
that will calculate the baud rate for us

1066
00:36:22,640 --> 00:36:23,440
so

1067
00:36:23,440 --> 00:36:25,599
we can pass in 100 kilohertz 400

1068
00:36:25,599 --> 00:36:27,440
kilohertz whatever it'll take care of

1069
00:36:27,440 --> 00:36:29,280
calculating those baud rate registers

1070
00:36:29,280 --> 00:36:30,400
for us

1071
00:36:30,400 --> 00:36:33,680
um then as you can see we

1072
00:36:33,680 --> 00:36:36,960
make sure that the uh

1073
00:36:36,960 --> 00:36:38,480
i'm not actually sure why i have this

1074
00:36:38,480 --> 00:36:40,480
line in here but

1075
00:36:40,480 --> 00:36:43,440
we set the direction to be inputs for

1076
00:36:43,440 --> 00:36:44,800
some reason then we

1077
00:36:44,800 --> 00:36:48,480
set those two bits bit zero and bit one

1078
00:36:48,480 --> 00:36:53,839
to be sda and scl like we saw earlier

1079
00:36:53,839 --> 00:36:56,480
set the device into reset the i squared

1080
00:36:56,480 --> 00:36:58,000
c peripheral remember this is that

1081
00:36:58,000 --> 00:36:59,280
really important step

1082
00:36:59,280 --> 00:37:01,200
before we can change any of these

1083
00:37:01,200 --> 00:37:03,760
registers it needs to be in reset

1084
00:37:03,760 --> 00:37:05,359
just like the example code i showed on

1085
00:37:05,359 --> 00:37:08,079
the slide we set the ucmst

1086
00:37:08,079 --> 00:37:11,119
bit uc mode 3 which is i squared c

1087
00:37:11,119 --> 00:37:14,079
uc sync and the control 1 register we

1088
00:37:14,079 --> 00:37:14,560
select

1089
00:37:14,560 --> 00:37:17,119
sm clock and we make sure that the

1090
00:37:17,119 --> 00:37:18,480
software reset is still

1091
00:37:18,480 --> 00:37:22,480
set then we write in

1092
00:37:22,480 --> 00:37:25,200
the calculated baud rate which we

1093
00:37:25,200 --> 00:37:27,119
calculated up here

1094
00:37:27,119 --> 00:37:30,480
if we were given a peripheral address we

1095
00:37:30,480 --> 00:37:32,960
load that now if we weren't given a

1096
00:37:32,960 --> 00:37:34,480
peripheral address then we just ignore

1097
00:37:34,480 --> 00:37:35,599
it for now

1098
00:37:35,599 --> 00:37:37,359
then we bring it out of reset and we're

1099
00:37:37,359 --> 00:37:39,040
ready to go

1100
00:37:39,040 --> 00:37:42,400
now i've taken all the

1101
00:37:42,400 --> 00:37:45,200
i squared c transactions that you can do

1102
00:37:45,200 --> 00:37:46,880
and put them into a big function called

1103
00:37:46,880 --> 00:37:50,160
transact you pass it the data

1104
00:37:50,160 --> 00:37:52,079
how long the data is and then what type

1105
00:37:52,079 --> 00:37:54,160
of transaction you're doing

1106
00:37:54,160 --> 00:37:58,320
um so if we are writing

1107
00:37:58,320 --> 00:38:00,640
then it's just the code we saw earlier

1108
00:38:00,640 --> 00:38:02,480
we set the transmit bode

1109
00:38:02,480 --> 00:38:05,119
transmit mode bit as well as the start

1110
00:38:05,119 --> 00:38:05,599
bit

1111
00:38:05,599 --> 00:38:08,160
it sends the address and the start

1112
00:38:08,160 --> 00:38:09,680
condition

1113
00:38:09,680 --> 00:38:12,560
we send the data that we're writing we

1114
00:38:12,560 --> 00:38:13,839
check the flags for

1115
00:38:13,839 --> 00:38:16,160
not acknowledge um if we get a not

1116
00:38:16,160 --> 00:38:18,000
acknowledge we send the stop

1117
00:38:18,000 --> 00:38:20,400
we already saw and went through all this

1118
00:38:20,400 --> 00:38:22,640
same for the read

1119
00:38:22,640 --> 00:38:25,280
this is the code we just looked at we

1120
00:38:25,280 --> 00:38:25,839
make sure

1121
00:38:25,839 --> 00:38:28,480
transmitter mode is clear we send a

1122
00:38:28,480 --> 00:38:30,079
start condition

1123
00:38:30,079 --> 00:38:31,839
uh we wait for the start condition to be

1124
00:38:31,839 --> 00:38:34,480
complete and then we

1125
00:38:34,480 --> 00:38:36,079
read that dummy bite at the end i also

1126
00:38:36,079 --> 00:38:37,599
have a combination one

1127
00:38:37,599 --> 00:38:40,480
where this is often what happens when

1128
00:38:40,480 --> 00:38:42,000
you're communicating with a peripheral

1129
00:38:42,000 --> 00:38:42,960
you need to write

1130
00:38:42,960 --> 00:38:45,440
a single byte and then read many bytes

1131
00:38:45,440 --> 00:38:47,359
so i've combined that into one function

1132
00:38:47,359 --> 00:38:48,800
which is nice

1133
00:38:48,800 --> 00:38:51,440
um actually it could be more than one so

1134
00:38:51,440 --> 00:38:51,920
we might

1135
00:38:51,920 --> 00:38:55,280
write a few bytes and then read a few

1136
00:38:55,280 --> 00:38:57,920
bytes back

1137
00:38:57,920 --> 00:38:59,359
which makes it handy and then i also

1138
00:38:59,359 --> 00:39:00,960
have a test mode

1139
00:39:00,960 --> 00:39:02,960
this is just a little function i wrote

1140
00:39:02,960 --> 00:39:04,079
it's actually

1141
00:39:04,079 --> 00:39:07,359
a linear feedback shift register which

1142
00:39:07,359 --> 00:39:09,040
essentially just generates all the

1143
00:39:09,040 --> 00:39:11,119
values between 0 and 255

1144
00:39:11,119 --> 00:39:13,280
in a random order and sends them over

1145
00:39:13,280 --> 00:39:14,640
and over and over again

1146
00:39:14,640 --> 00:39:16,320
this is what i use if i'm debugging if

1147
00:39:16,320 --> 00:39:18,079
something's going wrong

1148
00:39:18,079 --> 00:39:20,800
i can enter test mode and then take a

1149
00:39:20,800 --> 00:39:21,760
look at the actual

1150
00:39:21,760 --> 00:39:25,520
sda and scl lines and then i have an

1151
00:39:25,520 --> 00:39:27,280
another function down here change

1152
00:39:27,280 --> 00:39:30,320
address we pass it the address we want

1153
00:39:30,320 --> 00:39:32,720
and it will just write that into that

1154
00:39:32,720 --> 00:39:34,400
register for us

1155
00:39:34,400 --> 00:39:37,359
so pretty simple right now if we want to

1156
00:39:37,359 --> 00:39:38,800
actually use this to communicate with

1157
00:39:38,800 --> 00:39:41,599
something like an sht21

1158
00:39:41,599 --> 00:39:45,440
then we

1159
00:39:45,440 --> 00:39:47,680
write another class in c plus at least

1160
00:39:47,680 --> 00:39:49,599
this is how i implemented it

1161
00:39:49,599 --> 00:39:52,960
so the sht21

1162
00:39:52,960 --> 00:39:56,560
can get temperature or humidity

1163
00:39:56,560 --> 00:39:58,320
i'm not going to go into all the details

1164
00:39:58,320 --> 00:39:59,839
of how this chip works

1165
00:39:59,839 --> 00:40:03,280
but this is how we use this library that

1166
00:40:03,280 --> 00:40:04,640
i've written

1167
00:40:04,640 --> 00:40:08,079
so we store well if we actually look at

1168
00:40:08,079 --> 00:40:11,200
the main

1169
00:40:11,200 --> 00:40:14,319
we create an i squared c bus using that

1170
00:40:14,319 --> 00:40:16,240
constructor function running at 400

1171
00:40:16,240 --> 00:40:17,599
kilohertz

1172
00:40:17,599 --> 00:40:20,720
then we actually have an sht21 and then

1173
00:40:20,720 --> 00:40:23,280
we also have a bmp-180

1174
00:40:23,280 --> 00:40:25,839
both of these get past a reference to

1175
00:40:25,839 --> 00:40:27,359
that i squared c bus so that they can

1176
00:40:27,359 --> 00:40:27,680
both

1177
00:40:27,680 --> 00:40:30,319
use the same bus so if we actually look

1178
00:40:30,319 --> 00:40:31,040
at these

1179
00:40:31,040 --> 00:40:33,359
that bus that it gets passed gets stored

1180
00:40:33,359 --> 00:40:34,960
into a variable called bus

1181
00:40:34,960 --> 00:40:37,680
access this is just a way for this class

1182
00:40:37,680 --> 00:40:38,000
to

1183
00:40:38,000 --> 00:40:40,480
access that i squared c bus don't worry

1184
00:40:40,480 --> 00:40:42,160
about these details if you've never used

1185
00:40:42,160 --> 00:40:43,680
c plus plus before

1186
00:40:43,680 --> 00:40:45,359
what's important here is if we look at

1187
00:40:45,359 --> 00:40:48,079
the actual get temp function

1188
00:40:48,079 --> 00:40:51,280
we allocate a buffer of 10 10 bytes

1189
00:40:51,280 --> 00:40:53,119
which is probably more than we need

1190
00:40:53,119 --> 00:40:55,040
then we call that change address

1191
00:40:55,040 --> 00:40:57,359
function to set it to the sht

1192
00:40:57,359 --> 00:41:00,400
21 address which is actually defined in

1193
00:41:00,400 --> 00:41:02,560
the header file right here

1194
00:41:02,560 --> 00:41:06,640
sht 21 address is 0 by 40.

1195
00:41:06,640 --> 00:41:10,079
after that we send the trigger temp

1196
00:41:10,079 --> 00:41:13,119
command which is f3 that triggers a

1197
00:41:13,119 --> 00:41:15,119
temperature measurement

1198
00:41:15,119 --> 00:41:18,000
we call that transact function with the

1199
00:41:18,000 --> 00:41:19,040
buffer

1200
00:41:19,040 --> 00:41:22,640
as the argument we want to write one

1201
00:41:22,640 --> 00:41:26,319
byte so it writes that one byte out

1202
00:41:26,319 --> 00:41:29,400
then there's a unique feature of the

1203
00:41:29,400 --> 00:41:31,040
sht21

1204
00:41:31,040 --> 00:41:33,520
as it's converting the temperature if

1205
00:41:33,520 --> 00:41:34,079
you try

1206
00:41:34,079 --> 00:41:36,400
and read from it it will just send you

1207
00:41:36,400 --> 00:41:38,240
not acknowledges to the address

1208
00:41:38,240 --> 00:41:41,680
so what we do is we try and read the

1209
00:41:41,680 --> 00:41:43,520
three bytes from it

1210
00:41:43,520 --> 00:41:45,920
if it doesn't work for example it

1211
00:41:45,920 --> 00:41:46,800
returns

1212
00:41:46,800 --> 00:41:51,280
knack address we wait 15 000 cycles

1213
00:41:51,280 --> 00:41:52,960
then we try again we just keep doing

1214
00:41:52,960 --> 00:41:55,599
this until we get those three bytes

1215
00:41:55,599 --> 00:41:57,359
once we have those three bytes that's

1216
00:41:57,359 --> 00:41:59,040
the raw temperature data

1217
00:41:59,040 --> 00:42:01,200
as well as a checksum which we're not

1218
00:42:01,200 --> 00:42:02,640
going to use

1219
00:42:02,640 --> 00:42:05,599
we use the formula from the sht data

1220
00:42:05,599 --> 00:42:07,119
sheet to calculate the temperature and

1221
00:42:07,119 --> 00:42:09,040
then we return the temperature

1222
00:42:09,040 --> 00:42:11,280
so actually using our i squared z

1223
00:42:11,280 --> 00:42:12,960
library in

1224
00:42:12,960 --> 00:42:15,119
a function is quite simple we just call

1225
00:42:15,119 --> 00:42:17,040
change address to set the address we

1226
00:42:17,040 --> 00:42:18,000
want

1227
00:42:18,000 --> 00:42:20,960
and then we use the transact function to

1228
00:42:20,960 --> 00:42:21,680
write

1229
00:42:21,680 --> 00:42:24,800
or to read data it's pretty simple it's

1230
00:42:24,800 --> 00:42:27,119
the exact same thing for humidity

1231
00:42:27,119 --> 00:42:28,880
the only difference is we're sending the

1232
00:42:28,880 --> 00:42:31,440
trigger humidity measurement

1233
00:42:31,440 --> 00:42:34,720
byte we do the same thing we read three

1234
00:42:34,720 --> 00:42:36,560
bytes from it and then we calculate the

1235
00:42:36,560 --> 00:42:37,599
humidity

1236
00:42:37,599 --> 00:42:39,200
there's also functions here to turn the

1237
00:42:39,200 --> 00:42:41,040
heater on and off which

1238
00:42:41,040 --> 00:42:42,839
aren't actually used in this example

1239
00:42:42,839 --> 00:42:45,520
code

1240
00:42:45,520 --> 00:42:47,760
but i've done all this as c plus plus

1241
00:42:47,760 --> 00:42:50,000
because it makes it really easy to

1242
00:42:50,000 --> 00:42:53,200
break all these things into pieces where

1243
00:42:53,200 --> 00:42:54,880
we can have the i squared c library and

1244
00:42:54,880 --> 00:42:56,160
then that library can be

1245
00:42:56,160 --> 00:42:58,240
shared by different chips that are on

1246
00:42:58,240 --> 00:42:59,520
the bus

1247
00:42:59,520 --> 00:43:01,200
it just makes a lot easier so that's

1248
00:43:01,200 --> 00:43:03,520
just a quick overview all this code will

1249
00:43:03,520 --> 00:43:05,359
be posted

1250
00:43:05,359 --> 00:43:06,800
when we do the question and answer

1251
00:43:06,800 --> 00:43:08,400
session i expect there's going to be a

1252
00:43:08,400 --> 00:43:11,119
lot of questions about things

1253
00:43:11,119 --> 00:43:13,119
if you have questions about c plus plus

1254
00:43:13,119 --> 00:43:15,200
syntax or c syntax

1255
00:43:15,200 --> 00:43:18,160
um you can send those to me personally

1256
00:43:18,160 --> 00:43:19,440
through twitter or

1257
00:43:19,440 --> 00:43:21,040
by emailing me and i'll be happy to

1258
00:43:21,040 --> 00:43:22,800
explain things to you

1259
00:43:22,800 --> 00:43:24,400
but if you have questions specifically

1260
00:43:24,400 --> 00:43:26,480
about i squared c and about implementing

1261
00:43:26,480 --> 00:43:27,040
it then

1262
00:43:27,040 --> 00:43:28,640
ask those in the question and answer

1263
00:43:28,640 --> 00:43:30,480
session so

1264
00:43:30,480 --> 00:43:32,000
putting it to work we want to actually

1265
00:43:32,000 --> 00:43:33,839
communicate with something this is that

1266
00:43:33,839 --> 00:43:36,560
sht21 example i looked at

1267
00:43:36,560 --> 00:43:38,240
so whenever you're working with a new

1268
00:43:38,240 --> 00:43:40,000
sensor the most important thing to do is

1269
00:43:40,000 --> 00:43:42,480
to study the important parts of a data

1270
00:43:42,480 --> 00:43:44,480
sheet carefully

1271
00:43:44,480 --> 00:43:46,880
we want to know specifically the things

1272
00:43:46,880 --> 00:43:48,640
we're looking for in the data sheet for

1273
00:43:48,640 --> 00:43:50,240
a part we're working with

1274
00:43:50,240 --> 00:43:52,160
we want to know what the address of that

1275
00:43:52,160 --> 00:43:53,680
peripheral is

1276
00:43:53,680 --> 00:43:56,480
what its register map is so what

1277
00:43:56,480 --> 00:43:58,160
internal registers it have

1278
00:43:58,160 --> 00:44:01,200
and has and what bits get read and

1279
00:44:01,200 --> 00:44:03,760
written to them

1280
00:44:03,760 --> 00:44:05,680
and this is a skill you'll develop over

1281
00:44:05,680 --> 00:44:07,200
time you'll start to learn what the

1282
00:44:07,200 --> 00:44:09,359
essential pieces of data you need

1283
00:44:09,359 --> 00:44:13,040
are because often you can ignore

1284
00:44:13,040 --> 00:44:14,800
big chunks of a data sheet if you know

1285
00:44:14,800 --> 00:44:16,319
what you're looking for

1286
00:44:16,319 --> 00:44:18,560
so let's take a look at the sht21

1287
00:44:18,560 --> 00:44:19,680
datasheet

1288
00:44:19,680 --> 00:44:22,000
and we'll note down important parts so

1289
00:44:22,000 --> 00:44:24,640
let's go dive into it

1290
00:44:24,640 --> 00:44:26,880
okay so we're just going to take a quick

1291
00:44:26,880 --> 00:44:29,359
look at the sht21 datasheet we're not

1292
00:44:29,359 --> 00:44:30,880
going to go into the detail of how this

1293
00:44:30,880 --> 00:44:31,920
particular chip

1294
00:44:31,920 --> 00:44:34,319
works we're just going to show what it

1295
00:44:34,319 --> 00:44:35,599
is you need to look for when you're

1296
00:44:35,599 --> 00:44:36,880
working with an i squared c

1297
00:44:36,880 --> 00:44:39,119
device so it's going to give you an

1298
00:44:39,119 --> 00:44:40,720
explanation of the chip

1299
00:44:40,720 --> 00:44:42,319
um it's going to show you the you know

1300
00:44:42,319 --> 00:44:44,640
dimensions of the chip and how it works

1301
00:44:44,640 --> 00:44:46,400
what we're interested in you know it's

1302
00:44:46,400 --> 00:44:47,680
going to show you all the performance of

1303
00:44:47,680 --> 00:44:48,640
the sensor

1304
00:44:48,640 --> 00:44:50,880
and operating range and all the

1305
00:44:50,880 --> 00:44:52,400
different temperatures and how it

1306
00:44:52,400 --> 00:44:54,480
affects its accuracy

1307
00:44:54,480 --> 00:44:55,920
what we're interested in is the i

1308
00:44:55,920 --> 00:44:57,599
squared c

1309
00:44:57,599 --> 00:45:00,400
bus so oh it looks like we're getting

1310
00:45:00,400 --> 00:45:03,440
close communication with the sensor

1311
00:45:03,440 --> 00:45:06,160
explaining how i squared c works aha

1312
00:45:06,160 --> 00:45:09,040
here is a table of all the commands

1313
00:45:09,040 --> 00:45:11,200
so we can trigger the temperature

1314
00:45:11,200 --> 00:45:13,119
measurement trigger relative humidity

1315
00:45:13,119 --> 00:45:14,480
measurement

1316
00:45:14,480 --> 00:45:17,119
these different hold and no hold these

1317
00:45:17,119 --> 00:45:18,400
will either

1318
00:45:18,400 --> 00:45:21,680
hold the bus low making

1319
00:45:21,680 --> 00:45:24,800
us wait for it to finish or the no hold

1320
00:45:24,800 --> 00:45:26,480
version is what we use

1321
00:45:26,480 --> 00:45:28,880
where we let it do its measurement and

1322
00:45:28,880 --> 00:45:30,640
we just occasionally check to see if

1323
00:45:30,640 --> 00:45:32,560
it's finished by checking to see whether

1324
00:45:32,560 --> 00:45:36,078
it acknowledges its address

1325
00:45:36,560 --> 00:45:38,720
it's interesting that it doesn't

1326
00:45:38,720 --> 00:45:40,800
actually give you the address anywhere

1327
00:45:40,800 --> 00:45:42,640
often data sheets do this it's really

1328
00:45:42,640 --> 00:45:46,000
odd but in these examples you can see

1329
00:45:46,000 --> 00:45:49,920
it shows you let me zoom in on this

1330
00:45:49,920 --> 00:45:53,359
the i squared c address oop plus right

1331
00:45:53,359 --> 00:45:56,160
so which is one zero zero zero zero zero

1332
00:45:56,160 --> 00:45:57,359
zero zero which is eight

1333
00:45:57,359 --> 00:46:00,240
zero and then here's the address plus

1334
00:46:00,240 --> 00:46:00,800
read

1335
00:46:00,800 --> 00:46:04,240
eight and then a one so we can figure

1336
00:46:04,240 --> 00:46:06,480
out from that that the seven bit address

1337
00:46:06,480 --> 00:46:09,359
is zero by four zero it's interesting

1338
00:46:09,359 --> 00:46:09,920
that

1339
00:46:09,920 --> 00:46:12,079
it doesn't just say that somewhere i

1340
00:46:12,079 --> 00:46:13,440
found that a lot of

1341
00:46:13,440 --> 00:46:16,230
i squared c chips are like this

1342
00:46:16,230 --> 00:46:17,760
[Music]

1343
00:46:17,760 --> 00:46:20,400
they just won't give you the address

1344
00:46:20,400 --> 00:46:22,240
straight out anywhere

1345
00:46:22,240 --> 00:46:25,119
it'll be in the examples sometimes it'll

1346
00:46:25,119 --> 00:46:26,640
give it to you

1347
00:46:26,640 --> 00:46:28,720
but often not and then here are the

1348
00:46:28,720 --> 00:46:30,960
formulas that i use to actually

1349
00:46:30,960 --> 00:46:34,079
convert those raw data uh from the

1350
00:46:34,079 --> 00:46:36,480
registers into the relative humidity

1351
00:46:36,480 --> 00:46:39,440
and into temperature so this is a pretty

1352
00:46:39,440 --> 00:46:40,400
simple chip

1353
00:46:40,400 --> 00:46:44,720
all we have to do is send one of these

1354
00:46:44,720 --> 00:46:47,680
measurement codes so we write these

1355
00:46:47,680 --> 00:46:48,960
bytes on the i squared c

1356
00:46:48,960 --> 00:46:52,880
bus and then we read three bytes back

1357
00:46:52,880 --> 00:46:55,200
so you can see here this is this chart

1358
00:46:55,200 --> 00:46:56,800
over on the right this is how i

1359
00:46:56,800 --> 00:47:01,520
implemented it i'm so used to shift

1360
00:47:01,520 --> 00:47:05,599
scroll moving to the left and right

1361
00:47:05,839 --> 00:47:08,000
so we send the address on the right we

1362
00:47:08,000 --> 00:47:09,680
send the command

1363
00:47:09,680 --> 00:47:12,560
we wait 20 microseconds we send stop

1364
00:47:12,560 --> 00:47:14,480
that's how i've implemented it it starts

1365
00:47:14,480 --> 00:47:15,520
measuring

1366
00:47:15,520 --> 00:47:17,839
then a little while later we try and

1367
00:47:17,839 --> 00:47:19,920
send the i squared c address plus the

1368
00:47:19,920 --> 00:47:20,640
read bit

1369
00:47:20,640 --> 00:47:23,200
it responds with a not acknowledge this

1370
00:47:23,200 --> 00:47:25,200
is this means that it's not finished

1371
00:47:25,200 --> 00:47:27,359
measuring yet we wait another little

1372
00:47:27,359 --> 00:47:28,800
while we try again

1373
00:47:28,800 --> 00:47:30,559
this time we get an acknowledge okay

1374
00:47:30,559 --> 00:47:32,319
good we can read the data

1375
00:47:32,319 --> 00:47:34,400
you can see it reads the two data bytes

1376
00:47:34,400 --> 00:47:35,839
out and as well as the

1377
00:47:35,839 --> 00:47:38,559
checksum uh this is how i've chosen to

1378
00:47:38,559 --> 00:47:39,359
implement it

1379
00:47:39,359 --> 00:47:41,359
the other way to implement it with this

1380
00:47:41,359 --> 00:47:43,280
particular channel is it actually

1381
00:47:43,280 --> 00:47:45,200
will hold the bus low during the

1382
00:47:45,200 --> 00:47:46,880
measurement and then it'll send you the

1383
00:47:46,880 --> 00:47:48,400
three data bytes once it's finished

1384
00:47:48,400 --> 00:47:49,280
measuring

1385
00:47:49,280 --> 00:47:51,760
that ties up the bus there's reasons why

1386
00:47:51,760 --> 00:47:53,680
you might want to do it that way

1387
00:47:53,680 --> 00:47:55,839
to get the result as soon as possible

1388
00:47:55,839 --> 00:47:56,720
but

1389
00:47:56,720 --> 00:47:58,240
it doesn't really matter too much the

1390
00:47:58,240 --> 00:47:59,920
important things i want you to note from

1391
00:47:59,920 --> 00:48:01,520
this data sheet

1392
00:48:01,520 --> 00:48:04,079
is that you need to find these important

1393
00:48:04,079 --> 00:48:05,440
things you need to find

1394
00:48:05,440 --> 00:48:07,520
if it takes commands you need to find a

1395
00:48:07,520 --> 00:48:08,960
list of the commands

1396
00:48:08,960 --> 00:48:12,000
if it has registers like this also does

1397
00:48:12,000 --> 00:48:13,920
down here it explains what the user

1398
00:48:13,920 --> 00:48:15,280
register actually does

1399
00:48:15,280 --> 00:48:17,680
you can change the resolution of the

1400
00:48:17,680 --> 00:48:18,640
measurements

1401
00:48:18,640 --> 00:48:20,319
it'll tell you if it's running off of

1402
00:48:20,319 --> 00:48:21,920
battery life if the battery is getting

1403
00:48:21,920 --> 00:48:23,200
low

1404
00:48:23,200 --> 00:48:25,200
you can enable the on-chip heater

1405
00:48:25,200 --> 00:48:26,319
there's other things so

1406
00:48:26,319 --> 00:48:27,839
these are the important things you're

1407
00:48:27,839 --> 00:48:31,119
looking for as you can see it also has a

1408
00:48:31,119 --> 00:48:34,079
soft reset command we could actually

1409
00:48:34,079 --> 00:48:35,680
send that

1410
00:48:35,680 --> 00:48:39,200
after initializing the chip in the

1411
00:48:39,200 --> 00:48:42,400
constructor function for the sht21

1412
00:48:42,400 --> 00:48:44,240
i think i may actually do that in my

1413
00:48:44,240 --> 00:48:46,480
code

1414
00:48:46,480 --> 00:48:48,319
and then it shows here examples of how

1415
00:48:48,319 --> 00:48:50,160
to actually read and write to the

1416
00:48:50,160 --> 00:48:52,319
user register it also shows how to use

1417
00:48:52,319 --> 00:48:54,000
the crc checksum

1418
00:48:54,000 --> 00:48:56,640
if you're do using some sort of uh

1419
00:48:56,640 --> 00:48:57,680
application where

1420
00:48:57,680 --> 00:49:00,640
it's high reliability and it needs to be

1421
00:49:00,640 --> 00:49:02,319
sure the data is correct

1422
00:49:02,319 --> 00:49:03,839
then you would implement the crc

1423
00:49:03,839 --> 00:49:06,160
checksum if you're just doing something

1424
00:49:06,160 --> 00:49:07,359
simple like we're doing

1425
00:49:07,359 --> 00:49:08,960
you can just ignore the checksum and

1426
00:49:08,960 --> 00:49:10,800
just assume that the data is correct

1427
00:49:10,800 --> 00:49:13,040
because it's unlikely to be corrupted

1428
00:49:13,040 --> 00:49:14,880
on a bus as small as what we're doing

1429
00:49:14,880 --> 00:49:17,200
and this is all you need to know

1430
00:49:17,200 --> 00:49:21,440
uh most data sheets for i squared c

1431
00:49:21,440 --> 00:49:22,960
devices will actually have a whole

1432
00:49:22,960 --> 00:49:25,520
section explaining how i squared c works

1433
00:49:25,520 --> 00:49:27,839
it'll show you you know what all the

1434
00:49:27,839 --> 00:49:30,079
timings are how start and stop sequences

1435
00:49:30,079 --> 00:49:31,839
work so if you forget anything it's kind

1436
00:49:31,839 --> 00:49:33,599
of nice they have a reminder in here of

1437
00:49:33,599 --> 00:49:35,200
how the basics work

1438
00:49:35,200 --> 00:49:37,040
it shows you the different speeds it can

1439
00:49:37,040 --> 00:49:38,960
support see it can support up to 400

1440
00:49:38,960 --> 00:49:41,359
kilohertz

1441
00:49:41,359 --> 00:49:42,800
it gives you all the different times for

1442
00:49:42,800 --> 00:49:45,359
how long you have to hold each

1443
00:49:45,359 --> 00:49:47,680
thing high or low this would be useful

1444
00:49:47,680 --> 00:49:48,720
if you're writing

1445
00:49:48,720 --> 00:49:50,319
a bit bang version and you need to know

1446
00:49:50,319 --> 00:49:52,000
the exact timings so

1447
00:49:52,000 --> 00:49:54,480
basically you just need to find the

1448
00:49:54,480 --> 00:49:56,240
important data in the data sheet and you

1449
00:49:56,240 --> 00:49:58,640
can essentially ignore the rest

1450
00:49:58,640 --> 00:49:59,760
if you're just implementing something

1451
00:49:59,760 --> 00:50:01,520
simple like we are so let's go back to

1452
00:50:01,520 --> 00:50:04,720
the slides and finish up

1453
00:50:11,280 --> 00:50:14,400
so notes on the sht21 the most important

1454
00:50:14,400 --> 00:50:15,599
pieces of information

1455
00:50:15,599 --> 00:50:16,960
just like when you're working with any

1456
00:50:16,960 --> 00:50:19,520
chip address is zero by four zero

1457
00:50:19,520 --> 00:50:22,720
five commands we might wanna use trigger

1458
00:50:22,720 --> 00:50:23,040
temp

1459
00:50:23,040 --> 00:50:24,559
trigger human write and read the

1460
00:50:24,559 --> 00:50:26,160
register soft reset

1461
00:50:26,160 --> 00:50:27,680
after sending a trigger command we

1462
00:50:27,680 --> 00:50:29,760
simply keep issuing reads

1463
00:50:29,760 --> 00:50:31,520
as we saw it'll knack the address if

1464
00:50:31,520 --> 00:50:32,960
it's not ready

1465
00:50:32,960 --> 00:50:35,119
note the formulas that we use to convert

1466
00:50:35,119 --> 00:50:36,800
the raw values into actual temperature

1467
00:50:36,800 --> 00:50:38,079
and humidity values

1468
00:50:38,079 --> 00:50:42,000
and then we this is a summary of the

1469
00:50:42,000 --> 00:50:43,440
code that we just looked at not that

1470
00:50:43,440 --> 00:50:45,280
long ago

1471
00:50:45,280 --> 00:50:47,839
we create a buffer for the values we

1472
00:50:47,839 --> 00:50:49,920
send the humidity trigger command

1473
00:50:49,920 --> 00:50:51,760
we then try and read from the chip it's

1474
00:50:51,760 --> 00:50:54,400
going to send not acknowledges we repeat

1475
00:50:54,400 --> 00:50:55,920
this until we get an acknowledge

1476
00:50:55,920 --> 00:50:58,880
read the three bytes we put those first

1477
00:50:58,880 --> 00:51:00,319
two bytes which are the important ones

1478
00:51:00,319 --> 00:51:02,160
into a 16 bit integer

1479
00:51:02,160 --> 00:51:05,280
then we calculate the humidity and then

1480
00:51:05,280 --> 00:51:06,800
we can do whatever we want with that we

1481
00:51:06,800 --> 00:51:08,559
could print it out to the user

1482
00:51:08,559 --> 00:51:11,839
we could send it to the cloud the code

1483
00:51:11,839 --> 00:51:12,559
example

1484
00:51:12,559 --> 00:51:15,520
this is what we looked at before we

1485
00:51:15,520 --> 00:51:17,040
create a buffer

1486
00:51:17,040 --> 00:51:19,680
we set the address to the sht 21 address

1487
00:51:19,680 --> 00:51:21,119
trigger community we already went over

1488
00:51:21,119 --> 00:51:22,480
this

1489
00:51:22,480 --> 00:51:24,559
one we're at the at the end there you

1490
00:51:24,559 --> 00:51:26,559
can see it returns the humidity as a

1491
00:51:26,559 --> 00:51:27,200
double

1492
00:51:27,200 --> 00:51:30,079
so once that's returned uh reading

1493
00:51:30,079 --> 00:51:31,119
temperature

1494
00:51:31,119 --> 00:51:33,359
the only difference is the actual

1495
00:51:33,359 --> 00:51:34,640
command code we already sort of went

1496
00:51:34,640 --> 00:51:36,240
over this

1497
00:51:36,240 --> 00:51:37,920
uh the code example for getting the

1498
00:51:37,920 --> 00:51:39,520
temperature is the same the only

1499
00:51:39,520 --> 00:51:40,400
difference is

1500
00:51:40,400 --> 00:51:41,760
the formula for calculating the

1501
00:51:41,760 --> 00:51:44,400
temperature we already sort of looked at

1502
00:51:44,400 --> 00:51:47,040
the full sht21 library so we can skip

1503
00:51:47,040 --> 00:51:47,599
over that

1504
00:51:47,599 --> 00:51:49,280
now let's actually do something with the

1505
00:51:49,280 --> 00:51:51,599
data so the simplest thing we can do is

1506
00:51:51,599 --> 00:51:53,040
just display them

1507
00:51:53,040 --> 00:51:56,160
to the end user over a serial link

1508
00:51:56,160 --> 00:51:57,599
we won't be getting into how to actually

1509
00:51:57,599 --> 00:51:59,599
set up the serial link but

1510
00:51:59,599 --> 00:52:02,720
we will be using a timer interrupt to

1511
00:52:02,720 --> 00:52:04,000
put the processor to sleep when

1512
00:52:04,000 --> 00:52:05,760
it wakes up it'll sample the humidity

1513
00:52:05,760 --> 00:52:08,400
and temperature send it to the end user

1514
00:52:08,400 --> 00:52:12,079
so let's go take a look at that main

1515
00:52:12,079 --> 00:52:14,079
function again

1516
00:52:14,079 --> 00:52:16,160
all right and then to finish off we're

1517
00:52:16,160 --> 00:52:17,599
just gonna actually do something with

1518
00:52:17,599 --> 00:52:19,119
this data so we'll take a quick look at

1519
00:52:19,119 --> 00:52:20,720
this function i wrote

1520
00:52:20,720 --> 00:52:22,720
up here is all the stuff setting up the

1521
00:52:22,720 --> 00:52:23,920
clock and whatnot

1522
00:52:23,920 --> 00:52:26,559
this is all specific to the msp430 and

1523
00:52:26,559 --> 00:52:28,000
so it's not really relevant to this

1524
00:52:28,000 --> 00:52:30,400
lesson

1525
00:52:30,400 --> 00:52:33,359
we create the i squared c bus and we

1526
00:52:33,359 --> 00:52:36,559
pass it into the sht library i wrote

1527
00:52:36,559 --> 00:52:40,880
we also create a uart at 115 200

1528
00:52:40,880 --> 00:52:45,359
and then a timer that will actually

1529
00:52:45,359 --> 00:52:48,000
trigger every now and then eventually we

1530
00:52:48,000 --> 00:52:48,720
get down

1531
00:52:48,720 --> 00:52:51,520
into this while loop where it gets the

1532
00:52:51,520 --> 00:52:54,400
humidity and it gets the temperature

1533
00:52:54,400 --> 00:52:56,960
and then it prints them it formats them

1534
00:52:56,960 --> 00:52:57,520
into this

1535
00:52:57,520 --> 00:53:00,079
string buffer and then it prints it to

1536
00:53:00,079 --> 00:53:00,880
the screen

1537
00:53:00,880 --> 00:53:04,240
we start the timer we go to sleep it

1538
00:53:04,240 --> 00:53:05,839
waits until the timer triggers and then

1539
00:53:05,839 --> 00:53:07,599
it does it again it works out to every

1540
00:53:07,599 --> 00:53:09,040
few seconds

1541
00:53:09,040 --> 00:53:12,480
so make sure we're actually recording

1542
00:53:12,480 --> 00:53:14,480
this yep all right

1543
00:53:14,480 --> 00:53:17,599
let's actually run this

1544
00:53:17,599 --> 00:53:19,839
chip

1545
00:53:20,880 --> 00:53:24,400
so we'll go into debug mode

1546
00:53:24,800 --> 00:53:26,559
so i've actually got the board here set

1547
00:53:26,559 --> 00:53:28,000
up with the

1548
00:53:28,000 --> 00:53:31,440
sensorhub booster pack okay so we're

1549
00:53:31,440 --> 00:53:33,200
actually going to start the debug here

1550
00:53:33,200 --> 00:53:37,040
of this example that i wrote

1551
00:53:37,040 --> 00:53:39,440
we've got a terminal here open to the

1552
00:53:39,440 --> 00:53:40,400
serial port

1553
00:53:40,400 --> 00:53:45,280
of the chip and so when i hit start

1554
00:53:45,680 --> 00:53:47,520
you can see it's measuring the humidity

1555
00:53:47,520 --> 00:53:49,599
there's a sweltering 67

1556
00:53:49,599 --> 00:53:51,520
right now the temperature is about 25

1557
00:53:51,520 --> 00:53:53,359
degrees that's why you can see a bit of

1558
00:53:53,359 --> 00:53:54,319
a

1559
00:53:54,319 --> 00:53:56,800
sheen on my forehead uh and it's gonna

1560
00:53:56,800 --> 00:53:58,240
update this as you can see

1561
00:53:58,240 --> 00:54:02,079
every five or six seconds um

1562
00:54:02,079 --> 00:54:04,480
and that's pretty simple i mean we're

1563
00:54:04,480 --> 00:54:06,559
reading and writing from i squared c

1564
00:54:06,559 --> 00:54:11,200
chip with not that many lines of code

1565
00:54:11,200 --> 00:54:14,800
we can go back if we actually pause

1566
00:54:14,800 --> 00:54:17,359
we can actually have it break when we go

1567
00:54:17,359 --> 00:54:24,160
to get the humidity

1568
00:54:24,160 --> 00:54:27,280
now we can go through this if we want

1569
00:54:27,280 --> 00:54:30,160
see it go through

1570
00:54:32,480 --> 00:54:35,119
oh yes

1571
00:54:37,040 --> 00:54:40,000
what we want to see is this so of course

1572
00:54:40,000 --> 00:54:42,079
it changes the address so it calls that

1573
00:54:42,079 --> 00:54:43,599
function

1574
00:54:43,599 --> 00:54:46,880
down here to change the address it sets

1575
00:54:46,880 --> 00:54:47,440
that

1576
00:54:47,440 --> 00:54:50,880
register to the correct address we go

1577
00:54:50,880 --> 00:54:52,079
back

1578
00:54:52,079 --> 00:54:54,559
it loads the buffer with that humidity

1579
00:54:54,559 --> 00:54:55,440
trigger

1580
00:54:55,440 --> 00:54:58,880
and then we'll just skip ahead

1581
00:54:58,880 --> 00:55:00,319
you can see how fast that actually

1582
00:55:00,319 --> 00:55:02,960
happens so now

1583
00:55:02,960 --> 00:55:04,960
that raw data that comes from the chip

1584
00:55:04,960 --> 00:55:06,240
looks like that

1585
00:55:06,240 --> 00:55:08,160
three eight three seven six doesn't

1586
00:55:08,160 --> 00:55:09,440
really mean a lot

1587
00:55:09,440 --> 00:55:11,520
so it has to go through this function if

1588
00:55:11,520 --> 00:55:12,640
we skip ahead

1589
00:55:12,640 --> 00:55:16,720
actually we have to jump out of that

1590
00:55:17,119 --> 00:55:18,559
we'll see the humidity has now been

1591
00:55:18,559 --> 00:55:20,839
calculated to

1592
00:55:20,839 --> 00:55:23,200
67.8 percent that's actually showing

1593
00:55:23,200 --> 00:55:25,839
exponent plus one for some reason but

1594
00:55:25,839 --> 00:55:29,200
free buffer i mean it's pretty simple um

1595
00:55:29,200 --> 00:55:31,839
i've only got a few minutes left of my

1596
00:55:31,839 --> 00:55:34,000
laptop battery here so let's get back

1597
00:55:34,000 --> 00:55:39,920
to the slides and finish this off

1598
00:55:43,280 --> 00:55:46,000
so summary this is what i wanted to get

1599
00:55:46,000 --> 00:55:47,119
across

1600
00:55:47,119 --> 00:55:48,880
when you're working with i squared c the

1601
00:55:48,880 --> 00:55:50,319
most important skill

1602
00:55:50,319 --> 00:55:52,079
is reading data sheets getting the

1603
00:55:52,079 --> 00:55:53,839
essential information

1604
00:55:53,839 --> 00:55:54,880
both the data sheet for the

1605
00:55:54,880 --> 00:55:56,400
microcontroller that you're going to be

1606
00:55:56,400 --> 00:55:56,960
using

1607
00:55:56,960 --> 00:55:58,480
and the data sheet for the peripheral

1608
00:55:58,480 --> 00:56:00,480
you're going to be communicating with

1609
00:56:00,480 --> 00:56:02,079
this is an important skill that we'll

1610
00:56:02,079 --> 00:56:03,520
develop with use

1611
00:56:03,520 --> 00:56:05,599
if you have questions about this please

1612
00:56:05,599 --> 00:56:06,799
bring them up during the

1613
00:56:06,799 --> 00:56:09,839
q a session tomorrow night um most

1614
00:56:09,839 --> 00:56:11,440
microcontrollers that have i squared z

1615
00:56:11,440 --> 00:56:12,400
hardware support

1616
00:56:12,400 --> 00:56:14,640
work in generally the same fashion as i

1617
00:56:14,640 --> 00:56:16,240
showed today

1618
00:56:16,240 --> 00:56:17,920
another important skill is being able to

1619
00:56:17,920 --> 00:56:19,760
identify the quirks of the particular i

1620
00:56:19,760 --> 00:56:21,520
squared c peripheral and what strengths

1621
00:56:21,520 --> 00:56:22,880
and weaknesses it has versus other

1622
00:56:22,880 --> 00:56:24,079
microcontrollers

1623
00:56:24,079 --> 00:56:25,520
this is again something that comes with

1624
00:56:25,520 --> 00:56:27,200
experience once you've worked with

1625
00:56:27,200 --> 00:56:28,799
microcontrollers for a while you start

1626
00:56:28,799 --> 00:56:30,559
to learn which ones have easy to use

1627
00:56:30,559 --> 00:56:32,000
peripherals

1628
00:56:32,000 --> 00:56:34,240
so the key data points setting the

1629
00:56:34,240 --> 00:56:35,680
microcontroller baud rate

1630
00:56:35,680 --> 00:56:38,799
enable the i squared c module sending

1631
00:56:38,799 --> 00:56:40,880
the peripheral address generating start

1632
00:56:40,880 --> 00:56:42,319
and stop conditions

1633
00:56:42,319 --> 00:56:44,240
acknowledge and not acknowledge while

1634
00:56:44,240 --> 00:56:45,760
reading um

1635
00:56:45,760 --> 00:56:46,880
what are the addresses of the

1636
00:56:46,880 --> 00:56:48,720
peripherals you're working with does the

1637
00:56:48,720 --> 00:56:49,040
chip

1638
00:56:49,040 --> 00:56:50,880
automatically convert the 7-bit form to

1639
00:56:50,880 --> 00:56:52,400
the 8-bit format does it expect

1640
00:56:52,400 --> 00:56:55,119
you to do this what registers does the

1641
00:56:55,119 --> 00:56:57,040
i-squared-c peripheral have

1642
00:56:57,040 --> 00:56:58,880
does it require you to write a register

1643
00:56:58,880 --> 00:57:00,640
address before reading or does it simply

1644
00:57:00,640 --> 00:57:03,599
respond to commands with data

1645
00:57:03,599 --> 00:57:05,040
make sure you're able to detect

1646
00:57:05,040 --> 00:57:06,480
non-acknowledges from the peripherals

1647
00:57:06,480 --> 00:57:08,720
and handle these in software

1648
00:57:08,720 --> 00:57:11,280
so i know this was a little bit rushed i

1649
00:57:11,280 --> 00:57:12,799
was trying to squeeze this all into an

1650
00:57:12,799 --> 00:57:14,720
hour so further reading if you want to

1651
00:57:14,720 --> 00:57:16,000
get even more

1652
00:57:16,000 --> 00:57:18,480
in-depth look at i squared c i highly

1653
00:57:18,480 --> 00:57:20,000
recommend the book mastering the i

1654
00:57:20,000 --> 00:57:22,480
squared c bus by the legendary

1655
00:57:22,480 --> 00:57:25,119
engineer vincent himpe uh he's been

1656
00:57:25,119 --> 00:57:26,240
featured on

1657
00:57:26,240 --> 00:57:28,240
uh a bunch of different podcasts he's a

1658
00:57:28,240 --> 00:57:29,599
really really cool guy

1659
00:57:29,599 --> 00:57:32,400
um there's the isbn it's available from

1660
00:57:32,400 --> 00:57:35,520
electors an ebook for 24 euros

1661
00:57:35,520 --> 00:57:37,760
print copies are basically impossible to

1662
00:57:37,760 --> 00:57:39,760
get i'm lucky enough to have a paper

1663
00:57:39,760 --> 00:57:40,640
copy

1664
00:57:40,640 --> 00:57:42,960
sent to me by him signed by him which is

1665
00:57:42,960 --> 00:57:44,079
really cool

1666
00:57:44,079 --> 00:57:45,599
the full i squared c standard is

1667
00:57:45,599 --> 00:57:47,839
available for free download from nxp

1668
00:57:47,839 --> 00:57:49,520
there's the link to it kind of hard to

1669
00:57:49,520 --> 00:57:51,599
see but if you download these slides you

1670
00:57:51,599 --> 00:57:53,599
can click on that link

1671
00:57:53,599 --> 00:57:54,960
next week we're going to be starting

1672
00:57:54,960 --> 00:57:56,640
with one wire which has many

1673
00:57:56,640 --> 00:57:58,400
similarities to i squared c but it does

1674
00:57:58,400 --> 00:58:00,160
not have a clock line so make sure that

1675
00:58:00,160 --> 00:58:02,640
you signed up for that class and tune in

1676
00:58:02,640 --> 00:58:03,920
we're going to be bringing everything

1677
00:58:03,920 --> 00:58:06,559
we've learned together in week four

1678
00:58:06,559 --> 00:58:08,720
where we combine everything together uh

1679
00:58:08,720 --> 00:58:10,240
one wire and i squared c

1680
00:58:10,240 --> 00:58:12,880
and we do something with it so thank you

1681
00:58:12,880 --> 00:58:13,599
so much

1682
00:58:13,599 --> 00:58:15,680
for watching and uh hopefully you

1683
00:58:15,680 --> 00:58:17,359
learned something and hopefully

1684
00:58:17,359 --> 00:58:19,680
uh we will see you next week and also

1685
00:58:19,680 --> 00:58:21,040
tomorrow night at the question and

1686
00:58:21,040 --> 00:58:23,839
answer session

