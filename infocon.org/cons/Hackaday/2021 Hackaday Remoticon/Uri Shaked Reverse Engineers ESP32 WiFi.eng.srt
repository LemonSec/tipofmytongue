1
00:00:04,240 --> 00:00:07,359
next up we have uh ali shakhed a man who

2
00:00:07,359 --> 00:00:09,360
described himself to us as voiding

3
00:00:09,360 --> 00:00:12,080
warranties for son but two long-time

4
00:00:12,080 --> 00:00:13,519
hackaday readers will know as an

5
00:00:13,519 --> 00:00:15,759
authoritative expert on microcontroller

6
00:00:15,759 --> 00:00:17,119
internals

7
00:00:17,119 --> 00:00:19,359
over time he's shown us projects across

8
00:00:19,359 --> 00:00:22,720
nrf avr and arm and many more

9
00:00:22,720 --> 00:00:23,600
chips

10
00:00:23,600 --> 00:00:25,279
and most recently he's delivered the

11
00:00:25,279 --> 00:00:27,279
definitive lowdown on the raspberry pi

12
00:00:27,279 --> 00:00:30,640
rp 2040 dual core arm chip he's also

13
00:00:30,640 --> 00:00:32,479
turned his hand to more than one badge

14
00:00:32,479 --> 00:00:34,800
life project uh always producing very

15
00:00:34,800 --> 00:00:37,040
well engineered and fiendish ctf

16
00:00:37,040 --> 00:00:38,320
projects

17
00:00:38,320 --> 00:00:39,360
um so

18
00:00:39,360 --> 00:00:42,239
take it away yuri

19
00:00:42,239 --> 00:00:44,480
thank you jenny wow such a detailed

20
00:00:44,480 --> 00:00:46,879
introduction i didn't expect that

21
00:00:46,879 --> 00:00:50,000
um so before we start um i will say that

22
00:00:50,000 --> 00:00:52,399
hi i'm worried and let me take off my

23
00:00:52,399 --> 00:00:55,840
headphones and change them to my

24
00:00:55,840 --> 00:00:58,480
reverse engineering hat so

25
00:00:58,480 --> 00:01:00,320
well that will

26
00:01:00,320 --> 00:01:02,239
get us going through this talk

27
00:01:02,239 --> 00:01:05,840
and let's share my screen and do this um

28
00:01:05,840 --> 00:01:08,400
sharing screen number one you should be

29
00:01:08,400 --> 00:01:11,040
seeing my screen now let me just make

30
00:01:11,040 --> 00:01:14,080
sure i can see the chat so if there is

31
00:01:14,080 --> 00:01:15,840
anything you can let me know so

32
00:01:15,840 --> 00:01:18,960
reversing the esp32 wi-fi

33
00:01:18,960 --> 00:01:20,560
uh

34
00:01:20,560 --> 00:01:22,799
why would we want to do this

35
00:01:22,799 --> 00:01:26,240
in three two one so why would we want to

36
00:01:26,240 --> 00:01:28,000
do this um

37
00:01:28,000 --> 00:01:30,560
i will share with you my fav personal

38
00:01:30,560 --> 00:01:33,439
reason i'm working on an online uh

39
00:01:33,439 --> 00:01:35,680
simulator for arduino and electronics

40
00:01:35,680 --> 00:01:39,600
called walkwe and i recently added esp32

41
00:01:39,600 --> 00:01:42,079
let me show you that so this is walqui

42
00:01:42,079 --> 00:01:44,479
and on the left we have um

43
00:01:44,479 --> 00:01:47,040
micro python program and on the right

44
00:01:47,040 --> 00:01:49,439
there is an esp32 connected to a

45
00:01:49,439 --> 00:01:52,560
neopixel ring and as soon as we hit play

46
00:01:52,560 --> 00:01:54,720
we can see the simulation is starting

47
00:01:54,720 --> 00:01:57,360
and it does what the code tells it to do

48
00:01:57,360 --> 00:02:00,479
links alternates between red and green

49
00:02:00,479 --> 00:02:02,719
and we can easily stop the simulation

50
00:02:02,719 --> 00:02:05,360
and change one of the colors from red to

51
00:02:05,360 --> 00:02:08,479
let's say rgb of purple hit play again

52
00:02:08,479 --> 00:02:09,280
and

53
00:02:09,280 --> 00:02:10,479
yeah it's

54
00:02:10,479 --> 00:02:12,800
that simple uh just changing the code

55
00:02:12,800 --> 00:02:15,920
and seeing the result but don't let this

56
00:02:15,920 --> 00:02:17,200
very uh

57
00:02:17,200 --> 00:02:20,319
friendly or simple user interface fool

58
00:02:20,319 --> 00:02:22,560
you this is actually running a full

59
00:02:22,560 --> 00:02:25,760
esp32 simulation behind the scenes it's

60
00:02:25,760 --> 00:02:28,160
not a spatial version of python

61
00:02:28,160 --> 00:02:31,440
interpreter that i wrote or micro python

62
00:02:31,440 --> 00:02:33,680
compiled in a special way just running

63
00:02:33,680 --> 00:02:35,680
the stock micro pattern

64
00:02:35,680 --> 00:02:38,400
that runs also runs on your esp32

65
00:02:38,400 --> 00:02:39,519
devices

66
00:02:39,519 --> 00:02:41,040
and um

67
00:02:41,040 --> 00:02:42,640
i want to show you something so i'm

68
00:02:42,640 --> 00:02:45,360
going to add an led let's connect the

69
00:02:45,360 --> 00:02:47,200
anode to d2

70
00:02:47,200 --> 00:02:49,680
and let's connect the cathode to the

71
00:02:49,680 --> 00:02:50,480
ground

72
00:02:50,480 --> 00:02:53,840
and now i'm going to show you um

73
00:02:53,840 --> 00:02:56,160
the power that this simulator gives us

74
00:02:56,160 --> 00:02:58,400
by simulating the actual hardware so we

75
00:02:58,400 --> 00:03:00,400
are going to comment out this while loop

76
00:03:00,400 --> 00:03:02,319
so instead of running it we'll start a

77
00:03:02,319 --> 00:03:05,200
simulation and we'll get right into the

78
00:03:05,200 --> 00:03:06,959
micro python repel

79
00:03:06,959 --> 00:03:09,280
and now i'm going to do some witchcraft

80
00:03:09,280 --> 00:03:11,280
and this is something pretty advanced

81
00:03:11,280 --> 00:03:13,680
it's like a lot of parts in this talk if

82
00:03:13,680 --> 00:03:16,239
you can't follow it that's totally fine

83
00:03:16,239 --> 00:03:18,560
you don't have to understand everything

84
00:03:18,560 --> 00:03:21,680
um so i'm going to write directly into

85
00:03:21,680 --> 00:03:25,920
some memory address in the esp32 chip

86
00:03:25,920 --> 00:03:27,760
specifically i'm going to write this

87
00:03:27,760 --> 00:03:31,200
value and what's writing this value 4 to

88
00:03:31,200 --> 00:03:33,360
this address does it sets this pin

89
00:03:33,360 --> 00:03:36,319
number 2 to output and then i'm going to

90
00:03:36,319 --> 00:03:38,640
write another value or the same value to

91
00:03:38,640 --> 00:03:40,480
a different address this time it ends

92
00:03:40,480 --> 00:03:43,920
with an 8 and you can see it turned the

93
00:03:43,920 --> 00:03:45,360
led on

94
00:03:45,360 --> 00:03:47,760
and then i can do uh right to a

95
00:03:47,760 --> 00:03:49,519
different address and it will turn the

96
00:03:49,519 --> 00:03:52,480
led off so i can use the

97
00:03:52,480 --> 00:03:54,959
micro python high level interface to

98
00:03:54,959 --> 00:03:57,519
control the hardware but i can also

99
00:03:57,519 --> 00:03:59,760
write directly to the memory addresses

100
00:03:59,760 --> 00:04:02,400
that control the hardware and i get full

101
00:04:02,400 --> 00:04:05,120
control of the hardware this way

102
00:04:05,120 --> 00:04:09,120
and um i introduced this esp32 a few

103
00:04:09,120 --> 00:04:11,439
weeks ago and then i asked the users hey

104
00:04:11,439 --> 00:04:13,280
what what do you think about it and they

105
00:04:13,280 --> 00:04:15,200
all told me the same things

106
00:04:15,200 --> 00:04:18,238
it's great but we also need wi-fi

107
00:04:18,238 --> 00:04:20,720
and this is the why why i started this

108
00:04:20,720 --> 00:04:23,199
project other than um

109
00:04:23,199 --> 00:04:25,680
bringing wi-fi to my own simulator i

110
00:04:25,680 --> 00:04:27,680
figured out that nobody has really done

111
00:04:27,680 --> 00:04:29,520
this kind of reverse engineering to the

112
00:04:29,520 --> 00:04:32,560
esp32 wi-fi stack and it can probably be

113
00:04:32,560 --> 00:04:35,280
also useful for our security research

114
00:04:35,280 --> 00:04:37,759
and other purposes so now that we got

115
00:04:37,759 --> 00:04:41,440
the y covered let's talk a bit about uh

116
00:04:41,440 --> 00:04:44,320
the esp32 and before that this is a link

117
00:04:44,320 --> 00:04:46,400
with all the links and the link to the

118
00:04:46,400 --> 00:04:48,800
slides itself so someone please be kind

119
00:04:48,800 --> 00:04:51,680
take a screenshot and post it to discord

120
00:04:51,680 --> 00:04:54,400
uh for the other people watching this

121
00:04:54,400 --> 00:04:57,360
so esp32 how does it work the

122
00:04:57,360 --> 00:04:59,360
instruction set that it uses is called

123
00:04:59,360 --> 00:05:01,360
extensor it's not

124
00:05:01,360 --> 00:05:04,400
arm or risk 5 or avr that you probably

125
00:05:04,400 --> 00:05:06,639
have on your other microcontrollers it's

126
00:05:06,639 --> 00:05:09,520
a specific different instruction set

127
00:05:09,520 --> 00:05:11,360
and there is this a very detailed

128
00:05:11,360 --> 00:05:14,240
document called the esp32 technical

129
00:05:14,240 --> 00:05:16,880
reference manual that contains a lot of

130
00:05:16,880 --> 00:05:18,800
documentation about the chips and the

131
00:05:18,800 --> 00:05:21,360
peripherals and how everything is set up

132
00:05:21,360 --> 00:05:23,840
let me just show you a quick taste so

133
00:05:23,840 --> 00:05:26,880
this is one of the table from the trm

134
00:05:26,880 --> 00:05:29,240
and it tells us what the memory map for

135
00:05:29,240 --> 00:05:32,240
esp32 looks like so ramlandia if you

136
00:05:32,240 --> 00:05:35,600
watches alicia stocked yesterday

137
00:05:35,600 --> 00:05:39,360
which are part of memory does what so uh

138
00:05:39,360 --> 00:05:42,160
our interesting uh we are interested in

139
00:05:42,160 --> 00:05:44,479
the peripherals which are like the usb

140
00:05:44,479 --> 00:05:47,440
spi uart and also where i believe the

141
00:05:47,440 --> 00:05:49,680
wi-fi lives and we can see all the

142
00:05:49,680 --> 00:05:52,160
peripherals they sit in this memory

143
00:05:52,160 --> 00:05:55,199
address space starting from three ff0 up

144
00:05:55,199 --> 00:05:57,120
to three f7

145
00:05:57,120 --> 00:05:59,919
and talking about peripherals how does

146
00:05:59,919 --> 00:06:03,039
the code speak with peripherals so the

147
00:06:03,039 --> 00:06:06,160
main way the code that runs on the esp32

148
00:06:06,160 --> 00:06:08,240
speaks with peripherals with

149
00:06:08,240 --> 00:06:11,759
the spi with the urd serial and other

150
00:06:11,759 --> 00:06:13,919
peripherals i square c is through

151
00:06:13,919 --> 00:06:16,479
registers and we have seen a demo of

152
00:06:16,479 --> 00:06:19,520
this uh just here with this led we just

153
00:06:19,520 --> 00:06:21,520
wrote to these memory addresses which

154
00:06:21,520 --> 00:06:23,360
happen to lie in the peripheral area

155
00:06:23,360 --> 00:06:25,759
space these are hardware registers that

156
00:06:25,759 --> 00:06:28,639
belong to the gpio peripheral and by

157
00:06:28,639 --> 00:06:30,560
writing to them we were able to set a

158
00:06:30,560 --> 00:06:33,840
spin to output and even to uh turn it

159
00:06:33,840 --> 00:06:36,080
high and then backload

160
00:06:36,080 --> 00:06:38,880
um but for most peripherals that can

161
00:06:38,880 --> 00:06:41,600
send and receive data like uh spi or

162
00:06:41,600 --> 00:06:44,720
uart they also have at least

163
00:06:44,720 --> 00:06:47,680
a set of two registers

164
00:06:47,680 --> 00:06:50,000
for sending and receiving data rx and tx

165
00:06:50,000 --> 00:06:52,479
register so if we have a uart peripheral

166
00:06:52,479 --> 00:06:54,479
and we want to send some data we write

167
00:06:54,479 --> 00:06:56,720
it to the tx register and that tells the

168
00:06:56,720 --> 00:06:59,039
hardware hey we want to transmit it and

169
00:06:59,039 --> 00:07:00,960
if there is some data that comes in we

170
00:07:00,960 --> 00:07:02,880
can read it from the rx register so

171
00:07:02,880 --> 00:07:04,800
that's how it usually works with most

172
00:07:04,800 --> 00:07:06,240
peripherals

173
00:07:06,240 --> 00:07:08,960
and most of the peripherals also have an

174
00:07:08,960 --> 00:07:11,039
interrupt which is how they tell the

175
00:07:11,039 --> 00:07:12,400
code hey there is something that

176
00:07:12,400 --> 00:07:14,800
happened like there is new data on the

177
00:07:14,800 --> 00:07:17,440
rx register that you should read or the

178
00:07:17,440 --> 00:07:19,840
data that you wrote to the rx register

179
00:07:19,840 --> 00:07:22,400
is done i finished transmitting it

180
00:07:22,400 --> 00:07:23,680
and

181
00:07:23,680 --> 00:07:26,479
one more interface between the user code

182
00:07:26,479 --> 00:07:29,599
and the hardware is dma direct memory

183
00:07:29,599 --> 00:07:30,720
access

184
00:07:30,720 --> 00:07:32,800
and um i'm not going to talk about it

185
00:07:32,800 --> 00:07:34,720
too much right now but it basically

186
00:07:34,720 --> 00:07:37,440
copies data from the memory from

187
00:07:37,440 --> 00:07:39,440
some arbitrary memory address the user

188
00:07:39,440 --> 00:07:42,000
provides into the peripheral or from the

189
00:07:42,000 --> 00:07:44,720
peripheral into um

190
00:07:44,720 --> 00:07:48,479
into the memory and uh the the esp trm

191
00:07:48,479 --> 00:07:51,199
tells us that the wi-fi has dma which is

192
00:07:51,199 --> 00:07:53,759
a nice clue that we will use down the

193
00:07:53,759 --> 00:07:54,800
road

194
00:07:54,800 --> 00:07:56,720
so uh that's about the peripheral

195
00:07:56,720 --> 00:07:59,440
interface and i could sit here and talk

196
00:07:59,440 --> 00:08:01,440
about how the simulation work i think

197
00:08:01,440 --> 00:08:04,080
it's really interesting but i already

198
00:08:04,080 --> 00:08:06,400
done this in a very long youtube series

199
00:08:06,400 --> 00:08:08,080
where i code a raspberry pi

200
00:08:08,080 --> 00:08:10,000
picosimulator from scratch so you can

201
00:08:10,000 --> 00:08:12,080
find it in the link document with all

202
00:08:12,080 --> 00:08:15,120
the links and there is also my simulator

203
00:08:15,120 --> 00:08:17,840
is the esp32 part is not open source but

204
00:08:17,840 --> 00:08:20,319
there is a qme simulator which is open

205
00:08:20,319 --> 00:08:23,120
source and can simulate esp32 so there

206
00:08:23,120 --> 00:08:25,199
is a link if you want to try doing

207
00:08:25,199 --> 00:08:27,680
things with esp32 simulation on your

208
00:08:27,680 --> 00:08:29,919
computer and finally i'm i want to

209
00:08:29,919 --> 00:08:32,240
record another video where i show how i

210
00:08:32,240 --> 00:08:34,320
simulated the instruction set for this

211
00:08:34,320 --> 00:08:36,640
extends architecture it is probably

212
00:08:36,640 --> 00:08:38,000
coming soon there is a link to the

213
00:08:38,000 --> 00:08:40,240
youtube channel on the document with all

214
00:08:40,240 --> 00:08:41,360
the links

215
00:08:41,360 --> 00:08:42,080
so

216
00:08:42,080 --> 00:08:44,720
um let's talk about adding wi-fi how do

217
00:08:44,720 --> 00:08:46,959
we go about it of course the first thing

218
00:08:46,959 --> 00:08:49,360
i did was just google have any as is

219
00:08:49,360 --> 00:08:51,680
there any information online not really

220
00:08:51,680 --> 00:08:54,160
some people did something with all the

221
00:08:54,160 --> 00:08:58,880
sp 8266 but it wasn't really uh too deep

222
00:08:58,880 --> 00:09:01,040
and then of course i went to the data

223
00:09:01,040 --> 00:09:03,519
sheets and the trm but there was almost

224
00:09:03,519 --> 00:09:05,200
no information there was this thing

225
00:09:05,200 --> 00:09:07,120
about the dma that i showed you and a

226
00:09:07,120 --> 00:09:09,680
few other pieces of information but

227
00:09:09,680 --> 00:09:11,680
nothing really very useful

228
00:09:11,680 --> 00:09:13,680
and then i went to the source code of

229
00:09:13,680 --> 00:09:16,800
the esp-idf their application framework

230
00:09:16,800 --> 00:09:19,680
but apparently the wi-fi library is

231
00:09:19,680 --> 00:09:21,680
coming from a different repository you

232
00:09:21,680 --> 00:09:24,000
have the link here and in the document

233
00:09:24,000 --> 00:09:27,040
and it's just binaries no source code um

234
00:09:27,040 --> 00:09:28,800
so you have the whole source code for

235
00:09:28,800 --> 00:09:31,120
the rtos and everything

236
00:09:31,120 --> 00:09:34,320
else in the esp idf but not the wi-fi so

237
00:09:34,320 --> 00:09:36,320
this leaves us with only one option

238
00:09:36,320 --> 00:09:40,720
which is reverse engineering yeah

239
00:09:40,720 --> 00:09:44,720
and let's do reverse engineering but uh

240
00:09:44,720 --> 00:09:46,640
before we dive into it let's define our

241
00:09:46,640 --> 00:09:49,200
goal our goal today is to find which

242
00:09:49,200 --> 00:09:51,920
registers control the wi-fi radio and

243
00:09:51,920 --> 00:09:53,440
figure out their meaning what do we need

244
00:09:53,440 --> 00:09:55,519
to write or read from those registers in

245
00:09:55,519 --> 00:09:56,720
order to

246
00:09:56,720 --> 00:09:58,880
tell the wi-fi radio to do things like

247
00:09:58,880 --> 00:10:01,680
transmit frames over the air or receive

248
00:10:01,680 --> 00:10:04,720
them so that's our goal and let's see

249
00:10:04,720 --> 00:10:07,040
how uh we approach this code what tools

250
00:10:07,040 --> 00:10:09,200
we are going to use so the first tool is

251
00:10:09,200 --> 00:10:12,399
gdb the gnu debugger and there is a link

252
00:10:12,399 --> 00:10:14,480
to a blog post where i explain about my

253
00:10:14,480 --> 00:10:16,079
setup you can see it here it's a

254
00:10:16,079 --> 00:10:19,360
raspberry pi with a custom hat i made

255
00:10:19,360 --> 00:10:23,600
that is an adapter to an esp32 board and

256
00:10:23,600 --> 00:10:26,320
all of that lets the uh raspberry pi

257
00:10:26,320 --> 00:10:28,399
speak to the esp32

258
00:10:28,399 --> 00:10:30,560
through the jtag debugging interface and

259
00:10:30,560 --> 00:10:32,720
i'm using a tool called openocd which

260
00:10:32,720 --> 00:10:35,440
bridges between jtag to gdb but the

261
00:10:35,440 --> 00:10:38,560
point is i can use gdb.gnu debugger to

262
00:10:38,560 --> 00:10:41,360
debug my code on the physical hardware

263
00:10:41,360 --> 00:10:44,320
as well as in the simulation so gdb is

264
00:10:44,320 --> 00:10:46,959
one tool then we have guidewa and gitra

265
00:10:46,959 --> 00:10:47,680
is

266
00:10:47,680 --> 00:10:50,079
an open source reverse engineering uh

267
00:10:50,079 --> 00:10:52,720
tool a very useful one it doesn't work

268
00:10:52,720 --> 00:10:54,720
out of the box with extenza if you want

269
00:10:54,720 --> 00:10:56,720
to use it with esp32 you have to

270
00:10:56,720 --> 00:10:58,880
download and compile a plugin you have

271
00:10:58,880 --> 00:11:01,920
the link here and um

272
00:11:01,920 --> 00:11:04,399
more importantly i'm using the simulator

273
00:11:04,399 --> 00:11:07,120
itself to debug and reverse engineer the

274
00:11:07,120 --> 00:11:09,519
wi-fi framework the simulator gives us

275
00:11:09,519 --> 00:11:12,560
access to all the internals of the esp32

276
00:11:12,560 --> 00:11:15,279
so we can see the internal state of the

277
00:11:15,279 --> 00:11:17,920
peripherals and the cpu while the code

278
00:11:17,920 --> 00:11:19,920
is trying to connect to the wi-fi and

279
00:11:19,920 --> 00:11:21,920
then figure out how the code is trying

280
00:11:21,920 --> 00:11:23,519
to connect to the wi-fi and we'll see

281
00:11:23,519 --> 00:11:25,200
that in a moment

282
00:11:25,200 --> 00:11:27,839
so now that we know our tools let's dive

283
00:11:27,839 --> 00:11:28,880
into this

284
00:11:28,880 --> 00:11:32,320
and um we are going to take uh that

285
00:11:32,320 --> 00:11:34,320
that's what i did when i started working

286
00:11:34,320 --> 00:11:36,399
on this this scan example it's one of

287
00:11:36,399 --> 00:11:39,200
the examples that comes in the esp idf

288
00:11:39,200 --> 00:11:41,600
just uh scanning for wi-fi networks and

289
00:11:41,600 --> 00:11:43,839
printing the results here is the source

290
00:11:43,839 --> 00:11:45,279
code there is also a link in the

291
00:11:45,279 --> 00:11:47,760
document and you can see it's calling a

292
00:11:47,760 --> 00:11:50,160
few interesting functions like esp wi-fi

293
00:11:50,160 --> 00:11:52,800
init esp wi-fi start esp wi-fi scan

294
00:11:52,800 --> 00:11:55,360
start so it seems like it's using the

295
00:11:55,360 --> 00:11:57,279
wi-fi stack and we are going to figure

296
00:11:57,279 --> 00:11:58,639
out how

297
00:11:58,639 --> 00:12:01,200
but before we do it this is a very

298
00:12:01,200 --> 00:12:03,040
important tip if you are working on a

299
00:12:03,040 --> 00:12:05,440
reverse engineering project you always

300
00:12:05,440 --> 00:12:08,480
want to turn every kind of log messages

301
00:12:08,480 --> 00:12:10,800
that you can up to 11.

302
00:12:10,800 --> 00:12:13,440
and in this case uh for the idf there is

303
00:12:13,440 --> 00:12:15,279
this menu config tool and i can

304
00:12:15,279 --> 00:12:17,200
configure the default log the default

305
00:12:17,200 --> 00:12:19,760
log verbosity to verbose which gives me

306
00:12:19,760 --> 00:12:22,639
a lot of logs and that's super important

307
00:12:22,639 --> 00:12:24,639
because it turns out that the wi-fi

308
00:12:24,639 --> 00:12:27,279
stack has a lot of logs inside it so i

309
00:12:27,279 --> 00:12:29,519
can see what it's doing so whenever

310
00:12:29,519 --> 00:12:30,959
you're working on some reverse

311
00:12:30,959 --> 00:12:33,440
engineering projects find a way to get

312
00:12:33,440 --> 00:12:35,279
as many logs as you can

313
00:12:35,279 --> 00:12:38,079
and now that we got that covered i

314
00:12:38,079 --> 00:12:41,519
compile this scan program and

315
00:12:41,519 --> 00:12:44,079
i apply the following method i run it

316
00:12:44,079 --> 00:12:46,720
inside the simulation until it breaks or

317
00:12:46,720 --> 00:12:50,160
crashes and then i so where did it break

318
00:12:50,160 --> 00:12:52,959
or crash fix the issue and then repeated

319
00:12:52,959 --> 00:12:55,600
the process all over again until i was

320
00:12:55,600 --> 00:12:58,560
able to get the wi-fi uh to start in the

321
00:12:58,560 --> 00:13:00,399
simulator or at least the code to think

322
00:13:00,399 --> 00:13:02,720
that the wi-fi has started let's see how

323
00:13:02,720 --> 00:13:05,360
this is done in practice so this is the

324
00:13:05,360 --> 00:13:08,560
simulator running scan dot elf the uh

325
00:13:08,560 --> 00:13:10,880
compiled scan program and you can see

326
00:13:10,880 --> 00:13:13,200
there is a bunch of output and then it

327
00:13:13,200 --> 00:13:16,160
has this yellow warning and it freezes

328
00:13:16,160 --> 00:13:18,320
and at that point when it froze i

329
00:13:18,320 --> 00:13:21,360
connected to it with gdb the debugger

330
00:13:21,360 --> 00:13:23,680
and i hit the back race bt command which

331
00:13:23,680 --> 00:13:26,720
shows me um the the uh chain of

332
00:13:26,720 --> 00:13:29,120
functions where it uh it got stuck so

333
00:13:29,120 --> 00:13:30,720
this is like the call stack the back

334
00:13:30,720 --> 00:13:32,880
trace where it got stuck and it got

335
00:13:32,880 --> 00:13:35,120
stuck in this uh specific function

336
00:13:35,120 --> 00:13:38,079
hallmark the init and as you can see the

337
00:13:38,079 --> 00:13:39,920
functions in the stack trace they all

338
00:13:39,920 --> 00:13:42,959
seem to be related to wi-fi like wi-fi

339
00:13:42,959 --> 00:13:47,279
hardware struct height reple0211

340
00:13:47,279 --> 00:13:48,959
and um

341
00:13:48,959 --> 00:13:50,880
that got me interested to see what does

342
00:13:50,880 --> 00:13:52,880
this function do why does it get stuck

343
00:13:52,880 --> 00:13:55,680
into it so i asked gdp hey gdp can you

344
00:13:55,680 --> 00:13:57,839
disassemble the function for me we don't

345
00:13:57,839 --> 00:14:00,320
have the source code we are even lucky

346
00:14:00,320 --> 00:14:02,560
to have like the names of the functions

347
00:14:02,560 --> 00:14:05,519
so the wi-fi binaries they are compiled

348
00:14:05,519 --> 00:14:07,600
with basic symbols so we have names for

349
00:14:07,600 --> 00:14:09,680
most of the functions but we can't see

350
00:14:09,680 --> 00:14:11,600
the parameters and of course not the

351
00:14:11,600 --> 00:14:13,519
source code because it's not available

352
00:14:13,519 --> 00:14:16,000
but we can at least ask gdb to decompile

353
00:14:16,000 --> 00:14:18,720
it to disassemble it and this is what i

354
00:14:18,720 --> 00:14:19,600
got

355
00:14:19,600 --> 00:14:21,760
even if you know how to read extensor

356
00:14:21,760 --> 00:14:24,720
assembly this is like a nightmare you

357
00:14:24,720 --> 00:14:26,639
can't really make sense out of this code

358
00:14:26,639 --> 00:14:29,279
without um knowing the values of all

359
00:14:29,279 --> 00:14:33,600
these a9 a8 registers so um this is

360
00:14:33,600 --> 00:14:35,920
i mean you could debug it and step

361
00:14:35,920 --> 00:14:38,320
through it and painstakingly figure it

362
00:14:38,320 --> 00:14:41,040
out but fortunately there is a much

363
00:14:41,040 --> 00:14:44,399
better way to do it so enter gydra

364
00:14:44,399 --> 00:14:47,279
i asked gidra to take this scandal file

365
00:14:47,279 --> 00:14:50,480
load it and give me the uh hallmark the

366
00:14:50,480 --> 00:14:52,720
init to decompile it for me

367
00:14:52,720 --> 00:14:55,040
and now i got something that looks more

368
00:14:55,040 --> 00:14:57,440
like a pseudocode it's still messy we

369
00:14:57,440 --> 00:14:59,120
can clean it up i'm going to remove

370
00:14:59,120 --> 00:15:01,519
these memw instructions they are just

371
00:15:01,519 --> 00:15:04,480
memory synchronization stuff and clean

372
00:15:04,480 --> 00:15:06,800
it up a bit so the thing on the right is

373
00:15:06,800 --> 00:15:09,279
equivalent to the thing of the code of

374
00:15:09,279 --> 00:15:11,120
on the left you can verify it later if

375
00:15:11,120 --> 00:15:14,160
you want and now we can start making

376
00:15:14,160 --> 00:15:16,320
sense of what this function is doing

377
00:15:16,320 --> 00:15:18,880
it's writing to some memory address to

378
00:15:18,880 --> 00:15:21,839
some register and sets a few bits in it

379
00:15:21,839 --> 00:15:25,600
wait for 32 microseconds and then it

380
00:15:25,600 --> 00:15:28,000
busy waits it reads this same register

381
00:15:28,000 --> 00:15:30,399
that it has written to before and it

382
00:15:30,399 --> 00:15:33,279
waits until some bit in this register or

383
00:15:33,279 --> 00:15:36,959
this specific bit is set so it hangs

384
00:15:36,959 --> 00:15:39,440
before because um

385
00:15:39,440 --> 00:15:41,199
because in the simulator we don't

386
00:15:41,199 --> 00:15:43,199
implement that behavior

387
00:15:43,199 --> 00:15:45,680
um so back to our method i implemented

388
00:15:45,680 --> 00:15:47,680
that in the simulator so the simulator

389
00:15:47,680 --> 00:15:49,199
would listen on this address and

390
00:15:49,199 --> 00:15:52,079
whenever it sells this value rate end to

391
00:15:52,079 --> 00:15:54,880
this address it would set this bit so

392
00:15:54,880 --> 00:15:57,360
hal make the init would be happy and let

393
00:15:57,360 --> 00:16:00,079
me go on and i did it several time with

394
00:16:00,079 --> 00:16:02,079
several functions

395
00:16:02,079 --> 00:16:04,079
and i noticed something interesting i

396
00:16:04,079 --> 00:16:06,240
noticed that all of those functions they

397
00:16:06,240 --> 00:16:08,399
interacted with addresses that started

398
00:16:08,399 --> 00:16:09,079
with

399
00:16:09,079 --> 00:16:12,959
3ff73 which led me to ask okay what is

400
00:16:12,959 --> 00:16:15,600
what's there at 3ff73

401
00:16:15,600 --> 00:16:18,560
so i went to the trm and i looked like

402
00:16:18,560 --> 00:16:20,720
uh there is this peripheral address

403
00:16:20,720 --> 00:16:22,560
mapping that tells me where each

404
00:16:22,560 --> 00:16:25,279
peripheral like the uart pwm

405
00:16:25,279 --> 00:16:27,920
lives in the memory but apparently for

406
00:16:27,920 --> 00:16:31,519
this specific address 3ff 73 it says

407
00:16:31,519 --> 00:16:33,759
it's reserved they don't even tell us

408
00:16:33,759 --> 00:16:35,279
there is something there they just say

409
00:16:35,279 --> 00:16:37,440
it's reserved

410
00:16:37,440 --> 00:16:39,680
but since i figured out a lot of things

411
00:16:39,680 --> 00:16:42,320
are reading and writing uh all of the

412
00:16:42,320 --> 00:16:44,480
like wi-fi functions i encountered

413
00:16:44,480 --> 00:16:46,560
reading and writing from registers

414
00:16:46,560 --> 00:16:49,279
starting in this i figured out my first

415
00:16:49,279 --> 00:16:51,519
i had my first revelation wi-fi

416
00:16:51,519 --> 00:16:54,560
peripheral is probably at this address

417
00:16:54,560 --> 00:16:57,279
so this is the uh range of addresses

418
00:16:57,279 --> 00:16:59,839
that belong to the wi-fi peripheral and

419
00:16:59,839 --> 00:17:01,839
with that in mind i went on with my

420
00:17:01,839 --> 00:17:04,000
journey

421
00:17:04,000 --> 00:17:06,559
now we hit the first part of our cool we

422
00:17:06,559 --> 00:17:08,559
know which registers control the wi-fi

423
00:17:08,559 --> 00:17:11,520
radio and we just need to figure out or

424
00:17:11,520 --> 00:17:14,000
which range controls it and now we just

425
00:17:14,000 --> 00:17:15,839
need to figure out the actual registers

426
00:17:15,839 --> 00:17:17,599
and their meaning

427
00:17:17,599 --> 00:17:19,359
and in order to do that we are going

428
00:17:19,359 --> 00:17:21,439
back to that back trace that we saw

429
00:17:21,439 --> 00:17:24,160
before with all those uh functions but

430
00:17:24,160 --> 00:17:26,559
instead of focusing on the top one hull

431
00:17:26,559 --> 00:17:28,720
mac be in it we are going to focus on

432
00:17:28,720 --> 00:17:30,880
the one that is almost at the bottom

433
00:17:30,880 --> 00:17:33,520
this tippy task and we can see it has no

434
00:17:33,520 --> 00:17:35,520
source code information or parameters

435
00:17:35,520 --> 00:17:38,480
because it also comes from the wi-fi and

436
00:17:38,480 --> 00:17:40,720
it sounds like some kind of

437
00:17:40,720 --> 00:17:43,440
task that manages the wi-fi it's called

438
00:17:43,440 --> 00:17:46,240
pptask and it's called from this vpo or

439
00:17:46,240 --> 00:17:49,200
task repair which is um

440
00:17:49,200 --> 00:17:52,000
part of the free rtos operating system

441
00:17:52,000 --> 00:17:54,400
in the idf so it sounds like an

442
00:17:54,400 --> 00:17:57,280
interesting place to look i asked gidra

443
00:17:57,280 --> 00:17:59,679
to show me the source code and what you

444
00:17:59,679 --> 00:18:02,320
can see here is just an expert excerpt

445
00:18:02,320 --> 00:18:05,919
of this source code and this pptask is

446
00:18:05,919 --> 00:18:09,520
basically a very big switch statement

447
00:18:09,520 --> 00:18:12,000
which looks at some value it gets from

448
00:18:12,000 --> 00:18:14,080
somewhere and then depending on that

449
00:18:14,080 --> 00:18:16,240
value it caused different functions like

450
00:18:16,240 --> 00:18:21,280
pp process txq pp pro uh txtan rx uh

451
00:18:21,280 --> 00:18:23,600
packet and it sounds like it's the

452
00:18:23,600 --> 00:18:27,440
central place for uh all the um

453
00:18:27,440 --> 00:18:29,840
wi-fi communication so that got me

454
00:18:29,840 --> 00:18:32,799
intrigued i set up a break point in this

455
00:18:32,799 --> 00:18:34,799
pp process dxq

456
00:18:34,799 --> 00:18:37,919
and started tracing what happens inside

457
00:18:37,919 --> 00:18:40,799
and eventually i added a lot of logs to

458
00:18:40,799 --> 00:18:42,799
the simulator so it would log all the

459
00:18:42,799 --> 00:18:45,360
memory reads and writes in this region

460
00:18:45,360 --> 00:18:48,240
uh three uh whatever uh where the wi-fi

461
00:18:48,240 --> 00:18:49,679
peripheral is

462
00:18:49,679 --> 00:18:52,960
uh three ff73 and eventually i figured

463
00:18:52,960 --> 00:18:55,200
out through this uh reverse process of

464
00:18:55,200 --> 00:18:58,240
debugging that uh this is the address of

465
00:18:58,240 --> 00:19:00,640
the tx register so whenever the code

466
00:19:00,640 --> 00:19:03,919
wants to send some wi-fi frame over the

467
00:19:03,919 --> 00:19:04,720
air

468
00:19:04,720 --> 00:19:08,000
the wi-fi stack eventually writes a dma

469
00:19:08,000 --> 00:19:10,080
buffer with a packet and it writes the

470
00:19:10,080 --> 00:19:12,080
address of that dma buffer to this

471
00:19:12,080 --> 00:19:14,640
register and this tells the hardware hey

472
00:19:14,640 --> 00:19:17,280
you should uh transmit this wi-fi frame

473
00:19:17,280 --> 00:19:19,360
over the earth

474
00:19:19,360 --> 00:19:22,400
but that was the easier part it wasn't

475
00:19:22,400 --> 00:19:24,960
easy but it was the easier because with

476
00:19:24,960 --> 00:19:27,200
the tx we had sort of the starting point

477
00:19:27,200 --> 00:19:29,280
the code dictates when the packet would

478
00:19:29,280 --> 00:19:33,039
be sent and it sort of initiates a chain

479
00:19:33,039 --> 00:19:35,200
of events that eventually writes to this

480
00:19:35,200 --> 00:19:36,240
register

481
00:19:36,240 --> 00:19:39,039
but when we look at the rx part

482
00:19:39,039 --> 00:19:41,200
we can't know that i mean

483
00:19:41,200 --> 00:19:43,760
we know that uh if pptask is getting

484
00:19:43,760 --> 00:19:46,559
this value it already knows that it has

485
00:19:46,559 --> 00:19:49,280
to uh look at the received packet but

486
00:19:49,280 --> 00:19:53,120
who tells pptask that it has uh like who

487
00:19:53,120 --> 00:19:55,360
sends this value to pptask who tells

488
00:19:55,360 --> 00:19:58,000
pptask what to do that it should receive

489
00:19:58,000 --> 00:20:00,080
now a packet where where does the how

490
00:20:00,080 --> 00:20:02,320
does the hardware how do we know when

491
00:20:02,320 --> 00:20:04,559
the hardware want to tell the code you

492
00:20:04,559 --> 00:20:06,720
should receive the packet we should

493
00:20:06,720 --> 00:20:09,360
somehow find a way to go back in time

494
00:20:09,360 --> 00:20:11,919
from this point to where the hardware

495
00:20:11,919 --> 00:20:14,320
sent uh told the hardware to send the

496
00:20:14,320 --> 00:20:16,240
code to send to receive a packet in

497
00:20:16,240 --> 00:20:17,600
order to figure out

498
00:20:17,600 --> 00:20:19,840
how this uh this receive packet is

499
00:20:19,840 --> 00:20:20,799
triggered

500
00:20:20,799 --> 00:20:22,960
so for that we want to know who calls

501
00:20:22,960 --> 00:20:24,960
pptask

502
00:20:24,960 --> 00:20:26,960
and in order to do that i

503
00:20:26,960 --> 00:20:30,000
let's go back to the stack trace and

504
00:20:30,000 --> 00:20:32,159
we'll notice that in our stacked race we

505
00:20:32,159 --> 00:20:35,039
had this ieee

506
00:20:35,039 --> 00:20:38,320
whatever iocdl process function so if we

507
00:20:38,320 --> 00:20:41,440
could figure out what happened before

508
00:20:41,440 --> 00:20:44,000
this function was called

509
00:20:44,000 --> 00:20:46,480
from pipitask we could probably

510
00:20:46,480 --> 00:20:48,559
understand who orchestrates who manages

511
00:20:48,559 --> 00:20:50,720
the things who tells pp tasks who gives

512
00:20:50,720 --> 00:20:53,600
it it's we give speedy tasks the values

513
00:20:53,600 --> 00:20:55,760
that it uses to decide which functions

514
00:20:55,760 --> 00:20:56,960
to call

515
00:20:56,960 --> 00:21:00,640
and um for that um i added an ability to

516
00:21:00,640 --> 00:21:03,280
trace all the functions in the simulator

517
00:21:03,280 --> 00:21:05,440
so i could see every single function

518
00:21:05,440 --> 00:21:08,880
that is called in the simulated code how

519
00:21:08,880 --> 00:21:10,240
do we do that

520
00:21:10,240 --> 00:21:11,440
um

521
00:21:11,440 --> 00:21:13,840
if we take a look at the disassembly of

522
00:21:13,840 --> 00:21:16,240
almost every function in the compiled

523
00:21:16,240 --> 00:21:18,480
binary we can note that all of the

524
00:21:18,480 --> 00:21:20,799
functions are or most of them at least

525
00:21:20,799 --> 00:21:23,360
start with an entry instruction and we

526
00:21:23,360 --> 00:21:26,400
can take advantage of that so what i did

527
00:21:26,400 --> 00:21:29,200
i basically told the simulator whenever

528
00:21:29,200 --> 00:21:31,600
you see an entry instruction in the code

529
00:21:31,600 --> 00:21:34,320
just log the address the current program

530
00:21:34,320 --> 00:21:36,400
address the value of the pc register

531
00:21:36,400 --> 00:21:39,120
which holds the program address so

532
00:21:39,120 --> 00:21:40,960
we will have a log of all the function

533
00:21:40,960 --> 00:21:43,120
calls this is what it looks like in the

534
00:21:43,120 --> 00:21:44,799
simulator code

535
00:21:44,799 --> 00:21:46,559
you only have to care about this line

536
00:21:46,559 --> 00:21:48,799
which is highlighted so this is the

537
00:21:48,799 --> 00:21:51,039
implementation of the simulation for the

538
00:21:51,039 --> 00:21:53,360
entry instruction and when we get here

539
00:21:53,360 --> 00:21:55,840
we just look entry and we log the

540
00:21:55,840 --> 00:21:57,600
current the address of the current

541
00:21:57,600 --> 00:21:59,760
instruction i also had a script that

542
00:21:59,760 --> 00:22:02,320
would add that would read its output and

543
00:22:02,320 --> 00:22:04,320
add the name of the function next to the

544
00:22:04,320 --> 00:22:06,960
address to make this a bit more useful

545
00:22:06,960 --> 00:22:10,000
and then we finally got it

546
00:22:10,000 --> 00:22:12,960
so this is again that back trace and

547
00:22:12,960 --> 00:22:14,799
this is the look from the simulator

548
00:22:14,799 --> 00:22:16,799
where you can see all the function calls

549
00:22:16,799 --> 00:22:19,280
that happen in the simulation and i

550
00:22:19,280 --> 00:22:22,000
search for this function ie triple uh

551
00:22:22,000 --> 00:22:26,400
208 802 11 ioctl process i looked a bit

552
00:22:26,400 --> 00:22:28,480
back and then i found something called

553
00:22:28,480 --> 00:22:31,360
ppost and people post sounds like a good

554
00:22:31,360 --> 00:22:33,600
candidate it sounds like it would be a

555
00:22:33,600 --> 00:22:35,600
good name for a function that posts

556
00:22:35,600 --> 00:22:38,320
something to the queue of pptask and you

557
00:22:38,320 --> 00:22:41,440
can see it also called some uh qq

558
00:22:41,440 --> 00:22:43,919
functions down the road like uh

559
00:22:43,919 --> 00:22:46,240
coffee data to queue and start stuff

560
00:22:46,240 --> 00:22:48,320
like that so uh i did some more

561
00:22:48,320 --> 00:22:50,880
debugging and i figured out like uh the

562
00:22:50,880 --> 00:22:54,080
central dogma of the esp32 wi-fi there

563
00:22:54,080 --> 00:22:56,480
is this pp post function that gets a

564
00:22:56,480 --> 00:22:59,760
task id and it sends it to some queue

565
00:22:59,760 --> 00:23:02,799
and then it this what this tells pptask

566
00:23:02,799 --> 00:23:06,000
what do that to do next next so pptask

567
00:23:06,000 --> 00:23:07,919
is running all the wi-fi logic and pp

568
00:23:07,919 --> 00:23:09,840
post controls that

569
00:23:09,840 --> 00:23:12,080
and you might notice that the person who

570
00:23:12,080 --> 00:23:13,840
wrote this wasn't very good with

571
00:23:13,840 --> 00:23:16,960
following naming conventions

572
00:23:16,960 --> 00:23:19,600
anyways now with that knowledge we can

573
00:23:19,600 --> 00:23:22,559
go back to pptask and go back to ask

574
00:23:22,559 --> 00:23:26,080
herself okay so we know that uh

575
00:23:26,080 --> 00:23:28,240
this function is called when pptask

576
00:23:28,240 --> 00:23:30,720
received 11 hexa but

577
00:23:30,720 --> 00:23:33,679
and we know now that ppost can tell

578
00:23:33,679 --> 00:23:36,960
pptask what to do so somebody must call

579
00:23:36,960 --> 00:23:40,480
pb post with 11 hexa at some point but

580
00:23:40,480 --> 00:23:41,919
who did that

581
00:23:41,919 --> 00:23:43,440
so uh

582
00:23:43,440 --> 00:23:45,279
gdp has the answer

583
00:23:45,279 --> 00:23:48,240
um we can set up um

584
00:23:48,240 --> 00:23:50,640
a conditional breakpoint telling gdb

585
00:23:50,640 --> 00:23:53,679
break on in gpp post only if the

586
00:23:53,679 --> 00:23:55,919
parameter that is stored in this uh

587
00:23:55,919 --> 00:23:59,360
register a10 if it's 11 hexa to figure

588
00:23:59,360 --> 00:24:02,559
out uh what makes uh who calls pv post

589
00:24:02,559 --> 00:24:04,320
with this value and get us to this

590
00:24:04,320 --> 00:24:05,919
switch statement

591
00:24:05,919 --> 00:24:08,720
and i ran this on the physical esp32

592
00:24:08,720 --> 00:24:10,640
device i

593
00:24:10,640 --> 00:24:13,279
i got the uh

594
00:24:13,279 --> 00:24:15,679
backrace and i could see that it was

595
00:24:15,679 --> 00:24:18,000
like the chain of the events that called

596
00:24:18,000 --> 00:24:21,039
the pb post with 11 but the thing is we

597
00:24:21,039 --> 00:24:23,679
get back to pptask so it's like going

598
00:24:23,679 --> 00:24:25,200
back and forth

599
00:24:25,200 --> 00:24:27,600
this time pipitas called another

600
00:24:27,600 --> 00:24:30,799
function w dev process r exact data all

601
00:24:30,799 --> 00:24:32,480
um and i was like

602
00:24:32,480 --> 00:24:35,120
okay so pipitas called this function and

603
00:24:35,120 --> 00:24:37,760
they called pb post and then this goes

604
00:24:37,760 --> 00:24:40,880
back to pptask that's a bit confusing

605
00:24:40,880 --> 00:24:43,840
anyway i went back to the code of pptask

606
00:24:43,840 --> 00:24:46,640
and i saw uh in which case in the big

607
00:24:46,640 --> 00:24:48,799
swift statement it caused this function

608
00:24:48,799 --> 00:24:51,039
that i have seen in the stack race this

609
00:24:51,039 --> 00:24:53,840
w dev process rx data all

610
00:24:53,840 --> 00:24:56,720
and i noticed it calls it when it gets

611
00:24:56,720 --> 00:25:01,520
19 hexa so um i used back there i used

612
00:25:01,520 --> 00:25:04,240
again the same technique of asking gdb

613
00:25:04,240 --> 00:25:07,200
okay who sends us this 19 hexa

614
00:25:07,200 --> 00:25:10,000
um can you please set a breakpoint on pb

615
00:25:10,000 --> 00:25:12,720
pose but only if the parameter is 19

616
00:25:12,720 --> 00:25:13,760
hexa

617
00:25:13,760 --> 00:25:17,600
and so i did and you can see uh i ran it

618
00:25:17,600 --> 00:25:21,600
on the physical uh hardware uh and it

619
00:25:21,600 --> 00:25:23,200
hit a breakpoint i looked at the

620
00:25:23,200 --> 00:25:26,000
backrest and this time the brake race is

621
00:25:26,000 --> 00:25:27,120
ending with

622
00:25:27,120 --> 00:25:29,919
low int 1 which is the interrupt handler

623
00:25:29,919 --> 00:25:32,559
so this function is called by the

624
00:25:32,559 --> 00:25:34,480
hardware when the hardware generates

625
00:25:34,480 --> 00:25:36,000
some interrupt

626
00:25:36,000 --> 00:25:39,360
and at that point we can start piecing

627
00:25:39,360 --> 00:25:41,440
this information together

628
00:25:41,440 --> 00:25:44,640
all these small stack races that we got

629
00:25:44,640 --> 00:25:48,080
and build the rx frame story what

630
00:25:48,080 --> 00:25:50,799
happens which functions uh are called

631
00:25:50,799 --> 00:25:53,679
when there is uh when the hardware

632
00:25:53,679 --> 00:25:56,000
has a new frame to uh that has been

633
00:25:56,000 --> 00:25:57,679
received over the air and it wants to

634
00:25:57,679 --> 00:26:00,080
tell the code hey look at that frame

635
00:26:00,080 --> 00:26:02,960
and we have all these stack trays and at

636
00:26:02,960 --> 00:26:04,880
that point i spent a lot of time

637
00:26:04,880 --> 00:26:07,440
debugging all of these functions uh for

638
00:26:07,440 --> 00:26:09,279
instance figuring out

639
00:26:09,279 --> 00:26:11,760
how the code knows what happened like it

640
00:26:11,760 --> 00:26:13,600
gets an interrupt then it has to look

641
00:26:13,600 --> 00:26:15,440
into some register to figure out is

642
00:26:15,440 --> 00:26:17,520
there a new packet of it is there a new

643
00:26:17,520 --> 00:26:20,080
frame wi-fi frame available or maybe we

644
00:26:20,080 --> 00:26:22,159
just finished transmitting an existing

645
00:26:22,159 --> 00:26:24,400
frame or did we have an error

646
00:26:24,400 --> 00:26:25,919
so i

647
00:26:25,919 --> 00:26:28,480
spent a couple of nights just digging

648
00:26:28,480 --> 00:26:30,240
into all these functions in the stack

649
00:26:30,240 --> 00:26:31,600
race

650
00:26:31,600 --> 00:26:33,760
and eventually i figured out there is

651
00:26:33,760 --> 00:26:36,640
another register which gets a

652
00:26:36,640 --> 00:26:39,520
pointer to a dma buffer and this tells

653
00:26:39,520 --> 00:26:42,400
the hardware uh it's ready that the code

654
00:26:42,400 --> 00:26:44,480
is ready to receive the next frame and

655
00:26:44,480 --> 00:26:46,880
then when there is uh when the next

656
00:26:46,880 --> 00:26:48,720
frame is available when it's been

657
00:26:48,720 --> 00:26:51,919
received then the hardware just uh sets

658
00:26:51,919 --> 00:26:54,159
a bit in this event register and files

659
00:26:54,159 --> 00:26:56,799
the interrupt and the code can read the

660
00:26:56,799 --> 00:26:57,600
uh

661
00:26:57,600 --> 00:26:59,360
frame that has been received from the

662
00:26:59,360 --> 00:27:02,320
dma buffer so at this point

663
00:27:02,320 --> 00:27:04,880
uh we i sort of have the goal figured

664
00:27:04,880 --> 00:27:07,679
out and i at least know knew which

665
00:27:07,679 --> 00:27:10,480
registers are relevant for sending data

666
00:27:10,480 --> 00:27:13,440
over there and receiving data and how to

667
00:27:13,440 --> 00:27:14,640
use them

668
00:27:14,640 --> 00:27:17,760
and let me show you what it enabled us

669
00:27:17,760 --> 00:27:20,640
to do so we are going back to walkway

670
00:27:20,640 --> 00:27:23,279
but this time we are going to use a bit

671
00:27:23,279 --> 00:27:26,799
more complicated example

672
00:27:26,799 --> 00:27:30,720
this code example has uh still neopixels

673
00:27:30,720 --> 00:27:34,480
and then esp32 but it also uh tries to

674
00:27:34,480 --> 00:27:37,760
connect to the wi-fi and to an mqtt

675
00:27:37,760 --> 00:27:41,200
broker and then uh it lists the listens

676
00:27:41,200 --> 00:27:43,919
for messages from the mbq2t broker and

677
00:27:43,919 --> 00:27:45,679
whenever he gets a message from the

678
00:27:45,679 --> 00:27:48,720
mqutd worker broker

679
00:27:48,720 --> 00:27:51,279
it parses it with the ujson library as a

680
00:27:51,279 --> 00:27:54,000
json and uses the values from that

681
00:27:54,000 --> 00:27:56,240
message to fill the pixels in this new

682
00:27:56,240 --> 00:27:57,760
pixel ring

683
00:27:57,760 --> 00:28:00,640
um let's just see it in action i'm going

684
00:28:00,640 --> 00:28:03,039
to run it and by the way while i'm

685
00:28:03,039 --> 00:28:05,360
running it you can uh there is a link at

686
00:28:05,360 --> 00:28:07,279
the end of the document so if you opened

687
00:28:07,279 --> 00:28:09,200
it i see there are a few people you can

688
00:28:09,200 --> 00:28:11,679
even try it yourself so i'm going to

689
00:28:11,679 --> 00:28:15,279
start a simulation and let's minimize

690
00:28:15,279 --> 00:28:18,080
this window so now it's connecting to

691
00:28:18,080 --> 00:28:20,559
the wi-fi and on the right hand i'm

692
00:28:20,559 --> 00:28:23,520
going to connect to the mqtt broker

693
00:28:23,520 --> 00:28:26,000
and the code says it's connected to this

694
00:28:26,000 --> 00:28:28,880
mqtt debugger on the internet and i'm

695
00:28:28,880 --> 00:28:31,600
going to publish to the remote icon uh

696
00:28:31,600 --> 00:28:34,000
this message and you can see as soon as

697
00:28:34,000 --> 00:28:37,360
i send it to the mqtt broken it broker

698
00:28:37,360 --> 00:28:39,120
it went through the internet and the

699
00:28:39,120 --> 00:28:42,399
code got this incoming message um

700
00:28:42,399 --> 00:28:44,640
so now if anyone wants to try and send a

701
00:28:44,640 --> 00:28:46,399
message to this uh

702
00:28:46,399 --> 00:28:49,279
cue you are welcome um you have like

703
00:28:49,279 --> 00:28:51,520
five seconds to try this let's send

704
00:28:51,520 --> 00:28:52,720
another one

705
00:28:52,720 --> 00:28:55,120
and um

706
00:28:55,120 --> 00:28:59,279
so yeah and this is like uh finally

707
00:28:59,279 --> 00:29:01,440
people will be able to use wi-fi in the

708
00:29:01,440 --> 00:29:04,720
simulation as they wanted but it's

709
00:29:04,720 --> 00:29:06,559
much more powerful than that for

710
00:29:06,559 --> 00:29:09,840
instance i can open the developer tools

711
00:29:09,840 --> 00:29:11,520
wait a second

712
00:29:11,520 --> 00:29:13,520
yeah nobody is sending messages to the

713
00:29:13,520 --> 00:29:16,399
queue too bad anyway i can open the

714
00:29:16,399 --> 00:29:19,039
developer tools and uh there will be a

715
00:29:19,039 --> 00:29:21,279
better user interface for that but i can

716
00:29:21,279 --> 00:29:24,320
download a capture file and see all the

717
00:29:24,320 --> 00:29:27,600
frames that went into this simulated

718
00:29:27,600 --> 00:29:30,320
uh to the simulations let's just uh

719
00:29:30,320 --> 00:29:33,440
narrow it down to mqtt so i can see all

720
00:29:33,440 --> 00:29:35,919
the mqtt transactions all the packets

721
00:29:35,919 --> 00:29:38,240
like the ip the tcp

722
00:29:38,240 --> 00:29:40,880
and you know uh if you are going to

723
00:29:40,880 --> 00:29:43,200
learn about networks i think this is

724
00:29:43,200 --> 00:29:45,600
going to be a very useful tool but at

725
00:29:45,600 --> 00:29:48,320
least i personally love it so

726
00:29:48,320 --> 00:29:50,799
um to summarize

727
00:29:50,799 --> 00:29:52,240
um

728
00:29:52,240 --> 00:29:56,080
we have used uh three tools um that was

729
00:29:56,080 --> 00:30:00,080
a a pretty high level overview of my uh

730
00:30:00,080 --> 00:30:02,480
my approach to reverse engineering with

731
00:30:02,480 --> 00:30:06,000
gidra to decompile and do some static

732
00:30:06,000 --> 00:30:08,559
analysis without it it would have been a

733
00:30:08,559 --> 00:30:10,880
nightmare to understand what all these

734
00:30:10,880 --> 00:30:13,840
functions like pptask do believe me i

735
00:30:13,840 --> 00:30:14,880
tried

736
00:30:14,880 --> 00:30:17,600
we used gdb for focused runtime

737
00:30:17,600 --> 00:30:20,080
debugging so setting breakpoints looking

738
00:30:20,080 --> 00:30:22,159
at the values of variables the stack

739
00:30:22,159 --> 00:30:25,120
traces and we also modified a simulator

740
00:30:25,120 --> 00:30:28,399
code to allow us to debug the uh how the

741
00:30:28,399 --> 00:30:31,440
this the code in runtime but in a wider

742
00:30:31,440 --> 00:30:35,600
manner it allowed us to see how the code

743
00:30:35,600 --> 00:30:36,559
writes

744
00:30:36,559 --> 00:30:38,880
all like do things like see all the

745
00:30:38,880 --> 00:30:40,640
function calls that happens in the

746
00:30:40,640 --> 00:30:42,240
simulation or

747
00:30:42,240 --> 00:30:44,240
all the memory reads and writes to a

748
00:30:44,240 --> 00:30:46,480
specific region things that gdb wouldn't

749
00:30:46,480 --> 00:30:48,480
let us do efficiently

750
00:30:48,480 --> 00:30:50,880
and there is a lot more this is just we

751
00:30:50,880 --> 00:30:53,039
have just scratched the surface um

752
00:30:53,039 --> 00:30:54,320
they're like

753
00:30:54,320 --> 00:30:57,440
other tools that or uh other ways that i

754
00:30:57,440 --> 00:30:59,919
did there are other ways uh

755
00:30:59,919 --> 00:31:02,240
and techniques that i used and if you

756
00:31:02,240 --> 00:31:04,480
want to hear about them then you maybe

757
00:31:04,480 --> 00:31:07,440
want you may want to ask hackaday uh to

758
00:31:07,440 --> 00:31:09,919
organize a course or a longer session

759
00:31:09,919 --> 00:31:11,200
about that

760
00:31:11,200 --> 00:31:13,360
um so i hope you enjoyed thank you for

761
00:31:13,360 --> 00:31:16,000
joining me a bit for to learn a bit

762
00:31:16,000 --> 00:31:18,480
about my reverse engineering journey and

763
00:31:18,480 --> 00:31:22,840
see you on discord bye bye

