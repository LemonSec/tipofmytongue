1
00:00:04,880 --> 00:00:08,000
hey everybody and welcome to the 2021

2
00:00:08,000 --> 00:00:10,639
hackaday remoticon i'm elliott williams

3
00:00:10,639 --> 00:00:12,960
i'm managing editor of hackaday

4
00:00:12,960 --> 00:00:15,280
this year we've got three keynotes not

5
00:00:15,280 --> 00:00:18,240
one not two but three and they span

6
00:00:18,240 --> 00:00:21,760
software hardware and hard science

7
00:00:21,760 --> 00:00:24,400
first up today we'll start with software

8
00:00:24,400 --> 00:00:27,119
or should i say firmware

9
00:00:27,119 --> 00:00:30,880
because our speaker is elisia white she

10
00:00:30,880 --> 00:00:34,559
is an embedded engineer extraordinaire

11
00:00:34,559 --> 00:00:37,360
she's written the book on it basically

12
00:00:37,360 --> 00:00:40,399
she's written making embedded systems

13
00:00:40,399 --> 00:00:43,440
she's held down the embedded fm podcast

14
00:00:43,440 --> 00:00:46,239
for a very long time now

15
00:00:46,239 --> 00:00:49,680
and we are super happy to be able to

16
00:00:49,680 --> 00:00:53,280
share her hard-earned expertise with you

17
00:00:53,280 --> 00:00:55,520
to help guide you through one of the

18
00:00:55,520 --> 00:00:58,960
really dark corners of microcontrollers

19
00:00:58,960 --> 00:01:01,520
the memory map and so without further

20
00:01:01,520 --> 00:01:03,840
ado i would like to present you alicia

21
00:01:03,840 --> 00:01:06,400
white so happy to be here and thank you

22
00:01:06,400 --> 00:01:09,360
for that introduction

23
00:01:09,439 --> 00:01:12,400
let me share my screen

24
00:01:12,400 --> 00:01:13,280
okay

25
00:01:13,280 --> 00:01:15,040
if you are not seeing what looks like

26
00:01:15,040 --> 00:01:17,759
the first slide in a slide deck

27
00:01:17,759 --> 00:01:19,840
i don't know none of you can talk so

28
00:01:19,840 --> 00:01:21,840
here it goes

29
00:01:21,840 --> 00:01:24,080
i am here to talk about map files and

30
00:01:24,080 --> 00:01:25,600
memory and

31
00:01:25,600 --> 00:01:28,159
as eliot said i have a podcast and a

32
00:01:28,159 --> 00:01:29,119
book

33
00:01:29,119 --> 00:01:31,280
i've been an embedded software engineer

34
00:01:31,280 --> 00:01:33,360
for a couple of decades

35
00:01:33,360 --> 00:01:36,159
i have been thinking a lot lately about

36
00:01:36,159 --> 00:01:37,840
how we teach things

37
00:01:37,840 --> 00:01:39,439
i'm working on an online course about

38
00:01:39,439 --> 00:01:40,880
developing embedded software

39
00:01:40,880 --> 00:01:43,040
professionally and there were so many

40
00:01:43,040 --> 00:01:44,880
lectures i'd start with grand ideas of

41
00:01:44,880 --> 00:01:46,880
explaining bootloaders and pointers and

42
00:01:46,880 --> 00:01:48,560
state machines and it would all be

43
00:01:48,560 --> 00:01:50,720
glorious and fun like my talk about map

44
00:01:50,720 --> 00:01:52,159
files

45
00:01:52,159 --> 00:01:53,920
and at some point bleary-eyed and

46
00:01:53,920 --> 00:01:56,320
frustrated i would think look not

47
00:01:56,320 --> 00:01:58,159
everything can be as fascinating as map

48
00:01:58,159 --> 00:01:59,360
files are

49
00:01:59,360 --> 00:02:00,719
which when i say it aloud sounds

50
00:02:00,719 --> 00:02:02,640
ridiculous

51
00:02:02,640 --> 00:02:04,960
well let me share my view of memory maps

52
00:02:04,960 --> 00:02:05,920
with you

53
00:02:05,920 --> 00:02:07,759
and then we can figure out how to make

54
00:02:07,759 --> 00:02:10,318
the rest of embedded systems more fun to

55
00:02:10,318 --> 00:02:12,319
learn and to teach

56
00:02:12,319 --> 00:02:14,000
and if you don't know where a map file

57
00:02:14,000 --> 00:02:15,760
comes from or how it's built stick

58
00:02:15,760 --> 00:02:17,520
around we will get there

59
00:02:17,520 --> 00:02:19,040
before that i want to show you how

60
00:02:19,040 --> 00:02:21,440
awesome they are and why it's worth

61
00:02:21,440 --> 00:02:23,920
digging through your folders to find the

62
00:02:23,920 --> 00:02:26,319
file

63
00:02:29,280 --> 00:02:32,080
map files show you the memory layout of

64
00:02:32,080 --> 00:02:34,640
your system they depend on your compiler

65
00:02:34,640 --> 00:02:36,400
linker and processor

66
00:02:36,400 --> 00:02:38,400
and what i show you won't be exactly

67
00:02:38,400 --> 00:02:40,319
what you see on your system

68
00:02:40,319 --> 00:02:42,879
i want to give you landmarks

69
00:02:42,879 --> 00:02:44,959
to look for i want you to have a map for

70
00:02:44,959 --> 00:02:47,280
exploring your own map file

71
00:02:47,280 --> 00:02:49,760
there are many ways of looking at memory

72
00:02:49,760 --> 00:02:52,160
layout in your microcontroller system

73
00:02:52,160 --> 00:02:53,920
some are here but let's look at my

74
00:02:53,920 --> 00:02:56,560
favorite a little more closely

75
00:02:56,560 --> 00:02:59,280
on the left you can see how much we have

76
00:02:59,280 --> 00:03:01,760
of each type of memory my system here is

77
00:03:01,760 --> 00:03:04,640
a simple chip just two types flash and

78
00:03:04,640 --> 00:03:05,680
ram

79
00:03:05,680 --> 00:03:07,760
and this is the sort of memory layout on

80
00:03:07,760 --> 00:03:09,440
the left that you might find in your

81
00:03:09,440 --> 00:03:11,519
processor's data sheet

82
00:03:11,519 --> 00:03:13,760
on the right is where i've put the

83
00:03:13,760 --> 00:03:15,760
memory what i've put into the memory

84
00:03:15,760 --> 00:03:17,840
i've drawn it out in rows so i can see

85
00:03:17,840 --> 00:03:20,159
the ordering and what touches

86
00:03:20,159 --> 00:03:22,080
there's my code the constants the

87
00:03:22,080 --> 00:03:24,319
initializers for my globals some memory

88
00:03:24,319 --> 00:03:26,720
to grow into a little flash storage

89
00:03:26,720 --> 00:03:27,599
block

90
00:03:27,599 --> 00:03:29,680
maybe more like a database than a file

91
00:03:29,680 --> 00:03:30,720
system

92
00:03:30,720 --> 00:03:32,560
but some place to

93
00:03:32,560 --> 00:03:35,200
keep my serial number uh security keys

94
00:03:35,200 --> 00:03:37,440
and manufacturing data

95
00:03:37,440 --> 00:03:39,360
and since i want to be able to change my

96
00:03:39,360 --> 00:03:40,400
firmware

97
00:03:40,400 --> 00:03:43,440
i have a fixed bootloader to do that

98
00:03:43,440 --> 00:03:46,879
in ram i have actual globals a heap for

99
00:03:46,879 --> 00:03:49,040
any dynamic memory allocation and a

100
00:03:49,040 --> 00:03:50,000
stack

101
00:03:50,000 --> 00:03:52,159
with an rtos and operating system with

102
00:03:52,159 --> 00:03:54,239
multiple threads i'd have multiple heaps

103
00:03:54,239 --> 00:03:55,599
and stacks

104
00:03:55,599 --> 00:03:57,519
i like looking at memory this way it's

105
00:03:57,519 --> 00:03:59,920
worth sketching out early in the design

106
00:03:59,920 --> 00:04:02,080
to make a plan about where things will

107
00:04:02,080 --> 00:04:04,640
be and set expectations about how much

108
00:04:04,640 --> 00:04:07,120
code you can put in your processor but

109
00:04:07,120 --> 00:04:09,040
these are big sections the bird's eye

110
00:04:09,040 --> 00:04:11,439
view and they don't let us dig into what

111
00:04:11,439 --> 00:04:12,879
we need when we get to the

112
00:04:12,879 --> 00:04:15,840
implementation stage

113
00:04:16,478 --> 00:04:19,839
so why why do we need more detail as we

114
00:04:19,839 --> 00:04:21,358
do development

115
00:04:21,358 --> 00:04:23,199
now files can help with lots of problems

116
00:04:23,199 --> 00:04:25,199
there are tools amazing tools to help

117
00:04:25,199 --> 00:04:27,120
you solve these problems

118
00:04:27,120 --> 00:04:28,720
but we'll get back here in more detail

119
00:04:28,720 --> 00:04:30,639
first let's walk through an actual map

120
00:04:30,639 --> 00:04:32,880
file

121
00:04:33,440 --> 00:04:35,120
i want to look through

122
00:04:35,120 --> 00:04:37,600
an example program called hello this is

123
00:04:37,600 --> 00:04:39,840
for a ti chip that can use ble and

124
00:04:39,840 --> 00:04:42,080
zigbee and it was compiled with code

125
00:04:42,080 --> 00:04:43,600
composer studio

126
00:04:43,600 --> 00:04:48,000
it uses ti's rtos which is called bios

127
00:04:48,000 --> 00:04:49,919
it has a main that prints hello world

128
00:04:49,919 --> 00:04:51,120
and exits

129
00:04:51,120 --> 00:04:53,040
now there's a bit more going on with the

130
00:04:53,040 --> 00:04:55,520
init so that our system printf actually

131
00:04:55,520 --> 00:04:57,199
goes someplace

132
00:04:57,199 --> 00:04:58,720
and then there's the operating system

133
00:04:58,720 --> 00:05:01,840
piece bios exit and it it looks simple

134
00:05:01,840 --> 00:05:03,600
but it's an embedded system even

135
00:05:03,600 --> 00:05:07,520
printing hello world isn't really simple

136
00:05:07,520 --> 00:05:09,520
i'm going to switch over to the map file

137
00:05:09,520 --> 00:05:10,720
now

138
00:05:10,720 --> 00:05:12,560
and having someone else scroll through

139
00:05:12,560 --> 00:05:14,160
this would be tough for me so if you

140
00:05:14,160 --> 00:05:16,000
want to scroll your own speed you can

141
00:05:16,000 --> 00:05:17,759
find these files on my website at

142
00:05:17,759 --> 00:05:20,400
embedded fm or i dropped them into the

143
00:05:20,400 --> 00:05:21,919
discord link for those of you watching

144
00:05:21,919 --> 00:05:23,600
live

145
00:05:23,600 --> 00:05:25,039
and for those of you who know a bit

146
00:05:25,039 --> 00:05:26,639
about map files i'll put the linker file

147
00:05:26,639 --> 00:05:28,320
on the right so you can see if you can

148
00:05:28,320 --> 00:05:30,240
connect them but if you hear from map

149
00:05:30,240 --> 00:05:32,160
files ignore that window

150
00:05:32,160 --> 00:05:35,039
so let's take a look at this map file

151
00:05:35,039 --> 00:05:37,120
for a moment or two

152
00:05:37,120 --> 00:05:41,919
it's a wall of hex it's not nice lucky

153
00:05:43,600 --> 00:05:45,360
reading some of it the memory

154
00:05:45,360 --> 00:05:48,000
configuration so far so good

155
00:05:48,000 --> 00:05:50,000
flash and ram

156
00:05:50,000 --> 00:05:54,240
gpram has attributes like flash

157
00:05:54,240 --> 00:05:56,800
and the name says ram so

158
00:05:56,800 --> 00:05:59,120
probably some sort of ram

159
00:05:59,120 --> 00:06:01,039
we could look it up search on google the

160
00:06:01,039 --> 00:06:04,160
processor name and gpram and discover

161
00:06:04,160 --> 00:06:05,280
it

162
00:06:05,280 --> 00:06:07,919
it's a cache but right now we don't care

163
00:06:07,919 --> 00:06:09,759
we just want a bit of orientation with

164
00:06:09,759 --> 00:06:11,680
this map file

165
00:06:11,680 --> 00:06:14,160
the segment allocation map it's not a

166
00:06:14,160 --> 00:06:16,160
good name better to think of it as a

167
00:06:16,160 --> 00:06:18,080
summary

168
00:06:18,080 --> 00:06:20,479
uh we can look at what these addresses

169
00:06:20,479 --> 00:06:22,960
really are

170
00:06:22,960 --> 00:06:24,479
this is flash we know that from the

171
00:06:24,479 --> 00:06:26,720
address right above it says zero zero is

172
00:06:26,720 --> 00:06:27,919
flash

173
00:06:27,919 --> 00:06:30,400
it has different data segments text

174
00:06:30,400 --> 00:06:33,440
const c in it reset back

175
00:06:33,440 --> 00:06:35,039
you can guess what these are or maybe

176
00:06:35,039 --> 00:06:37,759
google them though i'll warn you text

177
00:06:37,759 --> 00:06:39,440
means code because when you see that a

178
00:06:39,440 --> 00:06:42,160
lot and it's important

179
00:06:42,160 --> 00:06:45,440
we can also see where our ram is

180
00:06:45,440 --> 00:06:47,360
again just based on the address this has

181
00:06:47,360 --> 00:06:49,039
different segments as well

182
00:06:49,039 --> 00:06:52,800
data heap bss data again stack

183
00:06:52,800 --> 00:06:55,199
keep in stack makes sense

184
00:06:55,199 --> 00:06:58,319
bss and data we'll see a lot more of

185
00:06:58,319 --> 00:07:00,639
as i scroll down these things get broken

186
00:07:00,639 --> 00:07:03,280
into more and more detail

187
00:07:03,280 --> 00:07:05,120
zooming in on the contents of the

188
00:07:05,120 --> 00:07:06,319
different set

189
00:07:06,319 --> 00:07:08,160
different sections

190
00:07:08,160 --> 00:07:10,319
and don't read everything look mostly at

191
00:07:10,319 --> 00:07:11,759
the left side of the screen with the

192
00:07:11,759 --> 00:07:14,759
sections

193
00:07:17,599 --> 00:07:19,280
and wherever there's a bit more white

194
00:07:19,280 --> 00:07:22,160
space like here expect something to be a

195
00:07:22,160 --> 00:07:24,479
little more interesting

196
00:07:24,479 --> 00:07:27,360
with bss and data these are in ram

197
00:07:27,360 --> 00:07:31,599
for either one if we looked at the

198
00:07:31,599 --> 00:07:33,360
symbols on the right side when they were

199
00:07:33,360 --> 00:07:34,560
on the screen

200
00:07:34,560 --> 00:07:36,000
and we wrote this code we might see a

201
00:07:36,000 --> 00:07:38,240
global variable name we recognize

202
00:07:38,240 --> 00:07:40,639
but let's go on to text these are going

203
00:07:40,639 --> 00:07:42,400
to be function names this is where your

204
00:07:42,400 --> 00:07:45,440
code really lives in the chips flash

205
00:07:45,440 --> 00:07:48,000
the first column is the start address

206
00:07:48,000 --> 00:07:50,720
the second column is the length of that

207
00:07:50,720 --> 00:07:54,160
function in flash

208
00:07:55,599 --> 00:07:57,680
if you get a crash and your back trace

209
00:07:57,680 --> 00:08:02,479
says it was a 300 0 000 300

210
00:08:02,479 --> 00:08:04,560
looking here we can see that it must be

211
00:08:04,560 --> 00:08:09,840
in the power sleep function on line 157

212
00:08:11,680 --> 00:08:14,400
scrolling down this goes on for a good

213
00:08:14,400 --> 00:08:16,800
long time and i have to wonder how much

214
00:08:16,800 --> 00:08:19,120
of this we don't really need to run how

215
00:08:19,120 --> 00:08:21,520
many bytes of flash we could get back if

216
00:08:21,520 --> 00:08:24,479
we needed them to do more useful work

217
00:08:24,479 --> 00:08:27,599
oh oh 353 uh something new white space

218
00:08:27,599 --> 00:08:29,440
really does make this easier these are

219
00:08:29,440 --> 00:08:33,320
const constants uh for example line

220
00:08:33,320 --> 00:08:35,200
365

221
00:08:35,200 --> 00:08:38,640
uh board gpio init table

222
00:08:38,640 --> 00:08:41,679
this is a piece of memory that sets up

223
00:08:41,679 --> 00:08:44,240
the gpio on init and

224
00:08:44,240 --> 00:08:46,080
in the source file it's marked with the

225
00:08:46,080 --> 00:08:48,720
const keyword

226
00:08:48,720 --> 00:08:51,760
that's all this is it's not magic

227
00:08:51,760 --> 00:08:53,200
so we're getting down to the module

228
00:08:53,200 --> 00:08:55,920
summary which takes objects of each type

229
00:08:55,920 --> 00:08:57,040
of memory

230
00:08:57,040 --> 00:09:00,880
read write read only code

231
00:09:00,880 --> 00:09:02,000
and so now we're getting into some

232
00:09:02,000 --> 00:09:05,279
seriously mangled names they're

233
00:09:05,279 --> 00:09:07,040
actually not important

234
00:09:07,040 --> 00:09:08,320
and i'm less than a third of the way

235
00:09:08,320 --> 00:09:10,880
through this file

236
00:09:10,880 --> 00:09:13,040
well now we're getting into the

237
00:09:13,040 --> 00:09:15,440
uh symbols ram and flash are being

238
00:09:15,440 --> 00:09:17,120
sorted alphabetically

239
00:09:17,120 --> 00:09:20,399
sure good scroll faster

240
00:09:20,399 --> 00:09:22,160
no seriously scroll faster we'll be here

241
00:09:22,160 --> 00:09:24,240
all day if you don't

242
00:09:24,240 --> 00:09:25,360
okay

243
00:09:25,360 --> 00:09:26,959
uh

244
00:09:26,959 --> 00:09:29,279
these are just the functions and the

245
00:09:29,279 --> 00:09:31,360
variables by name alphabetically that's

246
00:09:31,360 --> 00:09:32,880
all and now we're going to get them

247
00:09:32,880 --> 00:09:36,000
sorted by address it's truly the same

248
00:09:36,000 --> 00:09:37,360
information

249
00:09:37,360 --> 00:09:39,279
it's repeated from other places this is

250
00:09:39,279 --> 00:09:40,560
the third time we've seen this

251
00:09:40,560 --> 00:09:41,680
information

252
00:09:41,680 --> 00:09:43,279
there's a lot of stuff here but you

253
00:09:43,279 --> 00:09:45,120
don't need to read the file from start

254
00:09:45,120 --> 00:09:46,160
to finish

255
00:09:46,160 --> 00:09:48,080
it's not that kind of document a map

256
00:09:48,080 --> 00:09:50,080
file is a reference book like an

257
00:09:50,080 --> 00:09:52,320
encyclopedia not a novel

258
00:09:52,320 --> 00:09:54,399
and that is step one to understanding

259
00:09:54,399 --> 00:09:55,680
the map files

260
00:09:55,680 --> 00:09:58,160
use them but don't read them

261
00:09:58,160 --> 00:09:59,920
don't get too bogged down in the details

262
00:09:59,920 --> 00:10:01,360
don't worry about all the things you

263
00:10:01,360 --> 00:10:02,399
don't know

264
00:10:02,399 --> 00:10:05,519
figure out what you need and go on

265
00:10:05,519 --> 00:10:07,200
there's a lot of duplication in the map

266
00:10:07,200 --> 00:10:08,800
files which makes it handy to find

267
00:10:08,800 --> 00:10:10,880
certain types of memory corruption but

268
00:10:10,880 --> 00:10:14,160
it makes the files seem very long

269
00:10:14,160 --> 00:10:17,040
uh okay so now here at

270
00:10:17,040 --> 00:10:18,560
2098

271
00:10:18,560 --> 00:10:19,839
i have a global variable that's being

272
00:10:19,839 --> 00:10:23,040
corrupted um say in my code and i notice

273
00:10:23,040 --> 00:10:25,600
that it it isn't the value i think it

274
00:10:25,600 --> 00:10:26,480
should be

275
00:10:26,480 --> 00:10:28,640
say it's parm buff

276
00:10:28,640 --> 00:10:30,320
so now one of the things i can do with

277
00:10:30,320 --> 00:10:32,959
the memory map is look what's around it

278
00:10:32,959 --> 00:10:35,519
uh see what's being what could possibly

279
00:10:35,519 --> 00:10:37,760
happen to my parm buff we have pin

280
00:10:37,760 --> 00:10:40,240
handle table there

281
00:10:40,240 --> 00:10:42,640
above perm buff um if it's writing

282
00:10:42,640 --> 00:10:46,320
beyond its memory that might explain the

283
00:10:46,320 --> 00:10:48,079
corruption i'm seeing in the variable of

284
00:10:48,079 --> 00:10:49,519
interest

285
00:10:49,519 --> 00:10:51,200
walking through files like this though

286
00:10:51,200 --> 00:10:54,000
is not the best way to use a memory map

287
00:10:54,000 --> 00:10:56,320
usually i just searched for parm buff

288
00:10:56,320 --> 00:10:57,680
until i found something worth

289
00:10:57,680 --> 00:11:00,680
investigating

290
00:11:04,720 --> 00:11:07,440
but that was a very simple map file

291
00:11:07,440 --> 00:11:08,880
let's look at another map file very

292
00:11:08,880 --> 00:11:10,320
briefly

293
00:11:10,320 --> 00:11:14,720
uh hello was 2100

294
00:11:14,720 --> 00:11:16,240
lines long

295
00:11:16,240 --> 00:11:18,160
this next one is for a system that does

296
00:11:18,160 --> 00:11:19,440
a lot more

297
00:11:19,440 --> 00:11:22,240
including interfacing with both ble and

298
00:11:22,240 --> 00:11:25,519
zigbee it also is loaded by bootloader

299
00:11:25,519 --> 00:11:27,839
which is compiled separately so we don't

300
00:11:27,839 --> 00:11:30,720
see that in our map file

301
00:11:30,720 --> 00:11:32,640
the top looks similar

302
00:11:32,640 --> 00:11:34,959
and scrolling down it still looks pretty

303
00:11:34,959 --> 00:11:36,000
similar

304
00:11:36,000 --> 00:11:36,880
but

305
00:11:36,880 --> 00:11:38,320
i'm not going to go through all of this

306
00:11:38,320 --> 00:11:39,279
again

307
00:11:39,279 --> 00:11:41,040
i think maybe we just need to scroll a

308
00:11:41,040 --> 00:11:42,399
lot faster

309
00:11:42,399 --> 00:11:45,279
in fact let's just scroll to the end

310
00:11:45,279 --> 00:11:48,720
this one is 14 034 lines long much

311
00:11:48,720 --> 00:11:50,639
longer than the other but it's still

312
00:11:50,639 --> 00:11:52,240
full of repetition

313
00:11:52,240 --> 00:11:54,320
and really i want to look at a more

314
00:11:54,320 --> 00:11:57,760
interesting map file

315
00:11:57,760 --> 00:11:59,440
let's look at one

316
00:11:59,440 --> 00:12:03,920
let's look at one for an imaginary chip

317
00:12:04,800 --> 00:12:06,800
it still has memory configuration as we

318
00:12:06,800 --> 00:12:08,000
saw before

319
00:12:08,000 --> 00:12:09,920
and a summary these are in the middle

320
00:12:09,920 --> 00:12:12,000
now instead of at the top of the file

321
00:12:12,000 --> 00:12:14,079
the ordering of map files is often

322
00:12:14,079 --> 00:12:17,360
arbitrary depending on the build tools

323
00:12:17,360 --> 00:12:20,399
let's look at ramlandia we saw bss and

324
00:12:20,399 --> 00:12:21,519
data

325
00:12:21,519 --> 00:12:23,200
we should always expect this that's

326
00:12:23,200 --> 00:12:24,880
where globals go and that's where our

327
00:12:24,880 --> 00:12:27,440
file static and function statics go

328
00:12:27,440 --> 00:12:28,720
which is which

329
00:12:28,720 --> 00:12:32,079
well globals and statics both go into

330
00:12:32,079 --> 00:12:33,600
data and bss

331
00:12:33,600 --> 00:12:35,360
depends on how they're initialized

332
00:12:35,360 --> 00:12:37,519
anything with initial anything with an

333
00:12:37,519 --> 00:12:40,320
initializer goes into data anything with

334
00:12:40,320 --> 00:12:42,480
no initializer goes into bss and the

335
00:12:42,480 --> 00:12:44,560
lake of zeroing where they get zeroed

336
00:12:44,560 --> 00:12:45,760
out

337
00:12:45,760 --> 00:12:48,399
when we look at the ram sections we also

338
00:12:48,399 --> 00:12:50,959
expect to see stack and heap

339
00:12:50,959 --> 00:12:52,560
well we should always expect to see

340
00:12:52,560 --> 00:12:54,639
stack if you don't see heap and you're

341
00:12:54,639 --> 00:12:56,720
in an embedded system maybe you are

342
00:12:56,720 --> 00:13:00,000
intentionally not using dynamic memory

343
00:13:00,000 --> 00:13:01,519
though sometimes the heap is weirdly

344
00:13:01,519 --> 00:13:03,839
invisible it's implied that everything

345
00:13:03,839 --> 00:13:07,200
after the end of listed ram is heap

346
00:13:07,200 --> 00:13:10,000
or sometimes it's called esis or system

347
00:13:10,000 --> 00:13:12,880
or sometimes ebss the end of bss the end

348
00:13:12,880 --> 00:13:16,320
of linker allocated memory

349
00:13:16,560 --> 00:13:18,399
and there are a few things here on my

350
00:13:18,399 --> 00:13:21,040
map that are you will not see in your

351
00:13:21,040 --> 00:13:22,720
project's map file

352
00:13:22,720 --> 00:13:25,600
things that are part of your system

353
00:13:25,600 --> 00:13:28,079
uh first there's this ocean of unused

354
00:13:28,079 --> 00:13:29,360
address space

355
00:13:29,360 --> 00:13:31,279
we only used a tiny fraction of the

356
00:13:31,279 --> 00:13:32,720
addresses out there in the map file that

357
00:13:32,720 --> 00:13:35,120
we looked through the zero zero zeros

358
00:13:35,120 --> 00:13:36,480
and the

359
00:13:36,480 --> 00:13:38,560
hex 2000s

360
00:13:38,560 --> 00:13:40,560
even those we only used a small subset

361
00:13:40,560 --> 00:13:42,399
of them but be careful not to put

362
00:13:42,399 --> 00:13:44,320
anything in the ocean or a dragon will

363
00:13:44,320 --> 00:13:46,320
get it and your system will probably

364
00:13:46,320 --> 00:13:48,880
crash

365
00:13:48,880 --> 00:13:50,480
there's another address space you can

366
00:13:50,480 --> 00:13:53,199
use that isn't on your map isn't in your

367
00:13:53,199 --> 00:13:55,839
map file the port of peripheral

368
00:13:55,839 --> 00:13:57,120
registers

369
00:13:57,120 --> 00:14:00,560
timers watchdog spy dma uart

370
00:14:00,560 --> 00:14:02,639
all those memory mapped registers that

371
00:14:02,639 --> 00:14:04,720
you interact with that are hard coded in

372
00:14:04,720 --> 00:14:06,079
the address space

373
00:14:06,079 --> 00:14:08,160
these don't show up in your memory map

374
00:14:08,160 --> 00:14:09,920
file directly they're part of your

375
00:14:09,920 --> 00:14:12,000
processor manual

376
00:14:12,000 --> 00:14:14,160
now across the memory configuration

377
00:14:14,160 --> 00:14:15,199
mountains

378
00:14:15,199 --> 00:14:18,000
we have the flash federation

379
00:14:18,000 --> 00:14:20,160
most of that is taken up by code

380
00:14:20,160 --> 00:14:22,639
represented by dot text

381
00:14:22,639 --> 00:14:24,399
y dot text

382
00:14:24,399 --> 00:14:26,480
lost to the sands of time but at least

383
00:14:26,480 --> 00:14:28,480
this is very consistent across different

384
00:14:28,480 --> 00:14:29,760
linkers

385
00:14:29,760 --> 00:14:32,079
i have here the forest of functions and

386
00:14:32,079 --> 00:14:33,600
alternative functions with the mirror

387
00:14:33,600 --> 00:14:35,839
link in between that isn't part of your

388
00:14:35,839 --> 00:14:37,440
processor memory although it can be part

389
00:14:37,440 --> 00:14:39,360
of your map file

390
00:14:39,360 --> 00:14:41,839
functions go wherever they go depending

391
00:14:41,839 --> 00:14:44,800
on your link or optimization but when we

392
00:14:44,800 --> 00:14:46,399
looked at hello map

393
00:14:46,399 --> 00:14:48,320
we saw functions laid out in multiple

394
00:14:48,320 --> 00:14:51,920
ways and i wanted to represent that here

395
00:14:51,920 --> 00:14:54,560
the code section also usually has a

396
00:14:54,560 --> 00:14:57,040
interface or reset vect or some place

397
00:14:57,040 --> 00:14:59,120
where the interrupt vector table goes

398
00:14:59,120 --> 00:15:01,600
and sometimes it's at a fixed address

399
00:15:01,600 --> 00:15:03,040
sometimes not

400
00:15:03,040 --> 00:15:05,600
it may be ram vec and be over in

401
00:15:05,600 --> 00:15:06,959
remlandia

402
00:15:06,959 --> 00:15:09,199
it should be somewhere though we can't

403
00:15:09,199 --> 00:15:11,120
quite know where it will be

404
00:15:11,120 --> 00:15:14,480
or what it will be called

405
00:15:15,760 --> 00:15:17,199
so

406
00:15:17,199 --> 00:15:19,839
i want to go to initopia here

407
00:15:19,839 --> 00:15:23,199
here we have cnet which is the source of

408
00:15:23,199 --> 00:15:25,680
ram's river of initialization data's

409
00:15:25,680 --> 00:15:27,680
river of initialization

410
00:15:27,680 --> 00:15:29,519
all those static and global variables

411
00:15:29,519 --> 00:15:31,600
that get initialized they have to get

412
00:15:31,600 --> 00:15:33,839
their initialization values stored from

413
00:15:33,839 --> 00:15:35,600
somewhere in flash

414
00:15:35,600 --> 00:15:36,880
that all gets sorted out before your

415
00:15:36,880 --> 00:15:38,480
processor gets to me

416
00:15:38,480 --> 00:15:40,639
it's part of your init process for cnc

417
00:15:40,639 --> 00:15:42,480
plus plus it's called c startup if you

418
00:15:42,480 --> 00:15:44,000
want to know more

419
00:15:44,000 --> 00:15:47,199
c startup copies the ram functions

420
00:15:47,199 --> 00:15:48,480
oh sorry

421
00:15:48,480 --> 00:15:51,360
c startup also copies ram functions

422
00:15:51,360 --> 00:15:53,759
which can be there for speed

423
00:15:53,759 --> 00:15:55,279
maybe there are a few small functions

424
00:15:55,279 --> 00:15:58,000
that need to run really fast

425
00:15:58,000 --> 00:16:01,360
so let's go on to constantinia

426
00:16:01,360 --> 00:16:04,000
const well they're constants things you

427
00:16:04,000 --> 00:16:05,600
mark with the constant keywords or

428
00:16:05,600 --> 00:16:07,600
strings that are hard coded

429
00:16:07,600 --> 00:16:09,199
and by marking them with the const

430
00:16:09,199 --> 00:16:11,519
keyword they don't take up ram and they

431
00:16:11,519 --> 00:16:12,880
don't take up boot time to get

432
00:16:12,880 --> 00:16:14,240
initialized

433
00:16:14,240 --> 00:16:16,160
i believe i said not everything applies

434
00:16:16,160 --> 00:16:17,199
everywhere

435
00:16:17,199 --> 00:16:19,199
ro data is where many compilers

436
00:16:19,199 --> 00:16:21,839
including gcc usually put the variables

437
00:16:21,839 --> 00:16:23,839
marked with the cost keyword sometimes

438
00:16:23,839 --> 00:16:25,279
you have const sometimes you have ro

439
00:16:25,279 --> 00:16:27,120
data sometimes you both

440
00:16:27,120 --> 00:16:29,680
and you may never see switch which is

441
00:16:29,680 --> 00:16:31,360
used for lookup tables for switch

442
00:16:31,360 --> 00:16:32,639
expressions

443
00:16:32,639 --> 00:16:35,360
the tables will still be built but

444
00:16:35,360 --> 00:16:37,199
they'll get put into read-only memory

445
00:16:37,199 --> 00:16:39,440
unless there's a special section

446
00:16:39,440 --> 00:16:40,959
uh

447
00:16:40,959 --> 00:16:43,120
where we might have a faster bit of

448
00:16:43,120 --> 00:16:45,600
memory to run our switches from

449
00:16:45,600 --> 00:16:47,279
there are lots of these little linker

450
00:16:47,279 --> 00:16:49,279
keywords like this and we usually ignore

451
00:16:49,279 --> 00:16:51,040
them you can learn more about these

452
00:16:51,040 --> 00:16:52,320
different data segments from the

453
00:16:52,320 --> 00:16:53,440
internet

454
00:16:53,440 --> 00:16:55,120
it isn't critical to remember what each

455
00:16:55,120 --> 00:16:57,360
one does they try to give hints in their

456
00:16:57,360 --> 00:16:59,759
names except for bss which is block

457
00:16:59,759 --> 00:17:01,759
starting simple but really should be

458
00:17:01,759 --> 00:17:03,839
blank something something so that we

459
00:17:03,839 --> 00:17:07,119
remember it's full of zeros

460
00:17:07,119 --> 00:17:09,199
in addition to the parts of the system

461
00:17:09,199 --> 00:17:11,760
you usually see you may choose to

462
00:17:11,760 --> 00:17:13,520
allocate space

463
00:17:13,520 --> 00:17:15,919
to other things like a storage system a

464
00:17:15,919 --> 00:17:19,839
file system or bootloader

465
00:17:19,919 --> 00:17:22,240
and depending on your optimization layer

466
00:17:22,240 --> 00:17:24,799
level sorry

467
00:17:24,799 --> 00:17:27,439
depending on your optimization level

468
00:17:27,439 --> 00:17:29,280
optimization level

469
00:17:29,280 --> 00:17:31,600
and build system you may see a list of

470
00:17:31,600 --> 00:17:34,640
discarded functions in your map file

471
00:17:34,640 --> 00:17:37,840
those are the linker showing you how

472
00:17:37,840 --> 00:17:40,559
clever it is by showing you functions

473
00:17:40,559 --> 00:17:43,440
you shouldn't have bothered to write

474
00:17:43,440 --> 00:17:45,039
oh and down here

475
00:17:45,039 --> 00:17:47,200
you didn't think all memory mapped

476
00:17:47,200 --> 00:17:50,480
registers were documented right

477
00:17:50,480 --> 00:17:54,559
now clearly i had a lot of fun

478
00:17:54,559 --> 00:17:57,280
putting this together and you you can

479
00:17:57,280 --> 00:17:59,280
have access to it it's pretty easy to

480
00:17:59,280 --> 00:18:01,360
find including on the page that i

481
00:18:01,360 --> 00:18:03,280
mentioned and it's at the bottom of

482
00:18:03,280 --> 00:18:06,918
almost every slide

483
00:18:16,320 --> 00:18:18,480
now that we know what's in the map file

484
00:18:18,480 --> 00:18:20,000
let's look at how to use

485
00:18:20,000 --> 00:18:21,520
i've seen this list of problems and some

486
00:18:21,520 --> 00:18:23,760
possible tools not every tool works for

487
00:18:23,760 --> 00:18:26,320
every problem so let me go into these a

488
00:18:26,320 --> 00:18:28,799
little bit more detail

489
00:18:28,799 --> 00:18:30,400
let's say you're out of code space first

490
00:18:30,400 --> 00:18:31,760
thing to do is to look at the memory

491
00:18:31,760 --> 00:18:33,600
configuration in summary

492
00:18:33,600 --> 00:18:35,760
does your summary match the expectations

493
00:18:35,760 --> 00:18:37,520
you have based on the processor data

494
00:18:37,520 --> 00:18:38,400
sheet

495
00:18:38,400 --> 00:18:39,919
how much memory do you have how much do

496
00:18:39,919 --> 00:18:41,679
you expect and what kinds of memory do

497
00:18:41,679 --> 00:18:42,799
you have

498
00:18:42,799 --> 00:18:44,640
the next step is to decide where is your

499
00:18:44,640 --> 00:18:46,240
memory going

500
00:18:46,240 --> 00:18:48,000
looking at the more detailed information

501
00:18:48,000 --> 00:18:50,160
the functionless are you short of ram

502
00:18:50,160 --> 00:18:52,080
because you put a library into ram

503
00:18:52,080 --> 00:18:53,679
functions

504
00:18:53,679 --> 00:18:56,640
is it your code that's large because you

505
00:18:56,640 --> 00:18:58,480
have a ton of constants

506
00:18:58,480 --> 00:19:00,320
maybe it's all those strings you print

507
00:19:00,320 --> 00:19:02,640
out to the debug form

508
00:19:02,640 --> 00:19:04,720
another question to ask yourself is

509
00:19:04,720 --> 00:19:07,760
whether it's a new problem if so what

510
00:19:07,760 --> 00:19:08,960
changed

511
00:19:08,960 --> 00:19:11,919
are you if you suddenly run out of space

512
00:19:11,919 --> 00:19:13,520
was it because

513
00:19:13,520 --> 00:19:15,520
someone used a particular function that

514
00:19:15,520 --> 00:19:17,120
called the whole that caused a whole

515
00:19:17,120 --> 00:19:20,320
library to be included

516
00:19:20,320 --> 00:19:22,080
comparing files does mean you have to

517
00:19:22,080 --> 00:19:24,720
keep around the old map files or be able

518
00:19:24,720 --> 00:19:27,120
to easily rebuild them

519
00:19:27,120 --> 00:19:29,120
i recommend releasing them with your

520
00:19:29,120 --> 00:19:31,919
binaries but that's just me

521
00:19:31,919 --> 00:19:33,919
and while looking through the map files

522
00:19:33,919 --> 00:19:35,520
we saw functions were ordered in

523
00:19:35,520 --> 00:19:36,880
different ways

524
00:19:36,880 --> 00:19:39,520
by name and address sometimes they're

525
00:19:39,520 --> 00:19:41,840
often ordered by size

526
00:19:41,840 --> 00:19:44,480
and if you're really hitting a wall

527
00:19:44,480 --> 00:19:46,400
trying to find those last few bites of

528
00:19:46,400 --> 00:19:48,000
ram or code space

529
00:19:48,000 --> 00:19:50,320
sometimes a visualizer can help the idea

530
00:19:50,320 --> 00:19:51,600
is to make a viewer that looks sort of

531
00:19:51,600 --> 00:19:53,039
like this

532
00:19:53,039 --> 00:19:54,960
but with a lot more detail

533
00:19:54,960 --> 00:19:57,039
i looked for a commercial or open source

534
00:19:57,039 --> 00:19:58,559
tool to show you what one would look

535
00:19:58,559 --> 00:20:00,480
like but i found very little that did

536
00:20:00,480 --> 00:20:02,080
what i wanted

537
00:20:02,080 --> 00:20:04,640
long ago i made an aux script to parse

538
00:20:04,640 --> 00:20:07,760
my map file into an html table with

539
00:20:07,760 --> 00:20:10,799
cells proportional to the memory used it

540
00:20:10,799 --> 00:20:13,919
was for kyle compiler on 8051.

541
00:20:13,919 --> 00:20:15,360
i am sure that there will be a

542
00:20:15,360 --> 00:20:17,600
visualizer soon for this because it is

543
00:20:17,600 --> 00:20:19,600
such a problem but i have been saying

544
00:20:19,600 --> 00:20:21,360
that since twenty

545
00:20:21,360 --> 00:20:23,760
zero zero

546
00:20:23,760 --> 00:20:25,760
and once you get accustomed to your map

547
00:20:25,760 --> 00:20:27,360
file output

548
00:20:27,360 --> 00:20:28,320
you'll see

549
00:20:28,320 --> 00:20:30,880
it doesn't change that much so scripting

550
00:20:30,880 --> 00:20:33,200
a visualizer isn't that tough

551
00:20:33,200 --> 00:20:34,880
and once you make friends with your map

552
00:20:34,880 --> 00:20:36,799
file you may not need to

553
00:20:36,799 --> 00:20:38,400
i've added some visualizer links and

554
00:20:38,400 --> 00:20:40,799
resources at the end of the slides but i

555
00:20:40,799 --> 00:20:42,799
didn't find any that i would add to my

556
00:20:42,799 --> 00:20:46,559
personal useful tools list

557
00:20:46,720 --> 00:20:49,039
and as you go about optimizing look at

558
00:20:49,039 --> 00:20:50,960
the largest consumers first look at the

559
00:20:50,960 --> 00:20:52,880
things that are taking up the most space

560
00:20:52,880 --> 00:20:54,240
and reduce those

561
00:20:54,240 --> 00:20:56,320
saving 10 percent from 100 bytes isn't

562
00:20:56,320 --> 00:20:58,400
going to help as much as shaving 10 from

563
00:20:58,400 --> 00:21:00,240
the thousands

564
00:21:00,240 --> 00:21:02,559
you may find some unexpected libraries

565
00:21:02,559 --> 00:21:04,080
are included you can trace through the

566
00:21:04,080 --> 00:21:05,600
functions to see where they're called

567
00:21:05,600 --> 00:21:07,919
and find out why those libraries are

568
00:21:07,919 --> 00:21:10,080
included with the map file

569
00:21:10,080 --> 00:21:12,000
and some libraries are monolithic

570
00:21:12,000 --> 00:21:14,480
included if any function is used other

571
00:21:14,480 --> 00:21:17,039
libraries are granular loading only the

572
00:21:17,039 --> 00:21:18,880
required functions

573
00:21:18,880 --> 00:21:21,120
even the c standard libraries can be

574
00:21:21,120 --> 00:21:23,200
monolithic so that using a built-in

575
00:21:23,200 --> 00:21:25,440
string copy function can lead to a large

576
00:21:25,440 --> 00:21:27,520
footprint

577
00:21:27,520 --> 00:21:29,120
many times you can write a function to

578
00:21:29,120 --> 00:21:30,640
replace that library

579
00:21:30,640 --> 00:21:31,919
other times you'll need to figure out

580
00:21:31,919 --> 00:21:34,400
how to work around the limitation

581
00:21:34,400 --> 00:21:36,480
let me give you some examples to get

582
00:21:36,480 --> 00:21:39,280
ideas flowing uh replace floating point

583
00:21:39,280 --> 00:21:40,480
numbers with a fixed point

584
00:21:40,480 --> 00:21:41,760
representation

585
00:21:41,760 --> 00:21:43,919
replace printf with a few functions that

586
00:21:43,919 --> 00:21:46,159
don't take variable arguments like log

587
00:21:46,159 --> 00:21:48,880
string and log with num

588
00:21:48,880 --> 00:21:50,559
replace truecopy with your own

589
00:21:50,559 --> 00:21:52,320
implementation to exclude the strings

590
00:21:52,320 --> 00:21:55,039
library replace abs function with a

591
00:21:55,039 --> 00:21:57,200
macro to remove floating point math

592
00:21:57,200 --> 00:22:00,159
library dependencies you get the idea

593
00:22:00,159 --> 00:22:03,039
and i am not suggesting you do any of

594
00:22:03,039 --> 00:22:03,919
those

595
00:22:03,919 --> 00:22:06,640
before you know you have a problem

596
00:22:06,640 --> 00:22:08,799
when you do need to optimize i'm a huge

597
00:22:08,799 --> 00:22:10,720
fan of tracking the changes you made and

598
00:22:10,720 --> 00:22:12,320
the results they had because it isn't

599
00:22:12,320 --> 00:22:14,000
always straightforward if you have

600
00:22:14,000 --> 00:22:16,480
compile or link time optimizations

601
00:22:16,480 --> 00:22:17,679
turned on

602
00:22:17,679 --> 00:22:20,559
your attempts may not go as you expect

603
00:22:20,559 --> 00:22:22,320
at least not until you get the hang of

604
00:22:22,320 --> 00:22:24,000
it

605
00:22:24,000 --> 00:22:26,240
so that's how you use a memory map to

606
00:22:26,240 --> 00:22:29,919
consider ram and code space

607
00:22:29,919 --> 00:22:31,520
oh i have a question i have a question

608
00:22:31,520 --> 00:22:34,320
here a question about ram about knowing

609
00:22:34,320 --> 00:22:37,280
how much ram is left in the system

610
00:22:37,280 --> 00:22:39,520
okay didn't i answer that

611
00:22:39,520 --> 00:22:41,919
in the memory map

612
00:22:41,919 --> 00:22:43,760
oh i know the question is about how much

613
00:22:43,760 --> 00:22:45,520
ram do i have left when i'm running i

614
00:22:45,520 --> 00:22:47,280
knew that was the question

615
00:22:47,280 --> 00:22:50,000
and i have a sinking suspicion i'm going

616
00:22:50,000 --> 00:22:54,320
to have to actually address this one

617
00:22:54,320 --> 00:22:58,159
let's say this is your memory your ram

618
00:22:58,159 --> 00:22:59,520
these are our global and static

619
00:22:59,520 --> 00:23:01,679
variables they have initializers we know

620
00:23:01,679 --> 00:23:04,159
that the c initializers get put into ram

621
00:23:04,159 --> 00:23:05,600
from flash

622
00:23:05,600 --> 00:23:07,600
filling them in is part of the c startup

623
00:23:07,600 --> 00:23:10,559
process before maine happens

624
00:23:10,559 --> 00:23:12,559
and back to our lake of zeroing also

625
00:23:12,559 --> 00:23:15,200
part of the c startup process that bss

626
00:23:15,200 --> 00:23:17,120
globals and static are initialized to

627
00:23:17,120 --> 00:23:18,559
zero

628
00:23:18,559 --> 00:23:21,679
everything else is shown as unused in

629
00:23:21,679 --> 00:23:24,799
our memory map summary

630
00:23:24,799 --> 00:23:27,360
but it's not unused no no

631
00:23:27,360 --> 00:23:29,760
this is where the heap and stack go

632
00:23:29,760 --> 00:23:32,000
for most systems the heap grows down and

633
00:23:32,000 --> 00:23:33,679
the stack grows up and we hope they

634
00:23:33,679 --> 00:23:36,480
never meet in the middle but i have my

635
00:23:36,480 --> 00:23:38,799
suspicions

636
00:23:38,799 --> 00:23:41,039
once we call main variables

637
00:23:41,039 --> 00:23:42,960
in the function go on the stack some

638
00:23:42,960 --> 00:23:44,960
variables are small enough they might go

639
00:23:44,960 --> 00:23:47,200
into a register but most variables

640
00:23:47,200 --> 00:23:50,400
especially the big ones go

641
00:23:50,400 --> 00:23:53,919
into the stack memory uh we put it on

642
00:23:53,919 --> 00:23:55,200
the stack

643
00:23:55,200 --> 00:23:58,559
so let's say we now maleks a memory

644
00:23:58,559 --> 00:24:00,720
malik's memory goes on the memory we

645
00:24:00,720 --> 00:24:02,960
call the heap

646
00:24:02,960 --> 00:24:04,720
as maine goes along we allocate another

647
00:24:04,720 --> 00:24:06,000
bit of memory

648
00:24:06,000 --> 00:24:08,080
uh and we don't necessarily know how the

649
00:24:08,080 --> 00:24:09,760
heap is managed it depends on your c

650
00:24:09,760 --> 00:24:11,679
library but i'm going to pretend it's a

651
00:24:11,679 --> 00:24:14,720
pretty naive heap manager and new mallex

652
00:24:14,720 --> 00:24:15,919
are just going to go right next to each

653
00:24:15,919 --> 00:24:17,360
other

654
00:24:17,360 --> 00:24:19,360
now let's call another function the new

655
00:24:19,360 --> 00:24:21,039
functions variables get put onto the

656
00:24:21,039 --> 00:24:22,000
step

657
00:24:22,000 --> 00:24:24,240
and and this will be important soon the

658
00:24:24,240 --> 00:24:26,559
return address

659
00:24:26,559 --> 00:24:29,840
to get from our function back to main is

660
00:24:29,840 --> 00:24:32,159
put into a register the return address

661
00:24:32,159 --> 00:24:35,200
register so we can find our way back

662
00:24:35,200 --> 00:24:37,440
to where mu foo was called from back to

663
00:24:37,440 --> 00:24:39,600
me

664
00:24:39,600 --> 00:24:41,600
so let's allocate some more memory three

665
00:24:41,600 --> 00:24:44,080
corals

666
00:24:45,440 --> 00:24:47,120
four spiky corals

667
00:24:47,120 --> 00:24:48,640
let's call another function another

668
00:24:48,640 --> 00:24:50,960
turtle of course this represents the

669
00:24:50,960 --> 00:24:53,440
variables newly declared

670
00:24:53,440 --> 00:24:55,279
variables declared in our newly called

671
00:24:55,279 --> 00:24:56,559
function

672
00:24:56,559 --> 00:24:59,120
more importantly and before that the

673
00:24:59,120 --> 00:25:01,520
contents of the return address register

674
00:25:01,520 --> 00:25:03,919
is put on the stack

675
00:25:03,919 --> 00:25:06,240
so the stack has breadcrumbs telling us

676
00:25:06,240 --> 00:25:08,880
how to get back to our main function

677
00:25:08,880 --> 00:25:11,360
we'll use the return address register to

678
00:25:11,360 --> 00:25:12,960
return from here

679
00:25:12,960 --> 00:25:14,960
and then we'll pop the stack remove the

680
00:25:14,960 --> 00:25:16,799
turtle take things off and make them

681
00:25:16,799 --> 00:25:18,159
usable

682
00:25:18,159 --> 00:25:20,320
and that includes the return address

683
00:25:20,320 --> 00:25:21,600
register

684
00:25:21,600 --> 00:25:23,440
then we get back to maine by popping the

685
00:25:23,440 --> 00:25:25,760
stack again so the stack pointer would

686
00:25:25,760 --> 00:25:28,480
go back to the first turtle but for now

687
00:25:28,480 --> 00:25:30,960
we're three turtles in

688
00:25:30,960 --> 00:25:32,720
and i use turtles because of the story

689
00:25:32,720 --> 00:25:35,360
about flat earth about the flat earth

690
00:25:35,360 --> 00:25:37,360
being on the back of a turtle but what

691
00:25:37,360 --> 00:25:39,360
does the turtle stand on it's turtles

692
00:25:39,360 --> 00:25:41,679
all the way down the stack is like that

693
00:25:41,679 --> 00:25:43,360
it is stacked frames all the way down

694
00:25:43,360 --> 00:25:45,919
each one full of variables and bread

695
00:25:45,919 --> 00:25:49,039
crumbs to find our way home

696
00:25:49,039 --> 00:25:52,000
okay another malloc five this time

697
00:25:52,000 --> 00:25:53,360
another function

698
00:25:53,360 --> 00:25:55,039
i said before but i feel like mentioning

699
00:25:55,039 --> 00:25:57,440
it again if you had an aura toss each

700
00:25:57,440 --> 00:25:59,840
thread would get its own heap and stack

701
00:25:59,840 --> 00:26:01,440
but threads

702
00:26:01,440 --> 00:26:03,440
heap and stack each thread's heap and

703
00:26:03,440 --> 00:26:05,600
stack would probably be contiguous and

704
00:26:05,600 --> 00:26:07,360
laid out like this

705
00:26:07,360 --> 00:26:09,520
though your rtos may keep track of your

706
00:26:09,520 --> 00:26:11,360
stack pointer and cause an exception

707
00:26:11,360 --> 00:26:13,679
when you have too many turtles

708
00:26:13,679 --> 00:26:16,640
blow out the stack of memory

709
00:26:16,640 --> 00:26:17,679
six

710
00:26:17,679 --> 00:26:21,120
six brain corals allocated

711
00:26:21,200 --> 00:26:23,200
another function another stack frame i

712
00:26:23,200 --> 00:26:24,799
do feel like i should start playing the

713
00:26:24,799 --> 00:26:26,400
jaws theme

714
00:26:26,400 --> 00:26:28,960
seven violet corals allocated another

715
00:26:28,960 --> 00:26:30,720
function another turtle

716
00:26:30,720 --> 00:26:32,240
and here

717
00:26:32,240 --> 00:26:34,240
here we are with the last allocation

718
00:26:34,240 --> 00:26:35,279
eight

719
00:26:35,279 --> 00:26:38,640
chunks of coral of ram at this point we

720
00:26:38,640 --> 00:26:40,240
have zero

721
00:26:40,240 --> 00:26:42,080
zero bytes of memory left

722
00:26:42,080 --> 00:26:44,000
and finally we can answer the question

723
00:26:44,000 --> 00:26:46,559
of how much memory we have left how do

724
00:26:46,559 --> 00:26:49,120
you tell how much rem you have left

725
00:26:49,120 --> 00:26:51,520
when the heap pointer equals the stack

726
00:26:51,520 --> 00:26:54,799
pointer you have zero bytes of ram left

727
00:26:54,799 --> 00:26:57,840
you haven't crashed this is fine like a

728
00:26:57,840 --> 00:27:00,400
dog sitting in a cafe on fire this is

729
00:27:00,400 --> 00:27:01,919
fine

730
00:27:01,919 --> 00:27:04,080
you just can't call another function or

731
00:27:04,080 --> 00:27:06,960
allocate anything further if you called

732
00:27:06,960 --> 00:27:08,880
another function your stack would put it

733
00:27:08,880 --> 00:27:11,120
into the corals messing up the data

734
00:27:11,120 --> 00:27:13,039
already stored there

735
00:27:13,039 --> 00:27:15,840
if you're if you mallocked more memory

736
00:27:15,840 --> 00:27:17,760
you would lose the top of the stack

737
00:27:17,760 --> 00:27:19,760
scatter the breadcrumbs and not be able

738
00:27:19,760 --> 00:27:21,360
to find your way home

739
00:27:21,360 --> 00:27:24,159
in fact you'd probably try to return and

740
00:27:24,159 --> 00:27:26,799
end up someplace random

741
00:27:26,799 --> 00:27:28,720
as we are full up in our memory now

742
00:27:28,720 --> 00:27:29,840
let's let's freeze some of those

743
00:27:29,840 --> 00:27:31,760
pointers to malach memory we still need

744
00:27:31,760 --> 00:27:33,760
the last set but not the seven violet

745
00:27:33,760 --> 00:27:36,159
corals or the five flowers or the three

746
00:27:36,159 --> 00:27:37,600
rows like ones

747
00:27:37,600 --> 00:27:39,679
how much memory will we get back

748
00:27:39,679 --> 00:27:41,919
uh seven plus five plus three is

749
00:27:41,919 --> 00:27:43,919
thirteen

750
00:27:43,919 --> 00:27:46,000
how much memory do we have now

751
00:27:46,000 --> 00:27:49,039
seven plus five plus 3 is 15 corals

752
00:27:49,039 --> 00:27:51,279
but you can't call another function and

753
00:27:51,279 --> 00:27:54,159
you can't allocate 15 corals your memory

754
00:27:54,159 --> 00:27:55,520
is fragment

755
00:27:55,520 --> 00:27:59,360
and this is why many folk avoid heap in

756
00:27:59,360 --> 00:28:01,679
embedded systems if you're allocating in

757
00:28:01,679 --> 00:28:03,440
free in memory in a system without

758
00:28:03,440 --> 00:28:04,960
garbage collection

759
00:28:04,960 --> 00:28:06,640
your memory can get fragmented to the

760
00:28:06,640 --> 00:28:08,799
point where you have a bunch free but

761
00:28:08,799 --> 00:28:10,399
you can't allocate what seems like a

762
00:28:10,399 --> 00:28:12,080
small buffer

763
00:28:12,080 --> 00:28:15,039
and this is why how much ram do i have

764
00:28:15,039 --> 00:28:17,600
left is an impossible question

765
00:28:17,600 --> 00:28:19,279
how much do you have in your heap is it

766
00:28:19,279 --> 00:28:21,520
contiguous or fragmented how many

767
00:28:21,520 --> 00:28:23,840
function calls deep are you

768
00:28:23,840 --> 00:28:26,320
if we disallowed mal disallowed the heap

769
00:28:26,320 --> 00:28:27,919
in our system we'd know how much memory

770
00:28:27,919 --> 00:28:30,320
we had it would be from the bottom of

771
00:28:30,320 --> 00:28:33,200
bss to the top of stack

772
00:28:33,200 --> 00:28:35,600
but we could only fill that with

773
00:28:35,600 --> 00:28:37,600
function calls stack variables and

774
00:28:37,600 --> 00:28:39,440
turtles

775
00:28:39,440 --> 00:28:41,360
if you had a hardware abstraction layer

776
00:28:41,360 --> 00:28:43,279
layer that's like five layers deep in

777
00:28:43,279 --> 00:28:45,919
your system that's a lot of stack memory

778
00:28:45,919 --> 00:28:48,320
just building up reaching for the heap

779
00:28:48,320 --> 00:28:50,480
and certain doom

780
00:28:50,480 --> 00:28:52,320
there are static tools

781
00:28:52,320 --> 00:28:54,320
to tell you how deep your call tree is

782
00:28:54,320 --> 00:28:56,399
so you can estimate your stack usage and

783
00:28:56,399 --> 00:28:58,559
keep track of a high water mark

784
00:28:58,559 --> 00:29:00,240
that indicates the most amount of stack

785
00:29:00,240 --> 00:29:02,320
you've used

786
00:29:02,320 --> 00:29:03,360
though

787
00:29:03,360 --> 00:29:05,600
if you use recursion a function that

788
00:29:05,600 --> 00:29:06,960
calls itself

789
00:29:06,960 --> 00:29:08,720
then your stack can grow and grow and

790
00:29:08,720 --> 00:29:11,279
grow because

791
00:29:11,279 --> 00:29:13,760
it depends on runtime circumstances you

792
00:29:13,760 --> 00:29:16,399
can't estimate your maximum stack size

793
00:29:16,399 --> 00:29:18,880
which is why many embedded developers

794
00:29:18,880 --> 00:29:21,440
shy away from recursion

795
00:29:21,440 --> 00:29:23,840
so here we are back to how much ram do i

796
00:29:23,840 --> 00:29:25,279
have in my system

797
00:29:25,279 --> 00:29:27,520
and the answer is not what any of us

798
00:29:27,520 --> 00:29:28,480
wanted

799
00:29:28,480 --> 00:29:30,799
but the word ineffable is one of the

800
00:29:30,799 --> 00:29:34,720
finer ones in the english language

801
00:29:36,960 --> 00:29:38,799
let's go back to memory maps which is

802
00:29:38,799 --> 00:29:40,720
what this talk was about before i got

803
00:29:40,720 --> 00:29:42,640
distracted

804
00:29:42,640 --> 00:29:44,000
let's talk about debugging the

805
00:29:44,000 --> 00:29:45,760
impossible bug since we're kind of on

806
00:29:45,760 --> 00:29:47,200
the subject

807
00:29:47,200 --> 00:29:49,039
these are the icky crawly ones you worry

808
00:29:49,039 --> 00:29:51,440
about late at night but you can't

809
00:29:51,440 --> 00:29:54,399
reliably reproduce on your desk not the

810
00:29:54,399 --> 00:29:56,000
ones where the heap and stack merge

811
00:29:56,000 --> 00:29:58,880
those those can also cause hard faults

812
00:29:58,880 --> 00:30:01,120
but other hard faults

813
00:30:01,120 --> 00:30:03,360
which are where your processor says nope

814
00:30:03,360 --> 00:30:05,600
you just can't do that like when you try

815
00:30:05,600 --> 00:30:07,360
to write to null which in our address

816
00:30:07,360 --> 00:30:09,679
space is

817
00:30:09,679 --> 00:30:11,679
flash it's zero zero and that's either

818
00:30:11,679 --> 00:30:13,200
the start of flash not a place you can

819
00:30:13,200 --> 00:30:15,760
normally just write to

820
00:30:15,760 --> 00:30:17,279
or you get a hard fault when you try to

821
00:30:17,279 --> 00:30:20,480
jump to code that isn't code at all

822
00:30:20,480 --> 00:30:22,240
if you're fortunate and you have a

823
00:30:22,240 --> 00:30:24,159
debugging tool attached

824
00:30:24,159 --> 00:30:26,080
you get a back trace and that can help

825
00:30:26,080 --> 00:30:27,760
you figure out where you were when the

826
00:30:27,760 --> 00:30:29,520
hard fault was triggered

827
00:30:29,520 --> 00:30:30,960
if you aren't lucky

828
00:30:30,960 --> 00:30:33,679
don't be some digging on your part

829
00:30:33,679 --> 00:30:35,440
maybe from the heart fault interrupt you

830
00:30:35,440 --> 00:30:37,279
manage to write your return address

831
00:30:37,279 --> 00:30:39,919
register to a log or serial port

832
00:30:39,919 --> 00:30:41,679
before resetting

833
00:30:41,679 --> 00:30:43,200
then you'll need the memory map file to

834
00:30:43,200 --> 00:30:44,640
figure out where you were when things

835
00:30:44,640 --> 00:30:46,559
went wrong and note you'll need the

836
00:30:46,559 --> 00:30:48,640
memory map file of the image you're

837
00:30:48,640 --> 00:30:50,559
running so be careful about your

838
00:30:50,559 --> 00:30:53,120
versions

839
00:30:53,200 --> 00:30:55,279
even with a debugger and back trace

840
00:30:55,279 --> 00:30:58,240
available having the map file open while

841
00:30:58,240 --> 00:30:59,760
you look at the stack in the cpu

842
00:30:59,760 --> 00:31:01,440
registers might help you figure out

843
00:31:01,440 --> 00:31:03,120
where the code was when things went

844
00:31:03,120 --> 00:31:04,720
horribly wrong

845
00:31:04,720 --> 00:31:06,559
and note that searching directly for the

846
00:31:06,559 --> 00:31:08,799
address may not work as the map file

847
00:31:08,799 --> 00:31:10,960
lists the beginning of the function

848
00:31:10,960 --> 00:31:13,120
and you need to look around for

849
00:31:13,120 --> 00:31:15,120
functions that are near your address

850
00:31:15,120 --> 00:31:17,200
which is easy enough if your map file

851
00:31:17,200 --> 00:31:20,960
includes functions in address order

852
00:31:20,960 --> 00:31:22,720
the process is similar with the weird

853
00:31:22,720 --> 00:31:24,320
memory errors which sometimes lead to

854
00:31:24,320 --> 00:31:26,159
hard faults sometimes just lead to

855
00:31:26,159 --> 00:31:28,240
random results if you have a global

856
00:31:28,240 --> 00:31:30,240
buffer that's getting corrupted and you

857
00:31:30,240 --> 00:31:31,600
can look in the memory map file to see

858
00:31:31,600 --> 00:31:33,360
what's nearby

859
00:31:33,360 --> 00:31:36,080
well is uart buff overflowing into adc

860
00:31:36,080 --> 00:31:38,240
buffer

861
00:31:38,240 --> 00:31:40,480
finding corrupted memory near the end of

862
00:31:40,480 --> 00:31:42,720
segments can also be interesting this

863
00:31:42,720 --> 00:31:44,640
variable is right before the top of

864
00:31:44,640 --> 00:31:46,480
stack it's getting mangled maybe i

865
00:31:46,480 --> 00:31:47,679
should

866
00:31:47,679 --> 00:31:50,480
see if my stack is overflowing

867
00:31:50,480 --> 00:31:52,880
figuring out exactly what to do isn't

868
00:31:52,880 --> 00:31:54,720
easy and there's still going to be a lot

869
00:31:54,720 --> 00:31:56,480
of trying to make it happen more often

870
00:31:56,480 --> 00:31:58,240
trying to figure out when it crept into

871
00:31:58,240 --> 00:32:00,559
the code and general head scratching

872
00:32:00,559 --> 00:32:02,799
but your map file gives you a few more

873
00:32:02,799 --> 00:32:04,480
tools makes it easier to find those

874
00:32:04,480 --> 00:32:06,960
flash and ram addresses to find the root

875
00:32:06,960 --> 00:32:08,640
causes

876
00:32:08,640 --> 00:32:10,880
on to firmware updates

877
00:32:10,880 --> 00:32:12,720
as you plan out your system

878
00:32:12,720 --> 00:32:15,039
think about how your memory should look

879
00:32:15,039 --> 00:32:17,039
you need your bootloader here

880
00:32:17,039 --> 00:32:18,480
space large enough for the new version

881
00:32:18,480 --> 00:32:20,960
to go into an updatable library like

882
00:32:20,960 --> 00:32:24,240
nordic soft devices where do those go

883
00:32:24,240 --> 00:32:26,080
is your storage system supposed to stay

884
00:32:26,080 --> 00:32:28,480
intact through firmware update being

885
00:32:28,480 --> 00:32:30,559
able to sketch out a high-level memory

886
00:32:30,559 --> 00:32:32,559
map will help you figure this out where

887
00:32:32,559 --> 00:32:33,760
things should be

888
00:32:33,760 --> 00:32:35,279
and the linker file the linker file we

889
00:32:35,279 --> 00:32:37,760
are definitely not discussing

890
00:32:37,760 --> 00:32:38,880
will

891
00:32:38,880 --> 00:32:41,679
cause the linker to place the sections

892
00:32:41,679 --> 00:32:43,519
where it thinks you want them

893
00:32:43,519 --> 00:32:45,760
then the actual map file our memory map

894
00:32:45,760 --> 00:32:48,000
file can show you where they are

895
00:32:48,000 --> 00:32:49,039
and

896
00:32:49,039 --> 00:32:51,200
when working with firmware update you

897
00:32:51,200 --> 00:32:53,679
may need multiple map files when

898
00:32:53,679 --> 00:32:55,600
debugging from our update

899
00:32:55,600 --> 00:32:57,600
there's the new code the old code the

900
00:32:57,600 --> 00:32:59,679
bootloaders code the soft devices and

901
00:32:59,679 --> 00:33:01,440
they all have to agree on where they're

902
00:33:01,440 --> 00:33:03,279
supposed to go for firmware update to

903
00:33:03,279 --> 00:33:06,000
work properly

904
00:33:06,000 --> 00:33:08,559
and finally possibly inexplicably the

905
00:33:08,559 --> 00:33:10,399
map file can show you how to make your

906
00:33:10,399 --> 00:33:12,159
code run faster

907
00:33:12,159 --> 00:33:14,080
first if your code suddenly starts to

908
00:33:14,080 --> 00:33:16,159
get slow there's the diff with the last

909
00:33:16,159 --> 00:33:18,720
known good map file what changed

910
00:33:18,720 --> 00:33:20,720
it may be too small to see in the map

911
00:33:20,720 --> 00:33:23,039
file so diffinger version control might

912
00:33:23,039 --> 00:33:25,360
work better and yet sometimes you can't

913
00:33:25,360 --> 00:33:27,760
see why fabs instead of abs made such a

914
00:33:27,760 --> 00:33:29,919
big difference until you see a giant

915
00:33:29,919 --> 00:33:33,679
library added in to support floats

916
00:33:33,679 --> 00:33:34,640
next

917
00:33:34,640 --> 00:33:36,399
look at the summary

918
00:33:36,399 --> 00:33:38,320
look at those memory characteristics did

919
00:33:38,320 --> 00:33:40,080
you even know that flash can have weight

920
00:33:40,080 --> 00:33:42,000
states so that every time you read from

921
00:33:42,000 --> 00:33:44,559
flash you to run code or to read it

922
00:33:44,559 --> 00:33:45,760
constant

923
00:33:45,760 --> 00:33:48,399
the system just waits for a stop for

924
00:33:48,399 --> 00:33:50,640
like six cycles

925
00:33:50,640 --> 00:33:53,039
but knowing how many weight states each

926
00:33:53,039 --> 00:33:55,200
type of memory has

927
00:33:55,200 --> 00:33:56,399
will let you

928
00:33:56,399 --> 00:33:58,159
will give you options for speeding up

929
00:33:58,159 --> 00:33:59,360
execution

930
00:33:59,360 --> 00:34:01,919
oops by moving the

931
00:34:01,919 --> 00:34:04,080
by being able to move code to faster

932
00:34:04,080 --> 00:34:05,519
memory

933
00:34:05,519 --> 00:34:07,360
for example you may want to copy a

934
00:34:07,360 --> 00:34:09,440
critical function to zero weight state

935
00:34:09,440 --> 00:34:10,399
ram

936
00:34:10,399 --> 00:34:11,760
if that's faster than your normal

937
00:34:11,760 --> 00:34:13,599
program flash

938
00:34:13,599 --> 00:34:16,399
for many optimization problems if you

939
00:34:16,399 --> 00:34:18,639
are over using one type of resource like

940
00:34:18,639 --> 00:34:20,399
your cpu cycles

941
00:34:20,399 --> 00:34:22,639
and you have another available

942
00:34:22,639 --> 00:34:24,560
you can parlay that into a working

943
00:34:24,560 --> 00:34:27,119
solution

944
00:34:27,520 --> 00:34:29,520
and finally for using the map files to

945
00:34:29,520 --> 00:34:31,760
speed up your system look at statistical

946
00:34:31,760 --> 00:34:33,679
sampling this is going to be a

947
00:34:33,679 --> 00:34:35,839
ridiculously brief explanation of a very

948
00:34:35,839 --> 00:34:37,520
interesting subject

949
00:34:37,520 --> 00:34:40,079
a statistical sampling profiler runs in

950
00:34:40,079 --> 00:34:41,839
an interrupt and stores the return

951
00:34:41,839 --> 00:34:42,960
address

952
00:34:42,960 --> 00:34:45,280
thereby figuring out which functions

953
00:34:45,280 --> 00:34:46,320
your

954
00:34:46,320 --> 00:34:48,639
you spend the most of your time in it

955
00:34:48,639 --> 00:34:50,239
of course you need a pretty big ram

956
00:34:50,239 --> 00:34:52,399
buffer and some extra code

957
00:34:52,399 --> 00:34:54,560
uh and you could do this with a jtag

958
00:34:54,560 --> 00:34:56,239
programmer or a system debugger

959
00:34:56,239 --> 00:34:58,400
especially the ones that support trace

960
00:34:58,400 --> 00:35:00,320
but sometimes you can't sometimes you

961
00:35:00,320 --> 00:35:02,720
have to do it in the field so once you

962
00:35:02,720 --> 00:35:04,720
get a dump of the addresses of the

963
00:35:04,720 --> 00:35:07,119
functions that the timer interrupted

964
00:35:07,119 --> 00:35:09,520
you can use the map file to figure out

965
00:35:09,520 --> 00:35:12,240
where you're spending all your time

966
00:35:12,240 --> 00:35:15,280
as i mentioned this is kind of hard

967
00:35:15,280 --> 00:35:16,800
but if you need it the possibility is

968
00:35:16,800 --> 00:35:18,560
there and you'll definitely need a map

969
00:35:18,560 --> 00:35:20,880
file

970
00:35:20,960 --> 00:35:22,560
so that's what you can do with map file

971
00:35:22,560 --> 00:35:24,320
and the tools to do it

972
00:35:24,320 --> 00:35:29,040
we didn't use one of those so i fixed it

973
00:35:29,040 --> 00:35:30,880
let's look at another map

974
00:35:30,880 --> 00:35:33,520
one from a different compiler gcc

975
00:35:33,520 --> 00:35:35,200
well not really gcc generated because

976
00:35:35,200 --> 00:35:38,720
gcc is the compiler a program called ld

977
00:35:38,720 --> 00:35:40,720
does the actual linking and that's what

978
00:35:40,720 --> 00:35:42,320
generates the map file we're about to

979
00:35:42,320 --> 00:35:43,839
look at

980
00:35:43,839 --> 00:35:46,560
before we get there let's look at

981
00:35:46,560 --> 00:35:49,040
memory mapland again pretty map file in

982
00:35:49,040 --> 00:35:51,440
hopes that you find it amusing while i

983
00:35:51,440 --> 00:35:53,760
warn you about the graphic content we

984
00:35:53,760 --> 00:35:55,599
are about to see

985
00:35:55,599 --> 00:35:58,880
gnu generated maps are not pretty

986
00:35:58,880 --> 00:36:00,400
if you thought the ones that i was

987
00:36:00,400 --> 00:36:02,800
scrolling through earlier were a wall of

988
00:36:02,800 --> 00:36:04,800
hex and nonsense just close your eyes

989
00:36:04,800 --> 00:36:07,440
for the next bit

990
00:36:08,079 --> 00:36:10,240
not only are these maps tough to read

991
00:36:10,240 --> 00:36:12,000
you have to ask for them especially from

992
00:36:12,000 --> 00:36:13,599
the linker

993
00:36:13,599 --> 00:36:15,200
the one i'm going to show is for

994
00:36:15,200 --> 00:36:17,599
adafruit's circuit python

995
00:36:17,599 --> 00:36:20,160
running on a c duinojow which has a

996
00:36:20,160 --> 00:36:25,040
microchip at sam d21 an arm cortex m0

997
00:36:25,040 --> 00:36:27,760
plus it's a pretty complicated system

998
00:36:27,760 --> 00:36:30,400
running a python parser from a file

999
00:36:30,400 --> 00:36:32,240
system

1000
00:36:32,240 --> 00:36:35,920
it starts with the a list of files um

1001
00:36:35,920 --> 00:36:39,040
we i mean why

1002
00:36:39,040 --> 00:36:41,599
but uh then we go on to more important

1003
00:36:41,599 --> 00:36:42,960
things

1004
00:36:42,960 --> 00:36:45,680
oh here's a list of discarded imports

1005
00:36:45,680 --> 00:36:47,839
that's sure something i want to know

1006
00:36:47,839 --> 00:36:49,839
oh hey the memory configuration

1007
00:36:49,839 --> 00:36:52,560
mountains there they are

1008
00:36:52,560 --> 00:36:54,800
hey i thought we said we weren't doing

1009
00:36:54,800 --> 00:36:57,040
the linker file no i said definitely not

1010
00:36:57,040 --> 00:36:58,160
linker file

1011
00:36:58,160 --> 00:36:59,839
why are you doing this who's in charge

1012
00:36:59,839 --> 00:37:01,520
here

1013
00:37:01,520 --> 00:37:02,800
fine i'll talk about it in a little

1014
00:37:02,800 --> 00:37:03,599
while

1015
00:37:03,599 --> 00:37:05,200
talk about linker files later settle

1016
00:37:05,200 --> 00:37:09,160
your optical sensor down

1017
00:37:10,160 --> 00:37:12,800
okay we're in the function forest in the

1018
00:37:12,800 --> 00:37:16,480
dot text in the county of code

1019
00:37:16,480 --> 00:37:19,119
and now we're

1020
00:37:19,119 --> 00:37:22,800
moving on to constantinia the ro buffer

1021
00:37:22,800 --> 00:37:25,520
the ro segments

1022
00:37:25,520 --> 00:37:26,480
um

1023
00:37:26,480 --> 00:37:29,839
these go on for a good long time

1024
00:37:29,839 --> 00:37:33,680
as expected in a system of this scale

1025
00:37:33,680 --> 00:37:35,200
and now we're

1026
00:37:35,200 --> 00:37:37,359
starting to get into other stuff

1027
00:37:37,359 --> 00:37:40,560
but none of it's very big so

1028
00:37:40,560 --> 00:37:42,960
i'm pretty happy just skipping it

1029
00:37:42,960 --> 00:37:45,200
oh and here's ramlandia they don't have

1030
00:37:45,200 --> 00:37:47,040
any ram functions kind of sad i like

1031
00:37:47,040 --> 00:37:48,640
those

1032
00:37:48,640 --> 00:37:50,480
and all the data along the river of

1033
00:37:50,480 --> 00:37:54,000
initialization both globals and statics

1034
00:37:54,000 --> 00:37:56,480
here is that data

1035
00:37:56,480 --> 00:37:57,920
and we're going to move along and then

1036
00:37:57,920 --> 00:37:59,760
we're going to get to bss

1037
00:37:59,760 --> 00:38:02,640
with its lake of zeroing still globals

1038
00:38:02,640 --> 00:38:05,839
and statics

1039
00:38:09,680 --> 00:38:13,280
and here we are getting to the stacks

1040
00:38:13,280 --> 00:38:16,040
the stock ends at

1041
00:38:16,040 --> 00:38:19,359
2027 34. but the ram from the memory

1042
00:38:19,359 --> 00:38:23,119
configuration goes to 2008 000. so we

1043
00:38:23,119 --> 00:38:23,920
have

1044
00:38:23,920 --> 00:38:27,680
5 8 cc around 22k left over remember

1045
00:38:27,680 --> 00:38:30,000
that we'll need it later

1046
00:38:30,000 --> 00:38:32,720
so moving along uh

1047
00:38:32,720 --> 00:38:34,320
we have some stuff that looks important

1048
00:38:34,320 --> 00:38:36,320
but who knows let's skip those and come

1049
00:38:36,320 --> 00:38:38,359
back if we need them or maybe google

1050
00:38:38,359 --> 00:38:39,920
arm.attributes and find out it has

1051
00:38:39,920 --> 00:38:41,440
something to do with arm and probably

1052
00:38:41,440 --> 00:38:42,640
isn't something to mess with safe to

1053
00:38:42,640 --> 00:38:44,160
ignore

1054
00:38:44,160 --> 00:38:46,320
oh now the map file tells us we should

1055
00:38:46,320 --> 00:38:48,079
load all these objects

1056
00:38:48,079 --> 00:38:49,599
i mean did i really need to know that

1057
00:38:49,599 --> 00:38:51,119
isn't that something some other tools

1058
00:38:51,119 --> 00:38:52,640
should do

1059
00:38:52,640 --> 00:38:55,760
uh comment debug frame they don't look

1060
00:38:55,760 --> 00:38:57,839
critical they aren't huge we can google

1061
00:38:57,839 --> 00:39:00,160
them but for the most part ignoring is

1062
00:39:00,160 --> 00:39:02,560
okay

1063
00:39:04,160 --> 00:39:06,079
oh yes the cross reference table i guess

1064
00:39:06,079 --> 00:39:08,880
gcc doesn't think we have

1065
00:39:08,880 --> 00:39:09,680
or

1066
00:39:09,680 --> 00:39:11,200
doesn't think we have searched because

1067
00:39:11,200 --> 00:39:13,359
here's a list of where every function is

1068
00:39:13,359 --> 00:39:14,560
defined

1069
00:39:14,560 --> 00:39:16,560
i suppose it might be useful if we're

1070
00:39:16,560 --> 00:39:18,079
getting a function from an unexpected

1071
00:39:18,079 --> 00:39:19,200
library

1072
00:39:19,200 --> 00:39:20,880
but mostly snooze

1073
00:39:20,880 --> 00:39:22,720
and that's it i mean there was a lot of

1074
00:39:22,720 --> 00:39:24,640
scrolling and ignoring

1075
00:39:24,640 --> 00:39:26,800
but we saw most of what we expected we

1076
00:39:26,800 --> 00:39:28,480
didn't see the heap explicitly called

1077
00:39:28,480 --> 00:39:32,240
out but the build message

1078
00:39:32,320 --> 00:39:34,400
uh on the bottom gives us a little clue

1079
00:39:34,400 --> 00:39:37,119
about that the ebss

1080
00:39:37,119 --> 00:39:39,200
gives us another little clue about where

1081
00:39:39,200 --> 00:39:43,160
the heap will be placed

1082
00:39:46,000 --> 00:39:48,400
and remember in order to get the gnu

1083
00:39:48,400 --> 00:39:49,760
linker file

1084
00:39:49,760 --> 00:39:51,839
you or in order to get the canoe map

1085
00:39:51,839 --> 00:39:54,160
file you may have to use a compiler

1086
00:39:54,160 --> 00:39:56,400
linker flag

1087
00:39:56,400 --> 00:39:58,000
at the beginning i promise to tell you a

1088
00:39:58,000 --> 00:39:59,760
little more about where mount files come

1089
00:39:59,760 --> 00:40:03,599
from and i've mentioned the linker file

1090
00:40:03,599 --> 00:40:05,760
but how does the linker really know

1091
00:40:05,760 --> 00:40:07,760
where to put all the code and constants

1092
00:40:07,760 --> 00:40:09,119
in flash

1093
00:40:09,119 --> 00:40:11,040
and the statics and global should go in

1094
00:40:11,040 --> 00:40:13,359
bran

1095
00:40:15,119 --> 00:40:17,359
there's the linker file which has been

1096
00:40:17,359 --> 00:40:19,520
on the screen a couple times it usually

1097
00:40:19,520 --> 00:40:22,720
ends with command or dot make or dot l

1098
00:40:22,720 --> 00:40:24,640
ld or link

1099
00:40:24,640 --> 00:40:26,640
and explaining them in detail would be a

1100
00:40:26,640 --> 00:40:28,560
whole nother talk but let me show you a

1101
00:40:28,560 --> 00:40:30,480
little taste of what a linker file looks

1102
00:40:30,480 --> 00:40:32,319
like this was up on the screen before

1103
00:40:32,319 --> 00:40:34,480
but let's look a little more closely

1104
00:40:34,480 --> 00:40:37,119
and compare the hello example link file

1105
00:40:37,119 --> 00:40:39,040
with its map file

1106
00:40:39,040 --> 00:40:41,040
you can see they're definitely siblings

1107
00:40:41,040 --> 00:40:42,800
see how the memory

1108
00:40:42,800 --> 00:40:45,520
and memory configuration matched

1109
00:40:45,520 --> 00:40:47,359
and then we have these sections that we

1110
00:40:47,359 --> 00:40:49,680
see again later those sections go into

1111
00:40:49,680 --> 00:40:51,839
different types of memory flash and

1112
00:40:51,839 --> 00:40:53,200
esrap

1113
00:40:53,200 --> 00:40:55,680
and i hope you can start to see

1114
00:40:55,680 --> 00:40:57,200
how this answers some of the questions

1115
00:40:57,200 --> 00:40:59,040
like why is our flash organized like

1116
00:40:59,040 --> 00:41:01,359
this why do some parts of our code go

1117
00:41:01,359 --> 00:41:03,760
into flash and other parts into wrap

1118
00:41:03,760 --> 00:41:06,000
because that's what the linker file told

1119
00:41:06,000 --> 00:41:07,280
it to do

1120
00:41:07,280 --> 00:41:08,240
and

1121
00:41:08,240 --> 00:41:10,560
oops

1122
00:41:11,760 --> 00:41:15,480
that's going to be a problem

1123
00:41:22,160 --> 00:41:24,400
this is another area where the gnu tools

1124
00:41:24,400 --> 00:41:28,800
are pretty much the worst for learning

1125
00:41:28,960 --> 00:41:30,880
their link files are usually much harder

1126
00:41:30,880 --> 00:41:32,000
to read

1127
00:41:32,000 --> 00:41:34,720
with many tools that end up doing

1128
00:41:34,720 --> 00:41:37,040
exceedingly clever things with cnn and

1129
00:41:37,040 --> 00:41:39,200
bss variables making them hard to see in

1130
00:41:39,200 --> 00:41:40,400
the link file

1131
00:41:40,400 --> 00:41:42,480
and in the map file

1132
00:41:42,480 --> 00:41:45,359
according to its man page the gnu linker

1133
00:41:45,359 --> 00:41:48,400
ld accepts linker command language files

1134
00:41:48,400 --> 00:41:49,359
written

1135
00:41:49,359 --> 00:41:52,240
in a superset of a t's link editor

1136
00:41:52,240 --> 00:41:54,720
command language syntax

1137
00:41:54,720 --> 00:41:55,680
so

1138
00:41:55,680 --> 00:41:57,760
in order for your code to build

1139
00:41:57,760 --> 00:41:59,599
an unknown program

1140
00:41:59,599 --> 00:42:01,119
accepts

1141
00:42:01,119 --> 00:42:02,560
bizarre files

1142
00:42:02,560 --> 00:42:04,800
in an archaic language

1143
00:42:04,800 --> 00:42:07,280
our world our embedded systems are full

1144
00:42:07,280 --> 00:42:09,760
of wizardry and incantations

1145
00:42:09,760 --> 00:42:12,960
and yet linker files are very important

1146
00:42:12,960 --> 00:42:14,800
especially if you're allocating specific

1147
00:42:14,800 --> 00:42:16,800
sections for some sort of storage or you

1148
00:42:16,800 --> 00:42:18,319
have a bootloader or the ability to

1149
00:42:18,319 --> 00:42:21,359
switch between application images

1150
00:42:21,359 --> 00:42:24,160
still you need the map file you need to

1151
00:42:24,160 --> 00:42:26,319
understand the map file before you can

1152
00:42:26,319 --> 00:42:28,079
understand the linker file the linker

1153
00:42:28,079 --> 00:42:30,720
files are the directions the map file

1154
00:42:30,720 --> 00:42:33,520
is the reality

1155
00:42:34,160 --> 00:42:35,920
honestly i haven't figured out a way to

1156
00:42:35,920 --> 00:42:38,800
make map like i haven't found a way to

1157
00:42:38,800 --> 00:42:42,760
make linker files fun

1158
00:42:44,560 --> 00:42:46,160
my thought and it really is just a

1159
00:42:46,160 --> 00:42:48,160
thought nowhere near plan involves a

1160
00:42:48,160 --> 00:42:50,079
rube goldberg machine

1161
00:42:50,079 --> 00:42:52,160
i think embedded systems is hard to

1162
00:42:52,160 --> 00:42:54,000
teach because we

1163
00:42:54,000 --> 00:42:56,960
jump to so many details

1164
00:42:56,960 --> 00:42:59,680
how many of you were shouting tail

1165
00:42:59,680 --> 00:43:01,280
recursion

1166
00:43:01,280 --> 00:43:03,839
in the section about stacks of turtles

1167
00:43:03,839 --> 00:43:05,920
yes taylor christian is awesome

1168
00:43:05,920 --> 00:43:07,599
but aren't there fundamentals to learn

1169
00:43:07,599 --> 00:43:09,200
before we worry about optimizing

1170
00:43:09,200 --> 00:43:10,800
everything

1171
00:43:10,800 --> 00:43:11,839
between

1172
00:43:11,839 --> 00:43:14,160
hardware and software our world is made

1173
00:43:14,160 --> 00:43:16,000
up of exceptions

1174
00:43:16,000 --> 00:43:17,760
tweaky little things that aren't always

1175
00:43:17,760 --> 00:43:20,880
true corners we cut to keep costs down

1176
00:43:20,880 --> 00:43:22,480
how do you teach things in the right

1177
00:43:22,480 --> 00:43:24,880
order to show the fun the technical

1178
00:43:24,880 --> 00:43:27,920
information design methodologies

1179
00:43:27,920 --> 00:43:30,000
and 100 little details that depend on

1180
00:43:30,000 --> 00:43:32,000
the processor and application

1181
00:43:32,000 --> 00:43:33,760
i don't know

1182
00:43:33,760 --> 00:43:35,520
i have been excited to have arduino be a

1183
00:43:35,520 --> 00:43:37,200
popular thing to let people play with

1184
00:43:37,200 --> 00:43:39,200
the hardware and software to fall in

1185
00:43:39,200 --> 00:43:41,200
love with making gadgets

1186
00:43:41,200 --> 00:43:42,960
but we need a bridge between play and

1187
00:43:42,960 --> 00:43:45,280
work i tend to like metaphors and

1188
00:43:45,280 --> 00:43:46,880
simplifications

1189
00:43:46,880 --> 00:43:49,119
and i spend a lot of time near the ocean

1190
00:43:49,119 --> 00:43:51,920
but nothing replaces experience

1191
00:43:51,920 --> 00:43:53,839
how do we make it easier

1192
00:43:53,839 --> 00:43:55,280
this is something i would like to talk

1193
00:43:55,280 --> 00:43:56,400
about further

1194
00:43:56,400 --> 00:43:58,160
but i'm about out of time

1195
00:43:58,160 --> 00:44:00,240
so thank you for being here i'm elia

1196
00:44:00,240 --> 00:44:02,480
white if you'd like the pretty memory

1197
00:44:02,480 --> 00:44:04,720
map land file for yourself

1198
00:44:04,720 --> 00:44:06,319
there is a

1199
00:44:06,319 --> 00:44:08,880
link on the slide if you've enjoyed this

1200
00:44:08,880 --> 00:44:10,960
presentation you may enjoy embedded a

1201
00:44:10,960 --> 00:44:12,880
weekly podcast where we talk to folks

1202
00:44:12,880 --> 00:44:14,720
about the how and why of the systems

1203
00:44:14,720 --> 00:44:16,160
they make

1204
00:44:16,160 --> 00:44:18,160
and i'm doing a making embedded systems

1205
00:44:18,160 --> 00:44:21,119
course through class pert based on my

1206
00:44:21,119 --> 00:44:22,880
book which doesn't focus on one

1207
00:44:22,880 --> 00:44:24,960
processor or heavily on code but tries

1208
00:44:24,960 --> 00:44:26,160
to give you a framework for what to

1209
00:44:26,160 --> 00:44:29,599
expect when making embedded systems

1210
00:44:29,599 --> 00:44:32,240
the new cohort for making embedded

1211
00:44:32,240 --> 00:44:34,560
systems through class pert starts on

1212
00:44:34,560 --> 00:44:36,480
march 12th well let's just say it starts

1213
00:44:36,480 --> 00:44:38,560
in march let's not get too excited

1214
00:44:38,560 --> 00:44:41,359
uh for those of you watching now i have

1215
00:44:41,359 --> 00:44:42,800
a coupon code

1216
00:44:42,800 --> 00:44:45,680
good for the next two weeks from today

1217
00:44:45,680 --> 00:44:47,200
which

1218
00:44:47,200 --> 00:44:48,000
you know

1219
00:44:48,000 --> 00:44:49,359
november 18th

1220
00:44:49,359 --> 00:44:51,280
uh and it's good for the next two weeks

1221
00:44:51,280 --> 00:44:54,000
or the first 25 seats but the course

1222
00:44:54,000 --> 00:44:57,040
doesn't start until march

1223
00:45:00,480 --> 00:45:03,040
and that's about it

1224
00:45:03,040 --> 00:45:05,359
so

1225
00:45:05,359 --> 00:45:09,440
let's get back to elliot

1226
00:45:10,000 --> 00:45:12,960
hey thank you very much alicia that's

1227
00:45:12,960 --> 00:45:15,680
fantastic

1228
00:45:16,400 --> 00:45:18,640
uh we're gonna work on some questions

1229
00:45:18,640 --> 00:45:20,319
real quick so you can answer them there

1230
00:45:20,319 --> 00:45:22,079
were a few that went out as you were

1231
00:45:22,079 --> 00:45:24,480
giving the talk i think the first one

1232
00:45:24,480 --> 00:45:26,400
actually got answered as you were going

1233
00:45:26,400 --> 00:45:29,200
along but pierce nichols asked can the

1234
00:45:29,200 --> 00:45:31,280
map file be used to instrument which

1235
00:45:31,280 --> 00:45:33,359
functions are being run that would be

1236
00:45:33,359 --> 00:45:35,760
useful for finding the holes in hardware

1237
00:45:35,760 --> 00:45:38,640
in the loop test programs for instance

1238
00:45:38,640 --> 00:45:41,599
yes yes exactly

1239
00:45:41,599 --> 00:45:42,960
yeah

1240
00:45:42,960 --> 00:45:44,560
and i think you ended up covering that

1241
00:45:44,560 --> 00:45:48,240
in the in one of those sections

1242
00:45:48,240 --> 00:45:50,240
um waiting for some more questions to

1243
00:45:50,240 --> 00:45:53,040
come rolling in

1244
00:45:53,200 --> 00:45:54,720
people are saying your graphics were

1245
00:45:54,720 --> 00:45:59,040
fantastic and uh i have to agree the uh

1246
00:45:59,040 --> 00:46:01,359
there's nothing i'm more scared of than

1247
00:46:01,359 --> 00:46:04,480
the heap crashing with the stack and uh

1248
00:46:04,480 --> 00:46:06,880
you explained those holes beautifully

1249
00:46:06,880 --> 00:46:08,079
thank you

1250
00:46:08,079 --> 00:46:11,280
um for most of the art i use incarnate

1251
00:46:11,280 --> 00:46:14,800
inc carnate it's a it's a dungeon the

1252
00:46:14,800 --> 00:46:16,240
dragon style

1253
00:46:16,240 --> 00:46:18,960
map tool and it was a lot of fun to put

1254
00:46:18,960 --> 00:46:20,319
together

1255
00:46:20,319 --> 00:46:22,720
as for why map files are so complicated

1256
00:46:22,720 --> 00:46:24,240
to start with

1257
00:46:24,240 --> 00:46:25,920
because they do all these things that

1258
00:46:25,920 --> 00:46:28,560
repetition that i talked about where you

1259
00:46:28,560 --> 00:46:30,000
have the

1260
00:46:30,000 --> 00:46:33,119
the files ordered in different ways

1261
00:46:33,119 --> 00:46:34,960
well at some point i said i needed to

1262
00:46:34,960 --> 00:46:37,200
know what was around the file

1263
00:46:37,200 --> 00:46:39,359
and then at another point i said

1264
00:46:39,359 --> 00:46:41,920
i needed to know how big the files were

1265
00:46:41,920 --> 00:46:42,960
and so

1266
00:46:42,960 --> 00:46:45,359
they reproduce the information trying to

1267
00:46:45,359 --> 00:46:47,119
solve all the problems they can come up

1268
00:46:47,119 --> 00:46:49,200
with now i don't know why they ever put

1269
00:46:49,200 --> 00:46:50,800
it in alphabetical order that just

1270
00:46:50,800 --> 00:46:53,280
doesn't make sense to me but

1271
00:46:53,280 --> 00:46:54,720
yes there is a reason they're so

1272
00:46:54,720 --> 00:46:58,720
complicated because they do so much

1273
00:47:02,319 --> 00:47:05,200
the list of tools the map visualizers

1274
00:47:05,200 --> 00:47:07,520
here are the map visualizers

1275
00:47:07,520 --> 00:47:09,760
this is also available in the slide deck

1276
00:47:09,760 --> 00:47:10,800
which

1277
00:47:10,800 --> 00:47:14,160
i've already mentioned is available

1278
00:47:14,319 --> 00:47:16,800
let's see

1279
00:47:17,119 --> 00:47:20,480
statistical sampling from mike's dish

1280
00:47:20,480 --> 00:47:22,839
and when is most useful to use that

1281
00:47:22,839 --> 00:47:25,839
trick well the best way to do it now is

1282
00:47:25,839 --> 00:47:28,240
to buy something with trace capability

1283
00:47:28,240 --> 00:47:30,160
and do it on your desk

1284
00:47:30,160 --> 00:47:31,280
because

1285
00:47:31,280 --> 00:47:33,280
it's going to save you a lot of time

1286
00:47:33,280 --> 00:47:34,400
but

1287
00:47:34,400 --> 00:47:36,240
that isn't always possible

1288
00:47:36,240 --> 00:47:37,440
sometimes

1289
00:47:37,440 --> 00:47:39,359
systems behavior better on your desk

1290
00:47:39,359 --> 00:47:41,680
than they do in the field

1291
00:47:41,680 --> 00:47:42,880
and so

1292
00:47:42,880 --> 00:47:45,200
if you want to know why

1293
00:47:45,200 --> 00:47:47,839
the field systems are

1294
00:47:47,839 --> 00:47:50,079
running out of cpu however you decide

1295
00:47:50,079 --> 00:47:51,839
they're running out of cpu but they are

1296
00:47:51,839 --> 00:47:52,880
clearly

1297
00:47:52,880 --> 00:47:55,520
cpu limited when they shouldn't be when

1298
00:47:55,520 --> 00:47:57,440
they aren't on your desk

1299
00:47:57,440 --> 00:47:59,440
that's where statistical sampling really

1300
00:47:59,440 --> 00:48:02,160
comes into play where you start

1301
00:48:02,160 --> 00:48:04,079
with a giant ram buffer and you put your

1302
00:48:04,079 --> 00:48:06,000
return addresses in over and over again

1303
00:48:06,000 --> 00:48:09,440
and you count you know i was in

1304
00:48:09,440 --> 00:48:11,200
uh i was at this address i was at this

1305
00:48:11,200 --> 00:48:12,960
address i was this address and you take

1306
00:48:12,960 --> 00:48:14,960
that list of addresses and you go to the

1307
00:48:14,960 --> 00:48:16,640
map file and you say

1308
00:48:16,640 --> 00:48:18,800
oh this is this is in

1309
00:48:18,800 --> 00:48:21,760
delay millisecond this is in printf this

1310
00:48:21,760 --> 00:48:22,640
is in

1311
00:48:22,640 --> 00:48:24,480
oh that function i really meant to take

1312
00:48:24,480 --> 00:48:26,319
out before i shipped it

1313
00:48:26,319 --> 00:48:28,079
um

1314
00:48:28,079 --> 00:48:30,960
and so i wouldn't do it for normal

1315
00:48:30,960 --> 00:48:33,839
profiling because there are tools

1316
00:48:33,839 --> 00:48:35,839
that are better than statistical

1317
00:48:35,839 --> 00:48:36,880
sampling

1318
00:48:36,880 --> 00:48:40,160
but those tools don't always work

1319
00:48:40,160 --> 00:48:41,839
in every

1320
00:48:41,839 --> 00:48:43,200
in every case

1321
00:48:43,200 --> 00:48:47,399
these are terrible questions people

1322
00:48:50,880 --> 00:48:53,119
but thank you i i really do appreciate

1323
00:48:53,119 --> 00:48:56,319
what you're saying it's it's very nice

1324
00:48:56,319 --> 00:48:59,520
it's very kind of you to say

1325
00:49:00,240 --> 00:49:02,400
do you want to see the map file again

1326
00:49:02,400 --> 00:49:05,359
that's probably the best slide i have

1327
00:49:05,359 --> 00:49:08,160
so that's the pretty map

1328
00:49:08,160 --> 00:49:11,440
and now i've discord enough

1329
00:49:11,440 --> 00:49:14,079
and then i also pinned the link to this

1330
00:49:14,079 --> 00:49:16,319
file in the discord general channel for

1331
00:49:16,319 --> 00:49:19,119
people that are in there

1332
00:49:19,839 --> 00:49:23,200
um let's see ram funks ram funds appear

1333
00:49:23,200 --> 00:49:27,200
in both flash and ram memory segments

1334
00:49:27,200 --> 00:49:28,640
under what conditions would a function

1335
00:49:28,640 --> 00:49:30,160
be put into ram and is there a way to

1336
00:49:30,160 --> 00:49:32,240
know in advance where a function will be

1337
00:49:32,240 --> 00:49:33,280
put

1338
00:49:33,280 --> 00:49:35,440
functions are put wherever the linker

1339
00:49:35,440 --> 00:49:38,400
file tells them to

1340
00:49:38,640 --> 00:49:39,680
the

1341
00:49:39,680 --> 00:49:42,319
reason you would put a

1342
00:49:42,319 --> 00:49:44,640
file into ram

1343
00:49:44,640 --> 00:49:48,640
would be if your ram runs faster than

1344
00:49:48,640 --> 00:49:51,359
your flash and you need to

1345
00:49:51,359 --> 00:49:52,960
run fast

1346
00:49:52,960 --> 00:49:54,640
uh you can also there's also bootloader

1347
00:49:54,640 --> 00:49:55,760
reasons to do that but i don't want to

1348
00:49:55,760 --> 00:49:57,440
talk about those

1349
00:49:57,440 --> 00:49:59,040
and so what happens is your function

1350
00:49:59,040 --> 00:50:01,200
gets compiled to

1351
00:50:01,200 --> 00:50:03,599
flash i mean it gets compiled and then

1352
00:50:03,599 --> 00:50:05,520
it gets written to your flash and then

1353
00:50:05,520 --> 00:50:08,400
on c startup flash says oh i have a ram

1354
00:50:08,400 --> 00:50:10,160
function i'll have to copy this whole

1355
00:50:10,160 --> 00:50:11,599
file this whole

1356
00:50:11,599 --> 00:50:12,559
function

1357
00:50:12,559 --> 00:50:14,880
over into ram because

1358
00:50:14,880 --> 00:50:17,440
all of the other places all of the other

1359
00:50:17,440 --> 00:50:20,079
things that call this function

1360
00:50:20,079 --> 00:50:22,480
point to a place in ram

1361
00:50:22,480 --> 00:50:26,079
and notch to the points in flash

1362
00:50:26,079 --> 00:50:27,280
does that make sense does somebody want

1363
00:50:27,280 --> 00:50:30,079
me to do that again

1364
00:50:33,440 --> 00:50:35,280
i can only see elliot so

1365
00:50:35,280 --> 00:50:36,640
if he's not naughty and i don't know

1366
00:50:36,640 --> 00:50:38,839
what you're saying

1367
00:50:38,839 --> 00:50:42,559
um i'm okay nobody's typing

1368
00:50:42,559 --> 00:50:45,839
they're all typing that's true

1369
00:50:45,839 --> 00:50:48,800
uh no mapfi visualizer does what you

1370
00:50:48,800 --> 00:50:50,880
want it to do what would be points on my

1371
00:50:50,880 --> 00:50:52,640
wishlist i want

1372
00:50:52,640 --> 00:50:55,040
uh the ability to look at ram and code

1373
00:50:55,040 --> 00:50:56,160
separately

1374
00:50:56,160 --> 00:50:58,319
a lot of them right now are combining

1375
00:50:58,319 --> 00:50:59,680
but usually you're having one problem

1376
00:50:59,680 --> 00:51:00,800
with the other

1377
00:51:00,800 --> 00:51:03,359
i want to be able to

1378
00:51:03,359 --> 00:51:05,760
have proportional sizes so i can

1379
00:51:05,760 --> 00:51:07,119
visualize and say

1380
00:51:07,119 --> 00:51:09,359
oh that's where most of my memory is

1381
00:51:09,359 --> 00:51:12,240
i want to be able to mark off bits and

1382
00:51:12,240 --> 00:51:15,200
say i can't change that library

1383
00:51:15,200 --> 00:51:17,119
i want to

1384
00:51:17,119 --> 00:51:19,280
be able to

1385
00:51:19,280 --> 00:51:21,760
have it look nice which is hard because

1386
00:51:21,760 --> 00:51:23,920
you have a little tiny function that's

1387
00:51:23,920 --> 00:51:24,800
only

1388
00:51:24,800 --> 00:51:27,200
uh 15 bytes long and you're comparing it

1389
00:51:27,200 --> 00:51:30,319
to a monstrous function that's

1390
00:51:30,319 --> 00:51:31,920
two kilobytes long and how do you put

1391
00:51:31,920 --> 00:51:34,000
those in the same visualization

1392
00:51:34,000 --> 00:51:36,240
you can you can use logarithmic methods

1393
00:51:36,240 --> 00:51:37,839
but then you're not really

1394
00:51:37,839 --> 00:51:40,559
being true to what it's saying

1395
00:51:40,559 --> 00:51:42,480
uh if you want to talk more about that i

1396
00:51:42,480 --> 00:51:44,240
would be happy to talk more about what i

1397
00:51:44,240 --> 00:51:46,160
want in map visualizer

1398
00:51:46,160 --> 00:51:49,599
but the high level answer was that uh

1399
00:51:49,599 --> 00:51:52,640
was the one that i had up uh let's see

1400
00:51:52,640 --> 00:51:53,839
the one that i said was kind of like

1401
00:51:53,839 --> 00:51:57,000
your processors

1402
00:52:04,880 --> 00:52:06,000
okay i just just started at the

1403
00:52:06,000 --> 00:52:07,280
beginning because that's where it's it

1404
00:52:07,280 --> 00:52:09,440
is

1405
00:52:10,079 --> 00:52:12,400
this is a very long presentation thank

1406
00:52:12,400 --> 00:52:14,720
you for sticking through it with me this

1407
00:52:14,720 --> 00:52:17,359
one i want it to look kind of like this

1408
00:52:17,359 --> 00:52:19,040
where i can see the different kinds of

1409
00:52:19,040 --> 00:52:20,240
memory

1410
00:52:20,240 --> 00:52:24,479
and i can zoom in on certain parts

1411
00:52:28,559 --> 00:52:30,559
it's still sharing my screen yes okay

1412
00:52:30,559 --> 00:52:33,280
good

1413
00:52:33,280 --> 00:52:37,440
uh what about self-modifying code

1414
00:52:37,520 --> 00:52:39,839
um

1415
00:52:40,559 --> 00:52:42,240
part of me is like don't do that the

1416
00:52:42,240 --> 00:52:43,440
other part of me is like that's a

1417
00:52:43,440 --> 00:52:45,040
bootloader

1418
00:52:45,040 --> 00:52:47,280
uh yes of course we have self-modifying

1419
00:52:47,280 --> 00:52:49,040
code uh would you put that in ram

1420
00:52:49,040 --> 00:52:50,400
functions

1421
00:52:50,400 --> 00:52:52,240
yes

1422
00:52:52,240 --> 00:52:54,319
uh but

1423
00:52:54,319 --> 00:52:56,640
i hope you know what you're doing

1424
00:52:56,640 --> 00:52:58,960
because i don't

1425
00:52:58,960 --> 00:53:01,440
um but we do have you know we put things

1426
00:53:01,440 --> 00:53:03,520
in boot loaders and then we modify our

1427
00:53:03,520 --> 00:53:05,520
flash

1428
00:53:05,520 --> 00:53:06,800
and that's

1429
00:53:06,800 --> 00:53:09,359
self modifying um and sometimes the

1430
00:53:09,359 --> 00:53:10,880
bootloader needs to go in ram so that we

1431
00:53:10,880 --> 00:53:12,559
can erase all of our flash and sometimes

1432
00:53:12,559 --> 00:53:14,880
the bootloader can be snuck into a part

1433
00:53:14,880 --> 00:53:15,760
of

1434
00:53:15,760 --> 00:53:17,760
flash a page that doesn't need to be

1435
00:53:17,760 --> 00:53:20,160
erased

1436
00:53:20,240 --> 00:53:22,400
what is the coolest debug you had to do

1437
00:53:22,400 --> 00:53:23,920
with map files

1438
00:53:23,920 --> 00:53:27,680
um that would be at leapfrog where

1439
00:53:27,680 --> 00:53:30,319
software was cheap and hardware was

1440
00:53:30,319 --> 00:53:34,480
hideously expensive so every single byte

1441
00:53:34,480 --> 00:53:35,599
was

1442
00:53:35,599 --> 00:53:36,480
just

1443
00:53:36,480 --> 00:53:40,079
i mean you had to wring it out

1444
00:53:40,079 --> 00:53:41,520
and that was where i did the

1445
00:53:41,520 --> 00:53:45,040
visualizations so that i could because

1446
00:53:45,040 --> 00:53:47,599
we had a fair amount of flash but ram

1447
00:53:47,599 --> 00:53:49,280
was always

1448
00:53:49,280 --> 00:53:52,319
always low and if you could figure out

1449
00:53:52,319 --> 00:53:54,319
where it was going or how to cheat so

1450
00:53:54,319 --> 00:53:56,559
that you were using

1451
00:53:56,559 --> 00:53:58,319
flash

1452
00:53:58,319 --> 00:54:00,160
memory instead of ram it was very

1453
00:54:00,160 --> 00:54:01,839
helpful and when i say flash on that i

1454
00:54:01,839 --> 00:54:03,119
actually need rom

1455
00:54:03,119 --> 00:54:05,359
because toys don't have flash they they

1456
00:54:05,359 --> 00:54:06,400
have

1457
00:54:06,400 --> 00:54:08,079
read-only memory that gets programmed in

1458
00:54:08,079 --> 00:54:09,760
masks that probably somebody here will

1459
00:54:09,760 --> 00:54:11,839
be talking about very cool

1460
00:54:11,839 --> 00:54:16,240
that chips that don't have flash and big

1461
00:54:16,960 --> 00:54:19,839
big consumer problems

1462
00:54:19,839 --> 00:54:21,440
all right thank you very much we're

1463
00:54:21,440 --> 00:54:22,240
gonna

1464
00:54:22,240 --> 00:54:23,440
take a quick

1465
00:54:23,440 --> 00:54:25,760
break i think but will you be around to

1466
00:54:25,760 --> 00:54:27,599
stick around in the

1467
00:54:27,599 --> 00:54:28,960
discord for a little bit if people have

1468
00:54:28,960 --> 00:54:30,319
some more questions

1469
00:54:30,319 --> 00:54:32,960
i will absolutely um and i may have some

1470
00:54:32,960 --> 00:54:34,400
questions for some other talks because

1471
00:54:34,400 --> 00:54:36,720
you have an excellent lineup today and

1472
00:54:36,720 --> 00:54:38,640
yeah i'm excited to see the rest of it

1473
00:54:38,640 --> 00:54:41,879
thank you

