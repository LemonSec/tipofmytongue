1
00:00:05,759 --> 00:00:08,759
sure

2
00:01:20,080 --> 00:01:23,080
okay

3
00:01:40,799 --> 00:01:43,799
okay

4
00:01:55,520 --> 00:01:58,520
um

5
00:02:26,800 --> 00:02:29,800
agreement

6
00:02:37,040 --> 00:02:40,040
um

7
00:02:50,560 --> 00:02:53,800
oh yeah

8
00:03:29,200 --> 00:03:32,200
routers

9
00:04:58,000 --> 00:05:01,000
um

10
00:05:21,520 --> 00:05:24,520
yes

11
00:05:29,440 --> 00:05:32,440
like

12
00:05:52,880 --> 00:05:55,880
yes

13
00:06:18,000 --> 00:06:21,000
yes

14
00:06:38,560 --> 00:06:41,560
foreign

15
00:06:54,000 --> 00:06:57,000
oh

16
00:07:26,319 --> 00:07:29,479
my blood

17
00:07:31,919 --> 00:07:35,318
didn't get married

18
00:08:24,800 --> 00:08:27,800
is

19
00:08:34,719 --> 00:08:37,719
now

20
00:09:04,560 --> 00:09:07,560
foreign

21
00:09:21,200 --> 00:09:24,200
um

22
00:09:38,880 --> 00:09:42,279
they know me

23
00:09:51,920 --> 00:09:54,920
um

24
00:10:07,440 --> 00:10:10,440
here

25
00:10:42,480 --> 00:10:45,480
oh

26
00:11:24,640 --> 00:11:27,640
uh

27
00:11:54,800 --> 00:11:57,800
nice

28
00:12:38,480 --> 00:12:41,480
um

29
00:12:52,320 --> 00:12:55,320
yes

30
00:13:20,399 --> 00:13:23,399
yes

31
00:13:38,720 --> 00:13:41,720
oh

32
00:13:50,880 --> 00:13:53,880
outside

33
00:14:13,760 --> 00:14:17,000
thank you

34
00:14:19,440 --> 00:14:22,440
oh

35
00:14:52,240 --> 00:14:55,399
oh yeah

36
00:15:26,880 --> 00:15:29,880
right

37
00:15:47,519 --> 00:15:50,519
arcade

38
00:15:54,800 --> 00:15:57,800
uh

39
00:16:11,279 --> 00:16:14,279
okay

40
00:16:40,800 --> 00:16:43,800
um

41
00:17:02,639 --> 00:17:05,720
all right

42
00:17:45,840 --> 00:17:48,840
uh

43
00:18:16,480 --> 00:18:19,480
um

44
00:19:00,000 --> 00:19:03,000
uh

45
00:19:12,640 --> 00:19:15,640
is

46
00:19:29,280 --> 00:19:32,280
uh

47
00:19:40,000 --> 00:19:43,240
right now

48
00:19:52,480 --> 00:19:55,720
tell me

49
00:20:42,720 --> 00:20:45,720
foreign

50
00:20:58,480 --> 00:21:01,480
six

51
00:21:43,120 --> 00:21:45,840
it's

52
00:21:47,230 --> 00:21:50,410
[Music]

53
00:22:45,520 --> 00:22:48,520
is

54
00:23:42,860 --> 00:23:49,419
[Music]

55
00:23:57,650 --> 00:24:05,089
[Music]

56
00:24:11,530 --> 00:24:14,849
[Music]

57
00:24:15,279 --> 00:24:18,279
there

58
00:24:21,770 --> 00:24:25,250
[Music]

59
00:24:28,320 --> 00:24:30,480
[Music]

60
00:24:30,480 --> 00:24:33,480
bye

61
00:24:33,920 --> 00:24:39,630
[Music]

62
00:24:45,880 --> 00:24:49,059
[Music]

63
00:24:58,400 --> 00:25:01,569
[Music]

64
00:25:12,380 --> 00:25:16,809
[Music]

65
00:25:24,480 --> 00:25:26,730
okay

66
00:25:26,730 --> 00:25:35,530
[Music]

67
00:25:38,159 --> 00:25:40,400
well good morning

68
00:25:40,400 --> 00:25:42,080
again

69
00:25:42,080 --> 00:25:43,840
um

70
00:25:43,840 --> 00:25:46,400
so it's uh day two here at summer con

71
00:25:46,400 --> 00:25:48,240
2022.

72
00:25:48,240 --> 00:25:50,159
um

73
00:25:50,159 --> 00:25:52,720
i told myself i wouldn't say um too many

74
00:25:52,720 --> 00:25:53,760
times

75
00:25:53,760 --> 00:25:56,799
like i always do and i apologize for

76
00:25:56,799 --> 00:25:57,679
that

77
00:25:57,679 --> 00:26:00,720
i'll also try to not apologize too much

78
00:26:00,720 --> 00:26:02,000
i will say

79
00:26:02,000 --> 00:26:04,240
that judging by the size of today's

80
00:26:04,240 --> 00:26:06,880
early morning audience everybody had a

81
00:26:06,880 --> 00:26:10,880
really great time last night so yeah way

82
00:26:10,880 --> 00:26:13,200
to go folks um

83
00:26:13,200 --> 00:26:16,000
my um my extremely

84
00:26:16,000 --> 00:26:18,159
broken bodied friends

85
00:26:18,159 --> 00:26:20,799
yeah i i see somebody here who

86
00:26:20,799 --> 00:26:22,320
went went hard

87
00:26:22,320 --> 00:26:25,840
all right um

88
00:26:25,919 --> 00:26:27,840
they didn't have to carry you out tracy

89
00:26:27,840 --> 00:26:30,080
so that's you know that that's the you

90
00:26:30,080 --> 00:26:31,919
know like you can hold your head up high

91
00:26:31,919 --> 00:26:32,880
you were

92
00:26:32,880 --> 00:26:34,080
yeah

93
00:26:34,080 --> 00:26:35,279
um

94
00:26:35,279 --> 00:26:39,080
i just did it

95
00:26:40,000 --> 00:26:42,720
i'm going to

96
00:26:42,720 --> 00:26:45,200
like we did yesterday

97
00:26:45,200 --> 00:26:47,919
stay on schedule and so i will quickly

98
00:26:47,919 --> 00:26:49,520
segue

99
00:26:49,520 --> 00:26:50,840
to

100
00:26:50,840 --> 00:26:54,559
introducing our first speaker

101
00:26:54,559 --> 00:26:58,720
philip tenan who will be discussing

102
00:26:58,720 --> 00:27:00,960
um

103
00:27:01,760 --> 00:27:04,000
virtual memory i can't remember anything

104
00:27:04,000 --> 00:27:06,320
right now so you know maybe these are

105
00:27:06,320 --> 00:27:08,720
virtual memories that i'm having uh so

106
00:27:08,720 --> 00:27:12,480
please warm summer con day two welcome

107
00:27:12,480 --> 00:27:15,530
for philip tennant

108
00:27:15,530 --> 00:27:21,569
[Applause]

109
00:27:32,000 --> 00:27:33,600
i didn't help anyone with this yesterday

110
00:27:33,600 --> 00:27:35,760
i was basically like good luck you're on

111
00:27:35,760 --> 00:27:39,039
your own today somehow you got help

112
00:27:39,039 --> 00:27:41,120
thank you

113
00:27:41,120 --> 00:27:42,159
all right

114
00:27:42,159 --> 00:27:44,960
any second now

115
00:27:46,000 --> 00:27:48,399
it usually just takes

116
00:27:48,399 --> 00:27:49,679
okay cool

117
00:27:49,679 --> 00:27:51,600
um i've got to wear these sunglasses

118
00:27:51,600 --> 00:27:52,960
because after day one it's way too

119
00:27:52,960 --> 00:27:55,520
bright in here

120
00:27:55,520 --> 00:27:57,440
okay that's going to be the only prop

121
00:27:57,440 --> 00:27:59,679
based humor uh for the duration of the

122
00:27:59,679 --> 00:28:01,200
talk or so i hope

123
00:28:01,200 --> 00:28:03,200
um all right good morning everyone so a

124
00:28:03,200 --> 00:28:05,840
little bit about me uh like any good

125
00:28:05,840 --> 00:28:08,399
employee i uh derive my identity from my

126
00:28:08,399 --> 00:28:09,440
employer

127
00:28:09,440 --> 00:28:11,520
so i work at this company it's called

128
00:28:11,520 --> 00:28:13,360
data theorem they're pretty cool

129
00:28:13,360 --> 00:28:14,880
um

130
00:28:14,880 --> 00:28:16,640
i'm also an operating systems nerd i

131
00:28:16,640 --> 00:28:18,960
spend an inordinate amount of my life

132
00:28:18,960 --> 00:28:21,679
working on a hobby operating system uh

133
00:28:21,679 --> 00:28:23,520
that's going to be useful for a few bits

134
00:28:23,520 --> 00:28:25,200
here and there

135
00:28:25,200 --> 00:28:27,200
uh and i also really enjoy static

136
00:28:27,200 --> 00:28:28,640
analysis it's one of the things that i

137
00:28:28,640 --> 00:28:30,960
really enjoy at data theorem statically

138
00:28:30,960 --> 00:28:33,360
analyzing you know tens of thousands of

139
00:28:33,360 --> 00:28:35,120
ios apps

140
00:28:35,120 --> 00:28:36,640
okay with that

141
00:28:36,640 --> 00:28:38,880
uh paging all hackers virtual memory

142
00:28:38,880 --> 00:28:40,000
attacks we're going to be talking about

143
00:28:40,000 --> 00:28:41,760
memory today

144
00:28:41,760 --> 00:28:42,799
so

145
00:28:42,799 --> 00:28:44,720
i hope you've had your coffees so far if

146
00:28:44,720 --> 00:28:46,080
not feel free to grab an espresso

147
00:28:46,080 --> 00:28:50,159
martini and uh we should be good

148
00:28:50,159 --> 00:28:52,159
okay so if you're already familiar with

149
00:28:52,159 --> 00:28:53,840
virtual memory try to just put that to

150
00:28:53,840 --> 00:28:55,039
one side for a moment we're going to

151
00:28:55,039 --> 00:28:57,200
kind of start from first principles and

152
00:28:57,200 --> 00:28:58,720
see like why this is useful what

153
00:28:58,720 --> 00:29:00,240
problems it's solving

154
00:29:00,240 --> 00:29:03,039
so if we imagine all of the ram uh in a

155
00:29:03,039 --> 00:29:04,720
machine it's just a big list of bytes

156
00:29:04,720 --> 00:29:06,159
and it's bite addressed so the first

157
00:29:06,159 --> 00:29:09,360
byte by dr0 going up to however many

158
00:29:09,360 --> 00:29:11,200
bytes you have installed

159
00:29:11,200 --> 00:29:12,640
in ram

160
00:29:12,640 --> 00:29:14,399
okay let's pretend we're the operating

161
00:29:14,399 --> 00:29:16,480
system and the user has like double

162
00:29:16,480 --> 00:29:18,399
clicked a program or something wants to

163
00:29:18,399 --> 00:29:20,320
start for some reason so we the

164
00:29:20,320 --> 00:29:22,240
operating system are going to want to

165
00:29:22,240 --> 00:29:24,640
load this program into memory it's not a

166
00:29:24,640 --> 00:29:26,640
problem our memory is nice and free so

167
00:29:26,640 --> 00:29:28,720
we can just pick any place and slide it

168
00:29:28,720 --> 00:29:29,679
in

169
00:29:29,679 --> 00:29:31,360
uh okay the user double-clicks something

170
00:29:31,360 --> 00:29:32,799
else still no worries we've got lots of

171
00:29:32,799 --> 00:29:34,960
free space pick another slot and load it

172
00:29:34,960 --> 00:29:36,320
into memory

173
00:29:36,320 --> 00:29:38,640
uh okay here's where our problems begin

174
00:29:38,640 --> 00:29:40,320
the user has double-clicked another

175
00:29:40,320 --> 00:29:42,399
program and we actually do have enough

176
00:29:42,399 --> 00:29:44,480
memory to fulfill this request but it's

177
00:29:44,480 --> 00:29:46,240
become fragmented it's split between the

178
00:29:46,240 --> 00:29:48,080
beginning and end

179
00:29:48,080 --> 00:29:50,240
of the address space

180
00:29:50,240 --> 00:29:51,440
and this is our first problem with a

181
00:29:51,440 --> 00:29:53,679
kind of bare approach to ram we have

182
00:29:53,679 --> 00:29:55,679
memory fragmentation and we can't kind

183
00:29:55,679 --> 00:29:57,279
of do anything about it we can't deal

184
00:29:57,279 --> 00:29:58,960
with it well

185
00:29:58,960 --> 00:29:59,760
um

186
00:29:59,760 --> 00:30:01,360
the second problem comes about if we go

187
00:30:01,360 --> 00:30:03,679
back to this two-program approach and uh

188
00:30:03,679 --> 00:30:05,200
now we've got two programs in memory so

189
00:30:05,200 --> 00:30:06,480
the first one it's doing something

190
00:30:06,480 --> 00:30:08,720
really sensitive you know maybe it's got

191
00:30:08,720 --> 00:30:10,399
the user's password stored in memory

192
00:30:10,399 --> 00:30:12,159
maybe it's got some

193
00:30:12,159 --> 00:30:14,159
you know some private keys basically all

194
00:30:14,159 --> 00:30:15,679
kinds of sensitive data that you really

195
00:30:15,679 --> 00:30:18,559
don't want falling into the wrong hands

196
00:30:18,559 --> 00:30:20,480
okay over here on the right we have the

197
00:30:20,480 --> 00:30:22,720
wrong hands so this program can just go

198
00:30:22,720 --> 00:30:24,960
through all of memory reading it at will

199
00:30:24,960 --> 00:30:26,799
and extracting this private data there's

200
00:30:26,799 --> 00:30:28,960
nothing stopping it from doing this

201
00:30:28,960 --> 00:30:30,880
it has kind of you know unfettered

202
00:30:30,880 --> 00:30:33,360
access to all of memory

203
00:30:33,360 --> 00:30:35,360
not only can it read it can also write

204
00:30:35,360 --> 00:30:37,120
which is really scary because you could

205
00:30:37,120 --> 00:30:39,200
just like change the code of another

206
00:30:39,200 --> 00:30:40,799
running program to like insert a key

207
00:30:40,799 --> 00:30:42,480
logger or really do anything you want to

208
00:30:42,480 --> 00:30:43,520
do

209
00:30:43,520 --> 00:30:46,720
it's game over from day one

210
00:30:46,720 --> 00:30:48,799
so this is our second problem no concept

211
00:30:48,799 --> 00:30:50,559
of memory protection

212
00:30:50,559 --> 00:30:51,760
uh in this approach i'm just going to

213
00:30:51,760 --> 00:30:54,080
move that yep cool

214
00:30:54,080 --> 00:30:55,520
third problem we've got three programs

215
00:30:55,520 --> 00:30:56,960
loaded in memory the user wants to load

216
00:30:56,960 --> 00:30:58,480
another one but of course we can't do

217
00:30:58,480 --> 00:31:00,320
that because uh we're under high memory

218
00:31:00,320 --> 00:31:02,080
pressure and have no strategy for you

219
00:31:02,080 --> 00:31:03,519
know freeing up some of that memory so

220
00:31:03,519 --> 00:31:05,919
we can do more with it

221
00:31:05,919 --> 00:31:07,760
okay so the solution to a lot of these

222
00:31:07,760 --> 00:31:10,000
problems uh it's called paging um first

223
00:31:10,000 --> 00:31:11,279
things first let's get our definition

224
00:31:11,279 --> 00:31:12,640
straight there are a few kinds of paging

225
00:31:12,640 --> 00:31:14,480
we're not going to be talking about we

226
00:31:14,480 --> 00:31:16,960
are talking about uh paging as this

227
00:31:16,960 --> 00:31:18,640
memory virtualization technique so it

228
00:31:18,640 --> 00:31:21,120
allows us to take memory and rather than

229
00:31:21,120 --> 00:31:22,320
access it directly it becomes

230
00:31:22,320 --> 00:31:23,919
virtualized meaning that we have some

231
00:31:23,919 --> 00:31:27,919
kind of intermediary allowing us to uh

232
00:31:27,919 --> 00:31:30,000
kind of abstract it away in some sense

233
00:31:30,000 --> 00:31:31,440
in this talk we're going to be talking

234
00:31:31,440 --> 00:31:32,960
about some background of paging kind of

235
00:31:32,960 --> 00:31:35,440
structure and implementation uh some of

236
00:31:35,440 --> 00:31:37,039
the really cool security features that

237
00:31:37,039 --> 00:31:39,519
you can build on top of paging

238
00:31:39,519 --> 00:31:42,080
as well as uh yeah performance features

239
00:31:42,080 --> 00:31:44,720
security kind of defenses as well as

240
00:31:44,720 --> 00:31:46,799
some attacks that you can do

241
00:31:46,799 --> 00:31:48,240
we've also got a couple of demos which

242
00:31:48,240 --> 00:31:50,159
should be fun hopefully they won't fail

243
00:31:50,159 --> 00:31:52,799
but if i do we'll roll with it

244
00:31:52,799 --> 00:31:53,679
um

245
00:31:53,679 --> 00:31:55,840
paging is a kind of general technique

246
00:31:55,840 --> 00:31:57,600
across a lot of instruction set

247
00:31:57,600 --> 00:31:59,519
architectures so these concepts should

248
00:31:59,519 --> 00:32:02,159
carry over um occasionally i'll throw in

249
00:32:02,159 --> 00:32:05,679
the kind of specific bit uh about x864

250
00:32:05,679 --> 00:32:07,919
or arm64 or whatever i'll try and call

251
00:32:07,919 --> 00:32:10,880
those out uh when they happen

252
00:32:10,880 --> 00:32:13,600
okay so the core idea of paging if we go

253
00:32:13,600 --> 00:32:15,360
back to our model of ram as a big list

254
00:32:15,360 --> 00:32:18,000
of bytes uh kind of the central idea of

255
00:32:18,000 --> 00:32:20,000
paging is that we don't just have this

256
00:32:20,000 --> 00:32:22,080
contiguous stream anymore we split up

257
00:32:22,080 --> 00:32:23,519
the physical ram

258
00:32:23,519 --> 00:32:26,320
into these uh evenly sized chunks

259
00:32:26,320 --> 00:32:28,000
normally four kilobytes they can also be

260
00:32:28,000 --> 00:32:29,840
16 but we'll use four because it's kind

261
00:32:29,840 --> 00:32:31,600
of simple

262
00:32:31,600 --> 00:32:33,440
and uh traditional

263
00:32:33,440 --> 00:32:35,200
and then paging also introduces this

264
00:32:35,200 --> 00:32:37,120
concept of virtual ram so it's got the

265
00:32:37,120 --> 00:32:39,279
same divisions these same four kilobyte

266
00:32:39,279 --> 00:32:41,519
divisions uh but instead of beco being

267
00:32:41,519 --> 00:32:43,120
called frames each of these four

268
00:32:43,120 --> 00:32:44,960
kilobyte chunks they're called pages and

269
00:32:44,960 --> 00:32:47,200
now here's the core trick here's the the

270
00:32:47,200 --> 00:32:49,440
central idea you can take one of these

271
00:32:49,440 --> 00:32:51,519
pages and this is going to map to some

272
00:32:51,519 --> 00:32:52,880
you know segment of addresses in this

273
00:32:52,880 --> 00:32:56,159
case it'll be ox 7000 to ox 8000 and you

274
00:32:56,159 --> 00:32:58,559
can set things up in such a way that any

275
00:32:58,559 --> 00:33:00,159
time someone tries to access that

276
00:33:00,159 --> 00:33:02,080
address it will get redirected to a

277
00:33:02,080 --> 00:33:04,159
different physical frame in this example

278
00:33:04,159 --> 00:33:06,640
it's 4 000 to 5000 but of course that's

279
00:33:06,640 --> 00:33:08,240
arbitrary you could instead redirect

280
00:33:08,240 --> 00:33:11,120
this page to you know 9000 to 8000 or

281
00:33:11,120 --> 00:33:12,320
you could do what's called an identity

282
00:33:12,320 --> 00:33:14,240
map

283
00:33:14,240 --> 00:33:17,279
and map it to the same

284
00:33:17,279 --> 00:33:18,399
the virtual address and the physical

285
00:33:18,399 --> 00:33:20,000
address will match there's one more

286
00:33:20,000 --> 00:33:21,440
really important thing you can do with

287
00:33:21,440 --> 00:33:23,600
paging you can set permissions

288
00:33:23,600 --> 00:33:25,679
on each page so i can say okay this page

289
00:33:25,679 --> 00:33:27,279
can only be read from it can't be

290
00:33:27,279 --> 00:33:28,799
written to

291
00:33:28,799 --> 00:33:30,240
of course also read write and you can

292
00:33:30,240 --> 00:33:33,360
say that a page can only be accessible

293
00:33:33,360 --> 00:33:34,720
by the kernel it can't be used from

294
00:33:34,720 --> 00:33:36,960
userland

295
00:33:36,960 --> 00:33:38,960
okay so of course the way this works is

296
00:33:38,960 --> 00:33:41,200
the cpu is no longer hooked up directly

297
00:33:41,200 --> 00:33:43,519
to ram instead there's an intermediary

298
00:33:43,519 --> 00:33:44,960
in the middle this memory management

299
00:33:44,960 --> 00:33:45,840
unit

300
00:33:45,840 --> 00:33:48,240
or mmu so anytime the

301
00:33:48,240 --> 00:33:51,120
cpu tries to do memory access

302
00:33:51,120 --> 00:33:53,200
it'll get kind of intercepted by the mmu

303
00:33:53,200 --> 00:33:55,679
the mmu will consult the you know paging

304
00:33:55,679 --> 00:33:57,760
information that's been set up and then

305
00:33:57,760 --> 00:33:59,440
make sure the accesses are okay make

306
00:33:59,440 --> 00:34:01,039
sure they're allowed and finally it'll

307
00:34:01,039 --> 00:34:02,960
redirect it to the to the real physical

308
00:34:02,960 --> 00:34:05,279
address uh represented by that virtual

309
00:34:05,279 --> 00:34:07,279
address

310
00:34:07,279 --> 00:34:08,719
okay of course we're going to need some

311
00:34:08,719 --> 00:34:11,679
kind of of accounting to keep track of

312
00:34:11,679 --> 00:34:14,000
like you know what page is set up to

313
00:34:14,000 --> 00:34:15,599
what frame and what permissions are on

314
00:34:15,599 --> 00:34:17,679
that frame and as it turns out this

315
00:34:17,679 --> 00:34:21,199
accounting takes up eight bytes uh for a

316
00:34:21,199 --> 00:34:23,440
page or for a frame so for every eight

317
00:34:23,440 --> 00:34:26,560
bytes i'm sorry for every four kilobyte

318
00:34:26,560 --> 00:34:29,359
frame or page we need to use eight bytes

319
00:34:29,359 --> 00:34:31,839
of ram to you know kind of keep track of

320
00:34:31,839 --> 00:34:35,280
it to account for it okay so once again

321
00:34:35,280 --> 00:34:37,520
the bookkeeping for a page occupies

322
00:34:37,520 --> 00:34:40,239
eight bytes and it describes 4096 bytes

323
00:34:40,239 --> 00:34:41,679
four kilobytes

324
00:34:41,679 --> 00:34:45,040
um this is going somewhere i promise

325
00:34:45,040 --> 00:34:47,280
okay so one way that you might think of

326
00:34:47,280 --> 00:34:48,560
doing this is all right we need some

327
00:34:48,560 --> 00:34:50,719
bookkeeping we need to you know keep

328
00:34:50,719 --> 00:34:53,440
track of where the physical frames are

329
00:34:53,440 --> 00:34:55,679
backing each virtual page one idea you

330
00:34:55,679 --> 00:34:58,400
might kind of do for this is

331
00:34:58,400 --> 00:35:01,920
you just have a big list of all of the

332
00:35:01,920 --> 00:35:04,560
physical frames that you have

333
00:35:04,560 --> 00:35:06,400
and you just keep this big list

334
00:35:06,400 --> 00:35:08,960
you know one for every physical frame

335
00:35:08,960 --> 00:35:11,200
this seems like a kind of natural idea

336
00:35:11,200 --> 00:35:13,359
but uh there's a pretty big problem with

337
00:35:13,359 --> 00:35:15,359
it the problem is is that since we need

338
00:35:15,359 --> 00:35:18,000
eight bytes for every 40 96 bytes

339
00:35:18,000 --> 00:35:20,160
that's a factor of 512. so

340
00:35:20,160 --> 00:35:23,119
we're actually spending a 512th of our

341
00:35:23,119 --> 00:35:25,040
total available memory just on memory

342
00:35:25,040 --> 00:35:26,320
bookkeeping

343
00:35:26,320 --> 00:35:27,920
now maybe that sounds like a lot maybe

344
00:35:27,920 --> 00:35:29,760
it doesn't it's actually a ton

345
00:35:29,760 --> 00:35:31,119
because what it means is that if you

346
00:35:31,119 --> 00:35:32,800
have a different virtual address space a

347
00:35:32,800 --> 00:35:34,480
different set of bookkeeping tables for

348
00:35:34,480 --> 00:35:37,440
every process as soon as you've hit 512

349
00:35:37,440 --> 00:35:38,720
processes

350
00:35:38,720 --> 00:35:40,480
you've spent all of your memory budget

351
00:35:40,480 --> 00:35:42,720
just on bookkeeping memory itself so you

352
00:35:42,720 --> 00:35:44,800
need something better

353
00:35:44,800 --> 00:35:46,160
okay so the path here is we're going to

354
00:35:46,160 --> 00:35:47,920
look at instead of that naive approach

355
00:35:47,920 --> 00:35:49,040
we're going to look at the actual

356
00:35:49,040 --> 00:35:50,800
approach that's used and then we're

357
00:35:50,800 --> 00:35:52,079
going to kind of look at some of the

358
00:35:52,079 --> 00:35:53,599
implications of this and this will lead

359
00:35:53,599 --> 00:35:56,079
us to our first security defense that

360
00:35:56,079 --> 00:35:57,599
paging allows

361
00:35:57,599 --> 00:35:59,760
so there's a bit of a bit of setup work

362
00:35:59,760 --> 00:36:02,320
to do here but it's it'll it'll help us

363
00:36:02,320 --> 00:36:03,599
in the end

364
00:36:03,599 --> 00:36:04,560
okay

365
00:36:04,560 --> 00:36:06,160
so the way that it actually works is

366
00:36:06,160 --> 00:36:08,079
instead of having this list of

367
00:36:08,079 --> 00:36:10,160
accounting for every frame in the system

368
00:36:10,160 --> 00:36:14,560
this list is exactly 512 entries long

369
00:36:14,560 --> 00:36:15,920
this is called the page mapping level

370
00:36:15,920 --> 00:36:17,839
one and since each of these entries

371
00:36:17,839 --> 00:36:19,839
corresponds to four kilobytes of address

372
00:36:19,839 --> 00:36:20,800
space

373
00:36:20,800 --> 00:36:23,839
this whole 512 entry table covers two

374
00:36:23,839 --> 00:36:26,000
megabytes of address space so each of

375
00:36:26,000 --> 00:36:27,920
those entries is eight bytes

376
00:36:27,920 --> 00:36:29,920
um

377
00:36:29,920 --> 00:36:32,320
and uh yeah the the page mapping level

378
00:36:32,320 --> 00:36:34,320
one itself it's eight bytes times five

379
00:36:34,320 --> 00:36:36,240
hundred and twelve meaning it itself

380
00:36:36,240 --> 00:36:38,720
occupies exactly one frame in this very

381
00:36:38,720 --> 00:36:40,400
neat and tidy way

382
00:36:40,400 --> 00:36:42,800
and it describes 512 pages or two

383
00:36:42,800 --> 00:36:45,359
megabytes of address space

384
00:36:45,359 --> 00:36:47,839
okay obviously we can't do so much with

385
00:36:47,839 --> 00:36:49,920
two megabytes we've got a a large

386
00:36:49,920 --> 00:36:51,200
address space to cover so we've got to

387
00:36:51,200 --> 00:36:53,119
do more so we actually have another

388
00:36:53,119 --> 00:36:54,640
table it's called the page mapping level

389
00:36:54,640 --> 00:36:56,720
two it's the same idea it occupies a

390
00:36:56,720 --> 00:36:59,280
frame it's got 512 entries but each

391
00:36:59,280 --> 00:37:01,520
entry rather than directly describing a

392
00:37:01,520 --> 00:37:03,680
physical frame it instead describes an

393
00:37:03,680 --> 00:37:05,760
entire page mapping level one so you've

394
00:37:05,760 --> 00:37:08,160
got 512 page mapping level ones they're

395
00:37:08,160 --> 00:37:10,079
each two megabytes which means that a

396
00:37:10,079 --> 00:37:12,160
page mapping level two covers a gigabyte

397
00:37:12,160 --> 00:37:13,839
of address space

398
00:37:13,839 --> 00:37:15,839
and again just to drive this home a page

399
00:37:15,839 --> 00:37:18,160
mapping level two occupies one frame but

400
00:37:18,160 --> 00:37:20,079
describes in total if you like followed

401
00:37:20,079 --> 00:37:21,599
all the links in it a gigabyte of

402
00:37:21,599 --> 00:37:23,119
address space

403
00:37:23,119 --> 00:37:25,040
um if this is all making sense so far

404
00:37:25,040 --> 00:37:26,240
that's really great because you just

405
00:37:26,240 --> 00:37:27,520
continue the trick again you've got a

406
00:37:27,520 --> 00:37:30,079
page mapping level three it's got 512

407
00:37:30,079 --> 00:37:31,680
entries each of which are eight bytes

408
00:37:31,680 --> 00:37:34,240
meaning it occupies a frame

409
00:37:34,240 --> 00:37:36,560
uh and describes 512 gigabytes of

410
00:37:36,560 --> 00:37:37,680
address space

411
00:37:37,680 --> 00:37:39,200
and

412
00:37:39,200 --> 00:37:40,880
thankfully it ends here there's one more

413
00:37:40,880 --> 00:37:42,720
table the page mapping level four it

414
00:37:42,720 --> 00:37:45,440
contains 512 page mapping level threes

415
00:37:45,440 --> 00:37:47,680
for a grand total of the ability to talk

416
00:37:47,680 --> 00:37:51,760
about 256 terabytes of virtual address

417
00:37:51,760 --> 00:37:52,880
space

418
00:37:52,880 --> 00:37:56,000
okay thanks for bearing with me

419
00:37:56,000 --> 00:37:57,599
um yeah and this stops here the

420
00:37:57,599 --> 00:37:59,200
operating system sets up this page

421
00:37:59,200 --> 00:38:00,880
mapping level 4 and whatever tables

422
00:38:00,880 --> 00:38:02,960
inside it needs and then it hands it off

423
00:38:02,960 --> 00:38:06,400
to the cpu so the mmu can do its work

424
00:38:06,400 --> 00:38:07,599
okay so

425
00:38:07,599 --> 00:38:09,200
hold on this actually seems like a lot

426
00:38:09,200 --> 00:38:11,040
more bookkeeping first we just had that

427
00:38:11,040 --> 00:38:12,720
kind of nice simple list now we've got

428
00:38:12,720 --> 00:38:15,200
these like recursive nested tables how

429
00:38:15,200 --> 00:38:17,680
is this kind of helping us at all

430
00:38:17,680 --> 00:38:19,280
well

431
00:38:19,280 --> 00:38:20,720
you can have holes

432
00:38:20,720 --> 00:38:23,040
you don't need to fill out kind of all

433
00:38:23,040 --> 00:38:24,400
of the

434
00:38:24,400 --> 00:38:26,160
all of the recursive tables you only

435
00:38:26,160 --> 00:38:27,520
need to fill in the tables for the

436
00:38:27,520 --> 00:38:28,880
pieces of the address space that you

437
00:38:28,880 --> 00:38:30,800
actually care to use

438
00:38:30,800 --> 00:38:32,720
so another way of visualizing this if i

439
00:38:32,720 --> 00:38:34,640
don't care about this segment of the

440
00:38:34,640 --> 00:38:36,320
virtual address space in the middle i

441
00:38:36,320 --> 00:38:38,079
don't need to allocate that memory to

442
00:38:38,079 --> 00:38:39,280
keep track of it

443
00:38:39,280 --> 00:38:40,800
and of course this works at any level

444
00:38:40,800 --> 00:38:42,480
you just uh you only keep track of the

445
00:38:42,480 --> 00:38:44,560
stuff that you you know want to if you

446
00:38:44,560 --> 00:38:47,760
want to be able to access that memory

447
00:38:47,760 --> 00:38:49,760
okay so if we take a look at the anatomy

448
00:38:49,760 --> 00:38:52,160
of a virtual address

449
00:38:52,160 --> 00:38:54,400
it's of course 64 bits and each of those

450
00:38:54,400 --> 00:38:57,280
bits is actually describing to the mmu

451
00:38:57,280 --> 00:38:59,119
how you're going to find the information

452
00:38:59,119 --> 00:39:00,960
within those paging structures

453
00:39:00,960 --> 00:39:02,880
so the top 16 bits are unused we'll come

454
00:39:02,880 --> 00:39:04,800
back to those but then the next groups

455
00:39:04,800 --> 00:39:06,960
of nine bits give you the indexes into

456
00:39:06,960 --> 00:39:08,800
that page mapping level four index into

457
00:39:08,800 --> 00:39:11,839
the page mapping level three etc to uh

458
00:39:11,839 --> 00:39:12,960
see where you're going to find the

459
00:39:12,960 --> 00:39:15,520
information about that physical

460
00:39:15,520 --> 00:39:17,680
frame and then the bottom 12 bits give

461
00:39:17,680 --> 00:39:19,359
you the offset within the frame and

462
00:39:19,359 --> 00:39:20,640
we'll take a look at a more concrete

463
00:39:20,640 --> 00:39:22,400
example in a second here

464
00:39:22,400 --> 00:39:24,320
so this is a just a you know made up

465
00:39:24,320 --> 00:39:26,000
virtual address we can express it in

466
00:39:26,000 --> 00:39:28,560
binary and do those divisions that i

467
00:39:28,560 --> 00:39:30,640
showed a moment ago

468
00:39:30,640 --> 00:39:32,800
and you can see when the mmu tries to

469
00:39:32,800 --> 00:39:34,800
dereference this address it'll look at

470
00:39:34,800 --> 00:39:36,320
each of those chunks it'll say okay i'm

471
00:39:36,320 --> 00:39:38,720
going to go to the zero with index

472
00:39:38,720 --> 00:39:41,119
pardon me of the page mapping level four

473
00:39:41,119 --> 00:39:43,200
zero with index of the third table the

474
00:39:43,200 --> 00:39:45,599
third index of the second table 130th of

475
00:39:45,599 --> 00:39:47,359
the first you get the idea

476
00:39:47,359 --> 00:39:51,280
um and then it'll read 324 bytes into

477
00:39:51,280 --> 00:39:53,520
that physical frame to get the final

478
00:39:53,520 --> 00:39:56,079
physical memory address

479
00:39:56,079 --> 00:39:58,640
and notice those high 16 bits those red

480
00:39:58,640 --> 00:40:02,160
bits over on the right are all zeros

481
00:40:02,160 --> 00:40:03,920
yeah

482
00:40:03,920 --> 00:40:05,280
okay we can do the same kind of

483
00:40:05,280 --> 00:40:07,520
decomposition with a kind of higher

484
00:40:07,520 --> 00:40:10,160
memory address so exact same idea we've

485
00:40:10,160 --> 00:40:11,839
got a memory address we can split it up

486
00:40:11,839 --> 00:40:14,240
into those indexes uh we can visualize

487
00:40:14,240 --> 00:40:15,440
what that would look like in those page

488
00:40:15,440 --> 00:40:17,920
mapping tables everything makes sense

489
00:40:17,920 --> 00:40:20,640
except for now those high 16 bits are

490
00:40:20,640 --> 00:40:22,560
all ones before they were all zeros

491
00:40:22,560 --> 00:40:24,480
what's what's the deal with that well

492
00:40:24,480 --> 00:40:26,160
actually there's a rule here you take

493
00:40:26,160 --> 00:40:28,240
the value in that 48th high bit and then

494
00:40:28,240 --> 00:40:30,079
you have to copy it and assign extension

495
00:40:30,079 --> 00:40:32,560
to uh the upper 16 bits so those upper

496
00:40:32,560 --> 00:40:37,359
16 bits are either all zeros or all ones

497
00:40:37,680 --> 00:40:40,319
and they have to match that bit

498
00:40:40,319 --> 00:40:42,160
and this leads us to a really kind of

499
00:40:42,160 --> 00:40:43,280
interesting

500
00:40:43,280 --> 00:40:45,119
concept here because we're working in a

501
00:40:45,119 --> 00:40:47,760
64-bit system but we can't actually use

502
00:40:47,760 --> 00:40:49,359
all of those 64 bits in the address

503
00:40:49,359 --> 00:40:51,760
space no the addresses that are possible

504
00:40:51,760 --> 00:40:54,000
to represent with this kind of four

505
00:40:54,000 --> 00:40:56,560
table you know four level scheme are all

506
00:40:56,560 --> 00:40:59,440
of the addresses where those uh top 16

507
00:40:59,440 --> 00:41:02,000
bits are zero that's 128 terabytes of

508
00:41:02,000 --> 00:41:03,760
possible addresses and then all the

509
00:41:03,760 --> 00:41:05,599
addresses where those upper 16 bits are

510
00:41:05,599 --> 00:41:08,319
all ones that's another 128 terabytes

511
00:41:08,319 --> 00:41:10,160
but then we've got this massive portion

512
00:41:10,160 --> 00:41:12,240
of address space in between those two

513
00:41:12,240 --> 00:41:14,000
where you know those numbers those bits

514
00:41:14,000 --> 00:41:16,160
are some mixes of zeros and ones and

515
00:41:16,160 --> 00:41:17,839
these are impossible to talk about with

516
00:41:17,839 --> 00:41:18,640
uh

517
00:41:18,640 --> 00:41:22,160
what's called 48-bit addressing um

518
00:41:22,160 --> 00:41:23,680
and this region in the middle is really

519
00:41:23,680 --> 00:41:26,960
really big uh so we've we can use 256

520
00:41:26,960 --> 00:41:29,200
terabytes in this scheme but uh that

521
00:41:29,200 --> 00:41:31,760
unusable section is actually 16 million

522
00:41:31,760 --> 00:41:33,200
terabytes

523
00:41:33,200 --> 00:41:34,400
so it's really big

524
00:41:34,400 --> 00:41:36,000
surely someday we're going to need more

525
00:41:36,000 --> 00:41:37,839
of the address space of the full 64-bit

526
00:41:37,839 --> 00:41:40,240
address space for example i think intel

527
00:41:40,240 --> 00:41:42,160
has some extensions for doing 56-bit

528
00:41:42,160 --> 00:41:44,640
addressing 57-bit i know it's too early

529
00:41:44,640 --> 00:41:47,119
for arithmetic um

530
00:41:47,119 --> 00:41:49,680
but uh yeah for now 48-bit addressing is

531
00:41:49,680 --> 00:41:51,200
pretty much the norm

532
00:41:51,200 --> 00:41:52,640
and this of course raises the question

533
00:41:52,640 --> 00:41:54,240
can we do something more interesting

534
00:41:54,240 --> 00:41:56,000
with those bits rather than just having

535
00:41:56,000 --> 00:41:58,400
them be all zeros or all ones can we put

536
00:41:58,400 --> 00:42:00,480
them to some purpose to like

537
00:42:00,480 --> 00:42:02,720
drive user engagement or

538
00:42:02,720 --> 00:42:04,720
you know increase ad revenue

539
00:42:04,720 --> 00:42:06,319
well actually yes there are some some

540
00:42:06,319 --> 00:42:08,480
clever things you can do um so this is

541
00:42:08,480 --> 00:42:09,920
our first defense

542
00:42:09,920 --> 00:42:11,680
that was the kind of theory heavy part

543
00:42:11,680 --> 00:42:13,200
of the talk so again thanks for sticking

544
00:42:13,200 --> 00:42:14,079
with me

545
00:42:14,079 --> 00:42:15,280
uh and this first offense is called

546
00:42:15,280 --> 00:42:17,599
pointer authentication so rather than

547
00:42:17,599 --> 00:42:19,839
those high 16 bits just not really being

548
00:42:19,839 --> 00:42:22,000
put to any good use uh we're now going

549
00:42:22,000 --> 00:42:23,680
to store a crypto signature in them and

550
00:42:23,680 --> 00:42:26,160
this context value and so what you do is

551
00:42:26,160 --> 00:42:27,760
you take all those other parts the

552
00:42:27,760 --> 00:42:29,680
context and those indexes into the the

553
00:42:29,680 --> 00:42:31,680
paging tables and you fold them into a

554
00:42:31,680 --> 00:42:33,359
digest that gets stored in that crypto

555
00:42:33,359 --> 00:42:35,040
signature

556
00:42:35,040 --> 00:42:37,200
um and a really good question you might

557
00:42:37,200 --> 00:42:39,440
have is like okay what's that for and

558
00:42:39,440 --> 00:42:40,960
we'll look at that but one point i want

559
00:42:40,960 --> 00:42:43,200
to make first is that with signed

560
00:42:43,200 --> 00:42:45,440
pointers these pointers no longer refer

561
00:42:45,440 --> 00:42:47,520
to valid memory addresses they're

562
00:42:47,520 --> 00:42:50,079
instead like a kind of garbage value

563
00:42:50,079 --> 00:42:51,920
because it's got this additional data

564
00:42:51,920 --> 00:42:53,760
tacked onto it

565
00:42:53,760 --> 00:42:55,280
which is kind of neat

566
00:42:55,280 --> 00:42:57,200
um okay so what is point auth

567
00:42:57,200 --> 00:42:59,280
authentication good for well it's this

568
00:42:59,280 --> 00:43:00,720
extra defensive mechanism that's

569
00:43:00,720 --> 00:43:02,319
intended to make return oriented

570
00:43:02,319 --> 00:43:04,079
programming harder to achieve if you're

571
00:43:04,079 --> 00:43:05,680
not familiar with rob here's a quick

572
00:43:05,680 --> 00:43:08,640
little visualization so the idea is if

573
00:43:08,640 --> 00:43:10,079
for some reason you can't do like a

574
00:43:10,079 --> 00:43:11,599
classic buffer overflow attack but you

575
00:43:11,599 --> 00:43:13,760
still want to manipulate a system return

576
00:43:13,760 --> 00:43:15,520
oriented programming is one way to do

577
00:43:15,520 --> 00:43:18,480
that so over here on the left we've got

578
00:43:18,480 --> 00:43:21,119
two just innocuous pieces of code that

579
00:43:21,119 --> 00:43:22,720
exist in a program they're somewhere in

580
00:43:22,720 --> 00:43:24,880
the code of the program and each of them

581
00:43:24,880 --> 00:43:26,240
you know doesn't do anything interesting

582
00:43:26,240 --> 00:43:28,880
the top one just runs known binary the

583
00:43:28,880 --> 00:43:30,480
bottom one reads some user input and

584
00:43:30,480 --> 00:43:33,119
prints it out and the core idea behind

585
00:43:33,119 --> 00:43:35,040
return oriented programming is you can

586
00:43:35,040 --> 00:43:37,920
rearrange existing code in clever ways

587
00:43:37,920 --> 00:43:39,359
and and of course now what's happening

588
00:43:39,359 --> 00:43:41,680
here in the rearranged code is your you

589
00:43:41,680 --> 00:43:43,440
know reading user input and then running

590
00:43:43,440 --> 00:43:45,599
that so

591
00:43:45,599 --> 00:43:47,119
yeah the thing with pointer

592
00:43:47,119 --> 00:43:49,200
authentication is that

593
00:43:49,200 --> 00:43:51,200
each of these you know pieces of code

594
00:43:51,200 --> 00:43:52,640
that you would want to reuse has a

595
00:43:52,640 --> 00:43:54,160
signature and that signature would be

596
00:43:54,160 --> 00:43:56,640
invalid so the system would crash when

597
00:43:56,640 --> 00:43:59,119
you when you tried to do this attack

598
00:43:59,119 --> 00:44:02,079
um so okay we can't just pull pointers

599
00:44:02,079 --> 00:44:04,400
willy-nilly but can we sign a pointer

600
00:44:04,400 --> 00:44:07,440
ourselves well you could try but uh in

601
00:44:07,440 --> 00:44:09,359
fact you need one more piece of data

602
00:44:09,359 --> 00:44:10,880
that's only accessible in kernel space

603
00:44:10,880 --> 00:44:12,480
to sign pointers so it doesn't really

604
00:44:12,480 --> 00:44:13,280
work

605
00:44:13,280 --> 00:44:14,880
uh you can also just try brute forcing

606
00:44:14,880 --> 00:44:16,400
signatures but since every time you try

607
00:44:16,400 --> 00:44:17,920
to use a signed pointer that has an

608
00:44:17,920 --> 00:44:20,480
invalid signature the mmu will will you

609
00:44:20,480 --> 00:44:22,480
know throw an exception the program will

610
00:44:22,480 --> 00:44:24,480
crash every time so it's a pretty

611
00:44:24,480 --> 00:44:27,359
slow way to uh to break back

612
00:44:27,359 --> 00:44:28,800
there are of course ways around pac

613
00:44:28,800 --> 00:44:30,800
though one way is if you can find a

614
00:44:30,800 --> 00:44:32,160
snippet of assembly which will sign

615
00:44:32,160 --> 00:44:33,680
pointers for you

616
00:44:33,680 --> 00:44:35,760
you can use that so this is a little

617
00:44:35,760 --> 00:44:38,960
piece of assembly uh what it does is it

618
00:44:38,960 --> 00:44:41,359
loads the value from memory signs it and

619
00:44:41,359 --> 00:44:43,599
then stores it back in memory uh so if

620
00:44:43,599 --> 00:44:44,960
you can find one of these you can just

621
00:44:44,960 --> 00:44:47,200
sign arbitrary pointers and you know

622
00:44:47,200 --> 00:44:48,560
you're done but it's a cool technique

623
00:44:48,560 --> 00:44:50,960
nonetheless

624
00:44:50,960 --> 00:44:52,800
okay moving on to our first attack

625
00:44:52,800 --> 00:44:54,880
takeover via page mapping level one

626
00:44:54,880 --> 00:44:56,880
entry

627
00:44:56,880 --> 00:44:58,079
so

628
00:44:58,079 --> 00:45:00,960
uh if an attacker is able to gain access

629
00:45:00,960 --> 00:45:02,560
to one of these page mapping level one

630
00:45:02,560 --> 00:45:04,960
entries which again uh covers four

631
00:45:04,960 --> 00:45:06,480
kilobytes of the address space it's like

632
00:45:06,480 --> 00:45:08,400
the least significant part of these uh

633
00:45:08,400 --> 00:45:10,480
of this four level table it's totally

634
00:45:10,480 --> 00:45:11,760
game over and this might be a bit

635
00:45:11,760 --> 00:45:13,280
surprising because you might think that

636
00:45:13,280 --> 00:45:14,720
the page mapping level one entry is like

637
00:45:14,720 --> 00:45:16,560
the smallest kind of the least

638
00:45:16,560 --> 00:45:18,400
significant of the whole structure

639
00:45:18,400 --> 00:45:20,720
but uh yeah it's you're totally done if

640
00:45:20,720 --> 00:45:22,560
anyone does gain access to this because

641
00:45:22,560 --> 00:45:24,240
what the attacker can do

642
00:45:24,240 --> 00:45:27,040
is just change what physical frame that

643
00:45:27,040 --> 00:45:28,640
page mapping level one entry is pointing

644
00:45:28,640 --> 00:45:31,280
to and in doing so scan all of physical

645
00:45:31,280 --> 00:45:33,040
ram you know they can they can set this

646
00:45:33,040 --> 00:45:34,640
writable bit so they can write to any

647
00:45:34,640 --> 00:45:36,720
physical ram read from any physical ram

648
00:45:36,720 --> 00:45:40,000
it's it's it's game over um

649
00:45:40,000 --> 00:45:42,560
and i want to demo this now of course

650
00:45:42,560 --> 00:45:44,319
gaining access to a page mapping level

651
00:45:44,319 --> 00:45:45,760
one entry is something that you really

652
00:45:45,760 --> 00:45:47,440
should never be able to do in a secure

653
00:45:47,440 --> 00:45:49,599
system so i had to get creative with how

654
00:45:49,599 --> 00:45:51,920
i was going to present this um so one

655
00:45:51,920 --> 00:45:53,359
way of course is if you have some kind

656
00:45:53,359 --> 00:45:55,680
of you know zero day and

657
00:45:55,680 --> 00:45:57,200
some operating system you could exploit

658
00:45:57,200 --> 00:45:59,119
it i'm not going to do that

659
00:45:59,119 --> 00:46:00,400
as i mentioned i work on a hobby

660
00:46:00,400 --> 00:46:02,000
operating system and it was kind of

661
00:46:02,000 --> 00:46:03,680
quick and easy for me to modify my own

662
00:46:03,680 --> 00:46:06,240
os to grant an attacker program access

663
00:46:06,240 --> 00:46:08,400
to a page mapping level one entry so i'm

664
00:46:08,400 --> 00:46:10,319
using my own os here but you don't let

665
00:46:10,319 --> 00:46:12,560
that put you off the concepts are kind

666
00:46:12,560 --> 00:46:14,800
of at an architectural level rather than

667
00:46:14,800 --> 00:46:18,000
that an operating systems level

668
00:46:18,000 --> 00:46:20,480
okay hopefully this works

669
00:46:20,480 --> 00:46:21,920
so i'm going to launch my os in an

670
00:46:21,920 --> 00:46:24,480
emulator

671
00:46:25,119 --> 00:46:27,440
let's go full screen

672
00:46:27,440 --> 00:46:29,200
the background is pink for technical

673
00:46:29,200 --> 00:46:30,800
reasons

674
00:46:30,800 --> 00:46:31,920
ooh

675
00:46:31,920 --> 00:46:33,359
i was a bit worried about this the uh

676
00:46:33,359 --> 00:46:35,119
the backgrounds are randomly generated

677
00:46:35,119 --> 00:46:39,040
and sometimes they're a bit garish um

678
00:46:39,680 --> 00:46:41,440
yeah that's that's all right

679
00:46:41,440 --> 00:46:43,280
okay so i'm going to open up this

680
00:46:43,280 --> 00:46:46,000
program called exploit

681
00:46:46,000 --> 00:46:47,680
actually before i do that i'm going to

682
00:46:47,680 --> 00:46:49,520
get some sensitive data into memory so

683
00:46:49,520 --> 00:46:51,040
i'm just going to type in

684
00:46:51,040 --> 00:46:53,440
my secret password let's put that over

685
00:46:53,440 --> 00:46:55,119
there

686
00:46:55,119 --> 00:46:57,280
and you can see when this exploit this

687
00:46:57,280 --> 00:46:59,359
attacker program has launched it's uh

688
00:46:59,359 --> 00:47:01,440
requested a page mapping level one entry

689
00:47:01,440 --> 00:47:03,119
from the kernel and the kernel like a

690
00:47:03,119 --> 00:47:04,960
dummy has given it access

691
00:47:04,960 --> 00:47:06,800
um so

692
00:47:06,800 --> 00:47:08,480
it can now just scan all physical memory

693
00:47:08,480 --> 00:47:10,160
when i hit this big red button it'll do

694
00:47:10,160 --> 00:47:12,079
that and then what it's going to do is

695
00:47:12,079 --> 00:47:13,440
it's going to scan all the physical

696
00:47:13,440 --> 00:47:15,440
memory for strings

697
00:47:15,440 --> 00:47:17,119
and it'll print them over in this window

698
00:47:17,119 --> 00:47:18,800
and somewhere in there we'll see the

699
00:47:18,800 --> 00:47:22,079
sensitive data that i've entered

700
00:47:23,119 --> 00:47:24,960
yeah and uh over there on the left you

701
00:47:24,960 --> 00:47:26,559
can see all of the strings that are in

702
00:47:26,559 --> 00:47:28,480
physical memory a lot of this stuff is

703
00:47:28,480 --> 00:47:30,400
like symbol tables from loaded programs

704
00:47:30,400 --> 00:47:32,240
or unleaded programs even

705
00:47:32,240 --> 00:47:33,599
um

706
00:47:33,599 --> 00:47:36,319
but yeah it's it's totally game over now

707
00:47:36,319 --> 00:47:37,839
um this typically takes a couple of

708
00:47:37,839 --> 00:47:39,599
minutes so i'm not sure i'll let it run

709
00:47:39,599 --> 00:47:41,520
all the way through but if it did

710
00:47:41,520 --> 00:47:43,680
there's this big scary uh upload dump

711
00:47:43,680 --> 00:47:45,440
button that i could click

712
00:47:45,440 --> 00:47:45,740
um

713
00:47:45,740 --> 00:47:47,280
[Music]

714
00:47:47,280 --> 00:47:50,640
yeah let me just do a time check

715
00:47:51,040 --> 00:47:53,839
okay cool

716
00:47:55,440 --> 00:47:58,559
yeah all right i'll leave that b

717
00:47:58,559 --> 00:48:00,880
um

718
00:48:02,319 --> 00:48:05,520
okay defense number two aslr

719
00:48:05,520 --> 00:48:07,839
so we'll go back to our three programs

720
00:48:07,839 --> 00:48:09,599
in memory setup

721
00:48:09,599 --> 00:48:10,480
um

722
00:48:10,480 --> 00:48:11,839
so one thing i want to point out that's

723
00:48:11,839 --> 00:48:13,760
very kind of easy and natural to do with

724
00:48:13,760 --> 00:48:15,839
paging is if you note in our physical

725
00:48:15,839 --> 00:48:18,480
ram uh that goes from in the top left

726
00:48:18,480 --> 00:48:20,400
the bottom address zero to the top

727
00:48:20,400 --> 00:48:22,559
address in the top right uh

728
00:48:22,559 --> 00:48:24,640
b thousand so there's not very much

729
00:48:24,640 --> 00:48:26,319
physical memory here but one thing

730
00:48:26,319 --> 00:48:28,160
that's like really easy and natural to

731
00:48:28,160 --> 00:48:30,400
do with paging is to

732
00:48:30,400 --> 00:48:32,400
make a program think that it's loaded

733
00:48:32,400 --> 00:48:34,240
you know anywhere in memory in this case

734
00:48:34,240 --> 00:48:35,920
somewhere far higher than the actual

735
00:48:35,920 --> 00:48:37,599
memory we have available in the system

736
00:48:37,599 --> 00:48:38,960
just one of the many cool things you can

737
00:48:38,960 --> 00:48:41,200
do with paging in a very natural way

738
00:48:41,200 --> 00:48:43,040
um

739
00:48:43,040 --> 00:48:45,200
right so we've got three programs

740
00:48:45,200 --> 00:48:47,760
and notice that again easily they're

741
00:48:47,760 --> 00:48:50,240
loaded at different physical frames but

742
00:48:50,240 --> 00:48:51,839
it's very natural for us to make them

743
00:48:51,839 --> 00:48:53,200
all think that they're loaded at the

744
00:48:53,200 --> 00:48:55,599
same address so paging is an easy way to

745
00:48:55,599 --> 00:48:58,079
get stable loaded dresses but we can ask

746
00:48:58,079 --> 00:49:00,160
ourselves are stable load addresses such

747
00:49:00,160 --> 00:49:01,839
a good idea

748
00:49:01,839 --> 00:49:03,359
because if you remember in our rob

749
00:49:03,359 --> 00:49:05,280
attack this kind of relied on the

750
00:49:05,280 --> 00:49:07,040
attacker knowing that each of these

751
00:49:07,040 --> 00:49:08,160
functions was going to be at a

752
00:49:08,160 --> 00:49:10,400
particular memory location

753
00:49:10,400 --> 00:49:12,880
so what we can do instead is randomize

754
00:49:12,880 --> 00:49:13,920
where our programs are going to be

755
00:49:13,920 --> 00:49:16,000
loaded every time they launch so the

756
00:49:16,000 --> 00:49:17,920
idea here is that every time it launches

757
00:49:17,920 --> 00:49:19,680
it gets a different slide into virtual

758
00:49:19,680 --> 00:49:21,760
memory which makes it more difficult for

759
00:49:21,760 --> 00:49:23,359
an attacker to carry out an attack like

760
00:49:23,359 --> 00:49:25,200
return oriented programming

761
00:49:25,200 --> 00:49:26,800
this is an idea called address space

762
00:49:26,800 --> 00:49:30,559
layout randomization or aslr

763
00:49:30,800 --> 00:49:32,960
and it's it's been super common for the

764
00:49:32,960 --> 00:49:34,880
last 30 years it's a it's it's standard

765
00:49:34,880 --> 00:49:37,040
practice now

766
00:49:37,040 --> 00:49:39,280
okay moving on to our second attack

767
00:49:39,280 --> 00:49:40,559
dirty cow

768
00:49:40,559 --> 00:49:41,599
so we're going to do a little bit of

769
00:49:41,599 --> 00:49:43,920
background on on page vaults uh that'll

770
00:49:43,920 --> 00:49:46,160
help us uh kind of understand really in

771
00:49:46,160 --> 00:49:48,240
depth about uh cow and then we'll take a

772
00:49:48,240 --> 00:49:50,640
look at dirty cow

773
00:49:50,640 --> 00:49:52,000
all right how many times has this

774
00:49:52,000 --> 00:49:53,920
happened to you you're writing a program

775
00:49:53,920 --> 00:49:55,440
it's running it's doing a lot of

776
00:49:55,440 --> 00:49:56,960
computation and then right at the

777
00:49:56,960 --> 00:49:59,119
critical moment you see this message

778
00:49:59,119 --> 00:50:01,839
segmentation fault what is that uh and

779
00:50:01,839 --> 00:50:03,520
why is it stopping me from you know

780
00:50:03,520 --> 00:50:05,599
succeeding in what i want to compute

781
00:50:05,599 --> 00:50:07,359
well before i move on any further just a

782
00:50:07,359 --> 00:50:09,760
quick note segmentation is like a system

783
00:50:09,760 --> 00:50:11,200
that kind of came before paging it's

784
00:50:11,200 --> 00:50:12,720
like a precursor you can just read

785
00:50:12,720 --> 00:50:15,359
paging fault here so the bug is that

786
00:50:15,359 --> 00:50:18,079
someone has accessed some invalid memory

787
00:50:18,079 --> 00:50:19,599
for some reason maybe there's no pointer

788
00:50:19,599 --> 00:50:21,520
somewhere who knows

789
00:50:21,520 --> 00:50:22,880
um

790
00:50:22,880 --> 00:50:24,559
so i've written a little test program

791
00:50:24,559 --> 00:50:26,160
here just a tiny bit of c i don't

792
00:50:26,160 --> 00:50:28,319
recommend anyone writes more c than this

793
00:50:28,319 --> 00:50:30,319
this is probably just stop here four

794
00:50:30,319 --> 00:50:32,400
lines five lines

795
00:50:32,400 --> 00:50:33,760
um

796
00:50:33,760 --> 00:50:35,680
yeah and i'm de-referencing a no-pointer

797
00:50:35,680 --> 00:50:37,520
i'm trying to write to it just to force

798
00:50:37,520 --> 00:50:39,280
a crash of course and we can ask

799
00:50:39,280 --> 00:50:41,359
ourselves like why does this crash you

800
00:50:41,359 --> 00:50:42,400
know

801
00:50:42,400 --> 00:50:44,319
uh and if you think about it the null

802
00:50:44,319 --> 00:50:46,480
address is just a virtual memory

803
00:50:46,480 --> 00:50:48,160
location like any other

804
00:50:48,160 --> 00:50:49,440
we can do that virtual address

805
00:50:49,440 --> 00:50:51,440
decomposition we can traverse all of

806
00:50:51,440 --> 00:50:54,160
those tables and we'll realize there is

807
00:50:54,160 --> 00:50:56,000
some setup by the operating system you

808
00:50:56,000 --> 00:50:59,359
know there is an entry there uh with uh

809
00:50:59,359 --> 00:51:01,040
some frame assigned to it some read

810
00:51:01,040 --> 00:51:03,280
write permissions assigned to it

811
00:51:03,280 --> 00:51:04,800
and what's actually happening here is

812
00:51:04,800 --> 00:51:05,920
that the operating system has

813
00:51:05,920 --> 00:51:08,800
intentionally disabled any any access to

814
00:51:08,800 --> 00:51:10,720
this page and this is a feature this is

815
00:51:10,720 --> 00:51:13,040
intended to help you catch bugs uh if

816
00:51:13,040 --> 00:51:15,040
you're accessing the null pointer the no

817
00:51:15,040 --> 00:51:17,200
page

818
00:51:17,200 --> 00:51:19,200
you probably have messed up somewhere

819
00:51:19,200 --> 00:51:20,880
you've probably got some bug in your

820
00:51:20,880 --> 00:51:23,359
code so it's crashing early uh to kind

821
00:51:23,359 --> 00:51:25,920
of help you rather than um you know

822
00:51:25,920 --> 00:51:27,839
there's no magic here which i think is

823
00:51:27,839 --> 00:51:30,480
is quite cool

824
00:51:30,640 --> 00:51:32,000
and these mappings are set up by the

825
00:51:32,000 --> 00:51:33,920
operating system so when a binary loads

826
00:51:33,920 --> 00:51:35,119
typically it'll have some bit of

827
00:51:35,119 --> 00:51:37,280
metadata that says hey operating system

828
00:51:37,280 --> 00:51:40,000
please mark this you know bottom region

829
00:51:40,000 --> 00:51:41,839
of the address space the null page as

830
00:51:41,839 --> 00:51:43,520
inaccessible

831
00:51:43,520 --> 00:51:45,359
so if you take a look at a marko this is

832
00:51:45,359 --> 00:51:47,920
a marko analysis library that we have at

833
00:51:47,920 --> 00:51:49,440
data theorem

834
00:51:49,440 --> 00:51:51,440
you can see this page zero segment it's

835
00:51:51,440 --> 00:51:54,480
asking the operating system to disallow

836
00:51:54,480 --> 00:51:57,520
to map this but to disallow any use of

837
00:51:57,520 --> 00:51:59,280
it and what's really cool is that you

838
00:51:59,280 --> 00:52:00,960
can actually just go ahead and modify a

839
00:52:00,960 --> 00:52:04,079
binary and enable access to this null

840
00:52:04,079 --> 00:52:05,599
page and you can just read and write to

841
00:52:05,599 --> 00:52:07,599
the null pointer at will i'm not sure

842
00:52:07,599 --> 00:52:09,839
why you would do that aside for you know

843
00:52:09,839 --> 00:52:14,480
fun curiosity um but yeah

844
00:52:14,800 --> 00:52:16,319
okay

845
00:52:16,319 --> 00:52:17,440
we can ask ourselves a little bit

846
00:52:17,440 --> 00:52:19,359
further what is actually happening when

847
00:52:19,359 --> 00:52:21,599
you access an invalid address

848
00:52:21,599 --> 00:52:22,880
so what will happen here here we've got

849
00:52:22,880 --> 00:52:24,880
some assembly and then let's say some of

850
00:52:24,880 --> 00:52:26,800
it somewhere is accessing an invalid

851
00:52:26,800 --> 00:52:28,240
address maybe there

852
00:52:28,240 --> 00:52:30,000
what's going to happen is that the cpu

853
00:52:30,000 --> 00:52:32,480
will throw an exception and it'll jump

854
00:52:32,480 --> 00:52:34,720
into an exception handler within the

855
00:52:34,720 --> 00:52:37,119
operating system's kernel that the

856
00:52:37,119 --> 00:52:39,599
operating system has set up prior

857
00:52:39,599 --> 00:52:40,400
um

858
00:52:40,400 --> 00:52:42,079
so in the exception handler this is used

859
00:52:42,079 --> 00:52:44,079
for all sorts of things this is for like

860
00:52:44,079 --> 00:52:46,559
if you ask the cpu to divide by zero

861
00:52:46,559 --> 00:52:49,680
or um you try to run an invalid opcode

862
00:52:49,680 --> 00:52:51,760
uh or if you try to access invalid

863
00:52:51,760 --> 00:52:53,119
memory indeed so you've got this

864
00:52:53,119 --> 00:52:54,800
exception code that discriminates on

865
00:52:54,800 --> 00:52:57,119
what kind of exception has happened

866
00:52:57,119 --> 00:52:58,079
and then

867
00:52:58,079 --> 00:53:00,000
if it was a page fault if there was some

868
00:53:00,000 --> 00:53:03,040
invalid memory access as we saw uh the

869
00:53:03,040 --> 00:53:05,440
colonel will decide to kill that program

870
00:53:05,440 --> 00:53:07,200
in most cases and well

871
00:53:07,200 --> 00:53:08,720
in this case it'll decide to kill the

872
00:53:08,720 --> 00:53:10,640
program it's not always that way but uh

873
00:53:10,640 --> 00:53:12,640
we'll get there

874
00:53:12,640 --> 00:53:13,599
okay

875
00:53:13,599 --> 00:53:14,480
so

876
00:53:14,480 --> 00:53:16,079
we'll come back to that now if we think

877
00:53:16,079 --> 00:53:17,920
about fork

878
00:53:17,920 --> 00:53:20,160
by the way is a bad idea i do not

879
00:53:20,160 --> 00:53:22,960
endorse it but it's useful for this talk

880
00:53:22,960 --> 00:53:24,240
so

881
00:53:24,240 --> 00:53:26,160
if a parent program forks it's gonna

882
00:53:26,160 --> 00:53:28,640
create a copy of itself a duplicated

883
00:53:28,640 --> 00:53:30,000
program the only difference is going to

884
00:53:30,000 --> 00:53:31,520
be the process id is different and the

885
00:53:31,520 --> 00:53:33,359
return value of the for call itself will

886
00:53:33,359 --> 00:53:34,640
be different

887
00:53:34,640 --> 00:53:36,160
and we can visualize what this would be

888
00:53:36,160 --> 00:53:37,599
kind of in the memory

889
00:53:37,599 --> 00:53:39,599
so we've got a program running somewhere

890
00:53:39,599 --> 00:53:41,040
it's got some mappings it's got the null

891
00:53:41,040 --> 00:53:43,280
page code data heap and stack

892
00:53:43,280 --> 00:53:45,119
then it forks the operating system

893
00:53:45,119 --> 00:53:47,040
creates a copy

894
00:53:47,040 --> 00:53:49,040
and all of this memory

895
00:53:49,040 --> 00:53:51,040
all of this memory gets duplicated into

896
00:53:51,040 --> 00:53:52,960
the child

897
00:53:52,960 --> 00:53:54,319
and this is kind of wasteful you know we

898
00:53:54,319 --> 00:53:56,079
don't we don't really need to duplicate

899
00:53:56,079 --> 00:53:58,000
all of this memory uh because some of it

900
00:53:58,000 --> 00:53:59,839
is never going to change for example the

901
00:53:59,839 --> 00:54:01,680
code segment the code is immutable

902
00:54:01,680 --> 00:54:03,599
there's no reason to copy it

903
00:54:03,599 --> 00:54:06,240
so we can just map it once and then hand

904
00:54:06,240 --> 00:54:08,240
out the same frame to both programs

905
00:54:08,240 --> 00:54:09,760
again a very natural trick to do with

906
00:54:09,760 --> 00:54:10,800
paging

907
00:54:10,800 --> 00:54:11,760
um

908
00:54:11,760 --> 00:54:13,440
some stuff however is going to change

909
00:54:13,440 --> 00:54:15,200
like the heap you know the parent and

910
00:54:15,200 --> 00:54:16,800
child are going to allocate differently

911
00:54:16,800 --> 00:54:18,000
those pages are definitely going to

912
00:54:18,000 --> 00:54:19,359
change

913
00:54:19,359 --> 00:54:20,319
um

914
00:54:20,319 --> 00:54:22,160
but maybe not all of it will change so

915
00:54:22,160 --> 00:54:23,359
if we think about the heap it's split up

916
00:54:23,359 --> 00:54:26,720
into pages just like all other memory

917
00:54:26,720 --> 00:54:29,119
and uh one trick we can do to try and

918
00:54:29,119 --> 00:54:30,640
share this memory

919
00:54:30,640 --> 00:54:32,640
is uh

920
00:54:32,640 --> 00:54:35,599
right so my apologies

921
00:54:35,599 --> 00:54:37,520
maybe the child will change some pages

922
00:54:37,520 --> 00:54:38,640
over there

923
00:54:38,640 --> 00:54:39,440
um

924
00:54:39,440 --> 00:54:41,359
maybe the parent will change some pages

925
00:54:41,359 --> 00:54:43,359
the point is we don't know what's going

926
00:54:43,359 --> 00:54:44,960
to be changed in advance so we need some

927
00:54:44,960 --> 00:54:47,040
kind of strategy that's going to allow

928
00:54:47,040 --> 00:54:48,640
us to react

929
00:54:48,640 --> 00:54:50,160
so prior to the fork we've got a bunch

930
00:54:50,160 --> 00:54:51,280
of pages in the heap they're all

931
00:54:51,280 --> 00:54:53,359
writable and then one trick that we can

932
00:54:53,359 --> 00:54:54,400
do

933
00:54:54,400 --> 00:54:56,799
is when the fork is executed we can

934
00:54:56,799 --> 00:54:58,799
downgrade all of those pages to readable

935
00:54:58,799 --> 00:54:59,920
only

936
00:54:59,920 --> 00:55:01,599
okay how does that help us well when

937
00:55:01,599 --> 00:55:03,359
someone tries to access or write to one

938
00:55:03,359 --> 00:55:04,720
of those pages

939
00:55:04,720 --> 00:55:06,640
we'll go into our exception handler it's

940
00:55:06,640 --> 00:55:08,160
a page vault when we looked at this a

941
00:55:08,160 --> 00:55:09,839
moment ago we crossed the program but

942
00:55:09,839 --> 00:55:11,920
actually we can use this for features so

943
00:55:11,920 --> 00:55:14,079
we can say aha we're in this special

944
00:55:14,079 --> 00:55:15,520
fork scenario

945
00:55:15,520 --> 00:55:17,520
and we can create a copy of that page

946
00:55:17,520 --> 00:55:19,520
that's writable

947
00:55:19,520 --> 00:55:20,799
and now we're you know we're only

948
00:55:20,799 --> 00:55:22,880
copying what we need to copy so memory

949
00:55:22,880 --> 00:55:24,880
is shared until proven otherwise and

950
00:55:24,880 --> 00:55:28,000
this idea is called copy on write or cow

951
00:55:28,000 --> 00:55:29,680
so dirty cow is a

952
00:55:29,680 --> 00:55:31,599
implementation flaw in linux's

953
00:55:31,599 --> 00:55:33,440
implementation of cal

954
00:55:33,440 --> 00:55:35,200
and what's really cool about it one of

955
00:55:35,200 --> 00:55:36,400
the things that's cool about it is that

956
00:55:36,400 --> 00:55:38,559
it was around for a long time

957
00:55:38,559 --> 00:55:39,920
and it's not like it was undetected like

958
00:55:39,920 --> 00:55:41,680
people knew about this but i don't know

959
00:55:41,680 --> 00:55:42,559
maybe they didn't think it was

960
00:55:42,559 --> 00:55:44,720
exploitable not really sure

961
00:55:44,720 --> 00:55:46,480
and it's a it's a pretty game-breaking

962
00:55:46,480 --> 00:55:48,799
bug it allows you to

963
00:55:48,799 --> 00:55:50,319
over to write to mappings that should

964
00:55:50,319 --> 00:55:52,079
only be readable and you could do things

965
00:55:52,079 --> 00:55:52,799
like

966
00:55:52,799 --> 00:55:55,520
you know insert code into a set uiv root

967
00:55:55,520 --> 00:55:57,280
binary so

968
00:55:57,280 --> 00:55:58,400
it's not a good

969
00:55:58,400 --> 00:56:00,960
not a good flaw but it's fixed now

970
00:56:00,960 --> 00:56:02,640
moving on to our third security defense

971
00:56:02,640 --> 00:56:04,799
the no execute bit

972
00:56:04,799 --> 00:56:07,040
so if we think about the

973
00:56:07,040 --> 00:56:09,119
memory mappings of a program again we're

974
00:56:09,119 --> 00:56:10,799
going to have you know code some static

975
00:56:10,799 --> 00:56:12,799
data heap and stack there's an old page

976
00:56:12,799 --> 00:56:14,319
as well that i didn't bother visualizing

977
00:56:14,319 --> 00:56:15,119
here

978
00:56:15,119 --> 00:56:17,359
and this stack is going to be composed

979
00:56:17,359 --> 00:56:19,920
of stack frames those stack frames as

980
00:56:19,920 --> 00:56:21,680
you know i'm sure we're familiar contain

981
00:56:21,680 --> 00:56:24,000
base pointers return addresses and in a

982
00:56:24,000 --> 00:56:25,839
well-formed set of stack frames these

983
00:56:25,839 --> 00:56:27,119
base pointers are just going to kind of

984
00:56:27,119 --> 00:56:28,799
point up the chain back to the previous

985
00:56:28,799 --> 00:56:30,720
one this is what we expect this is

986
00:56:30,720 --> 00:56:33,280
normal um and the code is going to be

987
00:56:33,280 --> 00:56:34,720
jumping around you know backwards and

988
00:56:34,720 --> 00:56:36,559
forwards within the immutable code

989
00:56:36,559 --> 00:56:39,520
segment uh of the program again the

990
00:56:39,520 --> 00:56:40,960
arrows look a little bit crazy but this

991
00:56:40,960 --> 00:56:42,720
is the happy path this is what we kind

992
00:56:42,720 --> 00:56:45,359
of want and expect um

993
00:56:45,359 --> 00:56:47,119
but if we blow up one of those stack

994
00:56:47,119 --> 00:56:48,400
frames you know it's got the local

995
00:56:48,400 --> 00:56:50,000
variables allocated on the stack it's

996
00:56:50,000 --> 00:56:52,559
got the base pointer uh of the the next

997
00:56:52,559 --> 00:56:53,920
stack frame it's got the return address

998
00:56:53,920 --> 00:56:56,319
and the code and classic buffer overflow

999
00:56:56,319 --> 00:56:58,319
attack you can overwrite the base

1000
00:56:58,319 --> 00:57:00,319
pointer and the return address and what

1001
00:57:00,319 --> 00:57:02,319
that'll allow you to do is jump out of

1002
00:57:02,319 --> 00:57:04,880
that code segment and into the heap and

1003
00:57:04,880 --> 00:57:07,040
uh run some shell code that you've uh

1004
00:57:07,040 --> 00:57:08,400
that you've you know allocated and

1005
00:57:08,400 --> 00:57:09,520
populated

1006
00:57:09,520 --> 00:57:13,200
classic buffer overflow attack um and so

1007
00:57:13,200 --> 00:57:14,960
can paging help us with this well indeed

1008
00:57:14,960 --> 00:57:16,799
it can the heap and stack are composed

1009
00:57:16,799 --> 00:57:19,760
of pages and uh we can add a new field

1010
00:57:19,760 --> 00:57:21,440
in our page mapping level one entry that

1011
00:57:21,440 --> 00:57:23,040
describes the four kilobyte page or

1012
00:57:23,040 --> 00:57:24,000
frame

1013
00:57:24,000 --> 00:57:25,200
that says

1014
00:57:25,200 --> 00:57:27,359
is this are we allowed to execute code

1015
00:57:27,359 --> 00:57:28,640
within this page it's called the no

1016
00:57:28,640 --> 00:57:31,040
execute bit so what we can do is set

1017
00:57:31,040 --> 00:57:33,359
this no execute bit on all of the pages

1018
00:57:33,359 --> 00:57:35,280
in the heap and stack uh which will

1019
00:57:35,280 --> 00:57:37,359
prevent anyone from you know dynamically

1020
00:57:37,359 --> 00:57:40,319
setting up shell code and uh running it

1021
00:57:40,319 --> 00:57:41,760
we can only run the code that's allowed

1022
00:57:41,760 --> 00:57:43,119
to run that doesn't have this no execute

1023
00:57:43,119 --> 00:57:45,119
bit set this does create a little bit of

1024
00:57:45,119 --> 00:57:46,880
difficulty for things like jit engines

1025
00:57:46,880 --> 00:57:48,960
which do need to dynamically write code

1026
00:57:48,960 --> 00:57:51,280
and there are you know oss have policies

1027
00:57:51,280 --> 00:57:53,680
to help with that

1028
00:57:53,680 --> 00:57:55,280
so this is an architecture dependent

1029
00:57:55,280 --> 00:57:56,960
feature but it's available in the major

1030
00:57:56,960 --> 00:57:58,640
ones

1031
00:57:58,640 --> 00:58:01,520
all right third attack tlb info leak

1032
00:58:01,520 --> 00:58:02,559
um

1033
00:58:02,559 --> 00:58:04,319
cool so we're going to do a little bit

1034
00:58:04,319 --> 00:58:06,319
of background on page swapping and cache

1035
00:58:06,319 --> 00:58:07,760
latencies and then we'll take a look at

1036
00:58:07,760 --> 00:58:09,839
the attack itself

1037
00:58:09,839 --> 00:58:11,760
so

1038
00:58:11,760 --> 00:58:13,440
one thing that you can do with paging is

1039
00:58:13,440 --> 00:58:15,200
imagine we're under high memory pressure

1040
00:58:15,200 --> 00:58:17,440
all of our pages are allocated

1041
00:58:17,440 --> 00:58:18,480
we're getting to the point where we

1042
00:58:18,480 --> 00:58:19,760
can't really do any work because we

1043
00:58:19,760 --> 00:58:22,559
don't have any free memory to use so one

1044
00:58:22,559 --> 00:58:24,160
trick that you can do

1045
00:58:24,160 --> 00:58:26,079
is take an allocated page maybe one that

1046
00:58:26,079 --> 00:58:29,040
hasn't been accessed in a while and

1047
00:58:29,040 --> 00:58:30,640
write it to disk just write all of its

1048
00:58:30,640 --> 00:58:33,040
contents to disk mark the page as free

1049
00:58:33,040 --> 00:58:35,119
you can reuse it for something else then

1050
00:58:35,119 --> 00:58:37,680
when someone tries to access that page

1051
00:58:37,680 --> 00:58:39,359
you'll go back into your trap your

1052
00:58:39,359 --> 00:58:41,040
exception handler you'll be able to see

1053
00:58:41,040 --> 00:58:43,200
aha this is a page that i've you know

1054
00:58:43,200 --> 00:58:45,040
shoved away onto the disk to make room

1055
00:58:45,040 --> 00:58:46,799
for more memory and you can load it back

1056
00:58:46,799 --> 00:58:48,720
into resident memory

1057
00:58:48,720 --> 00:58:50,480
and this is an idea called page swapping

1058
00:58:50,480 --> 00:58:52,400
again you know classic technique that's

1059
00:58:52,400 --> 00:58:54,640
been around for a long time

1060
00:58:54,640 --> 00:58:57,200
and this leads to a really cool idea uh

1061
00:58:57,200 --> 00:58:59,599
so the idea here is that you don't

1062
00:58:59,599 --> 00:59:02,000
really need to care about ram as much of

1063
00:59:02,000 --> 00:59:03,440
course that's not totally the case we

1064
00:59:03,440 --> 00:59:05,520
still care about ram but it kind of just

1065
00:59:05,520 --> 00:59:08,480
becomes one more step in a layer of

1066
00:59:08,480 --> 00:59:10,079
caches so you have the really fast

1067
00:59:10,079 --> 00:59:12,720
caches uh you know on chip in the cpu

1068
00:59:12,720 --> 00:59:14,559
then you have ram which is a lot slower

1069
00:59:14,559 --> 00:59:16,400
but also quite a bit larger and then you

1070
00:59:16,400 --> 00:59:18,319
have the hard drive which again quite a

1071
00:59:18,319 --> 00:59:19,920
bit slower quite a lot larger and kind

1072
00:59:19,920 --> 00:59:22,079
of represents your true memory limit

1073
00:59:22,079 --> 00:59:23,839
because if you ever run out of ram you

1074
00:59:23,839 --> 00:59:25,440
can just swap to disk until you have

1075
00:59:25,440 --> 00:59:26,640
enough

1076
00:59:26,640 --> 00:59:29,520
um cool idea

1077
00:59:29,520 --> 00:59:31,440
okay so we look we looked at this

1078
00:59:31,440 --> 00:59:34,079
diagram the cpu tries to access a memory

1079
00:59:34,079 --> 00:59:36,079
address it gets routed to the mmu the

1080
00:59:36,079 --> 00:59:38,000
mmu will check the accesses consult the

1081
00:59:38,000 --> 00:59:40,720
paging tables and then go to real ram

1082
00:59:40,720 --> 00:59:42,480
the problem here though is that

1083
00:59:42,480 --> 00:59:44,559
accessing those paging tables

1084
00:59:44,559 --> 00:59:47,280
involves you know several accesses to

1085
00:59:47,280 --> 00:59:48,880
ram one for each of those tables at

1086
00:59:48,880 --> 00:59:51,520
least uh which is pretty expensive

1087
00:59:51,520 --> 00:59:54,240
so cpu designers introduced this really

1088
00:59:54,240 --> 00:59:56,240
really fast cache called the translation

1089
00:59:56,240 --> 00:59:58,319
look aside buffer the tlb

1090
00:59:58,319 --> 01:00:00,400
um so anytime the mmu performs a

1091
01:00:00,400 --> 01:00:01,839
translation and finds out where a

1092
01:00:01,839 --> 01:00:02,960
mapping is

1093
01:00:02,960 --> 01:00:04,880
it'll try to save it to this really fast

1094
01:00:04,880 --> 01:00:07,040
tlb and then if you kind of ask for that

1095
01:00:07,040 --> 01:00:08,880
same virtual address again it can

1096
01:00:08,880 --> 01:00:12,000
service it from the tlb

1097
01:00:12,000 --> 01:00:14,480
which sounds great and it is

1098
01:00:14,480 --> 01:00:16,319
but since there's this big timing

1099
01:00:16,319 --> 01:00:18,480
disparity between accessing an address

1100
01:00:18,480 --> 01:00:20,559
that's in the tlb versus accessing an

1101
01:00:20,559 --> 01:00:22,880
address that's not in the tlb uh this is

1102
01:00:22,880 --> 01:00:25,920
actually a side channel and uh

1103
01:00:25,920 --> 01:00:27,839
somehow i don't know i don't understand

1104
01:00:27,839 --> 01:00:29,599
it myself but somehow you can use this

1105
01:00:29,599 --> 01:00:31,920
to leak cryptographic keys uh which is

1106
01:00:31,920 --> 01:00:34,799
crazy um as far as i can tell they

1107
01:00:34,799 --> 01:00:36,319
discovered this one side channel

1108
01:00:36,319 --> 01:00:38,000
vulnerability and gave it two different

1109
01:00:38,000 --> 01:00:41,440
names so good on them i respect it

1110
01:00:41,440 --> 01:00:43,760
they named it tl bleed and translation

1111
01:00:43,760 --> 01:00:45,200
leak aside buffer they were being a bit

1112
01:00:45,200 --> 01:00:47,760
cheeky we'll let it slide

1113
01:00:47,760 --> 01:00:49,760
all right moving on to our next attack

1114
01:00:49,760 --> 01:00:51,119
row hammer

1115
01:00:51,119 --> 01:00:54,160
um right i've got a demo here oh cool so

1116
01:00:54,160 --> 01:00:56,079
this finished we can hit this upload

1117
01:00:56,079 --> 01:00:58,079
dump button and exfiltrate all of those

1118
01:00:58,079 --> 01:00:59,920
strings for you know

1119
01:00:59,920 --> 01:01:02,079
selling them or whatever

1120
01:01:02,079 --> 01:01:05,200
all right close those

1121
01:01:05,440 --> 01:01:08,160
cool let me full screen this

1122
01:01:08,160 --> 01:01:09,680
so one thing that i kind of mentioned in

1123
01:01:09,680 --> 01:01:11,200
passing but just want to really drive

1124
01:01:11,200 --> 01:01:12,880
home is that every

1125
01:01:12,880 --> 01:01:14,079
uh

1126
01:01:14,079 --> 01:01:16,559
process has its own virtual address

1127
01:01:16,559 --> 01:01:18,559
space so here you can see these are all

1128
01:01:18,559 --> 01:01:21,030
the processes loaded in the system um

1129
01:01:21,030 --> 01:01:22,319
[Music]

1130
01:01:22,319 --> 01:01:24,079
and each of them has its different set

1131
01:01:24,079 --> 01:01:27,839
of memory mappings so for example

1132
01:01:27,839 --> 01:01:29,520
open something interesting

1133
01:01:29,520 --> 01:01:31,359
um

1134
01:01:31,359 --> 01:01:34,240
so doom here it's got 544 kilobytes for

1135
01:01:34,240 --> 01:01:36,559
the code segment oh

1136
01:01:36,559 --> 01:01:38,480
okay well never mind

1137
01:01:38,480 --> 01:01:41,119
um the idea is that every process has

1138
01:01:41,119 --> 01:01:42,640
its own virtual address space with

1139
01:01:42,640 --> 01:01:44,240
different you know memory mappings

1140
01:01:44,240 --> 01:01:45,520
within them

1141
01:01:45,520 --> 01:01:47,760
all right

1142
01:01:47,760 --> 01:01:50,000
so if we think about dram

1143
01:01:50,000 --> 01:01:50,960
um

1144
01:01:50,960 --> 01:01:52,640
you know the the typical ram chips

1145
01:01:52,640 --> 01:01:54,480
you'll find in any computer it's a big

1146
01:01:54,480 --> 01:01:57,039
grid of capacitors uh and they're packed

1147
01:01:57,039 --> 01:01:58,960
in really closely and if you don't do

1148
01:01:58,960 --> 01:02:00,400
anything to these capacitors they'll

1149
01:02:00,400 --> 01:02:02,880
naturally discharge so all your ones

1150
01:02:02,880 --> 01:02:04,559
will their voltage levels will drop and

1151
01:02:04,559 --> 01:02:07,200
they'll instead be zeros so dram chips

1152
01:02:07,200 --> 01:02:09,039
have a feature where every 64

1153
01:02:09,039 --> 01:02:10,799
milliseconds they'll just kind of pump

1154
01:02:10,799 --> 01:02:13,520
up uh the charge levels

1155
01:02:13,520 --> 01:02:15,440
uh of all of these capacitors to keep

1156
01:02:15,440 --> 01:02:16,960
them in their you know whatever state

1157
01:02:16,960 --> 01:02:18,079
they should be in if they're zero they

1158
01:02:18,079 --> 01:02:19,440
should stay zero if they're one they

1159
01:02:19,440 --> 01:02:20,960
should stay once and not decay to a

1160
01:02:20,960 --> 01:02:22,480
different state

1161
01:02:22,480 --> 01:02:23,599
okay

1162
01:02:23,599 --> 01:02:25,599
one more thing is that anytime you read

1163
01:02:25,599 --> 01:02:28,319
from a row of dram because of the nature

1164
01:02:28,319 --> 01:02:30,319
of how these chip controllers work what

1165
01:02:30,319 --> 01:02:33,039
that does is it entirely discharges a

1166
01:02:33,039 --> 01:02:36,319
row reads the address

1167
01:02:36,319 --> 01:02:37,839
address you specified and then it

1168
01:02:37,839 --> 01:02:39,680
recharges the row

1169
01:02:39,680 --> 01:02:42,240
and what uh some researchers discovered

1170
01:02:42,240 --> 01:02:43,680
in 2014

1171
01:02:43,680 --> 01:02:45,839
is that if you

1172
01:02:45,839 --> 01:02:47,599
read an address just thousands and

1173
01:02:47,599 --> 01:02:50,400
thousands of times before that 64

1174
01:02:50,400 --> 01:02:52,319
millisecond refresh interval has a

1175
01:02:52,319 --> 01:02:53,839
chance to kick in

1176
01:02:53,839 --> 01:02:55,760
this act of charging and discharging

1177
01:02:55,760 --> 01:02:58,240
over and over again a row can actually

1178
01:02:58,240 --> 01:03:00,160
discharge one of those capacitors in an

1179
01:03:00,160 --> 01:03:02,720
adjacent row which is terrifying and

1180
01:03:02,720 --> 01:03:05,359
we'll take a look at why

1181
01:03:05,359 --> 01:03:07,039
so one of the one of the really crazy

1182
01:03:07,039 --> 01:03:08,960
things about this is that these two rows

1183
01:03:08,960 --> 01:03:10,960
can represent the virtual address spaces

1184
01:03:10,960 --> 01:03:13,039
of different processes so i'm doing a

1185
01:03:13,039 --> 01:03:15,280
bunch of reads thousands of reads in one

1186
01:03:15,280 --> 01:03:18,160
process and that's causing a write in a

1187
01:03:18,160 --> 01:03:21,920
different processes memory it's crazy

1188
01:03:21,920 --> 01:03:23,359
so row hammer violates some really

1189
01:03:23,359 --> 01:03:25,119
serious invariants that we expect from

1190
01:03:25,119 --> 01:03:26,960
memory so we have

1191
01:03:26,960 --> 01:03:28,400
the paging invariant that accessing

1192
01:03:28,400 --> 01:03:29,920
memory in one address space you know

1193
01:03:29,920 --> 01:03:31,599
cannot does not

1194
01:03:31,599 --> 01:03:33,520
access memory in another address space

1195
01:03:33,520 --> 01:03:34,960
and also some invariants that we really

1196
01:03:34,960 --> 01:03:36,960
take for granted in ram namely that

1197
01:03:36,960 --> 01:03:38,960
accessing an address only accesses that

1198
01:03:38,960 --> 01:03:41,359
address and that reads don't do rights

1199
01:03:41,359 --> 01:03:43,599
all of this gets blown away by row

1200
01:03:43,599 --> 01:03:45,599
really serious and kind of devastating

1201
01:03:45,599 --> 01:03:46,880
attack

1202
01:03:46,880 --> 01:03:48,720
this was caused by the way because drm

1203
01:03:48,720 --> 01:03:50,640
manufacturers wanted to get higher

1204
01:03:50,640 --> 01:03:52,640
memory densities on their chips

1205
01:03:52,640 --> 01:03:54,000
so they just kept packing in the

1206
01:03:54,000 --> 01:03:55,839
capacitors closer and closer together

1207
01:03:55,839 --> 01:03:56,960
and then you get these kind of circuit

1208
01:03:56,960 --> 01:03:58,720
level problems that arise

1209
01:03:58,720 --> 01:04:00,640
um so it's yeah kind of a leaky

1210
01:04:00,640 --> 01:04:02,880
abstraction i suppose

1211
01:04:02,880 --> 01:04:04,880
all right one really cool attack you can

1212
01:04:04,880 --> 01:04:08,160
do with uh with row hammer is if one of

1213
01:04:08,160 --> 01:04:10,799
those bits is in a page mapping level

1214
01:04:10,799 --> 01:04:11,920
one entry one of the bits that gets

1215
01:04:11,920 --> 01:04:13,760
flipped you can carry out that physical

1216
01:04:13,760 --> 01:04:15,359
memory attack that we took a look at

1217
01:04:15,359 --> 01:04:18,240
earlier you can you can do a total uh

1218
01:04:18,240 --> 01:04:20,640
physical memory takeover via these bit

1219
01:04:20,640 --> 01:04:22,640
flips in in the right paging structures

1220
01:04:22,640 --> 01:04:24,079
google project zero demonstrated this

1221
01:04:24,079 --> 01:04:27,599
attack in 2015. it's really cool

1222
01:04:27,599 --> 01:04:28,480
all right

1223
01:04:28,480 --> 01:04:30,720
so row hammer demo

1224
01:04:30,720 --> 01:04:32,640
i carried out this demo on a

1225
01:04:32,640 --> 01:04:34,400
ubuntu machine

1226
01:04:34,400 --> 01:04:36,079
but it's at my home in the uk so i

1227
01:04:36,079 --> 01:04:38,000
didn't bring it i took a video

1228
01:04:38,000 --> 01:04:41,000
um

1229
01:04:41,920 --> 01:04:44,720
let's close that

1230
01:04:50,319 --> 01:04:52,559
okay so don't take this too seriously i

1231
01:04:52,559 --> 01:04:54,160
had to give the system a lot of help to

1232
01:04:54,160 --> 01:04:55,760
get it something i could you know really

1233
01:04:55,760 --> 01:04:58,880
demo i did really scary things like um

1234
01:04:58,880 --> 01:05:00,960
i increased the memory refresh interval

1235
01:05:00,960 --> 01:05:02,640
from 64 milliseconds to something

1236
01:05:02,640 --> 01:05:04,640
ridiculous to give me tons of time to

1237
01:05:04,640 --> 01:05:06,480
execute these bit flips and and change

1238
01:05:06,480 --> 01:05:08,640
bits i also gave myself root privileges

1239
01:05:08,640 --> 01:05:09,280
and

1240
01:05:09,280 --> 01:05:11,200
just generally kind of mess with things

1241
01:05:11,200 --> 01:05:12,640
so

1242
01:05:12,640 --> 01:05:14,480
the idea here is real but but don't take

1243
01:05:14,480 --> 01:05:16,880
it too seriously so we've got a let me

1244
01:05:16,880 --> 01:05:18,160
start this

1245
01:05:18,160 --> 01:05:20,240
we've got a program here uh the code is

1246
01:05:20,240 --> 01:05:22,079
up on the screen but basically what it

1247
01:05:22,079 --> 01:05:24,079
does is it just presents a black canvas

1248
01:05:24,079 --> 01:05:26,079
and refreshes the canvas it doesn't do

1249
01:05:26,079 --> 01:05:28,160
anything else so uh let me pause that

1250
01:05:28,160 --> 01:05:30,559
yep so it'll start we've got our black

1251
01:05:30,559 --> 01:05:32,559
screen and then on the right i've done a

1252
01:05:32,559 --> 01:05:34,240
prior analysis of all the physical

1253
01:05:34,240 --> 01:05:35,760
memory in the system

1254
01:05:35,760 --> 01:05:38,559
to find out what addresses what physical

1255
01:05:38,559 --> 01:05:40,559
addresses are the most vulnerable to bit

1256
01:05:40,559 --> 01:05:42,559
flips and then i start hammering those

1257
01:05:42,559 --> 01:05:44,640
addresses and if we're lucky some of

1258
01:05:44,640 --> 01:05:46,240
those addresses compose this frame

1259
01:05:46,240 --> 01:05:48,079
buffer over on the right

1260
01:05:48,079 --> 01:05:50,400
so the idea here is that by just doing

1261
01:05:50,400 --> 01:05:52,240
tons and tons of reads

1262
01:05:52,240 --> 01:05:55,119
uh in one process we can cause bit flips

1263
01:05:55,119 --> 01:05:58,319
in this canvas over on the left um

1264
01:05:58,319 --> 01:05:59,760
and indeed we i don't know if you can

1265
01:05:59,760 --> 01:06:01,039
really see those

1266
01:06:01,039 --> 01:06:02,880
can anyone see like little white dots on

1267
01:06:02,880 --> 01:06:04,559
the black part

1268
01:06:04,559 --> 01:06:08,160
no okay they're there it's okay um

1269
01:06:08,160 --> 01:06:09,760
okay nice

1270
01:06:09,760 --> 01:06:11,280
one thing that's also really neat about

1271
01:06:11,280 --> 01:06:12,799
this is uh

1272
01:06:12,799 --> 01:06:14,480
you can get a bit flip you know anywhere

1273
01:06:14,480 --> 01:06:16,000
so depending on what bit is flipped it

1274
01:06:16,000 --> 01:06:17,520
might not be a white pixel it might be

1275
01:06:17,520 --> 01:06:20,160
like a bit yellow or a bit red which is

1276
01:06:20,160 --> 01:06:22,240
i think it's fun

1277
01:06:22,240 --> 01:06:24,479
um

1278
01:06:24,960 --> 01:06:26,480
right there's another 10 seconds in this

1279
01:06:26,480 --> 01:06:28,319
video i guess i'll let it play

1280
01:06:28,319 --> 01:06:32,759
i spent a lot of time on it so

1281
01:06:32,960 --> 01:06:35,280
okay

1282
01:06:35,760 --> 01:06:37,599
so in review we've talked about paging

1283
01:06:37,599 --> 01:06:39,039
we've talked about you know what it is

1284
01:06:39,039 --> 01:06:40,960
kind of how it works what the operating

1285
01:06:40,960 --> 01:06:43,119
system needs to do to facilitate it as

1286
01:06:43,119 --> 01:06:44,559
well as what's kind of happening under

1287
01:06:44,559 --> 01:06:47,039
the hood in the mmu in the cpu whenever

1288
01:06:47,039 --> 01:06:48,720
you access some memory

1289
01:06:48,720 --> 01:06:50,160
we've talked about some defenses that

1290
01:06:50,160 --> 01:06:51,839
are built on top of paging pointer

1291
01:06:51,839 --> 01:06:53,440
authentication address-based layout

1292
01:06:53,440 --> 01:06:55,520
randomization the no execute bit as well

1293
01:06:55,520 --> 01:06:57,359
as the kind of fundamental concept of

1294
01:06:57,359 --> 01:06:59,359
process isolation

1295
01:06:59,359 --> 01:07:01,359
and we also looked at some attacks that

1296
01:07:01,359 --> 01:07:02,640
you can carry out you can do a full

1297
01:07:02,640 --> 01:07:04,480
system takeover with the page mapping

1298
01:07:04,480 --> 01:07:06,160
level one entry if you manage to gain

1299
01:07:06,160 --> 01:07:09,119
access to one we saw how the cow feature

1300
01:07:09,119 --> 01:07:10,880
with a flaw turned into the dirty cow

1301
01:07:10,880 --> 01:07:13,520
attack as well as how page swapping was

1302
01:07:13,520 --> 01:07:15,839
a useful bit of background for seeing

1303
01:07:15,839 --> 01:07:18,559
those cache latencies and tlp info leaks

1304
01:07:18,559 --> 01:07:21,440
and finally we took a look at row hammer

1305
01:07:21,440 --> 01:07:24,079
all right that's all i've got

1306
01:07:24,079 --> 01:07:27,319
any questions

1307
01:07:27,910 --> 01:07:34,319
[Applause]

1308
01:07:34,319 --> 01:07:36,720
i was wondering

1309
01:07:36,720 --> 01:07:41,240
do you know much about uh

1310
01:07:44,160 --> 01:07:45,680
yeah great question so just in case

1311
01:07:45,680 --> 01:07:47,760
anyone anyone did not hear that the

1312
01:07:47,760 --> 01:07:51,359
question was uh does ecc mitigate row

1313
01:07:51,359 --> 01:07:53,599
hammer so ecc if you're not aware stands

1314
01:07:53,599 --> 01:07:55,920
for error correcting codes and the idea

1315
01:07:55,920 --> 01:07:57,839
here is that rather than just having a

1316
01:07:57,839 --> 01:08:00,400
bunch of ram that you can store data in

1317
01:08:00,400 --> 01:08:02,240
uh you reserve a little bit of your ram

1318
01:08:02,240 --> 01:08:04,799
for parity bits um the idea being that

1319
01:08:04,799 --> 01:08:06,240
you can kind of observe like is the

1320
01:08:06,240 --> 01:08:08,240
parity incorrect and if so you know

1321
01:08:08,240 --> 01:08:10,480
you've got a bit flip somewhere

1322
01:08:10,480 --> 01:08:12,160
and the answer is yes so people have

1323
01:08:12,160 --> 01:08:14,720
described kind of software mitigations

1324
01:08:14,720 --> 01:08:16,640
for row hammer ways that you can detect

1325
01:08:16,640 --> 01:08:20,238
in software if bit flips are happening

1326
01:08:20,238 --> 01:08:22,560
all of them are kind of fairy dust the

1327
01:08:22,560 --> 01:08:24,960
only real defense is a physical defense

1328
01:08:24,960 --> 01:08:28,640
like ecc yeah great question

1329
01:08:28,640 --> 01:08:29,759
anyone else

1330
01:08:29,759 --> 01:08:32,759
yeah

1331
01:08:35,759 --> 01:08:36,880
what's that

1332
01:08:36,880 --> 01:08:39,839
yeah yeah sure so the question just in

1333
01:08:39,839 --> 01:08:42,319
case uh was uh i did some prior analysis

1334
01:08:42,319 --> 01:08:43,759
to find out which bits of physical

1335
01:08:43,759 --> 01:08:45,520
memory were vulnerable in my row hammer

1336
01:08:45,520 --> 01:08:47,759
attack uh and what was that how did i do

1337
01:08:47,759 --> 01:08:51,439
that so i used memtest so the nice thing

1338
01:08:51,439 --> 01:08:53,839
so if anyone doesn't know

1339
01:08:53,839 --> 01:08:55,198
basically the way you want to do this

1340
01:08:55,198 --> 01:08:57,600
let me just give myself time check

1341
01:08:57,600 --> 01:08:59,839
yeah we're all right uh the way you want

1342
01:08:59,839 --> 01:09:02,080
to do this to check if some memory is

1343
01:09:02,080 --> 01:09:03,920
vulnerable to bit flips is you just want

1344
01:09:03,920 --> 01:09:05,920
to try attacking it you just want to try

1345
01:09:05,920 --> 01:09:07,759
you know spamming some adjacent memory

1346
01:09:07,759 --> 01:09:10,000
with reads and seeing if you get any any

1347
01:09:10,000 --> 01:09:12,479
writes any bit flips

1348
01:09:12,479 --> 01:09:14,319
so one kind of complication that you

1349
01:09:14,319 --> 01:09:16,080
would do if you try to do this just in a

1350
01:09:16,080 --> 01:09:17,839
normal operating system

1351
01:09:17,839 --> 01:09:20,960
is that the operating system controls

1352
01:09:20,960 --> 01:09:22,960
the physical memory allocation you as a

1353
01:09:22,960 --> 01:09:24,479
user of the operating system you don't

1354
01:09:24,479 --> 01:09:25,920
get to have a say

1355
01:09:25,920 --> 01:09:27,600
on uh you know i want to test that piece

1356
01:09:27,600 --> 01:09:28,880
of physical memory i want to test that

1357
01:09:28,880 --> 01:09:30,399
piece of physical memory some bits of

1358
01:09:30,399 --> 01:09:31,839
physical memory are going to be totally

1359
01:09:31,839 --> 01:09:33,359
inaccessible to you because it's you

1360
01:09:33,359 --> 01:09:34,640
know it's used for the operating

1361
01:09:34,640 --> 01:09:37,920
system's code or data um so you can't

1362
01:09:37,920 --> 01:09:39,839
really use an operating system

1363
01:09:39,839 --> 01:09:41,198
so people have developed this

1364
01:09:41,198 --> 01:09:44,000
application called memtest which is uh

1365
01:09:44,000 --> 01:09:45,600
rather than operating within an

1366
01:09:45,600 --> 01:09:47,600
operating system it's its own i guess

1367
01:09:47,600 --> 01:09:48,960
you could call it an operating system

1368
01:09:48,960 --> 01:09:51,040
it's a uefi application so it's

1369
01:09:51,040 --> 01:09:54,480
unconstrained by the normal uh kind of

1370
01:09:54,480 --> 01:09:56,640
you know guardrails of an os

1371
01:09:56,640 --> 01:09:57,920
and uh it's

1372
01:09:57,920 --> 01:10:00,080
pretty cool so memtest allows you to

1373
01:10:00,080 --> 01:10:01,360
test all the physical memory because you

1374
01:10:01,360 --> 01:10:02,719
have full control over the physical

1375
01:10:02,719 --> 01:10:04,560
address space um

1376
01:10:04,560 --> 01:10:06,159
but then of course some memory is going

1377
01:10:06,159 --> 01:10:08,880
to be taken up by mem test itself so at

1378
01:10:08,880 --> 01:10:11,040
runtime it it copies itself to different

1379
01:10:11,040 --> 01:10:14,239
locations of ram it relocates itself

1380
01:10:14,239 --> 01:10:15,840
so that it can you know exhaustively

1381
01:10:15,840 --> 01:10:17,040
test all the memory i thought that's

1382
01:10:17,040 --> 01:10:19,520
pretty cool yeah so i ran memtest for a

1383
01:10:19,520 --> 01:10:21,760
long time on this modified box where i

1384
01:10:21,760 --> 01:10:24,159
had uh upped the memory refresh rates to

1385
01:10:24,159 --> 01:10:27,120
really um inadvisable levels

1386
01:10:27,120 --> 01:10:30,159
uh and then memtest spat out a big list

1387
01:10:30,159 --> 01:10:31,760
of all the bit flips i sorted those by

1388
01:10:31,760 --> 01:10:33,280
frequency to get like the preferable

1389
01:10:33,280 --> 01:10:34,320
addresses

1390
01:10:34,320 --> 01:10:35,600
um

1391
01:10:35,600 --> 01:10:38,560
yeah does that make sense

1392
01:10:39,520 --> 01:10:43,400
all right any other questions

1393
01:10:44,480 --> 01:10:45,840
okay well if you think of anything else

1394
01:10:45,840 --> 01:10:47,679
just you know feel free to come up uh

1395
01:10:47,679 --> 01:10:49,670
thanks for your time and attention

1396
01:10:49,670 --> 01:10:58,239
[Applause]

1397
01:10:58,239 --> 01:11:00,239
all right thank you sure thank you

1398
01:11:00,239 --> 01:11:02,480
phillip that was great

1399
01:11:02,480 --> 01:11:04,799
um

1400
01:11:05,040 --> 01:11:07,679
so uh

1401
01:11:07,679 --> 01:11:09,520
i need to tap dance up here for a few

1402
01:11:09,520 --> 01:11:11,040
minutes because our next speakers aren't

1403
01:11:11,040 --> 01:11:13,440
here yet

1404
01:11:13,440 --> 01:11:15,360
yeah um

1405
01:11:15,360 --> 01:11:17,840
i i'm sure that uh they they said their

1406
01:11:17,840 --> 01:11:20,159
eta is uh

1407
01:11:20,159 --> 01:11:21,920
four minutes

1408
01:11:21,920 --> 01:11:22,880
um

1409
01:11:22,880 --> 01:11:25,199
which would be cool if it was true

1410
01:11:25,199 --> 01:11:28,159
um i bet they're here i bet they're here

1411
01:11:28,159 --> 01:11:31,280
by 11 30 which is when their slot begins

1412
01:11:31,280 --> 01:11:33,599
um

1413
01:11:34,640 --> 01:11:35,920
you know the

1414
01:11:35,920 --> 01:11:38,239
we we can we can we can spend the next

1415
01:11:38,239 --> 01:11:40,400
uh 14 minutes just staring at each other

1416
01:11:40,400 --> 01:11:42,080
if you like i could we could just do

1417
01:11:42,080 --> 01:11:43,440
that

1418
01:11:43,440 --> 01:11:46,239
the bar is open though so um what i'm

1419
01:11:46,239 --> 01:11:48,400
going to suggest is maybe

1420
01:11:48,400 --> 01:11:50,800
everyone take a uh

1421
01:11:50,800 --> 01:11:52,320
a 10 minute

1422
01:11:52,320 --> 01:11:53,520
break

1423
01:11:53,520 --> 01:11:55,760
to you know properly

1424
01:11:55,760 --> 01:11:57,199
prepare

1425
01:11:57,199 --> 01:11:58,560
for

1426
01:11:58,560 --> 01:12:00,800
kelly and ryan's presentation

1427
01:12:00,800 --> 01:12:02,880
uh maybe check your pockets for anything

1428
01:12:02,880 --> 01:12:04,560
that you may have found in them last

1429
01:12:04,560 --> 01:12:05,600
night

1430
01:12:05,600 --> 01:12:06,840
hey

1431
01:12:06,840 --> 01:12:10,320
tom um and uh yeah and come back here in

1432
01:12:10,320 --> 01:12:12,880
uh you know 12 minutes or so so thanks

1433
01:12:12,880 --> 01:12:14,750
guys

1434
01:12:14,750 --> 01:12:24,359
[Music]

1435
01:12:31,800 --> 01:13:51,319
[Music]

1436
01:13:53,400 --> 01:13:57,660
[Music]

1437
01:13:58,080 --> 01:14:00,770
this

1438
01:14:00,770 --> 01:14:10,689
[Music]

1439
01:14:19,520 --> 01:14:21,100
do

1440
01:14:21,100 --> 01:14:47,489
[Music]

1441
01:14:57,980 --> 01:15:29,679
[Music]

1442
01:15:29,679 --> 01:15:32,679
so

1443
01:15:35,140 --> 01:16:11,850
[Music]

1444
01:16:15,020 --> 01:16:25,600
[Music]

1445
01:16:25,600 --> 01:16:28,600
so

1446
01:16:30,370 --> 01:16:39,019
[Music]

1447
01:16:40,560 --> 01:16:42,730
so

1448
01:16:42,730 --> 01:16:45,860
[Music]

1449
01:16:53,990 --> 01:16:57,059
[Music]

1450
01:16:59,120 --> 01:17:04,480
[Music]

1451
01:17:04,480 --> 01:17:06,960
so

1452
01:17:06,960 --> 01:17:10,710
[Music]

1453
01:17:14,370 --> 01:17:21,050
[Music]

1454
01:17:26,880 --> 01:17:30,079
[Music]

1455
01:17:33,770 --> 01:17:48,779
[Music]

1456
01:17:52,920 --> 01:17:56,029
[Music]

1457
01:17:58,900 --> 01:18:14,858
[Music]

1458
01:18:32,580 --> 01:18:35,640
[Music]

1459
01:18:48,590 --> 01:18:51,640
[Music]

1460
01:20:08,590 --> 01:20:10,320
[Music]

1461
01:20:10,320 --> 01:20:11,920
so attack observability just involves

1462
01:20:11,920 --> 01:20:13,600
collecting data about the interactions

1463
01:20:13,600 --> 01:20:16,159
between attackers and systems and it's a

1464
01:20:16,159 --> 01:20:17,600
mistake to think that this just matters

1465
01:20:17,600 --> 01:20:19,360
to infosec people because attacker

1466
01:20:19,360 --> 01:20:21,199
effectiveness and systems resilience are

1467
01:20:21,199 --> 01:20:23,120
actually antithetical one inherently

1468
01:20:23,120 --> 01:20:25,360
erodes the other so understanding how

1469
01:20:25,360 --> 01:20:27,199
attackers make decisions allows you to

1470
01:20:27,199 --> 01:20:29,280
exploit attackers brains for this

1471
01:20:29,280 --> 01:20:31,600
improved resilience

1472
01:20:31,600 --> 01:20:33,520
but of course

1473
01:20:33,520 --> 01:20:35,280
you can think about attack observability

1474
01:20:35,280 --> 01:20:36,719
observability is not a new thing it's

1475
01:20:36,719 --> 01:20:38,320
very conceptually similar to the

1476
01:20:38,320 --> 01:20:40,320
importance of observability for all the

1477
01:20:40,320 --> 01:20:42,800
other stuff we care about in systems

1478
01:20:42,800 --> 01:20:43,760
um

1479
01:20:43,760 --> 01:20:45,040
because you

1480
01:20:45,040 --> 01:20:46,320
there's basically a mental model that

1481
01:20:46,320 --> 01:20:47,679
you have of reality so what you want to

1482
01:20:47,679 --> 01:20:49,920
do is basically look and trace how a

1483
01:20:49,920 --> 01:20:51,600
system actually behaves rather than how

1484
01:20:51,600 --> 01:20:53,600
you believe it behaves because you can

1485
01:20:53,600 --> 01:20:54,639
attempt to

1486
01:20:54,639 --> 01:20:56,480
like predict how you think of like

1487
01:20:56,480 --> 01:20:57,520
application or surface is going to

1488
01:20:57,520 --> 01:20:59,440
behave in production but it's actual

1489
01:20:59,440 --> 01:21:01,040
behavior is quite likely to deviate from

1490
01:21:01,040 --> 01:21:03,040
your expectations probably you a lot of

1491
01:21:03,040 --> 01:21:04,400
you have experienced this like what the

1492
01:21:04,400 --> 01:21:06,719
 is it doing now you never expected

1493
01:21:06,719 --> 01:21:08,800
it so similarly you can have beliefs

1494
01:21:08,800 --> 01:21:10,239
about attacker behavior and how they're

1495
01:21:10,239 --> 01:21:11,760
going to behave in your systems but

1496
01:21:11,760 --> 01:21:13,840
observing and tracing actual attacker

1497
01:21:13,840 --> 01:21:15,199
behavior will generate all of the

1498
01:21:15,199 --> 01:21:16,960
insight that's necessary for you to

1499
01:21:16,960 --> 01:21:18,639
improve design against this unwanted

1500
01:21:18,639 --> 01:21:20,639
activity

1501
01:21:20,639 --> 01:21:22,080
so of course understanding attacker

1502
01:21:22,080 --> 01:21:23,840
behavior starts with understanding how

1503
01:21:23,840 --> 01:21:25,120
humans generally learn and make

1504
01:21:25,120 --> 01:21:27,280
decisions so the answer is humans learn

1505
01:21:27,280 --> 01:21:29,199
both from immediate and repeated

1506
01:21:29,199 --> 01:21:30,800
interactions with the reality what you

1507
01:21:30,800 --> 01:21:33,600
mere mortals call experiences and while

1508
01:21:33,600 --> 01:21:35,120
uh when making decisions humans

1509
01:21:35,120 --> 01:21:36,639
basically supplement pre-existing

1510
01:21:36,639 --> 01:21:38,480
knowledge and beliefs with relevant

1511
01:21:38,480 --> 01:21:40,000
experience accumulated from prior

1512
01:21:40,000 --> 01:21:41,360
decisions and whatever their

1513
01:21:41,360 --> 01:21:43,440
consequences are that kind of like trial

1514
01:21:43,440 --> 01:21:45,199
and error sort of learning

1515
01:21:45,199 --> 01:21:46,880
so taken together you can think of human

1516
01:21:46,880 --> 01:21:48,719
learning and decision making as very

1517
01:21:48,719 --> 01:21:51,120
tightly coupled systems actually and so

1518
01:21:51,120 --> 01:21:52,719
given that attackers are human beings

1519
01:21:52,719 --> 01:21:54,239
and like there's a bunch of hullabaloo

1520
01:21:54,239 --> 01:21:56,239
about you know ai and automated tax

1521
01:21:56,239 --> 01:21:57,440
whatever like all of that is still

1522
01:21:57,440 --> 01:21:59,600
designed by humans right so this tight

1523
01:21:59,600 --> 01:22:01,360
coupling can actually be leveraged to

1524
01:22:01,360 --> 01:22:03,840
destabilize attacker cognition which is

1525
01:22:03,840 --> 01:22:06,159
great for us well assuming we're

1526
01:22:06,159 --> 01:22:07,760
defenders some of you may not like this

1527
01:22:07,760 --> 01:22:09,040
obviously but

1528
01:22:09,040 --> 01:22:11,280
we could draw on game theory here too so

1529
01:22:11,280 --> 01:22:12,960
in any interaction that's rife with

1530
01:22:12,960 --> 01:22:15,360
conflict uh like attackers for system

1531
01:22:15,360 --> 01:22:17,760
operators information asymmetry leads to

1532
01:22:17,760 --> 01:22:19,760
core advantages that can tip success to

1533
01:22:19,760 --> 01:22:22,480
one side or the other like the tall palm

1534
01:22:22,480 --> 01:22:24,480
tree here versus the short you'll see

1535
01:22:24,480 --> 01:22:26,159
there's like little easter egg imagery

1536
01:22:26,159 --> 01:22:28,639
behind me anyway uh imperfect

1537
01:22:28,639 --> 01:22:30,239
information again some of you may know

1538
01:22:30,239 --> 01:22:31,440
this from game theory if you don't

1539
01:22:31,440 --> 01:22:32,960
you're getting a little lesson so

1540
01:22:32,960 --> 01:22:34,800
imperfect information means players may

1541
01:22:34,800 --> 01:22:36,960
not observe or know all the moves made

1542
01:22:36,960 --> 01:22:39,679
during the game very much like real life

1543
01:22:39,679 --> 01:22:41,120
incomplete information means that

1544
01:22:41,120 --> 01:22:42,639
players may be unaware of their

1545
01:22:42,639 --> 01:22:43,920
opponent's characteristics like

1546
01:22:43,920 --> 01:22:46,320
priorities goals risk tolerance resource

1547
01:22:46,320 --> 01:22:49,120
constraints so if one player has more or

1548
01:22:49,120 --> 01:22:51,120
better information related to the game

1549
01:22:51,120 --> 01:22:52,400
than their opponent

1550
01:22:52,400 --> 01:22:54,159
that reflects an information asymmetry

1551
01:22:54,159 --> 01:22:56,639
and they're more likely to win

1552
01:22:56,639 --> 01:22:58,400
how does each side choose their game

1553
01:22:58,400 --> 01:23:00,639
plan so attackers choose an attack plan

1554
01:23:00,639 --> 01:23:02,960
based on pre-existing uh beliefs and

1555
01:23:02,960 --> 01:23:04,159
knowledge learned through experience

1556
01:23:04,159 --> 01:23:06,000
about operators current infrastructure

1557
01:23:06,000 --> 01:23:08,000
and protection of it then operators

1558
01:23:08,000 --> 01:23:09,600
choose a defensive plan based on

1559
01:23:09,600 --> 01:23:11,120
pre-existing and learned knowledge about

1560
01:23:11,120 --> 01:23:14,159
attackers beliefs and methods

1561
01:23:14,159 --> 01:23:15,679
this dynamic presents an awesome

1562
01:23:15,679 --> 01:23:17,440
opportunity for you to use deception to

1563
01:23:17,440 --> 01:23:19,760
amplify information asymmetries in your

1564
01:23:19,760 --> 01:23:22,080
favor it's great again your favor

1565
01:23:22,080 --> 01:23:24,159
assuming you're not attacker which case

1566
01:23:24,159 --> 01:23:26,719
it's against you so by manipulating the

1567
01:23:26,719 --> 01:23:28,560
experiences that attackers receive any

1568
01:23:28,560 --> 01:23:30,320
knowledge gained from those experiences

1569
01:23:30,320 --> 01:23:32,320
is inherently unreliable it's going to

1570
01:23:32,320 --> 01:23:34,320
poison the attacker's decision-making

1571
01:23:34,320 --> 01:23:37,120
process which disrupts everything so

1572
01:23:37,120 --> 01:23:38,480
think of it kind of like a denial of

1573
01:23:38,480 --> 01:23:40,159
service on their cognitive processes and

1574
01:23:40,159 --> 01:23:42,159
against that like tightly coupled like

1575
01:23:42,159 --> 01:23:44,880
decision making and learning system

1576
01:23:44,880 --> 01:23:46,960
so deception systems very conveniently

1577
01:23:46,960 --> 01:23:48,800
for us allow you to exacerbate

1578
01:23:48,800 --> 01:23:50,719
information asymmetries in two key

1579
01:23:50,719 --> 01:23:53,440
dimensions so first you're exposing real

1580
01:23:53,440 --> 01:23:55,199
world attack or real world data on

1581
01:23:55,199 --> 01:23:56,880
attackers thought processes you can

1582
01:23:56,880 --> 01:23:58,560
think of that as increasing the value of

1583
01:23:58,560 --> 01:24:01,120
information for operators

1584
01:24:01,120 --> 01:24:02,480
then second you're manipulating

1585
01:24:02,480 --> 01:24:04,400
information to disrupt attackers

1586
01:24:04,400 --> 01:24:06,159
abilities to learn and make decisions

1587
01:24:06,159 --> 01:24:07,600
and you can think of that like reducing

1588
01:24:07,600 --> 01:24:09,440
the information and the value of

1589
01:24:09,440 --> 01:24:11,440
information for attackers so the rest of

1590
01:24:11,440 --> 01:24:12,880
the talk is going to discuss the

1591
01:24:12,880 --> 01:24:14,960
challenges and potential of deception

1592
01:24:14,960 --> 01:24:17,280
systems to achieve these goals this

1593
01:24:17,280 --> 01:24:19,120
harnessing information asymmetry in your

1594
01:24:19,120 --> 01:24:21,920
favor in real world context

1595
01:24:21,920 --> 01:24:23,360
so i'll hand it over to ryan to talk

1596
01:24:23,360 --> 01:24:26,639
about the sucky status quo in deception

1597
01:24:26,639 --> 01:24:28,320
so yeah the status quo

1598
01:24:28,320 --> 01:24:30,639
kind of sucks yeah uh deception has kind

1599
01:24:30,639 --> 01:24:32,960
of been just like in a place it's been

1600
01:24:32,960 --> 01:24:35,840
for a while and key reason is honey pots

1601
01:24:35,840 --> 01:24:37,280
so honey pots are the prevailing

1602
01:24:37,280 --> 01:24:39,520
mechanism used to implement deception

1603
01:24:39,520 --> 01:24:41,920
and not really much has changed since

1604
01:24:41,920 --> 01:24:44,000
clifford stahl invented them in the 80s

1605
01:24:44,000 --> 01:24:45,679
there's been some advancements but they

1606
01:24:45,679 --> 01:24:47,600
haven't really kept pace with the

1607
01:24:47,600 --> 01:24:49,199
capability growth we see elsewhere in

1608
01:24:49,199 --> 01:24:50,320
computing

1609
01:24:50,320 --> 01:24:51,760
most of you might know what a honeypot

1610
01:24:51,760 --> 01:24:53,280
is but just to get everyone on the same

1611
01:24:53,280 --> 01:24:54,320
page

1612
01:24:54,320 --> 01:24:56,320
let's define it as a host that's set up

1613
01:24:56,320 --> 01:24:58,239
for the sole purpose of detecting

1614
01:24:58,239 --> 01:24:59,520
observing

1615
01:24:59,520 --> 01:25:01,520
or misdirecting attack behavior so that

1616
01:25:01,520 --> 01:25:04,159
any access or usage indicates suspicious

1617
01:25:04,159 --> 01:25:06,400
activity

1618
01:25:06,400 --> 01:25:08,239
what kind of honey pots are there

1619
01:25:08,239 --> 01:25:10,080
so honey pots are usually categorized by

1620
01:25:10,080 --> 01:25:12,480
whether they involve low medium or high

1621
01:25:12,480 --> 01:25:14,560
level of interactivity each has

1622
01:25:14,560 --> 01:25:18,080
deficiencies that we're going to cover

1623
01:25:18,080 --> 01:25:19,600
low interaction honey pots are the

1624
01:25:19,600 --> 01:25:22,560
equivalent of cardboard cutout decoys

1625
01:25:22,560 --> 01:25:24,800
attackers cannot interact with them in

1626
01:25:24,800 --> 01:25:26,719
any useful way think of them like the

1627
01:25:26,719 --> 01:25:29,520
basic of the honeypot community

1628
01:25:29,520 --> 01:25:31,600
nowhere the deception system community

1629
01:25:31,600 --> 01:25:32,880
yeah

1630
01:25:32,880 --> 01:25:34,560
so these honey pots they represent a

1631
01:25:34,560 --> 01:25:37,120
simple mimicry of systems availability

1632
01:25:37,120 --> 01:25:38,480
they're used to detect the presence of

1633
01:25:38,480 --> 01:25:40,480
port scanning and other basic methods

1634
01:25:40,480 --> 01:25:42,639
attackers use to gather relevant

1635
01:25:42,639 --> 01:25:44,000
knowledge

1636
01:25:44,000 --> 01:25:46,800
related to gaining access

1637
01:25:46,800 --> 01:25:48,719
medium interaction honeypots go a little

1638
01:25:48,719 --> 01:25:50,719
bit further they imitate a specific kind

1639
01:25:50,719 --> 01:25:52,080
of service

1640
01:25:52,080 --> 01:25:54,000
in enough depth to encourage attackers

1641
01:25:54,000 --> 01:25:56,320
to just like throw their exploit for

1642
01:25:56,320 --> 01:25:58,719
some well-known vault right so you have

1643
01:25:58,719 --> 01:26:00,960
to know about the ball and have to yeah

1644
01:26:00,960 --> 01:26:03,679
um they lack the presence of an actual

1645
01:26:03,679 --> 01:26:05,760
instance of the service so they're

1646
01:26:05,760 --> 01:26:08,320
pretty pretty opaque they kind of look

1647
01:26:08,320 --> 01:26:09,920
like it but not really

1648
01:26:09,920 --> 01:26:12,320
so upon an exploitation attempt a medium

1649
01:26:12,320 --> 01:26:14,400
interaction honeypot will send an alert

1650
01:26:14,400 --> 01:26:16,480
record the attempt reject it pretty

1651
01:26:16,480 --> 01:26:17,840
straightforward

1652
01:26:17,840 --> 01:26:19,920
so these are best for studying large

1653
01:26:19,920 --> 01:26:21,920
scale exploitation trends of public

1654
01:26:21,920 --> 01:26:23,040
volumes

1655
01:26:23,040 --> 01:26:25,280
or as a canary operating inside of a

1656
01:26:25,280 --> 01:26:27,360
production network where any sort of

1657
01:26:27,360 --> 01:26:29,679
access to the host indicates that some

1658
01:26:29,679 --> 01:26:32,000
attack is already in progress and maybe

1659
01:26:32,000 --> 01:26:34,320
you can have some idea about the source

1660
01:26:34,320 --> 01:26:35,760
of that attack but it's very

1661
01:26:35,760 --> 01:26:37,520
coarse-grained and doesn't give you very

1662
01:26:37,520 --> 01:26:39,520
much information

1663
01:26:39,520 --> 01:26:41,120
so now let's move on to high interaction

1664
01:26:41,120 --> 01:26:42,880
honeypots and this is where it gets a

1665
01:26:42,880 --> 01:26:45,440
little bit interesting uh so these are

1666
01:26:45,440 --> 01:26:46,320
well

1667
01:26:46,320 --> 01:26:47,199
we'll see

1668
01:26:47,199 --> 01:26:49,440
yeah so there are vulnerable copies of

1669
01:26:49,440 --> 01:26:52,080
services meant to tempt attackers who

1670
01:26:52,080 --> 01:26:54,239
can exploit the service gain access

1671
01:26:54,239 --> 01:26:55,679
interact with the operating system as

1672
01:26:55,679 --> 01:26:58,000
they normally would but aside from the

1673
01:26:58,000 --> 01:27:00,400
operating system it's uncommon for honey

1674
01:27:00,400 --> 01:27:03,120
pots to include other components which

1675
01:27:03,120 --> 01:27:05,040
mimic a real system so

1676
01:27:05,040 --> 01:27:07,440
um for the fuse that few that do it's

1677
01:27:07,440 --> 01:27:08,639
usually because they're built by

1678
01:27:08,639 --> 01:27:11,280
transplanting a system at some point in

1679
01:27:11,280 --> 01:27:13,199
time so you just like take a snapshot

1680
01:27:13,199 --> 01:27:16,159
and like that's your honeypot now um and

1681
01:27:16,159 --> 01:27:17,679
usually that's like

1682
01:27:17,679 --> 01:27:19,520
years old right so you end up with the

1683
01:27:19,520 --> 01:27:21,679
system that had some activity and then

1684
01:27:21,679 --> 01:27:24,000
was like frozen in time and here you go

1685
01:27:24,000 --> 01:27:26,800
it's now our lure um so that doesn't

1686
01:27:26,800 --> 01:27:28,239
doesn't work very well

1687
01:27:28,239 --> 01:27:30,080
uh so high interaction honey pots

1688
01:27:30,080 --> 01:27:32,239
usually send an alert upon detection of

1689
01:27:32,239 --> 01:27:34,080
an attacker's presence such as

1690
01:27:34,080 --> 01:27:36,560
successful exploitation etc

1691
01:27:36,560 --> 01:27:38,320
at least that's kind of the hope there's

1692
01:27:38,320 --> 01:27:40,480
no determinism in that you can't you

1693
01:27:40,480 --> 01:27:42,080
know tell for certain when they come in

1694
01:27:42,080 --> 01:27:44,719
because you know it's it's just the

1695
01:27:44,719 --> 01:27:46,719
service itself

1696
01:27:46,719 --> 01:27:48,400
so both low and medium interaction

1697
01:27:48,400 --> 01:27:51,120
honeypots are practically useless for

1698
01:27:51,120 --> 01:27:53,920
manipulating attackers um any insights

1699
01:27:53,920 --> 01:27:56,000
you gain from them are actually skewed

1700
01:27:56,000 --> 01:27:57,280
not our most creative endeavor but

1701
01:27:57,280 --> 01:27:58,239
anyway

1702
01:27:58,239 --> 01:28:00,159
the deception environments reflect like

1703
01:28:00,159 --> 01:28:01,679
a pretty significant departure from the

1704
01:28:01,679 --> 01:28:04,320
prior generation and in fact deception

1705
01:28:04,320 --> 01:28:05,840
environments are sufficiently involved

1706
01:28:05,840 --> 01:28:07,520
from honey pots they actually represent

1707
01:28:07,520 --> 01:28:09,440
like a new distinct category which is

1708
01:28:09,440 --> 01:28:10,800
exciting

1709
01:28:10,800 --> 01:28:13,280
again attackers are really uh adept at

1710
01:28:13,280 --> 01:28:15,360
attacking systems and understanding like

1711
01:28:15,360 --> 01:28:17,199
all of the interrelations between

1712
01:28:17,199 --> 01:28:19,120
components to inform their operations

1713
01:28:19,120 --> 01:28:21,040
it's like no wonder that attackers find

1714
01:28:21,040 --> 01:28:22,880
honey pots in the existing status quo

1715
01:28:22,880 --> 01:28:25,920
like just corny as

1716
01:28:25,920 --> 01:28:27,520
over to you

1717
01:28:27,520 --> 01:28:30,639
yeah um so new types of computing and

1718
01:28:30,639 --> 01:28:32,239
ownership by software engineers and

1719
01:28:32,239 --> 01:28:34,159
operators means we can create entire

1720
01:28:34,159 --> 01:28:37,199
environments dedicated to deception

1721
01:28:37,199 --> 01:28:39,120
uh these environments will run your real

1722
01:28:39,120 --> 01:28:41,280
software they'll behave like your actual

1723
01:28:41,280 --> 01:28:43,600
systems most importantly attackers will

1724
01:28:43,600 --> 01:28:45,360
recognize them as if they were your

1725
01:28:45,360 --> 01:28:47,679
actual systems rather than the mirage

1726
01:28:47,679 --> 01:28:49,120
they are

1727
01:28:49,120 --> 01:28:50,719
so the goal of traditional honeypots is

1728
01:28:50,719 --> 01:28:52,480
to determine the presence of attackers

1729
01:28:52,480 --> 01:28:54,960
using scanning tools known volumes um

1730
01:28:54,960 --> 01:28:58,560
and how how frequently they do so

1731
01:28:58,560 --> 01:29:00,480
rarely will they detect attackers moving

1732
01:29:00,480 --> 01:29:02,159
from one host to the next that's the

1733
01:29:02,159 --> 01:29:04,320
sort of like put it in your production

1734
01:29:04,320 --> 01:29:07,679
uh network situation um and tracing the

1735
01:29:07,679 --> 01:29:10,320
finer nuances of like their behavior or

1736
01:29:10,320 --> 01:29:12,880
uncovering their latest methodology

1737
01:29:12,880 --> 01:29:15,120
is sort of absent from deception

1738
01:29:15,120 --> 01:29:17,679
projects to date um hooray you can kind

1739
01:29:17,679 --> 01:29:20,880
of like discover that some ips are bad

1740
01:29:20,880 --> 01:29:23,360
and where the bad is badness that is

1741
01:29:23,360 --> 01:29:24,400
just like

1742
01:29:24,400 --> 01:29:26,320
in your face rather than lurking in the

1743
01:29:26,320 --> 01:29:29,280
shadows um and sure you can throw those

1744
01:29:29,280 --> 01:29:31,440
into your like you can put it on a block

1745
01:29:31,440 --> 01:29:33,600
list but you know like that's a pretty

1746
01:29:33,600 --> 01:29:36,719
shallow view of attacks

1747
01:29:36,719 --> 01:29:39,280
so deception environments are means to

1748
01:29:39,280 --> 01:29:40,960
observe and understand attack behavior

1749
01:29:40,960 --> 01:29:42,159
throughout all stages of their

1750
01:29:42,159 --> 01:29:43,440
operations

1751
01:29:43,440 --> 01:29:45,360
and their platforms for conducting

1752
01:29:45,360 --> 01:29:47,840
experiments on attackers that are

1753
01:29:47,840 --> 01:29:50,480
capable of evading your defensive

1754
01:29:50,480 --> 01:29:51,600
measures

1755
01:29:51,600 --> 01:29:53,520
so they're with you and now you

1756
01:29:53,520 --> 01:29:55,440
can with them yeah yeah that's

1757
01:29:55,440 --> 01:29:56,880
exciting right

1758
01:29:56,880 --> 01:29:59,280
uh so this this concentrates efforts on

1759
01:29:59,280 --> 01:30:01,840
designing more resilient systems uh and

1760
01:30:01,840 --> 01:30:04,000
makes fruitful use of finite engineering

1761
01:30:04,000 --> 01:30:05,920
resources it's almost sort of a

1762
01:30:05,920 --> 01:30:07,920
universal truth that engineers are

1763
01:30:07,920 --> 01:30:10,080
distracted and only can pay so much

1764
01:30:10,080 --> 01:30:12,080
attention to security and if you align

1765
01:30:12,080 --> 01:30:13,600
it with this sort of like resilience

1766
01:30:13,600 --> 01:30:15,920
characteristic they love uptime they

1767
01:30:15,920 --> 01:30:18,480
want their systems to function and

1768
01:30:18,480 --> 01:30:21,679
attackers are one means by which you can

1769
01:30:21,679 --> 01:30:24,159
lose some uptime

1770
01:30:24,159 --> 01:30:25,760
so what elements of modern

1771
01:30:25,760 --> 01:30:27,520
infrastructure are pivotal in nurturing

1772
01:30:27,520 --> 01:30:30,719
this new deception paradigm

1773
01:30:30,719 --> 01:30:32,719
first is cloud computing uh hopefully

1774
01:30:32,719 --> 01:30:34,960
you know what the cloud is if not maybe

1775
01:30:34,960 --> 01:30:36,880
you're too comfortable under your rock i

1776
01:30:36,880 --> 01:30:38,880
hope you know um but cloud computing

1777
01:30:38,880 --> 01:30:40,480
gives everyone the ability to provision

1778
01:30:40,480 --> 01:30:42,960
fully isolated computing infrastructure

1779
01:30:42,960 --> 01:30:45,040
with very little expense so full

1780
01:30:45,040 --> 01:30:46,719
isolation used to mean racking and

1781
01:30:46,719 --> 01:30:48,480
stacking your hardware and committing

1782
01:30:48,480 --> 01:30:50,560
your firstborn probably some of you have

1783
01:30:50,560 --> 01:30:51,920
been around for a while have been in

1784
01:30:51,920 --> 01:30:54,560
that era super inconvenient and you

1785
01:30:54,560 --> 01:30:56,800
gotta like go to new jersey and visit

1786
01:30:56,800 --> 01:30:58,880
the data center it's not fun

1787
01:30:58,880 --> 01:31:01,440
um who wants to go there right i know

1788
01:31:01,440 --> 01:31:02,719
right yeah

1789
01:31:02,719 --> 01:31:04,320
now it only requires an active credit

1790
01:31:04,320 --> 01:31:06,800
card to get some free quota um and you

1791
01:31:06,800 --> 01:31:09,199
can just like sign up and go super easy

1792
01:31:09,199 --> 01:31:11,679
and it's fully isolated

1793
01:31:11,679 --> 01:31:13,840
so next is deployment automation

1794
01:31:13,840 --> 01:31:16,239
so full systems deployment automation

1795
01:31:16,239 --> 01:31:18,159
and the practice of defining

1796
01:31:18,159 --> 01:31:20,560
infrastructure declaratively this

1797
01:31:20,560 --> 01:31:22,800
infrastructure is code thing that's

1798
01:31:22,800 --> 01:31:24,480
buzzword that's taking over

1799
01:31:24,480 --> 01:31:26,239
so this decreases your operational

1800
01:31:26,239 --> 01:31:28,159
overhead in deploying and maintaining

1801
01:31:28,159 --> 01:31:30,400
variance of infrastructure

1802
01:31:30,400 --> 01:31:32,320
it used to be considered a luxury to

1803
01:31:32,320 --> 01:31:33,920
have like additional environments to

1804
01:31:33,920 --> 01:31:36,400
test your software in so sometimes you

1805
01:31:36,400 --> 01:31:38,080
yellow it but

1806
01:31:38,080 --> 01:31:39,600
you know now the orchestrators just do

1807
01:31:39,600 --> 01:31:41,280
it for free you can have like 17

1808
01:31:41,280 --> 01:31:42,639
environments and give them all cute

1809
01:31:42,639 --> 01:31:45,760
names but you know like it's it's super

1810
01:31:45,760 --> 01:31:50,560
easy and uh it costs very little

1811
01:31:50,560 --> 01:31:52,000
and then there's virtualization

1812
01:31:52,000 --> 01:31:53,360
enhancements and this has been the

1813
01:31:53,360 --> 01:31:55,520
driving force behind these first two

1814
01:31:55,520 --> 01:31:57,440
parts so virtualization allows us to

1815
01:31:57,440 --> 01:31:59,840
carve up hardware in various ways and

1816
01:31:59,840 --> 01:32:02,080
lie to the software like yes operating

1817
01:32:02,080 --> 01:32:03,679
system you've got the whole machine to

1818
01:32:03,679 --> 01:32:06,080
yourself it's all yours right but

1819
01:32:06,080 --> 01:32:08,800
actually it's just tiny little slice

1820
01:32:08,800 --> 01:32:10,800
and you can resize those slices and do

1821
01:32:10,800 --> 01:32:13,280
tons of cool um the widespread

1822
01:32:13,280 --> 01:32:15,360
availability of nested virtualization

1823
01:32:15,360 --> 01:32:16,800
and mature

1824
01:32:16,800 --> 01:32:18,800
hardened virtualization that's like he

1825
01:32:18,800 --> 01:32:19,840
said

1826
01:32:19,840 --> 01:32:22,719
helps in a few ways um so it inspires

1827
01:32:22,719 --> 01:32:24,639
confidence that attackers are actually

1828
01:32:24,639 --> 01:32:26,719
isolated from production

1829
01:32:26,719 --> 01:32:28,400
it makes it possible to observe them in

1830
01:32:28,400 --> 01:32:30,880
more detail and it extracts extra

1831
01:32:30,880 --> 01:32:34,000
density out of machines which again

1832
01:32:34,000 --> 01:32:37,120
drives cost down even further

1833
01:32:37,120 --> 01:32:38,560
so the next is software defined

1834
01:32:38,560 --> 01:32:40,320
networking so with the ability to define

1835
01:32:40,320 --> 01:32:41,840
networks programmatically

1836
01:32:41,840 --> 01:32:43,840
isolated network topology can be

1837
01:32:43,840 --> 01:32:45,840
dedicated to attackers

1838
01:32:45,840 --> 01:32:48,000
uh and we can create this without like

1839
01:32:48,000 --> 01:32:49,760
it's basically free right you just have

1840
01:32:49,760 --> 01:32:51,520
the overhead of defining like where do i

1841
01:32:51,520 --> 01:32:52,960
want my traffic to go

1842
01:32:52,960 --> 01:32:55,199
build these routes

1843
01:32:55,199 --> 01:32:56,880
and so you can isolate a bunch of these

1844
01:32:56,880 --> 01:32:58,800
virtual machines in their own little

1845
01:32:58,800 --> 01:33:01,920
sandbox and attackers will be fully

1846
01:33:01,920 --> 01:33:03,760
isolated to just that set and that

1847
01:33:03,760 --> 01:33:05,360
applies to the cloud and sort of like

1848
01:33:05,360 --> 01:33:06,840
on-prem you're like

1849
01:33:06,840 --> 01:33:09,679
v-sphere or nonsense

1850
01:33:09,679 --> 01:33:12,080
um and finally and no less important

1851
01:33:12,080 --> 01:33:14,080
than the infrastruct stuff and we've

1852
01:33:14,080 --> 01:33:15,679
been harping on this a lot

1853
01:33:15,679 --> 01:33:17,199
but it's ownership based on systems

1854
01:33:17,199 --> 01:33:19,280
design and operation expertise that

1855
01:33:19,280 --> 01:33:21,120
creates this sort of like dynamism

1856
01:33:21,120 --> 01:33:23,600
necessary for deception systems to

1857
01:33:23,600 --> 01:33:26,239
succeed against your dynamic opponents

1858
01:33:26,239 --> 01:33:28,960
so sorry infosec folks like you're

1859
01:33:28,960 --> 01:33:31,520
unlikely to know how your systems behave

1860
01:33:31,520 --> 01:33:33,440
or are designed unless you operate them

1861
01:33:33,440 --> 01:33:36,000
uh some of you do that's great but like

1862
01:33:36,000 --> 01:33:37,679
um you know it's like the people

1863
01:33:37,679 --> 01:33:39,600
building the systems and like designing

1864
01:33:39,600 --> 01:33:41,760
them they kind of know how they function

1865
01:33:41,760 --> 01:33:45,040
and how the moving parts fit together

1866
01:33:45,040 --> 01:33:46,800
software engine teams are already

1867
01:33:46,800 --> 01:33:49,440
executing the necessary practices

1868
01:33:49,440 --> 01:33:50,960
they can repurpose their existing

1869
01:33:50,960 --> 01:33:52,480
systems deployment templates for

1870
01:33:52,480 --> 01:33:54,000
building production environments and

1871
01:33:54,000 --> 01:33:56,719
variants thereof like staging and dev

1872
01:33:56,719 --> 01:33:58,880
and just another variant you can pull

1873
01:33:58,880 --> 01:34:00,560
that towards building super powerful

1874
01:34:00,560 --> 01:34:02,400
deception systems

1875
01:34:02,400 --> 01:34:05,600
you can then derive attack data that is

1876
01:34:05,600 --> 01:34:07,679
distinctly applicable to the systems

1877
01:34:07,679 --> 01:34:10,080
that you own and operate that you cannot

1878
01:34:10,080 --> 01:34:12,719
garner elsewhere and this is key

1879
01:34:12,719 --> 01:34:14,159
with a little work over what you're

1880
01:34:14,159 --> 01:34:15,520
already doing you can gain a highly

1881
01:34:15,520 --> 01:34:17,520
effective observability tool

1882
01:34:17,520 --> 01:34:19,679
by deploying deception environments

1883
01:34:19,679 --> 01:34:21,360
and with them the security properties of

1884
01:34:21,360 --> 01:34:23,280
their systems become much more clear

1885
01:34:23,280 --> 01:34:25,360
than anything sort of like the security

1886
01:34:25,360 --> 01:34:28,080
team or the vendor community at large

1887
01:34:28,080 --> 01:34:30,239
could ever describe because it's your

1888
01:34:30,239 --> 01:34:32,320
system you know how attackers interact

1889
01:34:32,320 --> 01:34:34,800
with it i walk to the rsa floor cause i

1890
01:34:34,800 --> 01:34:36,960
mean i don't consider myself a masochist

1891
01:34:36,960 --> 01:34:38,480
but that seems to be evidence otherwise

1892
01:34:38,480 --> 01:34:39,440
and like

1893
01:34:39,440 --> 01:34:40,960
most vendors aren't

1894
01:34:40,960 --> 01:34:43,520
coming even close to this for sure

1895
01:34:43,520 --> 01:34:45,679
so hopefully you're super hyped

1896
01:34:45,679 --> 01:34:47,440
about building these deception systems

1897
01:34:47,440 --> 01:34:49,040
or deception environments specifically

1898
01:34:49,040 --> 01:34:50,639
right and you want to learn how to

1899
01:34:50,639 --> 01:34:53,040
design them hopefully this is this is

1900
01:34:53,040 --> 01:34:55,119
this is a big time so the design

1901
01:34:55,119 --> 01:34:56,400
philosophy underlying deception

1902
01:34:56,400 --> 01:34:58,080
environments is grounded in repurposing

1903
01:34:58,080 --> 01:34:59,920
the design assets and orchestration

1904
01:34:59,920 --> 01:35:02,000
templates of your real production system

1905
01:35:02,000 --> 01:35:03,199
instead of building like a separate

1906
01:35:03,199 --> 01:35:05,360
design for deception as is the status

1907
01:35:05,360 --> 01:35:07,840
quo the status quo really requires extra

1908
01:35:07,840 --> 01:35:09,280
design effort for transparent

1909
01:35:09,280 --> 01:35:11,040
ineffective results so this is just way

1910
01:35:11,040 --> 01:35:13,280
more efficient much better roi such a

1911
01:35:13,280 --> 01:35:15,280
waste

1912
01:35:15,280 --> 01:35:16,960
deception becomes a new environment

1913
01:35:16,960 --> 01:35:18,560
generated at the end of software

1914
01:35:18,560 --> 01:35:20,080
delivery pipelines so after development

1915
01:35:20,080 --> 01:35:22,560
staging pre-production production any

1916
01:35:22,560 --> 01:35:24,800
other bizarre deployment you've created

1917
01:35:24,800 --> 01:35:26,639
and in this case bazaar is good like

1918
01:35:26,639 --> 01:35:28,560
hopefully you'll discover some bizarre

1919
01:35:28,560 --> 01:35:30,960
behavior of attackers and bring it back

1920
01:35:30,960 --> 01:35:33,520
into the design of your system

1921
01:35:33,520 --> 01:35:35,760
from this foundation attacker skepticism

1922
01:35:35,760 --> 01:35:37,440
can be preempted by designing a

1923
01:35:37,440 --> 01:35:39,199
deception environment feels sort of

1924
01:35:39,199 --> 01:35:41,119
lived in through tactics such as

1925
01:35:41,119 --> 01:35:43,440
replaying traffic or other methods of

1926
01:35:43,440 --> 01:35:45,679
simulating system activity

1927
01:35:45,679 --> 01:35:47,440
so starting with the design of a genuine

1928
01:35:47,440 --> 01:35:49,119
production system provides a very

1929
01:35:49,119 --> 01:35:51,600
inherent level of realism to bamboozle

1930
01:35:51,600 --> 01:35:53,600
attackers and also to glean insights

1931
01:35:53,600 --> 01:35:55,679
that are pertinent to your real system

1932
01:35:55,679 --> 01:35:57,679
like and to securing the real system

1933
01:35:57,679 --> 01:35:59,520
because it looks like it so since every

1934
01:35:59,520 --> 01:36:00,960
system has very different resilience

1935
01:36:00,960 --> 01:36:02,880
concerns this also offers like a very

1936
01:36:02,880 --> 01:36:04,800
opportune and safe test of how your

1937
01:36:04,800 --> 01:36:07,199
resilience tactics like any mitigations

1938
01:36:07,199 --> 01:36:08,719
that you implement perform against

1939
01:36:08,719 --> 01:36:10,880
actual attackers and this framing of

1940
01:36:10,880 --> 01:36:13,199
resilience really is key not just to get

1941
01:36:13,199 --> 01:36:15,119
your software engineering

1942
01:36:15,119 --> 01:36:16,800
brethren like along with you on this

1943
01:36:16,800 --> 01:36:18,639
journey it's also the goal is to prevail

1944
01:36:18,639 --> 01:36:20,400
over attackers even in the presence of

1945
01:36:20,400 --> 01:36:22,480
temporary failure

1946
01:36:22,480 --> 01:36:24,880
so we came up with the fick trilemma fic

1947
01:36:24,880 --> 01:36:26,880
to help y'all and the community at large

1948
01:36:26,880 --> 01:36:28,400
reason about the design of deception

1949
01:36:28,400 --> 01:36:30,400
systems so again traditional honeypot

1950
01:36:30,400 --> 01:36:32,560
design very focused on like initial out

1951
01:36:32,560 --> 01:36:34,560
access looking at the like outer shape

1952
01:36:34,560 --> 01:36:36,639
of the system it's very hollow but this

1953
01:36:36,639 --> 01:36:38,320
framing really limits the ability to

1954
01:36:38,320 --> 01:36:40,960
evaluate and deception system design

1955
01:36:40,960 --> 01:36:42,800
approaches that are outside of the very

1956
01:36:42,800 --> 01:36:44,960
rudimentary ones that we've seen to date

1957
01:36:44,960 --> 01:36:46,560
so the new model we propose the fictory

1958
01:36:46,560 --> 01:36:48,400
limit really involves evaluating

1959
01:36:48,400 --> 01:36:50,480
deception systems along three axises

1960
01:36:50,480 --> 01:36:52,400
that are really important so fidelity

1961
01:36:52,400 --> 01:36:54,880
isolation and cost that represents a

1962
01:36:54,880 --> 01:36:56,239
trilemma if you aren't familiar with

1963
01:36:56,239 --> 01:36:58,080
trilemmas i am a huge hoe for them i

1964
01:36:58,080 --> 01:36:59,520
promise i didn't shoehorn this in on

1965
01:36:59,520 --> 01:37:01,199
purpose it really is a true telling them

1966
01:37:01,199 --> 01:37:03,040
but i'm just so excited about them so if

1967
01:37:03,040 --> 01:37:04,159
you don't know about them i am just

1968
01:37:04,159 --> 01:37:06,000
thrilled i get to teach you it's from

1969
01:37:06,000 --> 01:37:07,440
the world of like macroeconomics but

1970
01:37:07,440 --> 01:37:08,960
basically trilemma means that you have

1971
01:37:08,960 --> 01:37:10,560
three properties that are generally in

1972
01:37:10,560 --> 01:37:12,560
conflict and therefore they can't be

1973
01:37:12,560 --> 01:37:15,360
achieved fully simultaneously

1974
01:37:15,360 --> 01:37:17,840
as you can see here our beautiful thick

1975
01:37:17,840 --> 01:37:19,920
trilemma very big it's going to keep

1976
01:37:19,920 --> 01:37:22,080
getting filled out but you have fidelity

1977
01:37:22,080 --> 01:37:24,159
uh isolation and cost

1978
01:37:24,159 --> 01:37:25,840
you can see how it's impossible to

1979
01:37:25,840 --> 01:37:27,760
achieve all three at the same time so

1980
01:37:27,760 --> 01:37:30,000
understanding this beautiful trilemma

1981
01:37:30,000 --> 01:37:31,440
and the trade-offs between each of these

1982
01:37:31,440 --> 01:37:33,760
axes in particular is really vital for

1983
01:37:33,760 --> 01:37:35,360
designing successful deception

1984
01:37:35,360 --> 01:37:36,880
environments

1985
01:37:36,880 --> 01:37:38,639
so let's start with fidelity

1986
01:37:38,639 --> 01:37:41,119
f for fidelity which this is a very

1987
01:37:41,119 --> 01:37:42,960
strange children's book starting off so

1988
01:37:42,960 --> 01:37:44,639
f for fidelity refers to the deception

1989
01:37:44,639 --> 01:37:46,400
system's credibility to attackers and

1990
01:37:46,400 --> 01:37:47,920
its ability to support attack

1991
01:37:47,920 --> 01:37:50,320
observability so credible deceptions

1992
01:37:50,320 --> 01:37:52,159
system is very effective at deceiving

1993
01:37:52,159 --> 01:37:53,679
attackers into thinking the system is

1994
01:37:53,679 --> 01:37:55,920
real it involves falling

1995
01:37:55,920 --> 01:37:58,000
it sorry it avoids falling into that

1996
01:37:58,000 --> 01:38:01,679
like uncanny valley sort of effect

1997
01:38:01,679 --> 01:38:03,679
because attackers again some of you out

1998
01:38:03,679 --> 01:38:04,960
here there are wolves among us

1999
01:38:04,960 --> 01:38:06,719
presumably um you've probably

2000
01:38:06,719 --> 01:38:08,560
interrogated the systems that you've

2001
01:38:08,560 --> 01:38:10,960
compromised to unmask mirages and avoid

2002
01:38:10,960 --> 01:38:12,800
revealing your methods right because

2003
01:38:12,800 --> 01:38:15,040
attackers expect basic sorts of traits

2004
01:38:15,040 --> 01:38:16,800
in systems like running a service

2005
01:38:16,800 --> 01:38:18,239
receiving production like traffic

2006
01:38:18,239 --> 01:38:19,679
connecting to the wider internet

2007
01:38:19,679 --> 01:38:21,280
connecting to other services over a

2008
01:38:21,280 --> 01:38:22,560
local network

2009
01:38:22,560 --> 01:38:24,080
being orchestrated and monitored by

2010
01:38:24,080 --> 01:38:25,600
another system and not having things

2011
01:38:25,600 --> 01:38:28,239
like debugging tools that are present

2012
01:38:28,239 --> 01:38:30,159
so highly credible deception system will

2013
01:38:30,159 --> 01:38:32,560
provide sufficient depth that's fidelity

2014
01:38:32,560 --> 01:38:34,880
to stimulate extended attack or activity

2015
01:38:34,880 --> 01:38:36,639
so you want to lure even like very

2016
01:38:36,639 --> 01:38:38,719
cautious attackers into moving between

2017
01:38:38,719 --> 01:38:40,159
hosts and revealing all their methods

2018
01:38:40,159 --> 01:38:42,960
across the attack delivery life cycle

2019
01:38:42,960 --> 01:38:45,119
so this if you achieve this this begets

2020
01:38:45,119 --> 01:38:47,199
like a really detailed high quality very

2021
01:38:47,199 --> 01:38:49,199
accurate record of behavior for you to

2022
01:38:49,199 --> 01:38:50,719
gain an accurate understanding of attack

2023
01:38:50,719 --> 01:38:52,400
or decision making and that helps you

2024
01:38:52,400 --> 01:38:54,159
cultivate that information asymmetry

2025
01:38:54,159 --> 01:38:55,600
really wrong that we talked about at the

2026
01:38:55,600 --> 01:38:58,000
beginning so greater accuracy and depth

2027
01:38:58,000 --> 01:38:59,679
in extracting and recording activity

2028
01:38:59,679 --> 01:39:01,679
then informs better system design that

2029
01:39:01,679 --> 01:39:03,280
makes future iterations much more

2030
01:39:03,280 --> 01:39:05,600
resilient to attack

2031
01:39:05,600 --> 01:39:07,679
then i for isolation and that refers to

2032
01:39:07,679 --> 01:39:09,520
the degree to which a deception system

2033
01:39:09,520 --> 01:39:11,520
is isolated from the real environment or

2034
01:39:11,520 --> 01:39:14,000
data and it's the second axis in the fix

2035
01:39:14,000 --> 01:39:15,360
trilemma

2036
01:39:15,360 --> 01:39:17,520
again operators are like availability

2037
01:39:17,520 --> 01:39:19,360
and uptime is just precious so operators

2038
01:39:19,360 --> 01:39:20,639
are really loath to jeopardize

2039
01:39:20,639 --> 01:39:22,159
availability for much of anything

2040
01:39:22,159 --> 01:39:23,679
including security

2041
01:39:23,679 --> 01:39:25,600
they don't want to jeopardize real like

2042
01:39:25,600 --> 01:39:27,840
systems or real data or privacy in order

2043
01:39:27,840 --> 01:39:29,840
to just learn about attacker behavior

2044
01:39:29,840 --> 01:39:32,080
and we agree it would be stupid like i

2045
01:39:32,080 --> 01:39:33,840
think of apps and services kind of like

2046
01:39:33,840 --> 01:39:35,040
the money printer you want the money

2047
01:39:35,040 --> 01:39:37,440
printer to go like all the time so it's

2048
01:39:37,440 --> 01:39:39,199
stupid to put that money printer at risk

2049
01:39:39,199 --> 01:39:40,639
take it offline just for the art of

2050
01:39:40,639 --> 01:39:42,480
limbozling as much as we very deeply

2051
01:39:42,480 --> 01:39:43,600
love it

2052
01:39:43,600 --> 01:39:45,920
so a secondary element to del isolation

2053
01:39:45,920 --> 01:39:48,400
is that you can have the ability to keep

2054
01:39:48,400 --> 01:39:49,920
attackers actually isolated from each

2055
01:39:49,920 --> 01:39:50,880
other

2056
01:39:50,880 --> 01:39:52,320
which is really important if you want to

2057
01:39:52,320 --> 01:39:53,920
study each attacker's behavior

2058
01:39:53,920 --> 01:39:56,239
individually and independently

2059
01:39:56,239 --> 01:39:58,560
then finally c for cost and that refers

2060
01:39:58,560 --> 01:40:00,080
to the computing infrastructure and

2061
01:40:00,080 --> 01:40:01,679
operational overheads that are involved

2062
01:40:01,679 --> 01:40:05,280
to deploy and maintain deception systems

2063
01:40:05,280 --> 01:40:06,719
so it's computing costs continuing to

2064
01:40:06,719 --> 01:40:08,400
plummet as ryan talked about costs

2065
01:40:08,400 --> 01:40:10,239
really shift to operational burden and

2066
01:40:10,239 --> 01:40:12,239
things like actual head count that

2067
01:40:12,239 --> 01:40:13,440
really really really shouldn't be

2068
01:40:13,440 --> 01:40:15,280
underestimated because

2069
01:40:15,280 --> 01:40:17,119
expensive deception systems especially

2070
01:40:17,119 --> 01:40:18,560
those that take like a lot of time to

2071
01:40:18,560 --> 01:40:20,159
like operate and maintain they're not

2072
01:40:20,159 --> 01:40:22,000
going to be fully deployed or maintained

2073
01:40:22,000 --> 01:40:23,199
and then they're going to fail to serve

2074
01:40:23,199 --> 01:40:25,600
their purpose right

2075
01:40:25,600 --> 01:40:27,440
so mapping different types of deception

2076
01:40:27,440 --> 01:40:29,840
systems to this beautiful trilemma helps

2077
01:40:29,840 --> 01:40:31,600
really elucidate the value of the model

2078
01:40:31,600 --> 01:40:32,960
so we're going to take a little journey

2079
01:40:32,960 --> 01:40:35,679
into like add absurdum and look it

2080
01:40:35,679 --> 01:40:37,040
considering which types of systems

2081
01:40:37,040 --> 01:40:39,360
reflect like extreme realizations of

2082
01:40:39,360 --> 01:40:41,040
each of these axes which is perfect

2083
01:40:41,040 --> 01:40:42,800
fidelity total isolation and then

2084
01:40:42,800 --> 01:40:44,400
maximum cost

2085
01:40:44,400 --> 01:40:46,239
so oh you're going to be like vanna

2086
01:40:46,239 --> 01:40:48,000
white great so

2087
01:40:48,000 --> 01:40:49,520
real production systems reside at the

2088
01:40:49,520 --> 01:40:51,440
intersection of perfect fidelity little

2089
01:40:51,440 --> 01:40:53,600
cost and no isolation

2090
01:40:53,600 --> 01:40:55,600
they can't encounter real attackers

2091
01:40:55,600 --> 01:40:57,280
they're also monitored by like real

2092
01:40:57,280 --> 01:40:59,520
operators because production is where

2093
01:40:59,520 --> 01:41:01,199
organizations realize the value of all

2094
01:41:01,199 --> 01:41:02,800
the software development stuff that they

2095
01:41:02,800 --> 01:41:04,639
do right and it turns out organizations

2096
01:41:04,639 --> 01:41:06,239
and attackers both love money so they

2097
01:41:06,239 --> 01:41:07,679
like looking at the thing that makes the

2098
01:41:07,679 --> 01:41:08,800
money

2099
01:41:08,800 --> 01:41:10,960
so the next one is uh low interaction

2100
01:41:10,960 --> 01:41:12,880
honey pots down there at the bottom that

2101
01:41:12,880 --> 01:41:15,040
represents the inner kind of the

2102
01:41:15,040 --> 01:41:17,360
intersection of no fidelity little cost

2103
01:41:17,360 --> 01:41:19,199
and then perfect isolation they gather

2104
01:41:19,199 --> 01:41:21,280
like very very very limited info as we

2105
01:41:21,280 --> 01:41:22,960
talked about about attackers and also

2106
01:41:22,960 --> 01:41:24,480
present them with a very transparent

2107
01:41:24,480 --> 01:41:25,520
trick

2108
01:41:25,520 --> 01:41:27,440
they're very easy to deploy though and

2109
01:41:27,440 --> 01:41:29,920
they can deduct broad attack trends

2110
01:41:29,920 --> 01:41:31,600
and they offer also a risk-free incident

2111
01:41:31,600 --> 01:41:33,040
impact because they're often kind of

2112
01:41:33,040 --> 01:41:34,320
their own land

2113
01:41:34,320 --> 01:41:35,679
then finally and as far as we know this

2114
01:41:35,679 --> 01:41:37,600
doesn't exist at the intersection of

2115
01:41:37,600 --> 01:41:40,080
perfect fidelity full isolation and

2116
01:41:40,080 --> 01:41:42,719
absolute maximum cost is a hypothetical

2117
01:41:42,719 --> 01:41:44,159
data center that's just totally

2118
01:41:44,159 --> 01:41:46,320
dedicated to deception so imagine a

2119
01:41:46,320 --> 01:41:47,840
complete copy of a production data

2120
01:41:47,840 --> 01:41:49,920
center with identical monitoring and

2121
01:41:49,920 --> 01:41:52,400
maintenance like tons of like sres as

2122
01:41:52,400 --> 01:41:54,000
well as perfect simulation of real

2123
01:41:54,000 --> 01:41:56,000
traffic using an army of distributed

2124
01:41:56,000 --> 01:41:58,080
clients that is like hideously expensive

2125
01:41:58,080 --> 01:41:59,520
and i doubt anyone would do it outside

2126
01:41:59,520 --> 01:42:01,600
of maybe like nsa i don't know maybe

2127
01:42:01,600 --> 01:42:03,520
elon if he like keeps losing his mind

2128
01:42:03,520 --> 01:42:05,840
who knows but in any case if someone

2129
01:42:05,840 --> 01:42:07,280
built this it would provide like high

2130
01:42:07,280 --> 01:42:09,040
fidelity in full isolation but it would

2131
01:42:09,040 --> 01:42:10,480
cost like so much money it'd be

2132
01:42:10,480 --> 01:42:12,719
ridiculous

2133
01:42:12,719 --> 01:42:15,199
so we can also map all the other lamo

2134
01:42:15,199 --> 01:42:16,639
approaches from the infested community

2135
01:42:16,639 --> 01:42:18,320
we talked about specifically medium

2136
01:42:18,320 --> 01:42:20,320
interaction high interaction potty pots

2137
01:42:20,320 --> 01:42:22,320
the median interaction ones like it's

2138
01:42:22,320 --> 01:42:24,080
minimal supplemental fidelity over the

2139
01:42:24,080 --> 01:42:25,920
low interaction ones and they also cost

2140
01:42:25,920 --> 01:42:27,360
about the same they're basically in the

2141
01:42:27,360 --> 01:42:28,880
same place

2142
01:42:28,880 --> 01:42:30,560
high interaction honey pots do represent

2143
01:42:30,560 --> 01:42:32,719
like a minor increase in fidelity at

2144
01:42:32,719 --> 01:42:34,560
some additional cost but they're unable

2145
01:42:34,560 --> 01:42:36,480
to fool most attackers so they're like

2146
01:42:36,480 --> 01:42:38,960
clustered down here

2147
01:42:38,960 --> 01:42:41,440
but my friends there are previously

2148
01:42:41,440 --> 01:42:43,920
unexplored sweet spots for deception

2149
01:42:43,920 --> 01:42:45,760
mechanisms which you could probably see

2150
01:42:45,760 --> 01:42:47,199
there's like a huge gap in the middle

2151
01:42:47,199 --> 01:42:49,760
right so not much of a spoiler so

2152
01:42:49,760 --> 01:42:51,119
deception environments again are all

2153
01:42:51,119 --> 01:42:53,360
about supporting solutions in previously

2154
01:42:53,360 --> 01:42:55,199
unexplored areas of this trilemma which

2155
01:42:55,199 --> 01:42:57,280
the trilemma makes clear that they were

2156
01:42:57,280 --> 01:42:59,119
unexplored so there are two trilemma

2157
01:42:59,119 --> 01:43:00,880
sweet spots that we're going to cover

2158
01:43:00,880 --> 01:43:03,199
which provide mechanisms in uncovering a

2159
01:43:03,199 --> 01:43:05,199
richer and higher volume of attacker

2160
01:43:05,199 --> 01:43:09,519
behavior for advanced observability

2161
01:43:09,600 --> 01:43:11,440
uh so the first sweet spot are

2162
01:43:11,440 --> 01:43:13,920
replicomes so a replicom is a downgraded

2163
01:43:13,920 --> 01:43:16,159
replica of a production host that runs

2164
01:43:16,159 --> 01:43:18,400
with the same set of monitoring

2165
01:43:18,400 --> 01:43:20,880
orchestration and supporting services uh

2166
01:43:20,880 --> 01:43:22,080
that is deployed in a real prod

2167
01:43:22,080 --> 01:43:24,560
environment so this replica is fed with

2168
01:43:24,560 --> 01:43:27,360
simulated or replayed load from actual

2169
01:43:27,360 --> 01:43:28,560
systems

2170
01:43:28,560 --> 01:43:29,600
it's a functioning host with

2171
01:43:29,600 --> 01:43:31,280
production-like load that creates a

2172
01:43:31,280 --> 01:43:33,600
deception system that to an attacker

2173
01:43:33,600 --> 01:43:35,360
appears indistinguishable from a real

2174
01:43:35,360 --> 01:43:36,400
host

2175
01:43:36,400 --> 01:43:38,639
and you get this by feeding traffic into

2176
01:43:38,639 --> 01:43:39,280
it

2177
01:43:39,280 --> 01:43:42,320
so here we have some ungodly java

2178
01:43:42,320 --> 01:43:44,719
application running inside of jboss uh

2179
01:43:44,719 --> 01:43:46,480
we've downgraded one of the libraries

2180
01:43:46,480 --> 01:43:48,719
inside of it uh to a vulnerable version

2181
01:43:48,719 --> 01:43:51,760
maybe log4j if we're feeling extra lucky

2182
01:43:51,760 --> 01:43:54,480
um an added go replay to continuously

2183
01:43:54,480 --> 01:43:59,040
send simulated traffic to it uh so

2184
01:43:59,040 --> 01:44:01,040
this might look uh pretty similar to a

2185
01:44:01,040 --> 01:44:04,320
qa environment and it is um it might

2186
01:44:04,320 --> 01:44:06,320
even be the same traffic generation tool

2187
01:44:06,320 --> 01:44:08,480
that you might use for soap testing so

2188
01:44:08,480 --> 01:44:10,400
reusing and repurposing existing

2189
01:44:10,400 --> 01:44:13,679
practices is really important here

2190
01:44:13,679 --> 01:44:15,600
so infrastructure as code and other

2191
01:44:15,600 --> 01:44:17,119
modern practices make crafting

2192
01:44:17,119 --> 01:44:19,040
downgraded replicas easier just like

2193
01:44:19,040 --> 01:44:20,639
change the version number and boom you

2194
01:44:20,639 --> 01:44:21,600
go

2195
01:44:21,600 --> 01:44:23,199
and the plummeting cost of cloud

2196
01:44:23,199 --> 01:44:25,600
computing makes deployment of sizeable

2197
01:44:25,600 --> 01:44:27,679
systems inexpensive

2198
01:44:27,679 --> 01:44:30,080
while still higher cost than a honeypot

2199
01:44:30,080 --> 01:44:32,239
replicom all offers palpable

2200
01:44:32,239 --> 01:44:34,239
enhancements so it has impressive

2201
01:44:34,239 --> 01:44:36,159
fidelity and supports inspecting an

2202
01:44:36,159 --> 01:44:38,639
expansive range of attacker behavior

2203
01:44:38,639 --> 01:44:40,400
beyond initial access what do they do

2204
01:44:40,400 --> 01:44:42,480
once they're actually on the system and

2205
01:44:42,480 --> 01:44:44,000
playing around and trying to achieve

2206
01:44:44,000 --> 01:44:45,199
their goals

2207
01:44:45,199 --> 01:44:47,360
so as a result the replicom offers

2208
01:44:47,360 --> 01:44:49,679
occupies a space on the tremolo that's

2209
01:44:49,679 --> 01:44:52,239
closer to that full data center replica

2210
01:44:52,239 --> 01:44:53,119
that is

2211
01:44:53,119 --> 01:44:55,199
just massively expensive and is a big

2212
01:44:55,199 --> 01:44:58,000
money fire uh but it's about as much

2213
01:44:58,000 --> 01:45:00,480
effort as a high interactive

2214
01:45:00,480 --> 01:45:02,639
interactivity honeypot um the effort is

2215
01:45:02,639 --> 01:45:05,040
just placed in a little different place

2216
01:45:05,040 --> 01:45:07,280
so we think this is a sweet spot because

2217
01:45:07,280 --> 01:45:09,920
it should appear to be a real individual

2218
01:45:09,920 --> 01:45:12,320
production host to a cautious skeptical

2219
01:45:12,320 --> 01:45:15,360
attacker if done correctly

2220
01:45:15,360 --> 01:45:16,560
so the next

2221
01:45:16,560 --> 01:45:18,880
sweet spot is honey hives which you can

2222
01:45:18,880 --> 01:45:21,520
see right there

2223
01:45:22,239 --> 01:45:25,280
honey hives extend replicomes with a

2224
01:45:25,280 --> 01:45:27,679
full network of like production hosts to

2225
01:45:27,679 --> 01:45:29,840
observe how attackers move from their

2226
01:45:29,840 --> 01:45:31,920
initial point of access onto adjacent

2227
01:45:31,920 --> 01:45:34,000
hosts and services yep like lateral

2228
01:45:34,000 --> 01:45:36,239
movement basically yeah

2229
01:45:36,239 --> 01:45:38,560
complete scaled-down copies of the

2230
01:45:38,560 --> 01:45:41,040
entire environment are deployed as a

2231
01:45:41,040 --> 01:45:43,679
honey hive with simulated replayed or

2232
01:45:43,679 --> 01:45:45,920
mirrored activity flowing through the

2233
01:45:45,920 --> 01:45:47,280
entire system

2234
01:45:47,280 --> 01:45:49,119
and a honey hive yields a thoroughly

2235
01:45:49,119 --> 01:45:51,040
lifelike environment for observing and

2236
01:45:51,040 --> 01:45:53,520
conducting experiments on attackers even

2237
01:45:53,520 --> 01:45:56,159
as they move from host to host

2238
01:45:56,159 --> 01:45:57,280
so

2239
01:45:57,280 --> 01:46:00,719
on the left here we have an example

2240
01:46:00,719 --> 01:46:03,840
architecture diagram of some service you

2241
01:46:03,840 --> 01:46:05,199
know running a load balancer an

2242
01:46:05,199 --> 01:46:07,840
application server database file storage

2243
01:46:07,840 --> 01:46:09,119
just

2244
01:46:09,119 --> 01:46:11,600
grand just bunch of stuff right

2245
01:46:11,600 --> 01:46:13,040
and it's running behind a content

2246
01:46:13,040 --> 01:46:15,360
distribution network on the right we've

2247
01:46:15,360 --> 01:46:17,920
got almost the same we swapped the cdn

2248
01:46:17,920 --> 01:46:20,080
out for a load generator simulating real

2249
01:46:20,080 --> 01:46:22,239
traffic but the rest of the environment

2250
01:46:22,239 --> 01:46:24,159
is the same it's a little smaller but

2251
01:46:24,159 --> 01:46:24,880
like

2252
01:46:24,880 --> 01:46:27,520
it's it's the same yeah

2253
01:46:27,520 --> 01:46:30,000
so we

