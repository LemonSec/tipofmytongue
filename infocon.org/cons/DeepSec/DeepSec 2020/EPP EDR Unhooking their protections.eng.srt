1
00:00:03,679 --> 00:00:04,160
okay

2
00:00:04,160 --> 00:00:07,120
uh hello everyone welcome to the

3
00:00:07,120 --> 00:00:09,519
presentation epp edr unhooking the

4
00:00:09,519 --> 00:00:13,920
protections my name is daniel and i work

5
00:00:13,920 --> 00:00:15,679
as an ethical hacker at the company

6
00:00:15,679 --> 00:00:16,480
strong i.t

7
00:00:16,480 --> 00:00:20,080
in innsbruck here in austria and we are

8
00:00:20,080 --> 00:00:22,320
a small but very fine team

9
00:00:22,320 --> 00:00:24,320
with about four team members with

10
00:00:24,320 --> 00:00:26,800
different focuses on blue and red

11
00:00:26,800 --> 00:00:28,080
teaming

12
00:00:28,080 --> 00:00:30,480
and our company was founded about 10

13
00:00:30,480 --> 00:00:31,119
years ago

14
00:00:31,119 --> 00:00:33,920
by david winkler which is one of the

15
00:00:33,920 --> 00:00:36,559
pioneers here in austria

16
00:00:36,559 --> 00:00:40,160
in the area of cyber security so

17
00:00:40,160 --> 00:00:42,960
i want to say many thanks to david and

18
00:00:42,960 --> 00:00:45,120
also to my colleague robert

19
00:00:45,120 --> 00:00:48,879
for supporting me because without

20
00:00:48,879 --> 00:00:50,800
their support it wouldn't be possible to

21
00:00:50,800 --> 00:00:53,839
speak here right now

22
00:00:54,239 --> 00:00:56,320
my currently focus is on learning about

23
00:00:56,320 --> 00:00:57,520
red teaming under the windows

24
00:00:57,520 --> 00:00:59,359
environment

25
00:00:59,359 --> 00:01:02,480
so for that i do a lot of studying

26
00:01:02,480 --> 00:01:03,760
in the last few months the windows

27
00:01:03,760 --> 00:01:05,760
internals

28
00:01:05,760 --> 00:01:07,600
in my opinion the windows internals are

29
00:01:07,600 --> 00:01:08,880
a great resource

30
00:01:08,880 --> 00:01:10,840
no matter if you are a blue or a red

31
00:01:10,840 --> 00:01:12,080
teamer and

32
00:01:12,080 --> 00:01:13,920
also that knowledge from the internals

33
00:01:13,920 --> 00:01:15,200
helped me a lot about to

34
00:01:15,200 --> 00:01:19,200
understand which mechanisms

35
00:01:19,200 --> 00:01:22,560
could edr systems use under the windows

36
00:01:22,560 --> 00:01:26,240
west system and that is also

37
00:01:26,240 --> 00:01:30,479
the main topic we will speak about today

38
00:01:32,079 --> 00:01:34,479
so we take a look at two different spec

39
00:01:34,479 --> 00:01:37,040
mechanisms which can be used from edrs

40
00:01:37,040 --> 00:01:38,320
under windows

41
00:01:38,320 --> 00:01:41,280
the first one is user mode api hooking

42
00:01:41,280 --> 00:01:42,399
and the second one

43
00:01:42,399 --> 00:01:45,920
are kernel callback functions

44
00:01:45,920 --> 00:01:48,640
but before we can speak about that we

45
00:01:48,640 --> 00:01:49,920
have to

46
00:01:49,920 --> 00:01:52,240
clarify some basics so we speak shortly

47
00:01:52,240 --> 00:01:53,520
about what the

48
00:01:53,520 --> 00:01:55,680
main difference between a epp and an edr

49
00:01:55,680 --> 00:01:57,040
system

50
00:01:57,040 --> 00:02:00,320
and what do we understand uh

51
00:02:00,320 --> 00:02:02,399
under the bus world behavior-based

52
00:02:02,399 --> 00:02:03,920
detection

53
00:02:03,920 --> 00:02:05,520
and also we need a little bit to know

54
00:02:05,520 --> 00:02:07,759
about the windows architecture

55
00:02:07,759 --> 00:02:10,318
to better understand uh what is user

56
00:02:10,318 --> 00:02:13,359
mode api hooking

57
00:02:16,000 --> 00:02:18,080
so from the red team perspective for

58
00:02:18,080 --> 00:02:19,760
that presentation we have the goal to

59
00:02:19,760 --> 00:02:20,400
understand

60
00:02:20,400 --> 00:02:23,040
api hooking and kernel callbacks because

61
00:02:23,040 --> 00:02:24,319
when we understand it

62
00:02:24,319 --> 00:02:27,840
we can try to bypass it and

63
00:02:27,840 --> 00:02:32,000
in that presentation we want to bypass

64
00:02:32,000 --> 00:02:34,879
api hooking and callbacks because we

65
00:02:34,879 --> 00:02:36,400
want to dump uh

66
00:02:36,400 --> 00:02:38,720
credentials from the elsa's process

67
00:02:38,720 --> 00:02:39,440
without

68
00:02:39,440 --> 00:02:42,720
creating any alert in the edr system

69
00:02:42,720 --> 00:02:45,599
and we will see that also very tough edr

70
00:02:45,599 --> 00:02:46,879
systems

71
00:02:46,879 --> 00:02:49,120
have to play with the rule on the

72
00:02:49,120 --> 00:02:51,040
windows and so they also

73
00:02:51,040 --> 00:02:53,920
they have certain limits um in the

74
00:02:53,920 --> 00:02:56,080
windows environment

75
00:02:56,080 --> 00:02:58,400
and at the end of the presentation we

76
00:02:58,400 --> 00:02:59,680
will have a short look

77
00:02:59,680 --> 00:03:02,800
from the blue team perspective uh what

78
00:03:02,800 --> 00:03:04,319
can we do about idyapai

79
00:03:04,319 --> 00:03:07,440
passing in the context of credential

80
00:03:07,440 --> 00:03:08,000
dumping

81
00:03:08,000 --> 00:03:11,280
the elsa's memory

82
00:03:12,560 --> 00:03:14,400
so what's the main difference between

83
00:03:14,400 --> 00:03:16,159
ebp and edr

84
00:03:16,159 --> 00:03:19,760
very simple app has the main task to

85
00:03:19,760 --> 00:03:22,560
prevent the execution of malicious files

86
00:03:22,560 --> 00:03:23,599
before they can

87
00:03:23,599 --> 00:03:26,879
get executed by a user for that atp

88
00:03:26,879 --> 00:03:29,200
use different mechanisms like static

89
00:03:29,200 --> 00:03:33,040
dynamic or in-memory analysis

90
00:03:33,040 --> 00:03:34,959
but the problem with that is that sooner

91
00:03:34,959 --> 00:03:36,239
or later an

92
00:03:36,239 --> 00:03:39,040
attacker will find a way to bypass an

93
00:03:39,040 --> 00:03:39,840
epp

94
00:03:39,840 --> 00:03:43,360
so our test cases and practices show

95
00:03:43,360 --> 00:03:46,319
that there's currently no epp which

96
00:03:46,319 --> 00:03:48,000
couldn't be bypassed

97
00:03:48,000 --> 00:03:50,799
by for example by a trojan to get the

98
00:03:50,799 --> 00:03:53,040
command and control channel

99
00:03:53,040 --> 00:03:57,120
and after the first compromise

100
00:03:57,120 --> 00:04:00,560
with an epp alone you have

101
00:04:00,560 --> 00:04:02,879
very pervisibility on the endpoint so it

102
00:04:02,879 --> 00:04:04,640
it's very hard to find out

103
00:04:04,640 --> 00:04:07,360
what maybe had the hacker also done

104
00:04:07,360 --> 00:04:07,920
after

105
00:04:07,920 --> 00:04:11,280
compromising the first endpoint so

106
00:04:11,280 --> 00:04:15,840
not really a good visibility

107
00:04:15,920 --> 00:04:19,199
compared to that the edr a pure edr

108
00:04:19,199 --> 00:04:22,400
has the task to detect malware not to

109
00:04:22,400 --> 00:04:23,840
prevent

110
00:04:23,840 --> 00:04:28,960
so for example the edr also tries not to

111
00:04:28,960 --> 00:04:32,720
only detect malicious signatures

112
00:04:32,720 --> 00:04:35,360
ddr also tries for example by api

113
00:04:35,360 --> 00:04:36,320
hooking

114
00:04:36,320 --> 00:04:38,240
to get your response about malicious

115
00:04:38,240 --> 00:04:40,160
behavior on an endpoint

116
00:04:40,160 --> 00:04:42,800
and also you have the possibility uh

117
00:04:42,800 --> 00:04:43,680
with an edr

118
00:04:43,680 --> 00:04:45,360
by the collector telemetry on the

119
00:04:45,360 --> 00:04:47,120
endpoint to

120
00:04:47,120 --> 00:04:49,120
front half to fret hunt for malicious

121
00:04:49,120 --> 00:04:51,840
behavior also when there was no previous

122
00:04:51,840 --> 00:04:52,479
alert

123
00:04:52,479 --> 00:04:56,000
uh because you have centralized lock and

124
00:04:56,000 --> 00:04:58,320
so it's possible also when you just have

125
00:04:58,320 --> 00:04:59,759
when the fret hunter just have the

126
00:04:59,759 --> 00:05:00,639
theory about

127
00:05:00,639 --> 00:05:03,840
a possible compromise on endpoint uh he

128
00:05:03,840 --> 00:05:04,880
can search for that

129
00:05:04,880 --> 00:05:09,120
because idios compared to epp

130
00:05:09,120 --> 00:05:12,639
have a very high process or high

131
00:05:12,639 --> 00:05:15,600
end point visibility in practices for

132
00:05:15,600 --> 00:05:17,120
sure you will see

133
00:05:17,120 --> 00:05:20,000
always combination between epp and edr

134
00:05:20,000 --> 00:05:21,039
because you

135
00:05:21,039 --> 00:05:24,080
need the prevention but more it's

136
00:05:24,080 --> 00:05:26,400
you also need the visibility on the

137
00:05:26,400 --> 00:05:27,199
endpoint

138
00:05:27,199 --> 00:05:31,199
by an edr system and

139
00:05:31,199 --> 00:05:33,039
also when i speak in that presentation

140
00:05:33,039 --> 00:05:36,400
about edrs i always refer me to

141
00:05:36,400 --> 00:05:41,039
the combination of an epp and then edr

142
00:05:41,440 --> 00:05:44,320
so while learning about edrs we see in

143
00:05:44,320 --> 00:05:45,360
our pants that

144
00:05:45,360 --> 00:05:47,840
more and more customers are using edr

145
00:05:47,840 --> 00:05:49,759
systems

146
00:05:49,759 --> 00:05:52,639
that is a good thing from the blue team

147
00:05:52,639 --> 00:05:54,560
perspective because

148
00:05:54,560 --> 00:05:57,520
uh for sure we will reach that our

149
00:05:57,520 --> 00:06:00,800
customers get better in i.t security

150
00:06:00,800 --> 00:06:02,639
but also from the red team perspective

151
00:06:02,639 --> 00:06:04,000
we have to critically ask

152
00:06:04,000 --> 00:06:07,840
ourselves our edrs

153
00:06:07,840 --> 00:06:11,759
really do behavior based detection or

154
00:06:11,759 --> 00:06:12,319
there are

155
00:06:12,319 --> 00:06:15,199
also still a lot of cases uh where they

156
00:06:15,199 --> 00:06:16,960
just use signatures to

157
00:06:16,960 --> 00:06:20,000
to detect malicious files or malicious

158
00:06:20,000 --> 00:06:23,120
behavior but

159
00:06:23,120 --> 00:06:25,360
it just definitely raised the bar we saw

160
00:06:25,360 --> 00:06:28,880
it in pentest about five months ago

161
00:06:28,880 --> 00:06:30,400
that we have to deal with a very

162
00:06:30,400 --> 00:06:33,120
interesting edr system

163
00:06:33,120 --> 00:06:35,919
so it was very simple to to get a

164
00:06:35,919 --> 00:06:37,840
foothold on the system

165
00:06:37,840 --> 00:06:39,759
but compared to that the post

166
00:06:39,759 --> 00:06:41,919
exploitation was really hard because

167
00:06:41,919 --> 00:06:43,600
we have to get rid of that foothold

168
00:06:43,600 --> 00:06:45,919
process and inject

169
00:06:45,919 --> 00:06:49,039
into a more legitimate process but

170
00:06:49,039 --> 00:06:52,160
uh no matter if we try to inject into

171
00:06:52,160 --> 00:06:53,039
another process

172
00:06:53,039 --> 00:06:56,080
or later on to dump the

173
00:06:56,080 --> 00:06:57,840
memory address space from the alphas

174
00:06:57,840 --> 00:07:00,800
process we always get detected by ddr

175
00:07:00,800 --> 00:07:02,000
system and so

176
00:07:02,000 --> 00:07:05,120
it was very hard and we have to deal and

177
00:07:05,120 --> 00:07:07,120
dig deeper into

178
00:07:07,120 --> 00:07:10,639
why edrs why does ddr detect

179
00:07:10,639 --> 00:07:15,199
us and so we have to deal

180
00:07:15,199 --> 00:07:18,240
for example with user mode api hooking

181
00:07:18,240 --> 00:07:22,479
so user mode api hooking is a technique

182
00:07:22,479 --> 00:07:24,720
where we which we will see later on what

183
00:07:24,720 --> 00:07:26,160
it does exactly but

184
00:07:26,160 --> 00:07:28,960
for example by api hooking the edr has

185
00:07:28,960 --> 00:07:30,720
the policy possibility

186
00:07:30,720 --> 00:07:33,919
to check process accesses so

187
00:07:33,919 --> 00:07:38,080
edrs are not just signature pay do

188
00:07:38,080 --> 00:07:42,720
just signal to base detection but

189
00:07:42,720 --> 00:07:44,560
in the case when we have uh

190
00:07:44,560 --> 00:07:46,160
behavior-based detection like

191
00:07:46,160 --> 00:07:48,319
in for example when we try to dump the

192
00:07:48,319 --> 00:07:49,680
elsa's memory

193
00:07:49,680 --> 00:07:51,440
we also want to know what can we do

194
00:07:51,440 --> 00:07:53,919
about it and so we are forced to

195
00:07:53,919 --> 00:07:56,400
uh deal with api hooking and later on

196
00:07:56,400 --> 00:07:57,199
also with

197
00:07:57,199 --> 00:08:02,319
callbacks so our motivation was to see

198
00:08:02,479 --> 00:08:04,080
how long would it be possible to stay

199
00:08:04,080 --> 00:08:05,520
under the radar

200
00:08:05,520 --> 00:08:08,720
when we bypassed that techniques and

201
00:08:08,720 --> 00:08:12,240
also we created an

202
00:08:12,240 --> 00:08:14,479
own technical evaluation process based

203
00:08:14,479 --> 00:08:16,639
on the mitra tech framework

204
00:08:16,639 --> 00:08:19,599
for our customers when they are choosing

205
00:08:19,599 --> 00:08:20,879
an edr system

206
00:08:20,879 --> 00:08:26,000
or evaluating an adr system

207
00:08:26,000 --> 00:08:29,199
so what's all about that buzzword

208
00:08:29,199 --> 00:08:31,199
behavior-based detection in context of

209
00:08:31,199 --> 00:08:32,479
edrs

210
00:08:32,479 --> 00:08:34,159
behavior-based detection for example

211
00:08:34,159 --> 00:08:36,640
could be when the edr detects that an

212
00:08:36,640 --> 00:08:38,000
unauthorized process

213
00:08:38,000 --> 00:08:41,760
injects code into another process so

214
00:08:41,760 --> 00:08:44,640
in that example we see that we clearly

215
00:08:44,640 --> 00:08:46,720
get blocked by the edr system

216
00:08:46,720 --> 00:08:49,279
ddr detects malicious behavior on the

217
00:08:49,279 --> 00:08:51,120
endpoint because we

218
00:08:51,120 --> 00:08:53,360
try to break demonseration by process

219
00:08:53,360 --> 00:08:55,440
injection

220
00:08:55,440 --> 00:08:58,480
so we ask ourselves is it really the

221
00:08:58,480 --> 00:09:00,000
idea does it really

222
00:09:00,000 --> 00:09:02,720
detect malicious behavior or do we have

223
00:09:02,720 --> 00:09:04,640
chance to get rid of the signatures

224
00:09:04,640 --> 00:09:08,000
in our payload

225
00:09:08,000 --> 00:09:11,120
so uh we used a very uh nice tool from

226
00:09:11,120 --> 00:09:12,240
daniel buhaynon

227
00:09:12,240 --> 00:09:15,519
which is called invoke obfuscation and

228
00:09:15,519 --> 00:09:17,839
obfuscate our power shell payload very

229
00:09:17,839 --> 00:09:19,519
heavily

230
00:09:19,519 --> 00:09:22,320
and that was very interesting because

231
00:09:22,320 --> 00:09:23,760
after

232
00:09:23,760 --> 00:09:26,959
after that we executed our payload again

233
00:09:26,959 --> 00:09:29,920
and we there was no further detection by

234
00:09:29,920 --> 00:09:31,839
the edr system

235
00:09:31,839 --> 00:09:35,279
so um detect the

236
00:09:35,279 --> 00:09:38,000
detection before wasn't really behavior

237
00:09:38,000 --> 00:09:39,120
based

238
00:09:39,120 --> 00:09:41,200
uh because we have just to get rid of

239
00:09:41,200 --> 00:09:42,560
the signatures

240
00:09:42,560 --> 00:09:45,600
and we're still able to do our process

241
00:09:45,600 --> 00:09:48,000
injection

242
00:09:48,640 --> 00:09:50,959
also in that case we try to get

243
00:09:50,959 --> 00:09:53,839
persistent by a scheduled desktop

244
00:09:53,839 --> 00:09:55,839
uh in the first run we go to access the

245
00:09:55,839 --> 00:09:59,279
knight from the edr system

246
00:10:00,320 --> 00:10:02,959
and again in the lower picture you see

247
00:10:02,959 --> 00:10:05,279
that there is a little bit different

248
00:10:05,279 --> 00:10:08,320
obfuscation and

249
00:10:08,320 --> 00:10:10,720
after that we were able to successfully

250
00:10:10,720 --> 00:10:12,880
create our

251
00:10:12,880 --> 00:10:16,320
schedule desktop so again

252
00:10:16,320 --> 00:10:17,839
we have just to get rid of the

253
00:10:17,839 --> 00:10:19,760
signatures in our

254
00:10:19,760 --> 00:10:22,160
command

255
00:10:23,839 --> 00:10:26,959
also very interesting we

256
00:10:26,959 --> 00:10:29,360
intentionally used the pre-compiled

257
00:10:29,360 --> 00:10:31,200
version from rubios

258
00:10:31,200 --> 00:10:35,600
and started the cabarrus attack and

259
00:10:35,600 --> 00:10:39,279
we see that we got detected by the edr

260
00:10:39,279 --> 00:10:43,440
and very simple i just renamed the

261
00:10:43,440 --> 00:10:46,959
file from rubios to pari.dxe

262
00:10:46,959 --> 00:10:49,440
and we were not longer detected by the

263
00:10:49,440 --> 00:10:50,480
edr system

264
00:10:50,480 --> 00:10:54,240
and can successfully

265
00:10:54,240 --> 00:10:57,680
create our kerberos attack

266
00:10:58,720 --> 00:11:02,959
so we saw some cases where the edr

267
00:11:02,959 --> 00:11:06,000
maybe tells us it detects malicious

268
00:11:06,000 --> 00:11:07,279
behavior but

269
00:11:07,279 --> 00:11:10,399
we saw there was

270
00:11:10,399 --> 00:11:12,160
there was just signatures we have to get

271
00:11:12,160 --> 00:11:13,600
rid of in our

272
00:11:13,600 --> 00:11:16,880
commands or payloads but

273
00:11:16,880 --> 00:11:19,040
depending on the dr system for example

274
00:11:19,040 --> 00:11:20,640
in the case of credential dumping the

275
00:11:20,640 --> 00:11:23,360
elsos process

276
00:11:23,360 --> 00:11:26,560
it could be a little bit harder because

277
00:11:26,560 --> 00:11:28,079
they're not just

278
00:11:28,079 --> 00:11:30,560
going on signatures for example in mimi

279
00:11:30,560 --> 00:11:32,480
cuts or in other credential dumping

280
00:11:32,480 --> 00:11:33,440
tools

281
00:11:33,440 --> 00:11:35,440
they also check for example which

282
00:11:35,440 --> 00:11:37,680
process tries to access

283
00:11:37,680 --> 00:11:42,000
the address space of the ss process

284
00:11:42,000 --> 00:11:45,600
and so um we currently

285
00:11:45,600 --> 00:11:49,279
uh had no had no way to

286
00:11:49,279 --> 00:11:52,639
to to dump the elsa's process without

287
00:11:52,639 --> 00:11:57,120
creating an alert in the adr system

288
00:11:57,120 --> 00:11:58,639
so we ask ourselves what could be the

289
00:11:58,639 --> 00:12:00,480
reason for that

290
00:12:00,480 --> 00:12:03,920
one reason can be that the api

291
00:12:03,920 --> 00:12:07,519
at the adr system use api hooking

292
00:12:07,519 --> 00:12:09,680
so by api hooking it can check the

293
00:12:09,680 --> 00:12:12,320
process accesses and also can check

294
00:12:12,320 --> 00:12:14,320
for example which process tries to

295
00:12:14,320 --> 00:12:15,760
inject code into the

296
00:12:15,760 --> 00:12:18,800
address space of the esos process and

297
00:12:18,800 --> 00:12:21,519
that's also that the process visibility

298
00:12:21,519 --> 00:12:25,839
which i had speak before about

299
00:12:27,040 --> 00:12:29,680
so just getting rid of the signatures in

300
00:12:29,680 --> 00:12:30,720
our tools

301
00:12:30,720 --> 00:12:34,800
isn't enough so we also have

302
00:12:34,800 --> 00:12:39,040
to think about what can we do uh

303
00:12:39,040 --> 00:12:41,200
when we get rid of the signatures but

304
00:12:41,200 --> 00:12:42,079
also get

305
00:12:42,079 --> 00:12:43,680
but still get detected by malicious

306
00:12:43,680 --> 00:12:46,160
behavior

307
00:12:47,360 --> 00:12:49,600
so we have to deal with user mode api

308
00:12:49,600 --> 00:12:50,560
hooking

309
00:12:50,560 --> 00:12:53,440
and before we clarify some basics in the

310
00:12:53,440 --> 00:12:54,240
windows os

311
00:12:54,240 --> 00:12:56,000
architecture to better understand one is

312
00:12:56,000 --> 00:12:58,160
api hooking

313
00:12:58,160 --> 00:13:00,560
so since windows nt 3.1 windows is

314
00:13:00,560 --> 00:13:02,320
separated into user mode into

315
00:13:02,320 --> 00:13:05,519
kernel mode very easy

316
00:13:05,519 --> 00:13:07,600
or easy said in the user mode they are

317
00:13:07,600 --> 00:13:08,560
running our all

318
00:13:08,560 --> 00:13:11,440
user applications like word excel chrome

319
00:13:11,440 --> 00:13:13,440
etc what else

320
00:13:13,440 --> 00:13:15,760
and in the kernel mode are all critical

321
00:13:15,760 --> 00:13:17,440
system applications like

322
00:13:17,440 --> 00:13:21,120
the file system or the device drivers

323
00:13:21,120 --> 00:13:24,240
and by default there is no way to

324
00:13:24,240 --> 00:13:26,560
directly execute code from

325
00:13:26,560 --> 00:13:28,639
the user mode into the kernel mode

326
00:13:28,639 --> 00:13:30,639
because of that address

327
00:13:30,639 --> 00:13:33,279
because of that memory separation on

328
00:13:33,279 --> 00:13:35,839
processor level

329
00:13:37,920 --> 00:13:40,720
very important to understand before we

330
00:13:40,720 --> 00:13:41,360
go on

331
00:13:41,360 --> 00:13:43,920
is that the ntdl in user mode builds the

332
00:13:43,920 --> 00:13:44,880
lowest common

333
00:13:44,880 --> 00:13:48,480
common denominator in user mode before

334
00:13:48,480 --> 00:13:52,240
there is a way to access the kernel

335
00:13:52,560 --> 00:13:54,399
but still of that separation there has

336
00:13:54,399 --> 00:13:56,399
to be a way to get a transition from

337
00:13:56,399 --> 00:13:58,480
user mode to kernel mode

338
00:13:58,480 --> 00:14:02,000
and this is done by the play together

339
00:14:02,000 --> 00:14:05,440
from windows apis native apis

340
00:14:05,440 --> 00:14:08,000
and system calls in user mode so when

341
00:14:08,000 --> 00:14:08,880
application

342
00:14:08,880 --> 00:14:12,880
tries to access the kernel

343
00:14:12,880 --> 00:14:16,160
it can use the windows apis to call the

344
00:14:16,160 --> 00:14:19,680
associated native api and the native api

345
00:14:19,680 --> 00:14:23,360
includes a system call which initiate

346
00:14:23,360 --> 00:14:28,160
that transition from user mode to kernel

347
00:14:28,839 --> 00:14:30,000
mode

348
00:14:30,000 --> 00:14:31,839
have a look on an example where for

349
00:14:31,839 --> 00:14:33,279
example when you write some code in

350
00:14:33,279 --> 00:14:33,920
notepad

351
00:14:33,920 --> 00:14:37,360
and you to will save your your document

352
00:14:37,360 --> 00:14:39,279
notepad needs needs for the saving

353
00:14:39,279 --> 00:14:42,160
process access to the file system

354
00:14:42,160 --> 00:14:44,480
and to the device drivers and as we

355
00:14:44,480 --> 00:14:45,519
learned before

356
00:14:45,519 --> 00:14:48,079
both of that are running in kernel

357
00:14:48,079 --> 00:14:50,800
length in kernel mode

358
00:14:50,800 --> 00:14:52,959
so what happens when we click on the

359
00:14:52,959 --> 00:14:55,279
save button in notepad

360
00:14:55,279 --> 00:14:58,720
notepad calls windows api which is

361
00:14:58,720 --> 00:14:59,120
called

362
00:14:59,120 --> 00:15:03,199
create file w from the kernel 32 dll

363
00:15:03,199 --> 00:15:05,920
and by that dll it calls the associated

364
00:15:05,920 --> 00:15:07,040
native api

365
00:15:07,040 --> 00:15:10,240
anti-create file in the anti-dll as we

366
00:15:10,240 --> 00:15:11,199
learned before

367
00:15:11,199 --> 00:15:13,279
the entity dll builds the lowest common

368
00:15:13,279 --> 00:15:14,639
in dominator

369
00:15:14,639 --> 00:15:17,040
in user mode before access is accessing

370
00:15:17,040 --> 00:15:18,480
kernel land

371
00:15:18,480 --> 00:15:20,880
and in the native api there is a system

372
00:15:20,880 --> 00:15:22,560
call with a specific number

373
00:15:22,560 --> 00:15:24,959
and but i just by that system call we

374
00:15:24,959 --> 00:15:26,320
get the transition

375
00:15:26,320 --> 00:15:29,279
from user mode ring three to kernel mode

376
00:15:29,279 --> 00:15:31,600
ring zero

377
00:15:31,600 --> 00:15:35,920
but still the kernel needs to know which

378
00:15:35,920 --> 00:15:39,360
native api should be executed so

379
00:15:39,360 --> 00:15:41,199
the kernel can use the system service

380
00:15:41,199 --> 00:15:43,360
this page table and the syscall number

381
00:15:43,360 --> 00:15:45,279
to check

382
00:15:45,279 --> 00:15:49,440
which native api should be executed

383
00:15:49,440 --> 00:15:53,279
by the kernel therefore you see

384
00:15:53,279 --> 00:15:55,040
in that case it calls the anti-create

385
00:15:55,040 --> 00:15:57,759
file from the ntos kernel.xc

386
00:15:57,759 --> 00:16:00,800
also often you see

387
00:16:00,800 --> 00:16:03,279
instead of nt you see the kernel version

388
00:16:03,279 --> 00:16:04,000
nativifi

389
00:16:04,000 --> 00:16:09,839
api which is called set w

390
00:16:11,920 --> 00:16:16,160
so what's now about eds and api hooking

391
00:16:16,160 --> 00:16:19,600
ebr api hooking you can imagine like

392
00:16:19,600 --> 00:16:22,880
a proxy on process lab which means that

393
00:16:22,880 --> 00:16:23,759
the edrs

394
00:16:23,759 --> 00:16:26,720
use api hooking in different ways for

395
00:16:26,720 --> 00:16:28,079
example

396
00:16:28,079 --> 00:16:30,800
with inline api hooking to set a jump

397
00:16:30,800 --> 00:16:31,680
instruction

398
00:16:31,680 --> 00:16:34,720
in the anti-dll in the native api of

399
00:16:34,720 --> 00:16:37,680
in the ntdl and redirect the code to the

400
00:16:37,680 --> 00:16:38,959
edr

401
00:16:38,959 --> 00:16:42,240
so by that redirection from the executed

402
00:16:42,240 --> 00:16:43,680
code in a

403
00:16:43,680 --> 00:16:46,800
context of a specific native api

404
00:16:46,800 --> 00:16:50,399
the edr can analyze

405
00:16:50,399 --> 00:16:52,160
the process or the code which get

406
00:16:52,160 --> 00:16:54,240
executed in the context of that native

407
00:16:54,240 --> 00:16:56,639
api

408
00:16:57,040 --> 00:17:00,720
and in our test cases with different edr

409
00:17:00,720 --> 00:17:01,680
products we

410
00:17:01,680 --> 00:17:04,799
saw that edrs

411
00:17:04,799 --> 00:17:08,240
uh always use or in that product product

412
00:17:08,240 --> 00:17:11,439
use inline api hooking and inlet api

413
00:17:11,439 --> 00:17:12,480
hooking is

414
00:17:12,480 --> 00:17:16,000
as i said realized by a jump instruction

415
00:17:16,000 --> 00:17:19,520
in specific native apis in the entity l

416
00:17:19,520 --> 00:17:24,240
why in the ntdl because the ntdl

417
00:17:24,240 --> 00:17:27,119
built is the last last executed code

418
00:17:27,119 --> 00:17:33,200
before accessing kernel land

419
00:17:33,200 --> 00:17:35,440
so what are indicators for api hooking

420
00:17:35,440 --> 00:17:37,039
when you have an endpoint with installed

421
00:17:37,039 --> 00:17:37,840
edr

422
00:17:37,840 --> 00:17:40,480
you simply can use the process explorer

423
00:17:40,480 --> 00:17:42,720
and

424
00:17:43,120 --> 00:17:46,080
check the loaded dlls by a process in

425
00:17:46,080 --> 00:17:48,480
that case by the command gel

426
00:17:48,480 --> 00:17:52,400
and maybe you will find injected dll by

427
00:17:52,400 --> 00:17:55,440
the edr system

428
00:17:56,799 --> 00:18:00,000
you can check it a little bit more in

429
00:18:00,000 --> 00:18:01,039
detail

430
00:18:01,039 --> 00:18:03,600
when you install for example windy gb on

431
00:18:03,600 --> 00:18:04,799
your

432
00:18:04,799 --> 00:18:08,000
endpoint with install edr and use the

433
00:18:08,000 --> 00:18:09,919
command x to examine

434
00:18:09,919 --> 00:18:12,880
uh a specific idea specific native api

435
00:18:12,880 --> 00:18:15,520
for example anti-map view of section

436
00:18:15,520 --> 00:18:18,720
then you get the address of

437
00:18:18,720 --> 00:18:22,000
that native api in the

438
00:18:22,000 --> 00:18:24,640
in that process in the address space of

439
00:18:24,640 --> 00:18:25,919
that process

440
00:18:25,919 --> 00:18:27,600
and you can disassemble the address to

441
00:18:27,600 --> 00:18:29,919
get the assembly instructions from the

442
00:18:29,919 --> 00:18:31,280
native api

443
00:18:31,280 --> 00:18:34,080
and we see with installed edr we have

444
00:18:34,080 --> 00:18:36,080
clearly a jump instruction in the second

445
00:18:36,080 --> 00:18:37,840
line which could be an indicator

446
00:18:37,840 --> 00:18:40,840
that the code gets redirected to the edr

447
00:18:40,840 --> 00:18:42,320
system

448
00:18:42,320 --> 00:18:45,440
compared to an endpoint without ddr we

449
00:18:45,440 --> 00:18:46,080
see

450
00:18:46,080 --> 00:18:49,520
uh in the second line in the same native

451
00:18:49,520 --> 00:18:50,480
api

452
00:18:50,480 --> 00:18:52,160
that there is no jump instruction

453
00:18:52,160 --> 00:18:53,520
instead of that we have a move

454
00:18:53,520 --> 00:18:54,799
instruction

455
00:18:54,799 --> 00:18:57,440
and that move instruction moves the

456
00:18:57,440 --> 00:18:58,240
syscall

457
00:18:58,240 --> 00:19:01,360
that we see the cisco number to a hex

458
00:19:01,360 --> 00:19:04,400
into the ea x register and the the

459
00:19:04,400 --> 00:19:06,960
syscall can be directly executed

460
00:19:06,960 --> 00:19:09,120
compared to the upper picture before the

461
00:19:09,120 --> 00:19:10,640
cisco can be executed

462
00:19:10,640 --> 00:19:14,480
it gets redirected maybe to the edr

463
00:19:14,480 --> 00:19:17,520
so a jump instruction isn't really

464
00:19:17,520 --> 00:19:23,120
a clear sign that have to be api hooking

465
00:19:23,120 --> 00:19:25,679
but we can for example use the x64

466
00:19:25,679 --> 00:19:26,400
debugger

467
00:19:26,400 --> 00:19:29,840
to follow the jump instruction in

468
00:19:29,840 --> 00:19:33,440
the address space and we finally

469
00:19:33,440 --> 00:19:38,080
will see that we start in the ntdl

470
00:19:38,080 --> 00:19:41,039
and it ends in the the jump instruction

471
00:19:41,039 --> 00:19:42,960
when we follow the jump instruction

472
00:19:42,960 --> 00:19:46,720
it ends in the adder space of

473
00:19:46,720 --> 00:19:50,559
the edr dll and that is a clear

474
00:19:50,559 --> 00:19:53,840
indicator for the that ddr

475
00:19:53,840 --> 00:19:55,760
redirects the code by using a jump

476
00:19:55,760 --> 00:19:57,280
instruction for analyzing

477
00:19:57,280 --> 00:20:00,240
the executed code

478
00:20:01,919 --> 00:20:04,240
so one question why speak be always

479
00:20:04,240 --> 00:20:06,080
about user mode hooking and not kernel

480
00:20:06,080 --> 00:20:07,360
mode working

481
00:20:07,360 --> 00:20:12,080
that's very simple micro do microsoft

482
00:20:12,080 --> 00:20:14,799
implemented in the kernel with windows

483
00:20:14,799 --> 00:20:15,360
xp

484
00:20:15,360 --> 00:20:18,000
service pack free for windows x64

485
00:20:18,000 --> 00:20:18,960
systems

486
00:20:18,960 --> 00:20:22,000
bit systems a mechanism which is called

487
00:20:22,000 --> 00:20:23,280
patchguard

488
00:20:23,280 --> 00:20:27,520
and patchguard prevents edrs and epps to

489
00:20:27,520 --> 00:20:28,080
set

490
00:20:28,080 --> 00:20:31,679
officially their api hooking in

491
00:20:31,679 --> 00:20:36,559
kernel length so the edrs are officially

492
00:20:36,559 --> 00:20:40,960
forced to set the api hooks in

493
00:20:40,960 --> 00:20:44,159
user mode in the anti-dll and because of

494
00:20:44,159 --> 00:20:44,559
that

495
00:20:44,559 --> 00:20:47,280
because of the windows architecture we

496
00:20:47,280 --> 00:20:48,640
know that they are the same rules for

497
00:20:48,640 --> 00:20:50,480
everyone in user mode and best

498
00:20:50,480 --> 00:20:54,799
lead us to some ways to bypass

499
00:20:54,799 --> 00:20:57,840
user mode api hooking from the red team

500
00:20:57,840 --> 00:21:00,320
perspective

501
00:21:00,320 --> 00:21:02,720
so there are several ways to bypass user

502
00:21:02,720 --> 00:21:04,880
mode api hooking

503
00:21:04,880 --> 00:21:06,720
in that presentation we will have a look

504
00:21:06,720 --> 00:21:08,720
at direct system calls

505
00:21:08,720 --> 00:21:11,840
which was uh released or introduced uh

506
00:21:11,840 --> 00:21:14,320
two years ago by a very great blog post

507
00:21:14,320 --> 00:21:16,000
from outflank from the guy

508
00:21:16,000 --> 00:21:18,799
from the guys from from the netherlands

509
00:21:18,799 --> 00:21:20,880
so i just can recommend to have a look

510
00:21:20,880 --> 00:21:22,240
on their blog post

511
00:21:22,240 --> 00:21:24,720
you can really learn a lot about red

512
00:21:24,720 --> 00:21:25,760
teaming

513
00:21:25,760 --> 00:21:28,880
and yeah api hooking they have a very

514
00:21:28,880 --> 00:21:31,039
very great block which you can read

515
00:21:31,039 --> 00:21:33,360
about

516
00:21:34,000 --> 00:21:35,440
so still we have the goal to get

517
00:21:35,440 --> 00:21:37,200
credentials from the elsa's process

518
00:21:37,200 --> 00:21:39,679
without creating the alert

519
00:21:39,679 --> 00:21:44,080
any alert and so we have to to

520
00:21:44,080 --> 00:21:47,039
bypass in the first step user mode api

521
00:21:47,039 --> 00:21:48,080
hooking

522
00:21:48,080 --> 00:21:50,799
and we use a tool by outflank which is

523
00:21:50,799 --> 00:21:51,679
called

524
00:21:51,679 --> 00:21:55,360
uh dumpart and dumpert uses direct

525
00:21:55,360 --> 00:21:56,240
system calls

526
00:21:56,240 --> 00:21:59,360
to dump the address space of the essos

527
00:21:59,360 --> 00:22:00,559
process

528
00:22:00,559 --> 00:22:05,120
uh by direct system console so without

529
00:22:05,120 --> 00:22:08,159
without touching the entity level so

530
00:22:08,159 --> 00:22:11,440
first we compare short in theory

531
00:22:11,440 --> 00:22:13,760
the difference when we dump credentials

532
00:22:13,760 --> 00:22:15,760
with mimi cuts and when we dump

533
00:22:15,760 --> 00:22:19,520
credentials with dumpert so mimikatz for

534
00:22:19,520 --> 00:22:20,240
example

535
00:22:20,240 --> 00:22:23,600
uses a native api which is called

536
00:22:23,600 --> 00:22:25,360
anti-read with your memory

537
00:22:25,360 --> 00:22:27,440
to read the virtual memory of the elsa's

538
00:22:27,440 --> 00:22:29,440
process

539
00:22:29,440 --> 00:22:32,960
but often edrs set in that native api

540
00:22:32,960 --> 00:22:35,919
a jump instruction to redirect the code

541
00:22:35,919 --> 00:22:38,080
for analyzing the executed code

542
00:22:38,080 --> 00:22:41,280
in the context of that api and so you

543
00:22:41,280 --> 00:22:43,600
often have the problem that you are not

544
00:22:43,600 --> 00:22:44,960
able to dump

545
00:22:44,960 --> 00:22:48,159
credentials with maybe cuts on currently

546
00:22:48,159 --> 00:22:51,440
edrs or epps

547
00:22:52,320 --> 00:22:55,520
instead of that dumbart also needs

548
00:22:55,520 --> 00:22:57,600
the native api anti-virtual memory to

549
00:22:57,600 --> 00:22:59,200
read the address space

550
00:22:59,200 --> 00:23:03,200
uh from from the lfos process

551
00:23:03,200 --> 00:23:07,440
but instead of calling it by the ntdll

552
00:23:07,520 --> 00:23:10,799
dumper uses a combination of api hooking

553
00:23:10,799 --> 00:23:14,400
and direct system calls and implement

554
00:23:14,400 --> 00:23:17,360
the associated native api and the

555
00:23:17,360 --> 00:23:19,440
assembly instructions directly in the

556
00:23:19,440 --> 00:23:20,159
binary

557
00:23:20,159 --> 00:23:23,760
itself and so it is necessary to

558
00:23:23,760 --> 00:23:27,440
call that native api by the anti-dll

559
00:23:27,440 --> 00:23:29,760
and so also the code executed code

560
00:23:29,760 --> 00:23:31,600
cannot be redirected to the edl

561
00:23:31,600 --> 00:23:35,280
edr and ddr has no visibility

562
00:23:35,280 --> 00:23:40,080
into the cult native api

563
00:23:45,120 --> 00:23:47,679
okay so in our first demo we will try to

564
00:23:47,679 --> 00:23:48,320
bypass

565
00:23:48,320 --> 00:23:52,320
api hooking in user mode by using

566
00:23:52,320 --> 00:23:54,559
the tool dumper which uses direct system

567
00:23:54,559 --> 00:23:56,559
calls and we try to

568
00:23:56,559 --> 00:23:58,960
dump the asus process without creating

569
00:23:58,960 --> 00:24:00,640
an alert

570
00:24:00,640 --> 00:24:03,760
in the edr system and we will check

571
00:24:03,760 --> 00:24:06,320
if it in that case isn't is enough to

572
00:24:06,320 --> 00:24:07,520
just bypass

573
00:24:07,520 --> 00:24:11,039
user mode api okay so we switch to our

574
00:24:11,039 --> 00:24:13,840
demo system

575
00:24:15,919 --> 00:24:17,679
okay there we have our endpoint we see

576
00:24:17,679 --> 00:24:19,120
installed in yeah

577
00:24:19,120 --> 00:24:21,520
to keep everything anonym we have

578
00:24:21,520 --> 00:24:22,320
disabled

579
00:24:22,320 --> 00:24:25,120
uh every notification from the edr

580
00:24:25,120 --> 00:24:27,520
system

581
00:24:27,679 --> 00:24:30,880
so at first for short comparison

582
00:24:30,880 --> 00:24:34,080
we can try to execute mimi cuts first i

583
00:24:34,080 --> 00:24:34,880
i

584
00:24:34,880 --> 00:24:37,039
create a copy because we need it later

585
00:24:37,039 --> 00:24:38,000
on

586
00:24:38,000 --> 00:24:43,440
so we will see when we execute mimi cuts

587
00:24:44,000 --> 00:24:46,960
we get detected by edr and also mimi

588
00:24:46,960 --> 00:24:48,640
cuts gets deleted

589
00:24:48,640 --> 00:24:50,880
so no way to dump credentials with

590
00:24:50,880 --> 00:24:52,320
memory cards in that case

591
00:24:52,320 --> 00:24:55,279
on that endpoint

592
00:24:55,600 --> 00:24:58,480
okay so we will try it with the nice

593
00:24:58,480 --> 00:24:59,600
tool from outflank

594
00:24:59,600 --> 00:25:02,320
with dumpert

595
00:25:02,880 --> 00:25:05,279
to create a dump file from the elsa's

596
00:25:05,279 --> 00:25:07,760
process by using direct system calls

597
00:25:07,760 --> 00:25:15,840
to bypass user mode api hooking

598
00:25:25,279 --> 00:25:27,360
okay here we see a little bit what

599
00:25:27,360 --> 00:25:28,640
dumper is doing

600
00:25:28,640 --> 00:25:31,840
so we see it uses the native api anti

601
00:25:31,840 --> 00:25:33,600
read virtual memory

602
00:25:33,600 --> 00:25:36,559
and reads the address space of the ss

603
00:25:36,559 --> 00:25:37,360
process

604
00:25:37,360 --> 00:25:39,360
and creates a dump file to that

605
00:25:39,360 --> 00:25:41,279
directory

606
00:25:41,279 --> 00:25:44,720
but there is one problem the byte has

607
00:25:44,720 --> 00:25:47,919
zero kilobytes so i asked myself what

608
00:25:47,919 --> 00:25:49,360
could be the problem for that

609
00:25:49,360 --> 00:25:53,200
and checked checked in the binary in the

610
00:25:53,200 --> 00:25:55,120
source code the native apis

611
00:25:55,120 --> 00:25:59,039
so maybe i use a wrong version or i have

612
00:25:59,039 --> 00:26:00,000
to

613
00:26:00,000 --> 00:26:02,159
to

614
00:26:03,279 --> 00:26:06,640
to check the native apis in the binary

615
00:26:06,640 --> 00:26:08,240
because they can change from

616
00:26:08,240 --> 00:26:10,320
one one version from windows to another

617
00:26:10,320 --> 00:26:12,080
version

618
00:26:12,080 --> 00:26:14,640
but the real problem is that in that

619
00:26:14,640 --> 00:26:16,799
case with that edr system

620
00:26:16,799 --> 00:26:19,200
just bypassing user mode api looking to

621
00:26:19,200 --> 00:26:19,840
get credit

622
00:26:19,840 --> 00:26:22,840
credentials without an alert isn't

623
00:26:22,840 --> 00:26:24,400
enough so

624
00:26:24,400 --> 00:26:26,880
we have also to deal deal with another

625
00:26:26,880 --> 00:26:29,760
uh mechanism which is used by that edr

626
00:26:29,760 --> 00:26:31,279
and that are the kernel callback

627
00:26:31,279 --> 00:26:33,520
functions so we go back to our

628
00:26:33,520 --> 00:26:35,520
presentation

629
00:26:35,520 --> 00:26:38,640
have a short look about on what is

630
00:26:38,640 --> 00:26:40,799
what are curly callbacks and how can we

631
00:26:40,799 --> 00:26:41,840
deal with that

632
00:26:41,840 --> 00:26:43,919
from the red team perspective and then

633
00:26:43,919 --> 00:26:47,200
we come back to our demo system

634
00:26:47,200 --> 00:26:49,840
because still we want credentials from

635
00:26:49,840 --> 00:26:53,840
the elsa's process

636
00:27:00,720 --> 00:27:03,200
okay as i said at the first try it

637
00:27:03,200 --> 00:27:04,400
wasn't enough to guys

638
00:27:04,400 --> 00:27:08,159
just bypass user mode api hooking um

639
00:27:08,159 --> 00:27:10,159
when we have the possibility to look

640
00:27:10,159 --> 00:27:11,760
into the web console which isn't

641
00:27:11,760 --> 00:27:13,760
currently possible because then you will

642
00:27:13,760 --> 00:27:15,919
see which edr we are using

643
00:27:15,919 --> 00:27:17,520
you will see that we still create a

644
00:27:17,520 --> 00:27:19,360
critical alert because

645
00:27:19,360 --> 00:27:22,960
the edr checks that we try to

646
00:27:22,960 --> 00:27:24,960
access the address space of the essa's

647
00:27:24,960 --> 00:27:26,000
process

648
00:27:26,000 --> 00:27:31,600
from unauthorized or from an unusual

649
00:27:32,840 --> 00:27:34,240
process

650
00:27:34,240 --> 00:27:36,000
so we also have to deal with kernel

651
00:27:36,000 --> 00:27:38,080
callbacks

652
00:27:38,080 --> 00:27:40,000
as i said before patchcar prevents the

653
00:27:40,000 --> 00:27:41,600
edr to set the api

654
00:27:41,600 --> 00:27:44,720
hooks in kernel end but this by

655
00:27:44,720 --> 00:27:46,799
patchcard there is still a possibility

656
00:27:46,799 --> 00:27:49,840
to get feedback from the kernels for the

657
00:27:49,840 --> 00:27:51,039
edrs

658
00:27:51,039 --> 00:27:52,559
so what they can do they can load a

659
00:27:52,559 --> 00:27:54,559
device driver into the kernel

660
00:27:54,559 --> 00:27:56,880
and register some specific callbacks

661
00:27:56,880 --> 00:27:59,520
like the pset create process notify

662
00:27:59,520 --> 00:28:02,960
callback and by that callback the edr

663
00:28:02,960 --> 00:28:04,799
always gets informed about when a new

664
00:28:04,799 --> 00:28:05,440
process

665
00:28:05,440 --> 00:28:09,279
is started on the endpoint

666
00:28:09,279 --> 00:28:12,720
and how can we deal with that how can we

667
00:28:12,720 --> 00:28:14,960
maybe remove that callbacks because

668
00:28:14,960 --> 00:28:18,240
the callbacks are in that case

669
00:28:18,240 --> 00:28:21,360
uh still the reason why

670
00:28:21,360 --> 00:28:23,919
we are we are not able to create a dump

671
00:28:23,919 --> 00:28:26,320
file with dumper

672
00:28:26,320 --> 00:28:29,039
with the credentials or with with the

673
00:28:29,039 --> 00:28:30,799
credentials from the ls process

674
00:28:30,799 --> 00:28:32,960
and we still create an alert so how can

675
00:28:32,960 --> 00:28:36,559
we deal with with the callbacks

676
00:28:38,159 --> 00:28:39,919
for that we have to move into kernel

677
00:28:39,919 --> 00:28:42,399
land because

678
00:28:42,399 --> 00:28:45,039
as i said before it isn't possible to

679
00:28:45,039 --> 00:28:46,080
execute

680
00:28:46,080 --> 00:28:49,760
code from user mode in kernel land

681
00:28:49,760 --> 00:28:52,880
so what we can do when an attacker or

682
00:28:52,880 --> 00:28:53,919
how can we

683
00:28:53,919 --> 00:28:57,200
achieve it to get into the kernel

684
00:28:57,200 --> 00:29:02,240
when an attacker access or reaches

685
00:29:02,240 --> 00:29:04,960
full administrator privileges it can use

686
00:29:04,960 --> 00:29:05,440
that

687
00:29:05,440 --> 00:29:08,399
privileges to load a vulnerable driver

688
00:29:08,399 --> 00:29:09,520
like the mse

689
00:29:09,520 --> 00:29:13,679
afterburner driver into the kernel

690
00:29:13,679 --> 00:29:16,640
and by the vulnerability of the driver

691
00:29:16,640 --> 00:29:18,080
we get

692
00:29:18,080 --> 00:29:20,720
directly read and write access to the

693
00:29:20,720 --> 00:29:21,600
kernel from

694
00:29:21,600 --> 00:29:27,760
userland and that is a very interesting

695
00:29:27,760 --> 00:29:29,760
changing point because in my opinion

696
00:29:29,760 --> 00:29:31,200
when the attacker

697
00:29:31,200 --> 00:29:33,360
has reached administrative privileges

698
00:29:33,360 --> 00:29:35,039
and has upon its possibility to

699
00:29:35,039 --> 00:29:36,799
compromise a kernel

700
00:29:36,799 --> 00:29:39,360
by loading a wool level device driver it

701
00:29:39,360 --> 00:29:40,000
is a whole game

702
00:29:40,000 --> 00:29:42,559
changer because uh yeah when the kernel

703
00:29:42,559 --> 00:29:44,159
is compromised

704
00:29:44,159 --> 00:29:47,679
also in my opinion the endpoint is

705
00:29:47,679 --> 00:29:51,120
lost completely his integrity so by

706
00:29:51,120 --> 00:29:53,279
moving into the kernel we have the

707
00:29:53,279 --> 00:29:54,559
possibility

708
00:29:54,559 --> 00:29:58,799
to remove the callbacks

709
00:30:00,000 --> 00:30:03,360
why isn't that uh device driver loading

710
00:30:03,360 --> 00:30:04,880
from vulnerable device wherever not

711
00:30:04,880 --> 00:30:06,320
prevented

712
00:30:06,320 --> 00:30:09,440
this depends strongly on the certificate

713
00:30:09,440 --> 00:30:11,279
date of the vulnerable device driver for

714
00:30:11,279 --> 00:30:13,279
example the amazing afterburner driver

715
00:30:13,279 --> 00:30:18,240
is uh released before end of july 2015

716
00:30:18,240 --> 00:30:20,720
and so still when the when microsoft

717
00:30:20,720 --> 00:30:22,480
knows about their vulnerability

718
00:30:22,480 --> 00:30:25,520
the driver can still be used to to

719
00:30:25,520 --> 00:30:28,880
uh to load into to get access to the

720
00:30:28,880 --> 00:30:30,799
kernel

721
00:30:30,799 --> 00:30:32,799
after july 2015 it is a little bit

722
00:30:32,799 --> 00:30:34,080
harder because

723
00:30:34,080 --> 00:30:36,080
instead of the one certificate you need

724
00:30:36,080 --> 00:30:38,240
a extended validation

725
00:30:38,240 --> 00:30:41,679
uh hard reset certificate but also in

726
00:30:41,679 --> 00:30:43,200
that case you will still

727
00:30:43,200 --> 00:30:46,799
find uh drivers with vulnerabilities

728
00:30:46,799 --> 00:30:49,360
which can be loaded into the kernel and

729
00:30:49,360 --> 00:30:50,480
give you access

730
00:30:50,480 --> 00:30:53,279
to kernel land

731
00:30:54,240 --> 00:30:56,080
okay now we know a little bit about

732
00:30:56,080 --> 00:30:58,080
kernel callbacks so we go back to our

733
00:30:58,080 --> 00:30:59,679
demo system because we still want

734
00:30:59,679 --> 00:31:01,679
credentials from the elsa's process

735
00:31:01,679 --> 00:31:04,640
without creating any alert in the edr so

736
00:31:04,640 --> 00:31:05,679
what we do

737
00:31:05,679 --> 00:31:08,640
we use a very nice poc which is called

738
00:31:08,640 --> 00:31:10,000
jackie blinder

739
00:31:10,000 --> 00:31:14,320
from that guy and

740
00:31:14,320 --> 00:31:16,559
by that plc we load a reliable device

741
00:31:16,559 --> 00:31:18,320
driver into the kernel

742
00:31:18,320 --> 00:31:20,640
remove the callback and see if we can

743
00:31:20,640 --> 00:31:21,440
finally

744
00:31:21,440 --> 00:31:23,360
get our credentials or dump the elfs

745
00:31:23,360 --> 00:31:24,640
process

746
00:31:24,640 --> 00:31:27,679
without creating an alert so we go back

747
00:31:27,679 --> 00:31:33,840
to the demo system

748
00:31:35,440 --> 00:31:39,039
and in the folder you can see

749
00:31:39,200 --> 00:31:42,480
the poc which we are using and also the

750
00:31:42,480 --> 00:31:44,399
vulnerable device driver which we

751
00:31:44,399 --> 00:31:47,840
load into the kernel to get access

752
00:31:47,840 --> 00:31:51,519
from userland to kernel land

753
00:31:51,600 --> 00:31:54,080
so first we can check the options from

754
00:31:54,080 --> 00:31:55,919
the poc

755
00:31:55,919 --> 00:32:01,600
and we can install

756
00:32:01,600 --> 00:32:06,000
the driver with the vulnerability

757
00:32:06,000 --> 00:32:08,480
so now the driver is registered in

758
00:32:08,480 --> 00:32:11,039
kernel land

759
00:32:12,159 --> 00:32:15,279
and we can uh list

760
00:32:15,279 --> 00:32:18,320
all regis registered callbacks uh on

761
00:32:18,320 --> 00:32:19,039
that

762
00:32:19,039 --> 00:32:22,320
machine and uh these are not all

763
00:32:22,320 --> 00:32:24,320
callbacks from the edr system so you

764
00:32:24,320 --> 00:32:25,360
have to

765
00:32:25,360 --> 00:32:27,200
because when you remove the once you

766
00:32:27,200 --> 00:32:30,320
remove the callback you have to find out

767
00:32:30,320 --> 00:32:32,799
which callback is from the edr in that

768
00:32:32,799 --> 00:32:34,000
case i

769
00:32:34,000 --> 00:32:36,960
do it very often i tried it before a lot

770
00:32:36,960 --> 00:32:38,320
of times

771
00:32:38,320 --> 00:32:42,240
so i know it and we can very simple

772
00:32:42,240 --> 00:32:44,799
remove it

773
00:32:47,840 --> 00:32:51,440
so we can check the registered callbacks

774
00:32:51,440 --> 00:32:52,399
again

775
00:32:52,399 --> 00:32:56,240
and we will see that currently the

776
00:32:56,240 --> 00:32:59,519
we we are we are able to remove the

777
00:32:59,519 --> 00:33:02,000
callback

778
00:33:02,720 --> 00:33:05,919
so what did we know or what have we done

779
00:33:05,919 --> 00:33:09,519
by removing the callback now the edr

780
00:33:09,519 --> 00:33:11,600
has not longer the possibility to get

781
00:33:11,600 --> 00:33:13,360
informed about

782
00:33:13,360 --> 00:33:16,000
when a new process is started on the

783
00:33:16,000 --> 00:33:17,200
endpoint so

784
00:33:17,200 --> 00:33:19,840
no matter if we are now executing

785
00:33:19,840 --> 00:33:21,519
dumpers or mimi cuts

786
00:33:21,519 --> 00:33:24,399
or just for simple post exploitation id

787
00:33:24,399 --> 00:33:25,360
config

788
00:33:25,360 --> 00:33:28,399
which needs ipconfig.exe in the

789
00:33:28,399 --> 00:33:30,440
background or who am i which needs

790
00:33:30,440 --> 00:33:31,840
uemi.exe

791
00:33:31,840 --> 00:33:33,760
the edr system has not logged the

792
00:33:33,760 --> 00:33:36,240
possibility to collect that telemetry

793
00:33:36,240 --> 00:33:39,440
on the endpoint so now we can

794
00:33:39,440 --> 00:33:42,559
execute dumper again and see if we now

795
00:33:42,559 --> 00:33:46,399
can successfully dump the

796
00:33:46,399 --> 00:33:49,199
ss process

797
00:33:51,039 --> 00:33:53,200
and we see it changed from 0 to 50

798
00:33:53,200 --> 00:33:54,159
kilobyte

799
00:33:54,159 --> 00:33:57,279
and now that file can be used to

800
00:33:57,279 --> 00:33:59,919
take it to a local machine uh load it

801
00:33:59,919 --> 00:34:00,960
into memory cards

802
00:34:00,960 --> 00:34:03,440
and read out the created clear tech

803
00:34:03,440 --> 00:34:05,360
credentials or hashes

804
00:34:05,360 --> 00:34:09,679
from that end point but very interesting

805
00:34:09,679 --> 00:34:12,879
when you have removed in that case the

806
00:34:12,879 --> 00:34:15,280
callbacks from vdr as i said the idea

807
00:34:15,280 --> 00:34:18,239
gets no longer informed about

808
00:34:18,239 --> 00:34:20,800
which process is started on the endpoint

809
00:34:20,800 --> 00:34:21,918
and so also

810
00:34:21,918 --> 00:34:25,119
uh the combination from api hooking

811
00:34:25,119 --> 00:34:29,040
and kernel callbacks is no longer

812
00:34:29,040 --> 00:34:32,320
working efficiently so we are

813
00:34:32,320 --> 00:34:35,839
also able

814
00:34:36,159 --> 00:34:39,599
to directly execute mimikats now

815
00:34:39,599 --> 00:34:43,599
which wasn't possible before

816
00:34:43,918 --> 00:34:49,839
and we cannot just start mini cuts

817
00:34:50,079 --> 00:34:52,560
also

818
00:34:53,280 --> 00:34:56,320
it is not possible

819
00:35:01,520 --> 00:35:04,480
to dump credentials with memory cards

820
00:35:04,480 --> 00:35:06,160
directly

821
00:35:06,160 --> 00:35:08,960
so that is not longer it it's not no

822
00:35:08,960 --> 00:35:11,040
longer necessary to

823
00:35:11,040 --> 00:35:14,000
use uh direct system calls to bypass

824
00:35:14,000 --> 00:35:16,480
user mode api hooking

825
00:35:16,480 --> 00:35:19,920
when you were able to

826
00:35:19,920 --> 00:35:22,000
load a vulnerable device driver and

827
00:35:22,000 --> 00:35:23,520
knock out the edr

828
00:35:23,520 --> 00:35:26,880
by removing the callback so from that

829
00:35:26,880 --> 00:35:30,640
point it's a it's a game changer

830
00:35:30,640 --> 00:35:33,920
because the attacker has in my opinion

831
00:35:33,920 --> 00:35:36,480
for 100 percent compromised the endpoint

832
00:35:36,480 --> 00:35:38,160
and the endpoint definitely

833
00:35:38,160 --> 00:35:45,839
lost his integrity

834
00:35:49,760 --> 00:35:52,960
so we see that in that case it wasn't

835
00:35:52,960 --> 00:35:55,040
enough to just bypass apioking to get

836
00:35:55,040 --> 00:35:56,480
credentials from the else's process

837
00:35:56,480 --> 00:35:58,320
without creating an alert

838
00:35:58,320 --> 00:36:00,240
but this depends strangle strongly on

839
00:36:00,240 --> 00:36:03,119
the edr the also edr's weight is

840
00:36:03,119 --> 00:36:05,920
just enough to bypass user mode api okay

841
00:36:05,920 --> 00:36:07,359
also it depends on

842
00:36:07,359 --> 00:36:09,520
what the attacker is doing for example

843
00:36:09,520 --> 00:36:11,359
for process extraction it could be

844
00:36:11,359 --> 00:36:13,280
enough to just bypass user mode api

845
00:36:13,280 --> 00:36:14,000
hooking

846
00:36:14,000 --> 00:36:15,599
but in case of credential dumping the

847
00:36:15,599 --> 00:36:17,920
else process maybe you also have to deal

848
00:36:17,920 --> 00:36:19,839
with kernel callbacks

849
00:36:19,839 --> 00:36:23,200
so you can think about your strategy

850
00:36:23,200 --> 00:36:24,800
but it is possible depending on the

851
00:36:24,800 --> 00:36:27,520
sensitivity of a system

852
00:36:27,520 --> 00:36:29,839
maybe you can try to load that driver

853
00:36:29,839 --> 00:36:32,000
and use the short poc

854
00:36:32,000 --> 00:36:34,560
to remove the callback lock out the edr

855
00:36:34,560 --> 00:36:35,359
and try to

856
00:36:35,359 --> 00:36:40,560
dump credentials from the asus process

857
00:36:40,560 --> 00:36:42,079
very important when you are finished

858
00:36:42,079 --> 00:36:44,240
with your work in your lab or

859
00:36:44,240 --> 00:36:46,880
also in your penetration test when you

860
00:36:46,880 --> 00:36:48,160
use it

861
00:36:48,160 --> 00:36:50,240
do not forget to unload the device

862
00:36:50,240 --> 00:36:52,400
travel it's very important because

863
00:36:52,400 --> 00:36:54,000
for example in that case of the msc

864
00:36:54,000 --> 00:36:56,079
afterburner driver when the driver is

865
00:36:56,079 --> 00:36:57,200
still loaded

866
00:36:57,200 --> 00:37:00,480
um an attacker has the possibility to

867
00:37:00,480 --> 00:37:03,599
get system privileges directly get

868
00:37:03,599 --> 00:37:05,599
system privileges from the

869
00:37:05,599 --> 00:37:09,839
standard user account

870
00:37:10,800 --> 00:37:13,839
okay so we are finished now from

871
00:37:13,839 --> 00:37:16,000
directing perspective

872
00:37:16,000 --> 00:37:18,320
but as i said before what can we do

873
00:37:18,320 --> 00:37:20,160
about from the bluetooth

874
00:37:20,160 --> 00:37:22,160
perspective to protect us against

875
00:37:22,160 --> 00:37:23,440
credential dumping

876
00:37:23,440 --> 00:37:27,119
when the edr system is bypassed

877
00:37:28,400 --> 00:37:31,040
i have to say that it doesn't matter

878
00:37:31,040 --> 00:37:33,280
which edr project you are dealing for so

879
00:37:33,280 --> 00:37:35,839
it can be harder with one product

880
00:37:35,839 --> 00:37:38,000
compared to another product but

881
00:37:38,000 --> 00:37:40,640
uh every edr system have to play with

882
00:37:40,640 --> 00:37:42,800
the same rules under windows

883
00:37:42,800 --> 00:37:45,839
but um er systems

884
00:37:45,839 --> 00:37:48,480
do still increase the activity security

885
00:37:48,480 --> 00:37:49,599
so

886
00:37:49,599 --> 00:37:52,160
it is definitely a good thing to

887
00:37:52,160 --> 00:37:54,000
additionally use the edr product to a

888
00:37:54,000 --> 00:37:55,200
classic

889
00:37:55,200 --> 00:37:59,280
epp protector but still

890
00:37:59,280 --> 00:38:01,280
independent of using products you have

891
00:38:01,280 --> 00:38:03,440
to harden your windows environment

892
00:38:03,440 --> 00:38:05,440
because when an attacker was able to

893
00:38:05,440 --> 00:38:07,280
bypass tdr system

894
00:38:07,280 --> 00:38:11,119
and gains admin privileges he can

895
00:38:11,119 --> 00:38:14,079
dump credentials from the elsa's process

896
00:38:14,079 --> 00:38:16,000
but when you before hardened you

897
00:38:16,000 --> 00:38:18,000
previously when you harden your windows

898
00:38:18,000 --> 00:38:19,280
environment and the

899
00:38:19,280 --> 00:38:22,079
attacker isn't able to get credentials

900
00:38:22,079 --> 00:38:22,800
uh

901
00:38:22,800 --> 00:38:25,359
admin credentials it doesn't matter

902
00:38:25,359 --> 00:38:26,079
which tool

903
00:38:26,079 --> 00:38:28,400
he uses because for every tool we use to

904
00:38:28,400 --> 00:38:30,079
try the credentials from their

905
00:38:30,079 --> 00:38:34,320
process we need admin privileges

906
00:38:34,320 --> 00:38:38,240
in more detail when we try to dump

907
00:38:38,240 --> 00:38:40,640
the access process from a user session

908
00:38:40,640 --> 00:38:42,320
we need in our admin

909
00:38:42,320 --> 00:38:45,440
token the debug as a debug privilege so

910
00:38:45,440 --> 00:38:46,000
for example

911
00:38:46,000 --> 00:38:47,599
when you harden your administrative

912
00:38:47,599 --> 00:38:51,599
token and remove that privilege

913
00:38:51,599 --> 00:38:54,800
the attacker cannot dump the ss process

914
00:38:54,800 --> 00:38:57,599
from a user session for sure it can

915
00:38:57,599 --> 00:38:58,640
again

916
00:38:58,640 --> 00:39:01,520
get can gain uh when he already has

917
00:39:01,520 --> 00:39:03,040
admin villages he can

918
00:39:03,040 --> 00:39:06,160
get system privileges and then he has he

919
00:39:06,160 --> 00:39:06,640
can

920
00:39:06,640 --> 00:39:08,640
he's also in the uh works from the user

921
00:39:08,640 --> 00:39:09,680
session so

922
00:39:09,680 --> 00:39:13,200
the icd privilege is no longer necessary

923
00:39:13,200 --> 00:39:15,760
but for that the attacker has to do one

924
00:39:15,760 --> 00:39:18,320
step more

925
00:39:20,240 --> 00:39:22,880
so another way to protect the asus

926
00:39:22,880 --> 00:39:24,960
process is to use the lsr protection

927
00:39:24,960 --> 00:39:26,880
which uses a technique from microsoft

928
00:39:26,880 --> 00:39:28,960
which is called process protection lite

929
00:39:28,960 --> 00:39:32,720
so when the ss protection is enabled

930
00:39:32,720 --> 00:39:35,680
an attacker cannot dump the address

931
00:39:35,680 --> 00:39:37,680
space of the ss process

932
00:39:37,680 --> 00:39:39,839
also not when he has admin or system

933
00:39:39,839 --> 00:39:41,359
privileges

934
00:39:41,359 --> 00:39:43,520
but there's still a way by mimi cuts to

935
00:39:43,520 --> 00:39:44,640
remove the

936
00:39:44,640 --> 00:39:47,040
ppl of the ls from when elsa is

937
00:39:47,040 --> 00:39:47,839
protected by

938
00:39:47,839 --> 00:39:50,560
ppl so you can use mini cuts to load a

939
00:39:50,560 --> 00:39:52,079
vulnerable device driver

940
00:39:52,079 --> 00:39:54,560
into the kernel as we learned before you

941
00:39:54,560 --> 00:39:56,720
from the kernel then you have many

942
00:39:56,720 --> 00:39:57,520
options

943
00:39:57,520 --> 00:39:59,200
for example you can remove the callbacks

944
00:39:59,200 --> 00:40:01,440
but you also are able to

945
00:40:01,440 --> 00:40:04,800
remove the ppl from a process and so you

946
00:40:04,800 --> 00:40:05,520
can

947
00:40:05,520 --> 00:40:08,319
use the ring zero options by mimi cards

948
00:40:08,319 --> 00:40:09,680
to remove the ppl

949
00:40:09,680 --> 00:40:13,119
of the ss process and you were

950
00:40:13,119 --> 00:40:16,319
again able to dump credentials from the

951
00:40:16,319 --> 00:40:17,920
process

952
00:40:17,920 --> 00:40:21,119
but additionally to elsa's protection

953
00:40:21,119 --> 00:40:22,720
when you have the requirements fulfilled

954
00:40:22,720 --> 00:40:24,319
on the endpoint you can use credential

955
00:40:24,319 --> 00:40:25,200
guard

956
00:40:25,200 --> 00:40:26,960
and credential guard works a little bit

957
00:40:26,960 --> 00:40:28,400
different because it uses

958
00:40:28,400 --> 00:40:33,280
the hyper hypervisor based protection

959
00:40:33,280 --> 00:40:36,240
for creating virtual trust levels so

960
00:40:36,240 --> 00:40:38,720
when you enable credential guard

961
00:40:38,720 --> 00:40:42,079
you create um two different

962
00:40:42,079 --> 00:40:45,119
uh virtual trust levels so in the normal

963
00:40:45,119 --> 00:40:46,800
mode which we are working on

964
00:40:46,800 --> 00:40:48,240
in the normal user mode in the normal

965
00:40:48,240 --> 00:40:51,200
kernel mode is default l0

966
00:40:51,200 --> 00:40:53,040
uh credential when you activate

967
00:40:53,040 --> 00:40:54,880
credential guard you create

968
00:40:54,880 --> 00:40:57,040
a virtual trust level which is called

969
00:40:57,040 --> 00:40:58,880
faulty l1

970
00:40:58,880 --> 00:41:02,000
and by activating credential guard

971
00:41:02,000 --> 00:41:04,400
the domain admin credentials are no

972
00:41:04,400 --> 00:41:06,079
longer stored in the elsa

973
00:41:06,079 --> 00:41:10,079
process in the normal mode

974
00:41:10,079 --> 00:41:13,520
so uh they get from now on they get

975
00:41:13,520 --> 00:41:15,680
stored in the lsr iso process

976
00:41:15,680 --> 00:41:19,280
lsr iso is named for

977
00:41:19,280 --> 00:41:23,040
lsr isolation and currently there is no

978
00:41:23,040 --> 00:41:24,319
way to get access

979
00:41:24,319 --> 00:41:27,680
from file to l0 to file tl1 so

980
00:41:27,680 --> 00:41:30,960
also when an attacker has gained access

981
00:41:30,960 --> 00:41:33,520
admin privileges in the kernel mode in

982
00:41:33,520 --> 00:41:34,000
in

983
00:41:34,000 --> 00:41:38,400
faulty l0 he has no currently no way to

984
00:41:38,400 --> 00:41:40,640
get access to the address space of the

985
00:41:40,640 --> 00:41:41,920
lsi so process

986
00:41:41,920 --> 00:41:44,880
in fact that is one because of that

987
00:41:44,880 --> 00:41:46,800
separation

988
00:41:46,800 --> 00:41:50,400
based on the hypervisor

989
00:41:54,079 --> 00:41:56,480
okay so uh thanks a lot for your

990
00:41:56,480 --> 00:41:57,200
attention

991
00:41:57,200 --> 00:41:59,520
i hope it was a little bit exciting to

992
00:41:59,520 --> 00:42:00,319
learn about

993
00:42:00,319 --> 00:42:02,960
using what api looking kernel callbacks

994
00:42:02,960 --> 00:42:04,640
and so on what we can do about it as a

995
00:42:04,640 --> 00:42:06,400
red teamer

996
00:42:06,400 --> 00:42:08,560
feel free to ask any questions also you

997
00:42:08,560 --> 00:42:11,200
can write us later on email

998
00:42:11,200 --> 00:42:15,200
and yeah have a nice day and

999
00:42:15,200 --> 00:42:17,839
we will see you

