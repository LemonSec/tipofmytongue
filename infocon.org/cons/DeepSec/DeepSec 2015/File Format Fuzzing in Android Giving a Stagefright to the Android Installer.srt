1
00:00:00,000 --> 00:00:10,450
mixed up I like Blanda gives us an
insight into file former housing in

2
00:00:10,450 --> 00:00:17,990
android thank you for nice introduction
my name is Alex plunder I work as a

3
00:00:17,990 --> 00:00:22,000
software security engineer for Intel's
open source technology center in Romania

4
00:00:22,000 --> 00:00:29,179
today's stock has focused on an approach
that can be used for performing far from

5
00:00:29,179 --> 00:00:36,420
enforcing an Android these are the main
points of the presentation first we'll

6
00:00:36,420 --> 00:00:41,200
see general overview of how we can
perform far from what phasing in Android

7
00:00:41,200 --> 00:00:46,800
environment then we'll see how this
approach can be applied to several

8
00:00:46,800 --> 00:00:51,339
targets from the Android operating
system will see how to perform fighting

9
00:00:51,340 --> 00:00:55,840
against the stage fright Media Framework
and also the Android applications

10
00:00:55,840 --> 00:01:02,750
thought process towards the end of the
session will also see how to use an

11
00:01:02,750 --> 00:01:08,659
alternative approach exactly how to make
use of the American father Luke to which

12
00:01:08,659 --> 00:01:19,869
is a very public housing 200 environment
so for the job forcing approach these

13
00:01:19,869 --> 00:01:26,189
would be the steps that can be taken in
this campaign first we need to figure

14
00:01:26,189 --> 00:01:31,899
out how to generate the most from data
for our different funding needs the

15
00:01:31,900 --> 00:01:37,060
actual execution or the running of the
test cases won't be taken into

16
00:01:37,060 --> 00:01:43,149
consideration for this general approach
because this would be a step that is

17
00:01:43,149 --> 00:01:48,040
highly specific for each target so I'll
discuss more about this for each project

18
00:01:48,040 --> 00:01:55,630
example after generating the data and
executing the data on the device we need

19
00:01:55,630 --> 00:01:59,810
to figure out a way to actually see
what's happening with partisan campaign

20
00:01:59,810 --> 00:02:07,280
so to monitor the results we need to
figure out a way to do this in real time

21
00:02:07,280 --> 00:02:08,949
so we'll be talking about

22
00:02:08,949 --> 00:02:14,750
allowing process and how to develop a
long process that can be applied to

23
00:02:14,750 --> 00:02:20,110
general scenarios in the Fortune case
when we have frozen complain that

24
00:02:20,110 --> 00:02:27,370
generates good results so we have let's
take a large number of crisis we also

25
00:02:27,370 --> 00:02:33,150
need to come up with a way to uniquely
sort them so we need to figure out a way

26
00:02:33,150 --> 00:02:39,390
to develop what we are smoking is so
we've generated the data we've executed

27
00:02:39,390 --> 00:02:46,380
the data on the Android advice we've
wanted the results we so what happened

28
00:02:46,380 --> 00:02:52,739
there we've sorted out the unique issues
and now we are left with the small

29
00:02:52,739 --> 00:02:57,650
number of unique issues that need to be
analyzed so we're also talking about a

30
00:02:57,650 --> 00:03:07,799
few methods in which we can achieve this
task generally speaking in fostering and

31
00:03:07,799 --> 00:03:12,730
more specific info from advancing we can
have either rotational forcing or

32
00:03:12,730 --> 00:03:17,790
generational forcing me additional
funding means that we have an initial

33
00:03:17,790 --> 00:03:24,650
set of files that can be referred to the
target application or the target system

34
00:03:24,650 --> 00:03:28,680
component and we try to mars format or
to

35
00:03:28,680 --> 00:03:34,840
corrupted in various ways it's important
to note that we must try to maintain the

36
00:03:34,840 --> 00:03:40,810
structural validity of the files that
were we are fighting because we need to

37
00:03:40,810 --> 00:03:46,930
have the component that you're targeting
believes that the input that were

38
00:03:46,930 --> 00:03:52,810
feeling it is actually valid so the
target would actually accept that

39
00:03:52,810 --> 00:04:00,730
important parts it and maybe give give a
crash in generation focusing on the

40
00:04:00,730 --> 00:04:07,988
other hand we try to create the most
random 22 from scratch in this case also

41
00:04:07,989 --> 00:04:13,359
we need to be aware of the structure or
the format of the input because

42
00:04:13,960 --> 00:04:22,240
we need to know the way in which we can
construct that that this case the tools

43
00:04:22,240 --> 00:04:26,610
that we have been using for funding
purposes in Android are the ones

44
00:04:26,610 --> 00:04:27,810
mentioned on the screen

45
00:04:27,810 --> 00:04:32,550
the first of all is the basic funding
framework this is a tool that can be

46
00:04:32,550 --> 00:04:38,160
used in Linux environments it targets
applications or binaries the tension

47
00:04:38,160 --> 00:04:44,410
following put the thing is the main
advantage for this tool is that is

48
00:04:44,410 --> 00:04:51,590
almost completely automated so it
generates the gdb

49
00:04:52,290 --> 00:04:58,120
traces and vibrant resource for the
crash is that it finds it also tries to

50
00:04:58,120 --> 00:05:03,500
do our best effort into sorting out the
unique issues so you don't have to

51
00:05:03,500 --> 00:05:08,310
actually develop between us mechanism if
you run the tool in Linux based

52
00:05:08,310 --> 00:05:13,550
environment that all is actually based
on another popular tool so is based on a

53
00:05:13,550 --> 00:05:19,450
modified version of which is also a
general-purpose Pfizer not at all that

54
00:05:19,450 --> 00:05:20,469
we've been using

55
00:05:20,470 --> 00:05:29,450
is smaller on Facebook's this tool is
specialized on multimedia products we've

56
00:05:29,450 --> 00:05:35,490
been raining using this tool for facing
the stage fright Media Framework it also

57
00:05:35,490 --> 00:05:41,050
runs only on Linux environments or
downsize another popular solution the

58
00:05:41,050 --> 00:05:46,440
main advantage for them signed the
reason why we used it is because you can

59
00:05:46,440 --> 00:05:54,460
proceed to to the tool and you are able
to reproduce a test case when you find

60
00:05:54,460 --> 00:06:00,599
that specific this case has produced a
crash or issue the American father is

61
00:06:00,600 --> 00:06:04,590
probably the most popular shopping tool
at the moment I'll be talking about it

62
00:06:04,590 --> 00:06:07,590
in more detail

63
00:06:08,220 --> 00:06:14,790
in a section of the presentation it can
be really considered to be either

64
00:06:14,790 --> 00:06:20,660
imitation or generational fussing tool
it's more like an evolution facing tool

65
00:06:20,660 --> 00:06:25,180
because it's based on the response that
is it receives from the application

66
00:06:25,180 --> 00:06:34,080
based on the coverage so let's say we
have a fucking campaign and we've

67
00:06:34,080 --> 00:06:40,169
generated data using the tools that I've
mentioned we need a way to figure out

68
00:06:40,170 --> 00:06:46,040
what's happening with artists cases so
if you're familiar with Android you are

69
00:06:46,040 --> 00:06:53,820
also its locking system so the locket
before the thing is that each time

70
00:06:53,820 --> 00:07:00,200
fatal crash occurs so stomach rash
occurs the native code level of Android

71
00:07:00,200 --> 00:07:05,990
a fatal messages is generated and
inserted into the local buffer the local

72
00:07:05,990 --> 00:07:10,480
buffer gathers messages from all types
of components from the Android OS

73
00:07:10,480 --> 00:07:16,310
including applications and assigns them
different priorities we have in total

74
00:07:16,310 --> 00:07:21,000
seven priorities things like fatal
messages error messages information

75
00:07:21,000 --> 00:07:27,110
messages debug messages and you can
actually sort the local buffer to print

76
00:07:27,110 --> 00:07:33,870
out only messages that have a specific
priority so what we do in specific

77
00:07:33,870 --> 00:07:38,880
funding campaign for its this case that
we sent an executive on the device we

78
00:07:38,880 --> 00:07:43,560
also artificially insert a message into
the local buffer we can do that using

79
00:07:43,560 --> 00:07:51,020
the locum and that is built into the end
and Android devices show we can specify

80
00:07:51,020 --> 00:07:55,390
the propriety of the message the
component with the tax and other

81
00:07:55,390 --> 00:08:01,630
information about the case that we are
executing so this is an example of

82
00:08:02,600 --> 00:08:08,610
general template for funding campaign
Android so it's time we will execute

83
00:08:08,610 --> 00:08:15,040
this case on a device we also send a
message with a fatal priority with

84
00:08:15,040 --> 00:08:20,380
information such as this casing thanks
and more importantly a way to actually

85
00:08:20,380 --> 00:08:28,760
reproduce the issue in the case of media
files for example if we are facing or if

86
00:08:28,760 --> 00:08:34,049
you are corrupting the media files
locally on the Linux machine we can save

87
00:08:34,049 --> 00:08:37,689
the all the files that are being
modified and then for the

88
00:08:37,690 --> 00:08:42,210
reproducibility issue we can only have
let's say the following that is sent to

89
00:08:42,210 --> 00:08:49,460
the device this would be a simple
example because in order to reproduce

90
00:08:49,460 --> 00:08:54,860
that the crash we can just go on the
local machine where we have all the test

91
00:08:54,860 --> 00:09:00,700
cases saved so for instance case that is
executed we also insert a fatal message

92
00:09:00,700 --> 00:09:06,500
and when an actual fatal message or a
crash occurs and the system generates

93
00:09:06,500 --> 00:09:15,300
this type of message will know that this
case immediately above it is responsible

94
00:09:15,300 --> 00:09:24,109
for the crash however if we have a large
number of devices that run for large

95
00:09:24,110 --> 00:09:30,250
periods of times a large punitive damage
will have there are chances that the

96
00:09:30,250 --> 00:09:35,660
logs will get very crowded there will be
a large number of crashes and will

97
00:09:35,660 --> 00:09:40,839
simply can go through them manually and
start to look we have segmentation fault

98
00:09:40,840 --> 00:09:45,110
let's look at this kit this case try to
reproduce it and see what's going on so

99
00:09:45,110 --> 00:09:49,580
you have to come up with a way to
actually take the logs that are parsed

100
00:09:49,580 --> 00:09:52,209
after testing campaign

101
00:09:52,209 --> 00:09:57,128
and go through them and automatic
automatically find out which of these

102
00:09:57,129 --> 00:10:03,009
shoes are unique we can do this by
developing the Trias mechanism so

103
00:10:03,009 --> 00:10:07,309
besides inserting a fatal message into
the local buffer each time

104
00:10:07,309 --> 00:10:14,889
crash occurs into the native code level
of Android we also get an entry here in

105
00:10:14,889 --> 00:10:19,290
the a.m stones on the device so
tombstone file is generated each time a

106
00:10:19,290 --> 00:10:26,519
crash occurs in android this is what
looks like it contains a lot of useful

107
00:10:26,519 --> 00:10:30,809
information about the crash so we have
the signal and the coach for the single

108
00:10:30,809 --> 00:10:35,769
the process that crashed the first
addressed the registry values at the

109
00:10:35,769 --> 00:10:42,369
time of the crash and the batteries for
that pressing the targeted component it

110
00:10:42,369 --> 00:10:48,819
contains actually a lot more information
but for the purpose of the trash

111
00:10:48,819 --> 00:10:53,709
mechanism these are the information that
we need to look at how can we uniquely

112
00:10:53,709 --> 00:10:59,949
identify a crash based on this
information by looking at this the

113
00:10:59,949 --> 00:11:06,279
program counter value where the crash
occurred so this value is unique for

114
00:11:06,279 --> 00:11:14,170
each crash that occurred in the same
process however we need to be careful of

115
00:11:14,170 --> 00:11:21,809
how we applied this mechanism because if
we have two identical crashes but the

116
00:11:21,809 --> 00:11:26,689
image that is built on two separate
device on two separate devices is

117
00:11:26,689 --> 00:11:30,949
different than the program counter value
will also be different

118
00:11:30,949 --> 00:11:35,179
although the crisis are identical so we
need to use the trust mechanism when

119
00:11:35,179 --> 00:11:40,769
working on a cluster of devices that
have the same image flashed onto them

120
00:11:40,769 --> 00:11:46,019
how does it actually work so how do we
actually implemented reaction mechanism

121
00:11:46,019 --> 00:11:51,249
so we have the logs from the actual
testing phase would take those logs and

122
00:11:51,249 --> 00:11:57,920
we start our system we identify the
fatal messages when we identify the fate

123
00:11:57,920 --> 00:12:04,279
of messages we also have the actual test
case that produced the crash in some

124
00:12:04,279 --> 00:12:08,870
cases we it's simpler like in the case
of media files in all cases we just take

125
00:12:08,870 --> 00:12:16,079
the reproducibility we try to execute
that input that caused the crash to try

126
00:12:16,079 --> 00:12:21,189
to confirm that the crash actually
occurs and if it does occur then

127
00:12:21,189 --> 00:12:22,829
certainly

128
00:12:22,829 --> 00:12:30,089
tombstone files will be generated that
what we do is we parse it we get the

129
00:12:30,089 --> 00:12:36,910
program counter value from the race and
we check if the program counter value

130
00:12:36,910 --> 00:12:41,819
has been previously encountered if it
has previously been encountered then it

131
00:12:41,819 --> 00:12:48,309
means that the crash is not new but if
the value is new then we consider it to

132
00:12:48,309 --> 00:12:52,209
be an unique issue we save the tombstone
so have information about the crash and

133
00:12:52,209 --> 00:12:57,498
we also save the rain put order
reproducibility information so we have a

134
00:12:57,499 --> 00:13:05,029
way to action reproduce that crash so
let's say we had a large number of

135
00:13:05,029 --> 00:13:11,100
crises we passed all the questions for
the trust mechanism and are left and we

136
00:13:11,100 --> 00:13:18,279
are left with two or three unique issues
what can we do next so what can we do to

137
00:13:18,279 --> 00:13:23,799
try to analyze and find debugging
information the first place we go is as

138
00:13:23,799 --> 00:13:29,149
I mentioned earlier the daytime storms
location where we have the tombstone

139
00:13:29,149 --> 00:13:36,129
that is being generated the actual
single and a single code can give us the

140
00:13:36,129 --> 00:13:41,540
first thing type of information that can
be useful in to determine the severity

141
00:13:41,540 --> 00:13:48,469
of that crash also the fault address is
important in the registry values we can

142
00:13:48,470 --> 00:13:53,829
also take a look at the message you have
on the spring two examples of actual

143
00:13:53,829 --> 00:13:59,910
crashes in the stage fright the state's
redmond jeffrey mark the first one is an

144
00:13:59,910 --> 00:14:07,179
error for the second one is a narrow 6
the first one is user mode read access

145
00:14:07,179 --> 00:14:11,459
fault you can see how the error codes
can be formed

146
00:14:12,030 --> 00:14:17,290
so we have 00100 and the second one its
is on

147
00:14:17,290 --> 00:14:27,199
write access user mode fault you have
your own 1100 this also can can give us

148
00:14:27,199 --> 00:14:36,359
some information about about the crash
moving on we can also use gdb to perform

149
00:14:36,360 --> 00:14:41,490
debugging in Android for this you first
need to enable DHCP server on the device

150
00:14:41,490 --> 00:14:47,279
you can do this in two ways so either
you can attach the GDP server to the

151
00:14:47,279 --> 00:14:53,680
process I D that you are trying to bug
or you can actually if the process that

152
00:14:53,680 --> 00:14:59,040
you're targeting can we started using
executable finally you can actually

153
00:14:59,040 --> 00:15:08,920
started already using gdb server need to
mention the port so this is done in the

154
00:15:08,920 --> 00:15:13,810
shell of the Android device then you go
on to the local machine will you have

155
00:15:13,810 --> 00:15:18,930
the Android device connected and you
forward the TCP port that used to start

156
00:15:18,930 --> 00:15:25,459
GB server you started to be regularly
you start remote debugging session using

157
00:15:25,459 --> 00:15:32,130
this command and mentioning the report
let you have used only have to do is

158
00:15:32,130 --> 00:15:35,139
just reaching the process execution

159
00:15:35,829 --> 00:15:39,779
it's important to note that if you
really want to have a meaningful

160
00:15:39,779 --> 00:15:46,630
debugging session you should also use
the debugging symbols that can be taken

161
00:15:46,630 --> 00:15:49,630
from the end re-try after you have built

162
00:15:50,279 --> 00:15:53,279
an Android image and actually flashed it
on the Android device

163
00:15:57,499 --> 00:16:01,389
fortunate case when you actually have
access to the source code of the

164
00:16:01,389 --> 00:16:05,310
compliment that you are targeting in
Android in most of the cases you who do

165
00:16:05,310 --> 00:16:11,660
have but there are some buyers that are
property you don't have access to its

166
00:16:11,660 --> 00:16:19,180
source called you can use addressed line
you take the batteries from the date at

167
00:16:19,180 --> 00:16:25,689
install files and you check the program
counter value for the component that you

168
00:16:25,689 --> 00:16:30,790
are targeting you are not really
interested in to seeing the line of code

169
00:16:30,790 --> 00:16:35,300
where the crash according to leave see
you are more interested in actually

170
00:16:35,300 --> 00:16:41,889
seeing what happened in style live stage
fright so the last call from the stage

171
00:16:41,889 --> 00:16:48,970
fright library then all you have to do
is pass this value as a parameter to

172
00:16:48,970 --> 00:16:56,730
address line you also need to have
access to the symbols of the image that

173
00:16:56,730 --> 00:17:02,279
you have built actually have that same
image that you are passing the symbols

174
00:17:02,279 --> 00:17:02,860
here

175
00:17:02,860 --> 00:17:12,169
flashed onto the device so you have the
right correspondence ok so far and see

176
00:17:12,169 --> 00:17:19,449
how this applies to the first project
example which is facing the media free

177
00:17:19,449 --> 00:17:26,250
market Android more specifically very
popular topic in the Android security

178
00:17:26,250 --> 00:17:34,600
world first yr media files attractive
actors there is the fact that generally

179
00:17:34,600 --> 00:17:40,320
speaking of audio and video files are
binary strings that contain complex data

180
00:17:40,320 --> 00:17:45,059
there are a lot of specialized
components that handle the parsing of

181
00:17:45,059 --> 00:17:48,430
this house and because of that

182
00:17:48,430 --> 00:17:53,420
there is there is the probability that
when parsing these false memory

183
00:17:53,420 --> 00:17:59,370
corruption issues me occur then there's
the fact that it is a very large attack

184
00:17:59,370 --> 00:18:06,459
surface so really people who are trying
to find ways to actually find bugs

185
00:18:06,460 --> 00:18:11,550
explode them have a lot of possibilities
in doing this there is also the

186
00:18:11,550 --> 00:18:18,830
perception that media files are harmless
so users general normal users want

187
00:18:18,830 --> 00:18:23,389
generally have second thoughts when
downloading or using media files from

188
00:18:23,390 --> 00:18:31,460
untrusted sources especially because
these media files can be played without

189
00:18:31,460 --> 00:18:39,030
the actual consent of the users is the
example that made the stage fright bug

190
00:18:39,030 --> 00:18:44,070
very popular the one that we're messages
sent that has

191
00:18:45,530 --> 00:18:55,970
attached with an Android there isn't
really a way to give special permissions

192
00:18:55,970 --> 00:19:02,950
when playing or downloading media files
which is also attractive point from Dr

193
00:19:02,950 --> 00:19:14,260
attacker perspective so this is what we
try to achieve so we have set of media

194
00:19:14,260 --> 00:19:17,650
files so we performed mutational
fighting against the stage fright Media

195
00:19:17,650 --> 00:19:24,460
Framework what we do is locally so not
on the Android device we create more

196
00:19:24,460 --> 00:19:30,470
foreign media files that we try to keep
structurally valid we direct the test

197
00:19:30,470 --> 00:19:37,150
cases that are created locally through
the Android devices more specifically

198
00:19:37,150 --> 00:19:41,810
directing the test cases to the stage
fright when you're free market and we'll

199
00:19:41,810 --> 00:19:46,770
see how we actually do this we wanted
the system for potential issues using

200
00:19:46,770 --> 00:19:51,639
the login process approach that I've
mentioned in the first part of the

201
00:19:51,640 --> 00:19:58,330
presentation and then because in this
case we had a really large number of

202
00:19:58,330 --> 00:20:03,050
pressures from the beginning we had to
come up with a mechanism and we passed

203
00:20:03,050 --> 00:20:11,270
the results from the trio's mechanism in
the initial phases of the project we had

204
00:20:11,270 --> 00:20:15,879
to figure out how to actually sent the
test cases that we are what we were

205
00:20:15,880 --> 00:20:23,590
facing to the appropriate decoders the
first solution that we came up was to

206
00:20:23,590 --> 00:20:29,260
just played corrupt media files inside
different media player applications that

207
00:20:29,260 --> 00:20:34,160
are available on Android or to leverage
the Jeep Java API that handles

208
00:20:34,759 --> 00:20:42,329
media playback however the best solution
that we came up with was using the stage

209
00:20:42,329 --> 00:20:47,379
fright command line interface which can
be optionally built into Android device

210
00:20:47,379 --> 00:20:55,998
from this past weekend retreat the main
advantage is that using the command-line

211
00:20:55,999 --> 00:21:00,979
interface you have direct access to the
native gold of the media framework so

212
00:21:00,979 --> 00:21:07,929
you bypass all the general air which
would impose unnecessary performance

213
00:21:07,929 --> 00:21:11,889
overhead and it would be possible so
that some of the issues were not

214
00:21:11,889 --> 00:21:20,918
reproduce because the test cases won't
get parsed get barnstorming the Java

215
00:21:20,919 --> 00:21:29,049
where this is these are some of the main
functionalities of the the binary that

216
00:21:29,049 --> 00:21:35,979
can be built into the Android show the
functionalities that are to us is our

217
00:21:35,979 --> 00:21:43,719
the fact that you can pass audio or
video file to be the code it so it can

218
00:21:43,719 --> 00:21:49,769
actually take input media file and
directed to the appropriate instructor

219
00:21:49,769 --> 00:21:57,409
for the appropriate file format you can
also force the playback functionality

220
00:21:57,409 --> 00:22:05,009
for audiophiles and also force the usage
of a software or hardware codec we've

221
00:22:05,009 --> 00:22:11,069
tried to forge this case that we have
sent on 200 devices we try to test to

222
00:22:11,069 --> 00:22:14,539
see if anything happens using both
software and hard work of the

223
00:22:14,539 --> 00:22:21,849
functionality is the fact that you can
extract the video thumbnail so prices

224
00:22:21,849 --> 00:22:27,509
can also occur when the image files that
are associated with video files are

225
00:22:27,509 --> 00:22:29,710
being parsed by

226
00:22:29,710 --> 00:22:39,820
by the special arts components so this
is how an actual log looks like that is

227
00:22:39,820 --> 00:22:44,439
being created using the template that
I've mentioned before so for each test

228
00:22:44,440 --> 00:22:49,610
case that is being generated locally we
send it on to the device and then pass

229
00:22:49,610 --> 00:22:53,918
it as a parameter to the stage right
command line interface each time we do

230
00:22:53,919 --> 00:22:59,000
this we also insert fatal message into
the local buffer that looks something

231
00:22:59,000 --> 00:23:06,380
like this so we have the component that
we are targeting as I mentioned earlier

232
00:23:06,380 --> 00:23:13,610
just the filing of the media for that we
are we have created this is the simple

233
00:23:13,610 --> 00:23:21,110
example where we all the all the cases
are also being saved onto the device so

234
00:23:21,110 --> 00:23:26,879
when an actual real crash occurs like
this one here we know that this file is

235
00:23:26,880 --> 00:23:33,659
responsible for the crash and we can
just go back onto the local machine get

236
00:23:33,659 --> 00:23:40,110
get that far and try to reproduce it
these are some of the results that we

237
00:23:40,110 --> 00:23:45,199
had with this campaign so we started
this project sometimes in the beginning

238
00:23:45,200 --> 00:23:54,890
of 2014 in the first weeks of running
the campaigns we had extremely

239
00:23:54,890 --> 00:23:59,710
surprising results because the state's
riding a framework will just keep on

240
00:23:59,710 --> 00:24:05,320
crashing that led to the development of
the trust mechanism so it was actually

241
00:24:05,320 --> 00:24:09,779
on the system because we couldn't just
go manually flew from the crisis that we

242
00:24:09,779 --> 00:24:16,529
had the first severe issues were
reported to Google and assigned C V

243
00:24:16,529 --> 00:24:17,639
shoes

244
00:24:17,639 --> 00:24:23,129
in September 2014 these worrying that
overflows in the los tres froid

245
00:24:23,129 --> 00:24:29,019
libraries these are bugs that are very
similar to what is commonly known now as

246
00:24:29,019 --> 00:24:34,700
the stage fright bug we also a source
cartoons that made possible the

247
00:24:34,700 --> 00:24:41,369
discovery of these issues in February
2015 so little is publicly available on

248
00:24:41,369 --> 00:24:47,949
github you can take a look at it but
actually were not really using it for

249
00:24:47,950 --> 00:24:53,279
its purpose so we are now using it as a
complementary solution alongside with

250
00:24:53,279 --> 00:25:00,129
the american 402 I'm going to explain a
bit more about this section of the

251
00:25:00,129 --> 00:25:06,509
presentation this is the second example
that I'm going to talk about it relates

252
00:25:06,509 --> 00:25:12,879
to furthering the Android application
install process first why is this

253
00:25:12,879 --> 00:25:19,579
important there is the fact that the
component that handles the application

254
00:25:19,579 --> 00:25:27,139
install Android is a process that runs
with her system privileges so any issue

255
00:25:27,139 --> 00:25:35,728
that is found here and can be exploited
by an attacker can have greater severity

256
00:25:35,729 --> 00:25:42,200
from a security point of view there is
also the fact that installing an

257
00:25:42,200 --> 00:25:47,519
application is one of the few ways in
which improving user so on external user

258
00:25:47,519 --> 00:25:55,440
has access to send input to a privilege
component in Android also facing in

259
00:25:55,440 --> 00:25:56,690
general

260
00:25:56,690 --> 00:26:04,870
gives issues that are not generally
found through regular validation this is

261
00:26:04,870 --> 00:26:13,169
also the case here because issues that
we can find for this method would not be

262
00:26:13,170 --> 00:26:21,510
found through regular validation I'm
talking when have an EPK that is trying

263
00:26:21,510 --> 00:26:27,990
to handle it said the Google Play Store
this type of issues won't be found for

264
00:26:27,990 --> 00:26:33,540
that the validation that is performed
before entering the market we've

265
00:26:33,540 --> 00:26:40,409
identified two approaches that can be
used the protests are different because

266
00:26:40,410 --> 00:26:48,290
the newer Android versions have switched
virtual machine with the Android runtime

267
00:26:48,290 --> 00:26:55,930
so going through the all the steps that
are taken at the system level to

268
00:26:55,930 --> 00:27:01,220
actually install an application onto the
device we found that the most

269
00:27:01,220 --> 00:27:05,660
interesting components from opposing
perspective would be in the case of art

270
00:27:05,660 --> 00:27:11,750
the next 20 component and in the case of
the week except on the deck Stewart

271
00:27:11,750 --> 00:27:17,840
takes as input a text file which is the
compile Java code from an Android

272
00:27:17,840 --> 00:27:26,439
application and converts it into which
is actually an executive also fell in

273
00:27:26,440 --> 00:27:29,670
the case of KitKat the process is
similar

274
00:27:29,670 --> 00:27:35,840
only that they stop takes input text
file and convert it into an optimized

275
00:27:35,840 --> 00:27:39,080
explore this would be the

276
00:27:39,680 --> 00:27:46,580
the testing process of review so this is
also a mutational funding process we

277
00:27:46,580 --> 00:27:53,510
have large amounts of each show valid
apk files on a PK is actually the

278
00:27:53,510 --> 00:28:01,870
application of that contains the Java
code and the native library code so we

279
00:28:01,870 --> 00:28:09,110
have the initially picky valise files
and 4G PK we will strike the components

280
00:28:09,110 --> 00:28:16,040
from the decay because basically became
just regular huh file and we found the

281
00:28:16,040 --> 00:28:21,760
apk components that are of interest to
us and then in the case of dollars we

282
00:28:21,760 --> 00:28:27,850
repackage DPK and send it to the Android
install process and in the case of art

283
00:28:27,850 --> 00:28:31,969
the things are more simpler we can
actually parse we can actually send

284
00:28:31,970 --> 00:28:39,890
different components directly to the
install process this is the these are

285
00:28:39,890 --> 00:28:51,330
the components that are regularly found
inside an apk so . text file which is

286
00:28:51,330 --> 00:28:59,460
the compile Java code for this is the
actual father we will be facing target

287
00:28:59,460 --> 00:29:06,580
for funding could be DeAndre manifest
file however this is this was not in the

288
00:29:06,580 --> 00:29:12,439
scope of this project contains the
signing information for the apk

289
00:29:13,140 --> 00:29:17,840
this is also confirmed that is of
interest to us because for example if we

290
00:29:17,840 --> 00:29:23,409
have an initial apk that we extract its
components and start to modify things in

291
00:29:23,410 --> 00:29:28,940
it and then we tried to repackage it and
install it onto the device that won't be

292
00:29:28,940 --> 00:29:36,390
possible because the signing information
won't allow this so each time we modify

293
00:29:36,390 --> 00:29:41,790
an apk we need to actually re-sign it so
we can install it onto the device

294
00:29:45,090 --> 00:29:55,970
because the approaches are different on
dolphin art I'll start with the one on

295
00:29:55,970 --> 00:30:03,930
the pic excerpt is a binary that exists
in the exist on the device it's located

296
00:30:03,930 --> 00:30:10,710
in system / mean however we can use it
directly so we can call it directly

297
00:30:10,710 --> 00:30:15,930
because it takes a lot of parameters
that can be obtained from a show like

298
00:30:15,930 --> 00:30:23,990
environment so what we thought is to
actually simulate the entire apk install

299
00:30:23,990 --> 00:30:31,920
process these are the actual steps what
we do is pretty PK we extract the

300
00:30:31,920 --> 00:30:40,390
classes point we first that file I'm
going to talk to detail about how we

301
00:30:40,390 --> 00:30:45,680
actually first this for the moment we
are going to rationally that will text

302
00:30:45,680 --> 00:30:52,410
file we remove the original file from
the initially became you repackage the

303
00:30:52,410 --> 00:30:58,420
apk with the modified next we need to
create a local keystore so we can be

304
00:30:58,420 --> 00:31:06,110
able to actually sign the apk we can do
this with the key to come and we remove

305
00:31:06,110 --> 00:31:11,120
the previous signing information by
removing them but I'm directory and we

306
00:31:11,120 --> 00:31:20,030
we signed the apk using our local store
so we can actually say this is a lot of

307
00:31:20,030 --> 00:31:28,030
example that was taken from a national
campaign against the ACCEPT so we can

308
00:31:28,030 --> 00:31:37,310
see here that for each apk that we are
we have the epic a leading surely PK and

309
00:31:37,310 --> 00:31:43,659
the seed for themselves what we do is we
don't save each month from the apk that

310
00:31:43,660 --> 00:31:48,780
we are testing against the device we
only keep things sleepy case and the

311
00:31:48,780 --> 00:31:55,960
seat that can be used to actually
reproduce the issue so this seed

312
00:31:55,960 --> 00:32:01,660
that is passed to the dumpster father is
used to actually fast only the classes

313
00:32:01,660 --> 00:32:07,480
poindexter and they will repackage and
sign and re-signed the apk this is an

314
00:32:07,480 --> 00:32:17,000
example of an actual crash which was
generated by this apk I D would proceed

315
00:32:17,000 --> 00:32:25,110
in the case of art so in the case of the
extort things are more simpler we can

316
00:32:25,110 --> 00:32:30,370
actually use we can actually directly
used a text or binary we use it

317
00:32:30,940 --> 00:32:41,550
bypassing text file like this and
resulting Oct five so what we have to do

318
00:32:41,550 --> 00:32:48,860
is we have the initial apk valid files
we extract all the classes point X files

319
00:32:48,860 --> 00:32:54,840
from them and then we start using only
the text files and sending them as

320
00:32:54,840 --> 00:33:01,040
parameters to the next world by Gary
this is the log example this is how you

321
00:33:01,040 --> 00:33:06,760
look like so we don't have the PK we
just have the decks I D the principal is

322
00:33:06,760 --> 00:33:14,610
singer with the one mentioned that they
accept because we also using reduce our

323
00:33:14,610 --> 00:33:25,479
and bypassing accede to the further the
thing is that and the Android system has

324
00:33:25,480 --> 00:33:31,930
in place still verification process that
checks if the text files we are trying

325
00:33:31,930 --> 00:33:38,480
to install are actually valid so when we
first started the project and complete

326
00:33:38,480 --> 00:33:43,610
the round of funding and try to install
applications we mostly came up with

327
00:33:43,610 --> 00:33:50,350
error messages like this one because the
system was able to figure out that the

328
00:33:50,350 --> 00:33:55,719
text files that were trying to install
were invalid this is

329
00:33:55,720 --> 00:34:02,130
bad for us from further perspective
because we want to do our target

330
00:34:02,130 --> 00:34:07,240
actually parse the input that were
feeling it and this wouldn't be possible

331
00:34:07,240 --> 00:34:15,969
if the component rejects the input from
the beginning to overcome this we've

332
00:34:15,969 --> 00:34:22,060
considered free housing matters the
first one was the initial one where we

333
00:34:22,060 --> 00:34:26,629
completely when we performed a
completely random fashion campaign

334
00:34:26,629 --> 00:34:32,230
against text wrote this couldn't
actually be applied to accept them to do

335
00:34:32,230 --> 00:34:40,590
so then the second method was partially
guys fighting we would random far as the

336
00:34:40,590 --> 00:34:45,099
text file and then come back and try to
fix as much as possible into the file

337
00:34:45,099 --> 00:34:53,960
header and then we had targeted funding
which was pinpoint an exact section of

338
00:34:53,960 --> 00:34:59,670
the docs filed first only that section
and then have more control of what

339
00:34:59,670 --> 00:35:06,670
things what were the things that have
changed and have no control over the

340
00:35:06,670 --> 00:35:12,240
header sections that we can modify this
is the text file format I'm not going to

341
00:35:12,240 --> 00:35:14,080
go into

342
00:35:14,080 --> 00:35:19,460
very much detail what you need to
understand is the fact that the header

343
00:35:19,460 --> 00:35:23,740
contains first general information about
the file

344
00:35:24,450 --> 00:35:29,859
things like file size or six arms and
held her size and then specific

345
00:35:29,860 --> 00:35:35,950
information about it section more
exactly the offset and size of each

346
00:35:35,950 --> 00:35:43,939
section this section contains the actual
content of the compile Java files this

347
00:35:43,940 --> 00:35:49,160
is optional field it also contains
information about the offices of the

348
00:35:49,160 --> 00:35:53,750
section and what is the type of content
that is present in the section

349
00:35:56,850 --> 00:36:04,360
partially guys fighting approach we took
the text file as a whole and started

350
00:36:04,360 --> 00:36:11,710
firing randomly things in sided then we
came back they took a look at the header

351
00:36:11,710 --> 00:36:21,020
and try to fix as much as as much as
possible we have the magic number in the

352
00:36:21,020 --> 00:36:25,950
header which is a constant and also the
header size and Kenyan tag so if by

353
00:36:25,950 --> 00:36:30,230
accident we will have modified those
values would come back and rewrite those

354
00:36:30,230 --> 00:36:36,190
values we could also recalculate
computer checks summoned the show on

355
00:36:36,190 --> 00:36:41,360
signature and the file size because
after a different modifications these

356
00:36:41,360 --> 00:36:42,670
values

357
00:36:42,670 --> 00:36:49,040
would be different and invalid so this
was the first approached the second

358
00:36:49,040 --> 00:36:56,690
approach we take the files late entry
section that was of interest to us was

359
00:36:56,690 --> 00:37:01,200
the data section because it contains all
the strings and all the variables that

360
00:37:01,200 --> 00:37:10,810
were used by the Java methods we would
fight only this section all the chance

361
00:37:10,810 --> 00:37:18,170
together and try to fix the header
besides the sections that we would fix

362
00:37:18,170 --> 00:37:24,310
in the first approach we will also have
information about the map upset because

363
00:37:24,310 --> 00:37:28,830
the first intersection could be bigger
or smaller so it would change and we

364
00:37:28,830 --> 00:37:34,190
wouldn't know exactly what would be
offset and also the data size because we

365
00:37:34,190 --> 00:37:41,970
modified that could also be variable
this was actually the approach that gave

366
00:37:41,970 --> 00:37:50,500
the best results I'm gonna explain a bit
about a later post that we used in the

367
00:37:50,500 --> 00:37:55,700
beginning was to actually take large
amounts of the x-files valid ex-spouse

368
00:37:55,700 --> 00:37:59,120
first them randomly and

369
00:38:00,210 --> 00:38:07,240
don't get back with the header so just
send them against the vote this was

370
00:38:07,240 --> 00:38:15,700
surprisingly approached it also gives
some results so although the number of

371
00:38:15,700 --> 00:38:22,310
precious was not as spectacular as in
the case of the state's write me a free

372
00:38:22,310 --> 00:38:28,970
marketing campaign we had initially
about 1,000 crashes not unique prices

373
00:38:28,970 --> 00:38:37,319
per week on a cluster that range from 20
to 30 Android devices there was also

374
00:38:37,320 --> 00:38:45,070
critical issue discovered this was
discovered in November 2014 Google sign

375
00:38:45,070 --> 00:38:51,040
the CCID for it there are also a number
of low priority issues that affect both

376
00:38:51,040 --> 00:38:56,839
Kit Kat and lollipop the turnoff fixed
the project is still going so there are

377
00:38:56,839 --> 00:38:59,839
still a number of issues that are
currently under investigation

378
00:39:04,030 --> 00:39:09,890
this is the last section of my talk this
is an alternative approach using the

379
00:39:09,890 --> 00:39:17,098
full too so the american Muscle is
facing tool is developed by shells

380
00:39:17,099 --> 00:39:18,060
lipsky

381
00:39:18,060 --> 00:39:21,230
it offers to focusing modes the download

382
00:39:21,230 --> 00:39:26,070
performance actually complete the round
of funding and instrumental mode where

383
00:39:26,070 --> 00:39:30,680
you have to instrument the binary date
you are targeting so

384
00:39:31,780 --> 00:39:38,350
you can actually detect changes to the
program control flow and tried to direct

385
00:39:38,350 --> 00:39:44,520
the culprits that you are accessing it
has the advantage that it takes both

386
00:39:44,520 --> 00:39:53,420
crashes and hangs and tries to sort them
to offer only the unique issues we had

387
00:39:53,420 --> 00:39:58,210
an Android port of the tool developed by
a colleague of mine by Adrian the

388
00:39:58,210 --> 00:40:02,730
patches also publicly available now on
the mailing list of the tools you can

389
00:40:02,730 --> 00:40:08,220
check out the link in the presentation
this is how we used and we are still

390
00:40:08,220 --> 00:40:14,640
using fell alongside lower custom-built
further to perform facing campaigns

391
00:40:14,640 --> 00:40:18,830
against the stage stage right in your
framework so this would be the first

392
00:40:18,830 --> 00:40:26,130
inflow we have the sea generation phase
where we actually generate valid media

393
00:40:26,130 --> 00:40:32,050
files we use this we think this by
leveraging the functionality is provided

394
00:40:32,050 --> 00:40:39,390
by the FM baked too so let's say have
initial mp4 file we can use a pic to

395
00:40:39,390 --> 00:40:48,920
convert mp4 3442 all sorts of codecs and
containers we generally try to cover all

396
00:40:48,920 --> 00:40:57,070
the container end codec combinations
from the Android CD after generating the

397
00:40:57,070 --> 00:41:02,470
initial value media files we love the
seats onto the device where we're on FL

398
00:41:02,470 --> 00:41:13,299
FL the version that is that is working
on Android we get the crashes and hangs

399
00:41:13,300 --> 00:41:20,410
that are reported by the AFL to and what
we do is passed down through the

400
00:41:20,410 --> 00:41:29,069
framework army voting framework in order
to actually detect which issues are

401
00:41:29,070 --> 00:41:36,290
unique because first there is the fact
that the test cases are executed on air

402
00:41:36,290 --> 00:41:40,220
felt constrained environment so you have
to said

403
00:41:40,220 --> 00:41:45,540
specific memory limit the specific
timeout limit for the execution of the

404
00:41:45,540 --> 00:41:53,599
test cases and in some cases if FL
reported the crash the crash won't

405
00:41:53,599 --> 00:41:58,030
actually produced in a normal user
scenario when I actually passing through

406
00:41:58,030 --> 00:42:03,760
the station right command line interface
there's also the fact that there are

407
00:42:03,760 --> 00:42:11,340
four runs on large number of devices so
if a crash is identified as being unique

408
00:42:11,340 --> 00:42:17,630
on one device is also reported as unique
on a second device but they are not

409
00:42:17,630 --> 00:42:25,220
actually unique in-between so we tried
to identify the deputy it's between the

410
00:42:25,220 --> 00:42:29,919
results that are being reported on
several devices that is why you are

411
00:42:29,920 --> 00:42:38,060
using custom Pfizer so our customers
receives as input the crashes and hangs

412
00:42:38,060 --> 00:42:45,619
fo reported it generates the logs as
we've seen the logs are parsed and

413
00:42:45,619 --> 00:42:50,109
passed through the trash mechanism where
we are done left only with the unique

414
00:42:50,109 --> 00:42:57,150
issues this approach also give some
results so this was one critical issue

415
00:42:57,150 --> 00:43:02,099
that affects the station right library
it was a hypocrite because corruption

416
00:43:02,099 --> 00:43:06,410
which could lead to arbitrary code
execution in the media server process

417
00:43:06,410 --> 00:43:11,810
which is a process that has some special
privileges this was discovered in August

418
00:43:11,810 --> 00:43:17,190
2015 and was included in the first
public Nexus security bulletins there

419
00:43:17,190 --> 00:43:21,970
are also multiple low priority issues
that have been exported to Google and

420
00:43:21,970 --> 00:43:27,000
are now fixed meaning all pointed
references or stuff like division by

421
00:43:27,000 --> 00:43:27,869
zero

422
00:43:27,869 --> 00:43:36,819
issues some conclusions first there's
the fact that fuzzy inside 100 the

423
00:43:36,819 --> 00:43:41,359
environment would be a little bit more
tricky during regular links environment

424
00:43:41,359 --> 00:43:48,119
there although david has been highly
publicized has been highly publicized

425
00:43:48,119 --> 00:43:53,269
issue lately it's important to
understand that is not actually bug so

426
00:43:53,269 --> 00:43:57,720
satisfied is not a bug it's more
actually a library that has a lot of

427
00:43:57,720 --> 00:44:05,430
issues also well performing rising it's
important to understanding the rules of

428
00:44:05,430 --> 00:44:12,098
the system that you are you are
targeting you could you could try to

429
00:44:12,099 --> 00:44:16,619
perform intelligence pausing or just get
lucky would to performing completely

430
00:44:16,619 --> 00:44:23,759
don't forcing that will be questions
thank you

431
00:44:35,030 --> 00:44:38,540
guess it really is quite hungry ready
well thank you very much

432
00:44:43,920 --> 00:44:54,040
the testing using physical devices are
you using any kind of virtualization x86

433
00:44:54,040 --> 00:45:00,690
devices based devices are trying to see
if they choose reproduce alarm or just

434
00:45:00,690 --> 00:45:01,750
Pacific during the devices

