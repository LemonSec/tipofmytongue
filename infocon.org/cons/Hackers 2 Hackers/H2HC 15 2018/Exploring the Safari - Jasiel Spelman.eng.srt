1
00:00:02,790 --> 00:00:08,570
[Music]

2
00:00:11,389 --> 00:00:16,079
and thank you for making it for the

3
00:00:13,980 --> 00:00:20,310
first talk of the day especially after

4
00:00:16,079 --> 00:00:23,009
last night I actually skipped out to try

5
00:00:20,310 --> 00:00:25,198
and sleep and I ended up waking up at 2

6
00:00:23,010 --> 00:00:28,740
o'clock and I've been up since so I

7
00:00:25,199 --> 00:00:33,960
apologized profusely as I'm exhausted

8
00:00:28,740 --> 00:00:36,360
thankfully I have guarna all right so

9
00:00:33,960 --> 00:00:39,090
this is exploring the safari just in

10
00:00:36,360 --> 00:00:41,160
time exploitation and one of my pet

11
00:00:39,090 --> 00:00:44,280
peeves when I go to a talk or read about

12
00:00:41,160 --> 00:00:46,019
a talk is when the speaker gives an

13
00:00:44,280 --> 00:00:48,059
abstract or a title that says one thing

14
00:00:46,020 --> 00:00:50,129
but then their talk is actually doing

15
00:00:48,059 --> 00:00:53,190
something different and I'm mentioning

16
00:00:50,129 --> 00:00:55,199
this because I'm doing exactly that I'm

17
00:00:53,190 --> 00:00:57,599
talking the title says Just In Time

18
00:00:55,199 --> 00:00:59,968
exploitation but as I was developing the

19
00:00:57,600 --> 00:01:04,049
slides it occurred to me that the

20
00:00:59,969 --> 00:01:06,479
exploitation part of jet engines is not

21
00:01:04,049 --> 00:01:08,909
that interesting because most of the

22
00:01:06,479 --> 00:01:12,320
vulnerabilities lend themselves towards

23
00:01:08,909 --> 00:01:15,060
full read/write access of memory space

24
00:01:12,320 --> 00:01:16,860
and so for me the more interesting part

25
00:01:15,060 --> 00:01:18,540
is the architecture and the

26
00:01:16,860 --> 00:01:20,070
vulnerabilities themselves and so that's

27
00:01:18,540 --> 00:01:25,860
what I'm gonna try and focus on a little

28
00:01:20,070 --> 00:01:27,600
bit more so just to give a Genda as to

29
00:01:25,860 --> 00:01:30,119
what we're gonna cover today I'm gonna

30
00:01:27,600 --> 00:01:31,559
give an overview as to why I'm giving

31
00:01:30,119 --> 00:01:34,140
this presentation and what I'm gonna be

32
00:01:31,560 --> 00:01:36,060
covering I'm going to cover JavaScript

33
00:01:34,140 --> 00:01:39,119
core architecture and for those who

34
00:01:36,060 --> 00:01:40,979
don't know JavaScript core is the the

35
00:01:39,119 --> 00:01:44,880
name of the engine it's basically a sub

36
00:01:40,979 --> 00:01:47,640
project for WebKit and WebKit is the

37
00:01:44,880 --> 00:01:51,390
browsing engine that's used by Safari so

38
00:01:47,640 --> 00:01:54,299
if you use an iOS phone or if you use an

39
00:01:51,390 --> 00:01:56,310
iPhone at all any browser you use on

40
00:01:54,299 --> 00:01:58,079
that is going to be based on WebKit even

41
00:01:56,310 --> 00:02:01,829
if you use Chrome on iOS that's going to

42
00:01:58,079 --> 00:02:03,449
be using WebKit views if you use MacBook

43
00:02:01,829 --> 00:02:04,740
or Mac Pro that's all going to and use

44
00:02:03,450 --> 00:02:07,590
if re then that's also you can use

45
00:02:04,740 --> 00:02:08,940
WebKit then I'm going to go over some

46
00:02:07,590 --> 00:02:11,430
vulnerability case studies and then

47
00:02:08,940 --> 00:02:13,060
finally have time for questions and this

48
00:02:11,430 --> 00:02:16,360
image on the right where it's

49
00:02:13,060 --> 00:02:18,610
a URL not an exploit HTML is one of my

50
00:02:16,360 --> 00:02:20,800
favorite things about Safari in that

51
00:02:18,610 --> 00:02:23,800
it's very very exploit friendly if you

52
00:02:20,800 --> 00:02:25,150
are trying to run an exploit and trying

53
00:02:23,800 --> 00:02:27,210
to get code execution one of the things

54
00:02:25,150 --> 00:02:30,460
that can kind of get in your way is

55
00:02:27,210 --> 00:02:32,440
address space layout if someone has been

56
00:02:30,460 --> 00:02:34,750
browsing a lot then when they go to

57
00:02:32,440 --> 00:02:37,510
visit your malicious page and execute

58
00:02:34,750 --> 00:02:39,610
your payload it may not work and it may

59
00:02:37,510 --> 00:02:41,380
crash because of the layout that

60
00:02:39,610 --> 00:02:45,520
happened to be just just the way things

61
00:02:41,380 --> 00:02:49,450
were just from running things for as a

62
00:02:45,520 --> 00:02:51,220
usual browser browser Safari will see

63
00:02:49,450 --> 00:02:53,679
that access violation and retry the

64
00:02:51,220 --> 00:02:55,990
entire page giving you a fresh chance on

65
00:02:53,680 --> 00:02:58,270
a fresh address space which is great for

66
00:02:55,990 --> 00:03:03,370
an exploitation standpoint and not good

67
00:02:58,270 --> 00:03:05,680
at all from a usability standpoint so I

68
00:03:03,370 --> 00:03:08,770
am Jaisal Spellman I usually go by

69
00:03:05,680 --> 00:03:10,360
wandering glitch most of this is pretty

70
00:03:08,770 --> 00:03:12,130
irrelevant and actually a little bit out

71
00:03:10,360 --> 00:03:14,650
of date the main thing to take away here

72
00:03:12,130 --> 00:03:16,690
is if you want to contact me if you're

73
00:03:14,650 --> 00:03:19,570
too afraid to ask questions at the end

74
00:03:16,690 --> 00:03:21,550
of this feel free to reach out and ping

75
00:03:19,570 --> 00:03:24,400
me on Twitter or wondering glitch at

76
00:03:21,550 --> 00:03:26,260
gmail.com or I'm on freenode and a bunch

77
00:03:24,400 --> 00:03:28,150
of other IRC servers as wandering glitch

78
00:03:26,260 --> 00:03:32,170
if you have any questions just feel free

79
00:03:28,150 --> 00:03:35,380
to reach out in general my my main task

80
00:03:32,170 --> 00:03:37,480
is vulnerability analysis I'm part of

81
00:03:35,380 --> 00:03:38,859
Trend Micro zero day initiative team if

82
00:03:37,480 --> 00:03:41,920
you've ever heard of the pwned own

83
00:03:38,860 --> 00:03:43,750
hacking competition that that's one of

84
00:03:41,920 --> 00:03:45,269
the things I run I help organize it we

85
00:03:43,750 --> 00:03:47,770
have another one coming up in two weeks

86
00:03:45,270 --> 00:03:49,420
two of the vulnerabilities that I'll be

87
00:03:47,770 --> 00:03:53,080
talking about were presented during

88
00:03:49,420 --> 00:03:55,988
couple of honda owns and it's about it

89
00:03:53,080 --> 00:03:57,850
also this is my second time in Brazil I

90
00:03:55,989 --> 00:03:59,459
was last here when I was 13 years old

91
00:03:57,850 --> 00:04:01,930
and I started loving guaraná Antarctica

92
00:03:59,459 --> 00:04:03,660
back then and I'm very glad to be back

93
00:04:01,930 --> 00:04:06,070
here so I can drink a lot of it here

94
00:04:03,660 --> 00:04:10,359
it's also helping me stay awake which is

95
00:04:06,070 --> 00:04:11,890
definitely a plus so an overview one of

96
00:04:10,360 --> 00:04:13,959
the questions I got when I was talking

97
00:04:11,890 --> 00:04:16,570
about this in my local hometown where we

98
00:04:13,959 --> 00:04:19,570
have a security meetup was why why am I

99
00:04:16,570 --> 00:04:21,488
giving this presentation and there's a

100
00:04:19,570 --> 00:04:23,950
quote that one of my co-workers gave

101
00:04:21,488 --> 00:04:26,219
Simon Zucker Braun also goes by hex

102
00:04:23,950 --> 00:04:28,469
kitchen he used to sell vulnerabilities

103
00:04:26,220 --> 00:04:30,090
to the CDI a team and all of his

104
00:04:28,470 --> 00:04:32,460
vulnerabilities were used after freeze

105
00:04:30,090 --> 00:04:34,770
in Internet Explorer and we kind of had

106
00:04:32,460 --> 00:04:36,390
this internal debate with really all of

107
00:04:34,770 --> 00:04:38,219
our research researchers but especially

108
00:04:36,390 --> 00:04:40,229
with him as to how he was finding his

109
00:04:38,220 --> 00:04:42,120
vulnerabilities because everything he

110
00:04:40,230 --> 00:04:43,740
was submitting to us was a very very

111
00:04:42,120 --> 00:04:45,120
clean proof of concept and you could

112
00:04:43,740 --> 00:04:47,370
tell that everything in the proof of

113
00:04:45,120 --> 00:04:49,710
concept was there because he knew it had

114
00:04:47,370 --> 00:04:52,350
to be there and then his write-ups

115
00:04:49,710 --> 00:04:53,969
clearly showed a great understanding of

116
00:04:52,350 --> 00:04:56,430
the vulnerability and all the components

117
00:04:53,970 --> 00:04:58,290
so when we hired him we finally got

118
00:04:56,430 --> 00:05:00,150
confirmation that that was the case and

119
00:04:58,290 --> 00:05:03,000
we requested that he give a presentation

120
00:05:00,150 --> 00:05:05,159
as to how he what his methodology was

121
00:05:03,000 --> 00:05:06,120
for finding use after freeze and one of

122
00:05:05,160 --> 00:05:07,920
the things he said during that

123
00:05:06,120 --> 00:05:09,780
presentation kind of stuck with me and

124
00:05:07,920 --> 00:05:13,410
that's browsers break perfectly normal

125
00:05:09,780 --> 00:05:14,940
C++ and he showed a snippet of C++ not

126
00:05:13,410 --> 00:05:17,220
the snippet but it was effectively the

127
00:05:14,940 --> 00:05:19,440
same where we have at this pointer that

128
00:05:17,220 --> 00:05:20,760
we're dereferencing we're accessing some

129
00:05:19,440 --> 00:05:22,770
member object and then we're

130
00:05:20,760 --> 00:05:24,659
dereferencing that and we're calling

131
00:05:22,770 --> 00:05:26,849
some function this is a pattern that you

132
00:05:24,660 --> 00:05:30,590
will see all over the place and all

133
00:05:26,850 --> 00:05:34,260
sorts of C++ code bases however if the

134
00:05:30,590 --> 00:05:36,239
C++ code base is also something that

135
00:05:34,260 --> 00:05:38,520
runs JavaScript this can be incredibly

136
00:05:36,240 --> 00:05:42,300
dangerous specifically because if this

137
00:05:38,520 --> 00:05:44,250
funk virtual function can call any sort

138
00:05:42,300 --> 00:05:47,930
of JavaScript in any user supplied code

139
00:05:44,250 --> 00:05:50,760
then we may end up freeing the M object

140
00:05:47,930 --> 00:05:53,010
pointer or we may free R this pointer

141
00:05:50,760 --> 00:05:54,719
out from under us such that subsequent

142
00:05:53,010 --> 00:05:57,320
operations are now acting on freed

143
00:05:54,720 --> 00:06:01,590
memory and we'll have a use after free

144
00:05:57,320 --> 00:06:03,990
in a very very similar way objects break

145
00:06:01,590 --> 00:06:06,270
perfectly normal JavaScript and objects

146
00:06:03,990 --> 00:06:08,760
are the bane of JIT anyone that saw

147
00:06:06,270 --> 00:06:10,200
natalie's talk last year yesterday would

148
00:06:08,760 --> 00:06:11,520
have seen at least it's a little bit

149
00:06:10,200 --> 00:06:13,890
this little bit of this while she was

150
00:06:11,520 --> 00:06:16,710
talking about web assembly specifically

151
00:06:13,890 --> 00:06:19,800
because of re-entrance e bugs so here we

152
00:06:16,710 --> 00:06:22,380
have the snippet of kind of worthless

153
00:06:19,800 --> 00:06:25,410
looking but innocuous for the most part

154
00:06:22,380 --> 00:06:28,680
looking javascript and this is a proof

155
00:06:25,410 --> 00:06:30,510
of concept that 362 who used during one

156
00:06:28,680 --> 00:06:34,560
of the phones I think a year and a half

157
00:06:30,510 --> 00:06:37,020
ago so we have this function go and it's

158
00:06:34,560 --> 00:06:39,120
doing some writes of some double values

159
00:06:37,020 --> 00:06:41,669
into this a variable

160
00:06:39,120 --> 00:06:43,560
a parameter it's reading one of those

161
00:06:41,669 --> 00:06:45,900
values and then writing it to the speed

162
00:06:43,560 --> 00:06:48,120
parameter and then it's writing this 2.3

163
00:06:45,900 --> 00:06:50,489
whatever floating-point value and then

164
00:06:48,120 --> 00:06:54,300
in the middle we have this math clz 32

165
00:06:50,490 --> 00:06:57,180
function call turns out that because of

166
00:06:54,300 --> 00:06:59,100
the way Safari works because of the way

167
00:06:57,180 --> 00:07:02,460
javascriptcore works if this function

168
00:06:59,100 --> 00:07:04,169
gets jaded math coz 32 will end up being

169
00:07:02,460 --> 00:07:06,060
a special function call called an

170
00:07:04,169 --> 00:07:07,349
intrinsic and I'll go go over all of

171
00:07:06,060 --> 00:07:08,520
this later I just want to cover it a

172
00:07:07,350 --> 00:07:10,710
little bit here

173
00:07:08,520 --> 00:07:13,049
and what will happen is it will do type

174
00:07:10,710 --> 00:07:14,789
coercion on the C parameter if it's not

175
00:07:13,050 --> 00:07:17,190
already an integer or a floating point

176
00:07:14,789 --> 00:07:18,690
value when that happens you're able to

177
00:07:17,190 --> 00:07:21,630
break assumptions that have been made

178
00:07:18,690 --> 00:07:24,690
such that when you read out from a and

179
00:07:21,630 --> 00:07:26,520
when you write out to array two you end

180
00:07:24,690 --> 00:07:28,620
up being able to trigger type type

181
00:07:26,520 --> 00:07:35,219
confusion and you can get an info leak

182
00:07:28,620 --> 00:07:38,490
as well as a and so if we call math dlz

183
00:07:35,220 --> 00:07:40,860
32 with a with an object rather than a

184
00:07:38,490 --> 00:07:42,690
integer or a floating point value any

185
00:07:40,860 --> 00:07:45,930
object that has a custom to string or a

186
00:07:42,690 --> 00:07:47,340
value of function then will end up being

187
00:07:45,930 --> 00:07:48,840
able to break assumptions and

188
00:07:47,340 --> 00:07:51,479
specifically be able to trigger type

189
00:07:48,840 --> 00:07:53,250
confusion there's one particular aspect

190
00:07:51,479 --> 00:07:54,990
about JavaScript core that makes a lot

191
00:07:53,250 --> 00:07:57,180
of these vulnerabilities very very easy

192
00:07:54,990 --> 00:07:59,450
to exploit and I'll cover that in a

193
00:07:57,180 --> 00:08:02,010
little bit but basically

194
00:07:59,450 --> 00:08:03,419
innocuous-looking javascript can be very

195
00:08:02,010 --> 00:08:05,310
very vulnerable and can be triggering

196
00:08:03,419 --> 00:08:08,510
all sorts of interesting things because

197
00:08:05,310 --> 00:08:10,740
of the way that the cheat engine works

198
00:08:08,510 --> 00:08:12,900
so now I'm going to cover a little bit

199
00:08:10,740 --> 00:08:14,880
of the JavaScript core architecture and

200
00:08:12,900 --> 00:08:16,138
I'm gonna be glossing over a whole lot

201
00:08:14,880 --> 00:08:19,320
of it because there's a lot of it that

202
00:08:16,139 --> 00:08:20,520
we just don't care about main things I'm

203
00:08:19,320 --> 00:08:22,260
going to cover are gonna be the things

204
00:08:20,520 --> 00:08:23,490
that are specific to understanding the

205
00:08:22,260 --> 00:08:27,419
vulnerabilities and triggering the

206
00:08:23,490 --> 00:08:29,580
vulnerabilities so in JavaScript core

207
00:08:27,419 --> 00:08:33,270
there's a notion of a j/s value which is

208
00:08:29,580 --> 00:08:35,549
a overloaded value and these are all

209
00:08:33,270 --> 00:08:38,039
tagged and boxed values what that means

210
00:08:35,549 --> 00:08:40,199
is they're not a number values and

211
00:08:38,039 --> 00:08:42,020
they're tagged such that you have some

212
00:08:40,200 --> 00:08:44,640
type information that's put into

213
00:08:42,020 --> 00:08:46,920
basically the pointer so if the upper

214
00:08:44,640 --> 00:08:48,390
two bytes are all 0 then the rest of the

215
00:08:46,920 --> 00:08:49,979
value can be treated as a pointer

216
00:08:48,390 --> 00:08:51,660
basically it'll do a quick test to see

217
00:08:49,980 --> 00:08:53,790
if the upper two bytes are 0

218
00:08:51,660 --> 00:08:55,019
and if not or if so then it will

219
00:08:53,790 --> 00:08:57,449
dereference it as if it's a normal

220
00:08:55,019 --> 00:08:59,940
pointer and continue on its merry way

221
00:08:57,449 --> 00:09:02,459
if we then look at the sign integer form

222
00:08:59,940 --> 00:09:04,920
if the upper two bytes are ffff and the

223
00:09:02,459 --> 00:09:06,810
next two bytes are 0 0 0 0 then the

224
00:09:04,920 --> 00:09:09,209
lower half of the value can be treated

225
00:09:06,810 --> 00:09:11,699
as a 32-bit signed integer and then if

226
00:09:09,209 --> 00:09:15,420
the upper 2 bytes are anywhere from 0 0

227
00:09:11,699 --> 00:09:18,449
0 1 2 fffe then the entire thing can be

228
00:09:15,420 --> 00:09:19,920
treated as a double doubles are kind of

229
00:09:18,449 --> 00:09:22,490
special in the way that they have to be

230
00:09:19,920 --> 00:09:25,469
handled and that's specifically because

231
00:09:22,490 --> 00:09:27,899
this very large value has to be added to

232
00:09:25,470 --> 00:09:29,610
it the reason that value has to be added

233
00:09:27,899 --> 00:09:31,860
to it is because there are double values

234
00:09:29,610 --> 00:09:33,930
that can look like pointers and that

235
00:09:31,860 --> 00:09:35,879
fact alone is what makes a lot of these

236
00:09:33,930 --> 00:09:38,040
bugs very exploitable I'll give an

237
00:09:35,879 --> 00:09:41,040
example of just why that can be very bad

238
00:09:38,040 --> 00:09:44,730
in a few slides but if we have a pointer

239
00:09:41,040 --> 00:09:46,290
to ABCD 1 2 3 4 5 6 7 8 then the upper

240
00:09:44,730 --> 00:09:49,290
two bytes will be null and the rest will

241
00:09:46,290 --> 00:09:51,660
be that pointer value if we have a sign

242
00:09:49,290 --> 00:09:53,639
integer that we want to represent and in

243
00:09:51,660 --> 00:09:56,670
this case we want 1 then the upper half

244
00:09:53,639 --> 00:09:57,899
will be the ffff 0 0 0 0 and then the

245
00:09:56,670 --> 00:10:00,630
lower half will be where the signed

246
00:09:57,899 --> 00:10:02,130
integer is and then if we have a double

247
00:10:00,630 --> 00:10:04,949
value it's going to be whatever the

248
00:10:02,130 --> 00:10:08,699
double value is with 1 added so 1.5 is

249
00:10:04,949 --> 00:10:10,258
actually represented by 3 FF 8 and then

250
00:10:08,699 --> 00:10:11,849
a bunch of nulls but because it's a

251
00:10:10,259 --> 00:10:14,790
double because this is a tagged form

252
00:10:11,850 --> 00:10:18,569
it's actually being represented as 3 FF

253
00:10:14,790 --> 00:10:21,689
9 the next very important thing to

254
00:10:18,569 --> 00:10:23,729
understand our arrays and there are five

255
00:10:21,689 --> 00:10:25,259
or six different types of arrays in

256
00:10:23,730 --> 00:10:28,170
JavaScript core I'm going to talk about

257
00:10:25,259 --> 00:10:30,720
three of them specifically two of them

258
00:10:28,170 --> 00:10:32,189
are very very important and not actually

259
00:10:30,720 --> 00:10:35,189
this one but it's useful to know this

260
00:10:32,189 --> 00:10:37,980
one anyway this one is an array within

261
00:10:35,189 --> 00:10:40,589
32 which as the name kind of says is an

262
00:10:37,980 --> 00:10:43,019
array with signed integers sign 32-bit

263
00:10:40,589 --> 00:10:46,889
integers so we create it with new array

264
00:10:43,019 --> 00:10:48,480
one two and then the upper half of every

265
00:10:46,889 --> 00:10:50,250
value in this array is going to be

266
00:10:48,480 --> 00:10:52,649
completely worthless because all of its

267
00:10:50,250 --> 00:10:54,269
going to be FF FF 0 0 0 0

268
00:10:52,649 --> 00:10:57,269
but then the lower half will be that

269
00:10:54,269 --> 00:11:01,410
sign integer value sign 32-bit integer

270
00:10:57,269 --> 00:11:03,389
value now we have array with double this

271
00:11:01,410 --> 00:11:04,270
is the this is basically the most

272
00:11:03,389 --> 00:11:06,070
important format

273
00:11:04,270 --> 00:11:09,280
because all of the values here are

274
00:11:06,070 --> 00:11:11,200
stored in their native double form so

275
00:11:09,280 --> 00:11:13,089
one point five and then two point five

276
00:11:11,200 --> 00:11:15,250
are the two values we're placing in this

277
00:11:13,090 --> 00:11:17,800
array with double and we're being

278
00:11:15,250 --> 00:11:19,900
represented by three FF 8 and 4 0 0 4

279
00:11:17,800 --> 00:11:22,630
whereas in the previous slide I did

280
00:11:19,900 --> 00:11:24,790
mention that 3 FF 9 is the tagged format

281
00:11:22,630 --> 00:11:28,450
3 FF 8 is the native format and how it

282
00:11:24,790 --> 00:11:29,589
gets stored the last rate type I'm going

283
00:11:28,450 --> 00:11:33,130
to talk about is an array with

284
00:11:29,590 --> 00:11:35,160
contiguous despite its name all 3 rate

285
00:11:33,130 --> 00:11:38,170
types here are all continued

286
00:11:35,160 --> 00:11:40,420
contiguously allocated it's just named

287
00:11:38,170 --> 00:11:43,329
that because I don't actually know why

288
00:11:40,420 --> 00:11:47,260
it's kind of an overloaded term and what

289
00:11:43,330 --> 00:11:50,010
means is that this will have JavaScript

290
00:11:47,260 --> 00:11:53,560
types we're sorry object types of all

291
00:11:50,010 --> 00:11:56,260
you'll have JavaScript variables of all

292
00:11:53,560 --> 00:12:01,030
types so objects integers and doubles

293
00:11:56,260 --> 00:12:03,010
and there are also transitions from one

294
00:12:01,030 --> 00:12:06,310
array type to another so if we have this

295
00:12:03,010 --> 00:12:09,370
array within 32 and we write an object

296
00:12:06,310 --> 00:12:11,349
to it then that first value is going to

297
00:12:09,370 --> 00:12:14,460
stay the same but now this array isn't

298
00:12:11,350 --> 00:12:17,460
going to be considered a array with

299
00:12:14,460 --> 00:12:17,460
contiguous

300
00:12:23,860 --> 00:12:28,939
if we do the same thing with the array

301
00:12:26,149 --> 00:12:32,839
with double Weir we perform a right to

302
00:12:28,939 --> 00:12:34,730
the first index will also convert from

303
00:12:32,839 --> 00:12:36,889
an array with double into an array with

304
00:12:34,730 --> 00:12:39,439
contiguous but note that the three ff8

305
00:12:36,889 --> 00:12:41,959
is now becoming at three ff9 and just to

306
00:12:39,439 --> 00:12:44,599
drive that very very much into

307
00:12:41,959 --> 00:12:46,638
everyone's mind here we have an array

308
00:12:44,600 --> 00:12:49,459
with five point six seven blah and then

309
00:12:46,639 --> 00:12:51,740
two point five and then if we look at it

310
00:12:49,459 --> 00:12:53,839
that's six point or sixty eight sixty

311
00:12:51,740 --> 00:12:55,370
three seventy four so on so forth that

312
00:12:53,839 --> 00:12:57,769
could be interpreted as a pointer

313
00:12:55,370 --> 00:13:00,259
because the upper two values are upper

314
00:12:57,769 --> 00:13:01,459
two bytes are completely null but this

315
00:13:00,259 --> 00:13:04,579
is an array with double and so the

316
00:13:01,459 --> 00:13:06,529
engine itself knows not to do that if we

317
00:13:04,579 --> 00:13:08,269
then perform that right where we're now

318
00:13:06,529 --> 00:13:10,060
converting it from an array would double

319
00:13:08,269 --> 00:13:12,259
to an array with contiguous it adds one

320
00:13:10,060 --> 00:13:13,849
specifically so it knows never to

321
00:13:12,259 --> 00:13:15,230
dereference that because that is not

322
00:13:13,850 --> 00:13:18,829
something that should be safely

323
00:13:15,230 --> 00:13:20,569
dereferenced now I'm gonna give kind of

324
00:13:18,829 --> 00:13:23,120
an execution timeline this is how

325
00:13:20,569 --> 00:13:25,040
JavaScript goes from being executed or

326
00:13:23,120 --> 00:13:27,529
being seen by the browser and then

327
00:13:25,040 --> 00:13:29,120
executed by the engine itself goes

328
00:13:27,529 --> 00:13:32,170
through a parser which has a parser and

329
00:13:29,120 --> 00:13:34,910
a lexer it goes from there it gets

330
00:13:32,170 --> 00:13:37,040
converted into an abstract syntax tree

331
00:13:34,910 --> 00:13:39,050
which then goes to the bike compiler the

332
00:13:37,040 --> 00:13:40,969
bike compiler will then emit byte codes

333
00:13:39,050 --> 00:13:42,949
that will go into the low-level

334
00:13:40,970 --> 00:13:44,899
interpreter the low-level interpreter is

335
00:13:42,949 --> 00:13:48,349
the first piece to actually execute any

336
00:13:44,899 --> 00:13:50,120
of the JavaScript that it sees it then

337
00:13:48,350 --> 00:13:52,430
goes into what's called the JIT which is

338
00:13:50,120 --> 00:13:54,350
the baseline JIT despite the name it

339
00:13:52,430 --> 00:13:56,388
doesn't actually do any real performance

340
00:13:54,350 --> 00:13:59,600
speed up here it's just the name they

341
00:13:56,389 --> 00:14:01,309
chose after that is this the fastest

342
00:13:59,600 --> 00:14:02,600
sublight engine it's called the data

343
00:14:01,309 --> 00:14:04,399
flow graph

344
00:14:02,600 --> 00:14:05,959
where a lot of optimizations actually

345
00:14:04,399 --> 00:14:08,959
happen and a lot of vulnerabilities

346
00:14:05,959 --> 00:14:11,258
exist and then finally there's the FTL

347
00:14:08,959 --> 00:14:13,579
which stands for faster than light and

348
00:14:11,259 --> 00:14:16,399
just going a little bit more deep into

349
00:14:13,579 --> 00:14:18,739
each of those we start off with the

350
00:14:16,399 --> 00:14:20,600
parser which has a lexer and parser the

351
00:14:18,740 --> 00:14:23,029
lexer just converts scripts into tokens

352
00:14:20,600 --> 00:14:24,529
and the parser will convert the tokens

353
00:14:23,029 --> 00:14:26,720
into the syntax tree and this is also

354
00:14:24,529 --> 00:14:29,240
where any sort of grammar enforcement

355
00:14:26,720 --> 00:14:31,009
occurs so you can't just have some

356
00:14:29,240 --> 00:14:33,100
JavaScript that says like throw try

357
00:14:31,009 --> 00:14:34,750
catch finally

358
00:14:33,100 --> 00:14:38,890
it'll catch it right here and it'll

359
00:14:34,750 --> 00:14:41,980
break it out here one thing is I've not

360
00:14:38,890 --> 00:14:43,930
seen any real security vulnerabilities

361
00:14:41,980 --> 00:14:46,960
here I don't necessarily know that

362
00:14:43,930 --> 00:14:49,120
that's that's actually accurate

363
00:14:46,960 --> 00:14:52,240
however because WebKit does office gate

364
00:14:49,120 --> 00:14:53,980
commits of my vulnerabilities that I've

365
00:14:52,240 --> 00:14:55,930
submitted to WebKit if you were just

366
00:14:53,980 --> 00:14:57,370
looking at the commit tree you would not

367
00:14:55,930 --> 00:14:58,599
actually know for sure that their

368
00:14:57,370 --> 00:15:00,250
vulnerability is because there's no

369
00:14:58,600 --> 00:15:02,260
information they would actually tell you

370
00:15:00,250 --> 00:15:04,000
it just makes it look like they're

371
00:15:02,260 --> 00:15:06,670
fixing some random bug that they came

372
00:15:04,000 --> 00:15:07,930
across so it's possible that I missed

373
00:15:06,670 --> 00:15:11,199
something in one of the commits I was

374
00:15:07,930 --> 00:15:13,449
going through all right the bike

375
00:15:11,200 --> 00:15:15,010
compiler as I was saying was is going to

376
00:15:13,450 --> 00:15:17,470
consume the abstract syntax tree and

377
00:15:15,010 --> 00:15:20,710
then produce internal byte code there's

378
00:15:17,470 --> 00:15:22,270
not much to it that it's interesting

379
00:15:20,710 --> 00:15:23,700
from a security point of view however

380
00:15:22,270 --> 00:15:26,319
there have been vulnerabilities here

381
00:15:23,700 --> 00:15:28,360
that said they've chosen not to patch it

382
00:15:26,320 --> 00:15:30,520
here but instead choose it where the

383
00:15:28,360 --> 00:15:32,350
byte codes being acted upon rather than

384
00:15:30,520 --> 00:15:34,990
where it's being created I don't know

385
00:15:32,350 --> 00:15:38,830
why they've chosen that but that that's

386
00:15:34,990 --> 00:15:40,510
just what they've done and then finally

387
00:15:38,830 --> 00:15:42,340
we're down to the low level interpreter

388
00:15:40,510 --> 00:15:45,250
where execution of JavaScript is

389
00:15:42,340 --> 00:15:47,530
actually happening there dot there not

390
00:15:45,250 --> 00:15:49,990
caring at all about executing anything

391
00:15:47,530 --> 00:15:52,180
quickly because their entire goal here

392
00:15:49,990 --> 00:15:54,310
is to start execution as soon as

393
00:15:52,180 --> 00:15:57,310
possible so basically start up the

394
00:15:54,310 --> 00:15:59,560
engine with very very lightweight code

395
00:15:57,310 --> 00:16:02,380
and then start running is whatever

396
00:15:59,560 --> 00:16:05,560
bytecode they can as they can it won't

397
00:16:02,380 --> 00:16:07,300
run very performant at all but they will

398
00:16:05,560 --> 00:16:13,390
collect some data so that they can then

399
00:16:07,300 --> 00:16:15,370
run other layers faster yes one crucial

400
00:16:13,390 --> 00:16:17,860
thing about this and the other layers is

401
00:16:15,370 --> 00:16:19,780
that they all share a calling convention

402
00:16:17,860 --> 00:16:22,270
because you can be in one function that

403
00:16:19,780 --> 00:16:24,069
is being executed at all four engines

404
00:16:22,270 --> 00:16:26,439
basically at the same time or a

405
00:16:24,070 --> 00:16:28,780
different level levels in the stack the

406
00:16:26,440 --> 00:16:30,730
way they do this is something called the

407
00:16:28,780 --> 00:16:33,220
OSR entry and exit which stands for on

408
00:16:30,730 --> 00:16:34,890
stack replacement and they all share a

409
00:16:33,220 --> 00:16:37,270
calling convention to allow for this

410
00:16:34,890 --> 00:16:39,640
tier up is going to happen based on

411
00:16:37,270 --> 00:16:41,590
metrics and those metrics are going to

412
00:16:39,640 --> 00:16:43,090
be function hit count and then loop hit

413
00:16:41,590 --> 00:16:44,620
count so if you have a function that

414
00:16:43,090 --> 00:16:46,420
gets called over and over again that's

415
00:16:44,620 --> 00:16:46,840
going to affect it if you have a loop

416
00:16:46,420 --> 00:16:48,370
within

417
00:16:46,840 --> 00:16:49,890
that function that's being cold then

418
00:16:48,370 --> 00:16:52,210
that's going to affect it even further

419
00:16:49,890 --> 00:16:54,670
and again because the low-level

420
00:16:52,210 --> 00:16:58,960
interpreter is designed specifically to

421
00:16:54,670 --> 00:17:01,630
execute by code rather than to execute

422
00:16:58,960 --> 00:17:03,850
it quickly rather than fast it also

423
00:17:01,630 --> 00:17:05,530
performs JIT on another thread so that

424
00:17:03,850 --> 00:17:09,880
this is all done without the user

425
00:17:05,530 --> 00:17:11,319
noticing once we tear up from the

426
00:17:09,880 --> 00:17:13,420
low-level interpreter we'll hit the

427
00:17:11,319 --> 00:17:16,960
baseline JIT and the baseline JIT is

428
00:17:13,420 --> 00:17:18,670
only going to optimize function calls so

429
00:17:16,960 --> 00:17:21,310
if you have any sort of JavaScript that

430
00:17:18,670 --> 00:17:23,110
does a lot of math or does like string

431
00:17:21,310 --> 00:17:25,450
manipulations you're not going to get

432
00:17:23,109 --> 00:17:27,639
any benefit whatsoever from this tier

433
00:17:25,450 --> 00:17:28,630
however if you call JavaScript that is

434
00:17:27,640 --> 00:17:30,850
making a lot of function calls

435
00:17:28,630 --> 00:17:32,950
especially function calls that end up

436
00:17:30,850 --> 00:17:34,480
calling native code you'll get a huge

437
00:17:32,950 --> 00:17:35,950
benefit from here

438
00:17:34,480 --> 00:17:37,630
additionally like the low-level

439
00:17:35,950 --> 00:17:42,400
interpreter this will collect data to

440
00:17:37,630 --> 00:17:44,440
feed to the faster engines now we're on

441
00:17:42,400 --> 00:17:46,000
to the data flow graph and this is the

442
00:17:44,440 --> 00:17:48,610
fastest sublight engine is the most

443
00:17:46,000 --> 00:17:50,920
interesting engine at least to me out of

444
00:17:48,610 --> 00:17:52,750
all of them where it'll apply classic

445
00:17:50,920 --> 00:17:54,520
compiler optimizations and I'll show an

446
00:17:52,750 --> 00:17:56,320
example of this in a little bit

447
00:17:54,520 --> 00:17:58,060
it'll optimize certain function calls I

448
00:17:56,320 --> 00:18:00,550
kind of touched upon this when I was

449
00:17:58,060 --> 00:18:02,679
talking about math coz 32 and that

450
00:18:00,550 --> 00:18:04,389
beginning of slide and then it'll also

451
00:18:02,680 --> 00:18:06,670
do things like bounds checking removal

452
00:18:04,390 --> 00:18:09,300
and array type check removal which may

453
00:18:06,670 --> 00:18:12,370
seem dangerous at first because it is

454
00:18:09,300 --> 00:18:14,350
but there are safe ways of doing it and

455
00:18:12,370 --> 00:18:16,239
there are reasons to do it while

456
00:18:14,350 --> 00:18:20,500
actually caring about performance and

457
00:18:16,240 --> 00:18:22,870
security so here's just a very basic

458
00:18:20,500 --> 00:18:25,240
snippet of JavaScript we have a function

459
00:18:22,870 --> 00:18:26,979
bar takes a parameter X and then we have

460
00:18:25,240 --> 00:18:29,320
a for loop that's going to iterate ten

461
00:18:26,980 --> 00:18:32,760
times and it basically initialize an

462
00:18:29,320 --> 00:18:36,129
array with I plus 3 times 456 times X

463
00:18:32,760 --> 00:18:38,200
when the JIT sees this it'll see the

464
00:18:36,130 --> 00:18:40,960
three times 456 times X and then

465
00:18:38,200 --> 00:18:43,120
immediately convert that over to 1368

466
00:18:40,960 --> 00:18:47,500
times X and then I'll see that hey we

467
00:18:43,120 --> 00:18:49,239
don't actually use the 1368 times X

468
00:18:47,500 --> 00:18:51,070
doesn't depend on anything inside the

469
00:18:49,240 --> 00:18:54,490
loop so we can hoist it outside the loop

470
00:18:51,070 --> 00:18:56,560
and continue executing although this is

471
00:18:54,490 --> 00:18:59,020
a very basic example the main reason to

472
00:18:56,560 --> 00:19:00,429
show this is the DFG is going to or it's

473
00:18:59,020 --> 00:19:04,270
capable and

474
00:19:00,430 --> 00:19:06,100
to move code around which can be very

475
00:19:04,270 --> 00:19:10,300
very dangerous it can also be very very

476
00:19:06,100 --> 00:19:12,280
performance just trying to make it very

477
00:19:10,300 --> 00:19:13,930
very clear and aware that there are

478
00:19:12,280 --> 00:19:17,100
cases where it's going to do some

479
00:19:13,930 --> 00:19:19,870
interesting things to your JavaScript

480
00:19:17,100 --> 00:19:21,909
this is an example of one of the

481
00:19:19,870 --> 00:19:25,510
function calls that it optimizes this is

482
00:19:21,910 --> 00:19:28,300
math tlz 32 in the top part of the image

483
00:19:25,510 --> 00:19:30,580
we have probably not very readable it's

484
00:19:28,300 --> 00:19:32,230
okay that's from the runtime where it's

485
00:19:30,580 --> 00:19:33,850
basically defining the function and

486
00:19:32,230 --> 00:19:35,440
defining how it goes and it's just

487
00:19:33,850 --> 00:19:38,230
saying that hey this function has an

488
00:19:35,440 --> 00:19:40,300
intrinsic it has a version that is going

489
00:19:38,230 --> 00:19:43,450
to be far more optimized and far faster

490
00:19:40,300 --> 00:19:45,250
to run at the bottom we have a snippet

491
00:19:43,450 --> 00:19:47,470
of code from the DF cheese bytecode

492
00:19:45,250 --> 00:19:50,490
parser what's going through and seeing

493
00:19:47,470 --> 00:19:53,170
hey we have a clz 32 intrinsic being

494
00:19:50,490 --> 00:19:56,650
being executed or being used in this

495
00:19:53,170 --> 00:20:00,010
function in this particular case it has

496
00:19:56,650 --> 00:20:02,230
an explicit check to see if math dlz 32

497
00:20:00,010 --> 00:20:03,760
is being called with no argument at

498
00:20:02,230 --> 00:20:06,040
which plate at which point it's going to

499
00:20:03,760 --> 00:20:09,490
replace the call with a constant value

500
00:20:06,040 --> 00:20:11,440
of 32 otherwise it's going to call it's

501
00:20:09,490 --> 00:20:13,240
going to add a bytecode for a riff clz

502
00:20:11,440 --> 00:20:17,410
32 and use whatever argument was

503
00:20:13,240 --> 00:20:20,050
specified and then here I'm going to

504
00:20:17,410 --> 00:20:22,990
just talk about the array type check

505
00:20:20,050 --> 00:20:25,480
removal and the bounds checking removal

506
00:20:22,990 --> 00:20:27,790
so on the left side we have function bar

507
00:20:25,480 --> 00:20:30,970
and we have six rights that were

508
00:20:27,790 --> 00:20:32,950
performing to it if we go through normal

509
00:20:30,970 --> 00:20:35,680
JavaScript we're gonna hit array 0 and

510
00:20:32,950 --> 00:20:38,530
set it to 1.1 and it's gonna check is

511
00:20:35,680 --> 00:20:41,350
the array actually larger than 1 when we

512
00:20:38,530 --> 00:20:43,000
hit array index 1 and right to point 2

513
00:20:41,350 --> 00:20:45,040
it's gonna check hey is it greater than

514
00:20:43,000 --> 00:20:47,860
2 so on and so forth we're gonna end up

515
00:20:45,040 --> 00:20:50,530
with 6 array length checks for these

516
00:20:47,860 --> 00:20:52,990
rights when it goes through the DFG JIT

517
00:20:50,530 --> 00:20:55,480
it's gonna see we have 6 rights and it's

518
00:20:52,990 --> 00:20:57,490
going to do 1 check and just do one

519
00:20:55,480 --> 00:20:59,230
comparison because after that it can

520
00:20:57,490 --> 00:21:01,630
bail out and throw an exception or

521
00:20:59,230 --> 00:21:03,100
whatever based on those values but it

522
00:21:01,630 --> 00:21:04,750
only has to grab the length and do that

523
00:21:03,100 --> 00:21:07,149
comparison once as opposed to doing it

524
00:21:04,750 --> 00:21:09,940
for each operation on the right side we

525
00:21:07,150 --> 00:21:11,560
have bar this time taking in an argument

526
00:21:09,940 --> 00:21:13,960
and we're doing basically the same thing

527
00:21:11,560 --> 00:21:15,129
but here it's going to see that hey

528
00:21:13,960 --> 00:21:17,500
we're right

529
00:21:15,130 --> 00:21:19,630
we can do one check of the array at the

530
00:21:17,500 --> 00:21:21,550
beginning of the function see if we're

531
00:21:19,630 --> 00:21:24,040
operating on array with double that way

532
00:21:21,550 --> 00:21:27,580
we know whether or not we have to write

533
00:21:24,040 --> 00:21:30,310
1.1 as a tagged pointer with by adding

534
00:21:27,580 --> 00:21:31,740
that one zero zero zero value or if we

535
00:21:30,310 --> 00:21:34,149
can use the native format

536
00:21:31,740 --> 00:21:35,950
additionally we don't know what X is but

537
00:21:34,150 --> 00:21:38,230
we can do a type check on it and then

538
00:21:35,950 --> 00:21:41,500
afterwards when we're writing to Ray

539
00:21:38,230 --> 00:21:43,780
index for the 5.5 value we can either

540
00:21:41,500 --> 00:21:45,400
then write a tagged value or a non

541
00:21:43,780 --> 00:21:48,399
tagged value depending on whether or not

542
00:21:45,400 --> 00:21:50,740
that write from X coerced it into an

543
00:21:48,400 --> 00:21:52,600
array with contiguous or not and this is

544
00:21:50,740 --> 00:21:54,880
just some of the stuff that DFG has to

545
00:21:52,600 --> 00:21:57,730
keep track of and the way it does at

546
00:21:54,880 --> 00:22:01,270
least some of this is with the two

547
00:21:57,730 --> 00:22:04,000
different giant switch statements one is

548
00:22:01,270 --> 00:22:07,540
in DFG clobber eyes and then one is in

549
00:22:04,000 --> 00:22:09,310
DFT abstract interpreter DFT clobber

550
00:22:07,540 --> 00:22:11,409
eyes will attempt to safely model

551
00:22:09,310 --> 00:22:13,899
actually both attempt to safely model

552
00:22:11,410 --> 00:22:16,900
all the operations of any byte code that

553
00:22:13,900 --> 00:22:19,210
it tries to execute the worst cases are

554
00:22:16,900 --> 00:22:21,820
shown here where you have some switch

555
00:22:19,210 --> 00:22:25,120
case statements and then you end up in a

556
00:22:21,820 --> 00:22:27,159
call to read world and write heap or you

557
00:22:25,120 --> 00:22:29,199
end up in a call to clobber world the

558
00:22:27,160 --> 00:22:31,950
read world right he basically says we

559
00:22:29,200 --> 00:22:35,020
have no idea what this operation can do

560
00:22:31,950 --> 00:22:37,000
assume it will destroy everything and

561
00:22:35,020 --> 00:22:39,010
that we possibly have a reference to

562
00:22:37,000 --> 00:22:40,960
assume that will read everything we may

563
00:22:39,010 --> 00:22:43,510
have a reference to and the whole thing

564
00:22:40,960 --> 00:22:45,430
here is basically no links are to be

565
00:22:43,510 --> 00:22:47,170
trusted after this so if we grabbed an

566
00:22:45,430 --> 00:22:49,510
array length before this we need to

567
00:22:47,170 --> 00:22:52,240
regrow bit again if we have access to

568
00:22:49,510 --> 00:22:54,460
some objects property bag or a structure

569
00:22:52,240 --> 00:22:56,740
we need to regrow bit because all of it

570
00:22:54,460 --> 00:22:59,320
may be invalidated the clobber world

571
00:22:56,740 --> 00:23:01,450
basically says hey we previously thought

572
00:22:59,320 --> 00:23:03,010
that this function or this array was an

573
00:23:01,450 --> 00:23:04,780
array with double it was already with

574
00:23:03,010 --> 00:23:06,580
contiguous we need to recheck all of

575
00:23:04,780 --> 00:23:09,370
that afterwards because it may have

576
00:23:06,580 --> 00:23:12,429
changed around us I have no idea why

577
00:23:09,370 --> 00:23:15,399
they chose to have this handled in a

578
00:23:12,430 --> 00:23:17,680
number of switch statements because

579
00:23:15,400 --> 00:23:20,740
there's another one for whether or not

580
00:23:17,680 --> 00:23:22,630
an operation can initiate garbage

581
00:23:20,740 --> 00:23:24,970
collection there's several others

582
00:23:22,630 --> 00:23:26,920
similar to this and I there would have

583
00:23:24,970 --> 00:23:27,730
been cleaner ways to do it specifically

584
00:23:26,920 --> 00:23:29,310
because

585
00:23:27,730 --> 00:23:33,310
some of the vulnerabilities that have

586
00:23:29,310 --> 00:23:36,010
arisen have arisen because of mismatches

587
00:23:33,310 --> 00:23:39,190
between the DFG collaborize and the DFG

588
00:23:36,010 --> 00:23:41,800
abstract interpreter where basically one

589
00:23:39,190 --> 00:23:43,210
was properly modeling and of the effect

590
00:23:41,800 --> 00:23:47,230
of something whereas the other wasn't

591
00:23:43,210 --> 00:23:49,720
they've recently as in as of May maybe

592
00:23:47,230 --> 00:23:51,430
March started trying to track this but

593
00:23:49,720 --> 00:23:53,800
they started tracking it using dynamic

594
00:23:51,430 --> 00:23:55,390
instrumentation and only for debug

595
00:23:53,800 --> 00:23:56,800
builds that there they themselves are

596
00:23:55,390 --> 00:23:58,390
running so unless one of their tests

597
00:23:56,800 --> 00:24:07,540
catches it there's going to be a lot

598
00:23:58,390 --> 00:24:10,210
that they're going to miss all right the

599
00:24:07,540 --> 00:24:13,360
last back end is the or the last engine

600
00:24:10,210 --> 00:24:15,610
is the faster-than-light engine it

601
00:24:13,360 --> 00:24:19,479
currently uses a special back-end known

602
00:24:15,610 --> 00:24:22,240
as b3 or the bare-bones back-end it used

603
00:24:19,480 --> 00:24:25,480
to use LLVM but what they found is that

604
00:24:22,240 --> 00:24:27,490
LLVM is much better at optimizing entire

605
00:24:25,480 --> 00:24:30,880
functions rather than single functions

606
00:24:27,490 --> 00:24:33,480
at a time so they wrote b3 specifically

607
00:24:30,880 --> 00:24:35,980
to optimize small functions at a time

608
00:24:33,480 --> 00:24:38,320
web assembly will compile straight to b3

609
00:24:35,980 --> 00:24:39,850
and there have only been a couple of

610
00:24:38,320 --> 00:24:42,159
owner abilities here but one thing to

611
00:24:39,850 --> 00:24:45,340
note is that all integers at this level

612
00:24:42,160 --> 00:24:47,320
are signed and I'll they'll be very very

613
00:24:45,340 --> 00:24:50,050
important in a second I don't know why

614
00:24:47,320 --> 00:24:51,820
they made that decision but it it's

615
00:24:50,050 --> 00:24:55,870
strange and that's just what they went

616
00:24:51,820 --> 00:24:59,409
with so the first vulnerability I'm

617
00:24:55,870 --> 00:25:02,020
going to talk about is CVE 2017 two five

618
00:24:59,410 --> 00:25:04,600
four seven this is a vulnerability that

619
00:25:02,020 --> 00:25:07,030
was found by $0.10 and then used in home

620
00:25:04,600 --> 00:25:10,629
to own it was also found by a low key

621
00:25:07,030 --> 00:25:13,060
heart of project zero just a general

622
00:25:10,630 --> 00:25:16,470
buck collision I think he found it after

623
00:25:13,060 --> 00:25:18,669
it was after the contest anyway and

624
00:25:16,470 --> 00:25:20,950
whenever I see a proof of concept even

625
00:25:18,670 --> 00:25:23,440
if I already have details I try to

626
00:25:20,950 --> 00:25:26,170
ignore whatever the researcher has given

627
00:25:23,440 --> 00:25:27,880
me and I try to go from the crash and

628
00:25:26,170 --> 00:25:30,130
from the proof of concept just because

629
00:25:27,880 --> 00:25:32,410
it it makes it better for me to

630
00:25:30,130 --> 00:25:34,630
understand what's going on and it's just

631
00:25:32,410 --> 00:25:36,160
easier for me in general and so if we

632
00:25:34,630 --> 00:25:39,040
look at this we have a crash and one

633
00:25:36,160 --> 00:25:41,590
thing that should be noted is that we

634
00:25:39,040 --> 00:25:43,990
have a crash at 41 41 41 41

635
00:25:41,590 --> 00:25:45,879
a bunch of a's if we look at the proof

636
00:25:43,990 --> 00:25:47,890
of concept the one thing that stands out

637
00:25:45,880 --> 00:25:52,690
is that there are no a is anywhere in

638
00:25:47,890 --> 00:25:54,789
here but we can continue on and if we

639
00:25:52,690 --> 00:25:57,789
look at it we have this bar function

640
00:25:54,789 --> 00:25:59,890
being called 5,000 times and then inside

641
00:25:57,789 --> 00:26:02,470
the bar function we have this loop

642
00:25:59,890 --> 00:26:04,360
that's going to iterate 20,000 times and

643
00:26:02,470 --> 00:26:06,340
we have a subtraction that's being done

644
00:26:04,360 --> 00:26:08,408
but it seems rather pointless because

645
00:26:06,340 --> 00:26:10,809
the value is not actually saved the

646
00:26:08,409 --> 00:26:16,110
whole reason for this is to trigger the

647
00:26:10,809 --> 00:26:18,970
DFT tear up and to trigger a FTL tear up

648
00:26:16,110 --> 00:26:21,908
at the end of the bar function we have

649
00:26:18,970 --> 00:26:23,830
array being accessed at a negative index

650
00:26:21,909 --> 00:26:27,419
so negative 3 and then being added to

651
00:26:23,830 --> 00:26:29,699
array 2 and if we look at these values

652
00:26:27,419 --> 00:26:34,600
this is three point five for whatever

653
00:26:29,700 --> 00:26:37,960
that ends up being 41 41 41 41 which is

654
00:26:34,600 --> 00:26:39,879
the value we were crashing at so looking

655
00:26:37,960 --> 00:26:42,250
a little bit more what's going on I'd

656
00:26:39,880 --> 00:26:44,950
mentioned that the DFG engine performs

657
00:26:42,250 --> 00:26:46,659
ray bounds checking removal that happens

658
00:26:44,950 --> 00:26:50,679
in a phase called the integer check

659
00:26:46,659 --> 00:26:52,720
combining phase what happens is it'll

660
00:26:50,679 --> 00:26:55,600
see that there's some array bounds that

661
00:26:52,720 --> 00:26:58,029
are being accessed and it'll try and

662
00:26:55,600 --> 00:27:00,189
build up a list of minimum nodes and

663
00:26:58,029 --> 00:27:02,799
maximum nodes and then if necessary

664
00:27:00,190 --> 00:27:04,390
it'll go ahead and delete nodes where

665
00:27:02,799 --> 00:27:09,970
they're redundant or they're kind of

666
00:27:04,390 --> 00:27:11,740
superseded by another index so looking

667
00:27:09,970 --> 00:27:15,520
at it a little bit more closely if we

668
00:27:11,740 --> 00:27:17,080
are if we have constant values so we we

669
00:27:15,520 --> 00:27:19,570
don't have a variable that's being used

670
00:27:17,080 --> 00:27:21,730
as an index in this case we have the

671
00:27:19,570 --> 00:27:23,678
negative three we have the two then

672
00:27:21,730 --> 00:27:26,140
we'll set the minimum node to zero and

673
00:27:23,679 --> 00:27:29,320
also the maximum no two whatever is that

674
00:27:26,140 --> 00:27:31,929
an integer constant and then at the end

675
00:27:29,320 --> 00:27:34,360
we'll add a check inbounds which is a

676
00:27:31,929 --> 00:27:36,070
special byte code operation that just

677
00:27:34,360 --> 00:27:38,168
says hey just check if this value is

678
00:27:36,070 --> 00:27:40,600
actually inbounds based on the array

679
00:27:38,169 --> 00:27:43,510
size or the object size whatever we're

680
00:27:40,600 --> 00:27:46,449
operating on and if we look at the FTL

681
00:27:43,510 --> 00:27:50,020
code that's that's used to handle this

682
00:27:46,450 --> 00:27:52,750
it actually looks okay we see compile

683
00:27:50,020 --> 00:27:55,270
check inbounds it has speculate so it's

684
00:27:52,750 --> 00:27:59,350
speculated out of bounds if

685
00:27:55,270 --> 00:28:02,320
the length is above or equal to the to

686
00:27:59,350 --> 00:28:04,270
the size of the array and for those who

687
00:28:02,320 --> 00:28:06,790
spend a lot of time doing any sort of

688
00:28:04,270 --> 00:28:08,800
assembly above or equal you know is the

689
00:28:06,790 --> 00:28:12,510
unsigned way of handling and it anything

690
00:28:08,800 --> 00:28:14,710
but if you were paying attention during

691
00:28:12,510 --> 00:28:16,750
the overview where I was talking about

692
00:28:14,710 --> 00:28:19,630
the FTL you'll remember that the FTL

693
00:28:16,750 --> 00:28:21,040
only deals with sine integers the above

694
00:28:19,630 --> 00:28:22,840
or equal operation actually gets

695
00:28:21,040 --> 00:28:24,970
converted into a greater than or equal

696
00:28:22,840 --> 00:28:27,639
to operation and so if we look at our

697
00:28:24,970 --> 00:28:30,460
proof of concept again we have array

698
00:28:27,640 --> 00:28:32,170
minus three negative three is never

699
00:28:30,460 --> 00:28:34,660
going to be greater than whatever the

700
00:28:32,170 --> 00:28:36,880
array size is so it'll continue on and

701
00:28:34,660 --> 00:28:39,610
it'll just go and go on and execute

702
00:28:36,880 --> 00:28:41,350
basically this vulnerability allows for

703
00:28:39,610 --> 00:28:43,629
an out of bounds read leading to type

704
00:28:41,350 --> 00:28:47,919
confusion it's also great because it

705
00:28:43,630 --> 00:28:50,380
leads for both leaking objects as well

706
00:28:47,920 --> 00:28:53,710
as crafting pointers because here we the

707
00:28:50,380 --> 00:28:55,450
crash we examined that was controlling a

708
00:28:53,710 --> 00:28:58,470
pointer and getting it to dereference as

709
00:28:55,450 --> 00:29:01,929
our choosing if we wanted to we could

710
00:28:58,470 --> 00:29:05,200
create another array say array zero and

711
00:29:01,929 --> 00:29:06,970
have it allocated before array 1 and

712
00:29:05,200 --> 00:29:09,520
then run the same Bar function but

713
00:29:06,970 --> 00:29:11,500
instead have it access array 1 and do an

714
00:29:09,520 --> 00:29:13,960
out of bounds read on that because then

715
00:29:11,500 --> 00:29:16,900
it would read the pointers from array 0

716
00:29:13,960 --> 00:29:18,580
and return them back as floating-point

717
00:29:16,900 --> 00:29:21,100
values that we can then convert into

718
00:29:18,580 --> 00:29:22,928
something that we can actually use and

719
00:29:21,100 --> 00:29:25,480
so this this was a very very good bug

720
00:29:22,929 --> 00:29:27,700
and this is a huge this is a great

721
00:29:25,480 --> 00:29:29,710
example as to why the exploitation piece

722
00:29:27,700 --> 00:29:31,660
of JIT vulnerabilities is not that

723
00:29:29,710 --> 00:29:33,340
interesting to me because when you can

724
00:29:31,660 --> 00:29:35,710
do something like that you can very

725
00:29:33,340 --> 00:29:37,928
easily and very quickly get full read

726
00:29:35,710 --> 00:29:40,390
and write access to all of memory at

727
00:29:37,929 --> 00:29:42,100
which point you it's game over there's

728
00:29:40,390 --> 00:29:43,510
really nothing you can do but the

729
00:29:42,100 --> 00:29:44,620
vulnerabilities themselves are still

730
00:29:43,510 --> 00:29:48,100
very very interesting and quite

731
00:29:44,620 --> 00:29:49,989
fascinating to me so the next

732
00:29:48,100 --> 00:29:54,428
vulnerability I'm going to cover is CDE

733
00:29:49,990 --> 00:29:56,080
2018 41 62 and this is one of the ones

734
00:29:54,429 --> 00:29:58,270
that I found it was not the first one I

735
00:29:56,080 --> 00:30:00,309
found but one of the more interesting

736
00:29:58,270 --> 00:30:04,210
ones specifically because of the way I

737
00:30:00,309 --> 00:30:06,940
found it I was surfing reddit at home

738
00:30:04,210 --> 00:30:08,690
one day and was linked to a Stack

739
00:30:06,940 --> 00:30:12,380
Overflow post where

740
00:30:08,690 --> 00:30:15,380
someone was asked was asking basically

741
00:30:12,380 --> 00:30:17,540
this question so they went to a job

742
00:30:15,380 --> 00:30:20,330
interview and they were asked with this

743
00:30:17,540 --> 00:30:23,600
JavaScript snippet can a a equals equals

744
00:30:20,330 --> 00:30:26,750
one and a equals equals two and a equals

745
00:30:23,600 --> 00:30:28,310
equals three ever be true they they

746
00:30:26,750 --> 00:30:33,110
weren't sure but the answer is yes

747
00:30:28,310 --> 00:30:35,629
because JavaScript specifically if a is

748
00:30:33,110 --> 00:30:37,459
an object and has a custom value of

749
00:30:35,630 --> 00:30:39,320
function or a custom to string function

750
00:30:37,460 --> 00:30:41,960
you can have an internal iterator and

751
00:30:39,320 --> 00:30:44,840
basically choose a new value every time

752
00:30:41,960 --> 00:30:46,730
you get compared and so just kind of get

753
00:30:44,840 --> 00:30:48,470
an example of that you have two

754
00:30:46,730 --> 00:30:51,830
different ways of testing for equality

755
00:30:48,470 --> 00:30:54,500
in JavaScript you have like one equals

756
00:30:51,830 --> 00:30:56,389
equals true one equals equals one inside

757
00:30:54,500 --> 00:30:58,910
a string and both of those are true this

758
00:30:56,390 --> 00:31:02,000
is loose equality or loose comparisons

759
00:30:58,910 --> 00:31:04,490
and then we have one equals equals

760
00:31:02,000 --> 00:31:07,640
equals true basically three equals

761
00:31:04,490 --> 00:31:10,730
instead of two and you have here you'll

762
00:31:07,640 --> 00:31:12,350
do a type check before you actually do

763
00:31:10,730 --> 00:31:15,260
the value check

764
00:31:12,350 --> 00:31:17,810
whereas loose comparison will do a check

765
00:31:15,260 --> 00:31:20,629
by doing type coercion first this will

766
00:31:17,810 --> 00:31:22,040
try and make sure strict comparison will

767
00:31:20,630 --> 00:31:26,150
make sure that the objects are the same

768
00:31:22,040 --> 00:31:27,409
type before continuing on and just as a

769
00:31:26,150 --> 00:31:30,140
quick example of what that might look

770
00:31:27,410 --> 00:31:31,910
like here we have one equals equals and

771
00:31:30,140 --> 00:31:34,670
then I have this custom object that has

772
00:31:31,910 --> 00:31:37,160
a custom value of function that when

773
00:31:34,670 --> 00:31:38,810
executed is going to print out we got

774
00:31:37,160 --> 00:31:41,870
called and then it's going to return the

775
00:31:38,810 --> 00:31:43,909
value for and if we look right after it

776
00:31:41,870 --> 00:31:46,580
gets we got called gets printed out and

777
00:31:43,910 --> 00:31:49,370
then false is printed because one is

778
00:31:46,580 --> 00:31:52,100
obviously not equal to four when I was

779
00:31:49,370 --> 00:31:53,120
looking at this I decided not to look at

780
00:31:52,100 --> 00:31:55,669
the DFG

781
00:31:53,120 --> 00:31:57,679
clobber eyes or DFG abstract interpreter

782
00:31:55,670 --> 00:31:59,600
I just had a feeling they had not

783
00:31:57,680 --> 00:32:01,300
actually properly handled this and so I

784
00:31:59,600 --> 00:32:03,770
just created a proof-of-concept and

785
00:32:01,300 --> 00:32:07,340
immediately got a crash confirming that

786
00:32:03,770 --> 00:32:11,300
I was right so here we'll go over the

787
00:32:07,340 --> 00:32:14,510
entirety of the proof-of-concept starts

788
00:32:11,300 --> 00:32:16,100
off with creating an array and I'm not I

789
00:32:14,510 --> 00:32:18,170
didn't cover the or I forgot to add a

790
00:32:16,100 --> 00:32:21,969
highlight for the next line where I'm

791
00:32:18,170 --> 00:32:23,289
setting array 1 dot a 2 1

792
00:32:21,970 --> 00:32:26,169
the whole reason for this is to

793
00:32:23,289 --> 00:32:28,990
invalidate the structure for an array

794
00:32:26,169 --> 00:32:31,629
and that's going back into JSC internals

795
00:32:28,990 --> 00:32:33,490
that I was kind of glossing over main

796
00:32:31,629 --> 00:32:35,529
thing is that that's just a prereq in

797
00:32:33,490 --> 00:32:39,519
order to hit this particular bug or hit

798
00:32:35,529 --> 00:32:42,580
a couple of other similar bugs I'm now

799
00:32:39,519 --> 00:32:44,500
calling this go function very very large

800
00:32:42,580 --> 00:32:47,289
number of times the whole reason for

801
00:32:44,500 --> 00:32:49,419
this is specifically to make sure it

802
00:32:47,289 --> 00:32:52,059
hits the DFG with this particular proof

803
00:32:49,419 --> 00:32:53,259
of concept will hit the FTL but it's not

804
00:32:52,059 --> 00:32:55,809
that big a deal we're not going to

805
00:32:53,259 --> 00:32:58,990
notice this runs in about a second if

806
00:32:55,809 --> 00:33:01,178
even that we're gonna perform a couple

807
00:32:58,990 --> 00:33:03,480
of writes basically just trying to get

808
00:33:01,179 --> 00:33:05,950
the JIT to understand that we're writing

809
00:33:03,480 --> 00:33:07,509
we're writing double values into this

810
00:33:05,950 --> 00:33:09,909
array and that this is an array with

811
00:33:07,509 --> 00:33:13,570
double and just kind of reinforcing

812
00:33:09,909 --> 00:33:15,279
doubles all the way down at the end

813
00:33:13,570 --> 00:33:17,019
we're running or we're performing this

814
00:33:15,279 --> 00:33:19,240
right again this five point six seven

815
00:33:17,019 --> 00:33:23,440
whatever value and this ends up just

816
00:33:19,240 --> 00:33:25,500
being 0x clich just to prove that we

817
00:33:23,440 --> 00:33:29,799
have a pointer that's under our control

818
00:33:25,500 --> 00:33:32,049
and then in the middle right before that

819
00:33:29,799 --> 00:33:33,629
right we have C equals equals one to

820
00:33:32,049 --> 00:33:36,820
actually trigger their vulnerability

821
00:33:33,629 --> 00:33:38,500
then the last time we call it is calling

822
00:33:36,820 --> 00:33:41,080
go this time with our custom object

823
00:33:38,500 --> 00:33:43,350
we're using to string and set a value of

824
00:33:41,080 --> 00:33:46,080
here it doesn't matter both would work

825
00:33:43,350 --> 00:33:49,928
within the two string function we are

826
00:33:46,080 --> 00:33:54,129
setting the zeroth element in array 1 to

827
00:33:49,929 --> 00:33:56,799
a object so this is going to convert the

828
00:33:54,129 --> 00:33:59,769
array with double into an array with

829
00:33:56,799 --> 00:34:02,230
contiguous the problem is when go when

830
00:33:59,769 --> 00:34:05,019
the go function it within the JIT goes

831
00:34:02,230 --> 00:34:06,490
to run that goes to perform the rate of

832
00:34:05,019 --> 00:34:08,649
five point six seven and so on and so

833
00:34:06,490 --> 00:34:10,389
forth it still thinks that this is an

834
00:34:08,649 --> 00:34:12,339
array with double it hasn't validated

835
00:34:10,389 --> 00:34:14,379
any of its assumptions and so it's going

836
00:34:12,339 --> 00:34:18,159
to perform that right without tagging it

837
00:34:14,379 --> 00:34:20,699
which means we're able to control what

838
00:34:18,159 --> 00:34:23,500
pointers we write into this array and

839
00:34:20,699 --> 00:34:25,719
later when we do a string concatenation

840
00:34:23,500 --> 00:34:27,310
with it it ends up trying to dereference

841
00:34:25,719 --> 00:34:29,138
that pointer that pointer is not valid

842
00:34:27,310 --> 00:34:32,090
because I'm just showing a proof of

843
00:34:29,139 --> 00:34:35,810
concept and so we get a crash and

844
00:34:32,090 --> 00:34:37,820
nothing too bad happens but with any

845
00:34:35,810 --> 00:34:41,810
sort of control we were able to get full

846
00:34:37,820 --> 00:34:45,260
code execution just based off this if we

847
00:34:41,810 --> 00:34:47,029
look at the the DFG abstract interpreter

848
00:34:45,260 --> 00:34:49,430
and the DFG collaborize we'll see that

849
00:34:47,030 --> 00:34:52,070
they actually do have case statements

850
00:34:49,429 --> 00:34:54,699
for these op codes but nothing all that

851
00:34:52,070 --> 00:34:56,780
interesting actually happens within it

852
00:34:54,699 --> 00:34:58,460
basically all they're trying to do is

853
00:34:56,780 --> 00:35:00,530
see is there see if there's any

854
00:34:58,460 --> 00:35:03,290
opportunity to optimize this function

855
00:35:00,530 --> 00:35:05,590
call to try and make it much faster so

856
00:35:03,290 --> 00:35:08,210
are they looking at our both arguments

857
00:35:05,590 --> 00:35:11,600
constant integers or they constant

858
00:35:08,210 --> 00:35:13,160
doubles whatever and if so try and do

859
00:35:11,600 --> 00:35:15,470
the comparison there to try and replace

860
00:35:13,160 --> 00:35:17,240
the call altogether otherwise we'll have

861
00:35:15,470 --> 00:35:20,109
to continue on and actually execute it

862
00:35:17,240 --> 00:35:22,580
every time the function gets executed I

863
00:35:20,110 --> 00:35:25,550
also wanted to demonstrate just how easy

864
00:35:22,580 --> 00:35:28,160
this is to turn into an info leak all we

865
00:35:25,550 --> 00:35:30,650
have to do is create a float64 typed

866
00:35:28,160 --> 00:35:32,569
array this is typed array that basically

867
00:35:30,650 --> 00:35:35,780
just all the data that it stores is

868
00:35:32,570 --> 00:35:37,760
going to be doubles we have a couple of

869
00:35:35,780 --> 00:35:40,730
function of helper functions all this is

870
00:35:37,760 --> 00:35:43,130
going to do is create a two typed array

871
00:35:40,730 --> 00:35:45,020
as aun 32 typed array and a float 64

872
00:35:43,130 --> 00:35:47,660
typed array both of which have the same

873
00:35:45,020 --> 00:35:50,259
backing array buffer the reason for this

874
00:35:47,660 --> 00:35:53,720
is we're going to write a float64array

875
00:35:50,260 --> 00:35:55,910
value to it sorry we write a

876
00:35:53,720 --> 00:35:58,279
floating-point value to the float64array

877
00:35:55,910 --> 00:36:00,379
and then we'll read out two 32-bit

878
00:35:58,280 --> 00:36:03,080
values from the UN 32 array and then

879
00:36:00,380 --> 00:36:04,730
just basically add them together here

880
00:36:03,080 --> 00:36:06,020
I'm doing string math but if we're

881
00:36:04,730 --> 00:36:08,180
actually doing anything we'll have to

882
00:36:06,020 --> 00:36:11,630
shift the value so that forms an actual

883
00:36:08,180 --> 00:36:13,730
pointer and go on from there and then

884
00:36:11,630 --> 00:36:16,190
all I've done is instead of perform that

885
00:36:13,730 --> 00:36:18,110
right at the end of the go function here

886
00:36:16,190 --> 00:36:21,020
we're performing a read from a zero and

887
00:36:18,110 --> 00:36:24,410
writing it to our float64array from all

888
00:36:21,020 --> 00:36:26,630
the way at the top and then at the end

889
00:36:24,410 --> 00:36:29,210
I'm performing conversion on it and then

890
00:36:26,630 --> 00:36:33,410
just printing out the value allowing for

891
00:36:29,210 --> 00:36:34,700
a very quick and easy if a leak so one

892
00:36:33,410 --> 00:36:36,740
of the things I really really like about

893
00:36:34,700 --> 00:36:38,980
chip vulnerabilities is that they very

894
00:36:36,740 --> 00:36:41,839
much lend themselves to exploit reuse

895
00:36:38,980 --> 00:36:44,940
and what I mean by that is writing

896
00:36:41,840 --> 00:36:46,500
exploit takes a lot of time with chip

897
00:36:44,940 --> 00:36:49,410
abilities especially gym owner abilities

898
00:36:46,500 --> 00:36:51,720
of these type of this type there's a lot

899
00:36:49,410 --> 00:36:54,598
of them where all you have to do is swap

900
00:36:51,720 --> 00:36:56,578
out one one function one call one

901
00:36:54,599 --> 00:36:59,040
whatever so in this case we have the

902
00:36:56,579 --> 00:37:03,359
proof-of-concept on the Left C equals

903
00:36:59,040 --> 00:37:05,759
equals one can be replaced by C which is

904
00:37:03,359 --> 00:37:08,819
the spread operator can be replaced with

905
00:37:05,760 --> 00:37:11,940
Matt coz 32 can be replaced with NAFTA

906
00:37:08,819 --> 00:37:14,609
ABS can be replaced with that or it can

907
00:37:11,940 --> 00:37:16,290
be replaced with any of these I guess

908
00:37:14,609 --> 00:37:18,089
could is the better way of saying that

909
00:37:16,290 --> 00:37:19,920
these are all patched now but at one

910
00:37:18,089 --> 00:37:22,200
point you could have written one exploit

911
00:37:19,920 --> 00:37:25,349
and then used any of these to actually

912
00:37:22,200 --> 00:37:27,930
trigger any of them and I just really

913
00:37:25,349 --> 00:37:30,270
enjoy that because it makes it very very

914
00:37:27,930 --> 00:37:32,399
nice from an exploitation standpoint as

915
00:37:30,270 --> 00:37:34,230
someone that uses any of the software

916
00:37:32,400 --> 00:37:36,349
it's terrifying because again

917
00:37:34,230 --> 00:37:38,880
exploitation takes a lot of time and

918
00:37:36,349 --> 00:37:40,470
this massively shrinks the amount of

919
00:37:38,880 --> 00:37:42,869
time that you have to invest in doing

920
00:37:40,470 --> 00:37:45,540
any of that an interesting thing to note

921
00:37:42,869 --> 00:37:47,760
here is that there have been a couple of

922
00:37:45,540 --> 00:37:50,880
ulnar abilities here that applied to

923
00:37:47,760 --> 00:37:54,030
both chakra core the JavaScript engine

924
00:37:50,880 --> 00:37:56,310
for edge as well as the engine here

925
00:37:54,030 --> 00:37:58,560
javascriptcore the spread operator one

926
00:37:56,310 --> 00:38:01,980
the dot C and then also the equals

927
00:37:58,560 --> 00:38:04,578
equals one applied to both both of which

928
00:38:01,980 --> 00:38:09,450
are now patched but it's interesting and

929
00:38:04,579 --> 00:38:12,960
on that note I am pretty much done one

930
00:38:09,450 --> 00:38:15,210
thing that kind of expanding on what I

931
00:38:12,960 --> 00:38:17,550
just said about the to that effect both

932
00:38:15,210 --> 00:38:19,980
chakra and javascriptcore it's

933
00:38:17,550 --> 00:38:22,890
interesting and that they both have

934
00:38:19,980 --> 00:38:24,599
different devs entirely different dev

935
00:38:22,890 --> 00:38:27,060
teams but they're both building off of

936
00:38:24,599 --> 00:38:29,069
the spec and it's interesting to see how

937
00:38:27,060 --> 00:38:31,200
some of the vulnerability is kind of

938
00:38:29,069 --> 00:38:32,759
exists across all the browsers because

939
00:38:31,200 --> 00:38:35,368
they're all doing things very similar

940
00:38:32,760 --> 00:38:36,869
ways and the spec doesn't specify one

941
00:38:35,369 --> 00:38:39,030
thing or the other and they're just

942
00:38:36,869 --> 00:38:40,890
trying to be as performant but also

943
00:38:39,030 --> 00:38:43,500
trying to support as much as possible

944
00:38:40,890 --> 00:38:46,790
and that just kind of nice and on that

945
00:38:43,500 --> 00:38:46,790
note does anyone have any questions

946
00:38:46,980 --> 00:38:49,040
you

