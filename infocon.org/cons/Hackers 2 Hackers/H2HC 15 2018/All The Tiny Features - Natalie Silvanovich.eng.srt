1
00:00:00,030 --> 00:00:16,830
I thanks so much for coming to my

2
00:00:14,190 --> 00:00:19,619
presentation today I'm going to talk

3
00:00:16,830 --> 00:00:22,500
about some research I recently did in

4
00:00:19,619 --> 00:00:25,800
two browsers us so I'm Natali Silvano

5
00:00:22,500 --> 00:00:28,800
vaq and I'm on project zero at Google

6
00:00:25,800 --> 00:00:30,779
and I've looked at a lot of stuff that

7
00:00:28,800 --> 00:00:33,390
sprouts are related I've spent a lot of

8
00:00:30,779 --> 00:00:36,120
time looking at JavaScript and other

9
00:00:33,390 --> 00:00:38,820
JavaScript like languages but recently I

10
00:00:36,120 --> 00:00:40,578
found myself thinking about what the

11
00:00:38,820 --> 00:00:43,829
other attack surface of the browser is

12
00:00:40,579 --> 00:00:45,870
what things exist that are in browsers

13
00:00:43,829 --> 00:00:48,500
that attackers haven't looked at a lot

14
00:00:45,870 --> 00:00:52,050
and there were two specific things

15
00:00:48,500 --> 00:00:53,940
webassembly and WebRTC so today I'm

16
00:00:52,050 --> 00:00:57,360
going to talk a bit about how I looked

17
00:00:53,940 --> 00:00:59,269
at both of them and what I found out so

18
00:00:57,360 --> 00:01:02,940
let's start off with web assembly

19
00:00:59,270 --> 00:01:04,979
what is web assembly well web assembly

20
00:01:02,940 --> 00:01:08,220
isn't assembly like format for writing

21
00:01:04,979 --> 00:01:11,070
code in JavaScript they created it for

22
00:01:08,220 --> 00:01:13,830
two reasons one of them believe it or

23
00:01:11,070 --> 00:01:16,559
not is security one of the ideas behind

24
00:01:13,830 --> 00:01:19,470
web assembly is that it's supposed to be

25
00:01:16,560 --> 00:01:22,049
an alternative to installing native code

26
00:01:19,470 --> 00:01:24,509
on your hosts so the people who are

27
00:01:22,049 --> 00:01:26,759
creating the web web assembly standard

28
00:01:24,509 --> 00:01:29,100
hope that one day instead of installing

29
00:01:26,759 --> 00:01:31,380
programs on your computer you might have

30
00:01:29,100 --> 00:01:34,020
a web assembly VM and be able to run

31
00:01:31,380 --> 00:01:36,390
stuff that way it was also created

32
00:01:34,020 --> 00:01:40,610
because JavaScript has some

33
00:01:36,390 --> 00:01:43,110
inefficiencies especially in doing math

34
00:01:40,610 --> 00:01:45,119
javascript is not strictly typed which

35
00:01:43,110 --> 00:01:47,850
means that when you do math you have to

36
00:01:45,119 --> 00:01:49,799
check that every value is actually an

37
00:01:47,850 --> 00:01:52,048
integer every single time you add it and

38
00:01:49,799 --> 00:01:55,320
this makes math more difficult than it

39
00:01:52,049 --> 00:01:56,939
needs to be so web assembly also hopes

40
00:01:55,320 --> 00:01:59,789
to create a quick way to do math in

41
00:01:56,939 --> 00:02:03,419
JavaScript a major goal is compiled

42
00:01:59,790 --> 00:02:06,060
ability so right now you can compile C++

43
00:02:03,420 --> 00:02:08,038
into web assembly really well using a

44
00:02:06,060 --> 00:02:10,440
transpiler and there's some other

45
00:02:08,038 --> 00:02:12,510
languages that work okay but then

46
00:02:10,440 --> 00:02:13,859
there's some languages like Java where

47
00:02:12,510 --> 00:02:15,780
there's a whole lot of

48
00:02:13,860 --> 00:02:18,060
that you can't compile into webassembly

49
00:02:15,780 --> 00:02:21,210
right now specifically because of

50
00:02:18,060 --> 00:02:22,710
garbage collection and that's supposed

51
00:02:21,210 --> 00:02:25,740
to be a short-term thing the long-term

52
00:02:22,710 --> 00:02:28,530
of goal of webassembly is for you to be

53
00:02:25,740 --> 00:02:31,800
able to compile any code in any language

54
00:02:28,530 --> 00:02:35,010
to run in your browser

55
00:02:31,800 --> 00:02:37,200
it's a w3c standard and I think it's a

56
00:02:35,010 --> 00:02:38,940
very ambitious standard they have a lot

57
00:02:37,200 --> 00:02:41,820
of goals with it that haven't happened

58
00:02:38,940 --> 00:02:45,000
yet with regards to being able to run

59
00:02:41,820 --> 00:02:48,030
basically any code anywhere and it also

60
00:02:45,000 --> 00:02:50,820
has applications beyond browsers to give

61
00:02:48,030 --> 00:02:53,640
an example the etherium interpreter is

62
00:02:50,820 --> 00:02:57,030
going to move to being in web assembly

63
00:02:53,640 --> 00:02:59,339
soon so when you think about something

64
00:02:57,030 --> 00:03:02,070
like web assembly there are two possible

65
00:02:59,340 --> 00:03:04,620
problems that can happen number one is

66
00:03:02,070 --> 00:03:07,590
that your web assembly engine isn't

67
00:03:04,620 --> 00:03:10,350
implemented securely maybe someone can

68
00:03:07,590 --> 00:03:13,590
put malformed web assembly into your

69
00:03:10,350 --> 00:03:15,420
engine and they can corrupt memory and

70
00:03:13,590 --> 00:03:18,300
get code execution that's one problem

71
00:03:15,420 --> 00:03:20,579
there's another problem which is that

72
00:03:18,300 --> 00:03:22,800
code written web assembly isn't

73
00:03:20,580 --> 00:03:25,110
implemented securely maybe someone

74
00:03:22,800 --> 00:03:26,760
writes a buffer overflow in web assembly

75
00:03:25,110 --> 00:03:29,100
or a cross-site scripting in web

76
00:03:26,760 --> 00:03:31,980
assembly so today I'm going to talk

77
00:03:29,100 --> 00:03:34,260
about this problem and not that problem

78
00:03:31,980 --> 00:03:36,149
and if you're interested in the second

79
00:03:34,260 --> 00:03:38,100
problem which is writing secure web

80
00:03:36,150 --> 00:03:39,870
assembly I'd recommend this watching the

81
00:03:38,100 --> 00:03:42,450
video of this talk from black hat as a

82
00:03:39,870 --> 00:03:44,070
lot of good content on the subject but

83
00:03:42,450 --> 00:03:47,399
I'm specifically focused on the first

84
00:03:44,070 --> 00:03:51,000
problem which is the security of the

85
00:03:47,400 --> 00:03:54,660
actual web assembly engine so to start

86
00:03:51,000 --> 00:03:57,209
off what is web assembly actually in the

87
00:03:54,660 --> 00:03:59,549
browser well it starts off as a binary

88
00:03:57,209 --> 00:04:03,060
and in JavaScript this will end up being

89
00:03:59,550 --> 00:04:06,560
an array buffer or a typed array and you

90
00:04:03,060 --> 00:04:09,959
can load it using a keyword fetch in

91
00:04:06,560 --> 00:04:11,970
JavaScript and then you get an array

92
00:04:09,959 --> 00:04:14,760
buffer like this or an array like this

93
00:04:11,970 --> 00:04:18,149
or you can just do what I did and put in

94
00:04:14,760 --> 00:04:19,858
every byte by hand now what is this

95
00:04:18,149 --> 00:04:22,289
format that you're actually putting into

96
00:04:19,858 --> 00:04:24,690
this buffer well it's the web assembly

97
00:04:22,289 --> 00:04:26,330
binary format and it consists of a

98
00:04:24,690 --> 00:04:28,940
number of sections that

99
00:04:26,330 --> 00:04:31,729
of a name and a payload length and that

100
00:04:28,940 --> 00:04:34,370
sort of thing and these sections

101
00:04:31,729 --> 00:04:36,020
represent different things for example

102
00:04:34,370 --> 00:04:38,000
there's one for data types there's one

103
00:04:36,020 --> 00:04:40,490
for import there's one for functions

104
00:04:38,000 --> 00:04:42,800
I'll go through what a lot of these do

105
00:04:40,490 --> 00:04:44,780
later another important thing to

106
00:04:42,800 --> 00:04:47,210
remember is that there are some

107
00:04:44,780 --> 00:04:50,030
restrictions on this so there are some

108
00:04:47,210 --> 00:04:52,370
sections that you have to have and there

109
00:04:50,030 --> 00:04:54,229
are some sections that you can't have

110
00:04:52,370 --> 00:04:55,970
more than one and there are some

111
00:04:54,229 --> 00:04:59,030
sections they have to go in a certain

112
00:04:55,970 --> 00:05:00,879
order for example the type section has

113
00:04:59,030 --> 00:05:04,068
to go before the function declaration

114
00:05:00,879 --> 00:05:06,800
section that uses those types that sort

115
00:05:04,069 --> 00:05:09,199
of thing so what happens once you have

116
00:05:06,800 --> 00:05:11,120
this binary format in your array well

117
00:05:09,199 --> 00:05:13,849
then you create a web assembly module

118
00:05:11,120 --> 00:05:17,599
like this and what does this actually do

119
00:05:13,849 --> 00:05:20,210
well it parses the web assembly and

120
00:05:17,599 --> 00:05:23,330
basically loads it into memory and what

121
00:05:20,210 --> 00:05:26,359
sort of problems could this have well um

122
00:05:23,330 --> 00:05:29,539
there's this bug and what happened here

123
00:05:26,360 --> 00:05:31,969
is there as I said there needs to be a

124
00:05:29,539 --> 00:05:34,969
specific order of certain sections in

125
00:05:31,969 --> 00:05:36,919
web assembly and this was in WebKit this

126
00:05:34,969 --> 00:05:38,539
is how they actually validated the order

127
00:05:36,919 --> 00:05:41,359
and you'll notice there's a type of

128
00:05:38,539 --> 00:05:43,430
section called a custom section this is

129
00:05:41,360 --> 00:05:44,300
basically a section type that doesn't

130
00:05:43,430 --> 00:05:46,099
exist yet

131
00:05:44,300 --> 00:05:47,900
this is how they basically ensure

132
00:05:46,099 --> 00:05:50,060
backwards compatibility in the future

133
00:05:47,900 --> 00:05:51,710
when there's new section types and it

134
00:05:50,060 --> 00:05:55,729
turned out that when they check the

135
00:05:51,710 --> 00:05:57,529
section order for a web assembly binary

136
00:05:55,729 --> 00:06:00,229
and WebKit every time you had this

137
00:05:57,529 --> 00:06:01,639
section custom it would return true

138
00:06:00,229 --> 00:06:02,930
which would basically reset all the

139
00:06:01,639 --> 00:06:04,430
tracking of ordering

140
00:06:02,930 --> 00:06:06,830
so this basically meant you could have

141
00:06:04,430 --> 00:06:08,949
like any number of sections in any order

142
00:06:06,830 --> 00:06:12,139
you could completely bypass this check

143
00:06:08,949 --> 00:06:13,639
and what ended up happening is others

144
00:06:12,139 --> 00:06:15,590
actually created a lot of different

145
00:06:13,639 --> 00:06:18,949
problems but the one that ended up being

146
00:06:15,590 --> 00:06:20,869
exploited was actually but by other

147
00:06:18,949 --> 00:06:22,969
people who found this very same bug for

148
00:06:20,870 --> 00:06:24,169
pone to own but then I reported it and

149
00:06:22,969 --> 00:06:28,639
they ended up having to use a different

150
00:06:24,169 --> 00:06:32,479
bug they exploited it by looking at the

151
00:06:28,639 --> 00:06:34,550
fact that certain arrays in WebKit would

152
00:06:32,479 --> 00:06:36,080
assume certain sections only occur at

153
00:06:34,550 --> 00:06:37,789
once even though they could occur more

154
00:06:36,080 --> 00:06:39,409
than once and then you could just write

155
00:06:37,789 --> 00:06:40,610
outside of the vector

156
00:06:39,409 --> 00:06:42,129
if you had more than one section because

157
00:06:40,610 --> 00:06:46,509
it would overflow the allocated memory

158
00:06:42,129 --> 00:06:46,509
let's turn out to be an exploitable bug

159
00:06:46,569 --> 00:06:51,259
here's another bug that happened in

160
00:06:48,860 --> 00:06:54,739
WebKit this is also in just loading this

161
00:06:51,259 --> 00:06:57,830
module so in JavaScript there are a

162
00:06:54,739 --> 00:06:59,839
buffers and typed buffers like this int

163
00:06:57,830 --> 00:07:01,818
8 array buffer and what these do is

164
00:06:59,839 --> 00:07:05,300
they're basically just views into an

165
00:07:01,819 --> 00:07:08,149
array so it means that you can look at

166
00:07:05,300 --> 00:07:10,519
an array at offset say 700 but when you

167
00:07:08,149 --> 00:07:13,550
Index this view that'll actually be

168
00:07:10,519 --> 00:07:16,129
index 0 so the way this bug worked was

169
00:07:13,550 --> 00:07:18,739
they forgot to or I guess they didn't

170
00:07:16,129 --> 00:07:21,800
forget to they accidentally added the

171
00:07:18,739 --> 00:07:24,229
offset into the buffer twice so this

172
00:07:21,800 --> 00:07:25,849
didn't even work if you had a typed

173
00:07:24,229 --> 00:07:27,889
array buffer instead of an array buffer

174
00:07:25,849 --> 00:07:30,079
your web assembly would never run

175
00:07:27,889 --> 00:07:32,479
correctly and I'm not sure why this

176
00:07:30,079 --> 00:07:34,219
wasn't tested but this it was this

177
00:07:32,479 --> 00:07:35,709
actually also caused an out of bounds

178
00:07:34,219 --> 00:07:37,579
read because if you were looking at off

179
00:07:35,709 --> 00:07:41,599
700 it would actually look at offset

180
00:07:37,579 --> 00:07:46,039
1400 as this is kind of a funny bug that

181
00:07:41,599 --> 00:07:47,479
allowed out-of-bounds reading so what

182
00:07:46,039 --> 00:07:49,818
happens when you're done this parsing

183
00:07:47,479 --> 00:07:53,508
well then you create what's called a web

184
00:07:49,819 --> 00:07:55,369
assembly instance and this web assembly

185
00:07:53,509 --> 00:07:57,559
it stints low it's basically everything

186
00:07:55,369 --> 00:08:00,019
external from JavaScript that's needed

187
00:07:57,559 --> 00:08:02,869
to run your web assembly specifically it

188
00:08:00,019 --> 00:08:04,819
loads imports initializes imports and

189
00:08:02,869 --> 00:08:08,149
creates exports and what does that

190
00:08:04,819 --> 00:08:09,889
actually mean well um there's three

191
00:08:08,149 --> 00:08:12,279
types of imports and these are all

192
00:08:09,889 --> 00:08:15,349
things you can import from JavaScript

193
00:08:12,279 --> 00:08:17,599
there's functions there's memory and

194
00:08:15,349 --> 00:08:19,969
there's tables and I'll explain what

195
00:08:17,599 --> 00:08:22,279
these mean in a second but to start off

196
00:08:19,969 --> 00:08:24,349
I'm gonna give you some web assembly

197
00:08:22,279 --> 00:08:29,019
terminology that you can totally use to

198
00:08:24,349 --> 00:08:31,878
impress all your web assembly friends so

199
00:08:29,019 --> 00:08:34,759
instances can have the same memory and

200
00:08:31,879 --> 00:08:37,639
the same table and if they do they're

201
00:08:34,759 --> 00:08:40,039
called in the same compartment and you

202
00:08:37,639 --> 00:08:41,930
might think well you know since

203
00:08:40,039 --> 00:08:43,879
instances can have a memory in a table

204
00:08:41,929 --> 00:08:45,829
can they share the table but not the

205
00:08:43,879 --> 00:08:47,389
memory or the memory but not the table

206
00:08:45,829 --> 00:08:50,000
you know can they be in half of the same

207
00:08:47,389 --> 00:08:53,000
compartment and the answer here is yes

208
00:08:50,000 --> 00:08:56,270
but there's no reason to do this

209
00:08:53,000 --> 00:08:58,520
this is allowed by the standard but no

210
00:08:56,270 --> 00:09:00,350
language you would ever compile would

211
00:08:58,520 --> 00:09:02,180
ever generate code like this but of

212
00:09:00,350 --> 00:09:09,140
course it's still available for

213
00:09:02,180 --> 00:09:10,520
attackers to use if they want so um what

214
00:09:09,140 --> 00:09:12,710
are these types there's the first web

215
00:09:10,520 --> 00:09:14,329
assembly memory and this allocates all

216
00:09:12,710 --> 00:09:17,330
the memory that your web assembly can

217
00:09:14,330 --> 00:09:19,880
use it has an initial and a max size and

218
00:09:17,330 --> 00:09:22,070
it can be expanded by calling grow and

219
00:09:19,880 --> 00:09:23,870
web assembly or JavaScript and then you

220
00:09:22,070 --> 00:09:26,120
can access this memory using web

221
00:09:23,870 --> 00:09:27,830
assembly instructions um so here's how

222
00:09:26,120 --> 00:09:29,930
you create memory and web assembly

223
00:09:27,830 --> 00:09:31,760
you've got the initial size and pages

224
00:09:29,930 --> 00:09:34,489
maximum size and then you can just grow

225
00:09:31,760 --> 00:09:36,230
it as you need more and keep in mind you

226
00:09:34,490 --> 00:09:38,030
can only have one of these right now web

227
00:09:36,230 --> 00:09:40,310
assembly allows exactly one slab of

228
00:09:38,030 --> 00:09:43,730
memory and that is all your assembly

229
00:09:40,310 --> 00:09:45,050
code guts so I can go wrong here well

230
00:09:43,730 --> 00:09:47,720
there were two interesting and

231
00:09:45,050 --> 00:09:51,650
surprisingly similar bugs found in both

232
00:09:47,720 --> 00:09:54,860
Firefox and v8 they were both basically

233
00:09:51,650 --> 00:09:58,189
that when you grew your web assembly

234
00:09:54,860 --> 00:09:59,960
memory it would overflow the integer I'm

235
00:09:58,190 --> 00:10:01,430
causing to giraffe on the integer that

236
00:09:59,960 --> 00:10:03,710
showed the memory size and then they

237
00:10:01,430 --> 00:10:06,199
would actually get smaller and it's kind

238
00:10:03,710 --> 00:10:07,730
of funny that both of these bugs happen

239
00:10:06,200 --> 00:10:09,860
in different browsers because they were

240
00:10:07,730 --> 00:10:12,080
so similar but I guess that just shows

241
00:10:09,860 --> 00:10:15,800
that integer wrapping is a problem and

242
00:10:12,080 --> 00:10:18,260
people forget to check for it um know

243
00:10:15,800 --> 00:10:20,240
one thing I wondered about is can there

244
00:10:18,260 --> 00:10:22,069
be out-of-bounds issues because one

245
00:10:20,240 --> 00:10:23,750
thing that you know I really wondered

246
00:10:22,070 --> 00:10:25,580
about this memory format is you have

247
00:10:23,750 --> 00:10:27,260
this one page but what if your

248
00:10:25,580 --> 00:10:30,290
instructions try to access out of this

249
00:10:27,260 --> 00:10:32,120
page and surprisingly there were not

250
00:10:30,290 --> 00:10:34,490
very many bugs like this and there are a

251
00:10:32,120 --> 00:10:36,290
few reasons why to start off there is a

252
00:10:34,490 --> 00:10:38,089
limited set of web assembly instructions

253
00:10:36,290 --> 00:10:40,040
there's actually only about six

254
00:10:38,089 --> 00:10:42,560
instructions that access memory there's

255
00:10:40,040 --> 00:10:44,660
load read or load store and something

256
00:10:42,560 --> 00:10:47,180
they call T which is basically store and

257
00:10:44,660 --> 00:10:48,530
return the value so this is a very small

258
00:10:47,180 --> 00:10:52,130
set of instructions that it can actually

259
00:10:48,530 --> 00:10:55,250
be audited pretty easily there's also

260
00:10:52,130 --> 00:10:56,630
limited threading in web assembly and

261
00:10:55,250 --> 00:10:57,860
this might change in the future but

262
00:10:56,630 --> 00:10:59,330
right now there's no threading which

263
00:10:57,860 --> 00:11:01,670
makes it fit once again fairly easy to

264
00:10:59,330 --> 00:11:02,959
audit these instructions and now they

265
00:11:01,670 --> 00:11:06,199
also do something which i think is

266
00:11:02,959 --> 00:11:08,930
really cool which is called safe buffers

267
00:11:06,200 --> 00:11:11,930
our signal buffers and what this is I

268
00:11:08,930 --> 00:11:14,000
mean only works in 64-bit is that every

269
00:11:11,930 --> 00:11:17,839
time you allocate webassembly memory

270
00:11:14,000 --> 00:11:20,360
they map four gigs of memory so

271
00:11:17,840 --> 00:11:23,990
basically they map the entire pointer

272
00:11:20,360 --> 00:11:26,840
space from zero to ffffff and 32 bits

273
00:11:23,990 --> 00:11:28,520
and then the memory you actually are

274
00:11:26,840 --> 00:11:31,400
going to use it will map in at the

275
00:11:28,520 --> 00:11:33,470
beginning of that huge buffer and then

276
00:11:31,400 --> 00:11:35,540
when you into index to that into that

277
00:11:33,470 --> 00:11:37,460
memory using an integer which is all

278
00:11:35,540 --> 00:11:39,199
that web assembly supports it doesn't

279
00:11:37,460 --> 00:11:41,450
matter what the integer is it will

280
00:11:39,200 --> 00:11:43,910
either hit valid memory or will hit this

281
00:11:41,450 --> 00:11:47,330
on map section and throw a signal or an

282
00:11:43,910 --> 00:11:49,219
exception in Windows and then the the

283
00:11:47,330 --> 00:11:50,510
JavaScript engine can catch that and

284
00:11:49,220 --> 00:11:53,180
then they'll tell you you're out of

285
00:11:50,510 --> 00:11:55,340
bounds I so this is really nice just

286
00:11:53,180 --> 00:11:57,170
because a it's really hard to mess up if

287
00:11:55,340 --> 00:11:58,340
you can make your pointer anything you

288
00:11:57,170 --> 00:11:59,930
know you don't have to do any pointer

289
00:11:58,340 --> 00:12:02,090
math to make sure they're not going out

290
00:11:59,930 --> 00:12:03,770
of bounds worst thing that happens it's

291
00:12:02,090 --> 00:12:06,140
just they crash due to unmapped memory

292
00:12:03,770 --> 00:12:08,000
and the other nice thing about this is

293
00:12:06,140 --> 00:12:09,530
this puts all the performance impact of

294
00:12:08,000 --> 00:12:11,990
checking on the people who go out of

295
00:12:09,530 --> 00:12:15,260
bounds if you never go out of bounds in

296
00:12:11,990 --> 00:12:17,810
this scheme you will never hit a memory

297
00:12:15,260 --> 00:12:19,939
check and he'll go really fast if you go

298
00:12:17,810 --> 00:12:22,160
out of bounds this becomes super slow as

299
00:12:19,940 --> 00:12:23,870
they generate the exception but kind of

300
00:12:22,160 --> 00:12:25,189
who really cares when you're doing

301
00:12:23,870 --> 00:12:26,960
something invalid and going out of

302
00:12:25,190 --> 00:12:29,090
bounds so I think that's the cool

303
00:12:26,960 --> 00:12:31,400
feature that reduced bugs a lot so

304
00:12:29,090 --> 00:12:32,930
unfortunately it only works on 64-bit so

305
00:12:31,400 --> 00:12:38,390
I think it's more likely there will be

306
00:12:32,930 --> 00:12:40,400
overflows in webassembly in 32-bit so um

307
00:12:38,390 --> 00:12:42,650
the other thing that is supported in

308
00:12:40,400 --> 00:12:44,959
webassembly is tables and these are

309
00:12:42,650 --> 00:12:47,240
basically function tables and they can

310
00:12:44,960 --> 00:12:48,050
contain other web assembly functions but

311
00:12:47,240 --> 00:12:50,030
keep in mind they don't have to be in

312
00:12:48,050 --> 00:12:54,709
the same compartment any web assembly

313
00:12:50,030 --> 00:12:56,449
function can go into a table and tables

314
00:12:54,710 --> 00:12:58,640
can be changed dynamically which is once

315
00:12:56,450 --> 00:13:00,470
again an unnecessary feature if you're

316
00:12:58,640 --> 00:13:02,420
compiling code you will never have your

317
00:13:00,470 --> 00:13:05,990
tables changed after you first create

318
00:13:02,420 --> 00:13:08,750
them but if you're an attacker you can

319
00:13:05,990 --> 00:13:10,460
change them whenever you want and they

320
00:13:08,750 --> 00:13:11,930
grow similar to a memory you paid you

321
00:13:10,460 --> 00:13:15,320
start off with an initial size and then

322
00:13:11,930 --> 00:13:18,050
you call it grow so what could go wrong

323
00:13:15,320 --> 00:13:19,970
here well there are also some overflows

324
00:13:18,050 --> 00:13:23,150
and expanding the table

325
00:13:19,970 --> 00:13:25,850
in Firefox there was a similar one to

326
00:13:23,150 --> 00:13:27,560
the one with the memory where you could

327
00:13:25,850 --> 00:13:29,330
expand a table until the integer wrapped

328
00:13:27,560 --> 00:13:30,920
and then you'd write out of bounds and

329
00:13:29,330 --> 00:13:34,460
then there's kind of this interesting

330
00:13:30,920 --> 00:13:36,949
one in Chrome and this one was due to

331
00:13:34,460 --> 00:13:38,780
basically JavaScript bindings if you

332
00:13:36,950 --> 00:13:41,360
made the index an integer with two

333
00:13:38,780 --> 00:13:43,370
string defined or to integer defined it

334
00:13:41,360 --> 00:13:44,750
would call that and expand the memory

335
00:13:43,370 --> 00:13:46,220
but would still be pointing to the old

336
00:13:44,750 --> 00:13:48,830
memory you could write out-of-bounds and

337
00:13:46,220 --> 00:13:51,830
that's a very typical JavaScript issue

338
00:13:48,830 --> 00:13:53,030
and that's that's just something

339
00:13:51,830 --> 00:13:55,340
interesting in that it goes to show that

340
00:13:53,030 --> 00:13:57,470
you know webassembly bindings are a

341
00:13:55,340 --> 00:13:58,880
JavaScript they can have web assembly

342
00:13:57,470 --> 00:14:00,920
problems but they can also just have

343
00:13:58,880 --> 00:14:04,580
typical JavaScript vulnerabilities in

344
00:14:00,920 --> 00:14:06,829
them as well so what happens after this

345
00:14:04,580 --> 00:14:08,720
you've loaded all your imports and then

346
00:14:06,830 --> 00:14:11,300
the next step is initialization and

347
00:14:08,720 --> 00:14:13,460
there's two initialization types there

348
00:14:11,300 --> 00:14:15,650
are data segments and they're used

349
00:14:13,460 --> 00:14:20,570
implement to initialize the memory in

350
00:14:15,650 --> 00:14:24,199
the memory page and then there are

351
00:14:20,570 --> 00:14:27,020
elements Eggman's and these are used to

352
00:14:24,200 --> 00:14:29,810
initialize the table and when I read

353
00:14:27,020 --> 00:14:31,819
about these I was like yeah there are

354
00:14:29,810 --> 00:14:34,099
going to be so many bones in this

355
00:14:31,820 --> 00:14:36,170
initialization copying but I turned out

356
00:14:34,100 --> 00:14:37,910
not to be the case and I think part of

357
00:14:36,170 --> 00:14:39,949
it is they're very well defined in the

358
00:14:37,910 --> 00:14:41,390
specification they give every single

359
00:14:39,950 --> 00:14:43,160
step and every single check you should

360
00:14:41,390 --> 00:14:45,230
perform and it seems like all the

361
00:14:43,160 --> 00:14:46,939
implementations actually did that and

362
00:14:45,230 --> 00:14:50,240
they didn't really go out of bounds very

363
00:14:46,940 --> 00:14:53,870
often but something that I did find was

364
00:14:50,240 --> 00:14:55,160
this bug and it doesn't have CVE because

365
00:14:53,870 --> 00:14:57,140
the chrome team actually found it at the

366
00:14:55,160 --> 00:14:58,850
same time I did and fixed it before I

367
00:14:57,140 --> 00:15:03,170
filed it but I think it's pretty

368
00:14:58,850 --> 00:15:06,080
interesting so the problem here is that

369
00:15:03,170 --> 00:15:08,300
if you have web assembly that calls a

370
00:15:06,080 --> 00:15:10,190
function in a table that calls into

371
00:15:08,300 --> 00:15:12,260
JavaScript that then removes the

372
00:15:10,190 --> 00:15:15,080
function from the table there will now

373
00:15:12,260 --> 00:15:17,900
be no handles left to that function and

374
00:15:15,080 --> 00:15:19,490
it will be freed by the VM and this is

375
00:15:17,900 --> 00:15:22,459
kind of interesting and they ended up

376
00:15:19,490 --> 00:15:25,250
fixing it by making it so that if you

377
00:15:22,460 --> 00:15:26,780
call into a javascript function and

378
00:15:25,250 --> 00:15:29,180
you're already in a web assembly call

379
00:15:26,780 --> 00:15:30,770
you can't change the table and this is

380
00:15:29,180 --> 00:15:32,479
okay even though the specification says

381
00:15:30,770 --> 00:15:33,860
this is technically okay no

382
00:15:32,480 --> 00:15:35,870
like this will ever be legitimately

383
00:15:33,860 --> 00:15:38,029
generated so this didn't cause problems

384
00:15:35,870 --> 00:15:40,880
but then I found another way to hit this

385
00:15:38,029 --> 00:15:42,769
bug which is let's say that JavaScript

386
00:15:40,880 --> 00:15:45,439
you call that removes it from the table

387
00:15:42,769 --> 00:15:47,540
doesn't just remove it from the table

388
00:15:45,440 --> 00:15:48,980
but creates another web assembly

389
00:15:47,540 --> 00:15:52,040
instance that uses the initialization

390
00:15:48,980 --> 00:15:53,389
function to initialize that table that

391
00:15:52,040 --> 00:15:55,550
would still actually change the table

392
00:15:53,389 --> 00:15:57,829
and then once again you would have this

393
00:15:55,550 --> 00:16:03,290
problem so there was no handles to your

394
00:15:57,829 --> 00:16:04,969
function left when you unwound and they

395
00:16:03,290 --> 00:16:06,439
ended up fixing this by actually keeping

396
00:16:04,970 --> 00:16:08,329
a handle to the function which I think

397
00:16:06,440 --> 00:16:10,250
it's the right solution here but this

398
00:16:08,329 --> 00:16:13,099
was kind of an interesting and subtle

399
00:16:10,250 --> 00:16:16,040
problem in memory management in web

400
00:16:13,100 --> 00:16:18,709
assembly so what happens after you

401
00:16:16,040 --> 00:16:20,389
finish your instance well it's the last

402
00:16:18,709 --> 00:16:22,430
step the one that finally lets you run

403
00:16:20,389 --> 00:16:24,410
your web assembly so you create this

404
00:16:22,430 --> 00:16:25,939
module and you create the instance and

405
00:16:24,410 --> 00:16:27,529
then you get your exported functions and

406
00:16:25,940 --> 00:16:32,240
then you can just call them and web

407
00:16:27,529 --> 00:16:34,160
assembly happens so what happens next is

408
00:16:32,240 --> 00:16:37,730
it possible that there's runtime issues

409
00:16:34,160 --> 00:16:39,740
and web assembly maybe though I didn't

410
00:16:37,730 --> 00:16:41,569
find any I'm one concern I had was

411
00:16:39,740 --> 00:16:44,560
instructions doing the wrong thing and

412
00:16:41,569 --> 00:16:46,670
actually early in web assembly like

413
00:16:44,560 --> 00:16:48,199
right after it was released

414
00:16:46,670 --> 00:16:49,880
tons and tons of issues like this were

415
00:16:48,199 --> 00:16:51,260
found and some of them were security

416
00:16:49,880 --> 00:16:53,480
related and some of them weren't

417
00:16:51,260 --> 00:16:55,069
but now instructions have sort of

418
00:16:53,480 --> 00:16:56,360
started to converge on doing the right

419
00:16:55,069 --> 00:16:57,860
thing because people have started

420
00:16:56,360 --> 00:17:00,170
actually using using web assembly and

421
00:16:57,860 --> 00:17:01,399
reporting when stuff doesn't work I

422
00:17:00,170 --> 00:17:02,870
still think there could be incorrect

423
00:17:01,399 --> 00:17:06,559
bounds checking though I haven't seen

424
00:17:02,870 --> 00:17:08,929
much yet and I think the handling and

425
00:17:06,559 --> 00:17:10,428
memory management issue of web assembly

426
00:17:08,929 --> 00:17:12,110
is actually fairly complex so I think

427
00:17:10,429 --> 00:17:14,720
it's likely they'll be more use after

428
00:17:12,109 --> 00:17:16,698
freeze and issues where web assembly

429
00:17:14,720 --> 00:17:20,179
stops running and they haven't managed

430
00:17:16,699 --> 00:17:22,790
the handles correctly so I think also in

431
00:17:20,179 --> 00:17:24,290
web assembly even though I didn't find a

432
00:17:22,790 --> 00:17:25,459
large number of bugs now and there

433
00:17:24,290 --> 00:17:28,188
haven't been a large number of bugs

434
00:17:25,459 --> 00:17:30,080
reported in it in the future it could be

435
00:17:28,189 --> 00:17:31,270
much worse and I actually hope they

436
00:17:30,080 --> 00:17:33,889
don't end up going in this direction

437
00:17:31,270 --> 00:17:35,270
there's two features in particular that

438
00:17:33,890 --> 00:17:36,169
I think are likely to cause a lot of

439
00:17:35,270 --> 00:17:39,290
problems

440
00:17:36,169 --> 00:17:42,260
number one is concurrency right now web

441
00:17:39,290 --> 00:17:44,490
assembly only uses JavaScript threading

442
00:17:42,260 --> 00:17:46,530
and this makes it fairly safe in

443
00:17:44,490 --> 00:17:48,540
that web assembly itself does not have

444
00:17:46,530 --> 00:17:50,428
to be thread safe but they're likely to

445
00:17:48,540 --> 00:17:52,710
change this in the future and I think

446
00:17:50,429 --> 00:17:55,140
this will lead to a lot of bugs as they

447
00:17:52,710 --> 00:17:56,880
try and change these engines that didn't

448
00:17:55,140 --> 00:17:59,100
require threading to support threading

449
00:17:56,880 --> 00:18:01,950
and then there's this other feature

450
00:17:59,100 --> 00:18:04,469
coming up remember I always said they

451
00:18:01,950 --> 00:18:06,390
don't have a working JavaScript or Java

452
00:18:04,470 --> 00:18:08,820
engine right now because of memory

453
00:18:06,390 --> 00:18:10,470
management well they want to fix it by

454
00:18:08,820 --> 00:18:12,960
implementing this thing called web

455
00:18:10,470 --> 00:18:14,880
assembly GC web assembly garbage

456
00:18:12,960 --> 00:18:16,679
collection and this will be a feature

457
00:18:14,880 --> 00:18:19,050
that allows you to add to ask for a

458
00:18:16,679 --> 00:18:21,480
small slab of memory and have it managed

459
00:18:19,050 --> 00:18:23,639
by web assembly and this little make it

460
00:18:21,480 --> 00:18:25,770
possible to implement java but i think

461
00:18:23,640 --> 00:18:27,330
all the good things about memory like

462
00:18:25,770 --> 00:18:28,620
the signal buffer is and that sort of

463
00:18:27,330 --> 00:18:30,360
thing are going to go away if they

464
00:18:28,620 --> 00:18:32,340
implement this so I think if this

465
00:18:30,360 --> 00:18:34,139
feature does go in web assembly will

466
00:18:32,340 --> 00:18:38,070
suddenly start to have a lot of memory

467
00:18:34,140 --> 00:18:39,570
management bugs in it so who knows the

468
00:18:38,070 --> 00:18:40,350
future of web assembly hasn't been

469
00:18:39,570 --> 00:18:42,270
decided yet

470
00:18:40,350 --> 00:18:44,610
but this is one possible direction

471
00:18:42,270 --> 00:18:46,530
although they may also continue to go in

472
00:18:44,610 --> 00:18:50,760
the direction of limited features and

473
00:18:46,530 --> 00:18:52,980
attack surface - so that was web

474
00:18:50,760 --> 00:18:55,590
assembly and after that I looked at this

475
00:18:52,980 --> 00:18:57,120
other feature which is WebRTC and what

476
00:18:55,590 --> 00:18:59,939
was interesting about this is I ended up

477
00:18:57,120 --> 00:19:01,830
taking a very different approach with

478
00:18:59,940 --> 00:19:04,170
web assembly I went through every

479
00:19:01,830 --> 00:19:06,270
feature one by one and looked at how it

480
00:19:04,170 --> 00:19:08,730
worked and looked at the code and

481
00:19:06,270 --> 00:19:10,950
figured out where the bugs were and I

482
00:19:08,730 --> 00:19:12,750
look at historic bugs and used them to

483
00:19:10,950 --> 00:19:16,200
figure out what sort of bugs happened in

484
00:19:12,750 --> 00:19:18,240
web assembly and WebRTC this wasn't

485
00:19:16,200 --> 00:19:20,280
really an option partially because the

486
00:19:18,240 --> 00:19:22,559
code base was so large there were so

487
00:19:20,280 --> 00:19:25,379
many features and I actually couldn't

488
00:19:22,559 --> 00:19:28,440
find a single historic bug in it not a

489
00:19:25,380 --> 00:19:30,720
single historic security bug so I ended

490
00:19:28,440 --> 00:19:33,840
up doing a lot of fuzzing and I'll

491
00:19:30,720 --> 00:19:38,010
describe a bit how that worked so what

492
00:19:33,840 --> 00:19:42,389
is WebRTC WebRTC is an audio video

493
00:19:38,010 --> 00:19:44,910
conferencing library in browsers so if

494
00:19:42,390 --> 00:19:48,150
you say use dumb videoconferencing in

495
00:19:44,910 --> 00:19:49,830
Facebook you've used WebRTC any video

496
00:19:48,150 --> 00:19:52,830
conferencing you do in a browser these

497
00:19:49,830 --> 00:19:55,918
days is probably WebRTC and it's also in

498
00:19:52,830 --> 00:19:58,120
a lot of mobile applications it was

499
00:19:55,919 --> 00:20:01,210
first implemented in 2011

500
00:19:58,120 --> 00:20:04,169
and then it hit most browsers in 2015

501
00:20:01,210 --> 00:20:06,340
and it actually has a good usage rate

502
00:20:04,170 --> 00:20:08,500
but I was surprised when I looked at it

503
00:20:06,340 --> 00:20:11,020
there was basically no security

504
00:20:08,500 --> 00:20:13,030
information and available no information

505
00:20:11,020 --> 00:20:14,800
on how to file a security bug no

506
00:20:13,030 --> 00:20:17,290
information on how you should patch it

507
00:20:14,800 --> 00:20:18,310
and I couldn't find any historic bugs so

508
00:20:17,290 --> 00:20:20,379
I thought you know this would be

509
00:20:18,310 --> 00:20:22,929
interesting even if I found nothing just

510
00:20:20,380 --> 00:20:26,260
because you know there didn't seem to be

511
00:20:22,930 --> 00:20:28,180
any info available so how does web RTC

512
00:20:26,260 --> 00:20:31,180
actually work well it's a peer-to-peer

513
00:20:28,180 --> 00:20:32,560
protocol and then it and negotiate is

514
00:20:31,180 --> 00:20:36,280
this connection using something called

515
00:20:32,560 --> 00:20:38,290
signaling so signaling is not defined by

516
00:20:36,280 --> 00:20:40,899
the specification you can do this anyway

517
00:20:38,290 --> 00:20:42,520
and basically signaling is where you

518
00:20:40,900 --> 00:20:44,680
need to exchange two pieces of

519
00:20:42,520 --> 00:20:46,150
information to decide what sort of

520
00:20:44,680 --> 00:20:47,320
connection you're going to create with

521
00:20:46,150 --> 00:20:49,600
the peer with the person you're gonna

522
00:20:47,320 --> 00:20:51,490
call and there's lots of ways you can do

523
00:20:49,600 --> 00:20:53,590
this on a browser it tends to be done

524
00:20:51,490 --> 00:20:55,090
using WebSockets on something like

525
00:20:53,590 --> 00:20:56,740
Facebook where you already have a

526
00:20:55,090 --> 00:20:58,929
connection they'll just send a Facebook

527
00:20:56,740 --> 00:20:59,890
message to the other peer saying you

528
00:20:58,930 --> 00:21:02,470
know I want to start a web RTC

529
00:20:59,890 --> 00:21:04,690
connection but once you've sorted out

530
00:21:02,470 --> 00:21:07,510
your signaling then you start your

531
00:21:04,690 --> 00:21:09,250
peer-to-peer connection and your video

532
00:21:07,510 --> 00:21:12,879
streaming goes from peer to peer and

533
00:21:09,250 --> 00:21:14,860
this is actually a good way to or a good

534
00:21:12,880 --> 00:21:17,140
potential area for bugs because if you

535
00:21:14,860 --> 00:21:19,629
think about messaging usually it goes

536
00:21:17,140 --> 00:21:22,060
through a server and what happens there

537
00:21:19,630 --> 00:21:24,490
is your risk that your stuff is gonna

538
00:21:22,060 --> 00:21:27,070
get filtered by the server also if

539
00:21:24,490 --> 00:21:29,920
there's a really bad bug they might just

540
00:21:27,070 --> 00:21:32,169
turn this off but for the peer-to-peer

541
00:21:29,920 --> 00:21:34,420
message it's very hard for the server to

542
00:21:32,170 --> 00:21:38,070
filter it so I thought that was a good

543
00:21:34,420 --> 00:21:43,150
attack area so from a protocol level

544
00:21:38,070 --> 00:21:45,189
this is how it works on I guess my right

545
00:21:43,150 --> 00:21:47,680
this is the signaling protocols

546
00:21:45,190 --> 00:21:50,740
so typically signaling is done over TCP

547
00:21:47,680 --> 00:21:53,080
over SSL and then in a browser it can be

548
00:21:50,740 --> 00:21:55,060
HTTP it can be WebSockets it can be a

549
00:21:53,080 --> 00:21:56,980
lot of things but they don't mess it

550
00:21:55,060 --> 00:21:58,870
mention here is there's a lot of mobile

551
00:21:56,980 --> 00:22:01,800
messaging where they use the mobile

552
00:21:58,870 --> 00:22:05,260
message Jack should actually send the

553
00:22:01,800 --> 00:22:07,570
signaling and then on this side there is

554
00:22:05,260 --> 00:22:11,410
the actual stream that sends the video

555
00:22:07,570 --> 00:22:13,810
or the audio and it says you DB PPE

556
00:22:11,410 --> 00:22:15,370
but it's actually possible for this to

557
00:22:13,810 --> 00:22:19,750
be over TCP and a number of other

558
00:22:15,370 --> 00:22:23,469
protocols but usually it's UDP and then

559
00:22:19,750 --> 00:22:26,020
there's ice stun and turn and these are

560
00:22:23,470 --> 00:22:28,750
the three protocols that help you get

561
00:22:26,020 --> 00:22:33,370
around the NAT so usually on a network

562
00:22:28,750 --> 00:22:35,890
it can be difficult to hit one peer from

563
00:22:33,370 --> 00:22:37,989
another peer depending on your firewalls

564
00:22:35,890 --> 00:22:39,760
but this is these are the servers that

565
00:22:37,990 --> 00:22:43,300
will help you find the way that you can

566
00:22:39,760 --> 00:22:44,950
talk to the other peer and then there's

567
00:22:43,300 --> 00:22:48,460
different protocols this is usually once

568
00:22:44,950 --> 00:22:52,660
again over SSL and then the interesting

569
00:22:48,460 --> 00:22:54,670
protocol is SRTP or RTP where they

570
00:22:52,660 --> 00:22:57,580
actually send the audio and video and

571
00:22:54,670 --> 00:22:59,380
then there's also SCTP that's used to

572
00:22:57,580 --> 00:23:01,149
send data over this channel if you need

573
00:22:59,380 --> 00:23:02,980
data over this channel but I'd say

574
00:23:01,150 --> 00:23:06,310
that's kind of a less used and less

575
00:23:02,980 --> 00:23:09,190
complex protocol so what was my first

576
00:23:06,310 --> 00:23:11,230
idea well I was actually first

577
00:23:09,190 --> 00:23:12,850
interested in the signaling because even

578
00:23:11,230 --> 00:23:15,520
though it goes through a server and it's

579
00:23:12,850 --> 00:23:17,110
a bit complex it would be really useful

580
00:23:15,520 --> 00:23:19,690
if there was a bug in signaling just

581
00:23:17,110 --> 00:23:21,629
because it's interaction free you signal

582
00:23:19,690 --> 00:23:23,920
before someone picks up the phone so

583
00:23:21,630 --> 00:23:28,180
that would be a nice way to find remote

584
00:23:23,920 --> 00:23:29,320
bugs and when you signal in WebRTC you

585
00:23:28,180 --> 00:23:34,570
use a protocol called

586
00:23:29,320 --> 00:23:36,879
SDP and WebRTC requires you to do this

587
00:23:34,570 --> 00:23:39,010
before the person picks up the calls so

588
00:23:36,880 --> 00:23:41,920
you're parsing this untrusted data with

589
00:23:39,010 --> 00:23:44,020
no interaction so I used the web RTC

590
00:23:41,920 --> 00:23:46,060
library to create a fuzzer for this

591
00:23:44,020 --> 00:23:48,220
format on the command line and I

592
00:23:46,060 --> 00:23:50,200
reviewed all the code and I found

593
00:23:48,220 --> 00:23:53,140
absolutely no bugs so this turned out

594
00:23:50,200 --> 00:23:54,880
not to be a great area to look at but

595
00:23:53,140 --> 00:23:57,220
and I also discovered that some

596
00:23:54,880 --> 00:23:59,800
platforms implemented separately like

597
00:23:57,220 --> 00:24:04,390
Firefox uses WebRTC but they don't use

598
00:23:59,800 --> 00:24:06,760
the WebRTC implementation of SDP and

599
00:24:04,390 --> 00:24:09,280
likewise WebKit they do just use the web

600
00:24:06,760 --> 00:24:11,680
RTC implementation but they've actually

601
00:24:09,280 --> 00:24:13,899
branched quite a bit so I thought this

602
00:24:11,680 --> 00:24:15,760
would also be a multi browser but this

603
00:24:13,900 --> 00:24:18,100
turned out not to be the case so you

604
00:24:15,760 --> 00:24:21,250
know scratch that idea and I moved on to

605
00:24:18,100 --> 00:24:25,000
something different so the next idea was

606
00:24:21,250 --> 00:24:28,210
to look at RTP and media protocols

607
00:24:25,000 --> 00:24:30,549
RTP is the remote transfer protocol and

608
00:24:28,210 --> 00:24:32,919
this is the protocol that has all the

609
00:24:30,549 --> 00:24:35,650
video and audio packets in it and then

610
00:24:32,919 --> 00:24:37,690
once the RTP is processed there's media

611
00:24:35,650 --> 00:24:39,909
protocols and then there's the audio and

612
00:24:37,690 --> 00:24:43,030
video codecs that actually process your

613
00:24:39,909 --> 00:24:45,100
call and in WebRTC I noticed they'd

614
00:24:43,030 --> 00:24:46,960
actually written fuzzers for OSS fuzz

615
00:24:45,100 --> 00:24:49,240
for every single protocol in every

616
00:24:46,960 --> 00:24:51,429
single codec and I thought you know this

617
00:24:49,240 --> 00:24:52,929
probably won't have any bugs in it but I

618
00:24:51,429 --> 00:24:54,730
thought well you know I'm gonna try

619
00:24:52,929 --> 00:24:56,950
doing this end-to-end just in case

620
00:24:54,730 --> 00:24:59,080
there's problems where you know one

621
00:24:56,950 --> 00:25:00,490
parser purse is something one way but

622
00:24:59,080 --> 00:25:02,918
then when it gets to the next parse or

623
00:25:00,490 --> 00:25:05,559
actually gets to used maybe they haven't

624
00:25:02,919 --> 00:25:08,980
actually validated that data right so I

625
00:25:05,559 --> 00:25:12,010
wrote an end-to-end fuzzer for RTP so I

626
00:25:08,980 --> 00:25:14,860
started off by I'm prototyping it and

627
00:25:12,010 --> 00:25:17,770
the way I did this was I altered chrome

628
00:25:14,860 --> 00:25:19,719
to randomly change a bite of every tenth

629
00:25:17,770 --> 00:25:22,990
packet underneath the encryption layer

630
00:25:19,720 --> 00:25:25,539
of RTP and then I called one browser

631
00:25:22,990 --> 00:25:28,690
from another and it crashed every 30

632
00:25:25,539 --> 00:25:32,260
seconds so clearly this was something

633
00:25:28,690 --> 00:25:33,909
that was worth putting time into I like

634
00:25:32,260 --> 00:25:35,860
the concept with generally work and I

635
00:25:33,909 --> 00:25:37,809
got some very shallow bugs that blocked

636
00:25:35,860 --> 00:25:39,428
fuzzing fixed I'm a lot of these weren't

637
00:25:37,809 --> 00:25:42,220
exploitable bugs there were actually a

638
00:25:39,429 --> 00:25:47,200
lot of / 0 floating-point exceptions

639
00:25:42,220 --> 00:25:51,549
that happened here but got them fixed so

640
00:25:47,200 --> 00:25:54,549
then I start you know dude part 2 which

641
00:25:51,549 --> 00:25:56,530
is a rodas c++ client that interacts

642
00:25:54,549 --> 00:25:58,240
with the browser and what was nice about

643
00:25:56,530 --> 00:26:00,520
this is it was lighter weight it could

644
00:25:58,240 --> 00:26:04,270
run a lot faster and I could run it

645
00:26:00,520 --> 00:26:07,120
against any target browser I wanted what

646
00:26:04,270 --> 00:26:10,030
was good about it is it was a very good

647
00:26:07,120 --> 00:26:12,459
representation of WebRTC every bug that

648
00:26:10,030 --> 00:26:15,309
made your browser crash was a real bug

649
00:26:12,460 --> 00:26:18,070
that caused a problem the con of this it

650
00:26:15,309 --> 00:26:22,270
was slow but it did find additional and

651
00:26:18,070 --> 00:26:24,700
Denville 'nor abilities in WebRTC um and

652
00:26:22,270 --> 00:26:26,799
what happened next well I was filing all

653
00:26:24,700 --> 00:26:28,900
these WebRTC bugs with these really

654
00:26:26,799 --> 00:26:30,879
complicated reproduction steps oh you

655
00:26:28,900 --> 00:26:33,820
know build the browser but change the

656
00:26:30,880 --> 00:26:36,520
code Oh build the C++ then run this

657
00:26:33,820 --> 00:26:38,350
server then run your web page and web

658
00:26:36,520 --> 00:26:42,039
RTC you team kind of got

659
00:26:38,350 --> 00:26:43,750
of me and they said well you know we

660
00:26:42,039 --> 00:26:45,940
have this tool that you can use to

661
00:26:43,750 --> 00:26:48,940
record our TP in the browser and play it

662
00:26:45,940 --> 00:26:51,669
back in this video replay client and I

663
00:26:48,940 --> 00:26:53,590
tried it and it didn't exactly work it

664
00:26:51,669 --> 00:26:56,470
would work with the default settings but

665
00:26:53,590 --> 00:26:57,850
with all the not default settings I'm it

666
00:26:56,470 --> 00:27:00,669
wouldn't work so I spend some time

667
00:26:57,850 --> 00:27:03,789
rewriting it so that it would have the

668
00:27:00,669 --> 00:27:05,020
SDP protocol that you put in in Jason

669
00:27:03,789 --> 00:27:07,629
and then it would load it when you tried

670
00:27:05,020 --> 00:27:11,220
to replay it and this actually worked

671
00:27:07,630 --> 00:27:14,350
and this has now been committed to

672
00:27:11,220 --> 00:27:16,150
WebRTC mainline and this was really good

673
00:27:14,350 --> 00:27:17,799
what was nice about it is it was

674
00:27:16,150 --> 00:27:20,110
extremely fast it was extremely portable

675
00:27:17,799 --> 00:27:22,809
it was extremely easy to actually

676
00:27:20,110 --> 00:27:25,030
reproduce any bugs you found the

677
00:27:22,809 --> 00:27:28,289
downside is it was now not an exact

678
00:27:25,030 --> 00:27:31,889
representation of any WebRTC

679
00:27:28,289 --> 00:27:36,429
implementation so I did have an issue

680
00:27:31,890 --> 00:27:38,320
with false-positive bugs but it was good

681
00:27:36,429 --> 00:27:40,090
it could also run on multiple cores so I

682
00:27:38,320 --> 00:27:42,158
could fuzz very quickly and I could also

683
00:27:40,090 --> 00:27:47,289
build it with a sandwich improved

684
00:27:42,159 --> 00:27:49,330
fuzzing and I found a lot of bugs so let

685
00:27:47,289 --> 00:27:52,900
me show you some of these bugs they're

686
00:27:49,330 --> 00:27:56,260
actually pretty cool um actually this

687
00:27:52,900 --> 00:27:58,240
bug I found it was pretty interesting

688
00:27:56,260 --> 00:27:59,320
and I have to say I've never seen a bug

689
00:27:58,240 --> 00:28:01,630
like this before

690
00:27:59,320 --> 00:28:03,100
so I want to give everyone maybe 30

691
00:28:01,630 --> 00:28:05,080
seconds a minute to take a look at this

692
00:28:03,100 --> 00:28:07,899
and put your hand up if you think you

693
00:28:05,080 --> 00:28:10,960
know what the bug is a problem with the

694
00:28:07,900 --> 00:28:13,990
find function there that data access

695
00:28:10,960 --> 00:28:17,020
directly the the second eye could be a

696
00:28:13,990 --> 00:28:18,850
problem yeah that's that's exactly the

697
00:28:17,020 --> 00:28:20,289
problem and this is exciting I've given

698
00:28:18,850 --> 00:28:22,270
this talk to other people and no one has

699
00:28:20,289 --> 00:28:26,350
ever got that right before so that's

700
00:28:22,270 --> 00:28:30,370
awesome that's exactly the problem find

701
00:28:26,350 --> 00:28:32,408
is comes right out of the codec header

702
00:28:30,370 --> 00:28:34,928
so there's no guarantee that you're

703
00:28:32,409 --> 00:28:37,840
actually going to find this one but it

704
00:28:34,929 --> 00:28:39,490
still uses it like it was found so I'd

705
00:28:37,840 --> 00:28:42,490
never seen anything like this before so

706
00:28:39,490 --> 00:28:47,470
I looked up what the map iterator find

707
00:28:42,490 --> 00:28:49,540
actually does and it finds the key but

708
00:28:47,470 --> 00:28:52,120
then if it doesn't find anything it

709
00:28:49,540 --> 00:28:53,950
gives back end and that actually points

710
00:28:52,120 --> 00:28:55,719
to the end of the buffer all the stuff

711
00:28:53,950 --> 00:28:57,490
is being kept in so basically it's a

712
00:28:55,720 --> 00:29:00,159
pointer that points out of bounds and

713
00:28:57,490 --> 00:29:02,140
then this code is just using it so you

714
00:29:00,159 --> 00:29:05,950
can basically just change that value to

715
00:29:02,140 --> 00:29:08,380
be anything and then there was another

716
00:29:05,950 --> 00:29:12,039
issue and this one was kind of similar

717
00:29:08,380 --> 00:29:14,049
to that one and this is once again the

718
00:29:12,039 --> 00:29:16,720
red thing a value pulled out of the

719
00:29:14,049 --> 00:29:18,668
packet and then it calls lower bound and

720
00:29:16,720 --> 00:29:20,200
this is something that basically strips

721
00:29:18,669 --> 00:29:23,020
everything that's lower than a certain

722
00:29:20,200 --> 00:29:24,940
value out of a vector and then that

723
00:29:23,020 --> 00:29:27,190
happens then they erase everything that

724
00:29:24,940 --> 00:29:29,230
they stripped out and then you'll notice

725
00:29:27,190 --> 00:29:30,580
at the bottom here though they use

726
00:29:29,230 --> 00:29:32,830
something that they pulled out of this

727
00:29:30,580 --> 00:29:35,080
vector before they called the erase

728
00:29:32,830 --> 00:29:38,379
function so this is once again I use

729
00:29:35,080 --> 00:29:40,600
after free and another thing that's

730
00:29:38,380 --> 00:29:42,789
related to basically vectors and

731
00:29:40,600 --> 00:29:44,529
different C++ constructs and it's

732
00:29:42,789 --> 00:29:46,000
actually fairly unusual to see bugs like

733
00:29:44,529 --> 00:29:48,070
this or at least I haven't seen that

734
00:29:46,000 --> 00:29:52,570
many reported so I thought they were

735
00:29:48,070 --> 00:29:56,470
pretty interesting now there's this bug

736
00:29:52,570 --> 00:29:58,360
this bug is a more typical bug if you

737
00:29:56,470 --> 00:30:02,440
start off at the top you're going

738
00:29:58,360 --> 00:30:06,158
through this loop with temporal ID X and

739
00:30:02,440 --> 00:30:08,710
then you're indexing at L and then where

740
00:30:06,159 --> 00:30:10,899
did L come from well you read it out of

741
00:30:08,710 --> 00:30:14,049
the packet and this was a clear size

742
00:30:10,899 --> 00:30:16,658
mismatch they allocated a buffer of 5

743
00:30:14,049 --> 00:30:18,250
for this but if you read three bits if

744
00:30:16,659 --> 00:30:20,770
you think about it that can go up to the

745
00:30:18,250 --> 00:30:24,940
value of 7 so that ended up being just

746
00:30:20,770 --> 00:30:27,970
too out of bounds and then there was

747
00:30:24,940 --> 00:30:30,940
this bug this bug I thought was pretty

748
00:30:27,970 --> 00:30:33,299
interesting and it was also like a

749
00:30:30,940 --> 00:30:35,919
little bit simpler than I expected so

750
00:30:33,299 --> 00:30:37,510
there's a protocol called forward errand

751
00:30:35,919 --> 00:30:39,399
error correction and you can send

752
00:30:37,510 --> 00:30:42,429
forward error correction packets and

753
00:30:39,399 --> 00:30:45,729
theoretically they have a limit of 1,500

754
00:30:42,429 --> 00:30:48,130
bytes so WebRTC just copied every packet

755
00:30:45,730 --> 00:30:51,340
off the wire into a 1500 byte buffer

756
00:30:48,130 --> 00:30:52,870
without checking it but realistically in

757
00:30:51,340 --> 00:30:55,059
UDP you can probably go up to about a

758
00:30:52,870 --> 00:30:57,189
two thousand bytes so this ended up just

759
00:30:55,059 --> 00:30:59,080
being a huge mem copy overflow of a

760
00:30:57,190 --> 00:31:01,419
controlled size so this was a fairly

761
00:30:59,080 --> 00:31:04,600
good bug and one that I was surprised to

762
00:31:01,419 --> 00:31:06,440
find in WebRTC and then there was some

763
00:31:04,600 --> 00:31:09,490
kind of less interesting more tip

764
00:31:06,440 --> 00:31:11,870
bugs there was a use after free in vp8

765
00:31:09,490 --> 00:31:13,070
the decoder and this I guess was

766
00:31:11,870 --> 00:31:15,560
interesting about this one as it

767
00:31:13,070 --> 00:31:16,730
affected far more than WebRTC actually

768
00:31:15,560 --> 00:31:20,210
lauded lots of things use the vp8

769
00:31:16,730 --> 00:31:24,400
decoder and then there was this not very

770
00:31:20,210 --> 00:31:28,810
good bug in h.264 it was type confusion

771
00:31:24,400 --> 00:31:31,730
in that if something wasn't actually

772
00:31:28,810 --> 00:31:33,740
h.264 stream but then you made it look

773
00:31:31,730 --> 00:31:36,230
like an h.264 stream it would start

774
00:31:33,740 --> 00:31:40,490
confusing its type and it would end in a

775
00:31:36,230 --> 00:31:42,950
read out of bounds but wait there's more

776
00:31:40,490 --> 00:31:44,800
and this was I think the most surprising

777
00:31:42,950 --> 00:31:47,930
thing I found out of all this research

778
00:31:44,800 --> 00:31:50,419
web RTC it turns out is used by many

779
00:31:47,930 --> 00:31:52,490
many many third parties it's used by

780
00:31:50,420 --> 00:31:54,530
Facebook it's used by whatsapp used by

781
00:31:52,490 --> 00:31:57,950
signal it's used by viber it's used by

782
00:31:54,530 --> 00:31:59,629
slack every and I put an asterisk here

783
00:31:57,950 --> 00:32:02,090
because this is just a stat I made up

784
00:31:59,630 --> 00:32:03,680
it's not based on actual information but

785
00:32:02,090 --> 00:32:06,740
I think it's probably true that almost

786
00:32:03,680 --> 00:32:09,350
every mobile device has at least one and

787
00:32:06,740 --> 00:32:12,860
probably four or five implementations of

788
00:32:09,350 --> 00:32:15,649
WebRTC on it and I can turn me even more

789
00:32:12,860 --> 00:32:17,540
was that the WebRTC documentation didn't

790
00:32:15,650 --> 00:32:19,430
have any guidance on updates when

791
00:32:17,540 --> 00:32:22,129
developers started using this there was

792
00:32:19,430 --> 00:32:23,600
no place they could get updates or you

793
00:32:22,130 --> 00:32:25,640
know no guidance that this is something

794
00:32:23,600 --> 00:32:27,320
they should do regularly and actually a

795
00:32:25,640 --> 00:32:29,750
lot of these implementations have

796
00:32:27,320 --> 00:32:31,610
branched now so I've been working with

797
00:32:29,750 --> 00:32:33,260
WebRTC to help them provide better

798
00:32:31,610 --> 00:32:35,270
guidance provide better ways to report

799
00:32:33,260 --> 00:32:37,280
bugs and that sort of thing but there's

800
00:32:35,270 --> 00:32:39,650
still quite a few patch gaps in the

801
00:32:37,280 --> 00:32:43,550
existing web RTC implementations and I

802
00:32:39,650 --> 00:32:45,950
hope this gets better so the web RTC

803
00:32:43,550 --> 00:32:49,100
fuzzing um as I said this has been

804
00:32:45,950 --> 00:32:51,230
committed into WebRTC not the version I

805
00:32:49,100 --> 00:32:53,030
wrote they told me my coding style

806
00:32:51,230 --> 00:32:56,600
wasn't good enough and they rewrote it

807
00:32:53,030 --> 00:32:59,149
but it is in there now and you can use

808
00:32:56,600 --> 00:33:01,429
this to fuzz WebRTC I'd encourage you to

809
00:32:59,150 --> 00:33:03,020
try this at home it's pretty easy you

810
00:33:01,430 --> 00:33:04,550
record a stream in the browser and then

811
00:33:03,020 --> 00:33:06,500
you play it back and then if you fuzz

812
00:33:04,550 --> 00:33:08,720
the recorded stuff if you just alter it

813
00:33:06,500 --> 00:33:11,240
it'll let you try different WebRTC

814
00:33:08,720 --> 00:33:15,050
packets on your browser and this is an

815
00:33:11,240 --> 00:33:20,130
area I think needs a lot more work so um

816
00:33:15,050 --> 00:33:23,310
in conclusion um many browser features

817
00:33:20,130 --> 00:33:25,050
have limited external security attention

818
00:33:23,310 --> 00:33:27,780
I'm surprised especially with the WebRTC

819
00:33:25,050 --> 00:33:29,430
but even the webassembly how little

820
00:33:27,780 --> 00:33:30,780
public stuff had been written about this

821
00:33:29,430 --> 00:33:32,760
so I think there's a lot of

822
00:33:30,780 --> 00:33:34,170
opportunities to look at these features

823
00:33:32,760 --> 00:33:36,510
you know that aren't JavaScript that

824
00:33:34,170 --> 00:33:39,480
aren't HTML and find good bugs

825
00:33:36,510 --> 00:33:41,040
I also learned from this that different

826
00:33:39,480 --> 00:33:43,410
bug finding techniques work well on

827
00:33:41,040 --> 00:33:44,970
different targets I'm usually the person

828
00:33:43,410 --> 00:33:47,640
that reads the standard and looks at

829
00:33:44,970 --> 00:33:49,620
every feature one by one and finds bugs

830
00:33:47,640 --> 00:33:51,750
that way but this didn't work out with

831
00:33:49,620 --> 00:33:54,840
WebRTC and this was actually a target

832
00:33:51,750 --> 00:33:57,330
where fuzzing worked really well another

833
00:33:54,840 --> 00:34:00,810
conclusion is both of these projects had

834
00:33:57,330 --> 00:34:03,419
a high tooling cost for WebRTC I had to

835
00:34:00,810 --> 00:34:06,419
you know figure out the assembler make a

836
00:34:03,420 --> 00:34:09,480
tool that would copy the bytes into the

837
00:34:06,420 --> 00:34:12,179
browser and let me change them for the

838
00:34:09,480 --> 00:34:14,639
WebRTC I had to fix up that video player

839
00:34:12,179 --> 00:34:16,710
both of these were like more effort than

840
00:34:14,639 --> 00:34:18,360
I usually put into tooling but for both

841
00:34:16,710 --> 00:34:21,659
of them it was worth it with regards to

842
00:34:18,360 --> 00:34:26,399
finding bugs so I think I've discovered

843
00:34:21,659 --> 00:34:28,230
that that effort can be worth it and I

844
00:34:26,399 --> 00:34:29,879
also discovered that both projects could

845
00:34:28,230 --> 00:34:31,740
have benefited from more thought on

846
00:34:29,879 --> 00:34:34,799
patching strategies for now on browser

847
00:34:31,739 --> 00:34:37,469
users both of them have had people who

848
00:34:34,800 --> 00:34:40,050
are using web assembly and WebRTC not in

849
00:34:37,469 --> 00:34:41,699
a browser for various purposes and I

850
00:34:40,050 --> 00:34:43,710
don't think they thought about what is

851
00:34:41,699 --> 00:34:45,509
the patching strategy for these people

852
00:34:43,710 --> 00:34:47,040
when they started creating these

853
00:34:45,510 --> 00:34:48,810
features and I think that's something

854
00:34:47,040 --> 00:34:50,759
that could have had a great benefit

855
00:34:48,810 --> 00:34:53,659
because right now both of them have the

856
00:34:50,760 --> 00:34:58,230
situation where there are many unpatched

857
00:34:53,659 --> 00:35:01,140
implementations so that's it I'm gonna

858
00:34:58,230 --> 00:35:03,450
have about five or 10 minutes for

859
00:35:01,140 --> 00:35:07,049
questions and then I have a set of bonus

860
00:35:03,450 --> 00:35:11,520
slides for you here I said you said that

861
00:35:07,050 --> 00:35:15,570
there are in the memory allocation of

862
00:35:11,520 --> 00:35:18,630
the web assembly a chunk of memory is

863
00:35:15,570 --> 00:35:21,540
allocated allocated for the assembly

864
00:35:18,630 --> 00:35:25,580
code right that it is because of this

865
00:35:21,540 --> 00:35:29,400
that you don't have many out-of-bounds

866
00:35:25,580 --> 00:35:30,490
problems with with a web assembly this

867
00:35:29,400 --> 00:35:34,810
is that

868
00:35:30,490 --> 00:35:37,149
generate and tremaine memory costs like

869
00:35:34,810 --> 00:35:40,170
you could have like several web

870
00:35:37,150 --> 00:35:45,660
assemblies loaded in the memory and

871
00:35:40,170 --> 00:35:50,260
every every bit of a burr assembly like

872
00:35:45,660 --> 00:35:53,589
getting its chunk of memory and not

873
00:35:50,260 --> 00:35:58,869
using that whole memory um

874
00:35:53,589 --> 00:36:02,109
I guess sort of so you have these chunks

875
00:35:58,869 --> 00:36:03,760
of memory and webassembly instances they

876
00:36:02,109 --> 00:36:06,310
can either use your chunk or they can

877
00:36:03,760 --> 00:36:07,660
use their own but every instance can

878
00:36:06,310 --> 00:36:08,830
only use one piece of memory so it

879
00:36:07,660 --> 00:36:11,020
either either has to completely share

880
00:36:08,830 --> 00:36:13,569
the memory or completely use its own

881
00:36:11,020 --> 00:36:14,830
memory there's no opportunity for web

882
00:36:13,570 --> 00:36:18,820
assembly Institute's to have like more

883
00:36:14,830 --> 00:36:20,890
than one slab of memory does that make

884
00:36:18,820 --> 00:36:26,020
sense I think so

885
00:36:20,890 --> 00:36:30,720
hi so with node and webassembly can we

886
00:36:26,020 --> 00:36:36,940
use I don't know if no they already have

887
00:36:30,720 --> 00:36:42,430
implemented assembly but if they do can

888
00:36:36,940 --> 00:36:46,599
we use it for to get security issues

889
00:36:42,430 --> 00:36:51,399
from the server side I mean to explorers

890
00:36:46,599 --> 00:36:54,400
and if any anything yeah so that's the

891
00:36:51,400 --> 00:36:56,349
area that I looked at less I think the

892
00:36:54,400 --> 00:36:58,140
browser side is much more dangerous here

893
00:36:56,349 --> 00:37:00,580
in that you're actually processing

894
00:36:58,140 --> 00:37:02,290
untrusted web assembly and for things

895
00:37:00,580 --> 00:37:04,029
like no it's mostly going to be code you

896
00:37:02,290 --> 00:37:05,710
wrote so that so really you're getting

897
00:37:04,030 --> 00:37:08,020
into that second problem I showed on my

898
00:37:05,710 --> 00:37:10,780
slides which is maybe someone will write

899
00:37:08,020 --> 00:37:12,250
a vulnerable web assembly and I like and

900
00:37:10,780 --> 00:37:15,220
I do think that's a possibility but it's

901
00:37:12,250 --> 00:37:18,420
a very different problem than the issue

902
00:37:15,220 --> 00:37:18,419
of untrusted webassembly

903
00:37:18,450 --> 00:37:28,868
any more questions okay I'm gonna move

904
00:37:24,609 --> 00:37:30,279
on to bonus slides here then so I'm

905
00:37:28,869 --> 00:37:32,980
going to talk a bit about the whatsapp

906
00:37:30,280 --> 00:37:40,270
bug I found which was an offshoot of the

907
00:37:32,980 --> 00:37:43,000
WebRTC research so as I said what's up

908
00:37:40,270 --> 00:37:43,759
uses WebRTC but it also uses something

909
00:37:43,000 --> 00:37:46,249
called

910
00:37:43,759 --> 00:37:49,729
PJ sip and PJ sip is basically just

911
00:37:46,249 --> 00:37:52,009
another WebRTC type implementation it's

912
00:37:49,729 --> 00:37:53,448
also open source but it's commercial so

913
00:37:52,009 --> 00:37:57,229
if you put it into a product you have to

914
00:37:53,449 --> 00:38:00,859
pay for it and so whatsapp combines

915
00:37:57,229 --> 00:38:03,799
these two so the WebRTC issues didn't

916
00:38:00,859 --> 00:38:08,719
actually affect whatsapp so I wanted to

917
00:38:03,799 --> 00:38:10,549
go and find my own bike in whatsapp so I

918
00:38:08,719 --> 00:38:12,919
looked at the Android app because

919
00:38:10,549 --> 00:38:17,299
Android is far more debuggable than iOS

920
00:38:12,919 --> 00:38:20,658
and there were no symbols but they use a

921
00:38:17,299 --> 00:38:24,769
bar Lib SRTP which was written by Cisco

922
00:38:20,659 --> 00:38:27,199
and is also in WebRTC and I found the

923
00:38:24,769 --> 00:38:29,629
log entries and I eventually found a mem

924
00:38:27,199 --> 00:38:31,819
copy where they copied the packet right

925
00:38:29,630 --> 00:38:33,499
before it's encrypted so I decided I

926
00:38:31,819 --> 00:38:37,038
wanted to hook into that to do my

927
00:38:33,499 --> 00:38:38,988
fuzzing so I used a tool called frida

928
00:38:37,039 --> 00:38:41,989
which by the way is completely awesome

929
00:38:38,989 --> 00:38:44,329
and it's a server that you can put on

930
00:38:41,989 --> 00:38:47,059
your Android device and it'll allow you

931
00:38:44,329 --> 00:38:48,919
to hook a lot of functions so I started

932
00:38:47,059 --> 00:38:50,929
off by hooking mem copy and what was

933
00:38:48,919 --> 00:38:52,908
nice about it is it was like five

934
00:38:50,929 --> 00:38:55,429
seconds between starting frida and

935
00:38:52,909 --> 00:38:57,469
hooking mem copy but it turned out to

936
00:38:55,429 --> 00:39:00,380
not work well enough for what I was

937
00:38:57,469 --> 00:39:02,269
doing the problem with these video calls

938
00:39:00,380 --> 00:39:04,579
is there e calling like mem copy like

939
00:39:02,269 --> 00:39:07,158
many many times per second and for you

940
00:39:04,579 --> 00:39:08,509
too cause lag but it was good to see

941
00:39:07,159 --> 00:39:10,159
that it was at least getting called and

942
00:39:08,509 --> 00:39:16,609
this actually helped me to bug the next

943
00:39:10,159 --> 00:39:19,009
step so my next step was I basically

944
00:39:16,609 --> 00:39:22,788
altered this mem copy to call into a

945
00:39:19,009 --> 00:39:24,259
library that I wrote so my over wrote

946
00:39:22,789 --> 00:39:25,189
the Jeff grant transcoder because I

947
00:39:24,259 --> 00:39:27,679
didn't think I was going to use the

948
00:39:25,189 --> 00:39:31,699
whatsapp if transcoder or probably ever

949
00:39:27,679 --> 00:39:33,679
and I overrode it with this function

950
00:39:31,699 --> 00:39:35,869
that just yellow panda library I put on

951
00:39:33,679 --> 00:39:39,919
my device and call the function I wrote

952
00:39:35,869 --> 00:39:43,789
and then I made the mem copy just point

953
00:39:39,919 --> 00:39:46,489
to that function I totally used an

954
00:39:43,789 --> 00:39:49,939
online armed branch converter to do this

955
00:39:46,489 --> 00:39:51,409
as opposed to doing branch math but I

956
00:39:49,939 --> 00:39:53,178
ended up eventually getting it work to

957
00:39:51,409 --> 00:39:56,029
work so that it would call my code and

958
00:39:53,179 --> 00:39:57,050
then I was able to basically log this

959
00:39:56,029 --> 00:39:59,600
mem copy

960
00:39:57,050 --> 00:40:04,400
and change what packets were going to

961
00:39:59,600 --> 00:40:06,490
the other device on whatsapp so I tried

962
00:40:04,400 --> 00:40:08,750
doing this and I found that my calls

963
00:40:06,490 --> 00:40:10,250
disconnected all the time and then of

964
00:40:08,750 --> 00:40:12,470
course I discovered my code was buggy

965
00:40:10,250 --> 00:40:14,720
and I fixed it so that I could actually

966
00:40:12,470 --> 00:40:17,330
log and alter incoming packets reliably

967
00:40:14,720 --> 00:40:22,069
but I discovered that replaying the

968
00:40:17,330 --> 00:40:26,210
packets by pure copying did not work so

969
00:40:22,070 --> 00:40:28,700
I how it worked a bit more and I

970
00:40:26,210 --> 00:40:32,120
discovered that whatsapp has four RTC

971
00:40:28,700 --> 00:40:33,500
streams so the way the RTP protocol

972
00:40:32,120 --> 00:40:36,200
works is you can have multiple streams

973
00:40:33,500 --> 00:40:37,670
you can have audio you can have video

974
00:40:36,200 --> 00:40:40,339
you know whatever you want and they have

975
00:40:37,670 --> 00:40:42,500
different payload datatypes on them and

976
00:40:40,340 --> 00:40:45,260
also a different what's called an SSR

977
00:40:42,500 --> 00:40:47,960
sea which is just a random identifier so

978
00:40:45,260 --> 00:40:49,610
that if you have like five Facebook

979
00:40:47,960 --> 00:40:51,710
video calls going at the same on at the

980
00:40:49,610 --> 00:40:54,950
same time in your browser they don't

981
00:40:51,710 --> 00:40:57,140
collide with each other so an elaborate

982
00:40:54,950 --> 00:40:58,790
EC this wasn't a problem because since

983
00:40:57,140 --> 00:41:01,009
um you could basically control the

984
00:40:58,790 --> 00:41:03,110
protocol very well I just sized all the

985
00:41:01,010 --> 00:41:05,060
streams one at a time and it's really no

986
00:41:03,110 --> 00:41:07,820
different than having four at a time but

987
00:41:05,060 --> 00:41:10,610
on whatsapp you have to have all we're

988
00:41:07,820 --> 00:41:12,830
running at once and honestly I don't

989
00:41:10,610 --> 00:41:14,660
even know why they have four like it's

990
00:41:12,830 --> 00:41:16,190
one for audio one for video one for

991
00:41:14,660 --> 00:41:19,460
synchronization and I'm guessing like

992
00:41:16,190 --> 00:41:21,530
one for good luck because I don't know

993
00:41:19,460 --> 00:41:25,430
what they all do but they had different

994
00:41:21,530 --> 00:41:27,170
payload types so I made it so that I

995
00:41:25,430 --> 00:41:30,129
would log them separately and play them

996
00:41:27,170 --> 00:41:33,890
back separately and this actually worked

997
00:41:30,130 --> 00:41:36,470
so I replaced my logging function with

998
00:41:33,890 --> 00:41:38,839
something that would alter the outgoing

999
00:41:36,470 --> 00:41:41,560
RTP just change one byte or replace it

1000
00:41:38,840 --> 00:41:44,600
with random bytes or it would just

1001
00:41:41,560 --> 00:41:47,380
elongate or truncate the packet but took

1002
00:41:44,600 --> 00:41:49,580
15 minutes for whatsapp to crash and

1003
00:41:47,380 --> 00:41:56,900
that was how I found this heap

1004
00:41:49,580 --> 00:42:01,190
corruption bug so I think this is the

1005
00:41:56,900 --> 00:42:02,330
end of my bonus slides but it's somebody

1006
00:42:01,190 --> 00:42:05,030
to share with you this was another

1007
00:42:02,330 --> 00:42:07,040
offshoot of this browser thing it wasn't

1008
00:42:05,030 --> 00:42:09,650
quite WebRTC but it got me thinking

1009
00:42:07,040 --> 00:42:10,700
about how video conferencing works on

1010
00:42:09,650 --> 00:42:13,460
different platform

1011
00:42:10,700 --> 00:42:15,770
and what the different bug types are so

1012
00:42:13,460 --> 00:42:17,360
that's another advantage of looking at

1013
00:42:15,770 --> 00:42:19,640
these less known features it kind of

1014
00:42:17,360 --> 00:42:21,770
opened my mind to features that could

1015
00:42:19,640 --> 00:42:24,140
lead to remote code execution that I

1016
00:42:21,770 --> 00:42:27,950
hadn't thought about before so hopefully

1017
00:42:24,140 --> 00:42:30,100
you can take that idea away too thanks a

1018
00:42:27,950 --> 00:42:30,100
lot

