1
00:00:00,030 --> 00:00:19,699
oh good good morning for most of you or

2
00:00:16,830 --> 00:00:23,189
good afternoon for the rest of you

3
00:00:19,699 --> 00:00:25,769
welcome to my talk about GC GC sees the

4
00:00:23,189 --> 00:00:27,359
new pink type on the first slide as

5
00:00:25,769 --> 00:00:29,609
intended because for the last couple

6
00:00:27,359 --> 00:00:32,099
months I've seen a lot of CC all over

7
00:00:29,609 --> 00:00:35,489
where I looked the stock today is about

8
00:00:32,098 --> 00:00:38,968
GCC internals and what you can do for

9
00:00:35,489 --> 00:00:42,930
security when you work on GCC interns or

10
00:00:38,969 --> 00:00:44,010
generally on compile internals and yeah

11
00:00:42,930 --> 00:00:47,190
let's start over

12
00:00:44,010 --> 00:00:49,800
hello this is me my name is Marion I'm a

13
00:00:47,190 --> 00:00:53,039
security researcher and something might

14
00:00:49,800 --> 00:00:55,709
have heard I changed jobs a year ago and

15
00:00:53,039 --> 00:01:00,300
back then I moved to Portland Oregon to

16
00:00:55,710 --> 00:01:03,899
start work for Intel and since I started

17
00:01:00,300 --> 00:01:07,140
working in so my my field of research

18
00:01:03,899 --> 00:01:09,810
has moved from before I worked there I

19
00:01:07,140 --> 00:01:13,409
was a malleable reverse engineer looking

20
00:01:09,810 --> 00:01:15,450
mostly into into windows x86 64 Uslan

21
00:01:13,409 --> 00:01:17,790
memoir and since I started work at Intel

22
00:01:15,450 --> 00:01:21,170
my my interest because have shifted much

23
00:01:17,790 --> 00:01:24,390
a little above and a little below x86

24
00:01:21,170 --> 00:01:30,780
and for the last six months I have

25
00:01:24,390 --> 00:01:31,890
focused on GCC before I start to show

26
00:01:30,780 --> 00:01:33,329
you more about Jesus either like a

27
00:01:31,890 --> 00:01:35,810
little disclaimer you might have noticed

28
00:01:33,329 --> 00:01:38,520
when you work for a large corporation

29
00:01:35,810 --> 00:01:40,229
the the office right next to you is full

30
00:01:38,520 --> 00:01:42,479
of very very angry lawyers and those

31
00:01:40,229 --> 00:01:45,240
lawyers require us to tell you that

32
00:01:42,479 --> 00:01:47,880
whatever we say wherever we go is not

33
00:01:45,240 --> 00:01:49,949
happening in the name of Intel or any of

34
00:01:47,880 --> 00:01:54,149
its affiliates also we're not promoting

35
00:01:49,950 --> 00:01:59,100
and devaluing any product all right that

36
00:01:54,149 --> 00:02:02,009
was it though so if at any point in your

37
00:01:59,100 --> 00:02:04,530
life you you develop interest for

38
00:02:02,009 --> 00:02:06,600
compilers and you start to look into how

39
00:02:04,530 --> 00:02:09,090
modern modern day compilers work and

40
00:02:06,600 --> 00:02:09,508
what you can do with them then you'll

41
00:02:09,090 --> 00:02:10,160
figure out

42
00:02:09,508 --> 00:02:14,440
Yul's

43
00:02:10,160 --> 00:02:17,510
and a lot of time looking at hello world

44
00:02:14,440 --> 00:02:19,880
the this talk today I wanted to start

45
00:02:17,510 --> 00:02:21,530
with with a little demo that shows what

46
00:02:19,880 --> 00:02:23,299
you can do with the with a compiler just

47
00:02:21,530 --> 00:02:29,690
only by looking at at hello world so

48
00:02:23,300 --> 00:02:33,740
let's see whether this yes oh wow the

49
00:02:29,690 --> 00:02:34,760
switch to the VM worked okay so the

50
00:02:33,740 --> 00:02:39,620
first thing I wanted to show you today

51
00:02:34,760 --> 00:02:42,579
was literally hello world so when I take

52
00:02:39,620 --> 00:02:42,580
the microphone with me

53
00:02:48,110 --> 00:02:52,280
okay so whether in the folder where

54
00:02:50,450 --> 00:02:54,260
there is a hello world dot C file which

55
00:02:52,280 --> 00:02:55,790
clearly does nothing more than printing

56
00:02:54,260 --> 00:02:57,410
a hello world have a close look at the

57
00:02:55,790 --> 00:02:58,940
at the string that's being printed

58
00:02:57,410 --> 00:03:01,100
oh you can't actually see much here

59
00:02:58,940 --> 00:03:04,250
that's what he said is there a way to

60
00:03:01,100 --> 00:03:06,680
turn off the lights can't make it dark

61
00:03:04,250 --> 00:03:07,700
place and fall asleep so if you would if

62
00:03:06,680 --> 00:03:09,980
you would be able to read was in the

63
00:03:07,700 --> 00:03:11,929
screen here is a printf from that prints

64
00:03:09,980 --> 00:03:13,880
a hello world with the backslash and yet

65
00:03:11,930 --> 00:03:16,280
so this is literally all this

66
00:03:13,880 --> 00:03:20,570
application does and now if I go ahead

67
00:03:16,280 --> 00:03:22,850
and here there's another command line

68
00:03:20,570 --> 00:03:25,130
that they can read it's a GCC seven that

69
00:03:22,850 --> 00:03:27,049
compiles the hello dot C to the hello

70
00:03:25,130 --> 00:03:30,040
world objects that we can afterwards

71
00:03:27,050 --> 00:03:34,640
execute so we compile this now we

72
00:03:30,040 --> 00:03:37,790
execute the hello world and that printf

73
00:03:34,640 --> 00:03:39,859
hello world all right now what I

74
00:03:37,790 --> 00:03:42,290
actually want to show you I've prepared

75
00:03:39,860 --> 00:03:43,489
a little GCC plug-in which if we look at

76
00:03:42,290 --> 00:03:46,489
the next command line to the prepared

77
00:03:43,489 --> 00:03:48,440
here is again the GCC seven I can pass

78
00:03:46,489 --> 00:03:51,890
the hell of all dot C to the hello world

79
00:03:48,440 --> 00:03:53,510
executable and a little change that I

80
00:03:51,890 --> 00:03:56,510
applied here is that it loads the plugin

81
00:03:53,510 --> 00:03:59,299
that says hello that oh so this is a GCC

82
00:03:56,510 --> 00:04:01,820
plugin which will plug into the GCC

83
00:03:59,300 --> 00:04:04,360
compiler passes takes a pass where it

84
00:04:01,820 --> 00:04:06,680
can modify what the compiler outputs

85
00:04:04,360 --> 00:04:08,840
keep in mind that did not change the C

86
00:04:06,680 --> 00:04:10,790
file that that I showed you before so

87
00:04:08,840 --> 00:04:12,709
now I can compile the same C file with

88
00:04:10,790 --> 00:04:14,450
the same compiler with that plugin

89
00:04:12,709 --> 00:04:15,170
loaded and then when I execute my hello

90
00:04:14,450 --> 00:04:17,440
world all of them

91
00:04:15,170 --> 00:04:19,519
it says hail Satan

92
00:04:17,440 --> 00:04:21,469
this is one of the funny things they can

93
00:04:19,519 --> 00:04:24,440
do when you look into a cooler the

94
00:04:21,470 --> 00:04:26,509
plugin that does this is about twenty to

95
00:04:24,440 --> 00:04:29,630
thirty lines of C and now let's have a

96
00:04:26,509 --> 00:04:31,280
look at how the plug-in achieves this

97
00:04:29,630 --> 00:04:31,969
all right so our hello bull just went

98
00:04:31,280 --> 00:04:36,198
hail Satan

99
00:04:31,970 --> 00:04:38,240
um this happened because this routine

100
00:04:36,199 --> 00:04:41,389
that is here on the screen executed

101
00:04:38,240 --> 00:04:43,370
through within the the different passes

102
00:04:41,389 --> 00:04:46,310
that GCC executes the compiler binary

103
00:04:43,370 --> 00:04:48,650
and this this piece of code there's

104
00:04:46,310 --> 00:04:50,659
nothing else but looking for a print F

105
00:04:48,650 --> 00:04:52,068
call so it looks for a for a call

106
00:04:50,659 --> 00:04:54,380
statement which is here in the kitchen

107
00:04:52,069 --> 00:04:56,659
plan is called call then picks out the

108
00:04:54,380 --> 00:05:00,169
first argument that this call statement

109
00:04:56,659 --> 00:05:03,530
contains and at the bottom you can see

110
00:05:00,169 --> 00:05:05,960
it replaces the call statement with the

111
00:05:03,530 --> 00:05:11,299
API code the chimpo call set argument

112
00:05:05,960 --> 00:05:13,638
with a string that says hail Satan this

113
00:05:11,300 --> 00:05:16,220
sounds very simple in practice though

114
00:05:13,639 --> 00:05:22,039
this this is rather complex to to

115
00:05:16,220 --> 00:05:24,680
implement but the bigger the bigger part

116
00:05:22,039 --> 00:05:27,080
of my headache while I was working on

117
00:05:24,680 --> 00:05:29,330
GCC plugins was whenever I went up to

118
00:05:27,080 --> 00:05:31,430
people and told them I work on GCC

119
00:05:29,330 --> 00:05:36,469
plugins not supercool and everyone's

120
00:05:31,430 --> 00:05:37,950
like why like this like why why would

121
00:05:36,469 --> 00:05:40,740
you do that

122
00:05:37,950 --> 00:05:42,420
today my world we have LLVM we have

123
00:05:40,740 --> 00:05:44,910
clang we have things that are actually

124
00:05:42,420 --> 00:05:47,340
usable they have they have my CPI is

125
00:05:44,910 --> 00:05:49,430
they have documentation justjust think

126
00:05:47,340 --> 00:05:52,590
about that they have documentation and

127
00:05:49,430 --> 00:05:54,090
and yeah there's there's many many good

128
00:05:52,590 --> 00:05:57,090
reasons why it would work and cheesy see

129
00:05:54,090 --> 00:05:58,590
that that I could answer it's like most

130
00:05:57,090 --> 00:06:01,919
importantly learns Colonel is mostly

131
00:05:58,590 --> 00:06:04,020
compared in GCC then many former

132
00:06:01,920 --> 00:06:05,850
products remember I work for Intel

133
00:06:04,020 --> 00:06:07,650
many former products are compiled with

134
00:06:05,850 --> 00:06:10,830
GCC as well many import and software

135
00:06:07,650 --> 00:06:13,349
products is the Kampala GCC but they all

136
00:06:10,830 --> 00:06:15,300
wouldn't wouldn't count as much as some

137
00:06:13,350 --> 00:06:16,860
months ago my my team lead which y'all

138
00:06:15,300 --> 00:06:18,390
might now his his name is Rodrigo he

139
00:06:16,860 --> 00:06:19,800
came up to me and asked me do you want

140
00:06:18,390 --> 00:06:21,360
do you want something challenging to do

141
00:06:19,800 --> 00:06:24,720
like I have a have an interesting

142
00:06:21,360 --> 00:06:26,310
problem here and I have a bottle of

143
00:06:24,720 --> 00:06:29,250
water to I have an interesting problem

144
00:06:26,310 --> 00:06:30,810
here we needed to ride the cheese's he

145
00:06:29,250 --> 00:06:32,370
plugin do you want to do this it's a lot

146
00:06:30,810 --> 00:06:34,830
of it's it's very painful and I was like

147
00:06:32,370 --> 00:06:36,240
yes give me this challenge and I didn't

148
00:06:34,830 --> 00:06:39,229
know what I was what was good not gonna

149
00:06:36,240 --> 00:06:41,370
start out and I didn't expect that so

150
00:06:39,230 --> 00:06:45,300
when you start working on Jesus

151
00:06:41,370 --> 00:06:49,620
internals consider that there's long and

152
00:06:45,300 --> 00:06:52,230
painful road ahead and then turns out

153
00:06:49,620 --> 00:06:54,360
that like long and painful hurts all

154
00:06:52,230 --> 00:06:57,500
right back to TCC Jesus he actually

155
00:06:54,360 --> 00:06:59,760
stands for the new compiler collection

156
00:06:57,500 --> 00:07:02,610
of course that has a website that has

157
00:06:59,760 --> 00:07:05,039
documentation there's a really thick

158
00:07:02,610 --> 00:07:07,080
book about 700 pages that tells you a

159
00:07:05,040 --> 00:07:07,400
lot about the TCC internals as its

160
00:07:07,080 --> 00:07:10,620
called

161
00:07:07,400 --> 00:07:12,270
that lists all the api's that you can

162
00:07:10,620 --> 00:07:14,640
use when you want to plug into the GCC

163
00:07:12,270 --> 00:07:17,190
compiler passes jesusí like most

164
00:07:14,640 --> 00:07:18,630
compilers i think has a front end the

165
00:07:17,190 --> 00:07:20,910
middle end in the back end of course and

166
00:07:18,630 --> 00:07:23,219
it can compile code this is what all

167
00:07:20,910 --> 00:07:25,770
compilers do this is what most people

168
00:07:23,220 --> 00:07:27,630
use them for what most people don't know

169
00:07:25,770 --> 00:07:29,130
though is that you can also do with lots

170
00:07:27,630 --> 00:07:30,600
of other things with the compiler like

171
00:07:29,130 --> 00:07:32,120
'i could for example exchange the front

172
00:07:30,600 --> 00:07:35,180
end you could come up with your own

173
00:07:32,120 --> 00:07:37,710
proprietary or your own fictional

174
00:07:35,180 --> 00:07:39,750
programming language and implement a new

175
00:07:37,710 --> 00:07:41,340
front end and then use the rest of GCC

176
00:07:39,750 --> 00:07:42,960
which by the way are about fourteen

177
00:07:41,340 --> 00:07:44,340
million lines of code so you could use

178
00:07:42,960 --> 00:07:46,510
the rest of those forty million lines of

179
00:07:44,340 --> 00:07:48,489
code to compile your in

180
00:07:46,510 --> 00:07:50,590
vented programming language to a given

181
00:07:48,490 --> 00:07:52,270
architecture but you can also do is you

182
00:07:50,590 --> 00:07:55,270
could exchange the back-end of GCC and

183
00:07:52,270 --> 00:07:57,340
implement a new CPU architecture so you

184
00:07:55,270 --> 00:08:00,400
could write C code and compile that to

185
00:07:57,340 --> 00:08:02,140
your own CPU architecture if you ever

186
00:08:00,400 --> 00:08:03,849
got into the opposition again I work for

187
00:08:02,140 --> 00:08:05,229
Intel so this isn't all that futuristic

188
00:08:03,850 --> 00:08:08,050
if you never actually thought about

189
00:08:05,230 --> 00:08:11,050
building your own CPU anyway you can

190
00:08:08,050 --> 00:08:13,030
also add optimization passes the GCC

191
00:08:11,050 --> 00:08:15,490
Midlands mostly busy with optimizing

192
00:08:13,030 --> 00:08:17,979
code you might you might be aware that

193
00:08:15,490 --> 00:08:20,710
coders sometimes write very inefficient

194
00:08:17,980 --> 00:08:21,910
loops for example and compilers don't

195
00:08:20,710 --> 00:08:23,380
like that so they look at those loops

196
00:08:21,910 --> 00:08:27,660
and they they make them more efficient

197
00:08:23,380 --> 00:08:27,659
and more performant or maybe smaller

198
00:08:27,780 --> 00:08:31,450
furthermore you can perform static

199
00:08:29,650 --> 00:08:34,360
analysis inside the compiler or you can

200
00:08:31,450 --> 00:08:38,080
insert flags so you can add your own

201
00:08:34,360 --> 00:08:39,729
optimization passes that that constructs

202
00:08:38,080 --> 00:08:41,680
the output byte code in a certain format

203
00:08:39,729 --> 00:08:42,940
which might be easier for your analysis

204
00:08:41,679 --> 00:08:44,109
tools to understand which is very

205
00:08:42,940 --> 00:08:47,550
helpful for example if you want to

206
00:08:44,110 --> 00:08:50,080
search for bugs you can also look for

207
00:08:47,550 --> 00:08:51,910
optimization bugs inside of GCC and

208
00:08:50,080 --> 00:08:54,070
something that that caught my interest

209
00:08:51,910 --> 00:08:56,829
is that you can also introduce

210
00:08:54,070 --> 00:08:57,340
optimization bugs I'll get back to that

211
00:08:56,830 --> 00:08:58,900
later

212
00:08:57,340 --> 00:09:03,400
but yeah you're very powerful when you

213
00:08:58,900 --> 00:09:05,319
work inside of the compiler and as we

214
00:09:03,400 --> 00:09:06,610
start looking at GCC more closely I'll

215
00:09:05,320 --> 00:09:08,740
have to show you this picture because

216
00:09:06,610 --> 00:09:11,680
all the presentations that I saw about

217
00:09:08,740 --> 00:09:14,290
GC started with this picture it's called

218
00:09:11,680 --> 00:09:16,150
10,000 foot view and the GCC and again

219
00:09:14,290 --> 00:09:18,880
remember GCC is 14 million times of

220
00:09:16,150 --> 00:09:22,270
lines of code so for like a 10,000 foot

221
00:09:18,880 --> 00:09:23,439
view and GCC is very very vague but what

222
00:09:22,270 --> 00:09:26,140
you can see again on this picture is

223
00:09:23,440 --> 00:09:27,550
that there is the front end the front

224
00:09:26,140 --> 00:09:31,510
end that's mostly responsible for

225
00:09:27,550 --> 00:09:34,750
parsing code so if you hand GCC a C file

226
00:09:31,510 --> 00:09:38,380
or a Java file then the front end is

227
00:09:34,750 --> 00:09:40,570
responsible for parsing that piece of

228
00:09:38,380 --> 00:09:42,280
source code into an abstract syntax tree

229
00:09:40,570 --> 00:09:44,200
which is then translated to generic

230
00:09:42,280 --> 00:09:48,130
generic is the first intermediate

231
00:09:44,200 --> 00:09:51,730
language was recognized by GCC from

232
00:09:48,130 --> 00:09:53,470
there from that language the source or

233
00:09:51,730 --> 00:09:55,510
like the the intermediate representation

234
00:09:53,470 --> 00:09:58,300
of your source code is then lowered to a

235
00:09:55,510 --> 00:09:59,270
representation called simple jumplist

236
00:09:58,300 --> 00:10:05,839
GCC specific

237
00:09:59,270 --> 00:10:07,520
and it it is I think inspired by an

238
00:10:05,839 --> 00:10:12,890
intermediate language called simple

239
00:10:07,520 --> 00:10:15,170
that's used by a research compiler which

240
00:10:12,890 --> 00:10:17,540
doesn't remember now anyhow so this

241
00:10:15,170 --> 00:10:19,540
representation then is used for the many

242
00:10:17,540 --> 00:10:23,180
different optimization passes that are

243
00:10:19,540 --> 00:10:25,699
there are architecture independent so in

244
00:10:23,180 --> 00:10:27,739
the format of chimpo the representation

245
00:10:25,700 --> 00:10:29,839
is still very close to the source

246
00:10:27,740 --> 00:10:32,959
representation jimbo by itself actually

247
00:10:29,839 --> 00:10:37,279
looks very simple very very similar to 2

248
00:10:32,959 --> 00:10:39,859
C code itself so the language isn't used

249
00:10:37,279 --> 00:10:43,189
for target independent optimizations and

250
00:10:39,860 --> 00:10:45,560
from there finally the representation is

251
00:10:43,190 --> 00:10:48,080
lowered to RTL RTL stands for register

252
00:10:45,560 --> 00:10:49,670
transfer language I'll be speaking about

253
00:10:48,080 --> 00:10:53,089
all of those intermediate passes in

254
00:10:49,670 --> 00:10:56,750
great detail in a minute RTL is very

255
00:10:53,089 --> 00:11:00,230
very close already to the CPU bytecode

256
00:10:56,750 --> 00:11:02,570
but our tale by itself in in its initial

257
00:11:00,230 --> 00:11:05,089
state is still CPU independent so it's

258
00:11:02,570 --> 00:11:07,070
architecture independent meaning that

259
00:11:05,089 --> 00:11:11,120
from the initial state of RTL we can

260
00:11:07,070 --> 00:11:13,160
still lower down to arm to x86 or to any

261
00:11:11,120 --> 00:11:16,220
given other exotic CPU that might be

262
00:11:13,160 --> 00:11:18,560
supported by the compiler and our tale

263
00:11:16,220 --> 00:11:21,050
by itself implements the machine

264
00:11:18,560 --> 00:11:23,599
definitions which help the compiler

265
00:11:21,050 --> 00:11:26,479
lower the intermediate representation of

266
00:11:23,600 --> 00:11:31,160
RTL down to x86 bytecode or any given

267
00:11:26,480 --> 00:11:33,620
byte codes that we specified that was

268
00:11:31,160 --> 00:11:37,579
GCC in five minutes now let's look at

269
00:11:33,620 --> 00:11:38,839
GCC in 30 minutes GCC by itself is many

270
00:11:37,579 --> 00:11:45,339
split up in the different compiler

271
00:11:38,839 --> 00:11:48,110
passes this is a bit of an illusion

272
00:11:45,339 --> 00:11:50,839
GCC likes to pretend that it performs

273
00:11:48,110 --> 00:11:54,350
its compilation in in different passes

274
00:11:50,839 --> 00:11:56,750
for one pass execute after another which

275
00:11:54,350 --> 00:11:59,089
is exactly what happens except that

276
00:11:56,750 --> 00:12:01,010
those passes aren't independent from

277
00:11:59,089 --> 00:12:02,680
each other which one might think so if

278
00:12:01,010 --> 00:12:05,540
we look at different compiler passes

279
00:12:02,680 --> 00:12:06,890
those passes are responsible for parsing

280
00:12:05,540 --> 00:12:08,240
the source code translating the source

281
00:12:06,890 --> 00:12:09,949
code parsing intermediate

282
00:12:08,240 --> 00:12:11,000
representations translating them and

283
00:12:09,949 --> 00:12:12,800
lowering them to different

284
00:12:11,000 --> 00:12:13,160
representations and this is all not done

285
00:12:12,800 --> 00:12:19,519
like

286
00:12:13,160 --> 00:12:21,199
step by step but interleaving one thing

287
00:12:19,519 --> 00:12:23,899
that I learned after looking for a long

288
00:12:21,199 --> 00:12:26,839
time at GCC is that there is an insane

289
00:12:23,899 --> 00:12:30,500
amount of macros in there and an insane

290
00:12:26,839 --> 00:12:33,740
amount of API functions the API of GCC

291
00:12:30,500 --> 00:12:36,079
G's in internals is it actually defines

292
00:12:33,740 --> 00:12:37,579
there is there is documentation for most

293
00:12:36,079 --> 00:12:39,739
of those API sand from us of those

294
00:12:37,579 --> 00:12:41,779
macros and for the constants that

295
00:12:39,740 --> 00:12:44,269
they're using the thing is just that

296
00:12:41,779 --> 00:12:47,209
there are so many that writing a proper

297
00:12:44,269 --> 00:12:50,680
documentation with coding examples and

298
00:12:47,209 --> 00:12:55,459
and wise hints on how to use the API

299
00:12:50,680 --> 00:12:58,638
would probably require more than a 700

300
00:12:55,459 --> 00:13:01,638
pages book the 700 pages book is what we

301
00:12:58,639 --> 00:13:03,740
have right now anyhow the GCC compiler

302
00:13:01,639 --> 00:13:05,569
passes though are a nice thing to hold

303
00:13:03,740 --> 00:13:08,120
on to when you try to implement plugins

304
00:13:05,569 --> 00:13:10,519
because when you implement a TCC plugin

305
00:13:08,120 --> 00:13:13,699
what they do is you add exactly one pass

306
00:13:10,519 --> 00:13:16,370
to the GCC passive structure the GCC

307
00:13:13,699 --> 00:13:18,290
passes can be listed by the compiler

308
00:13:16,370 --> 00:13:19,699
itself when you insert or when you

309
00:13:18,290 --> 00:13:21,709
execute GCC with a flag

310
00:13:19,699 --> 00:13:23,569
- left on - passes you get the whole

311
00:13:21,709 --> 00:13:26,089
list of GCC passes to the currently

312
00:13:23,569 --> 00:13:27,469
active and then you can pick the path

313
00:13:26,089 --> 00:13:29,389
that you want to relate to when you

314
00:13:27,470 --> 00:13:31,819
insert your plugin more about this in a

315
00:13:29,389 --> 00:13:33,139
minute but what I wanted to mention is

316
00:13:31,819 --> 00:13:35,269
that there is a really really nice

317
00:13:33,139 --> 00:13:37,399
graphic that was created by one of the

318
00:13:35,269 --> 00:13:40,430
GCC folks himself his name is David

319
00:13:37,399 --> 00:13:42,410
Malcolm and my screen can't actually fit

320
00:13:40,430 --> 00:13:45,050
that graphic because there is about like

321
00:13:42,410 --> 00:13:46,790
200 passes that are listed on the

322
00:13:45,050 --> 00:13:49,399
graphic but if you're interested in

323
00:13:46,790 --> 00:13:51,529
which passes GCC executes and more

324
00:13:49,399 --> 00:13:53,870
importantly which data structures or

325
00:13:51,529 --> 00:13:56,329
which languages are available in which

326
00:13:53,870 --> 00:13:58,519
Civic pass and this graphic is what you

327
00:13:56,329 --> 00:14:01,849
should be looking at what I mean with

328
00:13:58,519 --> 00:14:03,439
data structures so you saw that GZ is

329
00:14:01,850 --> 00:14:05,120
pardon this front middle and back end

330
00:14:03,439 --> 00:14:08,569
and there's different representations

331
00:14:05,120 --> 00:14:11,149
and that that means that the passes they

332
00:14:08,569 --> 00:14:13,279
align with the different stages of the

333
00:14:11,149 --> 00:14:15,829
compilation process that means that you

334
00:14:13,279 --> 00:14:17,300
have passes that relate to generics and

335
00:14:15,829 --> 00:14:18,949
you have passes that relate to chimpo

336
00:14:17,300 --> 00:14:19,540
then you have passes they relate to RTL

337
00:14:18,949 --> 00:14:21,130
and

338
00:14:19,540 --> 00:14:25,120
process relate to the lowering to the

339
00:14:21,130 --> 00:14:27,490
machine definitions and that means when

340
00:14:25,120 --> 00:14:29,829
you when you want to implement the

341
00:14:27,490 --> 00:14:32,560
plug-in you have to be aware of what you

342
00:14:29,829 --> 00:14:35,050
want to achieve and we're in the stage

343
00:14:32,560 --> 00:14:38,768
of compilation you can achieve your goal

344
00:14:35,050 --> 00:14:41,469
that your your ought to get so for

345
00:14:38,769 --> 00:14:44,230
example when you when you want to

346
00:14:41,470 --> 00:14:46,269
implement a plug-in that is that is

347
00:14:44,230 --> 00:14:48,370
looking at input parameters like for

348
00:14:46,269 --> 00:14:50,709
example you want to automatically verify

349
00:14:48,370 --> 00:14:52,120
input parameters in an application then

350
00:14:50,709 --> 00:14:53,500
you might want to be closer to the

351
00:14:52,120 --> 00:14:55,540
serial presentation to the source

352
00:14:53,500 --> 00:14:57,579
representation because this is where the

353
00:14:55,540 --> 00:14:59,670
arguments the function arguments input

354
00:14:57,579 --> 00:15:01,750
arguments are still clearly visible on

355
00:14:59,670 --> 00:15:03,699
the other hand if you want to perform

356
00:15:01,750 --> 00:15:06,690
modifications that are closer to the

357
00:15:03,699 --> 00:15:09,939
xc60 to the to the assembly code layer

358
00:15:06,690 --> 00:15:12,069
then then you're better off plugging

359
00:15:09,940 --> 00:15:14,290
into layers paths in the in the

360
00:15:12,069 --> 00:15:16,750
compilation stage where you end up

361
00:15:14,290 --> 00:15:20,829
modifying the the RTR presentation or

362
00:15:16,750 --> 00:15:22,930
play with the machine definitions this

363
00:15:20,829 --> 00:15:24,939
much about the passes another important

364
00:15:22,930 --> 00:15:27,099
thing to note just so everyone's aware

365
00:15:24,940 --> 00:15:29,290
of that GCC stands for the no compiler

366
00:15:27,100 --> 00:15:30,850
collection I mentioned it already well

367
00:15:29,290 --> 00:15:31,349
working in GCC also found out what that

368
00:15:30,850 --> 00:15:34,410
means

369
00:15:31,350 --> 00:15:36,910
GCC actually isn't one executable that

370
00:15:34,410 --> 00:15:40,180
performs the whole compilation by itself

371
00:15:36,910 --> 00:15:43,209
but GCC is really a collection of the CC

372
00:15:40,180 --> 00:15:46,120
one or the CC one plus or the chasey one

373
00:15:43,209 --> 00:15:49,268
or the F 951 or whichever front end you

374
00:15:46,120 --> 00:15:51,310
are using for compiling the the source

375
00:15:49,269 --> 00:15:53,920
file that you're handing the compiler so

376
00:15:51,310 --> 00:15:57,010
GCC by itself can pick the appropriate

377
00:15:53,920 --> 00:15:59,529
compiler to perform compilation of the

378
00:15:57,010 --> 00:16:01,269
source and I might want to know that

379
00:15:59,529 --> 00:16:02,829
this CC one stage or like the first

380
00:16:01,269 --> 00:16:05,290
compiler stage is what I'll be talking

381
00:16:02,829 --> 00:16:08,550
about today mostly what comes afterwards

382
00:16:05,290 --> 00:16:14,649
is the GNU assembler and the linker

383
00:16:08,550 --> 00:16:20,500
that's also called collect - or LD a s

384
00:16:14,649 --> 00:16:23,350
is what consumes the assembly text files

385
00:16:20,500 --> 00:16:24,550
that the compiler produces and lowers

386
00:16:23,350 --> 00:16:27,430
them to the actual bytecode

387
00:16:24,550 --> 00:16:29,529
representation this was a bit of a

388
00:16:27,430 --> 00:16:30,540
surprise to me as well when you look at

389
00:16:29,529 --> 00:16:32,820
what the

390
00:16:30,540 --> 00:16:34,349
the first stage of the compiler er like

391
00:16:32,820 --> 00:16:36,510
the cc1 in the case of the C file

392
00:16:34,350 --> 00:16:39,150
produces you'll actually be surprised it

393
00:16:36,510 --> 00:16:43,350
produces esti text files those acts

394
00:16:39,150 --> 00:16:46,170
t-test text files are the the assembly

395
00:16:43,350 --> 00:16:48,360
representation that GCC generates from

396
00:16:46,170 --> 00:16:52,860
the source file and from those text

397
00:16:48,360 --> 00:16:58,100
files AAS generates the the bytecode if

398
00:16:52,860 --> 00:17:02,990
you've ever looked at GCC the - s option

399
00:16:58,100 --> 00:17:05,849
instructs GCC to not start the assembly

400
00:17:02,990 --> 00:17:07,650
yes Emily stage so with the men's s

401
00:17:05,849 --> 00:17:10,829
option GCC stops after the first

402
00:17:07,650 --> 00:17:12,839
executable after the first compiler so

403
00:17:10,829 --> 00:17:14,129
that you can expect the the SMD

404
00:17:12,839 --> 00:17:16,740
representation that the compiler

405
00:17:14,130 --> 00:17:19,100
produced anyhow that just as a hint by

406
00:17:16,740 --> 00:17:21,060
by itself

407
00:17:19,099 --> 00:17:23,310
another thing that it's important to

408
00:17:21,060 --> 00:17:25,470
note before we talk about more internals

409
00:17:23,310 --> 00:17:27,510
there's debug output there's

410
00:17:25,470 --> 00:17:30,000
documentation - documentation is awesome

411
00:17:27,510 --> 00:17:32,370
but documentation 700 pages the debug

412
00:17:30,000 --> 00:17:35,220
output by itself is super confusing it's

413
00:17:32,370 --> 00:17:37,379
a lot like if you here and all the debug

414
00:17:35,220 --> 00:17:43,050
output options you end up with I think

415
00:17:37,380 --> 00:17:44,880
40 to 50 lakh files each and those

416
00:17:43,050 --> 00:17:46,409
aren't always easy to read but if you

417
00:17:44,880 --> 00:17:48,000
know exactly which paths you want to

418
00:17:46,410 --> 00:17:50,670
look at or if you know which your

419
00:17:48,000 --> 00:17:52,770
presentation you want to study then it

420
00:17:50,670 --> 00:17:54,540
is mostly easier to look at the log

421
00:17:52,770 --> 00:17:56,610
output than the documentation this is

422
00:17:54,540 --> 00:17:58,860
what it was for me in order to learn how

423
00:17:56,610 --> 00:18:01,139
a specific representation looks like and

424
00:17:58,860 --> 00:18:04,379
what you have to learn in order to be

425
00:18:01,140 --> 00:18:06,930
able to modify it and what's more if

426
00:18:04,380 --> 00:18:10,110
you're implementing plugins with the

427
00:18:06,930 --> 00:18:12,900
dash F thump option you can dump

428
00:18:10,110 --> 00:18:14,850
specifically that one path that you're

429
00:18:12,900 --> 00:18:16,890
implementing in your plugin so that you

430
00:18:14,850 --> 00:18:18,209
cannot you can look what exactly is

431
00:18:16,890 --> 00:18:21,450
cheese is he doing when you're executing

432
00:18:18,210 --> 00:18:24,770
your plugin and how to have to fix that

433
00:18:21,450 --> 00:18:26,820
it's very important for for debugging

434
00:18:24,770 --> 00:18:34,350
okay but why do I keep talking about

435
00:18:26,820 --> 00:18:36,270
this GCC plugins the a good reason to

436
00:18:34,350 --> 00:18:38,010
look in the GCC plugins becomes obvious

437
00:18:36,270 --> 00:18:40,110
when you when you look into GCC

438
00:18:38,010 --> 00:18:42,100
modification itself so when you when you

439
00:18:40,110 --> 00:18:45,159
want to to perform a change

440
00:18:42,100 --> 00:18:46,780
on GCC itself first of all you have to

441
00:18:45,160 --> 00:18:49,420
dig into those 14 million lines of code

442
00:18:46,780 --> 00:18:50,950
and I haven't actually counted them the

443
00:18:49,420 --> 00:18:52,450
numbers from Wikipedia but I'm I have a

444
00:18:50,950 --> 00:18:54,970
feeling it's about right so like if you

445
00:18:52,450 --> 00:18:58,690
look at the code base of of the GCC

446
00:18:54,970 --> 00:19:01,180
compiler it's it's insane so when you

447
00:18:58,690 --> 00:19:04,720
stick to a plug-in you can you can

448
00:19:01,180 --> 00:19:06,220
mostly skip reading through through the

449
00:19:04,720 --> 00:19:09,400
through the study code that's really

450
00:19:06,220 --> 00:19:11,170
code of GCC but another good good reason

451
00:19:09,400 --> 00:19:12,670
becomes obvious but like let me let me

452
00:19:11,170 --> 00:19:18,190
ask the audience how many of you have

453
00:19:12,670 --> 00:19:23,260
ever compiled GCC was anyone finished on

454
00:19:18,190 --> 00:19:24,910
the three hours no okay so just imagine

455
00:19:23,260 --> 00:19:26,260
you do a little chance to choose the C

456
00:19:24,910 --> 00:19:29,500
and you want to see how well it works

457
00:19:26,260 --> 00:19:31,330
just for for testing so you change it

458
00:19:29,500 --> 00:19:34,030
and then you compile it and then you

459
00:19:31,330 --> 00:19:37,929
wait for half they really can't yeah

460
00:19:34,030 --> 00:19:40,629
been there so Chi plugins are clearly

461
00:19:37,930 --> 00:19:42,520
the better way to go black and spine

462
00:19:40,630 --> 00:19:45,280
cells are shared objects so you get a

463
00:19:42,520 --> 00:19:49,120
shared object that the compiler loads

464
00:19:45,280 --> 00:19:50,139
during compile time a thing that's

465
00:19:49,120 --> 00:19:52,000
that's slightly confusing in the

466
00:19:50,140 --> 00:19:53,260
beginning is you you compile a plug-in

467
00:19:52,000 --> 00:19:55,630
that you can feed the compilers the

468
00:19:53,260 --> 00:19:57,160
compiler can compile other things which

469
00:19:55,630 --> 00:19:58,810
is a lot of compiling once and then so

470
00:19:57,160 --> 00:20:00,130
essentially you build a piece of

471
00:19:58,810 --> 00:20:04,419
software which then helps building other

472
00:20:00,130 --> 00:20:07,800
pieces of software they're maintained by

473
00:20:04,420 --> 00:20:10,690
the GCC pass miniature and they're in

474
00:20:07,800 --> 00:20:16,720
the base structure they're fairly simple

475
00:20:10,690 --> 00:20:18,100
to implement this works as follows on

476
00:20:16,720 --> 00:20:22,300
the screen I'm not sure you can probably

477
00:20:18,100 --> 00:20:24,340
not read this in the beginning we see a

478
00:20:22,300 --> 00:20:27,040
struct that has to be defined to tell

479
00:20:24,340 --> 00:20:30,189
GCC which type of plug-in we want to

480
00:20:27,040 --> 00:20:32,230
implement the plug-in types to mean that

481
00:20:30,190 --> 00:20:34,510
the definition was a bit confusing as

482
00:20:32,230 --> 00:20:37,480
well as GCC says they have chimpo

483
00:20:34,510 --> 00:20:39,700
plugins they provide api's for RTL

484
00:20:37,480 --> 00:20:42,970
plugins for simple IP and for IP a

485
00:20:39,700 --> 00:20:46,000
plugins whereas simple IP plugins and IP

486
00:20:42,970 --> 00:20:47,680
plugins from from a hacker ish

487
00:20:46,000 --> 00:20:49,720
perspective or almost the same thing

488
00:20:47,680 --> 00:20:52,360
I'll be talking about that later as well

489
00:20:49,720 --> 00:20:54,990
and then there's nothing that you can do

490
00:20:52,360 --> 00:20:57,330
with IP plugins which is called IP alt

491
00:20:54,990 --> 00:21:00,179
plugins which would be a plugins run at

492
00:20:57,330 --> 00:21:01,919
linked time if you remember that is

493
00:21:00,179 --> 00:21:03,390
those four stages of compilation I

494
00:21:01,920 --> 00:21:05,220
showed you before like the compiler of

495
00:21:03,390 --> 00:21:07,110
the December and the linker the linker

496
00:21:05,220 --> 00:21:08,309
happens after compilation so you first

497
00:21:07,110 --> 00:21:09,870
you compile the code then you get an

498
00:21:08,309 --> 00:21:11,820
object file then the linker picks up the

499
00:21:09,870 --> 00:21:15,149
object files and this is linker execute

500
00:21:11,820 --> 00:21:16,350
jesusí can load another plug-in to work

501
00:21:15,150 --> 00:21:18,870
on those object files are already

502
00:21:16,350 --> 00:21:21,389
compiled which is a bit tricky so anyhow

503
00:21:18,870 --> 00:21:23,159
I would count like four and a half types

504
00:21:21,390 --> 00:21:26,880
of plugins that we can implement with

505
00:21:23,160 --> 00:21:30,170
GCC this is what we have to tell cheesy

506
00:21:26,880 --> 00:21:32,190
in this structure that's start up here

507
00:21:30,170 --> 00:21:34,170
another important thing that we have to

508
00:21:32,190 --> 00:21:35,429
tell the plug-in is to check whether

509
00:21:34,170 --> 00:21:37,080
it's running in the right compiler

510
00:21:35,429 --> 00:21:39,840
version an important thing about plugins

511
00:21:37,080 --> 00:21:41,820
is that they will only run with exactly

512
00:21:39,840 --> 00:21:43,409
or the in combination with exactly that

513
00:21:41,820 --> 00:21:45,480
compiler that they were compiled with

514
00:21:43,410 --> 00:21:47,490
you cannot run the plug-in the dick part

515
00:21:45,480 --> 00:21:50,610
which is a z6 within that associate

516
00:21:47,490 --> 00:21:53,130
instance for example another thing

517
00:21:50,610 --> 00:21:55,620
that's important we have to specify the

518
00:21:53,130 --> 00:21:57,480
path that we want to attach to so you

519
00:21:55,620 --> 00:21:59,489
can either plug in before a given paths

520
00:21:57,480 --> 00:22:01,140
or after a given path and you have to

521
00:21:59,490 --> 00:22:04,610
tell the plug-in which path you want to

522
00:22:01,140 --> 00:22:07,290
relate to but important to know is that

523
00:22:04,610 --> 00:22:10,350
passes each path the cheeses the execute

524
00:22:07,290 --> 00:22:13,860
changes the state of the binary you're

525
00:22:10,350 --> 00:22:15,689
compiling so the the whole translation

526
00:22:13,860 --> 00:22:18,149
transition from source codes to byte

527
00:22:15,690 --> 00:22:20,670
codes each path changes the state of

528
00:22:18,150 --> 00:22:23,100
that representation and some of the

529
00:22:20,670 --> 00:22:24,809
items that you want to modify or some of

530
00:22:23,100 --> 00:22:26,219
the items that you need to want to learn

531
00:22:24,809 --> 00:22:28,770
about the binary during compilation

532
00:22:26,220 --> 00:22:30,390
might not be available in each given

533
00:22:28,770 --> 00:22:34,110
path so you have to figure out which

534
00:22:30,390 --> 00:22:36,690
path provides the data structures that

535
00:22:34,110 --> 00:22:38,219
you want to use in your plugin so for

536
00:22:36,690 --> 00:22:41,100
example it's not it's not possible to

537
00:22:38,220 --> 00:22:44,160
allocate a virtual register is in RTL if

538
00:22:41,100 --> 00:22:46,399
register assignment has already taken

539
00:22:44,160 --> 00:22:48,480
place there's one particular pass that

540
00:22:46,400 --> 00:22:51,150
performs the translation from virtual

541
00:22:48,480 --> 00:22:53,040
registers to hard registers on the given

542
00:22:51,150 --> 00:22:54,570
CPU and after that happened you can't

543
00:22:53,040 --> 00:22:55,800
allocate virtual registers any more I

544
00:22:54,570 --> 00:22:59,280
had to learn that too because I tried

545
00:22:55,800 --> 00:23:00,870
and and of course I failed be aware when

546
00:22:59,280 --> 00:23:02,300
you try to modify cheesey there's going

547
00:23:00,870 --> 00:23:05,929
to be a lot of failing and a lot of

548
00:23:02,300 --> 00:23:08,450
it's awesome finally the last point down

549
00:23:05,930 --> 00:23:10,580
here says we need a callback the

550
00:23:08,450 --> 00:23:13,250
callback the specified by the plug-in is

551
00:23:10,580 --> 00:23:15,800
what defines the actual action that the

552
00:23:13,250 --> 00:23:19,430
plug-in performs during the the

553
00:23:15,800 --> 00:23:21,710
compilation sessions all right and

554
00:23:19,430 --> 00:23:24,860
before I go into into the dirty details

555
00:23:21,710 --> 00:23:27,920
there's been quite some research that's

556
00:23:24,860 --> 00:23:31,639
been done on plugins before quite some

557
00:23:27,920 --> 00:23:33,470
of it also on security topics I'm I

558
00:23:31,640 --> 00:23:36,140
wanted to to note at the beginning of

559
00:23:33,470 --> 00:23:37,700
this talk that right now at Intel I'm

560
00:23:36,140 --> 00:23:40,160
tasked with working and looking into

561
00:23:37,700 --> 00:23:41,540
compiler mitigations so most of my

562
00:23:40,160 --> 00:23:43,100
research has been performed and

563
00:23:41,540 --> 00:23:46,129
implementing medications into the GCC

564
00:23:43,100 --> 00:23:48,080
compiler to prototype and test how how

565
00:23:46,130 --> 00:23:49,070
about the perform and of course since

566
00:23:48,080 --> 00:23:51,500
the work friends'll I cannot actually

567
00:23:49,070 --> 00:23:54,649
talk about what I really work on hence

568
00:23:51,500 --> 00:23:58,400
this talk is mostly motivated by of

569
00:23:54,650 --> 00:23:59,900
offensive interests by and I'll show you

570
00:23:58,400 --> 00:24:01,820
later

571
00:23:59,900 --> 00:24:04,400
anyhow there's been really interesting

572
00:24:01,820 --> 00:24:06,800
research on how to perform the state of

573
00:24:04,400 --> 00:24:09,590
security through compiler plugins and

574
00:24:06,800 --> 00:24:11,960
pattern tools if you want to implement

575
00:24:09,590 --> 00:24:13,639
them yourself the best reference that I

576
00:24:11,960 --> 00:24:15,710
could find so far was a set of plugins

577
00:24:13,640 --> 00:24:21,290
published by a researcher named amis

578
00:24:15,710 --> 00:24:23,210
Rafi a meteor Fe is in my opinion

579
00:24:21,290 --> 00:24:25,879
outstanding software developer that also

580
00:24:23,210 --> 00:24:29,110
understands GCC plugins which is rare

581
00:24:25,880 --> 00:24:32,060
and the plugins are very nicely

582
00:24:29,110 --> 00:24:35,659
documented and show a lot of interesting

583
00:24:32,060 --> 00:24:37,490
example code someone also who published

584
00:24:35,660 --> 00:24:40,490
about security research through plugins

585
00:24:37,490 --> 00:24:43,790
was a guy named Matt Davis who published

586
00:24:40,490 --> 00:24:46,040
interesting research on how to obfuscate

587
00:24:43,790 --> 00:24:49,310
binaries and how to implement that

588
00:24:46,040 --> 00:24:52,940
Canaries in different ways then more

589
00:24:49,310 --> 00:24:54,560
research has been published by the pax

590
00:24:52,940 --> 00:24:58,460
team and some of it has actually been

591
00:24:54,560 --> 00:24:59,929
presented here at HCC in Brazil and also

592
00:24:58,460 --> 00:25:03,230
there is an interesting research project

593
00:24:59,930 --> 00:25:04,280
called K guard that is one of the few

594
00:25:03,230 --> 00:25:06,590
plugins that I could find that's

595
00:25:04,280 --> 00:25:09,649
implemented for RTL it plugs into the

596
00:25:06,590 --> 00:25:11,419
RTL path and then there is a couple of

597
00:25:09,650 --> 00:25:12,970
interesting example plugins by a guy

598
00:25:11,420 --> 00:25:14,600
named Roger

599
00:25:12,970 --> 00:25:17,690
whenever I

600
00:25:14,600 --> 00:25:20,629
we met in person anyway all right that

601
00:25:17,690 --> 00:25:23,510
was a research now let's let's let's

602
00:25:20,630 --> 00:25:28,039
look look closer at the beautiful

603
00:25:23,510 --> 00:25:30,410
internals of GCC I'll get back to my my

604
00:25:28,039 --> 00:25:35,960
favorite new favorite graphic that shows

605
00:25:30,410 --> 00:25:38,150
Jesus here the 10,000 foot view and you

606
00:25:35,960 --> 00:25:40,460
can say that the first intermediate

607
00:25:38,150 --> 00:25:43,270
representation that you can get in touch

608
00:25:40,460 --> 00:25:45,950
with inside of of GCC is called generic

609
00:25:43,270 --> 00:25:47,809
if you remember the plug-in types the

610
00:25:45,950 --> 00:25:49,340
first type that the plug-in can have

611
00:25:47,809 --> 00:25:51,139
simple which would be the next

612
00:25:49,340 --> 00:25:53,449
intermediate representation we look here

613
00:25:51,140 --> 00:25:56,510
let's next box but simple and generic

614
00:25:53,450 --> 00:25:59,090
are actually closely related generic is

615
00:25:56,510 --> 00:26:01,400
as the name says a generic

616
00:25:59,090 --> 00:26:03,590
representation of input code that means

617
00:26:01,400 --> 00:26:07,400
that any piece of source code that if

618
00:26:03,590 --> 00:26:11,260
each is Z ends up in generic generic by

619
00:26:07,400 --> 00:26:14,539
itself I'll show you it's it's beautiful

620
00:26:11,260 --> 00:26:17,299
generic is actually a tree but it's not

621
00:26:14,539 --> 00:26:19,549
really treats it's also a language and

622
00:26:17,299 --> 00:26:21,679
the documentation said it was inspired

623
00:26:19,549 --> 00:26:23,960
by Lisp I personally I think I'm a bit

624
00:26:21,679 --> 00:26:25,520
too young to to have any knowledge of

625
00:26:23,960 --> 00:26:30,880
Lisp I don't know if anyone in the room

626
00:26:25,520 --> 00:26:34,400
has seen Lisp before yeah well first

627
00:26:30,880 --> 00:26:35,900
Google all right I've never done that um

628
00:26:34,400 --> 00:26:41,720
you might you might be happy looking at

629
00:26:35,900 --> 00:26:44,620
generic I wasn't generic one of the log

630
00:26:41,720 --> 00:26:47,780
faster cheesy spits out is called T U

631
00:26:44,620 --> 00:26:50,090
which for some reason stands for the

632
00:26:47,780 --> 00:26:51,470
generic tree representation and if you

633
00:26:50,090 --> 00:26:54,439
look at that log file you see this

634
00:26:51,470 --> 00:26:56,690
beautiful piece of text which is

635
00:26:54,440 --> 00:26:59,980
actually a couple thousand lines long if

636
00:26:56,690 --> 00:26:59,980
you feed it a hello world

637
00:27:00,169 --> 00:27:05,750
that piece has shown on the screen is

638
00:27:02,150 --> 00:27:07,610
the printf hello world who specifically

639
00:27:05,750 --> 00:27:09,200
that the main the piece of the main

640
00:27:07,610 --> 00:27:11,658
function that calls the printf hello

641
00:27:09,200 --> 00:27:13,549
world this is the whole block of text

642
00:27:11,659 --> 00:27:15,770
you can see in there like in pink

643
00:27:13,549 --> 00:27:17,600
circles that's the nodes which are our

644
00:27:15,770 --> 00:27:19,940
nose of a tree so you can imagine you

645
00:27:17,600 --> 00:27:23,209
have a function that's the root then you

646
00:27:19,940 --> 00:27:23,640
have a call to a to an API function in

647
00:27:23,210 --> 00:27:25,860
the

648
00:27:23,640 --> 00:27:28,740
that's another note that's below that

649
00:27:25,860 --> 00:27:32,459
road and that function has arguments

650
00:27:28,740 --> 00:27:34,770
that are another more nodes underneath

651
00:27:32,460 --> 00:27:36,570
that that root and it has a return value

652
00:27:34,770 --> 00:27:39,570
which is another node underneath Detroit

653
00:27:36,570 --> 00:27:44,580
so the whole the whole source code is

654
00:27:39,570 --> 00:27:46,379
parsed too into tree representation what

655
00:27:44,580 --> 00:27:48,780
more you can see on the slide is the the

656
00:27:46,380 --> 00:27:51,030
types of the notes so each tree node has

657
00:27:48,780 --> 00:27:56,399
a type associated and might I might not

658
00:27:51,030 --> 00:27:59,430
have values associated all right which

659
00:27:56,400 --> 00:28:01,500
is terrible for humans to read but great

660
00:27:59,430 --> 00:28:04,380
for machines to analyze if you if you

661
00:28:01,500 --> 00:28:06,300
have any knowledge of graph graph

662
00:28:04,380 --> 00:28:08,460
analysis this is basically what the

663
00:28:06,300 --> 00:28:10,620
compiler does it translates the source

664
00:28:08,460 --> 00:28:15,090
code to a graph and then there's lots of

665
00:28:10,620 --> 00:28:19,290
mathematics on it very ugly from a

666
00:28:15,090 --> 00:28:21,959
plugin perspective generic has an API so

667
00:28:19,290 --> 00:28:24,420
you can create nodes on your on your own

668
00:28:21,960 --> 00:28:27,240
you can assign arguments you can parse

669
00:28:24,420 --> 00:28:28,890
the the tree you can pick out arguments

670
00:28:27,240 --> 00:28:31,320
you can change arguments which is

671
00:28:28,890 --> 00:28:33,540
exactly what the the hello the hail

672
00:28:31,320 --> 00:28:37,139
Satan plugin before did so we researched

673
00:28:33,540 --> 00:28:38,700
for the chimp a call which is also a

674
00:28:37,140 --> 00:28:40,350
node in the tree and then we searched

675
00:28:38,700 --> 00:28:42,360
for its arguments and replaced one of

676
00:28:40,350 --> 00:28:43,770
those arguments so this is pretty much

677
00:28:42,360 --> 00:28:47,250
what they can do in the generic

678
00:28:43,770 --> 00:28:48,690
representation more important though as

679
00:28:47,250 --> 00:28:52,200
a plugin author you're more interested

680
00:28:48,690 --> 00:28:54,120
in simple simple is based on generic and

681
00:28:52,200 --> 00:28:56,130
there also as mentioned closely related

682
00:28:54,120 --> 00:28:58,080
so each simple node will have a generic

683
00:28:56,130 --> 00:28:59,370
representation not each generic

684
00:28:58,080 --> 00:29:03,090
representation has a chimp or

685
00:28:59,370 --> 00:29:06,350
representation chimpo was introduced so

686
00:29:03,090 --> 00:29:08,550
that GCC can add more GCC specific

687
00:29:06,350 --> 00:29:09,990
optimizations there is a long paper on

688
00:29:08,550 --> 00:29:11,790
why they made that decision I did not

689
00:29:09,990 --> 00:29:13,860
read the paper if you're interested why

690
00:29:11,790 --> 00:29:15,750
we have templed and you're welcome to

691
00:29:13,860 --> 00:29:17,520
read that paper and yeah a chimp or from

692
00:29:15,750 --> 00:29:20,190
from a plugin author's perspective is

693
00:29:17,520 --> 00:29:23,910
much more welcoming than generic simple

694
00:29:20,190 --> 00:29:26,480
looks actually closer to two source code

695
00:29:23,910 --> 00:29:29,970
than the generic representation does

696
00:29:26,480 --> 00:29:35,250
simple also stands for the three address

697
00:29:29,970 --> 00:29:38,630
code the three address code specifies

698
00:29:35,250 --> 00:29:43,560
that each line of code and simple is

699
00:29:38,630 --> 00:29:46,170
ideally made up of three items there's a

700
00:29:43,560 --> 00:29:47,820
maximum of two items but there cannot be

701
00:29:46,170 --> 00:29:50,100
more items in the line that means the

702
00:29:47,820 --> 00:29:52,409
compiler looks at all the terrible code

703
00:29:50,100 --> 00:29:54,870
constructs the source code are produced

704
00:29:52,410 --> 00:29:57,770
which might be like an entire line of an

705
00:29:54,870 --> 00:29:59,879
if statement if your if you code like me

706
00:29:57,770 --> 00:30:01,920
then you might have an if statement and

707
00:29:59,880 --> 00:30:03,060
then 25 checks that come after any way

708
00:30:01,920 --> 00:30:04,740
the compiler looks at that this is

709
00:30:03,060 --> 00:30:06,149
stupid and builds like it's a

710
00:30:04,740 --> 00:30:08,340
representation that makes it makes it

711
00:30:06,150 --> 00:30:10,110
much more more simple and in case in

712
00:30:08,340 --> 00:30:13,949
this slide you can see a mathematical

713
00:30:10,110 --> 00:30:17,520
calculation that makes sense to some

714
00:30:13,950 --> 00:30:19,500
people for sure and you can see that the

715
00:30:17,520 --> 00:30:21,150
compiler for the cheaper presentation

716
00:30:19,500 --> 00:30:23,580
split it up into the different tuples

717
00:30:21,150 --> 00:30:25,620
which is essentially what what you do as

718
00:30:23,580 --> 00:30:27,929
well when you when you remember math in

719
00:30:25,620 --> 00:30:29,610
school you don't solve the whole

720
00:30:27,930 --> 00:30:31,110
equation at once but you solve it like

721
00:30:29,610 --> 00:30:34,320
piece by piece and essentially that's

722
00:30:31,110 --> 00:30:36,209
like to two pieces at a time did you did

723
00:30:34,320 --> 00:30:37,889
you solve and the compiler does the same

724
00:30:36,210 --> 00:30:40,770
thing so this whole statement ends up

725
00:30:37,890 --> 00:30:42,930
looking like this which now you can

726
00:30:40,770 --> 00:30:45,780
imagine if you dump the chimp or

727
00:30:42,930 --> 00:30:47,760
presentation of a large application the

728
00:30:45,780 --> 00:30:48,930
output field is a lot bigger than the

729
00:30:47,760 --> 00:30:50,610
large piece of source code you fed in

730
00:30:48,930 --> 00:30:52,160
before because the compiler essentially

731
00:30:50,610 --> 00:30:54,030
takes all the code constructs out and

732
00:30:52,160 --> 00:30:56,040
represents them in a much simpler way

733
00:30:54,030 --> 00:30:57,990
because optimization works much better

734
00:30:56,040 --> 00:31:01,440
if the representation is standardized

735
00:30:57,990 --> 00:31:03,210
and simpler that means for us if we take

736
00:31:01,440 --> 00:31:04,890
a piece of source code that's as simple

737
00:31:03,210 --> 00:31:06,360
as you can see here on the left side we

738
00:31:04,890 --> 00:31:08,760
have two functions and they perform a

739
00:31:06,360 --> 00:31:10,590
simple calculation then simple goes on

740
00:31:08,760 --> 00:31:12,480
and translates them to what I've just

741
00:31:10,590 --> 00:31:14,970
shown before to like a much much larger

742
00:31:12,480 --> 00:31:16,470
piece of code but you can also see that

743
00:31:14,970 --> 00:31:19,530
the whole chimp our presentation overall

744
00:31:16,470 --> 00:31:21,000
looks very much like like C code the

745
00:31:19,530 --> 00:31:22,860
surprising thing is that essentially any

746
00:31:21,000 --> 00:31:24,590
piece of source code that defeated GCC

747
00:31:22,860 --> 00:31:29,240
that ends up in generic representation

748
00:31:24,590 --> 00:31:29,240
eventually looks very similar to C code

749
00:31:29,630 --> 00:31:36,860
okay so you seem simple but now what

750
00:31:33,510 --> 00:31:38,879
does it mean for for plugging authors

751
00:31:36,860 --> 00:31:41,010
simple by self as mentioned looks much

752
00:31:38,880 --> 00:31:44,669
like C so modifying Jim pool is

753
00:31:41,010 --> 00:31:48,240
it's not as difficult what is difficult

754
00:31:44,669 --> 00:31:54,510
I was figuring out the GCC API to be

755
00:31:48,240 --> 00:31:56,370
able to do so although simple chamber

756
00:31:54,510 --> 00:31:59,070
comes with with statements that look

757
00:31:56,370 --> 00:32:01,260
much like like from any other high-level

758
00:31:59,070 --> 00:32:03,570
programming language it also provides

759
00:32:01,260 --> 00:32:06,059
iterators and API is to modify

760
00:32:03,570 --> 00:32:07,710
statements so really if you're if you

761
00:32:06,059 --> 00:32:09,740
want to build a quick and simple proof

762
00:32:07,710 --> 00:32:12,179
of concept simple as the way to go

763
00:32:09,740 --> 00:32:14,340
what's Curacao has mentioned is closely

764
00:32:12,179 --> 00:32:16,410
tied to tree so eventually when you work

765
00:32:14,340 --> 00:32:19,530
on simple you will always find the tree

766
00:32:16,410 --> 00:32:20,990
again and also that tree follows you

767
00:32:19,530 --> 00:32:23,639
throughout the whole compilation process

768
00:32:20,990 --> 00:32:24,660
so when you go down the different paths

769
00:32:23,640 --> 00:32:26,190
structure at GCC

770
00:32:24,660 --> 00:32:29,730
you will you will always again see that

771
00:32:26,190 --> 00:32:31,799
tree pop up again which is which is

772
00:32:29,730 --> 00:32:34,590
funny because sometimes you you execute

773
00:32:31,799 --> 00:32:36,270
simple API is and you handover simple

774
00:32:34,590 --> 00:32:38,100
arguments and you would expect the chimp

775
00:32:36,270 --> 00:32:40,679
or return value but what you get is a

776
00:32:38,100 --> 00:32:46,649
tree because the tree is always there

777
00:32:40,679 --> 00:32:48,990
it's a bit bit creepy all right how does

778
00:32:46,650 --> 00:32:51,750
it look inside the plugin a quick look

779
00:32:48,990 --> 00:32:53,669
back again and the hail Satan example

780
00:32:51,750 --> 00:32:54,299
they can see like we had the iterators

781
00:32:53,669 --> 00:32:57,000
on top

782
00:32:54,299 --> 00:32:59,400
essentially in simple you're working on

783
00:32:57,000 --> 00:33:04,559
a function by function basis or GCC says

784
00:32:59,400 --> 00:33:08,370
it's an code how is a code item like a

785
00:33:04,559 --> 00:33:09,928
an execution item by item basis for for

786
00:33:08,370 --> 00:33:11,699
C that means you compile the function

787
00:33:09,929 --> 00:33:13,950
then you compile the next function then

788
00:33:11,700 --> 00:33:16,559
you compare the next function until you

789
00:33:13,950 --> 00:33:19,020
hit interprocedural optimization I'll

790
00:33:16,559 --> 00:33:20,549
talk about this in a bit later but for

791
00:33:19,020 --> 00:33:24,120
template means that we can always only

792
00:33:20,549 --> 00:33:26,010
work on one function at a time in that

793
00:33:24,120 --> 00:33:27,989
function we can list all the basic

794
00:33:26,010 --> 00:33:29,220
blocks that are our container that

795
00:33:27,990 --> 00:33:30,480
function and then for all the basic

796
00:33:29,220 --> 00:33:32,940
blocks we can walk through the temple

797
00:33:30,480 --> 00:33:35,040
statements as a reverse engineer I

798
00:33:32,940 --> 00:33:35,640
looked at that was like holy and so

799
00:33:35,040 --> 00:33:37,470
as a compiler

800
00:33:35,640 --> 00:33:39,330
I can see functions I can see basic

801
00:33:37,470 --> 00:33:39,870
blocks and the comparators make any

802
00:33:39,330 --> 00:33:42,559
mistakes

803
00:33:39,870 --> 00:33:44,639
there is no no no parsing mistakes

804
00:33:42,559 --> 00:33:46,320
because the compiler produces the stuff

805
00:33:44,640 --> 00:33:47,910
as a reverse engineer that is worked on

806
00:33:46,320 --> 00:33:50,189
malware you're very excited when you see

807
00:33:47,910 --> 00:33:51,809
like clear function definitions and

808
00:33:50,190 --> 00:33:54,059
basic blocks and stuff like that it's a

809
00:33:51,809 --> 00:33:54,509
beautiful thing anyhow you can iterate

810
00:33:54,059 --> 00:33:57,299
through

811
00:33:54,509 --> 00:33:59,849
and in there you can then search for a

812
00:33:57,299 --> 00:34:01,918
call statement so any any function call

813
00:33:59,849 --> 00:34:06,089
inside of temple will be will have the

814
00:34:01,919 --> 00:34:08,909
type simple call and every chimpo call

815
00:34:06,089 --> 00:34:12,899
has a given set of of arguments that he

816
00:34:08,909 --> 00:34:15,659
can parse for if you want to parse for

817
00:34:12,899 --> 00:34:20,069
anything in cheese's eg C it doesn't

818
00:34:15,659 --> 00:34:21,809
restrict you much this the C compiler

819
00:34:20,069 --> 00:34:23,909
afterwards will restrict you and say

820
00:34:21,809 --> 00:34:26,579
like you cannot you cannot assign this

821
00:34:23,909 --> 00:34:28,109
this variable to this this value to that

822
00:34:26,579 --> 00:34:30,230
variable because types concur or

823
00:34:28,109 --> 00:34:32,489
something like that but inside of GCC

824
00:34:30,230 --> 00:34:35,369
remember that everything is a tree so in

825
00:34:32,489 --> 00:34:36,928
theory you could take any given any

826
00:34:35,369 --> 00:34:39,149
given type that Jesus your hands you

827
00:34:36,929 --> 00:34:40,918
lower it down to a tree and forget

828
00:34:39,149 --> 00:34:42,839
completely which type and head but

829
00:34:40,918 --> 00:34:44,460
different types sometimes their

830
00:34:42,839 --> 00:34:47,969
different arguments assignment and can

831
00:34:44,460 --> 00:34:50,639
only take in different values and only a

832
00:34:47,969 --> 00:34:51,868
very different to a given set of API s

833
00:34:50,639 --> 00:34:55,319
and this is something that the developer

834
00:34:51,869 --> 00:34:56,129
has to know the the documentation might

835
00:34:55,319 --> 00:34:58,200
tell you some of that

836
00:34:56,129 --> 00:35:00,779
I agree but again the documentation has

837
00:34:58,200 --> 00:35:04,200
700 pages so when you develop TC be

838
00:35:00,779 --> 00:35:06,359
aware that if you don't check your your

839
00:35:04,200 --> 00:35:09,149
statement whether it really has a given

840
00:35:06,359 --> 00:35:11,400
type then you can still run given are

841
00:35:09,150 --> 00:35:13,890
given API is that will parse the

842
00:35:11,400 --> 00:35:15,779
statement GCC does not complain that the

843
00:35:13,890 --> 00:35:17,430
type is wrong and then eventually the

844
00:35:15,779 --> 00:35:19,380
compiler will crash but the compiler

845
00:35:17,430 --> 00:35:22,680
will not know why it crashes because

846
00:35:19,380 --> 00:35:26,339
there was nothing being done wrong you

847
00:35:22,680 --> 00:35:27,690
see the problem yeah so we have to check

848
00:35:26,339 --> 00:35:29,910
whether we have a call statement at hand

849
00:35:27,690 --> 00:35:31,589
and then we can search for the first

850
00:35:29,910 --> 00:35:34,470
argument I mention it before and build

851
00:35:31,589 --> 00:35:36,630
our or a tree that represents the string

852
00:35:34,470 --> 00:35:39,779
the hail Satan string so this is a tree

853
00:35:36,630 --> 00:35:42,869
by itself and the sign that treat be the

854
00:35:39,779 --> 00:35:44,730
argument of the chimpo call you see how

855
00:35:42,869 --> 00:35:48,480
those two representations are closely

856
00:35:44,730 --> 00:35:50,519
tied together after all of that is

857
00:35:48,480 --> 00:35:52,380
happening you first of all to see that

858
00:35:50,519 --> 00:35:54,930
lots of optimization in the middle you

859
00:35:52,380 --> 00:35:56,640
can I said you're able to plug into one

860
00:35:54,930 --> 00:35:58,950
of those optimization passes and perform

861
00:35:56,640 --> 00:36:00,150
your own optimizations that's a that's a

862
00:35:58,950 --> 00:36:03,029
different set of Hideko

863
00:36:00,150 --> 00:36:04,810
might why not after that Jesus he goes

864
00:36:03,029 --> 00:36:08,660
on and lowers

865
00:36:04,810 --> 00:36:12,529
chimp or a presentation to RTL and RTL

866
00:36:08,660 --> 00:36:14,089
by itself is a curious kind of beast RTL

867
00:36:12,530 --> 00:36:17,090
stands for register transfer language

868
00:36:14,090 --> 00:36:19,100
some people might note that some

869
00:36:17,090 --> 00:36:22,190
hardware programming language named RTL

870
00:36:19,100 --> 00:36:23,690
also exists some rather that RTL stands

871
00:36:22,190 --> 00:36:26,960
for the same thing but it's essentially

872
00:36:23,690 --> 00:36:30,820
not the same kind of language RTL is

873
00:36:26,960 --> 00:36:33,890
specific to to GCC and it essentially

874
00:36:30,820 --> 00:36:35,390
implements the machine definition so

875
00:36:33,890 --> 00:36:40,069
after we're done with all the chimp land

876
00:36:35,390 --> 00:36:42,430
SSA passes with without my session the

877
00:36:40,070 --> 00:36:44,990
compiler is only interested in

878
00:36:42,430 --> 00:36:47,960
translating the code to the final output

879
00:36:44,990 --> 00:36:49,790
representation that isn't entirely true

880
00:36:47,960 --> 00:36:52,700
though there is still optimization

881
00:36:49,790 --> 00:36:55,130
happening in those passes so the

882
00:36:52,700 --> 00:36:57,770
optimization happening during the temple

883
00:36:55,130 --> 00:37:01,670
stages is used for target independent

884
00:36:57,770 --> 00:37:03,680
optimization during the RTL stages the

885
00:37:01,670 --> 00:37:05,540
optimization that is run there is used

886
00:37:03,680 --> 00:37:07,129
for target dependent optimization

887
00:37:05,540 --> 00:37:09,259
because different CPU architectures

888
00:37:07,130 --> 00:37:13,790
might offer different different options

889
00:37:09,260 --> 00:37:15,230
for optimizing code as it goes but at

890
00:37:13,790 --> 00:37:17,450
this point in time I want to note that

891
00:37:15,230 --> 00:37:19,490
anything any definite statement that

892
00:37:17,450 --> 00:37:20,089
tell you about GCC take with a grain of

893
00:37:19,490 --> 00:37:22,459
salt

894
00:37:20,090 --> 00:37:24,320
because there's no such thing as totally

895
00:37:22,460 --> 00:37:29,330
target independent or totally targets

896
00:37:24,320 --> 00:37:31,520
dependent since some of the simple

897
00:37:29,330 --> 00:37:33,080
stages already take into account which

898
00:37:31,520 --> 00:37:34,759
architecture the code is being

899
00:37:33,080 --> 00:37:36,020
competitive because this is something

900
00:37:34,760 --> 00:37:37,550
that the compiler knows at all times

901
00:37:36,020 --> 00:37:39,140
right so it could just propagate that

902
00:37:37,550 --> 00:37:42,080
information and this is exactly what

903
00:37:39,140 --> 00:37:43,609
they do so target independent

904
00:37:42,080 --> 00:37:46,490
optimization is mostly target

905
00:37:43,609 --> 00:37:48,920
independent and targets dependent

906
00:37:46,490 --> 00:37:50,419
optimization is mostly targets dependent

907
00:37:48,920 --> 00:37:52,900
but turns out that the different

908
00:37:50,420 --> 00:37:55,640
optimization RTL can be reused for other

909
00:37:52,900 --> 00:37:59,350
target architectures if those target

910
00:37:55,640 --> 00:38:04,580
actually supported the same CPU features

911
00:37:59,350 --> 00:38:06,618
all right I tell by itself is similar to

912
00:38:04,580 --> 00:38:09,830
nice actually not similar it's an

913
00:38:06,619 --> 00:38:12,920
abstract way of describing assembly

914
00:38:09,830 --> 00:38:14,600
assembly language assembly bytecode with

915
00:38:12,920 --> 00:38:17,349
an abstract way I mean that the RTL

916
00:38:14,600 --> 00:38:21,609
statements look like they want to

917
00:38:17,349 --> 00:38:24,519
reduce x86 or like a given bytecode in

918
00:38:21,609 --> 00:38:28,420
the end but they don't have actually had

919
00:38:24,519 --> 00:38:31,868
heard the same rules are tell by itself

920
00:38:28,420 --> 00:38:34,359
is an abstract algebraic language which

921
00:38:31,869 --> 00:38:36,460
supports an infinite number of registers

922
00:38:34,359 --> 00:38:38,920
and consumes an infinite amount of

923
00:38:36,460 --> 00:38:40,930
memory because it doesn't consider any

924
00:38:38,920 --> 00:38:42,999
hardware limitations during the lowering

925
00:38:40,930 --> 00:38:44,229
passes of GCC the hardware limitations

926
00:38:42,999 --> 00:38:45,939
are taken into account and if you

927
00:38:44,229 --> 00:38:48,430
remember before I told you that there's

928
00:38:45,940 --> 00:38:51,519
a path to designs hard registers so

929
00:38:48,430 --> 00:38:53,979
initially RTL has a set of virtual

930
00:38:51,519 --> 00:38:56,709
registers mixed with hard registers that

931
00:38:53,979 --> 00:38:59,910
any cpu architecture that Jesus is

932
00:38:56,710 --> 00:39:02,979
supports also supports but during the

933
00:38:59,910 --> 00:39:04,899
register assignment pass those virtual

934
00:39:02,979 --> 00:39:06,399
registers are translated to hard

935
00:39:04,900 --> 00:39:08,410
registers and afterwards will be

936
00:39:06,400 --> 00:39:10,839
compiled for x86 we will see the typical

937
00:39:08,410 --> 00:39:14,019
that the stack pointer and and the base

938
00:39:10,839 --> 00:39:18,700
pointer and our ax and RB X and the

939
00:39:14,019 --> 00:39:20,618
typical registers that x86 supports in

940
00:39:18,700 --> 00:39:22,269
there's a funny episode at some point I

941
00:39:20,619 --> 00:39:24,789
was sitting in the lab and I was

942
00:39:22,269 --> 00:39:27,669
wondering like how can I tell GCC to use

943
00:39:24,789 --> 00:39:29,019
a register that will not be used for any

944
00:39:27,670 --> 00:39:30,819
other thing that the compiler wants to

945
00:39:29,019 --> 00:39:32,578
do with it later on and the colleague

946
00:39:30,819 --> 00:39:35,859
came up to me and like look at the API

947
00:39:32,579 --> 00:39:37,180
and I was like oh processor ABI and

948
00:39:35,859 --> 00:39:39,479
another one said yeah this is what you

949
00:39:37,180 --> 00:39:42,009
look at like why are you even asking and

950
00:39:39,479 --> 00:39:43,749
I was like ok ok I'll look at the ABI

951
00:39:42,009 --> 00:39:47,650
and I looked for the ABI and guess where

952
00:39:43,749 --> 00:39:49,319
I found it inside of the compiler I was

953
00:39:47,650 --> 00:39:53,440
I was really upset so like essentially

954
00:39:49,319 --> 00:39:56,829
GCC doesn't just listen to the ABI but

955
00:39:53,440 --> 00:39:58,869
GCC implements the process of ABI so the

956
00:39:56,829 --> 00:40:01,029
machine definitions represent exactly

957
00:39:58,869 --> 00:40:03,609
what the processor can do and the whole

958
00:40:01,029 --> 00:40:07,420
process of parsing RTL to a given a

959
00:40:03,609 --> 00:40:09,640
given by to output is all oriented by

960
00:40:07,420 --> 00:40:12,039
the ABI so the compiler knows what the

961
00:40:09,640 --> 00:40:14,650
output architecture expects that is a

962
00:40:12,039 --> 00:40:16,289
lot of a lot of GCC code like this is

963
00:40:14,650 --> 00:40:18,579
about six hundred lines of code only for

964
00:40:16,289 --> 00:40:19,809
not for x86 but for one given

965
00:40:18,579 --> 00:40:21,009
architecture I think I looked at MIPS or

966
00:40:19,809 --> 00:40:23,799
something like six hundred thousand

967
00:40:21,009 --> 00:40:27,039
lines of code just for putting

968
00:40:23,799 --> 00:40:29,499
given our chair representations into a

969
00:40:27,039 --> 00:40:30,640
given byte code representation and so

970
00:40:29,499 --> 00:40:38,020
yeah that's that's essentially what

971
00:40:30,640 --> 00:40:41,830
tl does and i'm finished with that slide

972
00:40:38,020 --> 00:40:44,740
beautiful our tale by itself as

973
00:40:41,830 --> 00:40:48,250
mentioned looks nothing like bytecode or

974
00:40:44,740 --> 00:40:51,879
or opcode i tell by itself is a

975
00:40:48,250 --> 00:40:55,990
description language to perform abstract

976
00:40:51,880 --> 00:40:58,510
descriptions of processor bytecode in

977
00:40:55,990 --> 00:41:03,040
that sense if you look at this slide you

978
00:40:58,510 --> 00:41:05,050
see two different RTL statements in RTL

979
00:41:03,040 --> 00:41:08,410
the statements are called

980
00:41:05,050 --> 00:41:11,530
engines whoever came up with that name

981
00:41:08,410 --> 00:41:16,210
so we look at two engines now one

982
00:41:11,530 --> 00:41:19,390
general engine that performs a set

983
00:41:16,210 --> 00:41:22,570
statement and a specific engine that

984
00:41:19,390 --> 00:41:25,359
performs a call statement if you were

985
00:41:22,570 --> 00:41:28,390
translated to x86 assembly you would see

986
00:41:25,360 --> 00:41:34,150
that the the hello world argument is

987
00:41:28,390 --> 00:41:36,490
assigned to RDI and then the function

988
00:41:34,150 --> 00:41:37,870
call to printf is performed if you look

989
00:41:36,490 --> 00:41:40,240
at how function calls and then answer

990
00:41:37,870 --> 00:41:41,770
are done the the first argument to a

991
00:41:40,240 --> 00:41:44,859
given function call is handed over

992
00:41:41,770 --> 00:41:47,470
through the RDI register in this case

993
00:41:44,860 --> 00:41:49,890
you can see there is the the set

994
00:41:47,470 --> 00:41:53,830
statement right here in the third line

995
00:41:49,890 --> 00:41:55,930
that sets the RDI register here

996
00:41:53,830 --> 00:41:57,490
shortened with di because at this point

997
00:41:55,930 --> 00:41:59,770
in the compilation process where I took

998
00:41:57,490 --> 00:42:01,479
that log file we already know the

999
00:41:59,770 --> 00:42:04,750
registers we want to work with but we

1000
00:42:01,480 --> 00:42:06,670
don't yet know which business we're

1001
00:42:04,750 --> 00:42:09,250
looking at so from this stage we could

1002
00:42:06,670 --> 00:42:11,320
still compile for 32-bit or for 64-bit

1003
00:42:09,250 --> 00:42:15,700
which is why the registers are shortened

1004
00:42:11,320 --> 00:42:18,280
here then you see that the RDI register

1005
00:42:15,700 --> 00:42:20,259
is loaded with a symbol reference which

1006
00:42:18,280 --> 00:42:23,560
goes to dot LC 0 which is somewhere in

1007
00:42:20,260 --> 00:42:27,190
our data section at this address that

1008
00:42:23,560 --> 00:42:28,840
we'll have in the future which we could

1009
00:42:27,190 --> 00:42:31,240
not guess that holds the hello world

1010
00:42:28,840 --> 00:42:33,250
string something that's that's

1011
00:42:31,240 --> 00:42:36,040
occasionally annoying about RTL is that

1012
00:42:33,250 --> 00:42:37,960
it doesn't know anymore which which

1013
00:42:36,040 --> 00:42:41,950
pieces of data the application consumes

1014
00:42:37,960 --> 00:42:43,680
so when we enter the RTL stage the the

1015
00:42:41,950 --> 00:42:45,509
constant of hello world has already

1016
00:42:43,680 --> 00:42:47,160
moved to the data section of the output

1017
00:42:45,510 --> 00:42:48,329
file which means that we don't actually

1018
00:42:47,160 --> 00:42:50,220
have access anymore

1019
00:42:48,329 --> 00:42:52,440
to that hello world string we just see

1020
00:42:50,220 --> 00:42:54,569
there the symbol reference the reference

1021
00:42:52,440 --> 00:42:57,780
is an offset in the data section of the

1022
00:42:54,569 --> 00:42:58,980
compiled binary that is annoying if you

1023
00:42:57,780 --> 00:43:00,510
want to come up with a proof of concept

1024
00:42:58,980 --> 00:43:02,819
that replaces hello world with hail

1025
00:43:00,510 --> 00:43:04,079
Satan there is no more hello world when

1026
00:43:02,819 --> 00:43:05,819
you look at the arterial presentation

1027
00:43:04,079 --> 00:43:08,760
which is the reason why I wrote the

1028
00:43:05,819 --> 00:43:11,220
Chamber plugin you know so here we see

1029
00:43:08,760 --> 00:43:12,809
that our DL is loaded our di is loaded

1030
00:43:11,220 --> 00:43:14,609
with the hello world string or like with

1031
00:43:12,809 --> 00:43:18,059
the offset to the hello world string now

1032
00:43:14,609 --> 00:43:21,180
here we see a call in which again starts

1033
00:43:18,059 --> 00:43:24,930
with a set which is curious set in this

1034
00:43:21,180 --> 00:43:27,089
case sets the return value of the other

1035
00:43:24,930 --> 00:43:29,040
function that is going to be called so

1036
00:43:27,089 --> 00:43:30,720
with this first statement we say that re

1037
00:43:29,040 --> 00:43:32,690
X is gonna hold the return value of this

1038
00:43:30,720 --> 00:43:37,890
function that means for the compiler

1039
00:43:32,690 --> 00:43:40,079
that re X should not be like if he--if

1040
00:43:37,890 --> 00:43:42,328
re x is being used before this

1041
00:43:40,079 --> 00:43:44,790
instructions executed that it cannot be

1042
00:43:42,329 --> 00:43:46,800
trusted after this instructions executed

1043
00:43:44,790 --> 00:43:49,319
this is nothing to do with what the

1044
00:43:46,800 --> 00:43:50,970
function tries to do the function will

1045
00:43:49,319 --> 00:43:53,400
need to place its return the value into

1046
00:43:50,970 --> 00:43:54,629
into re X this is defined by by the

1047
00:43:53,400 --> 00:43:56,369
calling convention that was used for

1048
00:43:54,630 --> 00:43:57,780
implementing that function for the

1049
00:43:56,369 --> 00:43:59,609
compiler that just means that this

1050
00:43:57,780 --> 00:44:02,160
register will be clobbered that means

1051
00:43:59,609 --> 00:44:03,569
that again if it's used before that

1052
00:44:02,160 --> 00:44:06,240
instruction it cannot be used again

1053
00:44:03,569 --> 00:44:10,109
after the instruction because of this it

1054
00:44:06,240 --> 00:44:13,740
is dirty then you see the call statement

1055
00:44:10,109 --> 00:44:15,328
which cause puts if you've looked at

1056
00:44:13,740 --> 00:44:17,910
Linux binaries they translate every

1057
00:44:15,329 --> 00:44:19,460
printf to the library specific function

1058
00:44:17,910 --> 00:44:28,348
in our case that's a put string and

1059
00:44:19,460 --> 00:44:29,490
there we see that no sorry that's it we

1060
00:44:28,349 --> 00:44:31,319
don't see anything more interesting in

1061
00:44:29,490 --> 00:44:33,629
here you see that the puts instruction

1062
00:44:31,319 --> 00:44:35,819
the puts function is being called and

1063
00:44:33,630 --> 00:44:37,770
that this is the argument that's handed

1064
00:44:35,819 --> 00:44:39,270
over through through our di this would

1065
00:44:37,770 --> 00:44:43,140
be if you wanted to entrace late this

1066
00:44:39,270 --> 00:44:44,670
piece of text to x86 but keep in mind

1067
00:44:43,140 --> 00:44:47,400
this day this piece of text could still

1068
00:44:44,670 --> 00:44:50,640
be translated to arm or to MIPS or to

1069
00:44:47,400 --> 00:44:52,920
anywhere else or maybe not because

1070
00:44:50,640 --> 00:44:54,720
register assignment worked anyhow you're

1071
00:44:52,920 --> 00:44:56,750
still independent from x86 at this point

1072
00:44:54,720 --> 00:44:59,669
in time

1073
00:44:56,750 --> 00:45:01,500
the representation itself I've been

1074
00:44:59,670 --> 00:45:03,839
talking a lot about it I've not not

1075
00:45:01,500 --> 00:45:05,450
nearly described how it really looks

1076
00:45:03,839 --> 00:45:10,890
like and how to work with it

1077
00:45:05,450 --> 00:45:14,009
RTL by itself is made of objects and and

1078
00:45:10,890 --> 00:45:16,440
object types the the instance that we've

1079
00:45:14,010 --> 00:45:18,480
been talking about are mostly RTL

1080
00:45:16,440 --> 00:45:20,520
expressions which means if you want to

1081
00:45:18,480 --> 00:45:23,280
set the register with a certain value

1082
00:45:20,520 --> 00:45:26,190
that's that's considered an RTL

1083
00:45:23,280 --> 00:45:28,500
expression you tell the compiler you

1084
00:45:26,190 --> 00:45:31,190
teach the compiler RTL expressions and

1085
00:45:28,500 --> 00:45:33,300
the compiler produces instant statements

1086
00:45:31,190 --> 00:45:35,220
whatever you do will compile is usually

1087
00:45:33,300 --> 00:45:37,319
you look at it from two sides so if you

1088
00:45:35,220 --> 00:45:39,868
want to produce x86 you have to tell the

1089
00:45:37,319 --> 00:45:42,270
compiler to produce x86 if you want a

1090
00:45:39,869 --> 00:45:45,210
compiler to produce instance you have to

1091
00:45:42,270 --> 00:45:47,160
instruct the compiler to produce RTL

1092
00:45:45,210 --> 00:45:50,520
expressions this is how GCC works don't

1093
00:45:47,160 --> 00:45:53,759
ask me why we have different classes in

1094
00:45:50,520 --> 00:45:56,240
there so instead of r-tx engines which

1095
00:45:53,760 --> 00:46:01,950
would be like general sets we can also

1096
00:45:56,240 --> 00:46:04,078
generate compares or calls were returns

1097
00:46:01,950 --> 00:46:05,750
those are different types that are

1098
00:46:04,079 --> 00:46:07,710
supported as a generic representation

1099
00:46:05,750 --> 00:46:10,260
and of course we have to consider

1100
00:46:07,710 --> 00:46:11,640
machine modes before I told you that at

1101
00:46:10,260 --> 00:46:13,050
that stage we took the lock file we

1102
00:46:11,640 --> 00:46:15,480
could still decide whether we wanted to

1103
00:46:13,050 --> 00:46:18,030
go for 32-bit or 64-bit this is

1104
00:46:15,480 --> 00:46:20,130
essentially indicated by machine modes

1105
00:46:18,030 --> 00:46:21,960
that you have to hand over to an RTL

1106
00:46:20,130 --> 00:46:24,869
expression to tell the compiler which

1107
00:46:21,960 --> 00:46:26,250
machine mode you're compiling for this

1108
00:46:24,869 --> 00:46:28,560
is important as a plug-in author because

1109
00:46:26,250 --> 00:46:31,079
occasionally you get funny errors when a

1110
00:46:28,560 --> 00:46:33,020
variable doesn't doesn't fit a certain

1111
00:46:31,079 --> 00:46:36,890
space or something that usually means

1112
00:46:33,020 --> 00:46:39,660
the the error that cheesiest uses

1113
00:46:36,890 --> 00:46:42,480
invalid instruction invalid engine

1114
00:46:39,660 --> 00:46:44,009
length that means most likely that

1115
00:46:42,480 --> 00:46:45,569
you've confused the machine mount

1116
00:46:44,010 --> 00:46:48,210
somewhere and designed the wrong

1117
00:46:45,569 --> 00:46:52,440
width of your piece of memory or your

1118
00:46:48,210 --> 00:46:54,900
register that you're working with then

1119
00:46:52,440 --> 00:46:58,230
finally from packing perspective words

1120
00:46:54,900 --> 00:47:01,020
close as we can get to to the x86 layer

1121
00:46:58,230 --> 00:47:03,660
that also means we have more power than

1122
00:47:01,020 --> 00:47:07,440
we might have ever wanted when you

1123
00:47:03,660 --> 00:47:08,879
modify RTL be aware that many parting

1124
00:47:07,440 --> 00:47:10,170
stages where the compiler what

1125
00:47:08,880 --> 00:47:12,059
she's out that the author can do

1126
00:47:10,170 --> 00:47:14,279
anything wrong have already happened so

1127
00:47:12,059 --> 00:47:17,039
that stage the compiler looks at very

1128
00:47:14,279 --> 00:47:20,160
little for your mistakes that means if

1129
00:47:17,039 --> 00:47:23,250
you modify a register in an RTL pass and

1130
00:47:20,160 --> 00:47:25,589
you forget that that register is used

1131
00:47:23,250 --> 00:47:26,789
later on by the function for four

1132
00:47:25,589 --> 00:47:29,599
different things or is is used by the

1133
00:47:26,789 --> 00:47:31,920
compiler for different other activities

1134
00:47:29,599 --> 00:47:33,329
then you have to tell the compiler you

1135
00:47:31,920 --> 00:47:35,609
cannot assume that the compiler will

1136
00:47:33,329 --> 00:47:37,289
automatically know and use different

1137
00:47:35,609 --> 00:47:39,299
registers for the tasks that are lying

1138
00:47:37,289 --> 00:47:41,630
ahead an interesting problem that I had

1139
00:47:39,299 --> 00:47:43,829
there was position independent code

1140
00:47:41,630 --> 00:47:47,190
position independent code leverages the

1141
00:47:43,829 --> 00:47:50,400
RBX register to load a given table that

1142
00:47:47,190 --> 00:47:52,109
it needs for execution and turns out if

1143
00:47:50,400 --> 00:47:54,000
you use the RBX register for something

1144
00:47:52,109 --> 00:47:57,480
else than the position independent code

1145
00:47:54,000 --> 00:48:00,599
afterwards will not run as curiously as

1146
00:47:57,480 --> 00:48:03,450
it is a benefit though from from working

1147
00:48:00,599 --> 00:48:08,400
on RTL is that we're also as far away

1148
00:48:03,450 --> 00:48:10,740
from optimizers as we can get optimizers

1149
00:48:08,400 --> 00:48:13,049
are sometimes very annoying when you try

1150
00:48:10,740 --> 00:48:15,959
to modify something that's specific to

1151
00:48:13,049 --> 00:48:18,299
give an architecture so for example if

1152
00:48:15,960 --> 00:48:21,000
you try to introduce a stack cannery in

1153
00:48:18,299 --> 00:48:22,950
chimpo you can most likely go ahead and

1154
00:48:21,000 --> 00:48:25,529
do that but be aware that a compiler

1155
00:48:22,950 --> 00:48:28,348
like especially an optimizer things that

1156
00:48:25,529 --> 00:48:29,670
that Canaries are really stupid so i

1157
00:48:28,349 --> 00:48:31,349
compiler looks at that and says like

1158
00:48:29,670 --> 00:48:33,000
this is useless code let's take it out

1159
00:48:31,349 --> 00:48:34,559
which might not have been what you

1160
00:48:33,000 --> 00:48:35,940
wanted in the first place so when you do

1161
00:48:34,559 --> 00:48:38,579
modifications be aware that the

1162
00:48:35,940 --> 00:48:40,470
optimization process that run after your

1163
00:48:38,579 --> 00:48:44,849
given pass could still destroy your work

1164
00:48:40,470 --> 00:48:46,799
and make it useless and finally if you

1165
00:48:44,849 --> 00:48:48,000
want to implement anything in RTL look

1166
00:48:46,799 --> 00:48:49,609
at the log files rather than the

1167
00:48:48,000 --> 00:48:51,750
documentation I mentioned that before

1168
00:48:49,609 --> 00:48:55,410
here's some example and how to actually

1169
00:48:51,750 --> 00:48:57,119
write RTL so if you're if you're going

1170
00:48:55,410 --> 00:49:01,649
at it with a plugin you have to use the

1171
00:48:57,119 --> 00:49:03,660
API to to issue RTL expressions and that

1172
00:49:01,650 --> 00:49:06,390
means that for any given assembly

1173
00:49:03,660 --> 00:49:10,109
instruction that you want to issue you

1174
00:49:06,390 --> 00:49:12,180
have to in most cases you have to call

1175
00:49:10,109 --> 00:49:14,759
at least three or four functions to

1176
00:49:12,180 --> 00:49:17,009
actually get to your your output engine

1177
00:49:14,759 --> 00:49:18,660
so the first example you see an area

1178
00:49:17,009 --> 00:49:21,029
instruction in the second example you

1179
00:49:18,660 --> 00:49:21,890
see a push instruction and then the

1180
00:49:21,029 --> 00:49:23,600
third exam

1181
00:49:21,890 --> 00:49:25,009
we move instruction and the move is very

1182
00:49:23,600 --> 00:49:26,540
straightforward because as mentioned

1183
00:49:25,010 --> 00:49:28,730
before we have this set this

1184
00:49:26,540 --> 00:49:30,680
construction of set which just sets one

1185
00:49:28,730 --> 00:49:32,390
value to another which is pretty pretty

1186
00:49:30,680 --> 00:49:34,910
simple but for example if you want to

1187
00:49:32,390 --> 00:49:36,770
push a value the compiler needs to be

1188
00:49:34,910 --> 00:49:38,299
aware of where the stack is and what the

1189
00:49:36,770 --> 00:49:40,520
stack is and how to access the stack

1190
00:49:38,300 --> 00:49:41,780
which which memory miles we need to

1191
00:49:40,520 --> 00:49:43,759
accessing the stack because that could

1192
00:49:41,780 --> 00:49:45,680
be 32 bits wide or it could be 64 bits

1193
00:49:43,760 --> 00:49:49,370
wide or it could be whatever bits wide

1194
00:49:45,680 --> 00:49:51,680
that the CP architecture defines and we

1195
00:49:49,370 --> 00:49:53,089
need to modify the stack pointer so if

1196
00:49:51,680 --> 00:49:54,020
you push something and on top of the

1197
00:49:53,090 --> 00:49:55,340
stack you need to know where the stack

1198
00:49:54,020 --> 00:49:57,920
is and you need to modify the stack

1199
00:49:55,340 --> 00:49:59,630
pointer to update it to jump on a hand

1200
00:49:57,920 --> 00:50:01,010
which is usually what pushed us if you

1201
00:49:59,630 --> 00:50:02,840
remember the push instruction has

1202
00:50:01,010 --> 00:50:04,760
different things and if you're inside

1203
00:50:02,840 --> 00:50:07,700
the compiler you have to emulate those

1204
00:50:04,760 --> 00:50:10,030
same activities just so that the output

1205
00:50:07,700 --> 00:50:13,580
is still intact

1206
00:50:10,030 --> 00:50:14,810
just very tedious alright and I talked

1207
00:50:13,580 --> 00:50:16,370
about 30 minutes about compiler

1208
00:50:14,810 --> 00:50:17,810
internalize here's the last stage the

1209
00:50:16,370 --> 00:50:19,819
machine definitions the machine

1210
00:50:17,810 --> 00:50:21,160
definitions are fairly boring if you

1211
00:50:19,820 --> 00:50:24,110
look at it the machine definitions

1212
00:50:21,160 --> 00:50:26,750
describe how the output instructions

1213
00:50:24,110 --> 00:50:29,120
forgiving architecture look like they're

1214
00:50:26,750 --> 00:50:32,240
made up of different files where the

1215
00:50:29,120 --> 00:50:35,600
most important one is the architecture

1216
00:50:32,240 --> 00:50:37,850
dot nd file and that looks as shown on

1217
00:50:35,600 --> 00:50:39,620
the slide like very ugly again but when

1218
00:50:37,850 --> 00:50:40,670
you work in GCC you look at lots of text

1219
00:50:39,620 --> 00:50:43,029
files that I'll show you different

1220
00:50:40,670 --> 00:50:45,590
representations of the very same thing

1221
00:50:43,030 --> 00:50:49,460
so in this case we see a machine

1222
00:50:45,590 --> 00:50:52,190
definition define in Z for a sub which

1223
00:50:49,460 --> 00:50:54,350
defines how the RTL looks like that is

1224
00:50:52,190 --> 00:50:55,970
needed for describing that sub if you

1225
00:50:54,350 --> 00:50:59,120
want to generate a sub you will have to

1226
00:50:55,970 --> 00:51:01,640
to issue all of those RTL constructions

1227
00:50:59,120 --> 00:51:05,060
and then how the the output sub looks

1228
00:51:01,640 --> 00:51:06,589
like as text I mentioned at the

1229
00:51:05,060 --> 00:51:08,360
beginning the the first stage of the

1230
00:51:06,590 --> 00:51:10,970
compiler produces text files

1231
00:51:08,360 --> 00:51:14,060
I was I was stunned when I saw that

1232
00:51:10,970 --> 00:51:15,890
first in theory you can issue you don't

1233
00:51:14,060 --> 00:51:17,830
want to do this this is bad practice but

1234
00:51:15,890 --> 00:51:21,529
here you can issue a printf inside of a

1235
00:51:17,830 --> 00:51:23,569
or a print file to inside the village it

1236
00:51:21,530 --> 00:51:25,580
is a plugin and prints directly to the

1237
00:51:23,570 --> 00:51:27,320
assembly output file you will most

1238
00:51:25,580 --> 00:51:28,610
likely mess things up there and break

1239
00:51:27,320 --> 00:51:30,890
things and make everything unrunnable

1240
00:51:28,610 --> 00:51:34,550
but you could do that you could print SD

1241
00:51:30,890 --> 00:51:35,359
text to the assembly output and not do

1242
00:51:34,550 --> 00:51:41,660
all over the

1243
00:51:35,360 --> 00:51:43,160
asks you to do all right finally if we

1244
00:51:41,660 --> 00:51:44,450
step through all the different passes

1245
00:51:43,160 --> 00:51:47,000
and sheezy there's still the

1246
00:51:44,450 --> 00:51:49,850
interprocedural passes which help us

1247
00:51:47,000 --> 00:51:52,520
look at the whole piece of code that we

1248
00:51:49,850 --> 00:51:53,750
want to compile I'll make this quick so

1249
00:51:52,520 --> 00:51:55,640
in chimpo for example you look at the

1250
00:51:53,750 --> 00:51:57,770
function I mention that and inside of an

1251
00:51:55,640 --> 00:51:59,210
IPA plug-in you look at at all of the

1252
00:51:57,770 --> 00:52:00,620
functions together so there you can

1253
00:51:59,210 --> 00:52:04,190
parse from function to function and

1254
00:52:00,620 --> 00:52:07,839
perform changes that have to know how

1255
00:52:04,190 --> 00:52:10,280
the whole function call tree looks like

1256
00:52:07,840 --> 00:52:11,600
and I'll skip most of the rest of the

1257
00:52:10,280 --> 00:52:12,080
slide because I think I'm running out of

1258
00:52:11,600 --> 00:52:15,200
time

1259
00:52:12,080 --> 00:52:16,759
finally additional wisdom JCC plug-in

1260
00:52:15,200 --> 00:52:18,020
troubleshooting it's very important this

1261
00:52:16,760 --> 00:52:20,510
is what either most of the time when you

1262
00:52:18,020 --> 00:52:22,220
write plugins we try to troubleshoot GCC

1263
00:52:20,510 --> 00:52:23,360
isn't very helpful with putting out

1264
00:52:22,220 --> 00:52:26,029
there are messages when your plug-in

1265
00:52:23,360 --> 00:52:27,380
fails because GCC thinks that the source

1266
00:52:26,030 --> 00:52:29,960
codes the deferred the compiler is a

1267
00:52:27,380 --> 00:52:31,880
problem another plugin GCC is aware that

1268
00:52:29,960 --> 00:52:33,710
there's plugins running it will tell you

1269
00:52:31,880 --> 00:52:35,120
when you execute a plug-in that it is

1270
00:52:33,710 --> 00:52:36,800
running a plug-in that you should check

1271
00:52:35,120 --> 00:52:38,390
the plug-in but it does not tell you

1272
00:52:36,800 --> 00:52:41,270
where in the plug-in the compilation is

1273
00:52:38,390 --> 00:52:42,859
failing that means that you might be

1274
00:52:41,270 --> 00:52:44,120
looking for a mistake in your source

1275
00:52:42,860 --> 00:52:47,900
file where the mistake is actually

1276
00:52:44,120 --> 00:52:51,740
inside a plugin very helpful there is to

1277
00:52:47,900 --> 00:52:53,780
verify the the the stage to do plugging

1278
00:52:51,740 --> 00:52:55,310
into like know what the passes before

1279
00:52:53,780 --> 00:52:57,110
and after you are doing before you do

1280
00:52:55,310 --> 00:52:58,700
your own modifications so you know which

1281
00:52:57,110 --> 00:53:02,810
data structures are available and which

1282
00:52:58,700 --> 00:53:06,980
might not and of course look a lot at

1283
00:53:02,810 --> 00:53:08,600
GCC source code the first most helpful

1284
00:53:06,980 --> 00:53:10,880
thing I found was the log fast the

1285
00:53:08,600 --> 00:53:14,120
second most helpful thing I found was

1286
00:53:10,880 --> 00:53:15,860
mobile comm which lists very nice static

1287
00:53:14,120 --> 00:53:18,710
analysis of the whole GCC source base

1288
00:53:15,860 --> 00:53:20,780
with cross references and in inline

1289
00:53:18,710 --> 00:53:24,350
documentation everything that Linux

1290
00:53:20,780 --> 00:53:25,970
users don't usually have um I'll admit I

1291
00:53:24,350 --> 00:53:28,640
spend most of my development time on

1292
00:53:25,970 --> 00:53:30,020
Visual Studio where static online code

1293
00:53:28,640 --> 00:53:32,089
analysis isn't really a thing because

1294
00:53:30,020 --> 00:53:34,490
Visual Studio does all that and on Linux

1295
00:53:32,090 --> 00:53:35,810
here a bit less than that if anyone has

1296
00:53:34,490 --> 00:53:38,060
a better idea I'm open for suggestions

1297
00:53:35,810 --> 00:53:40,490
but I'm I'm still a very big favor of

1298
00:53:38,060 --> 00:53:42,170
efficiency in the case and yeah yeah the

1299
00:53:40,490 --> 00:53:46,279
debug logs and of course you can also go

1300
00:53:42,170 --> 00:53:47,720
debugging GCC if you go debugging GCC be

1301
00:53:46,280 --> 00:53:48,480
aware you have to compile a debug

1302
00:53:47,720 --> 00:53:51,390
builder cheese

1303
00:53:48,480 --> 00:53:54,089
and you want to debug the first stage of

1304
00:53:51,390 --> 00:53:55,440
the compiler this is where I found out

1305
00:53:54,089 --> 00:53:56,700
there's different stages of the compiler

1306
00:53:55,440 --> 00:53:57,900
that they can debug because if you try

1307
00:53:56,700 --> 00:53:59,578
to figure out why your plugin is not

1308
00:53:57,900 --> 00:54:01,980
working while you're debugging the the

1309
00:53:59,579 --> 00:54:03,930
assembler you're your own you you have

1310
00:54:01,980 --> 00:54:06,089
to debug the other binary just I've

1311
00:54:03,930 --> 00:54:08,129
mentioned and also finally you can you

1312
00:54:06,089 --> 00:54:09,890
can write RTL and simple C file so there

1313
00:54:08,130 --> 00:54:13,680
is an option as jesusí that it can

1314
00:54:09,890 --> 00:54:15,930
define inline RTL which is somewhat ugly

1315
00:54:13,680 --> 00:54:17,730
but you can do that and you can like

1316
00:54:15,930 --> 00:54:20,399
write RTL and simple C file and test

1317
00:54:17,730 --> 00:54:22,680
your code before you shoot sharp with

1318
00:54:20,400 --> 00:54:23,970
plugins alright

1319
00:54:22,680 --> 00:54:27,930
that was all the theory finally let's

1320
00:54:23,970 --> 00:54:30,598
have some fun as mentioned that identify

1321
00:54:27,930 --> 00:54:32,069
many work on mitigations where I cannot

1322
00:54:30,599 --> 00:54:34,980
actually tell you what I'm doing there

1323
00:54:32,070 --> 00:54:38,400
so for this talk I worked on the

1324
00:54:34,980 --> 00:54:41,670
opposite I tried to to unpatch code and

1325
00:54:38,400 --> 00:54:47,579
instead of fixing it so funny for for

1326
00:54:41,670 --> 00:54:49,920
the demo I I looked at the back I don't

1327
00:54:47,579 --> 00:54:52,800
know if she's in here right now so two

1328
00:54:49,920 --> 00:54:55,200
months ago I attended a code security

1329
00:54:52,800 --> 00:54:56,730
workshop by by Natalie's of animage who

1330
00:54:55,200 --> 00:54:59,848
gave a talk yesterday and on exactly

1331
00:54:56,730 --> 00:55:01,560
that and code security and she showed us

1332
00:54:59,849 --> 00:55:04,650
a very simple bug in SQLite that looked

1333
00:55:01,560 --> 00:55:06,750
looked funny when you when you look at

1334
00:55:04,650 --> 00:55:09,329
the source there is exactly one check

1335
00:55:06,750 --> 00:55:11,550
missing that checks whether a given size

1336
00:55:09,329 --> 00:55:14,250
argument that's being decreased in a

1337
00:55:11,550 --> 00:55:15,089
loop eventually hits zero so the check

1338
00:55:14,250 --> 00:55:17,250
isn't there

1339
00:55:15,089 --> 00:55:19,529
so when certain conditions are true that

1340
00:55:17,250 --> 00:55:21,420
size argument will go into the negatives

1341
00:55:19,530 --> 00:55:23,460
the third arguments author was used for

1342
00:55:21,420 --> 00:55:26,630
a mem copy call so the mem copy will

1343
00:55:23,460 --> 00:55:29,430
eventually copy stuff God knows where

1344
00:55:26,630 --> 00:55:32,970
all right and this happens when you feed

1345
00:55:29,430 --> 00:55:36,359
the SQLite library a turn-off file that

1346
00:55:32,970 --> 00:55:38,129
is usually generated by bicycle I itself

1347
00:55:36,359 --> 00:55:39,839
but you can trick sq idn't loading a

1348
00:55:38,130 --> 00:55:43,680
custom troll file and if you take out

1349
00:55:39,839 --> 00:55:45,029
the - the size variable will will

1350
00:55:43,680 --> 00:55:48,328
decrease until

1351
00:55:45,030 --> 00:55:49,910
unknown alright so what did I do

1352
00:55:48,329 --> 00:55:52,079
I looked at the spark and I said like

1353
00:55:49,910 --> 00:55:54,089
this interesting says come I actually

1354
00:55:52,079 --> 00:55:55,710
patched it there's now a check in that

1355
00:55:54,089 --> 00:55:56,400
loop if you download the latest version

1356
00:55:55,710 --> 00:55:58,380
of SQLite

1357
00:55:56,400 --> 00:55:59,670
this cannot happen anymore so I don't

1358
00:55:58,380 --> 00:56:01,349
know that the latest version of SQLite

1359
00:55:59,670 --> 00:56:04,079
and so whether I could actually

1360
00:56:01,349 --> 00:56:06,900
that check for doing so that's a quick

1361
00:56:04,079 --> 00:56:08,339
look at the at the source so this is the

1362
00:56:06,900 --> 00:56:10,829
problematic piece of code where you can

1363
00:56:08,339 --> 00:56:14,279
see now there's like an if statement and

1364
00:56:10,829 --> 00:56:16,650
it says if n DB equals zero or other

1365
00:56:14,279 --> 00:56:17,190
condition returned this wasn't there

1366
00:56:16,650 --> 00:56:18,989
before

1367
00:56:17,190 --> 00:56:21,569
thankfully they know that that in the in

1368
00:56:18,989 --> 00:56:23,430
the command and turns out that many many

1369
00:56:21,569 --> 00:56:25,829
source many open source projects

1370
00:56:23,430 --> 00:56:27,899
actually leave those comments like they

1371
00:56:25,829 --> 00:56:30,180
put in a patch and they comment why they

1372
00:56:27,900 --> 00:56:32,369
patched which is when you go and want to

1373
00:56:30,180 --> 00:56:34,640
remove patches this is awesome there's

1374
00:56:32,369 --> 00:56:38,400
like flags in the code to tell you where

1375
00:56:34,640 --> 00:56:41,400
anyhow so if this check wouldn't be

1376
00:56:38,400 --> 00:56:43,799
there then the code the the loop would

1377
00:56:41,400 --> 00:56:46,229
be searching for like a dot or a dash

1378
00:56:43,799 --> 00:56:48,390
and if it wouldn't be able to find those

1379
00:56:46,229 --> 00:56:50,700
it would decrease and they'd be until

1380
00:56:48,390 --> 00:56:53,788
unknown until eventually somewhere in

1381
00:56:50,700 --> 00:56:56,249
memory it would hit a - this is then the

1382
00:56:53,789 --> 00:56:57,390
the value that this handed over to the

1383
00:56:56,249 --> 00:56:59,999
mem copy which at that point in time

1384
00:56:57,390 --> 00:57:02,249
might have any any value any unknown

1385
00:56:59,999 --> 00:57:04,859
value mem copy would then try to men

1386
00:57:02,249 --> 00:57:07,259
copy something somewhere this is the

1387
00:57:04,859 --> 00:57:10,049
folder that I'm working in there's a

1388
00:57:07,259 --> 00:57:13,460
couple of files in there and in the NDC

1389
00:57:10,049 --> 00:57:16,769
attest DB DB and the test DB journal DB

1390
00:57:13,460 --> 00:57:20,160
I might want to admit for for triggering

1391
00:57:16,769 --> 00:57:22,019
the back I built myself I cheated I

1392
00:57:20,160 --> 00:57:24,629
built myself an easier bug and easier

1393
00:57:22,019 --> 00:57:26,508
path to get to the actual bug but when

1394
00:57:24,630 --> 00:57:29,039
figuring right now is still the same bug

1395
00:57:26,509 --> 00:57:32,069
it just makes the proof of concept a

1396
00:57:29,039 --> 00:57:34,289
little easier oh yeah let's look at the

1397
00:57:32,069 --> 00:57:35,999
whole thing with the patch so if I go

1398
00:57:34,289 --> 00:57:37,739
ahead I have a make file here for a

1399
00:57:35,999 --> 00:57:39,779
rescue lie difficult and compile

1400
00:57:37,739 --> 00:57:41,869
escalate with this command line that you

1401
00:57:39,779 --> 00:57:44,460
can see there that there's nothing but

1402
00:57:41,869 --> 00:57:46,650
minus LD elements LP thread for loading

1403
00:57:44,460 --> 00:57:47,190
libraries - shared - pick for being a

1404
00:57:46,650 --> 00:57:49,229
shared library

1405
00:57:47,190 --> 00:57:51,869
- that was 0 because they don't like up

1406
00:57:49,229 --> 00:57:56,269
to my session etc and spits out the best

1407
00:57:51,869 --> 00:58:00,200
collide $3 so now I have my my DB test

1408
00:57:56,269 --> 00:58:02,968
application which goes ahead and loads

1409
00:58:00,200 --> 00:58:07,319
lots of database file without - and

1410
00:58:02,969 --> 00:58:09,450
without a dot lots this and with the

1411
00:58:07,319 --> 00:58:11,400
patch as Clyde says the decree open the

1412
00:58:09,450 --> 00:58:12,538
database successfully so we're happy

1413
00:58:11,400 --> 00:58:14,810
everything's secure

1414
00:58:12,539 --> 00:58:19,580
but now we're we go on and

1415
00:58:14,810 --> 00:58:22,759
execute the same thing now with the - f

1416
00:58:19,580 --> 00:58:25,759
plugin equals two chimpo attacker data

1417
00:58:22,760 --> 00:58:28,640
so that's my very creative name for from

1418
00:58:25,760 --> 00:58:31,940
a plugin we will see that this dispatch

1419
00:58:28,640 --> 00:58:34,040
isn't there anymore my plugin does a

1420
00:58:31,940 --> 00:58:36,020
little bit of output where you can see I

1421
00:58:34,040 --> 00:58:38,600
look for that specific vulnerable

1422
00:58:36,020 --> 00:58:40,759
function then I looked for the mem copy

1423
00:58:38,600 --> 00:58:43,339
call in that function then I looked for

1424
00:58:40,760 --> 00:58:45,010
what the argument for the size was like

1425
00:58:43,340 --> 00:58:47,330
in this case this is underscore 8

1426
00:58:45,010 --> 00:58:49,160
underscore 8 isn't really the variable

1427
00:58:47,330 --> 00:58:51,500
we're looking for if you remember the

1428
00:58:49,160 --> 00:58:53,960
temporal presentation was split up every

1429
00:58:51,500 --> 00:58:57,440
every mathematical calculations in this

1430
00:58:53,960 --> 00:58:58,940
case since we have the decrease like

1431
00:58:57,440 --> 00:59:00,640
that the subtraction happening on the

1432
00:58:58,940 --> 00:59:03,800
size argument this is a vegetable

1433
00:59:00,640 --> 00:59:07,040
virtual variable for for temple so here

1434
00:59:03,800 --> 00:59:08,870
we have - underscore 8 the Linda

1435
00:59:07,040 --> 00:59:10,970
compiler we have to follow up underscore

1436
00:59:08,870 --> 00:59:13,580
8 and find the actual assignment until

1437
00:59:10,970 --> 00:59:15,770
eventually we hit the NDB variable then

1438
00:59:13,580 --> 00:59:17,990
we have that variable and when we know

1439
00:59:15,770 --> 00:59:20,390
which variable represents our size

1440
00:59:17,990 --> 00:59:23,029
argument we look for conditional

1441
00:59:20,390 --> 00:59:25,129
arguments that check that particular

1442
00:59:23,030 --> 00:59:29,090
variable and there eventually we find

1443
00:59:25,130 --> 00:59:32,450
the if NDB equals 0 so when I found that

1444
00:59:29,090 --> 00:59:35,060
I can just remove it right and then when

1445
00:59:32,450 --> 00:59:37,430
I run my very same database application

1446
00:59:35,060 --> 00:59:40,150
with the unpatched library all of a

1447
00:59:37,430 --> 00:59:42,100
sudden we run into a segmentation fault

1448
00:59:40,150 --> 00:59:47,360
so there we are we've successfully

1449
00:59:42,100 --> 00:59:49,069
unpatched escalate this isn't about

1450
00:59:47,360 --> 00:59:52,930
nearly as exciting as if I would have

1451
00:59:49,070 --> 00:59:52,930
popped the calc on stage and now I

1452
00:59:53,260 --> 00:59:59,390
apologize for that later happy memory

1453
00:59:56,870 --> 01:00:02,779
corruption how does that look like if we

1454
00:59:59,390 --> 01:00:05,299
look at the assembly this light has to

1455
01:00:02,780 --> 01:00:07,550
be looked at from the left side first so

1456
01:00:05,300 --> 01:00:08,840
here you see the patched version you can

1457
01:00:07,550 --> 01:00:11,000
see in there those two lines are the

1458
01:00:08,840 --> 01:00:12,530
actual patch there we we look at the

1459
01:00:11,000 --> 01:00:14,270
size argument which in this case is

1460
01:00:12,530 --> 01:00:19,760
located on the stack and check whether

1461
01:00:14,270 --> 01:00:24,290
it's 0 and if so we jump to the return

1462
01:00:19,760 --> 01:00:27,140
we will return an SQLite okay so that is

1463
01:00:24,290 --> 01:00:28,160
that's in there then any database or any

1464
01:00:27,140 --> 01:00:30,200
journal file without

1465
01:00:28,160 --> 01:00:32,660
without a doubt and anything will work

1466
01:00:30,200 --> 01:00:34,730
just fine after we compile it with the

1467
01:00:32,660 --> 01:00:36,230
plugin though this patch is missing so

1468
01:00:34,730 --> 01:00:38,270
if you look here this is like the same

1469
01:00:36,230 --> 01:00:40,130
jump instruction this move instruction

1470
01:00:38,270 --> 01:00:42,049
down here is the same one as you can

1471
01:00:40,130 --> 01:00:44,930
barely see down here so here it's just

1472
01:00:42,049 --> 01:00:47,660
those two lines are gone that means we

1473
01:00:44,930 --> 01:00:50,808
unpatched the target binary and ran into

1474
01:00:47,660 --> 01:00:52,490
our memory corruption how did I do this

1475
01:00:50,809 --> 01:00:54,470
just to sum it up real quickly I

1476
01:00:52,490 --> 01:00:56,288
searched for a chimp a call checked

1477
01:00:54,470 --> 01:00:58,879
whether the chimp a call was a man copy

1478
01:00:56,289 --> 01:01:01,130
searched for the size document of that

1479
01:00:58,880 --> 01:01:04,910
mem copy walked up the function switched

1480
01:01:01,130 --> 01:01:07,849
for sign each X on that size function

1481
01:01:04,910 --> 01:01:10,220
and remove them you might know that this

1482
01:01:07,849 --> 01:01:12,319
is possible like in any given

1483
01:01:10,220 --> 01:01:14,720
application so you don't have to stick

1484
01:01:12,319 --> 01:01:16,630
to that one particular bug I tried that

1485
01:01:14,720 --> 01:01:19,009
too with with SQLite there is actually

1486
01:01:16,630 --> 01:01:21,049
various different occasions where mem

1487
01:01:19,010 --> 01:01:22,730
copies are fed with size arguments that

1488
01:01:21,049 --> 01:01:25,119
are checked before whether they are zero

1489
01:01:22,730 --> 01:01:27,170
because they are decremented on the way

1490
01:01:25,119 --> 01:01:28,700
so this happens quite often in theory

1491
01:01:27,170 --> 01:01:31,220
you can remove all of those tiny checks

1492
01:01:28,700 --> 01:01:33,049
and just try to exploit like any bug you

1493
01:01:31,220 --> 01:01:34,939
can create as many bugs as you want but

1494
01:01:33,049 --> 01:01:36,230
the problem there is that you have to

1495
01:01:34,940 --> 01:01:38,119
reach out to not draw in the actual

1496
01:01:36,230 --> 01:01:41,089
application so I give anything that

1497
01:01:38,119 --> 01:01:43,099
you're removing is used by the by the

1498
01:01:41,089 --> 01:01:46,430
application by the application flow and

1499
01:01:43,099 --> 01:01:49,339
it's actually required to to be able to

1500
01:01:46,430 --> 01:01:51,529
execute properly in a normal setup then

1501
01:01:49,339 --> 01:01:53,900
you might be screwed if your your victim

1502
01:01:51,529 --> 01:01:56,029
tries to load the database file and it

1503
01:01:53,900 --> 01:01:58,220
just doesn't load like you can't exploit

1504
01:01:56,029 --> 01:01:59,270
something that's not running right so

1505
01:01:58,220 --> 01:02:03,770
you might want to make sure that your

1506
01:01:59,270 --> 01:02:06,130
plugin doesn't remove healthy things all

1507
01:02:03,770 --> 01:02:08,390
right finally who would do such things

1508
01:02:06,130 --> 01:02:10,190
supply chain attackers like attacking

1509
01:02:08,390 --> 01:02:11,390
compilers is something that's been noted

1510
01:02:10,190 --> 01:02:12,890
in the literature and a long time

1511
01:02:11,390 --> 01:02:15,589
actually been mentioned the first time

1512
01:02:12,890 --> 01:02:18,618
in 1984 by a guy

1513
01:02:15,589 --> 01:02:21,288
I forgot to name no but he gave a speech

1514
01:02:18,619 --> 01:02:23,599
after receiving his his touring his ACM

1515
01:02:21,289 --> 01:02:27,799
Turing Award and showed an example of

1516
01:02:23,599 --> 01:02:29,990
pulling it back tore into a given a

1517
01:02:27,799 --> 01:02:32,029
given application using a compiler so

1518
01:02:29,990 --> 01:02:33,859
that was the thing in 1984 you can still

1519
01:02:32,029 --> 01:02:36,529
do that today there's no real good

1520
01:02:33,859 --> 01:02:38,299
solution for the problem people can go

1521
01:02:36,529 --> 01:02:39,380
and of course watch out for the the

1522
01:02:38,299 --> 01:02:42,230
security of their builds

1523
01:02:39,380 --> 01:02:44,360
which is very healthy they can verify

1524
01:02:42,230 --> 01:02:46,670
third-party code which is very difficult

1525
01:02:44,360 --> 01:02:48,620
if you build open-source software and

1526
01:02:46,670 --> 01:02:50,920
the use of other open-source software to

1527
01:02:48,620 --> 01:02:54,259
build your open-source product then you

1528
01:02:50,920 --> 01:02:57,080
usually don't have the funding to look

1529
01:02:54,260 --> 01:02:59,810
at millions of lines of code in an

1530
01:02:57,080 --> 01:03:01,220
assembly representation to check whether

1531
01:02:59,810 --> 01:03:03,410
anything happens during the compilation

1532
01:03:01,220 --> 01:03:05,209
project process a similar problem by the

1533
01:03:03,410 --> 01:03:06,230
way is optimization bugs that's not a

1534
01:03:05,210 --> 01:03:07,550
field of research that people have

1535
01:03:06,230 --> 01:03:13,670
worked on in the past and that's that's

1536
01:03:07,550 --> 01:03:15,140
so far fairly unsolved and as an

1537
01:03:13,670 --> 01:03:16,340
attacker pretty pretty beautiful if you

1538
01:03:15,140 --> 01:03:18,620
can get your hands on the built

1539
01:03:16,340 --> 01:03:22,100
infrastructure of a large company then

1540
01:03:18,620 --> 01:03:24,109
oh my god alright yeah finally you can

1541
01:03:22,100 --> 01:03:25,490
do continuous build verification like

1542
01:03:24,110 --> 01:03:27,020
you produce your software you don't look

1543
01:03:25,490 --> 01:03:29,330
at the actual assembly representation

1544
01:03:27,020 --> 01:03:31,310
but you keep testing and fuzzing and you

1545
01:03:29,330 --> 01:03:32,060
have a great security team that does all

1546
01:03:31,310 --> 01:03:35,570
that for you

1547
01:03:32,060 --> 01:03:37,610
which is what I do with Intel alright

1548
01:03:35,570 --> 01:03:39,230
that was a presentation there's any

1549
01:03:37,610 --> 01:03:42,760
questions I might be detecting otherwise

1550
01:03:39,230 --> 01:03:42,760
thank you very much for your attention

1551
01:03:45,910 --> 01:03:47,970
you

