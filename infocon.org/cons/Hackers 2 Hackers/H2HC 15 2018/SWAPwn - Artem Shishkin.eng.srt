1
00:00:02,790 --> 00:00:08,570
[Music]

2
00:00:11,809 --> 00:00:21,289
hi everyone how are you doing well first

3
00:00:18,720 --> 00:00:23,698
of all I'd like to to give it up for

4
00:00:21,289 --> 00:00:33,360
hdhd like this conference is just

5
00:00:23,699 --> 00:00:35,430
gorgeous just nice so today I'm gonna

6
00:00:33,360 --> 00:00:39,690
talk about this thing

7
00:00:35,430 --> 00:00:42,180
SMAP on Smackdown I don't even know how

8
00:00:39,690 --> 00:00:43,739
you pronounce that but yeah it's a

9
00:00:42,180 --> 00:00:47,600
faster way for detecting double effects

10
00:00:43,739 --> 00:00:52,399
on their abilities and it's by me sure

11
00:00:47,600 --> 00:00:56,579
so this is a disclaimer that was put by

12
00:00:52,399 --> 00:00:59,579
into legal and I do not really speak

13
00:00:56,579 --> 00:01:03,390
lawyer language but it kind of means

14
00:00:59,579 --> 00:01:06,090
that it has nothing to do with Intel I

15
00:01:03,390 --> 00:01:07,740
was doing it in my spare time they have

16
00:01:06,090 --> 00:01:10,500
no responsibility for it

17
00:01:07,740 --> 00:01:12,689
yeah but for proper explanation I

18
00:01:10,500 --> 00:01:15,659
suggest you to visit Marion stock which

19
00:01:12,689 --> 00:01:19,710
is going to be the next stock after

20
00:01:15,659 --> 00:01:21,750
lunch I believe yeah and she has more

21
00:01:19,710 --> 00:01:25,949
knowledge about this one but still yeah

22
00:01:21,750 --> 00:01:26,580
it has nothing to do with Intel and Who

23
00:01:25,950 --> 00:01:29,900
am I

24
00:01:26,580 --> 00:01:32,700
yes I'm a security researcher I think

25
00:01:29,900 --> 00:01:37,290
Corporation that's why I had to put this

26
00:01:32,700 --> 00:01:41,130
disclaimer first and I like Windows

27
00:01:37,290 --> 00:01:46,350
kernel it's like not that much to talk

28
00:01:41,130 --> 00:01:53,070
about me yeah so the double fetch

29
00:01:46,350 --> 00:01:55,199
vulnerabilities what that is yeah I'm

30
00:01:53,070 --> 00:02:00,770
gonna cut with a different sample for

31
00:01:55,200 --> 00:02:04,710
example imagine the situation two guys

32
00:02:00,770 --> 00:02:08,579
going to the store they want to buy

33
00:02:04,710 --> 00:02:12,930
something really expensive let's say it

34
00:02:08,580 --> 00:02:13,430
be a new video card that makes your

35
00:02:12,930 --> 00:02:16,969
images

36
00:02:13,430 --> 00:02:20,120
all bright and shiny yeah so the point

37
00:02:16,969 --> 00:02:23,439
is they go to the store they walk around

38
00:02:20,120 --> 00:02:27,849
they're choosing all the options and

39
00:02:23,439 --> 00:02:30,459
then yeah okay you came up with the

40
00:02:27,849 --> 00:02:35,138
video card module you want to have and

41
00:02:30,459 --> 00:02:38,569
then you buy it you go to the registry

42
00:02:35,139 --> 00:02:42,639
register and you count the money your

43
00:02:38,569 --> 00:02:46,399
cash give it to the sales assistant and

44
00:02:42,639 --> 00:02:48,560
then you're like way it's too expensive

45
00:02:46,400 --> 00:02:51,680
I know it's cool but it's too expensive

46
00:02:48,560 --> 00:02:54,799
now I cannot do it and you're like no

47
00:02:51,680 --> 00:02:56,750
you know I'm not gonna do it here's a

48
00:02:54,799 --> 00:02:59,780
video card back give me my cash back

49
00:02:56,750 --> 00:03:03,590
it's just I cannot but at the very same

50
00:02:59,780 --> 00:03:06,439
moment a friend of this guy is like no

51
00:03:03,590 --> 00:03:09,769
you should buy it because you wanted to

52
00:03:06,439 --> 00:03:13,459
have it like you will whine all the time

53
00:03:09,769 --> 00:03:17,000
it's like and you're like I mean not

54
00:03:13,459 --> 00:03:21,379
here the guy is like okay he gives the

55
00:03:17,000 --> 00:03:23,769
cash back to the sales assistant gets

56
00:03:21,379 --> 00:03:28,159
the video card and the guys walk away

57
00:03:23,769 --> 00:03:30,379
but the thing is the second time he gave

58
00:03:28,159 --> 00:03:33,260
a cash he actually gave not a cash but

59
00:03:30,379 --> 00:03:38,540
for example this one with Rodrigo smiley

60
00:03:33,260 --> 00:03:40,939
face yeah so that's an example of double

61
00:03:38,540 --> 00:03:42,918
fish vulnerabilities because the first

62
00:03:40,939 --> 00:03:45,799
time the sales assistant fetch the money

63
00:03:42,919 --> 00:03:48,199
it was actual real money and the second

64
00:03:45,799 --> 00:03:51,500
time since yeah he had already checked

65
00:03:48,199 --> 00:03:55,340
that the money was real so he just

66
00:03:51,500 --> 00:03:58,040
accepted the fake ones so that same

67
00:03:55,340 --> 00:04:00,650
happens here as in this example we got

68
00:03:58,040 --> 00:04:03,228
some struct structure which is the

69
00:04:00,650 --> 00:04:06,680
referenced in the kernel in accra normal

70
00:04:03,229 --> 00:04:09,560
driver and for example yeah then the

71
00:04:06,680 --> 00:04:12,409
closest example to a real world is

72
00:04:09,560 --> 00:04:17,509
checking the size so you check the size

73
00:04:12,409 --> 00:04:19,909
and then the different treat

74
00:04:17,509 --> 00:04:25,070
concurrently tries to modify this field

75
00:04:19,909 --> 00:04:27,039
and this is where the vulnerability

76
00:04:25,070 --> 00:04:29,200
kicks in because we are

77
00:04:27,040 --> 00:04:31,600
we think that we've already checked the

78
00:04:29,200 --> 00:04:35,440
size but for example when we try to use

79
00:04:31,600 --> 00:04:38,350
it sometime later it is already

80
00:04:35,440 --> 00:04:40,330
different so it leads to buffer

81
00:04:38,350 --> 00:04:46,300
overflows right and that's the way you

82
00:04:40,330 --> 00:04:49,450
actually exploit this thing so in here

83
00:04:46,300 --> 00:04:53,040
we got two sequential references to the

84
00:04:49,450 --> 00:04:58,000
same address so the proper way would be

85
00:04:53,040 --> 00:05:00,040
to get the size to cache it not the size

86
00:04:58,000 --> 00:05:04,090
but the whole structure the cache it

87
00:05:00,040 --> 00:05:06,310
locally and then do the checks because

88
00:05:04,090 --> 00:05:10,179
in this case we would be sure that no

89
00:05:06,310 --> 00:05:13,780
one would modify the structure in this

90
00:05:10,180 --> 00:05:20,770
small window it's small but it's still a

91
00:05:13,780 --> 00:05:26,770
window and you can win this race so how

92
00:05:20,770 --> 00:05:30,039
do we track this situation so I'm not

93
00:05:26,770 --> 00:05:34,630
the first one who actually doing it does

94
00:05:30,040 --> 00:05:37,740
that the most famous work I believe is

95
00:05:34,630 --> 00:05:42,000
done by Mateos jewelery Oh chick and

96
00:05:37,740 --> 00:05:47,410
jinhwan : from Google project zero and

97
00:05:42,000 --> 00:05:50,710
they presented this talk like a couple

98
00:05:47,410 --> 00:05:53,440
of years ago already and the work in

99
00:05:50,710 --> 00:05:59,140
progress still I believe so what they

100
00:05:53,440 --> 00:06:01,719
did they yeah the project was called box

101
00:05:59,140 --> 00:06:03,250
bone I'm not sure about the

102
00:06:01,720 --> 00:06:06,190
pronunciation sorry about that in

103
00:06:03,250 --> 00:06:08,440
advance but still box is a full system

104
00:06:06,190 --> 00:06:11,920
in emulator I don't know if you ever

105
00:06:08,440 --> 00:06:19,120
tried that but it emulates the whole

106
00:06:11,920 --> 00:06:22,750
system so they took this thing and they

107
00:06:19,120 --> 00:06:28,180
turn it they instrumented it because

108
00:06:22,750 --> 00:06:30,130
yeah it's all in software and they do

109
00:06:28,180 --> 00:06:33,160
the instrumentation in the way they

110
00:06:30,130 --> 00:06:35,800
actually record all the references from

111
00:06:33,160 --> 00:06:39,900
the kernel mode to user mode and they

112
00:06:35,800 --> 00:06:39,900
also track the timestamps and

113
00:06:40,490 --> 00:06:46,020
for example if we have two sequential

114
00:06:43,020 --> 00:06:51,060
excesses from a kernel multi-user mode

115
00:06:46,020 --> 00:06:54,120
we just can check the timestamps and if

116
00:06:51,060 --> 00:06:56,040
it's small relatively this is like to be

117
00:06:54,120 --> 00:07:00,180
determined for each and every system and

118
00:06:56,040 --> 00:07:03,570
if it's small that means that possibly

119
00:07:00,180 --> 00:07:06,600
in this point of code there was a double

120
00:07:03,570 --> 00:07:11,310
dereference that might lead to a double

121
00:07:06,600 --> 00:07:14,420
fetch owner ability but the drawback of

122
00:07:11,310 --> 00:07:17,310
this merit is since it's a whole system

123
00:07:14,420 --> 00:07:19,980
instrumentation and everything is done

124
00:07:17,310 --> 00:07:24,420
in software it is really really slow

125
00:07:19,980 --> 00:07:27,300
like from their presentation the windows

126
00:07:24,420 --> 00:07:32,070
7 boot up process would take like

127
00:07:27,300 --> 00:07:36,590
several hours so it's yeah it's a little

128
00:07:32,070 --> 00:07:39,030
bit slow for my situation I did not I

129
00:07:36,590 --> 00:07:41,130
didn't have a need to instrument the

130
00:07:39,030 --> 00:07:44,429
whole system since I was checking some

131
00:07:41,130 --> 00:07:47,940
like very particular drivers I know what

132
00:07:44,430 --> 00:07:51,270
I was looking for so it's just checking

133
00:07:47,940 --> 00:07:54,240
some exact drivers so I needed a faster

134
00:07:51,270 --> 00:07:56,640
way because you know instrument the

135
00:07:54,240 --> 00:08:01,740
whole system to check just one driver is

136
00:07:56,640 --> 00:08:03,750
a little overhead so yeah I think like

137
00:08:01,740 --> 00:08:04,530
what are the difference way to track the

138
00:08:03,750 --> 00:08:06,920
kernel-mode

139
00:08:04,530 --> 00:08:12,450
accesses to the user mode memory and

140
00:08:06,920 --> 00:08:15,540
then I remember this useful feature of

141
00:08:12,450 --> 00:08:17,870
indole processors it is called SMA P

142
00:08:15,540 --> 00:08:24,540
which is supervisor mode access

143
00:08:17,870 --> 00:08:29,430
prevention so what it does the way

144
00:08:24,540 --> 00:08:31,860
Windows distinguishes the kernel memory

145
00:08:29,430 --> 00:08:34,950
and the user memory is based on the hot

146
00:08:31,860 --> 00:08:37,740
Hardware feature actually because in the

147
00:08:34,950 --> 00:08:42,000
page table entry there are there is a

148
00:08:37,740 --> 00:08:45,660
bit which shows us whether it's a user

149
00:08:42,000 --> 00:08:48,600
page or a supervisor page and we can

150
00:08:45,660 --> 00:08:51,000
interpret this one like user mode is a

151
00:08:48,600 --> 00:08:51,790
user mode patient supervisor is a kernel

152
00:08:51,000 --> 00:08:57,070
mode page

153
00:08:51,790 --> 00:09:00,010
and what it does is when I called runs

154
00:08:57,070 --> 00:09:03,639
in ring zero that means it's a chroma

155
00:09:00,010 --> 00:09:08,470
mode code when this code tried to access

156
00:09:03,639 --> 00:09:11,589
a user mode page which means that it has

157
00:09:08,470 --> 00:09:16,540
user mode bits set in page table entry a

158
00:09:11,589 --> 00:09:19,180
page fault is raised as simple as that

159
00:09:16,540 --> 00:09:23,620
so this feature is configured by the

160
00:09:19,180 --> 00:09:28,120
control register number for big 21 I

161
00:09:23,620 --> 00:09:34,209
guess yeah and it's called basically SM

162
00:09:28,120 --> 00:09:38,649
ap this technology is coupled with these

163
00:09:34,209 --> 00:09:41,888
two instructions it's stuck clock stack

164
00:09:38,649 --> 00:09:45,730
like yeah now what what these

165
00:09:41,889 --> 00:09:50,500
instructions do is they actually set AC

166
00:09:45,730 --> 00:09:54,220
flag in the eve flag registered or clear

167
00:09:50,500 --> 00:09:58,360
this flag so the way it works if you set

168
00:09:54,220 --> 00:10:00,639
this flag it is called access check I

169
00:09:58,360 --> 00:10:03,399
guess but we'll talk about this later

170
00:10:00,639 --> 00:10:07,870
the way it works is when you set this

171
00:10:03,399 --> 00:10:10,540
flag the SMA SMA P temporarily doesn't

172
00:10:07,870 --> 00:10:12,519
work so if even if you're running in

173
00:10:10,540 --> 00:10:14,800
kernel and you reference the user remote

174
00:10:12,519 --> 00:10:16,899
memory and this bit is set nothing cans

175
00:10:14,800 --> 00:10:21,399
nothing's gonna happen no page fault is

176
00:10:16,899 --> 00:10:24,220
raised and when you clear it is enabled

177
00:10:21,399 --> 00:10:28,779
again and it works at is supposed to

178
00:10:24,220 --> 00:10:32,139
work and since Windows does not utilize

179
00:10:28,779 --> 00:10:34,660
this feature yet I'm saying yet because

180
00:10:32,139 --> 00:10:39,339
in the latest windows insider builds it

181
00:10:34,660 --> 00:10:42,339
is already used but like in a limited

182
00:10:39,339 --> 00:10:44,829
way so I was like hmm the windows

183
00:10:42,339 --> 00:10:47,500
doesn't use this so yeah we should try

184
00:10:44,829 --> 00:10:54,630
that because that's exactly the thing I

185
00:10:47,500 --> 00:10:58,240
want to track and yeah so the idea is as

186
00:10:54,630 --> 00:11:01,980
I said before to track kernel reference

187
00:10:58,240 --> 00:11:05,180
to do to the user mode memory and

188
00:11:01,980 --> 00:11:08,480
tracking this one we gathered in

189
00:11:05,180 --> 00:11:10,810
necessary information like the code

190
00:11:08,480 --> 00:11:13,970
address that caused an exception

191
00:11:10,810 --> 00:11:17,989
of course because we need to know what

192
00:11:13,970 --> 00:11:21,260
where is the point of code which

193
00:11:17,990 --> 00:11:23,360
actually does the double fetch or double

194
00:11:21,260 --> 00:11:27,400
reference to the user no user mode

195
00:11:23,360 --> 00:11:31,850
memory of course will lock what address

196
00:11:27,400 --> 00:11:34,699
was being accessed yeah and a timestamp

197
00:11:31,850 --> 00:11:37,730
of course because it happens really

198
00:11:34,700 --> 00:11:40,550
quick and we need to track the

199
00:11:37,730 --> 00:11:44,780
timestamps to find out whether it was

200
00:11:40,550 --> 00:11:47,870
Atkins consecutive reference of the user

201
00:11:44,780 --> 00:11:51,199
memory oh just it was like different

202
00:11:47,870 --> 00:11:57,380
references in different points of code

203
00:11:51,200 --> 00:12:01,690
and in different time and we gather this

204
00:11:57,380 --> 00:12:05,420
information and we actually apply a

205
00:12:01,690 --> 00:12:08,060
filtering because when we enable this

206
00:12:05,420 --> 00:12:10,339
mep feature we're actually tracking all

207
00:12:08,060 --> 00:12:13,130
kernel-mode accesses which means all the

208
00:12:10,340 --> 00:12:16,510
drivers the colonel itself right but we

209
00:12:13,130 --> 00:12:20,780
don't need all of that we we need a

210
00:12:16,510 --> 00:12:23,930
specific driver to track so that's why

211
00:12:20,780 --> 00:12:26,990
we can apply filtering in real time that

212
00:12:23,930 --> 00:12:30,880
means when the page fault is raised you

213
00:12:26,990 --> 00:12:34,100
check the faulting instruction pointer

214
00:12:30,880 --> 00:12:37,220
against the range of addresses so for

215
00:12:34,100 --> 00:12:41,540
example my driver is loaded somewhere in

216
00:12:37,220 --> 00:12:43,790
memory between 10,000 and 20,000 so if a

217
00:12:41,540 --> 00:12:48,490
page fault handler happens within this

218
00:12:43,790 --> 00:12:53,000
range yes it's our case we track it and

219
00:12:48,490 --> 00:12:58,490
it also increases performance because if

220
00:12:53,000 --> 00:12:59,960
you apply filtering later it's already a

221
00:12:58,490 --> 00:13:03,380
little too late because the performance

222
00:12:59,960 --> 00:13:08,630
goes down as you track references not

223
00:13:03,380 --> 00:13:11,120
like later right which makes sense and I

224
00:13:08,630 --> 00:13:14,180
was thinking about the ways to implement

225
00:13:11,120 --> 00:13:17,510
this feature the first one I came up

226
00:13:14,180 --> 00:13:19,069
with is actually do it using the

227
00:13:17,510 --> 00:13:26,149
debugger script

228
00:13:19,070 --> 00:13:29,899
and to be precise using Python scripting

229
00:13:26,149 --> 00:13:32,320
like pike ad plugging for windbg because

230
00:13:29,899 --> 00:13:35,209
it offers more functionality than

231
00:13:32,320 --> 00:13:39,380
standard when the windbg scripting

232
00:13:35,209 --> 00:13:43,040
language so I was thinking yeah the

233
00:13:39,380 --> 00:13:47,209
algorithm would be in ableism ap for all

234
00:13:43,040 --> 00:13:49,250
the course place a breakpoint on key

235
00:13:47,209 --> 00:13:54,439
page fault function which is a page

236
00:13:49,250 --> 00:13:57,410
fault handler on Windows right and then

237
00:13:54,440 --> 00:13:59,660
when it's triggered we should check

238
00:13:57,410 --> 00:14:03,079
whether it costs whether it was caused

239
00:13:59,660 --> 00:14:06,110
by a SM ap veil violation we log

240
00:14:03,079 --> 00:14:09,109
everything with disable SM ap and we

241
00:14:06,110 --> 00:14:12,079
perform a single step like why because

242
00:14:09,110 --> 00:14:14,120
we need the system to be running not to

243
00:14:12,079 --> 00:14:17,060
be stuck in the loop when it tries to

244
00:14:14,120 --> 00:14:20,329
access user mode memory and we just lock

245
00:14:17,060 --> 00:14:24,069
an infinite loop now it's like the

246
00:14:20,329 --> 00:14:27,620
standard resume cycle as if it was in

247
00:14:24,069 --> 00:14:30,050
some sort of debugger so you temporarily

248
00:14:27,620 --> 00:14:32,360
disable the SMA P tracking you do a

249
00:14:30,050 --> 00:14:34,430
single step that's what how you are able

250
00:14:32,360 --> 00:14:36,760
to track the further kernel-mode

251
00:14:34,430 --> 00:14:41,089
references to the user remote memory

252
00:14:36,760 --> 00:14:44,240
yeah and which is do the loop yeah it

253
00:14:41,089 --> 00:14:47,720
and this one looks fine and the

254
00:14:44,240 --> 00:14:49,690
advantages are well it is supposed to be

255
00:14:47,720 --> 00:14:53,959
the fastest way to implement this

256
00:14:49,690 --> 00:14:55,100
alright because it's it's a plugin you

257
00:14:53,959 --> 00:14:59,149
place a breakpoint

258
00:14:55,100 --> 00:15:00,730
you do some coding to react to those

259
00:14:59,149 --> 00:15:03,980
breakpoints

260
00:15:00,730 --> 00:15:06,829
yeah and it may be the easiest way as

261
00:15:03,980 --> 00:15:12,170
well because debugger does does all this

262
00:15:06,829 --> 00:15:16,758
stuff for you already but it also has

263
00:15:12,170 --> 00:15:20,779
the drawbacks first of all it's about

264
00:15:16,759 --> 00:15:24,819
transport latency because we're talking

265
00:15:20,779 --> 00:15:27,589
about windbg kernel kernel multi bugging

266
00:15:24,819 --> 00:15:30,709
latency because the way it works it has

267
00:15:27,589 --> 00:15:32,550
two different machines or a virtual

268
00:15:30,709 --> 00:15:35,010
machine which is still a different

269
00:15:32,550 --> 00:15:37,979
Sheen and those two are connected with

270
00:15:35,010 --> 00:15:42,510
some transport like serial connection

271
00:15:37,980 --> 00:15:45,360
use B debug cable firewire network card

272
00:15:42,510 --> 00:15:47,790
but even with network card there is a

273
00:15:45,360 --> 00:15:51,470
latency when you try to transfer data

274
00:15:47,790 --> 00:15:56,490
from one machine to another you know it

275
00:15:51,470 --> 00:15:58,740
accumulates and it gives us a real delay

276
00:15:56,490 --> 00:16:02,160
in sending the information even though

277
00:15:58,740 --> 00:16:05,490
the transfer process is fast there are

278
00:16:02,160 --> 00:16:08,610
delays which causes the target system to

279
00:16:05,490 --> 00:16:12,300
slow down because the time is wasted on

280
00:16:08,610 --> 00:16:16,740
sending something and the second

281
00:16:12,300 --> 00:16:19,519
drawback which actually forced me to

282
00:16:16,740 --> 00:16:24,990
switch my approach to something else was

283
00:16:19,519 --> 00:16:28,950
it wasn't stable I'm not sure about the

284
00:16:24,990 --> 00:16:31,800
real source of the problem of this of

285
00:16:28,950 --> 00:16:34,350
this one so I'm not going to elaborate

286
00:16:31,800 --> 00:16:37,140
on this because I was not really

287
00:16:34,350 --> 00:16:42,450
debugging why it fails it seemed to me

288
00:16:37,140 --> 00:16:51,180
like it's not 2 thread safe but still

289
00:16:42,450 --> 00:16:54,360
yeah it fails a lot so yeah the last

290
00:16:51,180 --> 00:16:58,199
point is all is also it is not thread

291
00:16:54,360 --> 00:17:00,870
safe in terms of we're disabling SM ap

292
00:16:58,200 --> 00:17:03,240
how we do that we turn off the SMA

293
00:17:00,870 --> 00:17:05,730
pbteen CR for register the CR for

294
00:17:03,240 --> 00:17:08,880
register is not a part of a thread

295
00:17:05,730 --> 00:17:13,199
context it's just a system control

296
00:17:08,880 --> 00:17:15,959
register it is set once and it's mostly

297
00:17:13,199 --> 00:17:19,319
not modified during the lifetime of the

298
00:17:15,959 --> 00:17:22,040
operating system so what might happen

299
00:17:19,319 --> 00:17:25,260
imagine I'm logging some thread I

300
00:17:22,040 --> 00:17:28,260
disable SM ap and then this window

301
00:17:25,260 --> 00:17:31,980
scheduler schedules the another thread

302
00:17:28,260 --> 00:17:35,190
and it is running with SM ap disabled so

303
00:17:31,980 --> 00:17:37,770
basically we're losing some events which

304
00:17:35,190 --> 00:17:40,040
are we're supposed to be tracking yeah

305
00:17:37,770 --> 00:17:43,590
because for every thread we assume that

306
00:17:40,040 --> 00:17:45,550
SM EP works but yeah it might happen

307
00:17:43,590 --> 00:17:48,399
that

308
00:17:45,550 --> 00:17:50,620
it might not be the case because of the

309
00:17:48,400 --> 00:17:53,140
scheduler so yeah let's come up with

310
00:17:50,620 --> 00:17:55,929
something else

311
00:17:53,140 --> 00:17:58,120
so the different approach would be also

312
00:17:55,930 --> 00:18:00,520
debug you're plugging but that would

313
00:17:58,120 --> 00:18:04,600
work in a little different way

314
00:18:00,520 --> 00:18:07,120
same as before we enable SM ap but this

315
00:18:04,600 --> 00:18:09,699
time we implement a custom page fault

316
00:18:07,120 --> 00:18:14,050
handler for the Windows operating system

317
00:18:09,700 --> 00:18:16,680
a custom debug trapa fault handler it

318
00:18:14,050 --> 00:18:19,120
just it is just called this way because

319
00:18:16,680 --> 00:18:22,660
if you look at install software

320
00:18:19,120 --> 00:18:27,189
development manual manual the interrupt

321
00:18:22,660 --> 00:18:29,710
vector one is it's called like debug

322
00:18:27,190 --> 00:18:32,530
trap or fault because it either can be a

323
00:18:29,710 --> 00:18:37,210
trap or a fault so it's it's just a

324
00:18:32,530 --> 00:18:39,879
matter of name and what we do so we've

325
00:18:37,210 --> 00:18:42,250
implemented the custom exception

326
00:18:39,880 --> 00:18:46,840
handlers and we patch system health

327
00:18:42,250 --> 00:18:52,890
handlers and then we go and then our

328
00:18:46,840 --> 00:18:54,520
payload does all the job and we have

329
00:18:52,890 --> 00:18:56,710
nothing to worry about

330
00:18:54,520 --> 00:19:02,050
and we just received the result into

331
00:18:56,710 --> 00:19:04,810
into our debugger yeah so the advantages

332
00:19:02,050 --> 00:19:09,370
the target operating system operates way

333
00:19:04,810 --> 00:19:11,980
faster why because we're not we're not

334
00:19:09,370 --> 00:19:13,929
catching any breakpoints like in

335
00:19:11,980 --> 00:19:17,500
previous scenario scenario we were

336
00:19:13,930 --> 00:19:20,560
setting breakpoints and so the

337
00:19:17,500 --> 00:19:23,410
breakpoint was hit again there's a

338
00:19:20,560 --> 00:19:29,080
latency in a kernel debugger transport

339
00:19:23,410 --> 00:19:33,070
which accumulates and while the debugger

340
00:19:29,080 --> 00:19:35,919
reacts to this breakpoint a time goes

341
00:19:33,070 --> 00:19:40,149
right so we're wasting our time on this

342
00:19:35,920 --> 00:19:42,370
latency so in this case it operates way

343
00:19:40,150 --> 00:19:45,280
fast faster because there are no

344
00:19:42,370 --> 00:19:50,679
breakpoints so nothing for a debugger to

345
00:19:45,280 --> 00:19:54,389
react on right and the second is the

346
00:19:50,680 --> 00:19:57,870
second point is we're patching the

347
00:19:54,390 --> 00:20:00,390
exception handlers which

348
00:19:57,870 --> 00:20:03,149
it's something you should not really do

349
00:20:00,390 --> 00:20:05,520
and Windows kernel agrees on that

350
00:20:03,150 --> 00:20:08,610
because there there is a special

351
00:20:05,520 --> 00:20:10,889
mechanism which is we all know and it's

352
00:20:08,610 --> 00:20:13,320
called the patch guard something that

353
00:20:10,890 --> 00:20:17,490
monitors the patches on Windows kernel

354
00:20:13,320 --> 00:20:19,740
and then if it finds that something was

355
00:20:17,490 --> 00:20:23,790
patched it just shows us blue screen

356
00:20:19,740 --> 00:20:28,080
with with the appropriate code right but

357
00:20:23,790 --> 00:20:31,020
since we're in a debugging mode when we

358
00:20:28,080 --> 00:20:34,679
debug operating system page guard does

359
00:20:31,020 --> 00:20:36,450
not work because think of it if we need

360
00:20:34,680 --> 00:20:39,030
to place a breakpoint we actually have

361
00:20:36,450 --> 00:20:42,450
to patch the memory right but if we

362
00:20:39,030 --> 00:20:46,170
patch the memory whoops we're all broken

363
00:20:42,450 --> 00:20:48,090
so the patch guard is disabled and it's

364
00:20:46,170 --> 00:20:51,240
pretty convenient and one in our case

365
00:20:48,090 --> 00:20:56,129
because we're using KD we're patching

366
00:20:51,240 --> 00:20:58,200
system exception handlers and we just

367
00:20:56,130 --> 00:20:58,860
don't care patch guard will not complain

368
00:20:58,200 --> 00:21:03,180
about it

369
00:20:58,860 --> 00:21:06,750
I think it's a good thing so about the

370
00:21:03,180 --> 00:21:11,610
drawbacks yeah it is still not the

371
00:21:06,750 --> 00:21:16,490
fastest way of execution because the way

372
00:21:11,610 --> 00:21:19,500
it is supposed to work is in our custom

373
00:21:16,490 --> 00:21:23,670
exception exception handler we're

374
00:21:19,500 --> 00:21:27,620
sending the information about the event

375
00:21:23,670 --> 00:21:31,410
to the debugger and here we go the

376
00:21:27,620 --> 00:21:33,080
kernel debugger protocol and transport

377
00:21:31,410 --> 00:21:38,070
latency shows up again

378
00:21:33,080 --> 00:21:40,770
so simply speaking with you the dbg

379
00:21:38,070 --> 00:21:42,629
print we call the DBT print function

380
00:21:40,770 --> 00:21:45,570
from Windows kernel from the target

381
00:21:42,630 --> 00:21:48,750
Windows kernel and it shows some message

382
00:21:45,570 --> 00:21:52,679
to the debugger and as it transfers this

383
00:21:48,750 --> 00:21:56,540
message to the debugger the time goes

384
00:21:52,680 --> 00:22:00,180
yeah because this process is not instant

385
00:21:56,540 --> 00:22:03,420
and we also require a kernel debugger

386
00:22:00,180 --> 00:22:06,720
which is I'm not really sure if it's a

387
00:22:03,420 --> 00:22:09,470
drawback because I don't know I I like

388
00:22:06,720 --> 00:22:09,470
kernel debugger

389
00:22:09,940 --> 00:22:21,710
so that leads to the last approach I was

390
00:22:18,200 --> 00:22:24,440
thinking of and it's basically the

391
00:22:21,710 --> 00:22:28,610
autonomous kernel-mode driver so we do

392
00:22:24,440 --> 00:22:31,220
all the same stuff we did in a previous

393
00:22:28,610 --> 00:22:34,008
approach but we don't use the kernel

394
00:22:31,220 --> 00:22:39,320
debugger we do this from the kernel

395
00:22:34,009 --> 00:22:42,590
module module right and the advantage is

396
00:22:39,320 --> 00:22:45,168
obvious it is maximum target operating

397
00:22:42,590 --> 00:22:47,720
system execution speed because we don't

398
00:22:45,169 --> 00:22:51,919
have to send anything to do to the

399
00:22:47,720 --> 00:22:56,240
debugger back and forth and yeah the

400
00:22:51,919 --> 00:22:59,659
logging is local and that's pretty

401
00:22:56,240 --> 00:23:01,429
pretty much it so we got all the

402
00:22:59,659 --> 00:23:09,289
advantages from the previous approach

403
00:23:01,429 --> 00:23:12,080
and we got the maximum speed but in this

404
00:23:09,289 --> 00:23:16,220
case there is no kernel debugger anymore

405
00:23:12,080 --> 00:23:19,220
that means that the purge car shows its

406
00:23:16,220 --> 00:23:21,950
face and tries to spoil the fun so in

407
00:23:19,220 --> 00:23:25,100
this case we would actually spend even

408
00:23:21,950 --> 00:23:30,230
more time taming the patch card like

409
00:23:25,100 --> 00:23:33,019
trying to disable it right so if you

410
00:23:30,230 --> 00:23:34,970
think of the code that would be

411
00:23:33,019 --> 00:23:38,389
necessary to implement this approach it

412
00:23:34,970 --> 00:23:41,889
would be I don't know like for example

413
00:23:38,389 --> 00:23:45,918
hundred lines of the plug-in payload and

414
00:23:41,889 --> 00:23:49,668
a thousand lines to disable approach

415
00:23:45,919 --> 00:23:55,749
card you know it's like not the exact

416
00:23:49,669 --> 00:23:58,389
numbers but just to get an idea so

417
00:23:55,749 --> 00:23:59,990
obviously I chose the second approach

418
00:23:58,389 --> 00:24:04,729
because your life

419
00:23:59,990 --> 00:24:07,450
I love curing all debuggers and so the

420
00:24:04,730 --> 00:24:10,129
goals were to implement a shell codes

421
00:24:07,450 --> 00:24:14,649
that means to implement the custom page

422
00:24:10,129 --> 00:24:18,980
fault and debug trapper fault handlers

423
00:24:14,649 --> 00:24:20,508
then I would have to locate the space in

424
00:24:18,980 --> 00:24:21,690
Windows kernel to place the shellcode

425
00:24:20,509 --> 00:24:23,820
since I'm

426
00:24:21,690 --> 00:24:26,460
operating in the debugger I cannot

427
00:24:23,820 --> 00:24:29,009
really allocate the target operating

428
00:24:26,460 --> 00:24:33,539
system memory I would have to find a

429
00:24:29,009 --> 00:24:37,889
place to to place the shell code inside

430
00:24:33,539 --> 00:24:40,110
the target Windows operating system then

431
00:24:37,889 --> 00:24:43,379
we load the shell code by that I mean

432
00:24:40,110 --> 00:24:47,519
just copy the shell code using the

433
00:24:43,379 --> 00:24:47,908
kernel debugger and patch the upper init

434
00:24:47,519 --> 00:24:51,210
system

435
00:24:47,909 --> 00:24:54,299
I DT entries I DT is like interrupt

436
00:24:51,210 --> 00:24:58,529
descriptor table this is the way you set

437
00:24:54,299 --> 00:25:05,250
the disk interrupt handlers on Intel

438
00:24:58,529 --> 00:25:08,279
platform okay and here goes the most

439
00:25:05,250 --> 00:25:11,610
interesting part how do we implement the

440
00:25:08,279 --> 00:25:15,149
custom page fault handler so as I said

441
00:25:11,610 --> 00:25:17,758
before when SM ap violation occurs a

442
00:25:15,149 --> 00:25:20,758
page fault is raised so that's why we

443
00:25:17,759 --> 00:25:23,460
actually need to implement the custom

444
00:25:20,759 --> 00:25:25,830
page page fault handler but why there is

445
00:25:23,460 --> 00:25:28,710
already a page fault handler in the

446
00:25:25,830 --> 00:25:32,820
operating system right yeah but Windows

447
00:25:28,710 --> 00:25:35,490
does not really use as I might be so it

448
00:25:32,820 --> 00:25:38,610
is not aware that we're actually going

449
00:25:35,490 --> 00:25:42,269
to use this feature so it would

450
00:25:38,610 --> 00:25:45,090
basically break the system execution at

451
00:25:42,269 --> 00:25:47,700
some point because yeah it is not

452
00:25:45,090 --> 00:25:51,720
supposed to catch SME B violation that's

453
00:25:47,700 --> 00:25:56,070
why when it's sort of a wrapper of for

454
00:25:51,720 --> 00:25:59,279
this page fault handler by that I mean

455
00:25:56,070 --> 00:26:02,158
we have our code that is supposed to

456
00:25:59,279 --> 00:26:07,200
decide whether it was an SM ap violation

457
00:26:02,159 --> 00:26:10,019
or not lock the data in case it was an

458
00:26:07,200 --> 00:26:12,929
SM ap violation and in case it was not

459
00:26:10,019 --> 00:26:15,480
we would just return to the original

460
00:26:12,929 --> 00:26:18,029
page fault handler because yeah I really

461
00:26:15,480 --> 00:26:20,129
don't want to implement the original

462
00:26:18,029 --> 00:26:24,629
page fault handler from scratch because

463
00:26:20,129 --> 00:26:28,769
it's kind of complicated thing and the

464
00:26:24,629 --> 00:26:32,580
algorithm is for sure check whether the

465
00:26:28,769 --> 00:26:35,490
page fault was indeed an SMP Smad

466
00:26:32,580 --> 00:26:40,350
violation and that is a

467
00:26:35,490 --> 00:26:42,679
by checking the error code of the page

468
00:26:40,350 --> 00:26:42,678
fault

469
00:26:42,740 --> 00:26:48,480
the I got like a couple of screenshots I

470
00:26:46,470 --> 00:26:53,100
will show you like at the next slide

471
00:26:48,480 --> 00:26:57,150
where those are allocated to check of

472
00:26:53,100 --> 00:27:01,260
course or whether the fault happened in

473
00:26:57,150 --> 00:27:03,660
the kernel space so it's pretty obvious

474
00:27:01,260 --> 00:27:07,920
because we're tracking the kernel mode

475
00:27:03,660 --> 00:27:10,050
references and check if CR to register

476
00:27:07,920 --> 00:27:13,410
is a user address CR to register is a

477
00:27:10,050 --> 00:27:14,100
register where the address of a page

478
00:27:13,410 --> 00:27:17,190
fault

479
00:27:14,100 --> 00:27:20,520
is kept so for example if there was a

480
00:27:17,190 --> 00:27:24,179
page fault trying to access a virtual

481
00:27:20,520 --> 00:27:27,389
address 1 2 3 a page fault happens and

482
00:27:24,179 --> 00:27:30,780
this register will keep the value of 1 2

483
00:27:27,390 --> 00:27:35,940
3 right so it's basically the way we

484
00:27:30,780 --> 00:27:39,629
found out what memory was referenced so

485
00:27:35,940 --> 00:27:43,550
the next step is to disable SM ap by

486
00:27:39,630 --> 00:27:48,510
setting the our Flex access check flag

487
00:27:43,550 --> 00:27:51,149
so as I said before there are two

488
00:27:48,510 --> 00:27:57,660
instructions like stack and clack which

489
00:27:51,150 --> 00:28:00,420
do this but it's like for obvious reason

490
00:27:57,660 --> 00:28:02,370
we cannot use those because we're in a

491
00:28:00,420 --> 00:28:08,460
different context when the page fault

492
00:28:02,370 --> 00:28:12,540
happens right so what we do is we take

493
00:28:08,460 --> 00:28:15,890
the threat that caused default and we

494
00:28:12,540 --> 00:28:20,670
modified the flags of it for it to

495
00:28:15,890 --> 00:28:25,440
suppress the SM ap violation as we

496
00:28:20,670 --> 00:28:27,660
resumed its execution then we log

497
00:28:25,440 --> 00:28:31,740
everything we need

498
00:28:27,660 --> 00:28:35,400
the saved array P as I said before it is

499
00:28:31,740 --> 00:28:39,929
on the stack this year to register is in

500
00:28:35,400 --> 00:28:42,900
CR to register we use our G TSE as a

501
00:28:39,929 --> 00:28:46,260
time stamp because it has like high

502
00:28:42,900 --> 00:28:48,690
precision enough to track the time

503
00:28:46,260 --> 00:28:53,029
window of double fat

504
00:28:48,690 --> 00:28:57,149
I mean double that two consecutive

505
00:28:53,029 --> 00:28:59,570
references to user mode memory and yeah

506
00:28:57,149 --> 00:29:02,399
actually we can lock there anything else

507
00:28:59,570 --> 00:29:04,549
because we're operating in the debugger

508
00:29:02,399 --> 00:29:08,488
we have the access to a symbolic

509
00:29:04,549 --> 00:29:13,049
information we can resolve any kernel

510
00:29:08,489 --> 00:29:16,229
variables so we can lock them right away

511
00:29:13,049 --> 00:29:18,929
with no problem yeah I should have put

512
00:29:16,229 --> 00:29:21,629
this this one into the advantages of the

513
00:29:18,929 --> 00:29:23,099
second approach yeah because we have the

514
00:29:21,629 --> 00:29:29,158
kernel debugger and we have all the

515
00:29:23,099 --> 00:29:33,090
symbols cool and yeah the next step is

516
00:29:29,159 --> 00:29:35,609
just basically to turn the hexadecimal

517
00:29:33,090 --> 00:29:38,820
representation of our information into a

518
00:29:35,609 --> 00:29:42,210
string because we have to show a string

519
00:29:38,820 --> 00:29:45,359
eventually to the debugger and since

520
00:29:42,210 --> 00:29:48,749
we're not we're operating outside of the

521
00:29:45,359 --> 00:29:51,539
debugger context we have to use the

522
00:29:48,749 --> 00:29:54,960
kernel mode function that are already

523
00:29:51,539 --> 00:29:58,559
there and for that I chose via Sprint

524
00:29:54,960 --> 00:30:00,659
which is there to format the string with

525
00:29:58,559 --> 00:30:05,129
the with the needed and information and

526
00:30:00,659 --> 00:30:09,090
then I'll just call the dbg print x

527
00:30:05,129 --> 00:30:15,899
function which prints data to the

528
00:30:09,090 --> 00:30:18,629
debugger so yeah then we set a trap flag

529
00:30:15,899 --> 00:30:21,599
for the threat that caused the SMI

530
00:30:18,629 --> 00:30:26,849
people a violation why because the idea

531
00:30:21,599 --> 00:30:30,450
is to get a single step so as I said

532
00:30:26,849 --> 00:30:34,049
before we have a piece of code that that

533
00:30:30,450 --> 00:30:37,109
triggers the SM ap violation okay we

534
00:30:34,049 --> 00:30:40,679
lock that one but how do we skip this

535
00:30:37,109 --> 00:30:45,749
and move on to to the next instruction

536
00:30:40,679 --> 00:30:49,559
we just temporarily disable the SMAP by

537
00:30:45,749 --> 00:30:53,249
doing this by setting AC flag and we

538
00:30:49,559 --> 00:30:57,779
also set the trap flag so the next time

539
00:30:53,249 --> 00:31:00,479
it will receive an execution quantum it

540
00:30:57,779 --> 00:31:06,239
would issue a single step

541
00:31:00,479 --> 00:31:08,849
exception and then yeah this one is most

542
00:31:06,239 --> 00:31:11,779
important I don't know if you I don't

543
00:31:08,849 --> 00:31:14,309
think you see it but it's basically an

544
00:31:11,779 --> 00:31:18,899
obvious step is to get out of a page

545
00:31:14,309 --> 00:31:20,639
fault handler right it's obvious yeah

546
00:31:18,899 --> 00:31:24,299
and this is the picture I was talking

547
00:31:20,639 --> 00:31:29,299
about because the devil the devil is in

548
00:31:24,299 --> 00:31:33,839
the details so this is a stack layout

549
00:31:29,299 --> 00:31:36,329
with privilege level change hmm but yeah

550
00:31:33,839 --> 00:31:40,799
it doesn't even matter if the privilege

551
00:31:36,329 --> 00:31:44,999
change was in place or not because the

552
00:31:40,799 --> 00:31:48,829
stack layout would be the same so we got

553
00:31:44,999 --> 00:31:53,009
the error code for the page fault and

554
00:31:48,829 --> 00:31:58,379
this is the error code encoding for the

555
00:31:53,009 --> 00:32:02,279
page fault the problem is there is no

556
00:31:58,379 --> 00:32:06,289
bit in here that would actually tell us

557
00:32:02,279 --> 00:32:12,979
that it was an SM ap violation like

558
00:32:06,289 --> 00:32:17,309
imagine the situation when for example a

559
00:32:12,979 --> 00:32:21,509
user mode a kernel mode threat was

560
00:32:17,309 --> 00:32:27,928
trying to write something into a user

561
00:32:21,509 --> 00:32:33,299
mode memory but this user mode memory

562
00:32:27,929 --> 00:32:36,599
was protected to be read-only and we're

563
00:32:33,299 --> 00:32:39,479
not really sure the page fault was

564
00:32:36,599 --> 00:32:43,708
because of the memory was read-only or

565
00:32:39,479 --> 00:32:46,440
because of SM IP violation those there's

566
00:32:43,709 --> 00:32:48,749
really no way to find out using the

567
00:32:46,440 --> 00:32:52,159
error code that's why I needed some

568
00:32:48,749 --> 00:32:55,289
additional checks like for example

569
00:32:52,159 --> 00:32:59,479
whether the faulting code with the

570
00:32:55,289 --> 00:33:03,450
kernel code whether defaulting address

571
00:32:59,479 --> 00:33:06,059
would be the user mode address but for

572
00:33:03,450 --> 00:33:09,509
this case which I described just just

573
00:33:06,059 --> 00:33:11,969
now it doesn't work as well so for some

574
00:33:09,509 --> 00:33:13,650
cases you have to actually stand extend

575
00:33:11,969 --> 00:33:16,590
the logic of your

576
00:33:13,650 --> 00:33:20,660
page fault handler for example in this

577
00:33:16,590 --> 00:33:24,389
case I have to check I have to page walk

578
00:33:20,660 --> 00:33:27,570
the target address and to see whether it

579
00:33:24,390 --> 00:33:31,170
was read only or it was not read only

580
00:33:27,570 --> 00:33:35,070
because if it was not read only then hmm

581
00:33:31,170 --> 00:33:39,810
probably it was an SM ap violation but

582
00:33:35,070 --> 00:33:43,590
yeah anyways it was a user mode it was a

583
00:33:39,810 --> 00:33:46,290
kernel to use a reference right so yeah

584
00:33:43,590 --> 00:33:47,879
I think I should log it but it doesn't

585
00:33:46,290 --> 00:33:51,000
really answer the question whether it

586
00:33:47,880 --> 00:33:53,850
was a double fetch vulnerability related

587
00:33:51,000 --> 00:33:59,510
case but still this is something you

588
00:33:53,850 --> 00:34:03,840
have to check manually after all and

589
00:33:59,510 --> 00:34:07,190
just for the references the array our IP

590
00:34:03,840 --> 00:34:10,650
which is like instruction pointer of

591
00:34:07,190 --> 00:34:14,210
which shows where the page fault

592
00:34:10,650 --> 00:34:17,300
happened is here as well on the stack

593
00:34:14,210 --> 00:34:21,510
there is also like a stack pointer but I

594
00:34:17,300 --> 00:34:25,020
don't really see why it might be useful

595
00:34:21,510 --> 00:34:27,330
but still it's there and this is the

596
00:34:25,020 --> 00:34:29,790
value of the flags register where about

597
00:34:27,330 --> 00:34:33,360
the patch in our custom page fault

598
00:34:29,790 --> 00:34:36,600
handler so when we do the I read queue

599
00:34:33,360 --> 00:34:37,650
instruction which is like resume from

600
00:34:36,600 --> 00:34:40,319
the interrupt

601
00:34:37,650 --> 00:34:43,620
we just restore this set of registers

602
00:34:40,320 --> 00:34:48,650
and and with this set of registers the

603
00:34:43,620 --> 00:34:52,580
fault in thread would resume right

604
00:34:48,650 --> 00:35:00,660
there's another thing if we remember the

605
00:34:52,580 --> 00:35:03,680
eflags register where's that the excess

606
00:35:00,660 --> 00:35:06,779
check alignment check access control

607
00:35:03,680 --> 00:35:10,379
there's interesting thing about this one

608
00:35:06,780 --> 00:35:17,660
I'm not really sure why until use this

609
00:35:10,380 --> 00:35:23,010
flag to use it like with SM ap feature

610
00:35:17,660 --> 00:35:26,609
because this bit in effects register has

611
00:35:23,010 --> 00:35:27,210
also a different meaning because you see

612
00:35:26,610 --> 00:35:30,740
it is

613
00:35:27,210 --> 00:35:34,680
called alignment check or access control

614
00:35:30,740 --> 00:35:39,299
so the way it operates it actually can

615
00:35:34,680 --> 00:35:43,440
issue the alignment check exceptions as

616
00:35:39,300 --> 00:35:46,170
well the way it works is if you operate

617
00:35:43,440 --> 00:35:50,790
in user mode this time you're in user

618
00:35:46,170 --> 00:35:54,570
mode and you set this flag when you try

619
00:35:50,790 --> 00:35:56,880
to access some structure on an unaligned

620
00:35:54,570 --> 00:36:01,070
address for example if your reference

621
00:35:56,880 --> 00:36:03,869
like the word like 4 bytes but it's not

622
00:36:01,070 --> 00:36:07,020
aligned to a 4 bytes the target address

623
00:36:03,869 --> 00:36:11,520
is not on line 4 for 4 bytes and access

624
00:36:07,020 --> 00:36:14,009
check not access checks alignment check

625
00:36:11,520 --> 00:36:16,589
violation would occur and the thing is

626
00:36:14,010 --> 00:36:20,220
Windows actually utilizes this feature

627
00:36:16,589 --> 00:36:24,320
so to enable this feature we also should

628
00:36:20,220 --> 00:36:28,379
modify this see our control register 0

629
00:36:24,320 --> 00:36:31,470
bits I don't remember which bit but

630
00:36:28,380 --> 00:36:35,400
still it is set on Windows so basically

631
00:36:31,470 --> 00:36:39,319
if we set the X alignment check or

632
00:36:35,400 --> 00:36:43,950
access control bit in flags it would

633
00:36:39,320 --> 00:36:46,890
issue the access check violation but

634
00:36:43,950 --> 00:36:49,470
yeah in our case it's not that of a

635
00:36:46,890 --> 00:36:51,930
problem since we're trying to find the

636
00:36:49,470 --> 00:36:54,390
kernel mode references and for kernel

637
00:36:51,930 --> 00:36:57,899
mode this thing doesn't work it works

638
00:36:54,390 --> 00:37:01,259
only if you're in user mode so it's kind

639
00:36:57,900 --> 00:37:05,220
of weird to me why two different

640
00:37:01,260 --> 00:37:06,300
meanings are used for the same bit in

641
00:37:05,220 --> 00:37:11,459
error flux

642
00:37:06,300 --> 00:37:14,609
error flags register and by the way

643
00:37:11,460 --> 00:37:21,150
here's the trap fault flag yeah I found

644
00:37:14,609 --> 00:37:22,380
you so we've set the trap flag because

645
00:37:21,150 --> 00:37:26,220
we need two single step before

646
00:37:22,380 --> 00:37:30,050
defaulting instruction and that is also

647
00:37:26,220 --> 00:37:33,299
the reason why we have to write our own

648
00:37:30,050 --> 00:37:37,290
custom debug or trap fault handler

649
00:37:33,300 --> 00:37:39,540
because if we don't do that we're

650
00:37:37,290 --> 00:37:40,620
operating in the debugger right so every

651
00:37:39,540 --> 00:37:43,710
time we set

652
00:37:40,620 --> 00:37:46,890
trap flag for you for the faulting trap

653
00:37:43,710 --> 00:37:48,210
it would break into the debugger and you

654
00:37:46,890 --> 00:37:50,759
would have to resume the execution

655
00:37:48,210 --> 00:37:52,710
manually every time which is by the way

656
00:37:50,760 --> 00:37:55,590
a nice feature if you want to track the

657
00:37:52,710 --> 00:37:58,470
references manually and I actually use

658
00:37:55,590 --> 00:38:00,810
that like a couple of times but if you

659
00:37:58,470 --> 00:38:03,350
want to automate this you need a way to

660
00:38:00,810 --> 00:38:06,660
actually resume the execution

661
00:38:03,350 --> 00:38:12,110
automatically and that's why we actually

662
00:38:06,660 --> 00:38:17,069
do this so basically we reset the trap

663
00:38:12,110 --> 00:38:19,380
trap flag in the air flux so the next so

664
00:38:17,070 --> 00:38:21,780
then the following execution of the trap

665
00:38:19,380 --> 00:38:27,420
will not issue the single snap exception

666
00:38:21,780 --> 00:38:31,050
which is cool and we enables SMA be back

667
00:38:27,420 --> 00:38:34,290
because we have disabled sa SMA P in the

668
00:38:31,050 --> 00:38:36,930
page fault handler right so we have to

669
00:38:34,290 --> 00:38:40,970
like disable it single step and enable

670
00:38:36,930 --> 00:38:48,529
again and this is how we do it basically

671
00:38:40,970 --> 00:38:51,779
and yeah a little detail for the debug

672
00:38:48,530 --> 00:38:54,510
trapper full handler in the first

673
00:38:51,780 --> 00:38:59,310
version I was like yeah whatever I will

674
00:38:54,510 --> 00:39:02,970
just patch it away like the whole debug

675
00:38:59,310 --> 00:39:06,480
trapper full handler so it would resume

676
00:39:02,970 --> 00:39:08,520
automatically all the time but then it

677
00:39:06,480 --> 00:39:10,680
was a problem for me because I needed to

678
00:39:08,520 --> 00:39:12,360
trace the different places of code in

679
00:39:10,680 --> 00:39:14,940
the kernel and when I tried to

680
00:39:12,360 --> 00:39:17,400
single-step something it just and it

681
00:39:14,940 --> 00:39:19,650
skipped because yeah I enabled this

682
00:39:17,400 --> 00:39:22,590
single I disabled the single step

683
00:39:19,650 --> 00:39:24,900
automatically so I was like yeah I need

684
00:39:22,590 --> 00:39:28,170
a way to actually find out whether I

685
00:39:24,900 --> 00:39:34,620
need to resume or I don't need to resume

686
00:39:28,170 --> 00:39:38,210
and that's where the airlock registers

687
00:39:34,620 --> 00:39:42,020
saved my day again because I don't know

688
00:39:38,210 --> 00:39:44,760
in advance where I when I'm supposed to

689
00:39:42,020 --> 00:39:48,300
resume execution

690
00:39:44,760 --> 00:39:50,190
because it was an SM ap related stuff or

691
00:39:48,300 --> 00:39:51,660
it was something else like single step

692
00:39:50,190 --> 00:39:54,150
in the debugger I don't know in advance

693
00:39:51,660 --> 00:39:57,118
right so I

694
00:39:54,150 --> 00:40:00,930
cheated because I remembered I have a

695
00:39:57,119 --> 00:40:04,200
spare bit in the air flex register and

696
00:40:00,930 --> 00:40:09,538
it's identification flag which is cool

697
00:40:04,200 --> 00:40:12,029
this this one is used to define out

698
00:40:09,539 --> 00:40:15,029
whether your CPU supports the CPUID

699
00:40:12,029 --> 00:40:18,960
instruction so if you're able to modify

700
00:40:15,029 --> 00:40:21,319
this flag cool your processor is new

701
00:40:18,960 --> 00:40:25,559
enough to support the CPUID instruction

702
00:40:21,319 --> 00:40:28,109
which means it's like 20 years old but

703
00:40:25,559 --> 00:40:29,609
still I use this flag for a different

704
00:40:28,109 --> 00:40:32,279
purpose

705
00:40:29,609 --> 00:40:36,029
I use it to distinguish whether it was

706
00:40:32,279 --> 00:40:40,559
my fault or someone else so basically in

707
00:40:36,029 --> 00:40:43,799
a page fault handler I said this bit to

708
00:40:40,559 --> 00:40:47,490
disable SMI P this bit to enable single

709
00:40:43,799 --> 00:40:49,559
stepping and this bit to tell my custom

710
00:40:47,490 --> 00:40:51,359
debug or trap fault handler that it was

711
00:40:49,559 --> 00:40:53,309
me and you should resume this one

712
00:40:51,359 --> 00:40:56,250
automatically yeah

713
00:40:53,309 --> 00:41:00,240
and that actually made this made a trick

714
00:40:56,250 --> 00:41:02,309
and it worked and I was happy yeah and I

715
00:41:00,240 --> 00:41:06,589
found something but I cannot tell about

716
00:41:02,309 --> 00:41:10,680
this and about locating the space for

717
00:41:06,589 --> 00:41:12,960
for our payloads the problem is as I

718
00:41:10,680 --> 00:41:15,720
said before we cannot actually allocate

719
00:41:12,960 --> 00:41:17,730
memory in the debugger we're out of

720
00:41:15,720 --> 00:41:21,558
context of the target operating system

721
00:41:17,730 --> 00:41:24,990
so I was like hmm I'm gonna use

722
00:41:21,559 --> 00:41:29,670
something that is already there and I

723
00:41:24,990 --> 00:41:32,490
like this one the user shared page so

724
00:41:29,670 --> 00:41:35,010
this is the one that is mapped to on

725
00:41:32,490 --> 00:41:39,058
every process on Windows and it keeps

726
00:41:35,010 --> 00:41:42,779
some auxilary stuff like like what like

727
00:41:39,059 --> 00:41:45,390
system time interrupt I'm no pointers

728
00:41:42,779 --> 00:41:48,359
unfortunately that would leak the kernel

729
00:41:45,390 --> 00:41:51,828
mode layout but yeah just auxiliary data

730
00:41:48,359 --> 00:41:55,440
and it's a page so it's like 4k in size

731
00:41:51,829 --> 00:41:59,069
but the structure with all this

732
00:41:55,440 --> 00:42:02,579
information is a lot less it only

733
00:41:59,069 --> 00:42:05,130
occupies the half of the page so Wow I

734
00:42:02,579 --> 00:42:07,640
have the whole another half of a page to

735
00:42:05,130 --> 00:42:12,140
do all the to do all the stuff

736
00:42:07,640 --> 00:42:16,020
and it is located at a fixed address

737
00:42:12,140 --> 00:42:19,020
it doesn't care about KS LR but that's

738
00:42:16,020 --> 00:42:21,780
not a big deal because there are no car

739
00:42:19,020 --> 00:42:25,470
normal pointers or any sensitive data so

740
00:42:21,780 --> 00:42:30,329
which is also cool and it will not be

741
00:42:25,470 --> 00:42:32,750
reused it is just used for only this

742
00:42:30,329 --> 00:42:35,549
like only storing this auxiliary data

743
00:42:32,750 --> 00:42:38,609
what I mean by this will not be reused

744
00:42:35,549 --> 00:42:41,460
is if I if I take some

745
00:42:38,609 --> 00:42:44,970
I don't know pool allocation I would not

746
00:42:41,460 --> 00:42:47,579
have control over it because as the

747
00:42:44,970 --> 00:42:49,740
operating system executes someone would

748
00:42:47,579 --> 00:42:51,599
I don't know decide to free this

749
00:42:49,740 --> 00:42:52,288
allocation and then we used for

750
00:42:51,599 --> 00:42:54,240
something else

751
00:42:52,289 --> 00:42:56,839
it would overwrite my coat and you got

752
00:42:54,240 --> 00:43:02,848
the idea right so I need something more

753
00:42:56,839 --> 00:43:06,359
reliable but since it's a data page it

754
00:43:02,849 --> 00:43:08,430
is not executable but it is not the

755
00:43:06,359 --> 00:43:10,589
problem as well since I have a kernel

756
00:43:08,430 --> 00:43:14,308
debugger so what I do is I page page

757
00:43:10,589 --> 00:43:17,369
rocket and I reset the executive able

758
00:43:14,309 --> 00:43:21,420
bit in the page table entry and that how

759
00:43:17,369 --> 00:43:24,930
it becomes executable as I said before

760
00:43:21,420 --> 00:43:27,740
it is mapped in every Windows process

761
00:43:24,930 --> 00:43:31,288
but it is mapped in a different way so

762
00:43:27,740 --> 00:43:34,589
it is like one page but it has different

763
00:43:31,289 --> 00:43:38,190
mappings one is for kernel mode which I

764
00:43:34,589 --> 00:43:40,589
make executable and the other one is the

765
00:43:38,190 --> 00:43:42,690
user mode yeah it might be stupid to

766
00:43:40,589 --> 00:43:44,970
talk about security in this case since I

767
00:43:42,690 --> 00:43:47,450
patch everything out but still for a

768
00:43:44,970 --> 00:43:51,538
user mode mapping it will still remain

769
00:43:47,450 --> 00:43:55,529
not executable and this is an excuse for

770
00:43:51,539 --> 00:43:59,099
me so we just load our code there our

771
00:43:55,529 --> 00:44:03,210
caste custom exception handlers and we

772
00:43:59,099 --> 00:44:08,789
store our data there so yeah it worked

773
00:44:03,210 --> 00:44:13,020
out eventually and yeah one thing about

774
00:44:08,789 --> 00:44:15,839
this page so while I was developing this

775
00:44:13,020 --> 00:44:18,660
one I thought like hey wait a minute

776
00:44:15,839 --> 00:44:20,150
it is mapped in every user mode process

777
00:44:18,660 --> 00:44:25,129
so

778
00:44:20,150 --> 00:44:29,720
what I can do is actually not to send

779
00:44:25,130 --> 00:44:32,210
the collected data to the debugger but

780
00:44:29,720 --> 00:44:35,240
the different process like in a

781
00:44:32,210 --> 00:44:38,870
different threat might be monitoring

782
00:44:35,240 --> 00:44:41,270
this area you got the idea so since we

783
00:44:38,870 --> 00:44:44,859
store the data before sending to the

784
00:44:41,270 --> 00:44:47,810
debugger in this user user shared page

785
00:44:44,860 --> 00:44:50,150
we can as well monitor it from the user

786
00:44:47,810 --> 00:44:52,340
mode on a target system that would

787
00:44:50,150 --> 00:44:55,040
increase speed but yeah it would lose

788
00:44:52,340 --> 00:44:58,070
some events because we cannot really

789
00:44:55,040 --> 00:44:59,779
monitor this at the same rate that we

790
00:44:58,070 --> 00:45:04,250
would lock the data any we would

791
00:44:59,780 --> 00:45:06,560
definitely not get the double fetch

792
00:45:04,250 --> 00:45:09,560
related events because they are so close

793
00:45:06,560 --> 00:45:11,750
to each other we would like we have to

794
00:45:09,560 --> 00:45:16,370
win the race somehow I don't know even

795
00:45:11,750 --> 00:45:20,120
how so yeah but it's also an idea if you

796
00:45:16,370 --> 00:45:22,339
need to track just references from your

797
00:45:20,120 --> 00:45:26,900
target driver to the user mode structure

798
00:45:22,340 --> 00:45:29,660
yeah that would work but yeah still I

799
00:45:26,900 --> 00:45:36,050
use the log into the kernel Multi bugger

800
00:45:29,660 --> 00:45:37,970
and what I did is different modes of

801
00:45:36,050 --> 00:45:40,730
execution first of all it's just

802
00:45:37,970 --> 00:45:44,480
automatic mode it just loves everything

803
00:45:40,730 --> 00:45:47,270
and it puts it into the debugger the

804
00:45:44,480 --> 00:45:50,270
manual mode as I said before I did so as

805
00:45:47,270 --> 00:45:52,370
I said before I we can we can skip

806
00:45:50,270 --> 00:45:55,220
patching the debug trap of hole Handler

807
00:45:52,370 --> 00:45:59,120
and this in this case we get the manual

808
00:45:55,220 --> 00:46:01,189
way of tracking the references and and

809
00:45:59,120 --> 00:46:04,670
in this case you don't even have to look

810
00:46:01,190 --> 00:46:08,180
up the output data because your debugger

811
00:46:04,670 --> 00:46:10,510
just breaks in to the place where the SM

812
00:46:08,180 --> 00:46:14,770
ap violation happens and you can like

813
00:46:10,510 --> 00:46:21,050
explore from there because imagine this

814
00:46:14,770 --> 00:46:28,400
you actually I will say just a couple of

815
00:46:21,050 --> 00:46:30,830
slides so the manual mode yeah and we

816
00:46:28,400 --> 00:46:33,800
have a target module filtering that

817
00:46:30,830 --> 00:46:35,990
means that I do not log everything

818
00:46:33,800 --> 00:46:39,140
I locked just a specific driver I

819
00:46:35,990 --> 00:46:41,209
defined the range the address range of

820
00:46:39,140 --> 00:46:44,210
my target driver and I just filled it

821
00:46:41,210 --> 00:46:47,000
out in my custom page fault handler

822
00:46:44,210 --> 00:46:51,980
which means it works fast which is

823
00:46:47,000 --> 00:46:53,900
called from my case and yeah I wanted to

824
00:46:51,980 --> 00:46:57,830
show this screenshot

825
00:46:53,900 --> 00:47:00,590
it's a windbg output you see it's not

826
00:46:57,830 --> 00:47:03,410
really like human readable you have to

827
00:47:00,590 --> 00:47:08,480
know like what those numbers mean

828
00:47:03,410 --> 00:47:12,589
because the problem is I have the half

829
00:47:08,480 --> 00:47:16,460
of user mode user shared page the half

830
00:47:12,590 --> 00:47:19,220
but it's still not a lot so I cannot do

831
00:47:16,460 --> 00:47:21,440
the huge pretty string in there because

832
00:47:19,220 --> 00:47:25,430
I have a very limited amount of space

833
00:47:21,440 --> 00:47:28,280
that's why I just like do the output for

834
00:47:25,430 --> 00:47:31,790
this for hexadecimal values and and

835
00:47:28,280 --> 00:47:36,110
that's pretty much it and in this case

836
00:47:31,790 --> 00:47:38,810
you have to post process this data so

837
00:47:36,110 --> 00:47:41,150
you have like the reference to user mode

838
00:47:38,810 --> 00:47:44,420
address the kernel code that actually

839
00:47:41,150 --> 00:47:46,550
attached touched it the Arditi st valley

840
00:47:44,420 --> 00:47:49,340
and the XS whether it was writable

841
00:47:46,550 --> 00:47:53,060
whether it was a write access or a read

842
00:47:49,340 --> 00:47:58,690
access so what you need to do then is to

843
00:47:53,060 --> 00:48:01,730
match those addresses to the actual

844
00:47:58,690 --> 00:48:03,860
points in the cold so for example if we

845
00:48:01,730 --> 00:48:06,740
have like defaulting air IP we would

846
00:48:03,860 --> 00:48:08,360
have to look up the symbol to know the

847
00:48:06,740 --> 00:48:11,600
exact function that caused the violation

848
00:48:08,360 --> 00:48:15,050
right and for here we also have to match

849
00:48:11,600 --> 00:48:17,420
it to some structure user mode to get an

850
00:48:15,050 --> 00:48:19,250
idea what we were referencing but yeah

851
00:48:17,420 --> 00:48:21,470
in the manual mode we have an advantage

852
00:48:19,250 --> 00:48:23,840
because the debugger does everything for

853
00:48:21,470 --> 00:48:26,779
us it would just break in in the put in

854
00:48:23,840 --> 00:48:28,910
a point of a violation and it would

855
00:48:26,780 --> 00:48:32,000
resolve all the addresses automatically

856
00:48:28,910 --> 00:48:35,330
so you just like look at it oh yeah it

857
00:48:32,000 --> 00:48:37,610
was an in Foley yeah which is I didn't

858
00:48:35,330 --> 00:48:40,430
even say but it also can be used for

859
00:48:37,610 --> 00:48:42,620
info leaks because when kernel mode

860
00:48:40,430 --> 00:48:45,770
driver puts something into a user mode

861
00:48:42,620 --> 00:48:47,529
memory yeah it might be an info Lake and

862
00:48:45,770 --> 00:48:51,150
it happens a lot

863
00:48:47,530 --> 00:48:55,390
so yeah it's a cool feature after all

864
00:48:51,150 --> 00:48:57,910
basically yeah and that's pretty much it

865
00:48:55,390 --> 00:49:04,359
about it so if you have any questions

866
00:48:57,910 --> 00:49:06,000
you are welcome to ask them now Smyly

867
00:49:04,360 --> 00:49:10,070
rodrigo face

868
00:49:06,000 --> 00:49:10,070
[Applause]

