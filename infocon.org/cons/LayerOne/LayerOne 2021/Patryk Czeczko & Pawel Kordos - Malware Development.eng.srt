1
00:00:01,120 --> 00:00:03,040
hello guys welcome to our today's talk

2
00:00:03,040 --> 00:00:04,560
regarding halloween development for

3
00:00:04,560 --> 00:00:05,759
advanced adversary

4
00:00:05,759 --> 00:00:08,720
emulation and my name is pablo cordos

5
00:00:08,720 --> 00:00:09,760
and today with my

6
00:00:09,760 --> 00:00:12,160
uh friend patrick we'll try to introduce

7
00:00:12,160 --> 00:00:12,960
you uh

8
00:00:12,960 --> 00:00:15,679
into a world of marvel development i

9
00:00:15,679 --> 00:00:16,079
work

10
00:00:16,079 --> 00:00:18,560
as a penetration tester also as a red

11
00:00:18,560 --> 00:00:19,359
teamer

12
00:00:19,359 --> 00:00:22,320
uh patrick one away from you hello

13
00:00:22,320 --> 00:00:23,439
everyone so

14
00:00:23,439 --> 00:00:25,760
my name is patrick chetko i work as a

15
00:00:25,760 --> 00:00:28,320
technical director in a purple team

16
00:00:28,320 --> 00:00:31,519
in a global bank and previously i worked

17
00:00:31,519 --> 00:00:32,000
with

18
00:00:32,000 --> 00:00:35,200
pavel in a big four company

19
00:00:35,200 --> 00:00:37,920
yeah yeah so actually we have we've been

20
00:00:37,920 --> 00:00:39,840
working together for a couple of years

21
00:00:39,840 --> 00:00:41,440
and during this time we've

22
00:00:41,440 --> 00:00:43,680
performed hundreds of engagements during

23
00:00:43,680 --> 00:00:45,440
which we engage some knowledge we'd like

24
00:00:45,440 --> 00:00:46,640
to show you today

25
00:00:46,640 --> 00:00:48,239
and i think it will be used for doing

26
00:00:48,239 --> 00:00:50,320
both red teaming and maybe purple team

27
00:00:50,320 --> 00:00:52,800
activities depends on what we are doing

28
00:00:52,800 --> 00:00:54,399
and also if you are a part of a blue

29
00:00:54,399 --> 00:00:56,079
team i think it's great to

30
00:00:56,079 --> 00:00:57,920
know how actually malware works because

31
00:00:57,920 --> 00:00:59,280
this may actually

32
00:00:59,280 --> 00:01:01,680
really expand your knowledge regarding

33
00:01:01,680 --> 00:01:02,480
the attacker's

34
00:01:02,480 --> 00:01:05,199
technique all right so let's start from

35
00:01:05,199 --> 00:01:05,760
the

36
00:01:05,760 --> 00:01:08,240
beginning today we will talk about a few

37
00:01:08,240 --> 00:01:09,840
different uh different

38
00:01:09,840 --> 00:01:12,159
aspects so first we'll start from

39
00:01:12,159 --> 00:01:14,080
malware preventions and detections

40
00:01:14,080 --> 00:01:16,000
understand how actually antivirus and

41
00:01:16,000 --> 00:01:18,479
idios works this is crucial to a proper

42
00:01:18,479 --> 00:01:19,759
narrow development because without

43
00:01:19,759 --> 00:01:22,159
knowing that you actually you don't know

44
00:01:22,159 --> 00:01:25,840
who are you what were you dealing with

45
00:01:25,840 --> 00:01:26,320
and

46
00:01:26,320 --> 00:01:28,320
we'll try to understand how malware

47
00:01:28,320 --> 00:01:29,600
analysis analysis

48
00:01:29,600 --> 00:01:33,040
is performed then uh patrick will uh

49
00:01:33,040 --> 00:01:35,280
tell more about malware delivery how

50
00:01:35,280 --> 00:01:36,400
mango is delivered

51
00:01:36,400 --> 00:01:39,119
then covers local architecture overview

52
00:01:39,119 --> 00:01:39,680
and

53
00:01:39,680 --> 00:01:42,799
and some malicious loader

54
00:01:42,799 --> 00:01:45,600
things like bypassing static iocs

55
00:01:45,600 --> 00:01:46,720
antivirus

56
00:01:46,720 --> 00:01:49,119
and some box evasion and some kind of

57
00:01:49,119 --> 00:01:50,159
obfuscation

58
00:01:50,159 --> 00:01:53,439
techniques hope you'll find that useful

59
00:01:53,439 --> 00:01:56,960
and maybe we can begin

60
00:01:56,960 --> 00:01:59,840
all right so the first part is to

61
00:01:59,840 --> 00:02:00,479
understand

62
00:02:00,479 --> 00:02:03,520
who are actually who is or what is

63
00:02:03,520 --> 00:02:06,159
the antivirus and how they actually work

64
00:02:06,159 --> 00:02:06,719
so

65
00:02:06,719 --> 00:02:09,280
there are a couple of different ways how

66
00:02:09,280 --> 00:02:10,800
actually antivirus solution

67
00:02:10,800 --> 00:02:13,520
works and the first one is the this very

68
00:02:13,520 --> 00:02:15,599
simple the signature based detection

69
00:02:15,599 --> 00:02:19,599
which actually check your file and uh

70
00:02:19,599 --> 00:02:22,879
your things versus a list of known

71
00:02:22,879 --> 00:02:25,840
uh files which they are known for being

72
00:02:25,840 --> 00:02:27,840
malicious this is a very trivial one

73
00:02:27,840 --> 00:02:30,800
uh also this signature based interaction

74
00:02:30,800 --> 00:02:32,560
consists of

75
00:02:32,560 --> 00:02:34,720
known strings detection like malicious

76
00:02:34,720 --> 00:02:36,640
strings within your application

77
00:02:36,640 --> 00:02:38,959
and no byte sequences this is very

78
00:02:38,959 --> 00:02:39,840
travel to

79
00:02:39,840 --> 00:02:42,800
uh to perform by antivirus solutions but

80
00:02:42,800 --> 00:02:43,040
if

81
00:02:43,040 --> 00:02:44,800
if something is really trivial to detect

82
00:02:44,800 --> 00:02:46,800
probably something will be

83
00:02:46,800 --> 00:02:49,599
very trivial to actually full the

84
00:02:49,599 --> 00:02:50,560
antivirus solution

85
00:02:50,560 --> 00:02:53,360
which we'll show you in a few minutes

86
00:02:53,360 --> 00:02:54,239
then we got

87
00:02:54,239 --> 00:02:55,840
something a little smarter this is

88
00:02:55,840 --> 00:02:57,440
called heuristic detection

89
00:02:57,440 --> 00:02:59,920
and this actually performs a static

90
00:02:59,920 --> 00:03:00,720
analysis

91
00:03:00,720 --> 00:03:03,440
of the application behavior and i

92
00:03:03,440 --> 00:03:04,159
identify

93
00:03:04,159 --> 00:03:06,319
potentially molesting malicious

94
00:03:06,319 --> 00:03:07,920
characteristic characteristics

95
00:03:07,920 --> 00:03:10,640
and functions within this application

96
00:03:10,640 --> 00:03:11,440
those

97
00:03:11,440 --> 00:03:14,640
those two things are like the base for

98
00:03:14,640 --> 00:03:17,680
most of the antivirus solutions and

99
00:03:17,680 --> 00:03:20,720
something more dynamic one is

100
00:03:20,720 --> 00:03:23,599
sandboxing uh we this actually applies

101
00:03:23,599 --> 00:03:23,840
to

102
00:03:23,840 --> 00:03:26,480
most solutions there's a sandbox

103
00:03:26,480 --> 00:03:27,599
environment

104
00:03:27,599 --> 00:03:31,440
which provides you

105
00:03:31,440 --> 00:03:33,760
control controlled environment for for

106
00:03:33,760 --> 00:03:35,120
the antivirus to

107
00:03:35,120 --> 00:03:38,159
actually launch the file

108
00:03:38,159 --> 00:03:40,080
and actually execute it monitor the

109
00:03:40,080 --> 00:03:41,280
actions and

110
00:03:41,280 --> 00:03:44,480
uh by doing that it can actually observe

111
00:03:44,480 --> 00:03:46,000
the application's behavior

112
00:03:46,000 --> 00:03:48,159
and it's very useful to know to

113
00:03:48,159 --> 00:03:49,760
understand that and

114
00:03:49,760 --> 00:03:52,720
if you know and understand how this what

115
00:03:52,720 --> 00:03:54,799
are the artifacts for this sandbox you

116
00:03:54,799 --> 00:03:56,080
probably will be able

117
00:03:56,080 --> 00:03:58,959
to skip that and there are also edr

118
00:03:58,959 --> 00:04:00,720
specific patrick right

119
00:04:00,720 --> 00:04:03,599
yes sure so in the era of handball

120
00:04:03,599 --> 00:04:04,879
detection and response

121
00:04:04,879 --> 00:04:07,920
we get uh more and more for example

122
00:04:07,920 --> 00:04:09,760
function hooking so

123
00:04:09,760 --> 00:04:12,319
that's some some clever technique used

124
00:04:12,319 --> 00:04:14,799
by defensive solutions to

125
00:04:14,799 --> 00:04:17,839
trick malware but we can bypass that and

126
00:04:17,839 --> 00:04:21,839
there's also memory scanning performed

127
00:04:21,839 --> 00:04:24,960
here and then but

128
00:04:24,960 --> 00:04:27,120
it's more difficult to bypass but but

129
00:04:27,120 --> 00:04:28,320
still possible to

130
00:04:28,320 --> 00:04:31,120
to do something about that from malware

131
00:04:31,120 --> 00:04:33,600
developers perspective

132
00:04:33,600 --> 00:04:36,080
all right and so how this malware

133
00:04:36,080 --> 00:04:36,720
analysis

134
00:04:36,720 --> 00:04:39,520
is performed first there we got a as

135
00:04:39,520 --> 00:04:40,000
before

136
00:04:40,000 --> 00:04:42,080
uh told the static analysis those are

137
00:04:42,080 --> 00:04:44,400
the informations also included in the

138
00:04:44,400 --> 00:04:47,120
uh in the pe file uh source code

139
00:04:47,120 --> 00:04:48,000
recovery

140
00:04:48,000 --> 00:04:49,919
and source code analysis this is

141
00:04:49,919 --> 00:04:51,280
relatively easy to perform

142
00:04:51,280 --> 00:04:53,759
uh also for a marvel analysis because

143
00:04:53,759 --> 00:04:55,199
keep in mind that

144
00:04:55,199 --> 00:04:57,440
on the on on one hand you are facing

145
00:04:57,440 --> 00:04:58,560
some kind of

146
00:04:58,560 --> 00:05:02,080
uh fancy anterior solutions but also

147
00:05:02,080 --> 00:05:04,800
there are some our analysis analysis

148
00:05:04,800 --> 00:05:06,000
which probably

149
00:05:06,000 --> 00:05:08,800
will be taking a closer look in uh into

150
00:05:08,800 --> 00:05:12,160
our file and we definitely don't want to

151
00:05:12,160 --> 00:05:15,600
uh like make your job easier

152
00:05:15,600 --> 00:05:18,479
and eventually have our solution flagged

153
00:05:18,479 --> 00:05:19,039
so

154
00:05:19,039 --> 00:05:20,800
don't forget about it and there are some

155
00:05:20,800 --> 00:05:22,880
couple of uh

156
00:05:22,880 --> 00:05:25,440
dedicated techniques also to uh to make

157
00:05:25,440 --> 00:05:27,039
their life a little harder

158
00:05:27,039 --> 00:05:29,120
all right static analysis is one thing

159
00:05:29,120 --> 00:05:31,520
then we got this dynamic analysis

160
00:05:31,520 --> 00:05:34,639
which consists of this execution flow

161
00:05:34,639 --> 00:05:35,280
analysis

162
00:05:35,280 --> 00:05:38,320
monitoring and tracking system api calls

163
00:05:38,320 --> 00:05:41,759
uh some kind of file system and

164
00:05:41,759 --> 00:05:44,560
registry changes this also applies to a

165
00:05:44,560 --> 00:05:45,600
network traffic

166
00:05:45,600 --> 00:05:50,160
because this one is also this is also

167
00:05:50,160 --> 00:05:54,000
performed lastly we got a debugging

168
00:05:54,000 --> 00:05:56,720
which consists of step by step execution

169
00:05:56,720 --> 00:05:58,000
and

170
00:05:58,000 --> 00:06:02,639
modifying the program and at the runtime

171
00:06:02,639 --> 00:06:05,520
all right so very basic one about the

172
00:06:05,520 --> 00:06:06,560
antivirus solution

173
00:06:06,560 --> 00:06:09,199
but the very first uh very first step in

174
00:06:09,199 --> 00:06:10,479
each exploitation

175
00:06:10,479 --> 00:06:13,680
and in uh each uh malware creation

176
00:06:13,680 --> 00:06:14,240
aftermath

177
00:06:14,240 --> 00:06:16,240
creation is actually the delivery now

178
00:06:16,240 --> 00:06:18,160
these are very crucial step because the

179
00:06:18,160 --> 00:06:20,560
has to be somehow on our victim machine

180
00:06:20,560 --> 00:06:21,199
right

181
00:06:21,199 --> 00:06:23,520
sure so that's the first step of of

182
00:06:23,520 --> 00:06:25,199
delivering

183
00:06:25,199 --> 00:06:27,039
first step of the kill chain is actually

184
00:06:27,039 --> 00:06:29,360
the delivery of of some malicious file

185
00:06:29,360 --> 00:06:31,440
and

186
00:06:31,440 --> 00:06:33,840
we like to to develop stuff in c because

187
00:06:33,840 --> 00:06:34,639
it's

188
00:06:34,639 --> 00:06:36,560
more difficult to reverse engineer

189
00:06:36,560 --> 00:06:38,000
engineer by an analyst and

190
00:06:38,000 --> 00:06:41,360
also gives like direct access to

191
00:06:41,360 --> 00:06:43,759
the windows api and all the functions

192
00:06:43,759 --> 00:06:45,039
but

193
00:06:45,039 --> 00:06:48,080
there are some some ways to to deliver

194
00:06:48,080 --> 00:06:50,560
this code and and then execute this so

195
00:06:50,560 --> 00:06:52,560
the most popular

196
00:06:52,560 --> 00:06:56,160
stuff is is still since

197
00:06:56,160 --> 00:06:59,360
20 years ago i think or more in office

198
00:06:59,360 --> 00:07:02,240
and visual basic for applications so vba

199
00:07:02,240 --> 00:07:03,759
markers but there are

200
00:07:03,759 --> 00:07:06,400
also a lot of other techniques to to

201
00:07:06,400 --> 00:07:08,319
execute some malicious stuff from from

202
00:07:08,319 --> 00:07:10,080
office documents like

203
00:07:10,080 --> 00:07:13,520
old extra four macros dynamic data

204
00:07:13,520 --> 00:07:15,039
exchange

205
00:07:15,039 --> 00:07:18,479
symbolic links is all called silk files

206
00:07:18,479 --> 00:07:22,080
xll it's some actual feature uh

207
00:07:22,080 --> 00:07:25,440
also can be used for for code execution

208
00:07:25,440 --> 00:07:27,759
object link in linking and embedding so

209
00:07:27,759 --> 00:07:29,120
we can

210
00:07:29,120 --> 00:07:31,919
embed some some objects into the

211
00:07:31,919 --> 00:07:32,960
documents

212
00:07:32,960 --> 00:07:36,560
and also there's some cool trick with

213
00:07:36,560 --> 00:07:39,360
with mouse over event in powerpoint so

214
00:07:39,360 --> 00:07:42,160
this can be also used to execute stuff

215
00:07:42,160 --> 00:07:45,919
and another typical malicious document

216
00:07:45,919 --> 00:07:49,520
is html application called hta in short

217
00:07:49,520 --> 00:07:52,560
and this can be used to

218
00:07:52,560 --> 00:07:55,680
run either visual basic script or or

219
00:07:55,680 --> 00:07:59,280
jscript and jscript is some

220
00:07:59,280 --> 00:08:02,240
language is similar to javascript by but

221
00:08:02,240 --> 00:08:02,800
used

222
00:08:02,800 --> 00:08:06,000
by microsoft and there are

223
00:08:06,000 --> 00:08:10,160
other techniques like click ones or

224
00:08:10,160 --> 00:08:13,199
links sometimes you can sense

225
00:08:13,199 --> 00:08:16,240
links or or some other uh

226
00:08:16,240 --> 00:08:19,199
files that are very small but can

227
00:08:19,199 --> 00:08:20,160
contain some

228
00:08:20,160 --> 00:08:22,560
one-liners to be executed one little

229
00:08:22,560 --> 00:08:23,759
side note i think

230
00:08:23,759 --> 00:08:25,520
which will be outside of scope of this

231
00:08:25,520 --> 00:08:27,280
presentation but still

232
00:08:27,280 --> 00:08:29,680
my office documents are very popular

233
00:08:29,680 --> 00:08:30,479
because

234
00:08:30,479 --> 00:08:33,360
of course it's very easy to convince

235
00:08:33,360 --> 00:08:34,880
user actually to launch this file

236
00:08:34,880 --> 00:08:35,519
because people

237
00:08:35,519 --> 00:08:37,519
they don't they ignore those macro

238
00:08:37,519 --> 00:08:39,360
alerts this is

239
00:08:39,360 --> 00:08:41,599
one thing but actually the history knows

240
00:08:41,599 --> 00:08:42,559
that there are some

241
00:08:42,559 --> 00:08:44,240
antivirus solutions on the market which

242
00:08:44,240 --> 00:08:46,399
actually they just simply don't check

243
00:08:46,399 --> 00:08:47,680
the macros right

244
00:08:47,680 --> 00:08:49,279
we know certain examples we won't quote

245
00:08:49,279 --> 00:08:51,519
that of course but there are some of

246
00:08:51,519 --> 00:08:54,080
some of the some of that yeah we've seen

247
00:08:54,080 --> 00:08:55,200
such stuff

248
00:08:55,200 --> 00:08:57,040
so you can you can basically basically

249
00:08:57,040 --> 00:08:58,480
paste very tribal

250
00:08:58,480 --> 00:09:00,399
uh payload inside of the macro and it

251
00:09:00,399 --> 00:09:02,320
simply won't be scanned by the

252
00:09:02,320 --> 00:09:04,320
well-known product that's that's a

253
00:09:04,320 --> 00:09:06,000
that's a nice hint all right

254
00:09:06,000 --> 00:09:09,680
anyway let's go for sure so about in

255
00:09:09,680 --> 00:09:11,360
native code execution in those

256
00:09:11,360 --> 00:09:12,320
commercial documents

257
00:09:12,320 --> 00:09:15,600
so for example in vba we can just import

258
00:09:15,600 --> 00:09:17,519
windows api functions

259
00:09:17,519 --> 00:09:19,680
and this is example of create process

260
00:09:19,680 --> 00:09:21,040
function

261
00:09:21,040 --> 00:09:24,720
and that's it we could import those

262
00:09:24,720 --> 00:09:25,600
functions and

263
00:09:25,600 --> 00:09:27,839
for example inject shell code allocate

264
00:09:27,839 --> 00:09:28,800
memory

265
00:09:28,800 --> 00:09:31,760
and execute stuff directly from from

266
00:09:31,760 --> 00:09:36,399
visual basic macro in word or excel

267
00:09:36,399 --> 00:09:40,480
for html applications

268
00:09:40,480 --> 00:09:43,920
it works in a similar way

269
00:09:43,920 --> 00:09:47,040
we can use some some com objects to to

270
00:09:47,040 --> 00:09:49,360
register some external functions from

271
00:09:49,360 --> 00:09:50,240
dlls

272
00:09:50,240 --> 00:09:53,040
so for example those windows api

273
00:09:53,040 --> 00:09:54,399
functions

274
00:09:54,399 --> 00:09:57,440
and there's some other tricky way you

275
00:09:57,440 --> 00:09:58,480
can see below

276
00:09:58,480 --> 00:10:00,720
is to actually instantiate an excel

277
00:10:00,720 --> 00:10:02,240
object and then

278
00:10:02,240 --> 00:10:06,880
execute some vba macro with this

279
00:10:06,880 --> 00:10:10,959
and for jscript in hd8 this

280
00:10:10,959 --> 00:10:13,279
is very similar to the previous one we

281
00:10:13,279 --> 00:10:14,160
can also

282
00:10:14,160 --> 00:10:17,760
import some functions from the dlls and

283
00:10:17,760 --> 00:10:20,000
you may be wondering what's that in

284
00:10:20,000 --> 00:10:22,320
in double quotes so this is actually

285
00:10:22,320 --> 00:10:23,360
yeah this is actually

286
00:10:23,360 --> 00:10:26,640
a signature of the function so those

287
00:10:26,640 --> 00:10:30,560
letters mean specific parameters like

288
00:10:30,640 --> 00:10:33,279
pointer integer short long or whatever

289
00:10:33,279 --> 00:10:33,920
and this is

290
00:10:33,920 --> 00:10:37,120
what the function returns so this is

291
00:10:37,120 --> 00:10:40,720
some information about the function and

292
00:10:40,720 --> 00:10:43,440
and expect parameters and and what does

293
00:10:43,440 --> 00:10:44,160
it return

294
00:10:44,160 --> 00:10:48,000
but there's also an option to to execute

295
00:10:48,000 --> 00:10:50,480
dot net assembly via the serialization

296
00:10:50,480 --> 00:10:51,120
and there are

297
00:10:51,120 --> 00:10:54,720
some two good tools for for that uh

298
00:10:54,720 --> 00:10:57,279
namely dotnet to jscript and gathered to

299
00:10:57,279 --> 00:10:58,959
jscript

300
00:10:58,959 --> 00:11:02,399
and from dotnet or powershell we can

301
00:11:02,399 --> 00:11:05,600
also simply import

302
00:11:05,600 --> 00:11:08,880
api functions define them

303
00:11:08,880 --> 00:11:12,240
and execute so this is called actually

304
00:11:12,240 --> 00:11:16,560
platform invoke and it's a matter of

305
00:11:16,880 --> 00:11:20,399
cooperation from from.net with low level

306
00:11:20,399 --> 00:11:23,360
system apis

307
00:11:24,560 --> 00:11:27,360
and so some cool trick from old times

308
00:11:27,360 --> 00:11:28,000
when we want

309
00:11:28,000 --> 00:11:31,360
to leverage bad files

310
00:11:31,360 --> 00:11:33,839
batch files for for execution of some

311
00:11:33,839 --> 00:11:35,839
executable we can

312
00:11:35,839 --> 00:11:39,040
use some tools like exe to

313
00:11:39,040 --> 00:11:42,480
bat or hex bad whatever it's called

314
00:11:42,480 --> 00:11:46,240
to just write a hex dump

315
00:11:46,240 --> 00:11:49,120
in this form and then the batch file

316
00:11:49,120 --> 00:11:50,880
executed would

317
00:11:50,880 --> 00:11:55,200
retrieve the contents of the file and

318
00:11:55,519 --> 00:11:58,320
run this using uh this debug tool which

319
00:11:58,320 --> 00:11:59,920
is which is present on

320
00:11:59,920 --> 00:12:03,040
all windows systems i guess

321
00:12:04,240 --> 00:12:06,720
and also about the circle because uh

322
00:12:06,720 --> 00:12:07,279
usually

323
00:12:07,279 --> 00:12:10,480
we transform our c

324
00:12:10,480 --> 00:12:13,279
program into some form of shell code to

325
00:12:13,279 --> 00:12:15,920
to be executed

326
00:12:15,920 --> 00:12:18,480
by injection for example from this vba

327
00:12:18,480 --> 00:12:19,760
macro or from

328
00:12:19,760 --> 00:12:22,880
http document or whatever else so what

329
00:12:22,880 --> 00:12:24,240
what's this shell cut actually

330
00:12:24,240 --> 00:12:26,480
so this is a some piece of position

331
00:12:26,480 --> 00:12:28,399
position independent code so it can be

332
00:12:28,399 --> 00:12:29,440
executed

333
00:12:29,440 --> 00:12:34,399
whenever in the memory and it

334
00:12:36,000 --> 00:12:38,160
has some cool clever features to

335
00:12:38,160 --> 00:12:39,440
bootstrap itself

336
00:12:39,440 --> 00:12:43,120
in every location memory so

337
00:12:43,120 --> 00:12:46,720
this it uses some common structures like

338
00:12:46,720 --> 00:12:48,800
process environment block to locate

339
00:12:48,800 --> 00:12:50,000
needed functions and

340
00:12:50,000 --> 00:12:52,720
load libraries and execute stuff later

341
00:12:52,720 --> 00:12:53,760
and it's

342
00:12:53,760 --> 00:12:56,160
also mainly used in binary exploitation

343
00:12:56,160 --> 00:12:57,600
so

344
00:12:57,600 --> 00:12:59,600
for example when we have some buffer

345
00:12:59,600 --> 00:13:01,680
overflow or hip overflow we can

346
00:13:01,680 --> 00:13:04,079
can place some some short shell codes to

347
00:13:04,079 --> 00:13:05,680
to be executed

348
00:13:05,680 --> 00:13:08,959
when we take control of

349
00:13:08,959 --> 00:13:11,120
instruction pointer in the application

350
00:13:11,120 --> 00:13:12,320
exploited

351
00:13:12,320 --> 00:13:15,360
and as mentioned this is a good stuff

352
00:13:15,360 --> 00:13:16,959
for for in-memory injections for

353
00:13:16,959 --> 00:13:18,639
innermore executions

354
00:13:18,639 --> 00:13:21,760
and also shellcode provides

355
00:13:21,760 --> 00:13:24,079
like this perfect code reflection

356
00:13:24,079 --> 00:13:24,959
because

357
00:13:24,959 --> 00:13:28,240
it can modify itself so this is

358
00:13:28,240 --> 00:13:32,839
used for for some runtime decryption of

359
00:13:32,839 --> 00:13:35,200
shellcode particularly

360
00:13:35,200 --> 00:13:38,240
sour encoding is very popular in circles

361
00:13:38,240 --> 00:13:41,680
like those msf venom encoders

362
00:13:41,680 --> 00:13:45,120
and for windows circles as i mentioned

363
00:13:45,120 --> 00:13:46,880
it will just locate the process

364
00:13:46,880 --> 00:13:48,880
environment block in the memory

365
00:13:48,880 --> 00:13:52,480
then it locates more

366
00:13:52,480 --> 00:13:55,680
loader data list of imported loaded

367
00:13:55,680 --> 00:13:58,480
dls because every windows process has a

368
00:13:58,480 --> 00:14:01,760
kernel 32 dll and ntdll loaded

369
00:14:01,760 --> 00:14:05,360
and those libraries have some

370
00:14:05,360 --> 00:14:07,360
functions that are necessary to load

371
00:14:07,360 --> 00:14:08,560
additional modules

372
00:14:08,560 --> 00:14:12,160
namely get broadcast load library get

373
00:14:12,160 --> 00:14:13,120
module handle

374
00:14:13,120 --> 00:14:16,240
and this can be used to load any other

375
00:14:16,240 --> 00:14:17,760
library

376
00:14:17,760 --> 00:14:20,639
and invoke any function needed so for

377
00:14:20,639 --> 00:14:22,079
example

378
00:14:22,079 --> 00:14:25,839
load library could be used to load the

379
00:14:25,839 --> 00:14:29,040
socket library and then

380
00:14:29,360 --> 00:14:32,880
the simple reverse shell shell code uses

381
00:14:32,880 --> 00:14:34,480
great process with

382
00:14:34,480 --> 00:14:36,959
sockets created by wsi startup attached

383
00:14:36,959 --> 00:14:39,440
to standard input and output so that's

384
00:14:39,440 --> 00:14:42,880
like this simple reverse shell from from

385
00:14:42,880 --> 00:14:45,120
metal pattern

386
00:14:45,120 --> 00:14:48,480
and injecting shell code so this is

387
00:14:48,480 --> 00:14:52,320
some simple

388
00:14:52,320 --> 00:14:54,720
code to to inject shell code memory and

389
00:14:54,720 --> 00:14:56,880
so it's also written in c so

390
00:14:56,880 --> 00:15:00,560
it uses those well-known functions

391
00:15:00,560 --> 00:15:03,760
which because of that are

392
00:15:03,760 --> 00:15:06,480
kind of malicious so first the process

393
00:15:06,480 --> 00:15:08,399
would need to allocate memory

394
00:15:08,399 --> 00:15:11,120
then write the shortcut in some newly

395
00:15:11,120 --> 00:15:12,480
allocated memory

396
00:15:12,480 --> 00:15:14,720
mining the permissions of course because

397
00:15:14,720 --> 00:15:16,720
to write stuff we need

398
00:15:16,720 --> 00:15:18,720
rewrite permission and to execute we

399
00:15:18,720 --> 00:15:20,880
would need read execute

400
00:15:20,880 --> 00:15:24,000
but we can also allocate memory with

401
00:15:24,000 --> 00:15:25,680
execute read like permission so we can

402
00:15:25,680 --> 00:15:27,680
do everything

403
00:15:27,680 --> 00:15:29,920
i mean write the shortcut and execute

404
00:15:29,920 --> 00:15:31,360
this and then we can create

405
00:15:31,360 --> 00:15:34,160
thread pointing at our shell code or

406
00:15:34,160 --> 00:15:34,880
just

407
00:15:34,880 --> 00:15:38,240
cast the pointer to to function pointer

408
00:15:38,240 --> 00:15:38,800
and

409
00:15:38,800 --> 00:15:42,560
execute this in c but this

410
00:15:42,560 --> 00:15:45,120
won't work if permissions are not

411
00:15:45,120 --> 00:15:46,800
executable for this specific

412
00:15:46,800 --> 00:15:50,720
memory page so that's about shell code

413
00:15:50,720 --> 00:15:51,040
and

414
00:15:51,040 --> 00:15:55,360
let's do this theoretical exercise of

415
00:15:55,360 --> 00:15:58,000
developing a covert loader so let's say

416
00:15:58,000 --> 00:16:00,959
we want to have a

417
00:16:00,959 --> 00:16:04,000
loader written in c obfuscated as much

418
00:16:04,000 --> 00:16:04,959
as possible

419
00:16:04,959 --> 00:16:08,399
and this would eventually load

420
00:16:08,399 --> 00:16:10,480
for example a cobalt strike beacon so

421
00:16:10,480 --> 00:16:13,600
that's a typical approach we used during

422
00:16:13,600 --> 00:16:16,639
uh our red teaming exercises back in the

423
00:16:16,639 --> 00:16:18,639
days

424
00:16:18,639 --> 00:16:21,600
so starting with this architecture we

425
00:16:21,600 --> 00:16:23,759
got here what we mentioned

426
00:16:23,759 --> 00:16:26,720
two slides before so firstly the

427
00:16:26,720 --> 00:16:28,079
application would need to allocate

428
00:16:28,079 --> 00:16:28,959
memory

429
00:16:28,959 --> 00:16:30,560
write the shell code and then trigger

430
00:16:30,560 --> 00:16:32,240
execution but this is some

431
00:16:32,240 --> 00:16:35,120
uh some trivial stuff and would probably

432
00:16:35,120 --> 00:16:35,680
get

433
00:16:35,680 --> 00:16:38,959
detected right away by some antivirus

434
00:16:38,959 --> 00:16:41,199
so what what we can modify here first

435
00:16:41,199 --> 00:16:43,360
thing we could

436
00:16:43,360 --> 00:16:46,240
encrypt the shell code or just encode

437
00:16:46,240 --> 00:16:47,360
this or

438
00:16:47,360 --> 00:16:49,839
use our encryption wherever to just

439
00:16:49,839 --> 00:16:50,959
bypass those

440
00:16:50,959 --> 00:16:53,040
well-known signatures for shell codes

441
00:16:53,040 --> 00:16:54,399
and then this could be

442
00:16:54,399 --> 00:16:57,440
decrypted in memory and then written

443
00:16:57,440 --> 00:17:01,279
in in specific buffer and executed

444
00:17:01,279 --> 00:17:03,279
next step would be to implement some

445
00:17:03,279 --> 00:17:04,959
sandbox checks to bypass

446
00:17:04,959 --> 00:17:07,839
any dynamic analysis either automated in

447
00:17:07,839 --> 00:17:08,959
the sandbox or

448
00:17:08,959 --> 00:17:12,880
manual by an analyst

449
00:17:12,880 --> 00:17:16,000
then we can also implement some

450
00:17:16,000 --> 00:17:19,280
anti-debug checks which could be

451
00:17:19,280 --> 00:17:22,160
of course easily then bypassed by by the

452
00:17:22,160 --> 00:17:24,799
analyst but

453
00:17:24,799 --> 00:17:27,520
it would give a little bit of struggle

454
00:17:27,520 --> 00:17:28,799
to the analysts to

455
00:17:28,799 --> 00:17:31,280
to find them and bypass them well

456
00:17:31,280 --> 00:17:32,480
actually

457
00:17:32,480 --> 00:17:35,840
maybe not that much because for example

458
00:17:35,840 --> 00:17:39,039
there's this plugin for for

459
00:17:39,039 --> 00:17:41,919
x64 debugger called sila height which

460
00:17:41,919 --> 00:17:42,320
which

461
00:17:42,320 --> 00:17:45,600
bypasses those simple anti-double debug

462
00:17:45,600 --> 00:17:47,200
measures

463
00:17:47,200 --> 00:17:50,720
so anyway that's like a captain game

464
00:17:50,720 --> 00:17:52,799
cut and mouse game or whatever you call

465
00:17:52,799 --> 00:17:54,559
this like the whole model of development

466
00:17:54,559 --> 00:17:55,280
right because

467
00:17:55,280 --> 00:17:57,840
it keeps developing and the malware

468
00:17:57,840 --> 00:17:58,640
manufacture

469
00:17:58,640 --> 00:18:00,160
the antivirus manufacturers they keep

470
00:18:00,160 --> 00:18:01,840
you blocking keeps you blocking also you

471
00:18:01,840 --> 00:18:03,360
got this machine learning thing

472
00:18:03,360 --> 00:18:05,520
which gives you actually a whole new

473
00:18:05,520 --> 00:18:06,400
level

474
00:18:06,400 --> 00:18:08,799
yeah it already should well the the

475
00:18:08,799 --> 00:18:10,160
whole society security

476
00:18:10,160 --> 00:18:11,919
system counted mouse game and red

477
00:18:11,919 --> 00:18:13,520
teaming glow teaming for living in

478
00:18:13,520 --> 00:18:14,080
everything

479
00:18:14,080 --> 00:18:17,200
well anyway what we could

480
00:18:17,200 --> 00:18:20,640
implement further is to

481
00:18:20,640 --> 00:18:24,640
obfuscate some some data like

482
00:18:24,640 --> 00:18:29,039
some ip addresses or some function names

483
00:18:29,039 --> 00:18:29,440
or

484
00:18:29,440 --> 00:18:32,880
anything that's visible in in the binary

485
00:18:32,880 --> 00:18:36,240
so good thing would be to

486
00:18:36,240 --> 00:18:38,480
do the obfuscate the code or decrypt

487
00:18:38,480 --> 00:18:40,080
this during runtime

488
00:18:40,080 --> 00:18:44,160
so it won't be picked by simple analysis

489
00:18:44,160 --> 00:18:45,760
for example with strings tool which

490
00:18:45,760 --> 00:18:47,919
gives strings

491
00:18:47,919 --> 00:18:51,200
embedded in the executable

492
00:18:51,200 --> 00:18:53,600
and then

493
00:18:54,640 --> 00:18:58,559
come some clever techniques for uh

494
00:18:58,559 --> 00:19:01,840
bypassing memory scanning uh

495
00:19:01,840 --> 00:19:05,039
what we could do for example is to

496
00:19:05,039 --> 00:19:07,520
write the shellcode execute this but

497
00:19:07,520 --> 00:19:10,480
after some time

498
00:19:10,480 --> 00:19:12,720
get the shell coat removed from the

499
00:19:12,720 --> 00:19:13,679
memory by

500
00:19:13,679 --> 00:19:16,320
for example another thread another

501
00:19:16,320 --> 00:19:17,520
worker thread

502
00:19:17,520 --> 00:19:19,840
and then this could be replied and

503
00:19:19,840 --> 00:19:20,720
executed again

504
00:19:20,720 --> 00:19:25,200
so the edr for example would have

505
00:19:25,200 --> 00:19:27,679
less chances of detecting this malicious

506
00:19:27,679 --> 00:19:30,480
stuff in memory

507
00:19:30,480 --> 00:19:33,600
while doing this we could also implement

508
00:19:33,600 --> 00:19:35,440
some

509
00:19:35,440 --> 00:19:37,280
anti-debugging features to to make the

510
00:19:37,280 --> 00:19:39,760
debugging harder for for an analyst and

511
00:19:39,760 --> 00:19:44,960
we will talk about those specifics later

512
00:19:45,120 --> 00:19:48,880
another thing a cool feature we could

513
00:19:48,880 --> 00:19:51,919
implement in our malware is cracking of

514
00:19:51,919 --> 00:19:53,440
decryption case because

515
00:19:53,440 --> 00:19:56,000
as we mentioned we can we could use some

516
00:19:56,000 --> 00:19:57,679
verification or decryption during

517
00:19:57,679 --> 00:19:58,480
runtime

518
00:19:58,480 --> 00:20:00,960
for for some sensitive data like shell

519
00:20:00,960 --> 00:20:02,880
code or some function names or

520
00:20:02,880 --> 00:20:06,240
or ip addresses or any other iocs

521
00:20:06,240 --> 00:20:09,280
but either the key could be present in

522
00:20:09,280 --> 00:20:11,280
the binary and used for decryption

523
00:20:11,280 --> 00:20:14,880
or it could be cracked so this would

524
00:20:14,880 --> 00:20:17,520
take some time we would need to use some

525
00:20:17,520 --> 00:20:18,320
short key

526
00:20:18,320 --> 00:20:21,039
so it won't be cracked like forever but

527
00:20:21,039 --> 00:20:21,440
in

528
00:20:21,440 --> 00:20:25,679
few seconds or minutes and then

529
00:20:25,679 --> 00:20:28,080
this key would be used to decrypt stuff

530
00:20:28,080 --> 00:20:29,679
in memory doing

531
00:20:29,679 --> 00:20:32,720
sorry during runtime and

532
00:20:32,720 --> 00:20:36,159
another thing on top of that is to

533
00:20:36,159 --> 00:20:38,720
dynamically resolve function names and

534
00:20:38,720 --> 00:20:40,320
we'll go to that further so

535
00:20:40,320 --> 00:20:43,760
this would bypass those uh

536
00:20:43,760 --> 00:20:47,200
iocs based on import address table

537
00:20:47,200 --> 00:20:50,480
so to hide those malicious functions

538
00:20:50,480 --> 00:20:52,960
like virtual analog

539
00:20:52,960 --> 00:20:56,720
write process memory create thread or

540
00:20:56,720 --> 00:20:58,559
create process from from the import

541
00:20:58,559 --> 00:21:00,880
table

542
00:21:00,880 --> 00:21:04,960
and also for for the whole

543
00:21:04,960 --> 00:21:07,200
development process we could implement

544
00:21:07,200 --> 00:21:09,440
some

545
00:21:09,440 --> 00:21:14,000
compile time obfuscations for example uh

546
00:21:14,000 --> 00:21:16,960
we could have have some uh use some

547
00:21:16,960 --> 00:21:19,520
templates in c plus plus to

548
00:21:19,520 --> 00:21:22,480
change the uh obfuscation every time the

549
00:21:22,480 --> 00:21:23,120
code is

550
00:21:23,120 --> 00:21:26,400
is compiled and also leverage some

551
00:21:26,400 --> 00:21:29,760
uh compiler obfuscation for example with

552
00:21:29,760 --> 00:21:31,679
low level virtual machine to

553
00:21:31,679 --> 00:21:34,559
obfuscate stuff differently with every

554
00:21:34,559 --> 00:21:35,520
compilation

555
00:21:35,520 --> 00:21:38,000
so we with every compilation we will get

556
00:21:38,000 --> 00:21:38,720
of course

557
00:21:38,720 --> 00:21:41,120
a new checksums to bypass some some

558
00:21:41,120 --> 00:21:43,360
trivial detections based on md5 sounds

559
00:21:43,360 --> 00:21:44,320
of the file

560
00:21:44,320 --> 00:21:47,440
but also the the binary would look

561
00:21:47,440 --> 00:21:48,159
differently

562
00:21:48,159 --> 00:21:51,120
and would be

563
00:21:51,360 --> 00:21:54,000
stuff would be encrypted with with some

564
00:21:54,000 --> 00:21:54,480
other

565
00:21:54,480 --> 00:21:57,520
other key dynamically

566
00:21:57,520 --> 00:21:59,520
created during during compilation so

567
00:21:59,520 --> 00:22:00,640
that's some

568
00:22:00,640 --> 00:22:03,760
some advanced stuff but but

569
00:22:03,760 --> 00:22:06,799
very cool and useful all right so the

570
00:22:06,799 --> 00:22:08,240
next topic would be

571
00:22:08,240 --> 00:22:11,760
bypassing static static iocs and we got

572
00:22:11,760 --> 00:22:14,320
a couple of static properties

573
00:22:14,320 --> 00:22:17,440
which will be included within our uh our

574
00:22:17,440 --> 00:22:19,679
marvel code first one is definitely the

575
00:22:19,679 --> 00:22:20,799
hash of the file

576
00:22:20,799 --> 00:22:25,200
then some of the strings within our

577
00:22:25,200 --> 00:22:27,840
our code static signatures then

578
00:22:27,840 --> 00:22:28,720
something which

579
00:22:28,720 --> 00:22:31,520
is definitely very often forgotten are

580
00:22:31,520 --> 00:22:32,400
those debug

581
00:22:32,400 --> 00:22:36,000
informations with a pdb file

582
00:22:36,000 --> 00:22:39,120
then some important dlls and

583
00:22:39,120 --> 00:22:42,159
other functions and what actually can we

584
00:22:42,159 --> 00:22:45,200
do against against that so

585
00:22:45,200 --> 00:22:48,080
there are a couple of techniques so the

586
00:22:48,080 --> 00:22:48,640
first one

587
00:22:48,640 --> 00:22:50,559
for the fire hash would be the

588
00:22:50,559 --> 00:22:52,320
compilation then for the

589
00:22:52,320 --> 00:22:55,280
strings and static signatures we can use

590
00:22:55,280 --> 00:22:55,679
uh

591
00:22:55,679 --> 00:22:58,960
sore encryption just to hide it and

592
00:22:58,960 --> 00:23:00,400
that's basically

593
00:23:00,400 --> 00:23:04,080
uh it for hiding debug information

594
00:23:04,080 --> 00:23:06,799
we can go into the linker settings and

595
00:23:06,799 --> 00:23:08,159
try to

596
00:23:08,159 --> 00:23:10,880
hide that for the dlls there and

597
00:23:10,880 --> 00:23:11,840
imported functions

598
00:23:11,840 --> 00:23:13,520
there's this technique called api

599
00:23:13,520 --> 00:23:15,679
hashing which uh

600
00:23:15,679 --> 00:23:19,360
actually hide it from antivirus and from

601
00:23:19,360 --> 00:23:20,559
the analytics

602
00:23:20,559 --> 00:23:24,000
so the first one is a file hash so uh i

603
00:23:24,000 --> 00:23:25,600
think all of you guys probably know the

604
00:23:25,600 --> 00:23:26,400
file hash

605
00:23:26,400 --> 00:23:28,559
each time when you compare the file you

606
00:23:28,559 --> 00:23:30,880
got a file

607
00:23:30,880 --> 00:23:34,159
a file and once you made a new

608
00:23:34,159 --> 00:23:34,880
compilation

609
00:23:34,880 --> 00:23:38,080
the file is simply changed so the

610
00:23:38,080 --> 00:23:41,440
hash changes and this is a very very

611
00:23:41,440 --> 00:23:43,520
tribal uh technique if you want to

612
00:23:43,520 --> 00:23:44,559
change the file house

613
00:23:44,559 --> 00:23:47,679
just simply try to compile the code

614
00:23:47,679 --> 00:23:51,039
and that's that's basically it

615
00:23:51,039 --> 00:23:53,440
uh all right all right so the the next

616
00:23:53,440 --> 00:23:55,039
thing uh which will be

617
00:23:55,039 --> 00:23:58,320
uh the uh pdb uh file

618
00:23:58,320 --> 00:24:01,679
uh well what is actually a pdb this is a

619
00:24:01,679 --> 00:24:03,440
program database file often called as a

620
00:24:03,440 --> 00:24:05,279
simple file which stores some debugging

621
00:24:05,279 --> 00:24:06,320
information

622
00:24:06,320 --> 00:24:10,320
and this file is generated when

623
00:24:10,320 --> 00:24:13,039
on the during the compilation uh to

624
00:24:13,039 --> 00:24:14,880
store just the debugging information

625
00:24:14,880 --> 00:24:18,000
of course this file isn't attached to

626
00:24:18,000 --> 00:24:19,840
some kind of executable file which will

627
00:24:19,840 --> 00:24:21,039
finally produce

628
00:24:21,039 --> 00:24:24,320
but uh in this uh in your

629
00:24:24,320 --> 00:24:27,120
executable file you will have a

630
00:24:27,120 --> 00:24:27,840
reference

631
00:24:27,840 --> 00:24:30,880
uh to the to the to this pdb file

632
00:24:30,880 --> 00:24:33,440
on your home directory or on your folder

633
00:24:33,440 --> 00:24:34,799
where your project is

634
00:24:34,799 --> 00:24:38,320
so if an analyst or or whoever

635
00:24:38,320 --> 00:24:41,520
will perform a very very simple

636
00:24:41,520 --> 00:24:44,720
search tree or for this file you

637
00:24:44,720 --> 00:24:47,039
he or she may found my find the

638
00:24:47,039 --> 00:24:48,400
reference to this

639
00:24:48,400 --> 00:24:51,039
uh to this pdb file and finally it can

640
00:24:51,039 --> 00:24:51,679
also

641
00:24:51,679 --> 00:24:55,600
it can somehow

642
00:24:56,159 --> 00:25:01,840
store okay

643
00:25:02,880 --> 00:25:05,440
and finally it's it can somehow expose

644
00:25:05,440 --> 00:25:07,200
some of your sensitive information like

645
00:25:07,200 --> 00:25:08,320
your home directory

646
00:25:08,320 --> 00:25:10,400
or something which will be in this

647
00:25:10,400 --> 00:25:12,559
directory so it's a very

648
00:25:12,559 --> 00:25:15,120
uh good practice just to change the

649
00:25:15,120 --> 00:25:16,080
changes in

650
00:25:16,080 --> 00:25:18,559
linker settings so it won't be included

651
00:25:18,559 --> 00:25:19,279
or the

652
00:25:19,279 --> 00:25:22,080
directory won't be included in the final

653
00:25:22,080 --> 00:25:22,960
executable

654
00:25:22,960 --> 00:25:25,919
file all right so the next one will be

655
00:25:25,919 --> 00:25:27,440
associated to how hiding

656
00:25:27,440 --> 00:25:30,000
import and function functions api

657
00:25:30,000 --> 00:25:31,440
hashing but i think this is your

658
00:25:31,440 --> 00:25:32,400
favorite one so

659
00:25:32,400 --> 00:25:35,600
yeah that's cool stuff so

660
00:25:35,600 --> 00:25:38,000
normally when we use some some api

661
00:25:38,000 --> 00:25:38,799
functions we

662
00:25:38,799 --> 00:25:41,200
would have in this reference sorry in

663
00:25:41,200 --> 00:25:42,320
the import table

664
00:25:42,320 --> 00:25:45,600
so for example when injecting shell code

665
00:25:45,600 --> 00:25:48,799
we would have references for those

666
00:25:48,799 --> 00:25:50,720
malicious functions in the import

667
00:25:50,720 --> 00:25:53,120
library because windows loader needs to

668
00:25:53,120 --> 00:25:55,200
load those functions for for the

669
00:25:55,200 --> 00:25:56,720
executable to work

670
00:25:56,720 --> 00:25:59,840
but what can we do here we could uh

671
00:25:59,840 --> 00:26:03,760
use mentioned functions like load

672
00:26:03,760 --> 00:26:04,480
library

673
00:26:04,480 --> 00:26:06,880
get module handle and get proc address

674
00:26:06,880 --> 00:26:08,720
which are used by shellcode

675
00:26:08,720 --> 00:26:10,400
we could leverage those functions to

676
00:26:10,400 --> 00:26:12,320
find any other functions

677
00:26:12,320 --> 00:26:14,559
dynamically during the the runtime

678
00:26:14,559 --> 00:26:15,840
during execution of

679
00:26:15,840 --> 00:26:18,880
our application and then only function

680
00:26:18,880 --> 00:26:20,480
visible in the import table will be

681
00:26:20,480 --> 00:26:22,240
those

682
00:26:22,240 --> 00:26:25,120
for loading external libraries and at

683
00:26:25,120 --> 00:26:25,760
the

684
00:26:25,760 --> 00:26:29,200
first glance we would not see that the

685
00:26:29,200 --> 00:26:31,760
application actually imports this

686
00:26:31,760 --> 00:26:33,600
malicious create thread or will to

687
00:26:33,600 --> 00:26:35,520
unlock virtual protect or

688
00:26:35,520 --> 00:26:39,840
other functions like that

689
00:26:40,159 --> 00:26:43,440
and we can take this further and

690
00:26:43,440 --> 00:26:45,919
implement this shell called style

691
00:26:45,919 --> 00:26:48,000
bootstrapping in our application

692
00:26:48,000 --> 00:26:52,000
so to hide those load library and

693
00:26:52,000 --> 00:26:54,159
get proc address get module handle

694
00:26:54,159 --> 00:26:55,919
function from the import table

695
00:26:55,919 --> 00:26:58,799
we could find all those functions

696
00:26:58,799 --> 00:26:59,679
dynamically

697
00:26:59,679 --> 00:27:02,960
in in memory just like the shellcode

698
00:27:02,960 --> 00:27:03,520
does

699
00:27:03,520 --> 00:27:06,799
so the algorithm for for this

700
00:27:06,799 --> 00:27:08,880
is to locate the process environment

701
00:27:08,880 --> 00:27:10,000
block and this

702
00:27:10,000 --> 00:27:13,840
is simple as referencing to fs or gs

703
00:27:13,840 --> 00:27:15,520
register for

704
00:27:15,520 --> 00:27:19,120
32 or 64-bit architecture respectively

705
00:27:19,120 --> 00:27:21,919
and then there is this loader data

706
00:27:21,919 --> 00:27:23,360
structure

707
00:27:23,360 --> 00:27:24,960
in memory in the process environment

708
00:27:24,960 --> 00:27:27,919
block which contains information about

709
00:27:27,919 --> 00:27:30,559
all loaded modules either executable or

710
00:27:30,559 --> 00:27:31,840
dlls

711
00:27:31,840 --> 00:27:34,880
and then browsing through

712
00:27:34,880 --> 00:27:38,000
those informations we can we can find

713
00:27:38,000 --> 00:27:41,200
uh actual uh

714
00:27:41,200 --> 00:27:44,559
names of functions for for specific

715
00:27:44,559 --> 00:27:45,440
libraries

716
00:27:45,440 --> 00:27:48,480
and then uh knowing that kernel 32

717
00:27:48,480 --> 00:27:52,000
and ntdoll are loaded for every process

718
00:27:52,000 --> 00:27:55,120
we can browse the current 32

719
00:27:55,120 --> 00:27:57,840
exported functions which addresses our

720
00:27:57,840 --> 00:27:59,279
located memory

721
00:27:59,279 --> 00:28:03,120
to find them by name so

722
00:28:03,120 --> 00:28:06,000
we could find those two or three

723
00:28:06,000 --> 00:28:08,080
functions to to load external

724
00:28:08,080 --> 00:28:12,320
libraries and locate specific functions

725
00:28:12,320 --> 00:28:14,399
and then after dynamically finding

726
00:28:14,399 --> 00:28:16,240
address of those functions we could call

727
00:28:16,240 --> 00:28:17,120
them

728
00:28:17,120 --> 00:28:19,600
with arguments of other functions and

729
00:28:19,600 --> 00:28:21,760
load whatever we would need so

730
00:28:21,760 --> 00:28:24,720
for using this shell called like

731
00:28:24,720 --> 00:28:25,600
technique

732
00:28:25,600 --> 00:28:28,399
we would have actually empty import

733
00:28:28,399 --> 00:28:31,840
table so everything would be

734
00:28:31,919 --> 00:28:36,159
found dynamically during the execution

735
00:28:36,159 --> 00:28:38,399
and this is the the code for that so

736
00:28:38,399 --> 00:28:39,520
it's quite long

737
00:28:39,520 --> 00:28:42,559
but you can find this and

738
00:28:42,559 --> 00:28:44,720
all of the other stuff on my blog which

739
00:28:44,720 --> 00:28:48,159
i will link later in the presentation

740
00:28:48,159 --> 00:28:51,200
and also just checking the process

741
00:28:51,200 --> 00:28:52,399
environment block in

742
00:28:52,399 --> 00:28:55,440
in debugger we can see the information

743
00:28:55,440 --> 00:28:58,559
about loaded modules so first

744
00:28:58,559 --> 00:29:00,559
module is the application executable

745
00:29:00,559 --> 00:29:02,320
itself and then we have entity dll

746
00:29:02,320 --> 00:29:03,760
current 32 and

747
00:29:03,760 --> 00:29:06,799
we can browse this to find

748
00:29:06,799 --> 00:29:10,799
a specific function by names

749
00:29:10,960 --> 00:29:14,799
and uh going further

750
00:29:14,799 --> 00:29:18,320
because when we were looking for

751
00:29:18,320 --> 00:29:19,520
functions by names

752
00:29:19,520 --> 00:29:22,720
we had to embed those names as

753
00:29:22,720 --> 00:29:25,919
strings in the executables so still this

754
00:29:25,919 --> 00:29:29,039
could have been found by an analyst in

755
00:29:29,039 --> 00:29:32,880
executable we could for example

756
00:29:32,880 --> 00:29:36,240
uh encrypt or encode those function

757
00:29:36,240 --> 00:29:36,960
names but

758
00:29:36,960 --> 00:29:39,760
other thing we can do is calculate

759
00:29:39,760 --> 00:29:42,159
hashes of those function names and then

760
00:29:42,159 --> 00:29:46,080
while browsing every function

761
00:29:46,080 --> 00:29:48,960
for example in kernel 32 library we

762
00:29:48,960 --> 00:29:49,520
could

763
00:29:49,520 --> 00:29:52,399
calculate a hash of the name of the

764
00:29:52,399 --> 00:29:53,120
function name

765
00:29:53,120 --> 00:29:55,760
and compare this with with our

766
00:29:55,760 --> 00:29:57,440
predefined hash

767
00:29:57,440 --> 00:30:00,799
using some specific algorithm and uh

768
00:30:00,799 --> 00:30:03,120
just find find function that we need by

769
00:30:03,120 --> 00:30:04,000
by hash

770
00:30:04,000 --> 00:30:07,200
so like looking up some

771
00:30:07,200 --> 00:30:10,720
something in the hash table

772
00:30:11,039 --> 00:30:13,600
all right and then the sandbox evasion

773
00:30:13,600 --> 00:30:14,240
so

774
00:30:14,240 --> 00:30:16,080
if we can just place ourselves between

775
00:30:16,080 --> 00:30:17,279
the execution

776
00:30:17,279 --> 00:30:20,559
flow right now we will try to skip

777
00:30:20,559 --> 00:30:23,600
the sandbox which will be uh

778
00:30:23,600 --> 00:30:26,480
the sandbox uh check will be

779
00:30:26,480 --> 00:30:26,960
performed

780
00:30:26,960 --> 00:30:29,440
by antivirus the antivirus will try to

781
00:30:29,440 --> 00:30:30,960
run our software

782
00:30:30,960 --> 00:30:34,159
on our malware and verify whether

783
00:30:34,159 --> 00:30:37,039
what we actually have is malicious and

784
00:30:37,039 --> 00:30:38,240
after that it will

785
00:30:38,240 --> 00:30:40,240
perform scoring and finally decide

786
00:30:40,240 --> 00:30:41,919
malicious or not malicious

787
00:30:41,919 --> 00:30:43,120
and there are a couple of these

788
00:30:43,120 --> 00:30:45,679
techniques which actually can fool the

789
00:30:45,679 --> 00:30:48,320
antivirus that uh the piece of software

790
00:30:48,320 --> 00:30:50,399
which actually actually run is not

791
00:30:50,399 --> 00:30:51,039
something

792
00:30:51,039 --> 00:30:52,799
something malicious and one sorry one

793
00:30:52,799 --> 00:30:54,159
thing to note here that

794
00:30:54,159 --> 00:30:57,279
this anti-sunblock measures can

795
00:30:57,279 --> 00:31:00,240
also help us combating dynamic analysis

796
00:31:00,240 --> 00:31:00,640
because

797
00:31:00,640 --> 00:31:04,000
usually analysts use virtual

798
00:31:04,000 --> 00:31:07,360
machines to analyze malicious samples so

799
00:31:07,360 --> 00:31:08,000
we can

800
00:31:08,000 --> 00:31:11,279
implement those sandbox checks to to

801
00:31:11,279 --> 00:31:14,559
full this dynamic analysis in

802
00:31:14,559 --> 00:31:16,799
virtual machine also yeah so there are a

803
00:31:16,799 --> 00:31:18,399
couple of artifacts which are in common

804
00:31:18,399 --> 00:31:20,559
between the antivirus and actually

805
00:31:20,559 --> 00:31:23,200
the let's say a real machi real virtual

806
00:31:23,200 --> 00:31:24,159
machine of a

807
00:31:24,159 --> 00:31:26,320
malware analytics if we can call it that

808
00:31:26,320 --> 00:31:27,519
way but

809
00:31:27,519 --> 00:31:29,120
let's start from the from the antivirus

810
00:31:29,120 --> 00:31:32,320
we will try to mark them

811
00:31:32,320 --> 00:31:33,760
so the first one uh actually the

812
00:31:33,760 --> 00:31:36,640
antivirus solution uh it cannot

813
00:31:36,640 --> 00:31:39,760
prepare you a very uh great uh

814
00:31:39,760 --> 00:31:41,840
prepared environment it's this is

815
00:31:41,840 --> 00:31:43,279
somehow simplified

816
00:31:43,279 --> 00:31:46,000
and uh the two things which the first

817
00:31:46,000 --> 00:31:48,000
thing is the lack of resources

818
00:31:48,000 --> 00:31:49,840
so we can actually check how much the

819
00:31:49,840 --> 00:31:52,080
cpu cores or our processor have

820
00:31:52,080 --> 00:31:54,000
and this would be the first artifact and

821
00:31:54,000 --> 00:31:57,039
actually we can check how much memory

822
00:31:57,039 --> 00:32:00,399
available we have on our our machine

823
00:32:00,399 --> 00:32:03,360
in and if uh the machine which runs our

824
00:32:03,360 --> 00:32:04,000
code

825
00:32:04,000 --> 00:32:07,440
do not uh do not match our requirements

826
00:32:07,440 --> 00:32:08,159
let's say

827
00:32:08,159 --> 00:32:10,080
then we will simply uh stop the

828
00:32:10,080 --> 00:32:11,600
execution flow and

829
00:32:11,600 --> 00:32:14,720
uh the execution flow will not

830
00:32:14,720 --> 00:32:17,840
proceed uh just like i said before the

831
00:32:17,840 --> 00:32:20,000
resources the resources are limited and

832
00:32:20,000 --> 00:32:20,559
so

833
00:32:20,559 --> 00:32:23,039
we can try to allocate some huge amount

834
00:32:23,039 --> 00:32:23,760
of memory

835
00:32:23,760 --> 00:32:26,799
this will probably uh be

836
00:32:26,799 --> 00:32:28,480
pretty tough for the antivirus to

837
00:32:28,480 --> 00:32:30,880
allocate let's say 10 gigs of memory

838
00:32:30,880 --> 00:32:33,919
so maybe uh antivirus will skip

839
00:32:33,919 --> 00:32:37,039
at this point because this

840
00:32:37,039 --> 00:32:39,279
software could not allocate that much

841
00:32:39,279 --> 00:32:42,480
and we'll stop analyzing our

842
00:32:42,480 --> 00:32:46,159
our malware the another

843
00:32:46,159 --> 00:32:49,360
cool technique is try to load some fake

844
00:32:49,360 --> 00:32:50,080
library

845
00:32:50,080 --> 00:32:52,399
wi-fi library because it will try to

846
00:32:52,399 --> 00:32:54,320
load some existing library

847
00:32:54,320 --> 00:32:56,559
it could it also could be it could be

848
00:32:56,559 --> 00:32:57,600
emulated but

849
00:32:57,600 --> 00:32:59,600
if we will try to let's say load

850
00:32:59,600 --> 00:33:00,880
fake.dll

851
00:33:00,880 --> 00:33:02,320
we are pretty much sure that such a

852
00:33:02,320 --> 00:33:04,640
library will not exist or any machine

853
00:33:04,640 --> 00:33:07,120
or maybe only or it could but not in

854
00:33:07,120 --> 00:33:08,000
most cases

855
00:33:08,000 --> 00:33:11,600
and if uh this antivirus this sandbox

856
00:33:11,600 --> 00:33:14,559
will try to uh virtualize that and will

857
00:33:14,559 --> 00:33:16,080
provide this fake dll

858
00:33:16,080 --> 00:33:17,760
we will be pretty much sure that we are

859
00:33:17,760 --> 00:33:20,000
inside of an sandbox and again we can

860
00:33:20,000 --> 00:33:23,200
actually stop an execution uh like i

861
00:33:23,200 --> 00:33:24,960
said uh also before

862
00:33:24,960 --> 00:33:27,600
uh those virtualized and sandbox

863
00:33:27,600 --> 00:33:28,559
environments they

864
00:33:28,559 --> 00:33:31,039
are very simple one and somehow they

865
00:33:31,039 --> 00:33:31,919
struggle

866
00:33:31,919 --> 00:33:34,640
uh to support multi-threading so using

867
00:33:34,640 --> 00:33:36,880
multi-threading is also one of the

868
00:33:36,880 --> 00:33:40,000
very efficient technique to to uh

869
00:33:40,000 --> 00:33:43,919
just keep being detected in this stage

870
00:33:43,919 --> 00:33:46,799
uh or if you have some knowledge

871
00:33:46,799 --> 00:33:48,640
regarding your target especially

872
00:33:48,640 --> 00:33:50,399
if you are performing some kind of spare

873
00:33:50,399 --> 00:33:52,240
phishing attack and you know

874
00:33:52,240 --> 00:33:55,519
exactly uh what likes uh the

875
00:33:55,519 --> 00:33:58,799
computers are called on our uh victims

876
00:33:58,799 --> 00:33:59,440
environment

877
00:33:59,440 --> 00:34:01,360
we can check for your computer name if

878
00:34:01,360 --> 00:34:02,480
the pattern match

879
00:34:02,480 --> 00:34:05,200
our requirements if not we can also stop

880
00:34:05,200 --> 00:34:06,720
the

881
00:34:06,720 --> 00:34:10,159
execution even we can try to verify the

882
00:34:10,159 --> 00:34:12,960
username of a user

883
00:34:12,960 --> 00:34:16,399
which is running our uh our malware

884
00:34:16,399 --> 00:34:18,719
and sandboxes are known for using very

885
00:34:18,719 --> 00:34:20,320
simplified users like admin

886
00:34:20,320 --> 00:34:23,199
user or whatever we can we can check for

887
00:34:23,199 --> 00:34:23,599
that

888
00:34:23,599 --> 00:34:25,359
and we can also use the opposite

889
00:34:25,359 --> 00:34:27,760
technique we can try if

890
00:34:27,760 --> 00:34:29,839
for example we are trying to attacking

891
00:34:29,839 --> 00:34:31,599
john doe we can maybe

892
00:34:31,599 --> 00:34:34,000
verify if the user which launches our

893
00:34:34,000 --> 00:34:35,839
malware is actually and john doe this is

894
00:34:35,839 --> 00:34:36,639
also very good

895
00:34:36,639 --> 00:34:38,800
very cool stuff and in most cases you

896
00:34:38,800 --> 00:34:40,639
probably would be aiming a domain

897
00:34:40,639 --> 00:34:41,679
environment so

898
00:34:41,679 --> 00:34:44,960
it's also worth to check if our domain

899
00:34:44,960 --> 00:34:45,280
is

900
00:34:45,280 --> 00:34:48,800
domain joint uh regarding the usb

901
00:34:48,800 --> 00:34:49,440
devices

902
00:34:49,440 --> 00:34:51,679
one funny fact is that we can actually

903
00:34:51,679 --> 00:34:52,560
see how

904
00:34:52,560 --> 00:34:56,399
uh what are the

905
00:34:56,399 --> 00:34:59,680
usb register values and those virtual

906
00:34:59,680 --> 00:35:01,200
machines they will probably

907
00:35:01,200 --> 00:35:03,839
won't have any uh history of mounted usb

908
00:35:03,839 --> 00:35:04,560
devices

909
00:35:04,560 --> 00:35:07,760
so it's always great to er to great to

910
00:35:07,760 --> 00:35:08,400
have that

911
00:35:08,400 --> 00:35:11,280
of course in some environments like in

912
00:35:11,280 --> 00:35:12,720
bank environment those

913
00:35:12,720 --> 00:35:14,800
usb devices may not be the greatest

914
00:35:14,800 --> 00:35:17,520
technique because usbs may be disabled

915
00:35:17,520 --> 00:35:20,800
so just adjust it into that into your

916
00:35:20,800 --> 00:35:23,200
project uh just like patrick said there

917
00:35:23,200 --> 00:35:24,079
are some common

918
00:35:24,079 --> 00:35:26,560
common artifacts between sandboxes and

919
00:35:26,560 --> 00:35:28,320
the virtual machines which belongs to a

920
00:35:28,320 --> 00:35:29,440
mobile artist

921
00:35:29,440 --> 00:35:32,079
and probably you both of them will be

922
00:35:32,079 --> 00:35:33,119
virtual

923
00:35:33,119 --> 00:35:36,160
so as you probably know if uh if you

924
00:35:36,160 --> 00:35:37,680
have a virtual machine you got you've

925
00:35:37,680 --> 00:35:39,200
got this artifacts like

926
00:35:39,200 --> 00:35:42,720
guest additions for most or every single

927
00:35:42,720 --> 00:35:45,680
virtual tool and we can try to see

928
00:35:45,680 --> 00:35:47,839
whether those files uh

929
00:35:47,839 --> 00:35:49,839
actually exist on the system and we can

930
00:35:49,839 --> 00:35:51,599
also query

931
00:35:51,599 --> 00:35:54,800
the registry and see if we if we have

932
00:35:54,800 --> 00:35:56,480
the keys inside of our

933
00:35:56,480 --> 00:35:59,119
register if so we will be able to detect

934
00:35:59,119 --> 00:36:00,240
that we are within a

935
00:36:00,240 --> 00:36:02,480
virtual machine which probably is not

936
00:36:02,480 --> 00:36:04,560
our target and then we can also

937
00:36:04,560 --> 00:36:07,760
try to skip that and speaking of which

938
00:36:07,760 --> 00:36:10,160
uh when it comes to virtual network

939
00:36:10,160 --> 00:36:10,800
adapters

940
00:36:10,800 --> 00:36:13,920
uh they have this mac address which

941
00:36:13,920 --> 00:36:15,760
belongs to uh

942
00:36:15,760 --> 00:36:18,960
to the vendor like uh visual like a

943
00:36:18,960 --> 00:36:20,000
vmware or

944
00:36:20,000 --> 00:36:22,079
oracle you can all check that you can

945
00:36:22,079 --> 00:36:23,599
check the mac address or this network

946
00:36:23,599 --> 00:36:24,400
device

947
00:36:24,400 --> 00:36:27,760
and on the execution if uh we have

948
00:36:27,760 --> 00:36:30,240
something from a known list and the

949
00:36:30,240 --> 00:36:31,839
clock is thinking the clock is really

950
00:36:31,839 --> 00:36:34,960
a really uh funny part because it is not

951
00:36:34,960 --> 00:36:37,440
as this is the asleep 10 000 right

952
00:36:37,440 --> 00:36:40,320
you cannot just sleep the code yes we

953
00:36:40,320 --> 00:36:41,440
could but

954
00:36:41,440 --> 00:36:45,760
the clever sandboxes like for example

955
00:36:45,760 --> 00:36:48,079
properly configured cuckoo sandbox which

956
00:36:48,079 --> 00:36:49,520
can be used also for

957
00:36:49,520 --> 00:36:52,640
some books like analysis can just hook

958
00:36:52,640 --> 00:36:55,520
api functions and delay those slips so

959
00:36:55,520 --> 00:36:58,079
we as malware developers would

960
00:36:58,079 --> 00:37:00,079
sleep our code for a few minutes to time

961
00:37:00,079 --> 00:37:01,200
out an

962
00:37:01,200 --> 00:37:03,200
automated analysis in sandbox but

963
00:37:03,200 --> 00:37:04,720
sandbox could trick

964
00:37:04,720 --> 00:37:08,000
us and fast forward our delay

965
00:37:08,000 --> 00:37:11,520
and execute the code further so

966
00:37:11,520 --> 00:37:14,000
what we could do we can uh first of all

967
00:37:14,000 --> 00:37:15,440
use the lowest

968
00:37:15,440 --> 00:37:17,599
api which is anti-digital execution

969
00:37:17,599 --> 00:37:18,880
because sleep

970
00:37:18,880 --> 00:37:21,680
function eventually calls mtdl execution

971
00:37:21,680 --> 00:37:23,680
from ntdl

972
00:37:23,680 --> 00:37:25,839
we could sleep for example for 100

973
00:37:25,839 --> 00:37:27,280
seconds and then

974
00:37:27,280 --> 00:37:30,079
measure time elapsed i mean before and

975
00:37:30,079 --> 00:37:31,040
after and see

976
00:37:31,040 --> 00:37:35,680
if actually 100 seconds or so

977
00:37:35,680 --> 00:37:38,720
have passed or and if not that probably

978
00:37:38,720 --> 00:37:40,880
means that

979
00:37:40,880 --> 00:37:43,920
the environment is monitored

980
00:37:43,920 --> 00:37:47,200
hooked by by some sandbox for example

981
00:37:47,200 --> 00:37:51,040
environment and the sleep was fast

982
00:37:51,040 --> 00:37:52,000
forwarded

983
00:37:52,000 --> 00:37:54,720
but also they get the count function

984
00:37:54,720 --> 00:37:55,440
which

985
00:37:55,440 --> 00:37:58,400
returns the the system time it could be

986
00:37:58,400 --> 00:37:58,960
hooked and

987
00:37:58,960 --> 00:38:02,000
return false values in the sandbox so

988
00:38:02,000 --> 00:38:05,839
what we could do with that there is some

989
00:38:05,839 --> 00:38:08,800
system structure called a kernel user

990
00:38:08,800 --> 00:38:10,079
shared data

991
00:38:10,079 --> 00:38:13,440
and on specific offsets these are like

992
00:38:13,440 --> 00:38:14,560
uh

993
00:38:14,560 --> 00:38:17,040
the same for for every system i think we

994
00:38:17,040 --> 00:38:18,240
can check

995
00:38:18,240 --> 00:38:21,280
the the information about elapsed time

996
00:38:21,280 --> 00:38:22,160
store there and

997
00:38:22,160 --> 00:38:24,880
that's read-only only modifiable by

998
00:38:24,880 --> 00:38:25,839
kernel

999
00:38:25,839 --> 00:38:29,680
and less probably tampered with by by

1000
00:38:29,680 --> 00:38:30,720
the sandbox so

1001
00:38:30,720 --> 00:38:33,839
i think it's the most reliable

1002
00:38:33,839 --> 00:38:36,320
source of information for the system

1003
00:38:36,320 --> 00:38:37,359
uptime so we could

1004
00:38:37,359 --> 00:38:40,880
use this to check if if those 100

1005
00:38:40,880 --> 00:38:42,240
seconds that we

1006
00:38:42,240 --> 00:38:44,880
should have slept have actually passed

1007
00:38:44,880 --> 00:38:47,119
or not

1008
00:38:47,119 --> 00:38:51,599
and about hooking functions what why uh

1009
00:38:51,599 --> 00:38:55,040
some uh environment like sandbox or edr

1010
00:38:55,040 --> 00:38:58,480
edr would hook functions so uh

1011
00:38:58,480 --> 00:39:00,320
first thing mentioned for example to

1012
00:39:00,320 --> 00:39:02,560
return

1013
00:39:02,560 --> 00:39:06,000
false uptime or or fast forward our

1014
00:39:06,000 --> 00:39:10,880
our sleeps but also to

1015
00:39:10,880 --> 00:39:13,920
monitor what we are doing in the systems

1016
00:39:13,920 --> 00:39:14,960
for example

1017
00:39:14,960 --> 00:39:17,760
uh those create thread functions or

1018
00:39:17,760 --> 00:39:20,320
memory allocation functions those those

1019
00:39:20,320 --> 00:39:23,359
crucial ones could be hooked and

1020
00:39:23,359 --> 00:39:26,720
when a malware invokes this function the

1021
00:39:26,720 --> 00:39:28,240
execution flow would be

1022
00:39:28,240 --> 00:39:30,560
redirected to some edr module for

1023
00:39:30,560 --> 00:39:31,359
example

1024
00:39:31,359 --> 00:39:33,680
and then parameters will be checked and

1025
00:39:33,680 --> 00:39:35,200
if for example the

1026
00:39:35,200 --> 00:39:38,079
the pointers which are argument to the

1027
00:39:38,079 --> 00:39:39,440
function point to some malicious

1028
00:39:39,440 --> 00:39:40,800
buffering memory

1029
00:39:40,800 --> 00:39:42,720
this could be blocked by adr and the

1030
00:39:42,720 --> 00:39:43,839
same

1031
00:39:43,839 --> 00:39:47,359
case is for process damping so

1032
00:39:47,359 --> 00:39:51,040
the lowest level api for reading memory

1033
00:39:51,040 --> 00:39:51,280
is

1034
00:39:51,280 --> 00:39:54,640
is anti-read virtual memory and the

1035
00:39:54,640 --> 00:39:58,079
argument for this is uh the process

1036
00:39:58,079 --> 00:40:01,920
name i think so the edr or sandbox could

1037
00:40:01,920 --> 00:40:04,480
well in this case cdr probably because

1038
00:40:04,480 --> 00:40:06,560
we are assuming that we are

1039
00:40:06,560 --> 00:40:10,160
attacking some some life some actual

1040
00:40:10,160 --> 00:40:13,119
environment of a user the cdr would hook

1041
00:40:13,119 --> 00:40:14,240
this function and

1042
00:40:14,240 --> 00:40:17,359
check if we are trying to dump the lsa

1043
00:40:17,359 --> 00:40:18,720
memory and if so

1044
00:40:18,720 --> 00:40:22,319
just to to deny the access

1045
00:40:22,319 --> 00:40:25,839
to stop the execution

1046
00:40:26,000 --> 00:40:30,560
and what we can do with this so

1047
00:40:30,560 --> 00:40:34,160
first thing we could browse the

1048
00:40:34,160 --> 00:40:37,440
actual assembly code

1049
00:40:37,440 --> 00:40:40,960
of the functions in memory to see if

1050
00:40:40,960 --> 00:40:43,280
first instructions are modified because

1051
00:40:43,280 --> 00:40:44,240
usually

1052
00:40:44,240 --> 00:40:47,280
uh the first instructions in in hooked

1053
00:40:47,280 --> 00:40:48,480
function would

1054
00:40:48,480 --> 00:40:52,000
be something like call or push and

1055
00:40:52,000 --> 00:40:52,800
return

1056
00:40:52,800 --> 00:40:54,960
to actually call some some function in

1057
00:40:54,960 --> 00:40:56,640
external module

1058
00:40:56,640 --> 00:40:59,680
and uh we could see if

1059
00:40:59,680 --> 00:41:03,200
if that's the case for for the function

1060
00:41:03,200 --> 00:41:04,079
a code

1061
00:41:04,079 --> 00:41:07,119
or even better we could try to load the

1062
00:41:07,119 --> 00:41:10,720
dll from disk and then compare the stuff

1063
00:41:10,720 --> 00:41:13,280
from disk with the actual function

1064
00:41:13,280 --> 00:41:15,200
called memory to see if it's different

1065
00:41:15,200 --> 00:41:16,880
if it's different the function is

1066
00:41:16,880 --> 00:41:18,319
probably hooked so

1067
00:41:18,319 --> 00:41:21,200
you can see some source code for that uh

1068
00:41:21,200 --> 00:41:24,000
but also you can find this

1069
00:41:24,000 --> 00:41:28,000
on my blog so the

1070
00:41:28,000 --> 00:41:30,960
going further we would uh unhook those

1071
00:41:30,960 --> 00:41:32,480
hooked functions so

1072
00:41:32,480 --> 00:41:34,800
just replace the function code with with

1073
00:41:34,800 --> 00:41:36,720
original stuff

1074
00:41:36,720 --> 00:41:39,839
for example from the file on disk

1075
00:41:39,839 --> 00:41:43,119
so that that way we could

1076
00:41:43,119 --> 00:41:46,880
clear those edr hooks but we could also

1077
00:41:46,880 --> 00:41:48,560
bypass this by issuing

1078
00:41:48,560 --> 00:41:51,680
a direct syscall so for example we can

1079
00:41:51,680 --> 00:41:52,000
see

1080
00:41:52,000 --> 00:41:55,760
a progmon information here

1081
00:41:55,760 --> 00:41:58,880
when our application

1082
00:41:58,880 --> 00:42:00,960
calls the create thread function we we

1083
00:42:00,960 --> 00:42:02,720
see the

1084
00:42:02,720 --> 00:42:05,119
other apis that called and the lowest

1085
00:42:05,119 --> 00:42:06,880
level is anti-create

1086
00:42:06,880 --> 00:42:10,240
thread ex which and this

1087
00:42:10,240 --> 00:42:13,839
this integrator x function is actually

1088
00:42:13,839 --> 00:42:16,720
some simple wrapper to to cisco and i

1089
00:42:16,720 --> 00:42:17,440
think a lot

1090
00:42:17,440 --> 00:42:20,319
most of anti-dll functions are are just

1091
00:42:20,319 --> 00:42:21,599
syscalls and cisco

1092
00:42:21,599 --> 00:42:24,560
is some is a mean of transferring the

1093
00:42:24,560 --> 00:42:25,760
execution of the kernel

1094
00:42:25,760 --> 00:42:29,119
so the kernel does what's needed and

1095
00:42:29,119 --> 00:42:32,480
and this is co actually is

1096
00:42:32,480 --> 00:42:35,599
just putting some specific id in

1097
00:42:35,599 --> 00:42:37,760
register and then

1098
00:42:37,760 --> 00:42:39,119
issuing this processor instruction

1099
00:42:39,119 --> 00:42:42,000
called cisco and then

1100
00:42:42,000 --> 00:42:45,839
execution gets forwarded to kernel so uh

1101
00:42:45,839 --> 00:42:49,520
we could uh also

1102
00:42:50,160 --> 00:42:52,560
implement those direct ciscos in our

1103
00:42:52,560 --> 00:42:54,079
code and see

1104
00:42:54,079 --> 00:42:57,440
so for in visual studio for

1105
00:42:57,440 --> 00:43:00,160
32-bit architecture we could just put

1106
00:43:00,160 --> 00:43:01,839
in-line assembly in the code but

1107
00:43:01,839 --> 00:43:05,760
for 64-bit it's impossible and we

1108
00:43:05,760 --> 00:43:09,359
need to create

1109
00:43:09,359 --> 00:43:12,560
and compile some some assembly

1110
00:43:12,560 --> 00:43:15,839
file an external file and then reference

1111
00:43:15,839 --> 00:43:19,119
this function in our c code so

1112
00:43:19,119 --> 00:43:22,560
for example here we have a

1113
00:43:22,640 --> 00:43:24,960
cisco implemented in assembly with a

1114
00:43:24,960 --> 00:43:26,480
specific cisco id

1115
00:43:26,480 --> 00:43:29,040
that's different may be different for

1116
00:43:29,040 --> 00:43:29,760
every

1117
00:43:29,760 --> 00:43:32,400
windows version or even release because

1118
00:43:32,400 --> 00:43:34,240
those change often

1119
00:43:34,240 --> 00:43:37,599
and then reference this function with

1120
00:43:37,599 --> 00:43:38,319
this

1121
00:43:38,319 --> 00:43:41,920
modifier external extern c

1122
00:43:41,920 --> 00:43:44,640
so linker would find this function in in

1123
00:43:44,640 --> 00:43:46,240
this compiled assembly

1124
00:43:46,240 --> 00:43:47,760
and then we need to provide the

1125
00:43:47,760 --> 00:43:49,760
signature of functions so to provide all

1126
00:43:49,760 --> 00:43:51,599
the required parameters for

1127
00:43:51,599 --> 00:43:53,839
for this antiquate write x function and

1128
00:43:53,839 --> 00:43:55,040
then

1129
00:43:55,040 --> 00:43:57,280
this would be executed in kernel and

1130
00:43:57,280 --> 00:43:59,599
completely by passing any

1131
00:43:59,599 --> 00:44:03,040
function hooks put

1132
00:44:03,040 --> 00:44:06,960
there by by adr or any other

1133
00:44:06,960 --> 00:44:10,319
solution like that yeah so

1134
00:44:10,319 --> 00:44:11,920
uh now we have the anti-debugging

1135
00:44:11,920 --> 00:44:13,359
techniques which are crucial when it

1136
00:44:13,359 --> 00:44:14,160
comes to

1137
00:44:14,160 --> 00:44:17,440
uh fighting with an artist and we got

1138
00:44:17,440 --> 00:44:19,920
uh two very simple options to detect

1139
00:44:19,920 --> 00:44:21,520
that first one is the

1140
00:44:21,520 --> 00:44:24,560
is debugger present flag and also there

1141
00:44:24,560 --> 00:44:25,200
are some like

1142
00:44:25,200 --> 00:44:28,160
some other flags and artifacts which are

1143
00:44:28,160 --> 00:44:28,720
uh

1144
00:44:28,720 --> 00:44:31,200
set if you are debugging some some kind

1145
00:44:31,200 --> 00:44:32,160
of a file

1146
00:44:32,160 --> 00:44:35,440
and you can use that to break the

1147
00:44:35,440 --> 00:44:36,240
application

1148
00:44:36,240 --> 00:44:38,400
in case that it is being debugged but

1149
00:44:38,400 --> 00:44:40,800
don't forget to disable those especially

1150
00:44:40,800 --> 00:44:42,000
if you are actually working on the

1151
00:44:42,000 --> 00:44:42,640
malware

1152
00:44:42,640 --> 00:44:45,440
because you can block yourself and uh

1153
00:44:45,440 --> 00:44:47,680
that's that's very also important to

1154
00:44:47,680 --> 00:44:50,480
do and you can also dynamically detect

1155
00:44:50,480 --> 00:44:52,160
breakpoints right

1156
00:44:52,160 --> 00:44:54,560
yeah so that's some clever technique

1157
00:44:54,560 --> 00:44:56,720
implemented so

1158
00:44:56,720 --> 00:44:58,800
let's say we have some crucial function

1159
00:44:58,800 --> 00:44:59,760
and we would

1160
00:44:59,760 --> 00:45:03,359
want to check if it's debugged or not if

1161
00:45:03,359 --> 00:45:06,560
there's some software breakpoint in this

1162
00:45:06,560 --> 00:45:07,200
function

1163
00:45:07,200 --> 00:45:10,880
so what we could do is uh

1164
00:45:10,880 --> 00:45:14,400
first put some uh linker

1165
00:45:14,400 --> 00:45:17,200
directives to not to inline this

1166
00:45:17,200 --> 00:45:18,640
function and

1167
00:45:18,640 --> 00:45:20,800
after compiling the this like that would

1168
00:45:20,800 --> 00:45:22,480
have this crucial function and

1169
00:45:22,480 --> 00:45:24,079
right after this we would have another

1170
00:45:24,079 --> 00:45:26,079
function so we could

1171
00:45:26,079 --> 00:45:29,359
uh calculate the checksum of

1172
00:45:29,359 --> 00:45:31,920
all the bytes of the function starting

1173
00:45:31,920 --> 00:45:32,880
with

1174
00:45:32,880 --> 00:45:34,480
here so beginning of this crucial

1175
00:45:34,480 --> 00:45:36,240
function and

1176
00:45:36,240 --> 00:45:38,640
ending here because the beginning of

1177
00:45:38,640 --> 00:45:40,640
next function is the end of this

1178
00:45:40,640 --> 00:45:43,760
crucial function so we would we could

1179
00:45:43,760 --> 00:45:46,640
calculate bytes to see if they were

1180
00:45:46,640 --> 00:45:48,160
changed in memory because if

1181
00:45:48,160 --> 00:45:50,800
there's some software breakpoint placed

1182
00:45:50,800 --> 00:45:51,599
in this function

1183
00:45:51,599 --> 00:45:54,319
the the specific op code would be

1184
00:45:54,319 --> 00:45:55,920
present and the

1185
00:45:55,920 --> 00:45:58,160
checksum would be different here so

1186
00:45:58,160 --> 00:45:58,960
that's some

1187
00:45:58,960 --> 00:46:02,079
some cool feature and uh

1188
00:46:02,079 --> 00:46:05,359
another thing to

1189
00:46:05,440 --> 00:46:08,480
play a little bit with with malware

1190
00:46:08,480 --> 00:46:11,599
malware analyst is to use some windows

1191
00:46:11,599 --> 00:46:12,960
api callbacks because

1192
00:46:12,960 --> 00:46:16,079
when an analyst debugs our code

1193
00:46:16,079 --> 00:46:19,359
and steps by

1194
00:46:19,359 --> 00:46:23,280
every single instruction and

1195
00:46:23,280 --> 00:46:26,400
they can see what is executing after

1196
00:46:26,400 --> 00:46:27,200
what but

1197
00:46:27,200 --> 00:46:29,599
using callbacks we can for example call

1198
00:46:29,599 --> 00:46:30,560
the read

1199
00:46:30,560 --> 00:46:34,000
file function with filex and

1200
00:46:34,000 --> 00:46:36,079
implement some some callback which would

1201
00:46:36,079 --> 00:46:37,520
be executed

1202
00:46:37,520 --> 00:46:40,560
after the file read is completed and

1203
00:46:40,560 --> 00:46:43,760
we could transfer our malicious uh

1204
00:46:43,760 --> 00:46:46,640
execution to this callback so this won't

1205
00:46:46,640 --> 00:46:47,839
be

1206
00:46:47,839 --> 00:46:52,400
caught that easily by by the analyst

1207
00:46:54,000 --> 00:46:57,760
and some some advanced obfuscation now

1208
00:46:57,760 --> 00:47:01,200
so this is uh uh also a cool topic

1209
00:47:01,200 --> 00:47:05,040
first consider uh how how the actual

1210
00:47:05,040 --> 00:47:07,520
compilation process works so first we

1211
00:47:07,520 --> 00:47:08,400
have this

1212
00:47:08,400 --> 00:47:11,760
front end which

1213
00:47:11,760 --> 00:47:13,839
processes the the source code and

1214
00:47:13,839 --> 00:47:14,880
creates this

1215
00:47:14,880 --> 00:47:18,160
intermediate representation and then

1216
00:47:18,160 --> 00:47:22,640
the optimization takes place which

1217
00:47:22,640 --> 00:47:25,280
works on the intermediate representation

1218
00:47:25,280 --> 00:47:26,319
level to

1219
00:47:26,319 --> 00:47:29,599
reduce code complexity but not to change

1220
00:47:29,599 --> 00:47:30,960
the

1221
00:47:30,960 --> 00:47:34,160
application algorithm and

1222
00:47:34,160 --> 00:47:36,400
then the back end translates this

1223
00:47:36,400 --> 00:47:37,599
modified

1224
00:47:37,599 --> 00:47:42,319
ir code to to assembly or some bytecode

1225
00:47:42,880 --> 00:47:47,520
and here comes obfuscator llvm which is

1226
00:47:47,520 --> 00:47:50,559
open source fork or of low level virtual

1227
00:47:50,559 --> 00:47:51,200
machine

1228
00:47:51,200 --> 00:47:55,040
and llvm is some compiler infrastructure

1229
00:47:55,040 --> 00:47:57,359
alternative let's say and this includes

1230
00:47:57,359 --> 00:47:58,240
a

1231
00:47:58,240 --> 00:48:00,480
well-known c link compiler which is

1232
00:48:00,480 --> 00:48:01,760
actually a front-end

1233
00:48:01,760 --> 00:48:05,280
and this obfuscation

1234
00:48:05,280 --> 00:48:08,400
it works on this

1235
00:48:08,400 --> 00:48:10,240
intermediate representation level so we

1236
00:48:10,240 --> 00:48:11,440
mentioned before that

1237
00:48:11,440 --> 00:48:15,440
uh the second step is optimization

1238
00:48:15,440 --> 00:48:18,839
so the ir code is simplified so

1239
00:48:18,839 --> 00:48:21,440
it would execute quicker and the

1240
00:48:21,440 --> 00:48:22,720
obfuscation is kind of

1241
00:48:22,720 --> 00:48:26,480
anti-optimization so it's mangled and

1242
00:48:26,480 --> 00:48:29,280
probably would take more time to execute

1243
00:48:29,280 --> 00:48:29,680
but

1244
00:48:29,680 --> 00:48:33,200
it's also harder to read

1245
00:48:33,200 --> 00:48:35,599
so the assembly generated from the

1246
00:48:35,599 --> 00:48:36,640
obfuscated

1247
00:48:36,640 --> 00:48:39,119
intermediate representation is is more

1248
00:48:39,119 --> 00:48:41,119
difficult to

1249
00:48:41,119 --> 00:48:44,800
to read by an analyst for example while

1250
00:48:44,800 --> 00:48:47,119
reverse engineering the c or z plus plus

1251
00:48:47,119 --> 00:48:48,319
code

1252
00:48:48,319 --> 00:48:52,160
actually the actual assembly generated

1253
00:48:52,160 --> 00:48:55,520
so going to some example

1254
00:48:55,520 --> 00:48:58,720
we have this simple app which

1255
00:48:58,720 --> 00:49:00,800
gets the tick count and performs some

1256
00:49:00,800 --> 00:49:02,960
basic automatic operations

1257
00:49:02,960 --> 00:49:05,359
and after disassembling with gidra we

1258
00:49:05,359 --> 00:49:08,480
can see this uh

1259
00:49:08,559 --> 00:49:10,559
tree of execution this graph execution

1260
00:49:10,559 --> 00:49:11,599
graph

1261
00:49:11,599 --> 00:49:14,640
and we have three

1262
00:49:14,640 --> 00:49:17,119
types of of obfuscation in this

1263
00:49:17,119 --> 00:49:19,200
obfuscator llvm framework

1264
00:49:19,200 --> 00:49:22,480
so first is instruction substitution so

1265
00:49:22,480 --> 00:49:24,880
here simple arithmetic instructions are

1266
00:49:24,880 --> 00:49:26,240
replaced with

1267
00:49:26,240 --> 00:49:28,160
more difficult one which actually give

1268
00:49:28,160 --> 00:49:29,440
the

1269
00:49:29,440 --> 00:49:32,319
same output but more code as we can see

1270
00:49:32,319 --> 00:49:32,960
on the

1271
00:49:32,960 --> 00:49:36,000
function graph here the second thing is

1272
00:49:36,000 --> 00:49:39,359
bogus control flow and this

1273
00:49:39,359 --> 00:49:42,319
works differently this places some

1274
00:49:42,319 --> 00:49:44,960
opaque predicates before

1275
00:49:44,960 --> 00:49:47,200
a given function block and opec

1276
00:49:47,200 --> 00:49:48,400
predicate is

1277
00:49:48,400 --> 00:49:51,520
something that some piece of code that

1278
00:49:51,520 --> 00:49:54,720
is evaluated during runtime but to uh

1279
00:49:54,720 --> 00:49:57,200
predetermine the value of true or false

1280
00:49:57,200 --> 00:49:59,440
so during compilation we actually know

1281
00:49:59,440 --> 00:50:02,640
that for example this single predicate

1282
00:50:02,640 --> 00:50:04,480
would

1283
00:50:04,480 --> 00:50:07,119
be evaluated to false but it's it's

1284
00:50:07,119 --> 00:50:09,440
calculated during run time and then

1285
00:50:09,440 --> 00:50:12,559
based on the the condition

1286
00:50:12,559 --> 00:50:15,760
uh a jump is performed so

1287
00:50:15,760 --> 00:50:18,880
an analyst would need to to step by by

1288
00:50:18,880 --> 00:50:21,359
this predicate and execute this to see

1289
00:50:21,359 --> 00:50:22,000
if

1290
00:50:22,000 --> 00:50:24,160
it produces true or false but we during

1291
00:50:24,160 --> 00:50:26,000
compilation time know that for example

1292
00:50:26,000 --> 00:50:29,839
it's false and that a single

1293
00:50:29,839 --> 00:50:33,119
conditional jump would be

1294
00:50:33,119 --> 00:50:35,200
taken to a specific branch and not the

1295
00:50:35,200 --> 00:50:36,240
other

1296
00:50:36,240 --> 00:50:39,119
and third thing is control flow

1297
00:50:39,119 --> 00:50:40,079
flattening so

1298
00:50:40,079 --> 00:50:42,880
consider some algorithm with with

1299
00:50:42,880 --> 00:50:44,160
specific steps

1300
00:50:44,160 --> 00:50:47,280
and then we uh destroy this

1301
00:50:47,280 --> 00:50:49,440
sequence of instructions and place

1302
00:50:49,440 --> 00:50:50,880
everything at the same level and

1303
00:50:50,880 --> 00:50:52,079
actually the

1304
00:50:52,079 --> 00:50:54,240
execution is controlled by a switch

1305
00:50:54,240 --> 00:50:55,440
statement with some

1306
00:50:55,440 --> 00:50:57,920
control variables so this control

1307
00:50:57,920 --> 00:50:58,720
variables can

1308
00:50:58,720 --> 00:51:02,000
uh tell tell the application which

1309
00:51:02,000 --> 00:51:04,079
which block should be executed after

1310
00:51:04,079 --> 00:51:05,520
another so

1311
00:51:05,520 --> 00:51:08,319
this is uh some heavy application and

1312
00:51:08,319 --> 00:51:09,040
using this

1313
00:51:09,040 --> 00:51:12,240
uh the

1314
00:51:12,240 --> 00:51:14,559
function graph it gets gets much more

1315
00:51:14,559 --> 00:51:16,240
complicated than

1316
00:51:16,240 --> 00:51:19,680
the one before the prescription

1317
00:51:19,680 --> 00:51:21,839
all right that sounds pretty advanced

1318
00:51:21,839 --> 00:51:23,440
and uh

1319
00:51:23,440 --> 00:51:25,440
it's the last part for today last but

1320
00:51:25,440 --> 00:51:26,880
not least i think

1321
00:51:26,880 --> 00:51:28,559
we have other tricks and clever

1322
00:51:28,559 --> 00:51:30,319
techniques which you can actually use

1323
00:51:30,319 --> 00:51:33,200
in your uh your code uh the first one

1324
00:51:33,200 --> 00:51:33,680
parent

1325
00:51:33,680 --> 00:51:37,040
uh protocol disproving uh also

1326
00:51:37,040 --> 00:51:38,960
uh we encourage you to take a closer

1327
00:51:38,960 --> 00:51:40,480
look at process protection

1328
00:51:40,480 --> 00:51:42,400
then advanced data applications some

1329
00:51:42,400 --> 00:51:44,160
kind of time consuming operations

1330
00:51:44,160 --> 00:51:47,839
uh and also inventor environmental king

1331
00:51:47,839 --> 00:51:50,800
all right so the first one parameter is

1332
00:51:50,800 --> 00:51:52,720
proofing so if you create a new process

1333
00:51:52,720 --> 00:51:54,160
you can use actually

1334
00:51:54,160 --> 00:51:57,040
uh one of the parameters to provide a

1335
00:51:57,040 --> 00:51:57,920
process id

1336
00:51:57,920 --> 00:52:00,650
so you can abuse the relation between uh

1337
00:52:00,650 --> 00:52:02,240
[Music]

1338
00:52:02,240 --> 00:52:04,319
in the child or the other protests so on

1339
00:52:04,319 --> 00:52:06,240
the on the left we have the regular

1340
00:52:06,240 --> 00:52:06,800
protest

1341
00:52:06,800 --> 00:52:10,240
uh of notepad uh and uh the on the right

1342
00:52:10,240 --> 00:52:11,760
we have a protest

1343
00:52:11,760 --> 00:52:13,839
when the pro when the protest id was

1344
00:52:13,839 --> 00:52:15,359
actually spoofed

1345
00:52:15,359 --> 00:52:17,599
so this is a really really good one

1346
00:52:17,599 --> 00:52:19,119
pretty good against

1347
00:52:19,119 --> 00:52:22,880
i think some kind of uh blue team

1348
00:52:22,880 --> 00:52:25,200
blue teams and any other monitoring

1349
00:52:25,200 --> 00:52:26,640
monitoring tools

1350
00:52:26,640 --> 00:52:29,760
another technique is a data application

1351
00:52:29,760 --> 00:52:31,520
this is always useful when it comes to

1352
00:52:31,520 --> 00:52:33,200
malware developing you can either

1353
00:52:33,200 --> 00:52:35,920
use the windows default functions but

1354
00:52:35,920 --> 00:52:37,440
those can be

1355
00:52:37,440 --> 00:52:40,000
those can be hooked but so it's always a

1356
00:52:40,000 --> 00:52:43,680
good idea to run your own obfuscation

1357
00:52:43,680 --> 00:52:47,359
tool for encoding and decoding

1358
00:52:47,359 --> 00:52:51,280
and also you can

1359
00:52:51,280 --> 00:52:53,599
do not deliver the key but you can

1360
00:52:53,599 --> 00:52:55,680
during the code execution you can try to

1361
00:52:55,680 --> 00:52:56,720
brute force the key

1362
00:52:56,720 --> 00:52:59,599
so it actually makes little more mess

1363
00:52:59,599 --> 00:53:01,040
inside of the code and

1364
00:53:01,040 --> 00:53:04,160
makes it also harder to uh

1365
00:53:04,160 --> 00:53:07,280
to decompile and uh

1366
00:53:07,280 --> 00:53:09,119
reverse engineer and also it's time

1367
00:53:09,119 --> 00:53:10,480
consuming we could program

1368
00:53:10,480 --> 00:53:14,160
some the brute forcing cover key to take

1369
00:53:14,160 --> 00:53:15,040
a few minutes

1370
00:53:15,040 --> 00:53:17,920
so it's for example timeout in a sandbox

1371
00:53:17,920 --> 00:53:18,640
analysis

1372
00:53:18,640 --> 00:53:20,640
yeah so always keep in mind uh regarding

1373
00:53:20,640 --> 00:53:22,880
the power of the of the machine you're

1374
00:53:22,880 --> 00:53:25,680
trying to force because if the key would

1375
00:53:25,680 --> 00:53:26,720
be too complicated

1376
00:53:26,720 --> 00:53:29,119
it may take too long to actually decrypt

1377
00:53:29,119 --> 00:53:29,839
the

1378
00:53:29,839 --> 00:53:32,880
the key and the last thing associated

1379
00:53:32,880 --> 00:53:33,520
with

1380
00:53:33,520 --> 00:53:35,920
with the things we have to talk to you

1381
00:53:35,920 --> 00:53:36,559
today

1382
00:53:36,559 --> 00:53:38,960
is the environmental gain so making the

1383
00:53:38,960 --> 00:53:40,880
code execution depending on some

1384
00:53:40,880 --> 00:53:43,200
environmental uh things like a computer

1385
00:53:43,200 --> 00:53:43,520
name

1386
00:53:43,520 --> 00:53:45,920
on a target machine so if they don't

1387
00:53:45,920 --> 00:53:46,720
match the

1388
00:53:46,720 --> 00:53:49,599
code will simply not run all right so

1389
00:53:49,599 --> 00:53:50,240
this was

1390
00:53:50,240 --> 00:53:52,720
uh that's that's all which we have

1391
00:53:52,720 --> 00:53:54,000
prepared for you today

1392
00:53:54,000 --> 00:53:57,920
we hope you had a great time uh

1393
00:53:58,400 --> 00:54:00,880
watching us today apologies uh i

1394
00:54:00,880 --> 00:54:01,680
encourage you

1395
00:54:01,680 --> 00:54:03,599
uh to visit patrick's blog because it's

1396
00:54:03,599 --> 00:54:04,880
actually his property

1397
00:54:04,880 --> 00:54:07,200
uh where you can find a lot of more

1398
00:54:07,200 --> 00:54:08,800
interesting articles regarding malware

1399
00:54:08,800 --> 00:54:10,079
development and other

1400
00:54:10,079 --> 00:54:12,400
offensive techniques so thank you for

1401
00:54:12,400 --> 00:54:14,000
watching from me

1402
00:54:14,000 --> 00:54:15,680
thanks hope you enjoyed this and as far

1403
00:54:15,680 --> 00:54:17,520
as i said

1404
00:54:17,520 --> 00:54:20,160
feel free to visit my blog and see see

1405
00:54:20,160 --> 00:54:20,960
more of

1406
00:54:20,960 --> 00:54:23,440
stuff like this if you like this okay

1407
00:54:23,440 --> 00:54:25,839
see you guys

1408
00:54:26,359 --> 00:54:29,359
goodbye

