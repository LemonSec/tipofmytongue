1
00:00:02,080 --> 00:00:04,160
hi my name is joe rosner

2
00:00:04,160 --> 00:00:08,240
this is attacking esp-based products

3
00:00:08,480 --> 00:00:10,719
so what are we doing here today this is

4
00:00:10,719 --> 00:00:12,000
really meant to distill

5
00:00:12,000 --> 00:00:14,639
a whole bunch of content that's been

6
00:00:14,639 --> 00:00:16,800
created over the last few years

7
00:00:16,800 --> 00:00:18,320
you're not going to see any crazy odays

8
00:00:18,320 --> 00:00:20,160
here all of this information

9
00:00:20,160 --> 00:00:22,960
is available by reading the docs or code

10
00:00:22,960 --> 00:00:23,439
or

11
00:00:23,439 --> 00:00:25,279
a bunch of other research that's been

12
00:00:25,279 --> 00:00:27,439
presented in other places

13
00:00:27,439 --> 00:00:29,439
this is really meant to make it a much

14
00:00:29,439 --> 00:00:30,960
more approachable subject

15
00:00:30,960 --> 00:00:33,280
so that anyone who wants to can start

16
00:00:33,280 --> 00:00:34,640
diving into this ecosystem

17
00:00:34,640 --> 00:00:37,040
and learning how to attack espressif

18
00:00:37,040 --> 00:00:38,000
based products

19
00:00:38,000 --> 00:00:39,360
from whichever product family you're

20
00:00:39,360 --> 00:00:41,760
looking at

21
00:00:41,920 --> 00:00:44,640
mostly this is about reverse engineering

22
00:00:44,640 --> 00:00:45,520
and not

23
00:00:45,520 --> 00:00:47,760
super focused on hardware specific

24
00:00:47,760 --> 00:00:49,039
attacks though we

25
00:00:49,039 --> 00:00:52,160
will be looking at some hardware attacks

26
00:00:52,160 --> 00:00:55,920
later on while the title is

27
00:00:55,920 --> 00:00:58,160
mostly focused on esp32 that is the

28
00:00:58,160 --> 00:00:59,600
topic we're going to be covering

29
00:00:59,600 --> 00:01:01,359
a lot of this will apply across the

30
00:01:01,359 --> 00:01:02,960
entire product family

31
00:01:02,960 --> 00:01:06,159
to the esp8266 as well as some of the

32
00:01:06,159 --> 00:01:07,840
newer esp32s

33
00:01:07,840 --> 00:01:09,119
that are not based on the older

34
00:01:09,119 --> 00:01:11,200
architecture

35
00:01:11,200 --> 00:01:13,439
this isn't a junk hacking talk but you

36
00:01:13,439 --> 00:01:15,200
too can be a junk hacker

37
00:01:15,200 --> 00:01:16,880
once you start playing with this stuff

38
00:01:16,880 --> 00:01:19,360
and learning how it works

39
00:01:19,360 --> 00:01:21,759
a lot of this is going to be general

40
00:01:21,759 --> 00:01:23,680
techniques that you can apply

41
00:01:23,680 --> 00:01:26,400
whenever looking at any kind of product

42
00:01:26,400 --> 00:01:28,320
that is based on this chip

43
00:01:28,320 --> 00:01:32,479
or family of chips that uses it

44
00:01:33,119 --> 00:01:35,920
so i said this wasn't a junk hacking

45
00:01:35,920 --> 00:01:36,560
talk

46
00:01:36,560 --> 00:01:39,360
so why are we looking at junk i needed a

47
00:01:39,360 --> 00:01:40,079
real target

48
00:01:40,079 --> 00:01:43,520
so that i could make this really fit and

49
00:01:43,520 --> 00:01:45,280
we could look at the specifics of what

50
00:01:45,280 --> 00:01:46,079
it looks like

51
00:01:46,079 --> 00:01:49,840
on a real device so this is our target

52
00:01:49,840 --> 00:01:53,280
the lifx mini bulb there's tons of

53
00:01:53,280 --> 00:01:54,479
information about this on the internet

54
00:01:54,479 --> 00:01:55,520
already

55
00:01:55,520 --> 00:01:57,200
it's been around for a while they're

56
00:01:57,200 --> 00:01:59,040
pretty cheap but it's a really good

57
00:01:59,040 --> 00:02:00,159
platform

58
00:02:00,159 --> 00:02:03,439
to play around with because it's like i

59
00:02:03,439 --> 00:02:04,399
said cheap

60
00:02:04,399 --> 00:02:06,159
so you don't have to worry about

61
00:02:06,159 --> 00:02:08,080
damaging them or ruining

62
00:02:08,080 --> 00:02:10,160
it you can get a handful of them and not

63
00:02:10,160 --> 00:02:12,000
really feel bad

64
00:02:12,000 --> 00:02:15,440
it's also pretty representative of

65
00:02:15,440 --> 00:02:17,680
a lot of different devices you'll see

66
00:02:17,680 --> 00:02:19,599
there's not a lot of security enabled by

67
00:02:19,599 --> 00:02:20,800
default which

68
00:02:20,800 --> 00:02:22,879
is pretty normal anyway but it means

69
00:02:22,879 --> 00:02:26,319
that it's easy to get started with

70
00:02:26,560 --> 00:02:29,599
so what is the esp32 well

71
00:02:29,599 --> 00:02:31,840
it's a really low cost batteries

72
00:02:31,840 --> 00:02:33,200
included platform

73
00:02:33,200 --> 00:02:35,599
created by espressif espressif is the

74
00:02:35,599 --> 00:02:36,879
manufacturer of

75
00:02:36,879 --> 00:02:40,160
the chip but the architecture itself

76
00:02:40,160 --> 00:02:42,560
is actually created by someone else it

77
00:02:42,560 --> 00:02:43,599
was originally created

78
00:02:43,599 --> 00:02:46,160
by tensilica then they created the

79
00:02:46,160 --> 00:02:47,200
extensa

80
00:02:47,200 --> 00:02:49,040
instruction architecture and it's now

81
00:02:49,040 --> 00:02:50,239
owned by cadence

82
00:02:50,239 --> 00:02:52,720
cadence licenses the technology to

83
00:02:52,720 --> 00:02:54,560
espressif and espresso builds this

84
00:02:54,560 --> 00:02:56,400
platform

85
00:02:56,400 --> 00:03:00,239
it's a 32-bit architecture both the code

86
00:03:00,239 --> 00:03:02,480
and data are 32-bit addressable

87
00:03:02,480 --> 00:03:04,239
and it's a hardware architecture meaning

88
00:03:04,239 --> 00:03:05,920
that there's a split between

89
00:03:05,920 --> 00:03:07,840
code and data and you're going to have

90
00:03:07,840 --> 00:03:09,760
some different instructions

91
00:03:09,760 --> 00:03:11,680
to work with either if you've never

92
00:03:11,680 --> 00:03:12,800
worked with these before

93
00:03:12,800 --> 00:03:13,840
it's a little bit different than what

94
00:03:13,840 --> 00:03:15,760
you'd typically expect from say an

95
00:03:15,760 --> 00:03:17,519
intel-based architecture

96
00:03:17,519 --> 00:03:19,760
but once you get used to it it's not all

97
00:03:19,760 --> 00:03:21,519
that crazy

98
00:03:21,519 --> 00:03:24,560
the one caveat to this is that

99
00:03:24,560 --> 00:03:26,640
a lot of the stuff you typically see

100
00:03:26,640 --> 00:03:28,560
from say shell code on a

101
00:03:28,560 --> 00:03:30,799
intel architecture you won't necessarily

102
00:03:30,799 --> 00:03:32,400
get to use here

103
00:03:32,400 --> 00:03:34,159
because you won't always be able to just

104
00:03:34,159 --> 00:03:35,519
drop

105
00:03:35,519 --> 00:03:38,640
a code onto the stack somewhere that can

106
00:03:38,640 --> 00:03:40,640
be executed because the code and data is

107
00:03:40,640 --> 00:03:43,040
separate

108
00:03:43,519 --> 00:03:46,159
starting out espressif the chip that

109
00:03:46,159 --> 00:03:47,280
really got them famous

110
00:03:47,280 --> 00:03:50,560
was the esp8266 and its derivatives

111
00:03:50,560 --> 00:03:52,720
this was a wi-fi only chip and it gained

112
00:03:52,720 --> 00:03:54,239
popularity in the

113
00:03:54,239 --> 00:03:57,760
uh early 2010s the esp32 which

114
00:03:57,760 --> 00:04:00,319
a lot of more modern stuff has now this

115
00:04:00,319 --> 00:04:02,640
supplies both wi-fi and bluetooth

116
00:04:02,640 --> 00:04:07,359
this came out in 2016 as the successor

117
00:04:08,000 --> 00:04:09,040
and we're going to be looking at all of

118
00:04:09,040 --> 00:04:11,280
these

119
00:04:11,920 --> 00:04:13,360
so i mentioned there were a handful of

120
00:04:13,360 --> 00:04:15,599
different families uh and i gave a

121
00:04:15,599 --> 00:04:17,040
little bit of information about them but

122
00:04:17,040 --> 00:04:19,040
this will dive a little bit more in

123
00:04:19,040 --> 00:04:21,600
so we mentioned that the a266 is wi-fi

124
00:04:21,600 --> 00:04:22,400
only

125
00:04:22,400 --> 00:04:25,440
this was originally built with a uh

126
00:04:25,440 --> 00:04:28,479
a t like the modem command set and

127
00:04:28,479 --> 00:04:30,000
basically what this was used for

128
00:04:30,000 --> 00:04:30,880
primarily

129
00:04:30,880 --> 00:04:33,759
was a really easy way to cheaply add

130
00:04:33,759 --> 00:04:34,400
wi-fi

131
00:04:34,400 --> 00:04:37,600
to embedded products they sold them as

132
00:04:37,600 --> 00:04:38,800
little modules

133
00:04:38,800 --> 00:04:40,160
and you didn't have to write any code

134
00:04:40,160 --> 00:04:42,160
you just could write

135
00:04:42,160 --> 00:04:45,440
code that talked the at command set

136
00:04:45,440 --> 00:04:47,680
and it would speak it over uart and you

137
00:04:47,680 --> 00:04:49,120
could send data back and forth

138
00:04:49,120 --> 00:04:51,680
over the internet and so your product

139
00:04:51,680 --> 00:04:52,800
and your

140
00:04:52,800 --> 00:04:54,800
device didn't have to be wi-fi enabled

141
00:04:54,800 --> 00:04:56,720
but this could make it

142
00:04:56,720 --> 00:04:59,759
it uses a vastly different

143
00:04:59,759 --> 00:05:03,360
sdk than the 32 families

144
00:05:03,360 --> 00:05:07,360
do but it's fairly similar

145
00:05:07,360 --> 00:05:09,280
and i think that has also increased a

146
00:05:09,280 --> 00:05:11,600
lot in terms of capability

147
00:05:11,600 --> 00:05:13,680
as the esp-idf which we'll dive into in

148
00:05:13,680 --> 00:05:16,560
a little bit has expanded

149
00:05:16,560 --> 00:05:20,960
the esp32 is the

150
00:05:20,960 --> 00:05:22,840
the first of this family of the 32

151
00:05:22,840 --> 00:05:24,240
processors

152
00:05:24,240 --> 00:05:27,360
it's based on the lc6 which is the

153
00:05:27,360 --> 00:05:30,160
tensilica core and it comes in either

154
00:05:30,160 --> 00:05:31,759
singular dual core and these are

155
00:05:31,759 --> 00:05:33,919
super high performance you're talking up

156
00:05:33,919 --> 00:05:36,080
to 240 megahertz

157
00:05:36,080 --> 00:05:39,680
with you know 16 megs of ram at the top

158
00:05:39,680 --> 00:05:42,240
uh or flash and about eight megs of ram

159
00:05:42,240 --> 00:05:42,880
uh if you go

160
00:05:42,880 --> 00:05:44,400
like all the way up so these are these

161
00:05:44,400 --> 00:05:47,120
are pretty beefy processors

162
00:05:47,120 --> 00:05:49,039
the 32 introduced both wi-fi and

163
00:05:49,039 --> 00:05:50,960
bluetooth as opposed to

164
00:05:50,960 --> 00:05:53,120
just wi-fi and it includes this

165
00:05:53,120 --> 00:05:54,320
additional ulp or

166
00:05:54,320 --> 00:05:56,639
ultra low power core i believe that this

167
00:05:56,639 --> 00:05:57,680
is risk five

168
00:05:57,680 --> 00:05:59,600
it's really good if you want to have

169
00:05:59,600 --> 00:06:03,039
your main esp32 asleep and do some work

170
00:06:03,039 --> 00:06:04,240
you're probably not going to see this in

171
00:06:04,240 --> 00:06:06,160
a lot of these low end iot devices

172
00:06:06,160 --> 00:06:08,000
unless they're running on battery

173
00:06:08,000 --> 00:06:09,360
but they are there and there's a lot of

174
00:06:09,360 --> 00:06:11,919
really cool stuff you can do with it

175
00:06:11,919 --> 00:06:14,479
earlier versions of this specific chip

176
00:06:14,479 --> 00:06:16,639
we're also vulnerable to fault injection

177
00:06:16,639 --> 00:06:17,919
we're going to come up to that a little

178
00:06:17,919 --> 00:06:19,600
bit later on and this is the hardware

179
00:06:19,600 --> 00:06:21,520
attacks that i was talking about

180
00:06:21,520 --> 00:06:24,400
the secure boot process for this has

181
00:06:24,400 --> 00:06:26,000
been completely broken

182
00:06:26,000 --> 00:06:29,039
and you're able to defeat both code code

183
00:06:29,039 --> 00:06:30,240
readout protection

184
00:06:30,240 --> 00:06:33,680
as well as uh extract the

185
00:06:33,680 --> 00:06:37,039
key material used to sign the

186
00:06:37,039 --> 00:06:39,199
firmware images this has since been

187
00:06:39,199 --> 00:06:41,039
fixed i believe in the silicon

188
00:06:41,039 --> 00:06:43,440
in newer revisions but a lot of devices

189
00:06:43,440 --> 00:06:45,039
are still using these old

190
00:06:45,039 --> 00:06:46,560
chips and so you might be able to still

191
00:06:46,560 --> 00:06:49,840
use these

192
00:06:51,039 --> 00:06:53,440
the esp32s this is one of the newer

193
00:06:53,440 --> 00:06:54,240
chips

194
00:06:54,240 --> 00:06:56,080
and it added a lot of nice things like

195
00:06:56,080 --> 00:06:57,520
built-in usb

196
00:06:57,520 --> 00:06:59,840
the original 32 is uart only and so you

197
00:06:59,840 --> 00:07:01,280
had to add in your own

198
00:07:01,280 --> 00:07:04,400
usb chips that you wanted to communicate

199
00:07:04,400 --> 00:07:06,800
it i believe has support for talking usb

200
00:07:06,800 --> 00:07:08,080
directly to the bootloader meaning you

201
00:07:08,080 --> 00:07:09,919
don't need that extra chip

202
00:07:09,919 --> 00:07:12,000
and this also is resistant against the

203
00:07:12,000 --> 00:07:13,520
fault injection attacks

204
00:07:13,520 --> 00:07:16,560
mentioned in the esp32

205
00:07:16,560 --> 00:07:19,000
the newest part of the family is this

206
00:07:19,000 --> 00:07:21,039
esp32c line

207
00:07:21,039 --> 00:07:22,240
this is where i think a lot of the

208
00:07:22,240 --> 00:07:24,319
really interesting stuff is coming it's

209
00:07:24,319 --> 00:07:26,479
all based on risk 5.

210
00:07:26,479 --> 00:07:29,280
it's pin compatible with a266 meaning

211
00:07:29,280 --> 00:07:30,400
it's designed to be a drop in

212
00:07:30,400 --> 00:07:31,840
replacement

213
00:07:31,840 --> 00:07:34,000
it's currently single core only but it's

214
00:07:34,000 --> 00:07:35,919
compatible with the same sdk

215
00:07:35,919 --> 00:07:38,479
that you would use on the 32 and the 32s

216
00:07:38,479 --> 00:07:39,840
meaning a lot of your code

217
00:07:39,840 --> 00:07:41,840
should relatively easily be able to be

218
00:07:41,840 --> 00:07:43,199
ported over

219
00:07:43,199 --> 00:07:45,120
these just came out and they're just

220
00:07:45,120 --> 00:07:46,879
available now

221
00:07:46,879 --> 00:07:48,080
so you can start playing with these if

222
00:07:48,080 --> 00:07:50,560
you're interested

223
00:07:51,840 --> 00:07:53,440
so i mentioned a little bit why why

224
00:07:53,440 --> 00:07:56,560
these are used really it comes down to

225
00:07:56,560 --> 00:07:59,120
ease of use for adding wi-fi and just

226
00:07:59,120 --> 00:08:00,479
they're super cheap

227
00:08:00,479 --> 00:08:01,680
a lot of these chips are gonna be in the

228
00:08:01,680 --> 00:08:03,520
three to five dollar range uh

229
00:08:03,520 --> 00:08:06,319
at quantity uh in low quantity or in

230
00:08:06,319 --> 00:08:07,919
quantity i don't think you get much of a

231
00:08:07,919 --> 00:08:09,280
uh a price break on it just because

232
00:08:09,280 --> 00:08:10,479
they're so cheap

233
00:08:10,479 --> 00:08:12,080
but you get all this uh all this

234
00:08:12,080 --> 00:08:14,080
connectivity and tons of peripherals

235
00:08:14,080 --> 00:08:16,000
meaning that you don't need to

236
00:08:16,000 --> 00:08:18,960
add a bunch of extra ics when you buy

237
00:08:18,960 --> 00:08:20,639
this sock you pretty much get everything

238
00:08:20,639 --> 00:08:21,360
you need

239
00:08:21,360 --> 00:08:26,560
except for a crystal and power

240
00:08:26,560 --> 00:08:28,240
i already mentioned the performance of

241
00:08:28,240 --> 00:08:30,000
them super high performance

242
00:08:30,000 --> 00:08:33,039
you're getting into low power pc uh

243
00:08:33,039 --> 00:08:35,838
state right here

244
00:08:36,799 --> 00:08:39,679
now let's talk about distribution so you

245
00:08:39,679 --> 00:08:40,399
can of course

246
00:08:40,399 --> 00:08:42,000
buy the individual chips yourself and

247
00:08:42,000 --> 00:08:43,839
sometimes you'll see these on

248
00:08:43,839 --> 00:08:46,320
low end devices but you're probably not

249
00:08:46,320 --> 00:08:47,839
going to see them very often

250
00:08:47,839 --> 00:08:49,120
a lot of the time what you're going to

251
00:08:49,120 --> 00:08:51,440
see is these types of modules

252
00:08:51,440 --> 00:08:53,360
they have cast lighted edges on the end

253
00:08:53,360 --> 00:08:55,200
so you can grab these chips and you can

254
00:08:55,200 --> 00:08:56,640
drop them in place

255
00:08:56,640 --> 00:08:58,080
the nice thing about these and why

256
00:08:58,080 --> 00:09:00,240
they're used so commonly

257
00:09:00,240 --> 00:09:02,240
is that they're low cost you're not

258
00:09:02,240 --> 00:09:03,760
really paying much more

259
00:09:03,760 --> 00:09:05,839
to get one of these modules as you are

260
00:09:05,839 --> 00:09:07,680
for the individual chip

261
00:09:07,680 --> 00:09:09,279
but it comes with pretty much everything

262
00:09:09,279 --> 00:09:11,040
you need

263
00:09:11,040 --> 00:09:14,000
it has your external flash on it it can

264
00:09:14,000 --> 00:09:15,440
have ram if you buy the

265
00:09:15,440 --> 00:09:19,040
higher end modules standardized as a pin

266
00:09:19,040 --> 00:09:19,600
out

267
00:09:19,600 --> 00:09:22,000
it gets you all of the rf because the

268
00:09:22,000 --> 00:09:23,440
antenna is included here

269
00:09:23,440 --> 00:09:25,920
and it's fcc certified ce certified

270
00:09:25,920 --> 00:09:26,720
typically

271
00:09:26,720 --> 00:09:27,920
so you don't have to go through as much

272
00:09:27,920 --> 00:09:29,120
of that if you're building a low end

273
00:09:29,120 --> 00:09:31,440
product

274
00:09:31,440 --> 00:09:33,839
you'll see here the rf shield on top

275
00:09:33,839 --> 00:09:35,440
it'll have some markings which helps

276
00:09:35,440 --> 00:09:36,640
identify

277
00:09:36,640 --> 00:09:38,240
which is nice for us as reverse

278
00:09:38,240 --> 00:09:40,240
engineers

279
00:09:40,240 --> 00:09:41,839
if you pull it off this is what's on the

280
00:09:41,839 --> 00:09:44,560
inside as i mentioned you have the chip

281
00:09:44,560 --> 00:09:45,360
itself

282
00:09:45,360 --> 00:09:47,040
there's a crystal there a bunch of

283
00:09:47,040 --> 00:09:49,839
passives and our flash

284
00:09:49,839 --> 00:09:51,519
and if you have the ram on there you'll

285
00:09:51,519 --> 00:09:53,120
see it as well

286
00:09:53,120 --> 00:09:54,640
but you know it's pretty it's pretty

287
00:09:54,640 --> 00:09:56,640
small it's all that's really in there

288
00:09:56,640 --> 00:09:58,000
and then of course on the left hand side

289
00:09:58,000 --> 00:10:00,320
here you have the antenna

290
00:10:00,320 --> 00:10:04,000
for both bluetooth and wi-fi

291
00:10:04,000 --> 00:10:05,920
how do you write code for this thing

292
00:10:05,920 --> 00:10:07,360
well there's a bunch of different

293
00:10:07,360 --> 00:10:08,720
environments

294
00:10:08,720 --> 00:10:11,760
uh freertos is one of them and this is

295
00:10:11,760 --> 00:10:12,880
what you're probably gonna see

296
00:10:12,880 --> 00:10:16,320
most often for a lot of enterprise uh or

297
00:10:16,320 --> 00:10:17,440
products that you're gonna be seeing

298
00:10:17,440 --> 00:10:19,680
built for a lot of the makers and

299
00:10:19,680 --> 00:10:22,480
and uh individuals circuit python

300
00:10:22,480 --> 00:10:24,000
arduino nodemcu

301
00:10:24,000 --> 00:10:26,640
all available

302
00:10:27,200 --> 00:10:29,360
so mostly what we're gonna focus on for

303
00:10:29,360 --> 00:10:31,279
today is looking at the free rtos

304
00:10:31,279 --> 00:10:32,000
implementation

305
00:10:32,000 --> 00:10:35,040
which is distributed as the esp-idf

306
00:10:35,040 --> 00:10:36,640
and we're mostly focusing on that just

307
00:10:36,640 --> 00:10:38,480
because it's what's going to be

308
00:10:38,480 --> 00:10:41,760
most usually used in development of a

309
00:10:41,760 --> 00:10:43,760
real product

310
00:10:43,760 --> 00:10:46,240
so if you've never used an rtos before

311
00:10:46,240 --> 00:10:46,880
it's

312
00:10:46,880 --> 00:10:49,440
somewhere between writing specific

313
00:10:49,440 --> 00:10:50,880
low-level firmware

314
00:10:50,880 --> 00:10:53,600
and having a full os so they'll

315
00:10:53,600 --> 00:10:54,959
typically introduce

316
00:10:54,959 --> 00:10:57,360
high-level os like abstractions such as

317
00:10:57,360 --> 00:10:58,079
having

318
00:10:58,079 --> 00:11:02,399
file system uh apis network apis

319
00:11:02,399 --> 00:11:05,040
tasks or threads the same kind of apis

320
00:11:05,040 --> 00:11:07,120
you might use on say linux

321
00:11:07,120 --> 00:11:09,680
but it's all done in real time and you

322
00:11:09,680 --> 00:11:12,320
get to use this on this embedded device

323
00:11:12,320 --> 00:11:14,560
as i mentioned espressif provides

324
00:11:14,560 --> 00:11:17,200
freertos which is one of these r tosses

325
00:11:17,200 --> 00:11:20,800
uh as the esp-idf or iot development

326
00:11:20,800 --> 00:11:23,040
framework i believe

327
00:11:23,040 --> 00:11:25,760
you can get the most recent version uh

328
00:11:25,760 --> 00:11:27,360
from the links below here

329
00:11:27,360 --> 00:11:30,000
as well as api documentation and

330
00:11:30,000 --> 00:11:31,600
instructions for how to install it

331
00:11:31,600 --> 00:11:32,560
and we're going to have to do this

332
00:11:32,560 --> 00:11:35,360
shortly but it's pretty straightforward

333
00:11:35,360 --> 00:11:38,560
especially in the newer versions

334
00:11:38,560 --> 00:11:40,800
so what does this mean for us as people

335
00:11:40,800 --> 00:11:42,959
that are attacking these devices

336
00:11:42,959 --> 00:11:44,640
well it means that things are going to

337
00:11:44,640 --> 00:11:46,160
be a lot more standardized

338
00:11:46,160 --> 00:11:48,880
if everyone is using the same sdk and

339
00:11:48,880 --> 00:11:49,680
the same

340
00:11:49,680 --> 00:11:51,600
framework we're going to be able to make

341
00:11:51,600 --> 00:11:53,279
some assumptions about what things look

342
00:11:53,279 --> 00:11:54,880
like

343
00:11:54,880 --> 00:11:56,079
we're likely going to be able to build

344
00:11:56,079 --> 00:11:57,920
tooling that works across

345
00:11:57,920 --> 00:11:59,600
multiple products because it will work

346
00:11:59,600 --> 00:12:01,200
for the entire platform

347
00:12:01,200 --> 00:12:02,880
rather than having to target a specific

348
00:12:02,880 --> 00:12:05,360
device and building special tools just

349
00:12:05,360 --> 00:12:06,959
for it

350
00:12:06,959 --> 00:12:08,560
but it also means that this is going to

351
00:12:08,560 --> 00:12:10,959
be a lot more abstract

352
00:12:10,959 --> 00:12:14,240
the esp idf itself is huge there's tons

353
00:12:14,240 --> 00:12:15,440
of libraries

354
00:12:15,440 --> 00:12:17,839
it has a hal or a hardware abstraction

355
00:12:17,839 --> 00:12:18,480
layer

356
00:12:18,480 --> 00:12:21,040
that allows it to work across different

357
00:12:21,040 --> 00:12:22,800
variations of the chip

358
00:12:22,800 --> 00:12:24,000
and so that's going to mean a lot more

359
00:12:24,000 --> 00:12:26,160
code for us to dig through to find the

360
00:12:26,160 --> 00:12:28,399
relevant parts that we care about

361
00:12:28,399 --> 00:12:29,839
and so we're going to have much bigger

362
00:12:29,839 --> 00:12:31,440
firmware images than you would get

363
00:12:31,440 --> 00:12:33,760
by simply writing very specific code

364
00:12:33,760 --> 00:12:39,360
that targets that specific chip

365
00:12:39,360 --> 00:12:41,440
i mentioned we set up an environment and

366
00:12:41,440 --> 00:12:43,040
we can do that

367
00:12:43,040 --> 00:12:45,279
i'm not going to go through it here uh

368
00:12:45,279 --> 00:12:47,839
but it's pretty straightforward

369
00:12:47,839 --> 00:12:49,920
the link here the getting started guide

370
00:12:49,920 --> 00:12:51,200
is really

371
00:12:51,200 --> 00:12:52,399
what you're going to want to follow and

372
00:12:52,399 --> 00:12:54,480
it's going to install all the tooling

373
00:12:54,480 --> 00:12:56,959
that you're going to need most of the

374
00:12:56,959 --> 00:12:58,399
tooling itself

375
00:12:58,399 --> 00:13:01,040
you will not have to have specific to

376
00:13:01,040 --> 00:13:02,639
the

377
00:13:02,639 --> 00:13:05,040
version of the esp-idf that you're

378
00:13:05,040 --> 00:13:06,959
attacking but some of the specific

379
00:13:06,959 --> 00:13:09,200
tooling you may

380
00:13:09,200 --> 00:13:10,880
if you're attacking a product that's

381
00:13:10,880 --> 00:13:12,399
built on

382
00:13:12,399 --> 00:13:15,519
version 4 or above all of the tooling is

383
00:13:15,519 --> 00:13:16,480
very simple

384
00:13:16,480 --> 00:13:18,399
and there's a lot of scripts that manage

385
00:13:18,399 --> 00:13:20,240
it for you going beyond

386
00:13:20,240 --> 00:13:22,320
three you're gonna have to do a little

387
00:13:22,320 --> 00:13:23,760
bit more manual work

388
00:13:23,760 --> 00:13:25,519
because they rebuilt the entire build

389
00:13:25,519 --> 00:13:27,120
system and all the tooling

390
00:13:27,120 --> 00:13:34,720
as the transition from three to four

391
00:13:34,720 --> 00:13:36,959
so let's talk about connectivity so

392
00:13:36,959 --> 00:13:38,720
there's two main ways

393
00:13:38,720 --> 00:13:39,839
that you're going to interact with a

394
00:13:39,839 --> 00:13:43,519
device that you have under test

395
00:13:45,199 --> 00:13:48,720
the first is through the uart uh the ur

396
00:13:48,720 --> 00:13:52,160
is your serial console and all of these

397
00:13:52,160 --> 00:13:54,320
chips have a built-in bootloader

398
00:13:54,320 --> 00:13:57,360
and this bootloader makes getting code

399
00:13:57,360 --> 00:13:58,880
and interacting with the device really

400
00:13:58,880 --> 00:14:01,040
easy

401
00:14:01,040 --> 00:14:03,279
programming itself is usually done over

402
00:14:03,279 --> 00:14:04,240
the boot loader

403
00:14:04,240 --> 00:14:06,079
so you don't really need a lot of social

404
00:14:06,079 --> 00:14:08,240
tooling or programmers or software to do

405
00:14:08,240 --> 00:14:10,399
this

406
00:14:11,199 --> 00:14:13,120
almost always the bootloader is never

407
00:14:13,120 --> 00:14:14,560
going to be locked

408
00:14:14,560 --> 00:14:17,120
none of the devices i've ever interacted

409
00:14:17,120 --> 00:14:18,160
with that i've ever

410
00:14:18,160 --> 00:14:20,000
bought online have ever had a locked

411
00:14:20,000 --> 00:14:21,760
bootloader i've always been able to

412
00:14:21,760 --> 00:14:23,600
extract the firmware and i looked at it

413
00:14:23,600 --> 00:14:26,399
you know a decent amount

414
00:14:26,399 --> 00:14:28,399
the bootloader itself is pretty full

415
00:14:28,399 --> 00:14:30,399
featured and it can be patched which is

416
00:14:30,399 --> 00:14:31,199
nice because

417
00:14:31,199 --> 00:14:32,880
if we wanted to we could add more

418
00:14:32,880 --> 00:14:35,120
functionality in

419
00:14:35,120 --> 00:14:37,279
the host based tooling is very good

420
00:14:37,279 --> 00:14:39,600
there's a tool called esp-idf that comes

421
00:14:39,600 --> 00:14:41,199
with

422
00:14:41,199 --> 00:14:44,560
our esp tool that comes with the esp idf

423
00:14:44,560 --> 00:14:46,079
and this is what you use primarily for

424
00:14:46,079 --> 00:14:47,839
interacting with the chip

425
00:14:47,839 --> 00:14:49,040
we'll get a little bit more into that

426
00:14:49,040 --> 00:14:51,680
soon there's also idf.pi

427
00:14:51,680 --> 00:14:54,560
and this is the build system that will

428
00:14:54,560 --> 00:14:57,040
launch a lot of the

429
00:14:57,040 --> 00:14:58,959
interactivity that we want to use under

430
00:14:58,959 --> 00:15:02,880
the hood it uses the esp tool

431
00:15:02,880 --> 00:15:04,720
for actually connecting to the serial

432
00:15:04,720 --> 00:15:06,880
console or uart you can use any typical

433
00:15:06,880 --> 00:15:07,519
tool

434
00:15:07,519 --> 00:15:11,880
screen picocom etc they all work

435
00:15:11,880 --> 00:15:14,959
idf.pi also has a monitor sub command

436
00:15:14,959 --> 00:15:16,560
and this will do that as well but it

437
00:15:16,560 --> 00:15:18,399
also provides some additional

438
00:15:18,399 --> 00:15:21,040
uh functionality such as doing a

439
00:15:21,040 --> 00:15:23,120
software reboot of the device so if you

440
00:15:23,120 --> 00:15:24,480
needed to restart it and get it into

441
00:15:24,480 --> 00:15:25,680
bootloader mode

442
00:15:25,680 --> 00:15:28,320
or if you wanted to reflash firmware on

443
00:15:28,320 --> 00:15:28,720
it

444
00:15:28,720 --> 00:15:29,839
it'll provide some additional

445
00:15:29,839 --> 00:15:32,160
functionality that your typical

446
00:15:32,160 --> 00:15:36,319
uart or screen program will not do

447
00:15:37,120 --> 00:15:39,680
the other option is jtag there are

448
00:15:39,680 --> 00:15:41,199
protections on here so this can be

449
00:15:41,199 --> 00:15:42,480
disabled

450
00:15:42,480 --> 00:15:45,040
um again i've never actually had to use

451
00:15:45,040 --> 00:15:46,480
this because i've never had problems

452
00:15:46,480 --> 00:15:47,519
interacting

453
00:15:47,519 --> 00:15:51,519
directly with the bootloader the uh

454
00:15:51,519 --> 00:15:53,839
communication is all available via

455
00:15:53,839 --> 00:15:54,880
openocd

456
00:15:54,880 --> 00:15:57,279
you don't need any special hardware

457
00:15:57,279 --> 00:15:58,880
anything you're going to use for the

458
00:15:58,880 --> 00:16:00,800
serial console probably will work fine

459
00:16:00,800 --> 00:16:04,800
assuming it's a ftdi-based board

460
00:16:04,800 --> 00:16:07,040
so i tend to use a lot of the fti stuff

461
00:16:07,040 --> 00:16:08,480
just because they're pretty handy and

462
00:16:08,480 --> 00:16:12,079
i know that they work on every os

463
00:16:12,639 --> 00:16:13,920
and i have a few recommendations for

464
00:16:13,920 --> 00:16:17,120
those we'll get to a little bit

465
00:16:17,680 --> 00:16:20,959
so physical connections are one of the

466
00:16:20,959 --> 00:16:22,160
hardware aspects that we're going to

467
00:16:22,160 --> 00:16:24,160
talk about here

468
00:16:24,160 --> 00:16:26,800
it's pretty common to see uh labeled

469
00:16:26,800 --> 00:16:29,120
pins on these things for whatever reason

470
00:16:29,120 --> 00:16:31,680
a lot of them don't try to abstract it

471
00:16:31,680 --> 00:16:32,160
or

472
00:16:32,160 --> 00:16:34,160
obfuscate it and i don't know if this is

473
00:16:34,160 --> 00:16:35,360
laziness or

474
00:16:35,360 --> 00:16:37,040
it's just not worth it because the cost

475
00:16:37,040 --> 00:16:38,480
of these is so low

476
00:16:38,480 --> 00:16:41,199
um but typically you'll see about six

477
00:16:41,199 --> 00:16:42,320
pins

478
00:16:42,320 --> 00:16:44,720
uh and you'll see a tx and rx that's

479
00:16:44,720 --> 00:16:45,920
your normal

480
00:16:45,920 --> 00:16:49,279
your headers you'll see a vcc and ground

481
00:16:49,279 --> 00:16:52,079
your power then you'll also see an i o

482
00:16:52,079 --> 00:16:52,560
zero

483
00:16:52,560 --> 00:16:55,040
or boot uh and that that corresponds to

484
00:16:55,040 --> 00:16:56,320
the i o zero pin it's one of the

485
00:16:56,320 --> 00:16:57,759
bootstrapping pins

486
00:16:57,759 --> 00:16:59,600
uh and then the en pin which is your

487
00:16:59,600 --> 00:17:01,199
enable pin uh

488
00:17:01,199 --> 00:17:03,839
so when that's high the chip will be

489
00:17:03,839 --> 00:17:05,280
running when it's low the chip will be

490
00:17:05,280 --> 00:17:06,640
off

491
00:17:06,640 --> 00:17:09,439
the i o zero or boot works similarly

492
00:17:09,439 --> 00:17:11,199
when it's high it's in normal boot mode

493
00:17:11,199 --> 00:17:12,160
so it's gonna load

494
00:17:12,160 --> 00:17:14,720
the application that's flashed onto the

495
00:17:14,720 --> 00:17:15,520
device

496
00:17:15,520 --> 00:17:16,880
if it's low it's gonna go into boot

497
00:17:16,880 --> 00:17:18,400
loader mode and wait for you to send

498
00:17:18,400 --> 00:17:19,119
additional

499
00:17:19,119 --> 00:17:21,119
instructions to tell it what to actually

500
00:17:21,119 --> 00:17:22,480
do

501
00:17:22,480 --> 00:17:24,480
unlike arm there's no standardized

502
00:17:24,480 --> 00:17:26,240
headers for this you're going to see all

503
00:17:26,240 --> 00:17:27,359
kinds of

504
00:17:27,359 --> 00:17:29,919
crazy test points and alignments i was

505
00:17:29,919 --> 00:17:31,360
lucky on this device where they're all

506
00:17:31,360 --> 00:17:32,559
kind of in a line

507
00:17:32,559 --> 00:17:35,039
i was able to solder on this header here

508
00:17:35,039 --> 00:17:36,320
sometimes they're more spread out

509
00:17:36,320 --> 00:17:37,679
sometimes they're not

510
00:17:37,679 --> 00:17:41,360
but usually you can

511
00:17:41,360 --> 00:17:43,919
get it set up pretty easily and get it

512
00:17:43,919 --> 00:17:47,840
broken out

513
00:17:49,679 --> 00:17:50,799
the nice thing about this when they're

514
00:17:50,799 --> 00:17:52,480
all lined up is you can get it into a

515
00:17:52,480 --> 00:17:53,120
breadboard

516
00:17:53,120 --> 00:17:56,559
or you can uh

517
00:17:56,559 --> 00:17:58,960
just connect them with some normal

518
00:17:58,960 --> 00:18:00,480
jumper cables

519
00:18:00,480 --> 00:18:03,679
you can see here i'm using a ftdi

520
00:18:03,679 --> 00:18:06,400
ft 232h breakout board this is the

521
00:18:06,400 --> 00:18:07,520
adafruit one

522
00:18:07,520 --> 00:18:09,360
i used to recommend these a lot because

523
00:18:09,360 --> 00:18:11,039
they were really easy to work with

524
00:18:11,039 --> 00:18:13,520
the only problem with them is that they

525
00:18:13,520 --> 00:18:14,480
only have

526
00:18:14,480 --> 00:18:18,400
uh 5 volt power exposed on them and

527
00:18:18,400 --> 00:18:19,440
there's no

528
00:18:19,440 --> 00:18:22,400
voltage regulator on it that is broken

529
00:18:22,400 --> 00:18:23,280
out

530
00:18:23,280 --> 00:18:26,320
and part of the problem is you need to

531
00:18:26,320 --> 00:18:28,720
power all these chips with 3.3 volts

532
00:18:28,720 --> 00:18:31,360
they're not 5 volt tolerant typically

533
00:18:31,360 --> 00:18:34,320
and so uh it's one of the reasons why i

534
00:18:34,320 --> 00:18:35,679
recommended these was they were really

535
00:18:35,679 --> 00:18:37,039
easy to get a hold of and they were

536
00:18:37,039 --> 00:18:38,559
cheap and they worked really well

537
00:18:38,559 --> 00:18:40,799
the logic levels were all 3.3 volts and

538
00:18:40,799 --> 00:18:42,320
all you had to do was stick a uh

539
00:18:42,320 --> 00:18:46,000
a voltage regulator regulator on it

540
00:18:46,000 --> 00:18:47,919
um this will work pretty well if you

541
00:18:47,919 --> 00:18:49,600
have these around go for it

542
00:18:49,600 --> 00:18:52,480
um but what i really like these days is

543
00:18:52,480 --> 00:18:53,600
this uh

544
00:18:53,600 --> 00:18:55,520
this tiger board uh this is something

545
00:18:55,520 --> 00:18:57,200
that joe fitz

546
00:18:57,200 --> 00:19:00,880
built and is selling this uses the 2232

547
00:19:00,880 --> 00:19:02,559
which is nice because it has two

548
00:19:02,559 --> 00:19:04,640
different channels on it so if you

549
00:19:04,640 --> 00:19:06,400
want to have uart and jtag going at the

550
00:19:06,400 --> 00:19:10,080
same time you have that available the

551
00:19:10,080 --> 00:19:10,960
one thing that

552
00:19:10,960 --> 00:19:14,160
any of these boards will not have

553
00:19:14,160 --> 00:19:16,080
and what you're going to need is going

554
00:19:16,080 --> 00:19:18,240
to be the auto reset circuitry

555
00:19:18,240 --> 00:19:19,200
this is something that you're going to

556
00:19:19,200 --> 00:19:22,799
see on any dev board that is

557
00:19:22,799 --> 00:19:26,000
for the esp32 and what this does is it

558
00:19:26,000 --> 00:19:27,280
allows you to do

559
00:19:27,280 --> 00:19:30,799
the reset logic uh from software

560
00:19:30,799 --> 00:19:34,559
um and so most of the time you're not

561
00:19:34,559 --> 00:19:36,080
going to see the circuitry built into

562
00:19:36,080 --> 00:19:37,200
the product itself

563
00:19:37,200 --> 00:19:38,240
it'll be on their programming

564
00:19:38,240 --> 00:19:40,320
infrastructure but you're probably going

565
00:19:40,320 --> 00:19:40,799
to want

566
00:19:40,799 --> 00:19:43,280
some kind of replication of this whether

567
00:19:43,280 --> 00:19:44,480
it's in your breadboard or you have a

568
00:19:44,480 --> 00:19:45,840
dedicated programmer

569
00:19:45,840 --> 00:19:47,760
or a hat or a cape whatever they call

570
00:19:47,760 --> 00:19:50,720
them for the different boards

571
00:19:50,720 --> 00:19:52,480
but basically all you need is is two

572
00:19:52,480 --> 00:19:53,840
resistors and

573
00:19:53,840 --> 00:19:57,200
two npn transistors um

574
00:19:57,200 --> 00:19:59,520
and just got a wire up like this uh

575
00:19:59,520 --> 00:20:00,640
pretty commonly you'll see

576
00:20:00,640 --> 00:20:04,240
the uh ss 8t 8050s

577
00:20:04,240 --> 00:20:06,720
and these are used a lot on expressive

578
00:20:06,720 --> 00:20:07,840
actual boards

579
00:20:07,840 --> 00:20:11,440
that the 2222as work great too i use

580
00:20:11,440 --> 00:20:12,640
them on mine

581
00:20:12,640 --> 00:20:15,440
uh and i've built a bunch of programmers

582
00:20:15,440 --> 00:20:17,039
uh that'll be available pretty soon if

583
00:20:17,039 --> 00:20:18,080
you're interested

584
00:20:18,080 --> 00:20:21,520
and plan to be releasing a uh a hat

585
00:20:21,520 --> 00:20:23,280
or whatever they're called like stripes

586
00:20:23,280 --> 00:20:25,520
or uh tails for the tiger

587
00:20:25,520 --> 00:20:28,559
it'll just fit on top of its uart uh

588
00:20:28,559 --> 00:20:31,039
headers there and add the additional uh

589
00:20:31,039 --> 00:20:34,880
components you need

590
00:20:34,880 --> 00:20:36,960
so once you connect up you're going to

591
00:20:36,960 --> 00:20:38,240
see something like this

592
00:20:38,240 --> 00:20:42,000
this is the debug output from the uart

593
00:20:42,000 --> 00:20:44,080
uh you'll typically get a lot of really

594
00:20:44,080 --> 00:20:45,440
useful information

595
00:20:45,440 --> 00:20:48,640
and most engineers tend to not remove

596
00:20:48,640 --> 00:20:50,000
that

597
00:20:50,000 --> 00:20:51,360
so you're not going to see it here

598
00:20:51,360 --> 00:20:53,200
because it's already above but it'll

599
00:20:53,200 --> 00:20:54,559
print out information

600
00:20:54,559 --> 00:20:57,760
like where addresses are and where data

601
00:20:57,760 --> 00:21:02,960
has been loaded at

602
00:21:02,960 --> 00:21:05,280
the one really nice thing about this is

603
00:21:05,280 --> 00:21:06,000
it tells us

604
00:21:06,000 --> 00:21:09,520
when the firmware was built which allows

605
00:21:09,520 --> 00:21:10,480
us to

606
00:21:10,480 --> 00:21:14,000
get some information about the revision

607
00:21:14,000 --> 00:21:16,480
of the commit hash that was used for

608
00:21:16,480 --> 00:21:18,000
esp-idf

609
00:21:18,000 --> 00:21:20,480
and that will become important in a

610
00:21:20,480 --> 00:21:22,159
little bit as we dive into the very

611
00:21:22,159 --> 00:21:22,960
specifics

612
00:21:22,960 --> 00:21:25,760
of what the format of various parts of

613
00:21:25,760 --> 00:21:30,000
the firmware look like

614
00:21:30,000 --> 00:21:31,840
when you boot into bootloader mode

615
00:21:31,840 --> 00:21:33,039
you're going to see something like this

616
00:21:33,039 --> 00:21:34,000
and this is how you know it's in

617
00:21:34,000 --> 00:21:35,039
bootloader mode

618
00:21:35,039 --> 00:21:36,720
it's basically telling you that it's

619
00:21:36,720 --> 00:21:38,640
it's waiting to do something

620
00:21:38,640 --> 00:21:42,720
um and so it can vary but the esp tool

621
00:21:42,720 --> 00:21:44,000
is is how you're going to interact

622
00:21:44,000 --> 00:21:46,960
with the device

623
00:21:47,919 --> 00:21:50,400
so using esp tool we can query the chip

624
00:21:50,400 --> 00:21:51,600
we can get a chip id

625
00:21:51,600 --> 00:21:53,200
this will tell us the type of chip that

626
00:21:53,200 --> 00:21:55,440
it is it'll give us the mac address

627
00:21:55,440 --> 00:21:56,799
and tell it just a little bit more

628
00:21:56,799 --> 00:21:59,039
information about it uh this is really

629
00:21:59,039 --> 00:21:59,520
imp

630
00:21:59,520 --> 00:22:01,360
this is really useful if you want to go

631
00:22:01,360 --> 00:22:03,360
and perform any of the hardware attacks

632
00:22:03,360 --> 00:22:05,520
that we'll talk about a little bit later

633
00:22:05,520 --> 00:22:06,799
and let you know whether or not it's

634
00:22:06,799 --> 00:22:09,679
going to be vulnerable

635
00:22:09,760 --> 00:22:12,080
so here we can see it's the mac address

636
00:22:12,080 --> 00:22:12,880
which is useful

637
00:22:12,880 --> 00:22:14,880
if you want to find it on your network

638
00:22:14,880 --> 00:22:16,960
and you don't have

639
00:22:16,960 --> 00:22:19,120
more visibility but we see that it's

640
00:22:19,120 --> 00:22:22,159
revision one of the esp32 d0

641
00:22:22,159 --> 00:22:24,840
wd q6 and this one is vulnerable to that

642
00:22:24,840 --> 00:22:27,840
attack

643
00:22:28,000 --> 00:22:30,880
so now that we have a pretty good

644
00:22:30,880 --> 00:22:32,880
background on this chip and the tooling

645
00:22:32,880 --> 00:22:34,960
and how we want to interact with it

646
00:22:34,960 --> 00:22:36,960
let's dive into the boot process because

647
00:22:36,960 --> 00:22:38,559
this is where it starts to get

648
00:22:38,559 --> 00:22:39,919
interesting and kind of how we're going

649
00:22:39,919 --> 00:22:41,760
to start dissecting

650
00:22:41,760 --> 00:22:43,760
the firmware images that we're going to

651
00:22:43,760 --> 00:22:46,240
pull off

652
00:22:46,400 --> 00:22:49,360
so as the processor boots up if it's in

653
00:22:49,360 --> 00:22:50,480
the normal mode rather than the

654
00:22:50,480 --> 00:22:51,520
bootloader mode

655
00:22:51,520 --> 00:22:53,520
the first thing it's going to do is it

656
00:22:53,520 --> 00:22:54,640
has this boot rom

657
00:22:54,640 --> 00:22:56,400
and the boot rom is what's responsible

658
00:22:56,400 --> 00:22:58,080
for loading up the boot loader

659
00:22:58,080 --> 00:23:01,120
uh and the eventual

660
00:23:01,120 --> 00:23:03,919
application image the boot rom i believe

661
00:23:03,919 --> 00:23:05,120
is

662
00:23:05,120 --> 00:23:08,559
uh in flash on the chip and it is not

663
00:23:08,559 --> 00:23:09,919
something you can patch and that's where

664
00:23:09,919 --> 00:23:12,400
the vulnerability existed i believe

665
00:23:12,400 --> 00:23:14,559
uh in the hardware attacks that we'll

666
00:23:14,559 --> 00:23:16,000
link to later

667
00:23:16,000 --> 00:23:18,640
so it's going to load a partition table

668
00:23:18,640 --> 00:23:19,919
the flash itself

669
00:23:19,919 --> 00:23:22,000
is broken up into partitions and these

670
00:23:22,000 --> 00:23:23,520
are different have different types you

671
00:23:23,520 --> 00:23:25,440
can have multiple applications on there

672
00:23:25,440 --> 00:23:28,240
so if you wanted to do say an ota update

673
00:23:28,240 --> 00:23:30,080
and have space to load a new firmware

674
00:23:30,080 --> 00:23:31,760
image on but still fall back if it

675
00:23:31,760 --> 00:23:32,640
didn't work

676
00:23:32,640 --> 00:23:34,000
or you wanted to have testing

677
00:23:34,000 --> 00:23:35,679
application or just

678
00:23:35,679 --> 00:23:38,320
multiple applications you wanted to run

679
00:23:38,320 --> 00:23:39,919
you can partition it such that you can

680
00:23:39,919 --> 00:23:41,760
have both of those and it can fall back

681
00:23:41,760 --> 00:23:44,240
in certain situations

682
00:23:44,240 --> 00:23:45,679
so it loads that partition table into

683
00:23:45,679 --> 00:23:48,240
memory and it will

684
00:23:48,240 --> 00:23:51,039
read those partitions and look for an

685
00:23:51,039 --> 00:23:52,080
application type

686
00:23:52,080 --> 00:23:55,279
image once it loads that application

687
00:23:55,279 --> 00:23:57,760
it's going to bring it in from flash and

688
00:23:57,760 --> 00:23:58,960
it's going to load them one after

689
00:23:58,960 --> 00:23:59,760
another

690
00:23:59,760 --> 00:24:03,120
until there's none left or one succeeds

691
00:24:03,120 --> 00:24:05,200
once it's loaded in it's going to parse

692
00:24:05,200 --> 00:24:06,320
the application header

693
00:24:06,320 --> 00:24:08,480
you can think of this like an elf header

694
00:24:08,480 --> 00:24:10,480
every application is going to have

695
00:24:10,480 --> 00:24:13,039
its own header that has some information

696
00:24:13,039 --> 00:24:14,720
like the entry point

697
00:24:14,720 --> 00:24:16,320
and some information about the segments

698
00:24:16,320 --> 00:24:17,679
and so it knows how to load it into

699
00:24:17,679 --> 00:24:19,039
memory

700
00:24:19,039 --> 00:24:21,760
once it's grabbed the uh the various

701
00:24:21,760 --> 00:24:23,360
parts in

702
00:24:23,360 --> 00:24:24,640
it's then going to iterate through the

703
00:24:24,640 --> 00:24:26,559
segments loading them in at their load

704
00:24:26,559 --> 00:24:27,279
addresses

705
00:24:27,279 --> 00:24:29,120
so it tells it where to relocate these

706
00:24:29,120 --> 00:24:30,799
chunks to and then it's going to

707
00:24:30,799 --> 00:24:32,559
transfer execution to the entry point of

708
00:24:32,559 --> 00:24:33,360
the application

709
00:24:33,360 --> 00:24:36,720
which it right out of the header so this

710
00:24:36,720 --> 00:24:38,240
is important because it's going to tell

711
00:24:38,240 --> 00:24:39,679
us

712
00:24:39,679 --> 00:24:41,039
how things are booting where they're

713
00:24:41,039 --> 00:24:43,039
booting to and give us a little bit

714
00:24:43,039 --> 00:24:43,679
information

715
00:24:43,679 --> 00:24:45,919
about the flash itself and how to pull

716
00:24:45,919 --> 00:24:48,400
out what we care about

717
00:24:48,400 --> 00:24:50,320
if you're interested at all this is a

718
00:24:50,320 --> 00:24:52,320
call stack of what that looks like

719
00:24:52,320 --> 00:24:54,000
you can go into the code and read it for

720
00:24:54,000 --> 00:24:55,919
yourself this is a little bit dated and

721
00:24:55,919 --> 00:24:57,279
so some of the functions may have

722
00:24:57,279 --> 00:24:59,120
changed a little bit

723
00:24:59,120 --> 00:25:02,240
but this was relevant and accurate up

724
00:25:02,240 --> 00:25:02,720
until

725
00:25:02,720 --> 00:25:08,000
at least four zero or four one i believe

726
00:25:09,520 --> 00:25:12,000
so there's a few different types of

727
00:25:12,000 --> 00:25:14,080
partitions

728
00:25:14,080 --> 00:25:16,240
your application and data are the two

729
00:25:16,240 --> 00:25:18,159
mains and then within

730
00:25:18,159 --> 00:25:19,840
there you can have different types of

731
00:25:19,840 --> 00:25:21,279
data partitions

732
00:25:21,279 --> 00:25:24,320
so there's a data structure called the

733
00:25:24,320 --> 00:25:26,799
nvs or non-volatile storage

734
00:25:26,799 --> 00:25:29,120
and this is used primarily it's a key

735
00:25:29,120 --> 00:25:30,159
value store

736
00:25:30,159 --> 00:25:32,240
and this is primarily used for storing

737
00:25:32,240 --> 00:25:33,520
non-volatile data

738
00:25:33,520 --> 00:25:36,320
such as key material passwords things

739
00:25:36,320 --> 00:25:37,520
that the application

740
00:25:37,520 --> 00:25:41,200
needs to store permanently but

741
00:25:41,200 --> 00:25:43,679
needs to have a way to easily recall

742
00:25:43,679 --> 00:25:44,880
them without modifying

743
00:25:44,880 --> 00:25:46,720
the actual flash image of the

744
00:25:46,720 --> 00:25:48,159
application

745
00:25:48,159 --> 00:25:50,400
there's fat support in here uh which

746
00:25:50,400 --> 00:25:52,240
gives you like a full file system which

747
00:25:52,240 --> 00:25:53,840
is nice

748
00:25:53,840 --> 00:25:56,240
uh and a variety of other ones but those

749
00:25:56,240 --> 00:25:57,679
are the the few that you're probably

750
00:25:57,679 --> 00:25:59,039
going to see most often

751
00:25:59,039 --> 00:26:04,720
often is applications uh nvs and fat

752
00:26:05,440 --> 00:26:07,440
so how does this all work so the

753
00:26:07,440 --> 00:26:09,279
bootloader knows where the partition

754
00:26:09,279 --> 00:26:10,480
table is

755
00:26:10,480 --> 00:26:12,880
there's a default value that is used

756
00:26:12,880 --> 00:26:13,600
that

757
00:26:13,600 --> 00:26:16,320
most applications are going to use which

758
00:26:16,320 --> 00:26:17,760
is nice

759
00:26:17,760 --> 00:26:21,360
but as part of the flashing process and

760
00:26:21,360 --> 00:26:24,320
the building process you can change that

761
00:26:24,320 --> 00:26:25,760
almost always like i said

762
00:26:25,760 --> 00:26:29,440
it's uses the default um but if

763
00:26:29,440 --> 00:26:30,960
for whatever reason you're you're

764
00:26:30,960 --> 00:26:32,320
interacting with a device that doesn't

765
00:26:32,320 --> 00:26:33,440
use the default

766
00:26:33,440 --> 00:26:35,120
that information should be spit out

767
00:26:35,120 --> 00:26:37,120
during boot up and you should be able to

768
00:26:37,120 --> 00:26:38,400
get that uh

769
00:26:38,400 --> 00:26:41,600
from the uart if you need

770
00:26:45,919 --> 00:26:48,799
so this really is the first step to

771
00:26:48,799 --> 00:26:49,919
dumping the firmware

772
00:26:49,919 --> 00:26:51,120
because we need to figure out where

773
00:26:51,120 --> 00:26:54,000
everything is so by default

774
00:26:54,000 --> 00:26:55,200
the partition table is going to be

775
00:26:55,200 --> 00:26:57,760
stored at 8 000 hex

776
00:26:57,760 --> 00:27:00,720
the partition table is always 30 72

777
00:27:00,720 --> 00:27:02,240
bytes long

778
00:27:02,240 --> 00:27:05,279
and so by using esp tool we can

779
00:27:05,279 --> 00:27:08,240
dump that segment of flash this is the

780
00:27:08,240 --> 00:27:09,679
tool that i mentioned earlier that is

781
00:27:09,679 --> 00:27:10,400
gonna be

782
00:27:10,400 --> 00:27:12,480
you know a big piece of how we do our

783
00:27:12,480 --> 00:27:13,520
interaction

784
00:27:13,520 --> 00:27:16,159
with all these devices so we use the

785
00:27:16,159 --> 00:27:17,200
dump flash

786
00:27:17,200 --> 00:27:19,600
sub command we give it the start address

787
00:27:19,600 --> 00:27:20,559
the size

788
00:27:20,559 --> 00:27:23,360
and it's going to dump us the partition

789
00:27:23,360 --> 00:27:24,080
out of

790
00:27:24,080 --> 00:27:27,520
flash the problem here is this is a

791
00:27:27,520 --> 00:27:28,640
binary file

792
00:27:28,640 --> 00:27:31,360
it's a binary representation of this

793
00:27:31,360 --> 00:27:33,279
data because the firmware uses that

794
00:27:33,279 --> 00:27:36,320
in order to boot so

795
00:27:36,320 --> 00:27:39,120
gen esp32 part is a tool that comes with

796
00:27:39,120 --> 00:27:39,919
the esp

797
00:27:39,919 --> 00:27:42,399
idf

798
00:27:43,360 --> 00:27:45,520
its primary purpose is for converting

799
00:27:45,520 --> 00:27:47,360
back and forth between the binary

800
00:27:47,360 --> 00:27:50,240
and the csv representation this is used

801
00:27:50,240 --> 00:27:51,600
as part of the build process but it's

802
00:27:51,600 --> 00:27:52,880
useful for us here

803
00:27:52,880 --> 00:27:54,480
because we can take the binary form and

804
00:27:54,480 --> 00:27:55,919
we can turn it back into a human

805
00:27:55,919 --> 00:27:56,640
readable

806
00:27:56,640 --> 00:28:00,559
csv format so once we do this

807
00:28:00,559 --> 00:28:03,679
we get this partition data tells us the

808
00:28:03,679 --> 00:28:05,120
various partition names

809
00:28:05,120 --> 00:28:07,760
their types where they start and how big

810
00:28:07,760 --> 00:28:08,640
they are

811
00:28:08,640 --> 00:28:11,679
uh there's also a flags field here uh

812
00:28:11,679 --> 00:28:15,200
for the older partitions and and older

813
00:28:15,200 --> 00:28:16,799
products you're not really going to see

814
00:28:16,799 --> 00:28:18,240
a lot of use here

815
00:28:18,240 --> 00:28:20,559
where it is useful is on newer stuff to

816
00:28:20,559 --> 00:28:22,080
take advantage of encryption

817
00:28:22,080 --> 00:28:24,399
that's one of the flags that can be used

818
00:28:24,399 --> 00:28:26,640
here where it will ensure that that

819
00:28:26,640 --> 00:28:29,360
partition stays encrypted meaning that

820
00:28:29,360 --> 00:28:30,240
we won't be able

821
00:28:30,240 --> 00:28:32,960
we can still read it off but the data

822
00:28:32,960 --> 00:28:33,600
will be

823
00:28:33,600 --> 00:28:36,080
i believe aes encrypted and we won't be

824
00:28:36,080 --> 00:28:39,439
able to actually read the data

825
00:28:39,760 --> 00:28:42,799
so we can see here that there are two

826
00:28:42,799 --> 00:28:44,880
application partitions and those are

827
00:28:44,880 --> 00:28:47,279
what we really are gonna care about here

828
00:28:47,279 --> 00:28:50,320
uh and then the nvs as well which is our

829
00:28:50,320 --> 00:28:53,760
non-volatile storage um

830
00:28:56,000 --> 00:28:59,679
there's also some parts of the

831
00:28:59,679 --> 00:29:02,000
memory that we're gonna want that are

832
00:29:02,000 --> 00:29:04,000
not stored on our external flash

833
00:29:04,000 --> 00:29:05,600
there is some internal flash on the

834
00:29:05,600 --> 00:29:08,399
device and the esp tool

835
00:29:08,399 --> 00:29:11,520
dump flash sub command only works with

836
00:29:11,520 --> 00:29:13,120
the external flash it doesn't work with

837
00:29:13,120 --> 00:29:14,720
the internal flash

838
00:29:14,720 --> 00:29:17,679
there's also some various uh ram on

839
00:29:17,679 --> 00:29:18,399
there

840
00:29:18,399 --> 00:29:21,520
that will load data in such as like for

841
00:29:21,520 --> 00:29:22,960
the boot rom

842
00:29:22,960 --> 00:29:25,760
so we can use the dump mem sub command

843
00:29:25,760 --> 00:29:27,360
and this allows us to just arbitrarily

844
00:29:27,360 --> 00:29:28,480
dump memory

845
00:29:28,480 --> 00:29:30,480
this is really useful if we need to get

846
00:29:30,480 --> 00:29:31,520
some of that data

847
00:29:31,520 --> 00:29:34,080
but it's really really slow so unless

848
00:29:34,080 --> 00:29:36,399
you're looking for specifically

849
00:29:36,399 --> 00:29:38,399
data that's you know is stored in ram

850
00:29:38,399 --> 00:29:40,399
but not stored in flash i wouldn't

851
00:29:40,399 --> 00:29:42,080
recommend using it

852
00:29:42,080 --> 00:29:44,480
the parameters are the same you just

853
00:29:44,480 --> 00:29:46,399
give it the start address the size and

854
00:29:46,399 --> 00:29:49,199
what you want to write to

855
00:29:49,600 --> 00:29:53,440
as a reference for knowing where to dump

856
00:29:53,440 --> 00:29:55,520
all of this is laid out in the technical

857
00:29:55,520 --> 00:29:56,720
reference manual

858
00:29:56,720 --> 00:29:57,840
there's links to this later in the

859
00:29:57,840 --> 00:29:59,919
presentation all of the different

860
00:29:59,919 --> 00:30:01,440
families of chip will have

861
00:30:01,440 --> 00:30:04,880
a table like this and elsewhere in the

862
00:30:04,880 --> 00:30:06,559
the document it will break down even

863
00:30:06,559 --> 00:30:08,640
more to give you an idea of where the

864
00:30:08,640 --> 00:30:09,600
registers are

865
00:30:09,600 --> 00:30:13,039
and where specific data is stored

866
00:30:13,039 --> 00:30:14,799
but this is a pretty high level overview

867
00:30:14,799 --> 00:30:17,360
and gives you information about

868
00:30:17,360 --> 00:30:21,199
how the address space is divided up

869
00:30:21,520 --> 00:30:24,640
the other option that you have

870
00:30:24,640 --> 00:30:27,760
is just a good old-fashioned spy flash

871
00:30:27,760 --> 00:30:29,760
dumper

872
00:30:29,760 --> 00:30:33,279
you can use your ftdi

873
00:30:33,279 --> 00:30:36,559
breakout board here to do that instead

874
00:30:36,559 --> 00:30:38,880
of talking over uart

875
00:30:38,880 --> 00:30:41,840
uh i just have a chip clip here wired up

876
00:30:41,840 --> 00:30:42,880
to it

877
00:30:42,880 --> 00:30:46,159
uh and so if if your bootloader is

878
00:30:46,159 --> 00:30:47,360
locked

879
00:30:47,360 --> 00:30:49,360
and you can't interact with it from

880
00:30:49,360 --> 00:30:50,799
there you could

881
00:30:50,799 --> 00:30:53,760
still pull off the rf shielding and

882
00:30:53,760 --> 00:30:55,760
connect direct to the spy flash

883
00:30:55,760 --> 00:30:58,159
this isn't going to help you if the

884
00:30:58,159 --> 00:30:59,679
flash is encrypted

885
00:30:59,679 --> 00:31:01,600
because you'll pull the data off but you

886
00:31:01,600 --> 00:31:03,840
still won't be able to read it

887
00:31:03,840 --> 00:31:07,519
so maybe helpful may not be helpful

888
00:31:07,519 --> 00:31:10,960
but it's it's one option

889
00:31:11,200 --> 00:31:13,760
you also may run into problems where the

890
00:31:13,760 --> 00:31:16,320
addresses may not line up correctly

891
00:31:16,320 --> 00:31:20,000
the esp idf does some

892
00:31:20,000 --> 00:31:22,159
form of wear leveling to ensure that

893
00:31:22,159 --> 00:31:23,840
you're not destroying the flash

894
00:31:23,840 --> 00:31:25,279
especially for partitions

895
00:31:25,279 --> 00:31:26,559
where you're reading and writing a lot

896
00:31:26,559 --> 00:31:29,039
like nvs

897
00:31:29,039 --> 00:31:30,880
and your addresses in your partition

898
00:31:30,880 --> 00:31:33,600
table may not align directly with the

899
00:31:33,600 --> 00:31:35,039
physical addresses

900
00:31:35,039 --> 00:31:38,559
on the spy flash if you're doing this

901
00:31:38,559 --> 00:31:40,320
you can either take the spy flash all

902
00:31:40,320 --> 00:31:42,240
the way off the board or you can try to

903
00:31:42,240 --> 00:31:43,440
do it in circuit

904
00:31:43,440 --> 00:31:46,320
make sure you pull the en pin low so

905
00:31:46,320 --> 00:31:47,919
that the chip won't start up

906
00:31:47,919 --> 00:31:51,279
and race you for access to the

907
00:31:51,279 --> 00:31:53,200
flash otherwise you're probably going to

908
00:31:53,200 --> 00:31:54,720
lose and not be able to dump

909
00:31:54,720 --> 00:31:57,840
the partitions out

910
00:31:59,120 --> 00:32:02,640
so now that we've gotten the flash and

911
00:32:02,640 --> 00:32:03,360
the firmware

912
00:32:03,360 --> 00:32:06,399
off of here we have to start looking at

913
00:32:06,399 --> 00:32:06,720
it

914
00:32:06,720 --> 00:32:09,840
and trying to identify secrets bugs

915
00:32:09,840 --> 00:32:12,559
whatever we're looking for in the device

916
00:32:12,559 --> 00:32:13,760
so

917
00:32:13,760 --> 00:32:16,559
extensa does have support across a

918
00:32:16,559 --> 00:32:18,080
variety of debuggers

919
00:32:18,080 --> 00:32:20,960
but the quality is kind of hit and miss

920
00:32:20,960 --> 00:32:21,919
in general

921
00:32:21,919 --> 00:32:23,519
most of the implementations are pretty

922
00:32:23,519 --> 00:32:25,760
incomplete or they have bugs

923
00:32:25,760 --> 00:32:27,200
because the architecture itself is a

924
00:32:27,200 --> 00:32:29,200
little weird there's

925
00:32:29,200 --> 00:32:31,919
also not really a lot of good available

926
00:32:31,919 --> 00:32:33,600
official documentation

927
00:32:33,600 --> 00:32:36,159
and the reason for this is that cadence

928
00:32:36,159 --> 00:32:38,320
doesn't make it available

929
00:32:38,320 --> 00:32:41,519
espressif has licensed the isa and the

930
00:32:41,519 --> 00:32:43,600
cores and they're allowed to

931
00:32:43,600 --> 00:32:45,440
produce this but they're not allowed to

932
00:32:45,440 --> 00:32:46,960
release the documentation

933
00:32:46,960 --> 00:32:50,399
so getting an up-to-date doc about what

934
00:32:50,399 --> 00:32:51,200
the isa

935
00:32:51,200 --> 00:32:53,919
is and how it's encoded is not super

936
00:32:53,919 --> 00:32:55,440
easy

937
00:32:55,440 --> 00:32:57,679
there's been some leaks the first link

938
00:32:57,679 --> 00:32:59,519
here the extensor.pdf

939
00:32:59,519 --> 00:33:01,840
is one of those uh it came out from i

940
00:33:01,840 --> 00:33:03,440
think around 2010

941
00:33:03,440 --> 00:33:06,159
so it's available and has information

942
00:33:06,159 --> 00:33:06,960
but

943
00:33:06,960 --> 00:33:08,840
unclear as to whether or not it's

944
00:33:08,840 --> 00:33:10,320
complete

945
00:33:10,320 --> 00:33:13,600
the second link below is a dock that

946
00:33:13,600 --> 00:33:15,760
espressif has put together specifically

947
00:33:15,760 --> 00:33:17,279
for people building

948
00:33:17,279 --> 00:33:20,399
compilers and disassembly tools

949
00:33:20,399 --> 00:33:23,760
needing to support the architecture and

950
00:33:23,760 --> 00:33:25,039
this isn't official cadence

951
00:33:25,039 --> 00:33:27,120
documentation but it's probably the best

952
00:33:27,120 --> 00:33:29,039
that we're gonna get right now

953
00:33:29,039 --> 00:33:30,559
in order to help build some better

954
00:33:30,559 --> 00:33:33,279
tooling all of the official tooling

955
00:33:33,279 --> 00:33:33,919
right now

956
00:33:33,919 --> 00:33:36,159
is based off of gcc so that's what

957
00:33:36,159 --> 00:33:38,559
espresso ships there's

958
00:33:38,559 --> 00:33:41,840
i believe it's all upstream as well so

959
00:33:41,840 --> 00:33:44,880
you can get that there's also official

960
00:33:44,880 --> 00:33:46,880
patches that espressif is building for

961
00:33:46,880 --> 00:33:48,640
lvm and cling

962
00:33:48,640 --> 00:33:51,440
so eventually it will hopefully land

963
00:33:51,440 --> 00:33:52,000
this has been

964
00:33:52,000 --> 00:33:54,640
ongoing for a few years now and it's not

965
00:33:54,640 --> 00:33:55,519
really clear

966
00:33:55,519 --> 00:33:57,039
how long it's going to take until it

967
00:33:57,039 --> 00:33:59,360
gets upstreamed but when that happens

968
00:33:59,360 --> 00:34:00,000
it's

969
00:34:00,000 --> 00:34:01,519
you know presumable that it'll probably

970
00:34:01,519 --> 00:34:03,440
land in capstone which would be nice

971
00:34:03,440 --> 00:34:04,399
because

972
00:34:04,399 --> 00:34:06,159
all of a sudden you'll be able to add

973
00:34:06,159 --> 00:34:07,919
support to more

974
00:34:07,919 --> 00:34:10,639
disassemblers

975
00:34:11,040 --> 00:34:13,599
so what tools can actually interact with

976
00:34:13,599 --> 00:34:14,560
this

977
00:34:14,560 --> 00:34:17,280
well r2 and cutter probably have the

978
00:34:17,280 --> 00:34:19,520
best implementation i've seen so far

979
00:34:19,520 --> 00:34:21,520
and that's because it reuses the gcc

980
00:34:21,520 --> 00:34:22,719
infrastructure that

981
00:34:22,719 --> 00:34:26,320
is the official tool chain there's a

982
00:34:26,320 --> 00:34:29,359
third party ida plugin i have a fork

983
00:34:29,359 --> 00:34:30,000
here

984
00:34:30,000 --> 00:34:33,040
that fixes some of the python

985
00:34:33,040 --> 00:34:35,199
3 issues to support newer versions of

986
00:34:35,199 --> 00:34:36,719
ida

987
00:34:36,719 --> 00:34:38,879
i believe that this fork is up to date

988
00:34:38,879 --> 00:34:39,918
with upstream

989
00:34:39,918 --> 00:34:41,599
there hasn't been a lot of work on it

990
00:34:41,599 --> 00:34:43,520
and there were a number of

991
00:34:43,520 --> 00:34:45,359
bugs that i found that made it somewhat

992
00:34:45,359 --> 00:34:47,119
difficult to use

993
00:34:47,119 --> 00:34:50,320
there's a third party ghidra extension

994
00:34:50,320 --> 00:34:53,199
that adds support this will also work

995
00:34:53,199 --> 00:34:54,800
with the decompiler

996
00:34:54,800 --> 00:34:58,399
but i don't know how accurate it is

997
00:34:58,560 --> 00:35:01,599
the r2

998
00:35:01,599 --> 00:35:04,640
and cutter implementation i believe will

999
00:35:04,640 --> 00:35:06,480
also work with the decompiler but i

1000
00:35:06,480 --> 00:35:08,160
think it only works if you use the

1001
00:35:08,160 --> 00:35:10,720
geeter decompiler under the hood

1002
00:35:10,720 --> 00:35:12,640
there's talk about upstreaming the guide

1003
00:35:12,640 --> 00:35:14,400
implementation but i haven't seen any

1004
00:35:14,400 --> 00:35:15,520
real movement on it

1005
00:35:15,520 --> 00:35:17,040
but there are people still working on it

1006
00:35:17,040 --> 00:35:19,200
which is nice

1007
00:35:19,200 --> 00:35:21,040
the other the other big piece that's

1008
00:35:21,040 --> 00:35:22,720
missing from virtually all

1009
00:35:22,720 --> 00:35:25,359
tooling is first party support for

1010
00:35:25,359 --> 00:35:26,480
loading the

1011
00:35:26,480 --> 00:35:30,560
firmware images themselves

1012
00:35:30,560 --> 00:35:32,240
so one of the sort of irritating things

1013
00:35:32,240 --> 00:35:34,960
is once you load in the image

1014
00:35:34,960 --> 00:35:36,160
you're typically not going to get a lot

1015
00:35:36,160 --> 00:35:38,000
of very good

1016
00:35:38,000 --> 00:35:40,000
identification of functions and control

1017
00:35:40,000 --> 00:35:41,040
flow

1018
00:35:41,040 --> 00:35:42,320
just because it doesn't really know

1019
00:35:42,320 --> 00:35:44,079
where things are loaded and

1020
00:35:44,079 --> 00:35:47,119
where all that is luckily we can

1021
00:35:47,119 --> 00:35:50,160
know how to read the format for the

1022
00:35:50,160 --> 00:35:50,800
header

1023
00:35:50,800 --> 00:35:53,920
and so i've written one for ida

1024
00:35:53,920 --> 00:35:56,880
and that's available here at the bottom

1025
00:35:56,880 --> 00:35:58,560
i plan to build platform support for

1026
00:35:58,560 --> 00:36:00,000
binary ninja

1027
00:36:00,000 --> 00:36:02,640
uh i don't know if there's support for

1028
00:36:02,640 --> 00:36:04,880
esp32 but i'd like to write it at some

1029
00:36:04,880 --> 00:36:07,440
point in the near future

1030
00:36:07,440 --> 00:36:10,720
the this

1031
00:36:10,720 --> 00:36:14,160
loader will work with i believe the most

1032
00:36:14,160 --> 00:36:15,359
up-to-date version

1033
00:36:15,359 --> 00:36:18,160
of the esp-idf but some older versions

1034
00:36:18,160 --> 00:36:20,079
it won't work with because the

1035
00:36:20,079 --> 00:36:22,880
format has changed somewhat it also

1036
00:36:22,880 --> 00:36:26,160
won't completely load esp8266

1037
00:36:26,160 --> 00:36:29,280
images as those are somewhat different

1038
00:36:29,280 --> 00:36:31,359
but i do plan to add support to handle

1039
00:36:31,359 --> 00:36:35,119
all of them in the near future

1040
00:36:35,359 --> 00:36:36,560
if you're interested what the header

1041
00:36:36,560 --> 00:36:38,960
looks like this is it

1042
00:36:38,960 --> 00:36:41,040
the main things you care about really

1043
00:36:41,040 --> 00:36:42,880
are the entry point here

1044
00:36:42,880 --> 00:36:46,880
uh and the uh

1045
00:36:46,880 --> 00:36:48,800
segments that's what's really going to

1046
00:36:48,800 --> 00:36:50,079
help you figure out how to load this

1047
00:36:50,079 --> 00:36:51,520
thing in

1048
00:36:51,520 --> 00:36:54,320
immediately after by the way this is all

1049
00:36:54,320 --> 00:36:56,000
little endian values

1050
00:36:56,000 --> 00:36:59,200
um i believe it's a little indian chip

1051
00:36:59,200 --> 00:37:00,800
but it might be dual endian

1052
00:37:00,800 --> 00:37:02,720
uh but most of the time like i've always

1053
00:37:02,720 --> 00:37:05,760
seen it uh little endian

1054
00:37:05,760 --> 00:37:08,720
immediately following this header you're

1055
00:37:08,720 --> 00:37:11,440
going to see the individual segments

1056
00:37:11,440 --> 00:37:13,760
and this is what those look like you're

1057
00:37:13,760 --> 00:37:15,359
going to have a load address

1058
00:37:15,359 --> 00:37:17,200
followed by a segment length followed by

1059
00:37:17,200 --> 00:37:18,400
the data directly

1060
00:37:18,400 --> 00:37:20,800
and then the next segment after it you

1061
00:37:20,800 --> 00:37:21,520
just

1062
00:37:21,520 --> 00:37:23,839
take the uh the segment length to go

1063
00:37:23,839 --> 00:37:27,359
that far in and get to the next segment

1064
00:37:30,240 --> 00:37:32,560
i briefly talked about nvs as being this

1065
00:37:32,560 --> 00:37:34,839
this data storage

1066
00:37:34,839 --> 00:37:38,560
mechanism uh so other than hard-coded

1067
00:37:38,560 --> 00:37:39,119
values

1068
00:37:39,119 --> 00:37:41,200
in the application images and firmware

1069
00:37:41,200 --> 00:37:42,720
this is where most of the interesting

1070
00:37:42,720 --> 00:37:44,480
data is gonna live

1071
00:37:44,480 --> 00:37:46,160
currently there's not a lot of tooling

1072
00:37:46,160 --> 00:37:48,800
available for interacting with this

1073
00:37:48,800 --> 00:37:50,720
but that's something that i'm working on

1074
00:37:50,720 --> 00:37:52,320
um it's

1075
00:37:52,320 --> 00:37:53,839
theoretically possible that you could

1076
00:37:53,839 --> 00:37:56,240
reuse the c plus implementation

1077
00:37:56,240 --> 00:37:59,359
that they've written in the esp-idf

1078
00:37:59,359 --> 00:38:01,760
to add support to build host-based

1079
00:38:01,760 --> 00:38:02,720
tooling

1080
00:38:02,720 --> 00:38:04,560
the problem is that there's different

1081
00:38:04,560 --> 00:38:06,480
versions of nvs

1082
00:38:06,480 --> 00:38:08,960
and none of the partitions themselves

1083
00:38:08,960 --> 00:38:10,960
are aware of what version they are

1084
00:38:10,960 --> 00:38:12,960
they just depend on the fact that when

1085
00:38:12,960 --> 00:38:14,000
you compile

1086
00:38:14,000 --> 00:38:16,560
the whole firmware image the current

1087
00:38:16,560 --> 00:38:18,079
snapshot of that

1088
00:38:18,079 --> 00:38:20,000
knows how to interact with that version

1089
00:38:20,000 --> 00:38:22,480
of the nvs

1090
00:38:22,480 --> 00:38:24,800
implementation and so in order to figure

1091
00:38:24,800 --> 00:38:26,079
out what the format is

1092
00:38:26,079 --> 00:38:27,520
you actually need to figure out which

1093
00:38:27,520 --> 00:38:30,079
version of esp-idf is being used

1094
00:38:30,079 --> 00:38:33,040
and then go and parse it the correct way

1095
00:38:33,040 --> 00:38:34,160
i believe that there's two

1096
00:38:34,160 --> 00:38:36,320
different distinct implementations and

1097
00:38:36,320 --> 00:38:37,760
they're the

1098
00:38:37,760 --> 00:38:40,160
data back end is pretty substantially

1099
00:38:40,160 --> 00:38:42,560
different

1100
00:38:43,040 --> 00:38:44,480
the documentation for all that's

1101
00:38:44,480 --> 00:38:46,240
available in their docs

1102
00:38:46,240 --> 00:38:47,760
and the code is all open source so you

1103
00:38:47,760 --> 00:38:49,839
can go and read it um

1104
00:38:49,839 --> 00:38:52,480
i would like to build some uh host-based

1105
00:38:52,480 --> 00:38:53,680
tooling that allows you to basically

1106
00:38:53,680 --> 00:38:55,200
interact with it the same way you would

1107
00:38:55,200 --> 00:38:56,720
say like sqlite

1108
00:38:56,720 --> 00:39:00,000
um it doesn't seem too complicated but

1109
00:39:00,000 --> 00:39:01,680
the paging mechanism that they've added

1110
00:39:01,680 --> 00:39:03,200
in in later versions

1111
00:39:03,200 --> 00:39:05,119
uh definitely makes it a little bit more

1112
00:39:05,119 --> 00:39:08,720
difficult than the original version

1113
00:39:09,119 --> 00:39:10,480
so i mentioned that a whole bunch of

1114
00:39:10,480 --> 00:39:12,880
this is is based on previous research

1115
00:39:12,880 --> 00:39:14,720
um and this is really the stuff if

1116
00:39:14,720 --> 00:39:16,320
you're going to start diving into this

1117
00:39:16,320 --> 00:39:19,839
that you want to go and and look at

1118
00:39:19,839 --> 00:39:21,760
the first link here is reversing the

1119
00:39:21,760 --> 00:39:23,359
esp32 boot rom

1120
00:39:23,359 --> 00:39:26,320
this is the the first piece of code that

1121
00:39:26,320 --> 00:39:27,760
loads up when you start

1122
00:39:27,760 --> 00:39:29,920
and there's some really great research

1123
00:39:29,920 --> 00:39:31,440
in reverse engineering that and figuring

1124
00:39:31,440 --> 00:39:32,960
out how it works

1125
00:39:32,960 --> 00:39:34,320
this is something that's going to be

1126
00:39:34,320 --> 00:39:36,400
really interesting to you if you want to

1127
00:39:36,400 --> 00:39:37,040
understand

1128
00:39:37,040 --> 00:39:39,920
the hardware from a really low level the

1129
00:39:39,920 --> 00:39:41,599
limited results links here

1130
00:39:41,599 --> 00:39:43,520
this is probably the most interesting

1131
00:39:43,520 --> 00:39:46,480
research that's come out on the esp32

1132
00:39:46,480 --> 00:39:47,680
family of chips

1133
00:39:47,680 --> 00:39:50,079
this is the initial hardware attack that

1134
00:39:50,079 --> 00:39:50,720
broke

1135
00:39:50,720 --> 00:39:53,520
the secure boot functionality that has

1136
00:39:53,520 --> 00:39:56,640
since been fixed and replaced uh

1137
00:39:56,640 --> 00:39:58,640
but you know this this hardware that

1138
00:39:58,640 --> 00:40:00,560
came out like that generation

1139
00:40:00,560 --> 00:40:02,480
is forever broken so anything that's

1140
00:40:02,480 --> 00:40:04,880
based on that if it has the protection

1141
00:40:04,880 --> 00:40:05,520
enabled

1142
00:40:05,520 --> 00:40:07,680
you can still bypass it um the blog

1143
00:40:07,680 --> 00:40:09,599
posts do a pretty good job

1144
00:40:09,599 --> 00:40:12,480
of walking through how it works what the

1145
00:40:12,480 --> 00:40:14,640
bugs are and and how to replicate it

1146
00:40:14,640 --> 00:40:16,640
i haven't gone through and replicated

1147
00:40:16,640 --> 00:40:17,760
the attack yet but i

1148
00:40:17,760 --> 00:40:21,280
i plan to uh pretty soon uh it involves

1149
00:40:21,280 --> 00:40:23,119
voltage glitching

1150
00:40:23,119 --> 00:40:26,640
uh to get it back into a

1151
00:40:26,640 --> 00:40:29,359
known state um the person who did this

1152
00:40:29,359 --> 00:40:30,880
research is also the one

1153
00:40:30,880 --> 00:40:33,920
who publicized a bunch of the nri 52

1154
00:40:33,920 --> 00:40:36,190
glitching to

1155
00:40:36,190 --> 00:40:37,760
[Music]

1156
00:40:37,760 --> 00:40:39,760
unlock the the locked uh bootloader

1157
00:40:39,760 --> 00:40:41,520
again on there

1158
00:40:41,520 --> 00:40:43,040
and then again there's just there's so

1159
00:40:43,040 --> 00:40:44,880
much documentation that espressif makes

1160
00:40:44,880 --> 00:40:46,480
available themselves

1161
00:40:46,480 --> 00:40:50,240
um and that is really useful

1162
00:40:50,240 --> 00:40:52,640
and helpful if you start looking into

1163
00:40:52,640 --> 00:40:53,280
this

1164
00:40:53,280 --> 00:40:56,640
um it has been immensely helpful as i've

1165
00:40:56,640 --> 00:40:58,079
tried to understand like how everything

1166
00:40:58,079 --> 00:40:58,560
works

1167
00:40:58,560 --> 00:41:01,359
and trying to figure out um how to

1168
00:41:01,359 --> 00:41:02,720
approach some of these problems

1169
00:41:02,720 --> 00:41:04,240
there's also tons of tooling they

1170
00:41:04,240 --> 00:41:06,960
provide as part of the esp-idf that

1171
00:41:06,960 --> 00:41:07,839
makes a lot of this

1172
00:41:07,839 --> 00:41:09,920
more straightforward and so definitely

1173
00:41:09,920 --> 00:41:11,440
looking into that before you go and like

1174
00:41:11,440 --> 00:41:12,560
write your own

1175
00:41:12,560 --> 00:41:14,240
if you don't mind some like manual steps

1176
00:41:14,240 --> 00:41:16,319
here and there to shift the data from

1177
00:41:16,319 --> 00:41:18,960
tool to tool

1178
00:41:19,359 --> 00:41:21,920
so i want to talk a little bit about

1179
00:41:21,920 --> 00:41:23,280
next steps and kind of like where i'm

1180
00:41:23,280 --> 00:41:24,240
looking at

1181
00:41:24,240 --> 00:41:27,599
um there's definitely been some work as

1182
00:41:27,599 --> 00:41:28,079
i said

1183
00:41:28,079 --> 00:41:29,839
in terms of like third-party support for

1184
00:41:29,839 --> 00:41:31,200
building better reverse engineering

1185
00:41:31,200 --> 00:41:31,920
tooling

1186
00:41:31,920 --> 00:41:34,800
for this platform um i would like to

1187
00:41:34,800 --> 00:41:36,640
make that a lot better just because

1188
00:41:36,640 --> 00:41:38,160
right now like the state of it is not

1189
00:41:38,160 --> 00:41:40,160
very good

1190
00:41:40,160 --> 00:41:42,160
um disassembler support needs to get

1191
00:41:42,160 --> 00:41:44,160
better it's it's rough and

1192
00:41:44,160 --> 00:41:46,319
it's doable right now but it's really

1193
00:41:46,319 --> 00:41:48,160
really really painful

1194
00:41:48,160 --> 00:41:51,839
um depending on how well the esp32c

1195
00:41:51,839 --> 00:41:54,560
series goes i think we'll see this

1196
00:41:54,560 --> 00:41:56,079
naturally sort of just get

1197
00:41:56,079 --> 00:41:58,800
better because if espressif shifts their

1198
00:41:58,800 --> 00:42:00,240
direction toward

1199
00:42:00,240 --> 00:42:03,520
these risk five chips the extensor based

1200
00:42:03,520 --> 00:42:05,359
ones may just kind of phase out and

1201
00:42:05,359 --> 00:42:07,440
you know the hardware lifespan for these

1202
00:42:07,440 --> 00:42:09,200
is super long because they're you know

1203
00:42:09,200 --> 00:42:11,680
iot things that live forever

1204
00:42:11,680 --> 00:42:14,480
but you know as as the chips move toward

1205
00:42:14,480 --> 00:42:15,200
that

1206
00:42:15,200 --> 00:42:16,800
hopefully we'll just naturally get

1207
00:42:16,800 --> 00:42:18,640
better support by virtue of

1208
00:42:18,640 --> 00:42:21,280
risk five being well supported already

1209
00:42:21,280 --> 00:42:24,000
in a lot of the different tools

1210
00:42:24,000 --> 00:42:26,560
i mentioned nvs tooling and just getting

1211
00:42:26,560 --> 00:42:28,400
good host-based tooling to interact at

1212
00:42:28,400 --> 00:42:30,960
these data stores

1213
00:42:30,960 --> 00:42:33,040
that's an area that i plan to focus on

1214
00:42:33,040 --> 00:42:34,720
and just build out really good tooling

1215
00:42:34,720 --> 00:42:35,440
for

1216
00:42:35,440 --> 00:42:38,560
um right now you kind of have to do it

1217
00:42:38,560 --> 00:42:39,599
piece by piece

1218
00:42:39,599 --> 00:42:41,520
going in there and it's it's it's rough

1219
00:42:41,520 --> 00:42:42,800
but like it's really useful because

1220
00:42:42,800 --> 00:42:44,079
that's etc that's where the passwords

1221
00:42:44,079 --> 00:42:44,480
are

1222
00:42:44,480 --> 00:42:46,480
it's where the persistent storage is and

1223
00:42:46,480 --> 00:42:48,720
so you have data

1224
00:42:48,720 --> 00:42:51,119
um getting all the stuff that i've

1225
00:42:51,119 --> 00:42:51,760
already done

1226
00:42:51,760 --> 00:42:55,359
working with the a266 um so that you can

1227
00:42:55,359 --> 00:42:56,720
look at a lot of the older stuff that's

1228
00:42:56,720 --> 00:42:58,079
still based on it

1229
00:42:58,079 --> 00:43:00,079
a lot of the format itself hasn't

1230
00:43:00,079 --> 00:43:01,359
changed so much

1231
00:43:01,359 --> 00:43:04,240
and so getting it working is really not

1232
00:43:04,240 --> 00:43:05,760
that big of a deal but just

1233
00:43:05,760 --> 00:43:07,200
getting the right code paths in there

1234
00:43:07,200 --> 00:43:08,800
and making it aware

1235
00:43:08,800 --> 00:43:12,560
um is necessary and then automating some

1236
00:43:12,560 --> 00:43:14,160
of the extraction

1237
00:43:14,160 --> 00:43:16,079
and the recovery of the various

1238
00:43:16,079 --> 00:43:18,000
partitions right now it's a pretty

1239
00:43:18,000 --> 00:43:19,920
manual process of having to go step by

1240
00:43:19,920 --> 00:43:20,480
step

1241
00:43:20,480 --> 00:43:22,560
grabbing the partition table grabbing

1242
00:43:22,560 --> 00:43:24,720
the individual partitions

1243
00:43:24,720 --> 00:43:26,520
converting the partition table from

1244
00:43:26,520 --> 00:43:28,079
binary.csv

1245
00:43:28,079 --> 00:43:31,920
uh etc and so being able to do all that

1246
00:43:31,920 --> 00:43:34,400
uh in a simpler more automated manner

1247
00:43:34,400 --> 00:43:36,880
would be really nice

1248
00:43:36,880 --> 00:43:39,200
and that's all i got if you have any

1249
00:43:39,200 --> 00:43:40,880
questions i'll be around

1250
00:43:40,880 --> 00:43:43,359
happy to answer anything uh and if you'd

1251
00:43:43,359 --> 00:43:44,720
like information about

1252
00:43:44,720 --> 00:43:46,720
some of the hardware that i was talking

1253
00:43:46,720 --> 00:43:48,880
about in terms of

1254
00:43:48,880 --> 00:43:50,880
uh being able to get the auto reset

1255
00:43:50,880 --> 00:43:52,720
circuit i'll be publishing

1256
00:43:52,720 --> 00:43:55,839
some of the information about that

1257
00:43:55,839 --> 00:43:58,319
coming pretty soon i'm hoping to open

1258
00:43:58,319 --> 00:43:58,880
source

1259
00:43:58,880 --> 00:44:00,960
all the designs for that and then also

1260
00:44:00,960 --> 00:44:03,040
offer some pre-built

1261
00:44:03,040 --> 00:44:06,160
uh versions of them for sale for anyone

1262
00:44:06,160 --> 00:44:07,359
who just wants to get

1263
00:44:07,359 --> 00:44:14,560
one and not have to build it thanks

