1
00:00:03,500 --> 00:00:09,090
so I'm James I'm a security researcher

2
00:00:06,839 --> 00:00:10,710
balloon security and I should mention

3
00:00:09,090 --> 00:00:12,269
when I when I was doing this research I

4
00:00:10,710 --> 00:00:14,250
was working at NCC group and they were

5
00:00:12,269 --> 00:00:18,029
nice enough to let me still presented

6
00:00:14,250 --> 00:00:19,590
after I quit but so the I'm gonna be

7
00:00:18,029 --> 00:00:21,330
talking about hacking amiibo and if

8
00:00:19,590 --> 00:00:24,330
you're not not familiar with amiibo

9
00:00:21,330 --> 00:00:27,630
there are these toys with for a Nintendo

10
00:00:24,330 --> 00:00:29,070
consoles and and what you do is you take

11
00:00:27,630 --> 00:00:30,570
the toy it you get some toy and you can

12
00:00:29,070 --> 00:00:33,239
put it on the console and so someplace

13
00:00:30,570 --> 00:00:35,969
and it interacts with the game so like

14
00:00:33,239 --> 00:00:37,949
in one of the first games to really make

15
00:00:35,969 --> 00:00:39,480
much big use of this was the Super Smash

16
00:00:37,950 --> 00:00:41,730
Brothers game and like you would get

17
00:00:39,480 --> 00:00:43,050
some character and then you want to use

18
00:00:41,730 --> 00:00:45,110
the toy in the game you get that

19
00:00:43,050 --> 00:00:48,500
character is like a AI and you can save

20
00:00:45,110 --> 00:00:51,989
you could train it and save items to it

21
00:00:48,500 --> 00:00:55,170
so so these devices actually you can

22
00:00:51,989 --> 00:00:57,030
read and write data to them and save so

23
00:00:55,170 --> 00:00:59,309
that each game can save its own data on

24
00:00:57,030 --> 00:01:03,719
to the amiibo and the way that that

25
00:00:59,309 --> 00:01:06,030
works is that they use NFC so in the in

26
00:01:03,719 --> 00:01:07,920
the bottom of the tag there's something

27
00:01:06,030 --> 00:01:13,170
it's kind of like an RFID there there's

28
00:01:07,920 --> 00:01:15,240
an NFC tag which is a NFC is is a way to

29
00:01:13,170 --> 00:01:19,470
do contactless data and power transfer

30
00:01:15,240 --> 00:01:21,810
and what basically the all it is is

31
00:01:19,470 --> 00:01:22,920
there's big well it's small but there's

32
00:01:21,810 --> 00:01:26,009
an antenna and then a very tiny

33
00:01:22,920 --> 00:01:29,960
integrated circuit that gets powered by

34
00:01:26,009 --> 00:01:33,570
the radio and and also can you know

35
00:01:29,960 --> 00:01:37,860
there's actually it can do logic and

36
00:01:33,570 --> 00:01:39,449
yeah okay so also around the time when I

37
00:01:37,860 --> 00:01:43,829
started doing this I was really into

38
00:01:39,450 --> 00:01:45,780
save game packs and one example back on

39
00:01:43,829 --> 00:01:49,258
the Wii was for the Twilight Princess

40
00:01:45,780 --> 00:01:51,240
game we're not like the only two string

41
00:01:49,259 --> 00:01:53,009
inputs in the game was vulnerable to

42
00:01:51,240 --> 00:01:55,110
overflow and that was when you when you

43
00:01:53,009 --> 00:01:57,990
could name your horse so they edited the

44
00:01:55,110 --> 00:02:01,500
save file and you did a basic stack

45
00:01:57,990 --> 00:02:04,679
overflow and using that they were able

46
00:02:01,500 --> 00:02:07,049
to do a software-only kind of jailbreak

47
00:02:04,680 --> 00:02:11,580
on the on the console and install new

48
00:02:07,049 --> 00:02:13,080
apps onto it and there so this is what

49
00:02:11,580 --> 00:02:14,520
it looked like you just have this file

50
00:02:13,080 --> 00:02:16,650
you load it up

51
00:02:14,520 --> 00:02:19,170
you walk up to some character and as

52
00:02:16,650 --> 00:02:21,120
soon as you talk to them the puff

53
00:02:19,170 --> 00:02:23,099
overflow triggers and they you know run

54
00:02:21,120 --> 00:02:25,349
their own program and install their own

55
00:02:23,099 --> 00:02:26,369
their own channel on the week so they're

56
00:02:25,349 --> 00:02:29,730
the reason that you do this is that

57
00:02:26,370 --> 00:02:32,910
modern consoles are the pet the fast who

58
00:02:29,730 --> 00:02:35,910
generations of consoles they are kind of

59
00:02:32,910 --> 00:02:37,200
like kind of like smartphones annoying

60
00:02:35,910 --> 00:02:38,630
where they're they kind of lock you up

61
00:02:37,200 --> 00:02:41,250
from having total control of the device

62
00:02:38,630 --> 00:02:43,829
so people that want to say if you wanted

63
00:02:41,250 --> 00:02:45,030
to run your own homebrew games or you

64
00:02:43,830 --> 00:02:46,319
want to run Linux on a console or

65
00:02:45,030 --> 00:02:48,120
something that you wouldn't really be

66
00:02:46,319 --> 00:02:49,619
able to do it without break from the

67
00:02:48,120 --> 00:02:51,780
security model of the console and

68
00:02:49,620 --> 00:02:52,829
they've been getting very complex and

69
00:02:51,780 --> 00:02:56,880
very interesting so that there's a

70
00:02:52,829 --> 00:02:59,310
diagram here of the 3d yes which took

71
00:02:56,880 --> 00:03:01,829
about like four four or five years to

72
00:02:59,310 --> 00:03:03,030
break because you can see there's so

73
00:03:01,829 --> 00:03:06,900
many steps in there there's all this

74
00:03:03,030 --> 00:03:08,610
encryption and signing so part of the

75
00:03:06,900 --> 00:03:09,989
reason you want to find an exploit is is

76
00:03:08,610 --> 00:03:12,870
you can use that exploit you can

77
00:03:09,989 --> 00:03:18,720
leverage that exploit to jailbreak the

78
00:03:12,870 --> 00:03:20,250
console so I also started this before

79
00:03:18,720 --> 00:03:22,440
the switch I was coming out so there's

80
00:03:20,250 --> 00:03:23,940
only the Wii U and the 3ds but we knew

81
00:03:22,440 --> 00:03:25,109
that the switch was going to come out

82
00:03:23,940 --> 00:03:29,150
and is also going to be supporting

83
00:03:25,109 --> 00:03:32,430
amiibo so basically anything that I

84
00:03:29,150 --> 00:03:34,319
would work for so if I'm hacking these

85
00:03:32,430 --> 00:03:35,670
and I can do something on the 3ds of the

86
00:03:34,319 --> 00:03:36,780
Wii it's also going to work on the

87
00:03:35,670 --> 00:03:38,910
switch and that comes out and it would

88
00:03:36,780 --> 00:03:40,859
be interesting to see like these new

89
00:03:38,910 --> 00:03:42,510
games on the switch that are gonna you

90
00:03:40,859 --> 00:03:44,190
know save all this amiibo data on them

91
00:03:42,510 --> 00:03:45,690
if I could if I could maybe find an

92
00:03:44,190 --> 00:03:47,660
exploit on the switch doing doing that

93
00:03:45,690 --> 00:03:49,680
and like it's not the most practical

94
00:03:47,660 --> 00:03:51,660
attack but it would be like a very

95
00:03:49,680 --> 00:03:53,489
hilarious thing that you would find some

96
00:03:51,660 --> 00:04:02,340
some attack where you use it and even

97
00:03:53,489 --> 00:04:04,709
Evo to exploit the switch so yeah so the

98
00:04:02,340 --> 00:04:05,239
the questions are like how easy would it

99
00:04:04,709 --> 00:04:07,500
be

100
00:04:05,239 --> 00:04:10,230
how easy is it the clone the me bill

101
00:04:07,500 --> 00:04:12,120
were spoof them okay the data on them

102
00:04:10,230 --> 00:04:14,760
could we use that for some kind of saved

103
00:04:12,120 --> 00:04:15,989
game exploit and finally a you know for

104
00:04:14,760 --> 00:04:19,019
especially could it be used for an

105
00:04:15,989 --> 00:04:20,070
exploit on the switch those were the the

106
00:04:19,019 --> 00:04:26,270
questions I had in mind when I started

107
00:04:20,070 --> 00:04:26,270
doing this so do you get started

108
00:04:26,430 --> 00:04:30,050
first thing that you'd want to do is see

109
00:04:28,110 --> 00:04:33,300
what the data on the amiibo is like and

110
00:04:30,050 --> 00:04:37,410
if you were if you actually get a scan

111
00:04:33,300 --> 00:04:38,759
or a dump of the NFC tag it's mostly it

112
00:04:37,410 --> 00:04:42,900
looks like this and it's mostly into

113
00:04:38,759 --> 00:04:45,600
safer bytes and mostly it's mostly

114
00:04:42,900 --> 00:04:49,380
encrypted so it turns out part of this

115
00:04:45,600 --> 00:04:52,020
is actually in plain text so if I go go

116
00:04:49,380 --> 00:04:53,159
through the different parts of it some

117
00:04:52,020 --> 00:04:54,448
of the things that you can see here that

118
00:04:53,160 --> 00:04:55,650
the serial number is right at the

119
00:04:54,449 --> 00:04:57,979
beginning and that's that's in plain

120
00:04:55,650 --> 00:05:00,448
text there's actually a character ID

121
00:04:57,979 --> 00:05:02,120
that's also in played in plain text

122
00:05:00,449 --> 00:05:04,680
that's a few bytes long

123
00:05:02,120 --> 00:05:07,590
but the biggest chunk of it down at the

124
00:05:04,680 --> 00:05:09,690
bottom is all encrypted data and then

125
00:05:07,590 --> 00:05:13,258
some of the other stuff in there besides

126
00:05:09,690 --> 00:05:16,500
some settings there's signatures and

127
00:05:13,259 --> 00:05:19,080
hashes for the encrypted data so almost

128
00:05:16,500 --> 00:05:22,620
all of it is protected by encryption and

129
00:05:19,080 --> 00:05:25,050
signing which means you can't you can't

130
00:05:22,620 --> 00:05:29,160
tamper with it because you're not going

131
00:05:25,050 --> 00:05:31,680
to be able to make a valid signature so

132
00:05:29,160 --> 00:05:33,360
the first the first part if I want to

133
00:05:31,680 --> 00:05:34,409
actually edit edit these and mess around

134
00:05:33,360 --> 00:05:39,840
with them I'm gonna have to figure out

135
00:05:34,409 --> 00:05:41,219
the how that crypto works so well to

136
00:05:39,840 --> 00:05:42,659
start off with and at least know that

137
00:05:41,220 --> 00:05:45,330
they're encrypted and also that each

138
00:05:42,659 --> 00:05:47,430
each one is has a unique encryption keys

139
00:05:45,330 --> 00:05:51,479
so they're it's not like I can't use the

140
00:05:47,430 --> 00:05:52,770
same keys or every single also do the

141
00:05:51,479 --> 00:05:54,449
way they're signed you can't you can't

142
00:05:52,770 --> 00:05:56,909
just copy you can't directly copy data

143
00:05:54,449 --> 00:05:58,349
from one amiibo to another the kind of

144
00:05:56,909 --> 00:06:04,409
the signatures actually involved the

145
00:05:58,349 --> 00:06:06,870
serial number of the amiibo so and it's

146
00:06:04,409 --> 00:06:08,969
gonna be very difficult they're very

147
00:06:06,870 --> 00:06:11,550
difficult to do anything with them until

148
00:06:08,970 --> 00:06:13,229
you can break the crypto so one person I

149
00:06:11,550 --> 00:06:15,360
actually already figured this out

150
00:06:13,229 --> 00:06:16,650
and they released this cool called

151
00:06:15,360 --> 00:06:18,360
called the me tool and this this would

152
00:06:16,650 --> 00:06:20,539
actually go through the it would do the

153
00:06:18,360 --> 00:06:23,340
decryption and encryption algorithm but

154
00:06:20,539 --> 00:06:25,380
you need the keys to do that and one

155
00:06:23,340 --> 00:06:26,520
thing that they would not do is release

156
00:06:25,380 --> 00:06:29,820
the keys because they don't want to get

157
00:06:26,520 --> 00:06:30,960
in too much trouble and they also don't

158
00:06:29,820 --> 00:06:33,150
want to you don't want to really aid

159
00:06:30,960 --> 00:06:34,279
people in piracy so if you want the keys

160
00:06:33,150 --> 00:06:37,279
you're gonna have to find them yourself

161
00:06:34,279 --> 00:06:37,279
and

162
00:06:37,400 --> 00:06:41,750
the other the alternative alternatives

163
00:06:39,350 --> 00:06:44,360
to having the keys to use with me tool I

164
00:06:41,750 --> 00:06:46,280
think the same person also made an

165
00:06:44,360 --> 00:06:48,530
online API that you could use if if you

166
00:06:46,280 --> 00:06:49,969
get an API key from them and like you

167
00:06:48,530 --> 00:06:53,330
could send your amiibo data to their

168
00:06:49,970 --> 00:06:56,630
server and it would do the crypto for

169
00:06:53,330 --> 00:06:59,539
you these are what this is I would be

170
00:06:56,630 --> 00:07:01,699
limited to like so there would be kind

171
00:06:59,540 --> 00:07:03,199
of a rate limiting or you know if the

172
00:07:01,699 --> 00:07:05,150
service goes down or if they don't like

173
00:07:03,199 --> 00:07:08,979
what I'm using it for I wouldn't really

174
00:07:05,150 --> 00:07:12,830
be um I'd be restricted by that and

175
00:07:08,979 --> 00:07:15,229
there's also these a little cheat

176
00:07:12,830 --> 00:07:17,300
devices so if you just want to like copy

177
00:07:15,229 --> 00:07:20,870
or edit amiibo there's some you can get

178
00:07:17,300 --> 00:07:22,340
these at Gamestop and they kind of do

179
00:07:20,870 --> 00:07:23,900
the same thing where they you that has

180
00:07:22,340 --> 00:07:25,638
to be connected to your PC and it has to

181
00:07:23,900 --> 00:07:27,530
be online and they're just going to send

182
00:07:25,639 --> 00:07:28,460
your amiibo data to their server and

183
00:07:27,530 --> 00:07:30,859
then do the encryption or decryption

184
00:07:28,460 --> 00:07:32,440
there and also the editing there and

185
00:07:30,860 --> 00:07:35,270
send it back to you

186
00:07:32,440 --> 00:07:37,449
so they're also you know you can't just

187
00:07:35,270 --> 00:07:39,710
use this to do whatever you want either

188
00:07:37,449 --> 00:07:41,090
the they're not really trying to help

189
00:07:39,710 --> 00:07:42,469
like help help you get the keys to do

190
00:07:41,090 --> 00:07:48,409
this yourself they just want you to buy

191
00:07:42,470 --> 00:07:50,930
their their tools so the next next part

192
00:07:48,410 --> 00:07:51,950
so that yeah the first part is to do to

193
00:07:50,930 --> 00:07:53,660
do anything really I'm gonna have to

194
00:07:51,950 --> 00:07:56,750
find the crypto keys and to use within

195
00:07:53,660 --> 00:07:59,090
me tool next is like when I have that

196
00:07:56,750 --> 00:08:02,419
and I can edit the data how am I gonna

197
00:07:59,090 --> 00:08:04,099
actually simulate those so kind of send

198
00:08:02,419 --> 00:08:07,159
whatever ameba data I want to the

199
00:08:04,099 --> 00:08:09,320
console or if I simulate them and the

200
00:08:07,160 --> 00:08:12,169
answer because it's a because it's an

201
00:08:09,320 --> 00:08:14,659
NFC device one of the main tools for for

202
00:08:12,169 --> 00:08:16,549
doing NFC or RFID research is called the

203
00:08:14,660 --> 00:08:20,570
proxmark 3 and it's this software

204
00:08:16,550 --> 00:08:22,099
defined radio tool it's all the code for

205
00:08:20,570 --> 00:08:24,620
it is open source and you can you can

206
00:08:22,099 --> 00:08:26,419
reprogram it so if I wanted to if I

207
00:08:24,620 --> 00:08:29,870
needed to add new behavior to it I could

208
00:08:26,419 --> 00:08:31,370
do that by writing more code and the

209
00:08:29,870 --> 00:08:34,729
nice the other nice thing is that this

210
00:08:31,370 --> 00:08:36,529
could be used this it can simulate the

211
00:08:34,729 --> 00:08:38,270
amiibo and act like an amiibo to the

212
00:08:36,529 --> 00:08:39,770
console it all it could also simulate

213
00:08:38,270 --> 00:08:42,409
the console and act like a console to

214
00:08:39,770 --> 00:08:43,549
the amiibo so for any any steps that I

215
00:08:42,409 --> 00:08:48,130
want to mess around with I'd be able to

216
00:08:43,549 --> 00:08:48,130
do that with the software-defined radio

217
00:08:48,190 --> 00:08:53,810
so

218
00:08:50,380 --> 00:08:57,380
just to go over like what the NFC tag is

219
00:08:53,810 --> 00:08:59,930
again there's basically a digital

220
00:08:57,380 --> 00:09:01,550
control unit so this is like what takes

221
00:08:59,930 --> 00:09:02,900
in commands and we'll send out the

222
00:09:01,550 --> 00:09:09,050
responses and then you have a little bit

223
00:09:02,900 --> 00:09:11,150
of a prom storage and then RF interface

224
00:09:09,050 --> 00:09:17,540
just so it can communicate over over the

225
00:09:11,150 --> 00:09:18,709
radio the proxmark has some has already

226
00:09:17,540 --> 00:09:21,380
has some built-in support for like the

227
00:09:18,710 --> 00:09:24,380
the basic part of this where it can

228
00:09:21,380 --> 00:09:25,910
simulate an NFC tag that wakes up and

229
00:09:24,380 --> 00:09:29,180
reports what its serial number it's

230
00:09:25,910 --> 00:09:31,010
eerie 'el number is but beyond that it's

231
00:09:29,180 --> 00:09:33,040
it doesn't do anything else almost all

232
00:09:31,010 --> 00:09:38,120
the other code for on proxmark is for

233
00:09:33,040 --> 00:09:40,550
messing with like proximity ID cards so

234
00:09:38,120 --> 00:09:44,270
to simulate the specific kind of tag in

235
00:09:40,550 --> 00:09:46,969
an amiibo which is called a end tag we'd

236
00:09:44,270 --> 00:09:52,189
have have to write new code to simulate

237
00:09:46,970 --> 00:09:54,560
that and this this is from the datasheet

238
00:09:52,190 --> 00:09:57,110
on an tag so basically the part on the

239
00:09:54,560 --> 00:09:58,609
top that's in green that's where it's a

240
00:09:57,110 --> 00:10:00,470
gold like wake up and show its ID but

241
00:09:58,610 --> 00:10:02,540
everything at the bottom like reading

242
00:10:00,470 --> 00:10:05,960
reading data writing data there's a

243
00:10:02,540 --> 00:10:08,449
password authentication there's version

244
00:10:05,960 --> 00:10:10,070
and reading signatures all that stuff

245
00:10:08,450 --> 00:10:15,790
would have to have to write new code to

246
00:10:10,070 --> 00:10:20,090
to simulate that on the proxmark so the

247
00:10:15,790 --> 00:10:21,589
so what to do to you know get a useful

248
00:10:20,090 --> 00:10:23,810
tool to actually start tampering with

249
00:10:21,590 --> 00:10:25,760
them eva data and like maybe trying to

250
00:10:23,810 --> 00:10:28,819
do exploits against games of the console

251
00:10:25,760 --> 00:10:31,060
you'd have to first implement the the

252
00:10:28,820 --> 00:10:33,560
end tag 215 simulation with the

253
00:10:31,060 --> 00:10:35,689
software-defined radio like the proxmark

254
00:10:33,560 --> 00:10:38,209
get the crypto keys to actually be able

255
00:10:35,690 --> 00:10:39,890
to change the data and finally kind of

256
00:10:38,210 --> 00:10:42,020
glue them together in a way that you

257
00:10:39,890 --> 00:10:44,390
have like a useful tool where in tamper

258
00:10:42,020 --> 00:10:49,310
with the data send it out to the console

259
00:10:44,390 --> 00:10:51,290
and get get some feedback and come up

260
00:10:49,310 --> 00:10:56,900
with some way to use that to like do

261
00:10:51,290 --> 00:10:59,599
kind of fuzz testing so first first part

262
00:10:56,900 --> 00:11:03,709
i looked at was actually getting the

263
00:10:59,600 --> 00:11:05,240
crypto keys so I like I said before the

264
00:11:03,710 --> 00:11:07,390
some of the people that already figured

265
00:11:05,240 --> 00:11:10,520
this out didn't want to release the keys

266
00:11:07,390 --> 00:11:14,330
but luckily the 3ds was already

267
00:11:10,520 --> 00:11:17,449
jailbroken at this point and by getting

268
00:11:14,330 --> 00:11:19,220
a jailbroken 3ds it would be much easier

269
00:11:17,450 --> 00:11:21,920
to go through the process of just

270
00:11:19,220 --> 00:11:25,940
reverse engineering the NFC service code

271
00:11:21,920 --> 00:11:27,560
on that on that device myself was a you

272
00:11:25,940 --> 00:11:28,850
know that the Cure's of work that the

273
00:11:27,560 --> 00:11:29,810
other people put in the jailbreak it was

274
00:11:28,850 --> 00:11:32,420
already done that was like the hardest

275
00:11:29,810 --> 00:11:34,910
part so at that point I can just dump

276
00:11:32,420 --> 00:11:36,680
out the NFC service binary keys and

277
00:11:34,910 --> 00:11:41,000
start like trying to find can I find the

278
00:11:36,680 --> 00:11:43,790
crypto keys in here and also I can kind

279
00:11:41,000 --> 00:11:46,520
of tamper with those processes while

280
00:11:43,790 --> 00:11:48,860
they're running on the device so there's

281
00:11:46,520 --> 00:11:51,649
this cool custom firmware for the 3d

282
00:11:48,860 --> 00:11:53,779
yesterday that I used it's called NTR

283
00:11:51,649 --> 00:11:55,130
and one of the nice one of the cool

284
00:11:53,779 --> 00:11:59,510
things that it would do is edit debugger

285
00:11:55,130 --> 00:12:02,260
on to the 3ds but sadly the for the

286
00:11:59,510 --> 00:12:04,430
version of 3ds that I had at least

287
00:12:02,260 --> 00:12:06,410
breakpoints in the debugger didn't work

288
00:12:04,430 --> 00:12:07,339
which means I can't just like step

289
00:12:06,410 --> 00:12:09,140
through the code and kind of watch

290
00:12:07,339 --> 00:12:10,520
what's happening as it's going really

291
00:12:09,140 --> 00:12:13,279
all I could do is read and write memory

292
00:12:10,520 --> 00:12:18,890
out of out of the different processes on

293
00:12:13,279 --> 00:12:20,029
the 3ds so this is this is what the

294
00:12:18,890 --> 00:12:23,000
interface where it looks like so you

295
00:12:20,029 --> 00:12:25,580
you'd connect to the debugger um you

296
00:12:23,000 --> 00:12:26,959
could list out processes and then you

297
00:12:25,580 --> 00:12:28,640
can also read and write from memory and

298
00:12:26,959 --> 00:12:31,430
ideally you there's this debugging

299
00:12:28,640 --> 00:12:33,319
feature mm-hmm that you could turn on

300
00:12:31,430 --> 00:12:35,870
but as soon as soon as then I turned on

301
00:12:33,320 --> 00:12:37,160
the as soon as I attached to a process

302
00:12:35,870 --> 00:12:40,550
that try to debug it it would just crash

303
00:12:37,160 --> 00:12:42,730
this read yes so I was eliminated kind

304
00:12:40,550 --> 00:12:45,260
of limited and what I could do with that

305
00:12:42,730 --> 00:12:48,350
but one of the things that I can do just

306
00:12:45,260 --> 00:12:50,720
by dumping memory is is a see if I dump

307
00:12:48,350 --> 00:12:54,339
out so well for one dump out the service

308
00:12:50,720 --> 00:12:57,050
and see like what's inside it but - if I

309
00:12:54,339 --> 00:12:59,570
use some program that actually read an

310
00:12:57,050 --> 00:13:01,640
amiibo and and do something with it then

311
00:12:59,570 --> 00:13:03,649
and you know cause the NFC service to

312
00:13:01,640 --> 00:13:05,899
decrypt it and then I dump the memory

313
00:13:03,649 --> 00:13:09,110
out immediately afterwards I might be

314
00:13:05,899 --> 00:13:13,070
able to recover the decrypted images

315
00:13:09,110 --> 00:13:14,660
that way and that that was one of the

316
00:13:13,070 --> 00:13:16,760
first so one of the first things I did

317
00:13:14,660 --> 00:13:17,020
was I set up a little a custom app that

318
00:13:16,760 --> 00:13:19,390
way

319
00:13:17,020 --> 00:13:21,100
to turn on the NFC service they would

320
00:13:19,390 --> 00:13:22,689
scan it wait for the amiibo to show up

321
00:13:21,100 --> 00:13:26,980
and as soon as it they would read it I

322
00:13:22,690 --> 00:13:28,690
would use the dump the memory feature in

323
00:13:26,980 --> 00:13:32,260
the debugger and then I could search

324
00:13:28,690 --> 00:13:34,680
through it and try to find my decrypted

325
00:13:32,260 --> 00:13:37,830
data so it you can see here kind of that

326
00:13:34,680 --> 00:13:41,319
there's like the plain text nicknamed

327
00:13:37,830 --> 00:13:43,570
the tater in and also like the name of

328
00:13:41,320 --> 00:13:47,260
the me that it was set up set up with as

329
00:13:43,570 --> 00:13:49,029
you can so what this way at least like I

330
00:13:47,260 --> 00:13:50,350
can I can start to get that you hope

331
00:13:49,029 --> 00:13:54,160
that images and see what's inside them

332
00:13:50,350 --> 00:13:57,510
although it's it's a very clunky way to

333
00:13:54,160 --> 00:14:01,899
do it but to go over what we can see now

334
00:13:57,510 --> 00:14:03,459
so there's the nickname the information

335
00:14:01,899 --> 00:14:07,420
about the me that was registered to

336
00:14:03,459 --> 00:14:09,849
there's the the biggest part is the

337
00:14:07,420 --> 00:14:12,149
gamer application data and the the ID

338
00:14:09,850 --> 00:14:14,830
for the application so any any game can

339
00:14:12,149 --> 00:14:18,190
save whatever data it wants into this

340
00:14:14,830 --> 00:14:19,930
game data section so whichever whatever

341
00:14:18,190 --> 00:14:21,610
the last game that you played with that

342
00:14:19,930 --> 00:14:26,260
did this is going to have its data on

343
00:14:21,610 --> 00:14:27,910
there there's the suit the serial number

344
00:14:26,260 --> 00:14:30,790
again and the character ID and also a

345
00:14:27,910 --> 00:14:32,709
signature and then just more more

346
00:14:30,790 --> 00:14:39,910
signature in settings bits they're kind

347
00:14:32,709 --> 00:14:41,920
of less interesting so when it came to

348
00:14:39,910 --> 00:14:45,189
doing like a reverse engineering the NFC

349
00:14:41,920 --> 00:14:48,040
service one of the first things they

350
00:14:45,190 --> 00:14:50,440
kind of do with any any binary is search

351
00:14:48,040 --> 00:14:52,839
for strings that you try to get some

352
00:14:50,440 --> 00:14:54,459
context for what you're looking at and

353
00:14:52,839 --> 00:15:00,089
immediately like just doing a simple

354
00:14:54,459 --> 00:15:00,089
string search found just really weird

355
00:15:00,270 --> 00:15:04,750
really suspicious looking strings the

356
00:15:03,160 --> 00:15:07,410
one of them it said locked secret and

357
00:15:04,750 --> 00:15:09,550
one and one said unfixed infos and like

358
00:15:07,410 --> 00:15:10,959
there wasn't really there weren't really

359
00:15:09,550 --> 00:15:13,390
many other strings at all in the binary

360
00:15:10,959 --> 00:15:16,239
so this stuck out right away but I

361
00:15:13,390 --> 00:15:18,399
didn't know what it was yet and there's

362
00:15:16,240 --> 00:15:21,070
actually two sets of the two sets of

363
00:15:18,399 --> 00:15:26,560
this like unfixed info lock secret

364
00:15:21,070 --> 00:15:29,290
showing up and it will want to figure

365
00:15:26,560 --> 00:15:30,819
out like how the hell these were used I

366
00:15:29,290 --> 00:15:33,670
had some other issues where I was trying

367
00:15:30,820 --> 00:15:35,560
like I wasn't using Ida I tried using

368
00:15:33,670 --> 00:15:37,870
hopper on Linux and it didn't it didn't

369
00:15:35,560 --> 00:15:39,790
work too well or not but one of the

370
00:15:37,870 --> 00:15:42,910
issues with looking at the NFC service

371
00:15:39,790 --> 00:15:44,410
is the code isn't set up like a typical

372
00:15:42,910 --> 00:15:46,030
program where you have the main entry

373
00:15:44,410 --> 00:15:48,579
point and it calls into all the other

374
00:15:46,030 --> 00:15:50,410
parts of the app it's it's a setup as a

375
00:15:48,580 --> 00:15:51,880
service where there's all these little

376
00:15:50,410 --> 00:15:53,530
stub functions for the different service

377
00:15:51,880 --> 00:15:57,040
calls you can make and like little

378
00:15:53,530 --> 00:16:00,520
isolated bits of code so you when you

379
00:15:57,040 --> 00:16:02,500
identify for a typical program you

380
00:16:00,520 --> 00:16:04,660
identify like some main entry point and

381
00:16:02,500 --> 00:16:07,240
then the the disassembler can like kind

382
00:16:04,660 --> 00:16:08,740
of trace the path through all the code

383
00:16:07,240 --> 00:16:10,690
and like keep identifying more stuff for

384
00:16:08,740 --> 00:16:12,400
you automatically but this way I had to

385
00:16:10,690 --> 00:16:14,620
like manually go in and see like did

386
00:16:12,400 --> 00:16:17,230
this look does this look like a you know

387
00:16:14,620 --> 00:16:20,080
a function per log in hex and then like

388
00:16:17,230 --> 00:16:24,280
hit the code analysis thing and turn it

389
00:16:20,080 --> 00:16:27,430
in the code and it was very that like

390
00:16:24,280 --> 00:16:31,540
slow slow process to work with in the

391
00:16:27,430 --> 00:16:34,120
doing the static analysis it also

392
00:16:31,540 --> 00:16:35,770
crashed a lot so so I have like the

393
00:16:34,120 --> 00:16:38,230
broken debugger and like all this hard

394
00:16:35,770 --> 00:16:39,850
to identify code and my discomfort I

395
00:16:38,230 --> 00:16:42,520
can't search without crashing at the

396
00:16:39,850 --> 00:16:46,000
time so what can I do in this situation

397
00:16:42,520 --> 00:16:51,250
so what I decided or what I ended up

398
00:16:46,000 --> 00:16:54,250
doing was using using the custom

399
00:16:51,250 --> 00:16:56,470
application and the the homebrew

400
00:16:54,250 --> 00:17:01,090
libraries that already existed what I

401
00:16:56,470 --> 00:17:02,290
would try to do is leverage them to call

402
00:17:01,090 --> 00:17:03,790
on the certain parts of code and then

403
00:17:02,290 --> 00:17:07,959
identify where that code was in the

404
00:17:03,790 --> 00:17:10,540
binary so there was this code that

405
00:17:07,959 --> 00:17:12,490
there's these error codes that would

406
00:17:10,540 --> 00:17:15,909
show up lot and if you call the certain

407
00:17:12,490 --> 00:17:17,620
function like like open app data or scan

408
00:17:15,910 --> 00:17:19,240
tag or whatever and you called it at the

409
00:17:17,619 --> 00:17:20,948
wrong time you would get this invalid

410
00:17:19,240 --> 00:17:25,959
state error code and it shows up like

411
00:17:20,949 --> 00:17:28,840
kind of all over the place it's and it's

412
00:17:25,959 --> 00:17:30,640
this nice like unique looking 32 bit

413
00:17:28,840 --> 00:17:37,629
value instead of just being like a 1 or

414
00:17:30,640 --> 00:17:38,710
2 and what I did was I would find I

415
00:17:37,630 --> 00:17:41,470
would search for that error code

416
00:17:38,710 --> 00:17:43,090
throughout the binary and the first

417
00:17:41,470 --> 00:17:43,750
thing I did was I'll just replace that

418
00:17:43,090 --> 00:17:46,449
code with

419
00:17:43,750 --> 00:17:47,920
like hex dead beef and then start

420
00:17:46,450 --> 00:17:50,410
calling random functions when I see the

421
00:17:47,920 --> 00:17:52,990
Deb you show up I kind of know like that

422
00:17:50,410 --> 00:17:57,880
I called into that piece of code in the

423
00:17:52,990 --> 00:17:59,650
binary that I had changed the and that

424
00:17:57,880 --> 00:18:01,000
this is where I had like added more

425
00:17:59,650 --> 00:18:02,110
features into the app so I could call

426
00:18:01,000 --> 00:18:04,420
all these different all these different

427
00:18:02,110 --> 00:18:05,709
service calls and kind of do them all at

428
00:18:04,420 --> 00:18:07,420
the wrong time and try to do it when

429
00:18:05,710 --> 00:18:11,440
they when I would be in the invalid

430
00:18:07,420 --> 00:18:13,570
state a second iteration of that was

431
00:18:11,440 --> 00:18:16,300
instead of instead of like putting dead

432
00:18:13,570 --> 00:18:18,669
beef I would put the actual address in

433
00:18:16,300 --> 00:18:20,409
the binary that I had been that I had

434
00:18:18,670 --> 00:18:22,000
replaced so when I see an error code

435
00:18:20,410 --> 00:18:23,800
that shows up that's not the original

436
00:18:22,000 --> 00:18:27,640
error code it's actually giving me the

437
00:18:23,800 --> 00:18:29,770
address to look at in the binary to see

438
00:18:27,640 --> 00:18:31,600
like what what I had called in to and

439
00:18:29,770 --> 00:18:32,860
then I could just start pressing more

440
00:18:31,600 --> 00:18:35,649
buttons like doing things at the wrong

441
00:18:32,860 --> 00:18:37,360
time and if it was in the university it

442
00:18:35,650 --> 00:18:38,770
would it would return an error and the

443
00:18:37,360 --> 00:18:42,580
error would tell me where to look in the

444
00:18:38,770 --> 00:18:45,670
binary to find that code and that the

445
00:18:42,580 --> 00:18:48,699
the last and like the so the last

446
00:18:45,670 --> 00:18:51,940
iteration I did to this and the product

447
00:18:48,700 --> 00:18:53,710
like the best way to use this is instead

448
00:18:51,940 --> 00:18:57,250
of just replacing the in ballots the

449
00:18:53,710 --> 00:18:58,750
error codes I would take a list of all

450
00:18:57,250 --> 00:19:03,070
the different functions where I might

451
00:18:58,750 --> 00:19:06,790
want to where I wanted to see where they

452
00:19:03,070 --> 00:19:07,960
were I would rewrite the beginning of

453
00:19:06,790 --> 00:19:09,850
the function so that it would

454
00:19:07,960 --> 00:19:13,120
immediately just return its own address

455
00:19:09,850 --> 00:19:14,980
as an error code and then now when I

456
00:19:13,120 --> 00:19:17,320
call stuff even if it's like not in it

457
00:19:14,980 --> 00:19:19,510
yeah but invalid state it doesn't matter

458
00:19:17,320 --> 00:19:21,730
what I call it it will immediately just

459
00:19:19,510 --> 00:19:23,410
give me back an error code telling me

460
00:19:21,730 --> 00:19:25,480
what the address is like if I call the

461
00:19:23,410 --> 00:19:27,460
open app data I immediately get an error

462
00:19:25,480 --> 00:19:28,990
code and gives me the address of open

463
00:19:27,460 --> 00:19:31,720
app data in the binary which will help

464
00:19:28,990 --> 00:19:32,920
me reverse engineer that and like it

465
00:19:31,720 --> 00:19:34,180
gives me the context they need to

466
00:19:32,920 --> 00:19:40,800
understand what's happening within that

467
00:19:34,180 --> 00:19:40,800
in that assembly and this is a

468
00:19:43,290 --> 00:19:47,370
this is a video of the app

469
00:19:56,170 --> 00:20:01,960
okay well that's what I get for not

470
00:19:59,290 --> 00:20:04,930
doing a lot of presentation or a demo I

471
00:20:01,960 --> 00:20:08,770
mean okay but okay all that all that

472
00:20:04,930 --> 00:20:11,140
happens is I rewrite the function pour

473
00:20:08,770 --> 00:20:14,680
logs and the nice like you see here the

474
00:20:11,140 --> 00:20:16,180
Ken amiibo settings is instead of

475
00:20:14,680 --> 00:20:19,090
returning the envelops the air code it's

476
00:20:16,180 --> 00:20:21,340
returning its address I go into into

477
00:20:19,090 --> 00:20:23,379
hopper and I go to the address and I

478
00:20:21,340 --> 00:20:25,689
have identified where that function was

479
00:20:23,380 --> 00:20:27,520
in the binary so it's now I can much

480
00:20:25,690 --> 00:20:31,240
more quickly now find my way through

481
00:20:27,520 --> 00:20:34,000
through the NFC service and start to

482
00:20:31,240 --> 00:20:36,580
like focus in on trying to find where

483
00:20:34,000 --> 00:20:39,910
the cryptography functions are in the

484
00:20:36,580 --> 00:20:41,500
binary so then what I start to

485
00:20:39,910 --> 00:20:45,370
eventually you know from there I

486
00:20:41,500 --> 00:20:47,440
actually start to find there's some

487
00:20:45,370 --> 00:20:49,870
function that reads the weird unfixed

488
00:20:47,440 --> 00:20:53,080
info lock secret string strings I had

489
00:20:49,870 --> 00:20:54,550
seen before and it does if you remember

490
00:20:53,080 --> 00:20:55,300
there were two sets there were like two

491
00:20:54,550 --> 00:20:58,149
copies of that

492
00:20:55,300 --> 00:21:01,409
so there's when it when it reads these

493
00:20:58,150 --> 00:21:04,930
values there's actually a conditional

494
00:21:01,410 --> 00:21:07,750
statement that chooses which which set

495
00:21:04,930 --> 00:21:10,030
to read and it reads it reads some weird

496
00:21:07,750 --> 00:21:10,660
bit and it from memory to make this

497
00:21:10,030 --> 00:21:14,649
decision

498
00:21:10,660 --> 00:21:16,750
so I looked up what this bit means and

499
00:21:14,650 --> 00:21:18,880
it's actually something that's up by the

500
00:21:16,750 --> 00:21:22,570
kernel and it and it's it's some

501
00:21:18,880 --> 00:21:24,820
configuration settings that are set by

502
00:21:22,570 --> 00:21:27,250
the kernel and there's this bit in here

503
00:21:24,820 --> 00:21:29,770
that tells you whether the console is as

504
00:21:27,250 --> 00:21:32,530
a developer unit or a retail unit so at

505
00:21:29,770 --> 00:21:35,139
this point I know it's like I already

506
00:21:32,530 --> 00:21:37,149
already knew there's different sets of

507
00:21:35,140 --> 00:21:39,070
encryption keys for retail consoles and

508
00:21:37,150 --> 00:21:41,260
also in the developer console so at this

509
00:21:39,070 --> 00:21:43,389
point I was pretty certain that this

510
00:21:41,260 --> 00:21:47,590
unfixed info lock secret stuff was was

511
00:21:43,390 --> 00:21:53,710
the keys needed to do the encryption for

512
00:21:47,590 --> 00:21:56,709
the amiibo and then you know if I found

513
00:21:53,710 --> 00:21:58,740
another thing that was if you look up

514
00:21:56,710 --> 00:22:01,450
the algorithm for doing H Mac this this

515
00:21:58,740 --> 00:22:03,040
this function matched exactly it's like

516
00:22:01,450 --> 00:22:07,270
you could tell it was doing an H Mac and

517
00:22:03,040 --> 00:22:09,430
also by tracing what the input what to

518
00:22:07,270 --> 00:22:12,490
it was I could see part of that

519
00:22:09,430 --> 00:22:15,220
unfixed info blob was being used as a H

520
00:22:12,490 --> 00:22:17,310
Maki and I could so at this point I can

521
00:22:15,220 --> 00:22:21,900
kind of see like how different parts of

522
00:22:17,310 --> 00:22:25,510
of that crypto information is being used

523
00:22:21,900 --> 00:22:28,810
but and also I can start to see kind of

524
00:22:25,510 --> 00:22:31,480
where like there's stuff in the barn

525
00:22:28,810 --> 00:22:35,970
that looks exactly what's what looks

526
00:22:31,480 --> 00:22:35,970
exactly what the me tool program does

527
00:22:36,090 --> 00:22:40,540
but I just wanted I wanted to get the

528
00:22:38,620 --> 00:22:42,729
keys as quickly as possible so now

529
00:22:40,540 --> 00:22:45,670
knowing knowing that I had at least part

530
00:22:42,730 --> 00:22:48,690
of it I kinda I started searching for

531
00:22:45,670 --> 00:22:51,610
like the parts that I had online and

532
00:22:48,690 --> 00:22:54,370
actually found you know by searching for

533
00:22:51,610 --> 00:22:56,439
them in a certain format I found I found

534
00:22:54,370 --> 00:23:00,159
the whole file that was needed for a me

535
00:22:56,440 --> 00:23:01,150
tool and then I could do the you know I

536
00:23:00,160 --> 00:23:04,060
could do the encryption and decryption

537
00:23:01,150 --> 00:23:06,460
man which was nice but I I looked it was

538
00:23:04,060 --> 00:23:09,970
inside this file inside the key file and

539
00:23:06,460 --> 00:23:11,680
there was stuff in there that I but did

540
00:23:09,970 --> 00:23:13,300
not appear at all in the NFC service

541
00:23:11,680 --> 00:23:17,080
binary or anything else that I looked at

542
00:23:13,300 --> 00:23:18,310
and I wanted to know where word actually

543
00:23:17,080 --> 00:23:19,720
came from the you know so I could

544
00:23:18,310 --> 00:23:25,179
understand what how though the whole

545
00:23:19,720 --> 00:23:27,280
system was working so with the big piece

546
00:23:25,180 --> 00:23:32,260
that hasn't shown up at all yet in this

547
00:23:27,280 --> 00:23:35,020
is the 3ds had had this complicated AES

548
00:23:32,260 --> 00:23:36,940
encryption dedicated hardware that was

549
00:23:35,020 --> 00:23:41,230
explained in like a really good talk

550
00:23:36,940 --> 00:23:44,200
called breaking the 3ds at CCC and what

551
00:23:41,230 --> 00:23:46,120
happens is there there's these two

552
00:23:44,200 --> 00:23:48,340
different key components that get sent

553
00:23:46,120 --> 00:23:50,409
into this hardware AES engine and then

554
00:23:48,340 --> 00:23:52,840
they are scrambled to generate a new key

555
00:23:50,410 --> 00:23:55,720
and that new key can never leave the AES

556
00:23:52,840 --> 00:23:58,080
chip the only way to use it is you till

557
00:23:55,720 --> 00:24:00,310
till this chip what you want to encrypt

558
00:23:58,080 --> 00:24:02,379
and it will do that for you but you can

559
00:24:00,310 --> 00:24:07,080
never access like what what the real key

560
00:24:02,380 --> 00:24:09,520
is being used inside there so the at the

561
00:24:07,080 --> 00:24:11,560
at the breaking the 3ds talk they figure

562
00:24:09,520 --> 00:24:14,639
out what that that algorithm was to

563
00:24:11,560 --> 00:24:17,530
generate the composite key but before

564
00:24:14,640 --> 00:24:22,840
that had that had happened before they

565
00:24:17,530 --> 00:24:25,930
broke that the way the way that the way

566
00:24:22,840 --> 00:24:27,909
this what this engine or do it was using

567
00:24:25,930 --> 00:24:31,570
AES and something called counter mode

568
00:24:27,910 --> 00:24:33,550
and with counter mode you have some

569
00:24:31,570 --> 00:24:36,790
initial counter value and and and uh

570
00:24:33,550 --> 00:24:39,760
nonce and it uses the AES block cipher

571
00:24:36,790 --> 00:24:42,060
to encrypt it crypts the counter and

572
00:24:39,760 --> 00:24:45,879
generates a like a block of kind of

573
00:24:42,060 --> 00:24:48,280
pseudo random data it keeps increasing

574
00:24:45,880 --> 00:24:50,350
the counter and making a new block block

575
00:24:48,280 --> 00:24:52,780
by block and then once you have as you

576
00:24:50,350 --> 00:24:55,570
know enough blocks to cover whatever

577
00:24:52,780 --> 00:24:58,420
your input is it will do X or encryption

578
00:24:55,570 --> 00:25:01,179
with the blocks against your say your

579
00:24:58,420 --> 00:25:04,900
plaintext and then you get the

580
00:25:01,180 --> 00:25:07,630
ciphertext so an important so it an

581
00:25:04,900 --> 00:25:09,760
important part of the XOR operation is

582
00:25:07,630 --> 00:25:12,880
if you XOR something with 0 you just get

583
00:25:09,760 --> 00:25:15,550
the same value back so if you were to to

584
00:25:12,880 --> 00:25:17,530
tell this a s engine just to encrypt all

585
00:25:15,550 --> 00:25:20,530
zeros we're gonna get back is the

586
00:25:17,530 --> 00:25:27,490
immediate the intermediate key stream

587
00:25:20,530 --> 00:25:30,970
and using that you can which is kind of

588
00:25:27,490 --> 00:25:32,230
it's refer to it as a XOR pad using that

589
00:25:30,970 --> 00:25:34,120
you can actually do the offline

590
00:25:32,230 --> 00:25:36,280
encryption and decryption without

591
00:25:34,120 --> 00:25:42,729
needing the the three that the AES

592
00:25:36,280 --> 00:25:44,590
Hardware and this turns out turns out

593
00:25:42,730 --> 00:25:46,840
that this was the that that weird value

594
00:25:44,590 --> 00:25:49,570
that was in the key file that I couldn't

595
00:25:46,840 --> 00:25:51,760
find before and to verify that I just

596
00:25:49,570 --> 00:25:54,730
kind of set up like a Python script to

597
00:25:51,760 --> 00:25:56,820
take different values from the info I

598
00:25:54,730 --> 00:26:01,630
had and try to do a yes and counter mode

599
00:25:56,820 --> 00:26:05,290
and turned out using like the using the

600
00:26:01,630 --> 00:26:09,550
AES parameters from NFC service binary

601
00:26:05,290 --> 00:26:11,740
and using the some NFC key info from the

602
00:26:09,550 --> 00:26:13,629
from the 3ds and you encrypt I just

603
00:26:11,740 --> 00:26:17,080
encrypted a bunch of zeros and I got

604
00:26:13,630 --> 00:26:20,140
something that matched this this weird

605
00:26:17,080 --> 00:26:28,510
32 byte value that was in the I meet me

606
00:26:20,140 --> 00:26:29,620
tool key file so now like now when you

607
00:26:28,510 --> 00:26:31,570
know putting all those parts together

608
00:26:29,620 --> 00:26:36,340
you can start to actually explain what

609
00:26:31,570 --> 00:26:37,929
the entire system is so on the NFC

610
00:26:36,340 --> 00:26:39,850
around the data on the tag there's

611
00:26:37,930 --> 00:26:42,730
there's two partitions to the to the

612
00:26:39,850 --> 00:26:45,639
data that it's on there there's the the

613
00:26:42,730 --> 00:26:47,020
Tet the locked secret part is the tag

614
00:26:45,640 --> 00:26:50,770
information which is like the serial

615
00:26:47,020 --> 00:26:52,930
number the character ID and then a just

616
00:26:50,770 --> 00:26:56,290
a random kind of unique 32 byte value

617
00:26:52,930 --> 00:26:58,570
that's unique to each amigo and then the

618
00:26:56,290 --> 00:27:02,590
other section it's called unfixed infos

619
00:26:58,570 --> 00:27:04,330
is the data as like settings it has the

620
00:27:02,590 --> 00:27:06,280
game data and the registered me data

621
00:27:04,330 --> 00:27:10,530
those are all in the data section and

622
00:27:06,280 --> 00:27:14,410
for each section what happens is

623
00:27:10,530 --> 00:27:16,240
generate two two sets of the AES

624
00:27:14,410 --> 00:27:19,450
parameters and the end each match keys

625
00:27:16,240 --> 00:27:22,240
and and then for each each partition

626
00:27:19,450 --> 00:27:26,680
that the HMR key that was generated for

627
00:27:22,240 --> 00:27:28,540
it they sign that partition in the case

628
00:27:26,680 --> 00:27:32,110
of the data section they encrypt it with

629
00:27:28,540 --> 00:27:33,940
the AES the tag section doesn't get

630
00:27:32,110 --> 00:27:36,729
encrypted that remains in plain text and

631
00:27:33,940 --> 00:27:39,340
then finally they kind of rearrange that

632
00:27:36,730 --> 00:27:43,110
whole buffer to the format it needs to

633
00:27:39,340 --> 00:27:46,659
beat on the NFC tag so to reverse that

634
00:27:43,110 --> 00:27:50,409
they just they you know rearrange the

635
00:27:46,660 --> 00:27:52,300
buffer again generate the keys decrypt

636
00:27:50,410 --> 00:27:56,410
the data and then check all that all the

637
00:27:52,300 --> 00:27:58,450
H max signatures are valid so the most

638
00:27:56,410 --> 00:28:01,090
the the most complicated part of this is

639
00:27:58,450 --> 00:28:03,390
actually doing the generating the AES

640
00:28:01,090 --> 00:28:09,010
parameters and generating the H Marquis

641
00:28:03,390 --> 00:28:11,100
so the way that they do this they have

642
00:28:09,010 --> 00:28:14,590
they use a deterministic random

643
00:28:11,100 --> 00:28:16,449
generator and the the seed for the

644
00:28:14,590 --> 00:28:19,510
random bit generator is going to take

645
00:28:16,450 --> 00:28:23,770
the type string which is the name of the

646
00:28:19,510 --> 00:28:26,200
partition so that would be what the

647
00:28:23,770 --> 00:28:28,120
locked secret or unfixed info string is

648
00:28:26,200 --> 00:28:30,670
that's the type string then they take

649
00:28:28,120 --> 00:28:34,000
some magic bytes to go with that

650
00:28:30,670 --> 00:28:37,030
partition and in the case of a the data

651
00:28:34,000 --> 00:28:39,610
partition mmm excuse me they also

652
00:28:37,030 --> 00:28:41,139
include the right counter which is the

653
00:28:39,610 --> 00:28:44,409
number of times that that tag has been

654
00:28:41,140 --> 00:28:47,680
updated and they put in the serial

655
00:28:44,410 --> 00:28:50,169
number of the tag and finally encrypted

656
00:28:47,680 --> 00:28:54,129
the encrypted 32 byte value which

657
00:28:50,169 --> 00:28:56,139
came from the unique 32 bytes in the in

658
00:28:54,129 --> 00:28:59,139
the tag section getting encrypted

659
00:28:56,139 --> 00:29:00,580
through the AES Hardware engine and like

660
00:28:59,139 --> 00:29:03,219
putting all that stuff together that's

661
00:29:00,580 --> 00:29:06,129
the seed for a random bit generator and

662
00:29:03,220 --> 00:29:09,580
what that bit generator but the bit

663
00:29:06,129 --> 00:29:14,678
generator outputs is 48 bytes that are

664
00:29:09,580 --> 00:29:16,600
gonna be a new AES key account at a es

665
00:29:14,679 --> 00:29:20,529
counter mode parameters and another H

666
00:29:16,600 --> 00:29:22,748
Macke so these are this output is the

667
00:29:20,529 --> 00:29:25,960
the unique keys used on the amiibo and

668
00:29:22,749 --> 00:29:28,809
also in the case of the data section

669
00:29:25,960 --> 00:29:31,480
because the write counter is part of the

670
00:29:28,809 --> 00:29:33,309
as part of the seed every time you

671
00:29:31,480 --> 00:29:34,720
update data on the amiibo that there's a

672
00:29:33,309 --> 00:29:36,609
new set of keys are gonna be generated

673
00:29:34,720 --> 00:29:39,549
so it's not it's not just unique to I

674
00:29:36,609 --> 00:29:41,499
mean though it's it's each I mean both

675
00:29:39,549 --> 00:29:42,879
its you the keys are unique to it in its

676
00:29:41,499 --> 00:29:44,529
current state so every it's like the

677
00:29:42,879 --> 00:29:50,859
keys keep changing every time every time

678
00:29:44,529 --> 00:29:57,100
you update it so that's that's the

679
00:29:50,859 --> 00:29:59,230
crypto system so then the next part you

680
00:29:57,100 --> 00:30:00,820
know having that now I can like edit put

681
00:29:59,230 --> 00:30:03,850
whatever data I want in the amiibo and

682
00:30:00,820 --> 00:30:05,559
and try out out in the game but to do it

683
00:30:03,850 --> 00:30:12,668
in a convenient way like I have to set

684
00:30:05,559 --> 00:30:14,320
up the proxmark simulator so the process

685
00:30:12,669 --> 00:30:16,659
behind this was basically the the

686
00:30:14,320 --> 00:30:18,369
proxmark can sniff traffic so one thing

687
00:30:16,659 --> 00:30:20,320
I would do is put the proxmark between

688
00:30:18,369 --> 00:30:23,019
an amiibo and the console and record all

689
00:30:20,320 --> 00:30:25,239
the traffic and even though proxmark

690
00:30:23,019 --> 00:30:27,009
doesn't support simulating everything

691
00:30:25,239 --> 00:30:28,450
all these things it is pretty good at

692
00:30:27,009 --> 00:30:31,720
actually identifying what the different

693
00:30:28,450 --> 00:30:33,999
commands are that it's seeing and also I

694
00:30:31,720 --> 00:30:37,149
can use the datasheet for the end tag to

695
00:30:33,999 --> 00:30:39,100
an X that also helps like identify what

696
00:30:37,149 --> 00:30:42,178
what traffic I'm seeing there and I can

697
00:30:39,100 --> 00:30:45,219
go through the whole the whole process

698
00:30:42,179 --> 00:30:47,980
of like how the console will read from

699
00:30:45,220 --> 00:30:52,809
the amiibo and kind of build that up in

700
00:30:47,980 --> 00:30:55,509
this in the simulator so the to go over

701
00:30:52,809 --> 00:30:58,450
again the stuff that I need to implement

702
00:30:55,509 --> 00:31:00,249
for the in tag simulation is I'm gonna

703
00:30:58,450 --> 00:31:02,349
have to implement like the read commands

704
00:31:00,249 --> 00:31:03,360
the write command there's something

705
00:31:02,349 --> 00:31:06,620
called conversion

706
00:31:03,360 --> 00:31:09,629
there's a password authentication and

707
00:31:06,620 --> 00:31:12,870
read signature commands and then finally

708
00:31:09,630 --> 00:31:14,580
in addition to just interpreting the

709
00:31:12,870 --> 00:31:17,699
commands I also have to set up some

710
00:31:14,580 --> 00:31:21,120
piece of memory on the proxmark itself

711
00:31:17,700 --> 00:31:23,760
where I can store the the the data that

712
00:31:21,120 --> 00:31:25,860
would be on the NFC tag which was not

713
00:31:23,760 --> 00:31:30,990
something that was like already set up

714
00:31:25,860 --> 00:31:33,510
in the code yet and there's no developer

715
00:31:30,990 --> 00:31:34,890
documentation for developing on proxmark

716
00:31:33,510 --> 00:31:36,810
so you just kind of have to read through

717
00:31:34,890 --> 00:31:38,310
it and like figure out where everything

718
00:31:36,810 --> 00:31:43,110
is and figure out how it works yourself

719
00:31:38,310 --> 00:31:44,820
and then where to add stuff so what I

720
00:31:43,110 --> 00:31:47,070
had originally what I'd like to do is

721
00:31:44,820 --> 00:31:49,110
like make a new generic end tag

722
00:31:47,070 --> 00:31:51,360
simulator thing that B and I send

723
00:31:49,110 --> 00:31:53,459
modular but I ended up just kind of

724
00:31:51,360 --> 00:31:55,110
sticking this into the part of the code

725
00:31:53,460 --> 00:32:02,460
that already simulated like waking up

726
00:31:55,110 --> 00:32:09,209
and reporting the serial number the

727
00:32:02,460 --> 00:32:11,760
amiibo the amiibo so this so this is

728
00:32:09,210 --> 00:32:13,740
like this is what the read operation

729
00:32:11,760 --> 00:32:16,110
looks like so it's almost it's pretty

730
00:32:13,740 --> 00:32:17,490
much the same the console will go

731
00:32:16,110 --> 00:32:18,719
through the same series of steps every

732
00:32:17,490 --> 00:32:21,200
time it's doing a read or every time

733
00:32:18,720 --> 00:32:24,300
it's doing writing so I take this is

734
00:32:21,200 --> 00:32:26,640
what a typical read looks like the

735
00:32:24,300 --> 00:32:28,200
quakes up the amiibo it reads out some

736
00:32:26,640 --> 00:32:31,410
settings and then it will actually start

737
00:32:28,200 --> 00:32:34,980
to read all of the blocks of memory from

738
00:32:31,410 --> 00:32:36,030
the storage so the first and I would you

739
00:32:34,980 --> 00:32:37,740
know go down this list and basically

740
00:32:36,030 --> 00:32:39,149
implement the commands one by one so the

741
00:32:37,740 --> 00:32:44,100
first one is called to get version and

742
00:32:39,150 --> 00:32:46,080
all that does is get for each version of

743
00:32:44,100 --> 00:32:48,120
n tag has its own like a version bytes

744
00:32:46,080 --> 00:32:51,290
and all you have to do is send back the

745
00:32:48,120 --> 00:32:56,040
exact bytes that mean n tag to one five

746
00:32:51,290 --> 00:32:57,690
but one of the like the first two issues

747
00:32:56,040 --> 00:33:00,409
I ran into with doing this even even

748
00:32:57,690 --> 00:33:03,300
though these are very simple commands

749
00:33:00,410 --> 00:33:06,690
every everything that you send has to

750
00:33:03,300 --> 00:33:08,669
have a checksum value sent with it so in

751
00:33:06,690 --> 00:33:11,610
this case they left the calculate the

752
00:33:08,670 --> 00:33:14,970
CRC 16 checksum on the data you're going

753
00:33:11,610 --> 00:33:18,389
to send back but also you you have a

754
00:33:14,970 --> 00:33:22,919
time limit so there's this

755
00:33:18,389 --> 00:33:24,719
the specification for tag says like for

756
00:33:22,919 --> 00:33:27,450
most of these commands you only have

757
00:33:24,720 --> 00:33:29,130
five milliseconds to respond so

758
00:33:27,450 --> 00:33:30,419
including like getting the command

759
00:33:29,130 --> 00:33:32,100
interpreting it and like making your

760
00:33:30,419 --> 00:33:33,809
response then doing a checksum and

761
00:33:32,100 --> 00:33:34,590
sending it back you don't you have you

762
00:33:33,809 --> 00:33:35,850
have to do it in less than five

763
00:33:34,590 --> 00:33:38,010
milliseconds where it's going to reset

764
00:33:35,850 --> 00:33:40,320
and it's not going to work so that's

765
00:33:38,010 --> 00:33:42,590
kind of why you need the specialized

766
00:33:40,320 --> 00:33:46,019
hardware like a proxmark to do this

767
00:33:42,590 --> 00:33:48,110
where they had you know very fast

768
00:33:46,019 --> 00:33:50,970
dedicated hardware to handle all this

769
00:33:48,110 --> 00:33:52,918
but I had what I had to do is for these

770
00:33:50,970 --> 00:33:55,500
kind of initial commands is add them to

771
00:33:52,919 --> 00:33:56,850
a cache where I kind of pre calculated

772
00:33:55,500 --> 00:33:59,190
all the check sums and then when I would

773
00:33:56,850 --> 00:34:01,168
get the command I could I could send the

774
00:33:59,190 --> 00:34:05,070
cached response back and then I wouldn't

775
00:34:01,169 --> 00:34:07,529
timeout right at the beginning the next

776
00:34:05,070 --> 00:34:08,609
part to do there was this read command

777
00:34:07,529 --> 00:34:11,668
and the read command is just going to

778
00:34:08,609 --> 00:34:16,379
read sixteen bytes of data from a

779
00:34:11,668 --> 00:34:17,940
certain location and this is where I

780
00:34:16,379 --> 00:34:25,139
have to start actually implementing the

781
00:34:17,940 --> 00:34:26,540
the EEPROM buffer which one of the

782
00:34:25,139 --> 00:34:29,250
things that existed in the in the code

783
00:34:26,540 --> 00:34:31,230
for proxmark was something called big

784
00:34:29,250 --> 00:34:36,270
buffer and it's like this it's a custom

785
00:34:31,230 --> 00:34:38,399
heap implementation but in addition to

786
00:34:36,270 --> 00:34:40,259
like allocating the allocating memory it

787
00:34:38,399 --> 00:34:43,259
has this reserve section on the heath

788
00:34:40,260 --> 00:34:45,149
where you can put the card the the tag

789
00:34:43,260 --> 00:34:46,589
data and it won't you can like free

790
00:34:45,149 --> 00:34:49,098
everything else but still retain that

791
00:34:46,589 --> 00:34:54,480
tag data across your different

792
00:34:49,099 --> 00:34:56,909
operations so I took that and I also set

793
00:34:54,480 --> 00:35:00,030
it up so I could send I could send data

794
00:34:56,909 --> 00:35:02,369
from my laptop to the proxmark over USB

795
00:35:00,030 --> 00:35:05,940
and store it in the buffer and also it

796
00:35:02,369 --> 00:35:09,030
also a read data back out every USB you

797
00:35:05,940 --> 00:35:11,190
later so if I so I have some I'm you go

798
00:35:09,030 --> 00:35:14,190
image I want to send it in there I can

799
00:35:11,190 --> 00:35:15,750
populate that and it will simulate that

800
00:35:14,190 --> 00:35:17,490
and then I want to down I want to get

801
00:35:15,750 --> 00:35:19,050
the state of it back I can I can

802
00:35:17,490 --> 00:35:21,410
download it back off the practice with

803
00:35:19,050 --> 00:35:21,410
the proxmark

804
00:35:22,190 --> 00:35:27,359
so the next command is the fast read

805
00:35:24,750 --> 00:35:28,890
which is it can read an arbitrary range

806
00:35:27,359 --> 00:35:31,680
of a

807
00:35:28,890 --> 00:35:36,509
the pages pages are just a four byte

808
00:35:31,680 --> 00:35:38,640
blocks of data and this so it takes the

809
00:35:36,510 --> 00:35:41,039
start position in position you return

810
00:35:38,640 --> 00:35:45,839
you calculate the checksum return all

811
00:35:41,039 --> 00:35:49,049
those bytes the right command will

812
00:35:45,839 --> 00:35:50,880
update four bytes at a certain location

813
00:35:49,049 --> 00:35:55,319
there's the password authentication

814
00:35:50,880 --> 00:35:58,770
command so one of the security features

815
00:35:55,319 --> 00:36:01,170
on the end tag is there there's the

816
00:35:58,770 --> 00:36:02,970
right pages or writing two pages can be

817
00:36:01,170 --> 00:36:04,470
locked unless you supply certain

818
00:36:02,970 --> 00:36:06,629
password and if you give the wrong

819
00:36:04,470 --> 00:36:09,118
password too many times it permanently

820
00:36:06,630 --> 00:36:10,529
locks out those pages and you can never

821
00:36:09,119 --> 00:36:11,369
write you can never write new data to

822
00:36:10,529 --> 00:36:14,220
them again after that

823
00:36:11,369 --> 00:36:15,960
so for simulating I don't really care if

824
00:36:14,220 --> 00:36:18,209
the console tells me the right password

825
00:36:15,960 --> 00:36:20,789
or not I can just always accept it

826
00:36:18,210 --> 00:36:22,589
but if I want you know I still wanted to

827
00:36:20,789 --> 00:36:23,880
know like how this worked in like how I

828
00:36:22,589 --> 00:36:27,390
could figure out what the correct

829
00:36:23,880 --> 00:36:30,779
password was and one of the nice things

830
00:36:27,390 --> 00:36:35,129
I can do with the proxmark is I can kind

831
00:36:30,779 --> 00:36:37,859
of send arbitrary serial numbers when

832
00:36:35,130 --> 00:36:40,349
when a console tries to wake up the EMU

833
00:36:37,859 --> 00:36:41,910
go and a notice if I just put in all

834
00:36:40,349 --> 00:36:44,250
zeros in the serial number I get this

835
00:36:41,910 --> 00:36:48,240
weird weird password back that's just a

836
00:36:44,250 --> 00:36:52,980
a 5/5 a 5/5 that's just the alternating

837
00:36:48,240 --> 00:36:55,229
pattern of zero and one bits and if I

838
00:36:52,980 --> 00:36:57,059
sent if I put like that same if I start

839
00:36:55,230 --> 00:37:00,029
to put the same value into my serial

840
00:36:57,059 --> 00:37:02,309
number I get back zeros instead of

841
00:37:00,029 --> 00:37:04,890
whatever was there originally so like I

842
00:37:02,309 --> 00:37:07,289
put in the a a the first one gets zeroed

843
00:37:04,890 --> 00:37:09,779
out I put in five five this is the first

844
00:37:07,289 --> 00:37:11,539
two bytes of the password or now zero so

845
00:37:09,779 --> 00:37:14,010
this looks like it's XOR again because

846
00:37:11,539 --> 00:37:16,829
you XOR the same thing against itself

847
00:37:14,010 --> 00:37:21,089
you get zero or if you XOR to get zero

848
00:37:16,829 --> 00:37:23,460
again 0 you get the same thing and so

849
00:37:21,089 --> 00:37:25,380
what I did next was if I instead of

850
00:37:23,460 --> 00:37:27,869
sending zeros I just put this FF by it

851
00:37:25,380 --> 00:37:32,069
at different locations in the serial

852
00:37:27,869 --> 00:37:36,660
number and then I take out that that a

853
00:37:32,069 --> 00:37:38,160
a5 a5 mask you can just see the byte

854
00:37:36,660 --> 00:37:40,589
from the serial number is getting copied

855
00:37:38,160 --> 00:37:42,230
directly into the password until like

856
00:37:40,589 --> 00:37:45,230
the third position where

857
00:37:42,230 --> 00:37:49,880
is actually this shadowing copy of that

858
00:37:45,230 --> 00:37:52,130
by it so if I miss Marin and I add more

859
00:37:49,880 --> 00:37:55,850
I said more bytes to FF I can actually

860
00:37:52,130 --> 00:37:58,820
you know if I put one two positions

861
00:37:55,850 --> 00:38:00,319
ahead I get a zero out the FF that I'd

862
00:37:58,820 --> 00:38:03,290
shared up if I put one two positions

863
00:38:00,320 --> 00:38:06,470
behind a zero out the other one and I

864
00:38:03,290 --> 00:38:07,609
can fit like doing this I figure out you

865
00:38:06,470 --> 00:38:09,709
can figure out the algorithm for this

866
00:38:07,609 --> 00:38:13,730
pretty easily so it just goes through

867
00:38:09,710 --> 00:38:15,290
this process of exploring different

868
00:38:13,730 --> 00:38:16,280
bytes in the serial number and that's

869
00:38:15,290 --> 00:38:22,130
how it's going to generate these

870
00:38:16,280 --> 00:38:24,200
passwords for any time you go hey and

871
00:38:22,130 --> 00:38:26,750
then the last part was kind of just

872
00:38:24,200 --> 00:38:28,220
integrating the crypto with the

873
00:38:26,750 --> 00:38:32,119
simulator

874
00:38:28,220 --> 00:38:34,959
Sergi that proxmark the proxmark client

875
00:38:32,119 --> 00:38:37,730
actually has a Lua built into it so

876
00:38:34,960 --> 00:38:39,380
decided I could set up all my logic for

877
00:38:37,730 --> 00:38:41,720
like fuzzing and stuff and handling the

878
00:38:39,380 --> 00:38:46,580
Meebo in Lua cuz that's a lot it's a lot

879
00:38:41,720 --> 00:38:49,390
easier to do to write than C and kind of

880
00:38:46,580 --> 00:38:53,630
overall design of it looks like this so

881
00:38:49,390 --> 00:38:55,339
on the client side I have my the Lua

882
00:38:53,630 --> 00:38:57,770
script where you can put your fuzzy

883
00:38:55,340 --> 00:39:00,200
logic and also you can call the Emmy

884
00:38:57,770 --> 00:39:02,270
tool to do encryption or decryption for

885
00:39:00,200 --> 00:39:04,490
you and then you send whatever whatever

886
00:39:02,270 --> 00:39:08,150
you want to simulate you send it over

887
00:39:04,490 --> 00:39:08,629
USB to the simulator that's on the

888
00:39:08,150 --> 00:39:13,390
proxmark

889
00:39:08,630 --> 00:39:16,070
firmware and if like when you want to

890
00:39:13,390 --> 00:39:18,049
get the new state of the simulator you

891
00:39:16,070 --> 00:39:22,850
can you can read that buffer back out

892
00:39:18,050 --> 00:39:26,060
the EEPROM buffer back out over USB so

893
00:39:22,850 --> 00:39:29,390
that that's the that's the simulator is

894
00:39:26,060 --> 00:39:32,900
done and it worked it worked fine on the

895
00:39:29,390 --> 00:39:35,540
3ds but as soon as the switch came out

896
00:39:32,900 --> 00:39:40,670
and I tried using out and switch it

897
00:39:35,540 --> 00:39:42,890
didn't really work so well so part of

898
00:39:40,670 --> 00:39:46,520
the part of the issue was that the

899
00:39:42,890 --> 00:39:47,900
antenna you want you want the dimensions

900
00:39:46,520 --> 00:39:51,590
of the antenna to be pretty similar to

901
00:39:47,900 --> 00:39:52,430
the dimensions of the tag and on the on

902
00:39:51,590 --> 00:39:55,670
the 3ds

903
00:39:52,430 --> 00:39:56,299
so the and the default antenna you get

904
00:39:55,670 --> 00:39:58,640
with proxmark

905
00:39:56,300 --> 00:40:00,260
kind of shaped like an ID card and that

906
00:39:58,640 --> 00:40:02,420
happens to be good for the three guess

907
00:40:00,260 --> 00:40:04,490
because the antenna in the 3ds is also

908
00:40:02,420 --> 00:40:07,190
kind of shaped like a ID card and it's

909
00:40:04,490 --> 00:40:08,689
similar size but the switch there's this

910
00:40:07,190 --> 00:40:12,500
little antenna that's like the size if

911
00:40:08,690 --> 00:40:15,500
your your finger tip so you get a very

912
00:40:12,500 --> 00:40:17,150
bad signal trying to use the big ID card

913
00:40:15,500 --> 00:40:19,280
sized antenna

914
00:40:17,150 --> 00:40:22,490
the official guide for like making your

915
00:40:19,280 --> 00:40:24,800
own antenna is you you take a bunch of

916
00:40:22,490 --> 00:40:26,509
an ammo wire and wrap it around hundreds

917
00:40:24,800 --> 00:40:28,580
of times and then manually like unwrap

918
00:40:26,510 --> 00:40:31,160
it until it's tuned correctly and I

919
00:40:28,580 --> 00:40:34,210
didn't want to do that so I tried to I

920
00:40:31,160 --> 00:40:36,020
tried to just buy like these pre-made

921
00:40:34,210 --> 00:40:37,550
antennas that were kind of like the

922
00:40:36,020 --> 00:40:40,880
right size that looked like this so I

923
00:40:37,550 --> 00:40:42,560
also I didn't have any background in

924
00:40:40,880 --> 00:40:44,840
electrical engineering so I had to find

925
00:40:42,560 --> 00:40:47,330
out why that that doesn't work you you

926
00:40:44,840 --> 00:40:53,240
can't the the antenna it has to be tuned

927
00:40:47,330 --> 00:40:54,980
to the entire circuit and I'm not going

928
00:40:53,240 --> 00:40:57,200
to go too much into it but an NFC

929
00:40:54,980 --> 00:40:59,300
antenna is basically a circuit with an

930
00:40:57,200 --> 00:41:01,009
inductor and a capacitor and they have

931
00:40:59,300 --> 00:41:03,080
to be matched up just the right way to

932
00:41:01,010 --> 00:41:05,320
have a certain resonant frequency and

933
00:41:03,080 --> 00:41:07,549
you want the resonant frequency to be

934
00:41:05,320 --> 00:41:10,100
the frequency you're communicating on

935
00:41:07,550 --> 00:41:14,770
and that's on NFC that's thirteen point

936
00:41:10,100 --> 00:41:17,540
five six megahertz so because of the

937
00:41:14,770 --> 00:41:20,000
capacitor that was on the you know the

938
00:41:17,540 --> 00:41:21,860
the the capacitor they had on the

939
00:41:20,000 --> 00:41:24,050
proxmark what was set up

940
00:41:21,860 --> 00:41:27,560
you know if the it was tuned with the

941
00:41:24,050 --> 00:41:29,240
antenna it came with for to use the

942
00:41:27,560 --> 00:41:34,009
antenna that I had I would need

943
00:41:29,240 --> 00:41:36,709
different capacitance to match that and

944
00:41:34,010 --> 00:41:39,680
I had gone through like you know

945
00:41:36,710 --> 00:41:41,690
figuring out like how do I get the

946
00:41:39,680 --> 00:41:43,730
capacitance to be correct so you can

947
00:41:41,690 --> 00:41:46,070
calculate like you know using your

948
00:41:43,730 --> 00:41:47,240
capacitance and the property of the

949
00:41:46,070 --> 00:41:50,810
antenna I figure out what the resonant

950
00:41:47,240 --> 00:41:53,120
frequency is and like I had five mega or

951
00:41:50,810 --> 00:41:55,640
about six megahertz with that thing that

952
00:41:53,120 --> 00:41:57,380
I bought and then to figure out like

953
00:41:55,640 --> 00:42:02,870
okay I can add more capacitors to try to

954
00:41:57,380 --> 00:42:07,580
get it into the correct range ended up

955
00:42:02,870 --> 00:42:09,690
so it's kind of hard to it turns out the

956
00:42:07,580 --> 00:42:12,328
capacitors you use for

957
00:42:09,690 --> 00:42:16,079
high-frequency radio they're very tiny

958
00:42:12,329 --> 00:42:17,730
and not like I would probably have to

959
00:42:16,079 --> 00:42:21,420
make a custom design circuit board to

960
00:42:17,730 --> 00:42:23,160
use those so back to square one with

961
00:42:21,420 --> 00:42:25,920
like ticking enamel wire and manually

962
00:42:23,160 --> 00:42:28,920
tuning it but I did try to like displace

963
00:42:25,920 --> 00:42:30,359
in this crappy 10 Pico farad capacitor

964
00:42:28,920 --> 00:42:32,700
and see if it would cook which is kind

965
00:42:30,359 --> 00:42:35,098
of close to what I needed and it did

966
00:42:32,700 --> 00:42:37,890
sort of work for with the amiibo but it

967
00:42:35,099 --> 00:42:39,390
didn't work with the switch it's also

968
00:42:37,890 --> 00:42:43,859
it's not a capacitor that's designed for

969
00:42:39,390 --> 00:42:46,319
for RF so okay so the last thing that

970
00:42:43,859 --> 00:42:48,750
there was this signature check another

971
00:42:46,319 --> 00:42:51,720
another feature of these n tags is they

972
00:42:48,750 --> 00:42:55,319
have a signature on them that proves NXP

973
00:42:51,720 --> 00:42:59,819
Semiconductors made them and it's a look

974
00:42:55,319 --> 00:43:03,690
elliptic curve digital signature and the

975
00:42:59,819 --> 00:43:05,849
idea part of the idea is like if you

976
00:43:03,690 --> 00:43:07,020
were to either simulate or want you want

977
00:43:05,849 --> 00:43:08,670
it's like produce your own tag you

978
00:43:07,020 --> 00:43:12,450
wouldn't be able to create a valid

979
00:43:08,670 --> 00:43:17,849
serial number and signature unless you

980
00:43:12,450 --> 00:43:21,029
had an XPS private key which means that

981
00:43:17,849 --> 00:43:22,829
I can't just because the the newer

982
00:43:21,030 --> 00:43:24,839
console actually checks the signature I

983
00:43:22,829 --> 00:43:27,180
can't just use any serial number I want

984
00:43:24,839 --> 00:43:30,089
to unless I know what the the signature

985
00:43:27,180 --> 00:43:32,009
is and that's kind of a problem because

986
00:43:30,089 --> 00:43:34,619
some games like like the breath of the

987
00:43:32,010 --> 00:43:36,930
wild will limit how often you can use a

988
00:43:34,619 --> 00:43:38,280
certain amiibo and they limit it like

989
00:43:36,930 --> 00:43:40,950
they'll say you can only use it once per

990
00:43:38,280 --> 00:43:42,599
day and they limit it based on the

991
00:43:40,950 --> 00:43:43,890
serial number and that's bad if I want

992
00:43:42,599 --> 00:43:48,990
to try like hundreds of different

993
00:43:43,890 --> 00:43:51,270
different uh inputs so because of the

994
00:43:48,990 --> 00:43:52,740
signature it seems like I'm not going to

995
00:43:51,270 --> 00:43:56,730
be able to just do whatever whatever is

996
00:43:52,740 --> 00:43:59,399
here a long number I wanted but the well

997
00:43:56,730 --> 00:44:04,829
then I started like try to see what can

998
00:43:59,400 --> 00:44:06,210
I do to mess around with this so I was I

999
00:44:04,829 --> 00:44:07,650
did wonder how some of those cheat

1000
00:44:06,210 --> 00:44:09,540
devices like you get it GameStop would

1001
00:44:07,650 --> 00:44:11,220
do it and I'm not sure so I didn't

1002
00:44:09,540 --> 00:44:14,910
actually look into too much but I know

1003
00:44:11,220 --> 00:44:16,529
that because every amiibo you use with

1004
00:44:14,910 --> 00:44:18,710
them you're sending all your data to

1005
00:44:16,530 --> 00:44:21,180
their server there they can collect

1006
00:44:18,710 --> 00:44:23,160
serial numbers and tête and signatures

1007
00:44:21,180 --> 00:44:26,609
from you which is not some

1008
00:44:23,160 --> 00:44:29,700
I'd be able to recreate I tried to look

1009
00:44:26,610 --> 00:44:33,680
for kind of like crypto implementation

1010
00:44:29,700 --> 00:44:38,370
errors so that what this yeah oh yeah

1011
00:44:33,680 --> 00:44:39,660
that's so one of the things that you can

1012
00:44:38,370 --> 00:44:43,230
screw up with this elliptic curve

1013
00:44:39,660 --> 00:44:44,160
signature is if there's a nonce value

1014
00:44:43,230 --> 00:44:46,380
that you're only supposed to use one

1015
00:44:44,160 --> 00:44:48,540
super signature and if you reuse it you

1016
00:44:46,380 --> 00:44:51,060
leak your private key out so this

1017
00:44:48,540 --> 00:44:54,210
happened with the PlayStation 3 game

1018
00:44:51,060 --> 00:44:56,190
signatures I checked if they had done

1019
00:44:54,210 --> 00:44:57,630
this and put the small set of amiibo

1020
00:44:56,190 --> 00:45:04,190
that I checked they they hadn't reuse

1021
00:44:57,630 --> 00:45:06,270
this knots but finally I looked over

1022
00:45:04,190 --> 00:45:08,940
actually messing around with the with

1023
00:45:06,270 --> 00:45:11,400
the protocol of when the console tries

1024
00:45:08,940 --> 00:45:13,370
to redeem Evo and this is the whole

1025
00:45:11,400 --> 00:45:16,620
process it's going to go through it

1026
00:45:13,370 --> 00:45:17,970
finds it slightly gets the tags ID it

1027
00:45:16,620 --> 00:45:19,140
reads the signature out and then it's

1028
00:45:17,970 --> 00:45:21,419
going to validate the idea with the

1029
00:45:19,140 --> 00:45:23,879
signature and finally it's going to read

1030
00:45:21,420 --> 00:45:27,000
out all the data check the the hmx

1031
00:45:23,880 --> 00:45:31,170
signatures and make sure that the hmx

1032
00:45:27,000 --> 00:45:35,400
signatures are correct so the problem

1033
00:45:31,170 --> 00:45:38,730
here is when they validate the ID with

1034
00:45:35,400 --> 00:45:40,710
what the ID signature and then they

1035
00:45:38,730 --> 00:45:42,990
afterwards they check the hmm con the

1036
00:45:40,710 --> 00:45:46,110
data they never correlate the ID in the

1037
00:45:42,990 --> 00:45:51,060
data with the ID that I checked at the

1038
00:45:46,110 --> 00:45:53,250
beginning of this process so in the at

1039
00:45:51,060 --> 00:45:56,040
the start of it you can give whatever

1040
00:45:53,250 --> 00:45:59,150
known known serial number and signature

1041
00:45:56,040 --> 00:46:01,680
you have like so if you know just one

1042
00:45:59,150 --> 00:46:04,440
pair of like a serial number and its

1043
00:46:01,680 --> 00:46:06,270
signature you send that first but then

1044
00:46:04,440 --> 00:46:08,550
when you actually respond to the read

1045
00:46:06,270 --> 00:46:10,650
commands you send data for for any other

1046
00:46:08,550 --> 00:46:21,480
I mean go with it with a different

1047
00:46:10,650 --> 00:46:22,830
serial number so doing that so that was

1048
00:46:21,480 --> 00:46:26,280
the way to get around the game around

1049
00:46:22,830 --> 00:46:28,980
this they did I reported it to them and

1050
00:46:26,280 --> 00:46:30,630
they finally patched it on version 5 but

1051
00:46:28,980 --> 00:46:31,980
they said that there was no way to fix

1052
00:46:30,630 --> 00:46:35,970
it on the Wii U which I did which I

1053
00:46:31,980 --> 00:46:37,140
found kind of interesting but so now

1054
00:46:35,970 --> 00:46:39,000
finally I can I can

1055
00:46:37,140 --> 00:46:42,538
and like arbitrary you know whatever

1056
00:46:39,000 --> 00:46:47,880
data I want to the console and I'll try

1057
00:46:42,539 --> 00:46:51,349
to go quickly to through the other video

1058
00:46:47,880 --> 00:46:51,349
is not okay let's see

1059
00:47:03,250 --> 00:47:05,850
okay

1060
00:47:09,480 --> 00:47:12,480
this

1061
00:47:25,049 --> 00:47:30,339
okay so this is on the bottom you can

1062
00:47:28,000 --> 00:47:33,579
see that the client where I'm running a

1063
00:47:30,339 --> 00:47:37,170
script to load an amiibo image into the

1064
00:47:33,579 --> 00:47:47,799
proxmark and then on the top you

1065
00:47:37,170 --> 00:47:49,420
actually see the switch so and because

1066
00:47:47,799 --> 00:47:50,710
because this antenna isn't great it

1067
00:47:49,420 --> 00:47:54,460
takes it takes a little while sometimes

1068
00:47:50,710 --> 00:47:56,049
but and it showed up I and here I'm

1069
00:47:54,460 --> 00:48:00,819
going to enter like a nickname and save

1070
00:47:56,049 --> 00:48:03,160
it and I would show like loading it up

1071
00:48:00,819 --> 00:48:04,750
again the show that it saved that it's

1072
00:48:03,160 --> 00:48:06,490
like the data is persisting in the

1073
00:48:04,750 --> 00:48:16,000
simulator but I kind of want to skip

1074
00:48:06,490 --> 00:48:19,899
ahead to and then I sure showed it on

1075
00:48:16,000 --> 00:48:22,380
the 3ds in the same session because it's

1076
00:48:19,900 --> 00:48:22,380
cross-compatible

1077
00:48:30,560 --> 00:48:36,710
and finally I use it in the breasts of

1078
00:48:33,200 --> 00:48:38,149
the wild game we're using a certain

1079
00:48:36,710 --> 00:48:40,610
using a certain amiibo that's like

1080
00:48:38,150 --> 00:48:46,370
harder to buy now you can get like this

1081
00:48:40,610 --> 00:48:48,170
horse yeah so okay so that's their this

1082
00:48:46,370 --> 00:48:49,569
is oh I don't know if there's any time

1083
00:48:48,170 --> 00:49:06,820
for questions

1084
00:48:49,570 --> 00:49:06,820
one one or two are there any questions

1085
00:49:10,420 --> 00:49:15,920
that I would have is going in and doing

1086
00:49:13,640 --> 00:49:17,980
the fuzzing after this did you find

1087
00:49:15,920 --> 00:49:23,720
anything interesting after that oh right

1088
00:49:17,980 --> 00:49:25,340
so this is so that at that point that

1089
00:49:23,720 --> 00:49:26,930
was like before I stopped though so that

1090
00:49:25,340 --> 00:49:28,940
so that the next step is is actually

1091
00:49:26,930 --> 00:49:30,290
like now I have this working tool and I

1092
00:49:28,940 --> 00:49:32,300
want to start simulating the idea the

1093
00:49:30,290 --> 00:49:34,759
issue is that the new games on the

1094
00:49:32,300 --> 00:49:37,310
switch added a new layer of encryption

1095
00:49:34,760 --> 00:49:39,350
and on to the game data so like splatoon

1096
00:49:37,310 --> 00:49:41,600
- for example even though I could read

1097
00:49:39,350 --> 00:49:44,270
all the other parts of the amiibo like

1098
00:49:41,600 --> 00:49:46,069
all the game data has a new layer of

1099
00:49:44,270 --> 00:49:49,040
encryption and what I wanted to do was

1100
00:49:46,070 --> 00:49:50,390
figure out how that works but that you

1101
00:49:49,040 --> 00:49:52,730
know couldn't really do that until the

1102
00:49:50,390 --> 00:49:56,060
switch was jailbroken and you could

1103
00:49:52,730 --> 00:49:57,560
decrypt the game but I think I think the

1104
00:49:56,060 --> 00:49:58,910
people that actually made some of the

1105
00:49:57,560 --> 00:50:00,740
first gel bricks for this which I've

1106
00:49:58,910 --> 00:50:03,230
already looked at this platoon too and

1107
00:50:00,740 --> 00:50:08,149
they figured out what that encryption is

1108
00:50:03,230 --> 00:50:10,300
so I I had kind of moved on like to

1109
00:50:08,150 --> 00:50:13,010
doing a different project after it but

1110
00:50:10,300 --> 00:50:14,930
all the all the source code for that so

1111
00:50:13,010 --> 00:50:18,680
if you have a proxmark 3 I put all the

1112
00:50:14,930 --> 00:50:24,319
source code up on github and try to get

1113
00:50:18,680 --> 00:50:27,440
to show the link so it's all its this

1114
00:50:24,320 --> 00:50:29,330
all github and you know parks marks kind

1115
00:50:27,440 --> 00:50:31,220
of expensive but if you have it you can

1116
00:50:29,330 --> 00:50:34,700
like take this code and try it out

1117
00:50:31,220 --> 00:50:36,020
yourself and you know now that

1118
00:50:34,700 --> 00:50:38,330
somebody's figured out the splatoon -

1119
00:50:36,020 --> 00:50:40,720
crypto you think you could try messing

1120
00:50:38,330 --> 00:50:40,720
around with that

1121
00:50:42,609 --> 00:50:45,609
but

1122
00:50:50,550 --> 00:50:54,440
so that's it

