1
00:00:11,440 --> 00:00:13,920
hello everyone welcome to the next talk

2
00:00:13,920 --> 00:00:17,119
in track three today uh we're glad

3
00:00:17,119 --> 00:00:19,039
you're all here hope you're enjoying the

4
00:00:19,039 --> 00:00:20,480
the conference so far i hope you enjoyed

5
00:00:20,480 --> 00:00:22,880
the keynote a couple points of business

6
00:00:22,880 --> 00:00:24,480
please silence your cell phones when

7
00:00:24,480 --> 00:00:25,920
you're in the track room itself the

8
00:00:25,920 --> 00:00:27,519
audio is pretty sensitive and it can

9
00:00:27,519 --> 00:00:29,920
pick it up from quite a distance away

10
00:00:29,920 --> 00:00:32,800
and um

11
00:00:32,800 --> 00:00:35,600
i forgot my second point so

12
00:00:35,600 --> 00:00:36,719
this talk

13
00:00:36,719 --> 00:00:38,480
is by noof

14
00:00:38,480 --> 00:00:40,800
and it is on cherry a modern capability

15
00:00:40,800 --> 00:00:42,640
architectural framework

16
00:00:42,640 --> 00:00:45,200
so we will be doing the talk he says

17
00:00:45,200 --> 00:00:47,680
about 40 minutes we should have about 10

18
00:00:47,680 --> 00:00:49,920
minutes of qa at the end so we get the

19
00:00:49,920 --> 00:00:53,760
qa i will be over here on the mic so let

20
00:00:53,760 --> 00:00:55,199
me know what your question is i'll

21
00:00:55,199 --> 00:00:57,280
repeat the question back and then we can

22
00:00:57,280 --> 00:00:58,480
he'll be able to answer questions we

23
00:00:58,480 --> 00:01:00,160
also have some chat questions coming in

24
00:01:00,160 --> 00:01:02,960
through our matrix chat forum so as i

25
00:01:02,960 --> 00:01:06,239
said enjoy the talk

26
00:01:07,119 --> 00:01:09,280
hello everyone i'm luke and today i'm

27
00:01:09,280 --> 00:01:10,799
going to talk to you about cherry a

28
00:01:10,799 --> 00:01:12,560
modern computing architecture centered

29
00:01:12,560 --> 00:01:14,960
around capabilities

30
00:01:14,960 --> 00:01:17,119
uh before we dive in too much i should

31
00:01:17,119 --> 00:01:18,720
point out i work

32
00:01:18,720 --> 00:01:20,880
on cherry for microsoft but i'm not

33
00:01:20,880 --> 00:01:23,200
speaking for my employer

34
00:01:23,200 --> 00:01:25,280
opinions in this talk are mine

35
00:01:25,280 --> 00:01:27,920
uh cherry is a science experiment and so

36
00:01:27,920 --> 00:01:30,000
please don't take this as you know a

37
00:01:30,000 --> 00:01:32,720
commitment or promise of future products

38
00:01:32,720 --> 00:01:35,520
um as said questions during uh via

39
00:01:35,520 --> 00:01:37,520
matrix and there will be some time for q

40
00:01:37,520 --> 00:01:40,240
a at the end

41
00:01:40,240 --> 00:01:42,159
so a more inflammatory title for this

42
00:01:42,159 --> 00:01:43,840
talk might have been modern computing

43
00:01:43,840 --> 00:01:46,560
architecture unsafe at any speed

44
00:01:46,560 --> 00:01:50,720
uh and why might someone claim that

45
00:01:50,720 --> 00:01:51,680
so

46
00:01:51,680 --> 00:01:53,680
a less contentious phrasing of that is

47
00:01:53,680 --> 00:01:55,280
that software security really isn't

48
00:01:55,280 --> 00:01:57,040
great

49
00:01:57,040 --> 00:01:59,600
as computers continue to infiltrate

50
00:01:59,600 --> 00:02:02,079
every aspect of existence we're seeing a

51
00:02:02,079 --> 00:02:06,639
steep upward trend in yearly cves

52
00:02:07,680 --> 00:02:10,160
but embarrassingly these tend not to be

53
00:02:10,160 --> 00:02:12,319
like new kinds of bugs from new kinds of

54
00:02:12,319 --> 00:02:16,000
domains but rather year after year 70 of

55
00:02:16,000 --> 00:02:17,760
these things turn out to be from memory

56
00:02:17,760 --> 00:02:19,920
safety problems by which i mean pointer

57
00:02:19,920 --> 00:02:21,920
injection buffer overflows use have to

58
00:02:21,920 --> 00:02:24,000
free and so on

59
00:02:24,000 --> 00:02:25,520
these problems have been with us since

60
00:02:25,520 --> 00:02:27,440
the beginning at least the beginning of

61
00:02:27,440 --> 00:02:30,080
unix so about 50 years if not a little

62
00:02:30,080 --> 00:02:31,680
bit longer

63
00:02:31,680 --> 00:02:33,840
and okay they weren't widely known but

64
00:02:33,840 --> 00:02:36,480
they came to broader awareness in 1996

65
00:02:36,480 --> 00:02:38,319
with aleph ones smashing the stack for

66
00:02:38,319 --> 00:02:40,239
fun and profit

67
00:02:40,239 --> 00:02:42,080
and so even by that standard it's been

68
00:02:42,080 --> 00:02:45,360
25 years and counting

69
00:02:46,959 --> 00:02:48,640
and it turns out that if you take 70

70
00:02:48,640 --> 00:02:51,200
percent of an increasingly bad time it

71
00:02:51,200 --> 00:02:53,360
turns out to still be an increasingly

72
00:02:53,360 --> 00:02:54,560
bad time

73
00:02:54,560 --> 00:02:56,720
uh microsoft security response center is

74
00:02:56,720 --> 00:02:58,480
handling more and more memory safety

75
00:02:58,480 --> 00:03:01,440
issues every year

76
00:03:02,879 --> 00:03:04,720
of course we're not the first people to

77
00:03:04,720 --> 00:03:06,720
identify a 50 year old problem lots of

78
00:03:06,720 --> 00:03:08,720
people have tried lots of things ranging

79
00:03:08,720 --> 00:03:10,959
from minor tinkering to vast sweeping

80
00:03:10,959 --> 00:03:12,959
overhauls of everything some examples

81
00:03:12,959 --> 00:03:14,400
are on the slide

82
00:03:14,400 --> 00:03:16,239
unfortunately nothing really seems to

83
00:03:16,239 --> 00:03:18,319
have moved us closer to done for

84
00:03:18,319 --> 00:03:20,480
commodity computers

85
00:03:20,480 --> 00:03:22,640
but for all that don't get discouraged

86
00:03:22,640 --> 00:03:24,080
i'm going to try to convince you that

87
00:03:24,080 --> 00:03:25,760
there's hope if we make a slightly

88
00:03:25,760 --> 00:03:28,239
different kind of change

89
00:03:28,239 --> 00:03:30,879
and so enter cherry on the one hand it

90
00:03:30,879 --> 00:03:32,879
is indeed a pretty radical new computer

91
00:03:32,879 --> 00:03:34,799
approach we're going to change how

92
00:03:34,799 --> 00:03:36,400
pointers work

93
00:03:36,400 --> 00:03:38,640
if you remember a time before this is a

94
00:03:38,640 --> 00:03:40,720
foundational shift on the same scale as

95
00:03:40,720 --> 00:03:42,640
adding virtual memory to the computing

96
00:03:42,640 --> 00:03:44,720
architecture

97
00:03:44,720 --> 00:03:46,400
on the other hand i hope to convince you

98
00:03:46,400 --> 00:03:49,200
that it's not so radical after all

99
00:03:49,200 --> 00:03:50,959
i hope to show you that cherry composes

100
00:03:50,959 --> 00:03:53,120
well with modern micro architectures and

101
00:03:53,120 --> 00:03:55,439
that maybe c and c plus plus and foreign

102
00:03:55,439 --> 00:03:58,840
function interfaces to those can be made

103
00:03:58,840 --> 00:04:02,239
safer cherry has also taped out arm has

104
00:04:02,239 --> 00:04:04,640
an experimental morello prototype soc

105
00:04:04,640 --> 00:04:06,319
this is a quad core two and a half

106
00:04:06,319 --> 00:04:08,720
gigahertz rmv 8.2 a with cherry

107
00:04:08,720 --> 00:04:11,120
extensions so that's surprisingly real

108
00:04:11,120 --> 00:04:14,439
for an experiment

109
00:04:15,680 --> 00:04:17,918
so to understand the changes that cherry

110
00:04:17,918 --> 00:04:19,440
makes to a computing architecture it

111
00:04:19,440 --> 00:04:21,279
will be helpful to have a small example

112
00:04:21,279 --> 00:04:23,680
of some of the kinds of unsafety that it

113
00:04:23,680 --> 00:04:27,800
that we're designing it to inhibit

114
00:04:30,160 --> 00:04:31,840
come on

115
00:04:31,840 --> 00:04:33,360
i swear these things are not

116
00:04:33,360 --> 00:04:36,080
user-friendly okay so

117
00:04:36,080 --> 00:04:38,080
here's a little c program

118
00:04:38,080 --> 00:04:40,720
uh and all it does is a stack allocation

119
00:04:40,720 --> 00:04:43,520
calls a function and okay it has two

120
00:04:43,520 --> 00:04:46,639
rather glaring problems in it

121
00:04:46,639 --> 00:04:48,320
we can work out what the stack might

122
00:04:48,320 --> 00:04:51,199
look like when we make a function call

123
00:04:51,199 --> 00:04:52,560
and there's nothing really surprising

124
00:04:52,560 --> 00:04:57,800
here reading upwards from the bottom um

125
00:04:58,160 --> 00:05:00,560
we have that the lowest the lowest

126
00:05:00,560 --> 00:05:02,960
addresses are 16 bytes for the buff

127
00:05:02,960 --> 00:05:05,199
allocation above that are 16 bytes for

128
00:05:05,199 --> 00:05:07,520
the pad allocation and above that main

129
00:05:07,520 --> 00:05:10,240
has saved its return address

130
00:05:10,240 --> 00:05:12,479
so here's one possible compilation of

131
00:05:12,479 --> 00:05:14,320
our program into risk five which is a

132
00:05:14,320 --> 00:05:16,720
pretty boring standard risk architecture

133
00:05:16,720 --> 00:05:18,160
um you don't worry if you can't read

134
00:05:18,160 --> 00:05:19,919
risk five assembler i'll walk you

135
00:05:19,919 --> 00:05:22,080
through the highlights

136
00:05:22,080 --> 00:05:24,560
gazing into the assembler we see that

137
00:05:24,560 --> 00:05:26,160
the stores that we're performing are

138
00:05:26,160 --> 00:05:28,320
relative to an address in the register

139
00:05:28,320 --> 00:05:30,160
a0

140
00:05:30,160 --> 00:05:32,000
and if we look a little bit further down

141
00:05:32,000 --> 00:05:33,360
we can see that the compiler has

142
00:05:33,360 --> 00:05:35,919
inserted code before the function call

143
00:05:35,919 --> 00:05:40,000
to copy the stack pointer into a0

144
00:05:40,000 --> 00:05:41,280
and as we said

145
00:05:41,280 --> 00:05:43,199
the stack had buff at its lowest address

146
00:05:43,199 --> 00:05:46,479
so that's all as expected

147
00:05:46,479 --> 00:05:48,960
but what happens when this program runs

148
00:05:48,960 --> 00:05:51,600
well several things go wrong in rapid

149
00:05:51,600 --> 00:05:54,080
escalating succession

150
00:05:54,080 --> 00:05:56,479
the first thing that happens is that

151
00:05:56,479 --> 00:05:58,960
first store instruction writes

152
00:05:58,960 --> 00:06:00,880
outside of buff and clubbers something

153
00:06:00,880 --> 00:06:03,039
in pad

154
00:06:03,039 --> 00:06:04,400
that's bad but at least it's something

155
00:06:04,400 --> 00:06:06,479
we can kind of explain using the names

156
00:06:06,479 --> 00:06:09,840
of things visible in the language

157
00:06:09,840 --> 00:06:11,360
the next thing that happens though is

158
00:06:11,360 --> 00:06:13,440
really mysterious we write outside the

159
00:06:13,440 --> 00:06:15,039
language visible allocations into

160
00:06:15,039 --> 00:06:17,440
something that's just magic the compiler

161
00:06:17,440 --> 00:06:19,600
and abi have inserted this anonymous

162
00:06:19,600 --> 00:06:21,759
return address right so this is already

163
00:06:21,759 --> 00:06:23,919
really

164
00:06:23,919 --> 00:06:26,160
really far off into the weeds

165
00:06:26,160 --> 00:06:28,479
but then when main goes to actually

166
00:06:28,479 --> 00:06:29,840
return

167
00:06:29,840 --> 00:06:31,600
far after our bug

168
00:06:31,600 --> 00:06:33,840
it's going to load a corrupted pointer

169
00:06:33,840 --> 00:06:36,000
and jump who knows where it's just going

170
00:06:36,000 --> 00:06:39,840
to go and do whatever it's going to do

171
00:06:40,880 --> 00:06:41,680
so

172
00:06:41,680 --> 00:06:43,039
let's spend a moment being sort of

173
00:06:43,039 --> 00:06:45,600
philosophical about what just happened

174
00:06:45,600 --> 00:06:47,600
i'd contend that each thing stems from

175
00:06:47,600 --> 00:06:50,080
the cpu not really knowing enough about

176
00:06:50,080 --> 00:06:52,639
what's going on

177
00:06:52,639 --> 00:06:53,680
nothing

178
00:06:53,680 --> 00:06:56,240
foo had to hand that is in its registers

179
00:06:56,240 --> 00:06:58,800
or on its stack told it how big the

180
00:06:58,800 --> 00:07:01,280
buffer was or where or really even where

181
00:07:01,280 --> 00:07:02,960
it was it was just here's an address go

182
00:07:02,960 --> 00:07:05,280
for it

183
00:07:06,960 --> 00:07:08,240
when maine

184
00:07:08,240 --> 00:07:10,720
when foo wrote out of bounds the store

185
00:07:10,720 --> 00:07:12,960
silently corrupted a pointer

186
00:07:12,960 --> 00:07:14,560
right which is something something

187
00:07:14,560 --> 00:07:17,919
semantic it overwrote it with bytes

188
00:07:17,919 --> 00:07:19,840
and then when main jumped to its popped

189
00:07:19,840 --> 00:07:22,400
return address we didn't notice the cpu

190
00:07:22,400 --> 00:07:23,759
did not notice that there was anything

191
00:07:23,759 --> 00:07:26,080
amiss because bytes are just bytes and

192
00:07:26,080 --> 00:07:27,599
pointers are just addresses and

193
00:07:27,599 --> 00:07:30,000
addresses are just bytes

194
00:07:30,000 --> 00:07:30,960
so

195
00:07:30,960 --> 00:07:33,840
the common cause here in some sense is

196
00:07:33,840 --> 00:07:36,240
that we compiled c pointers these

197
00:07:36,240 --> 00:07:39,759
semantic objects down to fixed width

198
00:07:39,759 --> 00:07:43,240
integer addresses

199
00:07:44,639 --> 00:07:46,720
so with that example in mind what's

200
00:07:46,720 --> 00:07:48,479
cherry going to do differently and what

201
00:07:48,479 --> 00:07:50,160
are these capability things that i've

202
00:07:50,160 --> 00:07:52,960
alluded to

203
00:07:54,639 --> 00:07:56,639
so let's ponder what it would take to

204
00:07:56,639 --> 00:07:58,879
fix these problems and

205
00:07:58,879 --> 00:08:01,440
by fix i mean cause to fail stop

206
00:08:01,440 --> 00:08:03,759
deterministically and ideally close to

207
00:08:03,759 --> 00:08:05,199
the actual problem

208
00:08:05,199 --> 00:08:07,680
what would we need to pull that off

209
00:08:07,680 --> 00:08:10,160
we'd need some kind of new abstract data

210
00:08:10,160 --> 00:08:11,680
type that we could use instead of

211
00:08:11,680 --> 00:08:14,000
integers for pointers

212
00:08:14,000 --> 00:08:15,599
sometimes things like this go by the

213
00:08:15,599 --> 00:08:17,360
name of fat pointers but we're actually

214
00:08:17,360 --> 00:08:18,639
aiming for something a little better

215
00:08:18,639 --> 00:08:21,280
than that phrase usually means so we

216
00:08:21,280 --> 00:08:22,960
might call them just better pointers for

217
00:08:22,960 --> 00:08:24,960
the moment

218
00:08:24,960 --> 00:08:26,960
of course a better pointer still needs

219
00:08:26,960 --> 00:08:29,759
to carry an address around um so we have

220
00:08:29,759 --> 00:08:32,479
to have that in this thing

221
00:08:32,479 --> 00:08:35,039
but we also want to carry some bounds so

222
00:08:35,039 --> 00:08:37,120
this is two more addresses for the lower

223
00:08:37,120 --> 00:08:39,120
base and an upper limit

224
00:08:39,120 --> 00:08:40,320
to say that you you know we're

225
00:08:40,320 --> 00:08:42,080
describing an object that goes from here

226
00:08:42,080 --> 00:08:45,200
to here and currently pointing there

227
00:08:45,200 --> 00:08:47,360
and as we saw with the return address we

228
00:08:47,360 --> 00:08:49,839
need to distinguish somehow between

229
00:08:49,839 --> 00:08:52,160
valid better pointers and those that

230
00:08:52,160 --> 00:08:53,600
have been tampered with somehow

231
00:08:53,600 --> 00:08:55,440
including by clobbering some of their

232
00:08:55,440 --> 00:08:56,399
bites

233
00:08:56,399 --> 00:08:59,279
so this has to be special so we'll use a

234
00:08:59,279 --> 00:09:02,800
bit that will kind of set aside from

235
00:09:02,800 --> 00:09:05,120
the rest of our structure

236
00:09:05,120 --> 00:09:05,920
um

237
00:09:05,920 --> 00:09:07,360
and of course since we've opened the

238
00:09:07,360 --> 00:09:08,720
floodgates right everybody loves

239
00:09:08,720 --> 00:09:10,399
metadata there's probably going to be

240
00:09:10,399 --> 00:09:13,920
some other metadata in here too

241
00:09:16,080 --> 00:09:16,800
so

242
00:09:16,800 --> 00:09:18,320
abstract data types are all well and

243
00:09:18,320 --> 00:09:19,600
good but you know come on we're trying

244
00:09:19,600 --> 00:09:21,200
to build systems here so what does this

245
00:09:21,200 --> 00:09:23,519
actually look like

246
00:09:23,519 --> 00:09:25,680
so cherry defines an architectural

247
00:09:25,680 --> 00:09:27,760
representation for these better pointers

248
00:09:27,760 --> 00:09:29,920
with mysterious valid bits on the side

249
00:09:29,920 --> 00:09:32,320
which it calls capabilities

250
00:09:32,320 --> 00:09:34,640
the pointer bits are twice the size of

251
00:09:34,640 --> 00:09:36,399
the integer address so if you're on a

252
00:09:36,399 --> 00:09:38,240
64-bit machine that means that there's

253
00:09:38,240 --> 00:09:41,040
128 bits in memory uh for these better

254
00:09:41,040 --> 00:09:43,760
for these capabilities um actually it's

255
00:09:43,760 --> 00:09:45,839
129 because there is that one bit sort

256
00:09:45,839 --> 00:09:48,720
of floating off to the

257
00:09:48,839 --> 00:09:51,279
side these things are understood by the

258
00:09:51,279 --> 00:09:54,160
cpu hardware so we extend the registers

259
00:09:54,160 --> 00:09:56,640
to hold capabilities in some sense we

260
00:09:56,640 --> 00:09:58,800
have 129 bit registers although they

261
00:09:58,800 --> 00:10:03,200
mostly still act like 64-bit registers

262
00:10:03,200 --> 00:10:05,440
every load and store instruction that

263
00:10:05,440 --> 00:10:07,680
gets executed must be to an address

264
00:10:07,680 --> 00:10:09,360
that's in the bounds of a valid

265
00:10:09,360 --> 00:10:10,560
capability

266
00:10:10,560 --> 00:10:13,440
if ever that isn't true the cpu will

267
00:10:13,440 --> 00:10:15,680
trap raising a capability fault which is

268
00:10:15,680 --> 00:10:19,479
rather like a page fault

269
00:10:20,800 --> 00:10:22,880
and there are concretely some permission

270
00:10:22,880 --> 00:10:24,480
bits and some other metadata bits in the

271
00:10:24,480 --> 00:10:26,079
capability structure as well we'll get

272
00:10:26,079 --> 00:10:30,120
into that a little bit more later

273
00:10:32,160 --> 00:10:33,920
so let's talk about that valid bit

274
00:10:33,920 --> 00:10:35,120
that's been kind of floating off in

275
00:10:35,120 --> 00:10:37,839
space um for historical reasons it also

276
00:10:37,839 --> 00:10:39,760
gets called the cherry tag which is a

277
00:10:39,760 --> 00:10:42,160
horrifically overloaded word but is

278
00:10:42,160 --> 00:10:43,760
mercifully short i will probably

279
00:10:43,760 --> 00:10:46,399
continue to call it the tag

280
00:10:46,399 --> 00:10:47,440
so

281
00:10:47,440 --> 00:10:50,160
cherry systems associate one bit of tag

282
00:10:50,160 --> 00:10:53,440
for every 16 byte granule that is 128

283
00:10:53,440 --> 00:10:57,279
byte granule 128 bit 16 byte granule of

284
00:10:57,279 --> 00:11:00,000
physical memory

285
00:11:00,000 --> 00:11:02,640
as i just said we extend the registers

286
00:11:02,640 --> 00:11:05,120
to hold capabilities and their tags

287
00:11:05,120 --> 00:11:07,920
so here here's a small system right

288
00:11:07,920 --> 00:11:09,839
let's say that register six is holding a

289
00:11:09,839 --> 00:11:13,120
capability that's pointing to a location

290
00:11:13,120 --> 00:11:15,040
in memory that's holding a capability

291
00:11:15,040 --> 00:11:18,800
and register one is holding some data

292
00:11:18,880 --> 00:11:20,880
and in some kind of made up assembler

293
00:11:20,880 --> 00:11:22,800
here are some instructions that transfer

294
00:11:22,800 --> 00:11:25,600
capabilities and data between the cpu

295
00:11:25,600 --> 00:11:27,360
registers and memory

296
00:11:27,360 --> 00:11:30,160
so what happens when we run them

297
00:11:30,160 --> 00:11:33,839
so if we load a capability

298
00:11:34,240 --> 00:11:35,040
the

299
00:11:35,040 --> 00:11:37,279
tag that was in memory comes along with

300
00:11:37,279 --> 00:11:39,600
it and so now register 2 which was the

301
00:11:39,600 --> 00:11:41,200
target of our load

302
00:11:41,200 --> 00:11:43,519
has a set tag and is holding a valid

303
00:11:43,519 --> 00:11:45,839
capability

304
00:11:45,839 --> 00:11:48,240
if we store some data

305
00:11:48,240 --> 00:11:49,920
out to memory

306
00:11:49,920 --> 00:11:52,880
we always clear the tag that's out in

307
00:11:52,880 --> 00:11:54,560
memory

308
00:11:54,560 --> 00:11:55,680
so

309
00:11:55,680 --> 00:11:58,000
now that location in ram is holding a

310
00:11:58,000 --> 00:12:00,720
zero tag

311
00:12:01,839 --> 00:12:02,880
when we

312
00:12:02,880 --> 00:12:06,000
try to load a capability size thing from

313
00:12:06,000 --> 00:12:08,320
a location that has a clear tag again

314
00:12:08,320 --> 00:12:10,480
the tag just comes along for the ride

315
00:12:10,480 --> 00:12:12,959
and so we do transfer the 128 bits of

316
00:12:12,959 --> 00:12:15,200
the capability but the valid bit remains

317
00:12:15,200 --> 00:12:16,800
clear

318
00:12:16,800 --> 00:12:19,839
if we then try to use that thing because

319
00:12:19,839 --> 00:12:21,920
the tag is clear the processor will

320
00:12:21,920 --> 00:12:24,920
track

321
00:12:27,440 --> 00:12:29,120
so one way to think about this if you

322
00:12:29,120 --> 00:12:31,360
like is that cherry embodies a very

323
00:12:31,360 --> 00:12:34,240
simple one bit dynamic type system or

324
00:12:34,240 --> 00:12:37,920
tag system every word every 16 bytes is

325
00:12:37,920 --> 00:12:41,120
either a capability or an integer and if

326
00:12:41,120 --> 00:12:43,360
you ever try to use an integer where a

327
00:12:43,360 --> 00:12:45,279
capability is required the processor

328
00:12:45,279 --> 00:12:47,760
will trap

329
00:12:50,000 --> 00:12:50,720
so

330
00:12:50,720 --> 00:12:52,480
other than push capabilities around like

331
00:12:52,480 --> 00:12:54,079
we were just doing and load and store

332
00:12:54,079 --> 00:12:57,279
through them what can we do with them

333
00:12:57,279 --> 00:12:59,279
so one thing we'd better be able to do

334
00:12:59,279 --> 00:13:02,480
is change the address within bounds

335
00:13:02,480 --> 00:13:04,839
without really impacting the rest of the

336
00:13:04,839 --> 00:13:07,680
machinery so the processor has

337
00:13:07,680 --> 00:13:09,680
instructions a special case instruction

338
00:13:09,680 --> 00:13:10,639
for

339
00:13:10,639 --> 00:13:12,800
adding or offsetting

340
00:13:12,800 --> 00:13:15,519
and to an address and for anything else

341
00:13:15,519 --> 00:13:17,120
there are getters and setters so you can

342
00:13:17,120 --> 00:13:18,720
pull the address out do whatever you

343
00:13:18,720 --> 00:13:21,839
need and shove it back in

344
00:13:23,360 --> 00:13:24,880
if we're going to actually use these

345
00:13:24,880 --> 00:13:26,560
things to save us from ourselves we need

346
00:13:26,560 --> 00:13:28,880
to be able to to change the bounds on

347
00:13:28,880 --> 00:13:29,760
them

348
00:13:29,760 --> 00:13:31,360
and so there is indeed a set bounds

349
00:13:31,360 --> 00:13:33,120
instruction

350
00:13:33,120 --> 00:13:35,920
this generates a valid capability only

351
00:13:35,920 --> 00:13:39,360
if the requested bounds are smaller than

352
00:13:39,360 --> 00:13:41,839
the the existing bounds so you can raise

353
00:13:41,839 --> 00:13:43,839
the base and lower the limit but you

354
00:13:43,839 --> 00:13:47,639
can't do it the other way around

355
00:13:48,160 --> 00:13:49,680
and the last thing we can really depend

356
00:13:49,680 --> 00:13:51,680
on is that the architecture will do

357
00:13:51,680 --> 00:13:53,680
provenance tracking for us

358
00:13:53,680 --> 00:13:57,360
so if we manipulate or do something bad

359
00:13:57,360 --> 00:14:00,160
to the bytes of a capability other than

360
00:14:00,160 --> 00:14:02,160
through these these capability

361
00:14:02,160 --> 00:14:03,839
manipulating instructions the

362
00:14:03,839 --> 00:14:06,560
architecture will clear its valid bits

363
00:14:06,560 --> 00:14:08,720
or clear its valid bit and then prevent

364
00:14:08,720 --> 00:14:12,399
us from using it as a capability

365
00:14:13,680 --> 00:14:15,680
so with those operations in mind and by

366
00:14:15,680 --> 00:14:17,199
way of reminder here's what things

367
00:14:17,199 --> 00:14:19,360
looked like before on a non-cherry

368
00:14:19,360 --> 00:14:22,240
compilation target

369
00:14:24,000 --> 00:14:26,240
and now if we compile to cherry risk

370
00:14:26,240 --> 00:14:29,519
five the program looks quite similar

371
00:14:29,519 --> 00:14:31,279
the first thing to note is that our

372
00:14:31,279 --> 00:14:33,120
store byte instructions

373
00:14:33,120 --> 00:14:35,199
have become capability authorized store

374
00:14:35,199 --> 00:14:37,440
by instructions and they cite the

375
00:14:37,440 --> 00:14:40,800
capability in register ca0 which is just

376
00:14:40,800 --> 00:14:45,040
a0 extended to hold the capability

377
00:14:45,040 --> 00:14:46,880
and the second thing to note is that the

378
00:14:46,880 --> 00:14:50,000
call site where maine calls foo has not

379
00:14:50,000 --> 00:14:52,639
simply copied the stack pointer across

380
00:14:52,639 --> 00:14:54,880
but now builds a capability with

381
00:14:54,880 --> 00:14:57,920
narrower bounds to pass as the argument

382
00:14:57,920 --> 00:15:00,560
the 16 in the assembler is an immediate

383
00:15:00,560 --> 00:15:02,160
form because we statically know that

384
00:15:02,160 --> 00:15:04,320
buff is 16 bytes long

385
00:15:04,320 --> 00:15:05,839
there's also a form that takes its

386
00:15:05,839 --> 00:15:08,639
length from a register for doing dynamic

387
00:15:08,639 --> 00:15:10,639
bounding

388
00:15:10,639 --> 00:15:13,360
so what happens when we run this program

389
00:15:13,360 --> 00:15:15,360
well it crashes on the the first

390
00:15:15,360 --> 00:15:17,839
meaningful instruction in foo

391
00:15:17,839 --> 00:15:21,120
right because 16 up from ca0 is outside

392
00:15:21,120 --> 00:15:24,839
of the capability bounds

393
00:15:26,160 --> 00:15:27,680
we can use capabilities for more than

394
00:15:27,680 --> 00:15:30,000
just stack allocations too so the malec

395
00:15:30,000 --> 00:15:31,600
that we run on top of cherry for example

396
00:15:31,600 --> 00:15:34,079
can return bounded capabilities to heap

397
00:15:34,079 --> 00:15:35,279
objects

398
00:15:35,279 --> 00:15:37,519
internally malik has the authority to

399
00:15:37,519 --> 00:15:38,839
access the entire

400
00:15:38,839 --> 00:15:41,920
heap but when responding to a client

401
00:15:41,920 --> 00:15:44,800
request and deriving a capability it can

402
00:15:44,800 --> 00:15:46,959
set the capability bounds and then

403
00:15:46,959 --> 00:15:48,720
nothing that the client of the allocator

404
00:15:48,720 --> 00:15:49,519
does

405
00:15:49,519 --> 00:15:51,680
will let it use that capability to

406
00:15:51,680 --> 00:15:55,839
access beyond those initial bounds

407
00:15:55,839 --> 00:15:57,600
the client is of course free to derive

408
00:15:57,600 --> 00:16:00,320
its own subsets of that but those are

409
00:16:00,320 --> 00:16:02,800
again subsets of the the

410
00:16:02,800 --> 00:16:07,000
bounds enforced by malek

411
00:16:08,720 --> 00:16:11,360
so that's the core of cherry we add

412
00:16:11,360 --> 00:16:12,639
architectural capabilities to the

413
00:16:12,639 --> 00:16:14,000
machine

414
00:16:14,000 --> 00:16:16,160
and we ensure that they come about only

415
00:16:16,160 --> 00:16:18,160
through legitimate operations

416
00:16:18,160 --> 00:16:21,040
clearing the valid bit if not

417
00:16:21,040 --> 00:16:24,079
we check that every dereference is

418
00:16:24,079 --> 00:16:27,040
permitted by a capability

419
00:16:27,040 --> 00:16:28,800
and that we rewrite the compilers and

420
00:16:28,800 --> 00:16:31,199
runtimes and so on to use capabilities

421
00:16:31,199 --> 00:16:34,359
for pointers

422
00:16:36,320 --> 00:16:38,160
just i want to pause for a moment and

423
00:16:38,160 --> 00:16:40,399
note that cherry is unlike much of its

424
00:16:40,399 --> 00:16:42,000
competition secret free and

425
00:16:42,000 --> 00:16:44,399
deterministic

426
00:16:44,399 --> 00:16:46,880
so an adversary cannot forge a

427
00:16:46,880 --> 00:16:49,279
capability even if they know every bit

428
00:16:49,279 --> 00:16:50,959
of the system state right if i tell them

429
00:16:50,959 --> 00:16:52,720
every bit that's in ram including the

430
00:16:52,720 --> 00:16:55,600
valid bits they can't construct a

431
00:16:55,600 --> 00:16:58,560
capability this is unlike aslr or stack

432
00:16:58,560 --> 00:17:00,000
canaries or other mitigations that

433
00:17:00,000 --> 00:17:02,480
you're probably familiar with

434
00:17:02,480 --> 00:17:03,360
so

435
00:17:03,360 --> 00:17:05,679
we because we can't re-inject the data

436
00:17:05,679 --> 00:17:07,919
as pointers most of the things that are

437
00:17:07,919 --> 00:17:09,119
kind of

438
00:17:09,119 --> 00:17:11,280
stem from smashing the stack for fun and

439
00:17:11,280 --> 00:17:14,720
profit no longer work

440
00:17:15,039 --> 00:17:17,119
if you attempt an out of bounds or

441
00:17:17,119 --> 00:17:19,520
invalid dereference it will always trap

442
00:17:19,520 --> 00:17:21,520
there's nothing you can do to take an

443
00:17:21,520 --> 00:17:23,199
invalid capability and turn it back into

444
00:17:23,199 --> 00:17:24,959
a valid one

445
00:17:24,959 --> 00:17:26,720
and bite level corruption or attempts to

446
00:17:26,720 --> 00:17:28,400
widen the bounds or so on are always

447
00:17:28,400 --> 00:17:31,400
cough

448
00:17:32,000 --> 00:17:32,880
okay

449
00:17:32,880 --> 00:17:34,240
so now that we understand the

450
00:17:34,240 --> 00:17:36,559
architectural nature of cherry let's see

451
00:17:36,559 --> 00:17:40,000
how to build software on top of it

452
00:17:41,120 --> 00:17:42,720
we can take this idea

453
00:17:42,720 --> 00:17:44,320
of using capabilities for pointers to

454
00:17:44,320 --> 00:17:46,320
its logical conclusion we're going to

455
00:17:46,320 --> 00:17:48,160
use capabilities for every pointer in

456
00:17:48,160 --> 00:17:50,160
the inner process

457
00:17:50,160 --> 00:17:51,840
so that means both the pointers that you

458
00:17:51,840 --> 00:17:54,320
see and think of in the language

459
00:17:54,320 --> 00:17:56,799
as well as the ones below the language

460
00:17:56,799 --> 00:17:58,720
or the implicit ones

461
00:17:58,720 --> 00:18:00,640
and so this means the compiler loader

462
00:18:00,640 --> 00:18:02,240
and even the kernel have to be active

463
00:18:02,240 --> 00:18:06,080
participants in this implementation

464
00:18:06,960 --> 00:18:08,960
and we do also have to slightly change

465
00:18:08,960 --> 00:18:10,720
the c semantics if you're curious for

466
00:18:10,720 --> 00:18:12,000
more details please do see our

467
00:18:12,000 --> 00:18:15,039
programming guide but by and large most

468
00:18:15,039 --> 00:18:18,160
c just works

469
00:18:19,520 --> 00:18:21,360
if we do use capabilities to represent

470
00:18:21,360 --> 00:18:23,360
every pointer in a process what we get

471
00:18:23,360 --> 00:18:25,440
is a capability graph between different

472
00:18:25,440 --> 00:18:27,520
objects with the thread registers sort

473
00:18:27,520 --> 00:18:29,120
of forming the roots

474
00:18:29,120 --> 00:18:32,400
we call this environment cherry abi

475
00:18:32,400 --> 00:18:33,919
because it is an application binary

476
00:18:33,919 --> 00:18:37,760
interface that uses capabilities

477
00:18:38,400 --> 00:18:41,440
but wait hold on user processes do more

478
00:18:41,440 --> 00:18:43,760
than just follow user space pointers

479
00:18:43,760 --> 00:18:45,679
sometimes they interact with the outside

480
00:18:45,679 --> 00:18:47,600
world by taking advantage of this

481
00:18:47,600 --> 00:18:49,520
complicated thing called the kernel and

482
00:18:49,520 --> 00:18:52,640
they make system calls

483
00:18:52,640 --> 00:18:54,799
so there's a risk that the kernel could

484
00:18:54,799 --> 00:18:57,440
be tricked into violating our carefully

485
00:18:57,440 --> 00:18:59,840
orchestrated capability system uh making

486
00:18:59,840 --> 00:19:02,080
it what's called a confused deputy

487
00:19:02,080 --> 00:19:04,400
after all the kernel has legitimate

488
00:19:04,400 --> 00:19:06,640
intended access to the entirety of the

489
00:19:06,640 --> 00:19:08,559
the user space address

490
00:19:08,559 --> 00:19:11,600
address space so here's a short example

491
00:19:11,600 --> 00:19:12,720
where

492
00:19:12,720 --> 00:19:14,799
user space has allocated a one kilobyte

493
00:19:14,799 --> 00:19:17,280
buffer and is asking the kernel to write

494
00:19:17,280 --> 00:19:19,360
into that buffer some larger number of

495
00:19:19,360 --> 00:19:22,240
bytes uh perhaps because an attacker has

496
00:19:22,240 --> 00:19:25,440
control over the length of the request

497
00:19:25,440 --> 00:19:27,120
this is completely implausible i know

498
00:19:27,120 --> 00:19:30,000
hearts never bleed

499
00:19:30,160 --> 00:19:32,799
in order to limit its own behavior a

500
00:19:32,799 --> 00:19:35,200
cherry api aware kernel changes the

501
00:19:35,200 --> 00:19:36,960
system call interface so that pointers

502
00:19:36,960 --> 00:19:40,160
are now passed as capabilities

503
00:19:40,160 --> 00:19:42,400
this way that over long read request

504
00:19:42,400 --> 00:19:45,039
will fail gracefully when the kernel

505
00:19:45,039 --> 00:19:47,280
goes to copy data out

506
00:19:47,280 --> 00:19:49,280
and in fact in the implementation we can

507
00:19:49,280 --> 00:19:52,320
take advantage of this fact we can we

508
00:19:52,320 --> 00:19:54,240
can take advantage of the existing fail

509
00:19:54,240 --> 00:19:56,080
safe

510
00:19:56,080 --> 00:19:58,720
copy out which aborts on trap

511
00:19:58,720 --> 00:20:00,960
and all we have to do is pass the

512
00:20:00,960 --> 00:20:03,919
capability that the user gave us to copy

513
00:20:03,919 --> 00:20:04,720
out

514
00:20:04,720 --> 00:20:06,159
so we don't have to insert bounds

515
00:20:06,159 --> 00:20:07,520
instructions or bounce checking

516
00:20:07,520 --> 00:20:08,960
instructions there's actually very

517
00:20:08,960 --> 00:20:11,679
little code to change

518
00:20:11,679 --> 00:20:13,919
and the information flow the capability

519
00:20:13,919 --> 00:20:15,919
flow through the system will enforce the

520
00:20:15,919 --> 00:20:18,720
bounds for us

521
00:20:19,600 --> 00:20:21,840
so that's in a nutshell how cherry is

522
00:20:21,840 --> 00:20:23,919
different than current architectures but

523
00:20:23,919 --> 00:20:25,919
i also promised it wasn't as disruptive

524
00:20:25,919 --> 00:20:28,960
as it might first have sounded

525
00:20:28,960 --> 00:20:30,799
so perhaps the greatest indication so

526
00:20:30,799 --> 00:20:33,120
far that cherry is practical is that arm

527
00:20:33,120 --> 00:20:34,720
and its partners including us at

528
00:20:34,720 --> 00:20:37,200
microsoft are doing an industrial scale

529
00:20:37,200 --> 00:20:39,520
science experiment named morello which

530
00:20:39,520 --> 00:20:41,360
is a kind of cherry i had to look it up

531
00:20:41,360 --> 00:20:42,799
to

532
00:20:42,799 --> 00:20:45,840
this is an armv 8.2 chip with cherry

533
00:20:45,840 --> 00:20:47,360
features added

534
00:20:47,360 --> 00:20:48,960
it's clocked at two and a half gigahertz

535
00:20:48,960 --> 00:20:51,120
it has 16 gigs of ram by default it's

536
00:20:51,120 --> 00:20:53,440
really quite nice um

537
00:20:53,440 --> 00:20:55,280
arm really wants me to tell you that it

538
00:20:55,280 --> 00:20:57,600
is emphatically not

539
00:20:57,600 --> 00:20:59,679
but will hopefully influence successors

540
00:20:59,679 --> 00:21:02,640
to army 8.9 morello is a dead end

541
00:21:02,640 --> 00:21:04,640
experimental architecture but it's still

542
00:21:04,640 --> 00:21:06,880
really cool

543
00:21:06,880 --> 00:21:08,720
so all of that to say

544
00:21:08,720 --> 00:21:10,080
for present and future systems

545
00:21:10,080 --> 00:21:12,240
programmers it's looking increasingly

546
00:21:12,240 --> 00:21:14,080
likely that cherry will be part of the

547
00:21:14,080 --> 00:21:17,799
world that we live in

548
00:21:18,480 --> 00:21:20,400
one of the central design objectives and

549
00:21:20,400 --> 00:21:23,200
why cherry has why has been able to why

550
00:21:23,200 --> 00:21:25,039
we have been able to make cherry into a

551
00:21:25,039 --> 00:21:26,320
real chip

552
00:21:26,320 --> 00:21:27,919
was that it couldn't meet a whole new

553
00:21:27,919 --> 00:21:29,440
everything

554
00:21:29,440 --> 00:21:31,280
importantly it needed to be compatible

555
00:21:31,280 --> 00:21:33,360
with commodity memory and buses and so

556
00:21:33,360 --> 00:21:35,039
on right we called up the dram

557
00:21:35,039 --> 00:21:36,400
manufacturers and said hey could you

558
00:21:36,400 --> 00:21:39,600
make 129 bit dram for us and they looked

559
00:21:39,600 --> 00:21:41,840
at us like we were from mars

560
00:21:41,840 --> 00:21:43,679
so how do we do this how do we work with

561
00:21:43,679 --> 00:21:46,320
ordinary dram but have these weird 129

562
00:21:46,320 --> 00:21:49,760
bit data structures floating around

563
00:21:50,400 --> 00:21:51,120
so

564
00:21:51,120 --> 00:21:53,440
as i said before we augment the cpu core

565
00:21:53,440 --> 00:21:55,280
to hold capabilities in registers so

566
00:21:55,280 --> 00:21:56,960
that's roughly doubling the size of the

567
00:21:56,960 --> 00:21:59,840
register file

568
00:21:59,840 --> 00:22:02,720
and in the cache hierarchy we carry the

569
00:22:02,720 --> 00:22:05,760
tags around with data

570
00:22:05,760 --> 00:22:08,080
but our last level cache will split

571
00:22:08,080 --> 00:22:09,679
cache lines

572
00:22:09,679 --> 00:22:12,000
and the data bits of them will go out to

573
00:22:12,000 --> 00:22:14,240
dram as if they were ordinary data

574
00:22:14,240 --> 00:22:15,520
because they are

575
00:22:15,520 --> 00:22:17,679
and the tag bits will go separately to

576
00:22:17,679 --> 00:22:19,440
this new dedicated thing that we call a

577
00:22:19,440 --> 00:22:21,039
tag controller

578
00:22:21,039 --> 00:22:23,280
and the tag controller is in turn is

579
00:22:23,280 --> 00:22:27,600
backed by a reserved tag table in memory

580
00:22:27,600 --> 00:22:29,760
this tag table is not architecturally

581
00:22:29,760 --> 00:22:33,600
accessible as data to the cpu now you

582
00:22:33,600 --> 00:22:35,280
can imagine there's some hardware filter

583
00:22:35,280 --> 00:22:36,799
in the way that says the cpu doesn't get

584
00:22:36,799 --> 00:22:40,360
to see those bits

585
00:22:41,760 --> 00:22:44,640
so at a glance cherry has two primary

586
00:22:44,640 --> 00:22:47,360
architectural uh incarnations there is

587
00:22:47,360 --> 00:22:49,760
either morello soc and there's also uh

588
00:22:49,760 --> 00:22:52,240
risk five which is mostly in uh kwemu

589
00:22:52,240 --> 00:22:54,320
and in fpga

590
00:22:54,320 --> 00:22:55,840
both of those have

591
00:22:55,840 --> 00:22:59,760
executable and human readable isa specs

592
00:22:59,760 --> 00:23:00,559
as

593
00:23:00,559 --> 00:23:02,240
and of course there is an emulator for

594
00:23:02,240 --> 00:23:05,120
the morello as well

595
00:23:05,760 --> 00:23:08,480
atop these we do most of our work in a

596
00:23:08,480 --> 00:23:11,760
modified freebsd that we call cherrybsd

597
00:23:11,760 --> 00:23:13,600
the kernel and c runtime components have

598
00:23:13,600 --> 00:23:15,760
been made cherry aware there's also

599
00:23:15,760 --> 00:23:18,640
early work on linux free rtos and some

600
00:23:18,640 --> 00:23:22,960
other some other things of this ilk

601
00:23:22,960 --> 00:23:25,120
the whole software stack is built mostly

602
00:23:25,120 --> 00:23:27,200
in cross compilation using a capability

603
00:23:27,200 --> 00:23:29,919
aware branch of llvm so modern clang and

604
00:23:29,919 --> 00:23:31,600
lld

605
00:23:31,600 --> 00:23:33,600
and we have educated gdb

606
00:23:33,600 --> 00:23:35,679
for both cross architecture and native

607
00:23:35,679 --> 00:23:38,240
debugging

608
00:23:38,320 --> 00:23:40,480
continuing up the stack we have all of

609
00:23:40,480 --> 00:23:43,360
cherry bsd user space posgress apache

610
00:23:43,360 --> 00:23:48,399
nginx webkit qt and kde ported

611
00:23:48,799 --> 00:23:50,159
and it we can actually do some really

612
00:23:50,159 --> 00:23:52,080
interesting analysis um there's a whole

613
00:23:52,080 --> 00:23:53,840
lectures worth of material about porting

614
00:23:53,840 --> 00:23:56,240
c and c plus plus programs to cherry uh

615
00:23:56,240 --> 00:23:58,240
but generally the higher up in the stack

616
00:23:58,240 --> 00:24:00,720
you go the less work that it is

617
00:24:00,720 --> 00:24:01,919
um

618
00:24:01,919 --> 00:24:03,919
so when we were manipulating things in

619
00:24:03,919 --> 00:24:05,840
the kernel we had to change you know

620
00:24:05,840 --> 00:24:08,400
point to and in libsy it was like less

621
00:24:08,400 --> 00:24:10,559
than point five percent of lines

622
00:24:10,559 --> 00:24:12,240
jits are really complicated because they

623
00:24:12,240 --> 00:24:14,240
are intimately aware of the architecture

624
00:24:14,240 --> 00:24:16,799
but as you move up into applications

625
00:24:16,799 --> 00:24:18,559
it's very very little code that has to

626
00:24:18,559 --> 00:24:21,440
be changed in fact many kde applications

627
00:24:21,440 --> 00:24:23,440
required no modifications for cherry at

628
00:24:23,440 --> 00:24:26,640
all once the qt and the kde libraries

629
00:24:26,640 --> 00:24:29,279
have been ported

630
00:24:29,279 --> 00:24:31,039
and so everybody likes screenshots right

631
00:24:31,039 --> 00:24:32,799
so this is kde and some of its

632
00:24:32,799 --> 00:24:34,320
applications running completely

633
00:24:34,320 --> 00:24:37,600
charified on risk 5 in premiere over vmc

634
00:24:37,600 --> 00:24:39,840
this all works on morelo 2 morello has a

635
00:24:39,840 --> 00:24:43,039
gpu and real and open gpu drivers

636
00:24:43,039 --> 00:24:44,880
so it will real soon now be a viable

637
00:24:44,880 --> 00:24:46,640
workstation we're just going through the

638
00:24:46,640 --> 00:24:49,919
throes of platform bring up

639
00:24:51,120 --> 00:24:53,200
and everyone's next question i'm sure is

640
00:24:53,200 --> 00:24:55,760
okay how much does it cost

641
00:24:55,760 --> 00:24:57,679
for complicated reasons i don't have

642
00:24:57,679 --> 00:24:59,360
numbers to give you about morelo as i

643
00:24:59,360 --> 00:25:02,559
said we're still doing some bring up um

644
00:25:02,559 --> 00:25:04,720
but looking back a couple of years as of

645
00:25:04,720 --> 00:25:06,080
2019

646
00:25:06,080 --> 00:25:09,760
on a slightly different cpu in fpga

647
00:25:09,760 --> 00:25:12,480
we saw between zero and ten percent uh

648
00:25:12,480 --> 00:25:14,400
cycle time overhead which is for this

649
00:25:14,400 --> 00:25:16,559
cpu was equivalent to wall clock

650
00:25:16,559 --> 00:25:18,720
with many programs actually having

651
00:25:18,720 --> 00:25:21,440
essentially no performance difference

652
00:25:21,440 --> 00:25:22,559
um

653
00:25:22,559 --> 00:25:24,559
the biggest cost that we see is indeed

654
00:25:24,559 --> 00:25:25,919
because we have doubled the size of

655
00:25:25,919 --> 00:25:28,159
pointers l2 cache misses increase for

656
00:25:28,159 --> 00:25:30,159
pointer-heavy workloads

657
00:25:30,159 --> 00:25:32,000
um real soon now we should get a much

658
00:25:32,000 --> 00:25:33,520
better understanding of how this works

659
00:25:33,520 --> 00:25:35,200
on a modern micro architecture thanks to

660
00:25:35,200 --> 00:25:37,600
morello

661
00:25:39,760 --> 00:25:42,320
okay so the fact that all of that works

662
00:25:42,320 --> 00:25:44,880
is i think pretty exciting but it turns

663
00:25:44,880 --> 00:25:47,360
out there's a lot more that we can gain

664
00:25:47,360 --> 00:25:48,720
from cherry

665
00:25:48,720 --> 00:25:50,960
um i see sorry there's a question

666
00:25:50,960 --> 00:25:53,279
um

667
00:25:55,200 --> 00:25:56,880
i will take that uh the question is

668
00:25:56,880 --> 00:25:59,200
about uh running capability style os is

669
00:25:59,200 --> 00:26:00,880
on top of jerry um let's hold that to

670
00:26:00,880 --> 00:26:03,440
the end it's a bit of a discussion

671
00:26:03,440 --> 00:26:05,440
um

672
00:26:05,440 --> 00:26:06,480
right so

673
00:26:06,480 --> 00:26:08,400
i it turns out that there's much more

674
00:26:08,400 --> 00:26:10,480
that we can do with cherry than just

675
00:26:10,480 --> 00:26:13,039
mitigate existing problems

676
00:26:13,039 --> 00:26:14,960
we can actually use it to build

677
00:26:14,960 --> 00:26:16,559
compartmentalized software so that we

678
00:26:16,559 --> 00:26:18,799
can confine the impacts of arbitrarily

679
00:26:18,799 --> 00:26:23,200
bad behavior to just one compartment

680
00:26:23,679 --> 00:26:25,520
and the key insight here is that without

681
00:26:25,520 --> 00:26:27,200
a transitive capability to a given

682
00:26:27,200 --> 00:26:29,440
resource there's no way to access it

683
00:26:29,440 --> 00:26:32,640
even if you know the address

684
00:26:32,720 --> 00:26:34,559
and so the one really attractive thing

685
00:26:34,559 --> 00:26:36,640
to do is to sandbox things like codecs

686
00:26:36,640 --> 00:26:39,039
that face untrusted data

687
00:26:39,039 --> 00:26:41,200
if the only thing that you have as a

688
00:26:41,200 --> 00:26:44,159
codec is access to your own code

689
00:26:44,159 --> 00:26:45,919
your access to your input buffer your

690
00:26:45,919 --> 00:26:48,480
output buffer maybe some scratch space

691
00:26:48,480 --> 00:26:51,200
and the ability to stop running

692
00:26:51,200 --> 00:26:53,039
then there's not a whole lot that you

693
00:26:53,039 --> 00:26:56,400
can do even as a fully compromised codec

694
00:26:56,400 --> 00:26:58,000
right attacker-controlled input gives

695
00:26:58,000 --> 00:26:59,840
rise to attacker controlled output but

696
00:26:59,840 --> 00:27:03,039
that's it sort of ho-hum

697
00:27:03,440 --> 00:27:05,120
okay but there is this little caveat

698
00:27:05,120 --> 00:27:06,799
right of like how do you like what is

699
00:27:06,799 --> 00:27:08,400
that execute only thing how do you get

700
00:27:08,400 --> 00:27:09,840
back out of one of these it's easy to

701
00:27:09,840 --> 00:27:11,200
get in you just delete things from the

702
00:27:11,200 --> 00:27:12,799
register file but how do you get back

703
00:27:12,799 --> 00:27:14,960
out

704
00:27:17,279 --> 00:27:18,240
so

705
00:27:18,240 --> 00:27:20,559
one answer which we have done uh is to

706
00:27:20,559 --> 00:27:22,240
enrich sherry with additional kinds of

707
00:27:22,240 --> 00:27:24,320
capabilities i'm going to talk about two

708
00:27:24,320 --> 00:27:26,799
of them sealed and sealing and unsealing

709
00:27:26,799 --> 00:27:28,320
capabilities

710
00:27:28,320 --> 00:27:29,600
um

711
00:27:29,600 --> 00:27:31,360
this is exploiting some of that other

712
00:27:31,360 --> 00:27:33,120
metadata in the capability form that i

713
00:27:33,120 --> 00:27:35,120
talked about

714
00:27:35,120 --> 00:27:37,600
so a cherry capability can be combined

715
00:27:37,600 --> 00:27:39,760
with a ceiling capability to produce a

716
00:27:39,760 --> 00:27:41,760
sealed capability

717
00:27:41,760 --> 00:27:44,000
sealed capabilities are immutable if you

718
00:27:44,000 --> 00:27:45,600
try to change anything about them you'll

719
00:27:45,600 --> 00:27:46,960
clear the tag

720
00:27:46,960 --> 00:27:48,960
and they are inert in that they don't

721
00:27:48,960 --> 00:27:50,880
authorize other operations including

722
00:27:50,880 --> 00:27:52,880
loads or stores so you can hold on to

723
00:27:52,880 --> 00:27:56,559
these things but you can't use them

724
00:27:56,880 --> 00:27:57,919
until

725
00:27:57,919 --> 00:27:59,760
they get recombined with an unsealing

726
00:27:59,760 --> 00:28:01,279
capability which gives you back the

727
00:28:01,279 --> 00:28:03,600
original pre-sealed thing which now you

728
00:28:03,600 --> 00:28:06,080
can use

729
00:28:07,360 --> 00:28:09,760
there are multiple kinds of seals and

730
00:28:09,760 --> 00:28:11,760
the ceiling and unsealing capabilities

731
00:28:11,760 --> 00:28:13,360
have to match if you try to use the

732
00:28:13,360 --> 00:28:17,840
wrong one you get an untagged or a trap

733
00:28:18,960 --> 00:28:20,880
building on this functionality we can

734
00:28:20,880 --> 00:28:22,559
also do something really interesting if

735
00:28:22,559 --> 00:28:25,120
we have two capabilities under the same

736
00:28:25,120 --> 00:28:26,640
seal

737
00:28:26,640 --> 00:28:28,720
we can invoke them as

738
00:28:28,720 --> 00:28:30,960
a sealed pair we hand both of them to an

739
00:28:30,960 --> 00:28:32,080
instruction

740
00:28:32,080 --> 00:28:34,240
and that instruction checks that they

741
00:28:34,240 --> 00:28:36,960
have the same type unseals both of them

742
00:28:36,960 --> 00:28:38,480
and installs one of them into the

743
00:28:38,480 --> 00:28:40,559
register file and the other one as the

744
00:28:40,559 --> 00:28:42,399
program counter so this is a kind of

745
00:28:42,399 --> 00:28:43,600
jump

746
00:28:43,600 --> 00:28:45,679
you can think of this as an

747
00:28:45,679 --> 00:28:47,919
object-oriented method indication where

748
00:28:47,919 --> 00:28:49,600
the executable capability the one that

749
00:28:49,600 --> 00:28:51,200
gets installed is the program counter

750
00:28:51,200 --> 00:28:53,520
names the method and the other one names

751
00:28:53,520 --> 00:28:55,919
an object it's do this to that but you

752
00:28:55,919 --> 00:28:58,320
have no access to either of those things

753
00:28:58,320 --> 00:29:01,200
beyond the ability to call them

754
00:29:01,200 --> 00:29:02,720
and this is one way we can get out of

755
00:29:02,720 --> 00:29:04,720
these sandboxes in a very continuation

756
00:29:04,720 --> 00:29:06,159
passing style

757
00:29:06,159 --> 00:29:08,559
if the data pointer

758
00:29:08,559 --> 00:29:10,320
or sealed capability is the outer

759
00:29:10,320 --> 00:29:12,320
context continuations data and the

760
00:29:12,320 --> 00:29:14,399
method is the continuations code

761
00:29:14,399 --> 00:29:16,320
so this is a way for us to not have

762
00:29:16,320 --> 00:29:18,080
access to the outer context but be able

763
00:29:18,080 --> 00:29:20,960
to return to it

764
00:29:23,120 --> 00:29:25,120
another thing we can revisit with cherry

765
00:29:25,120 --> 00:29:26,960
is the need for process isolation in the

766
00:29:26,960 --> 00:29:28,480
first place

767
00:29:28,480 --> 00:29:30,080
traditionally processes live in

768
00:29:30,080 --> 00:29:31,919
different address spaces and we use the

769
00:29:31,919 --> 00:29:34,240
mmu to isolate them

770
00:29:34,240 --> 00:29:36,240
and if we want to do ipc we have to

771
00:29:36,240 --> 00:29:38,559
context switch between them

772
00:29:38,559 --> 00:29:40,399
probably by having the kernel do some

773
00:29:40,399 --> 00:29:42,000
data copies

774
00:29:42,000 --> 00:29:44,559
right i write and you read from a pipe

775
00:29:44,559 --> 00:29:48,320
this incurs tlb switching costs which is

776
00:29:48,320 --> 00:29:50,720
are paid in time power and or silicon

777
00:29:50,720 --> 00:29:53,039
area

778
00:29:53,679 --> 00:29:55,840
we can also establish shared pages with

779
00:29:55,840 --> 00:29:58,080
the mmu but notice there's something

780
00:29:58,080 --> 00:30:00,640
funny here right pointers to the shared

781
00:30:00,640 --> 00:30:02,799
region are fine

782
00:30:02,799 --> 00:30:04,480
if we're very careful we can have

783
00:30:04,480 --> 00:30:07,600
pointers within the shared region

784
00:30:07,600 --> 00:30:09,200
but there is now a risk that we might

785
00:30:09,200 --> 00:30:11,039
have pointers that leave the shared

786
00:30:11,039 --> 00:30:12,640
region

787
00:30:12,640 --> 00:30:14,159
right which is

788
00:30:14,159 --> 00:30:15,520
i get to store something that means

789
00:30:15,520 --> 00:30:17,200
something to me but it means nothing to

790
00:30:17,200 --> 00:30:19,039
you or worse means something vulnerable

791
00:30:19,039 --> 00:30:22,200
to you

792
00:30:25,679 --> 00:30:27,520
so cherry lets us tear down the

793
00:30:27,520 --> 00:30:29,840
mmu-based walls between processes so

794
00:30:29,840 --> 00:30:31,520
that we can run many processes in a

795
00:30:31,520 --> 00:30:33,200
single address space

796
00:30:33,200 --> 00:30:34,960
isolation is maintained thanks to the

797
00:30:34,960 --> 00:30:36,960
capability system again you can't access

798
00:30:36,960 --> 00:30:39,520
what you can't point at

799
00:30:39,520 --> 00:30:42,000
and in this model we can do ipc via

800
00:30:42,000 --> 00:30:44,240
those sealed capabilities

801
00:30:44,240 --> 00:30:46,720
and if we want to have copy semantics we

802
00:30:46,720 --> 00:30:49,840
can have an a trusted switcher in user

803
00:30:49,840 --> 00:30:50,720
space

804
00:30:50,720 --> 00:30:52,640
that we trust to do the copy before

805
00:30:52,640 --> 00:30:54,399
completing the call

806
00:30:54,399 --> 00:30:56,000
so this is really exciting this is

807
00:30:56,000 --> 00:30:59,120
kernel bypass ipc with user threads

808
00:30:59,120 --> 00:31:00,880
directly crossing the traditional

809
00:31:00,880 --> 00:31:03,600
process boundary

810
00:31:03,600 --> 00:31:05,919
and moreover we get really fast sharing

811
00:31:05,919 --> 00:31:07,440
in this model if we just pass a

812
00:31:07,440 --> 00:31:10,320
capability across that ipc layer

813
00:31:10,320 --> 00:31:12,159
and note that there's no risk of unders

814
00:31:12,159 --> 00:31:13,279
of

815
00:31:13,279 --> 00:31:15,519
misinterpretation of those capabilities

816
00:31:15,519 --> 00:31:17,519
because

817
00:31:17,519 --> 00:31:19,200
there's no misinterpretation risks

818
00:31:19,200 --> 00:31:20,640
because it's all within the same address

819
00:31:20,640 --> 00:31:22,960
space

820
00:31:24,320 --> 00:31:26,399
i'd like to very quickly touch on the

821
00:31:26,399 --> 00:31:28,159
part of the cherry project that i'm most

822
00:31:28,159 --> 00:31:29,760
directly involved with which is

823
00:31:29,760 --> 00:31:31,440
investigating using

824
00:31:31,440 --> 00:31:33,919
using cherry to build temporal safety as

825
00:31:33,919 --> 00:31:37,120
well as spatial safety

826
00:31:37,679 --> 00:31:39,440
so another way of phrasing temporal

827
00:31:39,440 --> 00:31:42,000
safety is what about use after free and

828
00:31:42,000 --> 00:31:44,240
that's a perfectly reasonable question

829
00:31:44,240 --> 00:31:46,080
after all having gone through the

830
00:31:46,080 --> 00:31:48,240
gyrations of making pointers into

831
00:31:48,240 --> 00:31:51,039
capabilities at runtime um

832
00:31:51,039 --> 00:31:53,279
it is possible to use a capability after

833
00:31:53,279 --> 00:31:54,880
freeing it still

834
00:31:54,880 --> 00:31:57,039
right so in this example right the the

835
00:31:57,039 --> 00:31:58,960
allocator is likely to return the same

836
00:31:58,960 --> 00:32:00,720
capability that i just handed back in

837
00:32:00,720 --> 00:32:02,799
free and i'm still allowed to write to

838
00:32:02,799 --> 00:32:04,960
it

839
00:32:06,159 --> 00:32:08,080
so we're going to focus or at least i

840
00:32:08,080 --> 00:32:09,760
have been mostly focused on heap

841
00:32:09,760 --> 00:32:11,519
temporal safety because heap objects

842
00:32:11,519 --> 00:32:13,440
have more complicated life cycles than

843
00:32:13,440 --> 00:32:15,440
stack objects and they tend to resist

844
00:32:15,440 --> 00:32:17,679
static approaches

845
00:32:17,679 --> 00:32:19,279
and as part of those complicated life

846
00:32:19,279 --> 00:32:21,200
cycles pointers to the heap tend to

847
00:32:21,200 --> 00:32:23,279
spread they end up in other heap objects

848
00:32:23,279 --> 00:32:25,600
in globals on the stack even into the

849
00:32:25,600 --> 00:32:27,279
kernel heap for example as part of

850
00:32:27,279 --> 00:32:30,320
asynchronous io

851
00:32:30,320 --> 00:32:31,840
right so this means that again that

852
00:32:31,840 --> 00:32:33,200
there's a risk that the application

853
00:32:33,200 --> 00:32:35,039
inadvertently retains a reference to a

854
00:32:35,039 --> 00:32:37,279
freed object which then comes to overlap

855
00:32:37,279 --> 00:32:39,039
a new allocation

856
00:32:39,039 --> 00:32:40,960
this is undefined behavior in c but that

857
00:32:40,960 --> 00:32:44,080
doesn't mean it doesn't happen

858
00:32:45,679 --> 00:32:48,640
so we can eliminate the risk of use

859
00:32:48,640 --> 00:32:50,799
after reallocation right after the

860
00:32:50,799 --> 00:32:52,880
allocator has repurposed memory

861
00:32:52,880 --> 00:32:56,159
if we first revoke dead references so

862
00:32:56,159 --> 00:32:57,600
this does leave a little bit of a use

863
00:32:57,600 --> 00:32:59,279
after free window but it just means that

864
00:32:59,279 --> 00:33:01,039
we've extended that object's lifetime a

865
00:33:01,039 --> 00:33:03,360
little bit

866
00:33:05,600 --> 00:33:07,279
note that revocation is the dual of

867
00:33:07,279 --> 00:33:09,840
garbage collection right so rather than

868
00:33:09,840 --> 00:33:11,760
extending the lifetime of objects until

869
00:33:11,760 --> 00:33:13,679
there are no references we're going to

870
00:33:13,679 --> 00:33:15,600
say you told me this object was dead i'm

871
00:33:15,600 --> 00:33:16,880
now going to delete all of the

872
00:33:16,880 --> 00:33:19,760
references to it

873
00:33:20,960 --> 00:33:22,320
so to pull this off we're going to

874
00:33:22,320 --> 00:33:24,720
expand the usual view of heap memory in

875
00:33:24,720 --> 00:33:26,399
which things are either free or

876
00:33:26,399 --> 00:33:28,000
allocated and just sort of cycle back

877
00:33:28,000 --> 00:33:30,159
and forth between the two

878
00:33:30,159 --> 00:33:32,399
by introducing a third state called

879
00:33:32,399 --> 00:33:34,320
quarantined

880
00:33:34,320 --> 00:33:36,000
address space becomes quarantined when

881
00:33:36,000 --> 00:33:38,320
the application calls free and only

882
00:33:38,320 --> 00:33:40,399
actually becomes free that is ready to

883
00:33:40,399 --> 00:33:42,000
be reallocated

884
00:33:42,000 --> 00:33:43,360
after a global sweep through the

885
00:33:43,360 --> 00:33:45,440
application's memory

886
00:33:45,440 --> 00:33:47,120
this sweep will remove capabilities

887
00:33:47,120 --> 00:33:49,760
pointing into any quarantined region and

888
00:33:49,760 --> 00:33:51,440
since sweeping is global and involves

889
00:33:51,440 --> 00:33:53,120
testing every capability in the address

890
00:33:53,120 --> 00:33:55,840
space we allow quarantine to accumulate

891
00:33:55,840 --> 00:33:58,240
for a while before we make revocation

892
00:33:58,240 --> 00:34:00,080
pass making it effectively a batch

893
00:34:00,080 --> 00:34:02,639
operation

894
00:34:03,840 --> 00:34:05,440
so this turns out to be quite feasible

895
00:34:05,440 --> 00:34:07,519
for cherry in some sense because it is a

896
00:34:07,519 --> 00:34:09,760
capability architecture we don't have to

897
00:34:09,760 --> 00:34:11,440
guess whether words are pointers to

898
00:34:11,440 --> 00:34:14,639
objects or just suspicious numbers

899
00:34:14,639 --> 00:34:16,639
and since we know with certainty we're

900
00:34:16,639 --> 00:34:19,520
justified in erasing capabilities right

901
00:34:19,520 --> 00:34:21,359
it would be really bad if we erased a

902
00:34:21,359 --> 00:34:24,239
suspicious number

903
00:34:24,639 --> 00:34:26,480
beyond merely being possible it turns

904
00:34:26,480 --> 00:34:28,320
out that we can add just a little bit of

905
00:34:28,320 --> 00:34:30,079
architectural support to speed things up

906
00:34:30,079 --> 00:34:31,918
really quite significantly

907
00:34:31,918 --> 00:34:33,599
we can have the cpu assist us in

908
00:34:33,599 --> 00:34:35,520
tracking which pages have capabilities

909
00:34:35,520 --> 00:34:37,199
on them so we don't need to sweep the

910
00:34:37,199 --> 00:34:39,839
ones that are just holding data

911
00:34:39,839 --> 00:34:42,399
and we can also avoid stopping the world

912
00:34:42,399 --> 00:34:45,280
by configuring the processor to trap on

913
00:34:45,280 --> 00:34:47,520
pages that we haven't yet looked at

914
00:34:47,520 --> 00:34:49,440
so if the user program tries to read a

915
00:34:49,440 --> 00:34:51,440
capability that we haven't yet scanned

916
00:34:51,440 --> 00:34:53,440
it will take a trap we'll scan that page

917
00:34:53,440 --> 00:34:55,119
and then allow it to access just that

918
00:34:55,119 --> 00:34:57,839
one more page

919
00:34:59,920 --> 00:35:01,760
so we have an implementation of this

920
00:35:01,760 --> 00:35:03,920
from a couple of years ago um and of

921
00:35:03,920 --> 00:35:05,359
course a bunch of work in progress but

922
00:35:05,359 --> 00:35:06,880
we haven't done a rigorous study on the

923
00:35:06,880 --> 00:35:08,160
work in progress

924
00:35:08,160 --> 00:35:11,040
but to give you some idea on spec 2006

925
00:35:11,040 --> 00:35:13,599
on the same cpu from uh from the last

926
00:35:13,599 --> 00:35:15,839
set of benchmarks the geomean overhead

927
00:35:15,839 --> 00:35:17,599
here if we have a second core that we

928
00:35:17,599 --> 00:35:19,040
can offload onto is two and a half

929
00:35:19,040 --> 00:35:20,960
percent on top of the cherry costs

930
00:35:20,960 --> 00:35:23,119
that's pretty good

931
00:35:23,119 --> 00:35:24,800
the work in progress that i mentioned of

932
00:35:24,800 --> 00:35:26,800
using these load traps uh lowers

933
00:35:26,800 --> 00:35:28,960
overheads across the board by about 10

934
00:35:28,960 --> 00:35:31,119
it seems um

935
00:35:31,119 --> 00:35:32,960
and it significantly improves by which i

936
00:35:32,960 --> 00:35:35,359
mean nearly eliminates application pause

937
00:35:35,359 --> 00:35:36,800
times

938
00:35:36,800 --> 00:35:38,160
uh and of course in the background we're

939
00:35:38,160 --> 00:35:39,440
doing additional software and

940
00:35:39,440 --> 00:35:41,599
architectural work uh to try to even

941
00:35:41,599 --> 00:35:45,720
further tamp down on these costs

942
00:35:47,119 --> 00:35:48,640
so the last thing i'd like to touch on

943
00:35:48,640 --> 00:35:51,119
today is is cherry in competition with

944
00:35:51,119 --> 00:35:54,079
safe languages like for example rust

945
00:35:54,079 --> 00:35:56,000
if you know betterage's law of headlines

946
00:35:56,000 --> 00:35:59,839
you already know that the answer is no

947
00:36:00,240 --> 00:36:02,480
but depending on which side people think

948
00:36:02,480 --> 00:36:04,480
they're on this supposed

949
00:36:04,480 --> 00:36:06,880
competition between the two begins the

950
00:36:06,880 --> 00:36:10,079
same way okay yes everything is on fire

951
00:36:10,079 --> 00:36:10,960
but

952
00:36:10,960 --> 00:36:13,040
and then it diverges with some people

953
00:36:13,040 --> 00:36:14,079
saying

954
00:36:14,079 --> 00:36:16,480
it's all c's fault safe languages solve

955
00:36:16,480 --> 00:36:18,160
all of these problems so why do we need

956
00:36:18,160 --> 00:36:20,240
cherry

957
00:36:20,240 --> 00:36:21,839
and other people say it's all the

958
00:36:21,839 --> 00:36:23,520
architecture's fault cherry fixes the

959
00:36:23,520 --> 00:36:25,520
architecture so why do we need to invest

960
00:36:25,520 --> 00:36:28,400
in safe languages

961
00:36:29,359 --> 00:36:31,440
but i think it's important right so why

962
00:36:31,440 --> 00:36:32,640
might people think that there's

963
00:36:32,640 --> 00:36:35,040
competition between the two um we should

964
00:36:35,040 --> 00:36:37,599
look in a little more detail so if i run

965
00:36:37,599 --> 00:36:39,520
an unsafe language on an unsafe

966
00:36:39,520 --> 00:36:42,720
architecture so c without cherry

967
00:36:42,720 --> 00:36:45,280
then spatial and temporal errors lead to

968
00:36:45,280 --> 00:36:47,839
arbitrary code execution it you know 90

969
00:36:47,839 --> 00:36:51,279
of the time that's just what happens

970
00:36:52,079 --> 00:36:53,760
so one answer is okay i'm going to make

971
00:36:53,760 --> 00:36:56,640
the architecture save and now spatial

972
00:36:56,640 --> 00:36:58,960
errors fail stop and if you believe the

973
00:36:58,960 --> 00:37:00,800
cornucopia implementation right then

974
00:37:00,800 --> 00:37:03,920
heap temporal error is due to

975
00:37:03,920 --> 00:37:05,520
or you could say okay no i'm just going

976
00:37:05,520 --> 00:37:07,119
to go switch to a safe language right

977
00:37:07,119 --> 00:37:09,119
java or c-sharp typescript ml haskell

978
00:37:09,119 --> 00:37:11,520
rust eta there's a whole list of these

979
00:37:11,520 --> 00:37:14,240
in these safe languages array index

980
00:37:14,240 --> 00:37:16,240
errors throw exceptions which are very

981
00:37:16,240 --> 00:37:18,400
nice little pre-packaged well-behaved

982
00:37:18,400 --> 00:37:20,400
things in the language

983
00:37:20,400 --> 00:37:22,960
and other spatial errors are impossible

984
00:37:22,960 --> 00:37:24,560
and all temporal errors are also

985
00:37:24,560 --> 00:37:26,720
impossible by construction

986
00:37:26,720 --> 00:37:28,640
so obviously that last box has a lot

987
00:37:28,640 --> 00:37:30,160
going for it right we should we should

988
00:37:30,160 --> 00:37:35,200
try to rewrite everything into that box

989
00:37:35,200 --> 00:37:37,200
unfortunately

990
00:37:37,200 --> 00:37:39,839
just in the open world there's about 10

991
00:37:39,839 --> 00:37:42,640
billion lines of c and about 3 billion

992
00:37:42,640 --> 00:37:44,480
lines of c plus

993
00:37:44,480 --> 00:37:46,880
uh that probably works out to between

994
00:37:46,880 --> 00:37:49,359
130 and 1 300

995
00:37:49,359 --> 00:37:52,240
billion dollars to rewrite just open

996
00:37:52,240 --> 00:37:54,560
source

997
00:37:56,400 --> 00:37:59,280
moreover even if we tried to do that

998
00:37:59,280 --> 00:38:01,760
there is some code that is intrinsically

999
00:38:01,760 --> 00:38:04,320
unsafe because it sits below the

1000
00:38:04,320 --> 00:38:06,240
language abstraction so these are things

1001
00:38:06,240 --> 00:38:07,839
like your memory manager your garbage

1002
00:38:07,839 --> 00:38:11,279
collector your context switcher

1003
00:38:12,079 --> 00:38:13,359
and moreover

1004
00:38:13,359 --> 00:38:15,599
different safe languages even even

1005
00:38:15,599 --> 00:38:18,000
runtimes of the same language likely

1006
00:38:18,000 --> 00:38:20,320
view each other as unsafe because the

1007
00:38:20,320 --> 00:38:21,839
runtimes will maintain different

1008
00:38:21,839 --> 00:38:24,480
invariants

1009
00:38:24,880 --> 00:38:27,200
okay so let's try to rewrite parts of

1010
00:38:27,200 --> 00:38:30,160
the program instead

1011
00:38:31,680 --> 00:38:33,520
so when we think about rewriting part of

1012
00:38:33,520 --> 00:38:35,680
a program the model that we have is a

1013
00:38:35,680 --> 00:38:38,400
two worlds model there's the safe world

1014
00:38:38,400 --> 00:38:39,920
with the new safe code which

1015
00:38:39,920 --> 00:38:42,320
communicates with the unsafe old world

1016
00:38:42,320 --> 00:38:46,240
through some well-defined interface

1017
00:38:46,240 --> 00:38:48,079
but in the real world things are quite

1018
00:38:48,079 --> 00:38:50,640
different the safe code is inside the

1019
00:38:50,640 --> 00:38:53,040
unsafe world and any memory safety bug

1020
00:38:53,040 --> 00:38:55,359
in the unsafe code can violate any of

1021
00:38:55,359 --> 00:38:57,119
the invariance that the safe language

1022
00:38:57,119 --> 00:39:00,480
code depends on

1023
00:39:00,480 --> 00:39:02,240
so the sandboxing functionality that

1024
00:39:02,240 --> 00:39:05,040
cherry provides gives us a mechanism to

1025
00:39:05,040 --> 00:39:07,280
confine memory safety errors to

1026
00:39:07,280 --> 00:39:09,599
instances of unsafe code

1027
00:39:09,599 --> 00:39:11,440
we can catch sherry's architectural

1028
00:39:11,440 --> 00:39:14,240
traps within a sandbox and turn them

1029
00:39:14,240 --> 00:39:17,119
into error reports for the safe language

1030
00:39:17,119 --> 00:39:19,200
or exceptions in the safe language which

1031
00:39:19,200 --> 00:39:21,280
can then gracefully recover because the

1032
00:39:21,280 --> 00:39:23,520
error cannot have corrupted the state of

1033
00:39:23,520 --> 00:39:26,240
the safe world

1034
00:39:27,040 --> 00:39:28,640
i'd like to give a shout out to the rest

1035
00:39:28,640 --> 00:39:30,880
community by the way where for not

1036
00:39:30,880 --> 00:39:32,560
entirely unrelated reasons there's

1037
00:39:32,560 --> 00:39:34,560
already a bit of a move towards a very

1038
00:39:34,560 --> 00:39:37,520
compatible story um they have recently

1039
00:39:37,520 --> 00:39:39,440
come to be fretting about the semantics

1040
00:39:39,440 --> 00:39:41,200
of unsafe rust because it turns out

1041
00:39:41,200 --> 00:39:43,839
compilers like to make assumptions

1042
00:39:43,839 --> 00:39:45,920
um and there's a recent proposal that

1043
00:39:45,920 --> 00:39:47,760
basically says we should use something

1044
00:39:47,760 --> 00:39:50,400
that is very much like cherry in unsafe

1045
00:39:50,400 --> 00:39:51,520
rust

1046
00:39:51,520 --> 00:39:54,160
and so if you write code that if you

1047
00:39:54,160 --> 00:39:55,839
write unsafe rust using this strict

1048
00:39:55,839 --> 00:39:57,839
provenance model it should be less

1049
00:39:57,839 --> 00:40:01,040
unsafe on cherry

1050
00:40:01,920 --> 00:40:04,079
and so with that i'll wrap up

1051
00:40:04,079 --> 00:40:06,880
so cherry enriches cpus to have tagged

1052
00:40:06,880 --> 00:40:08,319
capabilities with architecturally

1053
00:40:08,319 --> 00:40:11,440
enforced invariants this addresses many

1054
00:40:11,440 --> 00:40:13,359
root causes of long-standing security

1055
00:40:13,359 --> 00:40:15,839
vulnerabilities and promising and offers

1056
00:40:15,839 --> 00:40:17,359
promising new compartmentalization

1057
00:40:17,359 --> 00:40:19,440
mechanisms

1058
00:40:19,440 --> 00:40:21,920
it looks to be quite real there's

1059
00:40:21,920 --> 00:40:24,000
an fpga risk five and there's this arm

1060
00:40:24,000 --> 00:40:27,520
morello soc we have llvm freebsde and

1061
00:40:27,520 --> 00:40:29,920
most of kde

1062
00:40:29,920 --> 00:40:31,440
if you want to know more please do get

1063
00:40:31,440 --> 00:40:33,680
in touch on shariacpu.org there is a

1064
00:40:33,680 --> 00:40:35,040
whole bunch more reading material

1065
00:40:35,040 --> 00:40:36,720
probably about a thousand pages at this

1066
00:40:36,720 --> 00:40:37,599
point

1067
00:40:37,599 --> 00:40:40,160
um there's a slack and email lists and

1068
00:40:40,160 --> 00:40:41,599
so on

1069
00:40:41,599 --> 00:40:42,800
and of course you're welcome to play

1070
00:40:42,800 --> 00:40:45,280
along at home almost everything here is

1071
00:40:45,280 --> 00:40:47,599
uh open source uh so there's a getting

1072
00:40:47,599 --> 00:40:49,359
started guide we have a one-stop shop

1073
00:40:49,359 --> 00:40:50,960
cross-build system and there's even a

1074
00:40:50,960 --> 00:40:53,119
little bit of a textbook to help you uh

1075
00:40:53,119 --> 00:40:55,920
get used to programming on cherry

1076
00:40:55,920 --> 00:40:58,400
and with that i'll take questions

1077
00:40:58,400 --> 00:41:00,160
all right he can hear you everyone so if

1078
00:41:00,160 --> 00:41:01,520
you have any questions let me know and

1079
00:41:01,520 --> 00:41:04,480
i'll read them out to him

1080
00:41:04,720 --> 00:41:07,200
any questions oh there was

1081
00:41:07,200 --> 00:41:08,640
there was one on matrix that i can

1082
00:41:08,640 --> 00:41:10,720
answer um so the question was have you

1083
00:41:10,720 --> 00:41:13,040
tried first and then we'll do yours

1084
00:41:13,040 --> 00:41:15,200
sorry um it was the question was have

1085
00:41:15,200 --> 00:41:17,200
you tried running a capability style os

1086
00:41:17,200 --> 00:41:19,599
on top of cherry like scl4 or things

1087
00:41:19,599 --> 00:41:20,960
like gnode

1088
00:41:20,960 --> 00:41:23,520
we have not run those specifically to

1089
00:41:23,520 --> 00:41:25,359
the best of my knowledge

1090
00:41:25,359 --> 00:41:27,520
however there there have been over the

1091
00:41:27,520 --> 00:41:29,680
years some uh

1092
00:41:29,680 --> 00:41:33,040
some blue blue sky green field

1093
00:41:33,040 --> 00:41:34,880
experiments in writing

1094
00:41:34,880 --> 00:41:37,440
operating systems on the assumption of

1095
00:41:37,440 --> 00:41:38,640
um

1096
00:41:38,640 --> 00:41:40,079
you know what if we had had cherry from

1097
00:41:40,079 --> 00:41:41,359
the beginning

1098
00:41:41,359 --> 00:41:42,160
um

1099
00:41:42,160 --> 00:41:43,119
and so

1100
00:41:43,119 --> 00:41:45,680
uh this this

1101
00:41:45,680 --> 00:41:47,599
thesis by lawrence s wood chariots

1102
00:41:47,599 --> 00:41:48,880
designing an untrusted single

1103
00:41:48,880 --> 00:41:50,319
address-based capability operating

1104
00:41:50,319 --> 00:41:51,760
system using capability hardware and a

1105
00:41:51,760 --> 00:41:54,400
minimal hypervisor

1106
00:41:54,400 --> 00:41:57,040
is a really excellent look at that kind

1107
00:41:57,040 --> 00:41:58,560
of a direction

1108
00:41:58,560 --> 00:42:01,119
and if people want to try porting gnode

1109
00:42:01,119 --> 00:42:04,560
right we would be all ears

1110
00:42:05,280 --> 00:42:08,480
all right question from the room

1111
00:42:14,839 --> 00:42:17,280
uh okay the question is why did you

1112
00:42:17,280 --> 00:42:20,079
reduce the amount of metadata from 127

1113
00:42:20,079 --> 00:42:22,720
to 127 bits from 128 bits so you could

1114
00:42:22,720 --> 00:42:25,119
use the tag

1115
00:42:25,119 --> 00:42:27,520
ah so the reason that

1116
00:42:27,520 --> 00:42:30,720
that's an excellent question um so

1117
00:42:30,720 --> 00:42:33,040
the reason that we keep the tags

1118
00:42:33,040 --> 00:42:36,319
separate is so that memory continues to

1119
00:42:36,319 --> 00:42:37,839
act like memory

1120
00:42:37,839 --> 00:42:40,720
right if we put the tag in with the

1121
00:42:40,720 --> 00:42:41,520
other

1122
00:42:41,520 --> 00:42:43,040
chunk of bytes

1123
00:42:43,040 --> 00:42:46,480
then a data store to memory could set

1124
00:42:46,480 --> 00:42:48,400
that tag right or could you know could

1125
00:42:48,400 --> 00:42:51,040
do whatever it needed to do to magic up

1126
00:42:51,040 --> 00:42:53,359
a capability out of nowhere

1127
00:42:53,359 --> 00:42:55,440
because the valid bits are off on the

1128
00:42:55,440 --> 00:42:57,839
side the architecture can manipulate

1129
00:42:57,839 --> 00:42:59,839
them separately and enforce this

1130
00:42:59,839 --> 00:43:02,640
invariant that if the tag is set then

1131
00:43:02,640 --> 00:43:04,560
the corresponding bytes represent a

1132
00:43:04,560 --> 00:43:06,640
well-formed legitimately derived

1133
00:43:06,640 --> 00:43:09,200
capability

1134
00:43:09,280 --> 00:43:11,200
does that answer the question

1135
00:43:11,200 --> 00:43:13,040
all right that answers the question

1136
00:43:13,040 --> 00:43:16,400
any other questions from the room

1137
00:43:17,119 --> 00:43:21,160
all right we have one more

1138
00:43:30,880 --> 00:43:33,040
doesn't the tag explorer

1139
00:43:33,040 --> 00:43:35,599
run through it again doesn't 10 explorer

1140
00:43:35,599 --> 00:43:38,839
i'm sorry

1141
00:43:40,319 --> 00:43:41,680
uh we're going to bring the

1142
00:43:41,680 --> 00:43:44,240
question up to the mic

1143
00:43:44,240 --> 00:43:46,560
all right

1144
00:43:47,119 --> 00:43:48,800
doesn't the tag controller being

1145
00:43:48,800 --> 00:43:51,119
external and inaccessible

1146
00:43:51,119 --> 00:43:53,920
uh have implications in for example

1147
00:43:53,920 --> 00:43:56,640
hibernate and resume for processes

1148
00:43:56,640 --> 00:43:59,598
because the test ah

1149
00:44:00,079 --> 00:44:03,760
yes so what an excellent question um so

1150
00:44:03,760 --> 00:44:05,680
more generally paging is a really

1151
00:44:05,680 --> 00:44:07,200
interesting question because for example

1152
00:44:07,200 --> 00:44:10,319
discs also don't understand capabilities

1153
00:44:10,319 --> 00:44:12,400
right they just understand bytes

1154
00:44:12,400 --> 00:44:13,520
um

1155
00:44:13,520 --> 00:44:16,079
and so the way that paging and and

1156
00:44:16,079 --> 00:44:18,400
hibernate and resume would work

1157
00:44:18,400 --> 00:44:19,440
is

1158
00:44:19,440 --> 00:44:22,720
the kernel or the hypervisor retains

1159
00:44:22,720 --> 00:44:27,760
a capability to the entire address space

1160
00:44:27,760 --> 00:44:28,720
and

1161
00:44:28,720 --> 00:44:29,599
when

1162
00:44:29,599 --> 00:44:31,680
it pages something back in

1163
00:44:31,680 --> 00:44:35,040
it uses that authority to reconstruct

1164
00:44:35,040 --> 00:44:38,240
capabilities from the bytes on disk so

1165
00:44:38,240 --> 00:44:40,960
we write out all of the bytes in a page

1166
00:44:40,960 --> 00:44:43,119
we then write out the tag bits that

1167
00:44:43,119 --> 00:44:44,960
correspond to those bytes as a separate

1168
00:44:44,960 --> 00:44:47,200
chunk of bytes on disk

1169
00:44:47,200 --> 00:44:49,280
and then we pull both of those back in

1170
00:44:49,280 --> 00:44:51,119
and recombine them

1171
00:44:51,119 --> 00:44:53,119
using the capability manipulation

1172
00:44:53,119 --> 00:44:56,240
instructions of cherry

1173
00:44:56,319 --> 00:44:57,040
so

1174
00:44:57,040 --> 00:44:58,880
there are yes there is some complexity

1175
00:44:58,880 --> 00:45:03,000
there but it can be made to work

1176
00:45:04,000 --> 00:45:07,280
right any final questions

1177
00:45:07,280 --> 00:45:09,200
i see one on matrix which is would this

1178
00:45:09,200 --> 00:45:10,800
mitigate speculative execution

1179
00:45:10,800 --> 00:45:12,560
vulnerabilities that expose data via

1180
00:45:12,560 --> 00:45:14,560
side channels and oh that is an

1181
00:45:14,560 --> 00:45:16,640
excellent question we have a we the

1182
00:45:16,640 --> 00:45:19,119
computer lab at cambridge university

1183
00:45:19,119 --> 00:45:21,599
um have a short report that looks into

1184
00:45:21,599 --> 00:45:24,560
this um but boy it's just a

1185
00:45:24,560 --> 00:45:26,240
well speculative vulnerabilities in

1186
00:45:26,240 --> 00:45:28,240
general are just a minefield and and so

1187
00:45:28,240 --> 00:45:30,560
why would we be different um

1188
00:45:30,560 --> 00:45:33,520
but yes um because

1189
00:45:33,520 --> 00:45:35,599
leaking the capability bits themselves

1190
00:45:35,599 --> 00:45:40,079
doesn't buy an attacker anything we do

1191
00:45:40,079 --> 00:45:41,760
reduce the impact of a bunch of

1192
00:45:41,760 --> 00:45:44,000
speculation vulnerabilities i won't say

1193
00:45:44,000 --> 00:45:46,640
we mitigate them but right off the bat

1194
00:45:46,640 --> 00:45:48,560
we reduce their

1195
00:45:48,560 --> 00:45:50,000
uh

1196
00:45:50,000 --> 00:45:51,520
sorry right off the bat we reduce the

1197
00:45:51,520 --> 00:45:53,280
impact of some of them some of them we

1198
00:45:53,280 --> 00:45:54,800
do mitigate so

1199
00:45:54,800 --> 00:45:57,040
for example um if you think of like the

1200
00:45:57,040 --> 00:46:01,040
spectre v1 chain load gadget um because

1201
00:46:01,040 --> 00:46:04,079
you pick up bounds when you do that the

1202
00:46:04,079 --> 00:46:05,839
first load

1203
00:46:05,839 --> 00:46:08,240
even in speculation you won't execute

1204
00:46:08,240 --> 00:46:09,680
the second load it would it would

1205
00:46:09,680 --> 00:46:12,000
speculatively trap but instead you'll

1206
00:46:12,000 --> 00:46:14,560
you'll you know you'll abort and unwind

1207
00:46:14,560 --> 00:46:15,839
um

1208
00:46:15,839 --> 00:46:16,880
so

1209
00:46:16,880 --> 00:46:18,960
some vulnerabilities also just basically

1210
00:46:18,960 --> 00:46:21,599
right off the bat get get mitigated but

1211
00:46:21,599 --> 00:46:23,520
we don't do anything for example about

1212
00:46:23,520 --> 00:46:25,200
side channels that might leak your

1213
00:46:25,200 --> 00:46:27,200
cryptographic keys because those are

1214
00:46:27,200 --> 00:46:28,640
just data

1215
00:46:28,640 --> 00:46:30,720
um so there is this really interesting

1216
00:46:30,720 --> 00:46:34,640
landscape of like of splitting

1217
00:46:34,640 --> 00:46:40,118
how cherry and speculation work together

1218
00:46:42,560 --> 00:46:44,640
all right i think that's the last

1219
00:46:44,640 --> 00:46:46,240
question unless there's one more from

1220
00:46:46,240 --> 00:46:48,720
the audience

1221
00:46:48,720 --> 00:46:50,400
excellent well thank you so much new for

1222
00:46:50,400 --> 00:46:52,640
the talk on cherry it was fascinating

1223
00:46:52,640 --> 00:46:54,960
thank you everyone uh will the resources

1224
00:46:54,960 --> 00:46:57,359
be available to the audience anywhere uh

1225
00:46:57,359 --> 00:46:59,280
yes i will i will share these slides and

1226
00:46:59,280 --> 00:47:01,040
all of the links in them

1227
00:47:01,040 --> 00:47:02,640
uh yeah if you share them in the matrix

1228
00:47:02,640 --> 00:47:04,960
chat channel everyone can access the

1229
00:47:04,960 --> 00:47:06,560
matrix chat channel throughout the rest

1230
00:47:06,560 --> 00:47:08,839
of the conference and afterwards

1231
00:47:08,839 --> 00:47:11,280
perfect all right thank you so much for

1232
00:47:11,280 --> 00:47:12,640
your time we really appreciate thank you

1233
00:47:12,640 --> 00:47:14,960
everyone

1234
00:47:17,760 --> 00:47:20,160
all right everyone the next talk will be

1235
00:47:20,160 --> 00:47:20,960
uh

1236
00:47:20,960 --> 00:47:22,559
cyber security certification the good

1237
00:47:22,559 --> 00:47:24,720
the bad and the ugly at two o'clock

1238
00:47:24,720 --> 00:47:28,520
look forward to seeing you there

1239
00:47:58,960 --> 00:48:01,040
you

