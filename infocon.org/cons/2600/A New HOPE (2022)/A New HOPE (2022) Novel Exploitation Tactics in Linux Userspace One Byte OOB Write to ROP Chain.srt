1
00:00:55,440 --> 00:00:58,440
bye

2
00:01:05,920 --> 00:01:08,479
hello everyone welcome to the next talk

3
00:01:08,479 --> 00:01:09,680
in our

4
00:01:09,680 --> 00:01:11,760
series of talks today in track three a

5
00:01:11,760 --> 00:01:13,680
couple of housekeeping issues

6
00:01:13,680 --> 00:01:15,680
again i'm sure some of you heard this

7
00:01:15,680 --> 00:01:17,600
many times before

8
00:01:17,600 --> 00:01:19,920
thank you for confirming the mass policy

9
00:01:19,920 --> 00:01:21,680
we really appreciate it it helps keep

10
00:01:21,680 --> 00:01:23,280
you know it helps keep us all feel

11
00:01:23,280 --> 00:01:25,680
comfortable being here in the space

12
00:01:25,680 --> 00:01:26,880
if you feel uncomfortable remember you

13
00:01:26,880 --> 00:01:28,240
can always go outside and take them off

14
00:01:28,240 --> 00:01:30,320
master not required outside the building

15
00:01:30,320 --> 00:01:31,840
stay hydrated i know we're getting later

16
00:01:31,840 --> 00:01:32,880
in the day so it's not quite so

17
00:01:32,880 --> 00:01:34,799
important now but it's always important

18
00:01:34,799 --> 00:01:36,960
so you can be healthy and enjoy the rest

19
00:01:36,960 --> 00:01:38,799
of the talks in the conference

20
00:01:38,799 --> 00:01:40,400
please mute your phone for these

21
00:01:40,400 --> 00:01:42,960
sessions the audio is super sensitive so

22
00:01:42,960 --> 00:01:45,119
it picks up almost any sound other than

23
00:01:45,119 --> 00:01:46,640
and we'd like to keep the focus on the

24
00:01:46,640 --> 00:01:47,759
talks

25
00:01:47,759 --> 00:01:50,079
there's an unscheduled fourth talk track

26
00:01:50,079 --> 00:01:51,920
for anyone who wasn't able to get into

27
00:01:51,920 --> 00:01:53,840
any of the three principal tracks you

28
00:01:53,840 --> 00:01:55,439
can go to the information desk if you

29
00:01:55,439 --> 00:01:57,040
have an idea for a talk you want to give

30
00:01:57,040 --> 00:01:58,479
you can go there and you can request and

31
00:01:58,479 --> 00:01:59,840
they'll find a time for you to be able

32
00:01:59,840 --> 00:02:01,920
to participate in the unscheduled track

33
00:02:01,920 --> 00:02:04,479
which is in the the coffee house

34
00:02:04,479 --> 00:02:07,200
hacker karaoke tonight at 10

35
00:02:07,200 --> 00:02:09,679
hopefully some of you will participate

36
00:02:09,679 --> 00:02:11,440
i'm sure it'll be a lot of fun

37
00:02:11,440 --> 00:02:13,120
more volunteers are welcome we can

38
00:02:13,120 --> 00:02:14,879
always use volunteers there's all kinds

39
00:02:14,879 --> 00:02:16,480
of activities that we need help with

40
00:02:16,480 --> 00:02:18,640
especially in terms of security so if

41
00:02:18,640 --> 00:02:20,879
you're interested stop by room 301 or go

42
00:02:20,879 --> 00:02:23,520
to volunteer.hope.net and sign up and

43
00:02:23,520 --> 00:02:25,520
lastly the first late night block of

44
00:02:25,520 --> 00:02:27,200
mature content programming starts at 9

45
00:02:27,200 --> 00:02:29,760
30 in the video room which is 406 fourth

46
00:02:29,760 --> 00:02:31,760
floor all the way over

47
00:02:31,760 --> 00:02:34,400
uh tonight's video room late night theme

48
00:02:34,400 --> 00:02:36,720
is humor and horror so expect the

49
00:02:36,720 --> 00:02:38,879
unexpected is what they tell me

50
00:02:38,879 --> 00:02:41,200
uh for the talk novel exploitation

51
00:02:41,200 --> 00:02:43,599
tactics in linux user space one byte ob

52
00:02:43,599 --> 00:02:48,760
right to rop chain by sammy hallman

53
00:02:53,120 --> 00:02:56,080
everything joe and stuff

54
00:03:01,840 --> 00:03:04,319
all right hi uh welcome to novel

55
00:03:04,319 --> 00:03:06,319
exploitation tactics in linux user space

56
00:03:06,319 --> 00:03:08,080
with runtime loader

57
00:03:08,080 --> 00:03:09,599
we're going to be utilizing the runtime

58
00:03:09,599 --> 00:03:12,239
loader to exploit some vulnerabilities

59
00:03:12,239 --> 00:03:13,519
when these vulnerabilities are

60
00:03:13,519 --> 00:03:15,040
considered weak and the security checks

61
00:03:15,040 --> 00:03:17,120
are considered high so let's get right

62
00:03:17,120 --> 00:03:20,319
in first off who am i uh i'm sami

63
00:03:20,319 --> 00:03:22,640
hachamed uh i go by pepsipoo on twitter

64
00:03:22,640 --> 00:03:24,480
my handle stuff like that

65
00:03:24,480 --> 00:03:26,640
i'm a student at troy high school

66
00:03:26,640 --> 00:03:28,560
i'm also the founder and reverse

67
00:03:28,560 --> 00:03:31,440
engineer at b swap labs but i also do

68
00:03:31,440 --> 00:03:32,720
blockchain security auditing and

69
00:03:32,720 --> 00:03:35,280
vulnerability research at ottersec

70
00:03:35,280 --> 00:03:38,480
um i also play ctf for fun uh dice

71
00:03:38,480 --> 00:03:40,080
king's etf right phone ctf for my team

72
00:03:40,080 --> 00:03:42,000
hi dez king see you in the free photo

73
00:03:42,000 --> 00:03:43,519
all right so let's get right into the

74
00:03:43,519 --> 00:03:44,400
talk

75
00:03:44,400 --> 00:03:46,640
first off what's this presentation about

76
00:03:46,640 --> 00:03:48,159
well the process of turning

77
00:03:48,159 --> 00:03:50,959
vulnerabilities into exploits is

78
00:03:50,959 --> 00:03:53,280
hard there's a lot of protections which

79
00:03:53,280 --> 00:03:55,599
exist to make this even harder

80
00:03:55,599 --> 00:03:58,720
and it's complicated but the runtime

81
00:03:58,720 --> 00:04:01,040
loader can make it a lot easier

82
00:04:01,040 --> 00:04:02,799
first to show this we're going to start

83
00:04:02,799 --> 00:04:04,959
with a weak vulnerability and this

84
00:04:04,959 --> 00:04:06,480
vulnerability is going to be under

85
00:04:06,480 --> 00:04:08,159
extremely powerful protection so we'll

86
00:04:08,159 --> 00:04:09,840
talk about those protections later

87
00:04:09,840 --> 00:04:10,720
and

88
00:04:10,720 --> 00:04:11,840
through that we're still going to get

89
00:04:11,840 --> 00:04:13,680
arbitrary code execution

90
00:04:13,680 --> 00:04:16,238
so let's get right in

91
00:04:16,238 --> 00:04:18,160
all right vulnerability exploitation

92
00:04:18,160 --> 00:04:20,079
made easy houses

93
00:04:20,079 --> 00:04:22,400
houses are a sort of pre-baked series of

94
00:04:22,400 --> 00:04:24,400
steps to turn a vulnerability into a

95
00:04:24,400 --> 00:04:26,320
full-fledged exploit

96
00:04:26,320 --> 00:04:27,680
generally this is kind of sort of a

97
00:04:27,680 --> 00:04:29,199
helping process you know turning

98
00:04:29,199 --> 00:04:30,720
vulnerabilities into exploits is hard

99
00:04:30,720 --> 00:04:33,280
and houses kind of give you a road map

100
00:04:33,280 --> 00:04:35,040
to do that process

101
00:04:35,040 --> 00:04:36,080
there's a lot of them there's a lot of

102
00:04:36,080 --> 00:04:37,680
uh popular houses like you're right you

103
00:04:37,680 --> 00:04:40,479
could see a list of how to keep houses

104
00:04:40,479 --> 00:04:42,479
and there's also some unlisted like

105
00:04:42,479 --> 00:04:44,639
house of red house of husk house of

106
00:04:44,639 --> 00:04:46,240
corrosion all very popular and

107
00:04:46,240 --> 00:04:48,560
well-respected houses in ctf and

108
00:04:48,560 --> 00:04:49,840
exploitation

109
00:04:49,840 --> 00:04:52,000
but the one aspect that all these houses

110
00:04:52,000 --> 00:04:54,240
share is that they're portable

111
00:04:54,240 --> 00:04:56,800
see the series of steps to turn the

112
00:04:56,800 --> 00:04:59,280
vulnerability into the exploit should be

113
00:04:59,280 --> 00:05:01,360
roughly the same as long as the

114
00:05:01,360 --> 00:05:03,520
vulnerabilities are roughly the same for

115
00:05:03,520 --> 00:05:05,440
example two programs with the same

116
00:05:05,440 --> 00:05:08,479
vulnerability let's say top chunk header

117
00:05:08,479 --> 00:05:10,960
overwrite should both be exploitable by

118
00:05:10,960 --> 00:05:13,840
using house of uh house of force

119
00:05:13,840 --> 00:05:16,160
and even if those two programs are

120
00:05:16,160 --> 00:05:17,520
minecraft and chrome as long as they

121
00:05:17,520 --> 00:05:18,720
share that core

122
00:05:18,720 --> 00:05:20,400
vulnerability they can kind of share

123
00:05:20,400 --> 00:05:22,320
that core process of turning the

124
00:05:22,320 --> 00:05:24,960
vulnerability into an exploit so how do

125
00:05:24,960 --> 00:05:26,720
programs do this

126
00:05:26,720 --> 00:05:29,360
well the answer is libraries instead of

127
00:05:29,360 --> 00:05:31,199
leveraging the vulnerability against the

128
00:05:31,199 --> 00:05:33,680
program houses use the vulnerability

129
00:05:33,680 --> 00:05:35,600
against a shared library

130
00:05:35,600 --> 00:05:38,000
the overwhelming majority of of houses

131
00:05:38,000 --> 00:05:40,080
that vulnerability is leveraged against

132
00:05:40,080 --> 00:05:43,919
is libsy or the new c library it's

133
00:05:43,919 --> 00:05:45,919
over the most overwhelmingly popular c

134
00:05:45,919 --> 00:05:48,080
library it's really the de facto

135
00:05:48,080 --> 00:05:50,639
standard and it's used in almost 100 of

136
00:05:50,639 --> 00:05:52,639
linux programs it provides everything

137
00:05:52,639 --> 00:05:54,800
from printing to memory management file

138
00:05:54,800 --> 00:05:56,479
operations you name it

139
00:05:56,479 --> 00:05:58,720
and so if you can find a way to use your

140
00:05:58,720 --> 00:06:01,120
vulnerability against libsy you'll be

141
00:06:01,120 --> 00:06:03,600
able to have a portable house

142
00:06:03,600 --> 00:06:06,160
so

143
00:06:06,160 --> 00:06:07,759
let's take an example

144
00:06:07,759 --> 00:06:09,520
uh let's say we have a buffer overflow

145
00:06:09,520 --> 00:06:10,560
on the heap

146
00:06:10,560 --> 00:06:12,560
let's say we allocate two chunks chunk

147
00:06:12,560 --> 00:06:14,479
one and chunk two for those who don't

148
00:06:14,479 --> 00:06:17,120
know these chunks end up on the heap

149
00:06:17,120 --> 00:06:19,600
it's sort of a free use location of

150
00:06:19,600 --> 00:06:22,319
memory where programs can put their data

151
00:06:22,319 --> 00:06:24,720
now let's say we have a buffer overflow

152
00:06:24,720 --> 00:06:26,800
in chunk 1. this means that we're

153
00:06:26,800 --> 00:06:28,639
writing data outside the bounds of chunk

154
00:06:28,639 --> 00:06:29,520
1.

155
00:06:29,520 --> 00:06:32,800
is it a better idea to a overwrite the

156
00:06:32,800 --> 00:06:35,919
chunk 2 header or b overwrite the chunk

157
00:06:35,919 --> 00:06:38,000
2 program data as you've seen this

158
00:06:38,000 --> 00:06:39,520
little diagram right here

159
00:06:39,520 --> 00:06:41,759
well you could make a case for both but

160
00:06:41,759 --> 00:06:43,840
in the case for houses it's a lot easier

161
00:06:43,840 --> 00:06:45,680
to say let's overwrite the chunk 2

162
00:06:45,680 --> 00:06:48,000
header this is because the allocator's

163
00:06:48,000 --> 00:06:50,479
behavior when libsy anyways his behavior

164
00:06:50,479 --> 00:06:52,800
is very well studied and well documented

165
00:06:52,800 --> 00:06:55,039
and there exists multiple prebaked steps

166
00:06:55,039 --> 00:06:57,759
houses to turn this chunk to header

167
00:06:57,759 --> 00:07:00,880
overwrite into remote coexecution so you

168
00:07:00,880 --> 00:07:03,120
can kind of use somebody else's work by

169
00:07:03,120 --> 00:07:05,199
overwriting the header the program data

170
00:07:05,199 --> 00:07:06,960
on the other hand is different from each

171
00:07:06,960 --> 00:07:09,120
program to program so you'd have to roll

172
00:07:09,120 --> 00:07:10,560
your own solution

173
00:07:10,560 --> 00:07:11,759
just like that you could kind of see the

174
00:07:11,759 --> 00:07:15,199
power of houses that they're portable

175
00:07:15,199 --> 00:07:18,240
all right how do i find a house well

176
00:07:18,240 --> 00:07:19,919
finding houses is hard

177
00:07:19,919 --> 00:07:21,520
mostly because there's a lot of eyes not

178
00:07:21,520 --> 00:07:24,000
only from hackers looking for new houses

179
00:07:24,000 --> 00:07:26,720
but libsy maintainers patching all those

180
00:07:26,720 --> 00:07:28,639
houses that are getting generated

181
00:07:28,639 --> 00:07:30,479
but that doesn't mean it's impossible

182
00:07:30,479 --> 00:07:32,400
if you can look at an attack surface in

183
00:07:32,400 --> 00:07:34,639
a new way or perhaps find a new one

184
00:07:34,639 --> 00:07:37,360
entirely you can still get a really cool

185
00:07:37,360 --> 00:07:39,440
house out of it

186
00:07:39,440 --> 00:07:40,960
so let's talk about the surface i

187
00:07:40,960 --> 00:07:42,240
decided to look at

188
00:07:42,240 --> 00:07:43,360
exit

189
00:07:43,360 --> 00:07:46,240
programs tend to exit pretty frequently

190
00:07:46,240 --> 00:07:48,319
i mean not only calling the exit

191
00:07:48,319 --> 00:07:50,879
function but returning from main or

192
00:07:50,879 --> 00:07:53,280
tossing errors tends to call exit under

193
00:07:53,280 --> 00:07:55,599
the hood and i don't mean errors just in

194
00:07:55,599 --> 00:07:58,639
your program but libsy errors as well

195
00:07:58,639 --> 00:08:00,479
may cause an exit

196
00:08:00,479 --> 00:08:02,960
now forcing exits with vulnerabilities

197
00:08:02,960 --> 00:08:05,360
is pretty simple i mean it's very easy

198
00:08:05,360 --> 00:08:07,759
to corrupt some sort of lipsy state and

199
00:08:07,759 --> 00:08:10,400
cause an exit by throwing an error

200
00:08:10,400 --> 00:08:12,400
so if you can find some sort of process

201
00:08:12,400 --> 00:08:14,400
or inject your own code into that exit

202
00:08:14,400 --> 00:08:15,919
process you could potentially get a

203
00:08:15,919 --> 00:08:18,080
house out of it

204
00:08:18,080 --> 00:08:19,280
so

205
00:08:19,280 --> 00:08:22,000
we've seen this kind of uh done before i

206
00:08:22,000 --> 00:08:24,800
mean it has a pretty good track record

207
00:08:24,800 --> 00:08:26,160
if you take a look at for example the

208
00:08:26,160 --> 00:08:28,639
lipsy exit hook overwrite it was a kind

209
00:08:28,639 --> 00:08:30,479
of a cool tactic where you could just

210
00:08:30,479 --> 00:08:31,919
kind of write a function pointer to a

211
00:08:31,919 --> 00:08:34,000
location memory called libsy at exit

212
00:08:34,000 --> 00:08:36,080
hook and that would be called when the

213
00:08:36,080 --> 00:08:38,159
program decided to exit there's another

214
00:08:38,159 --> 00:08:39,279
one called

215
00:08:39,279 --> 00:08:41,360
house of orange which would exploit the

216
00:08:41,360 --> 00:08:43,839
i o cleanup process and would look up a

217
00:08:43,839 --> 00:08:45,440
piece of memory and it would call the

218
00:08:45,440 --> 00:08:46,959
function pointer at that at that piece

219
00:08:46,959 --> 00:08:48,000
of memory

220
00:08:48,000 --> 00:08:49,360
of course both of these both have

221
00:08:49,360 --> 00:08:52,399
mitigations and the lipsia exit hook has

222
00:08:52,399 --> 00:08:53,600
very strong mitigation pointer

223
00:08:53,600 --> 00:08:54,399
encryption

224
00:08:54,399 --> 00:08:56,720
so uh it's kind of not super viable

225
00:08:56,720 --> 00:08:58,880
anymore but you can kind of see that it

226
00:08:58,880 --> 00:09:00,560
still is a cool attack surface to look

227
00:09:00,560 --> 00:09:01,760
at

228
00:09:01,760 --> 00:09:03,760
all right let's take a deeper deeper

229
00:09:03,760 --> 00:09:04,560
look

230
00:09:04,560 --> 00:09:06,320
okay so right off the bat you can see at

231
00:09:06,320 --> 00:09:09,120
the top you have the code for exit

232
00:09:09,120 --> 00:09:11,360
it calls one function run exit handler

233
00:09:11,360 --> 00:09:13,839
with a list of exit functions

234
00:09:13,839 --> 00:09:16,000
it's it's a little complicated but when

235
00:09:16,000 --> 00:09:17,440
you break it down it comes down to i

236
00:09:17,440 --> 00:09:19,760
guess four separate steps the first

237
00:09:19,760 --> 00:09:22,320
three looking potentially exploitable

238
00:09:22,320 --> 00:09:25,680
the first step is to run tls detours we

239
00:09:25,680 --> 00:09:26,640
don't know what that is for now but

240
00:09:26,640 --> 00:09:28,080
let's just keep that in the back of our

241
00:09:28,080 --> 00:09:28,959
head

242
00:09:28,959 --> 00:09:31,120
then we call the exit handlers sort of

243
00:09:31,120 --> 00:09:32,880
cleanup processes that are registered by

244
00:09:32,880 --> 00:09:35,440
the program or libc or something and

245
00:09:35,440 --> 00:09:38,640
those are run and finally we call libsya

246
00:09:38,640 --> 00:09:39,680
exit

247
00:09:39,680 --> 00:09:42,560
then we call the actual exorcist call

248
00:09:42,560 --> 00:09:43,839
which terminates the program that's the

249
00:09:43,839 --> 00:09:45,839
underscore exit at the bottom

250
00:09:45,839 --> 00:09:47,680
now it seems like a complicated process

251
00:09:47,680 --> 00:09:51,040
but we can break it down step by step

252
00:09:51,040 --> 00:09:52,560
first off let's take a look at the tls

253
00:09:52,560 --> 00:09:54,800
detours call these are also known as

254
00:09:54,800 --> 00:09:56,240
thread destructors

255
00:09:56,240 --> 00:09:58,560
basically they kind of are a list of

256
00:09:58,560 --> 00:10:00,160
functions to call to clean up when a

257
00:10:00,160 --> 00:10:01,760
thread terminates

258
00:10:01,760 --> 00:10:03,920
now if we could somehow inject our own

259
00:10:03,920 --> 00:10:05,839
thread destructor we might be able to

260
00:10:05,839 --> 00:10:07,760
get remote code execution

261
00:10:07,760 --> 00:10:09,839
unfortunately it turns out we can't do

262
00:10:09,839 --> 00:10:12,399
this if you take a look at the commits

263
00:10:12,399 --> 00:10:15,279
florian weimer introduced a

264
00:10:15,279 --> 00:10:17,200
hardening of the tlsd torque calling

265
00:10:17,200 --> 00:10:18,480
seven years ago

266
00:10:18,480 --> 00:10:20,720
and no longer can you write an arbitrary

267
00:10:20,720 --> 00:10:22,880
function pointer and get it called now

268
00:10:22,880 --> 00:10:24,240
it's pointer mangled meaning you need to

269
00:10:24,240 --> 00:10:26,160
know lots of secrets about the program

270
00:10:26,160 --> 00:10:28,720
and other things that makes writing uh

271
00:10:28,720 --> 00:10:29,839
just a function point are completely

272
00:10:29,839 --> 00:10:31,279
inviable so you need a very very strong

273
00:10:31,279 --> 00:10:32,640
vulnerability and it's the same

274
00:10:32,640 --> 00:10:34,480
difficulty as just overwriting libsya

275
00:10:34,480 --> 00:10:36,560
exit so no dice with a weak

276
00:10:36,560 --> 00:10:38,720
vulnerability

277
00:10:38,720 --> 00:10:40,399
all right what about the exit function

278
00:10:40,399 --> 00:10:41,440
handlers

279
00:10:41,440 --> 00:10:43,120
well it's sort of just a linked list of

280
00:10:43,120 --> 00:10:44,720
exit functions and they all have their

281
00:10:44,720 --> 00:10:46,959
own uh flavor for example you can see

282
00:10:46,959 --> 00:10:48,480
this big switch statement in the code

283
00:10:48,480 --> 00:10:50,720
which kind of tells you uh what types of

284
00:10:50,720 --> 00:10:52,240
exits you could have

285
00:10:52,240 --> 00:10:54,480
although they do vary from from a flavor

286
00:10:54,480 --> 00:10:56,240
to flavor all of them implement pointer

287
00:10:56,240 --> 00:10:57,440
mangling or pointer encryption whatever

288
00:10:57,440 --> 00:10:59,519
you want to call it and so unfortunately

289
00:10:59,519 --> 00:11:01,680
you cannot inject your own function exit

290
00:11:01,680 --> 00:11:04,079
function handler without knowing uh

291
00:11:04,079 --> 00:11:05,920
memory leaks or knowing a little bit

292
00:11:05,920 --> 00:11:07,120
more information about the program you

293
00:11:07,120 --> 00:11:08,959
can't use a weak vulnerability

294
00:11:08,959 --> 00:11:11,279
so that's really unfortunate at this

295
00:11:11,279 --> 00:11:13,200
point you might be stumped truly lost

296
00:11:13,200 --> 00:11:15,200
even unfortunately

297
00:11:15,200 --> 00:11:17,200
uh that's just how it is sometimes and i

298
00:11:17,200 --> 00:11:19,600
had given up and i said hey maybe the

299
00:11:19,600 --> 00:11:21,360
exit attack surface was dry

300
00:11:21,360 --> 00:11:22,880
and so i took a break

301
00:11:22,880 --> 00:11:25,040
however i was playing a ctf not too long

302
00:11:25,040 --> 00:11:26,880
and then i remembered a trick in ctf

303
00:11:26,880 --> 00:11:28,959
it's called the feni array overwrite and

304
00:11:28,959 --> 00:11:30,640
then i was like wait how does this trick

305
00:11:30,640 --> 00:11:31,920
work

306
00:11:31,920 --> 00:11:33,519
let me give you a crash course the feeny

307
00:11:33,519 --> 00:11:34,640
array trick

308
00:11:34,640 --> 00:11:36,480
basically a common tactic in ctf is

309
00:11:36,480 --> 00:11:38,959
called a got overwrite basically the

310
00:11:38,959 --> 00:11:41,680
table of table the global offset table

311
00:11:41,680 --> 00:11:43,920
contains a list of function pointers

312
00:11:43,920 --> 00:11:45,120
overriding one of these function

313
00:11:45,120 --> 00:11:46,959
pointers with your own function or own

314
00:11:46,959 --> 00:11:48,720
function pointer would cause that

315
00:11:48,720 --> 00:11:50,240
function to get called instead of the

316
00:11:50,240 --> 00:11:51,760
function it's supposed to get called for

317
00:11:51,760 --> 00:11:53,040
example you could see in the image if we

318
00:11:53,040 --> 00:11:55,519
have got the enter the first entry zero

319
00:11:55,519 --> 00:11:57,519
entry is string copy if you overwrite

320
00:11:57,519 --> 00:11:59,200
that with something else like for

321
00:11:59,200 --> 00:12:01,600
example uh dead beef then you would end

322
00:12:01,600 --> 00:12:03,040
up calling dead beef when string copy is

323
00:12:03,040 --> 00:12:04,320
supposed to be called

324
00:12:04,320 --> 00:12:06,399
now sometimes overriding the got isn't

325
00:12:06,399 --> 00:12:07,680
always available

326
00:12:07,680 --> 00:12:08,880
so there's sort of an extension of the

327
00:12:08,880 --> 00:12:11,519
got tech very close to the got exists

328
00:12:11,519 --> 00:12:14,320
this variable called feni array

329
00:12:14,320 --> 00:12:16,079
now if you overwrite phenia right write

330
00:12:16,079 --> 00:12:18,000
your own function pointer to finia right

331
00:12:18,000 --> 00:12:19,600
then you can call

332
00:12:19,600 --> 00:12:21,440
whatever's there it'll get called when

333
00:12:21,440 --> 00:12:22,639
you exit

334
00:12:22,639 --> 00:12:24,000
but hold on for a second is that a

335
00:12:24,000 --> 00:12:25,200
little weird didn't we take a look at

336
00:12:25,200 --> 00:12:27,440
the exit code and we saw nothing calling

337
00:12:27,440 --> 00:12:32,000
fenia right so how does finia array work

338
00:12:33,120 --> 00:12:35,279
well it's a good question and the answer

339
00:12:35,279 --> 00:12:37,839
is diel finney it's an extremely

340
00:12:37,839 --> 00:12:39,519
complicated function but it is super

341
00:12:39,519 --> 00:12:40,800
cool because there's a lot of complexity

342
00:12:40,800 --> 00:12:42,399
inside of it maybe complexity we could

343
00:12:42,399 --> 00:12:44,000
exploit

344
00:12:44,000 --> 00:12:47,040
now this is the shared library unloader

345
00:12:47,040 --> 00:12:47,920
function

346
00:12:47,920 --> 00:12:49,680
uh it's the one that cleans up all the

347
00:12:49,680 --> 00:12:51,279
shared library unloads everything calls

348
00:12:51,279 --> 00:12:52,959
all the destructors stuff like that so

349
00:12:52,959 --> 00:12:54,480
it's kind of just like the the memory

350
00:12:54,480 --> 00:12:55,920
cleaner upper for all the shared

351
00:12:55,920 --> 00:12:57,440
libraries you have

352
00:12:57,440 --> 00:12:58,880
now it's really interesting right

353
00:12:58,880 --> 00:13:00,480
because this is a complicated function

354
00:13:00,480 --> 00:13:02,320
that not only has complexity

355
00:13:02,320 --> 00:13:05,360
but 18 year old code so it could be some

356
00:13:05,360 --> 00:13:06,800
attack vector we could take advantage of

357
00:13:06,800 --> 00:13:09,040
here to get uh potentially like remote

358
00:13:09,040 --> 00:13:11,680
co-execution or something like that

359
00:13:11,680 --> 00:13:14,160
and so that's exactly what i did

360
00:13:14,160 --> 00:13:16,800
in a house called house of blindness

361
00:13:16,800 --> 00:13:19,519
basically it's kind of taking advantage

362
00:13:19,519 --> 00:13:21,120
of this dl-fini

363
00:13:21,120 --> 00:13:23,440
function to call arbitrary functions

364
00:13:23,440 --> 00:13:26,000
without ever needing memory leaks

365
00:13:26,000 --> 00:13:27,680
now the way it works is you take a

366
00:13:27,680 --> 00:13:29,040
standard vulnerability remember houses

367
00:13:29,040 --> 00:13:30,880
turn vulnerabilities into exploits and

368
00:13:30,880 --> 00:13:32,639
the vulnerability that house of

369
00:13:32,639 --> 00:13:34,880
blindness takes is out of bounds heap

370
00:13:34,880 --> 00:13:36,560
right what it does is it takes the

371
00:13:36,560 --> 00:13:38,079
out-of-bound heap right and turns that

372
00:13:38,079 --> 00:13:39,600
into leakless function arbitrary

373
00:13:39,600 --> 00:13:41,199
co-execution which means you can call

374
00:13:41,199 --> 00:13:42,639
whatever function you want without

375
00:13:42,639 --> 00:13:44,800
needing to know aslr base or any of

376
00:13:44,800 --> 00:13:46,639
those things and so it's kind of like a

377
00:13:46,639 --> 00:13:49,040
new lickless take on the classic feeney

378
00:13:49,040 --> 00:13:52,079
array exploit which is since kind of

379
00:13:52,079 --> 00:13:53,760
a little deprecated it's not not very

380
00:13:53,760 --> 00:13:55,680
useful anymore

381
00:13:55,680 --> 00:13:57,279
anyways it's all written in this little

382
00:13:57,279 --> 00:13:59,120
document right here it's linked i'll

383
00:13:59,120 --> 00:14:00,079
post a slide to the end if you want to

384
00:14:00,079 --> 00:14:01,120
check it out

385
00:14:01,120 --> 00:14:02,399
but i'd like to read you guys a little

386
00:14:02,399 --> 00:14:03,680
synopsis of what house of blindness is

387
00:14:03,680 --> 00:14:04,560
about

388
00:14:04,560 --> 00:14:06,320
house of blindness isn't a conventional

389
00:14:06,320 --> 00:14:08,639
override finian array style exploit

390
00:14:08,639 --> 00:14:10,560
rather by a few clever partial overrides

391
00:14:10,560 --> 00:14:12,240
and interesting runtime dynamic loader

392
00:14:12,240 --> 00:14:14,160
properties we can trick the runtime

393
00:14:14,160 --> 00:14:16,079
loader into miscalculating where feni is

394
00:14:16,079 --> 00:14:18,079
in memory the only primitive we need is

395
00:14:18,079 --> 00:14:19,839
relative right did i mention we can do

396
00:14:19,839 --> 00:14:21,920
this completely leaklessly so basically

397
00:14:21,920 --> 00:14:23,279
we can call arbitrary functions without

398
00:14:23,279 --> 00:14:25,120
memory leaks and

399
00:14:25,120 --> 00:14:27,279
how exactly does this work

400
00:14:27,279 --> 00:14:28,720
well i'll first have to tell you

401
00:14:28,720 --> 00:14:31,040
something about link maps link maps are

402
00:14:31,040 --> 00:14:33,360
basically information about a shared

403
00:14:33,360 --> 00:14:34,480
object

404
00:14:34,480 --> 00:14:36,240
those shared objects could include lib c

405
00:14:36,240 --> 00:14:38,560
the runtime loader the program stuff

406
00:14:38,560 --> 00:14:40,880
like that has some important fields for

407
00:14:40,880 --> 00:14:42,959
example l address is where that share

408
00:14:42,959 --> 00:14:45,279
libraries loaded in memory but also has

409
00:14:45,279 --> 00:14:48,079
l info which is uh where all the data

410
00:14:48,079 --> 00:14:50,160
structures about that link map is for

411
00:14:50,160 --> 00:14:51,760
example the location of the global

412
00:14:51,760 --> 00:14:54,000
offset table location of the destructor

413
00:14:54,000 --> 00:14:56,320
functions dt fini is there and there's

414
00:14:56,320 --> 00:14:57,680
also things like the the constructor

415
00:14:57,680 --> 00:14:59,519
functions and all that stuff it's all

416
00:14:59,519 --> 00:15:01,839
where all the information about the

417
00:15:01,839 --> 00:15:04,160
shared object is

418
00:15:04,160 --> 00:15:06,000
and so you might think hey if we can

419
00:15:06,000 --> 00:15:08,160
somehow corrupt this link map with a

420
00:15:08,160 --> 00:15:10,000
something like an out of bounds right

421
00:15:10,000 --> 00:15:11,600
vulnerability maybe we can get some

422
00:15:11,600 --> 00:15:13,040
interesting behavior out of it and

423
00:15:13,040 --> 00:15:14,639
that's exactly what house of blindness

424
00:15:14,639 --> 00:15:16,480
did

425
00:15:16,480 --> 00:15:18,399
basically we caused the feni function to

426
00:15:18,399 --> 00:15:20,399
be miscalculated and this is done

427
00:15:20,399 --> 00:15:21,760
through something called an lsb

428
00:15:21,760 --> 00:15:23,839
overwrite in a normal link map as you

429
00:15:23,839 --> 00:15:25,600
can see in this diagram generally a

430
00:15:25,600 --> 00:15:26,399
ladder

431
00:15:26,399 --> 00:15:28,720
points at where the shared object is in

432
00:15:28,720 --> 00:15:29,680
memory

433
00:15:29,680 --> 00:15:32,480
and then it uses the dthini array points

434
00:15:32,480 --> 00:15:34,959
to some offset from that

435
00:15:34,959 --> 00:15:37,120
start address this l adder and so for

436
00:15:37,120 --> 00:15:39,839
example in this program the dt fini

437
00:15:39,839 --> 00:15:42,560
function would be located at the start

438
00:15:42,560 --> 00:15:44,440
of the program plus

439
00:15:44,440 --> 00:15:46,560
0x451 bytes

440
00:15:46,560 --> 00:15:48,639
now by using our out of bounds right we

441
00:15:48,639 --> 00:15:50,880
may be able to corrupt this link map and

442
00:15:50,880 --> 00:15:52,839
cause the dtfini function to be

443
00:15:52,839 --> 00:15:55,279
miscalculated in this specific case

444
00:15:55,279 --> 00:15:57,440
instead of using an lsb overwrite we can

445
00:15:57,440 --> 00:15:59,680
cause dt feeney to point at an entirely

446
00:15:59,680 --> 00:16:02,560
different dynamic entry in this case dt

447
00:16:02,560 --> 00:16:03,600
debug

448
00:16:03,600 --> 00:16:06,000
now dt debug is useful because instead

449
00:16:06,000 --> 00:16:08,480
of having an offset our debug is an

450
00:16:08,480 --> 00:16:10,399
actual pointer and so what you end up

451
00:16:10,399 --> 00:16:12,320
doing is you end up adding this pointer

452
00:16:12,320 --> 00:16:13,759
to the start of the program base which

453
00:16:13,759 --> 00:16:15,440
as you know is not a valid pointer

454
00:16:15,440 --> 00:16:17,680
however we can fix this by overriding

455
00:16:17,680 --> 00:16:20,160
the l adder with some arbitrary offset

456
00:16:20,160 --> 00:16:22,320
we can basically call any function from

457
00:16:22,320 --> 00:16:24,160
an offset from our debug

458
00:16:24,160 --> 00:16:26,560
now our debug is located in the same

459
00:16:26,560 --> 00:16:29,199
roughly the same memory region as libc

460
00:16:29,199 --> 00:16:31,440
it's adjacent in memory which means that

461
00:16:31,440 --> 00:16:33,600
we could call any libc function by

462
00:16:33,600 --> 00:16:35,839
specifying our offset in el adder and

463
00:16:35,839 --> 00:16:37,519
then calling that

464
00:16:37,519 --> 00:16:40,079
using house of blindness so we can

465
00:16:40,079 --> 00:16:41,759
arbitrarily call any lipsy function

466
00:16:41,759 --> 00:16:43,440
which is very useful

467
00:16:43,440 --> 00:16:44,880
and i thought this was pretty cool a

468
00:16:44,880 --> 00:16:47,120
little curious um

469
00:16:47,120 --> 00:16:48,399
but that was just the tip of the iceberg

470
00:16:48,399 --> 00:16:50,639
and i didn't know it at the time i had

471
00:16:50,639 --> 00:16:52,480
compiled all this research into this

472
00:16:52,480 --> 00:16:54,320
about dl-fini and house of blindness and

473
00:16:54,320 --> 00:16:56,000
all that it's this document called

474
00:16:56,000 --> 00:16:58,560
issues in exit town i didn't really

475
00:16:58,560 --> 00:16:59,759
publish it or anything i just kind of

476
00:16:59,759 --> 00:17:01,440
shared around my ctf friends and got

477
00:17:01,440 --> 00:17:03,440
some feedback on it but it really was

478
00:17:03,440 --> 00:17:04,720
the tip of the iceberg which you can do

479
00:17:04,720 --> 00:17:06,240
with the runtime loader

480
00:17:06,240 --> 00:17:08,240
so let's keep going

481
00:17:08,240 --> 00:17:08,959
so

482
00:17:08,959 --> 00:17:11,520
even now i had thought that you know ah

483
00:17:11,520 --> 00:17:13,359
i was done i finally got my house

484
00:17:13,359 --> 00:17:15,359
mission complete right

485
00:17:15,359 --> 00:17:19,039
but dice ctf 2022 was rolling around i

486
00:17:19,039 --> 00:17:20,559
decided there probably was more to be

487
00:17:20,559 --> 00:17:21,679
found

488
00:17:21,679 --> 00:17:23,359
and so that's exactly what i did i

489
00:17:23,359 --> 00:17:26,720
decided to go back in and do some more

490
00:17:26,720 --> 00:17:28,720
in this case i created the nightmare ctf

491
00:17:28,720 --> 00:17:30,559
challenge which basically instead of

492
00:17:30,559 --> 00:17:31,919
giving you the out of bounds and the

493
00:17:31,919 --> 00:17:34,320
heap required for house of blindness

494
00:17:34,320 --> 00:17:36,640
instead you got one bite out of bound

495
00:17:36,640 --> 00:17:39,840
right and a ton of security protections

496
00:17:39,840 --> 00:17:41,440
the most important security protection

497
00:17:41,440 --> 00:17:44,320
here is no leak this means that you have

498
00:17:44,320 --> 00:17:46,160
absolutely no memory leak and you don't

499
00:17:46,160 --> 00:17:48,720
know where any addresses are in memory

500
00:17:48,720 --> 00:17:50,400
and so it can be a lot more complicated

501
00:17:50,400 --> 00:17:52,240
to exploit like this

502
00:17:52,240 --> 00:17:53,440
but the program itself we'll talk about

503
00:17:53,440 --> 00:17:55,120
that more later but the program itself

504
00:17:55,120 --> 00:17:57,600
is pretty simple if you look at the code

505
00:17:57,600 --> 00:17:59,200
it reads an offset and a byte from the

506
00:17:59,200 --> 00:18:01,360
user and then it

507
00:18:01,360 --> 00:18:03,120
does the right it writes that byte to

508
00:18:03,120 --> 00:18:05,840
that offset for some allocated chunk

509
00:18:05,840 --> 00:18:08,000
after that it exits

510
00:18:08,000 --> 00:18:09,919
and so it's that seems like a very

511
00:18:09,919 --> 00:18:12,480
simple program but it actually can get

512
00:18:12,480 --> 00:18:14,720
pretty complicated and

513
00:18:14,720 --> 00:18:16,400
we can learn a lot about the runtime

514
00:18:16,400 --> 00:18:19,440
loader by going through this program

515
00:18:19,440 --> 00:18:21,679
but first let's talk about the

516
00:18:21,679 --> 00:18:23,280
security protections

517
00:18:23,280 --> 00:18:25,039
the first security restriction and by

518
00:18:25,039 --> 00:18:27,360
far the most severe and restrictive

519
00:18:27,360 --> 00:18:29,679
is there is no two-way communication

520
00:18:29,679 --> 00:18:31,520
although you can communicate the program

521
00:18:31,520 --> 00:18:33,840
the program cannot communicate with you

522
00:18:33,840 --> 00:18:35,600
this means that there's absolutely no

523
00:18:35,600 --> 00:18:39,520
way to leak aslr base or somehow

524
00:18:39,520 --> 00:18:41,200
figure out a memory leak or something

525
00:18:41,200 --> 00:18:42,559
it's just not possible because the

526
00:18:42,559 --> 00:18:43,760
program cannot communicate that

527
00:18:43,760 --> 00:18:46,240
information to you this means the entire

528
00:18:46,240 --> 00:18:48,240
time you are working blind you don't

529
00:18:48,240 --> 00:18:49,840
know where any pointers are in memory

530
00:18:49,840 --> 00:18:51,360
but you still have to somehow build a

531
00:18:51,360 --> 00:18:52,559
rock chain

532
00:18:52,559 --> 00:18:55,760
and we'll talk about this more later but

533
00:18:55,760 --> 00:18:57,280
the issue is that there's really isn't a

534
00:18:57,280 --> 00:18:58,799
current known way to build a rock chain

535
00:18:58,799 --> 00:19:01,200
without memory leak by definition you

536
00:19:01,200 --> 00:19:02,640
need to be able to write arbitrary

537
00:19:02,640 --> 00:19:04,640
pointers as sort of a list right to

538
00:19:04,640 --> 00:19:06,720
create a rock chain but that requires

539
00:19:06,720 --> 00:19:08,160
knowing memory leaks and since we don't

540
00:19:08,160 --> 00:19:09,280
know any memory leaks here because

541
00:19:09,280 --> 00:19:11,120
there's no two-way communication it's

542
00:19:11,120 --> 00:19:12,320
kind of a bust

543
00:19:12,320 --> 00:19:14,320
however we will be able to beat this but

544
00:19:14,320 --> 00:19:15,919
we'll talk about that later

545
00:19:15,919 --> 00:19:17,440
the second restriction built on the

546
00:19:17,440 --> 00:19:18,400
first

547
00:19:18,400 --> 00:19:20,720
uh it's preventing brew force and a lot

548
00:19:20,720 --> 00:19:22,320
of blind challenges where the users

549
00:19:22,320 --> 00:19:24,080
don't know memory leaks and can't defeat

550
00:19:24,080 --> 00:19:26,960
aslr often you have to use some brute

551
00:19:26,960 --> 00:19:28,720
force generally this brute force is

552
00:19:28,720 --> 00:19:31,120
either 4 to 12 bits for example the

553
00:19:31,120 --> 00:19:33,440
unsorted attack and house of corrosion

554
00:19:33,440 --> 00:19:35,440
both require at minimum guessing 4 bits

555
00:19:35,440 --> 00:19:37,440
of entropy and so this is a brute force

556
00:19:37,440 --> 00:19:38,480
that could potentially cause your

557
00:19:38,480 --> 00:19:40,400
program to fail and if it's like four

558
00:19:40,400 --> 00:19:42,720
bits you know 116 chance so it can get

559
00:19:42,720 --> 00:19:44,720
messy right

560
00:19:44,720 --> 00:19:46,960
so uh no brute force which makes this

561
00:19:46,960 --> 00:19:49,520
program are explaining a lot harder

562
00:19:49,520 --> 00:19:52,320
finally there's a sandbox using setcomp

563
00:19:52,320 --> 00:19:54,880
it prevents you it really disallows

564
00:19:54,880 --> 00:19:56,480
everything except the bare minimum to

565
00:19:56,480 --> 00:19:57,840
read the flag and get the program

566
00:19:57,840 --> 00:20:00,799
running and so uh you can't really just

567
00:20:00,799 --> 00:20:02,240
you know just call system and get a

568
00:20:02,240 --> 00:20:03,760
shell or something this is supposed to

569
00:20:03,760 --> 00:20:05,120
be kind of like emulate a sandbox

570
00:20:05,120 --> 00:20:07,200
process which is like you know supposed

571
00:20:07,200 --> 00:20:09,280
to just do computation right

572
00:20:09,280 --> 00:20:11,840
and so uh it's it sounds like a little

573
00:20:11,840 --> 00:20:13,919
difficult right because um how are you

574
00:20:13,919 --> 00:20:16,400
supposed to get a rough chain with all

575
00:20:16,400 --> 00:20:18,799
these protections but it's possible and

576
00:20:18,799 --> 00:20:20,000
to do it we're going to be using three

577
00:20:20,000 --> 00:20:22,240
new houses all leveraging the runtime

578
00:20:22,240 --> 00:20:24,720
loader and get these primitives

579
00:20:24,720 --> 00:20:26,400
uh and the last primitive will achieve

580
00:20:26,400 --> 00:20:28,720
something that has never been

581
00:20:28,720 --> 00:20:30,480
gotten before the house which will allow

582
00:20:30,480 --> 00:20:32,240
us to finally get rob

583
00:20:32,240 --> 00:20:34,080
so let's get right into it with our

584
00:20:34,080 --> 00:20:35,760
preliminary analysis

585
00:20:35,760 --> 00:20:37,600
how do we get more bytes

586
00:20:37,600 --> 00:20:39,840
well going from one byte right to

587
00:20:39,840 --> 00:20:41,360
infinite byte rights is probably the

588
00:20:41,360 --> 00:20:43,440
move here as you could imagine encoding

589
00:20:43,440 --> 00:20:44,799
an entire rock chain and remote

590
00:20:44,799 --> 00:20:48,400
coexecution cycle with um just one bite

591
00:20:48,400 --> 00:20:49,840
isn't really possible it's only eight

592
00:20:49,840 --> 00:20:51,840
bits of entropy you can't encode an

593
00:20:51,840 --> 00:20:54,480
entire rock chain with that so our first

594
00:20:54,480 --> 00:20:56,720
uh you know course of action should

595
00:20:56,720 --> 00:20:57,679
probably

596
00:20:57,679 --> 00:21:00,240
be to get more bite rights and this was

597
00:21:00,240 --> 00:21:02,080
sort of a warm-up for the users it's

598
00:21:02,080 --> 00:21:04,000
supposed to show them a little bit about

599
00:21:04,000 --> 00:21:06,080
the runtime loader and kind of get them

600
00:21:06,080 --> 00:21:07,520
warmed up with it

601
00:21:07,520 --> 00:21:08,640
but it's worth noting it's very

602
00:21:08,640 --> 00:21:10,400
contrived it's it's an interesting

603
00:21:10,400 --> 00:21:11,520
puzzle but doesn't have any real world

604
00:21:11,520 --> 00:21:12,799
bearing there's not really a time where

605
00:21:12,799 --> 00:21:14,720
you're supposed to you know go from one

606
00:21:14,720 --> 00:21:16,000
bite right to infinite bite rights in

607
00:21:16,000 --> 00:21:17,440
the real world it's not really makes

608
00:21:17,440 --> 00:21:18,799
sense but i think it was a good it's a

609
00:21:18,799 --> 00:21:20,480
good puzzle for competitors to get used

610
00:21:20,480 --> 00:21:22,640
to the runtime loader

611
00:21:22,640 --> 00:21:24,320
and so

612
00:21:24,320 --> 00:21:26,159
it can't you can kind of ask okay so how

613
00:21:26,159 --> 00:21:28,159
do we get infinite by rights and the

614
00:21:28,159 --> 00:21:30,240
first course of action is to choose a

615
00:21:30,240 --> 00:21:32,000
surface to attack

616
00:21:32,000 --> 00:21:33,679
but as you look at the program you might

617
00:21:33,679 --> 00:21:35,840
notice there's not really any attack

618
00:21:35,840 --> 00:21:38,640
surfaces here every function in the code

619
00:21:38,640 --> 00:21:41,600
is um all just syscalls the read is a

620
00:21:41,600 --> 00:21:43,600
syscall right is this called not like

621
00:21:43,600 --> 00:21:44,799
happens before so that's not really

622
00:21:44,799 --> 00:21:47,200
relevant but the read write and exit are

623
00:21:47,200 --> 00:21:49,840
all syscalls be warned the exit here is

624
00:21:49,840 --> 00:21:51,280
not the exit we've been talking about

625
00:21:51,280 --> 00:21:53,360
with the you know calling exit handlers

626
00:21:53,360 --> 00:21:55,120
but rather it's just a thin wrapper over

627
00:21:55,120 --> 00:21:58,000
the exit syscall so there's not really

628
00:21:58,000 --> 00:21:59,520
anywhere where our one byte write could

629
00:21:59,520 --> 00:22:01,039
be useful

630
00:22:01,039 --> 00:22:03,200
but there actually is and it's in

631
00:22:03,200 --> 00:22:05,360
between the lines it's complexity that's

632
00:22:05,360 --> 00:22:07,039
out of sight and that's the runtime

633
00:22:07,039 --> 00:22:08,400
letter once again

634
00:22:08,400 --> 00:22:11,760
basically symbols such as you know write

635
00:22:11,760 --> 00:22:14,400
exit read malloc are all being looked up

636
00:22:14,400 --> 00:22:16,559
at runtime the program needs to know

637
00:22:16,559 --> 00:22:18,000
where these are located in memory so

638
00:22:18,000 --> 00:22:19,520
they can call these functions like write

639
00:22:19,520 --> 00:22:21,679
like read like right like exit and so

640
00:22:21,679 --> 00:22:23,520
you have to call the runtime loader to

641
00:22:23,520 --> 00:22:25,200
look up these look up these symbols for

642
00:22:25,200 --> 00:22:27,200
you the function that does this is

643
00:22:27,200 --> 00:22:30,080
called dl fix up and it's quite a

644
00:22:30,080 --> 00:22:32,000
complicated process actually and it

645
00:22:32,000 --> 00:22:34,080
could be a very useful target for a one

646
00:22:34,080 --> 00:22:35,919
byte write we could potentially use the

647
00:22:35,919 --> 00:22:38,880
one byte right on the state of dl fix up

648
00:22:38,880 --> 00:22:40,799
to get infinite by rights

649
00:22:40,799 --> 00:22:43,200
and so let's try that

650
00:22:43,200 --> 00:22:45,760
but first we have to establish that if

651
00:22:45,760 --> 00:22:48,159
exit doesn't get called you get infinite

652
00:22:48,159 --> 00:22:50,720
byte rights this is actually due to

653
00:22:50,720 --> 00:22:52,559
technicality it's a it's a because of

654
00:22:52,559 --> 00:22:54,720
gcc optimizations and function orders as

655
00:22:54,720 --> 00:22:56,159
again this is a little contrived it's

656
00:22:56,159 --> 00:22:57,840
not actually useful in the real world

657
00:22:57,840 --> 00:22:59,600
but if x doesn't get called you'll get

658
00:22:59,600 --> 00:23:02,080
infinite byte rights and so the question

659
00:23:02,080 --> 00:23:03,600
is how do we prevent exit from getting

660
00:23:03,600 --> 00:23:06,559
called by modifying the state of dl fix

661
00:23:06,559 --> 00:23:07,440
up

662
00:23:07,440 --> 00:23:08,400
well

663
00:23:08,400 --> 00:23:10,960
the the way i did anyways was by doing

664
00:23:10,960 --> 00:23:14,000
an lsb overwrite on the l adder of the

665
00:23:14,000 --> 00:23:15,440
link map

666
00:23:15,440 --> 00:23:17,280
now it sounds a little weird and

667
00:23:17,280 --> 00:23:19,039
i guess it kind of is right

668
00:23:19,039 --> 00:23:20,320
but um

669
00:23:20,320 --> 00:23:22,799
you can kind of learn on why uh exit

670
00:23:22,799 --> 00:23:24,320
doesn't if exit doesn't get called that

671
00:23:24,320 --> 00:23:26,080
causes infinite bite rights on on the

672
00:23:26,080 --> 00:23:28,400
blog i linked earlier uh it goes into

673
00:23:28,400 --> 00:23:30,640
detail line by line breakdown all that

674
00:23:30,640 --> 00:23:31,840
but for now let's just take it as a

675
00:23:31,840 --> 00:23:34,240
given so to do this lsb overwrite on el

676
00:23:34,240 --> 00:23:36,480
adder what we'll do is we'll modify the

677
00:23:36,480 --> 00:23:38,080
least significant byte which basically

678
00:23:38,080 --> 00:23:40,080
is like the same as adding a small

679
00:23:40,080 --> 00:23:42,799
constant to l adder this causes the got

680
00:23:42,799 --> 00:23:45,520
location of right to be miscalculated

681
00:23:45,520 --> 00:23:47,919
this this instead of writing the right

682
00:23:47,919 --> 00:23:50,159
function to the right location in the

683
00:23:50,159 --> 00:23:52,640
global offset table we'll instead write

684
00:23:52,640 --> 00:23:54,000
the right function and that's a little

685
00:23:54,000 --> 00:23:55,760
confusing because you know same name but

686
00:23:55,760 --> 00:23:57,919
we'll write the right function to exit

687
00:23:57,919 --> 00:23:59,919
in the global offset table this means

688
00:23:59,919 --> 00:24:01,279
that exit will not get called and we'll

689
00:24:01,279 --> 00:24:03,360
call right instead of exit that way

690
00:24:03,360 --> 00:24:06,559
we'll end up looping the program

691
00:24:06,559 --> 00:24:08,640
all right that's super cool but what do

692
00:24:08,640 --> 00:24:10,720
we do once we have infinite by rights

693
00:24:10,720 --> 00:24:13,039
well we get lickless address call of

694
00:24:13,039 --> 00:24:14,400
course we're going to be calling

695
00:24:14,400 --> 00:24:16,799
arbitrary functions using dlfixup a

696
00:24:16,799 --> 00:24:19,120
second time this is actually a new house

697
00:24:19,120 --> 00:24:21,520
it's called house of fix-up uh

698
00:24:21,520 --> 00:24:23,200
i don't know that's the side name i

699
00:24:23,200 --> 00:24:24,880
chose but um it's a little more

700
00:24:24,880 --> 00:24:26,880
complicated than house of blindness but

701
00:24:26,880 --> 00:24:28,640
it uses that core structure of using our

702
00:24:28,640 --> 00:24:31,600
debug to forge fake entries of the

703
00:24:31,600 --> 00:24:33,760
dynamics section for example the two

704
00:24:33,760 --> 00:24:35,279
entries in the dot dynamics section that

705
00:24:35,279 --> 00:24:38,320
we're forging here is dt sim tab and dt

706
00:24:38,320 --> 00:24:41,279
string tab these two entries specify

707
00:24:41,279 --> 00:24:43,120
information about how symbols should be

708
00:24:43,120 --> 00:24:46,080
looked up for example it'll tell you uh

709
00:24:46,080 --> 00:24:49,000
the name of the of the right function is

710
00:24:49,000 --> 00:24:50,559
w-r-i-t-e

711
00:24:50,559 --> 00:24:52,799
and it'll also tell you like uh other

712
00:24:52,799 --> 00:24:54,559
information for deal fix-up to figure

713
00:24:54,559 --> 00:24:56,880
out where right is located in memory by

714
00:24:56,880 --> 00:24:59,360
forging this we can cause deal up to

715
00:24:59,360 --> 00:25:00,400
miscalculate

716
00:25:00,400 --> 00:25:02,320
where functions like write like read

717
00:25:02,320 --> 00:25:05,120
like exit are located in memory and in

718
00:25:05,120 --> 00:25:06,799
doing that we can use our debug to kind

719
00:25:06,799 --> 00:25:08,480
of make those fake

720
00:25:08,480 --> 00:25:10,480
symbols tables or string tables and so

721
00:25:10,480 --> 00:25:11,760
it could be pretty useful as you can see

722
00:25:11,760 --> 00:25:14,240
a diagram of how this is modified uh

723
00:25:14,240 --> 00:25:16,000
it's not super important to talk but um

724
00:25:16,000 --> 00:25:17,440
basically we can call arbitrary

725
00:25:17,440 --> 00:25:19,440
functions using fix up that's our second

726
00:25:19,440 --> 00:25:21,440
usage of fix of dfx as you can see it's

727
00:25:21,440 --> 00:25:24,000
a pretty cool function

728
00:25:24,000 --> 00:25:26,640
all right but from here you might uh oh

729
00:25:26,640 --> 00:25:29,679
what we also do is we we used house of

730
00:25:29,679 --> 00:25:31,600
fix up to get house of blindness it's

731
00:25:31,600 --> 00:25:33,760
worth noting that house of blindness is

732
00:25:33,760 --> 00:25:35,679
significantly more useful than house of

733
00:25:35,679 --> 00:25:37,200
fix up this is because house of

734
00:25:37,200 --> 00:25:39,120
blindness allows you to still call any

735
00:25:39,120 --> 00:25:40,640
arbitrary function

736
00:25:40,640 --> 00:25:42,960
but it also lets you specify a parameter

737
00:25:42,960 --> 00:25:44,640
for that arbitrary function well also

738
00:25:44,640 --> 00:25:46,640
fixed up is just a blank call it doesn't

739
00:25:46,640 --> 00:25:48,000
let you specify any arguments for that

740
00:25:48,000 --> 00:25:49,679
function so as you can imagine it's more

741
00:25:49,679 --> 00:25:51,440
useful to specify an argument for any

742
00:25:51,440 --> 00:25:53,200
arbitrary function you're calling

743
00:25:53,200 --> 00:25:55,360
and so we do this we migrate from house

744
00:25:55,360 --> 00:25:57,039
to fix up the house of blindness by

745
00:25:57,039 --> 00:26:00,240
calling dl feni using house of fix up

746
00:26:00,240 --> 00:26:02,480
remember uh house of blindness is only

747
00:26:02,480 --> 00:26:05,440
called with dlfini so if we call dilfini

748
00:26:05,440 --> 00:26:06,960
we can start using house of blindness

749
00:26:06,960 --> 00:26:09,120
and we do that with a relatively simple

750
00:26:09,120 --> 00:26:12,320
process you know using house of fix up

751
00:26:12,320 --> 00:26:14,400
all right now that we have arbitrary

752
00:26:14,400 --> 00:26:16,640
calling leaklessly what do we do from

753
00:26:16,640 --> 00:26:18,640
here because yeah we can call functions

754
00:26:18,640 --> 00:26:20,240
that's cool and all and we've escalated

755
00:26:20,240 --> 00:26:21,840
our vulnerability from just an out of

756
00:26:21,840 --> 00:26:24,720
bounds right to a calling functions but

757
00:26:24,720 --> 00:26:26,080
we need drop from here if we want to do

758
00:26:26,080 --> 00:26:28,159
anything like reading a flag from memory

759
00:26:28,159 --> 00:26:31,360
and the issue is is that rop needs leaks

760
00:26:31,360 --> 00:26:34,159
it's in order to make a rock chain you

761
00:26:34,159 --> 00:26:35,760
need to specify the functions you're

762
00:26:35,760 --> 00:26:37,279
going to call or return to in the rock

763
00:26:37,279 --> 00:26:39,760
chain right however writing these

764
00:26:39,760 --> 00:26:41,679
functions out in memory is impossible

765
00:26:41,679 --> 00:26:43,840
unless you have memory leak so what do

766
00:26:43,840 --> 00:26:44,960
we do

767
00:26:44,960 --> 00:26:46,799
well we'll need a man on the inside

768
00:26:46,799 --> 00:26:48,480
we'll need someone inside the program or

769
00:26:48,480 --> 00:26:50,640
a piece of code in the program which can

770
00:26:50,640 --> 00:26:52,880
write these addresses for us

771
00:26:52,880 --> 00:26:55,039
so we kind of need this rop writer right

772
00:26:55,039 --> 00:26:56,799
we need we need someone who can write

773
00:26:56,799 --> 00:26:58,880
arbitrary uh pointers to arbitrary

774
00:26:58,880 --> 00:27:00,640
locations in memory

775
00:27:00,640 --> 00:27:02,880
so what is it going to be how are we

776
00:27:02,880 --> 00:27:04,799
going to get a rock writer how are we

777
00:27:04,799 --> 00:27:06,080
going to write arbitrary pointers to

778
00:27:06,080 --> 00:27:07,840
arbitrary locations

779
00:27:07,840 --> 00:27:10,000
the answer is of course

780
00:27:10,000 --> 00:27:11,919
dl fix up for the third time we're using

781
00:27:11,919 --> 00:27:13,760
dl fix up again it's a great attack

782
00:27:13,760 --> 00:27:14,799
surface

783
00:27:14,799 --> 00:27:16,880
and what we're going to do is it's

784
00:27:16,880 --> 00:27:19,279
actually super cool how this is done

785
00:27:19,279 --> 00:27:22,320
basically we're gonna say it's because

786
00:27:22,320 --> 00:27:23,440
basically a

787
00:27:23,440 --> 00:27:25,200
deal fix up is a three-step process

788
00:27:25,200 --> 00:27:27,679
right what it does is it looks up a

789
00:27:27,679 --> 00:27:29,919
symbol in libsy and then it looks up

790
00:27:29,919 --> 00:27:31,520
where that symbol should be written in

791
00:27:31,520 --> 00:27:32,720
the got

792
00:27:32,720 --> 00:27:34,000
and then it writes the symbol to the

793
00:27:34,000 --> 00:27:35,919
g-o-t so it's a three-step process the

794
00:27:35,919 --> 00:27:37,679
lookup and then it does the where it

795
00:27:37,679 --> 00:27:39,200
should be written and then it actually

796
00:27:39,200 --> 00:27:41,120
writes right so three steps

797
00:27:41,120 --> 00:27:43,679
um and then you kind of say okay

798
00:27:43,679 --> 00:27:46,799
well how does dl fix up know where for

799
00:27:46,799 --> 00:27:49,120
example exit is in libsy and how does it

800
00:27:49,120 --> 00:27:52,240
how does dl fix up know where exact uh

801
00:27:52,240 --> 00:27:54,559
where exits should be written in the got

802
00:27:54,559 --> 00:27:55,840
and these are two very good questions

803
00:27:55,840 --> 00:27:57,600
right how does the deal fix up know that

804
00:27:57,600 --> 00:27:59,840
and by asking that question you can end

805
00:27:59,840 --> 00:28:01,520
up getting arbitrary symbols to

806
00:28:01,520 --> 00:28:02,960
arbitrary locations because what you can

807
00:28:02,960 --> 00:28:05,520
do is you can trick dl fix up into

808
00:28:05,520 --> 00:28:07,679
writing the wrong symbol to the wrong

809
00:28:07,679 --> 00:28:09,360
location and just like that you can

810
00:28:09,360 --> 00:28:11,520
write arbitrary pointers and so it's

811
00:28:11,520 --> 00:28:12,880
super cool because you can kind of you

812
00:28:12,880 --> 00:28:15,520
know use that to build a rock chain

813
00:28:15,520 --> 00:28:17,919
however this is a lot easier said than

814
00:28:17,919 --> 00:28:19,600
done it required an absolutely hellish

815
00:28:19,600 --> 00:28:21,039
amount of legwork

816
00:28:21,039 --> 00:28:22,559
it required not only several

817
00:28:22,559 --> 00:28:25,039
supplementary houses and exploits that

818
00:28:25,039 --> 00:28:27,279
are including but not limited to

819
00:28:27,279 --> 00:28:28,880
global max fast

820
00:28:28,880 --> 00:28:30,640
for uncontrolled pointer right i o

821
00:28:30,640 --> 00:28:32,399
string overflow and iowa string finish

822
00:28:32,399 --> 00:28:34,399
for malik free primitives uh credits to

823
00:28:34,399 --> 00:28:36,720
not the ghost slash robert chen for that

824
00:28:36,720 --> 00:28:39,760
uh double freeze using the i o save base

825
00:28:39,760 --> 00:28:41,840
and its associated functions openmem

826
00:28:41,840 --> 00:28:43,840
stream to spray pointers into a chunk

827
00:28:43,840 --> 00:28:45,840
among other lesser primitives in houses

828
00:28:45,840 --> 00:28:47,760
it's a complicated process in fact it

829
00:28:47,760 --> 00:28:49,120
could probably be an entire presentation

830
00:28:49,120 --> 00:28:51,600
by itself and so uh the entire process

831
00:28:51,600 --> 00:28:53,120
is of course documented on the blog post

832
00:28:53,120 --> 00:28:55,279
i mentioned earlier um but it could

833
00:28:55,279 --> 00:28:57,039
definitely be an entire presentation on

834
00:28:57,039 --> 00:29:00,640
itself anyways this construction of uh

835
00:29:00,640 --> 00:29:02,799
you know tricking dl fix up with this

836
00:29:02,799 --> 00:29:04,960
fake link map or crafting uh using all

837
00:29:04,960 --> 00:29:06,799
these different supplementary houses and

838
00:29:06,799 --> 00:29:08,399
stuff actually ends up in a very

839
00:29:08,399 --> 00:29:10,080
beautiful construction and that

840
00:29:10,080 --> 00:29:11,360
construction is

841
00:29:11,360 --> 00:29:12,399
house of sight

842
00:29:12,399 --> 00:29:13,760
i see a diagram of what that

843
00:29:13,760 --> 00:29:15,360
construction looks like

844
00:29:15,360 --> 00:29:17,520
basically we build a fake link map using

845
00:29:17,520 --> 00:29:19,200
all those different um you know

846
00:29:19,200 --> 00:29:20,559
supplementary houses and exploits i

847
00:29:20,559 --> 00:29:22,640
mentioned and what we end up with is

848
00:29:22,640 --> 00:29:25,520
this construction which when dl fix up

849
00:29:25,520 --> 00:29:28,159
is called on ends up writing arbitrary

850
00:29:28,159 --> 00:29:30,559
pointers to arbitrary locations it's a

851
00:29:30,559 --> 00:29:32,960
two parameter system so we specify where

852
00:29:32,960 --> 00:29:34,240
we want to write the pointer and then

853
00:29:34,240 --> 00:29:36,000
what we want to write by shifting around

854
00:29:36,000 --> 00:29:38,000
two values we shift around the where

855
00:29:38,000 --> 00:29:40,000
parameter to to

856
00:29:40,000 --> 00:29:41,840
adjust where exactly that that pointer

857
00:29:41,840 --> 00:29:44,159
gets written and then we can adjust the

858
00:29:44,159 --> 00:29:46,320
what parameter to uh to

859
00:29:46,320 --> 00:29:48,480
adjust what pointer gets written but

860
00:29:48,480 --> 00:29:50,640
like that we can build a rock chain the

861
00:29:50,640 --> 00:29:52,080
process of actually calling this rock

862
00:29:52,080 --> 00:29:53,200
chain is

863
00:29:53,200 --> 00:29:55,919
hell on its own but um it's documented

864
00:29:55,919 --> 00:29:57,279
in the blog post if that's the technical

865
00:29:57,279 --> 00:29:58,880
detail you're interested in

866
00:29:58,880 --> 00:30:01,600
but the point is is that house or all

867
00:30:01,600 --> 00:30:03,520
these houses using the runtime loader

868
00:30:03,520 --> 00:30:05,679
are very cool and i talk about this in

869
00:30:05,679 --> 00:30:07,440
the presentation more or the

870
00:30:07,440 --> 00:30:09,679
blog post more but the power of offsets

871
00:30:09,679 --> 00:30:12,480
is really shown here because uh because

872
00:30:12,480 --> 00:30:14,880
the the deal fix up and all the runtime

873
00:30:14,880 --> 00:30:17,279
loaders operate on sort of offsets you

874
00:30:17,279 --> 00:30:19,039
don't really need to specify pointers

875
00:30:19,039 --> 00:30:20,960
you can just specify offsets and that

876
00:30:20,960 --> 00:30:23,279
has very good implement implications for

877
00:30:23,279 --> 00:30:25,360
leakless exploits such as house of sight

878
00:30:25,360 --> 00:30:27,760
house of house of uh blindness and house

879
00:30:27,760 --> 00:30:29,919
of fix up because all these houses don't

880
00:30:29,919 --> 00:30:32,159
require memory leaks offsets are more

881
00:30:32,159 --> 00:30:33,919
powerful than pointers

882
00:30:33,919 --> 00:30:36,000
and that's it that's uh the nightmare

883
00:30:36,000 --> 00:30:37,760
challenge it had all these three houses

884
00:30:37,760 --> 00:30:40,320
and allowed us to never before write

885
00:30:40,320 --> 00:30:42,240
pointers to arbitrary locations without

886
00:30:42,240 --> 00:30:44,320
needing memory leak uh it was a lot of

887
00:30:44,320 --> 00:30:45,600
fun because you can learn a lot about

888
00:30:45,600 --> 00:30:47,760
the runtime loader uh you can learn a

889
00:30:47,760 --> 00:30:50,000
lot about houses and it was honestly so

890
00:30:50,000 --> 00:30:51,360
much fun to make and it was really fun

891
00:30:51,360 --> 00:30:53,279
to talk with competitors about uh their

892
00:30:53,279 --> 00:30:55,760
attempted solutions unfortunately uh

893
00:30:55,760 --> 00:30:57,840
that didn't have any uh solutions by the

894
00:30:57,840 --> 00:30:59,279
end of the ctf but

895
00:30:59,279 --> 00:31:00,480
uh later i talked to a lot of

896
00:31:00,480 --> 00:31:02,320
competitors about it and you know gave

897
00:31:02,320 --> 00:31:03,360
them the right hints and someone

898
00:31:03,360 --> 00:31:04,399
actually solved it in the end so that

899
00:31:04,399 --> 00:31:05,600
was super cool

900
00:31:05,600 --> 00:31:07,760
uh but yeah it was a lot of fun and it

901
00:31:07,760 --> 00:31:09,679
was really cool to learn about

902
00:31:09,679 --> 00:31:11,760
uh if you want the link is up there a

903
00:31:11,760 --> 00:31:14,399
tiny url of uh the slides if you want

904
00:31:14,399 --> 00:31:16,000
all the links in this presentation you

905
00:31:16,000 --> 00:31:16,960
might want to take a screenshot if

906
00:31:16,960 --> 00:31:18,640
that's something you're into but yeah

907
00:31:18,640 --> 00:31:20,720
that's it that's uh that's the runtime

908
00:31:20,720 --> 00:31:24,880
loader and how it can be used so yep

909
00:31:24,970 --> 00:31:29,840
[Applause]

910
00:31:29,840 --> 00:31:31,360
excellent daniel so now if anyone has

911
00:31:31,360 --> 00:31:34,240
any questions that's time for q a

912
00:31:34,240 --> 00:31:38,600
feel free to ask daniel any questions

913
00:31:46,640 --> 00:31:48,399
no looks like there are any questions

914
00:31:48,399 --> 00:31:49,679
thank you so much

915
00:31:49,679 --> 00:31:53,960
oh there's a question back there

916
00:32:00,000 --> 00:32:01,360
maybe there's a point that i missed

917
00:32:01,360 --> 00:32:03,279
because i thought usually right you know

918
00:32:03,279 --> 00:32:04,799
you know the relative offset of the

919
00:32:04,799 --> 00:32:06,640
functions of the standard library but we

920
00:32:06,640 --> 00:32:08,720
don't know where it's loaded and i

921
00:32:08,720 --> 00:32:11,200
thought that's where you needed a leak

922
00:32:11,200 --> 00:32:12,640
yeah you're saying that you don't need

923
00:32:12,640 --> 00:32:15,039
that here

924
00:32:21,600 --> 00:32:24,000
yeah exactly so the entire point here is

925
00:32:24,000 --> 00:32:25,840
that we don't know base right and that

926
00:32:25,840 --> 00:32:27,519
could cause a lot of problems so uh he

927
00:32:27,519 --> 00:32:30,240
he said uh wait hold on a second uh rock

928
00:32:30,240 --> 00:32:31,919
chains require you to know base right

929
00:32:31,919 --> 00:32:33,519
you need to know the base of the where

930
00:32:33,519 --> 00:32:35,519
the shared library or lipsy is loaded so

931
00:32:35,519 --> 00:32:36,880
that way you can write those addresses

932
00:32:36,880 --> 00:32:38,320
and that's that's very true in a normal

933
00:32:38,320 --> 00:32:39,679
circumstance you need to know the base

934
00:32:39,679 --> 00:32:42,000
of the the shared library or libsy or

935
00:32:42,000 --> 00:32:44,240
whatever but in this specific case what

936
00:32:44,240 --> 00:32:46,080
we're using is we can only specify the

937
00:32:46,080 --> 00:32:48,080
offset and then what we have is remember

938
00:32:48,080 --> 00:32:49,760
that man on the inside that rock chain

939
00:32:49,760 --> 00:32:51,279
writer which in this case is house of

940
00:32:51,279 --> 00:32:54,559
sight which allows us to write um those

941
00:32:54,559 --> 00:32:56,640
addresses in the rock chain with by only

942
00:32:56,640 --> 00:32:58,880
specifying the offset without specifying

943
00:32:58,880 --> 00:33:01,279
the base and the reason why we by not

944
00:33:01,279 --> 00:33:02,880
specifying the base is such a powerful

945
00:33:02,880 --> 00:33:05,760
tool is because getting base requires

946
00:33:05,760 --> 00:33:07,600
this vulnerability on its own remember

947
00:33:07,600 --> 00:33:08,799
you need a memory leak or something like

948
00:33:08,799 --> 00:33:10,960
that which can tell you what exactly the

949
00:33:10,960 --> 00:33:12,399
lipstick base is

950
00:33:12,399 --> 00:33:15,440
but the runtime loader allows us to not

951
00:33:15,440 --> 00:33:16,799
have to know that we don't need that

952
00:33:16,799 --> 00:33:17,919
separate information or that separate

953
00:33:17,919 --> 00:33:20,240
vulnerability we can do it without it by

954
00:33:20,240 --> 00:33:21,919
using dl fix up and its associated

955
00:33:21,919 --> 00:33:23,519
functions

956
00:33:23,519 --> 00:33:26,559
so yeah that's a good question

957
00:33:30,480 --> 00:33:31,760
uh yeah what's up

958
00:33:31,760 --> 00:33:32,480
so

959
00:33:32,480 --> 00:33:35,480
um

960
00:33:41,679 --> 00:33:43,760
oh yeah so um actually a lot of ctf

961
00:33:43,760 --> 00:33:45,679
wikis will list a lot of the different

962
00:33:45,679 --> 00:33:48,000
houses for specific attack surfaces

963
00:33:48,000 --> 00:33:49,760
for example i know uh the how to heap

964
00:33:49,760 --> 00:33:52,000
repository which is by the shellfish ctf

965
00:33:52,000 --> 00:33:54,480
team maintains an active list of all the

966
00:33:54,480 --> 00:33:56,480
the current and patched houses for a

967
00:33:56,480 --> 00:33:59,039
specific uh type of attack surface

968
00:33:59,039 --> 00:34:01,519
called the heap um but um yeah basically

969
00:34:01,519 --> 00:34:03,519
there's an entire list of those houses

970
00:34:03,519 --> 00:34:06,399
it's big i think it's like 28 29 or

971
00:34:06,399 --> 00:34:08,239
something like that but it's a big list

972
00:34:08,239 --> 00:34:09,599
of houses so yeah if that's something

973
00:34:09,599 --> 00:34:10,800
you want to learn i'd recommend checking

974
00:34:10,800 --> 00:34:12,399
it out

975
00:34:12,399 --> 00:34:13,679
yeah

976
00:34:13,679 --> 00:34:17,159
uh yeah what's up

977
00:34:22,320 --> 00:34:24,480
so he mentions that uh

978
00:34:24,480 --> 00:34:26,320
this this process might only only work

979
00:34:26,320 --> 00:34:28,239
for shared libraries right because if

980
00:34:28,239 --> 00:34:29,839
it's statically loaded then you don't

981
00:34:29,839 --> 00:34:32,879
end up doing uh this sort of uh this

982
00:34:32,879 --> 00:34:34,239
relocation process because you already

983
00:34:34,239 --> 00:34:35,918
know all the addresses in memory this is

984
00:34:35,918 --> 00:34:38,159
true in fact um if the binary is

985
00:34:38,159 --> 00:34:40,000
statically loaded you don't end up using

986
00:34:40,000 --> 00:34:41,599
functions like dlfixup because you

987
00:34:41,599 --> 00:34:42,800
already know the location of every

988
00:34:42,800 --> 00:34:44,719
address in memory this means the lfx up

989
00:34:44,719 --> 00:34:46,079
is never called so you can never really

990
00:34:46,079 --> 00:34:48,239
use this exploit however that's okay

991
00:34:48,239 --> 00:34:52,560
most times uh all all binaries and um or

992
00:34:52,560 --> 00:34:54,879
majority speaking are all dynamically

993
00:34:54,879 --> 00:34:56,560
loaded so usually this is not much of an

994
00:34:56,560 --> 00:34:57,680
issue

995
00:34:57,680 --> 00:34:59,440
yeah

996
00:34:59,440 --> 00:35:01,200
yeah good point

997
00:35:01,200 --> 00:35:03,119
yeah what's up uh i'll add because this

998
00:35:03,119 --> 00:35:05,119
thing tripped me up once

999
00:35:05,119 --> 00:35:07,119
i think you can have

1000
00:35:07,119 --> 00:35:09,680
even if it's dynamically loaded

1001
00:35:09,680 --> 00:35:10,640
the

1002
00:35:10,640 --> 00:35:12,160
there is a setting

1003
00:35:12,160 --> 00:35:13,680
right for

1004
00:35:13,680 --> 00:35:15,440
actually calculating

1005
00:35:15,440 --> 00:35:18,480
the memory locations functions before

1006
00:35:18,480 --> 00:35:19,520
runtime

1007
00:35:19,520 --> 00:35:21,280
yeah so this is true um this is called

1008
00:35:21,280 --> 00:35:24,880
relro uh yeah yeah so it's he mentions

1009
00:35:24,880 --> 00:35:26,560
that um

1010
00:35:26,560 --> 00:35:28,480
very often that the

1011
00:35:28,480 --> 00:35:29,440
the

1012
00:35:29,440 --> 00:35:31,599
functions in the got are calculated

1013
00:35:31,599 --> 00:35:34,320
before runtime which is true yeah it

1014
00:35:34,320 --> 00:35:36,400
happens sometimes um it's not all the

1015
00:35:36,400 --> 00:35:38,400
time but it does happen quite frequently

1016
00:35:38,400 --> 00:35:39,839
where people will enable railroad on

1017
00:35:39,839 --> 00:35:42,320
their programs and this means that you

1018
00:35:42,320 --> 00:35:43,599
all of them are calculated beforehand so

1019
00:35:43,599 --> 00:35:45,440
dl fix up never gets called in this

1020
00:35:45,440 --> 00:35:47,520
specific case um

1021
00:35:47,520 --> 00:35:48,720
the house of mine is still applies

1022
00:35:48,720 --> 00:35:51,440
because it's at exit time but for the

1023
00:35:51,440 --> 00:35:52,960
house of sight and house of fix-up both

1024
00:35:52,960 --> 00:35:55,520
of those require deal fix up and that is

1025
00:35:55,520 --> 00:35:57,920
only called uh when you're when you when

1026
00:35:57,920 --> 00:35:59,599
you have partial reload because partial

1027
00:35:59,599 --> 00:36:01,119
rows that when it does it's called lazy

1028
00:36:01,119 --> 00:36:04,480
loading it does it at um at a run time

1029
00:36:04,480 --> 00:36:06,320
but as you mentioned yeah there's also

1030
00:36:06,320 --> 00:36:09,520
full railroad which does it before yeah

1031
00:36:09,520 --> 00:36:13,240
yeah good great question

1032
00:36:20,640 --> 00:36:23,920
all right no more questions

1033
00:36:24,960 --> 00:36:26,560
all right well thank you so much sammy

1034
00:36:26,560 --> 00:36:28,630
it was an excellent talk

1035
00:36:28,630 --> 00:36:35,040
[Applause]

1036
00:36:35,040 --> 00:36:37,280
uh stick around at nine o'clock the next

1037
00:36:37,280 --> 00:36:40,079
talk will be not enough just enough rd

1038
00:36:40,079 --> 00:36:42,640
cloning to be dangerous so stick around

1039
00:36:42,640 --> 00:36:46,440
for the talk thank you

1040
00:37:30,800 --> 00:37:32,880
you

