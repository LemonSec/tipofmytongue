1
00:00:01,090 --> 00:00:05,720
all right I am super excited to be here

2
00:00:04,040 --> 00:00:11,330
so before we start can I take a selfie

3
00:00:05,720 --> 00:00:13,010
real quick let's do that all right

4
00:00:11,330 --> 00:00:14,870
thanks for letting me record that moment

5
00:00:13,010 --> 00:00:16,730
real fast cuz I I got here and I'm

6
00:00:14,870 --> 00:00:18,499
having a blast this is so cool to be

7
00:00:16,730 --> 00:00:20,810
able to learn from the the presentations

8
00:00:18,499 --> 00:00:23,060
yesterday really fascinating stuff got

9
00:00:20,810 --> 00:00:24,619
me outside of my comfort zone which is

10
00:00:23,060 --> 00:00:26,599
always what I strive to do when I go to

11
00:00:24,619 --> 00:00:28,249
a prison to a conference and then the

12
00:00:26,599 --> 00:00:31,880
city as well obviously it's beautiful so

13
00:00:28,249 --> 00:00:35,000
really great to be here let's get

14
00:00:31,880 --> 00:00:37,430
started alright so I am a reverse

15
00:00:35,000 --> 00:00:39,289
engineer at fire I might get kind of on

16
00:00:37,430 --> 00:00:40,640
the back end of the company which means

17
00:00:39,289 --> 00:00:43,160
when our incident responders go out

18
00:00:40,640 --> 00:00:45,800
there they do forensics they chase down

19
00:00:43,160 --> 00:00:47,750
attackers they recover their tools and

20
00:00:45,800 --> 00:00:50,358
our job is to understand well how do

21
00:00:47,750 --> 00:00:53,089
they work and then use that intelligence

22
00:00:50,359 --> 00:00:54,350
to kind of well find more places that

23
00:00:53,089 --> 00:00:55,998
they are understand how to reverse

24
00:00:54,350 --> 00:00:58,280
engineer or how to how to use their

25
00:00:55,999 --> 00:00:59,659
network protocols how to protect

26
00:00:58,280 --> 00:01:01,789
ourselves in the future that's what I'm

27
00:00:59,659 --> 00:01:03,710
doing on the back end and realistically

28
00:01:01,789 --> 00:01:05,330
I'm not exaggerating here on a yearly

29
00:01:03,710 --> 00:01:07,370
basis I'm looking at hundreds but

30
00:01:05,330 --> 00:01:11,300
probably more like thousands of malware

31
00:01:07,370 --> 00:01:13,040
binaries okay and what I've come to

32
00:01:11,300 --> 00:01:15,440
realize is that it's important not just

33
00:01:13,040 --> 00:01:17,060
to be focused on the current sample then

34
00:01:15,440 --> 00:01:18,320
I'm focused on right now my boss is

35
00:01:17,060 --> 00:01:20,300
hammering on my back you know come on

36
00:01:18,320 --> 00:01:23,240
finish this get it done real fast not to

37
00:01:20,300 --> 00:01:25,009
be focused on this moment right now but

38
00:01:23,240 --> 00:01:27,050
always to be thinking about well what

39
00:01:25,010 --> 00:01:30,440
don't we know about how can we expand

40
00:01:27,050 --> 00:01:32,840
our knowledge how can we find more

41
00:01:30,440 --> 00:01:34,520
interesting things you know I need to

42
00:01:32,840 --> 00:01:35,750
take what I'm doing now generalize it

43
00:01:34,520 --> 00:01:39,500
and use that to find more interesting

44
00:01:35,750 --> 00:01:40,940
binaries for example you know there are

45
00:01:39,500 --> 00:01:42,350
a couple there were some presentations

46
00:01:40,940 --> 00:01:45,350
yesterday they were talking about SCADA

47
00:01:42,350 --> 00:01:47,899
Malheur ICS malware definitely a very

48
00:01:45,350 --> 00:01:50,059
interesting domain right company

49
00:01:47,900 --> 00:01:52,310
spending billions of dollars on ICS

50
00:01:50,060 --> 00:01:53,990
security but let's take a moment here

51
00:01:52,310 --> 00:01:56,660
and think about publicly

52
00:01:53,990 --> 00:02:01,850
how many ICS malware samples are there

53
00:01:56,660 --> 00:02:05,360
publicly discussed like five maybe you

54
00:02:01,850 --> 00:02:07,280
got black energy you got Stuxnet you got

55
00:02:05,360 --> 00:02:09,919
Triton I know that was in the news the

56
00:02:07,280 --> 00:02:11,960
other day like what else what else is

57
00:02:09,919 --> 00:02:14,309
there one thing that is interesting

58
00:02:11,960 --> 00:02:17,010
there was malware called iron gate

59
00:02:14,310 --> 00:02:19,140
couple years ago that wasn't found

60
00:02:17,010 --> 00:02:21,929
during an investigation it wasn't found

61
00:02:19,140 --> 00:02:24,089
during an intrusion what happened was my

62
00:02:21,930 --> 00:02:27,720
buddy was studying obfuscation

63
00:02:24,090 --> 00:02:30,120
techniques for compiled Python binaries

64
00:02:27,720 --> 00:02:33,209
so those are like pop pyc files

65
00:02:30,120 --> 00:02:34,980
you know optimized Python code and

66
00:02:33,209 --> 00:02:37,230
there's a very few number of people out

67
00:02:34,980 --> 00:02:39,179
there they're actually obfuscating the

68
00:02:37,230 --> 00:02:40,410
bytecode and so you said this is a kind

69
00:02:39,180 --> 00:02:42,300
of interesting technique we never see

70
00:02:40,410 --> 00:02:43,770
this in legitimate software so what

71
00:02:42,300 --> 00:02:46,440
happens when we go and start hunting

72
00:02:43,770 --> 00:02:50,220
around singing else using that instantly

73
00:02:46,440 --> 00:02:52,019
stumbled across Irongate one of the five

74
00:02:50,220 --> 00:02:54,630
public malware samples out there

75
00:02:52,019 --> 00:02:59,519
targeting ICS systems it's worthwhile to

76
00:02:54,630 --> 00:03:03,450
do okay so here we're gonna focus on

77
00:02:59,519 --> 00:03:08,430
shellcode little less sexy maybe more

78
00:03:03,450 --> 00:03:10,859
sexy in any case I see hundreds of these

79
00:03:08,430 --> 00:03:12,060
gel code binaries per year and so what

80
00:03:10,860 --> 00:03:14,190
I've kind of noticed is obviously

81
00:03:12,060 --> 00:03:16,440
shellcode it's never legitimate it's

82
00:03:14,190 --> 00:03:17,850
always malicious so that's a it's a good

83
00:03:16,440 --> 00:03:19,769
differentiator if I can hunt for

84
00:03:17,850 --> 00:03:21,870
shellcode I know I'm finding malicious

85
00:03:19,769 --> 00:03:23,310
code that's good other things that are

86
00:03:21,870 --> 00:03:25,140
kind of interesting to me shellcode is

87
00:03:23,310 --> 00:03:27,780
often not just found as standalone

88
00:03:25,140 --> 00:03:31,440
binaries but embedded with other within

89
00:03:27,780 --> 00:03:33,420
other more complex file types so if I

90
00:03:31,440 --> 00:03:35,040
can find shellcode in a Word document

91
00:03:33,420 --> 00:03:36,750
probably also going to find exploits and

92
00:03:35,040 --> 00:03:39,690
other interesting features in there too

93
00:03:36,750 --> 00:03:42,299
pretty interesting to go about so it's

94
00:03:39,690 --> 00:03:44,820
good to find shellcode how can we do

95
00:03:42,299 --> 00:03:47,910
that in my experience one thing that

96
00:03:44,820 --> 00:03:49,530
I've found that's useful to do is if I

97
00:03:47,910 --> 00:03:51,660
can understand the difference between

98
00:03:49,530 --> 00:03:53,970
shellcode and legitimate code the way

99
00:03:51,660 --> 00:03:55,260
that it's structured then I can find it

100
00:03:53,970 --> 00:03:58,049
find new stuff

101
00:03:55,260 --> 00:04:00,239
okay so first text dump of the

102
00:03:58,049 --> 00:04:02,359
presentation we got to these guys here

103
00:04:00,239 --> 00:04:05,160
on the top we have a PE file

104
00:04:02,359 --> 00:04:07,019
well-understood file format there MZ

105
00:04:05,160 --> 00:04:09,890
header well understood when it comes to

106
00:04:07,019 --> 00:04:12,450
shell code that structure is not there

107
00:04:09,890 --> 00:04:15,089
it's kind of the Wild West we have very

108
00:04:12,450 --> 00:04:17,060
much less to key on we can't look for

109
00:04:15,090 --> 00:04:19,560
magic headers what do we need to do that

110
00:04:17,060 --> 00:04:20,820
let's take a step back and understand

111
00:04:19,560 --> 00:04:24,060
what are some key differences between

112
00:04:20,820 --> 00:04:26,969
shell code and standalone executable

113
00:04:24,060 --> 00:04:28,270
files that run on Windows systems the

114
00:04:26,970 --> 00:04:31,390
first thing that I would point

115
00:04:28,270 --> 00:04:34,960
is the difference of position dependence

116
00:04:31,390 --> 00:04:37,390
vs. independence so for a windows binary

117
00:04:34,960 --> 00:04:39,099
a p/e DLL something like that

118
00:04:37,390 --> 00:04:41,260
they're going to rely on the Windows

119
00:04:39,100 --> 00:04:42,940
loader to take the file off disk put

120
00:04:41,260 --> 00:04:46,330
into memory and prepare for execution as

121
00:04:42,940 --> 00:04:48,550
part of that the Windows loader is going

122
00:04:46,330 --> 00:04:50,650
to ensure that multiple modules that is

123
00:04:48,550 --> 00:04:53,650
DLLs are now getting loaded into the

124
00:04:50,650 --> 00:04:55,599
same place colliding if that were about

125
00:04:53,650 --> 00:04:57,280
to happen the loader would fix up the

126
00:04:55,600 --> 00:04:59,460
system to ensure there's not memory

127
00:04:57,280 --> 00:05:01,659
references colliding with one another

128
00:04:59,460 --> 00:05:05,200
makes the job of the software developer

129
00:05:01,660 --> 00:05:06,760
a lot easier so practically speaking

130
00:05:05,200 --> 00:05:08,680
what this means when I look in high to

131
00:05:06,760 --> 00:05:10,120
pro for example you know this is the

132
00:05:08,680 --> 00:05:11,920
beginning of a function here there's a

133
00:05:10,120 --> 00:05:13,270
lot of stuff going on but right in the

134
00:05:11,920 --> 00:05:15,520
middle here we have a reference to a

135
00:05:13,270 --> 00:05:18,190
global variable global variables name is

136
00:05:15,520 --> 00:05:21,340
a security cookie it's part of this anti

137
00:05:18,190 --> 00:05:23,590
exploitation technique okay if I were to

138
00:05:21,340 --> 00:05:25,179
navigate to that global variable this is

139
00:05:23,590 --> 00:05:27,880
data that can be referenced by multiple

140
00:05:25,180 --> 00:05:29,950
functions I can see that it contains

141
00:05:27,880 --> 00:05:31,840
some weird hexadecimal value we're not

142
00:05:29,950 --> 00:05:34,510
interested in that what I want to point

143
00:05:31,840 --> 00:05:37,119
out it exists at this single global

144
00:05:34,510 --> 00:05:41,020
address on the left here five six nine

145
00:05:37,120 --> 00:05:43,000
two zero zero now the code can actually

146
00:05:41,020 --> 00:05:44,620
refer to that specific address because

147
00:05:43,000 --> 00:05:46,300
and it can assume at that address

148
00:05:44,620 --> 00:05:48,729
whenever it's running that's where that

149
00:05:46,300 --> 00:05:50,590
variable will do so sure enough when I

150
00:05:48,729 --> 00:05:53,950
look at the disassembly and now it's

151
00:05:50,590 --> 00:05:56,140
actually encoded in hex that global

152
00:05:53,950 --> 00:05:58,240
memory address is right there in the

153
00:05:56,140 --> 00:06:00,669
data zero zero five six nine two zero

154
00:05:58,240 --> 00:06:01,840
zero that was the global memory it's

155
00:06:00,669 --> 00:06:04,049
hard coded right there

156
00:06:01,840 --> 00:06:05,440
in fact when I look at the hex dump

157
00:06:04,050 --> 00:06:07,419
there it is

158
00:06:05,440 --> 00:06:09,850
in the binder if I were to over my hex

159
00:06:07,419 --> 00:06:13,240
editor I would see that hard-coded value

160
00:06:09,850 --> 00:06:14,830
okay from a software development

161
00:06:13,240 --> 00:06:16,150
perspective this is really nice we can

162
00:06:14,830 --> 00:06:18,159
just reference global variables it's

163
00:06:16,150 --> 00:06:20,429
very easy to do but within shell code

164
00:06:18,160 --> 00:06:23,290
that's not something we can do

165
00:06:20,430 --> 00:06:25,419
because in shell code show code can make

166
00:06:23,290 --> 00:06:26,979
basically no assumptions about where

167
00:06:25,419 --> 00:06:28,960
it's running what the operating

168
00:06:26,979 --> 00:06:34,000
environment looks like it has to do

169
00:06:28,960 --> 00:06:36,130
everything itself that's because during

170
00:06:34,000 --> 00:06:37,930
exploitation or however the code

171
00:06:36,130 --> 00:06:40,120
actually got on the system there might

172
00:06:37,930 --> 00:06:41,139
have been additional constraints so we

173
00:06:40,120 --> 00:06:45,310
can't assume that it's

174
00:06:41,139 --> 00:06:46,900
a particular address for example this is

175
00:06:45,310 --> 00:06:49,539
something I see all of the time it's a

176
00:06:46,900 --> 00:06:52,688
stager from Metasploit PowerShell as we

177
00:06:49,539 --> 00:06:54,460
can see here fairly straightforward line

178
00:06:52,689 --> 00:06:56,830
one we have a bunch of raw bytes that's

179
00:06:54,460 --> 00:06:59,498
the shell code itself might be base64

180
00:06:56,830 --> 00:07:01,150
encoded something like that well then

181
00:06:59,499 --> 00:07:03,129
ask the operating system or the runtime

182
00:07:01,150 --> 00:07:04,719
hey please give me some memory into

183
00:07:03,129 --> 00:07:07,300
which I can put my shellcode and execute

184
00:07:04,719 --> 00:07:08,650
it make sure that memory is large enough

185
00:07:07,300 --> 00:07:10,900
for the shellcode

186
00:07:08,650 --> 00:07:13,448
that's that this argument here

187
00:07:10,900 --> 00:07:15,159
allocation size and then the runtime is

188
00:07:13,449 --> 00:07:16,539
going to give us back a memory region

189
00:07:15,159 --> 00:07:19,930
that we can write our shellcode in and

190
00:07:16,539 --> 00:07:22,469
then execute using create thread now

191
00:07:19,930 --> 00:07:24,909
it's interesting too that for me here is

192
00:07:22,469 --> 00:07:26,889
that the return value from virtual a

193
00:07:24,909 --> 00:07:28,688
lock could return us a memory region

194
00:07:26,889 --> 00:07:30,819
anywhere in memory it's not at a

195
00:07:28,689 --> 00:07:32,409
specific address we're not guaranteed to

196
00:07:30,819 --> 00:07:34,330
know where that is in fact we could call

197
00:07:32,409 --> 00:07:36,729
virtual a lock many times over and over

198
00:07:34,330 --> 00:07:39,758
it'll give it different return values

199
00:07:36,729 --> 00:07:42,159
each time therefore the shellcode that

200
00:07:39,759 --> 00:07:44,139
is written and then executed at that

201
00:07:42,159 --> 00:07:48,099
memory address again has to be able to

202
00:07:44,139 --> 00:07:49,389
deal with that situation okay what does

203
00:07:48,099 --> 00:07:53,378
that mean how are we gonna deal with

204
00:07:49,389 --> 00:07:55,509
that situation in shellcode and why do

205
00:07:53,379 --> 00:07:56,949
we need to do this the data that we

206
00:07:55,509 --> 00:07:59,050
might store in a global variable might

207
00:07:56,949 --> 00:08:00,729
be a thing like the c2 address where you

208
00:07:59,050 --> 00:08:02,409
want to connect to to receive commands

209
00:08:00,729 --> 00:08:05,500
or maybe how we're going to avoid

210
00:08:02,409 --> 00:08:06,610
forensic software on the endpoint so

211
00:08:05,500 --> 00:08:08,680
we're going to need these global

212
00:08:06,610 --> 00:08:10,569
variables so in order to get access to

213
00:08:08,680 --> 00:08:12,599
them without using relative addressing

214
00:08:10,569 --> 00:08:15,969
which doesn't really exist on 32-bit

215
00:08:12,599 --> 00:08:18,449
Intel we need to first figure out where

216
00:08:15,969 --> 00:08:21,599
is the shellcode executing at runtime

217
00:08:18,449 --> 00:08:24,909
figure out a common anchor point and

218
00:08:21,599 --> 00:08:27,339
then from there we can kind of reference

219
00:08:24,909 --> 00:08:28,659
the the code and the Condor

220
00:08:27,339 --> 00:08:31,019
configuration that when we need access

221
00:08:28,659 --> 00:08:33,399
to okay so

222
00:08:31,019 --> 00:08:35,529
memory diagram here we've got shellcode

223
00:08:33,399 --> 00:08:37,000
a bunch of program logic our program

224
00:08:35,529 --> 00:08:40,179
counters somewhere in the middle of the

225
00:08:37,000 --> 00:08:42,269
program logic in there and it needs the

226
00:08:40,179 --> 00:08:45,459
reference down here first thing it'll do

227
00:08:42,269 --> 00:08:47,589
figure out how far into the shellcode is

228
00:08:45,459 --> 00:08:49,089
the current program counter and then

229
00:08:47,589 --> 00:08:53,230
from there and that value is going to be

230
00:08:49,089 --> 00:08:55,550
constant known at compile time likewise

231
00:08:53,230 --> 00:08:57,590
the delta between the start of the

232
00:08:55,550 --> 00:08:58,939
shellcode and the configuration data

233
00:08:57,590 --> 00:09:01,070
that it needs is also going to be

234
00:08:58,940 --> 00:09:03,800
constant known at compile time so in

235
00:09:01,070 --> 00:09:06,860
those two steps we can recover how to

236
00:09:03,800 --> 00:09:09,280
access the configuration data everyone

237
00:09:06,860 --> 00:09:09,280
with me so far

238
00:09:10,690 --> 00:09:16,190
now we'll go down even another level how

239
00:09:14,600 --> 00:09:18,890
does this actually look in our

240
00:09:16,190 --> 00:09:21,560
disassembly we'll get to understand why

241
00:09:18,890 --> 00:09:23,390
this is important in a moment but what

242
00:09:21,560 --> 00:09:26,119
this typically looks like is one of

243
00:09:23,390 --> 00:09:28,280
these two two tricks here the one on the

244
00:09:26,120 --> 00:09:30,500
left that's what I see most commonly

245
00:09:28,280 --> 00:09:32,510
because in x86 there is no instruction

246
00:09:30,500 --> 00:09:34,790
fetch the instruction pointer and put it

247
00:09:32,510 --> 00:09:36,950
into a register doesn't exist so we have

248
00:09:34,790 --> 00:09:39,230
to fall back and use these tricks here

249
00:09:36,950 --> 00:09:41,240
we have called +5 relative call

250
00:09:39,230 --> 00:09:43,160
basically allows us to get access to

251
00:09:41,240 --> 00:09:48,800
where is the current instruction pointer

252
00:09:43,160 --> 00:09:50,660
those two instructions for example I

253
00:09:48,800 --> 00:09:51,770
think I pulled this from Metasploit

254
00:09:50,660 --> 00:09:53,810
something like that one of those

255
00:09:51,770 --> 00:09:55,340
projects it's the start of a function

256
00:09:53,810 --> 00:09:57,140
bunch of stuff going on here

257
00:09:55,340 --> 00:10:00,950
but what I do see suck instruction call

258
00:09:57,140 --> 00:10:04,730
+5 pop into a register I know that means

259
00:10:00,950 --> 00:10:08,920
fetch the current instruction counter

260
00:10:04,730 --> 00:10:11,630
value not used in legitimate programs I

261
00:10:08,920 --> 00:10:15,199
think that's weird what's going on here

262
00:10:11,630 --> 00:10:18,430
okay fetch the current instruction the

263
00:10:15,200 --> 00:10:23,810
program counter and then from there

264
00:10:18,430 --> 00:10:25,189
compute the global anchor point here the

265
00:10:23,810 --> 00:10:27,140
compiler seemed to know that the the

266
00:10:25,190 --> 00:10:28,840
Delta between where we comment and

267
00:10:27,140 --> 00:10:34,370
executing and the anchor point is

268
00:10:28,840 --> 00:10:37,580
hexadecimal 36 bytes so 36 bytes to the

269
00:10:34,370 --> 00:10:40,970
start of our shellcode buffer and then

270
00:10:37,580 --> 00:10:44,180
subsequently we reference relative to

271
00:10:40,970 --> 00:10:46,940
that anchor point the Delta to our

272
00:10:44,180 --> 00:10:49,099
configuration data okay simple

273
00:10:46,940 --> 00:10:50,750
arithmetic here and then that allows us

274
00:10:49,100 --> 00:10:52,100
to reference I think this is like the C

275
00:10:50,750 --> 00:10:54,110
to address that was going to be used by

276
00:10:52,100 --> 00:10:56,780
the shell code cool

277
00:10:54,110 --> 00:10:59,330
I understand under the hood what's going

278
00:10:56,780 --> 00:11:01,189
on and why it's happening but as a

279
00:10:59,330 --> 00:11:02,570
reverse engineer and someone who's out

280
00:11:01,190 --> 00:11:05,249
there trying to find interesting Malheur

281
00:11:02,570 --> 00:11:07,149
how can I use this to my advantage

282
00:11:05,249 --> 00:11:09,999
legitimate software isn't doing this

283
00:11:07,149 --> 00:11:11,949
shellcodes doing this well one thing

284
00:11:09,999 --> 00:11:14,199
that I notice is that these two

285
00:11:11,949 --> 00:11:17,160
instructions are interesting to me and

286
00:11:14,199 --> 00:11:19,118
it's only a very few ways to encode them

287
00:11:17,160 --> 00:11:22,079
so this sequence of bytes

288
00:11:19,119 --> 00:11:24,249
eh zero zero zero zero five eight

289
00:11:22,079 --> 00:11:27,368
probably never seen in legitimate

290
00:11:24,249 --> 00:11:29,470
software anytime I come to that

291
00:11:27,369 --> 00:11:31,299
conclusion I say well is there some way

292
00:11:29,470 --> 00:11:33,579
that I could build maybe a signature or

293
00:11:31,299 --> 00:11:35,439
a matching engine to find that sequence

294
00:11:33,579 --> 00:11:36,040
and then go and maybe across the

295
00:11:35,439 --> 00:11:41,230
virustotal

296
00:11:36,040 --> 00:11:43,809
find all malware that does that okay one

297
00:11:41,230 --> 00:11:45,699
easy way to do this is use yara your as

298
00:11:43,809 --> 00:11:47,499
a pattern matching kind of like a

299
00:11:45,699 --> 00:11:49,660
regular expression engine for binary

300
00:11:47,499 --> 00:11:51,759
data it's kind of little lingua franca

301
00:11:49,660 --> 00:11:55,169
for binary signatures these days so I

302
00:11:51,759 --> 00:11:59,079
can take what I learned about shellcode

303
00:11:55,169 --> 00:12:01,119
encode it as a binary signature and know

304
00:11:59,079 --> 00:12:02,439
that this rule is only going to match on

305
00:12:01,119 --> 00:12:04,149
code that's fetching the current

306
00:12:02,439 --> 00:12:06,399
instruction pointer and then probably

307
00:12:04,149 --> 00:12:09,160
using that to access global data but we

308
00:12:06,399 --> 00:12:12,610
are a thing so I was able to develop

309
00:12:09,160 --> 00:12:14,290
this rule it took five minutes I want to

310
00:12:12,610 --> 00:12:16,540
go and test it first thing I do run it

311
00:12:14,290 --> 00:12:20,759
against my local system how do you think

312
00:12:16,540 --> 00:12:23,860
that worked out well right when I ran a

313
00:12:20,759 --> 00:12:25,299
lot of hits granted I am a malware

314
00:12:23,860 --> 00:12:27,910
analyst there's a lot of malware on my

315
00:12:25,299 --> 00:12:29,439
system but look I mean if we look at

316
00:12:27,910 --> 00:12:31,419
where these hits are it's like it's in

317
00:12:29,439 --> 00:12:34,988
Python it's in web acts it's in teams

318
00:12:31,419 --> 00:12:37,899
this is not a good rule way too many

319
00:12:34,989 --> 00:12:40,119
false positives we're gonna need to use

320
00:12:37,899 --> 00:12:43,959
a different technique so this was not a

321
00:12:40,119 --> 00:12:45,549
good thing let's think about other ways

322
00:12:43,959 --> 00:12:47,919
that shellcode differs from legitimate

323
00:12:45,549 --> 00:12:51,339
binaries we have is our position

324
00:12:47,919 --> 00:12:53,259
independence and independence we also

325
00:12:51,339 --> 00:12:55,509
have the way that shellcode has to

326
00:12:53,259 --> 00:12:58,089
interact with the host system for

327
00:12:55,509 --> 00:13:02,139
example resolving imports system

328
00:12:58,089 --> 00:13:04,209
routines on a Windows binary AP file or

329
00:13:02,139 --> 00:13:07,449
DLL you can again rely on the Windows

330
00:13:04,209 --> 00:13:09,638
loader to resolve any dependent dll's

331
00:13:07,449 --> 00:13:11,498
shared libraries and the routines needed

332
00:13:09,639 --> 00:13:13,689
to interact with the system for example

333
00:13:11,499 --> 00:13:17,919
creating a file or connecting to an

334
00:13:13,689 --> 00:13:19,059
internet site we can rely on that one

335
00:13:17,919 --> 00:13:20,859
place you may have seen this

336
00:13:19,059 --> 00:13:22,659
if you've ever opened up if he editor

337
00:13:20,859 --> 00:13:24,729
and looked at the import table for a PE

338
00:13:22,659 --> 00:13:27,159
file you'll see a list of routines that

339
00:13:24,729 --> 00:13:28,479
are needed to execute the program for

340
00:13:27,159 --> 00:13:30,819
example here I see a bunch of routines

341
00:13:28,479 --> 00:13:33,009
related to the registry rendering text

342
00:13:30,819 --> 00:13:34,659
and maybe displaying an image as a

343
00:13:33,009 --> 00:13:36,159
forensic analyst I might look at that

344
00:13:34,659 --> 00:13:39,519
and have a hint as to what the binaries

345
00:13:36,159 --> 00:13:40,718
doing but again with shellcode we can't

346
00:13:39,519 --> 00:13:42,519
make that assumption there is no

347
00:13:40,719 --> 00:13:43,989
standard file format for shellcode and

348
00:13:42,519 --> 00:13:47,859
shellcode doesn't rely on the windows

349
00:13:43,989 --> 00:13:49,659
loader so that's not going to be there

350
00:13:47,859 --> 00:13:52,109
and yet shellcode still needs to

351
00:13:49,659 --> 00:13:54,669
interact with the system to do its job

352
00:13:52,109 --> 00:14:02,589
drop an additional file or maybe receive

353
00:13:54,669 --> 00:14:04,629
a command from a c2 server so it has to

354
00:14:02,589 --> 00:14:06,849
do all of this work manually it has to

355
00:14:04,629 --> 00:14:09,249
bring along its own implementation of

356
00:14:06,849 --> 00:14:12,279
what the windows loader is doing in

357
00:14:09,249 --> 00:14:15,939
practice this commonly looks like doing

358
00:14:12,279 --> 00:14:18,099
memory forensics on itself it has to

359
00:14:15,939 --> 00:14:20,199
find some global structures it has to

360
00:14:18,099 --> 00:14:21,789
follow pointers it has to use its

361
00:14:20,199 --> 00:14:23,829
knowledge of Windows internals to

362
00:14:21,789 --> 00:14:25,659
ultimately get access to the single

363
00:14:23,829 --> 00:14:28,899
function pointer to maybe create an HTTP

364
00:14:25,659 --> 00:14:30,849
request it's a lot of work but it's the

365
00:14:28,899 --> 00:14:34,379
price you pay for deploying a payload

366
00:14:30,849 --> 00:14:36,909
that's written in shellcode okay

367
00:14:34,379 --> 00:14:38,319
well let's dig into maybe how this works

368
00:14:36,909 --> 00:14:44,049
and see if we can figure out better ways

369
00:14:38,319 --> 00:14:45,669
of detecting this from a kind of high

370
00:14:44,049 --> 00:14:47,259
level what we're generally gonna see

371
00:14:45,669 --> 00:14:49,598
here is we have our shellcode buffer

372
00:14:47,259 --> 00:14:51,879
this is machine code that's running it's

373
00:14:49,599 --> 00:14:53,559
got a pro pro program logic here and

374
00:14:51,879 --> 00:14:55,719
that's going to basically have to find

375
00:14:53,559 --> 00:14:59,379
global memory structures like the tab

376
00:14:55,719 --> 00:15:01,899
the peb additional linked lists walk

377
00:14:59,379 --> 00:15:04,119
through all these memory structures to

378
00:15:01,899 --> 00:15:06,639
eventually resolve the DLLs that it

379
00:15:04,119 --> 00:15:09,729
needs to do its job maybe for encrypting

380
00:15:06,639 --> 00:15:11,319
data or connecting to the Internet these

381
00:15:09,729 --> 00:15:13,269
guys in orange over here on the right

382
00:15:11,319 --> 00:15:15,759
those are additional system dll's that

383
00:15:13,269 --> 00:15:17,559
are loaded into memory so once the

384
00:15:15,759 --> 00:15:19,869
shellcode is able to find these dll's

385
00:15:17,559 --> 00:15:22,929
well then it needs to parse the PE file

386
00:15:19,869 --> 00:15:26,649
walk the sections find the export table

387
00:15:22,929 --> 00:15:29,259
Wow a lot of steps but at the end of the

388
00:15:26,649 --> 00:15:31,779
day resolve the function pointer for

389
00:15:29,259 --> 00:15:32,980
opening an HTTP request life can

390
00:15:31,779 --> 00:15:39,230
continue

391
00:15:32,980 --> 00:15:41,270
okay a lot of work concretely under the

392
00:15:39,230 --> 00:15:44,570
hood we're gonna go dive down even

393
00:15:41,270 --> 00:15:47,240
another layer here in order to walk

394
00:15:44,570 --> 00:15:49,730
these structures we'll have to take the

395
00:15:47,240 --> 00:15:52,820
following steps we'll have to start by

396
00:15:49,730 --> 00:15:55,370
using the FS segment which you can kind

397
00:15:52,820 --> 00:15:59,800
of think of as a register that contains

398
00:15:55,370 --> 00:16:01,940
a pointer that always glows to this

399
00:15:59,800 --> 00:16:04,219
global structure called a thread

400
00:16:01,940 --> 00:16:07,190
environment block metadata about the

401
00:16:04,220 --> 00:16:10,190
currently executing thread that data

402
00:16:07,190 --> 00:16:12,710
structure is pointer to the peb metadata

403
00:16:10,190 --> 00:16:16,280
about the current process which has a

404
00:16:12,710 --> 00:16:18,710
pointer at offset hexadecimal C to

405
00:16:16,280 --> 00:16:21,709
another data structure called the loader

406
00:16:18,710 --> 00:16:25,130
data which has a number of pointers to

407
00:16:21,710 --> 00:16:28,130
various linked lists of dll's that are

408
00:16:25,130 --> 00:16:29,780
loaded on the system like I said it's a

409
00:16:28,130 --> 00:16:32,210
lot of work to kind of go through this

410
00:16:29,780 --> 00:16:33,980
process but what's interesting to me as

411
00:16:32,210 --> 00:16:36,890
malware analyst who wants to find more

412
00:16:33,980 --> 00:16:41,330
malware is that this is the way you have

413
00:16:36,890 --> 00:16:43,610
to do it and if we know that code has to

414
00:16:41,330 --> 00:16:45,170
do this I'm starting to see patterns I

415
00:16:43,610 --> 00:16:46,400
know that the way they do this they have

416
00:16:45,170 --> 00:16:47,569
to follow this point or they have to

417
00:16:46,400 --> 00:16:51,770
follow that pointer they have to follow

418
00:16:47,570 --> 00:16:54,110
that pointer okay if that's the case I

419
00:16:51,770 --> 00:16:57,140
wonder what does the C code look like to

420
00:16:54,110 --> 00:16:59,240
do that it's it has to look like what we

421
00:16:57,140 --> 00:17:00,500
see at the top there okay there's

422
00:16:59,240 --> 00:17:02,480
probably some more casting and the

423
00:17:00,500 --> 00:17:03,530
compiler is gonna get angry but like so

424
00:17:02,480 --> 00:17:08,209
it looks like a bunch of pointer

425
00:17:03,530 --> 00:17:09,770
dereferences to hard coded constants at

426
00:17:08,209 --> 00:17:12,470
the assembly level it's just three

427
00:17:09,770 --> 00:17:14,829
instructions fetching from the FS

428
00:17:12,470 --> 00:17:20,110
register offset 30 then offset

429
00:17:14,829 --> 00:17:23,030
hexadecimal C offset exodus Mel C hmm

430
00:17:20,109 --> 00:17:25,069
when I know that there's a sequence of

431
00:17:23,030 --> 00:17:27,470
assembly instructions that I'm only

432
00:17:25,069 --> 00:17:29,720
going to find in shell code then I start

433
00:17:27,470 --> 00:17:32,090
thinking is there way that I can code

434
00:17:29,720 --> 00:17:34,400
this in a binary signature and allow me

435
00:17:32,090 --> 00:17:37,129
to match across various file types let's

436
00:17:34,400 --> 00:17:39,230
find out this one's not as easy as the

437
00:17:37,130 --> 00:17:40,880
last example though you guys can do it

438
00:17:39,230 --> 00:17:43,190
you guys can hang in there though no big

439
00:17:40,880 --> 00:17:46,270
deal we'll start with the first term

440
00:17:43,190 --> 00:17:49,149
reference Nate FS 30

441
00:17:46,270 --> 00:17:51,789
I played with a key stone I think it was

442
00:17:49,149 --> 00:17:53,709
and capstone disassemblers and

443
00:17:51,789 --> 00:17:55,720
assemblers to kind of come up with this

444
00:17:53,710 --> 00:17:57,880
pattern but typically it'll look like

445
00:17:55,720 --> 00:17:59,169
the by pattern six for a one three zeros

446
00:17:57,880 --> 00:18:02,590
there's a bit but a lot don't memorize

447
00:17:59,169 --> 00:18:04,960
it I'll share a reference later that's

448
00:18:02,590 --> 00:18:07,570
for this first term then we'll want to

449
00:18:04,960 --> 00:18:12,159
see this offset a dereference from

450
00:18:07,570 --> 00:18:13,418
offset hexadecimal xxx okay that at the

451
00:18:12,159 --> 00:18:15,399
end of the day I apologize it's still

452
00:18:13,419 --> 00:18:22,600
low at the bottom here looks like the

453
00:18:15,399 --> 00:18:25,000
pattern 8b wild-card hexadecimal C all

454
00:18:22,600 --> 00:18:26,980
right and then that third pointer

455
00:18:25,000 --> 00:18:28,809
dereference it could go to one to one if

456
00:18:26,980 --> 00:18:31,029
possible three different pointers there

457
00:18:28,809 --> 00:18:34,299
there's kind of three options offset C

458
00:18:31,029 --> 00:18:36,760
offset fourteen or offset 1c cool we can

459
00:18:34,299 --> 00:18:39,340
again encode that part of the rule

460
00:18:36,760 --> 00:18:44,049
fragment as eight B wild card and then

461
00:18:39,340 --> 00:18:46,090
one of three options neat I've taken my

462
00:18:44,049 --> 00:18:49,240
x86 I know what it does and I've

463
00:18:46,090 --> 00:18:50,740
translated that into yara a shortened

464
00:18:49,240 --> 00:18:53,289
version of the yara rule is something

465
00:18:50,740 --> 00:18:54,580
like this and the only thing that's

466
00:18:53,289 --> 00:18:55,720
really different here is i've added a

467
00:18:54,580 --> 00:18:57,699
bit of padding in between the

468
00:18:55,720 --> 00:19:00,309
instructions to allow the compiler to

469
00:18:57,700 --> 00:19:02,529
potentially reorder some surrounding

470
00:19:00,309 --> 00:19:05,620
instructions it gives me a little bit of

471
00:19:02,529 --> 00:19:09,130
leeway it's definitely a human readable

472
00:19:05,620 --> 00:19:11,260
but I've told you what it does you can

473
00:19:09,130 --> 00:19:13,090
go out on github you can email me after

474
00:19:11,260 --> 00:19:16,710
the class happy to share this rule with

475
00:19:13,090 --> 00:19:18,730
you but it looks something like this

476
00:19:16,710 --> 00:19:20,770
well do we think this one's going to

477
00:19:18,730 --> 00:19:21,399
work the last one didn't work how about

478
00:19:20,770 --> 00:19:24,668
this one

479
00:19:21,399 --> 00:19:27,279
this one does a lot better first thing I

480
00:19:24,669 --> 00:19:29,770
did I ran it against my host system I

481
00:19:27,279 --> 00:19:34,690
said what on my system matches this rule

482
00:19:29,770 --> 00:19:36,309
oh there's a lot of hits but it's not as

483
00:19:34,690 --> 00:19:38,020
many as last time and in fact when I

484
00:19:36,309 --> 00:19:39,340
look at what the hits are it's not

485
00:19:38,020 --> 00:19:41,350
different file types it's not all over

486
00:19:39,340 --> 00:19:43,720
the place it's actually just my virtual

487
00:19:41,350 --> 00:19:45,879
machine images that I use when doing

488
00:19:43,720 --> 00:19:47,620
malware analysis so I'm really only

489
00:19:45,880 --> 00:19:50,860
matching the malware that I knew that

490
00:19:47,620 --> 00:19:52,479
was on the system that's good now that I

491
00:19:50,860 --> 00:19:55,658
know that it works on my system

492
00:19:52,480 --> 00:19:59,800
I cast a wider net I ran it against one

493
00:19:55,659 --> 00:20:02,380
of our malware posit orys fetched it had

494
00:19:59,800 --> 00:20:04,659
1,200 hits which is reasonable against

495
00:20:02,380 --> 00:20:06,310
the corpus of like 30 million false

496
00:20:04,660 --> 00:20:10,720
positive rate maybe it's not so high

497
00:20:06,310 --> 00:20:12,970
there and then oh I double-checked what

498
00:20:10,720 --> 00:20:15,340
are some of those things look like man

499
00:20:12,970 --> 00:20:17,200
we see here a couple complex functions

500
00:20:15,340 --> 00:20:19,330
this is one complex function see a

501
00:20:17,200 --> 00:20:21,160
number of nested loops and if statements

502
00:20:19,330 --> 00:20:22,510
we don't care about that right now what

503
00:20:21,160 --> 00:20:24,370
we do care about is right at the start

504
00:20:22,510 --> 00:20:27,370
of the function we see that pattern that

505
00:20:24,370 --> 00:20:30,520
we're looking for FS 30 off set C off

506
00:20:27,370 --> 00:20:34,479
set 14 its parsing through the pad the

507
00:20:30,520 --> 00:20:36,629
tab loader data to resolve imports this

508
00:20:34,480 --> 00:20:39,550
is malicious this is not legitimate

509
00:20:36,630 --> 00:20:42,010
another example looks very similar the

510
00:20:39,550 --> 00:20:44,260
function is different on the whole what

511
00:20:42,010 --> 00:20:46,990
the program is doing but it has the

512
00:20:44,260 --> 00:20:48,550
snippet of malicious behavior so this is

513
00:20:46,990 --> 00:20:51,610
really good I'm feeling happy about this

514
00:20:48,550 --> 00:20:53,530
so then I say from a high level what are

515
00:20:51,610 --> 00:20:55,209
all the files that I found and how do

516
00:20:53,530 --> 00:20:58,620
they distribute like what kind of data

517
00:20:55,210 --> 00:21:01,210
is in there and this is fascinating

518
00:20:58,620 --> 00:21:04,689
these are the file types that the role

519
00:21:01,210 --> 00:21:06,550
is matching on number one entry raw

520
00:21:04,690 --> 00:21:08,890
binary data that's the shell code buffer

521
00:21:06,550 --> 00:21:12,220
that was extracted look at what the

522
00:21:08,890 --> 00:21:14,050
number two hit is word document shell

523
00:21:12,220 --> 00:21:18,310
code in word document I bet there's

524
00:21:14,050 --> 00:21:19,960
exploits in 300 documents there cool we

525
00:21:18,310 --> 00:21:23,889
also see additional Word documents zip

526
00:21:19,960 --> 00:21:28,000
archives pcaps network traffic whoa

527
00:21:23,890 --> 00:21:31,090
awesome flash data maybe there's a

528
00:21:28,000 --> 00:21:32,980
Macromedia flash exploit in there this

529
00:21:31,090 --> 00:21:34,929
is awesome I thought this was so cool we

530
00:21:32,980 --> 00:21:36,670
took a an idea that we thought could

531
00:21:34,930 --> 00:21:37,780
possibly work and we're demonstrating

532
00:21:36,670 --> 00:21:40,210
its matching many different file types

533
00:21:37,780 --> 00:21:43,510
that we now know are gonna be very very

534
00:21:40,210 --> 00:21:45,580
interesting cool so let's take one of

535
00:21:43,510 --> 00:21:47,740
these kind of unusual unusual file types

536
00:21:45,580 --> 00:21:49,270
I took one of the peak apps I said I

537
00:21:47,740 --> 00:21:51,940
don't normally deal with peak apps let's

538
00:21:49,270 --> 00:21:54,750
see what's in there it's a peak app I

539
00:21:51,940 --> 00:21:57,100
promise you i open it up in Wireshark

540
00:21:54,750 --> 00:21:58,780
what I see in Wireshark are there's some

541
00:21:57,100 --> 00:22:01,270
HTTP traffic in there and some

542
00:21:58,780 --> 00:22:03,490
additional stuff going on but when I see

543
00:22:01,270 --> 00:22:04,600
HTTP I right-click I do follow stream

544
00:22:03,490 --> 00:22:09,550
and I see the data that's flowing

545
00:22:04,600 --> 00:22:12,969
between the server and the client this

546
00:22:09,550 --> 00:22:15,159
is what I saw flowing to the client

547
00:22:12,970 --> 00:22:17,440
on my Mountain my jaw dropped I was like

548
00:22:15,160 --> 00:22:20,260
oh geez this is not good what's not good

549
00:22:17,440 --> 00:22:21,730
about this well it's HTTP traffic 200

550
00:22:20,260 --> 00:22:25,180
okay no big deal

551
00:22:21,730 --> 00:22:28,390
then we've got HTML I know HTML I'm a

552
00:22:25,180 --> 00:22:32,260
web guru I'm not but whatever I can

553
00:22:28,390 --> 00:22:34,390
parse this there's JavaScript in here

554
00:22:32,260 --> 00:22:36,520
but it's not normal JavaScript this is

555
00:22:34,390 --> 00:22:38,170
like super off its obfuscated JavaScript

556
00:22:36,520 --> 00:22:39,970
with multiple different kind of encrypt

557
00:22:38,170 --> 00:22:41,740
the office keishon layers going on

558
00:22:39,970 --> 00:22:43,750
really weird what's happening here I

559
00:22:41,740 --> 00:22:45,700
thought it was malicious I've confirmed

560
00:22:43,750 --> 00:22:47,860
it's malicious what's going on here I

561
00:22:45,700 --> 00:22:50,890
continue scrolling through the dump

562
00:22:47,860 --> 00:22:53,020
there's the traffic of network data I

563
00:22:50,890 --> 00:22:55,510
see if this binary blob doesn't even

564
00:22:53,020 --> 00:22:58,740
look like JavaScript anymore looks like

565
00:22:55,510 --> 00:23:01,420
raw binary data embedded within that is

566
00:22:58,740 --> 00:23:03,340
actually those bytes that I was looking

567
00:23:01,420 --> 00:23:06,190
for white at the top of one of these

568
00:23:03,340 --> 00:23:08,490
streams so that's where my match

569
00:23:06,190 --> 00:23:11,650
for what I think shellcode should be

570
00:23:08,490 --> 00:23:15,850
open up this little buffer here in Ida

571
00:23:11,650 --> 00:23:17,530
Pro and there it is we have the start of

572
00:23:15,850 --> 00:23:19,300
a function we have function Prolog here

573
00:23:17,530 --> 00:23:22,750
and then we have parsing through the tab

574
00:23:19,300 --> 00:23:24,190
PAB loader data resolving imports this

575
00:23:22,750 --> 00:23:24,910
is definitely shellcode it's doing

576
00:23:24,190 --> 00:23:26,170
something bad

577
00:23:24,910 --> 00:23:30,010
pulled it out of the network traffic

578
00:23:26,170 --> 00:23:31,840
cool what is it what is it doing I start

579
00:23:30,010 --> 00:23:36,160
pivoting I look on Google where did this

580
00:23:31,840 --> 00:23:37,810
come from okay it's Metasploit there's

581
00:23:36,160 --> 00:23:39,490
way too much Metasploit in the world but

582
00:23:37,810 --> 00:23:41,710
at least I'm able to trace it back here

583
00:23:39,490 --> 00:23:46,510
someone's using Metasploit specifically

584
00:23:41,710 --> 00:23:48,010
what they appeared I poked around the

585
00:23:46,510 --> 00:23:49,480
mess boy a little bit further and I

586
00:23:48,010 --> 00:23:52,120
recognize that not only did I find

587
00:23:49,480 --> 00:23:54,310
JavaScript in our stream and shellcode

588
00:23:52,120 --> 00:23:56,020
on the stream I also look at this magic

589
00:23:54,310 --> 00:23:58,179
header down there it's a PE file in the

590
00:23:56,020 --> 00:24:00,129
stream as well so we've got this whole

591
00:23:58,180 --> 00:24:02,430
like layer upon layer upon layer of

592
00:24:00,130 --> 00:24:05,290
what's going on in this this is tack

593
00:24:02,430 --> 00:24:06,850
JavaScript passing shellcode the purpose

594
00:24:05,290 --> 00:24:10,510
of the shellcode is to download an

595
00:24:06,850 --> 00:24:12,580
additional PE file do reflective loading

596
00:24:10,510 --> 00:24:17,900
on that and it does something this is a

597
00:24:12,580 --> 00:24:19,970
really neat attack here so

598
00:24:17,900 --> 00:24:21,830
I extract that file I'm pretty sure

599
00:24:19,970 --> 00:24:24,140
that's where the payload is maybe this

600
00:24:21,830 --> 00:24:26,510
is state-sponsored backdoor so I

601
00:24:24,140 --> 00:24:27,919
uploaded to virustotal just cook I

602
00:24:26,510 --> 00:24:30,400
didn't actually do that but

603
00:24:27,919 --> 00:24:33,230
reverse-engineered it's just calc see

604
00:24:30,400 --> 00:24:35,419
the legitimate calc WC that's how I know

605
00:24:33,230 --> 00:24:40,179
real hacking is going on when I see calc

606
00:24:35,419 --> 00:24:42,110
pop up I've been exploited right but

607
00:24:40,179 --> 00:24:44,029
while this might be a little bit

608
00:24:42,110 --> 00:24:46,129
disappointing not state-sponsored

609
00:24:44,029 --> 00:24:48,950
activity it is interesting and it

610
00:24:46,130 --> 00:24:53,210
validates our approach here this type of

611
00:24:48,950 --> 00:24:55,250
rule can work so what do we do push to

612
00:24:53,210 --> 00:24:56,809
production you know just throw it out

613
00:24:55,250 --> 00:24:58,370
there see what happens so we deploy it

614
00:24:56,809 --> 00:25:00,559
across our thousands of sensors around

615
00:24:58,370 --> 00:25:02,629
the world and we've been running this

616
00:25:00,559 --> 00:25:04,970
now for months and months and months and

617
00:25:02,630 --> 00:25:08,750
we've had eight false positives which is

618
00:25:04,970 --> 00:25:10,870
stunning this is a very good rule all of

619
00:25:08,750 --> 00:25:14,630
those false positives are found within

620
00:25:10,870 --> 00:25:19,549
MSDN and strangely enough in their RPC

621
00:25:14,630 --> 00:25:21,500
code we see for some reason I know it's

622
00:25:19,549 --> 00:25:23,658
a little bit small here they parse the

623
00:25:21,500 --> 00:25:25,159
tab the peb the loader data they start

624
00:25:23,659 --> 00:25:28,640
walking around and then they pass that

625
00:25:25,159 --> 00:25:30,590
data to a reg get value they look into

626
00:25:28,640 --> 00:25:32,450
the registry for something that they

627
00:25:30,590 --> 00:25:33,740
manually parsed from these data

628
00:25:32,450 --> 00:25:33,980
structures I don't know why it's doing

629
00:25:33,740 --> 00:25:37,220
this

630
00:25:33,980 --> 00:25:40,460
it's strange to me the takeaway though

631
00:25:37,220 --> 00:25:42,590
is with a false positives we can deploy

632
00:25:40,460 --> 00:25:44,390
it even more widely so we've pushed this

633
00:25:42,590 --> 00:25:46,220
out and kind of non-blocking mode across

634
00:25:44,390 --> 00:25:49,970
our fireEye devices around the world and

635
00:25:46,220 --> 00:25:51,919
since January we've seen 500 hits true

636
00:25:49,970 --> 00:25:53,840
positive hits at our clients for this

637
00:25:51,919 --> 00:25:56,470
type of technique things that wouldn't

638
00:25:53,840 --> 00:25:59,240
have been caught by other signatures

639
00:25:56,470 --> 00:26:01,399
needs we're seeing fairly good

640
00:25:59,240 --> 00:26:04,039
distribution across different matching

641
00:26:01,399 --> 00:26:06,439
engines so both on the endpoint network

642
00:26:04,039 --> 00:26:08,450
data email data the rules are working

643
00:26:06,440 --> 00:26:10,940
pretty well and then on the right-hand

644
00:26:08,450 --> 00:26:13,789
side here we can see interesting kind of

645
00:26:10,940 --> 00:26:16,279
targeting trending there I won't go into

646
00:26:13,789 --> 00:26:18,408
more detail we see a lot of people on an

647
00:26:16,279 --> 00:26:20,090
education transmitting these types of

648
00:26:18,409 --> 00:26:22,010
bytes my suspicion there is probably

649
00:26:20,090 --> 00:26:23,570
college student who's hosting Metasploit

650
00:26:22,010 --> 00:26:23,840
to get his professors or something like

651
00:26:23,570 --> 00:26:26,689
that

652
00:26:23,840 --> 00:26:30,730
I don't know but I'm feeling pretty good

653
00:26:26,690 --> 00:26:30,730
about this this this was pretty cool

654
00:26:33,159 --> 00:26:37,700
now the one of the problems that I have

655
00:26:35,899 --> 00:26:40,428
is now I have too much malware to

656
00:26:37,700 --> 00:26:42,619
analyze and one of the things about

657
00:26:40,429 --> 00:26:44,899
shellcode is it's not always as easy to

658
00:26:42,619 --> 00:26:46,789
analyze as traditional Windows PE files

659
00:26:44,899 --> 00:26:48,649
because now I have to know more about

660
00:26:46,789 --> 00:26:52,460
what is the runtime I've brought along

661
00:26:48,649 --> 00:26:54,739
why is it doing these these tricks it

662
00:26:52,460 --> 00:26:56,090
can be kind of annoying one of the thing

663
00:26:54,740 --> 00:26:58,039
that's one of the things that's annoying

664
00:26:56,090 --> 00:27:01,100
to me is this technique that's commonly

665
00:26:58,039 --> 00:27:05,119
used by by shell code of resolving

666
00:27:01,100 --> 00:27:07,908
imports not by the import name but by

667
00:27:05,119 --> 00:27:11,658
hash because shell code has an OPSEC

668
00:27:07,909 --> 00:27:13,669
problem as a forensic analyst if I find

669
00:27:11,659 --> 00:27:15,740
a file and I run strings on the file I

670
00:27:13,669 --> 00:27:18,320
can see the human readable data within

671
00:27:15,740 --> 00:27:20,600
that file and if we're resolving the

672
00:27:18,320 --> 00:27:23,450
routines that we need to execute create

673
00:27:20,600 --> 00:27:26,449
file HTTP open and they're sitting in

674
00:27:23,450 --> 00:27:27,980
the strings I immediately know probably

675
00:27:26,450 --> 00:27:30,549
what the thing is doing it's a backdoor

676
00:27:27,980 --> 00:27:33,200
it's a download or something like that

677
00:27:30,549 --> 00:27:35,289
shell code authors know this they can't

678
00:27:33,200 --> 00:27:38,240
embed those strings in plain text

679
00:27:35,289 --> 00:27:39,919
likewise in the scheme of things shell

680
00:27:38,240 --> 00:27:41,240
code is often a fairly small buffer

681
00:27:39,919 --> 00:27:42,169
especially when it's an exploit or

682
00:27:41,240 --> 00:27:45,200
something like that

683
00:27:42,169 --> 00:27:47,090
we don't have kilobytes and kilobytes of

684
00:27:45,200 --> 00:27:49,789
space to waste on the the names of

685
00:27:47,090 --> 00:27:51,408
routines that we need to resolve so a

686
00:27:49,789 --> 00:27:55,039
clever trick that Michelle could authors

687
00:27:51,409 --> 00:27:57,289
can use is to encode the routines that

688
00:27:55,039 --> 00:28:00,139
they need to resolve as hashes

689
00:27:57,289 --> 00:28:04,429
fixed-length hashes often 2 or 4 bytes

690
00:28:00,139 --> 00:28:06,289
long so what this means

691
00:28:04,429 --> 00:28:08,529
so when we run strings we don't get

692
00:28:06,289 --> 00:28:11,360
anything useful from shellcode buffers

693
00:28:08,529 --> 00:28:12,919
now the way that this will work we've

694
00:28:11,360 --> 00:28:14,590
talked about these memory structures and

695
00:28:12,919 --> 00:28:17,690
these pointers that need to be followed

696
00:28:14,590 --> 00:28:20,629
that stays the same what's different is

697
00:28:17,690 --> 00:28:23,029
that by the time we get to win HTTP DLL

698
00:28:20,629 --> 00:28:25,100
and we are walking the export table

699
00:28:23,029 --> 00:28:27,590
looking for functions that we need like

700
00:28:25,100 --> 00:28:31,070
open or closed rather than doing a

701
00:28:27,590 --> 00:28:33,230
string compare instead we have an

702
00:28:31,070 --> 00:28:36,918
embedded list of hashes that we're going

703
00:28:33,230 --> 00:28:40,639
to look for me this is crc32 or wrote a

704
00:28:36,919 --> 00:28:42,640
tripe scheme we have a list of hashes

705
00:28:40,639 --> 00:28:44,350
that we need we

706
00:28:42,640 --> 00:28:48,190
hache each one of the entries in the

707
00:28:44,350 --> 00:28:51,129
export table and then search for a match

708
00:28:48,190 --> 00:28:56,410
and then from there we have our function

709
00:28:51,130 --> 00:28:58,450
pointer what this means as a reverse

710
00:28:56,410 --> 00:29:00,370
engineer is and I'm a little bit more

711
00:28:58,450 --> 00:29:02,050
out of luck because I can open this

712
00:29:00,370 --> 00:29:05,320
thing a night of pro I can disassemble

713
00:29:02,050 --> 00:29:06,760
it but when I look at the results I see

714
00:29:05,320 --> 00:29:09,010
a lot of these really random looking

715
00:29:06,760 --> 00:29:11,379
values and none of the routines that I'm

716
00:29:09,010 --> 00:29:13,210
used to seeing an Ida Pro I'd love to

717
00:29:11,380 --> 00:29:14,830
see create file here instead I have this

718
00:29:13,210 --> 00:29:17,410
this thing and I don't know what that

719
00:29:14,830 --> 00:29:18,939
means in order to understand what does

720
00:29:17,410 --> 00:29:20,890
that number mean and what routine is

721
00:29:18,940 --> 00:29:23,770
being invoked I have to reverse engineer

722
00:29:20,890 --> 00:29:28,200
the hashing routine do a brute force

723
00:29:23,770 --> 00:29:28,200
attack and it's really annoying

724
00:29:28,830 --> 00:29:33,040
fortunately a lot of these shell code

725
00:29:31,120 --> 00:29:35,590
frameworks are have either been leaked

726
00:29:33,040 --> 00:29:37,120
or published open-source online and so

727
00:29:35,590 --> 00:29:39,310
there is a pretty good corpus out there

728
00:29:37,120 --> 00:29:41,889
of what shell code uses and what hashes

729
00:29:39,310 --> 00:29:44,110
they've picked we can take these

730
00:29:41,890 --> 00:29:46,570
routines for example here's Metasploit

731
00:29:44,110 --> 00:29:47,740
found on github I can take a look at

732
00:29:46,570 --> 00:29:49,629
their hashing routine it's right out

733
00:29:47,740 --> 00:29:50,980
there anyone can look at it and we see

734
00:29:49,630 --> 00:29:54,640
that the way that this hashing routine

735
00:29:50,980 --> 00:29:57,130
works is it's a bitwise rotate right by

736
00:29:54,640 --> 00:29:59,350
13 bits at a time go character will take

737
00:29:57,130 --> 00:30:01,300
a character rotate it XOR it with the

738
00:29:59,350 --> 00:30:04,600
next character rotate it XOR it with the

739
00:30:01,300 --> 00:30:06,970
next character bye-bye I can

740
00:30:04,600 --> 00:30:08,350
reimplemented in Python and that's what

741
00:30:06,970 --> 00:30:10,690
we've done on the Flair team we've

742
00:30:08,350 --> 00:30:12,760
basically taken every shellcode hashing

743
00:30:10,690 --> 00:30:15,580
routine that we've seen in the wild

744
00:30:12,760 --> 00:30:17,890
we've reimplemented it in Python and use

745
00:30:15,580 --> 00:30:19,600
that to create a database of all

746
00:30:17,890 --> 00:30:22,780
possible hashes that we've seen in the

747
00:30:19,600 --> 00:30:24,669
public what this means is that you can

748
00:30:22,780 --> 00:30:27,930
download this database is a sequel ID

749
00:30:24,670 --> 00:30:31,330
database on github you can download it

750
00:30:27,930 --> 00:30:34,180
you can query it and you can say hey for

751
00:30:31,330 --> 00:30:37,659
a particular hashing routine I have this

752
00:30:34,180 --> 00:30:39,580
value what does that value resolve to so

753
00:30:37,660 --> 00:30:41,200
as a reverse engineer when I'm looking

754
00:30:39,580 --> 00:30:44,260
at I had a pro and I see this really

755
00:30:41,200 --> 00:30:45,940
weird number here I can simply query the

756
00:30:44,260 --> 00:30:48,100
sequel Lite database and say what does

757
00:30:45,940 --> 00:30:49,720
that value correspond to that weird

758
00:30:48,100 --> 00:30:52,540
number corresponds to the symbol name

759
00:30:49,720 --> 00:30:55,160
Internet open and I can vary I can I can

760
00:30:52,540 --> 00:30:58,159
script this I can do this very quickly

761
00:30:55,160 --> 00:30:59,870
I can update my disassembly listing and

762
00:30:58,160 --> 00:31:01,670
have a higher-level understanding of

763
00:30:59,870 --> 00:31:06,500
what this function is doing my jobs

764
00:31:01,670 --> 00:31:08,480
easier how this is still better than

765
00:31:06,500 --> 00:31:10,610
where we were a couple years ago when I

766
00:31:08,480 --> 00:31:11,600
have to do this all by hand other

767
00:31:10,610 --> 00:31:13,669
techniques we're doing this by hand

768
00:31:11,600 --> 00:31:16,639
might involve maybe setting a breakpoint

769
00:31:13,670 --> 00:31:18,890
on this instruction debugging it until

770
00:31:16,640 --> 00:31:21,050
there and then resolving where what

771
00:31:18,890 --> 00:31:25,010
routine we're about to recall it's a

772
00:31:21,050 --> 00:31:27,500
very manual annoying process I can use

773
00:31:25,010 --> 00:31:28,879
this brute-force attack that's cool but

774
00:31:27,500 --> 00:31:30,710
again one of the issues is I have to

775
00:31:28,880 --> 00:31:32,810
manually transcribe what I see in the

776
00:31:30,710 --> 00:31:34,460
assembly and transcribe that and port

777
00:31:32,810 --> 00:31:36,530
that into Python and ensure that it's a

778
00:31:34,460 --> 00:31:38,810
one-to-one match that takes a long time

779
00:31:36,530 --> 00:31:40,340
might take hours I don't really care

780
00:31:38,810 --> 00:31:42,530
about the implementation details I don't

781
00:31:40,340 --> 00:31:44,209
want to do that I want to understand

782
00:31:42,530 --> 00:31:45,620
what is a CT protocol where is it

783
00:31:44,210 --> 00:31:48,410
connecting to who's behind this what's

784
00:31:45,620 --> 00:31:50,840
the attribution so I'd still really like

785
00:31:48,410 --> 00:31:53,470
to avoid this manual implementation of

786
00:31:50,840 --> 00:31:53,470
hashing routines

787
00:31:54,190 --> 00:32:00,890
one way that we can do this well you can

788
00:31:56,540 --> 00:32:02,420
sometimes Google for these things but

789
00:32:00,890 --> 00:32:03,800
I'd like to present one way that we can

790
00:32:02,420 --> 00:32:07,340
actually do a lot of this automatically

791
00:32:03,800 --> 00:32:11,740
and this is going to be an automated

792
00:32:07,340 --> 00:32:11,740
hash decoding reversal of the hash

793
00:32:12,730 --> 00:32:17,330
there's kind of two things I hate in

794
00:32:14,900 --> 00:32:18,560
dealing with malware I mean I like them

795
00:32:17,330 --> 00:32:20,090
I think they're technically interesting

796
00:32:18,560 --> 00:32:23,000
but I have to do it so much that it's

797
00:32:20,090 --> 00:32:25,520
boring to me the first is string

798
00:32:23,000 --> 00:32:28,370
automatic string decoding a lot of

799
00:32:25,520 --> 00:32:30,320
malware obfuscates its strings using XOR

800
00:32:28,370 --> 00:32:32,810
routines and things like that it's

801
00:32:30,320 --> 00:32:34,010
really tedious to analyze develop tool

802
00:32:32,810 --> 00:32:36,590
for dealing with out it's called floss

803
00:32:34,010 --> 00:32:38,990
it'll automatically D office gate

804
00:32:36,590 --> 00:32:41,330
strings for you really easy to use you

805
00:32:38,990 --> 00:32:42,670
should use it on every investigation ok

806
00:32:41,330 --> 00:32:44,810
that's a solved problem

807
00:32:42,670 --> 00:32:46,610
what isn't yet a solved problem is this

808
00:32:44,810 --> 00:32:48,620
automated hash resolving I still have to

809
00:32:46,610 --> 00:32:50,060
do this manually every time what's

810
00:32:48,620 --> 00:32:52,580
interesting to me though is that these

811
00:32:50,060 --> 00:32:54,590
two problems are very similar both of

812
00:32:52,580 --> 00:32:56,750
them are super tedious to do they

813
00:32:54,590 --> 00:32:58,340
involve routines that have lot of

814
00:32:56,750 --> 00:33:00,110
looping they look kind of unusual

815
00:32:58,340 --> 00:33:02,149
they look like encryption routines that

816
00:33:00,110 --> 00:33:06,020
means I can usually automatically

817
00:33:02,150 --> 00:33:07,640
identify them and they're also typically

818
00:33:06,020 --> 00:33:08,860
like referential you're transparent

819
00:33:07,640 --> 00:33:10,570
which is just a nice

820
00:33:08,860 --> 00:33:14,649
pure sciency way of saying they're easy

821
00:33:10,570 --> 00:33:18,669
to understand what that means that I can

822
00:33:14,650 --> 00:33:23,980
do is put together a script let's see if

823
00:33:18,670 --> 00:33:26,490
this works here I script up sorry I see

824
00:33:23,980 --> 00:33:26,490
what's happening

825
00:33:29,330 --> 00:33:33,350
a script that can run against shellcode

826
00:33:31,940 --> 00:33:35,239
shellcode that I don't completely

827
00:33:33,350 --> 00:33:38,779
understand that I haven't manually

828
00:33:35,239 --> 00:33:40,789
marked up that's in this for example

829
00:33:38,779 --> 00:33:42,499
Metasploit binary here it's just the raw

830
00:33:40,789 --> 00:33:44,989
shellcode buffer I have a Python script

831
00:33:42,499 --> 00:33:46,399
and a couple system deals in the same

832
00:33:44,989 --> 00:33:47,600
directory that's where I think the

833
00:33:46,399 --> 00:33:52,908
shellcode is going to be resolving

834
00:33:47,600 --> 00:33:55,699
routines from I can run my Python script

835
00:33:52,909 --> 00:33:57,440
it's going to load the Metasploit binary

836
00:33:55,700 --> 00:34:00,470
into memory and it's going to use a cpu

837
00:33:57,440 --> 00:34:02,690
emulator which is kind of like you know

838
00:34:00,470 --> 00:34:04,519
a virtual CPU it's a fake CPU and it's a

839
00:34:02,690 --> 00:34:07,669
CPU that we can interact with

840
00:34:04,519 --> 00:34:10,399
programmatically just set up our

841
00:34:07,669 --> 00:34:12,319
execution environment load Metasploit

842
00:34:10,399 --> 00:34:13,578
load some additional dll's

843
00:34:12,319 --> 00:34:18,649
and then we're just gonna let the

844
00:34:13,579 --> 00:34:21,530
shellcode run and using some tricks it's

845
00:34:18,649 --> 00:34:23,960
going to take just a moment here it's

846
00:34:21,530 --> 00:34:25,970
going to emulate the shellcode identify

847
00:34:23,960 --> 00:34:28,069
what are the hashes that the shellcode

848
00:34:25,969 --> 00:34:29,928
is going to use and need and be

849
00:34:28,069 --> 00:34:31,639
searching for and that's going to

850
00:34:29,929 --> 00:34:34,879
automatically resolve what those hashes

851
00:34:31,639 --> 00:34:36,409
are to the symbols and it's doing this

852
00:34:34,879 --> 00:34:38,299
all I'm at all automatically without me

853
00:34:36,409 --> 00:34:41,210
having to go in there manually this is

854
00:34:38,299 --> 00:34:42,199
really helpful really useful in the last

855
00:34:41,210 --> 00:34:48,290
couple minutes here I'll walk through

856
00:34:42,199 --> 00:34:52,270
how this works okay so in 15 seconds

857
00:34:48,290 --> 00:34:52,270
I've saved hours of work useful

858
00:34:56,969 --> 00:35:00,899
so how does this work under the hood

859
00:34:59,880 --> 00:35:04,589
we've kind of touched on this a couple

860
00:35:00,900 --> 00:35:08,190
times we know that the shell code will

861
00:35:04,589 --> 00:35:09,900
walk the tab the peb the loader data to

862
00:35:08,190 --> 00:35:10,440
recover the dll's that are loaded into

863
00:35:09,900 --> 00:35:12,829
memory

864
00:35:10,440 --> 00:35:17,240
it'll enumerate each of those dll's

865
00:35:12,829 --> 00:35:19,980
enumerate all the exports in those dll's

866
00:35:17,240 --> 00:35:21,509
will hash each of those entries and if

867
00:35:19,980 --> 00:35:23,700
the hash matches what we're looking for

868
00:35:21,510 --> 00:35:27,569
then we can return that symbol and call

869
00:35:23,700 --> 00:35:29,730
it directly so for example we might be

870
00:35:27,569 --> 00:35:33,060
enumerated dll's like kernel32 or win

871
00:35:29,730 --> 00:35:34,950
aina and then for each one of those will

872
00:35:33,060 --> 00:35:37,259
the exports might look like something

873
00:35:34,950 --> 00:35:39,540
create file delete file and each of

874
00:35:37,260 --> 00:35:43,859
those is going to when hashed resolved

875
00:35:39,540 --> 00:35:45,810
to strange numbers now in code this is

876
00:35:43,859 --> 00:35:49,250
actually a lot more complex when it's an

877
00:35:45,810 --> 00:35:51,660
x86 we see a bunch of nested loops here

878
00:35:49,250 --> 00:35:55,260
but the key instruction out of all of

879
00:35:51,660 --> 00:35:57,480
this is this comparison here are when

880
00:35:55,260 --> 00:36:00,720
we're comparing our hash against the

881
00:35:57,480 --> 00:36:02,700
wanted hash we don't quite know how this

882
00:36:00,720 --> 00:36:04,740
hash algorithm looks like we haven't

883
00:36:02,700 --> 00:36:07,589
reversed that but this one comparison

884
00:36:04,740 --> 00:36:09,509
here is key to our understanding it's

885
00:36:07,589 --> 00:36:11,220
actually this instruction right in the

886
00:36:09,510 --> 00:36:14,190
middle here comparison between two

887
00:36:11,220 --> 00:36:20,160
registers the computer hash against the

888
00:36:14,190 --> 00:36:22,650
query hash so the way that we can set up

889
00:36:20,160 --> 00:36:25,230
our emulator is this to exploit this

890
00:36:22,650 --> 00:36:28,079
we'll map in our our shellcode into the

891
00:36:25,230 --> 00:36:30,150
virtual CPUs memory will set up the

892
00:36:28,079 --> 00:36:32,280
memory structures to emulate to look

893
00:36:30,150 --> 00:36:34,800
like things that are like the tab the

894
00:36:32,280 --> 00:36:37,020
PAB and the loader data we'll put our

895
00:36:34,800 --> 00:36:39,300
dll's into memory so they look as they

896
00:36:37,020 --> 00:36:42,150
would in the real world we'll set up all

897
00:36:39,300 --> 00:36:43,319
the pointers correctly and then we're

898
00:36:42,150 --> 00:36:45,270
going to emulate the shellcode we're

899
00:36:43,319 --> 00:36:48,060
going to let it run until we see that

900
00:36:45,270 --> 00:36:50,119
it's actually accessing those structures

901
00:36:48,060 --> 00:36:53,119
then we know it's trying to resolve

902
00:36:50,119 --> 00:36:53,119
routines

903
00:36:54,789 --> 00:36:58,150
at that point what we're going to do is

904
00:36:56,859 --> 00:36:59,919
we're going to that one instruction that

905
00:36:58,150 --> 00:37:01,569
does the comparison we're going to

906
00:36:59,919 --> 00:37:04,328
basically taint we're going to do a

907
00:37:01,569 --> 00:37:06,130
taint on that instruction on the data

908
00:37:04,329 --> 00:37:08,709
being compared in that comparison

909
00:37:06,130 --> 00:37:10,809
because we know that on one side we had

910
00:37:08,709 --> 00:37:13,149
the computed hash for a symbol that we

911
00:37:10,809 --> 00:37:14,380
know that's in an export table and on

912
00:37:13,150 --> 00:37:16,089
the other hand we have this thing we

913
00:37:14,380 --> 00:37:21,099
don't know what it is that's what the

914
00:37:16,089 --> 00:37:22,660
shellcode is looking for now we can do

915
00:37:21,099 --> 00:37:24,689
that taint we could say this is a value

916
00:37:22,660 --> 00:37:28,449
that we're looking for

917
00:37:24,689 --> 00:37:30,009
we're in kernel32 we've enumerated the

918
00:37:28,449 --> 00:37:31,809
exports we're looking at create file

919
00:37:30,009 --> 00:37:35,859
that's the human readable symbol there

920
00:37:31,809 --> 00:37:38,079
and then what we see here is the tainted

921
00:37:35,859 --> 00:37:40,479
value here doesn't really matter but the

922
00:37:38,079 --> 00:37:43,660
malware has computed a hash and

923
00:37:40,479 --> 00:37:45,698
therefore we know create file hashes

924
00:37:43,660 --> 00:37:48,509
down to this value here one two three

925
00:37:45,699 --> 00:37:51,189
four five six seven eight interesting

926
00:37:48,509 --> 00:37:53,859
then what we can do is say what are all

927
00:37:51,189 --> 00:37:57,549
of the values seen on this side here and

928
00:37:53,859 --> 00:38:01,959
we create a list and now we see okay

929
00:37:57,549 --> 00:38:05,439
delete file that's over here nine ABCDEF

930
00:38:01,959 --> 00:38:08,558
zero and we created a big list of all

931
00:38:05,439 --> 00:38:11,739
the hash values seen on this side of the

932
00:38:08,559 --> 00:38:13,809
expression that's going to be tens of

933
00:38:11,739 --> 00:38:16,869
thousands of entries now we can take a

934
00:38:13,809 --> 00:38:20,349
step back we can take each one of those

935
00:38:16,869 --> 00:38:23,979
entries and then we can rerun the

936
00:38:20,349 --> 00:38:26,319
resolution routine providing though the

937
00:38:23,979 --> 00:38:28,718
list of the entries from that list to

938
00:38:26,319 --> 00:38:31,569
the resolution we can go back and say oh

939
00:38:28,719 --> 00:38:32,499
I saw that the malware it was looking

940
00:38:31,569 --> 00:38:35,769
for a create file

941
00:38:32,499 --> 00:38:37,448
I saw the hash that it had you know had

942
00:38:35,769 --> 00:38:40,269
generated was one two three four five

943
00:38:37,449 --> 00:38:42,400
six seven eight now I'll let the malware

944
00:38:40,269 --> 00:38:44,078
going run do its resolution routine I

945
00:38:42,400 --> 00:38:46,630
don't really care how this whole thing

946
00:38:44,079 --> 00:38:50,909
works down here I just know that the

947
00:38:46,630 --> 00:38:54,579
purpose is to resolve that strange

948
00:38:50,909 --> 00:38:57,549
complex number into this human readable

949
00:38:54,579 --> 00:38:59,259
symbol awesome and so I can work my way

950
00:38:57,549 --> 00:39:01,150
through the list of ten thousand entries

951
00:38:59,259 --> 00:39:03,339
and just let the malware do the work for

952
00:39:01,150 --> 00:39:04,749
me I actually don't really know what

953
00:39:03,339 --> 00:39:07,029
it's doing I don't care what it's doing

954
00:39:04,749 --> 00:39:08,410
all I care about is its resolving these

955
00:39:07,029 --> 00:39:11,020
shellcode hashes I don't

956
00:39:08,410 --> 00:39:15,279
have to do that work so I thought that

957
00:39:11,020 --> 00:39:17,259
was kind of interesting this point just

958
00:39:15,280 --> 00:39:18,850
a couple minutes over it's probably a

959
00:39:17,260 --> 00:39:20,950
good time to answer any questions or

960
00:39:18,850 --> 00:39:23,759
maybe even move on to the additional

961
00:39:20,950 --> 00:39:23,759
presenters today

