1
00:00:01,040 --> 00:00:07,250
okay good day everyone and thank you for

2
00:00:04,279 --> 00:00:09,920
the introduction so part of this work I

3
00:00:07,250 --> 00:00:12,590
did when while I was still a postdoc at

4
00:00:09,920 --> 00:00:15,320
K Leuven in Belgium but yeah now I'm

5
00:00:12,590 --> 00:00:19,039
doing a postdoc at NYU Abu Dhabi quite

6
00:00:15,320 --> 00:00:22,250
close by so what will my presentation be

7
00:00:19,039 --> 00:00:24,619
about well as the name implies we're

8
00:00:22,250 --> 00:00:27,920
gonna attack routers and we're gonna use

9
00:00:24,619 --> 00:00:29,270
symbolic execution so to start the

10
00:00:27,920 --> 00:00:31,880
presentation I'll first give a

11
00:00:29,270 --> 00:00:35,140
high-level overview of what symbolic

12
00:00:31,880 --> 00:00:38,539
execution is and how it works

13
00:00:35,140 --> 00:00:42,170
then we're going to extend it so we can

14
00:00:38,539 --> 00:00:44,449
symbolically analyze cryptographic

15
00:00:42,170 --> 00:00:46,819
protocols so we're going to extend it so

16
00:00:44,449 --> 00:00:49,968
we can handle cryptographic primitives

17
00:00:46,819 --> 00:00:52,010
and why are we going to do this well

18
00:00:49,969 --> 00:00:54,469
because we can then apply symbolic

19
00:00:52,010 --> 00:00:58,218
execution to the four-way handshake of

20
00:00:54,469 --> 00:01:02,749
Wi-Fi so I'm still attacking Wi-Fi I

21
00:00:58,219 --> 00:01:05,750
like attacking Wi-Fi and we found some

22
00:01:02,749 --> 00:01:07,760
vulnerabilities using this technique now

23
00:01:05,750 --> 00:01:10,010
some of these vulnerabilities are more

24
00:01:07,760 --> 00:01:12,500
on the theoretic side on some have quite

25
00:01:10,010 --> 00:01:14,690
some preconditions so I would not say

26
00:01:12,500 --> 00:01:17,180
that the takeaway of this talk is that

27
00:01:14,690 --> 00:01:20,360
we found cool new vulnerabilities it's

28
00:01:17,180 --> 00:01:22,340
mainly that we have a new technique to

29
00:01:20,360 --> 00:01:24,940
discover them that's the main

30
00:01:22,340 --> 00:01:27,650
interesting part of the work that we did

31
00:01:24,940 --> 00:01:29,300
but at the end we'll go over some of the

32
00:01:27,650 --> 00:01:31,910
results and we will explain how we can

33
00:01:29,300 --> 00:01:34,370
exploit some of these vulnerabilities to

34
00:01:31,910 --> 00:01:38,420
for example gain code execution on a

35
00:01:34,370 --> 00:01:42,830
router so let's get started with the

36
00:01:38,420 --> 00:01:44,750
first part symbolic execution and let me

37
00:01:42,830 --> 00:01:48,620
introduce it immediately by starting

38
00:01:44,750 --> 00:01:52,550
with a very concrete example our goal is

39
00:01:48,620 --> 00:01:56,780
to apply symbolic execution to network

40
00:01:52,550 --> 00:02:00,560
code so let's start with this simple

41
00:01:56,780 --> 00:02:04,760
example it's a function that receives a

42
00:02:00,560 --> 00:02:07,520
network packet in this case it will

43
00:02:04,760 --> 00:02:09,530
first validate if the header of the

44
00:02:07,520 --> 00:02:12,019
packet is valid and then it will do some

45
00:02:09,530 --> 00:02:13,330
kind of calculations based on the

46
00:02:12,019 --> 00:02:17,410
content of the packets

47
00:02:13,330 --> 00:02:18,910
so here we can see it accepts data as

48
00:02:17,410 --> 00:02:21,700
the parameter which will contain the

49
00:02:18,910 --> 00:02:24,940
payloads over the packet the content it

50
00:02:21,700 --> 00:02:27,250
has a certain length and in the first if

51
00:02:24,940 --> 00:02:30,400
test we check if the first byte equals

52
00:02:27,250 --> 00:02:32,170
one you can imagine in a protocol it

53
00:02:30,400 --> 00:02:34,180
will check the version number that is

54
00:02:32,170 --> 00:02:36,850
included in the header and if this

55
00:02:34,180 --> 00:02:39,700
version is incorrect it will simply drop

56
00:02:36,850 --> 00:02:41,890
the packets on the other hands it will

57
00:02:39,700 --> 00:02:43,570
also check the second bytes it has to be

58
00:02:41,890 --> 00:02:45,640
equal to the length of the packets on

59
00:02:43,570 --> 00:02:49,239
the floats the packet will again simply

60
00:02:45,640 --> 00:02:51,760
be dropped if then the header is valid

61
00:02:49,240 --> 00:02:55,870
it will perform some kind of calculation

62
00:02:51,760 --> 00:02:59,649
on the content of the packets and we now

63
00:02:55,870 --> 00:03:01,800
want to first or analyze code like this

64
00:02:59,650 --> 00:03:05,860
in order to discover to discover

65
00:03:01,800 --> 00:03:08,020
vulnerabilities in it now if you would

66
00:03:05,860 --> 00:03:10,810
apply traditional fuzzing here where we

67
00:03:08,020 --> 00:03:14,080
simply generate random values it can be

68
00:03:10,810 --> 00:03:16,739
a bit tricky to pass these kinds of

69
00:03:14,080 --> 00:03:19,510
conditions because we need to randomly

70
00:03:16,739 --> 00:03:22,690
hit these two conditions at the same

71
00:03:19,510 --> 00:03:24,399
time this will slow down if we use

72
00:03:22,690 --> 00:03:26,829
traditional fuzzing it will require a

73
00:03:24,400 --> 00:03:31,810
lot of time before we hit exactly those

74
00:03:26,830 --> 00:03:34,239
requirements this is where symbolic

75
00:03:31,810 --> 00:03:37,900
execution comes into play symbolic

76
00:03:34,239 --> 00:03:41,530
execution is a technique to explore all

77
00:03:37,900 --> 00:03:45,600
the paths that your code can possibly

78
00:03:41,530 --> 00:03:50,200
execute how does that work in practice

79
00:03:45,600 --> 00:03:53,829
well in practice we would mark our data

80
00:03:50,200 --> 00:03:56,109
as symbolic and then we would analyze

81
00:03:53,830 --> 00:03:59,410
the function as if it is executing on

82
00:03:56,110 --> 00:04:01,270
this symbolic data so that doesn't mean

83
00:03:59,410 --> 00:04:03,760
we can run a program as normal anymore

84
00:04:01,270 --> 00:04:06,100
we can just compile it with GCC and run

85
00:04:03,760 --> 00:04:10,179
it we need a special kind of symbolic

86
00:04:06,100 --> 00:04:12,609
execution engine the main difference

87
00:04:10,180 --> 00:04:16,390
with a normal execution of a program is

88
00:04:12,610 --> 00:04:19,870
if we now hit an if condition if we had

89
00:04:16,390 --> 00:04:22,990
a branch that is based on a symbolic

90
00:04:19,870 --> 00:04:25,400
variable for example if we look here at

91
00:04:22,990 --> 00:04:28,220
the first if condition

92
00:04:25,400 --> 00:04:30,620
since we marked our data variable s

93
00:04:28,220 --> 00:04:33,620
symbolic now the program would be

94
00:04:30,620 --> 00:04:37,400
checking is this symbolic bytes equal to

95
00:04:33,620 --> 00:04:39,500
one or not and just to recap a symbolic

96
00:04:37,400 --> 00:04:44,179
variable means that we assumed it can

97
00:04:39,500 --> 00:04:46,970
take on any valid value and here we are

98
00:04:44,180 --> 00:04:50,180
asking if it equals a certain value or

99
00:04:46,970 --> 00:04:52,789
not and to handle this we are

100
00:04:50,180 --> 00:04:57,350
essentially going to fork the execution

101
00:04:52,789 --> 00:04:59,060
of this program into both cases so we're

102
00:04:57,350 --> 00:05:01,669
going to fork it in the first case and

103
00:04:59,060 --> 00:05:04,430
we are going to assume that this first

104
00:05:01,669 --> 00:05:06,049
byte doesn't equal one and in this case

105
00:05:04,430 --> 00:05:07,970
the program would then execute the

106
00:05:06,050 --> 00:05:12,260
return function that would stop

107
00:05:07,970 --> 00:05:15,050
executing and then we also have the

108
00:05:12,260 --> 00:05:17,570
other condition namely if this first

109
00:05:15,050 --> 00:05:20,479
byte does equal one and in that case

110
00:05:17,570 --> 00:05:25,580
we're going to continue with analyzing

111
00:05:20,479 --> 00:05:28,400
the function so another way to explain

112
00:05:25,580 --> 00:05:31,340
this is if we symbolically execute the

113
00:05:28,400 --> 00:05:35,270
program we first start with one instance

114
00:05:31,340 --> 00:05:37,340
on the other execution and whenever we

115
00:05:35,270 --> 00:05:42,080
had a branch that is based on a symbolic

116
00:05:37,340 --> 00:05:44,060
value we branch into the two possible

117
00:05:42,080 --> 00:05:46,099
cases we branch where the if condition

118
00:05:44,060 --> 00:05:48,800
is true and where the if condition is

119
00:05:46,099 --> 00:05:50,539
false on that way we will be able to

120
00:05:48,800 --> 00:05:54,979
explore all possible paths that a

121
00:05:50,539 --> 00:05:58,430
program will take and when we are

122
00:05:54,979 --> 00:06:00,250
analyzing the program in this way we

123
00:05:58,430 --> 00:06:03,169
will also keep track of all the

124
00:06:00,250 --> 00:06:05,510
conditions that most holds an order for

125
00:06:03,169 --> 00:06:08,560
a program to follow a certain execution

126
00:06:05,510 --> 00:06:10,490
so what do I mean with that if I

127
00:06:08,560 --> 00:06:12,590
encounter an f-test

128
00:06:10,490 --> 00:06:15,169
I assume this if test will be true I

129
00:06:12,590 --> 00:06:17,060
will record the the condition that must

130
00:06:15,169 --> 00:06:20,719
hold an order for the program to

131
00:06:17,060 --> 00:06:22,669
actually take that F test and these

132
00:06:20,720 --> 00:06:25,130
conditions are called the path

133
00:06:22,669 --> 00:06:27,830
constraint so these are the conditions

134
00:06:25,130 --> 00:06:29,900
that the input must add higher to in

135
00:06:27,830 --> 00:06:33,529
order for the program to indeed execute

136
00:06:29,900 --> 00:06:35,000
along this way so as I mentioned in the

137
00:06:33,529 --> 00:06:37,490
first case the function would

138
00:06:35,000 --> 00:06:38,620
immediately return and in the second

139
00:06:37,490 --> 00:06:41,260
case you would

140
00:06:38,620 --> 00:06:43,930
continue analyzing our program and we

141
00:06:41,260 --> 00:06:47,110
would then hit the second condition in

142
00:06:43,930 --> 00:06:50,530
our program and this is again a branch

143
00:06:47,110 --> 00:06:53,830
based on symbolic input so we again fork

144
00:06:50,530 --> 00:06:57,640
the execution and we add both conditions

145
00:06:53,830 --> 00:07:00,150
to the path constraint and then we

146
00:06:57,640 --> 00:07:02,530
continue analyzing these parts as well

147
00:07:00,150 --> 00:07:05,560
here in the middle case we would again

148
00:07:02,530 --> 00:07:08,049
immediately hit a return value and we

149
00:07:05,560 --> 00:07:10,390
would return we would stop analyzing the

150
00:07:08,050 --> 00:07:15,960
function and on the other case we would

151
00:07:10,390 --> 00:07:18,940
continue analyzing our receive function

152
00:07:15,960 --> 00:07:21,580
so you can see here with this technique

153
00:07:18,940 --> 00:07:23,920
we really can explore all paths of an

154
00:07:21,580 --> 00:07:26,830
execution because whenever there is a

155
00:07:23,920 --> 00:07:30,300
choice about which code to execute it

156
00:07:26,830 --> 00:07:34,140
will fork to explore all possible paths

157
00:07:30,300 --> 00:07:36,460
now let's get back to our example

158
00:07:34,140 --> 00:07:38,560
assuming that these two if conditions

159
00:07:36,460 --> 00:07:42,099
are not true we would end up at the code

160
00:07:38,560 --> 00:07:46,150
below where we divide the length by the

161
00:07:42,100 --> 00:07:48,910
thirds bytes and the packets and in this

162
00:07:46,150 --> 00:07:53,109
case we have a division and we know if

163
00:07:48,910 --> 00:07:55,210
we divide by 0 we have a problem so the

164
00:07:53,110 --> 00:07:57,580
interesting now interesting thing with

165
00:07:55,210 --> 00:08:00,640
symbolic execution we can now ask our

166
00:07:57,580 --> 00:08:04,469
symbolic execution engine can this byte

167
00:08:00,640 --> 00:08:07,599
ever be equal to 0 under the current

168
00:08:04,470 --> 00:08:11,860
current path constraint so given the

169
00:08:07,600 --> 00:08:14,740
conditions that must that must be at

170
00:08:11,860 --> 00:08:15,610
higher to reach this code is it possible

171
00:08:14,740 --> 00:08:18,850
that is stirred by it

172
00:08:15,610 --> 00:08:21,850
equals 0 we can ask that to our symbolic

173
00:08:18,850 --> 00:08:25,060
execution engine engine in this case the

174
00:08:21,850 --> 00:08:30,460
answer is yes this byte can be 0 meaning

175
00:08:25,060 --> 00:08:32,530
we possibly have a vulnerability here so

176
00:08:30,460 --> 00:08:36,159
this is a quick introduction to how

177
00:08:32,530 --> 00:08:38,110
symbolic execution works and practice

178
00:08:36,159 --> 00:08:41,980
there are some tools that's already

179
00:08:38,110 --> 00:08:44,920
implemented in our case we used we used

180
00:08:41,980 --> 00:08:47,560
clean the reason why is because this

181
00:08:44,920 --> 00:08:51,370
tool is actively maintained it's fairly

182
00:08:47,560 --> 00:08:52,449
easy to change and it works on LLVM byte

183
00:08:51,370 --> 00:08:54,760
codes

184
00:08:52,450 --> 00:08:57,310
that means we can take a Java program

185
00:08:54,760 --> 00:08:59,319
we'come compiler to LLVM and we can then

186
00:08:57,310 --> 00:09:01,719
symbolically execute it we can also

187
00:08:59,320 --> 00:09:07,350
analyze C codes anything you can compile

188
00:09:01,720 --> 00:09:11,230
to LLVM this tool will support now

189
00:09:07,350 --> 00:09:13,300
symbolic execution isn't the magic tool

190
00:09:11,230 --> 00:09:18,339
that will solve all your problems

191
00:09:13,300 --> 00:09:21,339
obviously it has some limitations namely

192
00:09:18,339 --> 00:09:23,709
if you have a big program it becomes

193
00:09:21,339 --> 00:09:27,160
infeasible to explore all paths in this

194
00:09:23,709 --> 00:09:29,439
program there are just way too many on

195
00:09:27,160 --> 00:09:32,199
top of that it also cannot handle if you

196
00:09:29,440 --> 00:09:33,790
have a infinite lip in your program for

197
00:09:32,199 --> 00:09:35,979
example a while loop or if you're

198
00:09:33,790 --> 00:09:40,209
processing linked lists that can also

199
00:09:35,980 --> 00:09:43,300
cause a problem and finally another

200
00:09:40,209 --> 00:09:47,138
problem is something we call SMT query

201
00:09:43,300 --> 00:09:49,420
complexity to explain that simply

202
00:09:47,139 --> 00:09:51,699
remember in our example that we asked

203
00:09:49,420 --> 00:09:54,130
out our symbolic execution engine a

204
00:09:51,699 --> 00:09:57,130
question like can the certain condition

205
00:09:54,130 --> 00:10:00,790
hold on asking these kinds of questions

206
00:09:57,130 --> 00:10:03,939
they are answered by an by an SMT solver

207
00:10:00,790 --> 00:10:06,099
and if your program is more complex

208
00:10:03,940 --> 00:10:09,070
these questions will also become more

209
00:10:06,100 --> 00:10:12,220
complex it will take a very long time

210
00:10:09,070 --> 00:10:18,640
for your execution engine to answer and

211
00:10:12,220 --> 00:10:21,880
analyze these kinds of questions ok so

212
00:10:18,640 --> 00:10:25,560
we now want to apply this technique to

213
00:10:21,880 --> 00:10:30,279
code that uses cryptographic primitives

214
00:10:25,560 --> 00:10:35,079
now let's modify our example a bit so it

215
00:10:30,279 --> 00:10:37,269
actually uses encryption in this case we

216
00:10:35,079 --> 00:10:39,670
have our receive function again on the

217
00:10:37,269 --> 00:10:43,089
first thing that it does it will decrypt

218
00:10:39,670 --> 00:10:45,699
the data that it is receiving if the

219
00:10:43,089 --> 00:10:49,079
decryption failed it will simply exit

220
00:10:45,699 --> 00:10:51,670
and drop the packets if not it will

221
00:10:49,079 --> 00:10:53,829
process the remaining content of the

222
00:10:51,670 --> 00:10:56,050
packets for example in this case I have

223
00:10:53,829 --> 00:10:58,479
an example where this packet might

224
00:10:56,050 --> 00:11:02,439
contain some kind of commands that the

225
00:10:58,480 --> 00:11:04,899
receiver would execute now let's say we

226
00:11:02,440 --> 00:11:06,250
would blindly apply our symbolic

227
00:11:04,899 --> 00:11:09,880
execution technique

228
00:11:06,250 --> 00:11:14,380
so we're again mark the incoming data as

229
00:11:09,880 --> 00:11:16,780
being symbolic the problem now is that

230
00:11:14,380 --> 00:11:19,300
our our execution engine will also

231
00:11:16,780 --> 00:11:23,170
symbolically execute this decryption

232
00:11:19,300 --> 00:11:25,569
function and this can be very

233
00:11:23,170 --> 00:11:29,860
time-consuming for our symbolic

234
00:11:25,570 --> 00:11:32,880
execution engine to analyze and to

235
00:11:29,860 --> 00:11:35,560
understand this intuitively in a sense

236
00:11:32,880 --> 00:11:38,860
our symbolic execution engine is

237
00:11:35,560 --> 00:11:41,859
summarizing what the decryption function

238
00:11:38,860 --> 00:11:43,900
is doing and for some encryption

239
00:11:41,860 --> 00:11:46,840
algorithms this can be summarized quite

240
00:11:43,900 --> 00:11:50,970
efficiently but for other cryptographic

241
00:11:46,840 --> 00:11:52,990
protocols or cryptographic primitives

242
00:11:50,970 --> 00:11:56,260
analyzing these implementations

243
00:11:52,990 --> 00:11:58,480
symbolically can take a lot of time and

244
00:11:56,260 --> 00:12:03,010
it would really slow down our symbolic

245
00:11:58,480 --> 00:12:05,590
analysis now let's use assume that in

246
00:12:03,010 --> 00:12:08,800
this case we are using some crypto where

247
00:12:05,590 --> 00:12:12,640
we can analyze this fairly fast then the

248
00:12:08,800 --> 00:12:15,670
second problem is if we then check

249
00:12:12,640 --> 00:12:20,410
whether the decrypted plaintext can

250
00:12:15,670 --> 00:12:23,620
equal a certain value and to understand

251
00:12:20,410 --> 00:12:25,750
this intuitively we're asking the

252
00:12:23,620 --> 00:12:29,680
symbolic execution engine to reason

253
00:12:25,750 --> 00:12:32,320
about our decryption function and in a

254
00:12:29,680 --> 00:12:34,780
sense crypto is made so it's hard to

255
00:12:32,320 --> 00:12:36,580
reason about so it's hard to try to

256
00:12:34,780 --> 00:12:39,130
break it now it's a it's a bit of a

257
00:12:36,580 --> 00:12:41,740
simplification simplification but

258
00:12:39,130 --> 00:12:43,630
essentially if we would symbolically

259
00:12:41,740 --> 00:12:46,480
execute this code it would be time

260
00:12:43,630 --> 00:12:49,740
consuming meaning we won't ever reach

261
00:12:46,480 --> 00:12:54,850
the interesting part of our program

262
00:12:49,740 --> 00:12:56,680
where it's actually parsing our data so

263
00:12:54,850 --> 00:12:59,400
now the question is how can we solve

264
00:12:56,680 --> 00:13:02,680
this how can we avoid that our

265
00:12:59,400 --> 00:13:08,740
decryption function introduces all this

266
00:13:02,680 --> 00:13:10,599
overhead well it's actually really

267
00:13:08,740 --> 00:13:15,370
simple one thing we can do is we can

268
00:13:10,600 --> 00:13:17,740
simply comment it out and this would

269
00:13:15,370 --> 00:13:19,300
already work so remember if you ever

270
00:13:17,740 --> 00:13:19,920
have to do this yourself

271
00:13:19,300 --> 00:13:21,930
the

272
00:13:19,920 --> 00:13:24,599
is a very quick fix simply replace the

273
00:13:21,930 --> 00:13:26,670
decrypt function by a stop function that

274
00:13:24,600 --> 00:13:30,870
is nothing and then you already solve

275
00:13:26,670 --> 00:13:32,849
the big part of the problem now in our

276
00:13:30,870 --> 00:13:35,730
case we're going to do it a bit more

277
00:13:32,850 --> 00:13:38,160
complicated but the idea is very similar

278
00:13:35,730 --> 00:13:40,470
to this we're simply going to replace

279
00:13:38,160 --> 00:13:43,670
the output of the decrypt function with

280
00:13:40,470 --> 00:13:47,550
a fresh symbolic variable instead of

281
00:13:43,670 --> 00:13:50,040
summarizing this decrypt function so if

282
00:13:47,550 --> 00:13:54,000
you go back to our example we would now

283
00:13:50,040 --> 00:13:56,430
again mark data as symbolic but instead

284
00:13:54,000 --> 00:13:59,519
of analyzing the decrypt function we

285
00:13:56,430 --> 00:14:01,529
simply let this plain variable that

286
00:13:59,519 --> 00:14:05,990
represents the plaintext be a fresh

287
00:14:01,529 --> 00:14:09,540
symbolic variable without any special

288
00:14:05,990 --> 00:14:13,320
conditions on it and this will allows us

289
00:14:09,540 --> 00:14:17,069
to do a normal symbolic execution of the

290
00:14:13,320 --> 00:14:19,139
rest of the code now why do we create

291
00:14:17,070 --> 00:14:21,510
this fresh variable instead of simply

292
00:14:19,139 --> 00:14:24,540
coming out commenting out the decrypt

293
00:14:21,510 --> 00:14:26,189
function the reason why is because we

294
00:14:24,540 --> 00:14:28,290
can then also check some more advanced

295
00:14:26,190 --> 00:14:32,160
properties and I'll come back to that in

296
00:14:28,290 --> 00:14:34,349
a bit but the takeaway message here is

297
00:14:32,160 --> 00:14:37,050
that by doing this we can now actually

298
00:14:34,350 --> 00:14:41,970
analyze the interesting codes of our

299
00:14:37,050 --> 00:14:43,920
protocol and some apart from handling

300
00:14:41,970 --> 00:14:46,610
decryption we can also handle hash

301
00:14:43,920 --> 00:14:48,930
functions in a similar way instead of

302
00:14:46,610 --> 00:14:51,600
symbolically analyzing these hash

303
00:14:48,930 --> 00:14:54,390
functions we simply replace their output

304
00:14:51,600 --> 00:15:00,360
by a fresh symbolic variable and that's

305
00:14:54,390 --> 00:15:03,329
it and one advantage of this approach is

306
00:15:00,360 --> 00:15:06,390
that we can essentially track the usage

307
00:15:03,329 --> 00:15:09,000
of crypto primitives throughout our code

308
00:15:06,390 --> 00:15:13,769
and this will allow us to check more

309
00:15:09,000 --> 00:15:17,100
interesting properties for example one

310
00:15:13,769 --> 00:15:19,470
thing we can do is we can now also

311
00:15:17,100 --> 00:15:26,010
detect trivial side-channel

312
00:15:19,470 --> 00:15:27,690
vulnerabilities imagine for example that

313
00:15:26,010 --> 00:15:30,480
you have a packet with a certain

314
00:15:27,690 --> 00:15:32,090
authenticity tag for example a signature

315
00:15:30,480 --> 00:15:34,550
or

316
00:15:32,090 --> 00:15:36,680
the output of a hash function and then

317
00:15:34,550 --> 00:15:39,199
your implementation will compare if this

318
00:15:36,680 --> 00:15:44,479
output of the hash function equals the

319
00:15:39,200 --> 00:15:46,280
expected value and if you want to do

320
00:15:44,480 --> 00:15:48,110
this securely you should be using a

321
00:15:46,280 --> 00:15:51,290
constant time memory compare which

322
00:15:48,110 --> 00:15:52,850
always compares all the bytes on it

323
00:15:51,290 --> 00:15:55,010
shouldn't exit on the first byte

324
00:15:52,850 --> 00:16:01,370
difference because otherwise you might

325
00:15:55,010 --> 00:16:03,920
have a timing leak and by by introducing

326
00:16:01,370 --> 00:16:06,520
our fresh symbolic variables we can

327
00:16:03,920 --> 00:16:10,400
actually check if this is done properly

328
00:16:06,520 --> 00:16:12,710
we can check that either no bytes of a

329
00:16:10,400 --> 00:16:15,650
hash outputs are in the path constraints

330
00:16:12,710 --> 00:16:20,240
or whether all bytes of the hash input

331
00:16:15,650 --> 00:16:22,730
are in the path constraint because if

332
00:16:20,240 --> 00:16:24,830
there's only one bytes in the path

333
00:16:22,730 --> 00:16:29,210
constraint it means it doesn't early

334
00:16:24,830 --> 00:16:31,940
exit so if this is not completely clear

335
00:16:29,210 --> 00:16:36,530
just remember that we can detect timing

336
00:16:31,940 --> 00:16:38,180
side channels using this another thing

337
00:16:36,530 --> 00:16:42,500
that we can do with this technique is

338
00:16:38,180 --> 00:16:45,979
detect decryption Oracle's not going to

339
00:16:42,500 --> 00:16:48,020
go into too much detail here basically

340
00:16:45,980 --> 00:16:51,590
what I mean when a decryption Oracle is

341
00:16:48,020 --> 00:16:54,319
if your program decrypt data and then

342
00:16:51,590 --> 00:16:58,520
processes it without checking the

343
00:16:54,320 --> 00:17:00,110
authenticity of this data then an

344
00:16:58,520 --> 00:17:02,660
attacker can potentially abuse this

345
00:17:00,110 --> 00:17:05,660
because he can take an encrypted packet

346
00:17:02,660 --> 00:17:07,639
it can manipulate it and then forward it

347
00:17:05,660 --> 00:17:10,580
to the receiver and the receiver won't

348
00:17:07,640 --> 00:17:12,950
detect that an adversary manipulated

349
00:17:10,579 --> 00:17:14,869
with the encrypted data and in practice

350
00:17:12,950 --> 00:17:16,819
this is something that an attacker can

351
00:17:14,869 --> 00:17:24,560
abuse to for example decrypt certain

352
00:17:16,819 --> 00:17:28,700
contents okay so this was a bit more on

353
00:17:24,560 --> 00:17:31,840
the technical side but ideas now to

354
00:17:28,700 --> 00:17:37,310
apply this to the 4-way handshake of

355
00:17:31,840 --> 00:17:39,709
Wi-Fi which is used in routers so let me

356
00:17:37,310 --> 00:17:43,310
quickly introduce what a four-way

357
00:17:39,710 --> 00:17:45,890
handshake actually is and whenever you

358
00:17:43,310 --> 00:17:48,460
connect to a protected Wi-Fi network

359
00:17:45,890 --> 00:17:51,409
the four-way handshake is the thing that

360
00:17:48,460 --> 00:17:54,590
verifies that you possess the correct

361
00:17:51,409 --> 00:17:57,559
password of the network in other words

362
00:17:54,590 --> 00:17:59,209
it provides mutual authentication the

363
00:17:57,559 --> 00:18:02,149
access point verifies that you know the

364
00:17:59,210 --> 00:18:04,309
password and you verify that you are

365
00:18:02,149 --> 00:18:06,289
connecting to a legitimate network and

366
00:18:04,309 --> 00:18:09,379
that you're not connecting to the

367
00:18:06,289 --> 00:18:12,169
attacker for example and at the same

368
00:18:09,380 --> 00:18:14,809
time this handshake also negotiates what

369
00:18:12,169 --> 00:18:17,419
we call the ptk which is basically just

370
00:18:14,809 --> 00:18:20,168
a fresh session key which will be used

371
00:18:17,419 --> 00:18:24,019
to encrypt data after the handshake

372
00:18:20,169 --> 00:18:25,370
now this handshake was originally part

373
00:18:24,019 --> 00:18:27,850
of wpa2

374
00:18:25,370 --> 00:18:30,949
but I do quickly want to remark that

375
00:18:27,850 --> 00:18:33,590
even if in a few years you'll be using

376
00:18:30,950 --> 00:18:37,159
WPA 3 or maybe this year already

377
00:18:33,590 --> 00:18:42,559
then the four-way handshake is also used

378
00:18:37,159 --> 00:18:45,019
in WPA 3 this is because in WP 3 we

379
00:18:42,559 --> 00:18:47,389
first execute what we call the dragonfly

380
00:18:45,019 --> 00:18:49,130
handshake and after the dragonfly

381
00:18:47,389 --> 00:18:52,189
handshake the four-way handshake is

382
00:18:49,130 --> 00:18:53,960
still being executed so the takeaway

383
00:18:52,190 --> 00:18:59,090
message here the four way handshake is

384
00:18:53,960 --> 00:19:00,919
used both in WPA 2 and WPA 3 and to give

385
00:18:59,090 --> 00:19:04,250
a bit of a preview of the things we

386
00:19:00,919 --> 00:19:06,080
discovered we discovered some denial of

387
00:19:04,250 --> 00:19:09,850
service attacks against this handshake

388
00:19:06,080 --> 00:19:14,449
we discovered a buffer overflow and also

389
00:19:09,850 --> 00:19:16,580
decryption Oracle now some of these are

390
00:19:14,450 --> 00:19:19,700
more theoretical tacks some of these are

391
00:19:16,580 --> 00:19:23,289
more practical on we'll discuss that in

392
00:19:19,700 --> 00:19:26,809
a bit more detail later on in the talk

393
00:19:23,289 --> 00:19:30,408
in order to properly understand these

394
00:19:26,809 --> 00:19:33,260
attacks though I want to quickly explain

395
00:19:30,409 --> 00:19:37,760
how the 4 Way handshake works at a high

396
00:19:33,260 --> 00:19:40,039
level and to do that I'm going to assume

397
00:19:37,760 --> 00:19:42,559
that we have our smart phone here on the

398
00:19:40,039 --> 00:19:48,200
left that connects to the access points

399
00:19:42,559 --> 00:19:50,269
on the right and if you're connecting to

400
00:19:48,200 --> 00:19:53,029
an enterprise Wi-Fi network where you

401
00:19:50,269 --> 00:19:55,510
either authenticate using certificates

402
00:19:53,029 --> 00:19:59,539
or where you have a username or password

403
00:19:55,510 --> 00:20:02,690
then first this optional

404
00:19:59,539 --> 00:20:04,999
she called 802 dot one axis executed but

405
00:20:02,690 --> 00:20:06,769
we don't really care about this the only

406
00:20:04,999 --> 00:20:09,590
thing we care about is that there is

407
00:20:06,769 --> 00:20:11,840
some shared secrets between the client

408
00:20:09,590 --> 00:20:13,249
on the access point and if that's the

409
00:20:11,840 --> 00:20:17,978
case the four-way handshake can be

410
00:20:13,249 --> 00:20:21,859
executed so how does this handshake work

411
00:20:17,979 --> 00:20:26,450
well the first two messages of the

412
00:20:21,859 --> 00:20:30,340
handshake they are used to transport a

413
00:20:26,450 --> 00:20:33,080
random number between both devices

414
00:20:30,340 --> 00:20:35,959
so first the access point sends the

415
00:20:33,080 --> 00:20:39,168
anals to the client and here the anals

416
00:20:35,960 --> 00:20:42,409
is a random number and a non stands for

417
00:20:39,169 --> 00:20:44,359
access point nonce once the client

418
00:20:42,409 --> 00:20:46,099
received that the client will generate

419
00:20:44,359 --> 00:20:49,369
its own random number called the

420
00:20:46,099 --> 00:20:51,950
assonance where s nonce stands for a

421
00:20:49,369 --> 00:20:55,728
supplicant months on supplicant is just

422
00:20:51,950 --> 00:20:58,159
a synonym for clients essentially so

423
00:20:55,729 --> 00:21:01,700
these two devices exchange these random

424
00:20:58,159 --> 00:21:04,999
numbers and they can then combine these

425
00:21:01,700 --> 00:21:07,639
two random numbers with for example the

426
00:21:04,999 --> 00:21:09,830
pre shared key of the network to

427
00:21:07,639 --> 00:21:12,228
generate the PDK which is this session

428
00:21:09,830 --> 00:21:16,570
key which will later on be used to

429
00:21:12,229 --> 00:21:16,570
actually encrypt data that is being sent

430
00:21:17,409 --> 00:21:23,720
okay so that's the first part of the

431
00:21:20,539 --> 00:21:27,710
handshake and the second part of the

432
00:21:23,720 --> 00:21:30,320
handshake is simplified simply used to

433
00:21:27,710 --> 00:21:35,299
confirm that they now both negotiated

434
00:21:30,320 --> 00:21:38,720
the same session key there is one more

435
00:21:35,299 --> 00:21:41,450
thing that's the second phase of the

436
00:21:38,720 --> 00:21:43,700
handshake does though you can see here

437
00:21:41,450 --> 00:21:47,779
in message 3 there's also something

438
00:21:43,700 --> 00:21:51,529
called the GDK now the GDK is basically

439
00:21:47,779 --> 00:21:53,809
the group key of the network and the

440
00:21:51,529 --> 00:21:57,979
group key is used to encrypt broadcast

441
00:21:53,809 --> 00:22:01,119
on multicast traffic so the idea here is

442
00:21:57,979 --> 00:22:03,679
that when you connect to a Wi-Fi network

443
00:22:01,119 --> 00:22:05,478
the access points will give you the

444
00:22:03,679 --> 00:22:08,450
current group key that is used to

445
00:22:05,479 --> 00:22:10,990
encrypt broadcast traffic which means

446
00:22:08,450 --> 00:22:13,270
every client will then be able to

447
00:22:10,990 --> 00:22:17,500
scripts the broadcast packets that the

448
00:22:13,270 --> 00:22:19,420
access point is sending on the year the

449
00:22:17,500 --> 00:22:21,940
group he is of course being sent in an

450
00:22:19,420 --> 00:22:23,590
encrypted way because otherwise it would

451
00:22:21,940 --> 00:22:30,090
be trivial for an attacker to just

452
00:22:23,590 --> 00:22:33,730
intercept it okay so this is the main

453
00:22:30,090 --> 00:22:36,280
thing about four way handshake you need

454
00:22:33,730 --> 00:22:38,350
to know after this the keys are being

455
00:22:36,280 --> 00:22:44,129
installed and you can actually send

456
00:22:38,350 --> 00:22:46,840
encrypted data one more remark is that

457
00:22:44,130 --> 00:22:49,900
the first message of the handshake is

458
00:22:46,840 --> 00:22:52,770
sent in plaintext meaning an adversary

459
00:22:49,900 --> 00:22:55,650
can modify that but all the other

460
00:22:52,770 --> 00:22:58,990
handshakes and check messages they are

461
00:22:55,650 --> 00:23:00,670
authenticated with a Mac so in other

462
00:22:58,990 --> 00:23:03,940
words you can compare this to a

463
00:23:00,670 --> 00:23:07,320
signature an adversary won't be able to

464
00:23:03,940 --> 00:23:14,429
forge these messages because a receiver

465
00:23:07,320 --> 00:23:18,220
will detect will detect that okay so

466
00:23:14,429 --> 00:23:21,070
that's quite some background and we can

467
00:23:18,220 --> 00:23:23,730
now finally get to the interesting parts

468
00:23:21,070 --> 00:23:26,110
of the talk we can now apply this to

469
00:23:23,730 --> 00:23:31,590
implementations of the four way

470
00:23:26,110 --> 00:23:34,120
handshake and in my case I checked three

471
00:23:31,590 --> 00:23:38,100
implementations where I had access to

472
00:23:34,120 --> 00:23:42,520
the source code so I checked the IWD

473
00:23:38,100 --> 00:23:46,090
daemon and this is a very fairly recent

474
00:23:42,520 --> 00:23:50,170
Wi-Fi clients for Linux distributions I

475
00:23:46,090 --> 00:23:53,439
also checked WPS applicants that's the

476
00:23:50,170 --> 00:23:55,300
most common Wi-Fi clients on Linux it's

477
00:23:53,440 --> 00:23:59,440
used and Ubuntu on nearly all

478
00:23:55,300 --> 00:24:03,700
open-source distributions it's used also

479
00:23:59,440 --> 00:24:06,190
on your Android phone and depending on

480
00:24:03,700 --> 00:24:10,390
how you configure it it's also used on

481
00:24:06,190 --> 00:24:14,740
for example open BSD or net BSD and so

482
00:24:10,390 --> 00:24:18,400
on these two these first two example

483
00:24:14,740 --> 00:24:22,320
they run in user space I also looked at

484
00:24:18,400 --> 00:24:25,890
a kernel driver which is used in more

485
00:24:22,320 --> 00:24:29,679
proprietary implementations

486
00:24:25,890 --> 00:24:32,320
basically MediaTek accidentally leaked

487
00:24:29,680 --> 00:24:37,810
some source code and we decide to check

488
00:24:32,320 --> 00:24:39,189
the quality of that as well so what are

489
00:24:37,810 --> 00:24:43,570
the things we found in these

490
00:24:39,190 --> 00:24:47,440
implementations the first thing that we

491
00:24:43,570 --> 00:24:49,510
found is that two of them are vulnerable

492
00:24:47,440 --> 00:24:52,990
to all these timing side channels

493
00:24:49,510 --> 00:24:56,080
attacks where the implementation doesn't

494
00:24:52,990 --> 00:25:01,600
use a constant time memory compared to

495
00:24:56,080 --> 00:25:04,899
check the signature of a message in

496
00:25:01,600 --> 00:25:08,949
theory this can be used to forge your

497
00:25:04,900 --> 00:25:11,590
own messages however in practice this

498
00:25:08,950 --> 00:25:15,850
isn't really a serious vulnerability for

499
00:25:11,590 --> 00:25:18,189
two reasons the first one is that nearly

500
00:25:15,850 --> 00:25:20,639
all implementations we check they

501
00:25:18,190 --> 00:25:23,230
actually compare four bytes at a time

502
00:25:20,640 --> 00:25:28,120
meaning if we would try to abuse this

503
00:25:23,230 --> 00:25:30,280
vulnerability to to force to forge a

504
00:25:28,120 --> 00:25:33,969
packet we would need to correctly guess

505
00:25:30,280 --> 00:25:40,149
four bytes at a time and that's hard to

506
00:25:33,970 --> 00:25:43,870
do on top of that the the small timing

507
00:25:40,150 --> 00:25:45,610
difference here it's very small and not

508
00:25:43,870 --> 00:25:49,600
really you're not able to measure that

509
00:25:45,610 --> 00:25:51,459
over Wi-Fi so yes there's a bug here but

510
00:25:49,600 --> 00:25:57,429
in practice I don't think it really

511
00:25:51,460 --> 00:26:00,070
matters a second vulnerability that we

512
00:25:57,430 --> 00:26:04,870
discovered is a denial of service attack

513
00:26:00,070 --> 00:26:07,750
and this is an IWD so remember IWD is a

514
00:26:04,870 --> 00:26:11,590
is the fairly new Wi-Fi clients for

515
00:26:07,750 --> 00:26:14,650
linux and the ideas that IWD will be

516
00:26:11,590 --> 00:26:16,600
ideal if you are running if you are if

517
00:26:14,650 --> 00:26:19,960
you have a resource-constrained device

518
00:26:16,600 --> 00:26:22,449
with only a low amount of memory that's

519
00:26:19,960 --> 00:26:26,560
where people expect IWD to be used in

520
00:26:22,450 --> 00:26:30,190
the future here we found a fairly simple

521
00:26:26,560 --> 00:26:33,639
integer overflow that leads to a huge

522
00:26:30,190 --> 00:26:36,270
memory allocation that fails on then the

523
00:26:33,640 --> 00:26:41,970
client will crash

524
00:26:36,270 --> 00:26:44,879
so this is possible to exploit in

525
00:26:41,970 --> 00:26:47,970
practice by setting up a rogue access

526
00:26:44,880 --> 00:26:51,720
point and forcing the clients to connect

527
00:26:47,970 --> 00:26:54,420
to you but again in practice this is one

528
00:26:51,720 --> 00:26:56,250
not one of the texts that really is

529
00:26:54,420 --> 00:26:58,770
interesting in my opinion because you

530
00:26:56,250 --> 00:27:01,770
had a client will crash but most likely

531
00:26:58,770 --> 00:27:06,629
it will just restart IWD and there's low

532
00:27:01,770 --> 00:27:09,809
impact in practice one of the more

533
00:27:06,630 --> 00:27:13,410
interesting bucks we discovered is a

534
00:27:09,809 --> 00:27:16,879
decryption Oracle though so remember the

535
00:27:13,410 --> 00:27:20,220
decryption Oracle occurs if a receiver

536
00:27:16,880 --> 00:27:22,830
decrypts the data that is being sent but

537
00:27:20,220 --> 00:27:28,440
it doesn't verify its authenticity

538
00:27:22,830 --> 00:27:31,559
it doesn't check the signature in this

539
00:27:28,440 --> 00:27:36,120
case we found that this is this can be

540
00:27:31,559 --> 00:27:40,290
abused to decrypt the content of message

541
00:27:36,120 --> 00:27:42,510
3 so remember that message 3 it's

542
00:27:40,290 --> 00:27:45,750
contained the group key of the network

543
00:27:42,510 --> 00:27:48,059
so that means we can abuse this to

544
00:27:45,750 --> 00:27:50,370
recover the group key of the network

545
00:27:48,059 --> 00:27:53,309
meaning we can then Forge broadcast on

546
00:27:50,370 --> 00:27:54,989
multicast traffic and in practice they

547
00:27:53,309 --> 00:27:57,270
are then some tricks to actually inject

548
00:27:54,990 --> 00:28:01,050
any type of traffic you want you can

549
00:27:57,270 --> 00:28:05,670
even use the group key to inject sorry

550
00:28:01,050 --> 00:28:07,620
to inject unicast traffic now if we have

551
00:28:05,670 --> 00:28:10,620
time for this I will explain on the high

552
00:28:07,620 --> 00:28:14,669
level this attack as well but I first

553
00:28:10,620 --> 00:28:17,879
want to focus on another attack which is

554
00:28:14,670 --> 00:28:24,780
a buffer overflow in our media attack

555
00:28:17,880 --> 00:28:26,550
driver and again this bug occurs when

556
00:28:24,780 --> 00:28:31,080
handling the group key when handling

557
00:28:26,550 --> 00:28:34,080
message 3 and we will show in a bit how

558
00:28:31,080 --> 00:28:36,659
this bug can actually be used to gain

559
00:28:34,080 --> 00:28:39,030
remote code execution and you then have

560
00:28:36,660 --> 00:28:41,940
code execution in the kernel meaning you

561
00:28:39,030 --> 00:28:44,668
can completely take over the device now

562
00:28:41,940 --> 00:28:48,419
there are some preconditions to this

563
00:28:44,669 --> 00:28:49,960
attack so you won't be able to execute

564
00:28:48,419 --> 00:28:53,530
this against all devices

565
00:28:49,960 --> 00:28:58,390
but if these preconditions are met then

566
00:28:53,530 --> 00:29:00,340
you can do anything you want another

567
00:28:58,390 --> 00:29:05,590
book that we found in the media tech

568
00:29:00,340 --> 00:29:08,020
router we discovered it manually is that

569
00:29:05,590 --> 00:29:11,760
one cryptographic primitive called a s

570
00:29:08,020 --> 00:29:15,129
unwrap it was incorrectly implemented

571
00:29:11,760 --> 00:29:18,480
which meant that we could Forge messages

572
00:29:15,130 --> 00:29:22,750
that are encrypted using this primitive

573
00:29:18,480 --> 00:29:25,090
however when we looked at it they were

574
00:29:22,750 --> 00:29:27,880
really know very interesting protocols

575
00:29:25,090 --> 00:29:30,129
that we're using this primitive so this

576
00:29:27,880 --> 00:29:32,530
is again a case where it shows that our

577
00:29:30,130 --> 00:29:35,050
technique can be used to find

578
00:29:32,530 --> 00:29:36,670
vulnerabilities so I think this is a

579
00:29:35,050 --> 00:29:38,649
very this is a very interesting

580
00:29:36,670 --> 00:29:42,910
methodology but this specific

581
00:29:38,650 --> 00:29:46,600
vulnerability it's not too serious in

582
00:29:42,910 --> 00:29:51,429
practice the one that's more serious is

583
00:29:46,600 --> 00:29:54,480
our buffer overflow for example so let

584
00:29:51,429 --> 00:30:00,760
me discuss this one in a bit more detail

585
00:29:54,480 --> 00:30:04,360
so this vulnerability is triggered when

586
00:30:00,760 --> 00:30:09,070
the client receives message three three

587
00:30:04,360 --> 00:30:11,490
of the four way handshake now remember

588
00:30:09,070 --> 00:30:14,889
that message three it's authenticated

589
00:30:11,490 --> 00:30:18,250
using essentially the current password

590
00:30:14,890 --> 00:30:20,440
of the network meaning if an adversary

591
00:30:18,250 --> 00:30:22,809
wants to exploit this buffer overflow

592
00:30:20,440 --> 00:30:27,130
they need to know the password of the

593
00:30:22,809 --> 00:30:28,750
network so you might be wondering now ok

594
00:30:27,130 --> 00:30:30,510
then does this really matter in practice

595
00:30:28,750 --> 00:30:33,250
I mean if they already know the password

596
00:30:30,510 --> 00:30:37,330
isn't it don't you already have enough

597
00:30:33,250 --> 00:30:41,140
information well there are quite some

598
00:30:37,330 --> 00:30:43,570
scenarios where an adversary does know

599
00:30:41,140 --> 00:30:46,420
the password of the network on you don't

600
00:30:43,570 --> 00:30:49,120
trust them for example at a conference

601
00:30:46,420 --> 00:30:51,190
we may be using a Wi-Fi network where

602
00:30:49,120 --> 00:30:55,300
we're all using the same Wi-Fi password

603
00:30:51,190 --> 00:30:57,850
yet I don't trust the other attendees or

604
00:30:55,300 --> 00:31:00,100
for example at a hotel or a coffee shop

605
00:30:57,850 --> 00:31:02,409
you can also have that you have a Wi-Fi

606
00:31:00,100 --> 00:31:03,580
network where everyone knows the

607
00:31:02,410 --> 00:31:07,690
password and

608
00:31:03,580 --> 00:31:10,570
including people you don't trust so I

609
00:31:07,690 --> 00:31:13,120
would say that this is still a realistic

610
00:31:10,570 --> 00:31:14,889
example an adversary can know the

611
00:31:13,120 --> 00:31:21,969
password of the network you are

612
00:31:14,890 --> 00:31:24,940
connecting to now one thing that saves

613
00:31:21,970 --> 00:31:27,760
us here is that the driver that we are

614
00:31:24,940 --> 00:31:31,840
attacking is not an official part of the

615
00:31:27,760 --> 00:31:34,810
Linux source tree because if that would

616
00:31:31,840 --> 00:31:36,850
have been the case a lot of smartphones

617
00:31:34,810 --> 00:31:40,450
would probably be vulnerable but

618
00:31:36,850 --> 00:31:45,639
fortunately I mainly found this code and

619
00:31:40,450 --> 00:31:49,420
for example routers or repeaters that

620
00:31:45,640 --> 00:31:51,760
act as a client and in our case I

621
00:31:49,420 --> 00:31:54,220
exploited this vulnerability against the

622
00:31:51,760 --> 00:31:57,490
following router when it was running the

623
00:31:54,220 --> 00:31:59,650
pen oven firmware and the reason why I

624
00:31:57,490 --> 00:32:02,710
tested it against this device is because

625
00:31:59,650 --> 00:32:05,500
I already had that one and when I was

626
00:32:02,710 --> 00:32:07,210
doing the research I didn't want to buy

627
00:32:05,500 --> 00:32:10,800
all these devices on wait for it to

628
00:32:07,210 --> 00:32:14,350
arrive so what I did is I basically

629
00:32:10,800 --> 00:32:17,530
looked at commonly used firmware for

630
00:32:14,350 --> 00:32:21,399
this router and I downloaded this

631
00:32:17,530 --> 00:32:26,290
specific version which is used by quite

632
00:32:21,400 --> 00:32:29,440
some people and to determine whether

633
00:32:26,290 --> 00:32:30,280
this buffer overflow was exploitable and

634
00:32:29,440 --> 00:32:33,820
practice

635
00:32:30,280 --> 00:32:35,889
I used this target and if another device

636
00:32:33,820 --> 00:32:40,810
is running this there's a high chance

637
00:32:35,890 --> 00:32:45,220
you can exploit it in a similar way okay

638
00:32:40,810 --> 00:32:49,540
so how does the vulnerable codes look

639
00:32:45,220 --> 00:32:51,690
like well it's this complicated bunch of

640
00:32:49,540 --> 00:32:55,510
code well it looks complicated but

641
00:32:51,690 --> 00:33:00,130
there's only three lines that we really

642
00:32:55,510 --> 00:33:02,680
need to focus on we have a variable here

643
00:33:00,130 --> 00:33:06,630
that's declared on the stack of a

644
00:33:02,680 --> 00:33:10,180
limited size and then here at the

645
00:33:06,630 --> 00:33:15,520
instruction right at the bottom we copy

646
00:33:10,180 --> 00:33:17,929
content from packet 3 to this buffer on

647
00:33:15,520 --> 00:33:20,279
the stack

648
00:33:17,929 --> 00:33:21,169
so you can probably see where this is

649
00:33:20,279 --> 00:33:25,230
going

650
00:33:21,169 --> 00:33:27,869
the problem is the lengths of this

651
00:33:25,230 --> 00:33:30,090
memory köppen copy at the bottom so end

652
00:33:27,869 --> 00:33:33,570
this move memory is simply a fancy name

653
00:33:30,090 --> 00:33:35,999
for memory copy the length of this

654
00:33:33,570 --> 00:33:41,519
memory copy is completely controlled by

655
00:33:35,999 --> 00:33:45,659
the attacker meaning we have a fairly

656
00:33:41,519 --> 00:33:48,749
trivial buffer overflow because the

657
00:33:45,659 --> 00:33:55,499
destination is only 32 bytes but we can

658
00:33:48,749 --> 00:33:58,379
copy around 250 bytes here so the

659
00:33:55,499 --> 00:34:01,619
question now is ok we have this buffer

660
00:33:58,379 --> 00:34:06,178
overflow how difficult would it be to

661
00:34:01,619 --> 00:34:10,859
exploit this in practice and to answer

662
00:34:06,179 --> 00:34:13,349
that question we have to know ok where

663
00:34:10,859 --> 00:34:16,710
can we put our shell codes can we then

664
00:34:13,349 --> 00:34:20,550
jump to the shell code and are there any

665
00:34:16,710 --> 00:34:23,639
counter measures in place and it turns

666
00:34:20,550 --> 00:34:26,579
out against our targets we don't have

667
00:34:23,639 --> 00:34:29,059
stack Canaries so that already

668
00:34:26,579 --> 00:34:31,799
simplifies it a lot

669
00:34:29,059 --> 00:34:34,079
we don't have address randomization so

670
00:34:31,799 --> 00:34:38,790
we know the exact location of the stack

671
00:34:34,079 --> 00:34:42,020
and the stack is executable as well so

672
00:34:38,790 --> 00:34:46,859
if you are familiar with exploitation

673
00:34:42,020 --> 00:34:49,530
this sounds very easy to do you simply

674
00:34:46,859 --> 00:34:54,719
put your shellcode on a stack you return

675
00:34:49,530 --> 00:34:57,149
to it and you're done unfortunately when

676
00:34:54,719 --> 00:35:03,000
we actually did this our shellcode

677
00:34:57,149 --> 00:35:05,430
crashed and the strange thing is that we

678
00:35:03,000 --> 00:35:08,309
didn't do this but if you would debug

679
00:35:05,430 --> 00:35:11,609
your exploits step-by-step by attaching

680
00:35:08,309 --> 00:35:16,770
a debugger to it then your shellcode

681
00:35:11,609 --> 00:35:20,700
actually would work so what is going on

682
00:35:16,770 --> 00:35:23,849
here well the problem is something

683
00:35:20,700 --> 00:35:26,939
that's already fairly known to people

684
00:35:23,849 --> 00:35:28,980
experienced with these systems but

685
00:35:26,940 --> 00:35:30,350
what's going wrong here is a thing

686
00:35:28,980 --> 00:35:34,080
called

687
00:35:30,350 --> 00:35:37,500
incoherency so let me explain this

688
00:35:34,080 --> 00:35:40,049
what's going wrong here when we

689
00:35:37,500 --> 00:35:44,930
triggered the buffer overflow we are

690
00:35:40,050 --> 00:35:48,330
copying our shellcode to the stack and

691
00:35:44,930 --> 00:35:52,140
this means that on our specific target

692
00:35:48,330 --> 00:35:54,750
which uses a MIPS processor our

693
00:35:52,140 --> 00:35:58,160
shellcode will first be copied to the

694
00:35:54,750 --> 00:36:00,630
data cache of the processor our

695
00:35:58,160 --> 00:36:07,500
shellcode will not yet be copied to the

696
00:36:00,630 --> 00:36:11,210
main memory of our target which means if

697
00:36:07,500 --> 00:36:14,340
we now exploit this vulnerability and we

698
00:36:11,210 --> 00:36:17,220
manipulate our program to execute an

699
00:36:14,340 --> 00:36:20,280
instruction on the on the stack our

700
00:36:17,220 --> 00:36:22,680
processor will look okay is the

701
00:36:20,280 --> 00:36:25,830
shellcode already in our instruction

702
00:36:22,680 --> 00:36:28,620
cache because this processor uses a

703
00:36:25,830 --> 00:36:31,080
separate cache for data and for code for

704
00:36:28,620 --> 00:36:33,960
instructions and in this case it will

705
00:36:31,080 --> 00:36:36,540
realize okay yeah this address here on

706
00:36:33,960 --> 00:36:39,900
the stuck on the stack I don't have this

707
00:36:36,540 --> 00:36:41,910
content yet in my cache meaning I will

708
00:36:39,900 --> 00:36:44,160
have to fetch it from the main memory

709
00:36:41,910 --> 00:36:46,859
but that can still contains the old

710
00:36:44,160 --> 00:36:50,910
stack data it doesn't yet contain our

711
00:36:46,860 --> 00:36:52,770
shellcode meaning it will try to execute

712
00:36:50,910 --> 00:36:58,890
some random data on the stack on the

713
00:36:52,770 --> 00:37:02,910
tool crash so how can we solve that

714
00:36:58,890 --> 00:37:06,299
well after writing our shellcode to the

715
00:37:02,910 --> 00:37:09,690
stack we need to somehow flush this

716
00:37:06,300 --> 00:37:12,330
contents to the main memory so that if

717
00:37:09,690 --> 00:37:16,110
we then jump to the stack and our

718
00:37:12,330 --> 00:37:18,480
process processor fetches these

719
00:37:16,110 --> 00:37:21,620
instructions it will actually it will

720
00:37:18,480 --> 00:37:21,620
execute the shellcode

721
00:37:22,100 --> 00:37:29,130
so how can we flush the cache well we

722
00:37:26,670 --> 00:37:33,180
will use our a technique called return

723
00:37:29,130 --> 00:37:36,900
oriented programming on anarchist we

724
00:37:33,180 --> 00:37:40,950
used a tool of Craig Hafner to easily

725
00:37:36,900 --> 00:37:42,690
find to easily perform this in practice

726
00:37:40,950 --> 00:37:44,189
now

727
00:37:42,690 --> 00:37:46,560
it's a bit tedious to do this in

728
00:37:44,190 --> 00:37:50,339
practice I'm not going to go into detail

729
00:37:46,560 --> 00:37:52,799
here but after a bit of puzzling it is

730
00:37:50,339 --> 00:37:58,140
possible to construct a gadget that will

731
00:37:52,800 --> 00:37:59,849
flush the cache for us meaning if we

732
00:37:58,140 --> 00:38:02,368
look at the steps that we need to

733
00:37:59,849 --> 00:38:05,280
perform to exploit this we now have code

734
00:38:02,369 --> 00:38:07,980
execution in the kernel and we now want

735
00:38:05,280 --> 00:38:11,099
to spawn an easy remote shell which we

736
00:38:07,980 --> 00:38:14,220
can so we can very easily execute

737
00:38:11,099 --> 00:38:17,520
commands on the target now this will

738
00:38:14,220 --> 00:38:22,109
require some more steps the reason why

739
00:38:17,520 --> 00:38:27,060
is that we're now executing codes in the

740
00:38:22,109 --> 00:38:29,910
kernel and in that context it's a bit

741
00:38:27,060 --> 00:38:33,119
annoying to start or take over a process

742
00:38:29,910 --> 00:38:35,160
to spawn a remote shell it's a lot

743
00:38:33,119 --> 00:38:37,920
easier to do that to do this if you're

744
00:38:35,160 --> 00:38:43,740
executing code in so-called process

745
00:38:37,920 --> 00:38:46,760
context so our next step in this exploit

746
00:38:43,740 --> 00:38:51,899
chain is to obtain a process context and

747
00:38:46,760 --> 00:38:56,099
how can we do this well we can intercept

748
00:38:51,900 --> 00:38:58,740
a system call of a legitimate process so

749
00:38:56,099 --> 00:39:01,710
for example when a legitimate process is

750
00:38:58,740 --> 00:39:03,720
executing the closed system call we want

751
00:39:01,710 --> 00:39:06,390
to intercept that call in the kernel

752
00:39:03,720 --> 00:39:09,060
because then we are operating in process

753
00:39:06,390 --> 00:39:12,868
context on then things are simply easier

754
00:39:09,060 --> 00:39:18,150
to do so how do we interrupt a system

755
00:39:12,869 --> 00:39:20,400
call well the way this is implemented in

756
00:39:18,150 --> 00:39:23,550
the kernel is you have a table of all

757
00:39:20,400 --> 00:39:26,819
the system calls with a pointer to the

758
00:39:23,550 --> 00:39:30,900
code that handles these system calls on

759
00:39:26,819 --> 00:39:33,240
the ideas we simply intercept that we

760
00:39:30,900 --> 00:39:37,230
simply update a pointer to point to our

761
00:39:33,240 --> 00:39:39,598
own codes where we then perform the

762
00:39:37,230 --> 00:39:44,940
second stage or of our attack and then

763
00:39:39,599 --> 00:39:49,170
we forward to the real system call so

764
00:39:44,940 --> 00:39:52,920
the nice thing now is that we are after

765
00:39:49,170 --> 00:39:55,660
doing this we are essentially hijacking

766
00:39:52,920 --> 00:39:57,580
the closed system call

767
00:39:55,660 --> 00:40:01,000
the idea is then that we monitor all

768
00:39:57,580 --> 00:40:04,060
close system calls until an unimportant

769
00:40:01,000 --> 00:40:05,680
process executes a closed system call on

770
00:40:04,060 --> 00:40:09,250
through then going to replace that

771
00:40:05,680 --> 00:40:10,899
process with our own remote shell and we

772
00:40:09,250 --> 00:40:16,750
can simply do this by expecting the

773
00:40:10,900 --> 00:40:20,830
process identifier the PID and how can

774
00:40:16,750 --> 00:40:24,820
we then replace this nine process with

775
00:40:20,830 --> 00:40:28,830
our remote shell well we first need to

776
00:40:24,820 --> 00:40:33,480
execute M protects in our shell code to

777
00:40:28,830 --> 00:40:37,779
mark the code of the process as writable

778
00:40:33,480 --> 00:40:41,320
we then copy shell codes in a sense to

779
00:40:37,780 --> 00:40:44,710
the return address of this process so

780
00:40:41,320 --> 00:40:47,080
that when the closed system call

781
00:40:44,710 --> 00:40:49,990
finishes on the execution is handed back

782
00:40:47,080 --> 00:40:52,420
to the process it will execute our shell

783
00:40:49,990 --> 00:40:56,350
code which just replaces the process by

784
00:40:52,420 --> 00:40:58,480
something new now we are missing one

785
00:40:56,350 --> 00:41:01,029
thing here there's one more step that we

786
00:40:58,480 --> 00:41:04,000
need to do maybe some of you already

787
00:41:01,030 --> 00:41:05,260
know it it was mentioned in the talk we

788
00:41:04,000 --> 00:41:07,540
need to remember to flush the cache

789
00:41:05,260 --> 00:41:11,320
again because otherwise we have the same

790
00:41:07,540 --> 00:41:13,720
problem that we copy our shell code but

791
00:41:11,320 --> 00:41:15,460
the old instructions are still in the

792
00:41:13,720 --> 00:41:19,990
cache meaning our shell code wouldn't be

793
00:41:15,460 --> 00:41:23,080
executed so after doing all this we can

794
00:41:19,990 --> 00:41:26,229
then simply run shell codes in a simple

795
00:41:23,080 --> 00:41:29,890
user space process and we can for

796
00:41:26,230 --> 00:41:34,930
example prints we can execute down at D

797
00:41:29,890 --> 00:41:37,600
which will connect back to us now this

798
00:41:34,930 --> 00:41:40,419
will replace the original process but if

799
00:41:37,600 --> 00:41:44,920
we perform this against an unimportant

800
00:41:40,420 --> 00:41:47,140
process it won't really matter now at

801
00:41:44,920 --> 00:41:49,600
this point you may be wondering okay

802
00:41:47,140 --> 00:41:52,450
those are a lot of steps I need to

803
00:41:49,600 --> 00:41:55,920
perform is it actually possible to put

804
00:41:52,450 --> 00:42:00,220
all this shell code into a single packet

805
00:41:55,920 --> 00:42:03,880
and here we are from the attacker

806
00:42:00,220 --> 00:42:06,520
perspective quite lucky because for the

807
00:42:03,880 --> 00:42:09,039
initial States stage of the attack we

808
00:42:06,520 --> 00:42:12,640
have 250 bytes so

809
00:42:09,039 --> 00:42:16,689
250 bytes are copied to the stack that's

810
00:42:12,640 --> 00:42:20,019
enough to for the first stage of the

811
00:42:16,689 --> 00:42:22,899
attack and on top of that our full

812
00:42:20,019 --> 00:42:25,328
handshake packets can transport two

813
00:42:22,900 --> 00:42:28,209
thousand bytes so we can put our second

814
00:42:25,329 --> 00:42:32,829
stage into this handshake frame as well

815
00:42:28,209 --> 00:42:35,308
and what makes this practical is that we

816
00:42:32,829 --> 00:42:37,839
can use no bytes in our shellcode

817
00:42:35,309 --> 00:42:40,449
because we will remember we are doing a

818
00:42:37,839 --> 00:42:42,939
memory mem copy we're not doing a string

819
00:42:40,449 --> 00:42:46,359
copy so we can use null bytes

820
00:42:42,939 --> 00:42:49,769
meaning it's relatively easy to write

821
00:42:46,359 --> 00:42:53,739
short shellcode and of course it's still

822
00:42:49,769 --> 00:42:57,629
tricky to get all of this working but in

823
00:42:53,739 --> 00:43:00,819
the end you do have done a remote shell

824
00:42:57,630 --> 00:43:04,269
now there are some takeaway lessons that

825
00:43:00,819 --> 00:43:06,759
we can learn from this the first one is

826
00:43:04,269 --> 00:43:08,769
if you are exploiting for example a

827
00:43:06,759 --> 00:43:12,299
router remember that you can have the

828
00:43:08,769 --> 00:43:16,598
cache in coherence problem another

829
00:43:12,299 --> 00:43:18,729
lesson is that with more complicated

830
00:43:16,599 --> 00:43:22,209
exploits like this this it will be very

831
00:43:18,729 --> 00:43:26,319
useful to first test your IDs in C and

832
00:43:22,209 --> 00:43:29,729
then convert them to assembly another

833
00:43:26,319 --> 00:43:34,659
clever trick is to debug your shellcode

834
00:43:29,729 --> 00:43:38,618
you can use infinite while loops for

835
00:43:34,659 --> 00:43:41,079
example to see if certain points of your

836
00:43:38,619 --> 00:43:42,849
shellcode is actually reached you can

837
00:43:41,079 --> 00:43:46,359
put an infinite loop in your shellcode

838
00:43:42,849 --> 00:43:50,109
and the ideas then if you perform your

839
00:43:46,359 --> 00:43:52,569
attack and indeed this infinite loop is

840
00:43:50,109 --> 00:43:55,179
reached has reached your router we'll

841
00:43:52,569 --> 00:43:57,130
just hang and then you know okay the

842
00:43:55,179 --> 00:44:00,789
infinite loop got reached meaning all

843
00:43:57,130 --> 00:44:02,499
the code above that is correct on the

844
00:44:00,789 --> 00:44:04,359
other hand if your router crashes it

845
00:44:02,499 --> 00:44:07,618
means this infinite loop never got it

846
00:44:04,359 --> 00:44:10,479
meaning there's a bug even before that

847
00:44:07,619 --> 00:44:12,759
and finally one thing I want to mention

848
00:44:10,479 --> 00:44:16,178
is if you want to practice exploitation

849
00:44:12,759 --> 00:44:20,769
I recommend the i/o wargame at i/o dot

850
00:44:16,179 --> 00:44:23,840
net garage dot orc it's where I learned

851
00:44:20,769 --> 00:44:28,350
quite of this stuff as well

852
00:44:23,840 --> 00:44:30,150
now I included this in case I still had

853
00:44:28,350 --> 00:44:32,940
time to explain the decryption Oracle

854
00:44:30,150 --> 00:44:34,980
but I'm already running out of time so

855
00:44:32,940 --> 00:44:37,920
if you have questions about this feel

856
00:44:34,980 --> 00:44:44,400
free to ask me after the talk basically

857
00:44:37,920 --> 00:44:47,609
we found a way to exploit to exploit

858
00:44:44,400 --> 00:44:51,210
this decryption Oracle and we were then

859
00:44:47,609 --> 00:44:57,240
able to recover the group key in

860
00:44:51,210 --> 00:44:58,770
practice this is exploitable but I

861
00:44:57,240 --> 00:45:00,810
wouldn't say it's the most practical

862
00:44:58,770 --> 00:45:03,930
attack someone can carry out against the

863
00:45:00,810 --> 00:45:06,690
Wi-Fi network because if you would

864
00:45:03,930 --> 00:45:10,589
exploit this against just a single

865
00:45:06,690 --> 00:45:13,770
client then we take 8 hours in total to

866
00:45:10,590 --> 00:45:17,400
recover the group key which is a long

867
00:45:13,770 --> 00:45:19,920
time right there are ways to optimize

868
00:45:17,400 --> 00:45:22,410
the attack though we can target multiple

869
00:45:19,920 --> 00:45:25,080
clients at the same time so for example

870
00:45:22,410 --> 00:45:26,399
if you would target 8 clients at the

871
00:45:25,080 --> 00:45:29,460
same time then we would be able to

872
00:45:26,400 --> 00:45:33,510
execute this in just an hour on top of

873
00:45:29,460 --> 00:45:36,000
that this estimate of one hour assumes

874
00:45:33,510 --> 00:45:39,000
you decrypt all 16 bytes of the group

875
00:45:36,000 --> 00:45:41,930
key but in practice you can only brute

876
00:45:39,000 --> 00:45:44,490
force to force the first 12 or 10 bytes

877
00:45:41,930 --> 00:45:50,270
and then just guess the remaining

878
00:45:44,490 --> 00:45:54,600
content so the takeaway message here is

879
00:45:50,270 --> 00:45:57,720
that symbolic execution is more

880
00:45:54,600 --> 00:46:00,118
practical than it used to be this is for

881
00:45:57,720 --> 00:46:02,459
example a comic of a few years ago where

882
00:46:00,119 --> 00:46:04,950
someone wrote their own symbolic

883
00:46:02,460 --> 00:46:07,800
execution engine and after a lot of work

884
00:46:04,950 --> 00:46:09,270
they found one buck while someone else

885
00:46:07,800 --> 00:46:13,320
just wrote a very simple fuzzer

886
00:46:09,270 --> 00:46:18,390
and yet they found more bugs I would say

887
00:46:13,320 --> 00:46:20,730
this situation is now changing symbolic

888
00:46:18,390 --> 00:46:24,089
execution tools definitely still have

889
00:46:20,730 --> 00:46:26,910
their limits but I think it's by this

890
00:46:24,090 --> 00:46:29,090
point useful to take a critical

891
00:46:26,910 --> 00:46:32,670
component of your program and then

892
00:46:29,090 --> 00:46:35,160
symbolically analyze that for example to

893
00:46:32,670 --> 00:46:38,930
symbolically analyze code that processes

894
00:46:35,160 --> 00:46:38,930
incoming data from a network

895
00:46:39,350 --> 00:46:43,680
so that's the takeaway message here we

896
00:46:41,880 --> 00:46:46,350
applied symbolic execution to

897
00:46:43,680 --> 00:46:48,779
cryptographic protocols we found some

898
00:46:46,350 --> 00:46:51,810
vulnerabilities on we believe this is an

899
00:46:48,780 --> 00:46:54,000
interesting technique so if there are

900
00:46:51,810 --> 00:46:57,440
any questions or least if we have time

901
00:46:54,000 --> 00:46:57,440
for them feel free to ask

