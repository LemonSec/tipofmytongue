1
00:00:01,270 --> 00:00:07,270
today I'm going to talk about practical

2
00:00:04,090 --> 00:00:12,879
uses for memory visualization my name is

3
00:00:07,270 --> 00:00:15,459
Lou frisk and I'm going to I'm going to

4
00:00:12,880 --> 00:00:18,189
start with a short introduction to my

5
00:00:15,460 --> 00:00:20,829
previous work and also some background

6
00:00:18,189 --> 00:00:22,509
then we'll jump straight into what the

7
00:00:20,829 --> 00:00:25,570
PCL each and the memory process

8
00:00:22,509 --> 00:00:28,000
filesystem is then we'll talk about two

9
00:00:25,570 --> 00:00:30,099
different use cases first how I used an

10
00:00:28,000 --> 00:00:33,059
earlier version of the software in order

11
00:00:30,099 --> 00:00:35,710
to find a total meltdown in Windows 7

12
00:00:33,059 --> 00:00:37,839
then we'll have a look how other people

13
00:00:35,710 --> 00:00:40,030
have been using modified versions of my

14
00:00:37,840 --> 00:00:42,730
software in order to do hardware

15
00:00:40,030 --> 00:00:44,500
assisted cheating in games after that

16
00:00:42,730 --> 00:00:47,678
we'll go more in depth we'll have a look

17
00:00:44,500 --> 00:00:50,109
at its capabilities its API the design

18
00:00:47,679 --> 00:00:52,480
and the plug-in functionality try to

19
00:00:50,109 --> 00:00:54,850
presentation I will do demos lots of

20
00:00:52,480 --> 00:00:56,519
demos live demos so let's help

21
00:00:54,850 --> 00:00:59,409
everything is working

22
00:00:56,519 --> 00:01:01,568
my name is Sol frisk I'm working as a

23
00:00:59,409 --> 00:01:04,179
pen tester by day in Stockholm Sweden

24
00:01:01,569 --> 00:01:07,750
and I also try to do some security

25
00:01:04,180 --> 00:01:09,850
research by night I'm the author of the

26
00:01:07,750 --> 00:01:13,060
PCL each direct memory access attack

27
00:01:09,850 --> 00:01:16,089
toolkit which represented almost three

28
00:01:13,060 --> 00:01:18,460
years ago at Def Con I found it's really

29
00:01:16,090 --> 00:01:22,119
low-cost piece of hardware I was able to

30
00:01:18,460 --> 00:01:25,000
do direct memory access DMA over PCI

31
00:01:22,119 --> 00:01:27,969
Express it didn't require any drivers on

32
00:01:25,000 --> 00:01:30,369
the target and with this really low cost

33
00:01:27,969 --> 00:01:33,309
piece of hardware I was able to do well

34
00:01:30,369 --> 00:01:35,140
over 150 megabytes per second reading

35
00:01:33,310 --> 00:01:37,869
the main memory of the target computer

36
00:01:35,140 --> 00:01:41,170
over PCI Express and also Brighton to

37
00:01:37,869 --> 00:01:43,659
the memory unfortunately this piece of

38
00:01:41,170 --> 00:01:46,689
hardware even though it was really fast

39
00:01:43,659 --> 00:01:49,240
and low-cost and it only was able to

40
00:01:46,689 --> 00:01:53,079
access memory below for jig's since it's

41
00:01:49,240 --> 00:01:55,179
only supported 32-bit addressing but at

42
00:01:53,079 --> 00:01:57,178
that point in time that was not really a

43
00:01:55,180 --> 00:02:00,250
big problem since I was able to

44
00:01:57,179 --> 00:02:02,320
successfully attack most major operating

45
00:02:00,250 --> 00:02:04,659
systems anyway

46
00:02:02,320 --> 00:02:07,059
operating systems improved and also the

47
00:02:04,659 --> 00:02:09,250
forging limit was very boring and this

48
00:02:07,060 --> 00:02:11,650
Hardware it became really popular so

49
00:02:09,250 --> 00:02:14,350
it's sold out as well so that's why I

50
00:02:11,650 --> 00:02:15,130
introduced public FPGA based DMA

51
00:02:14,350 --> 00:02:17,980
attacking

52
00:02:15,130 --> 00:02:22,030
at this ECC a little bit over one and a

53
00:02:17,980 --> 00:02:24,340
half years ago and and everything that

54
00:02:22,030 --> 00:02:26,890
I've been doing up until now it's 100%

55
00:02:24,340 --> 00:02:30,820
open-source and everything is available

56
00:02:26,890 --> 00:02:33,519
on my github page but today we'll have a

57
00:02:30,820 --> 00:02:36,549
look at the memory process filesystem

58
00:02:33,520 --> 00:02:39,340
which is a memory analysis tool with a

59
00:02:36,550 --> 00:02:42,280
strong windows focus it allows you to

60
00:02:39,340 --> 00:02:46,360
visualize in memory objects as files and

61
00:02:42,280 --> 00:02:50,200
folders in a file system it comes with a

62
00:02:46,360 --> 00:02:52,210
C and Python API and if I look at its

63
00:02:50,200 --> 00:02:55,000
its multi-threaded its multi-threaded

64
00:02:52,210 --> 00:02:57,700
core together with native C code and

65
00:02:55,000 --> 00:03:00,370
some intelligent parsing in there it's

66
00:02:57,700 --> 00:03:02,980
really fast it also comes with a wide

67
00:03:00,370 --> 00:03:04,660
range of memory acquisition methods not

68
00:03:02,980 --> 00:03:07,600
just the hardware based ones we are

69
00:03:04,660 --> 00:03:11,290
talking about earlier but also software

70
00:03:07,600 --> 00:03:15,489
based ones so let's do our first demo

71
00:03:11,290 --> 00:03:18,640
for today let's mount a memory dump

72
00:03:15,490 --> 00:03:21,100
image created by Matt's awesome

73
00:03:18,640 --> 00:03:23,619
dump it to let's mount it by

74
00:03:21,100 --> 00:03:29,470
double-clicking on it and do some really

75
00:03:23,620 --> 00:03:32,980
easy pointing click memory forensics so

76
00:03:29,470 --> 00:03:35,500
this is a memory dump image it's 32 gigs

77
00:03:32,980 --> 00:03:38,619
big so let's have a look at it let's

78
00:03:35,500 --> 00:03:41,560
analyze it let's double click on it it

79
00:03:38,620 --> 00:03:44,530
says it's mounted and if you click into

80
00:03:41,560 --> 00:03:47,650
the M drive as it's mounted as in the

81
00:03:44,530 --> 00:03:49,540
root folder you see the PMM file which

82
00:03:47,650 --> 00:03:52,420
is basically a copy of the physical

83
00:03:49,540 --> 00:03:55,690
memory it's not really interesting and

84
00:03:52,420 --> 00:03:59,619
if you're mounting a memory dump file as

85
00:03:55,690 --> 00:04:02,400
you do yes I'm doing now but imagine if

86
00:03:59,620 --> 00:04:05,050
you're acquiring memory using the FPGA

87
00:04:02,400 --> 00:04:07,810
hardware for example or acquiring the

88
00:04:05,050 --> 00:04:09,220
remote memory we have a statist

89
00:04:07,810 --> 00:04:12,370
directory which contains various

90
00:04:09,220 --> 00:04:14,200
configuration options and but more

91
00:04:12,370 --> 00:04:17,350
interestingly we do have it the names

92
00:04:14,200 --> 00:04:20,649
folder which contains each process on

93
00:04:17,350 --> 00:04:22,930
the running system as a directory just

94
00:04:20,649 --> 00:04:26,580
click into let's click into the explore

95
00:04:22,930 --> 00:04:28,020
directory and in each process directory

96
00:04:26,580 --> 00:04:29,818
we do

97
00:04:28,020 --> 00:04:32,669
a couple of files that we can have a

98
00:04:29,819 --> 00:04:36,979
look at and they have the base address

99
00:04:32,669 --> 00:04:42,299
of the director table base CR tree and

100
00:04:36,979 --> 00:04:44,370
we have the memory map which is again by

101
00:04:42,300 --> 00:04:48,479
walking the actual page tables that the

102
00:04:44,370 --> 00:04:50,699
CPU uses and this is all done by parsing

103
00:04:48,479 --> 00:04:54,840
physical memory and you also try to

104
00:04:50,699 --> 00:04:57,330
author identify what this memory is if

105
00:04:54,840 --> 00:05:02,880
it's for example here or if it's belongs

106
00:04:57,330 --> 00:05:05,130
to some process Explorer in this case we

107
00:05:02,880 --> 00:05:07,650
also do have files for the entire

108
00:05:05,130 --> 00:05:10,469
virtual memory just open it in your

109
00:05:07,650 --> 00:05:13,049
favorite text editor have a look at it

110
00:05:10,470 --> 00:05:15,599
to search for stuff in the memory or if

111
00:05:13,050 --> 00:05:18,090
you're using FPGA Hardware you can hit

112
00:05:15,599 --> 00:05:20,699
save as well and then you will write to

113
00:05:18,090 --> 00:05:22,859
virtual memory of that process and it

114
00:05:20,699 --> 00:05:27,810
will be reflected down into physical

115
00:05:22,860 --> 00:05:30,900
memory we have a couple of subfolders as

116
00:05:27,810 --> 00:05:34,110
well we have a Python subfolder which

117
00:05:30,900 --> 00:05:36,539
allows any user to code their own Python

118
00:05:34,110 --> 00:05:40,139
plugins quite easily and just drop the

119
00:05:36,539 --> 00:05:42,270
Python plugins in the program folder of

120
00:05:40,139 --> 00:05:45,210
the file system and it will show up in

121
00:05:42,270 --> 00:05:47,698
this case it provides like a small

122
00:05:45,210 --> 00:05:50,909
Python module provides easy access to

123
00:05:47,699 --> 00:05:52,710
the e process structure and in the

124
00:05:50,909 --> 00:05:55,530
kernel and we can just have a look at it

125
00:05:52,710 --> 00:05:58,250
by just clicking on files more

126
00:05:55,530 --> 00:06:00,989
interestingly we do have a modules

127
00:05:58,250 --> 00:06:04,020
subfolder to each process as well and

128
00:06:00,990 --> 00:06:06,740
here you see did all the loaded deals in

129
00:06:04,020 --> 00:06:11,190
the process and you can analyze them

130
00:06:06,740 --> 00:06:13,979
live by just clicking into the subfolder

131
00:06:11,190 --> 00:06:17,009
we can have a look at its exported

132
00:06:13,979 --> 00:06:19,800
functions imported functions here we see

133
00:06:17,009 --> 00:06:22,080
the exported functions where the

134
00:06:19,800 --> 00:06:25,919
function names and the memory address

135
00:06:22,080 --> 00:06:27,900
they're exported at we have a look at

136
00:06:25,919 --> 00:06:30,120
the imported function as well we can

137
00:06:27,900 --> 00:06:33,690
have a look at the sections for example

138
00:06:30,120 --> 00:06:37,589
executable sections text only sections

139
00:06:33,690 --> 00:06:40,199
and things like that but if we wish to

140
00:06:37,589 --> 00:06:42,250
do edits of a section we can also go

141
00:06:40,199 --> 00:06:45,040
into a subfolder

142
00:06:42,250 --> 00:06:48,340
we can open it in the favorite text

143
00:06:45,040 --> 00:06:52,300
editor whatever and have a look at it if

144
00:06:48,340 --> 00:06:53,109
we so should wish so that's a quick look

145
00:06:52,300 --> 00:07:00,720
at it

146
00:06:53,110 --> 00:07:03,540
guests should disable sound here yeah

147
00:07:00,720 --> 00:07:06,310
this wasn't backed by physical memory

148
00:07:03,540 --> 00:07:08,020
but if it's backed by physical memory

149
00:07:06,310 --> 00:07:11,350
you can click into it have a look at it

150
00:07:08,020 --> 00:07:14,229
and we can actually edit the binary data

151
00:07:11,350 --> 00:07:16,390
and we hit save and if you birth left it

152
00:07:14,230 --> 00:07:18,790
down into memory if you're running with

153
00:07:16,390 --> 00:07:28,870
the FPGA devices where we have bright

154
00:07:18,790 --> 00:07:30,730
capabilities so let's continue so doing

155
00:07:28,870 --> 00:07:34,330
analysis with a hardware device it's

156
00:07:30,730 --> 00:07:37,090
really powerful and in this example here

157
00:07:34,330 --> 00:07:40,479
I do have an analysis computer which is

158
00:07:37,090 --> 00:07:44,349
connected over USB 3 on two really big

159
00:07:40,480 --> 00:07:46,330
Xilinx FPGA development board they exist

160
00:07:44,350 --> 00:07:49,000
smaller boards as well as we will see

161
00:07:46,330 --> 00:07:52,000
later on and then you have PCI Express

162
00:07:49,000 --> 00:07:54,700
to the ThinkPad or Express card in this

163
00:07:52,000 --> 00:07:57,729
case in order to read and write memory

164
00:07:54,700 --> 00:08:01,150
of the target system I do in software on

165
00:07:57,729 --> 00:08:03,669
my analysis computer construct a PCI

166
00:08:01,150 --> 00:08:06,849
Express transaction layer packet PCI

167
00:08:03,669 --> 00:08:09,250
Express is a packet based I construct a

168
00:08:06,850 --> 00:08:11,229
memory read packet in this example I've

169
00:08:09,250 --> 00:08:13,780
wrap it in some extra metadata which

170
00:08:11,229 --> 00:08:17,229
allows it me to transmit it over USB 3

171
00:08:13,780 --> 00:08:19,289
on to the FPGA the FPGA then takes the

172
00:08:17,229 --> 00:08:23,080
PCI Express transaction layer packet

173
00:08:19,290 --> 00:08:25,979
unpacks it and put the raw PLP packet on

174
00:08:23,080 --> 00:08:29,229
the piece express of the target system

175
00:08:25,979 --> 00:08:31,030
once the piece Express packet reaches

176
00:08:29,229 --> 00:08:33,370
the route complex of the target system

177
00:08:31,030 --> 00:08:35,740
it sees that it's a read packet memory

178
00:08:33,370 --> 00:08:38,679
read packet so it's reads from the

179
00:08:35,740 --> 00:08:41,620
physical memory of the target system and

180
00:08:38,679 --> 00:08:43,359
responds with a PCI Express transaction

181
00:08:41,620 --> 00:08:45,670
layer packet which it's a completion

182
00:08:43,360 --> 00:08:48,580
packet in this case which contains the

183
00:08:45,670 --> 00:08:51,670
actual data read and it's responds with

184
00:08:48,580 --> 00:08:53,440
it back to the FPGA and the FPGA

185
00:08:51,670 --> 00:08:54,680
forwards its back to the analysis

186
00:08:53,440 --> 00:08:56,510
computer

187
00:08:54,680 --> 00:09:01,910
right thing works pretty much the same

188
00:08:56,510 --> 00:09:05,029
way and this is really powerful so let's

189
00:09:01,910 --> 00:09:08,000
continue to a couple of use cases first

190
00:09:05,029 --> 00:09:10,550
have a look at how I used an early

191
00:09:08,000 --> 00:09:13,220
version of the memory process file

192
00:09:10,550 --> 00:09:16,640
system in order to locate a total

193
00:09:13,220 --> 00:09:18,860
meltdown in Windows 7 it was a local

194
00:09:16,640 --> 00:09:21,260
privilege escalation vulnerability which

195
00:09:18,860 --> 00:09:24,260
allowed any user to escalate the kernel

196
00:09:21,260 --> 00:09:26,660
trivially it allowed Orbiter of physical

197
00:09:24,260 --> 00:09:30,370
memory reads and writes at gigabytes per

198
00:09:26,660 --> 00:09:33,529
second it only affected Windows 7 and

199
00:09:30,370 --> 00:09:36,500
2008 r2 and it was something that was

200
00:09:33,529 --> 00:09:39,740
introduced in the mountain patches from

201
00:09:36,500 --> 00:09:42,529
from January last year but it looked

202
00:09:39,740 --> 00:09:46,490
like it was patched in March last year

203
00:09:42,529 --> 00:09:48,410
yester before I found it and I didn't

204
00:09:46,490 --> 00:09:51,170
see anything in the release notes from

205
00:09:48,410 --> 00:09:52,819
Microsoft nsrc and I thought that was

206
00:09:51,170 --> 00:09:55,760
really strange since they usually do

207
00:09:52,820 --> 00:09:59,540
give some credit to researchers or

208
00:09:55,760 --> 00:10:02,029
anyway I put up a CV at the but they

209
00:09:59,540 --> 00:10:04,279
didn't do this for this one so I wrote

210
00:10:02,029 --> 00:10:06,140
them an email and told them I want to

211
00:10:04,279 --> 00:10:08,660
publish a blog entry about this I found

212
00:10:06,140 --> 00:10:10,490
this really interesting is it ok and

213
00:10:08,660 --> 00:10:12,620
they were like yeah let's check with our

214
00:10:10,490 --> 00:10:14,690
engineering team and they responded the

215
00:10:12,620 --> 00:10:16,279
day afterwards and was like yeah it's

216
00:10:14,690 --> 00:10:18,950
totally ok to publish this blog entry

217
00:10:16,279 --> 00:10:21,620
and in order to make it a little bit

218
00:10:18,950 --> 00:10:25,010
more interesting I decided to publish a

219
00:10:21,620 --> 00:10:27,680
proof-of-concept as well and only

220
00:10:25,010 --> 00:10:30,140
problem was it wasn't fixed and I

221
00:10:27,680 --> 00:10:32,000
released a traveler exploitable kernel

222
00:10:30,140 --> 00:10:35,449
zero-day with the permission of

223
00:10:32,000 --> 00:10:37,220
Microsoft it was actually fixed if you

224
00:10:35,450 --> 00:10:39,260
were running with administrative

225
00:10:37,220 --> 00:10:43,100
privileges or if you were running as

226
00:10:39,260 --> 00:10:45,439
system it was however not fixed if you

227
00:10:43,100 --> 00:10:48,290
were running as a normal low privileged

228
00:10:45,440 --> 00:10:51,620
user and since I ran everything in my

229
00:10:48,290 --> 00:10:54,829
test case as admin elector and Steffes

230
00:10:51,620 --> 00:10:57,170
admin on my test systems and I didn't

231
00:10:54,830 --> 00:11:01,130
spot this one and neither did Microsoft

232
00:10:57,170 --> 00:11:03,170
beforehand anyway really lucky here they

233
00:11:01,130 --> 00:11:05,510
managed to scramble and they came up

234
00:11:03,170 --> 00:11:08,150
with an out-of-band patch for the kernel

235
00:11:05,510 --> 00:11:10,640
itself yes two days after

236
00:11:08,150 --> 00:11:12,800
released my initial blog entry and I

237
00:11:10,640 --> 00:11:15,530
think that's really super fast response

238
00:11:12,800 --> 00:11:17,240
time and for doing stuff in the kernel

239
00:11:15,530 --> 00:11:20,900
so really thank you to Microsoft for

240
00:11:17,240 --> 00:11:23,780
that one but let's do a demo let's show

241
00:11:20,900 --> 00:11:26,300
how I came to find this total melt or

242
00:11:23,780 --> 00:11:29,209
burn ability let's locate it by looking

243
00:11:26,300 --> 00:11:32,599
at the memory map we had a look at while

244
00:11:29,210 --> 00:11:35,960
ago and India will see that the PML for

245
00:11:32,600 --> 00:11:38,240
which is the topmost paging structure in

246
00:11:35,960 --> 00:11:42,820
the page tables it's self referential

247
00:11:38,240 --> 00:11:42,820
entry was mapped straight into user mode

248
00:11:44,440 --> 00:11:53,210
so I should have a vulnerable virtual

249
00:11:47,540 --> 00:11:56,329
machine here so let's start it let's

250
00:11:53,210 --> 00:11:58,190
mount the memory process filesystem I'm

251
00:11:56,330 --> 00:12:00,200
shooting a little bit here today since

252
00:11:58,190 --> 00:12:02,420
I'm using the actual vulnerability to

253
00:12:00,200 --> 00:12:04,910
you if mount the filesystem when I was

254
00:12:02,420 --> 00:12:08,120
researching this I was using the FPGA

255
00:12:04,910 --> 00:12:10,550
hardware but once we have the file

256
00:12:08,120 --> 00:12:13,280
system mounted we can click into some

257
00:12:10,550 --> 00:12:17,030
folder for example a CMV folder and have

258
00:12:13,280 --> 00:12:19,790
a look at this memory map in here it

259
00:12:17,030 --> 00:12:22,220
looks kinda normal identify some heaps

260
00:12:19,790 --> 00:12:25,099
and some binaries and this is how it

261
00:12:22,220 --> 00:12:28,520
should look like so nothing strange here

262
00:12:25,100 --> 00:12:31,040
until I scroll down at the end I see a

263
00:12:28,520 --> 00:12:33,890
lots of addresses starting with 4 FS

264
00:12:31,040 --> 00:12:37,250
here which are read/write/execute

265
00:12:33,890 --> 00:12:39,949
but they are not a supervisor so they

266
00:12:37,250 --> 00:12:41,900
are not colonel here and adversity

267
00:12:39,950 --> 00:12:44,060
starting with lots of apps they're

268
00:12:41,900 --> 00:12:46,120
traditionally reserved for the kernel

269
00:12:44,060 --> 00:12:49,069
itself they don't have to be really

270
00:12:46,120 --> 00:12:50,810
according to Intel and but in Windows

271
00:12:49,070 --> 00:12:52,880
they should be reserved for the kernel

272
00:12:50,810 --> 00:12:55,280
and this is really strange that I see

273
00:12:52,880 --> 00:12:58,280
these memory addresses in my process

274
00:12:55,280 --> 00:13:02,839
memory space there was what is going on

275
00:12:58,280 --> 00:13:04,010
here I was also able to dump memory at

276
00:13:02,840 --> 00:13:06,680
very high speeds

277
00:13:04,010 --> 00:13:08,689
so let's it wrote up the

278
00:13:06,680 --> 00:13:11,390
proof-of-concept I wrote it from my PC

279
00:13:08,690 --> 00:13:14,590
LH program so let's try to dump the

280
00:13:11,390 --> 00:13:17,960
memory of this vulnerable system and

281
00:13:14,590 --> 00:13:19,970
dumping memory it's quite fast I can

282
00:13:17,960 --> 00:13:22,010
dump memory at around a couple of

283
00:13:19,970 --> 00:13:24,650
gigabytes per second here

284
00:13:22,010 --> 00:13:26,990
I was also able to execute the evil

285
00:13:24,650 --> 00:13:33,829
kernel implants and insert them into the

286
00:13:26,990 --> 00:13:36,140
kernel if it's yeah I held execution

287
00:13:33,830 --> 00:13:39,650
here I've inserted my kernel implant in

288
00:13:36,140 --> 00:13:40,640
the kernel just like that so what is

289
00:13:39,650 --> 00:13:42,650
going on here

290
00:13:40,640 --> 00:13:46,550
I mean this clearly shouldn't be the

291
00:13:42,650 --> 00:13:49,069
case and let's have a closer look at it

292
00:13:46,550 --> 00:13:55,609
once when we knew that their file system

293
00:13:49,070 --> 00:13:58,250
mounted here let's go into folder of a

294
00:13:55,610 --> 00:14:01,670
process the CMD and let's have a look at

295
00:13:58,250 --> 00:14:04,730
the two different PML 42 different

296
00:14:01,670 --> 00:14:08,089
topmost page tables since the melton fix

297
00:14:04,730 --> 00:14:12,620
was actually to split the page table

298
00:14:08,090 --> 00:14:15,770
into two one which was the PML four here

299
00:14:12,620 --> 00:14:18,200
and which was reserved for the kernel of

300
00:14:15,770 --> 00:14:20,569
the world after the meltdown fix and one

301
00:14:18,200 --> 00:14:23,180
for the user which was created before a

302
00:14:20,570 --> 00:14:27,830
meltdown fix and let's have a look at

303
00:14:23,180 --> 00:14:30,410
the first one and we talked about this

304
00:14:27,830 --> 00:14:34,280
self referential entry and we have this

305
00:14:30,410 --> 00:14:36,380
memory address here in Windows 7 the

306
00:14:34,280 --> 00:14:40,760
topmost page table has a very special

307
00:14:36,380 --> 00:14:44,720
entry at offset f68 it's this one it's

308
00:14:40,760 --> 00:14:48,140
self referential it actually points to

309
00:14:44,720 --> 00:14:52,750
the page table itself the PML for itself

310
00:14:48,140 --> 00:14:59,000
and the memory manager uses this and I

311
00:14:52,750 --> 00:15:00,620
have 68 it's actually this one and it as

312
00:14:59,000 --> 00:15:05,870
you can see it's in little-endian

313
00:15:00,620 --> 00:15:08,420
so it ends with 67 it ends with 7 and 7

314
00:15:05,870 --> 00:15:11,210
in this case means that it's present

315
00:15:08,420 --> 00:15:14,000
it's active it's vital and it's

316
00:15:11,210 --> 00:15:15,740
accessible from user mode and that

317
00:15:14,000 --> 00:15:18,080
shouldn't be it should only be

318
00:15:15,740 --> 00:15:19,640
accessible from the kernel itself but

319
00:15:18,080 --> 00:15:22,340
this is the current view of things

320
00:15:19,640 --> 00:15:24,680
after a patch it might not be that

321
00:15:22,340 --> 00:15:27,560
catastrophic so let's have a look at the

322
00:15:24,680 --> 00:15:31,069
user page table as well and if we check

323
00:15:27,560 --> 00:15:34,369
the offset at f68 it's self referential

324
00:15:31,070 --> 00:15:48,769
entering this one it also ends with a 7

325
00:15:34,370 --> 00:15:50,569
and this is the issue itself so the

326
00:15:48,769 --> 00:15:53,720
total Meldrum vulnerability was really

327
00:15:50,569 --> 00:15:55,910
one single bit set in error and if you

328
00:15:53,720 --> 00:15:58,699
read Intel manual it clearly states that

329
00:15:55,910 --> 00:16:01,969
use the supervisor if Cyril user mode

330
00:15:58,699 --> 00:16:04,370
accesses are not allowed to this memory

331
00:16:01,970 --> 00:16:09,050
region so it's set to one using old

332
00:16:04,370 --> 00:16:11,059
accesses or allowed exploitation it was

333
00:16:09,050 --> 00:16:12,620
so easy I don't even want to call it an

334
00:16:11,059 --> 00:16:15,740
exploit

335
00:16:12,620 --> 00:16:19,009
it was just a matter of inserting a fake

336
00:16:15,740 --> 00:16:21,949
page table entry at the fixed address is

337
00:16:19,009 --> 00:16:24,800
in already mapped in processed virtual

338
00:16:21,949 --> 00:16:27,309
memory once I inserted this fake page

339
00:16:24,800 --> 00:16:30,170
table entry I could read and write to

340
00:16:27,309 --> 00:16:34,519
the orbiter physical memory that that

341
00:16:30,170 --> 00:16:39,490
page table entry had pointed to another

342
00:16:34,519 --> 00:16:43,670
use case that I didn't expect at all was

343
00:16:39,490 --> 00:16:45,889
cheating in games it turns out that anti

344
00:16:43,670 --> 00:16:48,769
cheating software it's really powerful

345
00:16:45,889 --> 00:16:52,179
pieces of software they detect the most

346
00:16:48,769 --> 00:16:55,639
if not all software based cheats and a

347
00:16:52,179 --> 00:16:57,529
hardware based sheet it should in theory

348
00:16:55,639 --> 00:17:00,139
it should only be seen as a PCI Express

349
00:16:57,529 --> 00:17:02,089
device on the gaming system and you kind

350
00:17:00,139 --> 00:17:03,679
of need to have PCI Express devices in

351
00:17:02,089 --> 00:17:06,709
your gaming systems you need to have a

352
00:17:03,679 --> 00:17:09,770
powerful graphics card and things like

353
00:17:06,709 --> 00:17:13,010
that for example and then you could use

354
00:17:09,770 --> 00:17:14,990
this Hardware device and then ship

355
00:17:13,010 --> 00:17:17,270
member to a remote computer and do the

356
00:17:14,990 --> 00:17:20,000
analysis there and the yeah

357
00:17:17,270 --> 00:17:22,099
and she'd software cannot reach into

358
00:17:20,000 --> 00:17:26,000
that computer you could do things like a

359
00:17:22,099 --> 00:17:28,158
read-only wool hex radar map decloak X

360
00:17:26,000 --> 00:17:30,380
for example and you could do the

361
00:17:28,159 --> 00:17:32,690
analysis on this separate computer chip

362
00:17:30,380 --> 00:17:35,390
to play a location to another computer

363
00:17:32,690 --> 00:17:37,429
for example you can also do writing but

364
00:17:35,390 --> 00:17:39,260
that might be a little bit more easily

365
00:17:37,429 --> 00:17:43,309
detectable if you're tampering with the

366
00:17:39,260 --> 00:17:45,470
in-game internals I first became aware

367
00:17:43,309 --> 00:17:48,080
of this summer last year when it was a

368
00:17:45,470 --> 00:17:50,480
big cheating scandal in the nori

369
00:17:48,080 --> 00:17:52,760
in csgo community it turned out that

370
00:17:50,480 --> 00:17:55,220
their people have been cheating at home

371
00:17:52,760 --> 00:17:58,760
and on lands to where she was okay to

372
00:17:55,220 --> 00:18:00,919
bring your own computer and then a

373
00:17:58,760 --> 00:18:03,559
couple of months later on even a sheet

374
00:18:00,919 --> 00:18:07,399
focused fork of my PCL each software

375
00:18:03,559 --> 00:18:10,279
appeared on github and this is how it

376
00:18:07,399 --> 00:18:13,760
looks like if we look really closely

377
00:18:10,279 --> 00:18:17,029
here we'll see that we have the PCI

378
00:18:13,760 --> 00:18:21,230
Express screamer fpga board inserted in

379
00:18:17,029 --> 00:18:23,870
this gaming computer initially ante

380
00:18:21,230 --> 00:18:25,039
sheets didn't catch this at all and it

381
00:18:23,870 --> 00:18:27,260
was kind of touted as the next

382
00:18:25,039 --> 00:18:30,620
generation of cheating the future of

383
00:18:27,260 --> 00:18:33,830
sheeting but you see yeah which is a

384
00:18:30,620 --> 00:18:36,379
really good anti sheet it didn't take

385
00:18:33,830 --> 00:18:38,990
them that long to catch up and when they

386
00:18:36,380 --> 00:18:41,210
cashed up and they wrote a blog entry

387
00:18:38,990 --> 00:18:43,010
about it on their site geared toward the

388
00:18:41,210 --> 00:18:45,559
gaming community what explained you

389
00:18:43,010 --> 00:18:48,559
might have a DMA device in your computer

390
00:18:45,559 --> 00:18:51,230
and you read the membership to add that

391
00:18:48,559 --> 00:18:53,000
tag PC doing ad analysis there and then

392
00:18:51,230 --> 00:18:56,840
you ship the player location to a phone

393
00:18:53,000 --> 00:18:58,340
for example they claim the prices for

394
00:18:56,840 --> 00:19:03,500
these sheets had been selling in the

395
00:18:58,340 --> 00:19:05,600
range of 1500 to $5,000 and of course

396
00:19:03,500 --> 00:19:07,940
when they started to do detection it was

397
00:19:05,600 --> 00:19:09,889
really simple initially for them to do

398
00:19:07,940 --> 00:19:12,649
it since most people had just been

399
00:19:09,889 --> 00:19:16,789
downloading my initial my default bit

400
00:19:12,649 --> 00:19:18,889
stream of the FPGA and the farmer from

401
00:19:16,789 --> 00:19:21,889
my site and it was some hard-coded

402
00:19:18,889 --> 00:19:23,539
vendor a decent device IDs in there so

403
00:19:21,889 --> 00:19:25,699
if you had them in your gaming system

404
00:19:23,539 --> 00:19:28,220
you're probably she to rights just ban

405
00:19:25,700 --> 00:19:31,460
them and it resulted in a bandwidth

406
00:19:28,220 --> 00:19:33,980
about sheet customers and developers but

407
00:19:31,460 --> 00:19:35,299
now they also claim that they're able to

408
00:19:33,980 --> 00:19:37,490
detect harbor based sheets

409
00:19:35,299 --> 00:19:41,179
even with disguising the sheet as a

410
00:19:37,490 --> 00:19:43,399
legitimate device and they can look into

411
00:19:41,179 --> 00:19:47,169
some other things some other telltale

412
00:19:43,399 --> 00:19:49,879
signs in there and which is quite easily

413
00:19:47,169 --> 00:19:54,919
detectable which is not so easily be

414
00:19:49,880 --> 00:19:58,250
changed by the user or the but

415
00:19:54,919 --> 00:20:00,660
what if it was possible to perfectly

416
00:19:58,250 --> 00:20:03,690
emulate a legit target word

417
00:20:00,660 --> 00:20:05,820
and this is kinda in the last couple of

418
00:20:03,690 --> 00:20:08,070
months already been demonstrated by

419
00:20:05,820 --> 00:20:10,530
researches at Cambridge University in

420
00:20:08,070 --> 00:20:13,320
there thunderclap paper they used a

421
00:20:10,530 --> 00:20:17,639
really expensive hardware set up here

422
00:20:13,320 --> 00:20:20,220
around $4,500 but we're able to emulate

423
00:20:17,640 --> 00:20:24,300
some networking card entirely in

424
00:20:20,220 --> 00:20:27,000
software and I don't know maybe it would

425
00:20:24,300 --> 00:20:30,210
be we will see this in the gaming area

426
00:20:27,000 --> 00:20:32,670
in the future as well but let's continue

427
00:20:30,210 --> 00:20:35,910
with the memory process file system the

428
00:20:32,670 --> 00:20:37,800
memory analysis part and when I was

429
00:20:35,910 --> 00:20:40,890
creating it I wanted to have something

430
00:20:37,800 --> 00:20:43,620
that's really easy for users to use but

431
00:20:40,890 --> 00:20:44,790
it should yet be very powerful I wanted

432
00:20:43,620 --> 00:20:47,669
to create something that was really

433
00:20:44,790 --> 00:20:51,930
modular in design and had plug-in

434
00:20:47,670 --> 00:20:54,750
functionality API is for C was given

435
00:20:51,930 --> 00:20:58,020
since its coded in C and I also want

436
00:20:54,750 --> 00:20:59,970
added Python API since Python is really

437
00:20:58,020 --> 00:21:01,710
popular within the security community

438
00:20:59,970 --> 00:21:04,740
and also in the memory forensics

439
00:21:01,710 --> 00:21:06,540
community and of course performance is

440
00:21:04,740 --> 00:21:09,030
super important when clicking around in

441
00:21:06,540 --> 00:21:11,399
a file system you can't really wait for

442
00:21:09,030 --> 00:21:13,290
1 or 2 minutes for a directory with the

443
00:21:11,400 --> 00:21:17,400
files to render it needs to be pretty

444
00:21:13,290 --> 00:21:21,300
much instant this is what I came up with

445
00:21:17,400 --> 00:21:24,180
and I used a really awesome third-party

446
00:21:21,300 --> 00:21:26,879
product which is called dokkan which is

447
00:21:24,180 --> 00:21:29,430
a user mode file system it takes care of

448
00:21:26,880 --> 00:21:31,860
all the hard part so I don't have to do

449
00:21:29,430 --> 00:21:34,260
it it has a kernel driver for the file

450
00:21:31,860 --> 00:21:36,479
system parsh all I need to do is to

451
00:21:34,260 --> 00:21:39,180
implement some really simple user mode

452
00:21:36,480 --> 00:21:43,170
hoops in the memory process filesystem

453
00:21:39,180 --> 00:21:46,710
executable and this really simple code

454
00:21:43,170 --> 00:21:49,560
box is pretty much it's just a thin wrap

455
00:21:46,710 --> 00:21:52,830
around the main analysis library which

456
00:21:49,560 --> 00:21:56,909
where I do all the memory analysis it's

457
00:21:52,830 --> 00:21:59,310
it's a really big C API it also takes

458
00:21:56,910 --> 00:22:03,060
care of all the memory analysis steps

459
00:21:59,310 --> 00:22:05,280
and it's in here I do the translation

460
00:22:03,060 --> 00:22:07,230
between the physical memory and the

461
00:22:05,280 --> 00:22:09,420
virtual memory for example I need to

462
00:22:07,230 --> 00:22:12,780
know a little bit about different memory

463
00:22:09,420 --> 00:22:13,920
models also have a plug-in manager in

464
00:22:12,780 --> 00:22:17,340
there for

465
00:22:13,920 --> 00:22:19,590
Python and C plugins and if I do use a

466
00:22:17,340 --> 00:22:21,600
Python plug-in I want to call back into

467
00:22:19,590 --> 00:22:24,570
its memory analysis library and I do

468
00:22:21,600 --> 00:22:26,520
that we are the Python API and if you

469
00:22:24,570 --> 00:22:29,840
kill your own Python the applications

470
00:22:26,520 --> 00:22:32,570
you can use this Python API as well and

471
00:22:29,840 --> 00:22:36,780
then I had a separate library for

472
00:22:32,570 --> 00:22:39,179
physical memory analysis and it's the

473
00:22:36,780 --> 00:22:41,370
lead core library which has a really

474
00:22:39,180 --> 00:22:43,470
strong focus on physical memory some

475
00:22:41,370 --> 00:22:45,780
writes that's all it does and this

476
00:22:43,470 --> 00:22:49,160
allows me to separate memory acquisition

477
00:22:45,780 --> 00:22:52,260
from analysis in a really nice way and

478
00:22:49,160 --> 00:22:54,680
it supports a lot of different memory

479
00:22:52,260 --> 00:22:56,490
acquisition methods I do support the

480
00:22:54,680 --> 00:22:59,040
hardware based memory acquisition

481
00:22:56,490 --> 00:23:02,250
methods and then we can do writing to

482
00:22:59,040 --> 00:23:05,430
use memory as well also I do support

483
00:23:02,250 --> 00:23:08,640
live capture of physical memory from a

484
00:23:05,430 --> 00:23:11,070
system either by using pmm or even

485
00:23:08,640 --> 00:23:14,880
better Matt's wish awesome dampe tool

486
00:23:11,070 --> 00:23:16,889
and we might want to analyze memory

487
00:23:14,880 --> 00:23:19,290
dumps as well and then you can do that

488
00:23:16,890 --> 00:23:22,440
by clicking on a file for example a row

489
00:23:19,290 --> 00:23:24,930
member don't file a fulcrum file for

490
00:23:22,440 --> 00:23:28,800
example created with dump it and even

491
00:23:24,930 --> 00:23:31,890
hyper-v save files recently I also got a

492
00:23:28,800 --> 00:23:35,550
really nice contribution from sin active

493
00:23:31,890 --> 00:23:38,550
and if you do have a vulnerable HP ILO

494
00:23:35,550 --> 00:23:40,919
interface you might be able to reflash

495
00:23:38,550 --> 00:23:45,560
that one with a special custom firmware

496
00:23:40,920 --> 00:23:49,110
or even implant DMA backdoor in a live

497
00:23:45,560 --> 00:23:51,600
HP ILO system without refreshing it and

498
00:23:49,110 --> 00:23:55,709
once you do have de air DMA backdoor in

499
00:23:51,600 --> 00:23:57,990
there and it's the BMC of HP servers and

500
00:23:55,710 --> 00:23:59,760
then you can read and write memory from

501
00:23:57,990 --> 00:24:02,910
the host operating system running on

502
00:23:59,760 --> 00:24:05,910
this server using these tools you're

503
00:24:02,910 --> 00:24:08,760
also able to connect to a remote agent a

504
00:24:05,910 --> 00:24:11,760
remote leech agent or a Kerberos secured

505
00:24:08,760 --> 00:24:14,430
mutual authenticated or PC and this

506
00:24:11,760 --> 00:24:16,620
remote agent is pretty much the leech

507
00:24:14,430 --> 00:24:18,660
core library but remotes you can use any

508
00:24:16,620 --> 00:24:20,669
of the above memory acquisition methods

509
00:24:18,660 --> 00:24:22,960
over the network but on that remote

510
00:24:20,670 --> 00:24:25,180
system

511
00:24:22,960 --> 00:24:27,490
the maintenance is library looks

512
00:24:25,180 --> 00:24:30,430
something like this we do have an API on

513
00:24:27,490 --> 00:24:33,910
top in which my memory process file

514
00:24:30,430 --> 00:24:36,820
system is using or your own application

515
00:24:33,910 --> 00:24:39,250
and on the very bottom I do capture

516
00:24:36,820 --> 00:24:41,950
physical memory from the leach core

517
00:24:39,250 --> 00:24:44,560
library but they also have a simple

518
00:24:41,950 --> 00:24:47,620
object manager in there which allows me

519
00:24:44,560 --> 00:24:49,840
to handle some simple objects in this

520
00:24:47,620 --> 00:24:52,659
library and that allows me to in a

521
00:24:49,840 --> 00:24:55,360
really good way have caches for physical

522
00:24:52,660 --> 00:24:57,520
memory and the page tables user in two

523
00:24:55,360 --> 00:25:00,370
different caches and then I have a layer

524
00:24:57,520 --> 00:25:03,340
which translates physical memory in

525
00:25:00,370 --> 00:25:05,919
through virtual memory and I'd need to

526
00:25:03,340 --> 00:25:09,669
have a knowledge of few different memory

527
00:25:05,920 --> 00:25:11,530
models in order to do that and then I

528
00:25:09,670 --> 00:25:13,420
notion of the process object which

529
00:25:11,530 --> 00:25:16,300
contains a memory map object and a

530
00:25:13,420 --> 00:25:18,070
module map object also have a plugin

531
00:25:16,300 --> 00:25:21,760
manager there which allows me to

532
00:25:18,070 --> 00:25:24,879
communicate with external plugins and if

533
00:25:21,760 --> 00:25:27,070
you're capturing live memory bottles I

534
00:25:24,880 --> 00:25:30,340
remember from a live system I reducing

535
00:25:27,070 --> 00:25:33,490
the FPGA or dump it in its live KD mode

536
00:25:30,340 --> 00:25:34,240
I do have a background updater thread in

537
00:25:33,490 --> 00:25:38,080
there as well

538
00:25:34,240 --> 00:25:40,690
in order to update the caches in in the

539
00:25:38,080 --> 00:25:44,530
background and so the user don't have to

540
00:25:40,690 --> 00:25:46,510
wait for the memory capture and of

541
00:25:44,530 --> 00:25:49,510
course I do all the analysis in here as

542
00:25:46,510 --> 00:25:51,580
well so imagine you have an incident

543
00:25:49,510 --> 00:25:53,590
response scenario you might have a

544
00:25:51,580 --> 00:25:55,929
suspicious process on a remote system

545
00:25:53,590 --> 00:25:57,790
and that computer might be quarantine to

546
00:25:55,930 --> 00:26:00,370
a VLAN or something like that and it's

547
00:25:57,790 --> 00:26:02,800
quite cheap often you do have limited

548
00:26:00,370 --> 00:26:05,620
bandwidth and high latency over the

549
00:26:02,800 --> 00:26:08,710
networks corporate network you want to

550
00:26:05,620 --> 00:26:10,629
analyze physical memory maybe and a full

551
00:26:08,710 --> 00:26:13,830
memory dump over the network might be

552
00:26:10,630 --> 00:26:16,360
super slow the solution might be to

553
00:26:13,830 --> 00:26:18,699
retrieve only the memory you actually

554
00:26:16,360 --> 00:26:21,100
need to analyze and analyze it with a

555
00:26:18,700 --> 00:26:24,640
memory process file system or even

556
00:26:21,100 --> 00:26:26,889
better it's possible to run the analysis

557
00:26:24,640 --> 00:26:31,090
on the remote computer by submitting a

558
00:26:26,890 --> 00:26:34,570
small Python script so let's do another

559
00:26:31,090 --> 00:26:36,220
demo let's demo some remote malware

560
00:26:34,570 --> 00:26:38,770
memory analysis I'm going

561
00:26:36,220 --> 00:26:41,650
to analyze live malware memory from a

562
00:26:38,770 --> 00:26:43,510
remotely remote system which has been

563
00:26:41,650 --> 00:26:45,309
infected and we are going to analyze

564
00:26:43,510 --> 00:26:56,950
this memory by just clicking on some

565
00:26:45,309 --> 00:26:59,980
files so this remote system is another

566
00:26:56,950 --> 00:27:04,570
hyper-v machine here so I'm going to

567
00:26:59,980 --> 00:27:07,330
start this leech agent and we do have

568
00:27:04,570 --> 00:27:09,730
this memory address here I'm using dump

569
00:27:07,330 --> 00:27:12,460
it with its live KD mode in order to

570
00:27:09,730 --> 00:27:15,250
capture live physical memory from this

571
00:27:12,460 --> 00:27:17,710
remote system and I'm going to do it in

572
00:27:15,250 --> 00:27:20,409
interactive mode here today and also in

573
00:27:17,710 --> 00:27:22,480
insecure mode since this computer is not

574
00:27:20,409 --> 00:27:24,220
connected to an Active Directory domain

575
00:27:22,480 --> 00:27:27,909
I can't really secure the connection

576
00:27:24,220 --> 00:27:30,010
with Active Directory Kerberos so let's

577
00:27:27,909 --> 00:27:31,870
do it in insecure mode which it

578
00:27:30,010 --> 00:27:36,400
basically allows anyone with network

579
00:27:31,870 --> 00:27:39,399
access to connect so let's initialize

580
00:27:36,400 --> 00:27:40,659
the connection to instrument system we

581
00:27:39,400 --> 00:27:43,270
are going to start the memory process

582
00:27:40,659 --> 00:27:46,080
file system using the dump it device to

583
00:27:43,270 --> 00:27:49,120
capture memory from this remote system

584
00:27:46,080 --> 00:27:51,010
so this memories should be mounted now

585
00:27:49,120 --> 00:27:55,780
especially let's click in to have it

586
00:27:51,010 --> 00:27:59,470
having a look at it can click into the

587
00:27:55,780 --> 00:28:03,100
names folder and I know already know

588
00:27:59,470 --> 00:28:06,010
what the malware is it's an old Citadel

589
00:28:03,100 --> 00:28:08,260
example here can have a look at its

590
00:28:06,010 --> 00:28:09,220
memory map for example and will clearly

591
00:28:08,260 --> 00:28:10,900
see it that you have some

592
00:28:09,220 --> 00:28:16,179
read/write/execute sections with the

593
00:28:10,900 --> 00:28:18,130
malware which is this one but we can

594
00:28:16,179 --> 00:28:20,950
analyze its memory we can open the

595
00:28:18,130 --> 00:28:23,409
virtual memory in hex editor and in the

596
00:28:20,950 --> 00:28:29,020
hex editor I already know what to search

597
00:28:23,409 --> 00:28:32,880
for here so let's search for some known

598
00:28:29,020 --> 00:28:35,379
really good antivirus software here

599
00:28:32,880 --> 00:28:39,309
because this malware is a block list for

600
00:28:35,380 --> 00:28:41,710
antivirus so we can see and this is like

601
00:28:39,309 --> 00:28:44,830
live memory by editing a file live

602
00:28:41,710 --> 00:28:46,990
memory from this remote system cat

603
00:28:44,830 --> 00:28:49,668
shipped and when we are doing this we

604
00:28:46,990 --> 00:28:52,700
are only capturing that piece of memory

605
00:28:49,669 --> 00:28:55,249
and if we were doing this analysis with

606
00:28:52,700 --> 00:28:57,799
the FPGA as well we could even hit sale

607
00:28:55,249 --> 00:28:59,690
here after we change something and the

608
00:28:57,799 --> 00:29:01,879
malware might not even notice since we

609
00:28:59,690 --> 00:29:11,779
are not using an API some that remote

610
00:29:01,879 --> 00:29:14,918
system early so having incident response

611
00:29:11,779 --> 00:29:17,509
there's really big advantages doing

612
00:29:14,919 --> 00:29:21,289
physical memory analysis and you might

613
00:29:17,509 --> 00:29:24,649
already be familiar with Stardust

614
00:29:21,289 --> 00:29:26,690
bi mát if you're not familiar with it

615
00:29:24,649 --> 00:29:29,359
please have a look at it or you might

616
00:29:26,690 --> 00:29:32,059
even use the more traditional approach

617
00:29:29,359 --> 00:29:34,789
with volatility both those tools are

618
00:29:32,059 --> 00:29:36,678
super awesome and the memory process

619
00:29:34,789 --> 00:29:38,809
file system is not truly meant to

620
00:29:36,679 --> 00:29:41,599
replace them it's more meant to act as a

621
00:29:38,809 --> 00:29:44,928
platform to do things with your own

622
00:29:41,599 --> 00:29:48,079
favorite tools it has an okay

623
00:29:44,929 --> 00:29:51,589
performance even a leggy networks and if

624
00:29:48,079 --> 00:29:54,769
you use the agent you can actually do

625
00:29:51,589 --> 00:29:57,079
the remote analysis parch directly on

626
00:29:54,769 --> 00:29:59,749
the remote endpoint which is super nice

627
00:29:57,079 --> 00:30:07,129
since it avoids both latency and

628
00:29:59,749 --> 00:30:09,259
bandwidth and future focus for is to do

629
00:30:07,129 --> 00:30:11,869
even more performance optimizations I do

630
00:30:09,259 --> 00:30:14,109
wish to prioritize things even more in

631
00:30:11,869 --> 00:30:16,820
order to further reduce latency and

632
00:30:14,109 --> 00:30:18,559
having a multi-threaded design is really

633
00:30:16,820 --> 00:30:20,450
awesome here since allows me to do

634
00:30:18,559 --> 00:30:25,309
things like a background process

635
00:30:20,450 --> 00:30:26,839
refreshes and the analysis capabilities

636
00:30:25,309 --> 00:30:29,539
it's a little bit limited at the moment

637
00:30:26,839 --> 00:30:34,399
but I do plan to add more in the soon

638
00:30:29,539 --> 00:30:37,759
future so let's have another look at the

639
00:30:34,399 --> 00:30:39,768
year Python API let's analyze the live

640
00:30:37,759 --> 00:30:42,829
memory from this remote system in Python

641
00:30:39,769 --> 00:30:47,409
by using the API let's locate readwrite

642
00:30:42,829 --> 00:30:47,408
executable sections in the remote memory

643
00:30:49,450 --> 00:30:56,830
switch over to Python here

644
00:30:53,049 --> 00:31:00,230
first I need to import the Python API

645
00:30:56,830 --> 00:31:03,500
can have a look at the functionality

646
00:31:00,230 --> 00:31:06,470
here we have a few functions that we can

647
00:31:03,500 --> 00:31:09,140
call into we're going to initialize this

648
00:31:06,470 --> 00:31:11,990
first we are going to connect to this

649
00:31:09,140 --> 00:31:17,179
remote system and let's connect to it

650
00:31:11,990 --> 00:31:18,860
and if we check the remote system you

651
00:31:17,179 --> 00:31:21,590
see that we connected and we are still

652
00:31:18,860 --> 00:31:23,269
connected with the other connection for

653
00:31:21,590 --> 00:31:26,029
memory process file systems of this

654
00:31:23,269 --> 00:31:30,139
agent support multiple connections to

655
00:31:26,029 --> 00:31:32,929
this remote system and now we are able

656
00:31:30,139 --> 00:31:35,689
to do things like retrieving the pit for

657
00:31:32,929 --> 00:31:40,190
a process name for example the CMD dot

658
00:31:35,690 --> 00:31:43,519
exe is this pit and we can retrieve some

659
00:31:40,190 --> 00:31:46,730
additional information for that process

660
00:31:43,519 --> 00:31:49,010
or for all processes and have a look at

661
00:31:46,730 --> 00:31:51,529
it by pit and here we see things like

662
00:31:49,010 --> 00:31:53,539
the process name we have the address of

663
00:31:51,529 --> 00:31:55,039
the process the pep band a few other

664
00:31:53,539 --> 00:31:57,470
things in here which might be

665
00:31:55,039 --> 00:32:00,230
interesting when we have this

666
00:31:57,470 --> 00:32:02,630
information we can retrieve it for all

667
00:32:00,230 --> 00:32:05,019
processes we can iterate over it and we

668
00:32:02,630 --> 00:32:10,549
get a really nice list of all the

669
00:32:05,019 --> 00:32:13,010
processes in this system we can retrieve

670
00:32:10,549 --> 00:32:15,379
the memory map for a given process and

671
00:32:13,010 --> 00:32:18,260
this is just one entry in the memory map

672
00:32:15,380 --> 00:32:21,409
it would be HUGE if I would print it the

673
00:32:18,260 --> 00:32:23,929
whole one it seems to be a page from the

674
00:32:21,409 --> 00:32:29,360
MTB level which seems to be read execute

675
00:32:23,929 --> 00:32:31,370
here and it's the entity ll here and now

676
00:32:29,360 --> 00:32:35,590
when we do have all this information we

677
00:32:31,370 --> 00:32:39,110
can do code a small Python program and

678
00:32:35,590 --> 00:32:40,939
let's for each process in the system

679
00:32:39,110 --> 00:32:43,389
let's iterate over it and for each

680
00:32:40,940 --> 00:32:46,700
process we are going to retrieve its

681
00:32:43,389 --> 00:32:49,370
physical memory map and let's iterate

682
00:32:46,700 --> 00:32:51,279
over each entry in this memory map to

683
00:32:49,370 --> 00:32:54,559
see if we can find some readwrite

684
00:32:51,279 --> 00:32:55,850
executable entries in there and then

685
00:32:54,559 --> 00:32:58,190
we're going to print it on the screen

686
00:32:55,850 --> 00:33:00,908
and I'm only going to print maximum two

687
00:32:58,190 --> 00:33:04,760
entries on the screen per process just

688
00:33:00,909 --> 00:33:06,200
for show here and now it takes some time

689
00:33:04,760 --> 00:33:09,499
it's a lot of memory

690
00:33:06,200 --> 00:33:12,019
to acquire from the remote system but

691
00:33:09,499 --> 00:33:15,019
it's quite fast anyway and now we went

692
00:33:12,019 --> 00:33:17,269
through all the pages all the payment

693
00:33:15,019 --> 00:33:19,159
structures of all the processes on the

694
00:33:17,269 --> 00:33:21,580
system and it's already finished as you

695
00:33:19,159 --> 00:33:24,529
can see we seem to find some

696
00:33:21,580 --> 00:33:25,730
read/write/execute pages in onedrive

697
00:33:24,529 --> 00:33:29,059
which is pretty normal

698
00:33:25,730 --> 00:33:31,609
we have our trojan executable here and

699
00:33:29,059 --> 00:33:35,389
also have some pages in PowerShell which

700
00:33:31,609 --> 00:33:38,178
is kind of normal as well we can also

701
00:33:35,389 --> 00:33:41,899
retrieve virtual and physical memory by

702
00:33:38,179 --> 00:33:44,210
using the API and then we do it by using

703
00:33:41,899 --> 00:33:46,699
the memory read function and the first

704
00:33:44,210 --> 00:33:49,789
argument is the pit of the process we

705
00:33:46,700 --> 00:33:51,529
wish to retrieve the memory from and but

706
00:33:49,789 --> 00:33:55,609
we can retrieve from physical memory if

707
00:33:51,529 --> 00:34:01,669
you use pit minus one and it looks

708
00:33:55,609 --> 00:34:03,439
something like this but even better we

709
00:34:01,669 --> 00:34:06,379
might be able to do this by analyzing

710
00:34:03,440 --> 00:34:08,929
live memory on the remote system by

711
00:34:06,379 --> 00:34:11,118
submitting a short script or at remote

712
00:34:08,929 --> 00:34:12,710
system and do the analysis on the actual

713
00:34:11,119 --> 00:34:15,500
remote system and then we don't have to

714
00:34:12,710 --> 00:34:19,720
acquire any memory at all and it's

715
00:34:15,500 --> 00:34:19,719
really nice in low bandwidth scenarios

716
00:34:26,290 --> 00:34:30,349
so let's have a look at our small

717
00:34:28,609 --> 00:34:33,790
program here it's pretty much the same

718
00:34:30,349 --> 00:34:36,470
as around before and but now I'm

719
00:34:33,790 --> 00:34:39,049
printing all the entries from the memory

720
00:34:36,469 --> 00:34:41,388
map so let's use the PCL each program

721
00:34:39,049 --> 00:34:45,199
with the agent exit path from program to

722
00:34:41,389 --> 00:34:48,919
submit this small script to remote test

723
00:34:45,199 --> 00:34:51,589
let's still use dump it to do the memory

724
00:34:48,918 --> 00:34:55,158
acquisition I submit the script we wait

725
00:34:51,589 --> 00:34:58,940
for the result it should and we already

726
00:34:55,159 --> 00:35:01,430
have it and all the memory analysis in

727
00:34:58,940 --> 00:35:04,490
this step is been doing it's been done

728
00:35:01,430 --> 00:35:07,009
on the actual remote system and by

729
00:35:04,490 --> 00:35:09,200
analyzing physical memory on that remote

730
00:35:07,010 --> 00:35:11,960
system we are not really relying on any

731
00:35:09,200 --> 00:35:14,149
operating system api's to do this and

732
00:35:11,960 --> 00:35:16,329
this makes it really hard to catch as

733
00:35:14,150 --> 00:35:16,329
well

734
00:35:17,640 --> 00:35:22,930
so the Python API looks something like

735
00:35:20,350 --> 00:35:24,700
this we have memory read functionality a

736
00:35:22,930 --> 00:35:26,020
memory read and write functionality we

737
00:35:24,700 --> 00:35:29,200
can both read physical and virtual

738
00:35:26,020 --> 00:35:31,540
memory and we can retrieve various kinds

739
00:35:29,200 --> 00:35:34,149
of process information listing the pits

740
00:35:31,540 --> 00:35:36,960
for example retrieve which modules which

741
00:35:34,150 --> 00:35:40,780
dll's are in the specific processes and

742
00:35:36,960 --> 00:35:42,790
for the dll's in the each process we can

743
00:35:40,780 --> 00:35:44,350
retrieve exported functions important

744
00:35:42,790 --> 00:35:47,050
functions sections and things like that

745
00:35:44,350 --> 00:35:48,520
and then the whole file system even

746
00:35:47,050 --> 00:35:52,150
though it's not really mounted as a

747
00:35:48,520 --> 00:35:54,790
drive and we still exist in the API

748
00:35:52,150 --> 00:35:58,870
world so we can query the API and read

749
00:35:54,790 --> 00:36:00,910
and write this virtual file still so

750
00:35:58,870 --> 00:36:03,819
when is creating this performance was

751
00:36:00,910 --> 00:36:05,649
super important and I'm really happy to

752
00:36:03,820 --> 00:36:08,350
have completed multi-threading since

753
00:36:05,650 --> 00:36:10,000
it's a huge boon since it allows me to

754
00:36:08,350 --> 00:36:12,069
do a lot of things in the background

755
00:36:10,000 --> 00:36:15,550
which doesn't really affect the user and

756
00:36:12,070 --> 00:36:17,560
I also rely on in-memory caching and

757
00:36:15,550 --> 00:36:20,410
some really intelligent parsing in there

758
00:36:17,560 --> 00:36:22,779
an example of parsing I really want to

759
00:36:20,410 --> 00:36:25,270
avoid scanning large chunks of memory

760
00:36:22,780 --> 00:36:27,280
for known signatures if I can avoid it

761
00:36:25,270 --> 00:36:29,710
because reading a lot of memory is

762
00:36:27,280 --> 00:36:33,250
expensive in terms of performance

763
00:36:29,710 --> 00:36:35,050
one thing I achieve this is when I'm

764
00:36:33,250 --> 00:36:37,120
starting the memory process file system

765
00:36:35,050 --> 00:36:39,130
I need to locate the kernel director

766
00:36:37,120 --> 00:36:42,310
table base which is the base of the

767
00:36:39,130 --> 00:36:44,410
virtual memory paging structures for the

768
00:36:42,310 --> 00:36:45,910
kernel so I can translate physical

769
00:36:44,410 --> 00:36:49,660
memory into virtual memory and the

770
00:36:45,910 --> 00:36:51,819
kernel base itself and it might already

771
00:36:49,660 --> 00:36:53,950
be known to the underlying device if

772
00:36:51,820 --> 00:36:56,890
it's known to the underlying device I

773
00:36:53,950 --> 00:37:00,009
can use that of course then we are done

774
00:36:56,890 --> 00:37:01,690
nothing more like that otherwise I can

775
00:37:00,010 --> 00:37:04,150
check for a memory structure which is

776
00:37:01,690 --> 00:37:07,810
called the low stub it's something that

777
00:37:04,150 --> 00:37:10,210
usually exists at the address 1000 in

778
00:37:07,810 --> 00:37:14,350
physical memory in hex it doesn't have

779
00:37:10,210 --> 00:37:16,300
to but it usually does and especially

780
00:37:14,350 --> 00:37:20,529
with this structure is that that offset

781
00:37:16,300 --> 00:37:22,330
a zero you do have the kernel PML for

782
00:37:20,530 --> 00:37:24,690
the director of table base of the kernel

783
00:37:22,330 --> 00:37:27,210
which then would allow me to translate

784
00:37:24,690 --> 00:37:30,930
virtual memory into physical memory and

785
00:37:27,210 --> 00:37:33,599
then I have a pointer to the base of the

786
00:37:30,930 --> 00:37:36,540
to the entry of the antis colonel at

787
00:37:33,599 --> 00:37:38,550
offset 70 it's not the base so I need to

788
00:37:36,540 --> 00:37:40,558
be scanning back a few pages but it's

789
00:37:38,550 --> 00:37:46,619
not too much memory so it's really quick

790
00:37:40,559 --> 00:37:48,599
and as a last resort I might to go for

791
00:37:46,619 --> 00:37:50,700
scanning as well but it's it takes a

792
00:37:48,599 --> 00:37:54,210
little bit longer time so you want to

793
00:37:50,700 --> 00:37:56,819
avoid it if I can and so let's go on at

794
00:37:54,210 --> 00:37:59,160
the demo let's do some writing to live

795
00:37:56,819 --> 00:38:02,130
memory on another system as well and

796
00:37:59,160 --> 00:38:08,220
let's overwrite memory in the process on

797
00:38:02,130 --> 00:38:11,160
another system so for this part I'm

798
00:38:08,220 --> 00:38:13,470
going to use the vulnerable Windows 7

799
00:38:11,160 --> 00:38:16,259
here and since the total meltdown

800
00:38:13,470 --> 00:38:19,558
vulnerability allows me to do writing to

801
00:38:16,260 --> 00:38:22,290
physical memory as well so let's start

802
00:38:19,559 --> 00:38:24,300
the leach agent and I'm going to start

803
00:38:22,290 --> 00:38:29,009
it interactive and in secure mode here

804
00:38:24,300 --> 00:38:34,910
today and I'm starting the notepad here

805
00:38:29,010 --> 00:38:43,020
with some text as well so let's try to

806
00:38:34,910 --> 00:38:47,220
need to mount this remote so let's mount

807
00:38:43,020 --> 00:38:54,119
the filesystem it's mounted and now we

808
00:38:47,220 --> 00:38:56,160
should be able to click into it and we

809
00:38:54,119 --> 00:38:59,400
can go into the notepad process for

810
00:38:56,160 --> 00:39:02,069
example and in here we do have the

811
00:38:59,400 --> 00:39:04,710
virtual memory but more interestingly we

812
00:39:02,069 --> 00:39:07,500
do think that this text hello up code it

813
00:39:04,710 --> 00:39:11,400
should be somewhere on the heap of the

814
00:39:07,500 --> 00:39:15,960
notepad I would suspect that list and in

815
00:39:11,400 --> 00:39:18,329
the VM the sub directory we have for

816
00:39:15,960 --> 00:39:20,819
each physical memory region we have

817
00:39:18,329 --> 00:39:23,190
enumerated it's as a file as well so it

818
00:39:20,819 --> 00:39:25,470
should be kind of easy to access and is

819
00:39:23,190 --> 00:39:28,349
tagged if we try if we find what the

820
00:39:25,470 --> 00:39:31,520
memories it's also tagged with that so

821
00:39:28,349 --> 00:39:32,839
let's try to do it and let's do it in

822
00:39:31,520 --> 00:39:36,490
Ubuntu

823
00:39:32,839 --> 00:39:39,310
so let's first mount the drive

824
00:39:36,490 --> 00:39:45,879
and then they go into that subdirectory

825
00:39:39,310 --> 00:39:47,589
and let's have a look if you can find

826
00:39:45,880 --> 00:39:50,349
the heap in there it's probably on the

827
00:39:47,589 --> 00:39:53,250
primary heap heap zero and we just have

828
00:39:50,349 --> 00:39:58,359
one memory region for this heap and

829
00:39:53,250 --> 00:40:00,970
let's do some simple let's do a simple

830
00:39:58,359 --> 00:40:03,190
strings on the heap we're going to do

831
00:40:00,970 --> 00:40:07,930
strings and the text in notepad is

832
00:40:03,190 --> 00:40:10,780
stored in little-endian so utf-16 so

833
00:40:07,930 --> 00:40:12,848
let's do search use strings in that mode

834
00:40:10,780 --> 00:40:13,660
and you just grab for hello and we have

835
00:40:12,849 --> 00:40:16,630
the text there

836
00:40:13,660 --> 00:40:18,460
hello up code in this file and this is

837
00:40:16,630 --> 00:40:21,970
memory acquired from this remote system

838
00:40:18,460 --> 00:40:24,760
live now and let's try to change that

839
00:40:21,970 --> 00:40:29,200
text into something else just use our

840
00:40:24,760 --> 00:40:37,119
hex editor to do that and let's search

841
00:40:29,200 --> 00:40:41,589
for that memory so this is the text

842
00:40:37,119 --> 00:40:45,250
hello up code in utf-16 little-endian so

843
00:40:41,589 --> 00:40:49,119
and here we do have some promising text

844
00:40:45,250 --> 00:40:52,260
here so let's try to change that text

845
00:40:49,119 --> 00:40:52,260
into something else

846
00:40:55,470 --> 00:41:05,169
and hit save in our hex editor and the

847
00:41:01,599 --> 00:41:07,390
text didn't change and that's because we

848
00:41:05,170 --> 00:41:09,490
need to just update the frame buffer we

849
00:41:07,390 --> 00:41:12,960
can't click anywhere and the text will

850
00:41:09,490 --> 00:41:12,959
be updated so

851
00:41:13,490 --> 00:41:17,910
[Applause]

852
00:41:16,490 --> 00:41:20,509
thank you

853
00:41:17,910 --> 00:41:23,549
so imagine doing this on another system

854
00:41:20,510 --> 00:41:25,670
using the FPGA hardware for example it

855
00:41:23,550 --> 00:41:32,640
might be useful in some research

856
00:41:25,670 --> 00:41:35,310
scenarios I hope so the memory process

857
00:41:32,640 --> 00:41:38,100
file system it's a work and a lot of

858
00:41:35,310 --> 00:41:40,770
future work it's a work in progress and

859
00:41:38,100 --> 00:41:42,750
a lot of future work remains and one

860
00:41:40,770 --> 00:41:44,940
thing I want to do is quite soon is to

861
00:41:42,750 --> 00:41:47,370
add some page hashing hashing of the

862
00:41:44,940 --> 00:41:50,850
pages which would allow me to I think

863
00:41:47,370 --> 00:41:53,970
reduce add amount of memory capture from

864
00:41:50,850 --> 00:41:56,520
remote systems and also to do things

865
00:41:53,970 --> 00:41:59,450
like low bandwidth cache coherency

866
00:41:56,520 --> 00:42:02,009
updates and I wish to add a lot of

867
00:41:59,450 --> 00:42:04,799
functionality and features quite soon

868
00:42:02,010 --> 00:42:07,530
and additional analysis capabilities

869
00:42:04,800 --> 00:42:10,100
primer ones being support for the

870
00:42:07,530 --> 00:42:12,990
Windows registry and also threading

871
00:42:10,100 --> 00:42:16,350
threads of the target system analyze

872
00:42:12,990 --> 00:42:17,609
those ones and support for non Windows

873
00:42:16,350 --> 00:42:19,589
operating systems

874
00:42:17,610 --> 00:42:21,900
it's certainly possible but it's a lot

875
00:42:19,590 --> 00:42:25,710
of work and that's a little bit more for

876
00:42:21,900 --> 00:42:28,590
in the future and of course additional

877
00:42:25,710 --> 00:42:32,700
memory acquisition methods is always

878
00:42:28,590 --> 00:42:34,650
nice but to sum everything up the memory

879
00:42:32,700 --> 00:42:36,569
process file system it's an easy

880
00:42:34,650 --> 00:42:39,540
pointing click file based memory

881
00:42:36,570 --> 00:42:43,320
analysis tool it comes with an API for C

882
00:42:39,540 --> 00:42:45,360
C++ and Python it has a wide range of

883
00:42:43,320 --> 00:42:47,670
memory acquisition methods not just

884
00:42:45,360 --> 00:42:49,740
Hardware based ones but software based

885
00:42:47,670 --> 00:42:53,310
ones and also this remote agent

886
00:42:49,740 --> 00:42:57,859
it's 100% open source and it's found on

887
00:42:53,310 --> 00:42:57,860
my D tab and thank you very much

