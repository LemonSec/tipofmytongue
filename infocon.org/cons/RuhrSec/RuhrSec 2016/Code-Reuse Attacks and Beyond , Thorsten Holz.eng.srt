1
00:00:00,000 --> 00:00:03,950
<font color="#CCCCCC">yeah so thanks a lot for these kind</font>

2
00:00:01,949 --> 00:00:07,319
words as the introduction Martine and

3
00:00:03,950 --> 00:00:09,719
<font color="#E5E5E5">yeah welcome everyone it seems like we</font>

4
00:00:07,319 --> 00:00:12,870
lost some people do 2g data<font color="#CCCCCC"> on yesterday</font>

5
00:00:09,719 --> 00:00:14,518
evening but nevertheless it's good to

6
00:00:12,870 --> 00:00:17,788
see that at least<font color="#CCCCCC"> some people men and</font>

7
00:00:14,519 --> 00:00:19,439
made it here this morning and I<font color="#E5E5E5"> want to</font>

8
00:00:17,789 --> 00:00:22,260
stab the presentation with some kind<font color="#E5E5E5"> of</font>

9
00:00:19,439 --> 00:00:25,050
advertisement because as you probably

10
00:00:22,260 --> 00:00:26,580
know IT security is a very hot topic at

11
00:00:25,050 --> 00:00:28,890
this point and there's<font color="#E5E5E5"> actually quite a</font>

12
00:00:26,580 --> 00:00:31,080
lot<font color="#E5E5E5"> of interest also in industry about</font>

13
00:00:28,890 --> 00:00:33,530
the different solutions how to prevent

14
00:00:31,080 --> 00:00:36,899
the attacks what we can do about it and

15
00:00:33,530 --> 00:00:39,809
therefore<font color="#E5E5E5"> we decided to do something so</font>

16
00:00:36,899 --> 00:00:42,540
basically<font color="#CCCCCC"> to</font><font color="#E5E5E5"> we are to provide some</font>

17
00:00:39,809 --> 00:00:44,309
incentive to to you to think about

18
00:00:42,540 --> 00:00:46,739
<font color="#E5E5E5">whether it makes sense to start</font><font color="#CCCCCC"> a</font>

19
00:00:44,309 --> 00:00:49,289
company as you probably also know there

20
00:00:46,739 --> 00:00:52,230
are a lot of computer security companies

21
00:00:49,289 --> 00:00:56,539
around many startups that<font color="#CCCCCC"> eve often last</font>

22
00:00:52,230 --> 00:00:58,828
few years and<font color="#E5E5E5"> what we want to do is also</font>

23
00:00:56,539 --> 00:01:01,020
basically provide some kind<font color="#CCCCCC"> of culture</font>

24
00:00:58,829 --> 00:01:03,120
of startups in Europe and for<font color="#E5E5E5"> this we</font>

25
00:01:01,020 --> 00:01:07,380
started this security rock stars

26
00:01:03,120 --> 00:01:10,020
competition we<font color="#CCCCCC"> have some prices so the</font>

27
00:01:07,380 --> 00:01:11,520
main prices even 20,000 hero so that you

28
00:01:10,020 --> 00:01:14,610
have some kind<font color="#CCCCCC"> of incentive to also</font>

29
00:01:11,520 --> 00:01:18,479
apply and it will be co-located with ACM

30
00:01:14,610 --> 00:01:21,210
<font color="#CCCCCC">CCS in October in</font><font color="#E5E5E5"> Vienna in the hoof</font>

31
00:01:18,479 --> 00:01:24,689
book you can find<font color="#E5E5E5"> more information on</font>

32
00:01:21,210 --> 00:01:26,429
the website and Yvonne Yvonne is around

33
00:01:24,689 --> 00:01:28,490
here so if<font color="#CCCCCC"> you have questions about the</font>

34
00:01:26,430 --> 00:01:31,200
competition just talked to her she will

35
00:01:28,490 --> 00:01:36,210
probably be on provide you with all the

36
00:01:31,200 --> 00:01:39,320
information you need and in<font color="#E5E5E5"> my talk I</font>

37
00:01:36,210 --> 00:01:42,000
want to talk about code reuse attacks

38
00:01:39,320 --> 00:01:45,689
control flow integrity so both attacks

39
00:01:42,000 --> 00:01:47,610
and defenses and also may I ramble a bit

40
00:01:45,689 --> 00:01:49,889
about what we've done in the last few

41
00:01:47,610 --> 00:01:52,560
years<font color="#E5E5E5"> and what I think</font><font color="#CCCCCC"> will be the main</font>

42
00:01:49,890 --> 00:01:54,750
<font color="#CCCCCC">challenges in the future so what can we</font>

43
00:01:52,560 --> 00:01:57,119
expect in the let's say next five to<font color="#CCCCCC"> ten</font>

44
00:01:54,750 --> 00:01:59,700
years how will this kind of arms race as

45
00:01:57,119 --> 00:02:03,420
martin also talks said evolve in<font color="#CCCCCC"> the</font>

46
00:01:59,700 --> 00:02:05,759
next few years but let me start<font color="#E5E5E5"> with a</font>

47
00:02:03,420 --> 00:02:07,459
look back so<font color="#CCCCCC"> where's all</font><font color="#E5E5E5"> of this coming</font>

48
00:02:05,759 --> 00:02:11,068
from

49
00:02:07,459 --> 00:02:15,030
probably<font color="#CCCCCC"> falls in</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> picture it's for</font>

50
00:02:11,068 --> 00:02:17,220
no man in front of Aniak and actually

51
00:02:15,030 --> 00:02:19,379
many of the problems that we face today

52
00:02:17,220 --> 00:02:21,750
are due to this kind<font color="#E5E5E5"> of computer</font>

53
00:02:19,379 --> 00:02:23,548
architecture so the phenomena

54
00:02:21,750 --> 00:02:25,920
architecture where we have one memory

55
00:02:23,549 --> 00:02:29,790
space and in the memory space we have

56
00:02:25,920 --> 00:02:31,589
code and data interleaved so do actually

57
00:02:29,790 --> 00:02:34,290
during<font color="#CCCCCC"> run time it's only decided</font>

58
00:02:31,590 --> 00:02:36,239
<font color="#E5E5E5">whether a specific memory location is</font>

59
00:02:34,290 --> 00:02:38,879
interpreted as code or if it's

60
00:02:36,239 --> 00:02:41,340
interpreted as data and this is<font color="#CCCCCC"> actually</font>

61
00:02:38,879 --> 00:02:43,649
one of<font color="#E5E5E5"> them fundamental reasons why we</font>

62
00:02:41,340 --> 00:02:45,750
all have all of these buffer overflows

63
00:02:43,650 --> 00:02:48,150
and the other kinds<font color="#E5E5E5"> of attacks that we</font>

64
00:02:45,750 --> 00:02:51,090
see today because an attacker can<font color="#E5E5E5"> inject</font>

65
00:02:48,150 --> 00:02:54,989
his own code into a vulnerable process

66
00:02:51,090 --> 00:02:56,849
this code is<font color="#CCCCCC"> then first interpreted as</font>

67
00:02:54,989 --> 00:03:00,299
data because<font color="#E5E5E5"> it's data that the program</font>

68
00:02:56,849 --> 00:03:02,220
is processing and then later on once the

69
00:03:00,299 --> 00:03:04,799
vulnerability is triggered this data

70
00:03:02,220 --> 00:03:08,129
turns into code lettuce then executed by

71
00:03:04,799 --> 00:03:10,379
the processor so for<font color="#E5E5E5"> no man actually</font><font color="#CCCCCC"> is</font>

72
00:03:08,129 --> 00:03:14,160
responsible for many of the jobs that we

73
00:03:10,379 --> 00:03:15,840
have in today's industry but<font color="#E5E5E5"> actually</font>

74
00:03:14,160 --> 00:03:19,319
it's also not<font color="#CCCCCC"> only his fault because</font>

75
00:03:15,840 --> 00:03:21,720
they were also even back in the 50s 60s

76
00:03:19,319 --> 00:03:23,668
many computer architectures they'd

77
00:03:21,720 --> 00:03:27,900
already had security in mind that had a

78
00:03:23,669 --> 00:03:32,690
clear separation between coding data one

79
00:03:27,900 --> 00:03:35,790
example<font color="#E5E5E5"> is here the</font><font color="#CCCCCC"> burrows 5,000 of the</font>

80
00:03:32,690 --> 00:03:38,900
5500 also one of the computer

81
00:03:35,790 --> 00:03:42,720
architectures developed in<font color="#CCCCCC"> the 60s 70s</font>

82
00:03:38,900 --> 00:03:45,989
so this<font color="#CCCCCC"> is picture from 1964 it's a</font>

83
00:03:42,720 --> 00:03:49,319
<font color="#CCCCCC">burrows 5500 an interesting thing is</font>

84
00:03:45,989 --> 00:03:52,950
that in this kind<font color="#E5E5E5"> of computer they as I</font>

85
00:03:49,319 --> 00:03:54,839
said took security already in mind they

86
00:03:52,950 --> 00:03:59,130
had a clear separation between code and

87
00:03:54,840 --> 00:04:00,780
data and even in today's terms they had

88
00:03:59,130 --> 00:04:03,090
some innovative<font color="#E5E5E5"> features so they had</font>

89
00:04:00,780 --> 00:04:06,150
some kind of what they called<font color="#CCCCCC"> exist</font>

90
00:04:03,090 --> 00:04:07,980
executable space protection and the

91
00:04:06,150 --> 00:04:10,739
capability<font color="#E5E5E5"> was that there was a tact</font>

92
00:04:07,980 --> 00:04:12,929
architecture so each memory location had

93
00:04:10,739 --> 00:04:15,120
basically attack such that it was

94
00:04:12,930 --> 00:04:18,030
decided whether this is code or<font color="#E5E5E5"> whether</font>

95
00:04:15,120 --> 00:04:19,829
whether this data and data cannot be

96
00:04:18,029 --> 00:04:24,030
executed

97
00:04:19,829 --> 00:04:26,639
and code can only be executed so they

98
00:04:24,030 --> 00:04:28,198
had a tech architecture that also some

99
00:04:26,639 --> 00:04:32,039
of the modern processor architectures

100
00:04:28,199 --> 00:04:33,689
have and yeah unfortunately intro and

101
00:04:32,039 --> 00:04:37,889
others don't<font color="#E5E5E5"> have it so we need to</font>

102
00:04:33,689 --> 00:04:39,389
emulate all of this in software also

103
00:04:37,889 --> 00:04:41,370
some of<font color="#E5E5E5"> the other concepts that we</font>

104
00:04:39,389 --> 00:04:44,639
recently worked on in<font color="#CCCCCC"> the academic field</font>

105
00:04:41,370 --> 00:04:47,099
like execute only memory such that you

106
00:04:44,639 --> 00:04:51,090
have one memory page that it can only be

107
00:04:47,099 --> 00:04:53,250
executed but it's<font color="#E5E5E5"> not readable these are</font>

108
00:04:51,090 --> 00:04:55,650
concepts that are<font color="#E5E5E5"> actually on that</font><font color="#CCCCCC"> we're</font>

109
00:04:53,250 --> 00:04:57,960
<font color="#E5E5E5">developed a long time ago that</font><font color="#CCCCCC"> we ate</font>

110
00:04:55,650 --> 00:04:59,789
<font color="#CCCCCC">all the excess bits and everything but</font>

111
00:04:57,960 --> 00:05:01,669
somehow it seems like we forgot<font color="#CCCCCC"> about</font>

112
00:04:59,789 --> 00:05:04,318
<font color="#E5E5E5">all</font><font color="#CCCCCC"> of these</font><font color="#E5E5E5"> features that were</font>

113
00:05:01,669 --> 00:05:06,150
developed<font color="#E5E5E5"> back then so we actually</font>

114
00:05:04,319 --> 00:05:08,669
rediscovering quite a lot<font color="#CCCCCC"> of the things</font>

115
00:05:06,150 --> 00:05:14,099
<font color="#CCCCCC">that we're already available in the past</font>

116
00:05:08,669 --> 00:05:17,400
<font color="#E5E5E5">I think not another milestone of the</font>

117
00:05:14,099 --> 00:05:20,930
modern attacks is the this study

118
00:05:17,400 --> 00:05:26,279
published in 1972 it was an Air Force

119
00:05:20,930 --> 00:05:28,139
study where Anderson we<font color="#E5E5E5"> are reasoned</font>

120
00:05:26,279 --> 00:05:30,659
about potential attacks against

121
00:05:28,139 --> 00:05:34,650
computing systems and this document as I

122
00:05:30,659 --> 00:05:36,990
said from 1972 already described buffer

123
00:05:34,650 --> 00:05:40,378
overflows such they're basically if a

124
00:05:36,990 --> 00:05:42,870
memory location has a fixed with that an

125
00:05:40,379 --> 00:05:46,589
attacker<font color="#CCCCCC"> can ride past the boundary and</font>

126
00:05:42,870 --> 00:05:50,039
then potentially also<font color="#E5E5E5"> access control</font>

127
00:05:46,589 --> 00:05:53,099
structures so he already described the

128
00:05:50,039 --> 00:05:55,409
concept of buffer overflows back in 1972

129
00:05:53,099 --> 00:05:57,800
so it<font color="#E5E5E5"> seems like many people</font><font color="#CCCCCC"> or at least</font>

130
00:05:55,409 --> 00:06:01,710
some people already knew<font color="#CCCCCC"> about it and</font>

131
00:05:57,800 --> 00:06:04,069
then<font color="#E5E5E5"> probably the event where most of</font>

132
00:06:01,710 --> 00:06:07,650
the<font color="#E5E5E5"> things came to a larger audience</font>

133
00:06:04,069 --> 00:06:10,349
we're in 1988 with a Morris warm it's

134
00:06:07,650 --> 00:06:12,810
just a code snippet from the warm where

135
00:06:10,349 --> 00:06:15,240
you see that<font color="#E5E5E5"> it's basically preparing</font>

136
00:06:12,810 --> 00:06:18,000
some kind of shell code so<font color="#E5E5E5"> a buffer is</font>

137
00:06:15,240 --> 00:06:20,310
filled<font color="#E5E5E5"> and then the bar fights also</font>

138
00:06:18,000 --> 00:06:23,099
adjusted a bit such that it represents

139
00:06:20,310 --> 00:06:25,860
the actual stick layout that is needed

140
00:06:23,099 --> 00:06:27,139
<font color="#E5E5E5">in order to take control so that's one</font>

141
00:06:25,860 --> 00:06:31,629
of<font color="#E5E5E5"> the first publicly documented</font>

142
00:06:27,139 --> 00:06:35,120
examples of buffer overflows and

143
00:06:31,629 --> 00:06:39,439
so basically the grandfather of<font color="#E5E5E5"> what we</font>

144
00:06:35,120 --> 00:06:44,090
know as buffer overflows today and then

145
00:06:39,439 --> 00:06:46,250
<font color="#E5E5E5">I think the the golden time of frac and</font>

146
00:06:44,090 --> 00:06:50,179
backtrack and all of these magazines and

147
00:06:46,250 --> 00:06:52,610
websites emerged so<font color="#CCCCCC"> then we've seen</font><font color="#E5E5E5"> lots</font>

148
00:06:50,180 --> 00:06:55,039
of innovations so actually many people

149
00:06:52,610 --> 00:06:58,009
develop new techniques in order to take

150
00:06:55,039 --> 00:07:00,500
<font color="#CCCCCC">control</font><font color="#E5E5E5"> over vulnerabilities so concepts</font>

151
00:06:58,009 --> 00:07:04,400
like return to lipsy<font color="#CCCCCC"> were developed back</font>

152
00:07:00,500 --> 00:07:06,289
then all the format strings many also<font color="#CCCCCC"> he</font>

153
00:07:04,400 --> 00:07:09,440
<font color="#CCCCCC">based exploitation techniques were</font>

154
00:07:06,289 --> 00:07:11,960
developed so these were actually 10 15

155
00:07:09,440 --> 00:07:13,930
20 years in which lots of innovations

156
00:07:11,960 --> 00:07:16,669
happened especially on the attack site

157
00:07:13,930 --> 00:07:18,919
so<font color="#E5E5E5"> frack and all those magazines</font>

158
00:07:16,669 --> 00:07:21,889
documented you quite a few neat tricks

159
00:07:18,919 --> 00:07:25,029
that are many of them<font color="#E5E5E5"> even apply today</font>

160
00:07:21,889 --> 00:07:28,419
or have at least inspired many of the

161
00:07:25,029 --> 00:07:33,110
attack techniques that we even<font color="#E5E5E5"> see today</font>

162
00:07:28,419 --> 00:07:35,719
as a response<font color="#E5E5E5"> of course</font><font color="#CCCCCC"> also on the</font>

163
00:07:33,110 --> 00:07:37,340
defense side many things happened here

164
00:07:35,719 --> 00:07:40,940
probably needed two examples that are

165
00:07:37,340 --> 00:07:42,138
most widely deployed in the<font color="#E5E5E5"> wild on the</font>

166
00:07:40,940 --> 00:07:44,990
one hand<font color="#CCCCCC"> we have</font><font color="#E5E5E5"> data execution</font>

167
00:07:42,139 --> 00:07:46,699
prevention so the<font color="#E5E5E5"> idea that a memory</font>

168
00:07:44,990 --> 00:07:50,830
page can be either writable or

169
00:07:46,699 --> 00:07:55,009
executable and when you<font color="#CCCCCC"> try to interpret</font>

170
00:07:50,830 --> 00:07:56,810
data as code the processor stops you so

171
00:07:55,009 --> 00:07:59,719
the first implementations we are just

172
00:07:56,810 --> 00:08:01,430
based on a software emulation but not<font color="#E5E5E5"> in</font>

173
00:07:59,719 --> 00:08:03,680
over<font color="#E5E5E5"> days this is available in the</font>

174
00:08:01,430 --> 00:08:06,560
processor itself so the overhead is

175
00:08:03,680 --> 00:08:09,310
quite low and almost all devices from

176
00:08:06,560 --> 00:08:11,620
desktop to even those smartphones

177
00:08:09,310 --> 00:08:15,259
typically have data execution prevention

178
00:08:11,620 --> 00:08:17,719
implemented by now and yeah the other

179
00:08:15,259 --> 00:08:20,569
<font color="#CCCCCC">widely deployed thing is etro space</font>

180
00:08:17,719 --> 00:08:23,900
<font color="#CCCCCC">layout randomization so the</font><font color="#E5E5E5"> idea that we</font>

181
00:08:20,569 --> 00:08:26,270
try<font color="#CCCCCC"> to cope with the monoculture that</font>

182
00:08:23,900 --> 00:08:29,270
each process has<font color="#CCCCCC"> the same memory layout</font>

183
00:08:26,270 --> 00:08:31,669
so the the easiest<font color="#CCCCCC"> way to do this</font><font color="#E5E5E5"> is</font>

184
00:08:29,270 --> 00:08:34,939
just to read randomize the base address

185
00:08:31,669 --> 00:08:38,149
of libraries such that when you start a

186
00:08:34,940 --> 00:08:40,610
program tries or after reboot the memory

187
00:08:38,149 --> 00:08:42,380
layout looks different<font color="#E5E5E5"> and this is also</font>

188
00:08:40,610 --> 00:08:44,730
<font color="#E5E5E5">one of the concepts that's quite</font>

189
00:08:42,380 --> 00:08:45,750
prevalent and yeah

190
00:08:44,730 --> 00:08:48,360
especially in the academic literature

191
00:08:45,750 --> 00:08:51,360
many new techniques have been developed

192
00:08:48,360 --> 00:08:54,029
for more fine-grained address space

193
00:08:51,360 --> 00:08:56,699
layout randomization where you do<font color="#CCCCCC"> not</font>

194
00:08:54,029 --> 00:08:59,430
only randomize the base address but also

195
00:08:56,699 --> 00:09:02,339
for example within a library you can<font color="#E5E5E5"> do</font>

196
00:08:59,430 --> 00:09:06,269
real randomization you can insert some

197
00:09:02,339 --> 00:09:08,820
things like just not codes in order to

198
00:09:06,269 --> 00:09:11,699
just change the structure a bit you can

199
00:09:08,820 --> 00:09:16,110
<font color="#CCCCCC">reorder code in order to also somehow</font>

200
00:09:11,699 --> 00:09:19,139
distort the memory layout all of these

201
00:09:16,110 --> 00:09:22,589
more fine-grain techniques didn't adopt

202
00:09:19,139 --> 00:09:24,810
you know widely yet so I think<font color="#E5E5E5"> there are</font>

203
00:09:22,589 --> 00:09:27,420
<font color="#E5E5E5">no major systems that already have</font><font color="#CCCCCC"> fine</font>

204
00:09:24,810 --> 00:09:29,089
<font color="#CCCCCC">grained randomization but still I think</font>

205
00:09:27,420 --> 00:09:31,620
<font color="#CCCCCC">this is one of</font><font color="#E5E5E5"> the interesting</font>

206
00:09:29,089 --> 00:09:33,839
challenges for the future how to

207
00:09:31,620 --> 00:09:36,449
basically implement etro space layout

208
00:09:33,839 --> 00:09:39,360
randomization in a scalable way such

209
00:09:36,449 --> 00:09:41,519
that the overhead also is rather low and

210
00:09:39,360 --> 00:09:44,070
all of these techniques with software

211
00:09:41,519 --> 00:09:47,040
diversity so where you try to break the

212
00:09:44,070 --> 00:09:49,649
monoculture by providing individual

213
00:09:47,040 --> 00:09:52,380
boundaries of an executable to all the

214
00:09:49,649 --> 00:09:56,399
different<font color="#E5E5E5"> computers are promising ways</font>

215
00:09:52,380 --> 00:09:58,260
but also quite<font color="#E5E5E5"> a lot</font><font color="#CCCCCC"> of problems they'll</font>

216
00:09:56,399 --> 00:10:01,199
need<font color="#CCCCCC"> to be solved related to patching</font>

217
00:09:58,260 --> 00:10:04,680
ready to updates related to also

218
00:10:01,199 --> 00:10:07,079
development of debugging so I<font color="#CCCCCC"> think they</font>

219
00:10:04,680 --> 00:10:08,550
are<font color="#E5E5E5"> also as challenges but probably an</font>

220
00:10:07,079 --> 00:10:13,769
interesting area to<font color="#E5E5E5"> take a closer look</font>

221
00:10:08,550 --> 00:10:16,709
at and since those two techniques are in

222
00:10:13,769 --> 00:10:19,949
place nowadays also the attack side edge

223
00:10:16,709 --> 00:10:23,189
will advance and there I<font color="#CCCCCC"> think the main</font>

224
00:10:19,949 --> 00:10:25,800
two papers in this field where on the

225
00:10:23,190 --> 00:10:29,310
one hand a paper by stealth or the

226
00:10:25,800 --> 00:10:31,109
bastion<font color="#CCCCCC"> comma on the borrowed chunk or</font>

227
00:10:29,310 --> 00:10:34,050
borrowed coach<font color="#E5E5E5"> Frank exploitation</font>

228
00:10:31,110 --> 00:10:37,010
technique and from soshim on returning

229
00:10:34,050 --> 00:10:39,420
to lipsy without function calls that

230
00:10:37,010 --> 00:10:43,709
<font color="#E5E5E5">introduce the idea of return oriented</font>

231
00:10:39,420 --> 00:10:46,410
programming both papers were published

232
00:10:43,709 --> 00:10:52,949
about ten years ago so the<font color="#E5E5E5"> Bastian's</font>

233
00:10:46,410 --> 00:10:54,870
paper 2005 soshim 2007 and yeah in those

234
00:10:52,949 --> 00:10:57,630
last 10 years these techniques were

235
00:10:54,870 --> 00:10:58,370
refined quite a lot the basic ideas

236
00:10:57,630 --> 00:11:01,230
still

237
00:10:58,370 --> 00:11:03,660
still the same<font color="#E5E5E5"> so</font><font color="#CCCCCC"> the idea</font><font color="#E5E5E5"> is that</font>

238
00:11:01,230 --> 00:11:07,380
instead of injecting code as an attacker

239
00:11:03,660 --> 00:11:10,110
you can just<font color="#E5E5E5"> reuse existing code because</font>

240
00:11:07,380 --> 00:11:13,410
each program has many pages that are

241
00:11:10,110 --> 00:11:16,890
executable so that represent the text

242
00:11:13,410 --> 00:11:19,140
section of the program<font color="#E5E5E5"> that has or that</font>

243
00:11:16,890 --> 00:11:21,720
it's loaded memory that has certain

244
00:11:19,140 --> 00:11:23,900
vulnerabilities and then the<font color="#CCCCCC"> idea is to</font>

245
00:11:21,720 --> 00:11:26,220
reuse the<font color="#CCCCCC"> code that's already available</font>

246
00:11:23,900 --> 00:11:28,319
so that you do not need<font color="#E5E5E5"> to inject your</font>

247
00:11:26,220 --> 00:11:30,900
own code as an attacker but you'll just

248
00:11:28,320 --> 00:11:33,990
reuse what's already there<font color="#E5E5E5"> because it's</font>

249
00:11:30,900 --> 00:11:37,680
it may it may be protected<font color="#E5E5E5"> via some kind</font>

250
00:11:33,990 --> 00:11:40,200
<font color="#E5E5E5">of signature it's also executable so you</font>

251
00:11:37,680 --> 00:11:42,300
don't need<font color="#CCCCCC"> to mess with page formations</font>

252
00:11:40,200 --> 00:11:46,260
or anything so you<font color="#CCCCCC"> just reuse the code</font>

253
00:11:42,300 --> 00:11:48,030
that's available there yeah here on the

254
00:11:46,260 --> 00:11:49,740
slide you see a small<font color="#CCCCCC"> example of how</font>

255
00:11:48,030 --> 00:11:52,140
return<font color="#CCCCCC"> our into programming looks like</font>

256
00:11:49,740 --> 00:11:55,050
so you have<font color="#CCCCCC"> different</font><font color="#E5E5E5"> so-called gadgets</font>

257
00:11:52,140 --> 00:11:57,300
each gadget represents a mass and kind

258
00:11:55,050 --> 00:11:59,880
<font color="#E5E5E5">of micro instruction for example that</font>

259
00:11:57,300 --> 00:12:04,560
you add<font color="#E5E5E5"> two values or that you pop</font>

260
00:11:59,880 --> 00:12:07,040
values from<font color="#CCCCCC"> the to the stack so and</font><font color="#E5E5E5"> I'm</font>

261
00:12:04,560 --> 00:12:09,719
sorry<font color="#E5E5E5"> so the idea is to basically chain</font>

262
00:12:07,040 --> 00:12:13,319
some of these gadgets and the gadgets

263
00:12:09,720 --> 00:12:15,960
are then executed after each other and

264
00:12:13,320 --> 00:12:18,410
with each gadget you just do a some kind

265
00:12:15,960 --> 00:12:21,630
<font color="#CCCCCC">of specific operation to prepare</font>

266
00:12:18,410 --> 00:12:23,490
registers to prepare the stack or to

267
00:12:21,630 --> 00:12:26,430
take values from the stack and<font color="#E5E5E5"> then</font>

268
00:12:23,490 --> 00:12:29,160
finally you<font color="#E5E5E5"> do an operation like you add</font>

269
00:12:26,430 --> 00:12:31,349
<font color="#CCCCCC">some values or you multiply or you</font>

270
00:12:29,160 --> 00:12:33,930
perform a jump or a memory access or

271
00:12:31,350 --> 00:12:37,080
something of that so the<font color="#E5E5E5"> picture in the</font>

272
00:12:33,930 --> 00:12:39,000
lower right basically has a

273
00:12:37,080 --> 00:12:41,340
representation of how you can<font color="#CCCCCC"> think</font><font color="#E5E5E5"> of</font>

274
00:12:39,000 --> 00:12:43,980
return oriented programming so you're

275
00:12:41,340 --> 00:12:46,590
just chaining small values and at the

276
00:12:43,980 --> 00:12:49,140
end the reuse code that's already

277
00:12:46,590 --> 00:12:54,030
available is doing the computations that

278
00:12:49,140 --> 00:12:56,189
you want to<font color="#E5E5E5"> do as an attacker and yeah</font>

279
00:12:54,030 --> 00:12:58,470
Prue preventing this kind of<font color="#E5E5E5"> attacks is</font>

280
00:12:56,190 --> 00:13:01,590
challenging especially since there were

281
00:12:58,470 --> 00:13:04,230
many advances on the offensive side so

282
00:13:01,590 --> 00:13:06,900
here's<font color="#CCCCCC"> the slide from Luca will have his</font>

283
00:13:04,230 --> 00:13:09,870
presentation later on today he will dive

284
00:13:06,900 --> 00:13:11,329
into<font color="#CCCCCC"> some of the details so this</font>

285
00:13:09,870 --> 00:13:13,850
especially a timeline how

286
00:13:11,329 --> 00:13:17,049
love this evolved from return to<font color="#CCCCCC"> lipsy</font>

287
00:13:13,850 --> 00:13:20,480
to the new attacks that we see today and

288
00:13:17,049 --> 00:13:24,559
Luca will talk<font color="#CCCCCC"> about let's</font><font color="#E5E5E5"> say stitching</font>

289
00:13:20,480 --> 00:13:27,649
gadgets<font color="#E5E5E5"> jitter up and also a defense so</font>

290
00:13:24,559 --> 00:13:29,540
he will<font color="#E5E5E5"> provide more details about the</font>

291
00:13:27,649 --> 00:13:33,949
different kinds<font color="#CCCCCC"> of</font><font color="#E5E5E5"> attacks in his talk</font>

292
00:13:29,540 --> 00:13:36,319
later today and what we already are

293
00:13:33,949 --> 00:13:39,829
especially see is that especially

294
00:13:36,319 --> 00:13:43,339
<font color="#E5E5E5">real-world exploits also leveraged up in</font>

295
00:13:39,829 --> 00:13:46,809
<font color="#E5E5E5">order to bypass</font><font color="#CCCCCC"> ex the</font><font color="#E5E5E5"> defenses so</font>

296
00:13:43,339 --> 00:13:50,799
especially around 2011 or starting from

297
00:13:46,809 --> 00:13:53,569
<font color="#E5E5E5">2010-2011 there were many many publicly</font>

298
00:13:50,799 --> 00:13:57,610
documented exploits that took advantage

299
00:13:53,569 --> 00:14:00,170
of<font color="#E5E5E5"> Rob in order to bypass the</font><font color="#CCCCCC"> defenses</font><font color="#E5E5E5"> I</font>

300
00:13:57,610 --> 00:14:01,970
think the interesting inside is that the

301
00:14:00,170 --> 00:14:04,759
strength seems to somehow stop now

302
00:14:01,970 --> 00:14:07,069
because now major operating systems<font color="#E5E5E5"> like</font>

303
00:14:04,759 --> 00:14:10,309
Windows 10 have controlled your guard

304
00:14:07,069 --> 00:14:13,729
implemented so basic defenses against

305
00:14:10,309 --> 00:14:16,579
return oriented programming are adopted

306
00:14:13,730 --> 00:14:18,470
by also major operating systems and I

307
00:14:16,579 --> 00:14:20,059
think what will happen is<font color="#CCCCCC"> that the</font>

308
00:14:18,470 --> 00:14:23,600
practical value of return oriented

309
00:14:20,059 --> 00:14:26,149
programming will damage over time but on

310
00:14:23,600 --> 00:14:28,669
the attack site we also saw that<font color="#E5E5E5"> many</font>

311
00:14:26,149 --> 00:14:34,910
new concepts we are developed and I will

312
00:14:28,669 --> 00:14:37,459
talk about a few later on in my talk so

313
00:14:34,910 --> 00:14:40,519
we have this arms race on the one<font color="#E5E5E5"> hand</font>

314
00:14:37,459 --> 00:14:43,669
we<font color="#CCCCCC"> have ongoing attacks so the attacking</font>

315
00:14:40,519 --> 00:14:45,980
side is developing novel techniques they

316
00:14:43,669 --> 00:14:48,350
are thinking<font color="#CCCCCC"> about how to bypass the</font>

317
00:14:45,980 --> 00:14:52,839
existing dealers and then on the other

318
00:14:48,350 --> 00:14:55,519
hand we have all the different areas<font color="#CCCCCC"> how</font>

319
00:14:52,839 --> 00:14:58,489
this control for hijacking or code reuse

320
00:14:55,519 --> 00:15:00,499
the text can be prevented so we have the

321
00:14:58,489 --> 00:15:03,649
typical yin yin yang between offensive

322
00:15:00,499 --> 00:15:05,869
<font color="#CCCCCC">in the</font><font color="#E5E5E5"> defense side and this slide just</font>

323
00:15:03,649 --> 00:15:08,480
provides a brief overview<font color="#E5E5E5"> of some of the</font>

324
00:15:05,869 --> 00:15:16,129
defense's that<font color="#CCCCCC"> were presented in the</font>

325
00:15:08,480 --> 00:15:18,619
last few years many of<font color="#E5E5E5"> them target yeah</font>

326
00:15:16,129 --> 00:15:21,110
either binary or source code approaches

327
00:15:18,619 --> 00:15:24,579
and those were all academic papers that

328
00:15:21,110 --> 00:15:27,339
presented concepts I think<font color="#E5E5E5"> not</font>

329
00:15:24,579 --> 00:15:29,920
<font color="#E5E5E5">okay cling it meanwhile adopted by some</font>

330
00:15:27,339 --> 00:15:32,649
operating systems but<font color="#E5E5E5"> the others are</font>

331
00:15:29,920 --> 00:15:35,259
mainly concepts that didn't receive a

332
00:15:32,649 --> 00:15:37,389
widespread adoption yet some<font color="#E5E5E5"> of them</font>

333
00:15:35,259 --> 00:15:39,610
will probably<font color="#CCCCCC"> be adopted soon for</font>

334
00:15:37,389 --> 00:15:44,139
example you<font color="#CCCCCC"> have some compiler patches</font>

335
00:15:39,610 --> 00:15:46,749
available for both<font color="#CCCCCC"> GT GCC and llvm that</font>

336
00:15:44,139 --> 00:15:49,779
provide control flow integrity to a

337
00:15:46,749 --> 00:15:52,299
given binary so some of these concepts

338
00:15:49,779 --> 00:15:54,939
while only<font color="#E5E5E5"> being academic prototypes</font>

339
00:15:52,299 --> 00:15:57,970
will probably be adopted also by

340
00:15:54,939 --> 00:16:02,738
mainstream systems in the<font color="#CCCCCC"> near future at</font>

341
00:15:57,970 --> 00:16:05,589
least<font color="#E5E5E5"> I hope so so from a product</font>

342
00:16:02,739 --> 00:16:08,739
spective you can think<font color="#E5E5E5"> of different</font>

343
00:16:05,589 --> 00:16:10,989
areas<font color="#E5E5E5"> how control for hijacking con code</font>

344
00:16:08,739 --> 00:16:14,860
reuse the text<font color="#CCCCCC"> kemper can be prevented</font>

345
00:16:10,989 --> 00:16:18,220
and the different approaches how to

346
00:16:14,860 --> 00:16:21,189
tackle the problem basically target

347
00:16:18,220 --> 00:16:24,069
different different concepts<font color="#E5E5E5"> of</font><font color="#CCCCCC"> the</font>

348
00:16:21,189 --> 00:16:26,949
actual exploitation attempt so<font color="#E5E5E5"> the first</font>

349
00:16:24,069 --> 00:16:29,319
<font color="#E5E5E5">callum the memory safety is targeting</font>

350
00:16:26,949 --> 00:16:32,469
the root cause because if we allow the

351
00:16:29,319 --> 00:16:35,410
attacker to have something lighter like

352
00:16:32,470 --> 00:16:39,100
a ride for such that he can override

353
00:16:35,410 --> 00:16:42,669
<font color="#CCCCCC">four bytes of memory then he can bypass</font>

354
00:16:39,100 --> 00:16:45,069
probably most<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> defenses because</font>

355
00:16:42,669 --> 00:16:48,730
once we he can once he has a read/write

356
00:16:45,069 --> 00:16:51,419
primitive he has I think<font color="#CCCCCC"> it's pretty</font>

357
00:16:48,730 --> 00:16:54,879
<font color="#E5E5E5">hard or pretty challenging at least two</font>

358
00:16:51,419 --> 00:16:57,459
to stop the attacker so all the memory

359
00:16:54,879 --> 00:17:00,730
safety techniques what they try to do is

360
00:16:57,459 --> 00:17:03,449
to prevent the attacker<font color="#E5E5E5"> from corrupting</font>

361
00:17:00,730 --> 00:17:07,779
data structures from corrupting memory

362
00:17:03,449 --> 00:17:10,418
especially things like CPI<font color="#E5E5E5"> and cps</font><font color="#CCCCCC"> we're</font>

363
00:17:07,779 --> 00:17:13,419
discussed quite extensively they have

364
00:17:10,419 --> 00:17:15,610
<font color="#E5E5E5">certain limitations because it's tough</font>

365
00:17:13,419 --> 00:17:20,549
to implement this in a precise way in

366
00:17:15,609 --> 00:17:22,928
x86 in 64 you try to just hide some

367
00:17:20,549 --> 00:17:28,209
secret information that's also not that

368
00:17:22,929 --> 00:17:29,649
easy and so these systems provide or

369
00:17:28,209 --> 00:17:31,649
make it harder for an attacker but they

370
00:17:29,649 --> 00:17:34,479
also cannot provide any guarantees but

371
00:17:31,649 --> 00:17:37,719
then we have techniques like soft<font color="#E5E5E5"> bounds</font>

372
00:17:34,480 --> 00:17:40,330
of it that definitely are harder to buy

373
00:17:37,720 --> 00:17:43,809
pass but the drawback is that they<font color="#E5E5E5"> are</font>

374
00:17:40,330 --> 00:17:46,299
actually rather costly so soft bounce

375
00:17:43,809 --> 00:17:48,840
actually has an overhead of about one

376
00:17:46,299 --> 00:17:51,760
hundred percent so your runtime is

377
00:17:48,840 --> 00:17:55,720
suddenly only<font color="#E5E5E5"> half as it used to be and</font>

378
00:17:51,760 --> 00:17:58,419
that's<font color="#E5E5E5"> probably too much in most use</font>

379
00:17:55,720 --> 00:18:00,340
cases although soft bounce can guarantee

380
00:17:58,419 --> 00:18:02,530
you<font color="#CCCCCC"> that nothing</font><font color="#E5E5E5"> can go wrong so it's</font>

381
00:18:00,340 --> 00:18:05,080
definitely<font color="#E5E5E5"> an interesting approach but</font>

382
00:18:02,530 --> 00:18:07,178
what we need more efficient ways<font color="#CCCCCC"> to do</font>

383
00:18:05,080 --> 00:18:09,668
this so and I<font color="#CCCCCC"> think that's one of</font><font color="#E5E5E5"> the</font>

384
00:18:07,179 --> 00:18:12,820
main challenges how can we<font color="#E5E5E5"> achieve</font>

385
00:18:09,669 --> 00:18:17,380
memory safety without or with an

386
00:18:12,820 --> 00:18:19,210
acceptable overhead so that we provide

387
00:18:17,380 --> 00:18:22,240
integrity of data structures provide

388
00:18:19,210 --> 00:18:24,640
integrity of the memory state but still

389
00:18:22,240 --> 00:18:29,679
have only an impact of maybe<font color="#CCCCCC"> ten or even</font>

390
00:18:24,640 --> 00:18:31,360
<font color="#E5E5E5">less percent the second column or those</font>

391
00:18:29,679 --> 00:18:34,120
control flow integrity approaches

392
00:18:31,360 --> 00:18:37,750
interesting in the sense that they try

393
00:18:34,120 --> 00:18:41,229
<font color="#E5E5E5">to tackle especially where the point</font>

394
00:18:37,750 --> 00:18:43,179
<font color="#E5E5E5">where the attacker tries to tries to</font>

395
00:18:41,230 --> 00:18:47,049
<font color="#E5E5E5">escalate his privileges so where he</font>

396
00:18:43,179 --> 00:18:48,820
tries to ask<font color="#E5E5E5"> execute his own code the</font>

397
00:18:47,049 --> 00:18:50,740
basic idea<font color="#CCCCCC"> behind control flow integrity</font>

398
00:18:48,820 --> 00:18:54,960
is actually easy it's been documented

399
00:18:50,740 --> 00:18:59,280
since many years<font color="#E5E5E5"> and it works as follows</font>

400
00:18:54,960 --> 00:19:03,100
give me a program you first determine

401
00:18:59,280 --> 00:19:05,408
which states the<font color="#E5E5E5"> program can</font><font color="#CCCCCC"> be in so</font>

402
00:19:03,100 --> 00:19:07,570
typically<font color="#E5E5E5"> you construct something like a</font>

403
00:19:05,409 --> 00:19:10,140
control flow graph where you just

404
00:19:07,570 --> 00:19:13,450
represent the different states as blocks

405
00:19:10,140 --> 00:19:16,210
and then you connect the blocks to each

406
00:19:13,450 --> 00:19:19,809
other<font color="#CCCCCC"> by edges and each edge represents</font>

407
00:19:16,210 --> 00:19:22,179
a valid control flow transition and what

408
00:19:19,809 --> 00:19:25,178
you do then during runtime is to enforce

409
00:19:22,179 --> 00:19:27,880
this control flow graph such that each

410
00:19:25,179 --> 00:19:31,990
jump that<font color="#E5E5E5"> the program is doing only</font>

411
00:19:27,880 --> 00:19:33,940
follows a legitimate jump this prevents

412
00:19:31,990 --> 00:19:37,360
control for hijacking attacks because

413
00:19:33,940 --> 00:19:40,330
the attack is prevented from jumping to

414
00:19:37,360 --> 00:19:43,270
its own shell code and it also prevents

415
00:19:40,330 --> 00:19:45,370
at least to a certain extent code reuse

416
00:19:43,270 --> 00:19:49,590
attacks because the attack<font color="#E5E5E5"> is heavily</font>

417
00:19:45,370 --> 00:19:51,969
restricted in which edges he can take

418
00:19:49,590 --> 00:19:54,699
control flow integrity is also a concept

419
00:19:51,970 --> 00:19:57,220
that's as<font color="#CCCCCC"> I said widely available in</font>

420
00:19:54,700 --> 00:19:59,560
compilers by now so you can actually<font color="#CCCCCC"> use</font>

421
00:19:57,220 --> 00:20:03,400
<font color="#CCCCCC">it it's available</font><font color="#E5E5E5"> in Windows with</font>

422
00:19:59,560 --> 00:20:04,830
control flow guard with Windows 10 so we

423
00:20:03,400 --> 00:20:07,120
see more<font color="#E5E5E5"> and</font><font color="#CCCCCC"> more widespread adoption</font>

424
00:20:04,830 --> 00:20:10,960
but the challenge here is to have a

425
00:20:07,120 --> 00:20:13,179
precise control flow policy probably

426
00:20:10,960 --> 00:20:15,790
Luca<font color="#E5E5E5"> will also talk about a bit about</font>

427
00:20:13,180 --> 00:20:18,820
this because many of the implementations

428
00:20:15,790 --> 00:20:20,440
that represent it can be bypassed either

429
00:20:18,820 --> 00:20:23,169
because they have implementation flaws

430
00:20:20,440 --> 00:20:25,290
or because the<font color="#E5E5E5"> policy was not precise</font>

431
00:20:23,170 --> 00:20:29,620
enough that the attack I can still

432
00:20:25,290 --> 00:20:32,020
somehow bypass it and the main challenge

433
00:20:29,620 --> 00:20:34,870
also<font color="#CCCCCC"> with control flow integrity is that</font>

434
00:20:32,020 --> 00:20:37,330
even<font color="#E5E5E5"> in a benign binary you have many</font>

435
00:20:34,870 --> 00:20:40,510
functions that you<font color="#E5E5E5"> can use and if an</font>

436
00:20:37,330 --> 00:20:43,449
attacker performs whole function<font color="#E5E5E5"> reuse</font>

437
00:20:40,510 --> 00:20:46,690
so them something<font color="#CCCCCC"> like return to lipsy</font>

438
00:20:43,450 --> 00:20:49,980
in a more elaborate away you can also

439
00:20:46,690 --> 00:20:54,430
bypass many of the this some<font color="#CCCCCC"> of the</font>

440
00:20:49,980 --> 00:20:56,740
proposed systems because if he reuses a

441
00:20:54,430 --> 00:21:01,170
full function then this looks like a

442
00:20:56,740 --> 00:21:01,170
little<font color="#CCCCCC"> GT met code path that is followed</font>

443
00:21:01,260 --> 00:21:05,650
the third area are all those

444
00:21:03,550 --> 00:21:07,210
randomization techniques that do

445
00:21:05,650 --> 00:21:09,400
something like coach raveling or

446
00:21:07,210 --> 00:21:13,720
rewriting or try to hide some

447
00:21:09,400 --> 00:21:16,510
information so these basically or all of

448
00:21:13,720 --> 00:21:19,420
these<font color="#E5E5E5"> approaches basically just</font>

449
00:21:16,510 --> 00:21:21,850
randomize in the sense that they simply

450
00:21:19,420 --> 00:21:23,710
cannot provide any guarantees they just

451
00:21:21,850 --> 00:21:26,320
try to make it<font color="#E5E5E5"> harder for an attacker</font>

452
00:21:23,710 --> 00:21:29,200
<font color="#E5E5E5">and I think all of most of these have</font>

453
00:21:26,320 --> 00:21:31,270
been bypassed redactor is probably the

454
00:21:29,200 --> 00:21:36,510
state-of-the-art system in that space or

455
00:21:31,270 --> 00:21:38,920
<font color="#CCCCCC">rejecter + + by now that it tries to</font>

456
00:21:36,510 --> 00:21:41,590
reduce the attack surface as good as

457
00:21:38,920 --> 00:21:44,470
possible redactor<font color="#CCCCCC"> plus plus has a</font>

458
00:21:41,590 --> 00:21:46,389
certain memory and also a runtime

459
00:21:44,470 --> 00:21:48,550
<font color="#CCCCCC">overhead that's probably still</font>

460
00:21:46,390 --> 00:21:50,850
acceptable in practice but traductor

461
00:21:48,550 --> 00:21:54,180
<font color="#E5E5E5">plus plus can also be bypassed because</font>

462
00:21:50,850 --> 00:21:57,070
some of the code pointers are still

463
00:21:54,180 --> 00:22:00,010
controllable by an attacker and so it's

464
00:21:57,070 --> 00:22:02,439
it's even possible<font color="#E5E5E5"> to bypass even though</font>

465
00:22:00,010 --> 00:22:06,379
state-of-the-art systems

466
00:22:02,440 --> 00:22:08,900
and then the last<font color="#CCCCCC"> column are some are</font>

467
00:22:06,380 --> 00:22:11,270
just a collection of systems that just

468
00:22:08,900 --> 00:22:13,970
provide some kind<font color="#E5E5E5"> of heuristics so they</font>

469
00:22:11,270 --> 00:22:16,639
are just mass Amherst<font color="#E5E5E5"> dig in order to</font>

470
00:22:13,970 --> 00:22:19,130
estimate whether a given piece of code

471
00:22:16,640 --> 00:22:23,150
is actually following legitimate paths

472
00:22:19,130 --> 00:22:24,980
or not k bounds are received a lot of

473
00:22:23,150 --> 00:22:27,890
attention<font color="#CCCCCC"> because it was awarded two</font>

474
00:22:24,980 --> 00:22:30,680
hundred thousand dollars<font color="#E5E5E5"> by Microsoft as</font>

475
00:22:27,890 --> 00:22:32,420
part of the blue head price but it was

476
00:22:30,680 --> 00:22:34,970
also bypassed I think one or two weeks

477
00:22:32,420 --> 00:22:37,970
later so all those heuristics actually

478
00:22:34,970 --> 00:22:41,150
turned out to<font color="#CCCCCC"> be pretty weak in it can</font>

479
00:22:37,970 --> 00:22:43,490
be regularly bypassed or pick a<font color="#E5E5E5"> tool so</font>

480
00:22:41,150 --> 00:22:46,100
all of those heuristics have the problem

481
00:22:43,490 --> 00:22:50,330
in practice that they are<font color="#E5E5E5"> not precise</font>

482
00:22:46,100 --> 00:22:54,679
enough so and I think attackers always

483
00:22:50,330 --> 00:22:56,270
will find bypasses so it seems<font color="#E5E5E5"> like all</font>

484
00:22:54,680 --> 00:22:58,250
the academic approaches that were

485
00:22:56,270 --> 00:23:01,160
presented and also what's available in

486
00:22:58,250 --> 00:23:03,050
commercial systems doesn't provide a lot

487
00:23:01,160 --> 00:23:05,660
of<font color="#E5E5E5"> hurdle for the attacker so it makes</font>

488
00:23:03,050 --> 00:23:07,550
it harder something like a SLR which is

489
00:23:05,660 --> 00:23:10,610
just<font color="#E5E5E5"> something that the attacker</font><font color="#CCCCCC"> can't</font>

490
00:23:07,550 --> 00:23:13,490
bypass if you just provides enough

491
00:23:10,610 --> 00:23:16,699
effort and we cannot provide any

492
00:23:13,490 --> 00:23:19,220
guarantees so the state of the art is

493
00:23:16,700 --> 00:23:23,420
unfortunately very sad attackers seem to

494
00:23:19,220 --> 00:23:25,720
have the advantage<font color="#CCCCCC"> we do we seem to not</font>

495
00:23:23,420 --> 00:23:27,890
<font color="#CCCCCC">be able</font><font color="#E5E5E5"> to somehow can't contain them</font>

496
00:23:25,720 --> 00:23:30,410
because once they have<font color="#E5E5E5"> something like</font>

497
00:23:27,890 --> 00:23:31,700
like<font color="#E5E5E5"> a</font><font color="#CCCCCC"> read-write primitive once they</font>

498
00:23:30,410 --> 00:23:35,990
have something<font color="#E5E5E5"> like an</font><font color="#CCCCCC"> information leak</font>

499
00:23:31,700 --> 00:23:38,090
they can always<font color="#E5E5E5"> bypass our systems so it</font>

500
00:23:35,990 --> 00:23:41,090
seems<font color="#E5E5E5"> like we need to go one step</font>

501
00:23:38,090 --> 00:23:45,740
further and try to take the attackers

502
00:23:41,090 --> 00:23:47,419
away those primitives and yeah the main

503
00:23:45,740 --> 00:23:50,000
to challenge is here on<font color="#E5E5E5"> the one hand</font>

504
00:23:47,420 --> 00:23:53,330
<font color="#E5E5E5">information leaks so when the attacker</font>

505
00:23:50,000 --> 00:23:55,250
has the information or about let's say<font color="#CCCCCC"> a</font>

506
00:23:53,330 --> 00:23:56,629
base address or<font color="#CCCCCC"> something you can</font>

507
00:23:55,250 --> 00:23:59,150
typically escalate this pretty quickly

508
00:23:56,630 --> 00:24:02,120
such that he then knows more coat

509
00:23:59,150 --> 00:24:07,700
locations and can then bypass all of the

510
00:24:02,120 --> 00:24:10,209
defenses so and I think<font color="#E5E5E5"> that's one</font>

511
00:24:07,700 --> 00:24:13,700
research area we should focus more on

512
00:24:10,210 --> 00:24:15,110
all the information leaks so how to find

513
00:24:13,700 --> 00:24:17,870
them how to prevent them

514
00:24:15,110 --> 00:24:20,479
but it turns out that this is<font color="#CCCCCC"> actually</font>

515
00:24:17,870 --> 00:24:22,489
pretty challenging because once there is

516
00:24:20,480 --> 00:24:25,580
some kind<font color="#CCCCCC"> of vulnerability</font><font color="#E5E5E5"> an attacker</font>

517
00:24:22,490 --> 00:24:28,549
can to keep turn this vulnerability into

518
00:24:25,580 --> 00:24:31,899
an information leak and typically he can

519
00:24:28,549 --> 00:24:34,970
also abuse regular<font color="#CCCCCC"> contracts in order to</font>

520
00:24:31,900 --> 00:24:37,640
construct then<font color="#E5E5E5"> information leaks so</font>

521
00:24:34,970 --> 00:24:40,309
finding them is challenging and probably

522
00:24:37,640 --> 00:24:44,600
or at least my opinions probably cannot

523
00:24:40,309 --> 00:24:47,360
<font color="#CCCCCC">be fully automated in the end and the</font>

524
00:24:44,600 --> 00:24:49,610
second example are all those<font color="#CCCCCC"> readwrite</font>

525
00:24:47,360 --> 00:24:53,418
primitives so when an attacker is able

526
00:24:49,610 --> 00:24:55,699
to change four bytes in memory or

527
00:24:53,419 --> 00:24:59,090
sometimes maybe even one bite is enough

528
00:24:55,700 --> 00:25:02,350
or maybe even less then he can lead

529
00:24:59,090 --> 00:25:05,659
<font color="#E5E5E5">typically the program into</font><font color="#CCCCCC"> a state that</font>

530
00:25:02,350 --> 00:25:08,209
then either crashes the program or that

531
00:25:05,660 --> 00:25:11,750
escalates these privileges or even

532
00:25:08,210 --> 00:25:14,210
allows code execution so the combination

533
00:25:11,750 --> 00:25:16,910
of an info leak and then a read/write

534
00:25:14,210 --> 00:25:19,100
primitive is typically enough and that's

535
00:25:16,910 --> 00:25:21,200
typically<font color="#E5E5E5"> the first step and all of this</font>

536
00:25:19,100 --> 00:25:23,149
return oriented programming or so I then

537
00:25:21,200 --> 00:25:26,419
just techniques in order to bypass other

538
00:25:23,150 --> 00:25:29,150
defenses but to prevent the attacks we

539
00:25:26,419 --> 00:25:33,620
need to<font color="#E5E5E5"> tackle info leaks and the read</font>

540
00:25:29,150 --> 00:25:37,610
Fram read right parameters first and

541
00:25:33,620 --> 00:25:40,100
then want<font color="#E5E5E5"> to talk</font><font color="#CCCCCC"> about</font><font color="#E5E5E5"> one paper we did</font>

542
00:25:37,610 --> 00:25:42,168
recently on how to at least detect

543
00:25:40,100 --> 00:25:44,659
information leaks it's definitely<font color="#CCCCCC"> not</font>

544
00:25:42,169 --> 00:25:48,350
perfect<font color="#CCCCCC"> it's cannot be easily used in</font>

545
00:25:44,660 --> 00:25:51,380
practice but still it I<font color="#E5E5E5"> think it serves</font>

546
00:25:48,350 --> 00:25:54,770
as an idea and prolly this can be

547
00:25:51,380 --> 00:25:59,809
<font color="#CCCCCC">improved and hopefully we find better</font>

548
00:25:54,770 --> 00:26:02,059
ways to do this in the<font color="#E5E5E5"> future to unsend</font>

549
00:25:59,809 --> 00:26:05,870
how what we do first need to explain a

550
00:26:02,059 --> 00:26:08,690
bit how info leaks work in<font color="#CCCCCC"> JavaScript so</font>

551
00:26:05,870 --> 00:26:12,889
we have on the left just<font color="#E5E5E5"> it I'm sorry</font>

552
00:26:08,690 --> 00:26:14,440
just a JavaScript object and what the

553
00:26:12,890 --> 00:26:17,809
attack I can then do in order to

554
00:26:14,440 --> 00:26:20,390
construct an information leak is seeking

555
00:26:17,809 --> 00:26:22,520
for example override the length field so

556
00:26:20,390 --> 00:26:26,150
the length length field is set with a

557
00:26:22,520 --> 00:26:28,550
<font color="#E5E5E5">1000 first and then he</font><font color="#CCCCCC"> just adds four so</font>

558
00:26:26,150 --> 00:26:30,500
he overrides the

559
00:26:28,550 --> 00:26:35,330
field because he has a<font color="#CCCCCC"> read-write</font>

560
00:26:30,500 --> 00:26:38,870
primitive changes<font color="#E5E5E5"> this to 1004 and I had</font>

561
00:26:35,330 --> 00:26:43,040
this change here so he over at<font color="#E5E5E5"> the</font>

562
00:26:38,870 --> 00:26:46,040
length field at 1004 and then the<font color="#E5E5E5"> the</font>

563
00:26:43,040 --> 00:26:48,889
buffer is then a bit longer<font color="#E5E5E5"> four bytes</font>

564
00:26:46,040 --> 00:26:50,659
longer and so this P pointer is a

565
00:26:48,890 --> 00:26:53,810
virtual function pointer is then leaked

566
00:26:50,660 --> 00:26:56,570
because it's included in<font color="#CCCCCC"> this data</font>

567
00:26:53,810 --> 00:26:58,909
structure and then the attacker can read

568
00:26:56,570 --> 00:27:01,370
the virtual function pointer he knows

569
00:26:58,910 --> 00:27:04,940
the value of the<font color="#E5E5E5"> function pointer and</font>

570
00:27:01,370 --> 00:27:06,590
can then use a start to abuse this

571
00:27:04,940 --> 00:27:10,550
virtual function pointer in order to

572
00:27:06,590 --> 00:27:12,980
leak more information<font color="#E5E5E5"> so by just over</font>

573
00:27:10,550 --> 00:27:15,290
writing one field he can disclose

574
00:27:12,980 --> 00:27:17,180
information and this is what i meant

575
00:27:15,290 --> 00:27:19,430
earlier information leaks to really

576
00:27:17,180 --> 00:27:22,100
don't just exist but the attacker needs

577
00:27:19,430 --> 00:27:27,170
to construct them by cleverly

578
00:27:22,100 --> 00:27:30,709
overwriting certain structures a second

579
00:27:27,170 --> 00:27:33,410
example<font color="#CCCCCC"> is if he can he can also target</font>

580
00:27:30,710 --> 00:27:35,780
the data pointer by just basically

581
00:27:33,410 --> 00:27:38,540
changing where this pointer points to he

582
00:27:35,780 --> 00:27:41,899
just<font color="#CCCCCC"> moved this a bit up so to a higher</font>

583
00:27:38,540 --> 00:27:44,120
address and then he can also get access

584
00:27:41,900 --> 00:27:46,240
to the virtual function pointer that's

585
00:27:44,120 --> 00:27:50,330
available in this<font color="#CCCCCC"> JavaScript data</font>

586
00:27:46,240 --> 00:27:54,710
structure so here's on the<font color="#CCCCCC"> attack</font><font color="#E5E5E5"> has</font>

587
00:27:50,330 --> 00:27:56,990
quite many ways to to abuse his

588
00:27:54,710 --> 00:28:02,690
<font color="#CCCCCC">read/write primitive in order to then</font>

589
00:27:56,990 --> 00:28:04,760
construct information leaks um but still

590
00:28:02,690 --> 00:28:07,310
the observation and<font color="#E5E5E5"> that's we see the</font>

591
00:28:04,760 --> 00:28:10,490
main idea<font color="#CCCCCC"> behind what we do is that an</font>

592
00:28:07,310 --> 00:28:13,370
information leak is constructed by the

593
00:28:10,490 --> 00:28:15,620
attacker in the JavaScript context so he

594
00:28:13,370 --> 00:28:19,340
abuses some problems in the JavaScript

595
00:28:15,620 --> 00:28:21,919
context in order to get of a memory

596
00:28:19,340 --> 00:28:23,720
pointer into the JavaScript context and

597
00:28:21,920 --> 00:28:26,720
that's something that<font color="#E5E5E5"> should never</font>

598
00:28:23,720 --> 00:28:29,570
happen because javascript is running<font color="#CCCCCC"> on</font>

599
00:28:26,720 --> 00:28:31,430
a more abstract level the<font color="#E5E5E5"> JavaScript</font>

600
00:28:29,570 --> 00:28:34,480
context should never contain some

601
00:28:31,430 --> 00:28:37,840
information about memory locations and

602
00:28:34,480 --> 00:28:40,760
if the<font color="#E5E5E5"> JavaScript content has</font>

603
00:28:37,840 --> 00:28:42,370
information about the memory layout then

604
00:28:40,760 --> 00:28:46,270
clearly something happened

605
00:28:42,370 --> 00:28:49,209
<font color="#CCCCCC">slee and what we didn't do is we take</font>

606
00:28:46,270 --> 00:28:52,090
<font color="#CCCCCC">the idea of invariant systems so that</font>

607
00:28:49,210 --> 00:28:54,550
you have your ones one system and

608
00:28:52,090 --> 00:28:57,639
duplicate it or you have even<font color="#E5E5E5"> several</font>

609
00:28:54,550 --> 00:29:01,889
duplicates and those duplicates are then

610
00:28:57,640 --> 00:29:05,140
running in lockstep such that use

611
00:29:01,890 --> 00:29:08,200
precisely synchronized execution of the

612
00:29:05,140 --> 00:29:10,960
different processes<font color="#CCCCCC"> and you also compare</font>

613
00:29:08,200 --> 00:29:13,840
the state of both processes and once

614
00:29:10,960 --> 00:29:17,710
they start to diverge then you have

615
00:29:13,840 --> 00:29:20,470
detected something so the idea of<font color="#E5E5E5"> this</font>

616
00:29:17,710 --> 00:29:23,950
invariant systems is also pretty old it

617
00:29:20,470 --> 00:29:26,590
says also<font color="#E5E5E5"> been done in the 70s and what</font>

618
00:29:23,950 --> 00:29:29,350
we do<font color="#CCCCCC"> is we do this in and on a more</font>

619
00:29:26,590 --> 00:29:31,510
<font color="#E5E5E5">precise level in the sense that we do</font>

620
00:29:29,350 --> 00:29:35,949
<font color="#E5E5E5">this in the JavaScript context and we do</font>

621
00:29:31,510 --> 00:29:38,200
this also for binaries and in our case

622
00:29:35,950 --> 00:29:43,000
<font color="#CCCCCC">we do this</font><font color="#E5E5E5"> for internet explorer 10 and</font>

623
00:29:38,200 --> 00:29:45,220
ie11 so the idea<font color="#E5E5E5"> is that we do on the</font>

624
00:29:43,000 --> 00:29:48,730
one hand<font color="#CCCCCC"> a per processor e randomization</font>

625
00:29:45,220 --> 00:29:52,000
so that yeah the memory layout of the

626
00:29:48,730 --> 00:29:54,520
two process is different so here<font color="#E5E5E5"> we have</font>

627
00:29:52,000 --> 00:29:57,160
on the left the<font color="#E5E5E5"> so-called matha process</font>

628
00:29:54,520 --> 00:29:59,650
and then on the right the<font color="#CCCCCC"> tryn process</font>

629
00:29:57,160 --> 00:30:02,290
and both are we randomized in the sense

630
00:29:59,650 --> 00:30:04,720
that the memory layout on the left is

631
00:30:02,290 --> 00:30:09,129
different to the memory layout on the

632
00:30:04,720 --> 00:30:11,500
right yeah we do this by just<font color="#CCCCCC"> missing a</font>

633
00:30:09,130 --> 00:30:13,390
bit with a loading mechanism such that

634
00:30:11,500 --> 00:30:15,220
we make sure<font color="#E5E5E5"> that</font><font color="#CCCCCC"> all libraries are</font>

635
00:30:13,390 --> 00:30:19,510
located are loaded two different

636
00:30:15,220 --> 00:30:22,030
addresses and what we then do is a yeah

637
00:30:19,510 --> 00:30:24,750
dual process execution so we make sure

638
00:30:22,030 --> 00:30:27,460
that<font color="#CCCCCC"> the</font><font color="#E5E5E5"> master and the trend are</font>

639
00:30:24,750 --> 00:30:30,280
executing in lockstep that they are

640
00:30:27,460 --> 00:30:33,179
synchronized in the sense that the state

641
00:30:30,280 --> 00:30:35,860
of both processes is also kept the same

642
00:30:33,179 --> 00:30:40,170
so we need to take care for example of

643
00:30:35,860 --> 00:30:42,729
randomness let's so if the master<font color="#E5E5E5"> is</font>

644
00:30:40,170 --> 00:30:44,410
generating some random data why are

645
00:30:42,730 --> 00:30:46,480
something like math.random or something

646
00:30:44,410 --> 00:30:49,510
we need to<font color="#E5E5E5"> make sure that the tryn</font>

647
00:30:46,480 --> 00:30:52,480
process gets the same randomness or if

648
00:30:49,510 --> 00:30:54,730
data is received from<font color="#E5E5E5"> the outside that</font>

649
00:30:52,480 --> 00:30:56,130
both processes work on exactly the same

650
00:30:54,730 --> 00:31:00,760
data

651
00:30:56,130 --> 00:31:03,010
and then once this the IPC between both

652
00:31:00,760 --> 00:31:07,330
process is set up so that they can<font color="#CCCCCC"> be</font>

653
00:31:03,010 --> 00:31:09,340
synchronized we closely observe what's

654
00:31:07,330 --> 00:31:11,039
happening in the JavaScript context in

655
00:31:09,340 --> 00:31:14,260
the<font color="#CCCCCC"> master and what's happening in the</font>

656
00:31:11,039 --> 00:31:17,169
JavaScript context of the<font color="#CCCCCC"> Trin and then</font>

657
00:31:14,260 --> 00:31:19,750
here once a an information leak many

658
00:31:17,169 --> 00:31:22,450
fasts then you have an illegal read here

659
00:31:19,750 --> 00:31:24,909
from the heap to the JavaScript<font color="#E5E5E5"> context</font>

660
00:31:22,450 --> 00:31:27,580
on<font color="#E5E5E5"> the right and the same also happens</font>

661
00:31:24,909 --> 00:31:30,940
on the left but since the memory layout

662
00:31:27,580 --> 00:31:34,480
of both processes is similar the lead

663
00:31:30,940 --> 00:31:37,809
addresses are also not<font color="#E5E5E5"> the same and so</font>

664
00:31:34,480 --> 00:31:40,780
we can detect that s not the same<font color="#E5E5E5"> state</font>

665
00:31:37,809 --> 00:31:45,220
in both processes so we have one pointer

666
00:31:40,780 --> 00:31:47,289
here and a pointer with a different with

667
00:31:45,220 --> 00:31:50,080
a different address in the other process

668
00:31:47,289 --> 00:31:52,110
so they diverge and this is the point

669
00:31:50,080 --> 00:31:54,610
where the<font color="#CCCCCC"> information leak is actually</font>

670
00:31:52,110 --> 00:31:56,979
manifests and so this<font color="#E5E5E5"> is the earliest</font>

671
00:31:54,610 --> 00:32:02,530
<font color="#CCCCCC">point possible where we can detect that</font>

672
00:31:56,980 --> 00:32:05,830
something is<font color="#CCCCCC"> going wrong we as I said</font>

673
00:32:02,530 --> 00:32:08,590
implemented this on<font color="#E5E5E5"> Windows 8 with</font>

674
00:32:05,830 --> 00:32:11,230
Internet Explorer 10 and 11 and the idea

675
00:32:08,590 --> 00:32:13,959
<font color="#CCCCCC">is</font><font color="#E5E5E5"> that I see you have a wrapper for the</font>

676
00:32:11,230 --> 00:32:16,720
IE main process and then each time you

677
00:32:13,960 --> 00:32:19,000
start to browse we do<font color="#CCCCCC"> this</font><font color="#E5E5E5"> in an</font>

678
00:32:16,720 --> 00:32:21,010
automated way that we create a<font color="#E5E5E5"> train we</font>

679
00:32:19,000 --> 00:32:23,470
set up the IPC channel we closely

680
00:32:21,010 --> 00:32:25,780
synchronize what's happening and also

681
00:32:23,470 --> 00:32:29,500
<font color="#E5E5E5">read randomize the tryn actually do this</font>

682
00:32:25,780 --> 00:32:31,389
<font color="#E5E5E5">in the first</font><font color="#CCCCCC"> step as</font><font color="#E5E5E5"> you can imagine</font>

683
00:32:29,500 --> 00:32:34,809
that's quite a lot of<font color="#E5E5E5"> implementation</font>

684
00:32:31,390 --> 00:32:38,260
effort because you do this with the IE

685
00:32:34,809 --> 00:32:41,379
10 with<font color="#E5E5E5"> the chacha engines or a highly</font>

686
00:32:38,260 --> 00:32:44,799
optimized piece of code you need to dive

687
00:32:41,380 --> 00:32:48,179
a lot into details I think the PG

688
00:32:44,799 --> 00:32:50,650
students probably implemented on this I

689
00:32:48,179 --> 00:32:52,530
think probably you spend more<font color="#E5E5E5"> than one</font>

690
00:32:50,650 --> 00:32:56,140
person year just on the implementation

691
00:32:52,530 --> 00:33:01,928
it was a bit<font color="#E5E5E5"> of a crazy project but at</font>

692
00:32:56,140 --> 00:33:03,850
the end it works the overhead is it's a

693
00:33:01,929 --> 00:33:06,190
bit on the higher side so definitely not

694
00:33:03,850 --> 00:33:08,530
something you can easily<font color="#CCCCCC"> apply to all of</font>

695
00:33:06,190 --> 00:33:09,110
your desktops so the startup time is

696
00:33:08,530 --> 00:33:12,379
about

697
00:33:09,110 --> 00:33:16,040
<font color="#CCCCCC">1.3 times so it's it's definitely slower</font>

698
00:33:12,380 --> 00:33:18,770
to start up when you then do browsing

699
00:33:16,040 --> 00:33:20,928
and here we<font color="#CCCCCC"> have</font><font color="#E5E5E5"> a small benchmark on</font>

700
00:33:18,770 --> 00:33:22,580
some popular sites do you<font color="#E5E5E5"> see that the</font>

701
00:33:20,929 --> 00:33:24,950
average overhead is about seventeen

702
00:33:22,580 --> 00:33:28,250
percent so it's not<font color="#CCCCCC"> really noticeable</font>

703
00:33:24,950 --> 00:33:32,870
noticeable but you can still measure it

704
00:33:28,250 --> 00:33:35,240
and yeah<font color="#E5E5E5"> that's a certain overhead so</font>

705
00:33:32,870 --> 00:33:36,949
it's not not just<font color="#CCCCCC"> one percent overhead</font>

706
00:33:35,240 --> 00:33:39,530
but more like seventeen percent as I

707
00:33:36,950 --> 00:33:41,150
said so it's still some engineering

708
00:33:39,530 --> 00:33:44,030
would be needed to<font color="#E5E5E5"> basically bring this</font>

709
00:33:41,150 --> 00:33:46,190
down<font color="#E5E5E5"> from more reasonable level the only</font>

710
00:33:44,030 --> 00:33:50,030
advantage is that since the<font color="#CCCCCC"> browsers</font>

711
00:33:46,190 --> 00:33:52,040
optimized so much that it<font color="#CCCCCC"> displayed all</font>

712
00:33:50,030 --> 00:33:54,260
it shows you some rendering as fast as

713
00:33:52,040 --> 00:33:56,210
<font color="#CCCCCC">possible and everything what we do</font>

714
00:33:54,260 --> 00:33:58,610
actually<font color="#E5E5E5"> is happening in the background</font>

715
00:33:56,210 --> 00:34:00,410
<font color="#E5E5E5">and</font><font color="#CCCCCC"> the user to Billy doesn't see</font>

716
00:33:58,610 --> 00:34:05,510
anything so it's not really notable for

717
00:34:00,410 --> 00:34:08,090
the user with it just this with several

718
00:34:05,510 --> 00:34:10,550
pure information leaks that for example

719
00:34:08,090 --> 00:34:12,280
just<font color="#E5E5E5"> leak some information from a from</font>

720
00:34:10,550 --> 00:34:16,639
an image so some image processing

721
00:34:12,280 --> 00:34:20,330
problems or some other memory location

722
00:34:16,639 --> 00:34:22,100
also know some other info leaks for

723
00:34:20,330 --> 00:34:23,929
different kinds<font color="#CCCCCC"> of pros are related</font>

724
00:34:22,100 --> 00:34:27,319
vulnerabilities and of course we

725
00:34:23,929 --> 00:34:30,350
detected just<font color="#E5E5E5"> by design and when</font>

726
00:34:27,320 --> 00:34:33,560
browsing through the Alexa top 100 we

727
00:34:30,350 --> 00:34:35,989
also didn't<font color="#E5E5E5"> get any false positive so</font>

728
00:34:33,560 --> 00:34:37,668
the concept works it has a certain

729
00:34:35,989 --> 00:34:40,100
overhead especially<font color="#E5E5E5"> on the memory side</font>

730
00:34:37,668 --> 00:34:42,109
so we have about fifty<font color="#CCCCCC"> percent more</font>

731
00:34:40,100 --> 00:34:44,319
memory consumption so there's also

732
00:34:42,109 --> 00:34:47,449
something that needs to<font color="#CCCCCC"> be done there</font>

733
00:34:44,320 --> 00:34:49,850
but if I think still I still<font color="#E5E5E5"> think that</font>

734
00:34:47,449 --> 00:34:51,469
<font color="#E5E5E5">that's a viable approach in order to</font>

735
00:34:49,850 --> 00:34:55,129
basically try to tackle information

736
00:34:51,469 --> 00:34:56,629
leaks probably they are better ones so I

737
00:34:55,129 --> 00:34:59,540
think<font color="#E5E5E5"> that's something where we need to</font>

738
00:34:56,629 --> 00:35:01,819
spend<font color="#E5E5E5"> way more time on how to detect how</font>

739
00:34:59,540 --> 00:35:04,340
to prevent information leaks because

740
00:35:01,820 --> 00:35:06,770
that's yeah one<font color="#CCCCCC"> of the root causes if</font>

741
00:35:04,340 --> 00:35:08,630
you take<font color="#CCCCCC"> a look</font><font color="#E5E5E5"> at modern attacks one of</font>

742
00:35:06,770 --> 00:35:11,090
the first steps<font color="#E5E5E5"> that they do is that</font>

743
00:35:08,630 --> 00:35:13,460
they use an info leak and only later on

744
00:35:11,090 --> 00:35:16,510
they can bypass or the other defenses or

745
00:35:13,460 --> 00:35:16,510
use other techniques

746
00:35:17,050 --> 00:35:22,450
and then in the<font color="#E5E5E5"> last 10</font><font color="#CCCCCC"> minutes I want</font>

747
00:35:20,140 --> 00:35:26,410
<font color="#CCCCCC">to talk a bit about other things we do</font>

748
00:35:22,450 --> 00:35:29,290
or what I think is<font color="#E5E5E5"> also the challenging</font>

749
00:35:26,410 --> 00:35:31,509
<font color="#E5E5E5">attack</font><font color="#CCCCCC"> side in the future that we are</font>

750
00:35:29,290 --> 00:35:34,270
moving more and more away from code

751
00:35:31,510 --> 00:35:36,970
route from return oriented programming

752
00:35:34,270 --> 00:35:39,700
but to other kinds of code reuse attacks

753
00:35:36,970 --> 00:35:42,009
and especially code reuse the texts<font color="#CCCCCC"> that</font>

754
00:35:39,700 --> 00:35:44,310
do not modify code pointers because I

755
00:35:42,010 --> 00:35:48,040
think<font color="#CCCCCC"> we better understand now how to</font>

756
00:35:44,310 --> 00:35:50,110
protect code pointers but all those data

757
00:35:48,040 --> 00:35:52,450
only attacks so where the attacker

758
00:35:50,110 --> 00:35:54,400
doesn't modify a code pointer but where

759
00:35:52,450 --> 00:35:57,189
he only modifies data structures in

760
00:35:54,400 --> 00:35:59,830
order to influence the control flow I

761
00:35:57,190 --> 00:36:01,870
think that's something that will keep<font color="#CCCCCC"> us</font>

762
00:35:59,830 --> 00:36:04,810
busy in the next<font color="#CCCCCC"> few years because</font>

763
00:36:01,870 --> 00:36:10,600
<font color="#CCCCCC">that's also way harder to protect</font>

764
00:36:04,810 --> 00:36:12,370
against I want<font color="#E5E5E5"> to start with a just a</font>

765
00:36:10,600 --> 00:36:15,730
brief overview of<font color="#E5E5E5"> a paper that we did</font>

766
00:36:12,370 --> 00:36:18,400
also<font color="#CCCCCC"> two years ago where the basic</font>

767
00:36:15,730 --> 00:36:20,860
inside is that hooking actually got much

768
00:36:18,400 --> 00:36:23,140
harder so traditionally<font color="#CCCCCC"> you would do</font>

769
00:36:20,860 --> 00:36:26,860
something if you want to implement a

770
00:36:23,140 --> 00:36:30,190
coat hook that you that you override

771
00:36:26,860 --> 00:36:31,900
here a specific code pointer the the

772
00:36:30,190 --> 00:36:35,020
code pointer then doesn't point to the

773
00:36:31,900 --> 00:36:37,870
lid legitimate function but it first

774
00:36:35,020 --> 00:36:39,490
points22 your hook in the hook you do

775
00:36:37,870 --> 00:36:42,250
your computations that you want<font color="#E5E5E5"> to do as</font>

776
00:36:39,490 --> 00:36:45,129
an attacker and only afterwards you call

777
00:36:42,250 --> 00:36:48,550
the legitimate function so you divert

778
00:36:45,130 --> 00:36:50,050
the code pointer to your hook or if you

779
00:36:48,550 --> 00:36:52,270
want to implement the data hook you

780
00:36:50,050 --> 00:36:54,250
basically do something similar in the

781
00:36:52,270 --> 00:36:56,410
<font color="#E5E5E5">cisco table you override one of the</font>

782
00:36:54,250 --> 00:36:58,210
entries the entry then points to your

783
00:36:56,410 --> 00:37:00,700
hooking code and then now only

784
00:36:58,210 --> 00:37:04,060
afterwards you basically call the

785
00:37:00,700 --> 00:37:06,549
legitimate function there are many

786
00:37:04,060 --> 00:37:07,779
techniques available to provide and

787
00:37:06,550 --> 00:37:10,600
check<font color="#E5E5E5"> your tea for this kind of data</font>

788
00:37:07,780 --> 00:37:12,910
structures so code and data hooks I

789
00:37:10,600 --> 00:37:17,410
think well understood and<font color="#E5E5E5"> they are as I</font>

790
00:37:12,910 --> 00:37:20,680
said<font color="#E5E5E5"> many defenses already available and</font>

791
00:37:17,410 --> 00:37:22,779
especially those changes of<font color="#CCCCCC"> control data</font>

792
00:37:20,680 --> 00:37:26,669
that's needed with<font color="#E5E5E5"> this kind of folks is</font>

793
00:37:22,780 --> 00:37:26,670
easy to detect in practice

794
00:37:27,280 --> 00:37:33,560
but what's harder to<font color="#E5E5E5"> detect is if the</font>

795
00:37:30,530 --> 00:37:35,600
attacker abuses legitimate code so if he

796
00:37:33,560 --> 00:37:38,330
performs some kind of data only attack

797
00:37:35,600 --> 00:37:42,290
in order to then implement<font color="#CCCCCC"> the smoking</font>

798
00:37:38,330 --> 00:37:44,299
<font color="#E5E5E5">mechanism and this works as follows so</font>

799
00:37:42,290 --> 00:37:46,580
<font color="#E5E5E5">imagine we have a code block that's</font>

800
00:37:44,300 --> 00:37:49,490
doing nothing more than just writing a

801
00:37:46,580 --> 00:37:52,670
value to a memory location at a specific

802
00:37:49,490 --> 00:37:54,529
destination so we have here a right and

803
00:37:52,670 --> 00:37:57,470
the right<font color="#E5E5E5"> can</font><font color="#CCCCCC"> be something</font><font color="#E5E5E5"> just like a</font>

804
00:37:54,530 --> 00:38:01,580
move instruction that moves a certain

805
00:37:57,470 --> 00:38:03,770
value to a specific memory location what

806
00:38:01,580 --> 00:38:05,840
we<font color="#E5E5E5"> then do in the first step is we go</font>

807
00:38:03,770 --> 00:38:08,750
<font color="#E5E5E5">backwards in the code to figure out</font>

808
00:38:05,840 --> 00:38:10,940
where was value and war where was

809
00:38:08,750 --> 00:38:13,280
destination written for the first time

810
00:38:10,940 --> 00:38:15,410
so where I was it loaded so we go back

811
00:38:13,280 --> 00:38:17,830
<font color="#CCCCCC">in the control flow graph and find</font>

812
00:38:15,410 --> 00:38:21,560
specific areas or specific code

813
00:38:17,830 --> 00:38:24,410
locations where a<font color="#E5E5E5"> load for a happens</font>

814
00:38:21,560 --> 00:38:26,720
where a load for be happens and then we

815
00:38:24,410 --> 00:38:29,060
see<font color="#CCCCCC"> okay in these four locations we load</font>

816
00:38:26,720 --> 00:38:32,810
the values then we follow the path

817
00:38:29,060 --> 00:38:34,880
downwards again and try to see what<font color="#E5E5E5"> kind</font>

818
00:38:32,810 --> 00:38:37,370
of computations are happening on a or

819
00:38:34,880 --> 00:38:40,010
kind<font color="#E5E5E5"> of computation</font><font color="#CCCCCC"> ink siphoning on be</font>

820
00:38:37,370 --> 00:38:44,810
and how does this influence value and

821
00:38:40,010 --> 00:38:46,910
destination at the end there you can do

822
00:38:44,810 --> 00:38:48,500
<font color="#E5E5E5">something like symbolic execution so</font>

823
00:38:46,910 --> 00:38:50,779
basically from here you just go

824
00:38:48,500 --> 00:38:55,100
downwards just collect the different

825
00:38:50,780 --> 00:38:56,930
expressions so that<font color="#CCCCCC"> yeah things are</font>

826
00:38:55,100 --> 00:38:59,650
computations that are happening on the

827
00:38:56,930 --> 00:39:03,980
path you<font color="#E5E5E5"> basically solve those</font>

828
00:38:59,650 --> 00:39:06,560
constraints with now as with some tools

829
00:39:03,980 --> 00:39:08,240
and<font color="#E5E5E5"> then at the end you know okay here</font>

830
00:39:06,560 --> 00:39:10,880
at the beginning<font color="#E5E5E5"> the initialization</font>

831
00:39:08,240 --> 00:39:13,100
happened they wear some computations

832
00:39:10,880 --> 00:39:15,500
happening on the path and at the<font color="#CCCCCC"> end</font>

833
00:39:13,100 --> 00:39:18,049
basically<font color="#E5E5E5"> your system tells you</font><font color="#CCCCCC"> okay you</font>

834
00:39:15,500 --> 00:39:21,110
need to initially initialize value to a

835
00:39:18,050 --> 00:39:24,200
specific or you need to initialize a to

836
00:39:21,110 --> 00:39:27,560
specific value such that it has a

837
00:39:24,200 --> 00:39:30,649
specific other value at<font color="#E5E5E5"> the bottom and</font>

838
00:39:27,560 --> 00:39:32,390
you can also do the<font color="#CCCCCC"> same for</font><font color="#E5E5E5"> P such that</font>

839
00:39:30,650 --> 00:39:35,150
you know okay how do I need to influence

840
00:39:32,390 --> 00:39:38,480
<font color="#E5E5E5">a and B in order to influence the</font>

841
00:39:35,150 --> 00:39:41,540
destination and the<font color="#CCCCCC"> sauce</font>

842
00:39:38,480 --> 00:39:45,170
and once you have this and that as<font color="#CCCCCC"> a set</font>

843
00:39:41,540 --> 00:39:48,590
can be fully automated you can use this

844
00:39:45,170 --> 00:39:51,530
in order<font color="#E5E5E5"> to to install</font><font color="#CCCCCC"> your hook on</font>

845
00:39:48,590 --> 00:39:54,380
demand and<font color="#E5E5E5"> the interesting thing</font><font color="#CCCCCC"> is that</font>

846
00:39:51,530 --> 00:39:58,970
this will then<font color="#E5E5E5"> only be activated during</font>

847
00:39:54,380 --> 00:40:01,190
<font color="#CCCCCC">runtime another question is where do we</font>

848
00:39:58,970 --> 00:40:05,149
find<font color="#E5E5E5"> this kind of abusable code</font>

849
00:40:01,190 --> 00:40:07,370
locations and one instance of this would

850
00:40:05,150 --> 00:40:09,140
be<font color="#CCCCCC"> something like</font><font color="#E5E5E5"> a linked list so we</font>

851
00:40:07,370 --> 00:40:13,100
have just a data structure<font color="#E5E5E5"> that is a</font>

852
00:40:09,140 --> 00:40:15,500
next in the previous pointer and what we

853
00:40:13,100 --> 00:40:17,720
now do is we want<font color="#E5E5E5"> to abuse this kind of</font>

854
00:40:15,500 --> 00:40:19,190
data structure to implement the idea

855
00:40:17,720 --> 00:40:22,640
that<font color="#E5E5E5"> I just explained on</font><font color="#CCCCCC"> the previous</font>

856
00:40:19,190 --> 00:40:26,150
slide and what we do<font color="#E5E5E5"> is we create a list</font>

857
00:40:22,640 --> 00:40:30,140
entry and the list entry is created in a

858
00:40:26,150 --> 00:40:33,170
specific way such that we we create this

859
00:40:30,140 --> 00:40:36,259
list entry as an attacker we point the

860
00:40:33,170 --> 00:40:38,480
next pointer to a specific<font color="#E5E5E5"> address where</font>

861
00:40:36,260 --> 00:40:41,510
the hooking code that we want<font color="#E5E5E5"> to trigger</font>

862
00:40:38,480 --> 00:40:43,610
is located and the previous<font color="#E5E5E5"> pointer is</font>

863
00:40:41,510 --> 00:40:45,470
located to the stack on a<font color="#CCCCCC"> specific</font>

864
00:40:43,610 --> 00:40:49,750
address<font color="#E5E5E5"> where a return address is</font>

865
00:40:45,470 --> 00:40:53,330
located and what we then do is with this

866
00:40:49,750 --> 00:40:56,420
with this modified list entry that we

867
00:40:53,330 --> 00:40:59,240
then trigger that it should<font color="#CCCCCC"> be removed</font>

868
00:40:56,420 --> 00:41:00,920
from the linked list removing an entry

869
00:40:59,240 --> 00:41:02,779
from the linked list<font color="#CCCCCC"> as</font><font color="#E5E5E5"> a 3 to</font>

870
00:41:00,920 --> 00:41:04,940
operations we need to adjust the

871
00:41:02,780 --> 00:41:07,040
previews and the next pointer that's on

872
00:41:04,940 --> 00:41:09,230
<font color="#E5E5E5">the top and on the sampler side it looks</font>

873
00:41:07,040 --> 00:41:12,050
like this that the next point has just

874
00:41:09,230 --> 00:41:17,000
adjusted and the important thing is this

875
00:41:12,050 --> 00:41:19,880
year this is we move a specific value<font color="#E5E5E5"> to</font>

876
00:41:17,000 --> 00:41:21,590
a specific memory location so that's

877
00:41:19,880 --> 00:41:26,680
<font color="#CCCCCC">exactly</font><font color="#E5E5E5"> what I had on the previous slide</font>

878
00:41:21,590 --> 00:41:30,950
and if free prayer prev and next are

879
00:41:26,680 --> 00:41:34,970
initialized in as in as a counter feed

880
00:41:30,950 --> 00:41:37,009
list entry and if this code location is

881
00:41:34,970 --> 00:41:39,830
then triggered it does exactly what we

882
00:41:37,010 --> 00:41:42,170
want to do so it overrides the return

883
00:41:39,830 --> 00:41:45,110
address with a jump to our hooking

884
00:41:42,170 --> 00:41:47,420
address and then we can when this

885
00:41:45,110 --> 00:41:49,220
legitimate code is followed the data

886
00:41:47,420 --> 00:41:50,599
only attack is actually happening<font color="#E5E5E5"> and</font>

887
00:41:49,220 --> 00:41:54,288
then we

888
00:41:50,599 --> 00:41:56,930
can<font color="#E5E5E5"> install the hook during</font><font color="#CCCCCC"> run time and</font>

889
00:41:54,289 --> 00:42:00,289
this<font color="#E5E5E5"> idea can be actually generalized in</font>

890
00:41:56,930 --> 00:42:04,399
the sense that this move instruction is

891
00:42:00,289 --> 00:42:08,089
actually something like<font color="#E5E5E5"> right for as a</font>

892
00:42:04,400 --> 00:42:09,410
data oriented gadget and you can then if

893
00:42:08,089 --> 00:42:12,430
you search for this kind of gadgets you

894
00:42:09,410 --> 00:42:16,009
can find similar instances so you can

895
00:42:12,430 --> 00:42:18,739
find gadgets that do not implement drop

896
00:42:16,009 --> 00:42:21,499
primitives but that implement data only

897
00:42:18,739 --> 00:42:25,099
primitives the challenge is then to

898
00:42:21,499 --> 00:42:27,288
stitch those on<font color="#E5E5E5"> these kind of gadgets</font>

899
00:42:25,099 --> 00:42:30,499
together but it turns out that you can

900
00:42:27,289 --> 00:42:34,759
also do arbitrary computations by just

901
00:42:30,499 --> 00:42:37,249
using those data oriented gadgets and we

902
00:42:34,759 --> 00:42:39,259
have an<font color="#E5E5E5"> upcoming paper it's only a</font>

903
00:42:37,249 --> 00:42:42,439
submission but eventually hopefully

904
00:42:39,259 --> 00:42:44,690
public where we demonstrate that this

905
00:42:42,440 --> 00:42:51,229
data only attacks can be fully automated

906
00:42:44,690 --> 00:42:53,599
also for<font color="#E5E5E5"> binaries I think n just now I</font>

907
00:42:51,229 --> 00:42:56,450
<font color="#CCCCCC">think I skip this one but</font><font color="#E5E5E5"> yesterday you</font>

908
00:42:53,599 --> 00:42:58,430
saw the<font color="#E5E5E5"> D civilization talk by Matthias</font>

909
00:42:56,450 --> 00:43:00,049
<font color="#CCCCCC">and</font><font color="#E5E5E5"> 40 i missed it but that's</font><font color="#CCCCCC"> actually</font>

910
00:42:58,430 --> 00:43:04,308
something very similar to code reuse

911
00:43:00,049 --> 00:43:07,059
attack so you you inject data structure

912
00:43:04,309 --> 00:43:09,559
in this case here just a fake value and

913
00:43:07,059 --> 00:43:14,329
the DC realization is actually

914
00:43:09,559 --> 00:43:16,880
triggering a code reuse and then as the

915
00:43:14,329 --> 00:43:19,910
last example of what I think<font color="#CCCCCC"> will is or</font>

916
00:43:16,880 --> 00:43:22,400
is interesting is that the attacker can

917
00:43:19,910 --> 00:43:24,950
not only be used specific code

918
00:43:22,400 --> 00:43:26,900
structures but<font color="#E5E5E5"> we also implemented a</font>

919
00:43:24,950 --> 00:43:29,118
technique like a called counterfeit

920
00:43:26,900 --> 00:43:34,029
object-oriented<font color="#E5E5E5"> programming where the</font>

921
00:43:29,119 --> 00:43:37,989
<font color="#E5E5E5">idea is that we abuse C++ objects so we</font>

922
00:43:34,029 --> 00:43:40,880
create fake objects the objects are

923
00:43:37,989 --> 00:43:43,789
constructed in<font color="#CCCCCC"> a specific way</font><font color="#E5E5E5"> and then</font>

924
00:43:40,880 --> 00:43:46,819
we do not reuse small gadgets but we

925
00:43:43,789 --> 00:43:48,710
perform full function code reuse and it

926
00:43:46,819 --> 00:43:51,380
turns out that this kind of attack

927
00:43:48,710 --> 00:43:54,079
actually can bypass many of the

928
00:43:51,380 --> 00:43:56,749
available defenses so all of the<font color="#E5E5E5"> binary</font>

929
00:43:54,079 --> 00:44:00,469
only defenses they don't take C++

930
00:43:56,749 --> 00:44:03,140
semantics into account can be bypassed

931
00:44:00,469 --> 00:44:03,890
and in the paper we describe all the

932
00:44:03,140 --> 00:44:06,500
details

933
00:44:03,890 --> 00:44:09,319
but it turns out that you can find the

934
00:44:06,500 --> 00:44:12,260
same thing like gadgets but they are not

935
00:44:09,319 --> 00:44:14,480
just small gadgets that<font color="#E5E5E5"> are just a few</font>

936
00:44:12,260 --> 00:44:18,200
instructions but<font color="#E5E5E5"> you can find full</font>

937
00:44:14,480 --> 00:44:20,900
functions that can be reused<font color="#E5E5E5"> and they</font>

938
00:44:18,200 --> 00:44:23,598
can then serve as your building blocks

939
00:44:20,900 --> 00:44:25,609
of the<font color="#E5E5E5"> attack and</font><font color="#CCCCCC"> the challenge is then</font>

940
00:44:23,599 --> 00:44:27,170
to find<font color="#E5E5E5"> this kind of main loop and the</font>

941
00:44:25,609 --> 00:44:28,940
main loop then allows you to call the

942
00:44:27,170 --> 00:44:30,829
different gadgets<font color="#E5E5E5"> you need to also</font>

943
00:44:28,940 --> 00:44:34,400
stitch them together in a precise way

944
00:44:30,829 --> 00:44:36,319
but this also works for c++ and we also

945
00:44:34,400 --> 00:44:38,930
have an implementation for objective-c

946
00:44:36,319 --> 00:44:41,720
where you can take it an input a binary

947
00:44:38,930 --> 00:44:45,109
and it constructs this kind of exploit

948
00:44:41,720 --> 00:44:47,419
in an automated way for you and to skip

949
00:44:45,109 --> 00:44:50,000
this but it's just explaining what we do

950
00:44:47,420 --> 00:44:52,190
so we inject a fake object that's

951
00:44:50,000 --> 00:44:56,170
constructed in specific<font color="#CCCCCC"> way that helps</font>

952
00:44:52,190 --> 00:45:00,160
<font color="#E5E5E5">us to do a betrayal computations again</font>

953
00:44:56,170 --> 00:45:03,380
so the conclusion what I<font color="#E5E5E5"> think is that</font>

954
00:45:00,160 --> 00:45:06,109
we'll have a lot of more of<font color="#E5E5E5"> this arms</font>

955
00:45:03,380 --> 00:45:08,000
race in the<font color="#E5E5E5"> future so on the one</font><font color="#CCCCCC"> hand we</font>

956
00:45:06,109 --> 00:45:10,339
see more<font color="#CCCCCC"> and more attacks especially</font>

957
00:45:08,000 --> 00:45:12,500
data-oriented takes a text will be

958
00:45:10,339 --> 00:45:15,019
challenging because it's hard to

959
00:45:12,500 --> 00:45:16,940
basically find them if you for example

960
00:45:15,019 --> 00:45:19,008
remember the<font color="#CCCCCC"> gut moed exploit in</font>

961
00:45:16,940 --> 00:45:21,349
internet explorer<font color="#CCCCCC"> i think two or three</font>

962
00:45:19,009 --> 00:45:23,599
<font color="#E5E5E5">years ago where only a single bite was</font>

963
00:45:21,349 --> 00:45:25,519
overwritten by the attacker and suddenly

964
00:45:23,599 --> 00:45:28,279
<font color="#CCCCCC">I</font><font color="#E5E5E5"> II was running in higher privileged</font>

965
00:45:25,519 --> 00:45:30,950
context and if you<font color="#E5E5E5"> take a look at many</font>

966
00:45:28,279 --> 00:45:33,799
modern exploits they do<font color="#E5E5E5"> not take a</font>

967
00:45:30,950 --> 00:45:36,259
<font color="#E5E5E5">leveraged regenerate programming law</font>

968
00:45:33,799 --> 00:45:38,390
anymore but they<font color="#E5E5E5"> just have a small of</font>

969
00:45:36,259 --> 00:45:41,119
you small primitives where they take

970
00:45:38,390 --> 00:45:45,348
<font color="#E5E5E5">information leaks where they have a read</font>

971
00:45:41,119 --> 00:45:47,750
or write for and then<font color="#E5E5E5"> able wire some</font>

972
00:45:45,349 --> 00:45:51,019
kind<font color="#E5E5E5"> of data only attack to bypass all</font>

973
00:45:47,750 --> 00:45:53,390
of the<font color="#E5E5E5"> existing defenses just as the</font>

974
00:45:51,019 --> 00:45:57,019
last slide at Twitter discussion you

975
00:45:53,390 --> 00:45:59,868
should<font color="#E5E5E5"> probably follow so I think two or</font>

976
00:45:57,019 --> 00:46:03,500
three<font color="#CCCCCC"> days ago have I wrote a bit of a</font>

977
00:45:59,869 --> 00:46:07,009
<font color="#CCCCCC">rambling and that very similar idea that</font>

978
00:46:03,500 --> 00:46:10,730
he said<font color="#CCCCCC"> rob is dead and he also says</font>

979
00:46:07,009 --> 00:46:12,500
that Rob is basically only a small part

980
00:46:10,730 --> 00:46:15,559
and the main challenge is the info leak

981
00:46:12,500 --> 00:46:17,250
and the retry primitive and especially

982
00:46:15,559 --> 00:46:19,350
if the attacker has

983
00:46:17,250 --> 00:46:22,020
some interpreter available to him<font color="#E5E5E5"> sauna</font>

984
00:46:19,350 --> 00:46:25,620
browser context or jet engine that's

985
00:46:22,020 --> 00:46:27,960
designed to generate code for the

986
00:46:25,620 --> 00:46:31,470
attacker then it's pretty<font color="#E5E5E5"> hard to</font>

987
00:46:27,960 --> 00:46:35,280
basically prevent against and I think

988
00:46:31,470 --> 00:46:37,830
he's right here as always<font color="#E5E5E5"> he's right so</font>

989
00:46:35,280 --> 00:46:40,110
here's many good points and I think

990
00:46:37,830 --> 00:46:44,509
<font color="#CCCCCC">there we have many challenges to solve</font>

991
00:46:40,110 --> 00:46:44,510
in the future thanks a<font color="#E5E5E5"> lot</font>

