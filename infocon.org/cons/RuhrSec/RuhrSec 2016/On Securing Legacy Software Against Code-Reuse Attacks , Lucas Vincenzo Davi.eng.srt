1
00:00:01,730 --> 00:00:07,648
thank you thanks<font color="#E5E5E5"> for the introduction in</font>

2
00:00:05,609 --> 00:00:09,269
this talk<font color="#CCCCCC"> I will present a short</font>

3
00:00:07,649 --> 00:00:11,160
overview of<font color="#E5E5E5"> the research that</font><font color="#CCCCCC"> we have</font>

4
00:00:09,269 --> 00:00:13,559
been<font color="#CCCCCC"> doing</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> the area of code reuse</font>

5
00:00:11,160 --> 00:00:15,480
attacks you had already a very nice

6
00:00:13,559 --> 00:00:18,210
introduction this morning in the keynote

7
00:00:15,480 --> 00:00:20,609
of<font color="#CCCCCC"> torsten of course there is some</font>

8
00:00:18,210 --> 00:00:22,769
overlapping here but I will<font color="#E5E5E5"> also present</font>

9
00:00:20,609 --> 00:00:24,660
you some new stuff in<font color="#E5E5E5"> particular will</font>

10
00:00:22,769 --> 00:00:26,580
discuss control flow integrity and

11
00:00:24,660 --> 00:00:28,140
finding code randomization<font color="#E5E5E5"> and in the</font>

12
00:00:26,580 --> 00:00:30,538
last part of this presentation I will

13
00:00:28,140 --> 00:00:35,399
talk about our recent work on page table

14
00:00:30,539 --> 00:00:37,559
randomization is we all know today's

15
00:00:35,399 --> 00:00:39,809
devices execute a large<font color="#CCCCCC"> variety of</font>

16
00:00:37,559 --> 00:00:42,620
software programs and these programs are

17
00:00:39,809 --> 00:00:44,879
<font color="#E5E5E5">increasingly sophisticated and complex</font>

18
00:00:42,620 --> 00:00:46,589
further there<font color="#E5E5E5"> are various developers</font>

19
00:00:44,879 --> 00:00:48,570
involved in creating these software

20
00:00:46,590 --> 00:00:52,829
programs where most of them are not

21
00:00:48,570 --> 00:00:54,239
security experts for the more software

22
00:00:52,829 --> 00:00:56,610
is still based on a large amount of

23
00:00:54,239 --> 00:00:58,919
native code meaning code written and

24
00:00:56,610 --> 00:01:01,739
languages like C and C++ which are not

25
00:00:58,920 --> 00:01:04,860
per se typesafe and this introduces a

26
00:01:01,739 --> 00:01:06,780
high probability for program box that an

27
00:01:04,860 --> 00:01:09,360
attacker<font color="#CCCCCC"> can exploit for so-called</font>

28
00:01:06,780 --> 00:01:12,840
runtime exploits or control flow attacks

29
00:01:09,360 --> 00:01:15,180
that corrupt the execution flow of the

30
00:01:12,840 --> 00:01:17,310
program<font color="#E5E5E5"> and then start malicious actions</font>

31
00:01:15,180 --> 00:01:20,250
and these attacks affect many

32
00:01:17,310 --> 00:01:24,570
architectures from desktop<font color="#E5E5E5"> PCs to mobile</font>

33
00:01:20,250 --> 00:01:26,759
phones and even IOT devices in general

34
00:01:24,570 --> 00:01:28,619
there are two basic techniques<font color="#CCCCCC"> to</font>

35
00:01:26,759 --> 00:01:30,450
exploit<font color="#CCCCCC"> the program the first one is</font>

36
00:01:28,619 --> 00:01:32,430
code injection and the second one is

37
00:01:30,450 --> 00:01:36,119
<font color="#E5E5E5">code reuse which is the main focus</font><font color="#CCCCCC"> of</font>

38
00:01:32,430 --> 00:01:38,009
this talk these attacks can be best

39
00:01:36,119 --> 00:01:40,290
illustrated with a control flow graph

40
00:01:38,009 --> 00:01:41,909
where the graph represent the valid

41
00:01:40,290 --> 00:01:45,180
execution<font color="#E5E5E5"> paths the program may follow</font>

42
00:01:41,909 --> 00:01:48,210
at runtime and the note in<font color="#E5E5E5"> this graph</font>

43
00:01:45,180 --> 00:01:49,950
are represented for basic blocks where a

44
00:01:48,210 --> 00:01:52,320
basic block is a sequence<font color="#E5E5E5"> of machine</font>

45
00:01:49,950 --> 00:01:54,479
instructions with a unique entry and a

46
00:01:52,320 --> 00:01:56,908
unique exit instruction and the exit

47
00:01:54,479 --> 00:01:59,039
instruction can be a branch<font color="#E5E5E5"> that allows</font>

48
00:01:56,909 --> 00:02:01,799
the transition from one node to<font color="#E5E5E5"> the next</font>

49
00:01:59,040 --> 00:02:03,509
node assuming<font color="#E5E5E5"> that this program has a</font>

50
00:02:01,799 --> 00:02:06,450
vulnerability such as a buffer overflow

51
00:02:03,509 --> 00:02:09,090
error then the attacker can mount<font color="#E5E5E5"> a code</font>

52
00:02:06,450 --> 00:02:10,860
injection attack by first injecting some

53
00:02:09,090 --> 00:02:13,650
malicious code into the address space<font color="#E5E5E5"> of</font>

54
00:02:10,860 --> 00:02:17,159
<font color="#E5E5E5">the application represented here as node</font>

55
00:02:13,650 --> 00:02:18,989
<font color="#E5E5E5">X</font><font color="#CCCCCC"> the second step is to override and</font>

56
00:02:17,159 --> 00:02:20,810
<font color="#E5E5E5">corrupt control flow information such as</font>

57
00:02:18,989 --> 00:02:23,430
a function pointer or a return address

58
00:02:20,810 --> 00:02:26,700
so that the control flow is redirected

59
00:02:23,430 --> 00:02:28,799
to the injected code fortunately today's

60
00:02:26,700 --> 00:02:31,290
systems leverage data execution

61
00:02:28,799 --> 00:02:33,659
prevention marking memory either as

62
00:02:31,290 --> 00:02:35,819
writable or executable so that an

63
00:02:33,659 --> 00:02:38,760
attacker can<font color="#CCCCCC"> no longer run code</font>

64
00:02:35,819 --> 00:02:41,220
injection attacks directly however

65
00:02:38,760 --> 00:02:44,129
attackers quickly adapted and shifted to

66
00:02:41,220 --> 00:02:45,750
so-called<font color="#E5E5E5"> code reuse attacks where the</font>

67
00:02:44,129 --> 00:02:48,929
main difference is that we don't inject

68
00:02:45,750 --> 00:02:51,060
any code but we add new edges to the

69
00:02:48,930 --> 00:02:52,889
control flow graph so that<font color="#CCCCCC"> we trigger</font>

70
00:02:51,060 --> 00:02:56,129
malicious actions inside the control

71
00:02:52,889 --> 00:02:58,170
<font color="#E5E5E5">flow graph and it's not versi to mention</font>

72
00:02:56,129 --> 00:03:00,599
that<font color="#E5E5E5"> typically in modern exploits both</font>

73
00:02:58,170 --> 00:03:02,819
techniques are combined so that you

74
00:03:00,599 --> 00:03:04,798
first run a code reuse attack and then

75
00:03:02,819 --> 00:03:07,170
in the second stage you run a code

76
00:03:04,799 --> 00:03:12,629
injection attack<font color="#E5E5E5"> after you disable date</font>

77
00:03:07,170 --> 00:03:14,700
data execution prevention one<font color="#E5E5E5"> of the</font>

78
00:03:12,629 --> 00:03:17,010
most famous instantiation of code reuse

79
00:03:14,700 --> 00:03:18,690
attacks is return oriented programming

80
00:03:17,010 --> 00:03:21,179
which have been introduced which has

81
00:03:18,690 --> 00:03:23,760
been introduced in 2007 bio<font color="#E5E5E5"> of shock on</font>

82
00:03:21,180 --> 00:03:26,430
<font color="#E5E5E5">where the idea is to combine short</font>

83
00:03:23,760 --> 00:03:28,560
sequences of instructions to a new

84
00:03:26,430 --> 00:03:31,709
malicious program and the underlying

85
00:03:28,560 --> 00:03:34,859
attacker model is as follows<font color="#E5E5E5"> we have a</font>

86
00:03:31,709 --> 00:03:36,720
code and a data area and assume an

87
00:03:34,859 --> 00:03:39,209
application<font color="#CCCCCC"> that links to a number of</font>

88
00:03:36,720 --> 00:03:41,549
shared libraries the first<font color="#E5E5E5"> requirement</font>

89
00:03:39,209 --> 00:03:44,599
is that the<font color="#E5E5E5"> application suffers from a</font>

90
00:03:41,549 --> 00:03:47,310
program box that we can exploit second

91
00:03:44,599 --> 00:03:49,649
the adversary needs to know the memory

92
00:03:47,310 --> 00:03:52,650
layout this is in particular<font color="#CCCCCC"> important</font>

93
00:03:49,650 --> 00:03:55,590
because a code reuse attack requires to

94
00:03:52,650 --> 00:03:57,419
reuse code in memory and we know we have

95
00:03:55,590 --> 00:04:00,870
<font color="#CCCCCC">to know exactly where this code is</font>

96
00:03:57,419 --> 00:04:03,239
located in memory typically the attacker

97
00:04:00,870 --> 00:04:04,709
also needs access for conventional

98
00:04:03,239 --> 00:04:07,979
<font color="#CCCCCC">returning to programming attacks he</font>

99
00:04:04,709 --> 00:04:12,239
needs access<font color="#CCCCCC"> to shared libraries and the</font>

100
00:04:07,979 --> 00:04:14,370
<font color="#CCCCCC">application binaries this is required</font><font color="#E5E5E5"> to</font>

101
00:04:12,239 --> 00:04:16,470
generate the<font color="#E5E5E5"> so-called gadget set where</font>

102
00:04:14,370 --> 00:04:19,108
a gadget is simply a number of sequence

103
00:04:16,470 --> 00:04:21,989
that satisfy a particular attack code

104
00:04:19,108 --> 00:04:24,690
such as loading a word from memory or

105
00:04:21,988 --> 00:04:27,520
storing to memory and typically this

106
00:04:24,690 --> 00:04:29,410
this gadget set can be at or incomplete

107
00:04:27,520 --> 00:04:32,859
<font color="#CCCCCC">gadget</font><font color="#E5E5E5"> so that the attacker can emulate</font>

108
00:04:29,410 --> 00:04:36,069
any malicious behavior he desires the

109
00:04:32,860 --> 00:04:38,500
final<font color="#E5E5E5"> step of this attack is to get a</font>

110
00:04:36,069 --> 00:04:41,050
combination of these gadgets to satisfy

111
00:04:38,500 --> 00:04:43,990
the attack hole and inject that

112
00:04:41,050 --> 00:04:45,879
<font color="#E5E5E5">combination of gadgets as a rock payload</font>

113
00:04:43,990 --> 00:04:48,099
into the data area of the application

114
00:04:45,879 --> 00:04:50,860
and that they<font color="#CCCCCC"> not</font><font color="#E5E5E5"> only</font><font color="#CCCCCC"> consist of</font>

115
00:04:48,099 --> 00:04:52,270
pointers that reference the gadgets in

116
00:04:50,860 --> 00:04:57,099
the shared libraries but also the

117
00:04:52,270 --> 00:04:58,659
application<font color="#CCCCCC"> itself torsten already</font>

118
00:04:57,099 --> 00:05:01,659
showed you<font color="#E5E5E5"> this slide there has</font><font color="#CCCCCC"> been a</font>

119
00:04:58,659 --> 00:05:05,770
lot of research in this area for<font color="#CCCCCC"> the</font>

120
00:05:01,659 --> 00:05:07,750
<font color="#E5E5E5">last decade</font><font color="#CCCCCC"> it all started in 1997 where</font>

121
00:05:05,770 --> 00:05:10,508
the first code reuse attack has been

122
00:05:07,750 --> 00:05:13,300
<font color="#CCCCCC">published by solar designer where the</font>

123
00:05:10,509 --> 00:05:15,370
attack called return into lipsy allowed

124
00:05:13,300 --> 00:05:17,979
the attacker to redirect the execution

125
00:05:15,370 --> 00:05:20,289
to a dangerous system function in<font color="#E5E5E5"> lipsy</font>

126
00:05:17,979 --> 00:05:22,630
then they have been several advancement

127
00:05:20,289 --> 00:05:25,150
to this attack for<font color="#E5E5E5"> instance chaining</font>

128
00:05:22,630 --> 00:05:28,180
multiple functions inside a return into

129
00:05:25,150 --> 00:05:29,710
lipsy attack and then in 2007<font color="#CCCCCC"> whoville</font>

130
00:05:28,180 --> 00:05:32,139
shaham presented return on to

131
00:05:29,710 --> 00:05:35,380
programming for<font color="#CCCCCC"> Intel x86 architectures</font>

132
00:05:32,139 --> 00:05:37,719
and after 2007 they have been a<font color="#E5E5E5"> number</font>

133
00:05:35,380 --> 00:05:40,330
of works on academic conferences and

134
00:05:37,719 --> 00:05:41,919
also industry conferences showing that

135
00:05:40,330 --> 00:05:45,039
returning to programming can be applied

136
00:05:41,919 --> 00:05:49,150
to many architectures like spark atmel

137
00:05:45,039 --> 00:05:51,340
AVR or arm based systems from the end of

138
00:05:49,150 --> 00:05:54,219
2010 we have seen the first real-world

139
00:05:51,340 --> 00:05:56,440
exploit against browsers and PDF viewers

140
00:05:54,219 --> 00:05:58,659
and they have<font color="#E5E5E5"> been also a lot of work</font>

141
00:05:56,440 --> 00:06:01,389
and yeah basically they're also

142
00:05:58,659 --> 00:06:05,800
continues arms race between returning to

143
00:06:01,389 --> 00:06:07,719
programming attacks and defenses the

144
00:06:05,800 --> 00:06:10,599
main defense techniques explored in this

145
00:06:07,719 --> 00:06:13,419
<font color="#E5E5E5">area are code randomization and control</font>

146
00:06:10,599 --> 00:06:15,310
flow integrity and both of them assume

147
00:06:13,419 --> 00:06:17,889
that the attacker has some means to

148
00:06:15,310 --> 00:06:21,009
corrupt control flow information and

149
00:06:17,889 --> 00:06:24,819
they aim to stop the attacker from doing

150
00:06:21,009 --> 00:06:27,029
the militias<font color="#E5E5E5"> computation so let's start</font>

151
00:06:24,819 --> 00:06:30,219
with fine-grained coat randomization

152
00:06:27,029 --> 00:06:32,169
when a program gets loaded then the

153
00:06:30,219 --> 00:06:34,690
proper control flow graph is first

154
00:06:32,169 --> 00:06:38,469
flattened into memory so that every node

155
00:06:34,690 --> 00:06:40,599
in memory<font color="#E5E5E5"> gets its fixed position fine</font>

156
00:06:38,469 --> 00:06:41,139
when code randomization now randomizes

157
00:06:40,599 --> 00:06:43,360
the order

158
00:06:41,139 --> 00:06:45,129
of the basic blocks so that<font color="#E5E5E5"> the attacker</font>

159
00:06:43,360 --> 00:06:48,129
no longer knows where gadgets are

160
00:06:45,129 --> 00:06:50,710
located in<font color="#E5E5E5"> Marin and the main</font>

161
00:06:48,129 --> 00:06:53,080
implementation<font color="#CCCCCC"> that we know of today of</font>

162
00:06:50,710 --> 00:06:55,568
code randomization is address space

163
00:06:53,080 --> 00:06:58,270
layout randomization where the main idea

164
00:06:55,569 --> 00:07:00,669
<font color="#E5E5E5">is to always randomize the start address</font>

165
00:06:58,270 --> 00:07:04,270
of a code and data<font color="#E5E5E5"> segment for each run</font>

166
00:07:00,669 --> 00:07:06,758
of the application however this basic

167
00:07:04,270 --> 00:07:09,549
form of randomization has two

168
00:07:06,759 --> 00:07:12,310
limitations the first limitation is<font color="#CCCCCC"> that</font>

169
00:07:09,550 --> 00:07:15,189
for some systems in particular 32-bit

170
00:07:12,310 --> 00:07:17,169
systems<font color="#E5E5E5"> there the entropy is such low</font>

171
00:07:15,189 --> 00:07:19,900
that we can still run<font color="#E5E5E5"> brute-force attack</font>

172
00:07:17,169 --> 00:07:22,029
a more fundamental problem which<font color="#CCCCCC"> is</font>

173
00:07:19,900 --> 00:07:24,729
often exploited in today's exploit is

174
00:07:22,029 --> 00:07:27,879
memory disclosure here the idea<font color="#E5E5E5"> is</font><font color="#CCCCCC"> that</font>

175
00:07:24,729 --> 00:07:30,340
the attacker exploits a disclosure<font color="#CCCCCC"> Viner</font>

176
00:07:27,879 --> 00:07:32,740
empty which gives him access to<font color="#CCCCCC"> a</font>

177
00:07:30,340 --> 00:07:35,619
function<font color="#CCCCCC"> pointer and that function</font>

178
00:07:32,740 --> 00:07:38,080
pointer allows the attacker to revert

179
00:07:35,620 --> 00:07:40,659
and calculate all the gadget addresses

180
00:07:38,080 --> 00:07:43,060
inside that affected code segment the

181
00:07:40,659 --> 00:07:45,789
reason<font color="#E5E5E5"> for that</font><font color="#CCCCCC"> is because a SLR only</font>

182
00:07:43,060 --> 00:07:49,029
<font color="#CCCCCC">randomized the base</font><font color="#E5E5E5"> address but not the</font>

183
00:07:45,789 --> 00:07:51,938
internal layout of the application to

184
00:07:49,029 --> 00:07:53,800
tackle these deficiencies a number of

185
00:07:51,939 --> 00:07:55,719
fine-grained SLR proposals of

186
00:07:53,800 --> 00:07:57,969
fine-grained code randomization schemes

187
00:07:55,719 --> 00:08:00,639
<font color="#CCCCCC">have been proposed in the last two three</font>

188
00:07:57,969 --> 00:08:03,879
<font color="#E5E5E5">and four years here the simple idea is</font>

189
00:08:00,639 --> 00:08:06,399
basically not to only randomize the base

190
00:08:03,879 --> 00:08:09,580
address but also to randomize the code

191
00:08:06,399 --> 00:08:13,479
layout inside and executable or inside a

192
00:08:09,580 --> 00:08:16,628
library and depending<font color="#E5E5E5"> on the security</font>

193
00:08:13,479 --> 00:08:19,000
parameter the randomization can be

194
00:08:16,629 --> 00:08:20,800
<font color="#E5E5E5">carried out based on function</font>

195
00:08:19,000 --> 00:08:22,960
permutation or basic block<font color="#CCCCCC"> Perriman</font>

196
00:08:20,800 --> 00:08:26,830
<font color="#CCCCCC">tation or even randomizing the location</font>

197
00:08:22,960 --> 00:08:30,638
<font color="#E5E5E5">of each instruction in memory and just</font>

198
00:08:26,830 --> 00:08:33,760
recently<font color="#E5E5E5"> or this week openbsd announced</font>

199
00:08:30,639 --> 00:08:36,250
<font color="#E5E5E5">that it has now some</font><font color="#CCCCCC"> fine-grained code</font>

200
00:08:33,760 --> 00:08:38,289
randomization for its<font color="#CCCCCC"> Linux library</font>

201
00:08:36,250 --> 00:08:40,719
lipsy I haven't<font color="#E5E5E5"> checked out the details</font>

202
00:08:38,289 --> 00:08:43,689
but this is the first implementation of

203
00:08:40,719 --> 00:08:46,570
fine-grained coke randomization in

204
00:08:43,690 --> 00:08:49,600
practice however<font color="#CCCCCC"> the open question</font>

205
00:08:46,570 --> 00:08:51,730
remains if fine-grained SLR really

206
00:08:49,600 --> 00:08:54,400
provides it viable defense in the long

207
00:08:51,730 --> 00:08:56,110
run and unfortunately the bad news<font color="#CCCCCC"> is</font>

208
00:08:54,400 --> 00:08:58,600
that we were able<font color="#E5E5E5"> to construct a</font>

209
00:08:56,110 --> 00:09:01,030
<font color="#E5E5E5">so-called just in time code reuse</font><font color="#CCCCCC"> attack</font>

210
00:08:58,600 --> 00:09:02,950
or short<font color="#CCCCCC"> G</font><font color="#E5E5E5"> drop that allows</font><font color="#CCCCCC"> us to</font>

211
00:09:01,030 --> 00:09:06,370
undermine<font color="#CCCCCC"> fine-grained a seller</font>

212
00:09:02,950 --> 00:09:09,720
protection by only generating the entire

213
00:09:06,370 --> 00:09:12,640
exploit dynamically on the fly in memory

214
00:09:09,720 --> 00:09:14,620
<font color="#E5E5E5">the intuition behind this attack is as</font>

215
00:09:12,640 --> 00:09:16,900
follows consider that<font color="#E5E5E5"> we have a code</font>

216
00:09:14,620 --> 00:09:19,180
page in memory we're fine<font color="#E5E5E5"> grained</font>

217
00:09:16,900 --> 00:09:21,280
randomization randomizes the order of

218
00:09:19,180 --> 00:09:23,620
all the instructions in on that code

219
00:09:21,280 --> 00:09:26,560
page so that<font color="#E5E5E5"> the attacker has no idea</font>

220
00:09:23,620 --> 00:09:30,340
where<font color="#E5E5E5"> instructions are located on the</font>

221
00:09:26,560 --> 00:09:33,369
code page nevertheless memory disclosure

222
00:09:30,340 --> 00:09:35,440
vulnerabilities still<font color="#E5E5E5"> exist but since</font>

223
00:09:33,370 --> 00:09:37,660
fine-grained SLR<font color="#CCCCCC"> randomize the location</font>

224
00:09:35,440 --> 00:09:39,910
of each instruction the attacker only

225
00:09:37,660 --> 00:09:42,910
gets a mapping from one<font color="#CCCCCC"> random address</font>

226
00:09:39,910 --> 00:09:46,449
to one single instruction now the idea

227
00:09:42,910 --> 00:09:49,150
<font color="#E5E5E5">of G drop is that it observes that this</font>

228
00:09:46,450 --> 00:09:52,060
instruction will be located<font color="#CCCCCC"> on a memory</font>

229
00:09:49,150 --> 00:09:54,910
page that is aligned to<font color="#CCCCCC"> four kilobyte</font>

230
00:09:52,060 --> 00:09:57,310
because of modern paging mechanisms we

231
00:09:54,910 --> 00:09:59,740
can<font color="#E5E5E5"> leverage exactly this information</font>

232
00:09:57,310 --> 00:10:02,229
and leverage a scripting engine such as

233
00:09:59,740 --> 00:10:04,750
a JavaScript or visual basic script to

234
00:10:02,230 --> 00:10:07,780
deter mined the page start and end

235
00:10:04,750 --> 00:10:09,370
versus instruction is located once we

236
00:10:07,780 --> 00:10:12,010
know<font color="#CCCCCC"> the page start you can start</font>

237
00:10:09,370 --> 00:10:15,100
reading from that page and disassemble

238
00:10:12,010 --> 00:10:17,980
at runtime the<font color="#CCCCCC"> instruction</font><font color="#E5E5E5"> that are</font>

239
00:10:15,100 --> 00:10:20,980
located<font color="#CCCCCC"> on that page this effectively</font>

240
00:10:17,980 --> 00:10:23,830
<font color="#E5E5E5">gives the attacker access to</font><font color="#CCCCCC"> four</font>

241
00:10:20,980 --> 00:10:26,380
kilobyte<font color="#E5E5E5"> of code and the probability</font><font color="#CCCCCC"> is</font>

242
00:10:23,830 --> 00:10:29,080
high that one of those instructions will

243
00:10:26,380 --> 00:10:31,810
reference another code page for instance

244
00:10:29,080 --> 00:10:34,750
through<font color="#E5E5E5"> a jump or call instruction we</font>

245
00:10:31,810 --> 00:10:37,900
can really follow this follow this

246
00:10:34,750 --> 00:10:39,520
instruction and do the same procedure so

247
00:10:37,900 --> 00:10:41,970
we leverage the scripting engine to

248
00:10:39,520 --> 00:10:44,740
determine page start and end and then

249
00:10:41,970 --> 00:10:47,080
disclose the content of that<font color="#E5E5E5"> code page</font>

250
00:10:44,740 --> 00:10:49,540
with this technique we were able<font color="#CCCCCC"> to</font>

251
00:10:47,080 --> 00:10:52,420
disclose the content of approximately

252
00:10:49,540 --> 00:10:55,270
200 pages on average for internet

253
00:10:52,420 --> 00:10:57,010
explorer firefox and chrome starting

254
00:10:55,270 --> 00:11:00,370
from different entry points and

255
00:10:57,010 --> 00:11:02,290
obviously so many code page allow the

256
00:11:00,370 --> 00:11:05,500
attacker easily to run a return on to

257
00:11:02,290 --> 00:11:07,310
programming attack so what<font color="#E5E5E5"> are the</font>

258
00:11:05,500 --> 00:11:10,070
lessons learned from this

259
00:11:07,310 --> 00:11:11,239
first memory disclosure<font color="#CCCCCC"> texts are far</font>

260
00:11:10,070 --> 00:11:14,300
more damaging than was previously

261
00:11:11,240 --> 00:11:16,250
believed because<font color="#CCCCCC"> a single mapping of one</font>

262
00:11:14,300 --> 00:11:19,849
address to one instruction allowed us to

263
00:11:16,250 --> 00:11:22,130
disclose many code pages and this allows

264
00:11:19,850 --> 00:11:24,410
us to construct a<font color="#E5E5E5"> jatropha attack which</font>

265
00:11:22,130 --> 00:11:26,990
undermines<font color="#CCCCCC"> fine grain coat randomization</font>

266
00:11:24,410 --> 00:11:28,850
now in order to defend against it Rob

267
00:11:26,990 --> 00:11:32,540
there are number of there<font color="#E5E5E5"> are a number</font>

268
00:11:28,850 --> 00:11:34,970
of possibilities one possibilities to

269
00:11:32,540 --> 00:11:38,779
enforce execute only more memory for

270
00:11:34,970 --> 00:11:41,330
instance we explored the<font color="#E5E5E5"> Intel recent</font>

271
00:11:38,779 --> 00:11:43,250
features of<font color="#E5E5E5"> apt extended page tables</font>

272
00:11:41,330 --> 00:11:46,670
which conveniently allow us to set

273
00:11:43,250 --> 00:11:48,740
memory pages as only<font color="#E5E5E5"> executable so that</font>

274
00:11:46,670 --> 00:11:51,709
an attacker<font color="#CCCCCC"> can no longer read from that</font>

275
00:11:48,740 --> 00:11:53,839
page and disassemble it however to

276
00:11:51,710 --> 00:11:56,300
enforce this game you clearly need<font color="#CCCCCC"> to</font>

277
00:11:53,839 --> 00:11:58,460
separate data from code another

278
00:11:56,300 --> 00:12:00,439
<font color="#E5E5E5">alternative is to combine quote</font>

279
00:11:58,460 --> 00:12:03,770
randomization with execution paths

280
00:12:00,440 --> 00:12:06,440
randomization and as towards the<font color="#CCCCCC"> mention</font>

281
00:12:03,770 --> 00:12:08,180
<font color="#E5E5E5">in his keynote they are also first</font>

282
00:12:06,440 --> 00:12:10,400
<font color="#E5E5E5">schemes that aim at automatically</font>

283
00:12:08,180 --> 00:12:14,000
mitigating memory disclosure attacks in

284
00:12:10,400 --> 00:12:15,680
the first place now let's turn our

285
00:12:14,000 --> 00:12:18,140
<font color="#CCCCCC">attention to the</font><font color="#E5E5E5"> second direction</font>

286
00:12:15,680 --> 00:12:21,020
control flow integrity which in contrast

287
00:12:18,140 --> 00:12:23,600
to code randomization and forces

288
00:12:21,020 --> 00:12:26,390
explicit control flow checks and the

289
00:12:23,600 --> 00:12:29,330
main idea<font color="#E5E5E5"> is to assign unique labels to</font>

290
00:12:26,390 --> 00:12:31,970
each node in the graph the second<font color="#E5E5E5"> step</font>

291
00:12:29,330 --> 00:12:35,030
is to instrument those nodes and embed a

292
00:12:31,970 --> 00:12:37,839
control flow integrity<font color="#E5E5E5"> check for</font>

293
00:12:35,030 --> 00:12:40,640
instance<font color="#E5E5E5"> the check for node B would</font>

294
00:12:37,839 --> 00:12:43,580
simply validate if the exit instruction

295
00:12:40,640 --> 00:12:46,280
of<font color="#CCCCCC"> D targets label</font><font color="#E5E5E5"> 6 where label six is</font>

296
00:12:43,580 --> 00:12:48,170
<font color="#CCCCCC">the beginning of the</font><font color="#E5E5E5"> note F and only if</font>

297
00:12:46,280 --> 00:12:52,040
this is the case we allow the program to

298
00:12:48,170 --> 00:12:54,349
continue executing however when<font color="#CCCCCC"> we apply</font>

299
00:12:52,040 --> 00:12:55,550
this basic sea of ice creams then there

300
00:12:54,350 --> 00:12:58,550
will<font color="#CCCCCC"> be a significant performance</font>

301
00:12:55,550 --> 00:13:00,949
overhead because<font color="#CCCCCC"> of the many</font><font color="#E5E5E5"> cfi checks</font>

302
00:12:58,550 --> 00:13:03,829
involved in particular if we consider

303
00:13:00,950 --> 00:13:07,010
node B then node B can potentially

304
00:13:03,830 --> 00:13:09,320
target three other nodes and we would

305
00:13:07,010 --> 00:13:11,360
need<font color="#E5E5E5"> to check against three different</font>

306
00:13:09,320 --> 00:13:14,180
labels which is of<font color="#CCCCCC"> course a performance</font>

307
00:13:11,360 --> 00:13:17,120
heavy so one of the first optimization

308
00:13:14,180 --> 00:13:20,359
that Microsoft<font color="#E5E5E5"> Research proposed is to</font>

309
00:13:17,120 --> 00:13:22,760
merge the labels of those nodes that are

310
00:13:20,360 --> 00:13:25,430
targeted by<font color="#CCCCCC"> the same original in our</font>

311
00:13:22,760 --> 00:13:27,770
<font color="#E5E5E5">example no D and E would be assigned the</font>

312
00:13:25,430 --> 00:13:30,500
same label<font color="#CCCCCC"> 3 and then we would only need</font>

313
00:13:27,770 --> 00:13:34,370
to check if the exit instruction targets

314
00:13:30,500 --> 00:13:36,770
label<font color="#E5E5E5"> 3 however this results in some</font>

315
00:13:34,370 --> 00:13:39,050
imprecision in the CFG now looking at

316
00:13:36,770 --> 00:13:43,400
not<font color="#E5E5E5"> see the control flow check would</font>

317
00:13:39,050 --> 00:13:47,000
effectively look as in node<font color="#E5E5E5"> B and would</font>

318
00:13:43,400 --> 00:13:49,189
allow the an attacker<font color="#E5E5E5"> to also target</font>

319
00:13:47,000 --> 00:13:51,500
from not see the beginning of no<font color="#E5E5E5"> D</font>

320
00:13:49,190 --> 00:13:54,260
because it assigns in the same labor<font color="#E5E5E5"> 3</font>

321
00:13:51,500 --> 00:13:56,180
which<font color="#CCCCCC"> is checked here and note C can</font>

322
00:13:54,260 --> 00:13:58,760
even target itself because<font color="#CCCCCC"> it has been</font>

323
00:13:56,180 --> 00:14:00,800
assigned<font color="#E5E5E5"> labor 3 however the common</font>

324
00:13:58,760 --> 00:14:03,530
belief is that you can live with<font color="#E5E5E5"> this</font>

325
00:14:00,800 --> 00:14:06,439
imposition a more fundamental problem

326
00:14:03,530 --> 00:14:10,220
concerning the label enforcement

327
00:14:06,440 --> 00:14:11,810
concerns function returns consider<font color="#CCCCCC"> for</font>

328
00:14:10,220 --> 00:14:14,300
this an<font color="#E5E5E5"> example where we</font><font color="#CCCCCC"> have two nodes</font>

329
00:14:11,810 --> 00:14:17,959
a and B that both have a function call

330
00:14:14,300 --> 00:14:20,120
to note C and the code layout would look

331
00:14:17,959 --> 00:14:22,699
kind of like this we have function a and

332
00:14:20,120 --> 00:14:26,209
<font color="#E5E5E5">B and both of them have a call to note</font>

333
00:14:22,700 --> 00:14:28,579
see and not see our function<font color="#E5E5E5"> C will then</font>

334
00:14:26,209 --> 00:14:30,650
return to either function B and a

335
00:14:28,579 --> 00:14:34,250
depending on<font color="#CCCCCC"> the color of the function</font>

336
00:14:30,650 --> 00:14:36,920
and in this example for our graph we

337
00:14:34,250 --> 00:14:40,450
assume that<font color="#E5E5E5"> the code in function a is</font>

338
00:14:36,920 --> 00:14:44,479
marked<font color="#E5E5E5"> as a dash and function BSB dash</font>

339
00:14:40,450 --> 00:14:48,170
so the<font color="#CCCCCC"> cfi check if we would enforce</font>

340
00:14:44,480 --> 00:14:50,870
<font color="#CCCCCC">fine-grained cfi we would assign unique</font>

341
00:14:48,170 --> 00:14:53,449
labels to a dash and<font color="#CCCCCC"> b dash and then</font>

342
00:14:50,870 --> 00:14:56,120
validate and return whether label 1 or

343
00:14:53,450 --> 00:14:58,070
<font color="#E5E5E5">labor to our targeted however this still</font>

344
00:14:56,120 --> 00:15:01,670
results in an imposition because now the

345
00:14:58,070 --> 00:15:04,490
attacker is able to incur a flow from<font color="#E5E5E5"> A</font>

346
00:15:01,670 --> 00:15:07,069
to<font color="#E5E5E5"> C and then seek is allowed to</font><font color="#CCCCCC"> go to</font>

347
00:15:04,490 --> 00:15:10,160
be dash although a dash has been the

348
00:15:07,070 --> 00:15:12,680
original color to tackle this

349
00:15:10,160 --> 00:15:15,890
shortcoming one of the ideas is to

350
00:15:12,680 --> 00:15:18,890
maintain a shadow stack the shadows deck

351
00:15:15,890 --> 00:15:20,959
allows whenever there is a function call

352
00:15:18,890 --> 00:15:23,240
to<font color="#E5E5E5"> back up the return address of that</font>

353
00:15:20,959 --> 00:15:26,510
function and when there is a function

354
00:15:23,240 --> 00:15:28,190
return we validate if the program uses a

355
00:15:26,510 --> 00:15:30,160
return address that<font color="#E5E5E5"> we have been</font>

356
00:15:28,190 --> 00:15:34,569
previously<font color="#E5E5E5"> stored on the shadows</font>

357
00:15:30,160 --> 00:15:36,490
tag so in our example if a called<font color="#CCCCCC"> C then</font>

358
00:15:34,569 --> 00:15:39,550
we<font color="#E5E5E5"> first back</font><font color="#CCCCCC"> up the return address a</font>

359
00:15:36,490 --> 00:15:41,410
dash on the shadow stack and the control

360
00:15:39,550 --> 00:15:43,870
flow check would simply validate if the

361
00:15:41,410 --> 00:15:46,990
exit of C targets the top of the shadow

362
00:15:43,870 --> 00:15:50,019
stack which is in our case a dash so<font color="#CCCCCC"> we</font>

363
00:15:46,990 --> 00:15:53,100
would prevent a flow from A to C and

364
00:15:50,019 --> 00:15:55,839
from C to B dash so in summary

365
00:15:53,100 --> 00:15:58,990
<font color="#E5E5E5">fine-grained or c of i provides</font>

366
00:15:55,839 --> 00:16:00,939
fine-grained protection but suffers from

367
00:15:58,990 --> 00:16:03,310
performance<font color="#E5E5E5"> overhead in particular when</font>

368
00:16:00,939 --> 00:16:05,980
considering the extra<font color="#CCCCCC"> costs of</font>

369
00:16:03,310 --> 00:16:08,888
maintaining a shadow stack research has

370
00:16:05,980 --> 00:16:10,839
also complained about the fact that the

371
00:16:08,889 --> 00:16:13,240
original microsoft c of i approach

372
00:16:10,839 --> 00:16:15,160
requires site information such as debug

373
00:16:13,240 --> 00:16:17,709
symbols which are<font color="#E5E5E5"> often not available in</font>

374
00:16:15,160 --> 00:16:19,719
practice moreover they use an

375
00:16:17,709 --> 00:16:22,209
instrumentation framework which is not

376
00:16:19,720 --> 00:16:24,939
accessible except for microsoft itself

377
00:16:22,209 --> 00:16:27,279
so it serves as a kind of black box and

378
00:16:24,939 --> 00:16:30,310
we<font color="#E5E5E5"> don't really know how precisely it</font>

379
00:16:27,279 --> 00:16:32,230
generates the control flow graph in

380
00:16:30,310 --> 00:16:34,899
order to tackle these shortcomings a

381
00:16:32,230 --> 00:16:37,000
<font color="#E5E5E5">number</font><font color="#CCCCCC"> of new cfi schemes have been</font>

382
00:16:34,899 --> 00:16:40,269
proposed in the last two and three years

383
00:16:37,000 --> 00:16:42,160
and all these tools are doing a kind<font color="#E5E5E5"> of</font>

384
00:16:40,269 --> 00:16:44,860
trade-off between security and

385
00:16:42,160 --> 00:16:46,660
performance and some of these<font color="#E5E5E5"> tools have</font>

386
00:16:44,860 --> 00:16:48,819
been even awarded with the<font color="#E5E5E5"> microsoft</font>

387
00:16:46,660 --> 00:16:52,029
blue head price<font color="#CCCCCC"> i think we already</font>

388
00:16:48,819 --> 00:16:54,189
mentioned that a<font color="#E5E5E5"> microsoft has awarded</font>

389
00:16:52,029 --> 00:16:56,980
defenses against return or intrapreneur

390
00:16:54,189 --> 00:16:59,319
programming with<font color="#E5E5E5"> 260,000 dollars and</font>

391
00:16:56,980 --> 00:17:02,319
some of those ideas have been integrated

392
00:16:59,319 --> 00:17:04,480
into the tool microsoft<font color="#CCCCCC"> email which is a</font>

393
00:17:02,319 --> 00:17:06,849
free and public tool that one can

394
00:17:04,480 --> 00:17:09,549
download to<font color="#E5E5E5"> harden his browser or PDF</font>

395
00:17:06,849 --> 00:17:11,559
viewer<font color="#CCCCCC"> i think this is a great</font><font color="#E5E5E5"> step by</font>

396
00:17:09,549 --> 00:17:13,510
<font color="#E5E5E5">microsoft pushing this forward however</font>

397
00:17:11,559 --> 00:17:16,329
as we will see there are still some open

398
00:17:13,510 --> 00:17:18,099
problems and attacks that an attacker

399
00:17:16,329 --> 00:17:21,730
can potentially mount against these

400
00:17:18,099 --> 00:17:24,250
schemes in<font color="#CCCCCC"> particular the open question</font>

401
00:17:21,730 --> 00:17:26,409
remains if the trade-off between

402
00:17:24,250 --> 00:17:28,449
security and performance still results

403
00:17:26,409 --> 00:17:32,830
in a practical and<font color="#CCCCCC"> sakura mitigation of</font>

404
00:17:28,449 --> 00:17:35,140
code reuse attacks and the<font color="#E5E5E5"> second</font>

405
00:17:32,830 --> 00:17:36,970
requirement<font color="#E5E5E5"> if they really eliminate the</font>

406
00:17:35,140 --> 00:17:40,330
Turing completeness of<font color="#CCCCCC"> the attack as</font>

407
00:17:36,970 --> 00:17:42,309
these schemes proposed and<font color="#CCCCCC"> claim in</font>

408
00:17:40,330 --> 00:17:43,928
order to answer that question<font color="#CCCCCC"> we</font>

409
00:17:42,309 --> 00:17:45,809
performed a systematic

410
00:17:43,929 --> 00:17:48,580
purity analysis of all these schemes

411
00:17:45,809 --> 00:17:51,249
generated a combined policy and then

412
00:17:48,580 --> 00:17:52,809
validated based on a single library of a

413
00:17:51,249 --> 00:17:55,749
common<font color="#CCCCCC"> Windows libraries the</font>

414
00:17:52,809 --> 00:17:59,460
kernel32.dll whether we can find and

415
00:17:55,749 --> 00:18:02,429
construct a turing-complete gadget set

416
00:17:59,460 --> 00:18:04,629
the main policies deployed by these

417
00:18:02,429 --> 00:18:07,629
coarse-grained or practicality of I

418
00:18:04,629 --> 00:18:10,029
schemes are as follows first<font color="#E5E5E5"> they want</font>

419
00:18:07,629 --> 00:18:12,730
to avoid the costly shadow stack and

420
00:18:10,029 --> 00:18:15,490
thereby only enforce that a return can

421
00:18:12,730 --> 00:18:17,320
target any call<font color="#E5E5E5"> proceeded instruction so</font>

422
00:18:15,490 --> 00:18:19,450
if you have an application<font color="#CCCCCC"> with</font><font color="#E5E5E5"> recall</font>

423
00:18:17,320 --> 00:18:21,549
instructions then the return is allowed

424
00:18:19,450 --> 00:18:23,919
to target all those<font color="#E5E5E5"> instructions that</font>

425
00:18:21,549 --> 00:18:26,350
follow the calls and any other

426
00:18:23,919 --> 00:18:29,470
instruction would immediately result in

427
00:18:26,350 --> 00:18:32,049
an attack alarm obviously this is a kind

428
00:18:29,470 --> 00:18:33,669
of coarse-grained check and some of the

429
00:18:32,049 --> 00:18:35,860
schemes aim to compensate the

430
00:18:33,669 --> 00:18:38,470
coarse-grained ness by also deploying

431
00:18:35,860 --> 00:18:40,269
behavioral-based heuristics here the

432
00:18:38,470 --> 00:18:43,059
observation is that return on to

433
00:18:40,269 --> 00:18:45,490
programming typically execute very short

434
00:18:43,059 --> 00:18:47,950
sequences in a row which is not very

435
00:18:45,490 --> 00:18:50,740
typical for ordinary program execution

436
00:18:47,950 --> 00:18:54,610
so these tools define some thresholds

437
00:18:50,740 --> 00:18:57,820
and whenever they observe very short

438
00:18:54,610 --> 00:18:59,949
sequence of instructions and they have

439
00:18:57,820 --> 00:19:02,230
<font color="#E5E5E5">been repeated n times then the next</font>

440
00:18:59,950 --> 00:19:04,330
sequence must be a long sequence meaning

441
00:19:02,230 --> 00:19:06,879
more than des instructions and only and

442
00:19:04,330 --> 00:19:10,590
if this is<font color="#E5E5E5"> not if this is not the case</font>

443
00:19:06,879 --> 00:19:12,908
then the these tools report an attack

444
00:19:10,590 --> 00:19:15,009
different tools define different

445
00:19:12,909 --> 00:19:16,659
thresholds for instance k bounds or

446
00:19:15,009 --> 00:19:19,179
reports<font color="#CCCCCC"> an attack whenever they have</font>

447
00:19:16,659 --> 00:19:21,249
been more<font color="#E5E5E5"> than seven short instruction</font>

448
00:19:19,179 --> 00:19:23,499
sequences where short means in this

449
00:19:21,249 --> 00:19:26,499
example at less than<font color="#E5E5E5"> 20 instructions or</font>

450
00:19:23,499 --> 00:19:30,279
less than 20 non indirect branch

451
00:19:26,499 --> 00:19:32,110
instructions this slide gives an

452
00:19:30,279 --> 00:19:34,809
overview of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> tools that we</font><font color="#CCCCCC"> have been</font>

453
00:19:32,110 --> 00:19:37,658
analyzing and particularly<font color="#CCCCCC"> analyzed k</font>

454
00:19:34,809 --> 00:19:39,428
bouncer<font color="#CCCCCC"> Rob pecker</font><font color="#E5E5E5"> Rob guard and see</font><font color="#CCCCCC"> of</font>

455
00:19:37,659 --> 00:19:42,220
I for commercial off-the-shelf wineries

456
00:19:39,429 --> 00:19:44,259
and we tested them against these two

457
00:19:42,220 --> 00:19:46,690
policies<font color="#CCCCCC"> called proceeded sequences and</font>

458
00:19:44,259 --> 00:19:49,570
behavioral based or if six we also

459
00:19:46,690 --> 00:19:51,940
included the time of<font color="#CCCCCC"> cfi check because</font>

460
00:19:49,570 --> 00:19:54,850
as you can<font color="#E5E5E5"> see</font><font color="#CCCCCC"> some of the tools</font><font color="#E5E5E5"> apply</font>

461
00:19:51,940 --> 00:19:57,159
<font color="#CCCCCC">cfi policy one and two but they only</font>

462
00:19:54,850 --> 00:19:57,580
perform a sea of I validation when a

463
00:19:57,159 --> 00:20:00,220
crit

464
00:19:57,580 --> 00:20:02,110
kill Windows API function is called this

465
00:20:00,220 --> 00:20:04,540
<font color="#E5E5E5">is critical because an attacker could</font>

466
00:20:02,110 --> 00:20:08,050
potentially eliminate his traces before

467
00:20:04,540 --> 00:20:10,300
calling that critical function we then

468
00:20:08,050 --> 00:20:12,520
generated a combined policy that take

469
00:20:10,300 --> 00:20:15,250
the most<font color="#CCCCCC"> restrictive setting of all</font>

470
00:20:12,520 --> 00:20:17,740
these schemes in<font color="#CCCCCC"> particular we assume</font>

471
00:20:15,250 --> 00:20:20,050
that<font color="#CCCCCC"> GFI policy</font><font color="#E5E5E5"> one and two are checked</font>

472
00:20:17,740 --> 00:20:23,800
and that the sea of I validation is

473
00:20:20,050 --> 00:20:26,470
performed for any indirect branch then

474
00:20:23,800 --> 00:20:28,600
we inspected a common<font color="#CCCCCC"> Windows library</font>

475
00:20:26,470 --> 00:20:31,060
which is<font color="#E5E5E5"> only one megabyte in size so</font>

476
00:20:28,600 --> 00:20:32,709
note<font color="#CCCCCC"> that typically</font><font color="#E5E5E5"> Windows application</font>

477
00:20:31,060 --> 00:20:35,770
<font color="#CCCCCC">business application link to dozens of</font>

478
00:20:32,710 --> 00:20:37,930
libraries but we<font color="#E5E5E5"> wanted to restrict</font>

479
00:20:35,770 --> 00:20:39,820
ourselves to see what we can do based on

480
00:20:37,930 --> 00:20:42,130
<font color="#E5E5E5">a single library and in fact we were</font>

481
00:20:39,820 --> 00:20:44,020
able to<font color="#E5E5E5"> generate a turing-complete that</font>

482
00:20:42,130 --> 00:20:46,930
gadget set so<font color="#E5E5E5"> we have gadgets for</font>

483
00:20:44,020 --> 00:20:49,150
loading registers loading and storing to

484
00:20:46,930 --> 00:20:50,620
memory arithmetic logical<font color="#E5E5E5"> gadgets and</font>

485
00:20:49,150 --> 00:20:52,750
also conditional branch and

486
00:20:50,620 --> 00:20:54,879
unconditional branch gadgets of course

487
00:20:52,750 --> 00:20:57,580
all<font color="#E5E5E5"> the details on these gadgets are in</font>

488
00:20:54,880 --> 00:21:00,220
the paper<font color="#E5E5E5"> but what you</font><font color="#CCCCCC"> may observe here</font>

489
00:20:57,580 --> 00:21:02,530
is that all these gadgets are very short

490
00:21:00,220 --> 00:21:04,840
in the length so<font color="#CCCCCC"> that at some point they</font>

491
00:21:02,530 --> 00:21:08,560
will raise<font color="#CCCCCC"> an alarm for behavior based</font>

492
00:21:04,840 --> 00:21:11,230
heuristics so how can we<font color="#E5E5E5"> bypass also</font>

493
00:21:08,560 --> 00:21:13,270
these behavioral based heuristics again

494
00:21:11,230 --> 00:21:17,020
we have our example with node Z

495
00:21:13,270 --> 00:21:19,120
targeting a dash and B<font color="#E5E5E5"> dash and given</font>

496
00:21:17,020 --> 00:21:22,120
now the coarse-grained cfi policy one

497
00:21:19,120 --> 00:21:24,489
the attacker is able to redirect the

498
00:21:22,120 --> 00:21:27,040
execution to any of those<font color="#CCCCCC"> call</font><font color="#E5E5E5"> proceeded</font>

499
00:21:24,490 --> 00:21:29,350
sequences the branch monitor for

500
00:21:27,040 --> 00:21:32,200
instance implemented as a monitor to<font color="#E5E5E5"> the</font>

501
00:21:29,350 --> 00:21:35,139
last branch record can observe that we

502
00:21:32,200 --> 00:21:38,650
execute a very a chain of very short

503
00:21:35,140 --> 00:21:41,890
sequences and stop the attack now we

504
00:21:38,650 --> 00:21:44,970
constructed and found several so-called

505
00:21:41,890 --> 00:21:47,800
long nap<font color="#CCCCCC"> gadgets these are gadgets that</font>

506
00:21:44,970 --> 00:21:49,960
execute many instructions and perform

507
00:21:47,800 --> 00:21:51,820
many controlled memory writes so they

508
00:21:49,960 --> 00:21:54,160
are writing static values to a

509
00:21:51,820 --> 00:21:57,129
designated area there are not occupied

510
00:21:54,160 --> 00:21:59,350
<font color="#E5E5E5">or used currently by the return on to</font>

511
00:21:57,130 --> 00:22:02,200
programming attack so we can<font color="#E5E5E5"> take this</font>

512
00:21:59,350 --> 00:22:04,959
<font color="#E5E5E5">long</font><font color="#CCCCCC"> nom gadget and encapsulated in</font>

513
00:22:02,200 --> 00:22:06,850
between our gadget chain so<font color="#CCCCCC"> that the</font>

514
00:22:04,960 --> 00:22:09,280
branch monitor will see a<font color="#E5E5E5"> very long</font>

515
00:22:06,850 --> 00:22:10,800
sequence which does not introduce any

516
00:22:09,280 --> 00:22:14,550
side effects to our other

517
00:22:10,800 --> 00:22:17,760
edges and the allow us to undermine the

518
00:22:14,550 --> 00:22:20,700
protection of coarse-grained<font color="#E5E5E5"> cfi so the</font>

519
00:22:17,760 --> 00:22:23,100
last step of our analysis was to take

520
00:22:20,700 --> 00:22:24,620
existing exploit hunted programming

521
00:22:23,100 --> 00:22:27,629
exploits<font color="#CCCCCC"> that have been previously</font>

522
00:22:24,620 --> 00:22:30,030
detected by<font color="#E5E5E5"> Microsoft</font><font color="#CCCCCC"> image and</font><font color="#E5E5E5"> also the</font>

523
00:22:27,630 --> 00:22:33,240
other schemes<font color="#CCCCCC"> transforms them based on</font>

524
00:22:30,030 --> 00:22:36,870
our gadget set and demonstrate that we

525
00:22:33,240 --> 00:22:39,690
can now undermine the protection so what

526
00:22:36,870 --> 00:22:41,879
are<font color="#E5E5E5"> the lessons learned first there are</font>

527
00:22:39,690 --> 00:22:44,040
still too many call sites available so

528
00:22:41,880 --> 00:22:46,260
an attacker can<font color="#E5E5E5"> target many call</font>

529
00:22:44,040 --> 00:22:48,090
proceeded instructions and as we<font color="#E5E5E5"> have</font>

530
00:22:46,260 --> 00:22:50,790
shown<font color="#E5E5E5"> this can lead to</font><font color="#CCCCCC"> a turing-complete</font>

531
00:22:48,090 --> 00:22:52,620
gadget set so maybe it's better to fall

532
00:22:50,790 --> 00:22:54,870
back to<font color="#E5E5E5"> the original idea of shadows</font>

533
00:22:52,620 --> 00:22:58,229
deck and fix the performance problems

534
00:22:54,870 --> 00:23:01,290
their second heuristics are typically a

535
00:22:58,230 --> 00:23:03,540
talk and even adjusting the thresholds

536
00:23:01,290 --> 00:23:06,420
for the sequence length will not provide

537
00:23:03,540 --> 00:23:08,700
better security because then we<font color="#CCCCCC"> have a</font>

538
00:23:06,420 --> 00:23:11,220
large number of high false positives as

539
00:23:08,700 --> 00:23:14,070
this would<font color="#E5E5E5"> then resemble the same as</font>

540
00:23:11,220 --> 00:23:16,080
ordinary program execution finally there

541
00:23:14,070 --> 00:23:18,659
<font color="#E5E5E5">are also many targets for indirect jumps</font>

542
00:23:16,080 --> 00:23:20,340
and calls so maybe one compromise<font color="#E5E5E5"> one</font>

543
00:23:18,660 --> 00:23:23,370
can make here is to leverage compiler

544
00:23:20,340 --> 00:23:26,129
support to get more precise analysis on

545
00:23:23,370 --> 00:23:28,379
the indirect<font color="#E5E5E5"> cost particular for the</font>

546
00:23:26,130 --> 00:23:33,740
class hierarchy and class hierarchy in

547
00:23:28,380 --> 00:23:36,720
C++ programs given the potential of

548
00:23:33,740 --> 00:23:39,390
control flow integrity that<font color="#E5E5E5"> it provides</font>

549
00:23:36,720 --> 00:23:41,010
very fine-grained checks but suffers

550
00:23:39,390 --> 00:23:42,810
from performance problem one of the

551
00:23:41,010 --> 00:23:45,030
recent direction in this area is

552
00:23:42,810 --> 00:23:47,280
hardware support for control flow

553
00:23:45,030 --> 00:23:50,399
integrity for instance<font color="#E5E5E5"> also followed by</font>

554
00:23:47,280 --> 00:23:53,580
the NSA and in a recent project with

555
00:23:50,400 --> 00:23:56,130
<font color="#CCCCCC">inter labs we also developed a hardware</font>

556
00:23:53,580 --> 00:23:58,590
supported architecture that allows<font color="#E5E5E5"> us to</font>

557
00:23:56,130 --> 00:24:00,210
perform<font color="#E5E5E5"> control flow integrity by</font>

558
00:23:58,590 --> 00:24:04,740
extending<font color="#CCCCCC"> the instruction set</font>

559
00:24:00,210 --> 00:24:06,780
architecture the big picture of this hey

560
00:24:04,740 --> 00:24:08,700
fix solution hey fix<font color="#E5E5E5"> stands for her</font>

561
00:24:06,780 --> 00:24:12,480
hardware-assisted flow integrity

562
00:24:08,700 --> 00:24:14,550
<font color="#E5E5E5">intention is that we separate the</font>

563
00:24:12,480 --> 00:24:16,500
processor in two states where we have

564
00:24:14,550 --> 00:24:19,649
state 0 that is the normal execution

565
00:24:16,500 --> 00:24:22,470
state and then we have a separate<font color="#CCCCCC"> cfi</font>

566
00:24:19,650 --> 00:24:24,320
state that is<font color="#CCCCCC"> always triggered when we</font>

567
00:24:22,470 --> 00:24:26,570
have a sea of I<font color="#E5E5E5"> related event</font>

568
00:24:24,320 --> 00:24:28,879
such as a function call indirect jump or

569
00:24:26,570 --> 00:24:31,519
function return and for each of those

570
00:24:28,880 --> 00:24:34,909
<font color="#E5E5E5">events we have separate cfi instructions</font>

571
00:24:31,519 --> 00:24:37,340
that perform the<font color="#CCCCCC"> cfi validation and when</font>

572
00:24:34,909 --> 00:24:40,070
the<font color="#CCCCCC"> see of I validation is successful we</font>

573
00:24:37,340 --> 00:24:43,340
return back to state 0 otherwise be

574
00:24:40,070 --> 00:24:46,000
report an attack to give<font color="#E5E5E5"> you an example</font>

575
00:24:43,340 --> 00:24:48,889
how the sea of I instructions work

576
00:24:46,000 --> 00:24:51,169
consider the following example where we

577
00:24:48,889 --> 00:24:53,928
have simply two functions and we want to

578
00:24:51,169 --> 00:24:56,179
protect<font color="#E5E5E5"> an indirect function call and a</font>

579
00:24:53,929 --> 00:24:57,950
function return<font color="#CCCCCC"> when our example the</font>

580
00:24:56,179 --> 00:25:01,700
indirect call should only target

581
00:24:57,950 --> 00:25:04,070
function B now the first thing<font color="#E5E5E5"> that we</font>

582
00:25:01,700 --> 00:25:07,549
<font color="#E5E5E5">have introduced is to chain a compiler</font>

583
00:25:04,070 --> 00:25:10,250
that extends the program this cfi

584
00:25:07,549 --> 00:25:12,769
instructions here represented as a sea

585
00:25:10,250 --> 00:25:16,519
of I events such as CF I call entry

586
00:25:12,769 --> 00:25:20,779
function entry and function exit so when

587
00:25:16,519 --> 00:25:22,730
the and we also assign labels since we

588
00:25:20,779 --> 00:25:26,960
only want to check an indirect call here

589
00:25:22,730 --> 00:25:29,269
and the return we assign label a<font color="#E5E5E5"> one to</font>

590
00:25:26,960 --> 00:25:31,909
the call side of function a and label

591
00:25:29,269 --> 00:25:35,059
<font color="#E5E5E5">before</font><font color="#CCCCCC"> the beginning</font><font color="#E5E5E5"> of function B when</font>

592
00:25:31,909 --> 00:25:37,070
the program starts executing then<font color="#E5E5E5"> before</font>

593
00:25:35,059 --> 00:25:39,860
the indirect call we<font color="#E5E5E5"> end for</font><font color="#CCCCCC"> that the</font>

594
00:25:37,070 --> 00:25:42,740
processor switches to<font color="#CCCCCC"> RSC of I state in</font>

595
00:25:39,860 --> 00:25:45,139
that sea<font color="#CCCCCC"> of ice state we first execute</font>

596
00:25:42,740 --> 00:25:47,360
the sea of I call instruction where the

597
00:25:45,139 --> 00:25:49,908
purpose of<font color="#CCCCCC"> this sea of I</font><font color="#E5E5E5"> instruction is</font>

598
00:25:47,360 --> 00:25:52,158
only to<font color="#CCCCCC"> pushing a label on a separate</font>

599
00:25:49,909 --> 00:25:55,250
label stack which is similar to a shadow

600
00:25:52,159 --> 00:25:57,740
stack however this tag is on chip so it

601
00:25:55,250 --> 00:25:58,909
can be only accessed by or<font color="#CCCCCC"> receive I</font>

602
00:25:57,740 --> 00:26:02,090
<font color="#E5E5E5">instruction and not any other</font>

603
00:25:58,909 --> 00:26:04,149
instructions in the program label a one

604
00:26:02,090 --> 00:26:07,428
gets pushed on that label stack

605
00:26:04,149 --> 00:26:10,039
indicating that we have a<font color="#E5E5E5"> function call</font>

606
00:26:07,429 --> 00:26:12,679
from function a since this<font color="#E5E5E5"> is an</font>

607
00:26:10,039 --> 00:26:14,929
indirect call we also push the label

608
00:26:12,679 --> 00:26:17,990
that the indirect call wants to call

609
00:26:14,929 --> 00:26:21,620
into a separate register that we call

610
00:26:17,990 --> 00:26:23,870
the label state register since only a

611
00:26:21,620 --> 00:26:27,139
function<font color="#E5E5E5"> B is allowed for this indirect</font>

612
00:26:23,870 --> 00:26:30,439
call we push the<font color="#CCCCCC"> cfi as a label be into</font>

613
00:26:27,139 --> 00:26:32,629
the lsr register after these two

614
00:26:30,440 --> 00:26:35,899
instructions have been executing then

615
00:26:32,629 --> 00:26:36,980
the indirect call is allowed<font color="#CCCCCC"> to jump to</font>

616
00:26:35,899 --> 00:26:39,918
the function

617
00:26:36,980 --> 00:26:41,630
and in<font color="#CCCCCC"> that function we again have a</font>

618
00:26:39,919 --> 00:26:44,150
state transition which performs the

619
00:26:41,630 --> 00:26:47,299
control flow validation in<font color="#E5E5E5"> particular</font>

620
00:26:44,150 --> 00:26:49,100
the first check and validate if the

621
00:26:47,299 --> 00:26:51,200
correct label has been<font color="#E5E5E5"> loaded in the</font>

622
00:26:49,100 --> 00:26:53,959
<font color="#E5E5E5">label state register this</font><font color="#CCCCCC"> is achieved by</font>

623
00:26:51,200 --> 00:26:56,270
a cfi check instruction that simply

624
00:26:53,960 --> 00:26:58,669
checks if the correct label it has been

625
00:26:56,270 --> 00:27:01,100
<font color="#CCCCCC">loaded before and reasons these</font>

626
00:26:58,669 --> 00:27:03,980
instructions are allocated and emitted

627
00:27:01,100 --> 00:27:08,780
by our compiler for each function entry

628
00:27:03,980 --> 00:27:11,210
in in the code segment now the function

629
00:27:08,780 --> 00:27:15,020
body is executed and when<font color="#E5E5E5"> the function</font>

630
00:27:11,210 --> 00:27:17,090
<font color="#E5E5E5">returns is its occurring then we enforce</font>

631
00:27:15,020 --> 00:27:19,040
that the return needs to target a

632
00:27:17,090 --> 00:27:21,350
<font color="#E5E5E5">so-called see if I return instruction</font>

633
00:27:19,040 --> 00:27:23,840
which is again emitted by our compiler

634
00:27:21,350 --> 00:27:26,510
that<font color="#E5E5E5"> takes a label which is currently</font>

635
00:27:23,840 --> 00:27:29,240
active or set as active in our labor

636
00:27:26,510 --> 00:27:31,429
states deck since this<font color="#E5E5E5"> is the case in</font>

637
00:27:29,240 --> 00:27:33,650
our example the program is allowed to

638
00:27:31,429 --> 00:27:36,230
<font color="#CCCCCC">continue executing but if an attacker</font>

639
00:27:33,650 --> 00:27:38,630
would have redirected<font color="#E5E5E5"> the execution to</font>

640
00:27:36,230 --> 00:27:40,669
let's say function see here below then

641
00:27:38,630 --> 00:27:43,460
another see if I return<font color="#E5E5E5"> would have been</font>

642
00:27:40,669 --> 00:27:44,960
executed<font color="#CCCCCC"> and would not match the label</font>

643
00:27:43,460 --> 00:27:51,110
that we have stored<font color="#CCCCCC"> he and the</font><font color="#E5E5E5"> labor</font>

644
00:27:44,960 --> 00:27:52,880
state stack so in<font color="#E5E5E5"> general see a high</font>

645
00:27:51,110 --> 00:27:54,918
ethics and hardware supported<font color="#CCCCCC"> c of i</font>

646
00:27:52,880 --> 00:27:57,830
provides very high efficiency not

647
00:27:54,919 --> 00:28:01,100
surprisingly up to one and<font color="#E5E5E5"> two percent</font>

648
00:27:57,830 --> 00:28:02,899
performance overhead for<font color="#E5E5E5"> aria solution</font>

649
00:28:01,100 --> 00:28:05,330
we implemented that<font color="#E5E5E5"> on two platforms</font>

650
00:28:02,900 --> 00:28:07,580
into<font color="#CCCCCC"> siskiyou peak which is an embedded</font>

651
00:28:05,330 --> 00:28:13,220
platform<font color="#E5E5E5"> released to our Intel Institute</font>

652
00:28:07,580 --> 00:28:16,178
in<font color="#CCCCCC"> darmstadt and sparkly on three now</font>

653
00:28:13,220 --> 00:28:19,309
for the last part<font color="#E5E5E5"> of my talk I want to</font>

654
00:28:16,179 --> 00:28:22,520
elaborate on a scenario where we<font color="#E5E5E5"> want to</font>

655
00:28:19,309 --> 00:28:24,320
deploy<font color="#CCCCCC"> cfi into the kernel code and it</font>

656
00:28:22,520 --> 00:28:26,900
turns out that<font color="#E5E5E5"> there are some unique</font>

657
00:28:24,320 --> 00:28:28,909
challenges when they put deploying cfi

658
00:28:26,900 --> 00:28:33,020
for kernel code which are particular

659
00:28:28,910 --> 00:28:35,570
related to page tables consider for<font color="#E5E5E5"> this</font>

660
00:28:33,020 --> 00:28:38,540
again<font color="#E5E5E5"> a memory layout where we have user</font>

661
00:28:35,570 --> 00:28:41,990
code and kernel code and the kernel code

662
00:28:38,540 --> 00:28:44,809
contains a code and data section where

663
00:28:41,990 --> 00:28:47,150
the code section contains system<font color="#CCCCCC"> call</font>

664
00:28:44,809 --> 00:28:50,060
code and the data contains the page

665
00:28:47,150 --> 00:28:51,890
tables now from user mode

666
00:28:50,060 --> 00:28:53,690
if the attacker controls<font color="#E5E5E5"> a user mode and</font>

667
00:28:51,890 --> 00:28:55,580
has a read and write primitive to the

668
00:28:53,690 --> 00:28:57,320
current code he has<font color="#CCCCCC"> access to the</font>

669
00:28:55,580 --> 00:28:59,899
readable and writable page tables and

670
00:28:57,320 --> 00:29:02,840
can basically change the access

671
00:28:59,900 --> 00:29:04,760
permissions of<font color="#E5E5E5"> memory pages</font><font color="#CCCCCC"> sopia page</font>

672
00:29:02,840 --> 00:29:07,310
tables are used for the translation<font color="#CCCCCC"> of</font>

673
00:29:04,760 --> 00:29:09,260
from virtual to physical addresses but

674
00:29:07,310 --> 00:29:12,169
also to<font color="#CCCCCC"> maintain the</font><font color="#E5E5E5"> access rights of</font>

675
00:29:09,260 --> 00:29:13,640
memory pages so we can change the access

676
00:29:12,170 --> 00:29:17,090
permissions to readable right will

677
00:29:13,640 --> 00:29:21,260
executable and then inject our malicious

678
00:29:17,090 --> 00:29:23,810
code into that original current code and

679
00:29:21,260 --> 00:29:25,640
finally the attacker only needed needs

680
00:29:23,810 --> 00:29:28,639
to trigger the system call from user

681
00:29:25,640 --> 00:29:31,880
mode to execute the malicious code here

682
00:29:28,640 --> 00:29:34,130
so even if we have protected the entire

683
00:29:31,880 --> 00:29:35,900
program and the<font color="#CCCCCC"> kernel</font><font color="#E5E5E5"> code with GFI we</font>

684
00:29:34,130 --> 00:29:38,480
could not capture this attack because

685
00:29:35,900 --> 00:29:41,240
this kind of resembles<font color="#E5E5E5"> data only attack</font>

686
00:29:38,480 --> 00:29:45,590
that immediately overrides code here in

687
00:29:41,240 --> 00:29:48,200
the corner<font color="#E5E5E5"> a more detailed view of the</font>

688
00:29:45,590 --> 00:29:50,510
attack is as follows<font color="#E5E5E5"> the current the</font>

689
00:29:48,200 --> 00:29:52,790
attacker has access to several data

690
00:29:50,510 --> 00:29:55,550
structures in kernel in particular to a

691
00:29:52,790 --> 00:29:57,170
task structure that points to a memory

692
00:29:55,550 --> 00:29:59,360
management structure and that<font color="#E5E5E5"> one</font>

693
00:29:57,170 --> 00:30:01,490
contains the root address to the page

694
00:29:59,360 --> 00:30:04,010
tables and once<font color="#E5E5E5"> we know the root address</font>

695
00:30:01,490 --> 00:30:06,530
we can add the offset of<font color="#CCCCCC"> the page that</font>

696
00:30:04,010 --> 00:30:10,570
<font color="#E5E5E5">we want to change and arrive at the</font>

697
00:30:06,530 --> 00:30:13,340
first level of that page table entry on

698
00:30:10,570 --> 00:30:16,399
64-bit systems paging is implemented<font color="#E5E5E5"> as</font>

699
00:30:13,340 --> 00:30:18,949
a hierarchy<font color="#CCCCCC"> of four levels however if we</font>

700
00:30:16,400 --> 00:30:20,990
<font color="#E5E5E5">arrive at the first level then the</font>

701
00:30:18,950 --> 00:30:23,360
attacker has only access<font color="#CCCCCC"> to a physical</font>

702
00:30:20,990 --> 00:30:25,520
address and that physical address cannot

703
00:30:23,360 --> 00:30:27,860
since<font color="#CCCCCC"> Colonel operates on virtual memory</font>

704
00:30:25,520 --> 00:30:30,620
cannot be directly mapped to the next

705
00:30:27,860 --> 00:30:33,379
level however there is a data structure

706
00:30:30,620 --> 00:30:36,439
called fist map which can be exploited

707
00:30:33,380 --> 00:30:38,950
as a kind of Oracle so we feed the

708
00:30:36,440 --> 00:30:41,600
physical address into that Oracle and

709
00:30:38,950 --> 00:30:44,000
get<font color="#CCCCCC"> a get</font><font color="#E5E5E5"> the virtual address of the</font>

710
00:30:41,600 --> 00:30:46,159
<font color="#CCCCCC">next</font><font color="#E5E5E5"> level in</font><font color="#CCCCCC"> the page in</font><font color="#E5E5E5"> the page table</font>

711
00:30:44,000 --> 00:30:49,010
arriving at level<font color="#CCCCCC"> two for that</font>

712
00:30:46,160 --> 00:30:52,250
particular page now we can<font color="#E5E5E5"> exploit this</font>

713
00:30:49,010 --> 00:30:54,650
map continuously until we arrive at the

714
00:30:52,250 --> 00:30:57,140
level<font color="#CCCCCC"> four page table entry which</font>

715
00:30:54,650 --> 00:31:00,100
maintains the excess right of our page

716
00:30:57,140 --> 00:31:00,100
that we want<font color="#E5E5E5"> to change</font>

717
00:31:00,740 --> 00:31:05,750
now there have<font color="#CCCCCC"> been several through</font>

718
00:31:03,050 --> 00:31:08,059
schemes that aim at mitigating these

719
00:31:05,750 --> 00:31:09,950
attacks however all these schemes make

720
00:31:08,059 --> 00:31:12,678
some assumptions like requiring a

721
00:31:09,950 --> 00:31:14,900
separate<font color="#E5E5E5"> trust hardware or a separate</font>

722
00:31:12,679 --> 00:31:19,309
execution mode in form of a hypervisor

723
00:31:14,900 --> 00:31:21,650
or they built on very inefficient

724
00:31:19,309 --> 00:31:24,950
integrity checks and in our work the

725
00:31:21,650 --> 00:31:27,910
goal was to provide a mitigation scheme

726
00:31:24,950 --> 00:31:30,980
that can be instantly<font color="#E5E5E5"> applied to a</font>

727
00:31:27,910 --> 00:31:33,890
modern kernels and requires no extra

728
00:31:30,980 --> 00:31:36,770
hardware or extra assumptions and this

729
00:31:33,890 --> 00:31:38,210
is an ongoing work so if you have any

730
00:31:36,770 --> 00:31:40,790
feedback<font color="#E5E5E5"> on that we would</font><font color="#CCCCCC"> be very</font>

731
00:31:38,210 --> 00:31:42,800
grateful<font color="#E5E5E5"> to receive that but I want</font><font color="#CCCCCC"> to</font>

732
00:31:40,790 --> 00:31:46,309
<font color="#E5E5E5">we are just shortly present you how we</font>

733
00:31:42,800 --> 00:31:49,190
perform page table randomization the

734
00:31:46,309 --> 00:31:51,710
idea is first to obfuscate the pointers

735
00:31:49,190 --> 00:31:53,990
that reference page tables in our

736
00:31:51,710 --> 00:31:55,820
example we<font color="#E5E5E5"> have the root pointer to the</font>

737
00:31:53,990 --> 00:31:59,660
page tables and we use a<font color="#E5E5E5"> very simple</font>

738
00:31:55,820 --> 00:32:02,030
trick that we<font color="#E5E5E5"> simply change the virtual</font>

739
00:31:59,660 --> 00:32:04,730
<font color="#CCCCCC">address to a physical</font><font color="#E5E5E5"> address since the</font>

740
00:32:02,030 --> 00:32:06,860
kernel operates on virtual memory the

741
00:32:04,730 --> 00:32:09,050
attacker cannot directly infer the

742
00:32:06,860 --> 00:32:11,870
virtual address of the page tables once

743
00:32:09,050 --> 00:32:14,120
we change that we also create a

744
00:32:11,870 --> 00:32:18,590
randomized area where we allocate the

745
00:32:14,120 --> 00:32:22,399
page tables and use a separate register

746
00:32:18,590 --> 00:32:23,919
that is used to translate<font color="#E5E5E5"> the vertical</font>

747
00:32:22,400 --> 00:32:26,840
addresses back to virtual addresses

748
00:32:23,920 --> 00:32:28,610
however the attacker has not directly

749
00:32:26,840 --> 00:32:30,649
access to that privilege register

750
00:32:28,610 --> 00:32:32,928
because<font color="#E5E5E5"> in order to do so we would need</font>

751
00:32:30,650 --> 00:32:36,380
to<font color="#E5E5E5"> compromise the control flow of the</font>

752
00:32:32,929 --> 00:32:39,530
application in of the colonel<font color="#E5E5E5"> in memory</font>

753
00:32:36,380 --> 00:32:41,720
allowing him then to read that register

754
00:32:39,530 --> 00:32:44,600
but that one can be protected<font color="#CCCCCC"> with cfi</font>

755
00:32:41,720 --> 00:32:47,330
he also can no longer<font color="#E5E5E5"> use the fist map</font>

756
00:32:44,600 --> 00:32:49,550
as a kind of<font color="#E5E5E5"> Oracle because we remove</font>

757
00:32:47,330 --> 00:32:52,850
all page table related data and page

758
00:32:49,550 --> 00:32:54,649
table reference from that area there<font color="#CCCCCC"> are</font>

759
00:32:52,850 --> 00:32:56,659
some challenges involved in<font color="#CCCCCC"> this scheme</font>

760
00:32:54,650 --> 00:32:58,670
in particular there is<font color="#E5E5E5"> not only</font><font color="#CCCCCC"> that</font>

761
00:32:56,660 --> 00:33:01,070
route pointer to the page table there

762
00:32:58,670 --> 00:33:03,050
are many pointers to page tables and we

763
00:33:01,070 --> 00:33:05,419
need<font color="#CCCCCC"> to replay we need to</font><font color="#E5E5E5"> identify them</font>

764
00:33:03,050 --> 00:33:08,090
and replace them with physical addresses

765
00:33:05,420 --> 00:33:10,550
first<font color="#E5E5E5"> we need to</font><font color="#CCCCCC"> change the kernel</font>

766
00:33:08,090 --> 00:33:13,909
function that access the page tables so

767
00:33:10,550 --> 00:33:14,500
we<font color="#E5E5E5"> change them that they always return</font>

768
00:33:13,910 --> 00:33:16,390
physical

769
00:33:14,500 --> 00:33:17,980
addresses and if they access the<font color="#E5E5E5"> page</font>

770
00:33:16,390 --> 00:33:21,220
tables they always go<font color="#E5E5E5"> through our</font>

771
00:33:17,980 --> 00:33:23,710
privilege register as already mentioned

772
00:33:21,220 --> 00:33:26,440
we still<font color="#E5E5E5"> need to preserve the fist map</font>

773
00:33:23,710 --> 00:33:28,480
functionality so we remove only the page

774
00:33:26,440 --> 00:33:32,500
tables from that area and not any other

775
00:33:28,480 --> 00:33:35,320
data this has been<font color="#E5E5E5"> implemented for a</font>

776
00:33:32,500 --> 00:33:38,350
recent<font color="#E5E5E5"> Linux version in particular for</font>

777
00:33:35,320 --> 00:33:40,570
debian 8.2 and<font color="#CCCCCC"> linux kernel version 4.2</font>

778
00:33:38,350 --> 00:33:43,480
and it turns out that the performance

779
00:33:40,570 --> 00:33:45,730
overhead is almost negligible so we

780
00:33:43,480 --> 00:33:49,260
could not<font color="#E5E5E5"> really identify any overhead</font>

781
00:33:45,730 --> 00:33:52,330
than applying page table randomization

782
00:33:49,260 --> 00:33:54,340
so let<font color="#E5E5E5"> me conclude these talks code</font>

783
00:33:52,330 --> 00:33:57,879
reuse attack are still a prevalent

784
00:33:54,340 --> 00:33:59,800
exploitation technique and there are two

785
00:33:57,880 --> 00:34:02,200
defense directions that<font color="#CCCCCC"> we have explored</font>

786
00:33:59,800 --> 00:34:03,850
and also research community which is

787
00:34:02,200 --> 00:34:06,220
control flow integrity and fine-grained

788
00:34:03,850 --> 00:34:09,100
code randomization both of them have

789
00:34:06,220 --> 00:34:11,320
their advantages and disadvantages go to

790
00:34:09,100 --> 00:34:14,409
randomization builds on probabilistic

791
00:34:11,320 --> 00:34:17,620
where c of i is enforcement base and can

792
00:34:14,409 --> 00:34:19,540
provide higher let's say higher formal

793
00:34:17,620 --> 00:34:21,819
security assurance but on the<font color="#E5E5E5"> other hand</font>

794
00:34:19,540 --> 00:34:24,550
it's very hard to enforce<font color="#CCCCCC"> efi in</font>

795
00:34:21,820 --> 00:34:27,220
practice because<font color="#CCCCCC"> of performance</font><font color="#E5E5E5"> and also</font>

796
00:34:24,550 --> 00:34:29,500
because of the<font color="#E5E5E5"> limitations of static</font>

797
00:34:27,219 --> 00:34:32,080
analysis to capture the precise control

798
00:34:29,500 --> 00:34:34,649
flow graph hardware and software<font color="#CCCCCC"> co</font>

799
00:34:32,080 --> 00:34:37,418
<font color="#CCCCCC">design is one potential direction to</font>

800
00:34:34,649 --> 00:34:40,149
make these control flow integrity

801
00:34:37,418 --> 00:34:41,949
frameworks more efficient and we lastly

802
00:34:40,149 --> 00:34:44,549
<font color="#CCCCCC">discuss page table randomization which</font>

803
00:34:41,949 --> 00:34:48,428
allows us to<font color="#CCCCCC"> have a very efficient</font>

804
00:34:44,550 --> 00:34:52,690
underlying mechanism allowing a secure

805
00:34:48,429 --> 00:34:55,030
enforcement of GFI in the corner we said

806
00:34:52,690 --> 00:34:58,260
<font color="#CCCCCC">i thank you for your</font><font color="#E5E5E5"> attention and i'm</font>

807
00:34:55,030 --> 00:34:58,260
happy<font color="#E5E5E5"> to take your questions</font>

808
00:35:01,210 --> 00:35:03,270
you

