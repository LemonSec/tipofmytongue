1
00:00:00,060 --> 00:00:06,569
thank you so today<font color="#E5E5E5"> I</font><font color="#CCCCCC"> will first talk</font>

2
00:00:04,710 --> 00:00:08,820
about caches so<font color="#E5E5E5"> some</font><font color="#CCCCCC"> general</font>

3
00:00:06,569 --> 00:00:11,340
introduction then I will short very

4
00:00:08,820 --> 00:00:13,679
<font color="#E5E5E5">really briefly talk about cache attacks</font>

5
00:00:11,340 --> 00:00:16,800
and after that<font color="#CCCCCC"> about row hammer</font>

6
00:00:13,679 --> 00:00:18,448
<font color="#E5E5E5">especially</font><font color="#CCCCCC"> rohan Egeus</font><font color="#E5E5E5"> so let's start</font>

7
00:00:16,800 --> 00:00:21,779
<font color="#E5E5E5">with sketches right away of course</font><font color="#CCCCCC"> I</font>

8
00:00:18,449 --> 00:00:23,880
<font color="#E5E5E5">speak about CPU caches</font><font color="#CCCCCC"> I'm</font><font color="#E5E5E5"> I work on</font>

9
00:00:21,779 --> 00:00:29,279
micro architectural<font color="#E5E5E5"> attack so here</font>

10
00:00:23,880 --> 00:00:31,439
caches always means CPU caches the<font color="#CCCCCC"> idea</font>

11
00:00:29,279 --> 00:00:33,630
of CPU caches is that the<font color="#E5E5E5"> CPU speed</font>

12
00:00:31,439 --> 00:00:38,610
<font color="#E5E5E5">always increases so you have moves law</font>

13
00:00:33,630 --> 00:00:41,820
and the DRAM latency doesn't<font color="#E5E5E5"> reduce in</font>

14
00:00:38,610 --> 00:00:43,170
the same amount<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> same</font><font color="#E5E5E5"> amount so</font><font color="#CCCCCC"> we</font>

15
00:00:41,820 --> 00:00:46,950
<font color="#E5E5E5">get the problem that we have a</font>

16
00:00:43,170 --> 00:00:48,510
bottleneck here<font color="#E5E5E5"> the DRAM is slow the</font>

17
00:00:46,950 --> 00:00:51,090
solution is we<font color="#E5E5E5"> introduce smaller</font>

18
00:00:48,510 --> 00:00:53,099
memories inside the CPU earlier they

19
00:00:51,090 --> 00:00:55,170
were externally but now they are<font color="#E5E5E5"> inside</font>

20
00:00:53,100 --> 00:00:58,500
the CPU and also we have<font color="#CCCCCC"> different</font>

21
00:00:55,170 --> 00:01:01,680
caches<font color="#CCCCCC"> that are in of a different size</font>

22
00:00:58,500 --> 00:01:04,379
and have different<font color="#E5E5E5"> speed properties if</font>

23
00:01:01,680 --> 00:01:07,040
we perform memory<font color="#E5E5E5"> accesses</font><font color="#CCCCCC"> on a computer</font>

24
00:01:04,379 --> 00:01:09,930
in C and JavaScript in any language

25
00:01:07,040 --> 00:01:11,790
<font color="#CCCCCC">basically every memory</font><font color="#E5E5E5"> reference will go</font>

26
00:01:09,930 --> 00:01:14,189
through the cache we cannot avoid avoid

27
00:01:11,790 --> 00:01:16,619
that<font color="#E5E5E5"> unless we use specific instructions</font>

28
00:01:14,189 --> 00:01:18,570
for<font color="#E5E5E5"> that but usually every memory access</font>

29
00:01:16,619 --> 00:01:20,159
goes through the cache and this is

30
00:01:18,570 --> 00:01:22,408
transparent to<font color="#E5E5E5"> the operating</font><font color="#CCCCCC"> system and</font>

31
00:01:20,159 --> 00:01:26,970
<font color="#E5E5E5">the programs they can't work around</font><font color="#CCCCCC"> that</font>

32
00:01:22,409 --> 00:01:29,159
<font color="#E5E5E5">except using non temporal accesses for</font>

33
00:01:26,970 --> 00:01:31,710
<font color="#E5E5E5">instance but that's not the regular case</font>

34
00:01:29,159 --> 00:01:35,790
if we measure<font color="#E5E5E5"> the access latency for</font>

35
00:01:31,710 --> 00:01:36,869
<font color="#E5E5E5">memory</font><font color="#CCCCCC"> access we see that almost all</font>

36
00:01:35,790 --> 00:01:39,329
cached

37
00:01:36,869 --> 00:01:41,490
exits are excesses are here around 50

38
00:01:39,329 --> 00:01:44,369
cycles on this machine<font color="#CCCCCC"> this</font><font color="#E5E5E5"> includes all</font>

39
00:01:41,490 --> 00:01:47,490
the measurement and<font color="#E5E5E5"> the non-cash</font>

40
00:01:44,369 --> 00:01:50,040
accesses<font color="#E5E5E5"> they are mostly here around 250</font>

41
00:01:47,490 --> 00:01:52,829
cycles<font color="#E5E5E5"> so there is a huge gap and</font><font color="#CCCCCC"> also</font>

42
00:01:50,040 --> 00:01:55,259
we have a clear a clear difference we

43
00:01:52,829 --> 00:02:01,139
can say if<font color="#E5E5E5"> something is below 200 cycles</font>

44
00:01:55,259 --> 00:02:03,270
<font color="#CCCCCC">it's very likely to be cached if it's</font>

45
00:02:01,140 --> 00:02:05,670
above 200 then it's<font color="#E5E5E5"> very likely to</font><font color="#CCCCCC"> be</font>

46
00:02:03,270 --> 00:02:07,560
not cached<font color="#E5E5E5"> how does the cache work I</font>

47
00:02:05,670 --> 00:02:08,190
<font color="#CCCCCC">will start with</font><font color="#E5E5E5"> the most</font><font color="#CCCCCC"> simple cache</font>

48
00:02:07,560 --> 00:02:10,709
here

49
00:02:08,190 --> 00:02:12,380
that's a directly<font color="#E5E5E5"> mapped cache and we</font>

50
00:02:10,709 --> 00:02:14,150
have a memory address here

51
00:02:12,380 --> 00:02:17,359
we have the cash the cash<font color="#E5E5E5"> is divided</font>

52
00:02:14,150 --> 00:02:21,860
<font color="#CCCCCC">into two halves</font><font color="#E5E5E5"> the first half is the</font>

53
00:02:17,360 --> 00:02:23,660
first column is<font color="#CCCCCC"> the tag and the second</font>

54
00:02:21,860 --> 00:02:26,960
column is<font color="#CCCCCC"> the data so we have some</font><font color="#E5E5E5"> data</font>

55
00:02:23,660 --> 00:02:28,780
and the tag<font color="#E5E5E5"> is</font><font color="#CCCCCC"> used to identify</font><font color="#E5E5E5"> that</font>

56
00:02:26,960 --> 00:02:32,960
this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the data that we actually</font>

57
00:02:28,780 --> 00:02:35,540
<font color="#E5E5E5">actually are looking for next step the</font>

58
00:02:32,960 --> 00:02:38,840
<font color="#CCCCCC">Ameri a dress is divided into different</font>

59
00:02:35,540 --> 00:02:42,200
<font color="#E5E5E5">parts so the last part is just the</font>

60
00:02:38,840 --> 00:02:45,920
<font color="#E5E5E5">offset</font><font color="#CCCCCC"> and that's B bits</font><font color="#E5E5E5"> so we</font><font color="#CCCCCC"> have a</font>

61
00:02:42,200 --> 00:02:48,230
cache<font color="#CCCCCC"> line size of 2 to</font><font color="#E5E5E5"> the B bytes</font>

62
00:02:45,920 --> 00:02:51,140
<font color="#E5E5E5">that's just how the how the bits are</font>

63
00:02:48,230 --> 00:02:53,420
used it's<font color="#CCCCCC"> similar to the offset with</font>

64
00:02:51,140 --> 00:02:55,519
paging that you also have these<font color="#CCCCCC"> 12 bits</font>

65
00:02:53,420 --> 00:02:59,570
that are used for<font color="#CCCCCC"> the page offset</font><font color="#E5E5E5"> here</font>

66
00:02:55,520 --> 00:03:02,630
it's<font color="#CCCCCC"> just</font><font color="#E5E5E5"> the cache line offset the next</font>

67
00:02:59,570 --> 00:03:04,579
<font color="#CCCCCC">end bits are used</font><font color="#E5E5E5"> as the cash index and</font>

68
00:03:02,630 --> 00:03:06,799
the cash index<font color="#E5E5E5"> is</font><font color="#CCCCCC"> used to find the right</font>

69
00:03:04,580 --> 00:03:11,750
line in the<font color="#CCCCCC"> cache so you see that there</font>

70
00:03:06,800 --> 00:03:16,450
<font color="#CCCCCC">are multiple lines</font><font color="#E5E5E5"> in the cache and</font><font color="#CCCCCC"> we</font>

71
00:03:11,750 --> 00:03:18,770
can now look<font color="#E5E5E5"> up which line we want</font><font color="#CCCCCC"> to</font>

72
00:03:16,450 --> 00:03:20,359
<font color="#CCCCCC">where this memory address is</font><font color="#E5E5E5"> cached in</font>

73
00:03:18,770 --> 00:03:23,450
which line and then we can<font color="#CCCCCC"> verify</font>

74
00:03:20,360 --> 00:03:26,420
whether the tag is fixed to this<font color="#E5E5E5"> memory</font>

75
00:03:23,450 --> 00:03:28,609
address in<font color="#E5E5E5"> our process so given that we</font>

76
00:03:26,420 --> 00:03:32,239
have n<font color="#E5E5E5"> bits up for the cache index we</font>

77
00:03:28,610 --> 00:03:34,250
have<font color="#E5E5E5"> 2 to the</font><font color="#CCCCCC"> N cache lines finally the</font>

78
00:03:32,240 --> 00:03:36,620
tag is computed using<font color="#E5E5E5"> some function</font><font color="#CCCCCC"> that</font>

79
00:03:34,250 --> 00:03:39,950
can be<font color="#E5E5E5"> the identity function of some</font>

80
00:03:36,620 --> 00:03:43,490
address bits it can be<font color="#CCCCCC"> an XOR of address</font>

81
00:03:39,950 --> 00:03:45,980
bits we don't know that<font color="#E5E5E5"> but it's used as</font>

82
00:03:43,490 --> 00:03:51,920
a tag and<font color="#E5E5E5"> then we compare if the tag is</font>

83
00:03:45,980 --> 00:03:53,750
<font color="#E5E5E5">if the tag</font><font color="#CCCCCC"> is the same then we will have</font>

84
00:03:51,920 --> 00:03:59,030
a cache hit<font color="#E5E5E5"> if it's not the same we will</font>

85
00:03:53,750 --> 00:04:01,490
have a cache miss so<font color="#E5E5E5"> the obvious</font><font color="#CCCCCC"> problem</font>

86
00:03:59,030 --> 00:04:04,190
here<font color="#E5E5E5"> is if we</font><font color="#CCCCCC"> have two addresses</font><font color="#E5E5E5"> that</font>

87
00:04:01,490 --> 00:04:07,400
<font color="#E5E5E5">have</font><font color="#CCCCCC"> the same</font><font color="#E5E5E5"> n bits here they will go</font>

88
00:04:04,190 --> 00:04:09,260
<font color="#E5E5E5">to the same cache</font><font color="#CCCCCC"> index and if we all</font>

89
00:04:07,400 --> 00:04:13,340
the time<font color="#CCCCCC"> work on to such addresses it</font>

90
00:04:09,260 --> 00:04:16,730
will<font color="#CCCCCC"> actually be slower than</font><font color="#E5E5E5"> working</font>

91
00:04:13,340 --> 00:04:19,280
without<font color="#CCCCCC"> a cache because every</font><font color="#E5E5E5"> every time</font>

92
00:04:16,730 --> 00:04:21,590
<font color="#CCCCCC">we access it is that it has to be copied</font>

93
00:04:19,279 --> 00:04:24,138
<font color="#E5E5E5">back to the memory</font><font color="#CCCCCC"> and then</font><font color="#E5E5E5"> copied into</font>

94
00:04:21,589 --> 00:04:26,989
<font color="#E5E5E5">the cache</font><font color="#CCCCCC"> again</font>

95
00:04:24,139 --> 00:04:30,080
that's when we introduced the set

96
00:04:26,990 --> 00:04:35,300
associativity<font color="#E5E5E5"> so in this case we divide</font>

97
00:04:30,080 --> 00:04:37,729
the<font color="#E5E5E5"> cache lines into we change the cache</font>

98
00:04:35,300 --> 00:04:40,370
lines to cache sets and each cache set

99
00:04:37,729 --> 00:04:43,310
now contains two<font color="#CCCCCC"> so-called</font>

100
00:04:40,370 --> 00:04:48,680
ways<font color="#E5E5E5"> so we can we have two identical</font>

101
00:04:43,310 --> 00:04:51,259
<font color="#E5E5E5">ways in every cache set so they are</font>

102
00:04:48,680 --> 00:04:54,439
<font color="#CCCCCC">equivalent and we can just store the</font>

103
00:04:51,259 --> 00:04:56,870
data in<font color="#E5E5E5"> one of the two ways and when we</font>

104
00:04:54,439 --> 00:05:01,159
want<font color="#E5E5E5"> to retrieve</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> data</font><font color="#CCCCCC"> both ways are</font>

105
00:04:56,870 --> 00:05:03,560
checked and the correct one<font color="#CCCCCC"> returns</font><font color="#E5E5E5"> the</font>

106
00:05:01,159 --> 00:05:07,330
data<font color="#E5E5E5"> and if we don't find it then it's</font>

107
00:05:03,560 --> 00:05:10,669
<font color="#E5E5E5">not</font><font color="#CCCCCC"> in the cache</font><font color="#E5E5E5"> if we have multiple</font>

108
00:05:07,330 --> 00:05:13,068
ways in<font color="#E5E5E5"> a cache set that are equivalent</font>

109
00:05:10,669 --> 00:05:16,669
<font color="#E5E5E5">then the replacement policy</font><font color="#CCCCCC"> gets very</font>

110
00:05:13,069 --> 00:05:19,370
important<font color="#E5E5E5"> I will I will not go into</font>

111
00:05:16,669 --> 00:05:21,378
details of the replacement<font color="#E5E5E5"> policy right</font>

112
00:05:19,370 --> 00:05:24,849
now<font color="#E5E5E5"> but we will talk about it later</font>

113
00:05:21,379 --> 00:05:28,129
because it's relevant for<font color="#E5E5E5"> row hammer</font><font color="#CCCCCC"> jas</font>

114
00:05:24,849 --> 00:05:30,219
so how do these caches work<font color="#E5E5E5"> I write</font>

115
00:05:28,129 --> 00:05:34,669
<font color="#E5E5E5">memory address here that's on purpose</font>

116
00:05:30,219 --> 00:05:37,129
<font color="#E5E5E5">because it's not clear whether it's a</font>

117
00:05:34,669 --> 00:05:39,469
physical<font color="#E5E5E5"> or virtual address caches often</font>

118
00:05:37,129 --> 00:05:41,779
use physical addresses but some use

119
00:05:39,469 --> 00:05:44,690
virtual addresses and if we use physical

120
00:05:41,779 --> 00:05:46,250
<font color="#E5E5E5">addresses we have to translate the</font>

121
00:05:44,690 --> 00:05:48,620
virtual addresses to physical addresses

122
00:05:46,250 --> 00:05:51,919
first and that takes<font color="#E5E5E5"> some</font><font color="#CCCCCC"> time so here</font>

123
00:05:48,620 --> 00:05:55,069
we'll just go a bit into TLB and paging

124
00:05:51,919 --> 00:05:56,659
<font color="#E5E5E5">so you should know paging that's that's</font>

125
00:05:55,069 --> 00:05:58,460
a mechanism<font color="#E5E5E5"> that translates virtual</font>

126
00:05:56,659 --> 00:06:00,800
addresses to physical addresses<font color="#CCCCCC"> and we</font>

127
00:05:58,460 --> 00:06:02,560
have some<font color="#E5E5E5"> translation lookaside buffer</font>

128
00:06:00,800 --> 00:06:05,599
that's also just<font color="#CCCCCC"> the cache</font><font color="#E5E5E5"> that</font>

129
00:06:02,560 --> 00:06:08,360
<font color="#E5E5E5">translates that that caches these</font>

130
00:06:05,599 --> 00:06:10,669
translation table entries from<font color="#E5E5E5"> which</font>

131
00:06:08,360 --> 00:06:12,560
<font color="#CCCCCC">were to physical mapping</font><font color="#E5E5E5"> and the TLB of</font>

132
00:06:10,669 --> 00:06:15,139
course has<font color="#E5E5E5"> some latency so it's</font>

133
00:06:12,560 --> 00:06:16,849
<font color="#E5E5E5">expensive to use physical addresses here</font>

134
00:06:15,139 --> 00:06:18,620
<font color="#E5E5E5">the worst case</font><font color="#CCCCCC"> for the cache would be</font>

135
00:06:16,849 --> 00:06:21,409
that it's not<font color="#E5E5E5"> in the translation</font>

136
00:06:18,620 --> 00:06:24,830
lookaside buffer<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> need to load</font><font color="#E5E5E5"> the</font>

137
00:06:21,409 --> 00:06:26,569
mapping from the DRAM and then load the

138
00:06:24,830 --> 00:06:28,940
<font color="#E5E5E5">data as well from the DRM</font><font color="#CCCCCC"> that would be</font>

139
00:06:26,569 --> 00:06:31,159
the worst case so the solution is<font color="#CCCCCC"> to use</font>

140
00:06:28,940 --> 00:06:34,639
virtual addresses instead of physical

141
00:06:31,159 --> 00:06:37,280
addresses<font color="#CCCCCC"> if possibly so if we think of</font>

142
00:06:34,639 --> 00:06:40,160
the index and<font color="#E5E5E5"> the tag</font>

143
00:06:37,280 --> 00:06:42,200
of the<font color="#E5E5E5"> cash we can think of these four</font>

144
00:06:40,160 --> 00:06:44,780
combinations and I will just go briefly

145
00:06:42,200 --> 00:06:46,909
through these four combinations so the

146
00:06:44,780 --> 00:06:49,190
first one it's that's very similar<font color="#E5E5E5"> to</font>

147
00:06:46,910 --> 00:06:51,020
<font color="#CCCCCC">what we already saw</font><font color="#E5E5E5"> so here we have the</font>

148
00:06:49,190 --> 00:06:54,020
n bits the<font color="#E5E5E5"> B bits and the tag is</font>

149
00:06:51,020 --> 00:06:56,359
<font color="#E5E5E5">computed from the VPN the virtual page</font>

150
00:06:54,020 --> 00:06:58,010
number<font color="#E5E5E5"> here and the data is then</font>

151
00:06:56,360 --> 00:07:01,669
retrieved based on the virtual<font color="#E5E5E5"> pasted</font>

152
00:06:58,010 --> 00:07:03,860
<font color="#E5E5E5">page number</font><font color="#CCCCCC"> the obvious problem here is</font>

153
00:07:01,669 --> 00:07:07,219
that<font color="#E5E5E5"> the virtual page number we have</font>

154
00:07:03,860 --> 00:07:10,390
virtual addresses<font color="#CCCCCC"> so if we</font><font color="#E5E5E5"> are if we</font>

155
00:07:07,220 --> 00:07:12,830
have multiple processes<font color="#E5E5E5"> they will have</font>

156
00:07:10,390 --> 00:07:15,919
<font color="#E5E5E5">different data on the same virtual</font>

157
00:07:12,830 --> 00:07:18,800
address<font color="#E5E5E5"> so that's bad the advantage here</font>

158
00:07:15,919 --> 00:07:22,070
is<font color="#E5E5E5"> that the virtually</font><font color="#CCCCCC"> indexed virtually</font>

159
00:07:18,800 --> 00:07:24,110
tagged cache<font color="#E5E5E5"> is fast</font><font color="#CCCCCC"> the virtual tag is</font>

160
00:07:22,070 --> 00:07:26,840
not unique<font color="#CCCCCC"> that is bad because</font><font color="#E5E5E5"> it's a</font>

161
00:07:24,110 --> 00:07:28,850
slow upon a context switch and also

162
00:07:26,840 --> 00:07:30,830
shared memory can be<font color="#CCCCCC"> more</font><font color="#E5E5E5"> than once in</font>

163
00:07:28,850 --> 00:07:35,330
<font color="#CCCCCC">the cache</font><font color="#E5E5E5"> that's also bad because then</font>

164
00:07:30,830 --> 00:07:37,070
we waste the expensive cache memory the

165
00:07:35,330 --> 00:07:39,320
other extreme<font color="#E5E5E5"> is physically</font><font color="#CCCCCC"> indexed</font>

166
00:07:37,070 --> 00:07:40,880
physically<font color="#E5E5E5"> tagged</font><font color="#CCCCCC"> so here we have to go</font>

167
00:07:39,320 --> 00:07:43,099
through the translation<font color="#E5E5E5"> lookaside buffer</font>

168
00:07:40,880 --> 00:07:45,020
and<font color="#E5E5E5"> then get the physical</font><font color="#CCCCCC"> address and</font>

169
00:07:43,100 --> 00:07:50,210
then<font color="#E5E5E5"> we can compute the tag so this is</font>

170
00:07:45,020 --> 00:07:52,580
very<font color="#E5E5E5"> slow yeah slow because of</font><font color="#CCCCCC"> the TLB</font>

171
00:07:50,210 --> 00:07:56,270
lookup and the advantage is shared

172
00:07:52,580 --> 00:07:59,599
memory is only<font color="#E5E5E5"> once in the cache yeah</font>

173
00:07:56,270 --> 00:08:01,250
<font color="#E5E5E5">next one I will not talk</font><font color="#CCCCCC"> much about</font><font color="#E5E5E5"> this</font>

174
00:07:59,600 --> 00:08:03,200
one because<font color="#CCCCCC"> it doesn't</font><font color="#E5E5E5"> make</font><font color="#CCCCCC"> it make much</font>

175
00:08:01,250 --> 00:08:06,140
sense<font color="#E5E5E5"> because it has a disadvantage that</font>

176
00:08:03,200 --> 00:08:08,150
<font color="#E5E5E5">it's slow and also the virtual tag is</font>

177
00:08:06,140 --> 00:08:10,070
not unique because<font color="#E5E5E5"> the virtual tag is</font>

178
00:08:08,150 --> 00:08:12,260
computed from the from the virtual

179
00:08:10,070 --> 00:08:14,229
<font color="#E5E5E5">address so shared memory is once in the</font>

180
00:08:12,260 --> 00:08:17,120
cache this is not used in<font color="#CCCCCC"> practice</font>

181
00:08:14,229 --> 00:08:19,310
<font color="#E5E5E5">virtually indexed</font><font color="#CCCCCC"> physically tagged</font><font color="#E5E5E5"> this</font>

182
00:08:17,120 --> 00:08:21,710
<font color="#E5E5E5">is used in practice because you can do</font>

183
00:08:19,310 --> 00:08:23,870
this<font color="#CCCCCC"> entirely so we will do the cache</font>

184
00:08:21,710 --> 00:08:25,310
index<font color="#E5E5E5"> we compute the cache index from</font>

185
00:08:23,870 --> 00:08:28,280
<font color="#E5E5E5">the virtual address we look at them in</font>

186
00:08:25,310 --> 00:08:31,400
the cache and then in parallel<font color="#E5E5E5"> we can</font><font color="#CCCCCC"> do</font>

187
00:08:28,280 --> 00:08:34,039
the TLB lookup get<font color="#E5E5E5"> the PPM and compute</font>

188
00:08:31,400 --> 00:08:35,929
<font color="#CCCCCC">the tag and retrieve the data</font><font color="#E5E5E5"> so this is</font>

189
00:08:34,039 --> 00:08:39,949
<font color="#CCCCCC">almost as fast</font><font color="#E5E5E5"> as the virtual index</font>

190
00:08:35,929 --> 00:08:43,459
virtually<font color="#E5E5E5"> tagged cache no restriction</font>

191
00:08:39,950 --> 00:08:47,030
here<font color="#E5E5E5"> is that we can only go up to 12</font>

192
00:08:43,460 --> 00:08:49,670
bits for the for the cache index and if

193
00:08:47,030 --> 00:08:51,050
you think about it<font color="#E5E5E5"> we have things since</font>

194
00:08:49,670 --> 00:08:53,959
more than<font color="#CCCCCC"> 10</font>

195
00:08:51,050 --> 00:08:56,689
we have<font color="#E5E5E5"> 32 kilobyte level 1 caches now</font>

196
00:08:53,959 --> 00:08:58,518
and the<font color="#E5E5E5"> reason is that it's fast</font><font color="#CCCCCC"> and you</font>

197
00:08:56,690 --> 00:09:01,310
can do this with<font color="#E5E5E5"> 8 ways if you add more</font>

198
00:08:58,519 --> 00:09:03,680
ways it gets<font color="#E5E5E5"> it gets slower again so I</font>

199
00:09:01,310 --> 00:09:07,339
think we<font color="#E5E5E5"> will stay with 32 kilobyte</font>

200
00:09:03,680 --> 00:09:09,640
level<font color="#E5E5E5"> 1 caches for</font><font color="#CCCCCC"> a while so as I</font><font color="#E5E5E5"> said</font>

201
00:09:07,339 --> 00:09:12,350
virtually next virtually tagged<font color="#E5E5E5"> for the</font>

202
00:09:09,640 --> 00:09:13,610
virtually next virtually physically

203
00:09:12,350 --> 00:09:15,649
checked for the<font color="#E5E5E5"> level 1 cache and</font>

204
00:09:13,610 --> 00:09:17,660
physically next physically tagged<font color="#E5E5E5"> is</font>

205
00:09:15,649 --> 00:09:21,170
usually used<font color="#E5E5E5"> for</font><font color="#CCCCCC"> level 2 and level 3</font>

206
00:09:17,660 --> 00:09:22,910
caches<font color="#E5E5E5"> so shared memory is shared in the</font>

207
00:09:21,170 --> 00:09:25,579
<font color="#E5E5E5">cache</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is an interesting observation</font>

208
00:09:22,910 --> 00:09:27,410
<font color="#CCCCCC">because if we have multiple</font><font color="#E5E5E5"> processes</font>

209
00:09:25,579 --> 00:09:29,959
running<font color="#CCCCCC"> that has have some shared memory</font>

210
00:09:27,410 --> 00:09:32,449
they<font color="#E5E5E5"> can influence each other through</font>

211
00:09:29,959 --> 00:09:35,089
the cache although they shouldn't be

212
00:09:32,450 --> 00:09:37,459
able<font color="#E5E5E5"> to get to do that if you look at</font>

213
00:09:35,089 --> 00:09:39,050
caches today they will look<font color="#E5E5E5"> something</font>

214
00:09:37,459 --> 00:09:41,810
like this<font color="#E5E5E5"> so you have multiple cores you</font>

215
00:09:39,050 --> 00:09:43,790
have level 1 course in level 2 11 1

216
00:09:41,810 --> 00:09:48,229
caches in level 2 caches<font color="#E5E5E5"> that are</font>

217
00:09:43,790 --> 00:09:50,810
private<font color="#CCCCCC"> to each core and the level the</font>

218
00:09:48,230 --> 00:09:53,510
level<font color="#E5E5E5"> 3 cache the last level cache is</font>

219
00:09:50,810 --> 00:09:56,390
divided into slices<font color="#CCCCCC"> for</font><font color="#E5E5E5"> one for each</font>

220
00:09:53,510 --> 00:09:59,800
core and it is shared<font color="#E5E5E5"> across all course</font>

221
00:09:56,390 --> 00:10:04,279
<font color="#CCCCCC">so every core can access all the level 3</font>

222
00:09:59,800 --> 00:10:06,050
data<font color="#CCCCCC"> but it has it takes a different</font>

223
00:10:04,279 --> 00:10:07,790
amount<font color="#E5E5E5"> of time and you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> also exploit</font>

224
00:10:06,050 --> 00:10:10,670
that to<font color="#E5E5E5"> do some other attack that I</font>

225
00:10:07,790 --> 00:10:13,010
won't talk about<font color="#CCCCCC"> today another property</font>

226
00:10:10,670 --> 00:10:14,899
that's very<font color="#E5E5E5"> interesting is that it's</font>

227
00:10:13,010 --> 00:10:17,300
inclusive<font color="#E5E5E5"> so all data that</font><font color="#CCCCCC"> is in the</font>

228
00:10:14,899 --> 00:10:19,490
<font color="#E5E5E5">level 1 or level 2 cache is also in the</font>

229
00:10:17,300 --> 00:10:21,800
level 3<font color="#CCCCCC"> cache</font><font color="#E5E5E5"> there cannot be any data</font>

230
00:10:19,490 --> 00:10:26,209
in level 2 or level<font color="#E5E5E5"> 1 that is not also</font>

231
00:10:21,800 --> 00:10:29,359
in the<font color="#CCCCCC"> last level cache then we have</font>

232
00:10:26,209 --> 00:10:32,149
some<font color="#E5E5E5"> mapping to the slices this function</font>

233
00:10:29,360 --> 00:10:35,480
here is based on<font color="#E5E5E5"> the physical address</font>

234
00:10:32,149 --> 00:10:40,130
<font color="#CCCCCC">and it computes</font><font color="#E5E5E5"> where in the last</font><font color="#CCCCCC"> level</font>

235
00:10:35,480 --> 00:10:42,350
cache<font color="#E5E5E5"> our address is actually cached and</font>

236
00:10:40,130 --> 00:10:44,930
this function<font color="#CCCCCC"> has been</font><font color="#E5E5E5"> reversed in China</font>

237
00:10:42,350 --> 00:10:49,760
yet<font color="#E5E5E5"> by different research groups in the</font>

238
00:10:44,930 --> 00:10:53,599
last<font color="#E5E5E5"> time finally the last part of the</font>

239
00:10:49,760 --> 00:10:57,529
background<font color="#E5E5E5"> is cache maintenance so</font><font color="#CCCCCC"> Intel</font>

240
00:10:53,600 --> 00:11:00,320
provides<font color="#E5E5E5"> or also arm and AMD these</font><font color="#CCCCCC"> CPUs</font>

241
00:10:57,529 --> 00:11:02,839
are all provide cache maintenance

242
00:11:00,320 --> 00:11:04,520
<font color="#CCCCCC">instructions that is first prefetch to</font>

243
00:11:02,839 --> 00:11:08,300
suggest the CPU to

244
00:11:04,520 --> 00:11:10,490
data into the cache actually prefetch if

245
00:11:08,300 --> 00:11:12,680
you if you use<font color="#CCCCCC"> it not</font><font color="#E5E5E5"> in the</font><font color="#CCCCCC"> right way</font>

246
00:11:10,490 --> 00:11:14,839
it would actually<font color="#E5E5E5"> consume more time than</font>

247
00:11:12,680 --> 00:11:17,089
you can save with it so you<font color="#E5E5E5"> should be</font>

248
00:11:14,839 --> 00:11:19,760
very<font color="#CCCCCC"> much</font><font color="#E5E5E5"> aware</font><font color="#CCCCCC"> of what you're doing</font>

249
00:11:17,089 --> 00:11:21,830
<font color="#CCCCCC">when you're</font><font color="#E5E5E5"> using prefetch and</font><font color="#CCCCCC"> the other</font>

250
00:11:19,760 --> 00:11:24,740
one is even worse<font color="#E5E5E5"> it's CL /</font>

251
00:11:21,830 --> 00:11:28,250
<font color="#E5E5E5">with that you can throw</font><font color="#CCCCCC"> data out of</font><font color="#E5E5E5"> the</font>

252
00:11:24,740 --> 00:11:30,140
<font color="#E5E5E5">cache</font><font color="#CCCCCC"> if you look at this or</font><font color="#E5E5E5"> look for</font><font color="#CCCCCC"> a</font>

253
00:11:28,250 --> 00:11:33,290
CL flash<font color="#E5E5E5"> on github</font><font color="#CCCCCC"> you won't find many</font>

254
00:11:30,140 --> 00:11:36,140
projects<font color="#CCCCCC"> that use it CL search is rarely</font>

255
00:11:33,290 --> 00:11:37,640
used I would say it's used<font color="#E5E5E5"> it's</font>

256
00:11:36,140 --> 00:11:41,870
necessary<font color="#E5E5E5"> sometimes for a cache</font>

257
00:11:37,640 --> 00:11:47,270
coherency memory coherency related stuff

258
00:11:41,870 --> 00:11:49,160
<font color="#E5E5E5">but it has very</font><font color="#CCCCCC"> often been suggested to</font>

259
00:11:47,270 --> 00:11:52,100
just remove CL flash to get rid<font color="#CCCCCC"> of all</font>

260
00:11:49,160 --> 00:11:54,230
the problems it has so both instructions

261
00:11:52,100 --> 00:11:56,540
are based on<font color="#CCCCCC"> virtual</font><font color="#E5E5E5"> addresses</font><font color="#CCCCCC"> and as we</font>

262
00:11:54,230 --> 00:11:58,970
<font color="#E5E5E5">just heard shared</font><font color="#CCCCCC"> memories shared</font><font color="#E5E5E5"> in the</font>

263
00:11:56,540 --> 00:12:01,819
cache<font color="#CCCCCC"> Co</font><font color="#E5E5E5"> flash is based on virtual</font>

264
00:11:58,970 --> 00:12:03,529
<font color="#E5E5E5">addresses we can throw out shared data</font>

265
00:12:01,820 --> 00:12:06,529
from the cache<font color="#E5E5E5"> and that leads us</font>

266
00:12:03,529 --> 00:12:08,959
directly to cache attacks so what can we

267
00:12:06,529 --> 00:12:10,910
<font color="#CCCCCC">do with cache attacks</font><font color="#E5E5E5"> yesterday someone</font>

268
00:12:08,959 --> 00:12:13,069
asked me<font color="#CCCCCC"> ok</font><font color="#E5E5E5"> well why why is this</font>

269
00:12:10,910 --> 00:12:14,180
relevant<font color="#CCCCCC"> no one is</font><font color="#E5E5E5"> interested in this</font>

270
00:12:13,070 --> 00:12:16,279
<font color="#E5E5E5">because you cannot do anything</font>

271
00:12:14,180 --> 00:12:18,859
practically with that actually we<font color="#CCCCCC"> build</font>

272
00:12:16,279 --> 00:12:21,680
a cache based<font color="#E5E5E5"> key logger or</font><font color="#CCCCCC"> partial key</font>

273
00:12:18,860 --> 00:12:23,870
logger with that<font color="#E5E5E5"> so we can just run an</font>

274
00:12:21,680 --> 00:12:28,939
unprivileged program maybe in the chrome

275
00:12:23,870 --> 00:12:31,579
sandbox<font color="#E5E5E5"> and we can spy on keystrokes and</font>

276
00:12:28,940 --> 00:12:33,920
distinguish some letters<font color="#E5E5E5"> from other</font>

277
00:12:31,579 --> 00:12:36,469
letters<font color="#E5E5E5"> so this is this goes very much</font>

278
00:12:33,920 --> 00:12:39,319
<font color="#E5E5E5">into the</font><font color="#CCCCCC"> direction</font><font color="#E5E5E5"> of a cache based key</font>

279
00:12:36,470 --> 00:12:43,010
logger also in several research papers

280
00:12:39,320 --> 00:12:47,750
<font color="#E5E5E5">they have been attacks on AES on RSA on</font>

281
00:12:43,010 --> 00:12:50,470
ECC algorithms<font color="#CCCCCC"> for</font><font color="#E5E5E5"> instance in the flash</font>

282
00:12:47,750 --> 00:12:56,480
and reload paper by<font color="#CCCCCC"> Yahoo I mean fagner</font>

283
00:12:50,470 --> 00:12:59,450
<font color="#CCCCCC">there they have recovered 7 97% of RSA</font>

284
00:12:56,480 --> 00:13:01,160
key<font color="#E5E5E5"> after a single encryption so that's</font>

285
00:12:59,450 --> 00:13:03,890
<font color="#E5E5E5">really bad if you can do that after</font><font color="#CCCCCC"> a</font>

286
00:13:01,160 --> 00:13:06,140
single encryption just by<font color="#E5E5E5"> monitoring</font>

287
00:13:03,890 --> 00:13:07,910
what happens in<font color="#E5E5E5"> your cache</font><font color="#CCCCCC"> and these</font>

288
00:13:06,140 --> 00:13:10,370
<font color="#E5E5E5">attacks have been demonstrated cross V M</font>

289
00:13:07,910 --> 00:13:14,089
cross core we<font color="#E5E5E5"> have seen cross CPU</font>

290
00:13:10,370 --> 00:13:17,150
attacks on Intel even<font color="#E5E5E5"> on arm cross CPU</font>

291
00:13:14,089 --> 00:13:17,790
attacks and yeah they work on basically

292
00:13:17,150 --> 00:13:20,160
<font color="#E5E5E5">any arc</font>

293
00:13:17,790 --> 00:13:23,250
so most attacks have been performed an

294
00:13:20,160 --> 00:13:26,000
intel on<font color="#E5E5E5"> arm we</font><font color="#CCCCCC"> have seen</font><font color="#E5E5E5"> someone we</font>

295
00:13:23,250 --> 00:13:28,410
have performed some attacks recently

296
00:13:26,000 --> 00:13:32,580
<font color="#CCCCCC">also cross</font><font color="#E5E5E5"> cpu attacks have been</font>

297
00:13:28,410 --> 00:13:35,040
<font color="#E5E5E5">demonstrated on AMD so yeah it works</font>

298
00:13:32,580 --> 00:13:35,760
pretty<font color="#CCCCCC"> much everywhere across</font><font color="#E5E5E5"> cortex how</font>

299
00:13:35,040 --> 00:13:37,530
do they work

300
00:13:35,760 --> 00:13:39,960
yeah there we exploit the inclusive

301
00:13:37,530 --> 00:13:42,030
property and that the last level cache

302
00:13:39,960 --> 00:13:45,090
contains all data from level 1 and level

303
00:13:42,030 --> 00:13:46,709
2 cache<font color="#E5E5E5"> so if you evict data from the</font>

304
00:13:45,090 --> 00:13:48,540
last level cache<font color="#E5E5E5"> then you're also</font>

305
00:13:46,710 --> 00:13:51,960
evicted from level 1 and level 2 cache

306
00:13:48,540 --> 00:13:54,449
of all cores<font color="#E5E5E5"> so also of the other at</font>

307
00:13:51,960 --> 00:13:57,150
level 1<font color="#E5E5E5"> course you can evict cache lines</font>

308
00:13:54,450 --> 00:14:03,210
from<font color="#E5E5E5"> from a private</font><font color="#CCCCCC"> level 1 cache of</font>

309
00:13:57,150 --> 00:14:07,079
another<font color="#CCCCCC"> core</font><font color="#E5E5E5"> and this brings us to to</font>

310
00:14:03,210 --> 00:14:08,940
the flush and<font color="#E5E5E5"> reload attack I will today</font>

311
00:14:07,080 --> 00:14:10,710
<font color="#E5E5E5">I will talk briefly about a flash and</font>

312
00:14:08,940 --> 00:14:14,550
reload and<font color="#CCCCCC"> prime probe and</font><font color="#E5E5E5"> prime</font>

313
00:14:10,710 --> 00:14:15,960
<font color="#E5E5E5">properly within leaders to row hammer so</font>

314
00:14:14,550 --> 00:14:18,270
with flash<font color="#CCCCCC"> and reload you have an</font>

315
00:14:15,960 --> 00:14:20,220
attacker<font color="#E5E5E5"> and</font><font color="#CCCCCC"> the victim and the cache is</font>

316
00:14:18,270 --> 00:14:23,420
here in the<font color="#CCCCCC"> middle and in the first</font><font color="#E5E5E5"> step</font>

317
00:14:20,220 --> 00:14:26,400
<font color="#CCCCCC">the attacker maps the shared library and</font>

318
00:14:23,420 --> 00:14:29,520
accesses it and then<font color="#E5E5E5"> in share then it's</font>

319
00:14:26,400 --> 00:14:31,410
cached for both the attacker<font color="#CCCCCC"> and victim</font>

320
00:14:29,520 --> 00:14:34,020
because it's shared<font color="#E5E5E5"> memories so it's</font>

321
00:14:31,410 --> 00:14:36,810
shared in the cache then<font color="#CCCCCC"> the attacker</font>

322
00:14:34,020 --> 00:14:38,850
flushes the data then maybe the victim

323
00:14:36,810 --> 00:14:41,729
at some point will load the<font color="#E5E5E5"> data and</font>

324
00:14:38,850 --> 00:14:44,130
then when the attacker<font color="#E5E5E5"> reloads the data</font>

325
00:14:41,730 --> 00:14:46,410
it will observe a low memory latency

326
00:14:44,130 --> 00:14:49,110
just as we have<font color="#E5E5E5"> seen in the histogram</font>

327
00:14:46,410 --> 00:14:51,270
<font color="#E5E5E5">right in the beginning</font><font color="#CCCCCC"> and then the</font>

328
00:14:49,110 --> 00:14:55,470
attacker has learned<font color="#E5E5E5"> that the victim</font>

329
00:14:51,270 --> 00:14:57,180
just<font color="#E5E5E5"> accessed this particular address so</font>

330
00:14:55,470 --> 00:15:00,240
with<font color="#CCCCCC"> prime and probe this works pretty</font>

331
00:14:57,180 --> 00:15:02,969
similar just at<font color="#E5E5E5"> this time the attacker</font>

332
00:15:00,240 --> 00:15:05,370
uses much more addresses<font color="#E5E5E5"> and uses these</font>

333
00:15:02,970 --> 00:15:09,960
addresses to fill the whole cache set<font color="#E5E5E5"> so</font>

334
00:15:05,370 --> 00:15:12,900
all ways in<font color="#E5E5E5"> in a cache set and now if</font>

335
00:15:09,960 --> 00:15:16,650
the victim accesses<font color="#E5E5E5"> some memory</font>

336
00:15:12,900 --> 00:15:20,910
locations<font color="#E5E5E5"> it will evict data from the</font>

337
00:15:16,650 --> 00:15:23,880
last level cache<font color="#CCCCCC"> replace some ways the</font>

338
00:15:20,910 --> 00:15:26,939
<font color="#E5E5E5">the attacker previously has primed has</font>

339
00:15:23,880 --> 00:15:30,720
filled with data and then the attacker

340
00:15:26,940 --> 00:15:31,560
will<font color="#CCCCCC"> reacts s</font><font color="#E5E5E5"> and the the memory that he</font>

341
00:15:30,720 --> 00:15:33,330
believes

342
00:15:31,560 --> 00:15:35,189
is still<font color="#E5E5E5"> in the cache and then he</font>

343
00:15:33,330 --> 00:15:36,779
observes the slow<font color="#E5E5E5"> access because one</font><font color="#CCCCCC"> of</font>

344
00:15:35,190 --> 00:15:38,820
the ways has<font color="#CCCCCC"> been replaced and then the</font>

345
00:15:36,779 --> 00:15:42,120
attacker has learned that<font color="#E5E5E5"> the</font><font color="#CCCCCC"> victim</font>

346
00:15:38,820 --> 00:15:44,279
<font color="#CCCCCC">accessed a memory location</font><font color="#E5E5E5"> that maps to</font>

347
00:15:42,120 --> 00:15:46,500
<font color="#CCCCCC">the</font><font color="#E5E5E5"> same cache set so the attacker can</font>

348
00:15:44,279 --> 00:15:54,720
derive the middle n bits for the cache

349
00:15:46,500 --> 00:15:57,630
index so I will<font color="#E5E5E5"> I will</font><font color="#CCCCCC"> just go straight</font>

350
00:15:54,720 --> 00:16:00,839
<font color="#E5E5E5">away to this</font><font color="#CCCCCC"> example</font><font color="#E5E5E5"> here on</font><font color="#CCCCCC"> the</font>

351
00:15:57,630 --> 00:16:02,910
keystroke<font color="#E5E5E5"> examples so here I just ran</font>

352
00:16:00,839 --> 00:16:05,820
this on on<font color="#E5E5E5"> a</font><font color="#CCCCCC"> non key up and key down</font>

353
00:16:02,910 --> 00:16:08,510
<font color="#CCCCCC">events and this is very nice</font><font color="#E5E5E5"> so you can</font>

354
00:16:05,820 --> 00:16:12,510
now<font color="#E5E5E5"> see the length of my pseudo password</font>

355
00:16:08,510 --> 00:16:14,520
<font color="#E5E5E5">that's not good</font><font color="#CCCCCC"> so the challenge here is</font>

356
00:16:12,510 --> 00:16:16,920
<font color="#E5E5E5">of course</font><font color="#CCCCCC"> how do we locate these key</font>

357
00:16:14,520 --> 00:16:19,439
dependent memory<font color="#E5E5E5"> accesses we can of</font>

358
00:16:16,920 --> 00:16:22,020
course<font color="#CCCCCC"> look</font><font color="#E5E5E5"> at object dumps but that's</font>

359
00:16:19,440 --> 00:16:24,510
<font color="#E5E5E5">very</font><font color="#CCCCCC"> difficult because it</font><font color="#E5E5E5"> is very time</font>

360
00:16:22,020 --> 00:16:27,569
consuming<font color="#E5E5E5"> and</font><font color="#CCCCCC"> the lessons I learned</font>

361
00:16:24,510 --> 00:16:29,400
while<font color="#CCCCCC"> doing this staring at object dumps</font>

362
00:16:27,570 --> 00:16:31,260
for several<font color="#CCCCCC"> weeks will give you severe</font>

363
00:16:29,400 --> 00:16:33,990
<font color="#E5E5E5">headache you shouldn't do that</font>

364
00:16:31,260 --> 00:16:35,880
so automate everything<font color="#E5E5E5"> right from the</font>

365
00:16:33,990 --> 00:16:37,710
start<font color="#E5E5E5"> and that's how we started</font>

366
00:16:35,880 --> 00:16:39,300
<font color="#CCCCCC">developing cache template attacks and in</font>

367
00:16:37,710 --> 00:16:42,210
cache template attacks we<font color="#E5E5E5"> have two</font>

368
00:16:39,300 --> 00:16:44,459
phases<font color="#E5E5E5"> first the profiling phase and</font>

369
00:16:42,210 --> 00:16:46,980
second the<font color="#E5E5E5"> exploitation phase and the</font>

370
00:16:44,460 --> 00:16:48,630
<font color="#E5E5E5">profiling phase we will do some</font>

371
00:16:46,980 --> 00:16:50,370
pre-processing<font color="#E5E5E5"> and locate which</font>

372
00:16:48,630 --> 00:16:52,140
addresses are interesting and in the

373
00:16:50,370 --> 00:16:55,650
exploitation<font color="#E5E5E5"> phase we just perform a</font>

374
00:16:52,140 --> 00:16:57,089
standard<font color="#CCCCCC"> slash and reload attack so the</font>

375
00:16:55,650 --> 00:16:58,860
profiling<font color="#E5E5E5"> phase will look something like</font>

376
00:16:57,089 --> 00:17:01,530
this<font color="#E5E5E5"> so in the beginning the cache is</font>

377
00:16:58,860 --> 00:17:03,810
<font color="#CCCCCC">empty and then we trigger some event</font>

378
00:17:01,530 --> 00:17:06,119
here it's a<font color="#E5E5E5"> keystroke a and then it's</font>

379
00:17:03,810 --> 00:17:08,928
cached for both the attacker<font color="#E5E5E5"> and</font><font color="#CCCCCC"> the</font>

380
00:17:06,119 --> 00:17:12,448
victim and the attacker now can check

381
00:17:08,929 --> 00:17:15,270
whether<font color="#E5E5E5"> the address is cached</font><font color="#CCCCCC"> and if the</font>

382
00:17:12,449 --> 00:17:18,929
address<font color="#E5E5E5"> is cached and the attacker will</font>

383
00:17:15,270 --> 00:17:21,900
store this in some matrix<font color="#E5E5E5"> too to learn</font>

384
00:17:18,929 --> 00:17:25,439
<font color="#E5E5E5">that this address is used for this F</font>

385
00:17:21,900 --> 00:17:28,530
event<font color="#E5E5E5"> then we flush it and we repeat</font>

386
00:17:25,439 --> 00:17:31,170
this for higher accuracy then<font color="#E5E5E5"> we repeat</font>

387
00:17:28,530 --> 00:17:33,178
it for all events and then we do this

388
00:17:31,170 --> 00:17:36,570
for<font color="#CCCCCC"> the next</font><font color="#E5E5E5"> address</font><font color="#CCCCCC"> so finally we will</font>

389
00:17:33,179 --> 00:17:41,190
have a matrix for all<font color="#E5E5E5"> events and all</font>

390
00:17:36,570 --> 00:17:44,669
addresses<font color="#E5E5E5"> and know which event triggers</font>

391
00:17:41,190 --> 00:17:48,000
<font color="#E5E5E5">a cache hit on which address and</font>

392
00:17:44,670 --> 00:17:52,470
in the opposite direction Akash it on

393
00:17:48,000 --> 00:17:54,780
which address means which event so how

394
00:17:52,470 --> 00:17:58,200
hard is<font color="#E5E5E5"> it to perform Akash attempted</font>

395
00:17:54,780 --> 00:18:01,800
attack we just recently did students

396
00:17:58,200 --> 00:18:04,320
attack this<font color="#E5E5E5"> student-led attack different</font>

397
00:18:01,800 --> 00:18:06,300
programs and they typically found

398
00:18:04,320 --> 00:18:08,760
leakage within<font color="#CCCCCC"> 30 minutes and different</font>

399
00:18:06,300 --> 00:18:11,280
<font color="#E5E5E5">programs and this is really</font><font color="#CCCCCC"> a wide range</font>

400
00:18:08,760 --> 00:18:16,530
of programs although<font color="#E5E5E5"> most students just</font>

401
00:18:11,280 --> 00:18:20,129
<font color="#E5E5E5">they just kept doing keystroke attacks</font>

402
00:18:16,530 --> 00:18:23,220
<font color="#E5E5E5">so we found so the students in this case</font>

403
00:18:20,130 --> 00:18:27,780
found keystroke side<font color="#E5E5E5"> channels and nano</font>

404
00:18:23,220 --> 00:18:32,460
quasi client<font color="#E5E5E5"> X term</font><font color="#CCCCCC"> pidgin gk2</font><font color="#E5E5E5"> Firefox</font>

405
00:18:27,780 --> 00:18:35,160
<font color="#E5E5E5">Emacs mousepad and here the user 32 DLL</font>

406
00:18:32,460 --> 00:18:39,860
on<font color="#CCCCCC"> Windows so it also always Emacs all</font>

407
00:18:35,160 --> 00:18:42,600
on<font color="#E5E5E5"> OSX</font><font color="#CCCCCC"> we can monitor</font><font color="#E5E5E5"> our keystrokes</font>

408
00:18:39,860 --> 00:18:44,790
specifically in the<font color="#CCCCCC"> password field in he</font>

409
00:18:42,600 --> 00:18:47,370
<font color="#CCCCCC">pass X that's also very interesting</font>

410
00:18:44,790 --> 00:18:51,360
<font color="#E5E5E5">because if you if you see okay</font>

411
00:18:47,370 --> 00:18:53,909
we had<font color="#CCCCCC"> 11 keystrokes now and then for</font><font color="#E5E5E5"> a</font>

412
00:18:51,360 --> 00:18:58,649
long time<font color="#E5E5E5"> nothing</font><font color="#CCCCCC"> then probably this was</font>

413
00:18:53,910 --> 00:19:01,740
the whole password<font color="#CCCCCC"> we have the font</font>

414
00:18:58,650 --> 00:19:03,900
rendering in<font color="#E5E5E5"> live half</font><font color="#CCCCCC"> pass which is</font>

415
00:19:01,740 --> 00:19:07,230
used<font color="#CCCCCC"> by</font><font color="#E5E5E5"> many Linux applications we</font><font color="#CCCCCC"> can</font>

416
00:19:03,900 --> 00:19:10,620
monitor action buttons in VLC<font color="#CCCCCC"> we can</font>

417
00:19:07,230 --> 00:19:14,160
monitor when<font color="#E5E5E5"> net</font><font color="#CCCCCC"> Kadri</font><font color="#E5E5E5"> sees characters</font>

418
00:19:10,620 --> 00:19:16,770
we<font color="#E5E5E5"> can distinguish key groups in</font><font color="#CCCCCC"> GK</font><font color="#E5E5E5"> su</font>

419
00:19:14,160 --> 00:19:19,830
and also monitor<font color="#CCCCCC"> when the checkbox in</font>

420
00:19:16,770 --> 00:19:22,740
the<font color="#CCCCCC"> case who is clicked</font><font color="#E5E5E5"> so you can do</font>

421
00:19:19,830 --> 00:19:24,689
pretty<font color="#E5E5E5"> much with that so the conclusion</font>

422
00:19:22,740 --> 00:19:27,540
is<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> can use this technique</font><font color="#CCCCCC"> to</font>

423
00:19:24,690 --> 00:19:31,680
find any<font color="#E5E5E5"> side</font><font color="#CCCCCC"> channel leakage cache</font>

424
00:19:27,540 --> 00:19:34,440
side-channel leakage in feasible<font color="#E5E5E5"> time it</font>

425
00:19:31,680 --> 00:19:37,140
works on all these<font color="#CCCCCC"> CPUs and with unknown</font>

426
00:19:34,440 --> 00:19:39,870
binaries<font color="#CCCCCC"> so even on Windows and you can</font>

427
00:19:37,140 --> 00:19:42,720
automate this and perform this in a

428
00:19:39,870 --> 00:19:44,610
<font color="#E5E5E5">large scale but it still requires shared</font>

429
00:19:42,720 --> 00:19:46,890
memory so why<font color="#E5E5E5"> don't</font><font color="#CCCCCC"> we do this with</font>

430
00:19:44,610 --> 00:19:48,570
<font color="#E5E5E5">prime and probe prime and probe would</font>

431
00:19:46,890 --> 00:19:50,400
have the<font color="#CCCCCC"> advantage that</font><font color="#E5E5E5"> we don't need</font>

432
00:19:48,570 --> 00:19:52,379
shared memory but it's much more

433
00:19:50,400 --> 00:19:55,440
<font color="#CCCCCC">difficult</font><font color="#E5E5E5"> to do that because it has a</font>

434
00:19:52,380 --> 00:19:57,510
lot of noise<font color="#E5E5E5"> so I won't do that with</font>

435
00:19:55,440 --> 00:19:58,590
<font color="#CCCCCC">priming probe although it should</font><font color="#E5E5E5"> be</font>

436
00:19:57,510 --> 00:20:00,690
<font color="#CCCCCC">possible</font>

437
00:19:58,590 --> 00:20:02,939
<font color="#CCCCCC">we'll do something</font><font color="#E5E5E5"> that's</font><font color="#CCCCCC"> mmm yeah</font>

438
00:20:00,690 --> 00:20:07,110
<font color="#E5E5E5">that's more fun with</font><font color="#CCCCCC"> Prime intro or</font>

439
00:20:02,940 --> 00:20:09,120
evict and reload<font color="#CCCCCC"> evict and reload if you</font>

440
00:20:07,110 --> 00:20:11,879
take<font color="#E5E5E5"> Prime and</font><font color="#CCCCCC"> Probst so this does some</font>

441
00:20:09,120 --> 00:20:14,158
<font color="#CCCCCC">cash eviction and</font><font color="#E5E5E5"> if you'd now perform a</font>

442
00:20:11,879 --> 00:20:16,199
single memory access with then you have

443
00:20:14,159 --> 00:20:19,710
evict and reload so it's<font color="#E5E5E5"> just a variant</font>

444
00:20:16,200 --> 00:20:23,519
of<font color="#E5E5E5"> Prime and</font><font color="#CCCCCC"> propane killing so row</font>

445
00:20:19,710 --> 00:20:25,440
hammer if you look at the<font color="#CCCCCC"> DRAM then you</font>

446
00:20:23,519 --> 00:20:29,460
will have multiple<font color="#E5E5E5"> channels you will</font>

447
00:20:25,440 --> 00:20:33,179
have the<font color="#CCCCCC"> dim will have multiple ranks</font>

448
00:20:29,460 --> 00:20:36,929
<font color="#E5E5E5">and chips and if you look at the chip</font>

449
00:20:33,179 --> 00:20:40,429
then the chip is separated into multiple

450
00:20:36,929 --> 00:20:47,600
banks and you can access these banks<font color="#E5E5E5"> in</font>

451
00:20:40,429 --> 00:20:50,399
parallel<font color="#E5E5E5"> so if you want to access some</font>

452
00:20:47,600 --> 00:20:53,490
memory location in the DRAM<font color="#E5E5E5"> then you</font>

453
00:20:50,399 --> 00:20:56,539
first have to<font color="#E5E5E5"> activate</font><font color="#CCCCCC"> the row</font><font color="#E5E5E5"> and copy</font>

454
00:20:53,490 --> 00:21:01,230
the data into<font color="#E5E5E5"> the row buffer the cells</font>

455
00:20:56,539 --> 00:21:04,369
by<font color="#E5E5E5"> themselves they leak voltage over</font>

456
00:21:01,230 --> 00:21:06,419
<font color="#E5E5E5">time so the voltage drops over time and</font>

457
00:21:04,369 --> 00:21:09,570
therefore<font color="#E5E5E5"> these cells need</font><font color="#CCCCCC"> to be</font>

458
00:21:06,419 --> 00:21:12,690
refreshed frequently<font color="#E5E5E5"> if you perform</font>

459
00:21:09,570 --> 00:21:14,850
<font color="#E5E5E5">excesses in physical proximity then the</font>

460
00:21:12,690 --> 00:21:19,350
cells leak faster and that's<font color="#E5E5E5"> what we</font>

461
00:21:14,850 --> 00:21:21,059
exploit in<font color="#CCCCCC"> the row hammer back so in the</font>

462
00:21:19,350 --> 00:21:24,509
<font color="#CCCCCC">row hammer back we</font><font color="#E5E5E5"> will just activate</font>

463
00:21:21,059 --> 00:21:26,428
one row and copy<font color="#CCCCCC"> is then copied to the</font>

464
00:21:24,509 --> 00:21:30,240
it is<font color="#CCCCCC"> actually not copied to the row</font>

465
00:21:26,429 --> 00:21:31,799
buffer but we can<font color="#CCCCCC"> just think</font><font color="#E5E5E5"> about it as</font>

466
00:21:30,240 --> 00:21:33,600
<font color="#E5E5E5">if it would be copied to the row buffer</font>

467
00:21:31,799 --> 00:21:39,210
in the row<font color="#E5E5E5"> buffers again some sort of</font>

468
00:21:33,600 --> 00:21:41,369
cache and<font color="#E5E5E5"> we always activate the</font>

469
00:21:39,210 --> 00:21:43,200
different rows and if we do<font color="#E5E5E5"> this often</font>

470
00:21:41,369 --> 00:21:46,350
<font color="#E5E5E5">enough then we will</font><font color="#CCCCCC"> have bit flips in</font>

471
00:21:43,200 --> 00:21:49,649
<font color="#CCCCCC">the middle row so here we</font><font color="#E5E5E5"> need</font><font color="#CCCCCC"> to</font>

472
00:21:46,350 --> 00:21:52,199
perform non-cash<font color="#E5E5E5"> accesses to reach the</font>

473
00:21:49,649 --> 00:21:54,268
DRAM and the original<font color="#E5E5E5"> attacks you still</font>

474
00:21:52,200 --> 00:21:56,970
flush for that so they basically clearly

475
00:21:54,269 --> 00:21:59,610
just do a flush<font color="#CCCCCC"> and reload attack I once</font>

476
00:21:56,970 --> 00:22:02,009
did<font color="#CCCCCC"> a I wanted to do a measurement on</font><font color="#E5E5E5"> a</font>

477
00:21:59,610 --> 00:22:03,658
flash and reload attack and<font color="#E5E5E5"> buy that</font>

478
00:22:02,009 --> 00:22:04,919
destroyed some shared library on<font color="#CCCCCC"> my</font>

479
00:22:03,659 --> 00:22:08,549
system and then the window manager

480
00:22:04,919 --> 00:22:10,240
crashed<font color="#E5E5E5"> and interestingly it</font><font color="#CCCCCC"> linux</font>

481
00:22:08,549 --> 00:22:12,580
decided to

482
00:22:10,240 --> 00:22:14,710
the changes back<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> hard-disk so</font>

483
00:22:12,580 --> 00:22:17,350
even after rebooting<font color="#CCCCCC"> I still had these</font>

484
00:22:14,710 --> 00:22:20,830
corruptions in<font color="#E5E5E5"> the shared library on</font><font color="#CCCCCC"> my</font>

485
00:22:17,350 --> 00:22:22,540
system<font color="#E5E5E5"> that was not nice so yeah I</font>

486
00:22:20,830 --> 00:22:24,280
<font color="#E5E5E5">really wonder why it does</font><font color="#CCCCCC"> that because</font>

487
00:22:22,540 --> 00:22:26,530
<font color="#CCCCCC">the shared libraries usually read only</font>

488
00:22:24,280 --> 00:22:29,110
so<font color="#E5E5E5"> Linux should know that this data</font>

489
00:22:26,530 --> 00:22:31,870
can't<font color="#CCCCCC"> be modified it's</font><font color="#E5E5E5"> weird</font>

490
00:22:29,110 --> 00:22:34,750
so we flushed the line<font color="#E5E5E5"> from the cache</font>

491
00:22:31,870 --> 00:22:38,620
and then the<font color="#E5E5E5"> next access has to reach</font>

492
00:22:34,750 --> 00:22:40,410
the<font color="#CCCCCC"> DRM the row</font><font color="#E5E5E5"> hammer box so that the</font>

493
00:22:38,620 --> 00:22:43,959
<font color="#CCCCCC">row hammer back is some</font><font color="#E5E5E5"> sense of</font>

494
00:22:40,410 --> 00:22:46,480
relevance<font color="#E5E5E5"> force security was first</font>

495
00:22:43,960 --> 00:22:49,770
observed by<font color="#E5E5E5"> Kim a tile who showed that</font>

496
00:22:46,480 --> 00:22:52,900
<font color="#CCCCCC">you can</font><font color="#E5E5E5"> do this purely in software and</font>

497
00:22:49,770 --> 00:22:56,080
they suspected<font color="#CCCCCC"> that this can be used</font><font color="#E5E5E5"> for</font>

498
00:22:52,900 --> 00:22:59,770
some security exploits and then<font color="#CCCCCC"> see born</font>

499
00:22:56,080 --> 00:23:02,560
in 2015<font color="#CCCCCC"> March 2015 showed that you</font><font color="#E5E5E5"> can</font>

500
00:22:59,770 --> 00:23:04,780
actually do that you can actually<font color="#E5E5E5"> gain</font>

501
00:23:02,560 --> 00:23:07,990
root privileges or kernel privileges on

502
00:23:04,780 --> 00:23:10,290
a system by<font color="#CCCCCC"> using the row hammer by</font>

503
00:23:07,990 --> 00:23:12,760
exploiting<font color="#CCCCCC"> the row hammer back and</font>

504
00:23:10,290 --> 00:23:14,860
therefore you need the non cached

505
00:23:12,760 --> 00:23:16,270
<font color="#E5E5E5">accesses and this is very similar to</font>

506
00:23:14,860 --> 00:23:18,399
flash<font color="#E5E5E5"> and reload</font><font color="#CCCCCC"> if you have a</font>

507
00:23:16,270 --> 00:23:21,010
vulnerable system and you do<font color="#CCCCCC"> a slash and</font>

508
00:23:18,400 --> 00:23:23,470
reload attack in a high<font color="#CCCCCC"> frequency you</font>

509
00:23:21,010 --> 00:23:26,920
can probably induce<font color="#E5E5E5"> bit flips without</font>

510
00:23:23,470 --> 00:23:29,500
trying to okay<font color="#E5E5E5"> so how does</font><font color="#CCCCCC"> row hammer</font>

511
00:23:26,920 --> 00:23:33,310
work<font color="#CCCCCC"> simulate in the flash and reload</font>

512
00:23:29,500 --> 00:23:36,730
attack we<font color="#E5E5E5"> will flash</font><font color="#CCCCCC"> data from the</font><font color="#E5E5E5"> cache</font>

513
00:23:33,310 --> 00:23:41,530
and then we will reload it and we do

514
00:23:36,730 --> 00:23:45,010
<font color="#E5E5E5">this</font><font color="#CCCCCC"> with two</font><font color="#E5E5E5"> different rows here so in</font>

515
00:23:41,530 --> 00:23:47,560
this case we have some blue<font color="#E5E5E5"> row in the</font>

516
00:23:45,010 --> 00:23:50,590
<font color="#E5E5E5">middle of the blue page in the middle is</font>

517
00:23:47,560 --> 00:23:53,889
in<font color="#E5E5E5"> a separate row than these other pages</font>

518
00:23:50,590 --> 00:23:56,439
<font color="#E5E5E5">that we</font><font color="#CCCCCC"> access and if we do</font><font color="#E5E5E5"> this often</font>

519
00:23:53,890 --> 00:24:01,840
<font color="#E5E5E5">enough then we will have the bit flip in</font>

520
00:23:56,440 --> 00:24:04,390
<font color="#E5E5E5">the middle row so how does row hammer</font>

521
00:24:01,840 --> 00:24:06,459
without CL flash work and the<font color="#CCCCCC"> idea is</font>

522
00:24:04,390 --> 00:24:09,700
that<font color="#E5E5E5"> we use prime and probe or evict and</font>

523
00:24:06,460 --> 00:24:13,600
reload rather than<font color="#CCCCCC"> Schlessinger instead</font>

524
00:24:09,700 --> 00:24:16,960
of flat<font color="#CCCCCC"> and reload and this will works</font>

525
00:24:13,600 --> 00:24:19,060
like this we just access a lot<font color="#E5E5E5"> of memory</font>

526
00:24:16,960 --> 00:24:20,320
<font color="#CCCCCC">locations until</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> target memory</font>

527
00:24:19,060 --> 00:24:22,840
location<font color="#E5E5E5"> is evicted</font>

528
00:24:20,320 --> 00:24:23,679
then we reload it and that's it<font color="#CCCCCC"> and then</font>

529
00:24:22,840 --> 00:24:26,290
we repeat

530
00:24:23,680 --> 00:24:28,150
for a while<font color="#E5E5E5"> and then we will observe a</font>

531
00:24:26,290 --> 00:24:32,200
bit flip<font color="#CCCCCC"> if the system is vulnerable of</font>

532
00:24:28,150 --> 00:24:33,340
course<font color="#E5E5E5"> so the challenges here are if if</font>

533
00:24:32,200 --> 00:24:35,950
we want to<font color="#E5E5E5"> do this in JavaScript</font>

534
00:24:33,340 --> 00:24:38,590
<font color="#E5E5E5">especially how do we get accurate</font>

535
00:24:35,950 --> 00:24:41,890
accurate timing<font color="#E5E5E5"> in JavaScript so</font>

536
00:24:38,590 --> 00:24:44,649
actually<font color="#E5E5E5"> that's not that much</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> trouble</font>

537
00:24:41,890 --> 00:24:48,330
because<font color="#CCCCCC"> JavaScript provides you very</font>

538
00:24:44,650 --> 00:24:50,860
accurate timing<font color="#CCCCCC"> so we can easily do that</font>

539
00:24:48,330 --> 00:24:54,429
<font color="#E5E5E5">how do we get physical addresses in</font>

540
00:24:50,860 --> 00:24:56,949
JavaScript we will also<font color="#E5E5E5"> see</font><font color="#CCCCCC"> that this</font><font color="#E5E5E5"> is</font>

541
00:24:54,430 --> 00:24:59,560
<font color="#CCCCCC">very easy</font><font color="#E5E5E5"> with physical addresses to</font>

542
00:24:56,950 --> 00:25:02,080
access this<font color="#E5E5E5"> has</font><font color="#CCCCCC"> already been solved</font>

543
00:24:59,560 --> 00:25:03,909
<font color="#CCCCCC">because we had this sliced reverse</font>

544
00:25:02,080 --> 00:25:07,960
<font color="#CCCCCC">engineering we have</font><font color="#E5E5E5"> this reverse</font>

545
00:25:03,910 --> 00:25:10,270
engineering<font color="#E5E5E5"> of the DRM mappings</font><font color="#CCCCCC"> so this</font>

546
00:25:07,960 --> 00:25:13,780
part I would<font color="#E5E5E5"> consider this as already</font>

547
00:25:10,270 --> 00:25:17,860
solved<font color="#E5E5E5"> this is not part of</font><font color="#CCCCCC"> our work but</font>

548
00:25:13,780 --> 00:25:20,170
<font color="#E5E5E5">our work focuses</font><font color="#CCCCCC"> on in which order to</font>

549
00:25:17,860 --> 00:25:25,300
access<font color="#E5E5E5"> them because</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> actually not</font>

550
00:25:20,170 --> 00:25:28,360
that<font color="#E5E5E5"> trivial so let's just speak a few</font>

551
00:25:25,300 --> 00:25:30,940
words about the<font color="#E5E5E5"> timing here in the</font>

552
00:25:28,360 --> 00:25:32,250
native code you would use our<font color="#CCCCCC"> DTC in</font>

553
00:25:30,940 --> 00:25:34,570
JavaScript you<font color="#CCCCCC"> can use</font>

554
00:25:32,250 --> 00:25:37,230
<font color="#E5E5E5">window.performance now and it's</font>

555
00:25:34,570 --> 00:25:39,700
sufficient<font color="#CCCCCC"> to get the attack working</font>

556
00:25:37,230 --> 00:25:43,720
<font color="#E5E5E5">physical addresses in JavaScript is also</font>

557
00:25:39,700 --> 00:25:46,450
easy because<font color="#CCCCCC"> we just before we worked on</font>

558
00:25:43,720 --> 00:25:48,010
roham rjs we did some page<font color="#E5E5E5"> these</font>

559
00:25:46,450 --> 00:25:49,960
application attacks in<font color="#CCCCCC"> JavaScript and</font>

560
00:25:48,010 --> 00:25:53,379
<font color="#E5E5E5">there we exploited that the Opera</font>

561
00:25:49,960 --> 00:25:55,480
operating system optimizes<font color="#E5E5E5"> the usage of</font>

562
00:25:53,380 --> 00:25:59,260
memory by using<font color="#E5E5E5"> two</font><font color="#CCCCCC"> mega byte pages</font>

563
00:25:55,480 --> 00:26:00,730
whenever possible<font color="#CCCCCC"> so in this case if we</font>

564
00:25:59,260 --> 00:26:03,760
allocate a large<font color="#E5E5E5"> array in JavaScript</font>

565
00:26:00,730 --> 00:26:07,030
<font color="#E5E5E5">then the last 21 bits of the physical</font>

566
00:26:03,760 --> 00:26:10,540
address<font color="#E5E5E5"> are identical to the last 21</font>

567
00:26:07,030 --> 00:26:12,370
<font color="#E5E5E5">bits of the virtual address</font><font color="#CCCCCC"> and also the</font>

568
00:26:10,540 --> 00:26:15,070
last 21<font color="#E5E5E5"> bits of the</font><font color="#CCCCCC"> JavaScript array</font>

569
00:26:12,370 --> 00:26:17,229
index so great<font color="#E5E5E5"> physical addresses for</font>

570
00:26:15,070 --> 00:26:20,679
<font color="#E5E5E5">Java JavaScript what can possibly go</font>

571
00:26:17,230 --> 00:26:23,170
<font color="#CCCCCC">wrong this</font><font color="#E5E5E5"> is also very interesting</font>

572
00:26:20,680 --> 00:26:28,690
<font color="#CCCCCC">because</font><font color="#E5E5E5"> erm</font><font color="#CCCCCC"> rows on on a</font><font color="#E5E5E5"> typical system</font>

573
00:26:23,170 --> 00:26:31,990
<font color="#E5E5E5">are 128</font><font color="#CCCCCC"> kilo bytes or 256 kilobytes</font>

574
00:26:28,690 --> 00:26:34,169
apart from each<font color="#E5E5E5"> other</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> within a</font><font color="#CCCCCC"> two</font>

575
00:26:31,990 --> 00:26:37,679
megabyte page you will have<font color="#CCCCCC"> several</font>

576
00:26:34,169 --> 00:26:41,730
DRM<font color="#CCCCCC"> rolls and just can hammer right away</font>

577
00:26:37,679 --> 00:26:45,619
on these<font color="#CCCCCC"> DRM rules</font><font color="#E5E5E5"> which addresses to</font>

578
00:26:41,730 --> 00:26:49,019
access yeah we use eviction we focus we

579
00:26:45,619 --> 00:26:51,269
use the slice mapping that has been

580
00:26:49,019 --> 00:26:56,489
<font color="#CCCCCC">reverse engineered by Clement in movies</font>

581
00:26:51,269 --> 00:26:58,440
and from<font color="#E5E5E5"> this we</font><font color="#CCCCCC"> know which</font><font color="#E5E5E5"> addresses</font>

582
00:26:56,489 --> 00:27:00,419
are congruent in the<font color="#E5E5E5"> cash and then we</font>

583
00:26:58,440 --> 00:27:02,580
can<font color="#E5E5E5"> evict them</font><font color="#CCCCCC"> from the</font><font color="#E5E5E5"> cash</font>

584
00:27:00,419 --> 00:27:04,980
the remaining challenge is<font color="#E5E5E5"> in which</font>

585
00:27:02,580 --> 00:27:07,139
order to access<font color="#E5E5E5"> them and if we look at</font>

586
00:27:04,980 --> 00:27:09,450
the replacement<font color="#E5E5E5"> policy on</font><font color="#CCCCCC"> older CPUs</font>

587
00:27:07,139 --> 00:27:12,508
like Sandy Bridge that's more than<font color="#E5E5E5"> five</font>

588
00:27:09,450 --> 00:27:16,859
years<font color="#CCCCCC"> old</font><font color="#E5E5E5"> now there would work like this</font>

589
00:27:12,509 --> 00:27:20,909
<font color="#CCCCCC">I they use an LRU replacement policy and</font>

590
00:27:16,859 --> 00:27:24,019
there we evict of the oldest entry first

591
00:27:20,909 --> 00:27:26,850
<font color="#CCCCCC">so if I just add a timestamp</font><font color="#E5E5E5"> to every</font>

592
00:27:24,019 --> 00:27:30,989
entry<font color="#CCCCCC"> in the cache set so</font><font color="#E5E5E5"> each way in</font>

593
00:27:26,850 --> 00:27:33,238
the cache set then we<font color="#CCCCCC"> have some then the</font>

594
00:27:30,989 --> 00:27:35,820
replacement<font color="#CCCCCC"> policy will when we</font><font color="#E5E5E5"> load</font>

595
00:27:33,239 --> 00:27:39,720
<font color="#CCCCCC">some data stored in</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> cache set and</font>

596
00:27:35,820 --> 00:27:44,309
update the timestamp<font color="#E5E5E5"> and always the</font>

597
00:27:39,720 --> 00:27:46,830
<font color="#CCCCCC">youngest</font><font color="#E5E5E5"> the the oldest way is replaced</font>

598
00:27:44,309 --> 00:27:51,570
<font color="#E5E5E5">and then we have the new timestamp here</font>

599
00:27:46,830 --> 00:27:55,470
and finally the targeted cache way is

600
00:27:51,570 --> 00:27:57,809
also<font color="#E5E5E5"> replaced so the</font><font color="#CCCCCC"> replacement policy</font>

601
00:27:55,470 --> 00:28:02,249
<font color="#E5E5E5">on more recent CPUs like Ivybridge</font>

602
00:27:57,809 --> 00:28:06,389
<font color="#E5E5E5">or newer and also on arm CPUs or</font><font color="#CCCCCC"> AMD</font>

603
00:28:02,249 --> 00:28:09,659
<font color="#E5E5E5">CPUs they work differently so they don't</font>

604
00:28:06,389 --> 00:28:11,488
<font color="#E5E5E5">use LRU and if you try allow your</font>

605
00:28:09,659 --> 00:28:16,350
replacement<font color="#E5E5E5"> it will look something like</font>

606
00:28:11,489 --> 00:28:19,289
this yeah<font color="#CCCCCC"> okay this</font><font color="#E5E5E5"> was not</font><font color="#CCCCCC"> very</font>

607
00:28:16,350 --> 00:28:22,199
successful<font color="#CCCCCC"> and we tried this on</font><font color="#E5E5E5"> Haswell</font>

608
00:28:19,289 --> 00:28:24,989
<font color="#E5E5E5">and we had a success rate of 75 percent</font>

609
00:28:22,200 --> 00:28:27,869
<font color="#CCCCCC">and that's</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> sufficient to</font><font color="#E5E5E5"> do row</font>

610
00:28:24,989 --> 00:28:29,879
hammering<font color="#E5E5E5"> if you only succeed in 75% of</font>

611
00:28:27,869 --> 00:28:32,340
the cases<font color="#E5E5E5"> and you have to do something</font>

612
00:28:29,879 --> 00:28:35,699
<font color="#E5E5E5">like 2</font><font color="#CCCCCC"> million in victims in a very high</font>

613
00:28:32,340 --> 00:28:39,059
frequency<font color="#CCCCCC"> 75% will ruin the attack it</font>

614
00:28:35,700 --> 00:28:40,859
doesn't work so we can just do more

615
00:28:39,059 --> 00:28:42,809
excesses then we will get a higher

616
00:28:40,859 --> 00:28:46,369
success rate but actually this will be

617
00:28:42,809 --> 00:28:46,369
too slow

618
00:28:46,690 --> 00:28:52,539
when we started working<font color="#E5E5E5"> on this we we we</font>

619
00:28:49,720 --> 00:28:54,700
crafted these<font color="#E5E5E5"> eviction patterns by hand</font>

620
00:28:52,539 --> 00:28:57,099
so here you see address 1 address<font color="#E5E5E5"> to</font>

621
00:28:54,700 --> 00:28:59,649
address<font color="#E5E5E5"> address 3 and the black box</font>

622
00:28:57,099 --> 00:29:04,149
marks that we access<font color="#E5E5E5"> this address in at</font>

623
00:28:59,649 --> 00:29:06,639
this point in time<font color="#E5E5E5"> and if you represent</font>

624
00:29:04,149 --> 00:29:10,478
this as a sequence of<font color="#E5E5E5"> numbers</font><font color="#CCCCCC"> it would</font>

625
00:29:06,639 --> 00:29:12,998
<font color="#CCCCCC">look like this so 1 2 1 2 2</font><font color="#E5E5E5"> 3</font><font color="#CCCCCC"> 2 3 3 4 3</font>

626
00:29:10,479 --> 00:29:17,799
<font color="#CCCCCC">4 and so on and this</font><font color="#E5E5E5"> can be a very long</font>

627
00:29:12,999 --> 00:29:19,929
sequence<font color="#E5E5E5"> and then we found that and we</font>

628
00:29:17,799 --> 00:29:23,080
observe different properties of<font color="#CCCCCC"> these</font>

629
00:29:19,929 --> 00:29:25,179
<font color="#E5E5E5">addresses</font><font color="#CCCCCC"> too to go step further first</font>

630
00:29:23,080 --> 00:29:27,359
<font color="#E5E5E5">all the</font><font color="#CCCCCC"> addresses that we are working</font><font color="#E5E5E5"> on</font>

631
00:29:25,179 --> 00:29:29,529
<font color="#E5E5E5">they are congruent</font><font color="#CCCCCC"> so they are</font>

632
00:29:27,359 --> 00:29:31,299
<font color="#CCCCCC">indistinguishable in</font><font color="#E5E5E5"> terms of the</font>

633
00:29:29,529 --> 00:29:35,649
eviction strategy we don't care whether

634
00:29:31,299 --> 00:29:38,918
<font color="#CCCCCC">we label an address</font><font color="#E5E5E5"> 1 or</font><font color="#CCCCCC"> 2 or 3 as long</font>

635
00:29:35,649 --> 00:29:41,228
as the<font color="#E5E5E5"> strategy is unique</font><font color="#CCCCCC"> it doesn't</font>

636
00:29:38,919 --> 00:29:44,950
make a<font color="#CCCCCC"> difference so we can we can give</font>

637
00:29:41,229 --> 00:29:49,779
any<font color="#CCCCCC"> number any number into</font><font color="#E5E5E5"> sequence of</font>

638
00:29:44,950 --> 00:29:53,229
<font color="#CCCCCC">accesses</font><font color="#E5E5E5"> it just has to be unique so</font><font color="#CCCCCC"> if</font>

639
00:29:49,779 --> 00:29:59,979
you look<font color="#CCCCCC"> for instance</font><font color="#E5E5E5"> at at this</font><font color="#CCCCCC"> pattern</font>

640
00:29:53,229 --> 00:30:01,989
<font color="#E5E5E5">here 2 5 4 6 3 1</font><font color="#CCCCCC"> & 2 5</font><font color="#E5E5E5"> 6 4</font><font color="#CCCCCC"> 1 3 and so on</font>

641
00:29:59,979 --> 00:30:04,929
they are<font color="#E5E5E5"> all equivalent we can just</font>

642
00:30:01,989 --> 00:30:06,190
<font color="#CCCCCC">label them 1 2 3 4 5 6</font><font color="#E5E5E5"> we don't care</font>

643
00:30:04,929 --> 00:30:08,499
about the labeling<font color="#E5E5E5"> of</font><font color="#CCCCCC"> the addresses</font>

644
00:30:06,190 --> 00:30:14,080
<font color="#CCCCCC">that's that's all I want to say to this</font>

645
00:30:08,499 --> 00:30:16,299
<font color="#E5E5E5">point so we can do</font><font color="#CCCCCC"> two things now we can</font>

646
00:30:14,080 --> 00:30:19,210
add more different addresses so for

647
00:30:16,299 --> 00:30:21,309
instance at address 7 8 9 and<font color="#CCCCCC"> so on</font><font color="#E5E5E5"> that</font>

648
00:30:19,210 --> 00:30:23,229
will increase the or it can increase<font color="#E5E5E5"> the</font>

649
00:30:21,309 --> 00:30:25,960
eviction rate<font color="#E5E5E5"> or we can add multiple</font>

650
00:30:23,229 --> 00:30:28,960
accesses<font color="#CCCCCC"> to one address and there we</font>

651
00:30:25,960 --> 00:30:36,999
observe that<font color="#CCCCCC"> this also can increase</font><font color="#E5E5E5"> the</font>

652
00:30:28,960 --> 00:30:40,389
eviction rate so<font color="#E5E5E5"> the sequences that we</font>

653
00:30:36,999 --> 00:30:42,999
generated they often had repeating sub

654
00:30:40,389 --> 00:30:46,359
sequences<font color="#E5E5E5"> and they are we decided that</font>

655
00:30:42,999 --> 00:30:49,080
<font color="#E5E5E5">we could represent the sequences in in</font>

656
00:30:46,359 --> 00:30:54,699
form of a loop so I wrote this loop and

657
00:30:49,080 --> 00:30:57,309
it will just iterate over the different

658
00:30:54,700 --> 00:30:58,990
addresses in the inner loop<font color="#E5E5E5"> and access</font>

659
00:30:57,309 --> 00:31:01,840
these many addresses

660
00:30:58,990 --> 00:31:04,900
and then it will perform<font color="#E5E5E5"> see repetitions</font>

661
00:31:01,840 --> 00:31:07,149
of<font color="#E5E5E5"> this inner loop and then we have a</font>

662
00:31:04,900 --> 00:31:09,010
total set size so this is a number of

663
00:31:07,150 --> 00:31:13,330
different<font color="#CCCCCC"> addresses that</font><font color="#E5E5E5"> we actually</font>

664
00:31:09,010 --> 00:31:15,940
access<font color="#E5E5E5"> that's here and then an overlap</font>

665
00:31:13,330 --> 00:31:19,090
parameter so for instance if we<font color="#E5E5E5"> have 1 2</font>

666
00:31:15,940 --> 00:31:20,980
1 2<font color="#CCCCCC"> &</font><font color="#E5E5E5"> 2 3 2 3 then the overlap parameter</font>

667
00:31:19,090 --> 00:31:25,419
is 1<font color="#E5E5E5"> but we could also do something like</font>

668
00:31:20,980 --> 00:31:29,620
1 2 1 2<font color="#E5E5E5"> 3 4 3 4 then the overlap</font>

669
00:31:25,420 --> 00:31:31,809
parameter would be 2 and then we<font color="#E5E5E5"> can</font>

670
00:31:29,620 --> 00:31:35,678
write<font color="#E5E5E5"> eviction strategies in a compact</font>

671
00:31:31,809 --> 00:31:38,410
<font color="#E5E5E5">form by just</font><font color="#CCCCCC"> we just have the P here to</font>

672
00:31:35,679 --> 00:31:40,390
mark it as<font color="#E5E5E5"> an eviction strategy or an</font>

673
00:31:38,410 --> 00:31:43,660
eviction pattern and then<font color="#E5E5E5"> the different</font>

674
00:31:40,390 --> 00:31:46,690
parameters<font color="#CCCCCC"> of the strategy so for</font>

675
00:31:43,660 --> 00:31:49,809
instance if you<font color="#CCCCCC"> look at the pattern 1 1</font>

676
00:31:46,690 --> 00:31:53,470
1 4<font color="#E5E5E5"> it would look</font><font color="#CCCCCC"> like a look like</font><font color="#E5E5E5"> this</font>

677
00:31:49,809 --> 00:31:57,970
1 2<font color="#CCCCCC"> 3</font><font color="#E5E5E5"> 4 and if we have 2 2 1 4 it would</font>

678
00:31:53,470 --> 00:32:01,870
like look<font color="#E5E5E5"> like this 1</font><font color="#CCCCCC"> 2 1 2 2 3 2 3 3 4</font>

679
00:31:57,970 --> 00:32:04,929
3<font color="#CCCCCC"> 4 and then we generate</font><font color="#E5E5E5"> a lot</font><font color="#CCCCCC"> of</font>

680
00:32:01,870 --> 00:32:08,110
strategies based on<font color="#E5E5E5"> this scheme so in</font>

681
00:32:04,929 --> 00:32:11,590
total we evaluated<font color="#E5E5E5"> more than</font><font color="#CCCCCC"> 10000</font>

682
00:32:08,110 --> 00:32:14,979
strategies and here I have<font color="#CCCCCC"> some examples</font>

683
00:32:11,590 --> 00:32:16,600
<font color="#CCCCCC">that</font><font color="#E5E5E5"> are very interesting or at least I</font>

684
00:32:14,980 --> 00:32:21,460
find them very interesting<font color="#E5E5E5"> so here we</font>

685
00:32:16,600 --> 00:32:24,219
have P 1 1<font color="#CCCCCC"> 117</font><font color="#E5E5E5"> that has been suggested</font>

686
00:32:21,460 --> 00:32:27,580
<font color="#E5E5E5">and and also been used in</font><font color="#CCCCCC"> previous work</font>

687
00:32:24,220 --> 00:32:32,380
and<font color="#E5E5E5"> we also start with this and</font><font color="#CCCCCC"> then</font><font color="#E5E5E5"> we</font>

688
00:32:27,580 --> 00:32:34,270
have<font color="#CCCCCC"> P 1 1 120</font><font color="#E5E5E5"> so I already told you</font>

689
00:32:32,380 --> 00:32:38,500
<font color="#CCCCCC">that this one has an eviction rate of</font>

690
00:32:34,270 --> 00:32:40,990
approximately<font color="#CCCCCC"> 75%</font><font color="#E5E5E5"> do you expect the</font>

691
00:32:38,500 --> 00:32:43,660
eviction rate for the for the second<font color="#E5E5E5"> one</font>

692
00:32:40,990 --> 00:32:48,370
to be<font color="#E5E5E5"> higher or lower higher</font><font color="#CCCCCC"> whose for</font>

693
00:32:43,660 --> 00:32:50,590
higher okay<font color="#E5E5E5"> whose for lower some some</font>

694
00:32:48,370 --> 00:32:52,510
<font color="#E5E5E5">are for lower</font><font color="#CCCCCC"> okay actually I do too I</font>

695
00:32:50,590 --> 00:32:54,280
do three more excesses here that are

696
00:32:52,510 --> 00:32:56,920
<font color="#E5E5E5">congruent that go to the same cache set</font>

697
00:32:54,280 --> 00:33:00,220
so the eviction<font color="#E5E5E5"> rate should</font><font color="#CCCCCC"> be higher</font>

698
00:32:56,920 --> 00:33:02,740
here<font color="#CCCCCC"> and if</font><font color="#E5E5E5"> we look at the eviction rate</font>

699
00:33:00,220 --> 00:33:04,090
it is actually much higher so we here we

700
00:33:02,740 --> 00:33:06,250
have an eviction rate of<font color="#CCCCCC"> ninety-nine</font>

701
00:33:04,090 --> 00:33:11,678
point eight two percent<font color="#CCCCCC"> and that would</font>

702
00:33:06,250 --> 00:33:12,669
<font color="#E5E5E5">be high enough for</font><font color="#CCCCCC"> Oh hammer if we look</font>

703
00:33:11,679 --> 00:33:15,190
at the

704
00:33:12,669 --> 00:33:18,970
execution time of<font color="#E5E5E5"> this so I do this like</font>

705
00:33:15,190 --> 00:33:21,369
<font color="#E5E5E5">20 million times in a loop</font><font color="#CCCCCC"> this excess</font>

706
00:33:18,970 --> 00:33:27,190
pattern and this excess pattern which

707
00:33:21,369 --> 00:33:29,408
one will<font color="#E5E5E5"> be faster on</font><font color="#CCCCCC"> average the first</font>

708
00:33:27,190 --> 00:33:32,619
one<font color="#E5E5E5"> because it does</font><font color="#CCCCCC"> fewer memory</font>

709
00:33:29,409 --> 00:33:35,379
accesses<font color="#CCCCCC"> so its 307 nanoseconds</font><font color="#E5E5E5"> and the</font>

710
00:33:32,619 --> 00:33:39,009
second one is 934 nanoseconds on my

711
00:33:35,379 --> 00:33:41,408
system<font color="#CCCCCC"> that's very bad because 934</font>

712
00:33:39,009 --> 00:33:43,299
nanoseconds is way too slow for<font color="#CCCCCC"> a row</font>

713
00:33:41,409 --> 00:33:45,639
<font color="#E5E5E5">hammer now if we look at different</font>

714
00:33:43,299 --> 00:33:49,389
<font color="#CCCCCC">strategies for instance this one here I</font>

715
00:33:45,639 --> 00:33:52,719
do this<font color="#E5E5E5"> this first parameter</font><font color="#CCCCCC"> this means</font>

716
00:33:49,389 --> 00:33:53,070
that<font color="#E5E5E5"> I do the one two two three</font><font color="#CCCCCC"> and so</font>

717
00:33:52,720 --> 00:33:57,609
on

718
00:33:53,070 --> 00:34:00,039
so here we have<font color="#E5E5E5"> 34 excesses and the</font>

719
00:33:57,609 --> 00:34:02,559
eviction rate goes up<font color="#CCCCCC"> ninety-nine point</font>

720
00:34:00,039 --> 00:34:05,109
eight six percent that's<font color="#E5E5E5"> high enough</font><font color="#CCCCCC"> for</font>

721
00:34:02,559 --> 00:34:07,418
<font color="#CCCCCC">Oh hammer</font><font color="#E5E5E5"> now for the execution time</font>

722
00:34:05,109 --> 00:34:09,699
<font color="#E5E5E5">would you expect the execution time of</font>

723
00:34:07,419 --> 00:34:14,290
<font color="#E5E5E5">this loop</font><font color="#CCCCCC"> it does double the amount of</font>

724
00:34:09,699 --> 00:34:18,279
excesses<font color="#E5E5E5"> would it be higher or lower</font><font color="#CCCCCC"> its</font>

725
00:34:14,290 --> 00:34:21,520
lower so 191 cycles so optimizing

726
00:34:18,280 --> 00:34:24,669
programs<font color="#E5E5E5"> by adding memory accesses could</font>

727
00:34:21,520 --> 00:34:26,349
work so here works for<font color="#CCCCCC"> a row hammer and</font>

728
00:34:24,668 --> 00:34:28,449
I can<font color="#CCCCCC"> actually use</font><font color="#E5E5E5"> this to do the aroma</font>

729
00:34:26,349 --> 00:34:31,000
<font color="#CCCCCC">tech and if I for instance</font><font color="#E5E5E5"> look at this</font>

730
00:34:28,449 --> 00:34:34,000
one this<font color="#CCCCCC"> strategy here it does</font><font color="#E5E5E5"> 64</font>

731
00:34:31,000 --> 00:34:37,540
excesses<font color="#E5E5E5"> and the execution time is</font><font color="#CCCCCC"> even</font>

732
00:34:34,000 --> 00:34:39,369
lower<font color="#E5E5E5"> than for the first one so we just</font>

733
00:34:37,540 --> 00:34:42,129
measured the<font color="#CCCCCC"> average execution</font><font color="#E5E5E5"> time and</font>

734
00:34:39,369 --> 00:34:45,280
<font color="#CCCCCC">it</font><font color="#E5E5E5"> gets lower by adding memory accesses</font>

735
00:34:42,129 --> 00:34:47,319
<font color="#CCCCCC">one review of</font><font color="#E5E5E5"> our paper said yeah that's</font>

736
00:34:45,280 --> 00:34:50,079
that's that cannot work<font color="#CCCCCC"> you</font>

737
00:34:47,319 --> 00:34:55,058
<font color="#CCCCCC">made a mistake there but you can measure</font>

738
00:34:50,079 --> 00:34:59,380
that so replacement policies on modern

739
00:34:55,059 --> 00:35:01,960
<font color="#E5E5E5">interest CPUs so we just have seen that</font>

740
00:34:59,380 --> 00:35:06,369
LRU doesn't work and<font color="#E5E5E5"> that</font><font color="#CCCCCC"> you have</font><font color="#E5E5E5"> to</font>

741
00:35:01,960 --> 00:35:08,079
access<font color="#E5E5E5"> addresses multiple</font><font color="#CCCCCC"> times so in</font>

742
00:35:06,369 --> 00:35:11,619
which order to access<font color="#E5E5E5"> them</font><font color="#CCCCCC"> we solve that</font>

743
00:35:08,079 --> 00:35:13,750
<font color="#E5E5E5">and if we look at the bit flips that we</font>

744
00:35:11,619 --> 00:35:15,640
can achieve with<font color="#CCCCCC"> that then</font><font color="#E5E5E5"> we see that</font>

745
00:35:13,750 --> 00:35:18,309
<font color="#CCCCCC">okay in JavaScript we have a bit slower</font>

746
00:35:15,640 --> 00:35:21,819
but in native code we can trigger bit

747
00:35:18,309 --> 00:35:25,830
flips<font color="#E5E5E5"> using eviction</font><font color="#CCCCCC"> if we can do this</font>

748
00:35:21,819 --> 00:35:27,900
with CL<font color="#CCCCCC"> /</font><font color="#E5E5E5"> so systems the</font>

749
00:35:25,830 --> 00:35:31,580
<font color="#CCCCCC">our vulnerability or hammer with</font><font color="#E5E5E5"> CL</font>

750
00:35:27,900 --> 00:35:34,920
<font color="#CCCCCC">flash should be considered vulnerable</font><font color="#E5E5E5"> to</font>

751
00:35:31,580 --> 00:35:37,049
<font color="#E5E5E5">RO hammer</font><font color="#CCCCCC"> without CSS as well</font><font color="#E5E5E5"> we also</font>

752
00:35:34,920 --> 00:35:38,790
tried it on arm<font color="#CCCCCC"> so</font><font color="#E5E5E5"> here is a</font><font color="#CCCCCC"> regular</font>

753
00:35:37,050 --> 00:35:43,080
smartphone<font color="#CCCCCC"> but we attached the cooler to</font>

754
00:35:38,790 --> 00:35:46,020
it so<font color="#CCCCCC"> that</font><font color="#E5E5E5"> it doesn't overheat</font><font color="#CCCCCC"> we also</font>

755
00:35:43,080 --> 00:35:51,360
evaluated<font color="#E5E5E5"> several thousand strategies</font>

756
00:35:46,020 --> 00:35:54,300
there but we<font color="#E5E5E5"> found no bit flips so I'm I</font>

757
00:35:51,360 --> 00:35:57,960
take<font color="#E5E5E5"> three more minutes I think that</font>

758
00:35:54,300 --> 00:36:00,660
should<font color="#CCCCCC"> be just in time right so the</font>

759
00:35:57,960 --> 00:36:02,520
operating system groups pages and page

760
00:36:00,660 --> 00:36:03,960
tables<font color="#CCCCCC"> into</font><font color="#E5E5E5"> two megabyte frames and</font>

761
00:36:02,520 --> 00:36:07,200
that's<font color="#E5E5E5"> actually bad for exploiting</font>

762
00:36:03,960 --> 00:36:09,390
<font color="#E5E5E5">because we said we want to trigger a bit</font>

763
00:36:07,200 --> 00:36:11,520
flip possibly in a page table because<font color="#CCCCCC"> we</font>

764
00:36:09,390 --> 00:36:13,259
can exploit that but actually<font color="#CCCCCC"> the</font>

765
00:36:11,520 --> 00:36:15,390
operating system prevents that<font color="#E5E5E5"> by</font>

766
00:36:13,260 --> 00:36:18,480
<font color="#E5E5E5">grouping pages and page tables into two</font>

767
00:36:15,390 --> 00:36:21,629
megabyte frames the operating system

768
00:36:18,480 --> 00:36:24,600
just deviates from this<font color="#CCCCCC"> strategy if it's</font>

769
00:36:21,630 --> 00:36:26,370
<font color="#E5E5E5">almost out of memory and it's very hard</font>

770
00:36:24,600 --> 00:36:29,339
to<font color="#E5E5E5"> get there without crashing the</font>

771
00:36:26,370 --> 00:36:32,100
<font color="#E5E5E5">browser so we introduced a new technique</font>

772
00:36:29,340 --> 00:36:34,430
to<font color="#E5E5E5"> do that actually it has</font><font color="#CCCCCC"> already</font><font color="#E5E5E5"> been</font>

773
00:36:32,100 --> 00:36:37,470
described<font color="#E5E5E5"> in previous work but not</font>

774
00:36:34,430 --> 00:36:39,649
studied in detail<font color="#E5E5E5"> and we did some tests</font>

775
00:36:37,470 --> 00:36:43,319
on<font color="#CCCCCC"> that and we could even</font><font color="#E5E5E5"> use it</font><font color="#CCCCCC"> to</font>

776
00:36:39,650 --> 00:36:48,330
induce bit flips on a<font color="#E5E5E5"> ddr4 system</font>

777
00:36:43,320 --> 00:36:50,730
default configured so amplified single

778
00:36:48,330 --> 00:36:55,080
sided hammering works like that<font color="#E5E5E5"> we again</font>

779
00:36:50,730 --> 00:37:00,030
<font color="#CCCCCC">evict the data from the</font><font color="#E5E5E5"> cache and this</font>

780
00:36:55,080 --> 00:37:02,400
time we don't have<font color="#E5E5E5"> the</font><font color="#CCCCCC"> the target memory</font>

781
00:37:00,030 --> 00:37:03,920
<font color="#E5E5E5">location between</font><font color="#CCCCCC"> the two memory</font>

782
00:37:02,400 --> 00:37:07,860
locations that we<font color="#CCCCCC"> access but</font><font color="#E5E5E5"> it's</font>

783
00:37:03,920 --> 00:37:10,580
adjacent to<font color="#CCCCCC"> it and here I have drawn a</font>

784
00:37:07,860 --> 00:37:13,500
dashed<font color="#CCCCCC"> line to</font><font color="#E5E5E5"> mark the two megabyte</font>

785
00:37:10,580 --> 00:37:16,529
<font color="#CCCCCC">page frame borders so we have our two</font>

786
00:37:13,500 --> 00:37:19,320
<font color="#E5E5E5">rows that</font><font color="#CCCCCC"> are directly at the edge of a</font>

787
00:37:16,530 --> 00:37:22,140
<font color="#CCCCCC">two megabyte page and if we do</font><font color="#E5E5E5"> that then</font>

788
00:37:19,320 --> 00:37:25,920
we<font color="#CCCCCC"> will observe a bit flip here and that</font>

789
00:37:22,140 --> 00:37:29,339
even works on ddr4<font color="#E5E5E5"> and if we use this</font>

790
00:37:25,920 --> 00:37:31,380
then<font color="#CCCCCC"> we can we don't need in near</font><font color="#E5E5E5"> out of</font>

791
00:37:29,340 --> 00:37:33,510
memory situation and we can try this

792
00:37:31,380 --> 00:37:36,090
until the memory mappings have changed

793
00:37:33,510 --> 00:37:38,580
and then<font color="#CCCCCC"> we have a bit flip in our own</font>

794
00:37:36,090 --> 00:37:41,280
page tables and if we try this<font color="#CCCCCC"> until</font>

795
00:37:38,580 --> 00:37:43,290
we find that the new mapping<font color="#E5E5E5"> is one of</font>

796
00:37:41,280 --> 00:37:46,890
our own page tables then we have full

797
00:37:43,290 --> 00:37:48,930
access to<font color="#CCCCCC"> the physical memory so the</font>

798
00:37:46,890 --> 00:37:53,160
conclusion is<font color="#E5E5E5"> that</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> can do</font><font color="#CCCCCC"> cat</font>

799
00:37:48,930 --> 00:37:54,930
<font color="#E5E5E5">addiction instead of CL</font><font color="#CCCCCC"> flush then we</font>

800
00:37:53,160 --> 00:37:56,640
are independent<font color="#CCCCCC"> of programming language</font>

801
00:37:54,930 --> 00:37:58,290
<font color="#E5E5E5">and available instructions we can even</font>

802
00:37:56,640 --> 00:38:02,129
do that in<font color="#CCCCCC"> JavaScript and we</font>

803
00:37:58,290 --> 00:38:06,000
demonstrated<font color="#E5E5E5"> probably the first</font><font color="#CCCCCC"> hardware</font>

804
00:38:02,130 --> 00:38:09,300
<font color="#CCCCCC">fold attack</font><font color="#E5E5E5"> through</font><font color="#CCCCCC"> website</font><font color="#E5E5E5"> using</font>

805
00:38:06,000 --> 00:38:11,670
javascript<font color="#CCCCCC"> and that's very nice because</font>

806
00:38:09,300 --> 00:38:15,960
you<font color="#CCCCCC"> can</font><font color="#E5E5E5"> just put</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> website online and</font>

807
00:38:11,670 --> 00:38:18,900
see which systems on which<font color="#E5E5E5"> systems it</font>

808
00:38:15,960 --> 00:38:21,900
works<font color="#CCCCCC"> on this laptop it works on this</font>

809
00:38:18,900 --> 00:38:25,680
laptop<font color="#E5E5E5"> we verified that</font><font color="#CCCCCC"> we can get root</font>

810
00:38:21,900 --> 00:38:28,100
privileges<font color="#E5E5E5"> for web apps so thank you for</font>

811
00:38:25,680 --> 00:38:28,100
<font color="#E5E5E5">your attention</font>

