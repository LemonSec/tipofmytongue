1
00:00:01,040 --> 00:00:08,009
[Music]

2
00:00:11,059 --> 00:00:14,059
thank you

3
00:00:17,220 --> 00:00:18,900
so we in the last talk we heard about

4
00:00:18,900 --> 00:00:21,000
that it was a bit academic or something

5
00:00:21,000 --> 00:00:23,220
this is going to be much more academic

6
00:00:23,220 --> 00:00:24,539
we're going to be talking about things

7
00:00:24,539 --> 00:00:26,160
that don't exist

8
00:00:26,160 --> 00:00:28,380
yet maybe ever yeah

9
00:00:28,380 --> 00:00:31,320
so my name is Lucas Kino I'm a PhD

10
00:00:31,320 --> 00:00:33,719
student at Gratz University of

11
00:00:33,719 --> 00:00:36,420
Technology with him

12
00:00:36,420 --> 00:00:39,239
oh with me oh yeah yeah I'm Daniel Cruz

13
00:00:39,239 --> 00:00:41,520
and I also have been at rusek before

14
00:00:41,520 --> 00:00:44,280
actually I also I think I only missed

15
00:00:44,280 --> 00:00:46,620
one that was in person

16
00:00:46,620 --> 00:00:48,960
um and some of the slides you might

17
00:00:48,960 --> 00:00:50,820
remember them from my first talk at

18
00:00:50,820 --> 00:00:52,800
wusec because they are also talked about

19
00:00:52,800 --> 00:00:56,579
caches and cash attacks and for the

20
00:00:56,579 --> 00:00:58,800
basics there will be some parts that are

21
00:00:58,800 --> 00:01:01,320
similar so I should start right away I

22
00:01:01,320 --> 00:01:02,520
think sure

23
00:01:02,520 --> 00:01:05,400
um CPU caches are a shared resource

24
00:01:05,400 --> 00:01:07,439
caches they exist in all our computers

25
00:01:07,439 --> 00:01:10,740
and the problem is if we have a cache

26
00:01:10,740 --> 00:01:12,659
you probably know this from the movie

27
00:01:12,659 --> 00:01:15,000
Inception like this this sentence don't

28
00:01:15,000 --> 00:01:16,860
think of elephants

29
00:01:16,860 --> 00:01:20,040
now I pulled the picture of an elephant

30
00:01:20,040 --> 00:01:22,799
into many heads here in this room and

31
00:01:22,799 --> 00:01:25,680
this is caching now it's right in your

32
00:01:25,680 --> 00:01:27,960
readily available in your brain and for

33
00:01:27,960 --> 00:01:30,659
a computer this also exists if I

34
00:01:30,659 --> 00:01:33,900
um send the request to memory then it

35
00:01:33,900 --> 00:01:36,540
will be pulled into the caches and it

36
00:01:36,540 --> 00:01:38,340
will be readily available for further

37
00:01:38,340 --> 00:01:40,560
operations

38
00:01:40,560 --> 00:01:43,020
and this is a side Channel because now I

39
00:01:43,020 --> 00:01:46,259
know that when I access it again it will

40
00:01:46,259 --> 00:01:50,479
be there right away much faster

41
00:01:50,479 --> 00:01:53,640
channels are very powerful because they

42
00:01:53,640 --> 00:01:56,460
always are there when you access memory

43
00:01:56,460 --> 00:01:59,759
and when we work with data Maybe secret

44
00:01:59,759 --> 00:02:03,060
data we always work with memory because

45
00:02:03,060 --> 00:02:06,420
we can't fit all of that into registers

46
00:02:06,420 --> 00:02:08,580
so cache side channels are simple they

47
00:02:08,580 --> 00:02:10,318
are fast they are reliable we have seen

48
00:02:10,318 --> 00:02:13,140
many attacks there for instance cross VM

49
00:02:13,140 --> 00:02:15,959
key recoveries we have seen Specter and

50
00:02:15,959 --> 00:02:19,319
melt on that also rely on cash attacks

51
00:02:19,319 --> 00:02:22,140
internally zombie load maybe

52
00:02:22,140 --> 00:02:25,800
um actually need cash attacks well the

53
00:02:25,800 --> 00:02:28,280
the thing is Spectrum meltdown are

54
00:02:28,280 --> 00:02:31,319
microarchitectural effects and they they

55
00:02:31,319 --> 00:02:32,819
exploit something called transient

56
00:02:32,819 --> 00:02:34,920
execution and it's difficult to get

57
00:02:34,920 --> 00:02:37,140
information from this transient

58
00:02:37,140 --> 00:02:40,560
execution window to the normal world so

59
00:02:40,560 --> 00:02:43,080
the cache is just really nice for

60
00:02:43,080 --> 00:02:45,780
attacking things they are a nice side

61
00:02:45,780 --> 00:02:47,700
channel that you can use there but you

62
00:02:47,700 --> 00:02:49,140
could probably use other techniques as

63
00:02:49,140 --> 00:02:51,599
well okay so we'll start by trying to

64
00:02:51,599 --> 00:02:54,300
get rid of that Channel first

65
00:02:54,300 --> 00:02:56,220
so in this talk we will first give an

66
00:02:56,220 --> 00:02:58,200
overview of existing designs some

67
00:02:58,200 --> 00:02:59,940
existing designs not all of them right

68
00:02:59,940 --> 00:03:02,400
because that would be too much some

69
00:03:02,400 --> 00:03:04,680
traditional caches we will categorize

70
00:03:04,680 --> 00:03:07,920
them broadly and then examine some of

71
00:03:07,920 --> 00:03:10,920
these designs more specifically

72
00:03:10,920 --> 00:03:12,239
yeah and then we will also give an

73
00:03:12,239 --> 00:03:14,940
outlook on what we expect to happen in

74
00:03:14,940 --> 00:03:16,800
the future including some of our own

75
00:03:16,800 --> 00:03:17,819
work

76
00:03:17,819 --> 00:03:20,459
so how do modern caches work as I said

77
00:03:20,459 --> 00:03:24,959
we access a memory location like here we

78
00:03:24,959 --> 00:03:26,760
first get a cache Miss because it's not

79
00:03:26,760 --> 00:03:28,980
in the cache we pull it from the dram

80
00:03:28,980 --> 00:03:31,019
back into the cache now it's in the

81
00:03:31,019 --> 00:03:33,120
cache the second time we access it we

82
00:03:33,120 --> 00:03:35,459
get a cash hit so first the cash miss

83
00:03:35,459 --> 00:03:37,620
that is slow because it goes to dram

84
00:03:37,620 --> 00:03:40,379
second one a cache hit that's no dram

85
00:03:40,379 --> 00:03:42,959
access that's much faster and you can

86
00:03:42,959 --> 00:03:45,120
see this in timing and this is the part

87
00:03:45,120 --> 00:03:47,159
that I really like if you give this to a

88
00:03:47,159 --> 00:03:49,200
bachelor student an undergraduate

89
00:03:49,200 --> 00:03:50,879
student and tell them okay please

90
00:03:50,879 --> 00:03:53,760
distinguish cash hits and cache misses

91
00:03:53,760 --> 00:03:55,860
they don't even need the statistics

92
00:03:55,860 --> 00:03:57,540
classes for that because here are the

93
00:03:57,540 --> 00:04:00,000
cash hits here are the cash misses there

94
00:04:00,000 --> 00:04:02,459
are no cash misses below I said I would

95
00:04:02,459 --> 00:04:05,400
say 175 that's a simple threshold

96
00:04:05,400 --> 00:04:07,500
everyone can do that for the fraction

97
00:04:07,500 --> 00:04:09,480
there and say oh those were the cash

98
00:04:09,480 --> 00:04:11,640
hits here are the cash misses and this

99
00:04:11,640 --> 00:04:12,540
is

100
00:04:12,540 --> 00:04:14,819
um yeah 10 to the same you can see that

101
00:04:14,819 --> 00:04:17,880
really most of the cases are around

102
00:04:17,880 --> 00:04:19,620
those timing blocks

103
00:04:19,620 --> 00:04:22,139
how does the cache work this is a set

104
00:04:22,139 --> 00:04:25,080
associative cache design you have the

105
00:04:25,080 --> 00:04:27,060
memory address here you have some some

106
00:04:27,060 --> 00:04:29,759
usage of the bits the lowest B bits for

107
00:04:29,759 --> 00:04:32,100
the offset within a cache line the

108
00:04:32,100 --> 00:04:35,280
middle end bits to index uh the cache to

109
00:04:35,280 --> 00:04:37,199
find the right cache set and the cash

110
00:04:37,199 --> 00:04:42,020
set then exists of multiple such ways

111
00:04:42,020 --> 00:04:45,120
and each way has a tag and some data

112
00:04:45,120 --> 00:04:47,400
associated

113
00:04:47,400 --> 00:04:50,220
yeah and then you use the remaining bits

114
00:04:50,220 --> 00:04:52,380
to compute this tag and check whether

115
00:04:52,380 --> 00:04:54,240
the tag matches and if so you can return

116
00:04:54,240 --> 00:04:57,479
the data to the user and of course

117
00:04:57,479 --> 00:04:59,940
replacement policies will be relevant

118
00:04:59,940 --> 00:05:01,560
there and they also have some security

119
00:05:01,560 --> 00:05:06,060
uh implications but before we talk about

120
00:05:06,060 --> 00:05:08,340
that we want to talk about attacks

121
00:05:08,340 --> 00:05:12,479
simple attacks on these caches or maybe

122
00:05:12,479 --> 00:05:15,180
not that simple but techniques that are

123
00:05:15,180 --> 00:05:17,460
quite important so Prime and probe is a

124
00:05:17,460 --> 00:05:19,380
very generic technique you can apply

125
00:05:19,380 --> 00:05:21,660
that to many cache-like structures and

126
00:05:21,660 --> 00:05:24,120
buffers and it pretty much works like

127
00:05:24,120 --> 00:05:25,440
this you have some attacker address

128
00:05:25,440 --> 00:05:27,720
space some memory locations there and

129
00:05:27,720 --> 00:05:29,759
the attacker wants to attack this victim

130
00:05:29,759 --> 00:05:31,440
and there are some locations the

131
00:05:31,440 --> 00:05:34,560
attacker wants to know if the victim

132
00:05:34,560 --> 00:05:38,400
accesses those and the attacker to to

133
00:05:38,400 --> 00:05:40,500
get there the attacker will fill one of

134
00:05:40,500 --> 00:05:43,259
these cache sets with all of its own

135
00:05:43,259 --> 00:05:46,680
memory locations and generically we

136
00:05:46,680 --> 00:05:49,740
might call this an eviction set right

137
00:05:49,740 --> 00:05:52,620
yes we call this an eviction set and now

138
00:05:52,620 --> 00:05:55,259
if the victim tries to access one of

139
00:05:55,259 --> 00:05:57,419
those addresses it has to kick something

140
00:05:57,419 --> 00:05:58,979
out of the cache it has to evict

141
00:05:58,979 --> 00:06:01,440
something itself it will do that load

142
00:06:01,440 --> 00:06:04,020
the data Maybe here and if the attacker

143
00:06:04,020 --> 00:06:08,759
later on tries to re-access its own data

144
00:06:08,759 --> 00:06:11,220
the eviction set then the attacker will

145
00:06:11,220 --> 00:06:13,919
see that oh this was fast this was slow

146
00:06:13,919 --> 00:06:16,380
and it will continue like that and the

147
00:06:16,380 --> 00:06:19,440
attacker will see that re-accessing the

148
00:06:19,440 --> 00:06:22,860
eviction set is slower because some of

149
00:06:22,860 --> 00:06:27,240
its lines were kicked out of the cache

150
00:06:27,240 --> 00:06:30,419
the cash hierarchy today of course is a

151
00:06:30,419 --> 00:06:32,220
bit more complex than this simple yeah

152
00:06:32,220 --> 00:06:34,500
block of memory with cache sets today

153
00:06:34,500 --> 00:06:36,060
you have multiple cores you have

154
00:06:36,060 --> 00:06:38,280
multiple L1 caches they are usually

155
00:06:38,280 --> 00:06:40,380
private which means that

156
00:06:40,380 --> 00:06:42,900
um One Core can only access it all its

157
00:06:42,900 --> 00:06:45,720
own L1 cache but not the L1 cache of

158
00:06:45,720 --> 00:06:49,259
another core the same goes for the two

159
00:06:49,259 --> 00:06:51,479
caches and then we have the last level

160
00:06:51,479 --> 00:06:55,560
cache the L3 cache and on some CPUs this

161
00:06:55,560 --> 00:06:57,600
is connected via ring bus it could also

162
00:06:57,600 --> 00:06:59,460
be a mesh depending on the CPU

163
00:06:59,460 --> 00:07:01,259
architecture there are also some CPUs

164
00:07:01,259 --> 00:07:03,660
that skip the L2 layer and just have

165
00:07:03,660 --> 00:07:05,340
here the last level cache right away

166
00:07:05,340 --> 00:07:08,819
after that one and on Intel CPUs this is

167
00:07:08,819 --> 00:07:12,120
typically divided into slices also there

168
00:07:12,120 --> 00:07:14,819
they are different designs but we will

169
00:07:14,819 --> 00:07:18,660
focus on the slice one here

170
00:07:18,660 --> 00:07:20,940
the interesting attacks the interesting

171
00:07:20,940 --> 00:07:22,620
attacks that we have here are then

172
00:07:22,620 --> 00:07:25,380
cross-core attacks where one workload is

173
00:07:25,380 --> 00:07:27,419
running on One Core the attacker

174
00:07:27,419 --> 00:07:29,340
workload and the other the victim

175
00:07:29,340 --> 00:07:31,800
workload is running on another core

176
00:07:31,800 --> 00:07:34,259
and you would think oh they are running

177
00:07:34,259 --> 00:07:36,300
on separate CPU cores so they are

178
00:07:36,300 --> 00:07:38,880
isolated but because of this shared last

179
00:07:38,880 --> 00:07:42,900
level cache attacks are still possible

180
00:07:42,900 --> 00:07:46,259
and that gets us to secure cache designs

181
00:07:46,259 --> 00:07:49,860
so this was maybe 2015 2016 we realized

182
00:07:49,860 --> 00:07:51,479
oh this is really a big problem and then

183
00:07:51,479 --> 00:07:53,880
people started okay saying okay we need

184
00:07:53,880 --> 00:07:55,800
secure cache designs for the last level

185
00:07:55,800 --> 00:07:58,199
cache because so far there there weren't

186
00:07:58,199 --> 00:07:59,639
any that were applicable for the last

187
00:07:59,639 --> 00:08:01,800
level cache so let's start doing that

188
00:08:01,800 --> 00:08:04,620
and we focus here on mainly two

189
00:08:04,620 --> 00:08:05,780
directions

190
00:08:05,780 --> 00:08:09,240
that cover yeah it's broad categories

191
00:08:09,240 --> 00:08:11,160
that cover a lot of the designs in this

192
00:08:11,160 --> 00:08:13,620
space the One Direction is partition

193
00:08:13,620 --> 00:08:16,740
based the other is randomization based

194
00:08:16,740 --> 00:08:20,759
and we will start with Partition based

195
00:08:20,759 --> 00:08:23,940
here and so not to yeah so not to leave

196
00:08:23,940 --> 00:08:25,160
anything out there

197
00:08:25,160 --> 00:08:27,300
technically some other designs that

198
00:08:27,300 --> 00:08:29,039
don't quite fit in these but we're not

199
00:08:29,039 --> 00:08:32,000
going to be talking about them today

200
00:08:32,159 --> 00:08:35,640
okay so partitioning based designs

201
00:08:35,640 --> 00:08:37,979
partitioning the idea of partitioning is

202
00:08:37,979 --> 00:08:41,039
that you want to avoid that attacker and

203
00:08:41,039 --> 00:08:44,580
victim share a cash line or cash set in

204
00:08:44,580 --> 00:08:47,040
the cache and that's usually very

205
00:08:47,040 --> 00:08:49,500
difficult if you have shared memory so

206
00:08:49,500 --> 00:08:51,779
that's why we just say Oh Let's ignore

207
00:08:51,779 --> 00:08:53,940
the problem of shared memory problems of

208
00:08:53,940 --> 00:08:56,940
Futures so let's focus on non-shared

209
00:08:56,940 --> 00:08:58,980
memory for now shared libraries are

210
00:08:58,980 --> 00:09:01,200
complicated yeah

211
00:09:01,200 --> 00:09:03,120
um and then there are actually some

212
00:09:03,120 --> 00:09:04,800
solutions for instance compiler

213
00:09:04,800 --> 00:09:06,860
extensions or code diversification

214
00:09:06,860 --> 00:09:09,060
approaches that work on the software

215
00:09:09,060 --> 00:09:11,040
level during the compilation step for

216
00:09:11,040 --> 00:09:12,000
instance

217
00:09:12,000 --> 00:09:17,339
um to make sure that no two cash no

218
00:09:17,339 --> 00:09:19,560
cache lines of two different processes

219
00:09:19,560 --> 00:09:21,839
of two different security domains land

220
00:09:21,839 --> 00:09:25,019
in the same cache set

221
00:09:25,019 --> 00:09:28,560
and one very early approach one actually

222
00:09:28,560 --> 00:09:30,300
also one of these

223
00:09:30,300 --> 00:09:34,620
um is Cash coloring coloring is very

224
00:09:34,620 --> 00:09:36,000
simply because you have this mapping

225
00:09:36,000 --> 00:09:38,040
here from n Bits in the middle

226
00:09:38,040 --> 00:09:41,519
the cash index to those sets now if you

227
00:09:41,519 --> 00:09:43,920
would make sure that the selection of

228
00:09:43,920 --> 00:09:45,660
these addresses or the assignment of

229
00:09:45,660 --> 00:09:47,640
these addresses during compilation or

230
00:09:47,640 --> 00:09:51,120
while loading the program that this

231
00:09:51,120 --> 00:09:53,399
that you only hand out addresses to One

232
00:09:53,399 --> 00:09:55,620
Security domain there that all have the

233
00:09:55,620 --> 00:09:58,260
same n Bits here in the middle

234
00:09:58,260 --> 00:10:00,540
then you would have sort of like a color

235
00:10:00,540 --> 00:10:02,760
in the cache you can color the cache

236
00:10:02,760 --> 00:10:04,860
lines and here this address would then

237
00:10:04,860 --> 00:10:07,080
maybe the color yellow and the next one

238
00:10:07,080 --> 00:10:09,680
has a different color and so you assign

239
00:10:09,680 --> 00:10:12,839
one color to One Security domain or you

240
00:10:12,839 --> 00:10:15,120
can assign multiple colors even say well

241
00:10:15,120 --> 00:10:17,640
this workload can use multiple of these

242
00:10:17,640 --> 00:10:19,920
colors but you make sure that two

243
00:10:19,920 --> 00:10:21,779
separate workloads that that are not

244
00:10:21,779 --> 00:10:24,899
mutually trusted that they get different

245
00:10:24,899 --> 00:10:27,300
colors and therefore they don't see any

246
00:10:27,300 --> 00:10:29,100
interaction in the cache there

247
00:10:29,100 --> 00:10:31,140
cache coloring is a bit limited though

248
00:10:31,140 --> 00:10:34,200
if you think of a of an L1 cache for

249
00:10:34,200 --> 00:10:36,000
instance you have

250
00:10:36,000 --> 00:10:38,160
um four kilobyte pages in your system

251
00:10:38,160 --> 00:10:41,399
and four kilobyte Pages uh one page maps

252
00:10:41,399 --> 00:10:43,980
to 64 indices because you have 64 byte

253
00:10:43,980 --> 00:10:45,720
cache lines

254
00:10:45,720 --> 00:10:47,399
L3 caches

255
00:10:47,399 --> 00:10:50,300
um typically have something like 2048 to

256
00:10:50,300 --> 00:10:55,380
4096 sets per slice and that means also

257
00:10:55,380 --> 00:10:58,920
there each four kilobyte page covers

258
00:10:58,920 --> 00:11:03,240
um 64 of these indices there

259
00:11:03,240 --> 00:11:05,700
and if you now only hand out four

260
00:11:05,700 --> 00:11:07,740
kilowatt pages that have the same color

261
00:11:07,740 --> 00:11:10,079
so that then then you would for the L3

262
00:11:10,079 --> 00:11:12,240
for instance generate

263
00:11:12,240 --> 00:11:16,079
um 32 to 64 different colors and you can

264
00:11:16,079 --> 00:11:19,140
with that isolate workloads you can also

265
00:11:19,140 --> 00:11:20,820
modify the compiler if you want to focus

266
00:11:20,820 --> 00:11:23,459
on the L1 cache you can modify the

267
00:11:23,459 --> 00:11:26,459
compiler to also only use 64 byte

268
00:11:26,459 --> 00:11:28,140
regions of the same color then you get

269
00:11:28,140 --> 00:11:31,079
way more colors even why wouldn't you do

270
00:11:31,079 --> 00:11:33,899
that because you are actually not using

271
00:11:33,899 --> 00:11:35,579
your entire cache anymore you're

272
00:11:35,579 --> 00:11:38,040
restricting your workload to a very

273
00:11:38,040 --> 00:11:40,079
small subset maybe of the cache and

274
00:11:40,079 --> 00:11:41,640
that's inefficient

275
00:11:41,640 --> 00:11:44,040
um usage of resources and a big

276
00:11:44,040 --> 00:11:46,260
performance penalty so maybe you don't

277
00:11:46,260 --> 00:11:48,180
want to do that and then there are some

278
00:11:48,180 --> 00:11:50,100
other designs and I will just go briefly

279
00:11:50,100 --> 00:11:52,920
through them we have for instance a Nomo

280
00:11:52,920 --> 00:11:55,800
cache the non-monopolizable cache that

281
00:11:55,800 --> 00:11:57,720
was proposed and there the idea is that

282
00:11:57,720 --> 00:12:00,240
in every cache set you have

283
00:12:00,240 --> 00:12:02,579
um and this is an L1 cache we are in one

284
00:12:02,579 --> 00:12:05,180
core two threads of One Core with smt

285
00:12:05,180 --> 00:12:10,019
that each thread gets one cache line

286
00:12:10,019 --> 00:12:12,800
that cannot be monopolized by the other

287
00:12:12,800 --> 00:12:15,779
thread and that means if the attacker

288
00:12:15,779 --> 00:12:18,180
fills the cache set maybe with these

289
00:12:18,180 --> 00:12:20,279
yellow cache lines it cannot fill this

290
00:12:20,279 --> 00:12:23,040
one and the victim if it loads the cache

291
00:12:23,040 --> 00:12:24,600
line it will go there

292
00:12:24,600 --> 00:12:27,000
and the attacker if the attacker tries

293
00:12:27,000 --> 00:12:29,459
to evict it it doesn't work it's not

294
00:12:29,459 --> 00:12:32,180
allowed because it's a no more way

295
00:12:32,180 --> 00:12:34,500
non-monopolizable way

296
00:12:34,500 --> 00:12:36,839
there is also another design I want to

297
00:12:36,839 --> 00:12:39,720
mention here the dynamically allocated

298
00:12:39,720 --> 00:12:41,279
way guard

299
00:12:41,279 --> 00:12:44,339
um or a short dog and it uses two bit

300
00:12:44,339 --> 00:12:48,600
masks also to control which ways can be

301
00:12:48,600 --> 00:12:54,360
evicted and which ways hide hits so

302
00:12:54,360 --> 00:12:57,540
there the idea is if the attacker

303
00:12:57,540 --> 00:12:59,399
already controlled some part of the

304
00:12:59,399 --> 00:13:01,560
cache set and the victim now loads some

305
00:13:01,560 --> 00:13:04,019
data it will be included in the cache

306
00:13:04,019 --> 00:13:05,940
because of some inclusiveness property

307
00:13:05,940 --> 00:13:07,139
of the cache

308
00:13:07,139 --> 00:13:09,180
and then if the attacker tries to evict

309
00:13:09,180 --> 00:13:11,100
it it doesn't work because it's

310
00:13:11,100 --> 00:13:13,920
protected via this bit mask and if the

311
00:13:13,920 --> 00:13:16,079
attacker tries to access it the attacker

312
00:13:16,079 --> 00:13:18,180
will also see a cash Miss because it's

313
00:13:18,180 --> 00:13:21,839
protected by the other bitmask yeah so

314
00:13:21,839 --> 00:13:24,360
this is about partitioning and with

315
00:13:24,360 --> 00:13:26,279
explicit partitions

316
00:13:26,279 --> 00:13:27,839
um there are also further designs for

317
00:13:27,839 --> 00:13:30,060
instance the partition lock cache but

318
00:13:30,060 --> 00:13:32,220
also Intel cut Intel cut is something

319
00:13:32,220 --> 00:13:34,740
that you already find in processors you

320
00:13:34,740 --> 00:13:37,560
will find an intercut in in especially

321
00:13:37,560 --> 00:13:40,380
in server process source and there the

322
00:13:40,380 --> 00:13:41,880
idea is also you have the last level

323
00:13:41,880 --> 00:13:45,180
cache and you want to split it so that

324
00:13:45,180 --> 00:13:48,000
different partitions don't see each

325
00:13:48,000 --> 00:13:50,880
other and typical splits are then maybe

326
00:13:50,880 --> 00:13:54,000
that you assign 25 of the cash to one

327
00:13:54,000 --> 00:13:57,240
domain and then 75 to another or maybe

328
00:13:57,240 --> 00:13:59,279
half and half something like that it

329
00:13:59,279 --> 00:14:00,720
depends a bit on the processor what is

330
00:14:00,720 --> 00:14:04,079
supported and what you can do there but

331
00:14:04,079 --> 00:14:06,540
you really split the cache and then they

332
00:14:06,540 --> 00:14:09,480
are isolated these workloads

333
00:14:09,480 --> 00:14:12,240
there was uh recently

334
00:14:12,240 --> 00:14:15,060
um yeah after more advanced side Channel

335
00:14:15,060 --> 00:14:17,760
attacks side Channel tax we had really a

336
00:14:17,760 --> 00:14:21,180
yeah this sparked a wave of new cache

337
00:14:21,180 --> 00:14:24,420
designs and also some in this uh in this

338
00:14:24,420 --> 00:14:28,200
wave are hype cache and hype cash

339
00:14:28,200 --> 00:14:31,980
um had the idea that in every cache you

340
00:14:31,980 --> 00:14:35,700
just add a fully associative sub cache

341
00:14:35,700 --> 00:14:39,660
and this fully Associated sub cache the

342
00:14:39,660 --> 00:14:41,699
fully associativeness has a nice

343
00:14:41,699 --> 00:14:43,800
property that you don't know if you

344
00:14:43,800 --> 00:14:46,440
evict this fully associative cache you

345
00:14:46,440 --> 00:14:49,260
don't know which element it actually was

346
00:14:49,260 --> 00:14:52,740
within that so it it sort of hides what

347
00:14:52,740 --> 00:14:55,199
was going on so why don't you know

348
00:14:55,199 --> 00:14:56,459
what's different there

349
00:14:56,459 --> 00:14:58,860
yeah for the other one you had one set

350
00:14:58,860 --> 00:15:00,839
and if you have an eviction set for that

351
00:15:00,839 --> 00:15:03,720
one set you know exactly uh the attacker

352
00:15:03,720 --> 00:15:05,579
uh knows exactly that the victim

353
00:15:05,579 --> 00:15:07,760
accessed something in that set way okay

354
00:15:07,760 --> 00:15:10,380
one of eight addresses or something yes

355
00:15:10,380 --> 00:15:12,660
and in this case it's way more addresses

356
00:15:12,660 --> 00:15:14,639
and you don't you don't have any

357
00:15:14,639 --> 00:15:16,199
correlation with the address anymore

358
00:15:16,199 --> 00:15:19,620
because right the the on the y-axis we

359
00:15:19,620 --> 00:15:21,120
have this correlation with the index

360
00:15:21,120 --> 00:15:23,459
that is based on the address with this

361
00:15:23,459 --> 00:15:25,500
we eliminate that we don't have any

362
00:15:25,500 --> 00:15:27,660
relation to the address anymore so we

363
00:15:27,660 --> 00:15:29,100
really lose a lot of information with

364
00:15:29,100 --> 00:15:31,560
this fully associativeness and here the

365
00:15:31,560 --> 00:15:34,199
idea is to just have a small fraction of

366
00:15:34,199 --> 00:15:36,959
the cache acting like a fully Associated

367
00:15:36,959 --> 00:15:38,940
cache and

368
00:15:38,940 --> 00:15:41,940
um yeah isolate the workloads with that

369
00:15:41,940 --> 00:15:44,820
another design that is also very recent

370
00:15:44,820 --> 00:15:47,880
is a chunked cache and there

371
00:15:47,880 --> 00:15:50,040
um the split is in the other dimension

372
00:15:50,040 --> 00:15:51,899
there they don't say well let's split

373
00:15:51,899 --> 00:15:55,260
the ways apart but let's split the sets

374
00:15:55,260 --> 00:15:57,420
apart and here

375
00:15:57,420 --> 00:15:59,579
um the idea is that one domain gets the

376
00:15:59,579 --> 00:16:02,040
first half of the sets maybe and then a

377
00:16:02,040 --> 00:16:05,160
second one gets uh the next quarter and

378
00:16:05,160 --> 00:16:07,260
maybe the last part is still unallocated

379
00:16:07,260 --> 00:16:09,500
but then if the victim or if another

380
00:16:09,500 --> 00:16:12,300
isolated domain is created

381
00:16:12,300 --> 00:16:13,260
um then

382
00:16:13,260 --> 00:16:15,180
um this is also used by this isolated

383
00:16:15,180 --> 00:16:16,980
domain and again they don't see each

384
00:16:16,980 --> 00:16:19,199
other in the cache because they map to

385
00:16:19,199 --> 00:16:21,060
different locations and that means the

386
00:16:21,060 --> 00:16:24,779
attacker cannot evict the victim domain

387
00:16:24,779 --> 00:16:28,320
and this gets us to randomized caches

388
00:16:28,320 --> 00:16:30,060
which is what I will take over yeah

389
00:16:30,060 --> 00:16:33,180
thank you okay so all these partition

390
00:16:33,180 --> 00:16:34,500
caches are starting to set in the very

391
00:16:34,500 --> 00:16:36,060
beginning they have this nice property

392
00:16:36,060 --> 00:16:38,040
that are cut off and so the security is

393
00:16:38,040 --> 00:16:39,660
usually pretty good if you can't get to

394
00:16:39,660 --> 00:16:40,800
the other half

395
00:16:40,800 --> 00:16:42,300
we don't need to really talk about

396
00:16:42,300 --> 00:16:45,360
security but we lose performance

397
00:16:45,360 --> 00:16:48,180
and so for randomized uh caches the idea

398
00:16:48,180 --> 00:16:50,040
is that we keep the size but we make it

399
00:16:50,040 --> 00:16:51,660
harder to infer which addresses were

400
00:16:51,660 --> 00:16:52,680
accessed

401
00:16:52,680 --> 00:16:56,399
so in 2015 uh Lou and colleagues found a

402
00:16:56,399 --> 00:17:00,360
new function agnostic evictions new uh

403
00:17:00,360 --> 00:17:02,339
strategy to generate eviction sets

404
00:17:02,339 --> 00:17:05,099
without knowing what the cache looks

405
00:17:05,099 --> 00:17:06,119
like

406
00:17:06,119 --> 00:17:08,040
and in response to that could actually

407
00:17:08,040 --> 00:17:10,400
published a Caesar paper

408
00:17:10,400 --> 00:17:14,099
and then one year later he and Villa and

409
00:17:14,099 --> 00:17:16,260
colleagues found a break for that type

410
00:17:16,260 --> 00:17:18,900
of cache because they improved the

411
00:17:18,900 --> 00:17:21,119
strategy for finding eviction sets

412
00:17:21,119 --> 00:17:23,459
and just a bit later

413
00:17:23,459 --> 00:17:25,859
there were several proposed skilled

414
00:17:25,859 --> 00:17:27,839
randomized caches that can cope with

415
00:17:27,839 --> 00:17:31,559
even that those attacks so for example

416
00:17:31,559 --> 00:17:34,740
sorry turn yours off yeah maybe I turn

417
00:17:34,740 --> 00:17:37,100
mine off

418
00:17:37,799 --> 00:17:38,400
um

419
00:17:38,400 --> 00:17:40,640
yeah so we'll go through two of these

420
00:17:40,640 --> 00:17:44,100
Qureshi and violent colleagues and the

421
00:17:44,100 --> 00:17:46,080
colleagues are us

422
00:17:46,080 --> 00:17:46,799
um

423
00:17:46,799 --> 00:17:49,020
yeah and then

424
00:17:49,020 --> 00:17:50,760
just a bit later

425
00:17:50,760 --> 00:17:52,919
there was another paper the colleagues

426
00:17:52,919 --> 00:17:54,320
again are us

427
00:17:54,320 --> 00:17:57,419
that showed even faster eviction and

428
00:17:57,419 --> 00:18:00,539
kind of breaks those before so we can

429
00:18:00,539 --> 00:18:02,940
start to see a pattern here

430
00:18:02,940 --> 00:18:04,260
um and then lastly we have a new

431
00:18:04,260 --> 00:18:06,419
generation that aren't broken yet and

432
00:18:06,419 --> 00:18:07,559
we're going to look at those as well

433
00:18:07,559 --> 00:18:10,799
okay so let's jump in

434
00:18:10,799 --> 00:18:13,020
so first cater cache we have this idea

435
00:18:13,020 --> 00:18:16,200
that if the problem is that it's uh very

436
00:18:16,200 --> 00:18:19,679
easy to go from this index function here

437
00:18:19,679 --> 00:18:21,900
directly to an entire set and so it's

438
00:18:21,900 --> 00:18:23,220
very easy to construct these eviction

439
00:18:23,220 --> 00:18:24,299
sets

440
00:18:24,299 --> 00:18:26,760
why don't we construct something a lot

441
00:18:26,760 --> 00:18:28,020
more complicated

442
00:18:28,020 --> 00:18:30,480
okay let's look at that in detail

443
00:18:30,480 --> 00:18:31,919
so

444
00:18:31,919 --> 00:18:34,799
instead of fusing just an index we also

445
00:18:34,799 --> 00:18:36,660
use a tag which is the majority of the

446
00:18:36,660 --> 00:18:38,520
rest of the address so now we use the

447
00:18:38,520 --> 00:18:40,860
entire address except for the offset

448
00:18:40,860 --> 00:18:42,960
and we put that into something we call

449
00:18:42,960 --> 00:18:45,539
an index derivation function so this is

450
00:18:45,539 --> 00:18:48,419
some cryptographic primitive like karma

451
00:18:48,419 --> 00:18:49,440
for example

452
00:18:49,440 --> 00:18:51,360
and then we key that

453
00:18:51,360 --> 00:18:54,179
and we also add a domain here as a key

454
00:18:54,179 --> 00:18:58,080
and then what we get out are Indica into

455
00:18:58,080 --> 00:19:00,179
the cache that are unique for each

456
00:19:00,179 --> 00:19:02,520
domain and address

457
00:19:02,520 --> 00:19:05,460
so for example where I said before

458
00:19:05,460 --> 00:19:07,860
can you see the pointer

459
00:19:07,860 --> 00:19:10,679
oh okay not at all maybe I should go

460
00:19:10,679 --> 00:19:12,860
here

461
00:19:13,740 --> 00:19:15,360
which one

462
00:19:15,360 --> 00:19:17,160
is that better

463
00:19:17,160 --> 00:19:19,520
okay

464
00:19:20,100 --> 00:19:22,320
so before we would have a set would have

465
00:19:22,320 --> 00:19:24,660
been just one straight line here where

466
00:19:24,660 --> 00:19:26,640
these are the banks and now we construct

467
00:19:26,640 --> 00:19:28,380
these custom sets basically for each

468
00:19:28,380 --> 00:19:30,620
address

469
00:19:32,100 --> 00:19:33,539
uh yeah and the security notebook

470
00:19:33,539 --> 00:19:35,039
depends on the hardware key and the

471
00:19:35,039 --> 00:19:37,200
security domain so that can be processes

472
00:19:37,200 --> 00:19:40,160
or virtual machines

473
00:19:40,380 --> 00:19:42,240
um yeah

474
00:19:42,240 --> 00:19:43,679
so this is what it would have looked

475
00:19:43,679 --> 00:19:45,840
like before you just have these fixed

476
00:19:45,840 --> 00:19:48,240
static sets set one to whatever

477
00:19:48,240 --> 00:19:51,059
and then in our new design for each

478
00:19:51,059 --> 00:19:52,080
address

479
00:19:52,080 --> 00:19:54,179
you get a completely randomized set for

480
00:19:54,179 --> 00:19:56,940
so the same address would have two very

481
00:19:56,940 --> 00:19:58,860
different cache patterns

482
00:19:58,860 --> 00:20:00,660
for two different domains and another

483
00:20:00,660 --> 00:20:02,220
address a completely different pattern

484
00:20:02,220 --> 00:20:04,260
again

485
00:20:04,260 --> 00:20:07,559
right so this means well we start out

486
00:20:07,559 --> 00:20:08,880
with the unshared memory we have no

487
00:20:08,880 --> 00:20:10,500
shared cache lines

488
00:20:10,500 --> 00:20:12,419
and all of these fancy attacks that we

489
00:20:12,419 --> 00:20:14,220
haven't told you about but there are

490
00:20:14,220 --> 00:20:15,960
you're gonna have to believe me they are

491
00:20:15,960 --> 00:20:18,120
even better than Prime probe these don't

492
00:20:18,120 --> 00:20:21,240
work on unshared memory and for shared

493
00:20:21,240 --> 00:20:24,780
memory this cache design makes it such

494
00:20:24,780 --> 00:20:26,340
that it behaves like unshared memory

495
00:20:26,340 --> 00:20:29,340
because now we can have copies copies of

496
00:20:29,340 --> 00:20:31,980
shared memory in the cache

497
00:20:31,980 --> 00:20:34,559
right and without OS support it's just a

498
00:20:34,559 --> 00:20:37,440
bit harder let's suboptimal

499
00:20:37,440 --> 00:20:39,960
okay so at the time we already knew that

500
00:20:39,960 --> 00:20:41,400
specialized Prime probe variants would

501
00:20:41,400 --> 00:20:42,900
still work

502
00:20:42,900 --> 00:20:45,059
because there is still overlap in the

503
00:20:45,059 --> 00:20:45,960
cache set

504
00:20:45,960 --> 00:20:47,700
but it's now really hard to get a full

505
00:20:47,700 --> 00:20:51,840
overlap so we'd expect usually one

506
00:20:51,840 --> 00:20:54,539
one line to overlap between an address

507
00:20:54,539 --> 00:20:56,039
in the attacker and an address in the

508
00:20:56,039 --> 00:20:57,539
victim and so this turns it

509
00:20:57,539 --> 00:20:59,940
probabilistic and so now if we want to

510
00:20:59,940 --> 00:21:01,799
evict a certain address in a victim

511
00:21:01,799 --> 00:21:05,460
we'll certainly need 275 addresses just

512
00:21:05,460 --> 00:21:07,860
to evict an eight-way cache or a one set

513
00:21:07,860 --> 00:21:10,559
in an eight-way cache or one address

514
00:21:10,559 --> 00:21:12,000
and before that would have been just

515
00:21:12,000 --> 00:21:14,220
eight and those eight would have been

516
00:21:14,220 --> 00:21:15,600
very easy to find

517
00:21:15,600 --> 00:21:17,820
and so at the time we calculated that

518
00:21:17,820 --> 00:21:20,280
the set construction would need 2 to the

519
00:21:20,280 --> 00:21:24,120
power of 25 profiled victim accesses and

520
00:21:24,120 --> 00:21:27,179
not just attacker accesses

521
00:21:27,179 --> 00:21:28,919
um as opposed to maybe a hundred that

522
00:21:28,919 --> 00:21:31,320
you need before so we thought that was

523
00:21:31,320 --> 00:21:33,720
pretty good security

524
00:21:33,720 --> 00:21:34,320
um

525
00:21:34,320 --> 00:21:36,299
and a similar design like we actually

526
00:21:36,299 --> 00:21:39,240
had a uh also this idea that they take

527
00:21:39,240 --> 00:21:41,520
the normal address and they put it into

528
00:21:41,520 --> 00:21:43,679
two different encryption functions

529
00:21:43,679 --> 00:21:46,020
and then those those mapped to

530
00:21:46,020 --> 00:21:48,720
two different halves of a set and then

531
00:21:48,720 --> 00:21:50,700
you randomly choose between them

532
00:21:50,700 --> 00:21:52,980
and

533
00:21:52,980 --> 00:21:54,780
they had a strong focus on re-keying

534
00:21:54,780 --> 00:21:57,480
that you can see here so every so many

535
00:21:57,480 --> 00:22:00,000
accesses this mapping here this key

536
00:22:00,000 --> 00:22:01,919
would change and then your address moves

537
00:22:01,919 --> 00:22:03,600
somewhere else and that the idea is that

538
00:22:03,600 --> 00:22:05,940
profiling if you can't finish your

539
00:22:05,940 --> 00:22:07,919
profiling within one period of repeating

540
00:22:07,919 --> 00:22:11,159
then all the work you did is useless now

541
00:22:11,159 --> 00:22:14,340
and so they calculated that with 0.1

542
00:22:14,340 --> 00:22:16,440
reaching which means changing the

543
00:22:16,440 --> 00:22:18,600
location of only one line every 1000

544
00:22:18,600 --> 00:22:19,620
axises

545
00:22:19,620 --> 00:22:21,720
that the only vulnerability window of

546
00:22:21,720 --> 00:22:24,900
about one millisecond every 68 years it

547
00:22:24,900 --> 00:22:26,880
also sounds pretty good but overall this

548
00:22:26,880 --> 00:22:28,679
design is still very similar to scatter

549
00:22:28,679 --> 00:22:31,020
cache just that it uses the Reiki

550
00:22:31,020 --> 00:22:33,059
exactly and a few people noticed that

551
00:22:33,059 --> 00:22:35,159
but we're going to come to that a bit

552
00:22:35,159 --> 00:22:36,960
later so we're going to stay with Caesar

553
00:22:36,960 --> 00:22:40,620
and caesares for just a second

554
00:22:40,620 --> 00:22:43,020
um yeah so complicates crypto or the

555
00:22:43,020 --> 00:22:45,240
cryptographers in the audience enjoy

556
00:22:45,240 --> 00:22:47,820
uh but you don't need to understand that

557
00:22:47,820 --> 00:22:51,179
the important part is Caesar and Caesars

558
00:22:51,179 --> 00:22:54,000
use a custom low latency block Cipher is

559
00:22:54,000 --> 00:22:56,400
this first stage feisty Network here

560
00:22:56,400 --> 00:22:58,559
and this is linear in the entire Cipher

561
00:22:58,559 --> 00:23:00,539
and so those of you that learned about

562
00:23:00,539 --> 00:23:02,940
that might already have alarm Bells

563
00:23:02,940 --> 00:23:03,840
going off

564
00:23:03,840 --> 00:23:06,419
so that means that a difference at the

565
00:23:06,419 --> 00:23:08,039
input can propagate all the way to the

566
00:23:08,039 --> 00:23:10,380
output and that allows us to construct

567
00:23:10,380 --> 00:23:12,419
eviction sets entirely offline without

568
00:23:12,419 --> 00:23:15,059
ever touching the set at the cache

569
00:23:15,059 --> 00:23:18,720
and even if it's repeat those set

570
00:23:18,720 --> 00:23:20,580
relations stay exactly the same so I can

571
00:23:20,580 --> 00:23:22,320
use the same set with a new key on the

572
00:23:22,320 --> 00:23:24,419
victim address and basically the entire

573
00:23:24,419 --> 00:23:26,100
construction is bypassed

574
00:23:26,100 --> 00:23:29,100
and so the conclusion here is

575
00:23:29,100 --> 00:23:31,260
like you've probably been taught don't

576
00:23:31,260 --> 00:23:33,659
do custom photography

577
00:23:33,659 --> 00:23:36,720
yeah so now to to the commonality of

578
00:23:36,720 --> 00:23:38,400
that you may have noticed in the two

579
00:23:38,400 --> 00:23:40,940
designs before

580
00:23:41,039 --> 00:23:43,020
um some people noticed

581
00:23:43,020 --> 00:23:45,059
uh for Northern colleagues again

582
00:23:45,059 --> 00:23:48,360
colleagues are us uh song and Peugeot

583
00:23:48,360 --> 00:23:49,500
and colleagues

584
00:23:49,500 --> 00:23:52,260
and they also came up with new attacks

585
00:23:52,260 --> 00:23:54,960
as I said before that then drastically

586
00:23:54,960 --> 00:23:57,120
reduce the attack time on those improved

587
00:23:57,120 --> 00:23:58,620
cash designs

588
00:23:58,620 --> 00:24:01,039
so let's look at ours here the the

589
00:24:01,039 --> 00:24:03,480
phonary and us

590
00:24:03,480 --> 00:24:06,720
yeah so we built this generic model or

591
00:24:06,720 --> 00:24:08,580
that includes all of those other cache

592
00:24:08,580 --> 00:24:11,700
designs where we now take some part of

593
00:24:11,700 --> 00:24:13,020
the address

594
00:24:13,020 --> 00:24:15,720
put it into some function here

595
00:24:15,720 --> 00:24:18,659
and then map that to a number of P

596
00:24:18,659 --> 00:24:20,360
partitions

597
00:24:20,360 --> 00:24:24,000
between which we randomly decide

598
00:24:24,000 --> 00:24:25,500
and then within the partition for

599
00:24:25,500 --> 00:24:27,179
example these two ways you can still

600
00:24:27,179 --> 00:24:28,860
have lru or something like a normal

601
00:24:28,860 --> 00:24:29,880
cache

602
00:24:29,880 --> 00:24:32,220
and this function here

603
00:24:32,220 --> 00:24:37,260
can build or map onto the standard

604
00:24:37,260 --> 00:24:39,000
caches current standard caches and

605
00:24:39,000 --> 00:24:40,980
Scatter cache Caesar and also Phantom

606
00:24:40,980 --> 00:24:42,480
cache if you know it

607
00:24:42,480 --> 00:24:44,400
and the way it does that is for example

608
00:24:44,400 --> 00:24:47,400
for building lru all we need to do is

609
00:24:47,400 --> 00:24:49,679
make that just a pass-through of the

610
00:24:49,679 --> 00:24:50,520
index

611
00:24:50,520 --> 00:24:53,100
make p one partition and then we have

612
00:24:53,100 --> 00:24:55,280
normal cache again

613
00:24:55,280 --> 00:24:58,380
is on the other side of that where p is

614
00:24:58,380 --> 00:25:02,100
say 8 for an eight way cache and this is

615
00:25:02,100 --> 00:25:04,080
a cryptographic function then you get

616
00:25:04,080 --> 00:25:06,840
eight indices and then that's your set

617
00:25:06,840 --> 00:25:08,820
uh

618
00:25:08,820 --> 00:25:11,940
all right so within that paper we

619
00:25:11,940 --> 00:25:14,340
developed a generic attack that works

620
00:25:14,340 --> 00:25:15,720
for all

621
00:25:15,720 --> 00:25:18,120
um yeah all cache designs that fit into

622
00:25:18,120 --> 00:25:19,980
this pattern

623
00:25:19,980 --> 00:25:23,280
so it's called Prime prune and probe

624
00:25:23,280 --> 00:25:25,140
we start priming by accessing a certain

625
00:25:25,140 --> 00:25:27,480
amount of addresses okay usually larger

626
00:25:27,480 --> 00:25:30,419
than one that can be maybe half the

627
00:25:30,419 --> 00:25:32,580
cache or two-thirds the cache something

628
00:25:32,580 --> 00:25:34,919
that should fit into the cache

629
00:25:34,919 --> 00:25:38,279
and in the pruning step we now measure

630
00:25:38,279 --> 00:25:40,500
the time it takes to access them and

631
00:25:40,500 --> 00:25:42,059
then we'll discover if we've had self

632
00:25:42,059 --> 00:25:44,340
evictions when we populated this set

633
00:25:44,340 --> 00:25:46,679
and if we have no self evictions then we

634
00:25:46,679 --> 00:25:48,419
move to the next step and we we have

635
00:25:48,419 --> 00:25:50,159
some then we start again so we access

636
00:25:50,159 --> 00:25:52,640
them again and again and this starts to

637
00:25:52,640 --> 00:25:55,020
coalesce the set into the cache and if

638
00:25:55,020 --> 00:25:57,299
it does fit then we'll have a set that

639
00:25:57,299 --> 00:25:59,820
fills a good chunk of the cache

640
00:25:59,820 --> 00:26:00,480
um

641
00:26:00,480 --> 00:26:02,940
and doesn't self-evict and if you don't

642
00:26:02,940 --> 00:26:04,440
get there we start removing addresses

643
00:26:04,440 --> 00:26:06,480
and making a bit of small a bit smaller

644
00:26:06,480 --> 00:26:08,220
so once we have that

645
00:26:08,220 --> 00:26:11,460
can trigger one victim access and so for

646
00:26:11,460 --> 00:26:13,500
example if we have two-thirds of the

647
00:26:13,500 --> 00:26:16,559
entire cache then we have two-thirds a

648
00:26:16,559 --> 00:26:21,419
probability of 66 percent to notice this

649
00:26:21,419 --> 00:26:24,000
yeah to see Collision here and then

650
00:26:24,000 --> 00:26:26,400
we've found one address from our

651
00:26:26,400 --> 00:26:27,659
eviction set

652
00:26:27,659 --> 00:26:29,400
so this sounds complicated but it's

653
00:26:29,400 --> 00:26:31,260
better than what we had before

654
00:26:31,260 --> 00:26:33,840
but this changes how eviction works so

655
00:26:33,840 --> 00:26:35,400
that means some of the numbers and

656
00:26:35,400 --> 00:26:37,760
estimates we had before maybe are not

657
00:26:37,760 --> 00:26:41,340
correct anymore maybe a bit off yeah so

658
00:26:41,340 --> 00:26:42,419
that's

659
00:26:42,419 --> 00:26:45,900
uh yeah that's nice

660
00:26:45,900 --> 00:26:47,880
okay so first cut the cache for a

661
00:26:47,880 --> 00:26:49,380
certain case for small victim

662
00:26:49,380 --> 00:26:51,000
application we found that this reduces

663
00:26:51,000 --> 00:26:53,460
the profiling Time by three orders of

664
00:26:53,460 --> 00:26:55,200
magnitude but that's our own can you

665
00:26:55,200 --> 00:26:57,179
talk about some caches by someone else

666
00:26:57,179 --> 00:27:00,179
sorry okay

667
00:27:00,179 --> 00:27:02,279
uh so for Caesar two the variant we

668
00:27:02,279 --> 00:27:04,559
showed before with two partitions we saw

669
00:27:04,559 --> 00:27:06,059
that where before we had 68 years

670
00:27:06,059 --> 00:27:09,600
coincidentally We Now find that 68 of

671
00:27:09,600 --> 00:27:11,220
each re-keying interval is actually

672
00:27:11,220 --> 00:27:12,360
attackable

673
00:27:12,360 --> 00:27:14,039
so

674
00:27:14,039 --> 00:27:15,299
yeah

675
00:27:15,299 --> 00:27:17,700
at that at that raking interval not

676
00:27:17,700 --> 00:27:18,600
great

677
00:27:18,600 --> 00:27:20,580
for one percent retain we found its

678
00:27:20,580 --> 00:27:21,960
mostly resistant so we've already

679
00:27:21,960 --> 00:27:24,600
reduced the margins significantly

680
00:27:24,600 --> 00:27:26,700
and for the S4 configuration where

681
00:27:26,700 --> 00:27:28,320
Caesar has four partitions instead of

682
00:27:28,320 --> 00:27:31,140
two we find that we reduced by 20 orders

683
00:27:31,140 --> 00:27:32,460
of magnitude

684
00:27:32,460 --> 00:27:35,279
yeah so be careful with your assumptions

685
00:27:35,279 --> 00:27:37,620
about what an attacker can do but maybe

686
00:27:37,620 --> 00:27:39,539
we can build something better a better

687
00:27:39,539 --> 00:27:42,059
catch than those yeah some people have

688
00:27:42,059 --> 00:27:43,020
tried

689
00:27:43,020 --> 00:27:46,140
they haven't failed yet okay so which

690
00:27:46,140 --> 00:27:48,720
ones are those yeah let's see so we're

691
00:27:48,720 --> 00:27:50,039
gonna start with Mirage this one is

692
00:27:50,039 --> 00:27:52,380
complicated sorry

693
00:27:52,380 --> 00:27:53,520
um

694
00:27:53,520 --> 00:27:56,400
the idea is that we can that all of

695
00:27:56,400 --> 00:27:59,640
these attacks attack cache sets and so

696
00:27:59,640 --> 00:28:02,880
if we get rid of them what do we attack

697
00:28:02,880 --> 00:28:06,080
so the idea is to get somewhere into the

698
00:28:06,080 --> 00:28:08,460
vicinity of a fully associative cache

699
00:28:08,460 --> 00:28:10,380
that Daniel talked about before

700
00:28:10,380 --> 00:28:12,720
but the problem is here the cash could

701
00:28:12,720 --> 00:28:14,700
have 200 000 cash lines

702
00:28:14,700 --> 00:28:16,679
and if our address could be anywhere

703
00:28:16,679 --> 00:28:19,080
then for each access we would need to

704
00:28:19,080 --> 00:28:22,559
search 200 000 cache lines and that's

705
00:28:22,559 --> 00:28:24,659
way too expensive yeah way too much

706
00:28:24,659 --> 00:28:27,240
power not not a good idea and so they

707
00:28:27,240 --> 00:28:29,340
had the idea of emulating this

708
00:28:29,340 --> 00:28:31,559
probabilistically by doing some kind of

709
00:28:31,559 --> 00:28:33,419
load balancing

710
00:28:33,419 --> 00:28:36,000
so let's look at this okay complicated

711
00:28:36,000 --> 00:28:40,380
we start again with two functions

712
00:28:40,380 --> 00:28:42,419
to Hash uh cryptographic functions

713
00:28:42,419 --> 00:28:45,360
that's like scatter cache or like Caesar

714
00:28:45,360 --> 00:28:47,640
and then they each point to one of these

715
00:28:47,640 --> 00:28:50,460
sets now they're Tag sets

716
00:28:50,460 --> 00:28:53,640
and now the special part here is that we

717
00:28:53,640 --> 00:28:55,440
over provision this which means if we

718
00:28:55,440 --> 00:28:57,419
want to have a an eight-way cache then

719
00:28:57,419 --> 00:28:59,159
we have four here four here

720
00:28:59,159 --> 00:29:02,940
but we also have some extra space here

721
00:29:02,940 --> 00:29:05,580
space that you don't actually use well

722
00:29:05,580 --> 00:29:07,620
we use it sometimes and that's the point

723
00:29:07,620 --> 00:29:10,440
so when we now insert something we'll

724
00:29:10,440 --> 00:29:12,539
pick one of these functions and we'll

725
00:29:12,539 --> 00:29:15,120
pick the one that has fewer in there

726
00:29:15,120 --> 00:29:17,880
so we choose by load so here we have rn4

727
00:29:17,880 --> 00:29:19,200
we have only three

728
00:29:19,200 --> 00:29:21,539
and then this balances out nicely and

729
00:29:21,539 --> 00:29:24,059
each time we insert something new we

730
00:29:24,059 --> 00:29:25,980
remove a random line from the entire

731
00:29:25,980 --> 00:29:27,120
cache

732
00:29:27,120 --> 00:29:29,700
and so what this achieves is that each

733
00:29:29,700 --> 00:29:31,020
of these sets

734
00:29:31,020 --> 00:29:33,600
will actually never overflow and the

735
00:29:33,600 --> 00:29:36,840
Overflow is what we need to profile or

736
00:29:36,840 --> 00:29:38,880
to generate these eviction sets because

737
00:29:38,880 --> 00:29:40,799
we will never know if our address maps

738
00:29:40,799 --> 00:29:42,600
to this set

739
00:29:42,600 --> 00:29:45,480
unless we see a spill over here so or

740
00:29:45,480 --> 00:29:47,220
rather we won't know if two addresses

741
00:29:47,220 --> 00:29:49,679
conflict in a set if we can never see a

742
00:29:49,679 --> 00:29:51,240
spillover

743
00:29:51,240 --> 00:29:53,700
and the way they worked it out

744
00:29:53,700 --> 00:29:55,080
is that they can guarantee security

745
00:29:55,080 --> 00:29:57,779
beyond the lifetime of the universe

746
00:29:57,779 --> 00:29:59,940
according to the paper maybe land next

747
00:29:59,940 --> 00:30:01,440
year we don't know

748
00:30:01,440 --> 00:30:02,700
um

749
00:30:02,700 --> 00:30:05,700
or maybe it won't we can be hopeful okay

750
00:30:05,700 --> 00:30:07,740
Daniel will

751
00:30:07,740 --> 00:30:10,380
yeah there are more cash cash designs

752
00:30:10,380 --> 00:30:11,940
actually one that I wanted to mention

753
00:30:11,940 --> 00:30:14,279
here as well is a collapse Hydra cache

754
00:30:14,279 --> 00:30:16,640
also basically a secure cache design

755
00:30:16,640 --> 00:30:19,200
similar to the other ones that we've

756
00:30:19,200 --> 00:30:23,220
seen randomized cache but they introduce

757
00:30:23,220 --> 00:30:26,279
something that is called a time to live

758
00:30:26,279 --> 00:30:29,700
for each cache line and they have a rate

759
00:30:29,700 --> 00:30:32,240
with which the time to live decreases

760
00:30:32,240 --> 00:30:36,240
and if you have a conflict in the cache

761
00:30:36,240 --> 00:30:39,539
as Illustrated in in red here then this

762
00:30:39,539 --> 00:30:43,200
raid with which the catch lines age goes

763
00:30:43,200 --> 00:30:45,600
up so the cash lines age faster and then

764
00:30:45,600 --> 00:30:47,460
they are kicked out when they are time

765
00:30:47,460 --> 00:30:51,240
to live reaches zero so again things are

766
00:30:51,240 --> 00:30:52,919
kicked out of the cache without the

767
00:30:52,919 --> 00:30:55,080
attacker or the victim doing anything

768
00:30:55,080 --> 00:30:57,779
for that and with this effect if the

769
00:30:57,779 --> 00:31:00,360
attacker triggers a lot of conflicts

770
00:31:00,360 --> 00:31:03,659
which the attacker has to do to observe

771
00:31:03,659 --> 00:31:06,240
victim activity then the time to live

772
00:31:06,240 --> 00:31:09,360
would go down very quickly and the

773
00:31:09,360 --> 00:31:10,919
attacker wouldn't be able to observe

774
00:31:10,919 --> 00:31:11,840
anything

775
00:31:11,840 --> 00:31:15,600
about the victim yeah

776
00:31:15,600 --> 00:31:18,000
and we also came up with some a new

777
00:31:18,000 --> 00:31:20,100
design there and you want to talk about

778
00:31:20,100 --> 00:31:23,399
that now right yeah yes so we thought if

779
00:31:23,399 --> 00:31:25,080
at first you don't succeed make it more

780
00:31:25,080 --> 00:31:26,399
complicated

781
00:31:26,399 --> 00:31:28,980
so our new cache scatter and split

782
00:31:28,980 --> 00:31:30,360
securely is going to be published

783
00:31:30,360 --> 00:31:33,659
hopefully sometime soon we'll see and

784
00:31:33,659 --> 00:31:35,760
maybe notice it looks similar to scatter

785
00:31:35,760 --> 00:31:37,260
cache

786
00:31:37,260 --> 00:31:39,120
but now we have introduced into this

787
00:31:39,120 --> 00:31:41,399
index derivation function two sub

788
00:31:41,399 --> 00:31:43,919
functions so we have a generation layer

789
00:31:43,919 --> 00:31:46,020
that generates an immediate intermediate

790
00:31:46,020 --> 00:31:46,980
value

791
00:31:46,980 --> 00:31:48,960
and then a spacing layer that generates

792
00:31:48,960 --> 00:31:51,539
that spaces to the final indices and

793
00:31:51,539 --> 00:31:53,880
then that works the same so we we use

794
00:31:53,880 --> 00:31:55,799
these indices to create our cache set

795
00:31:55,799 --> 00:31:58,200
for an address so a difference that you

796
00:31:58,200 --> 00:31:59,520
may notice here is that some of these

797
00:31:59,520 --> 00:32:00,600
are white

798
00:32:00,600 --> 00:32:03,299
and that's because with this design some

799
00:32:03,299 --> 00:32:05,279
parts of the Cache can never be reached

800
00:32:05,279 --> 00:32:07,559
by a specific domain so you don't use

801
00:32:07,559 --> 00:32:10,440
part of the cache sadly not but that's

802
00:32:10,440 --> 00:32:13,200
that's a trade-off so that's uh

803
00:32:13,200 --> 00:32:15,120
something like partitioning that we've

804
00:32:15,120 --> 00:32:16,260
introduced here but crypto

805
00:32:16,260 --> 00:32:19,080
cryptographically

806
00:32:19,080 --> 00:32:20,880
all right let's look at this in a bit

807
00:32:20,880 --> 00:32:22,380
more detail

808
00:32:22,380 --> 00:32:25,020
okay so in this first stage generate

809
00:32:25,020 --> 00:32:26,640
immediate we use again the key the

810
00:32:26,640 --> 00:32:30,419
address we put them in a block Cipher

811
00:32:30,419 --> 00:32:31,260
um

812
00:32:31,260 --> 00:32:33,779
and then we which block Cipher do you

813
00:32:33,779 --> 00:32:35,159
use there

814
00:32:35,159 --> 00:32:37,860
a custom one can you just say you

815
00:32:37,860 --> 00:32:39,779
shouldn't design custom crypto oh no no

816
00:32:39,779 --> 00:32:41,159
no no it's fine it's fine we use the

817
00:32:41,159 --> 00:32:43,380
wealth class cryptographer to slightly

818
00:32:43,380 --> 00:32:46,860
modify a very well started Cipher which

819
00:32:46,860 --> 00:32:48,779
is karma so I'm sure this one will be

820
00:32:48,779 --> 00:32:50,760
fine okay okay

821
00:32:50,760 --> 00:32:52,799
you can trust us

822
00:32:52,799 --> 00:32:56,100
we haven't messed up yet okay

823
00:32:56,100 --> 00:32:58,740
so with this first layer we generate the

824
00:32:58,740 --> 00:33:01,080
these indexes again and we can just cut

825
00:33:01,080 --> 00:33:02,940
them out from the output and that's the

826
00:33:02,940 --> 00:33:04,980
same as cut the cache and now we add the

827
00:33:04,980 --> 00:33:06,299
second layer

828
00:33:06,299 --> 00:33:08,580
where each of the integers gets its own

829
00:33:08,580 --> 00:33:11,399
block Cipher we put in say 10 bits here

830
00:33:11,399 --> 00:33:14,519
or 11 bits here and we take out 11 bits

831
00:33:14,519 --> 00:33:16,919
bits and the point is not to make it

832
00:33:16,919 --> 00:33:20,460
more random but because we only put in

833
00:33:20,460 --> 00:33:23,039
11 bits of information here

834
00:33:23,039 --> 00:33:27,659
we get out less than those 11 bits here

835
00:33:27,659 --> 00:33:30,360
because these 11 bits are spread over

836
00:33:30,360 --> 00:33:32,820
this entire thing so that works out to

837
00:33:32,820 --> 00:33:35,100
about 63 percent

838
00:33:35,100 --> 00:33:37,860
so normally 11 bits would map to 2048

839
00:33:37,860 --> 00:33:40,980
but we only get about 1290. so this

840
00:33:40,980 --> 00:33:44,880
basically spaces it out over the cache

841
00:33:44,880 --> 00:33:47,279
okay and then we address again

842
00:33:47,279 --> 00:33:49,740
but this construction you can configure

843
00:33:49,740 --> 00:33:51,539
it a bit right oh yeah you're talking

844
00:33:51,539 --> 00:33:53,100
about that well

845
00:33:53,100 --> 00:33:55,019
okay so this gives us the notion of

846
00:33:55,019 --> 00:33:57,240
configurable coverage so if we go back

847
00:33:57,240 --> 00:33:59,100
again we could for example change this

848
00:33:59,100 --> 00:34:01,860
here of 11 bits to 11 bits into 10 bits

849
00:34:01,860 --> 00:34:04,799
to 11 bits and suddenly our coverage our

850
00:34:04,799 --> 00:34:06,899
part of the share of the cache is 39

851
00:34:06,899 --> 00:34:08,699
percent

852
00:34:08,699 --> 00:34:09,899
so

853
00:34:09,899 --> 00:34:11,099
let's look at this from different

854
00:34:11,099 --> 00:34:14,399
perspectives each domain with the

855
00:34:14,399 --> 00:34:17,339
spacing layer has access to a part of a

856
00:34:17,339 --> 00:34:19,080
bank so this would be normally a

857
00:34:19,080 --> 00:34:20,699
thousand addresses represented by 10

858
00:34:20,699 --> 00:34:23,159
here and so the the part that we would

859
00:34:23,159 --> 00:34:27,119
have access to 63 are now here six

860
00:34:27,119 --> 00:34:29,639
and if we now add a second domain and

861
00:34:29,639 --> 00:34:30,899
attack a domain

862
00:34:30,899 --> 00:34:34,020
we get a security notion so the second

863
00:34:34,020 --> 00:34:35,940
domain also has access to six of these

864
00:34:35,940 --> 00:34:36,839
ways

865
00:34:36,839 --> 00:34:39,899
but the only overlap in three so already

866
00:34:39,899 --> 00:34:41,520
we can maybe see

867
00:34:41,520 --> 00:34:43,859
if we don't have access to all of these

868
00:34:43,859 --> 00:34:47,540
maybe attacking will get a bit harder

869
00:34:48,000 --> 00:34:50,699
all right so blown up to all the uh all

870
00:34:50,699 --> 00:34:52,980
the sets for uh all the ways for a 16

871
00:34:52,980 --> 00:34:55,320
way cache that would look something like

872
00:34:55,320 --> 00:34:56,879
this each of these Banks has its own

873
00:34:56,879 --> 00:34:58,080
pattern because there's different

874
00:34:58,080 --> 00:35:00,960
function between beneath Eve

875
00:35:00,960 --> 00:35:02,580
need each of them

876
00:35:02,580 --> 00:35:04,380
and we'd select the set something like

877
00:35:04,380 --> 00:35:05,400
this

878
00:35:05,400 --> 00:35:07,200
then we can see that this set for

879
00:35:07,200 --> 00:35:08,040
example

880
00:35:08,040 --> 00:35:10,560
even in those three examples does not

881
00:35:10,560 --> 00:35:12,839
have overlap in all of them and so we

882
00:35:12,839 --> 00:35:15,180
get a certain probability that a victim

883
00:35:15,180 --> 00:35:17,520
line can even be reached by an attacker

884
00:35:17,520 --> 00:35:18,540
in full

885
00:35:18,540 --> 00:35:20,339
so no but no matter what an attacker

886
00:35:20,339 --> 00:35:22,320
does they may not be able to reach all

887
00:35:22,320 --> 00:35:24,839
of the ways a victim line can go into so

888
00:35:24,839 --> 00:35:27,839
it is not possible anymore to evict the

889
00:35:27,839 --> 00:35:30,540
victim exactly once it's in that in that

890
00:35:30,540 --> 00:35:34,079
line so for 63 for each line that's 0.06

891
00:35:34,079 --> 00:35:36,780
percent and maybe that's too much for

892
00:35:36,780 --> 00:35:38,460
you because you need I don't know every

893
00:35:38,460 --> 00:35:40,200
thousand addresses you have a good

894
00:35:40,200 --> 00:35:42,660
chance to have an overlap so let's make

895
00:35:42,660 --> 00:35:46,560
it 39 and at that point

896
00:35:46,560 --> 00:35:49,079
it becomes pretty unlikely that you find

897
00:35:49,079 --> 00:35:51,359
overlap and that means only this many

898
00:35:51,359 --> 00:35:54,780
addresses remain attackable what does it

899
00:35:54,780 --> 00:35:56,760
mean they remain attackable they get the

900
00:35:56,760 --> 00:35:59,400
same security level there as a typical

901
00:35:59,400 --> 00:36:02,280
secure randomized cache they still get

902
00:36:02,280 --> 00:36:03,920
that

903
00:36:03,920 --> 00:36:07,619
at least for the attacks we know about

904
00:36:07,619 --> 00:36:08,880
okay

905
00:36:08,880 --> 00:36:11,040
so this first layer provides this

906
00:36:11,040 --> 00:36:13,200
catacash security the second layer

907
00:36:13,200 --> 00:36:15,240
provides resistance against profiling

908
00:36:15,240 --> 00:36:17,700
because with profiling Prime Pro before

909
00:36:17,700 --> 00:36:20,400
we've seen we need repeated observations

910
00:36:20,400 --> 00:36:22,260
uh yeah

911
00:36:22,260 --> 00:36:24,420
and so when we do repeated observations

912
00:36:24,420 --> 00:36:27,000
we need to evict the victim repeatedly

913
00:36:27,000 --> 00:36:30,060
and that done at some point puts them in

914
00:36:30,060 --> 00:36:31,619
one of the cache lines that the attacker

915
00:36:31,619 --> 00:36:33,000
just cannot access

916
00:36:33,000 --> 00:36:35,520
and then it can't evict them anymore and

917
00:36:35,520 --> 00:36:37,260
then the whole game is over you can't

918
00:36:37,260 --> 00:36:40,260
continue profiling and yeah that's the

919
00:36:40,260 --> 00:36:42,480
idea basically

920
00:36:42,480 --> 00:36:44,400
um and so we see that for these

921
00:36:44,400 --> 00:36:47,040
configurations say for 39 after only

922
00:36:47,040 --> 00:36:49,740
about six victim observations we're

923
00:36:49,740 --> 00:36:52,260
almost a tier probability that it's not

924
00:36:52,260 --> 00:36:55,619
in a an inaccessible way

925
00:36:55,619 --> 00:36:57,119
right

926
00:36:57,119 --> 00:36:58,920
and even the improved version that we

927
00:36:58,920 --> 00:37:00,540
know about still needs a lot of victim

928
00:37:00,540 --> 00:37:02,460
accesses certainly more than

929
00:37:02,460 --> 00:37:04,619
somewhere below 10.

930
00:37:04,619 --> 00:37:07,440
okay yeah and then all the attacks are

931
00:37:07,440 --> 00:37:10,500
impossible and we're done great yeah

932
00:37:10,500 --> 00:37:14,640
so maybe let's take a look ahead

933
00:37:14,640 --> 00:37:17,640
um yeah so we've seen this pattern it's

934
00:37:17,640 --> 00:37:19,020
like I find something Defender does

935
00:37:19,020 --> 00:37:20,940
something better and getting Mouse game

936
00:37:20,940 --> 00:37:23,099
we all know yeah

937
00:37:23,099 --> 00:37:25,079
but it will continue probably as a cat

938
00:37:25,079 --> 00:37:27,240
and mouse game until someone finds a

939
00:37:27,240 --> 00:37:29,460
cache design that really solves every

940
00:37:29,460 --> 00:37:31,800
Everything once and for all maybe one of

941
00:37:31,800 --> 00:37:34,020
the last three or some of the Precision

942
00:37:34,020 --> 00:37:36,900
are already perfectly secure well we had

943
00:37:36,900 --> 00:37:40,079
in some cases where it said 100 years

944
00:37:40,079 --> 00:37:43,079
security or security until the End of

945
00:37:43,079 --> 00:37:45,240
the Universe and then the 100 years

946
00:37:45,240 --> 00:37:46,920
later on

947
00:37:46,920 --> 00:37:49,680
turned out to be five seconds and so I

948
00:37:49,680 --> 00:37:51,240
guess the last question is

949
00:37:51,240 --> 00:37:54,240
will we ever see that real CPUs yeah but

950
00:37:54,240 --> 00:37:56,240
I guess we have to ask Intel there and

951
00:37:56,240 --> 00:37:59,700
is anyone here from here

952
00:37:59,700 --> 00:38:01,140
you want to build something like this

953
00:38:01,140 --> 00:38:03,359
we've heard it's hard to build than it

954
00:38:03,359 --> 00:38:05,339
is to write a paper about it

955
00:38:05,339 --> 00:38:07,680
but we're unsure yeah

956
00:38:07,680 --> 00:38:10,500
okay yeah so that was our outlook on

957
00:38:10,500 --> 00:38:13,240
secure cache designs thank you

958
00:38:13,240 --> 00:38:16,390
[Applause]

959
00:38:16,390 --> 00:38:19,489
[Music]

