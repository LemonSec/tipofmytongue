1
00:00:09,230 --> 00:00:17,200
<font color="#E5E5E5">okay following</font><font color="#CCCCCC"> Clementine and Daniel is</font>

2
00:00:12,889 --> 00:00:20,619
a pretty<font color="#E5E5E5"> tough act to follow</font>

3
00:00:17,200 --> 00:00:22,689
it does have some<font color="#CCCCCC"> advantages as though</font>

4
00:00:20,619 --> 00:00:25,009
<font color="#CCCCCC">Clementine and Daniel spoke</font><font color="#E5E5E5"> a lot about</font>

5
00:00:22,689 --> 00:00:27,380
<font color="#E5E5E5">mitigations from row hammer and I have</font>

6
00:00:25,009 --> 00:00:29,060
blogged extensively on<font color="#E5E5E5"> the subject</font><font color="#CCCCCC"> so if</font>

7
00:00:27,380 --> 00:00:31,429
you're<font color="#CCCCCC"> interested in why the mitigations</font>

8
00:00:29,060 --> 00:00:33,820
don't really work<font color="#CCCCCC"> come see me after the</font>

9
00:00:31,429 --> 00:00:36,470
<font color="#E5E5E5">talk</font><font color="#CCCCCC"> anyways</font>

10
00:00:33,820 --> 00:00:38,600
I'll be talking<font color="#E5E5E5"> about how we you can use</font>

11
00:00:36,470 --> 00:00:41,930
micro architectural design to break

12
00:00:38,600 --> 00:00:45,500
kernel-mode address space layout

13
00:00:41,930 --> 00:00:47,180
randomization<font color="#CCCCCC"> and a bit more</font><font color="#E5E5E5"> and I'll</font>

14
00:00:45,500 --> 00:00:50,840
try to be<font color="#E5E5E5"> painting a bigger picture of</font>

15
00:00:47,180 --> 00:00:53,600
<font color="#E5E5E5">what is</font><font color="#CCCCCC"> happening</font><font color="#E5E5E5"> here</font><font color="#CCCCCC"> so this</font><font color="#E5E5E5"> talk is</font>

16
00:00:50,840 --> 00:00:56,690
<font color="#E5E5E5">about</font><font color="#CCCCCC"> microarchitecture</font><font color="#E5E5E5"> attacks on</font><font color="#CCCCCC"> KRS</font>

17
00:00:53,600 --> 00:00:58,910
cell are<font color="#E5E5E5"> if you don't know what micro</font>

18
00:00:56,690 --> 00:01:00,709
<font color="#E5E5E5">architecture is it is the implementation</font>

19
00:00:58,910 --> 00:01:02,389
of architecture which leads to<font color="#E5E5E5"> the</font>

20
00:01:00,710 --> 00:01:05,089
natural question<font color="#CCCCCC"> what is</font><font color="#E5E5E5"> architecture</font>

21
00:01:02,390 --> 00:01:07,610
<font color="#E5E5E5">well architecture in this sense is what</font>

22
00:01:05,089 --> 00:01:10,580
<font color="#E5E5E5">cpu developers promises to software</font>

23
00:01:07,610 --> 00:01:12,530
developers and<font color="#E5E5E5"> micro architecture is how</font>

24
00:01:10,580 --> 00:01:14,060
that<font color="#CCCCCC"> is</font><font color="#E5E5E5"> implemented there are some</font>

25
00:01:12,530 --> 00:01:15,410
leeway<font color="#E5E5E5"> and how you can implement the</font>

26
00:01:14,060 --> 00:01:18,789
micro architecture<font color="#CCCCCC"> whereas the</font>

27
00:01:15,410 --> 00:01:22,220
<font color="#CCCCCC">architecture is</font><font color="#E5E5E5"> promised and described</font>

28
00:01:18,789 --> 00:01:26,000
<font color="#E5E5E5">KRS</font><font color="#CCCCCC"> cell are coma</font><font color="#E5E5E5"> mode address space</font>

29
00:01:22,220 --> 00:01:27,649
<font color="#E5E5E5">randomized layout randomizes addresses</font>

30
00:01:26,000 --> 00:01:29,959
in the kernel to prevent exploits on the

31
00:01:27,649 --> 00:01:31,459
kernel will go into<font color="#E5E5E5"> a bit</font><font color="#CCCCCC"> more about how</font>

32
00:01:29,959 --> 00:01:35,330
that<font color="#E5E5E5"> works in a moment</font>

33
00:01:31,459 --> 00:01:36,830
and when<font color="#CCCCCC"> our use the word design in the</font>

34
00:01:35,330 --> 00:01:40,729
title of this talk I actually mean it

35
00:01:36,830 --> 00:01:42,380
it's<font color="#E5E5E5"> not</font><font color="#CCCCCC"> just to sell the talk the thing</font>

36
00:01:40,729 --> 00:01:45,170
about these micro architecture is that<font color="#CCCCCC"> a</font>

37
00:01:42,380 --> 00:01:48,410
lot of energy goes into<font color="#E5E5E5"> designing the</font>

38
00:01:45,170 --> 00:01:50,479
micro architecture of a CPU<font color="#E5E5E5"> and the</font>

39
00:01:48,410 --> 00:01:53,179
features that we end<font color="#E5E5E5"> up using to break</font>

40
00:01:50,479 --> 00:01:55,700
this these things or<font color="#CCCCCC"> actually</font><font color="#E5E5E5"> decisions</font>

41
00:01:53,179 --> 00:01:58,280
that<font color="#E5E5E5"> are made by design they</font><font color="#CCCCCC"> are meant</font>

42
00:01:55,700 --> 00:02:02,509
to<font color="#CCCCCC"> be there</font><font color="#E5E5E5"> they have some unfortunately</font>

43
00:01:58,280 --> 00:02:04,429
<font color="#E5E5E5">side effects that we can use</font><font color="#CCCCCC"> so in this</font>

44
00:02:02,509 --> 00:02:07,190
particular talk<font color="#E5E5E5"> I hope to paint a bigger</font>

45
00:02:04,429 --> 00:02:10,459
picture<font color="#CCCCCC"> this means</font><font color="#E5E5E5"> that I will not go as</font>

46
00:02:07,190 --> 00:02:12,440
much into details as I might like<font color="#CCCCCC"> it's</font>

47
00:02:10,459 --> 00:02:17,359
more<font color="#E5E5E5"> of an overview thing sort of like</font>

48
00:02:12,440 --> 00:02:19,010
the<font color="#E5E5E5"> last talk now</font><font color="#CCCCCC"> there is</font><font color="#E5E5E5"> one thing</font>

49
00:02:17,359 --> 00:02:21,130
that<font color="#CCCCCC"> I carry a doubt here I will</font><font color="#E5E5E5"> not</font>

50
00:02:19,010 --> 00:02:22,989
talk about<font color="#E5E5E5"> software attacks on</font>

51
00:02:21,130 --> 00:02:29,079
<font color="#E5E5E5">chrome own address space</font><font color="#CCCCCC"> randomized</font>

52
00:02:22,990 --> 00:02:31,500
layout<font color="#E5E5E5"> so I will mention</font><font color="#CCCCCC"> at</font><font color="#E5E5E5"> once though</font>

53
00:02:29,080 --> 00:02:34,120
<font color="#E5E5E5">but I won't talk</font><font color="#CCCCCC"> about it</font><font color="#E5E5E5"> in general</font>

54
00:02:31,500 --> 00:02:35,710
<font color="#CCCCCC">shabu</font><font color="#E5E5E5"> am</font><font color="#CCCCCC"> i my name</font><font color="#E5E5E5"> is Anders I'm a</font>

55
00:02:34,120 --> 00:02:38,050
<font color="#E5E5E5">principal security researcher for</font><font color="#CCCCCC"> DJI</font>

56
00:02:35,710 --> 00:02:40,240
<font color="#E5E5E5">advanced analytics</font><font color="#CCCCCC"> I used to be an</font>

57
00:02:38,050 --> 00:02:43,800
economist<font color="#E5E5E5"> with a hoppy and</font><font color="#CCCCCC"> nowadays you</font>

58
00:02:40,240 --> 00:02:43,800
can reach me on<font color="#CCCCCC"> Twitter or by email</font><font color="#E5E5E5"> the</font>

59
00:02:43,920 --> 00:02:48,220
<font color="#CCCCCC">grog things that I</font><font color="#E5E5E5"> learned assembly</font>

60
00:02:46,690 --> 00:02:50,320
language<font color="#CCCCCC"> because it was the only</font>

61
00:02:48,220 --> 00:02:53,020
functional language in Denmark<font color="#CCCCCC"> there</font><font color="#E5E5E5"> is</font>

62
00:02:50,320 --> 00:02:54,790
a matter of truth it to it so<font color="#E5E5E5"> you</font><font color="#CCCCCC"> here</font>

63
00:02:53,020 --> 00:02:59,320
we speak with a 16-bit<font color="#CCCCCC"> weighing is</font>

64
00:02:54,790 --> 00:03:01,120
because I'm old so paging in modern

65
00:02:59,320 --> 00:03:03,609
<font color="#E5E5E5">operating system function functions</font>

66
00:03:01,120 --> 00:03:07,240
pretty<font color="#E5E5E5"> much this way each process has</font>

67
00:03:03,610 --> 00:03:08,860
its own virtual address space and in

68
00:03:07,240 --> 00:03:10,360
<font color="#E5E5E5">this address space are the modules that</font>

69
00:03:08,860 --> 00:03:12,790
<font color="#E5E5E5">they're using in this picture we</font><font color="#CCCCCC"> have</font>

70
00:03:10,360 --> 00:03:15,760
calculus<font color="#CCCCCC"> and if you have a shared</font>

71
00:03:12,790 --> 00:03:17,890
<font color="#E5E5E5">library that both processes use they're</font>

72
00:03:15,760 --> 00:03:21,399
in there as well<font color="#E5E5E5"> and in all processes</font>

73
00:03:17,890 --> 00:03:23,170
<font color="#CCCCCC">you'll find a mapping</font><font color="#E5E5E5"> of the kernel the</font>

74
00:03:21,400 --> 00:03:25,990
kernel is protected here and<font color="#CCCCCC"> there's a</font>

75
00:03:23,170 --> 00:03:27,760
line<font color="#CCCCCC"> between them of</font><font color="#E5E5E5"> talked a bit about</font>

76
00:03:25,990 --> 00:03:30,820
how<font color="#CCCCCC"> that</font><font color="#E5E5E5"> line comes into play in a</font>

77
00:03:27,760 --> 00:03:34,899
moment they use the paging to map it to

78
00:03:30,820 --> 00:03:36,280
physical<font color="#CCCCCC"> memory and here is just</font><font color="#E5E5E5"> a black</font>

79
00:03:34,900 --> 00:03:38,350
box<font color="#CCCCCC"> we'll go into that in a moment</font>

80
00:03:36,280 --> 00:03:39,820
and<font color="#E5E5E5"> you can see that the shared library</font>

81
00:03:38,350 --> 00:03:44,140
as well<font color="#CCCCCC"> as</font><font color="#E5E5E5"> the kernel is only mapped</font>

82
00:03:39,820 --> 00:03:45,609
into physical memory<font color="#CCCCCC"> ones so the summary</font>

83
00:03:44,140 --> 00:03:48,250
here<font color="#CCCCCC"> is each process has its own virtual</font>

84
00:03:45,610 --> 00:03:50,320
address space paging<font color="#E5E5E5"> translators virtual</font>

85
00:03:48,250 --> 00:03:51,550
addresses to physical addresses<font color="#E5E5E5"> shared</font>

86
00:03:50,320 --> 00:03:54,670
libraries<font color="#E5E5E5"> mapped to the same physical</font>

87
00:03:51,550 --> 00:03:56,320
address<font color="#CCCCCC"> and the kernel in current</font>

88
00:03:54,670 --> 00:04:01,019
operating systems is mapped in each

89
00:03:56,320 --> 00:04:04,930
<font color="#E5E5E5">process so now how the black box works</font>

90
00:04:01,020 --> 00:04:07,630
<font color="#CCCCCC">we start at</font><font color="#E5E5E5"> the top</font><font color="#CCCCCC"> talk about the</font>

91
00:04:04,930 --> 00:04:08,890
virtual address<font color="#CCCCCC"> as listed here it's 48</font>

92
00:04:07,630 --> 00:04:09,970
<font color="#E5E5E5">bits and most of your software</font>

93
00:04:08,890 --> 00:04:14,230
<font color="#E5E5E5">developers out there will</font><font color="#CCCCCC"> know that</font>

94
00:04:09,970 --> 00:04:17,170
<font color="#E5E5E5">modern systems uses 64-bit pointers</font><font color="#CCCCCC"> the</font>

95
00:04:14,230 --> 00:04:20,680
secret<font color="#E5E5E5"> to this difference here is that</font>

96
00:04:17,170 --> 00:04:23,500
<font color="#E5E5E5">the upper 16 bit is actually only</font>

97
00:04:20,680 --> 00:04:26,410
decorations<font color="#E5E5E5"> they take the same value</font><font color="#CCCCCC"> as</font>

98
00:04:23,500 --> 00:04:28,720
the<font color="#E5E5E5"> 47th bit meaning that you will never</font>

99
00:04:26,410 --> 00:04:32,760
<font color="#E5E5E5">have</font><font color="#CCCCCC"> an address with a bit that is not 0</font>

100
00:04:28,720 --> 00:04:35,169
or<font color="#E5E5E5"> 1 in the upper 16 bit just decoration</font>

101
00:04:32,760 --> 00:04:38,409
<font color="#CCCCCC">this is why we</font>

102
00:04:35,169 --> 00:04:41,289
virtual address<font color="#E5E5E5"> space is 48 bits so</font>

103
00:04:38,409 --> 00:04:44,590
paging starts with the<font color="#E5E5E5"> CI 3 that's a</font>

104
00:04:41,289 --> 00:04:49,628
<font color="#CCCCCC">controlled register in the</font><font color="#E5E5E5"> input line</font>

105
00:04:44,590 --> 00:04:52,029
CPUs and each process has<font color="#CCCCCC"> a</font><font color="#E5E5E5"> own value</font>

106
00:04:49,629 --> 00:04:54,879
for this register and this register

107
00:04:52,029 --> 00:04:56,110
chooses a table to which to start<font color="#E5E5E5"> the</font>

108
00:04:54,879 --> 00:05:00,009
translation<font color="#E5E5E5"> from physical to</font><font color="#CCCCCC"> virtual</font>

109
00:04:56,110 --> 00:05:03,909
addresses in this table goes the upper

110
00:05:00,009 --> 00:05:07,479
<font color="#CCCCCC">nine</font><font color="#E5E5E5"> vid of the virtual address as you</font>

111
00:05:03,909 --> 00:05:11,919
can see it's<font color="#E5E5E5"> marked green what comes out</font>

112
00:05:07,479 --> 00:05:14,800
from<font color="#CCCCCC"> this table</font><font color="#E5E5E5"> lookup is the table for</font>

113
00:05:11,919 --> 00:05:17,830
the next<font color="#E5E5E5"> lookup the</font><font color="#CCCCCC"> entry in the next</font>

114
00:05:14,800 --> 00:05:21,039
table is the blue<font color="#E5E5E5"> and this goes on</font><font color="#CCCCCC"> until</font>

115
00:05:17,830 --> 00:05:24,698
we reaches the last table<font color="#E5E5E5"> with the page</font>

116
00:05:21,039 --> 00:05:26,438
table<font color="#E5E5E5"> where we</font><font color="#CCCCCC"> actually gets the</font>

117
00:05:24,699 --> 00:05:28,449
physical address maybe you saw it<font color="#E5E5E5"> in the</font>

118
00:05:26,439 --> 00:05:30,550
in<font color="#CCCCCC"> Daniel and Clementine slides as well</font>

119
00:05:28,449 --> 00:05:33,159
<font color="#E5E5E5">here you get the</font><font color="#CCCCCC"> physical address the</font>

120
00:05:30,550 --> 00:05:36,580
lower 12 bits however are identical

121
00:05:33,159 --> 00:05:38,800
between the physical<font color="#E5E5E5"> and virtual</font>

122
00:05:36,580 --> 00:05:41,800
addresses<font color="#E5E5E5"> and this is what makes up a</font>

123
00:05:38,800 --> 00:05:48,819
page<font color="#E5E5E5"> a page is typically 4096 kilobytes</font>

124
00:05:41,800 --> 00:05:51,729
<font color="#CCCCCC">and interesting thing here is</font><font color="#E5E5E5"> there are</font>

125
00:05:48,819 --> 00:05:55,750
<font color="#E5E5E5">other page sizes the just have bought</font>

126
00:05:51,729 --> 00:05:57,370
the each page table translation earlier

127
00:05:55,750 --> 00:05:59,289
then more<font color="#CCCCCC"> than twelve bits</font><font color="#E5E5E5"> are</font><font color="#CCCCCC"> in the</font>

128
00:05:57,370 --> 00:05:59,889
<font color="#E5E5E5">pages</font><font color="#CCCCCC"> I will not talk about that but</font><font color="#E5E5E5"> it</font>

129
00:05:59,289 --> 00:06:01,539
does<font color="#E5E5E5"> exist</font>

130
00:05:59,889 --> 00:06:07,120
I will just<font color="#E5E5E5"> in this talk assume that all</font>

131
00:06:01,539 --> 00:06:11,800
pages<font color="#E5E5E5"> are</font><font color="#CCCCCC"> four kilobytes</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> the last</font>

132
00:06:07,120 --> 00:06:13,779
entry in<font color="#CCCCCC"> the page table does</font><font color="#E5E5E5"> not only</font>

133
00:06:11,800 --> 00:06:18,009
include the physical<font color="#CCCCCC"> address</font><font color="#E5E5E5"> this is the</font>

134
00:06:13,779 --> 00:06:19,960
<font color="#E5E5E5">great part of the figure here in Daniel</font>

135
00:06:18,009 --> 00:06:22,360
<font color="#CCCCCC">in Clementi note it all has some ignored</font>

136
00:06:19,960 --> 00:06:24,520
parts that is<font color="#E5E5E5"> the red parts here it has</font>

137
00:06:22,360 --> 00:06:26,499
some parts<font color="#E5E5E5"> from management</font><font color="#CCCCCC"> I will not be</font>

138
00:06:24,520 --> 00:06:29,039
<font color="#E5E5E5">talking about those today</font><font color="#CCCCCC"> it also has</font>

139
00:06:26,499 --> 00:06:31,389
some parts that determines how the

140
00:06:29,039 --> 00:06:32,110
memory is<font color="#E5E5E5"> cache I will not be talking</font>

141
00:06:31,389 --> 00:06:34,029
<font color="#CCCCCC">about</font><font color="#E5E5E5"> that either</font>

142
00:06:32,110 --> 00:06:35,860
<font color="#E5E5E5">what I will be</font><font color="#CCCCCC"> talking</font><font color="#E5E5E5"> about is access</font>

143
00:06:34,029 --> 00:06:38,169
<font color="#CCCCCC">rights that</font><font color="#E5E5E5"> is the green parts the</font><font color="#CCCCCC"> three</font>

144
00:06:35,860 --> 00:06:41,669
bits related to access rights in the

145
00:06:38,169 --> 00:06:45,399
page table in a page<font color="#E5E5E5"> table entries and</font>

146
00:06:41,669 --> 00:06:48,190
they are the NX<font color="#E5E5E5"> bit which disables</font>

147
00:06:45,399 --> 00:06:48,729
execution for memory<font color="#CCCCCC"> it's the supervisor</font>

148
00:06:48,190 --> 00:06:50,680
user mode

149
00:06:48,729 --> 00:06:52,389
<font color="#CCCCCC">'but when</font><font color="#E5E5E5"> the bit is</font><font color="#CCCCCC"> set to one</font><font color="#E5E5E5"> only a</font>

150
00:06:50,680 --> 00:06:54,879
supervisor has access that is

151
00:06:52,389 --> 00:06:57,999
<font color="#CCCCCC">kernel-mode half axis</font><font color="#E5E5E5"> if the bit</font><font color="#CCCCCC"> isn't</font>

152
00:06:54,879 --> 00:07:00,699
<font color="#CCCCCC">set</font><font color="#E5E5E5"> of the user has access as well</font><font color="#CCCCCC"> and</font>

153
00:06:57,999 --> 00:07:02,589
then<font color="#E5E5E5"> there's the</font><font color="#CCCCCC"> read/write bit if the</font>

154
00:07:00,699 --> 00:07:05,680
bit is<font color="#E5E5E5"> set you can</font><font color="#CCCCCC"> also write the</font>

155
00:07:02,589 --> 00:07:10,180
content of this page<font color="#CCCCCC"> otherwise</font><font color="#E5E5E5"> you can</font>

156
00:07:05,680 --> 00:07:12,759
read it only so<font color="#CCCCCC"> security through this</font>

157
00:07:10,180 --> 00:07:15,249
paging systems<font color="#E5E5E5"> functions in the</font>

158
00:07:12,759 --> 00:07:17,229
following way if an<font color="#CCCCCC"> access is made by</font>

159
00:07:15,249 --> 00:07:18,669
code<font color="#E5E5E5"> running with user privileges to an</font>

160
00:07:17,229 --> 00:07:21,550
address<font color="#E5E5E5"> marked on the PT as we saw</font>

161
00:07:18,669 --> 00:07:23,258
before<font color="#CCCCCC"> a supervisor</font><font color="#E5E5E5"> then the page</font><font color="#CCCCCC"> fault</font>

162
00:07:21,550 --> 00:07:25,059
will<font color="#E5E5E5"> be thrown the</font><font color="#CCCCCC"> kernel gets a chance</font>

163
00:07:23,259 --> 00:07:29,199
<font color="#E5E5E5">to defend itself or handle the page</font>

164
00:07:25,059 --> 00:07:31,360
fault however<font color="#E5E5E5"> it likes the kernel in</font>

165
00:07:29,199 --> 00:07:35,080
each process<font color="#CCCCCC"> is protected from readwrite</font>

166
00:07:31,360 --> 00:07:37,180
access in this in the same<font color="#E5E5E5"> way on modern</font>

167
00:07:35,080 --> 00:07:39,580
<font color="#E5E5E5">operating system it's just</font><font color="#CCCCCC"> supervisor</font>

168
00:07:37,180 --> 00:07:42,699
fit in the<font color="#CCCCCC"> TTE that protects the kernel</font>

169
00:07:39,580 --> 00:07:47,979
<font color="#E5E5E5">from user</font><font color="#CCCCCC"> mode access</font><font color="#E5E5E5"> despite of it</font>

170
00:07:42,699 --> 00:07:50,139
being act mapped<font color="#E5E5E5"> in the process</font><font color="#CCCCCC"> this</font>

171
00:07:47,979 --> 00:07:52,330
kind of<font color="#CCCCCC"> system has a problem</font><font color="#E5E5E5"> and the</font>

172
00:07:50,139 --> 00:07:54,180
problem is<font color="#E5E5E5"> that the page tables</font>

173
00:07:52,330 --> 00:07:57,068
themselves<font color="#E5E5E5"> are stored in physical memory</font>

174
00:07:54,180 --> 00:07:59,499
access to<font color="#E5E5E5"> memory is really really slow</font>

175
00:07:57,069 --> 00:08:02,680
compared to<font color="#E5E5E5"> what modern processes is</font>

176
00:07:59,499 --> 00:08:04,270
capable of chewing through and<font color="#E5E5E5"> to this</font>

177
00:08:02,680 --> 00:08:06,039
problem<font color="#CCCCCC"> there's</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> microarchitecture</font>

178
00:08:04,270 --> 00:08:09,099
solution and the microarchitecture

179
00:08:06,039 --> 00:08:13,748
solution is recache the page table

180
00:08:09,099 --> 00:08:17,409
entries and they are<font color="#CCCCCC"> cached for each</font>

181
00:08:13,749 --> 00:08:21,550
core<font color="#E5E5E5"> in exactly the opposite</font><font color="#CCCCCC"> direction</font>

182
00:08:17,409 --> 00:08:24,870
<font color="#E5E5E5">that</font><font color="#CCCCCC"> the page table lookup goes</font><font color="#E5E5E5"> probably</font>

183
00:08:21,550 --> 00:08:29,050
the idea behind this is<font color="#CCCCCC"> that if we can</font>

184
00:08:24,870 --> 00:08:31,870
find a page<font color="#CCCCCC"> table entry in the caches</font>

185
00:08:29,050 --> 00:08:37,690
will save<font color="#E5E5E5"> more than if we find to say an</font>

186
00:08:31,870 --> 00:08:43,328
entry for a<font color="#E5E5E5"> higher level table also</font><font color="#CCCCCC"> and</font>

187
00:08:37,690 --> 00:08:45,190
of course has the<font color="#CCCCCC"> nevermind if it's not</font>

188
00:08:43,328 --> 00:08:48,160
found in<font color="#CCCCCC"> any of</font><font color="#E5E5E5"> these four level of</font>

189
00:08:45,190 --> 00:08:51,010
caches<font color="#E5E5E5"> the</font><font color="#CCCCCC"> lookup will actually be made</font>

190
00:08:48,160 --> 00:08:53,709
in physical memory<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is what you need</font>

191
00:08:51,010 --> 00:08:56,149
to the situation you need<font color="#E5E5E5"> to get</font><font color="#CCCCCC"> for</font>

192
00:08:53,709 --> 00:09:01,660
<font color="#CCCCCC">4ro hammer</font><font color="#E5E5E5"> exploited as you saw in the</font>

193
00:08:56,149 --> 00:09:05,750
last<font color="#E5E5E5"> talk</font><font color="#CCCCCC"> and then it will be slow so</font>

194
00:09:01,660 --> 00:09:07,459
<font color="#E5E5E5">let's move on to what and how does</font><font color="#CCCCCC"> KR is</font>

195
00:09:05,750 --> 00:09:10,250
a lot kernel-mode address space

196
00:09:07,459 --> 00:09:13,420
randomization work well<font color="#CCCCCC"> i'll do it by</font>

197
00:09:10,250 --> 00:09:16,970
<font color="#E5E5E5">example</font><font color="#CCCCCC"> say you know the</font><font color="#E5E5E5"> address of</font>

198
00:09:13,420 --> 00:09:20,420
<font color="#E5E5E5">relevant security relevant address in</font>

199
00:09:16,970 --> 00:09:22,850
the<font color="#CCCCCC"> kernel</font><font color="#E5E5E5"> say the</font><font color="#CCCCCC"> b test</font><font color="#E5E5E5"> signing enable</font>

200
00:09:20,420 --> 00:09:24,920
variable in the kernel<font color="#E5E5E5"> the example here</font>

201
00:09:22,850 --> 00:09:25,820
<font color="#E5E5E5">is not accidental and not something</font><font color="#CCCCCC"> i'm</font>

202
00:09:24,920 --> 00:09:28,310
pulling<font color="#CCCCCC"> out on my hat</font>

203
00:09:25,820 --> 00:09:30,079
in fact this variable used to exist in

204
00:09:28,310 --> 00:09:33,768
<font color="#E5E5E5">that fashion in the Windows kernel and</font>

205
00:09:30,079 --> 00:09:35,300
an apt group used an exploit to set this

206
00:09:33,769 --> 00:09:37,370
<font color="#CCCCCC">variable so</font><font color="#E5E5E5"> they could load their own</font>

207
00:09:35,300 --> 00:09:40,250
driver without having a certificate<font color="#E5E5E5"> for</font>

208
00:09:37,370 --> 00:09:43,550
it so it's not something<font color="#E5E5E5"> I'm pulling out</font>

209
00:09:40,250 --> 00:09:46,279
<font color="#CCCCCC">of</font><font color="#E5E5E5"> my hat</font><font color="#CCCCCC"> you would know the address if</font>

210
00:09:43,550 --> 00:09:49,880
you<font color="#E5E5E5"> just</font><font color="#CCCCCC"> disassembled the kernel at</font>

211
00:09:46,279 --> 00:09:52,130
least so if you have a<font color="#CCCCCC"> book that</font><font color="#E5E5E5"> allows</font>

212
00:09:49,880 --> 00:09:53,720
you to read write<font color="#E5E5E5"> anything anywhere</font>

213
00:09:52,130 --> 00:09:56,000
you'll be able to change<font color="#E5E5E5"> this variable</font>

214
00:09:53,720 --> 00:09:58,430
like the apt<font color="#E5E5E5"> group did and load your own</font>

215
00:09:56,000 --> 00:10:00,500
driver<font color="#E5E5E5"> into the kernel</font><font color="#CCCCCC"> despite of not</font>

216
00:09:58,430 --> 00:10:02,239
having a<font color="#E5E5E5"> valid certificate for it</font>

217
00:10:00,500 --> 00:10:04,850
historically the address of the kernel

218
00:10:02,240 --> 00:10:06,740
<font color="#E5E5E5">itself was hard-coded and with a</font>

219
00:10:04,850 --> 00:10:08,180
<font color="#E5E5E5">hard-coded kernel address the relative</font>

220
00:10:06,740 --> 00:10:10,370
via address<font color="#E5E5E5"> that you</font><font color="#CCCCCC"> can get with a</font>

221
00:10:08,180 --> 00:10:13,609
<font color="#CCCCCC">disassembly</font><font color="#E5E5E5"> you can figure out where</font>

222
00:10:10,370 --> 00:10:16,160
this<font color="#CCCCCC"> byte</font><font color="#E5E5E5"> is stored with</font><font color="#CCCCCC"> your rewrite it</font>

223
00:10:13,610 --> 00:10:18,920
<font color="#E5E5E5">anything anywhere but you can change the</font>

224
00:10:16,160 --> 00:10:22,010
variable and load<font color="#CCCCCC"> a driver</font><font color="#E5E5E5"> it's fairly</font>

225
00:10:18,920 --> 00:10:23,750
<font color="#CCCCCC">obvious that</font><font color="#E5E5E5"> is the deep I try to</font>

226
00:10:22,010 --> 00:10:25,790
illustrate<font color="#E5E5E5"> it in the figure on</font><font color="#CCCCCC"> the right</font>

227
00:10:23,750 --> 00:10:27,260
<font color="#E5E5E5">here in the kernel is loaded in the</font>

228
00:10:25,790 --> 00:10:30,260
kernel<font color="#E5E5E5"> mode part of the address</font><font color="#CCCCCC"> space</font>

229
00:10:27,260 --> 00:10:33,500
<font color="#E5E5E5">and the red dot is the address which you</font>

230
00:10:30,260 --> 00:10:35,930
will use<font color="#CCCCCC"> to disable</font><font color="#E5E5E5"> test</font><font color="#CCCCCC"> enable test</font>

231
00:10:33,500 --> 00:10:40,130
signing if you're an attacker

232
00:10:35,930 --> 00:10:41,689
so the idea to hide kernel space<font color="#E5E5E5"> kernel</font>

233
00:10:40,130 --> 00:10:44,990
address space layout randomization is

234
00:10:41,690 --> 00:10:46,640
well when we boot<font color="#E5E5E5"> the system</font><font color="#CCCCCC"> we load the</font>

235
00:10:44,990 --> 00:10:48,589
kernel at a different Android virtual

236
00:10:46,640 --> 00:10:52,370
address every time using the page tables

237
00:10:48,589 --> 00:10:54,230
to do that<font color="#CCCCCC"> so this means that</font><font color="#E5E5E5"> the</font>

238
00:10:52,370 --> 00:10:55,610
address you've got from the disassembly

239
00:10:54,230 --> 00:10:57,339
<font color="#CCCCCC">the relative address you get</font><font color="#E5E5E5"> from the</font>

240
00:10:55,610 --> 00:11:01,819
disassembly<font color="#E5E5E5"> won't help you anymore</font>

241
00:10:57,339 --> 00:11:04,610
if an attacker<font color="#E5E5E5"> guesses the wrong address</font>

242
00:11:01,819 --> 00:11:06,660
of the kernel<font color="#CCCCCC"> he will trigger a page</font>

243
00:11:04,610 --> 00:11:10,500
<font color="#CCCCCC">fold accessing memory that is not mapped</font>

244
00:11:06,660 --> 00:11:11,459
and usually<font color="#CCCCCC"> this system by the blue</font>

245
00:11:10,500 --> 00:11:12,720
screens<font color="#CCCCCC"> of sex Falls</font>

246
00:11:11,460 --> 00:11:16,170
depending on<font color="#E5E5E5"> what kind</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> system it is</font>

247
00:11:12,720 --> 00:11:18,390
turning the attack into<font color="#E5E5E5"> a</font>

248
00:11:16,170 --> 00:11:20,160
<font color="#CCCCCC">denial-of-service</font><font color="#E5E5E5"> instead of the system</font>

249
00:11:18,390 --> 00:11:21,810
getting owned that is the core idea

250
00:11:20,160 --> 00:11:25,620
<font color="#CCCCCC">behind</font><font color="#E5E5E5"> kernel address space layout</font>

251
00:11:21,810 --> 00:11:27,959
randomization<font color="#CCCCCC"> so to summarize the</font>

252
00:11:25,620 --> 00:11:30,450
background<font color="#E5E5E5"> the kernel is mapped in each</font>

253
00:11:27,960 --> 00:11:32,040
<font color="#E5E5E5">process user mode cannot access the</font>

254
00:11:30,450 --> 00:11:36,750
kernel<font color="#CCCCCC"> because it's marked as protected</font>

255
00:11:32,040 --> 00:11:38,550
by page tables the<font color="#CCCCCC"> KRS</font><font color="#E5E5E5"> Salar randomizes</font>

256
00:11:36,750 --> 00:11:41,250
the<font color="#E5E5E5"> page table where the page tables are</font>

257
00:11:38,550 --> 00:11:43,319
located<font color="#E5E5E5"> that should read the kernel</font>

258
00:11:41,250 --> 00:11:45,600
allocated so that an export cannot know

259
00:11:43,320 --> 00:11:48,630
where to attach something<font color="#E5E5E5"> that means</font>

260
00:11:45,600 --> 00:11:51,800
that even in the presence<font color="#CCCCCC"> of a</font><font color="#E5E5E5"> bug the</font>

261
00:11:48,630 --> 00:11:51,800
kernel is safe

262
00:11:52,290 --> 00:11:57,569
except I'm painting a picture here<font color="#E5E5E5"> this</font>

263
00:11:55,650 --> 00:11:59,750
<font color="#CCCCCC">is my favorite favorite painter bob ross</font>

264
00:11:57,570 --> 00:12:02,670
he likes to paint<font color="#CCCCCC"> pictures as well and</font>

265
00:11:59,750 --> 00:12:04,530
he famously<font color="#CCCCCC"> said there are no such thing</font>

266
00:12:02,670 --> 00:12:08,520
as<font color="#E5E5E5"> mistakes so this is not a mistake</font>

267
00:12:04,530 --> 00:12:11,250
this is<font color="#E5E5E5"> a happy little accident and the</font>

268
00:12:08,520 --> 00:12:14,370
happy little<font color="#E5E5E5"> accident was the</font><font color="#CCCCCC"> lens and</font>

269
00:12:11,250 --> 00:12:17,460
<font color="#E5E5E5">holes in 2013</font><font color="#CCCCCC"> from this</font><font color="#E5E5E5"> University here</font>

270
00:12:14,370 --> 00:12:21,420
<font color="#CCCCCC">and they figure it out</font><font color="#E5E5E5"> well we have</font>

271
00:12:17,460 --> 00:12:26,460
<font color="#E5E5E5">these caches what happens if a page is</font>

272
00:12:21,420 --> 00:12:28,079
<font color="#E5E5E5">cached and we all know why caches are</font>

273
00:12:26,460 --> 00:12:29,970
there<font color="#E5E5E5"> they're there</font><font color="#CCCCCC"> to make it faster so</font>

274
00:12:28,080 --> 00:12:35,490
<font color="#CCCCCC">we would think that</font><font color="#E5E5E5"> if a page is</font><font color="#CCCCCC"> capital</font>

275
00:12:29,970 --> 00:12:37,710
accessing it<font color="#CCCCCC"> would be faster and so it</font>

276
00:12:35,490 --> 00:12:40,110
is if we measure how<font color="#E5E5E5"> long</font><font color="#CCCCCC"> it takes</font><font color="#E5E5E5"> to</font>

277
00:12:37,710 --> 00:12:43,770
<font color="#CCCCCC">access a page depending</font><font color="#E5E5E5"> on at which</font>

278
00:12:40,110 --> 00:12:45,930
level the entries<font color="#CCCCCC"> in the page tables our</font>

279
00:12:43,770 --> 00:12:48,990
cache will get<font color="#E5E5E5"> different timings the</font>

280
00:12:45,930 --> 00:12:51,900
large blue column on the right side of

281
00:12:48,990 --> 00:12:53,040
your<font color="#CCCCCC"> screen is the uncashed</font><font color="#E5E5E5"> time you can</font>

282
00:12:51,900 --> 00:12:57,420
see that is significantly higher than

283
00:12:53,040 --> 00:12:59,280
<font color="#E5E5E5">the other times other access times</font><font color="#CCCCCC"> so</font>

284
00:12:57,420 --> 00:13:01,199
how do you measure<font color="#E5E5E5"> is the time of a page</font>

285
00:12:59,280 --> 00:13:03,540
<font color="#E5E5E5">false the time that it takes for the</font>

286
00:13:01,200 --> 00:13:05,790
system to<font color="#CCCCCC"> traverse the page tables</font><font color="#E5E5E5"> and</font>

287
00:13:03,540 --> 00:13:08,160
find out that there's<font color="#CCCCCC"> no access</font><font color="#E5E5E5"> rights</font>

288
00:13:05,790 --> 00:13:09,920
<font color="#E5E5E5">to access this process well you do it</font>

289
00:13:08,160 --> 00:13:12,719
with code<font color="#CCCCCC"> that looks</font><font color="#E5E5E5"> something like this</font>

290
00:13:09,920 --> 00:13:15,300
you start<font color="#CCCCCC"> a tile you get the current</font>

291
00:13:12,720 --> 00:13:17,190
time<font color="#E5E5E5"> and clock cycles then you access</font>

292
00:13:15,300 --> 00:13:17,880
the kernel address a page fault is

293
00:13:17,190 --> 00:13:20,820
thrown

294
00:13:17,880 --> 00:13:23,400
and you grab the page fold in an

295
00:13:20,820 --> 00:13:24,840
exception<font color="#CCCCCC"> Handler and read the</font><font color="#E5E5E5"> time</font>

296
00:13:23,400 --> 00:13:30,630
<font color="#E5E5E5">stamp</font><font color="#CCCCCC"> again and then you know how long</font>

297
00:13:24,840 --> 00:13:31,920
it took<font color="#E5E5E5"> to read this kernel memory</font><font color="#CCCCCC"> so so</font>

298
00:13:30,630 --> 00:13:34,620
how does<font color="#E5E5E5"> a</font><font color="#CCCCCC"> double-page</font><font color="#E5E5E5"> fold attack</font>

299
00:13:31,920 --> 00:13:37,260
<font color="#E5E5E5">basically work well your time accessing</font>

300
00:13:34,620 --> 00:13:40,700
<font color="#E5E5E5">a kernel mode address from user mode it</font>

301
00:13:37,260 --> 00:13:44,100
has<font color="#CCCCCC"> to do the page table translations</font>

302
00:13:40,700 --> 00:13:46,710
<font color="#CCCCCC">this has two effects the</font><font color="#E5E5E5"> first is it</font>

303
00:13:44,100 --> 00:13:48,120
loads<font color="#E5E5E5"> the paging caches and the second</font>

304
00:13:46,710 --> 00:13:49,470
is<font color="#CCCCCC"> the triggers a page fault but</font><font color="#E5E5E5"> is</font>

305
00:13:48,120 --> 00:13:51,050
thrown<font color="#E5E5E5"> down to user mode so you can</font>

306
00:13:49,470 --> 00:13:54,570
measure the<font color="#CCCCCC"> time as we just</font><font color="#E5E5E5"> saw in</font><font color="#CCCCCC"> code</font>

307
00:13:51,050 --> 00:13:57,359
this generates a baseline for<font color="#CCCCCC"> how long</font>

308
00:13:54,570 --> 00:14:01,220
it takes to<font color="#E5E5E5"> do an</font><font color="#CCCCCC"> uncashed</font><font color="#E5E5E5"> access to the</font>

309
00:13:57,360 --> 00:14:04,290
kernel memory<font color="#CCCCCC"> so now we do it</font><font color="#E5E5E5"> again and</font>

310
00:14:01,220 --> 00:14:08,670
remember we<font color="#E5E5E5"> let just loaded the paging</font>

311
00:14:04,290 --> 00:14:10,589
caches<font color="#E5E5E5"> so we should think that the</font>

312
00:14:08,670 --> 00:14:12,380
second time we access the address<font color="#E5E5E5"> it'll</font>

313
00:14:10,590 --> 00:14:17,070
<font color="#E5E5E5">be faster than the first time</font>

314
00:14:12,380 --> 00:14:18,870
except non map pages<font color="#E5E5E5"> does not get cached</font>

315
00:14:17,070 --> 00:14:21,420
<font color="#CCCCCC">meaning</font><font color="#E5E5E5"> that we</font><font color="#CCCCCC"> have a timing difference</font>

316
00:14:18,870 --> 00:14:22,200
here if the second time is faster than

317
00:14:21,420 --> 00:14:24,240
<font color="#E5E5E5">the first address</font>

318
00:14:22,200 --> 00:14:27,300
well then probably<font color="#E5E5E5"> this address is</font>

319
00:14:24,240 --> 00:14:30,090
mapped and then the attack goes<font color="#CCCCCC"> on it</font>

320
00:14:27,300 --> 00:14:33,660
just<font color="#CCCCCC"> repeats</font><font color="#E5E5E5"> step</font><font color="#CCCCCC"> one through three for</font>

321
00:14:30,090 --> 00:14:36,120
all possible kernel addresses and from

322
00:14:33,660 --> 00:14:39,380
the pattern of mapped on<font color="#CCCCCC"> pattern</font><font color="#E5E5E5"> pages</font>

323
00:14:36,120 --> 00:14:45,510
we can<font color="#CCCCCC"> actually tell where the kernel</font><font color="#E5E5E5"> is</font>

324
00:14:39,380 --> 00:14:48,000
so<font color="#E5E5E5"> execution time on modern multi-core</font>

325
00:14:45,510 --> 00:14:50,010
CPUs are not deterministic<font color="#E5E5E5"> there is</font>

326
00:14:48,000 --> 00:14:51,870
<font color="#E5E5E5">slight variation depending on which</font>

327
00:14:50,010 --> 00:14:56,490
order<font color="#E5E5E5"> the instruction comes in how the</font>

328
00:14:51,870 --> 00:15:00,000
<font color="#E5E5E5">DRAM is working or not so there is a</font>

329
00:14:56,490 --> 00:15:04,320
tiny<font color="#CCCCCC"> bit of noise in execution times on</font>

330
00:15:00,000 --> 00:15:06,300
<font color="#CCCCCC">one CPUs this particular attack</font><font color="#E5E5E5"> raises a</font>

331
00:15:04,320 --> 00:15:08,220
page fault<font color="#E5E5E5"> and forwards it to user mode</font>

332
00:15:06,300 --> 00:15:09,930
<font color="#E5E5E5">and this has a lot</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> overhead in it</font>

333
00:15:08,220 --> 00:15:11,070
there's a lot of code<font color="#CCCCCC"> to be executed and</font>

334
00:15:09,930 --> 00:15:13,079
there's a lot of<font color="#E5E5E5"> stuff going on with</font>

335
00:15:11,070 --> 00:15:15,020
interruptions<font color="#CCCCCC"> things like that meaning</font>

336
00:15:13,080 --> 00:15:18,300
<font color="#CCCCCC">that there's a lot of</font><font color="#E5E5E5"> space where these</font>

337
00:15:15,020 --> 00:15:19,800
tiny<font color="#E5E5E5"> random noise can add up meaning</font>

338
00:15:18,300 --> 00:15:23,400
<font color="#CCCCCC">that the result</font><font color="#E5E5E5"> that we get is very</font>

339
00:15:19,800 --> 00:15:25,140
noisy<font color="#E5E5E5"> the solution to this problem is we</font>

340
00:15:23,400 --> 00:15:28,439
<font color="#CCCCCC">just repeat the attack again and</font><font color="#E5E5E5"> again</font>

341
00:15:25,140 --> 00:15:31,010
<font color="#CCCCCC">and rely on this lots of large numbers</font>

342
00:15:28,440 --> 00:15:32,930
and statistics<font color="#CCCCCC"> assess if we have enough</font>

343
00:15:31,010 --> 00:15:34,939
sedation we will be able<font color="#CCCCCC"> to figure out</font>

344
00:15:32,930 --> 00:15:37,279
the real<font color="#CCCCCC"> meaning given</font><font color="#E5E5E5"> that we have</font>

345
00:15:34,940 --> 00:15:41,540
<font color="#CCCCCC">independent observations which</font><font color="#E5E5E5"> we'll</font>

346
00:15:37,279 --> 00:15:45,649
have<font color="#E5E5E5"> in this case so</font><font color="#CCCCCC"> attacks work kind</font>

347
00:15:41,540 --> 00:15:47,930
of<font color="#E5E5E5"> well and it works in a</font><font color="#CCCCCC"> couple of</font>

348
00:15:45,649 --> 00:15:49,579
minutes and we can be randomized the

349
00:15:47,930 --> 00:15:52,219
<font color="#CCCCCC">kernel and we can run our attack again</font>

350
00:15:49,579 --> 00:15:56,269
<font color="#E5E5E5">if we have the buck for it</font>

351
00:15:52,220 --> 00:15:58,790
it is<font color="#CCCCCC"> however relatively</font><font color="#E5E5E5"> easy to fix</font>

352
00:15:56,269 --> 00:16:00,290
when<font color="#CCCCCC"> pitch roll</font><font color="#E5E5E5"> thrown the callback is</font>

353
00:15:58,790 --> 00:16:02,990
made into<font color="#E5E5E5"> the kernel and the kernel gets</font>

354
00:16:00,290 --> 00:16:04,459
a chance to<font color="#E5E5E5"> handle a page fold and among</font>

355
00:16:02,990 --> 00:16:07,760
the information<font color="#CCCCCC"> that the kernel gets to</font>

356
00:16:04,459 --> 00:16:10,719
process page fault<font color="#E5E5E5"> is the address where</font>

357
00:16:07,760 --> 00:16:12,889
the page fault<font color="#E5E5E5"> happened and if this</font>

358
00:16:10,720 --> 00:16:16,160
address<font color="#CCCCCC"> turns</font><font color="#E5E5E5"> out to be a kernel</font>

359
00:16:12,889 --> 00:16:18,170
mattress and the client who cost the

360
00:16:16,160 --> 00:16:20,029
page fault<font color="#CCCCCC"> is a user mode application</font>

361
00:16:18,170 --> 00:16:23,329
then<font color="#CCCCCC"> we are</font><font color="#E5E5E5"> probably looking at double</font>

362
00:16:20,029 --> 00:16:25,760
page fault<font color="#E5E5E5"> the attack because</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> tends</font>

363
00:16:23,329 --> 00:16:27,380
<font color="#CCCCCC">to be that user mode application does</font>

364
00:16:25,760 --> 00:16:30,620
<font color="#CCCCCC">not try to access the kernel because</font>

365
00:16:27,380 --> 00:16:32,240
that<font color="#E5E5E5"> just causes</font><font color="#CCCCCC"> fault</font>

366
00:16:30,620 --> 00:16:34,250
so if it<font color="#E5E5E5"> happens a lot we can start</font>

367
00:16:32,240 --> 00:16:36,410
buggering around with<font color="#CCCCCC"> the client</font><font color="#E5E5E5"> that is</font>

368
00:16:34,250 --> 00:16:38,959
doing this they terminate the process<font color="#E5E5E5"> or</font>

369
00:16:36,410 --> 00:16:40,370
at<font color="#E5E5E5"> noise</font><font color="#CCCCCC"> whatever we like</font><font color="#E5E5E5"> to do and if</font>

370
00:16:38,959 --> 00:16:43,219
it isn't with<font color="#E5E5E5"> your channel page for the</font>

371
00:16:40,370 --> 00:16:47,690
way we actually<font color="#E5E5E5"> usually do it so we can</font>

372
00:16:43,220 --> 00:16:50,930
<font color="#CCCCCC">easily fix the double page fault so with</font>

373
00:16:47,690 --> 00:16:54,079
this<font color="#E5E5E5"> fix</font><font color="#CCCCCC"> we're safe even if there's a</font>

374
00:16:50,930 --> 00:16:55,459
bug even if the double page fault<font color="#E5E5E5"> even</font>

375
00:16:54,079 --> 00:16:58,899
<font color="#CCCCCC">if the attacker knows</font><font color="#E5E5E5"> the double page</font>

376
00:16:55,459 --> 00:17:00,739
for the tech well get kind<font color="#E5E5E5"> of</font>

377
00:16:58,899 --> 00:17:06,760
interesting here<font color="#CCCCCC"> because there was a</font>

378
00:17:00,740 --> 00:17:10,429
<font color="#E5E5E5">happy</font><font color="#CCCCCC"> little accident and this is</font><font color="#E5E5E5"> tsx</font>

379
00:17:06,760 --> 00:17:12,760
yang<font color="#CCCCCC"> Lee and</font><font color="#E5E5E5"> Kim in 2016</font><font color="#CCCCCC"> percentage ant</font>

380
00:17:10,429 --> 00:17:15,319
<font color="#CCCCCC">a Kroenke SLR</font><font color="#E5E5E5"> but</font><font color="#CCCCCC"> use TSX</font>

381
00:17:12,760 --> 00:17:17,890
TSX<font color="#E5E5E5"> was added with hash ville</font>

382
00:17:15,319 --> 00:17:19,970
microarchitecture so it's relatively<font color="#E5E5E5"> new</font>

383
00:17:17,890 --> 00:17:22,970
<font color="#E5E5E5">TSX tans for transitional</font>

384
00:17:19,970 --> 00:17:26,809
<font color="#E5E5E5">synchronization extensions and the</font>

385
00:17:22,970 --> 00:17:28,549
purpose here is synchronization<font color="#CCCCCC"> imagine</font>

386
00:17:26,809 --> 00:17:30,860
two<font color="#E5E5E5"> threads accessing the same variable</font>

387
00:17:28,549 --> 00:17:32,809
one of them is<font color="#E5E5E5"> writing and if this</font>

388
00:17:30,860 --> 00:17:35,740
happens<font color="#CCCCCC"> simultaneously say on multiple</font>

389
00:17:32,809 --> 00:17:39,260
course then inconsistencies<font color="#CCCCCC"> can arise</font>

390
00:17:35,740 --> 00:17:42,180
because<font color="#CCCCCC"> a solution for inconsistency of</font>

391
00:17:39,260 --> 00:17:44,700
<font color="#E5E5E5">this nature is synchronization</font>

392
00:17:42,180 --> 00:17:47,490
say you take semaphore events stuff like

393
00:17:44,700 --> 00:17:49,440
that<font color="#E5E5E5"> this is usually</font><font color="#CCCCCC"> very slow because</font>

394
00:17:47,490 --> 00:17:52,440
the<font color="#E5E5E5"> scheduler gets involved and</font><font color="#CCCCCC"> stuff</font>

395
00:17:49,440 --> 00:17:54,600
like that<font color="#CCCCCC"> and another</font><font color="#E5E5E5"> way that</font><font color="#CCCCCC"> has</font><font color="#E5E5E5"> been</font>

396
00:17:52,440 --> 00:17:57,900
classically<font color="#CCCCCC"> solve</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> locks you lock the</font>

397
00:17:54,600 --> 00:17:59,159
entire<font color="#CCCCCC"> memory bus and</font><font color="#E5E5E5"> that is</font><font color="#CCCCCC"> usually a</font>

398
00:17:57,900 --> 00:18:00,990
bit faster than<font color="#CCCCCC"> mute assistant</font>

399
00:17:59,160 --> 00:18:03,600
semaphores but it's still pretty slow<font color="#CCCCCC"> in</font>

400
00:18:00,990 --> 00:18:05,490
1924<font color="#E5E5E5"> cause working on a database and all</font>

401
00:18:03,600 --> 00:18:07,469
of a<font color="#CCCCCC"> sudden they can't do any memory</font>

402
00:18:05,490 --> 00:18:10,470
accesses until the<font color="#CCCCCC"> synchronize access is</font>

403
00:18:07,470 --> 00:18:15,270
done and this is what<font color="#CCCCCC"> TSX tries to solve</font>

404
00:18:10,470 --> 00:18:17,490
<font color="#E5E5E5">they simple they simply try to do the</font>

405
00:18:15,270 --> 00:18:20,220
<font color="#E5E5E5">memory access and detect if there's any</font>

406
00:18:17,490 --> 00:18:21,840
simultaneous operation simultaneous if

407
00:18:20,220 --> 00:18:24,150
they're<font color="#E5E5E5"> saying it's emulation action</font>

408
00:18:21,840 --> 00:18:27,570
that<font color="#E5E5E5"> will avoid it</font><font color="#CCCCCC"> and reset it</font><font color="#E5E5E5"> and let</font>

409
00:18:24,150 --> 00:18:29,540
you retry it and the thing is true

410
00:18:27,570 --> 00:18:33,600
simultaneous access<font color="#E5E5E5"> is rather rare and</font>

411
00:18:29,540 --> 00:18:37,139
this ends up meaning<font color="#E5E5E5"> that only rarely</font>

412
00:18:33,600 --> 00:18:39,449
will TSX really abort<font color="#CCCCCC"> synchronous access</font>

413
00:18:37,140 --> 00:18:44,400
and this turns out<font color="#E5E5E5"> to</font><font color="#CCCCCC"> be much much</font>

414
00:18:39,450 --> 00:18:48,920
<font color="#E5E5E5">faster</font><font color="#CCCCCC"> than say locking the bus so how</font>

415
00:18:44,400 --> 00:18:52,020
can we time an abort in<font color="#E5E5E5"> Tia in TSX well</font>

416
00:18:48,920 --> 00:18:55,080
here we now have<font color="#CCCCCC"> this wonderful if</font>

417
00:18:52,020 --> 00:18:57,389
statement instead<font color="#E5E5E5"> of</font><font color="#CCCCCC"> the try accept and</font>

418
00:18:55,080 --> 00:18:59,540
otherwise everything looks exactly<font color="#E5E5E5"> the</font>

419
00:18:57,390 --> 00:18:59,540
same

420
00:18:59,820 --> 00:19:06,419
why is TSX cool for<font color="#CCCCCC"> breaking ksl</font><font color="#E5E5E5"> are</font>

421
00:19:02,610 --> 00:19:07,770
well<font color="#E5E5E5"> if access is illegal that is user</font>

422
00:19:06,420 --> 00:19:12,179
mode<font color="#E5E5E5"> trying to</font><font color="#CCCCCC"> access the kernel mode</font>

423
00:19:07,770 --> 00:19:14,370
<font color="#CCCCCC">tiers</font><font color="#E5E5E5"> X will abort without generating a</font>

424
00:19:12,179 --> 00:19:17,429
page fault<font color="#E5E5E5"> meaning that the page fault</font>

425
00:19:14,370 --> 00:19:20,040
is gone the first cool thing about this

426
00:19:17,429 --> 00:19:20,760
<font color="#E5E5E5">is that will get less noise because we</font>

427
00:19:20,040 --> 00:19:23,220
have<font color="#E5E5E5"> less overhead</font>

428
00:19:20,760 --> 00:19:24,900
did you<font color="#E5E5E5"> talk is much</font><font color="#CCCCCC"> faster and the</font>

429
00:19:23,220 --> 00:19:27,360
mitigation not<font color="#E5E5E5"> address</font><font color="#CCCCCC"> presented you for</font>

430
00:19:24,900 --> 00:19:29,040
the double<font color="#E5E5E5"> page fold will not work</font>

431
00:19:27,360 --> 00:19:32,428
because<font color="#E5E5E5"> the page fault handler does not</font>

432
00:19:29,040 --> 00:19:35,990
get called and it actually works<font color="#E5E5E5"> because</font>

433
00:19:32,429 --> 00:19:38,040
even though we're<font color="#CCCCCC"> in</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> gsx section</font>

434
00:19:35,990 --> 00:19:42,150
<font color="#CCCCCC">paging casters are still</font><font color="#E5E5E5"> loaded on</font>

435
00:19:38,040 --> 00:19:44,309
<font color="#E5E5E5">access</font><font color="#CCCCCC"> the half of another</font><font color="#E5E5E5"> advantage</font>

436
00:19:42,150 --> 00:19:47,130
<font color="#E5E5E5">theorem is if we access kernel mode</font>

437
00:19:44,309 --> 00:19:50,370
<font color="#E5E5E5">memory with a jump instruction it gets</font>

438
00:19:47,130 --> 00:19:52,440
<font color="#E5E5E5">different results on other memory access</font>

439
00:19:50,370 --> 00:19:54,209
meaning that<font color="#E5E5E5"> we're able to tell if</font>

440
00:19:52,440 --> 00:19:55,590
memory is marked as executable or not

441
00:19:54,210 --> 00:19:58,799
<font color="#E5E5E5">meaning that we could find</font>

442
00:19:55,590 --> 00:20:01,799
if given<font color="#E5E5E5"> page in the kernel is marked as</font>

443
00:19:58,799 --> 00:20:03,270
executable or not<font color="#E5E5E5"> so this gives us more</font>

444
00:20:01,799 --> 00:20:06,690
information<font color="#CCCCCC"> than a double</font><font color="#E5E5E5"> page</font><font color="#CCCCCC"> fault</font>

445
00:20:03,270 --> 00:20:09,720
attack<font color="#E5E5E5"> there are some</font><font color="#CCCCCC"> problems with the</font>

446
00:20:06,690 --> 00:20:11,789
<font color="#E5E5E5">W the</font><font color="#CCCCCC"> tsx attack</font><font color="#E5E5E5"> the first is that it</font>

447
00:20:09,720 --> 00:20:13,890
might<font color="#E5E5E5"> be possible</font><font color="#CCCCCC"> to detect the tsx</font>

448
00:20:11,789 --> 00:20:17,520
attack heuristically using performance

449
00:20:13,890 --> 00:20:21,539
counters the when an instruction causes

450
00:20:17,520 --> 00:20:27,120
an abort the<font color="#E5E5E5"> the number of events are</font>

451
00:20:21,539 --> 00:20:29,700
generated related to<font color="#CCCCCC"> TS x and when and</font>

452
00:20:27,120 --> 00:20:31,559
in all other<font color="#CCCCCC"> cases</font><font color="#E5E5E5"> the TLB lookup missus</font>

453
00:20:29,700 --> 00:20:33,210
event is<font color="#CCCCCC"> generated</font><font color="#E5E5E5"> we can measure those</font>

454
00:20:31,559 --> 00:20:35,158
with the performance counters<font color="#E5E5E5"> and we</font>

455
00:20:33,210 --> 00:20:39,149
have a possibility to heuristically

456
00:20:35,159 --> 00:20:41,610
<font color="#E5E5E5">detect</font><font color="#CCCCCC"> GS x</font><font color="#E5E5E5"> but probably the</font><font color="#CCCCCC"> most</font>

457
00:20:39,149 --> 00:20:44,489
important disadvantage<font color="#CCCCCC"> of TS x</font><font color="#E5E5E5"> attack is</font>

458
00:20:41,610 --> 00:20:48,240
that it's not very<font color="#CCCCCC"> common there are a</font>

459
00:20:44,490 --> 00:20:50,760
<font color="#E5E5E5">few i</font><font color="#CCCCCC"> 5qi 7s and a few c on computers</font>

460
00:20:48,240 --> 00:20:52,890
that<font color="#E5E5E5"> actually supports TS x meaning that</font>

461
00:20:50,760 --> 00:20:55,950
the real supported days of TS x is

462
00:20:52,890 --> 00:21:00,529
relatively small<font color="#E5E5E5"> meaning</font><font color="#CCCCCC"> that an end</font>

463
00:20:55,950 --> 00:21:04,399
effect<font color="#E5E5E5"> we are something like</font><font color="#CCCCCC"> almost safe</font>

464
00:21:00,529 --> 00:21:09,570
except that was a happy<font color="#CCCCCC"> little accident</font>

465
00:21:04,399 --> 00:21:12,570
so the<font color="#CCCCCC"> groups maurice in</font><font color="#E5E5E5"> two previous</font>

466
00:21:09,570 --> 00:21:14,100
<font color="#CCCCCC">speakers myself and two others figured</font>

467
00:21:12,570 --> 00:21:16,439
<font color="#E5E5E5">out</font><font color="#CCCCCC"> that there was a</font><font color="#E5E5E5"> previous</font>

468
00:21:14,100 --> 00:21:18,240
<font color="#E5E5E5">instruction in the instruction set of</font>

469
00:21:16,440 --> 00:21:20,520
into computers there are five<font color="#E5E5E5"> of them</font>

470
00:21:18,240 --> 00:21:23,279
<font color="#E5E5E5">and</font><font color="#CCCCCC"> they serve the purpose of</font><font color="#E5E5E5"> speeding</font>

471
00:21:20,520 --> 00:21:27,240
things up<font color="#E5E5E5"> and how do they do</font><font color="#CCCCCC"> that well</font>

472
00:21:23,279 --> 00:21:29,640
the prefetch tells the memory management

473
00:21:27,240 --> 00:21:32,820
<font color="#CCCCCC">system of the cpu</font><font color="#E5E5E5"> that this software</font>

474
00:21:29,640 --> 00:21:34,110
<font color="#CCCCCC">would</font><font color="#E5E5E5"> like to use this memory soon so</font>

475
00:21:32,820 --> 00:21:36,178
why will this work in the first<font color="#E5E5E5"> place</font>

476
00:21:34,110 --> 00:21:39,090
<font color="#E5E5E5">well</font><font color="#CCCCCC"> Manas if you use a multi scaler</font><font color="#E5E5E5"> a</font>

477
00:21:36,179 --> 00:21:41,370
superscalar<font color="#E5E5E5"> they can proceed with other</font>

478
00:21:39,090 --> 00:21:43,559
instructions while loading<font color="#E5E5E5"> the memory</font>

479
00:21:41,370 --> 00:21:45,209
<font color="#E5E5E5">meaning that we can tell in a moment</font>

480
00:21:43,559 --> 00:21:47,010
<font color="#CCCCCC">we'll need this memory please cache it</font>

481
00:21:45,210 --> 00:21:49,200
and then we can do other instructions

482
00:21:47,010 --> 00:21:50,940
until<font color="#CCCCCC"> we actually use the memory</font><font color="#E5E5E5"> so we</font>

483
00:21:49,200 --> 00:21:54,240
have a speed over here<font color="#E5E5E5"> that is the</font>

484
00:21:50,940 --> 00:21:56,220
purpose<font color="#E5E5E5"> of the prefetch instruction</font>

485
00:21:54,240 --> 00:21:58,919
why is the prefetch instruction cool to

486
00:21:56,220 --> 00:22:01,080
break<font color="#CCCCCC"> kr Salar well prefetch</font>

487
00:21:58,919 --> 00:22:03,270
<font color="#CCCCCC">instructional</font><font color="#E5E5E5"> hints meaning they don't</font>

488
00:22:01,080 --> 00:22:06,240
<font color="#CCCCCC">cause false or</font><font color="#E5E5E5"> abort</font>

489
00:22:03,270 --> 00:22:07,320
they can't terminate completely silently

490
00:22:06,240 --> 00:22:09,930
instead

491
00:22:07,320 --> 00:22:11,730
however the prefetch<font color="#E5E5E5"> instructions also</font>

492
00:22:09,930 --> 00:22:15,050
<font color="#CCCCCC">need to traverse</font><font color="#E5E5E5"> the page tables and</font>

493
00:22:11,730 --> 00:22:18,540
<font color="#E5E5E5">they load a page in caches just as well</font>

494
00:22:15,050 --> 00:22:19,830
<font color="#E5E5E5">meaning that we can use the double page</font>

495
00:22:18,540 --> 00:22:24,540
<font color="#E5E5E5">hold attack</font><font color="#CCCCCC"> with the prefetch</font>

496
00:22:19,830 --> 00:22:26,460
instruction instead<font color="#E5E5E5"> and unlike the</font><font color="#CCCCCC"> tsx</font>

497
00:22:24,540 --> 00:22:28,290
<font color="#E5E5E5">the prefetch instructions are very very</font>

498
00:22:26,460 --> 00:22:32,250
<font color="#E5E5E5">old indeed they were introduced with</font>

499
00:22:28,290 --> 00:22:34,440
<font color="#CCCCCC">3dnow by AMD sometimes early</font>

500
00:22:32,250 --> 00:22:38,340
<font color="#CCCCCC">two-thousands I think and they are in</font>

501
00:22:34,440 --> 00:22:39,840
all current<font color="#E5E5E5"> CPUs</font><font color="#CCCCCC"> there is another</font>

502
00:22:38,340 --> 00:22:41,399
<font color="#CCCCCC">advantage to</font><font color="#E5E5E5"> the prefetch instruction</font>

503
00:22:39,840 --> 00:22:42,810
here<font color="#E5E5E5"> is prefetch instruction does not</font>

504
00:22:41,400 --> 00:22:44,670
match<font color="#E5E5E5"> well with performance counters</font>

505
00:22:42,810 --> 00:22:46,710
<font color="#E5E5E5">there used to be performance counters</font>

506
00:22:44,670 --> 00:22:48,750
for<font color="#E5E5E5"> the prefetch instruction</font><font color="#CCCCCC"> they are</font>

507
00:22:46,710 --> 00:22:50,340
gone it seems like<font color="#CCCCCC"> int'l are happy that</font>

508
00:22:48,750 --> 00:22:51,240
<font color="#CCCCCC">we</font><font color="#E5E5E5"> can all optimize our software the</font>

509
00:22:50,340 --> 00:22:55,290
prefetch instructions<font color="#E5E5E5"> without</font>

510
00:22:51,240 --> 00:22:57,420
performance counters help so there<font color="#E5E5E5"> are</font>

511
00:22:55,290 --> 00:22:59,430
maps very poorly<font color="#CCCCCC"> - performance counters</font>

512
00:22:57,420 --> 00:23:02,910
mean<font color="#CCCCCC"> thing</font><font color="#E5E5E5"> that the attackers</font><font color="#CCCCCC"> form are</font>

513
00:22:59,430 --> 00:23:04,590
stealth than<font color="#CCCCCC"> DTS X attack so how do we</font>

514
00:23:02,910 --> 00:23:06,420
time a prefetch instruction well you can

515
00:23:04,590 --> 00:23:08,129
see the code is<font color="#E5E5E5"> almost perfectly reduced</font>

516
00:23:06,420 --> 00:23:12,090
as<font color="#E5E5E5"> no if statement</font><font color="#CCCCCC"> there is no branching</font>

517
00:23:08,130 --> 00:23:14,190
<font color="#E5E5E5">it's just start the timer get the</font>

518
00:23:12,090 --> 00:23:15,750
current time<font color="#E5E5E5"> called the</font><font color="#CCCCCC"> precession</font>

519
00:23:14,190 --> 00:23:17,340
struck at the end time and<font color="#E5E5E5"> you got the</font>

520
00:23:15,750 --> 00:23:18,840
results you need<font color="#E5E5E5"> for these double</font>

521
00:23:17,340 --> 00:23:20,310
prefetch attacker and for the double

522
00:23:18,840 --> 00:23:22,639
page fault attack just using the<font color="#CCCCCC"> prefix</font>

523
00:23:20,310 --> 00:23:25,169
<font color="#E5E5E5">instruction instead of a page fault</font>

524
00:23:22,640 --> 00:23:26,250
<font color="#CCCCCC">there is a problem</font><font color="#E5E5E5"> with the prefetch</font>

525
00:23:25,170 --> 00:23:28,800
<font color="#E5E5E5">instructions that is prefetch</font>

526
00:23:26,250 --> 00:23:31,650
instructions<font color="#CCCCCC"> are data only meaning</font><font color="#E5E5E5"> that</font>

527
00:23:28,800 --> 00:23:32,940
we<font color="#E5E5E5"> have no way to tell</font><font color="#CCCCCC"> if memory is</font>

528
00:23:31,650 --> 00:23:35,340
mapped in the kernel<font color="#E5E5E5"> is executable</font>

529
00:23:32,940 --> 00:23:37,400
meaning that<font color="#CCCCCC"> we'll get a bit less</font>

530
00:23:35,340 --> 00:23:43,459
information<font color="#CCCCCC"> than we would get with the</font>

531
00:23:37,400 --> 00:23:49,530
<font color="#E5E5E5">tsx attack so it's all lost</font>

532
00:23:43,460 --> 00:23:53,250
well maybe not until built into current

533
00:23:49,530 --> 00:23:57,210
<font color="#CCCCCC">CPUs a feature called</font><font color="#E5E5E5"> SMTP or supervisor</font>

534
00:23:53,250 --> 00:23:59,640
mode execution protection and the idea

535
00:23:57,210 --> 00:24:01,770
here<font color="#CCCCCC"> is it prevents execution of memory</font>

536
00:23:59,640 --> 00:24:05,160
allocated<font color="#CCCCCC"> by a user with</font><font color="#E5E5E5"> user mode</font>

537
00:24:01,770 --> 00:24:05,910
privileges from<font color="#E5E5E5"> being executed with a</font>

538
00:24:05,160 --> 00:24:09,420
threat

539
00:24:05,910 --> 00:24:11,190
having kernel privileges<font color="#CCCCCC"> the idea here</font>

540
00:24:09,420 --> 00:24:13,110
is it forces an<font color="#CCCCCC"> expert to write a to</font>

541
00:24:11,190 --> 00:24:14,520
find a way<font color="#E5E5E5"> to move her code into the</font>

542
00:24:13,110 --> 00:24:17,850
kernel<font color="#E5E5E5"> mode before she can call it</font>

543
00:24:14,520 --> 00:24:19,399
meaning that something<font color="#E5E5E5"> like caching</font><font color="#CCCCCC"> an</font>

544
00:24:17,850 --> 00:24:21,918
indirect

545
00:24:19,399 --> 00:24:25,218
the address<font color="#E5E5E5"> for an indirect call won't</font>

546
00:24:21,919 --> 00:24:27,409
help here the<font color="#E5E5E5"> export rider would have to</font>

547
00:24:25,219 --> 00:24:31,219
move<font color="#E5E5E5"> his code into kernel mode before</font><font color="#CCCCCC"> it</font>

548
00:24:27,409 --> 00:24:34,009
<font color="#E5E5E5">can do that and there's maps map is</font>

549
00:24:31,219 --> 00:24:36,769
supervisor mode access prevention<font color="#E5E5E5"> that</font>

550
00:24:34,009 --> 00:24:40,129
<font color="#E5E5E5">is the exact identical thing for data</font>

551
00:24:36,769 --> 00:24:44,719
and it<font color="#E5E5E5"> prevented the kernel from using</font>

552
00:24:40,129 --> 00:24:46,728
<font color="#E5E5E5">user allocated data and this essentially</font>

553
00:24:44,719 --> 00:24:49,690
prevents an exploit<font color="#E5E5E5"> writer using</font>

554
00:24:46,729 --> 00:24:52,849
<font color="#CCCCCC">database attacks such as return object</font>

555
00:24:49,690 --> 00:24:55,849
<font color="#E5E5E5">object-oriented programming</font><font color="#CCCCCC"> and you need</font>

556
00:24:52,849 --> 00:25:00,249
to get<font color="#E5E5E5"> her data into the kernel before</font>

557
00:24:55,849 --> 00:25:02,418
she can launch an attack<font color="#E5E5E5"> using data so</font>

558
00:25:00,249 --> 00:25:04,489
this guy<font color="#CCCCCC"> that kind of getting old</font><font color="#E5E5E5"> isn't</font>

559
00:25:02,419 --> 00:25:08,869
<font color="#E5E5E5">it yes there was another happy little</font>

560
00:25:04,489 --> 00:25:12,950
accident now<font color="#E5E5E5"> so most operating systems</font>

561
00:25:08,869 --> 00:25:15,709
<font color="#CCCCCC">have so-called kernel direct mapping now</font>

562
00:25:12,950 --> 00:25:18,589
the major exceptions<font color="#E5E5E5"> under the modern</font>

563
00:25:15,710 --> 00:25:19,940
<font color="#E5E5E5">operating</font><font color="#CCCCCC"> systems is Windows will get</font>

564
00:25:18,589 --> 00:25:25,099
<font color="#E5E5E5">back to</font><font color="#CCCCCC"> Windows in a moment when I'm</font>

565
00:25:19,940 --> 00:25:26,869
<font color="#E5E5E5">done with Linux</font><font color="#CCCCCC"> the thing here is these</font>

566
00:25:25,099 --> 00:25:28,999
operating systems<font color="#E5E5E5"> mapped the entire</font>

567
00:25:26,869 --> 00:25:31,879
<font color="#E5E5E5">physical memory into</font><font color="#CCCCCC"> the kernel</font><font color="#E5E5E5"> part of</font>

568
00:25:28,999 --> 00:25:34,009
the<font color="#E5E5E5"> address space</font><font color="#CCCCCC"> it does so so that the</font>

569
00:25:31,879 --> 00:25:37,189
kernel have access to any memory at any

570
00:25:34,009 --> 00:25:39,499
<font color="#E5E5E5">time for any reason and this is just</font>

571
00:25:37,190 --> 00:25:41,330
plain convenient<font color="#E5E5E5"> among the things that</font>

572
00:25:39,499 --> 00:25:43,039
it need access to<font color="#E5E5E5"> of the page tables to</font>

573
00:25:41,330 --> 00:25:45,019
allocate and deallocate memory<font color="#E5E5E5"> stuff</font>

574
00:25:43,039 --> 00:25:47,059
like that<font color="#E5E5E5"> so you have the</font><font color="#CCCCCC"> entire</font>

575
00:25:45,019 --> 00:25:51,019
physical<font color="#CCCCCC"> memory inside the kernel space</font>

576
00:25:47,059 --> 00:25:55,460
the big<font color="#E5E5E5"> so now we have the attacker</font>

577
00:25:51,019 --> 00:25:57,409
already has her<font color="#E5E5E5"> data or code in the</font>

578
00:25:55,460 --> 00:26:00,799
kernel<font color="#E5E5E5"> mode is</font><font color="#CCCCCC"> just a matter of where is</font>

579
00:25:57,409 --> 00:26:04,070
<font color="#E5E5E5">it and the prefetch instruction is quite</font>

580
00:26:00,799 --> 00:26:06,769
<font color="#E5E5E5">helpful in</font><font color="#CCCCCC"> that connection the prefetch</font>

581
00:26:04,070 --> 00:26:10,279
instruction allows us to load<font color="#E5E5E5"> or use a</font>

582
00:26:06,769 --> 00:26:13,309
<font color="#E5E5E5">kernel mode address to load the data of</font>

583
00:26:10,279 --> 00:26:14,989
<font color="#E5E5E5">that address into the cache it does not</font>

584
00:26:13,309 --> 00:26:19,070
check<font color="#CCCCCC"> that it's called on</font><font color="#E5E5E5"> privileges</font>

585
00:26:14,989 --> 00:26:20,659
just does it<font color="#E5E5E5"> so what we need to know</font>

586
00:26:19,070 --> 00:26:22,960
<font color="#E5E5E5">here is</font><font color="#CCCCCC"> that accessing memory</font><font color="#E5E5E5"> that it's</font>

587
00:26:20,659 --> 00:26:25,419
already cached is faster than<font color="#E5E5E5"> otherwise</font>

588
00:26:22,960 --> 00:26:27,980
so now we can iterate it through the

589
00:26:25,419 --> 00:26:31,070
kernel direct physical<font color="#CCCCCC"> map</font>

590
00:26:27,980 --> 00:26:34,130
prefetch at one<font color="#CCCCCC"> address after</font><font color="#E5E5E5"> another</font>

591
00:26:31,070 --> 00:26:35,299
and then<font color="#E5E5E5"> test is the same if</font><font color="#CCCCCC"> the an</font>

592
00:26:34,130 --> 00:26:38,360
address that<font color="#E5E5E5"> we are interested in having</font>

593
00:26:35,299 --> 00:26:40,730
<font color="#E5E5E5">in kernel</font><font color="#CCCCCC"> mode is now fast to access and</font>

594
00:26:38,360 --> 00:26:43,969
if it is then we know where<font color="#E5E5E5"> it's mapped</font>

595
00:26:40,730 --> 00:26:49,190
in the kernel<font color="#E5E5E5"> and we have a perfect map</font>

596
00:26:43,970 --> 00:26:51,049
and<font color="#E5E5E5"> snip bypass so now that we</font><font color="#CCCCCC"> have seen</font>

597
00:26:49,190 --> 00:26:53,480
that what<font color="#CCCCCC"> is academically possible let's</font>

598
00:26:51,049 --> 00:26:55,760
turn to<font color="#CCCCCC"> a</font><font color="#E5E5E5"> real world kr celebrate using</font>

599
00:26:53,480 --> 00:27:00,830
these methods<font color="#CCCCCC"> it goes back</font><font color="#E5E5E5"> to nism in</font>

600
00:26:55,760 --> 00:27:04,340
2016 and Nitin had a<font color="#CCCCCC"> real-world run will</font>

601
00:27:00,830 --> 00:27:06,559
write anything<font color="#CCCCCC"> anywhere</font><font color="#E5E5E5"> block</font><font color="#CCCCCC"> the</font>

602
00:27:04,340 --> 00:27:10,668
mechanics of the bug relied on a

603
00:27:06,559 --> 00:27:13,580
combination of<font color="#E5E5E5"> using the windows</font><font color="#CCCCCC"> 32k and</font>

604
00:27:10,669 --> 00:27:15,679
module any of the next<font color="#CCCCCC"> window functions</font>

605
00:27:13,580 --> 00:27:17,389
in a combination with<font color="#CCCCCC"> entities</font><font color="#E5E5E5"> that</font>

606
00:27:15,679 --> 00:27:20,120
window long pointer<font color="#CCCCCC"> i'm not going to how</font>

607
00:27:17,390 --> 00:27:22,370
the export actually works<font color="#E5E5E5"> just</font><font color="#CCCCCC"> suffice</font>

608
00:27:20,120 --> 00:27:26,360
<font color="#E5E5E5">to</font><font color="#CCCCCC"> know that it's a write anything</font>

609
00:27:22,370 --> 00:27:28,790
anywhere<font color="#E5E5E5"> type</font><font color="#CCCCCC"> good luck</font><font color="#E5E5E5"> using</font><font color="#CCCCCC"> this</font>

610
00:27:26,360 --> 00:27:30,860
information<font color="#E5E5E5"> an ism had a very</font>

611
00:27:28,790 --> 00:27:33,200
<font color="#CCCCCC">interesting way of</font><font color="#E5E5E5"> gaining kernel</font>

612
00:27:30,860 --> 00:27:37,010
privileges<font color="#CCCCCC"> that is not quite unlike what</font>

613
00:27:33,200 --> 00:27:39,169
<font color="#E5E5E5">did Daniel and Clementine</font><font color="#CCCCCC"> I'm present in</font>

614
00:27:37,010 --> 00:27:43,400
the last<font color="#E5E5E5"> talk for row hammer they patch</font>

615
00:27:39,169 --> 00:27:45,350
the page tables<font color="#E5E5E5"> and before we find out</font>

616
00:27:43,400 --> 00:27:47,570
how that's works we need<font color="#E5E5E5"> to talk</font><font color="#CCCCCC"> about a</font>

617
00:27:45,350 --> 00:27:50,149
bit<font color="#CCCCCC"> of how</font><font color="#E5E5E5"> Windows uses the page tables</font>

618
00:27:47,570 --> 00:27:52,700
<font color="#E5E5E5">to modify the page tables so each</font>

619
00:27:50,150 --> 00:27:56,570
process always<font color="#E5E5E5"> Maps its own page tables</font>

620
00:27:52,700 --> 00:28:00,620
at a given<font color="#CCCCCC"> address or well used</font><font color="#E5E5E5"> to and</font>

621
00:27:56,570 --> 00:28:03,740
<font color="#E5E5E5">it allowed</font><font color="#CCCCCC"> nism to know exactly where</font>

622
00:28:00,620 --> 00:28:05,120
the page tables are and knowing where

623
00:28:03,740 --> 00:28:07,610
the page table are having a write

624
00:28:05,120 --> 00:28:10,399
anything<font color="#E5E5E5"> anywhere but well you can find</font>

625
00:28:07,610 --> 00:28:12,949
the supervisor bit<font color="#E5E5E5"> in the page tables</font>

626
00:28:10,400 --> 00:28:14,419
themselves<font color="#CCCCCC"> sorted bit and you</font><font color="#E5E5E5"> have root</font>

627
00:28:12,950 --> 00:28:16,669
because you can<font color="#E5E5E5"> access any memory</font>

628
00:28:14,419 --> 00:28:19,700
anywhere in the system<font color="#CCCCCC"> you can read</font>

629
00:28:16,669 --> 00:28:21,890
write execute<font color="#E5E5E5"> anything</font><font color="#CCCCCC"> you like</font><font color="#E5E5E5"> so you</font>

630
00:28:19,700 --> 00:28:23,780
have root pretty much the same way the

631
00:28:21,890 --> 00:28:28,750
original<font color="#E5E5E5"> row hammer attack worked this</font>

632
00:28:23,780 --> 00:28:33,370
<font color="#CCCCCC">time with classical software box</font>

633
00:28:28,750 --> 00:28:34,840
so<font color="#CCCCCC"> Microsoft's had a</font><font color="#E5E5E5"> solution for that</font>

634
00:28:33,370 --> 00:28:36,789
they added<font color="#CCCCCC"> KR Salar to the</font>

635
00:28:34,840 --> 00:28:38,760
<font color="#CCCCCC">self-reference</font><font color="#E5E5E5"> they randomized using the</font>

636
00:28:36,789 --> 00:28:41,500
upper<font color="#CCCCCC"> 9 bits of the virtual address</font>

637
00:28:38,760 --> 00:28:47,770
<font color="#E5E5E5">meaning</font><font color="#CCCCCC"> that now Nissen would have to</font>

638
00:28:41,500 --> 00:28:50,890
<font color="#E5E5E5">guess a value in in one one in 265 56</font>

639
00:28:47,770 --> 00:28:54,370
<font color="#E5E5E5">and if it gets wrong it</font><font color="#CCCCCC"> is just</font><font color="#E5E5E5"> blue</font>

640
00:28:50,890 --> 00:28:57,070
screen the system<font color="#CCCCCC"> nism was a smart guy</font>

641
00:28:54,370 --> 00:28:58,449
<font color="#CCCCCC">and</font><font color="#E5E5E5"> he responded</font><font color="#CCCCCC"> by using tsx and the</font>

642
00:28:57,070 --> 00:29:00,460
prefetch attacks

643
00:28:58,450 --> 00:29:02,950
to find the address<font color="#CCCCCC"> of the self</font>

644
00:29:00,460 --> 00:29:05,400
reference in the kernel space<font color="#E5E5E5"> and turns</font>

645
00:29:02,950 --> 00:29:07,419
out<font color="#E5E5E5"> both works the prefetch is faster</font>

646
00:29:05,400 --> 00:29:08,890
<font color="#E5E5E5">probably because the code is much</font>

647
00:29:07,419 --> 00:29:14,590
cleaner there's no aborts and<font color="#E5E5E5"> stuff like</font>

648
00:29:08,890 --> 00:29:18,010
that<font color="#E5E5E5"> so it's not like that we have</font>

649
00:29:14,590 --> 00:29:19,480
totally defenseless yet<font color="#CCCCCC"> the thing is the</font>

650
00:29:18,010 --> 00:29:21,850
three attacks<font color="#CCCCCC"> were viewed</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> I</font>

651
00:29:19,480 --> 00:29:23,740
<font color="#E5E5E5">presented so far</font><font color="#CCCCCC"> all work because of two</font>

652
00:29:21,850 --> 00:29:25,689
things<font color="#CCCCCC"> the one is the patient caches and</font>

653
00:29:23,740 --> 00:29:27,669
the second is the journalist map into

654
00:29:25,690 --> 00:29:31,720
every process and<font color="#E5E5E5"> only protected by the</font>

655
00:29:27,669 --> 00:29:33,370
supervisor bit<font color="#E5E5E5"> so</font><font color="#CCCCCC"> patron caches we</font>

656
00:29:31,720 --> 00:29:35,169
cannot do very much about<font color="#E5E5E5"> at least not</font>

657
00:29:33,370 --> 00:29:37,780
without a very steep performance penalty

658
00:29:35,169 --> 00:29:41,350
but we don't actually<font color="#E5E5E5"> have to have the</font>

659
00:29:37,780 --> 00:29:43,480
<font color="#E5E5E5">kernel map in every process</font><font color="#CCCCCC"> so what</font>

660
00:29:41,350 --> 00:29:45,969
happens if we<font color="#CCCCCC"> map the kernel in any</font>

661
00:29:43,480 --> 00:29:50,530
other process this<font color="#CCCCCC"> method was suggested</font>

662
00:29:45,970 --> 00:29:54,809
by<font color="#E5E5E5"> yang Lee Kim</font><font color="#CCCCCC"> gross</font><font color="#E5E5E5"> Marie's myself and</font>

663
00:29:50,530 --> 00:29:57,639
others<font color="#E5E5E5"> and it works something like this</font>

664
00:29:54,809 --> 00:29:58,990
in each<font color="#E5E5E5"> process you now have I call it a</font>

665
00:29:57,640 --> 00:30:00,039
microkernel<font color="#CCCCCC"> that's the wrong term I</font>

666
00:29:58,990 --> 00:30:02,020
<font color="#CCCCCC">don't know what the right term</font><font color="#E5E5E5"> is you</font>

667
00:30:00,039 --> 00:30:03,879
have a very small<font color="#E5E5E5"> kernel that has a</font>

668
00:30:02,020 --> 00:30:06,730
stuff for function<font color="#E5E5E5"> that must go on</font><font color="#CCCCCC"> the</font>

669
00:30:03,880 --> 00:30:09,010
current process<font color="#E5E5E5"> and then it transfers to</font>

670
00:30:06,730 --> 00:30:11,890
<font color="#E5E5E5">the kernel processor the real kernel</font>

671
00:30:09,010 --> 00:30:14,320
process<font color="#E5E5E5"> and real kernel processes</font><font color="#CCCCCC"> and is</font>

672
00:30:11,890 --> 00:30:16,120
in the process<font color="#CCCCCC"> of its own and thus we</font>

673
00:30:14,320 --> 00:30:19,840
can<font color="#CCCCCC"> have our access it using the paging</font>

674
00:30:16,120 --> 00:30:23,020
<font color="#CCCCCC">system inside</font><font color="#E5E5E5"> of a process</font><font color="#CCCCCC"> so some of</font>

675
00:30:19,840 --> 00:30:24,850
these things<font color="#E5E5E5"> that happens that gives us</font>

676
00:30:23,020 --> 00:30:27,789
the need to have this microkernel<font color="#E5E5E5"> is</font>

677
00:30:24,850 --> 00:30:30,219
that we need to receive interrupts we

678
00:30:27,789 --> 00:30:32,919
need to handle<font color="#E5E5E5"> Cisco Center stuff like</font>

679
00:30:30,220 --> 00:30:35,440
<font color="#E5E5E5">that once these things have been</font>

680
00:30:32,919 --> 00:30:38,370
received in kernel<font color="#CCCCCC"> mode</font><font color="#E5E5E5"> we can swap the</font>

681
00:30:35,440 --> 00:30:41,799
<font color="#CCCCCC">cr3</font><font color="#E5E5E5"> to the real kernel process and thus</font>

682
00:30:38,370 --> 00:30:44,479
<font color="#E5E5E5">significantly reduce the attack surface</font>

683
00:30:41,799 --> 00:30:46,999
to the point of where you can<font color="#E5E5E5"> really get</font>

684
00:30:44,480 --> 00:30:50,690
an export running<font color="#CCCCCC"> the real</font><font color="#E5E5E5"> Colonel</font><font color="#CCCCCC"> Phil</font>

685
00:30:46,999 --> 00:30:53,480
does everything<font color="#CCCCCC"> is supposed</font><font color="#E5E5E5"> to and in</font>

686
00:30:50,690 --> 00:30:56,259
turn this prevents us of chrome causing

687
00:30:53,480 --> 00:30:58,399
<font color="#E5E5E5">access to kernel mode from user</font><font color="#CCCCCC"> mode</font>

688
00:30:56,259 --> 00:31:00,679
<font color="#E5E5E5">meaning</font><font color="#CCCCCC"> that all three attacks</font><font color="#E5E5E5"> are</font>

689
00:30:58,399 --> 00:31:04,189
prevented with this<font color="#CCCCCC"> there is a</font>

690
00:31:00,679 --> 00:31:07,100
<font color="#E5E5E5">performance</font><font color="#CCCCCC"> impact of this</font><font color="#E5E5E5"> the estimate</font>

691
00:31:04,190 --> 00:31:11,480
<font color="#E5E5E5">in the literature is between 0.5 percent</font>

692
00:31:07,100 --> 00:31:13,820
and<font color="#CCCCCC"> 35% a rather large gap the</font>

693
00:31:11,480 --> 00:31:16,309
<font color="#CCCCCC">Clementina and</font><font color="#E5E5E5"> daniel told</font><font color="#CCCCCC"> me they have</font>

694
00:31:13,820 --> 00:31:18,259
actually<font color="#CCCCCC"> tested this in a paper</font><font color="#E5E5E5"> that</font>

695
00:31:16,309 --> 00:31:22,489
will be<font color="#E5E5E5"> released</font><font color="#CCCCCC"> i think tomorrow and</font>

696
00:31:18,259 --> 00:31:25,639
the real<font color="#E5E5E5"> value</font><font color="#CCCCCC"> is below a percentage if</font>

697
00:31:22,489 --> 00:31:27,980
<font color="#E5E5E5">i'm correct there are some overhead on</font>

698
00:31:25,639 --> 00:31:30,469
watching<font color="#CCCCCC"> the page</font><font color="#E5E5E5"> contagion caches</font><font color="#CCCCCC"> the</font>

699
00:31:27,980 --> 00:31:31,639
<font color="#CCCCCC">question</font><font color="#E5E5E5"> magazine here because</font><font color="#CCCCCC"> i wasn't</font>

700
00:31:30,470 --> 00:31:34,820
<font color="#E5E5E5">allowed to talk</font><font color="#CCCCCC"> about it it doesn't</font>

701
00:31:31,639 --> 00:31:37,369
<font color="#CCCCCC">actually rarely does it when it happens</font>

702
00:31:34,820 --> 00:31:39,289
the manual says it can and<font color="#E5E5E5"> usually</font>

703
00:31:37,369 --> 00:31:41,869
doesn't<font color="#E5E5E5"> because it does need</font><font color="#CCCCCC"> two attacks</font>

704
00:31:39,289 --> 00:31:44,960
with<font color="#E5E5E5"> the ca3 value and there's some</font>

705
00:31:41,869 --> 00:31:48,230
<font color="#E5E5E5">overhead on swapping the cr3 register as</font>

706
00:31:44,960 --> 00:31:50,989
well<font color="#E5E5E5"> so we</font><font color="#CCCCCC"> are safe again</font><font color="#E5E5E5"> for a small</font>

707
00:31:48,230 --> 00:31:53,720
price and<font color="#CCCCCC"> i can assume you can all guess</font>

708
00:31:50,989 --> 00:31:57,080
what happens now well this<font color="#E5E5E5"> guy kind of</font>

709
00:31:53,720 --> 00:31:58,759
getting annoying isn't it<font color="#CCCCCC"> it turns out</font>

710
00:31:57,080 --> 00:32:02,080
there's another<font color="#CCCCCC"> attack</font><font color="#E5E5E5"> through the</font>

711
00:31:58,759 --> 00:32:04,489
branch target buffer and this<font color="#E5E5E5"> was</font>

712
00:32:02,080 --> 00:32:09,559
released last<font color="#E5E5E5"> year by a Koosh</font><font color="#CCCCCC"> gentleman</font>

713
00:32:04,489 --> 00:32:13,639
<font color="#CCCCCC">f</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> abu sally and it works because</font>

714
00:32:09,559 --> 00:32:14,960
modern<font color="#E5E5E5"> x x86</font><font color="#CCCCCC"> our superscalar</font><font color="#E5E5E5"> meaning</font>

715
00:32:13,639 --> 00:32:18,469
<font color="#E5E5E5">that are able</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> execute multiple</font>

716
00:32:14,960 --> 00:32:21,440
instructions at once<font color="#E5E5E5"> and also modern x86</font>

717
00:32:18,470 --> 00:32:23,419
and<font color="#CCCCCC"> processors</font><font color="#E5E5E5"> are so-called pipeline to</font>

718
00:32:21,440 --> 00:32:25,789
signs meaning<font color="#CCCCCC"> that different stages of</font>

719
00:32:23,419 --> 00:32:28,249
processing instructions<font color="#E5E5E5"> running some</font>

720
00:32:25,789 --> 00:32:31,119
simultaneously it looks something like

721
00:32:28,249 --> 00:32:34,730
this in the pipeline<font color="#E5E5E5"> we start</font><font color="#CCCCCC"> anything</font>

722
00:32:31,119 --> 00:32:37,580
up above and decode the instructions and

723
00:32:34,730 --> 00:32:40,519
meanwhile the execution units which<font color="#CCCCCC"> is</font>

724
00:32:37,580 --> 00:32:43,730
the colorful<font color="#E5E5E5"> things down below are</font>

725
00:32:40,519 --> 00:32:51,120
executing instructions simultaneously as

726
00:32:43,730 --> 00:32:55,179
many as it can without dealing<font color="#E5E5E5"> with with</font>

727
00:32:51,120 --> 00:32:59,909
<font color="#E5E5E5">Dependencies just execute as much as it</font>

728
00:32:55,179 --> 00:33:01,870
can and<font color="#E5E5E5"> then submitting those to be</font>

729
00:32:59,910 --> 00:33:05,020
submitted to<font color="#CCCCCC"> the</font><font color="#E5E5E5"> architectural state</font>

730
00:33:01,870 --> 00:33:06,790
later<font color="#CCCCCC"> so what happens if</font><font color="#E5E5E5"> we have a</font>

731
00:33:05,020 --> 00:33:09,010
branch instruction<font color="#CCCCCC"> coming in in the</font>

732
00:33:06,790 --> 00:33:11,530
instruction decoder<font color="#CCCCCC"> a branch instruction</font>

733
00:33:09,010 --> 00:33:14,020
<font color="#E5E5E5">would mean that the instruction decoder</font>

734
00:33:11,530 --> 00:33:16,960
would have no<font color="#CCCCCC"> idea where it should take</font>

735
00:33:14,020 --> 00:33:19,990
the next instruction<font color="#CCCCCC"> to decode from so</font>

736
00:33:16,960 --> 00:33:22,000
we have two options<font color="#CCCCCC"> here one options is</font>

737
00:33:19,990 --> 00:33:25,929
we can either stall until<font color="#CCCCCC"> the branch</font>

738
00:33:22,000 --> 00:33:30,030
instruction is executed and then start

739
00:33:25,929 --> 00:33:32,980
<font color="#CCCCCC">parsing instructions that will leave the</font>

740
00:33:30,030 --> 00:33:34,960
execution units with nothing to execute

741
00:33:32,980 --> 00:33:37,720
<font color="#CCCCCC">for a small period</font><font color="#E5E5E5"> of time</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> so-called</font>

742
00:33:34,960 --> 00:33:39,340
stall<font color="#E5E5E5"> which of course is expensive and</font>

743
00:33:37,720 --> 00:33:43,179
the other<font color="#E5E5E5"> option is</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> can try to</font>

744
00:33:39,340 --> 00:33:45,159
predict where does the branch go<font color="#E5E5E5"> if we</font>

745
00:33:43,179 --> 00:33:48,270
turn out<font color="#CCCCCC"> to</font><font color="#E5E5E5"> predictive wrong we have</font><font color="#CCCCCC"> a</font>

746
00:33:45,160 --> 00:33:51,520
mechanism<font color="#E5E5E5"> that we can use to do rollback</font>

747
00:33:48,270 --> 00:33:54,400
so all model CPUs<font color="#E5E5E5"> choose the second</font>

748
00:33:51,520 --> 00:33:56,410
option that<font color="#E5E5E5"> is prediction and into</font><font color="#CCCCCC"> four</font>

749
00:33:54,400 --> 00:33:58,510
that have a branch target buffer it

750
00:33:56,410 --> 00:34:01,360
stores<font color="#E5E5E5"> the last target</font><font color="#CCCCCC"> address of a</font>

751
00:33:58,510 --> 00:34:03,820
branch in a cache and uses this for

752
00:34:01,360 --> 00:34:05,229
prediction<font color="#E5E5E5"> where</font><font color="#CCCCCC"> does</font><font color="#E5E5E5"> a branch</font>

753
00:34:03,820 --> 00:34:06,700
instruction really<font color="#E5E5E5"> go where does the</font>

754
00:34:05,230 --> 00:34:09,969
instruction decode I need to get<font color="#CCCCCC"> it's an</font>

755
00:34:06,700 --> 00:34:12,190
<font color="#CCCCCC">S next instruction from there is a very</font>

756
00:34:09,969 --> 00:34:16,388
interesting<font color="#E5E5E5"> thing about this cache it</font>

757
00:34:12,190 --> 00:34:18,389
uses<font color="#CCCCCC"> only 31 bits to index what does</font>

758
00:34:16,389 --> 00:34:20,740
this mean well<font color="#E5E5E5"> typically user-mode</font>

759
00:34:18,389 --> 00:34:25,060
addresses modern operating systems<font color="#E5E5E5"> are</font>

760
00:34:20,739 --> 00:34:28,449
all using addresses where the 47 v is<font color="#E5E5E5"> 0</font>

761
00:34:25,060 --> 00:34:31,389
and the<font color="#E5E5E5"> Kermode addresses have the 47th</font>

762
00:34:28,449 --> 00:34:33,279
bit to set to 1 meaning<font color="#CCCCCC"> that conflicts</font>

763
00:34:31,389 --> 00:34:36,129
can arise between<font color="#E5E5E5"> kernel and</font><font color="#CCCCCC"> user mode</font>

764
00:34:33,280 --> 00:34:38,320
addresses<font color="#E5E5E5"> the two addresses that</font><font color="#CCCCCC"> I have</font>

765
00:34:36,129 --> 00:34:40,629
here are two addresses<font color="#CCCCCC"> that will have a</font>

766
00:34:38,320 --> 00:34:41,950
conflict<font color="#E5E5E5"> in this cache because they use</font>

767
00:34:40,629 --> 00:34:44,529
the<font color="#E5E5E5"> same position</font><font color="#CCCCCC"> in the cache because</font>

768
00:34:41,949 --> 00:34:49,029
<font color="#E5E5E5">they attack on the identical third lower</font>

769
00:34:44,530 --> 00:34:50,950
31<font color="#CCCCCC"> bits</font><font color="#E5E5E5"> so if there is</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> conflict in</font>

770
00:34:49,030 --> 00:34:51,760
<font color="#E5E5E5">kick in a cache it means things will not</font>

771
00:34:50,949 --> 00:34:54,730
go as it should

772
00:34:51,760 --> 00:34:58,140
meaning<font color="#CCCCCC"> that things will</font><font color="#E5E5E5"> be slower and I</font>

773
00:34:54,730 --> 00:35:00,670
guess the demetri demetri<font color="#E5E5E5"> and</font><font color="#CCCCCC"> abu gazali</font>

774
00:34:58,140 --> 00:35:03,580
said<font color="#CCCCCC"> Oh</font><font color="#E5E5E5"> challenge accepted</font>

775
00:35:00,670 --> 00:35:04,270
so how does this work<font color="#CCCCCC"> you initialize the</font>

776
00:35:03,580 --> 00:35:07,000
cache by doing

777
00:35:04,270 --> 00:35:08,400
branch to an<font color="#E5E5E5"> address</font><font color="#CCCCCC"> a then you do a</font>

778
00:35:07,000 --> 00:35:11,350
<font color="#CCCCCC">sister call with a branch instruction</font>

779
00:35:08,400 --> 00:35:13,420
<font color="#CCCCCC">you</font><font color="#E5E5E5"> time</font><font color="#CCCCCC"> the bread</font><font color="#E5E5E5"> the same branch you</font>

780
00:35:11,350 --> 00:35:16,360
did in in the first step<font color="#E5E5E5"> and if it's</font>

781
00:35:13,420 --> 00:35:19,090
<font color="#CCCCCC">lower</font><font color="#E5E5E5"> address a has the same 31 lower</font>

782
00:35:16,360 --> 00:35:21,400
bits as one of<font color="#CCCCCC"> the branches in these</font>

783
00:35:19,090 --> 00:35:24,610
<font color="#CCCCCC">syscall and then you just repeat</font><font color="#E5E5E5"> this</font>

784
00:35:21,400 --> 00:35:27,960
for<font color="#CCCCCC"> all possible</font><font color="#E5E5E5"> values of a</font><font color="#CCCCCC"> and well</font>

785
00:35:24,610 --> 00:35:30,340
some some point you hopefully get a

786
00:35:27,960 --> 00:35:32,680
conflict and<font color="#E5E5E5"> a lower timing and you'll</font>

787
00:35:30,340 --> 00:35:34,300
<font color="#E5E5E5">not know exactly what this call in this</font>

788
00:35:32,680 --> 00:35:37,509
is what this branch<font color="#CCCCCC"> and this is</font><font color="#E5E5E5"> called</font>

789
00:35:34,300 --> 00:35:40,440
at what address<font color="#E5E5E5"> it is at least lower</font>

790
00:35:37,510 --> 00:35:42,970
<font color="#CCCCCC">31-bit</font><font color="#E5E5E5"> the unfortunate thing here is</font>

791
00:35:40,440 --> 00:35:44,950
<font color="#E5E5E5">that while we all can only do randomized</font>

792
00:35:42,970 --> 00:35:47,319
<font color="#E5E5E5">the lower 31-bit using this method</font><font color="#CCCCCC"> that</font>

793
00:35:44,950 --> 00:35:49,089
is exactly what modern<font color="#E5E5E5"> operating system</font>

794
00:35:47,320 --> 00:35:52,920
does to randomize the kernel<font color="#E5E5E5"> meaning</font>

795
00:35:49,090 --> 00:35:55,360
<font color="#E5E5E5">that we in dere an demise the kernel</font><font color="#CCCCCC"> and</font>

796
00:35:52,920 --> 00:35:57,400
<font color="#CCCCCC">here with</font><font color="#E5E5E5"> this attack we're not</font>

797
00:35:55,360 --> 00:35:59,980
depending<font color="#E5E5E5"> on actually accessing kernel</font>

798
00:35:57,400 --> 00:36:02,590
<font color="#E5E5E5">mode we're just depending on having a</font>

799
00:35:59,980 --> 00:36:06,880
branch at a certain position so the

800
00:36:02,590 --> 00:36:07,420
kernel<font color="#E5E5E5"> has a process mitigation</font><font color="#CCCCCC"> I showed</font>

801
00:36:06,880 --> 00:36:10,630
before

802
00:36:07,420 --> 00:36:12,610
will not fix it in fact<font color="#CCCCCC"> felix wilhelm</font>

803
00:36:10,630 --> 00:36:14,830
<font color="#E5E5E5">wundt 2016 could use this method to do</font>

804
00:36:12,610 --> 00:36:16,360
randomized kernel mode address<font color="#CCCCCC"> base</font>

805
00:36:14,830 --> 00:36:19,060
randomization in a hypervisor

806
00:36:16,360 --> 00:36:21,240
from<font color="#E5E5E5"> unprivileged guest so that's quite</font>

807
00:36:19,060 --> 00:36:26,740
kind of nice

808
00:36:21,240 --> 00:36:29,080
so can we map the kernel but this method

809
00:36:26,740 --> 00:36:31,120
of<font color="#E5E5E5"> course has some problems one of them</font>

810
00:36:29,080 --> 00:36:33,130
is we cannot map the kernel like in the

811
00:36:31,120 --> 00:36:34,540
previous attacks and that's a question

812
00:36:33,130 --> 00:36:37,810
<font color="#CCCCCC">mark at</font><font color="#E5E5E5"> the end</font><font color="#CCCCCC"> of the statement for</font>

813
00:36:34,540 --> 00:36:39,790
<font color="#E5E5E5">reasons because why we can</font><font color="#CCCCCC"> only locate</font>

814
00:36:37,810 --> 00:36:41,200
branch instructions<font color="#E5E5E5"> how about branch</font>

815
00:36:39,790 --> 00:36:44,500
instructions in the page fault handler

816
00:36:41,200 --> 00:36:46,029
if we can locate<font color="#E5E5E5"> Henry instruction the</font>

817
00:36:44,500 --> 00:36:49,600
page fault handler that<font color="#E5E5E5"> are only called</font>

818
00:36:46,030 --> 00:36:51,250
when you access a map page<font color="#E5E5E5"> well then you</font>

819
00:36:49,600 --> 00:36:54,940
can figure out which page are mapped

820
00:36:51,250 --> 00:36:56,560
again so I have not actually finished

821
00:36:54,940 --> 00:37:04,420
the research<font color="#CCCCCC"> on</font><font color="#E5E5E5"> that so it's</font><font color="#CCCCCC"> just leave</font>

822
00:36:56,560 --> 00:37:05,950
it as a thing<font color="#CCCCCC"> to think of so that</font><font color="#E5E5E5"> now we</font>

823
00:37:04,420 --> 00:37:10,540
are<font color="#CCCCCC"> reaching sort of the conclusion part</font>

824
00:37:05,950 --> 00:37:14,080
<font color="#E5E5E5">of this talk how can we mitigate attacks</font>

825
00:37:10,540 --> 00:37:15,710
on<font color="#E5E5E5"> KS</font><font color="#CCCCCC"> LR well we can use a combination</font>

826
00:37:14,080 --> 00:37:17,930
of kernel

827
00:37:15,710 --> 00:37:20,740
process and randomizing through the

828
00:37:17,930 --> 00:37:24,589
other 70 bits like Microsoft do for the

829
00:37:20,740 --> 00:37:28,879
self reference map<font color="#CCCCCC"> that</font><font color="#E5E5E5"> leaves the</font>

830
00:37:24,589 --> 00:37:30,740
<font color="#CCCCCC">question should we and first of</font><font color="#E5E5E5"> all we</font>

831
00:37:28,880 --> 00:37:33,170
<font color="#E5E5E5">should consider</font><font color="#CCCCCC"> that these mitigations</font>

832
00:37:30,740 --> 00:37:35,720
are<font color="#E5E5E5"> a mitigation of case</font><font color="#CCCCCC"> allow which</font>

833
00:37:33,170 --> 00:37:37,099
itself is a mitigation<font color="#E5E5E5"> and we should</font>

834
00:37:35,720 --> 00:37:40,399
seriously<font color="#E5E5E5"> ask ourselves the question is</font>

835
00:37:37,099 --> 00:37:42,170
that where we want<font color="#CCCCCC"> to go also we should</font>

836
00:37:40,400 --> 00:37:44,990
consider there might be more leakage in

837
00:37:42,170 --> 00:37:47,060
the<font color="#E5E5E5"> cpu</font><font color="#CCCCCC"> especially</font><font color="#E5E5E5"> it'd be</font><font color="#CCCCCC"> interesting</font>

838
00:37:44,990 --> 00:37:49,848
<font color="#CCCCCC">to see attacks like the one</font><font color="#E5E5E5"> I've</font>

839
00:37:47,060 --> 00:37:51,560
sketched before<font color="#CCCCCC"> where we used</font><font color="#E5E5E5"> say a</font>

840
00:37:49,849 --> 00:37:56,119
branch<font color="#E5E5E5"> and page fault handler to find</font>

841
00:37:51,560 --> 00:37:57,380
out<font color="#CCCCCC"> if pages are mapped or not it'd</font><font color="#E5E5E5"> be</font>

842
00:37:56,119 --> 00:37:59,720
interesting<font color="#E5E5E5"> to see what we can actually</font>

843
00:37:57,380 --> 00:38:04,310
do in that direction and<font color="#E5E5E5"> that might not</font>

844
00:37:59,720 --> 00:38:08,240
<font color="#CCCCCC">be mitigation mitigated by the</font><font color="#E5E5E5"> two</font>

845
00:38:04,310 --> 00:38:09,859
mitigations mentioned above<font color="#CCCCCC"> and finally</font>

846
00:38:08,240 --> 00:38:14,629
we<font color="#E5E5E5"> should consider that their software</font>

847
00:38:09,859 --> 00:38:17,810
attacks on chaos and ours well and again

848
00:38:14,630 --> 00:38:19,280
<font color="#E5E5E5">Yamini from Google project zero wrote</font>

849
00:38:17,810 --> 00:38:21,140
while those attacks<font color="#CCCCCC"> on meaning</font>

850
00:38:19,280 --> 00:38:22,790
<font color="#E5E5E5">prefetching</font><font color="#CCCCCC"> tsx</font><font color="#E5E5E5"> are quite interesting in</font>

851
00:38:21,140 --> 00:38:26,150
their own right<font color="#E5E5E5"> it should be noted that</font>

852
00:38:22,790 --> 00:38:28,520
<font color="#E5E5E5">by</font><font color="#CCCCCC"> passing chaos lr this often can often</font>

853
00:38:26,150 --> 00:38:31,010
be achieved much more easily<font color="#CCCCCC"> and if we</font>

854
00:38:28,520 --> 00:38:32,450
<font color="#E5E5E5">think that these attacks that</font><font color="#CCCCCC"> I've</font><font color="#E5E5E5"> just</font>

855
00:38:31,010 --> 00:38:34,880
<font color="#CCCCCC">sketched are very complicated to mount</font>

856
00:38:32,450 --> 00:38:36,640
<font color="#E5E5E5">they're not so it's easier to</font><font color="#CCCCCC"> find a</font>

857
00:38:34,880 --> 00:38:39,589
software break for it<font color="#E5E5E5"> well then maybe</font>

858
00:38:36,640 --> 00:38:43,839
yeah<font color="#CCCCCC"> KSR isn't that important in real</font>

859
00:38:39,589 --> 00:38:46,070
life so<font color="#CCCCCC"> should</font><font color="#E5E5E5"> we drop chaos at our</font>

860
00:38:43,839 --> 00:38:50,540
everything we've<font color="#E5E5E5"> seen</font><font color="#CCCCCC"> so far lets us</font>

861
00:38:46,070 --> 00:38:52,250
assume that<font color="#E5E5E5"> K RSL</font><font color="#CCCCCC"> R is broken but every</font>

862
00:38:50,540 --> 00:38:56,690
break that I've shown so<font color="#CCCCCC"> far even</font><font color="#E5E5E5"> now</font>

863
00:38:52,250 --> 00:39:00,109
the<font color="#E5E5E5"> been</font><font color="#CCCCCC"> Yamini</font><font color="#E5E5E5"> has a thing to it they</font>

864
00:38:56,690 --> 00:39:03,680
are using arbitrary unproduced execution

865
00:39:00,109 --> 00:39:05,810
on the<font color="#E5E5E5"> CPU and that's not always given</font>

866
00:39:03,680 --> 00:39:09,109
there's a class of attacks<font color="#CCCCCC"> that you say</font>

867
00:39:05,810 --> 00:39:11,810
<font color="#E5E5E5">funds or</font><font color="#CCCCCC"> other data</font><font color="#E5E5E5"> ducks as format and</font>

868
00:39:09,109 --> 00:39:14,420
they still to some extent break because

869
00:39:11,810 --> 00:39:16,609
of<font color="#CCCCCC"> KS l r KR</font><font color="#E5E5E5"> SLR</font><font color="#CCCCCC"> is implemented and</font>

870
00:39:14,420 --> 00:39:19,070
mostly<font color="#CCCCCC"> bug</font><font color="#E5E5E5"> free and with low performance</font>

871
00:39:16,609 --> 00:39:21,080
overhead in general so maybe we<font color="#CCCCCC"> should</font>

872
00:39:19,070 --> 00:39:23,930
probably keep<font color="#CCCCCC"> PSLRA against these</font>

873
00:39:21,080 --> 00:39:25,339
attacks<font color="#CCCCCC"> but realize</font><font color="#E5E5E5"> that we need</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> not</font>

874
00:39:23,930 --> 00:39:26,990
write safe software in the kernel as

875
00:39:25,339 --> 00:39:28,509
well otherwise<font color="#E5E5E5"> it'll be vulnerable the</font>

876
00:39:26,990 --> 00:39:31,629
KS<font color="#E5E5E5"> lr</font><font color="#CCCCCC"> is not</font>

877
00:39:28,510 --> 00:39:32,140
<font color="#E5E5E5">would six for it so</font><font color="#CCCCCC"> they look into the</font>

878
00:39:31,630 --> 00:39:34,660
<font color="#E5E5E5">future</font>

879
00:39:32,140 --> 00:39:37,750
<font color="#E5E5E5">my intro will introduce a</font><font color="#CCCCCC"> fifth patreon</font>

880
00:39:34,660 --> 00:39:39,549
level giving us a larger<font color="#CCCCCC"> nine</font><font color="#E5E5E5"> did larger</font>

881
00:39:37,750 --> 00:39:41,770
virtual<font color="#E5E5E5"> address space meaning</font><font color="#CCCCCC"> that we</font>

882
00:39:39,550 --> 00:39:42,760
<font color="#E5E5E5">have more interview for Colonel address</font>

883
00:39:41,770 --> 00:39:45,910
<font color="#CCCCCC">space randomizations</font>

884
00:39:42,760 --> 00:39:47,140
<font color="#E5E5E5">here is an opinion my iPhone think that</font>

885
00:39:45,910 --> 00:39:49,240
more entropy<font color="#E5E5E5"> is likely to fix this</font>

886
00:39:47,140 --> 00:39:51,069
problem because we<font color="#CCCCCC"> can serve the cash</font>

887
00:39:49,240 --> 00:39:54,069
observe the<font color="#E5E5E5"> cash level with proficient</font>

888
00:39:51,070 --> 00:39:56,350
TSX we can do a<font color="#CCCCCC"> breakfast scan doing</font>

889
00:39:54,070 --> 00:39:59,920
half terabyte steps at a time<font color="#CCCCCC"> meaning</font>

890
00:39:56,350 --> 00:40:04,150
<font color="#CCCCCC">that we're likely</font><font color="#E5E5E5"> to be able to run</font>

891
00:39:59,920 --> 00:40:06,790
through<font color="#E5E5E5"> even a</font><font color="#CCCCCC"> 70 57 bit virtual address</font>

892
00:40:04,150 --> 00:40:10,810
space in a reasonable time<font color="#E5E5E5"> unless they</font>

893
00:40:06,790 --> 00:40:13,480
change other<font color="#E5E5E5"> things in the CPU</font><font color="#CCCCCC"> so thank</font>

894
00:40:10,810 --> 00:40:14,560
you<font color="#CCCCCC"> I hope the picture here looks</font>

895
00:40:13,480 --> 00:40:17,050
something like the picture<font color="#E5E5E5"> that I</font>

896
00:40:14,560 --> 00:40:17,860
painted of<font color="#E5E5E5"> chaos LR there's a nice</font>

897
00:40:17,050 --> 00:40:22,590
romantic

898
00:40:17,860 --> 00:40:26,040
<font color="#CCCCCC">hada</font><font color="#E5E5E5"> on a lake and a big ugly duckling</font>

899
00:40:22,590 --> 00:40:30,490
<font color="#E5E5E5">swimming in the lake</font><font color="#CCCCCC"> so thank you</font>

900
00:40:26,040 --> 00:40:32,550
[Applause]

901
00:40:30,490 --> 00:40:32,549
you

