1
00:00:08,850 --> 00:00:16,379
[Music]

2
00:00:13,590 --> 00:00:20,529
if dengue helped us grocery

3
00:00:16,379 --> 00:00:24,540
fantastisch all right so our next talk

4
00:00:20,529 --> 00:00:28,480
on this stage we are here on ccc camp

5
00:00:24,540 --> 00:00:32,049
2019 and here on the planck stage direct

6
00:00:28,480 --> 00:00:34,390
next to the to the 300 monkeys village

7
00:00:32,049 --> 00:00:38,980
we have a we have two very special

8
00:00:34,390 --> 00:00:41,860
special speakers for you so I want you I

9
00:00:38,980 --> 00:00:51,309
want you to give a warm applause and one

10
00:00:41,860 --> 00:00:54,280
welcome to Hobart and Christian so robot

11
00:00:51,309 --> 00:00:58,030
and Christian will talk about processors

12
00:00:54,280 --> 00:01:01,120
in processors and what you can find out

13
00:00:58,030 --> 00:01:03,699
by dissecting them and maybe how to

14
00:01:01,120 --> 00:01:05,890
dissect them and the end we'll do a

15
00:01:03,699 --> 00:01:08,140
short Q&A I will come to you with

16
00:01:05,890 --> 00:01:09,790
microphone and so we have your question

17
00:01:08,140 --> 00:01:14,320
on the on the stream and on the

18
00:01:09,790 --> 00:01:18,340
recording and I want you to have much

19
00:01:14,320 --> 00:01:23,970
fun today with dissecting the AMD

20
00:01:18,340 --> 00:01:23,970
platform security processor so have fun

21
00:01:25,840 --> 00:01:32,950
[Applause]

22
00:01:30,090 --> 00:01:37,240
welcome to dissecting the AMD platform

23
00:01:32,950 --> 00:01:40,180
security processor who are we this is Ho

24
00:01:37,240 --> 00:01:43,770
bot he's a PhD candidate at the tu in

25
00:01:40,180 --> 00:01:48,280
Berlin and his research focuses on AMD

26
00:01:43,770 --> 00:01:50,289
encryption technology and I actually did

27
00:01:48,280 --> 00:01:52,780
my master's thesis about the AMD

28
00:01:50,290 --> 00:01:55,630
platform security processor with them

29
00:01:52,780 --> 00:02:00,340
and what this exactly is I'm gonna tell

30
00:01:55,630 --> 00:02:03,810
you in just a second so this talk is

31
00:02:00,340 --> 00:02:06,520
going to present our firmware research

32
00:02:03,810 --> 00:02:11,050
but we're not really firmware

33
00:02:06,520 --> 00:02:13,720
researchers as is so we want you to get

34
00:02:11,050 --> 00:02:16,920
to know our methods of reverse

35
00:02:13,720 --> 00:02:20,920
engineering such a deeply embedded and

36
00:02:16,920 --> 00:02:23,000
proprietary system such as the PSP so

37
00:02:20,920 --> 00:02:24,769
this talk is suit

38
00:02:23,000 --> 00:02:28,340
for everybody who's interested in

39
00:02:24,770 --> 00:02:30,470
reverse engineering everybody who might

40
00:02:28,340 --> 00:02:33,500
be curious what processors inside

41
00:02:30,470 --> 00:02:39,470
processors do and maybe also people who

42
00:02:33,500 --> 00:02:43,010
are into x86 firmware let's start off

43
00:02:39,470 --> 00:02:45,859
with some background if you've read the

44
00:02:43,010 --> 00:02:48,620
news recently you might have recognized

45
00:02:45,860 --> 00:02:53,450
that AMD's market share is growing

46
00:02:48,620 --> 00:02:56,720
massively so it might it might be worth

47
00:02:53,450 --> 00:02:59,540
to look at the security of AMD CPUs more

48
00:02:56,720 --> 00:03:01,850
closely than ever the AMD secure

49
00:02:59,540 --> 00:03:06,560
processor which we're going to call PSP

50
00:03:01,850 --> 00:03:11,870
in this talk is an arm cortex a5 built

51
00:03:06,560 --> 00:03:14,510
into your AMD CPU since 2013 it's as I

52
00:03:11,870 --> 00:03:17,360
said CPU and set.you CPU and it exists

53
00:03:14,510 --> 00:03:21,170
both on desktop as well as server

54
00:03:17,360 --> 00:03:24,400
variants of AMD processors so the

55
00:03:21,170 --> 00:03:27,230
current Rison and epic series

56
00:03:24,400 --> 00:03:30,530
unfortunately the PSP runs undocumented

57
00:03:27,230 --> 00:03:32,209
and proprietary firmware it doesn't have

58
00:03:30,530 --> 00:03:35,720
full access to the system memory

59
00:03:32,209 --> 00:03:38,030
including your actual x86 processor and

60
00:03:35,720 --> 00:03:40,280
you might argue that it's very similar

61
00:03:38,030 --> 00:03:44,720
to the internal management engine some

62
00:03:40,280 --> 00:03:47,810
of you might have heard of before so

63
00:03:44,720 --> 00:03:50,359
what did we learn from others regarding

64
00:03:47,810 --> 00:03:53,299
AMD subsystems there's the system

65
00:03:50,360 --> 00:03:57,260
management you'd system management unit

66
00:03:53,299 --> 00:04:00,799
responsible for power management amongst

67
00:03:57,260 --> 00:04:05,390
others it was detected by hood of malok

68
00:04:00,799 --> 00:04:07,549
already in 2014 at the 31 c3 and he

69
00:04:05,390 --> 00:04:10,690
managed to get arbitrary code execution

70
00:04:07,549 --> 00:04:13,790
on this very delicate piece of hardware

71
00:04:10,690 --> 00:04:17,290
the Intel management engine was covered

72
00:04:13,790 --> 00:04:20,450
with two talks at the at the Kaos

73
00:04:17,290 --> 00:04:22,340
Congress at 2017 there were several

74
00:04:20,450 --> 00:04:25,000
vulnerabilities over the last years

75
00:04:22,340 --> 00:04:28,070
including remote codes a code execution

76
00:04:25,000 --> 00:04:31,880
they're there for open source projects

77
00:04:28,070 --> 00:04:34,750
that try to neuter the abilities of the

78
00:04:31,880 --> 00:04:34,750
management engine

79
00:04:35,210 --> 00:04:40,250
so to sum up our motivation for this

80
00:04:37,580 --> 00:04:42,740
research and especially the focus of

81
00:04:40,250 --> 00:04:45,350
this talk we wanted to reverse engineer

82
00:04:42,740 --> 00:04:47,770
that thing we wanted to see if we can

83
00:04:45,350 --> 00:04:51,970
understand the inner workings of the PSP

84
00:04:47,770 --> 00:04:51,969
although its proprietary

85
00:04:52,240 --> 00:04:58,250
there are cloud security or memory

86
00:04:55,759 --> 00:04:59,990
encryption features by AMD which we're

87
00:04:58,250 --> 00:05:03,289
not going to cover so much in this talk

88
00:04:59,990 --> 00:05:06,410
but the PSP is a crucial component to

89
00:05:03,289 --> 00:05:11,750
implement these and we're about to

90
00:05:06,410 --> 00:05:16,039
publish a paper about these technologies

91
00:05:11,750 --> 00:05:16,789
in the near future and of course system

92
00:05:16,039 --> 00:05:18,530
security

93
00:05:16,789 --> 00:05:23,530
that's the PSP make our system more

94
00:05:18,530 --> 00:05:26,570
secure or does it make it less secure

95
00:05:23,530 --> 00:05:28,849
first of all we need to talk about the

96
00:05:26,570 --> 00:05:31,009
firmware and where the firmware actually

97
00:05:28,849 --> 00:05:34,449
is because in the beginning of this

98
00:05:31,009 --> 00:05:34,449
research we didn't know where it is

99
00:05:35,169 --> 00:05:45,889
what you see here is a Lenovo ThinkPad a

100
00:05:39,849 --> 00:05:50,479
285 from the bottom you can coarsely

101
00:05:45,889 --> 00:05:56,030
spot CPU under a heat sink you can spot

102
00:05:50,479 --> 00:05:59,210
an SSD and what's a bit hard to spot is

103
00:05:56,030 --> 00:06:03,580
an SPI flash this is a non-volatile

104
00:05:59,210 --> 00:06:08,000
memory that that is responsible for

105
00:06:03,580 --> 00:06:11,359
storing the BIOS or today it's called

106
00:06:08,000 --> 00:06:13,759
UEFI so in a traditional boot the CPU

107
00:06:11,360 --> 00:06:17,349
would first grab code and data from this

108
00:06:13,759 --> 00:06:20,599
SPI flash and only then after having

109
00:06:17,349 --> 00:06:22,400
proper drivers it can load such a

110
00:06:20,599 --> 00:06:28,039
complex thing as an operating system

111
00:06:22,400 --> 00:06:31,310
from the SSD an AMD boot looks a bit

112
00:06:28,039 --> 00:06:33,620
different as we as we already knew

113
00:06:31,310 --> 00:06:35,900
before a research the PSP was a crucial

114
00:06:33,620 --> 00:06:40,880
part of the boot process in fact it

115
00:06:35,900 --> 00:06:45,409
boots before the x86 CPU comes up so we

116
00:06:40,880 --> 00:06:47,659
assumed that might be part of the of the

117
00:06:45,409 --> 00:06:48,980
Yui fire or at least it might be stored

118
00:06:47,659 --> 00:06:56,950
on the SPI flash

119
00:06:48,980 --> 00:07:01,340
- so the contents of the SPI flash I

120
00:06:56,950 --> 00:07:04,969
called you if I image and this 16

121
00:07:01,340 --> 00:07:07,760
megabyte image actually is completely

122
00:07:04,970 --> 00:07:12,380
replaced when you do what is still

123
00:07:07,760 --> 00:07:14,120
called often a bias update the the

124
00:07:12,380 --> 00:07:17,090
format of this you Aoife image is

125
00:07:14,120 --> 00:07:19,480
standardized so why don't we just have a

126
00:07:17,090 --> 00:07:19,479
look inside

127
00:07:19,570 --> 00:07:26,690
using the open source tool you effectual

128
00:07:23,090 --> 00:07:28,940
we can parse the UEFI image and what we

129
00:07:26,690 --> 00:07:31,400
see here among other things is for

130
00:07:28,940 --> 00:07:33,260
example that it's exactly the 60

131
00:07:31,400 --> 00:07:37,969
megabyte in size that's exactly the size

132
00:07:33,260 --> 00:07:41,090
of the spi flash memory and we see some

133
00:07:37,970 --> 00:07:44,870
things related to the efi to the boot

134
00:07:41,090 --> 00:07:47,859
process of the x86 cpu what we also see

135
00:07:44,870 --> 00:07:51,620
is something called a petting a

136
00:07:47,860 --> 00:07:55,390
non-empty padding and this non empty

137
00:07:51,620 --> 00:07:55,390
padding is where it gets interesting

138
00:07:56,410 --> 00:08:04,100
using the popular firmware analysis tool

139
00:07:59,900 --> 00:08:07,489
bin walk or more specifically it's it's

140
00:08:04,100 --> 00:08:09,200
option to recognize processor

141
00:08:07,490 --> 00:08:14,000
instructions of different architectures

142
00:08:09,200 --> 00:08:15,940
and using it on the bios image we see

143
00:08:14,000 --> 00:08:19,550
that there arm instructions inside

144
00:08:15,940 --> 00:08:22,430
remember it's an x86 bios update so we

145
00:08:19,550 --> 00:08:27,020
might be close to the PSP firmware we

146
00:08:22,430 --> 00:08:30,560
are looking for and we were really close

147
00:08:27,020 --> 00:08:32,659
so the central data structure in what we

148
00:08:30,560 --> 00:08:36,110
call the firmware file system of the PSP

149
00:08:32,659 --> 00:08:41,659
is a directory which you can see here in

150
00:08:36,110 --> 00:08:44,210
a hex editorial mmm so a directory as we

151
00:08:41,659 --> 00:08:47,469
found out starch starts with a magic

152
00:08:44,210 --> 00:08:51,350
string in this case it's dollar PSP

153
00:08:47,470 --> 00:08:53,660
there is a checksum that provides some

154
00:08:51,350 --> 00:08:56,360
error detection but no nothing else

155
00:08:53,660 --> 00:08:58,569
there's a number of elements that will

156
00:08:56,360 --> 00:09:02,630
be listed in this directory and

157
00:08:58,570 --> 00:09:05,460
something else we haven't find out about

158
00:09:02,630 --> 00:09:08,160
one of those entries or each of those

159
00:09:05,460 --> 00:09:13,680
entries consists of a type it's just an

160
00:09:08,160 --> 00:09:15,540
integer size all in little-endian and an

161
00:09:13,680 --> 00:09:18,959
address where it's located inside the

162
00:09:15,540 --> 00:09:22,079
ufi image and then there's one very

163
00:09:18,960 --> 00:09:24,810
special type of directory entry which

164
00:09:22,080 --> 00:09:27,840
actually doesn't point to for example

165
00:09:24,810 --> 00:09:29,729
data or code but it pointed to another

166
00:09:27,840 --> 00:09:32,790
directory which we call a secondary

167
00:09:29,730 --> 00:09:36,960
directory this might be two to legacy

168
00:09:32,790 --> 00:09:39,839
reasons maybe older PSPs could only

169
00:09:36,960 --> 00:09:42,150
store 16 entries in the directories so

170
00:09:39,840 --> 00:09:46,350
this was a way to actually have larger

171
00:09:42,150 --> 00:09:48,030
directories than this but how did we how

172
00:09:46,350 --> 00:09:50,790
did we get there how did we get to the

173
00:09:48,030 --> 00:09:53,069
directory now we use BIM walk to just

174
00:09:50,790 --> 00:09:55,680
find some arm instructions somewhere

175
00:09:53,070 --> 00:09:59,460
inside the UEFA image but to be able to

176
00:09:55,680 --> 00:10:02,219
properly pass the firmware we had to

177
00:09:59,460 --> 00:10:04,380
find the firmware entry table and this

178
00:10:02,220 --> 00:10:08,070
firmware entry table we found out about

179
00:10:04,380 --> 00:10:09,570
through the core board project the core

180
00:10:08,070 --> 00:10:12,450
board project is an open source bias

181
00:10:09,570 --> 00:10:15,150
implementation which used to support

182
00:10:12,450 --> 00:10:18,780
systems with early versions of the psp2

183
00:10:15,150 --> 00:10:21,660
and the firmware entry table is there's

184
00:10:18,780 --> 00:10:23,850
only one of those and one UEFI image it

185
00:10:21,660 --> 00:10:27,329
begins with a specific bytes sequence

186
00:10:23,850 --> 00:10:34,050
and at least point us to firmware blobs

187
00:10:27,330 --> 00:10:36,900
such as PHP directories so now we end up

188
00:10:34,050 --> 00:10:38,849
with what we call entries or what you

189
00:10:36,900 --> 00:10:42,990
could call the files of the firmware

190
00:10:38,850 --> 00:10:46,560
file systems and there are two major and

191
00:10:42,990 --> 00:10:49,410
important types of entries you found one

192
00:10:46,560 --> 00:10:53,130
type is a public key entry this data

193
00:10:49,410 --> 00:10:55,890
structure holds information about a

194
00:10:53,130 --> 00:10:58,800
cryptographic key that can be used to

195
00:10:55,890 --> 00:11:01,710
verify signatures of other components

196
00:10:58,800 --> 00:11:04,709
this is actually the only data structure

197
00:11:01,710 --> 00:11:06,390
that is publicly documented by AMD as

198
00:11:04,710 --> 00:11:09,600
it's part of one of its memory

199
00:11:06,390 --> 00:11:12,150
encryption technologies and apart from

200
00:11:09,600 --> 00:11:14,430
one special key the route signing key

201
00:11:12,150 --> 00:11:16,339
all the keys can contain signatures

202
00:11:14,430 --> 00:11:18,989
themselves too

203
00:11:16,339 --> 00:11:22,829
the second important type is a header

204
00:11:18,990 --> 00:11:25,949
entry an entry with the header and it

205
00:11:22,829 --> 00:11:29,819
contains the header of 256 bytes with

206
00:11:25,949 --> 00:11:32,519
metadata such as what key was I signed

207
00:11:29,819 --> 00:11:35,969
with and these entries can have a

208
00:11:32,519 --> 00:11:37,920
trailing signature and they can for

209
00:11:35,970 --> 00:11:42,779
example be Z lip compressed compressed

210
00:11:37,920 --> 00:11:45,569
too so now that I've shown you what we

211
00:11:42,779 --> 00:11:48,930
found out about this proprietary simple

212
00:11:45,569 --> 00:11:51,750
file system I want you to show I want to

213
00:11:48,930 --> 00:11:54,359
show you peace patrol peace patrol is an

214
00:11:51,750 --> 00:11:59,339
open source now open source tool we

215
00:11:54,360 --> 00:12:06,259
developed to two powers PSP firmware

216
00:11:59,339 --> 00:12:06,259
from UEFA images so what we have here

217
00:12:07,730 --> 00:12:17,879
can you read this what we have here is a

218
00:12:14,779 --> 00:12:19,889
UEFI update or bias update for the

219
00:12:17,879 --> 00:12:20,370
Lenovo ThinkPad you saw earlier from the

220
00:12:19,889 --> 00:12:25,589
bottom

221
00:12:20,370 --> 00:12:29,370
so using PSP tral we can get an overview

222
00:12:25,589 --> 00:12:33,779
of all the directories and entries that

223
00:12:29,370 --> 00:12:36,449
we passed from this so using also some

224
00:12:33,779 --> 00:12:39,809
other older la boot resources we found

225
00:12:36,449 --> 00:12:42,269
out which integer type belongs to what

226
00:12:39,809 --> 00:12:45,240
kind of strings so we found some things

227
00:12:42,269 --> 00:12:46,980
like a PSP firmware bootloader something

228
00:12:45,240 --> 00:12:51,930
like a system management off chip

229
00:12:46,980 --> 00:12:54,120
firmware or similar things if you would

230
00:12:51,930 --> 00:13:00,089
like to start exploring the firmware

231
00:12:54,120 --> 00:13:05,120
that runs on your AMD processor you can

232
00:13:00,089 --> 00:13:10,220
for example extract and uncompress all

233
00:13:05,120 --> 00:13:10,220
entries of this specific firmware

234
00:13:13,500 --> 00:13:19,780
and now what you will find is a

235
00:13:17,680 --> 00:13:22,150
directory with all these entries as

236
00:13:19,780 --> 00:13:25,990
separate files and for example keys

237
00:13:22,150 --> 00:13:28,050
possible by open SSL - if we want to

238
00:13:25,990 --> 00:13:31,480
have a short glimpse inside one of those

239
00:13:28,050 --> 00:13:35,469
files we get for example look up some

240
00:13:31,480 --> 00:13:38,890
strings in one of those files let's say

241
00:13:35,470 --> 00:13:44,680
for example the PSP boot time trust

242
00:13:38,890 --> 00:13:46,510
let's whatever that is and there we go

243
00:13:44,680 --> 00:13:49,810
this might be the perfect starting point

244
00:13:46,510 --> 00:14:00,189
to start reversing the PSP boot time

245
00:13:49,810 --> 00:14:04,599
trust let's so peace patrol is available

246
00:14:00,190 --> 00:14:06,790
on github you can get it and get a BIOS

247
00:14:04,600 --> 00:14:11,500
update of your favorite machine and then

248
00:14:06,790 --> 00:14:14,410
check out the firmware that's inside so

249
00:14:11,500 --> 00:14:16,630
now that we got hold of the firmware

250
00:14:14,410 --> 00:14:19,089
itself of course we wanted to find out

251
00:14:16,630 --> 00:14:23,050
if we could execute our own code or if

252
00:14:19,090 --> 00:14:25,030
we could manipulate existing code for

253
00:14:23,050 --> 00:14:28,839
that we had to manipulate the UEFI image

254
00:14:25,030 --> 00:14:30,970
and this is feasible in two manners the

255
00:14:28,840 --> 00:14:33,450
first one is through software for

256
00:14:30,970 --> 00:14:36,940
example through an operating system

257
00:14:33,450 --> 00:14:39,100
sorry through a BIOS update utility

258
00:14:36,940 --> 00:14:42,310
inside your running operating system

259
00:14:39,100 --> 00:14:44,950
this will write the new u Aoife image to

260
00:14:42,310 --> 00:14:46,930
a specific area memory trigger system

261
00:14:44,950 --> 00:14:50,170
management interrupt and on the next

262
00:14:46,930 --> 00:14:52,329
reboot it will write the new contents of

263
00:14:50,170 --> 00:14:55,750
this UEFI image into your spi flash

264
00:14:52,330 --> 00:14:57,820
memory then of course from the BIOS

265
00:14:55,750 --> 00:15:01,780
configuration during boot up you can

266
00:14:57,820 --> 00:15:04,570
oftentimes also program a new you if I

267
00:15:01,780 --> 00:15:08,380
image but although this might be

268
00:15:04,570 --> 00:15:12,010
suitable for a real world attack for our

269
00:15:08,380 --> 00:15:14,620
experiments it's not very handy since as

270
00:15:12,010 --> 00:15:17,290
soon as we would have a non-functioning

271
00:15:14,620 --> 00:15:19,720
UEFI image the system wouldn't put any

272
00:15:17,290 --> 00:15:22,900
more at all and we wouldn't be able to

273
00:15:19,720 --> 00:15:25,030
get back to a functioning state so

274
00:15:22,900 --> 00:15:28,000
that's why we did it through hardware

275
00:15:25,030 --> 00:15:31,920
having access to the spi chip on the

276
00:15:28,000 --> 00:15:31,920
main board and using an SPI programmer

277
00:15:32,580 --> 00:15:37,750
now what you see here is again our

278
00:15:35,290 --> 00:15:41,170
Lenovo ThinkPad and the background you

279
00:15:37,750 --> 00:15:44,350
can you can see that we're connected to

280
00:15:41,170 --> 00:15:48,219
the flash and what will you see in front

281
00:15:44,350 --> 00:15:51,580
is an SPI programmer so the black thing

282
00:15:48,220 --> 00:15:55,240
on the bottom is the programmer it's

283
00:15:51,580 --> 00:15:58,000
like five hero Hardware in this case

284
00:15:55,240 --> 00:16:01,060
it's combined with a 1.8 voltage across

285
00:15:58,000 --> 00:16:05,790
if Terr since the flash on the lenovo

286
00:16:01,060 --> 00:16:08,979
thinkpad runs in an unusual voltage an

287
00:16:05,790 --> 00:16:12,040
SPI is a really simple protocol it's

288
00:16:08,980 --> 00:16:14,380
also used for SD cards and LCDs you

289
00:16:12,040 --> 00:16:16,329
might have heard about a SPI already

290
00:16:14,380 --> 00:16:20,860
yesterday and drama Watson's talk about

291
00:16:16,330 --> 00:16:24,430
the spy spy and it mainly consists of

292
00:16:20,860 --> 00:16:27,130
four channels chip select that means is

293
00:16:24,430 --> 00:16:30,400
the master the chipset speaking or the

294
00:16:27,130 --> 00:16:34,390
slave the spi flash memory data out and

295
00:16:30,400 --> 00:16:37,120
data in for communication the respective

296
00:16:34,390 --> 00:16:39,970
direction and the clock for

297
00:16:37,120 --> 00:16:43,390
synchronization so with this we can

298
00:16:39,970 --> 00:16:45,210
externally program the flesh and then we

299
00:16:43,390 --> 00:16:48,250
can boot the system and see what happens

300
00:16:45,210 --> 00:16:50,950
but the problem is this gives us only

301
00:16:48,250 --> 00:16:53,770
binary output either the system boots or

302
00:16:50,950 --> 00:16:59,530
doesn't boot but we wanted something

303
00:16:53,770 --> 00:17:02,290
more sophisticated so we took a logic

304
00:16:59,530 --> 00:17:05,250
analyzer a logic analyzer is an

305
00:17:02,290 --> 00:17:10,180
electronic instrument that can record

306
00:17:05,250 --> 00:17:13,689
the data flow on electronic lines logic

307
00:17:10,180 --> 00:17:16,420
lines so we hook this on to the flesh

308
00:17:13,689 --> 00:17:19,089
then boot the system and recorded the

309
00:17:16,420 --> 00:17:21,819
boot procedure and we want and through

310
00:17:19,089 --> 00:17:24,879
this we we wanted to see what parts of

311
00:17:21,819 --> 00:17:29,290
the SPI flash are exactly accessed at

312
00:17:24,880 --> 00:17:31,990
what time during the boot process using

313
00:17:29,290 --> 00:17:35,260
the accompanying software of this logic

314
00:17:31,990 --> 00:17:37,510
analyzer it's actually a salia logic

315
00:17:35,260 --> 00:17:40,530
analyzer it's around 350 euros but

316
00:17:37,510 --> 00:17:46,030
they're definitely cheaper ones away

317
00:17:40,530 --> 00:17:50,100
you can see you can you can really see

318
00:17:46,030 --> 00:17:53,500
what's happening so for example this is

319
00:17:50,100 --> 00:17:55,360
a read command on the data in line so

320
00:17:53,500 --> 00:17:59,350
that's that's a command sent from the

321
00:17:55,360 --> 00:18:02,229
chipset to the SPI flash memory that the

322
00:17:59,350 --> 00:18:06,250
hex byte 3 is a read is documented in

323
00:18:02,230 --> 00:18:09,820
the in the manual of the spi chip and

324
00:18:06,250 --> 00:18:13,780
then what follows is an address e 2 0 0

325
00:18:09,820 --> 00:18:17,110
0 0 and then the flash chip will gladly

326
00:18:13,780 --> 00:18:18,550
respond with data at that position we're

327
00:18:17,110 --> 00:18:20,649
actually not so much interested in the

328
00:18:18,550 --> 00:18:23,080
data that comes back because as you

329
00:18:20,650 --> 00:18:26,850
remember this is what we control we can

330
00:18:23,080 --> 00:18:31,230
program the spi flash memory as we want

331
00:18:26,850 --> 00:18:37,510
we're more interested in the order of

332
00:18:31,230 --> 00:18:39,820
the read commands especially so we wrote

333
00:18:37,510 --> 00:18:43,390
another small tool it's called PHP trace

334
00:18:39,820 --> 00:18:46,750
it takes one of those traces by the

335
00:18:43,390 --> 00:18:50,860
logic analyzer on one hand and on the

336
00:18:46,750 --> 00:18:53,830
other hand it takes in the the UEFI

337
00:18:50,860 --> 00:18:55,330
image and it will parse the file system

338
00:18:53,830 --> 00:18:57,970
the firmware file system in it and

339
00:18:55,330 --> 00:19:00,580
correlate that information so what

340
00:18:57,970 --> 00:19:03,790
you'll end up with is a really nice

341
00:19:00,580 --> 00:19:06,310
overview of the boot process and it's

342
00:19:03,790 --> 00:19:07,270
first of all the proof that the PSP

343
00:19:06,310 --> 00:19:11,830
comes up first

344
00:19:07,270 --> 00:19:14,410
PSP code is loaded first and then only

345
00:19:11,830 --> 00:19:21,040
later it follows the UEFI but we'll get

346
00:19:14,410 --> 00:19:23,560
more into detail about this one soon so

347
00:19:21,040 --> 00:19:26,760
from those experiments we gained some

348
00:19:23,560 --> 00:19:28,810
important insights about this black box

349
00:19:26,760 --> 00:19:31,330
the entries are cryptography

350
00:19:28,810 --> 00:19:33,790
cryptographically protected by signature

351
00:19:31,330 --> 00:19:35,919
we didn't only find the signature we

352
00:19:33,790 --> 00:19:39,610
found out if we would alter a byte in

353
00:19:35,920 --> 00:19:42,760
the entry it wouldn't it wouldn't it

354
00:19:39,610 --> 00:19:44,740
won't put any more so one of those

355
00:19:42,760 --> 00:19:46,990
header fields determines their recording

356
00:19:44,740 --> 00:19:49,180
public key compressed entries are

357
00:19:46,990 --> 00:19:52,750
actually uncompressed first and only

358
00:19:49,180 --> 00:19:55,120
then they are signature checked

359
00:19:52,750 --> 00:20:01,090
and there's a header field that

360
00:19:55,120 --> 00:20:03,520
determines the the exact size so as we

361
00:20:01,090 --> 00:20:07,030
also found out the AMD root public key

362
00:20:03,520 --> 00:20:09,129
is does not have a signature but when we

363
00:20:07,030 --> 00:20:10,510
would try to alter this one and the

364
00:20:09,130 --> 00:20:12,700
system wouldn't boot anymore so we

365
00:20:10,510 --> 00:20:20,110
assume there's maybe a hash of the root

366
00:20:12,700 --> 00:20:22,210
key in read-only memory what you can see

367
00:20:20,110 --> 00:20:25,659
here is just to give you a glimpse of

368
00:20:22,210 --> 00:20:28,120
what this looked like to us and in the

369
00:20:25,660 --> 00:20:32,560
beginning a header of such an entry a

370
00:20:28,120 --> 00:20:34,780
body and a trailing signature so with

371
00:20:32,560 --> 00:20:36,399
this I'm gonna hand over to Hobart to

372
00:20:34,780 --> 00:20:46,300
tell you about what we actually found

373
00:20:36,400 --> 00:20:49,390
out about the firmware alright thanks so

374
00:20:46,300 --> 00:20:52,419
if you look again at SBI trace of the

375
00:20:49,390 --> 00:20:56,320
PSP firmware we will see something like

376
00:20:52,420 --> 00:20:58,180
this so in the first four entries what

377
00:20:56,320 --> 00:21:02,530
you see here what happens is the

378
00:20:58,180 --> 00:21:05,800
following so a component usually an

379
00:21:02,530 --> 00:21:08,139
on-chip bootloader will read the

380
00:21:05,800 --> 00:21:11,889
firmware entry table determine the PSP

381
00:21:08,140 --> 00:21:14,200
directory lot the MD public key use the

382
00:21:11,890 --> 00:21:18,690
MB public key to verify the authenticity

383
00:21:14,200 --> 00:21:21,940
of the fw bootloader and then execute it

384
00:21:18,690 --> 00:21:25,300
so you can see here that's a rather

385
00:21:21,940 --> 00:21:28,660
large delay after that happens so in

386
00:21:25,300 --> 00:21:31,960
that delay the PSP FW bootloader which

387
00:21:28,660 --> 00:21:35,170
is loaded from flash is executed so the

388
00:21:31,960 --> 00:21:38,440
PSP FW bootloader initializes the the

389
00:21:35,170 --> 00:21:40,750
system and when it's done that it will

390
00:21:38,440 --> 00:21:42,640
load additional applications from the

391
00:21:40,750 --> 00:21:47,640
flash which you see in subsequent

392
00:21:42,640 --> 00:21:50,740
accesses to the SBI flash now so this

393
00:21:47,640 --> 00:21:52,480
this bootloader is the first component

394
00:21:50,740 --> 00:21:56,530
which is loaded from flash which

395
00:21:52,480 --> 00:21:59,230
contains instructions and this huge

396
00:21:56,530 --> 00:22:00,790
delay gave us the idea that we want to

397
00:21:59,230 --> 00:22:04,780
have close look at that specific

398
00:22:00,790 --> 00:22:06,290
component right so we can extract that

399
00:22:04,780 --> 00:22:08,629
component from an

400
00:22:06,290 --> 00:22:11,149
an image using the PSP tool and then

401
00:22:08,630 --> 00:22:13,040
just I don't again first look at some

402
00:22:11,150 --> 00:22:16,100
strings let's see what we find in this

403
00:22:13,040 --> 00:22:19,010
boot order so this is an output of the

404
00:22:16,100 --> 00:22:21,590
strings contained in a PSP bootloader

405
00:22:19,010 --> 00:22:23,750
from an aim D epic so the server variant

406
00:22:21,590 --> 00:22:25,370
system so what you see here actually

407
00:22:23,750 --> 00:22:27,770
there's some strings which are

408
00:22:25,370 --> 00:22:31,969
interesting for us for example it says

409
00:22:27,770 --> 00:22:34,520
PSP FW bootloader version right so when

410
00:22:31,970 --> 00:22:36,080
you just have this component at hand you

411
00:22:34,520 --> 00:22:38,090
might think about what could it be but

412
00:22:36,080 --> 00:22:41,240
okay yeah that's the string saying PSP

413
00:22:38,090 --> 00:22:43,939
FW bootloader version so it's not too

414
00:22:41,240 --> 00:22:47,960
far-fetched to say this is the PSP FW

415
00:22:43,940 --> 00:22:50,960
bootloader all right so strings are

416
00:22:47,960 --> 00:22:53,170
always the first thing you could imagine

417
00:22:50,960 --> 00:22:56,120
to check and might may be interesting

418
00:22:53,170 --> 00:22:58,670
but let's have a look at the binary

419
00:22:56,120 --> 00:23:01,729
itself so as we know already the first

420
00:22:58,670 --> 00:23:05,150
tax 100 bytes are just the header so

421
00:23:01,730 --> 00:23:07,370
what comes after that so we took the

422
00:23:05,150 --> 00:23:10,000
binary and put it into this assembler

423
00:23:07,370 --> 00:23:11,989
and what you would see at the first

424
00:23:10,000 --> 00:23:15,740
instructions after the header is

425
00:23:11,990 --> 00:23:17,450
something like this so if anyone here

426
00:23:15,740 --> 00:23:19,480
has some experience with the ARM

427
00:23:17,450 --> 00:23:22,970
architecture maybe someone already

428
00:23:19,480 --> 00:23:26,990
recognizes what that is if not here's

429
00:23:22,970 --> 00:23:30,110
the explanation so the architecture

430
00:23:26,990 --> 00:23:32,270
defines a table for entry points for

431
00:23:30,110 --> 00:23:35,120
privilege code so any a synchronous

432
00:23:32,270 --> 00:23:37,879
event such an interrupt system call a

433
00:23:35,120 --> 00:23:41,239
page fault the CPU has to continue

434
00:23:37,880 --> 00:23:43,220
execution at a specific address and that

435
00:23:41,240 --> 00:23:45,770
specific address is defined in a fixed

436
00:23:43,220 --> 00:23:49,070
table and this table the structure is

437
00:23:45,770 --> 00:23:51,530
defined and when you look at the the

438
00:23:49,070 --> 00:23:55,909
highlighted part what you see here is

439
00:23:51,530 --> 00:23:58,639
that at each offset you have a fixed

440
00:23:55,910 --> 00:24:01,490
entry for the reset vector for undefined

441
00:23:58,640 --> 00:24:03,860
instructions for supervisor call and so

442
00:24:01,490 --> 00:24:06,350
on and each of those vectors is just a

443
00:24:03,860 --> 00:24:08,090
single instruction so what happens is

444
00:24:06,350 --> 00:24:10,850
that an operating system programs that

445
00:24:08,090 --> 00:24:13,189
table in a way that okay the first

446
00:24:10,850 --> 00:24:16,429
vector the reset vector jumped to my

447
00:24:13,190 --> 00:24:19,760
initial initialization code and then for

448
00:24:16,430 --> 00:24:21,530
the SVC vector this is just a jump to my

449
00:24:19,760 --> 00:24:23,270
system called Hendler and from there on

450
00:24:21,530 --> 00:24:26,840
I will determine what system call

451
00:24:23,270 --> 00:24:30,910
happened so when you combine those you

452
00:24:26,840 --> 00:24:33,709
will see the sixth entry is not used and

453
00:24:30,910 --> 00:24:36,340
the sixth entry in our disassembly is

454
00:24:33,710 --> 00:24:40,370
enough instruction so it does nothing so

455
00:24:36,340 --> 00:24:43,510
this is also a like educated guess from

456
00:24:40,370 --> 00:24:46,100
outside this is the vectors table so

457
00:24:43,510 --> 00:24:48,710
let's continue with that assumption if

458
00:24:46,100 --> 00:24:51,199
that is the vector table we want to have

459
00:24:48,710 --> 00:24:56,440
a look at the reset vector code because

460
00:24:51,200 --> 00:24:59,960
that code initializes the system so well

461
00:24:56,440 --> 00:25:01,790
this is the assumption so far and this

462
00:24:59,960 --> 00:25:06,320
is are the first instructions which are

463
00:25:01,790 --> 00:25:09,050
executed on the reset vector so why are

464
00:25:06,320 --> 00:25:09,500
we going through this and the first

465
00:25:09,050 --> 00:25:12,020
place

466
00:25:09,500 --> 00:25:13,970
so one thing we want you alone to learn

467
00:25:12,020 --> 00:25:16,310
now is where in memory this bootloader

468
00:25:13,970 --> 00:25:18,020
is executing because so far we only know

469
00:25:16,310 --> 00:25:20,149
that it's loaded from flash and that

470
00:25:18,020 --> 00:25:23,720
it's executed but we don't know where it

471
00:25:20,150 --> 00:25:25,490
is loaded where in memory okay so we

472
00:25:23,720 --> 00:25:27,230
look at the reset vector the reset

473
00:25:25,490 --> 00:25:29,900
vector should initialize the system and

474
00:25:27,230 --> 00:25:32,900
what we see there is this the reset

475
00:25:29,900 --> 00:25:35,570
vector we sit there a configuration of

476
00:25:32,900 --> 00:25:37,730
register called V bar so the V bar

477
00:25:35,570 --> 00:25:41,240
register on arm architectures defines

478
00:25:37,730 --> 00:25:44,000
the location of this table in memory and

479
00:25:41,240 --> 00:25:47,450
it's an absolute address so this is a

480
00:25:44,000 --> 00:25:51,680
clear indication that at address hex 100

481
00:25:47,450 --> 00:25:55,190
the PSP FW bootloader needs to have is

482
00:25:51,680 --> 00:25:56,720
its vector table and it's loaded at that

483
00:25:55,190 --> 00:26:00,340
specific address so now we know the

484
00:25:56,720 --> 00:26:05,030
physical load address of that component

485
00:26:00,340 --> 00:26:07,370
and we know all the locations of the

486
00:26:05,030 --> 00:26:11,930
different handlers for a system call for

487
00:26:07,370 --> 00:26:14,030
page fault and so on alright now we

488
00:26:11,930 --> 00:26:15,920
continue so this is the code snippet you

489
00:26:14,030 --> 00:26:19,639
saw before with some additional lines

490
00:26:15,920 --> 00:26:22,640
after that just a few instructions later

491
00:26:19,640 --> 00:26:24,890
you will see that it enables paging so

492
00:26:22,640 --> 00:26:28,220
the exact instruction here is not really

493
00:26:24,890 --> 00:26:30,710
relevant just that for you to know this

494
00:26:28,220 --> 00:26:33,110
last instruction on the slide here will

495
00:26:30,710 --> 00:26:33,560
effectively enable paging so now we use

496
00:26:33,110 --> 00:26:35,600
verge

497
00:26:33,560 --> 00:26:37,370
memory where we need a page table which

498
00:26:35,600 --> 00:26:39,980
converts virtual addresses to physical

499
00:26:37,370 --> 00:26:42,679
addresses now where in memory is that

500
00:26:39,980 --> 00:26:44,180
page table located again an arm we have

501
00:26:42,680 --> 00:26:46,850
a specific register for that

502
00:26:44,180 --> 00:26:49,370
it's a TG BR 0 and this register is

503
00:26:46,850 --> 00:26:51,139
configured there so now we know the

504
00:26:49,370 --> 00:26:53,179
physical location of this boot of the

505
00:26:51,140 --> 00:26:56,150
component and we know the physical

506
00:26:53,180 --> 00:27:00,080
location of its page table right it's

507
00:26:56,150 --> 00:27:03,980
page tables loaded at hex 1 4 0 0 0 it's

508
00:27:00,080 --> 00:27:06,320
also fixed physical address so the next

509
00:27:03,980 --> 00:27:09,200
thing we wanted to have a look at is how

510
00:27:06,320 --> 00:27:11,149
can we access this page table we want to

511
00:27:09,200 --> 00:27:13,760
get more information about the system so

512
00:27:11,150 --> 00:27:15,830
the page table will define which virtual

513
00:27:13,760 --> 00:27:18,950
address maps to which physical address

514
00:27:15,830 --> 00:27:20,990
with with what attributes so whether a

515
00:27:18,950 --> 00:27:23,270
page is writable or readable or

516
00:27:20,990 --> 00:27:26,900
executable so we wanted to get that

517
00:27:23,270 --> 00:27:29,570
information too so we know the address

518
00:27:26,900 --> 00:27:31,970
of the page table but of course we just

519
00:27:29,570 --> 00:27:34,879
statically analyze the binary we don't

520
00:27:31,970 --> 00:27:37,870
have any access to the running memory so

521
00:27:34,880 --> 00:27:37,870
what can we do about that

522
00:27:38,290 --> 00:27:46,399
emulation so on a high level an emulator

523
00:27:44,330 --> 00:27:50,149
can emulate the hardware environment of

524
00:27:46,400 --> 00:27:52,720
the device so let's say we would be able

525
00:27:50,150 --> 00:27:54,980
to emulate the PSP we could just stop

526
00:27:52,720 --> 00:27:57,050
execution at an arbitrary point in time

527
00:27:54,980 --> 00:27:59,030
and read out the memory at an arbitrary

528
00:27:57,050 --> 00:28:02,510
address so that's how we could get the

529
00:27:59,030 --> 00:28:06,290
page table so an emulator needs to

530
00:28:02,510 --> 00:28:09,980
emulate both the CPU and the peripherals

531
00:28:06,290 --> 00:28:12,710
of the target system so one of the most

532
00:28:09,980 --> 00:28:16,610
common emulators and which is also open

533
00:28:12,710 --> 00:28:19,310
source is chemo and chemo has support

534
00:28:16,610 --> 00:28:23,270
for arm so this is good because the

535
00:28:19,310 --> 00:28:24,800
piece piece also an arm CPU and chemo

536
00:28:23,270 --> 00:28:28,220
can for example emulate a whole

537
00:28:24,800 --> 00:28:30,440
Raspberry Pi 2 but of course the chemo

538
00:28:28,220 --> 00:28:33,950
does not have support for the PSP it's a

539
00:28:30,440 --> 00:28:37,280
proprietary deeply embedded core which

540
00:28:33,950 --> 00:28:42,260
is not aware as no information publicly

541
00:28:37,280 --> 00:28:46,700
available so chemo can however emulate

542
00:28:42,260 --> 00:28:47,510
the CPU part so just the core however we

543
00:28:46,700 --> 00:28:49,100
don't have an

544
00:28:47,510 --> 00:28:54,080
formation or to memory layout or any

545
00:28:49,100 --> 00:28:56,270
peripherals so for example when you want

546
00:28:54,080 --> 00:28:57,770
to emulate an arm system you probably

547
00:28:56,270 --> 00:28:59,810
want to emulate an interrupt controller

548
00:28:57,770 --> 00:29:02,750
and there are very common interrupt

549
00:28:59,810 --> 00:29:05,389
controllers such as the geek V 4 or 5 or

550
00:29:02,750 --> 00:29:06,860
whatever none of those is used in the

551
00:29:05,390 --> 00:29:08,960
PSP they use a custom interrupt

552
00:29:06,860 --> 00:29:13,070
controller so we're kinda out of luck

553
00:29:08,960 --> 00:29:19,430
there however there is avatar

554
00:29:13,070 --> 00:29:23,480
- so avatar choose and framework that

555
00:29:19,430 --> 00:29:27,980
allows you to implement device emulation

556
00:29:23,480 --> 00:29:29,540
in Python which is way simpler than

557
00:29:27,980 --> 00:29:31,730
having to patch

558
00:29:29,540 --> 00:29:34,879
Kumu to support all of the PSP

559
00:29:31,730 --> 00:29:37,280
functionality a lot I can do a lot more

560
00:29:34,880 --> 00:29:40,790
but I will just focus on the stuff we

561
00:29:37,280 --> 00:29:43,580
used from that so what we have now is

562
00:29:40,790 --> 00:29:46,280
here's an example of how such a simple

563
00:29:43,580 --> 00:29:50,419
device simulation could look like so

564
00:29:46,280 --> 00:29:53,600
when you have navigate to setup you can

565
00:29:50,420 --> 00:29:57,710
program a peripheral with just defining

566
00:29:53,600 --> 00:30:02,360
two functions in this example I define

567
00:29:57,710 --> 00:30:04,430
the HW Reed and an HW write function the

568
00:30:02,360 --> 00:30:06,260
write function does nothing just ignores

569
00:30:04,430 --> 00:30:08,300
whatever is written to this peripheral

570
00:30:06,260 --> 00:30:12,050
and the read function just returns an

571
00:30:08,300 --> 00:30:14,389
arbitrary value so this is a stupid

572
00:30:12,050 --> 00:30:17,120
device but it shows how simple it is in

573
00:30:14,390 --> 00:30:19,340
Avatar to create a device simulation so

574
00:30:17,120 --> 00:30:24,409
you can easily extend that example with

575
00:30:19,340 --> 00:30:26,810
a more complex setup so this specific

576
00:30:24,410 --> 00:30:29,150
device if you would map it to an address

577
00:30:26,810 --> 00:30:31,129
of the emulation when you read from that

578
00:30:29,150 --> 00:30:36,890
address it will always return the same

579
00:30:31,130 --> 00:30:40,370
value now if you want to emulate the PSP

580
00:30:36,890 --> 00:30:43,700
using Kimo and avatar it can be as

581
00:30:40,370 --> 00:30:45,800
simple as I will show you now so when

582
00:30:43,700 --> 00:30:49,190
our troll is it's python-based and uses

583
00:30:45,800 --> 00:30:51,889
Kimo as a back-end you create an hour to

584
00:30:49,190 --> 00:30:54,200
object and then you add memory

585
00:30:51,890 --> 00:30:58,280
information to that object so you say

586
00:30:54,200 --> 00:31:00,720
hey avatar I want to have a file loaded

587
00:30:58,280 --> 00:31:03,240
into memory at this specific address

588
00:31:00,720 --> 00:31:06,690
so for example this line the second line

589
00:31:03,240 --> 00:31:09,620
here says load my bootloader binary

590
00:31:06,690 --> 00:31:12,210
which are Justice extracted at address 0

591
00:31:09,620 --> 00:31:16,050
so then we have 100 bytes of the header

592
00:31:12,210 --> 00:31:20,400
and at address hex 100 our reset vector

593
00:31:16,050 --> 00:31:22,050
starts alright the bootloader uses some

594
00:31:20,400 --> 00:31:24,270
stack so we'll give it just another

595
00:31:22,050 --> 00:31:27,120
memory page of stack memory saying hey

596
00:31:24,270 --> 00:31:30,180
at this address I give you some

597
00:31:27,120 --> 00:31:31,709
additional memory if you look at the

598
00:31:30,180 --> 00:31:34,020
disassembly of the bootloader you will

599
00:31:31,710 --> 00:31:36,840
see that this is the exact page that the

600
00:31:34,020 --> 00:31:38,670
boot order expects its stack to be all

601
00:31:36,840 --> 00:31:42,800
right so now we have the binary we have

602
00:31:38,670 --> 00:31:47,190
stack memory we add some peripherals so

603
00:31:42,800 --> 00:31:49,889
the bootloader expects some peripherals

604
00:31:47,190 --> 00:31:51,810
to be there you don't need to really

605
00:31:49,890 --> 00:31:54,450
implement all of the functionality but

606
00:31:51,810 --> 00:31:56,010
let's say the bootloader expects that

607
00:31:54,450 --> 00:31:59,820
there is an interrupt controller which

608
00:31:56,010 --> 00:32:01,560
has a register saying I'm version 5 so

609
00:31:59,820 --> 00:32:03,300
what you do is okay I add a custom

610
00:32:01,560 --> 00:32:05,280
peripheral it has nothing except for

611
00:32:03,300 --> 00:32:06,810
returning 5 at the correct offset you

612
00:32:05,280 --> 00:32:10,020
don't care about the functionality you

613
00:32:06,810 --> 00:32:13,050
just want emulation to continue okay so

614
00:32:10,020 --> 00:32:15,300
I will add some peripheral then I will

615
00:32:13,050 --> 00:32:18,330
just say ok I initialize the qumu target

616
00:32:15,300 --> 00:32:23,060
I set the start address which is the hax

617
00:32:18,330 --> 00:32:26,340
100 I set a specific CPU module I

618
00:32:23,060 --> 00:32:28,800
initialize the whole thing I set a

619
00:32:26,340 --> 00:32:32,459
breakpoint to an address where I want to

620
00:32:28,800 --> 00:32:34,340
stop the emulation and then I call kimu

621
00:32:32,460 --> 00:32:36,630
continue and this will start

622
00:32:34,340 --> 00:32:39,510
accumulation with the memory layout I

623
00:32:36,630 --> 00:32:42,000
just defined in the spicen setup and the

624
00:32:39,510 --> 00:32:45,510
weight will return once the breakpoint

625
00:32:42,000 --> 00:32:48,420
is hit so this is a very very simple way

626
00:32:45,510 --> 00:32:50,850
to emulate unknown Hardware right I just

627
00:32:48,420 --> 00:32:52,920
looked up some bits of where in the

628
00:32:50,850 --> 00:32:55,110
physical memory the binary expects to be

629
00:32:52,920 --> 00:32:57,180
and then I just start emulating and I

630
00:32:55,110 --> 00:32:59,100
don't even care what any complex

631
00:32:57,180 --> 00:33:02,070
peripherals such as the IQ controller I

632
00:32:59,100 --> 00:33:06,480
can just return the value that the code

633
00:33:02,070 --> 00:33:08,340
expects all right so we have a demo for

634
00:33:06,480 --> 00:33:10,530
that and the demo is also available on

635
00:33:08,340 --> 00:33:13,770
github so with the demo you can emulate

636
00:33:10,530 --> 00:33:27,929
the PSP firmware up to a certain part

637
00:33:13,770 --> 00:33:31,260
I hate to switch that's awesome so let's

638
00:33:27,929 --> 00:33:33,890
solve the demography most worthy showing

639
00:33:31,260 --> 00:33:33,890
you this demo

640
00:34:09,699 --> 00:34:12,540
not take clothes off

641
00:34:19,230 --> 00:34:24,869
all right so what you see here is I will

642
00:34:22,320 --> 00:34:27,210
now execute the Python script which I

643
00:34:24,869 --> 00:34:30,139
wrote to emulate parts of the PSP boot

644
00:34:27,210 --> 00:34:30,139
or a firmware version

645
00:34:37,280 --> 00:34:44,010
okay so you can see here it says virtual

646
00:34:41,668 --> 00:34:47,339
timer an initialized device at some

647
00:34:44,010 --> 00:34:50,159
address this is a implementation of a

648
00:34:47,339 --> 00:34:52,889
timer device I implemented to make the

649
00:34:50,159 --> 00:34:55,169
emulation run as far as I want it to be

650
00:34:52,889 --> 00:34:56,940
it's a very very simple device again it

651
00:34:55,168 --> 00:34:59,190
will just return an incrementing value

652
00:34:56,940 --> 00:35:02,549
whenever something is red this is

653
00:34:59,190 --> 00:35:05,609
sufficient to let firmware emulate after

654
00:35:02,549 --> 00:35:08,400
a certain point now I set a breakpoint

655
00:35:05,609 --> 00:35:11,670
and now it stopped so what can we do

656
00:35:08,400 --> 00:35:16,190
with that well I have now an interactive

657
00:35:11,670 --> 00:35:23,579
ipython shell and my script allows me to

658
00:35:16,190 --> 00:35:27,630
call disconnect gdb the avatar framework

659
00:35:23,579 --> 00:35:31,319
controlled qmo using gdb so now I detach

660
00:35:27,630 --> 00:35:38,599
that from gdb and I will now attach my

661
00:35:31,319 --> 00:35:38,599
own gdb so this is gdb

662
00:35:42,290 --> 00:35:48,900
so now I've attached the gdb to the

663
00:35:44,850 --> 00:35:52,020
emulation running inside Kimo so this is

664
00:35:48,900 --> 00:35:54,510
kind of nice I can inspect some of the

665
00:35:52,020 --> 00:35:57,300
instructions so this is the instructions

666
00:35:54,510 --> 00:36:01,080
which are currently emulated I stopped

667
00:35:57,300 --> 00:36:04,770
at the very first line and coming back

668
00:36:01,080 --> 00:36:06,690
to our original plan right we wanted to

669
00:36:04,770 --> 00:36:09,360
dump the page tables if you can remember

670
00:36:06,690 --> 00:36:12,510
so the Patriots are at the fixed address

671
00:36:09,360 --> 00:36:14,100
the breakpoint I hit here is past the

672
00:36:12,510 --> 00:36:18,270
function that will generate the page

673
00:36:14,100 --> 00:36:20,549
tables so I just have a peek at the

674
00:36:18,270 --> 00:36:23,490
address where I expect the page tables

675
00:36:20,550 --> 00:36:29,760
to be and there they are right doesn't

676
00:36:23,490 --> 00:36:33,509
look too fancy so what you see here is

677
00:36:29,760 --> 00:36:36,510
the dump of the page tables of the PSP

678
00:36:33,510 --> 00:36:38,460
so of course this does not say too much

679
00:36:36,510 --> 00:36:40,650
right I don't know how many of many of

680
00:36:38,460 --> 00:36:46,380
you can read page tables by just looking

681
00:36:40,650 --> 00:36:49,500
at that I hope no one we have where is

682
00:36:46,380 --> 00:36:51,860
it of course we have a script for that

683
00:36:49,500 --> 00:36:56,220
yeah there it is

684
00:36:51,860 --> 00:36:57,780
so what I did now I dumped the memory

685
00:36:56,220 --> 00:36:59,790
containing the page tables and this is a

686
00:36:57,780 --> 00:37:02,550
simple Python script that parses the

687
00:36:59,790 --> 00:37:04,080
page tables this is a lot of information

688
00:37:02,550 --> 00:37:07,470
so I will just highlight what's

689
00:37:04,080 --> 00:37:10,380
interesting here the way to read it is

690
00:37:07,470 --> 00:37:12,419
it starts with a virtual address which

691
00:37:10,380 --> 00:37:13,740
maps to a specific physical address and

692
00:37:12,420 --> 00:37:16,650
you can see it's just one-to-one

693
00:37:13,740 --> 00:37:17,220
mappings not too interesting now it gets

694
00:37:16,650 --> 00:37:21,600
interesting

695
00:37:17,220 --> 00:37:24,689
exactly here so if you let look at that

696
00:37:21,600 --> 00:37:31,710
those four lines in the middle you can

697
00:37:24,690 --> 00:37:34,020
see the AP bits right so right there AP

698
00:37:31,710 --> 00:37:36,000
bits are the access permission bits so

699
00:37:34,020 --> 00:37:38,759
these bits determine who has access to

700
00:37:36,000 --> 00:37:42,900
those page tables and you can see

701
00:37:38,760 --> 00:37:46,680
everything which is below hex one five

702
00:37:42,900 --> 00:37:49,470
zero zero has ap one everything after

703
00:37:46,680 --> 00:37:50,990
has ap one one now if you look up the

704
00:37:49,470 --> 00:37:52,279
our menu you will see that it means

705
00:37:50,990 --> 00:37:55,419
everything

706
00:37:52,280 --> 00:37:57,790
after hacks one five zero zero

707
00:37:55,420 --> 00:38:00,069
user space code everything above is

708
00:37:57,790 --> 00:38:02,259
operating system code so now we have

709
00:38:00,069 --> 00:38:05,170
another piece of information about how

710
00:38:02,260 --> 00:38:07,569
the PSP loads its application and where

711
00:38:05,170 --> 00:38:10,210
I've been know now exactly the user

712
00:38:07,569 --> 00:38:11,950
space applications are or rather their

713
00:38:10,210 --> 00:38:14,859
address space starts as a fixed address

714
00:38:11,950 --> 00:38:17,078
and of course these page tables could

715
00:38:14,859 --> 00:38:20,259
change over time right I stopped at a

716
00:38:17,079 --> 00:38:21,309
specific breakpoint kind of early on so

717
00:38:20,260 --> 00:38:23,859
maybe they change

718
00:38:21,309 --> 00:38:25,930
well they don't so this is the page

719
00:38:23,859 --> 00:38:33,308
table layout of the PSP throughout the

720
00:38:25,930 --> 00:38:36,569
whole usage of that processor alright ok

721
00:38:33,309 --> 00:38:36,569
coming back to the slides

722
00:38:52,460 --> 00:38:57,210
okay

723
00:38:53,640 --> 00:38:59,490
so yeah one thing you can find the

724
00:38:57,210 --> 00:39:01,260
scripts for the emulation on github I

725
00:38:59,490 --> 00:39:03,359
will show the links later on so you can

726
00:39:01,260 --> 00:39:06,930
actually run your own emulation of the

727
00:39:03,360 --> 00:39:09,930
ps3 firmware if you want okay some

728
00:39:06,930 --> 00:39:13,410
insights what we gained here so this is

729
00:39:09,930 --> 00:39:15,810
the memory layout of the PSP the

730
00:39:13,410 --> 00:39:19,440
bootloader is loaded at offset zero it

731
00:39:15,810 --> 00:39:22,680
has a header of 100 hex 100 bytes and it

732
00:39:19,440 --> 00:39:24,870
starts execution at exactly hex 100 it

733
00:39:22,680 --> 00:39:26,940
is privileged code it handled source

734
00:39:24,870 --> 00:39:29,700
codes interrupts at loads applications

735
00:39:26,940 --> 00:39:31,770
then we have the page table at this

736
00:39:29,700 --> 00:39:34,580
specific address and everything below

737
00:39:31,770 --> 00:39:39,270
that up to a certain point is

738
00:39:34,580 --> 00:39:41,400
application code so mmm interesting here

739
00:39:39,270 --> 00:39:43,470
is that at one point in time there was

740
00:39:41,400 --> 00:39:46,640
only one application so the way this

741
00:39:43,470 --> 00:39:49,160
works is the boot order has a fixed

742
00:39:46,640 --> 00:39:51,620
order of applications which are loaded

743
00:39:49,160 --> 00:39:53,009
once an application is running and

744
00:39:51,620 --> 00:39:55,410
finish this

745
00:39:53,010 --> 00:39:59,520
the next is loaded and so on so there's

746
00:39:55,410 --> 00:40:03,149
no Marty threading at all so very simple

747
00:39:59,520 --> 00:40:06,300
setup mmm so the user spit user space

748
00:40:03,150 --> 00:40:08,190
applications there are many of them so

749
00:40:06,300 --> 00:40:09,810
for example if you're familiar with the

750
00:40:08,190 --> 00:40:13,050
secure encrypted virtualization

751
00:40:09,810 --> 00:40:14,790
technology this technology uses the

752
00:40:13,050 --> 00:40:18,420
firmware and this firmware is a user

753
00:40:14,790 --> 00:40:22,020
space application on the PSP also we

754
00:40:18,420 --> 00:40:25,350
have applications which train DRM for

755
00:40:22,020 --> 00:40:28,380
example so in modern x86 system if you

756
00:40:25,350 --> 00:40:30,060
have ddr4 memory it has to be trained so

757
00:40:28,380 --> 00:40:32,130
you have to measure the timings of the

758
00:40:30,060 --> 00:40:35,520
specific DRM chips which are using and

759
00:40:32,130 --> 00:40:41,040
the application that does that is a user

760
00:40:35,520 --> 00:40:42,810
space application on the PSP um we had a

761
00:40:41,040 --> 00:40:44,940
look at some of the sis codes which are

762
00:40:42,810 --> 00:40:47,190
handled by the bootloader which is

763
00:40:44,940 --> 00:40:50,160
actually more an operating system than

764
00:40:47,190 --> 00:40:52,380
just the bootloader I would say um so we

765
00:40:50,160 --> 00:40:54,350
have cache maintenance so scrolls

766
00:40:52,380 --> 00:40:56,910
we have Cisco switch map an arbitrary

767
00:40:54,350 --> 00:40:58,170
x86 memory address into its own address

768
00:40:56,910 --> 00:41:01,940
space

769
00:40:58,170 --> 00:41:04,110
we have sis codes which provide the

770
00:41:01,940 --> 00:41:05,730
applications access to a crypto

771
00:41:04,110 --> 00:41:08,490
accelerator if they want to do some

772
00:41:05,730 --> 00:41:10,530
cryptographic operations we have random

773
00:41:08,490 --> 00:41:13,020
number and we have functions to read

774
00:41:10,530 --> 00:41:15,150
additional components from flash so also

775
00:41:13,020 --> 00:41:20,130
user space application can load

776
00:41:15,150 --> 00:41:21,980
additional components from flash so some

777
00:41:20,130 --> 00:41:28,140
words to the security of the whole thing

778
00:41:21,980 --> 00:41:29,310
a salar is a technique which randomizes

779
00:41:28,140 --> 00:41:31,109
the virtual memory layout of

780
00:41:29,310 --> 00:41:34,340
applications in order to make it harder

781
00:41:31,110 --> 00:41:38,100
to mount a buffer will flow for example

782
00:41:34,340 --> 00:41:39,810
and stack Canaries are like random

783
00:41:38,100 --> 00:41:42,810
values which are inserted the epilogue

784
00:41:39,810 --> 00:41:46,440
and prologue of a function to be able to

785
00:41:42,810 --> 00:41:48,150
detect the buffer overflow yeah of

786
00:41:46,440 --> 00:41:50,510
course we don't have any of those it's

787
00:41:48,150 --> 00:41:54,060
very simple no randomization at all and

788
00:41:50,510 --> 00:41:56,220
also what is interesting usually when

789
00:41:54,060 --> 00:41:59,400
you have an operating system in the user

790
00:41:56,220 --> 00:42:02,040
space application every syscall which

791
00:41:59,400 --> 00:42:03,810
gets a pointer the operating system has

792
00:42:02,040 --> 00:42:06,060
to be very careful about sanitizing

793
00:42:03,810 --> 00:42:09,690
these pointers so a new specification

794
00:42:06,060 --> 00:42:12,180
could provide and pointer to the

795
00:42:09,690 --> 00:42:14,610
operating itself operating system itself

796
00:42:12,180 --> 00:42:17,910
which then uses that pointer to write a

797
00:42:14,610 --> 00:42:20,160
value to write so you usually want to

798
00:42:17,910 --> 00:42:23,750
check whether your user space

799
00:42:20,160 --> 00:42:26,609
application that called the Cisco

800
00:42:23,750 --> 00:42:27,870
provides you with the right pointer so

801
00:42:26,610 --> 00:42:30,810
they don't do that here

802
00:42:27,870 --> 00:42:33,720
okay you could argue this is all kind of

803
00:42:30,810 --> 00:42:37,320
AMD code and it's signed and trusted and

804
00:42:33,720 --> 00:42:40,129
whatnot the thing is the applications

805
00:42:37,320 --> 00:42:43,050
are not only provided by AMD and aim

806
00:42:40,130 --> 00:42:45,870
signed with the AMD key they're also

807
00:42:43,050 --> 00:42:47,520
provided for example by UEFI vendors or

808
00:42:45,870 --> 00:42:52,710
mother bought vendors and signed with

809
00:42:47,520 --> 00:42:55,800
their key so I would say it's rather

810
00:42:52,710 --> 00:42:58,740
disappointing that there is no security

811
00:42:55,800 --> 00:43:01,260
check in the syscalls as there are

812
00:42:58,740 --> 00:43:06,450
probably vendors that aimed you should

813
00:43:01,260 --> 00:43:07,350
not trust too much alright coming to our

814
00:43:06,450 --> 00:43:11,910
conclusion

815
00:43:07,350 --> 00:43:13,710
so takeaways for you I hope

816
00:43:11,910 --> 00:43:15,899
we gave some insight to you how to

817
00:43:13,710 --> 00:43:17,789
approach such a problem at what you can

818
00:43:15,900 --> 00:43:19,799
do so the emulation part is something

819
00:43:17,789 --> 00:43:21,059
you hopefully can also do on your own

820
00:43:19,799 --> 00:43:24,059
now

821
00:43:21,059 --> 00:43:25,680
PSP to land PSP Trace is available for

822
00:43:24,059 --> 00:43:29,549
everyone so if you want to look at your

823
00:43:25,680 --> 00:43:32,419
BIOS images from these systems you can

824
00:43:29,549 --> 00:43:35,759
do that now quite easily and also this

825
00:43:32,420 --> 00:43:37,950
spi tracing using PSP tree is a very

826
00:43:35,760 --> 00:43:40,109
very helpful analysis method because it

827
00:43:37,950 --> 00:43:42,839
gives you the exact idea of which

828
00:43:40,109 --> 00:43:47,400
component is loaded when and if you are

829
00:43:42,839 --> 00:43:48,990
further interested in the secure

830
00:43:47,400 --> 00:43:52,049
encrypted virtualization technology and

831
00:43:48,990 --> 00:43:53,700
how the firmware or home security issues

832
00:43:52,049 --> 00:43:55,319
in the firmware could affect it there's

833
00:43:53,700 --> 00:44:00,598
a paper pending which is going to be

834
00:43:55,319 --> 00:44:03,390
published at CCS nineteen ok some thanks

835
00:44:00,599 --> 00:44:07,980
there is peter sugar who provided us

836
00:44:03,390 --> 00:44:11,670
with an flasher for spi flash that

837
00:44:07,980 --> 00:44:14,579
allows us to easily and fast flash the

838
00:44:11,670 --> 00:44:19,289
flash which is very helpful management

839
00:44:14,579 --> 00:44:21,750
who developed avatar 2 and the secti

840
00:44:19,289 --> 00:44:23,970
department and as all apps berlin for

841
00:44:21,750 --> 00:44:26,750
providing us with hardware that we can

842
00:44:23,970 --> 00:44:29,750
have a look at there are the links

843
00:44:26,750 --> 00:44:29,750
thanks

844
00:44:33,530 --> 00:44:39,119
all right pick applause for them great

845
00:44:36,540 --> 00:44:43,290
job great job and thank you for this

846
00:44:39,119 --> 00:44:45,960
very insightful talk yeah all right so

847
00:44:43,290 --> 00:44:49,980
we have some short time left for some

848
00:44:45,960 --> 00:44:52,319
Q&A who's interested in asking some

849
00:44:49,980 --> 00:44:55,740
questions ok so let me just come over to

850
00:44:52,319 --> 00:45:00,000
you so we get your question on the

851
00:44:55,740 --> 00:45:01,950
recording yeah thanks for the talk so

852
00:45:00,000 --> 00:45:03,780
it's the whole image signed as well or

853
00:45:01,950 --> 00:45:05,759
would I end up with a valid UEFI image

854
00:45:03,780 --> 00:45:07,559
of us just remove some applications

855
00:45:05,760 --> 00:45:09,599
let's say those who've been the ones I

856
00:45:07,559 --> 00:45:14,250
do not trust and hopefully aren't

857
00:45:09,599 --> 00:45:18,480
required to boot the system them so in

858
00:45:14,250 --> 00:45:21,630
general no it's not the it depends the

859
00:45:18,480 --> 00:45:25,079
the answer is it depends some BIOS

860
00:45:21,630 --> 00:45:27,869
vendors have an image over the whole

861
00:45:25,079 --> 00:45:29,970
UEFI image but this is actually only

862
00:45:27,869 --> 00:45:31,799
checked if you use for example their

863
00:45:29,970 --> 00:45:34,589
BIOS update utility

864
00:45:31,799 --> 00:45:37,950
so if you use an SPI programmer this

865
00:45:34,589 --> 00:45:39,869
won't stop you from actually removing

866
00:45:37,950 --> 00:45:42,990
for example one of those entries are

867
00:45:39,869 --> 00:45:44,790
also replaying entries for example from

868
00:45:42,990 --> 00:45:50,160
another UEFI image that are assigned

869
00:45:44,790 --> 00:45:52,079
with the same key my understanding is

870
00:45:50,160 --> 00:45:54,960
the initial reads of the flash the spy

871
00:45:52,079 --> 00:45:57,990
flash occur they have they're done by

872
00:45:54,960 --> 00:46:04,559
some kind of boot ROM were you able to

873
00:45:57,990 --> 00:46:07,890
access the boot ROM no so we didn't find

874
00:46:04,559 --> 00:46:10,380
any code regarding this inside the flash

875
00:46:07,890 --> 00:46:13,069
image but of course if it's in ROM it

876
00:46:10,380 --> 00:46:16,859
doesn't have to be in the in the flash

877
00:46:13,069 --> 00:46:19,109
we didn't I will poke through so maybe I

878
00:46:16,859 --> 00:46:23,220
can tell it like this so we actually

879
00:46:19,109 --> 00:46:25,380
have some ways to access the PSP's

880
00:46:23,220 --> 00:46:26,879
memory directly right now and we poked a

881
00:46:25,380 --> 00:46:30,390
bit in its memory around and we didn't

882
00:46:26,880 --> 00:46:33,450
find any code that could be something

883
00:46:30,390 --> 00:46:36,029
like an on-chip boot ROM but we suspect

884
00:46:33,450 --> 00:46:38,040
it has to be there but some part has to

885
00:46:36,030 --> 00:46:39,540
access the flash and load the second

886
00:46:38,040 --> 00:46:44,910
stage from the flash and verified its

887
00:46:39,540 --> 00:46:45,980
its integrity all right do we have any

888
00:46:44,910 --> 00:46:49,480
more questions yes

889
00:46:45,980 --> 00:46:49,480
over there one second

890
00:46:50,599 --> 00:46:54,710
hello things for the talk how did you

891
00:46:52,430 --> 00:46:59,270
manage to find out the meaning of those

892
00:46:54,710 --> 00:47:02,660
registers that are early on set like

893
00:46:59,270 --> 00:47:04,640
page table address this is defined in

894
00:47:02,660 --> 00:47:08,450
the arm reference we know it's an ARM

895
00:47:04,640 --> 00:47:10,578
Cortex CPU and the arm v7 manual

896
00:47:08,450 --> 00:47:12,560
specifically says which register is

897
00:47:10,579 --> 00:47:15,560
doing what so this isn't known and

898
00:47:12,560 --> 00:47:18,589
there's a very nice Ida plugin that

899
00:47:15,560 --> 00:47:21,980
actually makes comments on all those

900
00:47:18,589 --> 00:47:26,259
weird coprocessor instructions and tells

901
00:47:21,980 --> 00:47:30,050
you exactly what they do it's very handy

902
00:47:26,260 --> 00:47:33,109
so what there's some form of obligation

903
00:47:30,050 --> 00:47:40,520
on the client or on on the booth server

904
00:47:33,109 --> 00:47:46,210
on the runner-ups no it's all playing

905
00:47:40,520 --> 00:47:51,680
our code to be disassembled yes

906
00:47:46,210 --> 00:47:54,020
good to hear hey so you say you can pick

907
00:47:51,680 --> 00:47:55,930
and replace whatever user space programs

908
00:47:54,020 --> 00:47:57,770
other people are written for different

909
00:47:55,930 --> 00:47:59,899
motherboards different manufacturers

910
00:47:57,770 --> 00:48:01,220
have you started collecting all these

911
00:47:59,900 --> 00:48:03,230
from all the different boards have been

912
00:48:01,220 --> 00:48:04,848
made to kind of analyze and see if

913
00:48:03,230 --> 00:48:06,500
there's any interesting stuff there or

914
00:48:04,849 --> 00:48:09,859
do you have such an online collection

915
00:48:06,500 --> 00:48:13,609
somewhere we have a small collection of

916
00:48:09,859 --> 00:48:15,500
images locally and we try to distinguish

917
00:48:13,609 --> 00:48:19,009
the vendors whether there are some

918
00:48:15,500 --> 00:48:23,780
differences or not we don't have an

919
00:48:19,010 --> 00:48:27,410
online version of that the thing is if

920
00:48:23,780 --> 00:48:29,990
you look at epic you will see mostly the

921
00:48:27,410 --> 00:48:32,660
same now no differences between the

922
00:48:29,990 --> 00:48:34,970
different vendors of motherboards Rison

923
00:48:32,660 --> 00:48:38,149
I'm not too sure I can tell you that in

924
00:48:34,970 --> 00:48:40,129
general the Rison is much larger

925
00:48:38,150 --> 00:48:42,560
firmware with a lot more components than

926
00:48:40,130 --> 00:48:47,660
for epic but we have not looked into

927
00:48:42,560 --> 00:48:51,069
Rison that much actually all right any

928
00:48:47,660 --> 00:48:56,180
more questions from the audience

929
00:48:51,069 --> 00:48:58,279
ok looks good so thank you again thank

930
00:48:56,180 --> 00:48:59,649
you Robert Thank You Christian a big

931
00:48:58,280 --> 00:49:03,730
applause again

932
00:48:59,650 --> 00:49:06,920
[Applause]

933
00:49:03,730 --> 00:49:06,920
[Music]

934
00:49:12,200 --> 00:49:16,799
[Music]

935
00:49:17,990 --> 00:49:20,049
you

