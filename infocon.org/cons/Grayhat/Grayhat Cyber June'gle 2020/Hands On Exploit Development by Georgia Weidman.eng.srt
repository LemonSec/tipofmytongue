1
00:00:00,030 --> 00:00:02,129
the broadcast is now starting all

2
00:00:02,129 --> 00:00:04,490
attendees are in listen-only mode

3
00:00:04,490 --> 00:00:07,350
hey there everyone this is propaganda

4
00:00:07,350 --> 00:00:10,320
panda out aka Omar not the other Omar

5
00:00:10,320 --> 00:00:12,990
but the younger Omar and this is gonna

6
00:00:12,990 --> 00:00:15,450
be our first session of the jungle event

7
00:00:15,450 --> 00:00:17,490
for the training the red team training

8
00:00:17,490 --> 00:00:20,310
and I am very happy to announce that we

9
00:00:20,310 --> 00:00:22,890
have Georgia Weidman here who is

10
00:00:22,890 --> 00:00:26,369
currently working on version 2 of the

11
00:00:26,369 --> 00:00:29,789
red team so very excited to have her

12
00:00:29,789 --> 00:00:31,349
here thank you all for being here and

13
00:00:31,349 --> 00:00:32,940
please of course since this is kind of

14
00:00:32,940 --> 00:00:34,500
like our first time doing this we're

15
00:00:34,500 --> 00:00:35,460
still working through some technical

16
00:00:35,460 --> 00:00:38,160
difficulties so we do appreciate you all

17
00:00:38,160 --> 00:00:40,500
having some patience with us you know

18
00:00:40,500 --> 00:00:43,230
feel free to give us feedback as well we

19
00:00:43,230 --> 00:00:45,899
have the discord server here if you look

20
00:00:45,899 --> 00:00:47,910
at track 1 red team if you could put

21
00:00:47,910 --> 00:00:49,860
questions there if you need help with

22
00:00:49,860 --> 00:00:51,300
anything you know I'll be monitoring

23
00:00:51,300 --> 00:00:54,030
that along with Travis here and we'll be

24
00:00:54,030 --> 00:00:55,730
working through that with you all in

25
00:00:55,730 --> 00:00:58,440
Georgia if you don't mind let's go ahead

26
00:00:58,440 --> 00:01:00,750
and get this thing started all right

27
00:01:00,750 --> 00:01:05,069
thank you hey everybody its Georgia

28
00:01:05,069 --> 00:01:09,659
you know the notorious so actually the

29
00:01:09,659 --> 00:01:11,400
book that I'm working on version 2 of

30
00:01:11,400 --> 00:01:13,110
its penetration testing and hands-on

31
00:01:13,110 --> 00:01:15,990
introduction to hacking and in

32
00:01:15,990 --> 00:01:19,110
Portuguese it is testis the invasive oh

33
00:01:19,110 --> 00:01:20,970
you guys can't see me I'm like holding

34
00:01:20,970 --> 00:01:22,470
up the books and you can't even see me

35
00:01:22,470 --> 00:01:25,080
um probably for the best

36
00:01:25,080 --> 00:01:27,810
alright so we're gonna talk a little bit

37
00:01:27,810 --> 00:01:30,000
about exploit development today if you

38
00:01:30,000 --> 00:01:34,650
want to pass your osep from off SEC this

39
00:01:34,650 --> 00:01:37,850
is a really good great place to start

40
00:01:37,850 --> 00:01:41,310
but you know are you gonna come out of

41
00:01:41,310 --> 00:01:43,799
this being able to like bug bounty on

42
00:01:43,799 --> 00:01:47,520
the iPhone probably not you know it

43
00:01:47,520 --> 00:01:49,020
takes a little bit more than two hours

44
00:01:49,020 --> 00:01:51,869
but we're gonna start at the beginning

45
00:01:51,869 --> 00:01:53,640
and can work through some of this stuff

46
00:01:53,640 --> 00:01:55,350
I know it said it was brought to my

47
00:01:55,350 --> 00:01:58,140
attention that I copy and pasted um some

48
00:01:58,140 --> 00:02:00,719
stuff that said that I was gonna give

49
00:02:00,719 --> 00:02:02,729
you guys vm's and I will it will be

50
00:02:02,729 --> 00:02:06,509
emailed to you after the class blame it

51
00:02:06,509 --> 00:02:08,669
on the pandemic I and blame it on the

52
00:02:08,669 --> 00:02:10,770
fact that things are actually going very

53
00:02:10,770 --> 00:02:13,950
well in the version two of finitary

54
00:02:13,950 --> 00:02:16,500
interesting I get about ten messages a

55
00:02:16,500 --> 00:02:18,629
day asking me when version two is coming

56
00:02:18,629 --> 00:02:23,610
out and two that I cannot say but a real

57
00:02:23,610 --> 00:02:26,910
like I guess stopgap for it was and I've

58
00:02:26,910 --> 00:02:30,660
said this before but so I wanted to have

59
00:02:30,660 --> 00:02:33,870
an online lab because I get probably 20

60
00:02:33,870 --> 00:02:36,810
messages a day about setting up lab

61
00:02:36,810 --> 00:02:38,819
stuff and you know if you've done my

62
00:02:38,819 --> 00:02:42,900
book the lab did not age as well as I

63
00:02:42,900 --> 00:02:43,530
had hoped

64
00:02:43,530 --> 00:02:46,260
so my big thing was for version 2 I

65
00:02:46,260 --> 00:02:49,019
wanted it to be like all online and have

66
00:02:49,019 --> 00:02:52,349
like the ability to do like extra

67
00:02:52,349 --> 00:02:54,829
exercises afterwards and all that and

68
00:02:54,829 --> 00:02:57,630
after many failed attempts at getting

69
00:02:57,630 --> 00:02:59,670
that I finally like have the right

70
00:02:59,670 --> 00:03:02,040
partner for that so the stars have

71
00:03:02,040 --> 00:03:03,870
aligned and version 2 is coming

72
00:03:03,870 --> 00:03:07,700
imminently so tell your friends because

73
00:03:07,700 --> 00:03:10,590
that's your insight for being here is

74
00:03:10,590 --> 00:03:12,810
that all is well in the world and

75
00:03:12,810 --> 00:03:15,030
version 2 is going to come a lot faster

76
00:03:15,030 --> 00:03:18,359
than I previously expected alright so

77
00:03:18,359 --> 00:03:21,959
you know I recently did this class and a

78
00:03:21,959 --> 00:03:24,530
different class I'm doing it again on

79
00:03:24,530 --> 00:03:28,260
July 1st but it's on reverse engineering

80
00:03:28,260 --> 00:03:30,120
kind of the same sort of intro and they

81
00:03:30,120 --> 00:03:32,250
gave me all this feedback like shut up

82
00:03:32,250 --> 00:03:35,069
and just teach and you know whatever but

83
00:03:35,069 --> 00:03:37,799
that's difficult so bear with me there

84
00:03:37,799 --> 00:03:40,200
are going to be asides we're working on

85
00:03:40,200 --> 00:03:42,750
it making me like stay on track but it

86
00:03:42,750 --> 00:03:46,319
maybe I take some asides some people

87
00:03:46,319 --> 00:03:47,340
like it some people don't

88
00:03:47,340 --> 00:03:51,569
I don't that's just me I am what I am I

89
00:03:51,569 --> 00:03:54,269
supposed alright so it probably also

90
00:03:54,269 --> 00:03:56,250
said in the description that I was going

91
00:03:56,250 --> 00:03:57,959
to use updated vm's which was not

92
00:03:57,959 --> 00:04:00,840
because again as they say we're in

93
00:04:00,840 --> 00:04:03,359
pandemic mode I am way behind where I

94
00:04:03,359 --> 00:04:06,150
need to be in life but I'm keeping up to

95
00:04:06,150 --> 00:04:07,739
date on version 2 at the very least

96
00:04:07,739 --> 00:04:09,930
alright so you will get these themes um

97
00:04:09,930 --> 00:04:13,200
after class they'll send you an email my

98
00:04:13,200 --> 00:04:15,180
apologies on that I know some of you

99
00:04:15,180 --> 00:04:16,410
would probably like to work along with

100
00:04:16,410 --> 00:04:20,250
me um you know blame it on the

101
00:04:20,250 --> 00:04:23,010
weatherman I guess I screwed that one up

102
00:04:23,010 --> 00:04:25,560
ok so it's you know the usual

103
00:04:25,560 --> 00:04:27,720
you know Callie

104
00:04:27,720 --> 00:04:31,560
and which another insight that literally

105
00:04:31,560 --> 00:04:34,020
nobody knows is that I'm actually

106
00:04:34,020 --> 00:04:36,690
dumping Cali and parent and all of them

107
00:04:36,690 --> 00:04:41,100
for second book because they're it's the

108
00:04:41,100 --> 00:04:42,510
biggest problem because they keep taking

109
00:04:42,510 --> 00:04:44,730
down a tree pose so it's gotta be a

110
00:04:44,730 --> 00:04:47,090
custom like just a real kind of thing

111
00:04:47,090 --> 00:04:50,250
but there will be like it'll all be

112
00:04:50,250 --> 00:04:54,600
mentioned but I just don't want it to be

113
00:04:54,600 --> 00:04:57,650
like it was this time so I mean there's

114
00:04:57,650 --> 00:05:00,240
if you ever been to an airport people

115
00:05:00,240 --> 00:05:01,800
are like Oh Windows XP isn't still

116
00:05:01,800 --> 00:05:06,180
around but this is really just the same

117
00:05:06,180 --> 00:05:09,420
as everything else in terms of like

118
00:05:09,420 --> 00:05:12,570
exploit development and then Ubuntu

119
00:05:12,570 --> 00:05:14,760
Ubuntu is also old the fact that these

120
00:05:14,760 --> 00:05:16,830
beams are old like has nothing to do

121
00:05:16,830 --> 00:05:20,430
with to exploit development portion of

122
00:05:20,430 --> 00:05:22,500
it we're not actually attacking the

123
00:05:22,500 --> 00:05:26,640
operating system so yeah okay the for

124
00:05:26,640 --> 00:05:28,260
when you get these the password on both

125
00:05:28,260 --> 00:05:33,260
of these VMs is password yeah I know but

126
00:05:33,260 --> 00:05:36,270
don't do as I say not as I do don't you

127
00:05:36,270 --> 00:05:39,419
say what the password password and for

128
00:05:39,419 --> 00:05:42,690
Kali this is actually like a custom Kali

129
00:05:42,690 --> 00:05:45,930
that I made for the book but you can if

130
00:05:45,930 --> 00:05:47,730
you haven't updated Kali you can use

131
00:05:47,730 --> 00:05:50,430
that as well some of the tools probably

132
00:05:50,430 --> 00:05:53,460
will have changed because they do like

133
00:05:53,460 --> 00:05:55,770
Metasploit in particular seems to like

134
00:05:55,770 --> 00:05:58,380
never be satisfied with things like a

135
00:05:58,380 --> 00:06:00,350
must have been I'm having the right tag

136
00:06:00,350 --> 00:06:03,360
and you don't even have to use Kali like

137
00:06:03,360 --> 00:06:05,730
if you have like pen testers framework

138
00:06:05,730 --> 00:06:08,310
or anything like that or parrot or

139
00:06:08,310 --> 00:06:10,919
whatever all the other ones are cold it

140
00:06:10,919 --> 00:06:12,540
doesn't have to be Kali

141
00:06:12,540 --> 00:06:14,790
we don't actually even use it that much

142
00:06:14,790 --> 00:06:18,330
but anyway all right moving on I'm

143
00:06:18,330 --> 00:06:20,340
actually getting started all right so I

144
00:06:20,340 --> 00:06:22,710
even have slides I'm not entirely sure

145
00:06:22,710 --> 00:06:25,530
what was in my head with my like black

146
00:06:25,530 --> 00:06:28,350
with like bright yellow green writing

147
00:06:28,350 --> 00:06:36,270
but you know alright I don't use slides

148
00:06:36,270 --> 00:06:38,220
very much and you will not probably will

149
00:06:38,220 --> 00:06:40,260
not see slides very much in this class

150
00:06:40,260 --> 00:06:41,400
however

151
00:06:41,400 --> 00:06:45,810
slides can be made available to you the

152
00:06:45,810 --> 00:06:48,030
slides do walk through everything there

153
00:06:48,030 --> 00:06:50,160
are right ups as well office you know

154
00:06:50,160 --> 00:06:51,900
I'll just send it all to the organizers

155
00:06:51,900 --> 00:06:54,180
at the end and you know you guys can use

156
00:06:54,180 --> 00:06:56,009
what works best for you personally I

157
00:06:56,009 --> 00:06:57,120
don't like slides

158
00:06:57,120 --> 00:06:59,400
I like write-ups a lot better but some

159
00:06:59,400 --> 00:07:01,289
people like slides so we're gonna do a

160
00:07:01,289 --> 00:07:03,180
little bit of slides and a lot of

161
00:07:03,180 --> 00:07:08,910
hands-on so this is a really like basic

162
00:07:08,910 --> 00:07:12,030
and you know if you guys have a computer

163
00:07:12,030 --> 00:07:13,350
science degree or something you're

164
00:07:13,350 --> 00:07:14,970
probably like oh you're missing a lot of

165
00:07:14,970 --> 00:07:17,580
stuff and you're right but this is a

166
00:07:17,580 --> 00:07:20,910
really simplified version of a program

167
00:07:20,910 --> 00:07:23,370
in memory so we're we're gonna be

168
00:07:23,370 --> 00:07:25,949
focusing on today is this bit down here

169
00:07:25,949 --> 00:07:28,770
at the bottom on the stack and that's

170
00:07:28,770 --> 00:07:30,389
certainly not the only place you can

171
00:07:30,389 --> 00:07:32,639
have vulnerabilities I mean default

172
00:07:32,639 --> 00:07:34,310
passwords are vulnerability

173
00:07:34,310 --> 00:07:37,020
configuration issues there's heap you

174
00:07:37,020 --> 00:07:38,789
know you see the heap up here a little

175
00:07:38,789 --> 00:07:41,160
bit higher you know there's certainly

176
00:07:41,160 --> 00:07:43,770
you've heard he faced overflows I mean

177
00:07:43,770 --> 00:07:45,710
there are tons of different kinds but

178
00:07:45,710 --> 00:07:48,470
particularly if you want a paso SCP

179
00:07:48,470 --> 00:07:51,870
there's is a stack-based overflow and

180
00:07:51,870 --> 00:07:54,449
you know it's the best place to start I

181
00:07:54,449 --> 00:07:57,330
think so that's you know where we're

182
00:07:57,330 --> 00:07:58,979
gonna what we're gonna do today is focus

183
00:07:58,979 --> 00:08:01,949
on the stack you know the best outcome

184
00:08:01,949 --> 00:08:04,289
of this would be that you know one it

185
00:08:04,289 --> 00:08:08,370
gets you ready to do osep if you want to

186
00:08:08,370 --> 00:08:11,490
and to you know it is a jumping-off

187
00:08:11,490 --> 00:08:14,669
point to learn more I have found and

188
00:08:14,669 --> 00:08:17,370
again here I am being tangental I found

189
00:08:17,370 --> 00:08:18,990
like when I was starting out and

190
00:08:18,990 --> 00:08:22,680
security that there was and and

191
00:08:22,680 --> 00:08:24,180
certainly gotten better there's a lot

192
00:08:24,180 --> 00:08:26,760
more resources for beginners now but it

193
00:08:26,760 --> 00:08:29,099
was like there was so much knowledge

194
00:08:29,099 --> 00:08:31,919
assumed that you know once I got this

195
00:08:31,919 --> 00:08:34,020
basic stuff kind of in my head I was

196
00:08:34,020 --> 00:08:37,140
able to like understand a lot more but

197
00:08:37,140 --> 00:08:38,549
there really wasn't anything that like

198
00:08:38,549 --> 00:08:42,650
explained this sort of stuff um anyway

199
00:08:42,650 --> 00:08:45,450
tangents um so again we're gonna focus

200
00:08:45,450 --> 00:08:47,520
on the stack and what you might notice

201
00:08:47,520 --> 00:08:49,680
from this picture is the stack is like

202
00:08:49,680 --> 00:08:52,170
backwards and I would really like to go

203
00:08:52,170 --> 00:08:53,940
back in time and like be at that meeting

204
00:08:53,940 --> 00:08:55,290
when

205
00:08:55,290 --> 00:08:57,840
the founders of computers decided this

206
00:08:57,840 --> 00:09:00,060
was a good idea to have the heat grow

207
00:09:00,060 --> 00:09:01,890
one way and the stack or the other I

208
00:09:01,890 --> 00:09:03,300
would really like to be there but

209
00:09:03,300 --> 00:09:04,650
unfortunately I probably wasn't even

210
00:09:04,650 --> 00:09:07,260
born and probably nothing review must

211
00:09:07,260 --> 00:09:10,290
appear so anyway so you see the stack

212
00:09:10,290 --> 00:09:12,840
grows from we see high memory here at

213
00:09:12,840 --> 00:09:18,000
the bottom and low memory um and if you

214
00:09:18,000 --> 00:09:20,160
know memory is that thing that went like

215
00:09:20,160 --> 00:09:22,410
the beach ball on your Mac or like your

216
00:09:22,410 --> 00:09:24,720
windows freezes up it's probably because

217
00:09:24,720 --> 00:09:27,570
like it's a memory issue um you know

218
00:09:27,570 --> 00:09:29,400
it's where your computer like stores

219
00:09:29,400 --> 00:09:32,490
stuff which I realize is a silly

220
00:09:32,490 --> 00:09:35,610
definition but um you know they like

221
00:09:35,610 --> 00:09:38,910
deep details I mean pick up a Windows

222
00:09:38,910 --> 00:09:40,860
internals book if you really want to

223
00:09:40,860 --> 00:09:43,440
know but that's some hard reading anyway

224
00:09:43,440 --> 00:09:45,480
okay so high memory - low memory which

225
00:09:45,480 --> 00:09:48,900
is gonna come into play certainly it's

226
00:09:48,900 --> 00:09:50,670
just backwards doesn't remember it's

227
00:09:50,670 --> 00:09:53,220
backwards and it makes no sense why they

228
00:09:53,220 --> 00:09:56,490
did it this way I mean there's the text

229
00:09:56,490 --> 00:09:58,650
section it's like where the code is on

230
00:09:58,650 --> 00:10:01,080
but basically yeah we're gonna be

231
00:10:01,080 --> 00:10:05,010
focused on the stack um so this is x86

232
00:10:05,010 --> 00:10:07,670
which you might be like x86 come on now

233
00:10:07,670 --> 00:10:12,120
but uh there's actually still especially

234
00:10:12,120 --> 00:10:16,070
if you're working in like IOT space or

235
00:10:16,070 --> 00:10:20,550
some of the phones even still or 32 but

236
00:10:20,550 --> 00:10:24,210
again it's a good place to start

237
00:10:24,210 --> 00:10:26,190
things get more complicated as you go

238
00:10:26,190 --> 00:10:27,960
further some of you might be mobile

239
00:10:27,960 --> 00:10:30,390
people and you want to do arm arm is

240
00:10:30,390 --> 00:10:32,910
actually very similar to this it's just

241
00:10:32,910 --> 00:10:35,520
I mean I think it's more similar to this

242
00:10:35,520 --> 00:10:40,020
and it is just 64 bit oh um but you know

243
00:10:40,020 --> 00:10:41,130
things are gonna be a little bit

244
00:10:41,130 --> 00:10:42,930
different based on your architecture I

245
00:10:42,930 --> 00:10:47,310
mean this is Intel 32-bit 64-bit it's a

246
00:10:47,310 --> 00:10:49,560
little more complicated and arm is just

247
00:10:49,560 --> 00:10:52,110
a different set of registers basically

248
00:10:52,110 --> 00:10:53,280
what things are called

249
00:10:53,280 --> 00:10:56,070
and like where stuff happens to go will

250
00:10:56,070 --> 00:11:00,000
depend on your processor um but you know

251
00:11:00,000 --> 00:11:02,460
the general principles of we have

252
00:11:02,460 --> 00:11:05,580
registers at our CPU and they do things

253
00:11:05,580 --> 00:11:08,000
and stuff happens

254
00:11:08,000 --> 00:11:11,540
is universal so if you start out here

255
00:11:11,540 --> 00:11:13,610
it'll be I think a lot easier to pick up

256
00:11:13,610 --> 00:11:15,680
one of the other ones so general-purpose

257
00:11:15,680 --> 00:11:18,380
registers so registers are you know I

258
00:11:18,380 --> 00:11:20,660
said memory was a place to store stuff

259
00:11:20,660 --> 00:11:23,090
well registers are another place to

260
00:11:23,090 --> 00:11:25,430
store stuff remembering from my computer

261
00:11:25,430 --> 00:11:27,800
science degrees I think registers really

262
00:11:27,800 --> 00:11:29,570
the whole point is that it's faster like

263
00:11:29,570 --> 00:11:31,430
pulling stuff out of memory is like

264
00:11:31,430 --> 00:11:34,940
takes you know one gazillions of a

265
00:11:34,940 --> 00:11:36,650
second by pulling it from the registers

266
00:11:36,650 --> 00:11:38,780
which is actually on the CPU is he is

267
00:11:38,780 --> 00:11:41,210
faster which you know computers are so

268
00:11:41,210 --> 00:11:42,530
fast these days you probably wouldn't

269
00:11:42,530 --> 00:11:45,680
notice but I think that's what they said

270
00:11:45,680 --> 00:11:47,420
in computer science class but anyway

271
00:11:47,420 --> 00:11:49,430
just think of it as another place to

272
00:11:49,430 --> 00:11:53,570
store stuff um so for x86 and again this

273
00:11:53,570 --> 00:11:55,520
will change like an arm they're just

274
00:11:55,520 --> 00:12:00,530
like our one to a million in 64-bit the

275
00:12:00,530 --> 00:12:11,480
e turns into an r bit anyway but before

276
00:12:11,480 --> 00:12:14,060
there was 32-bit which again I'm

277
00:12:14,060 --> 00:12:16,880
probably talking like way before any of

278
00:12:16,880 --> 00:12:18,980
you guys were computing but there was

279
00:12:18,980 --> 00:12:21,350
16-bit and before there wasn't even a

280
00:12:21,350 --> 00:12:23,690
bit so actually all of these were just

281
00:12:23,690 --> 00:12:26,420
like instead of EBP it was BP and they

282
00:12:26,420 --> 00:12:29,500
just put the e on it to make it extended

283
00:12:29,500 --> 00:12:34,160
base pointer um so you know wait until

284
00:12:34,160 --> 00:12:36,830
we get like 64 times to all right so the

285
00:12:36,830 --> 00:12:38,510
ones we're really gonna focus on are

286
00:12:38,510 --> 00:12:40,970
actually just these top three these are

287
00:12:40,970 --> 00:12:44,300
gonna be our interesting ones for us but

288
00:12:44,300 --> 00:12:47,660
there are others as you see so anyway

289
00:12:47,660 --> 00:12:50,270
the most important one for us is AIP

290
00:12:50,270 --> 00:12:52,580
that is the instruction pointer that is

291
00:12:52,580 --> 00:12:55,640
going to hold the memory address the

292
00:12:55,640 --> 00:12:57,920
address in memory of the next

293
00:12:57,920 --> 00:13:02,120
instruction to be executed so taking

294
00:13:02,120 --> 00:13:04,160
that into account you might understand

295
00:13:04,160 --> 00:13:08,470
why control of a IP is our ultimate goal

296
00:13:08,470 --> 00:13:12,410
we want to get code execution we want to

297
00:13:12,410 --> 00:13:14,900
take over this machine and make it do

298
00:13:14,900 --> 00:13:18,770
stuff that we want it to do and being

299
00:13:18,770 --> 00:13:21,170
able to control yipeee ii sounds like a

300
00:13:21,170 --> 00:13:21,680
really

301
00:13:21,680 --> 00:13:23,570
great way to do that is that the only

302
00:13:23,570 --> 00:13:26,860
way to exploit things absolutely not but

303
00:13:26,860 --> 00:13:29,810
it's a good one so remember that's the

304
00:13:29,810 --> 00:13:32,620
memory address it's not actually like

305
00:13:32,620 --> 00:13:35,690
VIP isn't going to have like start calc

306
00:13:35,690 --> 00:13:38,149
yes you to start your calculator it's

307
00:13:38,149 --> 00:13:40,040
not gonna have the actual command it's

308
00:13:40,040 --> 00:13:43,250
going to have the memory address of the

309
00:13:43,250 --> 00:13:46,730
code so that will certainly come into

310
00:13:46,730 --> 00:13:48,470
play the other two that are really

311
00:13:48,470 --> 00:13:50,930
interesting to us since we are playing

312
00:13:50,930 --> 00:13:55,089
with the stack are ESP and EVP and

313
00:13:55,089 --> 00:13:58,700
that's basically the top ESP is the top

314
00:13:58,700 --> 00:14:01,610
and EBP is the bottom of the stack

315
00:14:01,610 --> 00:14:03,770
remember that the stack is upside down

316
00:14:03,770 --> 00:14:07,520
though so actually EBP is going to be at

317
00:14:07,520 --> 00:14:10,520
a higher memory address than ESP even

318
00:14:10,520 --> 00:14:12,560
though ESP is like the top and you think

319
00:14:12,560 --> 00:14:14,510
things would grow and get higher but no

320
00:14:14,510 --> 00:14:18,399
they get lower again there's other ones

321
00:14:18,399 --> 00:14:21,470
we will probably see some of them coming

322
00:14:21,470 --> 00:14:25,300
to play like places to jump to but

323
00:14:25,300 --> 00:14:28,490
really all you need to know is a IP ESP

324
00:14:28,490 --> 00:14:32,570
and EBP for now um again instruction

325
00:14:32,570 --> 00:14:34,220
pointer that's what we want to get

326
00:14:34,220 --> 00:14:37,130
control of SP and EBP are gonna be our

327
00:14:37,130 --> 00:14:40,070
boundaries for our stack and our stack

328
00:14:40,070 --> 00:14:41,600
is since we're doing a stack based

329
00:14:41,600 --> 00:14:45,110
overflow this is probably a good thing

330
00:14:45,110 --> 00:14:47,150
to look at what's going on in the stack

331
00:14:47,150 --> 00:14:50,120
so again you will get these slides and

332
00:14:50,120 --> 00:14:54,350
yeah all right this is also a problem

333
00:14:54,350 --> 00:14:56,750
that I have despite the fact that like I

334
00:14:56,750 --> 00:15:00,140
know these slides I will always tell you

335
00:15:00,140 --> 00:15:01,910
everything that's on the next slide

336
00:15:01,910 --> 00:15:05,839
before it happens but actually I guess I

337
00:15:05,839 --> 00:15:08,029
didn't really but usually I do but just

338
00:15:08,029 --> 00:15:10,100
watch out for that alright the stack it

339
00:15:10,100 --> 00:15:13,400
is first in last out so I like to think

340
00:15:13,400 --> 00:15:16,640
of that I guess because I'm weird that

341
00:15:16,640 --> 00:15:18,740
way it's like a stack of lunch trays

342
00:15:18,740 --> 00:15:21,110
which we don't have lunch trays anymore

343
00:15:21,110 --> 00:15:24,410
because pandemic stuffs but say we did

344
00:15:24,410 --> 00:15:27,140
all right so many of you probably

345
00:15:27,140 --> 00:15:29,360
remember lunch trays so you know the

346
00:15:29,360 --> 00:15:31,100
winds on one stacks up the lunch trays

347
00:15:31,100 --> 00:15:33,740
and you come to they're gonna put like

348
00:15:33,740 --> 00:15:35,510
the first one on and that

349
00:15:35,510 --> 00:15:37,130
be at the bottom they put more and more

350
00:15:37,130 --> 00:15:38,780
on but then when you come through and

351
00:15:38,780 --> 00:15:40,580
take one off you're not gonna get the

352
00:15:40,580 --> 00:15:43,070
one at the bottom that was the first one

353
00:15:43,070 --> 00:15:44,540
that was put on instead you're gonna

354
00:15:44,540 --> 00:15:47,870
take the one on the top so you know

355
00:15:47,870 --> 00:15:49,880
again if you have a computer science

356
00:15:49,880 --> 00:15:52,370
background like if you took computer

357
00:15:52,370 --> 00:15:54,110
science classes with all this theory and

358
00:15:54,110 --> 00:15:56,690
stuff you know this is oh yeah one of

359
00:15:56,690 --> 00:15:59,720
those because there's different stuff

360
00:15:59,720 --> 00:16:02,420
but yeah the stack first in last out so

361
00:16:02,420 --> 00:16:04,130
first thing that goes in is gonna be the

362
00:16:04,130 --> 00:16:04,970
last one

363
00:16:04,970 --> 00:16:06,770
same with lunch trays that's all I like

364
00:16:06,770 --> 00:16:09,500
to visualize it some of you may be

365
00:16:09,500 --> 00:16:11,630
beyond that and again we saw it's

366
00:16:11,630 --> 00:16:13,040
already a bit gross from high to low

367
00:16:13,040 --> 00:16:15,950
memory it seems upside down to

368
00:16:15,950 --> 00:16:19,340
instructions which this is not a coding

369
00:16:19,340 --> 00:16:23,690
intensive class because in addition to

370
00:16:23,690 --> 00:16:25,310
everything else you're also gonna get

371
00:16:25,310 --> 00:16:30,410
the exploit skeletons so you know a lot

372
00:16:30,410 --> 00:16:32,030
of classes it's like you have to learn

373
00:16:32,030 --> 00:16:34,670
how to write basic Python or C or

374
00:16:34,670 --> 00:16:36,620
whatever you know that's a completely

375
00:16:36,620 --> 00:16:39,170
different chapter for me I'm gonna give

376
00:16:39,170 --> 00:16:41,720
you guys on the exploit skeletons all

377
00:16:41,720 --> 00:16:45,050
you have to do is fill in the exploit

378
00:16:45,050 --> 00:16:47,780
you know being able to connect to a port

379
00:16:47,780 --> 00:16:50,560
in Python or Ruby or whatever you know

380
00:16:50,560 --> 00:16:53,150
do that if you want to but I'm gonna

381
00:16:53,150 --> 00:16:55,010
just make that available to you so you

382
00:16:55,010 --> 00:16:57,140
can just focus on the exploit so again

383
00:16:57,140 --> 00:16:59,120
not a coding intensive class you might

384
00:16:59,120 --> 00:17:01,220
see these push and pop instructions like

385
00:17:01,220 --> 00:17:03,230
oh god we're gonna have to do assembly

386
00:17:03,230 --> 00:17:06,220
and stuff but no these are actually the

387
00:17:06,220 --> 00:17:09,589
well not the only but most of the

388
00:17:09,589 --> 00:17:11,750
assembly instructions you will have to

389
00:17:11,750 --> 00:17:13,790
care about so don't worry if you don't

390
00:17:13,790 --> 00:17:15,949
have a reverse engineering and assembly

391
00:17:15,949 --> 00:17:18,380
background not an issue

392
00:17:18,380 --> 00:17:21,859
so just push instruction it puts data on

393
00:17:21,859 --> 00:17:23,810
the stack so you can think of push as

394
00:17:23,810 --> 00:17:25,849
somebody putting something on to the

395
00:17:25,849 --> 00:17:28,099
stack of lunch trays so they're

396
00:17:28,099 --> 00:17:30,140
refilling the lunch trays and they put

397
00:17:30,140 --> 00:17:32,210
one on they would use a push instruction

398
00:17:32,210 --> 00:17:35,000
and likewise we have the pop instruction

399
00:17:35,000 --> 00:17:36,770
and that's going to remove data from the

400
00:17:36,770 --> 00:17:38,810
stack and it's going to move it into one

401
00:17:38,810 --> 00:17:41,210
of those registers so you know it might

402
00:17:41,210 --> 00:17:44,120
put it in like yes I or yeah X Joule you

403
00:17:44,120 --> 00:17:47,750
know it goes where it wants so it'll

404
00:17:47,750 --> 00:17:48,809
push it or

405
00:17:48,809 --> 00:17:51,840
onto the stack pop it off the stack so

406
00:17:51,840 --> 00:17:53,879
you can think of a stocktronics crash

407
00:17:53,879 --> 00:17:54,659
face

408
00:17:54,659 --> 00:17:58,559
it's like root do what you need to do in

409
00:17:58,559 --> 00:17:59,820
the program like if you're doing

410
00:17:59,820 --> 00:18:02,190
calculations you know if you need to

411
00:18:02,190 --> 00:18:04,590
like save something like just a scratch

412
00:18:04,590 --> 00:18:07,019
space or something

413
00:18:07,019 --> 00:18:11,610
local variables go here um so yeah you

414
00:18:11,610 --> 00:18:13,139
can do whatever you want with the stack

415
00:18:13,139 --> 00:18:15,720
which is part of the problem but pushing

416
00:18:15,720 --> 00:18:17,159
a pop is really all you need to know

417
00:18:17,159 --> 00:18:19,309
putting things on and getting things off

418
00:18:19,309 --> 00:18:23,909
all right so here's like a stack frame

419
00:18:23,909 --> 00:18:26,820
so every function is going to have a

420
00:18:26,820 --> 00:18:29,279
stack frame and if you code anything

421
00:18:29,279 --> 00:18:31,889
like me be like well I just really just

422
00:18:31,889 --> 00:18:34,049
see Java for instance you know

423
00:18:34,049 --> 00:18:36,389
everything's an object I just like open

424
00:18:36,389 --> 00:18:38,340
an object and start scripting inside of

425
00:18:38,340 --> 00:18:41,190
it it's bad something about my brain

426
00:18:41,190 --> 00:18:43,169
just doesn't do object oriented

427
00:18:43,169 --> 00:18:45,840
programming naturally but even still

428
00:18:45,840 --> 00:18:47,940
like if you just write a program and it

429
00:18:47,940 --> 00:18:51,299
just has me and going back a couple main

430
00:18:51,299 --> 00:18:53,850
so if you guys have not done see more

431
00:18:53,850 --> 00:18:56,039
power to you stay very far away from C

432
00:18:56,039 --> 00:18:58,499
I'm just kidding because most things are

433
00:18:58,499 --> 00:19:00,629
still unfortunately written in C like

434
00:19:00,629 --> 00:19:03,690
the operating system levels so but

435
00:19:03,690 --> 00:19:07,049
anyway in C and some other programming

436
00:19:07,049 --> 00:19:10,289
languages like the first function that's

437
00:19:10,289 --> 00:19:12,570
called is always called main main

438
00:19:12,570 --> 00:19:13,980
function and then it calls other

439
00:19:13,980 --> 00:19:17,190
functions um so you know when the

440
00:19:17,190 --> 00:19:18,960
program starts mean will get a stack

441
00:19:18,960 --> 00:19:22,080
frame and even if you're like again like

442
00:19:22,080 --> 00:19:24,029
me and you don't use functions as much

443
00:19:24,029 --> 00:19:27,139
as you should they're still gonna be

444
00:19:27,139 --> 00:19:30,720
like stack frames for built-in functions

445
00:19:30,720 --> 00:19:33,899
like you know if you want printout text

446
00:19:33,899 --> 00:19:36,029
to the screen and see there's like 12

447
00:19:36,029 --> 00:19:37,679
different functions that do it

448
00:19:37,679 --> 00:19:42,029
stur copy is when we're gonna see that's

449
00:19:42,029 --> 00:19:44,850
copying data but there's a lot of that

450
00:19:44,850 --> 00:19:46,679
but you're not gonna write like the

451
00:19:46,679 --> 00:19:51,059
basic input/output of life yourself

452
00:19:51,059 --> 00:19:53,249
probably so you would call like a

453
00:19:53,249 --> 00:19:56,419
built-in function that C already has and

454
00:19:56,419 --> 00:19:58,830
then that would have its own stack frame

455
00:19:58,830 --> 00:20:02,220
so even if again even if you just open

456
00:20:02,220 --> 00:20:02,580
me

457
00:20:02,580 --> 00:20:04,560
to script stuff you're still gonna have

458
00:20:04,560 --> 00:20:07,560
other function calls in there notice ESP

459
00:20:07,560 --> 00:20:12,690
at the top at low memory and EBP kind of

460
00:20:12,690 --> 00:20:15,540
I probably write this in word but EBP

461
00:20:15,540 --> 00:20:17,190
like it's actually supposed to be right

462
00:20:17,190 --> 00:20:19,410
at the bottom and I'm not sure what it's

463
00:20:19,410 --> 00:20:22,890
not um and again high memory at the

464
00:20:22,890 --> 00:20:24,540
bottom some EBP is gonna have a high

465
00:20:24,540 --> 00:20:26,910
memory address and ESP is gonna have a

466
00:20:26,910 --> 00:20:29,220
low memory address our memory Dex's

467
00:20:29,220 --> 00:20:32,040
addresses are all like hexadecimal stuff

468
00:20:32,040 --> 00:20:34,530
but again I we're not gonna worry about

469
00:20:34,530 --> 00:20:36,330
all the theory we're gonna just make

470
00:20:36,330 --> 00:20:38,190
this work okay calling another function

471
00:20:38,190 --> 00:20:39,900
again this is gonna happen

472
00:20:39,900 --> 00:20:42,870
even if you just do one function you'll

473
00:20:42,870 --> 00:20:47,130
call built-in stuff so main will call

474
00:20:47,130 --> 00:20:49,110
another function so somewhere in the

475
00:20:49,110 --> 00:20:51,810
middle of main you know we call like

476
00:20:51,810 --> 00:20:55,770
another function of ours or a built-in

477
00:20:55,770 --> 00:20:58,860
function but when it finishes executing

478
00:20:58,860 --> 00:21:00,930
so we called something like prints out

479
00:21:00,930 --> 00:21:03,360
hi hello world or whatever should the

480
00:21:03,360 --> 00:21:06,090
screen but then it finishes executing it

481
00:21:06,090 --> 00:21:08,100
you don't want to start back in the

482
00:21:08,100 --> 00:21:09,600
calling function like at the beginning

483
00:21:09,600 --> 00:21:11,790
you don't want to do all that you want

484
00:21:11,790 --> 00:21:13,470
it to pick up right where it left off

485
00:21:13,470 --> 00:21:16,230
right so in order to pick up where we

486
00:21:16,230 --> 00:21:19,200
left off obviously we need to save where

487
00:21:19,200 --> 00:21:23,550
we were so we can get back there we

488
00:21:23,550 --> 00:21:25,110
don't want again we don't want to start

489
00:21:25,110 --> 00:21:26,790
at the beginning of May and we want to

490
00:21:26,790 --> 00:21:30,360
come back where we started so this is

491
00:21:30,360 --> 00:21:32,520
again this is gonna be a little

492
00:21:32,520 --> 00:21:36,020
different based on your platform um

493
00:21:36,020 --> 00:21:38,250
really I should just do everything in

494
00:21:38,250 --> 00:21:40,560
arm now because it's the way of the

495
00:21:40,560 --> 00:21:43,860
future but yeah these calling

496
00:21:43,860 --> 00:21:46,140
conventions may be a little different if

497
00:21:46,140 --> 00:21:49,110
you're looking at another platform but I

498
00:21:49,110 --> 00:21:52,170
mean they ultimately accomplish the same

499
00:21:52,170 --> 00:21:56,760
thing so the goal being being able to

500
00:21:56,760 --> 00:21:59,100
seamlessly go to another function and

501
00:21:59,100 --> 00:22:01,110
come back and pick up where we left off

502
00:22:01,110 --> 00:22:05,910
so for x86 what happens is before we

503
00:22:05,910 --> 00:22:09,300
hand over control to our called function

504
00:22:09,300 --> 00:22:12,270
it pushes its return address onto the

505
00:22:12,270 --> 00:22:12,870
stack

506
00:22:12,870 --> 00:22:16,010
so before it leaves off

507
00:22:16,010 --> 00:22:18,740
it just takes like where it needs to

508
00:22:18,740 --> 00:22:21,710
come back to it pushes it on the top of

509
00:22:21,710 --> 00:22:26,780
the stack and then it starts up the next

510
00:22:26,780 --> 00:22:31,610
function lift it just looks awful if

511
00:22:31,610 --> 00:22:33,230
that doesn't make any sense

512
00:22:33,230 --> 00:22:35,060
I'm you're probably not the only one it

513
00:22:35,060 --> 00:22:37,430
feels that way at this point my picture

514
00:22:37,430 --> 00:22:45,170
did not supposed to you know I'll fix it

515
00:22:45,170 --> 00:22:47,300
before I send it to you so we still have

516
00:22:47,300 --> 00:22:49,730
main stack frame you see most of it um

517
00:22:49,730 --> 00:22:52,640
so thethe main stack frame that return

518
00:22:52,640 --> 00:22:54,440
address the place that we want to pick

519
00:22:54,440 --> 00:22:57,620
up this is where execution will continue

520
00:22:57,620 --> 00:23:00,710
after our function finishes some of you

521
00:23:00,710 --> 00:23:02,600
might be thinking well if that's the

522
00:23:02,600 --> 00:23:05,050
address where things will continue

523
00:23:05,050 --> 00:23:07,820
executing getting control of that might

524
00:23:07,820 --> 00:23:10,880
be really cool and you are right and you

525
00:23:10,880 --> 00:23:12,440
are thinking absolutely in the right

526
00:23:12,440 --> 00:23:14,720
direction we want to think about ways

527
00:23:14,720 --> 00:23:16,820
that we can take control of this thing

528
00:23:16,820 --> 00:23:19,310
if it's just going to because it was

529
00:23:19,310 --> 00:23:23,870
told in its you know early days to take

530
00:23:23,870 --> 00:23:27,280
this return address and execute

531
00:23:27,280 --> 00:23:29,150
absolutely controlling that would be

532
00:23:29,150 --> 00:23:29,540
awesome

533
00:23:29,540 --> 00:23:34,670
um so EBP and ESP are now in function

534
00:23:34,670 --> 00:23:36,530
one stack frame I know you can't see the

535
00:23:36,530 --> 00:23:40,490
top ESPN EBP point to the bottom in the

536
00:23:40,490 --> 00:23:43,670
top of this currently executing function

537
00:23:43,670 --> 00:23:46,430
stack frame so when we're calling you

538
00:23:46,430 --> 00:23:49,490
know I call it function one here when

539
00:23:49,490 --> 00:23:53,270
function one is executing EBP in and ESP

540
00:23:53,270 --> 00:23:56,120
will be in that stack frame remember the

541
00:23:56,120 --> 00:23:58,370
stack grows to low memory so those will

542
00:23:58,370 --> 00:24:00,800
be at lower memory addresses but what's

543
00:24:00,800 --> 00:24:02,960
really really interesting to us is

544
00:24:02,960 --> 00:24:04,730
there's this a return address just

545
00:24:04,730 --> 00:24:08,600
sitting here and this is where I really

546
00:24:08,600 --> 00:24:10,520
wish I was there when they thought this

547
00:24:10,520 --> 00:24:12,050
would be a good idea because remember

548
00:24:12,050 --> 00:24:15,020
the stack frame grows up so we're

549
00:24:15,020 --> 00:24:17,450
growing up towards function one but if

550
00:24:17,450 --> 00:24:20,930
we copy data into it the data goes down

551
00:24:20,930 --> 00:24:23,960
and the stack but based over flows were

552
00:24:23,960 --> 00:24:26,210
born so I don't know they probably

553
00:24:26,210 --> 00:24:27,860
weren't thinking about security nobody

554
00:24:27,860 --> 00:24:29,260
was back then and

555
00:24:29,260 --> 00:24:30,730
occurred to anyone that this was gonna

556
00:24:30,730 --> 00:24:33,850
be what it is now all right a couple

557
00:24:33,850 --> 00:24:37,210
things um as I said we have to walk

558
00:24:37,210 --> 00:24:39,190
before we run there are a few things

559
00:24:39,190 --> 00:24:42,940
that I've actually turned off actually

560
00:24:42,940 --> 00:24:46,030
probably just one in this case um so you

561
00:24:46,030 --> 00:24:48,100
may have heard of address space layout

562
00:24:48,100 --> 00:24:51,070
randomization says we will study this

563
00:24:51,070 --> 00:24:53,380
later because our slides from today

564
00:24:53,380 --> 00:24:54,310
class

565
00:24:54,310 --> 00:24:57,880
silly me but there are certainly ways to

566
00:24:57,880 --> 00:24:59,560
bypass address space layout

567
00:24:59,560 --> 00:25:01,810
randomization sometimes it's easy

568
00:25:01,810 --> 00:25:03,970
sometimes you have to do like a memory

569
00:25:03,970 --> 00:25:06,760
leak but again we're gonna walk before

570
00:25:06,760 --> 00:25:09,310
we run and they don't do a a seller and

571
00:25:09,310 --> 00:25:12,610
the OS DP at least doesn't now and so

572
00:25:12,610 --> 00:25:14,680
what a SLR does is it randomizes

573
00:25:14,680 --> 00:25:18,150
locations in memory so if we want to

574
00:25:18,150 --> 00:25:20,830
return if we want to write an exploit

575
00:25:20,830 --> 00:25:22,570
when we want a hard code in like a

576
00:25:22,570 --> 00:25:24,520
memory address that we want to jump to

577
00:25:24,520 --> 00:25:28,030
um the first base layout randomization

578
00:25:28,030 --> 00:25:32,620
was basically created to stop that to

579
00:25:32,620 --> 00:25:37,000
make it difficult if not impossible to

580
00:25:37,000 --> 00:25:41,020
know um where things are going to be in

581
00:25:41,020 --> 00:25:43,600
memory so there's certainly a lot of

582
00:25:43,600 --> 00:25:48,040
other anti exploitation techniques you

583
00:25:48,040 --> 00:25:51,000
will run into in your continued studies

584
00:25:51,000 --> 00:25:54,730
but for now basically I'm just pointing

585
00:25:54,730 --> 00:25:56,860
out that I've turned address space

586
00:25:56,860 --> 00:26:00,040
layout randomization off on the machine

587
00:26:00,040 --> 00:26:04,810
we're going to use so it's off if you

588
00:26:04,810 --> 00:26:06,910
have your own like Ubuntu VM and you

589
00:26:06,910 --> 00:26:08,860
kind of do the same thing and and you're

590
00:26:08,860 --> 00:26:11,350
like why is this not working it's

591
00:26:11,350 --> 00:26:15,250
probably because SLR is on I would again

592
00:26:15,250 --> 00:26:17,140
encourage you to start like without all

593
00:26:17,140 --> 00:26:19,420
the stuff if you will the data execution

594
00:26:19,420 --> 00:26:22,600
prevention stack cookies also I mean

595
00:26:22,600 --> 00:26:24,220
there's tons of stuff since you know

596
00:26:24,220 --> 00:26:26,440
beginning a buffer overflows that people

597
00:26:26,440 --> 00:26:28,420
have put in place to try and stop this

598
00:26:28,420 --> 00:26:33,370
stuff but that said that's really up to

599
00:26:33,370 --> 00:26:36,970
the developer to use stuff you may find

600
00:26:36,970 --> 00:26:39,820
particularly again I keep harping on IOT

601
00:26:39,820 --> 00:26:43,070
like IOT and like inside like the

602
00:26:43,070 --> 00:26:46,850
embedded chips like people have done a

603
00:26:46,850 --> 00:26:49,940
lot of research on like attacking like

604
00:26:49,940 --> 00:26:51,350
the chips you know you see stuff like

605
00:26:51,350 --> 00:26:53,120
the Wi-Fi chip getting hit or the

606
00:26:53,120 --> 00:26:56,150
Bluetooth chip or the the mobile modem

607
00:26:56,150 --> 00:26:58,940
so you know it's great remote remote

608
00:26:58,940 --> 00:27:01,090
code execution because it's just

609
00:27:01,090 --> 00:27:03,800
broadcasting itself but a lot of that

610
00:27:03,800 --> 00:27:07,490
stuff doesn't have a lot of the latest

611
00:27:07,490 --> 00:27:10,160
and the greatest in terms of exploit

612
00:27:10,160 --> 00:27:12,050
mitigations so you might be surprised

613
00:27:12,050 --> 00:27:14,810
you might actually be able to find some

614
00:27:14,810 --> 00:27:16,850
instances especially now since

615
00:27:16,850 --> 00:27:19,640
everything is moving to IOT where a lot

616
00:27:19,640 --> 00:27:24,380
of this stuff doesn't exist anyway so

617
00:27:24,380 --> 00:27:27,740
yeah here's how to turn off a SLR yes I

618
00:27:27,740 --> 00:27:30,680
use nano I know that's a controversial

619
00:27:30,680 --> 00:27:33,080
thing to do but you tried teaching a

620
00:27:33,080 --> 00:27:36,080
class with VIH I dare you you make one

621
00:27:36,080 --> 00:27:39,470
mistake it just cascades nano is my

622
00:27:39,470 --> 00:27:44,170
go-to for when I have to do it calling

623
00:27:44,170 --> 00:27:47,990
um so yeah this is more for you this has

624
00:27:47,990 --> 00:27:50,330
already been done in the VM again if you

625
00:27:50,330 --> 00:27:52,160
want to do this like in your own VM and

626
00:27:52,160 --> 00:27:53,660
like why is it not working this is

627
00:27:53,660 --> 00:27:57,470
probably why all right so back to where

628
00:27:57,470 --> 00:27:59,960
we were so returning to means the

629
00:27:59,960 --> 00:28:02,690
function one finishes it calls it one

630
00:28:02,690 --> 00:28:06,410
needs to go back to main so basically a

631
00:28:06,410 --> 00:28:08,450
function stack frame is unwound so

632
00:28:08,450 --> 00:28:11,690
function one is done so it's gone its

633
00:28:11,690 --> 00:28:14,960
stack frame goes away ESP and EBP

634
00:28:14,960 --> 00:28:18,350
they're restored to main or the calling

635
00:28:18,350 --> 00:28:21,140
function and that save return address is

636
00:28:21,140 --> 00:28:25,790
loaded into EIP what was the IP the

637
00:28:25,790 --> 00:28:28,370
instruction pointer remember a IP is the

638
00:28:28,370 --> 00:28:30,020
memory address of the next instruction

639
00:28:30,020 --> 00:28:32,870
to be executed so that sounds right

640
00:28:32,870 --> 00:28:35,930
right our goal was to save the next

641
00:28:35,930 --> 00:28:38,750
instruction in main to be executed on to

642
00:28:38,750 --> 00:28:41,690
our stack and now when the function is

643
00:28:41,690 --> 00:28:44,120
finishing that saves return address from

644
00:28:44,120 --> 00:28:47,960
our stack is loaded into e IP so that

645
00:28:47,960 --> 00:28:50,630
sounds like I actually might know what

646
00:28:50,630 --> 00:28:52,190
I'm talking about because things work

647
00:28:52,190 --> 00:28:53,120
out the way they should

648
00:28:53,120 --> 00:28:55,910
so execution will continue where it left

649
00:28:55,910 --> 00:28:56,900
off it won't start

650
00:28:56,900 --> 00:28:58,970
getting a mane or anything like that

651
00:28:58,970 --> 00:29:01,360
it'll be like it never left and

652
00:29:01,360 --> 00:29:04,490
everything will be good but again you

653
00:29:04,490 --> 00:29:07,010
can maybe see why getting control of

654
00:29:07,010 --> 00:29:09,410
that same fraternity S which is then

655
00:29:09,410 --> 00:29:12,590
loaded into EIP might be a good thing to

656
00:29:12,590 --> 00:29:15,410
take control of because it's gonna go

657
00:29:15,410 --> 00:29:17,360
any IP and i said it's getting getting

658
00:29:17,360 --> 00:29:21,260
control of e IP that's kinda execution

659
00:29:21,260 --> 00:29:23,870
and we like that so definitely getting

660
00:29:23,870 --> 00:29:25,760
control of that save return address

661
00:29:25,760 --> 00:29:29,180
would be a good thing for us to do all

662
00:29:29,180 --> 00:29:29,860
right

663
00:29:29,860 --> 00:29:33,190
vulnerable code so this is on your

664
00:29:33,190 --> 00:29:35,780
punching machine which you probably

665
00:29:35,780 --> 00:29:37,730
don't have yet but it will be on the one

666
00:29:37,730 --> 00:29:39,350
that I give you so this is really really

667
00:29:39,350 --> 00:29:43,270
basic so sometimes you're going to have

668
00:29:43,270 --> 00:29:45,830
source code there's a fair amount of

669
00:29:45,830 --> 00:29:48,440
open source things so certainly you can

670
00:29:48,440 --> 00:29:50,480
one way to look for vulnerabilities if

671
00:29:50,480 --> 00:29:52,670
you have the source code available is to

672
00:29:52,670 --> 00:29:54,950
look at the source code this is a very

673
00:29:54,950 --> 00:29:57,920
basic program if you don't have the

674
00:29:57,920 --> 00:30:01,250
source code you'll you can you know just

675
00:30:01,250 --> 00:30:03,380
mess with it

676
00:30:03,380 --> 00:30:05,360
so try and like there's this thing

677
00:30:05,360 --> 00:30:07,280
called fuzzing that we won't get to

678
00:30:07,280 --> 00:30:12,130
today but basically sending bad input to

679
00:30:12,130 --> 00:30:15,530
programs or just as much input as you

680
00:30:15,530 --> 00:30:18,110
possibly can try different stuff to see

681
00:30:18,110 --> 00:30:21,320
what happens I'm only half joking when I

682
00:30:21,320 --> 00:30:23,840
say that the reason I've done well as a

683
00:30:23,840 --> 00:30:25,850
pen tester is because I can't follow

684
00:30:25,850 --> 00:30:29,810
directions because you know like if

685
00:30:29,810 --> 00:30:31,220
you're supposed to use a program a

686
00:30:31,220 --> 00:30:33,560
certain way and I do something else and

687
00:30:33,560 --> 00:30:35,960
the person who wrote it didn't think

688
00:30:35,960 --> 00:30:38,000
about the possibility that someone might

689
00:30:38,000 --> 00:30:40,340
do that the program will probably act in

690
00:30:40,340 --> 00:30:41,510
unexpected ways

691
00:30:41,510 --> 00:30:43,250
if any of you guys have a programming

692
00:30:43,250 --> 00:30:46,400
background you know if you don't do like

693
00:30:46,400 --> 00:30:49,160
your try-catch blocks and stuff like

694
00:30:49,160 --> 00:30:51,530
that and just stuff that doesn't work

695
00:30:51,530 --> 00:30:53,840
out the way it should

696
00:30:53,840 --> 00:30:57,200
weird stuff can happen and attackers

697
00:30:57,200 --> 00:31:01,550
like weird stuff to happen as we'll see

698
00:31:01,550 --> 00:31:05,120
so as a as a developer I realize this

699
00:31:05,120 --> 00:31:07,010
isn't a secure development class but as

700
00:31:07,010 --> 00:31:08,870
a developer I think if you're ever

701
00:31:08,870 --> 00:31:10,490
building anything thing

702
00:31:10,490 --> 00:31:13,370
with the attacker in mind like what is

703
00:31:13,370 --> 00:31:16,010
an attacker gonna do to mess with this

704
00:31:16,010 --> 00:31:17,690
and how can I stop it

705
00:31:17,690 --> 00:31:18,920
because I think a lot of people

706
00:31:18,920 --> 00:31:21,500
including myself at times they're really

707
00:31:21,500 --> 00:31:24,260
you know laser focused on like getting

708
00:31:24,260 --> 00:31:25,520
the program to work the way it should

709
00:31:25,520 --> 00:31:27,770
that you know we don't worry about like

710
00:31:27,770 --> 00:31:30,080
what if somebody likes sends a bunch of

711
00:31:30,080 --> 00:31:34,340
crap instead but anyway beside noting

712
00:31:34,340 --> 00:31:36,140
again all right so this is just a really

713
00:31:36,140 --> 00:31:38,510
basic C function well not function

714
00:31:38,510 --> 00:31:40,400
there's three functions in it C program

715
00:31:40,400 --> 00:31:44,360
and it's again I said you don't have to

716
00:31:44,360 --> 00:31:46,040
learn any programming and you don't

717
00:31:46,040 --> 00:31:48,380
because I'm just gonna walk through this

718
00:31:48,380 --> 00:31:52,070
real quickly so you see we've got so the

719
00:31:52,070 --> 00:31:53,870
include statements those are just C

720
00:31:53,870 --> 00:31:57,320
libraries so we have moved over if

721
00:31:57,320 --> 00:31:59,150
you're a Python person this is gonna

722
00:31:59,150 --> 00:32:01,430
make you scream because Python is like

723
00:32:01,430 --> 00:32:04,760
based on indention see it's not it's

724
00:32:04,760 --> 00:32:06,710
based on brackets you see the brackets

725
00:32:06,710 --> 00:32:08,600
so we open and close functions with

726
00:32:08,600 --> 00:32:12,650
brackets in C that's just how they

727
00:32:12,650 --> 00:32:14,240
decided to do it but you see we've got

728
00:32:14,240 --> 00:32:18,290
three functions one is overflowed one is

729
00:32:18,290 --> 00:32:21,470
function one and one is main as we said

730
00:32:21,470 --> 00:32:25,580
previously i main is where everything is

731
00:32:25,580 --> 00:32:27,650
going to start so despite the fact that

732
00:32:27,650 --> 00:32:29,300
it's on the bottom that's what's gonna

733
00:32:29,300 --> 00:32:30,590
get called first

734
00:32:30,590 --> 00:32:33,170
if we look at main at the bottom we see

735
00:32:33,170 --> 00:32:36,800
it's got weird stuff in parenthesis so

736
00:32:36,800 --> 00:32:38,240
that's where the arguments to a function

737
00:32:38,240 --> 00:32:40,460
go so if you need to pass something to a

738
00:32:40,460 --> 00:32:43,850
function um you put it in the arguments

739
00:32:43,850 --> 00:32:46,640
like if it was a function that said

740
00:32:46,640 --> 00:32:48,560
hello and then your name you know I

741
00:32:48,560 --> 00:32:50,660
think that's how at least in my day

742
00:32:50,660 --> 00:32:53,330
which makes me sound old that's what we

743
00:32:53,330 --> 00:32:54,740
started programming you would do like a

744
00:32:54,740 --> 00:32:56,870
program it said hello world and then you

745
00:32:56,870 --> 00:32:58,310
me do a program that says like hello

746
00:32:58,310 --> 00:32:58,850
Jordan

747
00:32:58,850 --> 00:33:01,220
hello John or whatever based on the

748
00:33:01,220 --> 00:33:03,350
input so like if it was something like

749
00:33:03,350 --> 00:33:06,050
that you would pass like the name to say

750
00:33:06,050 --> 00:33:09,290
hello to in the arguments but this one

751
00:33:09,290 --> 00:33:11,000
actually looks kind of weird it's like

752
00:33:11,000 --> 00:33:16,720
int argc char star RV and then like

753
00:33:18,250 --> 00:33:23,450
braces um but what that is that's just C

754
00:33:23,450 --> 00:33:24,380
jargons

755
00:33:24,380 --> 00:33:27,680
or command-line arguments input from the

756
00:33:27,680 --> 00:33:31,310
user input from the user is a great

757
00:33:31,310 --> 00:33:33,710
place for attackers input from the user

758
00:33:33,710 --> 00:33:36,260
is a terrible place for security people

759
00:33:36,260 --> 00:33:38,270
I mean you look at like you know I do

760
00:33:38,270 --> 00:33:40,040
some web application stuff you know web

761
00:33:40,040 --> 00:33:41,480
application is really big right now

762
00:33:41,480 --> 00:33:46,130
obviously but you know the whole problem

763
00:33:46,130 --> 00:33:49,670
with it is that users can input things

764
00:33:49,670 --> 00:33:52,700
if you just couldn't input things I feel

765
00:33:52,700 --> 00:33:54,740
like security would be a lot easier um

766
00:33:54,740 --> 00:33:58,220
but anything that you don't control that

767
00:33:58,220 --> 00:34:01,220
the user controls is potentially trouble

768
00:34:01,220 --> 00:34:03,290
because the user might either be

769
00:34:03,290 --> 00:34:06,710
incompetent or their an attacker which

770
00:34:06,710 --> 00:34:09,469
you might be surprised how often those

771
00:34:09,469 --> 00:34:12,110
are exactly the same like I said it's

772
00:34:12,110 --> 00:34:14,449
only half a jokes it you know I can't

773
00:34:14,449 --> 00:34:16,909
like pay attention to instructions so I

774
00:34:16,909 --> 00:34:19,219
end up crashing stuff it's like oh cool

775
00:34:19,219 --> 00:34:22,580
it's vulnerable all right so inside of

776
00:34:22,580 --> 00:34:25,480
main that takes command-line arguments

777
00:34:25,480 --> 00:34:28,310
the first thing we do is call a function

778
00:34:28,310 --> 00:34:31,310
one function ones up here and it takes

779
00:34:31,310 --> 00:34:32,330
as an argument

780
00:34:32,330 --> 00:34:35,629
argh v1 so that is going to be the first

781
00:34:35,629 --> 00:34:37,969
command-line argument given by the user

782
00:34:37,969 --> 00:34:40,280
so your first question might be what if

783
00:34:40,280 --> 00:34:42,590
the user doesn't even put in any input

784
00:34:42,590 --> 00:34:46,489
what's gonna happen then umm but though

785
00:34:46,489 --> 00:34:47,870
that's a good question that's not the

786
00:34:47,870 --> 00:34:50,000
one we're gonna focus on now we call

787
00:34:50,000 --> 00:34:54,590
function 1 and function 1 is up here so

788
00:34:54,590 --> 00:34:56,750
naturally the next instruction to be

789
00:34:56,750 --> 00:34:59,900
executed which is this printf thing that

790
00:34:59,900 --> 00:35:01,910
says executed normally this is gonna

791
00:35:01,910 --> 00:35:04,670
output to the screen executed normally

792
00:35:04,670 --> 00:35:09,110
um so what that's gonna do is save that

793
00:35:09,110 --> 00:35:12,350
the address of this or the assembly to

794
00:35:12,350 --> 00:35:14,810
go along with it on the stack just like

795
00:35:14,810 --> 00:35:16,850
we saw so it's gonna be you know right

796
00:35:16,850 --> 00:35:20,000
here return address and call function 1

797
00:35:20,000 --> 00:35:24,590
so so now we're up in function 1 it

798
00:35:24,590 --> 00:35:29,060
takes char star so strings and C are not

799
00:35:29,060 --> 00:35:34,460
friends so strings like Thor Georgia are

800
00:35:34,460 --> 00:35:38,260
actually character arrays so it's like

801
00:35:38,260 --> 00:35:41,680
g/e o-r-g

802
00:35:41,680 --> 00:35:46,870
a is like an array of characters so you

803
00:35:46,870 --> 00:35:49,060
know these complicated things that don't

804
00:35:49,060 --> 00:35:50,590
make a lot of sense until you really

805
00:35:50,590 --> 00:35:52,360
study them are great places to find

806
00:35:52,360 --> 00:35:54,520
vulnerabilities because probably most

807
00:35:54,520 --> 00:35:57,310
people are just as confused as you so

808
00:35:57,310 --> 00:35:59,350
yeah I consider that one of the big

809
00:35:59,350 --> 00:36:01,990
download you can't just do strings in C

810
00:36:01,990 --> 00:36:04,960
so it's taking a character array which

811
00:36:04,960 --> 00:36:07,650
is a string which is gonna be our

812
00:36:07,650 --> 00:36:11,230
argument so input from the user is now

813
00:36:11,230 --> 00:36:14,080
in function 1 so the user has some

814
00:36:14,080 --> 00:36:16,480
control still so there's a local

815
00:36:16,480 --> 00:36:20,710
variable char character call it buffer

816
00:36:20,710 --> 00:36:27,670
and it's 5 bytes long some of you may

817
00:36:27,670 --> 00:36:29,980
begin to see the problem how many

818
00:36:29,980 --> 00:36:34,030
letters are there in Georgia 8 right I

819
00:36:34,030 --> 00:36:37,230
should know this certainly more than 5

820
00:36:37,230 --> 00:36:40,840
so we have character array it's just a

821
00:36:40,840 --> 00:36:42,970
local variable remember local variables

822
00:36:42,970 --> 00:36:46,390
go on the stack so we are going to in

823
00:36:46,390 --> 00:36:50,680
the next line it does stir copy and it

824
00:36:50,680 --> 00:36:55,300
takes its destination source which is

825
00:36:55,300 --> 00:36:57,790
another silly things like why not source

826
00:36:57,790 --> 00:37:00,070
it in destination but that's just how

827
00:37:00,070 --> 00:37:03,880
they do it in the safe so we're copying

828
00:37:03,880 --> 00:37:07,300
STR which is our user input starts at

829
00:37:07,300 --> 00:37:09,490
arc v1 so that's our user input it's

830
00:37:09,490 --> 00:37:13,170
passed to function 1 as its argument

831
00:37:13,170 --> 00:37:18,660
character string and it is copied into

832
00:37:18,660 --> 00:37:22,270
buffer and this is just a built-in C

833
00:37:22,270 --> 00:37:24,630
function you don't see any code here for

834
00:37:24,630 --> 00:37:28,380
strcpy this is a built in c function and

835
00:37:28,380 --> 00:37:34,720
it's it gets a bad rap strcpy does

836
00:37:34,720 --> 00:37:37,240
exactly what it says it's gonna do it

837
00:37:37,240 --> 00:37:40,560
copies data from one place to another

838
00:37:40,560 --> 00:37:43,810
there's just it's not even a problem

839
00:37:43,810 --> 00:37:47,110
it's like if developers work the way

840
00:37:47,110 --> 00:37:49,410
they should it wouldn't be a problem um

841
00:37:49,410 --> 00:37:52,060
cuz naturally you might be thinking

842
00:37:52,060 --> 00:37:53,950
okay I kind of gave it away and I'm like

843
00:37:53,950 --> 00:37:55,720
my name is like eight characters and

844
00:37:55,720 --> 00:37:57,610
there's only five available what's gonna

845
00:37:57,610 --> 00:38:00,280
happen then is there some sort of like

846
00:38:00,280 --> 00:38:02,380
you don't see anything that's like a

847
00:38:02,380 --> 00:38:04,720
third argument that says only take the

848
00:38:04,720 --> 00:38:08,860
first five characters no strcpy is going

849
00:38:08,860 --> 00:38:11,650
to do exactly what you tell it to do

850
00:38:11,650 --> 00:38:14,170
it's going to take every character of

851
00:38:14,170 --> 00:38:16,390
our STR which is kind of short for

852
00:38:16,390 --> 00:38:18,970
string and copy it into buffer if it

853
00:38:18,970 --> 00:38:22,260
doesn't fit it's just gonna keep copying

854
00:38:22,260 --> 00:38:24,400
some of you are probably having a light

855
00:38:24,400 --> 00:38:27,670
bulb now oh very cool

856
00:38:27,670 --> 00:38:31,390
so but that's not to say you know if you

857
00:38:31,390 --> 00:38:34,230
ever work in code review and you see

858
00:38:34,230 --> 00:38:38,230
strcpy it's not like automatically wrong

859
00:38:38,230 --> 00:38:41,500
the developer could like put in a bounds

860
00:38:41,500 --> 00:38:44,020
check of their own make sure before they

861
00:38:44,020 --> 00:38:45,760
do the copy that things fit where they

862
00:38:45,760 --> 00:38:52,060
should but there's also strncpy and that

863
00:38:52,060 --> 00:38:54,970
does have a third argument for how many

864
00:38:54,970 --> 00:38:58,150
so with strcpy you have to do your own

865
00:38:58,150 --> 00:39:00,130
bounds checking if you don't want to do

866
00:39:00,130 --> 00:39:02,320
your own bounds checking then there's

867
00:39:02,320 --> 00:39:04,300
functions available that'll bounce check

868
00:39:04,300 --> 00:39:08,770
for you you know they weren't thinking

869
00:39:08,770 --> 00:39:12,630
security when they wrote this and so

870
00:39:12,630 --> 00:39:15,940
then that's the end of the function the

871
00:39:15,940 --> 00:39:17,710
function is over so we're gonna return

872
00:39:17,710 --> 00:39:19,690
to me and so all we've done is copied

873
00:39:19,690 --> 00:39:21,340
some stuff onto the stack

874
00:39:21,340 --> 00:39:25,270
not incredibly exciting this program and

875
00:39:25,270 --> 00:39:27,670
then it will so function one will end

876
00:39:27,670 --> 00:39:29,950
its stack frame will disappear as we

877
00:39:29,950 --> 00:39:32,050
said well it'll still be there ESP and

878
00:39:32,050 --> 00:39:36,340
EBP will return to main so yes P it's a

879
00:39:36,340 --> 00:39:40,810
top EBP at the bottom and then that

880
00:39:40,810 --> 00:39:42,460
return address that we saved on the

881
00:39:42,460 --> 00:39:45,700
stack will be loaded into EIP and we'll

882
00:39:45,700 --> 00:39:47,890
pick up where we left off with with main

883
00:39:47,890 --> 00:39:50,920
and it says executed normally so it will

884
00:39:50,920 --> 00:39:52,570
print out to the screen execute it

885
00:39:52,570 --> 00:39:55,420
normally if the incident did did indeed

886
00:39:55,420 --> 00:39:59,110
execute really but there's a third

887
00:39:59,110 --> 00:40:01,900
function as it is this third function is

888
00:40:01,900 --> 00:40:05,710
never called you can think of it

889
00:40:05,710 --> 00:40:07,420
kinda like debugging code I mean this

890
00:40:07,420 --> 00:40:09,730
happens people like leave debugging code

891
00:40:09,730 --> 00:40:15,460
in and it is compiled it is in memory

892
00:40:15,460 --> 00:40:18,070
somewhere even if it's never called you

893
00:40:18,070 --> 00:40:20,589
know it's there if we can get execution

894
00:40:20,589 --> 00:40:23,950
to go there it will execute so that's

895
00:40:23,950 --> 00:40:25,599
actually gonna be our goal for this

896
00:40:25,599 --> 00:40:28,630
first exercise which I'm hoping to get

897
00:40:28,630 --> 00:40:31,390
to in but I better like get on with it

898
00:40:31,390 --> 00:40:35,589
um want to show you a real program as

899
00:40:35,589 --> 00:40:37,990
well not this one that I wrote but we'll

900
00:40:37,990 --> 00:40:41,260
see how fast I can talk so our goal for

901
00:40:41,260 --> 00:40:43,330
this first exercise is actually going to

902
00:40:43,330 --> 00:40:46,000
be to get that function overflowed to

903
00:40:46,000 --> 00:40:48,520
execute overflowed is even simpler than

904
00:40:48,520 --> 00:40:51,520
the other two it says oh it does this

905
00:40:51,520 --> 00:40:53,950
print execution hijack to the screen so

906
00:40:53,950 --> 00:40:56,859
that's our goal because if the program

907
00:40:56,859 --> 00:40:59,080
runs normally overflowed is never called

908
00:40:59,080 --> 00:41:04,150
so our goal is to make execution

909
00:41:04,150 --> 00:41:07,599
hijacked run out to the screen so we

910
00:41:07,599 --> 00:41:09,760
know there's a vulnerability potentially

911
00:41:09,760 --> 00:41:13,839
here in function one this strcpy we only

912
00:41:13,839 --> 00:41:16,330
have five characters allotted to us on

913
00:41:16,330 --> 00:41:19,510
our stack but if we put more data in

914
00:41:19,510 --> 00:41:22,930
there something might happen our goal is

915
00:41:22,930 --> 00:41:25,270
to turn that something into code

916
00:41:25,270 --> 00:41:31,210
execution all right I told you I do this

917
00:41:31,210 --> 00:41:34,300
um so stir coffee does not do bounds

918
00:41:34,300 --> 00:41:40,680
checking then it will continue copying

919
00:41:41,099 --> 00:41:47,020
compiling a program GCC and you see I

920
00:41:47,020 --> 00:41:49,240
did this is another like turning off

921
00:41:49,240 --> 00:41:51,849
things I turned off the stack protector

922
00:41:51,849 --> 00:41:54,190
that's the stack cookie it's also called

923
00:41:54,190 --> 00:41:56,589
a stack canary again it's as we will

924
00:41:56,589 --> 00:42:00,190
discuss this later but just basics of it

925
00:42:00,190 --> 00:42:02,710
a stack Canaries kind of just stopped

926
00:42:02,710 --> 00:42:04,990
what we're doing like it basically just

927
00:42:04,990 --> 00:42:07,359
puts a magic number right above that

928
00:42:07,359 --> 00:42:10,000
return address that we stayed saved on

929
00:42:10,000 --> 00:42:12,250
the stack and then before it returns to

930
00:42:12,250 --> 00:42:14,410
main it checks to make sure that magic

931
00:42:14,410 --> 00:42:17,410
number is right so if we overflowed we

932
00:42:17,410 --> 00:42:18,580
would kill the magic number

933
00:42:18,580 --> 00:42:22,600
as well again by passing stacked cookies

934
00:42:22,600 --> 00:42:24,220
is another story for another day but

935
00:42:24,220 --> 00:42:27,300
again if you're doing this yourself and

936
00:42:27,300 --> 00:42:30,810
things seem weird it's probably because

937
00:42:30,810 --> 00:42:33,820
it has the stack protector on like if it

938
00:42:33,820 --> 00:42:35,680
puts out that it says like stack

939
00:42:35,680 --> 00:42:40,270
smashing detected execution halted it's

940
00:42:40,270 --> 00:42:43,450
probably the stack protector so that's

941
00:42:43,450 --> 00:42:45,670
that Alright running the program

942
00:42:45,670 --> 00:42:49,780
normally um so we just call overflow

943
00:42:49,780 --> 00:42:52,000
test that's what I called it the dash o

944
00:42:52,000 --> 00:42:54,520
is just naming it it don't call itself a

945
00:42:54,520 --> 00:42:57,490
dot out if you don't name it it's just

946
00:42:57,490 --> 00:43:01,870
fine so it will like if I give it for

947
00:43:01,870 --> 00:43:04,390
ease as my user input so four bytes each

948
00:43:04,390 --> 00:43:06,910
characters is one byte so we have five

949
00:43:06,910 --> 00:43:08,980
bytes putting four bytes in should be

950
00:43:08,980 --> 00:43:11,290
perfectly fine and it should execute

951
00:43:11,290 --> 00:43:13,270
normally well I should probably bring up

952
00:43:13,270 --> 00:43:17,020
the VM for this now um something was

953
00:43:17,020 --> 00:43:21,580
bouncing I hope it wasn't you guys um go

954
00:43:21,580 --> 00:43:26,040
to webinar control panel all right cool

955
00:43:26,040 --> 00:43:33,120
you don't see anything on here all right

956
00:43:33,120 --> 00:43:35,650
all right so I don't see any questions

957
00:43:35,650 --> 00:43:38,350
I'm just gonna continue um if I do see

958
00:43:38,350 --> 00:43:40,090
questions I'll do my best to answer them

959
00:43:40,090 --> 00:43:43,210
I'll give you my contact information at

960
00:43:43,210 --> 00:43:45,100
the end of class if you have any

961
00:43:45,100 --> 00:43:47,890
questions that you know or you know

962
00:43:47,890 --> 00:43:50,500
questions about anything really I will

963
00:43:50,500 --> 00:43:53,050
try to get to them all I think there's

964
00:43:53,050 --> 00:43:54,520
like a different place you guys are

965
00:43:54,520 --> 00:43:56,410
putting them that I'm not even in anyway

966
00:43:56,410 --> 00:44:00,490
alright alright so I have the PM's um

967
00:44:00,490 --> 00:44:04,740
again they're old not really matter um

968
00:44:04,740 --> 00:44:07,030
so again you'll get the PM's at the end

969
00:44:07,030 --> 00:44:09,340
of class I apologize for that alright so

970
00:44:09,340 --> 00:44:11,980
this is just my special little Ubuntu

971
00:44:11,980 --> 00:44:14,350
and we're gonna do something some of you

972
00:44:14,350 --> 00:44:16,120
guys may have not done before we're

973
00:44:16,120 --> 00:44:20,020
going to play with the terminal if you

974
00:44:20,020 --> 00:44:21,610
grew up on like windows before

975
00:44:21,610 --> 00:44:23,680
powershell you probably hate the

976
00:44:23,680 --> 00:44:27,490
terminal because like using the terminal

977
00:44:27,490 --> 00:44:29,470
before powershell and windows was just

978
00:44:29,470 --> 00:44:31,710
like pulling teeth

979
00:44:31,710 --> 00:44:34,170
our linux-based systems the terminal

980
00:44:34,170 --> 00:44:37,050
like is a lot better so if you're afraid

981
00:44:37,050 --> 00:44:39,720
of the terminal get a Linux machine

982
00:44:39,720 --> 00:44:43,230
because honestly you can do everything a

983
00:44:43,230 --> 00:44:47,310
lot better in the terminal in Linux so

984
00:44:47,310 --> 00:44:49,320
let me make this a little big right

985
00:44:49,320 --> 00:44:51,599
we're not on I always make things really

986
00:44:51,599 --> 00:44:53,339
big because it's on the projector but

987
00:44:53,339 --> 00:44:54,960
you guys actually see it on your screen

988
00:44:54,960 --> 00:44:56,160
never mind

989
00:44:56,160 --> 00:44:59,760
alright so again the password is

990
00:44:59,760 --> 00:45:04,530
password and you'll see we have overflow

991
00:45:04,530 --> 00:45:08,599
test C on here so you will have the code

992
00:45:08,599 --> 00:45:10,859
don't we just looked at in the slide

993
00:45:10,859 --> 00:45:14,099
same code exactly is right here set the

994
00:45:14,099 --> 00:45:18,810
formatting is better so that code will

995
00:45:18,810 --> 00:45:22,820
be available to you and I also have it

996
00:45:22,820 --> 00:45:25,800
already compiled as well so that bit

997
00:45:25,800 --> 00:45:29,040
with the GCC you don't have to do it so

998
00:45:29,040 --> 00:45:31,470
if we just run so thoughts lives that

999
00:45:31,470 --> 00:45:34,680
means like run it from this directory so

1000
00:45:34,680 --> 00:45:36,030
yeah

1001
00:45:36,030 --> 00:45:39,990
overflow chests and if we give it like

1002
00:45:39,990 --> 00:45:43,109
that sound like forays why forays

1003
00:45:43,109 --> 00:45:46,859
instead of five age Oh can't talk to me

1004
00:45:46,859 --> 00:45:50,130
so actually strings in C are terminated

1005
00:45:50,130 --> 00:45:53,060
with an old light so that's just 0 0

1006
00:45:53,060 --> 00:45:56,700
that's how strings know that or the

1007
00:45:56,700 --> 00:45:58,290
computer knows that the string is done

1008
00:45:58,290 --> 00:46:00,839
is that it's no Alterman ated certainly

1009
00:46:00,839 --> 00:46:03,150
strings not being null terminated you

1010
00:46:03,150 --> 00:46:04,950
may have seen stuff like this like you

1011
00:46:04,950 --> 00:46:06,420
put in your name and then it puts out

1012
00:46:06,420 --> 00:46:07,890
your name with like a bunch of junk

1013
00:46:07,890 --> 00:46:09,599
after it like question marks and stuff

1014
00:46:09,599 --> 00:46:11,849
on printable characters that's probably

1015
00:46:11,849 --> 00:46:14,700
because the developer didn't null

1016
00:46:14,700 --> 00:46:16,950
terminate the string so that's awesome

1017
00:46:16,950 --> 00:46:19,080
for memory leaks but you know another

1018
00:46:19,080 --> 00:46:20,160
story for another day

1019
00:46:20,160 --> 00:46:22,980
you guys would I'm sure get tired if we

1020
00:46:22,980 --> 00:46:25,260
did it that long so I'm actually putting

1021
00:46:25,260 --> 00:46:26,940
in for A's because we have five

1022
00:46:26,940 --> 00:46:28,859
characters and the fifth one is a null

1023
00:46:28,859 --> 00:46:31,470
byte so you actually have even less

1024
00:46:31,470 --> 00:46:33,240
space than you thought because you need

1025
00:46:33,240 --> 00:46:35,550
the last one for the null byte to

1026
00:46:35,550 --> 00:46:37,440
terminate the string so I'm actually

1027
00:46:37,440 --> 00:46:39,960
just giving it for A's and we expect to

1028
00:46:39,960 --> 00:46:42,810
see executed normally and that's exactly

1029
00:46:42,810 --> 00:46:45,519
what we see so

1030
00:46:45,519 --> 00:46:47,469
so far so good the program actually does

1031
00:46:47,469 --> 00:46:50,709
what I said it would do that's a good

1032
00:46:50,709 --> 00:46:51,459
start

1033
00:46:51,459 --> 00:46:57,369
so like all right so you know haven't

1034
00:46:57,369 --> 00:46:59,109
even made it a slide show but we'll be

1035
00:46:59,109 --> 00:47:00,999
here for like two seconds all right so

1036
00:47:00,999 --> 00:47:02,649
if we run over flow test and we just

1037
00:47:02,649 --> 00:47:04,149
give it like a ton of a's and these

1038
00:47:04,149 --> 00:47:06,399
don't have to be a z' at some point

1039
00:47:06,399 --> 00:47:08,649
people just decided it was going to be a

1040
00:47:08,649 --> 00:47:10,659
so we were gonna do an exploit

1041
00:47:10,659 --> 00:47:11,409
development

1042
00:47:11,409 --> 00:47:14,349
it could be B's it could be sees you

1043
00:47:14,349 --> 00:47:16,089
know as long as it's not like a special

1044
00:47:16,089 --> 00:47:17,829
character like you wouldn't want to put

1045
00:47:17,829 --> 00:47:19,419
in a nobody but you can't print that

1046
00:47:19,419 --> 00:47:22,419
anyway um but you know generally

1047
00:47:22,419 --> 00:47:24,369
speaking you're probably good and you're

1048
00:47:24,369 --> 00:47:29,469
like alphanumeric range but you know the

1049
00:47:29,469 --> 00:47:31,269
first person that like did a write-up of

1050
00:47:31,269 --> 00:47:33,099
exploit death I guess way back in the

1051
00:47:33,099 --> 00:47:37,409
day used a z' and so we still do um so

1052
00:47:37,409 --> 00:47:40,689
yeah what's gonna happen if we just give

1053
00:47:40,689 --> 00:47:42,640
it a lot of A's it's not going to print

1054
00:47:42,640 --> 00:47:44,589
out executed normally it's not gonna

1055
00:47:44,589 --> 00:47:46,509
print out execution hijack it's just

1056
00:47:46,509 --> 00:47:51,729
gonna crash crashing is I mean denial of

1057
00:47:51,729 --> 00:47:54,549
service is valid but code execution is

1058
00:47:54,549 --> 00:47:58,929
better so you know prove that I'm not

1059
00:47:58,929 --> 00:48:01,029
lying you know

1060
00:48:01,029 --> 00:48:02,769
and it doesn't matter really how many

1061
00:48:02,769 --> 00:48:04,929
A's at this point just like kill it

1062
00:48:04,929 --> 00:48:07,839
segmentation fault so it's like I can't

1063
00:48:07,839 --> 00:48:09,969
figure it out so let's see what actually

1064
00:48:09,969 --> 00:48:14,079
happened um so we're gonna we briefly

1065
00:48:14,079 --> 00:48:18,309
saw GCC the scan new compiler it comes

1066
00:48:18,309 --> 00:48:22,749
with gdb this is the new debugger so

1067
00:48:22,749 --> 00:48:25,149
again if any of you guys are programmers

1068
00:48:25,149 --> 00:48:26,799
you may have used debuggers before

1069
00:48:26,799 --> 00:48:29,019
debuggers are awesome for debugging your

1070
00:48:29,019 --> 00:48:30,939
stuff but they're also really awesome

1071
00:48:30,939 --> 00:48:35,289
for exploit developers or otherwise you

1072
00:48:35,289 --> 00:48:36,869
know people in the hacking business

1073
00:48:36,869 --> 00:48:39,399
because you can see what's going on in

1074
00:48:39,399 --> 00:48:43,209
like memory and things like that um so

1075
00:48:43,209 --> 00:48:47,789
basically what happened just make it big

1076
00:48:47,789 --> 00:48:51,819
all right so when STR cpy runs out of

1077
00:48:51,819 --> 00:48:54,219
room in our buffer variable which it

1078
00:48:54,219 --> 00:48:56,380
invariably will because we sent it tons

1079
00:48:56,380 --> 00:48:58,010
of stuff and only

1080
00:48:58,010 --> 00:49:00,770
five spaces it will just keep copying

1081
00:49:00,770 --> 00:49:03,230
data into the adjacent memory addresses

1082
00:49:03,230 --> 00:49:06,200
so it'll overwrite any additional space

1083
00:49:06,200 --> 00:49:08,840
in our stack frame for function and then

1084
00:49:08,840 --> 00:49:11,540
it will continue writing like it will

1085
00:49:11,540 --> 00:49:13,730
write literally to the end of the stack

1086
00:49:13,730 --> 00:49:16,550
if you give it enough information strcpy

1087
00:49:16,550 --> 00:49:19,640
will just do it again

1088
00:49:19,640 --> 00:49:22,010
not necessarily a bad function if you're

1089
00:49:22,010 --> 00:49:24,440
into writing bounds checking yourself it

1090
00:49:24,440 --> 00:49:26,720
can work perfectly fine but as it is

1091
00:49:26,720 --> 00:49:29,900
right here it's it's not good so it's

1092
00:49:29,900 --> 00:49:32,210
going to if we give it enough data

1093
00:49:32,210 --> 00:49:34,040
just keep overwriting everything on the

1094
00:49:34,040 --> 00:49:36,590
stack what's the interesting thing we

1095
00:49:36,590 --> 00:49:38,540
put on the stack that we said we wanted

1096
00:49:38,540 --> 00:49:41,510
to control that save return pointer for

1097
00:49:41,510 --> 00:49:44,960
main so if we basically what I am

1098
00:49:44,960 --> 00:49:47,240
alleging here at least is that if we

1099
00:49:47,240 --> 00:49:49,850
give it enough data we can overwrite

1100
00:49:49,850 --> 00:49:51,800
that safe return pointer I mean at this

1101
00:49:51,800 --> 00:49:53,780
point we're just giving it junk and it's

1102
00:49:53,780 --> 00:49:55,400
not gonna be able to figure out what to

1103
00:49:55,400 --> 00:49:57,890
do but you know we can give it other

1104
00:49:57,890 --> 00:50:02,300
stuff no all right oh this one looks

1105
00:50:02,300 --> 00:50:02,750
great

1106
00:50:02,750 --> 00:50:07,730
ha um so here's kind of a picture of

1107
00:50:07,730 --> 00:50:10,520
what would going on so there's a

1108
00:50:10,520 --> 00:50:13,430
variable buffer on that is a local

1109
00:50:13,430 --> 00:50:15,530
variable so it's in function one stack

1110
00:50:15,530 --> 00:50:18,530
frame and you know we put some A's in it

1111
00:50:18,530 --> 00:50:20,750
you know there's five spaces and then it

1112
00:50:20,750 --> 00:50:26,540
keeps writing A's it writes a cuz it's

1113
00:50:26,540 --> 00:50:29,930
32-bit the addresses are four bytes so

1114
00:50:29,930 --> 00:50:34,280
everything is four bytes a and then it

1115
00:50:34,280 --> 00:50:36,020
will even like I said it will write it

1116
00:50:36,020 --> 00:50:38,030
into main it will write to the very end

1117
00:50:38,030 --> 00:50:39,350
if you keep doing this you may see

1118
00:50:39,350 --> 00:50:42,770
issues where it actually will write to

1119
00:50:42,770 --> 00:50:44,450
the bottom of the stack frame and that's

1120
00:50:44,450 --> 00:50:49,460
what causes the exception so you know

1121
00:50:49,460 --> 00:50:53,090
check your bounds is the overarching I

1122
00:50:53,090 --> 00:50:55,070
guess thing if you don't want this to

1123
00:50:55,070 --> 00:50:58,910
happen to you so attaching to gdb you

1124
00:50:58,910 --> 00:51:02,480
really just say gdb and overflow test

1125
00:51:02,480 --> 00:51:07,310
tell it we want to use GB and debug our

1126
00:51:07,310 --> 00:51:09,800
overflow test program do not use

1127
00:51:09,800 --> 00:51:13,340
flutist see because that is just code we

1128
00:51:13,340 --> 00:51:18,460
want it to actually run the program and

1129
00:51:18,490 --> 00:51:21,759
let's do it

1130
00:51:22,010 --> 00:51:23,720
[Music]

1131
00:51:23,720 --> 00:51:28,130
gdb overflow test my typing Esther I

1132
00:51:28,130 --> 00:51:37,370
apologize alright so we get some like

1133
00:51:37,370 --> 00:51:39,800
you know this is the license and all

1134
00:51:39,800 --> 00:51:41,960
that stuff but then we get a gdb prompt

1135
00:51:41,960 --> 00:51:44,840
so we currently have the debugger hooked

1136
00:51:44,840 --> 00:51:48,650
up to overflow test so I said the

1137
00:51:48,650 --> 00:51:51,310
debugger was cool and indeed it is

1138
00:51:51,310 --> 00:51:53,990
probably the first thing that anybody

1139
00:51:53,990 --> 00:51:57,470
needs to know about it though I need

1140
00:51:57,470 --> 00:51:59,210
like two mortars and a switch back and

1141
00:51:59,210 --> 00:52:02,360
forth bunch of breakpoints there are a

1142
00:52:02,360 --> 00:52:04,160
lot of things you can do in the debugger

1143
00:52:04,160 --> 00:52:06,680
but like I said probably the most

1144
00:52:06,680 --> 00:52:08,600
important thing to know like starting

1145
00:52:08,600 --> 00:52:12,320
out is breakpoints so what breakpoints

1146
00:52:12,320 --> 00:52:14,900
do is they stop execution at a certain

1147
00:52:14,900 --> 00:52:16,640
point so you give it a memory address

1148
00:52:16,640 --> 00:52:18,650
name of the function anything like that

1149
00:52:18,650 --> 00:52:21,890
and it will stop if if we're running the

1150
00:52:21,890 --> 00:52:24,620
program and it hits that breakpoint in

1151
00:52:24,620 --> 00:52:28,130
all this pause completely freeze memory

1152
00:52:28,130 --> 00:52:30,020
will stay the way it is the registers

1153
00:52:30,020 --> 00:52:31,790
will stay the way they are everything

1154
00:52:31,790 --> 00:52:35,240
will just be stuck in that configuration

1155
00:52:35,240 --> 00:52:37,340
until we tell it to continue past the

1156
00:52:37,340 --> 00:52:40,730
breakpoint that's really interesting for

1157
00:52:40,730 --> 00:52:43,790
us because we kind of want to see if I'm

1158
00:52:43,790 --> 00:52:45,380
even telling the truth at this point

1159
00:52:45,380 --> 00:52:47,300
that it actually does what I say it's

1160
00:52:47,300 --> 00:52:49,900
gonna do but as you move on you can

1161
00:52:49,900 --> 00:52:52,070
certainly imagine that you might use it

1162
00:52:52,070 --> 00:52:54,500
as well so it allows us to examine the

1163
00:52:54,500 --> 00:52:56,150
state of our memory our registers

1164
00:52:56,150 --> 00:53:00,970
everything at that certain point so that

1165
00:53:00,970 --> 00:53:05,690
particularly should be cool so because

1166
00:53:05,690 --> 00:53:07,940
we actually have a source code because

1167
00:53:07,940 --> 00:53:09,560
it's on the same machine and it's just

1168
00:53:09,560 --> 00:53:11,810
like sitting there and it's you won't

1169
00:53:11,810 --> 00:53:14,180
always have the source code but again we

1170
00:53:14,180 --> 00:53:16,820
are walking before we're running so you

1171
00:53:16,820 --> 00:53:19,040
can actually list out the source code in

1172
00:53:19,040 --> 00:53:20,500
gdb

1173
00:53:20,500 --> 00:53:23,720
so you just again I don't know where

1174
00:53:23,720 --> 00:53:25,849
people come up with this is a syntax

1175
00:53:25,849 --> 00:53:28,460
we're gonna use but his list and then

1176
00:53:28,460 --> 00:53:29,810
you tell it where you want to start and

1177
00:53:29,810 --> 00:53:31,910
where you want to end so you want to

1178
00:53:31,910 --> 00:53:34,670
print out lines 1 to 16 in this case the

1179
00:53:34,670 --> 00:53:36,859
entire program and it will print that

1180
00:53:36,859 --> 00:53:38,930
out to the screen get this will not

1181
00:53:38,930 --> 00:53:42,080
always be available to you so we can

1182
00:53:42,080 --> 00:53:44,510
tell it to break it a line number you

1183
00:53:44,510 --> 00:53:46,369
can also tell it again at a memory

1184
00:53:46,369 --> 00:53:49,849
address you can break it it you know

1185
00:53:49,849 --> 00:53:53,540
look at the gdb man page if you want to

1186
00:53:53,540 --> 00:53:55,880
see like all the things it can do so we

1187
00:53:55,880 --> 00:53:57,349
can tell it a line number that we want

1188
00:53:57,349 --> 00:54:00,170
to break out since we have these so if

1189
00:54:00,170 --> 00:54:02,450
we wanted to break like right before the

1190
00:54:02,450 --> 00:54:04,670
strcpy I'm saying like this is our

1191
00:54:04,670 --> 00:54:07,940
problem function Msgr cpy probably

1192
00:54:07,940 --> 00:54:09,890
seeing like what's going on before and

1193
00:54:09,890 --> 00:54:12,260
after it is probably a good place to

1194
00:54:12,260 --> 00:54:14,270
start so we might want to tell it we

1195
00:54:14,270 --> 00:54:17,030
want to break at line 10 and line 11

1196
00:54:17,030 --> 00:54:20,510
right before strcpy so if we break on 10

1197
00:54:20,510 --> 00:54:24,230
it will stop before strcpy is called and

1198
00:54:24,230 --> 00:54:27,500
then if we break at 11 before right

1199
00:54:27,500 --> 00:54:30,619
before it returns then strcpy will have

1200
00:54:30,619 --> 00:54:32,300
happened and since that's supposed to be

1201
00:54:32,300 --> 00:54:34,520
a problem we should see scary stuff

1202
00:54:34,520 --> 00:54:38,540
happen so you just have to say break I

1203
00:54:38,540 --> 00:54:40,910
also have us breaking at line 14 if you

1204
00:54:40,910 --> 00:54:43,160
look at what line 14 is it's right

1205
00:54:43,160 --> 00:54:45,710
before the function call so that's just

1206
00:54:45,710 --> 00:54:48,710
gonna have us in main stack frame you

1207
00:54:48,710 --> 00:54:52,010
know just for you know our information

1208
00:54:52,010 --> 00:54:54,740
so okay and you just say break and then

1209
00:54:54,740 --> 00:54:56,330
the line number that you want

1210
00:54:56,330 --> 00:54:59,300
I have us breaking in main right before

1211
00:54:59,300 --> 00:55:01,130
the call of the function and I have us

1212
00:55:01,130 --> 00:55:03,380
breaking right before and right after

1213
00:55:03,380 --> 00:55:07,280
our vulnerable function that strcpy or

1214
00:55:07,280 --> 00:55:09,260
ster copy you know however you want to

1215
00:55:09,260 --> 00:55:16,250
say it um so we can do that there's a

1216
00:55:16,250 --> 00:55:22,580
break 14 well first let's actually do it

1217
00:55:22,580 --> 00:55:26,359
hope you guys aren't hearing that all

1218
00:55:26,359 --> 00:55:28,910
right so there's our source code and we

1219
00:55:28,910 --> 00:55:31,700
want to break right before the call to

1220
00:55:31,700 --> 00:55:37,170
function so we want to break it 14 great

1221
00:55:37,170 --> 00:55:40,470
I set the memory address for it then we

1222
00:55:40,470 --> 00:55:45,900
want to break at 10 and at 11 so right

1223
00:55:45,900 --> 00:55:50,490
before and right after the stare copy 19

1224
00:55:50,490 --> 00:55:57,359
really all right so we've got three

1225
00:55:57,359 --> 00:56:00,510
break points and they should all be hit

1226
00:56:00,510 --> 00:56:02,430
because we end up there if we set a

1227
00:56:02,430 --> 00:56:04,950
break point and overflowed it would

1228
00:56:04,950 --> 00:56:07,200
never get hit so it wouldn't matter but

1229
00:56:07,200 --> 00:56:09,210
so we should expect our program to stop

1230
00:56:09,210 --> 00:56:19,109
three times in normal execution all

1231
00:56:19,109 --> 00:56:21,089
right running the program in gdb you

1232
00:56:21,089 --> 00:56:23,280
just have to say run to run it and then

1233
00:56:23,280 --> 00:56:26,280
give it any arguments so again we can

1234
00:56:26,280 --> 00:56:28,319
just start with forays remember the

1235
00:56:28,319 --> 00:56:30,630
fifth bite is that null byte null

1236
00:56:30,630 --> 00:56:32,790
terminators are important memory leaks

1237
00:56:32,790 --> 00:56:34,049
are a big deal

1238
00:56:34,049 --> 00:56:36,420
so definitely always null terminate your

1239
00:56:36,420 --> 00:56:38,339
string so it doesn't just print out

1240
00:56:38,339 --> 00:56:44,940
things from memory not that you know I

1241
00:56:44,940 --> 00:56:46,950
try not to like put up any cramping

1242
00:56:46,950 --> 00:56:50,359
class but doesn't always work out

1243
00:56:50,359 --> 00:56:53,220
actually that was a PDF copy of my book

1244
00:56:53,220 --> 00:56:56,940
anyone all right so we want to run again

1245
00:56:56,940 --> 00:57:00,630
it doesn't have to be a z' um to run

1246
00:57:00,630 --> 00:57:03,119
with forays it hits the first breakpoint

1247
00:57:03,119 --> 00:57:06,780
so that is our first breakpoint um it's

1248
00:57:06,780 --> 00:57:08,309
gonna be in main because it's right

1249
00:57:08,309 --> 00:57:09,900
before they call the function so here we

1250
00:57:09,900 --> 00:57:14,099
are at line 14 so we are broken in main

1251
00:57:14,099 --> 00:57:20,059
function doesn't even exist yet um but

1252
00:57:20,059 --> 00:57:23,280
go down here and you can view your

1253
00:57:23,280 --> 00:57:26,910
registers and remember the registers a

1254
00:57:26,910 --> 00:57:31,890
IP ESPE vp e ax e si all those other

1255
00:57:31,890 --> 00:57:35,839
ones um even see more stuff than that

1256
00:57:35,839 --> 00:57:38,849
don't worry about the segments for now

1257
00:57:38,849 --> 00:57:40,799
these are just like the data segments

1258
00:57:40,799 --> 00:57:44,309
and stuff like that um but we want our

1259
00:57:44,309 --> 00:57:47,220
registers so you can view your registers

1260
00:57:47,220 --> 00:57:49,490
just like with info registers

1261
00:57:49,490 --> 00:57:50,730
additionally

1262
00:57:50,730 --> 00:57:53,040
you can view memory there are a lot of

1263
00:57:53,040 --> 00:57:55,079
ways to view memory this is another one

1264
00:57:55,079 --> 00:57:57,240
where it's like a whole chapter in the

1265
00:57:57,240 --> 00:58:00,900
book on GV I imagine but you can view

1266
00:58:00,900 --> 00:58:05,940
memory like the example here is we X's

1267
00:58:05,940 --> 00:58:09,660
examine so we want to examine 20 hex

1268
00:58:09,660 --> 00:58:16,680
words so 24 byte things from ESP

1269
00:58:16,680 --> 00:58:19,170
remember ESP is the top of our stack and

1270
00:58:19,170 --> 00:58:21,950
then we can like down here it's a

1271
00:58:21,950 --> 00:58:26,099
examine well one is the default one hex

1272
00:58:26,099 --> 00:58:28,740
word from EBP eBay fees the bottom of

1273
00:58:28,740 --> 00:58:31,950
our stack um it may not actually come

1274
00:58:31,950 --> 00:58:35,160
out the same as on the slide in terms of

1275
00:58:35,160 --> 00:58:36,810
the memory addresses because it might

1276
00:58:36,810 --> 00:58:40,710
move around let's see let's actually do

1277
00:58:40,710 --> 00:58:43,589
it alright so we are stuck here at main

1278
00:58:43,589 --> 00:58:48,480
we can do in two registers and you know

1279
00:58:48,480 --> 00:58:53,640
we see ESP top of our stack EVP bottom

1280
00:58:53,640 --> 00:58:55,440
of our stack I mean you can see it now

1281
00:58:55,440 --> 00:58:58,619
I realize these are in hex but you know

1282
00:58:58,619 --> 00:59:02,490
BF e 5 1 B those are the same but the

1283
00:59:02,490 --> 00:59:08,040
last byte 98 and 9000 BP 98 is higher

1284
00:59:08,040 --> 00:59:11,670
than 90 so you know as I said ESP is

1285
00:59:11,670 --> 00:59:13,109
gonna be the lower memory address

1286
00:59:13,109 --> 00:59:14,640
because the stack grows up to lower

1287
00:59:14,640 --> 00:59:18,060
memory so that kind of makes sense he's

1288
00:59:18,060 --> 00:59:21,300
actually doing what I say um so again x4

1289
00:59:21,300 --> 00:59:26,819
examined slash and then 20s probably too

1290
00:59:26,819 --> 00:59:32,849
much but 20 hex words from okay don't

1291
00:59:32,849 --> 00:59:36,630
kill the computer from ESP so it's gonna

1292
00:59:36,630 --> 00:59:39,270
start at yes huge and we saw was it b f

1293
00:59:39,270 --> 00:59:43,109
e5 1 b9 d sure enough it is so this just

1294
00:59:43,109 --> 00:59:45,810
left hand set with the the semicolons

1295
00:59:45,810 --> 00:59:49,589
that's the memory addresses i'm so yeah

1296
00:59:49,589 --> 00:59:53,579
so hex is base 16 i can hardly count

1297
00:59:53,579 --> 00:59:56,520
base 10 so bear with me all right so

1298
00:59:56,520 --> 00:59:57,750
this is gonna be the top of our stack

1299
00:59:57,750 --> 01:00:02,069
and then it said so we can do it here so

1300
01:00:02,069 --> 01:00:04,500
if we examine just one

1301
01:00:04,500 --> 01:00:12,180
next word from EVP the last fight is

1302
01:00:12,180 --> 01:00:14,640
nine eight which is our registers that's

1303
01:00:14,640 --> 01:00:16,200
what it says it should be it's not

1304
01:00:16,200 --> 01:00:18,660
entirely surprising all right so it's

1305
01:00:18,660 --> 01:00:21,000
the data in there which data can just be

1306
01:00:21,000 --> 01:00:25,500
junk or it can be useful um a b fe v 1c

1307
01:00:25,500 --> 01:00:31,740
0 8 right here so this highlighted bit

1308
01:00:31,740 --> 01:00:38,190
is actually main slate top highlighted

1309
01:00:38,190 --> 01:00:40,530
bit here that's actually on main stack

1310
01:00:40,530 --> 01:00:42,540
frame it's quite small but main doesn't

1311
01:00:42,540 --> 01:00:44,730
really do anything it just calls another

1312
01:00:44,730 --> 01:00:46,710
function and then prints out stuff to

1313
01:00:46,710 --> 01:00:51,570
the screen so actually yeah not entirely

1314
01:00:51,570 --> 01:00:53,550
surprising that it's small because it's

1315
01:00:53,550 --> 01:00:56,760
just for scratch space but you know it

1316
01:00:56,760 --> 01:00:59,100
all does what it says it's gonna do we

1317
01:00:59,100 --> 01:01:01,530
have a little place for it but things

1318
01:01:01,530 --> 01:01:03,210
are gonna start to get more interesting

1319
01:01:03,210 --> 01:01:07,740
when we actually keep going so to pass a

1320
01:01:07,740 --> 01:01:10,410
breakpoint you just say continue and

1321
01:01:10,410 --> 01:01:12,900
then it will run until it hits the next

1322
01:01:12,900 --> 01:01:14,580
breakpoint remember the next breakpoint

1323
01:01:14,580 --> 01:01:18,200
is at line 10 right before the call to

1324
01:01:18,200 --> 01:01:21,870
strcpy so we should expect we are now in

1325
01:01:21,870 --> 01:01:23,850
function stack frame and we should

1326
01:01:23,850 --> 01:01:26,990
expect to see the return address of main

1327
01:01:26,990 --> 01:01:30,780
pushed onto the stack and again that's

1328
01:01:30,780 --> 01:01:34,110
our what we want but that we shouldn't

1329
01:01:34,110 --> 01:01:36,600
see any age well there may be some but

1330
01:01:36,600 --> 01:01:38,910
we should not see like forays next to

1331
01:01:38,910 --> 01:01:41,280
each other in memory yet because the

1332
01:01:41,280 --> 01:01:44,910
strcpy hasn't happened well in function

1333
01:01:44,910 --> 01:01:48,930
stack frame anyway so then we can you

1334
01:01:48,930 --> 01:01:50,730
can hit the up arrow which I love

1335
01:01:50,730 --> 01:01:52,800
because yeah I'm not the best type

1336
01:01:52,800 --> 01:01:53,600
erever

1337
01:01:53,600 --> 01:01:57,090
so you know before main stack frame was

1338
01:01:57,090 --> 01:02:00,060
here right it's last byte was 90 so this

1339
01:02:00,060 --> 01:02:03,960
was main stack frame but now ESP is up

1340
01:02:03,960 --> 01:02:08,700
here where the last byte is 70 so and

1341
01:02:08,700 --> 01:02:15,180
then we can do EVP as well and

1342
01:02:15,180 --> 01:02:23,660
at last byte is 8 8 so that would be

1343
01:02:23,660 --> 01:02:30,660
function stack frame at the top we don't

1344
01:02:30,660 --> 01:02:35,309
see any A's at all but yeah more on that

1345
01:02:35,309 --> 01:02:37,619
later and then so that's function stack

1346
01:02:37,619 --> 01:02:42,890
frame and this is main stack frame

1347
01:02:42,890 --> 01:02:46,140
anybody have any ideas what this 4 bytes

1348
01:02:46,140 --> 01:02:49,099
here between the two remember this is

1349
01:02:49,099 --> 01:02:54,839
function stack frame main stack frame 4

1350
01:02:54,839 --> 01:02:59,300
bytes in between so if we go back and

1351
01:02:59,300 --> 01:03:01,880
you know look at our pictures and

1352
01:03:01,880 --> 01:03:10,980
probably figure out what it is so if we

1353
01:03:10,980 --> 01:03:14,849
go few back here like for this one this

1354
01:03:14,849 --> 01:03:18,030
is after you know overflowing it but you

1355
01:03:18,030 --> 01:03:20,280
see what function stack frame main stack

1356
01:03:20,280 --> 01:03:22,079
frame and right between the two you have

1357
01:03:22,079 --> 01:03:25,170
the return address addresses are 4 bytes

1358
01:03:25,170 --> 01:03:29,400
in in 32-bit so it makes sense that it's

1359
01:03:29,400 --> 01:03:31,470
4 bytes it's a memory address it's

1360
01:03:31,470 --> 01:03:34,290
probably the memory address of the next

1361
01:03:34,290 --> 01:03:38,369
instruction to be executed in main based

1362
01:03:38,369 --> 01:03:40,440
on you know what I've said assuming we

1363
01:03:40,440 --> 01:03:44,250
believe anything I say yeah this is all

1364
01:03:44,250 --> 01:03:48,599
just you know it's just again exactly

1365
01:03:48,599 --> 01:03:50,819
what we're doing I'm trying to use more

1366
01:03:50,819 --> 01:03:53,930
slides but again you'll get it all

1367
01:03:53,930 --> 01:04:00,690
anyway so this is or should be the

1368
01:04:00,690 --> 01:04:06,020
return address me now we can either

1369
01:04:06,020 --> 01:04:08,970
believe it or probably better since

1370
01:04:08,970 --> 01:04:10,890
we're just learning we can verify that

1371
01:04:10,890 --> 01:04:13,200
so I said you didn't have to know any

1372
01:04:13,200 --> 01:04:18,119
disassembly and I meant it so but you

1373
01:04:18,119 --> 01:04:22,710
can disassemble in gdb and look at the

1374
01:04:22,710 --> 01:04:24,420
assembly code so even if you don't have

1375
01:04:24,420 --> 01:04:26,160
the source code you can always get the

1376
01:04:26,160 --> 01:04:27,720
assembly code

1377
01:04:27,720 --> 01:04:30,780
I know assembly is kind of scary at the

1378
01:04:30,780 --> 01:04:33,150
beginning but you know in general is you

1379
01:04:33,150 --> 01:04:38,069
know we have Google so you know honestly

1380
01:04:38,069 --> 01:04:40,349
I if I forget something I was like what

1381
01:04:40,349 --> 01:04:42,630
does this mean and Google tells me so

1382
01:04:42,630 --> 01:04:48,260
yeah okay so just a simple Maine and

1383
01:04:48,260 --> 01:04:52,819
yeah it looks like assembly instructions

1384
01:04:52,819 --> 01:04:55,170
but you know we see a couple we already

1385
01:04:55,170 --> 01:04:57,180
know like we know push that pushes

1386
01:04:57,180 --> 01:04:58,670
something onto the stack

1387
01:04:58,670 --> 01:05:01,859
MOV that's move so move one thing to

1388
01:05:01,859 --> 01:05:07,619
another add pop you know sub I mean most

1389
01:05:07,619 --> 01:05:09,329
of this doesn't actually look that scary

1390
01:05:09,329 --> 01:05:11,700
but anyway I said you didn't have to

1391
01:05:11,700 --> 01:05:14,460
know it and you don't because it's

1392
01:05:14,460 --> 01:05:15,900
really obvious to see where we are

1393
01:05:15,900 --> 01:05:18,500
because there's a call to function and

1394
01:05:18,500 --> 01:05:21,480
obviously that was the last instruction

1395
01:05:21,480 --> 01:05:23,579
that was executed in Maine it called

1396
01:05:23,579 --> 01:05:25,859
function so we should expect it's a

1397
01:05:25,859 --> 01:05:28,440
return address to be the next address so

1398
01:05:28,440 --> 01:05:29,970
it should be zero eight zero four eight

1399
01:05:29,970 --> 01:05:38,250
four four three and if we look back here

1400
01:05:38,250 --> 01:05:42,180
remember this was function once or it's

1401
01:05:42,180 --> 01:05:43,829
a function of function one the function

1402
01:05:43,829 --> 01:05:47,670
stack frame is here main stack frame is

1403
01:05:47,670 --> 01:05:50,579
here so this we said is the return

1404
01:05:50,579 --> 01:05:52,470
address of main zero zero four eight

1405
01:05:52,470 --> 01:05:54,690
four four three it's exactly what we

1406
01:05:54,690 --> 01:05:56,490
would expect it to be the next thing to

1407
01:05:56,490 --> 01:05:59,700
be executed in Maine how awesome that a

1408
01:05:59,700 --> 01:06:01,920
computer actually does what its ban

1409
01:06:01,920 --> 01:06:06,900
pages say it will so cool now let's do

1410
01:06:06,900 --> 01:06:09,990
our next breakpoint remember this will

1411
01:06:09,990 --> 01:06:13,290
be right after our strcpy so we only

1412
01:06:13,290 --> 01:06:15,060
gave it for age so we don't expect it to

1413
01:06:15,060 --> 01:06:17,280
crash here everything should be fine but

1414
01:06:17,280 --> 01:06:20,250
we should expect to see our 4a is being

1415
01:06:20,250 --> 01:06:24,450
copied into our memory we continue in

1416
01:06:24,450 --> 01:06:27,089
our third breakpoint we should expect to

1417
01:06:27,089 --> 01:06:33,720
see some age nobody seen any ease look

1418
01:06:33,720 --> 01:06:37,500
kind of weird in it well you won't

1419
01:06:37,500 --> 01:06:38,030
actually

1420
01:06:38,030 --> 01:06:43,790
see an a because um you actually are

1421
01:06:43,790 --> 01:06:46,280
looking at it you're thinking ASCII not

1422
01:06:46,280 --> 01:06:50,690
hex so the hexadecimal representation of

1423
01:06:50,690 --> 01:06:54,050
an uppercase a is a 41 so it's you can

1424
01:06:54,050 --> 01:06:59,810
look at like ASCII table comm that has

1425
01:06:59,810 --> 01:07:02,180
like the complete set of what's what

1426
01:07:02,180 --> 01:07:06,380
you know big a is 41 big B is 42 big C

1427
01:07:06,380 --> 01:07:10,520
is 43 but again you can always look it

1428
01:07:10,520 --> 01:07:14,420
up I like my giggles so what we actually

1429
01:07:14,420 --> 01:07:17,120
see here is a kickin it looks kind of

1430
01:07:17,120 --> 01:07:18,890
weird and we're gonna see why it looks

1431
01:07:18,890 --> 01:07:21,980
weird but I said big a is 41 if we look

1432
01:07:21,980 --> 01:07:24,950
at it before we continued so up here we

1433
01:07:24,950 --> 01:07:28,430
have what things were and now we have

1434
01:07:28,430 --> 01:07:31,070
what things are after the string copy

1435
01:07:31,070 --> 01:07:32,660
and we can compare them but we said it's

1436
01:07:32,660 --> 01:07:36,560
41 so here's one 41 here like at the

1437
01:07:36,560 --> 01:07:40,310
first byte of this one which seems kind

1438
01:07:40,310 --> 01:07:46,190
of strange and then with this one it's

1439
01:07:46,190 --> 01:07:48,740
the last three bytes and then we have 0

1440
01:07:48,740 --> 01:07:51,080
0 which that's our null byte that we

1441
01:07:51,080 --> 01:07:54,050
talked about terminating the string so

1442
01:07:54,050 --> 01:07:56,810
it looks like we did get our 4 A's and

1443
01:07:56,810 --> 01:07:59,000
in the terminating no like we expected

1444
01:07:59,000 --> 01:08:02,180
but they don't look like what we would

1445
01:08:02,180 --> 01:08:04,340
probably expect them to like why is this

1446
01:08:04,340 --> 01:08:06,650
over here like if it's gonna be over

1447
01:08:06,650 --> 01:08:09,320
here because it's 5 bytes instead of 4

1448
01:08:09,320 --> 01:08:11,540
with the null byte like why isn't it at

1449
01:08:11,540 --> 01:08:13,490
the end and why is the null at the

1450
01:08:13,490 --> 01:08:15,590
beginning this is so confusing your

1451
01:08:15,590 --> 01:08:17,450
computer science people why did you do

1452
01:08:17,450 --> 01:08:19,670
this all right some of you may know I

1453
01:08:19,670 --> 01:08:22,580
always harp on this because when I was

1454
01:08:22,580 --> 01:08:25,370
starting out in exploit development I

1455
01:08:25,370 --> 01:08:27,080
guess I was sleeping that day in

1456
01:08:27,080 --> 01:08:29,299
computer science class because I did not

1457
01:08:29,299 --> 01:08:31,670
remember this at all and it took a lot

1458
01:08:31,670 --> 01:08:33,020
of time for me to figure out why

1459
01:08:33,020 --> 01:08:35,540
everything was backwards

1460
01:08:35,540 --> 01:08:38,299
so but we'll talk about that in just a

1461
01:08:38,299 --> 01:08:41,510
second if we do continue you know may we

1462
01:08:41,510 --> 01:08:44,899
see that the return address is the same

1463
01:08:44,899 --> 01:08:47,240
as it was before the next instruction to

1464
01:08:47,240 --> 01:08:50,180
be executed in main and it's you know we

1465
01:08:50,180 --> 01:08:51,529
only gave it for a

1466
01:08:51,529 --> 01:08:53,538
we use the program as it should be used

1467
01:08:53,538 --> 01:08:57,139
so they do get copied into memory but

1468
01:08:57,139 --> 01:08:59,149
they don't get far enough to hit this

1469
01:08:59,149 --> 01:09:02,868
guy so that makes sense right

1470
01:09:02,868 --> 01:09:06,948
if I could spell continue alright simply

1471
01:09:06,948 --> 01:09:09,859
continue it says executed normally and

1472
01:09:09,859 --> 01:09:11,988
then the program exits everything

1473
01:09:11,988 --> 01:09:15,799
happens as it should so the first

1474
01:09:15,799 --> 01:09:19,788
question I want to answer is what

1475
01:09:19,788 --> 01:09:23,649
happens if we give it a ton of input and

1476
01:09:23,649 --> 01:09:25,849
then the second question I want to

1477
01:09:25,849 --> 01:09:27,679
answer is why is everything backwards

1478
01:09:27,679 --> 01:09:30,859
and then the third question would be how

1479
01:09:30,859 --> 01:09:33,770
do we turn this into like a working

1480
01:09:33,770 --> 01:09:35,809
exploit remember our goal is to make it

1481
01:09:35,809 --> 01:09:39,819
print out execution hijack to the screen

1482
01:09:39,819 --> 01:09:42,649
so some of you might be thinking well we

1483
01:09:42,649 --> 01:09:45,259
need to get the address of execution

1484
01:09:45,259 --> 01:09:48,288
hijacked here you're absolutely right

1485
01:09:48,288 --> 01:09:53,800
but how do we do that so first I want to

1486
01:09:53,800 --> 01:09:56,420
run remember run is how we run things

1487
01:09:56,420 --> 01:09:58,780
and just again give it a bunch of input

1488
01:09:58,780 --> 01:10:02,030
it's just as long as it's like a lot

1489
01:10:02,030 --> 01:10:03,619
it's not even that much

1490
01:10:03,619 --> 01:10:06,829
um and then see what happens

1491
01:10:06,829 --> 01:10:08,420
all right our breakpoints are still

1492
01:10:08,420 --> 01:10:10,579
gonna be set you can delete breakpoints

1493
01:10:10,579 --> 01:10:12,739
with delete if you don't want them

1494
01:10:12,739 --> 01:10:15,349
anymore but you know they're open for us

1495
01:10:15,349 --> 01:10:18,679
so we run hit our first breakpoint again

1496
01:10:18,679 --> 01:10:20,869
nothing interesting really happens in

1497
01:10:20,869 --> 01:10:24,760
main but one thing to take into account

1498
01:10:24,760 --> 01:10:30,110
remember in our last one the last byte

1499
01:10:30,110 --> 01:10:33,920
was 90 it's not anymore it's actually

1500
01:10:33,920 --> 01:10:36,800
moved in memory where the stack is you

1501
01:10:36,800 --> 01:10:38,449
know I said we turned off address space

1502
01:10:38,449 --> 01:10:40,039
layout randomization so you might be

1503
01:10:40,039 --> 01:10:42,079
saying like why is it moving in memory

1504
01:10:42,079 --> 01:10:45,679
I'm well where this stack goes has a lot

1505
01:10:45,679 --> 01:10:50,059
of like inputs to where it goes one of

1506
01:10:50,059 --> 01:10:51,800
them is actually the length of the other

1507
01:10:51,800 --> 01:10:53,840
function so when you remove it when

1508
01:10:53,840 --> 01:10:56,809
you're changing how long your input is

1509
01:10:56,809 --> 01:11:00,530
it will move the stack the location of

1510
01:11:00,530 --> 01:11:02,780
the stack does not matter it's again

1511
01:11:02,780 --> 01:11:04,780
it's just scratch space

1512
01:11:04,780 --> 01:11:06,039
now what we were interested this is a

1513
01:11:06,039 --> 01:11:08,289
memory address for the safe return

1514
01:11:08,289 --> 01:11:11,320
address and if we go up you know that we

1515
01:11:11,320 --> 01:11:13,239
don't want to move that's what we were

1516
01:11:13,239 --> 01:11:15,639
stopping with a SLR the program the code

1517
01:11:15,639 --> 01:11:17,590
for the program and the code for the

1518
01:11:17,590 --> 01:11:20,500
built-in functions they will not move

1519
01:11:20,500 --> 01:11:22,239
with address space layout randomization

1520
01:11:22,239 --> 01:11:25,090
turned off if it was on they would move

1521
01:11:25,090 --> 01:11:28,360
and we wouldn't be hard-coded dresses

1522
01:11:28,360 --> 01:11:30,969
and you know if you continue your

1523
01:11:30,969 --> 01:11:32,530
studies you will learn much about that

1524
01:11:32,530 --> 01:11:36,460
um but worth where the stack is doesn't

1525
01:11:36,460 --> 01:11:38,409
matter we're not returning to the stack

1526
01:11:38,409 --> 01:11:40,030
the stacks tit you can really just think

1527
01:11:40,030 --> 01:11:43,690
oh stack is junk mostly so it's not a

1528
01:11:43,690 --> 01:11:47,020
problem that it moved so alright let's

1529
01:11:47,020 --> 01:11:49,179
continue we hit our second breakpoint

1530
01:11:49,179 --> 01:11:52,000
and now again this is right before

1531
01:11:52,000 --> 01:11:55,360
string copy so you know everything

1532
01:11:55,360 --> 01:11:58,539
should be but notice what hasn't changed

1533
01:11:58,539 --> 01:12:00,699
you know I didn't say this up here but

1534
01:12:00,699 --> 01:12:06,309
like EBP and ESP so despite the fact

1535
01:12:06,309 --> 01:12:08,199
that it moved so this address over here

1536
01:12:08,199 --> 01:12:08,860
on the left

1537
01:12:08,860 --> 01:12:13,420
it moved it's different but the size of

1538
01:12:13,420 --> 01:12:15,699
the stack remember it was just you know

1539
01:12:15,699 --> 01:12:20,969
three sets of four right it's the same

1540
01:12:20,969 --> 01:12:24,159
as we see our EBP is it Oh eight minutes

1541
01:12:24,159 --> 01:12:29,230
and 78 here so the size of the stack

1542
01:12:29,230 --> 01:12:31,630
frame doesn't change just where it is

1543
01:12:31,630 --> 01:12:35,320
does that will come into play all right

1544
01:12:35,320 --> 01:12:39,460
so now we're in function and again it is

1545
01:12:39,460 --> 01:12:42,820
the same size as well it's obviously not

1546
01:12:42,820 --> 01:12:45,309
in the same place either because it's

1547
01:12:45,309 --> 01:12:47,340
just put right on top of both main and

1548
01:12:47,340 --> 01:12:49,510
this is where our address space layout

1549
01:12:49,510 --> 01:12:51,940
randomization being off would come into

1550
01:12:51,940 --> 01:12:54,670
play is that you see this address if we

1551
01:12:54,670 --> 01:12:56,829
look if you look back up on that's the

1552
01:12:56,829 --> 01:12:58,449
same address in main zero eight zero

1553
01:12:58,449 --> 01:13:01,539
four eight four four three

1554
01:13:01,539 --> 01:13:04,270
and so our return address is the same

1555
01:13:04,270 --> 01:13:09,099
and our size of our our frames are the

1556
01:13:09,099 --> 01:13:12,070
same so the only thing that's changed is

1557
01:13:12,070 --> 01:13:14,230
where it is a memory all good all right

1558
01:13:14,230 --> 01:13:16,780
so this is where things should get

1559
01:13:16,780 --> 01:13:18,310
interesting so if I can't in

1560
01:13:18,310 --> 01:13:21,760
and let that string copy happen remember

1561
01:13:21,760 --> 01:13:24,520
we gave it I guess I gave it 37 days I

1562
01:13:24,520 --> 01:13:26,860
didn't really count but I gave it a lot

1563
01:13:26,860 --> 01:13:29,830
of ACE and remember they like last time

1564
01:13:29,830 --> 01:13:33,310
they were like here and here they're

1565
01:13:33,310 --> 01:13:37,500
gonna like copy down the stack so

1566
01:13:37,500 --> 01:13:39,580
theoretically we're gonna overwrite this

1567
01:13:39,580 --> 01:13:42,340
and it's going to be all 41 continue

1568
01:13:42,340 --> 01:13:46,660
here we are at our third breakpoint and

1569
01:13:46,660 --> 01:13:49,810
if we again examine memory indeed indeed

1570
01:13:49,810 --> 01:13:53,220
indeed it looks exactly how I just said

1571
01:13:53,220 --> 01:13:58,750
so we have you know our 141 over here

1572
01:13:58,750 --> 01:14:00,130
all by his lonesome

1573
01:14:00,130 --> 01:14:03,760
we'll talk about that directly and we

1574
01:14:03,760 --> 01:14:05,200
have our forty ones

1575
01:14:05,200 --> 01:14:07,390
it just keeps copying a series if you

1576
01:14:07,390 --> 01:14:10,120
want just keep copy so really what the

1577
01:14:10,120 --> 01:14:12,670
problem is is that the stack grows up

1578
01:14:12,670 --> 01:14:16,780
but it writes down or the other way it

1579
01:14:16,780 --> 01:14:20,320
grows to lower memory but it writes to

1580
01:14:20,320 --> 01:14:22,240
higher memory so stuff so it's not just

1581
01:14:22,240 --> 01:14:24,370
gonna write into like future stack frame

1582
01:14:24,370 --> 01:14:26,500
junks that isn't allocated yet it's

1583
01:14:26,500 --> 01:14:28,060
gonna write into stuff that's already on

1584
01:14:28,060 --> 01:14:30,370
the stack and this can be disaster it

1585
01:14:30,370 --> 01:14:33,250
says we'll see so again I would love to

1586
01:14:33,250 --> 01:14:34,660
be in the room when someone decided

1587
01:14:34,660 --> 01:14:35,980
things should be upside-down and groove

1588
01:14:35,980 --> 01:14:38,680
towards each other but I wasn't so

1589
01:14:38,680 --> 01:14:41,320
that's that so I can just take for a

1590
01:14:41,320 --> 01:14:43,180
fact that that's what happens

1591
01:14:43,180 --> 01:14:45,610
um so remember we saw zero eight zero

1592
01:14:45,610 --> 01:14:48,220
four eight four four three as our return

1593
01:14:48,220 --> 01:14:50,860
address in Maine we in our last run

1594
01:14:50,860 --> 01:14:52,930
disassembled Maine and saw that was the

1595
01:14:52,930 --> 01:14:55,510
next instruction to be executed but now

1596
01:14:55,510 --> 01:15:00,550
that we've done our our store copy we

1597
01:15:00,550 --> 01:15:03,190
see that that has been overwritten by 40

1598
01:15:03,190 --> 01:15:07,630
ones so 41 41 41 41 I mean it's all hex

1599
01:15:07,630 --> 01:15:10,330
it could be I mean it could be a real

1600
01:15:10,330 --> 01:15:11,800
memory address but there's probably not

1601
01:15:11,800 --> 01:15:14,020
anything there and you'll also see you

1602
01:15:14,020 --> 01:15:15,670
know like I said it'll just keep writing

1603
01:15:15,670 --> 01:15:17,590
like it's corrupting main stack frame

1604
01:15:17,590 --> 01:15:20,980
now like it's just and then again the no

1605
01:15:20,980 --> 01:15:22,660
bytes over here at the end this doesn't

1606
01:15:22,660 --> 01:15:24,460
make any sense what's going on

1607
01:15:24,460 --> 01:15:29,080
everything is backwards so you know if

1608
01:15:29,080 --> 01:15:30,730
we let it continue what we should expect

1609
01:15:30,730 --> 01:15:31,340
is

1610
01:15:31,340 --> 01:15:33,739
it's going to try to execute whatever is

1611
01:15:33,739 --> 01:15:37,460
that memory address 41 41 41 41

1612
01:15:37,460 --> 01:15:40,460
there is nothing that says that you

1613
01:15:40,460 --> 01:15:42,619
can't put things there you may have

1614
01:15:42,619 --> 01:15:47,060
programs that do have 41 41 41 41 map to

1615
01:15:47,060 --> 01:15:50,090
an actual a piece of code and it would

1616
01:15:50,090 --> 01:15:53,030
execute somewhere randomly but as we'll

1617
01:15:53,030 --> 01:15:56,830
see in this case in most cases actually

1618
01:15:56,830 --> 01:16:00,050
it just gets confused it's like I don't

1619
01:16:00,050 --> 01:16:04,280
know what 41 41 41 41 is it's not in a

1620
01:16:04,280 --> 01:16:06,860
function I'm freaking out and I'm just

1621
01:16:06,860 --> 01:16:08,480
gonna die and give up

1622
01:16:08,480 --> 01:16:12,920
so yeah the program just stops so I mean

1623
01:16:12,920 --> 01:16:15,440
if this was like a web server and we

1624
01:16:15,440 --> 01:16:18,170
were bad hacker we didn't like them this

1625
01:16:18,170 --> 01:16:19,730
might be good you know we brought it

1626
01:16:19,730 --> 01:16:21,349
down they're not making any money right

1627
01:16:21,349 --> 01:16:23,300
now if they were like Amazon they'd be

1628
01:16:23,300 --> 01:16:25,550
losing like tons or revenue and like a

1629
01:16:25,550 --> 01:16:27,290
few minutes it takes to get it back up

1630
01:16:27,290 --> 01:16:31,610
I'm sure so I mean denial of service has

1631
01:16:31,610 --> 01:16:33,949
its uses definitely but again we want

1632
01:16:33,949 --> 01:16:35,630
code execution we want to take this a

1633
01:16:35,630 --> 01:16:37,400
little bit farther so just like writing

1634
01:16:37,400 --> 01:16:39,530
aids into it and making it crash it's

1635
01:16:39,530 --> 01:16:43,010
not good enough for us today so our goal

1636
01:16:43,010 --> 01:16:45,440
is gonna be to get something interesting

1637
01:16:45,440 --> 01:16:48,170
there that's not gonna make it crash you

1638
01:16:48,170 --> 01:16:50,420
might guess we want since we want it to

1639
01:16:50,420 --> 01:16:53,150
um for now execution hijacked and we

1640
01:16:53,150 --> 01:16:54,710
have a nice function that does that

1641
01:16:54,710 --> 01:16:57,409
called overflowed that currently never

1642
01:16:57,409 --> 01:16:58,520
gets cold

1643
01:16:58,520 --> 01:17:03,080
remember if we look at our code we have

1644
01:17:03,080 --> 01:17:05,480
that top function overflowed that just

1645
01:17:05,480 --> 01:17:07,250
prints out execution hijacked if you

1646
01:17:07,250 --> 01:17:10,940
were cold our goal is to make it call

1647
01:17:10,940 --> 01:17:12,739
that function and print execution

1648
01:17:12,739 --> 01:17:15,739
hijacked to the screen so you might

1649
01:17:15,739 --> 01:17:18,830
imagine that we would like to get the

1650
01:17:18,830 --> 01:17:20,659
memory address of overflowed in the

1651
01:17:20,659 --> 01:17:22,489
place of those for a ones and you would

1652
01:17:22,489 --> 01:17:26,540
be absolutely right but first question

1653
01:17:26,540 --> 01:17:28,760
that we have to solve is you know what

1654
01:17:28,760 --> 01:17:32,270
happens if we overflow it in seg faults

1655
01:17:32,270 --> 01:17:35,239
it's bad we killed the memory address of

1656
01:17:35,239 --> 01:17:37,099
the return address which is bad because

1657
01:17:37,099 --> 01:17:39,949
it made it fall but it's good because

1658
01:17:39,949 --> 01:17:42,349
now we can exploit it that's awesome but

1659
01:17:42,349 --> 01:17:44,270
I still answer this question about we've

1660
01:17:44,270 --> 01:17:45,190
got this one over

1661
01:17:45,190 --> 01:17:48,880
here the null byte is like great person

1662
01:17:48,880 --> 01:17:53,890
all right here by itself at the end it

1663
01:17:53,890 --> 01:17:56,590
doesn't seem to make any sense so again

1664
01:17:56,590 --> 01:17:59,170
I want to harp on this because it was

1665
01:17:59,170 --> 01:18:01,030
difficult for me and if you know you

1666
01:18:01,030 --> 01:18:03,460
already know this my apologies but you

1667
01:18:03,460 --> 01:18:06,100
know I like to make it so people don't

1668
01:18:06,100 --> 01:18:08,020
make the same mistakes I did

1669
01:18:08,020 --> 01:18:10,900
alright so I want to run it and I'm

1670
01:18:10,900 --> 01:18:12,969
gonna run it at this time you know all

1671
01:18:12,969 --> 01:18:15,280
our A's are all three ones right so I

1672
01:18:15,280 --> 01:18:18,940
want to actually do ABCD cuz one a will

1673
01:18:18,940 --> 01:18:21,219
be a 41 B will be a for you to see will

1674
01:18:21,219 --> 01:18:24,340
be a 43 D will be a 44 again ASCII table

1675
01:18:24,340 --> 01:18:28,330
comm there's actually even a man pay I

1676
01:18:28,330 --> 01:18:41,050
think it's man ASCII yeah so yeah you

1677
01:18:41,050 --> 01:18:43,210
have the Internet it's also actually if

1678
01:18:43,210 --> 01:18:45,340
you're not familiar with man pages man

1679
01:18:45,340 --> 01:18:48,250
is short for manual and built into your

1680
01:18:48,250 --> 01:18:51,100
Linux systems you have manual pages so

1681
01:18:51,100 --> 01:18:52,630
you can google things but you can also

1682
01:18:52,630 --> 01:18:54,760
in a lot of cases you know if you're

1683
01:18:54,760 --> 01:18:56,080
like at a government thing and don't

1684
01:18:56,080 --> 01:18:59,980
have any internet actually have manuals

1685
01:18:59,980 --> 01:19:03,010
built in for a lot of the built-in stuff

1686
01:19:03,010 --> 01:19:06,130
so this is so we're working so we think

1687
01:19:06,130 --> 01:19:09,070
I'm in the charts right we think you

1688
01:19:09,070 --> 01:19:14,110
know ABCD what-have-you but the computer

1689
01:19:14,110 --> 01:19:17,230
thinks in hex which is base 16 so you

1690
01:19:17,230 --> 01:19:20,770
know it's one to nine and then a b c d e

1691
01:19:20,770 --> 01:19:25,690
s and that comes out to be 16 well

1692
01:19:25,690 --> 01:19:28,870
there's also the zero yeah so you know

1693
01:19:28,870 --> 01:19:30,430
again if you took computer science at

1694
01:19:30,430 --> 01:19:32,410
all they probably made you learn this I

1695
01:19:32,410 --> 01:19:35,610
don't remember it at all so I use this

1696
01:19:35,610 --> 01:19:37,900
but you know there's I'll even also see

1697
01:19:37,900 --> 01:19:42,850
there's octal and decimal and heck are

1698
01:19:42,850 --> 01:19:45,820
is so you know big a hex representation

1699
01:19:45,820 --> 01:19:53,469
is 41 big be 42 c 43 teen 44 excuse me

1700
01:19:53,469 --> 01:19:56,620
you know post kovat coughing is like I'm

1701
01:19:56,620 --> 01:19:58,090
always afraid people are gonna kick me

1702
01:19:58,090 --> 01:19:58,960
out of me

1703
01:19:58,960 --> 01:20:01,030
Barn or something I never go anywhere

1704
01:20:01,030 --> 01:20:03,940
but you know I have a terrible allergies

1705
01:20:03,940 --> 01:20:06,790
just aside but I guess you guys are in

1706
01:20:06,790 --> 01:20:08,410
the room with me so you don't care all

1707
01:20:08,410 --> 01:20:10,660
right um so we quit the manual page with

1708
01:20:10,660 --> 01:20:13,630
Q that was again just a side note prove

1709
01:20:13,630 --> 01:20:16,150
that I'm not lying so let's run it with

1710
01:20:16,150 --> 01:20:18,880
ABCD and see what happens see if it can

1711
01:20:18,880 --> 01:20:21,010
help us get to the bottom of why is

1712
01:20:21,010 --> 01:20:25,719
everything weird and backwards um well

1713
01:20:25,719 --> 01:20:27,700
it still thinks it's running because it

1714
01:20:27,700 --> 01:20:30,130
crashed like it didn't finish so do you

1715
01:20:30,130 --> 01:20:31,510
want to start it from the beginning you

1716
01:20:31,510 --> 01:20:33,640
just say yes you know it's just how it

1717
01:20:33,640 --> 01:20:37,840
works and we can look at our memory of

1718
01:20:37,840 --> 01:20:42,370
Maine again it's moved but let's

1719
01:20:42,370 --> 01:20:44,650
continue and go I actually want to look

1720
01:20:44,650 --> 01:20:46,750
at our third breakpoint so we've already

1721
01:20:46,750 --> 01:20:48,580
done it with four characters we did a

1722
01:20:48,580 --> 01:20:51,580
AAA and we saw what happened we want to

1723
01:20:51,580 --> 01:20:53,739
see it with ABCD so I'll just go to the

1724
01:20:53,739 --> 01:20:55,960
third breakpoint and now I want to

1725
01:20:55,960 --> 01:21:03,040
examine them all right so we see things

1726
01:21:03,040 --> 01:21:06,610
are as they should be so again same size

1727
01:21:06,610 --> 01:21:09,100
the size it's not gonna change which is

1728
01:21:09,100 --> 01:21:11,469
going to be important and then here's

1729
01:21:11,469 --> 01:21:13,600
main here here's our return address

1730
01:21:13,600 --> 01:21:15,850
you're eight zero four eight four four

1731
01:21:15,850 --> 01:21:19,810
three and that's again not change that's

1732
01:21:19,810 --> 01:21:21,010
the memory address of the next

1733
01:21:21,010 --> 01:21:23,170
instruction in main because we only gave

1734
01:21:23,170 --> 01:21:25,239
it four characters this time it did not

1735
01:21:25,239 --> 01:21:27,250
get corrupted like last time last time

1736
01:21:27,250 --> 01:21:29,020
remember that turned into all four T

1737
01:21:29,020 --> 01:21:31,390
ones or the representation in hex of the

1738
01:21:31,390 --> 01:21:34,090
big eggs we overflowed the boundaries of

1739
01:21:34,090 --> 01:21:36,910
buffer and ended up overwriting the

1740
01:21:36,910 --> 01:21:40,030
strike all right but in this case we did

1741
01:21:40,030 --> 01:21:43,560
not we just gave it ABCD all right so

1742
01:21:43,560 --> 01:21:46,330
now we can kind of make more

1743
01:21:46,330 --> 01:21:47,770
understanding about what was going on

1744
01:21:47,770 --> 01:21:49,660
all right so we only gave it one a this

1745
01:21:49,660 --> 01:21:51,670
time so this is the first character that

1746
01:21:51,670 --> 01:21:54,340
we gave it so it's over here and it's

1747
01:21:54,340 --> 01:21:56,290
the first flight which you would think

1748
01:21:56,290 --> 01:21:58,330
it would be the last but it's the first

1749
01:21:58,330 --> 01:22:01,120
bite and then the B is the last bite of

1750
01:22:01,120 --> 01:22:04,120
the next one and there's this XI and

1751
01:22:04,120 --> 01:22:06,489
then there's the D and then there's the

1752
01:22:06,489 --> 01:22:09,700
null what on earth is going on

1753
01:22:09,700 --> 01:22:11,320
everything

1754
01:22:11,320 --> 01:22:15,010
all right so yeah everything we've just

1755
01:22:15,010 --> 01:22:17,800
done we'll just go through it all all

1756
01:22:17,800 --> 01:22:20,460
right here's what we want to talk about

1757
01:22:20,460 --> 01:22:21,850
all right

1758
01:22:21,850 --> 01:22:26,440
Indian Asst so you know it's not like

1759
01:22:26,440 --> 01:22:29,470
people from India it's uh you see you

1760
01:22:29,470 --> 01:22:31,540
know misspelled with E and E so it's

1761
01:22:31,540 --> 01:22:36,070
literally which end do you load first so

1762
01:22:36,070 --> 01:22:39,160
you can load like the first bite first

1763
01:22:39,160 --> 01:22:41,950
and the last bite first you know I have

1764
01:22:41,950 --> 01:22:44,200
a if you just look up Indian s and

1765
01:22:44,200 --> 01:22:47,350
Google you know I have one link down

1766
01:22:47,350 --> 01:22:49,180
here at the bottom to more information

1767
01:22:49,180 --> 01:22:52,510
this is again one of those things that

1768
01:22:52,510 --> 01:22:55,690
the powers that be decided how things

1769
01:22:55,690 --> 01:22:59,350
were gonna be so just a little side note

1770
01:22:59,350 --> 01:23:01,510
of trivia this is always the trivia

1771
01:23:01,510 --> 01:23:04,270
question that I asked so all of you if

1772
01:23:04,270 --> 01:23:05,950
you're ever like winning a door prize

1773
01:23:05,950 --> 01:23:08,140
and I have to do the question you'll

1774
01:23:08,140 --> 01:23:12,070
know the answer so we're we're this

1775
01:23:12,070 --> 01:23:14,620
Indian this came from is actually it's

1776
01:23:14,620 --> 01:23:17,740
from Gulliver's Travels the the book

1777
01:23:17,740 --> 01:23:20,680
well you imagine deliver travels in

1778
01:23:20,680 --> 01:23:22,330
Gulliver's Travels and indeed he does

1779
01:23:22,330 --> 01:23:25,180
and one of the places he goes to is

1780
01:23:25,180 --> 01:23:28,420
called Lilliput and they are in a war

1781
01:23:28,420 --> 01:23:31,150
with these other people and the war is

1782
01:23:31,150 --> 01:23:32,980
about which side of the egg you should

1783
01:23:32,980 --> 01:23:36,810
crack like the little in Indian people

1784
01:23:36,810 --> 01:23:39,250
think you should crack the little end of

1785
01:23:39,250 --> 01:23:41,440
the egg and the big Indian people think

1786
01:23:41,440 --> 01:23:43,390
you should crack the big end which I

1787
01:23:43,390 --> 01:23:45,820
don't know that seems like a really

1788
01:23:45,820 --> 01:23:48,700
silly reason to be fighting but now in

1789
01:23:48,700 --> 01:23:51,480
computer science people do it too so

1790
01:23:51,480 --> 01:23:54,820
there are big Indian architectures big

1791
01:23:54,820 --> 01:23:57,280
endian architecture we wouldn't be

1792
01:23:57,280 --> 01:23:58,660
having this discussion because

1793
01:23:58,660 --> 01:24:01,660
everything would just look normal but a

1794
01:24:01,660 --> 01:24:04,360
lot of processors are little Indian

1795
01:24:04,360 --> 01:24:08,890
which is what our Intel is so that's why

1796
01:24:08,890 --> 01:24:11,050
everything is backwards is because it's

1797
01:24:11,050 --> 01:24:14,760
a taking the least-significant boy first

1798
01:24:14,760 --> 01:24:17,380
and the most basic alia everything's

1799
01:24:17,380 --> 01:24:20,080
backwards again here's a here's a link

1800
01:24:20,080 --> 01:24:22,600
there's tons a like theory about it and

1801
01:24:22,600 --> 01:24:24,909
but all you need to remember is

1802
01:24:24,909 --> 01:24:26,620
exploit developer what I'm doing a

1803
01:24:26,620 --> 01:24:29,199
little endian I need to slip my bytes

1804
01:24:29,199 --> 01:24:32,800
around and that seems to be what's

1805
01:24:32,800 --> 01:24:34,840
happening here that seems like a pretty

1806
01:24:34,840 --> 01:24:38,560
good explanation of what's going on so

1807
01:24:38,560 --> 01:24:46,090
we have our 41 by itself over here and

1808
01:24:46,090 --> 01:24:48,820
it's at the what seems to be the first

1809
01:24:48,820 --> 01:24:51,159
byte but if everything is backwards so

1810
01:24:51,159 --> 01:24:53,170
if we're taking if this is the beginning

1811
01:24:53,170 --> 01:24:55,060
we're loading the least significant byte

1812
01:24:55,060 --> 01:24:57,969
first then the 41 would become the end

1813
01:24:57,969 --> 01:25:00,340
the last thing loaded and that would

1814
01:25:00,340 --> 01:25:01,000
make sense

1815
01:25:01,000 --> 01:25:03,760
and then again so we start here at 42

1816
01:25:03,760 --> 01:25:07,630
load the 43 or the 44 don't like so

1817
01:25:07,630 --> 01:25:09,670
again there's a lot of theory we could

1818
01:25:09,670 --> 01:25:11,350
be here for a long time about it but as

1819
01:25:11,350 --> 01:25:13,659
an exploit developer lots of things

1820
01:25:13,659 --> 01:25:16,389
there little endian you have to flip

1821
01:25:16,389 --> 01:25:18,219
little endian backwards and we're not

1822
01:25:18,219 --> 01:25:20,110
doing it character by character right

1823
01:25:20,110 --> 01:25:22,090
it's not like one and then four we're

1824
01:25:22,090 --> 01:25:24,070
doing it by byte so these are so it

1825
01:25:24,070 --> 01:25:26,860
takes to hit hex digits to make a byte

1826
01:25:26,860 --> 01:25:29,739
so this is four bytes eight hex

1827
01:25:29,739 --> 01:25:34,170
characters so f4 is a byte EF is a byte

1828
01:25:34,170 --> 01:25:38,380
B 0 B is a byte 41 is in I it so we're

1829
01:25:38,380 --> 01:25:40,840
not it's not 14 we haven't taken our big

1830
01:25:40,840 --> 01:25:44,170
a and turned it into 14 it's still 41 so

1831
01:25:44,170 --> 01:25:45,489
we're flipping it around byte by byte

1832
01:25:45,489 --> 01:25:48,639
not character by character again I don't

1833
01:25:48,639 --> 01:25:50,409
know why they can't just talk base 10

1834
01:25:50,409 --> 01:25:52,900
like everybody else computers will do

1835
01:25:52,900 --> 01:25:53,739
what they will do

1836
01:25:53,739 --> 01:25:56,650
um so in that case it kind of makes

1837
01:25:56,650 --> 01:25:58,690
sense again it's probably like well why

1838
01:25:58,690 --> 01:26:02,350
and you know google it or look at that

1839
01:26:02,350 --> 01:26:05,320
link or you know remember your computer

1840
01:26:05,320 --> 01:26:06,699
science classes better than I do

1841
01:26:06,699 --> 01:26:09,219
um so that's why everything's backwards

1842
01:26:09,219 --> 01:26:11,920
it's just an architecture thing but

1843
01:26:11,920 --> 01:26:14,889
again if you remember your Gulliver's

1844
01:26:14,889 --> 01:26:17,860
Travels trivia that's always what I use

1845
01:26:17,860 --> 01:26:20,260
as a giveaway so if you ever see any of

1846
01:26:20,260 --> 01:26:22,350
my talks and they're doing giveaways um

1847
01:26:22,350 --> 01:26:24,900
come get your book or whatever um

1848
01:26:24,900 --> 01:26:30,010
alright so our next goal should be so we

1849
01:26:30,010 --> 01:26:32,320
said we had three goals we wanted to see

1850
01:26:32,320 --> 01:26:34,330
what happened if again we overflowed it

1851
01:26:34,330 --> 01:26:36,550
we saw we crashed it we denial of

1852
01:26:36,550 --> 01:26:39,390
service that we turned our zero

1853
01:26:39,390 --> 01:26:44,800
8:04 8 4 4 3 into 41 41 41 41 so we can

1854
01:26:44,800 --> 01:26:46,530
get control of that return address

1855
01:26:46,530 --> 01:26:47,710
awesome

1856
01:26:47,710 --> 01:26:49,870
our next question was why is everything

1857
01:26:49,870 --> 01:26:52,090
backwards and we'd at least a little bit

1858
01:26:52,090 --> 01:26:55,000
explains it right because they say so

1859
01:26:55,000 --> 01:26:59,170
just turn everything backwards so that's

1860
01:26:59,170 --> 01:27:02,320
good so our third thing that we wanted

1861
01:27:02,320 --> 01:27:07,420
to solve was actually turning that into

1862
01:27:07,420 --> 01:27:13,690
instead of a crash a execution hijacked

1863
01:27:13,690 --> 01:27:15,280
being printed out to the screen with

1864
01:27:15,280 --> 01:27:19,990
that overflowed function so maybe we can

1865
01:27:19,990 --> 01:27:25,750
do that I mean in a lot of cases and you

1866
01:27:25,750 --> 01:27:27,610
know everything's really small here this

1867
01:27:27,610 --> 01:27:29,800
is a really simple program so you know

1868
01:27:29,800 --> 01:27:31,720
probably in most cases you're not gonna

1869
01:27:31,720 --> 01:27:33,910
be able to count but in this case you

1870
01:27:33,910 --> 01:27:35,800
could I mean it's like alright so we

1871
01:27:35,800 --> 01:27:37,480
gave it four bytes right so it's like

1872
01:27:37,480 --> 01:27:41,430
one two three four the null byte so five

1873
01:27:41,430 --> 01:27:50,140
six seven eight nine and then the return

1874
01:27:50,140 --> 01:27:54,580
address so it looks like um we just need

1875
01:27:54,580 --> 01:27:57,460
like nine bytes of padding so right

1876
01:27:57,460 --> 01:28:12,130
we're starting here 1 2 3 4 5 6 7 7 8 9

1877
01:28:12,130 --> 01:28:15,580
and then I return address so remember

1878
01:28:15,580 --> 01:28:18,370
our stack frame sizes are not changing

1879
01:28:18,370 --> 01:28:20,260
where they are in memory this left hand

1880
01:28:20,260 --> 01:28:22,300
yeah that's going all over the place the

1881
01:28:22,300 --> 01:28:25,480
actual size of it is not so no matter

1882
01:28:25,480 --> 01:28:27,400
how many times we run it you know we're

1883
01:28:27,400 --> 01:28:28,660
still gonna have our first character

1884
01:28:28,660 --> 01:28:33,190
here 2 3 4 5 6 7 8 9 so it should this

1885
01:28:33,190 --> 01:28:35,650
be always no matter how many times we

1886
01:28:35,650 --> 01:28:38,350
run this there should be nine bytes of

1887
01:28:38,350 --> 01:28:41,200
space in this function stack frame

1888
01:28:41,200 --> 01:28:43,540
before we run up to the end of the stack

1889
01:28:43,540 --> 01:28:47,620
frame and hit this return address so to

1890
01:28:47,620 --> 01:28:50,680
prove this as we will I'm gonna run this

1891
01:28:50,680 --> 01:28:53,370
again

1892
01:28:53,570 --> 01:28:55,980
see this time I executed normally

1893
01:28:55,980 --> 01:28:57,960
because again we only gave it four bytes

1894
01:28:57,960 --> 01:29:00,150
we used it normally so I'm going to try

1895
01:29:00,150 --> 01:29:06,559
it again and I want to actually give it

1896
01:29:06,710 --> 01:29:10,470
9s and then four B's you can do this you

1897
01:29:10,470 --> 01:29:16,290
can also script inside of them like this

1898
01:29:16,290 --> 01:29:18,630
is a example you can script inside of

1899
01:29:18,630 --> 01:29:21,810
gdb so again because this is small we

1900
01:29:21,810 --> 01:29:25,410
could just write you know a nine times

1901
01:29:25,410 --> 01:29:31,470
um down here at the bottom so ignore the

1902
01:29:31,470 --> 01:29:33,630
slide for the fact that well not really

1903
01:29:33,630 --> 01:29:36,150
we're actually about to do it so we say

1904
01:29:36,150 --> 01:29:39,540
run and then you put the dollar sign and

1905
01:29:39,540 --> 01:29:41,970
then you can actually script inside of

1906
01:29:41,970 --> 01:29:44,790
it so clearly I was still in my pearl

1907
01:29:44,790 --> 01:29:49,560
day just um when I did this I used to

1908
01:29:49,560 --> 01:29:51,120
write a lot of Perl now I write Python

1909
01:29:51,120 --> 01:29:54,090
Python is awesome but you can script as

1910
01:29:54,090 --> 01:29:56,280
long as the Linux system knows the

1911
01:29:56,280 --> 01:29:58,260
programming language which most of them

1912
01:29:58,260 --> 01:30:00,240
come built-in and if your language of

1913
01:30:00,240 --> 01:30:02,870
choice doesn't you can just install it

1914
01:30:02,870 --> 01:30:08,390
you can actually script inside of it and

1915
01:30:08,930 --> 01:30:11,220
then yeah

1916
01:30:11,220 --> 01:30:14,760
but you can also not if you want to but

1917
01:30:14,760 --> 01:30:17,040
yeah this you know it just says Perl

1918
01:30:17,040 --> 01:30:22,850
execute print a in this case time 17 and

1919
01:30:22,850 --> 01:30:25,680
it's an X this is why I don't like pearl

1920
01:30:25,680 --> 01:30:28,440
gets an X and then instead of a plus

1921
01:30:28,440 --> 01:30:31,620
it's a dot and so it depends on your

1922
01:30:31,620 --> 01:30:33,510
programming language but again this time

1923
01:30:33,510 --> 01:30:38,720
it's so small it doesn't matter alright

1924
01:30:38,720 --> 01:30:43,320
so you know we could do run and let's do

1925
01:30:43,320 --> 01:30:47,040
it in Python so dollar sign open

1926
01:30:47,040 --> 01:30:51,410
parentheses and Python

1927
01:30:51,410 --> 01:30:53,790
- see like that's easy

1928
01:30:53,790 --> 01:30:59,730
Perl - see I'm pretty sure Python do I

1929
01:30:59,730 --> 01:31:02,180
have to put parentheses around that no

1930
01:31:02,180 --> 01:31:04,480
single quotes

1931
01:31:04,480 --> 01:31:08,290
bill is your friend I have joke that I

1932
01:31:08,290 --> 01:31:11,050
wrote my book so I should like look at

1933
01:31:11,050 --> 01:31:12,940
my own book to look up things that I

1934
01:31:12,940 --> 01:31:19,719
forgot again so we want print a times

1935
01:31:19,719 --> 01:31:22,239
because in Python time is it actually a

1936
01:31:22,239 --> 01:31:24,870
time symbol eight times nine and plus

1937
01:31:24,870 --> 01:31:27,250
goodness is all its programming language

1938
01:31:27,250 --> 01:31:29,890
specific if you don't want to do

1939
01:31:29,890 --> 01:31:31,530
programming languages you don't have to

1940
01:31:31,530 --> 01:31:35,350
but it comes in handy and then plus B

1941
01:31:35,350 --> 01:31:41,080
maybe times four times four and remember

1942
01:31:41,080 --> 01:31:44,770
that's because 32-bit architecture four

1943
01:31:44,770 --> 01:31:47,170
bytes so you know we've got eight

1944
01:31:47,170 --> 01:31:49,929
characters which is four bytes because

1945
01:31:49,929 --> 01:31:54,190
it's two bytes or two characters of hex

1946
01:31:54,190 --> 01:31:56,460
to make a bite now I'm confusing myself

1947
01:31:56,460 --> 01:32:01,179
but anyway so what should happen in this

1948
01:32:01,179 --> 01:32:02,949
case assuming I've gotten my syntax

1949
01:32:02,949 --> 01:32:05,380
right what's totally possible I haven't

1950
01:32:05,380 --> 01:32:12,219
is we should expect to see our 9a so 941

1951
01:32:12,219 --> 01:32:16,780
I'm filling up here here and then our

1952
01:32:16,780 --> 01:32:20,770
lonesome one over here but remember be

1953
01:32:20,770 --> 01:32:23,110
uppercase B we looked at that ASCII

1954
01:32:23,110 --> 01:32:27,850
table actually I still have it 42 is Big

1955
01:32:27,850 --> 01:32:31,260
B so what we should suspect to see is

1956
01:32:31,260 --> 01:32:34,780
our zero eight zero four eight four four

1957
01:32:34,780 --> 01:32:38,080
three that should actually turn into 42

1958
01:32:38,080 --> 01:32:41,550
42 42 42 that will allow us to pinpoint

1959
01:32:41,550 --> 01:32:45,699
the exact offset of our return address

1960
01:32:45,699 --> 01:32:48,280
as you become more comfortable with

1961
01:32:48,280 --> 01:32:50,410
exploit development you might skip this

1962
01:32:50,410 --> 01:32:53,110
step you know you might just you know

1963
01:32:53,110 --> 01:32:57,640
believe it was right um but you know one

1964
01:32:57,640 --> 01:33:00,460
we're learning into you know I've always

1965
01:33:00,460 --> 01:33:02,260
found that skipping steps generally it

1966
01:33:02,260 --> 01:33:03,610
leads to like something going wrong

1967
01:33:03,610 --> 01:33:06,969
later again you know it's up to you all

1968
01:33:06,969 --> 01:33:07,739
right

1969
01:33:07,739 --> 01:33:10,719
hopefully my syntax was correct

1970
01:33:10,719 --> 01:33:12,640
all right we've still got our our same

1971
01:33:12,640 --> 01:33:14,590
breakpoints again you can delete them

1972
01:33:14,590 --> 01:33:16,150
you know main is not very interesting

1973
01:33:16,150 --> 01:33:18,040
it's just there

1974
01:33:18,040 --> 01:33:19,870
and we can continue to our second

1975
01:33:19,870 --> 01:33:24,340
breakpoint and you know things look

1976
01:33:24,340 --> 01:33:24,790
normal

1977
01:33:24,790 --> 01:33:27,160
you know we're in function same old

1978
01:33:27,160 --> 01:33:30,460
story this is function stack frame this

1979
01:33:30,460 --> 01:33:33,010
is our return address yet again is your

1980
01:33:33,010 --> 01:33:34,840
eight zero four eight four four three

1981
01:33:34,840 --> 01:33:37,840
that is not changing every time we run

1982
01:33:37,840 --> 01:33:39,730
the program that's where it needs to go

1983
01:33:39,730 --> 01:33:41,410
next and then you know we have main

1984
01:33:41,410 --> 01:33:45,240
stack frame here so we've not done this

1985
01:33:45,240 --> 01:33:49,390
strcpy yet but we are about to and so if

1986
01:33:49,390 --> 01:33:51,040
we continue to our third breakpoint

1987
01:33:51,040 --> 01:33:53,110
again what we are expecting to see is

1988
01:33:53,110 --> 01:33:56,500
our loan 41 here these are all 41 SBA's

1989
01:33:56,500 --> 01:33:58,630
these will be all 40 ones and we should

1990
01:33:58,630 --> 01:34:03,400
expect we only gave it for 42 or Bigby

1991
01:34:03,400 --> 01:34:06,250
what we want to see is all those 40 twos

1992
01:34:06,250 --> 01:34:09,460
all four of them right there if there's

1993
01:34:09,460 --> 01:34:11,890
a 42 that dropped off and one of these

1994
01:34:11,890 --> 01:34:14,890
is a 41 we know our offset is wrong and

1995
01:34:14,890 --> 01:34:18,190
we need to adjust this might seem kind

1996
01:34:18,190 --> 01:34:19,810
of silly but you know there it's not

1997
01:34:19,810 --> 01:34:22,570
always gonna be 9 you'll look at ones

1998
01:34:22,570 --> 01:34:26,050
where you have to do like a times 1100

1999
01:34:26,050 --> 01:34:28,270
and in that case you can't really like

2000
01:34:28,270 --> 01:34:30,760
count the A's so you know in this case

2001
01:34:30,760 --> 01:34:32,200
it's real simple it's a good way to

2002
01:34:32,200 --> 01:34:34,870
start but these things get bigger you

2003
01:34:34,870 --> 01:34:36,310
won't just be able to look at memory and

2004
01:34:36,310 --> 01:34:38,950
count them like I don't think I could

2005
01:34:38,950 --> 01:34:42,310
anyway um so you know just take that

2006
01:34:42,310 --> 01:34:43,780
into account all right let's continue

2007
01:34:43,780 --> 01:34:48,130
and again see if I'm telling this all

2008
01:34:48,130 --> 01:34:50,290
right we hit breakpoint 3 which is right

2009
01:34:50,290 --> 01:34:58,230
after our called it a TR cpy we examine

2010
01:34:58,230 --> 01:35:01,030
all right things are looking good we've

2011
01:35:01,030 --> 01:35:02,920
got our one forty-one over here that's

2012
01:35:02,920 --> 01:35:07,180
our our first a we've got some more here

2013
01:35:07,180 --> 01:35:10,600
and some more here so our 9a is seem to

2014
01:35:10,600 --> 01:35:13,090
have done exactly what I was hoping

2015
01:35:13,090 --> 01:35:15,490
and then remember she it's the second

2016
01:35:15,490 --> 01:35:17,350
line on the right where it's always been

2017
01:35:17,350 --> 01:35:20,950
that was our return address now our

2018
01:35:20,950 --> 01:35:26,260
return address 42 42 42 42 so that looks

2019
01:35:26,260 --> 01:35:28,090
good right again we only gave it four

2020
01:35:28,090 --> 01:35:30,580
B's if those bees are there then our

2021
01:35:30,580 --> 01:35:31,630
offset is right

2022
01:35:31,630 --> 01:35:35,110
so that looks perfect perfect all right

2023
01:35:35,110 --> 01:35:40,000
so now we have what we need there but

2024
01:35:40,000 --> 01:35:43,420
again if we just let it continue we'd

2025
01:35:43,420 --> 01:35:45,370
get the same result as we did with the

2026
01:35:45,370 --> 01:35:48,220
A's no it doesn't that's not mapped you

2027
01:35:48,220 --> 01:35:50,200
know it's not mapped in memory so it

2028
01:35:50,200 --> 01:35:51,910
doesn't there's not any code there for

2029
01:35:51,910 --> 01:35:53,890
to run so it gets confused and it gives

2030
01:35:53,890 --> 01:35:58,080
up so we need to change that into

2031
01:35:58,080 --> 01:36:01,620
something more useful so remember we

2032
01:36:01,620 --> 01:36:06,940
disassembled name just ask aha remember

2033
01:36:06,940 --> 01:36:09,130
we did this when we were trying to see

2034
01:36:09,130 --> 01:36:10,960
you know was that the return address

2035
01:36:10,960 --> 01:36:12,790
when we saw your things are called a

2036
01:36:12,790 --> 01:36:16,660
function and the next instruction after

2037
01:36:16,660 --> 01:36:19,390
that it's memory address remember our

2038
01:36:19,390 --> 01:36:22,060
our safe return address that's our

2039
01:36:22,060 --> 01:36:23,620
memory address it's not actually gonna

2040
01:36:23,620 --> 01:36:27,430
be like uh move it whatever it's gonna

2041
01:36:27,430 --> 01:36:30,250
be the memory address and we saw that

2042
01:36:30,250 --> 01:36:32,470
over and over again you can probably say

2043
01:36:32,470 --> 01:36:34,210
it with your eyes closed now right zero

2044
01:36:34,210 --> 01:36:36,150
eight zero four eight four four three

2045
01:36:36,150 --> 01:36:39,940
right yeah okay because again that's not

2046
01:36:39,940 --> 01:36:42,070
changing so you know that's our memory

2047
01:36:42,070 --> 01:36:45,400
address that it should go to but we want

2048
01:36:45,400 --> 01:36:47,920
to send it somewhere else and you know

2049
01:36:47,920 --> 01:36:49,570
as you do more with this you know you

2050
01:36:49,570 --> 01:36:52,690
might unfortunately I've never done to

2051
01:36:52,690 --> 01:36:56,500
our class before like the next the next

2052
01:36:56,500 --> 01:37:00,010
exercise you actually like put shellcode

2053
01:37:00,010 --> 01:37:01,920
if you've not heard of shellcode it's

2054
01:37:01,920 --> 01:37:04,660
basically adding your own code into

2055
01:37:04,660 --> 01:37:08,320
memory and then you send execution to

2056
01:37:08,320 --> 01:37:09,970
the beginning of your shellcode and make

2057
01:37:09,970 --> 01:37:13,530
it execute so it might open up a shell

2058
01:37:13,530 --> 01:37:16,000
and call back to your attacker machine

2059
01:37:16,000 --> 01:37:18,340
it might open calculator it might you

2060
01:37:18,340 --> 01:37:21,520
know do whatever it wants but in this

2061
01:37:21,520 --> 01:37:25,420
case and you know that certainly um data

2062
01:37:25,420 --> 01:37:27,130
execution prevention which we didn't

2063
01:37:27,130 --> 01:37:28,660
really talk about at all

2064
01:37:28,660 --> 01:37:32,050
it's another anti exploitation technique

2065
01:37:32,050 --> 01:37:32,980
um

2066
01:37:32,980 --> 01:37:35,800
it says people should not be executing

2067
01:37:35,800 --> 01:37:38,170
off the stack so we should not be able

2068
01:37:38,170 --> 01:37:40,720
to just put our own stuff like our own

2069
01:37:40,720 --> 01:37:43,210
shell code instead of A's like we would

2070
01:37:43,210 --> 01:37:44,739
put like a ton of

2071
01:37:44,739 --> 01:37:46,690
characters that were hex characters to

2072
01:37:46,690 --> 01:37:49,449
actually execute code you should not be

2073
01:37:49,449 --> 01:37:51,219
executing off the stack the stack is

2074
01:37:51,219 --> 01:37:52,510
scratch space so it should not be

2075
01:37:52,510 --> 01:37:54,730
executable so data execution prevention

2076
01:37:54,730 --> 01:37:58,150
makes the stack non-executable and makes

2077
01:37:58,150 --> 01:38:00,039
you know just putting shellcode in on

2078
01:38:00,039 --> 01:38:02,289
our stack and executing it not work

2079
01:38:02,289 --> 01:38:02,739
anymore

2080
01:38:02,739 --> 01:38:09,909
um so I'm gonna say so things like this

2081
01:38:09,909 --> 01:38:12,730
where we can find other code I mean in

2082
01:38:12,730 --> 01:38:14,230
this case again it just prints out

2083
01:38:14,230 --> 01:38:16,539
execution hijacked it's not that serious

2084
01:38:16,539 --> 01:38:18,940
but I mean you might be able to find

2085
01:38:18,940 --> 01:38:21,760
code or pieces of code that you can put

2086
01:38:21,760 --> 01:38:26,249
together to make it do what you want

2087
01:38:26,249 --> 01:38:31,050
which is a silly explanation but

2088
01:38:31,050 --> 01:38:33,909
basically what I'm saying is that while

2089
01:38:33,909 --> 01:38:36,489
this example is easy and contrived it's

2090
01:38:36,489 --> 01:38:38,889
not it's not really that contrived

2091
01:38:38,889 --> 01:38:43,420
because it just could be something that

2092
01:38:43,420 --> 01:38:46,119
you do um with especially with you know

2093
01:38:46,119 --> 01:38:48,190
our most modern platforms like with the

2094
01:38:48,190 --> 01:38:50,139
iPhone where everything has to be like

2095
01:38:50,139 --> 01:38:53,409
signed it's uh you know being able to

2096
01:38:53,409 --> 01:38:55,090
you know look through memory and find

2097
01:38:55,090 --> 01:38:57,460
code that you want that is executable

2098
01:38:57,460 --> 01:38:59,730
because this is all that code that it

2099
01:38:59,730 --> 01:39:02,530
its executable obviously it's being

2100
01:39:02,530 --> 01:39:03,280
executed

2101
01:39:03,280 --> 01:39:07,869
um is definitely a good thing so yes we

2102
01:39:07,869 --> 01:39:10,480
are I just put a we'll say a debugging

2103
01:39:10,480 --> 01:39:13,059
function that does what we want I didn't

2104
01:39:13,059 --> 01:39:15,190
take it out I didn't comment it out if

2105
01:39:15,190 --> 01:39:17,559
you're not familiar with comments so you

2106
01:39:17,559 --> 01:39:19,360
know you should comment your code unlike

2107
01:39:19,360 --> 01:39:21,909
me um different programming languages

2108
01:39:21,909 --> 01:39:23,650
have different symbols for it but if I

2109
01:39:23,650 --> 01:39:26,289
commented the code out it would just

2110
01:39:26,289 --> 01:39:29,739
become like extra information and it

2111
01:39:29,739 --> 01:39:32,530
would not be you know compiled as code

2112
01:39:32,530 --> 01:39:34,780
and sitting in memory but because you

2113
01:39:34,780 --> 01:39:36,909
know I left that in there it actually it

2114
01:39:36,909 --> 01:39:40,679
does compile and it is in memory so

2115
01:39:40,679 --> 01:39:43,989
overflowed exists so we'll sit say it's

2116
01:39:43,989 --> 01:39:45,730
like debugging code say it's like a back

2117
01:39:45,730 --> 01:39:47,710
door that they left in there and it

2118
01:39:47,710 --> 01:39:51,309
happens believe me so that's that all

2119
01:39:51,309 --> 01:39:52,449
right so that's our goal we want

2120
01:39:52,449 --> 01:39:54,400
overflow to run so just like we

2121
01:39:54,400 --> 01:39:56,469
disassembled man right why don't we this

2122
01:39:56,469 --> 01:39:57,979
is simple over

2123
01:39:57,979 --> 01:40:01,369
see what happened all right so here's

2124
01:40:01,369 --> 01:40:04,789
overflowed so if I want to send

2125
01:40:04,789 --> 01:40:09,320
execution to overflowed my guess would

2126
01:40:09,320 --> 01:40:12,289
be the best thing to do would be to send

2127
01:40:12,289 --> 01:40:14,840
it send execution to the beginning of

2128
01:40:14,840 --> 01:40:16,880
overflowed and let it run so instead of

2129
01:40:16,880 --> 01:40:21,170
you know sending it 42 and crashing it

2130
01:40:21,170 --> 01:40:23,809
as we did and we crashed it

2131
01:40:23,809 --> 01:40:27,559
what's our 42 s if we send it a valid

2132
01:40:27,559 --> 01:40:30,079
memory address so this is where the code

2133
01:40:30,079 --> 01:40:32,630
is so it's valid it's executable it's

2134
01:40:32,630 --> 01:40:36,559
for real and then we should instead of

2135
01:40:36,559 --> 01:40:38,749
just crashing it make execution go where

2136
01:40:38,749 --> 01:40:43,459
we want it to so well running out of

2137
01:40:43,459 --> 01:40:46,579
time - so this should work out well all

2138
01:40:46,579 --> 01:40:48,789
right so again I love the up arrow

2139
01:40:48,789 --> 01:40:51,320
alright so I go up to my original run

2140
01:40:51,320 --> 01:40:53,449
again I did my name Python the slides

2141
01:40:53,449 --> 01:40:55,369
are in Perl the I'm pretty sure the

2142
01:40:55,369 --> 01:40:59,329
books in Perl - I was deleted Python is

2143
01:40:59,329 --> 01:41:02,900
much better so instead of our B times 4

2144
01:41:02,900 --> 01:41:05,749
this is why I mentioned being able to do

2145
01:41:05,749 --> 01:41:09,559
it with scripting because no sure we

2146
01:41:09,559 --> 01:41:12,499
could have did a a nine times and me

2147
01:41:12,499 --> 01:41:13,940
times four I mean one of the reasons is

2148
01:41:13,940 --> 01:41:17,659
you're not gonna print out a 1,100 times

2149
01:41:17,659 --> 01:41:21,380
um but in addition to that you know this

2150
01:41:21,380 --> 01:41:23,539
is a memory address so you know if I

2151
01:41:23,539 --> 01:41:28,550
type in 0 8 0 4 8 3 f4 it'll see each of

2152
01:41:28,550 --> 01:41:30,739
those as a character and we want it to

2153
01:41:30,739 --> 01:41:34,909
see it as text so you know most of them

2154
01:41:34,909 --> 01:41:37,880
are probably unprintable anyway so you

2155
01:41:37,880 --> 01:41:40,249
know our goal would probably be to use a

2156
01:41:40,249 --> 01:41:42,440
programming language is that point so

2157
01:41:42,440 --> 01:41:44,959
I'm gonna take out my B times 4 because

2158
01:41:44,959 --> 01:41:48,229
I don't want to go to 42 42 42 42

2159
01:41:48,229 --> 01:41:52,610
anymore I want to go to 0 8 0 4 8 3 F 4

2160
01:41:52,610 --> 01:41:56,389
and again the syntax may change based on

2161
01:41:56,389 --> 01:41:57,979
your programming language so if you're

2162
01:41:57,979 --> 01:41:59,510
using a different one when you play with

2163
01:41:59,510 --> 01:42:01,849
this later you know it might be a little

2164
01:42:01,849 --> 01:42:05,570
different but for me on my Python I'm

2165
01:42:05,570 --> 01:42:07,550
gonna open my string and it's backslash

2166
01:42:07,550 --> 01:42:10,519
X and that tells it it's a hex bite so

2167
01:42:10,519 --> 01:42:11,240
I'm going to go

2168
01:42:11,240 --> 01:42:14,060
you're a Max's it remember two digits

2169
01:42:14,060 --> 01:42:18,080
for a hex buy it so your age backslash X

2170
01:42:18,080 --> 01:42:23,810
0 4 8 8 3 and if you see what I did

2171
01:42:23,810 --> 01:42:28,250
wrong you're smart and then f4 and then

2172
01:42:28,250 --> 01:42:29,660
closes my string I always forget to

2173
01:42:29,660 --> 01:42:31,280
close my string so I have my string

2174
01:42:31,280 --> 01:42:33,560
close and I have my my single closed

2175
01:42:33,560 --> 01:42:37,160
closed as well so this should tell it

2176
01:42:37,160 --> 01:42:39,650
instead of 4 we used to put our four hex

2177
01:42:39,650 --> 01:42:44,120
bytes there 0 8 0 4 8 3 F 4 so if

2178
01:42:44,120 --> 01:42:47,060
everything goes as planned then this

2179
01:42:47,060 --> 01:42:50,420
should instead of crashing or printing

2180
01:42:50,420 --> 01:42:53,720
out executed normally it should print

2181
01:42:53,720 --> 01:42:56,930
out execution hijacked so let's see what

2182
01:42:56,930 --> 01:43:00,890
happens again cuz it crashed you want to

2183
01:43:00,890 --> 01:43:02,570
start at the beginning yes I do

2184
01:43:02,570 --> 01:43:06,980
and then we let's just continue through

2185
01:43:06,980 --> 01:43:15,620
I guess I hit continued twice all right

2186
01:43:15,620 --> 01:43:18,620
now let's look at all right so you know

2187
01:43:18,620 --> 01:43:21,320
as per usual memory addresses god knows

2188
01:43:21,320 --> 01:43:24,800
what but this is our stack frame for

2189
01:43:24,800 --> 01:43:27,920
function this is our return address and

2190
01:43:27,920 --> 01:43:31,130
this is our stack frame for me all right

2191
01:43:31,130 --> 01:43:33,110
so our aides are still looking good

2192
01:43:33,110 --> 01:43:38,510
where they were age age all right and

2193
01:43:38,510 --> 01:43:42,650
then we have ok we have 0 we have F 4 8

2194
01:43:42,650 --> 01:43:47,630
3 0 4 0 8 does that matter is that how

2195
01:43:47,630 --> 01:43:49,460
it's supposed to be is this an Indian

2196
01:43:49,460 --> 01:43:51,890
this thing like it's backwards and it's

2197
01:43:51,890 --> 01:43:54,320
backwards by.bite right it's like it's

2198
01:43:54,320 --> 01:43:59,560
still 0 8 it's not 8 0 but 0 8 is at the

2199
01:43:59,560 --> 01:44:02,660
far side and then f4 is that what would

2200
01:44:02,660 --> 01:44:06,770
be the beginning so maybe a problem

2201
01:44:06,770 --> 01:44:09,260
let's see if it's a problem or not I

2202
01:44:09,260 --> 01:44:11,420
mean everything looks backwards so maybe

2203
01:44:11,420 --> 01:44:12,320
it's fine

2204
01:44:12,320 --> 01:44:18,710
oh dear we did not get execution

2205
01:44:18,710 --> 01:44:21,380
hijacked printed to the screen because

2206
01:44:21,380 --> 01:44:24,770
it tried to execute F 4 8 3 2 0 4

2207
01:44:24,770 --> 01:44:28,340
0-8 so remember how I said in

2208
01:44:28,340 --> 01:44:30,050
little-endian you just have to flip

2209
01:44:30,050 --> 01:44:32,140
everything backwards byte by byte

2210
01:44:32,140 --> 01:44:34,730
literally you can just like mindlessly

2211
01:44:34,730 --> 01:44:36,500
knowing nothing about Indianness

2212
01:44:36,500 --> 01:44:39,170
whatsoever you can just remember that if

2213
01:44:39,170 --> 01:44:41,930
I'm little Indian I need to flip things

2214
01:44:41,930 --> 01:44:43,970
around by my bite or if I see something

2215
01:44:43,970 --> 01:44:45,500
like this where things come out

2216
01:44:45,500 --> 01:44:46,790
backwards bye bye bye

2217
01:44:46,790 --> 01:44:48,500
oh it's an Indian assist you flip it

2218
01:44:48,500 --> 01:44:50,840
around again definitely if you're

2219
01:44:50,840 --> 01:44:52,670
interested is like look up the Siri it's

2220
01:44:52,670 --> 01:44:54,560
interesting but you know as an exploit

2221
01:44:54,560 --> 01:44:56,660
developer all you gotta remember is flip

2222
01:44:56,660 --> 01:44:58,990
it around bite bite bite so

2223
01:44:58,990 --> 01:45:01,790
theoretically that should be our last

2224
01:45:01,790 --> 01:45:04,130
problem and since we have eight minutes

2225
01:45:04,130 --> 01:45:07,010
then that's probably a good thing all

2226
01:45:07,010 --> 01:45:13,970
right so let's go back to our run script

2227
01:45:13,970 --> 01:45:16,040
and this time I want to flip it around

2228
01:45:16,040 --> 01:45:18,230
bite my bike not character by character

2229
01:45:18,230 --> 01:45:22,040
I don't want it to become like four f38

2230
01:45:22,040 --> 01:45:29,000
etc I just want f4 to be first eight

2231
01:45:29,000 --> 01:45:38,090
three zero four zero eight so all I did

2232
01:45:38,090 --> 01:45:40,430
was flip it around night by byte so if I

2233
01:45:40,430 --> 01:45:41,900
put it in backwards it'll come out

2234
01:45:41,900 --> 01:45:45,350
forwards again I don't know why they do

2235
01:45:45,350 --> 01:45:47,390
that and again this isn't gonna be

2236
01:45:47,390 --> 01:45:50,050
universal you may like MIPS systems I

2237
01:45:50,050 --> 01:45:54,410
probably not all big endian but a lot of

2238
01:45:54,410 --> 01:45:56,630
them are there are like things that are

2239
01:45:56,630 --> 01:45:58,010
big endian there are things that are a

2240
01:45:58,010 --> 01:45:58,820
little Indian

2241
01:45:58,820 --> 01:46:01,370
so don't universally assume everything

2242
01:46:01,370 --> 01:46:04,220
is backwards but probably will be for a

2243
01:46:04,220 --> 01:46:06,950
lot of things just something to keep in

2244
01:46:06,950 --> 01:46:08,750
mind you like when things aren't working

2245
01:46:08,750 --> 01:46:11,530
in they're backwards Oh Indian this yeah

2246
01:46:11,530 --> 01:46:13,640
again I had a lot of trouble with that

2247
01:46:13,640 --> 01:46:14,990
starting out so I didn't know what it

2248
01:46:14,990 --> 01:46:18,260
was and people laughed at me but they

2249
01:46:18,260 --> 01:46:21,830
won't laugh at you alright so again I'll

2250
01:46:21,830 --> 01:46:23,420
just continue through the first two

2251
01:46:23,420 --> 01:46:25,370
breakpoints I think we've got it by this

2252
01:46:25,370 --> 01:46:30,730
point and then examine our memory

2253
01:46:30,940 --> 01:46:34,850
alright this looks good alright we got

2254
01:46:34,850 --> 01:46:38,300
our first 41 or 40 ones here these are

2255
01:46:38,300 --> 01:46:43,760
see everything's still good and now 0 8

2256
01:46:43,760 --> 01:46:51,620
0 4 8 3 f 4 just to recall just a symbol

2257
01:46:51,620 --> 01:46:58,280
overflowed 0 8 0 4 8 3 f 4 so if it does

2258
01:46:58,280 --> 01:47:01,070
indeed what it says it's supposed to do

2259
01:47:01,070 --> 01:47:04,940
instead of going back to main as it's

2260
01:47:04,940 --> 01:47:06,950
supposed to and saying executed normally

2261
01:47:06,950 --> 01:47:10,070
and instead of crashing and saying

2262
01:47:10,070 --> 01:47:12,320
segmentation fault it should jump over

2263
01:47:12,320 --> 01:47:14,030
here at the beginning of overflowed and

2264
01:47:14,030 --> 01:47:16,880
execute it you know you know you don't

2265
01:47:16,880 --> 01:47:18,680
have to know assembly I mean it's pretty

2266
01:47:18,680 --> 01:47:22,940
simple it's puts outputs to the screen

2267
01:47:22,940 --> 01:47:26,210
so you know it's setting up his thing as

2268
01:47:26,210 --> 01:47:28,070
calling puts and then it's returning

2269
01:47:28,070 --> 01:47:29,270
it's real simple

2270
01:47:29,270 --> 01:47:32,330
so you just believe me on that one

2271
01:47:32,330 --> 01:47:35,150
because we have the source code so I'm

2272
01:47:35,150 --> 01:47:36,050
gonna truth

2273
01:47:36,050 --> 01:47:40,480
I think I have solved all the problems

2274
01:47:41,200 --> 01:47:47,270
continue execution hijack code execution

2275
01:47:47,270 --> 01:47:49,220
you will see that it did crash

2276
01:47:49,220 --> 01:47:53,660
afterwards um that's not always gonna be

2277
01:47:53,660 --> 01:47:55,940
the case but in a lot of cases it will

2278
01:47:55,940 --> 01:47:58,550
be like your shell will be running but

2279
01:47:58,550 --> 01:48:00,230
when you exit your shell the thing will

2280
01:48:00,230 --> 01:48:03,680
die I mean there are ways to clean that

2281
01:48:03,680 --> 01:48:06,320
up and and get things working but

2282
01:48:06,320 --> 01:48:08,870
certainly we can't do it in five minutes

2283
01:48:08,870 --> 01:48:11,180
and certainly it's not even worth doing

2284
01:48:11,180 --> 01:48:13,760
at this point so our goal we reach we

2285
01:48:13,760 --> 01:48:16,220
did execution hijacked right um

2286
01:48:16,220 --> 01:48:18,020
just think have a notepad on or

2287
01:48:18,020 --> 01:48:22,520
something alright text editor alright so

2288
01:48:22,520 --> 01:48:27,890
what did we do I want to make it bigger

2289
01:48:27,890 --> 01:48:34,250
as I can apparently um alright it was a

2290
01:48:34,250 --> 01:48:37,580
little alright alright so what we did

2291
01:48:37,580 --> 01:48:42,580
was grant program gnarly

2292
01:48:46,480 --> 01:48:53,950
the program abnormally spell normal and

2293
01:48:53,950 --> 01:48:58,000
I mean again fuzzing it's just sending

2294
01:48:58,000 --> 01:49:00,490
it a lot of input but you and you know

2295
01:49:00,490 --> 01:49:02,080
you can do reverse engineering if you're

2296
01:49:02,080 --> 01:49:04,210
into the assembly like you know pop it

2297
01:49:04,210 --> 01:49:06,490
into like I had a pro Free Edition or

2298
01:49:06,490 --> 01:49:09,400
anything like that just so simpler and

2299
01:49:09,400 --> 01:49:11,950
look for vulnerabilities look for you

2300
01:49:11,950 --> 01:49:14,410
know bounds not being checked things

2301
01:49:14,410 --> 01:49:17,620
like that but you can also think about

2302
01:49:17,620 --> 01:49:21,340
it like for instance I didn't know this

2303
01:49:21,340 --> 01:49:22,930
until I started doing exploit

2304
01:49:22,930 --> 01:49:24,730
development but did you know that like

2305
01:49:24,730 --> 01:49:26,890
the links in Windows the highest links

2306
01:49:26,890 --> 01:49:30,070
of file names this juror 55 I didn't

2307
01:49:30,070 --> 01:49:33,370
know that um so like if somebody is if

2308
01:49:33,370 --> 01:49:35,980
it's a file server like if it's FTP or T

2309
01:49:35,980 --> 01:49:38,200
FTP or anything that deals with files

2310
01:49:38,200 --> 01:49:42,610
like knowing that it can only be 255 by

2311
01:49:42,610 --> 01:49:44,110
its according to the operating system

2312
01:49:44,110 --> 01:49:48,610
but probably most programmers don't even

2313
01:49:48,610 --> 01:49:50,260
know that and if they're not checking

2314
01:49:50,260 --> 01:49:53,440
their bounds um then you know the

2315
01:49:53,440 --> 01:49:55,150
operating system is gonna say it can

2316
01:49:55,150 --> 01:49:58,000
only be this big and what if I sent it

2317
01:49:58,000 --> 01:50:03,460
like 1,100 bytes so yeah there's fuzzing

2318
01:50:03,460 --> 01:50:05,290
where you just can send it a bunch of

2319
01:50:05,290 --> 01:50:07,300
crap and see what happens you know you

2320
01:50:07,300 --> 01:50:10,030
can do reverse engineering and find what

2321
01:50:10,030 --> 01:50:11,920
you believe to be vulnerabilities in the

2322
01:50:11,920 --> 01:50:14,770
assembly or you know the third thing to

2323
01:50:14,770 --> 01:50:17,050
do is like think about like what it's

2324
01:50:17,050 --> 01:50:18,940
doing and where there might be problems

2325
01:50:18,940 --> 01:50:22,540
you know if you've run into similar

2326
01:50:22,540 --> 01:50:25,750
things that have had like an problem you

2327
01:50:25,750 --> 01:50:27,820
might want to check like other ones for

2328
01:50:27,820 --> 01:50:29,380
it you know if that makes any sense

2329
01:50:29,380 --> 01:50:32,140
so we ran the program abnormally we have

2330
01:50:32,140 --> 01:50:34,150
the source code in our case we have the

2331
01:50:34,150 --> 01:50:35,590
source code which makes it even easier

2332
01:50:35,590 --> 01:50:37,690
we don't have to do assembly we just

2333
01:50:37,690 --> 01:50:39,490
have to you know look through it and be

2334
01:50:39,490 --> 01:50:41,890
like Oh strcpy doesn't check bounced

2335
01:50:41,890 --> 01:50:43,840
look let's let's see what happens so

2336
01:50:43,840 --> 01:50:46,630
that gave us our idea to run the program

2337
01:50:46,630 --> 01:50:50,950
abnormally we did um check our offset

2338
01:50:50,950 --> 01:50:52,890
you know that was the A's and the B's

2339
01:50:52,890 --> 01:50:56,170
check the offsets I mean you can skip

2340
01:50:56,170 --> 01:50:58,930
those once you're confident you know

2341
01:50:58,930 --> 01:51:00,160
when we sent like the

2342
01:51:00,160 --> 01:51:03,610
nine eight times nine plus three times

2343
01:51:03,610 --> 01:51:05,950
four now all we did in that case was

2344
01:51:05,950 --> 01:51:08,490
verified that our offsets were right

2345
01:51:08,490 --> 01:51:11,680
again this is really small 8 times 9 and

2346
01:51:11,680 --> 01:51:15,160
B times 4 I do want to show you one

2347
01:51:15,160 --> 01:51:22,570
thing for that 4 stop so this is didn't

2348
01:51:22,570 --> 01:51:25,240
gets Metasploit um but if see this is

2349
01:51:25,240 --> 01:51:29,950
Cali but any way so in either share

2350
01:51:29,950 --> 01:51:34,150
Metasploit framework here's might be in

2351
01:51:34,150 --> 01:51:35,950
a different place you're not using Cali

2352
01:51:35,950 --> 01:51:41,190
um but this is like the coding stuff for

2353
01:51:41,190 --> 01:51:46,590
so if you go into think it's in scripts

2354
01:51:46,590 --> 01:51:51,520
might be in tools I'm crazy yeah it's

2355
01:51:51,520 --> 01:51:55,090
not scripts good some tools so it's a

2356
01:51:55,090 --> 01:51:58,960
Metasploit tool um pattern create you'll

2357
01:51:58,960 --> 01:52:01,600
see everything has dot RB Metasploit is

2358
01:52:01,600 --> 01:52:03,610
written in rubies for whatever reason

2359
01:52:03,610 --> 01:52:05,710
should have been python but nobody asked

2360
01:52:05,710 --> 01:52:06,400
my opinion

2361
01:52:06,400 --> 01:52:08,410
see what you can view because again this

2362
01:52:08,410 --> 01:52:10,600
is a times 9 so we could just count you

2363
01:52:10,600 --> 01:52:12,370
remember we did it we counted how far

2364
01:52:12,370 --> 01:52:14,650
away our return address was when it's

2365
01:52:14,650 --> 01:52:16,840
like 1100 that's not going to work

2366
01:52:16,840 --> 01:52:19,840
obviously so you could do pattern to

2367
01:52:19,840 --> 01:52:27,850
create and like 1100 Oh

2368
01:52:27,850 --> 01:52:30,190
dot RB ha you actually have to give it

2369
01:52:30,190 --> 01:52:33,940
the whole name and then it will create

2370
01:52:33,940 --> 01:52:36,010
this pattern I mean this isn't like the

2371
01:52:36,010 --> 01:52:37,900
only way to do it I mean I'm sure in

2372
01:52:37,900 --> 01:52:39,820
like the early days of exploitation it

2373
01:52:39,820 --> 01:52:44,890
would be like 550 a's and then 550 b's

2374
01:52:44,890 --> 01:52:46,360
and then you would just keep like

2375
01:52:46,360 --> 01:52:48,640
cutting it but this is a unique pattern

2376
01:52:48,640 --> 01:52:51,370
it's cyclic so you'd be able to tell

2377
01:52:51,370 --> 01:52:53,680
like you know based on what came out and

2378
01:52:53,680 --> 01:52:56,860
then you can use pattern offset which

2379
01:52:56,860 --> 01:53:01,900
you also see and then tell it give it

2380
01:53:01,900 --> 01:53:03,400
the four bytes that show up in your

2381
01:53:03,400 --> 01:53:06,490
return address when it crashes and it'll

2382
01:53:06,490 --> 01:53:08,410
tell you the offset so that'll allow you

2383
01:53:08,410 --> 01:53:10,470
to figure these out when they're longer

2384
01:53:10,470 --> 01:53:12,910
again I have all the write-ups and

2385
01:53:12,910 --> 01:53:14,000
everything for

2386
01:53:14,000 --> 01:53:17,270
the next exercise that uses that and

2387
01:53:17,270 --> 01:53:19,420
then you know we check to the offsets

2388
01:53:19,420 --> 01:53:26,120
down where we wanted to go overflowed

2389
01:53:26,120 --> 01:53:32,330
function in our case and then we took

2390
01:53:32,330 --> 01:53:46,520
Indian s into account and words and then

2391
01:53:46,520 --> 01:53:48,410
it works right and then it said

2392
01:53:48,410 --> 01:53:58,040
execution idea that's a joke it's funny

2393
01:53:58,040 --> 01:54:00,920
don't like three too much into it I

2394
01:54:00,920 --> 01:54:03,500
thought it is closed I closed the

2395
01:54:03,500 --> 01:54:05,989
message is stupid mag alright I just

2396
01:54:05,989 --> 01:54:11,480
ruined the video at the very end okay so

2397
01:54:11,480 --> 01:54:13,489
you know I say would give you contact

2398
01:54:13,489 --> 01:54:21,860
information a bulb security dot-com is

2399
01:54:21,860 --> 01:54:24,620
email if I don't ring you back email me

2400
01:54:24,620 --> 01:54:28,130
again I'm trying to do inbox zero now

2401
01:54:28,130 --> 01:54:31,430
sometimes I just don't um I mean you can

2402
01:54:31,430 --> 01:54:33,350
also find me on social media but I get

2403
01:54:33,350 --> 01:54:35,690
so many messages on there that like if

2404
01:54:35,690 --> 01:54:37,190
you write me on LinkedIn or Twitter or

2405
01:54:37,190 --> 01:54:38,690
something and you don't hear back for me

2406
01:54:38,690 --> 01:54:41,210
quickly please don't be offended I just

2407
01:54:41,210 --> 01:54:43,040
get so many messages the easiest way

2408
01:54:43,040 --> 01:54:46,880
honestly to get me is um email is that I

2409
01:54:46,880 --> 01:54:49,310
do try to make sure I answer everything

2410
01:54:49,310 --> 01:54:52,040
at least once a day so if you have any

2411
01:54:52,040 --> 01:54:54,680
questions and again um you will get vm's

2412
01:54:54,680 --> 01:54:56,840
you'll get the windows vm - you'll get

2413
01:54:56,840 --> 01:54:58,989
the slides android apps and everything

2414
01:54:58,989 --> 01:55:03,469
and you have info about - that nobody

2415
01:55:03,469 --> 01:55:07,460
else has so that's that um that's all we

2416
01:55:07,460 --> 01:55:09,980
got - today I appreciate you as this

2417
01:55:09,980 --> 01:55:13,130
time thank you all I'm not entirely sure

2418
01:55:13,130 --> 01:55:16,550
how to give this back thank you

2419
01:55:16,550 --> 01:55:18,350
Thank You Georgia really appreciate you

2420
01:55:18,350 --> 01:55:21,800
presenting I think this was a really

2421
01:55:21,800 --> 01:55:23,449
great starter class for everybody that's

2422
01:55:23,449 --> 01:55:27,020
looking into getting into doing pen

2423
01:55:27,020 --> 01:55:27,770
testing

2424
01:55:27,770 --> 01:55:30,260
and you really went into depth into a

2425
01:55:30,260 --> 01:55:31,760
lot of things that I think people are

2426
01:55:31,760 --> 01:55:35,410
trying to learn and get a handle on so

2427
01:55:35,410 --> 01:55:38,660
why did you all this stuff it messed me

2428
01:55:38,660 --> 01:55:43,400
up when I started yeah no doubt

2429
01:55:43,400 --> 01:55:45,500
so everybody that's in in this class

2430
01:55:45,500 --> 01:55:47,840
probably received an email from me last

2431
01:55:47,840 --> 01:55:51,140
night as a reminder I have the list of

2432
01:55:51,140 --> 01:55:53,870
everybody as soon as Georgia has

2433
01:55:53,870 --> 01:55:58,880
completed I will email you a link to

2434
01:55:58,880 --> 01:56:02,210
where you can obtain the VMS so watch

2435
01:56:02,210 --> 01:56:04,540
for that email in the next day or two

2436
01:56:04,540 --> 01:56:10,190
and thank you again for presenting thank

2437
01:56:10,190 --> 01:56:12,740
you and also Georgia just let you know

2438
01:56:12,740 --> 01:56:15,980
you're getting a huge slew of rounds of

2439
01:56:15,980 --> 01:56:17,690
applause from people in the discord

2440
01:56:17,690 --> 01:56:19,910
server so people are really happy with

2441
01:56:19,910 --> 01:56:23,330
it I appreciate it I you know I get some

2442
01:56:23,330 --> 01:56:24,740
people are like oh you didn't teach me

2443
01:56:24,740 --> 01:56:28,750
how to hack and I thought in two hours

2444
01:56:30,010 --> 01:56:32,810
like this will take now we do where we

2445
01:56:32,810 --> 01:56:35,360
do most of our Q&A through discord

2446
01:56:35,360 --> 01:56:37,580
you're welcome to join join the discord

2447
01:56:37,580 --> 01:56:39,050
server if you want to if you want to

2448
01:56:39,050 --> 01:56:41,240
chat with any of the people that were in

2449
01:56:41,240 --> 01:56:43,940
your class up to you I can email you the

2450
01:56:43,940 --> 01:56:48,230
link to it the fire the oven that'd be

2451
01:56:48,230 --> 01:56:52,100
great okay will do all right thank you

2452
01:56:52,100 --> 01:56:55,820
thank you thank you I think that's it

2453
01:56:55,820 --> 01:56:58,520
for the class we'll see everybody at the

2454
01:56:58,520 --> 01:57:00,880
next one

